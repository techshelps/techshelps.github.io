<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SQLColumns</title>
<link disabled rel=stylesheet href=msdn_ie3.css>
<style type="text/css">
@import url(msdn_ie4.css);
</style>
</HEAD>
<BODY>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->


<h1><a name="odbcsqlcolumns"></a>SQLColumns</h1>
<p class=label>
<b>Conformance</b></p>
<p>
Version Introduced:ODBC 1.0<br>
Standards Compliance:X/Open</p>
<p class=label>
<b>Summary</b></p>
<p>
<b>SQLColumns</b> returns the list of column names in specified tables. The driver returns this information as a result set on the specified <i>StatementHandle</i>.</p>
<p class=label>
<b>Syntax</b></p>
<p>
SQLRETURN <b>SQLColumns</b>(<br>
SQLHSTMT<i>StatementHandle</i>,<br>
SQLCHAR *<i>CatalogName</i>,<br>
SQLSMALLINT<i>NameLength1</i>,<br>
SQLCHAR *<i>SchemaName</i>,<br>
SQLSMALLINT<i>NameLength2</i>,<br>
SQLCHAR *<i>TableName</i>,<br>
SQLSMALLINT<i>NameLength3</i>,<br>
SQLCHAR *<i>ColumnName</i>,<br>
SQLSMALLINT<i>NameLength4</i>);</p>
<p class=label>
<b>Arguments</b></p>
<p class=dt>
<i>StatementHandle</i></p>
<p class=indent>
[Input]<br>
Statement handle.</p>
<p class=dt>
<i>CatalogName</i></p>
<p class=indent>
[Input]<br>
Catalog name. If a driver supports catalogs for some tables but not for others, such as when the driver retrieves data from different DBMSs, an empty string ("") denotes those tables that do not have catalogs. <i>CatalogName</i> cannot contain a string search pattern.</p>
<p class=tl>
If the SQL_ATTR_METADATA_ID statement attribute is set to SQL_TRUE, <i>CatalogName</i> is treated as an identifier, and its case is not significant. If it is SQL_FALSE, <i>CatalogName</i> is an ordinary argument; it is treated literally, and its case is significant. For more information, see “<a href="odch07pr_841f.htm">Arguments in Catalog Functions</a>” in Chapter 7, “Catalog Functions.”</P><p class=dt>
<i>NameLength1</i></p>
<p class=indent>
[Input]<br>
Length of *<i>CatalogName</i>.</p>
<p class=dt>
<i>SchemaName</i></p>
<p class=indent>
[Input]<br>
String search pattern for schema names. If a driver supports schemas for some tables but not for others, such as when the driver retrieves data from different DBMSs, an empty string ("") denotes those tables that do not have schemas.</p>
<p class=tl>
If the SQL_ATTR_METADATA_ID statement attribute is set to SQL_TRUE, <i>SchemaName</i> is treated as an identifier, and its case is not significant. If it is SQL_FALSE, <i>SchemaName</i> is a pattern value argument; it is treated literally, and its case is significant.</P><p class=dt>
<i>NameLength2</i></p>
<p class=indent>
[Input]<br>
Length of *<i>SchemaName</i>.</p>
<p class=dt>
<i>TableName</i></p>
<p class=indent>
[Input]<br>
String search pattern for table names.</p>
<p class=tl>
If the SQL_ATTR_METADATA_ID statement attribute is set to SQL_TRUE, <i>TableName</i> is treated as an identifier, and its case is not significant. If it is SQL_FALSE, <i>TableName</i> is a pattern value argument; it is treated literally, and its case is significant.</P><p class=dt>
<i>NameLength3</i></p>
<p class=indent>
[Input]<br>
Length of *<i>TableName</i>.</p>
<p class=dt>
<i>ColumnName</i></p>
<p class=indent>
[Input]<br>
String search pattern for column names. </p>
<p class=tl>
If the SQL_ATTR_METADATA_ID statement attribute is set to SQL_TRUE, <i>ColumnName</i> is treated as an identifier, and its case is not significant. If it is SQL_FALSE, <i>ColumnName</i> is a pattern value argument; it is treated literally, and its case is significant.</P><p class=dt>
<i>NameLength4</i></p>
<p class=indent>
[Input]<br>
Length of *<i>ColumnName</i>.</p>
<p class=label>
<b>Returns</b></p>
<p>
SQL_SUCCESS, SQL_SUCCESS_WITH_INFO, SQL_STILL_EXECUTING, SQL_ERROR, or SQL_INVALID_HANDLE.</p>
<p class=label>
<b>Diagnostics</b></p>
<p>
When <b>SQLColumns</b> returns SQL_ERROR or SQL_SUCCESS_WITH_INFO, an associated SQLSTATE value may be obtained by calling <b>SQLGetDiagRec</b> with a <i>HandleType</i> of SQL_HANDLE_STMT and a <i>Handle</i> of <i>StatementHandle</i>. The following table lists the SQLSTATE values commonly returned by <b>SQLColumns</b> and explains each one in the context of this function; the notation “(DM)” precedes the descriptions of SQLSTATEs returned by the Driver Manager. The return code associated with each SQLSTATE value is SQL_ERROR, unless noted otherwise.</p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows width=587>
<tr valign=top>
<td class=label width=22%><b>SQLSTATE</b></td>
<td class=label width=26%><b>Error</b></td>
<td class=label width=52%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=22%>01000</td>
<td width=26%>General warning</td>
<td width=52%>Driver-specific informational message. (Function returns SQL_SUCCESS_WITH_INFO.)</td>
</tr>
<tr valign=top>
<td width=22%>08S01</td>
<td width=26%>Communication link failure</td>
<td width=52%>The communication link between the driver and the data source to which the driver was connected failed before the function completed processing.</td>
</tr>
<tr valign=top>
<td width=22%>24000</td>
<td width=26%>Invalid cursor state</td>
<td width=52%>A cursor was open on the <i>StatementHandle</i> and <b>SQLFetch</b> or <b>SQLFetchScroll</b> had been called. This error is returned by the Driver Manager if <b>SQLFetch</b> or <b>SQLFetchScroll</b> has not returned SQL_NO_DATA, and is returned by the driver if <b>SQLFetch</b> or <b>SQLFetchScroll</b> has returned SQL_NO_DATA.<p>
A cursor was open on the <i>StatementHandle</i> but <b>SQLFetch</b> or <b>SQLFetchScroll</b> had not been called.</p>
</td>
</tr>
<tr valign=top>
<td width=22%>40001</td>
<td width=26%>Serialization failure</td>
<td width=52%>The transaction was rolled back due to a resource deadlock with another transaction.</td>
</tr>
<tr valign=top>
<td width=22%>40003</td>
<td width=26%>Statement completion unknown</td>
<td width=52%>The associated connection failed during the execution of this function and the state of the transaction cannot be determined.</td>
</tr>
<tr valign=top>
<td width=22%>HY000</td>
<td width=26%>General error</td>
<td width=52%>An error occurred for which there was no specific SQLSTATE and for which no implementation-specific SQLSTATE was defined. The error message returned by <b>SQLGetDiagRec</b> in the <i>*MessageText</i> buffer describes the error and its cause.</td>
</tr>
<tr valign=top>
<td width=22%>HY001</td>
<td width=26%>Memory allocation error</td>
<td width=52%>The driver was unable to allocate memory required to support execution or completion of the function.</td>
</tr>
<tr valign=top>
<td width=22%>HY008</td>
<td width=26%>Operation canceled</td>
<td width=52%>Asynchronous processing was enabled for the <i>StatementHandle</i>. The function was called and before it completed execution, <b>SQLCancel</b> was called on the <i>StatementHandle</i>. Then the function was called again on the <i>StatementHandle</i>.<p>
The function was called and, before it completed execution, <b>SQLCancel</b> was called on the <i>StatementHandle</i> from a different thread in a multithread application.</p>
</td>
</tr>
<tr valign=top>
<td width=22%>HY009</td>
<td width=26%>Invalid use of null pointer</td>
<td width=52%>(DM) The SQL_ATTR_METADATA_ID statement attribute was set to SQL_TRUE, the <i>CatalogName</i> argument was a null pointer, and the SQL_CATALOG_NAME <i>InfoType</i> returns that catalog names are supported.<p>
(DM) The SQL_ATTR_METADATA_ID statement attribute was set to SQL_TRUE, and the <i>SchemaName</i>, <i>TableName</i>, or <i>ColumnName</i> argument was a null pointer.</p>
</td>
</tr>
<tr valign=top>
<td width=22%>HY010</td>
<td width=26%>Function sequence error</td>
<td width=52%>(DM) An asynchronously executing function (not this one) was called for the <i>StatementHandle</i> and was still executing when this function was called.<p>
(DM) <b>SQLExecute</b>, <b>SQLExecDirect</b>, <b>SQLBulkOperations</b>, or <b>SQLSetPos</b> was called for the <i>StatementHandle</i> and returned SQL_NEED_DATA. This function was called before data was sent for all data-at-execution parameters or columns.</p>
</td>
</tr>
<tr valign=top>
<td width=22%>HY013</td>
<td width=26%>Memory management error</td>
<td width=52%>The function call could not be processed because the underlying memory objects could not be accessed, possibly because of low memory conditions.</td>
</tr>
<tr valign=top>
<td width=22%>HY090</td>
<td width=26%>Invalid string or buffer length</td>
<td width=52%>(DM) The value of one of the name length arguments was less than 0, but not equal to SQL_NTS.</td>
</tr>
<tr valign=top>
<td width=22%></td>
<td width=26%></td>
<td width=52%>The value of one of the name length arguments exceeded the maximum length value for the corresponding catalog or name. The maximum length of each catalog or name may be obtained by calling <b>SQLGetInfo</b> with the <i>InfoType</i> values (see “Comments”).</td>
</tr>
<tr valign=top>
<td width=22%>HYC00</td>
<td width=26%>Optional feature not implemented</td>
<td width=52%>A catalog name was specified and the driver or data source does not support catalogs.<p>
A schema name was specified and the driver or data source does not support schemas.</p>
</td>
</tr>
<tr valign=top>
<td width=22%></td>
<td width=26%></td>
<td width=52%>A string search pattern was specified for the schema name, table name, or column name and the data source does not support search patterns for one or more of those arguments.<p>
The combination of the current settings of the SQL_ATTR_CONCURRENCY and SQL_ATTR_CURSOR_TYPE statement attributes was not supported by the driver or data source. </p>
<p>
The SQL_ATTR_USE_BOOKMARKS statement attribute was set to SQL_UB_VARIABLE, and the SQL_ATTR_CURSOR_TYPE statement attribute was set to a cursor type for which the driver does not support bookmarks.</p>
</td>
</tr>
<tr valign=top>
<td width=22%>HYT00</td>
<td width=26%>Timeout expired</td>
<td width=52%>The query timeout period expired before the data source returned the result set. The timeout period is set through <b>SQLSetStmtAttr</b>, SQL_ATTR_QUERY_TIMEOUT.</td>
</tr>
<tr valign=top>
<td width=22%>HYT01</td>
<td width=26%>Connection timeout expired</td>
<td width=52%>The connection timeout period expired before the data source responded to the request. The connection timeout period is set through <b>SQLSetConnectAttr</b>, SQL_ATTR_CONNECTION_TIMEOUT.</td>
</tr>
<tr valign=top>
<td width=22%>IM001</td>
<td width=26%>Driver does not support this function</td>
<td width=52%>(DM) The driver associated with the <i>StatementHandle</i> does not support the function.</td>
</tr>
</table><br>
<p class=label>
<b>Comments</b></p>
<p>
This function typically is used before statement execution to retrieve information about columns for a table or tables from the data source’s catalog. <b>SQLColumns</b> can be used to retrieve data for all types of items returned by <b>SQLTables</b>. In addition to base tables, this may include (but is not limited to) views, synonyms, system tables, and so on. Note by contrast, that the functions <b>SQLColAttribute</b> and <b>SQLDescribeCol</b> describe the columns in a result set and that the function <b>SQLNumResultCols</b> returns the number of columns in a result set. For more information, see “<a href="odch07pr_6o9t.htm">Uses of Catalog Data</a>” in Chapter 7, “Catalog Functions.”</p>
<p class=indent>
<B><b>Note</b></B> For more information about the general use, arguments, and returned data of ODBC catalog functions, see Chapter 7, "<a href="odch07pr_09rn.htm">Catalog Functions</a>.”</p>
<p>
<b>SQLColumns</b> returns the results as a standard result set, ordered by TABLE_CAT, TABLE_SCHEM, TABLE_NAME, and ORDINAL_POSITION. </p>
<p class=indent>
<B><b>Note</b></B> When an application works with an ODBC 2.<i>x</i> driver, no ORDINAL_POSITION column is returned in the result set. As a result, when working with ODBC 2.<i>x</i> drivers, the order of the columns in the column list returned by <b>SQLColumns</b> is not necessarily the same as the order of the columns returned when the application performs a SELECT statement on all columns in that table.</p>
<p class=indent>
<B><b>Note</b></B> <b>SQLColumns</b> might not return all columns. For example, a driver might not return information about pseudo-columns, such as Oracle ROWID. Applications can use any valid column, regardless of whether it is returned by <b>SQLColumns</b>. </p>
<p class=indent>
Some columns that can be returned by <b>SQLStatistics</b> are not returned by <b>SQLColumns</b>. For example, <b>SQLColumns</b> does not return the columns in an index created over an expression or filter, such as SALARY + BENEFITS or DEPT = 0012.</p>
<p>
The lengths of VARCHAR columns are not shown in the table; the actual lengths depend on the data source. To determine the actual lengths of the TABLE_CAT, TABLE_SCHEM, TABLE_NAME, and COLUMN_NAME columns, an application can call <b>SQLGetInfo</b> with the SQL_MAX_CATALOG_NAME_LEN, SQL_MAX_SCHEMA_NAME_LEN, SQL_MAX_TABLE_NAME_LEN, and SQL_MAX_COLUMN_NAME_LEN options.</p>
<p>
The following columns have been renamed for ODBC 3.x. The column name changes do not affect backward compatibility because applications bind by column number.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows width=587>
<tr valign=top>
<td class=label width=48%><b>ODBC 2.0 column</b></td>
<td class=label width=52%><b>ODBC 3.x column</b></td>
</tr>
<tr valign=top>
<td width=48%>TABLE_QUALIFIER</td>
<td width=52%>TABLE_CAT</td>
</tr>
<tr valign=top>
<td width=48%>TABLE_OWNER</td>
<td width=52%>TABLE_SCHEM</td>
</tr>
<tr valign=top>
<td width=48%>PRECISION</td>
<td width=52%>COLUMN_SIZE</td>
</tr>
<tr valign=top>
<td width=48%>LENGTH</td>
<td width=52%>BUFFER_LENGTH</td>
</tr>
<tr valign=top>
<td width=48%>SCALE</td>
<td width=52%>DECIMAL_DIGITS</td>
</tr>
<tr valign=top>
<td width=48%>RADIX</td>
<td width=52%>NUM_PREC_RADIX</td>
</tr>
</table><br>
<p>
The following columns have been added to the result set returned by <b>SQLColumns</b> for ODBC 3.x:</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows width=587>
<tr valign=top>
<td width=47%>CHAR_OCTET_LENGTH </td>
<td width=53%>ORDINAL_POSITION</td>
</tr>
<tr valign=top>
<td width=47%>COLUMN_DEF</td>
<td width=53%>SQL_DATA_TYPE</td>
</tr>
<tr valign=top>
<td width=47%>IS_NULLABLE </td>
<td width=53%>SQL_DATETIME_SUB</td>
</tr>
</table><br>
<p>
The following table lists the columns in the result set. Additional columns beyond column 18 (IS_NULLABLE) can be defined by the driver. An application should gain access to driver-specific columns by counting down from the end of the result set rather than specifying an explicit ordinal position. For more information, see “<a href="odch07pr_9g8j.htm">Data Returned by Catalog Functions</a>” in Chapter 7, “Catalog Functions.”</p>
<table border=1 cellpadding=5 cols=8 frame=below rules=rows width=587>
<tr valign=top>
<td class=label colspan=2 width=29%><b><br>
Column name</b></td>
<td class=label colspan=2 width=15%><b>Column number</b></td>
<td class=label colspan=2 width=16%><b><br>
Data type</b></td>
<td class=label colspan=2 width=40%><b><br>
Comments</b></td>
</tr>
<tr valign=top>
<td colspan=2 width=29%>TABLE_CAT<br>
(ODBC 1.0)</td>
<td colspan=2 width=15%>1</td>
<td colspan=2 width=16%>Varchar</td>
<td colspan=2 width=40%>Catalog name; NULL if not applicable to the data source. If a driver supports catalogs for some tables but not for others, such as when the driver retrieves data from different DBMSs, it returns an empty string ("") for those tables that do not have catalogs.</td>
</tr>
<tr valign=top>
<td colspan=2 width=29%>TABLE_SCHEM<br>
(ODBC 1.0)</td>
<td colspan=2 width=15%>2</td>
<td colspan=2 width=16%>Varchar </td>
<td colspan=2 width=40%>Schema name; NULL if not applicable to the data source. If a driver supports schemas for some tables but not for others, such as when the driver retrieves data from different DBMSs, it returns an empty string ("") for those tables that do not have schemas.</td>
</tr>
<tr valign=top>
<td colspan=2 width=29%>TABLE_NAME<br>
(ODBC 1.0)</td>
<td colspan=2 width=15%>3</td>
<td colspan=2 width=16%>Varchar not NULL</td>
<td colspan=2 width=40%>Table name.</td>
</tr>
<tr valign=top>
<td colspan=2 width=29%>COLUMN_NAME<br>
(ODBC 1.0)</td>
<td colspan=2 width=15%>4</td>
<td colspan=2 width=16%>Varchar not NULL</td>
<td colspan=2 width=40%>Column name. The driver returns an empty string for a column that does not have a name.</td>
</tr>
<tr valign=top>
<td colspan=2 width=29%>DATA_TYPE<br>
(ODBC 1.0)</td>
<td colspan=2 width=15%>5</td>
<td colspan=2 width=16%>Smallint not NULL</td>
<td colspan=2 width=40%>SQL data type. This can be an ODBC SQL data type or a driver-specific SQL data type. For datetime and interval data types, this column returns the concise data type (such as SQL_TYPE_DATE or SQL_INTERVAL_YEAR_TO_<br>
MONTH, rather than the non-concise data type such as SQL_DATETIME or SQL_INTERVAL). For a list of valid ODBC SQL data types, see “<a href="odappdpr_8fcj.htm">SQL Data Types</a>” in Appendix D, “Data Types.” For information about driver-specific SQL data types, see the driver’s documentation.</td>
</tr>
<tr valign=top>
<td colspan=2 width=29%>DATA_TYPE<br>
(ODBC 1.0) (<i>continued</i>)</td>
<td colspan=2 width=15%>5</td>
<td colspan=2 width=16%>Smallint not NULL</td>
<td colspan=2 width=40%>The data types returned for ODBC 3.<i>x</i> and ODBC 2.<i>x</i> applications may be different. For more information, see “<a href="odch17pr_0m1x.htm">Backward Compatibility and Standards Compliance</a>” in Chapter 17, “Programming Considerations.”</td>
</tr>
<tr valign=top>
<td colspan=2 width=29%>TYPE_NAME<br>
(ODBC 1.0)</td>
<td colspan=2 width=15%>6</td>
<td colspan=2 width=16%>Varchar not NULL</td>
<td colspan=2 width=40%>Data source&nbsp;–&nbsp;dependent data type name; for example, “CHAR”, “VARCHAR”, “MONEY”, “LONG VARBINAR”, or “CHAR ( ) FOR BIT DATA”.</td>
</tr>
<tr valign=top>
<td colspan=2 width=29%>COLUMN_SIZE<br>
(ODBC 1.0) </td>
<td colspan=2 width=15%>7</td>
<td colspan=2 width=16%>Integer</td>
<td colspan=2 width=40%>If DATA_TYPE is SQL_CHAR or SQL_VARCHAR, then this column contains the maximum length in characters of the column. For datetime data types, this is the total number of characters required to display the value when converted to characters. For numeric data types, this is either the total number of digits or the total number of bits allowed in the column, according to the NUM_PREC_RADIX column. For interval data types, this is the number of characters in the character representation of the interval literal (as defined by the interval leading precision, see “<a href="odappdpr_3qp4.htm">Interval Data Type Length</a>” in Appendix D, “Data Types”). For more information, see <a href="odappdpr_7ch1.htm">“Column Size, Decimal Digits, Transfer Octet Length, and Display Size</a>” in Appendix D, “Data Types.”</td>
</tr>
<tr valign=top>
<td colspan=2 width=29%>BUFFER_LENGTH<br>
(ODBC 1.0)</td>
<td colspan=2 width=15%>8</td>
<td colspan=2 width=16%>Integer</td>
<td colspan=2 width=40%>The length in bytes of data transferred on an <b>SQLGetData</b>, <b>SQLFetch</b>, or <b>SQLFetchScroll</b> operation if SQL_C_DEFAULT is specified. For numeric data, this size may be different than the size of the data stored on the data source. This value is the same as the COLUMN_SIZE column for character or binary data. For more information about length, see “<a href="odappdpr_7ch1.htm">Column Size, Decimal Digits, Transfer Octet Length, and Display Size</a>” in Appendix D, “Data Types.”</td>
</tr>
<tr valign=top>
<td colspan=2 width=29%>DECIMAL_DIGITS<br>
(ODBC 1.0)</td>
<td colspan=2 width=15%>9</td>
<td colspan=2 width=16%>Smallint</td>
<td colspan=2 width=40%>The total number of significant digits to the right of the decimal point. For SQL_TYPE_TIME and SQL_TYPE_TIMESTAMP, this column contains the number of digits in the fractional seconds component. For the other data types, this is the decimal digits of the column on the data source. For interval data types that contain a time component, this column contains the number of digits to the right of the decimal point (fractional seconds). For interval data types that do not contain a time component, this column is 0. For more information on decimal digits, see “<a href="odappdpr_7ch1.htm">Column Size, Decimal Digits, Transfer Octet Length, and Display Size</a>” in Appendix D, “Data Types.” NULL is returned for data types where decimal digits is not applicable.</td>
</tr>
<tr valign=top>
<td colspan=2 width=29%>NUM_PREC_RADIX<br>
(ODBC 1.0)</td>
<td colspan=2 width=15%>10</td>
<td colspan=2 width=16%>Smallint</td>
<td colspan=2 width=40%>For numeric data types, either 10 or 2. If it is 10, the values in COLUMN_SIZE and DECIMAL_DIGITS give the number of decimal digits allowed for the column. For example, a DECIMAL(12,5) column would return a NUM_PREC_RADIX of 10, a COLUMN_SIZE of 12, and a DECIMAL_DIGITS of 5; a FLOAT column could return a NUM_PREC_RADIX of 10, a COLUMN_SIZE of 15 and a DECIMAL_DIGITS of NULL.<p>
If it is 2, the values in COLUMN_SIZE and DECIMAL_DIGITS give the number of bits allowed in the column. For example, a FLOAT column could return a RADIX of 2, a COLUMN_SIZE of 53, and a DECIMAL_DIGITS of NULL.</p>
<p>
NULL is returned for data types where NUM_PREC_RADIX is not applicable.</p>
</td>
</tr>
<tr valign=top>
<td colspan=2 width=29%>NULLABLE<br>
(ODBC 1.0)</td>
<td colspan=2 width=15%>11</td>
<td colspan=2 width=16%>Smallint not NULL</td>
<td colspan=2 width=40%>SQL_NO_NULLS if the column could not include NULL values.<p>
SQL_NULLABLE if the column accepts NULL values.</p>
<p>
SQL_NULLABLE_UNKNOWN if it is not known whether the column accepts NULL values.</p>
<p>
The value returned for this column is different from the value returned for the IS_NULLABLE column. The NULLABLE column indicates with certainty that a column can accept NULLs, but cannot indicate with certainty that a column does not accept NULLs. The IS_NULLABLE column indicates with certainty that a column cannot accept NULLs, but cannot indicate with certainty that a column accepts NULLs.</p>
</td>
</tr>
<tr valign=top>
<td colspan=2 width=29%>REMARKS<br>
(ODBC 1.0)</td>
<td colspan=2 width=15%>12</td>
<td colspan=2 width=16%>Varchar</td>
<td colspan=2 width=40%>A description of the column.</td>
</tr>
<tr valign=top>
<td colspan=2 width=29%>COLUMN_DEF<br>
(ODBC 3.0)</td>
<td colspan=2 width=15%>13</td>
<td colspan=2 width=16%>Varchar</td>
<td colspan=2 width=40%>The default value of the column. The value in this column should be interpreted as a string if it is enclosed in quotation marks.<p>
If NULL was specified as the default value, then this column is the word NULL, not enclosed in quotation marks. If the default value cannot be represented without truncation, then this column contains TRUNCATED, with no enclosing single quotation marks. If no default value was specified, then this column is NULL.</p>
<p>
The value of COLUMN_DEF can be used in generating a new column definition, except when it contains the value TRUNCATED.</p>
</td>
</tr>
<tr valign=top>
<td width=23%>SQL_DATA_TYPE<br>
(ODBC 3.0)</td>
<td colspan=2 width=13%>14</td>
<td colspan=2 width=12%>Smallint not NULL</td>
<td colspan=2 width=33%>SQL data type, as it appears in the SQL_DESC_TYPE record field in the IRD. This can be an ODBC SQL data type or a driver-specific SQL data type. This column is the same as the DATA_TYPE column, with the exception of datetime and interval data types. This column returns the non-concise data type (such as SQL_DATETIME or SQL_INTERVAL), rather than the concise data type (such as&nbsp; SQL_TYPE_DATE or SQL_INTERVAL_YEAR_TO_<br>
MONTH) for datetime and interval data types. If this column returns SQL_DATETIME or SQL_INTERVAL, the specific data type can be determined from the SQL_DATETIME_SUB column. For a list of valid ODBC SQL data types, see “<a href="odappdpr_8fcj.htm">SQL Data Types</a>” in Appendix D, “Data Types.” For information about driver-specific SQL data types, see the driver’s documentation.</td>
</tr>
<tr valign=top>
<td width=23%>SQL_DATA_TYPE<br>
(ODBC 3.0) (<i>continued</i>)</td>
<td colspan=2 width=13%>14</td>
<td colspan=2 width=12%>Smallint not NULL</td>
<td colspan=2 width=33%>The data types returned for ODBC 3.<i>x</i> and ODBC 2.<i>x</i> applications may be different. For more information, see “<a href="odch17pr_0m1x.htm">Backward Compatibility and Standards Compliance</a>” in Chapter 17, “Programming Considerations.”</td>
</tr>
<tr valign=top>
<td width=23%>SQL_DATETIME_<br>
SUB<br>
(ODBC 3.0)</td>
<td colspan=2 width=13%>15</td>
<td colspan=2 width=12%>Smallint</td>
<td colspan=2 width=33%>The subtype code for datetime and interval data types. For other data types, this column returns a NULL. For more information about datetime and interval subcodes, see “SQL_DESC_DATETIME_<br>
INTERVAL_CODE” in <a href="odch21jpr_7e90.htm">SQLSetDescField</a>.</td>
</tr>
<tr valign=top>
<td width=23%>CHAR_OCTET_<br>
LENGTH<br>
(ODBC 3.0)</td>
<td colspan=2 width=13%>16</td>
<td colspan=2 width=12%>Integer</td>
<td colspan=2 width=33%>The maximum length in bytes of a character or binary data type column. For all other data types, this column returns a NULL.</td>
</tr>
<tr valign=top>
<td width=23%>ORDINAL_<br>
POSITION<br>
(ODBC 3.0)</td>
<td colspan=2 width=13%>17</td>
<td colspan=2 width=12%>Integer not NULL</td>
<td colspan=2 width=33%>The ordinal position of the column in the table. The first column in the table is number 1.</td>
</tr>
<tr valign=top>
<td width=23%>IS_NULLABLE<br>
(ODBC 3.0)</td>
<td colspan=2 width=13%>18</td>
<td colspan=2 width=12%>Varchar</td>
<td colspan=2 width=33%>“NO” if the column does not include NULLs.<p>
“YES” if the column could include NULLs.</p>
<p>
This column returns a zero-length string if nullability is unknown. </p>
<p>
ISO rules are followed to determine nullability. An ISO SQL&nbsp;–&nbsp;compliant DBMS cannot return an empty string. </p>
<p>
The value returned for this column is different from the value returned for the NULLABLE column. (See the description of the NULLABLE column.)</p>
</td>
</tr>
</table><br>
<p class=label>
<b>Code Example</b></p>
<p>
In the following example, an application declares buffers for the result set returned by <b>SQLColumns</b>. It calls <b>SQLColumns</b> to return a result set that describes each column in the EMPLOYEE table. It then calls <b>SQLBindCol</b> to bind the columns in the result set to the buffers. Finally, the application fetches each row of data with <b>SQLFetch</b> and processes it.</p>
<pre><code>#define STR_LEN 128+1
#define REM_LEN 254+1

/* Declare buffers for result set data */

SQLCHAR&nbsp;&nbsp; szCatalog[STR_LEN], szSchema[STR_LEN];
SQLCHAR&nbsp;&nbsp; szTableName[STR_LEN], szColumnName[STR_LEN];
SQLCHAR&nbsp;&nbsp; szTypeName[STR_LEN], szRemarks[REM_LEN];
SQLCHAR&nbsp;&nbsp; szColumnDefault[STR_LEN], szIsNullable[STR_LEN];
SQLINTEGER&nbsp; ColumnSize, BufferLength, CharOctetLength, OrdinalPosition;
SQLSMALLINT DataType, DecimalDigits, NumPrecRadix, Nullable;
SQLSMALLINT SQLDataType, DatetimeSubtypeCode;
SQLRETURN retcode;
SQLHSTMT&nbsp; hstmt;

/* Declare buffers for bytes available to return */

SQLINTEGER cbCatalog, cbSchema, cbTableName, cbColumnName;
SQLINTEGER cbDataType, cbTypeName, cbColumnSize, cbBufferLength;
SQLINTEGER cbDecimalDigits, cbNumPrecRadix, cbNullable, cbRemarks;
SQLINTEGER cbColumnDefault, cbSQLDataType, cbDatetimeSubtypeCode, cbCharOctetLength;
SQLINTEGER cbOrdinalPosition, cbIsNullable;

retcode = SQLColumns(hstmt,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL, 0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* All catalogs */
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL, 0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* All schemas&nbsp;&nbsp; */
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "CUSTOMERS", SQL_NTS, /* CUSTOMERS table */
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL, 0);&nbsp;&nbsp;&nbsp;&nbsp; /* All columns&nbsp; */

if (retcode == SQL_SUCCESS || retcode == SQL_SUCCESS_WITH_INFO) {

   /* Bind columns in result set to buffers */

   SQLBindCol(hstmt, 1, SQL_C_CHAR, szCatalog, STR_LEN,&amp;cbCatalog);
   SQLBindCol(hstmt, 2, SQL_C_CHAR, szSchema, STR_LEN, &amp;cbSchema);
   SQLBindCol(hstmt, 3, SQL_C_CHAR, szTableName, STR_LEN,&amp;cbTableName);
   SQLBindCol(hstmt, 4, SQL_C_CHAR, szColumnName, STR_LEN, &amp;cbColumnName);
   SQLBindCol(hstmt, 5, SQL_C_SSHORT, &amp;DataType, 0, &amp;cbDataType);
   SQLBindCol(hstmt, 6, SQL_C_CHAR, szTypeName, STR_LEN, &amp;cbTypeName);
   SQLBindCol(hstmt, 7, SQL_C_SLONG, &amp;ColumnSize, 0, &amp;cbColumnSize);
   SQLBindCol(hstmt, 8, SQL_C_SLONG, &amp;BufferLength, 0, &amp;cbBufferLength);
   SQLBindCol(hstmt, 9, SQL_C_SSHORT, &amp;DecimalDigits, 0, &amp;cbDecimalDigits);
   SQLBindCol(hstmt, 10, SQL_C_SSHORT, &amp;NumPrecRadix, 0, &amp;cbNumPrecRadix);
   SQLBindCol(hstmt, 11, SQL_C_SSHORT, &amp;Nullable, 0, &amp;cbNullable);
   SQLBindCol(hstmt, 12, SQL_C_CHAR, szRemarks, REM_LEN, &amp;cbRemarks);
   SQLBindCol(hstmt, 13, SQL_C_CHAR, szColumnDefault, STR_LEN, &amp;cbColumnDefault);
SQLBindCol(hstmt, 14, SQL_C_SSHORT, &amp;SQLDataType, 0, &amp;cbSQLDataType);
   SQLBindCol(hstmt, 15, SQL_C_SSHORT, &amp;DatetimeSubtypeCode, 0,
 &nbsp;&nbsp;&nbsp;&nbsp; &amp;cbDatetimeSubtypeCode);
   SQLBindCol(hstmt, 16, SQL_C_SLONG, &amp;CharOctetLength, 0, &amp;cbCharOctetLength);
   SQLBindCol(hstmt, 17, SQL_C_SLONG, &amp;OrdinalPosition, 0, &amp;cbOrdinalPosition);
   SQLBindCol(hstmt, 18, SQL_C_CHAR, szIsNullable, STR_LEN, &amp;cbIsNullable);
   while(TRUE) {
      retcode = SQLFetch(hstmt);
      if (retcode == SQL_ERROR || retcode == SQL_SUCCESS_WITH_INFO) {
         show_error( );
      }
      if (retcode == SQL_SUCCESS || retcode == SQL_SUCCESS_WITH_INFO){
         ...;&nbsp; /* Process fetched data */
      } else {
         break;
      }
   }
}
</code></pre>
<p class=label>
<b>Related Functions</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows width=587>
<tr valign=top>
<td class=label width=50%><b>For information about</b></td>
<td class=label width=50%><b>See</b></td>
</tr>
<tr valign=top>
<td width=50%>Binding a buffer to a column in a result set</td>
<td width=50%><a href="odch21bpr_0ht8.htm">SQLBindCol</a></td>
</tr>
<tr valign=top>
<td width=50%>Canceling statement processing</td>
<td width=50%><a href="odch21bpr_5b58.htm">SQLCancel</a></td>
</tr>
<tr valign=top>
<td width=50%>Returning privileges for a column or columns</td>
<td width=50%><a href="odch21cpr_5wvn.htm">SQLColumnPrivileges</a></td>
</tr>
<tr valign=top>
<td width=50%>Fetching a block of data or scrolling through a result set</td>
<td width=50%><a href="odch21epr_5m24.htm">SQLFetchScroll</a></td>
</tr>
<tr valign=top>
<td width=50%>Fetching multiple rows of data</td>
<td width=50%><a href="odch21epr_4zoo.htm">SQLFetch</a></td>
</tr>
<tr valign=top>
<td width=50%>Returning columns that uniquely identify a row, or columns automatically updated by a transaction</td>
<td width=50%><a href="odch21kpr_5d2r.htm">SQLSpecialColumns</a></td>
</tr>
<tr valign=top>
<td width=50%>Returning table statistics and indexes</td>
<td width=50%><a href="odch21kpr_73n7.htm">SQLStatistics</a></td>
</tr>
<tr valign=top>
<td width=50%>Returning a list of tables in a data source</td>
<td width=50%><a href="odch21kpr_6wqb.htm">SQLTables</a></td>
</tr>
<tr valign=top>
<td width=50%> &nbsp; Returning privileges for a table or tables</td>
<td width=50%><a href="odch21kpr_2xtf.htm">SQLTablePrivileges</a></td>
</tr>
</table><br>
</font></BODY>
</HTML>
