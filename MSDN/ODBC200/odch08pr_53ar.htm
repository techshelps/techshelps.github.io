<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Hard-Coded SQL Statements</title>
<link disabled rel=stylesheet href=msdn_ie3.css>
<style type="text/css">
@import url(msdn_ie4.css);
</style>
</HEAD>
<BODY>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->


<h2><a name="odbchard_coded_sql_statements"></a>Hard-Coded SQL Statements</h2>
<p>
Applications that perform a fixed task usually contain hard-coded SQL statements. For example, an order entry system might use the following call to list open sales orders:</p>
<pre><code>SQLExecDirect(hstmt, "SELECT OrderID FROM Orders WHERE Status = 'OPEN'", SQL_NTS);
</code></pre>
<p>
There are several advantages to hard-coded SQL statements: they can be tested when the application is written, they are simpler to implement than statements constructed at run time, and they simplify the application.</p>
<p>
Using statement parameters and preparing statements provide even better ways to use hard-coded SQL statements. For example, suppose the Parts table contains the PartID, Description, and Price columns. One way to insert a new row into this table would be to construct and execute an <b>INSERT</b> statement:</p>
<pre><code>#define DESC_LEN 51
#define STATEMENT_LEN 51

SQLUINTEGER PartID;
SQLCHAR&nbsp;&nbsp; Desc[DESC_LEN], Statement[STATEMENT_LEN];
SQLREAL&nbsp;&nbsp; Price;

// Set part ID, description, and price.
GetNewValues(&amp;PartID, Desc, &amp;Price);

// Build INSERT statement.
sprintf(Statement, "INSERT INTO Parts (PartID, Description,  Price) "
 &nbsp;&nbsp; "VALUES (%d, '%s', %f)", PartID, Desc, Price);

// Execute the statement.
SQLExecDirect(hstmt, Statement, SQL_NTS);
</code></pre>
<p>
An even better way is to use a hard-coded, parameterized statement. This has two advantages over a statement with hard-coded data values. First, it is easier to construct a parameterized statement because the data values can be sent in their native types, such as integers and floating point numbers, rather than converting them to strings. Second, such a statement can be used easily more than once by just changing the parameter values and re-executing it; there is no need to rebuild it.</p>
<pre><code>#define DESC_LEN 51

SQLCHAR * Statement = "INSERT INTO Parts (PartID, Description,  Price) "
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "VALUES (?, ?, ?)";
SQLUINTEGER PartID;
SQLCHAR&nbsp;&nbsp; Desc[DESC_LEN];
SQLREAL&nbsp;&nbsp; Price;
SQLINTEGER&nbsp; PartIDInd = 0, DescLenOrInd = SQL_NTS, PriceInd = 0;

// Bind the parameters.
SQLBindParameter(hstmt, 1, SQL_PARAM_INPUT, SQL_C_ULONG, SQL_INTEGER, 5, 0,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;PartID, 0, &amp;PartIDInd);
SQLBindParameter(hstmt, 2, SQL_PARAM_INPUT, SQL_C_CHAR, SQL_CHAR, DESC_LEN - 1, 0,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Desc, sizeof(Desc), &amp;DescLenOrInd);
SQLBindParameter(hstmt, 3, SQL_PARAM_INPUT, SQL_C_FLOAT, SQL_REAL, 7, 0,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;Price, 0, &amp;PriceInd);

// Set part ID, description, and price.
GetNewValues(&amp;PartID, Desc, &amp;Price);

// Execute the statement.
SQLExecDirect(hstmt, Statement, SQL_NTS);
</code></pre>
<p>
Assuming this statement is to be executed more than once, it can be prepared for even greater efficiency:</p>
<pre><code>#define DESC_LEN 51

SQLCHAR *Statement = "INSERT INTO Parts (PartID, Description,  Price) "
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "VALUES (?, ?, ?)";
SQLUINTEGER PartID;
SQLCHAR&nbsp;&nbsp; Desc[DESC_LEN];
SQLREAL&nbsp;&nbsp; Price;
SQLINTEGER&nbsp; PartIDInd = 0, DescLenOrInd = SQL_NTS, PriceInd = 0;

// Prepare the INSERT statement.
SQLPrepare(hstmt, Statement, SQL_NTS);

// Bind the parameters.
SQLBindParameter(hstmt, 1, SQL_PARAM_INPUT, SQL_C_ULONG, SQL_INTEGER, 5, 0,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;PartID, 0, &amp;PartIDInd);
SQLBindParameter(hstmt, 2, SQL_PARAM_INPUT, SQL_C_CHAR, SQL_CHAR, DESC_LEN - 1, 0,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Desc, sizeof(Desc), &amp;DescLenOrInd);
SQLBindParameter(hstmt, 3, SQL_PARAM_INPUT, SQL_C_FLOAT, SQL_REAL, 7, 0,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;Price, 0, &amp;PriceInd);

// Loop to continually get new values and insert them.
while (GetNewValues(&amp;PartID, Desc, &amp;Price))
 SQLExecute(hstmt);
</code></pre>
<p>
Perhaps the most efficient way to use the statement is to construct a procedure containing the statement, as shown in the following code example. Because the procedure is constructed at development time and stored on the data source, it does not need to be prepared at run time. A drawback of this method is that the syntax for creating procedures is DBMS-specific and procedures must be constructed separately for each DBMS on which the application is to run.</p>
<pre><code>#define DESC_LEN 51

SQLUINTEGER PartID;
SQLCHAR&nbsp;&nbsp; Desc[DESC_LEN];
SQLREAL&nbsp;&nbsp; Price;
SQLINTEGER&nbsp; PartIDInd = 0, DescLenOrInd = SQL_NTS, PriceInd = 0;

// Bind the parameters.
SQLBindParameter(hstmt, 1, SQL_PARAM_INPUT, SQL_C_ULONG, SQL_INTEGER, 5, 0,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;PartID, 0, &amp;PartIDInd);
SQLBindParameter(hstmt, 2, SQL_PARAM_INPUT, SQL_C_CHAR, SQL_CHAR, DESC_LEN - 1, 0,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Desc, sizeof(Desc), &amp;DescLenOrInd);
SQLBindParameter(hstmt, 3, SQL_PARAM_INPUT, SQL_C_FLOAT, SQL_REAL, 7, 0,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;Price, 0, &amp;PriceInd);

// Loop to continually get new values and insert them.
while (GetNewValues(&amp;PartID, Desc, &amp;Price))
 SQLExecDirect(hstmt, "{call InsertPart(?, ?, ?)}", SQL_NTS);
</code></pre>
<p>
For more information about parameters, prepared statements, and procedures, see “<a href="odch09pr_4mwk.htm">Executing a Statement</a>” in Chapter 9, “Executing Statements.”</p>
</font></BODY>
</HTML>
