<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Cursor Library Code Example</title>
<link disabled rel=stylesheet href=msdn_ie3.css>
<style type="text/css">
@import url(msdn_ie4.css);
</style>
</HEAD>
<BODY>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->


<h1><a name="odbccursor_library_code_example"></a>Cursor Library Code Example</h1>
<p>
The following example uses the cursor library to retrieve each order’s ID, open date, and status from the ORDERS table. It then displays 20 rows of data. If the user updates this data, the code updates the rowset buffers and executes a positioned update statement. Finally, it prompts the user for the direction to scroll and repeats the process.</p>
<pre><code>#define ROWS 20
#define STATUS_LEN 6
#define OPENDATE_LEN 11
#define DONE -1

SQLHENV         henv;
SQLHDBC         hdbc;
SQLHSTMT         hstmt1, hstmt2;
SQLRETURN         retcode;
SQLCHAR         szStatus[ROWS][STATUS_LEN], szOpenDate[ROWS][OPENDATE_LEN];
SQLCHAR         szNewStatus[STATUS_LEN], szNewOpenDate[OPENDATE_LEN];
SQLSMALLINT      sOrderID[ROWS], sNewOrderID[ROWS];
SQLINTEGER      cbStatus[ROWS], cbOrderID[ROWS], cbOpenDate[ROWS];
SQLUINTEGER      FetchOrientation, crow, FetchOffset, irowUpdt;
SQLUSMALLINT      RowStatusArray[ROWS];

SQLAllocHandle(SQL_HANDLE_ENV, SQL_NULL_HANDLE, &amp;henv);
SQLSetEnvAttr(henv, SQL_ATTR_ODBC_VERSION, SQL_OV_ODBC3,0);
SQLAllocHandle(SQL_HANDLE_DBC, henv, &amp;hdbc);

/* Specify that the ODBC Cursor Library is always used, then connect. */

SQLSetConnectAttr(hdbc, SQL_ATTR_ODBC_CURSORS, SQL_CUR_USE_ODBC);
SQLConnect(hdbc, "SalesOrder", SQL_NTS,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "JohnS", SQL_NTS,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Sesame", SQL_NTS);

if (retcode == SQL_SUCCESS || retcode == SQL_SUCCESS_WITH_INFO) {

   /* Allocate a statement handle for the result set and a statement */
   /* handle for positioned update statements.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */

   SQLAllocHandle(SQL_HANDLE_STMT, hdbc, &amp;hstmt1);
   SQLAllocHandle(SQL_HANDLE_STMT, hdbc, &amp;hstmt2);

   /* Specify an updatable static cursor with 20 rows of data. Set   */
   /* the cursor name, execute the SELECT statement, and bind the   */
   /* rowset buffers to result set columns in column-wise fashion.   */
   SQLSetStmtAttr(hstmt1, SQL_ATTR_CONCURRENCY, SQL_CONCUR_VALUES, 0);
   SQLSetStmtAttr(hstmt1, SQL_ATTR_CURSOR_TYPE, SQL_CURSOR_STATIC, 0);
   SQLSetStmtAttr(hstmt1, SQL_ATTR_ROW_ARRAY_SIZE, ROWS, 0);
   SQLSetStmtAttr(hstmt1, SQL_ATTR_ROW_STATUS_PTR, RowStatusArray, 0);
   SQLSetStmtAttr(hstmt1, SQL_ATTR_ROWS_FETCHED_PTR, &amp;crow, 0);
   SQLSetCursorName(hstmt1, "ORDERCURSOR", SQL_NTS);
   SQLExecDirect(hstmt1,
    &nbsp;&nbsp;&nbsp;&nbsp; "SELECT ORDERID, OPENDATE, STATUS FROM ORDERS ",
    &nbsp;&nbsp;&nbsp; SQL_NTS);
   SQLBindCol(hstmt1, 1, SQL_C_SSHORT, sOrderID, 0, cbName);
   SQLBindCol(hstmt1, 2, SQL_C_CHAR, szOpenDate, OPENDATE_LEN, cbOpenDate);
   SQLBindCol(hstmt1, 3, SQL_C_CHAR, szStatus, STATUS_LEN, cbStatus);

   /* Fetch the first block of data and display it. Prompt the user&nbsp; */
   /* for new data values. If the user supplies new values, update */
   /* the rowset buffers, bind them to the parameters in the update&nbsp; */
   /* statement, and execute a positioned update on another hstmt. */
   /* Prompt the user for how to scroll. Fetch and redisplay data as */
   /* needed.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */

   FetchOrientation = SQL_FETCH_FIRST;
   FetchOffset = 0;
   do {

      SQLFetchScroll(hstmt1, FetchOrientation, FetchOffset);
      DisplayRows(sOrderID, szOpenDate, szStatus, RowStatusArray);

      if (PromptUpdate(&amp;irowUpdt,&amp;sNewOrderID,szNewOpenDate,szNewStatus)==TRUE){
         sOrderID[irowUpdt] = sNewOrderID;
         cbOrderID[irowUpdt] = 0;
         strcpy(szOpenDate[irowUpdt], szNewOpenData);
         cbOpenDate[irowUpdt] = SQL_NTS;
         strcpy(szStatus[irowUpdt], szNewStatus);
         cbStatus[irowUpdt] = SQL_NTS;
         SQLBindParameter(hstmt2, 1, SQL_PARAM_INPUT,
                          SQL_C_SSHORT, SQL_INTEGER, 0, 0,
                          &amp;sOrderID[irowUpdt], 0, &amp;cbOrderID[irowUpdt]);
         SQLBindParameter(hstmt2, 2, SQL_PARAM_INPUT,
                          SQL_C_CHAR, SQL_TYPE_DATE, OPENDATE_LEN, 0,
                          szOpenDate[irowUpdt], OPENDATE_LEN, &amp;cbOpenDate[irowUpdt]);
         SQLBindParameter(hstmt2, 3, SQL_PARAM_INPUT,
                          SQL_C_CHAR, SQL_CHAR, STATUS_LEN, 0,
                          szStatus[irowUpdt], STATUS_LEN, &amp;cbStatus[irowUpdt]);
         SQLExecDirect(hstmt2,
          &nbsp;&nbsp;&nbsp;&nbsp; "UPDATE EMPLOYEE SET ORDERID = ?, OPENDATE = ?, STATUS = ?"
          &nbsp;&nbsp;&nbsp;&nbsp; "WHERE CURRENT OF EMPCURSOR",
          &nbsp;&nbsp;&nbsp;&nbsp; SQL_NTS);
      }

   while (PromptScroll(&amp;FetchOrientation, &amp;FetchOffset) != DONE)
}
</code></pre>
</font></BODY>
</HTML>
