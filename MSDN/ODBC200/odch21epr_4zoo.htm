<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SQLFetch</title>
<link disabled rel=stylesheet href=msdn_ie3.css>
<style type="text/css">
@import url(msdn_ie4.css);
</style>
</HEAD>
<BODY>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->


<h1><a name="odbcsqlfetch"></a>SQLFetch</h1>
<p class=label>
<b>Conformance</b></p>
<p>
Version Introduced:ODBC 1.0<br>
Standards Compliance:ISO 92</p>
<p class=label>
<b>Summary</b></p>
<p>
<b>SQLFetch</b> fetches the next rowset of data from the result set and returns data for all bound columns. </p>
<p class=label>
<b>Syntax</b></p>
<p>
SQLRETURN<b> SQLFetch</b>(<br>
SQLHSTMT<b></b><i>StatementHandle</i>);</p>
<p class=label>
<b>Arguments</b></p>
<p class=dt>
<i>StatementHandle</i></p>
<p class=indent>
[Input]<br>
Statement handle.</p>
<p class=label>
<b>Returns</b></p>
<p>
SQL_SUCCESS, SQL_SUCCESS_WITH_INFO, SQL_NO_DATA, SQL_STILL_EXECUTING, SQL_ERROR, or SQL_INVALID_HANDLE.</p>
<p class=label>
<b>Diagnostics</b></p>
<p>
When <b>SQLFetch</b> returns either SQL_ERROR or SQL_SUCCESS_WITH_INFO, an associated SQLSTATE value can be obtained by calling <b>SQLGetDiagRec</b> with a <i>HandleType</i> of SQL_HANDLE_STMT and a <i>Handle</i> of <i>StatementHandle</i>. The following table lists the SQLSTATE values commonly returned by <b>SQLFetch</b> and explains each one in the context of this function; the notation “(DM)” precedes the descriptions of SQLSTATEs returned by the Driver Manager. The return code associated with each SQLSTATE value is SQL_ERROR, unless noted otherwise. If an error occurs on a single column, <b>SQLGetDiagField</b> can be called with a <i>DiagIdentifier</i> of SQL_DIAG_COLUMN_NUMBER to determine the column the error occurred on; and <b>SQLGetDiagField</b> can be called with a <i>DiagIdentifier</i> of SQL_DIAG_ROW_NUMBER to determine the row containing that column. </p>
<p>
For all those SQLSTATEs that can return SQL_SUCCESS_WITH_INFO or SQL_ERROR (except 01xxx SQLSTATEs), SQL_SUCCESS_WITH_INFO is returned if an error occurs on one or more, but not all, rows of a multirow operation, and SQL_ERROR is returned if an error occurs on a single-row operation.</p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows width=587>
<tr valign=top>
<td class=label width=22%><b>SQLSTATE</b></td>
<td class=label width=26%><b>Error</b></td>
<td class=label width=52%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=22%>01000</td>
<td width=26%>General warning</td>
<td width=52%>Driver-specific informational message. (Function returns SQL_SUCCESS_WITH_INFO.)</td>
</tr>
<tr valign=top>
<td width=22%>01004</td>
<td width=26%>String data, right truncated</td>
<td width=52%>String or binary data returned for a column resulted in the truncation of non-blank character or non-NULL binary data. If it was a string value, it was right truncated.</td>
</tr>
<tr valign=top>
<td width=22%>01S01</td>
<td width=26%>Error in row</td>
<td width=52%>An error occurred while fetching one or more rows. <p>
(If this SQLSTATE is returned when an ODBC 3.x application is working with an ODBC 2<i>.x</i> driver, it can be ignored.)</p>
</td>
</tr>
<tr valign=top>
<td width=22%>01S07</td>
<td width=26%>Fractional truncation</td>
<td width=52%>The data returned for a column was truncated. For numeric data types, the fractional part of the number was truncated. For time, timestamp, and interval data types containing a time component, the fractional portion of the time was truncated. <p>
(Function returns SQL_SUCCESS_WITH_INFO.)</p>
</td>
</tr>
<tr valign=top>
<td width=22%>07006</td>
<td width=26%>Restricted data type attribute violation</td>
<td width=52%>The data value of a column in the result set could not be converted to the data type specified by <i>TargetType</i> in <b>SQLBindCol</b>.<p>
Column 0 was bound with a data type of SQL_C_BOOKMARK and the SQL_ATTR_USE_BOOKMARKS statement attribute was set to SQL_UB_VARIABLE. </p>
<p>
Column 0 was bound with a data type of SQL_C_VARBOOKMARK and the SQL_ATTR_USE_BOOKMARKS statement attribute was not set to SQL_UB_VARIABLE.</p>
</td>
</tr>
<tr valign=top>
<td width=22%>07009</td>
<td width=26%>Invalid descriptor index</td>
<td width=52%>The driver was an ODBC 2<i>.x</i> driver that does not support <b>SQLExtendedFetch</b>, and a column number specified in the binding for a column was 0. <p>
Column 0 was bound and the SQL_ATTR_USE_BOOKMARKS statement attribute was set to SQL_UB_OFF.</p>
</td>
</tr>
<tr valign=top>
<td width=22%>08S01</td>
<td width=26%>Communication link failure</td>
<td width=52%>The communication link between the driver and the data source to which the driver was connected failed before the function completed processing.</td>
</tr>
<tr valign=top>
<td width=22%>22001</td>
<td width=26%>String data, right truncated</td>
<td width=52%>A variable-length bookmark returned for a column was truncated.</td>
</tr>
<tr valign=top>
<td width=22%>22002</td>
<td width=26%>Indicator variable required but not supplied</td>
<td width=52%>NULL data was fetched into a column whose <i>StrLen_or_IndPtr</i> set by <b>SQLBindCol</b> (or SQL_DESC_INDICATOR_PTR set by <b>SQLSetDescField</b> or <b>SQLSetDescRec</b>) was a null pointer. </td>
</tr>
<tr valign=top>
<td width=22%>22003</td>
<td width=26%>Numeric value out of range</td>
<td width=52%>Returning the numeric value (as numeric or string) for one or more bound columns would have caused the whole (as opposed to fractional) part of the number to be truncated.<p>
For more information, see “<a href="odappdpr_4o4z.htm">Converting Data from SQL to C Data Types</a>” in Appendix D, “Data Types.”</p>
</td>
</tr>
<tr valign=top>
<td width=22%>22007</td>
<td width=26%>Invalid datetime format</td>
<td width=52%>A character column in the result set was bound to a date, time, or timestamp C structure, and a value in the column was, respectively, an invalid date, time, or timestamp. </td>
</tr>
<tr valign=top>
<td width=22%>22012</td>
<td width=26%>Division by zero</td>
<td width=52%>A value from an arithmetic expression was returned, which resulted in division by zero. </td>
</tr>
<tr valign=top>
<td width=22%>22015</td>
<td width=26%>Interval field overflow</td>
<td width=52%>Assigning from an exact numeric or interval SQL type to an interval C type caused a loss of significant digits in the leading field.<p>
When fetching data to an interval C type, there was no representation of the value of the SQL type in the interval C type. </p>
</td>
</tr>
<tr valign=top>
<td width=22%>22018</td>
<td width=26%>Invalid character value for cast specification</td>
<td width=52%>A character column in the result set was bound to a character C buffer, and the column contained a character for which there was no representation in the character set of the buffer.<p>
The C type was an exact or approximate numeric, a datetime, or an interval data type; the SQL type of the column was a character data type; and the value in the column was not a valid literal of the bound C type. </p>
</td>
</tr>
<tr valign=top>
<td width=22%>24000</td>
<td width=26%>Invalid cursor state</td>
<td width=52%>The <i>StatementHandle</i> was in an executed state but no result set was associated with the <i>StatementHandle</i>.</td>
</tr>
<tr valign=top>
<td width=22%>40001</td>
<td width=26%>Serialization failure</td>
<td width=52%>The transaction in which the fetch was executed was terminated to prevent deadlock.</td>
</tr>
<tr valign=top>
<td width=22%>40003</td>
<td width=26%>Statement completion unknown</td>
<td width=52%>The associated connection failed during the execution of this function and the state of the transaction cannot be determined.</td>
</tr>
<tr valign=top>
<td width=22%>HY000</td>
<td width=26%>General error</td>
<td width=52%>An error occurred for which there was no specific SQLSTATE and for which no implementation-specific SQLSTATE was defined. The error message returned by <b>SQLGetDiagRec</b> in the <i>*MessageText</i> buffer describes the error and its cause. </td>
</tr>
<tr valign=top>
<td width=22%>HY001</td>
<td width=26%>Memory allocation <br>
error</td>
<td width=52%>The driver was unable to allocate memory required to support execution or completion of the function.</td>
</tr>
<tr valign=top>
<td width=22%>HY008</td>
<td width=26%>Operation canceled</td>
<td width=52%>Asynchronous processing was enabled for the <i>StatementHandle</i>. The function was called and, before it completed execution, <b>SQLCancel</b> was called on the <i>StatementHandle</i>. Then the function was called again on the <i>StatementHandle</i>.<p>
The function was called and, before it completed execution, <b>SQLCancel</b> was called on the <i>StatementHandle</i> from a different thread in a multithread application.</p>
</td>
</tr>
<tr valign=top>
<td width=22%>HY010</td>
<td width=26%>Function sequence error</td>
<td width=52%>(DM) The specified <i>StatementHandle</i> was not in an executed state. The function was called without first calling <b>SQLExecDirect</b>, <b>SQLExecute</b>, or a catalog function.<p>
(DM) An asynchronously executing function (not this one) was called for the <i>StatementHandle</i> and was still executing when this function was called.</p>
<p>
(DM) <b>SQLExecute</b>, <b>SQLExecDirect</b>, <b>SQLBulkOperations</b>, or <b>SQLSetPos</b> was called for the <i>StatementHandle</i> and returned SQL_NEED_DATA. This function was called before data was sent for all data-at-execution parameters or columns.</p>
<p>
(DM) <b>SQLFetch</b> was called for the <i>StatementHandle</i> after <b>SQLExtendedFetch</b> was called and before <b>SQLFreeStmt</b> with the SQL_CLOSE option was called.</p>
</td>
</tr>
<tr valign=top>
<td width=22%>HY013</td>
<td width=26%>Memory management error</td>
<td width=52%>The function call could not be processed because the underlying memory objects could not be accessed, possibly because of low memory conditions.</td>
</tr>
<tr valign=top>
<td width=22%>HY090</td>
<td width=26%>Invalid string or buffer length</td>
<td width=52%>The SQL_ATTR_USE_BOOKMARK statement attribute was set to SQL_UB_VARIABLE, and column 0 was bound to a buffer whose length was not equal to the maximum length for the bookmark for this result set. (This length is available in the SQL_DESC_OCTET_LENGTH field of the IRD, and can be obtained by calling <b>SQLDescribeCol</b>, <b>SQLColAttribute</b>, or <b>SQLGetDescField</b>.)</td>
</tr>
<tr valign=top>
<td width=22%>HY107</td>
<td width=26%>Row value out of range</td>
<td width=52%>The value specified with the SQL_ATTR_CURSOR_TYPE statement attribute was SQL_CURSOR_KEYSET_DRIVEN, but the value specified with the SQL_ATTR_KEYSET_SIZE statement attribute was greater than 0 and less than the value specified with the SQL_ATTR_ROW_ARRAY_SIZE statement attribute.</td>
</tr>
<tr valign=top>
<td width=22%>HYC00</td>
<td width=26%>Optional feature not implemented</td>
<td width=52%>The driver or data source does not support the conversion specified by the combination of the <i>TargetType</i> in <b>SQLBindCol</b> and the SQL data type of the corresponding column.</td>
</tr>
<tr valign=top>
<td width=22%>HYT01</td>
<td width=26%>Connection timeout expired</td>
<td width=52%>The connection timeout period expired before the data source responded to the request. The connection timeout period is set through <b>SQLSetConnectAttr</b>, SQL_ATTR_CONNECTION_TIMEOUT.</td>
</tr>
<tr valign=top>
<td width=22%>IM001</td>
<td width=26%>Driver does not support this function</td>
<td width=52%>(DM) The driver associated with the <i>StatementHandle</i> does not support the function.</td>
</tr>
</table><br>
<p class=label>
<b>Comments</b></p>
<p>
<b>SQLFetch</b> returns the next rowset in the result set. It can be called only while a result set exists — that is, after a call that creates a result set and before the cursor over that result set is closed. If any columns are bound, it returns the data in those columns. If the application has specified a pointer to a row status array or a buffer in which to return the number of rows fetched, <b>SQLFetch</b> returns this information as well. Calls to <b>SQLFetch</b> can be mixed with calls to <b>SQLFetchScroll</b> but cannot be mixed with calls to <b>SQLExtendedFetch</b>. For more information, see “<a href="odch10pr_0601.htm">Fetching a Row of Data</a>” in Chapter 10, “Retrieving Results (Basic).”</p>
<p>
If an ODBC 3.x application works with an ODBC 2<i>.x</i> driver, the Driver Manager maps <b>SQLFetch</b> calls to <b>SQLExtendedFetch</b> for an ODBC 2.<i>x</i> driver that supports <b>SQLExtendedFetch</b>. If the ODBC 2.<i>x</i> driver does not support <b>SQLExtendedFetch</b>, the Driver Manager maps <b>SQLFetch</b> calls to <b>SQLFetch</b> in the ODBC 2.<i>x</i> driver, which can only fetch a single row.</p>
<p>
For more information, see “<a href="odappgpr_5drt.htm">Block Cursors, Scrollable Cursors, and Backward Compatibility</a>” in Appendix G, “Driver Guidelines for Backward Compatibility.”</p>
<h1>Positioning the Cursor</h1>
<p>
When the result set is created, the cursor is positioned before the start of the result set. <b>SQLFetch</b> fetches the next rowset. It is equivalent to calling <b>SQLFetchScroll</b> with <i>FetchOrientation</i> set to SQL_FETCH_NEXT. For more information about cursors, see “<a href="odch10pr_31bn.htm">Cursors</a>” in Chapter 10, “Retrieving Results (Basic)” and “<a href="odch11pr_2x6b.htm">Block Cursors</a>” in Chapter 11, “Retrieving Results (Advanced).”</p>
<p>
The SQL_ATTR_ROW_ARRAY_SIZE statement attribute specifies the number of rows in the rowset. If the rowset being fetched by <b>SQLFetch</b> overlaps the end of the result set, <b>SQLFetch</b> returns a partial rowset. That is, if S + R&nbsp;–&nbsp;1 is greater than L, where S is the starting row of the rowset being fetched, R is the rowset size, and L is the last row in the result set, then only the first L&nbsp;–&nbsp;S+1 rows of the rowset are valid. The remaining rows are empty and have a status of SQL_ROW_NOROW.</p>
<p>
After <b>SQLFetch</b> returns, the current row is the first row of the rowset.</p>
<p>
The following rules describe cursor positioning after a call to <b>SQLFetch</b>:</p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows width=587>
<tr valign=top>
<td class=label width=55%><b>Condition</b></td>
<td class=label colspan=2 width=45%><b>First row of new rowset</b></td>
</tr>
<tr valign=top>
<td width=55%>Before start</td>
<td colspan=2 width=45%>1</td>
</tr>
<tr valign=top>
<td width=55%><i>CurrRowsetStart</i> &lt;= <i>LastResultRow – RowsetSize </i><sup>1</sup></td>
<td colspan=2 width=45%><i>CurrRowsetStart</i> + <i>RowsetSize </i><sup>2</sup></td>
</tr>
<tr valign=top>
<td width=55%><i>CurrRowsetStart</i> &gt; <i>LastResultRow – RowsetSize </i><sup>1</sup></td>
<td colspan=2 width=45%>After end</td>
</tr>
<tr valign=top>
<td width=55%>After end</td>
<td colspan=2 width=45%>After end</td>
</tr>
<tr valign=top>
<td colspan=2 width=81%></td>
</tr>
<tr valign=top>
<td class=mini colspan=2 width=81%><sup>1</sup>If the rowset size is changed between fetches, this is the rowset size that was used with the previous fetch.<p class=mini>
<sup>2</sup>If the rowset size is changed between fetches, this is the rowset size that was used with the new fetch.</p>
</td>
</tr>
</table><br>
<p>
where:</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows width=587>
<tr valign=top>
<td class=label width=24%><b>Notation</b></td>
<td class=label width=76%><b>Meaning</b></td>
</tr>
<tr valign=top>
<td width=24%>Before start</td>
<td width=76%>The block cursor is positioned before the start of the result set. If the first row of the new rowset is before the start of the result set, <b>SQLFetch</b> returns SQL_NO_DATA.</td>
</tr>
<tr valign=top>
<td width=24%>After end</td>
<td width=76%>The block cursor is positioned after the end of the result set. If the first row of the new rowset is after the end of the result set, <b>SQLFetch</b> returns SQL_NO_DATA.</td>
</tr>
<tr valign=top>
<td width=24%><i>CurrRowsetStart</i></td>
<td width=76%>The number of the first row in the current rowset.</td>
</tr>
<tr valign=top>
<td width=24%><i>LastResultRow</i></td>
<td width=76%>The number of the last row in the result set.</td>
</tr>
<tr valign=top>
<td width=24%><i>RowsetSize</i></td>
<td width=76%>The rowset size.</td>
</tr>
</table><br>
<p>
For example, suppose a result set has 100 rows and the rowset size is 5. The following table shows the rowset and return code returned by <b>SQLFetch</b> for different starting positions.</p>
<table border=1 cellpadding=5 cols=4 frame=below rules=rows width=587>
<tr valign=top>
<td class=label width=21%><b><br>
Current rowset</b></td>
<td class=label width=29%><b><br>
Return code</b></td>
<td class=label width=34%><b><br>
New rowset</b></td>
<td class=label width=16%><b># of rows fetched</b></td>
</tr>
<tr valign=top>
<td width=21%>Before start</td>
<td width=29%>SQL_SUCCESS</td>
<td width=34%>1 to 5</td>
<td width=16%>5</td>
</tr>
<tr valign=top>
<td width=21%>1 to 5</td>
<td width=29%>SQL_SUCCESS</td>
<td width=34%>6 to 10</td>
<td width=16%>5</td>
</tr>
<tr valign=top>
<td width=21%>52 to 56</td>
<td width=29%>SQL_SUCCESS</td>
<td width=34%>57 to 61</td>
<td width=16%>5</td>
</tr>
<tr valign=top>
<td width=21%>91 to 95</td>
<td width=29%>SQL_SUCCESS</td>
<td width=34%>96 to 100</td>
<td width=16%>5</td>
</tr>
<tr valign=top>
<td width=21%>93 to 97</td>
<td width=29%>SQL_SUCCESS</td>
<td width=34%>98 to 100. Rows 4 and 5<br>
of the row status array<br>
are set to<br>
SQL_ROW_NOROW.</td>
<td width=16%>3</td>
</tr>
<tr valign=top>
<td width=21%>96 to 100</td>
<td width=29%>SQL_NO_DATA</td>
<td width=34%>None.</td>
<td width=16%>0</td>
</tr>
<tr valign=top>
<td width=21%>99 to 100</td>
<td width=29%>SQL_NO_DATA</td>
<td width=34%>None.</td>
<td width=16%>0</td>
</tr>
<tr valign=top>
<td width=21%>After end</td>
<td width=29%>SQL_NO_DATA</td>
<td width=34%>None.</td>
<td width=16%>0</td>
</tr>
</table><br>
<h1>Returning Data in Bound Columns</h1>
<p>
As <b>SQLFetch</b> returns each row, it places the data for each bound column in the buffer bound to that column. If no columns are bound, <b>SQLFetch</b> does not return any data but does move the block cursor forward. The data can still be retrieved with <b>SQLGetData</b>. If the cursor is a multirow cursor (that is, the SQL_ATTR_ROW_ARRAY_SIZE is greater than 1), <b>SQLGetData</b> can be called only if SQL_GD_BLOCK is returned when <b>SQLGetInfo</b> is called with an <i>InfoType</i> of SQL_GETDATA_EXTENSIONS. (For more information, see <a href="odch21gpr_682p.htm">SQLGetData</a>.)</p>
<p>
For each bound column in a row, <b>SQLFetch</b> does the following:
<ol>
<li>
Sets the length/indicator buffer to SQL_NULL_DATA and proceeds to the next column if the data is NULL. If the data is NULL and no length/indicator buffer was bound, <b>SQLFetch</b> returns SQLSTATE 22002 (Indicator variable required but not supplied) for the row and proceeds to the next row. For information about how to determine the address of the length/indicator buffer, see “Buffer Addresses” in <a href="odch21bpr_0ht8.htm">SQLBindCol</a>.<p class=tl>
If the data for the column is not NULL, <b>SQLFetch</b> proceeds to step 2.</P></li>
<li>
If the SQL_ATTR_MAX_LENGTH statement attribute is set to a nonzero value and the column contains character or binary data, the data is truncated to SQL_ATTR_MAX_LENGTH bytes.<p class=atl>
<B><b>Note</b></B> The SQL_ATTR_MAX_LENGTH statement attribute is intended to reduce network traffic. It is generally implemented by the data source, which truncates the data before returning it across the network. Drivers and data sources are not required to support it. Therefore, to guarantee that data is truncated to a particular size, an application should allocate a buffer of that size and specify the size in the <i>cbValueMax</i> argument in <b>SQLBindCol</b>.</p></li>
<li>
Converts the data to the type specified by <i>TargetType</i> in <b>SQLBindCol</b>.<br><br></li>
<li>
If the data was converted to a variable-length data type, such as character or binary, <b>SQLFetch</b> checks whether the length of the data exceeds the length of the data buffer. If the length of character data (including the null-termination character) exceeds the length of the data buffer, <b>SQLFetch</b> truncates the data to the length of the data buffer less the length of a null-termination character. It then null-terminates the data. If the length of binary data exceeds the length of the data buffer, <b>SQLFetch</b> truncates it to the length of the data buffer. The length of the data buffer is specified with <i>BufferLength</i> in <b>SQLBindCol</b>.<p class=tl>
<b>SQLFetch</b> never truncates data converted to fixed-length data types; it always assumes that the length of the data buffer is the size of the data type.</P></li>
<li>
Places the converted (and possibly truncated) data in the data buffer. For information about how to determine the address of the data buffer, see “Buffer Addresses” in <a href="odch21bpr_0ht8.htm">SQLBindCol</a>.<br><br></li>
<li>
Places the length of the data in the length/indicator buffer. If the indicator pointer and the length pointer were both set to the same buffer (as a call to <b>SQLBindCol</b> does), the length is written in the buffer for valid data and SQL_NULL_DATA is written in the buffer for NULL data. If no length/indicator buffer was bound, <b>SQLFetch</b> does not return the length.<ul type=disc>
<li>
For character or binary data, this is the length of the data after conversion and before truncation due to the data buffer being too small. If the driver cannot determine the length of the data after conversion, as is sometimes the case with long data, it sets the length to SQL_NO_TOTAL. If data was truncated due to the SQL_ATTR_MAX_LENGTH statement attribute, the value of this attribute — as opposed to the actual length — is placed in the length/indicator buffer. This is because this attribute is designed to truncate data on the server before conversion, so the driver has no way of figuring out what the actual length is.<br><br></li>
<li>
For all other data types, this is the length of the data after conversion; that is, it is the size of the type to which the data was converted.</li>
</ul>
<p class=tl>
For information about how to determine the address of the length/indicator buffer, see “Buffer Addresses” in <a href="odch21bpr_0ht8.htm">SQLBindCol</a>.</P></li>
<li>
If the data is truncated during conversion without a loss of significant digits (for example, the real number 1.234 is truncated when converted to the integer 1) and <b>SQLFetch</b> returns SQLSTATE 01S07 (Fractional truncation) and SQL_SUCCESS_WITH_INFO: If the data is truncated because the length of the data buffer is too small (for example, the string “abcdef” is placed in a 4-byte buffer), <b>SQLFetch</b> returns SQLSTATE 01004 (Data truncated) and SQL_SUCCESS_WITH_INFO. If data is truncated due to the SQL_ATTR_MAX_LENGTH statement attribute, <b>SQLFetch</b> returns SQL_SUCCESS and does not return SQLSTATE 01S07 (Fractional truncation) or SQLSTATE 01004 (Data truncated). If data is truncated during conversion with a loss of significant digits (for example, if an SQL_INTEGER value greater than 100,000 were converted to an SQL_C_TINYINT), <b>SQLFetch</b> returns SQLSTATE 22003 (Numeric value out of range) and SQL_ERROR (if the rowset size is 1) or SQL_SUCCESS_WITH_INFO (if the rowset size is greater than 1).</li>
</ol>
<p>
The contents of the bound data buffer and the length/indicator buffer are undefined if <b>SQLFetch</b> or <b>SQLFetchScroll</b> does not return SQL_SUCCESS or SQL_SUCCESS_WITH_INFO.</p>
<h1>Row Status Array</h1>
<p>
The row status array is used to return the status of each row in the rowset. The address of this array is specified with the SQL_ATTR_ROW_STATUS_PTR statement attribute. The array is allocated by the application and must have as many elements as are specified by the SQL_ATTR_ROW_ARRAY_SIZE statement attribute. Its values are set by <b>SQLFetch</b>, <b>SQLFetchScroll</b>, and <b>SQLBulkOperations</b> or <b>SQLSetPos</b> (except when they have been called after the cursor has been positioned by <b>SQLExtendedFetch</b>). If the value of the SQL_ATTR_ROW_STATUS_PTR statement attribute is a null pointer, these functions do not return the row status.</p>
<p>
The contents of the row status array buffer are undefined if <b>SQLFetch</b> or <b>SQLFetchScroll</b> does not return SQL_SUCCESS or SQL_SUCCESS_WITH_INFO.</p>
<p>
The following values are returned in the row status array.</p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows width=587>
<tr valign=top>
<td class=label width=43%><b>Row status array value</b></td>
<td class=label colspan=2 width=57%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=43%>SQL_ROW_SUCCESS</td>
<td colspan=2 width=57%>The row was successfully fetched and has not changed since it was last fetched from this result set.</td>
</tr>
<tr valign=top>
<td width=43%>SQL_ROW_SUCCESS_<br>
WITH_INFO</td>
<td colspan=2 width=57%>The row was successfully fetched and has not changed since it was last fetched from this result set. However, a warning was returned about the row.</td>
</tr>
<tr valign=top>
<td width=43%>SQL_ROW_ERROR</td>
<td colspan=2 width=57%>An error occurred while fetching the row.</td>
</tr>
<tr valign=top>
<td width=43%>SQL_ROW_UPDATED <sup>1,2, and 3</sup></td>
<td colspan=2 width=57%>The row was successfully fetched and has changed since it was last fetched from this result set. If the row is fetched again from this result set, or is refreshed by <b>SQLSetPos</b>, the status changed to the row’s new status.</td>
</tr>
<tr valign=top>
<td width=43%>SQL_ROW_DELETED <sup>3</sup></td>
<td colspan=2 width=57%>The row has been deleted since it was last fetched from this result set.</td>
</tr>
<tr valign=top>
<td width=43%>SQL_ROW_ADDED <sup>4</sup></td>
<td colspan=2 width=57%>The row was inserted by <b>SQLBulkOperations</b>. If the row is fetched again from this result set, or is refreshed by <b>SQLSetPos</b>, its status is SQL_ROW_SUCCESS.</td>
</tr>
<tr valign=top>
<td width=43%>SQL_ROW_NOROW</td>
<td colspan=2 width=57%>The rowset overlapped the end of the result set and no row was returned that corresponded to this element of the row status array.</td>
</tr>
<tr valign=top>
<td class=mini colspan=2 width=81%><sup>1</sup>For keyset, mixed, and dynamic cursors, if a key value is updated, the row of data is considered to have been deleted and a new row added.<p class=mini>
<sup>2</sup>Some drivers cannot detect updates to data and therefore cannot return this value. To determine whether a driver can detect updates to refetched rows, an application calls <b>SQLGetInfo</b> with the SQL_ROW_UPDATES option.</p>
<p class=mini>
<sup>3</sup><b>SQLFetch</b> can return this value only when it is intermixed with calls to <b>SQLFetchScroll</b>. The reason for this is that <b>SQLFetch</b> moves forward through the result set and, when used exclusively, does not refetch any rows. Because no rows are refetched, <b>SQLFetch</b> does not detect changes made to previously fetched rows. However, if <b>SQLFetchScroll</b> positions the cursor before any previously fetched rows and <b>SQLFetch</b> is used to fetch those rows, <b>SQLFetch</b> can detect any changes to those rows.</p>
<p class=mini>
<sup>4</sup>Returned by <b>SQLBulkOperations</b> only. Not set by <b>SQLFetch</b> or <b>SQLFetchScroll</b>.</p>
</td>
</tr>
</table><br>
<h1>Rows Fetched Buffer</h1>
<p>
The rows fetched buffer is used to return the number of rows fetched, including those rows for which no data was returned because an error occurred while they were being fetched. In other words, it is the number of rows for which the value in the row status array is not SQL_ROW_NOROW. The address of this buffer is specified with the SQL_ATTR_ROWS_FETCHED_PTR statement attribute. The buffer is allocated by the application. It is set by <b>SQLFetch </b>and <b>SQLFetchScroll</b>. If the value of the SQL_ATTR_ROWS_FETCHED_PTR statement attribute is a null pointer, these functions do not return the number of rows fetched. To determine the number of the current row in the result set, an application can call <b>SQLGetStmtAttr</b> with the SQL_ATTR_ROW_NUMBER attribute.</p>
<p>
The contents of the rows fetched buffer are undefined if <b>SQLFetch</b> or <b>SQLFetchScroll</b> does not return SQL_SUCCESS or SQL_SUCCESS_WITH_INFO, except when SQL_NO_DATA is returned, in which case the value in the rows fetched buffer is set to 0.</p>
<h1>Error Handling</h1>
<p>
Errors and warnings can apply to individual rows or to the entire function. For more information about diagnostic records, see Chapter 15, “<a href="odch15pr_3rqr.htm">Diagnostics</a>,” and <a href="odch21gpr_009w.htm">SQLGetDiagField</a>.</p>
<h1><B>Errors and Warnings on the Entire Function</B></h1>
<p>
If an error applies to the entire function, such as SQLSTATE HYT00 (Timeout expired) or SQLSTATE 24000 (Invalid cursor state), <b>SQLFetch</b> returns SQL_ERROR and the applicable SQLSTATE. The contents of the rowset buffers are undefined and the cursor position is unchanged.</p>
<p>
If a warning applies to the entire function, <b>SQLFetch</b> returns SQL_SUCCESS_WITH_INFO and the applicable SQLSTATE. The status records for warnings that apply to the entire function are returned before the status records that apply to individual rows.</p>
<h1><B>Errors and Warnings in Individual Rows</B></h1>
<p>
If an error (such as SQLSTATE 22012 (Division by zero)) or a warning (such as SQLSTATE 01004 (Data truncated)) applies to a single row, <b>SQLFetch</b>:
<ul type=disc>
<li>
Sets the corresponding element of the row status array to SQL_ROW_ERROR for errors or SQL_ROW_SUCCESS_WITH_INFO for warnings.<br><br></li>
<li>
Adds zero or more status records containing SQLSTATEs for the error or warning.<br><br></li>
<li>
Sets the row and column number fields in the status records. If <b>SQLFetch</b> cannot determine a row or column number, it sets that number to SQL_ROW_NUMBER_UNKNOWN or SQL_COLUMN_NUMBER_UNKNOWN, respectively. If the status record does not apply to a particular column, <b>SQLFetch</b> sets the column number to SQL_NO_COLUMN_NUMBER.</li>
</ul>
<p>
<b>SQLFetch</b> continues fetching rows until it has fetched all of the rows in the rowset. It returns SQL_SUCCESS_WITH_INFO unless an error occurs in every row of the rowset (not counting rows with status SQL_ROW_NOROW), in which case it returns SQL_ERROR. In particular, if the rowset size is 1 and an error occurs in that row, <b>SQLFetch</b> returns SQL_ERROR.</p>
<p>
<b>SQLFetch</b> returns the status records in row number order. That is, it returns all status records for unknown rows (if any), then all status records for the first row (if any), then all status records for the second row (if any), and so on. The status records for each individual row are ordered according to the normal rules for ordering status records; for more information, see “Sequence of Status Records” in <a href="odch21gpr_009w.htm">SQLGetDiagField</a>.</p>
<h1>Descriptors and SQLFetch</h1>
<p>
The following sections describe how <b>SQLFetch</b> interacts with descriptors.</p>
<h1>Argument Mappings</h1>
<p>
The driver does not set any descriptor fields based on the arguments of <b>SQLFetch</b>.</p>
<h1><B>Other Descriptor Fields</B></h1>
<p>
The following descriptor fields are used by <b>SQLFetch</b>.</p>
<table border=1 cellpadding=5 cols=4 frame=below rules=rows width=587>
<tr valign=top>
<td class=label width=40%><b>Descriptor field</b></td>
<td class=label width=8%><b>Desc.</b></td>
<td class=label width=11%><b>Field in</b></td>
<td class=label width=41%><b>Set through</b></td>
</tr>
<tr valign=top>
<td width=40%>SQL_DESC_ARRAY_SIZE</td>
<td width=8%>ARD</td>
<td width=11%>header</td>
<td width=41%>SQL_ATTR_ROW_ARRAY_SIZE statement attribute</td>
</tr>
<tr valign=top>
<td width=40%>SQL_DESC_ARRAY_STATUS_PTR</td>
<td width=8%>IRD</td>
<td width=11%>header</td>
<td width=41%>SQL_ATTR_ROW_STATUS_PTR statement attribute</td>
</tr>
<tr valign=top>
<td width=40%>SQL_DESC_BIND_OFFSET_PTR</td>
<td width=8%>ARD</td>
<td width=11%>header</td>
<td width=41%>SQL_ATTR_ROW_BIND_OFFSET_PTR statement attribute</td>
</tr>
<tr valign=top>
<td width=40%>SQL_DESC_BIND_TYPE</td>
<td width=8%>ARD</td>
<td width=11%>header</td>
<td width=41%>SQL_ATTR_ROW_BIND_TYPE statement attribute</td>
</tr>
<tr valign=top>
<td width=40%>SQL_DESC_COUNT</td>
<td width=8%>ARD</td>
<td width=11%>header</td>
<td width=41%><i>ColumnNumber</i> argument of <b>SQLBindCol</b></td>
</tr>
<tr valign=top>
<td width=40%>SQL_DESC_DATA_PTR</td>
<td width=8%>ARD</td>
<td width=11%>records</td>
<td width=41%><i>TargetValuePtr</i> argument of <b>SQLBindCol</b></td>
</tr>
<tr valign=top>
<td width=40%>SQL_DESC_INDICATOR_PTR</td>
<td width=8%>ARD</td>
<td width=11%>records</td>
<td width=41%><i>StrLen_or_IndPtr</i> argument in <b>SQLBindCol</b></td>
</tr>
<tr valign=top>
<td width=40%>SQL_DESC_OCTET_LENGTH</td>
<td width=8%>ARD</td>
<td width=11%>records</td>
<td width=41%><i>BufferLength</i> argument in <b>SQLBindCol</b></td>
</tr>
<tr valign=top>
<td width=40%>SQL_DESC_OCTET_LENGTH_PTR</td>
<td width=8%>ARD</td>
<td width=11%>records</td>
<td width=41%><i>StrLen_or_IndPtr</i> argument in <b>SQLBindCol</b></td>
</tr>
<tr valign=top>
<td width=40%>SQL_DESC_ROWS_<br>
PROCESSED_PTR</td>
<td width=8%>IRD</td>
<td width=11%>header</td>
<td width=41%>SQL_ATTR_ROWS_FETCHED_PTR statement attribute</td>
</tr>
<tr valign=top>
<td width=40%>SQL_DESC_TYPE</td>
<td width=8%>ARD</td>
<td width=11%>records</td>
<td width=41%><i>TargetType</i> argument in <b>SQLBindCol</b></td>
</tr>
</table><br>
<p>
All descriptor fields can also be set through <b>SQLSetDescField</b>.</p>
<h1><B>Separate Length and Indicator Buffers</B></h1>
<p>
Applications can bind a single buffer or two separate buffers to be used to hold length and indicator values. When an application calls <b>SQLBindCol</b>, the driver sets the SQL_DESC_OCTET_LENGTH_PTR and SQL_DESC_INDICATOR_PTR fields of the ARD to the same address, which is passed in the <i>StrLen_or_IndPtr</i> argument. When an application calls <b>SQLSetDescField</b> or <b>SQLSetDescRec</b>, it can set these two fields to different addresses.</p>
<p>
<b>SQLFetch</b> determines whether the application has specified separate length and indicator buffers. In this case, when the data is not NULL, <b>SQLFetch</b> sets the indicator buffer to 0 and returns the length in the length buffer. When the data is NULL, <b>SQLFetch</b> sets the indicator buffer to SQL_NULL_DATA and does not modify the length buffer.</p>
<p class=label>
<b>Code Example</b></p>
<p>
See <a href="odch21bpr_0ht8.htm">SQLBindCol</a>, <a href="odch21cpr_8nsj.htm">SQLColumns</a>, <a href="odch21gpr_682p.htm">SQLGetData</a>, and <a href="odch21jpr_2y0j.htm">SQLProcedures</a>.</p>
<p class=label>
<b>Related Functions</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows width=587>
<tr valign=top>
<td class=label width=50%><b>For information about</b></td>
<td class=label width=50%><b>See</b></td>
</tr>
<tr valign=top>
<td width=50%>Binding a buffer to a column in a result set</td>
<td width=50%><a href="odch21bpr_0ht8.htm">SQLBindCol</a></td>
</tr>
<tr valign=top>
<td width=50%>Canceling statement processing</td>
<td width=50%><a href="odch21bpr_5b58.htm">SQLCancel</a></td>
</tr>
<tr valign=top>
<td width=50%>Returning information about a column in a result set</td>
<td width=50%><a href="odch21dpr_92jw.htm">SQLDescribeCol</a></td>
</tr>
<tr valign=top>
<td width=50%>Executing an SQL statement</td>
<td width=50%><a href="odch21epr_35x0.htm">SQLExecDirect</a></td>
</tr>
<tr valign=top>
<td width=50%>Executing a prepared SQL statement</td>
<td width=50%><a href="odch21epr_0yg5.htm">SQLExecute</a></td>
</tr>
<tr valign=top>
<td width=50%>Fetching a block of data or scrolling through a result set</td>
<td width=50%><a href="odch21epr_5m24.htm">SQLFetchScroll</a></td>
</tr>
<tr valign=top>
<td width=50%>Closing the cursor on the statement</td>
<td width=50%><a href="odch21fpr_84hg.htm">SQLFreeStmt</a></td>
</tr>
<tr valign=top>
<td width=50%>Fetching part or all of a column of data</td>
<td width=50%><a href="odch21gpr_682p.htm">SQLGetData</a></td>
</tr>
<tr valign=top>
<td width=50%>Returning the number of result set columns</td>
<td width=50%><a href="odch21ipr_74hf.htm">SQLNumResultCols</a></td>
</tr>
<tr valign=top>
<td width=50%>Preparing a statement for execution</td>
<td width=50%><a href="odch21ipr_3td1.htm">SQLPrepare</a></td>
</tr>
</table><br>
</font></BODY>
</HTML>
