<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Alignment</title>
<link disabled rel=stylesheet href=msdn_ie3.css>
<style type="text/css">
@import url(msdn_ie4.css);
</style>
</HEAD>
<BODY>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->


<h1><a name="odbcalignment"></a>Alignment</h1>
<p>
The alignment issues in an ODBC application are generally no different than they are in any other application. That is, most ODBC applications have few or no problems with alignment. The penalties for not aligning addresses vary with the hardware and operating system, and may be as minor as a slight performance penalty or as major as a fatal run-time error. Thus, ODBC applications — and portable ODBC applications in particular — should be careful to align data properly.</p>
<p>
One place where ODBC applications encounter alignment issues is when they allocate a large block of memory and bind different parts of that memory to the columns in a result set. This is most likely to occur when a generic application must determine the shape of a result set at run time and allocate and bind memory accordingly.</p>
<p>
For example, suppose an application executes a <b>SELECT</b> statement entered by the user and fetches the results from this statement. Because the shape of this result set is not known when the program is written, the application must determine the type of each column after the result set is created and bind memory accordingly. The easiest way to do this is to allocate a large block of memory and bind different addresses in that block to each column. To access the data in a column, the application casts the memory bound to that column.</p>
<p>
The following diagram shows a sample result set and how a block of memory might be bound to it using the default C data type for each SQL data type. Each "X" represents a single byte of memory. Note that this example only shows the data buffers that are bound to the columns. This is done for simplicity. In actual code, the length/indicator buffers must also be aligned.</p>
<p>
<img src="pr24.gif" border=0></p>
<p>
Assuming the bound addresses are stored in the <i>Address</i> array, the application uses the following expressions to access the memory bound to each column:</p>
<pre><code>&nbsp;(SQLCHAR *)&nbsp; Address[0]
 (SQLSMALLINT *)&nbsp; Address[1]
 (SQLINTEGER *) Address[2]
</code></pre>
<p>
Notice that the addresses bound to the second and third columns start on odd-numbered bytes and that the address bound to the third column is not divisible by four, which is the size of an SDWORD. On some machines, this will not be a problem, on others, it will cause a slight performance penalty, on still others, it will cause a fatal run-time error. A better solution would be to align each bound address on its natural alignment boundary. Assuming this is 1 for a UCHAR, 2 for an SWORD, and 4 for an SDWORD, this would give the following, where an "X" represents a byte of memory that is used and an "O" represents a byte of memory that is unused:</p>
<p>
<img src="pr25.gif" border=0></p>
<p>
While this solution does not use all of the application's memory, it does not encounter any alignment problems. Unfortunately, it takes a fair amount of code to implement this solution, as each column must be aligned individually according to its type. A simpler solution is to align all columns on the size of the largest alignment boundary, which is 4 in this case:</p>
<p>
<img src="pr26.gif" border=0></p>
<p>
Although this solution leaves larger holes, the code to implement it is relatively simple and fast. In most cases, this offsets the penalty paid in unused memory. For an example that uses this method, see "<a href="odch10pr_59nw.htm">Using SQLBindCol</a>" in Chapter 10, "Retrieving Results (Basic)."</p>
</font></BODY>
</HTML>
