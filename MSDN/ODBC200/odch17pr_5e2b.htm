<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Writing ODBC 3.x Applications</title>
<link disabled rel=stylesheet href=msdn_ie3.css>
<style type="text/css">
@import url(msdn_ie4.css);
</style>
</HEAD>
<BODY>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->


<h2><a name="odbcwriting_odbc_3.x_applications"></a>Writing ODBC 3.x Applications</h2>
<p>
When an ODBC 2.<i>x </i>application is upgraded to ODBC 3.<i>x</i>, it should be written such that it works with both ODBC 2.<i>x </i>and 3.<i>x</i> drivers. The application should incorporate conditional code to take full advantage of the ODBC 3.<i>x</i> features. </p>
<p>
The SQL_ATTR_ODBC_VERSION environment attribute should be set to SQL_OV_ODBC2. This will ensure that the driver behaves like an ODBC 2<i>.x </i>driver with respect to the changes described in the "<a href="odch17pr_4lgz.htm">Behavioral Changes</a>" section earlier in this chapter are concerned.</p>
<p>
If the application will use any of the features described in the "<a href="odch17pr_2kdv.htm">New Features</a>" section earlier in this chapter, conditional code should be used to determine whether the driver is an ODBC 3.<i>x</i> or ODBC 2<i>.x</i> driver. The application uses <b>SQLGetDiagField</b> and <b>SQLGetDiagRec</b> to obtain ODBC 3.<i>x</i> SQLSTATEs while doing error processing on these conditional code fragments. The following points about the new functionality should be considered:
<ul type=disc>
<li>
An application affected by the change in rowset size behavior should be careful not to call <b>SQLFetch</b> when the array size is greater than 1. These applications should replace calls to <b>SQLExtendedFetch</b> with calls to <b>SQLSetStmtAttr</b> to set the SQL_ATTR_ARRAY_STATUS_PTR statement attribute and <b>SQLFetchScroll</b>, so they<b> </b>have common code that works with both ODBC 3.<i>x</i> and ODBC 2.<i>x </i>drivers. Because <b>SQLSetStmtAttr</b> with SQL_ATTR_ROW_ARRAY_SIZE will be mapped to <b>SQLSetStmtAttr</b> with SQL_ROWSET_SIZE for ODBC 2.<i>x </i>drivers, applications can just set SQL_ATTR_ROW_ARRAY_SIZE for their multirow fetch operations.<br><br></li>
<li>
Most applications that are upgrading are not actually affected by changes in SQLSTATE codes. For those applications that are affected, they can do a mechanical search and replace in most cases using the error conversion table in the "SQLSTATE Mapping" section to convert ODBC 3.<i>x</i> error codes to ODBC 2<i>.x</i> codes. Since the ODBC 3.x Driver Manager will perform mapping from ODBC 2.<i>x </i>SQLSTATEs to ODBC 3.<i>x</i> SQLSTATEs, these application writers need only check for the ODBC 3.<i>x</i> SQLSTATEs and not worry about including ODBC 2.<i>x </i>SQLSTATEs in conditional code.<br><br></li>
<li>
If an application makes great use of date, time, and timestamp data types, the application can declare itself to be an ODBC 2.<i>x </i>application and use its existing code, instead of using conditioning code.</li>
</ul>
<p>
The upgrade should also include the following steps:
<ul type=disc>
<li>
Call <b>SQLSetEnvAttr</b> before allocating a connection to set the SQL_ATTR_ODBC_VERSION environment attribute to SQL_OV_ODBC2.<br><br></li>
<li>
Replace all calls to <b>SQLAllocEnv</b>, <b>SQLAllocConnect</b>, or<b> SQLAllocStmt</b> with calls to <b>SQLAllocHandle</b> with the appropriate <i>HandleType</i> argument of SQL_HANDLE_ENV, SQL_HANDLE_DBC, or SQL_HANDLE_STMT.<br><br></li>
<li>
Replace all calls to <b>SQLFreeEnv</b> or <b>SQLFreeConnect</b> with calls to <b>SQLFreeHandle</b> with the appropriate <i>HandleType</i> argument of SQL_HANDLE_DBC or SQL_HANDLE_STMT.<br><br></li>
<li>
Replace all calls to <b>SQLSetConnectOption</b> with calls to <b>SQLSetConnectAttr</b>. If setting an attribute whose value is a string, set the <i>StringLength</i> argument appropriately. Change <i>Attribute</i> argument from SQL_XXXX to SQL_ATTR_XXXX.<br><br></li>
<li>
Replace all calls to <b>SQLGetConnectOption</b> with calls to <b>SQLGetConnectAttr</b>. If getting a string or binary attribute, set <i>BufferLength</i> to the appropriate value and pass in a <i>StringLength</i> argument. Change <i>Attribute</i> argument from SQL_XXXX to SQL_ATTR_XXXX.<br><br></li>
<li>
Replace all calls to <b>SQLSetStmtOption</b> with calls to <b>SQLSetStmtAttr</b>. If setting an attribute whose value is a string, set the <i>StringLength</i> argument appropriately. Change <i>Attribute</i> argument from SQL_XXXX to SQL_ATTR_XXXX.<br><br></li>
<li>
Replace all calls to <b>SQLGetStmtOption</b> with calls to <b>SQLGetStmtAttr</b>. If getting a string or binary attribute, set <i>BufferLength</i> to the appropriate value and pass in a <i>StringLength</i> argument. Change <i>Attribute</i> argument from SQL_XXXX to SQL_ATTR_XXXX.<br><br></li>
<li>
Replace all calls to <b>SQLTransact</b> with calls to <b>SQLEndTran</b>. If the rightmost valid handle in the <b>SQLTransact</b> call is an environment handle, then a <i>HandleType</i> argument of SQL_HANDLE_ENV should be used in the <b>SQLEndTran</b> call with the appropriate <i>Handle</i> argument. If the rightmost valid handle in your <b>SQLTransact</b> call is a connection handle, then a <i>HandleType</i> argument of SQL_HANDLE_DBC should be used in the <b>SQLEndTran</b> call with the appropriate <i>Handle</i> argument. <br><br></li>
<li>
Replace all calls to <b>SQLColAttributes</b> with calls to <b>SQLColAttribute</b>. If the <i>FieldIdentifier</i> argument is either SQL_COLUMN_PRECISION, SQL_COLUMN_SCALE, or SQL_COLUMN_LENGTH, then do not change anything other than the name of the function. If not, change <i>FieldIdentifier</i> from SQL_COLUMN_XXXX to SQL_DESC_XXXX. If <i>FieldIdentifier</i> is SQL_DESC_CONCISE_TYPE and the data type is a datetime data type, change to the corresponding ODBC 3.x data type.<br><br></li>
<li>
If using block cursors, scrollable cursors, or both then the application:<ul type=disc>
<li>
Sets the rowset size, cursor type, and cursor concurrency using <b>SQLSetStmtAttr</b>. <br><br></li>
<li>
Calls <b>SQLSetStmtAttr</b> to set SQL_ATTR_ROW_STATUS_PTR to point to an array of status records. <br><br></li>
<li>
Calls <b>SQLSetStmtAttr</b> to set SQL_ATTR_ROWS_FETCHED_PTR to point to an SQLINTEGER.<br><br></li>
<li>
Performs the required bindings and executes the SQL statement.<br><br></li>
<li>
Calls <b>SQLFetchScroll</b> in a loop to fetch rows and move around in the result set.<br><br></li>
<li>
If it wants to fetch by bookmark, then the application calls <b>SQLSetStmtAttr</b> to set SQL_ATTR_FETCH_BOOKMARK_PTR to a variable that will contain the bookmark for the row that it wants to fetch, and calls <b>SQLFetchScroll</b> with a <i>FetchOrientation</i> argument of SQL_FETCH_BOOKMARK.</li>
</ul>
</li>
<li>
If using arrays of parameters, then the application:<ul type=disc>
<li>
Calls <b>SQLSetStmtAttr</b> to set the SQL_ATTR_PARAMSET_SIZE attribute to the size of the parameter array.<br><br></li>
<li>
Calls <b>SQLSetStmtAttr</b> to set SQL_ATTR_ROWS_PROCESSED_PTR to point to an internal UDWORD variable.<br><br></li>
<li>
Performs prepare, bind, and execute operations as appropriate.<br><br></li>
<li>
If execution halts for some reason (such as SQL_NEED_DATA), it can find the "current" row of parameters by inspecting the location pointed to by SQL_ATTR_ROWS_PROCESSED_PTR.</li>
</ul>
</li>
</ul>
</font></BODY>
</HTML>
