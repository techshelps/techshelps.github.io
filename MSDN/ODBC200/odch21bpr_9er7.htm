<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SQLBulkOperations</title>
<link disabled rel=stylesheet href=msdn_ie3.css>
<style type="text/css">
@import url(msdn_ie4.css);
</style>
</HEAD>
<BODY>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->


<h1><a name="odbcsqlbulkoperations"></a>SQLBulkOperations</h1>
<p class=label>
<b>Conformance</b></p>
<p>
Version Introduced:ODBC 3.0<br>
Standards Compliance:ODBC</p>
<p class=label>
<b>Summary</b></p>
<p>
<b>SQLBulkOperations</b> performs bulk insertions and bulk bookmark operations, including update, delete, and fetch by bookmark.</p>
<p class=label>
<b>Syntax</b></p>
<p>
SQLRETURN <b>SQLBulkOperations</b>(<br>
SQLHSTMT<i>StatementHandle</i>,<br>
SQLUSMALLINT<i>Operation</i>);</p>
<p class=label>
<b>Arguments</b></p>
<p class=dt>
<i>StatementHandle</i></p>
<p class=indent>
[Input]<br>
Statement handle.</p>
<p class=dt>
<i>Operation</i></p>
<p class=indent>
[Input]<br>
Operation to perform:</p>
<p class=tl>
SQL_ADD<br>
SQL_UPDATE_BY_BOOKMARK<br>
SQL_DELETE_BY_BOOKMARK<br>
SQL_FETCH_BY_BOOKMARK</P><p class=tl>
For more information, see “Comments.”</P><p class=label>
<b>Returns</b></p>
<p>
SQL_SUCCESS, SQL_SUCCESS_WITH_INFO, SQL_NEED_DATA, SQL_STILL_EXECUTING, SQL_ERROR, or SQL_INVALID_HANDLE.</p>
<p class=label>
<b>Diagnostics</b></p>
<p>
When <b>SQLBulkOperations</b> returns SQL_ERROR or SQL_SUCCESS_WITH_INFO, an associated SQLSTATE value can be obtained by calling <b>SQLGetDiagRec</b> with a <i>HandleType</i> of SQL_HANDLE_STMT and a <i>Handle</i> of <i>StatementHandle</i>. The following table lists the SQLSTATE values commonly returned by <b>SQLBulkOperations</b> and explains each one in the context of this function; the notation “(DM)” precedes the descriptions of SQLSTATEs returned by the Driver Manager. The return code associated with each SQLSTATE value is SQL_ERROR, unless noted otherwise. </p>
<p>
For all those SQLSTATEs that can return SQL_SUCCESS_WITH_INFO or SQL_ERROR (except 01xxx SQLSTATEs), SQL_SUCCESS_WITH_INFO is returned if an error occurs on one or more, but not all, rows of a multirow operation, and SQL_ERROR is returned if an error occurs on a single-row operation.</p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows width=595>
<tr valign=top>
<td class=label width=22%><b>SQLSTATE</b></td>
<td class=label width=26%><b>Error</b></td>
<td class=label width=52%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=22%>01000</td>
<td width=26%>General warning</td>
<td width=52%>Driver-specific informational message. (Function returns SQL_SUCCESS_WITH_INFO.)</td>
</tr>
<tr valign=top>
<td width=22%>01004</td>
<td width=26%>String data right truncation</td>
<td width=52%>The <i>Operation</i> argument was SQL_FETCH_BY_BOOKMARK, and string or binary data returned for a column or columns with a data type of SQL_C_CHAR or SQL_C_BINARY resulted in the truncation of non-blank character or non-NULL binary data.</td>
</tr>
<tr valign=top>
<td width=22%>01S01</td>
<td width=26%>Error in row</td>
<td width=52%>The <i>Operation</i> argument was SQL_ADD, and an error occurred in one or more rows while performing the operation, but at least one row was successfully added. (Function returns SQL_SUCCESS_WITH_INFO.)<p>
(This error is raised only when an application is working with an ODBC 2.<i>x</i> driver.)</p>
</td>
</tr>
<tr valign=top>
<td width=22%>01S07</td>
<td width=26%>Fractional truncation</td>
<td width=52%>The <i>Operation</i> argument was SQL_FETCH_BY_BOOKMARK, the data type of the application buffer was not SQL_C_CHAR or SQL_C_BINARY, and the data returned to application buffers for one or more columns was truncated. (For numeric C data types, the fractional part of the number was truncated. For time, timestamp, and interval C data types containing a time component, the fractional portion of the time was truncated.) <p>
(Function returns SQL_SUCCESS_WITH_INFO.)</p>
</td>
</tr>
<tr valign=top>
<td width=22%>07006</td>
<td width=26%>Restricted data type attribute violation</td>
<td width=52%>The <i>Operation</i> argument was SQL_FETCH_BY_BOOKMARK, and the data value of a column in the result set could not be converted to the data type specified by the <i>TargetType</i> argument in the call to <b>SQLBindCol</b>.<p>
The <i>Operation</i> argument was SQL_UPDATE_BY_BOOKMARK or SQL_ADD, and the data value in the application buffers could not be converted to the data type of a column in the result set.</p>
</td>
</tr>
<tr valign=top>
<td width=22%>07009</td>
<td width=26%>Invalid descriptor index</td>
<td width=52%>The argument <i>Operation</i> was SQL_ADD and a column was bound with a column number greater than the number of columns in the result set.</td>
</tr>
<tr valign=top>
<td width=22%>21S02</td>
<td width=26%>Degree of derived table does not match column list</td>
<td width=52%>The argument <i>Operation</i> was SQL_UPDATE_BY_BOOKMARK; and no columns were updatable because all columns were either unbound, read-only, or the value in the bound length/indicator buffer was SQL_COLUMN_IGNORE.</td>
</tr>
<tr valign=top>
<td width=22%>22001</td>
<td width=26%>String data right truncation</td>
<td width=52%>The assignment of a character or binary value to a column in the result set resulted in the truncation of non-blank (for characters) or non-null (for binary) characters or bytes.</td>
</tr>
<tr valign=top>
<td width=22%>22003</td>
<td width=26%>Numeric value out of range</td>
<td width=52%>The <i>Operation</i> argument was SQL_ADD or SQL_UPDATE_BY_BOOKMARK, and the assignment of a numeric value to a column in the result set caused the whole (as opposed to fractional) part of the number to be truncated.<p>
The argument <i>Operation</i> was SQL_FETCH_BY_BOOKMARK, and returning the numeric value for one or more bound columns would have caused a loss of significant digits.</p>
</td>
</tr>
<tr valign=top>
<td width=22%>22007</td>
<td width=26%>Invalid datetime format</td>
<td width=52%>The <i>Operation</i> argument was SQL_ADD or SQL_UPDATE_BY_BOOKMARK, and the assignment of a date or timestamp value to a column in the result set caused the year, month, or day field to be out of range.<p>
The argument <i>Operation</i> was SQL_FETCH_BY_BOOKMARK, and returning the date or timestamp value for one or more bound columns would have caused the year, month, or day field to be out of range.</p>
</td>
</tr>
<tr valign=top>
<td width=22%>22008</td>
<td width=26%>Date/time field overflow</td>
<td width=52%>The <i>Operation</i> argument was SQL_ADD or SQL_UPDATE_BY_BOOKMARK, and the performance of datetime arithmetic on data being sent to a column in the result set resulted in a datetime field (the year, month, day, hour, minute, or second field) of the result being outside the permissible range of values for the field, or being invalid based on the natural rules for datetimes based on the Gregorian calendar.<p>
The <i>Operation</i> argument was SQL_FETCH_BY_BOOKMARK, and the performance of datetime arithmetic on data being retrieved from the result set resulted in a datetime field (the year, month, day, hour, minute, or second field) of the result being outside the permissible range of values for the field, or being invalid based on the natural rules for datetimes based on the Gregorian calendar.</p>
</td>
</tr>
<tr valign=top>
<td width=22%>22015</td>
<td width=26%>Interval field overflow</td>
<td width=52%>The <i>Operation</i> argument was SQL_ADD or SQL_UPDATE_BY_BOOKMARK, and the assignment of an exact numeric or interval C type to an interval SQL data type caused a loss of significant digits.<p>
The <i>Operation</i> argument was SQL_ADD or SQL_UPDATE_BY_BOOKMARK; when assigning to an interval SQL type, there was no representation of the value of the C type in the interval SQL type.</p>
<p>
The <i>Operation</i> argument was SQL_FETCH_BY_BOOKMARK, and assigning from an exact numeric or interval SQL type to an interval C type caused a loss of significant digits in the leading field.</p>
<p>
The <i>Operation</i> argument was SQL_FETCH_BY_BOOKMARK; when assigning to an interval C type, there was no representation of the value of the SQL type in the interval C type.</p>
</td>
</tr>
<tr valign=top>
<td width=22%>22018</td>
<td width=26%>Invalid character value for cast specification</td>
<td width=52%>The <i>Operation</i> argument was SQL_FETCH_BY_BOOKMARK; the C type was an exact or approximate numeric, a datetime, or an interval data type; the SQL type of the column was a character data type; and the value in the column was not a valid literal of the bound C type.<p>
The argument <i>Operation</i> was SQL_ADD or SQL_UPDATE_BY_BOOKMARK; the SQL type was an exact or approximate numeric, a datetime, or an interval data type; the C type was SQL_C_CHAR; and the value in the column was not a valid literal of the bound SQL type. </p>
</td>
</tr>
<tr valign=top>
<td width=22%>23000</td>
<td width=26%>Integrity constraint violation</td>
<td width=52%>The <i>Operation</i> argument was SQL_ADD, SQL_DELETE_BY_BOOKMARK, or SQL_UPDATE_BY_BOOKMARK, and an integrity constraint was violated.<p>
The <i>Operation</i> argument was SQL_ADD, and a column that was not bound is defined as NOT NULL and has no default.</p>
<p>
The <i>Operation</i> argument was SQL_ADD, the length specified in the bound <i>StrLen_or_IndPtr</i> buffer was SQL_COLUMN_IGNORE, and the column did not have a default value.</p>
</td>
</tr>
<tr valign=top>
<td width=22%>24000</td>
<td width=26%>Invalid cursor state</td>
<td width=52%>The <i>StatementHandle</i> was in an executed state but no result set was associated with the <i>StatementHandle</i>.</td>
</tr>
<tr valign=top>
<td width=22%>40001</td>
<td width=26%>Serialization failure</td>
<td width=52%>The transaction was rolled back due to a resource deadlock with another transaction.</td>
</tr>
<tr valign=top>
<td width=22%>40003</td>
<td width=26%>Statement completion unknown</td>
<td width=52%>The associated connection failed during the execution of this function and the state of the transaction cannot be determined.</td>
</tr>
<tr valign=top>
<td width=22%>42000</td>
<td width=26%>Syntax error or access violation</td>
<td width=52%>The driver was unable to lock the row as needed to perform the operation requested in the <i>Operation</i> argument.</td>
</tr>
<tr valign=top>
<td width=22%>44000</td>
<td width=26%>WITH CHECK OPTION violation</td>
<td width=52%>The <i>Operation</i> argument was SQL_ADD or SQL_UPDATE_BY_BOOKMARK, and the insert or update was performed on a viewed table or a table derived from the viewed table which was created by specifying <b>WITH CHECK OPTION</b>, such that one or more rows affected by the insert or update will no longer be present in the viewed table.</td>
</tr>
<tr valign=top>
<td width=22%>HY000</td>
<td width=26%>General error</td>
<td width=52%>An error occurred for which there was no specific SQLSTATE and for which no implementation-specific SQLSTATE was defined. The error message returned by <b>SQLGetDiagRec</b> in the <i>*MessageText</i> buffer describes the error and its cause.</td>
</tr>
<tr valign=top>
<td width=22%>HY001</td>
<td width=26%>Memory allocation error</td>
<td width=52%>The driver was unable to allocate memory required to support execution or completion of the function.</td>
</tr>
<tr valign=top>
<td width=22%>HY008</td>
<td width=26%>Operation canceled</td>
<td width=52%>Asynchronous processing was enabled for the <i>StatementHandle</i>. The function was called and before it completed execution, <b>SQLCancel</b> was called on the <i>StatementHandle</i>. Then the function was called again on the <i>StatementHandle</i>.<p>
The function was called and, before it completed execution, <b>SQLCancel</b> was called on the <i>StatementHandle</i> from a different thread in a multithread application.</p>
</td>
</tr>
<tr valign=top>
<td width=22%>HY010</td>
<td width=26%>Function sequence error</td>
<td width=52%>(DM) The specified <i>StatementHandle</i> was not in an executed state. The function was called without first calling <b>SQLExecDirect</b>, <b>SQLExecute</b>, or a catalog function.<p>
(DM) An asynchronously executing function (not this one) was called for the <i>StatementHandle</i> and was still executing when this function was called.</p>
<p>
(DM) <b>SQLExecute</b>, <b>SQLExecDirect</b>, or <b>SQLSetPos</b> was called for the <i>StatementHandle</i> and returned SQL_NEED_DATA. This function was called before data was sent for all data-at-execution parameters or columns.</p>
<p>
(DM) The driver was an ODBC 2.<i>x</i> driver and <b>SQLBulkOperations</b> was called for a <i>StatementHandle</i> before <b>SQLFetchScroll</b> or <b>SQLFetch</b> was called.</p>
<p>
(DM) <b>SQLBulkOperations</b> was called after <b>SQLExtendedFetch</b> was called on the <i>StatementHandle</i>.</p>
</td>
</tr>
<tr valign=top>
<td width=22%>HY011</td>
<td width=26%>Attribute cannot be set now</td>
<td width=52%>(DM) The driver was an ODBC 2<i>.x</i> driver, and the SQL_ATTR_ROW_STATUS_PTR statement attribute was set between calls to <b>SQLFetch</b> or <b>SQLFetchScroll</b> and <b>SQLBulkOperations</b>.</td>
</tr>
<tr valign=top>
<td width=22%>HY013</td>
<td width=26%>Memory management error</td>
<td width=52%>The function call could not be processed because the underlying memory objects could not be accessed, possibly because of low memory conditions.</td>
</tr>
<tr valign=top>
<td width=22%>HY090</td>
<td width=26%>Invalid string or buffer length</td>
<td width=52%>The <i>Operation</i> argument was SQL_ADD or SQL_UPDATE_BY_BOOKMARK, a data value was a null pointer, and the column length value was not 0, SQL_DATA_AT_EXEC, SQL_COLUMN_IGNORE, SQL_NULL_DATA, or less than or equal to SQL_LEN_DATA_AT_EXEC_OFFSET.<p>
The <i>Operation</i> argument was SQL_ADD or SQL_UPDATE_BY_BOOKMARK, a data value was not a null pointer; the C data type was SQL_C_BINARY or SQL_C_CHAR; and the column length value was less than 0, but not equal to SQL_DATA_AT_EXEC, SQL_COLUMN_IGNORE, SQL_NTS, or SQL_NULL_DATA, or less than or equal to SQL_LEN_DATA_AT_EXEC_OFFSET.</p>
<p>
The value in a length/indicator buffer was SQL_DATA_AT_EXEC; the SQL type was either SQL_LONGVARCHAR, SQL_LONGVARBINARY, or a long, data source&nbsp;–&nbsp;specific data type; and the SQL_NEED_LONG_DATA_LEN information type in <b>SQLGetInfo</b> was "Y".</p>
<p>
The <i>Operation</i> argument was SQL_ADD, the SQL_ATTR_USE_BOOKMARK statement attribute was set to SQL_UB_VARIABLE, and column 0 was bound to a buffer whose length was not equal to the maximum length for the bookmark for this result set. (This length is available in the SQL_DESC_OCTET_LENGTH field of the IRD, and can be obtained by calling <b>SQLDescribeCol</b>, <b>SQLColAttribute</b>, or <b>SQLGetDescField</b>.)</p>
</td>
</tr>
<tr valign=top>
<td width=22%>HY092</td>
<td width=26%>Invalid attribute identifier</td>
<td width=52%>(DM) The value specified for the <i>Operation</i> argument was invalid.<p>
The <i>Operation</i> argument was SQL_ADD, SQL_UPDATE_BY_BOOKMARK, or SQL_DELETE_BY_BOOKMARK, and the SQL_ATTR_CONCURRENCY statement attribute was set to SQL_CONCUR_READ_ONLY.</p>
<p>
The <i>Operation</i> argument was SQL_DELETE_BY_BOOKMARK, SQL_FETCH_BY_BOOKMARK, or SQL_UPDATE_BY_BOOKMARK, and the bookmark column was not bound or the SQL_ATTR_USE_BOOKMARKS statement attribute was set to SQL_UB_OFF.</p>
</td>
</tr>
<tr valign=top>
<td width=22%>HYC00</td>
<td width=26%>Optional feature not implemented</td>
<td width=52%>The driver or data source does not support the operation requested in the <i>Operation</i> argument.</td>
</tr>
<tr valign=top>
<td width=22%>HYT00</td>
<td width=26%>Timeout expired</td>
<td width=52%>The query timeout period expired before the data source returned the result set. The timeout period is set through <b>SQLSetStmtAttr </b>with an <i>Attribute</i> argument of SQL_ATTR_QUERY_TIMEOUT.</td>
</tr>
<tr valign=top>
<td width=22%>HYT01</td>
<td width=26%>Connection timeout expired</td>
<td width=52%>The connection timeout period expired before the data source responded to the request. The connection timeout period is set through <b>SQLSetConnectAttr</b>, SQL_ATTR_CONNECTION_TIMEOUT.</td>
</tr>
<tr valign=top>
<td width=22%>IM001</td>
<td width=26%>Driver does not support this function</td>
<td width=52%>(DM) The driver associated with the <i>StatementHandle</i> does not support the function.</td>
</tr>
</table><br>
<p class=label>
<b>Comments</b></p>
<p class=indent>
<B><b>Caution&nbsp;&nbsp;&nbsp;</b></B>For information about what statement states <b>SQLBulkOperations</b> can be called in and what it needs to do for compatibility with ODBC 2<i>.x</i> applications, see the “<a href="odappgpr_5drt.htm">Block Cursors, Scrollable Cursors, and Backward Compatibility</a>” section in Appendix G, “Driver Guidelines for Backward Compatibility.”</p>
<p>
An application uses <b>SQLBulkOperations</b> to perform the following operations on the base table or view that corresponds to the current query:
<ul type=disc>
<li>
Add new rows.<br><br></li>
<li>
Update a set of rows where each row is identified by a bookmark.<br><br></li>
<li>
Delete a set of rows where each row is identified by a bookmark.<br><br></li>
<li>
Fetch a set of rows where each row is identified by a bookmark.</li>
</ul>
<p>
After a call to <b>SQLBulkOperations</b>, the block cursor position is undefined. The application has to call <b>SQLFetchScroll</b> to set the cursor position. An application should only call <b>SQLFetchScroll</b> with a <i>FetchOrientation</i> argument of SQL_FETCH_FIRST, SQL_FETCH_LAST, SQL_FETCH_ABSOLUTE, or SQL_FETCH_BOOKMARK. The cursor position is undefined if the application calls <b>SQLFetch</b>, or <b>SQLFetchScroll</b> with a <i>FetchOrientation</i> argument of SQL_FETCH_PRIOR, SQL_FETCH_NEXT, or SQL_FETCH_RELATIVE.</p>
<p>
A column can be ignored in bulk operations performed by a call to <b>SQLBulkOperations</b> by setting the column length/indicator buffer specified in the call to <b>SQLBindCol</b>, to SQL_COLUMN_IGNORE.</p>
<p>
It is not necessary for the application to set the SQL_ATTR_ROW_OPERATION_PTR statement attribute when calling <b>SQLBulkOperations</b> because rows cannot be ignored when performing bulk operations with this function.</p>
<p>
The buffer pointed to by the SQL_ATTR_ROWS_FETCHED_PTR statement attribute contains the number of rows affected by a call to <b>SQLBulkOperations</b>.</p>
<p>
When the <i>Operation</i> argument is SQL_ADD or SQL_UPDATE_BY_BOOKMARK, and the select-list of the query specification associated with the cursor contains more than one reference to the same column, it is driver-defined whether:
<ul type=disc>
<li>
An error is generated, or<br><br></li>
<li>
The driver ignores the duplicated references and performs the requested operations.</li>
</ul>
<p>
For more information about using <b>SQLBulkOperations</b>, see “<a href="odch12pr_4lwz.htm">Updating Data with SQLBulkOperations</a>” in Chapter 12, “Updating Data.”</p>
<h1>Performing Bulk Inserts</h1>
<p>
To insert data with <b>SQLBulkOperations</b>, an application performs the following sequence of steps:
<ol>
<li>
Executes a query that returns a result set.<br><br></li>
<li>
Sets the SQL_ATTR_ROW_ARRAY_SIZE statement attribute to the number of rows that it wants to insert.<br><br></li>
<li>
Calls <b>SQLBindCol</b> to bind the data that it wants to insert. The data is bound to an array with a size equal to the value of SQL_ATTR_ROW_ARRAY_SIZE.<p class=atl>
<B><b>Note&nbsp;&nbsp;&nbsp;</b></B>The size of the array pointed to by the SQL_ATTR_ROW_STATUS_PTR statement attribute should either be equal to SQL_ATTR_ROW_ARRAY_SIZE or SQL_ATTR_ROW_STATUS_PTR should be a null pointer. </p></li>
<li>
Calls <b>SQLBulkOperations</b>(<i>StatementHandle, </i>SQL_ADD<i>)</i> to perform the insertion.<br><br></li>
<li>
If the application has set the SQL_ATTR_ROW_STATUS_PTR statement attribute, then it can inspect this array to see the result of the operation. </li>
</ol>
<p>
If an application binds column 0 before calling <b>SQLBulkOperations</b> with an <i>Operation</i> argument of SQL_ADD, the driver will update the bound column 0 buffers with the bookmark values for the newly inserted row. For this to occur, the application must have set SQL_ATTR_USE_BOOKMARKS statement attribute to SQL_UB_VARIABLE before executing the statement. (This does not work with an ODBC 2.<i>x</i> driver.)</p>
<p>
Long data can be added in parts by <b>SQLBulkOperations</b> using calls to <b>SQLParamData</b> and <b>SQLPutData</b>. For more information, see “Providing Long Data for Bulk Inserts and Updates” later in this function reference.</p>
<p>
It is not necessary for the application to call <b>SQLFetch</b> or <b>SQLFetchScroll</b> before calling <b>SQLBulkOperations</b> (except when going against an ODBC 2.<i>x</i> driver; see “<a href="odch17pr_0m1x.htm">Backward Compatibility and Standards Compliance</a>” in Chapter 17, “Programming Considerations”). </p>
<p>
It is driver-defined what the behavior is if <b>SQLBulkOperations</b> with an <i>Operation</i> argument of SQL_ADD is called on a cursor that contains duplicate columns. The driver can return a driver-defined SQLSTATE, add the data to the first column that appears in the result set, or perform other driver-defined behavior.</p>
<h1>Performing Bulk Updates Using Bookmarks</h1>
<p>
To perform bulk updates using bookmarks with <b>SQLBulkOperations</b>, an application performs the following steps in sequence:
<ol>
<li>
Sets the SQL_ATTR_USE_BOOKMARKS statement attribute to SQL_UB_VARIABLE.<br><br></li>
<li>
Executes a query that returns a result set.<br><br></li>
<li>
Sets the SQL_ATTR_ROW_ARRAY_SIZE statement attribute to the number of rows that it wants to update.<p class=tl>
Calls <b>SQLBindCol</b> to bind the data that it wants to update. The data is bound to an array with a size equal to the value of SQL_ATTR_ROW_ARRAY_SIZE. It also calls <b>SQLBindCol</b> to bind column 0 (the bookmark column).</P></li>
<li>
Copies the bookmarks for rows that it is interested in updating into the array bound to column 0.<br><br></li>
<li>
Updates the data in the bound buffers.<p class=atl>
<B><b>Note</b></B> The size of the array pointed to by the SQL_ATTR_ROW_STATUS_PTR statement attribute should either be equal to SQL_ATTR_ROW_ARRAY_SIZE or SQL_ATTR_ROW_STATUS_PTR should be a null pointer.</p></li>
<li>
Calls <b>SQLBulkOperations</b>(<i>StatementHandle, </i>SQL_UPDATE_BY_BOOKMARK).</li>
</ol>
<p class=indent>
<B><b>Note&nbsp;&nbsp;&nbsp;</b></B>If the application has set the SQL_ATTR_ROW_STATUS_PTR statement attribute, then it can inspect this array to see the result of the operation.</p>
<p>
Optionally calls <b>SQLBulkOperations</b>(<i>StatementHandle</i>, SQL_FETCH_BY_BOOKMARK) to fetch data into the bound application buffers to verify that the update has occurred.</p>
<p>
If data has been updated, the driver changes the value in the row status array for the appropriate rows to SQL_ROW_UPDATED.</p>
<p>
Bulk updates performed by <b>SQLBulkOperations</b> can include long data by using calls to <b>SQLParamData</b> and <b>SQLPutData</b>. For more information, see “Providing Long Data for Bulk Inserts and Updates” later in this function reference.</p>
<p>
If bookmarks persist across cursors, then there is no need for the application to call <b>SQLFetch</b> or <b>SQLFetchScroll</b> before updating by bookmarks. It can use bookmarks that it has stored from a previous cursor. If bookmarks do not persist across cursors, then the application has to call <b>SQLFetch</b> or <b>SQLFetchScroll</b> to retrieve the bookmarks.</p>
<p>
It is driver-defined what the behavior is if <b>SQLBulkOperations</b> with an <i>Operation</i> argument of SQL_UPDATE_BY_BOOKMARK is called on a cursor that contains duplicate columns. The driver can return a driver-defined SQLSTATE, update the first column that appears in the result set, or perform other driver-defined behavior.</p>
<h1>Performing Bulk Fetches Using Bookmarks</h1>
<p>
To perform bulk fetches using bookmarks with <b>SQLBulkOperations</b>, an application performs the following steps in sequence:
<ol>
<li>
Sets the SQL_ATTR_USE_BOOKMARKS statement attribute to SQL_UB_VARIABLE.<br><br></li>
<li>
Executes a query that returns a result set.<br><br></li>
<li>
Sets the SQL_ATTR_ROW_ARRAY_SIZE statement attribute to the number of rows that it wants to fetch.<br><br></li>
<li>
Calls <b>SQLBindCol</b> to bind the data that it wants to fetch. The data is bound to an array with a size equal to the value of SQL_ATTR_ROW_ARRAY_SIZE. It also calls <b>SQLBindCol</b> to bind column 0 (the bookmark column).<br><br></li>
<li>
Copies the bookmarks for rows that it is interested in fetching into the array bound to column 0. (This assumes that the application has already obtained the bookmarks separately.)<p class=atl>
<B><b>Note&nbsp;&nbsp;&nbsp;</b></B>The size of the array pointed to by the SQL_ATTR_ROW_STATUS_PTR statement attribute should either be equal to SQL_ATTR_ROW_ARRAY_SIZE or SQL_ATTR_ROW_STATUS_PTR should be a null pointer.</p></li>
<li>
Calls <b>SQLBulkOperations</b>(<i>StatementHandle, </i>SQL_FETCH_BY_BOOKMARK).<br><br></li>
<li>
If the application has set the SQL_ATTR_ROW_STATUS_PTR statement attribute, then it can inspect this array to see the result of the operation.</li>
</ol>
<p>
If bookmarks persist across cursors, then there is no need for the application to call <b>SQLFetch</b> or <b>SQLFetchScroll</b> before fetching by bookmarks. It can use bookmarks that it has stored from a previous cursor. If bookmarks do not persist across cursors, then the application has to call <b>SQLFetch</b> or <b>SQLFetchScroll </b>once to retrieve the bookmarks.</p>
<h1>Performing Bulk Deletes Using Bookmarks</h1>
<p>
To perform bulk deletes using bookmarks with <b>SQLBulkOperations</b>, an application performs the following steps in sequence:
<ol>
<li>
Sets the SQL_ATTR_USE_BOOKMARKS statement attribute to SQL_UB_VARIABLE.<br><br></li>
<li>
Executes a query that returns a result set.<br><br></li>
<li>
Sets the SQL_ATTR_ROW_ARRAY_SIZE statement attribute to the number of rows that it wants to delete.<br><br></li>
<li>
Calls <b>SQLBindCol</b> to bind column 0 (the bookmark column).<br><br></li>
<li>
Copies the bookmarks for rows that it is interested in deleting into the array bound to column 0.<p class=atl>
<B><b>Note</b></B> The size of the array pointed to by the SQL_ATTR_ROW_STATUS_PTR statement attribute should either be equal to SQL_ATTR_ROW_ARRAY_SIZE or SQL_ATTR_ROW_STATUS_PTR should be a null pointer.</p></li>
<li>
Calls <b>SQLBulkOperations</b>(<i>StatementHandle, </i>SQL_DELETE_BY_BOOKMARK).<br><br></li>
<li>
If the application has set the SQL_ATTR_ROW_STATUS_PTR statement attribute, then it can inspect this array to see the result of the operation.</li>
</ol>
<p>
If bookmarks persist across cursors, then there is no need for the application to call <b>SQLFetch</b> or <b>SQLFetchScroll</b> before deleting by bookmarks. It can use bookmarks that it has stored from a previous cursor. If bookmarks do not persist across cursors, then the application has to call <b>SQLFetch</b> or <b>SQLFetchScroll </b>once to retrieve the bookmarks.</p>
<h1>Providing Long Data for Bulk Inserts and Updates</h1>
<p>
Long data can be provided for bulk inserts and updates performed by calls to <b>SQLBulkOperations</b>. To insert or update long data, an application performs the following steps in addition to the steps described in the “Performing Bulk Inserts” and “Performing Bulk Updates Using Bookmarks” sections earlier in this section.
<ol>
<li>
When it binds the data using <b>SQLBindCol</b>, the application places an application-defined value, such as the column number, in the <i>*TargetValuePtr</i> buffer for data-at-execution columns. The value can be used later to identify the column.<p class=tl>
The application places the result of the SQL_LEN_DATA_AT_EXEC(<i>length</i>) macro in the <i>*StrLen_or_IndPtr</i> buffer. If the SQL data type of the column is SQL_LONGVARBINARY, SQL_LONGVARCHAR, or a long, data source&nbsp;–&nbsp;specific data type and the driver returns “Y” for the SQL_NEED_LONG_DATA_LEN information type in <b>SQLGetInfo</b>, <i>length</i> is the number of bytes of data to be sent for the parameter; otherwise, it must be a nonnegative value and is ignored.</P></li>
<li>
When <b>SQLBulkOperations</b> is called, if there are data-at-execution columns, the function returns SQL_NEED_DATA and proceeds to step 3 below. (If there are no data-at-execution columns, the process is complete.)<br><br></li>
<li>
The application calls <b>SQLParamData</b> to retrieve the address of the <i>*TargetValuePtr</i> buffer for the first data-at-execution column to be processed. <b>SQLParamData</b> returns SQL_NEED_DATA. The application retrieves the application-defined value from the <i>*TargetValuePtr</i> buffer.<p class=atl>
<B><b>Note&nbsp;&nbsp;&nbsp;</b></B>Although data-at-execution parameters are similar to data-at-execution columns, the value returned by <b>SQLParamData</b> is different for each.</p><p class=tl>
Data-at-execution columns are columns in a rowset for which data will be sent with <b>SQLPutData</b> when a row is updated or inserted with <b>SQLBulkOperations</b>. They are bound with <b>SQLBindCol</b>. The value returned by <b>SQLParamData</b> is the address of the row in the *<i>TargetValuePtr</i> buffer that is being processed.</P></li>
<li>
The application calls <b>SQLPutData</b> one or more times to send data for the column. More than one call is needed if all the data value cannot be returned in the <i>*TargetValuePtr</i> buffer specified in <b>SQLPutData</b>; note that multiple calls to <b>SQLPutData</b> for the same column are allowed only when sending character C data to a column with a character, binary, or data source&nbsp;–&nbsp;specific data type or when sending binary C data to a column with a character, binary, or data source&nbsp;–&nbsp;specific data type.<br><br></li>
<li>
The application calls <b>SQLParamData</b> again to signal that all data has been sent for the column.<ul type=disc>
<li>
If there are more data-at-execution columns, <b>SQLParamData</b> returns SQL_NEED_DATA and the address of the <i>TargetValuePtr</i> buffer for the next data-at-execution column to be processed. The application repeats steps 4 and 5.<br><br></li>
<li>
If there are no more data-at-execution columns, the process is complete. If the statement was executed successfully, <b>SQLParamData</b> returns SQL_SUCCESS or SQL_SUCCESS_WITH_INFO; if the execution failed, it returns SQL_ERROR. At this point, <b>SQLParamData</b> can return any SQLSTATE that can be returned by <b>SQLBulkOperations</b>.</li>
</ul>
</li>
</ol>
<p>
If the operation is canceled, or an error occurs in <b>SQLParamData</b> or <b>SQLPutData</b>, after <b>SQLBulkOperations</b> returns SQL_NEED_DATA, and before data is sent for all data-at-execution columns, the application can call only <b>SQLCancel</b>, <b>SQLGetDiagField</b>, <b>SQLGetDiagRec</b>, <b>SQLGetFunctions</b>, <b>SQLParamData</b>, or <b>SQLPutData</b> for the statement or the connection associated with the statement. If it calls any other function for the statement or the connection associated with the statement, the function returns SQL_ERROR and SQLSTATE HY010 (Function sequence error).</p>
<p>
If the application calls <b>SQLCancel</b> while the driver still needs data for data-at-execution columns, the driver cancels the operation. The application can then call <b>SQLBulkOperations</b> again; canceling does not affect the cursor state or the current cursor position.</p>
<h1>Row Status Array</h1>
<p>
The row status array contains status values for each row of data in the rowset after a call to <b>SQLBulkOperations</b>. The driver sets the status values in this array after a call to <b>SQLFetch</b>, <b>SQLFetchScroll</b>, <b>SQLSetPos</b>, or <b>SQLBulkOperations</b>. This array is initially populated by a call to <b>SQLBulkOperations</b> if <b>SQLFetch</b> or <b>SQLFetchScroll</b> has not been called prior to <b>SQLBulkOperations</b>. This array is pointed to by the SQL_ATTR_ROW_STATUS_PTR statement attribute. The number of elements in the row status arrays must equal the number of rows in the rowset (as defined by the SQL_ATTR_ROW_ARRAY_SIZE statement attribute). For information about this row status array, see <a href="odch21epr_4zoo.htm">SQLFetch</a>.</p>
<p class=label>
<b>Code Example</b></p>
<p>
The following example fetches 10 rows of data at a time from the Customers table. It then prompts the user for an action to take. To reduce network traffic, the example buffer updates, deletes, and inserts locally in the bound arrays, but at offsets past the rowset data. When the user chooses to send updates, deletes, and inserts to the data source, the code sets the binding offset appropriately and calls <b>SQLBulkOperations</b>. For simplicity, the user cannot buffer more than 10 updates, deletes, or inserts.</p>
<pre><code>#define UPDATE_ROW&nbsp;&nbsp;&nbsp; 100
#define DELETE_ROW&nbsp;&nbsp;&nbsp; 101
#define ADD_ROW&nbsp;&nbsp;&nbsp;&nbsp; 102
#define SEND_TO_DATA_SOURCE 103

#define UPDATE_OFFSET 10
#define INSERT_OFFSET 20
#define DELETE_OFFSET 30

// Define a structure to hold the customer data.&nbsp; Assume we know the maximum bookmark
// size to be 10 bytes.
typedef tagCustStruct {
 SQLCHAR&nbsp;&nbsp; Bookmark[10];
 SQLINTEGER&nbsp; BookmarkLen;
 SQLUINTEGER CustID;
 SQLINTEGER&nbsp; CustIDInd;
 SQLCHAR&nbsp;&nbsp; Name[51];
 SQLINTEGER&nbsp; NameLenOrInd;
 SQLCHAR&nbsp;&nbsp; Address[51];
 SQLINTEGER&nbsp; AddressLenOrInd;
 SQLCHAR&nbsp;&nbsp; Phone[11];
 SQLINTEGER&nbsp; PhoneLenOrInd;
} CustStruct;

// Allocate 40 of these structures. Elements 0-9 are for the current rowset,
// elements 10-19 are for the buffered updates, elements 20-29 are for
// the buffered inserts, and elements 30-39 are for the buffered deletes.
CustStruct CustArray[40];

SQLUSMALLINT RowStatusArray[10], Action, RowNum, NumUpdates = 0, NumInserts = 0,
 &nbsp;&nbsp;&nbsp; NumDeletes = 0;
SQLINTEGER BindOffset = 0;
SQLRETURN&nbsp; rc;
SQLHSTMT&nbsp;&nbsp; hstmt;

// Set the following statement attributes:
//&nbsp; SQL_ATTR_CURSOR_TYPE:&nbsp;&nbsp; Keyset-driven
//&nbsp; SQL_ATTR_ROW_BIND_TYPE:&nbsp;&nbsp; Row-wise
//&nbsp; SQL_ATTR_ROW_ARRAY_SIZE:&nbsp; 10
//&nbsp; SQL_ATTR_USE_BOOKMARKS:&nbsp;&nbsp; Use variable-length bookmarks
//&nbsp; SQL_ATTR_ROW_STATUS_PTR:&nbsp; Points to RowStatusArray
//&nbsp; SQL_ATTR_ROW_BIND_OFFSET_PTR: Points to BindOffset
SQLSetStmtAttr(hstmt, SQL_ATTR_CURSOR_TYPE, SQL_CURSOR_KEYSET_DRIVEN, 0);
SQLSetStmtAttr(hstmt, SQL_ATTR_ROW_BIND_TYPE, sizeof(CustStruct), 0);
SQLSetStmtAttr(hstmt, SQL_ATTR_ROW_ARRAY_SIZE, 10, 0);
SQLSetStmtAttr(hstmt, SQL_ATTR_USE_BOOKMARKS, SQL_UB_VARIABLE, 0);
SQLSetStmtAttr(hstmt, SQL_ATTR_ROW_STATUS_PTR, RowStatusArray, 0);
SQLSetStmtAttr(hstmt, SQL_ATTR_ROW_BIND_OFFSET_PTR, &amp;BindOffset, 0);

// Bind arrays to the bookmark, CustID, Name, Address, and Phone columns.
SQLBindCol(hstmt, 0, SQL_C_VARBOOKMARK, CustArray[0].Bookmark,
 &nbsp;&nbsp;&nbsp; sizeof(CustArray[0].Bookmark), &amp;CustArray[0].BookmarkLen);
SQLBindCol(hstmt, 1, SQL_C_ULONG, &amp;CustArray[0].CustID, 0, &amp;CustArray[0].CustIDInd);
SQLBindCol(hstmt, 2, SQL_C_CHAR, CustArray[0].Name, sizeof(CustArray[0].Name),
 &nbsp;&nbsp;&nbsp; &amp;CustArray[0].NameLenOrInd);
SQLBindCol(hstmt, 3, SQL_C_CHAR, CustArray[0].Address, sizeof(CustArray[0].Address),
 &nbsp;&nbsp;&nbsp; &amp;CustArray[0].AddressLenOrInd);
SQLBindCol(hstmt, 4, SQL_C_CHAR, CustArray[0].Phone, sizeof(CustArray[0].Phone),
 &nbsp;&nbsp;&nbsp; &amp;CustArray[0].PhoneLenOrInd);

// Execute a statement to retrieve rows from the Customers table.
SQLExecDirect(hstmt, "SELECT CustID, Name, Address, Phone FROM Customers", SQL_NTS);

// Fetch and display the first 10 rows.
rc = SQLFetchScroll(hstmt, SQL_FETCH_NEXT, 0);
DisplayCustData(CustArray, 10);

// Call GetAction to get an action and a row number from the user.
while (GetAction(&amp;Action, &amp;RowNum)) {
 switch (Action) {

  case SQL_FETCH_NEXT:
  case SQL_FETCH_PRIOR:
  case SQL_FETCH_FIRST:
  case SQL_FETCH_LAST:
  case SQL_FETCH_ABSOLUTE:
  case SQL_FETCH_RELATIVE:
 &nbsp; // Fetch and display the requested data.
 &nbsp; SQLFetchScroll(hstmt, Action, RowNum);
 &nbsp; DisplayCustData(CustArray, 10);
 &nbsp; break;

  case UPDATE_ROW:
 &nbsp; // Check if we have reached the maximum number of buffered updates.
 &nbsp; if (NumUpdates &lt; 10) {
 &nbsp;&nbsp; // Get the new customer data and place it in the next available element of
 &nbsp;&nbsp; // the buffered updates section of CustArray, copy the bookmark of the row
 &nbsp;&nbsp; // being updated to the same element, and increment the update counter.
 &nbsp;&nbsp; // Checking to see we have not already buffered an update for this
 &nbsp;&nbsp; // row not shown.
 &nbsp;&nbsp; GetNewCustData(CustArray, UPDATE_OFFSET + NumUpdates);
 &nbsp;&nbsp; memcopy(CustArray[UPDATE_OFFSET + NumUpdates].Bookmark,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CustArray[RowNum - 1].Bookmark,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CustArray[RowNum - 1].BookmarkLen);
 &nbsp;&nbsp; CustArray[UPDATE_OFFSET + NumUpdates].BookmarkLen =
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CustArray[RowNum - 1].BookmarkLen;
 &nbsp;&nbsp; NumUpdates++;
 &nbsp; } else {
 &nbsp;&nbsp; DisplayError("Buffers full. Send buffered changes to the data source.");
 &nbsp; }
 &nbsp; break;

  case DELETE_ROW:
 &nbsp; // Check if we have reached the maximum number of buffered deletes.
 &nbsp; if (NumDeletes &lt; 10) {
 &nbsp;&nbsp; // Copy the bookmark of the row being deleted to the next available element
 &nbsp;&nbsp; // of the buffered deletes section of CustArray and increment the delete
 &nbsp;&nbsp; // counter. Checking to see we have not already buffered an update for
 &nbsp;&nbsp; // this row not shown.
 &nbsp;&nbsp; memcopy(CustArray[DELETE_OFFSET + NumDeletes].Bookmark,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CustArray[RowNum - 1].Bookmark,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CustArray[RowNum - 1].BookmarkLen);
 &nbsp;&nbsp; CustArray[DELETE_OFFSET + NumDeletes].BookmarkLen =
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CustArray[RowNum - 1].BookmarkLen;
 &nbsp;&nbsp; NumDeletes++;
 &nbsp; } else {
 &nbsp;&nbsp; DisplayError("Buffers full. Send buffered changes to the data source.");
 &nbsp; }
 &nbsp; break;
  case ADD_ROW:
 &nbsp; // Check if we have reached the maximum number of buffered inserts.
 &nbsp; if (NumInserts &lt; 10) {
 &nbsp;&nbsp; // Get the new customer data and place it in the next available element of
 &nbsp;&nbsp; // the buffered inserts section of CustArray and increment the insert
 &nbsp;&nbsp; // counter.
 &nbsp;&nbsp; GetNewCustData(CustArray, INSERT_OFFSET + NumInserts);
 &nbsp;&nbsp; NumInserts++;
 &nbsp; } else {
 &nbsp;&nbsp; DisplayError("Buffers full. Send buffered changes to the data source.");
 &nbsp; }
 &nbsp; break;

  case SEND_TO_DATA_SOURCE:
 &nbsp; // If there are any buffered updates, inserts, or deletes, set the array size
 &nbsp; // to that number, set the binding offset to use the data in the buffered
 &nbsp; // update, insert, or delete part of CustArray, and call SQLBulkOperations to
 &nbsp; // do the updates, inserts, or deletes. Because we will never have more than
 &nbsp; // 10 updates, inserts, or deletes, we can use the same row status array.
 &nbsp; if (NumUpdates) {
 &nbsp;&nbsp; SQLSetStmtAttr(hstmt, SQL_ATTR_ROW_ARRAY_SIZE, NumUpdates, 0);
 &nbsp;&nbsp; BindOffset = UPDATE_OFFSET * sizeof(CustStruct);
 &nbsp;&nbsp; SQLBulkOperations(hstmt, SQL_UPDATE_BY_BOOKMARK);
 &nbsp;&nbsp; NumUpdates = 0;
 &nbsp; }

 &nbsp; if (NumInserts) {
 &nbsp;&nbsp; SQLSetStmtAttr(hstmt, SQL_ATTR_ROW_ARRAY_SIZE, NumInserts, 0);
 &nbsp;&nbsp; BindOffset = INSERT_OFFSET * sizeof(CustStruct);
 &nbsp;&nbsp; SQLBulkOperations(hstmt, SQL_ADD);
 &nbsp;&nbsp; NumInserts = 0;
 &nbsp; }

 &nbsp; if (NumDeletes) {
 &nbsp;&nbsp; SQLSetStmtAttr(hstmt, SQL_ATTR_ROW_ARRAY_SIZE, NumDeletes, 0);
 &nbsp;&nbsp; BindOffset = DELETE_OFFSET * sizeof(CustStruct);
 &nbsp;&nbsp; SQLBulkOperations(hstmt, SQL_DELETE_BY_BOOKMARK);
 &nbsp;&nbsp; NumDeletes = 0;
 &nbsp; }

 &nbsp; // If there were any updates, inserts, or deletes, reset the binding offset
 &nbsp; // and array size to their original values.
 &nbsp; if (NumUpdates || NumInserts || NumDeletes) {
 &nbsp;&nbsp; SQLSetStmtAttr(hstmt, SQL_ATTR_ROW_ARRAY_SIZE, 10, 0);
 &nbsp;&nbsp; BindOffset = 0;
 &nbsp; }
 &nbsp; break;
 }
}

// Close the cursor.
SQLFreeStmt(hstmt, SQL_CLOSE);</code></pre>
<p class=label>
<b>Related Functions</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows width=595>
<tr valign=top>
<td class=label width=48%><b>For information about</b></td>
<td class=label width=52%><b>See</b></td>
</tr>
<tr valign=top>
<td width=48%>Binding a buffer to a column in a result set</td>
<td width=52%><a href="odch21bpr_0ht8.htm">SQLBindCol</a></td>
</tr>
<tr valign=top>
<td width=48%>Canceling statement processing</td>
<td width=52%><a href="odch21bpr_5b58.htm">SQLCancel</a></td>
</tr>
<tr valign=top>
<td width=48%>Fetching a block of data or scrolling through a result set</td>
<td width=52%><a href="odch21epr_5m24.htm">SQLFetchScroll</a></td>
</tr>
<tr valign=top>
<td width=48%>Getting a single field of a descriptor</td>
<td width=52%><a href="odch21gpr_70bo.htm">SQLGetDescField</a></td>
</tr>
<tr valign=top>
<td width=48%>Getting multiple fields of a descriptor</td>
<td width=52%><a href="odch21gpr_12ub.htm">SQLGetDescRec</a></td>
</tr>
<tr valign=top>
<td width=48%>Setting a single field of a descriptor</td>
<td width=52%><a href="odch21jpr_7e90.htm">SQLSetDescField</a></td>
</tr>
<tr valign=top>
<td width=48%>Setting multiple fields of a descriptor</td>
<td width=52%><a href="odch21jpr_0q3n.htm">SQLSetDescRec</a></td>
</tr>
<tr valign=top>
<td width=48%>Positioning the cursor, refreshing data in the rowset, or updating or deleting data in the rowset</td>
<td width=52%><a href="odch21kpr_2rsj.htm">SQLSetPos</a></td>
</tr>
<tr valign=top>
<td width=48%>Setting a statement attribute</td>
<td width=52%><a href="odch21kpr_77jm.htm">SQLSetStmtAttr</a></td>
</tr>
</table><br>
</font></BODY>
</HTML>
