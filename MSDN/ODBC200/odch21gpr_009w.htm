<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SQLGetDiagField</title>
<link disabled rel=stylesheet href=msdn_ie3.css>
<style type="text/css">
@import url(msdn_ie4.css);
</style>
</HEAD>
<BODY>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->


<h1><a name="odbcsqlgetdiagfield"></a>SQLGetDiagField</h1>
<p class=label>
<b>Conformance</b></p>
<p>
Version Introduced:ODBC 3.0<br>
Standards Compliance:ISO 92</p>
<p class=label>
<b>Summary</b></p>
<p>
<b>SQLGetDiagField</b> returns the current value of a field of a record of the diagnostic data structure (associated with a specified handle) that contains error, warning, and status information.</p>
<p class=label>
<b>Syntax</b></p>
<p>
SQLRETURN <b>SQLGetDiagField</b>(<br>
SQLSMALLINT<i>HandleType</i>,<br>
SQLHANDLE<i>Handle</i>,<br>
SQLSMALLINT<i>RecNumber</i>,<br>
SQLSMALLINT<i>DiagIdentifier</i>,<br>
SQLPOINTER<i>DiagInfoPtr</i>,<br>
SQLSMALLINT<i>BufferLength</i>,<br>
SQLSMALLINT *<i>StringLengthPtr</i>);</p>
<p class=label>
<b>Arguments</b></p>
<p class=dt>
<i>HandleType</i></p>
<p class=indent>
[Input]<br>
A handle type identifier that describes the type of handle for which diagnostics are required. Must be one of the following:</p>
<p class=tl>
SQL_HANDLE_ENV<br>
SQL_HANDLE_DBC<br>
SQL_HANDLE_STMT<br>
SQL_HANDLE_DESC </P><p class=dt>
<i>Handle</i></p>
<p class=indent>
[Input]<br>
A handle for the diagnostic data structure, of the type indicated by <i>HandleType</i>. If <i>HandleType</i> is SQL_HANDLE_ENV, <i>Handle</i> can be either a shared or unshared environment handle.</p>
<p class=dt>
<i>RecNumber</i></p>
<p class=indent>
[Input]<br>
Indicates the status record from which the application seeks information. Status records are numbered from 1. If the <i>DiagIdentifier</i> argument indicates any field of the diagnostics header, <i>RecNumber</i> is ignored. If not, it should be greater than 0.</p>
<p class=dt>
<i>DiagIdentifier</i></p>
<p class=indent>
[Input]<br>
Indicates the field of the diagnostic whose value is to be returned. For more information, see the “<i>DiagIdentifier</i> Argument” section in “Comments.”</p>
<p class=dt>
<i>DiagInfoPtr</i></p>
<p class=indent>
[Output]<br>
Pointer to a buffer in which to return the diagnostic information. The data type depends on the value of <i>DiagIdentifier</i>.</p>
<p class=dt>
<i>BufferLength</i></p>
<p class=indent>
[Input]<br>
If <i>DiagIdentifier</i> is an ODBC-defined diagnostic and<i> DiagInfoPtr</i> points to a character string or a binary buffer, this argument should be the length of *<i>DiagInfoPtr</i>. If <i>DiagIdentifier</i> is an ODBC-defined field and *<i>DiagInfoPtr</i> is an integer, <i>BufferLength</i> is ignored. If the value in <i>*DiagInfoPtr</i> is a Unicode string (when calling <b>SQLGetDiagFieldW</b>), the <i>BufferLength</i> argument must be an even number. </p>
<p class=dt>
</p>
<p class=indent>
If <i>DiagIdentifier</i> is a driver-defined field, the application indicates the nature of the field to the Driver Manager by setting the <i>BufferLength</i> argument. <i>BufferLength</i> can have the following values:
<ul type=disc>
<li>
If <i>*ValuePtr</i> is a pointer to a character string, then <i>BufferLength</i> is the length of the string or SQL_NTS.<br><br></li>
<li>
If <i>*ValuePtr</i> is a pointer to a binary buffer, then the application places the result of the SQL_LEN_BINARY_ATTR(<i>length</i>) macro in <i>BufferLength</i>. This places a negative value in <i>BufferLength</i>.<br><br></li>
<li>
If <i>*ValuePtr</i> is a pointer to a value other than a character string or binary string, then <i>BufferLength</i> should have the value SQL_IS_POINTER. <br><br></li>
<li>
If <i>*ValuePtr</i> is contains a fixed-length data type, then <i>BufferLength</i> is either SQL_IS_INTEGER, SQL_IS_UINTEGER, SQL_IS_SMALLINT, or SQL_IS_USMALLINT, as appropriate.</li>
</ul>
<p class=dt>
<i>StringLengthPtr</i></p>
<p class=indent>
[Output]<br>
Pointer to a buffer in which to return the total number of bytes (excluding the number of bytes required for the null-termination character) available to return in *<i>DiagInfoPtr</i>, for character data. If the number of bytes available to return is greater than <i>BufferLength</i>, then the text in *<i>DiagInfoPtr</i> is truncated to <i>BufferLength</i> minus the length of a null-termination character.</p>
<p class=label>
<b>Returns</b></p>
<p>
SQL_SUCCESS, SQL_SUCCESS_WITH_INFO, SQL_ERROR, SQL_INVALID_HANDLE, or SQL_NO_DATA.</p>
<p class=label>
<b>Diagnostics</b></p>
<p>
<b>SQLGetDiagField</b> does not post diagnostic records for itself. It uses the following return values to report the outcome of its own execution:
<ul type=disc>
<li>
SQL_SUCCESS: The function successfully returned diagnostic information.<br><br></li>
<li>
SQL_SUCCESS_WITH_INFO: *<i>DiagInfoPtr</i> was too small to hold the requested diagnostic field, so the data in the diagnostic field was truncated. To determine that a truncation occurred, the application must compare <i>BufferLength</i> to the actual number of bytes available, which is written to *<i>StringLengthPtr</i>.<br><br></li>
<li>
SQL_INVALID_HANDLE: The handle indicated by <i>HandleType</i> and <i>Handle</i> was not a valid handle.<br><br></li>
<li>
SQL_ERROR: One of the following occurred:<ul type=disc>
<li>
<i>The DiagIdentifier</i> argument was not one of the valid values.<br><br></li>
<li>
<i>The DiagIdentifier</i> argument was SQL_DIAG_CURSOR_ROW_COUNT, SQL_DIAG_DYNAMIC_FUNCTION, SQL_DIAG_DYNAMIC_FUNCTION_CODE, or SQL_DIAG_ROW_COUNT, but <i>Handle</i> was not a statement handle. (The Driver Manager returns this diagnostic.)<br><br></li>
<li>
<i>The RecNumber</i> argument was negative or 0 when <i>DiagIdentifier</i> indicated a field from a diagnostic record. <i>RecNumber</i> is ignored for header fields.<br><br></li>
<li>
The value requested was a character string and <i>BufferLength</i> was less than zero.</li>
</ul>
</li>
<li>
SQL_NO_DATA: <i>RecNumber</i> was greater than the number of diagnostic records that existed for the handle specified in <i>Handle.</i> The function also returns SQL_NO_DATA for any positive <i>RecNumber</i> if there are no diagnostic records for <i>Handle</i>.</li>
</ul>
<p class=label>
<b>Comments</b></p>
<p>
An application typically calls <b>SQLGetDiagField </b>to accomplish one of three goals:
<ol>
<li>
To obtain specific error or warning information when a function call has returned SQL_ERROR or SQL_SUCCESS_WITH_INFO (or SQL_NEED_DATA for the <b>SQLBrowseConnect</b> function).<br><br></li>
<li>
To find out the number of rows in the data source that were affected when insert, delete, or update operations were performed with a call to <b>SQLExecute</b>, <b>SQLExecDirect</b>,<b> SQLBulkOperations</b>, or <b>SQLSetPos </b>(from the SQL_DIAG_ROW_COUNT header field), or to find out the number of rows that exist in the current open cursor, if the driver is able to provide this information (from the SQL_DIAG_CURSOR_ROW_COUNT header field).<br><br></li>
<li>
To determine which function was executed by a call to <b>SQLExecDirect </b>or <b>SQLExecute</b> (from the SQL_DIAG_DYNAMIC_FUNCTION and SQL_DIAG_DYNAMIC_FUNCTION_CODE header fields).</li>
</ol>
<p>
Any ODBC function can post zero or more diagnostic records each time it is called, so an application can call <b>SQLGetDiagField</b> after any ODBC function call. There is no limit to the number of diagnostic records that can be stored at any one time. <b>SQLGetDiagField </b>retrieves only the diagnostic information most recently associated with the diagnostic data structure specified in the <i>Handle</i> argument. If the application calls an ODBC function other than <b>SQLGetDiagField</b> or <b>SQLGetDiagRec</b>, any diagnostic information from a previous call with the same handle is lost. </p>
<p>
An application can scan all diagnostic records by incrementing <i>RecNumber</i>, as long as <b>SQLGetDiagField</b> returns SQL_SUCCESS. The number of status records is indicated in the SQL_DIAG_NUMBER header field. Calls to <b>SQLGetDiagField</b> are non-destructive to the header and record fields. The application can call <b>SQLGetDiagField</b> again at a later time to retrieve a field from a record, as long as a function other than the diagnostic functions has not been called in the interim, which would post records on the same handle.</p>
<p>
An application can call <b>SQLGetDiagField</b> to return any diagnostic field at any time, with the exception of SQL_DIAG_CURSOR_ROW_COUNT or SQL_DIAG_ROW_COUNT, which will return SQL_ERROR if <i>Handle</i> is not a statement handle. If any other diagnostic field is undefined, the call to <b>SQLGetDiagField</b> will return SQL_SUCCESS (provided no other diagnostic is encountered), and an undefined value is returned for the field.</p>
<p>
For more information, see “<a href="odch15pr_0yck.htm">Using SQLGetDiagRec and SQLGetDiagField</a>” and “<a href="odch15pr_76uc.htm">Implementing SQLGetDiagRec and SQLGetDiagField</a>” in Chapter 15, “Diagnostics.”</p>
<p class=label>
<b><i>HandleType</i> Argument</b></p>
<p>
Each handle type can have diagnostic information associated with it. The <i>HandleType</i> argument denotes the handle type of <i>Handle</i>. </p>
<p>
Some header and record fields cannot be returned for all types of handles: environment, connection, statement, and descriptor. Those handles for which a field is not applicable are indicated in the “Header Field” and “Record Fields” sections following. </p>
<p>
If <i>HandleType</i> is SQL_HANDLE_ENV, <i>Handle</i> can be either a shared or unshared environment handle.</p>
<p>
No driver-specific header diagnostic fields should be associated with an environment handle. </p>
<p>
The only diagnostic header fields that are defined for a descriptor handle are SQL_DIAG_NUMBER and SQL_DIAG_RETURNCODE.</p>
<p class=label>
<b><i>DiagIdentifier</i> Argument</b></p>
<p>
This argument indicates the identifier of the field required from the diagnostic data structure. If <i>RecNumber</i> is greater than or equal to 1, the data in the field describes the diagnostic information returned by a function. If <i>RecNumber</i> is 0, the field is in the header of the diagnostic data structure, and therefore contains data pertaining to the function call that returned the diagnostic information, not the specific information. </p>
<p>
Drivers can define driver-specific header and record fields in the diagnostic data structure.</p>
<p>
An ODBC 3.x application working with an ODBC 2<i>.x</i> driver will only be able to call <b>SQLGetDiagField</b> with a <i>DiagIdentifier</i> argument of SQL_DIAG_CLASS_ORIGIN, SQL_DIAG_CLASS_SUBCLASS_ORIGIN, SQL_DIAG_CONNECTION_NAME, SQL_DIAG_MESSAGE_TEXT, SQL_DIAG_NATIVE, SQL_DIAG_NUMBER, SQL_DIAG_RETURNCODE, SQL_DIAG_SERVER_NAME, or SQL_DIAG_SQLSTATE. All other diagnostic fields will return SQL_ERROR.</p>
<h1>Header Fields</h1>
<p>
The following header fields can be included in the <i>DiagIdentifier</i> argument. </p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows width=587>
<tr valign=top>
<td class=label width=35%><b>DiagIdentifier</b></td>
<td class=label width=23%><b>Return type</b></td>
<td class=label width=42%><b>Returns</b></td>
</tr>
<tr valign=top>
<td width=35%>SQL_DIAG_<br>
CURSOR_ROW_<br>
COUNT</td>
<td width=23%>SQLINTEGER</td>
<td width=42%>This field contains the count of rows in the cursor. Its semantics depend upon the <b>SQLGetInfo</b> information types SQL_DYNAMIC_CURSOR_<br>
ATTRIBUTES2, SQL_FORWARD_ONLY_CURSOR_<br>
ATTRIBUTES2, SQL_KEYSET_CURSOR_<br>
ATTRIBUTES2, and SQL_STATIC_CURSOR_<br>
ATTRIBUTES2, which indicate which row counts are available for each cursor type (in the SQL_CA2_CRC_EXACT and SQL_CA2_CRC_APPROXIMATE bits). <p>
The contents of this field are defined only for statement handles and only after <b>SQLExecute</b>, <b>SQLExecDirect</b>, or <b>SQLMoreResults</b> has been called. Calling <b>SQLGetDiagField</b> with a <i>DiagIdentifier</i> of SQL_DIAG_CURSOR_ROW_COUNT on other than a statement handle will return SQL_ERROR.</p>
</td>
</tr>
<tr valign=top>
<td width=35%>SQL_DIAG_DYNAMIC_<br>
FUNCTION</td>
<td width=23%>SQLCHAR *</td>
<td width=42%>This is a string that describes the SQL statement that the underlying function executed (see “Values of the Dynamic Function fields” later in this section for specific values). The contents of this field are defined only for statement handles, and only after a call to <b>SQLExecute</b>, <b>SQLExecDirect</b>, or <b>SQLMoreResults</b>. Calling <b>SQLGetDiagField</b> with a <i>DiagIdentifier</i> of SQL_DIAG_DYNAMIC_FUNCTION on other than a statement handle will return SQL_ERROR. The value of this field is undefined before a call to <b>SQLExecute</b> or <b>SQLExecDirect</b>.</td>
</tr>
<tr valign=top>
<td width=35%>SQL_DIAG_DYNAMIC_<br>
FUNCTION_CODE</td>
<td width=23%>SQLINTEGER</td>
<td width=42%>This is a numeric code that describes the SQL statement that was executed by the underlying function (see “Values of the Dynamic Function Fields” later in this section for specific values). The contents of this field are defined only for statement handles, and only after a call to <b>SQLExecute</b>, <b>SQLExecDirect</b>, or <b>SQLMoreResults</b>. Calling <b>SQLGetDiagField</b> with a <i>DiagIdentifier</i> of SQL_DIAG_DYNAMIC_FUNCTION_<br>
CODE on other than a statement handle will return SQL_ERROR. The value of this field is undefined before a call to <b>SQLExecute</b> or <b>SQLExecDirect</b>.</td>
</tr>
<tr valign=top>
<td width=35%>SQL_DIAG_NUMBER</td>
<td width=23%>SQLINTEGER</td>
<td width=42%>The number of status records that are available for the specified handle.</td>
</tr>
<tr valign=top>
<td width=35%>SQL_DIAG_<br>
RETURNCODE</td>
<td width=23%>SQLRETURN</td>
<td width=42%>Return code returned by the function. For a list of return codes, see “Return Codes” in Chapter 15, “Diagnostics.” The driver does not have to implement SQL_DIAG_RETURNCODE; it is always implemented by the Driver Manager. If no function has yet been called on the <i>Handle</i>, SQL_SUCCESS will be returned for SQL_DIAG_RETURNCODE.</td>
</tr>
<tr valign=top>
<td width=35%>SQL_DIAG_<br>
ROW_COUNT</td>
<td width=23%>SQLINTEGER</td>
<td width=42%>The number of rows affected by an insert, delete, or update performed by <b>SQLExecute</b>, <b>SQLExecDirect</b>, <b>SQLBulkOperations</b>, or <b>SQLSetPos</b>. It is driver-defined after a <i>cursor specification</i> has been executed. The contents of this field are defined only for statement handles. Calling <b>SQLGetDiagField</b> with a <i>DiagIdentifier</i> of SQL_DIAG_ROW_COUNT on other than a statement handle will return SQL_ERROR. The data in this field is also returned in the <i>RowCountPtr</i> argument of <b>SQLRowCount</b>. The data in this field is reset after every non-diagnostic function call, whereas the row count returned by <b>SQLRowCount</b> remains the same until the statement is set back to the prepared or allocated state.</td>
</tr>
</table><br>
<h1>Record Fields</h1>
<p>
The following record fields can be included in the <i>DiagIdentifier</i> argument:</p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows width=587>
<tr valign=top>
<td class=label width=35%><b>DiagIdentifier</b></td>
<td class=label width=23%><b>Return type</b></td>
<td class=label width=42%><b>Returns</b></td>
</tr>
<tr valign=top>
<td width=35%>SQL_DIAG_<br>
CLASS_ORIGIN</td>
<td width=23%>SQLCHAR *</td>
<td width=42%>A string that indicates the document that defines the class portion of the SQLSTATE value in this record. Its value is “ISO 9075” for all SQLSTATEs defined by X/Open and ISO call-level interface. For ODBC-specific SQLSTATEs (all those whose SQLSTATE class is “IM”), its value is “ODBC 3.0”.</td>
</tr>
<tr valign=top>
<td width=35%>SQL_DIAG_COLUMN_<br>
NUMBER</td>
<td width=23%>SQLINTEGER</td>
<td width=42%>If the SQL_DIAG_ROW_NUMBER field is a valid row number in a rowset or a set of parameters, then this field contains the value that represents the column number in the result set or the parameter number in the set of parameters. Result set column numbers always start at 1; if this status record pertains to a bookmark column, then the field can be zero. Parameter numbers start at 1. It has the value SQL_NO_COLUMN_NUMBER if the status record is not associated with a column number or parameter number. If the driver cannot determine the column number or parameter number that this record is associated with, this field has the value SQL_COLUMN_NUMBER_<br>
UNKNOWN. <p>
The contents of this field are defined only for statement handles.</p>
</td>
</tr>
<tr valign=top>
<td width=35%>SQL_DIAG_<br>
CONNECTION_<br>
NAME</td>
<td width=23%>SQLCHAR *</td>
<td width=42%>A string that indicates the name of the connection that the diagnostic record relates to. This field is driver-defined. For diagnostic data structures associated with the environment handle and for diagnostics that do not relate to any connection, this field is a zero-length string.</td>
</tr>
<tr valign=top>
<td width=35%>SQL_DIAG_<br>
MESSAGE_TEXT</td>
<td width=23%>SQLCHAR *</td>
<td width=42%>An informational message on the error or warning. This field is formatted as described in the “<a href="odch15pr_35wz.htm">Diagnostic Messages</a>” section of Chapter 15, “Diagnostics.” There is no maximum length to the diagnostic message text.</td>
</tr>
<tr valign=top>
<td width=35%>SQL_DIAG_NATIVE</td>
<td width=23%>SQLINTEGER</td>
<td width=42%>A driver/data source&nbsp;–&nbsp;specific native error code. If there is no native error code, the driver returns 0.</td>
</tr>
<tr valign=top>
<td width=35%>SQL_DIAG_<br>
ROW_NUMBER</td>
<td width=23%>SQLINTEGER</td>
<td width=42%>This field contains the row number in the rowset, or the parameter number in the set of parameters, with which the status record is associated. Row numbers and parameter numbers start with 1. This field has the value SQL_NO_ROW_NUMBER if this status record is not associated with a row number or parameter number. If the driver cannot determine the row number or parameter number that this record is associated with, this field has the value SQL_ROW_NUMBER_UNKNOWN. <p>
The contents of this field are defined only for statement handles.</p>
</td>
</tr>
<tr valign=top>
<td width=35%>SQL_DIAG_<br>
SERVER_NAME</td>
<td width=23%>SQLCHAR *</td>
<td width=42%>A string that indicates the server name that the diagnostic record relates to. It is the same as the value returned for a call to <b>SQLGetInfo</b> with the SQL_DATA_SOURCE_NAME <i>option</i>. For diagnostic data structures associated with the environment handle and for diagnostics that do not relate to any server, this field is a zero-length string.</td>
</tr>
<tr valign=top>
<td width=35%>SQL_DIAG_SQLSTATE</td>
<td width=23%>SQLCHAR *</td>
<td width=42%>A five-character SQLSTATE diagnostic code. For more information, see “<a href="odch15pr_09ir.htm">SQLSTATEs</a>” in Chapter 15, “Diagnostics.”</td>
</tr>
<tr valign=top>
<td width=35%>SQL_DIAG_SUBCLASS_<br>
ORIGIN</td>
<td width=23%>SQLCHAR *</td>
<td width=42%>A string with the same format and valid values as SQL_DIAG_CLASS_ORIGIN, that identifies the defining portion of the subclass portion of the SQLSTATE code. The ODBC-specific SQLSTATES for which “ODBC 3.0” is returned include the following:<p>
01S00, 01S01, 01S02, 01S06, 01S07, 07S01, 08S01, 21S01, 21S02, 25S01, 25S02, 25S03, 42S01, 42S02, 42S11, 42S12, 42S21, 42S22, HY095, HY097, HY098, HY099, HY100, HY101, HY105, HY107, HY109, HY110, HY111, HYT00, HYT01, IM001, IM002, IM003, IM004, IM005, IM006, IM007, IM008, IM010, IM011, IM012.</p>
</td>
</tr>
</table><br>
<h1>Values of the Dynamic Function Fields</h1>
<p>
The following table describes the values of SQL_DIAG_DYNAMIC_FUNCTION and SQL_DIAG_DYNAMIC_FUNCTION_CODE that apply to each type of SQL statement executed by a call to <b>SQLExecute</b> or <b>SQLExecDirect</b>. The driver can add driver-defined values to those listed.</p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows width=587>
<tr valign=top>
<td class=label width=23%><b>SQL statement <br>
executed</b></td>
<td class=label width=35%><b>Value of SQL_DIAG_<br>
DYNAMIC_FUNCTION</b></td>
<td class=label width=42%><b>Value of SQL_DIAG_DYNAMIC_<br>
FUNCTION_CODE</b></td>
</tr>
<tr valign=top>
<td width=23%><i>alter-domain-<br>
statement</i></td>
<td width=35%>“ALTER DOMAIN”</td>
<td width=42%>SQL_DIAG_ALTER_DOMAIN</td>
</tr>
<tr valign=top>
<td width=23%><i>alter-table-<br>
statement</i></td>
<td width=35%>“ALTER TABLE”</td>
<td width=42%>SQL_DIAG_ALTER_TABLE</td>
</tr>
<tr valign=top>
<td width=23%><i>assertion-<br>
definition</i></td>
<td width=35%>“CREATE ASSERTION”</td>
<td width=42%>SQL_DIAG_CREATE_<br>
ASSERTION</td>
</tr>
<tr valign=top>
<td width=23%><i>character-set-<br>
definition</i></td>
<td width=35%>“CREATE CHARACTER SET”</td>
<td width=42%>SQL_DIAG_CREATE_<br>
CHARACTER_SET</td>
</tr>
<tr valign=top>
<td width=23%><i>collation-<br>
definition</i></td>
<td width=35%>“CREATE COLLATION”</td>
<td width=42%>SQL_DIAG_CREATE_<br>
COLLATION</td>
</tr>
<tr valign=top>
<td width=23%><i>create-index-<br>
statement</i></td>
<td width=35%>“CREATE INDEX”</td>
<td width=42%>SQL_DIAG_CREATE_<br>
INDEX</td>
</tr>
<tr valign=top>
<td width=23%><i>create-table-<br>
statement</i></td>
<td width=35%>“CREATE TABLE”</td>
<td width=42%>SQL_DIAG_CREATE_<br>
TABLE</td>
</tr>
<tr valign=top>
<td width=23%><i>create-view-<br>
statement</i></td>
<td width=35%>“CREATE VIEW”</td>
<td width=42%>SQL_DIAG_CREATE_VIEW</td>
</tr>
<tr valign=top>
<td width=23%><i>cursor-<br>
specification</i></td>
<td width=35%>“SELECT CURSOR”</td>
<td width=42%>SQL_DIAG_SELECT_<br>
CURSOR</td>
</tr>
<tr valign=top>
<td width=23%><i>delete-<br>
statement-<br>
positioned</i></td>
<td width=35%>“DYNAMIC DELETE CURSOR”</td>
<td width=42%>SQL_DIAG_DYNAMIC_<br>
DELETE_CURSOR</td>
</tr>
<tr valign=top>
<td width=23%><i>delete-<br>
statement-<br>
searched</i></td>
<td width=35%>“DELETE WHERE”</td>
<td width=42%>SQL_DIAG_DELETE_<br>
WHERE</td>
</tr>
<tr valign=top>
<td width=23%><i>domain-<br>
definition</i></td>
<td width=35%>“CREATE DOMAIN”</td>
<td width=42%>SQL_DIAG_CREATE_<br>
DOMAIN</td>
</tr>
<tr valign=top>
<td width=23%><i>drop-assertion-<br>
statement</i></td>
<td width=35%>“DROP ASSERTION”</td>
<td width=42%>SQL_DIAG_DROP_<br>
ASSERTION</td>
</tr>
<tr valign=top>
<td width=23%><i>drop-character-<br>
set-stmt</i></td>
<td width=35%>“DROP CHARACTER SET”</td>
<td width=42%>SQL_DIAG_DROP_<br>
CHARACTER_SET</td>
</tr>
<tr valign=top>
<td width=23%><i>drop-collation-<br>
statement</i></td>
<td width=35%>“DROP COLLATION”</td>
<td width=42%>SQL_DIAG_DROP_<br>
COLLATION</td>
</tr>
<tr valign=top>
<td width=23%><i>drop-domain-<br>
statement</i></td>
<td width=35%>“DROP DOMAIN”</td>
<td width=42%>SQL_DIAG_DROP_DOMAIN</td>
</tr>
<tr valign=top>
<td width=23%><i>drop-index-<br>
statement</i></td>
<td width=35%>“DROP INDEX”</td>
<td width=42%>SQL_DIAG_DROP_INDEX</td>
</tr>
<tr valign=top>
<td width=23%><i>drop-schema-<br>
statement</i></td>
<td width=35%>“DROP SCHEMA”</td>
<td width=42%>SQL_DIAG_DROP_SCHEMA</td>
</tr>
<tr valign=top>
<td width=23%><i>drop-table-<br>
statement</i></td>
<td width=35%>“DROP TABLE”</td>
<td width=42%>SQL_DIAG_DROP_TABLE</td>
</tr>
<tr valign=top>
<td width=23%><i>drop-translation-<br>
statement</i></td>
<td width=35%>“DROP TRANSLATION”</td>
<td width=42%>SQL_DIAG_DROP_<br>
TRANSLATION</td>
</tr>
<tr valign=top>
<td width=23%><i>drop-view-<br>
statement</i></td>
<td width=35%>“DROP VIEW”</td>
<td width=42%>SQL_DIAG_DROP_VIEW</td>
</tr>
<tr valign=top>
<td width=23%><i>grant-statement</i></td>
<td width=35%>“GRANT”</td>
<td width=42%>SQL_DIAG_GRANT</td>
</tr>
<tr valign=top>
<td width=23%><i>insert-statement</i></td>
<td width=35%>“INSERT”</td>
<td width=42%>SQL_DIAG_INSERT</td>
</tr>
<tr valign=top>
<td width=23%><i>ODBC-<br>
procedure-<br>
extension</i></td>
<td width=35%>“CALL”</td>
<td width=42%>SQL_DIAG_ CALL</td>
</tr>
<tr valign=top>
<td width=23%><i>revoke-<br>
statement</i></td>
<td width=35%>“REVOKE”</td>
<td width=42%>SQL_DIAG_REVOKE</td>
</tr>
<tr valign=top>
<td width=23%><i>schema-<br>
definition</i></td>
<td width=35%>“CREATE SCHEMA”</td>
<td width=42%>SQL_DIAG_CREATE_<br>
SCHEMA</td>
</tr>
<tr valign=top>
<td width=23%><i>translation-<br>
definition</i></td>
<td width=35%>“CREATE TRANSLATION”</td>
<td width=42%>SQL_DIAG_CREATE_<br>
TRANSLATION</td>
</tr>
<tr valign=top>
<td width=23%><i>update-<br>
statement-<br>
positioned</i></td>
<td width=35%>“DYNAMIC UPDATE CURSOR”</td>
<td width=42%>SQL_DIAG_DYNAMIC_<br>
UPDATE_CURSOR</td>
</tr>
<tr valign=top>
<td width=23%><i>update-<br>
statement-<br>
searched</i></td>
<td width=35%>“UPDATE WHERE”</td>
<td width=42%>SQL_DIAG_UPDATE_<br>
WHERE</td>
</tr>
<tr valign=top>
<td width=23%>Unknown</td>
<td width=35%><i>empty string</i></td>
<td width=42%>SQL_DIAG_UNKNOWN_<br>
STATEMENT</td>
</tr>
</table><br>
<h1>Sequence of Status Records</h1>
<p>
Status records are placed in a sequence based upon row number and the type of the diagnostic. The Driver Manager determines the final order in which to return status records that it generates. The driver determines the final order in which to return status records that it generates.</p>
<p>
If diagnostic records are posted by both the Driver Manager and the driver, the Driver Manager is responsible for ordering them.</p>
<p>
If there are two or more status records, the sequence of the records is determined first by row number. The following rules apply to determining the sequence of diagnostic records by row:
<ul type=disc>
<li>
Records that do not correspond to any row appear in front of records that correspond to a particular row, because SQL_NO_ROW_NUMBER is defined to be &nbsp;–&nbsp;1. <br><br></li>
<li>
Records for which the row number is unknown appear in front of all other records, because SQL_ROW_NUMBER_UNKNOWN is defined to be &nbsp;–&nbsp;2.<br><br></li>
<li>
For all records that pertain to specific rows, records are sorted by the value in the SQL_DIAG_ROW_NUMBER field. All errors and warnings of the first row affected are listed, then all errors and warnings of the next row affected, and so on. </li>
</ul>
<p class=indent>
<B><b>Note</b></B> The ODBC 3.x Driver Manager does not order status records in the diagnostic queue if SQLSTATE 01S01 (Error in row) is returned by an ODBC 2.<i>x</i> driver, or SQLSTATE 01S01 (Error in row) is returned by an ODBC 3.x driver when <b>SQLExtendedFetch</b> is called or <b>SQLSetPos</b> is called on a cursor that has been positioned with <b>SQLExtendedFetch</b>.</p>
<p>
Within each row, or for all those records that do not correspond to a row or for which the row number is unknown, or for all those records with a row number equal to SQL_NO_ROW_NUMBER, the first record listed is determined using a set of sorting rules. After the first record, the order of the other records affecting a row is undefined. An application cannot assume that errors precede warnings after the first record. Applications should scan the entire diagnostic data structure to obtain complete information on an unsuccessful call to a function.</p>
<p>
The following rules are followed to determine the first record within a row. The record with the highest rank is the first record. The source of a record (Driver Manager, driver, gateway, and so on) is not considered when ranking records. 
<ul type=disc>
<li>
<b>Errors</b>. Status records that describe errors have the highest rank. The following rules are followed to sort errors:<ul type=disc>
<li>
Records that indicate a transaction failure or possible transaction failure outrank all other records. <br><br></li>
<li>
If two or more records describe the same error condition, then SQLSTATEs defined by the X/Open CLI specification (classes 03 through HZ) outrank ODBC- and driver-defined SQLSTATEs. </li>
</ul>
</li>
<li>
<b>Implementation-defined No Data values</b>. Status records that describe driver-defined No Data values (class 02) have the second highest rank.<br><br></li>
<li>
<b>Warnings</b>. Status records that describe warnings (class 01) have the lowest rank. If two or more records describe the same warning condition, then warning SQLSTATEs defined by the X/Open CLI specification outrank ODBC- and driver-defined SQLSTATEs.</li>
</ul>
<p class=label>
<b>Related Functions</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows width=587>
<tr valign=top>
<td class=label width=53%><b>For information about</b></td>
<td class=label width=47%><b>See</b></td>
</tr>
<tr valign=top>
<td width=53%>Obtaining multiple fields of a diagnostic data structure</td>
<td width=47%><a href="odch21gpr_6x0j.htm">SQLGetDiagRec</a></td>
</tr>
</table><br>
</font></BODY>
</HTML>
