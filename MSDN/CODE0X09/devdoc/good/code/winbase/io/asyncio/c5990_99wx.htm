<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>PDC.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5991"></a>PDC.C</h2>
<pre><code>/*++ <br> <br>Copyright 1992 - 1998 Microsoft Corporation <br> <br>Module Name: <br> <br>    pdc.c <br> <br>Abstract: <br> <br>    This is the main source file for the Windows/NT PDC API demonstration <br>    program.  This program demonstrates how to use many of the advanced <br>    operating system features provided by the Win32 API set on Windows/NT. <br> <br>    This file and its corresponding header file, pdc.h, can be found <br>    in the sample programs directory of the PDC CD-ROM. <br> <br>    This program has a real purpose, although the implementation is <br>    somewhat contrived in order to demonstrate the various operating <br>    system features of Windows/NT. <br> <br>    The features that this program demonstrate are: <br> <br>        - Creating multiple threads, using critical sections <br>          and semaphores for synchronization. <br> <br>        - Thread termination. <br> <br>        - Virtual memory, commitment vs reservation. <br> <br>        - Structured exception handling, including finally <br>          clauses and an exception filter procedure. <br> <br>        - Enumeration of directory entries. <br> <br>        - Mapped file I/O <br> <br>        - Asynchronous file I/O via completion routine. <br> <br>        - Synchronous file I/O <br> <br>    PDC is a character mode program for searching the files in a <br>    directory tree for a match against a pattern.  It uses multiple <br>    threads to do it's work, with each thread processing a file at a <br>    time, accumulating it's matches and outputting them to standard <br>    output contiguously when it is done searching a file. <br> <br>    The command line syntax is: <br> <br>        Usage: PDC [-h] [-v] [-y] [-a | -s | -m] [-t n] SearchString [DirectoryPath] <br> <br>        where: <br> <br>            -h - prints this message. <br> <br>            -v - generates verbose output. <br> <br>            -y - ignores case when doing comparisons. <br> <br>            -a - specifies that the program should use asynchronous file <br>                 I/O to read the files being searched. <br> <br>            -s - specifies that the program should use synchronous file <br>                 I/O to read the files being searched. <br> <br>            -m - specifies that the program should use mapped file I/O <br>                 to read the files being searched. <br> <br>            -t - specifies the number of threads to use when doing the <br>                 search.  Default is 4 * the number of processors. <br> <br>            SearchString - specifies the text to search for.  Enclose in <br>                           quotes if it contains spaces or punctuation. <br> <br>            DirectoryPath - specifies the root of the tree to begin the <br>                            search at.  Defaults to the current directory. <br> <br> <br>--*/ <br> <br>#include "pdc.h" <br> <br>  <br>int <br>main( <br>    int argc, <br>    char *argv[] <br>    ) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    This is the main procedure for the PDC program, and is called by <br>    the C Runtime startup code when the program starts. <br> <br>Arguments: <br> <br>    argc - number of argumments in the argv array. <br> <br>    argv - pointer to an array of null terminated string pointers. <br> <br>Return Value: <br> <br>    Process exit status.  The value returned by this function will <br>    be used as the exit code parameter passed to ExitProcess. <br> <br>--*/ <br> <br>{ <br>    SYSTEM_INFO SystemInformation; <br>    PWORK_QUEUE WorkQueue; <br> <br>    // <br>    // Query the number of processors from the system and <br>    // default the number of worker threads to 4 times that. <br>    // <br> <br>    GetSystemInfo( &amp;SystemInformation ); <br>    NumberOfWorkerThreads = SystemInformation.dwNumberOfProcessors * 4; <br> <br>    // <br>    // Process the arguments given on the command line. <br>    // <br> <br>    if (!ProcessCommandLineArguments( argc, argv )) { <br>        exit( 1 ); <br>        } <br> <br>    // <br>    // Allocate a thread local storage slot for use by our worker <br>    // thread routine (ProcessRequest).  This call reserves a <br>    // 32-bit slot in the thread local storage array for every <br>    // thread in this process.  Remember the slot index in a global <br>    // variable for use by our worker thread routine. <br>    // <br> <br>    TlsIndex = TlsAlloc(); <br>    if (TlsIndex == 0xFFFFFFFF) { <br>        fprintf( stderr, "PDC: Unable to allocated thread local storage.\n" ); <br>        exit( 1 ); <br>        } <br> <br> <br>    // <br>    // Create a work queue, which will create the specified number of threads <br>    // to process. <br>    // <br> <br>    WorkQueue = CreateWorkQueue( NumberOfWorkerThreads, ProcessRequest ); <br>    if (WorkQueue == NULL) { <br>        fprintf( stderr, "PDC: Unable to create %u worker threads.\n", NumberOfWorkerThreads ); <br>        exit( 1 ); <br>        } <br> <br>    // <br>    // If using asynchronous I/O, create an event that will be signalled <br>    // when there are no more outstanding I/O requests.  The event is <br>    // a manual reset event, that once signalled via SetEvent, will <br>    // remain signalled until ResetEvent is called. <br>    // <br> <br>    if (ASyncIO) { <br>        IoCompletedEvent = CreateEvent( NULL,   // Not inherited <br>                                        TRUE,   // Manual reset <br>                                        FALSE,  // Initially reset <br>                                        NULL    // No name <br>                                      ); <br>        } <br> <br>    // <br>    // Now walk the directory tree, which will call our procedure <br>    // (QueueSearchFile) for each directory and file in the tree. <br>    // <br> <br>    EnumerateDirectoryTree( DirectoryPath, <br>                            QueueSearchFile, <br>                            WorkQueue <br>                          ); <br> <br>    // <br>    // Done walking the tree.  If using asynchronous I/O, wait for all of <br>    // the outstanding I/O requests to be completed. <br>    // <br> <br>    if (ASyncIO) { <br>        // <br>        // We use an alertable wait in a loop, as I/O completion <br>        // will terminate the wait, even through the event we <br>        // are waiting on is not signalled. <br>        // <br> <br>        while (WaitForSingleObjectEx( IoCompletedEvent, <br>                                      0xFFFFFFFF, <br>                                      TRUE <br>                                    ) == WAIT_IO_COMPLETION <br>              ) { <br>            ; <br>            } <br>        } <br> <br>    // <br>    // All done, destroy the work queue.  This will wait for the work queues <br>    // to empty before terminating the worker threads and destroying the <br>    // queue. <br>    // <br> <br>    DestroyWorkQueue( WorkQueue ); <br> <br>    if (Verbose &amp;&amp; MatchedLineCount) { <br>        fprintf( stderr, <br>                 "Found %u lines with matches in %u files, out of %u files searched.\n", <br>                 MatchedLineCount, <br>                 MatchedFileCount, <br>                 SearchedFileCount <br>               ); <br>        } <br> <br>    return 0; <br>} <br> <br> <br>  <br>VOID <br>QueueSearchFile( <br>    LPSTR Path, <br>    PWIN32_FIND_DATA FindFileData, <br>    PVOID EnumerateParameter <br>    ) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    This is the directory enumeration function.  It is called by the <br>    EnumerateDirectoryTree function once for each file and directory <br>    in the tree. <br> <br>    This function, if it decides it wants to search the file, will <br>    open the file and then, depending upon the I/O method selected via <br>    the command line, will: <br> <br>        - map the file PAGE_READONLY for mapped file I/O <br> <br>        - read the file into an allocated buffer for synchronous <br>          I/O. <br> <br>        - will allocate the buffer and start a read operation <br>          to read the entire file into the buffer.  A completion <br>          routine will be invoked when the read completes, possibly <br>          in another thread context. <br> <br>    Finally it will queue a search request to the work queue, with the <br>    relevant information contained in the request.  For asynchronous <br>    I/O, the search request is allocated and initialized here but is <br>    not actually queued to the work queue until the I/O completion <br>    routine has been called. <br> <br>Arguments: <br> <br>    Path - Supplies a pointer to a null terminated string that contains <br>        the fully qualified path of the file or directory. <br> <br>    FindFileData - Supplies the directory information associated <br>        with the file or directory specified by the Path argument. <br> <br>    EnumerateParameter - Uninterpreted 32-bit value.  Not used. <br> <br>Return Value: <br> <br>    None. <br> <br>--*/ <br> <br>{ <br>    PWORK_QUEUE WorkQueue = (PWORK_QUEUE)EnumerateParameter; <br>    PSEARCH_REQUEST SearchRequest; <br>    HANDLE File; <br>    HANDLE Mapping; <br>    LPVOID FileData; <br>    DWORD FileSize; <br> <br>    // <br>    // Ignore directories or zero length files, as there <br>    // is nothing to search in these cases. <br>    // <br> <br>    if (FindFileData-&gt;dwFileAttributes &amp; FILE_ATTRIBUTE_DIRECTORY || <br>        !(FileSize = FindFileData-&gt;nFileSizeLow) <br>       ) { <br>        return; <br>        } <br> <br>    // <br>    // Open the file using the fully qualified path.  Specify the <br>    // sequential scan hint to the cache manager and if asynchronous <br>    // I/O will be used, specified the overlapped flag as well. <br>    // <br> <br>    File = CreateFile( Path, <br>                       GENERIC_READ, <br>                       FILE_SHARE_READ, <br>                       NULL, <br>                       OPEN_EXISTING, <br>                       FILE_FLAG_SEQUENTIAL_SCAN | <br>                         (ASyncIO ? FILE_FLAG_OVERLAPPED : 0), <br>                       NULL <br>                     ); <br> <br>    // <br>    // Since NULL might be a valid file object handle, failure <br>    // is indicated by a special return value. <br>    // <br> <br>    if (File == INVALID_HANDLE_VALUE) { <br>        fprintf( stderr, "%s(0) : error %u: Unable to open file.\n", <br>                 Path, <br>                 GetLastError() <br>               ); <br> <br>        return; <br>        } <br> <br>    // <br>    // File successfully opened for read access. <br>    // <br>    if (MappedFileIO) { <br>        // <br>        // If mapped file I/O, create a file mapping object, backed by <br>        // the file we just opened.  Make the default page protection <br>        // for the mapping be readonly. <br>        // <br> <br>        Mapping = CreateFileMapping( File, <br>                                     NULL, <br>                                     PAGE_READONLY, <br>                                     0, <br>                                     0, <br>                                     NULL <br>                                   ); <br> <br>        // <br>        // Okay to close the file handle now, since the mapping object <br>        // has a reference to the file that will cause the open file <br>        // object to remain until the reference is destroyed.  Note that <br>        // any sharing information is lost at this point, so somebody <br>        // could come in an open it for write access. <br>        // <br> <br>        CloseHandle( File ); <br> <br>        // <br>        // Here, a null value indicates an error. <br>        // <br> <br>        if (Mapping == NULL) { <br>            fprintf( stderr, "%s(0) : error %u: Unable to create mapping object.\n", <br>                     Path, <br>                     GetLastError() <br>                   ); <br>            return; <br>            } <br> <br>        // <br>        // Finally, map a view of the file, using the mapping object <br>        // just created, into the address space of this process. <br>        // The offset and size are zero, which means to map the <br>        // entire file. <br>        // <br> <br>        FileData = MapViewOfFile( Mapping, <br>                                  FILE_MAP_READ, <br>                                  0, <br>                                  0, <br>                                  0 <br>                                ); <br> <br>        // <br>        // Okay to close the mapping object handle now, it will remained <br>        // referenced as long as the view remains mapped. <br>        // <br> <br>        CloseHandle( Mapping ); <br> <br>        // <br>        // A null value indicates the map operation failed. <br>        // <br> <br>        if (FileData == NULL) { <br>            fprintf( stderr, "%s(0) : error %u: Unable to map file.\n", <br>                     Path, <br>                     GetLastError() <br>                   ); <br>            return; <br>            } <br> <br>        // <br>        // All done mapping the file.  Set the File handle to NULL as <br>        // it has been closed already.  Both the file object and mapping <br>        // objects created above will be freed when the map view is <br>        // unmapped. <br>        // <br> <br>        File = NULL; <br>        } <br>    else { <br>        // <br>        // Not using mapped I/O, so allocate a buffer big enough to <br>        // contain the entire file. <br>        // <br> <br>        FileData = VirtualAlloc( NULL, <br>                                 FileSize, <br>                                 MEM_COMMIT, <br>                                 PAGE_READWRITE <br>                               ); <br>        if (FileData == NULL) { <br>            fprintf( stderr, "%s(0) : error %u: Unable to allocate memory to contain file.\n", <br>                     Path, <br>                     GetLastError() <br>                   ); <br>            CloseHandle( File ); <br>            return; <br>            } <br>        } <br> <br>    // <br>    // We have successfully opened the file and are ready to go. <br>    // Allocate space for a search request and fill it in <br>    // with the information needed by the ProcessSearchFile <br>    // function when it runs. <br>    // <br> <br>    SearchRequest = LocalAlloc( LMEM_ZEROINIT, <br>                                sizeof( *SearchRequest ) + <br>                                    strlen( Path ) + 1 <br>                              ); <br>    if (SearchRequest == NULL) { <br>        fprintf( stderr, "PDC: Out of memory\n" ); <br>        exit( 1 ); <br>        } <br> <br>    SearchRequest-&gt;WorkItem.Reason = WORK_ITEM; <br>    SearchRequest-&gt;File = File; <br>    SearchRequest-&gt;FileSize = FileSize; <br>    SearchRequest-&gt;FileData = FileData; <br>    strcpy( SearchRequest-&gt;FullPathName, Path ); <br> <br>    if (!ASyncIO) { <br>        // <br>        // If not using asynchronous I/O, then queue the search <br>        // request to the work queue. <br>        // <br> <br>        QueueWorkItem( WorkQueue, &amp;SearchRequest-&gt;WorkItem ); <br>        } <br>    else { <br>        // <br>        // Using asynchronous I/O, so queue the read operation. <br>        // The file handle must remain open while the read operation <br>        // is pending. <br>        // <br> <br>        if (!ReadFileEx( File, <br>                         FileData, <br>                         FileSize, <br>                         &amp;SearchRequest-&gt;OverlappedIO, <br>                         (LPOVERLAPPED_COMPLETION_ROUTINE) ProcessReadFileCompletion <br>                       ) <br>           ) { <br>            fprintf( stderr, "%s(0) : error %u: Unable to queue read of file.\n", <br>                     Path, <br>                     GetLastError() <br>                   ); <br> <br>            VirtualFree( FileData, 0, MEM_RELEASE ); <br>            CloseHandle( File ); <br>            LocalFree( SearchRequest ); <br>            return; <br>            } <br> <br> <br>        // <br>        // Successfully queued the read operation.  Keep a count <br>        // of outstanding read operations so we know when it is <br>        // okay to terminate. <br>        // <br> <br>        OutstandingIOOperations += 1; <br>        } <br> <br>    // <br>    // Return back to the EnumerateDirectoryTree function so that it <br>    // can call us with the next file or directrry. <br>    // <br> <br>    return; <br>} <br> <br> <br>  <br>VOID <br>ProcessRequest( <br>    IN PWORK_QUEUE_ITEM WorkItem <br>    ) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    This function is called whenever a work item is removed from <br>    the work queue by one of the worker threads.  Which worker <br>    thread context this function is called in is arbitrary. <br> <br>    This functions keeps a pointer to state information in <br>    thread local storage. <br> <br>    This function is called once at the beginning with a <br>    special initialization call.  During this call, this <br>    function allocates space for state information and <br>    remembers the pointer to the state information in <br>    a Thread Local Storage (TLS) slot. <br> <br>    This function is called once at the end with a special <br>    termination call.  During this call, this function <br>    frees the state information allocated during the <br>    initialization call. <br> <br>    In between these two calls are zero or more calls to <br>    handle a work item.  The work item is a search request <br>    which is handled by the ProcessSearchFile function. <br> <br>Arguments: <br> <br>    WorkItem - Supplies a pointer to the work item just removed <br>        from the work queue.  It is the responsibility of this <br>        routine to free the memory used to hold the work item. <br> <br>Return Value: <br> <br>    None. <br> <br>--*/ <br> <br>{ <br>    DWORD BytesWritten; <br>    PSEARCH_REQUEST_STATE State; <br>    PSEARCH_REQUEST SearchRequest; <br>    CHAR MessageBuffer[ 2 * MAX_PATH ]; <br> <br>    if (WorkItem-&gt;Reason == WORK_INITIALIZE_ITEM) { <br>        // <br>        // First time initialization call.  Allocate space for <br>        // state information. <br>        // <br> <br>        State = LocalAlloc( LMEM_ZEROINIT, <br>                            sizeof( *State ) <br>                          ); <br> <br>        if (State != NULL) { <br>            // <br>            // Now create a virtual buffer, with an initial commitment <br>            // of zero and a maximum commitment of 128KB.  This buffer <br>            // will be used to accumulate the matched strings output <br>            // during the search of a single file.  This is so the <br>            // output can be written to standard output with a single <br>            // write call, thus insuring that it remains contiguous <br>            // in the output stream, and is not intermingled with the <br>            // output of the other worker threads. <br>            // <br> <br>            if (CreateVirtualBuffer( &amp;State-&gt;Buffer, 0, 2 * 64 * 1024 )) { <br>                // <br>                // The CurrentOutput field of the state block is <br>                // a pointer to where the next output goes in the <br>                // buffer.  It is initialized here and reset each <br>                // time the buffer is flushed to standard output. <br>                // <br> <br>                State-&gt;CurrentOutput = State-&gt;Buffer.Base; <br>                } <br>            else { <br>                LocalFree( State ); <br>                State = NULL; <br>                } <br>            } <br> <br>        // <br>        // Remember the pointer to the state informaiton <br>        // thread local storage. <br>        // <br> <br>        TlsSetValue( TlsIndex, State ); <br>        return; <br>        } <br> <br>    // <br>    // Here to handle a work item or special terminate call. <br>    // Get the state pointer from thread local storage. <br>    // <br> <br>    State = (PSEARCH_REQUEST_STATE)TlsGetValue( TlsIndex ); <br>    if (State == NULL) { <br>        return; <br>        } <br> <br>    // <br>    // If this is the special terminate work item, free the virtual <br>    // buffer and state block allocated above and set the thread <br>    // local storage value to NULL.  Return to caller. <br>    // <br> <br>    if (WorkItem-&gt;Reason == WORK_TERMINATE_ITEM) { <br>        FreeVirtualBuffer( &amp;State-&gt;Buffer ); <br>        LocalFree( State ); <br>        TlsSetValue( TlsIndex, NULL ); <br>        return; <br>        } <br> <br>    // <br>    // If not an initialize or terminate work item, then must be a <br>    // search request.  Calculate the address of the search request <br>    // block, based on the position of the WorkItem field in the <br>    // SEARCH_REQUEST structure. <br>    // <br> <br>    SearchRequest = CONTAINING_RECORD( WorkItem, SEARCH_REQUEST, WorkItem ); <br> <br>    // <br>    // Actual search operation is protected by a try ... except <br>    // block so that any attempts to store into the virtual buffer <br>    // will be handled correctly by extending the virtual buffer. <br>    // <br> <br>    _try { <br>        // <br>        // Perform the search against this file. <br>        // <br> <br>        ProcessSearchFile( SearchRequest, State ); <br> <br>        // <br>        // Done with this file.  If using asynchronous I/O, decrement the <br>        // count of outstanding I/O operations and it if goes to zero, <br>        // then signal the IoCompletedEvent as there are no more outstanding <br>        // I/O operations. <br>        // <br> <br>        if (ASyncIO &amp;&amp; InterlockedDecrement( &amp;OutstandingIOOperations ) == 0) { <br>            SetEvent( IoCompletedEvent ); <br>            } <br> <br>        // <br>        // If any output was written to the virtual buffer, <br>        // flush the output to standard output.  Trim the <br>        // virtual buffer back to zero committed pages. <br>        // <br> <br>        if (State-&gt;CurrentOutput &gt; (LPSTR)State-&gt;Buffer.Base) { <br>            WriteFile( GetStdHandle( STD_OUTPUT_HANDLE ), <br>                       State-&gt;Buffer.Base, <br>                       State-&gt;CurrentOutput - (LPSTR)State-&gt;Buffer.Base, <br>                       &amp;BytesWritten, <br>                       NULL <br>                     ); <br> <br>            TrimVirtualBuffer( &amp;State-&gt;Buffer ); <br>            State-&gt;CurrentOutput = (LPSTR)State-&gt;Buffer.Base; <br>            } <br>        } <br> <br>    _except( VirtualBufferExceptionFilter( GetExceptionCode(), <br>                                          GetExceptionInformation(), <br>                                          &amp;State-&gt;Buffer <br>                                        ) <br>          ) { <br> <br>        // <br>        // We will get here if the exception filter was unable to <br>        // commit the memory. <br>        // <br> <br>        WriteFile( GetStdHandle( STD_OUTPUT_HANDLE ), <br>                   MessageBuffer, <br>                   sprintf( MessageBuffer, <br>                            "%s(0) : error 0: too many matches for file\n", <br>                            SearchRequest-&gt;FullPathName <br>                          ), <br>                   &amp;BytesWritten, <br>                   NULL <br>                 ); <br>        } <br> <br>    // <br>    // Free the storage used by the SearchRequest <br>    // <br> <br>    LocalFree( SearchRequest ); <br> <br>    // <br>    // All done with this request.  Return to the worker thread that <br>    // called us. <br>    // <br> <br>    return; <br>} <br> <br> <br>  <br>VOID <br>ProcessReadFileCompletion( <br>    DWORD dwErrorCode, <br>    DWORD dwNumberOfBytesTransfered, <br>    LPOVERLAPPED lpOverlapped <br>    ) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    This function is called whenever an asynchronous I/O operation, <br>    queued by the previous function, completes.  This function <br>    calulates the address of the search request block and then <br>    queue the request to the work queue, now that the data is <br>    in memory. <br> <br>Arguments: <br> <br>    dwErrorCode - Supplies the error code that the I/O completed with. <br> <br>    dwNumberOfBytesTransfered - Supplies the actual number of bytes <br>        transferred. <br> <br>    lpOverlapped - Supplies a pointer to the structure given to <br>        ReadFileEx when the I/O operation was queued. <br> <br>Return Value: <br> <br>    None. <br> <br>--*/ <br> <br>{ <br>    PSEARCH_REQUEST SearchRequest; <br> <br>    // <br>    // Since the data we need is now in memory, queue the search <br>    // request to the work queue. <br>    // <br> <br>    SearchRequest = CONTAINING_RECORD( lpOverlapped, SEARCH_REQUEST, OverlappedIO ); <br>    QueueWorkItem( SearchRequest-&gt;WorkItem.WorkQueue, &amp;SearchRequest-&gt;WorkItem ); <br>} <br> <br> <br>  <br>VOID <br>ProcessSearchFile( <br>    IN PSEARCH_REQUEST SearchRequest, <br>    IN PSEARCH_REQUEST_STATE State <br>    ) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    This function performs the actual search of the contents of the <br>    passed file for the search string given on the command line. <br>    If we are using synchronous I/O, then do the read operation <br>    now. <br> <br>    Search the contents of the file for any matches, and accumulate <br>    the match output in the virtual buffer using sprintf, which is <br>    multi-thread safe, even with the single threaded version of <br>    the libraries. <br> <br>Arguments: <br> <br>    SearchRequest - Supplies a pointer to the search request which <br>        contains the relevant information. <br> <br>    State - Supplies a pointer to state information for the current <br>        thread. <br> <br>Return Value: <br> <br>    None. <br> <br>--*/ <br> <br>{ <br>    LPSTR FileData, s, s1, BegLine, EndLine, EndOfFile; <br>    DWORD LineNumber; <br>    DWORD MatchesFound; <br>    DWORD BytesRead; <br> <br>    // Get a pointer to the beginning of the file data in memory <br>    // and calculate the address of the end of file point in <br>    // memory. <br>    // <br> <br>    FileData = SearchRequest-&gt;FileData; <br>    EndOfFile = FileData + SearchRequest-&gt;FileSize; <br> <br>    // <br>    // If using synchronous I/O, then we have not read in the <br>    // file contents yet, so issue the synchronous read to get <br>    // the data into memory. <br>    // <br> <br>    if (SyncIO) { <br>        if (!ReadFile( SearchRequest-&gt;File, <br>                       FileData, <br>                       SearchRequest-&gt;FileSize, <br>                       &amp;BytesRead, <br>                       NULL <br>                     ) || <br>            BytesRead != SearchRequest-&gt;FileSize <br>           ) { <br>            State-&gt;CurrentOutput += sprintf( State-&gt;CurrentOutput, <br>                                             "%s(0) : error %u: Unable to read file contents.\n", <br>                                             SearchRequest-&gt;FullPathName, <br>                                             GetLastError() <br>                                           ); <br> <br>            CloseHandle( SearchRequest-&gt;File ); <br>            return; <br>            } <br>        } <br> <br>    // <br>    // Close any open file handle associated with this request. <br>    // <br> <br>    if (SearchRequest-&gt;File != NULL) { <br>        CloseHandle( SearchRequest-&gt;File ); <br>        } <br> <br>    // <br>    // Search the file contents, keeping track of line breaks <br>    // so we can tell the line number of each match. <br>    // <br> <br>    s = FileData; <br>    LineNumber = 0; <br>    MatchesFound = 0; <br>    while (s &lt; EndOfFile) { <br>        BegLine = s; <br>        while (s &lt; EndOfFile &amp;&amp; *s != '\n') { <br>            s++; <br>            } <br> <br>        if (*s == '\n') { <br>            LineNumber += 1; <br>            EndLine = s - 1; <br>            if (EndLine &gt; BegLine &amp;&amp; EndLine[ -1 ] == '\r') { <br>                EndLine -= 1; <br>                } <br> <br>            s1 = BegLine; <br>            while (s1 &lt; (EndLine - SearchStringLength)) { <br>                if (!(SearchFunction)( s1, SearchString, SearchStringLength )) { <br>                    // <br>                    // We have a match for this line.  Append the <br>                    // output to the virtual buffer and update the <br>                    // current output pointer. <br>                    // <br> <br>                    State-&gt;CurrentOutput += sprintf( State-&gt;CurrentOutput, <br>                                                     "%s(%u) : %.*s\n", <br>                                                     SearchRequest-&gt;FullPathName, <br>                                                     LineNumber, <br>                                                     EndLine - BegLine, <br>                                                     BegLine <br>                                                   ); <br>                    MatchesFound += 1; <br>                    break; <br>                    } <br> <br>                s1++; <br>                } <br> <br>            s++; <br>            } <br>        } <br> <br>    if (MatchesFound) { <br>        MatchedLineCount += MatchesFound; <br>        MatchedFileCount += 1; <br>        } <br>    SearchedFileCount += 1; <br> <br>    // <br>    // All done with the file contents.  Discard it either by <br>    // unmapping the view of the file in the case of mapped file <br>    // I/O or free the virtual memory for other types of I/O <br>    // <br> <br>    if (MappedFileIO) { <br>        if (!UnmapViewOfFile( FileData )) { <br>            State-&gt;CurrentOutput += sprintf( State-&gt;CurrentOutput, <br>                                             "%s(%u) : UnmapViewOfFile( %08x ) failed, error == %u\n", <br>                                             SearchRequest-&gt;FullPathName, <br>                                             LineNumber, <br>                                             FileData, <br>                                             GetLastError() <br>                                           ); <br>            } <br>        } <br>    else { <br>        VirtualFree( FileData, 0, MEM_RELEASE ); <br>        } <br>} <br> <br>  <br>PWORK_QUEUE <br>CreateWorkQueue( <br>    IN DWORD NumberOfWorkerThreads, <br>    IN PWORKER_ROUTINE WorkerRoutine <br>    ) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    This function creates a work queue, with the specified number of <br>    threads to service work items placed in the queue.  Work items <br>    are removed from the queue in the same order that they are placed <br>    in the queue. <br> <br>Arguments: <br> <br>    NumberOfWorkerThreads - Specifies how many threads this function <br>        should create to process work items placed in the queue. <br>        Must be greater than 0 and less than 128. <br> <br>    WorkerRoutine - Specifies the address of a routine to call <br>        for each work item as it is removed from the queue.  The <br>        thread context the routine is called in is undefined. <br> <br>Return Value: <br> <br>    A pointer to the work queue.  Returns NULL if unable to create <br>    the work queue and its worker threads.  Extended error information <br>    is available from GetLastError() <br> <br>--*/ <br> <br>{ <br>    PWORK_QUEUE WorkQueue; <br>    HANDLE Thread; <br>    DWORD ThreadId; <br>    DWORD i; <br> <br>    // <br>    // Allocate space for the work queue, which includes an <br>    // array of thread handles. <br>    // <br> <br>    WorkQueue = LocalAlloc( LMEM_ZEROINIT, <br>                            sizeof( *WorkQueue ) + <br>                                (NumberOfWorkerThreads * sizeof( HANDLE )) </code></pre>
<p>
</p>
<pre><code>); <br>    if (WorkQueue == NULL) { <br>        return NULL; <br>        } <br> <br>    // <br>    // The work queue is controlled by a counting semaphore that <br>    // is incremented each time a work item is placed in the queue <br>    // and decremented each time a worker thread wakes up to remove <br>    // an item from the queue. <br>    // <br> <br>    if (WorkQueue-&gt;Semaphore = CreateSemaphore( NULL, 0, 100000, NULL )) { <br>        // <br>        // Mutual exclusion between the worker threads accessing <br>        // the work queue is done with a critical section. <br>        // <br> <br>        InitializeCriticalSection( &amp;WorkQueue-&gt;CriticalSection ); <br> <br>        // <br>        // The queue itself is just a doubly linked list, where <br>        // items are placed in the queue at the tail of the list <br>        // and removed from the queue from the head of the list. <br>        // <br> <br>        InitializeListHead( &amp;WorkQueue-&gt;Queue ); <br> <br>        // <br>        // Removed the address of the supplied worker function <br>        // in the work queue structure. <br>        // <br> <br>        WorkQueue-&gt;WorkerRoutine = WorkerRoutine; <br> <br>        // <br>        // Now create the requested number of worker threads. <br>        // The handle to each thread is remembered in an <br>        // array of thread handles in the work queue structure. <br>        // <br> <br>        for (i=0; i&lt;NumberOfWorkerThreads; i++) { <br>            Thread = CreateThread( NULL, <br>                                   0, <br>                                   (LPTHREAD_START_ROUTINE) WorkerThread, <br>                                   WorkQueue, <br>                                   0, <br>                                   &amp;ThreadId <br>                                 ); <br>            if (Thread == NULL) { <br>                break; <br>                } <br>            else { <br>                WorkQueue-&gt;NumberOfWorkerThreads++; <br>                WorkQueue-&gt;WorkerThreads[ i ] = Thread; <br>                SetThreadPriority( Thread, THREAD_PRIORITY_ABOVE_NORMAL ); <br>                } <br>            } <br> <br>        // <br>        // If we successfully created all of the worker threads <br>        // then return the address of the work queue structure <br>        // to indicate success. <br>        // <br> <br>        if (i == NumberOfWorkerThreads) { <br>            return WorkQueue; <br>            } <br>        } <br> <br>    // <br>    // Failed for some reason.  Destroy whatever we managed <br>    // to create and return failure to the caller. <br>    // <br> <br>    DestroyWorkQueue( WorkQueue ); <br>    return NULL; <br>} <br> <br> <br>  <br>VOID <br>DestroyWorkQueue( <br>    IN OUT PWORK_QUEUE WorkQueue <br>    ) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    This function destroys a work queue created with the CreateWorkQueue <br>    functions.  It attempts to shut down the worker threads cleanly <br>    by queueing a terminate work item to each worker thread.  It then <br>    waits for all the worker threads to terminate.  If the wait is <br>    not satisfied within 30 seconds, then it goes ahead and terminates <br>    all of the worker threads. <br> <br>Arguments: <br> <br>    WorkQueue - Supplies a pointer to the work queue to destroy. <br> <br>Return Value: <br> <br>    None. <br> <br>--*/ <br> <br>{ <br>    DWORD i; <br>    DWORD rc; <br> <br>    // <br>    // If the semaphore handle field is not NULL, then there <br>    // may be threads to terminate. <br>    // <br> <br>    if (WorkQueue-&gt;Semaphore != NULL) { <br>        // <br>        // Set the termiating flag in the work queue and <br>        // signal the counting semaphore by the number <br>        // worker threads so they will all wake up and <br>        // notice the terminating flag and exit. <br>        // <br> <br>        EnterCriticalSection( &amp;WorkQueue-&gt;CriticalSection ); <br>        _try { <br>            WorkQueue-&gt;Terminating = TRUE; <br>            ReleaseSemaphore( WorkQueue-&gt;Semaphore, <br>                              WorkQueue-&gt;NumberOfWorkerThreads, <br>                              NULL <br>                            ); <br>            } <br>        _finally { <br>            LeaveCriticalSection( &amp;WorkQueue-&gt;CriticalSection ); <br>            } <br> <br>        // <br>        // Wait for all worker threads to wake up and see the <br>        // terminate flag and then terminate themselves.  Timeout <br>        // the wait after 30 seconds. <br>        // <br> <br>        while (TRUE) { <br>            rc = WaitForMultipleObjectsEx( WorkQueue-&gt;NumberOfWorkerThreads, <br>                                           WorkQueue-&gt;WorkerThreads, <br>                                           TRUE, <br>                                           30000, <br>                                           TRUE <br>                                         ); <br>            if (rc == WAIT_IO_COMPLETION) { <br>                // <br>                // If we came out of the wait because an I/O <br>                // completion routine was called, reissue the <br>                // wait. <br>                // <br>                continue; <br>                } <br>            else { <br>                break; <br>                } <br>            } <br> <br>        // <br>        // Now close our thread handles so they will actually <br>        // evaporate.  If the wait above was unsuccessful, <br>        // then first attempt to force the termination of <br>        // each worker thread prior to closing the handle. <br>        // <br> <br>        for (i=0; i&lt;WorkQueue-&gt;NumberOfWorkerThreads; i++) { <br>            if (rc != NO_ERROR) { <br>                TerminateThread( WorkQueue-&gt;WorkerThreads[ i ], rc ); <br>                } <br> <br>            CloseHandle( WorkQueue-&gt;WorkerThreads[ i ] ); <br>            } <br> <br>        // <br>        // All threads stopped, all thread handles closed.  Now <br>        // delete the critical section and close the semaphore <br>        // handle. <br>        // <br> <br>        DeleteCriticalSection( &amp;WorkQueue-&gt;CriticalSection ); <br>        CloseHandle( WorkQueue-&gt;Semaphore ); <br>        } <br> <br>    // <br>    // Everything done, now free the memory used by the work queue. <br>    // <br> <br>    LocalFree( WorkQueue ); <br>    return; <br>} <br> <br> <br>  <br>BOOL <br>QueueWorkItem( <br>    IN OUT PWORK_QUEUE WorkQueue, <br>    IN PWORK_QUEUE_ITEM WorkItem <br>    ) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    This function queues a work item to the passed work queue that is <br>    processed by one of the worker threads associated with the queue. <br> <br>Arguments: <br> <br>    WorkQueue - Supplies a pointer to the work queue that is to <br>        receive the work item. <br> <br>    WorkItem - Supplies a pointer to the work item to add the the queue. <br>        The work item structure contains a doubly linked list entry, the <br>        address of a routine to call and a parameter to pass to that <br>        routine.  It is the routine's responsibility to reclaim the <br>        storage occupied by the WorkItem structure. <br> <br>Return Value: <br> <br>    TRUE if operation was successful.  Otherwise returns FALSE and <br>    extended error information is available from GetLastError() <br> <br>--*/ <br> <br>{ <br>    BOOL Result; <br> <br>    // <br>    // Acquire the work queue critical section and insert the work item <br>    // in the queue and release the semaphore if the work item is not <br>    // already in the list. <br>    // <br> <br>    EnterCriticalSection( &amp;WorkQueue-&gt;CriticalSection ); <br>    Result = TRUE; <br>    _try { <br>        WorkItem-&gt;WorkQueue = WorkQueue; <br>        InsertTailList( &amp;WorkQueue-&gt;Queue, &amp;WorkItem-&gt;List ); <br>        Result = ReleaseSemaphore( WorkQueue-&gt;Semaphore, 1, NULL ); <br>        } <br>    _finally { <br>        LeaveCriticalSection( &amp;WorkQueue-&gt;CriticalSection ); <br>        } <br> <br>    return Result; <br>} <br> <br> <br>  <br>DWORD <br>WorkerThread( <br>    LPVOID lpThreadParameter <br>    ) <br>{ <br>    PWORK_QUEUE WorkQueue = (PWORK_QUEUE)lpThreadParameter; <br>    DWORD rc; <br>    WORK_QUEUE_ITEM InitWorkItem; <br>    PWORK_QUEUE_ITEM WorkItem; <br> <br>    // <br>    // Call the worker routine with an initialize work item <br>    // to give it a change to initialize some per thread <br>    // state that will passed to it for each subsequent <br>    // work item. <br>    // <br> <br>    InitWorkItem.Reason = WORK_INITIALIZE_ITEM; <br>    (WorkQueue-&gt;WorkerRoutine)( &amp;InitWorkItem ); <br>    while( TRUE ) { <br>        _try { <br> <br>            // <br>            // Wait until something is put in the queue (semaphore is <br>            // released), remove the item from the queue, mark it not <br>            // inserted, and execute the specified routine. <br>            // <br> <br>            rc = WaitForSingleObjectEx( WorkQueue-&gt;Semaphore, 0xFFFFFFFF, TRUE ); <br>            if (rc == WAIT_IO_COMPLETION) { <br>                continue; <br>                } <br> <br>            EnterCriticalSection( &amp;WorkQueue-&gt;CriticalSection ); <br>            _try { <br>                if (WorkQueue-&gt;Terminating &amp;&amp; IsListEmpty( &amp;WorkQueue-&gt;Queue )) { <br>                    break; <br>                    } <br> <br>                WorkItem = (PWORK_QUEUE_ITEM)RemoveHeadList( &amp;WorkQueue-&gt;Queue ); <br>                } <br>            _finally { <br>                LeaveCriticalSection( &amp;WorkQueue-&gt;CriticalSection ); <br>                } <br> <br>            // <br>            // Execute the worker routine for this work item. <br>            // <br> <br>            (WorkQueue-&gt;WorkerRoutine)( WorkItem ); <br>            } <br>        _except( EXCEPTION_EXECUTE_HANDLER ) { <br>            // <br>            // Ignore any exceptions from worker routine. <br>            // <br>            } <br>        } <br> <br>    InitWorkItem.Reason = WORK_TERMINATE_ITEM; <br>    (WorkQueue-&gt;WorkerRoutine)( &amp;InitWorkItem ); <br> <br>    ExitThread( 0 ); <br>    return 0;       // This will exit this thread <br>} <br> <br>  <br>BOOL <br>CreateVirtualBuffer( <br>    OUT PVIRTUAL_BUFFER Buffer, <br>    IN DWORD CommitSize, <br>    IN DWORD ReserveSize OPTIONAL <br>    ) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    This function is called to create a virtual buffer.  A virtual <br>    buffer is a contiguous range of virtual memory, where some initial <br>    prefix portion of the memory is committed and the remainder is only <br>    reserved virtual address space.  A routine is provided to extend the <br>    size of the committed region incrementally or to trim the size of <br>    the committed region back to some specified amount. <br> <br>Arguments: <br> <br>    Buffer - Pointer to the virtual buffer control structure that is <br>        filled in by this function. <br> <br>    CommitSize - Size of the initial committed portion of the buffer. <br>        May be zero. <br> <br>    ReserveSize - Amount of virtual address space to reserve for the <br>        buffer.  May be zero, in which case amount reserved is the <br>        committed size plus one, rounded up to the next 64KB boundary. <br> <br>Return Value: <br> <br>    TRUE if operation was successful.  Otherwise returns FALSE and <br>    extended error information is available from GetLastError() <br> <br>--*/ <br> <br>{ <br>    SYSTEM_INFO SystemInformation; <br> <br>    // <br>    // Query the page size from the system for rounding <br>    // our memory allocations. <br>    // <br> <br>    GetSystemInfo( &amp;SystemInformation ); <br>    Buffer-&gt;PageSize = SystemInformation.dwPageSize; <br> <br>    // <br>    // If the reserve size was not specified, default it by <br>    // rounding up the initial committed size to a 64KB <br>    // boundary.  This is because the Win32 Virtual Memory <br>    // API calls always allocate virtual address space on <br>    // 64KB boundaries, so we might well have it available <br>    // for commitment. <br>    // <br> <br>    if (!ARGUMENT_PRESENT( ReserveSize )) { <br>        ReserveSize = ROUND_UP( CommitSize + 1, 0x10000 ); <br>        } <br> <br>    // <br>    // Attempt to reserve the address space. <br>    // <br> <br>    Buffer-&gt;Base = VirtualAlloc( NULL, <br>                                 ReserveSize, <br>                                 MEM_RESERVE, <br>                                 PAGE_READWRITE <br>                               ); <br>    if (Buffer-&gt;Base == NULL) { <br>        // <br>        // Unable to reserve address space, return failure. <br>        // <br> <br>        return FALSE; <br>        } <br> <br>    // <br>    // Attempt to commit some initial portion of the reserved region. <br>    // <br>    // <br> <br>    CommitSize = ROUND_UP( CommitSize, Buffer-&gt;PageSize ); <br>    if (CommitSize == 0 || <br>        VirtualAlloc( Buffer-&gt;Base, <br>                      CommitSize, <br>                      MEM_COMMIT, <br>                      PAGE_READWRITE <br>                    ) != NULL <br>       ) { <br>        // <br>        // Either the size of the committed region was zero or the <br>        // commitment succeeded.  In either case calculate the <br>        // address of the first byte after the committed region <br>        // and the address of the first byte after the reserved <br>        // region and return successs. <br>        // <br> <br>        Buffer-&gt;CommitLimit = (LPVOID) <br>            ((char *)Buffer-&gt;Base + CommitSize); <br> <br>        Buffer-&gt;ReserveLimit = (LPVOID) <br>            ((char *)Buffer-&gt;Base + ReserveSize); <br> <br>        return TRUE; <br>        } <br> <br>    // <br>    // If unable to commit the memory, release the virtual address <br>    // range allocated above and return failure. <br>    // <br> <br>    VirtualFree( Buffer-&gt;Base, 0, MEM_RELEASE ); <br>    return FALSE; <br>} <br> <br> <br>  <br>BOOL <br>ExtendVirtualBuffer( <br>    IN PVIRTUAL_BUFFER Buffer, <br>    IN LPVOID Address <br>    ) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    This function is called to extend the committed portion of a virtual <br>    buffer. <br> <br>Arguments: <br> <br>    Buffer - Pointer to the virtual buffer control structure. <br> <br>    Address - Byte at this address is committed, along with all memory <br>        from the beginning of the buffer to this address.  If the <br>        address is already within the committed portion of the virtual <br>        buffer, then this routine does nothing.  If outside the reserved <br>        portion of the virtual buffer, then this routine returns an <br>        error. <br> <br>        Otherwise enough pages are committed so that the memory from the <br>        base of the buffer to the passed address is a contiguous region <br>        of committed memory. <br> <br> <br>Return Value: <br> <br>    TRUE if operation was successful.  Otherwise returns FALSE and <br>    extended error information is available from GetLastError() <br> <br>--*/ <br> <br>{ <br>    DWORD NewCommitSize; <br>    LPVOID NewCommitLimit; <br> <br>    // <br>    // See if address is within the buffer. <br>    // <br> <br>    if (Address &gt;= Buffer-&gt;Base &amp;&amp; Address &lt; Buffer-&gt;ReserveLimit) { <br>        // <br>        // See if the address is within the committed portion of <br>        // the buffer.  If so return success immediately. <br>        // <br> <br>        if (Address &lt; Buffer-&gt;CommitLimit) { <br>            return TRUE; <br>            } <br> <br>        // <br>        // Address is within the reserved portion.  Determine how many <br>        // bytes are between the address and the end of the committed <br>        // portion of the buffer.  Round this size to a multiple of <br>        // the page size and this is the amount we will attempt to <br>        // commit. <br>        // <br> <br>        NewCommitSize = <br>            ((DWORD)ROUND_UP( (DWORD)Address + 1, Buffer-&gt;PageSize ) - <br>             (DWORD)Buffer-&gt;CommitLimit <br>            ); <br> <br>        // <br>        // Attempt to commit the memory. <br>        // <br> <br>        NewCommitLimit = VirtualAlloc( Buffer-&gt;CommitLimit, <br>                                       NewCommitSize, <br>                                       MEM_COMMIT, <br>                                       PAGE_READWRITE <br>                                     ); <br>        if (NewCommitLimit != NULL) { <br>            // <br>            // Successful, so update the upper limit of the committed <br>            // region of the buffer and return success. <br>            // <br> <br>            Buffer-&gt;CommitLimit = (LPVOID) <br>                ((DWORD)NewCommitLimit + NewCommitSize); <br> <br>            return TRUE; <br>            } <br>        } <br> <br>    // <br>    // Address is outside of the buffer, return failure. <br>    // <br> <br>    return FALSE; <br>} <br> <br> <br>BOOL <br>TrimVirtualBuffer( <br>    IN PVIRTUAL_BUFFER Buffer <br>    ) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    This function is called to decommit any memory that has been <br>    committed for this virtual buffer. <br> <br>Arguments: <br> <br>    Buffer - Pointer to the virtual buffer control structure. <br> <br>Return Value: <br> <br>    TRUE if operation was successful.  Otherwise returns FALSE and <br>    extended error information is available from GetLastError() <br> <br>--*/ <br> <br>{ <br>    Buffer-&gt;CommitLimit = Buffer-&gt;Base; <br>    return VirtualFree( Buffer-&gt;Base, 0, MEM_DECOMMIT ); <br>} <br> <br> <br> <br>BOOL <br>FreeVirtualBuffer( <br>    IN PVIRTUAL_BUFFER Buffer <br>    ) <br>/*++ <br> <br>Routine Description: <br> <br>    This function is called to free all the memory that is associated <br>    with this virtual buffer. <br> <br>Arguments: <br> <br>    Buffer - Pointer to the virtual buffer control structure. <br> <br>Return Value: <br> <br>    TRUE if operation was successful.  Otherwise returns FALSE and <br>    extended error information is available from GetLastError() <br> <br>--*/ <br> <br>{ <br>    // <br>    // Decommit and release all virtual memory associated with <br>    // this virtual buffer. <br>    // <br> <br>    return VirtualFree( Buffer-&gt;Base, 0, MEM_RELEASE ); <br>} <br> <br> <br>  <br>int <br>VirtualBufferExceptionFilter( <br>    IN DWORD ExceptionCode, <br>    IN PEXCEPTION_POINTERS ExceptionInfo, <br>    IN OUT PVIRTUAL_BUFFER Buffer <br>    ) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    This function is an exception filter that handles exceptions that <br>    referenced uncommitted but reserved memory contained in the passed <br>    virtual buffer.  It this filter routine is able to commit the <br>    additional pages needed to allow the memory reference to succeed, <br>    then it will re-execute the faulting instruction.  If it is unable <br>    to commit the pages, it will execute the callers exception handler. <br> <br>    If the exception is not an access violation or is an access <br>    violation but does not reference memory contained in the reserved <br>    portion of the virtual buffer, then this filter passes the exception <br>    on up the exception chain. <br> <br>Arguments: <br> <br>    ExceptionCode - Reason for the exception. <br> <br>    ExceptionInfo - Information about the exception and the context <br>        that it occurred in. <br> <br>    Buffer - Points to a virtual buffer control structure that defines <br>        the reserved memory region that is to be committed whenever an <br>        attempt is made to access it. <br> <br>Return Value: <br> <br>    Exception disposition code that tells the exception dispatcher what <br>    to do with this exception.  One of three values is returned: <br> <br>        EXCEPTION_EXECUTE_HANDLER - execute the exception handler <br>            associated with the exception clause that called this filter <br>            procedure. <br> <br>        EXCEPTION_CONTINUE_SEARCH - Continue searching for an exception <br>            handler to handle this exception. <br> <br>        EXCEPTION_CONTINUE_EXECUTION - Dismiss this exception and return <br>            control to the instruction that caused the exception. <br> <br> <br>--*/ <br> <br>{ <br>    LPVOID FaultingAddress; <br> <br>    // <br>    // If this is an access violation touching memory within <br>    // our reserved buffer, but outside of the committed portion <br>    // of the buffer, then we are going to take this exception. <br>    // <br> <br>    if (ExceptionCode == STATUS_ACCESS_VIOLATION) { <br>        // <br>        // Get the virtual address that caused the access violation <br>        // from the exception record.  Determine if the address <br>        // references memory within the reserved but uncommitted <br>        // portion of the virtual buffer. <br>        // <br> <br>        FaultingAddress = (LPVOID)ExceptionInfo-&gt;ExceptionRecord-&gt;ExceptionInformation[ 1 ]; <br>        if (FaultingAddress &gt;= Buffer-&gt;CommitLimit &amp;&amp; <br>            FaultingAddress &lt;= Buffer-&gt;ReserveLimit <br>           ) { <br>            // <br>            // This is our exception.  Try to extend the buffer <br>            // to including the faulting address. <br>            // <br> <br>            if (ExtendVirtualBuffer( Buffer, FaultingAddress )) { <br>                // <br>                // Buffer successfully extended, so re-execute the <br>                // faulting instruction. <br>                // <br> <br>                return EXCEPTION_CONTINUE_EXECUTION; <br>                } <br>            else { <br>                // <br>                // Unable to extend the buffer.  Stop searching <br>                // for exception handlers and execute the caller's <br>                // handler. <br>                // <br> <br>                return EXCEPTION_EXECUTE_HANDLER; <br>                } <br>            } <br>        } <br> <br>    // <br>    // Not an exception we care about, so pass it up the chain. <br>    // <br> <br>    return EXCEPTION_CONTINUE_SEARCH; <br>} <br> <br>  <br>BOOL <br>EnumerateDirectoryTree( <br>    LPSTR DirectoryPath, <br>    PDIRECTORY_ENUMERATE_ROUTINE EnumerateRoutine, <br>    PVOID EnumerateParameter <br>    ) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    This function walks a directory tree, depth first, calling the <br>    passed enumeration routine for each directory and file found <br>    in the tree.  The enumeration routine is passed the full path <br>    of the file, the directory information associated with the file <br>    and an enumeration parameter that is uninterpreted by this <br>    function. <br> <br>Arguments: <br> <br>    DirectoryPath - Absolute or relative path to the directory that <br>        will is the root of the tree to enumerate. <br> <br>    EnumerateRoutine - Pointer to an enumeration routine to call <br>        for each file and directory found. <br> <br>    EnumerateParameter - Uninterpreted 32-bit value that is passed <br>        to the EnumerationRoutine each time it is called. <br> <br>Return Value: <br> <br>    TRUE if operation was successful.  Otherwise returns FALSE and <br>    extended error information is available from GetLastError() <br> <br>--*/ <br> <br>{ <br>    BOOL Result; <br>    VIRTUAL_BUFFER Buffer; <br>    PENUMERATE_DIRECTORY_STATE State; <br>    PENUMERATE_DIRECTORY_STACK Stack; <br>    WIN32_FIND_DATA FindFileData; <br> <br>    // <br>    // Create a virtual buffer with an initial committed size of <br>    // our directory state buffer, and a maximum reserved size of <br>    // the longest possible full path based on the maximum depth <br>    // we handle and the maximum length of each path component. <br>    // <br> <br>    if (!CreateVirtualBuffer( &amp;Buffer, <br>                              sizeof( ENUMERATE_DIRECTORY_STATE ), <br>                              sizeof( ENUMERATE_DIRECTORY_STATE ) + <br>                                 MAX_DEPTH * MAX_PATH <br>                            ) <br>       ) { <br>        return FALSE; <br>        } <br> <br>    // <br>    // This buffer will be used to maintain a stack of directory <br>    // search handles, as well as accumulate the full path string <br>    // as we descend the directory tree. <br>    // <br> <br>    State = (PENUMERATE_DIRECTORY_STATE)Buffer.Base; <br>    State-&gt;Depth = 0; <br>    Stack = &amp;State-&gt;Stack[ 0 ]; <br> <br>    // <br>    // Enter a try ... finally block so we can insure that we clean <br>    // up after ourselves on exit. <br>    // <br> <br>    _try { <br>        // <br>        // First translate the passed in DirectoryPath into a fully <br>        // qualified path.  This path will be the initial value in <br>        // our path buffer.  The initial allocation of the path buffer <br>        // is big enough for this initial request, so does not need <br>        // to be guarded by a try ... except clause. <br>        // <br> <br>        if (GetFullPathName( DirectoryPath, MAX_PATH, State-&gt;Path, &amp;Stack-&gt;PathEnd )) { <br>            // <br>            // Now enter a try ... except block that will be used to <br>            // manage the commitment of space in the path buffer as <br>            // we append subdirectory names and file names to it. <br>            // Using the virtual buffer allows us to handle full <br>            // path names up to 16KB in length, with an initial <br>            // allocation of 4KB. <br>            // <br> <br>            _try { <br>                // <br>                // Walk the directory tree.  The outer loop is executed <br>                // once for each directory in the tree. <br>                // <br> <br>                while (TRUE) { <br>startDirectorySearch: <br>                    // <br>                    // Find the end of the current path, and make sure <br>                    // there is a trailing path separator. <br>                    // <br> <br>                    Stack-&gt;PathEnd = strchr( State-&gt;Path, '\0' ); <br>                    if (Stack-&gt;PathEnd &gt; State-&gt;Path &amp;&amp; Stack-&gt;PathEnd[ -1 ] != '\\') { <br>                        *(Stack-&gt;PathEnd)++ = '\\'; <br>                        } <br> <br>                    // <br>                    // Now append the wild card specification that will <br>                    // let us enumerate all the entries in this directory. <br>                    // Call FindFirstFile to find the first entry in the <br>                    // directory. <br>                    // <br> <br>                    strcpy( Stack-&gt;PathEnd, "*.*" ); <br>                    Stack-&gt;FindHandle = FindFirstFile( State-&gt;Path, <br>                                                       &amp;FindFileData <br>                                                     ); <br>                    if (Stack-&gt;FindHandle != INVALID_HANDLE_VALUE) { <br>                        // <br>                        // Entry found.  Now loop through the entire <br>                        // directory processing each entry found, <br>                        // including the first one. <br>                        // <br>                        do { <br>                            // <br>                            // Ignore bogus pseudo-directories that are <br>                            // returned by some file systems (e.g. FAT). <br>                            // <br> <br>                            if (FindFileData.dwFileAttributes &amp; FILE_ATTRIBUTE_DIRECTORY &amp;&amp; <br>                                (!strcmp( FindFileData.cFileName, "." ) || <br>                                 !strcmp( FindFileData.cFileName, ".." ) <br>                                ) <br>                               ) { <br>                                continue; <br>                                } <br> <br>                            // <br>                            // Copy the file name portion from the current <br>                            // directory entry to the last component in the <br>                            // path buffer. <br>                            // <br> <br>                            strcpy( Stack-&gt;PathEnd, FindFileData.cFileName ); <br> <br>                            // <br>                            // Call the supplied enumeration routine with the <br>                            // full path we have built up in the path buffer, <br>                            // the directory information for this directory <br>                            // entry and the supplied enumeration parameter. <br>                            // <br> <br>                            (*EnumerateRoutine)( State-&gt;Path, &amp;FindFileData, EnumerateParameter ); <br> <br>                            // <br>                            // If this is entry is a subdirectory, then it is <br>                            // time to recurse.  Do this by incrementing the <br>                            // stack pointer and depth and jumping to the top <br>                            // of the outer loop to process current contents <br>                            // of the path buffer as a fully qualified name of <br>                            // a directory. <br>                            // <br> <br>                            if (FindFileData.dwFileAttributes &amp; FILE_ATTRIBUTE_DIRECTORY) { <br>                                Stack++; <br>                                State-&gt;Depth++; <br>                                goto startDirectorySearch; <br>restartDirectorySearch:         ; <br>                                } <br> <br>                            // <br>                            // Here to find the next entry in the current directory. <br>                            // <br>                            } <br> <br>                        while ( FindNextFile( Stack-&gt;FindHandle, &amp;FindFileData ) ); <br> <br>                        // <br>                        // No more entries in the current directory, so close <br>                        // the search handle and fall into the code that will <br>                        // pop our stack of directory seacrh handles. <br> <br>                        FindClose( Stack-&gt;FindHandle ); <br>                        } <br> <br>                    // <br>                    // Here when done with a directory.  See if we are pushed <br>                    // inside another directory.  If not, then we are done <br>                    // enumerating the whole tree, so break out of the loop. <br>                    // <br> <br>                    if (!State-&gt;Depth) { <br>                        Result = TRUE; <br>                        break; <br>                        } <br> <br>                    // <br>                    // We were pushed within another directory search, <br>                    // so pop the stack to restore its search handle <br>                    // and path buffer position and resume the search <br>                    // within that directory. <br> <br>                    State-&gt;Depth--; <br>                    --Stack; <br>                    goto restartDirectorySearch; <br>                    } <br>                } <br> <br>            // <br>            // Any of the code that appends to the path buffer within <br>            // the above try ... except clause can cause an access <br>            // violation if the path buffer becomes longer than its <br>            // current committed size.  This exception filter <br>            // will dynamically commit additional pages as needed <br>            // and resume execution. <br>            // <br> <br>            _except( VirtualBufferExceptionFilter( GetExceptionCode(), <br>                                                  GetExceptionInformation(), <br>                                                  &amp;Buffer </code></pre>
<p>
</p>
<pre><code>) <br>                  ) { <br>                // <br>                // We will get here if the exception filter was unable to <br>                // commit the memory. <br>                // <br> <br>                Result = FALSE; <br>                } <br>            } <br>        else { <br>            // <br>            // Initial GetFullPathName failed, so return a failure. <br>            // <br> <br>            Result = FALSE; <br>            } <br>        } <br>    _finally { <br>        // <br>        // Here on our way out of the outer try ... finally block. <br>        // Make sure all our search handles have been closed and then <br>        // free the virtual buffer.  The only way this code is not <br>        // executed is if code within the try ... finally block <br>        // called ExitThread or ExitProcess, or an external thread <br>        // or process terminated this thread or process. <br>        // <br>        // In the case of process death, this is not a problem, because <br>        // process terminate closes all open handles attached to the process <br>        // and frees all private virtual memory that is part of the address <br>        // space of the process. <br>        // <br>        // In the case ot thread death, the code below is not executed if <br>        // the thread terminates via ExitThread in the context of the <br>        // try .. finally or if an external thread, either in this process <br>        // or another process called TerminateThread on this thread. <br>        // <br> <br>        while (State-&gt;Depth--) { <br>            --Stack; <br>            FindClose( Stack-&gt;FindHandle ); <br>            } <br> <br>        FreeVirtualBuffer( &amp;Buffer ); <br>        } <br> <br>    return Result; <br>} <br> <br> <br>BOOL <br>ProcessCommandLineArguments( <br>    int argc, <br>    char *argv[] <br>    ) <br>{ <br>    BOOL Result; <br>    LPSTR s; <br> <br>    Result = FALSE; <br>    _try { <br>        if (argc &lt; 1) { <br>            return Result; <br>            } <br> <br>        while (--argc) { <br>            s = *++argv; <br>            if (*s == '-' || *s == '/') { <br>                while (*++s) { <br>                    switch( tolower( *s ) ) { <br>                        case 'm': <br>                            MappedFileIO = TRUE; <br>                            break; <br> <br>                        case 'a': <br>                            ASyncIO = TRUE; <br>                            break; <br> <br>                        case 's': <br>                            SyncIO = TRUE; <br>                            break; <br> <br>                        case 'v': <br>                            Verbose = TRUE; <br>                            break; <br> <br>                        case 'y': <br>                            IgnoreCase = TRUE; <br>                            break; <br> <br>                        case 't': <br>                            if (--argc) { <br>                                NumberOfWorkerThreads = atoi( *++argv ); <br>                                if (NumberOfWorkerThreads &gt; 0 &amp;&amp; NumberOfWorkerThreads &lt; 128) { <br>                                    break; <br>                                    } <br>                                } <br> <br>                            // fall through if -t argument missing. <br> <br>                        case '?': <br>                        case 'h': <br>                        default: <br>                            return Result; <br>                        } <br>                    } <br>                } <br>            else <br>            if (SearchString == NULL) { <br>                SearchString = s; <br>                } <br>            else <br>            if (DirectoryPath == NULL) { <br>                DirectoryPath = s; <br>                } <br>            else { <br>                return Result; <br>                } <br>            } <br> <br>        if (SearchString == NULL) { <br>            return Result; <br>            } <br> <br>        SearchStringLength = strlen( SearchString ); <br>        if (SearchStringLength == 0) { <br>            return Result; <br>            } <br> <br>        if (IgnoreCase) { <br>            SearchFunction = _strnicmp; <br>            } <br>        else { <br>            SearchFunction = strncmp; <br>            } <br> <br>        if (DirectoryPath == NULL) { <br>            DirectoryPath = "."; <br>            } <br> <br>        if (!(MappedFileIO || ASyncIO || SyncIO)) { <br>            MappedFileIO = TRUE; <br>            } <br> <br>        if (Verbose) { <br>            fprintf( stderr, "Directory Tree: %s\n", DirectoryPath ); <br>            fprintf( stderr, "Search String: '%s'\n", SearchString ); <br>            fprintf( stderr, "Case %ssensitive\n", IgnoreCase ? "in" : "" ); <br>            fprintf( stderr, "Number of Worker Threads: %u\n", NumberOfWorkerThreads ); <br>            if (MappedFileIO) { <br>                fprintf( stderr, "Using Mapped File I/O\n" ); <br>                } <br>            else <br>            if (ASyncIO) { <br>                fprintf( stderr, "Using ASynchronous File I/O\n" ); <br>                } <br>            else <br>            if (MappedFileIO) { <br>                fprintf( stderr, "Using Synchronous File I/O\n" ); <br>                } <br>            } <br> <br>        Result = TRUE; <br>        return Result; <br>        } <br>    _finally { <br>        if (!Result) { <br>            fprintf( stderr, "usage: PDC [-h] [-v] [-y] [-a | -s | -m] [-t n] SearchString [DirectoryPath]\n" ); <br>            fprintf( stderr, "Where...\n" ); <br>            fprintf( stderr, "    -h - prints this message\n" ); <br>            fprintf( stderr, "    -v - generates verbose output\n" ); <br>            fprintf( stderr, "    -y - ignores case when doing comparision\n" ); <br>            fprintf( stderr, "    -t - specifies the number of threads to use (defaults to 4 * number of processors)\n" ); <br>            fprintf( stderr, "    -a - uses asynchronous file I/O\n" ); <br>            fprintf( stderr, "    -s - uses synchronous file I/O\n" ); <br>            fprintf( stderr, "    -m - uses mapped file I/O (default)\n" ); <br>            fprintf( stderr, "    SearchString - specifies the text to search for\n" ); <br>            fprintf( stderr, "    DirectoryPath - specifies the directory to start from (defaults to .)\n" ); <br>            } <br>        } <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
