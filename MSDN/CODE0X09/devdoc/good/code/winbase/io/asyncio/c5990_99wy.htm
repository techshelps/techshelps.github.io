<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>PDC.H</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5992"></a>PDC.H</h2>
<pre><code>/*++ <br> <br>Copyright 1992 - 1998 Microsoft Corporation <br> <br>Module Name: <br> <br>    pdc.h <br> <br>Abstract: <br> <br>    This is the main source file for the Windows/NT PDC API demonstration <br>    program.  This include file defines macros, data structures and procedure <br>    prototypes for the code contained in the PDC.C source file. <br> <br>--*/ <br> <br>// <br>// Include file for using the Win32 API <br>// <br> <br>#include &lt;windows.h&gt; <br> <br>// <br>// C Runtime include files used by the program. <br>// <br> <br>#include &lt;stdio.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;errno.h&gt; <br>#include &lt;ctype.h&gt; <br>#include &lt;string.h&gt; <br>#include &lt;io.h&gt; <br>#include &lt;fcntl.h&gt; <br>#include &lt;malloc.h&gt; <br>#include &lt;sys\types.h&gt; <br>#include &lt;sys\stat.h&gt; <br> <br> <br>// <br>// Macro definitions <br>// <br> <br>// <br>// Useful rounding macros that the rounding amount is always a <br>// power of two. <br>// <br> <br>#define ROUND_DOWN( Size, Amount ) ((DWORD)(Size) &amp; ~((Amount) - 1)) <br>#define ROUND_UP( Size, Amount ) (((DWORD)(Size) + ((Amount) - 1)) &amp; ~((Amount) - 1)) <br> <br>// <br>// Pseudo keywords for documentation purposes. <br>// <br> <br>#define IN <br>#define OUT <br>#define OPTIONAL <br> <br>// <br>// Determine if an argument is present by testing a value of NULL <br>// <br> <br>#define ARGUMENT_PRESENT( ArgumentPointer )    (\ <br>    (LPSTR)(ArgumentPointer) != (LPSTR)(NULL) ) <br> <br> <br> <br>// <br>// Calculate the address of the base of the structure given its type, and an <br>// address of a field within the structure. <br>// <br> <br>#define CONTAINING_RECORD( address, type, field ) ((type *)( \ <br>                                                   (PCHAR)(address) - \ <br>                                                   (PCHAR)(&amp;((type *)0)-&gt;field))) <br> <br>  <br>// <br>// Virtual Buffer data structure and function prototypes. <br>// <br> <br>typedef struct _VIRTUAL_BUFFER { <br>    LPVOID Base; <br>    ULONG PageSize; <br>    LPVOID CommitLimit; <br>    LPVOID ReserveLimit; <br>} VIRTUAL_BUFFER, *PVIRTUAL_BUFFER; <br> <br>BOOL <br>CreateVirtualBuffer( <br>    OUT PVIRTUAL_BUFFER Buffer, <br>    IN DWORD CommitSize, <br>    IN DWORD ReserveSize OPTIONAL <br>    ); <br> <br>BOOL <br>ExtendVirtualBuffer( <br>    IN PVIRTUAL_BUFFER Buffer, <br>    IN LPVOID Address <br>    ); <br> <br>BOOL <br>TrimVirtualBuffer( <br>    IN PVIRTUAL_BUFFER Buffer <br>    ); <br> <br>BOOL <br>FreeVirtualBuffer( <br>    IN PVIRTUAL_BUFFER Buffer <br>    ); <br> <br>int <br>VirtualBufferExceptionFilter( <br>    IN DWORD ExceptionCode, <br>    IN PEXCEPTION_POINTERS ExceptionInfo, <br>    IN OUT PVIRTUAL_BUFFER Buffer <br>    ); <br>  <br> <br>// <br>// Directory enumeration and file notification definitions. <br>// <br> <br>typedef <br>VOID (*PDIRECTORY_ENUMERATE_ROUTINE)( <br>    LPSTR Path, <br>    PWIN32_FIND_DATA FindFileData, <br>    PVOID EnumerateParameter <br>    ); <br> <br>BOOL <br>EnumerateDirectoryTree( <br>    LPSTR DirectoryPath, <br>    PDIRECTORY_ENUMERATE_ROUTINE EnumerateRoutine, <br>    PVOID EnumerateParameter <br>    ); <br> <br>// <br>// Data structures private to the EnumerateDirectoryTree function. <br>// <br> <br>typedef struct _ENUMERATE_DIRECTORY_STACK { <br>    LPSTR PathEnd; <br>    HANDLE FindHandle; <br>} ENUMERATE_DIRECTORY_STACK, *PENUMERATE_DIRECTORY_STACK; <br> <br>#define MAX_DEPTH 256 <br> <br>typedef struct _ENUMERATE_DIRECTORY_STATE { <br>    DWORD Depth; <br>    ENUMERATE_DIRECTORY_STACK Stack[ MAX_DEPTH ]; <br>    CHAR Path[ MAX_PATH ]; <br>} ENUMERATE_DIRECTORY_STATE, *PENUMERATE_DIRECTORY_STATE; <br> <br> <br>  <br>// <br>//  Doubly-linked list manipulation routines.  Implemented as macros <br>//  but logically these are procedures. <br>// <br> <br>// <br>//  VOID <br>//  InitializeListHead( <br>//      PLIST_ENTRY ListHead <br>//      ); <br>// <br> <br>#define InitializeListHead(ListHead) (\ <br>    (ListHead)-&gt;Flink = (ListHead)-&gt;Blink = (ListHead) ) <br> <br>// <br>//  BOOLEAN <br>//  IsListEmpty( <br>//      PLIST_ENTRY ListHead <br>//      ); <br>// <br> <br>#define IsListEmpty(ListHead) (\ <br>    ( ((ListHead)-&gt;Flink == (ListHead)) ? TRUE : FALSE ) ) <br> <br>// <br>//  PLIST_ENTRY <br>//  RemoveHeadList( <br>//      PLIST_ENTRY ListHead <br>//      ); <br>// <br> <br>#define RemoveHeadList(ListHead) \ <br>    (ListHead)-&gt;Flink;\ <br>    {\ <br>        PLIST_ENTRY FirstEntry;\ <br>        FirstEntry = (ListHead)-&gt;Flink;\ <br>        FirstEntry-&gt;Flink-&gt;Blink = (ListHead);\ <br>        (ListHead)-&gt;Flink = FirstEntry-&gt;Flink;\ <br>    } <br> <br>// <br>//  VOID <br>//  RemoveEntryList( <br>//      PLIST_ENTRY Entry <br>//      ); <br>// <br> <br>#define RemoveEntryList(Entry) {\ <br>        PLIST_ENTRY _EX_Entry;\ <br>        _EX_Entry = (Entry);\ <br>        _EX_Entry-&gt;Blink-&gt;Flink = _EX_Entry-&gt;Flink;\ <br>        _EX_Entry-&gt;Flink-&gt;Blink = _EX_Entry-&gt;Blink;\ <br>        } <br> <br>// <br>//  VOID <br>//  InsertTailList( <br>//      PLIST_ENTRY ListHead, <br>//      PLIST_ENTRY Entry <br>//      ); <br>// <br> <br>#define InsertTailList(ListHead,Entry) \ <br>    (Entry)-&gt;Flink = (ListHead);\ <br>    (Entry)-&gt;Blink = (ListHead)-&gt;Blink;\ <br>    (ListHead)-&gt;Blink-&gt;Flink = (Entry);\ <br>    (ListHead)-&gt;Blink = (Entry) <br> <br>// <br>//  VOID <br>//  InsertHeadList( <br>//      PLIST_ENTRY ListHead, <br>//      PLIST_ENTRY Entry <br>//      ); <br>// <br> <br>#define InsertHeadList(ListHead,Entry) \ <br>    (Entry)-&gt;Flink = (ListHead)-&gt;Flink;\ <br>    (Entry)-&gt;Blink = (ListHead);\ <br>    (ListHead)-&gt;Flink-&gt;Blink = (Entry);\ <br>    (ListHead)-&gt;Flink = (Entry) <br> <br> <br>  <br>// <br>// Worker thread definitions <br>// <br> <br>typedef <br>VOID <br>(*PWORKER_ROUTINE)( <br>  //  IN PWORK_QUEUE_ITEM WorkItem <br>    ); <br> <br>typedef struct _WORK_QUEUE { <br>    CRITICAL_SECTION CriticalSection; <br>    HANDLE Semaphore; <br>    LIST_ENTRY Queue; <br>    BOOL Terminating; <br>    PWORKER_ROUTINE WorkerRoutine; <br>    DWORD NumberOfWorkerThreads; <br>    HANDLE WorkerThreads[ 1 ];      // Variable length array <br>} WORK_QUEUE, *PWORK_QUEUE; <br> <br>typedef struct _WORK_QUEUE_ITEM { <br>    LIST_ENTRY List; <br>    DWORD Reason; <br>    PWORK_QUEUE WorkQueue; <br>} WORK_QUEUE_ITEM, *PWORK_QUEUE_ITEM; <br> <br>#define WORK_INITIALIZE_ITEM 0 <br>#define WORK_ITEM            1 <br>#define WORK_TERMINATE_ITEM  2 <br> <br>DWORD <br>WorkerThread( <br>    LPVOID lpThreadParameter <br>    ); <br> <br>PWORK_QUEUE <br>CreateWorkQueue( <br>    IN DWORD NumberOfWorkerThreads, <br>    IN PWORKER_ROUTINE WorkerRoutine <br>    ); <br> <br>BOOL <br>QueueWorkItem( <br>    IN OUT PWORK_QUEUE WorkQueue, <br>    IN PWORK_QUEUE_ITEM WorkItem <br>    ); <br> <br>VOID <br>DestroyWorkQueue( <br>    IN OUT PWORK_QUEUE WorkQueue <br>    ); <br> <br>  <br>// <br>// Main procedure prototypes <br>// <br> <br>BOOL <br>ProcessCommandLineArguments( <br>    int argc, <br>    char *argv[] <br>    ); <br> <br>VOID <br>QueueSearchFile( <br>    LPSTR Path, <br>    PWIN32_FIND_DATA FindFileData, <br>    PVOID EnumerateParameter <br>    ); <br> <br>typedef struct _SEARCH_REQUEST_STATE { <br>    VIRTUAL_BUFFER Buffer; <br>    LPSTR CurrentOutput; <br>} SEARCH_REQUEST_STATE, *PSEARCH_REQUEST_STATE; <br> <br> <br>typedef struct _SEARCH_REQUEST { <br>    WORK_QUEUE_ITEM WorkItem; <br>    DWORD FileSize; <br>    LPSTR FileData; <br>    HANDLE File; <br>    OVERLAPPED OverlappedIO; <br>    CHAR FullPathName[ 1 ];         // Variable length array <br>} SEARCH_REQUEST, *PSEARCH_REQUEST; <br> <br> <br>VOID <br>ProcessRequest( <br>    IN PWORK_QUEUE_ITEM WorkItem <br>    ); <br> <br>VOID <br>ProcessReadFileCompletion( <br>    DWORD dwErrorCode, <br>    DWORD dwNumberOfBytesTransfered, <br>    LPOVERLAPPED lpOverlapped <br>    ); <br> <br>VOID <br>ProcessSearchFile( <br>    IN PSEARCH_REQUEST WorkerRequest, <br>    IN PSEARCH_REQUEST_STATE State <br>    ); <br> <br> <br>// <br>// Global variables <br>// <br> <br>DWORD TlsIndex; <br>INT NumberOfWorkerThreads; <br>BOOL Verbose; <br>BOOL IgnoreCase; <br>BOOL MappedFileIO; <br>BOOL ASyncIO; <br>BOOL SyncIO; <br>LPSTR DirectoryPath; <br>LPSTR SearchString; <br>DWORD SearchStringLength; <br>DWORD SearchedFileCount; <br>DWORD MatchedFileCount; <br>DWORD MatchedLineCount; <br>LONG  OutstandingIOOperations; <br>HANDLE IoCompletedEvent; <br> <br>typedef <br>int <br>(_CRTAPI1 *PCOMPARE_ROUTINE)( <br>    IN const char *, <br>    IN const char *, <br>    IN size_t <br>    ); <br> <br>PCOMPARE_ROUTINE SearchFunction; <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
