<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>FWATCH.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6006"></a>FWATCH.C</h2>
<pre><code>/********************************************************************** <br>   File name: fwatch.c <br> <br>      Main source file for sample demonstrating use of file change <br>      notification APIs. <br> <br>   Functions: <br> <br>      CheckChangedFile()      - Gets and displays change information <br>      HandleDirectoryChange() - Watch function <br>      WatchDirectories()      - Starts the watch <br>      main()                  - Program main <br> <br> <br>   Written by Microsoft Product Support Services, Windows Developer Support. <br>   Copyright 1996 - 1998 Microsoft Corporation. All rights reserved. <br>**********************************************************************/ <br>#define UNICODE <br> <br>#include &lt;stdio.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;conio.h&gt; <br>#include &lt;windows.h&gt; <br> <br>#define MAX_DIRS    10 <br>#define MAX_FILES   255 <br>#define MAX_BUFFER  4096 <br> <br>// this is the all purpose structure that contains   <br>// the interesting directory information and provides <br>// the input buffer that is filled with file change data <br>typedef struct _DIRECTORY_INFO { <br>HANDLE      hDir; <br>TCHAR       lpszDirName[MAX_PATH]; <br>CHAR        lpBuffer[MAX_BUFFER]; <br>DWORD       dwBufLength; <br>OVERLAPPED  Overlapped; <br>}DIRECTORY_INFO, *PDIRECTORY_INFO, *LPDIRECTORY_INFO; <br> <br>DIRECTORY_INFO  DirInfo[MAX_DIRS];        // Buffer for all of the directories <br>TCHAR           FileList[MAX_FILES*MAX_PATH];   // Buffer for all of the files <br>DWORD           numDirs; <br> <br> <br>/********************************************************************** <br>   CheckChangedFile() <br> <br>   Purpose: <br>      This function prints out information when one of the files we <br>      are watching is changed. <br> <br>   Parameters: <br> <br>      LPDIRECTORY_INFO lpdi - Information about the watched directory <br>      PFILE_NOTIFY_INFORMATION lpfni - Information about modified file <br> <br> <br>   Return Value: <br>      None <br> <br>   Comments: <br> <br>********************************************************************/ <br>void WINAPI CheckChangedFile( LPDIRECTORY_INFO lpdi, <br>                              PFILE_NOTIFY_INFORMATION lpfni) <br>{ <br>    TCHAR      szFullPathName[MAX_PATH]; <br>    TCHAR      *p; <br>    HANDLE     hFile; <br>    FILETIME   LocalFileTime; <br>    SYSTEMTIME SystemTime; <br>    BY_HANDLE_FILE_INFORMATION FileInfo; <br> <br>    p = FileList; <br> <br>    while(*p &amp;&amp; lstrcmpi(p,lpfni-&gt;FileName)) <br>        p+=(lstrlen(p)+1); <br> <br>    if(*p) <br>    { <br>        lstrcpy( szFullPathName, lpdi-&gt;lpszDirName ); <br>        lstrcat( szFullPathName, L"\\" ); <br>        lstrcat( szFullPathName, lpfni-&gt;FileName ); <br> <br>        // we assume that the file was changed, since  <br>        // that is the only thing we look for in this sample <br>        wprintf( L"%s changed,", szFullPathName ); <br> <br>        hFile=CreateFile( szFullPathName, <br>                          GENERIC_READ, <br>                          FILE_SHARE_READ, <br>                          NULL, <br>                          OPEN_EXISTING, <br>                          FILE_FLAG_SEQUENTIAL_SCAN, <br>                          0); <br> <br>        GetFileInformationByHandle( hFile, &amp;FileInfo ); <br> <br>        FileTimeToLocalFileTime( &amp;(FileInfo.ftLastWriteTime), &amp;LocalFileTime ); <br> <br>        FileTimeToSystemTime( &amp;LocalFileTime, &amp;SystemTime ); <br> <br>        wprintf( L" Size = %d bytes,", FileInfo.nFileSizeLow ); <br>        wprintf( L" Last Access = %02d/%02d/%02d %02d:%02d:%02d", <br>                 SystemTime.wMonth, <br>                 SystemTime.wDay, <br>                 SystemTime.wYear, <br>                 SystemTime.wHour, <br>                 SystemTime.wMinute, <br>                 SystemTime.wSecond ); <br> <br>        CloseHandle( hFile ); <br> <br>        wprintf( L"\n" ); <br>    } <br>} <br> <br> <br>/********************************************************************** <br>   HandleDirectoryChanges() <br> <br>   Purpose: <br>      This function receives notification of directory changes and <br>      calls CheckChangedFile() to display the actual changes. After <br>      notification and processing, this function calls <br>      ReadDirectoryChangesW to reestablish the watch. <br> <br>   Parameters: <br> <br>      HANDLE hCompPort - Handle for completion port <br> <br> <br>   Return Value: <br>      None <br> <br>   Comments: <br> <br>********************************************************************/ <br>void WINAPI HandleDirectoryChange( DWORD dwCompletionPort ) <br>{ <br>    DWORD numBytes; <br>    DWORD cbOffset; <br>    LPDIRECTORY_INFO di; <br>    LPOVERLAPPED lpOverlapped; <br>    PFILE_NOTIFY_INFORMATION fni; <br> <br>    do <br>    { <br>        // Retrieve the directory info for this directory <br>        // through the completion key <br>        GetQueuedCompletionStatus( (HANDLE) dwCompletionPort, <br>                                   &amp;numBytes, <br>                                   (LPDWORD) &amp;di, <br>                                   &amp;lpOverlapped, <br>                                   INFINITE); <br> <br>        if ( di ) <br>        { <br> <br>            fni = (PFILE_NOTIFY_INFORMATION)di-&gt;lpBuffer; <br> <br>            do <br>            { <br>                cbOffset = fni-&gt;NextEntryOffset; <br> <br>                if( fni-&gt;Action == FILE_ACTION_MODIFIED ) <br>                    CheckChangedFile( di, fni ); <br> <br>                fni = (PFILE_NOTIFY_INFORMATION)((LPBYTE) fni + cbOffset); <br> <br>            } while( cbOffset ); <br> <br>            // Reissue the watch command <br>            ReadDirectoryChangesW( di-&gt;hDir,di-&gt;lpBuffer, <br>                                   MAX_BUFFER, <br>                                   TRUE, <br>                                   FILE_NOTIFY_CHANGE_LAST_WRITE, <br>                                   &amp;di-&gt;dwBufLength, <br>                                   &amp;di-&gt;Overlapped, <br>                                   NULL); <br>        } <br> <br>    } while( di ); <br> <br> <br>} <br> <br> <br>/********************************************************************** <br>   WatchDirectories() <br> <br>   Purpose: <br>      This function implements the ReadDirectoryChangesW API for <br>      indicated directories. For each directory watched, a thread <br>      is created which waits for changes to the directory. This <br>      function waits for the user to input 'q', then cleans up and <br>      quits. <br> <br>   Parameters: <br> <br>      HANDLE hCompPort - Handle for completion port <br> <br> <br>   Return Value: <br>      None <br> <br>********************************************************************/ <br>void WINAPI WatchDirectories( HANDLE hCompPort ) <br>{ <br>    DWORD   i; <br>    DWORD   tid; <br>    HANDLE  hThread; <br> <br> <br>    // Start watching each of the directories of interest <br> <br>    for (i=0;i&lt;numDirs;i++) <br>    { <br>        ReadDirectoryChangesW( DirInfo[i].hDir, <br>                               DirInfo[i].lpBuffer, <br>                               MAX_BUFFER, <br>                               TRUE, <br>                               FILE_NOTIFY_CHANGE_LAST_WRITE, <br>                               &amp;DirInfo[i].dwBufLength,&amp;DirInfo[i].Overlapped, <br>                               NULL); <br>    } <br> <br>    // Create a thread to sit on the directory changes <br> <br>    hThread = CreateThread( NULL, <br>                            0, <br>                            (LPTHREAD_START_ROUTINE) HandleDirectoryChange, <br>                            hCompPort, <br>                            0, <br>                            &amp;tid); <br> <br>    // Just loop and wait for the user to quit <br> <br>    while (getch() != 'q'); <br> <br>    // The user has quit - clean up <br> <br>    PostQueuedCompletionStatus( hCompPort, 0, 0, NULL ); <br> <br>    // Wait for the Directory thread to finish before exiting <br> <br>    WaitForSingleObject( hThread, INFINITE ); <br> <br>    CloseHandle( hThread ); <br>} <br> <br> <br>/********************************************************************** <br>   main() <br> <br>   Purpose: <br>      Main entry-point for fwatch sample. This function reads an .ini <br>      file (fwatch.ini) to determine which directories and files to <br>          watch. For each directory watched some information is gathered <br>      and stored. <br> <br>   Return Value:  (see errors.h for description) <br>      None <br> <br>   Comments: <br> <br>********************************************************************/ <br>void main(int argc, char *argv[]) <br>{ <br> <br>    TCHAR   *p,*q;                          // Temporary String Pointer <br>    HANDLE  hCompPort=NULL;                 // Handle To a Completion Port <br>    DWORD   i;                              // You always need an I. <br>    TCHAR   DirList[MAX_DIRS*MAX_PATH];     // Buffer for all of the directories <br>    TCHAR   IniFile[MAX_PATH]; <br>    TCHAR   FilePath[MAX_PATH]; <br>    HANDLE  hFile; <br> <br>    GetCurrentDirectory( MAX_PATH, IniFile ); <br> <br>    lstrcat( IniFile, L"\\fwatch.ini" ); <br> <br>    GetPrivateProfileString( L"Directories", <br>                             NULL, <br>                             NULL, <br>                             DirList, <br>                             MAX_DIRS*MAX_PATH, <br>                             IniFile ); <br> <br>    GetPrivateProfileString( L"Files", <br>                             NULL, <br>                             NULL, <br>                             FileList, <br>                             MAX_FILES*MAX_PATH, <br>                             IniFile ); <br> <br>    wprintf( L"Watching these directories:\n" ); <br> <br>    // First, walk through the raw list and count items, creating <br>    // an array of handles for each directory <br>    for (p=DirList;*p!='\0';numDirs++,p+=(lstrlen(p)+1)) <br>    { <br> <br> <br>        if( CreateDirectory( p, NULL ) ) <br>            wprintf( L"Directory %s created\n", p ); <br>        else <br>            wprintf( L"Directory %s exists\n", p ); <br> <br>        // Get a handle to the directory <br>        DirInfo[numDirs].hDir = CreateFile( p, <br>                                            FILE_LIST_DIRECTORY, <br>                                            FILE_SHARE_READ | <br>                                            FILE_SHARE_WRITE | <br>                                            FILE_SHARE_DELETE, <br>                                            NULL, <br>                                            OPEN_EXISTING, <br>                                            FILE_FLAG_BACKUP_SEMANTICS | <br>                                            FILE_FLAG_OVERLAPPED, <br>                                            NULL); <br> <br>        if( DirInfo[numDirs].hDir == INVALID_HANDLE_VALUE ) <br>        { <br>            wprintf( L"Unable to open directory %s. GLE=%d. Terminating...\n", <br>                     p, GetLastError() ); <br>            exit( 0 ); <br>        } <br> <br>        for (q=FileList;*q!='\0';q+=(lstrlen(q)+1)) <br>        { <br>            lstrcpy( FilePath, p ); <br>            lstrcat( FilePath, L"\\" ); <br>            lstrcat( FilePath, q ); <br> <br>            if( hFile = CreateFile( FilePath, <br>                                    GENERIC_WRITE, <br>                                    FILE_SHARE_READ | <br>                                    FILE_SHARE_WRITE | <br>                                    FILE_SHARE_DELETE, <br>                                    NULL, <br>                                    CREATE_ALWAYS, <br>                                    FILE_ATTRIBUTE_NORMAL, <br>                                    NULL) ) <br>            { <br>                wprintf( L"  File %s created\n", FilePath ); <br>                CloseHandle( hFile ); <br>            } <br>            else <br>                wprintf( L"  File %s could not be created\n", FilePath ); <br> <br>        } <br> <br>        lstrcpy( DirInfo[numDirs].lpszDirName, p ); <br> <br>        // Set up a key(directory info) for each directory <br>        hCompPort=CreateIoCompletionPort( DirInfo[numDirs].hDir, <br>                                          hCompPort, <br>                                          (DWORD) &amp;DirInfo[numDirs], <br>                                          0); <br> <br>    } <br> <br>    wprintf( L"\n\nPress &lt;q&gt; to exit\n" ); <br> <br>    // Start watching <br>    WatchDirectories( hCompPort ); <br> <br>    for(i=0;i&lt;numDirs;i++) <br>        CloseHandle( DirInfo[i].hDir ); <br> <br>    CloseHandle( hCompPort ); <br> <br>} <br> <br> <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
