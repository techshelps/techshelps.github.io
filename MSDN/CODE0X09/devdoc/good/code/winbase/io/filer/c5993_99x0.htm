<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DRVPROC.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5994"></a>DRVPROC.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples. <br>*       Copyright 1993 - 1998 Microsoft Corporation. <br>*       All rights reserved. <br>*       This source code is only intended as a supplement to <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>/******************************Module*Header*******************************\ <br>* Module Name:  drvproc.c <br>* <br>* Filer : SDK sample <br>*   +   Simple File Management program with GUI front end. <br>*       Demonstrates Win32 File I/O API and various User algorithms. <br>* <br>* DRVPROC.C : Contains procedures relating to child window management. <br>*               In this sample, the Drive children handle the directory <br>*               and file enumeration, as well as the file I/O operations. <br>* <br>\**************************************************************************/ <br> <br>#define  STRICT <br>#include &lt;windows.h&gt; <br>#include &lt;string.h&gt; <br>#define _MBCS <br>#include &lt;mbstring.h&gt; <br>#include "globals.h" <br>#include "filer.h" <br>#include "expdir.h" <br>#include "drvproc.h" <br> <br>extern HANDLE   ghModule; <br>extern HANDLE   ghHeap; <br>extern HFONT    ghFont; <br>extern HANDLE   ghDrvThread; <br>extern HANDLE   ghMenu; <br> <br>extern HWND     ghwndCommand; <br>extern HWND     ghwndDrives; <br>extern HWND     ghActiveChild; <br>extern HWND     ghwndDrv1; <br>extern HWND     ghwndDrv2; <br>extern HWND     ghFocusWnd; <br> <br>extern LPDINFO  glpDrives; <br> <br>extern CRITICAL_SECTION    gHeapCS;  // Global heap critical section var. <br>extern CRITICAL_SECTION    gDrvCS;   // Drive list critical section var. <br> <br>extern TCHAR    gszEditor[DIRECTORY_STRING_SIZE]; <br>extern TCHAR    gszCommandLine[DIRECTORY_STRING_SIZE * 2]; <br> <br>extern TCHAR    gszExtensions[NUM_EXTENSION_STRINGS][EXTENSION_LENGTH]; <br> <br>extern VKINFO   gVKArray[NUM_VERSION_INFO_KEYS];  // .EXE version info array. <br> <br> <br>/***************************************************************************\ <br>* DrvWndProc() <br>* <br>* History: <br>* 05-1-92  Created <br>\***************************************************************************/ <br> <br>LRESULT  WINAPI DrvWndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam) <br>{ <br>    TCHAR lpBuffer[128]; <br>DWORD dwDirStyle = WS_BORDER | WS_CHILD | WS_VISIBLE | <br>                              LBS_NOINTEGRALHEIGHT | LBS_NOTIFY | <br>                              LBS_HASSTRINGS | LBS_WANTKEYBOARDINPUT | <br>                              LBS_DISABLENOSCROLL | WS_HSCROLL | <br>                              WS_VSCROLL |LBS_USETABSTOPS; <br> <br>    DWORD dwFileStyle = WS_BORDER | WS_CHILD | WS_VISIBLE | <br>                               LBS_NOINTEGRALHEIGHT | LBS_NOTIFY | <br>                               LBS_HASSTRINGS | LBS_WANTKEYBOARDINPUT | <br>                               LBS_DISABLENOSCROLL | WS_HSCROLL | <br>                               LBS_EXTENDEDSEL | LBS_MULTIPLESEL | <br>                               LBS_MULTICOLUMN | LBS_SORT; <br> <br>    switch (message){ <br> <br>        // <br>        // Creates the text and listbox windows for this Drv child and <br>        //  saves its handle in the per Drv child DRVCHILDINFO data structure. <br>        // <br>        case WM_CREATE: { <br>            LPCINFO lpCInfo; <br> <br>            DWORD   dwLoop; <br> <br>            LPDINFO lpWalk; <br> <br>            LONG    lTabs = LISTBOX_TAB_SIZE; <br> <br> <br>            // <br>            // Initialize DRVCHILDINFO structure <br>            // <br>            lpCInfo = (LPCINFO) ((LPCREATESTRUCT) lParam)-&gt;lpCreateParams; <br> <br>            lpCInfo-&gt;hwnd = hwnd; <br> <br>            // Create text window <br>            lpCInfo-&gt;hTextWnd = CreateWindow(TEXT("TextClass"), NULL, <br>                                    SS_LEFT | WS_CHILD | WS_VISIBLE | WS_BORDER, <br>                                    0, 0, 0, 0, <br>                                    lpCInfo-&gt;hwnd, <br>                                    (HMENU) TEXT_WINDOW_ID, <br>                                    ghModule, <br>                                    NULL); <br> <br>            // Create Directory and File List boxes <br>            lpCInfo-&gt;hDirLB = CreateWindow(TEXT("LISTBOX"), NULL, <br>                                    dwDirStyle, <br>                                    0, 0, 0, 0, <br>                                    lpCInfo-&gt;hwnd, <br>                                    (HMENU) LISTDIR_ID, <br>                                    ghModule, <br>                                    NULL); <br> <br>            lpCInfo-&gt;hFileLB = CreateWindow(TEXT("LISTBOX"), NULL, <br>                                    dwFileStyle, <br>                                    0, 0, 0, 0, <br>                                    lpCInfo-&gt;hwnd, <br>                                    (HMENU) LISTFILE_ID, <br>                                    ghModule, <br>                                    NULL); <br> <br>            // <br>            // fDirLeft indicates whether the Directory ListBox defaults to <br>            //  the left side of each of the two drive windows. <br>            // fDirExpand indicates whether the Directory Listbox defaults <br>            //  to full expansion. <br>            // <br>            lpCInfo-&gt;fDirLeft = TRUE; <br>            lpCInfo-&gt;fDirExpand = FALSE; <br>            lpCInfo-&gt;fSuicide = FALSE; <br> <br>            // <br>            // Create Mutex associated with each list box <br>            // <br>            lpCInfo-&gt;hDirMutex = CreateMutex(NULL, FALSE, NULL); <br>            lpCInfo-&gt;hFileMutex = CreateMutex(NULL, FALSE, NULL); <br> <br>            // <br>            // Associate window with the current directory LPDINFO structure <br>            //   from the Drives linked list <br>            // <br>            dwLoop = GetCurrentDirectory( DIRECTORY_STRING_SIZE, <br>                                          lpCInfo-&gt;CaptionBarText ); <br>            CharUpper(lpCInfo-&gt;CaptionBarText); <br> <br>            WaitForSingleObject(ghDrvThread, INFINITE); <br>            EnterCriticalSection(&amp;gDrvCS); <br> <br>            lpWalk = glpDrives; <br> <br>            if( dwLoop &amp;&amp; dwLoop &lt;= DIRECTORY_STRING_SIZE ){ <br>                while( lpWalk &amp;&amp; lpWalk-&gt;DriveName[0] != <br>                       (lpCInfo-&gt;CaptionBarText)[0] ) <br>                    lpWalk = lpWalk-&gt;next; <br>                if( !lpWalk ){ <br>LoadString(ghModule, IDS_DCCDRVLST, lpBuffer, sizeof(lpBuffer));  <br>                    ErrorMsg(lpBuffer); <br>                    LeaveCriticalSection(&amp;gDrvCS); <br>                    return(-1); <br>                } <br>            } <br>            else{ <br>LoadString(ghModule, IDS_DCCCURDIR, lpBuffer, sizeof(lpBuffer));  <br>                ErrorMsg(lpBuffer); <br>                LeaveCriticalSection(&amp;gDrvCS); <br>                return(-1); <br>            } <br> <br>            LeaveCriticalSection(&amp;gDrvCS); <br> <br>            lpCInfo-&gt;lpDriveInfo = lpWalk; <br> <br>            // <br>            // Save the handle to DRVCHILDINFO in our window structure <br>            // <br>            SetWindowLong(hwnd, GWL_USERDATA, (LONG) lpCInfo); <br> <br>            // <br>            // Initialize child windows <br>            // <br>            if( !SendMessage(lpCInfo-&gt;hDirLB, LB_SETTABSTOPS, (WPARAM)1, <br>                            (LPARAM)&amp;lTabs) ) { <br>LoadString(ghModule, IDS_DCCTABSTP, lpBuffer, sizeof(lpBuffer));  <br>                ErrorMsg(lpBuffer); <br>            } <br> <br>            // <br>            // Set default font. <br>            // <br>            SendMessage(lpCInfo-&gt;hDirLB, WM_SETFONT, (WPARAM)ghFont, (LPARAM)FALSE); <br>            SendMessage(lpCInfo-&gt;hFileLB, WM_SETFONT, (WPARAM)ghFont, (LPARAM)FALSE); <br> <br>            SendMessage(hwnd, WM_COMMAND, (WPARAM)MM_REFRESH, (LPARAM)NULL); <br> <br>            return(1); <br>        } <br> <br>        case WM_COMMAND: { <br>          static LPCINFO     lpCInfo; <br>          static SELECTINFO  Select; <br> <br>          // <br>          // Retrieving this child window's DRVCHILDINFO data for displaying <br>          //    messages in the text window <br>          // <br>          lpCInfo = (LPCINFO) GetWindowLong(hwnd, GWL_USERDATA); <br> <br>          switch (LOWORD(wParam)){ <br> <br>            case MM_TAB:{ <br>                HWND    hFocus; <br> <br>                hFocus = GetFocus(); <br> <br>                if( hFocus == lpCInfo-&gt;hDirLB ) <br>                    ghFocusWnd = lpCInfo-&gt;hFileLB; <br>                else <br>                    if( hFocus == lpCInfo-&gt;hFileLB ) <br>                        ghFocusWnd = ghwndCommand; <br>                    else <br>                        if( hFocus == ghwndCommand) <br>                            ghFocusWnd = lpCInfo-&gt;hDirLB; <br> <br>                SetFocus( ghFocusWnd ); <br>                return(1); <br>            } <br> <br>            // <br>            //  Clears the selection in the active window. <br>            //  Sent when user hits escape key. <br>            // <br>            case MM_ESCAPE:{ <br>                // <br>                // If there is a directory expand in process, kill the <br>                //  thread, and leave the listbox in a semi-expanded state. <br>                //  Else, clear file selection, and switch to command window. <br>                // <br>                if( WaitForSingleObject( lpCInfo-&gt;hDirMutex, MUTEX_TIMEOUT) <br>                        == WAIT_TIMEOUT ){ <br>                    lpCInfo-&gt;fSuicide = TRUE; <br>                    lpCInfo-&gt;fEscape = TRUE; <br>                } <br>                else <br>                    ReleaseMutex( lpCInfo-&gt;hDirMutex ); <br> <br>                SendMessage(lpCInfo-&gt;hFileLB, LB_SETCURSEL, (WPARAM)-1, <br>                               (LPARAM)0); <br> <br>                SetFocus( ghwndCommand ); <br>                ghFocusWnd = ghwndCommand; <br>                SendMessage(ghwndCommand, LB_SETCURSEL, (WPARAM)0, <br>                               (LPARAM)-1); <br>                return(1); <br>            } <br> <br>            case MM_OPEN:{ <br>                if( ghFocusWnd == lpCInfo-&gt;hFileLB ) <br>                    OpenListBoxItem(lpCInfo); <br>                else <br>                    if( ghFocusWnd == lpCInfo-&gt;hDirLB ){ <br>                        if( !PostMessage(hwnd, WM_COMMAND, MM_FILLDIR, <br>                                         (LPARAM)0) ){ <br>            LoadString(ghModule, IDS_MMOPENERR, lpBuffer, sizeof(lpBuffer));  <br>                            ErrorMsg(lpBuffer); <br>                            return(0); <br>                        } <br>                    } <br>                    else <br>                        RunCommandItem(lpCInfo); <br> <br>                return(1); <br>            } <br> <br>            case MM_COPY:{ <br> <br>                Select.hwnd = hwnd; <br>                Select.dwAction = MM_COPY; <br>                LoadString(ghModule, IDS_COPYING, lpBuffer, sizeof(lpBuffer));  <br>                Select.szAction = lpBuffer; <br>                LoadString(ghModule, IDS_COPYINGTO, lpBuffer, sizeof(lpBuffer)); <br>                Select.szToFrom = lpBuffer; <br> <br>                ExecuteFileAction(&amp;Select); <br> <br>                return(1); <br>            } <br> <br>            case MM_DELETE:{ <br> <br>                Select.hwnd = hwnd; <br>                Select.dwAction = MM_DELETE; <br>                LoadString(ghModule, IDS_DELETING, lpBuffer, sizeof(lpBuffer)); <br>                Select.szAction = lpBuffer; <br>                LoadString(ghModule, IDS_DELETINGFRM, lpBuffer, sizeof(lpBuffer)); <br>                Select.szToFrom = lpBuffer; <br> <br>                ExecuteFileAction(&amp;Select); <br> <br>                return(1); <br>            } <br> <br>            case MM_MOVE:{ <br> <br>                Select.hwnd = hwnd; <br>                Select.dwAction = MM_MOVE; <br>                LoadString(ghModule, IDS_MOVING, lpBuffer, sizeof(lpBuffer)); <br>                Select.szAction = lpBuffer; <br>                LoadString(ghModule, IDS_COPYINGTO, lpBuffer, sizeof(lpBuffer)); <br>                Select.szToFrom = lpBuffer; <br> <br>                ExecuteFileAction(&amp;Select); <br> <br>                return(1); <br>            } <br> <br>            case MM_RENAME:{ <br> <br>                if( DialogBoxParam(ghModule, TEXT("RenameDlg"), hwnd, <br>                              (DLGPROC)RenameProc, (LPARAM)lpCInfo) == -1 ){ <br>                    LoadString(ghModule, IDS_RENAMEERR, lpBuffer, sizeof(lpBuffer)); <br>                    ErrorMsg(lpBuffer); <br>                    return(0); <br>                } <br> <br>                return(1); <br>            } <br> <br>            case MM_MKDIR:{ <br> <br>                if( DialogBoxParam(ghModule, TEXT("MkDirDlg"), hwnd, <br>                              (DLGPROC)MkDirProc, (LPARAM)lpCInfo) == -1 ){ <br>                    LoadString(ghModule, IDS_MKDIRERR, lpBuffer, sizeof(lpBuffer)); <br>                    ErrorMsg(lpBuffer); <br>                    return(0); <br>                } <br> <br>                return(1); <br>            } <br> <br>            case MM_VERSION:{ <br> <br>                if( DialogBoxParam(ghModule, TEXT("VersionInfoDlg"), hwnd, <br>                              (DLGPROC)VersionProc, (LPARAM)lpCInfo) == -1 ){ <br>                    LoadString(ghModule, IDS_VERDLGERR, lpBuffer, sizeof(lpBuffer)); <br>                    ErrorMsg(lpBuffer); <br>                    return(0); <br>                } <br> <br>                return(1); <br>            } <br> <br>            case MM_EXPAND:{ <br> <br>                lpCInfo-&gt;fDirExpand = !lpCInfo-&gt;fDirExpand; <br> <br>                if( lpCInfo-&gt;fDirExpand ) <br>                    CheckMenuItem( ghMenu, MM_EXPAND, <br>                                    MF_BYCOMMAND | MF_CHECKED); <br>                else <br>                    CheckMenuItem( ghMenu, MM_EXPAND, <br>                                MF_BYCOMMAND | MF_UNCHECKED); <br> <br>                if( !SendMessage( (HWND)lpCInfo-&gt;hwnd, WM_COMMAND, <br>                                 (WPARAM)MM_REFRESH, (LPARAM)0 ) ){ <br>                    LoadString(ghModule, IDS_MMEXPAND, lpBuffer, sizeof(lpBuffer)); <br>                    ErrorMsg(lpBuffer); <br>                    return(0); <br>                } <br>                return(1); <br>            } <br> <br>            // <br>            // refreshes contents of directory and file ListBoxes. <br>            // <br>            case MM_REFRESH:{ <br> <br>                DWORD   dwThreadID; <br> <br>                if( WaitForSingleObject( lpCInfo-&gt;hDirMutex, MUTEX_TIMEOUT) <br>                        == WAIT_TIMEOUT ) <br>                    // <br>                    // If the full directory expand has been cancled, kill the <br>                    //  existing thread. <br>                    // <br>                    if( !lpCInfo-&gt;fDirExpand &amp;&amp; !lpCInfo-&gt;fSuicide){ <br>                        lpCInfo-&gt;fSuicide = TRUE; <br>                        return(1); <br>                    } <br>                    else{ <br>                        return(0); <br>                    } <br> <br>                // if set, clear the expand dir. user abort (escape key) flag. <br>                if( lpCInfo-&gt;fEscape ){ <br>                    lpCInfo-&gt;fEscape = FALSE; <br>                    ReleaseMutex( lpCInfo-&gt;hDirMutex ); <br>                    return(1); <br>                } <br> <br>                // At this point, the Dir LB mutex has been grabbed. <br> <br>                // Clear directory LB.  If expand flag is set, expand all <br>                //  directories.  Refill File LB. <br>                // <br>                if( SendMessage( lpCInfo-&gt;hDirLB, LB_RESETCONTENT, <br>                                 (WPARAM)0, (LPARAM)0 ) &lt; 0 ){ <br>                    LoadString(ghModule, IDS_REFRESH1, lpBuffer, sizeof(lpBuffer)); <br>                    ErrorMsg(lpBuffer); <br>                    ReleaseMutex( lpCInfo-&gt;hDirMutex ); <br>                    return(0); <br>                } <br> <br>                // <br>                // This call puts the default root entry back into the empty <br>                //  LB.  Set suicide flag to false to ensure it will complete. <br>                // <br>                lpCInfo-&gt;fSuicide = FALSE; <br>                ExpDir( lpCInfo ); <br> <br>                // <br>                // All the Dir LB work is done.  Release Dir LB Mutex. <br>                // <br>                ReleaseMutex( lpCInfo-&gt;hDirMutex ); <br> <br>                if( lpCInfo-&gt;fDirExpand ){ <br> <br>                    CloseHandle( lpCInfo-&gt;hDirThread ); <br> <br>                    lpCInfo-&gt;hDirThread = CreateThread( NULL, 0, <br>                                  (LPTHREAD_START_ROUTINE)FullExpand, <br>                                  (LPVOID)lpCInfo, 0, &amp;dwThreadID); <br> <br>                    if( !lpCInfo-&gt;hDirThread ){ <br>                        LoadString(ghModule, IDS_REFRESH2, lpBuffer, sizeof(lpBuffer)); <br>                        ErrorMsg(lpBuffer); <br>                        return(0); <br>                    } <br>                } <br>                else <br>                    ExpDir( lpCInfo ); <br> <br>                if( !PostMessage(hwnd, WM_COMMAND, MM_FILLFILE, <br>                                 (LPARAM)0) ){ <br>                    LoadString(ghModule, IDS_REFRESH3, lpBuffer, sizeof(lpBuffer)); <br>                    ErrorMsg(lpBuffer); <br>                    return(0); <br>                } <br> <br>                return(1); <br>            } <br> <br>            // <br>            //  Fill listbox in lParam with directory from Drv child's drive. <br>            //  Sent by MM_REFRESH. <br>            // <br>            //  lParam == 0 <br>            // <br>            case MM_FILLDIR:{ <br> <br>                DWORD   dwThreadID; <br> <br>                lpCInfo-&gt;fSuicide = FALSE; <br> <br>                CloseHandle( lpCInfo-&gt;hDirThread ); <br> <br>                lpCInfo-&gt;hDirThread = CreateThread( NULL, 0, <br>                              (LPTHREAD_START_ROUTINE)ExpDir, <br>                              (LPVOID)lpCInfo, 0, &amp;dwThreadID); <br> <br>                if( !(lpCInfo-&gt;hDirThread) ){ <br>                    LoadString(ghModule, IDS_FILDIRERR, lpBuffer, sizeof(lpBuffer)); <br>                    ErrorMsg(lpBuffer); <br>                    return(0); <br>                } <br> <br>                return(1); <br>            } <br> <br>            // <br>            //  Fill listbox in lParam with files from current directory. <br>            //  Sent by MM_REFRESH &amp; LBN_DBLCLK in DrvWndProc, as well as <br>            //  DoFileIO. and HandleIOError(). <br>            // <br>            //  lParam == 0 <br>            // <br>            case MM_FILLFILE:{ <br>                TCHAR               szFiles[DIRECTORY_STRING_SIZE + 20]; <br>                LPTSTR              lpHold; <br> <br>                if( WaitForSingleObject( lpCInfo-&gt;hFileMutex, MUTEX_TIMEOUT) <br>                        == WAIT_TIMEOUT ){ <br>                    LoadString(ghModule, IDS_FILDIRERR2, lpBuffer, sizeof(lpBuffer)); <br>                    ErrorMsg(lpBuffer); <br>                    return(0); <br>                } <br> <br> <br>                // <br>                // Not checking for errors here, as LB_RESETCONTENT always <br>                //  returns true, and LB_DIR returns an error if the directory <br>                //  is empty. <br>                // <br>                SendMessage(lpCInfo-&gt;hFileLB, LB_RESETCONTENT, (WPARAM)NULL, (LPARAM)NULL); <br> <br>                lstrcpy( szFiles, lpCInfo-&gt;CaptionBarText ); <br>                lpHold = TStrChr(szFiles, TEXT('\0')); <br>                lpHold--; <br>                if( *lpHold != TEXT('\\') ){ <br>                    lpHold++; <br>                    *lpHold = TEXT('\\'); <br>                } <br> <br>                lpHold++; <br>                lstrcpy( lpHold, TEXT("*.*")); <br> <br>                if( SendMessage( lpCInfo-&gt;hFileLB, LB_DIR, (WPARAM)0x10, <br>                                 (LPARAM)szFiles ) == LB_ERR ){ <br>                    LoadString(ghModule, IDS_FILDIRERR3, lpBuffer, sizeof(lpBuffer)); <br>                    ErrorMsg(lpBuffer); <br>                    ReleaseMutex( lpCInfo-&gt;hFileMutex ); <br>                    return(0); <br>                } <br> <br>                // <br>                //  Set selection to first file. <br>                // <br>                if( SendMessage( lpCInfo-&gt;hFileLB, LB_SETSEL, (WPARAM)TRUE, <br>                                 (LPARAM)0 ) == LB_ERR ){ <br>                    LoadString(ghModule, IDS_FILDIRERR4, lpBuffer, sizeof(lpBuffer)); <br>                    ErrorMsg(lpBuffer); <br>                    ReleaseMutex( lpCInfo-&gt;hFileMutex ); <br>                    return(0); <br>                } <br> <br>                SetWindowText(lpCInfo-&gt;hTextWnd, lpCInfo-&gt;CaptionBarText); <br> <br>                ReleaseMutex( lpCInfo-&gt;hFileMutex ); <br> <br>                return(1); <br>            } <br> <br>            // <br>            //  Toggle active status of drive child. <br>            // <br>            case MM_TOGGLE:{ <br> <br>                SetWindowText(lpCInfo-&gt;hTextWnd, lpCInfo-&gt;CaptionBarText); <br>                return(1); <br>            } <br> <br>            // <br>            // The following WM_COMMAND messages are sent by the listboxes <br>            // <br>            // HIWORD(wParam) = LB notification message <br>            // lParam = LB window handle <br>            // <br>            case LISTFILE_ID:{ <br>              switch( HIWORD(wParam) ){ <br>                // <br>                // In case of double click on a directory, expand the file <br>                // Listbox. if on a file name, run or edit file. <br>                // <br>                case LBN_DBLCLK:{ <br>                    OpenListBoxItem(lpCInfo); <br>                    return(1); <br>                } <br>                break; <br> <br>                case LBN_SETFOCUS:{ <br>                    ghFocusWnd = lpCInfo-&gt;hFileLB; <br>                } <br>                break; <br> <br>                default: <br>                    return(1); <br>              } <br>            } // LISTFILE_ID <br>            break; <br> <br>            // <br>            // Notification from the Directory ListBox <br>            // <br>            case LISTDIR_ID:{ <br>              switch( HIWORD(wParam) ){ <br> <br>                case LBN_SETFOCUS:{ <br>                    ghFocusWnd = lpCInfo-&gt;hDirLB; <br>                } <br>                break; <br> <br>                // <br>                // Expand subdirectories in dir listbox <br>                // <br>                case LBN_DBLCLK:{ <br> <br>                    if( !PostMessage(hwnd, WM_COMMAND, MM_FILLDIR, <br>                                     (LPARAM)0) ){ <br>                        LoadString(ghModule, IDS_DBLCLKERR, lpBuffer, sizeof(lpBuffer)); <br>                        ErrorMsg(lpBuffer); <br>                        return(0); <br>                    } <br>                    return(1); <br>                } <br>                break; <br> <br>                case LBN_SELCHANGE:{ <br>                    // <br>                    // for the Directory LB, fill the <br>                    // corresp. File LB with items in the newly selected dir. <br>                    // <br>                    LONG lIndex; <br> <br> <br>                    if( WaitForSingleObject( lpCInfo-&gt;hDirMutex, MUTEX_TIMEOUT) <br>                            == WAIT_TIMEOUT ){ <br>                        LoadString(ghModule, IDS_SELCNGERR, lpBuffer, sizeof(lpBuffer)); <br>                        ErrorMsg(lpBuffer); <br>                        return(0); <br>                    } <br> <br>                    // <br>                    // Retrieve selected (careted) item. <br>                    // <br>                    lIndex = SendMessage( (HWND)lParam, LB_GETCARETINDEX, <br>                                        (WPARAM)NULL, (LPARAM)NULL ); <br> <br>                    if( !ConstructDirName(lpCInfo, lIndex, <br>                                          lpCInfo-&gt;CaptionBarText) ){ <br>                        LoadString(ghModule, IDS_CONDIRERR, lpBuffer, sizeof(lpBuffer)); <br>                        ErrorMsg(lpBuffer); <br>                        ReleaseMutex( lpCInfo-&gt;hDirMutex ); <br>                        return(0); <br>                    } <br> <br>                    ReleaseMutex( lpCInfo-&gt;hDirMutex ); <br> <br>                    if( !PostMessage(hwnd, WM_COMMAND, MM_FILLFILE, <br>                                     (LPARAM)0) ){ <br>                        LoadString(ghModule, IDS_LBNOTFYERR, lpBuffer, sizeof(lpBuffer)); <br>                        ErrorMsg(lpBuffer); <br>                        return(0); <br>                    } <br>                } // LBN_SELCHANGE <br>                break; <br> <br>                default: <br>                    return(1); <br>              } <br>            } //  LISTDIR_ID <br>            break; <br> <br>            default: <br>               return(1); <br>          } <br>        } <br>        break; <br> <br>        // <br>        // Whenever the Drv child window is resized, its children has to be <br>        //  resized accordingly.  The GetWindowLong GWL_USERDATA values <br>        //  contain the height of the windows queried, set in their respective <br>        //  WM_CREATE cases. <br>        // <br>        case WM_SIZE: { <br>            LPCINFO     lpCInfo; <br> <br>            int         nListHeight, <br>                        nListWidth; <br> <br>            HWND        hLeftLB, <br>                        hRightLB; <br> <br>            // <br>            // First, get the text window's handle from the per Drv child <br>            //  DRVCHILDINFO data structure <br>            // <br>            lpCInfo = (LPCINFO)GetWindowLong(hwnd, GWL_USERDATA); <br> <br>            nListHeight = HIWORD(lParam) - <br>                          GetWindowLong(lpCInfo-&gt;hTextWnd, GWL_USERDATA) <br>                          - LIST_BORDER * 2; <br> <br>            nListWidth = (LOWORD(lParam) - LIST_BORDER) / 2 - LIST_BORDER; <br> <br>            // <br>            // Always, put the text window at the top of the Drv window. <br>            // Increasing sides and bottom extents by 1 to overlap border <br>            //   with Drv child border <br>            // <br>            MoveWindow(lpCInfo-&gt;hTextWnd, <br>                       -1, <br>                       0, <br>                       LOWORD(lParam) + 2, <br>                       GetWindowLong(lpCInfo-&gt;hTextWnd, GWL_USERDATA) + 1, <br>                       TRUE); <br> <br>            if( lpCInfo-&gt;fDirLeft ){ <br>                hLeftLB = lpCInfo-&gt;hDirLB; <br>                hRightLB = lpCInfo-&gt;hFileLB; <br>            } <br>            else{ <br>                hLeftLB = lpCInfo-&gt;hFileLB; <br>                hRightLB = lpCInfo-&gt;hDirLB; <br>            } <br> <br>            MoveWindow(hLeftLB, <br>                       LIST_BORDER, <br>                       GetWindowLong(lpCInfo-&gt;hTextWnd, GWL_USERDATA) + 1 <br>                         + LIST_BORDER, <br>                       nListWidth, <br>                       nListHeight, <br>                       TRUE); <br> <br>            MoveWindow(hRightLB, <br>                       (LOWORD(lParam) + LIST_BORDER) / 2, <br>                       GetWindowLong(lpCInfo-&gt;hTextWnd, GWL_USERDATA) + 1 <br>                         + LIST_BORDER, <br>                       nListWidth, <br>                       nListHeight, <br>                       TRUE); <br> <br>        break; <br>        } <br> <br>        case WM_PARENTNOTIFY:{ <br>            LPCINFO lpCInfo; <br> <br>            if(wParam == WM_LBUTTONDOWN){ <br>                lpCInfo = (LPCINFO) GetWindowLong(hwnd, GWL_USERDATA); <br>                if(lpCInfo == NULL){ <br>                    LoadString(ghModule, IDS_PARNTFYERR, lpBuffer, sizeof(lpBuffer)); <br>                    ErrorMsg(lpBuffer); <br>                    return(1); <br>                } <br>                if(HIWORD(wParam) == LISTDIR_ID) <br>                    SetFocus(lpCInfo-&gt;hDirLB); <br>                else <br>                    if(HIWORD(wParam) == LISTFILE_ID) <br>                        SetFocus(lpCInfo-&gt;hFileLB); <br>                    else <br>                        if(HIWORD(wParam) == TEXT_WINDOW_ID) <br>                            SetFocus(lpCInfo-&gt;hTextWnd); <br>            } <br> <br>            break; <br>        } <br> <br>        // <br>        // Same as MainWndProc's MM_ACTIVEDRV case.  The initial PostMessage <br>        //   is so the currently active Drv child will not process the message <br>        //   until it is no longer in focus. <br>        // <br>        case WM_MOUSEACTIVATE:{ <br>            LPCINFO lpCInfo; <br> <br>            PostMessage(ghActiveChild, WM_COMMAND, (WPARAM)MM_TOGGLE, <br>                        (LPARAM)NULL); <br>            ghActiveChild = hwnd; <br>            SendMessage(ghActiveChild, WM_COMMAND, (WPARAM)MM_TOGGLE, <br>                        (LPARAM)NULL); <br> <br>            lpCInfo = (LPCINFO) GetWindowLong(hwnd, GWL_USERDATA); <br>            SendMessage(ghwndDrives, WM_COMMAND, MM_ACTIVEDRV, <br>                        (LPARAM)lpCInfo-&gt;lpDriveInfo); <br> <br>            break; <br>        } <br> <br>        // <br>        // Free the DRVCHILDINFO data that associates with this window <br>        //  also, reset the menu. <br>        // <br>        case WM_CLOSE: { <br>            LPCINFO lpCInfo; <br> <br>            lpCInfo = (LPCINFO)GetWindowLong(hwnd, GWL_USERDATA); <br> <br>            CloseHandle(lpCInfo-&gt;hDirMutex ); <br>            CloseHandle(lpCInfo-&gt;hFileMutex ); <br> <br>            EnterCriticalSection(&amp;gHeapCS); <br>            HeapFree(ghHeap, 0, (LPVOID)lpCInfo); <br>            LeaveCriticalSection(&amp;gHeapCS); <br> <br>            break; <br>        } <br> <br>        default: <br>            return DefWindowProc(hwnd, message, wParam, lParam); <br> <br>    } //switch <br>    return DefWindowProc(hwnd, message, wParam, lParam); <br>} <br> <br> <br>/***************************************************************************\ <br>* <br>* GetLBText() <br>* <br>* Gets the text of the currently selected (careted) item in the given <br>*   listbox. <br>* <br>* Returns:  Index of selected item if successful, -1 on failure <br>* <br>* History: <br>* 4/26/93 <br>*   Created. <br>* <br>\***************************************************************************/ <br>LONG GetLBText(HWND hActiveLB, PTCHAR szItemBuff) <br>{ <br>    LONG    lIndex; <br>    TCHAR   lpBuffer[128]; <br> <br>    // <br>    // Retrieve selected (careted) item. <br>    // <br>    lIndex = SendMessage( hActiveLB, LB_GETCARETINDEX, <br>                          (WPARAM)NULL, (LPARAM)NULL ); <br> <br>    if( SendMessage( hActiveLB, LB_GETTEXT, (WPARAM)lIndex, <br>                     (LPARAM)szItemBuff) == LB_ERR ){ <br>        LoadString(ghModule, IDS_GETLBTXTERR, lpBuffer, sizeof(lpBuffer)); <br>        ErrorMsg(lpBuffer); </code></pre>
<p>
</p>
<pre><code>return(-1); <br>    } <br> <br>    return( lIndex ); <br>} <br> <br> <br>/***************************************************************************\ <br>* <br>* UpdateFileLB() <br>* <br>* Updates the file listbox of the drive child given by sending an MM_FILLFILE <br>*   message to it. <br>* <br>*  input:   hwnd    -   Handle of drive child to update file listbox of. <br>* <br>* History: <br>* 6/3/92 <br>*   Created. <br>* <br>\***************************************************************************/ <br>void UpdateFileLB(HWND hwnd) <br>{ <br>    LPCINFO lpCInfo; <br> <br>    lpCInfo = (LPCINFO)GetWindowLong(hwnd, GWL_USERDATA); <br> <br>    SendMessage(hwnd, WM_COMMAND, (WPARAM)MM_FILLFILE, <br>                (LPARAM)0); <br>} <br> <br> <br>/***************************************************************************\ <br>* <br>* OpenListBoxItem() <br>* <br>* Attempts to expand a selected File list box directory entry into an available <br>*  file listbox, or spawn a selected list box file. <br>* <br>*  input:   lpCInfo   -   pointer to Drv child's LPCINFO structure <br>* <br>* History: <br>* 5/27/92 <br>*   Created. <br>* <br>\***************************************************************************/ <br>BOOL OpenListBoxItem(LPCINFO lpCInfo) <br>{ <br>    TCHAR   szItemBuff[DIRECTORY_STRING_SIZE]; <br>    TCHAR   lpBuffer[128]; <br> <br>    // <br>    // Retrieve selected (careted) item. <br>    // <br>    GetLBText(lpCInfo-&gt;hFileLB, szItemBuff); <br> <br>    // <br>    // Determine whether the item is a directory or a file. <br>    //   If file, Run if possible. <br>    // <br>    if( !IsDirectory(lpCInfo-&gt;CaptionBarText, szItemBuff) ){ <br>        RunListBoxItem(lpCInfo); <br>        return(1); <br>        } <br> <br>    // <br>    // It is a directory.  Set the new caption text, and expand files. <br>    // <br>    lstrcpy( lpCInfo-&gt;CaptionBarText, szItemBuff); <br> <br>    if( !PostMessage(lpCInfo-&gt;hwnd, WM_COMMAND, MM_FILLFILE, <br>                        (LPARAM)0) ){ <br>        LoadString(ghModule, IDS_OPENLBERR, lpBuffer, sizeof(lpBuffer)); <br>        ErrorMsg(lpBuffer); <br>        return(0); <br>    } <br> <br>    return(1); <br>} <br> <br>/***************************************************************************\ <br>* <br>* RunListBoxItem() <br>* <br>* Attempts to spawn the selected list box file. If the file is not executable, <br>*   attempts to spawn an editor to edit the file. <br>* <br>*  input:   lpCInfo   -   pointer to Drv child's LPCINFO structure <br>* <br>* History: <br>* 5/27/92 <br>*   Created. <br>* <br>* 5/12/93 <br>*   Modified. <br>* <br>\***************************************************************************/ <br>BOOL RunListBoxItem(LPCINFO lpCInfo) <br>{ <br>    LONG        lIndex; <br>    TCHAR       szFileBuff[DIRECTORY_STRING_SIZE]; <br>    TCHAR       szCmdLine[DIRECTORY_STRING_SIZE * 2]; <br>    LPTSTR      szHold; <br>    TCHAR       lpBuffer[128]; <br> <br>    STARTUPINFO si; <br>    PROCESS_INFORMATION pi; <br> <br> <br>    lstrcpy(szCmdLine, lpCInfo-&gt;CaptionBarText); <br> <br>    lstrcat(szCmdLine, TEXT("\\")); <br> <br>    // <br>    // Get file that was opened, and attempt to spawn. If fails, attempt to <br>    // edit it. <br>    // <br> <br>    // <br>    // Retrieve selected (careted) item. <br>    // <br>    lIndex = GetLBText(lpCInfo-&gt;hFileLB, szFileBuff); <br>    if( lIndex == LB_ERR) <br>        return(0); <br> <br>    // <br>    // Don't assume the file has an extension. if no '.', insert one at end <br>    //  of file, so spawned editor will not assume any default extension. <br>    //  (i.e. Notepad assumes a .TXT if no extension is given.) <br>    // <br>    szHold = TStrChr(szFileBuff, TEXT('.')); <br>    if( !szHold ){ <br>        szHold = TStrChr(szFileBuff, TEXT('\0')); <br>        *szHold = TEXT('.'); <br>        *(szHold + sizeof(TCHAR)) = TEXT('\0'); <br>    } <br> <br>    si.cb = sizeof(STARTUPINFO); <br>    si.lpReserved = NULL; <br>    si.lpDesktop = NULL; <br>    si.lpTitle = NULL; <br>    si.dwFlags = 0; <br>    si.cbReserved2 = 0; <br>    si.lpReserved2 = NULL; <br> <br>    // <br>    // Convert file to uppercase for extension comparison.  Raise the <br>    //   priority of this thread for the duration of the create process code. <br>    //   This is so the CreateProcess will not be held up by the directory <br>    //   fill threads. <br>    //   If an executable extension, spawn, else edit. <br>    // <br>    CharUpper(szFileBuff); <br> <br>    SetThreadPriority( GetCurrentThread(), THREAD_PRIORITY_HIGHEST); <br> <br>    for(lIndex = 0; lIndex &lt; NUM_EXTENSION_STRINGS; lIndex++) <br>        if( !lstrcmp(szHold, &amp;gszExtensions[lIndex][0]) ){ <br> <br>            lstrcat(szCmdLine, szFileBuff); <br> <br>            if( !CreateProcess(NULL, (LPTSTR)szCmdLine, NULL, NULL, FALSE, <br>                               CREATE_NEW_CONSOLE | NORMAL_PRIORITY_CLASS, <br>                               NULL, lpCInfo-&gt;CaptionBarText, &amp;si, &amp;pi) ){ <br>                LoadString(ghModule, IDS_CANTSPAWN, lpBuffer, sizeof(lpBuffer)); <br>                ErrorMsg(lpBuffer); <br>                return(0); <br>            } <br> <br>            CloseHandle( pi.hProcess ); <br>            CloseHandle( pi.hThread ); <br> <br>            return(1); <br>        } <br> <br>    LoadString(ghModule, STR_DEF_EDITOR, szCmdLine, <br>               DIRECTORY_STRING_SIZE * 2); <br>    lstrcat(szCmdLine, TEXT(" ")); <br>    lstrcat(szCmdLine, szFileBuff); <br> <br>    if( !CreateProcess(NULL, szCmdLine, NULL, NULL, FALSE, <br>                       CREATE_NEW_CONSOLE | NORMAL_PRIORITY_CLASS, <br>                       NULL, lpCInfo-&gt;CaptionBarText, &amp;si, &amp;pi) ){ <br>        LoadString(ghModule, IDS_CANTEDIT, lpBuffer, sizeof(lpBuffer)); <br>        ErrorMsg(lpBuffer); <br>        return(0); <br>    } <br> <br>    CloseHandle( pi.hProcess ); <br>    CloseHandle( pi.hThread ); <br> <br>    SetThreadPriority( GetCurrentThread(), THREAD_PRIORITY_NORMAL); <br> <br>    return(1); <br>} <br> <br> <br>/***************************************************************************\ <br>* <br>* FilerGetVersion() <br>* <br>*  Given an item from a File ListBox, GetVersion retrieves the version <br>*    information from the specified file. <br>* <br>*  input:   lpszFileName   -   the name of the file. <br>*           dwBuffSize     -   &gt; 0 size of buffer to hold version info <br>*           szBuff         -   buffer to hold version info <br>* <br>*  returns: TRUE if successful, FALSE otherwise. <br>* <br>*  comments:  gVKArray would need a critical section if this function were <br>*             to be called by more than one thread. <br>* <br>* History: <br>* 2/23/93 <br>*   Created. <br>* <br>\***************************************************************************/ <br>BOOL FilerGetVersion(LPTSTR lpszFileName, DWORD dwBuffSize, LPTSTR szBuff) <br>{ <br>    // <br>    // NUM_VERSION_INFO_KEYS in GLOBALS.H should be set to the number of entries in <br>    //   VersionKeys[]. <br>    // <br>    CONST static TCHAR   *VersionKeys[] = { <br>            TEXT("ProductName"), <br>            TEXT("ProductVersion"), <br>            TEXT("OriginalFilename"), <br>            TEXT("FileDescription"), <br>            TEXT("FileVersion"), <br>            TEXT("CompanyName"), <br>            TEXT("LegalCopyright"), <br>            TEXT("LegalTrademarks"), <br>            TEXT("InternalName"), <br>            TEXT("PrivateBuild"), <br>            TEXT("SpecialBuild"), <br>            TEXT("Comments") <br>    }; <br> <br>    static TCHAR szNull[1] = TEXT(""); <br>    LPVOID  lpInfo; <br>    DWORD   cch; <br>    UINT    i; <br>    TCHAR   key[80]; <br>    TCHAR   lpBuffer[10]; <br> <br>    GetFileVersionInfo(lpszFileName, 0, dwBuffSize, (LPVOID)szBuff ); <br>    wsprintf(lpBuffer, "%04X", GetUserDefaultLangID()); <br>strcat(lpBuffer,TEXT("04B0")); <br>    for (i = 0; i &lt; NUM_VERSION_INFO_KEYS; i++) { <br>        lstrcpy(key, VERSION_INFO_KEY_ROOT); <br>        lstrcat(key, lpBuffer); <br>        lstrcat(key, "\\"); <br>        lstrcat(key, VersionKeys[i]); <br>        gVKArray[i].szKey = VersionKeys[i]; <br> <br>        // <br>        // If version info exists, and the key query is successful, add <br>        //  the value.  Otherwise, the value for the key is NULL. <br>        // <br>        if( dwBuffSize &amp;&amp; VerQueryValue(szBuff, key, &amp;lpInfo, &amp;cch) ) <br>            gVKArray[i].szValue = lpInfo; <br>        else <br>            gVKArray[i].szValue = szNull; <br>    } <br> <br>    return TRUE; <br>} <br> <br> <br>/***************************************************************************\ <br>* VersionProc() <br>* <br>* .EXE Version Info Dialog Box <br>* <br>* History: <br>* 2/24/93  2am <br>*   Created. <br>\***************************************************************************/ <br>LRESULT WINAPI VersionProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam) <br>{ <br>    static LPTSTR   lpszBuff; <br>    TCHAR   lpBuffer[128]; <br> <br>    switch (message){ <br>      case WM_INITDIALOG:{ <br> <br>        LPCINFO lpCInfo; <br>        DWORD   dwLength; <br>        DWORD   dwCount; <br>        DWORD   dwHandle; <br>        TCHAR   szFile[DIRECTORY_STRING_SIZE]; <br>        TCHAR   szDir[DIRECTORY_STRING_SIZE]; <br>        TCHAR   szFullName[DIRECTORY_STRING_SIZE]; <br>        LPTSTR  lpszHold; <br>        TCHAR   lpBuffer[128]; <br> <br> <br>        lpCInfo = (LPCINFO)lParam; <br>        LoadString(ghModule, IDS_FILE, lpBuffer, sizeof(lpBuffer)); <br>        strcpy(szFile, lpBuffer); <br>        LoadString(ghModule, IDS_DIR, lpBuffer, sizeof(lpBuffer)); <br>        strcpy(szDir, lpBuffer); <br> <br>        // <br>        // Concatenate path to szDir text-control string. <br>        // <br>        lstrcat(szDir, lpCInfo-&gt;CaptionBarText); <br>        SendDlgItemMessage( hDlg, SB_DEST, WM_SETTEXT, <br>                            (WPARAM)0, (LPARAM)szDir); <br> <br>        // <br>        // Concatenate File name to szFile text-control string. <br>        // <br>        dwLength = lstrlen(szFile); <br> <br>        // <br>        // Get selected (careted) ListBox item <br>        // <br>        GetLBText(lpCInfo-&gt;hFileLB, (PTCHAR)&amp;szFile[dwLength]); <br> <br>        SendDlgItemMessage( hDlg, SB_SOURCE, WM_SETTEXT, <br>                            (WPARAM)0, (LPARAM)szFile); <br> <br>        // <br>        // Fill Version Key and Value edit boxes. <br>        // <br>        lstrcpy( szFullName, lpCInfo-&gt;CaptionBarText ); <br> <br>        // <br>        // a file under some file systems may have [] characters. <br>        //   Prepend path, adding a delimiting backslash unless we're in the root. <br>        //   If the attribute check is successful, it's a file, so leave. <br>        // <br>        lpszHold = TStrChr(szFullName, TEXT('\0')); <br> <br>        lpszHold--; <br>        if( *lpszHold != TEXT('\\') ){ <br>            lpszHold++; <br>            *lpszHold = TEXT('\\'); <br>        } <br>        lpszHold++; <br> <br>        lstrcpy(lpszHold, &amp;szFile[dwLength]); // File name past 'File:' prefix <br> <br>        dwLength = GetFileVersionInfoSize( szFullName, &amp;dwHandle); <br>        if( !dwLength ){ <br>            LoadString(ghModule, IDS_GETVERERR, lpBuffer, sizeof(lpBuffer)); <br>            ErrorMsg(lpBuffer); <br>            return(1); <br>        } <br> <br>        // Allocate Version Info buffer <br>        EnterCriticalSection(&amp;gHeapCS); <br>        lpszBuff = (LPTSTR)HeapAlloc( ghHeap, HEAP_ZERO_MEMORY, dwLength * sizeof(TCHAR) ); <br>        LeaveCriticalSection(&amp;gHeapCS); <br> <br>        FilerGetVersion( szFullName, dwLength, lpszBuff ); <br> <br>        for( dwCount = 0; dwCount &lt; NUM_VERSION_INFO_KEYS; dwCount++){ <br>            if( SendDlgItemMessage( hDlg, SB_KEY, LB_ADDSTRING, 0, <br>                                    (LPARAM)gVKArray[dwCount].szKey) <br>                                    == LB_ERR ){ <br>                LoadString(ghModule, IDS_GETVERERR2, lpBuffer, sizeof(lpBuffer)); <br>                ErrorMsg(lpBuffer); <br>                return(0); <br>            } <br>            if( SendDlgItemMessage( hDlg, SB_VALUE, LB_ADDSTRING, 0, <br>                                    (LPARAM)gVKArray[dwCount].szValue) <br>                                    == LB_ERR ){ <br>                LoadString(ghModule, IDS_GETVERERR3, lpBuffer, sizeof(lpBuffer)); <br>                ErrorMsg(lpBuffer); <br>                return(0); <br>            } <br>        } <br> <br>        //  Set selection in listboxes to first item. <br>        if( SendDlgItemMessage( hDlg, SB_KEY, LB_SETCURSEL, <br>                               (WPARAM)0, <br>                               (LPARAM)0 ) <br>                               == LB_ERR ){ <br>            LoadString(ghModule, IDS_GETVERERR4, lpBuffer, sizeof(lpBuffer)); <br>            ErrorMsg(lpBuffer); <br>            return(0); <br>        } <br>        if( SendDlgItemMessage( hDlg, SB_VALUE, LB_SETCURSEL, <br>                               (WPARAM)0, <br>                               (LPARAM)0 ) <br>                               == LB_ERR ){ <br>            LoadString(ghModule, IDS_GETVERERR5, lpBuffer, sizeof(lpBuffer)); <br>            ErrorMsg(lpBuffer); <br>            return(0); <br>        } <br> <br>        //  Initialize Scroll Bar <br>        //  Check to see if a scroll bar is needed. See GLOBALS.H and FILER.DLG <br>        if( NUM_VERSION_INFO_KEYS - VERSION_DLG_LB_HEIGHT &gt; 0 ) <br>            SendDlgItemMessage( hDlg, SB_SCROLL, SBM_SETRANGE, <br>                               (WPARAM)0, <br>                               (LPARAM)NUM_VERSION_INFO_KEYS -1); <br>        SendDlgItemMessage( hDlg, SB_SCROLL, SBM_SETPOS, <br>                           (WPARAM)0, <br>                           (LPARAM)TRUE ); <br> <br>        return(1); <br>      } <br> <br>      case WM_VSCROLL:{ <br>        int nPos; <br> <br>        nPos = SendDlgItemMessage( hDlg, SB_SCROLL, SBM_GETPOS, <br>                                  (WPARAM)0, <br>                                  (LPARAM)0 ); <br> <br>        switch( LOWORD(wParam) ){ <br> <br>            case SB_PAGEDOWN:{ <br>                nPos += VERSION_DLG_LB_HEIGHT; <br>                if( nPos &gt; NUM_VERSION_INFO_KEYS ) <br>                    nPos = NUM_VERSION_INFO_KEYS; <br>                break; <br>            } <br>            case SB_LINEDOWN:{ <br>                nPos++; <br>                if( nPos &gt; NUM_VERSION_INFO_KEYS ) <br>                    nPos = NUM_VERSION_INFO_KEYS; <br>                break; <br>            } <br>            case SB_PAGEUP:{ <br>                nPos -= VERSION_DLG_LB_HEIGHT; <br>                if( nPos &lt; 0 ) <br>                    nPos = 0; <br>                break; <br>            } <br>            case SB_LINEUP:{ <br>                nPos--; <br>                if( nPos &lt; 0 ) <br>                    nPos = 0; <br>                break; <br>            } <br>            default: <br>                return(1); <br>        } <br> <br>        //  Set Scroll Bar position <br>        SendDlgItemMessage( hDlg, SB_SCROLL, SBM_SETPOS, <br>                            (WPARAM)nPos, <br>                            (LPARAM)TRUE ); <br>        //  Set selection in listboxes <br>        if( SendDlgItemMessage( hDlg, SB_KEY, LB_SETCURSEL, <br>                                (WPARAM)nPos, <br>                                (LPARAM)0 ) <br>                                == LB_ERR ){ <br>            LoadString(ghModule, IDS_GETVERERR6, lpBuffer, sizeof(lpBuffer)); <br>            ErrorMsg(lpBuffer); <br>            return(0); <br>        } <br>        if( SendDlgItemMessage( hDlg, SB_VALUE, LB_SETCURSEL, <br>                                (WPARAM)nPos, <br>                                (LPARAM)0 ) <br>                                == LB_ERR ){ <br>            LoadString(ghModule, IDS_GETVERERR6, lpBuffer, sizeof(lpBuffer)); <br>            ErrorMsg(lpBuffer); <br>            return(0); <br>        } <br> <br>        return(0); <br>      } <br> <br>      case WM_CLOSE: <br>          // Free allocated buffer <br>          EnterCriticalSection(&amp;gHeapCS); <br>          HeapFree( ghHeap, 0, lpszBuff); <br>          LeaveCriticalSection(&amp;gHeapCS); <br> <br>          EndDialog(hDlg, wParam); <br>          return(1); <br> <br>      case WM_COMMAND:{ <br>            int nLBid = 0;  // holds ID of listbox other than one sending LBN msg. <br> <br>        switch( LOWORD(wParam) ){ <br>            case SB_OK: <br>            case SB_CANCEL:{ <br>                // Free allocated buffer <br>                EnterCriticalSection(&amp;gHeapCS); <br>                HeapFree( ghHeap, 0, lpszBuff); <br>                LeaveCriticalSection(&amp;gHeapCS); <br> <br>                EndDialog(hDlg, wParam); <br>                return(1); <br>            } <br> <br>            // SB_VALUE and SB_KEY are the ListBox IDs. Below are LB notifications. <br>            case SB_VALUE: <br>                nLBid = SB_KEY; <br>                // we slip through to the SB_KEY case on purpose!! <br>            case SB_KEY:{ <br>                int nSelect;    // Holds selected item <br> <br>                if( HIWORD(wParam) == LBN_SELCHANGE ){ <br> <br>                    if( !nLBid )    // If nLBid wasn't set by the SB_VALUE case above... <br>                        nLBid = SB_VALUE; <br> <br>                    //  Get current listbox selection. <br>                    nSelect = SendDlgItemMessage( hDlg, LOWORD(wParam), LB_GETCURSEL, <br>                                        (WPARAM)0, <br>                                        (LPARAM)0 ); <br>                    if( nSelect == LB_ERR ){ <br>                        LoadString(ghModule, IDS_GETVERERR7, lpBuffer, sizeof(lpBuffer)); <br>                        ErrorMsg(lpBuffer); <br>                        return(0); <br>                    } <br> <br>                    //  Set similar selection in corresponding listbox. <br>                    if( SendDlgItemMessage( hDlg, nLBid, LB_SETCURSEL, <br>                                            (WPARAM)nSelect, <br>                                            (LPARAM)0 ) <br>                                            == LB_ERR ){ <br>                        LoadString(ghModule, IDS_GETVERERR8, lpBuffer, sizeof(lpBuffer)); <br>                        ErrorMsg(lpBuffer); <br>                        return(0); <br>                    } <br> <br> <br>                    //  Set Scroll Bar position <br>                    SendDlgItemMessage( hDlg, SB_SCROLL, SBM_SETPOS, <br>                                        (WPARAM)nSelect, <br>                                        (LPARAM)TRUE ); <br>                } <br>            } <br>        } <br>        return(1); <br>      } <br>    } <br> <br>    return(0); <br>} <br> <br> <br>/***************************************************************************\ <br>* <br>* IsDirectory() <br>* <br>*  Given an item from a ListBox filled from an LB_DIR call, IsDirectory <br>*    verifies whether or not the item is a directory, and if so, returns <br>*    true, and places the full directory path in lpszFile. <br>* <br>*  input:   lpszDir     -   Holds current directory <br>*           lpszFile    -   Holds item of dubious directoryness. <br>* <br>* History: <br>* 5/30/92 <br>*   Created. <br>* <br>\***************************************************************************/ <br>BOOL IsDirectory(LPTSTR lpszDir, LPTSTR lpszFile) <br>{ <br>    DWORD   dwAttrib; <br>    LPTSTR  lpszHold; <br>    TCHAR   szItem[DIRECTORY_STRING_SIZE * 2]; <br>    TCHAR   lpBuffer[128]; <br> <br> <br>    // <br>    // if it's '..', go up one directory <br>    // <br>    if( !lstrcmp(lpszFile, TEXT("[..]")) ){ <br>        lstrcpy(lpszFile, lpszDir); <br>        lpszHold = TStrChr(lpszFile, TEXT('\0')); <br>        while( lpszHold &gt; lpszFile ){ <br>            if(*lpszHold == TEXT('\\')){ <br>                break; <br>            } <br>            lpszHold = CharPrev(lpszFile, lpszHold); <br>        } <br>        if(lpszHold &lt;= lpszFile){ <br>            LoadString(ghModule, IDS_ISDIRERR, lpBuffer, sizeof(lpBuffer)); <br>            ErrorMsg(lpBuffer); <br>            return(0); <br>        } <br>        else{ <br>            if( TStrChr(lpszFile, TEXT('\\')) == lpszHold ) <br>                lpszHold++; <br>            *lpszHold = TEXT('\0'); <br>            return(1); <br>        } <br>    } <br> <br>    // <br>    // A directory will have [] around it in the listbox. Check for it. <br>    // <br>    if( *lpszFile != TEXT('[') ) <br>        return(0); <br> <br>    // <br>    // A file under some file systems may have [] characters. <br>    //   Prepend path, adding a delimiting backslash unless we're in the root. <br>    //   If the attribute check is successful, it's a file, so leave. <br>    // <br>    // NOTE:  This is a hack.  If there is a file called '[foo]' and a <br>    //   Directory called 'foo', they will appear identical in the listbox. <br>    //   Rather than check for this rare case, if it happens, Filer will <br>    //   assume it is a file first, as the directory may be changed from <br>    //   the Directory Listbox. <br>    // <br>    lstrcpy(szItem, lpszDir); <br>    lpszHold = TStrChr(szItem, TEXT('\0')); <br> <br>    lpszHold--; <br>    if( *lpszHold != TEXT('\\') ){ <br>        lpszHold++; <br>        *lpszHold = TEXT('\\'); <br>    } <br>    lpszHold++; <br> <br>    lstrcpy(lpszHold, lpszFile); <br> <br>    dwAttrib = GetFileAttributes(szItem); <br> <br>    if( dwAttrib != 0xFFFFFFFF )             // there really is a file called <br>        return(0);                           //  '[foo]'.  Exit. <br> <br>    // <br>    // remove the [], and check if valid directory. <br>    //   if it fails, or it's not a directory, leave. <br>    // <br>    lstrcpy(lpszHold, &amp;lpszFile[1]); <br>    lpszHold = TStrChr(lpszHold, TEXT('\0')); <br> <br>    lpszHold--; <br>    if( *lpszHold != TEXT(']') ) <br>        return(0); <br>    *lpszHold = TEXT('\0'); <br> <br>    dwAttrib = GetFileAttributes(szItem); <br> <br>    if( (dwAttrib == 0xFFFFFFFF) || !(dwAttrib &amp; FILE_ATTRIBUTE_DIRECTORY) ) <br>        return(0); <br> <br>    // <br>    // OK, it's a directory, and szItem now holds the fully qualified path. <br>    // copy this to the filename buffer sent in, and return true. <br>    // <br>    CharUpper(szItem); <br>    lstrcpy(lpszFile, szItem); <br>    return(1); <br>} <br> <br> <br>/***************************************************************************\ <br>* <br>* ExecuteFileAction() <br>* <br>* Creates a dialog box verifying a file action, and carries out the action. <br>* <br>*  input:   hwnd    -   handle to Drv child. <br>*           lpSelect    -   pointer to SELECTINFO structure, containing <br>*                           info on the file i/o action to be performed. <br>* <br>* History: <br>* 5/28/92 <br>*   Created. <br>* <br>\***************************************************************************/ <br>BOOL ExecuteFileAction(LPSINFO lpSelect) <br>{ <br>    TCHAR   lpBuffer[128]; <br> <br>    if( DialogBoxParam(ghModule, TEXT("SelectDlg"), lpSelect-&gt;hwnd, <br>                  (DLGPROC)SelectProc, (LPARAM)lpSelect) == -1 ){ <br>        LoadString(ghModule, IDS_EXEFILEERR, lpBuffer, sizeof(lpBuffer)); <br>        ErrorMsg(lpBuffer); <br>        return(0); <br>    } <br>    return(1); <br>} <br> <br> <br>/***************************************************************************\ <br>* SelectProc() <br>* <br>* File I/O selection dialog proc. <br>* <br>* History: <br>* 5/28/92 <br>*   Created. <br>\***************************************************************************/ <br>LRESULT WINAPI SelectProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam) <br>{ <br>    static LPSINFO lpSelect; <br>    TCHAR   lpBuffer[128]; <br> <br>    switch (message) { <br>      case WM_INITDIALOG:{ <br> <br>        lpSelect = (LPSINFO)lParam; <br> <br>        // <br>        // Fill source and destination fields of Select dialog. <br>        // <br>        if( !FillSelectDlg(hDlg, lpSelect) ){ <br>            EndDialog(hDlg, wParam); <br>            return(1); <br>        } <br> <br>        // <br>        // Set the TEXT('action') text (i.e. TEXT("COPYING:"), TEXT("MOVING:"), etc.) <br>        // <br>        if( !SetDlgItemText(hDlg, SB_ACTION, lpSelect-&gt;szAction) ){ <br>            LoadString(ghModule, IDS_SELPROCERR, lpBuffer, sizeof(lpBuffer)); <br>            ErrorMsg(lpBuffer); <br>            EndDialog(hDlg, wParam); <br>            return(1); <br>        } <br> <br>        // <br>        // Set the TEXT("TO:") or TEXT("FROM:") text. <br>        // <br>        if( !SetDlgItemText(hDlg, SB_TOFROM, lpSelect-&gt;szToFrom) ){ <br>            LoadString(ghModule, IDS_SELPROCERR, lpBuffer, sizeof(lpBuffer)); <br>            ErrorMsg(lpBuffer); <br>            EndDialog(hDlg, wParam); <br>            return(1); <br>        } <br> <br>        break; <br>      } <br>      case WM_CLOSE: <br>        EndDialog(hDlg, wParam); <br>        return(1); <br>       <br>      case WM_COMMAND:{ <br>        switch(LOWORD(wParam)){ <br>            case SB_OK:{ <br>                DoFileIO(hDlg, lpSelect); <br>                EndDialog(hDlg, wParam); <br>                return(1); <br>            } <br>            case SB_CANCEL:{ <br>                EndDialog(hDlg, wParam); <br>                return(1); <br>            } <br>        } <br>        return(1); <br>      } <br>    } <br> <br>    return(0); <br>} <br> <br> <br>/***************************************************************************\ <br>* <br>* FillSelectDlg() <br>* <br>* Fills the Select Dialog box with the files selected in the active Drv Child <br>*  for a file i/o action.  Destination defaults to directory selection in <br>*  inactive Drv Child. <br>* <br>*  input:   hDlg    -   handle to Select dialog box. <br>*           hwnd    -   handle to Drv child. <br>* <br>* History: <br>* 5/28/92 <br>*   Created. <br>* <br>\***************************************************************************/ <br>BOOL FillSelectDlg(HWND hDlg, LPSINFO lpSelect) <br>{ <br>    LONG    lCount;         // Number of items selected in ListBox <br>    LONG    lSize;          // Holds size of a string <br>    LONG    lLargest = 0;   // Holds largest string encountered. <br>    UINT    *lpnIndex;      // ptr to array of selected ListBox items' indeces <br>    int     i;              // counter <br>    TCHAR   lpBuffer[128];  // Buffer for string retrieved from resources <br> <br>    LPCINFO lpCInfo; <br>    HWND    hDest;          // dir of files if delete, else inactive Drv dir. <br> <br>    HDC     hDC; <br>    TEXTMETRIC  Metrics; <br> <br>    LPTSTR  lpszHold;       // marks end of directory path in szName. <br>    TCHAR   szName[DIRECTORY_STRING_SIZE * 2];  // holds ListBox strings. <br> <br> <br>    lpCInfo = (LPCINFO)GetWindowLong(lpSelect-&gt;hwnd, GWL_USERDATA); <br> <br>    lCount = SendMessage( lpCInfo-&gt;hFileLB, LB_GETSELCOUNT, <br>                          (WPARAM)NULL, (LPARAM)NULL ); <br> <br>    // <br>    // if no items selected, leave. <br>    // <br>    if( !lCount ) <br>        return(0); <br> <br>    // <br>    // Allocate array of lCount listbox indexes, and fill it. <br>    // <br>    EnterCriticalSection(&amp;gHeapCS); <br>    lpnIndex = (UINT*)HeapAlloc( ghHeap, HEAP_ZERO_MEMORY, lCount * sizeof(UINT) ); <br>    LeaveCriticalSection(&amp;gHeapCS); <br>    if( !lpnIndex ){ <br>        LoadString(ghModule, IDS_SELDLGERR, lpBuffer, sizeof(lpBuffer)); <br>        ErrorMsg(lpBuffer); <br>        return(0); <br>    } <br> <br>    if( SendMessage( lpCInfo-&gt;hFileLB, LB_GETSELITEMS, (WPARAM)lCount, <br>                     (LPARAM)lpnIndex) != lCount ){ <br>        LoadString(ghModule, IDS_SELDLGERR2, lpBuffer, sizeof(lpBuffer)); <br>        ErrorMsg(lpBuffer); <br>        return(0); <br>    } <br> <br>    // <br>    // Check if each selected entry is a valid file. <br>    // <br>    // Check to see if there is a terminating backslash, by decrementing <br>    //  pointer, checking, adding a '\' if necessary, then re-incrementing <br>    //  the pointer. <br>    // <br>    lstrcpy(szName, lpCInfo-&gt;CaptionBarText); <br> <br>    lpszHold = TStrChr(szName, TEXT('\0')); <br> <br>    lpszHold--; <br>    if( *lpszHold != TEXT('\\') ){ <br>        lpszHold++; <br>        *lpszHold = TEXT('\\'); <br>    } <br>    lpszHold++; <br> <br>    // <br>    // Fill Dlg ListBox with selected strings from Drv child's ListBox, <br>    //   noting size of largest entry. <br>    // <br>    for( i = 0; i &lt; lCount; i++){ <br>        if( SendMessage( lpCInfo-&gt;hFileLB, LB_GETTEXT, (WPARAM)lpnIndex[i], <br>                        (LPARAM)lpszHold) == LB_ERR ){ <br>            LoadString(ghModule, IDS_SELDLGERR3, lpBuffer, sizeof(lpBuffer)); <br>            ErrorMsg(lpBuffer); <br>            return(0); <br>        } <br> <br>        if( GetFileAttributes(szName) == 0xFFFFFFFF ){    //Error <br>            LoadString(ghModule, IDS_SELDLGERR4, lpBuffer, sizeof(lpBuffer)); <br>            lstrcat(lpszHold, lpBuffer); <br>            ErrorMsg(lpszHold); <br>        } <br>        else{ <br>            lSize = lstrlen(lpszHold); <br>            if( lSize &gt; lLargest ) <br>                lLargest = lSize; <br> <br>            if( SendDlgItemMessage( hDlg, SB_SOURCE, LB_ADDSTRING, 0, <br>                                    (LPARAM)lpszHold) == LB_ERR ){ <br>                LoadString(ghModule, IDS_SELDLGERR5, lpBuffer, sizeof(lpBuffer)); <br>                ErrorMsg(lpBuffer); <br>                return(0); <br>            } <br>        } <br>    } <br> <br>    // <br>    // Get the average char width of current font, <br>    // We then set the dialog listbox column width to <br>    // (longest string + arbitrary column spacing) * ave width. <br>    // <br>    hDC = GetDC(lpSelect-&gt;hwnd); <br>    if( !GetTextMetrics(hDC, &amp;Metrics) ){ <br>        LoadString(ghModule, IDS_SELDLGERR6, lpBuffer, sizeof(lpBuffer)); <br>        ErrorMsg(lpBuffer); <br>        return(0); <br>    } <br> <br>    ReleaseDC(lpSelect-&gt;hwnd, hDC); <br> <br>    SendDlgItemMessage( hDlg, SB_SOURCE, LB_SETCOLUMNWIDTH, <br>                        (WPARAM)((lLargest + 8) * Metrics.tmAveCharWidth), <br>                        (LPARAM)NULL ); <br> <br>    EnterCriticalSection(&amp;gHeapCS); <br>    HeapFree( ghHeap, 0, (LPVOID)lpnIndex); <br>    LeaveCriticalSection(&amp;gHeapCS); <br> <br> <br>    // <br>    // Fill SB_DEST with directory. <br>    // If deleteing, default to the directory of the files. <br>    // <br>    if( lpSelect-&gt;dwAction != MM_DELETE ){ <br>        // <br>        // Not Deleting.  Default to selected directory (titlebar) <br>        //   of the inactive Drive child. <br>        // <br>        if( lpSelect-&gt;hwnd == ghwndDrv1 ) <br>            hDest = ghwndDrv2; <br>        else <br>            hDest = ghwndDrv1; <br> <br>        lpCInfo = (LPCINFO)GetWindowLong(hDest, GWL_USERDATA); <br>    } <br> <br>   SendDlgItemMessage( hDlg, SB_DEST, EM_LIMITTEXT, <br>                            (WPARAM)DIRECTORY_STRING_SIZE, (LPARAM)0); <br> <br>   if( SendDlgItemMessage( hDlg, SB_DEST, WM_SETTEXT, 0, <br>                            (LPARAM)lpCInfo-&gt;CaptionBarText) == CB_ERR ){ <br>        LoadString(ghModule, IDS_SELDLGERR7, lpBuffer, sizeof(lpBuffer)); <br>        ErrorMsg(lpBuffer); <br>        return(0); <br>    } <br> <br>    return(1); <br>} <br> <br> <br>/***************************************************************************\ <br>* <br>* DoFileIO() <br>* <br>* Called by SelectProc.  Carries out the chosed file operations verified <br>*   in the Select Dialog Box. <br>* <br>*  input:   hDlg    -   handle to Select dialog box. </code></pre>
<p>
</p>
<pre><code>*           lpSelect    -   ptr to SELECTINFO structure. <br>* <br>*  returns: 1 if successful <br>*           0 if unsuccessful <br>* History: <br>* 6/3/92 <br>*   Created. <br>* <br>\***************************************************************************/ <br>BOOL DoFileIO( HWND hDlg, LPSINFO lpSelect) <br>{ <br>    LONG    lCount; <br>    LONG    lFile; <br>    LPCINFO lpCInfo; <br>    LPTSTR  lpEndDest; <br>    LPTSTR  lpEndSource; <br>    BOOL    fError = FALSE; <br>    TCHAR   lpBuffer[128]; <br> <br>    TCHAR   szSource[DIRECTORY_STRING_SIZE]; <br>    TCHAR   szDest[DIRECTORY_STRING_SIZE * 2]; <br> <br> <br>    // <br>    // Find number of files to copy <br>    // <br>    lCount = SendDlgItemMessage( hDlg, SB_SOURCE, LB_GETCOUNT, (WPARAM)NULL, <br>                                 (LPARAM)NULL); <br> <br>    if( (lCount == LB_ERR) || (lCount == 0) ){ <br>        LoadString(ghModule, IDS_FILEIOERR, lpBuffer, sizeof(lpBuffer)); <br>        ErrorMsg(lpBuffer); <br>        return(0); <br>    } <br> <br>    // <br>    // Get source directory path. Add a \ to the end, set pointer to end. <br>    // <br>    lpCInfo = (LPCINFO)GetWindowLong( lpSelect-&gt;hwnd, GWL_USERDATA); <br> <br>    lstrcpy(szSource, lpCInfo-&gt;CaptionBarText); <br> <br>    lpEndSource = TStrChr(szSource, TEXT('\0')); <br>    *lpEndSource++ = TEXT('\\'); <br> <br>    // <br>    // Get destination directory path. Add a \ to the end, set pointer to end. <br>    // <br>    if( SendDlgItemMessage( hDlg, SB_DEST, WM_GETTEXT, <br>            (WPARAM)DIRECTORY_STRING_SIZE * 2, (LPARAM)szDest) == CB_ERR ){ <br>        LoadString(ghModule, IDS_FILEIOERR2, lpBuffer, sizeof(lpBuffer)); <br>        ErrorMsg(lpBuffer); <br>        return(0); <br>    } <br> <br>    lpEndDest = TStrChr(szDest, TEXT('\0')); <br>    *lpEndDest++ = TEXT('\\'); <br> <br>    // <br>    // for each file, do appropriate I/O. <br>    // <br>    while( lCount ){ <br> <br>        lCount--; <br> <br>        lFile = SendDlgItemMessage( hDlg, SB_SOURCE, LB_GETTEXT, <br>                                    (WPARAM)0, (LPARAM)lpEndSource); <br>        if( lFile == LB_ERR){ <br>            LoadString(ghModule, IDS_FILEIOERR3, lpBuffer, sizeof(lpBuffer)); <br>            ErrorMsg(lpBuffer); <br>            fError = TRUE; <br>        } <br> <br>        SendDlgItemMessage( hDlg, SB_SOURCE, LB_DELETESTRING, <br>                            (WPARAM)0, (LPARAM)NULL); <br> <br>        switch( lpSelect-&gt;dwAction ){ <br>          case MM_COPY:{ <br> <br>            lstrcpy(lpEndDest, lpEndSource); <br> <br>            if( !CopyFile( szSource, szDest, TRUE) ) <br>                if( !HandleIOError(lpSelect-&gt;hwnd, lpSelect-&gt;dwAction, <br>                                   szSource, szDest) ) <br>                    fError = TRUE; <br>            break; <br>          } <br> <br>          case MM_MOVE:{ <br> <br>            lstrcpy(lpEndDest, lpEndSource); <br> <br>            if( !MoveFileEx( szSource, szDest, <br>                            MOVEFILE_REPLACE_EXISTING|MOVEFILE_COPY_ALLOWED) ) <br>                if( !HandleIOError(lpSelect-&gt;hwnd, lpSelect-&gt;dwAction, <br>                                   szSource, szDest) ) <br>                    fError = TRUE; <br>            break; <br>          } <br>          case MM_DELETE:{ <br> <br>            if(GetFileAttributes(szSource) &amp; FILE_ATTRIBUTE_DIRECTORY) { <br>                if(!RemoveDirectory(szSource)) <br>                    if( !HandleIOError(lpSelect-&gt;hwnd, lpSelect-&gt;dwAction, <br>                                   szSource, szDest) ) <br>                        fError = TRUE; <br>            } <br>            else { <br>                if( !DeleteFile(szSource) ) <br>                    if( !HandleIOError(lpSelect-&gt;hwnd, lpSelect-&gt;dwAction, <br>                                   szSource, szDest) ) <br>                        fError = TRUE; <br>            } <br>          } <br>          break;   <br>        } <br>        if( fError ) <br>            break; <br>    } <br> <br>    // <br>    //  Update file listboxes. <br>    // <br>    if( fError ) <br>        return(0); <br>    else{ <br>        UpdateFileLB(ghwndDrv1); <br>        UpdateFileLB(ghwndDrv2); <br>    } <br> <br>    return(1); <br>} <br> <br> <br>/***************************************************************************\ <br>* <br>* HandleIOError() <br>* <br>* Called by DoFileIO. Handles errors arising from File IO operations <br>* <br>*  input:   hwnd        -   handle to Drv child window <br>*           dwAction    -   File I/O Action.  Window message. <br>*           szSource    -   ptr to Source string <br>*           szDest      -   ptr to Destination string <br>* <br>*  returns: 1 if successful <br>*           0 if unsuccessful <br>* <br>* History: <br>* 6/3/92 <br>*   Created. <br>* <br>\***************************************************************************/ <br>BOOL HandleIOError(HWND hwnd, DWORD dwAction, LPTSTR szSource, LPTSTR szDest) <br>{ <br>    DWORD   dwError; <br>    int     nReply; <br>    LPCINFO lpCInfo; <br>    TCHAR   buff[50]; <br>    TCHAR   lpBuffer[128]; <br> <br>    dwError = GetLastError(); <br> <br>    CharUpper(szDest); <br> <br>    switch( dwError ){ <br>        case ERROR_ALREADY_EXISTS: <br>        case ERROR_FILE_EXISTS:{ <br>          // <br>          // MoveFile file already exists. We can CopyFile &amp; DeleteFile source. <br>          // <br>          LoadString(ghModule, IDS_HNDIOMSG, lpBuffer, sizeof(lpBuffer)); <br>          nReply = MessageBox(hwnd, <br>                              lpBuffer, <br>                              szDest, MB_YESNOCANCEL); <br>          switch( nReply ){ <br>            case IDYES:{ <br> <br>              lpCInfo = (LPCINFO)GetWindowLong(hwnd, GWL_USERDATA); <br> <br>              if( !CopyFile( szSource, szDest, FALSE) ) <br>                  if( HandleIOError(hwnd, dwAction, szSource, szDest) ) <br>                      return(1); <br>                  else <br>                      return(0); <br>              if( dwAction == MM_MOVE ) <br>                  if( !DeleteFile( szSource) ) <br>                      if( HandleIOError(hwnd, dwAction, szSource, szDest) ) <br>                          return(1); <br>                      else <br>                          return(0); <br> <br>              UpdateFileLB(ghwndDrv1); <br>              UpdateFileLB(ghwndDrv2); <br> <br>              return(1); <br>            } <br>            case IDNO:{ <br>              return(1); <br>            } <br>            case IDCANCEL:{ <br>              return(0); <br>            } <br>          } <br>          break; <br>        } <br> <br>        case ERROR_ACCESS_DENIED: <br>        case ERROR_FILE_NOT_FOUND: <br>        case ERROR_INVALID_PARAMETER:{ <br>            LoadString(ghModule, IDS_HNDIOMSG2, lpBuffer, sizeof(lpBuffer)); <br>            wsprintf(buff, <br>                     lpBuffer, <br>                     dwError); <br>            MessageBox( hwnd, buff, szDest, MB_OK); <br> <br>            return(1); <br>        } <br> <br>        case ERROR_DISK_FULL:{ <br>            LoadString(ghModule, IDS_HNDIOMSG3, lpBuffer, sizeof(lpBuffer)); <br>            MessageBox( hwnd, <br>            lpBuffer, <br>            szDest, MB_OK); <br>            return(0); <br>        } <br> <br>        case ERROR_INVALID_NAME: <br>        case ERROR_DIRECTORY: <br>        case ERROR_PATH_NOT_FOUND:{ <br>            LoadString(ghModule, IDS_HNDIOMSG4, lpBuffer, sizeof(lpBuffer)); <br>            MessageBox( hwnd, <br>            lpBuffer, <br>            szDest, MB_OK); <br>            return(0); <br>        } <br> <br>        default:{ <br>            LoadString(ghModule, IDS_HNDIOMSG5, lpBuffer, sizeof(lpBuffer)); <br>            wsprintf(buff, lpBuffer, dwError); <br>            ErrorMsg(buff); <br>            return(1); <br>        } <br>    } <br> <br>    return(1); <br>} <br> <br> <br>/***************************************************************************\ <br>* RenameProc() <br>* <br>* File I/O rename Dialog Box <br>* <br>* History: <br>* 6/5/92  2am <br>*   Created. <br>\***************************************************************************/ <br>LRESULT WINAPI RenameProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam) <br>{ <br>    static TCHAR   szName[DIRECTORY_STRING_SIZE]; <br>    static LPTSTR  lpszHold; <br>    static LPCINFO lpCInfo; <br>    TCHAR   lpBuffer[128]; <br>    TCHAR   lpBuffer2[128]; <br> <br>    switch (message){ <br>      case WM_INITDIALOG:{ <br> <br>        LONG    lIndex; <br> <br>        lpCInfo = (LPCINFO)lParam; <br> <br>        // <br>        // Check to see if there is a terminating backslash, by decrementing <br>        //  pointer, checking, adding a '\' if necessary, then re-incrementing <br>        //  the pointer. <br>        // <br>        lstrcpy(szName, lpCInfo-&gt;CaptionBarText); <br>        lpszHold = TStrChr(szName, TEXT('\0')); <br> <br>        lpszHold--; <br>        if( *lpszHold != TEXT('\\') ){ <br>            lpszHold++; <br>            *lpszHold = TEXT('\\'); <br>        } <br>        lpszHold++; <br> <br>        lIndex = GetLBText(lpCInfo-&gt;hFileLB, lpszHold); <br>        if( lIndex == LB_ERR ) <br>            return(1); <br> <br>        // <br>        // if not a valid file (i.e. listbox directory entry in []s), fail. <br>        // <br>        if( GetFileAttributes(szName) == 0xFFFFFFFF ){    //Error <br>            LoadString(ghModule, IDS_SELDLGERR4, lpBuffer, sizeof(lpBuffer)); <br>            lstrcat(lpszHold, lpBuffer); <br>            ErrorMsg(lpszHold); <br>            return(1); <br>        } <br> <br>        // <br>        // Place name in both source and destination edit controls. <br>        // <br>        CharUpper(szName); <br> <br>        SendDlgItemMessage( hDlg, SB_SOURCE, EM_LIMITTEXT, <br>                            (WPARAM)DIRECTORY_STRING_SIZE, (LPARAM)0); <br> <br>        SendDlgItemMessage( hDlg, SB_DEST, EM_LIMITTEXT, <br>                            (WPARAM)DIRECTORY_STRING_SIZE, (LPARAM)0); <br> <br>        if( SendDlgItemMessage( hDlg, SB_SOURCE, WM_SETTEXT, 0, <br>                                (LPARAM)lpszHold) == LB_ERR ){ <br>            LoadString(ghModule, IDS_RENMEMSG, lpBuffer, sizeof(lpBuffer)); <br>            ErrorMsg(lpBuffer); <br>            return(1); <br>        } <br>        if( SendDlgItemMessage( hDlg, SB_DEST, WM_SETTEXT, 0, <br>                                (LPARAM)lpszHold) == LB_ERR ){ <br>            LoadString(ghModule, IDS_RENMEMSG2, lpBuffer, sizeof(lpBuffer)); <br>            ErrorMsg(lpBuffer); <br>            return(1); <br>        } <br>        return(1); <br>      } <br>      case WM_COMMAND:{ <br>        switch(LOWORD(wParam)){ <br>            case SB_OK:{ <br>                TCHAR   szDest[DIRECTORY_STRING_SIZE]; <br>                LPTSTR  lpszCheck; <br> <br>                // <br>                // the entire source dir\file is still in static szName. <br>                // static lpszHold points to the end of the dir <br>                // <br>                *lpszHold = TEXT('\0'); <br> <br>                lstrcpy(szDest, szName); <br> <br>                if( SendDlgItemMessage( hDlg, SB_SOURCE, WM_GETTEXT, <br>                                        DIRECTORY_STRING_SIZE, <br>                                        (LPARAM)lpszHold) == LB_ERR ){ <br>                    LoadString(ghModule, IDS_RENMEMSG3, lpBuffer, sizeof(lpBuffer)); <br>                    ErrorMsg(lpBuffer); <br>                    EndDialog(hDlg, wParam); <br>                    return(1); <br>                } <br> <br>                // <br>                // If there are any \s in the new filename, fail. <br>                // <br>                lpszCheck = TStrChr(lpszHold, TEXT('\\')); <br> <br>                if( lpszCheck ){ <br>                    LoadString(ghModule, IDS_RENMEMSG4, lpBuffer, sizeof(lpBuffer)); <br>                    LoadString(ghModule, IDS_RENMEMSG5, lpBuffer2, sizeof(lpBuffer2)); <br>                    MessageBox(lpCInfo-&gt;hwnd, <br>                               lpBuffer, <br>                               lpBuffer2, MB_OK ); <br>                    return(1); <br>                } <br> <br>                lpszHold = TStrChr(szDest, TEXT('\0')); <br> <br>                if( SendDlgItemMessage( hDlg, SB_DEST, WM_GETTEXT, <br>                                        DIRECTORY_STRING_SIZE, <br>                                        (LPARAM)lpszHold) == LB_ERR ){ <br>                    LoadString(ghModule, IDS_RENMEMSG6, lpBuffer, sizeof(lpBuffer)); <br>                    ErrorMsg(lpBuffer); <br>                    EndDialog(hDlg, wParam); <br>                    return(1); <br>                } <br> <br>                // <br>                // If there are any \s in the destination filename, fail. <br>                // <br>                lpszCheck = TStrChr(lpszHold, TEXT('\\')); <br> <br>                if( lpszCheck ){ <br>                    LoadString(ghModule, IDS_RENMEMSG4, lpBuffer, sizeof(lpBuffer)); <br>                    LoadString(ghModule, IDS_RENMEMSG5, lpBuffer2, sizeof(lpBuffer2)); <br>                    MessageBox(lpCInfo-&gt;hwnd, <br>                               lpBuffer, <br>                               lpBuffer2, MB_OK ); <br>                    return(1); <br>                } <br> <br>                // <br>                // if strings are identical, leave. <br>                // <br>                if( !lstrcmpi(szName, szDest) ){ <br>                    EndDialog(hDlg, wParam); <br>                    return(1); <br>                } <br> <br>                if( !MoveFile( szName, szDest) ) <br>                    if( !HandleIOError(lpCInfo-&gt;hwnd, <br>                                       (DWORD)MM_RENAME, szName, szDest) ){ <br>                        EndDialog(hDlg, wParam); <br>                        return(1); <br>                    } <br> <br>                if( !PostMessage(lpCInfo-&gt;hwnd, WM_COMMAND, MM_FILLFILE, <br>                                 (LPARAM)0) ) { <br>                    LoadString(ghModule, IDS_RENMEMSG7, lpBuffer, sizeof(lpBuffer)); <br>                    ErrorMsg(lpBuffer); <br>                } <br>                EndDialog(hDlg, wParam); <br>                return(1); <br>            } <br>            case SB_CANCEL:{ <br>                EndDialog(hDlg, wParam); <br>                return(1); <br>            } <br>        } <br>        return(1); <br>      } // WM_COMMAND <br>    } <br> <br>    return(0); <br>} <br> <br> <br>/***************************************************************************\ <br>* MkDirProc() <br>* <br>* File I/O Make Directory Dialog Box <br>* <br>* History: <br>* 6/5/92  2am <br>*   Created. <br>\***************************************************************************/ <br>LRESULT WINAPI MkDirProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam) <br>{ <br>    TCHAR   lpBuffer[128]; <br> <br>    switch (message){ <br>      case WM_INITDIALOG:{ <br>        LPCINFO lpCInfo; <br>        TCHAR   szDest[DIRECTORY_STRING_SIZE]; <br>        LPTSTR  lpszHold; <br> <br> <br>        lpCInfo = (LPCINFO)lParam; <br> <br>        // <br>        // Check to see if there is a terminating backslash, by decrementing <br>        //  pointer, checking, adding a '\' if necessary. <br>        // <br>        lstrcpy(szDest, lpCInfo-&gt;CaptionBarText); <br>        lpszHold = TStrChr(szDest, TEXT('\0')); <br> <br>        lpszHold--; <br>        if( *lpszHold != TEXT('\\') ){ <br>            lpszHold++; <br>            *lpszHold = TEXT('\\'); <br>            lpszHold++; <br>            *lpszHold = TEXT('\0'); <br>        } <br> <br>        SendDlgItemMessage( hDlg, SB_DEST, EM_LIMITTEXT, <br>                            (WPARAM)DIRECTORY_STRING_SIZE, (LPARAM)0); <br> <br>        // <br>        // Place name in directory name edit control. <br>        // <br>        if( SendDlgItemMessage( hDlg, SB_DEST, WM_SETTEXT, 0, <br>                                (LPARAM)szDest) == LB_ERR ){ <br>            LoadString(ghModule, IDS_MKDIRMSG, lpBuffer, sizeof(lpBuffer)); <br>            ErrorMsg(lpBuffer); <br>            return(1); <br>        } <br> <br>        SendDlgItemMessage( hDlg, SB_DEST, EM_SETSEL, (WPARAM)-1, (LPARAM)0); <br> <br>        return(1); <br>      } <br>      case WM_COMMAND:{ <br>        switch(wParam){ <br>            case SB_OK:{ <br>                TCHAR    szDest[DIRECTORY_STRING_SIZE]; <br> <br>                if( SendDlgItemMessage( hDlg, SB_DEST, WM_GETTEXT, <br>                                        DIRECTORY_STRING_SIZE, <br>                                        (LPARAM)szDest) == LB_ERR ){ <br>                    LoadString(ghModule, IDS_MKDIRMSG2, lpBuffer, sizeof(lpBuffer)); <br>                    ErrorMsg(lpBuffer); <br>                    EndDialog(hDlg, wParam); <br>                    return(1); <br>                } <br> <br>                // <br>                // If loacation of subdir is invalid, leave. <br>                // <br>                if( !CreateDirectory(szDest, NULL) ){ <br>                    LoadString(ghModule, IDS_MKDIRMSG3, lpBuffer, sizeof(lpBuffer)); <br>                    ErrorMsg(lpBuffer); <br>                    EndDialog(hDlg, wParam); <br>                    return(1); <br>                } <br> <br>                SendMessage( ghwndDrv1, WM_COMMAND, MM_REFRESH, (LPARAM)0); <br>                SendMessage( ghwndDrv2, WM_COMMAND, MM_REFRESH, (LPARAM)0); <br>            } <br>            case SB_CANCEL:{ <br>                EndDialog(hDlg, wParam); <br>                return(1); <br>            } <br>        } <br>        return(1); <br>      } <br>    } <br> <br>    return(0); <br>} <br> <br> <br>/***************************************************************************\ <br>* <br>* TextWndProc() <br>* <br>* Text Window procedure for displaying miscellaneous messages to user. <br>* <br>* History: <br>* 5/25/92 <br>*   Created. <br>* <br>\***************************************************************************/ <br> <br>LRESULT WINAPI TextWndProc (HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam) <br>{ <br> <br>    TCHAR   lpBuffer[128]; <br>     <br>    switch (message) <br>    { <br>    case WM_CREATE: <br>        { <br>        HDC        hDC; <br>        HGDIOBJ    hOldFont; <br>        TEXTMETRIC tm; <br>        LONG       lHeight; <br> <br>        hDC = GetDC(hwnd); <br> <br>        hOldFont = SelectObject(hDC, ghFont); <br>        GetTextMetrics(hDC, &amp;tm); <br> <br>        // <br>        // base the height of the window on size of text <br>        // <br>        lHeight = tm.tmHeight + GetSystemMetrics(SM_CYBORDER) + 6; <br> <br>        // <br>        // saved the height for later reference <br>        // <br>        SetWindowLong(hwnd, GWL_USERDATA, lHeight); <br> <br>            if(hOldFont) <br>                SelectObject(hDC, hOldFont); <br> <br>            ReleaseDC(hwnd, hDC); <br>            break; <br>        } <br> <br>    case WM_SETTEXT: <br>            DefWindowProc(hwnd, message, wParam, lParam); <br>            if( !InvalidateRect(hwnd, NULL, TRUE) ){ <br>                LoadString(ghModule, IDS_TXTMSG, lpBuffer, sizeof(lpBuffer)); <br>                ErrorMsg(lpBuffer); <br>                return(1); <br>            } <br>            UpdateWindow(hwnd); <br>            return(1); <br> <br>    case WM_PAINT: <br>        { <br>            PAINTSTRUCT ps; <br>            RECT        rc; <br>            TCHAR       ach[128]; <br>            int         len, nxBorder, nyBorder; <br>            HFONT       hOldFont = NULL; <br>            HBRUSH      hBrush; <br> <br>            BeginPaint(hwnd, &amp;ps); <br> <br>            GetClientRect(hwnd,&amp;rc); <br> <br>            len = GetWindowText(hwnd, ach, sizeof(ach)); <br> <br>            SetBkMode(ps.hdc, TRANSPARENT); <br> <br>            if( GetParent(hwnd) == ghActiveChild ){ <br>                hBrush = CreateSolidBrush( GetSysColor(COLOR_ACTIVECAPTION) ); <br>                SetTextColor( ps.hdc, GetSysColor(COLOR_CAPTIONTEXT) ); <br>            } <br>            else{ <br>                hBrush = CreateSolidBrush( GetSysColor(COLOR_INACTIVECAPTION) ); <br>                SetTextColor( ps.hdc, GetSysColor(COLOR_INACTIVECAPTIONTEXT) ); <br>            } <br> <br>            hOldFont = SelectObject(ps.hdc, ghFont); <br> <br>            FillRect(ps.hdc, &amp;rc, hBrush); <br> <br>            nxBorder = GetSystemMetrics(SM_CXBORDER); <br>            rc.left  += 9*nxBorder; <br>            rc.right -= 9*nxBorder; <br> <br>            nyBorder = GetSystemMetrics(SM_CYBORDER); <br>            rc.top    += 3*nyBorder; <br>            rc.bottom -= 3*nyBorder; <br> <br>            ExtTextOut(ps.hdc, rc.left+2*nxBorder, rc.top, ETO_CLIPPED, <br>                    &amp;rc, ach, len, NULL); <br> <br>            SetBkMode(ps.hdc, OPAQUE); <br> <br>            if (hOldFont) <br>                SelectObject(ps.hdc, hOldFont); <br> <br>            DeleteObject(hBrush); <br> <br>            EndPaint(hwnd, &amp;ps); <br>            return(1); <br>        } <br>    } <br>    return DefWindowProc(hwnd, message, wParam, lParam); <br>} <br> <br>/***************************************************************************\ <br>* <br>* TStrChr() <br>* <br>* A strchr() function which is ASCII or UNICODE. <br>* <br>* History: <br>* 2/25/93 <br>*   Created. <br>* <br>\***************************************************************************/ <br>PTCHAR TStrChr(const PTCHAR string, UINT c) <br>{ <br>#ifdef UNICODE <br>    return wcschr((wchar_t*)string, (wchar_t)c); <br>#else <br>    PTCHAR  psz; <br>    for (psz = string; *psz; psz = CharNext(psz)) { <br>        if (*psz == (TCHAR)c) { <br>            break; <br>        } <br>    } <br>    return psz; <br>#endif <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
