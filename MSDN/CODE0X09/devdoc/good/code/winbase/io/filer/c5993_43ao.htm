<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>FILER.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6000"></a>FILER.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples.  <br>*       Copyright 1993 - 1998 Microsoft Corporation. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>/******************************Module*Header*******************************\ <br>* <br>* Module Name:  Filer.c <br>* <br>* <br>* Filer: SDK sample <br>*   +   Simple File Management program with GUI front end. <br>*       Demonstrates Win32 File I/O API and various User algorithms. <br>* <br>* Dependencies: <br>* <br>*   (#defines) <br>*   (#includes) <br>*         -Enumdrv.h <br>*         -Walk.h <br>*         -Drvproc.h <br>*         -Filer.h <br>* <br>\**************************************************************************/ <br>#define  STRICT <br>#include &lt;windows.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;stdarg.h&gt; <br>#include "globals.h" <br>#include "enumdrv.h" <br>#include "drvproc.h" <br>#include "filer.h" <br> <br>// <br>// Global Handles <br>// <br>HANDLE  ghModule;                     // Process Instance handle <br> <br>HWND    ghwndMain;                       // Main window handle <br>HWND    ghwndDrives;                     // Drives Toolbar window handle <br>HWND    ghwndFunction;                   // Function Toolbar window handle <br>HWND    ghwndCommand;                    // Command Line window handle <br>HWND    ghwndDrv1, <br>        ghwndDrv2; <br>HWND    ghActiveChild = NULL;            // Handle to active drive child window <br>HWND    ghFocusWnd;                      // Handle to last listbox with focus <br> <br> <br>HANDLE  ghHeap;                          // Application heap handle <br>HFONT   ghFont; <br>HANDLE  ghDrvThread = NULL; <br> <br>HMENU   ghMenu;                          // App Menu variables <br> <br>// <br>//   Global Data Items <br>// <br>BOOL                gfDrvWndOrient = SIDE_BY_SIDE, // relative Drv child pos. <br>                    gfKeepCommandWin = FALSE; <br> <br>DRVCHILDINFO        gDrvChild1Info, <br>                    gDrvChild2Info; <br> <br>LPDINFO             glpDrives = NULL;    // Root of Available Drives linked list <br> <br>CRITICAL_SECTION    gDrvCS;              // Drive list critical section var. <br>CRITICAL_SECTION    gHeapCS;             // Global heap critical section. <br> <br>TCHAR    gszCommandLine[DIRECTORY_STRING_SIZE * 2]; <br>TCHAR    gszExtensions[NUM_EXTENSION_STRINGS][EXTENSION_LENGTH]; <br> <br>VKINFO  gVKArray[NUM_VERSION_INFO_KEYS];     // .EXE version info array. <br>                                             // See GetVersion() in DRVPROC.C <br> <br>/***************************************************************************\ <br>* WinMain <br>* <br>* <br>* History: <br>* 04-17-91 <br>*   Created. <br>\***************************************************************************/ <br>int WINAPI WinMain( <br>    HINSTANCE hInstance, <br>    HINSTANCE hPrevInstance, <br>    LPSTR lpCmdLine, <br>    int nCmdShow) <br>{ <br>    MSG    msg; <br>    HANDLE hAccel; <br> <br>    //-- check to make sure we are running on Windows NT <br>    if( GetVersion() &amp; 0x80000000 ) {            // 0x80000000 == Windows 3.1 <br>        MessageBox( NULL, <br>        TEXT("Sorry, Filer must run under Windows NT.  Filer will now terminate."), <br>        TEXT("Error: Windows NT Required"),  MB_OK ); <br>        return( 0 ); <br>    } <br> <br>    ghModule = hInstance; <br> <br>    if (!InitializeApp()) { <br>        ErrorMsg(TEXT("Filer: InitializeApp failure!")); <br>        return 0; <br>    } <br>    ShowWindow(ghwndMain, nCmdShow); <br> <br>    if (!(hAccel = LoadAccelerators (ghModule, MAKEINTRESOURCE(ACCEL_ID)))) <br>        ErrorMsg(TEXT("Filer: Load Accel failure!")); <br> <br> <br>    while (GetMessage(&amp;msg, NULL, 0, 0)) { <br>        if( !TranslateAccelerator(ghwndMain, hAccel, &amp;msg) ) { <br>            TranslateMessage(&amp;msg); <br>            DispatchMessage(&amp;msg); <br>        } <br>    } <br> <br>    return 1; <br> <br>    UNREFERENCED_PARAMETER(lpCmdLine); <br>    UNREFERENCED_PARAMETER(hPrevInstance); <br>} <br> <br> <br>/***************************************************************************\ <br>* InitializeApp <br>* <br>* History: <br>* 5/5/92 <br>*   Created <br>\***************************************************************************/ <br> <br>BOOL InitializeApp(void) <br>{ <br>    WNDCLASS wc; <br> <br>    wc.style            = 0; <br>    wc.lpfnWndProc      = (WNDPROC)MainWndProc; <br>    wc.cbClsExtra       = 0; <br>    wc.cbWndExtra   = 0; <br>    wc.hInstance        = ghModule; <br>    wc.hIcon            = LoadIcon(ghModule, MAKEINTRESOURCE(UI_FILERICON)); <br>    wc.hCursor          = LoadCursor(ghModule, IDC_ARROW); <br>    wc.hbrBackground    = (HBRUSH)(COLOR_APPWORKSPACE); <br>    wc.lpszMenuName     = TEXT("FilerMenu"); <br>    wc.lpszClassName    = TEXT("FilerClass"); <br> <br>    if (!RegisterClass(&amp;wc)) <br>    return(FALSE); <br> <br>    wc.lpfnWndProc  = DrvWndProc; <br>    wc.hIcon        = NULL; <br>    wc.lpszMenuName = NULL; <br>    wc.lpszClassName    = TEXT("DrvClass"); <br> <br>    if (!RegisterClass(&amp;wc)) <br>        return(FALSE); <br> <br>    wc.style        = CS_HREDRAW | CS_VREDRAW | CS_OWNDC; <br>    wc.lpfnWndProc  = DriveBarProc; <br>    wc.hbrBackground    = (HBRUSH)(COLOR_BTNSHADOW); <br>    wc.lpszClassName    = TEXT("DriveBarClass"); <br> <br>    if (!RegisterClass(&amp;wc)) <br>            return(FALSE); <br> <br>    wc.style        = CS_HREDRAW | CS_VREDRAW; <br>    wc.lpfnWndProc  = TextWndProc; <br>    wc.hbrBackground    = (HBRUSH)(COLOR_INACTIVECAPTION); <br>    wc.lpszClassName    = TEXT("TextClass"); <br> <br>    if (!RegisterClass(&amp;wc)) <br>            return(FALSE); <br> <br>    ghMenu = LoadMenu(ghModule, TEXT("FilerMenu")); <br> <br>    ghwndMain = CreateWindow(TEXT("FilerClass"), <br>                             TEXT("Filer"), <br>                             WS_OVERLAPPEDWINDOW, <br>                             CW_USEDEFAULT, <br>                             CW_USEDEFAULT, <br>                             MAIN_WIDTH, <br>                             MAIN_HEIGHT, <br>                             HWND_DESKTOP, <br>                             ghMenu, <br>                             ghModule, <br>                             NULL); <br> <br>    if (ghwndMain == NULL) <br>    return(FALSE); <br> <br>    return(TRUE); <br>} <br> <br> <br>/***************************************************************************\ <br>* MainWndProc <br>* <br>* History: <br>* 05-01-92  Created. <br>\***************************************************************************/ <br> <br>LRESULT WINAPI MainWndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam) <br>{ <br>    switch (message) { <br> <br>      case WM_CREATE:{ <br>        LOGFONT    lf; <br>        HDC        hDC; <br>        HGDIOBJ    hOldFont; <br>        TEXTMETRIC tm; <br> <br>        DWORD dwThreadID; <br> <br>        // <br>        // Initialize drive list and Set Directory critical sections. <br>        // <br>        InitializeCriticalSection(&amp;gDrvCS); <br>        InitializeCriticalSection(&amp;gHeapCS); <br> <br>        ghDrvThread = CreateThread(NULL, 0, <br>                                   (LPTHREAD_START_ROUTINE)EnumDrives, <br>                                   (LPVOID)&amp;glpDrives, <br>                                   0, &amp;dwThreadID); <br> <br>        // <br>        // Create the application's heap <br>        // <br>        ghHeap = HeapCreate( 0, (DWORD)sizeof(DRVCHILDINFO), 0); <br>        if( ghHeap == NULL ) <br>            ErrorMsg(TEXT("Main Create: Failed in Creating Heap")); <br> <br>        // <br>        // Compute default application font by creating a bold version <br>        //   of the system default icon font. <br>        // <br>        SystemParametersInfo(SPI_GETICONTITLELOGFONT, sizeof(lf), <br>                             (PVOID) &amp;lf, FALSE); <br> <br>        hDC = GetDC(hwnd); <br> <br>        // this is the height for 8 point size font in pixels. <br>        //  (1 point = 1/72 in.) <br>        //  Japanese fonts have different characteristics and don't look good in bold <br>        if (PRIMARYLANGID(GetUserDefaultLangID()) == LANG_JAPANESE) <br>            lf.lfHeight = 10 * GetDeviceCaps(hDC, LOGPIXELSY) / 72; <br>        else { <br>            lf.lfHeight = 8 * GetDeviceCaps(hDC, LOGPIXELSY) / 72; <br>            lf.lfWeight = BOLD_FONT; <br>        } <br> <br>        ghFont = CreateFontIndirect(&amp;lf); <br>        hOldFont = SelectObject(hDC, ghFont); <br>        GetTextMetrics(hDC, &amp;tm); <br> <br>        if(hOldFont) <br>            SelectObject(hDC, hOldFont); <br> <br>        ReleaseDC(hwnd, hDC); <br> <br>        // <br>        // Create Drive windows <br>        // <br>        gDrvChild1Info.hParent = hwnd; <br>        gDrvChild2Info.hParent = hwnd; <br> <br>        ghwndDrv1 = CreateWindow(TEXT("DrvClass"), NULL, <br>                                 WS_CHILD | <br>                                 WS_CLIPSIBLINGS | WS_VISIBLE, <br>                                 0, 0, 0, 0, <br>                                 hwnd, (HMENU) 1, ghModule, <br>                                 (LPVOID)&amp;gDrvChild1Info); <br> <br>        ghActiveChild = ghwndDrv1; <br> <br>        // <br>        // Set initial focus to Drive Child 1's Directory listbox. <br>        // <br>        ghFocusWnd = ((LPCINFO)GetWindowLong(ghwndDrv1, GWL_USERDATA))-&gt;hDirLB; <br> <br>        ghwndDrv2 = CreateWindow(TEXT("DrvClass"), NULL, <br>                                 WS_CHILD | <br>                                 WS_CLIPSIBLINGS | WS_VISIBLE, <br>                                 0, 0, 0, 0, <br>                                 hwnd, (HMENU) 2, ghModule, <br>                                 (LPVOID)&amp;gDrvChild2Info); <br> <br>        // <br>        // Create DriveBar, FunctionBar and Command windows <br>        // <br>        ghwndDrives = CreateWindow(TEXT("DriveBarClass"), NULL, <br>                                   WS_CHILD | WS_VISIBLE | WS_BORDER, <br>                                   0, 0, 0, 0, <br>                                   hwnd, (HMENU) 3, ghModule, <br>                                   (LPVOID)NULL); <br> <br>        ghwndFunction = CreateDialog(ghModule, <br>                                    TEXT("FunctionBar"), <br>                                    hwnd, <br>                                    (DLGPROC)FunctionBarProc); <br> <br>        ghwndCommand = CreateWindow(TEXT("EDIT"), NULL, <br>                                   ES_AUTOHSCROLL | ES_LEFT | WS_BORDER | <br>                                   ES_NOHIDESEL | WS_CHILD | WS_VISIBLE, <br>                                   0, 0, 0, 0, <br>                                   hwnd, <br>                                   (HMENU) COMMAND_ID, <br>                                   ghModule, <br>                                   NULL); <br> <br>        // <br>        // Compute height of command window from font; store in window info. <br>        // Set command window to default font. <br>        // <br>        SetWindowLong( ghwndCommand, GWL_USERDATA, <br>                       tm.tmHeight + GetSystemMetrics(SM_CYBORDER) + 6); <br>        SendMessage(ghwndCommand, WM_SETFONT, (WPARAM)ghFont, (LPARAM)FALSE); <br> <br>        // <br>        // Load String table entries <br>        // <br>        LoadString( ghModule, STR_EXE, &amp;gszExtensions[0][0], EXTENSION_LENGTH); <br>        LoadString( ghModule, STR_COM, &amp;gszExtensions[1][0], EXTENSION_LENGTH); <br>        LoadString( ghModule, STR_CMD, &amp;gszExtensions[2][0], EXTENSION_LENGTH); <br>        LoadString( ghModule, STR_BAT, &amp;gszExtensions[3][0], EXTENSION_LENGTH); <br> <br>        UpdateDrivesMenu(ghMenu, ghDrvThread); <br> <br>        return(1); <br>      } <br> <br>      case WM_COMMAND:{ <br> <br>        // <br>        // The menu Identifiers for the drives are (potentially) <br>        // MM_DRIVE_NUM + 0 thru MM_DRIVE_NUM + 25. They all go to the <br>        // same case, so we will put the Menu ID in lParam, and <br>        // MM_DRIVE_NUM in LOWORD(wParam). <br>        // <br>        if( (LOWORD(wParam) - MM_DRIVE_NUM) &lt;= 25 &amp;&amp; <br>            (LOWORD(wParam) - MM_DRIVE_NUM) &gt;= 0 ){ <br>            lParam = LOWORD(wParam); <br>            wParam = MM_DRIVE_NUM; <br>        } <br> <br>        switch (LOWORD(wParam)) { <br>            // <br>            // If a drive is selected from the Drives menu, or clicked <br>            //  on the drives toolbar, the currently active child will <br>            //  switch to this drive. Message 'unconverted' (see top of <br>            //  WM_COMMAND case), and sent to DriveBarProc <br>            // <br>            case MM_DRIVE_NUM:{ <br> <br>                SendMessage(ghwndDrives, WM_COMMAND, <br>                            (WPARAM)lParam, (LPARAM)NULL); <br>                return(1); <br>            } <br> <br>            // <br>            // Passes these WM_COMMAND messages to the appropriate active child <br>            //  window proc for processing <br>            // <br>            case MM_TAB: <br>            case MM_ESCAPE: <br>            case MM_OPEN: <br>            case MM_COPY: <br>            case MM_DELETE: <br>            case MM_MOVE: <br>            case MM_RENAME: <br>            case MM_MKDIR: <br>            case MM_EXPAND: <br>            case MM_VERSION:{ <br> <br>                SendMessage(ghActiveChild, WM_COMMAND, wParam, lParam); <br>                return(1); <br>            } <br> <br>            case MM_EXIT:{ <br>                SendMessage(ghwndMain, WM_CLOSE, wParam, lParam); <br>                return(1); <br>            } <br> <br>            // <br>            // Creates the drive enumeration thread to re-enumerate the <br>            //   available drives in the main menu.  Also sends a refresh <br>            //   to the active drive child, and repaints the window. <br>            // <br>            case MM_REFRESH: { <br>                DWORD   dwThreadID; <br> <br>                // <br>                // Initialize/Refresh Drives linked list <br>                // <br> <br>                if( WaitForSingleObject(ghDrvThread, 0) != WAIT_TIMEOUT ){ <br> <br>                    // <br>                    // Close previous Drive Thread handle before creating new handle. <br>                    // <br>                    CloseHandle( ghDrvThread ); <br> <br>                    ghDrvThread = CreateThread(NULL, 0, <br>                                           (LPTHREAD_START_ROUTINE)EnumDrives, <br>                                           (LPVOID)&amp;glpDrives, <br>                                           0, &amp;dwThreadID); <br> <br>                    // <br>                    // Refresh active child, drive toolbar, and drives menu <br>                    // <br>                    SendMessage(ghActiveChild, WM_COMMAND, wParam, lParam); <br>                    SendMessage(ghwndDrives, WM_COMMAND, wParam, lParam); <br>                    UpdateDrivesMenu(ghMenu, ghDrvThread); <br> <br>                    // <br>                    // Mark all for repaint <br>                    // <br>                    InvalidateRect(hwnd,NULL,TRUE); <br> <br>                } <br>                else <br>                    MessageBeep(MB_ICONASTERISK); <br> <br>                return(1); <br>            } <br> <br>            // <br>            // Swaps the directory and file list boxes of the active drv child. <br>            // <br>            case MM_SWAP:{ <br>                LPCINFO lpCInfo; <br>                RECT    rect; <br> <br>                lpCInfo = (LPCINFO)GetWindowLong(ghActiveChild, GWL_USERDATA); <br> <br>                // <br>                // Switch the flag which indicates which side the Directory <br>                //  LB is on.  This is used by the WM_SIZE case of DrvWndProc. <br>                // <br>                lpCInfo-&gt;fDirLeft = !lpCInfo-&gt;fDirLeft; <br> <br>                // <br>                // Send size message with current size to active child, <br>                //   in order to redraw the listboxes. <br>                // <br>                if( !GetClientRect( ghActiveChild, &amp;rect ) ) <br>                    return(0); <br> <br>                SendMessage( ghActiveChild, WM_SIZE, SIZENORMAL, <br>                             MAKELONG( rect.right - rect.left, <br>                                       rect.bottom - rect.top) ); <br>                return(1); <br>            } <br> <br>            case MM_KEEPCMD:{ <br> <br>                gfKeepCommandWin = !gfKeepCommandWin; <br> <br>                if( gfKeepCommandWin ) <br>                    CheckMenuItem( ghMenu, MM_KEEPCMD, <br>                                    MF_BYCOMMAND | MF_CHECKED); <br>                else <br>                    CheckMenuItem( ghMenu, MM_KEEPCMD, <br>                                MF_BYCOMMAND | MF_UNCHECKED); <br>            } <br>            break; <br> <br>            // <br>            // Toggles the relative Drive Child orientaion between <br>            // Over/under and side/side.  gfDrvWndOrient is a flag checked <br>            // by WM_SIZE to size Drv children <br>            // <br>            case MM_ORIENT:{ <br>                RECT    rect; <br> <br>                if( gfDrvWndOrient == OVER_UNDER ) <br>                    gfDrvWndOrient = SIDE_BY_SIDE; <br>                else <br>                    gfDrvWndOrient = OVER_UNDER; <br> <br>                // <br>                // Send size message with current size to self (main window), <br>                //   in order to redraw the Drv children. <br>                // <br>                if( !GetClientRect( hwnd, &amp;rect ) ) <br>                    return(0); <br> <br>                SendMessage( hwnd, WM_SIZE, SIZENORMAL, <br>                             MAKELONG( rect.right - rect.left, <br>                                       rect.bottom - rect.top) ); <br> <br>                InvalidateRect(ghwndDrv1,NULL,TRUE); <br>                InvalidateRect(ghwndDrv2,NULL,TRUE); <br> <br>                return(1); <br>            } <br> <br>            // <br>            // Toggles the active drive child.  Sent from menu. <br>            // This behaves the same as a WM_MOUSEACTIVATE in one of the <br>            //   Drive children.  The PostMessage is so the current Active <br>            //   child will not process the MM_TOGGLE message until after it <br>            //   is no longer active. <br>            // <br>            case MM_ACTIVEDRV:{ <br>                LPCINFO lpCInfo; <br> <br>                PostMessage(ghActiveChild, WM_COMMAND, (WPARAM)MM_TOGGLE, <br>                            (LPARAM)NULL); <br> <br>                if( ghActiveChild == ghwndDrv1 ) <br>                    ghActiveChild = ghwndDrv2; <br>                else <br>                    ghActiveChild = ghwndDrv1; <br> <br>                SendMessage(ghActiveChild, WM_COMMAND, (WPARAM)MM_TOGGLE, <br>                            (LPARAM)NULL); <br> <br>                // change drive button <br>                lpCInfo = (LPCINFO)GetWindowLong(ghActiveChild, GWL_USERDATA); <br>                SendMessage(ghwndDrives, WM_COMMAND, MM_ACTIVEDRV, <br>                            (LPARAM)lpCInfo-&gt;lpDriveInfo); <br>                return(1); <br>            } <br> <br>            // <br>            // Sent by the Command line Edit control. <br>            // <br>            case COMMAND_ID:{ <br> <br>                if( HIWORD(wParam) == EN_SETFOCUS ) <br>                    ghFocusWnd = ghwndCommand; <br>            } <br>            break; <br> <br>            // <br>            // Launches the About DialogBox. <br>            // <br>            case MM_ABOUT:{ <br>                TCHAR   lpBuffer[128]; <br> <br>                if (DialogBox(ghModule, TEXT("AboutBox"), ghwndMain, (DLGPROC)AboutProc) == -1) { <br>                    LoadString(ghModule, IDS_ABOUTDLGERR, lpBuffer, sizeof(lpBuffer)); <br>                    ErrorMsg(lpBuffer); <br>                } <br>                return(1); <br>            } <br> <br>            default: <br>                return( DefWindowProc(hwnd, message, wParam, lParam) ); <br>        } <br>        return(1); <br>      } <br>      // <br>      // Whenever the window is resized, its children have to be <br>      //  resized accordingly.  The GetWindowLong values are the height <br>      //  of the windows queried by this function, and are set in the <br>      //  WM_CREATE cases of their respective WNDPROCs. <br>      // <br>      case WM_SIZE:{ <br>        int DrvWndHeight; <br> <br>        // <br>        // Always put the command window at the bottom of the frame window <br>        // <br>        MoveWindow(ghwndCommand, <br>           0, <br>           HIWORD(lParam) - GetWindowLong(ghwndCommand, GWL_USERDATA), <br>           LOWORD(lParam), <br>           GetWindowLong(ghwndCommand, GWL_USERDATA), <br>               TRUE); <br>        // <br>        // Always put the drives toolbar at the top of the frame window <br>        // <br>        MoveWindow(ghwndDrives, <br>           0, <br>           0, <br>           LOWORD(lParam), <br>           GetWindowLong(ghwndDrives, GWL_USERDATA), <br>               TRUE); <br> <br>        // <br>        // Always put the Function window just below the drives toolbar. <br>        // <br>        MoveWindow(ghwndFunction, <br>                   0, <br>                   GetWindowLong(ghwndDrives, GWL_USERDATA), <br>                   LOWORD(lParam), <br>                   GetWindowLong(ghwndFunction, GWL_USERDATA), <br>                   TRUE); <br> <br>        // <br>        // Always size the Drive Children between the Drives and Command <br>        // windows. The width is set so that borders overlap. <br>        // <br> <br>        if( gfDrvWndOrient == OVER_UNDER ){ <br> <br>            DrvWndHeight = ( HIWORD(lParam) - <br>                           GetWindowLong(ghwndDrives, GWL_USERDATA) - <br>                           GetWindowLong(ghwndFunction, GWL_USERDATA) - <br>                           GetWindowLong(ghwndCommand, GWL_USERDATA) ) / 2; <br> <br>            MoveWindow(ghwndDrv1, <br>                        -1, <br>                        GetWindowLong(ghwndDrives, GWL_USERDATA)+ <br>                            GetWindowLong(ghwndFunction, GWL_USERDATA), <br>                        LOWORD(lParam) + 2, <br>                        DrvWndHeight, <br>                        TRUE); <br> <br>            MoveWindow(ghwndDrv2, <br>                        -1, <br>                        GetWindowLong(ghwndDrives, GWL_USERDATA)+ <br>                            GetWindowLong(ghwndFunction, GWL_USERDATA) + <br>                            DrvWndHeight, <br>                        LOWORD(lParam) + 2, <br>                        DrvWndHeight, <br>                        TRUE); <br>        } <br>        else{ <br> <br>            DrvWndHeight = HIWORD(lParam) - <br>                           GetWindowLong(ghwndDrives, GWL_USERDATA) - <br>                           GetWindowLong(ghwndFunction, GWL_USERDATA) - <br>                           GetWindowLong(ghwndCommand, GWL_USERDATA); <br> <br>            MoveWindow(ghwndDrv1, <br>                        -1, <br>                        GetWindowLong(ghwndDrives, GWL_USERDATA)+ <br>                            GetWindowLong(ghwndFunction, GWL_USERDATA), <br>                        LOWORD(lParam)/2 + 1, <br>                        DrvWndHeight, <br>                        TRUE); <br> <br>            MoveWindow(ghwndDrv2, <br>                        LOWORD(lParam)/2, <br>                        GetWindowLong(ghwndDrives, GWL_USERDATA)+ <br>                            GetWindowLong(ghwndFunction, GWL_USERDATA), <br>                        LOWORD(lParam)/2 + 1, <br>                        DrvWndHeight, <br>                        TRUE); <br>        } <br> <br>        return(1); <br>      } <br> <br>      case WM_DESTROY: { <br>        // <br>        // Close last drive thread handle, the global heap and it's corresponding critical section, <br>        //  the created font, and the Drive list critical section. <br>        // <br>        CloseHandle( ghDrvThread ); <br> <br>        EnterCriticalSection(&amp;gHeapCS); <br>        HeapDestroy(ghHeap); <br>        LeaveCriticalSection(&amp;gHeapCS); <br> <br>        DeleteObject(ghFont); <br> <br>        DeleteCriticalSection(&amp;gDrvCS); <br>        DeleteCriticalSection(&amp;gHeapCS); <br> <br>        PostQuitMessage(0); <br>        return(1); <br>      } <br> <br>      default: <br>        return DefWindowProc(hwnd, message, wParam, lParam); <br>    } <br>} <br> <br> <br>/***************************************************************************\ <br>* AboutProc <br>* <br>* About dialog proc. <br>* <br>* History: <br>*   05-13-92      Created. <br>\***************************************************************************/ <br> <br>LRESULT WINAPI AboutProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam) <br>{ <br>    switch (message) { <br>      case WM_INITDIALOG:{ <br>        return TRUE; <br>      } <br> <br>      case WM_COMMAND:{ <br>        if (wParam == IDOK) <br>            EndDialog(hDlg, wParam); <br>        break; <br>      } <br>    } <br> <br>    return FALSE; <br> <br>    UNREFERENCED_PARAMETER(lParam); <br>    UNREFERENCED_PARAMETER(hDlg); <br>} <br> <br> <br>/***************************************************************************\ <br>* <br>* DriveBarProc() <br>* <br>* Drive Toolbar procedure for displaying available drive Icons. <br>*  A bitmap button is displayed corresponding to the drive type of the <br>*  given drive, with the drive letter alongside. <br>*  ghwndDrives is the global handle assoc. w/ this window procedure. <br>* <br>* <br>* History: <br>* 6/9/92 <br>*   Created. <br>* <br>\***************************************************************************/ <br> <br>LRESULT WINAPI DriveBarProc (HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam) <br>{ <br>    static HBITMAP  hDrvBmp[NUM_BITMAPS]; <br>    static HBRUSH   hBrush;         // background brush <br>    static int      nDrvEntryWidth; // width of button/letter entry <br>    static int      yVal;           // y value in toolbar for top left of bmp <br>    static LPBINFO  lpDrvButtonRoot; <br>    static int      nActiveDrvIndex; <br>    TCHAR           lpBuffer[128]; <br> <br>    switch (message) <br>    { <br>        case WM_CREATE:{ <br>            HDC        hDC; <br>            HGDIOBJ    hOldFont; <br>            TEXTMETRIC tm; <br>            LONG       lHeight; <br> <br> <br>            lpDrvButtonRoot = NULL; <br> <br>            // <br>            // Load drive button bitmaps. <br>            // <br>            for(yVal = 0; yVal &lt; NUM_BITMAPS; yVal++) <br>                hDrvBmp[yVal] = LoadBitmap( ghModule, <br>                                      MAKEINTRESOURCE(UB_BMP_MARKER + yVal) ); <br> <br>            // <br>            // Sets background color of Toolbar non-modal dialog children. <br>            // <br>            hBrush = CreateSolidBrush(GetSysColor(COLOR_BTNSHADOW)); <br> <br>            hDC = GetDC(hwnd); <br> <br>            hOldFont = SelectObject(hDC, ghFont); <br>            GetTextMetrics(hDC, &amp;tm); <br>             <br>            // base the height of the window on size of text <br>            // Different display height is optimal if on a Japanese language system <br>            // <br>            if (PRIMARYLANGID(GetUserDefaultLangID()) == LANG_JAPANESE)  <br>                lHeight = tm.tmHeight + GetSystemMetrics(SM_CYBORDER) + 8; <br>            else  <br>                lHeight = tm.tmHeight + GetSystemMetrics(SM_CYBORDER) + 6; <br> <br>            // <br>            // saved the window height, drive button entry width <br>            //   and button y starting value for later reference <br>            // <br>            SetWindowLong(hwnd, GWL_USERDATA, lHeight); <br> <br>            // <br>            // Width of one button entry = spacing, button, sm. space, <br>            //   drive letter, spacing. <br>            // <br>            nDrvEntryWidth = DRIVE_BITMAP_SPACING + DRIVE_BITMAP_WIDTH + <br>                             DRIVE_LETTER_SPACING + tm.tmAveCharWidth + <br>                             DRIVE_BITMAP_SPACING; <br> <br>            // <br>            // Center bitmaps (by height) in drive toolbar. <br>            // <br>            yVal = (lHeight - DRIVE_BITMAP_HEIGHT)/2; <br> <br>            SelectObject(hDC, hOldFont); <br>            ReleaseDC(hwnd, hDC); <br> <br>            SendMessage(hwnd, WM_COMMAND, (WPARAM)MM_REFRESH, (LPARAM)NULL); <br> <br>            break; <br>        } <br> <br>        case WM_COMMAND:{ <br>            // <br>            // The button Identifiers for the drives are (potentially) <br>            // MM_DRIVE_NUM + 0 thru MM_DRIVE_NUM + 25. They all go to the <br>            // same case, so we will put the Menu ID in lParam, and <br>            // MM_DRIVE_NUM in LOWORD(wParam). <br>            // <br>            if( (LOWORD(wParam) - MM_DRIVE_NUM) &lt;= 25 &amp;&amp; <br>                (LOWORD(wParam) - MM_DRIVE_NUM) &gt;= 0 ){ <br>                lParam = LOWORD(wParam); <br>                wParam = MM_DRIVE_NUM; <br>            } <br> <br>            switch( LOWORD(wParam) ){ <br>              case MM_REFRESH:{ <br> <br>                LPDINFO lpWalk; <br>                LPBINFO lpBWalk, lpBHold; <br>                LPCINFO lpCInfo; <br>                int     xVal = 0; <br>                int     nCount = MM_DRIVE_NUM; <br>                TCHAR   lpBuffer[128]; <br> <br>                lpCInfo = (LPCINFO)GetWindowLong(ghActiveChild, GWL_USERDATA); <br> <br>                // <br>                // Wait for Drive Thread to complete, if necessary. <br>                // <br>                WaitForSingleObject(ghDrvThread, INFINITE); <br>                EnterCriticalSection(&amp;gDrvCS); <br> <br>                // <br>                // Traverse DRVINFO linked list, creating drive buttons and <br>                //   allocating corresp. structures as necessary. <br>                // <br>                lpWalk = glpDrives; <br>                lpBWalk = lpDrvButtonRoot; <br> <br>                while( lpWalk != NULL ){ <br>                    if( lpBWalk == NULL ){ //If at the end of the button list <br> <br>                        // Allocate a LPBINFO (button) structure <br>                        EnterCriticalSection(&amp;gHeapCS); <br>                        lpBWalk = (LPBINFO)HeapAlloc(ghHeap, 0, (DWORD)sizeof(BINFO) ); <br>                        LeaveCriticalSection(&amp;gHeapCS); <br> <br>                        // Create a button window <br>                        lpBWalk-&gt;hButton = (HANDLE)CreateWindow(TEXT("BUTTON"), <br>                                                 lpWalk-&gt;DriveName, <br>                                                 WS_CHILD | WS_VISIBLE | <br>                                                 BS_OWNERDRAW, <br>                                                 xVal + DRIVE_BITMAP_SPACING, <br>                                                 yVal, <br>                                                 DRIVE_BITMAP_WIDTH, <br>                                                 DRIVE_BITMAP_HEIGHT, <br>                                                 hwnd, <br>                                                 (HMENU)nCount, <br>                                                 ghModule, </code></pre>
<p>
</p>
<pre><code>NULL); <br> <br>                        // Insert structure into list <br>                        if( lpDrvButtonRoot == NULL) <br>                            lpDrvButtonRoot = lpBHold = lpBWalk; <br>                        else{ <br>                            lpBHold-&gt;next = lpBWalk; <br>                            lpBWalk-&gt;next = NULL; <br>                        } <br> <br>                    } <br> <br>                    // An LPBINFO (button) structure exists: now initialize <br> <br>                    // Set Title of Button (Drive Letter) <br>                    SetWindowText(lpBWalk-&gt;hButton, lpWalk-&gt;DriveName); <br> <br>                    // Set Child Window ID for Button <br>                    SetMenu( lpBWalk-&gt;hButton, (HMENU)nCount); <br> <br>                    // Determine button up/down status <br>                    if( lpCInfo-&gt;lpDriveInfo == lpWalk ){ <br>                        nActiveDrvIndex = nCount; <br>                        lpBWalk-&gt;fButtonDown = TRUE; <br>                    } <br>                    else <br>                        lpBWalk-&gt;fButtonDown = FALSE; <br> <br>                    // Set a pointer to the corresponding drive in Drive list <br>                    lpBWalk-&gt;lpDrive = lpWalk; <br> <br>                    nCount++; <br>                    xVal += nDrvEntryWidth; <br>                    lpBHold = lpBWalk; <br>                    lpBWalk = lpBWalk-&gt;next; <br> <br>                    lpWalk = lpWalk-&gt;next; <br>                } <br> <br>                LeaveCriticalSection(&amp;gDrvCS); <br> <br>                // <br>                // Free any remaining button windows. <br>                // <br>                while( lpBWalk != NULL ){ <br>                    // NULL out new end of list <br>                    lpBHold-&gt;next = NULL; <br> <br>                    // Assign pointer to doomed node <br>                    lpBHold = lpBWalk; <br>                    lpBWalk = lpBWalk-&gt;next; <br> <br>                    // Free doomed node resources <br>                    if( !DestroyWindow(lpBHold-&gt;hButton) ) { <br>                        LoadString(ghModule, IDS_DRVBUTTNERR, lpBuffer, sizeof(lpBuffer)); <br>                        ErrorMsg(lpBuffer); <br>                    } <br> <br>                    EnterCriticalSection(&amp;gHeapCS); <br>                    HeapFree(ghHeap, 0, (LPVOID)lpBHold); <br>                    LeaveCriticalSection(&amp;gHeapCS); <br>                } <br> <br>                SendMessage(hwnd, WM_PAINT, (WPARAM)NULL, (LPARAM)NULL); <br>                break; <br>              } <br> <br> <br>              // <br>              // switches the drive button to the newly active drv child's <br>              //   current drive.  Called by WM_MOUSEACTIVATE in DrvWndProc, <br>              //   as well as ChangeDrive. <br>              //   lParam contains the drive linked list pointer of the active <br>              //   drv child's LPCINFO struct. <br>              // <br>              case MM_ACTIVEDRV:{ <br>                LPBINFO lpBWalk = lpDrvButtonRoot; <br>                int     nCount = 0; <br> <br>                // <br>                // 'unpush' old active button <br>                // <br>                for( nCount = MM_DRIVE_NUM; nCount &lt; nActiveDrvIndex; nCount++) <br>                    lpBWalk = lpBWalk-&gt;next; <br>                lpBWalk-&gt;fButtonDown = FALSE; <br> <br>                InvalidateRect(lpBWalk-&gt;hButton, NULL, FALSE); <br> <br>                // <br>                // change active drive to new before redrawing old. <br>                //  'push' new active button <br>                // <br>                lpBWalk = lpDrvButtonRoot; <br>                nCount = MM_DRIVE_NUM; <br>                while( lpBWalk-&gt;lpDrive != (LPDINFO)lParam){ <br>                    lpBWalk = lpBWalk-&gt;next; <br>                    nCount++; <br>                } <br> <br>                nActiveDrvIndex = nCount; <br> <br>                lpBWalk-&gt;fButtonDown = TRUE; <br> <br>                InvalidateRect(lpBWalk-&gt;hButton, NULL, FALSE); <br> <br>                break; <br>              } <br> <br>              // <br>              // Changes drive of active child.  ButtonID in lParam. <br>              // <br>              case MM_DRIVE_NUM:{ <br> <br>                LPBINFO lpBWalk = lpDrvButtonRoot; <br>                int     nCount = 0; <br>                TCHAR    szDrvBuff[DIRECTORY_STRING_SIZE]; <br> <br>                // <br>                // if drive chosen is already current drive, leave. <br>                // <br>                if( nActiveDrvIndex == (int)lParam ) <br>                    break; <br> <br>                // <br>                // unpush' old active button <br>                // <br>                for( nCount = MM_DRIVE_NUM; nCount &lt; nActiveDrvIndex; nCount++) <br>                    lpBWalk = lpBWalk-&gt;next; <br>                lpBWalk-&gt;fButtonDown = FALSE; <br> <br>                // <br>                // change active drive to new before redrawing old. <br>                // <br>                nActiveDrvIndex = (int)lParam; <br> <br>                InvalidateRect(lpBWalk-&gt;hButton, NULL, FALSE); <br> <br>                // <br>                // 'push' new active button <br>                // <br>                lpBWalk = lpDrvButtonRoot; <br> <br>                for( nCount = MM_DRIVE_NUM; nCount &lt; nActiveDrvIndex; nCount++) <br>                    lpBWalk = lpBWalk-&gt;next; <br>                lpBWalk-&gt;fButtonDown = TRUE; <br> <br>                InvalidateRect(lpBWalk-&gt;hButton, NULL, FALSE); <br> <br>                GetWindowText(lpBWalk-&gt;hButton, szDrvBuff, <br>                              DIRECTORY_STRING_SIZE); <br> <br>                if( !ChangeDrive(szDrvBuff, (DWORD)nActiveDrvIndex) ){ <br>                    LoadString(ghModule, IDS_CHNGDRVERR, lpBuffer, sizeof(lpBuffer)); <br>                    ErrorMsg(lpBuffer); <br>                    return(0); <br>                } <br> <br>                break; <br>              } <br>            } <br>            return(1); <br>        } <br> <br>        // <br>        // Sent by all created buttons for initialization purposes. <br>        // <br>        case WM_MEASUREITEM:{ <br>            LPMEASUREITEMSTRUCT lpMIS; <br> <br>            lpMIS = (LPMEASUREITEMSTRUCT)lParam; <br> <br>            lpMIS-&gt;CtlType = ODT_BUTTON; <br>            lpMIS-&gt;CtlID = (UINT)wParam; <br>            lpMIS-&gt;itemWidth = DRIVE_BITMAP_WIDTH; <br>            lpMIS-&gt;itemHeight = DRIVE_BITMAP_HEIGHT; <br> <br>            return(1); <br>        } <br> <br>        // <br>        // Sent by owner draw drive buttons when needing redrawing. <br>        // <br>        case WM_DRAWITEM:{ <br>            LPBINFO lpBWalk = lpDrvButtonRoot; <br>            int     nCount; <br>            int     nBmpIndex; <br>            HDC     hDC; <br>            HDC     hCompatDC; <br>            HGDIOBJ hOldBitmap; <br>            TCHAR    szDrvBuff[DIRECTORY_STRING_SIZE]; <br>            LPDRAWITEMSTRUCT    lpDIS; <br> <br>            lpDIS = (LPDRAWITEMSTRUCT)lParam; <br> <br>            for( nCount = MM_DRIVE_NUM; nCount &lt; (int)wParam; nCount++) <br>                lpBWalk = lpBWalk-&gt;next; <br> <br>            // <br>            // If not the current selected button, handle button stuff. <br>            // <br>            if( (int)wParam != nActiveDrvIndex ){ <br>                // <br>                // mousebutton is down... <br>                // <br>                if( lpDIS-&gt;itemAction &amp; ODA_SELECT ){ <br>                    // <br>                    // left button region, 'unpush' button <br>                    // <br>                    if( lpDIS-&gt;itemState == (UINT)ODS_FOCUS ) <br>                        lpBWalk-&gt;fButtonDown = FALSE; <br>                    // <br>                    // clicked on a button, draw 'pushed' button <br>                    // <br>                    if( lpDIS-&gt;itemState == (UINT)(ODS_SELECTED | ODS_FOCUS)) <br>                        lpBWalk-&gt;fButtonDown = TRUE; <br>                } <br>            } <br> <br>            // <br>            // draw current state of button. <br>            // <br>            GetWindowText(lpDIS-&gt;hwndItem, szDrvBuff, <br>                          DIRECTORY_STRING_SIZE); <br> <br>            szDrvBuff[1] = TEXT('\0'); <br> <br>            hCompatDC = CreateCompatibleDC(lpDIS-&gt;hDC); <br>            hOldBitmap = CreateCompatibleBitmap(hCompatDC, <br>                                                DRIVE_BITMAP_WIDTH, <br>                                                DRIVE_BITMAP_HEIGHT); <br> <br>            nBmpIndex = GetDriveBitmap(lpBWalk); <br> <br>            SelectObject( hCompatDC, hDrvBmp[nBmpIndex] ); <br> <br>            if( !hOldBitmap ) { <br>                LoadString(ghModule, IDS_SELOBJERR, lpBuffer, sizeof(lpBuffer)); <br>                ErrorMsg(lpBuffer); <br>            } <br>            if( !BitBlt(lpDIS-&gt;hDC, lpDIS-&gt;rcItem.left, lpDIS-&gt;rcItem.top, <br>                   DRIVE_BITMAP_WIDTH, <br>                   DRIVE_BITMAP_HEIGHT, <br>                   hCompatDC, 0, 0, SRCCOPY) ) { <br>                LoadString(ghModule, IDS_BITBLTERR, lpBuffer, sizeof(lpBuffer)); <br>                ErrorMsg(lpBuffer); <br>            } <br> <br>            SelectObject( hCompatDC, hOldBitmap); <br>            DeleteDC(hCompatDC); <br> <br>            hDC = GetDC(hwnd); <br>            SetBkMode(hDC, TRANSPARENT); <br>            SetTextColor(hDC, GetSysColor(COLOR_BTNTEXT) ); <br>            SetBkColor(hDC, GetSysColor(COLOR_BTNSHADOW) ); <br> <br>            // Allow for a different aesthetic for Japanese systems <br>            if (GetUserDefaultLangID() == LANG_JAPANESE)  <br>                TextOut(hDC, <br>                        ((int)(wParam - MM_DRIVE_NUM) * nDrvEntryWidth) + <br>                            DRIVE_BITMAP_SPACING + DRIVE_BITMAP_WIDTH + <br>                            DRIVE_LETTER_SPACING, <br>                        GetSystemMetrics(SM_CYBORDER)/2, <br>                        szDrvBuff, 1); <br>            else <br>                TextOut(hDC, <br>                        ((int)(wParam - MM_DRIVE_NUM) * nDrvEntryWidth) + <br>                            DRIVE_BITMAP_SPACING + DRIVE_BITMAP_WIDTH + <br>                            DRIVE_LETTER_SPACING, <br>                        (GetSystemMetrics(SM_CYBORDER) + 6)/2, <br>                        szDrvBuff, 1); <br> <br>            SetBkMode(hDC, OPAQUE); <br> <br>            ReleaseDC(hwnd, hDC); <br> <br>            break; <br>        } <br> <br> <br>        case WM_PAINT:{ <br>            HDC     hCompatDC; <br>            RECT     rc; <br>            PAINTSTRUCT ps; <br> <br>            // <br>            // Paint btnshadow background. <br>            // <br>            GetClientRect(hwnd, &amp;rc); <br> <br>            BeginPaint(hwnd, &amp;ps); <br> <br>            hCompatDC = CreateCompatibleDC(ps.hdc); <br>            FillRect(ps.hdc, &amp;rc, hBrush); <br> <br>            EndPaint(hwnd, &amp;ps); <br> <br>            return(TRUE); <br>        } <br> <br>        case WM_DESTROY:{ <br>            DeleteObject(hBrush); <br> <br>            for(yVal = 0; yVal &lt; NUM_BITMAPS; yVal++) <br>                DeleteObject(hDrvBmp[yVal]); <br> <br>            break; <br>        } <br>    } <br>    return DefWindowProc(hwnd, message, wParam, lParam); <br>} <br> <br> <br>/***************************************************************************\ <br>* <br>* GetDriveBitmap() <br>* <br>* Determines the appropriate index into the drive button bitmap array <br>*   (hDrvBmp[]), given a pointer to a drive info structure (LPDINFO) <br>* <br>*   lpWalk          -   pointer to LPDINFO structure. <br>*   lpCurrentDrv    -   pointer to current drive of active child. <br>* <br>* <br>* History: <br>* 6/16/92 <br>*   Created. <br>* <br>\***************************************************************************/ <br>int GetDriveBitmap(LPBINFO lpBWalk) <br>{ <br>    int nBmpIndex; <br> <br>    EnterCriticalSection(&amp;gDrvCS); <br> <br>    switch( lpBWalk-&gt;lpDrive-&gt;DriveType ){ <br>        case DRIVE_REMOVABLE:{ <br>          nBmpIndex = UB_FLOPPY1 - UB_BMP_MARKER; <br>          break; <br>        } <br> <br>        case DRIVE_REMOTE:{ <br>          nBmpIndex = UB_REMOTE1 - UB_BMP_MARKER; <br>            break; <br>        } <br> <br>        case DRIVE_CDROM:{ <br>          nBmpIndex = UB_CD1 - UB_BMP_MARKER; <br>            break; <br>        } <br> <br>        case DRIVE_FIXED: <br>        default:{ <br>          nBmpIndex = UB_FIXED1 - UB_BMP_MARKER; <br>            break; <br>        } <br>    } <br> <br>    LeaveCriticalSection(&amp;gDrvCS); <br> <br>    if( lpBWalk-&gt;fButtonDown == TRUE ) <br>        nBmpIndex++; <br> <br>    return(nBmpIndex); <br>} <br> <br> <br>/***************************************************************************\ <br>* <br>* ChangeDrive() <br>* <br>*   Changes the current drive of the active child.  Called by the MM_DRIVE_NUM <br>*     cases in MainWndProc and DriveBarProc.  This is caused by choosing a <br>*     Drive menu item or selecting a drive button from the drive toolbar. <br>* <br>*     lpszDriveName -   points to a buffer containing the name of the drive <br>*     DriveID       -   points to the ID of the Menu item or button, which <br>*                         corresponds to the index into the drives linked list <br>*                         of the new drive. <br>* <br>* History: <br>* 6/20/92 <br>*   Created. <br>* <br>\***************************************************************************/ <br>BOOL ChangeDrive(LPTSTR lpszDriveName, DWORD DriveIndex) <br>{ <br>    LPCINFO     lpCInfo; <br>    LPDINFO     lpWalk; <br>    DWORD       dwLoop; <br>    UINT        nDriveType; <br>    TCHAR       lpBuffer[128]; <br> <br>    // <br>    // Retrieve active child handle. <br>    // <br>    if( (ghActiveChild != ghwndDrv1) &amp;&amp; <br>        (ghActiveChild != ghwndDrv2) ){ <br>        LoadString(ghModule, IDS_DRVNOTACTVE, lpBuffer, sizeof(lpBuffer)); <br>        ErrorMsg(lpBuffer); <br>        return(0); <br>    } <br> <br>    // <br>    // Retrieving the child window's DRVCHILDINFO data <br>    // <br>    lpCInfo = (LPCINFO)GetWindowLong(ghActiveChild, GWL_USERDATA); <br> <br>    // <br>    // Enter Drive list critical section <br>    // <br>    EnterCriticalSection(&amp;gDrvCS); <br> <br>    // <br>    // if removable drive, check for existing media. <br>    // <br>    nDriveType = GetDriveType(lpszDriveName); <br>    if( nDriveType == DRIVE_REMOVABLE || <br>        nDriveType == DRIVE_CDROM ){ <br>        dwLoop = (DWORD)IDOK; <br> <br>        LoadString(ghModule, IDS_INSRTMEDIA, lpBuffer, sizeof(lpBuffer)); <br> <br>        while( !CheckRM(lpszDriveName) &amp;&amp; (dwLoop == (DWORD)IDOK) ){ <br>           dwLoop = (DWORD)MessageBox(ghwndMain, lpBuffer, lpszDriveName, MB_OKCANCEL); <br>        } <br> <br>        if( dwLoop == (DWORD)IDCANCEL ){ <br>            SendMessage(ghwndDrives, WM_COMMAND, MM_ACTIVEDRV, <br>                        (LPARAM)lpCInfo-&gt;lpDriveInfo); <br>        LeaveCriticalSection(&amp;gDrvCS); <br>            return(0); <br>        } <br>    } <br> <br>    // <br>    // set lpDriveInfo member to associated drive struct. <br>    // <br>    lpWalk = glpDrives; <br>    for( dwLoop = 0; dwLoop &lt; DriveIndex - MM_DRIVE_NUM; <br>         dwLoop++) <br>         lpWalk = lpWalk-&gt;next; <br> <br>    lpCInfo-&gt;lpDriveInfo = lpWalk; <br> <br>    lstrcpy(lpCInfo-&gt;CaptionBarText, lpWalk-&gt;DriveName); <br> <br>    LeaveCriticalSection(&amp;gDrvCS); <br> <br>    // <br>    // This will terminate any currently running drive thread. <br>    // <br>    SendMessage(ghActiveChild, WM_COMMAND, MM_ESCAPE, (LPARAM)0); <br>    lpCInfo-&gt;fEscape = FALSE; <br> <br>    // <br>    // enact the drive change. <br>    // <br>    PostMessage(ghActiveChild, WM_COMMAND, MM_REFRESH, (LPARAM)0); <br> <br>    return(1); <br>} <br> <br> <br>/***************************************************************************\ <br>* <br>* FunctionBarProc <br>* <br>* ToolBar Window procedure for displaying File I/O functions. <br>*   ghwndFunction is the global handle assoc. w/ this Dlg procedure. <br>* <br>* History: <br>* 6/8/92 <br>*   Created. <br>* <br>\***************************************************************************/ <br>LRESULT WINAPI FunctionBarProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam) <br>{ <br>    static HBRUSH   hBrush; <br> <br>    switch (message){ <br>      case WM_INITDIALOG:{ <br>        HWND    hButton; <br>        RECT     rc; <br> <br>        hButton = GetDlgItem(hDlg, MM_COPY); <br> <br>        GetWindowRect(hButton, &amp;rc); <br> <br>        SetWindowLong(hDlg, GWL_USERDATA, rc.bottom - rc.top); <br> <br>        // <br>        // Sets background color of Toolbar non-modal dialog children. <br>        // <br>        hBrush = CreateSolidBrush(GetSysColor(COLOR_BTNSHADOW)); <br> <br>        return(FALSE); <br>      } <br> <br>      case WM_PAINT:{ <br>        RECT     rc; <br>        PAINTSTRUCT ps; <br> <br>        // <br>        // Paint btnshadow background. <br>        // <br>        GetClientRect(hDlg, &amp;rc); <br>        InvalidateRect(hDlg, &amp;rc, FALSE); <br> <br>        BeginPaint(hDlg, &amp;ps); <br> <br>        FillRect(ps.hdc, &amp;rc, hBrush); <br> <br>        EndPaint(hDlg, &amp;ps); <br> <br>        return(TRUE); <br>      } <br> <br>      // <br>      // Passes button messages ( = file I/O function messages ) <br>      //   to active Drv child. <br>      // <br>      case WM_COMMAND:{ <br>        switch(wParam){ <br>          case MM_COPY: <br>          case MM_MOVE: <br>          case MM_DELETE: <br>          case MM_RENAME: <br>          case MM_MKDIR:{ <br>            SendMessage(ghActiveChild, message, wParam, lParam); <br>            return(TRUE); <br>          } <br>        } <br>      } <br> <br>      case WM_DESTROY:{ <br>          DeleteObject(hBrush); <br>          break; <br>      } <br>    } <br> <br>    return(FALSE); <br>} <br> <br> <br>/***************************************************************************\ <br>* <br>* RunCommandItem() <br>* <br>* <br>* History: <br>* 5/26/93 <br>*   Created. <br>* <br>\***************************************************************************/ <br>BOOL RunCommandItem(LPCINFO lpCInfo) <br>{ <br>    TCHAR       szCmdLine[DIRECTORY_STRING_SIZE * 2] = TEXT("cmd "); <br>    LPTSTR      lpszHold; <br>    TCHAR       lpBuffer[128]; <br> <br>    STARTUPINFO si; <br>    PROCESS_INFORMATION pi; <br> <br>    // <br>    // Add the CMD.EXE parameter to keep or kill cmd sessions when done. <br>    // <br>    if( gfKeepCommandWin ) <br>        lstrcat( szCmdLine, TEXT("/k ") ); <br>    else <br>        lstrcat( szCmdLine, TEXT("/c ") ); <br> <br>    // <br>    // Add command line edit control text. <br>    // <br>    lpszHold = TStrChr(szCmdLine, TEXT('\0')); <br> <br>    if( SendMessage( ghwndCommand, WM_GETTEXT, <br>                            DIRECTORY_STRING_SIZE, <br>                            (LPARAM)lpszHold) == LB_ERR ){ <br>        LoadString(ghModule, IDS_SRCSTRNGERR, lpBuffer, sizeof(lpBuffer)); <br>        ErrorMsg(lpBuffer); <br>        return(0); <br>    } <br> <br>    // <br>    // Attempt to spawn command shell with entry as parameter. <br>    // <br>    si.cb = sizeof(STARTUPINFO); <br>    si.lpReserved = NULL; <br>    si.lpDesktop = NULL; <br>    si.lpTitle = NULL; <br>    si.dwFlags = 0; <br>    si.cbReserved2 = 0; <br>    si.lpReserved2 = NULL; <br> <br>    SetThreadPriority( GetCurrentThread(), THREAD_PRIORITY_HIGHEST); <br> <br>    if( !CreateProcess(NULL, (LPTSTR)szCmdLine, NULL, NULL, FALSE, <br>                       CREATE_NEW_CONSOLE | NORMAL_PRIORITY_CLASS, <br>                       NULL, lpCInfo-&gt;CaptionBarText, &amp;si, &amp;pi) ){ <br>        LoadString(ghModule, IDS_CANTSPAWN, lpBuffer, sizeof(lpBuffer)); <br>        ErrorMsg(lpBuffer); <br>        return(0); <br>    } <br> <br>    CloseHandle( pi.hProcess ); <br>    CloseHandle( pi.hThread ); <br> <br>    SetThreadPriority( GetCurrentThread(), THREAD_PRIORITY_NORMAL); <br> <br>    return(1); <br>} <br> <br> <br>/***************************************************************************\ <br>* <br>* UpdateDrivesMenu() <br>* <br>* Adds current drives from the glpDrives linked list to the TEXT('Drives') menu <br>* <br>* Input: hDrivesMenu - handle to TEXT('Drives') Menu <br>*        hThread    - used to wait for drives thread to terminate <br>* <br>* History: <br>* 5/14/92 <br>*   Created. <br>* <br>\***************************************************************************/ <br>BOOL UpdateDrivesMenu(HMENU hMenu, HANDLE hThread) <br>{ <br>    HMENU   hDrivesMenu; <br>    int     NumMenuItems; <br>    DWORD   dwLoop; <br>    LPDINFO lpWalk; <br>    TCHAR   lpBuffer[128]; <br> <br>    // <br>    // Remove list of drive menu items from Drive menu, if any. <br>    // <br>    hDrivesMenu = GetSubMenu( hMenu, DRIVE_MENU_NUM); <br>    if( !hDrivesMenu ){ <br>        LoadString(ghModule, IDS_MENUERR1, lpBuffer, sizeof(lpBuffer)); <br>        ErrorMsg(lpBuffer); <br>        return(FALSE); <br>    } <br> <br>    if( (NumMenuItems = GetMenuItemCount(hDrivesMenu)) == -1) { <br>        LoadString(ghModule, IDS_MENUERR2, lpBuffer, sizeof(lpBuffer)); <br>        ErrorMsg(lpBuffer); <br>    } <br> <br>    // <br>    // Delete previous menu items. <br>    // <br>    for( dwLoop = 0; dwLoop &lt; (DWORD)NumMenuItems; dwLoop++) <br>        if( !DeleteMenu( hDrivesMenu, 0, <br>                         MF_BYPOSITION) ){ <br>            LoadString(ghModule, IDS_MENUERR3, lpBuffer, sizeof(lpBuffer)); <br>            ErrorMsg(lpBuffer); <br>            return(FALSE); <br>        } <br> <br>    // <br>    // Wait for Enumdrv Thread to terminate, and <br>    //   enter drive list critical section <br>    // <br>    WaitForSingleObject(hThread, INFINITE); <br>    EnterCriticalSection(&amp;gDrvCS); <br> <br>    // <br>    // Fill drive menu from glpDrives linked list <br>    // <br>    NumMenuItems = 0; <br>    lpWalk = glpDrives; <br> <br>    while(lpWalk != NULL){ <br>        if( !InsertMenu( hDrivesMenu, NumMenuItems, MF_STRING | <br>            MF_BYPOSITION | MF_ENABLED, MM_DRIVE_NUM + NumMenuItems, <br>            lpWalk-&gt;DriveName)) { <br>            LoadString(ghModule, IDS_MENUERR4, lpBuffer, sizeof(lpBuffer));             <br>            ErrorMsg(lpBuffer); <br>        } <br>        NumMenuItems++; <br>        lpWalk = lpWalk-&gt;next; <br>    } <br> <br>    LeaveCriticalSection(&amp;gDrvCS); <br> <br>    return(TRUE); <br>} <br> <br> <br>/***************************************************************************\ <br>* <br>* ErrorMsg() <br>* <br>*   Displays a Message Box with a given error message. <br>* <br>* History: <br>* 5/28/92 <br>*   Created. <br>* <br>\***************************************************************************/ <br>void ErrorMsg(LPTSTR szMsg) <br>{ <br>    TCHAR szHold[DIRECTORY_STRING_SIZE + 1]; <br> <br>    lstrcpy( szHold, szMsg ); <br>    lstrcat( szHold, TEXT("\n") ); <br> <br>    OutputDebugString(szHold); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
