<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>ENUMDRV.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5996"></a>ENUMDRV.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples.  <br>*       Copyright 1993 - 1998 Microsoft Corporation. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>/**************************************************************************** <br>* <br>*    PROGRAM: Enumdrv.C <br>* <br>*    PURPOSE: Determines all drives in the system, both local and remote, <br>*             and their file system type <br>* <br>****************************************************************************/ <br>#define  STRICT <br>#include &lt;windows.h&gt; <br>#include "globals.h" <br>#include "filer.h" <br>#include "enumdrv.h" <br> <br>extern HANDLE           ghHeap;  // Handle to global heap, declared in FILER.C <br>extern CRITICAL_SECTION gHeapCS;  // Global heap critical section var. <br>extern CRITICAL_SECTION gDrvCS;  // Drive list critical section var. <br>extern LPDINFO          glpDrives; <br>extern HANDLEghModule;  // Global Instance handle, declared in FILER.C <br> <br>/**************************************************************************** <br>* <br>*    FUNCTION: CheckRM(LPTSTR) <br>* <br>*    PURPOSE: Verifies that a removeable media drive contains a disk <br>* <br>*    COMMENTS: <br>* <br>*        This function is called each time a drive type is determined to be <br>*        removeable (DRIVE_REMOVEABLE).  An attempt is made to open a <br>*        file in the root directory of the drive.  If the attempt succeeds, <br>*        then media is present in the drive and subsequent calls to the <br>*        drive can be safely made.  If the call fails, then there is no media <br>*        present in the drive and no attempts should be made to access this <br>*        drive.  The Error Mode is temporarily set to 1 to allow failures <br>*        to immediately return to the calling program.  This eliminates <br>*        unwanted dialog boxes that prompt for disks to be placed in the <br>*        drive. <br>* <br>*    INPUT: szDriveName - removeable media drive name (ex - "a:") <br>* <br>*    OUTPUT: Returns TRUE if media present <br>*                    FALSE if media is not present <br>* <br>****************************************************************************/ <br> <br>BOOL CheckRM( LPTSTR lpszDriveName ) <br>{ <br>    TCHAR    szFileName[DIRECTORY_STRING_SIZE]; <br>    DWORD    dwHold; <br> <br>    SetErrorMode( SEM_FAILCRITICALERRORS ); <br> <br>    lstrcpy( szFileName, lpszDriveName ); <br>    lstrcat( szFileName, TEXT(".") ); <br> <br>    dwHold = GetFileAttributes( szFileName ); <br> <br>    SetErrorMode( 0 ); <br> <br>    //  If no error, media must be in drive. <br>    if( dwHold != 0xFFFFFFFF ){ <br>        return(TRUE); <br>    } <br>    else{ <br>        dwHold = GetLastError(); <br>        if( dwHold != ERROR_NOT_READY ) <br>            ErrorMsg(TEXT("CheckRM: Get Removable Media Info Failure.")); <br> <br>        return(FALSE); <br>    } <br> <br>} <br> <br> <br>/**************************************************************************** <br>* <br>*    FUNCTION: DWORD EnumDrives(*LPDINFO) <br>* <br>*    PURPOSE: Enumerates available drives, and information on them. If the <br>*               DINFO structure passed in is NULL, it creates a linked list <br>*               of DINFO structures, reporting information on each available <br>*               drive.  If DINFO points to an existing structure, the list <br>*               is updated. <br>* <br>*    COMMENTS: <br>*        The number of available drives is first determined by a call to <br>*        GetLogicalDrives.  This provides a bit mask of all logical drives. <br>* <br>*        For each logical drive, a call is made to GetDriveType to determine <br>*        the drive type.  If the logical drive is not in the bit mask that <br>*        was created with the GetLogicalDrives call, then this drive is <br>*        bypassed. <br>* <br>*        GetVolumeInformation is used to determine the file syste for the <br>*        logical drive. If the drive type is removable, a check must be made <br>*        to see if the drive contains a disk. If the remote drive contains a <br>*        disk, then it is safe to proceed with the GetVolumeInformation call. <br>* <br>*    INPUT:  LPDINFO dINfo: A pointer to a DRVINFO Structure. <br>* <br>*    OUTPUT: Returns the number of DINFO structures in the linked <br>*            list pointed to by dInfo.  Value is negative if error. <br>* <br>\****************************************************************************/ <br> <br>void EnumDrives(LPDINFO *lplpRoot) <br>{ <br>  DWORD         dwDriveMask; <br>  DWORD         dwCount; <br>  LPTSTR        lpszRootPathName=TEXT("?:\\"); <br>  TCHARlpBuffer[128]; <br> <br>  static LPTSTR lpDriveStrings = NULL; <br>  LPTSTR        lpParse; <br> <br>  LPDINFO       lpDInfo,                // new node ptr <br>                lpHold,                 // list walking ptrs <br>                lpBack, <br>                lpRoot = *lplpRoot;     // root ptr <br> <br> <br>  EnterCriticalSection(&amp;gDrvCS); <br> <br>  // <br>  // Free old drive strings; <br>  // With a buffer size of 0, the first call returns the size of buffer needed. <br>  // <br>  if(lpDriveStrings != NULL){ <br>    EnterCriticalSection(&amp;gHeapCS); <br>    HeapFree( ghHeap, 0, lpDriveStrings); <br>    LeaveCriticalSection(&amp;gHeapCS); <br>  } <br> <br>  dwCount=GetLogicalDriveStrings( 0, lpDriveStrings); <br>  if( !dwCount ){ <br>LoadString(ghModule, IDS_ENUMDRVERR, lpBuffer, sizeof(lpBuffer)); <br>    LeaveCriticalSection(&amp;gDrvCS); <br>    ErrorMsg(lpBuffer); <br>    ExitThread((DWORD)-1); <br>  } <br> <br>  EnterCriticalSection(&amp;gHeapCS); <br>  // allocate memory, +1 for trailing NULL <br>  lpDriveStrings = (LPTSTR)HeapAlloc( ghHeap, 0, (dwCount + 1) * sizeof(TCHAR) ); <br>  LeaveCriticalSection(&amp;gHeapCS); <br> <br>  if( lpDriveStrings == NULL){ <br>      LeaveCriticalSection(&amp;gDrvCS); <br>  LoadString(ghModule, IDS_ENUMALOCERR, lpBuffer, sizeof(lpBuffer)); <br>      ErrorMsg(lpBuffer); <br>      ExitThread((DWORD)-2); <br>  } <br> <br>  if(dwCount &lt; GetLogicalDriveStrings( dwCount, lpDriveStrings) ){ <br>      LeaveCriticalSection(&amp;gDrvCS); <br>  LoadString(ghModule, IDS_ENUMSTRERR, lpBuffer, sizeof(lpBuffer)); <br>      ErrorMsg(lpBuffer); <br>      ExitThread((DWORD)-3); <br>  } <br>  lpParse = lpDriveStrings; <br> <br>  dwDriveMask=GetLogicalDrives(); <br> <br>  // <br>  // walk list, inserting, deleting, &amp; updating nodes as necessary <br>  // <br>  dwCount = 0; <br>  lpHold = lpBack = lpRoot; <br> <br>  for (*lpszRootPathName=TEXT('a');*lpszRootPathName&lt;=TEXT('z');(*lpszRootPathName)++){ <br>    if (dwDriveMask &amp; 1){   // drive exists. Insert or update. <br> <br>      dwCount++; <br> <br>      // <br>      // if lpHold (the list walking ptr) is NULL, or the drive that exists <br>      //  does not already have a node in the list, allocate a node. <br>      // <br>      if( !lpHold || lpHold-&gt;DriveLetter &gt; *lpszRootPathName ){ <br>        // <br>        // Allocating memory for DRVINFO node <br>        // <br>        EnterCriticalSection(&amp;gHeapCS); <br>        lpDInfo = (LPDINFO) HeapAlloc( ghHeap, 0, (DWORD)sizeof(DRVINFO) ); <br>        LeaveCriticalSection(&amp;gHeapCS); <br>        if( lpDInfo == NULL){ <br>          LeaveCriticalSection(&amp;gDrvCS); <br>  LoadString(ghModule, IDS_DRVALOCERR, lpBuffer, sizeof(lpBuffer)); <br>          ErrorMsg(lpBuffer); <br>          ExitThread((DWORD)-4); <br>        } <br> <br>        // <br>        // insert new node into list <br>        // <br>        if( lpHold == lpRoot ){ <br>          lpDInfo-&gt;next = lpRoot; <br>          lpRoot = lpDInfo; <br>        } <br>        else{ <br>          lpDInfo-&gt;next = lpBack-&gt;next; <br>          lpBack-&gt;next = lpDInfo; <br>        } <br> <br>        lpBack = lpDInfo; <br>        lpHold = lpDInfo-&gt;next; <br> <br>        lpDInfo-&gt;DriveLetter = *lpszRootPathName; <br>      } <br>      else{ <br>        if( lpBack != lpHold ) <br>          lpBack = lpBack-&gt;next; <br>        lpHold = lpHold-&gt;next; <br>      } <br> <br>      lpBack-&gt;DriveType = GetDriveType(lpszRootPathName); <br>      if( lpBack-&gt;DriveType == DRIVE_REMOVABLE || <br>          lpBack-&gt;DriveType == DRIVE_CDROM ) <br>        if( CheckRM(lpszRootPathName ) ) <br>          if( !GetVolumeInformation(lpszRootPathName,NULL,0,NULL,NULL,NULL, <br>                                   (LPTSTR)lpBack-&gt;FileSystem, <br>                                   (DWORD)FILE_SYSTEM_STRING_SIZE) ) <br>            lstrcpy(lpBack-&gt;FileSystem, TEXT("UNKNOWN")); <br>          else; <br>        else      // no removable media <br>          lstrcpy(lpBack-&gt;FileSystem, TEXT("UNKNOWN")); <br>      else        // not removable <br>        if( !GetVolumeInformation(lpszRootPathName,NULL,0,NULL,NULL,NULL, <br>                                  (LPTSTR)lpBack-&gt;FileSystem, <br>                                  (DWORD)FILE_SYSTEM_STRING_SIZE) ) <br>          lstrcpy(lpBack-&gt;FileSystem, TEXT("UNKNOWN")); <br>        else; <br> <br>      lpBack-&gt;DriveName = lpParse; <br>      lpParse += lstrlen(lpParse)+1; <br>    } <br>    else{               // drive does not exist. <br>      if( lpHold )      //   if node exists, delete it. <br>        if( lpHold-&gt;DriveLetter == *lpszRootPathName ){ <br>          if( lpHold == lpRoot ) <br>            lpRoot = lpBack = lpHold-&gt;next; <br>          else <br>            lpBack-&gt;next = lpHold-&gt;next; <br> <br>          EnterCriticalSection(&amp;gHeapCS); <br>          HeapFree(ghHeap, 0, (LPVOID)lpHold); <br>          LeaveCriticalSection(&amp;gHeapCS); <br> <br>          lpHold = lpBack-&gt;next; <br>        } <br>    } <br>    dwDriveMask &gt;&gt;= 1; <br> <br>  } // end for <br> <br>  *lplpRoot = lpRoot; <br> <br>  LeaveCriticalSection(&amp;gDrvCS); <br> <br>  ExitThread(dwCount); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
