<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>TTY.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6009"></a>TTY.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples. <br>*       Copyright 1993 - 1998 Microsoft Corporation. <br>*       All rights reserved. <br>*       This source code is only intended as a supplement to <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>//--------------------------------------------------------------------------- <br>// <br>//  Module: tty.c <br>// <br>//  Purpose: <br>//     The sample application demonstrates the usage of the COMM <br>//     API.  It implements the new COMM API of Windows 3.1. <br>// <br>//     NOTE:  no escape sequences are translated, only <br>//            the necessary control codes (LF, CR, BS, etc.) <br>// <br>//  Description of functions: <br>//     Descriptions are contained in the function headers. <br>// <br>//--------------------------------------------------------------------------- <br>// <br>//  Written by Microsoft Product Support Services, Windows Developer Support. <br>// <br>//--------------------------------------------------------------------------- <br> <br>#include "tty.h" <br> <br>//--------------------------------------------------------------------------- <br>//  int PASCAL WinMain( HANDLE hInstance, HANDLE hPrevInstance, <br>//                      LPSTR lpszCmdLine, int nCmdShow ) <br>// <br>//  Description: <br>//     This is the main window loop! <br>// <br>//  Parameters: <br>//     As documented for all WinMain() functions. <br>// <br>//--------------------------------------------------------------------------- <br> <br>int PASCAL WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, <br>                    LPSTR lpszCmdLine, int nCmdShow ) <br>{ <br>   MSG   msg ; <br> <br>   if (!hPrevInstance) <br>      if (!InitApplication( hInstance )) <br>         return ( FALSE ) ; <br> <br>   if (NULL == (hTTYWnd = InitInstance( hInstance, nCmdShow ))) <br>      return ( FALSE ) ; <br> <br>   while (GetMessage( &amp;msg, NULL, 0, 0 )) <br>   { <br>      if (!TranslateAccelerator( hTTYWnd, ghAccel, &amp;msg )) <br>      { <br>         TranslateMessage( &amp;msg ) ; <br>         DispatchMessage( &amp;msg ) ; <br>      } <br>   } <br>   return ( (int) msg.wParam ) ; <br> <br>} // end of WinMain() <br> <br>//--------------------------------------------------------------------------- <br>//  BOOL NEAR InitApplication( HANDLE hInstance ) <br>// <br>//  Description: <br>//     First time initialization stuff.  This registers information <br>//     such as window classes. <br>// <br>//  Parameters: <br>//     HANDLE hInstance <br>//        Handle to this instance of the application. <br>// <br>//--------------------------------------------------------------------------- <br> <br>BOOL NEAR InitApplication( HANDLE hInstance ) <br>{ <br>   WNDCLASS  wndclass ; <br> <br>   // register tty window class <br> <br>   wndclass.style =         0 ; <br>   wndclass.lpfnWndProc =   TTYWndProc ; <br>   wndclass.cbClsExtra =    0 ; <br>   wndclass.cbWndExtra =    TTYEXTRABYTES ; <br>   wndclass.hInstance =     hInstance ; <br>   wndclass.hIcon =         LoadIcon( hInstance, MAKEINTRESOURCE( TTYICON ) ); <br>   wndclass.hCursor =       LoadCursor( NULL, IDC_ARROW ) ; <br>   wndclass.hbrBackground = (HBRUSH) (COLOR_WINDOW + 1) ; <br>   wndclass.lpszMenuName =  MAKEINTRESOURCE( TTYMENU ) ; <br>   wndclass.lpszClassName = gszTTYClass ; <br> <br>   return( RegisterClass( &amp;wndclass ) ) ; <br> <br>} // end of InitApplication() <br> <br>//--------------------------------------------------------------------------- <br>//  HWND NEAR InitInstance( HANDLE hInstance, int nCmdShow ) <br>// <br>//  Description: <br>//     Initializes instance specific information. <br>// <br>//  Parameters: <br>//     HANDLE hInstance <br>//        Handle to instance <br>// <br>//     int nCmdShow <br>//        How do we show the window? <br>// <br>//--------------------------------------------------------------------------- <br> <br>HWND NEAR InitInstance( HANDLE hInstance, int nCmdShow ) <br>{ <br>   HWND  hTTYWnd ; <br> <br>   // load accelerators <br>   ghAccel = LoadAccelerators( hInstance, MAKEINTRESOURCE( TTYACCEL ) ) ; <br> <br>   // create the TTY window <br>   hTTYWnd = CreateWindow( gszTTYClass, gszAppName, <br>                           WS_OVERLAPPEDWINDOW, <br>                           CW_USEDEFAULT, CW_USEDEFAULT, <br>                           CW_USEDEFAULT, CW_USEDEFAULT, <br>                           NULL, NULL, hInstance, NULL ) ; <br> <br>   if (NULL == hTTYWnd) <br>      return ( NULL ) ; <br> <br>   ShowWindow( hTTYWnd, nCmdShow ) ; <br>   UpdateWindow( hTTYWnd ) ; <br> <br>   return ( hTTYWnd ) ; <br> <br>} // end of InitInstance() <br> <br>//--------------------------------------------------------------------------- <br>//  LRESULT FAR PASCAL TTYWndProc( HWND hWnd, UINT uMsg, <br>//                                 WPARAM wParam, LPARAM lParam ) <br>// <br>//  Description: <br>//     This is the TTY Window Proc.  This handles ALL messages <br>//     to the tty window. <br>// <br>//  Parameters: <br>//     As documented for Window procedures. <br>// <br>//  Win-32 Porting Issues: <br>//     - WM_HSCROLL and WM_VSCROLL packing is different under Win-32. <br>//     - Needed LOWORD() of wParam for WM_CHAR messages. <br>// <br>//--------------------------------------------------------------------------- <br> <br>LRESULT FAR PASCAL TTYWndProc( HWND hWnd, UINT uMsg, <br>                               WPARAM wParam, LPARAM lParam ) <br>{ <br> <br>   DWORD dwBlockSize=512; <br>   char * szBuffer; <br> <br>   switch (uMsg) <br>   { <br> <br>      case WM_CREATE: <br>         return ( CreateTTYInfo( hWnd ) ) ; <br> <br>      case WM_COMMAND: <br>      { <br>         switch ( LOWORD( wParam ) ) <br>         { <br>            case IDM_CONNECT: <br>               if (!OpenConnection( hWnd )) <br>                  MessageBox( hWnd, "Connection failed.", gszAppName, <br>                              MB_ICONEXCLAMATION ) ; <br>               break ; <br> <br>            case IDM_DISCONNECT: <br>               KillTTYFocus( hWnd ) ; <br>               CloseConnection( hWnd ) ; <br>               break ; <br> <br>            case IDM_SETTINGS: <br>            { <br>               NPTTYINFO  npTTYInfo ; <br> <br>               if (NULL == (npTTYInfo = GETNPTTYINFO( hWnd ))) <br>                  return ( FALSE ) ; <br>               GoModalDialogBoxParam( GETHINST( hWnd ), <br>                                      MAKEINTRESOURCE( SETTINGSDLGBOX ), hWnd, <br>                                      (DLGPROC) SettingsDlgProc, <br>                                      (LPARAM) (LPSTR) npTTYInfo ) ; <br> <br>               // if fConnected, set new COM parameters <br> <br>               if (CONNECTED( npTTYInfo )) <br>               { <br>                  if (!SetupConnection( hWnd )) <br>                     MessageBox( hWnd, "Settings failed!", gszAppName, <br>                                 MB_ICONEXCLAMATION ) ; <br>               } <br>            } <br>            break ; <br> <br>            case IDM_SENDBLOCK: <br>               // This function is very useful to test how <br>               // your comm application handles large blocks <br>               // of data <br> <br>               szBuffer = malloc(dwBlockSize); <br>               memset(szBuffer, 'X', dwBlockSize); <br>               WriteCommBlock( hWnd, szBuffer, dwBlockSize); <br>               free(szBuffer); <br> <br>               break; <br> <br>            case IDM_ABOUT: <br>               GoModalDialogBoxParam ( GETHINST( hWnd ), <br>                                       MAKEINTRESOURCE( ABOUTDLGBOX ), <br>                                       hWnd, <br>                                       (DLGPROC) AboutDlgProc, 0L ) ; <br>               break; <br> <br>            case IDM_EXIT: <br>               PostMessage( hWnd, WM_CLOSE, 0, 0L ) ; <br>               break ; <br>         } <br>      } <br>      break ; <br> <br>      case WM_PAINT: <br>         PaintTTY( hWnd ) ; <br>         break ; <br> <br>      case WM_SIZE: <br>         SizeTTY( hWnd, HIWORD( lParam ), LOWORD( lParam ) ) ; <br>         break ; <br> <br>      case WM_HSCROLL: <br>         ScrollTTYHorz( hWnd, LOWORD( wParam ), HIWORD( wParam ) ) ; <br>         break ; <br> <br>      case WM_VSCROLL: <br>         ScrollTTYVert( hWnd, LOWORD( wParam ), HIWORD( wParam ) ) ; <br>         break ; <br> <br>      case WM_CHAR: <br>         ProcessTTYCharacter( hWnd, LOBYTE( LOWORD( wParam ) ) ) ; <br>         break ; <br> <br>      case WM_SETFOCUS: <br>         SetTTYFocus( hWnd ) ; <br>         break ; <br> <br>      case WM_KILLFOCUS: <br>         KillTTYFocus( hWnd ) ; <br>         break ; <br> <br>      case WM_DESTROY: <br>         DestroyTTYInfo( hWnd ) ; <br>         PostQuitMessage( 0 ) ; <br>         break ; <br> <br>      case WM_CLOSE: <br>         if (IDOK != MessageBox( hWnd, "OK to close window?", "TTY Sample", <br>                                 MB_ICONQUESTION | MB_OKCANCEL )) <br>            break ; <br> <br>         // fall through <br> <br>      default: <br>         return( DefWindowProc( hWnd, uMsg, wParam, lParam ) ) ; <br>   } <br>   return 0L ; <br> <br>} // end of TTYWndProc() <br> <br>//--------------------------------------------------------------------------- <br>//  LRESULT NEAR CreateTTYInfo( HWND hWnd ) <br>// <br>//  Description: <br>//     Creates the tty information structure and sets <br>//     menu option availability.  Returns -1 if unsuccessful. <br>// <br>//  Parameters: <br>//     HWND  hWnd <br>//        Handle to main window. <br>// <br>//  Win-32 Porting Issues: <br>//     - Needed to initialize TERMWND( npTTYInfo ) for secondary thread. <br>//     - Needed to create/initialize overlapped structures used in reads &amp; <br>//       writes to COMM device. <br>// <br>//--------------------------------------------------------------------------- <br> <br>LRESULT NEAR CreateTTYInfo( HWND hWnd ) <br>{ <br>   HMENU       hMenu ; <br>   NPTTYINFO   npTTYInfo ; <br> <br>   if (NULL == (npTTYInfo = <br>                   (NPTTYINFO) LocalAlloc( LPTR, sizeof( TTYINFO ) ))) <br>      return ( (LRESULT) -1 ) ; <br> <br>   // initialize TTY info structure <br> <br>   COMDEV( npTTYInfo )        = 0 ; <br>   CONNECTED( npTTYInfo )     = FALSE ; <br>   CURSORSTATE( npTTYInfo )   = CS_HIDE ; <br>   LOCALECHO( npTTYInfo )     = FALSE ; <br>   AUTOWRAP( npTTYInfo )      = TRUE ; <br>   PORT( npTTYInfo )          = 1 ; <br>   BAUDRATE( npTTYInfo )      = CBR_9600 ; <br>   BYTESIZE( npTTYInfo )      = 8 ; <br>   //FLOWCTRL( npTTYInfo )      = FC_RTSCTS ; <br>   FLOWCTRL( npTTYInfo )      = FC_XONXOFF ; <br>   PARITY( npTTYInfo )        = NOPARITY ; <br>   STOPBITS( npTTYInfo )      = ONESTOPBIT ; <br>   XONXOFF( npTTYInfo )       = FALSE ; <br>   XSIZE( npTTYInfo )         = 0 ; <br>   YSIZE( npTTYInfo )         = 0 ; <br>   XSCROLL( npTTYInfo )       = 0 ; <br>   YSCROLL( npTTYInfo )       = 0 ; <br>   XOFFSET( npTTYInfo )       = 0 ; <br>   YOFFSET( npTTYInfo )       = 0 ; <br>   COLUMN( npTTYInfo )        = 0 ; <br>   ROW( npTTYInfo )           = 0 ; <br>   HTTYFONT( npTTYInfo )      = NULL ; <br>   FGCOLOR( npTTYInfo )       = RGB( 0, 0, 0 ) ; <br>   USECNRECEIVE( npTTYInfo )  = TRUE ; <br>   DISPLAYERRORS( npTTYInfo ) = TRUE ; <br>   WRITE_OS( npTTYInfo ).Offset = 0 ; <br>   WRITE_OS( npTTYInfo ).OffsetHigh = 0 ; <br>   READ_OS( npTTYInfo ).Offset = 0 ; <br>   READ_OS( npTTYInfo ).OffsetHigh = 0 ; <br>   TERMWND( npTTYInfo ) =       hWnd ; <br> <br>   // create I/O event used for overlapped reads / writes <br> <br>   READ_OS( npTTYInfo ).hEvent = CreateEvent( NULL,    // no security <br>                                              TRUE,    // explicit reset req <br>                                              FALSE,   // initial event reset <br>                                              NULL ) ; // no name <br>   if (READ_OS( npTTYInfo ).hEvent == NULL) <br>   { <br>      LocalFree( npTTYInfo ) ; <br>      return ( -1 ) ; <br>   } <br>   WRITE_OS( npTTYInfo ).hEvent = CreateEvent( NULL,    // no security <br>                                               TRUE,    // explicit reset req <br>                                               FALSE,   // initial event reset <br>                                               NULL ) ; // no name <br>   if (NULL == WRITE_OS( npTTYInfo ).hEvent) <br>   { <br>      CloseHandle( READ_OS( npTTYInfo ).hEvent ) ; <br>      LocalFree( npTTYInfo ) ; <br>      return ( -1 ) ; <br>   } <br> <br>   // clear screen space <br> <br>   _fmemset( SCREEN( npTTYInfo ), ' ', MAXROWS * MAXCOLS ) ; <br> <br>   // setup default font information <br> <br>   LFTTYFONT( npTTYInfo ).lfHeight =         9 ; <br>   LFTTYFONT( npTTYInfo ).lfWidth =          0 ; <br>   LFTTYFONT( npTTYInfo ).lfEscapement =     0 ; <br>   LFTTYFONT( npTTYInfo ).lfOrientation =    0 ; <br>   LFTTYFONT( npTTYInfo ).lfWeight =         0 ; <br>   LFTTYFONT( npTTYInfo ).lfItalic =         0 ; <br>   LFTTYFONT( npTTYInfo ).lfUnderline =      0 ; <br>   LFTTYFONT( npTTYInfo ).lfStrikeOut =      0 ; <br>   LFTTYFONT( npTTYInfo ).lfCharSet =        OEM_CHARSET ; <br>   LFTTYFONT( npTTYInfo ).lfOutPrecision =   OUT_DEFAULT_PRECIS ; <br>   LFTTYFONT( npTTYInfo ).lfClipPrecision =  CLIP_DEFAULT_PRECIS ; <br>   LFTTYFONT( npTTYInfo ).lfQuality =        DEFAULT_QUALITY ; <br>   LFTTYFONT( npTTYInfo ).lfPitchAndFamily = FIXED_PITCH | FF_MODERN ; <br>   lstrcpy( LFTTYFONT( npTTYInfo ).lfFaceName, "FixedSys" ) ; <br> <br>   // set TTYInfo handle before any further message processing. <br> <br>   SETNPTTYINFO( hWnd, npTTYInfo ) ; <br> <br>   // reset the character information, etc. <br> <br>   ResetTTYScreen( hWnd, npTTYInfo ) ; <br> <br>   hMenu = GetMenu( hWnd ) ; <br>   EnableMenuItem( hMenu, IDM_DISCONNECT, <br>                   MF_GRAYED | MF_DISABLED | MF_BYCOMMAND ) ; <br>   EnableMenuItem( hMenu, IDM_CONNECT, MF_ENABLED | MF_BYCOMMAND ) ; <br> <br>   return ( (LRESULT) TRUE ) ; <br> <br>} // end of CreateTTYInfo() <br> <br>//--------------------------------------------------------------------------- <br>//  BOOL NEAR DestroyTTYInfo( HWND hWnd ) <br>// <br>//  Description: <br>//     Destroys block associated with TTY window handle. <br>// <br>//  Parameters: <br>//     HWND hWnd <br>//        handle to TTY window <br>// <br>//  Win-32 Porting Issues: <br>//     - Needed to clean up event objects created during initialization. <br>// <br>//--------------------------------------------------------------------------- <br> <br>BOOL NEAR DestroyTTYInfo( HWND hWnd ) <br>{ <br>   NPTTYINFO npTTYInfo ; <br> <br>   if (NULL == (npTTYInfo = GETNPTTYINFO( hWnd ))) <br>      return ( FALSE ) ; <br> <br>   // force connection closed (if not already closed) <br> <br>   if (CONNECTED( npTTYInfo )) <br>      CloseConnection( hWnd ) ; <br> <br>   // clean up event objects <br> <br>   CloseHandle( READ_OS( npTTYInfo ).hEvent ) ; <br>   CloseHandle( WRITE_OS( npTTYInfo ).hEvent ) ; <br>   CloseHandle( POSTEVENT( npTTYInfo ) ) ; <br> <br>   DeleteObject( HTTYFONT( npTTYInfo ) ) ; <br> <br>   LocalFree( npTTYInfo ) ; <br>   return ( TRUE ) ; <br> <br>} // end of DestroyTTYInfo() <br> <br>//--------------------------------------------------------------------------- <br>//  BOOL NEAR ResetTTYScreen( HWND hWnd, NPTTYINFO npTTYInfo ) <br>// <br>//  Description: <br>//     Resets the TTY character information and causes the <br>//     screen to resize to update the scroll information. <br>// <br>//  Parameters: <br>//     NPTTYINFO  npTTYInfo <br>//        pointer to TTY info structure <br>// <br>//--------------------------------------------------------------------------- <br> <br>BOOL NEAR ResetTTYScreen( HWND hWnd, NPTTYINFO npTTYInfo ) <br>{ <br>   HDC         hDC ; <br>   TEXTMETRIC  tm ; <br>   RECT        rcWindow ; <br> <br>   if (NULL == npTTYInfo) <br>      return ( FALSE ) ; <br> <br>   if (NULL != HTTYFONT( npTTYInfo )) <br>      DeleteObject( HTTYFONT( npTTYInfo ) ) ; <br> <br>   HTTYFONT( npTTYInfo ) = CreateFontIndirect( &amp;LFTTYFONT( npTTYInfo ) ) ; <br> <br>   hDC = GetDC( hWnd ) ; <br>   SelectObject( hDC, HTTYFONT( npTTYInfo ) ) ; <br>   GetTextMetrics( hDC, &amp;tm ) ; <br>   ReleaseDC( hWnd, hDC ) ; <br> <br>   XCHAR( npTTYInfo ) = tm.tmAveCharWidth  ; <br>   YCHAR( npTTYInfo ) = tm.tmHeight + tm.tmExternalLeading ; <br> <br>   // a slimy hack to force the scroll position, region to <br>   // be recalculated based on the new character sizes <br> <br>   GetWindowRect( hWnd, &amp;rcWindow ) ; <br>   SendMessage( hWnd, WM_SIZE, SIZENORMAL, <br>                (LPARAM) MAKELONG( rcWindow.right - rcWindow.left, <br>                                   rcWindow.bottom - rcWindow.top ) ) ; <br> <br>   return ( TRUE ) ; <br> <br>} // end of ResetTTYScreen() <br> <br>//--------------------------------------------------------------------------- <br>//  BOOL NEAR PaintTTY( HWND hWnd ) <br>// <br>//  Description: <br>//     Paints the rectangle determined by the paint struct of <br>//     the DC. <br>// <br>//  Parameters: <br>//     HWND hWnd <br>//        handle to TTY window (as always) <br>// <br>//--------------------------------------------------------------------------- <br> <br>BOOL NEAR PaintTTY( HWND hWnd ) <br>{ <br>   int          nRow, nCol, nEndRow, nEndCol, nCount, nHorzPos, nVertPos ; <br>   HDC          hDC ; <br>   HFONT        hOldFont ; <br>   NPTTYINFO    npTTYInfo ; <br>   PAINTSTRUCT  ps ; <br>   RECT         rect ; <br> <br>   if (NULL == (npTTYInfo = GETNPTTYINFO( hWnd ))) <br>      return ( FALSE ) ; <br> <br>   hDC = BeginPaint( hWnd, &amp;ps ) ; <br>   hOldFont = SelectObject( hDC, HTTYFONT( npTTYInfo ) ) ; <br>   SetTextColor( hDC, FGCOLOR( npTTYInfo ) ) ; <br>   SetBkColor( hDC, GetSysColor( COLOR_WINDOW ) ) ; <br>   rect = ps.rcPaint ; <br>   nRow = <br>      min( MAXROWS - 1, <br>           max( 0, (rect.top + YOFFSET( npTTYInfo )) / YCHAR( npTTYInfo ) ) ) ; <br>   nEndRow = <br>      min( MAXROWS - 1, <br>           ((rect.bottom + YOFFSET( npTTYInfo ) - 1) / YCHAR( npTTYInfo ) ) ) ; <br>   nCol = <br>      min( MAXCOLS - 1, <br>           max( 0, (rect.left + XOFFSET( npTTYInfo )) / XCHAR( npTTYInfo ) ) ) ; <br>   nEndCol = <br>      min( MAXCOLS - 1, <br>           ((rect.right + XOFFSET( npTTYInfo ) - 1) / XCHAR( npTTYInfo ) ) ) ; <br>   nCount = nEndCol - nCol + 1 ; <br>   for (; nRow &lt;= nEndRow; nRow++) <br>   { <br>      nVertPos = (nRow * YCHAR( npTTYInfo )) - YOFFSET( npTTYInfo ) ; <br>      nHorzPos = (nCol * XCHAR( npTTYInfo )) - XOFFSET( npTTYInfo ) ; <br>      rect.top = nVertPos ; <br>      rect.bottom = nVertPos + YCHAR( npTTYInfo ) ; <br>      rect.left = nHorzPos ; <br>      rect.right = nHorzPos + XCHAR( npTTYInfo ) * nCount ; <br>      SetBkMode( hDC, OPAQUE ) ; <br>      ExtTextOut( hDC, nHorzPos, nVertPos, ETO_OPAQUE | ETO_CLIPPED, &amp;rect, <br>                  (LPSTR)( SCREEN( npTTYInfo ) + nRow * MAXCOLS + nCol ), <br>                  nCount, NULL ) ; <br>   } <br>   SelectObject( hDC, hOldFont ) ; <br>   EndPaint( hWnd, &amp;ps ) ; <br>   MoveTTYCursor( hWnd ) ; <br>   return ( TRUE ) ; <br> <br>} // end of PaintTTY() <br> <br>//--------------------------------------------------------------------------- <br>//  BOOL NEAR SizeTTY( HWND hWnd, WORD wVertSize, WORD wHorzSize ) <br>// <br>//  Description: <br>//     Sizes TTY and sets up scrolling regions. <br>// <br>//  Parameters: <br>//     HWND hWnd <br>//        handle to TTY window <br>// <br>//     WORD wVertSize <br>//        new vertical size <br>// <br>//     WORD wHorzSize <br>//        new horizontal size <br>// <br>//--------------------------------------------------------------------------- <br> <br>BOOL NEAR SizeTTY( HWND hWnd, WORD wVertSize, WORD wHorzSize ) <br>{ <br>   int        nScrollAmt ; <br>   NPTTYINFO  npTTYInfo ; <br> <br>   if (NULL == (npTTYInfo = GETNPTTYINFO( hWnd ))) <br>      return ( FALSE ) ; <br> <br>   YSIZE( npTTYInfo ) = (int) wVertSize ; <br>   YSCROLL( npTTYInfo ) = max( 0, (MAXROWS * YCHAR( npTTYInfo )) - <br>                               YSIZE( npTTYInfo ) ) ; <br>   nScrollAmt = min( YSCROLL( npTTYInfo ), YOFFSET( npTTYInfo ) ) - <br>                     YOFFSET( npTTYInfo ) ; <br>   ScrollWindow( hWnd, 0, -nScrollAmt, NULL, NULL ) ; <br> <br>   YOFFSET( npTTYInfo ) = YOFFSET( npTTYInfo ) + nScrollAmt ; <br>   SetScrollPos( hWnd, SB_VERT, YOFFSET( npTTYInfo ), FALSE ) ; <br>   SetScrollRange( hWnd, SB_VERT, 0, YSCROLL( npTTYInfo ), TRUE ) ; <br> <br>   XSIZE( npTTYInfo ) = (int) wHorzSize ; <br>   XSCROLL( npTTYInfo ) = max( 0, (MAXCOLS * XCHAR( npTTYInfo )) - <br>                                XSIZE( npTTYInfo ) ) ; <br>   nScrollAmt = min( XSCROLL( npTTYInfo ), XOFFSET( npTTYInfo )) - <br>                     XOFFSET( npTTYInfo ) ; <br>   ScrollWindow( hWnd, 0, -nScrollAmt, NULL, NULL ) ; <br>   XOFFSET( npTTYInfo ) = XOFFSET( npTTYInfo ) + nScrollAmt ; <br>   SetScrollPos( hWnd, SB_HORZ, XOFFSET( npTTYInfo ), FALSE ) ; <br>   SetScrollRange( hWnd, SB_HORZ, 0, XSCROLL( npTTYInfo ), TRUE ) ; <br> <br>   InvalidateRect( hWnd, NULL, TRUE ) ; <br> <br>   return ( TRUE ) ; <br> <br>} // end of SizeTTY() <br> <br>//--------------------------------------------------------------------------- <br>//  BOOL NEAR ScrollTTYVert( HWND hWnd, WORD wScrollCmd, WORD wScrollPos ) <br>// <br>//  Description: <br>//     Scrolls TTY window vertically. <br>// <br>//  Parameters: <br>//     HWND hWnd <br>//        handle to TTY window <br>// <br>//     WORD wScrollCmd <br>//        type of scrolling we're doing <br>// <br>//     WORD wScrollPos <br>//        scroll position <br>// <br>//--------------------------------------------------------------------------- <br> <br>BOOL NEAR ScrollTTYVert( HWND hWnd, WORD wScrollCmd, WORD wScrollPos ) <br>{ <br>   int        nScrollAmt ; <br>   NPTTYINFO  npTTYInfo ; <br> <br>   if (NULL == (npTTYInfo = GETNPTTYINFO( hWnd ))) <br>      return ( FALSE ) ; <br> <br>   switch (wScrollCmd) <br>   { <br>      case SB_TOP: <br>         nScrollAmt = -YOFFSET( npTTYInfo ) ; <br>         break ; <br> <br>      case SB_BOTTOM: <br>         nScrollAmt = YSCROLL( npTTYInfo ) - YOFFSET( npTTYInfo ) ; <br>         break ; <br> <br>      case SB_PAGEUP: <br>         nScrollAmt = -YSIZE( npTTYInfo ) ; <br>         break ; <br> <br>      case SB_PAGEDOWN: <br>         nScrollAmt = YSIZE( npTTYInfo ) ; <br>         break ; <br> <br>      case SB_LINEUP: <br>         nScrollAmt = -YCHAR( npTTYInfo ) ; <br>         break ; <br> <br>      case SB_LINEDOWN: <br>         nScrollAmt = YCHAR( npTTYInfo ) ; <br>         break ; <br> <br>      case SB_THUMBPOSITION: <br>         nScrollAmt = wScrollPos - YOFFSET( npTTYInfo ) ; <br>         break ; <br> <br>      default: <br>         return ( FALSE ) ; <br>   } <br>   if ((YOFFSET( npTTYInfo ) + nScrollAmt) &gt; YSCROLL( npTTYInfo )) <br>      nScrollAmt = YSCROLL( npTTYInfo ) - YOFFSET( npTTYInfo ) ; <br>   if ((YOFFSET( npTTYInfo ) + nScrollAmt) &lt; 0) <br>      nScrollAmt = -YOFFSET( npTTYInfo ) ; <br>   ScrollWindow( hWnd, 0, -nScrollAmt, NULL, NULL ) ; <br>   YOFFSET( npTTYInfo ) = YOFFSET( npTTYInfo ) + nScrollAmt ; <br>   SetScrollPos( hWnd, SB_VERT, YOFFSET( npTTYInfo ), TRUE ) ; <br> <br>   return ( TRUE ) ; <br> <br>} // end of ScrollTTYVert() <br> <br>//--------------------------------------------------------------------------- <br>//  BOOL NEAR ScrollTTYHorz( HWND hWnd, WORD wScrollCmd, WORD wScrollPos ) <br>// <br>//  Description: <br>//     Scrolls TTY window horizontally. <br>// <br>//  Parameters: <br>//     HWND hWnd <br>//        handle to TTY window <br>// <br>//     WORD wScrollCmd <br>//        type of scrolling we're doing <br>// <br>//     WORD wScrollPos <br>//        scroll position <br>// <br>//--------------------------------------------------------------------------- <br> <br>BOOL NEAR ScrollTTYHorz( HWND hWnd, WORD wScrollCmd, WORD wScrollPos ) <br>{ <br>   int        nScrollAmt ; <br>   NPTTYINFO  npTTYInfo ; <br> <br>   if (NULL == (npTTYInfo = GETNPTTYINFO( hWnd ))) <br>      return ( FALSE ) ; <br> <br>   switch (wScrollCmd) <br>   { <br>      case SB_TOP: <br>         nScrollAmt = -XOFFSET( npTTYInfo ) ; <br>         break ; <br> <br>      case SB_BOTTOM: <br>         nScrollAmt = XSCROLL( npTTYInfo ) - XOFFSET( npTTYInfo ) ; <br>         break ; <br> <br>      case SB_PAGEUP: <br>         nScrollAmt = -XSIZE( npTTYInfo ) ; <br>         break ; <br> <br>      case SB_PAGEDOWN: <br>         nScrollAmt = XSIZE( npTTYInfo ) ; <br>         break ; <br> <br>      case SB_LINEUP: <br>         nScrollAmt = -XCHAR( npTTYInfo ) ; <br>         break ; <br> <br>      case SB_LINEDOWN: <br>         nScrollAmt = XCHAR( npTTYInfo ) ; <br>         break ; <br> <br>      case SB_THUMBPOSITION: <br>         nScrollAmt = wScrollPos - XOFFSET( npTTYInfo ) ; <br>         break ; <br> <br>      default: <br>         return ( FALSE ) ; <br>   } <br>   if ((XOFFSET( npTTYInfo ) + nScrollAmt) &gt; XSCROLL( npTTYInfo )) <br>      nScrollAmt = XSCROLL( npTTYInfo ) - XOFFSET( npTTYInfo ) ; <br>   if ((XOFFSET( npTTYInfo ) + nScrollAmt) &lt; 0) <br>      nScrollAmt = -XOFFSET( npTTYInfo ) ; <br>   ScrollWindow( hWnd, -nScrollAmt, 0, NULL, NULL ) ; <br>   XOFFSET( npTTYInfo ) = XOFFSET( npTTYInfo ) + nScrollAmt ; <br>   SetScrollPos( hWnd, SB_HORZ, XOFFSET( npTTYInfo ), TRUE ) ; <br> <br>   return ( TRUE ) ; <br> <br>} // end of ScrollTTYHorz() <br> <br>//--------------------------------------------------------------------------- <br>//  BOOL NEAR SetTTYFocus( HWND hWnd ) <br>// <br>//  Description: <br>//     Sets the focus to the TTY window also creates caret. <br>// <br>//  Parameters: <br>//     HWND hWnd <br>//        handle to TTY window <br>// <br>//--------------------------------------------------------------------------- <br> <br>BOOL NEAR SetTTYFocus( HWND hWnd ) <br>{ <br>   NPTTYINFO  npTTYInfo ; <br> <br>   if (NULL == (npTTYInfo = GETNPTTYINFO( hWnd ))) <br>      return ( FALSE ) ; <br> <br>   if (CONNECTED( npTTYInfo ) &amp;&amp; (CURSORSTATE( npTTYInfo ) != CS_SHOW)) <br>   { <br>      CreateCaret( hWnd, NULL, XCHAR( npTTYInfo ), YCHAR( npTTYInfo ) ) ; <br>      ShowCaret( hWnd ) ; <br>      CURSORSTATE( npTTYInfo ) = CS_SHOW ; <br>   } <br>   MoveTTYCursor( hWnd ) ; <br>   return ( TRUE ) ; <br> <br>} // end of SetTTYFocus() <br> <br>//--------------------------------------------------------------------------- <br>//  BOOL NEAR KillTTYFocus( HWND hWnd ) <br>// <br>//  Description: <br>//     Kills TTY focus and destroys the caret. <br>// <br>//  Parameters: <br>//     HWND hWnd <br>//        handle to TTY window <br>// <br>//--------------------------------------------------------------------------- <br> <br>BOOL NEAR KillTTYFocus( HWND hWnd ) <br>{ <br>   NPTTYINFO  npTTYInfo ; <br> <br>   if (NULL == (npTTYInfo = GETNPTTYINFO( hWnd ))) <br>      return ( FALSE ) ; <br> <br>   if (CONNECTED( npTTYInfo ) &amp;&amp; (CURSORSTATE( npTTYInfo ) != CS_HIDE)) <br>   { <br>      HideCaret( hWnd ) ; <br>      DestroyCaret() ; <br>      CURSORSTATE( npTTYInfo ) = CS_HIDE ; <br>   } <br>   return ( TRUE ) ; <br> <br>} // end of KillTTYFocus() <br> <br>//--------------------------------------------------------------------------- <br>//  BOOL NEAR MoveTTYCursor( HWND hWnd ) <br>// <br>//  Description: <br>//     Moves caret to current position. <br>// <br>//  Parameters: <br>//     HWND hWnd <br>//        handle to TTY window <br>// <br>//--------------------------------------------------------------------------- <br> <br>BOOL NEAR MoveTTYCursor( HWND hWnd ) <br>{ <br>   NPTTYINFO  npTTYInfo ; <br> <br>   if (NULL == (npTTYInfo = GETNPTTYINFO( hWnd ))) <br>      return ( FALSE ) ; <br> <br>   if (CONNECTED( npTTYInfo ) &amp;&amp; (CURSORSTATE( npTTYInfo ) &amp; CS_SHOW)) <br>      SetCaretPos( (COLUMN( npTTYInfo ) * XCHAR( npTTYInfo )) - <br>                   XOFFSET( npTTYInfo ), <br>                   (ROW( npTTYInfo ) * YCHAR( npTTYInfo )) - <br>                   YOFFSET( npTTYInfo ) ) ; <br> <br>   return ( TRUE ) ; <br> <br>} // end of MoveTTYCursor() <br> <br>//--------------------------------------------------------------------------- <br>//  BOOL NEAR ProcessTTYCharacter( HWND hWnd, BYTE bOut ) <br>// <br>//  Description: <br>//     This simply writes a character to the port and echos it <br>//     to the TTY screen if fLocalEcho is set.  Some minor <br>//     keyboard mapping could be performed here. <br>// <br>//  Parameters: <br>//     HWND hWnd <br>//        handle to TTY window <br>// <br>//     BYTE bOut <br>//        byte from keyboard <br>// <br>//--------------------------------------------------------------------------- <br> <br>BOOL NEAR ProcessTTYCharacter( HWND hWnd, BYTE bOut ) <br>{ <br>   NPTTYINFO  npTTYInfo ; <br> <br>   if (NULL == (npTTYInfo = GETNPTTYINFO( hWnd ))) <br>      return ( FALSE ) ; <br> <br>   if (!CONNECTED( npTTYInfo )) <br>      return ( FALSE ) ; <br> <br>   // a robust app would take appropriate steps if WriteCommBlock failed <br>   WriteCommBlock( hWnd, &amp;bOut, 1 ) ; <br>   if (LOCALECHO( npTTYInfo )) <br>      WriteTTYBlock( hWnd, &amp;bOut, 1 ) ; <br> <br>   return ( TRUE ) ; <br> <br>} // end of ProcessTTYCharacter() <br> <br>//--------------------------------------------------------------------------- <br>//  BOOL NEAR OpenConnection( HWND hWnd ) <br>// <br>//  Description: <br>//     Opens communication port specified in the TTYINFO struct. <br>//     It also sets the CommState and notifies the window via <br>//     the fConnected flag in the TTYINFO struct. <br>// <br>//  Parameters: <br>//     HWND hWnd <br>//        handle to TTY window <br>// <br>//  Win-32 Porting Issues: <br>//     - OpenComm() is not supported under Win-32.  Use CreateFile() <br>//       and setup for OVERLAPPED_IO. <br>//     - Win-32 has specific communication timeout parameters. <br>//     - Created the secondary thread for event notification. <br>// <br>//--------------------------------------------------------------------------- <br> <br>BOOL NEAR OpenConnection( HWND hWnd ) <br>{ <br>   char       szPort[ 15 ], szTemp[ 10 ] ; <br>   BOOL       fRetVal ; <br>   HCURSOR    hOldCursor, hWaitCursor ; <br>   HMENU      hMenu ; <br>   NPTTYINFO  npTTYInfo ; <br> <br>   HANDLE        hCommWatchThread ; <br>   DWORD         dwThreadID ; <br>   COMMTIMEOUTS  CommTimeOuts ; <br> <br>   if (NULL == (npTTYInfo = GETNPTTYINFO( hWnd ))) <br>      return ( FALSE ) ; <br> <br>   // show the hourglass cursor <br>   hWaitCursor = LoadCursor( NULL, IDC_WAIT ) ; <br>   hOldCursor = SetCursor( hWaitCursor ) ; <br> <br>   // load the COM prefix string and append port number <br> <br>   LoadString( GETHINST( hWnd ), IDS_COMPREFIX, szTemp, sizeof( szTemp ) ) ; <br>   wsprintf( szPort, "%s%d", (LPSTR) szTemp, PORT( npTTYInfo ) ) ; <br> <br>   // open COMM device <br> <br>   if ((COMDEV( npTTYInfo ) = <br>      CreateFile( szPort, GENERIC_READ | GENERIC_WRITE, <br>                  0,                    // exclusive access <br>                  NULL,                 // no security attrs <br>                  OPEN_EXISTING, <br>                  FILE_ATTRIBUTE_NORMAL | <br>                  FILE_FLAG_OVERLAPPED, // overlapped I/O <br>                  NULL )) == (HANDLE) -1 ) <br>      return ( FALSE ) ; <br>   else <br>   { <br>      // get any early notifications <br> <br>      SetCommMask( COMDEV( npTTYInfo ), EV_RXCHAR ) ; <br> <br>      // setup device buffers <br> <br>      SetupComm( COMDEV( npTTYInfo ), 4096, 4096 ) ; <br> <br>      // purge any information in the buffer <br> <br>      PurgeComm( COMDEV( npTTYInfo ), PURGE_TXABORT | PURGE_RXABORT | </code></pre>
<p>
</p>
<pre><code>PURGE_TXCLEAR | PURGE_RXCLEAR ) ; <br> <br>      // set up for overlapped I/O <br> <br>      CommTimeOuts.ReadIntervalTimeout = 0xFFFFFFFF ; <br>      CommTimeOuts.ReadTotalTimeoutMultiplier = 0 ; <br>      CommTimeOuts.ReadTotalTimeoutConstant = 1000 ; <br>      // CBR_9600 is approximately 1byte/ms. For our purposes, allow <br>      // double the expected time per character for a fudge factor. <br>      CommTimeOuts.WriteTotalTimeoutMultiplier = 2*CBR_9600/BAUDRATE( npTTYInfo ) ; <br>      CommTimeOuts.WriteTotalTimeoutConstant = 0 ; <br>      SetCommTimeouts( COMDEV( npTTYInfo ), &amp;CommTimeOuts ) ; <br>   } <br> <br>   fRetVal = SetupConnection( hWnd ) ; <br> <br>   if (fRetVal) <br>   { <br>      CONNECTED( npTTYInfo ) = TRUE ; <br> <br>      // Create a secondary thread <br>      // to watch for an event. <br> <br>      if (NULL == (hCommWatchThread = <br>                      CreateThread( (LPSECURITY_ATTRIBUTES) NULL, <br>                                    0, <br>                                    (LPTHREAD_START_ROUTINE) CommWatchProc, <br>                                    (LPVOID) npTTYInfo, <br>                                    0, &amp;dwThreadID ))) <br>      { <br>         CONNECTED( npTTYInfo ) = FALSE ; <br>         CloseHandle( COMDEV( npTTYInfo ) ) ; <br>         fRetVal = FALSE ; <br>      } <br>      else <br>      { <br>         THREADID( npTTYInfo ) = dwThreadID ; <br>         HTHREAD( npTTYInfo ) = hCommWatchThread ; <br> <br>         // assert DTR <br> <br>         EscapeCommFunction( COMDEV( npTTYInfo ), SETDTR ) ; <br> <br>         SetTTYFocus( hWnd ) ; <br> <br>         hMenu = GetMenu( hWnd ) ; <br>         EnableMenuItem( hMenu, IDM_DISCONNECT, <br>                        MF_ENABLED | MF_BYCOMMAND ) ; <br>         EnableMenuItem( hMenu, IDM_CONNECT, <br>                        MF_GRAYED | MF_DISABLED | MF_BYCOMMAND ) ; <br> <br>      } <br>   } <br>   else <br>   { <br>      CONNECTED( npTTYInfo ) = FALSE ; <br>      CloseHandle( COMDEV( npTTYInfo ) ) ; <br>   } <br> <br>   // restore cursor <br> <br>   SetCursor( hOldCursor ) ; <br> <br>   return ( fRetVal ) ; <br> <br>} // end of OpenConnection() <br> <br>//--------------------------------------------------------------------------- <br>//  BOOL NEAR SetupConnection( HWND hWnd ) <br>// <br>//  Description: <br>//     This routines sets up the DCB based on settings in the <br>//     TTY info structure and performs a SetCommState(). <br>// <br>//  Parameters: <br>//     HWND hWnd <br>//        handle to TTY window <br>// <br>//  Win-32 Porting Issues: <br>//     - Win-32 requires a slightly different processing of the DCB. <br>//       Changes were made for configuration of the hardware handshaking <br>//       lines. <br>// <br>//--------------------------------------------------------------------------- <br> <br>BOOL NEAR SetupConnection( HWND hWnd ) <br>{ <br>   BOOL       fRetVal ; <br>   BYTE       bSet ; <br>   DCB        dcb ; <br>   NPTTYINFO  npTTYInfo ; <br> <br>   if (NULL == (npTTYInfo = GETNPTTYINFO( hWnd ))) <br>      return ( FALSE ) ; <br> <br>   dcb.DCBlength = sizeof( DCB ) ; <br> <br>   GetCommState( COMDEV( npTTYInfo ), &amp;dcb ) ; <br> <br>   dcb.BaudRate = BAUDRATE( npTTYInfo ) ; <br>   dcb.ByteSize = BYTESIZE( npTTYInfo ) ; <br>   dcb.Parity = PARITY( npTTYInfo ) ; <br>   dcb.StopBits = STOPBITS( npTTYInfo ) ; <br> <br>   // setup hardware flow control <br> <br>   bSet = (BYTE) ((FLOWCTRL( npTTYInfo ) &amp; FC_DTRDSR) != 0) ; <br>   dcb.fOutxDsrFlow = bSet ; <br>   if (bSet) <br>      dcb.fDtrControl = DTR_CONTROL_HANDSHAKE ; <br>   else <br>      dcb.fDtrControl = DTR_CONTROL_ENABLE ; <br> <br>   bSet = (BYTE) ((FLOWCTRL( npTTYInfo ) &amp; FC_RTSCTS) != 0) ; <br>dcb.fOutxCtsFlow = bSet ; <br>   if (bSet) <br>      dcb.fRtsControl = RTS_CONTROL_HANDSHAKE ; <br>   else <br>      dcb.fRtsControl = RTS_CONTROL_ENABLE ; <br> <br>   // setup software flow control <br> <br>   bSet = (BYTE) ((FLOWCTRL( npTTYInfo ) &amp; FC_XONXOFF) != 0) ; <br> <br>   dcb.fInX = dcb.fOutX = bSet ; <br>   dcb.XonChar = ASCII_XON ; <br>   dcb.XoffChar = ASCII_XOFF ; <br>   dcb.XonLim = 100 ; <br>   dcb.XoffLim = 100 ; <br> <br>   // other various settings <br> <br>   dcb.fBinary = TRUE ; <br>   dcb.fParity = TRUE ; <br> <br>   fRetVal = SetCommState( COMDEV( npTTYInfo ), &amp;dcb ) ; <br> <br>   return ( fRetVal ) ; <br> <br>} // end of SetupConnection() <br> <br>//--------------------------------------------------------------------------- <br>//  BOOL NEAR CloseConnection( HWND hWnd ) <br>// <br>//  Description: <br>//     Closes the connection to the port.  Resets the connect flag <br>//     in the TTYINFO struct. <br>// <br>//  Parameters: <br>//     HWND hWnd <br>//        handle to TTY window <br>// <br>//  Win-32 Porting Issues: <br>//     - Needed to stop secondary thread.  SetCommMask() will signal the <br>//       WaitCommEvent() event and the thread will halt when the <br>//       CONNECTED() flag is clear. <br>//     - Use new PurgeComm() API to clear communications driver before <br>//       closing device. <br>// <br>//--------------------------------------------------------------------------- <br> <br>BOOL NEAR CloseConnection( HWND hWnd ) <br>{ <br>   HMENU      hMenu ; <br>   NPTTYINFO  npTTYInfo ; <br> <br>   if (NULL == (npTTYInfo = GETNPTTYINFO( hWnd ))) <br>      return ( FALSE ) ; <br> <br>   // set connected flag to FALSE <br> <br>   CONNECTED( npTTYInfo ) = FALSE ; <br> <br>   // disable event notification and wait for thread <br>   // to halt <br> <br>   SetCommMask( COMDEV( npTTYInfo ), 0 ) ; <br> <br>   // block until thread has been halted <br> <br>   while(THREADID(npTTYInfo) != 0); <br> <br>   // kill the focus <br> <br>   KillTTYFocus( hWnd ) ; <br> <br>   // drop DTR <br> <br>   EscapeCommFunction( COMDEV( npTTYInfo ), CLRDTR ) ; <br> <br>   // purge any outstanding reads/writes and close device handle <br> <br>   PurgeComm( COMDEV( npTTYInfo ), PURGE_TXABORT | PURGE_RXABORT | <br>                                   PURGE_TXCLEAR | PURGE_RXCLEAR ) ; <br>   CloseHandle( COMDEV( npTTYInfo ) ) ; <br> <br>   // change the selectable items in the menu <br> <br>   hMenu = GetMenu( hWnd ) ; <br>   EnableMenuItem( hMenu, IDM_DISCONNECT, <br>                   MF_GRAYED | MF_DISABLED | MF_BYCOMMAND ) ; <br>   EnableMenuItem( hMenu, IDM_CONNECT, <br>                   MF_ENABLED | MF_BYCOMMAND ) ; <br> <br>   return ( TRUE ) ; <br> <br>} // end of CloseConnection() <br> <br>//--------------------------------------------------------------------------- <br>//  int NEAR ReadCommBlock( HWND hWnd, LPSTR lpszBlock, int nMaxLength ) <br>// <br>//  Description: <br>//     Reads a block from the COM port and stuffs it into <br>//     the provided buffer. <br>// <br>//  Parameters: <br>//     HWND hWnd <br>//        handle to TTY window <br>// <br>//     LPSTR lpszBlock <br>//        block used for storage <br>// <br>//     int nMaxLength <br>//        max length of block to read <br>// <br>//  Win-32 Porting Issues: <br>//     - ReadComm() has been replaced by ReadFile() in Win-32. <br>//     - Overlapped I/O has been implemented. <br>// <br>//--------------------------------------------------------------------------- <br> <br>int NEAR ReadCommBlock( HWND hWnd, LPSTR lpszBlock, int nMaxLength ) <br>{ <br>   BOOL       fReadStat ; <br>   COMSTAT    ComStat ; <br>   DWORD      dwErrorFlags; <br>   DWORD      dwLength; <br>   DWORD      dwError; <br>   char       szError[ 10 ] ; <br>   NPTTYINFO  npTTYInfo ; <br> <br>   if (NULL == (npTTYInfo = GETNPTTYINFO( hWnd ))) <br>      return ( FALSE ) ; <br> <br>   // only try to read number of bytes in queue <br>   ClearCommError( COMDEV( npTTYInfo ), &amp;dwErrorFlags, &amp;ComStat ) ; <br>   dwLength = min( (DWORD) nMaxLength, ComStat.cbInQue ) ; <br> <br>   if (dwLength &gt; 0) <br>   { <br>      fReadStat = ReadFile( COMDEV( npTTYInfo ), lpszBlock, <br>                    dwLength, &amp;dwLength, &amp;READ_OS( npTTYInfo ) ) ; <br>      if (!fReadStat) <br>      { <br>         if (GetLastError() == ERROR_IO_PENDING) <br>         { <br>            OutputDebugString("\n\rIO Pending"); <br>            // We have to wait for read to complete. <br>            // This function will timeout according to the <br>            // CommTimeOuts.ReadTotalTimeoutConstant variable <br>            // Every time it times out, check for port errors <br>            while(!GetOverlappedResult( COMDEV( npTTYInfo ), <br>               &amp;READ_OS( npTTYInfo ), &amp;dwLength, TRUE )) <br>            { <br>               dwError = GetLastError(); <br>               if(dwError == ERROR_IO_INCOMPLETE) <br>                  // normal result if not finished <br>                  continue; <br>               else <br>               { <br>                  // an error occurred, try to recover <br>                  wsprintf( szError, "&lt;CE-%u&gt;", dwError ) ; <br>                  WriteTTYBlock( hWnd, szError, lstrlen( szError ) ) ; <br>                  ClearCommError( COMDEV( npTTYInfo ), &amp;dwErrorFlags, &amp;ComStat ) ; <br>                  if ((dwErrorFlags &gt; 0) &amp;&amp; DISPLAYERRORS( npTTYInfo )) <br>                  { <br>                  wsprintf( szError, "&lt;CE-%u&gt;", dwErrorFlags ) ; <br>                  WriteTTYBlock( hWnd, szError, lstrlen( szError ) ) ; <br>                  } <br>                  break; <br>               } <br> <br>            } <br> <br>      } <br>         else <br>         { <br>            // some other error occurred <br>            dwLength = 0 ; <br>            ClearCommError( COMDEV( npTTYInfo ), &amp;dwErrorFlags, &amp;ComStat ) ; <br>            if ((dwErrorFlags &gt; 0) &amp;&amp; DISPLAYERRORS( npTTYInfo )) <br>            { <br>            wsprintf( szError, "&lt;CE-%u&gt;", dwErrorFlags ) ; <br>            WriteTTYBlock( hWnd, szError, lstrlen( szError ) ) ; <br>            } <br>         } <br>      } <br>   } <br> <br>   return ( dwLength ) ; <br> <br>} // end of ReadCommBlock() <br> <br>//--------------------------------------------------------------------------- <br>//  BOOL NEAR WriteCommBlock( HWND hWnd, BYTE *pByte ) <br>// <br>//  Description: <br>//     Writes a block of data to the COM port specified in the associated <br>//     TTY info structure. <br>// <br>//  Parameters: <br>//     HWND hWnd <br>//        handle to TTY window <br>// <br>//     BYTE *pByte <br>//        pointer to data to write to port <br>// <br>//  Win-32 Porting Issues: <br>//     - WriteComm() has been replaced by WriteFile() in Win-32. <br>//     - Overlapped I/O has been implemented. <br>// <br>//--------------------------------------------------------------------------- <br> <br>BOOL NEAR WriteCommBlock( HWND hWnd, LPSTR lpByte , DWORD dwBytesToWrite) <br>{ <br> <br>   BOOL        fWriteStat ; <br>   DWORD       dwBytesWritten ; <br>   NPTTYINFO   npTTYInfo ; <br>   DWORD       dwErrorFlags; <br>   DWORD   dwError; <br>   DWORD       dwBytesSent=0; <br>   COMSTAT     ComStat; <br>   char        szError[ 128 ] ; <br> <br> <br>   if (NULL == (npTTYInfo = GETNPTTYINFO( hWnd ))) <br>      return ( FALSE ) ; <br> <br>   fWriteStat = WriteFile( COMDEV( npTTYInfo ), lpByte, dwBytesToWrite, <br>                           &amp;dwBytesWritten, &amp;WRITE_OS( npTTYInfo ) ) ; <br> <br>   // Note that normally the code will not execute the following <br>   // because the driver caches write operations. Small I/O requests <br>   // (up to several thousand bytes) will normally be accepted <br>   // immediately and WriteFile will return true even though an <br>   // overlapped operation was specified <br> <br>   if (!fWriteStat) <br>   { <br>      if(GetLastError() == ERROR_IO_PENDING) <br>      { <br>         // We should wait for the completion of the write operation <br>         // so we know if it worked or not <br> <br>         // This is only one way to do this. It might be beneficial to <br>         // place the write operation in a separate thread <br>         // so that blocking on completion will not negatively <br>         // affect the responsiveness of the UI <br> <br>         // If the write takes too long to complete, this <br>         // function will timeout according to the <br>         // CommTimeOuts.WriteTotalTimeoutMultiplier variable. <br>         // This code logs the timeout but does not retry <br>         // the write. <br> <br>         while(!GetOverlappedResult( COMDEV( npTTYInfo ), <br>            &amp;WRITE_OS( npTTYInfo ), &amp;dwBytesWritten, TRUE )) <br>         { <br>            dwError = GetLastError(); <br>            if(dwError == ERROR_IO_INCOMPLETE) <br>            { <br>               // normal result if not finished <br>               dwBytesSent += dwBytesWritten; <br>               continue; <br>            } <br>            else <br>            { <br>               // an error occurred, try to recover <br>               wsprintf( szError, "&lt;CE-%u&gt;", dwError ) ; <br>               WriteTTYBlock( hWnd, szError, lstrlen( szError ) ) ; <br>               ClearCommError( COMDEV( npTTYInfo ), &amp;dwErrorFlags, &amp;ComStat ) ; <br>               if ((dwErrorFlags &gt; 0) &amp;&amp; DISPLAYERRORS( npTTYInfo )) <br>               { <br>                  wsprintf( szError, "&lt;CE-%u&gt;", dwErrorFlags ) ; <br>                  WriteTTYBlock( hWnd, szError, lstrlen( szError ) ) ; <br>               } <br>               break; <br>            } <br>         } <br> <br>         dwBytesSent += dwBytesWritten; <br> <br>         if( dwBytesSent != dwBytesToWrite ) <br>             wsprintf(szError,"\nProbable Write Timeout: Total of %ld bytes sent", dwBytesSent); <br>         else <br>             wsprintf(szError,"\n%ld bytes written", dwBytesSent); <br> <br>         OutputDebugString(szError); <br> <br>      } <br>      else <br>      { <br>         // some other error occurred <br>         ClearCommError( COMDEV( npTTYInfo ), &amp;dwErrorFlags, &amp;ComStat ) ; <br>         if ((dwErrorFlags &gt; 0) &amp;&amp; DISPLAYERRORS( npTTYInfo )) <br>         { <br>            wsprintf( szError, "&lt;CE-%u&gt;", dwErrorFlags ) ; <br>            WriteTTYBlock( hWnd, szError, lstrlen( szError ) ) ; <br>         } <br>         return ( FALSE ); <br>      } <br>   } <br>   return ( TRUE ) ; <br> <br>} // end of WriteCommBlock() <br> <br>//--------------------------------------------------------------------------- <br>//  BOOL NEAR WriteTTYBlock( HWND hWnd, LPSTR lpBlock, int nLength ) <br>// <br>//  Description: <br>//     Writes block to TTY screen.  Nothing fancy - just <br>//     straight TTY. <br>// gl <br>//  Parameters: <br>//     HWND hWnd <br>//        handle to TTY window <br>// <br>//     LPSTR lpBlock <br>//        far pointer to block of data <br>// <br>//     int nLength <br>//        length of block <br>// <br>//--------------------------------------------------------------------------- <br> <br>BOOL NEAR WriteTTYBlock( HWND hWnd, LPSTR lpBlock, int nLength ) <br>{ <br>   int        i ; <br>   NPTTYINFO  npTTYInfo ; <br>   RECT       rect ; <br> <br>   if (NULL == (npTTYInfo = GETNPTTYINFO( hWnd ))) <br>      return ( FALSE ) ; <br> <br>   for (i = 0 ; i &lt; nLength; i++) <br>   { <br>      switch (lpBlock[ i ]) <br>      { <br>         case ASCII_BEL: <br>            // Bell <br>            MessageBeep( 0 ) ; <br>            break ; <br> <br>         case ASCII_BS: <br>            // Backspace <br>            if (COLUMN( npTTYInfo ) &gt; 0) <br>               COLUMN( npTTYInfo ) -- ; <br>            MoveTTYCursor( hWnd ) ; <br>            break ; <br> <br>         case ASCII_CR: <br>            // Carriage return <br>            COLUMN( npTTYInfo ) = 0 ; <br>            MoveTTYCursor( hWnd ) ; <br>            if (!NEWLINE( npTTYInfo )) <br>               break; <br> <br>            // fall through <br> <br>         case ASCII_LF: <br>            // Line feed <br>            if (ROW( npTTYInfo )++ == MAXROWS - 1) <br>            { <br>               _fmemmove( (LPSTR) (SCREEN( npTTYInfo )), <br>                          (LPSTR) (SCREEN( npTTYInfo ) + MAXCOLS), <br>                          (MAXROWS - 1) * MAXCOLS ) ; <br>               _fmemset( (LPSTR) (SCREEN( npTTYInfo ) + (MAXROWS - 1) * MAXCOLS), <br>                         ' ', MAXCOLS ) ; <br>               InvalidateRect( hWnd, NULL, FALSE ) ; <br>               ROW( npTTYInfo )-- ; <br>            } <br>            MoveTTYCursor( hWnd ) ; <br>            break ; <br> <br>         default: <br>            *(SCREEN( npTTYInfo ) + ROW( npTTYInfo ) * MAXCOLS + <br>                COLUMN( npTTYInfo )) = lpBlock[ i ] ; <br>            rect.left = (COLUMN( npTTYInfo ) * XCHAR( npTTYInfo )) - <br>                        XOFFSET( npTTYInfo ) ; <br>            rect.right = rect.left + XCHAR( npTTYInfo ) ; <br>            rect.top = (ROW( npTTYInfo ) * YCHAR( npTTYInfo )) - <br>                       YOFFSET( npTTYInfo ) ; <br>            rect.bottom = rect.top + YCHAR( npTTYInfo ) ; <br>            InvalidateRect( hWnd, &amp;rect, FALSE ) ; <br> <br>            // Line wrap <br>            if (COLUMN( npTTYInfo ) &lt; MAXCOLS - 1) <br>               COLUMN( npTTYInfo )++ ; <br>            else if (AUTOWRAP( npTTYInfo )) <br>               WriteTTYBlock( hWnd, "\r\n", 2 ) ; <br>            break; <br>      } <br>   } <br>   return ( TRUE ) ; <br> <br>} // end of WriteTTYBlock() <br> <br>//--------------------------------------------------------------------------- <br>//  VOID NEAR GoModalDialogBoxParam( HINSTANCE hInstance, <br>//                                   LPCSTR lpszTemplate, HWND hWnd, <br>//                                   DLGPROC lpDlgProc, LPARAM lParam ) <br>// <br>//  Description: <br>//     It is a simple utility function that simply performs the <br>//     MPI and invokes the dialog box with a DWORD paramter. <br>// <br>//  Parameters: <br>//     similar to that of DialogBoxParam() with the exception <br>//     that the lpDlgProc is not a procedure instance <br>// <br>//--------------------------------------------------------------------------- <br> <br>VOID NEAR GoModalDialogBoxParam( HINSTANCE hInstance, LPCSTR lpszTemplate, <br>                                 HWND hWnd, DLGPROC lpDlgProc, LPARAM lParam ) <br>{ <br>   DLGPROC  lpProcInstance ; <br> <br>   lpProcInstance = (DLGPROC) MakeProcInstance( (FARPROC) lpDlgProc, <br>                                                hInstance ) ; <br>   DialogBoxParam( hInstance, lpszTemplate, hWnd, lpProcInstance, lParam ) ; <br>   FreeProcInstance( (FARPROC) lpProcInstance ) ; <br> <br>} // end of GoModalDialogBoxParam() <br> <br>//--------------------------------------------------------------------------- <br>//  BOOL FAR PASCAL AboutDlgProc( HWND hDlg, UINT uMsg, <br>//                                WPARAM wParam, LPARAM lParam ) <br>// <br>//  Description: <br>//     Simulates the Windows System Dialog Box. <br>// <br>//  Parameters: <br>//     Same as standard dialog procedures. <br>// <br>//--------------------------------------------------------------------------- <br> <br>BOOL FAR PASCAL AboutDlgProc( HWND hDlg, UINT uMsg, <br>                              WPARAM wParam, LPARAM lParam ) <br>{ <br>   switch (uMsg) <br>   { <br>      case WM_INITDIALOG: <br>      { <br>         char         szBuffer[ MAXLEN_TEMPSTR ], szTemp[ MAXLEN_TEMPSTR ]; <br>         WORD         wRevision, wVersion ; <br> <br>#ifdef ABOUTDLG_USEBITMAP <br>         // if we are using the bitmap, hide the icon <br> <br>         ShowWindow( GetDlgItem( hDlg, IDD_ABOUTICON ), SW_HIDE ) ; <br>#endif <br>         // sets up the version number for Windows <br> <br>         wVersion = LOWORD( GetVersion() ) ; <br>         wRevision = HIBYTE( wVersion ) ; <br>         wVersion = LOBYTE( wVersion ) ; <br> <br>         GetDlgItemText( hDlg, IDD_TITLELINE, szTemp, sizeof( szTemp ) ) ; <br>         wsprintf( szBuffer, szTemp, wVersion, wRevision ) ; <br>         SetDlgItemText( hDlg, IDD_TITLELINE, szBuffer ) ; <br> <br>         // sets up version number for TTY <br> <br>         GetDlgItemText( hDlg, IDD_VERSION, szTemp, sizeof( szTemp ) ) ; <br>         wsprintf( szBuffer, szTemp, VER_MAJOR, VER_MINOR, VER_BUILD ) ; <br>         SetDlgItemText( hDlg, IDD_VERSION, (LPSTR) szBuffer ) ; <br> <br>         // get by-line <br> <br>         LoadString( GETHINST( hDlg ), IDS_BYLINE, szBuffer, <br>                     sizeof( szBuffer ) ) ; <br>         SetDlgItemText( hDlg, IDD_BYLINE, szBuffer ) ; <br> <br>         SetDlgItemText( hDlg, IDD_WINDOWSMODE, "NT Mode" ) ; <br> <br>      } <br>      return ( TRUE ) ; <br> <br>#ifdef ABOUTDLG_USEBITMAP <br>      // used to paint the bitmap <br> <br>      case WM_PAINT: <br>      { <br>         HBITMAP      hBitMap ; <br>         HDC          hDC, hMemDC ; <br>         PAINTSTRUCT  ps ; <br> <br>         // load bitmap and display it <br> <br>         hDC = BeginPaint( hDlg, &amp;ps ) ; <br>         if (NULL != (hMemDC = CreateCompatibleDC( hDC ))) <br>         { <br>            hBitMap = LoadBitmap( GETHINST( hDlg ), <br>                                  MAKEINTRESOURCE( TTYBITMAP ) ) ; <br>            hBitMap = SelectObject( hMemDC, hBitMap ) ; <br>            BitBlt( hDC, 10, 10, 64, 64, hMemDC, 0, 0, SRCCOPY ) ; <br>            DeleteObject( SelectObject( hMemDC, hBitMap ) ) ; <br>            DeleteDC( hMemDC ) ; <br>         } <br>         EndPaint( hDlg, &amp;ps ) ; <br>      } <br>      break ; <br>#endif <br> <br>      case WM_COMMAND: <br>         if (LOWORD( wParam ) == IDD_OK) <br>         { <br>            EndDialog( hDlg, TRUE ) ; <br>            return ( TRUE ) ; <br>         } <br>         break; <br>   } <br>   return ( FALSE ) ; <br> <br>} // end of AboutDlgProc() <br> <br>//--------------------------------------------------------------------------- <br>//  VOID NEAR FillComboBox( HINSTANCE hInstance, HWND hCtrlWnd, int nIDString, <br>//                          WORD NEAR *npTable, WORD wTableLen, <br>//                          WORD wCurrentSetting ) <br>// <br>//  Description: <br>//     Fills the given combo box with strings from the resource <br>//     table starting at nIDString.  Associated items are <br>//     added from given table.  The combo box is notified of <br>//     the current setting. <br>// <br>//  Parameters: <br>//     HINSTANCE hInstance <br>//        handle to application instance <br>// <br>//     HWND hCtrlWnd <br>//        handle to combo box control <br>// <br>//     int nIDString <br>//        first resource string id <br>// <br>//     DWORD NEAR *npTable <br>//        near point to table of associated values <br>// <br>//     WORD wTableLen <br>//        length of table <br>// <br>//     DWORD dwCurrentSetting <br>//        current setting (for combo box selection) <br>// <br>//--------------------------------------------------------------------------- <br> <br>VOID NEAR FillComboBox( HINSTANCE hInstance, HWND hCtrlWnd, int nIDString, <br>                        DWORD NEAR *npTable, WORD wTableLen, <br>                        DWORD dwCurrentSetting ) <br>{ <br>   char  szBuffer[ MAXLEN_TEMPSTR ] ; <br>   WORD  wCount, wPosition ; <br> <br>   for (wCount = 0; wCount &lt; wTableLen; wCount++) <br>   { <br>      // load the string from the string resources and <br>      // add it to the combo box <br> <br>      LoadString( hInstance, nIDString + wCount, szBuffer, sizeof( szBuffer ) ) ; <br>      wPosition = LOWORD( SendMessage( hCtrlWnd, CB_ADDSTRING, 0, <br>                                       (LPARAM) (LPSTR) szBuffer ) ) ; <br> <br>      // use item data to store the actual table value <br> <br>      SendMessage( hCtrlWnd, CB_SETITEMDATA, (WPARAM) wPosition, <br>                   (LPARAM) *(npTable + wCount) ) ; <br> <br>      // if this is our current setting, select it <br> <br>      if (*(npTable + wCount) == dwCurrentSetting) <br>         SendMessage( hCtrlWnd, CB_SETCURSEL, (WPARAM) wPosition, 0L ) ; <br>   } <br> <br>} // end of FillComboBox() <br> <br>//--------------------------------------------------------------------------- <br>//  BOOL NEAR SettingsDlgInit( HWND hDlg ) <br>// <br>//  Description: <br>//     Puts current settings into dialog box (via CheckRadioButton() etc.) <br>// <br>//  Parameters: <br>//     HWND hDlg <br>//        handle to dialog box <br>// <br>//  Win-32 Porting Issues: <br>//     - Constants require DWORD arrays for baud rate table, etc. <br>//     - There is no "MAXCOM" function in Win-32.  Number of COM ports <br>//       is assumed to be 4. <br>// <br>//--------------------------------------------------------------------------- <br> <br>BOOL NEAR SettingsDlgInit( HWND hDlg ) <br>{ <br>   char       szBuffer[ MAXLEN_TEMPSTR ], szTemp[ MAXLEN_TEMPSTR ] ; <br>   NPTTYINFO  npTTYInfo ; <br>   WORD       wCount, wMaxCOM, wPosition ; <br> <br>   if (NULL == (npTTYInfo = (NPTTYINFO) GET_PROP( hDlg, ATOM_TTYINFO ))) <br>      return ( FALSE ) ; <br> <br>   wMaxCOM = MAXPORTS ; <br> <br>   // load the COM prefix from resources <br> <br>   LoadString( GETHINST( hDlg ), IDS_COMPREFIX, szTemp, sizeof( szTemp ) ) ; <br> <br>   // fill port combo box and make initial selection <br> <br>   for (wCount = 0; wCount &lt; wMaxCOM; wCount++) <br>   { <br>      wsprintf( szBuffer, "%s%d", (LPSTR) szTemp, wCount + 1 ) ; <br>      SendDlgItemMessage( hDlg, IDD_PORTCB, CB_ADDSTRING, 0, <br>                          (LPARAM) (LPSTR) szBuffer ) ; <br>   } <br> <br>   SendDlgItemMessage( hDlg, IDD_PORTCB, CB_SETCURSEL, <br>                       (WPARAM) (PORT( npTTYInfo ) - 1), 0L ) ; <br> <br>   // disable COM port combo box if connection has already been <br>   // established (e.g. OpenComm() already successful) <br> <br>   EnableWindow( GetDlgItem( hDlg, IDD_PORTCB ), !CONNECTED( npTTYInfo ) ) ; <br> <br>   // fill baud combo box and make initial selection <br> <br>   FillComboBox( GETHINST( hDlg ), GetDlgItem( hDlg, IDD_BAUDCB ), <br>                 IDS_BAUD110, BaudTable, <br>                 sizeof( BaudTable ) / sizeof( BaudTable[ 0 ] ), <br>                 BAUDRATE( npTTYInfo ) ) ; <br> <br>   // fill data bits combo box and make initial selection <br> <br>   for (wCount = 5; wCount &lt; 9; wCount++) <br>   { <br>      wsprintf( szBuffer, "%d", wCount ) ; <br>      wPosition = LOWORD( SendDlgItemMessage( hDlg, IDD_DATABITSCB, <br>                                              CB_ADDSTRING, 0, <br>                                              (LPARAM) (LPSTR) szBuffer ) ) ; <br> <br>      // if current selection, tell the combo box <br> <br>      if (wCount == BYTESIZE( npTTYInfo )) <br>         SendDlgItemMessage( hDlg, IDD_DATABITSCB, CB_SETCURSEL, <br>                             (WPARAM) wPosition, 0L ) ; <br>   } <br> <br>   // fill parity combo box and make initial selection <br> <br>   FillComboBox( GETHINST( hDlg ), GetDlgItem( hDlg, IDD_PARITYCB ), <br>                 IDS_PARITYNONE, ParityTable, <br>                 sizeof( ParityTable ) / sizeof( ParityTable[ 0 ] ), <br>                 PARITY( npTTYInfo ) ) ; <br> <br>   // fill stop bits combo box and make initial selection <br> <br>   FillComboBox( GETHINST( hDlg ), GetDlgItem( hDlg, IDD_STOPBITSCB ), <br>                 IDS_ONESTOPBIT, StopBitsTable, <br>                 sizeof( StopBitsTable ) / sizeof ( StopBitsTable ), <br>                 STOPBITS( npTTYInfo ) ) ; <br> <br>   // initalize the flow control settings <br> <br>   CheckDlgButton( hDlg, IDD_DTRDSR, <br>                   (FLOWCTRL( npTTYInfo ) &amp; FC_DTRDSR) &gt; 0 ) ; <br>   CheckDlgButton( hDlg, IDD_RTSCTS, <br>                   (FLOWCTRL( npTTYInfo ) &amp; FC_RTSCTS) &gt; 0 ) ; <br>   CheckDlgButton( hDlg, IDD_XONXOFF, <br>                   (FLOWCTRL( npTTYInfo ) &amp; FC_XONXOFF) &gt; 0 ) ; <br> <br>   // other TTY settings <br> <br>   CheckDlgButton( hDlg, IDD_AUTOWRAP, AUTOWRAP( npTTYInfo ) ) ; <br>   CheckDlgButton( hDlg, IDD_NEWLINE, NEWLINE( npTTYInfo ) ) ; <br>   CheckDlgButton( hDlg, IDD_LOCALECHO, LOCALECHO( npTTYInfo ) ) ; <br> <br>   // control options <br> <br>   // "Use CN_RECEIVE" is not valid under Win-32 <br> <br>   EnableWindow( GetDlgItem( hDlg, IDD_USECNRECEIVE ), FALSE ) ; <br> <br>   CheckDlgButton( hDlg, IDD_DISPLAYERRORS, DISPLAYERRORS( npTTYInfo ) ) ; <br> <br>   return ( TRUE ) ; <br> <br>} // end of SettingsDlgInit() <br> <br>//--------------------------------------------------------------------------- <br>//  BOOL NEAR SelectTTYFont( HWND hDlg ) <br>// <br>//  Description: <br>//     Selects the current font for the TTY screen. <br>//     Uses the Common Dialog ChooseFont() API. <br>// <br>//  Parameters: <br>//     HWND hDlg <br>//        handle to settings dialog <br>// <br>//--------------------------------------------------------------------------- <br> <br>BOOL NEAR SelectTTYFont( HWND hDlg ) <br>{ <br>   CHOOSEFONT  cfTTYFont ; <br>   NPTTYINFO   npTTYInfo ; <br> <br>   if (NULL == (npTTYInfo = (NPTTYINFO) GET_PROP( hDlg, ATOM_TTYINFO ))) <br>      return ( FALSE ) ; <br> <br>   cfTTYFont.lStructSize    = sizeof( CHOOSEFONT ) ; <br>   cfTTYFont.hwndOwner      = hDlg ; <br>   cfTTYFont.hDC            = NULL ; <br>   cfTTYFont.rgbColors      = FGCOLOR( npTTYInfo ) ; <br>   cfTTYFont.lpLogFont      = &amp;LFTTYFONT( npTTYInfo ) ; <br>   cfTTYFont.Flags          = CF_SCREENFONTS | CF_FIXEDPITCHONLY | <br>                              CF_EFFECTS | CF_INITTOLOGFONTSTRUCT ; <br>   cfTTYFont.lCustData      = 0 ; <br>   cfTTYFont.lpfnHook       = NULL ; <br>   cfTTYFont.lpTemplateName = NULL ; <br>   cfTTYFont.hInstance      = GETHINST( hDlg ) ; <br> <br>   if (ChooseFont( &amp;cfTTYFont )) <br>   { <br>     FGCOLOR( npTTYInfo ) = cfTTYFont.rgbColors ; <br>     ResetTTYScreen( GetParent( hDlg ), npTTYInfo ) ; <br>   } <br> <br>   return ( TRUE ) ; <br> <br>} // end of SelectTTYFont() <br> <br>//--------------------------------------------------------------------------- <br>//  BOOL NEAR SettingsDlgTerm( HWND hDlg ) <br>// <br>//  Description: <br>//     Puts dialog contents into TTY info structure. <br>// <br>//  Parameters: <br>//     HWND hDlg <br>//        handle to settings dialog <br>// <br>//  Win-32 Porting Issues: <br>//     - Baud rate requires DWORD values. <br>// <br>//--------------------------------------------------------------------------- <br> <br>BOOL NEAR SettingsDlgTerm( HWND hDlg ) <br>{ <br>   NPTTYINFO  npTTYInfo ; <br>   WORD       wSelection ; <br> <br>   if (NULL == (npTTYInfo = (NPTTYINFO) GET_PROP( hDlg, ATOM_TTYINFO ))) <br>      return ( FALSE ) ; <br> <br>   // get port selection <br> <br>   PORT( npTTYInfo ) = <br>      LOBYTE( LOWORD( SendDlgItemMessage( hDlg, IDD_PORTCB, <br>                                          CB_GETCURSEL, <br>                                          0, 0L ) ) + 1 ) ; <br>   // get baud rate selection <br> <br>   wSelection = <br>      LOWORD( SendDlgItemMessage( hDlg, IDD_BAUDCB, CB_GETCURSEL, <br>                                  0, 0L ) ) ; <br>   BAUDRATE( npTTYInfo ) = <br>      SendDlgItemMessage( hDlg, IDD_BAUDCB, CB_GETITEMDATA, <br>                          (WPARAM) wSelection, 0L ) ; <br> <br>   // get data bits selection <br> <br>   BYTESIZE( npTTYInfo ) = <br>      LOBYTE( LOWORD( SendDlgItemMessage( hDlg, IDD_DATABITSCB, <br>                                          CB_GETCURSEL, <br>                                          0, 0L ) ) + 5 ) ; <br> <br>   // get parity selection <br> <br>   wSelection = <br>      LOWORD( SendDlgItemMessage( hDlg, IDD_PARITYCB, CB_GETCURSEL, <br>                                  0, 0L ) ) ; <br>   PARITY( npTTYInfo ) = <br>      LOBYTE( LOWORD( SendDlgItemMessage( hDlg, IDD_PARITYCB, <br>                                          CB_GETITEMDATA, <br>                                          (WPARAM) wSelection, <br>                                          0L ) ) ) ; <br> <br>   // get stop bits selection <br> <br>   wSelection = <br>      LOWORD( SendDlgItemMessage( hDlg, IDD_STOPBITSCB, CB_GETCURSEL, <br>                                  0, 0L ) ) ; </code></pre>
<p>
</p>
<pre><code>STOPBITS( npTTYInfo ) = <br>      LOBYTE( LOWORD( SendDlgItemMessage( hDlg, IDD_STOPBITSCB, <br>                                          CB_GETITEMDATA, <br>                                          (WPARAM) wSelection, 0L ) ) ) ; <br> <br>   // get flow control settings <br> <br>   FLOWCTRL( npTTYInfo ) = 0 ; <br>   if (IsDlgButtonChecked( hDlg, IDD_DTRDSR )) <br>      FLOWCTRL( npTTYInfo ) |= FC_DTRDSR ; <br>   if (IsDlgButtonChecked( hDlg, IDD_RTSCTS )) <br>      FLOWCTRL( npTTYInfo ) |= FC_RTSCTS ; <br>   if (IsDlgButtonChecked( hDlg, IDD_XONXOFF )) <br>      FLOWCTRL( npTTYInfo ) |= FC_XONXOFF ; <br> <br>   // get other various settings <br> <br>   AUTOWRAP( npTTYInfo ) = IsDlgButtonChecked( hDlg, IDD_AUTOWRAP ) ; <br>   NEWLINE( npTTYInfo ) = IsDlgButtonChecked( hDlg, IDD_NEWLINE ) ; <br>   LOCALECHO( npTTYInfo ) = IsDlgButtonChecked( hDlg, IDD_LOCALECHO ) ; <br> <br>   // control options <br> <br>   USECNRECEIVE( npTTYInfo ) = IsDlgButtonChecked( hDlg, IDD_USECNRECEIVE ) ; <br>   DISPLAYERRORS( npTTYInfo ) = IsDlgButtonChecked( hDlg, IDD_DISPLAYERRORS ) ; <br> <br>   return ( TRUE ) ; <br> <br>} // end of SettingsDlgTerm() <br> <br>//--------------------------------------------------------------------------- <br>//  BOOL FAR PASCAL SettingsDlgProc( HWND hDlg, UINT uMsg, <br>//                                   WPARAM wParam, LPARAM lParam ) <br>// <br>//  Description: <br>//     This handles all of the user preference settings for <br>//     the TTY. <br>// <br>//  Parameters: <br>//     same as all dialog procedures <br>// <br>//  Win-32 Porting Issues: <br>//     - npTTYInfo is a DWORD in Win-32. <br>// <br>//--------------------------------------------------------------------------- <br> <br>BOOL FAR PASCAL SettingsDlgProc( HWND hDlg, UINT uMsg, <br>                                 WPARAM wParam, LPARAM lParam ) <br>{ <br>   switch (uMsg) <br>   { <br>      case WM_INITDIALOG: <br>      { <br>         NPTTYINFO  npTTYInfo ; <br> <br>         // get &amp; save pointer to TTY info structure <br> <br>         npTTYInfo = (NPTTYINFO) lParam ; <br> <br>         SET_PROP( hDlg, ATOM_TTYINFO, (HANDLE) npTTYInfo ) ; <br> <br>         return ( SettingsDlgInit( hDlg ) ) ; <br>      } <br> <br>      case WM_COMMAND: <br>         switch ( LOWORD( wParam )) <br>         { <br>            case IDD_FONT: <br>               return ( SelectTTYFont( hDlg ) ) ; <br> <br>            case IDD_OK: <br>               // Copy stuff into structure <br>               SettingsDlgTerm( hDlg ) ; <br>               EndDialog( hDlg, TRUE ) ; <br>               return ( TRUE ) ; <br> <br>            case IDD_CANCEL: <br>               // Just end <br>               EndDialog( hDlg, TRUE ) ; <br>               return ( TRUE ) ; <br>         } <br>         break; <br> <br>      case WM_DESTROY: <br>         REMOVE_PROP( hDlg, ATOM_TTYINFO ) ; <br>         break ; <br>   } <br>   return ( FALSE ) ; <br> <br>} // end of SettingsDlgProc() <br> <br>//************************************************************************ <br>//  DWORD FAR PASCAL CommWatchProc( LPSTR lpData ) <br>// <br>//  Description: <br>//     A secondary thread that will watch for COMM events. <br>// <br>//  Parameters: <br>//     LPSTR lpData <br>//        32-bit pointer argument <br>// <br>//  Win-32 Porting Issues: <br>//     - Added this thread to watch the communications device and <br>//       post notifications to the associated window. <br>// <br>//************************************************************************ <br> <br>DWORD FAR PASCAL CommWatchProc( LPSTR lpData ) <br>{ <br>   DWORD       dwEvtMask ; <br>   NPTTYINFO   npTTYInfo = (NPTTYINFO) lpData ; <br>   OVERLAPPED  os ; <br>int        nLength ; <br>   BYTE       abIn[ MAXBLOCK + 1] ; <br> <br>   memset( &amp;os, 0, sizeof( OVERLAPPED ) ) ; <br> <br>   // create I/O event used for overlapped read <br> <br>   os.hEvent = CreateEvent( NULL,    // no security <br>                            TRUE,    // explicit reset req <br>                            FALSE,   // initial event reset <br>                            NULL ) ; // no name <br>   if (os.hEvent == NULL) <br>   { <br>      MessageBox( NULL, "Failed to create event for thread!", "TTY Error!", <br>                  MB_ICONEXCLAMATION | MB_OK ) ; <br>      return ( FALSE ) ; <br>   } <br> <br>   if (!SetCommMask( COMDEV( npTTYInfo ), EV_RXCHAR )) <br>      return ( FALSE ) ; <br> <br>   while ( CONNECTED( npTTYInfo ) ) <br>   { <br>      dwEvtMask = 0 ; <br> <br>      WaitCommEvent( COMDEV( npTTYInfo ), &amp;dwEvtMask, NULL ); <br> <br>      if ((dwEvtMask &amp; EV_RXCHAR) == EV_RXCHAR) <br>      { <br>         do <br>         { <br>            if (nLength = ReadCommBlock( hTTYWnd, (LPSTR) abIn, MAXBLOCK )) <br>            { <br>               WriteTTYBlock( hTTYWnd, (LPSTR) abIn, nLength ) ; <br> <br>               // force a paint <br> <br>               UpdateWindow( hTTYWnd ) ; <br>            } <br>         } <br>         while ( nLength &gt; 0 ) ; <br>      } <br>   } <br> <br>   // get rid of event handle <br> <br>   CloseHandle( os.hEvent ) ; <br> <br>   // clear information in structure (kind of a "we're done flag") <br> <br>   THREADID( npTTYInfo ) = 0 ; <br>   HTHREAD( npTTYInfo ) = NULL ; <br> <br>   return( TRUE ) ; <br> <br>} // end of CommWatchProc() <br> <br> <br>//--------------------------------------------------------------------------- <br>//  End of File: tty.c <br>//--------------------------------------------------------------------------- </code></pre>
<p>&nbsp;</p></body>
</HTML>
