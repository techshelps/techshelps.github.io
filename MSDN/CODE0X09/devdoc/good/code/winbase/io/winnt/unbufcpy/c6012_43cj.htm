<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>UNBUFCP1.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6013"></a>UNBUFCP1.C</h2>
<pre><code>/*++ <br> <br>Copyright 1994 - 1998 Microsoft Corporation <br> <br>Module Name: <br> <br>    unbufcp1.c <br> <br>Abstract: <br> <br>    This single-threaded version shows how to multiplex I/O to a number of files with  <br>    a single thread. This is the most efficient mechanism if you do not need the  <br>    asynchronous completion model that the dual-threaded version offers. <br> <br>    Only one thread and one I/O completion port is used. The file handles for the <br>    source and destination file are both associated with the same port.  The <br>    thread starts off by posting a number of overlapped <br>    reads from the source file.  It then waits on the I/O completion port. <br>    Whenever a read completes, it immediately turns it around into a write to <br>    the destination file. Whenever a write completes, it immediately posts the <br>    next read from the source file. <br> <br>    Thread 1 <br>       | <br>       | <br>    kick off a few <br>    overlapped reads <br>       | <br>       | <br>  -&gt;GetQueuedCompletionStatus(WritePort) &lt;----------- <br>  |    |                                            | <br>  |    |-------------------------------             | <br>  |    |                              |             | <br>  | write has completed,      read has completed,   | <br>  | kick off another          kick off the write.   | <br>  | read                              |             | <br>  |    |                              |             | <br>  |____|                              |_____________| <br> <br>Author: <br> <br>    John Vert (jvert) 21-Dec-1994 <br> <br>Revision History: <br>   <br>    24-Apr-1995       Brian Sherrell (briansh) - Added platform detection &amp;  <br>                      I/O Completion Port creation with INVALID_HANDLE_VALUE. <br> <br>    22-March-1996     Brian Sherrell (briansh) - Pending I/O bug fix. <br> <br> 3-Apr-1996       Brian Sherrell (briansh) - Correct versioning logic. <br> <br>--*/ <br>#include &lt;windows.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;ctype.h&gt; <br> <br>// <br>// File handles for the copy operation. All read operations are <br>// from SourceFile. All write operations are to DestFile. <br>// <br>HANDLE SourceFile; <br>HANDLE DestFile; <br> <br>// <br>//version information <br>// <br>OSVERSIONINFO     ver; <br> <br>// <br>// I/O completion port. All read and writes to the files complete <br>// to this port. <br>// <br>HANDLE IoPort; <br> <br>// <br>// Key values used to determine whether a read or a write <br>// has completed. <br>// <br>#define ReadKey 0 <br>#define WriteKey 1 <br> <br>// <br>// Structure used to track each outstanding I/O. The maximum <br>// number of I/Os that will be outstanding at any time is <br>// controllable by the MAX_CONCURRENT_IO definition. <br>// <br> <br>#define MAX_CONCURRENT_IO 20 <br> <br>typedef struct _COPY_CHUNK { <br>    OVERLAPPED Overlapped; <br>    LPVOID Buffer; <br>} COPY_CHUNK, *PCOPY_CHUNK; <br> <br>COPY_CHUNK CopyChunk[MAX_CONCURRENT_IO]; <br> <br>// <br>// Define the size of the buffers used to do the I/O. <br>// 64K is a nice number. <br>// <br>#define BUFFER_SIZE (64*1024) <br> <br>// <br>// The system's page size will always be a multiple of the <br>// sector size. Do all I/Os in page-size chunks. <br>// <br>DWORD PageSize; <br> <br> <br>// <br>// Local function prototype <br>// <br>VOID <br>CopyLoop( <br>    ULARGE_INTEGER FileSize <br>    ); <br> <br>int <br>_CRTAPI1 <br>main( <br>    int argc, <br>    char *argv[], <br>    char *envp <br>    ) <br>{ <br>    ULARGE_INTEGER FileSize; <br>    ULARGE_INTEGER InitialSize; <br>    BOOL Success; <br>    DWORD Status; <br>    DWORD StartTime, EndTime; <br>    SYSTEM_INFO SystemInfo; <br>    HANDLE BufferedHandle; <br>     <br>    if (argc != 3) { <br>        fprintf(stderr, "Usage: %s SourceFile DestinationFile\n", argv[0]); <br>        exit(1); <br>    } <br> <br>    // <br>    //confirm we are running on Windows NT 3.5 or greater, if not, display notice and  <br>    //terminate.  Completion ports are only supported on Win32 &amp; Win32s.  Creating a  <br>    //Completion port with no handle specified is only supported on NT 3.51, so we need  <br>    //to know what we're running on.  Note, Win32s does not support console apps, thats  <br>    //why we exit here if we are not on Windows NT. <br>    // <br>    // <br>    //ver.dwOSVersionInfoSize needs to be set before calling GetVersionInfoEx() <br>    // <br>    ver.dwOSVersionInfoSize = sizeof(OSVERSIONINFO); <br> <br>    // <br>    //Failure here could mean several things 1. On an NT system,  <br>    //it indicates NT version 3.1 because GetVersionEx() is only  <br>    //implemented on NT 3.5.  2. On Windows 3.1 system, it means  <br>    //either Win32s version 1.1 or 1.0 is installed. <br>    // <br>    Success = GetVersionEx((LPOSVERSIONINFO) &amp;ver); <br> <br>    if ( (!Success) ||                                   //GetVersionEx() failed - see above. <br>         (ver.dwPlatformId != VER_PLATFORM_WIN32_NT) )   //GetVersionEx() succeeded but we are not on NT. <br>      { <br>       MessageBox(NULL, <br>                  "This sample application can only be run on Windows NT. 3.5 or greater\n" <br>                  "This application will now terminate.", <br>                  "UnBufCp1", <br>                  MB_OK           |  <br>                  MB_ICONSTOP     |  <br>                  MB_SETFOREGROUND ); <br>       exit( 1 ); <br>      } <br> <br> <br>    // <br>    // Get the system's page size. <br>    // <br>    GetSystemInfo(&amp;SystemInfo); <br>    PageSize = SystemInfo.dwPageSize; <br> <br>    // <br>    // Open the source file and create the destination file. <br>    // Use FILE_FLAG_NO_BUFFERING to avoid polluting the <br>    // system cache with two copies of the same data. <br>    // <br> <br>    SourceFile = CreateFile(argv[1], <br>                            GENERIC_READ | GENERIC_WRITE, <br>                            FILE_SHARE_READ, <br>                            NULL, <br>                            OPEN_EXISTING, <br>                            FILE_FLAG_NO_BUFFERING | FILE_FLAG_OVERLAPPED, <br>                            NULL); <br>    if (SourceFile == INVALID_HANDLE_VALUE) { <br>        fprintf(stderr, "failed to open %s, error %d\n", argv[1], GetLastError()); <br>        exit(1); <br>    } <br>    FileSize.LowPart = GetFileSize(SourceFile, &amp;FileSize.HighPart); <br>    if ((FileSize.LowPart == 0xffffffff) &amp;&amp; (GetLastError() != NO_ERROR)) { <br>        fprintf(stderr, "GetFileSize failed, error %d\n", GetLastError()); <br>        exit(1); <br>    } <br> <br>    DestFile = CreateFile(argv[2], <br>                          GENERIC_READ | GENERIC_WRITE, <br>                          FILE_SHARE_READ | FILE_SHARE_WRITE, <br>                          NULL, <br>                          CREATE_ALWAYS, <br>                          FILE_FLAG_NO_BUFFERING | FILE_FLAG_OVERLAPPED, <br>                          SourceFile); <br>    if (DestFile == INVALID_HANDLE_VALUE) { <br>        fprintf(stderr, "failed to open %s, error %d\n", argv[2], GetLastError()); <br>        exit(1); <br>    } <br> <br>    // <br>    // Extend the destination file so that the filesystem does not <br>    // turn our asynchronous writes into synchronous ones. <br>    // <br>    InitialSize.QuadPart = (FileSize.QuadPart + PageSize - 1) &amp; ~(PageSize-1); <br>    Status = SetFilePointer(DestFile, <br>                            InitialSize.LowPart, <br>                            (PLONG)&amp;InitialSize.HighPart, <br>                            FILE_BEGIN); <br>    if ((Status == 0xffffffff) &amp;&amp; (GetLastError() != NO_ERROR)) { <br>        fprintf(stderr, "initial SetFilePointer failed, error %d\n", GetLastError()); <br>        exit(1); <br>    } <br>    Success = SetEndOfFile(DestFile); <br>    if (!Success) { <br>        fprintf(stderr, "SetEndOfFile failed, error %d\n", GetLastError()); <br>        exit(1); <br>    } <br> <br>    // <br>    //In NT 3.51 it is not necessary to specify the FileHandle parameter <br>    //of CreateIoCompletionPort()--It is legal to specify the FileHandle <br>    //as INVALID_HANDLE_VALUE.  However, for NT 3.5 an overlapped file <br>    //handle is needed. <br>    // <br>    //We know already that we are running on NT, or else we wouldn't have <br>    //gotten this far, so lets see what version we are running on. <br>    // <br>    if (ver.dwMajorVersion == 3 &amp;&amp; ver.dwMinorVersion == 50) //we're running on NT 3.5 - Completion Ports exists. <br>      IoPort = CreateIoCompletionPort(SourceFile,            //file handle to associate with I/O completion port.                        <br>                                      NULL,                  //optional handle to existing I/O completion port. <br>                                      ReadKey,               //completion key. <br>                                      1);                    //# of threads allowed to execute concurrently. <br>    else                                                  <br>        { <br>          //                                                 //we are running on NT 3.51 or greater       <br>          //Create the I/O Completion Port <br>          // <br>          IoPort = CreateIoCompletionPort(INVALID_HANDLE_VALUE,//file handle to associate with I/O completion port <br>                                          NULL,                //optional handle to existing I/O completion port <br>                                          ReadKey,             //completion key <br>                                          1);                  //# of threads allowed to execute concurrently <br>   <br>    <br>          if (IoPort == NULL) { <br>            fprintf(stderr, "failed to create ReadPort, error %d\n", GetLastError()); <br>            exit(1); <br>          } <br> <br>         // <br>         //If we need to, aka we're running on NT 3.51, let's associate a file handle with the <br>         //completion port. <br>         // <br>     <br>         IoPort = CreateIoCompletionPort(SourceFile, <br>                                         IoPort, <br>                                         ReadKey,             <br>                                         1); <br> <br>         if (IoPort == NULL) <br>           { <br>             fprintf(stderr, <br>                     "failed to create IoPort, error %d\n",  <br>                     GetLastError()); <br> <br>             exit(1); <br> <br>           } <br>        } <br>     <br>    // <br>    // Associate the destination file handle with the <br>    // I/O completion port. <br>    // <br>     <br>    IoPort = CreateIoCompletionPort(DestFile, <br>                                    IoPort, <br>                                    WriteKey, <br>                                    1); <br>    if (IoPort == NULL) { <br>        fprintf(stderr, "failed to create WritePort, error %d\n", GetLastError()); <br>        exit(1); <br>    } <br> <br>     <br> <br>    StartTime = GetTickCount(); <br> <br>    // <br>    // Do the copy <br>    // <br>    CopyLoop(FileSize); <br> <br>    EndTime = GetTickCount(); <br> <br>    CloseHandle(SourceFile); <br>    CloseHandle(DestFile); <br> <br>    // <br>    // We need another handle to the destination file that is <br>    // opened without FILE_FLAG_NO_BUFFERING. This allows us to set <br>    // the end-of-file marker to a position that is not sector-aligned. <br>    // <br>    BufferedHandle = CreateFile(argv[2], <br>                                GENERIC_WRITE, <br>                                FILE_SHARE_READ | FILE_SHARE_WRITE, <br>                                NULL, <br>                                OPEN_EXISTING, <br>                                0, <br>                                NULL); <br>    if (BufferedHandle == INVALID_HANDLE_VALUE) { <br>        fprintf(stderr, <br>                "failed to open buffered handle to %s, error %d\n", <br>                argv[2], <br>                GetLastError()); <br>        exit(1); <br>    } <br> <br> <br>    // <br>    // Set the destination's file size to the size of the <br>    // source file, in case the size of the source file was <br>    // not a multiple of the page size. <br>    // <br>    Status = SetFilePointer(BufferedHandle, <br>                            FileSize.LowPart, <br>                            (PLONG)&amp;FileSize.HighPart, <br>                            FILE_BEGIN); <br>    if ((Status == 0xffffffff) &amp;&amp; (GetLastError() != NO_ERROR)) { <br>        fprintf(stderr, "final SetFilePointer failed, error %d\n", GetLastError()); <br>        exit(1); <br>    } <br>    Success = SetEndOfFile(BufferedHandle); <br>    if (!Success) { <br>        fprintf(stderr, "SetEndOfFile failed, error %d\n", GetLastError()); <br>        exit(1); <br>    } <br>    CloseHandle(BufferedHandle); <br> <br>    printf("%d bytes copied in %.3f seconds\n", <br>           FileSize.LowPart, <br>           (float)(EndTime-StartTime)/1000.0); <br>    printf("%.2f MB/sec\n", <br>           ((LONGLONG)FileSize.QuadPart/(1024.0*1024.0)) / (((float)(EndTime-StartTime)) / 1000.0)); <br> <br>    return(0); <br> <br>} <br> <br>VOID <br>CopyLoop( <br>    ULARGE_INTEGER FileSize <br>    ) <br>{ <br>    ULARGE_INTEGER ReadPointer; <br>    BOOL Success; <br>    DWORD NumberBytes; <br>    LPOVERLAPPED CompletedOverlapped; <br>    DWORD Key; <br>    PCOPY_CHUNK Chunk; <br>    int PendingIO = 0; <br>    int i; <br> <br>    // <br>    // Start reading the file. Kick off MAX_CONCURRENT_IO reads, then just <br>    // loop waiting for I/O to complete. <br>    // <br>    ReadPointer.QuadPart = 0; <br> <br>    for (i=0; i &lt; MAX_CONCURRENT_IO; i++) { <br>        if (ReadPointer.QuadPart &gt;= FileSize.QuadPart) { <br>            break; <br>        } <br>        // <br>        // Use VirtualAlloc so we get a page-aligned buffer suitable <br>        // for unbuffered I/O. <br>        // <br>        CopyChunk[i].Buffer = VirtualAlloc(NULL, <br>                                           BUFFER_SIZE, <br>                                           MEM_COMMIT, <br>                                           PAGE_READWRITE); <br>        if (CopyChunk[i].Buffer == NULL) { <br>            fprintf(stderr, "VirtualAlloc %d failed, error %d\n",i, GetLastError()); <br>            exit(1); <br>        } <br>        CopyChunk[i].Overlapped.Offset = ReadPointer.LowPart; <br>        CopyChunk[i].Overlapped.OffsetHigh = ReadPointer.HighPart; <br>        CopyChunk[i].Overlapped.hEvent = NULL;     // not needed <br> <br>        Success = ReadFile(SourceFile, <br>                           CopyChunk[i].Buffer, <br>                           BUFFER_SIZE, <br>                           &amp;NumberBytes, <br>                           &amp;CopyChunk[i].Overlapped); <br> <br>        if (!Success &amp;&amp; (GetLastError() != ERROR_IO_PENDING)) { <br>            fprintf(stderr, <br>                    "ReadFile at %lx failed, error %d\n", <br>                    ReadPointer.LowPart, <br>                    GetLastError()); <br>        } else { <br>            ReadPointer.QuadPart += BUFFER_SIZE; <br>            ++PendingIO; <br>        } <br>    } <br> <br>    // <br>    // We have started the initial async. reads, enter the main loop. <br>    // This simply waits until an I/O completes, then issues the next <br>    // I/O.  When a write completes, the next read is issued. When a <br>    // read completes, the corresponding write is issued. <br>    // <br>    while (PendingIO) { <br>        Success = GetQueuedCompletionStatus(IoPort, <br>                                            &amp;NumberBytes, <br>                                            &amp;Key, <br>                                            &amp;CompletedOverlapped, <br>                                            (DWORD)-1); <br>        if (!Success &amp;&amp; (CompletedOverlapped == NULL)) { <br>            // <br>            // The call has failed. <br>            // <br>            fprintf(stderr, <br>                    "GetQueuedCompletionStatus on the IoPort failed, error %d\n", <br>                    GetLastError()); <br>            exit(1); <br>        } <br>        if (!Success) { <br>            // <br>            // The call has succeeded, but the initial I/O operation <br>            // has failed. <br>            // <br>            fprintf(stderr, <br>                    "GetQueuedCompletionStatus on the IoPort removed a failed\n" <br>                    "I/O packet, error %d\n",GetLastError()); <br>            // <br>            // This is probably bad, but what the heck, it's only a demo program, <br>            // so proceed blindly ahead. <br>            // <br>        } <br> <br>        Chunk = (PCOPY_CHUNK)CompletedOverlapped; <br> <br>        if (Key == ReadKey) { <br> <br>            // <br>            // A read has completed, issue the corresponding write. <br>            // <br> <br>            // <br>            // Round the number of bytes to write up to a sector boundary. <br>            // <br>            NumberBytes = (NumberBytes + PageSize - 1) &amp; ~(PageSize-1); <br> <br>            Success = WriteFile(DestFile, <br>                                Chunk-&gt;Buffer, <br>                                NumberBytes, <br>                                &amp;NumberBytes, <br>                                &amp;Chunk-&gt;Overlapped); <br> <br>            if (!Success &amp;&amp; (GetLastError() != ERROR_IO_PENDING)) <br>                fprintf(stderr, <br>                        "WriteFile at %lx failed, error %d\n", <br>                        Chunk-&gt;Overlapped.Offset, <br>                        GetLastError()); <br>             <br>            // <br>            // decrement pending I/O count <br>            // <br>            --PendingIO;  <br>             <br>        } else if (Key == WriteKey) { <br> <br>            // <br>            // A write has completed, issue the next read. <br>            // <br> <br>            if (ReadPointer.QuadPart &lt; FileSize.QuadPart) { <br>                Chunk-&gt;Overlapped.Offset = ReadPointer.LowPart; <br>                Chunk-&gt;Overlapped.OffsetHigh = ReadPointer.HighPart; <br>                ReadPointer.QuadPart += BUFFER_SIZE; <br>                Success = ReadFile(SourceFile, <br>                                   Chunk-&gt;Buffer, <br>                                   NumberBytes, <br>                                   &amp;NumberBytes, <br>                                   &amp;Chunk-&gt;Overlapped); <br>                if (!Success &amp;&amp; (GetLastError() != ERROR_IO_PENDING)) { <br>                    fprintf(stderr, <br>                            "ReadFile at %lx failed, error %d\n", <br>                            Chunk-&gt;Overlapped.Offset, <br>                            GetLastError()); <br>                } <br>            } else { <br>                // <br>                // There are no more reads left to issue, just <br>                // wait for the pending writes to drain. <br>                // <br>                --PendingIO; <br>            } <br>        } <br>    } <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
