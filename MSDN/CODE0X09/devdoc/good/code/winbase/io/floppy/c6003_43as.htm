<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>MFMT.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6004"></a>MFMT.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples.  <br>*       Copyright 1993 - 1998 Microsoft Corporation. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>/*++ <br> <br>Module Name: <br> <br>    mfmt.c <br> <br>Abstract: <br> <br>    This program is designed to show how to access a physical floppy <br>    disk using the Win32 API set. <br> <br>    This program has two major functions. <br> <br>        - It can be used to display the geometry of a disk <br> <br>            mfmt -g a: <br> <br>        - It can be used to produce a disk image, or to write a disk <br>          image to a floppy. <br> <br>            mfmt -c a: bootdisk         - produce a disk image of a: <br> <br>            mfmt -c bootdisk a:         - make a: identical to bootdisk image <br> <br>    This program is very very simple. Minimal error checking is done. It is <br>    meant to provide an example of how to: <br> <br>        - Open a physical disk <br> <br>        - Read a disk's geometry <br> <br>        - Perform a low level format operation <br> <br>        - read and write physical sectors <br> <br>--*/ <br> <br>#include &lt;stdlib.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;windows.h&gt; <br>#include &lt;winioctl.h&gt; <br>#include &lt;string.h&gt; <br>#include &lt;ctype.h&gt; <br>#include &lt;memory.h&gt; <br> <br>DISK_GEOMETRY SupportedGeometry[20]; <br>DWORD SupportedGeometryCount; <br> <br>BOOL <br>GetDiskGeometry( <br>    HANDLE hDisk, <br>    PDISK_GEOMETRY lpGeometry <br>    ) <br> <br>{ <br>    DWORD ReturnedByteCount; <br> <br>    return DeviceIoControl( <br>                hDisk, <br>                IOCTL_DISK_GET_DRIVE_GEOMETRY, <br>                NULL, <br>                0, <br>                lpGeometry, <br>                sizeof(*lpGeometry), <br>                &amp;ReturnedByteCount, <br>                NULL <br>                ); <br>} <br> <br>DWORD <br>GetSupportedGeometrys( <br>    HANDLE hDisk <br>    ) <br>{ <br>    DWORD ReturnedByteCount; <br>    BOOL b; <br>    DWORD NumberSupported; <br> <br>    b = DeviceIoControl( <br>                hDisk, <br>                IOCTL_DISK_GET_MEDIA_TYPES, <br>                NULL, <br>                0, <br>                SupportedGeometry, <br>                sizeof(SupportedGeometry), <br>                &amp;ReturnedByteCount, <br>                NULL <br>                ); <br>    if ( b ) { <br>        NumberSupported = ReturnedByteCount / sizeof(DISK_GEOMETRY); <br>        } <br>    else { <br>        NumberSupported = 0; <br>        } <br>    SupportedGeometryCount = NumberSupported; <br> <br>    return NumberSupported; <br>} <br> <br>VOID <br>PrintGeometry( <br>    LPSTR lpDriveName, <br>    PDISK_GEOMETRY lpGeometry <br>    ) <br>{ <br>    LPSTR MediaType; <br> <br>    if (lpDriveName) { <br>        printf("Geometry for Drive %s\n",lpDriveName); <br>        } <br> <br>    switch ( lpGeometry-&gt;MediaType ) { <br>        case F5_1Pt2_512:  MediaType = "5.25, 1.2MB,  512 bytes/sector";break; <br>        case F3_1Pt44_512: MediaType = "3.5,  1.44MB, 512 bytes/sector";break; <br>        case F3_2Pt88_512: MediaType = "3.5,  2.88MB, 512 bytes/sector";break; <br>        case F3_20Pt8_512: MediaType = "3.5,  20.8MB, 512 bytes/sector";break; <br>        case F3_720_512:   MediaType = "3.5,  720KB,  512 bytes/sector";break; <br>        case F5_360_512:   MediaType = "5.25, 360KB,  512 bytes/sector";break; <br>        case F5_320_512:   MediaType = "5.25, 320KB,  512 bytes/sector";break; <br>        case F5_320_1024:  MediaType = "5.25, 320KB,  1024 bytes/sector";break; <br>        case F5_180_512:   MediaType = "5.25, 180KB,  512 bytes/sector";break; <br>        case F5_160_512:   MediaType = "5.25, 160KB,  512 bytes/sector";break; <br>        case RemovableMedia: MediaType = "Removable media other than floppy";break; <br>        case FixedMedia:   MediaType = "Fixed hard disk media";break; <br>        default:           MediaType = "Unknown";break; <br>    } <br>    printf("    Media Type %s\n",MediaType); <br>    printf("    Cylinders %d Tracks/Cylinder %d Sectors/Track %d\n", <br>        lpGeometry-&gt;Cylinders.LowPart, <br>        lpGeometry-&gt;TracksPerCylinder, <br>        lpGeometry-&gt;SectorsPerTrack <br>        ); <br>} <br> <br>BOOL <br>LowLevelFormat( <br>    HANDLE hDisk, <br>    PDISK_GEOMETRY lpGeometry <br>    ) <br>{ <br>    FORMAT_PARAMETERS FormatParameters; <br>    PBAD_TRACK_NUMBER lpBadTrack; <br>    UINT i; <br>    BOOL b; <br>    DWORD ReturnedByteCount; <br> <br>    FormatParameters.MediaType = lpGeometry-&gt;MediaType; <br>    FormatParameters.StartHeadNumber = 0; <br>    FormatParameters.EndHeadNumber = lpGeometry-&gt;TracksPerCylinder - 1; <br>    lpBadTrack = (PBAD_TRACK_NUMBER) LocalAlloc(LMEM_ZEROINIT,lpGeometry-&gt;TracksPerCylinder*sizeof(*lpBadTrack)); <br> <br>    for (i = 0; i &lt; lpGeometry-&gt;Cylinders.LowPart; i++) { <br> <br>        FormatParameters.StartCylinderNumber = i; <br>        FormatParameters.EndCylinderNumber = i; <br> <br>        b = DeviceIoControl( <br>                hDisk, <br>                IOCTL_DISK_FORMAT_TRACKS, <br>                &amp;FormatParameters, <br>                sizeof(FormatParameters), <br>                lpBadTrack, <br>                lpGeometry-&gt;TracksPerCylinder*sizeof(*lpBadTrack), <br>                &amp;ReturnedByteCount, <br>                NULL <br>                ); <br> <br>        if (!b ) { <br>            LocalFree(lpBadTrack); <br>            return b; <br>            } <br>        } <br> <br>    LocalFree(lpBadTrack); <br> <br>    return TRUE; <br>} <br> <br>BOOL <br>LockVolume( <br>    HANDLE hDisk <br>    ) <br>{ <br>    DWORD ReturnedByteCount; <br> <br>    return DeviceIoControl( <br>                hDisk, <br>                FSCTL_LOCK_VOLUME, <br>                NULL, <br>                0, <br>                NULL, <br>                0, <br>                &amp;ReturnedByteCount, <br>                NULL <br>                ); <br>} <br> <br>BOOL <br>UnlockVolume( <br>    HANDLE hDisk <br>    ) <br>{ <br>    DWORD ReturnedByteCount; <br> <br>    return DeviceIoControl( <br>                hDisk, <br>                FSCTL_UNLOCK_VOLUME, <br>                NULL, <br>                0, <br>                NULL, <br>                0, <br>                &amp;ReturnedByteCount, <br>                NULL <br>                ); <br>} <br> <br>BOOL <br>DismountVolume( <br>    HANDLE hDisk <br>    ) <br>{ <br>    DWORD ReturnedByteCount; <br> <br>    return DeviceIoControl( <br>                hDisk, <br>                FSCTL_DISMOUNT_VOLUME, <br>                NULL, <br>                0, <br>                NULL, <br>                0, <br>                &amp;ReturnedByteCount, <br>                NULL <br>                ); <br>} <br> <br>DWORD <br>_cdecl <br>main( <br>    int argc, <br>    char *argv[], <br>    char *envp[] <br>    ) <br>{ <br>    char Drive[MAX_PATH]; <br>    HANDLE hDrive, hDiskImage; <br>    DISK_GEOMETRY Geometry; <br>    UINT i; <br>    char c, *p; <br>    LPSTR DriveName; <br>    BOOL fUsage = TRUE; <br>    BOOL fShowGeometry = FALSE; <br>    BOOL fDiskImage = FALSE; <br>    BOOL SourceIsDrive; <br>    LPSTR Source, Destination, DiskImage; <br> <br>    if ( argc &gt; 1 ) { <br>        fUsage = FALSE; <br>        while (--argc &gt; 0 ) { <br>            p = *++argv; <br>            if (*p == '/' || *p == '-') { <br>                while (c = *++p) <br>                switch (toupper( c )) { <br>                case '?': <br>                    fUsage = TRUE; <br>                    break; <br> <br>                case 'C': <br>                    fDiskImage = TRUE; <br>                    argc--, argv++; <br>                    Source = *argv; <br>                    argc--, argv++; <br>                    Destination = *argv; <br>                    break; <br> <br>                case 'G': <br>                    argc--, argv++; <br>                    if ( (DriveName = *argv ) &amp;&amp; *DriveName &amp;&amp;  <br>                         isalpha(*DriveName) ) <br>                        fShowGeometry = TRUE; <br>                    else <br>                                                { <br>                        printf( "MFMT: Missing drive letter after -G\n" ); <br>                                    DriveName = NULL; <br>                        fUsage = TRUE; <br>                        } <br>                            break; <br> <br>                default: <br>                    printf("MFMT: Invalid switch - /%c\n", c ); <br>                    fUsage = TRUE; <br>                    break; <br>                    } <br>                } <br>            } <br>        } <br> <br>    if ( fUsage ) { <br>        printf("usage: MFMT switches \n" ); <br>        printf("            [-?] display this message\n" ); <br>        printf("            [-g drive] shows disk geometry\n" ); <br>        printf("            [-c source destination] produce diskimage\n" ); <br>        ExitProcess(1); <br>        } <br> <br>    if ( fShowGeometry ) { <br>        sprintf(Drive,"\\\\.\\%s",DriveName); <br>        hDrive = CreateFile( <br>                    Drive, <br>                    GENERIC_READ | GENERIC_WRITE, <br>                    FILE_SHARE_READ|FILE_SHARE_WRITE, <br>                    NULL, <br>                    OPEN_EXISTING, <br>                    0, <br>                    NULL <br>                    ); <br>        if ( hDrive == INVALID_HANDLE_VALUE ) { <br>            printf("MFMT: Open %s failed %d\n",DriveName,GetLastError()); <br>            ExitProcess(1); <br>            } <br> <br>        if ( LockVolume(hDrive) == FALSE ) { <br>            printf("MFMT:Locking volume %s failed %d\n", DriveName, GetLastError()); <br>            ExitProcess(1); <br>            } <br> <br>        if ( !GetDiskGeometry(hDrive,&amp;Geometry) ) { <br>            printf("MFMT: GetDiskGeometry %s failed %d\n",DriveName,GetLastError()); <br>            ExitProcess(1); <br>            } <br>        PrintGeometry(DriveName,&amp;Geometry); <br> <br>        if ( !GetSupportedGeometrys(hDrive) ) { <br>            printf("MFMT: GetSupportedGeometrys %s failed %d\n",DriveName,GetLastError()); <br>            ExitProcess(1); <br>            } <br>        printf("\nDrive %s supports the following disk geometries\n",DriveName); <br> <br>        for(i=0;i&lt;SupportedGeometryCount;i++) { <br>            printf("\n"); <br>            PrintGeometry(NULL,&amp;SupportedGeometry[i]); <br>            } <br> <br>        printf("\n"); <br>        ExitProcess(0); <br>        } <br> <br>    if ( fDiskImage ) { <br>        SourceIsDrive = FALSE; <br>        if ( Source[strlen(Source)-1] == ':' ) { <br>            SourceIsDrive = TRUE; <br>            sprintf(Drive,"\\\\.\\%s",Source); <br>            DriveName=Source; <br>            DiskImage = Destination; <br>            } <br>        if ( Destination[strlen(Destination)-1] == ':' ) { <br>            if ( SourceIsDrive ) { <br>                printf("MFMT: Source and Destination cannot both be drives\n"); <br>                ExitProcess(1); <br>                } <br>            SourceIsDrive = FALSE; <br>            sprintf(Drive,"\\\\.\\%s",Destination); <br>            DriveName=Destination; <br>            DiskImage = Source; <br>            } <br>        else { <br>            if ( !SourceIsDrive ) { <br>                printf("MFMT: Either Source or Destination must be a drive\n"); <br>                ExitProcess(1); <br>                } <br>            } <br> <br>        // <br>        // Open and Lock the drive <br>        // <br> <br>        hDrive = CreateFile( <br>                    Drive, <br>                    GENERIC_READ | GENERIC_WRITE, <br>                    FILE_SHARE_READ|FILE_SHARE_WRITE, <br>                    NULL, <br>                    OPEN_EXISTING, <br>                    0, <br>                    NULL <br>                    ); <br>        if ( hDrive == INVALID_HANDLE_VALUE ) { <br>            printf("MFMT: Open %s failed %d\n",DriveName,GetLastError()); <br>            ExitProcess(1); <br>            } <br>        if ( LockVolume(hDrive) == FALSE ) { <br>            printf("MFMT: LockVolume %s failed %d\n",DriveName,GetLastError()); <br>            ExitProcess(1); <br>            } <br> <br>        if ( !GetDiskGeometry(hDrive,&amp;Geometry) ) { <br>            printf("MFMT: GetDiskGeometry %s failed %d\n",DriveName,GetLastError()); <br>            ExitProcess(1); <br>            } <br> <br>        if ( !GetSupportedGeometrys(hDrive) ) { <br>            printf("MFMT: GetSupportedGeometrys %s failed %d\n",DriveName,GetLastError()); <br>            ExitProcess(1); <br>            } <br> <br>        // <br>        // Open the disk image file <br>        // <br> <br>        hDiskImage = CreateFile( <br>                        DiskImage, <br>                        GENERIC_READ | GENERIC_WRITE, <br>                        0, <br>                        NULL, <br>                        SourceIsDrive ? CREATE_ALWAYS : OPEN_EXISTING, <br>                        0, <br>                        NULL <br>                        ); <br>        if ( hDiskImage == INVALID_HANDLE_VALUE ) { <br>            printf("MFMT: Open %s failed %d\n",DiskImage,GetLastError()); <br>            ExitProcess(1); <br>            } <br> <br>        // <br>        // Now do the copy <br>        // <br>        { <br>            LPVOID IoBuffer; <br>            BOOL b; <br>            DWORD BytesRead, BytesWritten; <br>            DWORD FileSize; <br>            DWORD VirtBufSize; <br>            DWORD NumBufs; <br> <br>            // <br>            // If we are copying from floppy to file, just do the copy <br>            // Otherwise, we might have to format the floppy first <br>            // <br> <br>            if ( SourceIsDrive ) { <br> <br>                // <br>                // Device reads must be sector aligned. VirtualAlloc will <br>                // garuntee alignment <br>                // <br> <br>                NumBufs = Geometry.Cylinders.LowPart; <br>                VirtBufSize =  Geometry.TracksPerCylinder * <br>                               Geometry.SectorsPerTrack * <br>                               Geometry.BytesPerSector; <br> <br>                IoBuffer = VirtualAlloc(NULL,VirtBufSize,MEM_COMMIT,PAGE_READWRITE); <br> <br>                if ( !IoBuffer ) { <br>                    printf("MFMT: Buffer Allocation Failed\n"); <br>                    ExitProcess(1); <br>                    } <br> <br>                for ( ;NumBufs &gt; 0; NumBufs-- ) <br>                    { <br>                    b = ReadFile(hDrive,IoBuffer, VirtBufSize, &amp;BytesRead, NULL); <br>                    if (b &amp;&amp; BytesRead){ <br>                        b = WriteFile(hDiskImage,IoBuffer, BytesRead, &amp;BytesWritten, NULL); <br>                        if ( !b || ( BytesRead != BytesWritten ) ) { <br>                            printf("MFMT: Fatal Write Error %d\n",GetLastError()); <br>                            ExitProcess(1); <br>                            } <br>                        } <br>                    else { <br>                        printf("MFMT: Fatal Read Error %d\n",GetLastError()); <br>                        ExitProcess(1); <br>                        } <br>                    } <br>                } <br>            else { <br> <br>                // <br>                // Check to see if the image will fit on the floppy. If it <br>                // will, then LowLevelFormat the floppy and press on <br>                // <br> <br>                FileSize = GetFileSize(hDiskImage,NULL); <br> <br>                b = FALSE; <br>                for(i=0;i&lt;SupportedGeometryCount;i++) { <br>                    NumBufs = SupportedGeometry[i].Cylinders.LowPart; <br>                    VirtBufSize =  SupportedGeometry[i].TracksPerCylinder * <br>                                   SupportedGeometry[i].SectorsPerTrack * <br>                                   SupportedGeometry[i].BytesPerSector; <br>                    if ( VirtBufSize*NumBufs &gt;= FileSize ) { <br> <br>                        IoBuffer = VirtualAlloc(NULL,VirtBufSize,MEM_COMMIT,PAGE_READWRITE); <br> <br>                        if ( !IoBuffer ) { <br>                            printf("MFMT: Buffer Allocation Failed\n"); <br>                            ExitProcess(1); <br>                            } <br> <br>                        // <br>                        // Format the floppy <br>                        // <br> <br>                        LowLevelFormat(hDrive,&amp;SupportedGeometry[i]); <br> <br>                        for ( ;NumBufs &gt; 0; NumBufs-- ) <br>                            { <br>                            b = ReadFile(hDiskImage,IoBuffer, VirtBufSize, &amp;BytesRead, NULL); <br>                            if (b &amp;&amp; BytesRead){ <br>                                b = WriteFile(hDrive,IoBuffer, BytesRead, &amp;BytesWritten, NULL); <br>                                if ( !b || ( BytesRead != BytesWritten ) ) { <br>                                    printf("MFMT: Fatal Write Error %d\n",GetLastError()); <br>                                    ExitProcess(1); <br>                                    } <br>                                } <br>                            else { <br>                                printf("MFMT: Fatal Read Error %d\n",GetLastError()); <br>                                ExitProcess(1); <br>                                } <br>                            } <br>                        b = TRUE; <br>                        break; <br>                    } <br>                    } <br> <br>                if ( !b ) { <br>                    printf("MFMT: FileSize %d is not supported on drive %s\n",FileSize,DriveName); <br>                    ExitProcess(1); <br>                    } <br>                } <br>        } <br> <br>        // <br>        // Dismounting forces the filesystem to re-evaluate the media id <br>        // and geometry. This is the same as popping the floppy in and out <br>        // of the disk drive <br>        // <br> <br>        DismountVolume(hDrive); <br>        UnlockVolume(hDrive); <br> <br>        ExitProcess(0); <br>        } <br>    return (0); <br>} <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
