<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>FIBERS.C</title>
<link disabled rel=stylesheet href=../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5989"></a>FIBERS.C</h2>
<pre><code>/*++ <br> <br>Copyright 1995 - 1998 Microsoft Corporation <br> <br>Module Name: <br> <br>    fibers.c <br> <br>Abstract: <br> <br>    This module illustrates the Win32 fiber APIs. <br> <br>    This example implements a fiber based file copy operation.  Note that <br>    a number of different techiques exists for copying files programmatically; <br>    this sample simply illustrates the fiber APIs. <br> <br>    This example makes use of a fiber data structure which is used to <br>    determine the behavior and state of the fiber.  One data structure <br>    exists for each fiber; the pointer to the data structure is passed <br>    to the fiber at fiber creation time via the lpParameter fiber parameter. <br> <br>    The executing thread in the process makes a call to ConvertThreadToFiber, <br>    which allows fibers to be scheduled by the caller.  This also allows <br>    the resultant fiber to be scheduled by another fiber. <br> <br>    Next, two additional fibers are created, one fiber which performs read <br>    operations against a specified file, and another fiber which performs <br>    the write operations against a specified file. <br> <br>    The primary fiber then schedules the read fiber.  After a succesful <br>    read, the read fiber schedules the write fiber.  After a succesful write <br>    in the write fiber, the write fiber schedules the read fiber.  When <br>    the read/write cycle has completed, the primary fiber is scheduled, <br>    which results in the display of the read/write status. If an error occurs <br>    during the read or write fibers, the primary fiber is scheduled and status <br>    of the read/write is displayed. <br> <br>    The fibers, fiber data structures, and file handles are then freed <br>    prior to process termination. <br> <br>Author: <br> <br>    Scott Field (sfield) 30-Nov-95 <br> <br>Revision History: <br> <br>--*/ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;stdio.h&gt; <br> <br>VOID <br>__stdcall <br>ReadFiberFunc( <br>    LPVOID lpParameter <br>    ); <br> <br>VOID <br>__stdcall <br>WriteFiberFunc( <br>    LPVOID lpParameter <br>    ); <br> <br>void <br>DisplayFiberInfo( <br>    void <br>    ); <br> <br>typedef struct { <br>    DWORD dwParameter;          // DWORD parameter to fiber (unused) <br>    DWORD dwFiberResultCode;    // GetLastError() result code <br>    HANDLE hFile;               // handle to operate on <br>    DWORD dwBytesProcessed;     // number of bytes processed <br>} FIBERDATASTRUCT, *PFIBERDATASTRUCT, *LPFIBERDATASTRUCT; <br> <br>#define RTN_OK 0 <br>#define RTN_USAGE 1 <br>#define RTN_ERROR 13 <br> <br>#define BUFFER_SIZE 32768   // read/write buffer size <br>#define FIBER_COUNT 3       // total number of fibers (including primary) <br> <br>#define PRIMARY_FIBER 0 // array index to primary fiber <br>#define READ_FIBER 1    // array index to read fiber <br>#define WRITE_FIBER 2   // array index to write fiber <br> <br>LPVOID g_lpFiber[FIBER_COUNT]; <br>LPBYTE g_lpBuffer; <br>DWORD g_dwBytesRead; <br> <br>int <br>__cdecl <br>main( <br>    int argc, <br>    char *argv[] <br>    ) <br>{ <br>    LPFIBERDATASTRUCT fs; <br> <br>    if(argc != 3) { <br>        printf("Usage: %s &lt;SourceFile&gt; &lt;DestinationFile&gt;\n", argv[0]); <br>        return RTN_USAGE; <br>    } <br> <br>    // <br>    // allocate storage for our fiber data structures <br>    // <br>    fs = (LPFIBERDATASTRUCT)HeapAlloc( <br>        GetProcessHeap(), 0, sizeof(FIBERDATASTRUCT) * FIBER_COUNT); <br> <br>    if(fs == NULL) { <br>        printf("HeapAlloc error! (rc%=lu)\n", GetLastError()); <br>        return RTN_ERROR; <br>    } <br> <br>    // <br>    // allocate storage for the read/write buffer <br>    // <br>    g_lpBuffer = (LPBYTE)HeapAlloc(GetProcessHeap(), 0, BUFFER_SIZE); <br>    if(g_lpBuffer == NULL) { <br>        printf("HeapAlloc error! (rc=%lu)\n", GetLastError()); <br>        return RTN_ERROR; <br>    } <br> <br>    // <br>    // open the source file <br>    // <br>    fs[READ_FIBER].hFile = CreateFile( <br>        argv[1], <br>        GENERIC_READ, <br>        FILE_SHARE_READ, <br>        NULL, <br>        OPEN_EXISTING, <br>        FILE_FLAG_SEQUENTIAL_SCAN, <br>        NULL <br>        ); <br> <br>    if(fs[READ_FIBER].hFile == INVALID_HANDLE_VALUE) { <br>        printf("CreateFile error! (rc=%lu)\n", GetLastError()); <br>        return RTN_ERROR; <br>    } <br> <br>    // <br>    // open the destination file <br>    // <br>    fs[WRITE_FIBER].hFile = CreateFile( <br>        argv[2], <br>        GENERIC_WRITE, <br>        0, <br>        NULL, <br>        CREATE_NEW, <br>        FILE_FLAG_SEQUENTIAL_SCAN, <br>        NULL <br>        ); <br> <br>    if(fs[WRITE_FIBER].hFile == INVALID_HANDLE_VALUE) { <br>        printf("CreateFile error! (rc=%lu)\n", GetLastError()); <br>        return RTN_ERROR; <br>    } <br> <br>    // <br>    // convert this thread to a fiber, to allow scheduling of other fibers <br>    // <br>    g_lpFiber[PRIMARY_FIBER] = ConvertThreadToFiber(&amp;fs[PRIMARY_FIBER]); <br> <br>    if(g_lpFiber[PRIMARY_FIBER] == NULL) { <br>        printf("ConvertThreadToFiber failed! rc=%lu\n", GetLastError()); <br>        return RTN_ERROR; <br>    } <br> <br>    // <br>    // Just initialize the primary fiber data structure.  We don't use <br>    // the primary fiber data structure for anything in this sample. <br>    // <br>    fs[PRIMARY_FIBER].dwParameter = 0; <br>    fs[PRIMARY_FIBER].dwFiberResultCode = 0; <br>    fs[PRIMARY_FIBER].hFile = INVALID_HANDLE_VALUE; <br> <br>    // <br>    // create the Read fiber <br>    // <br>    g_lpFiber[READ_FIBER] = CreateFiber(0, ReadFiberFunc, &amp;fs[READ_FIBER]); <br> <br>    if(g_lpFiber[READ_FIBER] == NULL) { <br>        printf("CreateFiber error! (rc=%lu)\n", GetLastError()); <br>        return RTN_ERROR; <br>    } <br> <br>    fs[READ_FIBER].dwParameter = 0x12345678; <br> <br>    // <br>    // create the Write fiber <br>    // <br>    g_lpFiber[WRITE_FIBER]=CreateFiber(0, WriteFiberFunc, &amp;fs[WRITE_FIBER]); <br> <br>    if(g_lpFiber[WRITE_FIBER] == NULL) { <br>        printf("CreateFiber error! (rc=%lu)\n", GetLastError()); <br>        return RTN_ERROR; <br>    } <br> <br>    fs[WRITE_FIBER].dwParameter = 0x54545454; <br> <br>    // <br>    // switch to the read fiber <br>    // <br>    SwitchToFiber(g_lpFiber[READ_FIBER]); <br> <br>    // <br>    // We have now been scheduled again.  Display results from the read/write <br>    // fibers <br>    // <br>    printf("ReadFiber result == %lu Bytes Processed == %lu\n", <br>        fs[READ_FIBER].dwFiberResultCode, fs[READ_FIBER].dwBytesProcessed); <br> <br>    printf("WriteFiber result == %lu Bytes Processed == %lu\n", <br>        fs[WRITE_FIBER].dwFiberResultCode, fs[WRITE_FIBER].dwBytesProcessed); <br> <br>    // <br>    // Delete the fibers <br>    // <br>    DeleteFiber(g_lpFiber[READ_FIBER]); <br>    DeleteFiber(g_lpFiber[WRITE_FIBER]); <br> <br>    // <br>    // close handles <br>    // <br>    CloseHandle(fs[READ_FIBER].hFile); <br>    CloseHandle(fs[WRITE_FIBER].hFile); <br> <br>    // <br>    // free allocated memory <br>    // <br>    HeapFree(GetProcessHeap(), 0, g_lpBuffer); <br>    HeapFree(GetProcessHeap(), 0, fs); <br> <br>    return RTN_OK; <br>} <br> <br>VOID <br>__stdcall <br>ReadFiberFunc( <br>    LPVOID lpParameter <br>    ) <br>{ <br>    LPFIBERDATASTRUCT fds = (LPFIBERDATASTRUCT)lpParameter; <br> <br>    // <br>    // if this fiber was passed NULL for fiber data, just return, <br>    // causing the current thread to exit <br>    // <br>    if(fds == NULL) { <br>        printf("Passed NULL fiber data.  Exiting current thread.\n"); <br>        return; <br>    } <br> <br>    // <br>    // display some information pertaining to the current fiber <br>    // <br>    DisplayFiberInfo(); <br> <br>    fds-&gt;dwBytesProcessed = 0; <br> <br>    while(1) { <br>        // <br>        // read data from file specified in the READ_FIBER data structure <br>        // <br>        if(!ReadFile(fds-&gt;hFile, g_lpBuffer, BUFFER_SIZE, &amp;g_dwBytesRead, NULL)) { <br>            break; <br>        } <br> <br>        // <br>        // if we reached EOF, break <br>        // <br>        if(g_dwBytesRead == 0) break; <br> <br>        // <br>        // update number of bytes processed in the fiber data structure <br>        // <br>        fds-&gt;dwBytesProcessed += g_dwBytesRead; <br> <br>        // <br>        // switch to the write fiber <br>        // <br>        SwitchToFiber(g_lpFiber[WRITE_FIBER]); <br>    } // while <br> <br>    // <br>    // update the fiber result code <br>    // <br>    fds-&gt;dwFiberResultCode = GetLastError(); <br> <br>    // <br>    // switch back to the primary fiber <br>    // <br>    SwitchToFiber(g_lpFiber[PRIMARY_FIBER]); <br>} <br> <br>VOID <br>__stdcall <br>WriteFiberFunc( <br>    LPVOID lpParameter <br>    ) <br>{ <br>    LPFIBERDATASTRUCT fds = (LPFIBERDATASTRUCT)lpParameter; <br>    DWORD dwBytesWritten; <br> <br>    // <br>    // if this fiber was passed NULL for fiber data, just return, <br>    // causing the current thread to exit <br>    // <br>    if(fds == NULL) { <br>        printf("Passed NULL fiber data.  Exiting current thread.\n"); <br>        return; <br>    } <br> <br>    // <br>    // display some information pertaining to the current fiber <br>    // <br>    DisplayFiberInfo(); <br> <br>    // <br>    // assume all of the writes succeed.  If a write fails, the fiber <br>    // result code will be updated to reflect the reason for failure <br>    // <br>    fds-&gt;dwBytesProcessed = 0; <br>    fds-&gt;dwFiberResultCode = ERROR_SUCCESS; <br> <br>    while (1) { <br>        // <br>        // write data to the file specified in the WRITE_FIBER data structure <br>        // <br>        if(!WriteFile(fds-&gt;hFile, g_lpBuffer, g_dwBytesRead, &amp;dwBytesWritten, NULL)) { <br>            // <br>            // if an error occurred writing, break <br>            // <br>            break; <br>        } <br> <br>        // <br>        // update number of bytes processed in the fiber data structure <br>        // <br>        fds-&gt;dwBytesProcessed += dwBytesWritten; <br> <br>        // <br>        // switch back to the read fiber <br>        // <br>        SwitchToFiber(g_lpFiber[READ_FIBER]); <br>    }  // while <br> <br>    // <br>    // if an error occurred, update the fiber result code... <br>    // <br>    fds-&gt;dwFiberResultCode = GetLastError(); <br> <br>    // <br>    // ...and switch to the primary fiber <br>    // <br>    SwitchToFiber(g_lpFiber[PRIMARY_FIBER]); <br>} <br> <br>void <br>DisplayFiberInfo( <br>    void <br>    ) <br>{ <br>    LPFIBERDATASTRUCT fds = (LPFIBERDATASTRUCT)GetFiberData(); <br>    LPVOID lpCurrentFiber = GetCurrentFiber(); <br> <br>    // <br>    // determine which fiber we are executing, based on the fiber address <br>    // <br>    if(lpCurrentFiber == g_lpFiber[READ_FIBER]) <br>        printf("Read Fiber entered"); <br>    else { <br>        if(lpCurrentFiber == g_lpFiber[WRITE_FIBER]) <br>            printf("Write Fiber entered"); <br>        else { <br>            if(lpCurrentFiber == g_lpFiber[PRIMARY_FIBER]) <br>                printf("Primary Fiber entered"); <br>            else <br>                printf("Unknown Fiber entered"); <br>            } <br>    } <br> <br>    // <br>    // display dwParameter from the current fiber data structure <br>    // <br>    printf(" (dwParameter == 0x%lx)\n", fds-&gt;dwParameter); <br>} <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
