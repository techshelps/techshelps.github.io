<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>WRPHELP.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6116"></a>WRPHELP.CPP</h2>
<pre><code>/*++ <br> <br>Copyright (c) 1996  Microsoft Corporation <br> <br>Module Name: <br> <br>    WrpHelp <br> <br>Abstract: <br> <br>    This file contains wrapper class implementations. <br>     <br>Author: <br> <br> <br>Environment: <br> <br>    Win32, C++ w/Exceptions, ATL, COM/OLE <br> <br>Notes: <br>     <br>--*/ <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// <br>// Includes <br>// <br> <br>#include "stdafx.h" <br>#include "wrphelp.h" <br>#include "scarddef.h" <br> <br>/////////////////////////////////////////////////////////////////////////// <br>// Macros <br>// <br>#ifdef _DEBUG <br>    #define TRACE_STR(name,sz) \ <br>                TRACE(_T("WrpHelp Classes::%s: %s\n"), name, sz) <br>    #define TRACE_CODE(name,code) \ <br>                TRACE(_T("WrpHelp Classes::%s: error = 0x%x\n"), name, code) <br>    #define TRACE_CATCH(name,code)      TRACE_CODE(name,code) <br>    #define TRACE_CATCH_UNKNOWN(name)   TRACE_STR(name,_T("An unidentified exception has occurred!")) <br>#else <br>    #define TRACE_STR(name,sz)          ((void)0) <br>    #define TRACE_CODE(name,code)       ((void)0) <br>    #define TRACE_CATCH(name,code)      ((void)0) <br>    #define TRACE_CATCH_UNKNOWN(name)   ((void)0) <br>#endif  // _DEBUG <br> <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// <br>// Construction and Destruction <br>// <br> <br>/*++ <br> <br>CCriticalSection::CCriticalSection <br> <br>    This method implements the constructor for CCriticalSection <br>     <br>Arguments: <br> <br>    None <br>     <br>Return Value: <br> <br>    None <br> <br>Author: <br> <br>--*/ <br> <br>CCriticalSection::CCriticalSection() <br>{ <br>    // locals <br> <br>    // Initialize the internal critical section object <br>    try { <br>        ::InitializeCriticalSection(&amp;m_CriticalSection); <br>    } <br> <br>    catch (...){ <br>        TRACE_CATCH_UNKNOWN(_T("CCriticalSection")); <br>    } <br>} <br> <br> <br>/*++ <br> <br>CCriticalSection::~CCriticalSection <br> <br>    This method implements the destructor for CCriticalSection <br>     <br>Arguments: <br> <br>    None <br>     <br>Return Value: <br> <br>    None <br> <br>Author: <br> <br>--*/ <br>CCriticalSection::~CCriticalSection() <br>{ <br>    // locals <br> <br>    try { <br>        ::DeleteCriticalSection(&amp;m_CriticalSection); <br>    } <br> <br>    catch(...) { <br>        TRACE_CATCH_UNKNOWN(_T("~CriticalSection")); <br>    } <br>} <br> <br> <br>///////////////////////////////////////////////////////////////////////////////////// <br>// <br>// CCriticalSection <br>// <br> <br>/*++ <br> <br>CCriticalSection::EnterCriticalSection <br> <br>    This routines puts the internal critical section <br>    object into the non-signaled state <br>     <br>Arguments: <br> <br>    None <br>     <br>Return Value: <br> <br>    None <br> <br>Author: <br> <br>--*/ <br>CCriticalSection::EnterCriticalSection() <br>{ <br>    // Locals <br>    BOOL    fResult = FALSE; <br> <br>    try { <br>        ::EnterCriticalSection(&amp;m_CriticalSection); <br> <br>        // Ok... <br>        fResult = TRUE; <br>    } <br> <br>    catch (...) { <br>        TRACE_CATCH_UNKNOWN(_T("EnterCriticalSection")); <br>    } <br> <br>    return fResult; <br>} <br> <br> <br>/*++ <br> <br>CCriticalSection::ExitCriticalSection <br> <br>    This routines puts the internal critical section <br>    object into the signaled state <br>     <br>Arguments: <br> <br>    None <br>     <br>Return Value: <br> <br>    None <br> <br>Author: <br> <br>    Chris Dudley (cdudley) 2/6/1997 <br> <br>--*/ <br>CCriticalSection::ExitCriticalSection() <br>{ <br>    // Locals <br>    BOOL        fResult = FALSE; <br> <br>    try { <br>        ::LeaveCriticalSection(&amp;m_CriticalSection); <br> <br>        // Ok... <br>        fResult = TRUE; <br>    } <br> <br>    catch (...) { <br>        TRACE_CATCH_UNKNOWN(_T("EnterCriticalSection")); <br>    } <br> <br>    return fResult; <br>} <br> <br> <br>/////////////////////////////////////////////////////////////////////////////////// <br> <br>///////////////////////////////////////////////////////////////////////////////////// <br>// <br>// CGrabData <br>// <br> <br>/*++ <br> <br>CGrabData::GetExtraData <br> <br>    This routine calls the ISO7816-4 command GetResponse to get additional <br>    data from the card and return it in the IByteBuffer (aka IStream) <br> <br>Arguments: <br> <br>    ppDataOut - pointer to a pointer to an IByteBuffer. If this pointer is <br>                NULL, the IStream will be created but MUST be release in caller's <br>                code. <br>    pwCmdStatus - (IN) The status word (SW1/SW2) returned from the initial smart card <br>                command. <br>                 (OUT) the final status word. <br>    pdwDataLength - (OUT) Total number of bytes written into the buffer. <br>     <br>Return Value: <br> <br>    A HRESULT value indicating the status of the requested action. <br> <br>    Return                      Meaning <br>    ======                      ======= <br>    E_INVALIDARG                An argument was invalid or unrecognizable. <br>    E_OUTOFMEMORY               No free memory in process address space <br>                                to create requested object. <br>    E_UNEXPECTED                One of the parameters was of an unexpected <br>                                type or value. <br>    S_OK                        Command successful. <br>     <br>Author: <br> <br>Notes: <br>     <br>    This routine expects (*pwCmdStatus) to contain a 0x61xx response code where <br>    xx is the number of bytes to be retrieved by the GetResponse. <br> <br>--*/ <br>HRESULT CGrabData::GetExtraData(LPBYTEBUFFER *ppDataOut, <br>                                WORD *pwCmdStatus, <br>                                LONG *plDataLength) <br>{ <br>    // Locals <br>    HRESULT         hresult = S_OK; <br>    LONG            lSize; <br>    LPBYTEBUFFER    pBuffer; <br>    ULARGE_INTEGER  liBytesToCopy, <br>                    liBytesRead, <br>                    liBytesWritten, <br>                    liLength; <br> <br>    try { <br>        // clear length <br>        (*plDataLength) = 0; <br>        // Create buffers if needed...1 for GetResponse, another to copy into <br>        if ( (*ppDataOut) == NULL) { <br>            hresult = m_pISCardTypeConv-&gt;CreateByteBuffer((ULONG) 1, <br>                                                        ppDataOut); <br>            if (FAILED(hresult)) <br>                throw (hresult); <br>        };// if <br>        hresult = m_pISCardTypeConv-&gt;CreateByteBuffer((ULONG) 1, <br>                                                        &amp;pBuffer); <br>        if (FAILED(hresult)) <br>            throw (hresult); <br>        // Check status <br>        m_wReplyStatus = (*pwCmdStatus); <br>        while(HIBYTE(m_wReplyStatus) == SC_STATUS_MOREDATA){ <br>            lSize = LOBYTE( m_wReplyStatus ); <br>            // Build the command <br>            hresult = m_pISCardISO7816-&gt;GetResponse((BYTE) 0, <br>                                                    (BYTE) 0, <br>                                                    lSize, <br>                                                    &amp;m_pISCardCmd); <br>            if (FAILED(hresult)) <br>                throw (hresult); <br>     <br>            // Force correct class id for the vendor's card <br>            hresult = m_pISCardCmd-&gt;put_ClassId(VENDOR_CLASS_ID); <br>            if (FAILED(hresult)) <br>                throw (hresult); <br>     <br>            // Do transaction <br>            hresult = m_pISCard-&gt;LockSCard(); <br>            if (FAILED(hresult)) <br>                throw (hresult); <br>            hresult = m_pISCard-&gt;Transaction(&amp;m_pISCardCmd); <br>            if (FAILED(hresult)) <br>                throw (hresult); <br>            hresult = m_pISCard-&gt;UnlockSCard(LEAVE); <br>            if (FAILED(hresult)) <br>                throw (hresult); <br>            // Interpret response <br>            hresult = m_pISCardCmd-&gt;get_ApduReplyLength(&amp;m_lReplyLength); <br>            if (FAILED(hresult)) <br>                throw (hresult); <br>            hresult = m_pISCardCmd-&gt;get_ReplyStatus( &amp;m_wReplyStatus ); <br>            if (FAILED(hresult)) <br>                throw (hresult); <br>            if ( (m_wReplyStatus != SC_STATUS_SUCCESS) &amp;&amp; <br>                    (HIBYTE(m_wReplyStatus) != SC_STATUS_MOREDATA )) <br>                throw ( (HRESULT) E_FAIL);   <br>         <br>            // Get reply data <br>            hresult = m_pISCardCmd-&gt;get_ApduReply( &amp;pBuffer ); <br>            if (FAILED(hresult)) <br>                throw (hresult); <br>     <br>            // Copy it into given Internal IStream. First set new Length. <br>            // Don't REALLY have to do this. The IStream Copy would take care of it... <br>            (*plDataLength) += m_lReplyLength; <br>            LISet32 (liLength, (*plDataLength)); <br>            hresult = (*ppDataOut)-&gt;SetSize((LONG) liLength.LowPart); <br>            if (FAILED(hresult)) <br>                throw (hresult); <br>            LISet32 (liBytesToCopy, m_lReplyLength ); <br>            hresult = (pBuffer)-&gt;CopyTo(ppDataOut, <br>                                        (LONG) liBytesToCopy.LowPart, <br>                                        (LONG*) &amp;(liBytesRead.LowPart), <br>                                        (LONG*) &amp;(liBytesWritten.LowPart)); <br>            if (FAILED(hresult)) <br>                throw (hresult); <br>        }; //while <br>    } <br> <br>    catch (HRESULT hr) { <br>        hresult = hr; <br>        TRACE_CATCH(_T("GetResultData"),hr); <br>    } <br> <br>    catch (...) { <br>        hresult = (HRESULT) E_UNEXPECTED; <br>        TRACE_CATCH_UNKNOWN(_T("GetResultData")); <br>    } <br> <br>    // Release resources...Cleanup <br>    if (pBuffer != NULL) <br>        while (pBuffer-&gt;Release()&gt;0); <br> <br>    (*pwCmdStatus) = m_wReplyStatus; <br> <br>    return hresult; <br>} <br> <br> <br>////////////////////////////////////////////////////////////////////////////////////// <br> <br>////////////////////////////////////////////////////////////////////////////////////// <br>// <br>//  Various Useful routines <br>// <br> <br>/*++ <br> <br>SspCreateByteArray: <br> <br>    This routine creates an array of bytes. <br>     <br>Arguments: <br> <br>    dwAllocSize - Size in bytes of the memory to be allocated for the array. <br> <br>    ppbyArray - Points to the created byte array to be returned. <br> <br>    pExceptInfo - Points to an OLE exception block which contains extended <br>        information about any failure that might occur. Can be set to <br>        NULL if the exception information is not desired. <br>     <br>Return Value: <br> <br>    A HRESULT value indicating the status of the requested action. <br> <br>    Return          Meaning <br>    ======          ======= <br>    S_OK            The byte array was created successfully. <br>    S_FALSE         Unknown error. <br>    E_OUTOFMEMORY   There is not enough memory in this process to <br>                    satisfy the request. <br>    E_FAIL          Unspecified error. <br>    E_INVALIDARG    One or more arguments are invalid. <br>    E_HANDLE        Invalid handle. <br>    E_POINTER       Invalid pointer. <br>    E_UNEXPECTED    Unexpected fault has occurred. <br>     <br>Author: <br> <br>--*/ <br> <br>HRESULT <br>SspCreateByteArray( <br>    IN DWORD dwAllocSize, <br>    OUT LPBYTE *ppbyArray, <br>    OUT OPTIONAL EXCEPINFO* pExceptInfo) <br>{ <br>    // Locals. <br>    HRESULT hr = S_OK; <br>    HGLOBAL hMem = NULL; <br>    LPBYTE pObj = NULL; <br>    DWORD dwErr = NO_ERROR; <br>     <br>    try <br>    { <br>        // Initialize the parameters. <br>        (*ppbyArray) = NULL; <br> <br>        // Is caller asking for a reasonable array size? <br>        if (dwAllocSize &lt;= 0) <br>            throw ( (HRESULT) E_INVALIDARG); <br> <br>        // Allocate the memory for the array from the system. <br>        hMem = ::GlobalAlloc(GHND, dwAllocSize); <br>        if (hMem == NULL) <br>        { <br>            dwErr = ::GetLastError(); <br>            throw (HRESULT_FROM_WIN32(dwErr)); <br>        } <br>         <br>        // Map the memory for use. <br>        pObj = (LPBYTE) GlobalLock(hMem); <br>        if (pObj == NULL) <br>        { <br>            dwErr = ::GetLastError(); <br>            throw (HRESULT_FROM_WIN32(dwErr)); <br>        } <br>        ASSERT(pObj != NULL); <br> <br>        // Ok, pack for return. <br>        (*ppbyArray) = pObj; <br>    } <br> <br>    catch (HRESULT hrStatus) <br>    { <br>        hr = hrStatus; <br>        TRACE_CATCH(_T("SspCreateByteArray"),hrStatus); <br>        if (pObj!=NULL) <br>            ::GlobalUnlock(hMem); <br>        if (hMem!=NULL) <br>            ::GlobalFree(hMem); <br>        switch (hr) <br>        { <br>            case E_UNEXPECTED: <br>            case E_POINTER: <br>            case E_INVALIDARG: <br>                ::SetLastError( (DWORD) ERROR_INVALID_PARAMETER); <br>                break; <br> <br>            case S_FALSE: <br>            case E_FAIL: <br>                ::SetLastError((DWORD) ERROR_NOT_SUPPORTED); <br>                break; <br> <br>            case E_ACCESSDENIED: <br>                ::SetLastError((DWORD)ERROR_ACCESS_DENIED); <br>                break; <br> <br>            case E_HANDLE: <br>                ::SetLastError((DWORD) ERROR_INVALID_HANDLE); <br>                break; <br> <br>            case E_OUTOFMEMORY: <br>                ::SetLastError((DWORD) ERROR_OUTOFMEMORY); <br>                break; <br> <br>            default: <br>                ::SetLastError(dwErr); <br>                break; <br>        } <br>    } <br> <br>    catch (...) <br>    { <br>        TRACE_CATCH_UNKNOWN(_T("SspCreateByteArray")); <br>        if (pObj != NULL) <br>            ::GlobalUnlock(hMem); <br>        if (hMem != NULL) <br>            ::GlobalFree(hMem); <br>        ::SetLastError( (DWORD) ERROR_INVALID_PARAMETER); <br>        hr = (HRESULT) E_UNEXPECTED; <br>    } <br> <br>    return (hr); <br>} <br> <br> <br>/*++ <br> <br>SspConvertDwordToByte: <br> <br>    This function will convert a DWORD to an array of BYTEs. <br>     <br>Arguments: <br> <br>    dwNum - DWORD number to be converted. <br> <br>    ppbyArray - Points to the byte array created to hold the converted <br>        DWORD if successful; else, NULL! <br> <br>    pdwByteArraySize - Optional pointer to how big was the byte array <br>        created to hold the DWORD is. <br> <br>    pExceptInfo - Points to an OLE exception block which contains extended <br>        information about any failure that might occur. Can be set to <br>        NULL if the exception information is not desired. <br>     <br>Return Value: <br> <br>    A HRESULT value indicating the status of the requested action. <br> <br>    Return              Meaning <br>    ======              ======= <br>    S_OK                Operation completed successfully. <br>    S_FALSE             Unknown error. <br>    E_OUTOFMEMORY       There is not enough memory in this process to <br>                        satisfy the request. <br>    E_FAIL              Unspecified error. <br>    E_INVALIDARG        One or more arguments are invalid. <br>    E_POINTER           Invalid pointer. <br>    E_UNEXPECTED        Unexpected event occurred in this function. <br>    E_HANDLE            Invalid handle. <br>    E_ACCESSDENIED      Access to resource is denied. <br> <br>Author: <br> <br>--*/ <br> <br>HRESULT <br>SspConvertDwordToByte( <br>    IN DWORD dwNum, <br>    OUT LPBYTE *ppbyArray, <br>    OUT LPDWORD pdwByteArraySize, <br>    OUT OPTIONAL EXCEPINFO* pExceptInfo) <br>{ <br>    // Locals. <br>    LPBYTE pbyBuff = NULL; <br>    HRESULT hr = S_OK; <br>    DWORD dwSize = 0; <br> <br>    try <br>    { <br>        // Initialize... <br>        if ((*ppbyArray)) <br>            (*ppbyArray) = NULL; <br>        if (pdwByteArraySize) <br>            (*pdwByteArraySize) = 0; <br> <br>        // Determine the appropriately sized byte array needed <br>        // to hold DWORD. <br>        if (dwNum &lt;= 0xFF) <br>            dwSize = 1; <br>        else if (dwNum &lt;= 0xFFFF) <br>                dwSize = 2; <br>        else if (dwNum &lt;= 0xFFFFFF) <br>                dwSize = 3; <br>        else <br>            throw ( (HRESULT) E_INVALIDARG); <br> <br>        // Create the byte array. <br>        hr = SspCreateByteArray(dwSize, <br>                                &amp;pbyBuff, <br>                                NULL); <br>        if (FAILED(hr)) <br>            throw (hr); <br>        if (pbyBuff == NULL) <br>            throw ( (HRESULT) E_OUTOFMEMORY); <br>        ASSERT(pbyBuff != NULL); <br> <br>        // Copy it! <br>        ::CopyMemory( (LPVOID) pbyBuff, <br>                      (CONST VOID*) &amp;dwNum, <br>                      (DWORD) sizeof(DWORD) ); <br> <br>        // Package for return. <br>        *ppbyArray = pbyBuff; <br>        if (pdwByteArraySize != NULL) <br>            (*pdwByteArraySize) = dwSize; <br>    } <br> <br>    catch (HRESULT hrStatus) <br>    { <br>        hr = hrStatus; <br>        TRACE_CATCH(_T("SspConvertDwordToByte"),hrStatus); <br>        switch (hr) <br>        { <br>            case E_UNEXPECTED: <br>            case E_POINTER: <br>            case E_INVALIDARG: <br>                ::SetLastError((DWORD) ERROR_INVALID_PARAMETER); <br>                break; <br> <br>            case S_FALSE: <br>            case E_FAIL: <br>                ::SetLastError((DWORD) ERROR_NOT_SUPPORTED); <br>                break; <br> <br>            case E_ACCESSDENIED: <br>                ::SetLastError((DWORD) ERROR_ACCESS_DENIED); <br>                break; <br> <br>            case E_HANDLE: <br>                ::SetLastError((DWORD) ERROR_INVALID_HANDLE); <br>                break; <br> <br>            case E_OUTOFMEMORY: <br>                ::SetLastError((DWORD) ERROR_OUTOFMEMORY); <br>                break; <br>        } <br>    } <br> <br>    catch (...) <br>    { <br>        TRACE_CATCH_UNKNOWN(_T("SspConvertDwordToByte")); <br>        ::SetLastError((DWORD) ERROR_INVALID_PARAMETER); <br>        hr = (HRESULT) E_UNEXPECTED; <br>    } <br> <br>    return (hr); <br>} <br> <br> <br>/*++ <br> <br>SspFreeByteArray: <br> <br>    This routine frees a byte array (aka a block of HGLOBAL memory). <br>         <br>Arguments: <br> <br>    pbyArray - Points to the byte array to be freed. <br> <br>    pExceptInfo - Points to an OLE exception block which contains extended <br>        information about any failure that might occur. Can be set to <br>        NULL if the exception information is not desired. <br>     <br>Return Value: <br> <br>    A HRESULT value indicating the status of the requested action. <br> <br>    Return          Meaning <br>    ======          ======= <br>    S_OK            The byte array was created freed. <br>    S_FALSE         Unknown error. <br>    E_OUTOFMEMORY   There is not enough memory in this process to <br>                    satisfy the request. <br>    E_FAIL          Unspecified error. <br>    E_INVALIDARG    One or more arguments are invalid. <br>    E_UNEXPECTED    Unexpected fault has occurred. <br>    E_POINTER       Invalid pointer. <br>    E_HANDLE        Invalid handle. <br>    E_ACCESSDENIED  Access to resource is denied. <br>     <br>Author: <br> <br>--*/ <br> <br>HRESULT <br>SspFreeByteArray( <br>    IN LPBYTE pbyArray, <br>    OUT OPTIONAL EXCEPINFO* pExceptInfo) <br>{ <br>    // Locals. <br>    DWORD dwErr = NO_ERROR; <br>    HGLOBAL hMem = NULL; <br>    HRESULT hr = S_OK; <br> <br>    try <br>    { <br>        // Is the parameter-list ok? <br>        if (pbyArray == NULL) <br>            throw ( (HRESULT) E_POINTER); <br> <br>        // Get access to the string's memory block. <br>        hMem = ::GlobalHandle((LPCVOID) pbyArray); <br>        if (hMem == NULL) <br>        { <br>            dwErr = ::GetLastError(); <br>            throw (HRESULT_FROM_WIN32(dwErr)); <br>        } <br>        ASSERT(hMem != NULL); <br>         <br>        // Decrement the memory block's reference count. <br>        while (::GlobalUnlock(hMem)); <br>        dwErr = ::GetLastError(); <br>        if (dwErr != NO_ERROR) <br>            throw (HRESULT_FROM_WIN32(dwErr)); <br> <br>        // Free the memory! <br>        hMem = ::GlobalFree(hMem); <br>        if (hMem == NULL) <br>        { <br>            dwErr = ::GetLastError(); <br>            throw (HRESULT_FROM_WIN32(dwErr)); <br>        } <br>        ASSERT(hMem == NULL); <br>    } <br> <br>    catch (HRESULT hrStatus) <br>    { <br>        hr = hrStatus; <br>        TRACE_CATCH(_T("SspFreeByteArray"),hrStatus); <br>        switch (hr) <br>        { <br>            case E_UNEXPECTED: <br>            case E_POINTER: <br>            case E_INVALIDARG: <br>                ::SetLastError((DWORD) ERROR_INVALID_PARAMETER); <br>                break; <br> <br>            case S_FALSE: <br>            case E_FAIL: <br>                ::SetLastError((DWORD) ERROR_NOT_SUPPORTED); <br>                break; <br> <br>            case E_ACCESSDENIED: <br>                ::SetLastError((DWORD) ERROR_ACCESS_DENIED); <br>                break; <br> <br>            case E_HANDLE: <br>                ::SetLastError((DWORD) ERROR_INVALID_HANDLE); <br>                break; <br> <br>            case E_OUTOFMEMORY: <br>                ::SetLastError((DWORD) ERROR_OUTOFMEMORY); <br>                break; <br>         <br>            default: <br>                ::SetLastError(dwErr); <br>                break; <br>        } <br>    } <br> <br>    catch (...) <br>    { <br>        TRACE_CATCH_UNKNOWN(_T("SspFreeByteArray")); <br>        ::SetLastError((DWORD) ERROR_INVALID_PARAMETER); <br>        hr = (HRESULT) E_UNEXPECTED; <br>    } <br> <br>    return (hr); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
