<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SCARDFIL.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6108"></a>SCARDFIL.CPP</h2>
<pre><code>////////////////////////////////////////////////////////////////////////// <br>// <br>// Includes <br>// <br> <br>#include "stdafx.h" <br>#include "SCardCOM.h" <br>#include "SCardFil.h" <br> <br>#include "scarddef.h" <br> <br>/////////////////////////////////////////////////////////////////////////// <br>// Macros <br>// <br>#ifdef _DEBUG <br>#define TRACE_STR(name,sz) \ <br>TRACE(_T("SCardCOM.DLL: CSCardFileAccess::%s: %s\n"), name, sz) <br>#define TRACE_CODE(name,code) \ <br>TRACE(_T("SCardCOM.DLL: CSCardFileAccess::%s: error = 0x%x\n"), name, code) <br>#define TRACE_CATCH(name,code)TRACE_CODE(name,code) <br>#define TRACE_CATCH_UNKNOWN(name)TRACE_STR(name,_T("An unidentified exception has occurred!")) <br>#else <br>#define TRACE_STR(name,sz)((void)0) <br>#define TRACE_CODE(name,code)((void)0) <br>#define TRACE_CATCH(name,code)((void)0) <br>#define TRACE_CATCH_UNKNOWN(name)((void)0) <br>#endif  // _DEBUG <br> <br>/*++ <br> <br>CSCardFileAccess::FinalConstruct: <br> <br>    This routine defines a final constructor that is called after the constructor <br>for the template class is called. <br> <br>Arguments: <br> <br>    None <br> <br>Return Value: <br> <br>    A HRESULT value indicating the status of the requested action. <br> <br>ReturnMeaning <br>============= <br>S_OKOperation completed successfully. <br>S_FALSEUnknown error occurred. <br>E_OUTOFMEMORYThere is not enough memory in this process to  <br>satisfy the request. <br>E_FAILUnspecified error. <br>E_INVALIDARGOne or more arguments are invalid. <br>E_UNEXPECTEDUnexpected event occurred in this function. <br> <br>Author: <br> <br>--*/ <br> <br>HRESULT CSCardFileAccess::FinalConstruct() <br>{ <br>// Locals. <br>HRESULT hresult = S_OK; <br> <br>try { <br>m_iOpenFiles = 0; <br>m_FileInfoMap.InitHashTable(13); <br>m_hfileNextHandle = 1; <br>m_wCurrentFileID = 0x3f00; <br>m_Manage = NULL; <br>} <br> <br>catch (...) { <br>hresult = E_UNEXPECTED; <br>TRACE_CATCH(_T("FinalConstruct"), hresult); <br>} <br> <br>return (hresult); <br>} <br> <br> <br>/*++ <br> <br>CSCardFileAccess::FinalRelease: <br> <br>    This routine defines a final release. <br> <br>Arguments: <br> <br>    None <br> <br>Return Value: <br> <br>    A HRESULT value indicating the status of the requested action. <br> <br>ReturnMeaning <br>============= <br>S_OKOperation completed successfully. <br>S_FALSEUnknown error occurred. <br>E_OUTOFMEMORYThere is not enough memory in this process to  <br>satisfy the request. <br>E_FAILUnspecified error. <br>E_INVALIDARGOne or more arguments are invalid. <br>E_UNEXPECTEDUnexpected event occurred in this function. <br> <br>Author: <br> <br>--*/ <br> <br>HRESULT CSCardFileAccess::FinalRelease() <br>{ <br>// Locals. <br>HRESULT hresult = S_OK; <br> <br>try { <br>// Decrement the reference count on the "creation" object <br>if (m_Manage != NULL) <br>m_Manage-&gt;Release(); <br>} <br> <br>catch (...) { <br>} <br> <br>return (hresult); <br>} <br> <br> <br>/*++ <br> <br>CSCardFileAccess::ConvertFilename <br> <br>    This routine converts a filename (BSTR) to a word for internal use <br>as the file ID. BSTR MUST be in hex! <br>   <br>Arguments: <br> <br>    bstrFilename - filename as BSTR <br> <br>Return Value: <br> <br>A word containing the filename or 0 if failed. <br> <br>Author: <br> <br>Note: <br> <br>--*/ <br> <br>WORD CSCardFileAccess::ConvertFilename( BSTR bstrFilename) <br>{ <br>//locals <br>WORDwFileID = 0; <br>intnStringLength = :: SysStringLen(bstrFilename); <br>LPTSTRpszBuffer,  <br>pszEndBuffer; <br>HLOCALhMem; <br>DWORDdwErr; <br>#ifdef _UNICODE <br>intnNewStrLen = sizeof(WCHAR); <br>#else <br>int nNewStrLen = sizeof(char); <br>#endif <br> <br>m_CriticalSection.EnterCriticalSection(); <br> <br>try { <br>if ( (nStringLength &gt; SC_FILE_ID_STR_LENGTH) ||  <br> (nStringLength &lt;=0) ) <br>throw ( (HRESULT) E_INVALIDARG ); <br>// Alloc mem for BSTR to LPTSTR conversion if required <br>nNewStrLen *= nStringLength; <br>nNewStrLen++;  //For NULL termination <br>#ifdef _UNICODE <br>pszBuffer = (LPTSTR) bstrFileName; <br>#else <br>hMem = ::LocalAlloc(LPTR, (UINT) nNewStrLen); <br>if (hMem == NULL) { <br>dwErr = ::GetLastError(); <br>throw (HRESULT_FROM_WIN32(dwErr)); <br>}; <br>pszBuffer = (LPTSTR) ::LocalLock(hMem); <br>if (pszBuffer == NULL) { <br>dwErr = ::GetLastError(); <br>throw (HRESULT_FROM_WIN32(dwErr)); <br>}; <br>// Convert wide char to ansi string <br>WideCharToMultiByte(CP_ACP, <br>0, <br>bstrFilename, <br>nStringLength, <br>pszBuffer, <br>nNewStrLen, <br>NULL, <br>NULL ); <br>#endif <br>// Now convert to WORD... <br>pszEndBuffer = pszBuffer + nStringLength; <br>// Use correct conversion per UNICODE  <br>#ifdef _UNICODE <br>wFileID = (WORD) wcstol( pszBuffer , &amp;pszEndBuffer, 16); <br>#else <br>wFileID = (WORD) strtol( pszBuffer , &amp;pszEndBuffer, 16); <br>#endif <br>} <br> <br>catch (...) { <br>wFileID = 0; <br>TRACE_CATCH(_T("ConvertFilename"), wFileID); <br>} <br> <br>// Eliminate the temp buffer <br>while (::LocalUnlock(hMem)); <br>// At this point, ::GetLastError() should equal NO_ERROR! <br>if (::LocalFree(hMem) != NULL) { <br>wFileID = 0; <br>} <br> <br>m_CriticalSection.ExitCriticalSection(); <br> <br>return wFileID; <br>} <br> <br> <br>/*++ <br> <br>CSCardFileAccess::CreateFileHandle <br> <br>    This routine creates a file handle. <br> <br>Arguments: <br> <br>    None <br> <br>Return Value: <br> <br>A HSCARD_FILE handle or 0 if call failed. <br> <br>Author: <br> <br>--*/ <br>HSCARD_FILE CSCardFileAccess::CreateFileHandle() <br>{ <br>// locals <br>HSCARD_FILE hFile = 0; <br> <br>m_CriticalSection.EnterCriticalSection(); <br> <br>try { <br>// Simple generation based on successive HSCARD_FILE values. <br>if (m_hfileNextHandle == MAX_HANDLE_VALUE) <br>throw(hFile = 0); <br>hFile = m_hfileNextHandle; <br>m_hfileNextHandle++; <br>} <br> <br>catch (HSCARD_FILE handle) { <br>hFile = handle; <br>TRACE_CATCH(_T("CreateFileHandle"), hFile); <br>} <br> <br>catch (...) { <br>hFile = 0; <br>TRACE_CATCH_UNKNOWN(_T("CreateFileHandle")); <br>} <br> <br>m_CriticalSection.ExitCriticalSection(); <br> <br>return hFile; <br>} <br> <br>/*++ <br> <br>CSCardFileAccess::FileSelect <br> <br>    This routine selects file/changes directory on the ICC.  <br> <br>Arguments: <br> <br>    sFilePath - 2-byte file ID of file to be selected <br> <br>Return Value: <br> <br>    A HRESULT value indicating the status of the requested action. <br> <br>ReturnMeaning <br>============= <br>S_OKOperation completed successfully. <br>S_FALSEUnknown error occurred. <br>E_OUTOFMEMORYThere is not enough memory in this process to  <br>satisfy the request. <br>E_FAILUnspecified error. <br>E_INVALIDARGOne or more arguments are invalid. <br>E_UNEXPECTEDUnexpected event occurred in this function. <br> <br>Author: <br> <br>Notes: <br> <br>FCI is requested but NOT stored within this object. To store  <br>the FCI data, create a IByteBuffer (aka IStream) and call <br>ISCard-&gt;get_ReplyApdu(..). <br> <br>--*/ <br> <br>HRESULT CSCardFileAccess::FileSelect( WORD wFilePath ) <br>{ <br>HRESULT hresult = S_OK; <br>LPBYTEBUFFERpData = NULL, <br>pResultData = NULL; <br>ULONGulLength = 1L, <br>ulBytesWritten = 0; <br>BYTEbyID = 0, <br>byP1 = 0, <br>byP2 = 0; <br>LPSCARDCMDpCmd = NULL; <br> <br>m_CriticalSection.EnterCriticalSection(); <br> <br>try { <br>// Is internal pointer to "Creation Class" valid <br>if (m_Manage == NULL) <br>throw ( (HRESULT) E_FAIL ); <br> <br>if (ulLength&gt;MAX_PATH_LEN) <br>throw ( (HRESULT) E_INVALIDARG ); <br> <br>// Create Cmd Object <br>hresult = m_Manage-&gt;CreateCmdObject(&amp;pCmd); <br>if (FAILED(hresult)) <br>throw (hresult); <br> <br>// Create Data grabber <br>CGrabDataGrabData(pCmd, <br>m_Manage-&gt;m_pISCard, <br>m_Manage-&gt;m_pISCardISO7816, <br>m_Manage-&gt;m_pISCardTypeConv); <br> <br>// Create a byte buffer for ISO call  <br>hresult = m_Manage-&gt;m_pISCardTypeConv-&gt;CreateByteBuffer(ulLength, <br>&amp;pData); <br>if ( FAILED(hresult) ) <br>throw (hresult); <br> <br>// Write data to the buffer - High byte of file ID first! <br>byID = HIBYTE(wFilePath); <br>pData-&gt;Write( (BYTE*) &amp;byID, (LONG) ulLength, (LONG*) &amp;ulBytesWritten ); <br>byID = LOBYTE(wFilePath); <br>pData-&gt;Write( (BYTE*) &amp;byID, (LONG) ulLength, (LONG*) &amp;ulBytesWritten ); <br> <br>// Create the p1-p2 paramters <br>byP1 = SC_ID_MF_DF_EF; <br>byP2 = (SC_ONLY_OCCUR | SC_RETURN_FCI); <br>// ISO7186 COM builds command <br>hresult = m_Manage-&gt;m_pISCardISO7816-&gt;SelectFile(byP1, <br>byP2, <br>pData, <br>0, <br>&amp;pCmd); <br> <br> <br>if (FAILED(hresult)) <br>throw hresult; <br> <br>// Force correct class id for the vendor's card <br>hresult = pCmd-&gt;put_ClassId(VENDOR_CLASS_ID); <br>if (FAILED(hresult)) <br>throw (hresult); <br> <br>hresult = m_Manage-&gt;m_pISCard-&gt;LockSCard(); <br>if (FAILED(hresult)) <br>throw (hresult); <br>hresult = m_Manage-&gt;m_pISCard-&gt;Transaction(&amp;pCmd); <br>if (FAILED(hresult)) <br>throw (hresult); <br>hresult = m_Manage-&gt;m_pISCard-&gt;UnlockSCard(LEAVE); <br>if (FAILED(hresult)) <br>throw (hresult); <br> <br>//interpret return APDU <br>hresult = pCmd-&gt;get_ApduReplyLength(&amp;m_lReplyLength); <br>if (FAILED(hresult)) <br>throw (hresult); <br>hresult = pCmd-&gt;get_ReplyStatus( &amp;m_wReplyStatus ); <br>if (FAILED(hresult)) <br>throw (hresult); <br>if (HIBYTE(m_wReplyStatus)==SC_STATUS_MOREDATA) { <br>hresult = GrabData.GetExtraData(&amp;pResultData,  <br>&amp;m_wReplyStatus, <br>&amp;m_lReplyLength); <br>if (FAILED(hresult)) <br>throw (hresult); <br>// Todo: Store returned file specfic data?? <br>} <br>else if (m_wReplyStatus!=SC_STATUS_SUCCESS) <br>throw ( (HRESULT) E_FAIL ); <br>} <br> <br>catch (HRESULT hr) { <br>hresult = hr; <br>TRACE_CATCH(_T("FileSelect"), hr); <br>} <br> <br>catch (...) { <br>hresult = (HRESULT) E_UNEXPECTED; <br>TRACE_CATCH_UNKNOWN(_T("FileSelect")); <br>} <br> <br>// Free the ByteBuffer <br>if (pData != NULL) <br>pData-&gt;Release(); <br>if (pResultData != NULL) <br>pResultData-&gt;Release(); <br>// Release cmd interface <br>if (pCmd != NULL) <br>pCmd-&gt;Release(); <br> <br>m_CriticalSection.ExitCriticalSection(); <br> <br>return hresult; <br>} <br> <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// <br>// ISCardFileAccess Methods <br>// <br> <br> <br>/*++ <br> <br>CSCardFileAccess::ChangeDir: <br> <br>This method changing the current smartcard directory to the new <br>specified directory. <br> <br>Arguments: <br> <br>    refType - specifies the type of reference used in PathSpec as follows <br>SC_TYPE_BY_NAME <br>SC_TYPE_BY_ID <br>SC_TYPE_BY_SHORT_ID <br>SC_TYPE_BY_ANY <br>  in this example code we are only supporting SC_TYPE_BY_ID <br>   <br>NewDir - Specifies an File to select. (It must be &lt; 4 for this example.) <br> <br>Return Value: <br> <br>    A HRESULT value indicating the status of the requested action. <br> <br>ReturnMeaning <br>============= <br>S_OKOperation completed successfully. <br>S_FALSEUnknown error occurred. <br>E_OUTOFMEMORYThere is not enough memory in this process to  <br>satisfy the request. <br>E_FAILUnspecified error. <br>E_INVALIDARGOne or more arguments are invalid. <br>E_UNEXPECTEDUnexpected event occurred in this function. <br> <br>Author: <br> <br>Notes: <br> <br>This example code and assumes a ISO7816 supported file structure on  <br>the ICC and passes the given bstrNewDir directly too the corresponding ISO7816  <br>command as an absolute path only (i.e. beginning from MF).  <br> <br>--*/ <br> <br>STDMETHODIMP CSCardFileAccess::ChangeDir( <br>REFTYPE refType, <br>BSTR bstrNewDir) <br>{ <br>//locals <br>HRESULThresult = S_OK; <br>WORDwFileID; <br> <br>try { <br>// Is internal pointer to "Creation Class" valid <br>if (m_Manage == NULL) <br>throw ( (HRESULT) E_FAIL ); <br> <br>// only supporting SC_TYPE_BY_ID <br>if ( refType != SC_TYPE_BY_ID ) <br>throw ( (HRESULT) E_INVALIDARG ); <br>// convert and store <br>wFileID = ConvertFilename(bstrNewDir); <br>hresult = FileSelect(wFileID); <br>if (FAILED(hresult)) <br>throw (hresult); <br>// success...store the path <br>m_wCurrentFileID = wFileID; <br>} <br> <br>catch (HRESULT hr) { <br>hresult = hr; <br>TRACE_CATCH(_T("ChangeDir"), hr); <br>} <br> <br>catch (...) { <br>hresult = (HRESULT) E_UNEXPECTED; <br>TRACE_CATCH_UNKNOWN(_T("ChangeDir")); <br>} <br> <br>return hresult; <br>} <br> <br>/*++ <br> <br>CSCardFileAccess::Close: <br> <br>This method closes the specified file. No further access to file is <br>allowed. <br> <br>Arguments: <br> <br>    hFile - An HSCARD_FILE to the file to be closed. <br> <br>Return Value: <br> <br>    A HRESULT value indicating the status of the requested action. <br> <br>ReturnMeaning <br>============= <br>S_OKOperation completed successfully. <br>S_FALSEUnknown error occurred. <br>E_OUTOFMEMORYThere is not enough memory in this process to  <br>satisfy the request. <br>E_FAILUnspecified error. <br>E_INVALIDARGOne or more arguments are invalid. <br>E_UNEXPECTEDUnexpected event occurred in this function. <br> <br>Author: <br> <br> <br>Notes: <br> <br>Use of Open or Close methods involves updating an internal CMap object which <br>tracks the current open file information (handle, name, etc).  <br> <br>--*/ <br> <br>STDMETHODIMP CSCardFileAccess::Close( <br>HSCARD_FILE hFile) <br>{ <br>//locals <br>HRESULThresult = S_OK; <br>FILE_INFORMATIONFileInfo; <br> <br> <br>try { <br>// Is internal pointer to "Creation Class" valid <br>if (m_Manage == NULL) <br>throw ( (HRESULT) E_FAIL ); <br> <br>m_CriticalSection.EnterCriticalSection(); <br>// Lookup the handle in the file map <br>if ( !m_FileInfoMap.Lookup(hFile, FileInfo) ) <br>throw ( (HRESULT) E_HANDLE); <br> <br>if ( !m_FileInfoMap.RemoveKey(hFile) ) <br>throw ( (HRESULT) E_FAIL); <br>m_CriticalSection.ExitCriticalSection(); <br>} <br> <br>catch (HRESULT hr) { <br>hresult = hr; <br>TRACE_CATCH(_T("Close"), hr); <br>} <br> <br>catch (...) { <br>hresult = (HRESULT) E_UNEXPECTED; <br>TRACE_CATCH_UNKNOWN(_T("Close")); <br>} <br> <br>return hresult; <br>} <br> <br> <br>/*++ <br> <br>CSCardFileAccess::Create: <br> <br>The method creates a file at a given location within the smartcard file <br>system. <br> <br>Arguments: <br> <br>    refType - Specifies the type of file to be created (directory, fixed length,  <br>etc.) <br> <br>bstrPathSpec - specifies file to be created within current context <br> <br>ppTLVs - list of TLV structures, with file properties that have to be set. <br> <br>lpcTLVs -- number of entries in TLV <br> <br>Flags - specifies whether Secure Messaging should be used and data  <br>pre-allocated <br> <br>pDataBuffer - pointer to pre-allocated data <br> <br>Return Value: <br> <br>    A HRESULT value indicating the status of the requested action. <br> <br>ReturnMeaning <br>============= <br>S_OKOperation completed successfully. <br>S_FALSEUnknown error occurred. <br>E_OUTOFMEMORYThere is not enough memory in this process to  <br>satisfy the request. <br>E_FAILUnspecified error. <br>E_INVALIDARGOne or more arguments are invalid. <br>E_UNEXPECTEDUnexpected event occurred in this function. <br> <br>Author: <br> <br>--*/ <br> <br>STDMETHODIMP CSCardFileAccess::Create( <br>REFTYPE refType, <br>BSTR bstrPathSpec, <br>LPTLV_TABLE* ppTLVs, <br>LONG* lpcTLVs, <br>SCARD_FLAGS Flags, <br>LPBYTEBUFFER pDataBuffer) <br>{ <br>//locals <br>HRESULThresult = E_NOTIMPL; <br> <br>// to do <br>// This method should be implemented if the ICC supports this command.  <br> <br>return hresult; <br>} <br> <br> <br>/*++ <br> <br>CSCardFileAccess::Delete: <br> <br>The method deletes a file at a given location. <br> <br>Arguments: <br> <br>refType - references filename type (ID, short ID, etc) used in  <br>bstrPathSpec. <br> <br>    bstrPathSpec - specifies file to be deleted  <br> <br>Flags - specifies whether secure messaging should be used. In the case of a  <br>directory file(DF), this parameter specifies whether complete tree below the <br>dir should be deleted <br> <br>Return Value: <br> <br>    A HRESULT value indicating the status of the requested action. <br> <br>ReturnMeaning <br>============= <br>S_OKOperation completed successfully. <br>S_FALSEUnknown error occurred. <br>E_OUTOFMEMORYThere is not enough memory in this process to  <br>satisfy the request. <br>E_FAILUnspecified error. <br>E_INVALIDARGOne or more arguments are invalid. <br>E_UNEXPECTEDUnexpected event occurred in this function. <br> <br>Author: <br> <br>Note: <br> <br>This is an EXAMPLE of using ISO7816 Erase Binary to remove a file. This should <br>be updated to support your specific ICC and file type(s). <br> <br>--*/ <br> <br>STDMETHODIMP CSCardFileAccess::Delete( <br>REFTYPE refType, <br>BSTR bstrPathSpec, <br>SCARD_FLAGS Flag) <br>{ <br>//locals <br>HRESULThresult = E_NOTIMPL; <br> <br>try { <br>// Todo: <br>} <br> <br>catch (HRESULT hr) { <br>hresult = hr; <br>TRACE_CATCH(_T("Delete"), hr); <br>} <br> <br>catch (...) { <br>hresult = (HRESULT) E_UNEXPECTED; <br>TRACE_CATCH_UNKNOWN(_T("Delete")); <br>} <br> <br>return hresult; <br>} <br> <br> <br>/*++ <br> <br>CSCardFileAccess::Directory: <br> <br>Retrieve a list of files of the specified type. <br> <br>Arguments: <br> <br>    fileType - specifies the type of files to be listed <br> <br>ppFileList - returned list of specified files as array of BSTRs <br> <br>Part 6 of the PC/SC Interoperability Specification for ICCs and Personal <br>Computer Systems calls for a variable describing the length of ppFileList; <br>as BSTRs include their length, this variable is excluded from this  <br>example implementation. <br> <br>Return Value: <br> <br>    A HRESULT value indicating the status of the requested action. <br> <br>ReturnMeaning <br>============= <br>S_OKOperation completed successfully. <br>S_FALSEUnknown error occurred. <br>E_OUTOFMEMORYThere is not enough memory in this process to  <br>satisfy the request. <br>E_FAILUnspecified error. <br>E_INVALIDARGOne or more arguments are invalid. <br>E_UNEXPECTEDUnexpected event occurred in this function. <br> <br>Author: <br> <br>--*/ <br> <br>STDMETHODIMP CSCardFileAccess::Directory( <br>FILETYPE fileType, <br>LPSAFEARRAY *ppFileList) <br>{ <br>//locals <br>HRESULThresult = E_NOTIMPL; <br> <br>// to do <br>// This method should be implemented if the ICC supports this command.  <br> <br>return hresult; <br>} <br> <br> <br>/*++ <br> <br>CSCardFileAccess::GetCurrentDirectory: <br> <br>This method returns an absolute path to the currently selected directory <br> <br>Arguments: <br> <br>    pbstrPathSpec - pointer to a BSTR containing the path <br> <br>Return Value: <br> <br>    A HRESULT value indicating the status of the requested action. <br> <br>ReturnMeaning <br>============= <br>S_OKOperation completed successfully. <br>S_FALSEUnknown error occurred. <br>E_OUTOFMEMORYThere is not enough memory in this process to  <br>satisfy the request. <br>E_FAILUnspecified error. <br>E_INVALIDARGOne or more arguments are invalid. <br>E_UNEXPECTEDUnexpected event occurred in this function. <br> <br>Author: <br> <br>Notes: <br> <br>1) The calling application MUST free this global memory allocated for <br>the BSTR. <br> <br>--*/ <br> <br>STDMETHODIMP CSCardFileAccess::GetCurrentDir( <br>BSTR* pbstrPathSpec) <br>{ <br>//locals <br>HRESULThresult = E_NOTIMPL; <br> <br>// Todo: <br>// Add return directory code. <br> <br>return hresult; <br>} <br> <br> <br>/*++ <br> <br>CSCardFileAccess::GetFileCapabilities <br> <br>Retrieve list of file capabilities. <br> <br>Arguments: <br> <br>    ppProperties - list of TLV_TABLE structures indicating the files for which <br>to get properties on input, and containing those properties on output. <br> <br>plProperties - pointer to LONG containing the number of elements in  <br>pProperties <br> <br>Flags - flags <br> <br>Return Value: <br> <br>    A HRESULT value indicating the status of the requested action. <br> <br>ReturnMeaning <br>============= <br>S_OKOperation completed successfully. <br>S_FALSEUnknown error occurred. <br>E_OUTOFMEMORYThere is not enough memory in this process to  <br>satisfy the request. <br>E_FAILUnspecified error. <br>E_INVALIDARGOne or more arguments are invalid. <br>E_UNEXPECTEDUnexpected event occurred in this function. <br> <br>Author: <br> <br>--*/ <br>STDMETHODIMP CSCardFileAccess::GetFileCapabilities( <br>LPTLV_TABLE* ppProperties, <br>LONG *plProperties, <br>SCARD_FLAGS Flags) <br>{ <br>//locals <br>HRESULThresult = E_NOTIMPL; <br> <br>// to do <br>return hresult; <br>} <br> <br> <br>/*++ <br> <br>CSCardFileAccess::GetProperties <br> <br>Retrieve the primitive data refered by tags (TLV) for the specified <br>object <br> <br>Arguments: <br> <br>    refType - specifies the type of reference to the file <br> <br>bstrPathSpec - specifies the file to use. <br> <br>ppTLV - point to TLV structs whose value has been retrieved. <br> <br>plcTLV - number of entries in ppTLV <br> <br>Flags - specifies whether Secure Messaging has to be used. <br> <br>Return Value: <br> <br>    A HRESULT value indicating the status of the requested action. <br> <br>ReturnMeaning <br>============= <br>S_OKOperation completed successfully. <br>S_FALSEUnknown error occurred. <br>E_OUTOFMEMORYThere is not enough memory in this process to  <br>satisfy the request. <br>E_FAILUnspecified error. <br>E_INVALIDARGOne or more arguments are invalid. <br>E_UNEXPECTEDUnexpected event occurred in this function. <br> <br>Author: <br> <br>--*/ <br> <br>STDMETHODIMP CSCardFileAccess::GetProperties( <br>REFTYPE refType, <br>BSTR bstrPathSpec, <br>LPTLV_TABLE* ppTLV, <br>LONG* plcTLV, <br>SCARD_FLAGS Flags) <br>{ <br>//locals <br>HRESULThresult = E_NOTIMPL; <br> <br>// to do <br>return hresult; <br>} <br> <br> <br>/*++ <br> <br>CSCardAuth::Initialize <br> <br>Initializes the object for use. <br> <br>Arguments: <br> <br>lp - a long pointer to the "controlling" ISCardManage object. <br> <br>Return Value: <br> <br>    A HRESULT value indicating the status of the requested action. <br> <br>ReturnMeaning <br>============= <br>S_OKOperation completed successfully. <br>S_FALSEUnknown error occurred. <br>E_OUTOFMEMORYThere is not enough memory in this process to  <br>satisfy the request. <br>E_FAILUnspecified error. <br>E_INVALIDARGOne or more arguments are invalid. <br>E_UNEXPECTEDUnexpected event occurred in this function. <br> <br>Author: <br> <br>--*/ <br>STDMETHODIMP CSCardFileAccess::Initialize( LONG *lp) <br>{ <br>// Locals <br>HRESULThresult = S_OK; <br> <br>try { <br>// Check Params, etc.. <br>if (lp == NULL) <br>throw ( (HRESULT) E_INVALIDARG ); <br> <br>if (m_Manage != NULL) <br>throw ( (HRESULT) E_FAIL ); <br> <br>// Ok... <br>m_Manage = (LPCSCARDMANAGE) lp; <br>} <br> <br>catch (HRESULT hr) { <br>hresult=hr; <br>TRACE_CATCH(_T("Initialize"), hr); <br>} <br> <br>catch (...) { <br>hresult = (HRESULT) E_UNEXPECTED; <br>TRACE_CATCH_UNKNOWN(_T("Initialize")); <br>} <br> <br>return (hresult); <br>} <br> <br> <br>/*++ <br> <br>CSCardFileAccess::Invalidate: <br> <br>Invalidate the specified file (EF or DF). An invalidated file cannot <br>be accessed by other methods prior to using rehabilitate <br> <br>Arguments: <br> <br>    bstrPathSpec - specifies file to be invalidated (relative path) <br> <br>Flag - specifies whether Secure Messaging is to be used <br> <br>Return Value: <br> <br>    A HRESULT value indicating the status of the requested action. <br> <br>ReturnMeaning <br>============= <br>S_OKOperation completed successfully. <br>S_FALSEUnknown error occurred. <br>E_OUTOFMEMORYThere is not enough memory in this process to  <br>satisfy the request. <br>E_FAILUnspecified error. <br>E_INVALIDARGOne or more arguments are invalid. <br>E_UNEXPECTEDUnexpected event occurred in this function. <br> <br>Author: <br> <br>--*/ <br> <br>STDMETHODIMP CSCardFileAccess::Invalidate( <br>BSTR bstrPathSpec, <br>SCARD_FLAGS Flags) <br>{ <br>//locals <br>HRESULThresult = E_NOTIMPL; <br> <br>// to do <br>// This method should be implemented if the ICC supports this command.  <br> <br>return hresult; <br>} <br> <br> <br>/*++ <br> <br>CSCardFileAccess::Open <br> <br>Opens the specified file for further use <br> <br>Arguments: <br> <br>    refType - Specifies the type of reference to the file <br> <br>bstrPathSpec - specifies the file to open. <br> <br>hFile - HSCARD_FILE to file if successful, NULL otherwise. <br> <br>Return Value: <br> <br>    A HRESULT value indicating the status of the requested action. <br> <br>ReturnMeaning <br>============= <br>S_OKOperation completed successfully. <br>S_FALSEUnknown error occurred. <br>E_OUTOFMEMORYThere is not enough memory in this process to  <br>satisfy the request. <br>E_FAILUnspecified error. <br>E_INVALIDARGOne or more arguments are invalid. <br>E_UNEXPECTEDUnexpected event occurred in this function. <br> <br>Author: <br> <br>Notes: <br> <br>This method DOES NOT read file headers. It defaults to setting the <br>class type as transparent EF. <br> <br>--*/ <br> <br>STDMETHODIMP CSCardFileAccess::Open( <br>REFTYPE refType, <br>BSTR bstrPathSpec, <br>HSCARD_FILE *phFile) <br>{ <br>//locals <br>HRESULThresult = E_NOTIMPL; <br>FILE_INFORMATIONFileInfo; <br>WORDwFileID; <br> <br>try { <br>// Is internal pointer to "Creation Class" valid <br>if (m_Manage == NULL) <br>throw ( (HRESULT) E_FAIL ); <br> <br>if ( (bstrPathSpec == NULL) || (phFile == NULL) ) <br>throw ( (HRESULT) E_INVALIDARG ); <br>// Does file exist? <br>wFileID = ConvertFilename(bstrPathSpec); <br>if (wFileID == 0 ) <br>throw ( (HRESULT) E_FAIL ); <br> <br>hresult = FileSelect( wFileID ); <br>if (FAILED(hresult)) <br>throw (hresult); <br> <br>*phFile = CreateFileHandle(); <br>if (*phFile == 0) <br>throw ( (HRESULT) E_FAIL); <br> <br>m_CriticalSection.EnterCriticalSection(); <br>// Create file info struct and add to map <br>FileInfo.fileHandle = *phFile; <br>FileInfo.fileStatus= SC_FL_STAT_DEFAULT; <br>FileInfo.wfileName = wFileID; <br>// Assume transparent EF for this example. <br>FileInfo.fileType = SC_TYPE_TRANSPARENT_EF; <br>FileInfo.lSeekOffset = 0; <br>m_FileInfoMap.SetAt(*phFile,FileInfo); <br>m_CriticalSection.ExitCriticalSection(); <br> <br>} <br> <br>catch (HRESULT hr) { <br>hresult = hr; <br>TRACE_CATCH(_T("Open"),hr); <br>} <br> <br>catch (...) { <br>hresult = (HRESULT) E_UNEXPECTED; <br>TRACE_CATCH_UNKNOWN(_T("Open")); <br>} <br> <br>return hresult; <br>} <br> <br> <br>/*++ <br> <br>CSCardFileAccess::Read <br> <br>This method reads and returns the specifed data from a given file <br> <br>Arguments: <br> <br>    HSCARD_FILE - contains the handle of the file to access <br> <br>lBytesToRead - length of the data object to be read from file <br> <br>ppBuffer - if successful, contains the read data <br> <br>Flags - specifies whether Secure Messaging is to be used <br> <br>Return Value: <br> <br>    A HRESULT value indicating the status of the requested action. <br> <br>ReturnMeaning <br>============= <br>S_OKOperation completed successfully. <br>S_FALSEUnknown error occurred. <br>E_OUTOFMEMORYThere is not enough memory in this process to  <br>satisfy the request. <br>E_FAILUnspecified error. <br>E_INVALIDARGOne or more arguments are invalid. <br>E_UNEXPECTEDUnexpected event occurred in this function. <br> <br>Author: <br> <br>Notes: <br> <br>As is this routine mainly supports the write to a transparent EF. This <br>is the default given to the file type on Open within this class. <br> <br>--*/ <br> <br>STDMETHODIMP CSCardFileAccess::Read( <br>HSCARD_FILE hFile, <br>LONG *lBytesToRead, <br>LPBYTEBUFFER *ppBuffer, <br>SCARD_FLAGS Flags) <br>{ <br>//locals <br>HRESULThresult = S_OK; <br>FILE_INFORMATIONFileInfo; <br>LPBYTEBUFFERpData = NULL; <br>LPSCARDCMDpCmd = NULL; <br>LONGcbBufferSize = 0, <br>cbToRead = 0; <br>BYTErgbyReadData[MAX_READ_LEN], <br>byP1 = 0, <br>byP2 = 0; <br>WORDwOffset = 0; <br>LONGlReplyLength = 0; <br>LARGE_INTEGERli; <br> <br>try { <br>// Is internal pointer to "Creation Class" valid <br>if (m_Manage == NULL) <br>throw ( (HRESULT) E_FAIL ); <br> <br>// Check Params... <br>if (*lBytesToRead == NULL) <br>throw ( (HRESULT) E_POINTER); <br>if (*lBytesToRead &lt;=0 ) <br>throw ( (HRESULT) E_INVALIDARG ); <br> <br>// Create return buffer if required <br>if (*ppBuffer == NULL) { <br>// Create z new buffer  <br>hresult = m_Manage-&gt;m_pISCardTypeConv-&gt;CreateByteBuffer((ULONG) *lBytesToRead, <br>ppBuffer); <br>if ( FAILED(hresult) ) <br>throw (hresult); <br>}; <br> <br> <br>m_CriticalSection.EnterCriticalSection(); <br>// Check for valid handle <br>if (!m_FileInfoMap.Lookup(hFile, FileInfo)) <br>throw ( (HRESULT) E_HANDLE ); <br>m_CriticalSection.ExitCriticalSection(); <br>// Change directory <br>hresult = FileSelect(FileInfo.wfileName); <br>if (FAILED(hresult)) <br>throw (hresult); <br> <br>// Create Cmd Object <br>hresult = m_Manage-&gt;CreateCmdObject(&amp;pCmd); <br>if (FAILED(hresult)) <br>throw (hresult); <br> <br>// Set the size for amount of data to be read from file <br>cbBufferSize = (*lBytesToRead); <br> <br>// set Seek position to the head of buffer where return data will be read <br>LISet32 (li, BYTE_BUFFER_HEAD ); <br>hresult = (*ppBuffer)-&gt;Seek((LONG) li.LowPart, <br>(LONG) STREAM_SEEK_SET, <br>NULL); <br>if (FAILED(hresult)) <br>throw hresult; <br> <br>// Loop to read complete file into retur buffer <br>while (cbBufferSize &gt; 0) { <br>// Determine amount of data to write <br>if (cbBufferSize &lt;= MAX_READ_LEN) { <br>// Set bytes to read <br>cbToRead = cbBufferSize; <br>// Last time through, clear it <br>cbBufferSize = 0; <br>} <br>else { <br>// Read max bytes <br>cbToRead = MAX_READ_LEN; <br>// Decrement total number bytes remaining to read <br>cbBufferSize -= MAX_READ_LEN; <br>}; <br> <br>// Build correct command based on file type <br>switch (FileInfo.fileType) { <br>case SC_TYPE_TRANSPARENT_EF: <br>byP1 = HIBYTE(wOffset); <br>byP2 = LOBYTE(wOffset); <br>// Build Update command for TRANSPARENT (i.e. Binary) file <br>hresult = m_Manage-&gt;m_pISCardISO7816-&gt;ReadBinary(   byP1, <br>byP2, <br>cbToRead, <br>&amp;pCmd); <br>if (FAILED(hresult)) <br>throw (hresult); <br>// Calculate the new offset for the command </code></pre>
<p>
</p>
<pre><code>wOffset += (WORD) cbToRead; <br>break; <br>default: <br>break; <br>};// switch <br> <br> <br>// Force correct class id for the vendor's card <br>hresult = pCmd-&gt;put_ClassId(VENDOR_CLASS_ID); <br>if (FAILED(hresult)) <br>throw (hresult); <br> <br>// Do complete transaction <br>hresult = m_Manage-&gt;m_pISCard-&gt;LockSCard(); <br>if (FAILED(hresult)) <br>throw (hresult); <br>hresult = m_Manage-&gt;m_pISCard-&gt;Transaction(&amp;pCmd); <br>if (FAILED(hresult)) <br>throw (hresult); <br>hresult = m_Manage-&gt;m_pISCard-&gt;UnlockSCard(LEAVE); <br>if (FAILED(hresult)) <br>throw (hresult); <br> <br>// Get status of command <br>hresult = pCmd-&gt;get_ReplyStatus( &amp;m_wReplyStatus ); <br>if (FAILED(hresult)) <br>throw (hresult); <br>if (m_wReplyStatus != SC_STATUS_SUCCESS) <br>throw ( (HRESULT) E_FAIL ); <br> <br>// Get reply data (i.e. the data that was read from file) and length <br>hresult = pCmd-&gt;get_ApduReply( &amp;pData ); <br>if (FAILED(hresult)) <br>throw (hresult); <br>hresult = pCmd-&gt;get_ApduReplyLength(&amp;lReplyLength); <br>if (FAILED(hresult)) <br>throw (hresult); <br>if (lReplyLength&lt;0) <br>throw ((HRESULT) E_FAIL); <br> <br> <br>// Set Seek pointer of return buffer <br>hresult = pData-&gt;Seek((LONG) li.LowPart, <br>(LONG) STREAM_SEEK_SET, <br>NULL); <br>if (FAILED(hresult)) <br>throw hresult; <br>// Read reply data into temp buffer <br>hresult = pData-&gt;Read((LPBYTE) rgbyReadData, <br>(LONG) (lReplyLength-2), //Read reply data-status bytes <br>NULL); <br>if (FAILED(hresult)) <br>throw (hresult); <br>// Write temp buffer back into return buffer <br>hresult = (*ppBuffer)-&gt;Write((LPBYTE) rgbyReadData, <br>(LONG) (lReplyLength-2), //Read reply data-status bytes <br>NULL); <br>if (FAILED(hresult)) <br>throw (hresult); <br>// Release the Reply buffer <br>if (pData != NULL) <br>pData-&gt;Release(); <br>}; //while - write buffer <br>} <br> <br>catch (HRESULT hr) { <br>hresult = hr; <br>TRACE_CATCH(_T("Read"),hr); <br>} <br> <br>catch (...) { <br>hresult = (HRESULT) E_UNEXPECTED; <br>TRACE_CATCH_UNKNOWN(_T("Read")); <br>} <br> <br>// Clean Up <br>if (pCmd != NULL) <br>pCmd-&gt;Release(); <br> <br>return hresult; <br>} <br> <br> <br>/*++ <br> <br>CSCardFileAccess::Rehabilitate <br> <br>Makes a file (EF or DF), which has been previously invalidated with the <br>invalidate command, accessable by the application. <br> <br>Arguments: <br> <br>    bstrPathSpec - specifies the file to be invalidated (relative path) <br> <br>Flag - specifies whether Secure Messaging is to be used <br> <br>Return Value: <br> <br>    A HRESULT value indicating the status of the requested action. <br> <br>ReturnMeaning <br>============= <br>S_OKOperation completed successfully. <br>S_FALSEUnknown error occurred. <br>E_OUTOFMEMORYThere is not enough memory in this process to  <br>satisfy the request. <br>E_FAILUnspecified error. <br>E_INVALIDARGOne or more arguments are invalid. <br>E_UNEXPECTEDUnexpected event occurred in this function. <br> <br>Author: <br> <br>--*/ <br> <br>STDMETHODIMP CSCardFileAccess::Rehabilitate( <br>BSTR bstrPathSpec, <br>SCARD_FLAGS Flags) <br>{ <br>//locals <br>HRESULThresult = E_NOTIMPL; <br> <br>// to do <br>// This method should be implemented if the ICC supports this command.  <br> <br>return hresult; <br>} <br> <br> <br>/*++ <br> <br>CSCardFileAccess::Seek <br> <br>Selects the object form which (read/write) access will be done <br> <br>Arguments: <br> <br>    hFile - contains the handle of the file to access <br> <br>lOffset - is the number of data objects from the reference object <br> <br>Seek - specifies the type of seek access on the file <br> <br>Return Value: <br> <br>    A HRESULT value indicating the status of the requested action. <br> <br>ReturnMeaning <br>============= <br>S_OKOperation completed successfully. <br>S_FALSEUnknown error occurred. <br>E_OUTOFMEMORYThere is not enough memory in this process to  <br>satisfy the request. <br>E_FAILUnspecified error. <br>E_INVALIDARGOne or more arguments are invalid. <br>E_UNEXPECTEDUnexpected event occurred in this function. <br> <br>Author: <br> <br>Notes: <br> <br>--*/ <br> <br>STDMETHODIMP CSCardFileAccess::Seek( <br>HSCARD_FILE hFile, <br>LONG lOffset, <br>SEEKTYPE Seek) <br>{ <br>//locals <br>HRESULThresult = S_OK; <br>FILE_INFORMATIONFileInfo; <br> <br>try { <br>// Is internal pointer to "Creation Class" valid <br>if (m_Manage == NULL) <br>throw ( (HRESULT) E_FAIL ); <br> <br>// Check Params... <br>if (lOffset &lt;0) <br>throw ( (HRESULT) E_INVALIDARG); <br>// We are only seeking from beginning of the file <br>if (Seek != SC_SEEK_FROM_BEGINNING) <br>throw ( (HRESULT) E_INVALIDARG ); <br> <br>m_CriticalSection.EnterCriticalSection(); <br>// Check for valid handle <br>if (!m_FileInfoMap.Lookup(hFile, FileInfo)) <br>throw ( (HRESULT) E_HANDLE ); <br>// Store the seek/record position <br>FileInfo.lSeekOffset = lOffset; <br>m_FileInfoMap.SetAt(hFile, FileInfo); <br>m_CriticalSection.ExitCriticalSection(); <br> <br>} <br> <br>catch (HRESULT hr) { <br>hresult = hr; <br>TRACE_CATCH(_T("Seek"), hr); <br>} <br> <br>catch (...) { <br>hresult = (HRESULT) E_UNEXPECTED; <br>TRACE_CATCH_UNKNOWN(_T("Seek")); <br>} <br> <br>return hresult; <br>} <br> <br> <br>/*++ <br> <br>CSCardFileAccess::SetProperties <br> <br>Set the primitive data refered by tags (TLV) for the specified <br>object <br> <br>Arguments: <br> <br>    refType - specifies the type of reference to the file <br> <br>bstrPathSpec - specifies the file to use (relative or absolute path). <br> <br>pTLV - point to TLV structs whose values have to set <br> <br>lcTLV - number of entries in ppTLV <br> <br>Flags - specifies whether Secure Messaging has to be used. <br> <br>Return Value: <br> <br>    A HRESULT value indicating the status of the requested action. <br> <br>ReturnMeaning <br>============= <br>S_OKOperation completed successfully. <br>S_FALSEUnknown error occurred. <br>E_OUTOFMEMORYThere is not enough memory in this process to  <br>satisfy the request. <br>E_FAILUnspecified error. <br>E_INVALIDARGOne or more arguments are invalid. <br>E_UNEXPECTEDUnexpected event occurred in this function. <br> <br>Author: <br> <br>--*/ <br> <br>STDMETHODIMP CSCardFileAccess::SetProperties( <br>REFTYPE refType, <br>BSTR bstrPathSpec, <br>LPTLV_TABLE pTLV, <br>LONG lcTLV, <br>SCARD_FLAGS Flags) <br>{ <br>//locals <br>HRESULThresult = E_NOTIMPL; <br> <br>// to do <br>return hresult; <br>} <br> <br> <br>/*++ <br> <br>CSCardFileAccess::Write <br> <br>This method writes data to the specified file. <br> <br>Arguments: <br> <br>    HSCARD_FILE - contains the handle of the file to access <br> <br>lLength - length of the data object to write <br> <br>pData - contains the object/data to be written <br> <br>Flags - specifies whether Secure Messaging is to be used <br> <br>Return Value: <br> <br>    A HRESULT value indicating the status of the requested action. <br> <br>ReturnMeaning <br>============= <br>S_OKOperation completed successfully. <br>S_FALSEUnknown error occurred. <br>E_OUTOFMEMORYThere is not enough memory in this process to  <br>satisfy the request. <br>E_FAILUnspecified error. <br>E_INVALIDARGOne or more arguments are invalid. <br>E_UNEXPECTEDUnexpected event occurred in this function. <br> <br>Author: <br> <br> <br>Revision History <br> <br> <br>Note: <br> <br>As is this routine mainly supports the write to a transparent EF. This <br>is the default given to the file type on Open within this class. <br> <br>--*/ <br> <br>STDMETHODIMP CSCardFileAccess::Write( <br>HSCARD_FILE hFile, <br>LONG lLength, <br>LPBYTEBUFFER pData, <br>SCARD_FLAGS Flags) <br>{ <br>//locals <br>HRESULThresult = S_OK; <br>FILE_INFORMATIONFileInfo; <br>LPBYTEBUFFERpBuffer = NULL; <br>LPSCARDCMDpCmd = NULL; <br>LONGcbBufferSize = 0, <br>cbToWrite = 0; <br>BYTErgbyWriteData[MAX_WRITE_LEN], <br>byP1 = 0, <br>byP2 = 0; <br>STATSTRUCTstatstruct; <br>WORDwOffset = 0; <br>LARGE_INTEGERli; <br> <br>try { <br>// Is internal pointer to "Creation Class" valid <br>if (m_Manage == NULL) <br>throw ( (HRESULT) E_FAIL ); <br> <br>// Check Params... <br>if (pData == NULL) <br>throw ( (HRESULT) E_POINTER); <br> <br>m_CriticalSection.EnterCriticalSection(); <br>// Check for valid handle <br>if (!m_FileInfoMap.Lookup(hFile, FileInfo)) <br>throw ( (HRESULT) E_HANDLE ); <br>m_CriticalSection.ExitCriticalSection(); <br>// Change directory <br>hresult = FileSelect(FileInfo.wfileName); <br>if (FAILED(hresult)) <br>throw (hresult); <br> <br>// Create Cmd Object <br>hresult = m_Manage-&gt;CreateCmdObject(&amp;pCmd); <br>if (FAILED(hresult)) <br>throw (hresult); <br> <br>// Get the write buffer statistics <br>hresult = pData-&gt;Stat(&amp;statstruct, 0L ); <br>if (FAILED(hresult)) <br>throw (hresult); <br>if (statstruct.cbSize &lt;= 0) <br>throw ( (HRESULT) E_FAIL ); <br>cbBufferSize = statstruct.cbSize; <br> <br>// set Seek position/Read challenge to buffer's head <br>LISet32 (li, BYTE_BUFFER_HEAD ); <br>hresult = pData-&gt;Seek((LONG) li.LowPart, <br>(LONG) STREAM_SEEK_SET, <br>NULL); <br>if (FAILED(hresult)) <br>throw hresult; <br> <br>// Create new buffer for use in holding portion of data to be written to ICC <br>hresult = m_Manage-&gt;m_pISCardTypeConv-&gt;CreateByteBuffer(1L, <br>&amp;pBuffer); <br>if ( FAILED(hresult) ) <br>throw (hresult); <br> <br>// Loop to write complete buffer <br>while (cbBufferSize &gt; 0) { <br>// Determine amount of data to write <br>if (cbBufferSize &lt;= MAX_WRITE_LEN) { <br>// Set bytes to write <br>cbToWrite = cbBufferSize; <br>// Last time through, clear it <br>cbBufferSize = 0; <br>} <br>else { <br>// Write max bytes <br>cbToWrite = MAX_WRITE_LEN; <br>// Decrement total number bytes remaining to write <br>cbBufferSize -= MAX_WRITE_LEN; <br>}; <br> <br>// Read information from parameter write buffer <br>hresult = pData-&gt;Read((LPBYTE) rgbyWriteData, <br>cbToWrite, <br>NULL); <br>if (FAILED(hresult)) <br>throw (hresult); <br> <br>// Set Seek pointer to write into temp buffer at its head <br>hresult = pBuffer-&gt;Seek((LONG) li.LowPart, <br>(LONG) STREAM_SEEK_SET, <br>NULL); <br>if (FAILED(hresult)) <br>throw hresult; <br> <br>// Set buffer size and write information <br>hresult = pBuffer-&gt;SetSize( cbToWrite ); <br>hresult = pBuffer-&gt;Write((LPBYTE) rgbyWriteData, <br>cbToWrite, <br>NULL); <br>if (FAILED(hresult)) <br>throw (hresult); <br> <br>// Build correct command based on file type <br>switch (FileInfo.fileType) { <br>case SC_TYPE_TRANSPARENT_EF: <br>byP1 = HIBYTE(wOffset); <br>byP2 = LOBYTE(wOffset); <br>// Build Update command for TRANSPARENT (i.e. Binary) file <br>hresult = m_Manage-&gt;m_pISCardISO7816-&gt;UpdateBinary( byP1, <br>byP2, <br>pBuffer, <br>&amp;pCmd); <br>if (FAILED(hresult)) <br>throw (hresult); <br>// Calculate the new offset for the command <br>wOffset += (WORD) cbToWrite; <br>break; <br>default: <br>break; <br>};// switch <br> <br> <br>// Force correct class id for the vendor's card <br>hresult = pCmd-&gt;put_ClassId(VENDOR_CLASS_ID); <br>if (FAILED(hresult)) <br>throw (hresult); <br> <br>// Do complete transaction <br>hresult = m_Manage-&gt;m_pISCard-&gt;LockSCard(); <br>if (FAILED(hresult)) <br>throw (hresult); <br>hresult = m_Manage-&gt;m_pISCard-&gt;Transaction(&amp;pCmd); <br>if (FAILED(hresult)) <br>throw (hresult); <br>hresult = m_Manage-&gt;m_pISCard-&gt;UnlockSCard(LEAVE); <br>if (FAILED(hresult)) <br>throw (hresult); <br> <br>//interpret return APDU <br>hresult = pCmd-&gt;get_ReplyStatus( &amp;m_wReplyStatus ); <br>if (FAILED(hresult)) <br>throw (hresult); <br>if (m_wReplyStatus != SC_STATUS_SUCCESS) <br>throw ( (HRESULT) E_FAIL ); <br>}; //while - write buffer <br>} <br> <br>catch (HRESULT hr) { <br>hresult = hr; <br>TRACE_CATCH(_T("Write"), hr); <br>} <br> <br>catch (...) { <br>hresult = (HRESULT) E_UNEXPECTED; <br>TRACE_CATCH_UNKNOWN(_T("Write")); <br>} <br> <br>// Clean UP <br>if (pBuffer != NULL) <br>pBuffer-&gt;Release(); <br> <br>if (pCmd != NULL) <br>pCmd-&gt;Release(); <br> <br>return hresult; <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
