<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SCARDWRP.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6118"></a>SCARDWRP.CPP</h2>
<pre><code>/*++ <br> <br>Copyright (c) 1997  Microsoft Corporation <br> <br>Module Name: <br> <br>    scardwrp <br> <br>Abstract: <br> <br>    This file contains a simple class implementation for "wrapping" some <br>    of the Vendor COM Wrapper API functionality. <br> <br>Author: <br> <br>Environment: <br> <br>    Win32, C++ w/Exceptions, ATL, COM/OLE <br> <br>--*/ <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// <br>// Includes <br>// <br>#include "preapp.h"   //This include for the app SSP COM example <br>#include "SCardWrp.h" <br> <br>// GUIDs <br>#include &lt;WrpGUID.h&gt; <br>#include &lt;sspguid.h&gt; <br> <br>// OLE Specific headers <br>#include &lt;ole2.h&gt; <br>#include &lt;objbase.h&gt; <br>#include &lt;oleauto.h&gt; <br> <br>#ifdef _DEBUG <br>#define new DEBUG_NEW <br>#undef THIS_FILE <br>static char THIS_FILE[] = __FILE__; <br>#endif <br> <br>/////////////////////////////////////////////////////////////////////////// <br>// Macros <br>// <br>#ifdef _DEBUG <br>    #define TRACE_STR(name,sz) \ <br>                TRACE(_T("CSCardWrapper::%s: %s\n"), name, sz) <br>    #define TRACE_CODE(name,code) \ <br>                TRACE(_T("CSCardWrapper::%s: error = 0x%x\n"), name, code) <br>    #define TRACE_CATCH(name,code)      TRACE_CODE(name,code) <br>    #define TRACE_CATCH_UNKNOWN(name)   TRACE_STR(name,_T("An unidentified exception has occurred!")) <br>#else <br>    #define TRACE_STR(name,sz)          ((void)0) <br>    #define TRACE_CODE(name,code)       ((void)0) <br>    #define TRACE_CATCH(name,code)      ((void)0) <br>    #define TRACE_CATCH_UNKNOWN(name)   ((void)0) <br>#endif  // _DEBUG <br> <br> <br> <br>//////////////////////////////////////////////////////////////////////////// <br>// <br>// CSCardWrapper <br>// <br> <br> <br> <br>/*++ <br> <br>CSCardWrapper::CreateByteBuffer <br> <br>    This routines creates a byte buffer. <br>     <br>Arguments: <br> <br>    dwSize - size of bytebuffer to create <br>    ppBuffer - pointer to created buffer <br>     <br>Return Value: <br> <br>    A HRESULT value indicating the status of the requested action. <br> <br>    Return          Meaning <br>    ======          ======= <br>    S_OK            Operation completed successfully. <br>    S_FALSE         Unknown error occurred. <br>    E_OUTOFMEMORY   There is not enough memory in this process to <br>                    satisfy the request. <br>    E_FAIL          Unspecified error. <br>    E_INVALIDARG    One or more arguments are invalid. <br>    E_UNEXPECTED    Unexpected event occurred in this function. <br>     <br>Author: <br> <br>Notes: <br>     <br>--*/ <br>HRESULT CSCardWrapper::CreateByteBuffer(DWORD dwSize, <br>                                        LPBYTEBUFFER *ppBuffer) <br>{ <br>    //locals <br>    HRESULT     hresult = S_OK; <br>    LPCLASSFACTORY  lpClassFactory = NULL; <br> <br>    try { <br>        // Check Parames, etc <br>        if (ppBuffer == NULL) <br>            throw ( (HRESULT) E_INVALIDARG ); <br> <br>        // Do WIN 95 safe creation of the IByteBuffer IStream wrapper <br>        hresult = CoGetClassObject( CLSID_ByteBuffer, <br>                                    CLSCTX_LOCAL, <br>                                    NULL, <br>                                    IID_IClassFactory, <br>                                    (LPVOID*) &amp;lpClassFactory ); <br>        if (FAILED(hresult)) <br>            throw (hresult); <br>        ASSERT(lpClassFactory != NULL); <br>        hresult = lpClassFactory-&gt;CreateInstance(NULL, <br>                                                IID_IByteBuffer, <br>                                                (LPVOID*) ppBuffer); <br>        if (FAILED(hresult)) <br>            throw (hresult); <br>        ASSERT( (*ppBuffer) != NULL); <br> <br>        // Initialize the IStream wrapper <br>        hresult = (*ppBuffer)-&gt;Initialize(dwSize, NULL); <br>        if (FAILED(hresult)) <br>            throw (hresult); <br>    } <br> <br>    catch (HRESULT hr) { <br>        hresult = hr; <br>        TRACE_CATCH(_T("CreateByteBuffer"), hr); <br>    } <br> <br>    catch (...) { <br>        hresult = (HRESULT) E_UNEXPECTED; <br>        TRACE_CATCH_UNKNOWN(_T("CreateByteBuffer")); <br>    } <br>     <br>    return hresult; <br>} <br> <br> <br>/*++ <br> <br>CSCardWrapper::AttachToReaderByName <br> <br>    This routine attaches to a reader (and the card in that reader) <br>     <br>Arguments: <br> <br>    szReaderName = a null terminated wide character string <br>    containing the reader name <br>     <br>Return Value: <br> <br>    A HRESULT value indicating the status of the requested action. <br> <br>    Return          Meaning <br>    ======          ======= <br>    S_OK            Operation completed successfully. <br>    S_FALSE         Unknown error occurred. <br>    E_OUTOFMEMORY   There is not enough memory in this process to <br>                    satisfy the request. <br>    E_FAIL          Unspecified error. <br>    E_INVALIDARG    One or more arguments are invalid. <br>    E_UNEXPECTED    Unexpected event occurred in this function. <br>     <br>Author: <br> <br>Notes: <br>     <br>--*/ <br>HRESULT CSCardWrapper::AttachToReaderByName( WCHAR  *wszReaderName ) <br>{ <br>    //locals <br>    HRESULT     hresult = S_OK; <br>    BSTR        bstrReader = NULL; <br> <br>    try { <br>        if (!m_sequence.COMLoad) <br>            throw ( (HRESULT) E_FAIL); <br>        if (wszReaderName == NULL) <br>            throw ( (HRESULT) E_INVALIDARG ); <br>        // create the BSTR <br>        bstrReader = ::SysAllocString(wszReaderName); <br>        if (bstrReader == NULL) <br>            throw ( (HRESULT) E_OUTOFMEMORY ); <br>        // Attach to reader <br>        hresult=m_pISCardManage-&gt;AttachByIFD( bstrReader, SHARED ); <br>        if (FAILED(hresult)) <br>            throw(hresult); <br> <br>        // Ok... <br>        m_sequence.Attach = 1; <br>    } <br> <br>    catch (HRESULT hr) { <br>        hresult = hr; <br>        TRACE_CATCH(_T("AttachToReaderByName"), hr); <br>    } <br> <br>    catch (...) { <br>        hresult = (HRESULT) E_UNEXPECTED; <br>        TRACE_CATCH_UNKNOWN(_T("AttachToReaderByName")); <br>    } <br>     <br>    // Free memory <br>    if (bstrReader != NULL) <br>        ::SysFreeString(bstrReader); <br> <br>    return hresult; <br>} <br> <br> <br>/*++ <br> <br>CSCardWrapper::ChangeDirectory <br> <br>    Changes to the specified directory on the ICC. <br>     <br>Arguments: <br> <br>    wszDirectory = a null terminated wide character string <br>    containing the Directory <br>     <br>Return Value: <br> <br>    A HRESULT value indicating the status of the requested action. <br> <br>    Return          Meaning <br>    ======          ======= <br>    S_OK            Operation completed successfully. <br>    S_FALSE         Unknown error occurred. <br>    E_OUTOFMEMORY   There is not enough memory in this process to <br>                    satisfy the request. <br>    E_FAIL          Unspecified error. <br>    E_INVALIDARG    One or more arguments are invalid. <br>    E_UNEXPECTED    Unexpected event occurred in this function. <br>     <br>Author: <br> <br>Notes: <br>     <br>    This method is calling the ISO 7816-4 SelectFile command. The wszDirectory <br>    should ONLY be a 2-byte file ID (as supported by the vendor com example code). <br> <br>--*/ <br>HRESULT CSCardWrapper::ChangeDirectory( WCHAR *wszDirectory ) <br>{ <br>    //locals <br>    HRESULT     hresult = S_OK; <br>    BSTR        bstrDir = NULL; <br> <br>    try { <br>        // Are attached? <br>        if (!m_sequence.Attach) <br>            throw ( (HRESULT) E_FAIL ); <br>        if (wszDirectory == NULL) <br>            throw ( (HRESULT) E_INVALIDARG ); <br>        //Create BSTR <br>        bstrDir = ::SysAllocString(wszDirectory); <br>        if (bstrDir == NULL) <br>            throw ( (HRESULT) E_OUTOFMEMORY); <br>        //ChangeDir <br>        hresult=m_pISCardFileAccess-&gt;ChangeDir( SC_TYPE_BY_ID, <br>                                                bstrDir); <br>        if (FAILED(hresult)) <br>            throw(hresult); <br> <br>        //Ok... <br>    } <br> <br>    catch (HRESULT hr) { <br>        hresult = hr; <br>        TRACE_CATCH(_T("ChangeDirectory"), hr); <br>    } <br> <br>    catch (...) { <br>        hresult = (HRESULT) E_UNEXPECTED; <br>        TRACE_CATCH_UNKNOWN(_T("ChangeDirectory")); <br>    } <br> <br>    // Free memory <br>    if (bstrDir != NULL) <br>        ::SysFreeString(bstrDir); <br> <br>    return hresult; <br>} <br> <br> <br>/*++ <br> <br>CSCardWrapper::Detach <br> <br>    This method does a detach from the current card. <br>     <br>Arguments: <br> <br>    None. <br> <br>Return Value: <br> <br>    A HRESULT value indicating the status of the requested action. <br> <br>    Return          Meaning <br>    ======          ======= <br>    S_OK            Operation completed successfully. <br>    S_FALSE         Unknown error occurred. <br>    E_OUTOFMEMORY   There is not enough memory in this process to <br>                    satisfy the request. <br>    E_FAIL          Unspecified error. <br>    E_INVALIDARG    One or more arguments are invalid. <br>    E_UNEXPECTED    Unexpected event occurred in this function. <br>     <br>Author: <br> <br>Notes: <br>     <br>--*/ <br>HRESULT CSCardWrapper::Detach() <br>{ <br>    // Locals <br>    HRESULT     hresult = S_OK; <br> <br>    try { <br>        hresult = m_pISCardManage-&gt;Detach(); <br>        if (FAILED(hresult)) <br>            throw (hresult); <br>    } <br> <br>    catch (HRESULT hr) { <br>        hresult = hr; <br>        TRACE_CATCH(_T("Detach"), hr); <br>    } <br> <br>    catch (...) { <br>        hresult = (HRESULT) E_UNEXPECTED; <br>        TRACE_CATCH_UNKNOWN(_T("Detach")); <br>    } <br> <br>    return hresult; <br>} <br> <br> <br>/*++ <br> <br>CSCardWrapper::GetChallenge <br> <br>    This method calls gets a challenge from the ICC and returns <br>     <br>Arguments: <br> <br>    lpbyChallange - long point to a byte array large enough to hold the <br>    challenge. <br> <br>    lpLengthOfChal - length of the challenge expected. <br> <br>Return Value: <br> <br>    A HRESULT value indicating the status of the requested action. <br> <br>    Return          Meaning <br>    ======          ======= <br>    S_OK            Operation completed successfully. <br>    S_FALSE         Unknown error occurred. <br>    E_OUTOFMEMORY   There is not enough memory in this process to <br>                    satisfy the request. <br>    E_FAIL          Unspecified error. <br>    E_INVALIDARG    One or more arguments are invalid. <br>    E_UNEXPECTED    Unexpected event occurred in this function. <br>     <br>Author: <br> <br>Notes: <br>     <br>--*/ <br>HRESULT CSCardWrapper::GetChallenge( LPBYTE lpbyChallenge, LONG* lpLengthOfChal ) <br>{ <br>    // locals <br>    HRESULT         hresult = S_OK; <br>    LPBYTEBUFFER    pOutputBuffer = NULL; <br>    ULONG           ulBytesRead; <br>    LARGE_INTEGER   li; <br> <br>    try { <br>        if (!m_sequence.Attach) <br>            throw ( (HRESULT) E_FAIL ); <br>        //Get challenge..NOTE Vendor COM will create outputbuffer but we must <br>        // -&gt;Release!! <br>        hresult = m_pISCardAuth-&gt;GetChallenge(  0L, <br>                                                NULL, <br>                                                lpLengthOfChal, <br>                                                &amp;pOutputBuffer); <br>        if (FAILED(hresult)) <br>            throw hresult; <br>        // set seek position/Read challenge head <br>        LISet32 (li, BYTE_BUFFER_HEAD ); <br>        hresult = pOutputBuffer-&gt;Seek(  (LONG) li.LowPart, <br>                                        (LONG) STREAM_SEEK_SET, <br>                                        NULL); <br>        if (FAILED(hresult)) <br>            throw hresult; <br>        // Read data into return stream <br>        hresult = pOutputBuffer-&gt;Read(  (BYTE*) lpbyChallenge, <br>                                        (LONG)*lpLengthOfChal, <br>                                        (LONG*)&amp;ulBytesRead); <br>        if (FAILED(hresult)) <br>            throw hresult; <br>    } <br> <br>    catch (HRESULT hr) { <br>        hresult = hr; <br>        TRACE_CATCH(_T("GetChallenge"), hr); <br>    } <br> <br>    catch (...) { <br>        hresult = (HRESULT) E_UNEXPECTED; <br>        TRACE_CATCH_UNKNOWN(_T("GetChallenge")); <br>    } <br> <br>    // Release Bytebuffer (IStream) object <br>    if (pOutputBuffer != NULL) <br>        while (pOutputBuffer-&gt;Release() &gt; 0); <br> <br>    return hresult; <br>} <br> <br> <br>/*++ <br> <br>CSCardWrapper::LoadCOM <br> <br>    This routine loads the Vendor COM object which, in turn, loads <br>    the low level COM API's <br>     <br>Arguments: <br> <br>    none <br>     <br>Return Value: <br> <br>    A HRESULT value indicating the status of the requested action. <br> <br>    Return          Meaning <br>    ======          ======= <br>    S_OK            Operation completed successfully. <br>    S_FALSE         Unknown error occurred. <br>    E_OUTOFMEMORY   There is not enough memory in this process to <br>                    satisfy the request. <br>    E_FAIL          Unspecified error. <br>    E_INVALIDARG    One or more arguments are invalid. <br>    E_UNEXPECTED    Unexpected event occurred in this function. <br>     <br>Author: <br> <br>Notes: <br>     <br>--*/ <br> <br>HRESULT CSCardWrapper::LoadCOM() <br>{ <br>    // locals <br>    HRESULT     hresult = S_OK; <br> <br>    try { <br>        // Initialize COM <br>        hresult = CoInitialize(NULL); <br>        // SCardManage           <br>        hresult = CoCreateInstance( CLSID_SCardManage, <br>                                    NULL, <br>                                    CLSCTX_INPROC_SERVER, <br>                                    IID_ISCardManage, <br>                                    (void FAR * FAR *) &amp;m_pISCardManage); <br>        if ( FAILED(hresult) ) <br>            throw (hresult); <br> <br>        // Use the SCardManage object to create the others <br>        hresult = m_pISCardManage-&gt;CreateCardAuth(  &amp;m_pISCardAuth ); <br>        if (FAILED(hresult)) <br>            throw (hresult); <br> <br>        hresult = m_pISCardManage-&gt;CreateFileAccess( &amp;m_pISCardFileAccess ); <br>        if (FAILED(hresult)) <br>            throw (hresult); <br> <br>        hresult = m_pISCardManage-&gt;CreateCHVerification( &amp;m_pISCardVerify ); <br>        if (FAILED(hresult)) <br>            throw (hresult); <br> <br>        //ok... <br>        m_sequence.COMLoad = 1; <br>    } <br>     <br>    catch (HRESULT hr) { <br>        hresult = hr; <br>        TRACE_CATCH(_T("Initialize"),hr); <br>    } <br> <br>    catch (...) { <br>        hresult = (HRESULT) E_UNEXPECTED; <br>        TRACE_CATCH_UNKNOWN(_T("Initialize")); <br>    } <br> <br>    // <br> <br>    return hresult; <br>} <br> <br> <br>/*++ <br> <br>CSCardWrapper::Open <br> <br>    This method opens the requested file. <br> <br>Arguments: <br> <br>    wszFilename - 0 terminated, wide character string <br> <br>    phFile - pointer to an HSCARD_FILE ICC file handle <br>     <br>Return Value: <br> <br>    A HRESULT value indicating the status of the requested action. <br> <br>    Return          Meaning <br>    ======          ======= <br>    S_OK            Operation completed successfully. <br>    S_FALSE         Unknown error occurred. <br>    E_OUTOFMEMORY   There is not enough memory in this process to <br>                    satisfy the request. <br>    E_FAIL          Unspecified error. <br>    E_INVALIDARG    One or more arguments are invalid. <br>    E_UNEXPECTED    Unexpected event occurred in this function. <br>     <br>Author: <br> <br>Notes: <br>     <br> <br>--*/ <br>HRESULT CSCardWrapper::Open( WCHAR *wszFilename, HSCARD_FILE *phFile ) <br>{ <br>    // locals <br>    HRESULT     hresult = S_OK; <br>    BSTR        bstrFilename = NULL; <br> <br>    try { <br>        if ( (wszFilename == NULL) || (phFile == NULL) ) <br>            throw ( (HRESULT) E_INVALIDARG); <br>        bstrFilename = ::SysAllocString( wszFilename ); <br>        if (bstrFilename == NULL) <br>            throw ( (HRESULT) E_OUTOFMEMORY ); <br>        // Open the file <br>        hresult = m_pISCardFileAccess-&gt;Open(SC_TYPE_BY_ID, <br>                                            bstrFilename, <br>                                            phFile); <br>        if (FAILED(hresult)) <br>            throw (hresult); <br> <br>        // Ok... <br>    } <br> <br>    catch (HRESULT hr) { <br>        hresult = hr; <br>        TRACE_CATCH(_T("Open"), hr); <br>    } <br> <br>    catch (...) { <br>        hresult = (HRESULT) E_UNEXPECTED; <br>        TRACE_CATCH_UNKNOWN(_T("Open")); <br>    } <br>     <br>    // Free memory <br>    if (bstrFilename != NULL) <br>        ::SysFreeString(bstrFilename); <br> <br>    return hresult; <br>} <br> <br> <br>/*++ <br> <br>CSCardWrapper::Status <br> <br>    This method returns status of card. <br>     <br>Arguments: <br> <br>    pState - State of the card <br>    pProtocol - Protocol in use on the card <br>     <br>Return Value: <br> <br>    A HRESULT value indicating the status of the requested action. <br> <br>    Return          Meaning <br>    ======          ======= <br>    S_OK            Operation completed successfully. <br>    S_FALSE         Unknown error occurred. <br>    E_OUTOFMEMORY   There is not enough memory in this process to <br>                    satisfy the request. <br>    E_FAIL          Unspecified error. <br>    E_INVALIDARG    One or more arguments are invalid. <br>    E_UNEXPECTED    Unexpected event occurred in this function. <br>     <br>Author: <br> <br>Notes: <br>     <br>--*/ <br>HRESULT CSCardWrapper::Status( SCARD_STATES *pState, SCARD_PROTOCOLS *pProtocol ) <br>{ <br>    //locals <br>    HRESULT     hresult = S_OK; <br> <br>    try { <br>        if (!m_sequence.Attach) <br>            throw ( (HRESULT) E_FAIL ); <br>        if ( (pState == NULL) || (pProtocol == NULL) ) <br>            throw ( (HRESULT) E_INVALIDARG ); <br>        // Get Status <br>        hresult = m_pISCardManage-&gt;Status(pState, pProtocol); <br> <br>        //Ok... <br>    } <br> <br>    catch (HRESULT hr) { <br>        hresult = hr; <br>        TRACE_CATCH(_T("Status"), hr); <br>    } <br> <br>    catch (...) { <br>        hresult = (HRESULT) E_UNEXPECTED; <br>        TRACE_CATCH_UNKNOWN(_T("Status")); <br>    } <br> <br>    return hresult; <br>} <br> <br> <br>/*++ <br> <br>CSCardWrapper::UnloadCOM <br> <br>    This routine unloads the Vendor COM object which, in turn, unloads <br>    the low level COM API's <br>     <br>Arguments: <br> <br>    none <br>     <br>Return Value: <br> <br>    A HRESULT value indicating the status of the requested action. <br> <br>    Return          Meaning <br>    ======          ======= <br>    S_OK            Operation completed successfully. <br>    S_FALSE         Unknown error occurred. <br>    E_OUTOFMEMORY   There is not enough memory in this process to <br>                    satisfy the request. <br>    E_FAIL          Unspecified error. <br>    E_INVALIDARG    One or more arguments are invalid. <br>    E_UNEXPECTED    Unexpected event occurred in this function. <br>     <br>Author: <br> <br>Notes: <br>     <br>--*/ <br>void CSCardWrapper::UnloadCOM() <br>{ <br>    //locals <br> <br>    try { <br>        // UninitializeOLE if error has not occured <br>        if (m_sequence.COMLoad) { <br>            if (m_pISCardFileAccess != NULL) <br>                while (m_pISCardFileAccess-&gt;Release()&gt;0);; <br>            if (m_pISCardVerify != NULL) <br>                while (m_pISCardVerify-&gt;Release()&gt;0); <br>            if (m_pISCardAuth != NULL) <br>                while (m_pISCardAuth-&gt;Release()&gt;0); <br>            if (m_pISCardManage != NULL) <br>                while (m_pISCardManage-&gt;Release()&gt;0); <br>            CoUninitialize(); <br>        };//if <br>    } <br> <br>    catch(...) { <br>        TRACE_CATCH_UNKNOWN(_T("UnloadCOM")); <br>    } <br>} <br> <br> <br>/*++ <br> <br>CSCardWrapper::VerifyPIN <br> <br>    This method does a PPIN verification with the card. <br>     <br>Arguments: <br> <br>    wszPIN = a null terminated wide character string <br>    containing the PIN <br>     <br>Return Value: <br> <br>    A HRESULT value indicating the status of the requested action. <br> <br>    Return          Meaning <br>    ======          ======= <br>    S_OK            Operation completed successfully. <br>    S_FALSE         Unknown error occurred. <br>    E_OUTOFMEMORY   There is not enough memory in this process to <br>                    satisfy the request. <br>    E_FAIL          Unspecified error. <br>    E_INVALIDARG    One or more arguments are invalid. <br>    E_UNEXPECTED    Unexpected event occurred in this function. <br>     <br>Author: <br> <br>Notes: <br>     <br>--*/ <br>HRESULT CSCardWrapper::VerifyPIN( WCHAR *wszPIN ) <br>{ <br>    //locals <br>    HRESULT     hresult = S_OK; <br>    BSTR        bstrPIN = NULL; <br> <br>    try { <br>        // Are Attached? <br>        if (!m_sequence.Attach) <br>            throw ( (HRESULT) E_FAIL ); <br>        if (wszPIN == NULL) <br>            throw ( (HRESULT) E_INVALIDARG ); <br> <br>        // Todo: convert to byte buffer and pass to vendor wrapper. <br> <br>        //Ok... <br>    } <br> <br>    catch (HRESULT hr) { <br>        hresult = hr; <br>        TRACE_CATCH(_T("VerifyPIN"), hr); <br>    } <br> <br>    catch (...) { <br>        hresult = (HRESULT) E_UNEXPECTED; <br>        TRACE_CATCH_UNKNOWN(_T("VerifyPIN")); <br>    } <br> <br>    // Free memory <br>    if (bstrPIN != NULL) <br>        ::SysFreeString(bstrPIN); <br> <br>    return hresult; <br>} <br> <br> <br>/*++ <br> <br>CSCardWrapper::Write <br> <br>    Write data to an open EF. <br>     <br>Arguments: <br> <br>    hFile - handle to file. <br>    cbBytes - number of bytes to write <br>    pbyData - pointer to data to write. <br>     <br>Return Value: <br> <br>    A HRESULT value indicating the status of the requested action. <br> <br>    Return          Meaning <br>    ======          ======= <br>    S_OK            Operation completed successfully. <br>    S_FALSE         Unknown error occurred. <br>    E_OUTOFMEMORY   There is not enough memory in this process to <br>                    satisfy the request. <br>    E_FAIL          Unspecified error. <br>    E_INVALIDARG    One or more arguments are invalid. <br>    E_UNEXPECTED    Unexpected event occurred in this function. <br>     <br>Author: <br> <br>Notes: <br>     <br>--*/ <br> <br>HRESULT CSCardWrapper::Write(   HSCARD_FILE hFile, <br>                                BYTE byRecordID, <br>                                LONG cbBytes, <br>                                LPBYTE pbyData) <br>{ <br>    //locals <br>    HRESULT     hresult = S_OK; <br>    LPBYTEBUFFER pBuffer = NULL; <br>    LARGE_INTEGER li; <br>    ULONG       ulBytesWritten = 0; <br> <br>    try { <br>        // Are Attached? <br>        if (!m_sequence.Attach) <br>            throw ( (HRESULT) E_FAIL ); <br>        if (pbyData == NULL) <br>            throw ( (HRESULT) E_INVALIDARG ); <br>        if (cbBytes &lt;0) <br>            throw ( (HRESULT) E_INVALIDARG ); <br>        // Create ByteBuffer <br>        hresult = CreateByteBuffer( (DWORD) cbBytes, <br>                                    &amp;pBuffer); <br>        if (FAILED(hresult)) <br>            throw (hresult); <br>        // set seek position <br>        LISet32 (li, BYTE_BUFFER_HEAD ); <br>        hresult = pBuffer-&gt;Seek((LONG) li.LowPart, <br>                                (LONG) STREAM_SEEK_SET, <br>                                NULL); <br>        if (FAILED(hresult)) <br>            throw hresult; <br>        // Write data into return stream <br>        hresult = pBuffer-&gt;Write(   (BYTE*) pbyData, <br>                                    (LONG) cbBytes, <br>                                    (LONG*) &amp;ulBytesWritten); <br>        if (FAILED(hresult)) <br>            throw hresult; <br> <br>        // Do the write... <br>        hresult = m_pISCardFileAccess-&gt;Write(   hFile, <br>ulBytesWritten, <br>                                                pBuffer, <br>                                                SC_FL_REPLACE); <br>        if (FAILED(hresult)) <br>            throw (hresult); <br> <br>        //Ok... <br>    } <br> <br>    catch (HRESULT hr) { <br>        hresult = hr; <br>        TRACE_CATCH(_T("Write"), hr); <br>    } <br> <br>    catch (...) { <br>        hresult = (HRESULT) E_UNEXPECTED; <br>        TRACE_CATCH_UNKNOWN(_T("Write")); <br>    } <br> <br>    return hresult; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
