<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SCDTEST.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6099"></a>SCDTEST.CPP</h2>
<pre><code>/*++ <br> <br>Copyright (c) 1996-1997  Microsoft Corporation <br> <br>Module Name: <br> <br>scdtest <br> <br>Abstract: <br> <br>Simple brute force test SSP application. Usage: "test &lt;# of iterations&gt;". <br>Contains good examples for calling low-level SSPs. <br> <br>Environment: <br> <br>    Win32, C++ w/Exceptions, COM/OLE <br> <br>Notes: <br> <br> <br>--*/ <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// <br>// Includes <br>// <br> <br>#include &lt;stdio.h&gt; <br>#include &lt;windows.h&gt; <br>#include &lt;tchar.h&gt; <br>#include &lt;crtdbg.h&gt; <br>#include &lt;initguid.h&gt; <br> <br>//#include "sspmacro.h" <br>#include "scarddat.h" <br>#include "scardmgr.h" <br>#include "scardsrv.h" <br>#define IID_DEFINED <br>#include "scarddat_i.c" <br>#include "scardmgr_i.c" <br>#include "scardsrv_i.c" <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// <br>// Globals <br>// <br>LPSCARD g_pISCard = NULL; <br>LPSCARDDATABASE g_pISCardDatabase = NULL; <br>LPSCARDLOCATE g_pISCardLocate = NULL; <br>LPSCARDISO7816 g_pISCardISO7816 = NULL; <br>LPSCARDTYPECONV g_pISCardTypeConv = NULL; <br>LPSCARDCMD g_pISCardCmd = NULL; <br>LPBYTEBUFFER g_pIByteBuffer = NULL; <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// <br>// Macros <br>// <br> <br>#ifndef SafeCast <br>#define SafeCast(cast,pt)((cast)(pt)) <br>#endif <br> <br>#ifndef ASSERT <br>#define ASSERT_ASSERTE <br>#endif <br> <br>#ifndef IN <br>#define IN <br>#endif <br> <br>//////////////////////////////////////////////////////////////////////////// <br>// <br>// Defines <br>// <br> <br>#define BYTE_BUFFER_HEAD(0) <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// <br>// Functions <br>// <br> <br> <br>/*++ <br> <br>ConTrace: <br> <br>    Simply Tracing function to dump text to standard output. <br> <br>Arguments: <br> <br>lpszFormat - String to dump to standard output <br> <br>--*/ <br> <br>void _cdecl  <br>ConTrace( <br>IN LPCTSTR lpszFormat, ...) <br>{ <br>// <br>// Helper to do print traces... <br>// <br> <br>va_list args; <br>va_start(args, lpszFormat); <br> <br>int nBuf; <br>TCHAR szBuffer[512]; <br>ZeroMemory(szBuffer, SafeCast(DWORD,(512*sizeof(TCHAR)))); <br> <br>nBuf = _vstprintf(szBuffer, lpszFormat, args); <br>ASSERT(nBuf &lt; sizeof(szBuffer)); <br> <br>_tprintf(szBuffer); <br>    OutputDebugString(szBuffer); <br>va_end(args); <br>} <br> <br> <br>/*++ <br> <br>DumpAPDU: <br> <br>    Dumps the ReplyADPU of the current CardCmd object. <br> <br>Arguments: <br> <br>None. <br> <br>--*/ <br>void _cdecl <br>DumpAPDU( void ) <br>{ <br>#ifdef _DEBUG <br>// Locals <br>HRESULThresult = S_OK; <br>ULONGulBytesRead = 0; <br>BYTEpbyIStreamData[10]; <br>LPBYTEBUFFER pBuffer = NULL; <br>TCHARpCharBuffer[10]; <br>LARGE_INTEGERli; <br>STATSTRUCTstatstruct; <br> <br>// Get the Command APDU <br>hresult = g_pISCardCmd-&gt;get_Apdu(&amp;pBuffer); <br>if (FAILED(hresult)) { <br>ConTrace(_T("Failed to get command apdu.")); <br>return; <br>};// if <br> <br>// set seek position <br>LISet32 (li, BYTE_BUFFER_HEAD ); <br>hresult = pBuffer-&gt;Seek((LONG) li.LowPart, <br>(LONG) STREAM_SEEK_SET, <br>NULL); <br>if (FAILED(hresult)){ <br>ConTrace(_T("Unable to seek in IStream.")); <br>return; <br>}; <br>// Seek <br>hresult = pBuffer-&gt;Stat(&amp;statstruct, (LONG) 0); <br>if (FAILED(hresult)) <br>throw (hresult); <br> <br>// Set buffer size <br>hresult = pBuffer-&gt;SetSize(statstruct.cbSize); <br>if (FAILED(hresult)) { <br>ConTrace(_T("Unable to set IStream size.")); <br>return; <br>}; <br> <br>// Read Data <br>hresult = pBuffer-&gt;Read((BYTE*) pbyIStreamData, <br>(LONG) statstruct.cbSize,  // APDU header <br>(LONG*) &amp;ulBytesRead); <br>if (FAILED(hresult)) { <br>ConTrace(_T("Unable to read IStream.")); <br>return; <br>}; <br> <br> <br>// "Quick" not best way to do this... <br>switch (statstruct.cbSize) { <br>case 5: <br>sprintf(pCharBuffer, "%d %d %d %d %d\n", <br>(int) pbyIStreamData[0], (int) pbyIStreamData[1],  <br>(int) pbyIStreamData[2], (int) pbyIStreamData[3], <br>(int) pbyIStreamData[4]); <br>break; <br>case 4: <br>sprintf(pCharBuffer, "%d %d %d %d\n", <br>(int) pbyIStreamData[0], (int) pbyIStreamData[1],  <br>(int) pbyIStreamData[2], (int) pbyIStreamData[3]); <br>break; <br>default: <br>// Sending data with command...Just display APDU. <br>sprintf(pCharBuffer, "%d %d %d %d %d\n", <br>(int) pbyIStreamData[0], (int) pbyIStreamData[1],  <br>(int) pbyIStreamData[2], (int) pbyIStreamData[3], <br>(int) pbyIStreamData[4]); <br>break; <br>break; <br> }; //switch <br> <br>ConTrace( (LPCTSTR) pCharBuffer ); <br> <br>// Eliminate the temp buffer(s)...Clean up <br>if (pBuffer != NULL) <br>while (pBuffer-&gt;Release()&gt;0); <br>#endif // _DEBUG <br>} <br> <br> <br>/*++ <br> <br>CallServer: <br> <br>    Routine creates an instance of each low-level com object. <br> <br>Arguments: <br> <br>lpszFormat - String to dump to standard output <br> <br>--*/ <br>void _cdecl  <br>CallServer( <br>void) <br>{ <br>// locals <br>HRESULThresult; <br> <br>ConTrace(_T("\nSTARTING Object Creation\n=============================\n")); <br>ConTrace(_T("Calling CoCreateInstance()...\n")); <br> <br>hresult = CoCreateInstance(CLSID_CSCard, <br>NULL, <br>CLSCTX_ALL, <br>IID_ISCard, <br>(LPVOID*) &amp;g_pISCard); <br>if (FAILED(hresult)) { <br>ConTrace(_T("Failed to create CSCard object\n")); <br>return; <br>} <br>ConTrace(_T("Object CSCard created\n")); <br> <br>hresult = CoCreateInstance(CLSID_CSCardTypeConv, <br>NULL, <br>CLSCTX_ALL, <br>IID_ISCardTypeConv, <br>(LPVOID*) &amp;g_pISCardTypeConv); <br>if (FAILED(hresult)) { <br>ConTrace(_T("Failed to create CSCardTypeConv object\n")); <br>return; <br>} <br>ConTrace(_T("Object CSCardTypeConv created\n")); <br> <br>hresult = CoCreateInstance(CLSID_CSCardISO7816, <br>NULL, <br>CLSCTX_ALL, <br>IID_ISCardISO7816, <br>(LPVOID*) &amp;g_pISCardISO7816); <br>if (FAILED(hresult)) { <br>ConTrace(_T("Failed to create CSCardISO7816 object\n")); <br>return; <br>} <br>ConTrace(_T("Object CSCardISO7816 created\n")); <br> <br>hresult = CoCreateInstance(CLSID_CSCardCmd, <br>NULL, <br>CLSCTX_ALL, <br>IID_ISCardCmd, <br>(LPVOID*) &amp;g_pISCardCmd); <br>if (FAILED(hresult)) { <br>ConTrace(_T("Failed to create CSCardCmd object\n")); <br>return; <br>} <br>ConTrace(_T("Object CSCardCmd created\n")); <br> <br>hresult = CoCreateInstance(CLSID_CSCardLocate, <br>NULL, <br>CLSCTX_ALL, <br>IID_ISCardLocate, <br>(LPVOID*) &amp;g_pISCardLocate); <br>if (FAILED(hresult)) { <br>ConTrace(_T("Failed to create CSCardLocate object\n")); <br>return; <br>} <br>ConTrace(_T("Object CSCardLocate created\n")); <br> <br>hresult = CoCreateInstance(CLSID_CSCardDatabase, <br>NULL, <br>CLSCTX_ALL, <br>IID_ISCardDatabase, <br>(LPVOID*) &amp;g_pISCardDatabase); <br>if (FAILED(hresult)) { <br>ConTrace(_T("Failed to create CSCardDatabase object\n")); <br>return; <br>} <br>ConTrace(_T("Object CSCardDatabase created\n")); <br> <br>hresult = CoCreateInstance(CLSID_ByteBuffer, <br>NULL, <br>CLSCTX_ALL, <br>IID_IByteBuffer, <br>(LPVOID*) &amp;g_pIByteBuffer); <br>if (FAILED(hresult)) { <br>ConTrace(_T("Failed to create CSCardDatabase object\n")); <br>return; <br>} <br>ConTrace(_T("Object CByteBuffer created\n")); <br> <br>ConTrace(_T("\nDONE!!! with Object Creation\n=============================\n")); <br>} <br> <br> <br>/*++ <br> <br>CallISOFunctions: <br> <br>    Routine calls all the low level ISO build commands. <br> <br>Arguments: <br> <br>lpszFormat - String to dump to standard output <br> <br>Notes: <br> <br>1. This function does not actually send the command to a smartcard. It only <br>builds the apdu. In order to send the command to a card, the card/reader must be <br>attached: <br>hresult = g_pISCard-&gt;AttachByReader(bstrReaderName, <br>EXCLUSIVE, <br>T0); <br>if (FAILED(hresult)){ <br>ConTrace(_T("Failed on AttachByReader\n")); <br>return; <br>} <br>Transactions must be performed: <br>hresult = g_pISCard-&gt;Transaction(&amp;g_pISCardCmd); <br>And the card finally released. <br> <br>--*/ <br>void _cdecl  <br>CallISOFunctions( longlLoops ) <br>{ <br>// Locals <br>HRESULThresult = S_OK; <br>LPBYTEBUFFERpBuffer1 = NULL, <br>pBuffer2 = NULL; <br>TCHARszBuffer[200]; <br> <br>ConTrace(_T("\nSTARTING Call Testing\n=============================\n")); <br>ConTrace(_T("Calling ISO Functions...\n")); <br> <br>// Create a couple of byte buffers for testing <br>hresult = g_pISCardTypeConv-&gt;CreateByteBuffer((ULONG) 1, <br>&amp;pBuffer1); <br>if (FAILED(hresult)) { <br>ConTrace(_T("Failed to create IByteBuffer\n")); <br>return; <br>};// if <br>hresult = g_pISCardTypeConv-&gt;CreateByteBuffer((ULONG) 1, <br>&amp;pBuffer2); <br>if (FAILED(hresult)) { <br>ConTrace(_T("Failed to create IByteBuffer\n")); <br>return; <br>};// if <br> <br>// Loop through the build/execute ISO commands <br>while (lLoops != 0) { <br>sprintf(szBuffer,"Iteration Number: %d\n", (int) lLoops); <br>ConTrace( (LPCTSTR) szBuffer ); <br>// Appendrecord <br>ConTrace(_T("Build/Execute: AppendRecord\n")); <br>hresult = g_pISCardISO7816-&gt;AppendRecord(0, <br>pBuffer1, <br>&amp;g_pISCardCmd); <br>if (FAILED(hresult)){ <br>ConTrace(_T("Failed on AppendRecord\n")); <br>//return; <br>} <br>DumpAPDU(); <br>ConTrace(_T("Build/Execute: AppendRecord successful\n")); <br> <br> <br>// EraseBinary <br>ConTrace(_T("Build/Execute: EraseBinary\n")); <br>hresult = g_pISCardISO7816-&gt;EraseBinary(0, <br>0, <br>pBuffer1, <br>&amp;g_pISCardCmd); <br>if (FAILED(hresult)){ <br>ConTrace(_T("Failed on EraseBinary\n")); <br>//return; <br>} <br>DumpAPDU(); <br>ConTrace(_T("Build/Execute: EraseBinary successful\n")); <br> <br> <br>// ExternalAuthenticate <br>ConTrace(_T("Build/Execute: ExternalAuthenticate\n")); <br>hresult = g_pISCardISO7816-&gt;ExternalAuthenticate(0, <br>0, <br>pBuffer2, <br>&amp;g_pISCardCmd); <br>if (FAILED(hresult)){ <br>ConTrace(_T("Failed on ExternalAuthenticate\n")); <br>//return; <br>} <br>DumpAPDU(); <br>ConTrace(_T("Build/Execute: ExternalAuthenticate successful\n")); <br> <br> <br>// GetChallenge <br>ConTrace(_T("Build/Execute: GetChallenge\n")); <br>hresult = g_pISCardISO7816-&gt;GetChallenge(10, <br>&amp;g_pISCardCmd); <br>if (FAILED(hresult)){ <br>ConTrace(_T("Failed on GetChallenge\n")); <br>//return; <br>} <br>DumpAPDU(); <br>ConTrace(_T("Build/Execute: GetChallenge successful\n")); <br> <br> <br>// GetData <br>ConTrace(_T("Build/Execute: GetData\n")); <br>hresult = g_pISCardISO7816-&gt;GetData(0, <br>0, <br>10, <br>&amp;g_pISCardCmd); <br>if (FAILED(hresult)){ <br>ConTrace(_T("Failed on GetData\n")); <br>//return; <br>} <br>DumpAPDU(); <br>ConTrace(_T("Build/Execute: GetData successful\n")); <br> <br> <br>// GetResponse <br>ConTrace(_T("Build/Execute: GetResponse\n")); <br>hresult = g_pISCardISO7816-&gt;GetResponse(0, <br>0, <br>0, <br>&amp;g_pISCardCmd); <br>if (FAILED(hresult)){ <br>ConTrace(_T("Failed on GetResponse\n")); <br>//return; <br>} <br>DumpAPDU(); <br>ConTrace(_T("Build/Execute: GetResponse successful\n")); <br> <br> <br>// InternalAuthenticate <br>ConTrace(_T("Build/Execute: InternalAuthenticate\n")); <br>hresult = g_pISCardISO7816-&gt;InternalAuthenticate(0, <br>0, <br>pBuffer1, <br>10, <br>&amp;g_pISCardCmd); <br>if (FAILED(hresult)){ <br>ConTrace(_T("Failed on InternalAuthenticate\n")); <br>//return; <br>} <br>DumpAPDU(); <br>ConTrace(_T("Build/Execute: InternalAuthenticate successful\n")); <br> <br> <br>// ManageChannel <br>ConTrace(_T("Build/Execute: ManageChannel\n")); <br>hresult = g_pISCardISO7816-&gt;ManageChannel(0x00, <br>0x80, <br>&amp;g_pISCardCmd); <br>if (FAILED(hresult)){ <br>ConTrace(_T("Failed on ManageChannel\n")); <br>//return; <br>} <br>DumpAPDU(); <br>ConTrace(_T("Build/Execute: ManageChannel successful\n")); <br> <br> <br>// PutData <br>ConTrace(_T("Build/Execute: PutData\n")); <br>hresult = g_pISCardISO7816-&gt;PutData(0, <br>0, <br>pBuffer1, <br>&amp;g_pISCardCmd); <br>if (FAILED(hresult)){ <br>ConTrace(_T("Failed on PutData\n")); <br>//return; <br>} <br>DumpAPDU(); <br>ConTrace(_T("Build/Execute: PutData successful\n")); <br> <br> <br>// ReadBinary <br>ConTrace(_T("Build/Execute: ReadBinary\n")); <br>hresult = g_pISCardISO7816-&gt;ReadBinary(0, <br>0, <br>20, <br>&amp;g_pISCardCmd); <br>if (FAILED(hresult)){ <br>ConTrace(_T("Failed on ReadBinary\n")); <br>//return; <br>} <br>DumpAPDU(); <br>ConTrace(_T("Build/Execute: ReadBinary successful\n")); <br> <br> <br>// ReadRecord <br>ConTrace(_T("Build/Execute: ReadRecord\n")); <br>hresult = g_pISCardISO7816-&gt;ReadRecord(10, <br>5, <br>100, <br>&amp;g_pISCardCmd); <br>if (FAILED(hresult)){ <br>ConTrace(_T("Failed on ReadRecord\n")); <br>//return; <br>} <br>DumpAPDU(); <br>ConTrace(_T("Build/Execute: ReadRecord successful\n")); <br> <br> <br>// SelectFile <br>ConTrace(_T("Build/Execute: SelectFile\n")); <br>hresult = g_pISCardISO7816-&gt;SelectFile(0, <br>0, <br>pBuffer1, <br>20, <br>&amp;g_pISCardCmd); <br>if (FAILED(hresult)){ <br>ConTrace(_T("Failed on SelectFile\n")); <br>//return; <br>} <br>DumpAPDU(); <br>ConTrace(_T("Build/Execute: SelectFile successful\n")); <br> <br> <br>// SetDefaultClassID <br>ConTrace(_T("Build/Execute: SetDefaultClassID\n")); <br>hresult = g_pISCardISO7816-&gt;SetDefaultClassId(20); <br>if (FAILED(hresult)){ <br>ConTrace(_T("Failed on SetDefaultClassID\n")); <br>//return; <br>} <br>DumpAPDU(); <br>ConTrace(_T("Build/Execute: SetDefaultClassID successful\n")); <br> <br> <br>// UpdateBinary <br>ConTrace(_T("Build/Execute: UpdateBinary\n")); <br>hresult = g_pISCardISO7816-&gt;UpdateBinary(0, <br>0, <br>pBuffer1, <br>&amp;g_pISCardCmd); <br>if (FAILED(hresult)){ <br>ConTrace(_T("Failed on UpdateBinary\n")); <br>//return; <br>} <br>DumpAPDU(); <br>ConTrace(_T("Build/Execute: UpdateBinary successful\n")); <br> <br> <br>// UpdateRecord <br>ConTrace(_T("Build/Execute: UpdateRecord\n")); <br>hresult = g_pISCardISO7816-&gt;UpdateRecord(10, <br>1, <br>pBuffer2, <br>&amp;g_pISCardCmd); <br>if (FAILED(hresult)){ <br>ConTrace(_T("Failed on UpdateRecord\n")); <br>//return; <br>} <br>DumpAPDU(); <br>ConTrace(_T("Build/Execute: UpdateRecord successful\n")); <br> <br> <br>// Verify <br>ConTrace(_T("Build/Execute: Verify\n")); <br>hresult = g_pISCardISO7816-&gt;Verify(1, <br>pBuffer2, <br>&amp;g_pISCardCmd); <br>if (FAILED(hresult)){ <br>ConTrace(_T("Failed on Verify\n")); <br>//return; <br>} <br>DumpAPDU(); <br>ConTrace(_T("Build/Execute: Verify successful\n")); <br> <br> <br>// WriteBinary <br>ConTrace(_T("Build/Execute: WriteBinary\n")); <br>hresult = g_pISCardISO7816-&gt;WriteBinary(0, <br>0, <br>pBuffer1, <br>&amp;g_pISCardCmd); <br>if (FAILED(hresult)){ <br>ConTrace(_T("Failed on WriteBinary\n")); <br>//return; <br>} <br>DumpAPDU(); <br>ConTrace(_T("Build/Execute: WriteBinary successful\n")); <br> <br> <br>// WriteRecord <br>ConTrace(_T("Build/Execute: WriteRecord\n")); <br>hresult = g_pISCardISO7816-&gt;WriteRecord(1, <br>1, <br>pBuffer1, <br>&amp;g_pISCardCmd); <br>if (FAILED(hresult)){ <br>ConTrace(_T("Failed on WriteRecord\n")); <br>//return; <br>} <br>DumpAPDU(); <br>ConTrace(_T("Build/Execute: WriteRecord successful\n")); <br> <br>// Decrement count <br>--lLoops; <br>};//while <br>// Clean up <br>if (pBuffer1 != NULL) <br>while (pBuffer1-&gt;Release()); <br>if (pBuffer2 != NULL) <br>while (pBuffer2-&gt;Release()); <br> <br>ConTrace(_T("\nDONE!!! with Call Testing\n=============================\n")); <br>} <br> <br> <br>/*++ <br> <br>CallLocateFunctions: <br> <br>    Calls the ISCardLocate functions (i.e. common dialog). <br> <br>Arguments: <br> <br>lpszFormat - String to dump to standard output <br> <br>--*/ <br>void _cdecl  <br>CallLocateFunctions( long lLoops) <br>{ <br>// Locals <br>HRESULThresult = S_OK; <br>LPSAFEARRAY rgCardName = NULL; <br>LPSAFEARRAY rgGroupName = NULL; <br>SCARDINFOscardinfo; <br>LPSCARDINFO pscardinfo = &amp;scardinfo; <br>SAFEARRAYBOUND Bounds[] = {2,0}, <br>   Bounds2[] = {1,0}; <br>longlIndex[] = {0};// Access only 1 element <br>BSTRbstrCardName = ::SysAllocString(L"Cryptoflex"), <br>bstrCardName2 = ::SysAllocString(L"Sicrypt"), <br>bstrGroupName = ::SysAllocString(L"SCard$DefaultReaders"); <br> <br>ConTrace(_T("\nSTARTING Call Testing\n=============================\n")); <br>ConTrace(_T("Calling Locate Functions...\n")); <br> <br>// Clear memory <br>::ZeroMemory((LPVOID) pscardinfo, (DWORD) sizeof(SCARDINFO) ); <br> <br>// Create a SAFEARRAY of type BSTR (contains  <br>rgCardName = ::SafeArrayCreate(VT_BSTR,// BSTRs <br>(UINT) 1,// 1 dimensional array <br>Bounds);// That dimension contains 2 element <br> <br>if (rgCardName == NULL) { <br>ConTrace(_T("\nUnable to create SAFEARRAY.")); <br>return; <br>} <br>// Create a SAFEARRAY of type BSTR (contains  <br>rgGroupName = ::SafeArrayCreate(VT_BSTR,// BSTRs <br>(UINT) 1,// 1 dimensional array <br>Bounds2);// That dimension contains 1 element <br> <br>if (rgGroupName == NULL) { <br>ConTrace(_T("\nUnable to create SAFEARRAY.")); <br>return; <br>} <br> <br>// Add an element... <br>// lIndex is does not really have to be declared as an array since <br>// both SAFEARRAYs are 1 dimensional. An array is, however, required <br>// for multi dimensional arrays. <br>hresult = SafeArrayPutElement(rgCardName, lIndex, (LPVOID) bstrCardName); <br>if (FAILED(hresult)) { <br>ConTrace(_T("\nSafearray put element failed.")); <br>return; <br>} <br>lIndex[0]= 1; <br>hresult = SafeArrayPutElement(rgCardName, lIndex, (LPVOID) bstrCardName2); <br>if (FAILED(hresult)) { <br>ConTrace(_T("\nSafearray put element failed.")); <br>return; <br>} <br>lIndex[0] = 0; <br>hresult = SafeArrayPutElement(rgGroupName, lIndex, (LPVOID) bstrGroupName); <br>if (FAILED(hresult)) { <br>ConTrace(_T("\nSafearray put element failed.")); <br>return; <br>} <br> <br>// Setup for search <br>hresult = g_pISCardLocate-&gt;ConfigureCardNameSearch(rgCardName, <br>rgGroupName, <br>NULL, <br>0); <br>if (FAILED(hresult)) { <br>ConTrace(_T("\nConfigureCardSearch failed.")); <br>return; <br>} <br> <br>// Setup for common dialog..This actually displays the dialog for user input <br>//hresult = g_pISCardLocate-&gt;FindCard(bstrCardName, <br>//EXCLUSIVE, <br>//T0, <br>//&amp;pscardinfo); <br>//if (FAILED(hresult)) { <br>//ConTrace(_T("\nFindCard failed.")); <br>//return; <br>//} <br> <br>ConTrace(_T("\nDONE!!! with Call Testing\n=============================\n")); <br> <br>// Cleanup <br>if (rgCardName != NULL) <br>::SafeArrayDestroy(rgCardName); <br>if (rgGroupName != NULL) <br>::SafeArrayDestroy(rgGroupName); <br>if (bstrGroupName != NULL) <br>::SysFreeString(bstrGroupName); <br>if (bstrCardName != NULL) <br>::SysFreeString(bstrCardName); <br>if (bstrCardName != NULL) <br>::SysFreeString(bstrCardName2); <br>} <br> <br> <br>/*++ <br> <br>CallDbFunctions: <br> <br>    Calls the ISCardDatabase functions. <br> <br>Arguments: <br> <br>lpszFormat - String to dump to standard output <br> <br>--*/ <br>void _cdecl  <br>CallDbFunctions( long lLoops) <br>{ <br>// Locals <br>GUIDguidProviderID; <br>LPGUIDlpguidProviderID = &amp;guidProviderID; <br>HRESULThresult = S_OK; <br>BSTRbstrCardName = ::SysAllocString(L"Cryptoflex"); <br>LPSAFEARRAYlpSafeArray = NULL; <br>LPBYTEBUFFER pBuffer = NULL; <br>LARGE_INTEGERli; <br>BYTEbAtr[] = {0x3b,0x00}; <br>ULONGulBytesWritten = 0; <br> <br>// GetProviderCardId <br>hresult = g_pISCardDatabase-&gt;GetProviderCardId(bstrCardName, <br>&amp;lpguidProviderID); <br>if (FAILED(hresult)) { <br>ConTrace(_T("\nGetProviderCardId failed.")); <br>} <br> <br>//ListCardInterfaces...NOT SUPPORTED IN THIS RELEASE!! <br> <br>// ListCards <br>// Create a bytebuffer for use in call <br>hresult = g_pISCardTypeConv-&gt;CreateByteBuffer((ULONG) 2, <br>&amp;pBuffer); <br>if (FAILED(hresult)) { <br>ConTrace(_T("Failed to create IByteBuffer\n")); <br>};// if <br>// set seek position <br>LISet32 (li, BYTE_BUFFER_HEAD ); <br>hresult = pBuffer-&gt;Seek((LONG) li.LowPart, <br>(LONG) STREAM_SEEK_SET, <br>NULL); <br>if (FAILED(hresult)){ <br>ConTrace(_T("Unable to seek in IStream.")); <br>}; <br>// Fill in an ATR to search <br>hresult = pBuffer-&gt;Write((BYTE*) bAtr, <br>(LONG) 2, <br>(LONG*) &amp;ulBytesWritten); <br>if (FAILED(hresult)) { <br>ConTrace(_T("Unable to write to IStream.")); <br>}; <br>// Call it <br>hresult = g_pISCardDatabase-&gt;ListCards(pBuffer, <br>NULL, <br>(long) 0, <br>&amp;lpSafeArray); <br>if (FAILED(hresult)) { <br>ConTrace(_T("\nListCards failed.")); <br>} <br>if (lpSafeArray != NULL) { <br>::SafeArrayDestroy(lpSafeArray); <br>lpSafeArray = NULL; <br>} <br> <br>// ListReaderGroups <br>hresult = g_pISCardDatabase-&gt;ListReaderGroups((long) 0, <br>&amp;lpSafeArray); <br>if (FAILED(hresult)) { <br>ConTrace(_T("\nListReaderGroups failed.")); <br>} <br>if (lpSafeArray != NULL) { <br>::SafeArrayDestroy(lpSafeArray); <br>lpSafeArray = NULL; <br>} <br> <br>// ListReaders <br>hresult = g_pISCardDatabase-&gt;ListReaders((long) 0, <br>&amp;lpSafeArray); <br>if (FAILED(hresult)) { <br>ConTrace(_T("\nListReaders failed.")); <br>} <br>if (lpSafeArray != NULL) { <br>::SafeArrayDestroy(lpSafeArray); <br>lpSafeArray = NULL; <br>} <br>} <br> <br> <br>/*++ <br> <br>Cleanup: <br> <br>    Release all the interfaces/memory. <br> <br>Arguments: <br> <br>lpszFormat - String to dump to standard output <br> <br>--*/ <br>void _cdecl  <br>CleanUp( <br>void) <br>{ <br>while (g_pISCard-&gt;Release()&gt;0); <br>while (g_pISCardISO7816-&gt;Release()&gt;0); <br>while (g_pISCardTypeConv-&gt;Release()&gt;0); <br>while (g_pISCardCmd-&gt;Release()&gt;0); <br>// If required... <br>while (g_pISCardDatabase-&gt;Release()&gt;0); <br>while (g_pISCardLocate-&gt;Release()&gt;0); <br>while (g_pIByteBuffer-&gt;Release()&gt;0); <br>} <br> <br> <br>/*++ <br> <br>main: <br> <br>    Entry point. <br> <br>Arguments: <br> <br>lpszFormat - String to dump to standard output <br> <br>--*/ <br>int  <br>main(  <br>IN int argc,  <br>IN char *argv[ ]) <br>{ <br>int nRet = 0; <br>long lIterations; <br> <br>try <br>{ <br>// Check command line arguments <br>if (argc==1) <br>lIterations = 1; <br>else if (argc==2)  <br>lIterations = atol(argv[1]); <br>else { <br>printf ("\nCorrect Usage: test [#iterations]\n"); <br>throw; <br>} <br> <br>if (FAILED(CoInitialize(NULL))) <br>throw; <br> <br>// Create Objects... <br>CallServer(); <br>// Call Various Functions <br>CallISOFunctions(lIterations); <br>//CallLocateFunctions(lIterations); <br>//CallDbFunctions(lIterations); <br>// Clean Up... <br>CleanUp(); <br> <br>CoUninitialize(); <br> <br>#ifdef _DEBUG <br>_CrtDumpMemoryLeaks(); <br>#endif <br> <br> <br>nRet = 0; <br>} <br> <br>catch (...) <br>{ <br>printf(_T("Unhandled exception!!!\n")); <br>} <br> <br>return (nRet); <br>} <br> <br>///////////////////////////////////////////////////////////////////////////// <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
