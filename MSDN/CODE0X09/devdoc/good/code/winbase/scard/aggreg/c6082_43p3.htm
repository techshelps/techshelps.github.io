<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SCARDAGG.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6087"></a>SCARDAGG.CPP</h2>
<pre><code>/*++ <br> <br>Copyright (c) 1996  Microsoft Corporation <br> <br>Module Name: <br> <br>    SCardAgg <br> <br>Abstract: <br> <br>This file contains the outline implementation of the DLL exports <br>for this in-process server (DLL) for example aggregate object. <br> <br>Author: <br> <br>Environment: <br> <br>    Win32, C++ w/Exceptions, ATL, COM/OLE <br> <br>Revision History: <br> <br>Notes: <br> <br>1) This code is NOT specific to any one ICC. It only supports those methods <br>that map directly to a low-level ICC COM interface/method. <br> <br>2) You will need the NT SUR Beta 2 SDK or VC 4.2 in order to build this  <br>project.  This is because you will need MIDL 3.00.15 or higher and  <br>new headers and libs.  If you have VC 4.2 installed, then everything <br>should already be configured correctly. <br> <br>Proxy/Stub Information - <br> <br>To merge the proxy/stub code into the object DLL, add the file  <br>dlldatax.c to the project.  Make sure precompiled headers  <br>are turned off for this file, and add _MERGE_PROXYSTUB to the  <br>defines for the project.   <br> <br>Modify the custom build rule for SCardCOM.idl by adding the  <br>following files to the Outputs.  You can select all of the .IDL  <br>files by expanding each project and holding Ctrl while clicking  <br>on each of them. <br> <br>SCardAgg_p.c <br>dlldata.c <br> <br>To build a separate proxy/stub DLL, run: <br> <br>nmake -f SCardAggps.mak  <br> <br>, in the project directory. <br>--*/ <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// <br>// Includes <br>// <br> <br>#include "preagg.h" <br>#include "resagg.h" <br>#include "initguid.h" <br>#include "ScardAgg.h" <br>#include "SCardNI.h" <br>#include "dllaggx.h" <br> <br>/////////////////////////////////////////////////////////////////////////// <br>// Macros <br>// <br>#ifdef _DEBUG <br>#define TRACE_STR(name,sz) \ <br>TRACE(_T("SCardAgg.DLL: CSCardAggApp::%s: %s\n"), name, sz) <br>#define TRACE_CODE(name,code) \ <br>TRACE(_T("SCardAgg.DLL: CSCardAggApp::%s: error = 0x%x\n"), name, code) <br>#define TRACE_CATCH(name,code)TRACE_CODE(name,code) <br>#define TRACE_CATCH_UNKNOWN(name)TRACE_STR(name,_T("An unidentified exception has occurred!")) <br>#else <br>#define TRACE_STR(name,sz)((void)0) <br>#define TRACE_CODE(name,code)((void)0) <br>#define TRACE_CATCH(name,code)((void)0) <br>#define TRACE_CATCH_UNKNOWN(name)((void)0) <br>#endif  // _DEBUG <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// <br>// ActiveX Template Library (ATL) <br>// <br> <br>#define IID_DEFINED <br>#include "ScardAgg_i.c" <br> <br>#ifdef _MERGE_PROXYSTUB <br>extern "C" HINSTANCE hProxyDll; <br>#endif <br> <br>CComModule _Module; <br> <br>BEGIN_OBJECT_MAP(ObjectMap) <br>OBJECT_ENTRY(CLSID_CSCardNewInterface, CSCardNewInterface) <br>END_OBJECT_MAP() <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// <br>// DLL Entry Point <br>// <br> <br>class CScardAggApp : public CWinApp <br>{ <br>public: <br>virtual BOOL InitInstance(); <br>virtual int ExitInstance(); <br>}; <br> <br>CScardAggApp theApp; <br> <br>/*++ <br> <br>CSCardDatApp::InitInstance: <br> <br>    Override to perform Windows instance initialization, such as <br>creating your window objects. <br> <br>Arguments: <br> <br>    None <br> <br>Return Value: <br> <br>    Nonzero if initialization is successful; otherwise 0. <br> <br>Author: <br> <br>    Chris Dudley (cdudley) 2/22/1997 <br> <br>--*/ <br> <br>BOOL CScardAggApp::InitInstance() <br>{ <br>#ifdef _MERGE_PROXYSTUB <br>// Initialize the DLL's COM interfaces. <br>hProxyDll = m_hInstance; <br>// Initialize the MFC part of this object. <br>#endif <br>_Module.Init(ObjectMap, m_hInstance); <br>return CWinApp::InitInstance(); <br>} <br> <br> <br>/*++ <br> <br>CSCardDatApp::ExitInstance: <br> <br>    Override to clean up when your application terminates. <br> <br>Arguments: <br> <br>    None <br> <br>Return Value: <br> <br>    The application s exit code; 0 indicates no errors, and values greater <br>than 0 indicate an error. This value is used as the return value from <br>WinMain. <br> <br>Author: <br> <br>    Chris Dudley (cdudley) 2/22/1997 <br> <br>--*/ <br>int CScardAggApp::ExitInstance() <br>{ <br>_Module.Term(); <br>return CWinApp::ExitInstance(); <br>} <br> <br>/*++ <br> <br>DllCanUnloadNow: <br> <br>    This routine determines whether the DLL that implements this function <br>is in use. If not, the caller can safely unload the DLL from memory. <br> <br>Arguments: <br> <br>    None <br> <br>Return Value: <br> <br>    A HRESULT value indicating the status of the requested action. <br> <br>ReturnMeaning <br>============= <br>S_OKThe DLL can be unloaded. <br>S_FALSEThe DLL cannot be unloaded now. <br> <br>Author: <br> <br>    Chris Dudley (cdudley) 2/22/1997 <br> <br>Notes: <br> <br>1. Remarks <br>A call to DllCanUnloadNow determines whether the DLL from which  <br>it is exported is still in use. A DLL is no longer in use when  <br>it is not managing any existing objects (the reference count on  <br>all of its objects is 0).  <br> <br>2. Notes to Callers <br>You should not have to call DllCanUnloadNow directly. OLE calls  <br>it only through a call to the CoFreeUnusedLibraries function.  <br>When it returns S_OK, CoFreeUnusedLibraries safely frees the DLL. <br> <br>3. Notes to Implementers <br>You need to implement DllCanUnloadNow in, and export it from,  <br>DLLs that are to be dynamically loaded through a call to the  <br>CoGetClassObject function. (You also need to implement and export <br>the DllGetClassObject function in the same DLL). <br> <br>If a DLL loaded through a call to CoGetClassObject fails to export <br>DllCanUnloadNow, the DLL will not be unloaded until the application <br>calls the CoUninitialize function to release the OLE libraries. <br> <br>If the DLL links to another DLL, returning S_OK from DllCanUnloadNow <br>will also cause the second, dependent DLL to be unloaded. To  <br>eliminate the possibility of a crash, the primary DLL should call <br>the CoLoadLibrary function, specifying the path to the second DLL  <br>as the first parameter, and setting the auto free parameter to TRUE. <br>This forces the COM library to reload the second DLL and set it up <br>for a call to CoFreeUnusedLibraries to free it separately when  <br>appropriate.  <br> <br>DllCanUnloadNow should return S_FALSE if there are any existing  <br>references to objects that the DLL manages. <br> <br>--*/ <br>STDAPI DllCanUnloadNow(void) <br>{ <br>#ifdef _MERGE_PROXYSTUB <br>if (PrxDllCanUnloadNow() != S_OK) <br>return S_FALSE; <br>#endif <br>AFX_MANAGE_STATE(AfxGetStaticModuleState()); <br>return (AfxDllCanUnloadNow()==S_OK &amp;&amp; _Module.GetLockCount()==0) ? S_OK : S_FALSE; <br>} <br> <br> <br>/*++ <br> <br>DllGetClassObject: <br> <br>    This routine returns a class factory to create an object of the  <br>requested type. <br> <br>Arguments: <br> <br>    rclsid - CLSID for the class object. <br> <br>riid - Reference to the identifier of the interface that communicates <br>with the class object. Usually, this is IID_IClassFactory  <br>(defined in the OLE headers as the interface identifier for <br>IClassFactory). <br> <br>ppv - Indirect pointer to the communicating interface. <br> <br>Return Value: <br> <br>    A HRESULT value indicating the status of the requested action. <br> <br>ReturnMeaning <br>============= <br>E_INVALIDARGAn argument was invalid or unrecognizable. <br>E_OUTOFMEMORYNo free memory in process address space <br>to create requested object. <br>E_UNEXPECTEDOne of the parameters was of an unexpected <br>type or value. <br>S_OKThe object was retrieved successfully. <br>CLASS_E_CLASSNOTAVAILABLEThe DLL does not support the class  <br>(object definition). <br> <br> <br>Author: <br> <br>    Chris Dudley (cdudley) 2/22/1997 <br> <br>Notes: <br> <br>1. Remarks <br>If a call to the CoGetClassObject function finds the class object <br>that is to be loaded in a DLL, CoGetClassObject uses the DLL's  <br>exported DllGetClassObject function.  <br> <br>2. Notes to Callers <br>You should not call DllGetClassObject directly. When an object <br>is defined in a DLL, CoGetClassObject calls the CoLoadLibrary <br>function to load the DLL, which, in turn, calls DllGetClassObject.  <br> <br>3. Notes to Implementers <br>You need to implement DllGetClassObject in (and export it from)  <br>DLLs that support the OLE Component Object Model. <br> <br>--*/ <br>STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv) <br>{ <br>#ifdef _MERGE_PROXYSTUB <br>if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK) <br>return S_OK; <br>#endif <br>return _Module.GetClassObject(rclsid, riid, ppv); <br>} <br> <br> <br>/*++ <br> <br>DllRegisterServer: <br> <br>    This routine instructs an in-process server to create its registry <br>entries for all classes supported in this server module. If this  <br>function fails, the state of the registry for all its classes is <br>indeterminate. <br> <br>Arguments: <br> <br>    None <br> <br>Return Value: <br> <br>    A HRESULT value indicating the status of the requested action. <br> <br>ReturnMeaning <br>============= <br>E_OUTOFMEMORYNo free memory in process address space to <br>create requested object. <br>E_UNEXPECTEDOne of the parameters was of an unexpected <br>type or value. <br>S_OKThe registry entries were created successfully. <br>SELFREG_E_TYPELIBThe server was unable to complete the  <br>registration of all the type libraries used  <br>by its classes. <br>SELFREG_E_CLASSThe server was unable to complete the  <br>registration of all the object classes. <br> <br>Author: <br> <br>    Chris Dudley (cdudley) 2/22/1997 <br> <br>--*/ <br>STDAPI DllRegisterServer(void) <br>{ <br>#ifdef _MERGE_PROXYSTUB <br>HRESULT hRes = PrxDllRegisterServer(); <br>if (FAILED(hRes)) <br>return hRes; <br>#endif <br>// registers object, typelib and all interfaces in typelib <br>return _Module.RegisterServer(TRUE); <br>} <br> <br> <br>/*++ <br> <br>DllUnregisterServer: <br> <br>    This routine instructs an in-process server to remove only those  <br>entries created through DllRegisterServer. <br> <br>Arguments: <br> <br>    None <br> <br>Return Value: <br> <br>    A HRESULT value indicating the status of the requested action. <br> <br>ReturnMeaning <br>============= <br>E_OUTOFMEMORYNo free memory in process address space to create <br>requested object. <br>E_UNEXPECTEDOne of the parameters was of an unexpected type <br>or value. <br>S_OKThe registry entries were created successfully. <br>S_FALSEUnregistration of this server's known entries  <br>was successful, but other entries still exist  <br>for this server's classes. <br> <br>Author: <br> <br>    Chris Dudley (cdudley) 2/22/1997 <br> <br>Notes: <br> <br>The server must not disturb any entries that it did not create <br>which currently exist for its object classes. For example, between  <br>registration and unregistration, the user may have specified a  <br>TreatAs relationship between this class and another. In that case, <br>unregistration can remove all entries except the TreatAs key and <br>any others that were not explicitly created in DllRegisterServer. <br>The Win32 registry functions specifically disallow the deletion  <br>of an entire populated tree in the registry. The server can attempt, <br>as the last step, to remove the CLSID key, but if other entries  <br>still exist, the key will remain. <br> <br>--*/ <br>STDAPI DllUnregisterServer(void) <br>{ <br>#ifdef _MERGE_PROXYSTUB <br>PrxDllUnregisterServer(); <br>#endif <br>_Module.UnregisterServer(); <br>return S_OK; <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
