<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>README.TXT</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6173"></a>README.TXT</h2>
<pre><code>Check Security Descriptors (SD) <br> <br> <br>In the Win32 Programmer's Reference, if you go to the Security overview, then <br>choose the sub-topic "Allowing Access", you'll find the comment <br> <br>   Note: It is fine to write code like this that builds security <br>   descriptors from scratch. It is, however, a good practice <br>   for people who write code that builds or manipulates <br>   security descriptors to first write code that explores the <br>   default security descriptors that Windows NT places on <br>   objects. For example, if Windows NT by default includes in <br>   a DACL an ACE granting the Local Logon SID certain access, <br>   it's good to know that, so that a decision not to grant any <br>   access to the Local Logon SID would be a conscious decision <br> <br>This comment is accurate, however, to begin with, this task of examining the <br>SD is easier if there is sample code to start from. The purpose of the CHECK_SD <br>sample is to provide sample code you can start from as you examine an SD. <br>This sample only examines the SD on files, but the code can be modified to <br>examine the SD on other objects. <br> <br>This sample is not a supported utility <br> <br>To run <br>------ <br> <br>Type Check_sd to check the SD on the \\.\A: device <br> <br>   Type Check_sd d:\a.fil to check the SD on the d:\a.fil <br>      file.  In this case d: must be formatted NTFS, <br>      because only NTFS files have SD(s) <br> <br>Further notes <br>------------- <br> <br>If you recompile with this define statement included: <br> <br>  #define I_DO_NOT_WANT_THIS_CODE_TO_CLUTTER_THIS_PROGRAM_S_OUTPUT (1==0) <br> <br>and re-run the program, the program will display more output, including <br>all the information you can access from the process Access Token, and the <br>SD's of some sample objects. <br> <br>If you logon, run with the program built to produce the extra output as <br>mentioned, save that output to a file, log off and re-run the program, <br>and save the output of this second run to a different file, then you use <br>WinDiff to observe how the local logon SID changes values for each session. <br> <br>Here is a sample test you could run to exercise DACLs involves using the <br>SD_FLPPY sample in conjunction with the CHECK_SD sample: <br> <br> - Log on to a machine as a local Administrator <br> - Do <br>      check_sd \\.\A: &gt;out_bef.a <br>      check_sd \\.\B: &gt;out_bef.b <br> - Logoff <br> - Log on the same machine as Guest on the local machine domain <br> - Do <br>      sd_flppy <br> - Try <br>      dir a:    (observe access denied) <br>      dir b:    (observe access denied) <br>      copy config.sys a:\   (get device not found) <br>      copy config.sys b:\   (get device not found) <br> - Logoff <br> - Log on the same machine as a local Administrator <br> - Do <br>      check_sd \\.\A: &gt;out_aft.a <br>      check_sd \\.\B: &gt;out_aft.b <br> - Browse the differences between out_bef.* and out_aft.* <br> <br>This test demonstrates that the ACLs that SD_FLPPY applies survive logoff. <br>To demonstrate that the DACLs do not survive logoff, simply reboot, log back <br>on as a local Administrator, and run the commands: <br> <br>   check_sd \\.\A: &gt;out_rbt.a <br>   check_sd \\.\B: &gt;out_rbt.b <br> <br>to see the DACLs are again as they were. </code></pre>
<p>&nbsp;</p></body>
</HTML>
