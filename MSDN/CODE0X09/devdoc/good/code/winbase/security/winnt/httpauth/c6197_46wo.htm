<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>GET_SOCK.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6198"></a>GET_SOCK.C</h2>
<pre><code>/*++ <br> <br>Copyright 1996 - 1998 Microsoft Corporation <br> <br>Module Name: <br> <br>    get_sock.c <br> <br>Abstract: <br> <br>    This does a get using raw sockets <br> <br>History: <br> <br>    09-Nov-1995     Created <br>    15-Feb-1996     Added authentication support <br> <br>--*/ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;winsock.h&gt; <br> <br>#include &lt;stdio.h&gt; <br>#include &lt;stdarg.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;string.h&gt; <br>#include &lt;tchar.h&gt; <br>#include &lt;io.h&gt; <br>#include &lt;fcntl.h&gt; <br>#include &lt;sys/types.h&gt; <br>#include &lt;sys/stat.h&gt; <br> <br>#include "httpauth.h" <br> <br>// globals <br> <br>#define HD_AUTHENTICATE         "WWW-Authenticate:" <br>#define HD_LENGTH               "Content-Length:" <br>#define HD_CONNECTION           "Connection:" <br> <br>// list of Authentication methods to support <br> <br>char      achAuth[256]; <br> <br> <br>// Helper functions <br> <br>void SkipWhite(PSTR *ppS ) <br>{ <br>    PSTR pS = *ppS; <br> <br>    while ( *pS &amp;&amp; isspace(*pS) ) <br>        ++pS; <br> <br>    *ppS = pS; <br>} <br> <br> <br>void SkipNonWhite(PSTR *ppS ) <br>{ <br>    PSTR pS = *ppS; <br> <br>    while ( *pS &amp;&amp; !isspace(*pS) ) <br>        ++pS; <br> <br>    *ppS = pS; <br>} <br> <br> <br> <br>BOOL <br>HttpGetSocket( <br>    char * Verb, <br>    char * Server, <br>    char * URL, <br>    BOOL   DisplayHeaders, <br>    DWORD  ClientDataSize, <br>    PSTR   pchUserName, <br>    PSTR   pchPassword, <br>    PSTR   pszStore, <br>    PSTR   pszPref <br>    ) <br>/*++ <br> <br> Routine Description: <br> <br>    Issue a command to a HTTP server using authentication <br> <br> Arguments: <br> <br>    Verb                HTTP command : GET / HEAD / ... <br>    Server              server name <br>    URL                 URL to send to the server <br>    DisplayHeaders      TRUE to display headers as received <br>    ClientDataSize      number of bytes to send in the request <br>    pchUserName         user name for authentication <br>    pchPassword         password for authentication <br>    pszStore            file name where to dump reply from server <br> <br> Return Value: <br> <br>    Returns TRUE is successful; otherwise FALSE is returned. <br> <br>--*/ <br>{ <br>    char               ReceiveBuffer[8*1024]; <br>    int                Error; <br>    BYTE               Request[1024]; <br>    int                RequestSize; <br>    char *             AcceptTypes[2] = {"*/*", NULL}; <br>    SOCKET             Socket = INVALID_SOCKET; <br>    WSADATA            WsaData; <br>    struct sockaddr_in Address; <br>    struct hostent *   HostEntry; <br>    char               Headers[] =  <br>                           "HTTP/1.0\r\n" <br>                           "User-Agent: AuthClient\r\n" <br>                           "Accept: */*\r\n"; <br>    char               CrLf[] = "\r\n"; <br>    BYTE               ClientData[64*1024]; <br>    BOOL               fKeepAlive = FALSE; <br>    int                cRec; <br>    DWORD              cLen; <br>    BOOL               fInHeader; <br>    PSTR               pchAuthData; <br>    BOOL               fServerKeepAlive = FALSE; <br>    BOOL               fNeedMoreData; <br>    BOOL               fNeedAuthenticate; <br>    PSTR               pH; <br>    PSTR               pN; <br>    BOOL               fStatusLine; <br>    int                Status = -1; <br>    DWORD              cToRead; <br>    PSTR               paAuth = achAuth; <br>    BOOL               fSt = FALSE; <br>    int                hnd = EOF; <br> <br>    Error = WSAStartup (0x101, &amp;WsaData); <br> <br>    if (Error == SOCKET_ERROR)  <br>    { <br>        fprintf(stderr, "Error in WSAStartup = %d\n", GetLastError()); <br>        return FALSE; <br>    } <br> <br>    if ( !InitAuthorizationHeader() ) <br>    { <br>        fprintf(stderr, "Cannot initialize security module\n" ); <br>        return FALSE; <br>    } <br> <br>    memset( achAuth, '\0', sizeof(achAuth) ); <br>    pchAuthData = NULL; <br>    fNeedAuthenticate = FALSE; <br> <br>    // <br>    // Connect to the server <br>    // <br> <br>    if  ( pszStore != NULL ) <br>        if ( (hnd = _open( pszStore, _O_BINARY | _O_CREAT | _O_TRUNC | _O_RDWR, S_IREAD|S_IWRITE )) == EOF ) <br>        { <br>            fprintf( stderr, "Can't create file %s\n", pszStore ); <br>            return FALSE; <br>        } <br> <br>again: <br> <br>    if ( Socket == INVALID_SOCKET ) <br>    { <br>        Socket = socket(AF_INET, SOCK_STREAM, 0); <br> <br>        if (Socket == INVALID_SOCKET)  <br>        { <br>            fprintf(stderr, "Error creating socket = %d\n", GetLastError()); <br>            fSt = FALSE; <br>            goto ex; <br>        } <br> <br>        Address.sin_family = AF_INET; <br>        Address.sin_port = 0; <br>        Address.sin_addr.s_addr = INADDR_ANY; <br> <br>        Error =  <br>        bind( <br>            Socket, <br>            (struct sockaddr *) &amp;Address, <br>            sizeof(Address)); <br> <br>        if (Error)  <br>        { <br>            fprintf(stderr, "Error in bind = %d\n", GetLastError()); <br>            fSt = FALSE; <br>            goto ex; <br>        } <br> <br>        Address.sin_family = AF_INET; <br>        Address.sin_port = htons(80); <br>        Address.sin_addr.s_addr = inet_addr(Server); <br> <br>        if (Address.sin_addr.s_addr == -1)  <br>        { <br>            // <br>            // Must be a server name <br>            // <br>            HostEntry = gethostbyname(Server); <br>            if (HostEntry == NULL)  <br>            { <br>                printf("unable to resolve %s\n", Server); <br>                fSt = FALSE; <br>                goto ex; <br>            } else  <br>            { <br>                Address.sin_addr.s_addr = *((unsigned long *) HostEntry-&gt;h_addr); <br>            } <br>        } <br> <br>        Error = <br>        connect( <br>            Socket, <br>            (struct sockaddr *) &amp;Address, <br>            sizeof(Address)); <br> <br>        if (Error)  <br>        { <br>            fprintf(stderr, "Error connecting to %s = %d\n", Server, GetLastError()); <br>            fSt = FALSE; <br>            goto ex; <br>        } <br>    } <br> <br>    // <br>    // Send the client request <br>    // <br> <br>    strcpy(Request, Verb); <br>    strcat(Request, " "); <br>    strcat(Request, URL); <br>    strcat(Request, " "); <br>    strcat(Request, Headers); <br>    if (ClientDataSize)  <br>    { <br>        sprintf(ClientData, "Content-Length: %d\r\n", ClientDataSize); <br>        strcat(Request, ClientData); <br>    } <br>    if ( fKeepAlive ) <br>    { <br>        strcat(Request, "Connection: Keep-Alive\r\n" ); <br>    } <br> <br>    if ( !AddAuthorizationHeader( Request + strlen(Request), achAuth, pchAuthData, pchUserName, pchPassword, &amp;fNeedMoreData ) ) <br>    { <br>        printf( "Authentication failed\n" ); <br>        fSt = FALSE; <br>        goto ex; <br>    } <br> <br>    strcat(Request, CrLf); <br> <br>    RequestSize = strlen(Request); <br> <br>    Error = <br>    send( <br>        Socket, <br>        Request, <br>        RequestSize, <br>        0); <br> <br>    if (Error != RequestSize)  <br>    { <br>        printf("Error in client send = %d, %d\n", Error, GetLastError()); <br>        fSt = FALSE; <br>        goto ex; <br>    } <br> <br>    if (ClientDataSize)  <br>    { <br>        memset( ClientData, ' ', ClientDataSize ); <br> <br>        // <br>        // Send the client data <br>        // <br> <br>        Error = <br>        send( <br>            Socket, <br>            ClientData, <br>            ClientDataSize, <br>            0); <br> <br>        if ( (DWORD)Error != ClientDataSize)  <br>        { <br>            printf("Error in client send = %d, %d\n", Error, GetLastError()); <br>            fSt = FALSE; <br>            goto ex; <br>        } <br>    } <br> <br>    // parse status &amp; header <br> <br>    cLen = (DWORD)-1; <br>    fInHeader = TRUE; <br>    fServerKeepAlive = FALSE; <br>    fNeedAuthenticate = FALSE; <br> <br>    for ( pH = ReceiveBuffer, fStatusLine = TRUE ; fInHeader ; ) <br>    { <br>        cRec = recv( Socket, pH, ReceiveBuffer+sizeof(ReceiveBuffer)-pH, 0 ); <br>        if ( cRec &lt;= 0 ) <br>        { <br>            closesocket( Socket ); <br>            Socket = INVALID_SOCKET; <br>            break; <br>        } <br>        pH[ cRec ] = '\0'; <br> <br>        // Iterate on header fields <br> <br>        while ( pN = strstr(pH, "\r\n" ) ) <br>        { <br>            *pN = '\0'; <br> <br>            if ( DisplayHeaders ) <br>            { <br>                printf( "%s\n", pH ); <br>            } <br> <br>            if ( fStatusLine ) <br>            { <br>                // This is the status line, decode status <br> <br>                SkipNonWhite( &amp;pH ); <br>                SkipWhite( &amp;pH ); <br>                Status = atoi( pH ); <br>                if ( Status == 401 ) <br>                { <br>                    fNeedAuthenticate = TRUE; <br>                } <br>                fStatusLine = FALSE; <br>            } <br>            else if ( pN == pH )    // end of header fields <br>            { <br>                if ( hnd != EOF ) <br>                    write( hnd, pH+2, ReceiveBuffer+cRec-pH-2 ); <br> <br>                cLen -= ( ReceiveBuffer+cRec-pH-2 ); <br>                fInHeader = FALSE; <br>                break; <br>            } <br>            else if ( !strnicmp( pH, HD_AUTHENTICATE, sizeof(HD_AUTHENTICATE)-1 ) ) <br>            { <br>                SkipNonWhite( &amp;pH ); <br>                SkipWhite( &amp;pH ); <br> <br>                // check if we are already in the authentication sequence <br> <br>                if ( !IsInAuthorizationSequence() ) <br>                { <br>                    // append to list of supported authentication methods <br> <br>                    strcpy( paAuth, pH ); <br>                    paAuth += strlen( pH ) + 1; <br>                } <br>                else <br>                { <br>                    // store pointer to authenticate blob <br> <br>                    SkipNonWhite( &amp;pH ); <br>                    SkipWhite( &amp;pH ); <br>                    pchAuthData = pH; <br>                } <br>            } <br>            else if ( !strnicmp( pH, HD_LENGTH, sizeof(HD_LENGTH)-1 ) ) <br>            { <br>                // get content length <br> <br>                SkipNonWhite( &amp;pH ); <br>                SkipWhite( &amp;pH ); <br>                cLen = atoi( pH ); <br>            } <br>            else if ( !strnicmp( pH, HD_CONNECTION, sizeof(HD_CONNECTION)-1 ) ) <br>            { <br>                // check for keep-alive flag <br> <br>                SkipNonWhite( &amp;pH ); <br>                SkipWhite( &amp;pH ); <br>                if ( !strnicmp( pH, "Keep-Alive", sizeof("Keep-Alive")-1 ) ) <br>                    fServerKeepAlive = TRUE; <br>            } <br> <br>            pH = pN + 2; <br>        } <br>    } <br> <br>    // add final delimiter to list of supported authentication methods <br> <br>    if ( !IsInAuthorizationSequence() &amp;&amp; fNeedAuthenticate ) <br>    { <br>        *paAuth = '\0'; <br> <br>        // Insure specified methods are supported localy <br> <br>        if ( !ValidateAuthenticationMethods( achAuth, pszPref ) ) <br>        { <br>            // None of the server specified authentication methods <br>            // are supported localy. <br> <br>            SetLastError( ERROR_ACCESS_DENIED ); <br> <br>            fprintf( stderr, "No supported authentication method\n" ); <br> <br>            fSt = FALSE; <br>            goto ex; <br>        } <br>    } <br> <br>    // read message body <br> <br>    if ( Socket != INVALID_SOCKET ) <br>    { <br>        for ( ; cLen ; ) <br>        { <br>            if ( (cToRead = sizeof(ReceiveBuffer)) &gt; cLen ) <br>                cToRead = cLen; <br>            cRec = recv( Socket, ReceiveBuffer, cToRead, 0 ); <br> <br>            if ( cRec &lt;= 0 ) <br>            { <br>                closesocket( Socket ); <br>                Socket = INVALID_SOCKET; <br>                break; <br>            } <br>            if ( hnd != EOF ) <br>                write( hnd, ReceiveBuffer, cRec ); <br> <br>            cLen -= cRec; <br>        } <br>    } <br> <br>    if ( !fServerKeepAlive ) <br>    { <br>        if ( IsInAuthorizationSequence() ) <br>        { <br>            fprintf( stderr, "Authentication rejected by server\n" ); <br> <br>            fNeedAuthenticate = FALSE;  // authentication failed <br>        } <br> <br>        closesocket( Socket ); <br>        Socket = INVALID_SOCKET; <br>    } <br> <br>    if ( fNeedAuthenticate ) <br>    { <br>        fKeepAlive = TRUE; <br>        goto again; <br>    } <br> <br>    if ( Socket != INVALID_SOCKET ) <br>        closesocket(Socket); <br> <br>    fSt = Status == 200; <br> <br>ex: <br>    TerminateAuthorizationHeader(); <br> <br>    if ( hnd != EOF ) <br>        close( hnd ); <br> <br>    return fSt; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
