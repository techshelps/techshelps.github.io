<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>GINASTUB.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6196"></a>GINASTUB.C</h2>
<pre><code>/*++ <br> <br>Copyright 1996 - 1997 Microsoft Corporation <br> <br>Module Name: <br> <br>    ginastub.c <br> <br>Abstract: <br> <br>    This sample illustrates a pass-thru "stub" gina which can be used <br>    in some cases to simplify gina development. <br> <br>    A common use for a gina is to implement code which requires the <br>    credentials of the user logging onto the workstation.  The credentials <br>    may be required for syncronization with foreign account databases <br>    or custom authentication activities. <br> <br>    In this example case, it is possible to implement a simple gina <br>    stub layer which simply passes control for the required functions <br>    to the previously installed gina, and captures the interesting <br>    parameters from that gina.  In this scenario, the existing functionality <br>    in the existent gina is retained.  In addition, the development time <br>    is reduced drastically, as existing functionality does not need to <br>    be duplicated. <br> <br>    When dealing with credentials, take steps to maintain the security <br>    of the credentials.  For instance, if transporting credentials over <br>    a network, be sure to encrypt the credentials. <br> <br>Author: <br> <br>    Scott Field (sfield)    18-Jul-96 <br> <br>--*/ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;winwlx.h&gt; <br> <br>#include "ginastub.h" <br> <br>// <br>// Location of the real msgina. <br>// <br> <br>#define REALGINA_PATH   TEXT("MSGINA.DLL") <br> <br> <br>// <br>// winlogon function dispatch table <br>// <br> <br>PWLX_DISPATCH_VERSION_1_0 g_pWinlogon; <br> <br>// <br>// Functions pointers to the real msgina which we will call. <br>// <br> <br>PGWLXNEGOTIATE GWlxNegotiate; <br>PGWLXINITIALIZE GWlxInitialize; <br>PGWLXDISPLAYSASNOTICE GWlxDisplaySASNotice; <br>PGWLXLOGGEDOUTSAS GWlxLoggedOutSAS; <br>PGWLXACTIVATEUSERSHELL GWlxActivateUserShell; <br>PGWLXLOGGEDONSAS GWlxLoggedOnSAS; <br>PGWLXDISPLAYLOCKEDNOTICE GWlxDisplayLockedNotice; <br>PGWLXWKSTALOCKEDSAS GWlxWkstaLockedSAS; <br>PGWLXISLOCKOK GWlxIsLockOk; <br>PGWLXISLOGOFFOK GWlxIsLogoffOk; <br>PGWLXLOGOFF GWlxLogoff; <br>PGWLXSHUTDOWN GWlxShutdown; <br> <br>// <br>// NEW for version 1.1 <br>// <br> <br>PGWLXSTARTAPPLICATION GWlxStartApplication; <br>PGWLXSCREENSAVERNOTIFY GWlxScreenSaverNotify; <br> <br>// <br>// hook into the real GINA. <br>// <br> <br>BOOL <br>MyInitialize( void ) <br>{ <br>    HINSTANCE hDll; <br> <br>    // <br>    // Load MSGINA.DLL. <br>    // <br>    if( !(hDll = LoadLibrary( REALGINA_PATH )) ) { <br>        return FALSE; <br>    } <br> <br>    // <br>    // Get pointers to all of the WLX functions in the real MSGINA. <br>    // <br>    GWlxNegotiate = (PGWLXNEGOTIATE)GetProcAddress( hDll, "WlxNegotiate" ); <br>    if( !GWlxNegotiate ) { <br>        return FALSE; <br>    } <br> <br>    GWlxInitialize = (PGWLXINITIALIZE)GetProcAddress( hDll, "WlxInitialize" ); <br>    if( !GWlxInitialize ) { <br>        return FALSE; <br>    } <br> <br>    GWlxDisplaySASNotice = <br>        (PGWLXDISPLAYSASNOTICE)GetProcAddress( hDll, "WlxDisplaySASNotice" ); <br>    if( !GWlxDisplaySASNotice ) { <br>        return FALSE; <br>    } <br> <br>    GWlxLoggedOutSAS = <br>        (PGWLXLOGGEDOUTSAS)GetProcAddress( hDll, "WlxLoggedOutSAS" ); <br>    if( !GWlxLoggedOutSAS ) { <br>        return FALSE; <br>    } <br> <br>    GWlxActivateUserShell = <br>        (PGWLXACTIVATEUSERSHELL)GetProcAddress( hDll, "WlxActivateUserShell" ); <br>    if( !GWlxActivateUserShell ) { <br>        return FALSE; <br>    } <br> <br>    GWlxLoggedOnSAS = <br>        (PGWLXLOGGEDONSAS)GetProcAddress( hDll, "WlxLoggedOnSAS" ); <br>    if( !GWlxLoggedOnSAS ) { <br>        return FALSE; <br>    } <br> <br>    GWlxDisplayLockedNotice = <br>        (PGWLXDISPLAYLOCKEDNOTICE)GetProcAddress( <br>                                        hDll, <br>                                        "WlxDisplayLockedNotice" ); <br>    if( !GWlxDisplayLockedNotice ) { <br>        return FALSE; <br>    } <br> <br>    GWlxIsLockOk = (PGWLXISLOCKOK)GetProcAddress( hDll, "WlxIsLockOk" ); <br>    if( !GWlxIsLockOk ) { <br>        return FALSE; <br>    } <br> <br>    GWlxWkstaLockedSAS = <br>        (PGWLXWKSTALOCKEDSAS)GetProcAddress( hDll, "WlxWkstaLockedSAS" ); <br>    if( !GWlxWkstaLockedSAS ) { <br>        return FALSE; <br>    } <br> <br>    GWlxIsLogoffOk = (PGWLXISLOGOFFOK)GetProcAddress( hDll, "WlxIsLogoffOk" ); <br>    if( !GWlxIsLogoffOk ) { <br>        return FALSE; <br>    } <br> <br>    GWlxLogoff = (PGWLXLOGOFF)GetProcAddress( hDll, "WlxLogoff" ); <br>    if( !GWlxLogoff ) { <br>        return FALSE; <br>    } <br> <br>    GWlxShutdown = (PGWLXSHUTDOWN)GetProcAddress( hDll, "WlxShutdown" ); <br>    if( !GWlxShutdown ) { <br>        return FALSE; <br>    } <br> <br>    // <br>    // we don't check for failure here because these don't exist for <br>    // gina's implemented prior to Windows NT 4.0 <br>    // <br> <br>    GWlxStartApplication = (PGWLXSTARTAPPLICATION) GetProcAddress( hDll, "WlxStartApplication" ); <br>    GWlxScreenSaverNotify = (PGWLXSCREENSAVERNOTIFY) GetProcAddress( hDll, "WlxScreenSaverNotify" ); <br> <br>    // <br>    // Everything loaded ok.  Return success. <br>    // <br>    return TRUE; <br>} <br> <br> <br>BOOL <br>WINAPI <br>WlxNegotiate( <br>    DWORD       dwWinlogonVersion, <br>    DWORD       *pdwDllVersion) <br>{ <br>    if( !MyInitialize() ) <br>        return FALSE; <br> <br>    return GWlxNegotiate( dwWinlogonVersion, pdwDllVersion ); <br>} <br> <br> <br>BOOL <br>WINAPI <br>WlxInitialize( <br>    LPWSTR      lpWinsta, <br>    HANDLE      hWlx, <br>    PVOID       pvReserved, <br>    PVOID       pWinlogonFunctions, <br>    PVOID       *pWlxContext) <br>{ <br>    return GWlxInitialize( <br>                lpWinsta, <br>                hWlx, <br>                pvReserved, <br>                pWinlogonFunctions, <br>                pWlxContext <br>                ); <br>} <br> <br> <br>VOID <br>WINAPI <br>WlxDisplaySASNotice( <br>    PVOID   pWlxContext) <br>{ <br>    GWlxDisplaySASNotice( pWlxContext ); <br>} <br> <br> <br>int <br>WINAPI <br>WlxLoggedOutSAS( <br>    PVOID           pWlxContext, <br>    DWORD           dwSasType, <br>    PLUID           pAuthenticationId, <br>    PSID            pLogonSid, <br>    PDWORD          pdwOptions, <br>    PHANDLE         phToken, <br>    PWLX_MPR_NOTIFY_INFO    pMprNotifyInfo, <br>    PVOID           *pProfile) <br>{ <br>    int iRet; <br> <br>    iRet = GWlxLoggedOutSAS( <br>                pWlxContext, <br>                dwSasType, <br>                pAuthenticationId, <br>                pLogonSid, <br>                pdwOptions, <br>                phToken, <br>                pMprNotifyInfo, <br>                pProfile <br>                ); <br> <br>    if(iRet == WLX_SAS_ACTION_LOGON) { <br>        // <br>        // copy pMprNotifyInfo and pLogonSid for later use <br>        // <br> <br>        // pMprNotifyInfo-&gt;pszUserName <br>        // pMprNotifyInfo-&gt;pszDomain <br>        // pMprNotifyInfo-&gt;pszPassword <br>        // pMprNotifyInfo-&gt;pszOldPassword <br> <br>    } <br> <br>    return iRet; <br>} <br> <br> <br>BOOL <br>WINAPI <br>WlxActivateUserShell( <br>    PVOID           pWlxContext, <br>    PWSTR           pszDesktopName, <br>    PWSTR           pszMprLogonScript, <br>    PVOID           pEnvironment) <br>{ <br>    return GWlxActivateUserShell( <br>                pWlxContext, <br>                pszDesktopName, <br>                pszMprLogonScript, <br>                pEnvironment <br>                ); <br>} <br> <br> <br>int <br>WINAPI <br>WlxLoggedOnSAS( <br>    PVOID           pWlxContext, <br>    DWORD           dwSasType, <br>    PVOID           pReserved) <br>{ <br>    return GWlxLoggedOnSAS( pWlxContext, dwSasType, pReserved ); <br>} <br> <br>VOID <br>WINAPI <br>WlxDisplayLockedNotice( <br>    PVOID           pWlxContext ) <br>{ <br>    GWlxDisplayLockedNotice( pWlxContext ); <br>} <br> <br> <br>BOOL <br>WINAPI <br>WlxIsLockOk( <br>    PVOID           pWlxContext) <br>{ <br>    return GWlxIsLockOk( pWlxContext ); <br>} <br> <br> <br>int <br>WINAPI <br>WlxWkstaLockedSAS( <br>    PVOID           pWlxContext, <br>    DWORD           dwSasType ) <br>{ <br>    return GWlxWkstaLockedSAS( pWlxContext, dwSasType ); <br>} <br> <br>BOOL <br>WINAPI <br>WlxIsLogoffOk( <br>    PVOID pWlxContext <br>    ) <br>{ <br>    BOOL bSuccess; <br> <br>    bSuccess = GWlxIsLogoffOk( pWlxContext ); <br> <br>    if(bSuccess) { <br> <br>        // <br>        // if it's ok to logoff, finish with the stored credentials <br>        // and scrub the buffers <br>        // <br> <br>    } <br> <br>    return bSuccess; <br>} <br> <br> <br>VOID <br>WINAPI <br>WlxLogoff( <br>    PVOID pWlxContext <br>    ) <br>{ <br>    GWlxLogoff( pWlxContext ); <br>} <br> <br> <br>VOID <br>WINAPI <br>WlxShutdown( <br>    PVOID pWlxContext, <br>    DWORD ShutdownType <br>    ) <br>{ <br>    GWlxShutdown( pWlxContext, ShutdownType ); <br>} <br> <br> <br>// <br>// NEW for version 1.1 <br>// <br> <br>BOOL <br>WINAPI <br>WlxScreenSaverNotify( <br>    PVOID                   pWlxContext, <br>    BOOL *                  pSecure <br>    ) <br>{ <br>    if(GWlxScreenSaverNotify != NULL) <br>        return GWlxScreenSaverNotify( pWlxContext, pSecure ); <br> <br>    // <br>    // if not exported, return something intelligent <br>    // <br> <br>    *pSecure = TRUE; <br> <br>    return TRUE; <br>} <br> <br>BOOL <br>WINAPI <br>WlxStartApplication( <br>    PVOID                   pWlxContext, <br>    PWSTR                   pszDesktopName, <br>    PVOID                   pEnvironment, <br>    PWSTR                   pszCmdLine <br>    ) <br>{ <br>    if(GWlxStartApplication != NULL) <br>        return GWlxStartApplication( <br>            pWlxContext, <br>            pszDesktopName, <br>            pEnvironment, <br>            pszCmdLine <br>            ); <br> <br>    // <br>    // if not exported, return something intelligent <br>    // <br> <br>} <br> <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
