<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>HTTPAUTH.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6199"></a>HTTPAUTH.C</h2>
<pre><code>/*++ <br> <br>Copyright 1996 - 1998 Microsoft Corporation <br> <br>Module Name: <br> <br>    httpauth.c <br> <br>Abstract: <br> <br>    Handles authentication sequence ( Basic &amp; SSPI ) <br> <br>History: <br> <br>    Created     15-Feb-1996 <br> <br> <br>Revision History: <br> <br>--*/ <br> <br>/************************************************************ <br> *    Include Headers <br> ************************************************************/ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;rpc.h&gt; <br>#include &lt;winsock.h&gt; <br>#include &lt;lm.h&gt; <br> <br>#include &lt;stdio.h&gt; <br>#include &lt;stdarg.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;string.h&gt; <br>#include &lt;tchar.h&gt; <br>#include &lt;fcntl.h&gt; <br> <br>#define SECURITY_WIN32 <br>#include "sspi.h" <br>#include "issperr.h" <br> <br> <br>// declaration for this module <br> <br>#include "httpauth.h" <br> <br>#define SEC_SUCCESS(Status) ((Status) &gt;= 0) <br>#define STATUS_SUCCESS 0 <br> <br> <br>// Target name for the security package <br> <br>#define TOKEN_SOURCE_NAME       "InetSvcs" <br> <br> <br>// general purpose dynamic buffer structure <br> <br>typedef struct _BUFFER { <br>    PBYTE pBuf; <br>    DWORD cLen; <br>} BUFFER ; <br> <br> <br>// structure storing the state of the authentication sequence <br> <br>typedef struct _AUTH_SEQ { <br>    BOOL _fNewConversation; <br>    CredHandle _hcred; <br>    BOOL _fHaveCredHandle; <br>    DWORD _cbMaxToken; <br>    BOOL _fHaveCtxtHandle; <br>    struct _SecHandle  _hctxt; <br>    BOOL _fUUEncodeData; <br>} AUTH_SEQ; <br> <br>// entry points in the security DLL <br> <br>typedef struct _SEC_FUNC { <br>    FREE_CREDENTIALS_HANDLE_FN pFreeCredentialsHandle; <br>    ACQUIRE_CREDENTIALS_HANDLE_FN pAcquireCredentialsHandle; <br>    QUERY_SECURITY_PACKAGE_INFO_FN pQuerySecurityPackageInfo;   // A <br>    FREE_CONTEXT_BUFFER_FN pFreeContextBuffer; <br>    INITIALIZE_SECURITY_CONTEXT_FN pInitializeSecurityContext;  // A <br>    COMPLETE_AUTH_TOKEN_FN pCompleteAuthToken; <br>    ENUMERATE_SECURITY_PACKAGES_FN pEnumerateSecurityPackages;  // A <br>} SEC_FUNC; <br> <br>// local functions <br> <br>BOOL CrackUserAndDomain( <br>    CHAR *   pszDomainAndUser, <br>    CHAR * * ppszUser, <br>    CHAR * * ppszDomain <br>    ); <br> <br>BOOL AuthConverse( <br>    AUTH_SEQ *pAS, <br>    VOID   * pBuffIn, <br>    DWORD    cbBuffIn, <br>    BUFFER * pbuffOut, <br>    DWORD  * pcbBuffOut, <br>    BOOL   * pfNeedMoreData, <br>    CHAR   * pszPackage, <br>    CHAR   * pszUser, <br>    CHAR   * pszPassword <br>    ); <br> <br>BOOL AuthInit( AUTH_SEQ *pAS ); <br> <br>void AuthTerminate( AUTH_SEQ *pAS ); <br> <br> <br>// uuencode/decode routines declaration <br>// used to code the authentication blob <br> <br>BOOL uudecode(char   * bufcoded, <br>              BUFFER * pbuffdecoded, <br>              DWORD  * pcbDecoded ); <br>BOOL uuencode( BYTE *   bufin, <br>               DWORD    nbytes, <br>               BUFFER * pbuffEncoded ); <br> <br> <br>/************************************************************ <br> *    Globals for this module <br> ************************************************************/ <br> <br>static BOOL g_fAuth = FALSE; <br>static BOOL g_fBasic = FALSE; <br>static AUTH_SEQ g_Auth; <br>static HINSTANCE g_hSecLib = NULL; <br>static SEC_FUNC sfProcs; <br> <br> <br>/************************************************************ <br> *    Helper functions <br> ************************************************************/ <br> <br>BOOL BufferInit( BUFFER *pB ) <br>{ <br>    pB-&gt;pBuf = NULL; <br>    pB-&gt;cLen = 0; <br> <br>    return TRUE; <br>} <br> <br> <br>void BufferTerminate( BUFFER *pB ) <br>{ <br>    if ( pB-&gt;pBuf != NULL ) <br>    { <br>        free( pB-&gt;pBuf ); <br>        pB-&gt;pBuf = NULL; <br>        pB-&gt;cLen = 0; <br>    } <br>} <br> <br> <br>PBYTE BufferQueryPtr( BUFFER * pB ) <br>{ <br>    return pB-&gt;pBuf; <br>} <br> <br> <br>BOOL BufferResize( BUFFER *pB, DWORD cNewL ) <br>{ <br>    PBYTE pN; <br>    if ( cNewL &gt; pB-&gt;cLen ) <br>    { <br>        pN = malloc( cNewL ); <br>        if ( pB-&gt;pBuf ) <br>        { <br>            memcpy( pN, pB-&gt;pBuf, pB-&gt;cLen ); <br>            free( pB-&gt;pBuf ); <br>        } <br>        pB-&gt;pBuf = pN; <br>        pB-&gt;cLen = cNewL; <br>    } <br> <br>    return TRUE; <br>} <br> <br> <br>/************************************************************ <br> *    Authentication functions <br> ************************************************************/ <br> <br> <br>BOOL  <br>InitAuthorizationHeader( <br>    ) <br>/*++ <br> <br> Routine Description: <br> <br>    Initialize the authentication package <br> <br> Arguments: <br> <br>    None <br> <br> Return Value: <br> <br>    Returns TRUE is successful; otherwise FALSE is returned. <br> <br>--*/ <br>{ <br>    OSVERSIONINFO   VerInfo; <br>    UCHAR lpszDLL[MAX_PATH]; <br> <br>    // <br>    //  Find out which security DLL to use, depending on  <br>    //  whether we are on NT or Win95 <br>    // <br>    VerInfo.dwOSVersionInfoSize = sizeof (OSVERSIONINFO); <br>    if (!GetVersionEx (&amp;VerInfo))   // If this fails, something has gone wrong <br>    { <br>        return FALSE; <br>    } <br> <br>    if (VerInfo.dwPlatformId == VER_PLATFORM_WIN32_NT) <br>    { <br>        strcpy (lpszDLL, "security.dll" ); <br>    } <br>    else if (VerInfo.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS) <br>    { <br>        strcpy (lpszDLL, "secur32.dll" ); <br>    } <br>    else <br>    { <br>        return FALSE; <br>    } <br> <br>    // <br>    //  Load Security DLL <br>    // <br> <br>    g_hSecLib = LoadLibrary (lpszDLL); <br>    if (g_hSecLib == NULL) <br>    { <br>        return FALSE; <br>    } <br> <br>    // Get all entry points we care about <br> <br>    sfProcs.pFreeCredentialsHandle  <br>            = (FREE_CREDENTIALS_HANDLE_FN) GetProcAddress(  <br>                    g_hSecLib,  <br>                    "FreeCredentialsHandle" ); <br> <br>    sfProcs.pQuerySecurityPackageInfo  <br>            = (QUERY_SECURITY_PACKAGE_INFO_FN) GetProcAddress(  <br>                    g_hSecLib,  <br>                    "QuerySecurityPackageInfoA" ); <br> <br>    sfProcs.pAcquireCredentialsHandle  <br>            = (ACQUIRE_CREDENTIALS_HANDLE_FN) GetProcAddress( <br>                    g_hSecLib,  <br>                    "AcquireCredentialsHandleA" ); <br> <br>    sfProcs.pFreeContextBuffer  <br>            = (FREE_CONTEXT_BUFFER_FN) GetProcAddress(  <br>                    g_hSecLib,  <br>                    "FreeContextBuffer" ); <br> <br>    sfProcs.pInitializeSecurityContext <br>            = (INITIALIZE_SECURITY_CONTEXT_FN) GetProcAddress(  <br>                    g_hSecLib,  <br>                    "InitializeSecurityContextA" ); <br> <br>    sfProcs.pCompleteAuthToken  <br>            = (COMPLETE_AUTH_TOKEN_FN) GetProcAddress(  <br>                    g_hSecLib,  <br>                    "CompleteAuthToken" ); <br> <br>    sfProcs.pEnumerateSecurityPackages  <br>            = (ENUMERATE_SECURITY_PACKAGES_FN) GetProcAddress(  <br>                    g_hSecLib,  <br>                    "EnumerateSecurityPackagesA" ); <br> <br>    if ( sfProcs.pFreeCredentialsHandle == NULL <br>            || sfProcs.pQuerySecurityPackageInfo == NULL <br>            || sfProcs.pAcquireCredentialsHandle == NULL <br>            || sfProcs.pFreeContextBuffer == NULL <br>            || sfProcs.pInitializeSecurityContext == NULL  <br>            || sfProcs.pEnumerateSecurityPackages == NULL ) <br>    { <br>        FreeLibrary( g_hSecLib ); <br>        g_hSecLib = NULL; <br>        return FALSE; <br>    } <br> <br>    g_fAuth = g_fBasic = FALSE; <br>  <br>    return TRUE; <br>} <br> <br> <br>void  <br>TerminateAuthorizationHeader( <br>    ) <br>/*++ <br> <br> Routine Description: <br> <br>    Terminate the authentication package <br> <br> Arguments: <br> <br>    None <br> <br> Return Value: <br> <br>    None <br> <br>--*/ <br>{ <br>    if ( g_fAuth ) <br>    { <br>        AuthTerminate( &amp;g_Auth ); <br>        g_fAuth = FALSE; <br>    } <br> <br>    g_fBasic = FALSE; <br> <br>    if ( g_hSecLib != NULL ) <br>    { <br>        FreeLibrary( g_hSecLib ); <br>        g_hSecLib = NULL; <br>    } <br>} <br> <br> <br>BOOL  <br>IsInAuthorizationSequence( <br>    ) <br>/*++ <br> <br> Routine Description: <br> <br>    Indicates if in authentication sequence <br> <br> Arguments: <br> <br>    None <br> <br> Return Value: <br> <br>    Returns TRUE is successful; otherwise FALSE is returned. <br> <br>--*/ <br>{ <br>    return g_fAuth || g_fBasic; <br>} <br> <br> <br>BOOL  <br>ValidateAuthenticationMethods(  <br>    PSTR pszMet, <br>    PSTR pszPreferedMet ) <br>/*++ <br> <br> Routine Description: <br> <br>    Filter the supplied authentication list for supported <br>    methods ( Basic and all local security packages ) <br> <br> Arguments: <br> <br>    None <br> <br> Return Value: <br> <br>    Returns TRUE if at least one authentication method supported, <br>    otherwise FALSE is returned. <br> <br>--*/ <br>{ <br>    PSecPkgInfo pSec; <br>    ULONG cSec, iS; <br>    BOOL fValid; <br>    PSTR p,t; <br>    SECURITY_STATUS ss; <br> <br> <br>    // access local security packages list <br> <br>    if ( (ss = sfProcs.pEnumerateSecurityPackages( &amp;cSec, &amp;pSec ))  <br>            == STATUS_SUCCESS ) <br>    { <br>        for ( t = p = pszMet ; *p ; ) <br>        { <br>            // Valid methods are "Basic" and all security packages <br> <br>            if ( !_stricmp( p , "Basic" ) ) <br>                fValid = TRUE; <br>            else for ( iS = 0 ; iS &lt; cSec ; ++iS ) <br>                if ( !_stricmp( pSec[iS].Name, p ) ) <br>                    break; <br> <br>            if ( fValid ) <br>            { <br>                if ( t != p ) <br>                    memmove( t, p, strlen(p)+1 ); <br>                p += strlen( p ) + 1; <br>                t += strlen( t ) + 1; <br>            } <br>        } <br>        *t = '\0'; <br>    } <br> <br>    // check for prefered method <br> <br>    if ( pszPreferedMet != NULL ) <br>    { <br>        PSTR pP; <br> <br>        for ( pP = strtok( pszPreferedMet, "," ) ; <br>                pP != NULL ; <br>                pP = strtok( NULL, "," ) ) <br>        { <br>            // scan list of validated methods for the current <br>            // prefered method <br> <br>            for ( p = pszMet ; *p ; ) <br>            { <br>                if ( !_stricmp( pP, p ) ) <br>                { <br>                    memmove( pszMet, p, strlen(p) + 1 ); <br>                    return TRUE; <br>                } <br>                p += strlen( p ) + 1; <br>            } <br>        } <br> <br>        // no method in the prefered method list is supported <br> <br>        return FALSE; <br>    } <br> <br>    // no prefered method list supplied <br> <br>    return *pszMet ? TRUE : FALSE; <br>} <br> <br> <br>BOOL <br>AddAuthorizationHeader( <br>    PSTR pch,        <br>    PSTR pchSchemes, <br>    PSTR pchAuthData, <br>    PSTR pchUserName, <br>    PSTR pchPassword, <br>    BOOL *pfNeedMoreData <br>    ) <br>/*++ <br> <br> Routine Description: <br> <br>    Generates an authentication header to be sent to the server. <br>    An authentication sequence will be initiated if none is in <br>    use and at least one of the authentication scheme specified <br>    in pchSchemes is recognized. <br>    Otherwise the current authentication sequence will proceed. <br> <br> Arguments: <br> <br>    pch                 where to append authentication header <br>    pchSchemes          list of null-delimited authentication methods <br>    pchAuthData         incoming blob from server <br>    pchUserName         user name ( possibly prefixed with domain ) <br>    pchPassword         password <br>    pfNeedMoreData      Out: TRUE if authentication sequence to continue <br> <br> Return Value: <br> <br>    Returns TRUE is successful; otherwise FALSE is returned. <br> <br>--*/ <br>{ <br>    CHAR   achUserAndPass[256]; <br>    BUFFER buff; <br>    BOOL fSt = TRUE; <br>    DWORD cbOut; <br> <br> <br>    BufferInit( &amp;buff ); <br> <br>    while ( *pchSchemes ) <br>    { <br>        if ( !stricmp( pchSchemes, "Basic" )) <br>        { <br>            // if already in authentication sequence, it failed. <br> <br>            if ( g_fBasic ) <br>            { <br>                SetLastError( ERROR_ACCESS_DENIED ); <br>                fSt = FALSE; <br>                break; <br>            } <br> <br>            strcpy( achUserAndPass, pchUserName ); <br>            strcat( achUserAndPass, ":" ); <br>            strcat( achUserAndPass, pchPassword ); <br> <br>            uuencode( (BYTE *) achUserAndPass, <br>                      strlen( achUserAndPass ), <br>                      &amp;buff ); <br>            strcat( pch, "Authorization: " ); <br>            strcat( pch, "Basic " ); <br>            strcat( pch, BufferQueryPtr( &amp;buff )); <br>            strcat( pch, "\r\n"); <br>            g_fBasic = TRUE; <br>            break; <br>        } <br>        else  <br>        { <br>            // SSPI package ( assuming methods list have been validated ) <br> <br>            if ( !g_fAuth ) <br>            { <br>                if ( !AuthInit( &amp;g_Auth ) ) <br>                { <br>                    fSt = FALSE; <br>                    goto ex; <br>                } <br>            } <br>            else if ( pchAuthData == NULL || *pchAuthData == '\0' ) <br>            { <br>                // no blob while in authentication sequence : it failed <br> <br>                SetLastError( ERROR_ACCESS_DENIED ); <br>                fSt = FALSE; <br>                break; <br>            } <br> <br>            if ( !AuthConverse( &amp;g_Auth, <br>                  (void *) pchAuthData, <br>                  0, <br>                  &amp;buff, <br>                  &amp;cbOut, <br>                  pfNeedMoreData, <br>                  pchSchemes, <br>                  pchUserName, <br>                  pchPassword )) <br>            { <br>                fSt = FALSE; <br>                goto ex; <br>            } <br> <br>            strcat( pch, "Authorization: " ); <br>            strcat( pch, pchSchemes ); <br>            strcat( pch, " " ); <br>            strcat( pch, (CHAR *) BufferQueryPtr( &amp;buff ) ); <br>            strcat( pch, "\r\n" ); <br>            break; <br>        } <br> <br>        pchSchemes += strlen(pchSchemes) + 1; <br>    } <br>ex: <br>    BufferTerminate( &amp;buff ); <br> <br>    return fSt; <br>} <br> <br> <br>BOOL  <br>AuthInit(  <br>    AUTH_SEQ *pAS ) <br>/*++ <br> <br> Routine Description: <br> <br>    Initialize a SSP authentication sequence <br> <br> Arguments: <br> <br>    None <br> <br> Return Value: <br> <br>    Returns TRUE is successful; otherwise FALSE is returned. <br> <br>--*/ <br>{ <br>    pAS-&gt;_fNewConversation = TRUE; <br>    pAS-&gt;_fHaveCredHandle = FALSE; <br>    pAS-&gt;_fHaveCtxtHandle = FALSE; <br>    pAS-&gt;_fUUEncodeData = TRUE; <br> <br>    g_fAuth = TRUE; <br> <br>    return TRUE; <br>} <br> <br> <br>void  <br>AuthTerminate(  <br>    AUTH_SEQ *pAS ) <br>/*++ <br> <br> Routine Description: <br> <br>    Terminate a SSP authentication sequence <br> <br> Arguments: <br> <br>    None <br> <br> Return Value: <br> <br>    None <br> <br>--*/ <br>{ <br>    if ( pAS-&gt;_fHaveCredHandle ) <br>        sfProcs.pFreeCredentialsHandle( &amp;pAS-&gt;_hcred ); <br> <br>    pAS-&gt;_fHaveCredHandle = FALSE; <br>    pAS-&gt;_fHaveCtxtHandle = FALSE; <br>} <br> <br> <br>BOOL  <br>AuthConverse( <br>    AUTH_SEQ *pAS, <br>    VOID   * pBuffIn, <br>    DWORD    cbBuffIn, <br>    BUFFER * pbuffOut, <br>    DWORD  * pcbBuffOut, <br>    BOOL   * pfNeedMoreData, <br>    CHAR   * pszPackage, <br>    CHAR   * pszUser, <br>    CHAR   * pszPassword <br>    ) <br>/*++ <br> <br>Routine Description: <br> <br>    Initiates or continues a previously initiated authentication conversation <br> <br>    Client calls this first to get the negotiation message which <br>    it then sends to the server.  The server calls this with the <br>    client result and sends back the result.  The conversation <br>    continues until *pfNeedMoreData is FALSE. <br> <br>    On the first call, pszPackage must point to the zero terminated <br>    authentication package name to be used and pszUser and pszPassword <br>    should point to the user name and password to authenticated with <br>    on the client side (server side will always be NULL). <br> <br>Arguments: <br> <br>    pBuffIn - Points to SSP message received from the <br>        client.  If UUENCODE is used, then this must point to a <br>        zero terminated uuencoded string (except for the first call). <br>    cbBuffIn - Number of bytes in pBuffIn or zero if pBuffIn points to a <br>        zero terminated, uuencoded string. <br>    pbuffOut - If *pfDone is not set to TRUE, this buffer contains the data <br>        that should be sent to the other side.  If this is zero, then no <br>        data needs to be sent. <br>    pcbBuffOut - Number of bytes in pbuffOut <br>    pfNeedMoreData - Set to TRUE while this side of the conversation is <br>        expecting more data from the remote side. <br>    pszPackage - On the first call points to a zero terminate string indicating <br>        the security package to use <br>    pszUser - Specifies user or domain\user the first time the client calls <br>        this method (client side only) <br>    pszPassword - Specifies the password for pszUser the first time the <br>        client calls this method (client side only) <br> <br>Return Value: <br> <br>    TRUE if successful, FALSE otherwise (call GetLastError).  Access is <br>    denied if FALSE is returned and GetLastError is ERROR_ACCESS_DENIED. <br> <br>--*/ <br>{ <br>    SECURITY_STATUS       ss; <br>    TimeStamp             Lifetime; <br>    SecBufferDesc         OutBuffDesc; <br>    SecBuffer             OutSecBuff; <br>    SecBufferDesc         InBuffDesc; <br>    SecBuffer             InSecBuff; <br>    ULONG                 ContextAttributes; <br>    BUFFER                buffData; <br>    BUFFER                buff; <br>    BOOL                  fSt; <br>    BOOL                  fReply; <br> <br>    BufferInit( &amp;buffData ); <br>    BufferInit( &amp;buff ); <br> <br>    // <br>    //  Decode the data if there's something to decode <br>    // <br> <br>    if ( pAS-&gt;_fUUEncodeData &amp;&amp; pBuffIn ) <br>    { <br>        if ( !uudecode( (CHAR *) pBuffIn, <br>                        &amp;buffData, <br>                        &amp;cbBuffIn )) <br>        { <br>            fSt = FALSE; <br>            goto ex; <br>        } <br> <br>        pBuffIn = BufferQueryPtr( &amp;buffData ); <br>    } <br> <br>    // <br>    //  If this is a new conversation, then we need to get the credential <br>    //  handle and find out the maximum token size <br>    // <br> <br>    if ( pAS-&gt;_fNewConversation ) <br>    { <br>        SecPkgInfo *              pspkg; <br>        SEC_WINNT_AUTH_IDENTITY   AuthIdentity; <br>        SEC_WINNT_AUTH_IDENTITY * pAuthIdentity; <br>        CHAR *                    pszDomain = NULL; <br>        CHAR                      szDomainAndUser[DNLEN+UNLEN+2]; <br> <br> <br>        // <br>        //  fill out the authentication information <br>        // <br> <br>        if ( ((pszUser != NULL) || <br>              (pszPassword != NULL)) ) <br>        { <br>            pAuthIdentity = &amp;AuthIdentity; <br> <br>            // <br>            //  Break out the domain from the username if one was specified <br>            // <br> <br>            if ( pszUser != NULL ) <br>            { <br>                strcpy( szDomainAndUser, pszUser ); <br>                if ( !CrackUserAndDomain( szDomainAndUser, <br>                                          &amp;pszUser, <br>                                          &amp;pszDomain )) <br>                { <br>                    return FALSE; <br>                } <br>            } <br> <br>            memset( &amp;AuthIdentity, <br>                    0, <br>                    sizeof( AuthIdentity )); <br> <br>            if ( pszUser != NULL ) <br>            { <br>                AuthIdentity.User       = (unsigned char *) pszUser; <br>                AuthIdentity.UserLength = strlen( pszUser ); <br>            } <br> <br>            if ( pszPassword != NULL ) <br>            { <br>                AuthIdentity.Password       = (unsigned char *) pszPassword; <br>                AuthIdentity.PasswordLength = strlen( pszPassword ); <br>            } <br> <br>            if ( pszDomain != NULL ) <br>            { <br>                AuthIdentity.Domain       = (unsigned char *) pszDomain; <br>                AuthIdentity.DomainLength = strlen( pszDomain ); <br>            } <br> <br>            AuthIdentity.Flags = SEC_WINNT_AUTH_IDENTITY_ANSI; <br>        } <br>        else <br>        { <br>            pAuthIdentity = NULL; <br>        } <br> <br>        ss = sfProcs.pAcquireCredentialsHandle( NULL,    // New principal <br>                                       pszPackage,       // Package name <br>                                       SECPKG_CRED_OUTBOUND, <br>                                       NULL,             // Logon ID <br>                                       pAuthIdentity,    // Auth Data <br>                                       NULL,             // Get key func <br>                                       NULL,             // Get key arg <br>                                       &amp;pAS-&gt;_hcred, <br>                                       &amp;Lifetime ); <br> <br>        // <br>        //  Need to determine the max token size for this package <br>        // <br> <br>        if ( ss == STATUS_SUCCESS ) <br>        { <br>            pAS-&gt;_fHaveCredHandle = TRUE; <br>            ss = sfProcs.pQuerySecurityPackageInfo(  <br>                        (char *) pszPackage, <br>                        &amp;pspkg ); <br>        } <br> <br>        if ( ss != STATUS_SUCCESS ) <br>        { <br>            SetLastError( ss ); <br>            return FALSE; <br>        } <br> <br>        pAS-&gt;_cbMaxToken = pspkg-&gt;cbMaxToken; <br> <br>        sfProcs.pFreeContextBuffer( pspkg ); <br> <br>    } <br> <br>    // <br>    //  Prepare our output buffer.  We use a temporary buffer because <br>    //  the real output buffer will most likely need to be uuencoded <br>    // <br> <br>    if ( !BufferResize( &amp;buff, pAS-&gt;_cbMaxToken )) <br>    { <br>        fSt = FALSE; <br>        goto ex; <br>    } <br> <br>    OutBuffDesc.ulVersion = 0; <br>    OutBuffDesc.cBuffers  = 1; <br>    OutBuffDesc.pBuffers  = &amp;OutSecBuff; <br> <br>    OutSecBuff.cbBuffer   = pAS-&gt;_cbMaxToken; <br>    OutSecBuff.BufferType = SECBUFFER_TOKEN; <br>    OutSecBuff.pvBuffer   = BufferQueryPtr( &amp;buff ); <br> <br>    // <br>    //  Prepare our Input buffer - Note the server is expecting the client's <br>    //  negotiation packet on the first call <br>    // <br> <br>    if ( pBuffIn ) <br>    { <br>        InBuffDesc.ulVersion = 0; <br>        InBuffDesc.cBuffers  = 1; <br>        InBuffDesc.pBuffers  = &amp;InSecBuff; <br> <br>        InSecBuff.cbBuffer   = cbBuffIn; <br>        InSecBuff.BufferType = SECBUFFER_TOKEN; <br>        InSecBuff.pvBuffer   = pBuffIn; <br>    } <br> <br>    { <br>        // <br>        //  will return success when its done but we still <br>        //  need to send the out buffer if there are bytes to send <br>        // <br> <br>        ss = sfProcs.pInitializeSecurityContext(  <br>                                        &amp;pAS-&gt;_hcred, <br>                                        pAS-&gt;_fNewConversation ? NULL : <br>                                                &amp;pAS-&gt;_hctxt, <br>                                        TOKEN_SOURCE_NAME, <br>                                        0, <br>                                        0, <br>                                        SECURITY_NATIVE_DREP, <br>                                        pAS-&gt;_fNewConversation ? NULL : <br>                                                &amp;InBuffDesc, <br>                                        0, <br>                                        &amp;pAS-&gt;_hctxt, <br>                                        &amp;OutBuffDesc, <br>                                        &amp;ContextAttributes, <br>                                        &amp;Lifetime ); <br>    } <br> <br>    if ( !SEC_SUCCESS( ss ) ) <br>    { <br>        if ( ss == SEC_E_LOGON_DENIED ) <br>            ss = ERROR_LOGON_FAILURE; <br> <br>        SetLastError( ss ); <br>        fSt = FALSE; <br>        goto ex; <br>    } <br> <br>    pAS-&gt;_fHaveCtxtHandle = TRUE; <br> <br>    // <br>    //  Now we just need to complete the token (if requested) and prepare <br>    //  it for shipping to the other side if needed <br>    // <br> <br>    fReply = !!OutSecBuff.cbBuffer; <br> <br>    if ( (ss == SEC_I_COMPLETE_NEEDED) || <br>         (ss == SEC_I_COMPLETE_AND_CONTINUE) ) <br>    { <br>        if ( sfProcs.pCompleteAuthToken != NULL ) <br>        { <br>            ss = sfProcs.pCompleteAuthToken( &amp;pAS-&gt;_hctxt, <br>                                    &amp;OutBuffDesc ); <br> <br>            if ( !SEC_SUCCESS( ss )) <br>            { <br>                fSt = FALSE; <br>                goto ex; <br>            } <br>        } <br>        else <br>        { <br>            // if not supported <br> <br>            fSt = FALSE; <br>            goto ex; <br>        } <br>    } <br> <br>    // <br>    //  Format or copy to the output buffer if we need to reply <br>    // <br> <br>    if ( fReply ) <br>    { <br>        if ( pAS-&gt;_fUUEncodeData ) <br>        { <br>            if ( !uuencode( (BYTE *) OutSecBuff.pvBuffer, <br>                            OutSecBuff.cbBuffer, <br>                            pbuffOut )) <br>            { <br>                fSt = FALSE; <br>                goto ex; <br>            } <br> <br>            *pcbBuffOut = strlen( (CHAR *) BufferQueryPtr(pbuffOut) ); <br>        } <br>        else <br>        { <br>            if ( !BufferResize( pbuffOut, OutSecBuff.cbBuffer )) <br>            { <br>                fSt = FALSE; <br>                goto ex; <br>            } <br> <br>            memcpy( BufferQueryPtr(pbuffOut), <br>                    OutSecBuff.pvBuffer, <br>                    OutSecBuff.cbBuffer ); <br> <br>            *pcbBuffOut = OutSecBuff.cbBuffer; <br>        } <br>    } <br> <br>    if ( pAS-&gt;_fNewConversation ) <br>        pAS-&gt;_fNewConversation = FALSE; <br> <br>    *pfNeedMoreData = ((ss == SEC_I_CONTINUE_NEEDED) || <br>                       (ss == SEC_I_COMPLETE_AND_CONTINUE)); <br> <br>    fSt = TRUE; <br> <br>ex: <br>    BufferTerminate( &amp;buffData ); <br>    BufferTerminate( &amp;buff ); <br> <br>    return fSt; <br>} <br> <br> <br>BOOL CrackUserAndDomain( <br>    CHAR *   pszDomainAndUser, <br>    CHAR * * ppszUser, <br>    CHAR * * ppszDomain <br>    ) <br>/*++ <br> <br>Routine Description: <br> <br>    Given a user name potentially in the form domain\user, zero terminates <br>    the domain name and returns pointers to the domain name and the user name <br> <br>Arguments: <br> <br>    pszDomainAndUser - Pointer to user name or domain and user name <br>    ppszUser - Receives pointer to user portion of name <br>    ppszDomain - Receives pointer to domain portion of name <br> <br>Return Value: <br> <br>    TRUE if successful, FALSE otherwise (call GetLastError) <br> <br>--*/ <br>{ <br>    static CHAR szDefaultDomain[MAX_COMPUTERNAME_LENGTH+1]; <br>    DWORD cbN; <br> <br>    // <br>    //  Crack the name into domain/user components. <br>    // <br> <br>    *ppszDomain = pszDomainAndUser; <br>    *ppszUser   = strpbrk( pszDomainAndUser, "/\\" ); <br> <br>    if( *ppszUser == NULL ) <br>    { <br>        // <br>        //  No domain name specified, just the username so we assume the <br>        //  user is on the local machine <br>        // <br> <br>        if ( !*szDefaultDomain ) <br>        { <br>            cbN = sizeof(szDefaultDomain); <br>            GetComputerName( szDefaultDomain, &amp;cbN ); <br>        } <br> <br>        *ppszDomain = szDefaultDomain; <br>        *ppszUser   = pszDomainAndUser; <br>    } <br>    else <br>    { <br>        // <br>        //  Both domain &amp; user specified, skip delimiter. <br>        // <br> <br>        **ppszUser = '\0'; <br>        (*ppszUser)++; <br> <br>        if( ( **ppszUser == '\0' ) || <br>            ( **ppszUser == '\\' ) || <br>            ( **ppszUser == '/' ) ) <br>        { <br>            // <br>            //  Name is of one of the following (invalid) forms: <br>            // <br>            //      "domain\" <br>            //      "domain\\..." <br>            //      "domain/..." <br>            // <br> <br>            SetLastError( ERROR_INVALID_PARAMETER ); <br>            return FALSE; <br>        } <br>    } <br> <br>    return TRUE; <br>} <br> <br> <br>/************************************************************ <br> *    uuencode/decode functions <br> ************************************************************/ <br> <br>// <br>//  Taken from NCSA HTTP and wwwlib. <br>// <br>//  NOTE: These conform to RFC1113, which is slightly different then the Unix <br>//        uuencode and uudecode! <br>// <br> <br>const int pr2six[256]={ <br>    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64, <br>    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,62,64,64,64,63, <br>    52,53,54,55,56,57,58,59,60,61,64,64,64,64,64,64,64,0,1,2,3,4,5,6,7,8,9, <br>    10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,64,64,64,64,64,64,26,27, <br>    28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51, <br>    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64, <br>    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64, <br>    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64, <br>    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64, <br>    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64, <br>    64,64,64,64,64,64,64,64,64,64,64,64,64 <br>}; <br> <br>char six2pr[64] = { <br>    'A','B','C','D','E','F','G','H','I','J','K','L','M', <br>    'N','O','P','Q','R','S','T','U','V','W','X','Y','Z', <br>    'a','b','c','d','e','f','g','h','i','j','k','l','m', <br>    'n','o','p','q','r','s','t','u','v','w','x','y','z', <br>    '0','1','2','3','4','5','6','7','8','9','+','/' <br>}; <br> <br> <br>BOOL  <br>uudecode( <br>    char   * bufcoded, <br>    BUFFER * pbuffdecoded, <br>    DWORD  * pcbDecoded ) <br>/*++ <br> <br> Routine Description: <br> <br>    uudecode a string of data <br> <br> Arguments: <br> <br>    bufcoded            pointer to uuencoded data <br>    pbuffdecoded        pointer to output BUFFER structure <br>    pcbDecoded          number of decode bytes <br> <br> Return Value: <br> <br>    Returns TRUE is successful; otherwise FALSE is returned. <br> <br>--*/ <br>{ <br>    int nbytesdecoded; <br>    char *bufin = bufcoded; <br>    unsigned char *bufout; <br>    int nprbytes; <br> <br>    /* Strip leading whitespace. */ <br> <br>    while(*bufcoded==' ' || *bufcoded == '\t') bufcoded++; <br> <br>    /* Figure out how many characters are in the input buffer. <br>     * If this would decode into more bytes than would fit into <br>     * the output buffer, adjust the number of input bytes downwards. <br>     */ <br>    bufin = bufcoded; <br>    while(pr2six[*(bufin++)] &lt;= 63); <br>    nprbytes = bufin - bufcoded - 1; <br>    nbytesdecoded = ((nprbytes+3)/4) * 3; <br> <br>    if ( !BufferResize( pbuffdecoded, nbytesdecoded + 4 )) <br>        return FALSE; <br> <br>    if ( pcbDecoded ) <br>        *pcbDecoded = nbytesdecoded; <br> <br>    bufout = (unsigned char *) BufferQueryPtr(pbuffdecoded); <br> <br>    bufin = bufcoded; <br> <br>    while (nprbytes &gt; 0) { <br>        *(bufout++) = </code></pre>
<p>
</p>
<pre><code>(unsigned char) (pr2six[*bufin] &lt;&lt; 2 | pr2six[bufin[1]] &gt;&gt; 4); <br>        *(bufout++) = <br>            (unsigned char) (pr2six[bufin[1]] &lt;&lt; 4 | pr2six[bufin[2]] &gt;&gt; 2); <br>        *(bufout++) = <br>            (unsigned char) (pr2six[bufin[2]] &lt;&lt; 6 | pr2six[bufin[3]]); <br>        bufin += 4; <br>        nprbytes -= 4; <br>    } <br> <br>    if(nprbytes &amp; 03) { <br>        if(pr2six[bufin[-2]] &gt; 63) <br>            nbytesdecoded -= 2; <br>        else <br>            nbytesdecoded -= 1; <br>    } <br> <br>    ((CHAR *)BufferQueryPtr(pbuffdecoded))[nbytesdecoded] = '\0'; <br> <br>    return TRUE; <br>} <br> <br> <br>BOOL  <br>uuencode(  <br>    BYTE *   bufin, <br>    DWORD    nbytes, <br>    BUFFER * pbuffEncoded ) <br>/*++ <br> <br> Routine Description: <br> <br>    uuencode a string of data <br> <br> Arguments: <br> <br>    bufin           pointer to data to encode <br>    nbytes          number of bytes to encode <br>    pbuffEncoded    pointer to output BUFFER structure <br> <br> Return Value: <br> <br>    Returns TRUE is successful; otherwise FALSE is returned. <br> <br>--*/ <br>{ <br>   unsigned char *outptr; <br>   unsigned int i; <br> <br>   // <br>   //  Resize the buffer to 133% of the incoming data <br>   // <br> <br>   if ( !BufferResize( pbuffEncoded, nbytes + ((nbytes + 3) / 3) + 4)) <br>        return FALSE; <br> <br>   outptr = (unsigned char *) BufferQueryPtr(pbuffEncoded); <br> <br>   for (i=0; i&lt;nbytes; i += 3) { <br>      *(outptr++) = six2pr[*bufin &gt;&gt; 2];            /* c1 */ <br>      *(outptr++) = six2pr[((*bufin &lt;&lt; 4) &amp; 060) | ((bufin[1] &gt;&gt; 4) &amp; 017)]; /*c2*/ <br>      *(outptr++) = six2pr[((bufin[1] &lt;&lt; 2) &amp; 074) | ((bufin[2] &gt;&gt; 6) &amp; 03)];/*c3*/ <br>      *(outptr++) = six2pr[bufin[2] &amp; 077];         /* c4 */ <br> <br>      bufin += 3; <br>   } <br> <br>   /* If nbytes was not a multiple of 3, then we have encoded too <br>    * many characters.  Adjust appropriately. <br>    */ <br>   if(i == nbytes+1) { <br>      /* There were only 2 bytes in that last group */ <br>      outptr[-1] = '='; <br>   } else if(i == nbytes+2) { <br>      /* There was only 1 byte in that last group */ <br>      outptr[-1] = '='; <br>      outptr[-2] = '='; <br>   } <br> <br>   *outptr = '\0'; <br> <br>   return TRUE; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
