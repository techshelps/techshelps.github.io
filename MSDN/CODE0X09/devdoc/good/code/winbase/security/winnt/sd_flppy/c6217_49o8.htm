<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>FLOPLOCK.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6218"></a>FLOPLOCK.C</h2>
<pre><code>/****************************************************************************\ <br>*  INCLUDES, DEFINES <br>\****************************************************************************/ <br>#define STRICT <br>#include &lt;windows.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;stdlib.h&gt; <br> <br>#define PERR(api) printf("\n%s: Error %d from %s on line %d",  \ <br>    __FILE__, GetLastError(), api, __LINE__); <br>#define PMSG(msg) printf("\n%s line %d: %s",  \ <br>    __FILE__, __LINE__, msg); <br> <br>// this event is signalled when the <br>//  worker thread ends <br>// <br>HANDLE                  hServDoneEvent = NULL; <br>SERVICE_STATUS          ssStatus;       // current status of the service <br> <br>SERVICE_STATUS_HANDLE   sshStatusHandle; <br>DWORD                   dwGlobalErr; <br>DWORD                   TID = 0; <br>HANDLE                  threadHandle = NULL; <br>HANDLE                  pipeHandle; <br> <br> <br>/****************************************************************************\ <br>* FUNCTION PROTOTYPES <br>\****************************************************************************/ <br> <br>VOID    WINAPI service_main(DWORD dwArgc, LPTSTR *lpszArgv); <br>VOID    WINAPI service_ctrl(DWORD dwCtrlCode); <br>BOOL    ReportStatusToSCMgr(DWORD dwCurrentState, <br>                            DWORD dwWin32ExitCode, <br>                            DWORD dwCheckPoint, <br>                            DWORD dwWaitHint); <br>VOID    die(char *reason); <br>VOID    worker_thread(VOID *notUsed); <br>VOID    StopSimpleService(LPTSTR lpszMsg); <br>BOOL    WriteSD_ToA_File(PSECURITY_DESCRIPTOR psdAbsoluteSD, LPTSTR lpszFileName); <br> <br> <br>/****************************************************************************\ <br>* GLOBAL VARIABLES AND TYPEDEFS <br>\****************************************************************************/ <br> <br>#define                               SZ_SD_BUF   100 <br>#define                               SZ_SID_BUF   75 <br>#define                               SZ_ACL_BUF  150 <br> <br>UCHAR                ucAbsSDBuf      [SZ_SD_BUF]  = ""; <br>UCHAR                ucEvrSDBuf      [SZ_SD_BUF]  = ""; <br>UCHAR                ucSIDBuf        [SZ_SID_BUF] = ""; <br>UCHAR                ucPwrUsrsSIDBuf [SZ_SID_BUF] = ""; <br>UCHAR                ucACLBuf        [SZ_ACL_BUF] = ""; <br> <br>DWORD                dwSID          = SZ_SID_BUF; <br>DWORD                dwDACL         = SZ_ACL_BUF; <br>BOOL                 bFloppiesAreLocked; <br> <br>PSECURITY_DESCRIPTOR psdAbsoluteSD      = (PSECURITY_DESCRIPTOR)&amp;ucAbsSDBuf; <br>PSECURITY_DESCRIPTOR psdEveryoneSD      = (PSECURITY_DESCRIPTOR)&amp;ucEvrSDBuf; <br>PSID                 psidAdministrators = (PSID)&amp;ucSIDBuf; <br>PSID                 psidPowerUsers     = (PSID)&amp;ucPwrUsrsSIDBuf; <br>PACL                 pNewDACL           = (PACL)&amp;ucACLBuf; <br> <br> <br> <br>//  main() -- <br>//      all main does is call StartServiceCtrlDispatcher <br>//      to register the main service thread.  When the <br>//      API returns, the service has stopped, so exit. <br>// <br>int <br>main() <br>{ <br> <br>    SERVICE_TABLE_ENTRY dispatchTable[] = { <br>        { TEXT("SimpleService"), (LPSERVICE_MAIN_FUNCTION)service_main }, <br>        { NULL, NULL } <br>    }; <br> <br>  // check if Win32s, if so, display notice and terminate <br>        if( GetVersion() &amp; 0x80000000 ) <br>        { <br>          MessageBox( NULL, <br>             "This application cannot run on Windows 3.1 or Windows 95.\n" <br>             "This application will now terminate.", <br>             "SD_FLPPY", <br>             MB_OK | MB_ICONSTOP | MB_SETFOREGROUND ); <br>          return( 1 ); <br>        } <br> <br>    #define FILE_TO_REDIRECT_STDOUT_TO "c:\\floplock.out" <br>//  freopen(FILE_TO_REDIRECT_STDOUT_TO,"w+",stdout); <br> <br>    if (!StartServiceCtrlDispatcher(dispatchTable)) { <br>        StopSimpleService("StartServiceCtrlDispatcher failed."); <br>    } <br>} <br> <br> <br> <br>//  service_main() -- <br>//      this function takes care of actually starting the service, <br>//      informing the service controller at each step along the way. <br>//      After launching the worker thread, it waits on the event <br>//      that the worker thread will signal at its termination. <br>// <br>VOID WINAPI <br>service_main(DWORD dwArgc, LPTSTR *lpszArgv) <br>{ <br>    DWORD                   dwWait; <br>    SECURITY_ATTRIBUTES     sa; <br> <br>    // register our service control handler: <br>    // <br>    sshStatusHandle = RegisterServiceCtrlHandler( <br>                                    TEXT("SimpleService"), <br>                                    service_ctrl); <br> <br>    if (!sshStatusHandle) <br>        goto cleanup; <br> <br>    // SERVICE_STATUS members that don't change in example <br>    // <br>    ssStatus.dwServiceType = SERVICE_WIN32_OWN_PROCESS; <br>    ssStatus.dwServiceSpecificExitCode = 0; <br> <br> <br>    // report the status to Service Control Manager. <br>    // <br>    if (!ReportStatusToSCMgr( <br>        SERVICE_START_PENDING, // service state <br>        NO_ERROR,              // exit code <br>        1,                     // checkpoint <br>        3000))                 // wait hint <br>        goto cleanup; <br> <br>    // create the event object. The control handler function signals <br>    // this event when it receives the "stop" control code. <br>    // <br>    hServDoneEvent = CreateEvent( <br>        NULL,    // no security attributes <br>        TRUE,    // manual reset event <br>        FALSE,   // not-signalled <br>        NULL);   // no name <br> <br>    if (hServDoneEvent == (HANDLE)NULL) <br>        goto cleanup; <br> <br>    // report the status to the service control manager. <br>    // <br>    if (!ReportStatusToSCMgr( <br>        SERVICE_START_PENDING, // service state <br>        NO_ERROR,              // exit code <br>        2,                     // checkpoint <br>        3000))                 // wait hint <br>        goto cleanup; <br> <br>    // Create a security descriptor that allows only local Administrators <br>    //   to do anything with the pipe.  Since Domain administrators are <br>    //   normally also local Administrators, this will serve most needs <br> <br>    /************************************************************************\ <br>    * <br>    * Build SIDs of local Administrators and Power Users.  Note that the Power <br>    *   Users group is defined on Windows NT machines, but not on Advanced <br>    *   Server machines.  This means that we will on Advanced Server machines <br>    *   have a DACL that has an ACE (for Power Users) that will never be used <br>    * <br>    \************************************************************************/ <br> <br>    { <br>      SID_IDENTIFIER_AUTHORITY siaNtAuthority = SECURITY_NT_AUTHORITY; <br> <br>      InitializeSid(        psidAdministrators, &amp;siaNtAuthority, 2 ); <br>      InitializeSid(        psidPowerUsers,     &amp;siaNtAuthority, 2 ); <br> <br>      *(GetSidSubAuthority( psidAdministrators, 0 )) = SECURITY_BUILTIN_DOMAIN_RID; <br>      *(GetSidSubAuthority( psidPowerUsers,     0 )) = SECURITY_BUILTIN_DOMAIN_RID; <br> <br>      *(GetSidSubAuthority( psidAdministrators, 1 )) = DOMAIN_ALIAS_RID_ADMINS; <br>      *(GetSidSubAuthority( psidPowerUsers,     1 )) = DOMAIN_ALIAS_RID_POWER_USERS; <br>    } <br> <br> <br>    /************************************************************************\ <br>    * <br>    * Initialize new DACL <br>    * <br>    \************************************************************************/ <br> <br>    if (!InitializeAcl(pNewDACL, <br>                       dwDACL, <br>                       ACL_REVISION)) <br>    { StopSimpleService("InitializeAcl"); <br>    } <br> <br>    /************************************************************************\ <br>    * <br>    * Allow All access for local Administrators only <br>    * <br>    \************************************************************************/ <br> <br>    if (!AddAccessAllowedAce(pNewDACL, <br>                             ACL_REVISION, <br>                             FILE_ALL_ACCESS, <br>                             psidAdministrators)) <br>    { StopSimpleService("AddAccessAllowedAce"); <br>    } <br> <br>    /************************************************************************\ <br>    * <br>    * If we unlock the floppies when the service stops, then for the sake of <br>    *   consistency, we have to also allow Power Users on the Admin-only DACL, <br>    *   since Power Users can stop services.  It would be inconsistent to try <br>    *   to lock Power Users away from their floppies if Power Users could get <br>    *   to the floppies simply by stopping the service <br>    * <br>    * It's still OK to use the same DACL for the pipe as for the floppies, <br>    *   that is, it's OK to let Power Users on the DACL for the pipe too.  The <br>    *   reason is that it is not generally (and certainly not by default) the <br>    *   case that an account is a member of Power Users on more than their own <br>    *   machines.  So, putting Power Users on the pipe let's Power Users admin <br>    *   the floppies via the pipe only on the machines on which they are <br>    *   actually Power Users, and again, on those machines they can stop the <br>    *   floppy-locking service as well <br>    * <br>    \************************************************************************/ <br> <br>    #define UNLOCK_AT_SERVICE_STOP (0==0) <br>    if     (UNLOCK_AT_SERVICE_STOP) <br>    { if (!AddAccessAllowedAce(pNewDACL, <br>                               ACL_REVISION, <br>                               FILE_ALL_ACCESS, <br>                               psidPowerUsers)) <br>      { StopSimpleService("AddAccessAllowedAce"); <br>      } <br>    } <br> <br>    /************************************************************************\ <br>    * <br>    * Build SD in absolute format - first the Admins-only then the Everyone SD <br>    * <br>    \************************************************************************/ <br> <br>    if (!InitializeSecurityDescriptor(psdAbsoluteSD, <br>                                      SECURITY_DESCRIPTOR_REVISION)) <br>    { StopSimpleService("InitializeSecurityDescriptor"); <br>    } <br> <br>    if (!InitializeSecurityDescriptor(psdEveryoneSD, <br>                                      SECURITY_DESCRIPTOR_REVISION)) <br>    { StopSimpleService("InitializeSecurityDescriptor"); <br>    } <br> <br>    /************************************************************************\ <br>    * <br>    * Set DACL into SD - first the Admins-only then the Everyone SD <br>    * <br>    \************************************************************************/ <br> <br>    if (!SetSecurityDescriptorDacl(psdAbsoluteSD, <br>                                   TRUE,      // fDaclPresent flag <br>                                   pNewDACL, <br>                                   FALSE))    // not a default DACL <br>    { StopSimpleService("SetSecurityDescriptorDacl"); <br>    } <br> <br>    if (!SetSecurityDescriptorDacl(psdEveryoneSD, <br>                                   TRUE,      // fDaclPresent flag <br>                                   (PACL)NULL, <br>                                   FALSE))    // not a default DACL <br>    { StopSimpleService("SetSecurityDescriptorDacl"); <br>    } <br> <br>    /************************************************************************\ <br>    * <br>    * Check to see that SD is valid before attempting to write it to the file <br>    * <br>    \************************************************************************/ <br> <br>    if (!IsValidSecurityDescriptor(psdAbsoluteSD)) <br>    { StopSimpleService("IsValidSecurityDescriptor"); <br>    } <br> <br>    sa.nLength = sizeof(sa); <br>    sa.lpSecurityDescriptor = psdAbsoluteSD; <br>    sa.bInheritHandle = TRUE;  // why not... we spawn no processes <br> <br>    // open our named pipe... <br>    // <br>    pipeHandle = CreateNamedPipe( <br>                    "\\\\.\\pipe\\sd_flppy",  // name of pipe <br>                    PIPE_ACCESS_DUPLEX,     // pipe open mode <br>                    PIPE_TYPE_MESSAGE | <br>                    PIPE_READMODE_MESSAGE | <br>                    PIPE_WAIT,              // pipe IO type <br>                    1,                      // number of instances <br>                    0,                      // size of outbuf (0 == allocate as necessary) <br>                    0,                      // size of inbuf <br>                    1000,                   // default time-out value <br>                    &amp;sa);                   // security attributes <br> <br>    if (!pipeHandle) { <br>        StopSimpleService("CreateNamedPipe"); <br>        return; <br>    } <br> <br>    // Set the same DACL onto the floppies <br>    // <br> <br>    /************************************************************************\ <br>    * <br>    * Write SD to file system - first for A: then B: <br>    * <br>    \************************************************************************/ <br> <br>    if (!WriteSD_ToA_File(psdAbsoluteSD,"\\\\.\\A:")) <br>    { StopSimpleService("Write of DACL to A: failed"); <br>    } <br> <br>    if (!WriteSD_ToA_File(psdAbsoluteSD,"\\\\.\\B:")) <br>    { StopSimpleService("Write of DACL to B: failed"); <br>    } <br> <br>    bFloppiesAreLocked = TRUE; <br> <br>    /************************************************************************\ <br>    * <br>    * only works for CDROM drives if you revoke the SeChangeNotify privilege <br>    * from Everyone in user manager <br>    * <br>    \************************************************************************/ <br>  /* <br>    if (!WriteSD_ToA_File(psdAbsoluteSD,"\\\\.\\E:")) <br>    { StopSimpleService("Write of DACL to E: failed"); <br>    } <br>  */ <br>    /************************************************************************\ <br>    * <br>    * Works for COM ports as well - commented out as this samples is floppy only <br>    * <br>    \************************************************************************/ <br>  /* <br>    if (!WriteSD_ToA_File(psdAbsoluteSD,"COM1:")) <br>    { StopSimpleService("Write of DACL to COM1: failed"); <br>    } <br>  */ <br> <br>    // start the thread that performs the work of the service. <br>    // <br>    threadHandle = CreateThread( <br>                    NULL,       // security attributes <br>                    0,          // stack size (0 means inherit parent's stack size) <br>                    (LPTHREAD_START_ROUTINE)worker_thread, <br>                    NULL,       // argument to thread <br>                    0,          // thread creation flags <br>                    &amp;TID);      // pointer to thread ID <br> <br>    if (!threadHandle) <br>        goto cleanup; <br> <br>    // report the status to the service control manager. <br>    // <br>    if (!ReportStatusToSCMgr( <br>        SERVICE_RUNNING, // service state <br>        NO_ERROR,        // exit code <br>        0,               // checkpoint <br>        0))              // wait hint <br>        goto cleanup; <br> <br>    // wait indefinitely until hServDoneEvent is signaled. <br>    // <br>    dwWait = WaitForSingleObject( <br>        hServDoneEvent,  // event object <br>        INFINITE);       // wait indefinitely <br> <br>cleanup: <br> <br>    if (hServDoneEvent != NULL) <br>        CloseHandle(hServDoneEvent); <br> <br> <br>    // try to report the stopped status to the service control manager. <br>    // <br>    if (sshStatusHandle != 0) <br>        (VOID)ReportStatusToSCMgr( <br>                            SERVICE_STOPPED, <br>                            dwGlobalErr, <br>                            0, <br>                            0); <br> <br>    // When SERVICE MAIN FUNCTION returns in a single service <br>    // process, the StartServiceCtrlDispatcher function in <br>    // the main thread returns, terminating the process. <br>    // <br>    return; <br>} <br> <br> <br> <br>//  service_ctrl() -- <br>//      this function is called by the Service Controller whenever <br>//      someone calls ControlService in reference to our service. <br>// <br>VOID WINAPI <br>service_ctrl(DWORD dwCtrlCode) <br>{ <br>    DWORD  dwState = SERVICE_RUNNING; <br> <br>    // Handle the requested control code. <br>    // <br>    switch(dwCtrlCode) { <br> <br>        // Pause the service if it is running. <br>        // <br>        case SERVICE_CONTROL_PAUSE: <br> <br>            if (ssStatus.dwCurrentState == SERVICE_RUNNING) { <br>                SuspendThread(threadHandle); <br>                dwState = SERVICE_PAUSED; <br>            } <br>            break; <br> <br>        // Resume the paused service. <br>        // <br>        case SERVICE_CONTROL_CONTINUE: <br> <br>            if (ssStatus.dwCurrentState == SERVICE_PAUSED) { <br>                ResumeThread(threadHandle); <br>                dwState = SERVICE_RUNNING; <br>            } <br>            break; <br> <br>        // Stop the service. <br>        // <br>        case SERVICE_CONTROL_STOP: <br> <br>            dwState = SERVICE_STOP_PENDING; <br> <br>            // Report the status, specifying the checkpoint and waithint, <br>            //  before setting the termination event. <br>            // <br>            ReportStatusToSCMgr( <br>                    SERVICE_STOP_PENDING, // current state <br>                    NO_ERROR,             // exit code <br>                    1,                    // checkpoint <br>                    3000);                // waithint <br> <br>            if     (UNLOCK_AT_SERVICE_STOP) <br>            { if (!WriteSD_ToA_File(psdEveryoneSD,"\\\\.\\A:")) <br>              { StopSimpleService("Unlock of A: failed, see log file"); <br>              } <br>              if (!WriteSD_ToA_File(psdEveryoneSD,"\\\\.\\B:")) <br>              { StopSimpleService("Unlock of B: failed, see log file"); <br>              } <br> <br>              bFloppiesAreLocked = FALSE; <br>            } <br> <br>            SetEvent(hServDoneEvent); <br>            return; <br> <br>        // Update the service status. <br>        // <br>        case SERVICE_CONTROL_INTERROGATE: <br>            break; <br> <br>        // invalid control code <br>        // <br>        default: <br>            break; <br> <br>    } <br> <br>    // send a status response. <br>    // <br>    ReportStatusToSCMgr(dwState, NO_ERROR, 0, 0); <br>} <br> <br> <br> <br>//  worker_thread() -- <br>//      this function does the actual nuts and bolts work that <br>//      the service requires.  It will also Pause or Stop when <br>//      asked by the service_ctrl function. <br>// <br>VOID <br>worker_thread(VOID *notUsed) <br>{ <br>    char                 inbuf[180]; <br>    char                 outbuf[180]; <br>    BOOL                 ret; <br>    DWORD                bytesRead; <br>    DWORD                bytesWritten; <br>    DWORD                dwLen; <br> <br>    // okay, our pipe has been created, let's enter the simple <br>    //  processing loop... <br>    // <br>    while (1) { <br> <br>        // wait for a connection... <br>        // <br>        ConnectNamedPipe(pipeHandle, NULL); <br> <br>        // grab whatever's coming through the pipe... <br>        // <br>        ret = ReadFile( <br>                    pipeHandle,     // file to read from <br>                    inbuf,          // address of input buffer <br>                    sizeof(inbuf),  // number of bytes to read <br>                    &amp;bytesRead,     // number of bytes read <br>                    NULL);          // overlapped stuff, not needed <br> <br>        if (!ret) <br>            // pipe's broken... go back and reconnect <br>            // <br>            continue; <br> <br>        switch (inbuf[0]) <br>        { case 'U': <br>            dwLen = sprintf(outbuf,"Floppies were unlocked"); <br> <br>            if (!WriteSD_ToA_File(psdEveryoneSD,"\\\\.\\A:")) <br>            { dwLen += sprintf(outbuf+dwLen,", unlock of A: failed, see log file"); <br>            } <br>            if (!WriteSD_ToA_File(psdEveryoneSD,"\\\\.\\B:")) <br>            { dwLen += sprintf(outbuf+dwLen,", unlock of B: failed, see log file"); <br>            } <br> <br>            bFloppiesAreLocked = FALSE; <br>            break; <br> <br>          case 'L': <br>            dwLen = sprintf(outbuf,"Floppies were locked"); <br> <br>            if (!WriteSD_ToA_File(psdAbsoluteSD,"\\\\.\\A:")) <br>            { dwLen += sprintf(outbuf+dwLen,", lock of A: failed, see log file"); <br>            } <br>            if (!WriteSD_ToA_File(psdAbsoluteSD,"\\\\.\\B:")) <br>            { dwLen += sprintf(outbuf+dwLen,", lock of B: failed, see log file"); <br>            } <br> <br>            bFloppiesAreLocked = TRUE; <br>            break; <br> <br>          case 'Q': <br>            if (bFloppiesAreLocked) <br>            { sprintf(outbuf,"Floppy status is: Locked"); <br>            } <br>            else <br>            { sprintf(outbuf,"Floppy status is: Unlocked"); <br>            } <br>            break; <br> <br>          default : <br>            sprintf(outbuf,"Bad operation passed in"); <br>        } <br> <br>        // send it back out... <br>        // <br>        ret = WriteFile( <br>                    pipeHandle,     // file to write to <br>                    outbuf,         // address of output buffer <br>                    sizeof(outbuf), // number of bytes to write <br>                    &amp;bytesWritten,  // number of bytes written <br>                    NULL);          // overlapped stuff, not needed <br> <br>        if (!ret) <br>            // pipe's broken... go back and reconnect <br>            // <br>            continue; <br> <br>        // drop the connection... <br>        // <br>        DisconnectNamedPipe(pipeHandle); <br>    } <br>} <br> <br> <br> <br>// utility functions... <br> <br> <br> <br>// ReportStatusToSCMgr() -- <br>//      This function is called by the ServMainFunc() and <br>//      ServCtrlHandler() functions to update the service's status <br>//      to the service control manager. <br>// <br>BOOL <br>ReportStatusToSCMgr(DWORD dwCurrentState, <br>                    DWORD dwWin32ExitCode, <br>                    DWORD dwCheckPoint, <br>                    DWORD dwWaitHint) <br>{ <br>    BOOL fResult; <br> <br>    // Disable control requests until the service is started. <br>    // <br>    if (dwCurrentState == SERVICE_START_PENDING) <br>        ssStatus.dwControlsAccepted = 0; <br>    else <br>        ssStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP | <br>            SERVICE_ACCEPT_PAUSE_CONTINUE; <br> <br>    // These SERVICE_STATUS members are set from parameters. <br>    // <br>    ssStatus.dwCurrentState = dwCurrentState; <br>    ssStatus.dwWin32ExitCode = dwWin32ExitCode; <br>    ssStatus.dwCheckPoint = dwCheckPoint; <br> <br>    ssStatus.dwWaitHint = dwWaitHint; <br> <br>    // Report the status of the service to the service control manager. <br>    // <br>    if (!(fResult = SetServiceStatus( <br>                sshStatusHandle,    // service reference handle <br>                &amp;ssStatus))) {      // SERVICE_STATUS structure <br> <br>        // If an error occurs, stop the service. <br>        // <br>        StopSimpleService("SetServiceStatus"); <br>    } <br>    return fResult; <br>} <br> <br> <br> <br>// The StopSimpleService function can be used by any thread to report an <br>//  error, or stop the service. <br>// <br>VOID <br>StopSimpleService(LPTSTR lpszMsg) <br>{ <br>    CHAR    chMsg[256]; <br>    HANDLE  hEventSource; <br>    LPTSTR  lpszStrings[2]; <br> <br>    dwGlobalErr = GetLastError(); <br> <br>    // Use event logging to log the error. <br>    // <br>    hEventSource = RegisterEventSource(NULL, <br>                            TEXT("SimpleService")); <br> <br>    sprintf(chMsg, "SimpleService error: %d", dwGlobalErr); <br>    lpszStrings[0] = chMsg; <br>    lpszStrings[1] = lpszMsg; <br> <br>    if (hEventSource != NULL) { <br>        ReportEvent(hEventSource, // handle of event source <br>            EVENTLOG_ERROR_TYPE,  // event type <br>            0,                    // event category <br>            0,                    // event ID <br>            NULL,                 // current user's SID <br>            2,                    // strings in lpszStrings <br>            0,                    // no bytes of raw data <br>            lpszStrings,          // array of error strings <br>            NULL);                // no raw data <br> <br>        (VOID) DeregisterEventSource(hEventSource); <br>    } <br> <br>    // Set a termination event to stop SERVICE MAIN FUNCTION. <br>    // <br>    SetEvent(hServDoneEvent); <br>} <br>  <br>/****************************************************************************\ <br>* <br>* FUNCTION: WriteSD_ToA_File <br>* <br>\****************************************************************************/ <br> <br>BOOL WriteSD_ToA_File(PSECURITY_DESCRIPTOR psdAbsoluteSD, LPTSTR lpszFileName) <br>{ <br>  DWORD dwErrorMode; <br>  BOOL  bStatus; <br> <br>  /**************************************************************************\ <br>  * <br>  * SetErrorMode so we don't get the error due to no floppy disk in the floppy <br>  *   drive <br>  * <br>  \**************************************************************************/ <br> <br>  dwErrorMode = SetErrorMode(SEM_FAILCRITICALERRORS); <br> <br>  /**************************************************************************\ <br>  * <br>  * Write SD to file system <br>  * <br>  \**************************************************************************/ <br> <br>  bStatus = SetFileSecurity(lpszFileName, <br>                            (SECURITY_INFORMATION)(DACL_SECURITY_INFORMATION), <br>                            psdAbsoluteSD); <br> <br>  /**************************************************************************\ <br>  * <br>  * SetErrorMode back to its previous value <br>  * <br>  \**************************************************************************/ <br> <br>  SetErrorMode(dwErrorMode); <br> <br>  if (!bStatus) <br>  { if (ERROR_FILE_NOT_FOUND == GetLastError()) <br>    { printf("\nAttempted to lock %s, but it was not found",lpszFileName); <br>    } <br>    else <br>    { PERR("SetFileSecurity"); <br>      return(FALSE); <br>    } <br>  } <br> <br>  return(TRUE); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
