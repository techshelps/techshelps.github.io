<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SIDCLEAN.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6226"></a>SIDCLEAN.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples.  <br>*       Copyright 1993 - 1998 Microsoft Corporation. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>/****************************************************************************\ <br>* MODULE:       sidclean.c <br>* <br>*               NT never deletes SIDs, so the name of this sample is most <br>*                 accurately be intrepreted as "Clean up SID ownership and <br>*                 ACE's that relate to SIDs that still (and always will) <br>*                 exist, but for which the corresponding user account has been <br>*                 deleted" <br>* <br>* <br>* PURPOSE:      Demonstrate some of the Win32 security api(s), and provide a <br>*                 sample of how a utility could be written that recovers <br>*                 on-disk resources remaining allocated to deleted user <br>*                 accounts.  The on-disk resources recovered are 1) Files that <br>*                 are still owned by accounts that have been deleted are <br>*                 assigned ownership to the account logged on when this sample <br>*                 is run, and 2) ACE's for deleted accounts are edited <br>*                 (deleted) out of the ACLs of files to which the deleted <br>*                 accounts had been granted authorizations (eg., Read access) <br>* <br>*               It may be that running this sample as a utility has no <br>*                 practical value in many environments, as the number of files <br>*                 belonging to deleted user accounts will often be quite <br>*                 small, and the number of bytes recovered on disk by editing <br>*                 out ACEs for deleted accounts may well not be worth the time <br>*                 it takes to run this sample.  The time it takes to run this <br>*                 sample may be quite significant when processing an entire <br>*                 hard disk or partition <br>* <br>*               This sample is not a supported utility <br>* <br>* <br>* TO RUN:       You must log on using an account, such as Administrator, that <br>*                 has the priviledges to take file ownership and edit ACls <br>* <br>*               The ACL editing part of this sample can only be excercised for <br>*                 files on a partition that has ACLs NT processes:  NTFS <br>* <br>*               Typical test scenario:  Create a user account or two, log on <br>*                 as each of these accounts in turn, while logged on for each <br>*                 account, go to an NTFS partition, create a couple of files <br>*                 so the test accounts each own a few files, use the file <br>*                 manager to edit permissions for those files so that each <br>*                 test user has some authorities (e.g., Read) explicitly <br>*                 granted for those files.  Logon as Administrator, authorize <br>*                 each test user to a few Administrator-owned files.  Delete <br>*                 the test accounts.  Run the sample in the directories where <br>*                 you put the files the test accounts owned or were authorized <br>*                 to <br>* <br>* <br>* OVERALL APPROACH: The command line interface is kept inflexible to simplify <br>*                 it's parsing in this sample.  The user must pass in a switch <br>*                 argument, a directory spec, and a file search pattern <br>* <br>*               The sample positions the current directory (of the process the <br>*                 sample runs in) to the dir spec, and uses FindFirstFile and <br>*                 FindNextFile to walk through the directory specified looking <br>*                 for files that match the file pattern specified <br>* <br>*               The switch argument can cause subdirectories to be searched <br>*                 recursively <br>* <br>*               The switch argument lets the user choose only to take <br>*                 ownerships, only to edit ACLs, do both, or do neither, in <br>*                 which case the sample merely reports on what ownerships <br>*                 would have been taken, and what ACE's would have been <br>*                 deleted <br>* <br>*               As the directories are walked, each file that matches the <br>*                 file pattern is processed right then <br>* <br>*               Note that we process files in a directory, and we also process <br>*                 the directory itself that contains the files.  We process <br>*                 directories because they can also be owned by deleted <br>*                 accounts, or could have ACEs that will no longer be used <br>* <br>*               Note also that we process all directories that we check for <br>*                 files, regardless of the spelling of the directory name <br>* <br>*               Counters are kept of file ownerships taken, ACEs deleted and <br>*                 total files checked, to print a summary line at the end of <br>*                 the run <br>* <br>*               The sample considers it perfectly acceptable if 0 files match <br>*                 the file pattern for the entire run <br>* <br>* <br>* FUNCTIONS:  DoMatchingFilesInOneDir <br>* <br>*               Look in one dir or sub-dir for files that match the file <br>*                 pattern.  For each match call DoOneFileOrDir <br>* <br>*             DoAllDirsInOneDir <br>* <br>*               For all the sub-dirs in a dir, set the current directory to be <br>*                 that directory, check for files that match the file pattern, <br>*                 and if any match, call DoMatchingFilesInOneDir to process <br>*                 those.  Then reset the current directory <br>* <br>*             GetFullFileOrDirName <br>* <br>*               Get the full name of the file or dir for simplified processing <br>*                 (and for display on the console) <br>* <br>*             DoOneFileOrDir <br>* <br>*               Get the file's SD (Security Descriptor), and call <br>*                 TakeOwnershipIfAppropriate and/or DeleteACEsAsAppropriate as <br>*                 needed <br>* <br>*             TakeOwnershipIfAppropriate <br>* <br>*               Get the owning SID of the file from the file's SD that <br>*                 DoOneFileOrDir passed in, check that SID to see if the <br>*                 account is deleted.  If so, edit into the file's SD a new <br>*                 owning SID (the SID of the process running the sample). <br>*                 Then write the modified file SD to disk <br>* <br>*             DeleteACEsAsAppropriate <br>* <br>*               Get the DACL of the file from the file's SD that <br>*                 DoOneFileOrDir passed in.  Walk through the ACE list for <br>*                 that DACL, checking each ACE to see what SID the ACE refers <br>*                 to.  For the SID referred to, check to see if the account is <br>*                 deleted.  If so, delete that ACE from the DACL.  When all <br>*                 ACE's have been examined, write the new DACL into the file's <br>*                 SD.  Then write the modified file SD to disk <br>* <br>*             GetProcessSid <br>* <br>*               Retrieve into a global variable the SID of the user account <br>*                 logged on when this sample is run.  This is the SID used by <br>*                 TakeOwnershipIfAppropriate <br>* <br>*               NOTE:  This routine has the notable side-effect on the access <br>*                 token of the curent process of enabling two privileges: <br>*                 SeTakeOwnershipPrivilege, and SeSecurityPrivilege. <br>*                 SeTakeOwnershipPrivilege is needed to ensure we can take <br>*                 ownership in spite of any DACL on the file. <br>*                 SeSecurityPrivilege is needed to work with SACLs <br>* <br>*             CrackArgs <br>* <br>*               Process the command line, cracking (parsing/decoding) the <br>*                 switch argument into boolean global variables (see below). <br>*                 Call DisplayHelp if anything illegal is found in the command <br>*                 line, or if the user asked for help <br>* <br>*             DisplayHelp <br>* <br>*               Display help text on the console <br>* <br>* <br>* GLOBAL VARS: <br>*             BOOL  bTakeOwnership <br>*             BOOL  bEditACLs <br>*             BOOL  bRecurse <br>*             BOOL  bJustCount <br>* <br>*               These store the values the user specified on the command <br>*                 line's first argument (the switches argument). <br>*                 Respectively, they record whether we are to do the <br>*                 processing to Take Ownerships, Edit ACLs, whether we are to <br>*                 recurse into all subdirectories, and whether we are just <br>*                 counting up what would be processed (in which case we take <br>*                 no ownerships and edit no ACLs) <br>* <br>*             DWORD dwFilesChecked <br>*             DWORD dwFilesOwned <br>*             DWORD dwACEsDeleted <br>* <br>*               These count, respecively, the total files we checked, the <br>*                 number of files we took ownership of (or would have if we <br>*                 had not been told only to count), and the number of ACEs we <br>*                 deleted (or would have if we had not been told only to <br>*                 count).  Note that the total number of files checked does <br>*                 not include files in the directories we process that do not <br>*                 match the file pattern <br>* <br>*               Note, however, that we process directories regardless of <br>*                 whether they match the file pattern <br>* <br>*             UCHAR ucProcessSIDBuf <br>*             PSID  psidProcessOwnerSID <br>* <br>*               These store the SID of the account logged on as this sample <br>*                 runs, and a pointer to that SID <br>* <br>\****************************************************************************/ <br> <br> <br>/****************************************************************************\ <br>*  INCLUDES, DEFINES, TYPEDEFS <br>\****************************************************************************/ <br>#define STRICT <br>#include &lt;windows.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;string.h&gt; <br>#include &lt;stdlib.h&gt; <br> <br>#define PERR(api) printf("%s: Error %d from %s on line %d\n",  \ <br>    __FILE__, GetLastError(), api, __LINE__); <br>#define PMSG(msg) printf("%s line %d: %s\n",  \ <br>    __FILE__, __LINE__, msg); <br> <br>#define PrintAppStyleAPIError(ApiTxt,MsgTxt) {                     \ <br>  DWORD dwLastError;                                               \ <br>  dwLastError = GetLastError();                                    \ <br>  switch (dwLastError)                                             \ <br>  { case ERROR_FILE_NOT_FOUND :                                    \ <br>      printf("\nFile not found (%s) line %d",MsgTxt,__LINE__);     \ <br>      break;                                                       \ <br>    case ERROR_INVALID_NAME   :                                    \ <br>      printf("\nInvalid name (%s) line %d",MsgTxt,__LINE__);       \ <br>      break;                                                       \ <br>    case ERROR_PATH_NOT_FOUND :                                    \ <br>      printf("\nError path not found (%s) line %d",MsgTxt,__LINE__); \ <br>      break;                                                       \ <br>    case ERROR_SHARING_VIOLATION :                                 \ <br>      printf("\nSharing violation - shut down net and/or stop other sessions (%s) line %d",MsgTxt,__LINE__); \ <br>      break;                                                       \ <br>    case ERROR_ACCESS_DENIED  :                                    \ <br>      printf("\nAccess denied (%s) line %d",MsgTxt,__LINE__);      \ <br>      break;                                                       \ <br>    default                   :                                    \ <br>      printf("\n" #ApiTxt " - unexpected return code=%d (%s) line %d",dwLastError,MsgTxt,__LINE__); \ <br>      break;                                                       \ <br>  }                                                                \ <br>  } <br> <br>/****************************************************************************\ <br>* GLOBAL VARIABLES <br>\****************************************************************************/ <br> <br>BOOL  bTakeOwnership  = FALSE; <br>BOOL  bEditACLs       = FALSE; <br>BOOL  bRecurse        = FALSE; <br>BOOL  bJustCount      = FALSE; <br> <br>DWORD dwFilesChecked  = 0; <br>DWORD dwFilesOwned    = 0; <br>DWORD dwACEsDeleted   = 0; <br> <br>PSID  psidProcessOwnerSID; <br> <br> <br>/****************************************************************************\ <br>* FUNCTION PROTOTYPES <br>\****************************************************************************/ <br> <br>BOOL DoMatchingFilesInOneDir(HANDLE          hFound, <br>                             WIN32_FIND_DATA ffdFoundData); <br>BOOL DoAllDirsInOneDir(char *FilePattern); <br>BOOL GetFullFileOrDirName(LPTSTR lpszFileName); <br>BOOL DoOneFileOrDir(LPTSTR lpszFullName); <br>BOOL TakeOwnershipIfAppropriate(PSECURITY_DESCRIPTOR psdFileSD, <br>                                LPTSTR  lpszFullName); <br>BOOL DeleteACEsAsAppropriate   (PSECURITY_DESCRIPTOR psdFileSD, <br>                                LPTSTR  lpszFullName); <br>BOOL GetProcessSid(VOID); <br>BOOL CrackArgs(UINT argc, char *argv[]); <br>VOID DisplayHelp(VOID); <br>  <br>/****************************************************************************\ <br>* <br>* FUNCTION: Main <br>* <br>\****************************************************************************/ <br> <br>UINT main(UINT argc, char *argv[]) <br>{ <br>  WIN32_FIND_DATA ffdFoundData; <br>  HANDLE          hFound; <br>  #define                   SZ_NAME_BUF MAX_PATH <br>  UCHAR           ucPathBuf[SZ_NAME_BUF]; <br>  LPTSTR          lpszFullName = (LPTSTR)&amp;ucPathBuf; <br> <br>  /**************************************************************************\ <br>  * <br>  * Store the process's SID in a global variable for later use (in taking <br>  *   ownership). <br>  * <br>  \**************************************************************************/ <br> <br>  if (!GetProcessSid()) <br>  { PERR("Can't proceed without process SID - see earlier error messages"); <br>    return(1); <br>  } <br> <br>  if (!CrackArgs(argc,argv)) <br>    return(1); <br> <br>  /**************************************************************************\ <br>  * <br>  * CrackArgs has set our global processing switches, and proven argv[2] and <br>  *   argv[3] are our non-blank dir-spec and file-pattern strings.  Now we <br>  *   must see that the file-spec is acceptable to the Win32 api's.  Argv[2] <br>  *   is the file-spec to pass to SetCurrentDirectory, and argv[3] is the <br>  *   file-pattern to pass to FindFirstFile <br>  * <br>  * First we have to expand the dir-spec in argv[2], because if we set the <br>  *   current directory to it before expansion,the expansion will have a <br>  *   different result if argv[2] is something like ..\.. <br>  * <br>  \**************************************************************************/ <br> <br>  strcpy(lpszFullName,argv[2]); <br> <br>  if (!GetFullFileOrDirName(lpszFullName)) <br>  { PERR("Failed to expand to full name the 2nd argument (directory specification)"); <br>    return(1); <br>  } <br> <br>  /**************************************************************************\ <br>  * <br>  * Now we pass the un-expanded argv[2] to SetCurrentDirectory for validity <br>  *   checking.  GetFullPathName (called by GetFullFileOrDirName) does not <br>  *   validity check <br>  * <br>  \**************************************************************************/ <br> <br>  if (!SetCurrentDirectory(argv[2])) <br>  { PrintAppStyleAPIError(SetCurrentDirectory,"2nd argument (directory specification)"); <br>    return(1); <br>  } <br> <br>  /**************************************************************************\ <br>  * <br>  * We begin processing with the current directory, using the expanded form we <br>  *   got before.  We have to use the expanded form, because if we set to <br>  *   ..\.. and then try to process the string ..\.. as a dir name, instead of <br>  *   processing the dir two levels up from where we are we'll process the dir <br>  *   four levels up <br>  * <br>  \**************************************************************************/ <br> <br>  if (!DoOneFileOrDir(lpszFullName)) <br>    return(1); <br>  <br>  /**************************************************************************\ <br>  * <br>  * It's OK to get no hits.  The files-checked counter will show how many <br>  *   files we looked at, and it's OK to look at 0 <br>  * <br>  * On the else branch, Argv[3] has been verified, and we have a good handle. <br>  *   We now pass to DoMatchingFilesInOneDir for processing the handle and <br>  *   found data we just got from FindFirstFile <br>  * <br>  \**************************************************************************/ <br> <br>  hFound = FindFirstFile(argv[3], <br>                         (LPWIN32_FIND_DATA)&amp;ffdFoundData); <br>  if ((HANDLE)(-1) == hFound) <br>  { if (GetLastError() != ERROR_FILE_NOT_FOUND) <br>    { PrintAppStyleAPIError(FindFirstFile,"3rd argument"); <br>      return(1); <br>    } <br>  } <br>  else if (!DoMatchingFilesInOneDir(hFound,ffdFoundData)) <br>    return(1); <br> <br>  /**************************************************************************\ <br>  * <br>  * Pass the original file pattern for recursive calling to DoAllDirsInOneDir <br>  * <br>  \**************************************************************************/ <br> <br>  if (!DoAllDirsInOneDir(argv[3])) <br>    return(1); <br> <br>  if (bJustCount) <br>    printf("\nChecked %d files, would have taken ownership of %d files, would have deleted %d ACEs\n", <br>           dwFilesChecked,dwFilesOwned,dwACEsDeleted); <br>  else <br>    printf("\nChecked %d files, took ownership of %d files, deleted %d ACEs\n", <br>           dwFilesChecked,dwFilesOwned,dwACEsDeleted); <br> <br>  free(psidProcessOwnerSID); <br> <br>  return(0); <br>} <br>  <br>/****************************************************************************\ <br>* <br>* FUNCTION: DoMatchingFilesInOneDir <br>* <br>\****************************************************************************/ <br> <br>BOOL DoMatchingFilesInOneDir(HANDLE          hFound, <br>                             WIN32_FIND_DATA ffdFoundData) <br>{ <br>  BOOL bDoneWithHandle = FALSE; <br> <br>  /**************************************************************************\ <br>  * <br>  * Process all files referred to by the handle, but not including <br>  *   directories, because directories are handled with separate calls to <br>  *   DoOneFileOrDir.  Such separate calls are made as we are setting the <br>  *   current directory to be the directory to be processed <br>  * <br>  \**************************************************************************/ <br> <br>  while (!bDoneWithHandle) <br>  { <br>    if (!(FILE_ATTRIBUTE_DIRECTORY &amp; ffdFoundData.dwFileAttributes)) <br>    { <br>      if (!DoOneFileOrDir(ffdFoundData.cFileName)) <br>        return(FALSE); <br>    } <br> <br>    if (!FindNextFile(hFound, <br>                      (LPWIN32_FIND_DATA)&amp;ffdFoundData)) <br>      if (GetLastError() == ERROR_NO_MORE_FILES) <br>        bDoneWithHandle = TRUE; <br>      else <br>      { PrintAppStyleAPIError(FindNextFile,"on FindNext"); <br>        return(FALSE); <br>      } <br>  } <br>  return TRUE; <br>} <br>  <br>/****************************************************************************\ <br>* <br>* FUNCTION: DoAllDirsInOneDir <br>* <br>\****************************************************************************/ <br> <br>BOOL DoAllDirsInOneDir(char *FilePattern) <br>{ <br>  HANDLE          hFound; <br>  WIN32_FIND_DATA ffdFoundData; <br>  BOOL            bDoneWithHandle = FALSE; <br> <br>  /**************************************************************************\ <br>  * <br>  * If not recursing into dirs, simply return <br>  * <br>  \**************************************************************************/ <br> <br>  if (!bRecurse) <br>    return TRUE; <br> <br>  /**************************************************************************\ <br>  * <br>  * Since we are recursing, get a handle that points to entire directory, and <br>  *   walk the handle picking off only directories to recurse into <br>  * <br>  \**************************************************************************/ <br> <br>  hFound = FindFirstFile("*.*", <br>                         (LPWIN32_FIND_DATA)&amp;ffdFoundData); <br>  if ((HANDLE)(-1) == hFound) <br>  { PrintAppStyleAPIError(FindFirstFile,"on dir *.* FindFirst"); <br>    return(FALSE); <br>  } <br>  <br>  while (!bDoneWithHandle) <br>  { <br>    /************************************************************************\ <br>    * <br>    * We only do dirs here, and we only do directories with textual names <br>    *   (i.e., not "." and not "..") <br>    * <br>    \************************************************************************/ <br> <br>    if (   (FILE_ATTRIBUTE_DIRECTORY &amp; ffdFoundData.dwFileAttributes) <br>        &amp;&amp; (0 != strcmp("." ,ffdFoundData.cFileName)) <br>        &amp;&amp; (0 != strcmp("..",ffdFoundData.cFileName))) <br>    { <br>      HANDLE          hFile2; <br>      WIN32_FIND_DATA ffdFound2; <br> <br>      /**********************************************************************\ <br>      * <br>      * We begin processing the new current directory by processing it itself, <br>      *   then setting the current dir to be the dir itself <br>      * <br>      \**********************************************************************/ <br> <br>      if (!DoOneFileOrDir(ffdFoundData.cFileName)) <br>        return(FALSE); <br> <br>      if (!SetCurrentDirectory(ffdFoundData.cFileName)) <br>      { PrintAppStyleAPIError(SetCurrentDirectory,"recursive set"); <br>        return(FALSE); <br>      } <br>  <br>      /**********************************************************************\ <br>      * <br>      * It's OK to get no hits.  The files-checked counter will show how many <br>      *   files we looked at, and it's OK to look at 0 <br>      * <br>      \**********************************************************************/ <br> <br>      hFile2 = FindFirstFile(FilePattern, <br>                             (LPWIN32_FIND_DATA)&amp;ffdFound2); <br>      if ((HANDLE)(-1) == hFile2) <br>      { if (GetLastError() != ERROR_FILE_NOT_FOUND) <br>        { PrintAppStyleAPIError(FindFirstFile,"during recursion"); <br>          return(FALSE); <br>        } <br>      } <br>      else if (!DoMatchingFilesInOneDir(hFile2,ffdFound2)) <br>        return(FALSE); <br> <br>      if (!DoAllDirsInOneDir(FilePattern)) <br>        return(FALSE); <br> <br>      if (!SetCurrentDirectory("..")) <br>      { PrintAppStyleAPIError(SetCurrentDirectory,"un-recursive set"); <br>        return(FALSE); <br>      } <br>    } <br> <br>    /************************************************************************\ <br>    * <br>    * Get next recursion candidate (file or dir at this point, however at loop <br>    *   top files are screened out) <br>    * <br>    \************************************************************************/ <br> <br>    if (!FindNextFile(hFound, <br>                      (LPWIN32_FIND_DATA)&amp;ffdFoundData)) <br>      if (GetLastError() == ERROR_NO_MORE_FILES) <br>        bDoneWithHandle = TRUE; <br>      else <br>      { PrintAppStyleAPIError(FindNextFile,"on dir *.* FindNext"); <br>        return(FALSE); <br>      } <br>  } <br>  return(TRUE); <br>} <br>  <br>/****************************************************************************\ <br>* <br>* FUNCTION: GetFullFileOrDirName <br>* <br>\****************************************************************************/ <br> <br>BOOL GetFullFileOrDirName(LPTSTR lpszFileName) <br>{ <br>  UCHAR   ucPathBuf[SZ_NAME_BUF]; <br>  DWORD   dwSzReturned; <br>  LPTSTR  lpszLastNamePart; <br>  LPTSTR  lpszFullName; <br> <br>  dwSzReturned = GetFullPathName <br>                   (lpszFileName, <br>                    (DWORD)SZ_NAME_BUF, <br>                    (LPTSTR)&amp;ucPathBuf, <br>                    (LPTSTR *)&amp;lpszLastNamePart); <br>  if (0 == dwSzReturned) <br>    switch (GetLastError()) <br>    { case ERROR_INVALID_NAME   : <br>        printf("\nError invalid file full-name (on GetFullPathName)"); <br>        return(FALSE); <br>      default                   : <br>        PERR("GetFullPathName - unexpected return code"); <br>        return(FALSE); <br>    } <br> <br>  if (dwSzReturned &gt; SZ_NAME_BUF) <br>  { PERR("GetFullPathName - buffer too small"); <br>    return(FALSE); <br>  } <br> <br>  lpszFullName = CharLower((LPTSTR)&amp;ucPathBuf); <br> <br>  if (!lpszFullName) <br>  { PERR("CharLower failure"); <br>    return(FALSE); <br>  } <br> <br>  /**************************************************************************\ <br>  * <br>  * Copy the expanded and upper-case-shifted name to the buffer pointed to by <br>  *   the input argument <br>  * <br>  \**************************************************************************/ <br> <br>  strcpy(lpszFileName,lpszFullName); <br>} <br>  <br>/****************************************************************************\ <br>* <br>* FUNCTION: DoOneFileOrDir <br>* <br>\****************************************************************************/ <br> <br>BOOL DoOneFileOrDir(LPTSTR lpszFullName) <br>{ <br>  #define                                 SZ_REL_SD_BUF 1000 <br>  #define                                 SZ_ABS_SD_BUF  500 <br>  #define                                 SZ_DACL_BUF    500 <br>  #define                                 SZ_SACL_BUF    500 <br>  #define                                 SZ_SID_OWN_BUF 500 <br>  #define                                 SZ_SID_PG_BUF  500 <br>  UCHAR                ucBuf             [SZ_REL_SD_BUF]; <br>  UCHAR                ucBufAbs          [SZ_ABS_SD_BUF]; <br>  UCHAR                ucBufDacl         [SZ_DACL_BUF]; <br>  UCHAR                ucBufSacl         [SZ_SACL_BUF]; <br>  UCHAR                ucBufCtrl         [sizeof(PSECURITY_DESCRIPTOR_CONTROL)]; <br>  UCHAR                ucBufSidOwn       [SZ_SID_OWN_BUF]; <br>  UCHAR                ucBufSidPG        [SZ_SID_PG_BUF]; <br>  DWORD                dwSDLength       = SZ_REL_SD_BUF; <br>  DWORD                dwDACLLength     = SZ_DACL_BUF; <br>  DWORD                dwSACLLength     = SZ_SACL_BUF; <br>  DWORD                dwSidOwnLength   = SZ_SID_OWN_BUF; <br>  DWORD                dwSidPGLength    = SZ_SID_PG_BUF; <br>  DWORD                dwSDLengthNeeded; <br>  PSECURITY_DESCRIPTOR psdSrelFileSD    = (PSECURITY_DESCRIPTOR)&amp;ucBuf; <br>  PSECURITY_DESCRIPTOR psdAbsFileSD     = (PSECURITY_DESCRIPTOR)&amp;ucBufAbs; <br>  PSECURITY_DESCRIPTOR_CONTROL psdcCtrl = (PSECURITY_DESCRIPTOR_CONTROL)&amp;ucBufCtrl; <br>  PACL                 paclDacl         = (PACL)&amp;ucBufDacl; <br>  PACL                 paclSacl         = (PACL)&amp;ucBufSacl; <br>  PSID                 psidSidOwn       = (PSID)&amp;ucBufSidOwn; <br>  PSID                 psidSidPG        = (PSID)&amp;ucBufSidPG; <br>  BOOL                 bDaclPresent; <br>  BOOL                 bDaclDefaulted; <br>  BOOL                 bSaclPresent; <br>  BOOL                 bSaclDefaulted; <br>  BOOL                 bOwnerDefaulted; <br>  BOOL                 bGroupDefaulted; <br>  BOOL                 bSDSelfRelative; <br>  DWORD                dwRevision; <br> <br>  if (!GetFullFileOrDirName(lpszFullName)) <br>    return(FALSE); <br> <br>  /**************************************************************************\ <br>  * <br>  * Now the input argument's name is accurate:  it is expanded and lower-case <br>  * <br>  \**************************************************************************/ <br> <br>  printf("\nChecking %s",lpszFullName); <br> <br>  dwFilesChecked++; <br> <br>  if (!GetFileSecurity <br>        (lpszFullName, <br>         (SECURITY_INFORMATION)( OWNER_SECURITY_INFORMATION <br>                               | GROUP_SECURITY_INFORMATION <br>                               | DACL_SECURITY_INFORMATION <br>                               | SACL_SECURITY_INFORMATION), <br>         psdSrelFileSD, <br>         dwSDLength, <br>         (LPDWORD)&amp;dwSDLengthNeeded)) <br>  { PERR("GetFileSecurity"); <br>    return(FALSE); <br>  } <br> <br>  /**************************************************************************\ <br>  * <br>  * This validity check is here for demonstration pruposes.  It's not likely a <br>  *   real app would need to check the validity of this returned SD.  The <br>  *   validity check APIs are more intended to check validity after app code <br>  *   has manipulated the structure and is about to hand it back to the system <br>  * <br>  \**************************************************************************/ <br> <br>  if (!IsValidSecurityDescriptor(psdSrelFileSD)) <br>  { PERR("IsValidSecurityDescriptor said bad SD"); <br>    return(FALSE); <br>  } <br> <br>  /**************************************************************************\ <br>  * <br>  *  Build File SD in absolute format for potential later modification <br>  * <br>  *  First Initialize a new SD, which is by definition in absolute format <br>  * <br>  *  Then Set in the fields from the relative format SD we just fetched <br>  * <br>  \**************************************************************************/ <br> <br>  if (!InitializeSecurityDescriptor(psdAbsFileSD, <br>                 SECURITY_DESCRIPTOR_REVISION)) <br>  { PERR("InitializeSecurityDescriptor"); <br>    return FALSE; <br>  } <br> <br>  /**************************************************************************\ <br>  * <br>  * Get Control from relative format File SD <br>  * <br>  * This control info isn't much queried in the code that follows, as the <br>  *   Get/Set calls are more convienent in this case, but it does give us a <br>  *   change to verify that the SD is in relative format <br>  * <br>  \**************************************************************************/ <br> <br>  if (!GetSecurityDescriptorControl(psdSrelFileSD, <br>          psdcCtrl, <br>          &amp;dwRevision)) <br>  { PERR("GetSecurityDescriptorControl"); <br>    return FALSE; <br>  } <br> <br>  bSDSelfRelative = (SE_SELF_RELATIVE &amp; *psdcCtrl); <br> <br>  /**************************************************************************\ <br>  * <br>  * Set DACL into absolute format File SD <br>  * <br>  * Note that it is possible that a NULL DACL has been explictly specified. <br>  *   If so the Get/Set call pair will correctly map that into the absolute <br>  *   format SD <br>  * <br>  * The next if statement isn't necessary, it simply shows the relationship <br>  *   between SE_DACL_PRESENT and SE_DACL_DEFAULTED, and lets you trace <br>  *   through with the debugger </code></pre>
<p>
</p>
<pre><code>* <br>  \**************************************************************************/ <br> <br>  if (bDaclPresent = (SE_DACL_PRESENT   &amp; *psdcCtrl)) <br>  {                // SE_DACL_DEFAULTED ignored if SE_DACL_PRESENT not set <br>    bDaclDefaulted = (SE_DACL_DEFAULTED &amp; *psdcCtrl); <br>  } <br>  else <br>  { // No DACL at all <br>  } <br> <br>  if (!GetSecurityDescriptorDacl(psdSrelFileSD, <br>          &amp;bDaclPresent,      // fDaclPresent flag <br>          &amp;paclDacl, <br>          &amp;bDaclDefaulted))   // is/is not a default DACL <br>  { PERR("GetSecurityDescriptorDacl"); <br>    return FALSE; <br>  } <br>  if (!SetSecurityDescriptorDacl(psdAbsFileSD, <br>          bDaclPresent,       // fDaclPresent flag <br>          paclDacl, <br>          bDaclDefaulted))    // is/is not a default DACL <br>  { PERR("SetSecurityDescriptorDacl"); <br>    return FALSE; <br>  } <br> <br>  /**************************************************************************\ <br>  * <br>  * Set SACL into absolute format File SD <br>  * <br>  * Note that it is possible that a NULL SACL has been explictly specified. <br>  *   If so the Get/Set call pair will correctly map that into the absolute <br>  *   format SD <br>  * <br>  * The next if statement isn't necessary, it simply shows the relationship <br>  *   between SE_SACL_PRESENT and SE_SACL_DEFAULTED, and lets you trace <br>  *   through with the debugger <br>  * <br>  \**************************************************************************/ <br> <br>  if (bSaclPresent = (SE_SACL_PRESENT   &amp; *psdcCtrl)) <br>  {                // SE_SACL_DEFAULTED ignored if SE_SACL_PRESENT not set <br>    bSaclDefaulted = (SE_SACL_DEFAULTED &amp; *psdcCtrl); <br>  } <br>  else <br>  { // No SACL at all <br>  } <br> <br>  if (!GetSecurityDescriptorSacl(psdSrelFileSD, <br>          &amp;bSaclPresent,      // fSaclPresent flag <br>          &amp;paclSacl, <br>          &amp;bSaclDefaulted))   // is/is not a default SACL <br>  { PERR("GetSecurityDescriptorSacl"); <br>    return FALSE; <br>  } <br>  if (!SetSecurityDescriptorSacl(psdAbsFileSD, <br>          bSaclPresent,       // fSaclPresent flag <br>          paclSacl, <br>          bSaclDefaulted))    // is/is not a default SACL <br>  { PERR("SetSecurityDescriptorSacl"); <br>    return FALSE; <br>  } <br> <br>  /**************************************************************************\ <br>  * <br>  * Set Owner into absolute format File SD <br>  * <br>  * The next if statement isn't necessary, it simply let's you trace through <br>  *   with the debugger <br>  * <br>  \**************************************************************************/ <br> <br>  bOwnerDefaulted = (SE_OWNER_DEFAULTED &amp; *psdcCtrl); <br> <br>  if (!GetSecurityDescriptorOwner(psdSrelFileSD, <br>          &amp;psidSidOwn, <br>          &amp;bOwnerDefaulted))   // is/is not a default Owner <br>  { PERR("GetSecurityDescriptorOwner"); <br>    return FALSE; <br>  } <br>  if (!SetSecurityDescriptorOwner(psdAbsFileSD, <br>          psidSidOwn, <br>          bOwnerDefaulted))    // is/is not a default Owner <br>  { PERR("SetSecurityDescriptorOwner"); <br>    return FALSE; <br>  } <br> <br>  /**************************************************************************\ <br>  * <br>  * Set Group into absolute format File SD <br>  * <br>  * The next if statement isn't necessary, it simply let's you trace through <br>  *   with the debugger <br>  * <br>  \**************************************************************************/ <br> <br>  bGroupDefaulted = (SE_GROUP_DEFAULTED &amp; *psdcCtrl); <br> <br>  if (!GetSecurityDescriptorGroup(psdSrelFileSD, <br>          &amp;psidSidOwn, <br>          &amp;bGroupDefaulted))   // is/is not a default Group <br>  { PERR("GetSecurityDescriptorGroup"); <br>    return FALSE; <br>  } <br>  if (!SetSecurityDescriptorGroup(psdAbsFileSD, <br>          psidSidOwn, <br>          bGroupDefaulted))    // is/is not a default Group <br>  { PERR("SetSecurityDescriptorGroup"); <br>    return FALSE; <br>  } <br> <br>  /**************************************************************************\ <br>  * <br>  * This validity check is here for demonstration pruposes.  It's not likely a <br>  *   real app would need to check the validity of the SD after it was just <br>  *   built into absolute format.  The validity check APIs are more intended <br>  *   to check validity after app code has manipulated the structure and is <br>  *   about to hand it back to the system <br>  * <br>  * One thing to notice is that IsValidSecurityDescriptor will succeed on both <br>  *   self-relative and absolute format SDs.  However, some other api's, such <br>  *   as SetSecurityDescriptorOwner, require the SD to be in a certain format, <br>  *   and will give a return code of Invalid SD if the SD passed to the api is <br>  *   valid, but in the wrong format.  In other words, when an api such as <br>  *   SetSecurityDescriptorOwner gives the retun code Invalid SD, this doesn't <br>  *   mean the SD passed in was necessarily invalid.  It might have been in <br>  *   the wrong format <br>  * <br>  \**************************************************************************/ <br> <br>  if (!IsValidSecurityDescriptor(psdAbsFileSD)) <br>  { PERR("IsValidSecurityDescriptor said bad SD"); <br>    return(FALSE); <br>  } <br> <br>  if (bTakeOwnership) <br>    if (!TakeOwnershipIfAppropriate(psdAbsFileSD,lpszFullName)) <br>      return(FALSE); <br> <br>  if (bEditACLs) <br>    if (!DeleteACEsAsAppropriate   (psdAbsFileSD,lpszFullName)) <br>      return(FALSE); <br> <br>  return(TRUE); <br>} <br>  <br>/****************************************************************************\ <br>* <br>* FUNCTION: TakeOwnershipIfAppropriate <br>* <br>\****************************************************************************/ <br> <br>BOOL TakeOwnershipIfAppropriate(PSECURITY_DESCRIPTOR psdFileSD, <br>                                LPTSTR  lpszFullName) <br>{ <br>  PSID psidFileOwnerSID; <br>  { <br>    BOOL  bOwnerDefaulted; <br> <br>    if (!GetSecurityDescriptorOwner <br>           (psdFileSD, <br>            (PSID *)&amp;psidFileOwnerSID, <br>            (LPBOOL)&amp;bOwnerDefaulted)) <br>    { PERR("GetSecurityDescriptorOwner"); <br>      return(FALSE); <br>    } <br> <br>    /************************************************************************\ <br>    * <br>    * This validity check is here for demonstration pruposes.  It's not likely <br>    *   a real app would need to check the validity of this returned SID.  The <br>    *   validity check APIs are more intended to check validity after app code <br>    *   has manipulated the structure and is about to hand it back to the <br>    *   system <br>    * <br>    \************************************************************************/ <br> <br>    if (!IsValidSid(psidFileOwnerSID)) <br>    { PERR("IsValidSid said bad SID!"); <br>      return(FALSE); <br>    } <br>  } <br> <br>  { <br>    DWORD        dwLastError   = NO_ERROR; <br>    #define                      SZ_ACCT_NAME_BUF 1000 <br>    UCHAR        ucNameBuf      [SZ_ACCT_NAME_BUF]; <br>    DWORD        dwNameLength  = SZ_ACCT_NAME_BUF; <br>    #define                      SZ_DMN_NAME_BUF  1000 <br>    UCHAR        ucDomainNmBuf  [SZ_DMN_NAME_BUF ]; <br>    DWORD        dwDNameLength = SZ_DMN_NAME_BUF ; <br>    SID_NAME_USE peAcctNameUse; <br> <br>    if (!LookupAccountSid <br>           ((LPTSTR)"",             // Look on local machine <br>           psidFileOwnerSID, <br>           (LPTSTR)&amp;ucNameBuf, <br>           (LPDWORD)&amp;dwNameLength, <br>           (LPTSTR)&amp;ucDomainNmBuf, <br>           (LPDWORD)&amp;dwDNameLength, <br>           (PSID_NAME_USE)&amp;peAcctNameUse)) <br>    { dwLastError = GetLastError(); <br>      if (ERROR_NONE_MAPPED != dwLastError) <br>      { PERR("LookupAccountSID"); <br>        return(FALSE); <br>      } <br>    } <br>  <br>    /************************************************************************\ <br>    * <br>    * If deleted account, take ownership.  This routine's caller checked the <br>    *   global switches that said we are in take ownership mode <br>    * <br>    * In some cases, the account lookup will fail with ERROR_NONE_MAPPED, <br>    *   meaning there is no deleted account mapped to the SID, in which case <br>    *   we also take ownership <br>    * <br>    *   We check that first to avoid referencing peAcctNameUse, which in that <br>    *     case is not set <br>    * <br>    \************************************************************************/ <br> <br>    if (  (ERROR_NONE_MAPPED == dwLastError) <br>       || (SidTypeDeletedAccount == peAcctNameUse)) <br>    { <br>      dwFilesOwned++; <br> <br>      if (bJustCount) <br>      { printf(" - would have taken ownership"); <br>        return(TRUE); <br>      } <br>      else <br>      { <br>        /********************************************************************\ <br>        * <br>        * Modify the SD in virtual memory.  No check on the new owning SID <br>        *   here, because we validity checked it when we fetched it in <br>        *   GetProcessSid <br>        * <br>        \********************************************************************/ <br> <br>        if (!SetSecurityDescriptorOwner <br>               (psdFileSD, <br>                psidProcessOwnerSID, <br>                FALSE))               // New owner explicitly specified <br>        { PERR("SetSecurityDescriptorOwner"); <br>          return(FALSE); <br>        } <br> <br>        /********************************************************************\ <br>        * <br>        *  This validity check is something a real app might actually like to <br>        *    do.  We manupulated the SD, so before we write it back out to the <br>        *    file system, a check is worth considering. <br>        * <br>        \********************************************************************/ <br> <br>        if (!IsValidSecurityDescriptor(psdFileSD)) <br>        { PERR("IsValidSecurityDescriptor said bad SD"); <br>          return(FALSE); <br>        } <br> <br>        /********************************************************************\ <br>        * <br>        * Modify the SD on the hard disk <br>        * <br>        \********************************************************************/ <br> <br>        if (!SetFileSecurity <br>               (lpszFullName, <br>                (SECURITY_INFORMATION)OWNER_SECURITY_INFORMATION, <br>                psdFileSD)) <br>        { PERR("SetFileSecurity"); <br>          return(FALSE); <br>        } <br> <br>        printf(" - took ownership"); <br>      } <br>    } <br>  } <br> <br>  return(TRUE); <br> <br>} <br>  <br>/****************************************************************************\ <br>* <br>* FUNCTION: DeleteACEsAsAppropriate <br>* <br>\****************************************************************************/ <br> <br>BOOL DeleteACEsAsAppropriate(PSECURITY_DESCRIPTOR psdFileSD, <br>                             LPTSTR  lpszFullName) <br>{ <br>  PACL                 paclFile; <br>  BOOL                 bHasACL; <br>  BOOL                 bOwnerDefaulted; <br>  DWORD                dwAcl_i; <br>  DWORD                dwACEsDeletedBeforeNow; <br> <br>  ACL_SIZE_INFORMATION                      asiAclSize; <br>  DWORD                dwBufLength = sizeof(asiAclSize); <br>  ACCESS_ALLOWED_ACE   *paaAllowedAce; <br> <br>  if (!GetSecurityDescriptorDacl(psdFileSD, <br>                                 (LPBOOL)&amp;bHasACL, <br>                                 (PACL *)&amp;paclFile, <br>                                 (LPBOOL)&amp;bOwnerDefaulted)) <br>  { PERR("GetSecurityDescriptorDacl"); <br>    return(FALSE); <br>  } <br> <br>  if (!bHasACL)  // No ACL to process, so OK, return <br>    return(TRUE); <br> <br>  /**************************************************************************\ <br>  * <br>  * This validity check is here for demonstration pruposes.  It's not likely a <br>  *   real app would need to check the validity of this returned ACL.  The <br>  *   validity check APIs are more intended to check validity after app code <br>  *   has manipulated the structure and is about to hand it back to the system <br>  * <br>  \**************************************************************************/ <br> <br>  if (!IsValidAcl(paclFile)) <br>  { PERR("IsValidAcl said bad ACL!"); <br>    return(FALSE); <br>  } <br> <br>  if (!GetAclInformation(paclFile, <br>                         (LPVOID)&amp;asiAclSize, <br>                         (DWORD)dwBufLength, <br>                         (ACL_INFORMATION_CLASS)AclSizeInformation)) <br>  { PERR("GetAclInformation"); <br>    return(FALSE); <br>  } <br>  <br>  dwACEsDeletedBeforeNow = dwACEsDeleted; <br> <br>  /**************************************************************************\ <br>  * <br>  * We loop through in reverse order, because that's simpler, given that we <br>  *   potentially delete ACEs as we loop through.  If started at 0 and went <br>  *   up, if we deleted the 0th ACE, then the 1th ACE would become the 0th, <br>  *   and we'd have to check the 0th ACE again <br>  * <br>  \**************************************************************************/ <br> <br>  for (dwAcl_i = asiAclSize.AceCount-1;  ((int)dwAcl_i) &gt;= 0;  dwAcl_i--) <br>  { <br>    /************************************************************************\ <br>    * <br>    * It doesn't matter for this sample that we don't yet know the ACE type, <br>    *   because they all start with the header field and that's what we need <br>    * <br>    \************************************************************************/ <br> <br>    if (!GetAce(paclFile, <br>                dwAcl_i, <br>                (LPVOID *)&amp;paaAllowedAce)) <br>    { PERR("GetAce"); <br>      return(FALSE); <br>    } <br> <br>    /************************************************************************\ <br>    * <br>    * There are only four Ace Types pre-defined, so this next check is <br>    *   redundant in a real app, but useful as a sanity check and a <br>    *   demonstration in a sample <br>    * <br>    \************************************************************************/ <br> <br>    if (!( (paaAllowedAce-&gt;Header.AceType == ACCESS_ALLOWED_ACE_TYPE) <br>         ||(paaAllowedAce-&gt;Header.AceType == ACCESS_DENIED_ACE_TYPE ) <br>         ||(paaAllowedAce-&gt;Header.AceType == SYSTEM_AUDIT_ACE_TYPE  ) <br>         ||(paaAllowedAce-&gt;Header.AceType == SYSTEM_ALARM_ACE_TYPE  ))) <br>    { PERR("Invalid AceType"); <br>      return(FALSE); <br>    } <br> <br>    { // Find SID of ACE, check if acct deleted <br> <br>      UCHAR        ucNameBuf      [SZ_ACCT_NAME_BUF]; <br>      DWORD        dwNameLength  = SZ_ACCT_NAME_BUF; <br>      UCHAR        ucDomainNmBuf  [SZ_DMN_NAME_BUF]; <br>      DWORD        dwDNameLength = SZ_DMN_NAME_BUF; <br>      SID_NAME_USE peAcctNameUse; <br>      DWORD        dwLastError   = NO_ERROR; <br> <br>      /**********************************************************************\ <br>      * <br>      * This validity check is here for demonstration pruposes.  It's not <br>      *   likely a real app would need to check the validity of the SID <br>      *   contained in the returned ACL.  The validity check APIs are more <br>      *   intended to check validity after app code has manipulated the <br>      *   structure and is about to hand it back to the system <br>      * <br>      \**********************************************************************/ <br> <br>      if (!IsValidSid((PSID)&amp;(paaAllowedAce-&gt;SidStart))) <br>      { PERR("IsValidSid said bad SID!"); <br>        return(FALSE); <br>      } <br> <br>      if (!LookupAccountSid <br>             ((LPTSTR)"",         // Look on local machine <br>             (PSID)&amp;(paaAllowedAce-&gt;SidStart), <br>             (LPTSTR)&amp;ucNameBuf, <br>             (LPDWORD)&amp;dwNameLength, <br>             (LPTSTR)&amp;ucDomainNmBuf, <br>             (LPDWORD)&amp;dwDNameLength, <br>             (PSID_NAME_USE)&amp;peAcctNameUse)) <br>      { dwLastError = GetLastError(); <br>        if (ERROR_NONE_MAPPED != dwLastError) <br>        { PERR("LookupAccountSID"); <br>          return(FALSE); <br>        } <br>      } <br> <br>      if (  (ERROR_NONE_MAPPED == dwLastError) <br>         || (SidTypeDeletedAccount == peAcctNameUse)) <br>      { <br>        dwACEsDeleted++; <br> <br>        if (bJustCount) <br>        { printf(" - would have edited ACL"); <br>          return(TRUE); <br>        } <br> <br>        if (!DeleteAce(paclFile,dwAcl_i)) <br>        { PERR("DeleteAce"); <br>          return(FALSE); <br>        } <br>      } <br>    } <br>  } <br> <br>  if (dwACEsDeletedBeforeNow &lt; dwACEsDeleted) <br>  { <br>    /************************************************************************\ <br>    * <br>    * This validity check is something a real app might actually like to do. <br>    *   We manupulated the ACL, so before we write it back into an SD, a check <br>    *   is worth considering <br>    * <br>    \************************************************************************/ <br> <br>    if (!IsValidAcl(paclFile)) <br>    { PERR("IsValidAcl said bad ACL!"); <br>      return(FALSE); <br>    } <br> <br>    /************************************************************************\ <br>    * <br>    * Modify the SD in virtual memory <br>    * <br>    \************************************************************************/ <br> <br>    if (!SetSecurityDescriptorDacl <br>           (psdFileSD, <br>            TRUE,                 // Yes, set the DACL <br>            paclFile, <br>            FALSE))               // New DACL explicitly specified <br>    { PERR("SetSecurityDescriptorDacl"); <br>      return(FALSE); <br>    } <br> <br>    /************************************************************************\ <br>    * <br>    * This validity check is something a real app might actually like to do. <br>    *   We manupulated the SD, so before we write it back out to the file <br>    *   system, a check is worth considering <br>    * <br>    \************************************************************************/ <br> <br>    if (!IsValidSecurityDescriptor(psdFileSD)) <br>    { PERR("IsValidSecurityDescriptor said bad SD"); <br>      return(FALSE); <br>    } <br> <br>    /************************************************************************\ <br>    * <br>    * Modify the SD on the hard disk <br>    * <br>    \************************************************************************/ <br> <br>    if (!SetFileSecurity <br>           (lpszFullName, <br>            (SECURITY_INFORMATION)DACL_SECURITY_INFORMATION, <br>            psdFileSD)) <br>    { PERR("SetFileSecurity"); <br>      return(FALSE); <br>    } <br> <br>    printf(" - edited ACL"); <br>  } <br> <br>  return(TRUE); <br> <br>} <br>  <br>/****************************************************************************\ <br>* <br>* FUNCTION: GetProcessSid <br>* <br>\****************************************************************************/ <br> <br>BOOL GetProcessSid(VOID) <br>{ <br>  HANDLE               hProcess; <br>  PSECURITY_DESCRIPTOR psdProcessSD; <br>  PSID                 psidProcessOwnerSIDTemp; <br> <br>  UCHAR                ucBuf       [SZ_REL_SD_BUF]; <br>  DWORD                dwSDLength = SZ_REL_SD_BUF; <br>  DWORD                dwSDLengthNeeded; <br>  BOOL                 bOwnerDefaulted; <br> <br>  hProcess = GetCurrentProcess(); <br> <br>  if (!hProcess) <br>  { PERR("GetCurrentProcess"); <br>    return(FALSE); <br>  } <br> <br>  psdProcessSD = (PSECURITY_DESCRIPTOR)ucBuf; <br> <br>  if (!GetKernelObjectSecurity <br>         (hProcess, <br>          (SECURITY_INFORMATION)(OWNER_SECURITY_INFORMATION), <br>          psdProcessSD, <br>          dwSDLength, <br>          (LPDWORD)&amp;dwSDLengthNeeded)) <br>  { PERR("GetKernelObjectSecurity on current process handle"); <br>    return(FALSE); <br>  } <br> <br>  /**************************************************************************\ <br>  * <br>  * This validity check is here for demonstration purposes.  It's not likely a <br>  *   real app would need to check the validity of this returned SD.  The <br>  *   validity check APIs are more intended to check validity after app code <br>  *   has manipulated the structure and is about to hand it back to the system <br>  * <br>  \**************************************************************************/ <br> <br>  if (!IsValidSecurityDescriptor(psdProcessSD)) <br>  { PERR("IsValidSecurityDescriptor said bad SD"); <br>    return(FALSE); <br>  } <br> <br>  if (!GetSecurityDescriptorOwner <br>         (psdProcessSD, <br>          (PSID *)&amp;psidProcessOwnerSIDTemp, <br>          (LPBOOL)&amp;bOwnerDefaulted)) <br>  { PERR("GetSecurityDescriptorOwner of current process"); <br>    return(FALSE); <br>  } <br> <br>  /**************************************************************************\ <br>  * <br>  * This validity check is here for demonstration pruposes.  It's not likely a <br>  *   real app would need to check the validity of this returned SID.  The <br>  *   validity check APIs are more intended to check validity after app code <br>  *   has manipulated the structure and is about to hand it back to the system <br>  * <br>  \**************************************************************************/ <br> <br>  if (!IsValidSid(psidProcessOwnerSIDTemp)) <br>  { PERR("IsValidSid said bad process SID!"); <br>    return(FALSE); <br>  } <br> <br>  /**************************************************************************\ <br>  * <br>  * On the other hand, we are about to call GetLengthSid on the returned SID, <br>  *   and calling GetLengthSid with an invalid SID is a bad idea, since then <br>  *   GetLengthSid's result is undefined, and an undefined result is hard to <br>  *   handle cleanly.  So, even in a real app, the above check on SID validity <br>  *   is a good idea to ensure the result GetLengthSid returns is valid <br>  * <br>  * It should be clear that the reason why the CopySid below is needed is that <br>  *   in the current routine the SID of the current process is on the stack <br>  *   (in the SD structure), so we have to copy the SID to static storage <br>  *   before the current routine returns <br>  * <br>  \**************************************************************************/ <br> <br>  { DWORD dwSIDLengthNeeded; <br> <br>    dwSIDLengthNeeded = GetLengthSid(psidProcessOwnerSIDTemp); <br> <br>    psidProcessOwnerSID = malloc(dwSIDLengthNeeded); <br> <br>    if (NULL == psidProcessOwnerSID) <br>      PERR("GetProcessSid - ran out of heap space"); <br> <br>    if (!CopySid(dwSIDLengthNeeded, <br>                 psidProcessOwnerSID, <br>                 psidProcessOwnerSIDTemp)) <br>    { PERR("CopySid"); <br>      return(FALSE); <br>    } <br>  } <br> <br> <br>  /**************************************************************************\ <br>  * <br>  * This validity check is here for demonstration pruposes only (see above). <br>  * <br>  \**************************************************************************/ <br> <br>  if (!IsValidSid(psidProcessOwnerSID)) <br>  { PERR("IsValidSid said bad process SID!"); <br>    return(FALSE); <br>  } <br> <br> <br>  /**************************************************************************\ <br>  * <br>  * Now ensure that two privileges are enabled in the access token of the <br>  *   current process <br>  * <br>  \**************************************************************************/ <br> <br>  { HANDLE           hAccessToken; <br>    LUID             luidPrivilegeLUID; <br>    TOKEN_PRIVILEGES tpTokenPrivilege; <br> <br>    if (!OpenProcessToken(hProcess, <br>                          TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, <br>                          &amp;hAccessToken)) <br>    { PERR("OpenProcessToken"); <br>      return(FALSE); <br>    } <br> <br>    /************************************************************************\ <br>    * <br>    * Get LUID of SeTakeOwnershipPrivilege privilege <br>    * <br>    \************************************************************************/ <br> <br>    if (!LookupPrivilegeValue(NULL, <br>                              "SeTakeOwnershipPrivilege", <br>                              &amp;luidPrivilegeLUID)) <br>    { PERR("LookupPrivilegeValue"); <br>      printf("\nThe above error means you need to use User Manager (menu item"); <br>      printf("\n  Policies\\UserRights) to turn on the 'Take ownership of...' "); <br>      printf("\n  privilege, log off, log back on"); <br>      return(FALSE); <br>    } <br> <br>    /************************************************************************\ <br>    * <br>    * Enable the SeTakeOwnershipPrivilege privilege using the LUID just <br>    *   obtained <br>    * <br>    \************************************************************************/ <br> <br>    tpTokenPrivilege.PrivilegeCount = 1; <br>    tpTokenPrivilege.Privileges[0].Luid = luidPrivilegeLUID; <br>    tpTokenPrivilege.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED; <br> <br>    AdjustTokenPrivileges (hAccessToken, <br>                           FALSE,  // Do not disable all <br>                           &amp;tpTokenPrivilege, <br>                           sizeof(TOKEN_PRIVILEGES), <br>                           NULL,   // Ignore previous info <br>                           NULL);  // Ignore previous info <br> <br>    if ( GetLastError() != NO_ERROR ) <br>    { PERR("AdjustTokenPrivileges"); <br>      return(FALSE); <br>    } <br> <br>    /************************************************************************\ <br>    * <br>    * Get LUID of SeSecurityPrivilege privilege <br>    * <br>    \************************************************************************/ <br> <br>    if (!LookupPrivilegeValue(NULL, <br>                              "SeSecurityPrivilege", <br>                              &amp;luidPrivilegeLUID)) <br>    { PERR("LookupPrivilegeValue"); <br>      printf("\nThe above error means you need to log on as an Administrator"); <br>      return(FALSE); <br>    } <br> <br>    /************************************************************************\ <br>    * <br>    * Enable the SeSecurityPrivilege privilege using the LUID just <br>    *   obtained <br>    * <br>    \************************************************************************/ <br> <br>    tpTokenPrivilege.PrivilegeCount = 1; <br>    tpTokenPrivilege.Privileges[0].Luid = luidPrivilegeLUID; <br>    tpTokenPrivilege.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED; <br> <br>    AdjustTokenPrivileges (hAccessToken, <br>                           FALSE,  // Do not disable all <br>                           &amp;tpTokenPrivilege, <br>                           sizeof(TOKEN_PRIVILEGES), <br>                           NULL,   // Ignore previous info <br>                           NULL);  // Ignore previous info <br> <br>    if ( GetLastError() != NO_ERROR ) <br>    { PERR("AdjustTokenPrivileges"); <br>      return(FALSE); <br>    } <br> <br>  } <br> <br>  return(TRUE); <br> <br>} <br>  <br>/****************************************************************************\ <br>* <br>* FUNCTION: CrackArgs <br>* <br>\****************************************************************************/ <br> <br>BOOL CrackArgs(UINT argc, char *argv[]) <br>{ <br>  char *p; <br> <br>  /**************************************************************************\ <br>  * <br>  * There must be three arguments <br>  * <br>  \**************************************************************************/ <br> <br>  if (argc != 4) <br>  { DisplayHelp(); <br>    return(FALSE); <br>  } <br> <br>  p=argv[1]; <br> <br>  /**************************************************************************\ <br>  * <br>  * The switch argument must be 2-5 chars long <br>  * <br>  \**************************************************************************/ <br> <br>  if ((strlen(p) &lt; 2) || (strlen(p) &gt; 5)) <br>  { DisplayHelp(); <br>    return(FALSE); <br>  } <br> <br>  /**************************************************************************\ <br>  * <br>  * The first char in the switch argument must be / <br>  * <br>  \**************************************************************************/ <br> <br>  if ('/' != *p) <br>  { DisplayHelp(); <br>    return(FALSE); <br>  } <br>  <br>  /**************************************************************************\ <br>  * <br>  * Chars 2-5 of the switch argument must be O or A or R or C <br>  * <br>  \**************************************************************************/ <br> <br>  for (p=p+1; *p; p++) <br>    switch (*p) <br>    { case 'o': <br>      case 'O': <br>        bTakeOwnership = TRUE; <br>        break; <br>      case 'a': <br>      case 'A': <br>        bEditACLs      = TRUE; <br>        break; <br>      case 'r': <br>      case 'R': <br>        bRecurse       = TRUE; <br>        break; <br>      case 'c': <br>      case 'C': <br>        bJustCount     = TRUE; <br>        break; <br>      default : <br>        DisplayHelp(); <br>        return(FALSE); <br>    } <br> <br>  /**************************************************************************\ <br>  * <br>  * Have to say one of O or A <br>  * <br>  \**************************************************************************/ <br> <br>  if (!(bTakeOwnership || bEditACLs)) <br>  { DisplayHelp(); <br>    return(FALSE); <br>  } <br> <br>  return(TRUE); <br>} <br>  <br>/****************************************************************************\ <br>* <br>* FUNCTION: DisplayHelp <br>* <br>\****************************************************************************/ <br> <br>VOID DisplayHelp(VOID) <br>{ <br>  printf("\nTo run type SIDCLEAN and 3 parameters.  Syntax:"); <br>  printf("\n  SIDCLEAN /roah dirspec filepattern"); <br>  printf("\n           /r    Recursively process subdirectories"); <br>  printf("\n           /o    For any files matching filepattern: Take ownership if"); <br>  printf("\n                   file currently owned by any deleted SID"); <br>  printf("\n           /a    For any files matching filepattern: Edit ACL, deleting"); <br>  printf("\n                   ACEs associated with any deleted SID"); <br>  printf("\n           /c    Overrides /o and /a, causes counts of /a or /o actions that"); <br>  printf("\n                   would take place if /c not used.  Counts always displayed"); <br>  printf("\n           /h    Override other switch values, just display this message\n"); <br>  printf("\n                 . and .. syntax allowed in dirspec"); <br>  printf("\n                 * and ? wildcards allowed in filepattern"); <br>  printf("\n                 Switch letters can be in any order, upper or lower case"); <br>  printf("\nExamples:"); <br>  printf("\n  SIDCLEAN /o  .  *.*  Take ownership of all files (but not subdirs) in "); <br>  printf("\n                         current dir that are owned by any deleted SID"); <br>  printf("\n  SIDCLEAN /a  .  *.*  For any file in current dir (but not subdirs), delete"); <br>  printf("\n                         any ACL info that is associated with any deleted SID"); <br>  printf("\n  SIDCLEAN /ro .  *.*  Same as first  example, but also recursively process"); <br>  printf("\n                         subdirectories"); <br>  printf("\n  SIDCLEAN /ar .  *.*  Same as second example, but also recursively process"); <br>  printf("\n                         subdirectories"); <br>  printf("\n  SIDCLEAN /O  \\  *.*  Same as first  example, but process files in root"); <br>  printf("\n                         of current drive"); <br>  printf("\n  SIDCLEAN /oC .. *.*  Same as first  example, but looks at files in dir"); </code></pre>
<p>
</p>
<pre><code>printf("\n                         containing current dir, processes nothing, just counts"); <br>  printf("\n  SIDCLEAN /A d:\\ *.*  Same as second example, but process files in root"); <br>  printf("\n                         of D: drive"); <br>  printf("\n  SIDCLEAN             Displays this message"); <br>  printf("\n  SIDCLEAN /h          Displays this message (so do ? -? /? -h -H /H)\n"); <br>  printf("\nThis utility must be run while logged on as Administrator\n"); <br> <br>  return; <br>} <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
