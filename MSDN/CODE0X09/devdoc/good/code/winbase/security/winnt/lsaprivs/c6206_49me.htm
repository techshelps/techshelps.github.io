<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>LSAPRIVS.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6206"></a>LSAPRIVS.C</h2>
<pre><code>/*++ <br> <br>Copyright 1996 - 1997 Microsoft Corporation <br> <br>Module Name: <br> <br>    privs.c <br> <br>Abstract: <br> <br>    This module illustrates how to use the Windows NT LSA security API <br>    to manage account privileges on the local or a remote machine. <br> <br>    When targetting a domain controller for privilege update operations, <br>    be sure to target the primary domain controller for the domain. <br>    The privilege settings are replicated by the primary domain controller <br>    to each backup domain controller as appropriate.  The NetGetDCName() <br>    Lan Manager API call can be used to get the primary domain controller <br>    computer name from a domain name. <br> <br>    For a list of privilges, consult winnt.h, and search for <br>    SE_ASSIGNPRIMARYTOKEN_NAME. <br> <br>    For a list of logon rights, which can also be assigned using this <br>    sample code, consult ntsecapi.h, and search for SE_BATCH_LOGON_NAME <br> <br>    You can use domain\account as argv[1]. For instance, mydomain\scott will <br>    grant the privilege to the mydomain domain account scott. <br> <br>    The optional target machine is specified as argv[2], otherwise, the <br>    account database is updated on the local machine. <br> <br>    The LSA APIs used by this sample are Unicode only. <br> <br>    Use LsaRemoveAccountRights() to remove account rights. <br> <br>Author: <br> <br>    Scott Field (sfield)    17-Apr-96 <br>        Minor cleanup <br> <br>    Scott Field (sfield)    12-Jul-95 <br> <br>--*/ <br> <br>#ifndef UNICODE <br>#define UNICODE <br>#endif // UNICODE <br> <br>#include &lt;windows.h&gt; <br>#include &lt;stdio.h&gt; <br> <br>#include "ntsecapi.h" <br> <br>NTSTATUS <br>OpenPolicy( <br>    LPWSTR ServerName,          // machine to open policy on (Unicode) <br>    DWORD DesiredAccess,        // desired access to policy <br>    PLSA_HANDLE PolicyHandle    // resultant policy handle <br>    ); <br> <br>BOOL <br>GetAccountSid( <br>    LPTSTR SystemName,          // where to lookup account <br>    LPTSTR AccountName,         // account of interest <br>    PSID *Sid                   // resultant buffer containing SID <br>    ); <br> <br>NTSTATUS <br>SetPrivilegeOnAccount( <br>    LSA_HANDLE PolicyHandle,    // open policy handle <br>    PSID AccountSid,            // SID to grant privilege to <br>    LPWSTR PrivilegeName,       // privilege to grant (Unicode) <br>    BOOL bEnable                // enable or disable <br>    ); <br> <br>void <br>InitLsaString( <br>    PLSA_UNICODE_STRING LsaString, // destination <br>    LPWSTR String                  // source (Unicode) <br>    ); <br> <br>void <br>DisplayNtStatus( <br>    LPSTR szAPI,                // pointer to function name (ANSI) <br>    NTSTATUS Status             // NTSTATUS error value <br>    ); <br> <br>void <br>DisplayWinError( <br>    LPSTR szAPI,                // pointer to function name (ANSI) <br>    DWORD WinError              // DWORD WinError <br>    ); <br> <br>#define RTN_OK 0 <br>#define RTN_USAGE 1 <br>#define RTN_ERROR 13 <br> <br>// <br>// If you have the ddk, include ntstatus.h. <br>// <br>#ifndef STATUS_SUCCESS <br>#define STATUS_SUCCESS  ((NTSTATUS)0x00000000L) <br>#endif <br> <br>int <br>__cdecl <br>main( <br>    int argc, <br>    char *argv[] <br>    ) <br>{ <br>    LSA_HANDLE PolicyHandle; <br> <br>    WCHAR wComputerName[256]=L"";   // static machine name buffer <br>    TCHAR AccountName[256];         // static account name buffer <br>    PSID pSid; <br> <br>    NTSTATUS Status; <br>    int iRetVal=RTN_ERROR;          // assume error from main <br> <br>    if(argc == 1) { <br>        fprintf(stderr,"Usage: %s &lt;Account&gt; [TargetMachine]\n", argv[0]); <br>        return RTN_USAGE; <br>    } <br> <br>    // <br>    // Pick up account name on argv[1]. <br>    // Assumes source is ANSI. Resultant string is ANSI or Unicode <br>    // <br>    wsprintf(AccountName, TEXT("%hS"), argv[1]); <br> <br>    // <br>    // Pick up machine name on argv[2], if appropriate <br>    // assumes source is ANSI. Resultant string is Unicode. <br>    // <br>    if(argc == 3) wsprintfW(wComputerName, L"%hS", argv[2]); <br> <br>    // <br>    // Open the policy on the target machine. <br>    // <br>    Status = OpenPolicy( <br>                wComputerName,      // target machine <br>                POLICY_CREATE_ACCOUNT | POLICY_LOOKUP_NAMES, <br>                &amp;PolicyHandle       // resultant policy handle <br>                ); <br> <br>    if(Status != STATUS_SUCCESS) { <br>        DisplayNtStatus("OpenPolicy", Status); <br>        return RTN_ERROR; <br>    } <br> <br>    // <br>    // Obtain the SID of the user/group. <br>    // Note that we could target a specific machine, but we don't. <br>    // Specifying NULL for target machine searches for the SID in the <br>    // following order: well-known, Built-in and local, primary domain, <br>    // trusted domains. <br>    // <br>    if(GetAccountSid( <br>            NULL,       // default lookup logic <br>            AccountName,// account to obtain SID <br>            &amp;pSid       // buffer to allocate to contain resultant SID <br>            )) { <br>        // <br>        // We only grant the privilege if we succeeded in obtaining the <br>        // SID. We can actually add SIDs which cannot be looked up, but <br>        // looking up the SID is a good sanity check which is suitable for <br>        // most cases. <br> <br>        // <br>        // Grant the SeServiceLogonRight to users represented by pSid. <br>        // <br>        Status = SetPrivilegeOnAccount( <br>                    PolicyHandle,           // policy handle <br>                    pSid,                   // SID to grant privilege <br>                    L"SeServiceLogonRight", // Unicode privilege <br>                    TRUE                    // enable the privilege <br>                    ); <br> <br>        if(Status == STATUS_SUCCESS) <br>            iRetVal = RTN_OK; <br>        else <br>            DisplayNtStatus("SetPrivilegeOnAccount", Status); <br>    } <br>    else { <br>        // <br>        // Error obtaining SID. <br>        // <br>        DisplayWinError("GetAccountSid", GetLastError()); <br>    } <br> <br>    // <br>    // Close the policy handle. <br>    // <br>    LsaClose(PolicyHandle); <br> <br>    // <br>    // Free memory allocated for SID. <br>    // <br>    if(pSid != NULL) HeapFree(GetProcessHeap(), 0, pSid); <br> <br>    return iRetVal; <br>} <br> <br>/*++ <br>This function attempts to obtain a SID representing the supplied <br>account on the supplied system. <br> <br>If the function succeeds, the return value is TRUE. A buffer is <br>allocated which contains the SID representing the supplied account. <br>This buffer should be freed when it is no longer needed by calling <br>HeapFree(GetProcessHeap(), 0, buffer) <br> <br>If the function fails, the return value is FALSE. Call GetLastError() <br>to obtain extended error information. <br> <br>Scott Field (sfield)    12-Jul-95 <br>--*/ <br> <br>BOOL <br>GetAccountSid( <br>    LPTSTR SystemName, <br>    LPTSTR AccountName, <br>    PSID *Sid <br>    ) <br>{ <br>    LPTSTR ReferencedDomain=NULL; <br>    DWORD cbSid=128;    // initial allocation attempt <br>    DWORD cchReferencedDomain=16; // initial allocation size <br>    SID_NAME_USE peUse; <br>    BOOL bSuccess=FALSE; // assume this function will fail <br> <br>    __try { <br> <br>    // <br>    // initial memory allocations <br>    // <br>    *Sid = (PSID)HeapAlloc(GetProcessHeap(), 0, cbSid); <br> <br>    if(*Sid == NULL) __leave; <br> <br>    ReferencedDomain = (LPTSTR)HeapAlloc( <br>                    GetProcessHeap(), <br>                    0, <br>                    cchReferencedDomain * sizeof(TCHAR) <br>                    ); <br> <br>    if(ReferencedDomain == NULL) __leave; <br> <br>    // <br>    // Obtain the SID of the specified account on the specified system. <br>    // <br>    while(!LookupAccountName( <br>                    SystemName,         // machine to lookup account on <br>                    AccountName,        // account to lookup <br>                    *Sid,               // SID of interest <br>                    &amp;cbSid,             // size of SID <br>                    ReferencedDomain,   // domain account was found on <br>                    &amp;cchReferencedDomain, <br>                    &amp;peUse <br>                    )) { <br>        if (GetLastError() == ERROR_INSUFFICIENT_BUFFER) { <br>            // <br>            // reallocate memory <br>            // <br>            *Sid = (PSID)HeapReAlloc( <br>                        GetProcessHeap(), <br>                        0, <br>                        *Sid, <br>                        cbSid <br>                        ); <br>            if(*Sid == NULL) __leave; <br> <br>            ReferencedDomain = (LPTSTR)HeapReAlloc( <br>                        GetProcessHeap(), <br>                        0, <br>                        ReferencedDomain, <br>                        cchReferencedDomain * sizeof(TCHAR) <br>                        ); <br>            if(ReferencedDomain == NULL) __leave; <br>        } <br>        else __leave; <br>    } <br> <br>    // <br>    // Indicate success. <br>    // <br>    bSuccess = TRUE; <br> <br>    } // try <br>    __finally { <br> <br>    // <br>    // Cleanup and indicate failure, if appropriate. <br>    // <br> <br>    HeapFree(GetProcessHeap(), 0, ReferencedDomain); <br> <br>    if(!bSuccess) { <br>        if(*Sid != NULL) { <br>            HeapFree(GetProcessHeap(), 0, *Sid); <br>            *Sid = NULL; <br>        } <br>    } <br> <br>    } // finally <br> <br>    return bSuccess; <br>} <br> <br>NTSTATUS <br>SetPrivilegeOnAccount( <br>    LSA_HANDLE PolicyHandle,    // open policy handle <br>    PSID AccountSid,            // SID to grant privilege to <br>    LPWSTR PrivilegeName,       // privilege to grant (Unicode) <br>    BOOL bEnable                // enable or disable <br>    ) <br>{ <br>    LSA_UNICODE_STRING PrivilegeString; <br> <br>    // <br>    // Create a LSA_UNICODE_STRING for the privilege name. <br>    // <br>    InitLsaString(&amp;PrivilegeString, PrivilegeName); <br> <br>    // <br>    // grant or revoke the privilege, accordingly <br>    // <br>    if(bEnable) { <br>        return LsaAddAccountRights( <br>                PolicyHandle,       // open policy handle <br>                AccountSid,         // target SID <br>                &amp;PrivilegeString,   // privileges <br>                1                   // privilege count <br>                ); <br>    } <br>    else { <br>        return LsaRemoveAccountRights( <br>                PolicyHandle,       // open policy handle <br>                AccountSid,         // target SID <br>                FALSE,              // do not disable all rights <br>                &amp;PrivilegeString,   // privileges <br>                1                   // privilege count <br>                ); <br>    } <br>} <br> <br>void <br>InitLsaString( <br>    PLSA_UNICODE_STRING LsaString, <br>    LPWSTR String <br>    ) <br>{ <br>    DWORD StringLength; <br> <br>    if(String == NULL) { <br>        LsaString-&gt;Buffer = NULL; <br>        LsaString-&gt;Length = 0; <br>        LsaString-&gt;MaximumLength = 0; <br>        return; <br>    } <br> <br>    StringLength = lstrlenW(String); <br>    LsaString-&gt;Buffer = String; <br>    LsaString-&gt;Length = (USHORT) StringLength * sizeof(WCHAR); <br>    LsaString-&gt;MaximumLength=(USHORT)(StringLength+1) * sizeof(WCHAR); <br>} <br> <br>NTSTATUS <br>OpenPolicy( <br>    LPWSTR ServerName, <br>    DWORD DesiredAccess, <br>    PLSA_HANDLE PolicyHandle <br>    ) <br>{ <br>    LSA_OBJECT_ATTRIBUTES ObjectAttributes; <br>    LSA_UNICODE_STRING ServerString; <br>    PLSA_UNICODE_STRING Server; <br> <br>    // <br>    // Always initialize the object attributes to all zeroes. <br>    // <br>    ZeroMemory(&amp;ObjectAttributes, sizeof(ObjectAttributes)); <br> <br>    if (ServerName != NULL) { <br>        // <br>        // Make a LSA_UNICODE_STRING out of the LPWSTR passed in <br>        // <br>        InitLsaString(&amp;ServerString, ServerName); <br>        Server = &amp;ServerString; <br>    } else { <br>        Server = NULL; <br>    } <br> <br>    // <br>    // Attempt to open the policy. <br>    // <br>    return LsaOpenPolicy( <br>                Server, <br>                &amp;ObjectAttributes, <br>                DesiredAccess, <br>                PolicyHandle <br>                ); <br>} <br> <br>void <br>DisplayNtStatus( <br>    LPSTR szAPI, <br>    NTSTATUS Status <br>    ) <br>{ <br>    // <br>    // Convert the NTSTATUS to Winerror. Then call DisplayWinError(). <br>    // <br>    DisplayWinError(szAPI, LsaNtStatusToWinError(Status)); <br>} <br> <br>void <br>DisplayWinError( <br>    LPSTR szAPI, <br>    DWORD WinError <br>    ) <br>{ <br>    LPSTR MessageBuffer; <br>    DWORD dwBufferLength; <br> <br>    // <br>    // TODO: Get this fprintf out of here! <br>    // <br>    fprintf(stderr,"%s error!\n", szAPI); <br> <br>    if(dwBufferLength=FormatMessageA( <br>                        FORMAT_MESSAGE_ALLOCATE_BUFFER | <br>                        FORMAT_MESSAGE_FROM_SYSTEM, <br>                        NULL, <br>                        WinError, <br>                        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), <br>                        (LPSTR) &amp;MessageBuffer, <br>                        0, <br>                        NULL <br>                        )) <br>    { <br>        DWORD dwBytesWritten; // unused <br> <br>        // <br>        // Output message string on stderr. <br>        // <br>        WriteFile( <br>            GetStdHandle(STD_ERROR_HANDLE), <br>            MessageBuffer, <br>            dwBufferLength, <br>            &amp;dwBytesWritten, <br>            NULL <br>            ); <br> <br>        // <br>        // Free the buffer allocated by the system. <br>        // <br>        LocalFree(MessageBuffer); <br>    } <br>} <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
