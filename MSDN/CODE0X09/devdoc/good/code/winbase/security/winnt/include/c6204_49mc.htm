<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SSPI.H</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6204"></a>SSPI.H</h2>
<pre><code>//+--------------------------------------------------------------------------- <br>// <br>//  Microsoft Windows <br>//  Copyright (C) Microsoft Corporation, 1992-1997. <br>// <br>//  File:       sspi.h <br>// <br>//  Contents:   Security Support Provider Interface <br>//              Prototypes and structure definitions <br>// <br>//  Functions:  Security Support Provider API <br>// <br>//  History:    11-24-93   RichardW   Created <br>// <br>//---------------------------------------------------------------------------- <br> <br>#ifndef __SSPI_H__ <br>#define __SSPI_H__ <br> <br> <br>// <br>// Determine environment: <br>// <br> <br>#ifdef SECURITY_WIN32 <br>#define ISSP_LEVEL  32 <br>#define ISSP_MODE   1 <br>#endif // SECURITY_WIN32 <br> <br>#ifdef SECURITY_WIN16 <br>#define ISSP_LEVEL  16 <br>#define ISSP_MODE   1 <br>#endif // SECURITY_WIN16 <br> <br>#ifdef SECURITY_KERNEL <br>#define ISSP_LEVEL  32 <br> <br>// <br>// SECURITY_KERNEL trumps SECURITY_WIN32.  Undefine ISSP_MODE so that <br>// we don't get redefine errors. <br>// <br>#ifdef ISSP_MODE <br>#undef ISSP_MODE <br>#endif <br>#define ISSP_MODE   0 <br>#endif // SECURITY_KERNEL <br> <br>#ifdef SECURITY_OS212 <br>#define ISSP_LEVEL  16 <br>#define ISSP_MODE   1 <br>#endif // SECURITY_OS212 <br> <br>#ifdef SECURITY_DOS <br>#define ISSP_LEVEL  16 <br>#define ISSP_MODE   1 <br>#endif // SECURITY_DOS <br> <br>#ifdef SECURITY_MAC <br>#define ISSP_LEVEL  32 <br>#define ISSP_MODE   1 <br>#endif // SECURITY_MAC <br> <br> <br>#ifndef ISSP_LEVEL <br>#error  You must define one of SECURITY_WIN32, SECURITY_WIN16, SECURITY_KERNEL <br>#error  SECURITY_DOS, SECURITY_MAC or SECURITY_OS212 <br>#endif // !ISSP_LEVEL <br> <br> <br>// <br>// Now, define platform specific mappings: <br>// <br> <br>#if ISSP_LEVEL == 16 <br> <br>typedef short SECURITY_STATUS; <br>typedef unsigned short SEC_WCHAR; <br>typedef char SEC_CHAR; <br>#define SEC_TEXT(_x_) _x_ <br> <br>#ifdef SECURITY_WIN16 <br> <br>#define SEC_FAR __far <br>#define SEC_ENTRY __pascal __far __export <br> <br>#else // SECURITY_WIN16 <br> <br>#define SEC_FAR __far <br>#define SEC_ENTRY __pascal __far __loadds <br>#pragma warning(disable:4147) <br> <br>#endif // SECURITY_WIN16 <br> <br>#elif defined(SECURITY_MAC)  // ISSP_LEVEL == 16 <br> <br>#define SEC_ENTRY <br>#define SEC_TEXT(_X_) _X_ <br>#define SEC_FAR <br> <br>typedef unsigned short SEC_WCHAR; <br>typedef char SEC_CHAR; <br>typedef long SECURITY_STATUS; <br> <br>// No Unicode on the Mac <br> <br>typedef SEC_CHAR SEC_FAR * SECURITY_PSTR; <br>typedef SEC_CHAR SEC_FAR * SECURITY_PCSTR; <br> <br>#else // ISSP_LEVEL == 16 <br> <br>// <br>// For NT-2 and up, wtypes will define HRESULT to be long. <br>// <br> <br>// begin_ntifs <br> <br>typedef WCHAR SEC_WCHAR; <br>typedef CHAR SEC_CHAR; <br> <br> <br>typedef LONG SECURITY_STATUS; <br> <br>#define SEC_TEXT TEXT <br>#define SEC_FAR <br>#define SEC_ENTRY __stdcall <br> <br>// end_ntifs <br> <br>// <br>// Decide what a string - 32 bits only since for 16 bits it is clear. <br>// <br> <br> <br>#ifdef UNICODE <br>typedef SEC_WCHAR SEC_FAR * SECURITY_PSTR; <br>typedef CONST SEC_WCHAR SEC_FAR * SECURITY_PCSTR; <br>#else // UNICODE <br>typedef SEC_CHAR SEC_FAR * SECURITY_PSTR; <br>typedef CONST SEC_CHAR SEC_FAR * SECURITY_PCSTR; <br>#endif // UNICODE <br> <br> <br>#endif // ISSP_LEVEL == 16 <br> <br>// <br>// Equivalent string for rpcrt: <br>// <br> <br>#define __SEC_FAR SEC_FAR <br> <br> <br>// <br>// Okay, security specific types: <br>// <br> <br>// begin_ntifs <br> <br>typedef struct _SecHandle <br>{ <br>    unsigned long dwLower; <br>    unsigned long dwUpper; <br>} SecHandle, SEC_FAR * PSecHandle; <br> <br>typedef SecHandle CredHandle; <br>typedef PSecHandle PCredHandle; <br> <br>typedef SecHandle CtxtHandle; <br>typedef PSecHandle PCtxtHandle; <br> <br>// end_ntifs <br> <br>#if ISSP_LEVEL == 32 <br> <br> <br>#  ifdef WIN32_CHICAGO <br> <br>typedef unsigned __int64 QWORD; <br>typedef QWORD SECURITY_INTEGER, *PSECURITY_INTEGER; <br>#define SEC_SUCCESS(Status) ((Status) &gt;= 0) <br> <br>#  elif defined(_NTDEF_) || defined(_WINNT_) <br> <br>typedef LARGE_INTEGER _SECURITY_INTEGER, SECURITY_INTEGER, *PSECURITY_INTEGER; // ntifs <br> <br>#  else // _NTDEF_ || _WINNT_ <br> <br>// BUGBUG:  Alignment for axp <br> <br>typedef struct _SECURITY_INTEGER <br>{ <br>    unsigned long LowPart; <br>    long HighPart; <br>} SECURITY_INTEGER, *PSECURITY_INTEGER; <br> <br>#  endif // _NTDEF_ || _WINNT_ <br> <br>#  ifndef SECURITY_MAC <br> <br>typedef SECURITY_INTEGER TimeStamp;                 // ntifs <br>typedef SECURITY_INTEGER SEC_FAR * PTimeStamp;      // ntifs <br> <br>#  else // SECURITY_MAC <br>typedef unsigned long TimeStamp; <br>typedef unsigned long * PTimeStamp; <br>#  endif // SECUIRT_MAC <br> <br>#else // ISSP_LEVEL == 32 <br> <br>typedef unsigned long TimeStamp; <br>typedef unsigned long SEC_FAR * PTimeStamp; <br>#  ifdef WIN32_CHICAGO <br>typedef TimeStamp LARGE_INTEGER; <br>#endif // WIN32_CHICAGO <br> <br>#endif // ISSP_LEVEL == 32 <br> <br> <br>// <br>// If we are in 32 bit mode, define the SECURITY_STRING structure, <br>// as a clone of the base UNICODE_STRING structure.  This is used <br>// internally in security components, an as the string interface <br>// for kernel components (e.g. FSPs) <br>// <br> <br>#if ISSP_LEVEL == 32 <br>#  ifndef _NTDEF_ <br>typedef struct _SECURITY_STRING { <br>    unsigned short      Length; <br>    unsigned short      MaximumLength; <br>#    ifdef MIDL_PASS <br>    [size_is(MaximumLength / 2), length_is(Length / 2)] <br>#    endif // MIDL_PASS <br>    unsigned short *    Buffer; <br>} SECURITY_STRING, * PSECURITY_STRING; <br>#  else // _NTDEF_ <br>typedef UNICODE_STRING SECURITY_STRING, *PSECURITY_STRING;  // ntifs <br>#  endif // _NTDEF_ <br>#endif // ISSP_LEVEL == 32 <br> <br> <br>// begin_ntifs <br> <br>// <br>// SecPkgInfo structure <br>// <br>//  Provides general information about a security provider <br>// <br> <br>typedef struct _SecPkgInfoW <br>{ <br>    unsigned long fCapabilities;        // Capability bitmask <br>    unsigned short wVersion;            // Version of driver <br>    unsigned short wRPCID;              // ID for RPC Runtime <br>    unsigned long cbMaxToken;           // Size of authentication token (max) <br>#ifdef MIDL_PASS <br>    [string] <br>#endif <br>    SEC_WCHAR SEC_FAR * Name;           // Text name <br> <br>#ifdef MIDL_PASS <br>    [string] <br>#endif <br>    SEC_WCHAR SEC_FAR * Comment;        // Comment <br>} SecPkgInfoW, SEC_FAR * PSecPkgInfoW; <br> <br>// end_ntifs <br> <br>typedef struct _SecPkgInfoA <br>{ <br>    unsigned long fCapabilities;        // Capability bitmask <br>    unsigned short wVersion;            // Version of driver <br>    unsigned short wRPCID;              // ID for RPC Runtime <br>    unsigned long cbMaxToken;           // Size of authentication token (max) <br>#ifdef MIDL_PASS <br>    [string] <br>#endif <br>    SEC_CHAR SEC_FAR * Name;            // Text name <br> <br>#ifdef MIDL_PASS <br>    [string] <br>#endif <br>    SEC_CHAR SEC_FAR * Comment;         // Comment <br>} SecPkgInfoA, SEC_FAR * PSecPkgInfoA; <br> <br>#ifdef UNICODE <br>#  define SecPkgInfo SecPkgInfoW        // ntifs <br>#  define PSecPkgInfo PSecPkgInfoW      // ntifs <br>#else <br>#  define SecPkgInfo SecPkgInfoA <br>#  define PSecPkgInfo PSecPkgInfoA <br>#endif // !UNICODE <br> <br>// begin_ntifs <br> <br>// <br>//  Security Package Capabilities <br>// <br>#define SECPKG_FLAG_INTEGRITY       0x00000001  // Supports integrity on messages <br>#define SECPKG_FLAG_PRIVACY         0x00000002  // Supports privacy (confidentiality) <br>#define SECPKG_FLAG_TOKEN_ONLY      0x00000004  // Only security token needed <br>#define SECPKG_FLAG_DATAGRAM        0x00000008  // Datagram RPC support <br>#define SECPKG_FLAG_CONNECTION      0x00000010  // Connection oriented RPC support <br>#define SECPKG_FLAG_MULTI_REQUIRED  0x00000020  // Full 3-leg required for re-auth. <br>#define SECPKG_FLAG_CLIENT_ONLY     0x00000040  // Server side functionality not available <br>#define SECPKG_FLAG_EXTENDED_ERROR  0x00000080  // Supports extended error msgs <br>#define SECPKG_FLAG_IMPERSONATION   0x00000100  // Supports impersonation <br>#define SECPKG_FLAG_ACCEPT_WIN32_NAME   0x00000200  // Accepts Win32 names <br>#define SECPKG_FLAG_STREAM          0x00000400  // Supports stream semantics <br>#define SECPKG_FLAG_NEGOTIABLE      0x00000800  // Can be used by the negotiate package <br>#define SECPKG_FLAG_GSS_COMPATIBLE  0x00001000  // GSS Compatibility Available <br>#define SECPKG_FLAG_LOGON           0x00002000  // Supports common LsaLogonUser <br> <br> <br>#define SECPKG_ID_NONE      0xFFFF <br> <br> <br>// <br>// SecBuffer <br>// <br>//  Generic memory descriptors for buffers passed in to the security <br>//  API <br>// <br> <br>typedef struct _SecBuffer { <br>    unsigned long cbBuffer;             // Size of the buffer, in bytes <br>    unsigned long BufferType;           // Type of the buffer (below) <br>    void SEC_FAR * pvBuffer;            // Pointer to the buffer <br>} SecBuffer, SEC_FAR * PSecBuffer; <br> <br>typedef struct _SecBufferDesc { <br>    unsigned long ulVersion;            // Version number <br>    unsigned long cBuffers;             // Number of buffers <br>#ifdef MIDL_PASS <br>    [size_is(cBuffers)] <br>#endif <br>    PSecBuffer pBuffers;                // Pointer to array of buffers <br>} SecBufferDesc, SEC_FAR * PSecBufferDesc; <br> <br>#define SECBUFFER_VERSION           0 <br> <br>#define SECBUFFER_EMPTY             0   // Undefined, replaced by provider <br>#define SECBUFFER_DATA              1   // Packet data <br>#define SECBUFFER_TOKEN             2   // Security token <br>#define SECBUFFER_PKG_PARAMS        3   // Package specific parameters <br>#define SECBUFFER_MISSING           4   // Missing Data indicator <br>#define SECBUFFER_EXTRA             5   // Extra data <br>#define SECBUFFER_STREAM_TRAILER    6   // Security Trailer <br>#define SECBUFFER_STREAM_HEADER     7   // Security Header <br>#define SECBUFFER_NEGOTIATION_INFO  8   // Hints from the negotiation pkg <br> <br>#define SECBUFFER_ATTRMASK          0xF0000000 <br>#define SECBUFFER_READONLY          0x80000000  // Buffer is read-only <br>#define SECBUFFER_RESERVED          0x40000000 <br> <br>typedef struct _SEC_NEGOTIATION_INFO { <br>    unsigned long       Size;           // Size of this structure <br>    unsigned long       NameLength;     // Length of name hint <br>    SEC_WCHAR SEC_FAR * Name;           // Name hint <br>    void SEC_FAR *      Reserved;       // Reserved <br>} SEC_NEGOTIATION_INFO, SEC_FAR * PSEC_NEGOTIATION_INFO ; <br> <br>// <br>//  Data Representation Constant: <br>// <br>#define SECURITY_NATIVE_DREP        0x00000010 <br>#define SECURITY_NETWORK_DREP       0x00000000 <br> <br>// <br>//  Credential Use Flags <br>// <br>#define SECPKG_CRED_INBOUND         0x00000001 <br>#define SECPKG_CRED_OUTBOUND        0x00000002 <br>#define SECPKG_CRED_BOTH            0x00000003 <br> <br>// <br>//  InitializeSecurityContext Requirement and return flags: <br>// <br> <br>#define ISC_REQ_DELEGATE                0x00000001 <br>#define ISC_REQ_MUTUAL_AUTH             0x00000002 <br>#define ISC_REQ_REPLAY_DETECT           0x00000004 <br>#define ISC_REQ_SEQUENCE_DETECT         0x00000008 <br>#define ISC_REQ_CONFIDENTIALITY         0x00000010 <br>#define ISC_REQ_USE_SESSION_KEY         0x00000020 <br>#define ISC_REQ_PROMPT_FOR_CREDS        0x00000040 <br>#define ISC_REQ_USE_SUPPLIED_CREDS      0x00000080 <br>#define ISC_REQ_ALLOCATE_MEMORY         0x00000100 <br>#define ISC_REQ_USE_DCE_STYLE           0x00000200 <br>#define ISC_REQ_DATAGRAM                0x00000400 <br>#define ISC_REQ_CONNECTION              0x00000800 <br>#define ISC_REQ_CALL_LEVEL              0x00001000 <br>#define ISC_REQ_EXTENDED_ERROR          0x00004000 <br>#define ISC_REQ_STREAM                  0x00008000 <br>#define ISC_REQ_INTEGRITY               0x00010000 <br>#define ISC_REQ_IDENTIFY                0x00020000 <br>#define ISC_REQ_NULL_SESSION            0x00040000 <br> <br>#define ISC_RET_DELEGATE                0x00000001 <br>#define ISC_RET_MUTUAL_AUTH             0x00000002 <br>#define ISC_RET_REPLAY_DETECT           0x00000004 <br>#define ISC_RET_SEQUENCE_DETECT         0x00000008 <br>#define ISC_RET_CONFIDENTIALITY         0x00000010 <br>#define ISC_RET_USE_SESSION_KEY         0x00000020 <br>#define ISC_RET_USED_COLLECTED_CREDS    0x00000040 <br>#define ISC_RET_USED_SUPPLIED_CREDS     0x00000080 <br>#define ISC_RET_ALLOCATED_MEMORY        0x00000100 <br>#define ISC_RET_USED_DCE_STYLE          0x00000200 <br>#define ISC_RET_DATAGRAM                0x00000400 <br>#define ISC_RET_CONNECTION              0x00000800 <br>#define ISC_RET_INTERMEDIATE_RETURN     0x00001000 <br>#define ISC_RET_CALL_LEVEL              0x00002000 <br>#define ISC_RET_EXTENDED_ERROR          0x00004000 <br>#define ISC_RET_STREAM                  0x00008000 <br>#define ISC_RET_INTEGRITY               0x00010000 <br>#define ISC_RET_IDENTIFY                0x00020000 <br>#define ISC_RET_NULL_SESSION            0x00040000 <br> <br>#define ASC_REQ_DELEGATE                0x00000001 <br>#define ASC_REQ_MUTUAL_AUTH             0x00000002 <br>#define ASC_REQ_REPLAY_DETECT           0x00000004 <br>#define ASC_REQ_SEQUENCE_DETECT         0x00000008 <br>#define ASC_REQ_CONFIDENTIALITY         0x00000010 <br>#define ASC_REQ_USE_SESSION_KEY         0x00000020 <br>#define ASC_REQ_ALLOCATE_MEMORY         0x00000100 <br>#define ASC_REQ_USE_DCE_STYLE           0x00000200 <br>#define ASC_REQ_DATAGRAM                0x00000400 <br>#define ASC_REQ_CONNECTION              0x00000800 <br>#define ASC_REQ_CALL_LEVEL              0x00001000 <br>#define ASC_REQ_EXTENDED_ERROR          0x00008000 <br>#define ASC_REQ_STREAM                  0x00010000 <br>#define ASC_REQ_INTEGRITY               0x00020000 <br>#define ASC_REQ_LICENSING               0x00040000 <br>#define ASC_REQ_IDENTIFY                0x00080000 <br>#define ASC_REQ_ALLOW_NULL_SESSION      0x00100000 <br> <br>#define ASC_RET_DELEGATE                0x00000001 <br>#define ASC_RET_MUTUAL_AUTH             0x00000002 <br>#define ASC_RET_REPLAY_DETECT           0x00000004 <br>#define ASC_RET_SEQUENCE_DETECT         0x00000008 <br>#define ASC_RET_CONFIDENTIALITY         0x00000010 <br>#define ASC_RET_USE_SESSION_KEY         0x00000020 <br>#define ASC_RET_ALLOCATED_MEMORY        0x00000100 <br>#define ASC_RET_USED_DCE_STYLE          0x00000200 <br>#define ASC_RET_DATAGRAM                0x00000400 <br>#define ASC_RET_CONNECTION              0x00000800 <br>#define ASC_RET_CALL_LEVEL              0x00002000 // skipped 1000 to be like ISC_ <br>#define ASC_RET_THIRD_LEG_FAILED        0x00004000 <br>#define ASC_RET_EXTENDED_ERROR          0x00008000 <br>#define ASC_RET_STREAM                  0x00010000 <br>#define ASC_RET_INTEGRITY               0x00020000 <br>#define ASC_RET_LICENSING               0x00040000 <br>#define ASC_RET_IDENTIFY                0x00080000 <br>#define ASC_RET_NULL_SESSION            0x00100000 <br> <br>// <br>//  Security Credentials Attributes: <br>// <br> <br>#define SECPKG_CRED_ATTR_NAMES 1 <br> <br>typedef struct _SecPkgCredentials_NamesW <br>{ <br>    SEC_WCHAR SEC_FAR * sUserName; <br>} SecPkgCredentials_NamesW, SEC_FAR * PSecPkgCredentials_NamesW; <br> <br>// end_ntifs <br> <br>typedef struct _SecPkgCredentials_NamesA <br>{ <br>    SEC_CHAR SEC_FAR * sUserName; <br>} SecPkgCredentials_NamesA, SEC_FAR * PSecPkgCredentials_NamesA; <br> <br>#ifdef UNICODE <br>#  define SecPkgCredentials_Names SecPkgCredentials_NamesW      // ntifs <br>#  define PSecPkgCredentials_Names PSecPkgCredentials_NamesW    // ntifs <br>#else <br>#  define SecPkgCredentials_Names SecPkgCredentials_NamesA <br>#  define PSecPkgCredentials_Names PSecPkgCredentials_NamesA <br>#endif // !UNICODE <br> <br>// begin_ntifs <br> <br>// <br>//  Security Context Attributes: <br>// <br> <br>#define SECPKG_ATTR_SIZES           0 <br>#define SECPKG_ATTR_NAMES           1 <br>#define SECPKG_ATTR_LIFESPAN        2 <br>#define SECPKG_ATTR_DCE_INFO        3 <br>#define SECPKG_ATTR_STREAM_SIZES    4 <br>#define SECPKG_ATTR_KEY_INFO        5 <br>#define SECPKG_ATTR_AUTHORITY       6 <br>#define SECPKG_ATTR_PROTO_INFO      7 <br>#define SECPKG_ATTR_PASSWORD_EXPIRY 8 <br>#define SECPKG_ATTR_SESSION_KEY     9 <br>#define SECPKG_ATTR_PACKAGE_INFO    10 <br> <br>typedef struct _SecPkgContext_Sizes <br>{ <br>    unsigned long cbMaxToken; <br>    unsigned long cbMaxSignature; <br>    unsigned long cbBlockSize; <br>    unsigned long cbSecurityTrailer; <br>} SecPkgContext_Sizes, SEC_FAR * PSecPkgContext_Sizes; <br> <br>typedef struct _SecPkgContext_StreamSizes <br>{ <br>    unsigned long   cbHeader; <br>    unsigned long   cbTrailer; <br>    unsigned long   cbMaximumMessage; <br>    unsigned long   cBuffers; <br>    unsigned long   cbBlockSize; <br>} SecPkgContext_StreamSizes, * PSecPkgContext_StreamSizes; <br> <br>typedef struct _SecPkgContext_NamesW <br>{ <br>    SEC_WCHAR SEC_FAR * sUserName; <br>} SecPkgContext_NamesW, SEC_FAR * PSecPkgContext_NamesW; <br> <br>// end_ntifs <br> <br>typedef struct _SecPkgContext_NamesA <br>{ <br>    SEC_CHAR SEC_FAR * sUserName; <br>} SecPkgContext_NamesA, SEC_FAR * PSecPkgContext_NamesA; <br> <br>#ifdef UNICODE <br>#  define SecPkgContext_Names SecPkgContext_NamesW          // ntifs <br>#  define PSecPkgContext_Names PSecPkgContext_NamesW        // ntifs <br>#else <br>#  define SecPkgContext_Names SecPkgContext_NamesA <br>#  define PSecPkgContext_Names PSecPkgContext_NamesA <br>#endif // !UNICODE <br> <br>// begin_ntifs <br> <br>typedef struct _SecPkgContext_Lifespan <br>{ <br>    TimeStamp tsStart; <br>    TimeStamp tsExpiry; <br>} SecPkgContext_Lifespan, SEC_FAR * PSecPkgContext_Lifespan; <br> <br>typedef struct _SecPkgContext_DceInfo <br>{ <br>    unsigned long AuthzSvc; <br>    void SEC_FAR * pPac; <br>} SecPkgContext_DceInfo, SEC_FAR * PSecPkgContext_DceInfo; <br> <br>// end_ntifs <br> <br>typedef struct _SecPkgContext_KeyInfoA <br>{ <br>    SEC_CHAR SEC_FAR *  sSignatureAlgorithmName; <br>    SEC_CHAR SEC_FAR *  sEncryptAlgorithmName; <br>    unsigned long       KeySize; <br>    unsigned long       SignatureAlgorithm; <br>    unsigned long       EncryptAlgorithm; <br>} SecPkgContext_KeyInfoA, SEC_FAR * PSecPkgContext_KeyInfoA; <br> <br>// begin_ntifs <br> <br>typedef struct _SecPkgContext_KeyInfoW <br>{ <br>    SEC_WCHAR SEC_FAR * sSignatureAlgorithmName; <br>    SEC_WCHAR SEC_FAR * sEncryptAlgorithmName; <br>    unsigned long       KeySize; <br>    unsigned long       SignatureAlgorithm; <br>    unsigned long       EncryptAlgorithm; <br>} SecPkgContext_KeyInfoW, SEC_FAR * PSecPkgContext_KeyInfoW; <br> <br>// end_ntifs <br> <br>#ifdef UNICODE <br>#define SecPkgContext_KeyInfo   SecPkgContext_KeyInfoW      // ntifs <br>#define PSecPkgContext_KeyInfo  PSecPkgContext_KeyInfoW     // ntifs <br>#else <br>#define SecPkgContext_KeyInfo   SecPkgContext_KeyInfoA <br>#define PSecPkgContext_KeyInfo  PSecPkgContext_KeyInfoA <br>#endif <br> <br>typedef struct _SecPkgContext_AuthorityA <br>{ <br>    SEC_CHAR SEC_FAR *  sAuthorityName; <br>} SecPkgContext_AuthorityA, * PSecPkgContext_AuthorityA; <br> <br>// begin_ntifs <br> <br>typedef struct _SecPkgContext_AuthorityW <br>{ <br>    SEC_WCHAR SEC_FAR * sAuthorityName; <br>} SecPkgContext_AuthorityW, * PSecPkgContext_AuthorityW; <br> <br>// end_ntifs <br> <br>#ifdef UNICODE <br>#define SecPkgContext_Authority SecPkgContext_AuthorityW        // ntifs <br>#define PSecPkgContext_Authority    PSecPkgContext_AuthorityW   // ntifs <br>#else <br>#define SecPkgContext_Authority SecPkgContext_AuthorityA <br>#define PSecPkgContext_Authority    PSecPkgContext_AuthorityA <br>#endif <br> <br>typedef struct _SecPkgContext_ProtoInfoA <br>{ <br>    SEC_CHAR SEC_FAR *  sProtocolName; <br>    unsigned long       majorVersion; <br>    unsigned long       minorVersion; <br>} SecPkgContext_ProtoInfoA, SEC_FAR * PSecPkgContext_ProtoInfoA; <br> <br>// begin_ntifs <br> <br>typedef struct _SecPkgContext_ProtoInfoW <br>{ <br>    SEC_WCHAR SEC_FAR * sProtocolName; <br>    unsigned long       majorVersion; <br>    unsigned long       minorVersion; <br>} SecPkgContext_ProtoInfoW, SEC_FAR * PSecPkgContext_ProtoInfoW; <br> <br>// end_ntifs <br> <br>#ifdef UNICODE <br>#define SecPkgContext_ProtoInfo   SecPkgContext_ProtoInfoW      // ntifs <br>#define PSecPkgContext_ProtoInfo  PSecPkgContext_ProtoInfoW     // ntifs <br>#else <br>#define SecPkgContext_ProtoInfo   SecPkgContext_ProtoInfoA <br>#define PSecPkgContext_ProtoInfo  PSecPkgContext_ProtoInfoA <br>#endif <br> <br>// begin_ntifs <br> <br>typedef struct _SecPkgContext_PasswordExpiry <br>{ <br>    TimeStamp tsPasswordExpires; <br>} SecPkgContext_PasswordExpiry, SEC_FAR * PSecPkgContext_PasswordExpiry; <br> <br>typedef struct _SecPkgContext_SessionKey <br>{ <br>    unsigned long SessionKeyLength; <br>    unsigned char SEC_FAR * SessionKey; <br>} SecPkgContext_SessionKey, *PSecPkgContext_SessionKey; <br> <br>// end_ntifs <br>// begin_ntifs <br> <br> <br>typedef struct _SecPkgContext_PackageInfoW <br>{ <br>    PSecPkgInfoW PackageInfo; <br>} SecPkgContext_PackageInfoW, SEC_FAR * PSecPkgContext_PackageInfoW; <br> <br>// end_ntifs <br> <br>typedef struct _SecPkgContext_PackageInfoA <br>{ <br>    PSecPkgInfoA PackageInfo; <br>} SecPkgContext_PackageInfoA, SEC_FAR * PSecPkgContext_PackageInfoA; <br> <br> <br>#ifdef UNICODE <br>#define SecPkgContext_PackageInfo   SecPkgContext_PackageInfoW      // ntifs <br>#define PSecPkgContext_PackageInfo  PSecPkgContext_PackageInfoW     // ntifs <br>#else <br>#define SecPkgContext_PackageInfo   SecPkgContext_PackageInfoA <br>#define PSecPkgContext_PackageInfo  PSecPkgContext_PackageInfoA <br>#endif <br> <br>// begin_ntifs <br> <br>typedef void <br>(SEC_ENTRY SEC_FAR * SEC_GET_KEY_FN) ( <br>    void SEC_FAR * Arg,                 // Argument passed in <br>    void SEC_FAR * Principal,           // Principal ID <br>    unsigned long KeyVer,               // Key Version <br>    void SEC_FAR * SEC_FAR * Key,       // Returned ptr to key <br>    SECURITY_STATUS SEC_FAR * Status    // returned status <br>    ); <br> <br>// <br>// Flags for ExportSecurityContext <br>// <br> <br>#define SECPKG_CONTEXT_EXPORT_RESET_NEW         0x00000001      // New context is reset to initial state <br>#define SECPKG_CONTEXT_EXPORT_DELETE_OLD        0x00000002      // Old context is deleted during export <br> <br> <br>SECURITY_STATUS SEC_ENTRY <br>AcquireCredentialsHandleW( <br>#if ISSP_MODE == 0                      // For Kernel mode <br>    PSECURITY_STRING pPrincipal, <br>    PSECURITY_STRING pPackage, <br>#else <br>    SEC_WCHAR SEC_FAR * pszPrincipal,   // Name of principal <br>    SEC_WCHAR SEC_FAR * pszPackage,     // Name of package <br>#endif <br>    unsigned long fCredentialUse,       // Flags indicating use <br>    void SEC_FAR * pvLogonId,           // Pointer to logon ID <br>    void SEC_FAR * pAuthData,           // Package specific data <br>    SEC_GET_KEY_FN pGetKeyFn,           // Pointer to GetKey() func <br>    void SEC_FAR * pvGetKeyArgument,    // Value to pass to GetKey() <br>    PCredHandle phCredential,           // (out) Cred Handle <br>    PTimeStamp ptsExpiry                // (out) Lifetime (optional) <br>    ); <br> <br>typedef SECURITY_STATUS <br>(SEC_ENTRY * ACQUIRE_CREDENTIALS_HANDLE_FN_W)( <br>#if ISSP_MODE == 0 <br>    PSECURITY_STRING, <br>    PSECURITY_STRING, <br>#else <br>    SEC_WCHAR SEC_FAR *, <br>    SEC_WCHAR SEC_FAR *, <br>#endif <br>    unsigned long, <br>    void SEC_FAR *, <br>    void SEC_FAR *, <br>    SEC_GET_KEY_FN, <br>    void SEC_FAR *, <br>    PCredHandle, <br>    PTimeStamp); <br> <br>// end_ntifs <br> <br>SECURITY_STATUS SEC_ENTRY <br>AcquireCredentialsHandleA( <br>    SEC_CHAR SEC_FAR * pszPrincipal,    // Name of principal <br>    SEC_CHAR SEC_FAR * pszPackage,      // Name of package <br>    unsigned long fCredentialUse,       // Flags indicating use <br>    void SEC_FAR * pvLogonId,           // Pointer to logon ID <br>    void SEC_FAR * pAuthData,           // Package specific data <br>    SEC_GET_KEY_FN pGetKeyFn,           // Pointer to GetKey() func <br>    void SEC_FAR * pvGetKeyArgument,    // Value to pass to GetKey() <br>    PCredHandle phCredential,           // (out) Cred Handle <br>    PTimeStamp ptsExpiry                // (out) Lifetime (optional) <br>    ); <br> <br>typedef SECURITY_STATUS <br>(SEC_ENTRY * ACQUIRE_CREDENTIALS_HANDLE_FN_A)( <br>    SEC_CHAR SEC_FAR *, <br>    SEC_CHAR SEC_FAR *, <br>    unsigned long, <br>    void SEC_FAR *, <br>    void SEC_FAR *, <br>    SEC_GET_KEY_FN, <br>    void SEC_FAR *, <br>    PCredHandle, <br>    PTimeStamp); <br> <br>#ifdef UNICODE <br>#  define AcquireCredentialsHandle AcquireCredentialsHandleW            // ntifs <br>#  define ACQUIRE_CREDENTIALS_HANDLE_FN ACQUIRE_CREDENTIALS_HANDLE_FN_W // ntifs <br>#else <br>#  define AcquireCredentialsHandle AcquireCredentialsHandleA <br>#  define ACQUIRE_CREDENTIALS_HANDLE_FN ACQUIRE_CREDENTIALS_HANDLE_FN_A <br>#endif // !UNICODE <br> <br>// begin_ntifs <br> <br>SECURITY_STATUS SEC_ENTRY <br>FreeCredentialsHandle( <br>    PCredHandle phCredential            // Handle to free <br>    ); <br> <br>typedef SECURITY_STATUS <br>(SEC_ENTRY * FREE_CREDENTIALS_HANDLE_FN)( <br>    PCredHandle ); <br> <br>#ifdef WIN32_CHICAGO <br>SECURITY_STATUS SEC_ENTRY <br>SspiLogonUserW( <br>    SEC_WCHAR SEC_FAR * pszPackage,     // Name of package <br>    SEC_WCHAR SEC_FAR * pszUserName,     // Name of package <br>    SEC_WCHAR SEC_FAR * pszDomainName,     // Name of package <br>    SEC_WCHAR SEC_FAR * pszPassword      // Name of package <br>    ); <br> <br>typedef SECURITY_STATUS <br>(SEC_ENTRY * SSPI_LOGON_USER_FN_W)( <br>    SEC_CHAR SEC_FAR *, <br>    SEC_CHAR SEC_FAR *, <br>    SEC_CHAR SEC_FAR *, <br>    SEC_CHAR SEC_FAR *); <br> <br>SECURITY_STATUS SEC_ENTRY <br>SspiLogonUserA( <br>    SEC_CHAR SEC_FAR * pszPackage,     // Name of package <br>    SEC_CHAR SEC_FAR * pszUserName,     // Name of package <br>    SEC_CHAR SEC_FAR * pszDomainName,     // Name of package <br>    SEC_CHAR SEC_FAR * pszPassword      // Name of package <br>    ); <br> <br>typedef SECURITY_STATUS <br>(SEC_ENTRY * SSPI_LOGON_USER_FN_A)( <br>    SEC_CHAR SEC_FAR *, <br>    SEC_CHAR SEC_FAR *, <br>    SEC_CHAR SEC_FAR *, <br>    SEC_CHAR SEC_FAR *); <br> <br>#ifdef UNICODE <br>#define SspiLogonUser SspiLogonUserW            // ntifs <br>#define SSPI_LOGON_USER_FN SSPI_LOGON_USER_FN_W <br>#else <br>#define SspiLogonUser SspiLogonUserA <br>#define SSPI_LOGON_USER_FN SSPI_LOGON_USER_FN_A <br>#endif // !UNICODE <br>#endif // WIN32_CHICAGO <br> <br>// end_ntifs <br> <br>// begin_ntifs <br> <br>//////////////////////////////////////////////////////////////////////// <br>/// <br>/// Context Management Functions <br>/// <br>//////////////////////////////////////////////////////////////////////// <br> <br>SECURITY_STATUS SEC_ENTRY <br>InitializeSecurityContextW( <br>    PCredHandle phCredential,               // Cred to base context <br>    PCtxtHandle phContext,                  // Existing context (OPT) <br>#if ISSP_MODE == 0 <br>    PSECURITY_STRING pTargetName, <br>#else <br>    SEC_WCHAR SEC_FAR * pszTargetName,      // Name of target <br>#endif <br>    unsigned long fContextReq,              // Context Requirements <br>    unsigned long Reserved1,                // Reserved, MBZ <br>    unsigned long TargetDataRep,            // Data rep of target <br>    PSecBufferDesc pInput,                  // Input Buffers <br>    unsigned long Reserved2,                // Reserved, MBZ <br>    PCtxtHandle phNewContext,               // (out) New Context handle <br>    PSecBufferDesc pOutput,                 // (inout) Output Buffers <br>    unsigned long SEC_FAR * pfContextAttr,  // (out) Context attrs <br>    PTimeStamp ptsExpiry                    // (out) Life span (OPT) <br>    ); <br> <br>typedef SECURITY_STATUS <br>(SEC_ENTRY * INITIALIZE_SECURITY_CONTEXT_FN_W)( <br>    PCredHandle, <br>    PCtxtHandle, <br>#if ISSP_MODE == 0 <br>    PSECURITY_STRING, <br>#else <br>    SEC_WCHAR SEC_FAR *, <br>#endif <br>    unsigned long, <br>    unsigned long, <br>    unsigned long, <br>    PSecBufferDesc, <br>    unsigned long, <br>    PCtxtHandle, <br>    PSecBufferDesc, <br>    unsigned long SEC_FAR *, <br>    PTimeStamp); <br> <br>// end_ntifs <br> <br>SECURITY_STATUS SEC_ENTRY <br>InitializeSecurityContextA( <br>    PCredHandle phCredential,               // Cred to base context <br>    PCtxtHandle phContext,                  // Existing context (OPT) <br>    SEC_CHAR SEC_FAR * pszTargetName,       // Name of target <br>    unsigned long fContextReq,              // Context Requirements <br>    unsigned long Reserved1,                // Reserved, MBZ <br>    unsigned long TargetDataRep,            // Data rep of target <br>    PSecBufferDesc pInput,                  // Input Buffers <br>    unsigned long Reserved2,                // Reserved, MBZ <br>    PCtxtHandle phNewContext,               // (out) New Context handle <br>    PSecBufferDesc pOutput,                 // (inout) Output Buffers <br>    unsigned long SEC_FAR * pfContextAttr,  // (out) Context attrs <br>    PTimeStamp ptsExpiry                    // (out) Life span (OPT) <br>    ); <br> <br>typedef SECURITY_STATUS <br>(SEC_ENTRY * INITIALIZE_SECURITY_CONTEXT_FN_A)( <br>    PCredHandle, <br>    PCtxtHandle, <br>    SEC_CHAR SEC_FAR *, <br>    unsigned long, <br>    unsigned long, <br>    unsigned long, <br>    PSecBufferDesc, <br>    unsigned long, <br>    PCtxtHandle, <br>    PSecBufferDesc, <br>    unsigned long SEC_FAR *, <br>    PTimeStamp); <br> <br>#ifdef UNICODE <br>#  define InitializeSecurityContext InitializeSecurityContextW              // ntifs <br>#  define INITIALIZE_SECURITY_CONTEXT_FN INITIALIZE_SECURITY_CONTEXT_FN_W   // ntifs <br>#else <br>#  define InitializeSecurityContext InitializeSecurityContextA <br>#  define INITIALIZE_SECURITY_CONTEXT_FN INITIALIZE_SECURITY_CONTEXT_FN_A <br>#endif // !UNICODE <br> <br>// begin_ntifs <br> <br>SECURITY_STATUS SEC_ENTRY <br>AcceptSecurityContext( <br>    PCredHandle phCredential,               // Cred to base context <br>    PCtxtHandle phContext,                  // Existing context (OPT) <br>    PSecBufferDesc pInput,                  // Input buffer <br>    unsigned long fContextReq,              // Context Requirements <br>    unsigned long TargetDataRep,            // Target Data Rep <br>    PCtxtHandle phNewContext,               // (out) New context handle <br>    PSecBufferDesc pOutput,                 // (inout) Output buffers <br>    unsigned long SEC_FAR * pfContextAttr,  // (out) Context attributes <br>    PTimeStamp ptsExpiry                    // (out) Life span (OPT) <br>    ); <br> <br>typedef SECURITY_STATUS <br>(SEC_ENTRY * ACCEPT_SECURITY_CONTEXT_FN)( <br>    PCredHandle, <br>    PCtxtHandle, <br>    PSecBufferDesc, <br>    unsigned long, <br>    unsigned long, <br>    PCtxtHandle, <br>    PSecBufferDesc, <br>    unsigned long SEC_FAR *, <br>    PTimeStamp); <br> <br> <br> <br>SECURITY_STATUS SEC_ENTRY <br>CompleteAuthToken( <br>    PCtxtHandle phContext,              // Context to complete <br>    PSecBufferDesc pToken               // Token to complete <br>    ); <br> <br>typedef SECURITY_STATUS <br>(SEC_ENTRY * COMPLETE_AUTH_TOKEN_FN)( <br>    PCtxtHandle, <br>    PSecBufferDesc); <br> <br> <br>SECURITY_STATUS SEC_ENTRY <br>ImpersonateSecurityContext( <br>    PCtxtHandle phContext               // Context to impersonate <br>    ); <br> <br>typedef SECURITY_STATUS <br>(SEC_ENTRY * IMPERSONATE_SECURITY_CONTEXT_FN)( <br>    PCtxtHandle); <br> <br> <br> <br>SECURITY_STATUS SEC_ENTRY <br>RevertSecurityContext( <br>    PCtxtHandle phContext               // Context from which to re <br>    ); <br> <br>typedef SECURITY_STATUS </code></pre>
<p>
</p>
<pre><code>(SEC_ENTRY * REVERT_SECURITY_CONTEXT_FN)( <br>    PCtxtHandle); <br> <br> <br>SECURITY_STATUS SEC_ENTRY <br>QuerySecurityContextToken( <br>    PCtxtHandle phContext, <br>    void SEC_FAR * SEC_FAR * Token <br>    ); <br> <br>typedef SECURITY_STATUS <br>(SEC_ENTRY * QUERY_SECURITY_CONTEXT_TOKEN_FN)( <br>    PCtxtHandle, void SEC_FAR * SEC_FAR *); <br> <br> <br> <br>SECURITY_STATUS SEC_ENTRY <br>DeleteSecurityContext( <br>    PCtxtHandle phContext               // Context to delete <br>    ); <br> <br>typedef SECURITY_STATUS <br>(SEC_ENTRY * DELETE_SECURITY_CONTEXT_FN)( <br>    PCtxtHandle); <br> <br> <br> <br>SECURITY_STATUS SEC_ENTRY <br>ApplyControlToken( <br>    PCtxtHandle phContext,              // Context to modify <br>    PSecBufferDesc pInput               // Input token to apply <br>    ); <br> <br>typedef SECURITY_STATUS <br>(SEC_ENTRY * APPLY_CONTROL_TOKEN_FN)( <br>    PCtxtHandle, PSecBufferDesc); <br> <br> <br> <br>SECURITY_STATUS SEC_ENTRY <br>QueryContextAttributesW( <br>    PCtxtHandle phContext,              // Context to query <br>    unsigned long ulAttribute,          // Attribute to query <br>    void SEC_FAR * pBuffer              // Buffer for attributes <br>    ); <br> <br>typedef SECURITY_STATUS <br>(SEC_ENTRY * QUERY_CONTEXT_ATTRIBUTES_FN_W)( <br>    PCtxtHandle, <br>    unsigned long, <br>    void SEC_FAR *); <br> <br>// end_ntifs <br> <br>SECURITY_STATUS SEC_ENTRY <br>QueryContextAttributesA( <br>    PCtxtHandle phContext,              // Context to query <br>    unsigned long ulAttribute,          // Attribute to query <br>    void SEC_FAR * pBuffer              // Buffer for attributes <br>    ); <br> <br>typedef SECURITY_STATUS <br>(SEC_ENTRY * QUERY_CONTEXT_ATTRIBUTES_FN_A)( <br>    PCtxtHandle, <br>    unsigned long, <br>    void SEC_FAR *); <br> <br>#ifdef UNICODE <br>#  define QueryContextAttributes QueryContextAttributesW            // ntifs <br>#  define QUERY_CONTEXT_ATTRIBUTES_FN QUERY_CONTEXT_ATTRIBUTES_FN_W // ntifs <br>#else <br>#  define QueryContextAttributes QueryContextAttributesA <br>#  define QUERY_CONTEXT_ATTRIBUTES_FN QUERY_CONTEXT_ATTRIBUTES_FN_A <br>#endif // !UNICODE <br> <br>// begin_ntifs <br> <br>SECURITY_STATUS SEC_ENTRY <br>QueryCredentialsAttributesW( <br>    PCredHandle phCredential,              // Credential to query <br>    unsigned long ulAttribute,          // Attribute to query <br>    void SEC_FAR * pBuffer              // Buffer for attributes <br>    ); <br> <br>typedef SECURITY_STATUS <br>(SEC_ENTRY * QUERY_CREDENTIALS_ATTRIBUTES_FN_W)( <br>    PCredHandle, <br>    unsigned long, <br>    void SEC_FAR *); <br> <br>// end_ntifs <br> <br>SECURITY_STATUS SEC_ENTRY <br>QueryCredentialsAttributesA( <br>    PCredHandle phCredential,              // Credential to query <br>    unsigned long ulAttribute,          // Attribute to query <br>    void SEC_FAR * pBuffer              // Buffer for attributes <br>    ); <br> <br>typedef SECURITY_STATUS <br>(SEC_ENTRY * QUERY_CREDENTIALS_ATTRIBUTES_FN_A)( <br>    PCredHandle, <br>    unsigned long, <br>    void SEC_FAR *); <br> <br>#ifdef UNICODE <br>#  define QueryCredentialsAttributes QueryCredentialsAttributesW            // ntifs <br>#  define QUERY_CREDENTIALS_ATTRIBUTES_FN QUERY_CREDENTIALS_ATTRIBUTES_FN_W // ntifs <br>#else <br>#  define QueryCredentialsAttributes QueryCredentialsAttributesA <br>#  define QUERY_CREDENTIALS_ATTRIBUTES_FN QUERY_CREDENTIALS_ATTRIBUTES_FN_A <br>#endif // !UNICODE <br> <br>// begin_ntifs <br> <br>SECURITY_STATUS SEC_ENTRY <br>FreeContextBuffer( <br>    void SEC_FAR * pvContextBuffer      // buffer to free <br>    ); <br> <br>typedef SECURITY_STATUS <br>(SEC_ENTRY * FREE_CONTEXT_BUFFER_FN)( <br>    void SEC_FAR *); <br> <br>// end_ntifs <br> <br>// begin_ntifs <br>/////////////////////////////////////////////////////////////////// <br>//// <br>////    Message Support API <br>//// <br>////////////////////////////////////////////////////////////////// <br> <br>SECURITY_STATUS SEC_ENTRY <br>MakeSignature( <br>    PCtxtHandle phContext,              // Context to use <br>    unsigned long fQOP,                 // Quality of Protection <br>    PSecBufferDesc pMessage,            // Message to sign <br>    unsigned long MessageSeqNo          // Message Sequence Num. <br>    ); <br> <br>typedef SECURITY_STATUS <br>(SEC_ENTRY * MAKE_SIGNATURE_FN)( <br>    PCtxtHandle, <br>    unsigned long, <br>    PSecBufferDesc, <br>    unsigned long); <br> <br> <br> <br>SECURITY_STATUS SEC_ENTRY <br>VerifySignature( <br>    PCtxtHandle phContext,              // Context to use <br>    PSecBufferDesc pMessage,            // Message to verify <br>    unsigned long MessageSeqNo,         // Sequence Num. <br>    unsigned long SEC_FAR * pfQOP       // QOP used <br>    ); <br> <br>typedef SECURITY_STATUS <br>(SEC_ENTRY * VERIFY_SIGNATURE_FN)( <br>    PCtxtHandle, <br>    PSecBufferDesc, <br>    unsigned long, <br>    unsigned long SEC_FAR *); <br> <br> <br>SECURITY_STATUS SEC_ENTRY <br>EncryptMessage( PCtxtHandle         phContext, <br>                unsigned long       fQOP, <br>                PSecBufferDesc      pMessage, <br>                unsigned long       MessageSeqNo); <br> <br>typedef SECURITY_STATUS <br>(SEC_ENTRY * ENCRYPT_MESSAGE_FN)( <br>    PCtxtHandle, unsigned long, PSecBufferDesc, unsigned long); <br> <br> <br>SECURITY_STATUS SEC_ENTRY <br>DecryptMessage( PCtxtHandle         phContext, <br>                PSecBufferDesc      pMessage, <br>                unsigned long       MessageSeqNo, <br>                unsigned long *     pfQOP); <br> <br> <br>typedef SECURITY_STATUS <br>(SEC_ENTRY * DECRYPT_MESSAGE_FN)( <br>    PCtxtHandle, PSecBufferDesc, unsigned long, <br>    unsigned long SEC_FAR *); <br> <br> <br>// end_ntifs <br> <br>// begin_ntifs <br>/////////////////////////////////////////////////////////////////////////// <br>//// <br>////    Misc. <br>//// <br>/////////////////////////////////////////////////////////////////////////// <br> <br> <br>SECURITY_STATUS SEC_ENTRY <br>EnumerateSecurityPackagesW( <br>    unsigned long SEC_FAR * pcPackages,     // Receives num. packages <br>    PSecPkgInfoW SEC_FAR * ppPackageInfo    // Receives array of info <br>    ); <br> <br>typedef SECURITY_STATUS <br>(SEC_ENTRY * ENUMERATE_SECURITY_PACKAGES_FN_W)( <br>    unsigned long SEC_FAR *, <br>    PSecPkgInfoW SEC_FAR *); <br> <br>// end_ntifs <br> <br>SECURITY_STATUS SEC_ENTRY <br>EnumerateSecurityPackagesA( <br>    unsigned long SEC_FAR * pcPackages,     // Receives num. packages <br>    PSecPkgInfoA SEC_FAR * ppPackageInfo    // Receives array of info <br>    ); <br> <br>typedef SECURITY_STATUS <br>(SEC_ENTRY * ENUMERATE_SECURITY_PACKAGES_FN_A)( <br>    unsigned long SEC_FAR *, <br>    PSecPkgInfoA SEC_FAR *); <br> <br>#ifdef UNICODE <br>#  define EnumerateSecurityPackages EnumerateSecurityPackagesW              // ntifs <br>#  define ENUMERATE_SECURITY_PACKAGES_FN ENUMERATE_SECURITY_PACKAGES_FN_W   // ntifs <br>#else <br>#  define EnumerateSecurityPackages EnumerateSecurityPackagesA <br>#  define ENUMERATE_SECURITY_PACKAGES_FN ENUMERATE_SECURITY_PACKAGES_FN_A <br>#endif // !UNICODE <br> <br>// begin_ntifs <br> <br>SECURITY_STATUS SEC_ENTRY <br>QuerySecurityPackageInfoW( <br>#if ISSP_MODE == 0 <br>    PSECURITY_STRING pPackageName, <br>#else <br>    SEC_WCHAR SEC_FAR * pszPackageName,     // Name of package <br>#endif <br>    PSecPkgInfoW SEC_FAR *ppPackageInfo              // Receives package info <br>    ); <br> <br>typedef SECURITY_STATUS <br>(SEC_ENTRY * QUERY_SECURITY_PACKAGE_INFO_FN_W)( <br>#if ISSP_MODE == 0 <br>    PSECURITY_STRING, <br>#else <br>    SEC_WCHAR SEC_FAR *, <br>#endif <br>    PSecPkgInfoW SEC_FAR *); <br> <br>// end_ntifs <br> <br>SECURITY_STATUS SEC_ENTRY <br>QuerySecurityPackageInfoA( <br>    SEC_CHAR SEC_FAR * pszPackageName,      // Name of package <br>    PSecPkgInfoA SEC_FAR *ppPackageInfo              // Receives package info <br>    ); <br> <br>typedef SECURITY_STATUS <br>(SEC_ENTRY * QUERY_SECURITY_PACKAGE_INFO_FN_A)( <br>    SEC_CHAR SEC_FAR *, <br>    PSecPkgInfoA SEC_FAR *); <br> <br>#ifdef UNICODE <br>#  define QuerySecurityPackageInfo QuerySecurityPackageInfoW                // ntifs <br>#  define QUERY_SECURITY_PACKAGE_INFO_FN QUERY_SECURITY_PACKAGE_INFO_FN_W   // ntifs <br>#else <br>#  define QuerySecurityPackageInfo QuerySecurityPackageInfoA <br>#  define QUERY_SECURITY_PACKAGE_INFO_FN QUERY_SECURITY_PACKAGE_INFO_FN_A <br>#endif // !UNICODE <br> <br> <br>#if ISSP_MODE == 0 <br> <br>#define DeleteSecurityContextDefer  DeleteSecurityContext <br>#define FreeCredentialsHandleDefer  FreeCredentialsHandle <br> <br>#if 0 <br>// <br>// Deferred mode calls for rdr <br>// <br> <br>SECURITY_STATUS SEC_ENTRY <br>DeleteSecurityContextDefer( <br>    PCtxtHandle     phContext); <br> <br>SECURITY_STATUS SEC_ENTRY <br>FreeCredentialsHandleDefer( <br>    PCredHandle     phCreds); <br> <br>#endif <br> <br>#endif <br> <br>typedef enum _SecDelegationType { <br>    SecFull, <br>    SecService, <br>    SecTree, <br>    SecDirectory, <br>    SecObject <br>} SecDelegationType, * PSecDelegationType; <br> <br>SECURITY_STATUS SEC_ENTRY <br>DelegateSecurityContext( <br>    PCtxtHandle         phContext,          // IN Active context to delegate <br>#if ISSP_MODE == 0 <br>    PSECURITY_STRING    pTarget,            // IN Target path <br>#else <br>    SEC_CHAR SEC_FAR *  pszTarget, <br>#endif <br>    SecDelegationType   DelegationType,     // IN Type of delegation <br>    PTimeStamp          pExpiry,            // IN OPTIONAL time limit <br>    PSecBuffer          pPackageParameters, // IN OPTIONAL package specific <br>    PSecBufferDesc      pOutput);           // OUT Token for applycontroltoken. <br> <br> <br>/////////////////////////////////////////////////////////////////////////// <br>//// <br>////    Proxies <br>//// <br>/////////////////////////////////////////////////////////////////////////// <br> <br> <br>// <br>// Proxies are only available on NT platforms <br>// <br> <br>// begin_ntifs <br> <br>/////////////////////////////////////////////////////////////////////////// <br>//// <br>////    Context export/import <br>//// <br>/////////////////////////////////////////////////////////////////////////// <br> <br> <br> <br>SECURITY_STATUS SEC_ENTRY <br>ExportSecurityContext( <br>    PCtxtHandle          phContext,             // (in) context to export <br>    ULONG                fFlags,                // (in) option flags <br>    PSecBuffer           pPackedContext,        // (out) marshalled context <br>    void SEC_FAR * SEC_FAR * pToken                 // (out, optional) token handle for impersonation <br>    ); <br> <br>typedef SECURITY_STATUS <br>(SEC_ENTRY * EXPORT_SECURITY_CONTEXT_FN)( <br>    PCtxtHandle, <br>    ULONG, <br>    PSecBuffer, <br>    void SEC_FAR * SEC_FAR * <br>    ); <br> <br>SECURITY_STATUS SEC_ENTRY <br>ImportSecurityContextW( <br>    SEC_WCHAR SEC_FAR * pszPackage, <br>    PSecBuffer           pPackedContext,        // (in) marshalled context <br>    void SEC_FAR *       Token,                 // (in, optional) handle to token for context <br>    PCtxtHandle          phContext              // (out) new context handle <br>    ); <br> <br>typedef SECURITY_STATUS <br>(SEC_ENTRY * IMPORT_SECURITY_CONTEXT_FN_W)( <br>    SEC_WCHAR SEC_FAR *, <br>    PSecBuffer, <br>    VOID SEC_FAR *, <br>    PCtxtHandle <br>    ); <br> <br>// end_ntifs <br>SECURITY_STATUS SEC_ENTRY <br>ImportSecurityContextA( <br>    SEC_CHAR SEC_FAR * pszPackage, <br>    PSecBuffer           pPackedContext,        // (in) marshalled context <br>    VOID SEC_FAR *       Token,                 // (in, optional) handle to token for context <br>    PCtxtHandle          phContext              // (out) new context handle <br>    ); <br> <br>typedef SECURITY_STATUS <br>(SEC_ENTRY * IMPORT_SECURITY_CONTEXT_FN_A)( <br>    SEC_CHAR SEC_FAR *, <br>    PSecBuffer, <br>    void SEC_FAR *, <br>    PCtxtHandle <br>    ); <br> <br>#ifdef UNICODE <br>#  define ImportSecurityContext ImportSecurityContextW              // ntifs <br>#  define IMPORT_SECURITY_CONTEXT_FN IMPORT_SECURITY_CONTEXT_FN_W   // ntifs <br>#else <br>#  define ImportSecurityContext ImportSecurityContextA <br>#  define IMPORT_SECURITY_CONTEXT_FN IMPORT_SECURITY_CONTEXT_FN_A <br>#endif // !UNICODE <br> <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//// <br>////  Fast access for RPC: <br>//// <br>/////////////////////////////////////////////////////////////////////////////// <br> <br>#define SECURITY_ENTRYPOINT_ANSIW "InitSecurityInterfaceW" <br>#define SECURITY_ENTRYPOINT_ANSIA "InitSecurityInterfaceW" <br>#define SECURITY_ENTRYPOINTW SEC_TEXT("InitSecurityInterfaceW")     // ntifs <br>#define SECURITY_ENTRYPOINTA SEC_TEXT("InitSecurityInterfaceA") <br>#define SECURITY_ENTRYPOINT16 "INITSECURITYINTERFACEA" <br> <br>#ifdef SECURITY_WIN32 <br>#  ifdef UNICODE <br>#    define SECURITY_ENTRYPOINT SECURITY_ENTRYPOINTW                // ntifs <br>#    define SECURITY_ENTRYPOINT_ANSI SECURITY_ENTRYPOINT_ANSIW <br>#  else // UNICODE <br>#    define SECURITY_ENTRYPOINT SECURITY_ENTRYPOINTA <br>#    define SECURITY_ENTRYPOINT_ANSI SECURITY_ENTRYPOINT_ANSIA <br>#  endif // UNICODE <br>#else // SECURITY_WIN32 <br>#  define SECURITY_ENTRYPOINT SECURITY_ENTRYPOINT16 <br>#  define SECURITY_ENTRYPOINT_ANSI SECURITY_ENTRYPOINT16 <br>#endif // SECURITY_WIN32 <br> <br>// begin_ntifs <br> <br>typedef struct _SECURITY_FUNCTION_TABLE_W { <br>    unsigned long                       dwVersion; <br>    ENUMERATE_SECURITY_PACKAGES_FN_W    EnumerateSecurityPackagesW; <br>    QUERY_CREDENTIALS_ATTRIBUTES_FN_W   QueryCredentialsAttributesW; <br>    ACQUIRE_CREDENTIALS_HANDLE_FN_W     AcquireCredentialsHandleW; <br>    FREE_CREDENTIALS_HANDLE_FN          FreeCredentialHandle; <br>#ifndef WIN32_CHICAGO <br>    void SEC_FAR *                      Reserved2; <br>#else // WIN32_CHICAGO <br>    SSPI_LOGON_USER_FN                       SspiLogonUserW; <br>#endif // WIN32_CHICAGO <br>    INITIALIZE_SECURITY_CONTEXT_FN_W    InitializeSecurityContextW; <br>    ACCEPT_SECURITY_CONTEXT_FN          AcceptSecurityContext; <br>    COMPLETE_AUTH_TOKEN_FN              CompleteAuthToken; <br>    DELETE_SECURITY_CONTEXT_FN          DeleteSecurityContext; <br>    APPLY_CONTROL_TOKEN_FN              ApplyControlToken; <br>    QUERY_CONTEXT_ATTRIBUTES_FN_W       QueryContextAttributesW; <br>    IMPERSONATE_SECURITY_CONTEXT_FN     ImpersonateSecurityContext; <br>    REVERT_SECURITY_CONTEXT_FN          RevertSecurityContext; <br>    MAKE_SIGNATURE_FN                   MakeSignature; <br>    VERIFY_SIGNATURE_FN                 VerifySignature; <br>    FREE_CONTEXT_BUFFER_FN              FreeContextBuffer; <br>    QUERY_SECURITY_PACKAGE_INFO_FN_W    QuerySecurityPackageInfoW; <br>    void SEC_FAR *                      Reserved3; <br>    void SEC_FAR *                      Reserved4; <br>    EXPORT_SECURITY_CONTEXT_FN          ExportSecurityContext; <br>    IMPORT_SECURITY_CONTEXT_FN_W        ImportSecurityContextW; <br>    void SEC_FAR *                      Reserved7; <br>    void SEC_FAR *                      Reserved8; <br>    QUERY_SECURITY_CONTEXT_TOKEN_FN     QuerySecurityContextToken; <br>    ENCRYPT_MESSAGE_FN                  EncryptMessage; <br>    DECRYPT_MESSAGE_FN                  DecryptMessage; <br>} SecurityFunctionTableW, SEC_FAR * PSecurityFunctionTableW; <br> <br>// end_ntifs <br> <br>typedef struct _SECURITY_FUNCTION_TABLE_A { <br>    unsigned long                       dwVersion; <br>    ENUMERATE_SECURITY_PACKAGES_FN_A    EnumerateSecurityPackagesA; <br>    QUERY_CREDENTIALS_ATTRIBUTES_FN_A   QueryCredentialsAttributesA; <br>    ACQUIRE_CREDENTIALS_HANDLE_FN_A     AcquireCredentialsHandleA; <br>    FREE_CREDENTIALS_HANDLE_FN          FreeCredentialHandle; <br>#ifndef WIN32_CHICAGO <br>    void SEC_FAR *                      Reserved2; <br>#else // WIN32_CHICAGO <br>    SSPI_LOGON_USER_FN                       SspiLogonUserA; <br>#endif // WIN32_CHICAGO <br>    INITIALIZE_SECURITY_CONTEXT_FN_A    InitializeSecurityContextA; <br>    ACCEPT_SECURITY_CONTEXT_FN          AcceptSecurityContext; <br>    COMPLETE_AUTH_TOKEN_FN              CompleteAuthToken; <br>    DELETE_SECURITY_CONTEXT_FN          DeleteSecurityContext; <br>    APPLY_CONTROL_TOKEN_FN              ApplyControlToken; <br>    QUERY_CONTEXT_ATTRIBUTES_FN_A       QueryContextAttributesA; <br>    IMPERSONATE_SECURITY_CONTEXT_FN     ImpersonateSecurityContext; <br>    REVERT_SECURITY_CONTEXT_FN          RevertSecurityContext; <br>    MAKE_SIGNATURE_FN                   MakeSignature; <br>    VERIFY_SIGNATURE_FN                 VerifySignature; <br>    FREE_CONTEXT_BUFFER_FN              FreeContextBuffer; <br>    QUERY_SECURITY_PACKAGE_INFO_FN_A    QuerySecurityPackageInfoA; <br>    void SEC_FAR *                      Reserved3; <br>    void SEC_FAR *                      Reserved4; <br>    EXPORT_SECURITY_CONTEXT_FN          ExportSecurityContext; <br>    IMPORT_SECURITY_CONTEXT_FN_A        ImportSecurityContextA; <br>   void SEC_FAR *                      Reserved7; <br>    void SEC_FAR *                      Reserved8; <br>    QUERY_SECURITY_CONTEXT_TOKEN_FN     QuerySecurityContextToken; <br>    ENCRYPT_MESSAGE_FN                  EncryptMessage; <br>    DECRYPT_MESSAGE_FN                  DecryptMessage; <br>} SecurityFunctionTableA, SEC_FAR * PSecurityFunctionTableA; <br> <br>#ifdef UNICODE <br>#  define SecurityFunctionTable SecurityFunctionTableW <br>#  define PSecurityFunctionTable PSecurityFunctionTableW <br>#else <br>#  define SecurityFunctionTable SecurityFunctionTableA <br>#  define PSecurityFunctionTable PSecurityFunctionTableA <br>#endif // !UNICODE <br> <br>#define SECURITY_ <br> <br>#define SECURITY_SUPPORT_PROVIDER_INTERFACE_VERSION     1 <br> <br> <br>PSecurityFunctionTableA SEC_ENTRY <br>InitSecurityInterfaceA( <br>    void <br>    ); <br> <br>typedef PSecurityFunctionTableA <br>(SEC_ENTRY * INIT_SECURITY_INTERFACE_A)(void); <br> <br>// begin_ntifs <br> <br>PSecurityFunctionTableW SEC_ENTRY <br>InitSecurityInterfaceW( <br>    void <br>    ); <br> <br>typedef PSecurityFunctionTableW <br>(SEC_ENTRY * INIT_SECURITY_INTERFACE_W)(void); <br> <br>// end_ntifs <br> <br>#ifdef UNICODE <br>#  define InitSecurityInterface InitSecurityInterfaceW          // ntifs <br>#  define INIT_SECURITY_INTERFACE INIT_SECURITY_INTERFACE_W     // ntifs <br>#else <br>#  define InitSecurityInterface InitSecurityInterfaceA <br>#  define INIT_SECURITY_INTERFACE INIT_SECURITY_INTERFACE_A <br>#endif // !UNICODE <br> <br>typedef struct _SECURITY_PACKAGE_OPTIONS { <br>    unsigned long   Size; <br>    unsigned long   Type; <br>    unsigned long   Flags; <br>    unsigned long   SignatureSize; <br>    void SEC_FAR *  Signature; <br>} SECURITY_PACKAGE_OPTIONS, SEC_FAR * PSECURITY_PACKAGE_OPTIONS; <br> <br>#define SECPKG_OPTIONS_TYPE_UNKNOWN 0 <br>#define SECPKG_OPTIONS_TYPE_LSA     1 <br>#define SECPKG_OPTIONS_TYPE_SSPI    2 <br> <br>#define SECPKG_OPTIONS_PERMANENT    0x00000001 <br> <br>SECURITY_STATUS <br>SEC_ENTRY <br>AddSecurityPackageA( <br>    SEC_CHAR SEC_FAR *  pszPackageName, <br>    SECURITY_PACKAGE_OPTIONS SEC_FAR * Options <br>    ); <br> <br>SECURITY_STATUS <br>SEC_ENTRY <br>AddSecurityPackageW( <br>    SEC_WCHAR SEC_FAR * pszPackageName, <br>    SECURITY_PACKAGE_OPTIONS SEC_FAR * Options <br>    ); <br> <br>#ifdef UNICODE <br>#define AddSecurityPackage  AddSecurityPackageW <br>#else <br>#define AddSecurityPackage  AddSecurityPackageA <br>#endif <br> <br>SECURITY_STATUS <br>SEC_ENTRY <br>DeleteSecurityPackageA( <br>    SEC_CHAR SEC_FAR *  pszPackageName ); <br> <br>SECURITY_STATUS <br>SEC_ENTRY <br>DeleteSecurityPackageW( <br>    SEC_WCHAR SEC_FAR * pszPackageName ); <br> <br>#ifdef UNICODE <br>#define DeleteSecurityPackage   DeleteSecurityPackageW <br>#else <br>#define DeleteSecurityPackage   DeleteSecurityPackageA <br>#endif <br> <br> <br>// <br>// Extended Name APIs for NTDS <br>// <br> <br> <br>typedef enum <br>{ <br>    // Examples for the following formats assume a fictitous company <br>    // which hooks into the global X.500 and DNS name spaces as follows. <br>    // <br>    // Enterprise root domain in DNS is <br>    // <br>    //      widget.com <br>    // <br>    // Enterprise root domain in X.500 (RFC 1779 format) is <br>    // <br>    //      O=Widget, C=US <br>    // <br>    // There exists the child domain <br>    // <br>    //      engineering.widget.com <br>    // <br>    // equivalent to <br>    // <br>    //      OU=Engineering, O=Widget, C=US <br>    // <br>    // There exists a container within the Engineering domain <br>    // <br>    //      OU=Software, OU=Engineering, O=Widget, C=US <br>    // <br>    // There exists the user <br>    // <br>    //      CN=Spencer Katt, OU=Software, OU=Engineering, O=Widget, C=US <br>    // <br>    // And this user's downlevel (pre-NTDS) user name is <br>    // <br>    //      Engineering\SpencerK <br> <br>    // unknown name type <br>    NameUnknown = 0, <br> <br>    // CN=Spencer Katt, OU=Software, OU=Engineering, O=Widget, C=US <br>    NameFullyQualifiedDN = 1, <br> <br>    // Engineering\SpencerK <br>    NameSamCompatible = 2, <br> <br>    // Probably "Spencer Katt" but could be something else.  I.e. The <br>    // display name is not necessarily the defining RDN. <br>    NameDisplay = 3, <br> <br>    // xxx@engineering.widget.com where xxx could be "SpencerK" or <br>    // anything else.  Could be multi-valued to handle migration and aliasing. <br>    NameDomainSimple = 4, <br> <br>    // xxx@widget.com where xxx could be "SpencerK" or anything else. <br>    // Could be multi-valued to handle migration and aliasing. <br>    NameEnterpriseSimple = 5, <br> <br>    // String-ized GUID as returned by IIDFromString(). <br>    // eg: {4fa050f0-f561-11cf-bdd9-00aa003a77b6} <br>    NameUniqueId = 6, <br> <br>    // engineering.widget.com/software/spencer katt <br>    NameCanonical = 7 <br> <br>} EXTENDED_NAME_FORMAT, * PEXTENDED_NAME_FORMAT ; <br> <br>BOOLEAN <br>SEC_ENTRY <br>GetUserNameExA( <br>    EXTENDED_NAME_FORMAT  NameFormat, <br>    LPSTR lpNameBuffer, <br>    PULONG nSize <br>    ); <br>BOOLEAN <br>SEC_ENTRY <br>GetUserNameExW( <br>    EXTENDED_NAME_FORMAT NameFormat, <br>    LPWSTR lpNameBuffer, <br>    PULONG nSize <br>    ); <br> <br>#ifdef UNICODE <br>#define GetUserNameEx   GetUserNameExW <br>#else <br>#define GetUserNameEx   GetUserNameExA <br>#endif <br> <br>BOOLEAN <br>SEC_ENTRY <br>TranslateNameA( <br>    LPCSTR lpAccountName, <br>    EXTENDED_NAME_FORMAT AccountNameFormat, <br>    EXTENDED_NAME_FORMAT DesiredNameFormat, <br>    LPSTR lpTranslatedName, <br>    PULONG nSize <br>    ); <br>BOOLEAN <br>SEC_ENTRY <br>TranslateNameW( <br>    LPCWSTR lpAccountName, <br>    EXTENDED_NAME_FORMAT AccountNameFormat, <br>    EXTENDED_NAME_FORMAT DesiredNameFormat, <br>    LPWSTR lpTranslatedName, <br>    PULONG nSize <br>    ); <br>#ifdef UNICODE <br>#define TranslateName   TranslateNameW <br>#else <br>#define TranslateName   TranslateNameA <br>#endif <br> <br>#ifdef SECURITY_DOS <br>#pragma warning(default:4147) <br>#endif <br> <br>#endif // __SSPI_H__ </code></pre>
<p>&nbsp;</p></body>
</HTML>
