<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>TAKEOWN.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6241"></a>TAKEOWN.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples.  <br>*       Copyright 1993 - 1998 Microsoft Corporation. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>/*++ <br> <br>Module Name: <br> <br>    Takeown.c <br> <br>Abstract: <br> <br>    Implements a recovery scheme to give an Administrator access to a  <br>    file that has been denied to all.   <br> <br>Environment: <br> <br>    Must be run from an Administrator account in order to perform  <br>    reliably.   <br> <br>--*/ <br>#include &lt;windows.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;malloc.h&gt; <br> <br>BOOL <br>AssertTakeOwnership( <br>    HANDLE TokenHandle <br>    ); <br> <br>BOOL <br>GetTokenHandle( <br>    PHANDLE TokenHandle <br>    ); <br> <br>BOOL <br>VariableInitialization(); <br> <br> <br> <br> <br>PSID AliasAdminsSid = NULL; <br>PSID SeWorldSid; <br> <br>static SID_IDENTIFIER_AUTHORITY    SepNtAuthority = SECURITY_NT_AUTHORITY; <br>static SID_IDENTIFIER_AUTHORITY    SepWorldSidAuthority   = SECURITY_WORLD_SID_AUTHORITY; <br> <br> <br> <br> <br>void main (int argc, char *argv[]) <br>{ <br> <br> <br>    BOOL Result; <br>    LPSTR lpFileName; <br>    SECURITY_DESCRIPTOR SecurityDescriptor; <br>    HANDLE TokenHandle; <br> <br> <br>    // <br>    // We expect a file... <br>    // <br>    if (argc &lt;= 1) { <br> <br>        printf("Must specify a file name"); <br>        return; <br>    } <br> <br> <br>    lpFileName = argv[1]; <br> <br> <br>    Result = VariableInitialization(); <br> <br>    if ( !Result ) { <br>        printf("Out of memory\n"); <br>        return; <br>    } <br> <br> <br> <br> <br>    Result = GetTokenHandle( &amp;TokenHandle ); <br> <br>    if ( !Result ) { <br> <br>        // <br>        // This should not happen <br>        // <br> <br>        printf("Unable to obtain the handle to our token, exiting\n"); <br>        return; <br>    } <br> <br> <br> <br> <br> <br> <br>    // <br>    // Attempt to put a NULL Dacl on the object <br>    // <br> <br>    InitializeSecurityDescriptor( &amp;SecurityDescriptor, SECURITY_DESCRIPTOR_REVISION ); <br> <br> <br>    Result = SetSecurityDescriptorDacl ( <br>                 &amp;SecurityDescriptor, <br>                 TRUE, <br>                 NULL, <br>                 FALSE <br>                 ); <br> <br> <br> <br>    if ( !Result ) { <br>        printf("SetSecurityDescriptorDacl failed, error code = %d\n", GetLastError()); <br>        printf("Exiting\n"); <br>        return; <br>    } <br> <br>    Result = SetFileSecurity( <br>                 lpFileName, <br>                 DACL_SECURITY_INFORMATION, <br>                 &amp;SecurityDescriptor <br>                 ); <br> <br>    if ( Result ) { <br> <br>        printf("Successful, protection removed\n"); <br>        return; <br>    }  <br> <br> <br>    // <br>    // That didn't work. <br>    // <br> <br> <br>    // <br>    // Attempt to make Administrator the owner of the file. <br>    // <br> <br> <br>    Result = SetSecurityDescriptorOwner ( <br>                 &amp;SecurityDescriptor, <br>                 AliasAdminsSid, <br>                 FALSE <br>                 ); <br> <br>    if ( !Result ) { <br>        printf("SetSecurityDescriptorOwner failed, lasterror = %d\n", GetLastError()); <br>        return; <br>    } <br> <br> <br>    Result = SetFileSecurity( <br>                 lpFileName, <br>                 OWNER_SECURITY_INFORMATION, <br>                 &amp;SecurityDescriptor <br>                 ); <br> <br>    if ( !Result ) { <br> <br> <br>        // <br>        // That didn't work either. <br>        // <br> <br> <br> <br>        // <br>        // Assert TakeOwnership privilege, then try again.  Note that <br>        // since the privilege is only enabled for the duration of  <br>        // this process, we don't have to worry about turning it off <br>        // again. <br>        // <br> <br>        Result = AssertTakeOwnership( TokenHandle ); <br> <br>        if ( !Result ) { <br>            printf("Could not enable SeTakeOwnership privilege\n"); <br>            printf("Log on as Administrator and try again\n"); <br>            return; <br>        } <br> <br> <br>        Result = SetFileSecurity( <br>                     lpFileName, <br>                     OWNER_SECURITY_INFORMATION, <br>                     &amp;SecurityDescriptor <br>                     ); <br> <br>        if ( !Result ) { <br> <br>            printf("Unable to assign Administrator as owner\n"); <br>            printf("Log on as Administrator and try again\n"); <br>            return; <br> <br>        } <br>    } <br> <br>    // <br>    // Try to put a benign DACL onto the file again <br>    // <br> <br>    Result = SetFileSecurity( <br>                 lpFileName, <br>                 DACL_SECURITY_INFORMATION, <br>                 &amp;SecurityDescriptor <br>                 ); <br> <br>    if ( !Result ) { <br> <br>        // <br>        // This should not happen. <br>        // <br> <br>        printf("SetFileSecurity unexpectedly failed, error code = %d\n", GetLastError()); <br> <br>    } else { <br> <br>        printf("Successful, protection removed\n"); <br>        return; <br>    } <br>} <br> <br> <br> <br> <br> <br>BOOL <br>GetTokenHandle( <br>    PHANDLE TokenHandle <br>    ) <br>// <br>// This routine will open the current process and return <br>// a handle to its token. <br>// <br>// These handles will be closed for us when the process <br>// exits. <br>// <br>{ <br> <br>    HANDLE ProcessHandle; <br>    BOOL Result; <br> <br>    ProcessHandle = OpenProcess( <br>                        PROCESS_QUERY_INFORMATION, <br>                        FALSE, <br>                        GetCurrentProcessId() <br>                        ); <br> <br>    if ( ProcessHandle == NULL ) { <br> <br>        // <br>        // This should not happen <br>        // <br> <br>        return( FALSE ); <br>    } <br> <br> <br>    Result = OpenProcessToken ( <br>                 ProcessHandle, <br>                 TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, <br>                 TokenHandle <br>                 ); <br> <br>    if ( !Result ) { <br> <br>        // <br>        // This should not happen <br>        // <br> <br>        return( FALSE ); <br> <br>    } <br> <br>    return( TRUE ); <br>} <br> <br> <br>BOOL <br>AssertTakeOwnership( <br>    HANDLE TokenHandle <br>    ) <br>// <br>// This routine turns on SeTakeOwnershipPrivilege in the current <br>// token.  Once that has been accomplished, we can open the file <br>// for WRITE_OWNER even if we are denied that access by the ACL <br>// on the file. <br> <br>{ <br>    LUID TakeOwnershipValue; <br>    BOOL Result; <br>    TOKEN_PRIVILEGES TokenPrivileges; <br> <br> <br>    // <br>    // First, find out the value of TakeOwnershipPrivilege <br>    // <br> <br> <br>    Result = LookupPrivilegeValue( <br>                 NULL, <br>                 "SeTakeOwnershipPrivilege", <br>                 &amp;TakeOwnershipValue <br>                 ); <br> <br>    if ( !Result ) { <br> <br>        // <br>        // This should not happen <br>        // <br> <br>        printf("Unable to obtain value of TakeOwnership privilege\n"); <br>        printf("Error = %d\n",GetLastError()); <br>        printf("Exiting\n"); <br>        return FALSE; <br>    } <br> <br>    // <br>    // Set up the privilege set we will need <br>    // <br> <br>    TokenPrivileges.PrivilegeCount = 1; <br>    TokenPrivileges.Privileges[0].Luid = TakeOwnershipValue; <br>    TokenPrivileges.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED; <br> <br> <br> <br> <br>    (VOID) AdjustTokenPrivileges ( <br>                TokenHandle, <br>                FALSE, <br>                &amp;TokenPrivileges, <br>                sizeof( TOKEN_PRIVILEGES ), <br>                NULL, <br>                NULL <br>                ); <br> <br>    if ( GetLastError() != NO_ERROR ) { <br> <br>        return( FALSE ); <br> <br>    } else { <br> <br>        return( TRUE ); <br>    } <br> <br>} <br> <br> <br> <br>BOOL <br>VariableInitialization() <br> <br>// <br>// Create some useful SIDs. <br>// <br> <br>{ <br> <br>    BOOL Result; <br> <br>    Result = AllocateAndInitializeSid( <br>                 &amp;SepNtAuthority, <br>                 2, <br>                 SECURITY_BUILTIN_DOMAIN_RID, <br>                 DOMAIN_ALIAS_RID_ADMINS, <br>                 0, <br>                 0, <br>                 0, <br>                 0, <br>                 0, <br>                 0, <br>                 &amp;AliasAdminsSid <br>                 ); <br> <br>    if ( !Result ) { <br>        return( FALSE ); <br>    } <br> <br> <br>    Result = AllocateAndInitializeSid( <br>                 &amp;SepWorldSidAuthority, <br>                 1, <br>                 SECURITY_WORLD_RID, <br>                 0, <br>                 0, <br>                 0, <br>                 0, <br>                 0, <br>                 0, <br>                 0, <br>                 &amp;SeWorldSid <br>                 ); <br> <br>    if ( !Result ) { <br>        return( FALSE ); <br>    } <br> <br>    return( TRUE ); <br>} <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
