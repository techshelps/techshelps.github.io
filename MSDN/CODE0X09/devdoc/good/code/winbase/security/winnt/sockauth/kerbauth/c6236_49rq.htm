<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SECURITY.C</title>
<link disabled rel=stylesheet href=../../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6236"></a>SECURITY.C</h2>
<pre><code>/*++ <br> <br>Copyright 1996 - 1998 Microsoft Corporation <br> <br>Module Name: <br> <br>    security.c <br> <br>Abstract: <br> <br>    Handles communication with the SSP package. <br> <br>Revision History: <br> <br>--*/ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;winsock.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;stdlib.h&gt; <br>#define SECURITY_WIN32 <br>#include "sspi.h" <br>#include "issperr.h" <br>#include "security.h" <br>#include "collect.h" <br> <br>static HINSTANCE g_hLib; <br>static DWORD g_cbMaxToken; <br>static PSecurityFunctionTable g_pFuncs; <br> <br>// structure storing the state of the authentication sequence <br>// <br>typedef struct _AUTH_SEQ { <br>    BOOL _fNewConversation; <br>    CredHandle _hcred; <br>    BOOL _fHaveCredHandle; <br>    BOOL _fHaveCtxtHandle; <br>    struct _SecHandle  _hctxt; <br>} AUTH_SEQ, *PAUTH_SEQ; <br> <br>#define SEC_SUCCESS(Status) ((Status) &gt;= 0) <br> <br>#define PACKAGE_NAME"kerberos" <br>#define NT_DLL_NAME"security.dll" <br> <br>// Target name for the security package <br>// De-comment after filling appropriate principal name here. <br>// <br>// #define TOKEN_SOURCE_NAME       "&lt;Domain&gt;\\&lt;User&gt;" <br> <br> <br>BOOL InitPackage (DWORD *pcbMaxMessage) <br>/*++ <br> <br> Routine Description: <br> <br>    Finds, loads and initializes the security package <br> <br> Return Value: <br> <br>    Returns TRUE is successful; otherwise FALSE is returned. <br> <br>--*/ <br>{ <br>FARPROC pInit; <br>SECURITY_STATUS ss; <br>PSecPkgInfo pkgInfo; <br> <br>// load and initialize the ntlm ssp <br>// <br>g_hLib = LoadLibrary (NT_DLL_NAME); <br>if (NULL == g_hLib)  { <br>fprintf (stderr, "Couldn't load dll: %u\n", GetLastError ()); <br>return(FALSE); <br>} <br> <br>pInit = GetProcAddress (g_hLib, SECURITY_ENTRYPOINT); <br>if (NULL == pInit)  { <br>fprintf (stderr, "Couldn't get sec init routine: %u\n", GetLastError ()); <br>return(FALSE); <br>} <br> <br>g_pFuncs = (PSecurityFunctionTable) pInit (); <br>if (NULL == g_pFuncs)  { <br>fprintf (stderr, "Couldn't init package\n"); <br>return(FALSE); <br>} <br> <br>// Query for the package we're interested in <br>// <br>ss = g_pFuncs-&gt;QuerySecurityPackageInfo (PACKAGE_NAME, &amp;pkgInfo); <br>if (!SEC_SUCCESS(ss))  { <br>fprintf (stderr, "Couldn't query package info for %s, error %u\n", <br>PACKAGE_NAME, ss); <br>return(FALSE); <br>} <br> <br>g_cbMaxToken = pkgInfo-&gt;cbMaxToken; <br> <br>g_pFuncs-&gt;FreeContextBuffer (pkgInfo); <br> <br>*pcbMaxMessage = g_cbMaxToken; <br> <br>return TRUE; <br>} <br> <br>BOOL TermPackage () <br>{ <br>FreeLibrary (g_hLib); <br> <br>return(TRUE); <br>} <br> <br>BOOL GenClientContext ( <br>DWORD dwKey, <br>BYTE *pIn, <br>DWORD cbIn, <br>BYTE *pOut, <br>DWORD *pcbOut, <br>BOOL *pfDone) <br>/*++ <br> <br> Routine Description: <br> <br>    Optionally takes an input buffer coming from the server and returns <br>a buffer of information to send back to the server.  Also returns <br>an indication of whether or not the context is complete. <br> <br> Return Value: <br> <br>    Returns TRUE is successful; otherwise FALSE is returned. <br> <br>--*/ <br>{ <br>SECURITY_STATUSss; <br>TimeStampLifetime; <br>SecBufferDescOutBuffDesc; <br>SecBufferOutSecBuff; <br>SecBufferDescInBuffDesc; <br>SecBufferInSecBuff; <br>ULONGContextAttributes; <br>PAUTH_SEQpAS; <br> <br>// Lookup pAS based on Key <br>// <br>if (!GetEntry (dwKey, (PVOID*) &amp;pAS)) <br>return(FALSE); <br> <br>if (pAS-&gt;_fNewConversation)  { <br>ss = g_pFuncs-&gt;AcquireCredentialsHandle ( <br>NULL,// principal <br>PACKAGE_NAME, <br>SECPKG_CRED_OUTBOUND, <br>NULL,// LOGON id <br>NULL,// auth data <br>NULL,// get key fn <br>NULL,// get key arg <br>&amp;pAS-&gt;_hcred, <br>&amp;Lifetime <br>); <br>if (SEC_SUCCESS (ss)) <br>pAS-&gt;_fHaveCredHandle = TRUE; <br>else { <br>fprintf (stderr, "AcquireCreds failed: %u\n", ss); <br>return(FALSE); <br>} <br>} <br> <br>// prepare output buffer <br>// <br>OutBuffDesc.ulVersion = 0; <br>OutBuffDesc.cBuffers = 1; <br>OutBuffDesc.pBuffers = &amp;OutSecBuff; <br> <br>OutSecBuff.cbBuffer = *pcbOut; <br>OutSecBuff.BufferType = SECBUFFER_TOKEN; <br>OutSecBuff.pvBuffer = pOut; <br> <br>// prepare input buffer <br>// <br>if (!pAS-&gt;_fNewConversation)  { <br>InBuffDesc.ulVersion = 0; <br>InBuffDesc.cBuffers = 1; <br>InBuffDesc.pBuffers = &amp;InSecBuff; <br> <br>InSecBuff.cbBuffer = cbIn; <br>InSecBuff.BufferType = SECBUFFER_TOKEN; <br>InSecBuff.pvBuffer = pIn; <br>} <br> <br>ss = g_pFuncs-&gt;InitializeSecurityContext ( <br>&amp;pAS-&gt;_hcred, <br>pAS-&gt;_fNewConversation ? NULL : &amp;pAS-&gt;_hctxt, <br>TOKEN_SOURCE_NAME, <br>0,// context requirements <br>0,// reserved1 <br>SECURITY_NATIVE_DREP, <br>pAS-&gt;_fNewConversation ? NULL : &amp;InBuffDesc, <br>0,// reserved2 <br>&amp;pAS-&gt;_hctxt, <br>&amp;OutBuffDesc, <br>&amp;ContextAttributes, <br>&amp;Lifetime <br>); <br>if (!SEC_SUCCESS (ss))  { <br>fprintf (stderr, "init context failed: %u\n", ss); <br>return FALSE; <br>} <br> <br>pAS-&gt;_fHaveCtxtHandle = TRUE; <br> <br>// Complete token -- if applicable <br>// <br>if ((SEC_I_COMPLETE_NEEDED == ss) || (SEC_I_COMPLETE_AND_CONTINUE == ss))  { <br>if (g_pFuncs-&gt;CompleteAuthToken) { <br>ss = g_pFuncs-&gt;CompleteAuthToken (&amp;pAS-&gt;_hctxt, &amp;OutBuffDesc); <br>if (!SEC_SUCCESS(ss))  { <br>fprintf (stderr, "complete failed: %u\n", ss); <br>return FALSE; <br>} <br>} <br>else { <br>fprintf (stderr, "Complete not supported.\n"); <br>return FALSE; <br>} <br>} <br> <br>*pcbOut = OutSecBuff.cbBuffer; <br> <br>if (pAS-&gt;_fNewConversation) <br>pAS-&gt;_fNewConversation = FALSE; <br> <br>*pfDone = !((SEC_I_CONTINUE_NEEDED == ss) || <br>(SEC_I_COMPLETE_AND_CONTINUE == ss)); <br> <br>return TRUE; <br>} <br> <br>BOOL GenServerContext ( <br>DWORD dwKey, <br>BYTE *pIn, <br>DWORD cbIn, <br>BYTE *pOut, <br>DWORD *pcbOut, <br>BOOL *pfDone) <br>/*++ <br> <br> Routine Description: <br> <br>    Takes an input buffer coming from the client and returns a buffer <br>to be sent to the client.  Also returns an indication of whether or <br>not the context is complete. <br> <br> Return Value: <br> <br>    Returns TRUE is successful; otherwise FALSE is returned. <br> <br>--*/ <br>{ <br>SECURITY_STATUSss; <br>TimeStampLifetime; <br>SecBufferDescOutBuffDesc; <br>SecBufferOutSecBuff; <br>SecBufferDescInBuffDesc; <br>SecBufferInSecBuff; <br>ULONGContextAttributes; <br>PAUTH_SEQpAS; <br> <br>// Lookup pAS based on Key <br>// <br>if (!GetEntry (dwKey, (PVOID*) &amp;pAS)) <br>return(FALSE); <br> <br>if (pAS-&gt;_fNewConversation)  { <br>ss = g_pFuncs-&gt;AcquireCredentialsHandle ( <br>NULL,// principal <br>PACKAGE_NAME, <br>SECPKG_CRED_INBOUND, <br>NULL,// LOGON id <br>NULL,// auth data <br>NULL,// get key fn <br>NULL,// get key arg <br>&amp;pAS-&gt;_hcred, <br>&amp;Lifetime <br>); <br>if (SEC_SUCCESS (ss)) <br>pAS-&gt;_fHaveCredHandle = TRUE; <br>else { <br>fprintf (stderr, "AcquireCreds failed: %u\n", ss); <br>return(FALSE); <br>} <br>} <br> <br>// prepare output buffer <br>// <br>OutBuffDesc.ulVersion = 0; <br>OutBuffDesc.cBuffers = 1; <br>OutBuffDesc.pBuffers = &amp;OutSecBuff; <br> <br>OutSecBuff.cbBuffer = *pcbOut; <br>OutSecBuff.BufferType = SECBUFFER_TOKEN; <br>OutSecBuff.pvBuffer = pOut; <br> <br>// prepare input buffer <br>// <br>InBuffDesc.ulVersion = 0; <br>InBuffDesc.cBuffers = 1; <br>InBuffDesc.pBuffers = &amp;InSecBuff; <br> <br>InSecBuff.cbBuffer = cbIn; <br>InSecBuff.BufferType = SECBUFFER_TOKEN; <br>InSecBuff.pvBuffer = pIn; <br> <br>ss = g_pFuncs-&gt;AcceptSecurityContext ( <br>&amp;pAS-&gt;_hcred, <br>pAS-&gt;_fNewConversation ? NULL : &amp;pAS-&gt;_hctxt, <br>&amp;InBuffDesc, <br>0,// context requirements <br>SECURITY_NATIVE_DREP, <br>&amp;pAS-&gt;_hctxt, <br>&amp;OutBuffDesc, <br>&amp;ContextAttributes, <br>&amp;Lifetime <br>); <br>if (!SEC_SUCCESS (ss))  { <br>fprintf (stderr, "init context failed: %u\n", ss); <br>return FALSE; <br>} <br> <br>pAS-&gt;_fHaveCtxtHandle = TRUE; <br> <br>// Complete token -- if applicable <br>// <br>if ((SEC_I_COMPLETE_NEEDED == ss) || (SEC_I_COMPLETE_AND_CONTINUE == ss))  { <br>if (g_pFuncs-&gt;CompleteAuthToken) { <br>ss = g_pFuncs-&gt;CompleteAuthToken (&amp;pAS-&gt;_hctxt, &amp;OutBuffDesc); <br>if (!SEC_SUCCESS(ss))  { <br>fprintf (stderr, "complete failed: %u\n", ss); <br>return FALSE; <br>} <br>} <br>else { <br>fprintf (stderr, "Complete not supported.\n"); <br>return FALSE; <br>} <br>} <br> <br>*pcbOut = OutSecBuff.cbBuffer; <br> <br>if (pAS-&gt;_fNewConversation) <br>pAS-&gt;_fNewConversation = FALSE; <br> <br>*pfDone = !((SEC_I_CONTINUE_NEEDED == ss) || <br>(SEC_I_COMPLETE_AND_CONTINUE == ss)); <br> <br>return TRUE; <br>} <br> <br>BOOL ImpersonateContext (DWORD dwKey) <br>/*++ <br> <br> Routine Description: <br> <br>    Impersonates the client whose context is associated with the <br>supplied key. <br> <br> Return Value: <br> <br>    Returns TRUE is successful; otherwise FALSE is returned. <br> <br>--*/ <br>{ <br>SECURITY_STATUSss; <br>PAUTH_SEQpAS; <br> <br>// Lookup pAS based on Key <br>// <br>if (!GetEntry (dwKey, (PVOID*) &amp;pAS)) <br>return(FALSE); <br> <br>ss = g_pFuncs-&gt;ImpersonateSecurityContext (&amp;pAS-&gt;_hctxt); <br>if (!SEC_SUCCESS(ss)) { <br>fprintf (stderr, "Impersonate failed: %u\n", ss); <br>return(FALSE); <br>} <br> <br>return(TRUE); <br>} <br> <br>BOOL RevertContext (DWORD dwKey) <br>/*++ <br> <br> Routine Description: <br> <br>    Reverts to the original server context. <br> <br> Return Value: <br> <br>    Returns TRUE is successful; otherwise FALSE is returned. <br> <br>--*/ <br>{ <br>SECURITY_STATUS ss; <br>PAUTH_SEQpAS; <br> <br>// Lookup pAS based on Key <br>// <br>if (!GetEntry (dwKey, (PVOID*) &amp;pAS)) <br>return(FALSE); <br> <br>ss = g_pFuncs-&gt;RevertSecurityContext (&amp;pAS-&gt;_hctxt); <br>if (!SEC_SUCCESS(ss)) { <br>fprintf (stderr, "Revert failed: %u\n", ss); <br>return(FALSE); <br>} <br> <br>return(TRUE); <br>} <br> <br>BOOL InitSession (DWORD dwKey) <br>/*++ <br> <br> Routine Description: <br> <br>    Initializes the context associated with a key and adds it to the <br>collection. <br> <br> Return Value: <br> <br>    Returns TRUE is successful; otherwise FALSE is returned. <br> <br>--*/ <br>{ <br>PAUTH_SEQ pAS; <br> <br>pAS = (PAUTH_SEQ) malloc (sizeof (AUTH_SEQ)); <br>if (NULL == pAS) <br>return(FALSE); <br> <br>pAS-&gt;_fNewConversation = TRUE; <br>pAS-&gt;_fHaveCredHandle = FALSE; <br>pAS-&gt;_fHaveCtxtHandle = FALSE; <br> <br>if (!AddEntry (dwKey, (PVOID)pAS))  { <br>free (pAS); <br>return(FALSE); <br>} <br> <br>return(TRUE); <br>} <br> <br>BOOL TermSession (DWORD dwKey) <br>/*++ <br> <br> Routine Description: <br> <br>    Releases the resources associated with a key and removes it from <br>the collection. <br> <br> Return Value: <br> <br>    Returns TRUE is successful; otherwise FALSE is returned. <br> <br>--*/ <br>{ <br>PAUTH_SEQ pAS; <br> <br>if (!DeleteEntry (dwKey, (LPVOID*)&amp;pAS)) <br>return(FALSE); <br> <br>if (pAS-&gt;_fHaveCtxtHandle) <br>g_pFuncs-&gt;DeleteSecurityContext (&amp;pAS-&gt;_hctxt); <br> <br>if (pAS-&gt;_fHaveCredHandle) <br>g_pFuncs-&gt;FreeCredentialHandle (&amp;pAS-&gt;_hcred); <br> <br>free (pAS); <br> <br>return(TRUE); <br>} <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
