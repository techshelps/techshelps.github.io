<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SUBAUTH.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6239"></a>SUBAUTH.C</h2>
<pre><code>/*++ <br> <br>Copyright (c) 1987-1996  Microsoft Corporation <br> <br>Module Name: <br> <br>    subauth.c <br> <br>Abstract: <br> <br>    Sample SubAuthentication Package. <br> <br>Author: <br> <br>    Cliff Van Dyke (cliffv) 23-May-1994 <br> <br>Revisions: <br> <br>    Andy Herron (andyhe)    21-Jun-1994  Added code to read domain/user info <br> <br>Environment: <br> <br>    User mode only. <br>    Contains NT-specific code. <br>    Requires ANSI C extensions: slash-slash comments, long external names. <br> <br>Revision History: <br> <br>--*/ <br> <br> <br>#if ( _MSC_VER &gt;= 800 ) <br>#pragma warning ( 3 : 4100 ) // enable "Unreferenced formal parameter" <br>#pragma warning ( 3 : 4219 ) // enable "trailing ',' used for variable argument list" <br>#endif <br> <br>#define WIN32_NO_STATUS <br>#include &lt;windef.h&gt; <br>#undef WIN32_NO_STATUS <br>#include &lt;windows.h&gt; <br>#include &lt;lmcons.h&gt; <br>#include &lt;lmaccess.h&gt; <br>#include &lt;lmapibuf.h&gt; <br>#include "subauth.h" <br> <br> <br>BOOLEAN <br>EqualComputerName( <br>    IN PUNICODE_STRING String1, <br>    IN PUNICODE_STRING String2 <br>    ); <br> <br>NTSTATUS <br>QuerySystemTime ( <br>    OUT PLARGE_INTEGER SystemTime <br>    ); <br> <br> <br>BOOL <br>GetPasswordExpired( <br>    IN LARGE_INTEGER PasswordLastSet, <br>    IN LARGE_INTEGER MaxPasswordAge <br>    ); <br> <br>NTSTATUS <br>AccountRestrictions( <br>    IN ULONG UserRid, <br>    IN PUNICODE_STRING LogonWorkStation, <br>    IN PUNICODE_STRING WorkStations, <br>    IN PLOGON_HOURS LogonHours, <br>    OUT PLARGE_INTEGER LogoffTime, <br>    OUT PLARGE_INTEGER KickoffTime <br>    ); <br> <br>LARGE_INTEGER <br>NetpSecondsToDeltaTime( <br>    IN ULONG Seconds <br>    ); <br> <br>VOID <br>InitUnicodeString( <br>    OUT PUNICODE_STRING DestinationString, <br>    IN PCWSTR SourceString OPTIONAL <br>    ); <br> <br>VOID <br>CopyUnicodeString( <br>    OUT PUNICODE_STRING DestinationString, <br>    IN PUNICODE_STRING SourceString OPTIONAL <br>    ); <br> <br> <br>  <br>NTSTATUS <br>NTAPI <br>Msv1_0SubAuthenticationRoutine ( <br>    IN NETLOGON_LOGON_INFO_CLASS LogonLevel, <br>    IN PVOID LogonInformation, <br>    IN ULONG Flags, <br>    IN PUSER_ALL_INFORMATION UserAll, <br>    OUT PULONG WhichFields, <br>    OUT PULONG UserFlags, <br>    OUT PBOOLEAN Authoritative, <br>    OUT PLARGE_INTEGER LogoffTime, <br>    OUT PLARGE_INTEGER KickoffTime <br>) <br>/*++ <br> <br>Routine Description: <br> <br>    The subauthentication routine does client/server specific authentication <br>    of a user. The credentials of the user are passed in addition to all the <br>    information from SAM defining the user. This routine decides whether to <br>    let the user log on. <br> <br> <br>Arguments: <br> <br>    LogonLevel -- Specifies the level of information given in <br>        LogonInformation. <br> <br>    LogonInformation -- Specifies the description for the user <br>        logging on.  The LogonDomainName field should be ignored. <br> <br>    Flags - Flags describing the circumstances of the logon. <br> <br>        MSV1_0_PASSTHRU -- This is a PassThru authenication.  (i.e., the <br>            user isn't connecting to this machine.) <br>        MSV1_0_GUEST_LOGON -- This is a retry of the logon using the GUEST <br>            user account. <br> <br>    UserAll -- The description of the user as returned from SAM. <br> <br>    WhichFields -- Returns which fields from UserAllInfo are to be written <br>        back to SAM.  The fields will only be written if MSV returns success <br>        to it's caller.  Only the following bits are valid. <br> <br>        USER_ALL_PARAMETERS - Write UserAllInfo-&gt;Parameters back to SAM.  If <br>            the size of the buffer is changed, Msv1_0SubAuthenticationRoutine <br>            must delete the old buffer using MIDL_user_free() and reallocate the <br>            buffer using MIDL_user_allocate(). <br> <br>    UserFlags -- Returns UserFlags to be returned from LsaLogonUser in the <br>        LogonProfile.  The following bits are currently defined: <br> <br> <br>            LOGON_GUEST -- This was a guest logon <br>            LOGON_NOENCRYPTION -- The caller didn't specify encrypted credentials <br> <br>        SubAuthentication packages should restrict themselves to returning <br>        bits in the high order byte of UserFlags.  However, this convention <br>        isn't enforced giving the SubAuthentication package more flexibility. <br> <br>    Authoritative -- Returns whether the status returned is an <br>        authoritative status which should be returned to the original <br>        caller.  If not, this logon request may be tried again on another <br>        domain controller.  This parameter is returned regardless of the <br>        status code. <br> <br>    LogoffTime - Receives the time at which the user should log off the <br>        system.  This time is specified as a GMT relative NT system time. <br> <br>    KickoffTime - Receives the time at which the user should be kicked <br>        off the system. This time is specified as a GMT relative system <br>        time.  Specify, a full scale positive number if the user isn't to <br>        be kicked off. <br> <br>Return Value: <br> <br>    STATUS_SUCCESS: if there was no error. <br> <br>    STATUS_NO_SUCH_USER: The specified user has no account. <br>    STATUS_WRONG_PASSWORD: The password was invalid. <br> <br>    STATUS_INVALID_INFO_CLASS: LogonLevel is invalid. <br>    STATUS_ACCOUNT_LOCKED_OUT: The account is locked out <br>    STATUS_ACCOUNT_DISABLED: The account is disabled <br>    STATUS_ACCOUNT_EXPIRED: The account has expired. <br>    STATUS_PASSWORD_MUST_CHANGE: Account is marked as Password must change <br>        on next logon. <br>    STATUS_PASSWORD_EXPIRED: The Password is expired. <br>    STATUS_INVALID_LOGON_HOURS - The user is not authorized to log on at <br>        this time. <br>    STATUS_INVALID_WORKSTATION - The user is not authorized to log on to <br>        the specified workstation. <br> <br>--*/ <br>{ <br>    NTSTATUS Status; <br>    ULONG UserAccountControl; <br>    LARGE_INTEGER LogonTime; <br>    UNICODE_STRING LocalWorkstation; <br> <br>    PNETLOGON_NETWORK_INFO LogonNetworkInfo; <br> <br> <br>    // <br>    // Check whether the SubAuthentication package supports this type <br>    //  of logon. <br>    // <br> <br>    *Authoritative = TRUE; <br>    *UserFlags = 0; <br>    *WhichFields = 0; <br> <br>    (VOID) QuerySystemTime( &amp;LogonTime ); <br> <br>    switch ( LogonLevel ) { <br>    case NetlogonInteractiveInformation: <br>    case NetlogonServiceInformation: <br> <br>        // <br>        // This SubAuthentication package only supports network logons. <br>        // <br> <br>        return STATUS_INVALID_INFO_CLASS; <br> <br>    case NetlogonNetworkInformation: <br> <br>        // <br>        // This SubAuthentication package doesn't support access via machine <br>        // accounts. <br>        // <br> <br>        UserAccountControl = USER_NORMAL_ACCOUNT; <br> <br>        // <br>        // Local user (Temp Duplicate) accounts are only used on the machine <br>        // being directly logged onto. <br>        // (Nor are interactive or service logons allowed to them.) <br>        // <br> <br>        if ( (Flags &amp; MSV1_0_PASSTHRU) == 0 ) { <br>            UserAccountControl |= USER_TEMP_DUPLICATE_ACCOUNT; <br>        } <br> <br>        LogonNetworkInfo = (PNETLOGON_NETWORK_INFO) LogonInformation; <br> <br>        break; <br> <br>    default: <br>        *Authoritative = TRUE; <br>        return STATUS_INVALID_INFO_CLASS; <br>    } <br> <br> <br> <br> <br>    // <br>    // If the account type isn't allowed, <br>    //  Treat this as though the User Account doesn't exist. <br>    // <br> <br>    if ( (UserAccountControl &amp; UserAll-&gt;UserAccountControl) == 0 ) { <br>        *Authoritative = FALSE; <br>        Status = STATUS_NO_SUCH_USER; <br>        goto Cleanup; <br>    } <br> <br>    // <br>    // This SubAuthentication package doesn't allow guest logons. <br>    // <br>    if ( Flags &amp; MSV1_0_GUEST_LOGON ) { <br>        *Authoritative = FALSE; <br>        Status = STATUS_NO_SUCH_USER; <br>        goto Cleanup; <br>    } <br> <br> <br> <br>    // <br>    // Ensure the account isn't locked out. <br>    // <br> <br>    if ( UserAll-&gt;UserId != DOMAIN_USER_RID_ADMIN &amp;&amp; <br>         (UserAll-&gt;UserAccountControl &amp; USER_ACCOUNT_AUTO_LOCKED) ) { <br> <br>        // <br>        // Since the UI strongly encourages admins to disable user <br>        // accounts rather than delete them.  Treat disabled acccount as <br>        // non-authoritative allowing the search to continue for other <br>        // accounts by the same name. <br>        // <br>        if ( UserAll-&gt;UserAccountControl &amp; USER_ACCOUNT_DISABLED ) { <br>            *Authoritative = FALSE; <br>        } else { <br>            *Authoritative = TRUE; <br>        } <br>        Status = STATUS_ACCOUNT_LOCKED_OUT; <br>        goto Cleanup; <br>    } <br> <br> <br>    // <br>    // Check the password. <br>    // <br> <br>    if ( FALSE /* VALIDATE THE USER'S PASSWORD HERE */ ) { <br> <br>        Status = STATUS_WRONG_PASSWORD; <br> <br>        // <br>        // Since the UI strongly encourages admins to disable user <br>        // accounts rather than delete them.  Treat disabled acccount as <br>        // non-authoritative allowing the search to continue for other <br>        // accounts by the same name. <br>        // <br>        if ( UserAll-&gt;UserAccountControl &amp; USER_ACCOUNT_DISABLED ) { <br>            *Authoritative = FALSE; <br>        } else { <br>            *Authoritative = TRUE; <br>        } <br> <br>        goto Cleanup; <br>    } <br> <br>    // <br>    // Prevent some things from effecting the Administrator user <br>    // <br> <br>    if (UserAll-&gt;UserId == DOMAIN_USER_RID_ADMIN) { <br> <br>        // <br>        //  The administrator account doesn't have a forced logoff time. <br>        // <br> <br>        LogoffTime-&gt;HighPart = 0x7FFFFFFF; <br>        LogoffTime-&gt;LowPart = 0xFFFFFFFF; <br> <br>        KickoffTime-&gt;HighPart = 0x7FFFFFFF; <br>        KickoffTime-&gt;LowPart = 0xFFFFFFFF; <br> <br>    } else { <br> <br>        // <br>        // Check if the account is disabled. <br>        // <br> <br>        if ( UserAll-&gt;UserAccountControl &amp; USER_ACCOUNT_DISABLED ) { <br>            // <br>            // Since the UI strongly encourages admins to disable user <br>            // accounts rather than delete them.  Treat disabled acccount as <br>            // non-authoritative allowing the search to continue for other <br>            // accounts by the same name. <br>            // <br>            *Authoritative = FALSE; <br>            Status = STATUS_ACCOUNT_DISABLED; <br>            goto Cleanup; <br>        } <br> <br>        // <br>        // Check if the account has expired. <br>        // <br> <br>        if ( UserAll-&gt;AccountExpires.QuadPart != 0 &amp;&amp; <br>             LogonTime.QuadPart &gt;= UserAll-&gt;AccountExpires.QuadPart ) { <br>            *Authoritative = TRUE; <br>            Status = STATUS_ACCOUNT_EXPIRED; <br>            goto Cleanup; <br>        } <br> <br>#if 1 <br> <br>    // <br>    //  If your using SAM's password expiration date, use this code, otherwise <br>    //  use the code below and supply your own password set date... <br>    // <br> <br>        // <br>        // The password is valid, check to see if the password is expired. <br>        //  (SAM will have appropriately set PasswordMustChange to reflect <br>        //  USER_DONT_EXPIRE_PASSWORD) <br>        // <br>        // If the password checked above is not the SAM password, you may <br>        // want to consider not checking the SAM password expiration times here. <br>        // <br> <br>        if ( LogonTime.QuadPart &gt;= UserAll-&gt;PasswordMustChange.QuadPart ) { <br> <br>            if ( UserAll-&gt;PasswordLastSet.QuadPart == 0 ) { <br>                Status = STATUS_PASSWORD_MUST_CHANGE; <br>            } else { <br>                Status = STATUS_PASSWORD_EXPIRED; <br>            } <br>            *Authoritative = TRUE; <br>            goto Cleanup; <br>        } <br> <br>#else <br> <br>        // <br>        // Response is correct. So, check if the password has expired or not <br>        // <br> <br>        if (! (UserAll-&gt;UserAccountControl &amp; USER_DONT_EXPIRE_PASSWORD)) { <br>            LARGE_INTEGER MaxPasswordAge; <br>            MaxPasswordAge.HighPart = 0x7FFFFFFF; <br>            MaxPasswordAge.LowPart = 0xFFFFFFFF; <br> <br>            // <br>            // PasswordDateSet should be modified to hold the last date the <br>            // user's password was set. <br>            // <br> <br>            PasswordDateSet.LowPart = 0; <br>            PasswordDateSet.HighPart = 0; <br> <br>            if ( GetPasswordExpired( PasswordDateSet, <br>                        MaxPasswordAge )) { <br> <br>                Status = STATUS_PASSWORD_EXPIRED; <br>                goto Cleanup; <br>            } <br>        } <br> <br>#endif <br> <br> <br>#if 1 <br> <br>    // <br>    // Validate the workstation the user logged on from. <br>    // <br>    // Ditch leading \\ on workstation name before passing it to SAM. <br>    // <br> <br>    LocalWorkstation = LogonNetworkInfo-&gt;Identity.Workstation; <br>    if ( LocalWorkstation.Length &gt; 0 &amp;&amp; <br>         LocalWorkstation.Buffer[0] == L'\\' &amp;&amp; <br>         LocalWorkstation.Buffer[1] == L'\\' ) { <br>        LocalWorkstation.Buffer += 2; <br>        LocalWorkstation.Length -= 2*sizeof(WCHAR); <br>        LocalWorkstation.MaximumLength -= 2*sizeof(WCHAR); <br>    } <br> <br> <br>    // <br>    //  To validate the user's logon hours as SAM does it, use this code, <br>    //  otherwise, supply your own checks below this code. <br>    // <br> <br>    Status = AccountRestrictions( UserAll-&gt;UserId, <br>                                  &amp;LocalWorkstation, <br>                                  (PUNICODE_STRING) &amp;UserAll-&gt;WorkStations, <br>                                  &amp;UserAll-&gt;LogonHours, <br>                                  LogoffTime, <br>                                  KickoffTime ); <br> <br>    if ( !NT_SUCCESS( Status )) { <br>        goto Cleanup; <br>    } <br> <br>#else <br> <br>        // <br>        // Validate the user's logon hours. <br>        // <br> <br>        if ( TRUE /* VALIDATE THE LOGON HOURS */ ) { <br> <br> <br>            // <br>            // All times are allowed, so there's no logoff <br>            // time.  Return forever for both logofftime and <br>            // kickofftime. <br>            // <br> <br>            LogoffTime-&gt;HighPart = 0x7FFFFFFF; <br>            LogoffTime-&gt;LowPart = 0xFFFFFFFF; <br> <br>            KickoffTime-&gt;HighPart = 0x7FFFFFFF; <br>            KickoffTime-&gt;LowPart = 0xFFFFFFFF; <br>        } else { <br>            Status = STATUS_INVALID_LOGON_HOURS; <br>            *Authoritative = TRUE; <br>            goto Cleanup; <br>        } <br>#endif <br> <br>        // <br>        // Validate if the user can log on from this workstation. <br>        //  (Supply subauthentication package specific code here.) <br> <br>        if ( LogonNetworkInfo-&gt;Identity.Workstation.Buffer == NULL ) { <br>            Status = STATUS_INVALID_WORKSTATION; <br>            *Authoritative = TRUE; <br>            goto Cleanup; <br>        } <br>    } <br> <br> <br>    // <br>    // The user is valid. <br>    // <br> <br>    *Authoritative = TRUE; <br>    Status = STATUS_SUCCESS; <br> <br>    // <br>    // Cleanup up before returning. <br>    // <br> <br>Cleanup: <br> <br>    return Status; <br> <br>}  // Msv1_0SubAuthenticationRoutine <br> <br> <br> <br> <br>BOOL <br>GetPasswordExpired ( <br>    IN LARGE_INTEGER PasswordLastSet, <br>    IN LARGE_INTEGER MaxPasswordAge <br>    ) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    This routine returns true if the password is expired, false otherwise. <br> <br>Arguments: <br> <br>    PasswordLastSet - Time when the password was last set for this user. <br> <br>    MaxPasswordAge - Maximum password age for any password in the domain. <br> <br>Return Value: <br> <br>    Returns true if password is expired.  False if not expired. <br> <br>--*/ <br>{ <br>    LARGE_INTEGER PasswordMustChange; <br>    NTSTATUS Status; <br>    BOOLEAN rc; <br>    LARGE_INTEGER TimeNow; <br> <br>    // <br>    // Compute the expiration time as the time the password was <br>    // last set plus the maximum age. <br>    // <br> <br>    if ( PasswordLastSet.QuadPart &lt; 0 || MaxPasswordAge.QuadPart &gt; 0 ) { <br> <br>        rc = TRUE;      // default for invalid times is that it is expired. <br> <br>    } else { <br> <br>        __try { <br> <br>            PasswordMustChange.QuadPart = <br>                PasswordLastSet.QuadPart - MaxPasswordAge.QuadPart; <br>            // <br>            // Limit the resultant time to the maximum valid absolute time <br>            // <br> <br>            if ( PasswordMustChange.QuadPart &lt; 0 ) { <br> <br>                rc = FALSE; <br> <br>            } else { <br> <br>                Status = QuerySystemTime( &amp;TimeNow ); <br>                if (NT_SUCCESS(Status)) { <br> <br>                    if ( TimeNow.QuadPart &gt;= PasswordMustChange.QuadPart ) { <br>                        rc = TRUE; <br> <br>                    } else { <br> <br>                        rc = FALSE; <br>                    } <br>                } else { <br>                    rc = FALSE;     // won't fail if QuerySystemTime failed. <br>                } <br>            } <br> <br>        } __except(EXCEPTION_EXECUTE_HANDLER) { <br> <br>            rc = TRUE; <br>        } <br>    } <br> <br>    return rc; <br> <br>}  // GetPasswordExpired <br> <br>  <br>NTSTATUS <br>QuerySystemTime ( <br>    OUT PLARGE_INTEGER SystemTime <br>    ) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    This function returns the absolute system time. The time is in units of <br>    100nsec ticks since the base time which is midnight January 1, 1601. <br> <br>Arguments: <br> <br>    SystemTime - Supplies the address of a variable that will receive the <br>        current system time. <br> <br>Return Value: <br> <br>    STATUS_SUCCESS is returned if the service is successfully executed. <br> <br>    STATUS_ACCESS_VIOLATION is returned if the output parameter for the <br>        system time cannot be written. <br> <br>--*/ <br> <br>{ <br>    SYSTEMTIME CurrentTime; <br> <br>    GetSystemTime( &amp;CurrentTime ); <br> <br>    if ( !SystemTimeToFileTime( &amp;CurrentTime, (LPFILETIME) SystemTime ) ) { <br>        return STATUS_ACCESS_VIOLATION; <br>    } <br> <br>    return STATUS_SUCCESS; <br>} <br> <br>NTSTATUS <br>SampMatchworkstation( <br>    IN PUNICODE_STRING LogonWorkStation, <br>    IN PUNICODE_STRING WorkStations <br>    ) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    Check if the given workstation is a member of the list of workstations <br>    given. <br> <br> <br>Arguments: <br> <br>    LogonWorkStations - UNICODE name of the workstation that the user is <br>        trying to log into. <br> <br>    WorkStations - API list of workstations that the user is allowed to <br>        log into. <br> <br> <br>Return Value: <br> <br> <br>    STATUS_SUCCESS - The user is allowed to log into the workstation. <br> <br> <br> <br>--*/ <br>{ <br>    PWCHAR          WorkStationName; <br>    UNICODE_STRING  Unicode; <br>    NTSTATUS        NtStatus; <br>    WCHAR           Buffer[256]; <br>    USHORT          LocalBufferLength = 256; <br>    UNICODE_STRING  WorkStationsListCopy; <br>    BOOLEAN         BufferAllocated = FALSE; <br>    PWCHAR          TmpBuffer; <br> <br>    // <br>    // Local workstation is always allowed <br>    // If WorkStations field is 0 everybody is allowed <br>    // <br> <br>    if ( ( LogonWorkStation == NULL ) || <br>        ( LogonWorkStation-&gt;Length == 0 ) || <br>        ( WorkStations-&gt;Length == 0 ) ) { <br> <br>        return( STATUS_SUCCESS ); <br>    } <br> <br>    // <br>    // Assume failure; change status only if we find the string. <br>    // <br> <br>    NtStatus = STATUS_INVALID_WORKSTATION; <br> <br>    // <br>    // WorkStationApiList points to our current location in the list of <br>    // WorkStations. <br>    // <br> <br>    if ( WorkStations-&gt;Length &gt; LocalBufferLength ) { <br> <br>        WorkStationsListCopy.Buffer = LocalAlloc( 0, WorkStations-&gt;Length ); <br>        BufferAllocated = TRUE; <br> <br>        if ( WorkStationsListCopy.Buffer == NULL ) { <br>            NtStatus = STATUS_INSUFFICIENT_RESOURCES; <br>            return( NtStatus ); <br>        } <br> <br>        WorkStationsListCopy.MaximumLength = WorkStations-&gt;Length; <br> <br>    } else { <br> <br>        WorkStationsListCopy.Buffer = Buffer; <br>        WorkStationsListCopy.MaximumLength = LocalBufferLength; <br>    } <br> <br>    CopyUnicodeString( &amp;WorkStationsListCopy, WorkStations ); <br> <br>    // <br>    // wcstok requires a string the first time it's called, and NULL <br>    // for all subsequent calls.  Use a temporary variable so we <br>    // can do this. <br>    // <br> <br>    TmpBuffer = WorkStationsListCopy.Buffer; <br> <br>    while( WorkStationName = wcstok(TmpBuffer, L",") ) { <br> <br>        TmpBuffer = NULL; <br>        InitUnicodeString( &amp;Unicode, WorkStationName ); <br>        if (EqualComputerName( &amp;Unicode, LogonWorkStation )) { <br>            NtStatus = STATUS_SUCCESS; <br>            break; <br>        } <br>    } <br> <br>    if ( BufferAllocated ) { <br>        LocalFree( WorkStationsListCopy.Buffer ); <br>    } <br> <br>    return( NtStatus ); <br>} <br> <br>NTSTATUS <br>AccountRestrictions( <br>    IN ULONG UserRid, <br>    IN PUNICODE_STRING LogonWorkStation, <br>    IN PUNICODE_STRING WorkStations, <br>    IN PLOGON_HOURS LogonHours, <br>    OUT PLARGE_INTEGER LogoffTime, <br>    OUT PLARGE_INTEGER KickoffTime <br>    ) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    Validate a user's ability to log on at this time and at the workstation <br>    being logged onto. <br> <br> <br>Arguments: <br> <br>    UserRid - The user id of the user to operate on. <br> <br>    LogonWorkStation - The name of the workstation the logon is being <br>        attempted at. <br> <br>    WorkStations - The list of workstations the user may log on to.  This <br>        information comes from the user's account information.  It must <br>        be in API list format. <br> <br>    LogonHours - The times the user may logon.  This information comes <br>        from the user's account information. <br> <br>    LogoffTime - Receives the time at which the user should log off the <br>        system. <br> <br>    KickoffTime - Receives the time at which the user should be kicked <br>        off the system. <br> <br> <br>Return Value: <br> <br> <br>    STATUS_SUCCESS - Logon is permitted. <br> <br>    STATUS_INVALID_LOGON_HOURS - The user is not authorized to log on at <br>        this time. <br> <br>    STATUS_INVALID_WORKSTATION - The user is not authorized to log on to <br>        the specified workstation. <br> <br> <br>--*/ <br>{ <br> <br>    static BOOLEAN GetForceLogoff = TRUE; <br>    static LARGE_INTEGER ForceLogoff = { 0x7fffffff, 0xFFFFFFF}; <br> <br>#define MILLISECONDS_PER_WEEK 7 * 24 * 60 * 60 * 1000 <br> <br>    SYSTEMTIME              CurrentTimeFields; <br>    LARGE_INTEGER           CurrentTime, CurrentUTCTime; <br>    LARGE_INTEGER           MillisecondsIntoWeekXUnitsPerWeek; <br>    LARGE_INTEGER           LargeUnitsIntoWeek; <br>    LARGE_INTEGER           Delta100Ns; <br>    NTSTATUS                NtStatus = STATUS_SUCCESS; <br>    ULONG                   CurrentMsIntoWeek; <br>    ULONG                   LogoffMsIntoWeek; <br>    ULONG                   DeltaMs; <br>    ULONG                   MillisecondsPerUnit; <br>    ULONG                   CurrentUnitsIntoWeek; <br>    ULONG                   LogoffUnitsIntoWeek; <br>    USHORT                  i; <br>    TIME_ZONE_INFORMATION   TimeZoneInformation; <br>    DWORD TimeZoneId; <br>    LARGE_INTEGER           BiasIn100NsUnits; <br>    LONG                    BiasInMinutes; <br> <br> <br> <br>    // <br>    // Only check for users other than the builtin ADMIN <br>    // <br> <br>    if ( UserRid != DOMAIN_USER_RID_ADMIN) { <br> <br>        // <br>        // Scan to make sure the workstation being logged into is in the <br>        // list of valid workstations - or if the list of valid workstations <br>        // is null, which means that all are valid. <br>        // <br> <br>        NtStatus = SampMatchworkstation( LogonWorkStation, WorkStations ); <br> <br>        if ( NT_SUCCESS( NtStatus ) ) { <br> <br>            // <br>            // Check to make sure that the current time is a valid time to log <br>            // on in the LogonHours. <br>            // <br>            // We need to validate the time taking into account whether we are <br>            // in daylight savings time or standard time.  Thus, if the logon <br>            // hours specify that we are able to log on between 9am and 5pm, <br>            // this means 9am to 5pm standard time during the standard time <br>            // period, and 9am to 5pm daylight savings time when in the <br>            // daylight savings time.  Since the logon hours stored by SAM are <br>            // independent of daylight savings time, we need to add in the <br>            // difference between standard time and daylight savings time to <br>            // the current time before checking whether this time is a valid <br>            // time to log on.  Since this difference (or bias as it is called) <br>            // is actually held in the form <br>            // <br>            // Standard time = Daylight savings time + Bias <br>            // <br>            // the Bias is a negative number.  Thus we actually subtract the <br>            // signed Bias from the Current Time. <br> <br>            // <br>            // First, get the Time Zone Information. <br>            // <br> <br>            TimeZoneId = GetTimeZoneInformation( <br>                             (LPTIME_ZONE_INFORMATION) &amp;TimeZoneInformation <br>                             ); <br> <br>            // <br>            // Next, get the appropriate bias (signed integer in minutes) to subtract from <br>            // the Universal Time Convention (UTC) time returned by NtQuerySystemTime <br>            // to get the local time.  The bias to be used depends whether we're <br>            // in Daylight Savings time or Standard Time as indicated by the <br>            // TimeZoneId parameter. <br>            // <br>            // local time  = UTC time - bias in 100Ns units <br>            // <br> <br>            switch (TimeZoneId) { <br> <br>            case TIME_ZONE_ID_UNKNOWN: <br> <br>                // <br>                // There is no differentiation between standard and <br>                // daylight savings time.  Proceed as for Standard Time <br>                // <br> <br>                BiasInMinutes = TimeZoneInformation.StandardBias; <br>                break; <br> <br>            case TIME_ZONE_ID_STANDARD: <br> <br>                BiasInMinutes = TimeZoneInformation.StandardBias; <br>                break; <br> <br>            case TIME_ZONE_ID_DAYLIGHT: <br> <br>                BiasInMinutes = TimeZoneInformation.DaylightBias; <br>                break; <br> <br>            default: <br> <br>                // <br>                // Something is wrong with the time zone information.  Fail <br>                // the logon request. <br>                // <br> <br>                NtStatus = STATUS_INVALID_LOGON_HOURS; <br>                break; <br>            } <br> <br>            if (NT_SUCCESS(NtStatus)) { <br> <br>                // <br>                // Convert the Bias from minutes to 100ns units <br>                // <br> <br>                BiasIn100NsUnits.QuadPart = ((LONGLONG)BiasInMinutes) <br>                                            * 60 * 10000000; <br> <br>                // <br>                // Get the UTC time in 100Ns units used by Windows Nt.  This <br>                // time is GMT. <br>                // <br> <br>                NtStatus = QuerySystemTime( &amp;CurrentUTCTime ); <br>            } <br> <br>            if ( NT_SUCCESS( NtStatus ) ) { <br> <br>                CurrentTime.QuadPart = CurrentUTCTime.QuadPart - <br>                              BiasIn100NsUnits.QuadPart; <br> <br>                FileTimeToSystemTime( (PFILETIME)&amp;CurrentTime, &amp;CurrentTimeFields ); <br> <br>                CurrentMsIntoWeek = (((( CurrentTimeFields.wDayOfWeek * 24 ) + <br>                                       CurrentTimeFields.wHour ) * 60 + <br>                                       CurrentTimeFields.wMinute ) * 60 + <br>                                       CurrentTimeFields.wSecond ) * 1000 + <br>                                       CurrentTimeFields.wMilliseconds; <br> <br>                MillisecondsIntoWeekXUnitsPerWeek.QuadPart = <br>                    ((LONGLONG)CurrentMsIntoWeek) * <br>                    ((LONGLONG)LogonHours-&gt;UnitsPerWeek); <br> <br>                LargeUnitsIntoWeek.QuadPart = <br>                    MillisecondsIntoWeekXUnitsPerWeek.QuadPart / ((ULONG) MILLISECONDS_PER_WEEK); <br> <br>                CurrentUnitsIntoWeek = LargeUnitsIntoWeek.LowPart; <br> <br>                if ( !( LogonHours-&gt;LogonHours[ CurrentUnitsIntoWeek / 8] &amp; <br>                    ( 0x01 &lt;&lt; ( CurrentUnitsIntoWeek % 8 ) ) ) ) { <br> <br>                    NtStatus = STATUS_INVALID_LOGON_HOURS; <br> <br>                } else { <br> <br>                    // <br>                    // Determine the next time that the user is NOT supposed to be logged <br>                    // in, and return that as LogoffTime. <br>                    // <br> <br>                    i = 0; <br>                    LogoffUnitsIntoWeek = CurrentUnitsIntoWeek; <br> <br>                    do { <br> <br>                        i++; <br> <br>                        LogoffUnitsIntoWeek = ( LogoffUnitsIntoWeek + 1 ) % LogonHours-&gt;UnitsPerWeek; <br> <br>                    } while ( ( i &lt;= LogonHours-&gt;UnitsPerWeek ) &amp;&amp; <br>                        ( LogonHours-&gt;LogonHours[ LogoffUnitsIntoWeek / 8 ] &amp; <br>                        ( 0x01 &lt;&lt; ( LogoffUnitsIntoWeek % 8 ) ) ) ); <br> <br>                    if ( i &gt; LogonHours-&gt;UnitsPerWeek ) { <br> <br>                        // <br>                        // All times are allowed, so there's no logoff <br>                        // time.  Return forever for both LogoffTime and <br>                        // KickoffTime. <br>                        // <br> <br>                        LogoffTime-&gt;HighPart = 0x7FFFFFFF; <br>                        LogoffTime-&gt;LowPart = 0xFFFFFFFF; <br> <br>                        KickoffTime-&gt;HighPart = 0x7FFFFFFF; <br>                        KickoffTime-&gt;LowPart = 0xFFFFFFFF; <br> <br>                    } else { <br> <br>                        // <br>                        // LogoffUnitsIntoWeek points at which time unit the <br>                        // user is to log off.  Calculate actual time from <br>                        // the unit, and return it. <br>                        // <br>                        // CurrentTimeFields already holds the current <br>                        // time for some time during this week; just adjust <br>                        // to the logoff time during this week and convert <br>                        // to time format. <br>                        // <br> <br>                        MillisecondsPerUnit = MILLISECONDS_PER_WEEK / LogonHours-&gt;UnitsPerWeek; <br> <br>                        LogoffMsIntoWeek = MillisecondsPerUnit * LogoffUnitsIntoWeek; <br> <br>                        if ( LogoffMsIntoWeek &lt; CurrentMsIntoWeek ) { </code></pre>
<p>
</p>
<pre><code><br>                            DeltaMs = MILLISECONDS_PER_WEEK - ( CurrentMsIntoWeek - LogoffMsIntoWeek ); <br> <br>                        } else { <br> <br>                            DeltaMs = LogoffMsIntoWeek - CurrentMsIntoWeek; <br>                        } <br> <br>                        Delta100Ns.QuadPart = (LONGLONG) DeltaMs * 10000; <br> <br>                        LogoffTime-&gt;QuadPart = CurrentUTCTime.QuadPart + <br>                                      Delta100Ns.QuadPart; <br> <br>                        // <br>                        // Grab the domain's ForceLogoff time. <br>                        // <br> <br>                        if ( GetForceLogoff ) { <br>                            NET_API_STATUS NetStatus; <br>                            LPUSER_MODALS_INFO_0 UserModals0; <br> <br>                            NetStatus = NetUserModalsGet( NULL, <br>                                                          0, <br>                                                          (LPBYTE *)&amp;UserModals0 ); <br> <br>                            if ( NetStatus == 0 ) { <br>                                GetForceLogoff = FALSE; <br> <br>                                ForceLogoff = NetpSecondsToDeltaTime( UserModals0-&gt;usrmod0_force_logoff ); <br> <br>                                NetApiBufferFree( UserModals0 ); <br>                            } <br>                        } <br>                        // <br>                        // Subtract Domain-&gt;ForceLogoff from LogoffTime, and return <br>                        // that as KickoffTime.  Note that Domain-&gt;ForceLogoff is a <br>                        // negative delta.  If its magnitude is sufficiently large <br>                        // (in fact, larger than the difference between LogoffTime <br>                        // and the largest positive large integer), we'll get overflow <br>                        // resulting in a KickOffTime that is negative.  In this <br>                        // case, reset the KickOffTime to this largest positive <br>                        // large integer (i.e. "never") value. <br>                        // <br> <br> <br>                        KickoffTime-&gt;QuadPart = LogoffTime-&gt;QuadPart - ForceLogoff.QuadPart; <br> <br>                        if (KickoffTime-&gt;QuadPart &lt; 0) { <br> <br>                            KickoffTime-&gt;HighPart = 0x7FFFFFFF; <br>                            KickoffTime-&gt;LowPart = 0xFFFFFFFF; <br>                        } <br>                    } <br>                } <br>            } <br>        } <br> <br>    } else { <br> <br>        // <br>        // Never kick administrators off <br>        // <br> <br>        LogoffTime-&gt;HighPart  = 0x7FFFFFFF; <br>        LogoffTime-&gt;LowPart   = 0xFFFFFFFF; <br>        KickoffTime-&gt;HighPart = 0x7FFFFFFF; <br>        KickoffTime-&gt;LowPart  = 0xFFFFFFFF; <br>    } <br> <br> <br>    return( NtStatus ); <br>} <br> <br>LARGE_INTEGER <br>NetpSecondsToDeltaTime( <br>    IN ULONG Seconds <br>    ) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    Convert a number of seconds to an NT delta time specification <br> <br>Arguments: <br> <br>    Seconds - a positive number of seconds <br> <br>Return Value: <br> <br>    Returns the NT Delta time.  NT delta time is a negative number <br>        of 100ns units. <br> <br>--*/ <br> <br>{ <br>    LARGE_INTEGER DeltaTime; <br>    LARGE_INTEGER LargeSeconds; <br>    LARGE_INTEGER Answer; <br> <br>    // <br>    // Special case TIMEQ_FOREVER (return a full scale negative) <br>    // <br> <br>    if ( Seconds == TIMEQ_FOREVER ) { <br>        DeltaTime.LowPart = 0; <br>        DeltaTime.HighPart = (LONG) 0x80000000; <br> <br>    // <br>    // Convert seconds to 100ns units simply by multiplying by 10000000. <br>    // <br>    // Convert to delta time by negating. <br>    // <br> <br>    } else { <br> <br>        LargeSeconds.LowPart = Seconds; <br>        LargeSeconds.HighPart = 0; <br> <br>        Answer.QuadPart = LargeSeconds.QuadPart * 10000000; <br> <br>          if ( Answer.QuadPart &lt; 0 ) { <br>            DeltaTime.LowPart = 0; <br>            DeltaTime.HighPart = (LONG) 0x80000000; <br>        } else { <br>            DeltaTime.QuadPart = -Answer.QuadPart; <br>        } <br> <br>    } <br> <br>    return DeltaTime; <br> <br>} // NetpSecondsToDeltaTime <br> <br> <br>BOOLEAN <br>EqualComputerName( <br>    IN PUNICODE_STRING String1, <br>    IN PUNICODE_STRING String2 <br>    ) <br>/*++ <br> <br>Routine Description: <br> <br>    Compare two computer names for equality. <br> <br>Arguments: <br> <br>    String1 - Name of first computer. <br>    String2 - Name of second computer. <br> <br>Return Value: <br> <br>    TRUE if the names, converted to OEM, compare case-insensitively, <br>    FALSE if they don't compare or can't be converted to OEM. <br> <br>--*/ <br>{ <br>    WCHAR Computer1[CNLEN+1]; <br>    WCHAR Computer2[CNLEN+1]; <br>    CHAR OemComputer1[CNLEN+1]; <br>    CHAR OemComputer2[CNLEN+1]; <br> <br>    // <br>    // Make sure the names are not too long <br>    // <br> <br>    if ((String1-&gt;Length &gt; CNLEN*sizeof(WCHAR)) || <br>        (String2-&gt;Length &gt; CNLEN*sizeof(WCHAR))) { <br>        return(FALSE); <br> <br>    } <br> <br>    // <br>    // Copy them to null terminated strings <br>    // <br> <br>    CopyMemory( <br>        Computer1, <br>        String1-&gt;Buffer, <br>        String1-&gt;Length <br>        ); <br>    Computer1[String1-&gt;Length/sizeof(WCHAR)] = L'\0'; <br> <br>    CopyMemory( <br>        Computer2, <br>        String2-&gt;Buffer, <br>        String2-&gt;Length <br>        ); <br>    Computer2[String2-&gt;Length/sizeof(WCHAR)] = L'\0'; <br> <br>    // <br>    // Convert the computer names to OEM <br>    // <br> <br>    if (!CharToOemW( <br>            Computer1, <br>            OemComputer1 <br>            )) { <br>        return(FALSE); <br>    } <br> <br>    if (!CharToOemW( <br>            Computer2, <br>            OemComputer2 <br>            )) { <br>        return(FALSE); <br>    } <br> <br>    // <br>    // Do a case insensitive comparison of the oem computer names. <br>    // <br> <br>    if (lstrcmpiA(OemComputer1, OemComputer2) == 0) <br>    { <br>        return(TRUE); <br>    } <br>    else <br>    { <br>        return(FALSE); <br>    } <br>} <br> <br>VOID <br>InitUnicodeString( <br>    OUT PUNICODE_STRING DestinationString, <br>    IN PCWSTR SourceString OPTIONAL <br>    ) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    The InitUnicodeString function initializes an NT counted <br>    unicode string.  The DestinationString is initialized to point to <br>    the SourceString and the Length and MaximumLength fields of <br>    DestinationString are initialized to the length of the SourceString, <br>    which is zero if SourceString is not specified. <br> <br>Arguments: <br> <br>    DestinationString - Pointer to the counted string to initialize <br> <br>    SourceString - Optional pointer to a null terminated unicode string that <br>        the counted string is to point to. <br> <br> <br>Return Value: <br> <br>    None. <br> <br>--*/ <br> <br>{ <br>    ULONG Length; <br> <br>    DestinationString-&gt;Buffer = (PWSTR)SourceString; <br>    if (SourceString != NULL) { <br>        Length = wcslen( SourceString ) * sizeof( WCHAR ); <br>        DestinationString-&gt;Length = (USHORT)Length; <br>        DestinationString-&gt;MaximumLength = (USHORT)(Length + sizeof(UNICODE_NULL)); <br>        } <br>    else { <br>        DestinationString-&gt;MaximumLength = 0; <br>        DestinationString-&gt;Length = 0; <br>        } <br>} <br> <br>VOID <br>CopyUnicodeString( <br>    OUT PUNICODE_STRING DestinationString, <br>    IN PUNICODE_STRING SourceString OPTIONAL <br>    ) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    The CopyString function copies the SourceString to the <br>    DestinationString.  If SourceString is not specified, then <br>    the Length field of DestinationString is set to zero.  The <br>    MaximumLength and Buffer fields of DestinationString are not <br>    modified by this function. <br> <br>    The number of bytes copied from the SourceString is either the <br>    Length of SourceString or the MaximumLength of DestinationString, <br>    whichever is smaller. <br> <br>Arguments: <br> <br>    DestinationString - Pointer to the destination string. <br> <br>    SourceString - Optional pointer to the source string. <br> <br>Return Value: <br> <br>    None. <br> <br>--*/ <br> <br>{ <br>    UNALIGNED WCHAR *src, *dst; <br>    ULONG n; <br> <br>    if (SourceString != NULL) { <br>        dst = DestinationString-&gt;Buffer; <br>        src = SourceString-&gt;Buffer; <br>        n = SourceString-&gt;Length; <br>        if ((USHORT)n &gt; DestinationString-&gt;MaximumLength) { <br>            n = DestinationString-&gt;MaximumLength; <br>        } <br> <br>        DestinationString-&gt;Length = (USHORT)n; <br>        CopyMemory(dst, src, n); <br>        if (DestinationString-&gt;Length &lt; DestinationString-&gt;MaximumLength) { <br>            dst[n / sizeof(WCHAR)] = UNICODE_NULL; <br>        } <br> <br>    } else { <br>        DestinationString-&gt;Length = 0; <br>    } <br> <br>    return; <br>} <br> <br>  <br>NTSTATUS <br>NTAPI <br>Msv1_0SubAuthenticationFilter ( <br>    IN NETLOGON_LOGON_INFO_CLASS LogonLevel, <br>    IN PVOID LogonInformation, <br>    IN ULONG Flags, <br>    IN PUSER_ALL_INFORMATION UserAll, <br>    OUT PULONG WhichFields, <br>    OUT PULONG UserFlags, <br>    OUT PBOOLEAN Authoritative, <br>    OUT PLARGE_INTEGER LogoffTime, <br>    OUT PLARGE_INTEGER KickoffTime <br>) <br>{ <br>    return( Msv1_0SubAuthenticationRoutine( <br>                LogonLevel, <br>                LogonInformation, <br>                Flags, <br>                UserAll, <br>                WhichFields, <br>                UserFlags, <br>                Authoritative, <br>                LogoffTime, <br>                KickoffTime <br>                ) ); <br>} <br>// subauth.c eof <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
