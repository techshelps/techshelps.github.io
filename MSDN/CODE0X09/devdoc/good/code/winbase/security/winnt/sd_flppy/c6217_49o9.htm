<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>INSTSRV.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6219"></a>INSTSRV.C</h2>
<pre><code>#include &lt;windows.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;string.h&gt; <br> <br>#define FORCE_SERVICE_NAME_TO_FLOPPYLOCK (1==0) <br> <br>#define PERR(api) printf("\n%s: Error %d from %s on line %d",  \ <br>    __FILE__, GetLastError(), api, __LINE__); <br>#define PMSG(msg) printf("\n%s line %d: %s",  \ <br>    __FILE__, __LINE__, msg); <br> <br>#define MSG_FOR_ACCESS_DENIED "You aren't authorized to do this - please see your system Administrator" <br>#define MSG_1_FOR_BAD_PATH "The fully qualified path name to the .exe must be given, and" <br>#define MSG_2_FOR_BAD_PATH "  the drive letter must be for a fixed disk (e.g., not a net drive)" <br> <br>SC_HANDLE schService; <br>SC_HANDLE schSCManager; <br> <br>VOID DisplayHelp(VOID); <br> <br>VOID InstallService(LPCTSTR serviceName, LPCTSTR serviceExe) <br>{ <br>  LPCTSTR lpszBinaryPathName = serviceExe; <br>  LPTSTR  lpszRootPathName="?:\\"; <br> <br>  if ( (':' != *(lpszBinaryPathName+1)) || ('\\' != *(lpszBinaryPathName+2)) ) <br>  { printf("\n%s",MSG_1_FOR_BAD_PATH); <br>    printf("\n%s\n",MSG_2_FOR_BAD_PATH); <br>    return; <br>  } <br> <br>  #define DRIVE_TYPE_INDETERMINATE 0 <br>  #define ROOT_DIR_DOESNT_EXIST    1 <br> <br>  *lpszRootPathName = *(lpszBinaryPathName+0) ; <br> <br>  switch (  GetDriveType(lpszRootPathName)  ) <br>  { <br>    case DRIVE_FIXED : <br>    { // OK <br>      break; <br>    } <br>    case  ROOT_DIR_DOESNT_EXIST : <br>    { printf("\n%s",MSG_1_FOR_BAD_PATH); <br>      printf("\n  the root directory where the .exe is specified to be must exist, and"); <br>      printf("\n%s\n",MSG_2_FOR_BAD_PATH); <br>      return; <br>    } <br>    case  DRIVE_TYPE_INDETERMINATE : <br>    case  DRIVE_REMOVABLE          : <br>    case  DRIVE_REMOTE             : <br>    case  DRIVE_CDROM              : <br>    case  DRIVE_RAMDISK            : <br>    { printf("\n%s",MSG_1_FOR_BAD_PATH); <br>      printf("\n%s\n",MSG_2_FOR_BAD_PATH); <br>      return; <br>    } <br>    default : <br>    { printf("\n%s",MSG_1_FOR_BAD_PATH); <br>      printf("\n%s\n",MSG_2_FOR_BAD_PATH); <br>      return; <br>    } <br>  } <br> <br>  if (INVALID_HANDLE_VALUE == CreateFile(lpszBinaryPathName, <br>                                         GENERIC_READ, <br>                                         FILE_SHARE_READ, <br>                                         NULL, <br>                                         OPEN_EXISTING, <br>                                         FILE_ATTRIBUTE_NORMAL, <br>                                         NULL)) <br>  { printf("\n%s",MSG_1_FOR_BAD_PATH); <br>    printf("\n  the file must exist, and"); <br>    printf("\n%s\n",MSG_2_FOR_BAD_PATH); <br>    return; <br>  } <br> <br>  if (FORCE_SERVICE_NAME_TO_FLOPPYLOCK) <br>  { schService = CreateService( <br>        schSCManager,               // SCManager database <br>        serviceName,                // name of service <br>        serviceName,                // name to display (new parameter after october beta) <br>        SERVICE_ALL_ACCESS,         // desired access <br>        SERVICE_WIN32_OWN_PROCESS,  // service type <br>        SERVICE_AUTO_START,         // start type <br>        SERVICE_ERROR_NORMAL,       // error control type <br>        lpszBinaryPathName,         // service's binary <br>        NULL,                       // no load ordering group <br>        NULL,                       // no tag identifier <br>        NULL,                       // no dependencies <br>        NULL,                       // Local System account <br>        NULL);                      // null password <br>  } <br>  else <br>  { schService = CreateService( <br>        schSCManager,               // SCManager database <br>        serviceName,                // name of service <br>        serviceName,                // name to display (new parameter after october beta) <br>        SERVICE_ALL_ACCESS,         // desired access <br>        SERVICE_WIN32_OWN_PROCESS,  // service type <br>        SERVICE_AUTO_START,         // start type <br>        SERVICE_ERROR_NORMAL,       // error control type <br>        lpszBinaryPathName,         // service's binary <br>        NULL,                       // no load ordering group <br>        NULL,                       // no tag identifier <br>        NULL,                       // no dependencies <br>        ".\\Administrator",         // Admin account <br>        "");                        // likely incorrect password <br>  } <br> <br>  if (NULL == schService) <br>  { switch (GetLastError()) <br>    { <br>      case ERROR_ACCESS_DENIED : <br>      { printf("\n%s",MSG_FOR_ACCESS_DENIED); <br>        break; <br>      } <br>      case ERROR_SERVICE_EXISTS : <br>      { printf("\nThe %s service is already installed",serviceName); <br>        printf("\nRemove it first if you need to re-install a new version\n"); <br>        break; <br>      } <br>      default : <br>      { PERR("CreateService"); <br>      } <br>    } <br>    return; <br>  } <br>  else <br>  { if (FORCE_SERVICE_NAME_TO_FLOPPYLOCK) <br>    { printf("\nThe FloppyLock service was installed successfully.\n"); <br>      printf("\nImportant! Before you can use the FloppyLock service, start Control"); <br>      printf("\nPanel and choose the Services applet.  Then select the FloppyLock"); <br>      printf("\nservice and press Startup.  Select System Account, or else FloppyLock"); <br>      printf("\nwill not be able to start properly.  If you want the service to start"); <br>      printf("\nautomatically, select Automatic.\n"); <br>    } <br>    else <br>    { printf("\nCreateService SUCCESS\n"); <br>      printf("\nDon't forget!!! You must now go to the Control Panel and"); <br>      printf("\n  use the Services applet to change the account name and"); <br>      printf("\n  password that this newly installed service will use when"); <br>      printf("\n  it attempts to logon as a service when it starts."); <br>      printf("\nTo do this: use the Startup button in the Services applet,"); <br>      printf("\n  and (for example) specify the Administrator account and"); <br>      printf("\n  correct password."); <br>      printf("\nAlso, use the Services applet to ensure this newly installed"); <br>      printf("\n  service starts automatically, since the point of this"); <br>      printf("\n  service is to start automatically and apply the DACLs"); <br>      printf("\n  to the floppy drives prior to a user logging on at"); <br>      printf("\n  the keyboard\n"); <br>    } <br>  } <br> <br>  CloseServiceHandle(schService); <br>} <br> <br>VOID RemoveService(LPCTSTR serviceName) <br>{ <br>  { <br>    #define                                     SZ_ENUM_BUF 4096 <br>    ENUM_SERVICE_STATUS        essServiceStatus[SZ_ENUM_BUF]; <br>    DWORD   dwBufSize = sizeof(essServiceStatus); <br>    DWORD   dwBytesNeeded      = 0; <br>    DWORD   dwServicesReturned = 0; <br>    DWORD   dwResumeHandle     = 0; <br>    DWORD   dwI                = 0; <br>    BOOLEAN bFound = FALSE; <br> <br>    if (!EnumServicesStatus(schSCManager, <br>                            SERVICE_WIN32, <br>                            SERVICE_ACTIVE, <br>                            (LPENUM_SERVICE_STATUS)&amp;essServiceStatus, <br>                            dwBufSize, <br>                            &amp;dwBytesNeeded, <br>                            &amp;dwServicesReturned, <br>                            &amp;dwResumeHandle)) <br>    { switch (GetLastError()) <br>      { <br>        case ERROR_ACCESS_DENIED : <br>        { printf("\n%s",MSG_FOR_ACCESS_DENIED); <br>          break; <br>        } <br>        default : <br>        { PERR("EnumServicesStatus"); <br>        } <br>      } <br>      return; <br>    } <br> <br>    for (dwI=0; dwI&lt;dwServicesReturned; dwI++) <br>    { if(0 == _stricmp(essServiceStatus[dwI].lpServiceName,serviceName)) <br>      { bFound = TRUE; <br>        break; <br>      } <br>    } <br> <br>    if (bFound) <br>    { printf("\nThe %s service cannot be removed until it has been stopped.",serviceName); <br>      printf("\nTo stop the %s service, use the Stop button in the Control",serviceName); <br>      printf("\n  Panel Services applet\n"); <br>      return; <br>    } <br>  } <br> <br>  schService = OpenService(schSCManager, <br>                           serviceName, <br>                           SERVICE_ALL_ACCESS); <br>  if (NULL == schService) <br>  { switch (GetLastError()) <br>    { <br>      case ERROR_ACCESS_DENIED : <br>      { printf("\n%s",MSG_FOR_ACCESS_DENIED); <br>        break; <br>      } <br>      case ERROR_SERVICE_DOES_NOT_EXIST : <br>      { printf("\nThe %s service is not installed, so cannot be removed\n",serviceName); <br>        break; <br>      } <br>      default : <br>      { PERR("OpenService"); <br>      } <br>    } <br>    return; <br>  } <br> <br>  if (DeleteService(schService)) <br>  { printf("\nDeleteService SUCCESS\n"); <br>  } <br>  else <br>  { switch (GetLastError()) <br>    { <br>      case ERROR_ACCESS_DENIED : <br>      { printf("\n%s",MSG_FOR_ACCESS_DENIED); <br>        break; <br>      } <br>      default : <br>      { PERR("DeleteService"); <br>      } <br>    } <br>  } <br>} <br> <br>int main(int argc, char *argv[]) <br>{ <br>  #define           SZ_NAME_BUF  270  // 256 is max, add a little <br>  UCHAR   ucNameBuf[SZ_NAME_BUF] = "FloppyLock"; <br>  LPTSTR  lpszServName = (LPTSTR)&amp;ucNameBuf; <br> <br>  UCHAR   ucExeNBuf[SZ_NAME_BUF] = ""; <br>  LPTSTR  lpszExeName  = (LPTSTR)&amp;ucExeNBuf; <br> <br>  BOOL    bRemovingService = FALSE; <br>  char *p; <br> <br>  // check if Win32s, if so, display notice and terminate <br>      if( GetVersion() &amp; 0x80000000 ) <br>      { <br>        MessageBox( NULL, <br>           "This application cannot run on Windows 3.1 or Windows 95.\n" <br>           "This application will now terminate.", <br>           "SD_FLPPY", <br>           MB_OK | MB_ICONSTOP | MB_SETFOREGROUND ); <br>        return( 1 ); <br>      } <br> <br>  if ( (argc != 2) &amp;&amp; (argc != 3) ) <br>  { DisplayHelp(); <br>    exit(1); <br>  } <br> <br>  p=argv[1]; <br>  if (    ('/' == *p) <br>       || ('-' == *p) ) <br>  { DisplayHelp(); <br>    exit(1); <br>  } <br> <br>  if (FORCE_SERVICE_NAME_TO_FLOPPYLOCK) <br>  { if (argc != 2) <br>    { DisplayHelp(); <br>      exit(1); <br>    } <br>    else <br>    { strcpy(lpszExeName ,argv[1]); <br> <br>      bRemovingService = (!stricmp(argv[1], "remove")); <br>    } <br>  } <br>  else <br>  { if (argc != 3) <br>    { DisplayHelp(); <br>      exit(1); <br>    } <br>    else <br>    { if (strlen(argv[1]) &gt; 256) <br>      { printf("\nThe service name cannot be longer than 256 characters\n"); <br>        exit(1); <br>      } <br>      strcpy(lpszServName,argv[1]); <br>      strcpy(lpszExeName ,argv[2]); <br> <br>      bRemovingService = (!stricmp(argv[2], "remove")); <br>    } <br>  } <br> <br>  schSCManager = OpenSCManager( <br>                      NULL,                   // machine (NULL == local) <br>                      NULL,                   // database (NULL == default) <br>                      SC_MANAGER_ALL_ACCESS); // access required <br>  if (NULL == schSCManager) <br>  { switch (GetLastError()) <br>    { <br>      case ERROR_ACCESS_DENIED : <br>      { printf("\n%s",MSG_FOR_ACCESS_DENIED); <br>        break; <br>      } <br>      default : <br>      { PERR("OpenSCManager"); <br>      } <br>    } <br>    return (0); <br>  } <br> <br>  if (bRemovingService) <br>  { RemoveService(lpszServName); <br>  } <br>  else <br>  { InstallService(lpszServName,lpszExeName); <br>  } <br> <br>  CloseServiceHandle(schSCManager); <br>} <br>  <br>VOID DisplayHelp(VOID) <br>{ <br>  if (FORCE_SERVICE_NAME_TO_FLOPPYLOCK) <br>  { printf("\nInstalls or removes the FloppyLock service.  When the FloppyLock"); <br>    printf("\nservice is started, only members of the Administrators group can use"); <br>    printf("\nthe floppy drives on the computer.\n"); <br>    printf("\nTo install the FloppyLock service, type INSTSRV &lt;path&gt;\n"); <br>    printf("\n    path    Absolute path to the FloppyLock service, floplock.exe.  You must"); <br>    printf("\n            use a fully qualified path and the drive letter must be for a"); <br>    printf("\n            fixed, local drive.  For example, INSTSRV c:\\reskit\\floplock.exe.\n"); <br>    printf("\nTo remove the FloppyLock service, type INSTSRV remove\n"); <br>  } <br>  else <br>  { printf("\nUsage: instsrv &lt;service name&gt; &lt;exe location&gt;"); <br>    printf("\n           to install a service, or:"); <br>    printf("\n       instsrv &lt;service name&gt; remove"); <br>    printf("\n           to remove a service\n"); <br>    printf("\nIn the case of this service, a more specific example"); <br>    printf("\n       instsrv FloppyLocker c:\\q_a\\samples\\sd_flppy\\floplock.exe"); <br>    printf("\n           (note fully-qualified path name to .exe)"); <br>    printf("\n       instsrv FloppyLocker remove\n"); <br>  } <br>  return; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
