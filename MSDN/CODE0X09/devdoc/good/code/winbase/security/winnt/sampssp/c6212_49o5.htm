<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SSPI.H</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6215"></a>SSPI.H</h2>
<pre><code>//+--------------------------------------------------------------------------- <br>// <br>//  Microsoft Windows <br>//  Copyright (C) Microsoft Corporation, 1992-1996. <br>// <br>//  File:       sspi.h <br>// <br>//  Contents:   Security Support Provider Interface <br>//              Prototypes and structure definitions <br>// <br>//  Functions:  Security Support Provider API <br>// <br>// <br>//---------------------------------------------------------------------------- <br> <br>#ifndef __SSPI_H__ <br>#define __SSPI_H__ <br> <br>// <br>// Determine environment: <br>// <br> <br>#ifdef SECURITY_WIN32 <br>#define ISSP_LEVEL  32 <br>#define ISSP_MODE   1 <br>#endif // SECURITY_WIN32 <br> <br>#ifdef SECURITY_WIN16 <br>#define ISSP_LEVEL  16 <br>#define ISSP_MODE   1 <br>#endif // SECURITY_WIN16 <br> <br>#ifdef SECURITY_KERNEL <br>#define ISSP_LEVEL  32 <br> <br>// <br>// SECURITY_KERNEL trumps SECURITY_WIN32.  Undefine ISSP_MODE so that <br>// we don't get redefine errors. <br>// <br>#ifdef ISSP_MODE <br>#undef ISSP_MODE <br>#endif <br>#define ISSP_MODE   0 <br>#endif // SECURITY_KERNEL <br> <br>#ifdef SECURITY_OS212 <br>#define ISSP_LEVEL  16 <br>#define ISSP_MODE   1 <br>#endif // SECURITY_OS212 <br> <br>#ifdef SECURITY_DOS <br>#define ISSP_LEVEL  16 <br>#define ISSP_MODE   1 <br>#endif // SECURITY_DOS <br> <br>#ifdef SECURITY_MAC <br>#define ISSP_LEVEL  32 <br>#define ISSP_MODE   1 <br>#endif // SECURITY_MAC <br> <br> <br>#ifndef ISSP_LEVEL <br>#error  You must define one of SECURITY_WIN32, SECURITY_WIN16, SECURITY_KERNEL <br>#error  SECURITY_DOS, SECURITY_MAC or SECURITY_OS212 <br>#endif // !ISSP_LEVEL <br> <br> <br>// <br>// Now, define platform specific mappings: <br>// <br> <br>#if ISSP_LEVEL == 16 <br> <br>typedef short SECURITY_STATUS; <br>typedef short HRESULT; <br>typedef unsigned short SEC_WCHAR; <br>typedef char SEC_CHAR; <br>#define SEC_TEXT(_x_) _x_ <br> <br>#ifdef SECURITY_WIN16 <br> <br>#define SEC_FAR __far <br>#define SEC_ENTRY __pascal __far __export <br> <br>#else // SECURITY_WIN16 <br> <br>#define SEC_FAR __far <br>#define SEC_ENTRY __pascal __far __loadds <br>#pragma warning(disable:4147) <br> <br>#endif // SECURITY_WIN16 <br> <br>#elif defined(SECURITY_MAC)  // ISSP_LEVEL == 16 <br> <br>#define SEC_ENTRY <br>#define SEC_TEXT(_X_) _X_ <br>#define SEC_FAR <br> <br>typedef unsigned short SEC_WCHAR; <br>typedef char SEC_CHAR; <br>typedef long    HRESULT; <br>typedef HRESULT SECURITY_STATUS; <br> <br>// No Unicode on the Mac <br> <br>typedef SEC_CHAR SEC_FAR * SECURITY_PSTR; <br>typedef SEC_CHAR SEC_FAR * SECURITY_PCSTR; <br> <br>#else // ISSP_LEVEL == 16 <br> <br>// <br>// For NT-2 and up, wtypes will define HRESULT to be long. <br>// <br> <br>typedef WCHAR SEC_WCHAR; <br>typedef CHAR SEC_CHAR; <br> <br>#if !defined(__wtypes_h__) || defined(SECURITY_KERNEL) <br>typedef long    HRESULT; <br>#endif // wtypes.h || security_kernel <br> <br>typedef HRESULT SECURITY_STATUS; <br> <br>#define SEC_TEXT TEXT <br>#define SEC_FAR <br>#define SEC_ENTRY __stdcall <br> <br>// <br>// Decide what a string - 32 bits only since for 16 bits it is clear. <br>// <br> <br> <br>#ifdef UNICODE <br>typedef SEC_WCHAR SEC_FAR * SECURITY_PSTR; <br>typedef CONST SEC_WCHAR SEC_FAR * SECURITY_PCSTR; <br>#else // UNICODE <br>typedef SEC_CHAR SEC_FAR * SECURITY_PSTR; <br>typedef CONST SEC_CHAR SEC_FAR * SECURITY_PCSTR; <br>#endif // UNICODE <br> <br> <br>#endif // ISSP_LEVEL == 16 <br> <br>// <br>// Equivalent string for rpcrt: <br>// <br> <br>#define __SEC_FAR SEC_FAR <br> <br> <br>// <br>// Okay, security specific types: <br>// <br> <br> <br>typedef struct _SecHandle <br>{ <br>    unsigned long dwLower; <br>    unsigned long dwUpper; <br>} SecHandle, SEC_FAR * PSecHandle; <br> <br>typedef SecHandle CredHandle; <br>typedef PSecHandle PCredHandle; <br> <br>typedef SecHandle CtxtHandle; <br>typedef PSecHandle PCtxtHandle; <br> <br>#if ISSP_LEVEL == 32 <br> <br> <br>#  ifdef WIN32_CHICAGO <br> <br>typedef unsigned __int64 QWORD; <br>typedef QWORD SECURITY_INTEGER, *PSECURITY_INTEGER; <br> <br>#  elif defined(_NTDEF_) || defined(_WINNT_) <br> <br>typedef LARGE_INTEGER _SECURITY_INTEGER, SECURITY_INTEGER, *PSECURITY_INTEGER; <br> <br>#  else // _NTDEF_ || _WINNT_ <br> <br>// BUGBUG:  Alignment for axp <br> <br>typedef struct _SECURITY_INTEGER <br>{ <br>    unsigned long LowPart; <br>    long HighPart; <br>} SECURITY_INTEGER, *PSECURITY_INTEGER; <br> <br>#  endif // _NTDEF_ || _WINNT_ <br> <br>#  ifndef SECURITY_MAC <br>typedef SECURITY_INTEGER TimeStamp; <br>typedef SECURITY_INTEGER SEC_FAR * PTimeStamp; <br>#  else // SECURITY_MAC <br>typedef unsigned long TimeStamp; <br>typedef unsigned long * PTimeStamp; <br>#  endif // SECUIRT_MAC <br> <br>#else // ISSP_LEVEL == 32 <br> <br>typedef unsigned long TimeStamp; <br>typedef unsigned long SEC_FAR * PTimeStamp; <br> <br>#endif // ISSP_LEVEL == 32 <br> <br> <br>// <br>// If we are in 32 bit mode, define the SECURITY_STRING structure, <br>// as a clone of the base UNICODE_STRING structure.  This is used <br>// internally in security components, an as the string interface <br>// for kernel components (e.g. FSPs) <br>// <br> <br>#if ISSP_LEVEL == 32 <br>#  ifndef _NTDEF_ <br>typedef struct _SECURITY_STRING { <br>    unsigned short      Length; <br>    unsigned short      MaximumLength; <br>#    ifdef MIDL_PASS <br>    [size_is(MaximumLength / 2), length_is(Length / 2)] <br>#    endif // MIDL_PASS <br>    unsigned short *    Buffer; <br>} SECURITY_STRING, * PSECURITY_STRING; <br>#  else // _NTDEF_ <br>typedef UNICODE_STRING SECURITY_STRING, *PSECURITY_STRING; <br>#  endif // _NTDEF_ <br>#endif // ISSP_LEVEL == 32 <br> <br> <br>// <br>// SecPkgInfo structure <br>// <br>//  Provides general information about a security provider <br>// <br> <br>typedef struct _SecPkgInfoW <br>{ <br>    unsigned long fCapabilities;        // Capability bitmask <br>    unsigned short wVersion;            // Version of driver <br>    unsigned short wRPCID;              // ID for RPC Runtime <br>    unsigned long cbMaxToken;           // Size of authentication token (max) <br>#ifdef MIDL_PASS <br>    [string] <br>#endif <br>    SEC_WCHAR SEC_FAR * Name;           // Text name <br> <br>#ifdef MIDL_PASS <br>    [string] <br>#endif <br>    SEC_WCHAR SEC_FAR * Comment;        // Comment <br>} SecPkgInfoW, SEC_FAR * PSecPkgInfoW; <br> <br> <br>typedef struct _SecPkgInfoA <br>{ <br>    unsigned long fCapabilities;        // Capability bitmask <br>    unsigned short wVersion;            // Version of driver <br>    unsigned short wRPCID;              // ID for RPC Runtime <br>    unsigned long cbMaxToken;           // Size of authentication token (max) <br>#ifdef MIDL_PASS <br>    [string] <br>#endif <br>    SEC_CHAR SEC_FAR * Name;            // Text name <br> <br>#ifdef MIDL_PASS <br>    [string] <br>#endif <br>    SEC_CHAR SEC_FAR * Comment;         // Comment <br>} SecPkgInfoA, SEC_FAR * PSecPkgInfoA; <br> <br>#ifdef UNICODE <br>#  define SecPkgInfo SecPkgInfoW <br>#  define PSecPkgInfo PSecPkgInfoW <br>#else <br>#  define SecPkgInfo SecPkgInfoA <br>#  define PSecPkgInfo PSecPkgInfoA <br>#endif // !UNICODE <br> <br>// <br>//  Security Package Capabilities <br>// <br>#define SECPKG_FLAG_INTEGRITY       0x00000001  // Supports integrity on messages <br>#define SECPKG_FLAG_PRIVACY         0x00000002  // Supports privacy (confidentiality) <br>#define SECPKG_FLAG_TOKEN_ONLY      0x00000004  // Only security token needed <br>#define SECPKG_FLAG_DATAGRAM        0x00000008  // Datagram RPC support <br>#define SECPKG_FLAG_CONNECTION      0x00000010  // Connection oriented RPC support <br>#define SECPKG_FLAG_MULTI_REQUIRED  0x00000020  // Full 3-leg required for re-auth. <br>#define SECPKG_FLAG_CLIENT_ONLY     0x00000040  // Server side functionality not available <br>#define SECPKG_FLAG_EXTENDED_ERROR  0x00000080  // Supports extended error msgs <br>#define SECPKG_FLAG_IMPERSONATION   0x00000100  // Supports impersonation <br>#define SECPKG_FLAG_ACCEPT_WIN32_NAME   0x00000200  // Accepts Win32 names <br>#define SECPKG_FLAG_STREAM          0x00000400  // Supports stream semantics <br> <br> <br>#define SECPKG_ID_NONE      0xFFFF <br> <br> <br>// <br>// SecBuffer <br>// <br>//  Generic memory descriptors for buffers passed in to the security <br>//  API <br>// <br> <br>typedef struct _SecBuffer { <br>    unsigned long cbBuffer;             // Size of the buffer, in bytes <br>    unsigned long BufferType;           // Type of the buffer (below) <br>    void SEC_FAR * pvBuffer;            // Pointer to the buffer <br>} SecBuffer, SEC_FAR * PSecBuffer; <br> <br>typedef struct _SecBufferDesc { <br>    unsigned long ulVersion;            // Version number <br>    unsigned long cBuffers;             // Number of buffers <br>#ifdef MIDL_PASS <br>    [size_is(cBuffers)] <br>#endif <br>    PSecBuffer pBuffers;                // Pointer to array of buffers <br>} SecBufferDesc, SEC_FAR * PSecBufferDesc; <br> <br>#define SECBUFFER_VERSION           0 <br> <br>#define SECBUFFER_EMPTY             0   // Undefined, replaced by provider <br>#define SECBUFFER_DATA              1   // Packet data <br>#define SECBUFFER_TOKEN             2   // Security token <br>#define SECBUFFER_PKG_PARAMS        3   // Package specific parameters <br>#define SECBUFFER_MISSING           4   // Missing Data indicator <br>#define SECBUFFER_EXTRA             5   // Extra data <br>#define SECBUFFER_STREAM_TRAILER    6   // Security Trailer <br>#define SECBUFFER_STREAM_HEADER     7   // Security Header <br> <br>#define SECBUFFER_ATTRMASK          0xF0000000 <br>#define SECBUFFER_READONLY          0x80000000  // Buffer is read-only <br> <br>// <br>//  Data Representation Constant: <br>// <br>#define SECURITY_NATIVE_DREP        0x00000010 <br> <br>// <br>//  Credential Use Flags <br>// <br>#define SECPKG_CRED_INBOUND         0x00000001 <br>#define SECPKG_CRED_OUTBOUND        0x00000002 <br>#define SECPKG_CRED_BOTH            0x00000003 <br> <br>// <br>//  InitializeSecurityContext Requirement and return flags: <br>// <br> <br>#define ISC_REQ_DELEGATE                0x00000001 <br>#define ISC_REQ_MUTUAL_AUTH             0x00000002 <br>#define ISC_REQ_REPLAY_DETECT           0x00000004 <br>#define ISC_REQ_SEQUENCE_DETECT         0x00000008 <br>#define ISC_REQ_CONFIDENTIALITY         0x00000010 <br>#define ISC_REQ_USE_SESSION_KEY         0x00000020 <br>#define ISC_REQ_PROMPT_FOR_CREDS        0x00000040 <br>#define ISC_REQ_USE_SUPPLIED_CREDS      0x00000080 <br>#define ISC_REQ_ALLOCATE_MEMORY         0x00000100 <br>#define ISC_REQ_USE_DCE_STYLE           0x00000200 <br>#define ISC_REQ_DATAGRAM                0x00000400 <br>#define ISC_REQ_CONNECTION              0x00000800 <br>#define ISC_REQ_CALL_LEVEL              0x00001000 <br>#define ISC_REQ_EXTENDED_ERROR          0x00004000 <br>#define ISC_REQ_STREAM                  0x00008000 <br>#define ISC_REQ_INTEGRITY               0x00010000 <br>#define ISC_REQ_IDENTIFY                0x00020000 <br> <br>#define ISC_RET_DELEGATE                0x00000001 <br>#define ISC_RET_MUTUAL_AUTH             0x00000002 <br>#define ISC_RET_REPLAY_DETECT           0x00000004 <br>#define ISC_RET_SEQUENCE_DETECT         0x00000008 <br>#define ISC_RET_CONFIDENTIALITY         0x00000010 <br>#define ISC_RET_USE_SESSION_KEY         0x00000020 <br>#define ISC_RET_USED_COLLECTED_CREDS    0x00000040 <br>#define ISC_RET_USED_SUPPLIED_CREDS     0x00000080 <br>#define ISC_RET_ALLOCATED_MEMORY        0x00000100 <br>#define ISC_RET_USED_DCE_STYLE          0x00000200 <br>#define ISC_RET_DATAGRAM                0x00000400 <br>#define ISC_RET_CONNECTION              0x00000800 <br>#define ISC_RET_INTERMEDIATE_RETURN     0x00001000 <br>#define ISC_RET_CALL_LEVEL              0x00002000 <br>#define ISC_RET_EXTENDED_ERROR          0x00004000 <br>#define ISC_RET_STREAM                  0x00008000 <br>#define ISC_RET_INTEGRITY               0x00010000 <br>#define ISC_RET_IDENTIFY                0x00020000 <br> <br>#define ASC_REQ_DELEGATE                0x00000001 <br>#define ASC_REQ_MUTUAL_AUTH             0x00000002 <br>#define ASC_REQ_REPLAY_DETECT           0x00000004 <br>#define ASC_REQ_SEQUENCE_DETECT         0x00000008 <br>#define ASC_REQ_CONFIDENTIALITY         0x00000010 <br>#define ASC_REQ_USE_SESSION_KEY         0x00000020 <br>#define ASC_REQ_ALLOCATE_MEMORY         0x00000100 <br>#define ASC_REQ_USE_DCE_STYLE           0x00000200 <br>#define ASC_REQ_DATAGRAM                0x00000400 <br>#define ASC_REQ_CONNECTION              0x00000800 <br>#define ASC_REQ_CALL_LEVEL              0x00001000 <br>#define ASC_REQ_EXTENDED_ERROR          0x00008000 <br>#define ASC_REQ_STREAM                  0x00010000 <br>#define ASC_REQ_INTEGRITY               0x00020000 <br>#define ASC_REQ_LICENSING               0x00040000 <br> <br> <br>#define ASC_RET_DELEGATE                0x00000001 <br>#define ASC_RET_MUTUAL_AUTH             0x00000002 <br>#define ASC_RET_REPLAY_DETECT           0x00000004 <br>#define ASC_RET_SEQUENCE_DETECT         0x00000008 <br>#define ASC_RET_CONFIDENTIALITY         0x00000010 <br>#define ASC_RET_USE_SESSION_KEY         0x00000020 <br>#define ASC_RET_ALLOCATED_MEMORY        0x00000100 <br>#define ASC_RET_USED_DCE_STYLE          0x00000200 <br>#define ASC_RET_DATAGRAM                0x00000400 <br>#define ASC_RET_CONNECTION              0x00000800 <br>#define ASC_RET_CALL_LEVEL              0x00002000 // skipped 1000 to be like ISC_ <br>#define ASC_RET_THIRD_LEG_FAILED        0x00004000 <br>#define ASC_RET_EXTENDED_ERROR          0x00008000 <br>#define ASC_RET_STREAM                  0x00010000 <br>#define ASC_RET_INTEGRITY               0x00020000 <br>#define ASC_RET_LICENSING               0x00040000 <br> <br>// <br>//  Security Credentials Attributes: <br>// <br> <br>#define SECPKG_CRED_ATTR_NAMES 1 <br> <br>typedef struct _SecPkgCredentials_NamesW <br>{ <br>    SEC_WCHAR SEC_FAR * sUserName; <br>} SecPkgCredentials_NamesW, SEC_FAR * PSecPkgCredentials_NamesW; <br> <br>typedef struct _SecPkgCredentials_NamesA <br>{ <br>    SEC_CHAR SEC_FAR * sUserName; <br>} SecPkgCredentials_NamesA, SEC_FAR * PSecPkgCredentials_NamesA; <br> <br>#ifdef UNICODE <br>#  define SecPkgCredentials_Names SecPkgCredentials_NamesW <br>#  define PSecPkgCredentials_Names PSecPkgCredentials_NamesW <br>#else <br>#  define SecPkgCredentials_Names SecPkgCredentials_NamesA <br>#  define PSecPkgCredentials_Names PSecPkgCredentials_NamesA <br>#endif // !UNICODE <br> <br>// <br>//  Security Context Attributes: <br>// <br> <br>#define SECPKG_ATTR_SIZES           0 <br>#define SECPKG_ATTR_NAMES           1 <br>#define SECPKG_ATTR_LIFESPAN        2 <br>#define SECPKG_ATTR_DCE_INFO        3 <br>#define SECPKG_ATTR_STREAM_SIZES    4 <br>#define SECPKG_ATTR_KEY_INFO        5 <br>#define SECPKG_ATTR_AUTHORITY       6 <br>#define SECPKG_ATTR_PROTO_INFO      7 <br> <br>typedef struct _SecPkgContext_Sizes <br>{ <br>    unsigned long cbMaxToken; <br>    unsigned long cbMaxSignature; <br>    unsigned long cbBlockSize; <br>    unsigned long cbSecurityTrailer; <br>} SecPkgContext_Sizes, SEC_FAR * PSecPkgContext_Sizes; <br> <br>typedef struct _SecPkgContext_StreamSizes <br>{ <br>    unsigned long   cbHeader; <br>    unsigned long   cbTrailer; <br>    unsigned long   cbMaximumMessage; <br>    unsigned long   cBuffers; <br>    unsigned long   cbBlockSize; <br>} SecPkgContext_StreamSizes, * PSecPkgContext_StreamSizes; <br> <br>typedef struct _SecPkgContext_NamesW <br>{ <br>    SEC_WCHAR SEC_FAR * sUserName; <br>} SecPkgContext_NamesW, SEC_FAR * PSecPkgContext_NamesW; <br> <br>typedef struct _SecPkgContext_NamesA <br>{ <br>    SEC_CHAR SEC_FAR * sUserName; <br>} SecPkgContext_NamesA, SEC_FAR * PSecPkgContext_NamesA; <br> <br>#ifdef UNICODE <br>#  define SecPkgContext_Names SecPkgContext_NamesW <br>#  define PSecPkgContext_Names PSecPkgContext_NamesW <br>#else <br>#  define SecPkgContext_Names SecPkgContext_NamesA <br>#  define PSecPkgContext_Names PSecPkgContext_NamesA <br>#endif // !UNICODE <br> <br>typedef struct _SecPkgContext_Lifespan <br>{ <br>    TimeStamp tsStart; <br>    TimeStamp tsExpiry; <br>} SecPkgContext_Lifespan, SEC_FAR * PSecPkgContext_Lifespan; <br> <br>typedef struct _SecPkgContext_DceInfo <br>{ <br>    unsigned long AuthzSvc; <br>    void SEC_FAR * pPac; <br>} SecPkgContext_DceInfo, SEC_FAR * PSecPkgContext_DceInfo; <br> <br>typedef struct _SecPkgContext_KeyInfoA <br>{ <br>    SEC_CHAR SEC_FAR *  sSignatureAlgorithmName; <br>    SEC_CHAR SEC_FAR *  sEncryptAlgorithmName; <br>    unsigned long       KeySize; <br>    unsigned long       SignatureAlgorithm; <br>    unsigned long       EncryptAlgorithm; <br>} SecPkgContext_KeyInfoA, SEC_FAR * PSecPkgContext_KeyInfoA; <br> <br>typedef struct _SecPkgContext_KeyInfoW <br>{ <br>    SEC_WCHAR SEC_FAR * sSignatureAlgorithmName; <br>    SEC_WCHAR SEC_FAR * sEncryptAlgorithmName; <br>    unsigned long       KeySize; <br>    unsigned long       SignatureAlgorithm; <br>    unsigned long       EncryptAlgorithm; <br>} SecPkgContext_KeyInfoW, SEC_FAR * PSecPkgContext_KeyInfoW; <br> <br>#ifdef UNICODE <br>#define SecPkgContext_KeyInfo   SecPkgContext_KeyInfoW <br>#define PSecPkgContext_KeyInfo  PSecPkgContext_KeyInfoW <br>#else <br>#define SecPkgContext_KeyInfo   SecPkgContext_KeyInfoA <br>#define PSecPkgContext_KeyInfo  PSecPkgContext_KeyInfoA <br>#endif <br> <br>typedef struct _SecPkgContext_AuthorityA <br>{ <br>    SEC_CHAR SEC_FAR *  sAuthorityName; <br>} SecPkgContext_AuthorityA, * PSecPkgContext_AuthorityA; <br> <br>typedef struct _SecPkgContext_AuthorityW <br>{ <br>    SEC_WCHAR SEC_FAR * sAuthorityName; <br>} SecPkgContext_AuthorityW, * PSecPkgContext_AuthorityW; <br> <br>#ifdef UNICODE <br>#define SecPkgContext_Authority SecPkgContext_AuthorityW <br>#define PSecPkgContext_Authority    PSecPkgContext_AuthorityW <br>#else <br>#define SecPkgContext_Authority SecPkgContext_AuthorityA <br>#define PSecPkgContext_Authority    PSecPkgContext_AuthorityA <br>#endif <br> <br>typedef struct _SecPkgContext_ProtoInfoA <br>{ <br>    SEC_CHAR SEC_FAR *  sProtocolName; <br>    unsigned long       majorVersion; <br>    unsigned long       minorVersion; <br>} SecPkgContext_ProtoInfoA, SEC_FAR * PSecPkgContext_ProtoInfoA; <br> <br>typedef struct _SecPkgContext_ProtoInfoW <br>{ <br>    SEC_WCHAR SEC_FAR * sProtocolName; <br>    unsigned long       majorVersion; <br>    unsigned long       minorVersion; <br>} SecPkgContext_ProtoInfoW, SEC_FAR * PSecPkgContext_ProtoInfoW; <br> <br>#ifdef UNICODE <br>#define SecPkgContext_ProtoInfo   SecPkgContext_ProtoInfoW <br>#define PSecPkgContext_ProtoInfo  PSecPkgContext_ProtoInfoW <br>#else <br>#define SecPkgContext_ProtoInfo   SecPkgContext_ProtoInfoA <br>#define PSecPkgContext_ProtoInfo  PSecPkgContext_ProtoInfoA <br>#endif <br> <br>typedef void <br>(SEC_ENTRY SEC_FAR * SEC_GET_KEY_FN) ( <br>    void SEC_FAR * Arg,                 // Argument passed in <br>    void SEC_FAR * Principal,           // Principal ID <br>    unsigned long KeyVer,               // Key Version <br>    void SEC_FAR * SEC_FAR * Key,       // Returned ptr to key <br>    SECURITY_STATUS SEC_FAR * Status    // returned status <br>    ); <br> <br>SECURITY_STATUS SEC_ENTRY <br>AcquireCredentialsHandleW( <br>#if ISSP_MODE == 0                      // For Kernel mode <br>    PSECURITY_STRING pPrincipal, <br>    PSECURITY_STRING pPackage, <br>#else <br>    SEC_WCHAR SEC_FAR * pszPrincipal,   // Name of principal <br>    SEC_WCHAR SEC_FAR * pszPackage,     // Name of package <br>#endif <br>    unsigned long fCredentialUse,       // Flags indicating use <br>    void SEC_FAR * pvLogonId,           // Pointer to logon ID <br>    void SEC_FAR * pAuthData,           // Package specific data <br>    SEC_GET_KEY_FN pGetKeyFn,           // Pointer to GetKey() func <br>    void SEC_FAR * pvGetKeyArgument,    // Value to pass to GetKey() <br>    PCredHandle phCredential,           // (out) Cred Handle <br>    PTimeStamp ptsExpiry                // (out) Lifetime (optional) <br>    ); <br> <br>typedef SECURITY_STATUS <br>(SEC_ENTRY * ACQUIRE_CREDENTIALS_HANDLE_FN_W)( <br>#if ISSP_MODE == 0 <br>    PSECURITY_STRING, <br>    PSECURITY_STRING, <br>#else <br>    SEC_WCHAR SEC_FAR *, <br>    SEC_WCHAR SEC_FAR *, <br>#endif <br>    unsigned long, <br>    void SEC_FAR *, <br>    void SEC_FAR *, <br>    SEC_GET_KEY_FN, <br>    void SEC_FAR *, <br>    PCredHandle, <br>    PTimeStamp); <br> <br> <br>SECURITY_STATUS SEC_ENTRY <br>AcquireCredentialsHandleA( <br>    SEC_CHAR SEC_FAR * pszPrincipal,    // Name of principal <br>    SEC_CHAR SEC_FAR * pszPackage,      // Name of package <br>    unsigned long fCredentialUse,       // Flags indicating use <br>    void SEC_FAR * pvLogonId,           // Pointer to logon ID <br>    void SEC_FAR * pAuthData,           // Package specific data <br>    SEC_GET_KEY_FN pGetKeyFn,           // Pointer to GetKey() func <br>    void SEC_FAR * pvGetKeyArgument,    // Value to pass to GetKey() <br>    PCredHandle phCredential,           // (out) Cred Handle <br>    PTimeStamp ptsExpiry                // (out) Lifetime (optional) <br>    ); <br> <br>typedef SECURITY_STATUS <br>(SEC_ENTRY * ACQUIRE_CREDENTIALS_HANDLE_FN_A)( <br>    SEC_CHAR SEC_FAR *, <br>    SEC_CHAR SEC_FAR *, <br>    unsigned long, <br>    void SEC_FAR *, <br>    void SEC_FAR *, <br>    SEC_GET_KEY_FN, <br>    void SEC_FAR *, <br>    PCredHandle, <br>    PTimeStamp); <br> <br>#ifdef UNICODE <br>#  define AcquireCredentialsHandle AcquireCredentialsHandleW <br>#  define ACQUIRE_CREDENTIALS_HANDLE_FN ACQUIRE_CREDENTIALS_HANDLE_FN_W <br>#else <br>#  define AcquireCredentialsHandle AcquireCredentialsHandleA <br>#  define ACQUIRE_CREDENTIALS_HANDLE_FN ACQUIRE_CREDENTIALS_HANDLE_FN_A <br>#endif // !UNICODE <br> <br> <br> <br>SECURITY_STATUS SEC_ENTRY <br>FreeCredentialsHandle( <br>    PCredHandle phCredential            // Handle to free <br>    ); <br> <br>typedef SECURITY_STATUS <br>(SEC_ENTRY * FREE_CREDENTIALS_HANDLE_FN)( <br>    PCredHandle ); <br> <br> <br> <br>//////////////////////////////////////////////////////////////////////// <br>/// <br>/// Context Management Functions <br>/// <br>//////////////////////////////////////////////////////////////////////// <br> <br>SECURITY_STATUS SEC_ENTRY <br>InitializeSecurityContextW( <br>    PCredHandle phCredential,               // Cred to base context <br>    PCtxtHandle phContext,                  // Existing context (OPT) <br>#if ISSP_MODE == 0 <br>    PSECURITY_STRING pTargetName, <br>#else <br>    SEC_WCHAR SEC_FAR * pszTargetName,      // Name of target <br>#endif <br>    unsigned long fContextReq,              // Context Requirements <br>    unsigned long Reserved1,                // Reserved, MBZ <br>    unsigned long TargetDataRep,            // Data rep of target <br>    PSecBufferDesc pInput,                  // Input Buffers <br>    unsigned long Reserved2,                // Reserved, MBZ <br>    PCtxtHandle phNewContext,               // (out) New Context handle <br>    PSecBufferDesc pOutput,                 // (inout) Output Buffers <br>    unsigned long SEC_FAR * pfContextAttr,  // (out) Context attrs <br>    PTimeStamp ptsExpiry                    // (out) Life span (OPT) <br>    ); <br> <br>typedef SECURITY_STATUS <br>(SEC_ENTRY * INITIALIZE_SECURITY_CONTEXT_FN_W)( <br>    PCredHandle, <br>    PCtxtHandle, <br>#if ISSP_MODE == 0 <br>    PSECURITY_STRING, <br>#else <br>    SEC_WCHAR SEC_FAR *, <br>#endif <br>    unsigned long, <br>    unsigned long, <br>    unsigned long, <br>    PSecBufferDesc, <br>    unsigned long, <br>    PCtxtHandle, <br>    PSecBufferDesc, <br>    unsigned long SEC_FAR *, <br>    PTimeStamp); <br> <br> <br>SECURITY_STATUS SEC_ENTRY <br>InitializeSecurityContextA( <br>    PCredHandle phCredential,               // Cred to base context <br>    PCtxtHandle phContext,                  // Existing context (OPT) <br>    SEC_CHAR SEC_FAR * pszTargetName,       // Name of target <br>    unsigned long fContextReq,              // Context Requirements <br>    unsigned long Reserved1,                // Reserved, MBZ <br>    unsigned long TargetDataRep,            // Data rep of target <br>    PSecBufferDesc pInput,                  // Input Buffers <br>    unsigned long Reserved2,                // Reserved, MBZ <br>    PCtxtHandle phNewContext,               // (out) New Context handle <br>    PSecBufferDesc pOutput,                 // (inout) Output Buffers <br>    unsigned long SEC_FAR * pfContextAttr,  // (out) Context attrs <br>    PTimeStamp ptsExpiry                    // (out) Life span (OPT) <br>    ); <br> <br>typedef SECURITY_STATUS <br>(SEC_ENTRY * INITIALIZE_SECURITY_CONTEXT_FN_A)( <br>    PCredHandle, <br>    PCtxtHandle, <br>    SEC_CHAR SEC_FAR *, <br>    unsigned long, <br>    unsigned long, <br>    unsigned long, <br>    PSecBufferDesc, <br>    unsigned long, <br>    PCtxtHandle, <br>    PSecBufferDesc, <br>    unsigned long SEC_FAR *, <br>    PTimeStamp); <br> <br>#ifdef UNICODE <br>#  define InitializeSecurityContext InitializeSecurityContextW <br>#  define INITIALIZE_SECURITY_CONTEXT_FN INITIALIZE_SECURITY_CONTEXT_FN_W <br>#else <br>#  define InitializeSecurityContext InitializeSecurityContextA <br>#  define INITIALIZE_SECURITY_CONTEXT_FN INITIALIZE_SECURITY_CONTEXT_FN_A <br>#endif // !UNICODE <br> <br> <br> <br>SECURITY_STATUS SEC_ENTRY <br>AcceptSecurityContext( <br>    PCredHandle phCredential,               // Cred to base context <br>    PCtxtHandle phContext,                  // Existing context (OPT) <br>    PSecBufferDesc pInput,                  // Input buffer <br>    unsigned long fContextReq,              // Context Requirements <br>    unsigned long TargetDataRep,            // Target Data Rep <br>    PCtxtHandle phNewContext,               // (out) New context handle <br>    PSecBufferDesc pOutput,                 // (inout) Output buffers <br>    unsigned long SEC_FAR * pfContextAttr,  // (out) Context attributes <br>    PTimeStamp ptsExpiry                    // (out) Life span (OPT) <br>    ); <br> <br>typedef SECURITY_STATUS <br>(SEC_ENTRY * ACCEPT_SECURITY_CONTEXT_FN)( <br>    PCredHandle, <br>    PCtxtHandle, <br>    PSecBufferDesc, <br>    unsigned long, <br>    unsigned long, <br>    PCtxtHandle, <br>    PSecBufferDesc, <br>    unsigned long SEC_FAR *, <br>    PTimeStamp); <br> <br> <br> <br>SECURITY_STATUS SEC_ENTRY <br>CompleteAuthToken( <br>    PCtxtHandle phContext,              // Context to complete <br>    PSecBufferDesc pToken               // Token to complete <br>    ); <br> <br>typedef SECURITY_STATUS <br>(SEC_ENTRY * COMPLETE_AUTH_TOKEN_FN)( <br>    PCtxtHandle, <br>    PSecBufferDesc); <br> <br> <br>SECURITY_STATUS SEC_ENTRY <br>ImpersonateSecurityContext( <br>    PCtxtHandle phContext               // Context to impersonate <br>    ); <br> <br>typedef SECURITY_STATUS <br>(SEC_ENTRY * IMPERSONATE_SECURITY_CONTEXT_FN)( <br>    PCtxtHandle); <br> <br> <br> <br>SECURITY_STATUS SEC_ENTRY <br>RevertSecurityContext( <br>    PCtxtHandle phContext               // Context from which to re <br>    ); <br> <br>typedef SECURITY_STATUS <br>(SEC_ENTRY * REVERT_SECURITY_CONTEXT_FN)( <br>    PCtxtHandle); <br> <br> <br>SECURITY_STATUS SEC_ENTRY <br>QuerySecurityContextToken( <br>    PCtxtHandle phContext, <br>    void SEC_FAR * Token <br>    ); <br> <br>typedef SECURITY_STATUS <br>(SEC_ENTRY * QUERY_SECURITY_CONTEXT_TOKEN_FN)( <br>    PCtxtHandle, void SEC_FAR *); <br> <br> <br> <br>SECURITY_STATUS SEC_ENTRY <br>DeleteSecurityContext( <br>    PCtxtHandle phContext               // Context to delete <br>    ); <br> <br>typedef SECURITY_STATUS <br>(SEC_ENTRY * DELETE_SECURITY_CONTEXT_FN)( <br>    PCtxtHandle); <br> <br> <br> <br>SECURITY_STATUS SEC_ENTRY <br>ApplyControlToken( <br>    PCtxtHandle phContext,              // Context to modify <br>    PSecBufferDesc pInput               // Input token to apply <br>    ); <br> <br>typedef SECURITY_STATUS <br>(SEC_ENTRY * APPLY_CONTROL_TOKEN_FN)( <br>    PCtxtHandle, PSecBufferDesc); <br> <br> <br> <br>SECURITY_STATUS SEC_ENTRY <br>QueryContextAttributesW( <br>    PCtxtHandle phContext,              // Context to query <br>    unsigned long ulAttribute,          // Attribute to query <br>    void SEC_FAR * pBuffer              // Buffer for attributes <br>    ); <br> <br>typedef SECURITY_STATUS <br>(SEC_ENTRY * QUERY_CONTEXT_ATTRIBUTES_FN_W)( <br>    PCtxtHandle, <br>    unsigned long, <br>    void SEC_FAR *); <br> <br>SECURITY_STATUS SEC_ENTRY <br>QueryContextAttributesA( <br>    PCtxtHandle phContext,              // Context to query <br>    unsigned long ulAttribute,          // Attribute to query <br>    void SEC_FAR * pBuffer              // Buffer for attributes <br>    ); <br> <br>typedef SECURITY_STATUS <br>(SEC_ENTRY * QUERY_CONTEXT_ATTRIBUTES_FN_A)( <br>    PCtxtHandle, <br>    unsigned long, <br>    void SEC_FAR *); <br> <br>#ifdef UNICODE <br>#  define QueryContextAttributes QueryContextAttributesW <br>#  define QUERY_CONTEXT_ATTRIBUTES_FN QUERY_CONTEXT_ATTRIBUTES_FN_W <br>#else <br>#  define QueryContextAttributes QueryContextAttributesA <br>#  define QUERY_CONTEXT_ATTRIBUTES_FN QUERY_CONTEXT_ATTRIBUTES_FN_A <br>#endif // !UNICODE <br> <br> <br>SECURITY_STATUS SEC_ENTRY <br>QueryCredentialsAttributesW( <br>    PCredHandle phCredential,              // Credential to query <br>    unsigned long ulAttribute,          // Attribute to query <br>    void SEC_FAR * pBuffer              // Buffer for attributes <br>    ); <br> <br>typedef SECURITY_STATUS <br>(SEC_ENTRY * QUERY_CREDENTIALS_ATTRIBUTES_FN_W)( <br>    PCredHandle, <br>    unsigned long, <br>    void SEC_FAR *); <br> <br>SECURITY_STATUS SEC_ENTRY <br>QueryCredentialsAttributesA( <br>    PCredHandle phCredential,              // Credential to query <br>    unsigned long ulAttribute,          // Attribute to query <br>    void SEC_FAR * pBuffer              // Buffer for attributes <br>    ); <br> <br>typedef SECURITY_STATUS <br>(SEC_ENTRY * QUERY_CREDENTIALS_ATTRIBUTES_FN_A)( <br>    PCredHandle, <br>    unsigned long, <br>    void SEC_FAR *); <br> <br>#ifdef UNICODE <br>#  define QueryCredentialsAttributes QueryCredentialsAttributesW <br>#  define QUERY_CREDENTIALS_ATTRIBUTES_FN QUERY_CREDENTIALS_ATTRIBUTES_FN_W <br>#else <br>#  define QueryCredentialsAttributes QueryCredentialsAttributesA <br>#  define QUERY_CREDENTIALS_ATTRIBUTES_FN QUERY_CREDENTIALS_ATTRIBUTES_FN_A <br>#endif // !UNICODE <br> <br> <br> <br>SECURITY_STATUS SEC_ENTRY <br>FreeContextBuffer( <br>    void SEC_FAR * pvContextBuffer      // buffer to free <br>    ); <br> <br>typedef SECURITY_STATUS <br>(SEC_ENTRY * FREE_CONTEXT_BUFFER_FN)( <br>    void SEC_FAR *); <br> <br> <br> <br>/////////////////////////////////////////////////////////////////// <br>//// <br>////    Message Support API <br>//// <br>////////////////////////////////////////////////////////////////// <br> <br>SECURITY_STATUS SEC_ENTRY <br>MakeSignature( <br>    PCtxtHandle phContext,              // Context to use <br>    unsigned long fQOP,                 // Quality of Protection <br>    PSecBufferDesc pMessage,            // Message to sign <br>    unsigned long MessageSeqNo          // Message Sequence Num. <br>    ); <br> <br>typedef SECURITY_STATUS <br>(SEC_ENTRY * MAKE_SIGNATURE_FN)( <br>    PCtxtHandle, <br>    unsigned long, <br>    PSecBufferDesc, <br>    unsigned long); <br> <br> <br> <br>SECURITY_STATUS SEC_ENTRY <br>VerifySignature( <br>    PCtxtHandle phContext,              // Context to use <br>    PSecBufferDesc pMessage,            // Message to verify <br>    unsigned long MessageSeqNo,         // Sequence Num. <br>    unsigned long SEC_FAR * pfQOP       // QOP used <br>    ); <br> <br>typedef SECURITY_STATUS <br>(SEC_ENTRY * VERIFY_SIGNATURE_FN)( <br>    PCtxtHandle, <br>    PSecBufferDesc, <br>    unsigned long, <br>    unsigned long SEC_FAR *); <br> <br> <br> <br> <br> <br>/////////////////////////////////////////////////////////////////////////// </code></pre>
<p>
</p>
<pre><code>//// <br>////    Misc. <br>//// <br>/////////////////////////////////////////////////////////////////////////// <br> <br> <br>SECURITY_STATUS SEC_ENTRY <br>EnumerateSecurityPackagesW( <br>    unsigned long SEC_FAR * pcPackages,     // Receives num. packages <br>    PSecPkgInfoW SEC_FAR * ppPackageInfo    // Receives array of info <br>    ); <br> <br>typedef SECURITY_STATUS <br>(SEC_ENTRY * ENUMERATE_SECURITY_PACKAGES_FN_W)( <br>    unsigned long SEC_FAR *, <br>    PSecPkgInfoW SEC_FAR *); <br> <br> <br> <br>SECURITY_STATUS SEC_ENTRY <br>EnumerateSecurityPackagesA( <br>    unsigned long SEC_FAR * pcPackages,     // Receives num. packages <br>    PSecPkgInfoA SEC_FAR * ppPackageInfo    // Receives array of info <br>    ); <br> <br>typedef SECURITY_STATUS <br>(SEC_ENTRY * ENUMERATE_SECURITY_PACKAGES_FN_A)( <br>    unsigned long SEC_FAR *, <br>    PSecPkgInfoA SEC_FAR *); <br> <br>#ifdef UNICODE <br>#  define EnumerateSecurityPackages EnumerateSecurityPackagesW <br>#  define ENUMERATE_SECURITY_PACKAGES_FN ENUMERATE_SECURITY_PACKAGES_FN_W <br>#else <br>#  define EnumerateSecurityPackages EnumerateSecurityPackagesA <br>#  define ENUMERATE_SECURITY_PACKAGES_FN ENUMERATE_SECURITY_PACKAGES_FN_A <br>#endif // !UNICODE <br> <br> <br> <br>SECURITY_STATUS SEC_ENTRY <br>QuerySecurityPackageInfoW( <br>#if ISSP_MODE == 0 <br>    PSECURITY_STRING pPackageName, <br>#else <br>    SEC_WCHAR SEC_FAR * pszPackageName,     // Name of package <br>#endif <br>    PSecPkgInfoW SEC_FAR *ppPackageInfo              // Receives package info <br>    ); <br> <br>typedef SECURITY_STATUS <br>(SEC_ENTRY * QUERY_SECURITY_PACKAGE_INFO_FN_W)( <br>#if ISSP_MODE == 0 <br>    PSECURITY_STRING, <br>#else <br>    SEC_WCHAR SEC_FAR *, <br>#endif <br>    PSecPkgInfoW SEC_FAR *); <br> <br> <br> <br>SECURITY_STATUS SEC_ENTRY <br>QuerySecurityPackageInfoA( <br>    SEC_CHAR SEC_FAR * pszPackageName,      // Name of package <br>    PSecPkgInfoA SEC_FAR *ppPackageInfo              // Receives package info <br>    ); <br> <br>typedef SECURITY_STATUS <br>(SEC_ENTRY * QUERY_SECURITY_PACKAGE_INFO_FN_A)( <br>    SEC_CHAR SEC_FAR *, <br>    PSecPkgInfoA SEC_FAR *); <br> <br>#ifdef UNICODE <br>#  define QuerySecurityPackageInfo QuerySecurityPackageInfoW <br>#  define QUERY_SECURITY_PACKAGE_INFO_FN QUERY_SECURITY_PACKAGE_INFO_FN_W <br>#else <br>#  define QuerySecurityPackageInfo QuerySecurityPackageInfoA <br>#  define QUERY_SECURITY_PACKAGE_INFO_FN QUERY_SECURITY_PACKAGE_INFO_FN_A <br>#endif // !UNICODE <br> <br> <br>#if ISSP_MODE == 0 <br> <br>// <br>// Deferred mode calls for rdr <br>// <br> <br>SECURITY_STATUS SEC_ENTRY <br>DeleteSecurityContextDefer( <br>    PCtxtHandle     phContext); <br> <br>SECURITY_STATUS SEC_ENTRY <br>FreeCredentialsHandleDefer( <br>    PCredHandle     phCreds); <br> <br>#endif <br> <br>typedef enum _SecDelegationType { <br>    SecFull, <br>    SecService, <br>    SecTree, <br>    SecDirectory, <br>    SecObject <br>} SecDelegationType, * PSecDelegationType; <br> <br>SECURITY_STATUS SEC_ENTRY <br>DelegateSecurityContext( <br>    PCtxtHandle         phContext,          // IN Active context to delegate <br>#if ISSP_MODE == 0 <br>    PSECURITY_STRING    pTarget,            // IN Target path <br>#else <br>    SEC_CHAR SEC_FAR *  pszTarget, <br>#endif <br>    SecDelegationType   DelegationType,     // IN Type of delegation <br>    PTimeStamp          pExpiry,            // IN OPTIONAL time limit <br>    PSecBuffer          pPackageParameters, // IN OPTIONAL package specific <br>    PSecBufferDesc      pOutput);           // OUT Token for applycontroltoken. <br> <br> <br>/////////////////////////////////////////////////////////////////////////// <br>//// <br>////    Proxies <br>//// <br>/////////////////////////////////////////////////////////////////////////// <br> <br> <br>// <br>// Proxies are only available on NT platforms <br>// <br> <br>#ifdef NT_INCLUDED <br> <br>typedef enum _SSPI_PROXY_CLASS_TAG { <br>        SspiProxyFull, <br>        SspiProxyService, <br>        SspiProxyTree, <br>        SspiProxyDirectory <br>} _SSPI_PROXY_CLASS; <br> <br>#ifndef SSPI_PROXY_CLASS <br>#define SSPI_PROXY_CLASS _SSPI_PROXY_CLASS <br>#endif <br> <br>#ifndef _DWORD_DEFINED <br>#define _DWORD_DEFINED <br>typedef unsigned long DWORD; <br>#endif // !_DWORD_DEFINED <br> <br> <br> <br>#include &lt;accctrl.h&gt; <br> <br>// <br>// proxy access rights <br>// <br>#define PROXY_READ              0x01        // reading of proxy data <br>#define PROXY_WRITE             0x02        // writing of proxy data <br>#define PROXY_INVOKE            0x04        // invoking an existing proxy <br> <br>#define PROXY_ALL_ACCESS        ( READ_CONTROL | WRITE_DAC | DELETE | 0x07 ) <br> <br>#define PROXY_GENERIC_READ      PROXY_READ <br>#define PROXY_GENERIC_WRITE     PROXY_WRITE <br>#define PROXY_GENERIC_EXECUTE   PROXY_INVOKE <br>#define PROXY_GENERIC_ALL       ( PROXY_READ   |  \ <br>                                  PROXY_WRITE  |  \ <br>                                  PROXY_INVOKE |  \ <br>                                  WRITE_DAC    |  \ <br>                                  READ_CONTROL |  \ <br>                                  DELETE ) <br> <br>#define GRANTOR_DEFAULT_ACCESS  ( WRITE_DAC    |  \ <br>                                  READ_CONTROL |  \ <br>                                  DELETE       |  \ <br>                                  PROXY_READ   |  \ <br>                                  PROXY_WRITE  ) <br> <br>#define GRANTEE_DEFAULT_ACCESS  ( PROXY_INVOKE ) <br> <br>#define ADMIN_DEFAULT_ACCESS    ( WRITE_DAC    |  \ <br>                                  READ_CONTROL |  \ <br>                                  DELETE       |  \ <br>                                  PROXY_READ  ) <br> <br> <br>// <br>// Types available for use with proxy APIs <br>// <br>typedef enum _SECURITY_INFORMATION_TYPE { <br>    GranteeList,                // simple list of grantees' DN <br>    ExplicitAccess,             // list of EXPLICIT_ACCESSes <br>    SecurityDescriptor          // SECURITY_DESCRIPTOR <br>} SECURITY_INFORMATION_TYPE; <br> <br>typedef struct _SECURITY_ACCESS_INFO { <br>    SECURITY_INFORMATION_TYPE    ulType; <br>    VOID SEC_FAR *               pvData; <br>} SECURITY_ACCESS_INFO, SEC_FAR * PSECURITY_ACCESS_INFO; <br> <br>typedef struct _PROXY_ACCESS_LIST { <br>    ULONG                       cAccesses; <br>    EXPLICIT_ACCESS SEC_FAR *   pAccesses; <br>} PROXY_ACCESS_LIST, SEC_FAR * PPROXY_ACCESS_LIST; <br> <br>typedef struct _PROXY_GRANTEE_LIST { <br>    ULONG                          cGrantees; <br>#if ISSP_MODE == 0 <br>    PSECURITY_STRING *             ppssGrantees; <br>#else <br>    SEC_WCHAR SEC_FAR * SEC_FAR *  ppwszGrantees; <br>#endif <br>} PROXY_GRANTEE_LIST, SEC_FAR * PPROXY_GRANTEE_LIST; <br> <br>typedef struct _PROXY_REFERENCE { <br>    GUID    gIssuingDomain; <br>    GUID    gProxyId; <br>} PROXY_REFERENCE, SEC_FAR * PPROXY_REFERENCE; <br> <br> <br>// <br>// GrantProxy API <br>// <br>SECURITY_STATUS SEC_ENTRY <br>GrantProxyW( <br>    PCredHandle           phCredential,           // (in) Handle to base proxy on <br>#if ISSP_MODE == 0 <br>    PSECURITY_STRING      pssProxyName,           // (in optional) proxy name <br>#else <br>    SEC_WCHAR SEC_FAR *   pwszProxyName, <br>#endif <br>    SSPI_PROXY_CLASS           ProxyClass,             // (in) class requested <br>#if ISSP_MODE == 0 <br>    PSECURITY_STRING      pssTarget, <br>#else <br>    SEC_WCHAR SEC_FAR *   pwszTarget,             // (in) Target of proxy <br>#endif <br>    unsigned long         ContainerMask,          // (in) Access mask <br>    unsigned long         ObjectMask,             // (in) Access mask <br>    PTimeStamp            tsExpiry,               // (in) time proxy expires <br>    PSECURITY_ACCESS_INFO pAccessInfo,            // (in) grantees and accesses <br>    PPROXY_REFERENCE      phProxy                 // (out) proxy handle <br>    ); <br> <br>typedef SECURITY_STATUS <br>(SEC_ENTRY * GRANT_PROXY_FN_W)( <br>    PCredHandle, <br>#if ISSP_MODE == 0 <br>    PSECURITY_STRING, <br>#else <br>    SEC_WCHAR SEC_FAR *, <br>#endif <br>    SSPI_PROXY_CLASS, <br>#if ISSP_MODE == 0 <br>    PSECURITY_STRING, <br>#else <br>    SEC_WCHAR SEC_FAR *, <br>#endif <br>    unsigned long, <br>    unsigned long, <br>    PTimeStamp, <br>    PSECURITY_ACCESS_INFO, <br>    PPROXY_REFERENCE ); <br> <br> <br>SECURITY_STATUS SEC_ENTRY <br>GrantProxyA( <br>    PCredHandle           phCredential,           // (in) Handle to base proxy on <br>    SEC_CHAR SEC_FAR *    pszProxyName,           // (in optional) proxy name <br>    SSPI_PROXY_CLASS           ProxyClass,             // (in) class requested <br>    SEC_CHAR SEC_FAR *    pszTarget,              // (in) Target of proxy <br>    unsigned long         ContainerMask,          // (in) Access mask <br>    unsigned long         ObjectMask,             // (in) Access mask <br>    PTimeStamp            ptsExpiry,              // (in) time proxy expires <br>    PSECURITY_ACCESS_INFO pAccessInfo,            // (in) grantees and accesses <br>    PPROXY_REFERENCE      phProxy                 // (out) proxy handle <br>    ); <br> <br>typedef SECURITY_STATUS <br>(SEC_ENTRY * GRANT_PROXY_FN_A)( <br>    PCredHandle, <br>    SEC_CHAR SEC_FAR *, <br>    SSPI_PROXY_CLASS, <br>    SEC_CHAR SEC_FAR *, <br>    unsigned long, <br>    unsigned long, <br>    PTimeStamp, <br>    PSECURITY_ACCESS_INFO, <br>    PPROXY_REFERENCE ); <br> <br> <br>#ifdef UNICODE <br>#  define GrantProxy       GrantProxyW <br>#  define GRANT_PROXY_FN   GRANT_PROXY_FN_W <br>#else <br>#  define GrantProxy       GrantProxyA <br>#  define GRANT_PROXY_FN   GRANT_PROXY_FN_A <br>#endif // !UNICODE <br> <br>// <br>// RevokeProxy API <br>// <br>SECURITY_STATUS SEC_ENTRY <br>RevokeProxyW( <br>    PCredHandle          phCredential,           // (in) credentials <br>    PPROXY_REFERENCE     phProxy,                // (in) proxy handle <br>#if ISSP_MODE == 0 <br>    PSECURITY_STRING     pssProxyName <br>#else <br>    SEC_WCHAR SEC_FAR *  pwszProxyName           // (in optional) Proxy name <br>#endif <br>    ); <br> <br>typedef SECURITY_STATUS <br>(SEC_ENTRY * REVOKE_PROXY_FN_W)( <br>    PCredHandle, <br>    PPROXY_REFERENCE, <br>#if ISSP_MODE == 0 <br>    PSECURITY_STRING <br>#else <br>    SEC_WCHAR SEC_FAR * <br>#endif <br>    ); <br> <br>SECURITY_STATUS SEC_ENTRY <br>RevokeProxyA( <br>    PCredHandle          phCredential,           // (in) credentials <br>    PPROXY_REFERENCE     phProxy,                // (in) proxy handle <br>    SEC_CHAR SEC_FAR *   pszProxyName            // (in) proxy name <br>    ); <br> <br>typedef SECURITY_STATUS <br>(SEC_ENTRY * REVOKE_PROXY_FN_A)( <br>    PCredHandle, <br>    PPROXY_REFERENCE, <br>    SEC_CHAR SEC_FAR * <br>    ); <br> <br>#ifdef UNICODE <br>#  define RevokeProxy      RevokeProxyW <br>#  define REVOKE_PROXY_FN  REVOKE_PROXY_FN_W <br>#else <br>#  define RevokeProxy      RevokeProxyA <br>#  define REVOKE_PROXY_FN  REVOKE_PROXY_FN_A <br>#endif // !UNICODE <br> <br> <br>// <br>// InvokeProxy API <br>// <br>SECURITY_STATUS SEC_ENTRY <br>InvokeProxyW( <br>    PCredHandle          phCredential,           // (in) handle to base proxy on <br>    PPROXY_REFERENCE     phProxy,                // (in) proxy handle <br>#if ISSP_MODE == 0 <br>    PSECURITY_STRING     pssProxyName, <br>#else <br>    SEC_WCHAR SEC_FAR *  pwszProxyName,          // (in optional) Proxy name <br>#endif <br>    PCtxtHandle          phContext               // (out) security context <br>    ); <br> <br>typedef SECURITY_STATUS <br>(SEC_ENTRY * INVOKE_PROXY_FN_W)( <br>    PCredHandle, <br>    PPROXY_REFERENCE, <br>#if ISSP_MODE == 0 <br>    PSECURITY_STRING, <br>#else <br>    SEC_WCHAR SEC_FAR *, <br>#endif <br>    PCtxtHandle ); <br> <br>SECURITY_STATUS SEC_ENTRY <br>InvokeProxyA( <br>    PCredHandle          phCredential,           // (in) handle to base proxy on <br>    PPROXY_REFERENCE     phProxy,                // (in) proxy handle <br>    SEC_CHAR SEC_FAR *   pszProxyName,           // (in optional) Proxy name <br>    PCtxtHandle          phContext               // (out) security context <br>    ); <br> <br>typedef SECURITY_STATUS <br>(SEC_ENTRY * INVOKE_PROXY_FN_A)( <br>    PCredHandle, <br>    PPROXY_REFERENCE, <br>    SEC_CHAR SEC_FAR *, <br>    PCtxtHandle ); <br> <br>#ifdef UNICODE <br>#  define InvokeProxy      InvokeProxyW <br>#  define INVOKE_PROXY_FN  INVOKE_PROXY_FN_W <br>#else <br>#  define InvokeProxy      InvokeProxyA <br>#  define INVOKE_PROXY_FN  INVOKE_PROXY_FN_A <br>#endif // !UNICODE <br> <br> <br>// <br>// RenewProxy API <br>// <br>SECURITY_STATUS SEC_ENTRY <br>RenewProxyW( <br>    PCredHandle          phCredential,           // (in) credentials <br>    PPROXY_REFERENCE     phProxy,                // (in) proxy handle <br>#if ISSP_MODE == 0 <br>    PSECURITY_STRING     pssProxyName, <br>#else <br>    SEC_WCHAR SEC_FAR *  pwszProxyName,          // (in) proxy name <br>#endif <br>    PTimeStamp           ptsExpiry               // (in) new absolute expiry <br>    ); <br> <br>typedef SECURITY_STATUS <br>(SEC_ENTRY * RENEW_PROXY_FN_W)( <br>    PCredHandle, <br>    PPROXY_REFERENCE, <br>#if ISSP_MODE == 0 <br>    PSECURITY_STRING, <br>#else <br>    SEC_WCHAR SEC_FAR *, <br>#endif <br>    PTimeStamp <br>    ); <br> <br>SECURITY_STATUS SEC_ENTRY <br>RenewProxyA( <br>    PCredHandle          phCredential,           // (in) credentials <br>    PPROXY_REFERENCE     phProxy,                // (in) proxy handle <br>    SEC_CHAR SEC_FAR *   pszProxyName,           // (in) proxy name <br>    PTimeStamp           ptsExpiry               // (in) new expiry time <br>    ); <br> <br>typedef SECURITY_STATUS <br>(SEC_ENTRY * RENEW_PROXY_FN_A)( <br>    PCredHandle, <br>    PPROXY_REFERENCE, <br>    SEC_CHAR SEC_FAR *, <br>    PTimeStamp <br>    ); <br> <br>#ifdef UNICODE <br>#  define RenewProxy      RenewProxyW <br>#  define RENEW_PROXY_FN  RENEW_PROXY_FN_W <br>#else <br>#  define RenewProxy      RenewProxyA <br>#  define RENEW_PROXY_FN  RENEW_PROXY_FN_A <br>#endif // !UNICODE <br> <br> <br>#endif // NT_INCLUDED <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//// <br>////  Fast access for RPC: <br>//// <br>/////////////////////////////////////////////////////////////////////////////// <br> <br>#define SECURITY_ENTRYPOINTW SEC_TEXT("InitSecurityInterfaceW") <br>#define SECURITY_ENTRYPOINTA SEC_TEXT("InitSecurityInterfaceA") <br>#define SECURITY_ENTRYPOINT16 "INITSECURITYINTERFACEA" <br> <br>#ifdef SECURITY_WIN32 <br>#  ifdef UNICODE <br>#    define SECURITY_ENTRYPOINT SECURITY_ENTRYPOINTW <br>#  else // UNICODE <br>#    define SECURITY_ENTRYPOINT SECURITY_ENTRYPOINTA <br>#  endif // UNICODE <br>#else // SECURITY_WIN32 <br>#  define SECURITY_ENTRYPOINT SECURITY_ENTRYPOINT16 <br>#endif // SECURITY_WIN32 <br> <br> <br>typedef struct _SECURITY_FUNCTION_TABLE_W { <br>    unsigned long                       dwVersion; <br>    ENUMERATE_SECURITY_PACKAGES_FN_W    EnumerateSecurityPackagesW; <br>    void SEC_FAR *                      Reserved1; <br>//    QUERY_CREDENTIALS_ATTRIBUTES_FN_W   QueryCredentialsAttributesW; <br>    ACQUIRE_CREDENTIALS_HANDLE_FN_W     AcquireCredentialsHandleW; <br>    FREE_CREDENTIALS_HANDLE_FN          FreeCredentialHandle; <br>    void SEC_FAR *                      Reserved2; <br>    INITIALIZE_SECURITY_CONTEXT_FN_W    InitializeSecurityContextW; <br>    ACCEPT_SECURITY_CONTEXT_FN          AcceptSecurityContext; <br>    COMPLETE_AUTH_TOKEN_FN              CompleteAuthToken; <br>    DELETE_SECURITY_CONTEXT_FN          DeleteSecurityContext; <br>    APPLY_CONTROL_TOKEN_FN              ApplyControlToken; <br>    QUERY_CONTEXT_ATTRIBUTES_FN_W       QueryContextAttributesW; <br>    IMPERSONATE_SECURITY_CONTEXT_FN     ImpersonateSecurityContext; <br>    REVERT_SECURITY_CONTEXT_FN          RevertSecurityContext; <br>    MAKE_SIGNATURE_FN                   MakeSignature; <br>    VERIFY_SIGNATURE_FN                 VerifySignature; <br>    FREE_CONTEXT_BUFFER_FN              FreeContextBuffer; <br>    QUERY_SECURITY_PACKAGE_INFO_FN_W    QuerySecurityPackageInfoW; <br>    void SEC_FAR *                      Reserved3; <br>    void SEC_FAR *                      Reserved4; <br>#ifdef NT_INCLUDED <br>    GRANT_PROXY_FN_W                    GrantProxyW; <br>    REVOKE_PROXY_FN_W                   RevokeProxy; <br>    INVOKE_PROXY_FN_W                   InvokeProxy; <br>    RENEW_PROXY_FN_W                    RenewProxy; <br>#else <br>    void SEC_FAR *                      GrantProxyW; <br>    void SEC_FAR *                      RevokeProxy; <br>    void SEC_FAR *                      InvokeProxy; <br>    void SEC_FAR *                      RenewProxy; <br>#endif <br>    QUERY_SECURITY_CONTEXT_TOKEN_FN     QuerySecurityContextToken; <br>} SecurityFunctionTableW, SEC_FAR * PSecurityFunctionTableW; <br> <br>typedef struct _SECURITY_FUNCTION_TABLE_A { <br>    unsigned long                       dwVersion; <br>    ENUMERATE_SECURITY_PACKAGES_FN_A    EnumerateSecurityPackagesA; <br>    void SEC_FAR *                      Reserved1; <br>//    QUERY_CREDENTIALS_ATTRIBUTES_FN_A   QueryCredentialsAttributesA; <br>    ACQUIRE_CREDENTIALS_HANDLE_FN_A     AcquireCredentialsHandleA; <br>    FREE_CREDENTIALS_HANDLE_FN          FreeCredentialHandle; <br>    void SEC_FAR *                      Reserved2; <br>    INITIALIZE_SECURITY_CONTEXT_FN_A    InitializeSecurityContextA; <br>    ACCEPT_SECURITY_CONTEXT_FN          AcceptSecurityContext; <br>    COMPLETE_AUTH_TOKEN_FN              CompleteAuthToken; <br>    DELETE_SECURITY_CONTEXT_FN          DeleteSecurityContext; <br>    APPLY_CONTROL_TOKEN_FN              ApplyControlToken; <br>    QUERY_CONTEXT_ATTRIBUTES_FN_A       QueryContextAttributesA; <br>    IMPERSONATE_SECURITY_CONTEXT_FN     ImpersonateSecurityContext; <br>    REVERT_SECURITY_CONTEXT_FN          RevertSecurityContext; <br>    MAKE_SIGNATURE_FN                   MakeSignature; <br>    VERIFY_SIGNATURE_FN                 VerifySignature; <br>    FREE_CONTEXT_BUFFER_FN              FreeContextBuffer; <br>    QUERY_SECURITY_PACKAGE_INFO_FN_A    QuerySecurityPackageInfoA; <br>    void SEC_FAR *                      Reserved3; <br>    void SEC_FAR *                      Reserved4; <br>#ifdef NT_INCLUDED <br>    GRANT_PROXY_FN_A                    GrantProxyA; <br>    REVOKE_PROXY_FN_A                   RevokeProxy; <br>    INVOKE_PROXY_FN_A                   InvokeProxy; <br>    RENEW_PROXY_FN_A                    RenewProxy; <br>#else <br>    void SEC_FAR *                      GrantProxyA; <br>    void SEC_FAR *                      RevokeProxy; <br>    void SEC_FAR *                      InvokeProxy; <br>    void SEC_FAR *                      RenewProxy; <br>#endif <br>    QUERY_SECURITY_CONTEXT_TOKEN_FN     QuerySecurityContextToken; <br>} SecurityFunctionTableA, SEC_FAR * PSecurityFunctionTableA; <br> <br>#ifdef UNICODE <br>#  define SecurityFunctionTable SecurityFunctionTableW <br>#  define PSecurityFunctionTable PSecurityFunctionTableW <br>#else <br>#  define SecurityFunctionTable SecurityFunctionTableA <br>#  define PSecurityFunctionTable PSecurityFunctionTableA <br>#endif // !UNICODE <br> <br>#define SECURITY_ <br> <br>#define SECURITY_SUPPORT_PROVIDER_INTERFACE_VERSION     1 <br> <br> <br>PSecurityFunctionTableA SEC_ENTRY <br>InitSecurityInterfaceA( <br>    void <br>    ); <br> <br>typedef PSecurityFunctionTableA <br>(SEC_ENTRY * INIT_SECURITY_INTERFACE_A)(void); <br> <br>PSecurityFunctionTableW SEC_ENTRY <br>InitSecurityInterfaceW( <br>    void <br>    ); <br> <br>typedef PSecurityFunctionTableW <br>(SEC_ENTRY * INIT_SECURITY_INTERFACE_W)(void); <br> <br>#ifdef UNICODE <br>#  define InitSecurityInterface InitSecurityInterfaceW <br>#  define INIT_SECURITY_INTERFACE INIT_SECURITY_INTERFACE_W <br>#else <br>#  define InitSecurityInterface InitSecurityInterfaceA <br>#  define INIT_SECURITY_INTERFACE INIT_SECURITY_INTERFACE_A <br>#endif // !UNICODE <br> <br>SECURITY_STATUS <br>SEC_ENTRY <br>AddSecurityPackageA( <br>    SEC_CHAR SEC_FAR *  pszPackageName, <br>    void     SEC_FAR *  Reserved <br>    ); <br> <br>SECURITY_STATUS <br>SEC_ENTRY <br>AddSecurityPackageW( <br>    SEC_WCHAR SEC_FAR * pszPackageName, <br>    void      SEC_FAR * Reserved <br>    ); <br> <br>#ifdef UNICODE <br>#define AddSecurityPackage  AddSecurityPackageW <br>#else <br>#define AddSecurityPackage  AddSecurityPackageA <br>#endif <br> <br>SECURITY_STATUS <br>SEC_ENTRY <br>DeleteSecurityPackageA( <br>    SEC_CHAR SEC_FAR *  pszPackageName ); <br> <br>SECURITY_STATUS <br>SEC_ENTRY <br>DeleteSecurityPackageW( <br>    SEC_WCHAR SEC_FAR * pszPackageName ); <br> <br>#ifdef UNICODE <br>#define DeleteSecurityPackage   DeleteSecurityPackageW <br>#else <br>#define DeleteSecurityPackage   DeleteSecurityPackageA <br>#endif <br> <br> <br>#ifdef SECURITY_DOS <br>#pragma warning(default:4147) <br>#endif <br> <br>#endif // __SSPI_H__ </code></pre>
<p>&nbsp;</p></body>
</HTML>
