<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SERVER.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6211"></a>SERVER.C</h2>
<pre><code>/*++ <br> <br>Copyright 1996 - 1997 Microsoft Corporation <br> <br>Module Name: <br> <br>    server.c <br> <br>Abstract: <br> <br>    This sample illustrates the new DuplicateTokenEx() API for Windows NT 4.0. <br>    This portion of the sample illustrates how to implement a remote cmd <br>    server which launches cmd.exe in the security context of the client that <br>    connected to the server. <br> <br>    When a client connects to the named-pipe, the server process impersonates <br>    the client and then saves a copy of the impersonation token.  This token <br>    is then duplicated via DuplicateTokenEx() to a primary level access token. <br>    The primary level token is then supplied to CreateProcessAsUser(), which <br>    launches a process in the security context of the client.  All threads in <br>    the new process inherit the security context of the client.  All processes <br>    created by the new process inherit the security context of the client.  The <br>    input and output of the new process will be redirected to the client over <br>    the named-pipes, which provides a means of interactively executing commands <br>    remotely in a secure manner. <br> <br>    In order to allow processes to run in a different security context than <br>    the server process, it is necessary to adjust the security on the <br>    windowstation and desktop objects associated with the server process. <br>    This is required to allow for proper console initialization. <br> <br>    For simplicity, this sample applies a Null Dacl to the windowstation and <br>    desktop objects, which is generally not appropriate in a production <br>    environment.  The best approach to selectively secure the windowstation and <br>    desktop objects is to extract the Logon Sid from the access token returned <br>    by DuplicateTokenEx().  The Logon Sid can be extracted with <br>    GetTokenInformation() and then added to an access allowed ace which is <br>    supplied in a Dacl which contains the existing access allowed aces in <br>    addition to the new access allowed ace. <br> <br>    Some additional considerations with this sample follow: <br> <br>    * The account which the server process runs in needs the following two <br>      privileges granted, to allow for the call to CreateProcessAsUser() to <br>      succeed: <br> <br>      SeAssignPrimaryTokenPrivilege (Replace a process level token) <br>      SeIncreateQuotaPrivilege (Increase quotas) <br> <br>    * The security on the initial server side named-pipe allows for Everyone <br>      to connect.  This may present security problems in the event that the <br>      server's file system has not be secured appropriately.  In a production <br>      environment, it may be appropriate to apply a more restrictive Dacl on <br>      the initial named-pipe. <br> <br>    * This sample only allows one client to be connected at a time. <br> <br>    * Any child processes started by the launched process will not be terminated <br>      when the initial child process exits. <br> <br> <br>Author: <br> <br>    Scott Field (sfield)    02-Apr-96 <br> <br>--*/ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;stdio.h&gt; <br> <br>BOOL <br>BuildNamedPipeAcl( <br>    PACL pAcl, <br>    PDWORD cbAclSize <br>    ); <br> <br>BOOL <br>SetupNamedPipes( <br>    PSECURITY_ATTRIBUTES saInbound, <br>    PSECURITY_ATTRIBUTES saOutbound, <br>    PHANDLE hFileIn, <br>    PHANDLE hFileOut <br>    ); <br> <br>BOOL <br>SetWinstaDesktopSecurity( <br>    void <br>    ); <br> <br>void <br>DisplayLastError( <br>    LPSTR szAPI // pointer to Ansi function name <br>    ); <br> <br>// <br>// this defines the commandline that the server will execute in the security <br>// context of the client.  The /Q switch tells cmd.exe not to echo the <br>// entered commands back to the client. <br>// <br>#define COMMANDLINE     TEXT("cmd.exe /Q") <br> <br>#define INBOUND_PIPE    TEXT("\\\\.\\pipe\\rcmd_in") <br>#define OUTBOUND_PIPE   TEXT("\\\\.\\pipe\\rcmd_out") <br> <br>#define RTN_OK 0 <br>#define RTN_ERROR 13 <br> <br>int <br>__cdecl <br>main( <br>    void <br>    ) <br>{ <br>    HANDLE hPipeInbound; <br>    HANDLE hPipeOutbound; <br> <br>    SECURITY_ATTRIBUTES saInbound; <br>    SECURITY_DESCRIPTOR sd; <br> <br>    BYTE AclBuf[ 64 ]; <br>    DWORD cbAclSize = 64; <br>    PACL pAcl = (PACL)AclBuf; <br> <br>    SECURITY_ATTRIBUTES saOutbound; <br> <br>    HANDLE hImpersonationToken; <br>    HANDLE hPrimaryToken; <br> <br>    STARTUPINFO si; <br>    PROCESS_INFORMATION pi; <br> <br>    // <br>    // suppress errors regarding startup directory, etc <br>    // <br>    SetErrorMode(SEM_FAILCRITICALERRORS); <br> <br>    // <br>    // build security attributes for named-pipes <br>    // <br>    // the inbound pipe will grant Everyone the ability to connect, <br>    // and the server process full control over the pipe.  This way, <br>    // only the server process has the ability to update security <br>    // on the resource; clients can only connect. <br>    // <br>    // the outbound pipe will be built after the server impersonates <br>    // the client, and will inherit the default security of the client <br>    // as a result.  This allows only the same user that connected to <br>    // the inbound pipe to connect to the outbound pipe <br>    // <br> <br>    if(!BuildNamedPipeAcl(pAcl, &amp;cbAclSize)) { <br>        DisplayLastError("BuildNamedPipeAcl"); <br>        return RTN_ERROR; <br>    } <br> <br>    if(!InitializeSecurityDescriptor(&amp;sd, SECURITY_DESCRIPTOR_REVISION)) { <br>        DisplayLastError("InitializeSecurityDescriptor"); <br>        return RTN_ERROR; <br>    } <br> <br>    if(!SetSecurityDescriptorDacl(&amp;sd, TRUE, pAcl, FALSE)) { <br>        DisplayLastError("SetSecurityDescriptorDacl"); <br>        return RTN_ERROR; <br>    } <br> <br>    saInbound.nLength = sizeof(SECURITY_ATTRIBUTES); <br>    saInbound.lpSecurityDescriptor = &amp;sd; <br>    saInbound.bInheritHandle = TRUE; <br> <br>    saOutbound.nLength = sizeof(SECURITY_ATTRIBUTES); <br>    saOutbound.lpSecurityDescriptor = NULL; // default Dacl of caller <br>    saOutbound.bInheritHandle = TRUE; <br> <br>    // <br>    // modify security on windowstation and desktop to allow for correct <br>    // process and console initialization by arbitrary clients <br>    // <br>    if(!SetWinstaDesktopSecurity()) { <br>        DisplayLastError("SetWinstaDesktopSecurity"); <br>        return RTN_ERROR; <br>    } <br> <br>    while(1) { <br> <br>    hPipeInbound = INVALID_HANDLE_VALUE; <br>    hPipeOutbound = INVALID_HANDLE_VALUE; <br>    hImpersonationToken = INVALID_HANDLE_VALUE; <br>    hPrimaryToken = INVALID_HANDLE_VALUE; <br>    pi.hProcess = INVALID_HANDLE_VALUE; <br>    pi.hThread = INVALID_HANDLE_VALUE; <br> <br>    if(!SetupNamedPipes( <br>        &amp;saInbound, <br>        &amp;saOutbound, <br>        &amp;hPipeInbound, <br>        &amp;hPipeOutbound <br>        )) { <br> <br>        // <br>        // just bail out on failure for now <br>        // <br>        DisplayLastError("SetupNamedPipes"); <br>        break; <br>    } <br> <br>    // <br>    // obtain the impersonation token from the current thread <br>    // <br>    if(!OpenThreadToken( <br>        GetCurrentThread(), <br>        TOKEN_DUPLICATE, <br>        TRUE, <br>        &amp;hImpersonationToken <br>        )) { <br>        DisplayLastError("OpenThreadToken"); <br>        goto cleanup; <br>    } <br> <br>    // <br>    // duplicate the impersonation token to primary <br>    // since we are impersonating the client, the token will get the <br>    // default Dacl of the client <br>    // <br>    if(!DuplicateTokenEx( <br>        hImpersonationToken, <br>        TOKEN_IMPERSONATE | TOKEN_READ | <br>        TOKEN_ASSIGN_PRIMARY | TOKEN_DUPLICATE, <br>        NULL, <br>        SecurityImpersonation, <br>        TokenPrimary, <br>        &amp;hPrimaryToken <br>        )) { <br>        DisplayLastError("DuplicateTokenEx"); <br>        goto cleanup; <br>    } <br> <br>    RevertToSelf(); <br>    CloseHandle(hImpersonationToken); <br>    hImpersonationToken = INVALID_HANDLE_VALUE; <br> <br>    // <br>    // setup STARTUPINFO structure <br>    // <br>    si.cb = sizeof(STARTUPINFO); <br>    si.lpReserved = NULL; <br>    si.lpDesktop = NULL; <br>    si.lpTitle = NULL; <br>    si.cbReserved2 = 0; <br>    si.lpReserved2 = NULL; <br>    si.dwFlags = STARTF_USESTDHANDLES; <br>    si.hStdOutput = hPipeOutbound; <br>    si.hStdError = hPipeOutbound; <br>    si.hStdInput = hPipeInbound; <br> <br>    // <br>    // create a process running as the user <br>    // <br> <br>    if(!CreateProcessAsUser( <br>        hPrimaryToken, <br>        NULL, <br>        COMMANDLINE, // commandline to execute <br>        NULL,   // process sa <br>        NULL,   // thread sa <br>        TRUE,   // inherit handles? <br>        0,      // process creation flags (inherit existing console) <br>        NULL,   // environment <br>        NULL,   // current directory <br>        &amp;si,    // startupinfo <br>        &amp;pi     // processinfo <br>        )) { <br>        DisplayLastError("CreateProcessAsUser"); <br>        goto cleanup; <br>    } <br> <br>cleanup: <br> <br>    if(hImpersonationToken != INVALID_HANDLE_VALUE) { <br>        RevertToSelf(); <br>        CloseHandle(hImpersonationToken); <br>    } <br> <br>    if(hPrimaryToken != INVALID_HANDLE_VALUE) { <br>        CloseHandle(hPrimaryToken); <br>    } <br> <br>    if(pi.hThread != INVALID_HANDLE_VALUE) { <br>        CloseHandle(pi.hThread); <br>    } <br> <br>    if(pi.hProcess != INVALID_HANDLE_VALUE) { <br>        WaitForSingleObject(pi.hProcess, INFINITE); <br>        CloseHandle(pi.hProcess); <br> <br>        // <br>        // TODO kill any child by enumerating process tokens in the system <br>        // by looking at the tokenID <br>        // <br>    } <br> <br>    if(hPipeInbound != INVALID_HANDLE_VALUE) { <br>        DisconnectNamedPipe(hPipeInbound); <br>        CloseHandle(hPipeInbound); <br>    } <br> <br>    if(hPipeOutbound != INVALID_HANDLE_VALUE) { <br>        DisconnectNamedPipe(hPipeOutbound); <br>        CloseHandle(hPipeOutbound); <br>    } <br> <br>    } // while <br> <br>    return RTN_OK; <br>} <br> <br>/*** <br> If the function succeeds, the return value is TRUE.  The parameters <br> hFileIn and hFileOut will point to the Inbound and Outbound named-pipe <br> handles.  The current thread will be impersonating the client. <br> <br> If the function fails, the return value is FALSE.  The current thread will <br> not be impersonating the client. <br>***/ <br>BOOL <br>SetupNamedPipes( <br>    PSECURITY_ATTRIBUTES saInbound, // security attributes for Inbound pipe <br>    PSECURITY_ATTRIBUTES saOutbound,// security attributes for Outbound pipe <br>    PHANDLE hFileIn,                // resultant Inbound pipe handle on success <br>    PHANDLE hFileOut                // resultant Outbound pipe handle on success <br>    ) <br>{ <br>    HANDLE hPipeInbound = INVALID_HANDLE_VALUE; <br>    HANDLE hPipeOutbound = INVALID_HANDLE_VALUE; <br> <br>    BOOL bSuccess = FALSE; // assume this function fails <br> <br>    // <br>    // create Inbound named-pipe <br>    // <br>    hPipeInbound = CreateNamedPipe( <br>        INBOUND_PIPE, <br>        PIPE_ACCESS_INBOUND, <br>        PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT, <br>        1, // number of instances <br>        4096, <br>        4096, <br>        NMPWAIT_USE_DEFAULT_WAIT, <br>        saInbound <br>        ); <br> <br>    if(hPipeInbound == INVALID_HANDLE_VALUE) { <br>        DisplayLastError("CreateNamedPipe"); <br>        return FALSE; <br>    } <br> <br>    printf("Waiting for connection... "); <br> <br>    // <br>    // wait for somebody to connect to the Inbound named pipe <br>    // <br>    ConnectNamedPipe(hPipeInbound, NULL); <br> <br>    // <br>    // impersonate the client <br>    // <br>    if(!ImpersonateNamedPipeClient(hPipeInbound)) { <br>        DisplayLastError("ImpersonateNamedPipeClient"); <br>        goto cleanup; <br>    } <br> <br>    // <br>    // create Outbound named-pipe <br>    // the security on this named-pipe will be inherited from the default Dacl <br>    // of the client that just connected, because this pipe instance is <br>    // created in that users security context.  This prevents other users <br>    // from connecting to the Outbound pipe. <br>    // <br>    hPipeOutbound = CreateNamedPipe( <br>        OUTBOUND_PIPE, <br>        PIPE_ACCESS_OUTBOUND, <br>        PIPE_TYPE_MESSAGE | PIPE_WAIT, <br>        1, // number of instances <br>        4096, <br>        4096, <br>        NMPWAIT_USE_DEFAULT_WAIT, <br>        saOutbound <br>        ); <br> <br>    if(hPipeOutbound == INVALID_HANDLE_VALUE) { <br>        DisplayLastError("CreateNamedPipe"); <br>        goto cleanup; <br>    } <br> <br>    // <br>    // wait for the client to connect to the Outbound named pipe <br>    // <br>    ConnectNamedPipe(hPipeOutbound, NULL); <br> <br>    printf("Client connected!\n"); <br> <br>    *hFileIn = hPipeInbound; <br>    *hFileOut = hPipeOutbound; <br> <br>    bSuccess = TRUE; <br> <br>cleanup: <br> <br>    if(!bSuccess) { <br>        RevertToSelf(); <br> <br>        if(hPipeInbound != INVALID_HANDLE_VALUE) <br>            CloseHandle(hPipeInbound); <br>        if(hPipeOutbound != INVALID_HANDLE_VALUE) <br>            CloseHandle(hPipeOutbound); <br>    } <br> <br>    return bSuccess; <br>} <br> <br>/** <br>This function builds a Dacl which grants the creator of the objects <br>FILE_ALL_ACCESS and Everyone FILE_GENERIC_READ and FILE_GENERIC_WRITE <br>access to the object. <br> <br>This Dacl allows for higher security than a NULL Dacl, which is common for <br>named-pipes, as this only grants the creator/owner write access to the <br>security descriptor, and grants Everyone the ability to "use" the named-pipe. <br>This scenario prevents a malevolent user from disrupting service by preventing <br>arbitrary access manipulation. <br>**/ <br>BOOL <br>BuildNamedPipeAcl( <br>    PACL pAcl, <br>    PDWORD cbAclSize <br>    ) <br>{ <br>    DWORD dwAclSize; <br> <br>    SID_IDENTIFIER_AUTHORITY siaWorld = SECURITY_WORLD_SID_AUTHORITY; <br>    SID_IDENTIFIER_AUTHORITY siaCreator = SECURITY_CREATOR_SID_AUTHORITY; <br> <br>    BYTE BufEveryoneSid[32]; <br>    BYTE BufOwnerSid[32]; <br> <br>    PSID pEveryoneSid = (PSID)BufEveryoneSid; <br>    PSID pOwnerSid = (PSID)BufOwnerSid; <br> <br>    // <br>    // compute size of acl <br>    // <br>    dwAclSize = sizeof(ACL) + <br>        2 * ( sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD) ) + <br>        GetSidLengthRequired( 1 ) + // well-known Everyone Sid <br>        GetSidLengthRequired( 1 ) ; // well-known Creator Owner Sid <br> <br>    if(*cbAclSize &lt; dwAclSize) { <br>        *cbAclSize = dwAclSize; <br>        return FALSE; <br>    } <br> <br>    *cbAclSize = dwAclSize; <br> <br>    // <br>    // intialize well known sids <br>    // <br> <br>    if(!InitializeSid(pEveryoneSid, &amp;siaWorld, 1)) return FALSE; <br>    *GetSidSubAuthority(pEveryoneSid, 0) = SECURITY_WORLD_RID; <br> <br>    if(!InitializeSid(pOwnerSid, &amp;siaCreator, 1)) return FALSE; <br>    *GetSidSubAuthority(pOwnerSid, 0) = SECURITY_CREATOR_OWNER_RID; <br> <br>    if(!InitializeAcl(pAcl, dwAclSize, ACL_REVISION)) <br>        return FALSE; <br> <br>    // <br>    // <br>    if(!AddAccessAllowedAce( <br>        pAcl, <br>        ACL_REVISION, <br>        FILE_GENERIC_READ | FILE_GENERIC_WRITE, <br>        pEveryoneSid <br>        )) <br>        return FALSE; <br> <br>    // <br>    // <br>    return AddAccessAllowedAce( <br>        pAcl, <br>        ACL_REVISION, <br>        FILE_ALL_ACCESS, <br>        pOwnerSid <br>        ); <br>} <br> <br>/** <br>This function adjusts the security on the current windowstation and desktop, <br>to allow arbitrary client to have access to the windowstation and desktop. <br>This is necessary to allow for correct process and console initialization. <br> <br>Note that in a secure environment, it would be appropriate to create <br>a specific desktop and launch the process spawned by the client on that <br>desktop, rather than opening up the current desktop to the client. <br> <br>This function simply applies a NULL Dacl to the current windowstation and <br>desktop in order to reduce the size of this sample.  Applying NULL Dacls <br>to objects is generally not a wise idea. <br> <br>TODO revist this function later to better address security on the windowstation <br>and desktop. <br>**/ <br>BOOL <br>SetWinstaDesktopSecurity( <br>    void <br>    ) <br>{ <br>    HWINSTA hWinsta; <br>    HDESK hDesk; <br> <br>    SECURITY_INFORMATION si = DACL_SECURITY_INFORMATION; <br>    SECURITY_DESCRIPTOR sd; <br> <br>    hWinsta = GetProcessWindowStation(); <br>    if(hWinsta == NULL) return FALSE; <br> <br>    hDesk = GetThreadDesktop(GetCurrentThreadId()); <br>    if(hDesk == NULL) return FALSE; <br> <br>    InitializeSecurityDescriptor(&amp;sd, SECURITY_DESCRIPTOR_REVISION); <br>    SetSecurityDescriptorDacl(&amp;sd, TRUE, (PACL)NULL, FALSE); <br> <br>    if(!SetUserObjectSecurity(hWinsta, &amp;si, &amp;sd)) return FALSE; <br> <br>    return SetUserObjectSecurity(hDesk, &amp;si, &amp;sd); <br>} <br> <br>void <br>DisplayLastError( <br>    LPSTR szAPI // pointer to Ansi function name <br>    ) <br>{ <br>    LPSTR MessageBuffer; <br>    DWORD dwBufferLength; <br> <br>    // <br>    // TODO get this fprintf out of here! <br>    // <br>    fprintf(stderr,"%s error!\n", szAPI); <br> <br>    if(dwBufferLength=FormatMessageA( <br>            FORMAT_MESSAGE_ALLOCATE_BUFFER | <br>            FORMAT_MESSAGE_FROM_SYSTEM, <br>            NULL, <br>            GetLastError(), <br>            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), <br>            (LPSTR) &amp;MessageBuffer, <br>            0, <br>            NULL <br>            )) <br>    { <br>        DWORD dwBytesWritten; // unused <br> <br>        // <br>        // Output message string on stderr <br>        // <br>        WriteFile( <br>                GetStdHandle(STD_ERROR_HANDLE), <br>                MessageBuffer, <br>                dwBufferLength, <br>                &amp;dwBytesWritten, <br>                NULL <br>                ); <br> <br>        // <br>        // free the buffer allocated by the system <br>        // <br>        LocalFree(MessageBuffer); <br>    } <br>} <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
