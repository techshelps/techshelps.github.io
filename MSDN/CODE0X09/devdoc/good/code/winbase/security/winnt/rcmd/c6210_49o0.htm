<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CLIENT.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6210"></a>CLIENT.C</h2>
<pre><code>/*++ <br> <br>Copyright 1996 - 1997 Microsoft Corporation <br> <br>Module Name: <br> <br>    client.c <br> <br>Abstract: <br> <br>    This sample illustrates a simple client side of the DuplicateTokenEx() <br>    server sample. <br> <br>    This client functions correctly on the following platforms: <br>    Windows NT 3.5 <br>    Windows NT 3.51 <br>    Windows NT 4.0 <br>    Windows 95 <br> <br>Author: <br> <br>    Scott Field (sfield)    02-Apr-96 <br> <br>--*/ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;stdio.h&gt; <br> <br>DWORD <br>WINAPI <br>ReadFunc( <br>    LPVOID lpParam <br>    ); <br> <br>DWORD <br>WINAPI <br>WriteFunc( <br>    LPVOID lpParam <br>    ); <br> <br>void <br>DisplayWinError( <br>    LPSTR szAPI,    // pointer to Ansi function name <br>    DWORD dwError   // DWORD WinError <br>    ); <br> <br>#define RTN_OK 0 <br>#define RTN_USAGE 1 <br>#define RTN_ERROR 13 <br> <br>int <br>__cdecl <br>main( <br>    int argc, <br>    char *argv[] <br>    ) <br>{ <br>    HANDLE hFileRead; <br>    HANDLE hFileWrite; <br> <br>    HANDLE hThread; <br>    DWORD dwThreadId; <br> <br>    CHAR PipeIn[255]; <br>    CHAR PipeOut[255]; <br> <br>    if(argc == 1) { <br>        printf("Usage: %s &lt;\\\\server\n", argv[0]); <br>        printf("  %s \\\\WINBASE (remote server is \\\\winbase)\n", argv[0]); <br>        printf("  %s \\\\. (local server)\n",   argv[0]); <br>        return RTN_USAGE; <br>    } <br> <br>    // <br>    // build Pipe names <br>    // <br>    wsprintf(PipeIn, "%s\\pipe\\rcmd_out", argv[1]); <br>    wsprintf(PipeOut, "%s\\pipe\\rcmd_in", argv[1]); <br> <br>    // <br>    // wait for the outbound (inbound on server-side) pipe to be available <br>    // <br>    WaitNamedPipe(PipeOut, NMPWAIT_WAIT_FOREVER); <br> <br>    hFileWrite = CreateFile( <br>        PipeOut, <br>        GENERIC_WRITE, <br>        0, // exclusive open <br>        NULL, <br>        OPEN_EXISTING, <br>        SECURITY_SQOS_PRESENT | SECURITY_IMPERSONATION, // server can impersonate <br>        NULL <br>        ); <br> <br>    if(hFileWrite == INVALID_HANDLE_VALUE) { <br>        DisplayWinError("CreateFile", GetLastError()); <br>        return RTN_ERROR; <br>    } <br> <br>    // <br>    // wait for the inbound (outbound on server-side) pipe to be available <br>    // we time-out in 5 seconds because the server should be ready for us <br>    // right-away <br>    // <br>    WaitNamedPipe(PipeIn, 5 * 1000); <br> <br>    hFileRead = CreateFile( <br>        PipeIn, <br>        GENERIC_READ, <br>        0, // exclusive open <br>        NULL, <br>        OPEN_EXISTING, <br>        0, <br>        NULL <br>        ); <br> <br>    if(hFileRead == INVALID_HANDLE_VALUE) { <br>        DisplayWinError("CreateFile", GetLastError()); <br>        return RTN_ERROR; <br>    } <br> <br>    // <br>    // start a thread to handle stdin redirection to the pipe <br>    // <br>    hThread = CreateThread( <br>        NULL, <br>        0, <br>        WriteFunc, <br>        (LPVOID)hFileWrite, // parm <br>        0, <br>        &amp;dwThreadId <br>        ); <br> <br>    if(hThread == NULL) { <br>        DisplayWinError("CreateThread", GetLastError()); <br>        return RTN_ERROR; <br>    } <br> <br>    // <br>    // handle stdout redirection <br>    // <br>    ReadFunc((LPVOID)hFileRead); <br> <br>    // <br>    // if the read returned, kill the write, cleanup, and then exit <br>    // <br>    TerminateThread(hThread, 0xFFFFFFFF); <br>    CloseHandle(hThread); <br> <br>    CloseHandle(hFileRead); <br>    CloseHandle(hFileWrite); <br> <br>    return RTN_OK; <br>} <br> <br>DWORD <br>WINAPI <br>ReadFunc( <br>    LPVOID lpParam <br>    ) <br>{ <br>    #define BUFFER_SIZE 4096 <br> <br>    HANDLE hFile = (HANDLE)lpParam; <br>    BYTE lpBuffer[BUFFER_SIZE]; <br> <br>    DWORD dwBytesRead; <br>    DWORD dwBytesWritten; <br> <br>    HANDLE hStdOut = GetStdHandle(STD_OUTPUT_HANDLE); <br> <br>    DWORD dwLastError; <br> <br>    while (1) { <br>        if(!ReadFile( <br>            hFile, <br>            lpBuffer, <br>            BUFFER_SIZE, <br>            &amp;dwBytesRead, <br>            NULL <br>            )) { <br>            dwLastError = GetLastError(); <br> <br>            if(dwLastError == ERROR_NO_DATA) continue; <br>            if(dwLastError != ERROR_MORE_DATA) break; <br>        } <br> <br>        if(!WriteFile( <br>            hStdOut, <br>            lpBuffer, <br>            dwBytesRead, <br>            &amp;dwBytesWritten, <br>            NULL <br>            )) break; <br>    } <br> <br>    return GetLastError(); <br>} <br> <br>DWORD <br>WINAPI <br>WriteFunc( <br>    LPVOID lpParam <br>    ) <br>{ <br>    HANDLE hPipe = (HANDLE)lpParam; <br> <br>    BYTE lpBuffer[ 1 ]; // change this later <br> <br>    DWORD dwBytesRead; <br>    DWORD dwBytesWritten; <br> <br>    HANDLE hStdIn = GetStdHandle(STD_INPUT_HANDLE); <br> <br>    while (1) { <br>        // <br>        // TODO rework this loop to be line-based. <br>        // this would entail doing the console buffering outselves. <br>        // <br>        if(!ReadFile( <br>            hStdIn, <br>            lpBuffer, <br>            1, <br>            &amp;dwBytesRead, <br>            NULL <br>            )) break; <br> <br>        if(!WriteFile( <br>            hPipe, <br>            lpBuffer, <br>            dwBytesRead, <br>            &amp;dwBytesWritten, <br>            NULL <br>            )) break; <br>    } <br> <br>    return GetLastError(); <br>} <br> <br>void <br>DisplayWinError( <br>    LPSTR szAPI,    // pointer to Ansi function name <br>    DWORD dwError   // DWORD WinError <br>    ) <br>{ <br>    LPSTR MessageBuffer; <br>    DWORD dwBufferLength; <br> <br>    // <br>    // TODO get this fprintf out of here! <br>    // <br>    fprintf(stderr,"%s error!\n", szAPI); <br> <br>    if(dwBufferLength=FormatMessageA( <br>            FORMAT_MESSAGE_ALLOCATE_BUFFER | <br>            FORMAT_MESSAGE_FROM_SYSTEM, <br>            NULL, <br>            dwError, <br>            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), <br>            (LPSTR) &amp;MessageBuffer, <br>            0, <br>            NULL <br>            )) <br>    { <br>        DWORD dwBytesWritten; // unused <br> <br>        // <br>        // Output message string on stderr <br>        // <br>        WriteFile( <br>                GetStdHandle(STD_ERROR_HANDLE), <br>                MessageBuffer, <br>                dwBufferLength, <br>                &amp;dwBytesWritten, <br>                NULL <br>                ); <br> <br>        // <br>        // free the buffer allocated by the system <br>        // <br>        LocalFree(MessageBuffer); <br>    } <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
