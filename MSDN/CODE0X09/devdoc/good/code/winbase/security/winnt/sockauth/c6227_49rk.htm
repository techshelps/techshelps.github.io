<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>COMM.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6230"></a>COMM.C</h2>
<pre><code>/*++ <br> <br>Copyright 1996 - 1998 Microsoft Corporation <br> <br>Module Name: <br> <br>    comm.c <br> <br>Abstract: <br> <br>    Implements a set of common operations for socket communication <br> <br>Revision History: <br> <br>--*/ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;winsock.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include "comm.h" <br> <br>BOOL InitWinsock () <br>{ <br>int nRes; <br>WSADATA wsaData; <br>WORD wVerRequested = 0x0101; // ver 1.1 <br> <br>// Init the sockets interface <br>nRes = WSAStartup (wVerRequested, &amp;wsaData); <br>if (nRes)  { <br>fprintf (stderr, "Couldn't init winsock: %d\n", nRes); <br>return(FALSE); <br>} <br> <br>return(TRUE); <br>} <br> <br>BOOL TermWinsock () <br>{ <br>if (SOCKET_ERROR == WSACleanup ()) <br>return(FALSE); <br>else <br>return(TRUE); <br>} <br> <br>BOOL SendMsg (SOCKET s, PBYTE pBuf, DWORD cbBuf) <br>/*++ <br> <br> Routine Description: <br> <br>    Sends a message over the socket by first sending a DWORD that <br>represents the size of the message followed by the message itself. <br> <br> Return Value: <br> <br>    Returns TRUE is successful; otherwise FALSE is returned. <br> <br>--*/ <br>{ <br>if (0 == cbBuf) <br>return(TRUE); <br> <br>// send the size of the message <br>// <br>if (!SendBytes (s, (PBYTE)&amp;cbBuf, sizeof (cbBuf))) <br>return(FALSE); <br> <br>// send the body of the message <br>// <br>if (!SendBytes (s, pBuf, cbBuf)) <br>return(FALSE); <br> <br>return(TRUE); <br>} <br> <br>BOOL ReceiveMsg (SOCKET s, PBYTE pBuf, DWORD cbBuf, DWORD *pcbRead) <br>/*++ <br> <br> Routine Description: <br> <br>    Receives a message over the socket.  The first DWORD in the message <br>will be the message size.  The remainder of the bytes will be the <br>actual message. <br> <br> Return Value: <br> <br>    Returns TRUE is successful; otherwise FALSE is returned. <br> <br>--*/ <br>{ <br>DWORD cbRead; <br>DWORD cbData; <br> <br>// find out how much data is in the message <br>// <br>if (!ReceiveBytes (s, (PBYTE)&amp;cbData, sizeof (cbData), &amp;cbRead)) <br>return(FALSE); <br> <br>if (sizeof (cbData) != cbRead) <br>return(FALSE); <br> <br>// Read the full message <br>// <br>if (!ReceiveBytes (s, pBuf, cbData, &amp;cbRead)) <br>return(FALSE); <br> <br>if (cbRead != cbData) <br>return(FALSE); <br> <br>*pcbRead = cbRead; <br> <br>return(TRUE); <br>} <br> <br>BOOL SendBytes (SOCKET s, PBYTE pBuf, DWORD cbBuf) <br>{ <br>PBYTE pTemp = pBuf; <br>int cbSent, cbRemaining = cbBuf; <br> <br>if (0 == cbBuf) <br>return(TRUE); <br> <br>while (cbRemaining) { <br>cbSent = send (s, pTemp, cbRemaining, 0); <br>if (SOCKET_ERROR == cbSent) { <br>fprintf (stderr, "send failed: %u\n", GetLastError ()); <br>return FALSE; <br>} <br> <br>pTemp += cbSent; <br>cbRemaining -= cbSent; <br>} <br> <br>return TRUE; <br>} <br> <br>BOOL ReceiveBytes (SOCKET s, PBYTE pBuf, DWORD cbBuf, DWORD *pcbRead) <br>{ <br>PBYTE pTemp = pBuf; <br>int cbRead, cbRemaining = cbBuf; <br> <br>while (cbRemaining) { <br>cbRead = recv (s, pTemp, cbRemaining, 0); <br>if (0 == cbRead) <br>break; <br> <br>if (SOCKET_ERROR == cbRead) { <br>fprintf (stderr, "recv failed: %u\n", GetLastError ()); <br>return FALSE; <br>} <br> <br>cbRemaining -= cbRead; <br>pTemp += cbRead; <br>} <br> <br>*pcbRead = cbBuf - cbRemaining; <br> <br>return TRUE; <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
