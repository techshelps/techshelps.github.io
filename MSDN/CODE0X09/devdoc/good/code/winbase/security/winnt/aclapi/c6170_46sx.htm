<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>ACLAPI.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6171"></a>ACLAPI.C</h2>
<pre><code>/*++ <br> <br>Copyright 1996 - 1997 Microsoft Corporation <br> <br>Module Name: <br> <br>    aclapi.c <br> <br>Abstract: <br> <br>    This module illustrates new Acl management API for Windows NT 4.0. <br> <br>    Developers of new software which is to run on Windows NT version 4.0 <br>    and above are encouraged to utilize these security API rather than <br>    implementing code which uses lower level security API.  The development <br>    and test time can be drastically reduced by utilizing these new API. <br> <br>    This sample illustrates this point by implementing code which modifies <br>    the security on an existing file using the new Windows NT 4.0 <br>    Acl management API. <br> <br> <br>    The following new API functions are illustrated in this sample: <br> <br>    GetNamedSecurityInfo() <br>    BuildExplicitAccessWithName() <br>    SetEntriesInAcl() <br>    SetNamedSecurityInfo() <br> <br>    The following lower-level security API would have been used to achieve <br>    the same result: <br> <br>    LookupAccountName() <br>    InitializeSecurityDescriptor() <br>    InitializeAcl() <br>    GetSecurityDescriptorDacl() <br>    GetAclInformation() <br>    GetAce() <br>    SetSecurityDescriptorDacl() <br>    AddAce() <br>    AddAccessAllowedAce() / AddAccessDeniedAce() <br>    GetFileSecurity() <br>    SetFileSecurity() <br> <br>    Less code and less complex code is required to achieve this task using <br>    the new Windows NT 4.0 Acl management API. <br> <br>Author: <br> <br>    Scott Field (sfield)    02-Jun-96 <br> <br>--*/ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;aclapi.h&gt; <br>#include &lt;lmerr.h&gt; <br> <br>#include &lt;stdio.h&gt; <br> <br>#define RTN_OK 0 <br>#define RTN_USAGE 1 <br>#define RTN_ERROR 13 <br> <br>void <br>DisplayLastError( <br>    LPSTR szAPI <br>    ); <br> <br>int <br>__cdecl <br>main( <br>    int argc, <br>    char *argv[] <br>    ) <br>{ <br>    LPTSTR FileName; <br>    LPTSTR TrusteeName; <br> <br>    DWORD AccessMask = GENERIC_ALL; <br>    DWORD InheritFlag = NO_INHERITANCE; <br>    ACCESS_MODE option; <br>    EXPLICIT_ACCESS explicitaccess; <br> <br>    PACL ExistingDacl; <br>    PACL NewAcl = NULL; <br>    PSECURITY_DESCRIPTOR psd = NULL; <br> <br>    DWORD dwError; <br>    BOOL bSuccess = FALSE; // assume failure <br> <br>    if(argc &lt; 4) { <br>        printf("Usage: %s &lt;filename&gt; {/Deny | /Grant | /Revoke | /Set} [&lt;trustee&gt;] [&lt;permissions&gt;] [&lt;InheritFlag&gt;]\n", argv[0]); <br>        return RTN_USAGE; <br>    } <br> <br>    FileName = argv[1]; <br>    TrusteeName = argv[3]; <br> <br>    if ( (0 == stricmp(argv[2], "/Deny") ) || <br>        (0 == stricmp(argv[2], "/D") ) ) <br>    { <br>      option = DENY_ACCESS; <br>    } else if ( ( (0 == stricmp(argv[2], "/Revoke") ) || <br>                 (0 == stricmp(argv[2], "/R") ) ) ) <br>    { <br>      option = REVOKE_ACCESS; <br>    } else if ( (0 == stricmp(argv[2], "/Set") ) || <br>               (0 == stricmp(argv[2], "/S") ) ) <br>    { <br>      option = SET_ACCESS; <br>    } else if ( (0 == stricmp(argv[2], "/Grant") ) || <br>               (0 == stricmp(argv[2], "/G") ) ) <br>    { <br>      option = GRANT_ACCESS; <br>    } else { <br>        printf("Invalid action specified\n"); <br>        return RTN_ERROR; <br>    } <br> <br>    if (argc &gt; 4) <br>    { <br>        AccessMask = atol( argv[4] ); <br>    } <br> <br>    if (argc &gt; 5) <br>    { <br>       InheritFlag = atol( argv[5] ); <br>    } <br> <br>    // <br>    // get current Dacl on specified file <br>    // <br> <br>    dwError = GetNamedSecurityInfo( <br>                        FileName, <br>                        SE_FILE_OBJECT, <br>                        DACL_SECURITY_INFORMATION, <br>                        NULL, <br>                        NULL, <br>                        &amp;ExistingDacl, <br>                        NULL, <br>                        &amp;psd <br>                        ); <br> <br>    if(dwError != ERROR_SUCCESS) { <br>        DisplayLastError("GetNamedSecurityInfo"); <br>        return RTN_ERROR; <br>    } <br> <br>    BuildExplicitAccessWithName( <br>            &amp;explicitaccess, <br>            TrusteeName, <br>            AccessMask, <br>            option, <br>            InheritFlag <br>            ); <br> <br>    // <br>    // add specified access to the object <br>    // <br> <br>    dwError = SetEntriesInAcl( <br>            1, <br>            &amp;explicitaccess, <br>            ExistingDacl, <br>            &amp;NewAcl <br>            ); <br> <br>    if(dwError != ERROR_SUCCESS) { <br>        DisplayLastError("SetEntriesInAcl"); <br>        goto cleanup; <br>    } <br> <br>    // <br>    // apply new security to file <br>    // <br> <br>    dwError = SetNamedSecurityInfo( <br>                    FileName, <br>                    SE_FILE_OBJECT, // object type <br>                    DACL_SECURITY_INFORMATION, <br>                    NULL, <br>                    NULL, <br>                    NewAcl, <br>                    NULL <br>                    ); <br> <br>    if(dwError != ERROR_SUCCESS) { <br>        DisplayLastError("SetNamedSecurityInfo"); <br>        goto cleanup; <br>    } <br> <br>    bSuccess = TRUE; // indicate success <br> <br>cleanup: <br> <br>    if( NewAcl != NULL ) AccFree( NewAcl ); <br>    if( psd != NULL) AccFree( psd ); <br> <br> <br>    if(!bSuccess) <br>        return RTN_ERROR; <br> <br>    return RTN_OK; <br>} <br> <br>void <br>DisplayLastError( <br>    LPSTR szAPI <br>    ) <br>{ <br>    HMODULE hModule = NULL; // default to system source <br>    DWORD dwLastError = GetLastError(); <br>    LPSTR MessageBuffer; <br>    DWORD dwBufferLength; <br> <br>    DWORD dwFormatFlags = FORMAT_MESSAGE_ALLOCATE_BUFFER | <br>        FORMAT_MESSAGE_IGNORE_INSERTS | <br>        FORMAT_MESSAGE_FROM_SYSTEM ; <br> <br>    // <br>    // if dwLastError is in the network range, load the message source <br>    // <br> <br>    if(dwLastError &gt;= NERR_BASE &amp;&amp; dwLastError &lt;= MAX_NERR) { <br>        hModule = LoadLibraryEx( <br>            TEXT("netmsg.dll"), <br>            NULL, <br>            LOAD_LIBRARY_AS_DATAFILE <br>            ); <br> <br>        if(hModule != NULL) <br>            dwFormatFlags |= FORMAT_MESSAGE_FROM_HMODULE; <br>    } <br> <br>    printf("%s error! (rc=%lu)\n", szAPI, dwLastError); <br> <br>    // <br>    // call FormatMessage() to allow for message text to be acquired <br>    // from the system or the supplied module handle <br>    // <br> <br>    if(dwBufferLength = FormatMessageA( <br>        dwFormatFlags, <br>        hModule, // module to get message from (NULL == system) <br>        dwLastError, <br>        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // default language <br>        (LPSTR) &amp;MessageBuffer, <br>        0, <br>        NULL <br>        )) <br>    { <br>        DWORD dwBytesWritten; <br> <br>        // <br>        // Output message string on stderr <br>        // <br>        WriteFile( <br>            GetStdHandle(STD_ERROR_HANDLE), <br>            MessageBuffer, <br>            dwBufferLength, <br>            &amp;dwBytesWritten, <br>            NULL <br>            ); <br> <br>        // <br>        // free the buffer allocated by the system <br>        // <br>        LocalFree(MessageBuffer); <br>    } <br> <br>    // <br>    // if we loaded a message source, unload it <br>    // <br>    if(hModule != NULL) <br>        FreeLibrary(hModule); <br>} <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
