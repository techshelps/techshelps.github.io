<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SECPERF.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6224"></a>SECPERF.C</h2>
<pre><code>/*++ <br> <br>Module Name: <br> <br>    secperf.c <br> <br>Abstract: <br> <br>    This sample illustrates how to regulate access to the performance data <br>    provided by the registry key HKEY_PERFORMANCE_DATA. <br> <br>    The security on the following registry key dictates which users or groups <br>    can gain access to the performance data: <br> <br>    HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Perflib <br> <br>    This sample opens the registry key for WRITE_DAC access, which allows <br>    for a new Dacl to be applied to the registry key. <br> <br>    A Dacl is then built, which grants the following users access: <br> <br>    Administrators are granted full control to allow for future updates to the <br>    security on the key and to allow for querying performance data. <br> <br>    Interactively logged on users, through the well-known Interactive Sid, <br>    are granted KEY_READ access, which allows for querying performance <br>    data. <br> <br>    The new Dacl is then applied to the registry key using the <br>    RegSetKeySecurity() Win32 API. <br> <br>    This sample relies on the import library advapi32.lib. <br> <br>Author: <br> <br>    Scott Field (sfield)    19-Feb-96 <br> <br>--*/ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;stdio.h&gt; <br> <br>#define RTN_OK 0 <br>#define RTN_ERROR 13 <br> <br>void <br>DisplayWinError( <br>    LPSTR szAPI,    // pointer to Ansi function name <br>    DWORD dwError   // DWORD WinError <br>    ); <br> <br>int <br>__cdecl <br>main( <br>    void <br>    ) <br>{ <br>    SID_IDENTIFIER_AUTHORITY sia = SECURITY_NT_AUTHORITY; <br>    PSID pInteractiveSid = NULL; <br>    PSID pAdministratorsSid = NULL; <br>    SECURITY_DESCRIPTOR sd; <br>    PACL pDacl = NULL; <br>    DWORD dwAclSize; <br>    HKEY hKey; <br>    LONG lRetCode; <br>    BOOL bSuccess = FALSE; // assume this function fails <br> <br>    // <br>    // open the performance key for WRITE_DAC access <br>    // <br>    lRetCode = RegOpenKeyEx( <br>        HKEY_LOCAL_MACHINE, <br>       TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Perflib"), <br>        0, <br>        WRITE_DAC, <br>        &amp;hKey <br>        ); <br> <br>    if(lRetCode != ERROR_SUCCESS) { <br>        DisplayWinError("RegOpenKeyEx", lRetCode); <br>        return RTN_ERROR; <br>    } <br> <br>    // <br>    // prepare a Sid representing any Interactively logged-on user <br>    // <br>    if(!AllocateAndInitializeSid( <br>        &amp;sia, <br>        1, <br>        SECURITY_INTERACTIVE_RID, <br>        0, 0, 0, 0, 0, 0, 0, <br>        &amp;pInteractiveSid <br>        )) { <br>        DisplayWinError("AllocateAndInitializeSid", GetLastError()); <br>        goto cleanup; <br>    } <br> <br>    // <br>    // preprate a Sid representing the well-known admin group <br>    // <br>    if(!AllocateAndInitializeSid( <br>        &amp;sia, <br>        2, <br>        SECURITY_BUILTIN_DOMAIN_RID, <br>        DOMAIN_ALIAS_RID_ADMINS, <br>        0, 0, 0, 0, 0, 0, <br>        &amp;pAdministratorsSid <br>        )) { <br>        DisplayWinError("AllocateAndInitializeSid", GetLastError()); <br>        goto cleanup; <br>    } <br> <br>    // <br>    // compute size of new acl <br>    // <br>    dwAclSize = sizeof(ACL) + <br>        2 * ( sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD) ) + <br>        GetLengthSid(pInteractiveSid) + <br>        GetLengthSid(pAdministratorsSid) ; <br> <br>    // <br>    // allocate storage for Acl <br>    // <br>    pDacl = (PACL)HeapAlloc(GetProcessHeap(), 0, dwAclSize); <br>    if(pDacl == NULL) goto cleanup; <br> <br>    if(!InitializeAcl(pDacl, dwAclSize, ACL_REVISION)) { <br>        DisplayWinError("InitializeAcl", GetLastError()); <br>        goto cleanup; <br>    } <br> <br>    // <br>    // grant the Interactive Sid KEY_READ access to the perf key <br>    // <br>    if(!AddAccessAllowedAce( <br>        pDacl, <br>        ACL_REVISION, <br>        KEY_READ, <br>        pInteractiveSid <br>        )) { <br>        DisplayWinError("AddAccessAllowedAce", GetLastError()); <br>        goto cleanup; <br>    } <br> <br>    // <br>    // grant the Administrators Sid KEY_ALL_ACCESS access to the perf key <br>    // <br>    if(!AddAccessAllowedAce( <br>        pDacl, <br>        ACL_REVISION, <br>        KEY_ALL_ACCESS, <br>        pAdministratorsSid <br>        )) { <br>        DisplayWinError("AddAccessAllowedAce", GetLastError()); <br>        goto cleanup; <br>    } <br> <br>    if(!InitializeSecurityDescriptor(&amp;sd, SECURITY_DESCRIPTOR_REVISION)) { <br>        DisplayWinError("InitializeSecurityDescriptor", GetLastError()); <br>        goto cleanup; <br>    } <br> <br>    if(!SetSecurityDescriptorDacl(&amp;sd, TRUE, pDacl, FALSE)) { <br>        DisplayWinError("SetSecurityDescriptorDacl", GetLastError()); <br>        goto cleanup; <br>    } <br> <br>    // <br>    // apply the security descriptor to the registry key <br>    // <br>    lRetCode = RegSetKeySecurity( <br>        hKey, <br>        (SECURITY_INFORMATION)DACL_SECURITY_INFORMATION, <br>        &amp;sd <br>        ); <br> <br>    if(lRetCode != ERROR_SUCCESS) { <br>        DisplayWinError("RegSetKeySecurity", lRetCode); <br>        goto cleanup; <br>    } <br> <br>    bSuccess = TRUE; // indicate success <br> <br>cleanup: <br> <br>    RegCloseKey(hKey); <br>    RegCloseKey(HKEY_LOCAL_MACHINE); <br> <br>    // <br>    // free allocated resources <br>    // <br>    if(pDacl != NULL) <br>        HeapFree(GetProcessHeap(), 0, pDacl); <br> <br>    if(pInteractiveSid != NULL) <br>        FreeSid(pInteractiveSid); <br> <br>    if(pAdministratorsSid != NULL) <br>        FreeSid(pAdministratorsSid); <br> <br>    if(bSuccess) { <br>        printf("SUCCESS updating performance data security\n"); <br>        return RTN_OK; <br>    } else { <br>        printf("ERROR updating performance data security\n"); <br>        return RTN_ERROR; <br>    } <br>} <br> <br>void <br>DisplayWinError( <br>    LPSTR szAPI,    // pointer to Ansi function name <br>    DWORD dwError   // DWORD WinError <br>    ) <br>{ <br>    LPSTR MessageBuffer; <br>    DWORD dwBufferLength; <br> <br>    // <br>    // TODO get this fprintf out of here! <br>    // <br>    fprintf(stderr,"%s error!\n", szAPI); <br> <br>    if(dwBufferLength=FormatMessageA( <br>            FORMAT_MESSAGE_ALLOCATE_BUFFER | <br>            FORMAT_MESSAGE_FROM_SYSTEM, <br>            NULL, <br>            dwError, <br>            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), <br>            (LPSTR) &amp;MessageBuffer, <br>            0, <br>            NULL <br>            )) <br>    { <br>        DWORD dwBytesWritten; // unused <br> <br>        // <br>        // Output message string on stderr <br>        // <br>        WriteFile( <br>                GetStdHandle(STD_ERROR_HANDLE), <br>                MessageBuffer, <br>                dwBufferLength, <br>                &amp;dwBytesWritten, <br>                NULL <br>                ); <br> <br>        // <br>        // free the buffer allocated by the system <br>        // <br>        LocalFree(MessageBuffer); <br>    } <br>} <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
