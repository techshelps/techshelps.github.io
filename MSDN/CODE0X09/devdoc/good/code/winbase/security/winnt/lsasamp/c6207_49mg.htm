<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>LSASAMP.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6208"></a>LSASAMP.C</h2>
<pre><code>/*++ <br> <br>Managing user privileges can be achieved programmatically using the <br>following steps: <br> <br>1. Open the policy on the target machine with LsaOpenPolicy(). To grant <br>   privileges, open the policy with POLICY_CREATE_ACCOUNT and <br>   POLICY_LOOKUP_NAMES access. To revoke privileges, open the policy with <br>   POLICY_LOOKUP_NAMES access. <br> <br>2. Obtain a SID (security identifier) representing the user/group of <br>   interest. The LookupAccountName() and LsaLookupNames() APIs can obtain a <br>   SID from an account name. <br> <br>3. Call LsaAddAccountRights() to grant privileges to the user(s) <br>   represented by the supplied SID. <br> <br>4. Call LsaRemoveAccountRights() to revoke privileges from the user(s) <br>   represented by the supplied SID. <br> <br>5. Close the policy with LsaClose(). <br> <br>To successfully grant and revoke privileges, the caller needs to be an <br>administrator on the target system. <br> <br>The LSA API LsaEnumerateAccountRights() can be used to determine which <br>privileges have been granted to an account. <br> <br>The LSA API LsaEnumerateAccountsWithUserRight() can be used to determine <br>which accounts have been granted a specified privilege. <br> <br>Documentation and header files for these LSA APIs is provided in the <br>Windows 32 SDK in the MSTOOLS\SECURITY directory. <br> <br>NOTE: These LSA APIs are currently implemented as Unicode only. <br> <br>This sample will grant the privilege SeServiceLogonRight to the account <br>specified on argv[1]. <br> <br>This sample is dependant on these import libs <br> <br>   advapi32.lib (for LsaXxx) <br>   user32.lib (for wsprintf) <br> <br>This sample will work properly compiled ANSI or Unicode. <br> <br> <br> <br>You can use domain\account as argv[1]. For instance, mydomain\scott will <br>grant the privilege to the mydomain domain account scott. <br> <br>The optional target machine is specified as argv[2], otherwise, the <br>account database is updated on the local machine. <br> <br>The LSA APIs used by this sample are Unicode only. <br> <br>Use LsaRemoveAccountRights() to remove account rights. <br> <br>Scott Field (sfield)    12-Jul-95 <br> <br>--*/ <br> <br>#ifndef UNICODE <br>#define UNICODE <br>#endif // UNICODE <br> <br>#include &lt;windows.h&gt; <br>#include &lt;stdio.h&gt; <br> <br>#include "ntsecapi.h" <br> <br>NTSTATUS <br>OpenPolicy( <br>    LPWSTR ServerName,          // machine to open policy on (Unicode) <br>    DWORD DesiredAccess,        // desired access to policy <br>    PLSA_HANDLE PolicyHandle    // resultant policy handle <br>    ); <br> <br>BOOL <br>GetAccountSid( <br>    LPTSTR SystemName,          // where to lookup account <br>    LPTSTR AccountName,         // account of interest <br>    PSID *Sid                   // resultant buffer containing SID <br>    ); <br> <br>NTSTATUS <br>SetPrivilegeOnAccount( <br>    LSA_HANDLE PolicyHandle,    // open policy handle <br>    PSID AccountSid,            // SID to grant privilege to <br>    LPWSTR PrivilegeName,       // privilege to grant (Unicode) <br>    BOOL bEnable                // enable or disable <br>    ); <br> <br>void <br>InitLsaString( <br>    PLSA_UNICODE_STRING LsaString, // destination <br>    LPWSTR String                  // source (Unicode) <br>    ); <br> <br>void <br>DisplayNtStatus( <br>    LPSTR szAPI,                // pointer to function name (ANSI) <br>    NTSTATUS Status             // NTSTATUS error value <br>    ); <br> <br>void <br>DisplayWinError( <br>    LPSTR szAPI,                // pointer to function name (ANSI) <br>    DWORD WinError              // DWORD WinError <br>    ); <br> <br>#define RTN_OK 0 <br>#define RTN_USAGE 1 <br>#define RTN_ERROR 13 <br> <br>// <br>// If you have the ddk, include ntstatus.h. <br>// <br>#ifndef STATUS_SUCCESS <br>#define STATUS_SUCCESS  ((NTSTATUS)0x00000000L) <br>#endif <br> <br>int _cdecl <br>main(int argc, char *argv[]) <br>{ <br>    LSA_HANDLE PolicyHandle; <br>    WCHAR wComputerName[256]=L"";   // static machine name buffer <br>    TCHAR AccountName[256];         // static account name buffer <br>    PSID pSid; <br>    NTSTATUS Status; <br>    int iRetVal=RTN_ERROR;          // assume error from main <br> <br>    if(argc == 1) <br>    { <br>        fprintf(stderr,"Usage: %s &lt;Account&gt; [TargetMachine]\n", <br>            argv[0]); <br>        return RTN_USAGE; <br>    } <br> <br>    // <br>    // Pick up account name on argv[1]. <br>    // Assumes source is ANSI. Resultant string is ANSI or Unicode <br>    // <br>    wsprintf(AccountName, TEXT("%hS"), argv[1]); <br> <br>    // <br>    // Pick up machine name on argv[2], if appropriate <br>    // assumes source is ANSI. Resultant string is Unicode. <br>    // <br>    if(argc == 3) wsprintfW(wComputerName, L"%hS", argv[2]); <br> <br>    // <br>    // Open the policy on the target machine. <br>    // <br>    if((Status=OpenPolicy( <br>                wComputerName,      // target machine <br>                POLICY_CREATE_ACCOUNT | POLICY_LOOKUP_NAMES, <br>                &amp;PolicyHandle       // resultant policy handle <br>                )) != STATUS_SUCCESS) { <br>        DisplayNtStatus("OpenPolicy", Status); <br>        return RTN_ERROR; <br>    } <br> <br>    // <br>    // Obtain the SID of the user/group. <br>    // Note that we could target a specific machine, but we don't. <br>    // Specifying NULL for target machine searches for the SID in the <br>    // following order: well-known, Built-in and local, primary domain, <br>    // trusted domains. <br>    // <br>    if(GetAccountSid( <br>            NULL,       // default lookup logic <br>            AccountName,// account to obtain SID <br>            &amp;pSid       // buffer to allocate to contain resultant SID <br>            )) { <br>        // <br>        // We only grant the privilege if we succeeded in obtaining the <br>        // SID. We can actually add SIDs which cannot be looked up, but <br>        // looking up the SID is a good sanity check which is suitable for <br>        // most cases. <br> <br>        // <br>        // Grant the SeServiceLogonRight to users represented by pSid. <br>        // <br>        if((Status=SetPrivilegeOnAccount( <br>                    PolicyHandle,           // policy handle <br>                    pSid,                   // SID to grant privilege <br>                    L"SeServiceLogonRight", // Unicode privilege <br>                    TRUE                    // enable the privilege <br>                    )) == STATUS_SUCCESS) <br>            iRetVal=RTN_OK; <br>        else <br>            DisplayNtStatus("AddUserRightToAccount", Status); <br>    } <br>    else { <br>        // <br>        // Error obtaining SID. <br>        // <br>        DisplayWinError("GetAccountSid", GetLastError()); <br>    } <br> <br>    // <br>    // Close the policy handle. <br>    // <br>    LsaClose(PolicyHandle); <br> <br>    // <br>    // Free memory allocated for SID. <br>    // <br>    if(pSid != NULL) HeapFree(GetProcessHeap(), 0, pSid); <br> <br>    return iRetVal; <br>} <br> <br>void <br>InitLsaString( <br>    PLSA_UNICODE_STRING LsaString, <br>    LPWSTR String <br>    ) <br>{ <br>    DWORD StringLength; <br> <br>    if (String == NULL) { <br>        LsaString-&gt;Buffer = NULL; <br>        LsaString-&gt;Length = 0; <br>        LsaString-&gt;MaximumLength = 0; <br>        return; <br>    } <br> <br>    StringLength = wcslen(String); <br>    LsaString-&gt;Buffer = String; <br>    LsaString-&gt;Length = (USHORT) StringLength * sizeof(WCHAR); <br>    LsaString-&gt;MaximumLength=(USHORT)(StringLength+1) * sizeof(WCHAR); <br>} <br> <br>NTSTATUS <br>OpenPolicy( <br>    LPWSTR ServerName, <br>    DWORD DesiredAccess, <br>    PLSA_HANDLE PolicyHandle <br>    ) <br>{ <br>    LSA_OBJECT_ATTRIBUTES ObjectAttributes; <br>    LSA_UNICODE_STRING ServerString; <br>    PLSA_UNICODE_STRING Server = NULL; <br> <br>    // <br>    // Always initialize the object attributes to all zeroes. <br>    // <br>    ZeroMemory(&amp;ObjectAttributes, sizeof(ObjectAttributes)); <br> <br>    if (ServerName != NULL) { <br>        // <br>        // Make a LSA_UNICODE_STRING out of the LPWSTR passed in <br>        // <br>        InitLsaString(&amp;ServerString, ServerName); <br>        Server = &amp;ServerString; <br>    } <br> <br>    // <br>    // Attempt to open the policy. <br>    // <br>    return LsaOpenPolicy( <br>                Server, <br>                &amp;ObjectAttributes, <br>                DesiredAccess, <br>                PolicyHandle <br>                ); <br>} <br> <br>/*++ <br>This function attempts to obtain a SID representing the supplied <br>account on the supplied system. <br> <br>If the function succeeds, the return value is TRUE. A buffer is <br>allocated which contains the SID representing the supplied account. <br>This buffer should be freed when it is no longer needed by calling <br>HeapFree(GetProcessHeap(), 0, buffer) <br> <br>If the function fails, the return value is FALSE. Call GetLastError() <br>to obtain extended error information. <br> <br>Scott Field (sfield)    12-Jul-95 <br>--*/ <br> <br>BOOL <br>GetAccountSid( <br>    LPTSTR SystemName, <br>    LPTSTR AccountName, <br>    PSID *Sid <br>    ) <br>{ <br>    LPTSTR ReferencedDomain=NULL; <br>    DWORD cbSid=128;    // initial allocation attempt <br>    DWORD cbReferencedDomain=16; // initial allocation size <br>    SID_NAME_USE peUse; <br>    BOOL bSuccess=FALSE; // assume this function will fail <br> <br>    __try { <br> <br>    // <br>    // initial memory allocations <br>    // <br>    if((*Sid=HeapAlloc( <br>                    GetProcessHeap(), <br>                    0, <br>                    cbSid <br>                    )) == NULL) __leave; <br> <br>    if((ReferencedDomain=HeapAlloc( <br>                    GetProcessHeap(), <br>                    0, <br>                    cbReferencedDomain <br>                    )) == NULL) __leave; <br> <br>    // <br>    // Obtain the SID of the specified account on the specified system. <br>    // <br>    while(!LookupAccountName( <br>                    SystemName,         // machine to lookup account on <br>                    AccountName,        // account to lookup <br>                    *Sid,               // SID of interest <br>                    &amp;cbSid,             // size of SID <br>                    ReferencedDomain,   // domain account was found on <br>                    &amp;cbReferencedDomain, <br>                    &amp;peUse <br>                    )) { <br>        if (GetLastError() == ERROR_INSUFFICIENT_BUFFER) { <br>            // <br>            // reallocate memory <br>            // <br>            if((*Sid=HeapReAlloc( <br>                        GetProcessHeap(), <br>                        0, <br>                        *Sid, <br>                        cbSid <br>                        )) == NULL) __leave; <br> <br>            if((ReferencedDomain=HeapReAlloc( <br>                        GetProcessHeap(), <br>                        0, <br>                        ReferencedDomain, <br>                        cbReferencedDomain <br>                        )) == NULL) __leave; <br>        } <br>        else __leave; <br>    } <br> <br>    // <br>    // Indicate success. <br>    // <br>    bSuccess=TRUE; <br> <br>    } // finally <br>    __finally { <br> <br>    // <br>    // Cleanup and indicate failure, if appropriate. <br>    // <br> <br>    HeapFree(GetProcessHeap(), 0, ReferencedDomain); <br> <br>    if(!bSuccess) { <br>        if(*Sid != NULL) { <br>            HeapFree(GetProcessHeap(), 0, *Sid); <br>            *Sid = NULL; <br>        } <br>    } <br> <br>    } // finally <br> <br>    return bSuccess; <br>} <br> <br>NTSTATUS <br>SetPrivilegeOnAccount( <br>    LSA_HANDLE PolicyHandle,    // open policy handle <br>    PSID AccountSid,            // SID to grant privilege to <br>    LPWSTR PrivilegeName,       // privilege to grant (Unicode) <br>    BOOL bEnable                // enable or disable <br>    ) <br>{ <br>    LSA_UNICODE_STRING PrivilegeString; <br> <br>    // <br>    // Create a LSA_UNICODE_STRING for the privilege name. <br>    // <br>    InitLsaString(&amp;PrivilegeString, PrivilegeName); <br> <br>    // <br>    // grant or revoke the privilege, accordingly <br>    // <br>    if(bEnable) { <br>        return LsaAddAccountRights( <br>                PolicyHandle,       // open policy handle <br>                AccountSid,         // target SID <br>                &amp;PrivilegeString,   // privileges <br>                1                   // privilege count <br>                ); <br>    } <br>    else { <br>        return LsaRemoveAccountRights( <br>                PolicyHandle,       // open policy handle <br>                AccountSid,         // target SID <br>                FALSE,              // do not disable all rights <br>                &amp;PrivilegeString,   // privileges <br>                1                   // privilege count <br>                ); <br>    } <br>} <br> <br>void <br>DisplayNtStatus( <br>    LPSTR szAPI, <br>    NTSTATUS Status <br>    ) <br>{ <br>    // <br>    // Convert the NTSTATUS to Winerror. Then call DisplayWinError(). <br>    // <br>    DisplayWinError(szAPI, LsaNtStatusToWinError(Status)); <br>} <br> <br>void <br>DisplayWinError( <br>    LPSTR szAPI, <br>    DWORD WinError <br>    ) <br>{ <br>    LPSTR MessageBuffer; <br>    DWORD dwBufferLength; <br> <br>    // <br>    // TODO: Get this fprintf out of here! <br>    // <br>    fprintf(stderr,"%s error!\n", szAPI); <br> <br>    if(dwBufferLength=FormatMessageA( <br>                        FORMAT_MESSAGE_ALLOCATE_BUFFER | <br>                        FORMAT_MESSAGE_FROM_SYSTEM, <br>                        NULL, <br>                        WinError, <br>                        GetUserDefaultLangID(), <br>                        (LPSTR) &amp;MessageBuffer, <br>                        0, <br>                        NULL <br>                        )) <br>    { <br>        DWORD dwBytesWritten; // unused <br> <br>        // <br>        // Output message string on stderr. <br>        // <br>        WriteFile( <br>            GetStdHandle(STD_ERROR_HANDLE), <br>            MessageBuffer, <br>            dwBufferLength, <br>            &amp;dwBytesWritten, <br>            NULL <br>            ); <br> <br>        // <br>        // Free the buffer allocated by the system. <br>        // <br>        LocalFree(MessageBuffer); <br>    } <br>} <br> <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
