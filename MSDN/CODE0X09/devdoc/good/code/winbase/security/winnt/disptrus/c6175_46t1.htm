<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DISPTRUS.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6175"></a>DISPTRUS.C</h2>
<pre><code>/*++ <br> <br>Copyright 1996 - 1997 Microsoft Corporation <br> <br>Module Name: <br> <br>    disptrus.c <br> <br>Abstract: <br> <br>    This sample enumerates the trusted domains on the target machine, and <br>    displays them on stdout.  This list matches (minus sorting) the list of <br>    domains presents by the WinNT Dacl editor.  For practical applications, <br>    replace the AddTrustToList() function with linked-list management code <br>    and then use the resultant list later on in the application. <br> <br>    The optional target machine is specified as argv[1], eg, lsatrust \\winbase <br> <br>    For a WinNT workstation which is not a member of a domain, the only <br>    relevant trusted domain is the account domain of the machine.  We detect <br>    a non-member workstation by checking if the primary domain Sid is NULL. <br> <br>    For a WinNT workstation which is a member of a domain, the relevant trusted <br>    domain is the account domain, the primary domain, and the trusted domain(s) <br>    of the primary domain. <br> <br>    For a WinNT Domain controller, the account domain and the trusted domains. <br> <br>Author: <br> <br>    Scott Field (sfield) 16-Mar-96 <br> <br>--*/ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;lm.h&gt; <br>#include "ntsecapi.h" // \mstools\samples\win32\winnt\security\include\ntsecapi.h <br> <br>#include &lt;stdio.h&gt; <br> <br>BOOL <br>BuildTrustList( <br>    LPWSTR Target <br>    ); <br> <br>BOOL <br>IsDomainController( <br>    LPWSTR Server, <br>    LPBOOL bDomainController <br>    ); <br> <br>BOOL <br>EnumTrustedDomains( <br>    LSA_HANDLE PolicyHandle <br>    ); <br> <br>BOOL <br>AddTrustToList( <br>    PLSA_UNICODE_STRING UnicodeString <br>    ); <br> <br>// <br>// helper functions <br>// <br> <br>void <br>InitLsaString( <br>    PLSA_UNICODE_STRING LsaString, <br>    LPWSTR String <br>    ); <br> <br>NTSTATUS <br>OpenPolicy( <br>    LPWSTR ServerName, <br>    DWORD DesiredAccess, <br>    PLSA_HANDLE PolicyHandle <br>    ); <br> <br>void <br>DisplayWinError( <br>    LPSTR szAPI,        // pointer to Ansi function name <br>    DWORD dwLastError   // DWORD WinError <br>    ); <br> <br>#define RTN_OK 0 <br>#define RTN_ERROR 13 <br> <br>// <br>// if you have the ddk, include ntstatus.h <br>// <br>#ifndef STATUS_SUCCESS <br>#define STATUS_SUCCESS                  ((NTSTATUS)0x00000000L) <br>#define STATUS_MORE_ENTRIES             ((NTSTATUS)0x00000105L) <br>#define STATUS_NO_MORE_ENTRIES          ((NTSTATUS)0x8000001AL) <br>#endif <br> <br> <br>#define ELEMENT_COUNT 64    // number of array elements to allocate <br> <br>LPWSTR *g_TrustList;        // array of trust elements <br>DWORD g_TrustCount;         // number of elements in g_TrustList <br> <br>// <br>// Unicode entry point and argv <br>// <br> <br>int <br>__cdecl <br>wmain( <br>    int argc, <br>    wchar_t *argv[] <br>    ) <br>{ <br>    LPWSTR TargetComputer; <br>    DWORD i; <br> <br>    g_TrustCount = 0; <br>    g_TrustList = (LPWSTR *)HeapAlloc( <br>        GetProcessHeap(), HEAP_ZERO_MEMORY, <br>        ELEMENT_COUNT * sizeof(LPWSTR) <br>        ); <br> <br>    if(g_TrustList == NULL) { <br>        printf("HeapAlloc error!\n"); <br>        return RTN_ERROR; <br>    } <br> <br>    // <br>    // if a target computer was specified, get it <br>    // <br>    if(argc == 2) <br>        TargetComputer = argv[1]; <br>    else <br>        TargetComputer = NULL; // default to local machine <br> <br>    // <br>    // build the trust list, and display it if successful <br>    // <br>    if(!BuildTrustList(TargetComputer)) { <br>        DisplayWinError("BuildTrustList", GetLastError()); <br>    } else { <br> <br>        // <br>        // display trust list <br>        // <br>        for(i = 0 ; i &lt; g_TrustCount ; i++) <br>            printf("%ls\n", g_TrustList[i]); <br>    } <br> <br>    // <br>    // free trust list <br>    // <br>    for(i = 0 ; i &lt; g_TrustCount ; i++) { <br>        if(g_TrustList[i] != NULL) <br>            HeapFree(GetProcessHeap(), 0, g_TrustList[i]); <br>    } <br> <br>    HeapFree(GetProcessHeap(), 0, g_TrustList); <br> <br>    return RTN_OK; <br>} <br> <br>BOOL <br>BuildTrustList( <br>    LPWSTR Target <br>    ) <br>{ <br>    LSA_HANDLE PolicyHandle; <br>    NTSTATUS Status; <br> <br>    PPOLICY_ACCOUNT_DOMAIN_INFO AccountDomain; <br>    BOOL bDC; <br>    NET_API_STATUS nas = NERR_Success; // assume success <br> <br>    BOOL bSuccess = FALSE; // assume this function will fail <br> <br>    // <br>    // open the policy on the specified machine <br>    // <br>    Status = OpenPolicy( <br>                Target, <br>                POLICY_VIEW_LOCAL_INFORMATION, <br>                &amp;PolicyHandle <br>                ); <br> <br>    if(Status != STATUS_SUCCESS) { <br>        SetLastError( LsaNtStatusToWinError(Status) ); <br>        return FALSE; <br>    } <br> <br>    // <br>    // obtain the AccountDomain, which is common to all three cases <br>    // <br>    Status = LsaQueryInformationPolicy( <br>                PolicyHandle, <br>                PolicyAccountDomainInformation, <br>                &amp;AccountDomain <br>                ); <br> <br>    if(Status != STATUS_SUCCESS) <br>        goto cleanup; <br> <br>    // <br>    // Note: AccountDomain-&gt;DomainSid will contain binary Sid <br>    // <br>    AddTrustToList(&amp;AccountDomain-&gt;DomainName); <br> <br>    // <br>    // free memory allocated for account domain <br>    // <br>    LsaFreeMemory(AccountDomain); <br> <br>    // <br>    // find out if the target machine is a domain controller <br>    // <br>    if(!IsDomainController(Target, &amp;bDC)) { <br>        //// <br>        goto cleanup; <br>    } <br> <br>    if(!bDC) { <br>        PPOLICY_PRIMARY_DOMAIN_INFO PrimaryDomain; <br>        LPWSTR szPrimaryDomainName = NULL; <br>        LPWSTR DomainController = NULL; <br> <br>        // <br>        // get the primary domain <br>        // <br>        Status = LsaQueryInformationPolicy( <br>                PolicyHandle, <br>                PolicyPrimaryDomainInformation, <br>                &amp;PrimaryDomain <br>                ); <br> <br>        if(Status != STATUS_SUCCESS) <br>            goto cleanup; <br> <br>        // <br>        // if the primary domain Sid is NULL, we are a non-member, and <br>        // our work is done. <br>        // <br>        if(PrimaryDomain-&gt;Sid == NULL) { <br>            LsaFreeMemory(PrimaryDomain); <br>            bSuccess = TRUE; <br>            goto cleanup; <br>        } <br> <br>        AddTrustToList(&amp;PrimaryDomain-&gt;Name); <br> <br>        // <br>        // build a copy of what we just added.  This is necessary in order <br>        // to lookup the domain controller for the specified domain. <br>        // the Domain name must be NULL terminated for NetGetDCName(), <br>        // and the LSA_UNICODE_STRING buffer is not necessarilly NULL <br>        // terminated.  Note that in a practical implementation, we <br>        // could just extract the element we added, since it ends up <br>        // NULL terminated. <br>        // <br> <br>        szPrimaryDomainName = (LPWSTR)HeapAlloc( <br>            GetProcessHeap(), 0, <br>            PrimaryDomain-&gt;Name.Length + sizeof(WCHAR) // existing length + NULL <br>            ); <br> <br>        if(szPrimaryDomainName != NULL) { <br>            // <br>            // copy the existing buffer to the new storage, appending a NULL <br>            // <br>            lstrcpynW( <br>                szPrimaryDomainName, <br>                PrimaryDomain-&gt;Name.Buffer, <br>                (PrimaryDomain-&gt;Name.Length / sizeof(WCHAR)) + 1 <br>                ); <br>        } <br> <br>        LsaFreeMemory(PrimaryDomain); <br> <br>        if(szPrimaryDomainName == NULL) goto cleanup; <br> <br>        // <br>        // get the primary domain controller computer name <br>        // <br>        nas = NetGetDCName( <br>            NULL, <br>            szPrimaryDomainName, <br>            (LPBYTE *)&amp;DomainController <br>            ); <br> <br>        HeapFree(GetProcessHeap(), 0, szPrimaryDomainName); <br> <br>        if(nas != NERR_Success) <br>            goto cleanup; <br> <br>        // <br>        // close the policy handle, because we don't need it anymore <br>        // for the workstation case, as we open a handle to a DC <br>        // policy below <br>        // <br>        LsaClose(PolicyHandle); <br>        PolicyHandle = INVALID_HANDLE_VALUE; // invalidate handle value <br> <br>        // <br>        // open the policy on the domain controller <br>        // <br>        Status = OpenPolicy( <br>                    DomainController, <br>                    POLICY_VIEW_LOCAL_INFORMATION, <br>                    &amp;PolicyHandle <br>                    ); <br> <br>        // <br>        // free the domaincontroller buffer <br>        // <br>        NetApiBufferFree(DomainController); <br> <br>        if(Status != STATUS_SUCCESS) <br>            goto cleanup; <br>    } <br> <br>    // <br>    // build additional trusted domain(s) list and indicate if successful <br>    // <br>    bSuccess = EnumTrustedDomains(PolicyHandle); <br> <br>cleanup: <br> <br>    // <br>    // close the policy handle <br>    // <br>    if(PolicyHandle != INVALID_HANDLE_VALUE) <br>        LsaClose(PolicyHandle); <br> <br>    if(!bSuccess) { <br>        if(Status != STATUS_SUCCESS) <br>            SetLastError( LsaNtStatusToWinError(Status) ); <br>        else if(nas != NERR_Success) <br>            SetLastError( nas ); <br>    } <br> <br>    return bSuccess; <br>} <br> <br>BOOL <br>EnumTrustedDomains( <br>    LSA_HANDLE PolicyHandle <br>    ) <br>{ <br>    LSA_ENUMERATION_HANDLE lsaEnumHandle=0; // start an enum <br>    PLSA_TRUST_INFORMATION TrustInfo; <br>    ULONG ulReturned;               // number of items returned <br>    ULONG ulCounter;                // counter for items returned <br>    NTSTATUS Status; <br> <br>    do { <br>        Status = LsaEnumerateTrustedDomains( <br>                        PolicyHandle,   // open policy handle <br>                        &amp;lsaEnumHandle, // enumeration tracker <br>                        &amp;TrustInfo,     // buffer to receive data <br>                        32000,          // recommended buffer size <br>                        &amp;ulReturned     // number of items returned <br>                        ); <br>        // <br>        // get out if an error occurred <br>        // <br>        if( (Status != STATUS_SUCCESS) &amp;&amp; <br>            (Status != STATUS_MORE_ENTRIES) &amp;&amp; <br>            (Status != STATUS_NO_MORE_ENTRIES) <br>            ) { <br>            SetLastError( LsaNtStatusToWinError(Status) ); <br>            return FALSE; <br>        } <br> <br>        // <br>        // Display results <br>        // Note: Sids are in TrustInfo[ulCounter].Sid <br>        // <br>        for(ulCounter = 0 ; ulCounter &lt; ulReturned ; ulCounter++) <br>            AddTrustToList(&amp;TrustInfo[ulCounter].Name); <br> <br>        // <br>        // free the buffer <br>        // <br>        LsaFreeMemory(TrustInfo); <br> <br>    } while (Status != STATUS_NO_MORE_ENTRIES); <br> <br>    return TRUE; <br>} <br> <br>BOOL <br>IsDomainController( <br>    LPWSTR Server, <br>    LPBOOL bDomainController <br>    ) <br>{ <br>    PSERVER_INFO_101 si101; <br>    NET_API_STATUS nas; <br> <br>    nas = NetServerGetInfo( <br>        (LPTSTR)Server, <br>        101,    // info-level <br>        (LPBYTE *)&amp;si101 <br>        ); <br> <br>    if(nas != NERR_Success) { <br>        SetLastError(nas); <br>        return FALSE; <br>    } <br> <br>    if( (si101-&gt;sv101_type &amp; SV_TYPE_DOMAIN_CTRL) || <br>        (si101-&gt;sv101_type &amp; SV_TYPE_DOMAIN_BAKCTRL) ) { <br>        // <br>        // we are dealing with a DC <br>        // <br>        *bDomainController = TRUE; <br>    } else { <br>        *bDomainController = FALSE; <br>    } <br> <br>    NetApiBufferFree(si101); <br> <br>    return TRUE; <br>} <br> <br>BOOL <br>AddTrustToList( <br>    PLSA_UNICODE_STRING UnicodeString <br>    ) <br>{ <br>    if(g_TrustCount &gt;= ELEMENT_COUNT) return FALSE; <br> <br>    // <br>    // allocate storage for array element <br>    // <br>    g_TrustList[g_TrustCount] = (LPWSTR)HeapAlloc( <br>        GetProcessHeap(), 0, <br>        UnicodeString-&gt;Length + sizeof(WCHAR) // existing length + NULL <br>        ); <br> <br>    if(g_TrustList[g_TrustCount] == NULL) return FALSE; <br> <br>    // <br>    // copy the existing buffer to the new storage, appending a NULL <br>    // <br>    lstrcpynW( <br>        g_TrustList[g_TrustCount], <br>        UnicodeString-&gt;Buffer, <br>        (UnicodeString-&gt;Length / sizeof(WCHAR)) + 1 <br>        ); <br> <br>    g_TrustCount++; // increment the trust count <br> <br>    return TRUE; <br>} <br> <br>void <br>InitLsaString( <br>    PLSA_UNICODE_STRING LsaString, <br>    LPWSTR String <br>    ) <br>{ <br>    DWORD StringLength; <br> <br>    if (String == NULL) { <br>        LsaString-&gt;Buffer = NULL; <br>        LsaString-&gt;Length = 0; <br>        LsaString-&gt;MaximumLength = 0; <br> <br>        return; <br>    } <br> <br>    StringLength = lstrlenW(String); <br>    LsaString-&gt;Buffer = String; <br>    LsaString-&gt;Length = (USHORT) StringLength * sizeof(WCHAR); <br>    LsaString-&gt;MaximumLength = (USHORT) (StringLength + 1) * sizeof(WCHAR); <br>} <br> <br>NTSTATUS <br>OpenPolicy( <br>    LPWSTR ServerName, <br>    DWORD DesiredAccess, <br>    PLSA_HANDLE PolicyHandle <br>    ) <br>{ <br>    LSA_OBJECT_ATTRIBUTES ObjectAttributes; <br>    LSA_UNICODE_STRING ServerString; <br>    PLSA_UNICODE_STRING Server; <br> <br>    // <br>    // Always initialize the object attributes to all zeroes <br>    // <br>    ZeroMemory(&amp;ObjectAttributes, sizeof(ObjectAttributes)); <br> <br>    if(ServerName != NULL) { <br>        // <br>        // Make a LSA_UNICODE_STRING out of the LPWSTR passed in <br>        // <br>        InitLsaString(&amp;ServerString, ServerName); <br> <br>        Server = &amp;ServerString; <br>    } else { <br>        Server = NULL; <br>    } <br> <br>    // <br>    // Attempt to open the policy <br>    // <br>    return LsaOpenPolicy( <br>                Server, <br>                &amp;ObjectAttributes, <br>                DesiredAccess, <br>                PolicyHandle <br>                ); <br>} <br> <br>void <br>DisplayWinError( <br>    LPSTR szAPI,    // pointer to failed API name <br>    DWORD dwLastError <br>    ) <br>{ <br>    HMODULE hModule = NULL; <br>    LPSTR MessageBuffer; <br>    DWORD dwBufferLength; <br> <br>    fprintf(stderr,"%s error! (rc=%lu)\n", szAPI, dwLastError); <br> <br>    if(dwLastError &gt;= NERR_BASE &amp;&amp; dwLastError &lt;= MAX_NERR) { <br>        hModule = LoadLibraryEx( <br>            TEXT("netmsg.dll"), <br>            NULL, <br>            LOAD_LIBRARY_AS_DATAFILE <br>            ); <br>    } <br> <br>    if(dwBufferLength=FormatMessageA( <br>        FORMAT_MESSAGE_ALLOCATE_BUFFER | <br>        FORMAT_MESSAGE_IGNORE_INSERTS | <br>        FORMAT_MESSAGE_FROM_SYSTEM | <br>        ((hModule != NULL) ? FORMAT_MESSAGE_FROM_HMODULE : 0), <br>        hModule, // module to get message from <br>        dwLastError, <br>        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // default language <br>        (LPSTR) &amp;MessageBuffer, <br>        0, <br>        NULL <br>        )) <br>    { <br>        DWORD dwBytesWritten; <br> <br>        // <br>        // Output message string on stderr <br>        // <br>        WriteFile( <br>            GetStdHandle(STD_ERROR_HANDLE), <br>            MessageBuffer, <br>            dwBufferLength, <br>            &amp;dwBytesWritten, <br>            NULL <br>            ); <br> <br>        // <br>        // free the buffer allocated by the system <br>        // <br>        LocalFree(MessageBuffer); <br>    } <br> <br>    if(hModule != NULL) <br>        FreeLibrary(hModule); <br>} <br> <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
