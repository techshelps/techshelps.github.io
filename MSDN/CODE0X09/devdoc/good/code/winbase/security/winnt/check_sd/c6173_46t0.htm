<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CHECK_SD.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6174"></a>CHECK_SD.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples. <br>*       Copyright 1992 - 1998 Microsoft Corporation. <br>*       All rights reserved. <br>*       This source code is only intended as a supplement to <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>/****************************************************************************\ <br>* <br>* MODULE:       check_sd.c <br>* <br>*               In the Win32 .hlp file, if you click on Search, goto "Security <br>*                 Overview", then choose from the list of topics under <br>*                 Security Overview the sub-topic "Allowing Access", you'll <br>*                 find the comment <br>* <br>*                 Note:  It is fine to write code like this that builds <br>*                   security descriptors from scratch.  It is, however, a good <br>*                   practice for people who write code that builds or <br>*                   manipulates security descriptors to first write code that <br>*                   explores the default security descriptors that Windows NT <br>*                   places on objects.  For example, if Windows NT by default <br>*                   includes in a DACL an ACE granting the Local Logon SID <br>*                   certain access, it's good to know that, so that a decision <br>*                   not to grant any access to the Local Logon SID would be a <br>*                   conscious decision <br>* <br>*                 Note:  Obtaining the SACL from an object requires that the <br>*                   caller enables the SeSecurityPrivilege, and the object is <br>*                   opened with an additional access mask, <br>*                   ACCESS_SYSTEM_SECURITY. <br>* <br>* <br>* PURPOSE:      The comment in the .hlp file is accurate, however, for many <br>*                 people this task of examining the SD is easier if there is <br>*                 sample code to start from.  So, the purpose of this sample <br>*                 is to assist people by providing sample code people can <br>*                 start from as they examine SD(s).  This sample as is <br>*                 examines the SD on files, and this code can be modified to <br>*                 examine the SD on other objects <br>* <br>*               This sample is not a supported utility <br>* <br>* TO RUN:       Type Check_sd to check the SD on the \\.\A:  device <br>* <br>*               Type Check_sd d:\a.fil to check the SD on the d:\a.fil file. <br>*                 In this case d:  must be formatted NTFS, because only NTFS <br>*                 files have SD(s) <br>* <br>\****************************************************************************/ <br> <br>/****************************************************************************\ <br>*  INCLUDES, DEFINES <br>\****************************************************************************/ <br>#define STRICT <br>#include &lt;windows.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;stdio.h&gt; <br> <br>#define PERR(api) printf("\n%s: Error %d from %s on line %d",  \ <br>    __FILE__, GetLastError(), api, __LINE__); <br>#define PMSG(msg) printf("\n%s line %d: %s",  \ <br>    __FILE__, __LINE__, msg); <br> <br>/****************************************************************************\ <br>* GLOBAL VARIABLES AND TYPEDEFS <br>\****************************************************************************/ <br> <br>typedef enum _KINDS_OF_ACCESSMASKS_DECODED { <br>    FileAccessMask, <br>    ProcessAccessMask, <br>    WindowStationAccessMask, <br>    DesktopAccessMask, <br>    RegKeyAccessMask, <br>    ServiceAccessMask, <br>    DefaultDaclInAccessTokenAccessMask <br>    } KINDS_OF_ACCESSMASKS_DECODED, * PKINDS_OF_ACCESSMASKS_DECODED; <br> <br>// These hold the well-known SIDs <br> <br>PSID psidNullSid; <br>PSID psidWorldSid; <br>PSID psidLocalSid; <br>PSID psidCreatorOwnerSid; <br>PSID psidCreatorGroupSid; <br>PSID psidNtAuthoritySid; <br>PSID psidDialupSid; <br>PSID psidNetworkSid; <br>PSID psidBatchSid; <br>PSID psidInteractiveSid; <br>PSID psidLogonIdsSid; // But the X and Y values are bogus at first!!! (See below) <br>PSID psidServiceSid; <br>PSID psidLocalSystemSid; <br>PSID psidBuiltinDomainSid; <br> <br>/****************************************************************************\ <br>* FUNCTION PROTOTYPES <br>\****************************************************************************/ <br> <br>VOID ExamineAccessToken(HANDLE hAccessToken); <br>BOOL ExamineSD    (PSECURITY_DESCRIPTOR psdSD, <br>                   KINDS_OF_ACCESSMASKS_DECODED kamKindOfMask); <br>BOOL ExamineACL   (PACL paclACL,              LPTSTR lpszOldIndent, <br>                   KINDS_OF_ACCESSMASKS_DECODED kamKindOfMask); <br>VOID ExamineMask  (ACCESS_MASK amMask,        LPTSTR lpszOldIndent, <br>                   KINDS_OF_ACCESSMASKS_DECODED kamKindOfMask); <br>BOOL LookupSIDName(PSID psidSID,              LPTSTR lpszOldIndent); <br>BOOL SIDStringName(PSID psidSID, LPTSTR lpszSIDStringName); <br>BOOL SetPrivilegeInAccessToken(VOID); <br>VOID InitializeWellKnownSIDs(VOID); <br>VOID DisplayHelp(VOID); <br> <br>UINT main(UINT argc, char *argv[]) <br>{ <br> <br>  HANDLE               hProcess; <br>  HANDLE               hAccessToken; <br>  #define         DEFAULT_FILE_TO_CHECK "\\\\.\\A:" <br>  #define                   SZ_NAME_BUF MAX_PATH <br>  UCHAR           ucPathBuf[SZ_NAME_BUF]; <br>  LPTSTR          lpszFullName = (LPTSTR)&amp;ucPathBuf; <br>  #define                           SZ_SD_BUF 8096 <br>  UCHAR                ucBuf       [SZ_SD_BUF] = ""; <br>  DWORD                dwSDLength = SZ_SD_BUF; <br>  DWORD                dwSDLengthNeeded; <br>  PSECURITY_DESCRIPTOR psdSD      = (PSECURITY_DESCRIPTOR)&amp;ucBuf; <br>  DWORD                dwErrorMode; <br> <br> // check if running on Windows NT, if not, display notice and terminate <br> <br>    if( GetVersion() &amp; 0x80000000 ) <br>    { <br>      MessageBox( NULL, <br>         "This sample application can only be run on Windows NT.\n" <br>         "This application will now terminate.", <br>         "CheckSD", <br>         MB_OK | MB_ICONSTOP | MB_SETFOREGROUND ); <br>      return( 1 ); <br>    } <br> <br>  /**************************************************************************\ <br>  * <br>  * This sample is not inside a Win32 service, however if this code were to be <br>  *   moved inside a Win32 service, the following defines and code that <br>  *   redirects stdout will be handy, because services cannot write to the <br>  *   screen <br>  * <br>  * You may wish to choose a different file name for the output file if you <br>  *   use this mechanism - note that the "w+" will destroy an existing file! <br>  * <br>  \**************************************************************************/ <br> <br>  #define WE_ARE_IN_A_SERVICE_SO_REDIRECT_STDOUT (0==1) <br>  #define   FILE_TO_REDIRECT_STDOUT_TO "c:\\check_sd.out" <br> <br>  if     (WE_ARE_IN_A_SERVICE_SO_REDIRECT_STDOUT) <br>  { freopen(FILE_TO_REDIRECT_STDOUT_TO,"w+",stdout); <br>  } <br> <br> <br>  if      (1 == argc) <br>  { strcpy(lpszFullName,DEFAULT_FILE_TO_CHECK); <br>  } <br>  else if (2 == argc) <br>  { strcpy(lpszFullName,argv[1]); <br>  } <br>  else <br>  { DisplayHelp(); <br>    return(0); <br>  } <br> <br>  /**************************************************************************\ <br>  * <br>  * Set up the well-known SID(s) in global variables, and enable the privilege <br>  *   needed in the access token to work with SACL(s) <br>  * <br>  \**************************************************************************/ <br> <br>  InitializeWellKnownSIDs(); <br> <br>  if (!SetPrivilegeInAccessToken()) <br>  { return(1); <br>  } <br> <br>  /**************************************************************************\ <br>  * <br>  * This sample's primary purpose is to explore Security Descriptors. <br>  *   However, it is all too easy to over-focus on SD(s), while losing insight <br>  *   of the importance of Access Tokens.  So, we will now digress briefly to <br>  *   examine the access token of the current process <br>  * <br>  \**************************************************************************/ <br> <br>  hProcess = GetCurrentProcess(); <br>  if (!hProcess) <br>  { PERR("GetCurrentProcess"); <br>    return(1); <br>  } <br> <br>  if (!OpenProcessToken(hProcess, <br>                        (TOKEN_READ | TOKEN_QUERY_SOURCE), <br>                        &amp;hAccessToken)) <br>  { PERR("OpenProcessToken"); <br>    return(1); <br>  } <br> <br>  ExamineAccessToken(hAccessToken); <br> <br>  /**************************************************************************\ <br>  * <br>  * Back to examining SD(s) <br>  * <br>  \**************************************************************************/ <br> <br>  printf("\nChecking SD on %s",lpszFullName); <br> <br>  /**************************************************************************\ <br>  * <br>  * SetErrorMode so we don't get the error due to no floppy disk in the floppy <br>  *   drive <br>  * <br>  \**************************************************************************/ <br> <br>  dwErrorMode = SetErrorMode(SEM_FAILCRITICALERRORS); <br> <br>  if (!GetFileSecurity <br>        (lpszFullName, <br>         (SECURITY_INFORMATION)( OWNER_SECURITY_INFORMATION <br>                               | GROUP_SECURITY_INFORMATION <br>                               | DACL_SECURITY_INFORMATION <br>                               | SACL_SECURITY_INFORMATION), <br>         psdSD, <br>         dwSDLength, <br>         (LPDWORD)&amp;dwSDLengthNeeded)) <br>  { PERR("GetFileSecurity"); <br>    return(1); <br>  } <br> <br>  SetErrorMode(dwErrorMode); <br> <br>  if(!ExamineSD(psdSD,FileAccessMask)) <br>  { PERR("ExamineSD failed"); <br>    return(1); <br>  } <br> <br>  /**************************************************************************\ <br>  * <br>  * The above code showed how to examine an SD on a file.  There are SDs on <br>  *   other objects that could be examined by the function ExamineSD (and the <br>  *   other functions it calls).  The following are one example call each of <br>  *   the other four api's that are used to retrieve the SD from each of the <br>  *   types of Win32 objects that can have an SD <br>  * <br>  * These calls will execute properly without any work on your part, however, <br>  *   some work on your part will be required to get the sample calls below to <br>  *   show the SD for the objects your program uses!  You would need to make <br>  *   copy of this sample in a new directory, and write the code to get a <br>  *   handle to the object you're interested in, so you can pass that handle <br>  *   to the applicable api call below <br>  * <br>  * To insert the SD checking code into your own code you would do <br>  *   something like <br>  * <br>  * 1) Add the global variables above in your globals <br>  * <br>  * 2) Add the function prototypes above in your globals <br>  * <br>  * 3) Add the includes and PERR/PMSG macroes above to your code <br>  * <br>  * 4) Add all the functions defined below (except DisplayHelp and except <br>  *   ExamineAccessToken) to your code <br>  * <br>  * 5) Add a call sequence such as that in main() above that gets an <br>  *   SD and passes it to Examine SD.  Or add a call sequence such as <br>  *   one of those that follows that gets a handle, gets the SD on the <br>  *   object the handle addresses, then calls ExamineSD <br>  * <br>  * 6) If you are examining a type SD not already listed in <br>  *   KINDS_OF_ACCESSMASKS_DECODED, then you will have to add the new type to <br>  *   KINDS_OF_ACCESSMASKS_DECODED, and add to ExamineMask() the necessary <br>  *   code to crack that type of SD's access mask bits into the defines <br>  * <br>  \**************************************************************************/ <br> <br>  #define I_DO_NOT_WANT_THIS_CODE_TO_CLUTTER_THIS_PROGRAM_S_OUTPUT (0==0) <br> <br>  if    (!I_DO_NOT_WANT_THIS_CODE_TO_CLUTTER_THIS_PROGRAM_S_OUTPUT) <br>  { HANDLE    hProcess; <br>    HANDLE    hWindowStation; <br>    HDESK     hDesktop; <br>    HKEY      hKey; <br>    SC_HANDLE schService; <br>    SC_HANDLE schSCManager; <br>    SECURITY_INFORMATION siSInfo = <br>         (SECURITY_INFORMATION)( OWNER_SECURITY_INFORMATION <br>                               | GROUP_SECURITY_INFORMATION <br>                               | DACL_SECURITY_INFORMATION); <br> <br>    printf("\n\nChecking SD on current process"); <br> <br>    hProcess = GetCurrentProcess(); <br>    if (!hProcess) <br>    { PERR("GetCurrentProcess"); <br>      return(1); <br>    } <br> <br>    dwSDLength = SZ_SD_BUF; <br> <br>    if (!GetKernelObjectSecurity <br>          (hProcess, <br>           (SECURITY_INFORMATION)( OWNER_SECURITY_INFORMATION <br>                                 | GROUP_SECURITY_INFORMATION <br>                                 | DACL_SECURITY_INFORMATION), <br>           psdSD, <br>           dwSDLength, <br>           (LPDWORD)&amp;dwSDLengthNeeded)) <br>    { PERR("GetKernelObjectSecurity"); <br>      return(1); <br>    } <br> <br>    /************************************************************************\ <br>    * <br>    * It is important to close all handles as soon as your code no longer <br>    *   needs them.  This conserves system resources.  In a sample such as <br>    *   this one, the practical effect is close to nil, since as soon as the <br>    *   sample exits (which only takes a few seconds, Windows NT destroys the <br>    *   process this sample was running in, which reclaims all resources <br>    * <br>    * However, in a program that creates many objects (such as threads), or <br>    *   where that program will be running for a long time, closing handles as <br>    *   soon as the program no longer needs them can save significant <br>    *   resources <br>    * <br>    * It is a good coding practice to make a habit of closing handles as soon <br>    *   as your code no longer needs the handle <br>    * <br>    \************************************************************************/ <br> <br>    CloseHandle(hProcess); <br> <br>    if(!ExamineSD(psdSD,ProcessAccessMask)) <br>    { PERR("ExamineSD failed"); <br>      return(1); <br>    } <br> <br> <br>    printf("\n\nChecking SD on current Windowstation"); <br> <br>    hWindowStation = GetProcessWindowStation(); <br>    if (INVALID_HANDLE_VALUE == hWindowStation) <br>    { PERR("GetProcessWindowStation"); <br>      return(1); <br>    } <br> <br>    dwSDLength = SZ_SD_BUF; <br> <br>    if (!GetUserObjectSecurity <br>          (hWindowStation, <br>           &amp;siSInfo, <br>           psdSD, <br>           dwSDLength, <br>           (LPDWORD)&amp;dwSDLengthNeeded)) <br>    { PERR("GetUserObjectSecurity"); <br>      return(1); <br>    } <br> <br>    CloseHandle(hWindowStation); <br> <br>    if(!ExamineSD(psdSD,WindowStationAccessMask)) <br>    { PERR("ExamineSD failed"); <br>      return(1); <br>    } <br> <br>    printf("\n\nChecking SD on current Desktop"); <br> <br>    hDesktop = GetThreadDesktop(GetCurrentThreadId()); <br>    if (INVALID_HANDLE_VALUE == hDesktop) <br>    { PERR("GetThreadDesktop"); <br>      return(1); <br>    } <br> <br>    dwSDLength = SZ_SD_BUF; <br> <br>    if (!GetUserObjectSecurity <br>          (hDesktop, <br>           &amp;siSInfo, <br>           psdSD, <br>           dwSDLength, <br>           (LPDWORD)&amp;dwSDLengthNeeded)) <br>    { PERR("GetUserObjectSecurity"); <br>      return(1); <br>    } <br> <br>    CloseHandle(hDesktop); <br> <br>    if(!ExamineSD(psdSD,DesktopAccessMask)) <br>    { PERR("ExamineSD failed"); <br>      return(1); <br>    } <br> <br> <br>    printf("\n\nChecking SD on registry key HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet"); <br> <br>    if (ERROR_SUCCESS != RegOpenKeyEx(HKEY_LOCAL_MACHINE, <br>                                      "SYSTEM\\CurrentControlSet", <br>                                      0, <br>                                      KEY_READ, <br>                                      &amp;hKey)) <br>    { PERR("RegOpenKeyEx"); <br>      return(1); <br>    } <br> <br>    dwSDLength = SZ_SD_BUF; <br> <br>    if (ERROR_SUCCESS != RegGetKeySecurity <br>          (hKey, <br>           (SECURITY_INFORMATION)( OWNER_SECURITY_INFORMATION <br>                                 | GROUP_SECURITY_INFORMATION <br>                                 | DACL_SECURITY_INFORMATION), <br>           psdSD, <br>           &amp;dwSDLength)) <br>    { PERR("RegGetKeySecurity"); <br>      return(1); <br>    } <br> <br>    RegCloseKey(hKey); <br> <br>    if(!ExamineSD(psdSD,RegKeyAccessMask)) <br>    { PERR("ExamineSD failed"); <br>      return(1); <br>    } <br> <br> <br>    /************************************************************************\ <br>    * <br>    * Any service will do here, just be sure to pick one that is in the <br>    *   Service Control Manager's database, and use the service name, not the <br>    *   service's display name.  For example, ClipSrv is displayed as Clipbook <br>    *   in the Services Control Panel applet <br>    * <br>    \************************************************************************/ <br> <br>    printf("\n\nChecking SD on service Clipbook"); <br> <br>    schSCManager = OpenSCManager( <br>                        NULL,                 // machine (NULL == local) <br>                        NULL,                 // database (NULL == default) <br>                        SC_MANAGER_ALL_ACCESS // access required <br>                        ); <br> <br>    if (!schSCManager) <br>    { PERR("OpenSCManager"); <br>      return(1); <br>    } <br> <br>    schService = OpenService(schSCManager,"ClipSrv",SERVICE_ALL_ACCESS); <br>    if (!schService) <br>    { PERR("OpenService"); <br>      return(1); <br>    } <br> <br>    CloseServiceHandle(schSCManager); <br> <br>    dwSDLength = SZ_SD_BUF; <br> <br>    if (!QueryServiceObjectSecurity <br>          (schService, <br>           (SECURITY_INFORMATION)( OWNER_SECURITY_INFORMATION <br>                                 | GROUP_SECURITY_INFORMATION <br>                                 | DACL_SECURITY_INFORMATION), <br>           psdSD, <br>           dwSDLength, <br>           (LPDWORD)&amp;dwSDLengthNeeded)) <br>    { PERR("QueryServiceObjectSecurity"); <br>      return(1); <br>    } <br> <br>    CloseServiceHandle(schService); <br> <br>    if(!ExamineSD(psdSD,ServiceAccessMask)) <br>    { PERR("ExamineSD failed"); <br>      return(1); <br>    } <br>  } <br> <br>  return(0); <br>} <br>  <br>/****************************************************************************\ <br>* <br>* FUNCTION: ExamineSD <br>* <br>\****************************************************************************/ <br> <br>BOOL ExamineSD    (PSECURITY_DESCRIPTOR psdSD, <br>                   KINDS_OF_ACCESSMASKS_DECODED kamKindOfMask) <br>{ <br> <br>  PACL                        paclDACL; <br>  PACL                        paclSACL; <br>  BOOL                        bHasDACL        = FALSE; <br>  BOOL                        bHasSACL        = FALSE; <br>  BOOL                        bDaclDefaulted  = FALSE; <br>  BOOL                        bSaclDefaulted  = FALSE; <br>  BOOL                        bOwnerDefaulted = FALSE; <br>  BOOL                        bGroupDefaulted = FALSE; <br>  PSID                        psidOwner; <br>  PSID                        psidGroup; <br>  SECURITY_DESCRIPTOR_CONTROL sdcSDControl; <br>  DWORD                       dwSDRevision; <br>  DWORD                       dwSDLength; <br> <br>  if (!IsValidSecurityDescriptor(psdSD)) <br>  { PERR("IsValidSecurityDescriptor"); <br>    return(FALSE); <br>  } <br> <br>  dwSDLength = GetSecurityDescriptorLength(psdSD); <br> <br>  if (!GetSecurityDescriptorDacl(psdSD, <br>                                 (LPBOOL)&amp;bHasDACL, <br>                                 (PACL *)&amp;paclDACL, <br>                                 (LPBOOL)&amp;bDaclDefaulted)) <br>  { PERR("GetSecurityDescriptorDacl"); <br>    return(FALSE); <br>  } <br> <br>  if (!GetSecurityDescriptorSacl(psdSD, <br>                                 (LPBOOL)&amp;bHasSACL, <br>                                 (PACL *)&amp;paclSACL, <br>                                 (LPBOOL)&amp;bSaclDefaulted)) <br>  { PERR("GetSecurityDescriptorSacl"); <br>    return(FALSE); <br>  } <br> <br>  if (!GetSecurityDescriptorOwner(psdSD, <br>                                  (PSID *)&amp;psidOwner, <br>                                  (LPBOOL)&amp;bOwnerDefaulted)) <br>  { PERR("GetSecurityDescriptorOwner"); <br>    return(FALSE); <br>  } <br> <br>  if (!GetSecurityDescriptorGroup(psdSD, <br>                                  (PSID *)&amp;psidGroup, <br>                                  (LPBOOL)&amp;bGroupDefaulted)) <br>  { PERR("GetSecurityDescriptorGroup"); <br>    return(FALSE); <br>  } <br> <br>  if (!GetSecurityDescriptorControl(psdSD, <br>                                    (PSECURITY_DESCRIPTOR_CONTROL)&amp;sdcSDControl, <br>                                    (LPDWORD)&amp;dwSDRevision)) <br>  { PERR("GetSecurityDescriptorControl"); <br>    return(FALSE); <br>  } <br> <br>  printf("\nSD is valid.  SD is %d bytes long.  SD revision is %d == ",dwSDLength,dwSDRevision); <br> <br>  switch (dwSDRevision) <br>  { <br>    case      SECURITY_DESCRIPTOR_REVISION1 : <br>    { printf("SECURITY_DESCRIPTOR_REVISION1"); <br>      break; <br>    } <br>    default : <br>    { printf("! SD Revision is an IMPOSSIBLE SD revision!!! Perhaps a new revision was added..."); <br>      return(FALSE); <br>    } <br>  } <br> <br>  if (SE_SELF_RELATIVE &amp; sdcSDControl) <br>    printf("\nSD is in self-relative format (all SDs returned by the system are)"); <br> <br>  if (NULL == psidOwner) <br>  { printf("\nSD's Owner is NULL, so SE_OWNER_DEFAULTED is ignored"); <br>  } <br>  else <br>  { printf("\nSD's Owner is Not NULL"); <br>    if (bOwnerDefaulted ) <br>    { printf("\nSD's Owner-Defaulted flag is TRUE"); <br>    } <br>    else <br>    { printf("\nSD's Owner-Defaulted flag is FALSE"); <br>    } <br>    if(!LookupSIDName(psidOwner,"")) <br>    { PERR("LookupSIDName failed"); <br>    } <br>  } <br> <br>  /**************************************************************************\ <br>  * <br>  * The other use for psidGroup is for Macintosh client support <br>  * <br>  \**************************************************************************/ <br> <br>  if (NULL == psidGroup) <br>  { printf("\nSD's Group is NULL, so SE_GROUP_DEFAULTED is ignored"); <br>    printf("\nSD's Group being NULL is typical, GROUP in SD(s) is mainly for POSIX compliance"); <br>  } <br>  else <br>  { if (bGroupDefaulted) <br>    { printf("\nSD's Group-Defaulted flag is TRUE"); <br>    } <br>    else <br>    { printf("\nSD's Group-Defaulted flag is FALSE"); <br>    } <br>    if(!LookupSIDName(psidGroup,"")) <br>    { PERR("LookupSIDName failed"); <br>    } <br>  } <br> <br>  if   (SE_DACL_PRESENT &amp; sdcSDControl) <br>  { printf("\nSD's DACL is Present"); <br>    if (bDaclDefaulted) <br>    { printf("\nSD's DACL-Defaulted flag is TRUE"); <br>    } <br>    else <br>    { printf("\nSD's DACL-Defaulted flag is FALSE"); <br>    } <br> <br>    if (NULL == paclDACL) <br>    { printf("\nSD has a NULL DACL explicitly specified      (allows all access to Everyone)"); <br>      printf("\n    This does not apply to this SD, but for comparison,"); <br>      printf("\n    a non-NULL DACL pointer to a 0-length ACL allows  no access to   anyone"); <br>    } <br>    else if(!ExamineACL(paclDACL,"",kamKindOfMask)) <br>    {  PERR("ExamineACL failed"); <br>    } <br>  } <br>  else <br>  { printf("\nSD's DACL is Not Present, so SE_DACL_DEFAULTED is ignored"); <br>    printf("\nSD has no DACL at all (allows all access to Everyone)"); <br>  } <br> <br>  if   (SE_SACL_PRESENT &amp; sdcSDControl) <br>  { printf("\nSD's SACL is Present"); <br>    if (bSaclDefaulted) <br>    { printf("\nSD's SACL-Defaulted flag is TRUE"); <br>    } <br>    else <br>    { printf("\nSD's SACL-Defaulted flag is FALSE"); <br>    } <br> <br>    if (NULL == paclSACL) <br>    { printf("\nSD has a NULL SACL explicitly specified"); <br>    } <br>    else if(!ExamineACL(paclSACL,"",kamKindOfMask)) <br>    {  PERR("ExamineACL failed"); <br>    } <br>  } <br>  else <br>  { printf("\nSD's SACL is Not Present, so SE_SACL_DEFAULTED is ignored"); <br>    printf("\nSD has no SACL at all (or we did not request to see it)"); <br>  } <br>} <br>  <br>/****************************************************************************\ <br>* <br>* FUNCTION: ExamineACL <br>* <br>\****************************************************************************/ <br> <br>BOOL ExamineACL   (PACL paclACL,              LPTSTR lpszOldIndent, <br>                   KINDS_OF_ACCESSMASKS_DECODED kamKindOfMask) <br>{ <br>  #define                          SZ_INDENT_BUF 80 <br>  UCHAR                ucIndentBuf[SZ_INDENT_BUF] = ""; <br>  ACL_SIZE_INFORMATION                      asiAclSize; <br>  ACL_REVISION_INFORMATION                  ariAclRevision; <br>  DWORD                dwBufLength; <br>  DWORD                dwAcl_i; <br>  ACCESS_ALLOWED_ACE   *paaAllowedAce; <br> <br>  strcpy(ucIndentBuf,lpszOldIndent); <br>  strcat(ucIndentBuf,"  "); <br> <br>  if (!IsValidAcl(paclACL)) <br>  { PERR("IsValidAcl"); <br>    return(FALSE); <br>  } <br> <br>  dwBufLength = sizeof(asiAclSize); <br> <br>  if (!GetAclInformation(paclACL, <br>                         (LPVOID)&amp;asiAclSize, <br>                         (DWORD)dwBufLength, <br>                         (ACL_INFORMATION_CLASS)AclSizeInformation)) <br>  { PERR("GetAclInformation"); <br>    return(FALSE); <br>  } <br> <br>  dwBufLength = sizeof(ariAclRevision); <br> <br>  if (!GetAclInformation(paclACL, <br>                         (LPVOID)&amp;ariAclRevision, <br>                         (DWORD)dwBufLength, <br>                         (ACL_INFORMATION_CLASS)AclRevisionInformation)) <br>  { PERR("GetAclInformation"); <br>    return(FALSE); <br>  } <br> <br>  printf("\n%sACL has %d ACE(s), %d bytes used, %d bytes free",ucIndentBuf, <br>     asiAclSize.AceCount, <br>     asiAclSize.AclBytesInUse, <br>     asiAclSize.AclBytesFree); <br> <br>  printf("\n%sACL revision is %d == ",ucIndentBuf,ariAclRevision.AclRevision); <br> <br>  switch (ariAclRevision.AclRevision) <br>  { <br>    case      ACL_REVISION1 : <br>    { printf("ACL_REVISION1"); <br>      break; <br>    } <br>    case      ACL_REVISION2 : <br>    { printf("ACL_REVISION2"); <br>      break; <br>    } <br>    default : <br>    { printf("\n%sACL Revision is an IMPOSSIBLE ACL revision!!! Perhaps a new revision was added...",ucIndentBuf); <br>      return(FALSE); <br>    } <br>  } <br> <br>  for (dwAcl_i = 0; dwAcl_i &lt; asiAclSize.AceCount;  dwAcl_i++) <br>  { <br>    if (!GetAce(paclACL, <br>                dwAcl_i, <br>                (LPVOID *)&amp;paaAllowedAce)) <br>    { PERR("GetAce"); <br>      return(FALSE); <br>    } <br> <br>    printf("\n%sACE %d size %d",ucIndentBuf,dwAcl_i,paaAllowedAce-&gt;Header.AceSize); <br> <br>    { DWORD dwAceFlags = paaAllowedAce-&gt;Header.AceFlags; <br> <br>      printf("\n%sACE %d flags 0x%.2x",ucIndentBuf,dwAcl_i,dwAceFlags); <br> <br>      if (dwAceFlags) <br>      { <br>        DWORD dwExtraBits; <br>        UCHAR ucIndentBitsBuf[SZ_INDENT_BUF] = ""; <br> <br>        strcpy(ucIndentBitsBuf,ucIndentBuf); <br>        strcat(ucIndentBitsBuf,"            "); <br> <br>        if ((dwAceFlags  &amp; OBJECT_INHERIT_ACE        ) == OBJECT_INHERIT_ACE        ) <br>        { printf("\n%s0x01 OBJECT_INHERIT_ACE        ",ucIndentBitsBuf); <br>        } <br>        if ((dwAceFlags  &amp; CONTAINER_INHERIT_ACE     ) == CONTAINER_INHERIT_ACE     ) <br>        { printf("\n%s0x02 CONTAINER_INHERIT_ACE     ",ucIndentBitsBuf); <br>        } <br>        if ((dwAceFlags  &amp; NO_PROPAGATE_INHERIT_ACE  ) == NO_PROPAGATE_INHERIT_ACE  ) <br>        { printf("\n%s0x04 NO_PROPAGATE_INHERIT_ACE  ",ucIndentBitsBuf); <br>        } <br>        if ((dwAceFlags  &amp; INHERIT_ONLY_ACE          ) == INHERIT_ONLY_ACE          ) <br>        { printf("\n%s0x08 INHERIT_ONLY_ACE          ",ucIndentBitsBuf); <br>        } <br>        if ((dwAceFlags  &amp; VALID_INHERIT_FLAGS       ) == VALID_INHERIT_FLAGS       ) <br>        { printf("\n%s0x0F VALID_INHERIT_FLAGS       ",ucIndentBitsBuf); <br>        } <br>        if ((dwAceFlags  &amp; SUCCESSFUL_ACCESS_ACE_FLAG) == SUCCESSFUL_ACCESS_ACE_FLAG) <br>        { printf("\n%s0x40 SUCCESSFUL_ACCESS_ACE_FLAG",ucIndentBitsBuf); <br>        } <br>        if ((dwAceFlags  &amp; FAILED_ACCESS_ACE_FLAG    ) == FAILED_ACCESS_ACE_FLAG    ) <br>        { printf("\n%s0x80 FAILED_ACCESS_ACE_FLAG    ",ucIndentBitsBuf); <br>        } <br> <br>        dwExtraBits = dwAceFlags &amp; ( ~( OBJECT_INHERIT_ACE <br>                                      | CONTAINER_INHERIT_ACE <br>                                      | NO_PROPAGATE_INHERIT_ACE <br>                                      | INHERIT_ONLY_ACE <br>                                      | VALID_INHERIT_FLAGS <br>                                      | SUCCESSFUL_ACCESS_ACE_FLAG <br>                                      | FAILED_ACCESS_ACE_FLAG) ); <br>        if (dwExtraBits) <br>        { printf("\n%sExtra AceFlag bits     == 0x%.8x &lt;-This is a problem, should be all 0s",ucIndentBuf,dwExtraBits); <br>        } <br>      } <br>    } <br> <br>    switch (paaAllowedAce-&gt;Header.AceType) <br>    { <br>      case                       ACCESS_ALLOWED_ACE_TYPE : <br>      { printf("\n%sACE %d is an ACCESS_ALLOWED_ACE_TYPE",ucIndentBuf,dwAcl_i); <br>        break; <br>      } <br>      case                       ACCESS_DENIED_ACE_TYPE : <br>      { printf("\n%sACE %d is an ACCESS_DENIED_ACE_TYPE",ucIndentBuf,dwAcl_i); <br>        break; <br>      } <br>      case                       SYSTEM_AUDIT_ACE_TYPE : <br>      { printf("\n%sACE %d is a  SYSTEM_AUDIT_ACE_TYPE",ucIndentBuf,dwAcl_i); <br>        break; <br>      } <br>      case                       SYSTEM_ALARM_ACE_TYPE : <br>      { printf("\n%sACE %d is a  SYSTEM_ALARM_ACE_TYPE",ucIndentBuf,dwAcl_i); <br>        break; <br>      } <br>      default : <br>      { printf("\n%sACE %d is an IMPOSSIBLE ACE_TYPE!!! Run debugger, examine value!",ucIndentBuf,dwAcl_i); <br>        return(FALSE); <br>      } <br>    } <br> <br>    printf("\n%sACE %d mask               == 0x%.8x",ucIndentBuf,dwAcl_i,paaAllowedAce-&gt;Mask); <br> <br>    ExamineMask(paaAllowedAce-&gt;Mask,ucIndentBuf,kamKindOfMask); <br> <br>    if(!LookupSIDName((PSID)&amp;(paaAllowedAce-&gt;SidStart),ucIndentBuf)) <br>    { PERR("LookupSIDName failed"); <br>    } <br>  } <br>} <br>  <br>/****************************************************************************\ <br>* <br>* FUNCTION: ExamineMask <br>* <br>\****************************************************************************/ <br> <br>VOID ExamineMask  (ACCESS_MASK amMask,        LPTSTR lpszOldIndent, <br>                   KINDS_OF_ACCESSMASKS_DECODED kamKindOfMask) <br>{ <br>  #define STANDARD_RIGHTS_ALL_THE_BITS 0x00FF0000L <br>  #define GENERIC_RIGHTS_ALL_THE_BITS  0xF0000000L <br>  UCHAR ucIndentBuf[SZ_INDENT_BUF]     = ""; <br>  UCHAR ucIndentBitsBuf[SZ_INDENT_BUF] = ""; <br>  DWORD dwGenericBits; <br>  DWORD dwStandardBits; <br>  DWORD dwSpecificBits; <br>  DWORD dwAccessSystemSecurityBit; <br>  DWORD dwExtraBits; <br> <br>  strcpy(ucIndentBuf,    lpszOldIndent); <br>  strcat(ucIndentBuf,    "  "); </code></pre>
<p>
</p>
<pre><code>strcpy(ucIndentBitsBuf,lpszOldIndent); <br>  strcat(ucIndentBitsBuf,"                            "); <br> <br>  dwStandardBits            = (amMask &amp; STANDARD_RIGHTS_ALL_THE_BITS); <br>  dwSpecificBits            = (amMask &amp; SPECIFIC_RIGHTS_ALL         ); <br>  dwAccessSystemSecurityBit = (amMask &amp; ACCESS_SYSTEM_SECURITY      ); <br>  dwGenericBits             = (amMask &amp; GENERIC_RIGHTS_ALL_THE_BITS ); <br> <br>  /**************************************************************************\ <br>  * <br>  * Print then decode the standard rights bits <br>  * <br>  \**************************************************************************/ <br> <br>  printf("\n%sStandard Rights        == 0x%.8x",ucIndentBuf,dwStandardBits); <br> <br>  if (dwStandardBits) <br>  { <br>    if ((dwStandardBits    &amp; DELETE                  ) == DELETE                  ) <br>    { printf("\n%s0x00010000 DELETE                  ",ucIndentBitsBuf); <br>    } <br>    if ((dwStandardBits    &amp; READ_CONTROL            ) == READ_CONTROL            ) <br>    { printf("\n%s0x00020000 READ_CONTROL            ",ucIndentBitsBuf); <br>    } <br>    if ((dwStandardBits    &amp; STANDARD_RIGHTS_READ    ) == STANDARD_RIGHTS_READ    ) <br>    { printf("\n%s0x00020000 STANDARD_RIGHTS_READ    ",ucIndentBitsBuf); <br>    } <br>    if ((dwStandardBits    &amp; STANDARD_RIGHTS_WRITE   ) == STANDARD_RIGHTS_WRITE   ) <br>    { printf("\n%s0x00020000 STANDARD_RIGHTS_WRITE   ",ucIndentBitsBuf); <br>    } <br>    if ((dwStandardBits    &amp; STANDARD_RIGHTS_EXECUTE ) == STANDARD_RIGHTS_EXECUTE ) <br>    { printf("\n%s0x00020000 STANDARD_RIGHTS_EXECUTE ",ucIndentBitsBuf); <br>    } <br>    if ((dwStandardBits    &amp; WRITE_DAC               ) == WRITE_DAC               ) <br>    { printf("\n%s0x00040000 WRITE_DAC               ",ucIndentBitsBuf); <br>    } <br>    if ((dwStandardBits    &amp; WRITE_OWNER             ) == WRITE_OWNER             ) <br>    { printf("\n%s0x00080000 WRITE_OWNER             ",ucIndentBitsBuf); <br>    } <br>    if ((dwStandardBits    &amp; SYNCHRONIZE             ) == SYNCHRONIZE             ) <br>    { printf("\n%s0x00100000 SYNCHRONIZE             ",ucIndentBitsBuf); <br>    } <br>    if ((dwStandardBits    &amp; STANDARD_RIGHTS_REQUIRED) == STANDARD_RIGHTS_REQUIRED) <br>    { printf("\n%s0x000F0000 STANDARD_RIGHTS_REQUIRED",ucIndentBitsBuf); <br>    } <br>    if ((dwStandardBits    &amp; STANDARD_RIGHTS_ALL     ) == STANDARD_RIGHTS_ALL     ) <br>    { printf("\n%s0x001F0000 STANDARD_RIGHTS_ALL     ",ucIndentBitsBuf); <br>    } <br> <br>    dwExtraBits = dwStandardBits &amp; ( ~( DELETE <br>                                      | READ_CONTROL <br>                                      | STANDARD_RIGHTS_READ <br>                                      | STANDARD_RIGHTS_WRITE <br>                                      | STANDARD_RIGHTS_EXECUTE <br>                                      | WRITE_DAC <br>                                      | WRITE_OWNER <br>                                      | SYNCHRONIZE <br>                                      | STANDARD_RIGHTS_REQUIRED <br>                                      | STANDARD_RIGHTS_ALL) ); <br>    if (dwExtraBits) <br>    { printf("\n%sExtra standard bits    == 0x%.8x &lt;-This is a problem, should be all 0s",ucIndentBuf,dwExtraBits); <br>    } <br>  } <br> <br>  /**************************************************************************\ <br>  * <br>  * Print then decode the specific rights bits <br>  * <br>  \**************************************************************************/ <br> <br>  printf("\n%sSpecific Rights        == 0x%.8x",ucIndentBuf,dwSpecificBits); <br> <br>  if (dwSpecificBits) <br>  { <br>    if      (FileAccessMask          == kamKindOfMask) <br>    { <br>      if ((dwSpecificBits    &amp; FILE_READ_DATA           ) == FILE_READ_DATA           ) <br>      { printf("\n%s0x00000001 FILE_READ_DATA            (file &amp; pipe)     ",ucIndentBitsBuf); <br>      } <br>      if ((dwSpecificBits    &amp; FILE_LIST_DIRECTORY      ) == FILE_LIST_DIRECTORY      ) <br>      { printf("\n%s0x00000001 FILE_LIST_DIRECTORY       (directory)       ",ucIndentBitsBuf); <br>      } <br>      if ((dwSpecificBits    &amp; FILE_WRITE_DATA          ) == FILE_WRITE_DATA          ) <br>      { printf("\n%s0x00000002 FILE_WRITE_DATA           (file &amp; pipe)     ",ucIndentBitsBuf); <br>      } <br>      if ((dwSpecificBits    &amp; FILE_ADD_FILE            ) == FILE_ADD_FILE            ) <br>      { printf("\n%s0x00000002 FILE_ADD_FILE             (directory)       ",ucIndentBitsBuf); <br>      } <br>      if ((dwSpecificBits    &amp; FILE_APPEND_DATA         ) == FILE_APPEND_DATA         ) <br>      { printf("\n%s0x00000004 FILE_APPEND_DATA          (file)            ",ucIndentBitsBuf); <br>      } <br>      if ((dwSpecificBits    &amp; FILE_ADD_SUBDIRECTORY    ) == FILE_ADD_SUBDIRECTORY    ) <br>      { printf("\n%s0x00000004 FILE_ADD_SUBDIRECTORY     (directory)       ",ucIndentBitsBuf); <br>      } <br>      if ((dwSpecificBits    &amp; FILE_CREATE_PIPE_INSTANCE) == FILE_CREATE_PIPE_INSTANCE) <br>      { printf("\n%s0x00000004 FILE_CREATE_PIPE_INSTANCE (named pipe)      ",ucIndentBitsBuf); <br>      } <br>      if ((dwSpecificBits    &amp; FILE_READ_EA             ) == FILE_READ_EA             ) <br>      { printf("\n%s0x00000008 FILE_READ_EA              (file &amp; directory)",ucIndentBitsBuf); <br>      } <br>      if ((dwSpecificBits    &amp; FILE_WRITE_EA            ) == FILE_WRITE_EA            ) <br>      { printf("\n%s0x00000010 FILE_WRITE_EA             (file &amp; directory)",ucIndentBitsBuf); <br>      } <br>      if ((dwSpecificBits    &amp; FILE_EXECUTE             ) == FILE_EXECUTE             ) <br>      { printf("\n%s0x00000020 FILE_EXECUTE              (file)            ",ucIndentBitsBuf); <br>      } <br>      if ((dwSpecificBits    &amp; FILE_TRAVERSE            ) == FILE_TRAVERSE            ) <br>      { printf("\n%s0x00000020 FILE_TRAVERSE             (directory)       ",ucIndentBitsBuf); <br>      } <br>      if ((dwSpecificBits    &amp; FILE_DELETE_CHILD        ) == FILE_DELETE_CHILD        ) <br>      { printf("\n%s0x00000040 FILE_DELETE_CHILD         (directory)       ",ucIndentBitsBuf); <br>      } <br>      if ((dwSpecificBits    &amp; FILE_READ_ATTRIBUTES     ) == FILE_READ_ATTRIBUTES     ) <br>      { printf("\n%s0x00000080 FILE_READ_ATTRIBUTES      (all)             ",ucIndentBitsBuf); <br>      } <br>      if ((dwSpecificBits    &amp; FILE_WRITE_ATTRIBUTES    ) == FILE_WRITE_ATTRIBUTES    ) <br>      { printf("\n%s0x00000100 FILE_WRITE_ATTRIBUTES     (all)             ",ucIndentBitsBuf); <br>      } <br> <br>      if (((dwStandardBits | dwSpecificBits   ) <br>           &amp; FILE_ALL_ACCESS     ) == FILE_ALL_ACCESS     ) <br>      { printf("\n%s0x001F01FF FILE_ALL_ACCESS      == (STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | 0x1FF)",ucIndentBitsBuf); <br>      } <br>      if (((dwStandardBits | dwSpecificBits   ) <br>           &amp; FILE_GENERIC_READ   ) == FILE_GENERIC_READ   ) <br>      { printf("\n%s0x00120089 FILE_GENERIC_READ    == (STANDARD_RIGHTS_READ | FILE_READ_DATA | FILE_READ_ATTRIBUTES | FILE_READ_EA | SYNCHRONIZE)",ucIndentBitsBuf); <br>      } <br>      if (((dwStandardBits | dwSpecificBits   ) <br>           &amp; FILE_GENERIC_WRITE  ) == FILE_GENERIC_WRITE  ) <br>      { printf("\n%s0x00120116 FILE_GENERIC_WRITE   == (STANDARD_RIGHTS_WRITE | FILE_WRITE_DATA | FILE_WRITE_ATTRIBUTES | FILE_WRITE_EA | FILE_APPEND_DATA | SYNCHRONIZE)",ucIndentBitsBuf); <br>      } <br>      if (((dwStandardBits | dwSpecificBits   ) <br>           &amp; FILE_GENERIC_EXECUTE) == FILE_GENERIC_EXECUTE) <br>      { printf("\n%s0x001200A0 FILE_GENERIC_EXECUTE == (STANDARD_RIGHTS_EXECUTE | FILE_READ_ATTRIBUTES | FILE_EXECUTE | SYNCHRONIZE)",ucIndentBitsBuf); <br>      } <br> <br>      dwExtraBits = dwSpecificBits &amp; ( ~( FILE_READ_DATA <br>                                        | FILE_LIST_DIRECTORY <br>                                        | FILE_WRITE_DATA <br>                                        | FILE_ADD_FILE <br>                                        | FILE_APPEND_DATA <br>                                        | FILE_ADD_SUBDIRECTORY <br>                                        | FILE_CREATE_PIPE_INSTANCE <br>                                        | FILE_READ_EA <br>                                        | FILE_WRITE_EA <br>                                        | FILE_EXECUTE <br>                                        | FILE_TRAVERSE <br>                                        | FILE_DELETE_CHILD <br>                                        | FILE_READ_ATTRIBUTES <br>                                        | FILE_WRITE_ATTRIBUTES <br>                                        | (FILE_ALL_ACCESS      &amp; SPECIFIC_RIGHTS_ALL) <br>                                        | (FILE_GENERIC_READ    &amp; SPECIFIC_RIGHTS_ALL) <br>                                        | (FILE_GENERIC_WRITE   &amp; SPECIFIC_RIGHTS_ALL) <br>                                        | (FILE_GENERIC_EXECUTE &amp; SPECIFIC_RIGHTS_ALL) ) ); <br>      if (dwExtraBits) <br>      { printf("\n%sExtra specific bits    == 0x%.8x &lt;-This is a problem, should be all 0s",ucIndentBuf,dwExtraBits); <br>      } <br>    } <br>    else if (ProcessAccessMask       == kamKindOfMask) <br>    { <br>      if ((dwSpecificBits    &amp; PROCESS_TERMINATE        ) == PROCESS_TERMINATE        ) <br>      { printf("\n%s0x00000001 PROCESS_TERMINATE        ",ucIndentBitsBuf); <br>      } <br>      if ((dwSpecificBits    &amp; PROCESS_CREATE_THREAD    ) == PROCESS_CREATE_THREAD    ) <br>      { printf("\n%s0x00000002 PROCESS_CREATE_THREAD    ",ucIndentBitsBuf); <br>      } <br>      if ((dwSpecificBits    &amp; PROCESS_VM_OPERATION     ) == PROCESS_VM_OPERATION     ) <br>      { printf("\n%s0x00000008 PROCESS_VM_OPERATION     ",ucIndentBitsBuf); <br>      } <br>      if ((dwSpecificBits    &amp; PROCESS_VM_READ          ) == PROCESS_VM_READ          ) <br>      { printf("\n%s0x00000010 PROCESS_VM_READ          ",ucIndentBitsBuf); <br>      } <br>      if ((dwSpecificBits    &amp; PROCESS_VM_WRITE         ) == PROCESS_VM_WRITE         ) <br>      { printf("\n%s0x00000020 PROCESS_VM_WRITE         ",ucIndentBitsBuf); <br>      } <br>      if ((dwSpecificBits    &amp; PROCESS_DUP_HANDLE       ) == PROCESS_DUP_HANDLE       ) <br>      { printf("\n%s0x00000040 PROCESS_DUP_HANDLE       ",ucIndentBitsBuf); <br>      } <br>      if ((dwSpecificBits    &amp; PROCESS_CREATE_PROCESS   ) == PROCESS_CREATE_PROCESS   ) <br>      { printf("\n%s0x00000080 PROCESS_CREATE_PROCESS   ",ucIndentBitsBuf); <br>      } <br>      if ((dwSpecificBits    &amp; PROCESS_SET_INFORMATION  ) == PROCESS_SET_INFORMATION  ) <br>      { printf("\n%s0x00000200 PROCESS_SET_INFORMATION  ",ucIndentBitsBuf); <br>      } <br>      if ((dwSpecificBits    &amp; PROCESS_QUERY_INFORMATION) == PROCESS_QUERY_INFORMATION) <br>      { printf("\n%s0x00000400 PROCESS_QUERY_INFORMATION",ucIndentBitsBuf); <br>      } <br> <br>      if (((dwStandardBits | dwSpecificBits ) <br>           &amp; PROCESS_ALL_ACCESS) == PROCESS_ALL_ACCESS) <br>      { printf("\n%s0x001F0FFF PROCESS_ALL_ACCESS == (STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | 0x00000FFF) ",ucIndentBitsBuf); <br>      } <br> <br>      dwExtraBits = dwSpecificBits &amp; ( ~( PROCESS_TERMINATE <br>                                        | PROCESS_CREATE_THREAD <br>                                        | PROCESS_VM_OPERATION <br>                                        | PROCESS_VM_READ <br>                                        | PROCESS_VM_WRITE <br>                                        | PROCESS_DUP_HANDLE <br>                                        | PROCESS_CREATE_PROCESS <br>                                        | PROCESS_SET_INFORMATION <br>                                        | PROCESS_QUERY_INFORMATION <br>                                        | (PROCESS_ALL_ACCESS &amp; SPECIFIC_RIGHTS_ALL) ) ); <br>      if (dwExtraBits) <br>      { printf("\n%sExtra specific bits    == 0x%.8x &lt;-This is a problem, should be all 0s",ucIndentBuf,dwExtraBits); <br>      } <br>    } <br>    else if (WindowStationAccessMask == kamKindOfMask) <br>    { <br>      if ((dwSpecificBits    &amp; WINSTA_ENUMDESKTOPS     ) == WINSTA_ENUMDESKTOPS     ) <br>      { printf("\n%s0x00000001 WINSTA_ENUMDESKTOPS     ",ucIndentBitsBuf); <br>      } <br>      if ((dwSpecificBits    &amp; WINSTA_READATTRIBUTES   ) == WINSTA_READATTRIBUTES   ) <br>      { printf("\n%s0x00000002 WINSTA_READATTRIBUTES   ",ucIndentBitsBuf); <br>      } <br>      if ((dwSpecificBits    &amp; WINSTA_ACCESSCLIPBOARD  ) == WINSTA_ACCESSCLIPBOARD  ) <br>      { printf("\n%s0x00000004 WINSTA_ACCESSCLIPBOARD  ",ucIndentBitsBuf); <br>      } <br>      if ((dwSpecificBits    &amp; WINSTA_CREATEDESKTOP    ) == WINSTA_CREATEDESKTOP    ) <br>      { printf("\n%s0x00000008 WINSTA_CREATEDESKTOP    ",ucIndentBitsBuf); <br>      } <br>      if ((dwSpecificBits    &amp; WINSTA_WRITEATTRIBUTES  ) == WINSTA_WRITEATTRIBUTES  ) <br>      { printf("\n%s0x00000010 WINSTA_WRITEATTRIBUTES  ",ucIndentBitsBuf); <br>      } <br>      if ((dwSpecificBits    &amp; WINSTA_ACCESSGLOBALATOMS) == WINSTA_ACCESSGLOBALATOMS) <br>      { printf("\n%s0x00000020 WINSTA_ACCESSGLOBALATOMS",ucIndentBitsBuf); <br>      } <br>      if ((dwSpecificBits    &amp; WINSTA_EXITWINDOWS      ) == WINSTA_EXITWINDOWS      ) <br>      { printf("\n%s0x00000040 WINSTA_EXITWINDOWS      ",ucIndentBitsBuf); <br>      } <br>      if ((dwSpecificBits    &amp; WINSTA_ENUMERATE        ) == WINSTA_ENUMERATE        ) <br>      { printf("\n%s0x00000100 WINSTA_ENUMERATE        ",ucIndentBitsBuf); <br>      } <br>      if ((dwSpecificBits    &amp; WINSTA_READSCREEN       ) == WINSTA_READSCREEN       ) <br>      { printf("\n%s0x00000200 WINSTA_READSCREEN       ",ucIndentBitsBuf); <br>      } <br> <br>      dwExtraBits = dwSpecificBits &amp; ( ~( WINSTA_ENUMDESKTOPS <br>                                        | WINSTA_READATTRIBUTES <br>                                        | WINSTA_ACCESSCLIPBOARD <br>                                        | WINSTA_CREATEDESKTOP <br>                                        | WINSTA_WRITEATTRIBUTES <br>                                        | WINSTA_ACCESSGLOBALATOMS <br>                                        | WINSTA_EXITWINDOWS <br>                                        | WINSTA_ENUMERATE <br>                                        | WINSTA_READSCREEN) ); <br>      if (dwExtraBits) <br>      { printf("\n%sExtra specific bits    == 0x%.8x &lt;-This is a problem, should be all 0s",ucIndentBuf,dwExtraBits); <br>      } <br>    } <br>    else if (DesktopAccessMask == kamKindOfMask) <br>    { <br>      if ((dwSpecificBits    &amp; DESKTOP_READOBJECTS     ) == DESKTOP_READOBJECTS     ) <br>      { printf("\n%s0x00000001 DESKTOP_READOBJECTS     ",ucIndentBitsBuf); <br>      } <br>      if ((dwSpecificBits    &amp; DESKTOP_CREATEWINDOW    ) == DESKTOP_CREATEWINDOW    ) <br>      { printf("\n%s0x00000002 DESKTOP_CREATEWINDOW    ",ucIndentBitsBuf); <br>      } <br>      if ((dwSpecificBits    &amp; DESKTOP_CREATEMENU      ) == DESKTOP_CREATEMENU      ) <br>      { printf("\n%s0x00000004 DESKTOP_CREATEMENU      ",ucIndentBitsBuf); <br>      } <br>      if ((dwSpecificBits    &amp; DESKTOP_HOOKCONTROL     ) == DESKTOP_HOOKCONTROL     ) <br>      { printf("\n%s0x00000008 DESKTOP_HOOKCONTROL     ",ucIndentBitsBuf); <br>      } <br>      if ((dwSpecificBits    &amp; DESKTOP_JOURNALRECORD   ) == DESKTOP_JOURNALRECORD   ) <br>      { printf("\n%s0x00000010 DESKTOP_JOURNALRECORD   ",ucIndentBitsBuf); <br>      } <br>      if ((dwSpecificBits    &amp; DESKTOP_JOURNALPLAYBACK ) == DESKTOP_JOURNALPLAYBACK ) <br>      { printf("\n%s0x00000020 DESKTOP_JOURNALPLAYBACK ",ucIndentBitsBuf); <br>      } <br>      if ((dwSpecificBits    &amp; DESKTOP_ENUMERATE       ) == DESKTOP_ENUMERATE       ) <br>      { printf("\n%s0x00000040 DESKTOP_ENUMERATE       ",ucIndentBitsBuf); <br>      } <br>      if ((dwSpecificBits    &amp; DESKTOP_WRITEOBJECTS    ) == DESKTOP_WRITEOBJECTS    ) <br>      { printf("\n%s0x00000080 DESKTOP_WRITEOBJECTS    ",ucIndentBitsBuf); <br>      } <br>      if ((dwSpecificBits    &amp; DESKTOP_SWITCHDESKTOP   ) == DESKTOP_SWITCHDESKTOP   ) <br>      { printf("\n%s0x00000100 DESKTOP_SWITCHDESKTOP   ",ucIndentBitsBuf); <br>      } <br> <br>      dwExtraBits = dwSpecificBits &amp; ( ~( DESKTOP_READOBJECTS <br>                                        | DESKTOP_CREATEWINDOW <br>                                        | DESKTOP_CREATEMENU <br>                                        | DESKTOP_HOOKCONTROL <br>                                        | DESKTOP_JOURNALRECORD <br>                                        | DESKTOP_JOURNALPLAYBACK <br>                                        | DESKTOP_ENUMERATE <br>                                        | DESKTOP_WRITEOBJECTS <br>                                        | DESKTOP_SWITCHDESKTOP) ); <br>      if (dwExtraBits) <br>      { printf("\n%sExtra specific bits    == 0x%.8x &lt;-This is a problem, should be all 0s",ucIndentBuf,dwExtraBits); <br>      } <br>    } <br>    else if (RegKeyAccessMask        == kamKindOfMask) <br>    { <br>      if ((dwSpecificBits    &amp; KEY_QUERY_VALUE       ) == KEY_QUERY_VALUE       ) <br>      { printf("\n%s0x00000001 KEY_QUERY_VALUE       ",ucIndentBitsBuf); <br>      } <br>      if ((dwSpecificBits    &amp; KEY_SET_VALUE         ) == KEY_SET_VALUE         ) <br>      { printf("\n%s0x00000002 KEY_SET_VALUE         ",ucIndentBitsBuf); <br>      } <br>      if ((dwSpecificBits    &amp; KEY_CREATE_SUB_KEY    ) == KEY_CREATE_SUB_KEY    ) <br>      { printf("\n%s0x00000004 KEY_CREATE_SUB_KEY    ",ucIndentBitsBuf); <br>      } <br>      if ((dwSpecificBits    &amp; KEY_ENUMERATE_SUB_KEYS) == KEY_ENUMERATE_SUB_KEYS) <br>      { printf("\n%s0x00000008 KEY_ENUMERATE_SUB_KEYS",ucIndentBitsBuf); <br>      } <br>      if ((dwSpecificBits    &amp; KEY_NOTIFY            ) == KEY_NOTIFY            ) <br>      { printf("\n%s0x00000010 KEY_NOTIFY            ",ucIndentBitsBuf); <br>      } <br>      if ((dwSpecificBits    &amp; KEY_CREATE_LINK       ) == KEY_CREATE_LINK       ) <br>      { printf("\n%s0x00000020 KEY_CREATE_LINK       ",ucIndentBitsBuf); <br>      } <br> <br>      if (((dwStandardBits | dwSpecificBits   ) <br>           &amp; KEY_READ      ) == KEY_READ      ) <br>      { printf("\n%s0x00020019 KEY_READ       == ((STANDARD_RIGHTS_READ | KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS | KEY_NOTIFY) &amp; (~SYNCHRONIZE))",ucIndentBitsBuf); <br>      } <br>      if (((dwStandardBits | dwSpecificBits   ) <br>           &amp; KEY_WRITE     ) == KEY_WRITE     ) <br>      { printf("\n%s0x00020006 KEY_WRITE      == ((STANDARD_RIGHTS_WRITE | KEY_SET_VALUE | KEY_CREATE_SUB_KEY) &amp; (~SYNCHRONIZE))",ucIndentBitsBuf); <br>      } <br>      if (((dwStandardBits | dwSpecificBits   ) <br>           &amp; KEY_EXECUTE   ) == KEY_EXECUTE   ) <br>      { printf("\n%s0x00020019 KEY_EXECUTE    == ((KEY_READ) &amp; (~SYNCHRONIZE))",ucIndentBitsBuf); <br>      } <br>      if (((dwStandardBits | dwSpecificBits   ) <br>           &amp; KEY_ALL_ACCESS) == KEY_ALL_ACCESS) <br>      { printf("\n%s0x000F003F KEY_ALL_ACCESS == ((STANDARD_RIGHTS_ALL | KEY_QUERY_VALUE | KEY_SET_VALUE | KEY_CREATE_SUB_KEY | KEY_ENUMERATE_SUB_KEYS | KEY_NOTIFY | KEY_CREATE_LINK) &amp; (~SYNCHRONIZE))",ucIndentBitsBuf); <br>      } <br> <br>      dwExtraBits = dwSpecificBits &amp; ( ~( KEY_QUERY_VALUE <br>                                        | KEY_SET_VALUE <br>                                        | KEY_CREATE_SUB_KEY <br>                                        | KEY_ENUMERATE_SUB_KEYS <br>                                        | KEY_NOTIFY <br>                                        | KEY_CREATE_LINK <br>                                        | (KEY_READ       &amp; SPECIFIC_RIGHTS_ALL) <br>                                        | (KEY_WRITE      &amp; SPECIFIC_RIGHTS_ALL) <br>                                        | (KEY_EXECUTE    &amp; SPECIFIC_RIGHTS_ALL) <br>                                        | (KEY_ALL_ACCESS &amp; SPECIFIC_RIGHTS_ALL) ) ); <br>      if (dwExtraBits) <br>      { printf("\n%sExtra specific bits    == 0x%.8x &lt;-This is a problem, should be all 0s",ucIndentBuf,dwExtraBits); <br>      } <br>    } <br>    else if (ServiceAccessMask       == kamKindOfMask) <br>    { <br>      if ((dwSpecificBits    &amp; SERVICE_QUERY_CONFIG        ) == SERVICE_QUERY_CONFIG        ) <br>      { printf("\n%s0x00000001 SERVICE_QUERY_CONFIG        ",ucIndentBitsBuf); <br>      } <br>      if ((dwSpecificBits    &amp; SERVICE_CHANGE_CONFIG       ) == SERVICE_CHANGE_CONFIG       ) <br>      { printf("\n%s0x00000002 SERVICE_CHANGE_CONFIG       ",ucIndentBitsBuf); <br>      } <br>      if ((dwSpecificBits    &amp; SERVICE_QUERY_STATUS        ) == SERVICE_QUERY_STATUS        ) <br>      { printf("\n%s0x00000004 SERVICE_QUERY_STATUS        ",ucIndentBitsBuf); <br>      } <br>      if ((dwSpecificBits    &amp; SERVICE_ENUMERATE_DEPENDENTS) == SERVICE_ENUMERATE_DEPENDENTS) <br>      { printf("\n%s0x00000008 SERVICE_ENUMERATE_DEPENDENTS",ucIndentBitsBuf); <br>      } <br>      if ((dwSpecificBits    &amp; SERVICE_START               ) == SERVICE_START               ) <br>      { printf("\n%s0x00000010 SERVICE_START               ",ucIndentBitsBuf); <br>      } <br>      if ((dwSpecificBits    &amp; SERVICE_STOP                ) == SERVICE_STOP                ) <br>      { printf("\n%s0x00000020 SERVICE_STOP                ",ucIndentBitsBuf); <br>      } <br>      if ((dwSpecificBits    &amp; SERVICE_PAUSE_CONTINUE      ) == SERVICE_PAUSE_CONTINUE      ) <br>      { printf("\n%s0x00000040 SERVICE_PAUSE_CONTINUE      ",ucIndentBitsBuf); <br>      } <br>      if ((dwSpecificBits    &amp; SERVICE_INTERROGATE         ) == SERVICE_INTERROGATE         ) <br>      { printf("\n%s0x00000080 SERVICE_INTERROGATE         ",ucIndentBitsBuf); <br>      } <br>      if ((dwSpecificBits    &amp; SERVICE_USER_DEFINED_CONTROL) == SERVICE_USER_DEFINED_CONTROL) <br>      { printf("\n%s0x00000100 SERVICE_USER_DEFINED_CONTROL",ucIndentBitsBuf,ucIndentBitsBuf); <br>      } <br> <br>      if (((dwStandardBits | dwSpecificBits ) <br>           &amp; SERVICE_ALL_ACCESS) == SERVICE_ALL_ACCESS) <br>      { printf("\n%s0x000F01FF SERVICE_ALL_ACCESS == (STANDARD_RIGHTS_REQUIRED | SERVICE_QUERY_CONFIG | SERVICE_CHANGE_CONFIG | ", ucIndentBitsBuf ); <br>        printf("%s", "SERVICE_QUERY_STATUS | SERVICE_ENUMERATE_DEPENDENTS | SERVICE_START | SERVICE_STOP | SERVICE_PAUSE_CONTINUE | SERVICE_INTERROGATE | SERVICE_USER_DEFINED_CONTROL)" ); <br>      } <br> <br>      dwExtraBits = dwSpecificBits &amp; ( ~( SERVICE_QUERY_CONFIG <br>                                        | SERVICE_CHANGE_CONFIG <br>                                        | SERVICE_QUERY_STATUS <br>                                        | SERVICE_ENUMERATE_DEPENDENTS <br>                                        | SERVICE_START <br>                                        | SERVICE_STOP <br>                                        | SERVICE_PAUSE_CONTINUE <br>                                        | SERVICE_INTERROGATE <br>                                        | SERVICE_USER_DEFINED_CONTROL <br>                                        | (SERVICE_ALL_ACCESS &amp; SPECIFIC_RIGHTS_ALL) ) ); <br>      if (dwExtraBits) <br>      { printf("\n%sExtra specific bits    == 0x%.8x &lt;-This is a problem, should be all 0s",ucIndentBuf,dwExtraBits); <br>      } <br>    } <br>    else if (DefaultDaclInAccessTokenAccessMask == kamKindOfMask) <br>    { <br>      printf("\n%sSpecific bits in default Dacl(s) in token not broken down into defines",ucIndentBitsBuf); <br>    } <br>    else <br>    { printf("\n%sYou will need to write some code (such as that directly",ucIndentBuf); <br>      printf("\n%s  above the code that wrote out this message) to decode",ucIndentBuf); <br>      printf("\n%s  this kind of access mask",ucIndentBuf); <br>    } <br>  } <br> <br>  /**************************************************************************\ <br>  * <br>  * Print then decode the ACCESS_SYSTEM_SECURITY bit <br>  * <br>  \**************************************************************************/ <br> <br>  printf("\n%sAccess System Security == 0x%.8x",ucIndentBuf,dwAccessSystemSecurityBit); <br> <br>  /**************************************************************************\ <br>  * <br>  * Print then decode the generic rights bits, which will rarely be on <br>  * <br>  * Generic bits are nearly always mapped by Windows NT before it tries to do <br>  *   anything with them.  You can ignore the fact that generic bits are <br>  *   special in any way, although it helps to keep track of what the mappings <br>  *   are so that you don't have any surprises <br>  * <br>  * The only time the generic bits are not mapped immediately is if they are <br>  *   placed in an inheritable ACE in an ACL, or in an ACL that will be <br>  *   assigned by default (such as the default DACL in an access token).  In <br>  *   that case they're mapped when the child object is created (or when the <br>  *   default DACL is used at object creation time) <br>  * <br>  \**************************************************************************/ <br> <br>  printf("\n%sGeneric  Rights        == 0x%.8x",ucIndentBuf,dwGenericBits); <br> <br>  if (dwGenericBits) <br>  { <br>    if ((dwGenericBits     &amp; GENERIC_READ   ) == GENERIC_READ   ) <br>    { printf("\n%s0x80000000 GENERIC_READ   ",ucIndentBitsBuf); <br>    } <br>    if ((dwGenericBits     &amp; GENERIC_WRITE  ) == GENERIC_WRITE  ) <br>    { printf("\n%s0x40000000 GENERIC_WRITE  ",ucIndentBitsBuf); <br>    } <br>    if ((dwGenericBits     &amp; GENERIC_EXECUTE) == GENERIC_EXECUTE) <br>    { printf("\n%s0x20000000 GENERIC_EXECUTE",ucIndentBitsBuf); <br>    } <br>    if ((dwGenericBits     &amp; GENERIC_ALL    ) == GENERIC_ALL    ) <br>    { printf("\n%s0x10000000 GENERIC_ALL    ",ucIndentBitsBuf); <br>    } <br> <br>    dwExtraBits = dwGenericBits &amp; ( ~( GENERIC_READ <br>                                     | GENERIC_WRITE <br>                                     | GENERIC_EXECUTE <br>                                     | GENERIC_ALL) ); <br>    if (dwExtraBits) <br>    { printf("\n%sExtra generic bits     == 0x%.8x &lt;-This is a problem, should be all 0s",ucIndentBuf,dwExtraBits); <br>    } <br>  } <br>} <br>  <br>/****************************************************************************\ <br>* <br>* FUNCTION: LookupSIDName <br>* <br>\****************************************************************************/ <br> <br>BOOL LookupSIDName(PSID psidSID, LPTSTR lpszOldIndent) <br>{ <br>  UCHAR        ucIndentBuf    [SZ_INDENT_BUF]    = ""; <br>  #define                      SZ_ACCT_NAME_BUF  60 <br>  UCHAR        ucNameBuf      [SZ_ACCT_NAME_BUF] = ""; <br>  DWORD        dwNameLength  = SZ_ACCT_NAME_BUF; <br>  #define                      SZ_DMN_NAME_BUF   60 <br>  UCHAR        ucDomainNmBuf  [SZ_DMN_NAME_BUF]  = ""; <br>  DWORD        dwDNameLength = SZ_DMN_NAME_BUF; <br>  #define                      SZ_SID_STRING_BUF 150 <br>  UCHAR        ucSIDStringBuf [SZ_SID_STRING_BUF] = ""; <br>  SID_NAME_USE peAcctNameUse = SidTypeInvalid; <br>  DWORD        dwLookupStatus; <br>  BOOL         bGotBadLookupThatIsNotLocalLogonSID; <br> <br>  strcpy(ucIndentBuf,lpszOldIndent); <br>  strcat(ucIndentBuf,"  "); <br> <br>  if (!IsValidSid(psidSID)) <br>  { PERR("IsValidSid"); <br>    return(FALSE); <br>  } <br> <br>  if (!SIDStringName(psidSID,ucSIDStringBuf)) <br>  { PERR("SIDStringName"); <br>    return(FALSE); <br>  } <br> <br>  if (!LookupAccountSid( <br>         (LPTSTR)"",         // Look on local machine <br>         psidSID, <br>         (LPTSTR)&amp;ucNameBuf, <br>         (LPDWORD)&amp;dwNameLength, <br>         (LPTSTR)&amp;ucDomainNmBuf, <br>         (LPDWORD)&amp;dwDNameLength, <br>         (PSID_NAME_USE)&amp;peAcctNameUse)) <br>  { <br>    dwLookupStatus = GetLastError(); <br> <br>    /************************************************************************\ <br>    * <br>    * Got a bad Lookup, so check is SID the Local Logon SID? <br>    * <br>    * The problem is that LookupAccountSid api will find all the well-known <br>    *   SIDs except the Local Logon SID.  The last two sub-authorities are <br>    *   always different, so to check to see if the SID we're looking at is <br>    *   the Local Logon SID, we take the psidLogonIdsSid variable we built at <br>    *   initialization time, and blast into it's last two sub-authorities the <br>    *   last two sub-authorities that we have.  Then compare for EqualSid <br>    * <br>    \************************************************************************/ <br> <br>    // Must have same number of sub authorities <br> <br>    bGotBadLookupThatIsNotLocalLogonSID = FALSE;  // Assume the best :) <br> <br>    if ( ( *(GetSidSubAuthorityCount(psidLogonIdsSid))) != <br>         ( *(GetSidSubAuthorityCount(psidSID        )))    ) <br>    { // Not same number of sub-authorities, so can't be a match <br>      bGotBadLookupThatIsNotLocalLogonSID = TRUE; <br>    } <br>    else <br>    { <br>      // Force the last two sub-authorities to match <br>      *(GetSidSubAuthority( psidLogonIdsSid, 1 )) = <br>      *(GetSidSubAuthority( psidSID        , 1 )); <br>      *(GetSidSubAuthority( psidLogonIdsSid, 2 )) = <br>      *(GetSidSubAuthority( psidSID        , 2 )); <br> <br>      /**********************************************************************\ <br>      * <br>      * EqualPrefixSid could be used instead if we want to blast in all but <br>      *   the last sub-authority.  For demonstration purposes, as long as we <br>      *   did one of the two previous assignment statements, we may as well to <br>      *   the other and use EqualSID <br>      * <br>      \**********************************************************************/ <br> <br>      if (EqualSid(psidSID,psidLogonIdsSid)) <br>      { printf("\n%sSID is the Local Logon SID   %s",ucIndentBuf,ucSIDStringBuf); <br>      } <br>      else <br>      { bGotBadLookupThatIsNotLocalLogonSID = TRUE; <br>      } <br>    } <br>    if (bGotBadLookupThatIsNotLocalLogonSID) <br>    { <br>      /**********************************************************************\ <br>      * <br>      * ERROR_NONE_MAPPED means account unknown.  RegEdt32.exe will show <br>      *   1332-error-type accounts as Account Unknown, so we will also <br>      * <br>      \**********************************************************************/ <br> <br>      if (ERROR_NONE_MAPPED == dwLookupStatus) <br>      { printf("\n%sSID domain == %s, Name == %s    (Account Unknown)  %s",ucIndentBuf,ucDomainNmBuf,ucNameBuf,ucSIDStringBuf); <br>      } <br>      else <br>      { SetLastError(dwLookupStatus); <br>        PERR("LookupAccountSid"); <br>        return(FALSE); <br>      } <br>    } <br>  } <br>  else <br>  { // Got good Lookup, so SID Is NOT the Local Logon SID <br>    printf("\n%sSID domain == %s, Name == %s   %s",ucIndentBuf,ucDomainNmBuf,ucNameBuf,ucSIDStringBuf); <br> <br>    /************************************************************************\ <br>    * <br>    * For demonstration purposes see which well-known SID it might be <br>    * For demonstration purposes do a silly search demonstrating <br>    *   no two well-known SIDs are equal <br>    * <br>    \************************************************************************/ <br> <br>    if (EqualSid(psidSID,psidNullSid)) <br>    { printf("\n%sSID is the Null SID",ucIndentBuf); <br>    } <br>    if (EqualSid(psidSID,psidWorldSid)) <br>    { printf("\n%sSID is the World SID",ucIndentBuf); <br>    } <br>    if (EqualSid(psidSID,psidLocalSid)) <br>    { printf("\n%sSID is the Local SID",ucIndentBuf); <br>    } <br>    if (EqualSid(psidSID,psidCreatorOwnerSid)) <br>    { printf("\n%sSID is the CreatorOwner SID",ucIndentBuf); </code></pre>
<p>
</p>
<pre><code>} <br>    if (EqualSid(psidSID,psidCreatorGroupSid)) <br>    { printf("\n%sSID is the CreatorGroup SID",ucIndentBuf); <br>    } <br>    if (EqualSid(psidSID,psidNtAuthoritySid)) <br>    { printf("\n%sSID is the NtAuthority SID",ucIndentBuf); <br>    } <br>    if (EqualSid(psidSID,psidDialupSid)) <br>    { printf("\n%sSID is the DialUp SID",ucIndentBuf); <br>    } <br>    if (EqualSid(psidSID,psidNetworkSid)) <br>    { printf("\n%sSID is the Network SID",ucIndentBuf); <br>    } <br>    if (EqualSid(psidSID,psidBatchSid)) <br>    { printf("\n%sSID is the Batch SID",ucIndentBuf); <br>    } <br>    if (EqualSid(psidSID,psidInteractiveSid)) <br>    { printf("\n%sSID is the Interactive SID",ucIndentBuf); <br>    } <br>    if (EqualSid(psidSID,psidServiceSid)) <br>    { printf("\n%sSID is the Service SID",ucIndentBuf); <br>    } <br>    if (EqualSid(psidSID,psidLocalSystemSid)) <br>    { printf("\n%sSID is the LocalSystem SID",ucIndentBuf); <br>    } <br>    if (EqualSid(psidSID,psidBuiltinDomainSid)) <br>    { printf("\n%sSID is the Builtin Domain SID",ucIndentBuf); <br>    } <br>  } <br> <br>  switch (peAcctNameUse) <br>  { case                      SidTypeUser           : <br>      printf("\n%sSID type is SidTypeUser"          ,ucIndentBuf); <br>      break; <br>    case                      SidTypeGroup          : <br>      printf("\n%sSID type is SidTypeGroup"         ,ucIndentBuf); <br>      break; <br>    case                      SidTypeDomain         : <br>      printf("\n%sSID type is SidTypeDomain"        ,ucIndentBuf); <br>      break; <br>    case                      SidTypeAlias          : <br>      printf("\n%sSID type is SidTypeAlias"         ,ucIndentBuf); <br>      break; <br>    case                      SidTypeWellKnownGroup : <br>      printf("\n%sSID type is SidTypeWellKnownGroup",ucIndentBuf); <br>      break; <br>    case                      SidTypeDeletedAccount : <br>      printf("\n%sSID type is SidTypeDeletedAccount",ucIndentBuf); <br>      break; <br>    case                      SidTypeInvalid        : <br>      printf("\n%sSID type is SidTypeInvalid"       ,ucIndentBuf); <br>      break; <br>    case                      SidTypeUnknown        : <br>      printf("\n%sSID type is SidTypeUnknown"       ,ucIndentBuf); <br>      break; <br>    default                   : <br>      printf("\n%sSID type is IMPOSSIBLE!!!!  Run debugger, see value!",ucIndentBuf); <br>      break; <br>  } <br>} <br>  <br>/****************************************************************************\ <br>* <br>* FUNCTION: SIDStringName <br>* <br>\****************************************************************************/ <br> <br>BOOL SIDStringName(PSID psidSID, LPTSTR lpszSIDStringName) <br>{ <br>  /**************************************************************************\ <br>  * <br>  * Unfortunately there is no api to return the SID Revision, and the number <br>  *   of bytes in the Identifier Authority must be expressed as a define <br>  *   (since the == operator won't operate on structures so mempcy has to be <br>  *   used for the identifier authority compares) <br>  * <br>  \**************************************************************************/ <br> <br>  DWORD dwNumSubAuthorities; <br>  DWORD dwLen; <br>  DWORD dwSubAuthorityI; <br>  #define BytesInIdentifierAuthority  6 <br>  SID_IDENTIFIER_AUTHORITY siaSidAuthority; <br>  SID_IDENTIFIER_AUTHORITY siaNullSidAuthority    = SECURITY_NULL_SID_AUTHORITY; <br>  SID_IDENTIFIER_AUTHORITY siaWorldSidAuthority   = SECURITY_WORLD_SID_AUTHORITY; <br>  SID_IDENTIFIER_AUTHORITY siaLocalSidAuthority   = SECURITY_LOCAL_SID_AUTHORITY; <br>  SID_IDENTIFIER_AUTHORITY siaCreatorSidAuthority = SECURITY_CREATOR_SID_AUTHORITY; <br>  SID_IDENTIFIER_AUTHORITY siaNtAuthority         = SECURITY_NT_AUTHORITY; <br> <br>  dwLen = sprintf(lpszSIDStringName,"S-%d-",SID_REVISION); <br> <br>  if (SID_REVISION != ((PISID)psidSID)-&gt;Revision) <br>  { dwLen += sprintf(lpszSIDStringName+dwLen,"bad_revision==%d",((PISID)psidSID)-&gt;Revision); <br>  } <br> <br>  siaSidAuthority = *(GetSidIdentifierAuthority(psidSID)); <br> <br>  if      (0==memcmp(&amp;siaSidAuthority,&amp;siaNullSidAuthority   ,BytesInIdentifierAuthority)) <br>  { dwLen += sprintf(lpszSIDStringName+dwLen,"0"); <br>  } <br>  else if (0==memcmp(&amp;siaSidAuthority,&amp;siaWorldSidAuthority  ,BytesInIdentifierAuthority)) <br>  { dwLen += sprintf(lpszSIDStringName+dwLen,"1"); <br>  } <br>  else if (0==memcmp(&amp;siaSidAuthority,&amp;siaLocalSidAuthority  ,BytesInIdentifierAuthority)) <br>  { dwLen += sprintf(lpszSIDStringName+dwLen,"2"); <br>  } <br>  else if (0==memcmp(&amp;siaSidAuthority,&amp;siaCreatorSidAuthority,BytesInIdentifierAuthority)) <br>  { dwLen += sprintf(lpszSIDStringName+dwLen,"3"); <br>  } <br>  else if (0==memcmp(&amp;siaSidAuthority,&amp;siaNtAuthority        ,BytesInIdentifierAuthority)) <br>  { dwLen += sprintf(lpszSIDStringName+dwLen,"5"); <br>  } <br>  else <br>  { dwLen += sprintf(lpszSIDStringName+dwLen,"UnknownAuthority!"); <br>  } <br> <br>  dwNumSubAuthorities = (DWORD)( *(GetSidSubAuthorityCount(psidSID)) ); <br> <br>  for (dwSubAuthorityI=0; dwSubAuthorityI&lt;dwNumSubAuthorities; dwSubAuthorityI++) <br>  { dwLen += sprintf(lpszSIDStringName+dwLen,"-%d",*(GetSidSubAuthority(psidSID,dwSubAuthorityI))); <br>  } <br> <br>  return(TRUE); <br>} <br>  <br>/****************************************************************************\ <br>* <br>* FUNCTION: ExamineAccessToken <br>* <br>\****************************************************************************/ <br> <br>VOID ExamineAccessToken(HANDLE hAccessToken) <br>{ TOKEN_INFORMATION_CLASS ticInfoClass; <br>  #define                               SZ_TOK_INFO_BUF  2000 <br>  UCHAR                   ucTokInfoBuf [SZ_TOK_INFO_BUF] = ""; <br>  DWORD                   dwTokInfoBufSz; <br>  PTOKEN_USER             ptuTokenUser         = (PTOKEN_USER         )&amp;ucTokInfoBuf; <br>  PTOKEN_GROUPS           ptgTokenGroups       = (PTOKEN_GROUPS       )&amp;ucTokInfoBuf; <br>  PTOKEN_PRIVILEGES       ptpTokenPrivileges   = (PTOKEN_PRIVILEGES   )&amp;ucTokInfoBuf; <br>  PTOKEN_OWNER            ptoTokenOwner        = (PTOKEN_OWNER        )&amp;ucTokInfoBuf; <br>  PTOKEN_PRIMARY_GROUP    ptgTokenPrimaryGroup = (PTOKEN_PRIMARY_GROUP)&amp;ucTokInfoBuf; <br>  PTOKEN_DEFAULT_DACL     ptdTokenDefaultDacl  = (PTOKEN_DEFAULT_DACL )&amp;ucTokInfoBuf; <br>  PTOKEN_SOURCE           ptsTokenSource       = (PTOKEN_SOURCE       )&amp;ucTokInfoBuf; <br>  PTOKEN_TYPE             pttTokenType         = (PTOKEN_TYPE         )&amp;ucTokInfoBuf; <br>  PSECURITY_IMPERSONATION_LEVEL psilSecurityImpersonationLevel = (PSECURITY_IMPERSONATION_LEVEL)&amp;ucTokInfoBuf; <br>  PTOKEN_STATISTICS       ptsTokenStatistics   = (PTOKEN_STATISTICS   )&amp;ucTokInfoBuf; <br>  DWORD                   dwGroupI; <br>  DWORD                   dwPrivilegeI; <br>  #define                               SZ_PRIV_INFO_BUF  250 <br>  UCHAR                   ucPrivInfoBuf[SZ_PRIV_INFO_BUF] = ""; <br>  DWORD                   dwPrivInfoBufSz; <br>  DWORD                   dwExtraBits; <br>  UCHAR                   ucIndentBitsBuf[SZ_INDENT_BUF]  = ""; <br> <br>  strcpy(ucIndentBitsBuf,""); <br>  strcat(ucIndentBitsBuf,"                                  "); <br> <br> <br>  if    (!I_DO_NOT_WANT_THIS_CODE_TO_CLUTTER_THIS_PROGRAM_S_OUTPUT) <br>  { <br>    ticInfoClass   = TokenUser; <br>    dwTokInfoBufSz = SZ_TOK_INFO_BUF; <br> <br>    if (!GetTokenInformation(hAccessToken, <br>                             ticInfoClass, <br>                             ucTokInfoBuf, <br>                             (DWORD)SZ_TOK_INFO_BUF, <br>                             &amp;dwTokInfoBufSz)) <br>    { PERR("GetTokenInformation"); <br>      return; <br>    } <br> <br>    printf("\nToken's User SID"); <br>    printf("\n    (this is a SID that is used to compare to SIDs in DACL(s) and SACL(s)"); <br> <br>    if(!LookupSIDName( (*ptuTokenUser).User.Sid,"")) <br>    { PERR("LookupSIDName failed"); <br>    } <br> <br>    printf("\nToken's User SID Attributes == 0x%.8x",(*ptuTokenUser).User.Attributes); <br>    printf("\n    These should always be 0 - see \\mstools\\h\\winnt.h right after"); <br>    printf("\n      the defines such as SE_GROUP_LOGON_ID - there are no user"); <br>    printf("\n      attributes yet defined"); <br> <br> <br> <br>    ticInfoClass   = TokenGroups; <br>    dwTokInfoBufSz = SZ_TOK_INFO_BUF; <br> <br>    if (!GetTokenInformation(hAccessToken, <br>                             ticInfoClass, <br>                             ucTokInfoBuf, <br>                             (DWORD)SZ_TOK_INFO_BUF, <br>                             &amp;dwTokInfoBufSz)) <br>    { PERR("GetTokenInformation"); <br>      return; <br>    } <br> <br>    printf("\nToken groups (%d)",(*ptgTokenGroups).GroupCount); <br>    printf("\n    (these SID(s) also are used to compare to SIDs in DACL(s) and SACL(s)"); <br> <br>    for (dwGroupI=0; dwGroupI&lt;(*ptgTokenGroups).GroupCount; dwGroupI++) <br>    { <br>      DWORD dwAttributeBits = (*ptgTokenGroups).Groups[dwGroupI].Attributes; <br>      printf("\n  Token group (%d)",dwGroupI); <br> <br>      if(!LookupSIDName( (*ptgTokenGroups).Groups[dwGroupI].Sid,"  ")) <br>      { PERR("LookupSIDName failed"); <br>      } <br>      printf("\n  Token's group (%d) attributes == 0x%.8x",dwGroupI,dwAttributeBits); <br> <br>      if (dwAttributeBits) <br>      { <br>        if ((dwAttributeBits   &amp; SE_GROUP_MANDATORY         ) == SE_GROUP_MANDATORY         ) <br>        { printf("\n%s0x00000001 SE_GROUP_MANDATORY         ",ucIndentBitsBuf); <br>        } <br>        if ((dwAttributeBits   &amp; SE_GROUP_ENABLED_BY_DEFAULT) == SE_GROUP_ENABLED_BY_DEFAULT) <br>        { printf("\n%s0x00000002 SE_GROUP_ENABLED_BY_DEFAULT",ucIndentBitsBuf); <br>        } <br>        if ((dwAttributeBits   &amp; SE_GROUP_ENABLED           ) == SE_GROUP_ENABLED           ) <br>        { printf("\n%s0x00000004 SE_GROUP_ENABLED           ",ucIndentBitsBuf); <br>        } <br>        if ((dwAttributeBits   &amp; SE_GROUP_OWNER             ) == SE_GROUP_OWNER             ) <br>        { printf("\n%s0x00000008 SE_GROUP_OWNER             ",ucIndentBitsBuf); <br>        } <br>        if ((dwAttributeBits   &amp; SE_GROUP_LOGON_ID          ) == SE_GROUP_LOGON_ID          ) <br>        { printf("\n%s0xC0000000 SE_GROUP_LOGON_ID          ",ucIndentBitsBuf); <br>        } <br> <br>        dwExtraBits = dwAttributeBits &amp; ( ~( SE_GROUP_MANDATORY <br>                                           | SE_GROUP_ENABLED_BY_DEFAULT <br>                                           | SE_GROUP_ENABLED <br>                                           | SE_GROUP_OWNER <br>                                           | SE_GROUP_LOGON_ID) ); <br>        if (0 != dwExtraBits) <br>        { printf("\n          Extra attribute bits == 0x%.8x &lt;-This is a problem, should be all 0s",dwExtraBits); <br>        } <br>      } <br>    } <br> <br> <br> <br>    ticInfoClass   = TokenPrivileges; <br>    dwTokInfoBufSz = SZ_TOK_INFO_BUF; <br> <br>    if (!GetTokenInformation(hAccessToken, <br>                             ticInfoClass, <br>                             ucTokInfoBuf, <br>                             (DWORD)SZ_TOK_INFO_BUF, <br>                             &amp;dwTokInfoBufSz)) <br>    { PERR("GetTokenInformation"); <br>      return; <br>    } <br> <br>    printf("\nToken privileges (%d)",(*ptpTokenPrivileges).PrivilegeCount); <br>    printf("\n  NOTE: Most token privileges are not enabled by default."); <br>    printf("\n    For example the privilege to reboot or logoff is not."); <br>    printf("\n    0x00000000 for attributes implies the privilege is not enabled."); <br>    printf("\n    Use care when enabling privileges.  Enable only those needed,"); <br>    printf("\n      and leave them enabled only for as long as they are needed."); <br> <br>    for (dwPrivilegeI=0; dwPrivilegeI&lt;(*ptpTokenPrivileges).PrivilegeCount; dwPrivilegeI++) <br>    { <br>      LUID  luidTokenLuid   = (*ptpTokenPrivileges).Privileges[dwPrivilegeI].Luid; <br>      DWORD dwAttributeBits = (*ptpTokenPrivileges).Privileges[dwPrivilegeI].Attributes; <br> <br>      dwPrivInfoBufSz = SZ_PRIV_INFO_BUF; <br> <br>      if (!LookupPrivilegeName(NULL, <br>                               (PLUID)&amp;luidTokenLuid, <br>                               (LPTSTR)ucPrivInfoBuf, <br>                               (LPDWORD)&amp;dwPrivInfoBufSz)) <br>      { PERR("LookUpPrivilegeName"); <br>        return; <br>      } <br> <br>      printf("\n  Token's privilege (%.2d) name       == %s",dwPrivilegeI,ucPrivInfoBuf); <br> <br>      printf("\n  Token's privilege (%.2d) attributes == 0x%.8x",dwPrivilegeI,dwAttributeBits); <br> <br>      if (dwAttributeBits) <br>      { <br>        if ((dwAttributeBits   &amp; SE_PRIVILEGE_ENABLED_BY_DEFAULT) == SE_PRIVILEGE_ENABLED_BY_DEFAULT) <br>        { printf("\n%s     0x00000001 SE_PRIVILEGE_ENABLED_BY_DEFAULT",ucIndentBitsBuf); <br>        } <br>        if ((dwAttributeBits   &amp; SE_PRIVILEGE_ENABLED           ) == SE_PRIVILEGE_ENABLED           ) <br>        { printf("\n%s     0x00000002 SE_PRIVILEGE_ENABLED           ",ucIndentBitsBuf); <br>        } <br>        if ((dwAttributeBits   &amp; SE_PRIVILEGE_USED_FOR_ACCESS   ) == SE_PRIVILEGE_USED_FOR_ACCESS   ) <br>        { printf("\n%s     0x80000000 SE_PRIVILEGE_USED_FOR_ACCESS   ",ucIndentBitsBuf); <br>        } <br> <br>        dwExtraBits = dwAttributeBits &amp; ( ~( SE_PRIVILEGE_ENABLED_BY_DEFAULT <br>                                           | SE_PRIVILEGE_ENABLED <br>                                           | SE_PRIVILEGE_USED_FOR_ACCESS ) ); <br>        if (0 != dwExtraBits) <br>        { printf("\n               Extra attribute bits == 0x%.8x &lt;-This is a problem, should be all 0s",dwExtraBits); <br>        } <br>      } <br>    } <br> <br> <br> <br>    ticInfoClass   = TokenOwner; <br>    dwTokInfoBufSz = SZ_TOK_INFO_BUF; <br> <br>    if (!GetTokenInformation(hAccessToken, <br>                             ticInfoClass, <br>                             ucTokInfoBuf, <br>                             (DWORD)SZ_TOK_INFO_BUF, <br>                             &amp;dwTokInfoBufSz)) <br>    { PERR("GetTokenInformation"); <br>      return; <br>    } <br> <br>    printf("\nToken's default-owner-SID for created objects"); <br>    printf("\n    (this is NOT a SID that is used to compare to SIDs in DACL(s) and SACL(s)"); <br> <br>    if(!LookupSIDName((*ptoTokenOwner).Owner,"")) <br>    { PERR("LookupSIDName failed"); <br>    } <br> <br> <br> <br>    ticInfoClass   = TokenPrimaryGroup; <br>    dwTokInfoBufSz = SZ_TOK_INFO_BUF; <br> <br>    if (!GetTokenInformation(hAccessToken, <br>                             ticInfoClass, <br>                             ucTokInfoBuf, <br>                             (DWORD)SZ_TOK_INFO_BUF, <br>                             &amp;dwTokInfoBufSz)) <br>    { PERR("GetTokenInformation"); <br>      return; <br>    } <br> <br>    printf("\nToken's Primary Group SID"); <br>    printf("\n    (Current uses are Posix and Macintosh client support)"); <br> <br>    if(!LookupSIDName((*ptgTokenPrimaryGroup).PrimaryGroup,"")) <br>    { PERR("LookupSIDName failed"); <br>    } <br> <br> <br> <br>    ticInfoClass   = TokenDefaultDacl; <br>    dwTokInfoBufSz = SZ_TOK_INFO_BUF; <br> <br>    if (!GetTokenInformation(hAccessToken, <br>                             ticInfoClass, <br>                             ucTokInfoBuf, <br>                             (DWORD)SZ_TOK_INFO_BUF, <br>                             &amp;dwTokInfoBufSz)) <br>    { PERR("GetTokenInformation"); <br>      return; <br>    } <br> <br>    if (NULL         == (*ptdTokenDefaultDacl).DefaultDacl) <br>    { printf("\nToken has a NULL Default DACL explicitly specified (allows all access to"); <br>      printf("\n    Everyone, only on objects that are created where the object's Dacl is"); <br>      printf("\n    assigned by default from this default Dacl in this access token)"); <br>    } <br>    else <br>    { printf("\nToken's default-DACL for created objects"); <br>      if(!ExamineACL((*ptdTokenDefaultDacl).DefaultDacl,"",DefaultDaclInAccessTokenAccessMask)) <br>      { PERR("ExamineACL failed"); <br>      } <br>    } <br> <br> <br> <br>    ticInfoClass   = TokenSource; <br>    dwTokInfoBufSz = SZ_TOK_INFO_BUF; <br> <br>    if (!GetTokenInformation(hAccessToken, <br>                             ticInfoClass, <br>                             ucTokInfoBuf, <br>                             (DWORD)SZ_TOK_INFO_BUF, <br>                             &amp;dwTokInfoBufSz)) <br>    { PERR("GetTokenInformation"); <br>      return; <br>    } <br> <br>    printf("\nToken's Source"); <br>    printf("\n  Source Name        == %.8s",(*ptsTokenSource).SourceName); <br>    printf("\n  Source Identifier  == 0x%.8x%.8x", <br>       (*ptsTokenSource).SourceIdentifier.HighPart, <br>       (*ptsTokenSource).SourceIdentifier.LowPart); <br> <br> <br> <br>    ticInfoClass   = TokenType; <br>    dwTokInfoBufSz = SZ_TOK_INFO_BUF; <br> <br>    if (!GetTokenInformation(hAccessToken, <br>                             ticInfoClass, <br>                             ucTokInfoBuf, <br>                             (DWORD)SZ_TOK_INFO_BUF, <br>                             &amp;dwTokInfoBufSz)) <br>    { PERR("GetTokenInformation"); <br>      return; <br>    } <br> <br>    switch (*pttTokenType) <br>    { case  TokenPrimary       : <br>        printf("\nToken's Type is TokenPrimary"); <br>        break; <br>      case  TokenImpersonation : <br>        printf("\nToken's Type is TokenImpersonation"); <br>        printf("\n    Hence the token's TokenImpersonationLevel can be examined"); <br> <br>        ticInfoClass   = TokenImpersonationLevel; <br>        dwTokInfoBufSz = SZ_TOK_INFO_BUF; <br> <br>        if (!GetTokenInformation(hAccessToken, <br>                                 ticInfoClass, <br>                                 ucTokInfoBuf, <br>                                 (DWORD)SZ_TOK_INFO_BUF, <br>                                 &amp;dwTokInfoBufSz)) <br>        { PERR("GetTokenInformation"); <br>          return; <br>        } <br> <br>        switch (*psilSecurityImpersonationLevel) <br>        { case                     SecurityAnonymous      : <br>            printf("\n  Token is a SecurityAnonymous impersonation token"); <br>            break; <br>          case                     SecurityIdentification : <br>            printf("\n  Token is a SecurityIdentification impersonation token"); <br>            break; <br>          case                     SecurityImpersonation  : <br>            printf("\n  Token is a SecurityImpersonation impersonation token"); <br>            break; <br>          case                     SecurityDelegation     : <br>            printf("\n  Token is a SecurityDelegation impersonation token"); <br>            break; <br>          default                   : <br>            printf("\n  Token is an ILLEGAL KIND OF impersonation token!!! == 0x%.8x",*psilSecurityImpersonationLevel); <br>            break; <br>        } <br> <br>      default                  : <br>        printf("\nToken's Type is ILLEGAL!!! == 0x%.8x",*pttTokenType); <br>        break; <br>    } <br> <br> <br> <br>    ticInfoClass   = TokenStatistics; <br>    dwTokInfoBufSz = SZ_TOK_INFO_BUF; <br> <br>    if (!GetTokenInformation(hAccessToken, <br>                             ticInfoClass, <br>                             ucTokInfoBuf, <br>                             (DWORD)SZ_TOK_INFO_BUF, <br>                             &amp;dwTokInfoBufSz)) <br>    { PERR("GetTokenInformation"); <br>      return; <br>    } <br> <br>    printf("\nToken's Statistics"); <br>    printf("\n  TokenId            == 0x%.8x%.8x", <br>      (*ptsTokenStatistics).TokenId.HighPart, <br>      (*ptsTokenStatistics).TokenId.LowPart); <br>    printf("\n  AuthenticationId   == 0x%.8x%.8x", <br>      (*ptsTokenStatistics).AuthenticationId.HighPart, <br>      (*ptsTokenStatistics).AuthenticationId.LowPart); <br>    printf("\n  ExpirationTime     == (not supported in this release of Windows NT)"); <br>    printf("\n  TokenType          == See token type above"); <br>    printf("\n  ImpersonationLevel == See impersonation level above (only if TokenType is not TokenPrimary)"); <br>    printf("\n  DynamicCharged     == %ld",(*ptsTokenStatistics).DynamicCharged    ); <br>    printf("\n  DynamicAvailable   == %ld",(*ptsTokenStatistics).DynamicAvailable  ); <br>    printf("\n  GroupCount         == %d",(*ptsTokenStatistics).GroupCount        ); <br>    printf("\n  PrivilegeCount     == %d",(*ptsTokenStatistics).PrivilegeCount    ); <br>    printf("\n  ModifiedId         == 0x%.8x%.8x", <br>      (*ptsTokenStatistics).ModifiedId.HighPart, <br>      (*ptsTokenStatistics).ModifiedId.LowPart); <br> <br> <br> <br>    printf("\n\n"); <br> <br>  } <br>} <br>  <br>/****************************************************************************\ <br>* <br>* FUNCTION: SetPrivilegeInAccessToken <br>* <br>\****************************************************************************/ <br> <br>BOOL SetPrivilegeInAccessToken(VOID) <br>{ <br>  HANDLE           hProcess; <br>  HANDLE           hAccessToken; <br>  LUID             luidPrivilegeLUID; <br>  TOKEN_PRIVILEGES tpTokenPrivilege; <br> <br>  hProcess = GetCurrentProcess(); <br>  if (!hProcess) <br>  { PERR("GetCurrentProcess"); <br>    return(FALSE); <br>  } <br> <br>  if (!OpenProcessToken(hProcess, <br>                        TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, <br>                        &amp;hAccessToken)) <br>  { PERR("OpenProcessToken"); <br>    return(FALSE); <br>  } <br> <br>  /**************************************************************************\ <br>  * <br>  * Get LUID of SeSecurityPrivilege privilege <br>  * <br>  \**************************************************************************/ <br> <br>  if (!LookupPrivilegeValue(NULL, <br>                            SE_SECURITY_NAME, <br>                            &amp;luidPrivilegeLUID)) <br>  { PERR("LookupPrivilegeValue"); <br>    printf("\nThe above error means you need to log on as an Administrator"); <br>    return(FALSE); <br>  } <br> <br>  /**************************************************************************\ <br>  * <br>  * Enable the SeSecurityPrivilege privilege using the LUID just <br>  *   obtained <br>  * <br>  \**************************************************************************/ <br> <br>  tpTokenPrivilege.PrivilegeCount = 1; <br>  tpTokenPrivilege.Privileges[0].Luid = luidPrivilegeLUID; <br>  tpTokenPrivilege.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED; <br> <br>  AdjustTokenPrivileges (hAccessToken, <br>                         FALSE,  // Do not disable all <br>                         &amp;tpTokenPrivilege, <br>                         sizeof(TOKEN_PRIVILEGES), <br>                         NULL,   // Ignore previous info <br>                         NULL);  // Ignore previous info <br> <br>  if ( GetLastError() != NO_ERROR ) <br>  { PERR("AdjustTokenPrivileges"); <br>    return(FALSE); <br>  } <br> <br>  return(TRUE); <br>} <br>  <br>/****************************************************************************\ <br>* <br>* FUNCTION: InitializeWellKnownSIDs <br>* <br>\****************************************************************************/ <br> <br>VOID InitializeWellKnownSIDs(VOID) <br>{ <br>  DWORD dwSidWith0SubAuthorities; <br>  DWORD dwSidWith1SubAuthority; <br>  DWORD dwSidWith2SubAuthorities; <br>  DWORD dwSidWith3SubAuthorities; <br>  DWORD dwSidWith4SubAuthorities; <br> <br>  SID_IDENTIFIER_AUTHORITY siaNullSidAuthority    = SECURITY_NULL_SID_AUTHORITY; <br>  SID_IDENTIFIER_AUTHORITY siaWorldSidAuthority   = SECURITY_WORLD_SID_AUTHORITY; <br>  SID_IDENTIFIER_AUTHORITY siaLocalSidAuthority   = SECURITY_LOCAL_SID_AUTHORITY; <br>  SID_IDENTIFIER_AUTHORITY siaCreatorSidAuthority = SECURITY_CREATOR_SID_AUTHORITY; <br>  SID_IDENTIFIER_AUTHORITY siaNtAuthority         = SECURITY_NT_AUTHORITY; <br> <br>  //  These SID sizes need to be allocated <br> <br>  dwSidWith0SubAuthorities = GetSidLengthRequired( 0 ); <br>  dwSidWith1SubAuthority   = GetSidLengthRequired( 1 ); <br>  dwSidWith2SubAuthorities = GetSidLengthRequired( 2 ); <br>  dwSidWith3SubAuthorities = GetSidLengthRequired( 3 ); <br>  dwSidWith4SubAuthorities = GetSidLengthRequired( 4 ); <br> <br>  //  Allocate and initialize the universal SIDs <br> <br>  psidNullSid         = (PSID)LocalAlloc(LPTR,dwSidWith1SubAuthority); <br>  psidWorldSid        = (PSID)LocalAlloc(LPTR,dwSidWith1SubAuthority); <br>  psidLocalSid        = (PSID)LocalAlloc(LPTR,dwSidWith1SubAuthority); <br>  psidCreatorOwnerSid = (PSID)LocalAlloc(LPTR,dwSidWith1SubAuthority); <br>  psidCreatorGroupSid = (PSID)LocalAlloc(LPTR,dwSidWith1SubAuthority); <br> <br>  InitializeSid( psidNullSid,         &amp;siaNullSidAuthority,    1 ); <br>  InitializeSid( psidWorldSid,        &amp;siaWorldSidAuthority,   1 ); <br>  InitializeSid( psidLocalSid,        &amp;siaLocalSidAuthority,   1 ); <br>  InitializeSid( psidCreatorOwnerSid, &amp;siaCreatorSidAuthority, 1 ); <br>  InitializeSid( psidCreatorGroupSid, &amp;siaCreatorSidAuthority, 1 ); <br> <br>  *(GetSidSubAuthority( psidNullSid,         0 )) = SECURITY_NULL_RID; <br>  *(GetSidSubAuthority( psidWorldSid,        0 )) = SECURITY_WORLD_RID; <br>  *(GetSidSubAuthority( psidLocalSid,        0 )) = SECURITY_LOCAL_RID; <br>  *(GetSidSubAuthority( psidCreatorOwnerSid, 0 )) = SECURITY_CREATOR_OWNER_RID; <br>  *(GetSidSubAuthority( psidCreatorGroupSid, 0 )) = SECURITY_CREATOR_GROUP_RID; <br> <br>  // Allocate and initialize the NT defined SIDs <br> <br>  psidNtAuthoritySid   = (PSID)LocalAlloc(LPTR,dwSidWith0SubAuthorities); <br>  psidDialupSid        = (PSID)LocalAlloc(LPTR,dwSidWith1SubAuthority); <br>  psidNetworkSid       = (PSID)LocalAlloc(LPTR,dwSidWith1SubAuthority); <br>  psidBatchSid         = (PSID)LocalAlloc(LPTR,dwSidWith1SubAuthority); <br>  psidInteractiveSid   = (PSID)LocalAlloc(LPTR,dwSidWith1SubAuthority); <br>  psidLogonIdsSid      = (PSID)LocalAlloc(LPTR,dwSidWith3SubAuthorities); <br>  psidServiceSid       = (PSID)LocalAlloc(LPTR,dwSidWith1SubAuthority); <br>  psidLocalSystemSid   = (PSID)LocalAlloc(LPTR,dwSidWith1SubAuthority); <br>  psidBuiltinDomainSid = (PSID)LocalAlloc(LPTR,dwSidWith1SubAuthority); <br> <br>  InitializeSid( psidNtAuthoritySid,   &amp;siaNtAuthority, 0 ); <br>  InitializeSid( psidDialupSid,        &amp;siaNtAuthority, 1 ); <br>  InitializeSid( psidNetworkSid,       &amp;siaNtAuthority, 1 ); <br>  InitializeSid( psidBatchSid,         &amp;siaNtAuthority, 1 ); <br>  InitializeSid( psidInteractiveSid,   &amp;siaNtAuthority, 1 ); <br>  InitializeSid( psidLogonIdsSid,      &amp;siaNtAuthority, 3 ); <br>  InitializeSid( psidServiceSid,       &amp;siaNtAuthority, 1 ); <br>  InitializeSid( psidLocalSystemSid,   &amp;siaNtAuthority, 1 ); <br>  InitializeSid( psidBuiltinDomainSid, &amp;siaNtAuthority, 1 ); <br> <br>  *(GetSidSubAuthority( psidDialupSid,        0 )) = SECURITY_DIALUP_RID; <br>  *(GetSidSubAuthority( psidNetworkSid,       0 )) = SECURITY_NETWORK_RID; <br>  *(GetSidSubAuthority( psidBatchSid,         0 )) = SECURITY_BATCH_RID; <br>  *(GetSidSubAuthority( psidInteractiveSid,   0 )) = SECURITY_INTERACTIVE_RID; <br>  *(GetSidSubAuthority( psidLogonIdsSid,      0 )) = SECURITY_LOGON_IDS_RID; <br>  *(GetSidSubAuthority( psidLogonIdsSid,      1 )) = 0; // Bogus! <br>  *(GetSidSubAuthority( psidLogonIdsSid,      2 )) = 0; // Also bogus! <br>  *(GetSidSubAuthority( psidServiceSid,       0 )) = SECURITY_SERVICE_RID; <br>  *(GetSidSubAuthority( psidLocalSystemSid,   0 )) = SECURITY_LOCAL_SYSTEM_RID; <br>  *(GetSidSubAuthority( psidBuiltinDomainSid, 0 )) = SECURITY_BUILTIN_DOMAIN_RID; <br>} <br>  <br>/****************************************************************************\ <br>* <br>* FUNCTION: DisplayHelp <br>* <br>\****************************************************************************/ <br> <br>VOID DisplayHelp(VOID) <br>{ <br>  printf("\nTo run type CHECK_SD and 0 or 1 parameters.  Syntax:"); <br>  printf("\n  CHECK_SD"); <br>  printf("\n      or"); <br>  printf("\n  CHECK_SD filename"); <br>  printf("\n           filename is the name of the file that is passed"); <br>  printf("\n             to GetFileSecurity() to fetch the SD to examine"); <br>  printf("\nExamples:"); <br>  printf("\n  CHECK_SD            Checks the SD on A: (this is the default)"); <br>  printf("\n  CHECK_SD \\\\.\\A:     Checks the SD on A:"); <br>  printf("\n  CHECK_SD d:\\a.fil   Checks the SD on d:\a.fil"); <br>  printf("\n  CHECK_SD A:         Checks the SD on the A: root, but that"); <br>  printf("\n                        is not where the DACL is that controls"); <br>  printf("\n                        access to the floppy, so don't do this"); <br>} <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
