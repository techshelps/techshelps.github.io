<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DOMTRUST.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6176"></a>DOMTRUST.C</h2>
<pre><code>/*++ <br> <br>Copyright 1996 - 1997 Microsoft Corporation <br> <br>Module Name: <br> <br>    domtrust.c <br> <br>Abstract: <br> <br>    This sample illustrates how to manage Windows NT trusted domains at the <br>    domain controller level. <br> <br>    The first command line argument indicates the name of the new or existing <br>    trusted domain to create or modify. <br> <br>    The second command line argument indicates the new password for the <br>    trusted domain specified in the first argument. <br> <br>    The optional third argument indicates the domain name that is the target <br>    of the trusted domain update operation. If this argument is not specified, <br>    the update will occur on the local domain. Note that this sample will not <br>    allow a trusted domain update to occur on a non-domain controller. <br> <br>    This sample works correctly compiled ANSI or Unicode. Note that LAN <br>    Manager NetXxx API are Unicode only, and Windows NT LSA API are Unicode <br>    only. <br> <br>Author: <br> <br>    Scott Field (sfield)    05-Feb-96 <br> <br>--*/ <br> <br>#ifndef UNICODE <br>#define UNICODE <br>#define _UNICODE <br>#endif <br> <br>#include &lt;windows.h&gt; <br>#include &lt;lm.h&gt;         // for NetXxx API <br> <br>#include "ntsecapi.h"   // \mstools\samples\win32\winnt\security\include\ntsecapi.h <br> <br>#include &lt;stdio.h&gt; <br> <br>void <br>InitLsaString( <br>    PLSA_UNICODE_STRING LsaString, <br>    LPWSTR String <br>    ); <br> <br>NTSTATUS <br>OpenPolicy( <br>    LPWSTR ServerName, <br>    DWORD DesiredAccess, <br>    PLSA_HANDLE PolicyHandle <br>    ); <br> <br>BOOL <br>GetDomainSid( <br>    LPWSTR DomainName,  // domain name to acquire Sid of <br>    PSID *pDomainSid    // points to allocated Sid on success <br>    ); <br> <br>NTSTATUS <br>SetTrustedDomainInfo( <br>    LSA_HANDLE PolicyHandle, <br>    PSID DomainSid,             // Sid of domain to manipulate <br>    LPWSTR TrustedDomainName,   // trusted domain name to add/update <br>    LPWSTR Password             // new trust password for trusted domain <br>    ); <br> <br>BOOL <br>VerifyTrustRelationship( <br>    LPWSTR TargetDomainName,        // domain name to verify trust at <br>    LPWSTR TrustAccountToVerify,    // trusted domain name to verify <br>    LPWSTR Password,                // password associated with trust <br>    LPBOOL bTrustVerified           // indicates if trust was verified <br>    ); <br> <br>void <br>DisplayNtStatus( <br>    LPSTR szAPI,    // ANSI string containing API name <br>    NTSTATUS Status <br>    ); <br> <br>void <br>DisplayError( <br>    LPSTR szAPI,    // pointer to failed API name <br>    DWORD dwLastError <br>    ); <br> <br>#define RTN_OK 0 <br>#define RTN_USAGE 1 <br>#define RTN_ERROR 13 <br> <br>// <br>// if you have the DDK, include Ntstatus.h <br>// <br>#ifndef STATUS_SUCCESS <br>#define STATUS_SUCCESS                  ((NTSTATUS)0x00000000L) <br>#define STATUS_OBJECT_NAME_NOT_FOUND    ((NTSTATUS)0xC0000034L) <br>#define STATUS_INVALID_SID              ((NTSTATUS)0xC0000078L) <br>#endif <br> <br>// <br>// Unicode entry point and argv <br>// <br> <br>int <br>__cdecl <br>wmain( <br>    int argc, <br>    wchar_t *argv[] <br>    ) <br>{ <br>    BOOL bAllocTargetDomain;    // did you allocate memory for target? <br>    LSA_HANDLE PolicyHandle; <br>    LPWSTR TargetDomainName;    // target domain of policy update <br>    LPWSTR DomainController;    // computer name where policy update <br>    PSID DomainSid; // allocated Sid representing domain to trust <br>    LPWSTR TrustedDomainName; <br>    LPWSTR Password; <br>    BOOL bTrustVerified; <br>    NET_API_STATUS nas; <br>    NTSTATUS Status; <br> <br>    if(argc &lt; 3) { <br>        fprintf(stderr, <br>            "Usage: %ls &lt;NewTrustedDomain&gt; &lt;Password&gt; [TargetDomain]\n", <br>            argv[0]); <br>        return RTN_USAGE; <br>    } <br> <br>    TrustedDomainName = argv[1];    // existing or new TrustedDomain <br>    Password = argv[2];             // new password for TrustedDomain <br> <br>    // <br>    // if a TargetDomain was specified, point to that. <br>    // if not, set TargetDomain to the current domain if a DC. <br>    // <br>    if(argc == 4 &amp;&amp; *argv[3] != L'\0') { <br>        TargetDomainName = argv[3]; // domain to update trust at <br>        bAllocTargetDomain = FALSE; // no memory allocated <br>    } <br>    else { <br>        PSERVER_INFO_101 si101; <br>        DWORD Type; <br>        PUSER_MODALS_INFO_2 umi2; <br> <br>        // <br>        // ensure that the local computer is a DC. This operation is only <br>        // appropriate against a domain controller. <br>        // <br>        nas = NetServerGetInfo(NULL, 101, (LPBYTE *)&amp;si101); <br>        if(nas != NERR_Success) { <br>            DisplayError("NetServerGetInfo", nas); <br>            return RTN_ERROR; <br>        } <br> <br>        Type = si101-&gt;sv101_type; <br>        NetApiBufferFree(si101); <br> <br>        if( !(Type &amp; SV_TYPE_DOMAIN_CTRL) &amp;&amp; <br>            !(Type &amp; SV_TYPE_DOMAIN_BAKCTRL) ) { <br>            printf("Error:  Specify a TargetDomain; this operation" <br>                    " is only valid against a domain.\n"); <br>            return RTN_ERROR; <br>        } <br> <br>        // <br>        // obtain the local computer's domain name <br>        // <br>        nas = NetUserModalsGet(NULL, 2, (LPBYTE *)&amp;umi2); <br> <br>        if(nas != NERR_Success) { <br>            DisplayError("NetUserModalsGet", nas); <br>            return RTN_ERROR; <br>        } <br> <br>        // <br>        // copy the domain name to new storage <br>        // <br>        TargetDomainName = (LPWSTR)HeapAlloc(GetProcessHeap(), 0, <br>            (lstrlenW(umi2-&gt;usrmod2_domain_name) + 1) * sizeof(WCHAR)); <br> <br>        if(TargetDomainName != NULL) { <br>            lstrcpyW(TargetDomainName, umi2-&gt;usrmod2_domain_name); <br>            bAllocTargetDomain = TRUE; // we allocated memory <br>        } <br> <br>        NetApiBufferFree(umi2); // free memory allocated by NetXxx <br> <br>        // <br>        // if an error occurred allocating memory, exit <br>        // <br>        if(TargetDomainName == NULL) { <br>            DisplayError("HeapAlloc", 0); <br>            return RTN_ERROR; <br>        } <br>    } <br> <br>    // <br>    // do not allow a Domain to trust itself <br>    // <br>    if(lstrcmpiW(TargetDomainName, TrustedDomainName) == 0) { <br>        fprintf(stderr,"Error:  Domain %ls cannot trust itself.\n", <br>            TargetDomainName); <br> <br>        return RTN_ERROR; <br>    } <br> <br>    // <br>    // ensure Password and TrustedDomainName are the correct length <br>    // <br>    if(lstrlenW(Password) &gt; LM20_PWLEN) <br>        Password[LM20_PWLEN] = L'\0'; // truncate <br> <br>    if(lstrlenW(TrustedDomainName) &gt; MAX_COMPUTERNAME_LENGTH) <br>        TrustedDomainName[MAX_COMPUTERNAME_LENGTH] = L'\0'; // truncate <br> <br>    // <br>    // obtain the primary DC computer name from the specified <br>    // TargetDomainName <br>    // <br>    nas = NetGetDCName( <br>        NULL, TargetDomainName, (LPBYTE *)&amp;DomainController); <br> <br>    if(nas != NERR_Success) { <br>        DisplayError("NetGetDCName", nas); <br>        return RTN_ERROR; <br>    } <br> <br>    // <br>    // verify the trust relationship <br>    // <br>    if(!VerifyTrustRelationship( <br>        TrustedDomainName, <br>        TargetDomainName,   // trust account to verify <br>        Password, <br>        &amp;bTrustVerified <br>        )) { <br>        // <br>        // an error occurred during trust relationship verification <br>        // <br>        DisplayError("VerifyTrustRelationship", GetLastError()); <br>    } <br>    else { <br>        // <br>        // inform the user if the trust was not verified <br>        // <br>        if(!bTrustVerified) { <br>            DWORD dwTrustVerifyFailReason = GetLastError(); <br> <br>            // <br>            // You could exit here, but this is optional. Reasons for <br>            // trust verification failure could be non-existent <br>            // "permitted to trust" on the verified domain (rc=1317), <br>            // wrong password (rc=1326), etc <br>            // <br>            printf("Warning:  "); <br> <br>            switch(dwTrustVerifyFailReason) { <br>                case ERROR_NO_SUCH_USER: <br>                    printf("%ls not permitted-to-trust on %ls\n", <br>                        TargetDomainName, TrustedDomainName); <br>                    break; <br> <br>                case ERROR_LOGON_FAILURE: <br>                    printf("Trust %ls has incorrect password on %ls\n", <br>                        TrustedDomainName, TargetDomainName); <br>                    break; <br> <br>                default: <br>                    DisplayError("Trust was not verified.  Non-fatal", <br>                        dwTrustVerifyFailReason); <br>            } // switch <br>        } <br>    } <br> <br>    // <br>    // fetch the DomainSid of the domain to trust <br>    // <br>    if(!GetDomainSid(TrustedDomainName, &amp;DomainSid)) { <br>        DisplayError("GetDomainSid", GetLastError()); <br>        return RTN_ERROR; <br>    } <br> <br>    // <br>    // open the policy on the target domain <br>    // <br>    Status = OpenPolicy( <br>                DomainController, <br>                POLICY_CREATE_SECRET |  // for password set operation <br>                POLICY_TRUST_ADMIN,     // for trust creation <br>                &amp;PolicyHandle <br>                ); <br> <br>    if(Status != STATUS_SUCCESS) { <br>        DisplayNtStatus("OpenPolicy", Status); <br>        return RTN_ERROR; <br>    } <br> <br>    // <br>    // Update TrustedDomainInfo to reflect the specified trust. <br>    // <br>    Status = SetTrustedDomainInfo( <br>        PolicyHandle, <br>        DomainSid, <br>        TrustedDomainName, <br>        Password <br>        ); <br> <br>    if(Status != STATUS_SUCCESS) { <br>        DisplayNtStatus("SetTrustedDomainInfo", Status); <br>        return RTN_ERROR; <br>    } <br> <br>    // <br>    // if you allocated memory for TargetDomainName, free it <br>    // <br>    if(bAllocTargetDomain) <br>        HeapFree(GetProcessHeap(), 0, TargetDomainName); <br> <br>    // <br>    // free the Sid which was allocated for the TrustedDomain Sid <br>    // <br>    FreeSid(DomainSid); <br> <br>    // <br>    // close the policy handle <br>    // <br>    LsaClose(PolicyHandle); <br> <br>    if(DomainController != NULL) <br>        NetApiBufferFree(DomainController); <br> <br>    return RTN_OK; <br>} <br> <br>void <br>InitLsaString( <br>    PLSA_UNICODE_STRING LsaString, <br>    LPWSTR String <br>    ) <br>{ <br>    DWORD StringLength; <br> <br>    if(String == NULL) { <br>        LsaString-&gt;Buffer = NULL; <br>        LsaString-&gt;Length = 0; <br>        LsaString-&gt;MaximumLength = 0; <br> <br>        return; <br>    } <br> <br>    StringLength = lstrlenW(String); <br>    LsaString-&gt;Buffer = String; <br>    LsaString-&gt;Length = (USHORT) StringLength * sizeof(WCHAR); <br>    LsaString-&gt;MaximumLength = (USHORT) (StringLength + 1) * <br>        sizeof(WCHAR); <br>} <br> <br>NTSTATUS <br>OpenPolicy( <br>    LPWSTR ServerName, <br>    DWORD DesiredAccess, <br>    PLSA_HANDLE PolicyHandle <br>    ) <br>{ <br>    LSA_OBJECT_ATTRIBUTES ObjectAttributes; <br>    LSA_UNICODE_STRING ServerString; <br>    PLSA_UNICODE_STRING Server; <br> <br>    // <br>    // Always initialize the object attributes to all zeroes <br>    // <br>    ZeroMemory(&amp;ObjectAttributes, sizeof(ObjectAttributes)); <br> <br>    if(ServerName != NULL) { <br>        // <br>        // Make a LSA_UNICODE_STRING out of the LPWSTR passed in <br>        // <br>        InitLsaString(&amp;ServerString, ServerName); <br> <br>        Server = &amp;ServerString; <br>    } else { <br>        Server = NULL; <br>    } <br> <br>    // <br>    // Attempt to open the policy <br>    // <br>    return LsaOpenPolicy( <br>                Server, <br>                &amp;ObjectAttributes, <br>                DesiredAccess, <br>                PolicyHandle <br>                ); <br>} <br> <br>/*++ <br> This function retrieves the Sid representing the specified DomainName. <br> <br> If the function succeeds, the return value is TRUE and pDomainSid will <br> point to the Sid representing the specified DomainName. The caller <br> should free the memory associated with this Sid with the Win32 API <br> FreeSid() when the Sid is no longer needed. <br> <br> If the function fails, the return value is FALSE, and pDomainSid will <br> be set to NULL. <br> <br>--*/ <br> <br>BOOL <br>GetDomainSid( <br>    LPWSTR DomainName,  // domain name to acquire Sid of <br>    PSID *pDomainSid    // points to allocated Sid on success <br>    ) <br>{ <br>    NET_API_STATUS nas; <br>    LPWSTR DomainController; <br>    PUSER_MODALS_INFO_2 umi2 = NULL; <br>    DWORD dwSidSize; <br>    BOOL bSuccess = FALSE; // assume this function will fail <br> <br>    *pDomainSid = NULL; // invalidate pointer <br> <br>    // <br>    // obtain the PDC computer name of the supplied domain name <br>    // <br>    nas = NetGetDCName(NULL, DomainName, (LPBYTE *)&amp;DomainController); <br>    if(nas != NERR_Success) { <br>        SetLastError(nas); <br>        return FALSE; <br>    } <br> <br>    __try { <br> <br>    // <br>    // obtain the domain Sid from the PDC <br>    // NOTE: this may fail if the credentials of the caller are not <br>    // recognized or valid on the target computer. In this case, it <br>    // is necessary to first establish a connection via NetUseAdd() <br>    // at info-level 2 to the remote IPC$, specifying EMPTY <br>    // credentials. <br>    // <br>    nas = NetUserModalsGet(DomainController, 2, (LPBYTE *)&amp;umi2); <br>    if(nas != NERR_Success) __leave; <br> <br>    // <br>    // if the Sid is valid, obtain the size of the Sid <br>    // <br>    if(!IsValidSid(umi2-&gt;usrmod2_domain_id)) __leave; <br>    dwSidSize = GetLengthSid(umi2-&gt;usrmod2_domain_id); <br> <br>    // <br>    // allocate storage and copy the Sid <br>    // <br>    *pDomainSid = (PSID)HeapAlloc(GetProcessHeap(), 0, dwSidSize); <br>    if(*pDomainSid == NULL) __leave; <br> <br>    if(!CopySid(dwSidSize, *pDomainSid, umi2-&gt;usrmod2_domain_id)) <br>        __leave; <br> <br>    bSuccess = TRUE; // indicate success <br> <br>    } // try <br>    __finally { <br> <br>    // <br>    // free allocated memory <br>    // <br>    NetApiBufferFree(DomainController); <br> <br>    if(umi2 != NULL) <br>        NetApiBufferFree(umi2); <br> <br>    if(!bSuccess) { <br>        // <br>        // if the function failed, free memory and indicate result code <br>        // <br> <br>        if(*pDomainSid != NULL) { <br>            FreeSid(*pDomainSid); <br>            *pDomainSid = NULL; <br>        } <br> <br>        if(nas != NERR_Success) { <br>            SetLastError(nas); <br>        } <br>    } <br> <br>    } <br>    return bSuccess; <br>} <br> <br>/*++ <br> This function manipulates the trust associated with the supplied <br> DomainSid. <br> <br> If the domain trust does not exist, it is created with the <br> specified password. In this case, the supplied PolicyHandle must <br> have been opened with POLICY_TRUST_ADMIN and POLICY_CREATE_SECRET <br> access to the policy object. <br> <br> If the domain trust exists, the password is updated with the <br> password specified by the Password parameter. The trust OldPassword <br> is set to the previous password. <br> <br> If DomainName and Password are NULL, the trusted domain specified by <br> DomainSid is deleted. <br> <br>--*/ <br> <br>NTSTATUS <br>SetTrustedDomainInfo( <br>    LSA_HANDLE PolicyHandle, <br>    PSID DomainSid,             // Sid of domain to manipulate <br>    LPWSTR TrustedDomainName,   // trusted domain name to add/update <br>    LPWSTR Password             // new trust password for trusted domain <br>    ) <br>{ <br>    PTRUSTED_PASSWORD_INFO tpi; <br>//    PTRUSTED_DOMAIN_NAME_INFO tdni; <br>    LSA_UNICODE_STRING LsaPassword; <br>    TRUSTED_PASSWORD_INFO Newtpi; <br>    BOOL bTrustExists = TRUE; // assume trust exists <br>    NTSTATUS Status; <br> <br>    // <br>    // Make sure you were passed a valid Sid <br>    // <br>    if(DomainSid == NULL || !IsValidSid(DomainSid)) <br>        return STATUS_INVALID_SID; <br> <br>    // <br>    // if TristedDomainName and Password is NULL (or emptry strings), <br>    // delete the specified trust <br>    // <br>    if( (TrustedDomainName == NULL || *TrustedDomainName == L'\0') &amp;&amp; <br>        (Password == NULL || *Password == L'\0') ) { <br>        return LsaDeleteTrustedDomain(PolicyHandle, DomainSid); <br>    } <br> <br>    // <br>    // query the current password, which is used to update the <br>    // OldPassword. If the trust doesn't exist, indicate this so that the <br>    // trust will be created. <br>    // <br>    Status = LsaQueryTrustedDomainInfo( <br>        PolicyHandle, <br>        DomainSid, <br>        TrustedPasswordInformation, <br>        &amp;tpi); <br> <br>    if(Status != STATUS_SUCCESS) { <br>        if(Status == STATUS_OBJECT_NAME_NOT_FOUND) { <br>            bTrustExists = FALSE; // indicate trust does not exist <br>        } <br>        else { <br>            DisplayNtStatus("LsaQueryTrustedDomainInfo", Status); <br>            return Status; <br>        } <br>    } <br> <br>    InitLsaString(&amp;LsaPassword, Password); <br> <br>    // <br>    // set the new password to the supplied password <br>    // <br>    Newtpi.Password = LsaPassword; <br> <br>    if(bTrustExists) { <br>        // <br>        // if the trust already existed, set OldPassword to the <br>        // current password... <br>        // <br>        Newtpi.OldPassword = tpi-&gt;Password; <br>    } <br>    else { <br>        LSA_UNICODE_STRING LsaDomainName; <br>        DWORD cchDomainName; // number of chars in TrustedDomainName <br> <br>        // <br>        // if the trust did not exist, set OldPassword to the <br>        // supplied password... <br>        // <br>        Newtpi.OldPassword = LsaPassword; <br> <br>        InitLsaString(&amp;LsaDomainName, TrustedDomainName); <br> <br>        // <br>        // ...convert TrustedDomainName to uppercase... <br>        // <br>        cchDomainName = LsaDomainName.Length / sizeof(WCHAR); <br>        while(cchDomainName--) { <br>            LsaDomainName.Buffer[cchDomainName] = <br>             towupper(LsaDomainName.Buffer[cchDomainName]); <br>        } <br> <br>        // <br>        // ...create the trusted domain object <br>        // <br>        Status = LsaSetTrustedDomainInformation( <br>            PolicyHandle, <br>            DomainSid, <br>            TrustedDomainNameInformation, <br>            &amp;LsaDomainName <br>            ); <br> <br>        if(Status != STATUS_SUCCESS) return Status; <br>    } <br> <br>    // <br>    // update TrustedPasswordInformation for the specified trust <br>    // <br>    Status = LsaSetTrustedDomainInformation( <br>        PolicyHandle, <br>        DomainSid, <br>        TrustedPasswordInformation, <br>        &amp;Newtpi <br>        ); <br> <br>    // <br>    // if a trust already existed, free the memory associated with <br>    // the retrieved information <br>    // <br>    if(bTrustExists) LsaFreeMemory(tpi); <br> <br>    return Status; <br>} <br> <br>/*++ <br> <br> This function verifies that the "permitted to trust" side of the <br> trust relationship has been established and that the specified <br> password matches the "permitted to trust" password. <br> <br> If the function fails, the return value is FALSE, and bTrustVerified <br> is undefined. <br> <br> If the function succeeds, the trust verification succeeded, and <br> bTrustVerified is set to the result of the verification. <br> <br> If bTrustVerified is TRUE, the trust relationship is verfied. <br> <br> If bTrustVerified is FALSE, the trust was not verified.  Call <br> GetLastError() to get extended error information. <br> <br> ERROR_NO_SUCH_USER indicates that the "permitted to trust" <br> UF_INTERDOMAIN_TRUST_ACCOUNT does not exist on the specified domain. <br> <br> ERROR_LOGON_FAILURE indicates that the supplied password does <br> not match the password in the "permitted to trust" <br> UF_INTERDOMAIN_TRUST_ACCOUNT. <br> <br> NOTE: if a connection exists to the domain controller of the <br> TargetDomainName prior to calling this function, this function will <br> fail due to a credential conflict (WinError == 1219). <br> <br>--*/ <br> <br>BOOL <br>VerifyTrustRelationship( <br>    LPWSTR TargetDomainName,        // domain name to verify trust at <br>    LPWSTR TrustAccountToVerify,    // trusted domain name to verify <br>    LPWSTR Password,                // password associated with trust <br>    LPBOOL bTrustVerified           // indicates if trust was verified <br>    ) <br>{ <br>    NET_API_STATUS nas; <br>    USE_INFO_2 ui2; <br>    LPWSTR DomainController; <br>    LPWSTR szIpc = L"\\IPC$"; <br>    LPWSTR RemoteResource = NULL; <br>    LPWSTR UserName = NULL; <br>    BOOL bSuccess = FALSE; // assume this function will fail <br> <br>    // <br>    // fetch the computer name of the domain you try to connect to <br>    // <br>    nas = NetGetDCName( <br>        NULL, TargetDomainName, (LPBYTE *)&amp;DomainController); <br>    if(nas != NERR_Success) { <br>        SetLastError(nas); <br>        return FALSE; <br>    } <br> <br>    __try { <br> <br>    // <br>    // build the \\&lt;DCName&gt;\ipc$ as the remote resource <br>    // <br>    RemoteResource = (LPWSTR)HeapAlloc(GetProcessHeap(), 0, <br>        (lstrlenW(DomainController) + lstrlenW(szIpc) + 1 ) * <br>            sizeof(WCHAR) <br>        ); <br> <br>    if(RemoteResource == NULL) __leave; <br> <br>    if(lstrcpyW(RemoteResource, DomainController) == NULL) __leave; <br>    if(lstrcatW(RemoteResource, szIpc) == NULL) __leave; <br> <br>    // <br>    // build the user name as &lt;TrustAccountToVerify&gt;$ <br>    // <br>    UserName = (LPWSTR)HeapAlloc(GetProcessHeap(), 0, <br>        (lstrlenW(TrustAccountToVerify) + 1 + 1) * sizeof(WCHAR) <br>        ); <br> <br>    if(UserName == NULL) __leave; <br> <br>    if(lstrcpyW(UserName, TrustAccountToVerify) == NULL) __leave; <br>    if(lstrcatW(UserName, L"$") == NULL) __leave; <br> <br>    ZeroMemory(&amp;ui2, sizeof(ui2)); <br> <br>    ui2.ui2_local = NULL; <br>    ui2.ui2_remote = RemoteResource; <br>    ui2.ui2_asg_type = USE_IPC; <br>    ui2.ui2_password = Password; <br>    ui2.ui2_username = UserName; <br>    ui2.ui2_domainname = TargetDomainName; <br> <br>    // <br>    // Attempt to establish a connection to the target domain. <br>    // If the result is ERROR_NOLOGON_INTERDOMAIN_TRUST_ACCOUNT, <br>    // this illustrates the supplied Password matches an existing <br>    // trust account because the credentials were validated but <br>    // a logon is not allowed for this account type. <br>    // <br>    nas = NetUseAdd(NULL, 2, (LPBYTE)&amp;ui2, NULL); <br> <br>    if(nas == ERROR_NOLOGON_INTERDOMAIN_TRUST_ACCOUNT) { <br>        *bTrustVerified = TRUE;     // indicate trust verified <br>    } <br>    else { <br>        *bTrustVerified = FALSE;    // indicate trust not verified <br> <br>        // <br>        // if the connection succeeded, the UF_INTERDOMAIN_TRUST_ACCOUNT <br>        // does not exist, because the supplied credentials aren't <br>        // recognized by the remote (default credentials are applied). <br>        // Delete the connection and indicate the "permitted to trust" <br>        // account is non-existent. <br>        // <br>        if(nas == NERR_Success) { <br>            NetUseDel(NULL, RemoteResource, 0); <br>            nas = ERROR_NO_SUCH_USER; <br>        } <br>    } <br> <br>    bSuccess = TRUE; // indicate this function succeeded <br> <br>    } // try <br>    __finally { <br> <br>    // <br>    // free allocated memory <br>    // <br>    NetApiBufferFree(DomainController); <br> <br>    if(RemoteResource != NULL) { <br>        HeapFree(GetProcessHeap(), 0, RemoteResource); <br>    } <br> <br>    if(UserName != NULL) { <br>        HeapFree(GetProcessHeap(), 0, UserName); <br>    } <br> <br>    // <br>    // if you succeeded, but trust could not be verified, indicate why <br>    // <br>    if(bSuccess == TRUE &amp;&amp; *bTrustVerified == FALSE) { <br>        SetLastError(nas); <br>    } <br> <br>    } <br> <br>    return bSuccess; <br>} <br> <br>void <br>DisplayNtStatus( <br>    LPSTR szAPI,    // ANSI string containing API name <br>    NTSTATUS Status <br>    ) <br>{ <br>    // <br>    // convert the NTSTATUS to Winerror and display the result <br>    // <br>    DisplayError(szAPI, LsaNtStatusToWinError(Status)); <br>} <br> <br> <br>void <br>DisplayError( <br>    LPSTR szAPI,    // pointer to failed API name <br>    DWORD dwLastError <br>    ) <br>{ <br>    HMODULE hModule = NULL; <br>    LPSTR MessageBuffer; <br>    DWORD dwBufferLength; <br> <br>    fprintf(stderr,"%s error! (rc=%lu)\n", szAPI, dwLastError); <br> <br>    if(dwLastError &gt;= NERR_BASE &amp;&amp; dwLastError &lt;= MAX_NERR) { <br>        hModule = LoadLibraryEx( <br>            TEXT("netmsg.dll"), <br>            NULL, <br>            LOAD_LIBRARY_AS_DATAFILE <br>            ); <br>    } <br> <br>    if(dwBufferLength=FormatMessageA( <br>        FORMAT_MESSAGE_ALLOCATE_BUFFER | <br>        FORMAT_MESSAGE_IGNORE_INSERTS | <br>        FORMAT_MESSAGE_FROM_SYSTEM | <br>        ((hModule != NULL) ? FORMAT_MESSAGE_FROM_HMODULE : 0), <br>        hModule, // module to get message from <br>        dwLastError, <br>        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // default language <br>        (LPSTR) &amp;MessageBuffer, <br>        0, <br>        NULL <br>        )) <br>    { <br>        DWORD dwBytesWritten; <br> <br>        // <br>        // Output message string on stderr <br>        // <br>        WriteFile( <br>            GetStdHandle(STD_ERROR_HANDLE), <br>            MessageBuffer, <br>            dwBufferLength, <br>            &amp;dwBytesWritten, <br>            NULL <br>            ); <br> <br>        // <br>        // free the buffer allocated by the system <br>        // <br>        LocalFree(MessageBuffer); <br>    } <br> <br>    if(hModule != NULL) <br>        FreeLibrary(hModule); <br>} <br> <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
