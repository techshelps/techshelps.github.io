<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>AUDIT.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6172"></a>AUDIT.C</h2>
<pre><code>/*++ <br> <br>Copyright 1996 - 1997 Microsoft Corporation <br> <br>Module Name: <br> <br>    audit.c <br> <br>Abstract: <br> <br>    This module illustrates how to use the Windows NT LSA security API <br>    to manage the audit status on the local machine or a remote machine. <br> <br>    Querying the current audit status is illustrated, in addition to <br>    changing the audit state of an audit event type.  Enabling and <br>    disabling all auditing is also illustrated. <br> <br>    When targetting a domain controller for an audit update operation, <br>    be sure to target the primary domain controller for the domain. <br>    The audit settings are replicated by the primary domain controller <br>    to each backup domain controller as appropriate.  The NetGetDCName() <br>    Lan Manager API call can be used to get the primary domain controller <br>    computer name from a domain name. <br> <br>    This sample will target the local machine if no command line argument is <br>    specified, or the machine specified on argv[1], eg. audit.exe \\winbase <br> <br>    The sample relies on the ntsecapi.h header file found in the Win32SDK <br>    \mstools\security directory. <br> <br>Author: <br> <br>    Scott Field (sfield)    13-Apr-96 <br> <br>--*/ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;stdio.h&gt; <br> <br>#include "ntsecapi.h" // \mstools\samples\win32\winnt\security\include\ntsecapi.h <br> <br>#define RTN_OK 0 <br>#define RTN_USAGE 1 <br>#define RTN_ERROR 13 <br> <br>// <br>// if you have the ddk, include ntstatus.h <br>// <br>#ifndef STATUS_SUCCESS <br>#define STATUS_SUCCESS              ((NTSTATUS)0x00000000L) <br>#define STATUS_INVALID_PARAMETER    ((NTSTATUS)0xC000000DL) <br>#endif <br> <br> <br>NTSTATUS <br>DisplayAudit( <br>    LSA_HANDLE PolicyHandle <br>    ); <br> <br>void <br>DisplayAuditEventOption( <br>    DWORD EventTypeIndex, <br>    POLICY_AUDIT_EVENT_OPTIONS EventOption <br>    ); <br> <br>NTSTATUS <br>SetAuditEvent( <br>    LSA_HANDLE PolicyHandle, <br>    POLICY_AUDIT_EVENT_TYPE EventType, <br>    POLICY_AUDIT_EVENT_OPTIONS EventOption <br>    ); <br> <br>NTSTATUS <br>SetAuditMode( <br>    LSA_HANDLE PolicyHandle, <br>    BOOL bEnable <br>    ); <br> <br>// <br>// helper functions <br>// <br> <br>NTSTATUS <br>OpenPolicy( <br>    LPWSTR ServerName, <br>    DWORD DesiredAccess, <br>    PLSA_HANDLE PolicyHandle <br>    ); <br> <br>void <br>InitLsaString( <br>    PLSA_UNICODE_STRING LsaString, <br>    LPWSTR String <br>    ); <br> <br>void <br>DisplayNtStatus( <br>    LPSTR szAPI,        // pointer to Ansi function name <br>    NTSTATUS Status     // NTSTATUS error value <br>    ); <br> <br>void <br>DisplayWinError( <br>    LPSTR szAPI,    // pointer to Ansi function name <br>    DWORD dwError   // DWORD WinError <br>    ); <br> <br>// <br>// unicode entry point and argv <br>// <br>int <br>__cdecl <br>wmain( <br>    int argc, <br>    wchar_t *argv[] <br>    ) <br>{ <br>    LPWSTR wComputerName; <br>    LSA_HANDLE PolicyHandle; <br>    NTSTATUS Status; <br> <br>    // <br>    // pickup machine name if appropriate <br>    // <br>    if(argc == 2) <br>        wComputerName = argv[1]; <br>    else <br>        wComputerName = NULL; // local machine <br> <br>    // <br>    // display current audit state <br>    // <br> <br>    Status = OpenPolicy( <br>                wComputerName, <br>                POLICY_VIEW_AUDIT_INFORMATION, <br>                &amp;PolicyHandle <br>                ); <br> <br>    if(Status == STATUS_SUCCESS) { <br>        // <br>        // display current auditing status <br>        // <br>        Status = DisplayAudit(PolicyHandle); <br> <br>        LsaClose(PolicyHandle); <br> <br>        if(Status != STATUS_SUCCESS) { <br>            DisplayNtStatus("DisplayAudit", Status); <br>            return RTN_ERROR; <br>        } <br>    } else { <br>        DisplayNtStatus("OpenPolicy", Status); <br>        return RTN_ERROR; <br>    } <br> <br>    // <br>    // enable success and failure audits of logon/logoff events <br>    // <br> <br>    Status = OpenPolicy( <br>                wComputerName, <br>                POLICY_VIEW_AUDIT_INFORMATION | <br>                POLICY_SET_AUDIT_REQUIREMENTS, <br>                &amp;PolicyHandle <br>                ); <br> <br>    if(Status == STATUS_SUCCESS) { <br> <br>        // <br>        // enable success and failure auditing of logon/logoff <br>        // <br>        Status = SetAuditEvent( <br>            PolicyHandle, <br>            AuditCategoryLogon, <br>            POLICY_AUDIT_EVENT_SUCCESS | POLICY_AUDIT_EVENT_FAILURE <br>            ); <br> <br>        // <br>        // enable audits <br>        // <br>        if( Status == STATUS_SUCCESS ) <br>            Status = SetAuditMode(PolicyHandle, TRUE); <br> <br>        LsaClose(PolicyHandle); <br> <br>        if(Status != STATUS_SUCCESS) { <br>            DisplayNtStatus("SetAuditMode", Status); <br>            return RTN_ERROR; <br>        } <br>    } else { <br>        DisplayNtStatus("OpenPolicy", Status); <br>        return RTN_ERROR; <br>    } <br> <br>    return RTN_OK; <br>} <br> <br> <br>NTSTATUS <br>DisplayAudit( <br>    LSA_HANDLE PolicyHandle <br>    ) <br>{ <br>    PPOLICY_AUDIT_EVENTS_INFO AuditEvents; <br>    NTSTATUS Status; <br>    DWORD i; // index into EventAuditingOptions <br> <br>    // <br>    // obtain AuditEvents <br>    // <br>    Status = LsaQueryInformationPolicy( <br>                PolicyHandle, <br>                PolicyAuditEventsInformation, <br>                &amp;AuditEvents <br>                ); <br> <br>    if(Status != STATUS_SUCCESS) return Status; <br> <br>    // <br>    // successfully obtained AuditEventsInformation.  Now display. <br>    // <br>    if(AuditEvents-&gt;AuditingMode) { <br>        printf("Auditing Enabled\n"); <br>    } else { <br>        printf("Auditing Disabled\n"); <br>    } <br> <br>    for(i = 0 ; i &lt; AuditEvents-&gt;MaximumAuditEventCount ; i++) { <br>        DisplayAuditEventOption(i, AuditEvents-&gt;EventAuditingOptions[i]); <br>    } <br> <br>    // <br>    // free allocated memory <br>    // <br>    LsaFreeMemory(AuditEvents); <br> <br>    return Status; <br>} <br> <br>void <br>DisplayAuditEventOption( <br>    DWORD EventTypeIndex, <br>    POLICY_AUDIT_EVENT_OPTIONS EventOption <br>    ) <br>{ <br>    printf("AuditCategory"); <br> <br>    switch (EventTypeIndex) { <br>        case AuditCategorySystem: <br>        printf("System"); <br>        break; <br> <br>        case AuditCategoryLogon: <br>        printf("Logon"); <br>        break; <br> <br>        case AuditCategoryObjectAccess: <br>        printf("ObjectAccess"); <br>        break; <br> <br>        case AuditCategoryPrivilegeUse: <br>        printf("PrivilegeUse"); <br>        break; <br> <br>        case AuditCategoryDetailedTracking: <br>        printf("DetailedTracking"); <br>        break; <br> <br>        case AuditCategoryPolicyChange: <br>        printf("PolicyChange"); <br>        break; <br> <br>        case AuditCategoryAccountManagement: <br>        printf("AccountManagement"); <br>        break; <br> <br>        default: <br>        printf("Unknown"); <br>    } <br> <br>    if(EventOption &amp; POLICY_AUDIT_EVENT_SUCCESS) <br>        printf(" AUDIT_EVENT_SUCCESS"); <br> <br>    if(EventOption &amp; POLICY_AUDIT_EVENT_FAILURE) <br>        printf(" AUDIT_EVENT_FAILURE"); <br> <br>    printf("\n"); <br>} <br> <br>NTSTATUS <br>SetAuditEvent( <br>    LSA_HANDLE PolicyHandle, <br>    POLICY_AUDIT_EVENT_TYPE EventType, <br>    POLICY_AUDIT_EVENT_OPTIONS EventOption <br>    ) <br>{ <br>    PPOLICY_AUDIT_EVENTS_INFO pae; <br>    NTSTATUS Status; <br>    DWORD i; // index into EventAuditingOptions <br> <br>    // <br>    // obtain AuditEvents <br>    // <br>    Status = LsaQueryInformationPolicy( <br>                PolicyHandle, <br>                PolicyAuditEventsInformation, <br>                &amp;pae <br>                ); <br> <br>    if(Status != STATUS_SUCCESS) return Status; <br> <br>    // <br>    // insure we were passed a valid EventType and EventOption <br>    // <br>    if((ULONG)EventType &gt; pae-&gt;MaximumAuditEventCount || <br>      (!EventOption &amp; POLICY_AUDIT_EVENT_MASK) ) { <br>        LsaFreeMemory(pae); <br>        return STATUS_INVALID_PARAMETER; <br>    } <br> <br>    // <br>    // set all auditevents to the unchanged status... <br>    // <br>    for(i = 0 ; i &lt; pae-&gt;MaximumAuditEventCount ; i++) { <br>        pae-&gt;EventAuditingOptions[i] = POLICY_AUDIT_EVENT_UNCHANGED; <br>    } <br> <br>    // <br>    // ...and update only the specified EventType <br>    // <br>    pae-&gt;EventAuditingOptions[EventType] = EventOption; <br> <br>    // <br>    // set the new AuditEvents <br>    // <br>    Status = LsaSetInformationPolicy( <br>                PolicyHandle, <br>                PolicyAuditEventsInformation, <br>                pae <br>                ); <br> <br>    // <br>    // free allocated memory <br>    // <br>    LsaFreeMemory(pae); <br> <br>    return Status; <br>} <br> <br>NTSTATUS <br>SetAuditMode( <br>    LSA_HANDLE PolicyHandle, <br>    BOOL bEnable <br>    ) <br>{ <br>    PPOLICY_AUDIT_EVENTS_INFO AuditEvents; <br>    NTSTATUS Status; <br>    DWORD i; <br> <br>    // <br>    // obtain current AuditEvents <br>    // <br>    Status = LsaQueryInformationPolicy( <br>                PolicyHandle, <br>                PolicyAuditEventsInformation, <br>                &amp;AuditEvents <br>                ); <br> <br>    if(Status != STATUS_SUCCESS) return Status; <br> <br>    // <br>    // update the relevant member <br>    // <br>    AuditEvents-&gt;AuditingMode = bEnable; <br> <br>    // <br>    // set all auditevents to the unchanged status... <br>    // <br>    for(i = 0 ; i &lt; AuditEvents-&gt;MaximumAuditEventCount ; i++) { <br>        AuditEvents-&gt;EventAuditingOptions[i] = POLICY_AUDIT_EVENT_UNCHANGED; <br>    } <br> <br>    // <br>    // set the new auditing mode (enabled or disabled) <br>    // <br>    Status = LsaSetInformationPolicy( <br>                PolicyHandle, <br>                PolicyAuditEventsInformation, <br>                AuditEvents <br>                ); <br> <br>    LsaFreeMemory(AuditEvents); <br> <br>    return Status; <br>} <br> <br>void <br>InitLsaString( <br>    PLSA_UNICODE_STRING LsaString, <br>    LPWSTR String <br>    ) <br>{ <br>    DWORD StringLength; <br> <br>    if(String == NULL) { <br>        LsaString-&gt;Buffer = NULL; <br>        LsaString-&gt;Length = 0; <br>        LsaString-&gt;MaximumLength = 0; <br> <br>        return; <br>    } <br> <br>    StringLength = lstrlenW(String); <br>    LsaString-&gt;Buffer = String; <br>    LsaString-&gt;Length = (USHORT) StringLength * sizeof(WCHAR); <br>    LsaString-&gt;MaximumLength = (USHORT) (StringLength + 1) * <br>        sizeof(WCHAR); <br>} <br> <br>NTSTATUS <br>OpenPolicy( <br>    LPWSTR ServerName, <br>    DWORD DesiredAccess, <br>    PLSA_HANDLE PolicyHandle <br>    ) <br>{ <br>    PLSA_UNICODE_STRING Server; <br>    LSA_OBJECT_ATTRIBUTES ObjectAttributes; <br>    LSA_UNICODE_STRING ServerString; <br> <br>    // <br>    // Always initialize the object attributes to all zeroes <br>    // <br>    ZeroMemory(&amp;ObjectAttributes, sizeof(ObjectAttributes)); <br> <br>    if(ServerName != NULL) { <br>        // <br>        // Make a LSA_UNICODE_STRING out of the LPWSTR passed in <br>        // <br>        InitLsaString(&amp;ServerString, ServerName); <br>        Server = &amp;ServerString; <br>    } else { <br>        Server = NULL; // default to local machine <br>    } <br> <br>    // <br>    // Attempt to open the policy and return NTSTATUS <br>    // <br>    return LsaOpenPolicy( <br>                Server, <br>                &amp;ObjectAttributes, <br>                DesiredAccess, <br>                PolicyHandle <br>                ); <br>} <br> <br>void <br>DisplayNtStatus( <br>    LPSTR szAPI, <br>    NTSTATUS Status <br>    ) <br>{ <br>    // <br>    // convert the NTSTATUS to Winerror and DisplayWinError() <br>    // <br>    DisplayWinError(szAPI, LsaNtStatusToWinError(Status) ); <br>} <br> <br>void <br>DisplayWinError( <br>    LPSTR szAPI,    // pointer to Ansi function name <br>    DWORD dwError   // DWORD WinError <br>    ) <br>{ <br>    LPSTR MessageBuffer; <br>    DWORD dwBufferLength; <br> <br>    // <br>    // TODO get this fprintf out of here! <br>    // <br>    fprintf(stderr,"%s error!\n", szAPI); <br> <br>    if(dwBufferLength=FormatMessageA( <br>            FORMAT_MESSAGE_ALLOCATE_BUFFER | <br>            FORMAT_MESSAGE_FROM_SYSTEM, <br>            NULL, <br>            dwError, <br>            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), <br>            (LPSTR) &amp;MessageBuffer, <br>            0, <br>            NULL <br>            )) <br>    { <br>        DWORD dwBytesWritten; // unused <br> <br>        // <br>        // Output message string on stderr <br>        // <br>        WriteFile( <br>                GetStdHandle(STD_ERROR_HANDLE), <br>                MessageBuffer, <br>                dwBufferLength, <br>                &amp;dwBytesWritten, <br>                NULL <br>                ); <br> <br>        // <br>        // free the buffer allocated by the system <br>        // <br>        LocalFree(MessageBuffer); <br>    } <br>} <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
