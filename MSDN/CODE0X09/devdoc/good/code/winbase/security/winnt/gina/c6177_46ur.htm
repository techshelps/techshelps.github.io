<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>LOGON.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6183"></a>LOGON.C</h2>
<pre><code>//+--------------------------------------------------------------------------- <br>// <br>//  Microsoft Windows <br>//  Copyright 1992 - 1998 Microsoft Corporation. <br>// <br>//  File:       logon.c <br>// <br>//  Contents: <br>// <br>//  Classes: <br>// <br>//  Functions: <br>// <br>//  History:    4-28-95   RichardW   Created <br>// <br>//---------------------------------------------------------------------------- <br> <br>#include "gina.h" <br>#pragma hdrstop <br> <br>HIMAGELIST      hiLogonSmall; <br>HIMAGELIST      hiLogonLarge; <br>PMiniAccount    pAccountList; <br>WCHAR           szMiniKey[] = TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\Accounts"); <br> <br>BYTE            LongPseudoRandomString[] = {0x27, 0xbd, 0xff, 0xa0, <br>                                            0xaf, 0xbf, 0x00, 0x1c, <br>                                            0x24, 0x0e, 0x00, 0x01, <br>                                            0x24, 0x0f, 0x00, 0x05 }; <br> <br> <br>MiniAccount TestAccounts[]  = { {NULL, TEXT("daveth"), TEXT("\\msft\\risc\\dev"), TEXT("daveth"), TEXT("Oooh"), 0, MINI_CAN_EDIT}, <br>                                {NULL, TEXT("Test1"), TEXT("Redmond"), TEXT("Test1"), TEXT("Mine"), 0, MINI_CAN_EDIT}, <br>                                {NULL, TEXT("Test2"), TEXT("NtWksta"), TEXT("Test2"), TEXT("Yours"), 0, 0}, <br>                                {NULL, TEXT("New User"), TEXT(""), TEXT(""), TEXT(""), 0, MINI_NEW_ACCOUNT} <br> <br>                              }; <br> <br>BOOL <br>SaveMiniAccount(PMiniAccount    pAccount) <br>{ <br>    HKEY                    hMiniKey; <br>    PSerializedMiniAccount  pPacked; <br>    DWORD                   cbNeeded; <br>    PWSTR                   pszPack; <br>    int                     err; <br>    DWORD                   Disposition; <br> <br>    err = RegCreateKeyEx(   HKEY_LOCAL_MACHINE, <br>                            szMiniKey, <br>                            0, <br>                            TEXT(""), <br>                            REG_OPTION_NON_VOLATILE, <br>                            KEY_WRITE | KEY_READ, <br>                            NULL, <br>                            &amp;hMiniKey, <br>                            &amp;Disposition); <br> <br>    if (err) <br>    { <br>        return(FALSE); <br>    } <br> <br>    cbNeeded = sizeof(SerializedMiniAccount) + <br>                (wcslen(pAccount-&gt;pszDomain) + 1 + <br>                 wcslen(pAccount-&gt;pszPassword) + 1 + <br>                 wcslen(pAccount-&gt;pszComment) + 1 ) * sizeof(WCHAR) ; <br> <br>    pPacked = LocalAlloc(LMEM_FIXED, cbNeeded); <br> <br>    if (!pPacked) <br>    { <br>        return(FALSE); <br>    } <br> <br>    pszPack = (PWSTR) (pPacked + 1); <br> <br>    pPacked-&gt;Version = MINI_VERSION; <br>    pPacked-&gt;Flags = pAccount-&gt;Flags; <br>    pPacked-&gt;IconId = pAccount-&gt;IconId; <br> <br>    pPacked-&gt;dwDomainOffset = sizeof(SerializedMiniAccount); <br>    pPacked-&gt;dwDomainLength = (wcslen(pAccount-&gt;pszDomain) + 1) * sizeof(WCHAR); <br>    wcscpy(pszPack, pAccount-&gt;pszDomain); <br>    pszPack += (pPacked-&gt;dwDomainLength / sizeof(WCHAR) ); <br> <br>    pPacked-&gt;dwPasswordOffset = pPacked-&gt;dwDomainOffset + pPacked-&gt;dwDomainLength; <br>    pPacked-&gt;dwPasswordLength = (wcslen(pAccount-&gt;pszPassword) + 1) * sizeof(WCHAR); <br>    wcscpy(pszPack, pAccount-&gt;pszPassword); <br>    pszPack += (pPacked-&gt;dwPasswordLength / sizeof(WCHAR) ); <br> <br>    pPacked-&gt;dwCommentOffset = pPacked-&gt;dwPasswordOffset + pPacked-&gt;dwPasswordLength; <br>    pPacked-&gt;dwCommentLength = (wcslen(pAccount-&gt;pszComment) + 1) * sizeof(WCHAR); <br>    wcscpy(pszPack, pAccount-&gt;pszComment); <br> <br>    err = RegSetValueEx(hMiniKey, <br>                        pAccount-&gt;pszUsername, <br>                        0, <br>                        REG_BINARY, <br>                        (PBYTE) pPacked, <br>                        cbNeeded); <br> <br>    RegCloseKey(hMiniKey); <br> <br>    return(err == 0); <br>} <br> <br>BOOL <br>LoadMiniAccounts(PGlobals   pGlobals) <br>{ <br>    FILETIME            LastWrite; <br>    // HKEY                hKey; <br>    HKEY                hMiniKey; <br>    WCHAR               szClass[64]; <br>    DWORD               err; <br>    DWORD               Disposition; <br>    DWORD               Class; <br>    DWORD               cKeys; <br>    DWORD               LongestKeyName; <br>    DWORD               LongestClass; <br>    DWORD               cValues; <br>    DWORD               LongestValueName; <br>    DWORD               LongestValueData; <br>    DWORD               Security; <br>    DWORD               i; <br>    WCHAR               szValue[MAX_PATH]; <br>    DWORD               cbValue; <br>    DWORD               dwType; <br>    DWORD               cbData; <br>    PBYTE               pBuffer; <br>    DWORD               cbBuffer; <br>    PMiniAccount        pAccount; <br>    PSerializedMiniAccount  pPacked; <br> <br> <br>    if (pGlobals-&gt;fAllowNewUser) <br>    { <br>        pAccount = LocalAlloc(LMEM_FIXED, sizeof(MiniAccount) ); <br>        if (pAccount) <br>        { <br>            pAccount-&gt;pNext = NULL; <br>            pAccount-&gt;pszUsername = TEXT("New User"); <br>            pAccount-&gt;pszDomain = TEXT(""); <br>            pAccount-&gt;pszPassword = TEXT(""); <br>            pAccount-&gt;pszComment = TEXT(""); <br>            pAccount-&gt;Flags = MINI_NEW_ACCOUNT; <br> <br>            pAccountList = pAccount; <br>        } <br>        else <br>            return(FALSE); <br>    } <br>    else <br>    { <br>        pAccountList = NULL; <br>    } <br> <br>    // <br>    // <br> <br>    err = RegCreateKeyEx(   HKEY_LOCAL_MACHINE, <br>                            szMiniKey, <br>                            0, <br>                            TEXT(""), <br>                            REG_OPTION_NON_VOLATILE, <br>                            KEY_WRITE | KEY_READ, <br>                            NULL, <br>                            &amp;hMiniKey, <br>                            &amp;Disposition); <br> <br>    if (err) <br>    { <br>        return(FALSE); <br>    } <br> <br>    if (Disposition == REG_OPENED_EXISTING_KEY) <br>    { <br>        // <br>        // Enumerate the sub keys of our class, and Load them. <br>        // <br>        Class = sizeof(szClass) / sizeof(WCHAR); <br>        err = RegQueryInfoKey(  hMiniKey, <br>                                szClass, <br>                                &amp;Class, <br>                                NULL, <br>                                &amp;cKeys, <br>                                &amp;LongestKeyName, <br>                                &amp;LongestClass, <br>                                &amp;cValues, <br>                                &amp;LongestValueName, <br>                                &amp;LongestValueData, <br>                                &amp;Security, <br>                                &amp;LastWrite); <br> <br>        pBuffer = LocalAlloc(LMEM_FIXED, 512); <br>        cbBuffer = 512; <br> <br>        for (i = 0; i &lt; cValues ; i++ ) <br>        { <br>            cbValue = MAX_PATH; <br> <br>            err = RegEnumValue( hMiniKey, <br>                                i, <br>                                szValue, <br>                                &amp;cbValue, <br>                                NULL, <br>                                &amp;dwType, <br>                                NULL, <br>                                &amp;cbData); <br> <br>            if (err) <br>            { <br>                break; <br>            } <br> <br>            if (dwType != REG_BINARY) <br>            { <br>                continue; <br>            } <br> <br>            if (cbData &gt; cbBuffer) <br>            { <br>                pBuffer = LocalReAlloc(pBuffer, LMEM_FIXED, cbData); <br>                if (!pBuffer) <br>                { <br>                    break; <br>                } <br>                cbBuffer = cbData; <br>            } <br> <br>            err = RegQueryValueEx(  hMiniKey, <br>                                    szValue, <br>                                    0, <br>                                    &amp;dwType, <br>                                    pBuffer, <br>                                    &amp;cbData); <br> <br>            if (err == 0) <br>            { <br>                pPacked = (PSerializedMiniAccount) pBuffer; <br> <br>                if (pPacked-&gt;Version != MINI_VERSION) <br>                { <br>                    continue; <br>                } <br> <br>                pAccount = LocalAlloc(LMEM_FIXED, sizeof(MiniAccount)); <br>                if (pAccount) <br>                { <br>                    pAccount-&gt;Flags = pPacked-&gt;Flags; <br>                    pAccount-&gt;IconId = pPacked-&gt;IconId; <br>                    pAccount-&gt;pszUsername = LocalAlloc(LMEM_FIXED, (cbValue+1)*sizeof(TCHAR)); <br>                    if (pAccount-&gt;pszUsername) <br>                    { <br>                        wcscpy(pAccount-&gt;pszUsername, szValue); <br>                    } <br> <br>                    pAccount-&gt;pszDomain = LocalAlloc(LMEM_FIXED, pPacked-&gt;dwDomainLength); <br>                    if (pAccount-&gt;pszDomain) <br>                    { <br>                        wcscpy(pAccount-&gt;pszDomain, <br>                               (PWSTR) ((pBuffer) + pPacked-&gt;dwDomainOffset) ); <br>                    } <br> <br>                    pAccount-&gt;pszPassword = LocalAlloc(LMEM_FIXED, pPacked-&gt;dwPasswordLength); <br>                    if (pAccount-&gt;pszPassword) <br>                    { <br>                        wcscpy(pAccount-&gt;pszPassword, <br>                               (PWSTR) (pBuffer + pPacked-&gt;dwPasswordOffset) ); <br>                    } <br> <br>                    pAccount-&gt;pszComment = LocalAlloc(LMEM_FIXED, pPacked-&gt;dwCommentLength); <br>                    if (pAccount-&gt;pszComment) <br>                    { <br>                        wcscpy(pAccount-&gt;pszComment, <br>                               (PWSTR) (pBuffer + pPacked-&gt;dwCommentOffset) ); <br>                    } <br> <br>                    pAccount-&gt;pNext = pAccountList; <br>                    pAccountList = pAccount; <br>                } <br>            } <br> <br>        } <br> <br>    } <br> <br>    return(TRUE); <br>} <br> <br>VOID <br>InitializeImageLists() <br>{ <br>    HICON   hIcon; <br> <br>    hiLogonSmall = ImageList_Create(16, 16, TRUE, 4, 0); <br>    hiLogonLarge = ImageList_Create(32, 32, TRUE, 4, 0); <br> <br>    hIcon = LoadIcon(hDllInstance, MAKEINTRESOURCE(IDI_USER_ICON)); <br>    if (!hIcon) <br>    { <br>        DebugLog((DEB_ERROR, "Unable to load icon, %d\n", GetLastError())); <br>    } <br>    ImageList_AddIcon(hiLogonLarge, hIcon); <br>    ImageList_AddIcon(hiLogonSmall, hIcon); <br> <br>    hIcon = LoadIcon(hDllInstance, MAKEINTRESOURCE(IDI_NEW_USER_ICON)); <br>    ImageList_AddIcon(hiLogonLarge, hIcon); <br>    ImageList_AddIcon(hiLogonSmall, hIcon); <br> <br>} <br> <br> <br>PopulateListView( <br>    HWND            hLV, <br>    PMiniAccount    pAccList) <br>{ <br>    LV_ITEM     lvi; <br>    LV_COLUMN   lvc; <br>    DWORD       Count; <br> <br> <br>    ListView_SetImageList(hLV, hiLogonLarge, LVSIL_NORMAL); <br>    ListView_SetImageList(hLV, hiLogonSmall, LVSIL_SMALL); <br> <br>    // <br>    // Ok, now set up the columns for the list view <br>    // <br> <br>    lvc.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM; <br>    lvc.fmt = LVCFMT_LEFT; <br>    lvc.cx = 0; <br> <br>    lvc.iSubItem = 0; <br>    lvc.pszText = TEXT("Name        "); <br>    ListView_InsertColumn(hLV, 0, &amp;lvc); <br> <br>    lvc.iSubItem = 1; <br>    lvc.pszText = TEXT("Domain   "); <br>    ListView_InsertColumn(hLV, 1, &amp;lvc); <br>    // <br>    // Comment <br>    // <br> <br>    lvc.iSubItem = 2; <br>    lvc.pszText = TEXT("Comment   "); <br>    ListView_InsertColumn(hLV, 2, &amp;lvc); <br> <br>    lvi.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM; <br> <br> <br>    Count = 0; <br>    while (pAccList) <br>    { <br>        lvi.iItem = Count; <br>        lvi.iSubItem  = 0; <br>        lvi.iImage = (pAccList-&gt;Flags &amp; MINI_NEW_ACCOUNT) ? 1 : 0; <br>        lvi.pszText = pAccList-&gt;pszUsername; <br>        lvi.lParam = (LPARAM) pAccList; <br> <br>        ListView_InsertItem(hLV, &amp;lvi); <br> <br>        ListView_SetItemText(hLV, Count, 1, pAccList-&gt;pszDomain); <br>        ListView_SetItemText(hLV, Count, 2, pAccList-&gt;pszComment); <br> <br>        Count++; <br>        pAccList = pAccList-&gt;pNext; <br> <br>    } <br> <br>    return(TRUE); <br>} <br> <br>int <br>CALLBACK <br>NewUserDlgProc( <br>    HWND    hDlg, <br>    UINT    Message, <br>    WPARAM  wParam, <br>    LPARAM  lParam) <br>{ <br>    PGlobals        pGlobals; <br>    PMiniAccount    pMini; <br> <br>    pGlobals = (PGlobals) GetWindowLong(hDlg, GWL_USERDATA); <br>    switch (Message) <br>    { <br>        case WM_INITDIALOG: <br>            CenterWindow(hDlg); <br>            SetWindowLong(hDlg, GWL_USERDATA, lParam); <br>            return(TRUE); <br> <br>        case WM_COMMAND: <br>            if (LOWORD(wParam) == IDOK) <br>            { <br>                pMini = LocalAlloc(LMEM_FIXED, sizeof(MiniAccount)); <br>                pMini-&gt;pszUsername = AllocAndCaptureText(hDlg, IDD_USER_NAME); <br>                pMini-&gt;pszDomain = AllocAndCaptureText(hDlg, IDD_DOMAIN); <br>                pMini-&gt;pszPassword = AllocAndCaptureText(hDlg, IDD_PASSWORD); <br>                pMini-&gt;pszComment = DupString(TEXT("")); <br>                pMini-&gt;Flags = MINI_SAVE | MINI_CAN_EDIT; <br>                pMini-&gt;IconId = 0; <br>                pMini-&gt;pNext = pAccountList; <br>                pAccountList = pMini; <br>                pGlobals-&gt;pAccount = pMini; <br>                EndDialog(hDlg, IDOK); <br>            } <br>            if (LOWORD(wParam) == IDCANCEL) <br>            { <br>                EndDialog(hDlg, IDCANCEL); <br>            } <br>            return(TRUE); <br>    } <br> <br>    return(FALSE); <br> <br>} <br> <br>LogonDlgInit( <br>    HWND    hDlg, <br>    LPARAM  lParam) <br>{ <br>    PGlobals        pGlobals; <br>    HWND            hLV; <br> <br>    pGlobals = (PGlobals) lParam; <br>    SetWindowLong(hDlg, GWL_USERDATA, lParam); <br>    pGlobals-&gt;pAccount = NULL; <br> <br>    if (pAccountList == NULL) <br>    { <br>        LoadMiniAccounts(pGlobals); <br>    } <br> <br>    InitializeImageLists(); <br> <br>    hLV = GetDlgItem(hDlg, IDD_LOGON_LV); <br>    PopulateListView(hLV, pAccountList); <br> <br>    CenterWindow(hDlg); <br> <br>    ListView_SetColumnWidth(hLV, 0, LVSCW_AUTOSIZE); <br>    ListView_SetColumnWidth(hLV, 1, LVSCW_AUTOSIZE); <br>    ListView_SetColumnWidth(hLV, 2, LVSCW_AUTOSIZE); <br> <br>    ShowWindow(hLV, SW_NORMAL); <br>    EnableWindow(hLV, TRUE); <br>    EnableWindow(GetDlgItem(hDlg, IDD_LOGON_BUTTON), FALSE); <br> <br>    return(TRUE); <br> <br>} <br> <br>int <br>HandleLvNotify( <br>    HWND        hDlg, <br>    PGlobals    pGlobals, <br>    NMHDR *     pNMH) <br>{ <br>    NM_LISTVIEW *   pNotify; <br>    LV_ITEM         lvi; <br>    HWND            hLV; <br>    PMiniAccount *  ppAcc; <br>    int             ret; <br>    int             index; <br> <br>    pNotify = (NM_LISTVIEW *) pNMH; <br> <br>    hLV = GetDlgItem(hDlg, IDD_LOGON_LV); <br> <br>    ppAcc = &amp;pGlobals-&gt;pAccount; <br> <br>    switch (pNotify-&gt;hdr.code) <br>    { <br>        case NM_CLICK: <br>        case NM_DBLCLK: <br>            EnableWindow(GetDlgItem(hDlg, IDD_LOGON_BUTTON), TRUE); <br> <br>            index = ListView_GetNextItem(hLV, -1, LVNI_SELECTED); <br>            if (index &gt;= 0) <br>            { <br>                lvi.iItem = index; <br>                lvi.iSubItem = 0; <br>                lvi.mask = LVIF_PARAM; <br> <br>                ret = ListView_GetItem(hLV, &amp;lvi); <br>                *ppAcc = (PMiniAccount) lvi.lParam; <br>                DebugLog((DEB_TRACE, "Selected Item %d, lParam = %x\n", index, lvi.lParam)); <br>            } <br> <br>            if (pNotify-&gt;hdr.code == NM_DBLCLK) <br>            { <br>                PostMessage(hDlg, WM_COMMAND, IDOK, 0); <br>            } <br>            return(TRUE); <br> <br>    } <br>    return(FALSE); <br> <br>} <br> <br>int <br>CALLBACK <br>LogonDlgProc( <br>    HWND        hDlg, <br>    UINT        Message, <br>    WPARAM      wParam, <br>    LPARAM      lParam) <br>{ <br>    NMHDR *     pNotifyHeader; <br>    PGlobals    pGlobals; <br>    int         result; <br> <br>    pGlobals = (PGlobals) GetWindowLong(hDlg, GWL_USERDATA); <br>    switch (Message) <br>    { <br>        case WM_INITDIALOG: <br>            return(LogonDlgInit(hDlg, lParam)); <br> <br>        case WM_COMMAND: <br>            if (LOWORD(wParam) == IDCANCEL) <br>            { <br>                EndDialog(hDlg, WLX_SAS_ACTION_NONE); <br>            } <br>            if (LOWORD(wParam) == IDD_LOGON_BUTTON) <br>            { <br>                if (pGlobals-&gt;pAccount-&gt;Flags &amp; MINI_NEW_ACCOUNT) <br>                { <br>                    result = pWlxFuncs-&gt;WlxDialogBoxParam(  hGlobalWlx, <br>                                                            hDllInstance, <br>                                                            (LPTSTR) MAKEINTRESOURCE(IDD_NEW_USER_LOGON), <br>                                                            hDlg, <br>                                                            (DLGPROC) NewUserDlgProc, <br>                                                            (LPARAM) pGlobals); <br>                } <br>                else <br>                { <br>                    result = IDOK; <br>                } <br> <br>                if (result == IDOK) <br>                { <br>                    EndDialog(hDlg, WLX_SAS_ACTION_LOGON); <br>                } <br>            } <br>            if (LOWORD(wParam) == IDD_SHUTDOWN_BUTTON) <br>            { <br>                result = pWlxFuncs-&gt;WlxDialogBoxParam(  hGlobalWlx, <br>                                                        hDllInstance, <br>                                                        (LPTSTR) MAKEINTRESOURCE(IDD_SHUTDOWN), <br>                                                        hDlg, <br>                                                        (DLGPROC) ShutdownDlgProc, <br>                                                        (LPARAM) pGlobals); <br>                if (result != WLX_SAS_ACTION_NONE) <br>                { <br>                    EndDialog(hDlg, result); <br>                } <br>            } <br>            return(TRUE); <br>            break; <br> <br>        case WM_NOTIFY: <br>            pNotifyHeader = (NMHDR *) lParam; <br>            if (wParam == IDD_LOGON_LV) <br>            { <br>                return(HandleLvNotify(hDlg, pGlobals, pNotifyHeader)); <br>            } <br>        case WM_CLOSE: <br>            hiLogonSmall = NULL; <br>            hiLogonLarge = NULL; <br>            return(TRUE); <br> <br>    } <br> <br>    return(FALSE); <br>} <br> <br>/////////////////////////////////////////////////////////////////////////// <br>/////////////////////////////////////////////////////////////////////////// <br>// <br>// <br>// <br>/////////////////////////////////////////////////////////////////////////// <br>/////////////////////////////////////////////////////////////////////////// <br> <br>int <br>AttemptLogon( <br>    PGlobals        pGlobals, <br>    PMiniAccount    pAccount, <br>    PSID            pLogonSid, <br>    PLUID           pLogonId) <br>{ <br>    HANDLE              hUser; <br>    TOKEN_STATISTICS    TStats; <br>    TOKEN_GROUPS    *   pGroups; <br>    DWORD               size; <br>    DWORD               i; <br> <br>    if (LogonUser(  pAccount-&gt;pszUsername, <br>                    pAccount-&gt;pszDomain, <br>                    pAccount-&gt;pszPassword, <br>                    LOGON32_LOGON_INTERACTIVE, <br>                    LOGON32_PROVIDER_DEFAULT, <br>                    &amp;hUser)) <br>    { <br>        if (pAccount-&gt;Flags &amp; MINI_SAVE) <br>        { <br>            SaveMiniAccount(pAccount); <br>            pAccount-&gt;Flags &amp;= ~MINI_SAVE; <br>        } <br> <br>        pGlobals-&gt;hUserToken = hUser; <br> <br>        // <br>        // Now, grovel the token we got back for interesting stuff: <br>        // <br> <br>        GetTokenInformation(hUser, <br>                            TokenStatistics, <br>                            &amp;TStats, <br>                            sizeof(TStats), <br>                            &amp;size); <br> <br>        *pLogonId = TStats.AuthenticationId; <br> <br>        pGroups = LocalAlloc(LMEM_FIXED, 1024); <br> <br>        if (!pGroups) <br>        { <br>            CloseHandle(hUser); <br>            return(WLX_SAS_ACTION_NONE); <br>        } <br> <br>        // <br>        // The tricky part.  We need to get the Logon SID from the token, <br>        // since that is what Winlogon will use to protect the windowstation <br>        // and desktop. <br>        // <br> <br>        GetTokenInformation(hUser, <br>                            TokenGroups, <br>                            pGroups, <br>                            1024, <br>                            &amp;size); <br> <br>        if (size &gt; 1024) <br>        { <br>            pGroups = LocalReAlloc(pGroups, LMEM_FIXED, size); <br>            GetTokenInformation(hUser, <br>                                TokenGroups, <br>                                pGroups, <br>                                size, <br>                                &amp;size); <br>        } <br> <br>        for (i = 0; i &lt; pGroups-&gt;GroupCount ; i++) <br>        { <br>            if ((pGroups-&gt;Groups[i].Attributes &amp; SE_GROUP_LOGON_ID) == SE_GROUP_LOGON_ID) <br>            { <br>                CopySid(GetLengthSid(pLogonSid), <br>                        pLogonSid, <br>                        pGroups-&gt;Groups[i].Sid ); <br>                break; <br>            } <br>        } <br> <br>        LocalFree(pGroups); <br> <br>        return(WLX_SAS_ACTION_LOGON); <br>    } <br> <br>    return(WLX_SAS_ACTION_NONE); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
