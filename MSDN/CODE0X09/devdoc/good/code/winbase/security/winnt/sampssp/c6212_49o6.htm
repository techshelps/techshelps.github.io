<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>STUBS.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6216"></a>STUBS.C</h2>
<pre><code>//+----------------------------------------------------------------------- <br>// <br>// Microsoft Windows <br>// <br>// Copyright (c) Microsoft Corporation 1992 - 1994 <br>// <br>// File:        stubs.cxx <br>// <br>// Contents:    user-mode stubs for security API <br>// <br>// <br>//------------------------------------------------------------------------ <br>#include "sampssp.h" <br> <br> <br>SecurityFunctionTableW SecTableW = {SECURITY_SUPPORT_PROVIDER_INTERFACE_VERSION, <br>                                    EnumerateSecurityPackagesW, <br>                                    NULL, <br>                                    AcquireCredentialsHandleW, <br>                                    FreeCredentialsHandle, <br>                                    NULL, // LogonUser <br>                                    InitializeSecurityContextW, <br>                                    AcceptSecurityContext, <br>                                    CompleteAuthToken, <br>                                    DeleteSecurityContext, <br>                                    ApplyControlToken, <br>                                    QueryContextAttributesW, <br>                                    ImpersonateSecurityContext, <br>                                    RevertSecurityContext, <br>                                    MakeSignature, <br>                                    VerifySignature, <br>                                    FreeContextBuffer, <br>                                    QuerySecurityPackageInfoW <br>                                   }; <br> <br> <br>PSEC_CONTEXT ContextList; <br>PCREDENTIAL CredentialList; <br>ULONG NextId; <br>TimeStamp Forever = {0x7fffffff,0xfffffff}; <br>TimeStamp Never = {0,0}; <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Function:   LocateContext <br>// <br>//  Synopsis: <br>// <br>//  Effects: <br>// <br>//  Arguments: <br>// <br>//  Requires: <br>// <br>//  Returns: <br>// <br>//  Notes: <br>// <br>// <br>//-------------------------------------------------------------------------- <br> <br> <br>PSEC_CONTEXT <br>LocateContext(ULONG ContextId) <br>{ <br>    PSEC_CONTEXT TestContext; <br>    EnterCriticalSection(&amp;DllCritSect); <br> <br>    TestContext = ContextList; <br>    while (TestContext != NULL) <br>    { <br>        if (TestContext-&gt;ContextId == ContextId) <br>        { <br>            break; <br>        } <br>        TestContext = TestContext-&gt;Next; <br>    } <br>    LeaveCriticalSection(&amp;DllCritSect); <br>    return(TestContext); <br> <br>} <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Function:   DeleteContext <br>// <br>//  Synopsis: <br>// <br>//  Effects: <br>// <br>//  Arguments: <br>// <br>//  Requires: <br>// <br>//  Returns: <br>// <br>//  Notes: <br>// <br>// <br>//-------------------------------------------------------------------------- <br> <br> <br>BOOLEAN <br>DeleteContext(ULONG ContextId) <br>{ <br>    PSEC_CONTEXT TestContext, LastContext; <br> <br>    EnterCriticalSection(&amp;DllCritSect); <br>    TestContext = ContextList; <br>    LastContext = NULL; <br> <br>    while (TestContext != NULL) <br>    { <br>        if (TestContext-&gt;ContextId == ContextId) <br>        { <br>            break; <br>        } <br>        LastContext = TestContext; <br>        TestContext = TestContext-&gt;Next; <br>    } <br>    if (TestContext != NULL) <br>    { <br>        if (LastContext != NULL) <br>        { <br>            LastContext-&gt;Next = TestContext-&gt;Next; <br>        } <br>        else <br>        { <br>            assert(ContextList == TestContext); <br>            ContextList = TestContext-&gt;Next; <br>        } <br>        LocalFree(TestContext); <br>    } <br>    LeaveCriticalSection(&amp;DllCritSect); <br>    return( TestContext == NULL ? FALSE : TRUE ); <br>} <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Function:   AddContext <br>// <br>//  Synopsis: <br>// <br>//  Effects: <br>// <br>//  Arguments: <br>// <br>//  Requires: <br>// <br>//  Returns: <br>// <br>//  Notes: <br>// <br>// <br>//-------------------------------------------------------------------------- <br> <br> <br>VOID <br>AddContext(PSEC_CONTEXT Context) <br>{ <br>    EnterCriticalSection(&amp;DllCritSect); <br>    Context-&gt;Next = ContextList; <br>    ContextList = Context; <br>    LeaveCriticalSection(&amp;DllCritSect); <br>} <br> <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Function:   InitSecurityInterfaceW <br>// <br>//  Synopsis: <br>// <br>//  Effects: <br>// <br>//  Arguments: <br>// <br>//  Requires: <br>// <br>//  Returns: <br>// <br>//  Notes: <br>// <br>// <br>//-------------------------------------------------------------------------- <br> <br> <br> <br>PCREDENTIAL <br>LocateCredential(ULONG CredentialId) <br>{ <br>    PCREDENTIAL TestCredential; <br>    EnterCriticalSection(&amp;DllCritSect); <br> <br>    TestCredential = CredentialList; <br>    while (TestCredential != NULL) <br>    { <br>        if (TestCredential-&gt;CredentialId == CredentialId) <br>        { <br>            break; <br>        } <br>        TestCredential = TestCredential-&gt;Next; <br>    } <br>    LeaveCriticalSection(&amp;DllCritSect); <br>    return(TestCredential); <br> <br>} <br> <br>BOOLEAN <br>DeleteCredential(ULONG CredentialId) <br>{ <br>    PCREDENTIAL TestCredential, LastCredential; <br> <br>    EnterCriticalSection(&amp;DllCritSect); <br>    TestCredential = CredentialList; <br>    LastCredential = NULL; <br> <br>    while (TestCredential != NULL) <br>    { <br>        if (TestCredential-&gt;CredentialId == CredentialId) <br>        { <br>            break; <br>        } <br>        LastCredential = TestCredential; <br>        TestCredential = TestCredential-&gt;Next; <br>    } <br>    if (TestCredential != NULL) <br>    { <br>        if (LastCredential != NULL) <br>        { <br>            LastCredential-&gt;Next = TestCredential-&gt;Next; <br>        } <br>        else <br>        { <br>            assert(CredentialList == TestCredential); <br>            CredentialList = TestCredential-&gt;Next; <br>        } <br>        LocalFree(TestCredential); <br>    } <br>    LeaveCriticalSection(&amp;DllCritSect); <br>    return( TestCredential == NULL ? FALSE : TRUE ); <br>} <br> <br>VOID <br>AddCredential(PCREDENTIAL Credential) <br>{ <br>    EnterCriticalSection(&amp;DllCritSect); <br>    Credential-&gt;Next = CredentialList; <br>    CredentialList = Credential; <br>    LeaveCriticalSection(&amp;DllCritSect); <br>} <br> <br>ULONG <br>GetNewId() <br>{ <br>    ULONG NewId; <br> <br>    EnterCriticalSection(&amp;DllCritSect); <br>    NewId = NextId; <br>    NextId ++; <br>    LeaveCriticalSection(&amp;DllCritSect); <br>    return(NewId); <br> <br>} <br> <br>PSecBuffer <br>LocateBuffer(PSecBufferDesc Buffer, ULONG MinimumSize) <br>{ <br>    ULONG Index; <br>    if (Buffer == NULL) <br>    { <br>        return(NULL); <br>    } <br> <br>    for (Index = 0; Index &lt; Buffer-&gt;cBuffers  ; Index++) <br>    { <br>        if (((Buffer-&gt;pBuffers[Index].BufferType) &amp; ~SECBUFFER_ATTRMASK) <br>            == SECBUFFER_TOKEN) <br>        { <br> <br>            // <br>            // Do size checking <br>            // <br> <br>            if (Buffer-&gt;pBuffers[Index].cbBuffer &lt; MinimumSize) <br>            { <br>                return(NULL); <br>            } <br>            return(&amp;Buffer-&gt;pBuffers[Index]); <br>        } <br>    } <br>    return(NULL); <br>} <br> <br> <br> <br>PSecBuffer <br>LocateSecBuffer(PSecBufferDesc Buffer) <br>{ <br>    return(LocateBuffer(Buffer, sizeof(MESSAGE))); <br>} <br> <br> <br>PSecBuffer <br>LocateSigBuffer(PSecBufferDesc Buffer) <br>{ <br>    return(LocateBuffer(Buffer, sizeof(SIGNATURE))); <br>} <br> <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Function:   InitSecurityInterfaceW <br>// <br>//  Synopsis: <br>// <br>//  Effects: <br>// <br>//  Arguments: <br>// <br>//  Requires: <br>// <br>//  Returns: <br>// <br>//  Notes: <br>// <br>// <br>//-------------------------------------------------------------------------- <br>PSecurityFunctionTableW SEC_ENTRY <br>InitSecurityInterfaceW(VOID) <br>{ <br>    InitializeCriticalSection( &amp;DllCritSect ); <br>    return(&amp;SecTableW); <br>} <br> <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Function:   AcquireCredentialsHandleW <br>// <br>//  Synopsis: <br>// <br>//  Effects: <br>// <br>//  Arguments: <br>// <br>//  Requires: <br>// <br>//  Returns: <br>// <br>//  Notes: <br>// <br>// <br>//-------------------------------------------------------------------------- <br> <br> <br> <br>SECURITY_STATUS SEC_ENTRY <br>AcquireCredentialsHandleW( <br>    LPWSTR                      pszPrincipal,       // Name of principal <br>    LPWSTR                      pszPackageName,     // Name of package <br>    unsigned long               fCredentialUse,     // Flags indicating use <br>    void SEC_FAR *              pvLogonId,          // Pointer to logon ID <br>    void SEC_FAR *              pAuthData,          // Package specific data <br>    SEC_GET_KEY_FN              pGetKeyFn,          // Pointer to GetKey() func <br>    void SEC_FAR *              pvGetKeyArgument,   // Value to pass to GetKey() <br>    PCredHandle                 phCredential,       // (out) Cred Handle <br>    PTimeStamp                  ptsExpiry           // (out) Lifetime (optional) <br>    ) <br>{ <br>    PCREDENTIAL NewCredential = NULL; <br> <br>    if ((fCredentialUse &amp; (SECPKG_CRED_BOTH)) == 0) <br>    { <br>        return(SEC_E_UNKNOWN_CREDENTIALS); <br>    } <br>    NewCredential = (PCREDENTIAL) LocalAlloc(0,sizeof(CREDENTIAL)); <br>    if (NewCredential == NULL) <br>    { <br>        return(SEC_E_INSUFFICIENT_MEMORY); <br>    } <br>    NewCredential-&gt;CredentialId = GetNewId(); <br>    NewCredential-&gt;Use = fCredentialUse; <br>    NewCredential-&gt;AuthData = *(ULONG *)pAuthData; <br>    phCredential-&gt;dwUpper = NewCredential-&gt;CredentialId; <br>    *ptsExpiry = Forever; <br>    AddCredential(NewCredential); <br>    return(SEC_E_OK); <br> <br>} <br> <br> <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Function:   FreeCredentialsHandle <br>// <br>//  Synopsis: <br>// <br>//  Effects: <br>// <br>//  Arguments: <br>// <br>//  Requires: <br>// <br>//  Returns: <br>// <br>//  Notes: <br>// <br>// <br>//-------------------------------------------------------------------------- <br> <br> <br>SECURITY_STATUS SEC_ENTRY <br>FreeCredentialsHandle( <br>    PCredHandle                 phCredential        // Handle to free <br>    ) <br>{ <br>    if (DeleteCredential(phCredential-&gt;dwUpper)) <br>    { <br>        return(SEC_E_OK); <br>    } <br>    else <br>    { <br>        return(SEC_E_UNKNOWN_CREDENTIALS); <br>    } <br>} <br> <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Function:   InitializeSecurityContextW <br>// <br>//  Synopsis: <br>// <br>//  Effects: <br>// <br>//  Arguments: <br>// <br>//  Requires: <br>// <br>//  Returns: <br>// <br>//  Notes: <br>// <br>// <br>//-------------------------------------------------------------------------- <br> <br> <br>SECURITY_STATUS SEC_ENTRY <br>InitializeSecurityContextW( <br>    PCredHandle                 phCredential,       // Cred to base context <br>    PCtxtHandle                 phContext,          // Existing context (OPT) <br>    LPWSTR                      pszTargetName,      // Name of target <br>    unsigned long               fContextReq,        // Context Requirements <br>    unsigned long               Reserved1,          // Reserved, MBZ <br>    unsigned long               TargetDataRep,      // Data rep of target <br>    PSecBufferDesc              pInput,             // Input Buffers <br>    unsigned long               Reserved2,          // Reserved, MBZ <br>    PCtxtHandle                 phNewContext,       // (out) New Context handle <br>    PSecBufferDesc              pOutput,            // (inout) Output Buffers <br>    unsigned long SEC_FAR *     pfContextAttr,      // (out) Context attrs <br>    PTimeStamp                  ptsExpiry           // (out) Life span (OPT) <br>    ) <br>{ <br>    PCREDENTIAL Credential = NULL; <br>    PSEC_CONTEXT Context = NULL; <br>    PMESSAGE Message = NULL; <br>    PSecBuffer OutputBuffer; <br>    PSecBuffer InputBuffer; <br>    MESSAGE SampleMessage; <br> <br> <br>    if (fContextReq &amp; ISC_REQ_ALLOCATE_MEMORY) <br>    { <br>        return(SEC_E_INSUFFICIENT_MEMORY); <br>    } <br> <br>    OutputBuffer = LocateSecBuffer(pOutput); <br>    if (OutputBuffer == NULL) <br>    { <br>        return(SEC_E_INVALID_TOKEN); <br>    } <br> <br>    if (phContext == NULL) <br>    { <br> <br>        Credential = LocateCredential(phCredential-&gt;dwUpper); <br>        if (Credential == NULL) <br>        { <br>            return(SEC_E_UNKNOWN_CREDENTIALS); <br>        } <br> <br>        if ((Credential-&gt;Use &amp; SECPKG_CRED_OUTBOUND) == 0) <br>        { <br>            return(SEC_E_UNKNOWN_CREDENTIALS); <br>        } <br> <br>    } <br> <br>    // <br>    // If the context is NULL, create a new one. <br>    // <br> <br>    if (phContext == NULL) <br>    { <br>        Context = (PSEC_CONTEXT) LocalAlloc(0,sizeof(SEC_CONTEXT)); <br>        if (Context == NULL) <br>        { <br>            return(SEC_E_INSUFFICIENT_MEMORY); <br>        } <br>        Context-&gt;ContextId = GetNewId(); <br>        phNewContext-&gt;dwUpper = Context-&gt;ContextId; <br>        Context-&gt;CredentialId = phCredential-&gt;dwUpper; <br>        Context-&gt;State = FirstInit; <br>        Context-&gt;Nonce = 0; <br>        Context-&gt;ContextFlags = fContextReq; <br>        *pfContextAttr = fContextReq; <br>        *ptsExpiry = Forever; <br> <br>        // <br>        // Build an output token. <br>        // <br> <br>        Message = (PMESSAGE) OutputBuffer-&gt;pvBuffer; <br>        Message-&gt;MessageType = Negotiate; <br>        memset(Message-&gt;Buffer,'x',MESSAGE_SIZE); <br>        OutputBuffer-&gt;cbBuffer = sizeof(MESSAGE); <br> <br>        AddContext(Context); <br> <br>        return(SEC_I_CONTINUE_NEEDED); <br> <br>    } else { <br>        // <br>        // This is the second call. Lookup the old context. <br>        // <br> <br>        Context = LocateContext(phContext-&gt;dwUpper); <br>        if (Context == NULL) <br>        { <br>            return(SEC_E_INVALID_HANDLE); <br>        } <br> <br>        if ((Context-&gt;State != FirstInit) &amp;&amp; <br>            (Context-&gt;State != SecondInit)) <br>        { <br>            return(SEC_E_INVALID_HANDLE); <br>        } <br> <br> <br>        // <br>        // Build the new output message <br>        // <br> <br>        if (Context-&gt;State == FirstInit) <br>        { <br> <br>            // <br>            // Check that the input message is what we expected. <br>            // <br> <br>            InputBuffer = LocateSecBuffer(pInput); <br>            if (InputBuffer == NULL) <br>            { <br>                return(SEC_E_INVALID_TOKEN); <br>            } <br>            Message = (PMESSAGE) InputBuffer-&gt;pvBuffer; <br> <br>            SampleMessage.MessageType = Challenge; <br>            memset(SampleMessage.Buffer, 'y', MESSAGE_SIZE); <br> <br>            if (memcmp(&amp;SampleMessage,Message,MESSAGE_SIZE) != 0) <br>            { <br>                return(SEC_E_INVALID_TOKEN); <br>            } <br> <br>            Message = (PMESSAGE) OutputBuffer-&gt;pvBuffer; <br>            Message-&gt;MessageType = ChallengeResponse; <br>            memset(Message-&gt;Buffer,'z',MESSAGE_SIZE); <br>        } <br>        else <br>        { <br>            Message = (PMESSAGE) OutputBuffer-&gt;pvBuffer; <br>            Message-&gt;MessageType = ReAuthenticate; <br>            memset(Message-&gt;Buffer,'q',MESSAGE_SIZE); <br>        } <br> <br>        OutputBuffer-&gt;cbBuffer = sizeof(MESSAGE); <br>        Context-&gt;State = SecondInit; <br>        return(SEC_E_OK); <br>    } <br>} <br> <br> <br> <br>//+------------------------------------------- ------------------------------ <br>// <br>//  Function:   AcceptSecurityContext <br>// <br>//  Synopsis:Allows a remotely initiated security context between the  <br>//              application and a remote peer to be established.  To complete  <br>//              the establishment of context one or more reply tokens may be  <br>//              required from remote peer. <br>//              This function is the server counterpart to the  <br>//              InitializeSecurityContext API.  The ContextAttributes is a bit  <br>//              mask representing various context level functions such as   <br>//              delegation, mutual authentication, confidentiality, replay  <br>//              detection and sequence detection.  This API is used by the  <br>//              server side.  When a request comes in, the server uses the  <br>//              ContextReqFlags parameter to specify what it requires of the  <br>//              session.  In this fashion, a server can specify that clients  <br>//              must be capable of using a confidential or integrity checked <br>//              session, and fail clients that can't meet that demand.   <br>//              Alternatively, a server can require nothing, and whatever the  <br>//              client can provide or requires is returned in the  <br>//              pfContextAttributes parameter.  For a package that supports 3  <br>//              leg mutual authentication, the calling sequence would be:  <br>//              Client provides a token, server calls Accept the first time, <br>//              generating a reply token.  The client uses this in a second  <br>//              call to InitializeSecurityContext, and generates a final token. <br>//              This token is then used in the final call to Accept to complete <br>//              the session.  Another example would be the LAN Manager/NT  <br>//              authentication style.  The client connects to negotiate a  <br>//              protocol.  The server calls Accept to set up a context and  <br>//              generate a challenge to the client.  The client calls  <br>//              InitializeSecurityContext and creates a response.  The server  <br>//              then calls Accept the final time to allow the package to verify <br>//              the response is appropriate for the challenge. <br>// <br>//  Effects: <br>// <br>// <br>//  Arguments:[phCredential] - Handle to the credentials to be used to <br>//              create the context. <br>// <br>//              [phContext] - Handle to the partially formed context, if <br>//              this is a second call (see above) or NULL if this is the first call. <br>// <br>//              [pInput] - Pointer to the input token.  In the first call  <br>//              this token can either be NULL or may contain  <br>//              security package specific information. <br>// <br>//              [fContextReq] - Requirements of the context, package specific. See <br>//              the ASC_REQ_xxx defines in SSPI.H. <br>// <br>//              [TargetDataRep] - Long indicating the data representation (byte <br>//              ordering, etc) on the target.  The constant  <br>//              SECURITY_NATIVE_DREP may be supplied by the  <br>//              transport indicating that the native format  <br>//              is in use. <br>// <br>//              [phNewContext] - New context handle.  If this is a second  <br>//              call, this can be same as OldContextHandle. <br>// <br>//              [pOutput] - Buffer to receive the output token. <br>// <br>//              [pfContextAttr] - Attributes of the context established. See <br>//              the ASC_RET_xxx defines in SSPI.H <br>// <br>//              [ptsExpiry] - Expiration time of the context. <br>// <br>//  Requires: <br>// <br>//  Returns:STATUS_SUCCESS - Message handled <br>//              SEC_I_CALLBACK_NEEDED - Caller should call again later <br>//              SEC_E_NO_SPM - Security Support Provider is not running <br>//              SEC_E_INVALID_TOKEN - Token improperly formatted <br>//              SEC_E_INVALID_HANDLE - Credential/Context Handle is invalid <br>//              SEC_E_BUFFER_TOO_SMALL- Buffer for output token isn't big enough <br>//              SEC_E_LOGON_DENIED - User is no allowed to logon to this server <br>//              SEC_E_INSUFFICIENT_MEMORY - Not enough memory <br>// <br>//  Notes: <br>// <br>// <br>//-------------------------------------------------------------------------- <br> <br> <br>SECURITY_STATUS SEC_ENTRY <br>AcceptSecurityContext( <br>    PCredHandle                 phCredential,       // Cred to base context <br>    PCtxtHandle                 phContext,          // Existing context (OPT) <br>    PSecBufferDesc              pInput,             // Input buffer <br>    unsigned long               fContextReq,        // Context Requirements <br>    unsigned long               TargetDataRep,      // Target Data Rep <br>    PCtxtHandle                 phNewContext,       // (out) New context handle <br>    PSecBufferDesc              pOutput,            // (inout) Output buffers <br>    unsigned long SEC_FAR *     pfContextAttr,      // (out) Context attributes <br>    PTimeStamp                  ptsExpiry           // (out) Life span (OPT) <br>    ) <br>{ <br>    PCREDENTIAL Credential = NULL; <br>    PSEC_CONTEXT Context = NULL; <br>    PMESSAGE Message = NULL; <br>    PSecBuffer OutputBuffer; <br>    PSecBuffer InputBuffer; <br>    MESSAGE SampleMessage; <br> <br> <br>    if (fContextReq &amp; ISC_REQ_ALLOCATE_MEMORY) <br>    { <br>        return(SEC_E_INSUFFICIENT_MEMORY); <br>    } <br> <br>    InputBuffer = LocateSecBuffer(pInput); <br>    if (InputBuffer == NULL) <br>    { <br>        return(SEC_E_INVALID_TOKEN); <br>    } <br> <br>    if (phContext == NULL) <br>    { <br> <br>        Credential = LocateCredential(phCredential-&gt;dwUpper); <br>        if (Credential == NULL) <br>        { <br>            return(SEC_E_UNKNOWN_CREDENTIALS); <br>        } <br> <br>        if ((Credential-&gt;Use &amp; SECPKG_CRED_INBOUND) == 0) <br>        { <br>            return(SEC_E_UNKNOWN_CREDENTIALS); <br>        } <br> <br>    } <br> <br>    // <br>    // If the context is NULL, create a new one. <br>    // <br> <br>    if (phContext == NULL) <br>    { <br>        // <br>        // Make sure the output buffer exists. <br>        // <br> <br>        OutputBuffer = LocateSecBuffer(pOutput); <br>        if (OutputBuffer == NULL) <br>        { <br>            return(SEC_E_INVALID_TOKEN); <br>        } <br> <br> <br> <br>        // <br>        // Check that the input message is what we expected. <br>        // <br> <br>        Message = (PMESSAGE) InputBuffer-&gt;pvBuffer; <br>        SampleMessage.MessageType = Negotiate; <br>        memset(SampleMessage.Buffer, 'x', MESSAGE_SIZE); <br> <br>        if (memcmp(&amp;SampleMessage,Message,MESSAGE_SIZE) != 0) <br>        { <br>            return(SEC_E_INVALID_TOKEN); <br>        } <br> <br>        // <br>        // Build a new context. <br>        // <br> <br>        Context = (PSEC_CONTEXT) LocalAlloc(0,sizeof(SEC_CONTEXT)); <br>        if (Context == NULL) <br>        { <br>            return(SEC_E_INSUFFICIENT_MEMORY); <br>        } <br>        Context-&gt;ContextId = GetNewId(); <br>        phNewContext-&gt;dwUpper = Context-&gt;ContextId; <br>        Context-&gt;CredentialId = phCredential-&gt;dwUpper; <br>        Context-&gt;State = FirstAccept; <br>        Context-&gt;Nonce = 0; <br>        Context-&gt;ContextFlags = fContextReq; <br>        *pfContextAttr = fContextReq; <br>        *ptsExpiry = Forever; <br> <br>        // <br>        // Build an output token. <br>        // <br> <br>        Message = (PMESSAGE) OutputBuffer-&gt;pvBuffer; <br>        Message-&gt;MessageType = Challenge; <br>        memset(Message-&gt;Buffer,'y',MESSAGE_SIZE); <br>        OutputBuffer-&gt;cbBuffer = sizeof(MESSAGE); <br> <br>        AddContext(Context); <br> <br>        return(SEC_I_CONTINUE_NEEDED); <br> <br>    } else { <br>        // <br>        // This is the second call. Lookup the old context. <br>        // <br> <br>        Context = LocateContext(phContext-&gt;dwUpper); <br>        if (Context == NULL) <br>        { <br>            return(SEC_E_INVALID_HANDLE); <br>        } <br>        if ((Context-&gt;State != FirstAccept) &amp;&amp; <br>            (Context-&gt;State != SecondAccept)) <br>        { <br>            return(SEC_E_INVALID_HANDLE); <br>        } <br> <br>        Message = (PMESSAGE) InputBuffer-&gt;pvBuffer; <br> <br>        // <br>        // Check that the input message is what we expected. <br>        // <br> <br>        if (Context-&gt;State == FirstAccept) <br>        { <br>            SampleMessage.MessageType = ChallengeResponse; <br>            memset(SampleMessage.Buffer, 'z', MESSAGE_SIZE); <br>        } <br>        else <br>        { <br>            SampleMessage.MessageType = ReAuthenticate; <br>            memset(SampleMessage.Buffer, 'q', MESSAGE_SIZE); <br>        } <br> <br>        if (memcmp(&amp;SampleMessage,Message,MESSAGE_SIZE) != 0) <br>        { <br>            return(SEC_E_INVALID_TOKEN); <br>        } <br> <br>        Context-&gt;State = SecondAccept; <br>        return(SEC_E_OK); <br>    } <br>} <br> <br> <br> <br> <br> <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Function:   DeleteSecurityContext <br>// <br>//  Synopsis: <br>// <br>//  Effects: <br>// <br>//  Arguments: <br>// <br>//  Requires: <br>// <br>//  Returns: <br>// <br>//  Notes: <br>// <br>// <br>//-------------------------------------------------------------------------- <br> <br> <br>SECURITY_STATUS SEC_ENTRY <br>DeleteSecurityContext( <br>    PCtxtHandle                 phContext           // Context to delete <br>    ) <br>{ <br>    if (DeleteContext(phContext-&gt;dwUpper)) <br>    { <br>        return(SEC_E_OK); <br>    } <br>    else <br>    { <br>        return(SEC_E_INVALID_HANDLE); <br>    } <br>} <br> <br> <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Function:   ApplyControlToken <br>// <br>//  Synopsis: <br>// <br>//  Effects: <br>// <br>//  Arguments: <br>// <br>//  Requires: <br>// <br>//  Returns: <br>// <br>//  Notes: <br>// <br>// <br>//-------------------------------------------------------------------------- <br> <br> <br>SECURITY_STATUS SEC_ENTRY <br>ApplyControlToken( <br>    PCtxtHandle                 phContext,          // Context to modify <br>    PSecBufferDesc              pInput              // Input token to apply <br>    ) <br>{ <br>    return(SEC_E_UNSUPPORTED_FUNCTION); <br> <br>} <br> <br> <br> <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Function:   EnumerateSecurityPackagesW <br>// <br>//  Synopsis: <br>// <br>//  Effects: <br>// <br>//  Arguments: <br>// <br>//  Requires: <br>// <br>//  Returns: <br>// <br>//  Notes: <br>// <br>// <br>//-------------------------------------------------------------------------- <br> <br> <br> <br>SECURITY_STATUS SEC_ENTRY <br>EnumerateSecurityPackagesW( <br>    unsigned long SEC_FAR *     pcPackages,         // Receives num. packages <br>    PSecPkgInfoW SEC_FAR *      ppPackageInfo       // Receives array of info <br>    ) <br>{ <br>    SECURITY_STATUS SecStatus; <br> <br>    SecStatus = QuerySecurityPackageInfoW( <br>                    PACKAGE_NAME, <br>                    ppPackageInfo <br>                    ); <br>    if (SecStatus == SEC_E_OK) <br>    { <br>        *pcPackages = 1; <br> <br>    } <br> <br>    return(SecStatus); <br> <br>} <br> <br> <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Function:   QuerySecurityPackageInfoW <br>// <br>//  Synopsis: <br>// <br>//  Effects: <br>// <br>//  Arguments: <br>// <br>//  Requires: <br>// <br>//  Returns: <br>// <br>//  Notes: <br>// <br>// <br>//-------------------------------------------------------------------------- <br> <br> <br>SECURITY_STATUS SEC_ENTRY <br>QuerySecurityPackageInfoW( <br>    LPWSTR                      pszPackageName,     // Name of package <br>    PSecPkgInfoW SEC_FAR *      ppPackageInfo        // Receives package info <br>    ) <br>{ <br>    PSecPkgInfoW PackageInfo; <br>    ULONG PackageInfoSize; <br>    PUCHAR Where; <br> <br>    if (_wcsicmp(pszPackageName, PACKAGE_NAME)) <br>    { <br>        return(SEC_E_SECPKG_NOT_FOUND); <br>    } <br> <br>    PackageInfoSize = sizeof(SecPkgInfoW) + <br>                        (wcslen(PACKAGE_NAME) + 1 + <br>                         wcslen(PACKAGE_COMMENT) + 1) * sizeof(WCHAR); <br> <br>    PackageInfo = (PSecPkgInfoW) LocalAlloc(0,PackageInfoSize); <br>    if (PackageInfo == NULL) <br>    { <br>        return(SEC_E_INSUFFICIENT_MEMORY); <br>    } <br>    PackageInfo-&gt;fCapabilities = PACKAGE_CAPABILITIES; <br>    PackageInfo-&gt;wVersion = PACKAGE_VERSION; <br>    PackageInfo-&gt;wRPCID = PACKAGE_RPCID; <br>    PackageInfo-&gt;cbMaxToken = PACKAGE_MAXTOKEN; <br> <br>    Where = (PUCHAR) (PackageInfo + 1); <br>    PackageInfo-&gt;Name = (LPWSTR) Where; <br>    Where += (wcslen(PACKAGE_NAME) + 1) * sizeof(WCHAR); <br>    wcscpy(PackageInfo-&gt;Name, PACKAGE_NAME); <br> <br>    PackageInfo-&gt;Comment = (LPWSTR) Where; <br>    Where += (wcslen(PACKAGE_COMMENT) + 1) * sizeof(WCHAR); <br>    wcscpy(PackageInfo-&gt;Comment, PACKAGE_COMMENT); <br> <br>    assert(Where - (PBYTE) PackageInfo == (LONG) PackageInfoSize); <br> <br>    *ppPackageInfo = PackageInfo; <br>    return(SEC_E_OK); <br>} <br> <br> <br> <br> <br> <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Function:   FreeContextBuffer <br>// <br>//  Synopsis: <br>// <br>//  Effects: <br>// <br>//  Arguments: <br>// <br>//  Requires: <br>// <br>//  Returns: <br>// <br>//  Notes: <br>// <br>// <br>//-------------------------------------------------------------------------- <br> <br>SECURITY_STATUS SEC_ENTRY <br>FreeContextBuffer( <br>    void SEC_FAR *      pvContextBuffer <br>    ) <br>{ <br>    LocalFree(pvContextBuffer); <br>    return(SEC_E_OK); <br>} <br> <br> <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Function:   CompleteAuthToken <br>// <br>//  Synopsis: <br>// <br>//  Effects: <br>// <br>//  Arguments: <br>// <br>//  Requires: <br>// <br>//  Returns: <br>// <br>//  Notes: <br>// <br>// <br>//-------------------------------------------------------------------------- <br> <br> <br> <br>SECURITY_STATUS SEC_ENTRY <br>CompleteAuthToken( <br>    PCtxtHandle                 phContext,          // Context to complete <br>    PSecBufferDesc              pToken              // Token to complete <br>    ) <br>{ <br> <br>    return(SEC_E_OK); <br>     <br>} <br> <br> <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Function:   ImpersonateSecurityContext <br>// <br>//  Synopsis: <br>// <br>//  Effects: <br>// <br>//  Arguments: <br>// <br>//  Requires: <br>// <br>//  Returns: <br>// <br>//  Notes: <br>// <br>// <br>//-------------------------------------------------------------------------- <br> <br> <br>SECURITY_STATUS SEC_ENTRY <br>ImpersonateSecurityContext( <br>    PCtxtHandle                 phContext           // Context to impersonate <br>    ) <br>{ <br>    return(SEC_E_OK); <br>} <br> <br> <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Function:   RevertSecurityContext <br>// <br>//  Synopsis: <br>// <br>//  Effects: <br>// <br>//  Arguments: <br>// <br>//  Requires: <br>// <br>//  Returns: <br>// </code></pre>
<p>
</p>
<pre><code>//  Notes: <br>// <br>// <br>//-------------------------------------------------------------------------- <br> <br> <br>SECURITY_STATUS SEC_ENTRY <br>RevertSecurityContext( <br>    PCtxtHandle                 phContext           // Context from which to re <br>    ) <br>{ <br>    return(SEC_E_OK); <br>} <br> <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Function:   QueryContextAttributes <br>// <br>//  Synopsis: <br>// <br>//  Effects: <br>// <br>//  Arguments: <br>// <br>//  Requires: <br>// <br>//  Returns: <br>// <br>//  Notes: <br>// <br>// <br>//-------------------------------------------------------------------------- <br> <br> <br> <br>SECURITY_STATUS SEC_ENTRY <br>QueryContextAttributesW( <br>    PCtxtHandle                 phContext,          // Context to query <br>    unsigned long               ulAttribute,        // Attribute to query <br>    void SEC_FAR *              pBuffer             // Buffer for attributes <br>    ) <br>{ <br>    PSEC_CONTEXT Context; <br>    PSecPkgContext_Sizes ContextSizes; <br>    PSecPkgContext_NamesW ContextNames; <br>    PSecPkgContext_Lifespan ContextLifespan; <br>    PSecPkgContext_DceInfo  ContextDceInfo; <br> <br>    Context = LocateContext(phContext-&gt;dwUpper); <br> <br>    if (Context == NULL) <br>    { <br>        return(SEC_E_INVALID_HANDLE); <br>    } <br> <br>    switch(ulAttribute) { <br>    case SECPKG_ATTR_SIZES: <br>        ContextSizes = (PSecPkgContext_Sizes) pBuffer; <br>        ContextSizes-&gt;cbMaxSignature = PACKAGE_SIGNATURE_SIZE; <br>        if ((Context-&gt;ContextFlags &amp; ISC_REQ_CONFIDENTIALITY) != 0) <br>        { <br>            ContextSizes-&gt;cbSecurityTrailer = PACKAGE_SIGNATURE_SIZE; <br>            ContextSizes-&gt;cbBlockSize = 1; <br>        } <br>        else <br>        { <br>            ContextSizes-&gt;cbSecurityTrailer = 0; <br>            ContextSizes-&gt;cbBlockSize = 0; <br>        } <br>        ContextSizes-&gt;cbMaxToken = PACKAGE_MAXTOKEN; <br>        break; <br>    case SECPKG_ATTR_NAMES: <br>        ContextNames = (PSecPkgContext_Names) pBuffer; <br>        ContextNames-&gt;sUserName = (LPWSTR) LocalAlloc(0,sizeof(L"dummy user")); <br>        if (ContextNames-&gt;sUserName == NULL) <br>        { <br>            return(SEC_E_INSUFFICIENT_MEMORY); <br>        } <br>        wcscpy(ContextNames-&gt;sUserName, L"dummy user"); <br>        break; <br>    case SECPKG_ATTR_LIFESPAN: <br>        ContextLifespan = (PSecPkgContext_Lifespan) pBuffer; <br>        ContextLifespan-&gt;tsStart = Never; <br>        ContextLifespan-&gt;tsExpiry = Forever; <br>        break; <br>    case SECPKG_ATTR_DCE_INFO: <br>        ContextDceInfo = (PSecPkgContext_DceInfo) pBuffer; <br>        ContextDceInfo-&gt;AuthzSvc = 0; <br>        ContextDceInfo-&gt;pPac = (PVOID) LocalAlloc(0,sizeof(L"dummy user")); <br>        if (ContextDceInfo-&gt;pPac == NULL) <br>        { <br>            return(SEC_E_INSUFFICIENT_MEMORY); <br>        } <br>        wcscpy((LPWSTR) ContextDceInfo-&gt;pPac, L"dummy user"); <br> <br>        break; <br>    default: <br>        return(SEC_E_INVALID_TOKEN); <br>    } <br> <br>    return(SEC_E_OK); <br>} <br> <br>#if 0 <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Function:   QueryCredentialsAttributes <br>// <br>//  Synopsis: <br>// <br>//  Effects: <br>// <br>//  Arguments: <br>// <br>//  Requires: <br>// <br>//  Returns: <br>// <br>//  Notes: <br>// <br>// <br>//-------------------------------------------------------------------------- <br> <br> <br> <br>SECURITY_STATUS SEC_ENTRY <br>QueryCredentialsAttributesW( <br>    PCredHandle                 phCredentials,      // Credentials to query <br>    unsigned long               ulAttribute,        // Attribute to query <br>    void SEC_FAR *              pBuffer             // Buffer for attributes <br>    ) <br>{ <br>    return( pspPackages[phCredentials-&gt;dwLower].pftTableW-&gt;QueryCredentialsAttributesW( <br>                                        phCredentials, <br>                                        ulAttribute, <br>                                        pBuffer ) ); <br>} <br> <br>#endif <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Function:   MakeSignature <br>// <br>//  Synopsis: <br>// <br>//  Effects: <br>// <br>//  Arguments:  [phContext]     -- context to use <br>//              [fQOP]          -- quality of protection to use <br>//              [pMessage]      -- message <br>//              [MessageSeqNo]  -- sequence number of message <br>// <br>//  Requires: <br>// <br>//  Returns: <br>// <br>//  Notes: <br>// <br>//-------------------------------------------------------------------------- <br>SECURITY_STATUS SEC_ENTRY <br>MakeSignature(  PCtxtHandle         phContext, <br>                ULONG               fQOP, <br>                PSecBufferDesc      pMessage, <br>                ULONG               MessageSeqNo) <br>{ <br>    PSEC_CONTEXT Context; <br>    PSecBuffer SignatureBuffer; <br>    PSIGNATURE Signature; <br> <br>    Context = LocateContext(phContext-&gt;dwUpper); <br>    if (Context == NULL) <br>    { <br>        return(SEC_E_INVALID_HANDLE); <br>    } <br> <br>    SignatureBuffer = LocateSigBuffer(pMessage); <br>    if (SignatureBuffer == NULL) <br>    { <br>        return(SEC_E_INVALID_TOKEN); <br>    } <br>    Signature = (PSIGNATURE) SignatureBuffer-&gt;pvBuffer; <br>    Signature-&gt;MessageId = Context-&gt;Nonce++; <br>    Signature-&gt;Tag = PACKAGE_SIGNATURE_TAG; <br>    SignatureBuffer-&gt;cbBuffer = sizeof(SIGNATURE); <br>    return(SEC_E_OK); <br>} <br> <br> <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Function:   VerifySignature <br>// <br>//  Synopsis: <br>// <br>//  Effects: <br>// <br>//  Arguments:  [phContext]     -- Context performing the unseal <br>//              [pMessage]      -- Message to verify <br>//              [MessageSeqNo]  -- Sequence number of this message <br>//              [pfQOPUsed]     -- quality of protection used <br>// <br>//  Requires: <br>// <br>//  Returns: <br>// <br>//  Notes: <br>// <br>//-------------------------------------------------------------------------- <br>SECURITY_STATUS SEC_ENTRY <br>VerifySignature(PCtxtHandle     phContext, <br>                PSecBufferDesc  pMessage, <br>                ULONG           MessageSeqNo, <br>                ULONG *         pfQOP) <br>{ <br>    PSEC_CONTEXT Context; <br>    PSecBuffer SignatureBuffer; <br>    PSIGNATURE Signature; <br> <br>    Context = LocateContext(phContext-&gt;dwUpper); <br>    if (Context == NULL) <br>    { <br>        return(SEC_E_INVALID_HANDLE); <br>    } <br> <br>    SignatureBuffer = LocateSigBuffer(pMessage); <br>    if (SignatureBuffer == NULL) <br>    { <br>        return(SEC_E_INVALID_TOKEN); <br>    } <br>    Signature = (PSIGNATURE) SignatureBuffer-&gt;pvBuffer; <br> <br>    if (Signature-&gt;Tag != PACKAGE_SIGNATURE_TAG) <br>    { <br>        return(SEC_E_MESSAGE_ALTERED); <br>    } <br> <br>    if (Signature-&gt;MessageId != Context-&gt;Nonce++) <br>    { <br>        Context-&gt;State = Idle; <br>        return(SEC_E_OUT_OF_SEQUENCE); <br>    } <br> <br>    return(SEC_E_OK); <br>} <br> <br> <br> <br> <br> <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
