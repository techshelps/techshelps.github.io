<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>EXIT.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6124"></a>EXIT.CPP</h2>
<pre><code>//+-------------------------------------------------------------------------- <br>// <br>// Microsoft Windows <br>// Copyright (C) Microsoft Corporation, 1996-1997 <br>// <br>// File:        exit.cpp <br>// <br>// Contents:    CCertExit implementation <br>// <br>//--------------------------------------------------------------------------- <br> <br>#include "pch.cpp" <br>#pragma hdrstop <br> <br>#include &lt;stdio.h&gt; <br>#include "exit.h" <br> <br>#define myEXITEVENTS \ <br>EXITEVENT_CERTISSUED | \ <br>EXITEVENT_CERTPENDING | \ <br>EXITEVENT_CERTDENIED | \ <br>EXITEVENT_CERTREVOKED | \ <br>EXITEVENT_CERTRETRIEVEPENDING | \ <br>EXITEVENT_CRLISSUED | \ <br>EXITEVENT_SHUTDOWN <br> <br>#ifndef DBG_CERTSRV <br>#error -- DBG_CERTSRV not defined! <br>#endif <br>BOOL fDebug = DBG_CERTSRV; <br> <br>#define wszDESCRIPTIONL"Sample Exit Module" <br> <br> <br>//+-------------------------------------------------------------------------- <br>// CCertExit::~CCertExit -- destructor <br>// <br>// free memory associated with this instance <br>//+-------------------------------------------------------------------------- <br> <br>CCertExit::~CCertExit() <br>{ <br>    if (NULL != m_strConfig) <br>    { <br>SysFreeString(m_strConfig); <br>    } <br>} <br> <br> <br>//+-------------------------------------------------------------------------- <br>// CCertExit::Initialize -- initialize for a CA &amp; return interesting Event Mask <br>// <br>// Returns S_OK on success. <br>//+-------------------------------------------------------------------------- <br> <br>STDMETHODIMP <br>CCertExit::Initialize( <br>    /* [in] */ BSTR const strConfig, <br>    /* [retval][out] */ LONG __RPC_FAR *pEventMask) <br>{ <br>    HRESULT hr = S_OK; <br> <br>    m_strConfig = SysAllocString(strConfig); <br>    if (NULL == m_strConfig) <br>    { <br>hr = E_OUTOFMEMORY; <br>    } <br>    else <br>    { <br>*pEventMask = myEXITEVENTS; <br>printf("Exit::Initialize(%ws) ==&gt; %x\n", m_strConfig, *pEventMask); <br>    } <br>    return(hr); <br>} <br> <br> <br>HRESULT <br>EnumerateExtensions( <br>    IN ICertServerExit *pServer) <br>{ <br>    HRESULT hr; <br>    HRESULT hr2; <br>    BSTR strName = NULL; <br>    LONG ExtFlags; <br>    VARIANT varValue; <br>    BOOL fClose = FALSE; <br> <br>    VariantInit(&amp;varValue); <br>    hr = pServer-&gt;EnumerateExtensionsSetup(0); <br>    if (S_OK != hr) <br>    { <br>if (fDebug) <br>{ <br>    printf("Exit:EnumerateExtensionsSetup: %x", hr); <br>} <br>goto error; <br>    } <br>    fClose = TRUE; <br>    while (TRUE) <br>    { <br>hr = pServer-&gt;EnumerateExtensions(&amp;strName); <br>if (S_OK != hr) <br>{ <br>    if (S_FALSE == hr) <br>    { <br>hr = S_OK; <br>break; <br>    } <br>    if (fDebug) <br>    { <br>printf("Exit:EnumerateExtensions: %x", hr); <br>    } <br>    goto error; <br>} <br>hr = pServer-&gt;GetCertificateExtension( <br>strName, <br>PROPTYPE_BINARY, <br>&amp;varValue); <br>if (S_OK != hr) <br>{ <br>    if (fDebug) <br>    { <br>printf("Exit:GetCertificateExtension: %x", hr); <br>    } <br>    goto error; <br>} <br>hr = pServer-&gt;GetCertificateExtensionFlags(&amp;ExtFlags); <br>if (S_OK != hr) <br>{ <br>    if (fDebug) <br>    { <br>printf("Exit:GetCertificateExtensionFlags: %x", hr); <br>    } <br>    goto error; <br>} <br>if (fDebug) <br>{ <br>    printf( <br>"Exit:EnumerateExtensions(%ws, Flags=%x, %x bytes)\n", <br>strName, <br>ExtFlags, <br>SysStringByteLen(varValue.bstrVal)); <br>} <br>VariantClear(&amp;varValue); <br>    } <br> <br>error: <br>    if (fClose) <br>    { <br>hr2 = pServer-&gt;EnumerateExtensionsClose(); <br>if (S_OK != hr2) <br>{ <br>    if (fDebug) <br>    { <br>printf("Exit:EnumerateExtensionsClose: %x", hr2); <br>    } <br>    if (S_OK == hr) <br>    { <br>hr = hr2; <br>    } <br>    goto error; <br>} <br>    } <br>    if (NULL != strName) <br>    { <br>SysFreeString(strName); <br>    } <br>    VariantClear(&amp;varValue); <br>    return(hr); <br>} <br> <br> <br>HRESULT <br>EnumerateAttributes( <br>    IN ICertServerExit *pServer) <br>{ <br>    HRESULT hr; <br>    HRESULT hr2; <br>    BSTR strName = NULL; <br>    BOOL fClose = FALSE; <br>    BSTR strValue = NULL; <br> <br>    hr = pServer-&gt;EnumerateAttributesSetup(0); <br>    if (S_OK != hr) <br>    { <br>if (fDebug) <br>{ <br>    printf("Exit:EnumerateAttributesSetup: %x", hr); <br>} <br>goto error; <br>    } <br>    fClose = TRUE; <br>    while (TRUE) <br>    { <br>hr = pServer-&gt;EnumerateAttributes(&amp;strName); <br>if (S_OK != hr) <br>{ <br>    if (S_FALSE == hr) <br>    { <br>hr = S_OK; <br>break; <br>    } <br>    if (fDebug) <br>    { <br>printf("Exit:EnumerateAttributes: %x", hr); <br>    } <br>    goto error; <br>} <br>hr = pServer-&gt;GetRequestAttribute(strName, &amp;strValue); <br>if (S_OK != hr) <br>{ <br>    if (fDebug) <br>    { <br>printf("Exit:GetRequestAttribute: %x", hr); <br>    } <br>    goto error; <br>} <br>if (fDebug) <br>{ <br>    printf("Exit:EnumerateAttributes(%ws = %ws)\n", strName, strValue); <br>} <br>if (NULL != strValue) <br>{ <br>    SysFreeString(strValue); <br>    strValue = NULL; <br>} <br>    } <br> <br>error: <br>    if (fClose) <br>    { <br>hr2 = pServer-&gt;EnumerateAttributesClose(); <br>if (S_OK != hr2) <br>{ <br>    if (fDebug) <br>    { <br>printf("Exit:EnumerateAttributesClose: %x", hr2); <br>    } <br>    if (S_OK == hr) <br>    { <br>hr = hr2; <br>    } <br>    goto error; <br>} <br>    } <br> <br>    if (NULL != strName) <br>    { <br>SysFreeString(strName); <br>    } <br>    if (NULL != strValue) <br>    { <br>SysFreeString(strValue); <br>    } <br>    return(hr); <br>} <br> <br> <br>HRESULT <br>CheckRequestProperties( <br>    IN ICertServerExit *pServer) <br>{ <br>    HRESULT hr; <br>    VARIANT varValue; <br>    BSTR strName = NULL; <br> <br>    VariantInit(&amp;varValue); <br> <br>    strName = SysAllocString(wszPROPREQUESTREQUESTID); <br>    if (NULL == strName) <br>    { <br>hr = E_OUTOFMEMORY; <br>goto error; <br>    } <br> <br>    hr = pServer-&gt;GetRequestProperty(strName, PROPTYPE_LONG, &amp;varValue); <br>    if (S_OK != hr) <br>    { <br>if (fDebug) <br>{ <br>    printf("Exit:GetRequestProperty: %x", hr); <br>} <br>goto error; <br>    } <br>    if (fDebug) <br>    { <br>printf( <br>    "Exit:CheckRequestProperties(%ws = %x)\n", <br>    strName, <br>    varValue.lVal); <br>    } <br>    VariantClear(&amp;varValue); <br> <br>error: <br>    if (NULL != strName) <br>    { <br>SysFreeString(strName); <br>    } <br>    return(hr); <br>} <br> <br> <br>HRESULT <br>CheckCert( <br>    LONG Context) <br>{ <br>    HRESULT hr; <br>    ICertServerExit *pServer = NULL; <br> <br>    hr = CoCreateInstance( <br>    CLSID_CCertServerExit, <br>    NULL,// pUnkOuter <br>    CLSCTX_INPROC_SERVER, <br>    IID_ICertServerExit, <br>    (VOID **) &amp;pServer); <br>    if (S_OK != hr) <br>    { <br>goto exit; <br>    } <br> <br>    hr = pServer-&gt;SetContext(Context); <br>    if (S_OK != hr) <br>    { <br>goto exit; <br>    } <br>    hr = EnumerateExtensions(pServer); <br>    if (S_OK != hr) <br>    { <br>goto exit; <br>    } <br> <br>    hr = EnumerateAttributes(pServer); <br>    if (S_OK != hr) <br>    { <br>goto exit; <br>    } <br> <br>    hr = CheckRequestProperties(pServer); <br>    if (S_OK != hr) <br>    { <br>goto exit; <br>    } <br> <br>exit: <br>    if (NULL != pServer) <br>    { <br>pServer-&gt;Release(); <br>    } <br>    return(hr); <br>} <br> <br> <br>//+-------------------------------------------------------------------------- <br>// CCertExit::Notify -- Notify the exit module of an event <br>// <br>// Returns S_OK. <br>//+-------------------------------------------------------------------------- <br> <br>STDMETHODIMP <br>CCertExit::Notify( <br>    /* [in] */ LONG Event, <br>    /* [in] */ LONG Context) <br>{ <br>    HRESULT hr = S_OK; <br>    char *psz = "UNKNOWN EVENT"; <br> <br>    switch (Event) <br>    { <br>case EXITEVENT_CERTISSUED: <br>    psz = "certissued"; <br>    break; <br> <br>case EXITEVENT_CERTPENDING: <br>    psz = "certpending"; <br>    break; <br> <br>case EXITEVENT_CERTDENIED: <br>    psz = "certdenied"; <br>    break; <br> <br>case EXITEVENT_CERTREVOKED: <br>    psz = "certrevoked"; <br>    break; <br> <br>case EXITEVENT_CERTRETRIEVEPENDING: <br>    psz = "retrievepending"; <br>    break; <br> <br>case EXITEVENT_CRLISSUED: <br>    psz = "crlissued"; <br>    break; <br> <br>case EXITEVENT_SHUTDOWN: <br>    psz = "shutdown"; <br>    break; <br>    } <br>    printf("Exit::Notify(%s=%x, ctx=%u)\n", psz, Event, Context); <br> <br>    if (EXITEVENT_CERTISSUED == Event) <br>    { <br>hr = CheckCert(Context); <br>    } <br>    return(hr); <br>} <br> <br> <br>STDMETHODIMP <br>CCertExit::GetDescription( <br>    /* [retval][out] */ BSTR *pstrDescription) <br>{ <br>    HRESULT hr = S_OK; <br> <br>    *pstrDescription = SysAllocString(wszDESCRIPTION); <br>    if (NULL == *pstrDescription) <br>    { <br>hr = E_OUTOFMEMORY; <br>    } <br>    return(hr); <br>} <br> <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// <br> <br>STDMETHODIMP <br>CCertExit::InterfaceSupportsErrorInfo(REFIID riid) <br>{ <br>    int i; <br>    static const IID *arr[] = <br>    { <br>&amp;IID_ICertExit, <br>    }; <br> <br>    for (i = 0; i &lt; sizeof(arr)/sizeof(arr[0]); i++) <br>    { <br>if (InlineIsEqualGUID(*arr[i],riid)) <br>{ <br>    return(S_OK); <br>} <br>    } <br>    return(S_FALSE); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
