<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CONST.BAS</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6142"></a>CONST.BAS</h2>
<pre><code>Attribute VB_Name = "Const" <br>Option Explicit <br>'+--------------------------------------------------------------------------- <br>' <br>' Microsoft Windows <br>' <br>' File: wincrypt.h <br>' <br>' Contents: Cryptographic API Prototypes and Definitions <br>' <br>'---------------------------------------------------------------------------- <br>' <br>' Algorithm IDs and Flags <br>' <br>' ALG_ID crackers <br>' Algorithm classes <br>Public Const ALG_CLASS_ANY As Long = 0 <br>' Algorithm types <br>Public Const ALG_TYPE_ANY As Long = 0 <br>' Generic sub-ids <br>Public Const ALG_SID_ANY As Long = 0 <br>' Some RSA sub-ids <br>Public Const ALG_SID_RSA_ANY As Long = 0 <br>Public Const ALG_SID_RSA_PKCS As Long = 1 <br>Public Const ALG_SID_RSA_MSATWORK As Long = 2 <br>Public Const ALG_SID_RSA_ENTRUST As Long = 3 <br>Public Const ALG_SID_RSA_PGP As Long = 4 <br>' Some DSS sub-ids <br>' <br>Public Const ALG_SID_DSS_ANY As Long = 0 <br>Public Const ALG_SID_DSS_PKCS As Long = 1 <br>Public Const ALG_SID_DSS_DMS As Long = 2 <br>' Block cipher sub ids <br>' DES sub_ids <br>Public Const ALG_SID_DES As Long = 1 <br>Public Const ALG_SID_3DES As Long = 3 <br>Public Const ALG_SID_DESX As Long = 4 <br>Public Const ALG_SID_IDEA As Long = 5 <br>Public Const ALG_SID_CAST As Long = 6 <br>Public Const ALG_SID_SAFERSK64 As Long = 7 <br>Public Const ALD_SID_SAFERSK128 As Long = 8 <br>Public Const ALG_SID_3DES_112 As Long = 9 <br>Public Const ALG_SID_CYLINK_MEK As Long = 12 <br>Public Const ALG_SID_RC5 As Long = 13 <br>' Fortezza sub-ids <br>Public Const ALG_SID_SKIPJACK As Long = 10 <br>Public Const ALG_SID_TEK As Long = 11 <br>' KP_MODE <br>Public Const CRYPT_MODE_CBCI As Long = 6 <br>Public Const CRYPT_MODE_CFBP As Long = 7 <br>Public Const CRYPT_MODE_OFBP As Long = 8 <br>Public Const CRYPT_MODE_CBCOFM As Long = 9 <br>Public Const CRYPT_MODE_CBCOFMI As Long = 10 <br>' RC2 sub-ids <br>Public Const ALG_SID_RC2 As Long = 2 <br>' Stream cipher sub-ids <br>Public Const ALG_SID_RC4 As Long = 1 <br>Public Const ALG_SID_SEAL As Long = 2 <br>' Diffie-Hellman sub-ids <br>Public Const ALG_SID_DH_SANDF As Long = 1 <br>Public Const ALG_SID_DH_EPHEM As Long = 2 <br>Public Const ALG_SID_AGREED_KEY_ANY As Long = 3 <br>Public Const ALG_SID_KEA As Long = 4 <br>' Hash sub ids <br>Public Const ALG_SID_MD2 As Long = 1 <br>Public Const ALG_SID_MD4 As Long = 2 <br>Public Const ALG_SID_MD5 As Long = 3 <br>Public Const ALG_SID_SHA As Long = 4 <br>Public Const ALG_SID_SHA1 As Long = 4 <br>Public Const ALG_SID_MAC As Long = 5 <br>Public Const ALG_SID_RIPEMD As Long = 6 <br>Public Const ALG_SID_RIPEMD160 As Long = 7 <br>Public Const ALG_SID_SSL3SHAMD5 As Long = 8 <br>Public Const ALG_SID_HMAC As Long = 9 <br>' secure channel sub ids <br>Public Const ALG_SID_SSL3_MASTER As Long = 1 <br>Public Const ALG_SID_SCHANNEL_MASTER_HASH As Long = 2 <br>Public Const ALG_SID_SCHANNEL_MAC_KEY As Long = 3 <br>Public Const ALG_SID_PCT1_MASTER As Long = 4 <br>Public Const ALG_SID_SSL2_MASTER As Long = 5 <br>Public Const ALG_SID_TLS1_MASTER As Long = 6 <br>Public Const ALG_SID_SCHANNEL_ENC_KEY As Long = 7 <br>' Our silly example sub-id <br>Public Const ALG_SID_EXAMPLE As Long = 80 <br>' algorithm identifier definitions <br>' dwFlags definitions for CryptAcquireContext <br>Public Const CRYPT_VERIFYCONTEXT As Long = &amp;HF0000000 <br>Public Const CRYPT_NEWKEYSET As Long = &amp;H00000008 <br>Public Const CRYPT_DELETEKEYSET As Long = &amp;H00000010 <br>Public Const CRYPT_MACHINE_KEYSET As Long = &amp;H00000020 <br>' dwFlag definitions for CryptGenKey <br>Public Const CRYPT_EXPORTABLE As Long = &amp;H00000001 <br>Public Const CRYPT_USER_PROTECTED As Long = &amp;H00000002 <br>Public Const CRYPT_CREATE_SALT As Long = &amp;H00000004 <br>Public Const CRYPT_UPDATE_KEY As Long = &amp;H00000008 <br>Public Const CRYPT_NO_SALT As Long = &amp;H00000010 <br>Public Const CRYPT_PREGEN As Long = &amp;H00000040 <br>Public Const CRYPT_RECIPIENT As Long = &amp;H00000010 <br>Public Const CRYPT_INITIATOR As Long = &amp;H00000040 <br>Public Const CRYPT_ONLINE As Long = &amp;H00000080 <br>Public Const CRYPT_SF As Long = &amp;H00000100 <br>Public Const CRYPT_CREATE_IV As Long = &amp;H00000200 <br>Public Const CRYPT_KEK As Long = &amp;H00000400 <br>Public Const CRYPT_DATA_KEY As Long = &amp;H00000800 <br>' dwFlags definitions for CryptDeriveKey <br>Public Const CRYPT_SERVER As Long = &amp;H00000400 <br>Public Const KEY_LENGTH_MASK As Long = &amp;HFFFF0000 <br>' dwFlag definitions for CryptExportKey <br>Public Const CRYPT_Y_ONLY As Long = &amp;H00000001 <br>Public Const CRYPT_SSL2_SLUMMING As Long = &amp;H00000002 <br>' dwFlags definitions for CryptHashSessionKey <br>Public Const CRYPT_LITTLE_ENDIAN As Long = &amp;H00000001 <br>' dwFlag definitions for CryptSetProviderEx and CryptGetDefaultProvider <br>Public Const CRYPT_MACHINE_DEFAULT As Long = &amp;H00000001 <br>Public Const CRYPT_USER_DEFAULT As Long = &amp;H00000002 <br>Public Const CRYPT_DELETE_DEFAULT As Long = &amp;H00000004 <br>' exported key blob definitions <br>Public Const SIMPLEBLOB As Long = &amp;H1 <br>Public Const PUBLICKEYBLOB As Long = &amp;H6 <br>Public Const PRIVATEKEYBLOB As Long = &amp;H7 <br>Public Const PLAINTEXTKEYBLOB As Long = &amp;H8 <br>Public Const AT_KEYEXCHANGE As Long = 1 <br>Public Const AT_SIGNATURE As Long = 2 <br>Public Const CRYPT_USERDATA As Long = 1 <br>' dwParam <br>Public Const KP_IV As Long = 1 <br>Public Const KP_SALT As Long = 2 <br>Public Const KP_PADDING As Long = 3 <br>Public Const KP_MODE As Long = 4 <br>Public Const KP_MODE_BITS As Long = 5 <br>Public Const KP_PERMISSIONS As Long = 6 <br>Public Const KP_ALGID As Long = 7 <br>Public Const KP_BLOCKLEN As Long = 8 <br>Public Const KP_KEYLEN As Long = 9 <br>Public Const KP_SALT_EX As Long = 10 <br>Public Const KP_P As Long = 11 <br>Public Const KP_G As Long = 12 <br>Public Const KP_Q As Long = 13 <br>Public Const KP_X As Long = 14 <br>Public Const KP_Y As Long = 15 <br>Public Const KP_RA As Long = 16 <br>Public Const KP_RB As Long = 17 <br>Public Const KP_INFO As Long = 18 <br>Public Const KP_EFFECTIVE_KEYLEN As Long = 19 <br>Public Const KP_SCHANNEL_ALG As Long = 20 <br>Public Const KP_CLIENT_RANDOM As Long = 21 <br>Public Const KP_SERVER_RANDOM As Long = 22 <br>Public Const KP_RP As Long = 23 <br>Public Const KP_PRECOMP_MD5 As Long = 24 <br>Public Const KP_PRECOMP_SHA As Long = 25 <br>Public Const KP_CERTIFICATE As Long = 26 <br>Public Const KP_CLEAR_KEY As Long = 27 <br>Public Const KP_PUB_EX_LEN As Long = 28 <br>Public Const KP_PUB_EX_VAL As Long = 29 <br>' KP_PADDING <br>Public Const PKCS5_PADDING As Long = 1 <br>Public Const RANDOM_PADDING As Long = 2 <br>Public Const ZERO_PADDING As Long = 3 <br>' KP_MODE <br>Public Const CRYPT_MODE_CBC As Long = 1 <br>Public Const CRYPT_MODE_ECB As Long = 2 <br>Public Const CRYPT_MODE_OFB As Long = 3 <br>Public Const CRYPT_MODE_CFB As Long = 4 <br>Public Const CRYPT_MODE_CTS As Long = 5 <br>' KP_PERMISSIONS <br>Public Const CRYPT_ENCRYPT As Long = &amp;H0001 <br>Public Const CRYPT_DECRYPT As Long = &amp;H0002 <br>Public Const CRYPT_EXPORT As Long = &amp;H0004 <br>Public Const CRYPT_READ As Long = &amp;H0008 <br>Public Const CRYPT_WRITE As Long = &amp;H0010 <br>Public Const CRYPT_MAC As Long = &amp;H0020 <br>Public Const CRYPT_EXPORT_KEY As Long = &amp;H0040 <br>Public Const CRYPT_IMPORT_KEY As Long = &amp;H0080 <br>Public Const HP_ALGID As Long = &amp;H0001 <br>Public Const HP_HASHVAL As Long = &amp;H0002 <br>Public Const HP_HASHSIZE As Long = &amp;H0004 <br>Public Const HP_HMAC_INFO As Long = &amp;H0005 <br>' <br>' CryptGetProvParam <br>' <br>Public Const PP_ENUMALGS As Long = 1 <br>Public Const PP_ENUMCONTAINERS As Long = 2 <br>Public Const PP_IMPTYPE As Long = 3 <br>Public Const PP_NAME As Long = 4 <br>Public Const PP_VERSION As Long = 5 <br>Public Const PP_CONTAINER As Long = 6 <br>Public Const PP_CHANGE_PASSWORD As Long = 7 <br>Public Const PP_KEYSET_SEC_DESCR As Long = 8 <br>Public Const PP_CERTCHAIN As Long = 9 <br>Public Const PP_KEY_TYPE_SUBTYPE As Long = 10 <br>Public Const PP_PROVTYPE As Long = 16 <br>Public Const PP_KEYSTORAGE As Long = 17 <br>Public Const PP_APPLI_CERT As Long = 18 <br>Public Const PP_SYM_KEYSIZE As Long = 19 <br>Public Const PP_SESSION_KEYSIZE As Long = 20 <br>Public Const PP_UI_PROMPT As Long = 21 <br>Public Const PP_ENUMALGS_EX As Long = 22 <br>Public Const CRYPT_FIRST As Long = 1 <br>Public Const CRYPT_NEXT As Long = 2 <br>Public Const CRYPT_IMPL_HARDWARE As Long = 1 <br>Public Const CRYPT_IMPL_SOFTWARE As Long = 2 <br>Public Const CRYPT_IMPL_MIXED As Long = 3 <br>Public Const CRYPT_IMPL_UNKNOWN As Long = 4 <br>' key storage flags <br>Public Const CRYPT_SEC_DESCR As Long = &amp;H00000001 <br>Public Const CRYPT_PSTORE As Long = &amp;H00000002 <br>Public Const CRYPT_UI_PROMPT As Long = &amp;H00000004 <br>' protocol flags <br>Public Const CRYPT_FLAG_PCT1 As Long = &amp;H0001 <br>Public Const CRYPT_FLAG_SSL2 As Long = &amp;H0002 <br>Public Const CRYPT_FLAG_SSL3 As Long = &amp;H0004 <br>Public Const CRYPT_FLAG_TLS1 As Long = &amp;H0008 <br>' <br>' CryptSetProvParam <br>' <br>Public Const PP_CLIENT_HWND As Long = 1 <br>Public Const PP_CONTEXT_INFO As Long = 11 <br>Public Const PP_KEYEXCHANGE_KEYSIZE As Long = 12 <br>Public Const PP_SIGNATURE_KEYSIZE As Long = 13 <br>Public Const PP_KEYEXCHANGE_ALG As Long = 14 <br>Public Const PP_SIGNATURE_ALG As Long = 15 <br>Public Const PROV_RSA_FULL As Long = 1 <br>Public Const PROV_RSA_SIG As Long = 2 <br>Public Const PROV_DSS As Long = 3 <br>Public Const PROV_FORTEZZA As Long = 4 <br>Public Const PROV_MS_EXCHANGE As Long = 5 <br>Public Const PROV_SSL As Long = 6 <br>Public Const PROV_RSA_SCHANNEL As Long = 12 <br>Public Const PROV_DSS_DH As Long = 13 <br>Public Const PROV_EC_ECDSA As Long = 14 <br>Public Const PROV_EC_ECNR As Long = 15 <br>Public Const PROV_EC_ECDSA_FULL As Long = 16 <br>Public Const PROV_EC_ECNR_FULL As Long = 17 <br>Public Const PROV_SPYRUS_LYNKS As Long = 20 <br>' <br>' STT defined Providers <br>' <br>Public Const PROV_STT_MER As Long = 7 <br>Public Const PROV_STT_ACQ As Long = 8 <br>Public Const PROV_STT_BRND As Long = 9 <br>Public Const PROV_STT_ROOT As Long = 10 <br>Public Const PROV_STT_ISS As Long = 11 <br>' <br>' Provider friendly names <br>' <br>Public Const MS_DEF_PROV_A As String = "Microsoft Base Cryptographic Provider v1.0" <br>Public Const MS_DEF_PROV_W As String = "Microsoft Base Cryptographic Provider v1.0" <br>Public Const MS_ENHANCED_PROV_A As String = "Microsoft Enhanced Cryptographic Provider v1.0" <br>Public Const MS_ENHANCED_PROV_W As String = "Microsoft Enhanced Cryptographic Provider v1.0" <br>Public Const MS_DEF_DSS_PROV_A As String = "Microsoft Base DSS Cryptographic Provider" <br>Public Const MS_DEF_DSS_PROV_W As String = "Microsoft Base DSS Cryptographic Provider" <br>Public Const MAXUIDLEN As Long = 64 <br>Public Const CUR_BLOB_VERSION As Long = 2 <br>' structure for use with CryptSetHashParam with CALG_HMAC <br>' structure for use with CryptSetKeyParam with KP_SCHANNEL_ALG <br>' uses of algortihms for SCHANNEL_ALG structure <br>Public Const SCHANNEL_MAC_KEY As Long = &amp;H00000000 <br>Public Const SCHANNEL_ENC_KEY As Long = &amp;H00000001 <br>'+------------------------------------------------------------------------- <br>' CRYPTOAPI BLOB definitions <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' In a CRYPT_BIT_BLOB the last byte may contain 0-7 unused bits. Therefore, the <br>' overall bit length is cbData * 8 - cUnusedBits. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' Type used for any algorithm <br>' <br>' Where the Parameters CRYPT_OBJID_BLOB is in its encoded representation. For most <br>'-------------------------------------------------------------------------- <br>' Following are the definitions of various algorithm object identifiers <br>' RSA <br>Public Const szOID_RSA As String = "1.2.840.113549" <br>Public Const szOID_PKCS As String = "1.2.840.113549.1" <br>Public Const szOID_RSA_HASH As String = "1.2.840.113549.2" <br>Public Const szOID_RSA_ENCRYPT As String = "1.2.840.113549.3" <br>Public Const szOID_PKCS_1 As String = "1.2.840.113549.1.1" <br>Public Const szOID_PKCS_2 As String = "1.2.840.113549.1.2" <br>Public Const szOID_PKCS_3 As String = "1.2.840.113549.1.3" <br>Public Const szOID_PKCS_4 As String = "1.2.840.113549.1.4" <br>Public Const szOID_PKCS_5 As String = "1.2.840.113549.1.5" <br>Public Const szOID_PKCS_6 As String = "1.2.840.113549.1.6" <br>Public Const szOID_PKCS_7 As String = "1.2.840.113549.1.7" <br>Public Const szOID_PKCS_8 As String = "1.2.840.113549.1.8" <br>Public Const szOID_PKCS_9 As String = "1.2.840.113549.1.9" <br>Public Const szOID_PKCS_10 As String = "1.2.840.113549.1.10" <br>Public Const szOID_RSA_RSA As String = "1.2.840.113549.1.1.1" <br>Public Const szOID_RSA_MD2RSA As String = "1.2.840.113549.1.1.2" <br>Public Const szOID_RSA_MD4RSA As String = "1.2.840.113549.1.1.3" <br>Public Const szOID_RSA_MD5RSA As String = "1.2.840.113549.1.1.4" <br>Public Const szOID_RSA_SHA1RSA As String = "1.2.840.113549.1.1.5" <br>Public Const szOID_RSA_SETOAEP_RSA As String = "1.2.840.113549.1.1.6" <br>Public Const szOID_RSA_data As String = "1.2.840.113549.1.7.1" <br>Public Const szOID_RSA_signedData As String = "1.2.840.113549.1.7.2" <br>Public Const szOID_RSA_envelopedData As String = "1.2.840.113549.1.7.3" <br>Public Const szOID_RSA_signEnvData As String = "1.2.840.113549.1.7.4" <br>Public Const szOID_RSA_digestedData As String = "1.2.840.113549.1.7.5" <br>Public Const szOID_RSA_hashedData As String = "1.2.840.113549.1.7.5" <br>Public Const szOID_RSA_encryptedData As String = "1.2.840.113549.1.7.6" <br>Public Const szOID_RSA_emailAddr As String = "1.2.840.113549.1.9.1" <br>Public Const szOID_RSA_unstructName As String = "1.2.840.113549.1.9.2" <br>Public Const szOID_RSA_contentType As String = "1.2.840.113549.1.9.3" <br>Public Const szOID_RSA_messageDigest As String = "1.2.840.113549.1.9.4" <br>Public Const szOID_RSA_signingTime As String = "1.2.840.113549.1.9.5" <br>Public Const szOID_RSA_counterSign As String = "1.2.840.113549.1.9.6" <br>Public Const szOID_RSA_challengePwd As String = "1.2.840.113549.1.9.7" <br>Public Const szOID_RSA_unstructAddr As String = "1.2.840.113549.1.9.8" <br>Public Const szOID_RSA_extCertAttrs As String = "1.2.840.113549.1.9.9" <br>Public Const szOID_RSA_MD2 As String = "1.2.840.113549.2.2" <br>Public Const szOID_RSA_MD4 As String = "1.2.840.113549.2.4" <br>Public Const szOID_RSA_MD5 As String = "1.2.840.113549.2.5" <br>Public Const szOID_RSA_RC2CBC As String = "1.2.840.113549.3.2" <br>Public Const szOID_RSA_RC4 As String = "1.2.840.113549.3.4" <br>' ITU-T UsefulDefinitions <br>Public Const szOID_DS As String = "2.5" <br>Public Const szOID_DSALG As String = "2.5.8" <br>Public Const szOID_DSALG_CRPT As String = "2.5.8.1" <br>Public Const szOID_DSALG_HASH As String = "2.5.8.2" <br>Public Const szOID_DSALG_SIGN As String = "2.5.8.3" <br>Public Const szOID_DSALG_RSA As String = "2.5.8.1.1" <br>' http: <br>' http: <br>Public Const szOID_OIW As String = "1.3.14" <br>Public Const szOID_OIWSEC As String = "1.3.14.3.2" <br>Public Const szOID_OIWSEC_md4RSA As String = "1.3.14.3.2.2" <br>Public Const szOID_OIWSEC_md5RSA As String = "1.3.14.3.2.3" <br>Public Const szOID_OIWSEC_md4RSA2 As String = "1.3.14.3.2.4" <br>Public Const szOID_OIWSEC_desECB As String = "1.3.14.3.2.6" <br>Public Const szOID_OIWSEC_desCBC As String = "1.3.14.3.2.7" <br>Public Const szOID_OIWSEC_desOFB As String = "1.3.14.3.2.8" <br>Public Const szOID_OIWSEC_desCFB As String = "1.3.14.3.2.9" <br>Public Const szOID_OIWSEC_desMAC As String = "1.3.14.3.2.10" <br>Public Const szOID_OIWSEC_rsaSign As String = "1.3.14.3.2.11" <br>Public Const szOID_OIWSEC_dsa As String = "1.3.14.3.2.12" <br>Public Const szOID_OIWSEC_shaDSA As String = "1.3.14.3.2.13" <br>Public Const szOID_OIWSEC_mdc2RSA As String = "1.3.14.3.2.14" <br>Public Const szOID_OIWSEC_shaRSA As String = "1.3.14.3.2.15" <br>Public Const szOID_OIWSEC_dhCommMod As String = "1.3.14.3.2.16" <br>Public Const szOID_OIWSEC_desEDE As String = "1.3.14.3.2.17" <br>Public Const szOID_OIWSEC_sha As String = "1.3.14.3.2.18" <br>Public Const szOID_OIWSEC_mdc2 As String = "1.3.14.3.2.19" <br>Public Const szOID_OIWSEC_dsaComm As String = "1.3.14.3.2.20" <br>Public Const szOID_OIWSEC_dsaCommSHA As String = "1.3.14.3.2.21" <br>Public Const szOID_OIWSEC_rsaXchg As String = "1.3.14.3.2.22" <br>Public Const szOID_OIWSEC_keyHashSeal As String = "1.3.14.3.2.23" <br>Public Const szOID_OIWSEC_md2RSASign As String = "1.3.14.3.2.24" <br>Public Const szOID_OIWSEC_md5RSASign As String = "1.3.14.3.2.25" <br>Public Const szOID_OIWSEC_sha1 As String = "1.3.14.3.2.26" <br>Public Const szOID_OIWSEC_dsaSHA1 As String = "1.3.14.3.2.27" <br>Public Const szOID_OIWSEC_dsaCommSHA1 As String = "1.3.14.3.2.28" <br>Public Const szOID_OIWSEC_sha1RSASign As String = "1.3.14.3.2.29" <br>Public Const szOID_OIWDIR As String = "1.3.14.7.2" <br>Public Const szOID_OIWDIR_CRPT As String = "1.3.14.7.2.1" <br>Public Const szOID_OIWDIR_HASH As String = "1.3.14.7.2.2" <br>Public Const szOID_OIWDIR_SIGN As String = "1.3.14.7.2.3" <br>Public Const szOID_OIWDIR_md2 As String = "1.3.14.7.2.2.1" <br>Public Const szOID_OIWDIR_md2RSA As String = "1.3.14.7.2.3.1" <br>' INFOSEC Algorithms <br>Public Const szOID_INFOSEC As String = "2.16.840.1.101.2.1" <br>Public Const szOID_INFOSEC_sdnsSignature As String = "2.16.840.1.101.2.1.1.1" <br>Public Const szOID_INFOSEC_mosaicSignature As String = "2.16.840.1.101.2.1.1.2" <br>Public Const szOID_INFOSEC_sdnsConfidentiality As String = "2.16.840.1.101.2.1.1.3" <br>Public Const szOID_INFOSEC_mosaicConfidentiality As String = "2.16.840.1.101.2.1.1.4" <br>Public Const szOID_INFOSEC_sdnsIntegrity As String = "2.16.840.1.101.2.1.1.5" <br>Public Const szOID_INFOSEC_mosaicIntegrity As String = "2.16.840.1.101.2.1.1.6" <br>Public Const szOID_INFOSEC_sdnsTokenProtection As String = "2.16.840.1.101.2.1.1.7" <br>Public Const szOID_INFOSEC_mosaicTokenProtection As String = "2.16.840.1.101.2.1.1.8" <br>Public Const szOID_INFOSEC_sdnsKeyManagement As String = "2.16.840.1.101.2.1.1.9" <br>Public Const szOID_INFOSEC_mosaicKeyManagement As String = "2.16.840.1.101.2.1.1.10" <br>Public Const szOID_INFOSEC_sdnsKMandSig As String = "2.16.840.1.101.2.1.1.11" <br>Public Const szOID_INFOSEC_mosaicKMandSig As String = "2.16.840.1.101.2.1.1.12" <br>Public Const szOID_INFOSEC_SuiteASignature As String = "2.16.840.1.101.2.1.1.13" <br>Public Const szOID_INFOSEC_SuiteAConfidentiality As String = "2.16.840.1.101.2.1.1.14" <br>Public Const szOID_INFOSEC_SuiteAIntegrity As String = "2.16.840.1.101.2.1.1.15" <br>Public Const szOID_INFOSEC_SuiteATokenProtection As String = "2.16.840.1.101.2.1.1.16" <br>Public Const szOID_INFOSEC_SuiteAKeyManagement As String = "2.16.840.1.101.2.1.1.17" <br>Public Const szOID_INFOSEC_SuiteAKMandSig As String = "2.16.840.1.101.2.1.1.18" <br>Public Const szOID_INFOSEC_mosaicUpdatedSig As String = "2.16.840.1.101.2.1.1.19" <br>Public Const szOID_INFOSEC_mosaicKMandUpdSig As String = "2.16.840.1.101.2.1.1.20" <br>Public Const szOID_INFOSEC_mosaicUpdatedInteg As String = "2.16.840.1.101.2.1.1.21" <br>'+------------------------------------------------------------------------- <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' Type used for an extension to an encoded content <br>' <br>' Where the Value's CRYPT_OBJID_BLOB is in its encoded representation. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' AttributeTypeValue <br>' <br>' Where the Value's CRYPT_OBJID_BLOB is in its encoded representation. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' Attributes <br>' <br>' Where the Value's PATTR_BLOBs are in their encoded representation. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' <br>' The interpretation of the Value depends on the dwValueType. <br>' See below for a list of the types. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' CERT_RDN attribute Object Identifiers <br>'-------------------------------------------------------------------------- <br>' Labeling attribute types: <br>Public Const szOID_COMMON_NAME As String = "2.5.4.3" <br>Public Const szOID_SUR_NAME As String = "2.5.4.4" <br>Public Const szOID_DEVICE_SERIAL_NUMBER As String = "2.5.4.5" <br>' Geographic attribute types: <br>Public Const szOID_COUNTRY_NAME As String = "2.5.4.6" <br>Public Const szOID_LOCALITY_NAME As String = "2.5.4.7" <br>Public Const szOID_STATE_OR_PROVINCE_NAME As String = "2.5.4.8" <br>Public Const szOID_STREET_ADDRESS As String = "2.5.4.9" <br>' Organizational attribute types: <br>Public Const szOID_ORGANIZATION_NAME As String = "2.5.4.10" <br>Public Const szOID_ORGANIZATIONAL_UNIT_NAME As String = "2.5.4.11" <br>Public Const szOID_TITLE As String = "2.5.4.12" <br>' Explanatory attribute types: <br>Public Const szOID_DESCRIPTION As String = "2.5.4.13" <br>Public Const szOID_SEARCH_GUIDE As String = "2.5.4.14" <br>Public Const szOID_BUSINESS_CATEGORY As String = "2.5.4.15" <br>' Postal addressing attribute types: <br>Public Const szOID_POSTAL_ADDRESS As String = "2.5.4.16" <br>Public Const szOID_POSTAL_CODE As String = "2.5.4.17" <br>Public Const szOID_POST_OFFICE_BOX As String = "2.5.4.18" <br>Public Const szOID_PHYSICAL_DELIVERY_OFFICE_NAME As String = "2.5.4.19" <br>' Telecommunications addressing attribute types: <br>Public Const szOID_TELEPHONE_NUMBER As String = "2.5.4.20" <br>Public Const szOID_TELEX_NUMBER As String = "2.5.4.21" <br>Public Const szOID_TELETEXT_TERMINAL_IDENTIFIER As String = "2.5.4.22" <br>Public Const szOID_FACSIMILE_TELEPHONE_NUMBER As String = "2.5.4.23" <br>Public Const szOID_X21_ADDRESS As String = "2.5.4.24" <br>Public Const szOID_INTERNATIONAL_ISDN_NUMBER As String = "2.5.4.25" <br>Public Const szOID_REGISTERED_ADDRESS As String = "2.5.4.26" <br>Public Const szOID_DESTINATION_INDICATOR As String = "2.5.4.27" <br>' Preference attribute types: <br>Public Const szOID_PREFERRED_DELIVERY_METHOD As String = "2.5.4.28" <br>' OSI application attribute types: <br>Public Const szOID_PRESENTATION_ADDRESS As String = "2.5.4.29" <br>Public Const szOID_SUPPORTED_APPLICATION_CONTEXT As String = "2.5.4.30" <br>' Relational application attribute types: <br>Public Const szOID_MEMBER As String = "2.5.4.31" <br>Public Const szOID_OWNER As String = "2.5.4.32" <br>Public Const szOID_ROLE_OCCUPANT As String = "2.5.4.33" <br>Public Const szOID_SEE_ALSO As String = "2.5.4.34" <br>' Security attribute types: <br>Public Const szOID_USER_PASSWORD As String = "2.5.4.35" <br>Public Const szOID_USER_CERTIFICATE As String = "2.5.4.36" <br>Public Const szOID_CA_CERTIFICATE As String = "2.5.4.37" <br>Public Const szOID_AUTHORITY_REVOCATION_LIST As String = "2.5.4.38" <br>Public Const szOID_CERTIFICATE_REVOCATION_LIST As String = "2.5.4.39" <br>Public Const szOID_CROSS_CERTIFICATE_PAIR As String = "2.5.4.40" <br>' Undocumented attribute types??? <br>'#define szOID_??? "2.5.4.41" <br>Public Const szOID_GIVEN_NAME As String = "2.5.4.42" <br>Public Const szOID_INITIALS As String = "2.5.4.43" <br>' Pilot user attribute types: <br>Public Const szOID_DOMAIN_COMPONENT As String = "0.9.2342.19200300.100.1.25" <br>'+------------------------------------------------------------------------- <br>' CERT_RDN Attribute Value Types <br>' <br>' For RDN_ENCODED_BLOB, the Value's CERT_RDN_VALUE_BLOB is in its encoded <br>' representation. Otherwise, its an array of bytes. <br>' <br>' For all CERT_RDN types, Value.cbData is always the number of bytes, not <br>' necessarily the number of elements in the string. For instance, <br>' <br>' For CertDecodeName, two 0 bytes are always appended to the end of the <br>' These added 0 bytes are't included in the BLOB.cbData. <br>'-------------------------------------------------------------------------- <br>Public Const CERT_RDN_ANY_TYPE As Long = 0 <br>Public Const CERT_RDN_ENCODED_BLOB As Long = 1 <br>Public Const CERT_RDN_OCTET_STRING As Long = 2 <br>Public Const CERT_RDN_NUMERIC_STRING As Long = 3 <br>Public Const CERT_RDN_PRINTABLE_STRING As Long = 4 <br>Public Const CERT_RDN_TELETEX_STRING As Long = 5 <br>Public Const CERT_RDN_T61_STRING As Long = 5 <br>Public Const CERT_RDN_VIDEOTEX_STRING As Long = 6 <br>Public Const CERT_RDN_IA5_STRING As Long = 7 <br>Public Const CERT_RDN_GRAPHIC_STRING As Long = 8 <br>Public Const CERT_RDN_VISIBLE_STRING As Long = 9 <br>Public Const CERT_RDN_ISO646_STRING As Long = 9 <br>Public Const CERT_RDN_GENERAL_STRING As Long = 10 <br>Public Const CERT_RDN_UNIVERSAL_STRING As Long = 11 <br>Public Const CERT_RDN_INT4_STRING As Long = 11 <br>Public Const CERT_RDN_BMP_STRING As Long = 12 <br>Public Const CERT_RDN_UNICODE_STRING As Long = 12 <br>' Macro to check that the dwValueType is a character string and not an <br>' encoded blob or octet string <br>'+------------------------------------------------------------------------- <br>' A CERT_RDN consists of an array of the above attributes <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' Information stored in a subject's or issuer's name. The information <br>' is represented as an array of the above RDNs. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' Name attribute value without the Object Identifier <br>' <br>' The interpretation of the Value depends on the dwValueType. <br>' See above for a list of the types. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' Public Key Info <br>' <br>' The PublicKey is the encoded representation of the information as it is <br>' stored in the bit string <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' Information stored in a certificate <br>' <br>' The Issuer, Subject, Algorithm, PublicKey and Extension BLOBs are the <br>' encoded representation of the information. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' Certificate versions <br>'-------------------------------------------------------------------------- <br>Public Const CERT_V1 As Long = 0 <br>Public Const CERT_V2 As Long = 1 <br>Public Const CERT_V3 As Long = 2 <br>'+------------------------------------------------------------------------- <br>' Certificate Information Flags <br>'-------------------------------------------------------------------------- <br>Public Const CERT_INFO_VERSION_FLAG As Long = 1 <br>Public Const CERT_INFO_SERIAL_NUMBER_FLAG As Long = 2 <br>Public Const CERT_INFO_SIGNATURE_ALGORITHM_FLAG As Long = 3 <br>Public Const CERT_INFO_ISSUER_FLAG As Long = 4 <br>Public Const CERT_INFO_NOT_BEFORE_FLAG As Long = 5 <br>Public Const CERT_INFO_NOT_AFTER_FLAG As Long = 6 <br>Public Const CERT_INFO_SUBJECT_FLAG As Long = 7 <br>Public Const CERT_INFO_SUBJECT_PUBLIC_KEY_INFO_FLAG As Long = 8 <br>Public Const CERT_INFO_ISSUER_UNIQUE_ID_FLAG As Long = 9 <br>Public Const CERT_INFO_SUBJECT_UNIQUE_ID_FLAG As Long = 10 <br>Public Const CERT_INFO_EXTENSION_FLAG As Long = 11 <br>'+------------------------------------------------------------------------- <br>' An entry in a CRL <br>' <br>' The Extension BLOBs are the encoded representation of the information. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' Information stored in a CRL <br>' <br>' The Issuer, Algorithm and Extension BLOBs are the encoded <br>' representation of the information. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' CRL versions <br>'-------------------------------------------------------------------------- <br>Public Const CRL_V1 As Long = 0 <br>Public Const CRL_V2 As Long = 1 <br>'+------------------------------------------------------------------------- <br>' Information stored in a certificate request <br>' <br>' The Subject, Algorithm, PublicKey and Attribute BLOBs are the encoded <br>' representation of the information. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' Certificate Request versions <br>'-------------------------------------------------------------------------- <br>Public Const CERT_REQUEST_V1 As Long = 0 <br>'+------------------------------------------------------------------------- <br>' Information stored in Netscape's Keygen request <br>'-------------------------------------------------------------------------- <br>Public Const CERT_KEYGEN_REQUEST_V1 As Long = 0 <br>'+------------------------------------------------------------------------- <br>' Certificate, CRL, Certificate Request or Keygen Request Signed Content <br>' <br>' The "to be signed" encoded content plus its signature. The ToBeSigned <br>' is the encoded CERT_INFO, CRL_INFO, CERT_REQUEST_INFO or <br>' CERT_KEYGEN_REQUEST_INFO. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' CTL Usage. Also used for EnhancedKeyUsage extension. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' An entry in a CTL <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' Information stored in a CTL <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' CTL versions <br>'-------------------------------------------------------------------------- <br>Public Const CTL_V1 As Long = 0 <br>'+------------------------------------------------------------------------- <br>' TimeStamp Request <br>' <br>' The pszTimeStamp is the OID for the Time type requested <br>' The pszContentType is the Content Type OID for the content, usually DATA <br>' The Content is a un-decoded blob <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' Certificate and Message encoding types <br>' <br>' The encoding type is a DWORD containing both the certificate and message <br>' encoding types. The certificate encoding type is stored in the LOWORD. <br>' The message encoding type is stored in the HIWORD. Some functions or <br>' structure fields require only one of the encoding types. The following <br>' required: <br>' <br>' Its always acceptable to specify both. <br>'-------------------------------------------------------------------------- <br>Public Const CERT_ENCODING_TYPE_MASK As Long = &amp;H0000FFFF <br>Public Const CMSG_ENCODING_TYPE_MASK As Long = &amp;HFFFF0000 </code></pre>
<p>
</p>
<pre><code>Public Const CRYPT_ASN_ENCODING As Long = &amp;H00000001 <br>Public Const CRYPT_NDR_ENCODING As Long = &amp;H00000002 <br>Public Const X509_ASN_ENCODING As Long = &amp;H00000001 <br>Public Const X509_NDR_ENCODING As Long = &amp;H00000002 <br>Public Const PKCS_7_ASN_ENCODING As Long = &amp;H00010000 <br>Public Const PKCS_7_NDR_ENCODING As Long = &amp;H00020000 <br>'+------------------------------------------------------------------------- <br>' format the specified data structure according to the certificate <br>' encoding type. <br>' <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' Encode / decode the specified data structure according to the certificate <br>' encoding type. <br>' <br>' See below for a list of the predefined data structures. <br>'-------------------------------------------------------------------------- <br>' When the following flag is set the nocopy optimization is enabled. <br>' This optimization where appropriate, updates the pvStructInfo fields <br>' to point to content residing within pbEncoded instead of making a copy <br>' of and appending to pvStructInfo. <br>' <br>' Note, when set, pbEncoded can't be freed until pvStructInfo is freed. <br>Public Const CRYPT_DECODE_NOCOPY_FLAG As Long = &amp;H1 <br>'+------------------------------------------------------------------------- <br>' Predefined X509 certificate data structures that can be encoded / decoded. <br>'-------------------------------------------------------------------------- <br>Public Const CRYPT_ENCODE_DECODE_NONE As Long = 0 <br>'+------------------------------------------------------------------------- <br>' Predefined X509 certificate extension data structures that can be <br>' encoded / decoded. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' Additional predefined data structures that can be encoded / decoded. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' Predefined primitive data structures that can be encoded / decoded. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' More predefined X509 certificate extension data structures that can be <br>' encoded / decoded. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' Predefined PKCS #7 data structures that can be encoded / decoded. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' can be encoded / decoded. <br>' <br>' Predefined values: 2000 .. 2999 <br>' <br>' See spc.h for value and data structure definitions. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' Extension Object Identifiers <br>'-------------------------------------------------------------------------- <br>Public Const szOID_AUTHORITY_KEY_IDENTIFIER As String = "2.5.29.1" <br>Public Const szOID_KEY_ATTRIBUTES As String = "2.5.29.2" <br>Public Const szOID_KEY_USAGE_RESTRICTION As String = "2.5.29.4" <br>Public Const szOID_SUBJECT_ALT_NAME As String = "2.5.29.7" <br>Public Const szOID_ISSUER_ALT_NAME As String = "2.5.29.8" <br>Public Const szOID_BASIC_CONSTRAINTS As String = "2.5.29.10" <br>Public Const szOID_KEY_USAGE As String = "2.5.29.15" <br>Public Const szOID_BASIC_CONSTRAINTS2 As String = "2.5.29.19" <br>Public Const szOID_CERT_POLICIES As String = "2.5.29.32" <br>Public Const szOID_AUTHORITY_KEY_IDENTIFIER2 As String = "2.5.29.35" <br>Public Const szOID_SUBJECT_KEY_IDENTIFIER As String = "2.5.29.14" <br>Public Const szOID_SUBJECT_ALT_NAME2 As String = "2.5.29.17" <br>Public Const szOID_ISSUER_ALT_NAME2 As String = "2.5.29.18" <br>Public Const szOID_CRL_REASON_CODE As String = "2.5.29.21" <br>Public Const szOID_CRL_DIST_POINTS As String = "2.5.29.31" <br>Public Const szOID_ENHANCED_KEY_USAGE As String = "2.5.29.37" <br>' Internet Public Key Infrastructure <br>Public Const szOID_PKIX As String = "1.3.6.1.5.5.7" <br>Public Const szOID_AUTHORITY_INFO_ACCESS As String = "1.3.6.1.5.5.7.2" <br>' Microsoft extensions or attributes <br>Public Const szOID_CERT_EXTENSIONS As String = "1.3.6.1.4.1.311.2.1.14" <br>Public Const szOID_NEXT_UPDATE_LOCATION As String = "1.3.6.1.4.1.311.10.2" <br>' Microsoft PKCS #7 ContentType Object Identifiers <br>Public Const szOID_CTL As String = "1.3.6.1.4.1.311.10.1" <br>'+------------------------------------------------------------------------- <br>'-------------------------------------------------------------------------- <br>Public Const szOID_POLICY_MAPPINGS As String = "2.5.29.5" <br>Public Const szOID_SUBJECT_DIR_ATTRS As String = "2.5.29.9" <br>'+------------------------------------------------------------------------- <br>'-------------------------------------------------------------------------- <br>Public Const szOID_PKIX_KP As String = "1.3.6.1.5.5.7.3" <br>' Consistent key usage bits: DIGITAL_SIGNATURE, KEY_ENCIPHERMENT <br>' or KEY_AGREEMENT <br>Public Const szOID_PKIX_KP_SERVER_AUTH As String = "1.3.6.1.5.5.7.3.1" <br>' Consistent key usage bits: DIGITAL_SIGNATURE <br>Public Const szOID_PKIX_KP_CLIENT_AUTH As String = "1.3.6.1.5.5.7.3.2" <br>' Consistent key usage bits: DIGITAL_SIGNATURE <br>Public Const szOID_PKIX_KP_CODE_SIGNING As String = "1.3.6.1.5.5.7.3.3" <br>' Consistent key usage bits: DIGITAL_SIGNATURE, NON_REPUDIATION and/or <br>Public Const szOID_PKIX_KP_EMAIL_PROTECTION As String = "1.3.6.1.5.5.7.3.4" <br>'+------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' Signer of CTLs <br>Public Const szOID_KP_CTL_USAGE_SIGNING As String = "1.3.6.1.4.1.311.10.3.1" <br>'+------------------------------------------------------------------------- <br>' Microsoft Attribute Object Identifiers <br>'+------------------------------------------------------------------------- <br>Public Const szOID_YESNO_TRUST_ATTR As String = "1.3.6.1.4.1.311.10.4.1" <br>'+------------------------------------------------------------------------- <br>' X509_CERT <br>' <br>' The "to be signed" encoded content plus its signature. The ToBeSigned <br>' X509_CERT_TO_BE_SIGNED, X509_CERT_CRL_TO_BE_SIGNED or <br>' X509_CERT_REQUEST_TO_BE_SIGNED. <br>' <br>' pvStructInfo points to CERT_SIGNED_CONTENT_INFO. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' X509_CERT_TO_BE_SIGNED <br>' <br>' pvStructInfo points to CERT_INFO. <br>' <br>' <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' X509_CERT_CRL_TO_BE_SIGNED <br>' <br>' pvStructInfo points to CRL_INFO. <br>' <br>' <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' X509_CERT_REQUEST_TO_BE_SIGNED <br>' <br>' pvStructInfo points to CERT_REQUEST_INFO. <br>' <br>' <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' X509_EXTENSIONS <br>' szOID_CERT_EXTENSIONS <br>' <br>' pvStructInfo points to following CERT_EXTENSIONS. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' X509_NAME_VALUE <br>' X509_ANY_STRING <br>' <br>' pvStructInfo points to CERT_NAME_VALUE. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' X509_UNICODE_NAME_VALUE <br>' X509_UNICODE_ANY_STRING <br>' <br>' pvStructInfo points to CERT_NAME_VALUE. <br>' <br>' The name values are unicode strings. <br>' <br>' For CryptEncodeObject: <br>' Value.pbData points to the unicode string. <br>' If Value.cbData = 0, then, the unicode string is NULL terminated. <br>' Otherwise, Value.cbData is the unicode string byte count. The byte count <br>' is twice the character count. <br>' <br>' If the unicode string contains an invalid character for the specified <br>' dwValueType, then, *pcbEncoded is updated with the unicode character <br>' index of the first invalid character. LastError is set to: <br>' CRYPT_E_INVALID_NUMERIC_STRING, CRYPT_E_INVALID_PRINTABLE_STRING or <br>' CRYPT_E_INVALID_IA5_STRING. <br>' <br>' The unicode string is converted before being encoded according to <br>' the specified dwValueType. If dwValueType is set to 0, LastError <br>' is set to E_INVALIDARG. <br>' <br>' CERT_RDN_ENCODED_BLOB or CERT_RDN_OCTET_STRING), then, CryptEncodeObject <br>' will return FALSE with LastError set to CRYPT_E_NOT_CHAR_STRING. <br>' <br>' For CryptDecodeObject: <br>' Value.pbData points to a NULL terminated unicode string. Value.cbData <br>' contains the byte count of the unicode string excluding the NULL <br>' terminator. dwValueType contains the type used in the encoded object. <br>' Its not forced to CERT_RDN_UNICODE_STRING. The encoded value is <br>' converted to the unicode string according to the dwValueType. <br>' <br>' If the encoded object isn't one of the character string types, then, <br>' CryptDecodeObject will return FALSE with LastError set to <br>' CRYPT_E_NOT_CHAR_STRING. For a non character string, decode using <br>' X509_NAME_VALUE or X509_ANY_STRING. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' X509_NAME <br>' <br>' pvStructInfo points to CERT_NAME_INFO. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' X509_UNICODE_NAME <br>' <br>' pvStructInfo points to CERT_NAME_INFO. <br>' <br>' The RDN attribute values are unicode strings except for the dwValueTypes of <br>' CERT_RDN_ENCODED_BLOB or CERT_RDN_OCTET_STRING. These dwValueTypes are <br>' the same as for a X509_NAME. Their values aren't converted to/from unicode. <br>' <br>' For CryptEncodeObject: <br>' Value.pbData points to the unicode string. <br>' If Value.cbData = 0, then, the unicode string is NULL terminated. <br>' Otherwise, Value.cbData is the unicode string byte count. The byte count <br>' is twice the character count. <br>' <br>' an acceptable dwValueType. If the unicode string contains an <br>' invalid character for the found or specified dwValueType, then, <br>' *pcbEncoded is updated with the error location of the invalid character. <br>' See below for details. LastError is set to: <br>' CRYPT_E_INVALID_NUMERIC_STRING, CRYPT_E_INVALID_PRINTABLE_STRING or <br>' CRYPT_E_INVALID_IA5_STRING. <br>' <br>' The unicode string is converted before being encoded according to <br>' the specified or ObjId matching dwValueType. <br>' <br>' For CryptDecodeObject: <br>' Value.pbData points to a NULL terminated unicode string. Value.cbData <br>' contains the byte count of the unicode string excluding the NULL <br>' terminator. dwValueType contains the type used in the encoded object. <br>' Its not forced to CERT_RDN_UNICODE_STRING. The encoded value is <br>' converted to the unicode string according to the dwValueType. <br>' <br>' If the dwValueType of the encoded value isn't a character string <br>' type, then, it isn't converted to UNICODE. Use the <br>' that Value.pbData points to a converted unicode string. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' Unicode Name Value Error Location Definitions <br>' <br>' Error location is returned in *pcbEncoded by <br>' <br>' Error location consists of: <br>' RDN_INDEX - 10 bits &lt;&lt; 22 <br>' ATTR_INDEX - 6 bits &lt;&lt; 16 <br>'-------------------------------------------------------------------------- <br>Public Const CERT_UNICODE_RDN_ERR_INDEX_MASK As Long = &amp;H3FF <br>Public Const CERT_UNICODE_RDN_ERR_INDEX_SHIFT As Long = 22 <br>Public Const CERT_UNICODE_ATTR_ERR_INDEX_MASK As Long = &amp;H003F <br>Public Const CERT_UNICODE_ATTR_ERR_INDEX_SHIFT As Long = 16 <br>Public Const CERT_UNICODE_VALUE_ERR_INDEX_MASK As Long = &amp;H0000FFFF <br>Public Const CERT_UNICODE_VALUE_ERR_INDEX_SHIFT As Long = 0 <br>'+------------------------------------------------------------------------- <br>' X509_PUBLIC_KEY_INFO <br>' <br>' pvStructInfo points to CERT_PUBLIC_KEY_INFO. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' X509_AUTHORITY_KEY_ID <br>' szOID_AUTHORITY_KEY_IDENTIFIER <br>' <br>' pvStructInfo points to following CERT_AUTHORITY_KEY_ID_INFO. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' X509_KEY_ATTRIBUTES <br>' szOID_KEY_ATTRIBUTES <br>' <br>' pvStructInfo points to following CERT_KEY_ATTRIBUTES_INFO. <br>'-------------------------------------------------------------------------- <br>Public Const CERT_DIGITAL_SIGNATURE_KEY_USAGE As Long = &amp;H80 <br>Public Const CERT_NON_REPUDIATION_KEY_USAGE As Long = &amp;H40 <br>Public Const CERT_KEY_ENCIPHERMENT_KEY_USAGE As Long = &amp;H20 <br>Public Const CERT_DATA_ENCIPHERMENT_KEY_USAGE As Long = &amp;H10 <br>Public Const CERT_KEY_AGREEMENT_KEY_USAGE As Long = &amp;H08 <br>Public Const CERT_KEY_CERT_SIGN_KEY_USAGE As Long = &amp;H04 <br>Public Const CERT_OFFLINE_CRL_SIGN_KEY_USAGE As Long = &amp;H02 <br>Public Const CERT_CRL_SIGN_KEY_USAGE As Long = &amp;H02 <br>'+------------------------------------------------------------------------- <br>' X509_KEY_USAGE_RESTRICTION <br>' szOID_KEY_USAGE_RESTRICTION <br>' <br>' pvStructInfo points to following CERT_KEY_USAGE_RESTRICTION_INFO. <br>'-------------------------------------------------------------------------- <br>' See CERT_KEY_ATTRIBUTES_INFO for definition of the RestrictedKeyUsage bits <br>'+------------------------------------------------------------------------- <br>' X509_ALTERNATE_NAME <br>' szOID_SUBJECT_ALT_NAME <br>' szOID_ISSUER_ALT_NAME <br>' szOID_SUBJECT_ALT_NAME2 <br>' szOID_ISSUER_ALT_NAME2 <br>' <br>' pvStructInfo points to following CERT_ALT_NAME_INFO. <br>'-------------------------------------------------------------------------- <br>Public Const CERT_ALT_NAME_OTHER_NAME As Long = 1 <br>Public Const CERT_ALT_NAME_RFC822_NAME As Long = 2 <br>Public Const CERT_ALT_NAME_DNS_NAME As Long = 3 <br>Public Const CERT_ALT_NAME_X400_ADDRESS As Long = 4 <br>Public Const CERT_ALT_NAME_DIRECTORY_NAME As Long = 5 <br>Public Const CERT_ALT_NAME_EDI_PARTY_NAME As Long = 6 <br>Public Const CERT_ALT_NAME_URL As Long = 7 <br>Public Const CERT_ALT_NAME_IP_ADDRESS As Long = 8 <br>Public Const CERT_ALT_NAME_REGISTERED_ID As Long = 9 <br>'+------------------------------------------------------------------------- <br>' Alternate name IA5 Error Location Definitions for <br>' CRYPT_E_INVALID_IA5_STRING. <br>' <br>' Error location is returned in *pcbEncoded by <br>' <br>' Error location consists of: <br>' ENTRY_INDEX - 8 bits &lt;&lt; 16 <br>'-------------------------------------------------------------------------- <br>Public Const CERT_ALT_NAME_ENTRY_ERR_INDEX_MASK As Long = &amp;HFF <br>Public Const CERT_ALT_NAME_ENTRY_ERR_INDEX_SHIFT As Long = 16 <br>Public Const CERT_ALT_NAME_VALUE_ERR_INDEX_MASK As Long = &amp;H0000FFFF <br>Public Const CERT_ALT_NAME_VALUE_ERR_INDEX_SHIFT As Long = 0 <br>'+------------------------------------------------------------------------- <br>' X509_BASIC_CONSTRAINTS <br>' szOID_BASIC_CONSTRAINTS <br>' <br>' pvStructInfo points to following CERT_BASIC_CONSTRAINTS_INFO. <br>'-------------------------------------------------------------------------- <br>Public Const CERT_CA_SUBJECT_FLAG As Long = &amp;H80 <br>Public Const CERT_END_ENTITY_SUBJECT_FLAG As Long = &amp;H40 <br>'+------------------------------------------------------------------------- <br>' X509_BASIC_CONSTRAINTS2 <br>' szOID_BASIC_CONSTRAINTS2 <br>' <br>' pvStructInfo points to following CERT_BASIC_CONSTRAINTS2_INFO. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' X509_KEY_USAGE <br>' szOID_KEY_USAGE <br>' <br>' pvStructInfo points to a CRYPT_BIT_BLOB. Has same bit definitions as <br>' CERT_KEY_ATTRIBUTES_INFO's IntendedKeyUsage. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' X509_CERT_POLICIES <br>' szOID_CERT_POLICIES <br>' <br>' pvStructInfo points to following CERT_POLICIES_INFO. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' RSA_CSP_PUBLICKEYBLOB <br>' <br>' pvStructInfo points to a PUBLICKEYSTRUC immediately followed by a <br>' RSAPUBKEY and the modulus bytes. <br>' <br>' CryptExportKey outputs the above StructInfo for a dwBlobType of <br>' PUBLICKEYBLOB. CryptImportKey expects the above StructInfo when <br>' importing a public key. <br>' <br>' For dwCertEncodingType = X509_ASN_ENCODING, the RSA_CSP_PUBLICKEYBLOB is <br>' encoded as a PKCS #1 RSAPublicKey consisting of a SEQUENCE of a <br>' modulus INTEGER and a publicExponent INTEGER. The modulus is encoded <br>' as being a unsigned integer. When decoded, if the modulus was encoded <br>' as unsigned integer with a leading 0 byte, the 0 byte is removed before <br>' converting to the CSP modulus bytes. <br>' <br>' For decode, the aiKeyAlg field of PUBLICKEYSTRUC is always set to <br>' CALG_RSA_KEYX. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' X509_KEYGEN_REQUEST_TO_BE_SIGNED <br>' <br>' pvStructInfo points to CERT_KEYGEN_REQUEST_INFO. <br>' <br>' <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' PKCS_ATTRIBUTE data structure <br>' <br>' pvStructInfo points to a CRYPT_ATTRIBUTE. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' PKCS_CONTENT_INFO_SEQUENCE_OF_ANY data structure <br>' <br>' pvStructInfo points to following CRYPT_CONTENT_INFO_SEQUENCE_OF_ANY. <br>' <br>' For X509_ASN_ENCODING: encoded as a PKCS#7 ContentInfo structure wrapping <br>' a sequence of ANY. The value of the contentType field is pszObjId, <br>' while the content field is the following structure: <br>' SequenceOfAny ::= SEQUENCE OF ANY <br>' <br>' The CRYPT_DER_BLOBs point to the already encoded ANY content. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' PKCS_CONTENT_INFO data structure <br>' <br>' pvStructInfo points to following CRYPT_CONTENT_INFO. <br>' <br>' For X509_ASN_ENCODING: encoded as a PKCS#7 ContentInfo structure. <br>' The CRYPT_DER_BLOB points to the already encoded ANY content. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' X509_OCTET_STRING data structure <br>' <br>' pvStructInfo points to a CRYPT_DATA_BLOB. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' X509_BITS data structure <br>' <br>' pvStructInfo points to a CRYPT_BIT_BLOB. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' X509_INTEGER data structure <br>' <br>' pvStructInfo points to an int. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' X509_MULTI_BYTE_INTEGER data structure <br>' <br>' pvStructInfo points to a CRYPT_INTEGER_BLOB. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' X509_ENUMERATED data structure <br>' <br>' pvStructInfo points to an int containing the enumerated value <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' X509_CHOICE_OF_TIME data structure <br>' <br>' pvStructInfo points to a FILETIME. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' X509_SEQUENCE_OF_ANY data structure <br>' <br>' pvStructInfo points to following CRYPT_SEQUENCE_OF_ANY. <br>' <br>' The CRYPT_DER_BLOBs point to the already encoded ANY content. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' X509_AUTHORITY_KEY_ID2 <br>' szOID_AUTHORITY_KEY_IDENTIFIER2 <br>' <br>' pvStructInfo points to following CERT_AUTHORITY_KEY_ID2_INFO. <br>' <br>' For CRYPT_E_INVALID_IA5_STRING, the error location is returned in <br>' <br>' See X509_ALTERNATE_NAME for error location defines. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' szOID_SUBJECT_KEY_IDENTIFIER <br>' <br>' pvStructInfo points to a CRYPT_DATA_BLOB. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' X509_CRL_REASON_CODE <br>' szOID_CRL_REASON_CODE <br>' <br>' pvStructInfo points to an int which can be set to one of the following <br>' enumerated values: <br>'-------------------------------------------------------------------------- <br>Public Const CRL_REASON_UNSPECIFIED As Long = 0 <br>Public Const CRL_REASON_KEY_COMPROMISE As Long = 1 <br>Public Const CRL_REASON_CA_COMPROMISE As Long = 2 <br>Public Const CRL_REASON_AFFILIATION_CHANGED As Long = 3 <br>Public Const CRL_REASON_SUPERSEDED As Long = 4 <br>Public Const CRL_REASON_CESSATION_OF_OPERATION As Long = 5 <br>Public Const CRL_REASON_CERTIFICATE_HOLD As Long = 6 <br>Public Const CRL_REASON_REMOVE_FROM_CRL As Long = 8 <br>'+------------------------------------------------------------------------- <br>' X509_CRL_DIST_POINTS <br>' szOID_CRL_DIST_POINTS <br>' <br>' pvStructInfo points to following CRL_DIST_POINTS_INFO. <br>' <br>' For CRYPT_E_INVALID_IA5_STRING, the error location is returned in <br>' <br>' Error location consists of: <br>' POINT_INDEX - 7 bits &lt;&lt; 24 <br>' ENTRY_INDEX - 8 bits &lt;&lt; 16 <br>' <br>' See X509_ALTERNATE_NAME for ENTRY_INDEX and VALUE_INDEX error location <br>' defines. <br>'-------------------------------------------------------------------------- <br>Public Const CRL_DIST_POINT_NO_NAME As Long = 0 <br>Public Const CRL_DIST_POINT_FULL_NAME As Long = 1 <br>Public Const CRL_DIST_POINT_ISSUER_RDN_NAME As Long = 2 <br>Public Const CRL_REASON_UNUSED_FLAG As Long = &amp;H80 <br>Public Const CRL_REASON_KEY_COMPROMISE_FLAG As Long = &amp;H40 <br>Public Const CRL_REASON_CA_COMPROMISE_FLAG As Long = &amp;H20 <br>Public Const CRL_REASON_AFFILIATION_CHANGED_FLAG As Long = &amp;H10 <br>Public Const CRL_REASON_SUPERSEDED_FLAG As Long = &amp;H08 <br>Public Const CRL_REASON_CESSATION_OF_OPERATION_FLAG As Long = &amp;H04 <br>Public Const CRL_REASON_CERTIFICATE_HOLD_FLAG As Long = &amp;H02 <br>Public Const CRL_DIST_POINT_ERR_INDEX_MASK As Long = &amp;H7F <br>Public Const CRL_DIST_POINT_ERR_INDEX_SHIFT As Long = 24 <br>'+------------------------------------------------------------------------- <br>' X509_ENHANCED_KEY_USAGE <br>' szOID_ENHANCED_KEY_USAGE <br>' <br>' pvStructInfo points to a CERT_ENHKEY_USAGE, CTL_USAGE. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' szOID_NEXT_UPDATE_LOCATION <br>' <br>' pvStructInfo points to a CERT_ALT_NAME_INFO. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' PKCS_CTL <br>' szOID_CTL <br>' <br>' pvStructInfo points to a CTL_INFO. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' PKCS7_SIGNER_INFO <br>' <br>' pvStructInfo points to CMSG_SIGNER_INFO. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' Netscape Certificate Extension Object Identifiers <br>'-------------------------------------------------------------------------- <br>Public Const szOID_NETSCAPE As String = "2.16.840.1.113730" <br>Public Const szOID_NETSCAPE_CERT_EXTENSION As String = "2.16.840.1.113730.1" <br>Public Const szOID_NETSCAPE_CERT_TYPE As String = "2.16.840.1.113730.1.1" <br>Public Const szOID_NETSCAPE_BASE_URL As String = "2.16.840.1.113730.1.2" <br>Public Const szOID_NETSCAPE_REVOCATION_URL As String = "2.16.840.1.113730.1.3" <br>Public Const szOID_NETSCAPE_CA_REVOCATION_URL As String = "2.16.840.1.113730.1.4" <br>Public Const szOID_NETSCAPE_CERT_RENEWAL_URL As String = "2.16.840.1.113730.1.7" <br>Public Const szOID_NETSCAPE_CA_POLICY_URL As String = "2.16.840.1.113730.1.8" <br>Public Const szOID_NETSCAPE_SSL_SERVER_NAME As String = "2.16.840.1.113730.1.12" <br>Public Const szOID_NETSCAPE_COMMENT As String = "2.16.840.1.113730.1.13" <br>'+------------------------------------------------------------------------- <br>' Netscape Certificate Data Type Object Identifiers <br>'-------------------------------------------------------------------------- <br>Public Const szOID_NETSCAPE_DATA_TYPE As String = "2.16.840.1.113730.2" <br>Public Const szOID_NETSCAPE_CERT_SEQUENCE As String = "2.16.840.1.113730.2.5" <br>'+------------------------------------------------------------------------- <br>' szOID_NETSCAPE_CERT_TYPE extension <br>' <br>' Its value is a bit string. CryptDecodeObject/CryptEncodeObject using <br>' X509_BITS. <br>' <br>' The following bits are defined: <br>'-------------------------------------------------------------------------- <br>Public Const NETSCAPE_SSL_CLIENT_AUTH_CERT_TYPE As Long = &amp;H80 <br>Public Const NETSCAPE_SSL_SERVER_AUTH_CERT_TYPE As Long = &amp;H40 <br>Public Const NETSCAPE_SSL_CA_CERT_TYPE As Long = &amp;H04 <br>'+------------------------------------------------------------------------- <br>' szOID_NETSCAPE_BASE_URL extension <br>' <br>' Its value is an IA5_STRING. CryptDecodeObject/CryptEncodeObject using <br>' X509_ANY_STRING or X509_UNICODE_ANY_STRING, where, <br>' dwValueType = CERT_RDN_IA5_STRING. <br>' <br>' When present this string is added to the beginning of all relative URLs <br>' in the certificate. This extension can be considered an optimization <br>' to reduce the size of the URL extensions. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' szOID_NETSCAPE_REVOCATION_URL extension <br>' <br>' Its value is an IA5_STRING. CryptDecodeObject/CryptEncodeObject using <br>' X509_ANY_STRING or X509_UNICODE_ANY_STRING, where, <br>' dwValueType = CERT_RDN_IA5_STRING. <br>' <br>' It is a relative or absolute URL that can be used to check the <br>' revocation status of a certificate. The revocation check will be <br>' performed as an HTTP GET method using a url that is the concatenation of <br>' revocation-url and certificate-serial-number. <br>' Where the certificate-serial-number is encoded as a string of <br>' ascii hexadecimal digits. For example, if the netscape-base-url is <br>' https: <br>' cgi-bin/check-rev.cgi?, and the certificate serial number is 173420, <br>' the resulting URL would be: <br>' https: <br>' <br>' The server should return a document with a Content-Type of <br>' application/x-netscape-revocation. The document should contain <br>' a single ascii digit, '1' if the certificate is not curently valid, <br>' and '0' if it is curently valid. <br>' <br>' Note: for all of the URLs that include the certificate serial number, <br>' the serial number will be encoded as a string which consists of an even <br>' number of hexadecimal digits. If the number of significant digits is odd, <br>' the string will have a single leading zero to ensure an even number of <br>' digits is generated. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' szOID_NETSCAPE_CA_REVOCATION_URL extension <br>' <br>' Its value is an IA5_STRING. CryptDecodeObject/CryptEncodeObject using <br>' X509_ANY_STRING or X509_UNICODE_ANY_STRING, where, <br>' dwValueType = CERT_RDN_IA5_STRING. <br>' <br>' It is a relative or absolute URL that can be used to check the <br>' revocation status of any certificates that are signed by the CA that <br>' this certificate belongs to. This extension is only valid in CA <br>' certificates. The use of this extension is the same as the above <br>' szOID_NETSCAPE_REVOCATION_URL extension. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' szOID_NETSCAPE_CERT_RENEWAL_URL extension <br>' <br>' Its value is an IA5_STRING. CryptDecodeObject/CryptEncodeObject using <br>' X509_ANY_STRING or X509_UNICODE_ANY_STRING, where, <br>' dwValueType = CERT_RDN_IA5_STRING. <br>' <br>' It is a relative or absolute URL that points to a certificate renewal <br>' form. The renewal form will be accessed with an HTTP GET method using a <br>' url that is the concatenation of renewal-url and <br>' certificate-serial-number. Where the certificate-serial-number is <br>' encoded as a string of ascii hexadecimal digits. For example, if the <br>' netscape-base-url is https: <br>' netscape-cert-renewal-url is cgi-bin/check-renew.cgi?, and the <br>' certificate serial number is 173420, the resulting URL would be: <br>' https: <br>' The document returned should be an HTML form that will allow the user <br>' to request a renewal of their certificate. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' szOID_NETSCAPE_CA_POLICY_URL extension <br>' <br>' Its value is an IA5_STRING. CryptDecodeObject/CryptEncodeObject using <br>' X509_ANY_STRING or X509_UNICODE_ANY_STRING, where, <br>' dwValueType = CERT_RDN_IA5_STRING. <br>' <br>' It is a relative or absolute URL that points to a web page that <br>' describes the policies under which the certificate was issued. <br>'-------------------------------------------------------------------------- </code></pre>
<p>
</p>
<pre><code>'+------------------------------------------------------------------------- <br>' szOID_NETSCAPE_SSL_SERVER_NAME extension <br>' <br>' Its value is an IA5_STRING. CryptDecodeObject/CryptEncodeObject using <br>' X509_ANY_STRING or X509_UNICODE_ANY_STRING, where, <br>' dwValueType = CERT_RDN_IA5_STRING. <br>' <br>' It is a "shell expression" that can be used to match the hostname of the <br>' SSL server that is using this certificate. It is recommended that if <br>' the server's hostname does not match this pattern the user be notified <br>' and given the option to terminate the SSL connection. If this extension <br>' is not present then the CommonName in the certificate subject's <br>' distinguished name is used for the same purpose. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' szOID_NETSCAPE_COMMENT extension <br>' <br>' Its value is an IA5_STRING. CryptDecodeObject/CryptEncodeObject using <br>' X509_ANY_STRING or X509_UNICODE_ANY_STRING, where, <br>' dwValueType = CERT_RDN_IA5_STRING. <br>' <br>' It is a comment that may be displayed to the user when the certificate <br>' is viewed. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' szOID_NETSCAPE_CERT_SEQUENCE <br>' <br>' Its value is a PKCS#7 ContentInfo structure wrapping a sequence of <br>' certificates. The value of the contentType field is <br>' szOID_NETSCAPE_CERT_SEQUENCE, while the content field is the following <br>' structure: <br>' CertificateSequence ::= SEQUENCE OF Certificate. <br>' <br>' CryptDecodeObject/CryptEncodeObject using <br>' PKCS_CONTENT_INFO_SEQUENCE_OF_ANY, where, <br>' pszObjId = szOID_NETSCAPE_CERT_SEQUENCE and the CRYPT_DER_BLOBs point <br>' to encoded X509 certificates. <br>'-------------------------------------------------------------------------- <br>'+========================================================================= <br>'========================================================================== <br>' Predefined OID Function Names <br>Public Const CRYPT_OID_ENCODE_OBJECT_FUNC As String = "CryptDllEncodeObject" <br>Public Const CRYPT_OID_DECODE_OBJECT_FUNC As String = "CryptDllDecodeObject" <br>Public Const CRYPT_OID_CREATE_COM_OBJECT_FUNC As String = "CryptDllCreateCOMObject" <br>Public Const CRYPT_OID_VERIFY_REVOCATION_FUNC As String = "CertDllVerifyRevocation" <br>Public Const CRYPT_OID_VERIFY_CTL_USAGE_FUNC As String = "CertDllVerifyCTLUsage" <br>Public Const CRYPT_OID_FORMAT_OBJECT_FUNC As String = "CryptDllFormatObject" <br>' CryptDllEncodeObject has same function signature as CryptEncodeObject. <br>' CryptDllDecodeObject has same function signature as CryptDecodeObject. <br>' CryptDllCreateCOMObject has the following signature: <br>' IN DWORD dwEncodingType, <br>' IN LPCSTR pszOID, <br>' IN PCRYPT_DATA_BLOB pEncodedContent, <br>' IN DWORD dwFlags, <br>' IN REFIID riid, <br>' OUT void **ppvObj); <br>' CertDllVerifyRevocation has the same signature as CertVerifyRevocation <br>' CertDllVerifyCTLUsage has the same signature as CertVerifyCTLUsage <br>' Example of a complete OID Function Registry Name: <br>' HKEY_LOCAL_MACHINE\Software\Microsoft\Cryptography\OID <br>' Encoding Type 1\CryptDllEncodeObject\1.2.3 <br>' <br>' The key's "Dll" value contains the name of the Dll. <br>' The key's "FuncName" value overrides the default function name <br>Public Const CRYPT_OID_REGPATH As String = "Software\\Microsoft\\Cryptography\\OID" <br>Public Const CRYPT_OID_REG_ENCODING_TYPE_PREFIX As String = "EncodingType " <br>Public Const CRYPT_OID_REG_DLL_VALUE_NAME As String = "Dll" <br>Public Const CRYPT_OID_REG_FUNC_NAME_VALUE_NAME As String = "FuncName" <br>Public Const CRYPT_OID_REG_FUNC_NAME_VALUE_NAME_A As String = "FuncName" <br>' OID used for Default OID functions <br>Public Const CRYPT_DEFAULT_OID As String = "DEFAULT" <br>Public Const CRYPT_INSTALL_OID_FUNC_BEFORE_FLAG As Long = 1 <br>'+------------------------------------------------------------------------- <br>' Install a set of callable OID function addresses. <br>' <br>' By default the functions are installed at end of the list. <br>' Set CRYPT_INSTALL_OID_FUNC_BEFORE_FLAG to install at beginning of list. <br>' <br>' hModule should be updated with the hModule passed to DllMain to prevent <br>' the Dll containing the function addresses from being unloaded by <br>' CryptGetOIDFuncAddress/CryptFreeOIDFunctionAddress. This would be the <br>' case when the Dll has also regsvr32'ed OID functions via <br>' CryptRegisterOIDFunction. <br>' <br>' DEFAULT functions are installed by setting rgFuncEntry[].pszOID = <br>' CRYPT_DEFAULT_OID. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' Initialize and return handle to the OID function set identified by its <br>' function name. <br>' <br>' If the set already exists, a handle to the existing set is returned. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' Search the list of installed functions for an encoding type and OID match. <br>' If not found, search the registry. <br>' <br>' For success, returns TRUE with *ppvFuncAddr updated with the function's <br>' address and *phFuncAddr updated with the function address's handle. <br>' The function's handle is AddRef'ed. CryptFreeOIDFunctionAddress needs to <br>' be called to release it. <br>' <br>' For a registry match, the Dll containing the function is loaded. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' Get the list of registered default Dll entries for the specified <br>' function set and encoding type. <br>' <br>' The returned list consists of none, one or more null terminated Dll file <br>' For example: "first.dll" L"\0" L"second.dll" L"\0" L"\0" <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' Either: get the first or next installed DEFAULT function OR <br>' load the Dll containing the DEFAULT function. <br>' <br>' If pwszDll is NULL, search the list of installed DEFAULT functions. <br>' *phFuncAddr must be set to NULL to get the first installed function. <br>' Successive installed functions are returned by setting *phFuncAddr <br>' to the hFuncAddr returned by the previous call. <br>' <br>' If pwszDll is NULL, the input *phFuncAddr <br>' is always CryptFreeOIDFunctionAddress'ed by this function, even for <br>' an error. <br>' <br>' If pwszDll isn't NULL, then, attempts to load the Dll and the DEFAULT <br>' function. *phFuncAddr is ignored upon entry and isn't <br>' CryptFreeOIDFunctionAddress'ed. <br>' <br>' For success, returns TRUE with *ppvFuncAddr updated with the function's <br>' address and *phFuncAddr updated with the function address's handle. <br>' The function's handle is AddRef'ed. CryptFreeOIDFunctionAddress needs to <br>' be called to release it or CryptGetDefaultOIDFunctionAddress can also <br>' be called for a NULL pwszDll. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' Releases the handle AddRef'ed and returned by CryptGetOIDFunctionAddress <br>' or CryptGetDefaultOIDFunctionAddress. <br>' <br>' If a Dll was loaded for the function its unloaded. However, before doing <br>' the unload, the DllCanUnloadNow function exported by the loaded Dll is <br>' called. It should return S_FALSE to inhibit the unload or S_TRUE to enable <br>' the unload. If the Dll doesn't export DllCanUnloadNow, the Dll is unloaded. <br>' <br>' DllCanUnloadNow has the following signature: <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' Register the Dll containing the function to be called for the specified <br>' encoding type, function name and OID. <br>' <br>' pwszDll may contain environment-variable strings <br>' <br>' In addition to registering the DLL, you may override the <br>' name of the function to be called. For example, <br>' pszFuncName = "CryptDllEncodeObject", <br>' pszOverrideFuncName = "MyEncodeXyz". <br>' This allows a Dll to export multiple OID functions for the same <br>' function name without needing to interpose its own OID dispatcher function. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' Unregister the Dll containing the function to be called for the specified <br>' encoding type, function name and OID. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' Register the Dll containing the default function to be called for the <br>' specified encoding type and function name. <br>' <br>' Unlike CryptRegisterOIDFunction, you can't override the function name <br>' needing to be exported by the Dll. <br>' <br>' The Dll is inserted before the entry specified by dwIndex. <br>' dwIndex == 0, inserts at the beginning. <br>' dwIndex == CRYPT_REGISTER_LAST_INDEX, appends at the end. <br>' <br>' pwszDll may contain environment-variable strings <br>'-------------------------------------------------------------------------- <br>Public Const CRYPT_REGISTER_FIRST_INDEX As Long = 0 <br>Public Const CRYPT_REGISTER_LAST_INDEX As Long = &amp;HFFFFFFFF <br>'+------------------------------------------------------------------------- <br>' Unregister the Dll containing the default function to be called for <br>' the specified encoding type and function name. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' Set the value for the specified encoding type, function name, OID and <br>' value name. <br>' <br>' See RegSetValueEx for the possible value types. <br>' <br>' String types are UNICODE. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' Get the value for the specified encoding type, function name, OID and <br>' value name. <br>' <br>' See RegEnumValue for the possible value types. <br>' <br>' String types are UNICODE. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' Enumerate the OID functions identified by their encoding type, <br>' function name and OID. <br>' <br>' pfnEnumOIDFunc is called for each registry key matching the input <br>' parameters. Setting dwEncodingType to CRYPT_MATCH_ANY_ENCODING_TYPE matches <br>' any. Setting pszFuncName or pszOID to NULL matches any. <br>' <br>' Set pszOID == CRYPT_DEFAULT_OID to restrict the enumeration to only the <br>' DEFAULT functions <br>' <br>' String types are UNICODE. <br>'-------------------------------------------------------------------------- <br>Public Const CRYPT_MATCH_ANY_ENCODING_TYPE As Long = &amp;HFFFFFFFF <br>'+========================================================================= <br>' Low Level Cryptographic Message Data Structures and APIs <br>'========================================================================== <br>Public Const szOID_PKCS_7_DATA As String = "1.2.840.113549.1.7.1" <br>Public Const szOID_PKCS_7_SIGNED As String = "1.2.840.113549.1.7.2" <br>Public Const szOID_PKCS_7_ENVELOPED As String = "1.2.840.113549.1.7.3" <br>Public Const szOID_PKCS_7_SIGNEDANDENVELOPED As String = "1.2.840.113549.1.7.4" <br>Public Const szOID_PKCS_7_DIGESTED As String = "1.2.840.113549.1.7.5" <br>Public Const szOID_PKCS_7_ENCRYPTED As String = "1.2.840.113549.1.7.6" <br>Public Const szOID_PKCS_9_CONTENT_TYPE As String = "1.2.840.113549.1.9.3" <br>Public Const szOID_PKCS_9_MESSAGE_DIGEST As String = "1.2.840.113549.1.9.4" <br>'+------------------------------------------------------------------------- <br>' Message types <br>'-------------------------------------------------------------------------- <br>Public Const CMSG_DATA As Long = 1 <br>Public Const CMSG_SIGNED As Long = 2 <br>Public Const CMSG_ENVELOPED As Long = 3 <br>Public Const CMSG_SIGNED_AND_ENVELOPED As Long = 4 <br>Public Const CMSG_HASHED As Long = 5 <br>Public Const CMSG_ENCRYPTED As Long = 6 <br>'+------------------------------------------------------------------------- <br>' Message Type Bit Flags <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' CMSG_DATA: pvMsgEncodeInfo = NULL <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' CMSG_SIGNED <br>' <br>' The pCertInfo in the CMSG_SIGNER_ENCODE_INFO provides the Issuer, SerialNumber <br>' and PublicKeyInfo.Algorithm. The PublicKeyInfo.Algorithm implicitly <br>' specifies the HashEncryptionAlgorithm to be used. <br>' <br>' The hCryptProv and dwKeySpec specify the private key to use. If dwKeySpec <br>' == 0, then, defaults to AT_SIGNATURE. <br>' <br>' pvHashAuxInfo currently isn't used and must be set to NULL. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' CMSG_ENVELOPED <br>' <br>' The PCERT_INFO for the rgRecipients provides the Issuer, SerialNumber <br>' and PublicKeyInfo. The PublicKeyInfo.Algorithm implicitly <br>' specifies the KeyEncryptionAlgorithm to be used. <br>' <br>' The PublicKeyInfo.PublicKey in PCERT_INFO is used to encrypt the content <br>' encryption key for the recipient. <br>' <br>' hCryptProv is used to do the content encryption, recipient key encryption <br>' and export. The hCryptProv's private keys aren't used. <br>' <br>' Note: CAPI currently doesn't support more than one KeyEncryptionAlgorithm <br>' per provider. This will need to be fixed. <br>' <br>' pvEncryptionAuxInfo currently isn't used and must be set to NULL. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' CMSG_SIGNED_AND_ENVELOPED <br>' <br>' For PKCS #7, a signed and enveloped message doesn't have the <br>' signer's authenticated or unauthenticated attributes. Otherwise, a <br>' combination of the CMSG_SIGNED_ENCODE_INFO and CMSG_ENVELOPED_ENCODE_INFO. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' CMSG_HASHED <br>' <br>' hCryptProv is used to do the hash. Doesn't need to use a private key. <br>' <br>' If fDetachedHash is set, then, the encoded message doesn't contain <br>' <br>' pvHashAuxInfo currently isn't used and must be set to NULL. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' CMSG_ENCRYPTED <br>' <br>' The key used to encrypt the message is identified outside of the message <br>' <br>' The content input to CryptMsgUpdate has already been encrypted. <br>' <br>' pvEncryptionAuxInfo currently isn't used and must be set to NULL. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' This parameter allows messages to be of variable length with streamed <br>' output. <br>' <br>' By default, messages are of a definite length and <br>' called to get the cryptographically processed content. Until closed, <br>' the handle keeps a copy of the processed content. <br>' <br>' With streamed output, the processed content can be freed as its streamed. <br>' <br>' If the length of the content to be updated is known at the time of the <br>' open, then, ContentLength should be set to that length. Otherwise, it <br>' should be set to CMSG_INDEFINITE_LENGTH. <br>'-------------------------------------------------------------------------- <br>Public Const CMSG_INDEFINITE_LENGTH As Long = &amp;HFFFFFFFF <br>'+------------------------------------------------------------------------- <br>' Open dwFlags <br>'-------------------------------------------------------------------------- <br>Public Const CMSG_BARE_CONTENT_FLAG As Long = &amp;H00000001 <br>Public Const CMSG_LENGTH_ONLY_FLAG As Long = &amp;H00000002 <br>Public Const CMSG_DETACHED_FLAG As Long = &amp;H00000004 <br>Public Const CMSG_AUTHENTICATED_ATTRIBUTES_FLAG As Long = &amp;H00000008 <br>Public Const CMSG_CONTENTS_OCTETS_FLAG As Long = &amp;H00000010 <br>'+------------------------------------------------------------------------- <br>' Open a cryptographic message for encoding <br>' <br>' For PKCS #7: <br>' If the content to be passed to CryptMsgUpdate has already <br>' from another message encode), then, the CMSG_ENCODED_CONTENT_INFO_FLAG should <br>' be set in dwFlags. If not set, then, the inner ContentType is Data and <br>' the input to CryptMsgUpdate is treated as the inner Data type's Content, <br>' a string of bytes. <br>' If CMSG_BARE_CONTENT_FLAG is specified for a streamed message, <br>' the streamed output will not have an outer ContentInfo wrapper. This <br>' makes it suitable to be streamed into an enclosing message. <br>' <br>' The pStreamInfo parameter needs to be set to stream the encoded message <br>' output. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' Calculate the length of an encoded cryptographic message. <br>' <br>' Calculates the length of the encoded message given the <br>' message type, encoding parameters and total length of <br>' the data to be updated. Note, this might not be the exact length. However, <br>' it will always be greater than or equal to the actual length. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' Open a cryptographic message for decoding <br>' <br>' BUGBUG! These comments need to be changed <br>' For PKCS #7: if the inner ContentType isn't Data, then, the inner <br>' ContentInfo consisting of both ContentType and Content is output. <br>' To also enable ContentInfo output for the Data ContentType, then, <br>' the CMSG_ENCODED_CONTENT_INFO_FLAG should be set <br>' in dwFlags. If not set, then, only the content portion of the inner <br>' ContentInfo is output for the Data ContentType. <br>' <br>' To only calculate the length of the decoded message, set the <br>' CMSG_LENGTH_ONLY_FLAG in dwFlags. After the final CryptMsgUpdate get the <br>' MSG_CONTENT_PARAM. Note, this might not be the exact length. However, <br>' it will always be greater than or equal to the actual length. <br>' <br>' hCryptProv specifies the crypto provider to use for hashing and/or <br>' decrypting the message. For enveloped messages, hCryptProv also specifies <br>' the private exchange key to use. For signed messages, hCryptProv is used <br>' when CryptMsgVerifySigner is called. <br>' <br>' For enveloped messages, the pRecipientInfo contains the Issuer and <br>' SerialNumber identifying the RecipientInfo in the message. <br>' <br>' Note, the pRecipientInfo should correspond to the provider's private <br>' exchange key. <br>' <br>' If pRecipientInfo is NULL, then, the message isn't decrypted. To decrypt <br>' CryptMsgUpdate. <br>' <br>' The pStreamInfo parameter needs to be set to stream the decoded content <br>' output. Note, if pRecipientInfo is NULL, then, the streamed output isn't <br>' decrypted. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' Close a cryptographic message handle <br>' <br>' LastError is preserved unless FALSE is returned. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' Update the content of a cryptographic message. Depending on how the <br>' message was opened, the content is either encoded or decoded. <br>' <br>' This function is repetitively called to append to the message content. <br>' fFinal is set to identify the last update. On fFinal, the encode/decode <br>' is completed. The encoded/decoded content and the decoded parameters <br>' are valid until the open and all duplicated handles are closed. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' Perform a special "control" function after the final CryptMsgUpdate of a <br>' encoded/decoded cryptographic message. <br>' <br>' The dwCtrlType parameter specifies the type of operation to be performed. <br>' <br>' The pvCtrlPara definition depends on the dwCtrlType value. <br>' <br>' See below for a list of the control operations and their pvCtrlPara <br>' type definition. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' Message control types <br>'-------------------------------------------------------------------------- <br>Public Const CMSG_CTRL_VERIFY_SIGNATURE As Long = 1 <br>Public Const CMSG_CTRL_DECRYPT As Long = 2 <br>Public Const CMSG_CTRL_VERIFY_HASH As Long = 5 <br>Public Const CMSG_CTRL_ADD_SIGNER As Long = 6 <br>Public Const CMSG_CTRL_DEL_SIGNER As Long = 7 <br>Public Const CMSG_CTRL_ADD_SIGNER_UNAUTH_ATTR As Long = 8 <br>Public Const CMSG_CTRL_DEL_SIGNER_UNAUTH_ATTR As Long = 9 <br>Public Const CMSG_CTRL_ADD_CERT As Long = 10 <br>Public Const CMSG_CTRL_DEL_CERT As Long = 11 <br>Public Const CMSG_CTRL_ADD_CRL As Long = 12 <br>Public Const CMSG_CTRL_DEL_CRL As Long = 13 <br>'+------------------------------------------------------------------------- <br>' CMSG_CTRL_VERIFY_SIGNATURE <br>' <br>' Verify the signature of a SIGNED or SIGNED_AND_ENVELOPED <br>' message after it has been decoded. <br>' <br>' For a SIGNED_AND_ENVELOPED message, called after <br>' with a NULL pRecipientInfo. <br>' <br>' pvCtrlPara points to a CERT_INFO struct. <br>' <br>' The CERT_INFO contains the Issuer and SerialNumber identifying <br>' the Signer of the message. The CERT_INFO also contains the <br>' PublicKeyInfo <br>' used to verify the signature. The cryptographic provider specified <br>' in CryptMsgOpenToDecode is used. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' CMSG_CTRL_DECRYPT <br>' <br>' Decrypt an ENVELOPED or SIGNED_AND_ENVELOPED message after it has been <br>' decoded. <br>' <br>' hCryptProv and dwKeySpec specify the private key to use. For dwKeySpec == <br>' 0, defaults to AT_KEYEXCHANGE. <br>' <br>' dwRecipientIndex is the index of the recipient in the message associated <br>' with the hCryptProv's private key. <br>' <br>' This control function needs to be called, if you don't know the appropriate <br>' recipient before calling CryptMsgOpenToDecode. After the final <br>' CryptMsgUpdate, the list of recipients is obtained by iterating through <br>' CMSG_RECIPIENT_INFO_PARAM. The recipient corresponding to a private <br>' key owned by the caller is selected and passed to this function to decrypt <br>' the message. <br>' <br>' Note, the message can only be decrypted once. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' CMSG_CTRL_VERIFY_HASH <br>' <br>' Verify the hash of a HASHED message after it has been decoded. <br>' <br>' Only the hCryptMsg parameter is used, to specify the message whose <br>' hash is being verified. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' CMSG_CTRL_ADD_SIGNER <br>' <br>' Add a signer to a signed-data or signed-and-enveloped-data message. <br>' <br>' pvCtrlPara points to a CMSG_SIGNER_ENCODE_INFO. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' CMSG_CTRL_DEL_SIGNER <br>' <br>' Remove a signer from a signed-data or signed-and-enveloped-data message. <br>' <br>' pvCtrlPara points to a DWORD containing the 0-based index of the <br>' signer to be removed. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' CMSG_CTRL_ADD_SIGNER_UNAUTH_ATTR <br>' <br>' Add an unauthenticated attribute to the SignerInfo of a signed-data or <br>' signed-and-enveloped-data message. <br>' <br>' The unauthenticated attribute is input in the form of an encoded blob. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' CMSG_CTRL_DEL_SIGNER_UNAUTH_ATTR <br>' <br>' Delete an unauthenticated attribute from the SignerInfo of a signed-data <br>' or signed-and-enveloped-data message. <br>' <br>' The unauthenticated attribute to be removed is specified by <br>' a 0-based index. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' CMSG_CTRL_ADD_CERT <br>' <br>' Add a certificate to a signed-data or signed-and-enveloped-data message. <br>' <br>' pvCtrlPara points to a CRYPT_DATA_BLOB containing the certificate's <br>' encoded bytes. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' CMSG_CTRL_DEL_CERT <br>' <br>' Delete a certificate from a signed-data or signed-and-enveloped-data <br>' message. <br>' <br>' pvCtrlPara points to a DWORD containing the 0-based index of the <br>' certificate to be removed. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' CMSG_CTRL_ADD_CRL <br>' <br>' Add a CRL to a signed-data or signed-and-enveloped-data message. <br>' <br>' pvCtrlPara points to a CRYPT_DATA_BLOB containing the CRL's <br>' encoded bytes. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' CMSG_CTRL_DEL_CRL <br>' <br>' Delete a CRL from a signed-data or signed-and-enveloped-data message. <br>' <br>' pvCtrlPara points to a DWORD containing the 0-based index of the CRL <br>' to be removed. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' Verify a countersignature, at the SignerInfo level. <br>' ie. verify that pbSignerInfoCountersignature contains the encrypted <br>' hash of the encryptedDigest field of pbSignerInfo. <br>' <br>' hCryptProv is used to hash the encryptedDigest field of pbSignerInfo. <br>' The only fields referenced from pciCountersigner are SerialNumber, Issuer, <br>' and SubjectPublicKeyInfo. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' Countersign an already-existing signature in a message <br>' <br>' dwIndex is a zero-based index of the SignerInfo to be countersigned. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' Output an encoded SignerInfo blob, suitable for use as a countersignature <br>' attribute in the unauthenticated attributes of a signed-data or <br>' signed-and-enveloped-data message. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' Get a parameter after encoding/decoding a cryptographic message. Called <br>' after the final CryptMsgUpdate. Only the CMSG_CONTENT_PARAM and <br>' CMSG_COMPUTED_HASH_PARAM are valid for an encoded message. <br>' <br>' For an encoded HASHED message, the CMSG_COMPUTED_HASH_PARAM can be got <br>' before any CryptMsgUpdates to get its length. <br>' <br>' The pvData type definition depends on the dwParamType value. <br>' <br>' Elements pointed to by fields in the pvData structure follow the <br>' structure. Therefore, *pcbData may exceed the size of the structure. <br>' <br>' Upon input, if *pcbData == 0, then, *pcbData is updated with the length <br>' of the data and the pvData parameter is ignored. <br>' <br>' Upon return, *pcbData is updated with the length of the data. <br>' <br>' The OBJID BLOBs returned in the pvData structures point to <br>' their still encoded representation. The appropriate functions <br>' must be called to decode the information. <br>' <br>' See below for a list of the parameters to get. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' Get parameter types and their corresponding data structure definitions. <br>'-------------------------------------------------------------------------- <br>Public Const CMSG_TYPE_PARAM As Long = 1 <br>Public Const CMSG_CONTENT_PARAM As Long = 2 <br>Public Const CMSG_BARE_CONTENT_PARAM As Long = 3 <br>Public Const CMSG_INNER_CONTENT_TYPE_PARAM As Long = 4 <br>Public Const CMSG_SIGNER_COUNT_PARAM As Long = 5 <br>Public Const CMSG_SIGNER_INFO_PARAM As Long = 6 <br>Public Const CMSG_SIGNER_CERT_INFO_PARAM As Long = 7 <br>Public Const CMSG_SIGNER_HASH_ALGORITHM_PARAM As Long = 8 <br>Public Const CMSG_SIGNER_AUTH_ATTR_PARAM As Long = 9 <br>Public Const CMSG_SIGNER_UNAUTH_ATTR_PARAM As Long = 10 <br>Public Const CMSG_CERT_COUNT_PARAM As Long = 11 <br>Public Const CMSG_CERT_PARAM As Long = 12 <br>Public Const CMSG_CRL_COUNT_PARAM As Long = 13 <br>Public Const CMSG_CRL_PARAM As Long = 14 <br>Public Const CMSG_ENVELOPE_ALGORITHM_PARAM As Long = 15 <br>Public Const CMSG_RECIPIENT_COUNT_PARAM As Long = 17 <br>Public Const CMSG_RECIPIENT_INDEX_PARAM As Long = 18 <br>Public Const CMSG_RECIPIENT_INFO_PARAM As Long = 19 <br>Public Const CMSG_HASH_ALGORITHM_PARAM As Long = 20 <br>Public Const CMSG_HASH_DATA_PARAM As Long = 21 <br>Public Const CMSG_COMPUTED_HASH_PARAM As Long = 22 <br>Public Const CMSG_ENCRYPT_PARAM As Long = 26 <br>Public Const CMSG_ENCRYPTED_DIGEST As Long = 27 <br>Public Const CMSG_ENCODED_SIGNER As Long = 28 <br>Public Const CMSG_ENCODED_MESSAGE As Long = 29 <br>'+------------------------------------------------------------------------- <br>' CMSG_TYPE_PARAM <br>' <br>' The type of the decoded message. <br>' <br>' pvData points to a DWORD </code></pre>
<p>
</p>
<pre><code>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' CMSG_CONTENT_PARAM <br>' <br>' The encoded content of a cryptographic message. Depending on how the <br>' message was opened, the content is either the whole PKCS#7 <br>' In the decode case, the decrypted content is returned, if enveloped. <br>' If not enveloped, and if the inner content is of type DATA, the returned <br>' data is the contents octets of the inner content. <br>' <br>' pvData points to the buffer receiving the content bytes <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' CMSG_BARE_CONTENT_PARAM <br>' <br>' The encoded content of an encoded cryptographic message, without the <br>' outer layer of ContentInfo. That is, only the encoding of the <br>' ContentInfo.content field is returned. <br>' <br>' pvData points to the buffer receiving the content bytes <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' CMSG_INNER_CONTENT_TYPE_PARAM <br>' <br>' The type of the inner content of a decoded cryptographic message, <br>' in the form of a NULL-terminated object identifier string <br>' <br>' pvData points to the buffer receiving the object identifier string <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' CMSG_SIGNER_COUNT_PARAM <br>' <br>' Count of signers in a SIGNED or SIGNED_AND_ENVELOPED message <br>' <br>' pvData points to a DWORD <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' CMSG_SIGNER_CERT_INFO_PARAM <br>' <br>' To get all the signers, repetitively call CryptMsgGetParam, with <br>' dwIndex set to 0 .. SignerCount - 1. <br>' <br>' pvData points to a CERT_INFO struct. <br>' <br>' Only the following fields have been updated in the CERT_INFO struct: <br>' Issuer and SerialNumber. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' CMSG_SIGNER_INFO_PARAM <br>' <br>' To get all the signers, repetitively call CryptMsgGetParam, with <br>' dwIndex set to 0 .. SignerCount - 1. <br>' <br>' pvData points to a CMSG_SIGNER_INFO struct. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' CMSG_SIGNER_HASH_ALGORITHM_PARAM <br>' <br>' This parameter specifies the HashAlgorithm that was used for the signer. <br>' <br>' Set dwIndex to iterate through all the signers. <br>' <br>' pvData points to an CRYPT_ALGORITHM_IDENTIFIER struct. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' CMSG_SIGNER_AUTH_ATTR_PARAM <br>' <br>' The authenticated attributes for the signer. <br>' <br>' Set dwIndex to iterate through all the signers. <br>' <br>' pvData points to a CMSG_ATTR struct. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' CMSG_SIGNER_UNAUTH_ATTR_PARAM <br>' <br>' The unauthenticated attributes for the signer. <br>' <br>' Set dwIndex to iterate through all the signers. <br>' <br>' pvData points to a CMSG_ATTR struct. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' CMSG_CERT_COUNT_PARAM <br>' <br>' Count of certificates in a SIGNED or SIGNED_AND_ENVELOPED message. <br>' <br>' pvData points to a DWORD <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' CMSG_CERT_PARAM <br>' <br>' To get all the certificates, repetitively call CryptMsgGetParam, with <br>' dwIndex set to 0 .. CertCount - 1. <br>' <br>' pvData points to an array of the certificate's encoded bytes. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' CMSG_CRL_COUNT_PARAM <br>' <br>' Count of CRLs in a SIGNED or SIGNED_AND_ENVELOPED message. <br>' <br>' pvData points to a DWORD <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' CMSG_CRL_PARAM <br>' <br>' To get all the CRLs, repetitively call CryptMsgGetParam, with <br>' dwIndex set to 0 .. CrlCount - 1. <br>' <br>' pvData points to an array of the CRL's encoded bytes. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' CMSG_ENVELOPE_ALGORITHM_PARAM <br>' <br>' The ContentEncryptionAlgorithm that was used in <br>' an ENVELOPED or SIGNED_AND_ENVELOPED message. <br>' <br>' pvData points to an CRYPT_ALGORITHM_IDENTIFIER struct. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' CMSG_RECIPIENT_COUNT_PARAM <br>' <br>' Count of recipients in an ENVELOPED or SIGNED_AND_ENVELOPED message. <br>' <br>' pvData points to a DWORD <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' CMSG_RECIPIENT_INDEX_PARAM <br>' <br>' Index of the recipient used to decrypt an ENVELOPED or SIGNED_AND_ENVELOPED <br>' message. <br>' <br>' pvData points to a DWORD <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' CMSG_RECIPIENT_INFO_PARAM <br>' <br>' To get all the recipients, repetitively call CryptMsgGetParam, with <br>' dwIndex set to 0 .. RecipientCount - 1. <br>' <br>' pvData points to a CERT_INFO struct. <br>' <br>' Only the following fields have been updated in the CERT_INFO struct: <br>' Issuer, SerialNumber and PublicKeyAlgorithm. The PublicKeyAlgorithm <br>' specifies the KeyEncryptionAlgorithm that was used. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' CMSG_HASH_ALGORITHM_PARAM <br>' <br>' The HashAlgorithm in a HASHED message. <br>' <br>' pvData points to an CRYPT_ALGORITHM_IDENTIFIER struct. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' CMSG_HASH_DATA_PARAM <br>' <br>' The hash in a HASHED message. <br>' <br>' pvData points to an array of bytes. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' CMSG_COMPUTED_HASH_PARAM <br>' <br>' The computed hash for a HASHED message. <br>' <br>' This may be called for either an encoded or decoded message. <br>' It also may be called before any encoded CryptMsgUpdates to get its length. <br>' <br>' pvData points to an array of bytes. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' CMSG_ENCRYPT_PARAM <br>' <br>' The ContentEncryptionAlgorithm that was used in an ENCRYPTED message. <br>' <br>' pvData points to an CRYPT_ALGORITHM_IDENTIFIER struct. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' CMSG_ENCODED_MESSAGE <br>' <br>' The full encoded message. This is useful in the case of a decoded <br>' signed-and-enveloped-data message which has been countersigned). <br>' <br>' pvData points to an array of the message's encoded bytes. <br>'-------------------------------------------------------------------------- <br>'+========================================================================= <br>' Certificate Store Data Structures and APIs <br>'========================================================================== <br>'+------------------------------------------------------------------------- <br>' In its most basic implementation, a cert store is simply a <br>' collection of certificates and/or CRLs. This is the case when <br>' a cert store is opened with all of its certificates and CRLs <br>' coming from a PKCS #7 encoded cryptographic message. <br>' <br>' Nonetheless, all cert stores have the following properties: <br>' - A public key may have more than one certificate in the store. <br>' For example, a private/public key used for signing may have a <br>' certificate issued for VISA and another issued for <br>' Mastercard. Also, when a certificate is renewed there might <br>' be more than one certificate with the same subject and <br>' issuer. <br>' - However, each certificate in the store is uniquely <br>' identified by its Issuer and SerialNumber. <br>' - There's an issuer of subject certificate relationship. A <br>' certificate's issuer is found by doing a match of <br>' pSubjectCert-&gt;Issuer with pIssuerCert-&gt;Subject. <br>' The relationship is verified by using <br>' the issuer's public key to verify the subject certificate's <br>' signature. Note, there might be X.509 v3 extensions <br>' to assist in finding the issuer certificate. <br>' - Since issuer certificates might be renewed, a subject <br>' certificate might have more than one issuer certificate. <br>' - There's an issuer of CRL relationship. An <br>' issuer's CRL is found by doing a match of <br>' pIssuerCert-&gt;Subject with pCrl-&gt;Issuer. <br>' The relationship is verified by using <br>' the issuer's public key to verify the CRL's <br>' signature. Note, there might be X.509 v3 extensions <br>' to assist in finding the CRL. <br>' - Since some issuers might support the X.509 v3 delta CRL <br>' extensions, an issuer might have more than one CRL. <br>' - The store shouldn't have any redundant certificates or <br>' CRLs. There shouldn't be two certificates with the same <br>' Issuer and SerialNumber. There shouldn't be two CRLs with <br>' the same Issuer, ThisUpdate and NextUpdate. <br>' - The store has NO policy or trust information. No <br>' certificates are tagged as being "root". Its up to <br>' SerialNumber) for certificates it trusts. <br>' - The store might contain bad certificates and/or CRLs. <br>' The issuer's signature of a subject certificate or CRL may <br>' not verify. Certificates or CRLs may not satisfy their <br>' time validity requirements. Certificates may be <br>' revoked. <br>' <br>' In addition to the certificates and CRLs, properties can be <br>' stored. There are two predefined property IDs for a user <br>' certificate: CERT_KEY_PROV_HANDLE_PROP_ID and <br>' CERT_KEY_PROV_INFO_PROP_ID. The CERT_KEY_PROV_HANDLE_PROP_ID <br>' is a HCRYPTPROV handle to the private key assoicated <br>' with the certificate. The CERT_KEY_PROV_INFO_PROP_ID contains <br>' information to be used to call <br>' CryptAcquireContext and CryptProvSetParam to get a handle <br>' to the private key associated with the certificate. <br>' <br>' There exists two more predefined property IDs for certificates <br>' and CRLs, CERT_SHA1_HASH_PROP_ID and CERT_MD5_HASH_PROP_ID. <br>' If these properties don't already exist, then, a hash of the <br>' hash algorithm, currently, CERT_SHA1_HASH_PROP_ID). <br>' <br>' There are additional APIs for creating certificate and CRL <br>' CertCreateCRLContext). <br>' <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' Certificate context. <br>' <br>' A certificate context contains both the encoded and decoded representation <br>' of a certificate. A certificate context returned by a cert store function <br>' must be freed by calling the CertFreeCertificateContext function. The <br>' CertDuplicateCertificateContext function can be called to make a duplicate <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' CRL context. <br>' <br>' A CRL context contains both the encoded and decoded representation <br>' of a CRL. A CRL context returned by a cert store function <br>' must be freed by calling the CertFreeCRLContext function. The <br>' CertDuplicateCRLContext function can be called to make a duplicate <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' <br>' A CTL context contains both the encoded and decoded representation <br>' of a CTL. Also contains an opened HCRYPTMSG handle to the decoded <br>' cryptographic signed message containing the CTL_INFO as its inner content. <br>' pbCtlContent is the encoded inner content of the signed message. <br>' <br>' The CryptMsg APIs can be used to extract additional signer information. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' Certificate, CRL and CTL property IDs <br>' <br>' See CertSetCertificateContextProperty or CertGetCertificateContextProperty <br>' for usage information. <br>'-------------------------------------------------------------------------- <br>Public Const CERT_KEY_PROV_HANDLE_PROP_ID As Long = 1 <br>Public Const CERT_KEY_PROV_INFO_PROP_ID As Long = 2 <br>Public Const CERT_SHA1_HASH_PROP_ID As Long = 3 <br>Public Const CERT_MD5_HASH_PROP_ID As Long = 4 <br>Public Const CERT_KEY_CONTEXT_PROP_ID As Long = 5 <br>Public Const CERT_KEY_SPEC_PROP_ID As Long = 6 <br>Public Const CERT_IE30_RESERVED_PROP_ID As Long = 7 <br>Public Const CERT_PUBKEY_HASH_RESERVED_PROP_ID As Long = 8 <br>Public Const CERT_ENHKEY_USAGE_PROP_ID As Long = 9 <br>Public Const CERT_NEXT_UPDATE_LOCATION_PROP_ID As Long = 10 <br>Public Const CERT_FRIENDLY_NAME_PROP_ID As Long = 11 <br>' Note, 32 - 34 are reserved for the CERT, CRL and CTL file element IDs. <br>Public Const CERT_FIRST_RESERVED_PROP_ID As Long = 12 <br>Public Const CERT_LAST_RESERVED_PROP_ID As Long = &amp;H00007FFF <br>Public Const CERT_FIRST_USER_PROP_ID As Long = &amp;H00008000 <br>Public Const CERT_LAST_USER_PROP_ID As Long = &amp;H0000FFFF <br>'+------------------------------------------------------------------------- <br>' Cryptographic Key Provider Information <br>' <br>' CRYPT_KEY_PROV_INFO defines the CERT_KEY_PROV_INFO_PROP_ID's pvData. <br>' <br>' The CRYPT_KEY_PROV_INFO fields are passed to CryptAcquireContext <br>' to get a HCRYPTPROV handle. The optional CRYPT_KEY_PROV_PARAM fields are <br>' passed to CryptProvSetParam to further initialize the provider. <br>' <br>' The dwKeySpec field identifies the private key to use from the container <br>' For example, AT_KEYEXCHANGE or AT_SIGNATURE. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' The following flag should be set in the above dwFlags to enable <br>' CryptAcquireContext is done in the Sign or Decrypt Message functions. <br>' <br>' The following define must not collide with any of the <br>' CryptAcquireContext dwFlag defines. <br>'-------------------------------------------------------------------------- <br>Public Const CERT_SET_KEY_PROV_HANDLE_PROP_ID As Long = &amp;H00000001 <br>Public Const CERT_SET_KEY_CONTEXT_PROP_ID As Long = &amp;H00000001 <br>'+------------------------------------------------------------------------- <br>' Certificate Key Context <br>' <br>' CERT_KEY_CONTEXT defines the CERT_KEY_CONTEXT_PROP_ID's pvData. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' Certificate Store Provider Types <br>'-------------------------------------------------------------------------- <br>Public Const sz_CERT_STORE_PROV_MEMORY As String = "Memory" <br>Public Const sz_CERT_STORE_PROV_FILENAME_W As String = "File" <br>Public Const sz_CERT_STORE_PROV_SYSTEM_W As String = "System" <br>Public Const sz_CERT_STORE_PROV_PKCS7 As String = "PKCS7" <br>Public Const sz_CERT_STORE_PROV_SERIALIZED As String = "Serialized" <br>'+------------------------------------------------------------------------- <br>' Certificate Store verify/results flags <br>'-------------------------------------------------------------------------- <br>Public Const CERT_STORE_SIGNATURE_FLAG As Long = &amp;H00000001 <br>Public Const CERT_STORE_TIME_VALIDITY_FLAG As Long = &amp;H00000002 <br>Public Const CERT_STORE_REVOCATION_FLAG As Long = &amp;H00000004 <br>Public Const CERT_STORE_NO_CRL_FLAG As Long = &amp;H00010000 <br>Public Const CERT_STORE_NO_ISSUER_FLAG As Long = &amp;H00020000 <br>'+------------------------------------------------------------------------- <br>' Certificate Store open/property flags <br>'-------------------------------------------------------------------------- <br>Public Const CERT_STORE_NO_CRYPT_RELEASE_FLAG As Long = &amp;H00000001 <br>Public Const CERT_STORE_READONLY_FLAG As Long = &amp;H00008000 <br>'+------------------------------------------------------------------------- <br>' Certificate Store Provider flags are in the HiWord 0xFFFF0000 <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' Certificate System Store Flag Values <br>'-------------------------------------------------------------------------- <br>' Location of the system store in the registry: <br>' HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE <br>Public Const CERT_SYSTEM_STORE_LOCATION_MASK As Long = &amp;H00030000 <br>Public Const CERT_SYSTEM_STORE_CURRENT_USER As Long = &amp;H00010000 <br>Public Const CERT_SYSTEM_STORE_LOCAL_MACHINE As Long = &amp;H00020000 <br>'+------------------------------------------------------------------------- <br>' Open the cert store using the specified store provider. <br>' <br>' hCryptProv specifies the crypto provider to use to create the hash <br>' properties or verify the signature of a subject certificate or CRL. <br>' The store doesn't need to use a private <br>' key. If the CERT_STORE_NO_CRYPT_RELEASE_FLAG isn't set, hCryptProv is <br>' CryptReleaseContext'ed on the final CertCloseStore. <br>' <br>' Note, if the open fails, hCryptProv is released if it would have been <br>' released when the store was closed. <br>' <br>' If hCryptProv is zero, then, the default provider and container for the <br>' PROV_RSA_FULL provider type is CryptAcquireContext'ed with <br>' CRYPT_VERIFYCONTEXT access. The CryptAcquireContext is deferred until <br>' the first create hash or verify signature. In addition, once acquired, <br>' the default provider isn't released until process exit when crypt32.dll <br>' is unloaded. The acquired default provider is shared across all stores <br>' and threads. <br>' <br>' After initializing the store's data structures and optionally acquiring a <br>' default crypt provider, CertOpenStore calls CryptGetOIDFunctionAddress to <br>' get the address of the CRYPT_OID_OPEN_STORE_PROV_FUNC specified by <br>' lpszStoreProvider. Since a store can contain certificates with different <br>' encoding types, CryptGetOIDFunctionAddress is called with dwEncodingType <br>' set to 0 and not the dwEncodingType passed to CertOpenStore. <br>' PFN_CERT_DLL_OPEN_STORE_FUNC specifies the signature of the provider's <br>' open function. This provider open function is called to load the <br>' store's certificates and CRLs. Optionally, the provider may return an <br>' array of functions called before a certificate or CRL is added or deleted <br>' or has a property that is set. <br>' <br>' Use of the dwEncodingType parameter is provider dependent. The type <br>' definition for pvPara also depends on the provider. <br>' <br>' Store providers are installed or registered via <br>' CryptInstallOIDFunctionAddress or CryptRegisterOIDFunction, where, <br>' dwEncodingType is 0 and pszFuncName is CRYPT_OID_OPEN_STORE_PROV_FUNC. <br>' <br>' <br>' CERT_STORE_PROV_MSG: <br>' Gets the certificates and CRLs from the specified cryptographic message. <br>' dwEncodingType contains the message and certificate encoding types. <br>' The message's handle is passed in pvPara. Given, <br>' <br>' CERT_STORE_PROV_MEMORY <br>' sz_CERT_STORE_PROV_MEMORY: <br>' Opens a store without any initial certificates or CRLs. pvPara <br>' isn't used. <br>' <br>' CERT_STORE_PROV_FILE: <br>' Reads the certificates and CRLs from the specified file. The file's <br>' handle is passed in pvPara. Given, <br>' <br>' For a successful open, the file pointer is advanced past <br>' the certificates and CRLs and their properties read from the file. <br>' Note, only expects a serialized store and not a file containing <br>' either a PKCS #7 signed message or a single encoded certificate. <br>' <br>' The hFile isn't closed. <br>' <br>' CERT_STORE_PROV_REG: <br>' Reads the certificates and CRLs from the registry. The registry's <br>' key handle is passed in pvPara. Given, <br>' <br>' The input hKey isn't closed by the provider. Before returning, the <br>' provider opens/creates "Certificates" and "CRLs" subkeys. These <br>' subkeys remain open until the store is closed. <br>' <br>' If CERT_STORE_READONLY_FLAG is set, then, the registry subkeys are <br>' RegOpenKey'ed with KEY_READ_ACCESS. Otherwise, the registry subkeys <br>' are RegCreateKey'ed with KEY_ALL_ACCESS. <br>' <br>' This provider returns the array of functions for reading, writing, <br>' deleting and property setting certificates and CRLs. <br>' Any changes to the opened store are immediately pushed through to <br>' the registry. However, if CERT_STORE_READONLY_FLAG is set, then, <br>' writing, deleting or property setting results in a <br>' <br>' Note, all the certificates and CRLs are read from the registry <br>' when the store is opened. The opened store serves as a write through <br>' cache. However, the opened store isn't notified of other changes <br>' made to the registry. Note, RegNotifyChangeKeyValue is supported <br>' on NT but not supported on Windows95. <br>' <br>' CERT_STORE_PROV_PKCS7: <br>' sz_CERT_STORE_PROV_PKCS7: <br>' Gets the certificates and CRLs from the encoded PKCS #7 signed message. <br>' dwEncodingType specifies the message and certificate encoding types. <br>' The pointer to the encoded message's blob is passed in pvPara. Given, <br>' <br>' Note, also supports the IE3.0 special version of a <br>' PKCS #7 signed message referred to as a "SPC" formatted message. <br>' <br>' CERT_STORE_PROV_SERIALIZED: <br>' sz_CERT_STORE_PROV_SERIALIZED: <br>' Gets the certificates and CRLs from memory containing a serialized <br>' store. The pointer to the serialized memory blob is passed in pvPara. <br>' Given, <br>' <br>' CERT_STORE_PROV_FILENAME_A: <br>' CERT_STORE_PROV_FILENAME_W: <br>' CERT_STORE_PROV_FILENAME: <br>' sz_CERT_STORE_PROV_FILENAME_W: <br>' sz_CERT_STORE_PROV_FILENAME: <br>' Opens the file and first attempts to read as a serialized store. Then, <br>' as a PKCS #7 signed message. Finally, as a single encoded certificate. <br>' The filename is passed in pvPara. The filename is UNICODE for the <br>' "_W" provider and ASCII for the "_A" provider. For "_W": given, <br>' For "_A": given, <br>' <br>' <br>' Note, also supports the reading of the IE3.0 special version of a <br>' PKCS #7 signed message file referred to as a "SPC" formatted file. <br>' <br>' CERT_STORE_PROV_SYSTEM_A: <br>' CERT_STORE_PROV_SYSTEM_W: <br>' CERT_STORE_PROV_SYSTEM: <br>' sz_CERT_STORE_PROV_SYSTEM_W: <br>' sz_CERT_STORE_PROV_SYSTEM: <br>' Opens the specified "system" store. Currently, all the system <br>' stores are stored in the registry. The upper word of the dwFlags <br>' parameter is used to specify the location of the system store. It <br>' should be set to either CERT_SYSTEM_STORE_CURRENT_USER for <br>' HKEY_CURRENT_USER or CERT_SYSTEM_STORE_LOCAL_MACHINE for <br>' HKEY_LOCAL_MACHINE. <br>' <br>' After opening the registry key associated with the system name, <br>' the CERT_STORE_PROV_REG provider is called to complete the open. <br>' <br>' The system store name is passed in pvPara. The name is UNICODE for the <br>' "_W" provider and ASCII for the "_A" provider. For "_W": given, <br>' For "_A": given, <br>' <br>' <br>' If CERT_STORE_READONLY_FLAG is set, then, the registry is <br>' RegOpenKey'ed with KEY_READ_ACCESS. Otherwise, the registry is <br>' RegCreateKey'ed with KEY_ALL_ACCESS. <br>' <br>' The "root" store is treated differently from the other system <br>' stores. Before a certificate is added to or deleted from the "root" <br>' store, a pop up message box is displayed. The certificate's subject, <br>' issuer, serial number, time validity, sha1 and md5 thumbprints are <br>' displayed. The user is given the option to do the add or delete. <br>' If they don't allow the operation, LastError is set to E_ACCESSDENIED. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' OID Installable Certificate Store Provider Data Structures <br>'-------------------------------------------------------------------------- <br>' Handle returned by the store provider when opened. <br>' Store Provider OID function's pszFuncName. <br>Public Const CRYPT_OID_OPEN_STORE_PROV_FUNC As String = "CertDllOpenStoreProv" <br>' Note, the Store Provider OID function's dwEncodingType is always 0. <br>' The following information is returned by the provider when opened. Its <br>' zeroed with cbSize set before the provider is called. If the provider <br>' doesn't need to be called again after the open it doesn't need to <br>' make any updates to the CERT_STORE_PROV_INFO. <br>' Definition of the store provider's open function. <br>' <br>' *pStoreProvInfo has been zeroed before the call. <br>' <br>' Note, pStoreProvInfo-&gt;cStoreProvFunc should be set last. Once set, <br>' all subsequent store calls, such as CertAddSerializedElementToStore will <br>' call the appropriate provider callback function. <br>' Indices into the store provider's array of callback functions. <br>' <br>' The provider can implement any subset of the following functions. It <br>' sets pStoreProvInfo-&gt;cStoreProvFunc to the last index + 1 and any <br>' preceding not implemented functions to NULL. <br>Public Const CERT_STORE_PROV_CLOSE_FUNC As Long = 0 <br>Public Const CERT_STORE_PROV_READ_CERT_FUNC As Long = 1 <br>Public Const CERT_STORE_PROV_WRITE_CERT_FUNC As Long = 2 <br>Public Const CERT_STORE_PROV_DELETE_CERT_FUNC As Long = 3 <br>Public Const CERT_STORE_PROV_SET_CERT_PROPERTY_FUNC As Long = 4 <br>Public Const CERT_STORE_PROV_READ_CRL_FUNC As Long = 5 <br>Public Const CERT_STORE_PROV_WRITE_CRL_FUNC As Long = 6 <br>Public Const CERT_STORE_PROV_DELETE_CRL_FUNC As Long = 7 <br>Public Const CERT_STORE_PROV_SET_CRL_PROPERTY_FUNC As Long = 8 <br>Public Const CERT_STORE_PROV_READ_CTL_FUNC As Long = 9 <br>Public Const CERT_STORE_PROV_WRITE_CTL_FUNC As Long = 10 <br>Public Const CERT_STORE_PROV_DELETE_CTL_FUNC As Long = 11 <br>Public Const CERT_STORE_PROV_SET_CTL_PROPERTY_FUNC As Long = 12 <br>' Called by CertCloseStore when the store's reference count is <br>' decremented to 0. <br>' Currently not called directly by the store APIs. However, may be exported <br>' to support other providers based on it. <br>' <br>' Reads the provider's copy of the certificate context. If it exists, <br>' creates a new certificate context. <br>Public Const CERT_STORE_PROV_WRITE_ADD_FLAG As Long = &amp;H1 <br>' Called by CertAddEncodedCertificateToStore, <br>' CertAddCertificateContextToStore or CertAddSerializedElementToStore before <br>' adding to the store. The CERT_STORE_PROV_WRITE_ADD_FLAG is set. In <br>' addition to the encoded certificate, the added pCertContext might also <br>' have properties. <br>' <br>' Returns TRUE if its OK to update the the store. <br>' Called by CertDeleteCertificateFromStore before deleting from the <br>' store. <br>' <br>' Returns TRUE if its OK to delete from the store. <br>' Called by CertSetCertificateContextProperty before setting the <br>' certificate's property. Also called by CertGetCertificateContextProperty, <br>' when getting a hash property that needs to be created and then persisted <br>' via the set. <br>' <br>' Upon input, the property hasn't been set for the pCertContext parameter. <br>' <br>' Returns TRUE if its OK to set the property. <br>' Currently not called directly by the store APIs. However, may be exported <br>' to support other providers based on it. <br>' <br>' Reads the provider's copy of the CRL context. If it exists, <br>' creates a new CRL context. <br>' Called by CertAddEncodedCRLToStore, <br>' CertAddCRLContextToStore or CertAddSerializedElementToStore before <br>' adding to the store. The CERT_STORE_PROV_WRITE_ADD_FLAG is set. In <br>' addition to the encoded CRL, the added pCertContext might also <br>' have properties. <br>' <br>' Returns TRUE if its OK to update the the store. <br>' Called by CertDeleteCRLFromStore before deleting from the store. <br>' <br>' Returns TRUE if its OK to delete from the store. <br>' Called by CertSetCRLContextProperty before setting the <br>' CRL's property. Also called by CertGetCRLContextProperty, <br>' when getting a hash property that needs to be created and then persisted <br>' via the set. <br>' <br>' Upon input, the property hasn't been set for the pCrlContext parameter. <br>' <br>' Returns TRUE if its OK to set the property. <br>' Currently not called directly by the store APIs. However, may be exported <br>' to support other providers based on it. <br>' <br>' Reads the provider's copy of the CTL context. If it exists, <br>' creates a new CTL context. <br>' Called by CertAddEncodedCTLToStore, <br>' CertAddCTLContextToStore or CertAddSerializedElementToStore before <br>' adding to the store. The CERT_STORE_PROV_WRITE_ADD_FLAG is set. In <br>' addition to the encoded CTL, the added pCertContext might also <br>' have properties. <br>' <br>' Returns TRUE if its OK to update the the store. <br>' Called by CertDeleteCTLFromStore before deleting from the store. <br>' <br>' Returns TRUE if its OK to delete from the store. <br>' Called by CertSetCTLContextProperty before setting the <br>' CTL's property. Also called by CertGetCTLContextProperty, <br>' when getting a hash property that needs to be created and then persisted <br>' via the set. <br>' <br>' Upon input, the property hasn't been set for the pCtlContext parameter. <br>' <br>' Returns TRUE if its OK to set the property. <br>'+------------------------------------------------------------------------- <br>' Duplicate a cert store handle <br>'-------------------------------------------------------------------------- <br>Public Const CERT_STORE_SAVE_AS_STORE As Long = 1 <br>Public Const CERT_STORE_SAVE_AS_PKCS7 As Long = 2 <br>Public Const CERT_STORE_SAVE_TO_FILE As Long = 1 <br>Public Const CERT_STORE_SAVE_TO_MEMORY As Long = 2 <br>Public Const CERT_STORE_SAVE_TO_FILENAME_A As Long = 3 <br>Public Const CERT_STORE_SAVE_TO_FILENAME_W As Long = 4 <br>'+------------------------------------------------------------------------- </code></pre>
<p>
</p>
<pre><code>' Save the cert store. Extended version with lots of options. <br>' <br>' According to the dwSaveAs parameter, the store can be saved as a <br>' addition to encoded certificates, CRLs and CTLs or the store can be saved <br>' include the properties or CTLs. <br>' <br>' CERT_KEY_PROV_HANDLE_PROP_ID or CERT_KEY_SPEC_PROP_ID) isn't saved into <br>' a serialized store. <br>' <br>' For CERT_STORE_SAVE_AS_PKCS7, the dwEncodingType specifies the message <br>' encoding type. The dwEncodingType parameter isn't used for <br>' CERT_STORE_SAVE_AS_STORE. <br>' <br>' The dwFlags parameter currently isn't used and should be set to 0. <br>' <br>' The dwSaveTo and pvSaveToPara parameters specify where to save the <br>' store as follows: <br>' CERT_STORE_SAVE_TO_FILE: <br>' Saves to the specified file. The file's handle is passed in <br>' pvSaveToPara. Given, <br>' <br>' For a successful save, the file pointer is positioned after the <br>' last write. <br>' <br>' CERT_STORE_SAVE_TO_MEMORY: <br>' Saves to the specified memory blob. The pointer to <br>' the memory blob is passed in pvSaveToPara. Given, <br>' Upon entry, the SaveBlob's pbData and cbData need to be initialized. <br>' Upon return, cbData is updated with the actual length. <br>' For a length only calculation, pbData should be set to NULL. If <br>' pbData is non-NULL and cbData isn't large enough, FALSE is returned <br>' with a last error of ERRROR_MORE_DATA. <br>' <br>' CERT_STORE_SAVE_TO_FILENAME_A: <br>' CERT_STORE_SAVE_TO_FILENAME_W: <br>' CERT_STORE_SAVE_TO_FILENAME: <br>' Opens the file and saves to it. The filename is passed in pvSaveToPara. <br>' The filename is UNICODE for the "_W" option and ASCII for the "_A" <br>' option. For "_W": given, <br>' For "_A": given, <br>' <br>' <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' Certificate Store close flags <br>'-------------------------------------------------------------------------- <br>Public Const CERT_CLOSE_STORE_FORCE_FLAG As Long = &amp;H00000001 <br>Public Const CERT_CLOSE_STORE_CHECK_FLAG As Long = &amp;H00000002 <br>'+------------------------------------------------------------------------- <br>' Close a cert store handle. <br>' <br>' There needs to be a corresponding close for each open and duplicate. <br>' <br>' Even on the final close, the cert store isn't freed until all of its <br>' certificate and CRL contexts have also been freed. <br>' <br>' On the final close, the hCryptProv passed to CertStoreOpen is <br>' CryptReleaseContext'ed. <br>' <br>' To force the closure of the store with all of its memory freed, set the <br>' CERT_STORE_CLOSE_FORCE_FLAG. This flag should be set when the caller does <br>' its own reference counting and wants everything to vanish. <br>' <br>' To check if all the store's certificates and CRLs have been freed and that <br>' this is the last CertCloseStore, set the CERT_CLOSE_STORE_CHECK_FLAG. If <br>' set and certs, CRLs or stores still need to be freed/closed, FALSE is <br>' returned with LastError set to CRYPT_E_PENDING_CLOSE. Note, for FALSE, <br>' the store is still closed. This is a diagnostic flag. <br>' <br>' LastError is preserved unless CERT_CLOSE_STORE_CHECK_FLAG is set and FALSE <br>' is returned. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' Get the subject certificate context uniquely identified by its Issuer and <br>' SerialNumber from the store. <br>' <br>' If the certificate isn't found, NULL is returned. Otherwise, a pointer to <br>' a read only CERT_CONTEXT is returned. CERT_CONTEXT must be freed by calling <br>' CertFreeCertificateContext. CertDuplicateCertificateContext can be called to make a <br>' duplicate. <br>' <br>' The returned certificate might not be valid. Normally, it would be <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' Enumerate the certificate contexts in the store. <br>' <br>' If a certificate isn't found, NULL is returned. <br>' Otherwise, a pointer to a read only CERT_CONTEXT is returned. CERT_CONTEXT <br>' must be freed by calling CertFreeCertificateContext or is freed when passed as the <br>' pPrevCertContext on a subsequent call. CertDuplicateCertificateContext <br>' can be called to make a duplicate. <br>' <br>' pPrevCertContext MUST BE NULL to enumerate the first <br>' certificate in the store. Successive certificates are enumerated by setting <br>' pPrevCertContext to the CERT_CONTEXT returned by a previous call. <br>' <br>' NOTE: a NON-NULL pPrevCertContext is always CertFreeCertificateContext'ed by <br>' this function, even for an error. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' Find the first or next certificate context in the store. <br>' <br>' The certificate is found according to the dwFindType and its pvFindPara. <br>' See below for a list of the find types and its parameters. <br>' <br>' Currently dwFindFlags is only used for CERT_FIND_SUBJECT_ATTR, <br>' CERT_FIND_ISSUER_ATTR or CERT_FIND_CTL_USAGE. Otherwise, must be set to 0. <br>' <br>' Usage of dwCertEncodingType depends on the dwFindType. <br>' <br>' If the first or next certificate isn't found, NULL is returned. <br>' Otherwise, a pointer to a read only CERT_CONTEXT is returned. CERT_CONTEXT <br>' must be freed by calling CertFreeCertificateContext or is freed when passed as the <br>' pPrevCertContext on a subsequent call. CertDuplicateCertificateContext <br>' can be called to make a duplicate. <br>' <br>' pPrevCertContext MUST BE NULL on the first <br>' call to find the certificate. To find the next certificate, the <br>' pPrevCertContext is set to the CERT_CONTEXT returned by a previous call. <br>' <br>' NOTE: a NON-NULL pPrevCertContext is always CertFreeCertificateContext'ed by <br>' this function, even for an error. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' Certificate comparison functions <br>'-------------------------------------------------------------------------- <br>Public Const CERT_COMPARE_MASK As Long = &amp;HFFFF <br>Public Const CERT_COMPARE_SHIFT As Long = 16 <br>Public Const CERT_COMPARE_ANY As Long = 0 <br>Public Const CERT_COMPARE_SHA1_HASH As Long = 1 <br>Public Const CERT_COMPARE_NAME As Long = 2 <br>Public Const CERT_COMPARE_ATTR As Long = 3 <br>Public Const CERT_COMPARE_MD5_HASH As Long = 4 <br>Public Const CERT_COMPARE_PROPERTY As Long = 5 <br>Public Const CERT_COMPARE_PUBLIC_KEY As Long = 6 <br>Public Const CERT_COMPARE_NAME_STR_A As Long = 7 <br>Public Const CERT_COMPARE_NAME_STR_W As Long = 8 <br>Public Const CERT_COMPARE_KEY_SPEC As Long = 9 <br>Public Const CERT_COMPARE_ENHKEY_USAGE As Long = 10 <br>'+------------------------------------------------------------------------- <br>' dwFindType <br>' <br>' The dwFindType definition consists of two components: <br>' - comparison function <br>' - certificate information flag <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' CERT_FIND_ANY <br>' <br>' Find any certificate. <br>' <br>' pvFindPara isn't used. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' CERT_FIND_HASH <br>' <br>' Find a certificate with the specified hash. <br>' <br>' pvFindPara points to a CRYPT_HASH_BLOB. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' CERT_FIND_PROPERTY <br>' <br>' Find a certificate having the specified property. <br>' <br>' pvFindPara points to a DWORD containing the PROP_ID <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' CERT_FIND_PUBLIC_KEY <br>' <br>' Find a certificate matching the specified public key. <br>' <br>' pvFindPara points to a CERT_PUBLIC_KEY_INFO containing the public key <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' CERT_FIND_SUBJECT_NAME <br>' CERT_FIND_ISSUER_NAME <br>' <br>' Find a certificate with the specified subject/issuer name. Does an exact <br>' match of the entire name. <br>' <br>' Restricts search to certificates matching the dwCertEncodingType. <br>' <br>' pvFindPara points to a CERT_NAME_BLOB. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' CERT_FIND_SUBJECT_ATTR <br>' CERT_FIND_ISSUER_ATTR <br>' <br>' Find a certificate with the specified subject/issuer attributes. <br>' <br>' Compares the attributes in the subject/issuer name with the <br>' pvFindPara. The comparison iterates through the CERT_RDN attributes and looks <br>' for an attribute match in any of the subject/issuer's RDNs. <br>' <br>' The CERT_RDN_ATTR fields can have the following special values: <br>' pszObjId == NULL - ignore the attribute object identifier <br>' dwValueType == RDN_ANY_TYPE - ignore the value type <br>' Value.pbData == NULL - match any value <br>' <br>' Currently only an exact, case sensitive match is supported. <br>' <br>' CERT_UNICODE_IS_RDN_ATTRS_FLAG should be set in dwFindFlags if the RDN was <br>' initialized with unicode strings as for <br>' <br>' Restricts search to certificates matching the dwCertEncodingType. <br>' <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' CERT_FIND_SUBJECT_STR_A <br>' CERT_FIND_SUBJECT_STR_W | CERT_FIND_SUBJECT_STR <br>' CERT_FIND_ISSUER_STR_A <br>' CERT_FIND_ISSUER_STR_W | CERT_FIND_ISSUER_STR <br>' <br>' Find a certificate containing the specified subject/issuer name string. <br>' <br>' First, the certificate's subject/issuer is converted to a name string <br>' case insensitive substring within string match is performed. <br>' <br>' Restricts search to certificates matching the dwCertEncodingType. <br>' <br>' For *_STR_A, pvFindPara points to a null terminated character string. <br>' For *_STR_W, pvFindPara points to a null terminated wide character string. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' CERT_FIND_KEY_SPEC <br>' <br>' Find a certificate having a CERT_KEY_SPEC_PROP_ID property matching <br>' the specified KeySpec. <br>' <br>' pvFindPara points to a DWORD containing the KeySpec. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' CERT_FIND_ENHKEY_USAGE <br>' <br>' Find a certificate having the szOID_ENHANCED_KEY_USAGE extension or <br>' the CERT_ENHKEY_USAGE_PROP_ID and matching the specified pszUsageIdentifers. <br>' <br>' pvFindPara points to a CERT_ENHKEY_USAGE data structure. If pvFindPara <br>' is NULL or CERT_ENHKEY_USAGE's cUsageIdentifier is 0, then, matches any <br>' certificate having enhanced key usage. <br>' <br>' The CERT_FIND_OPTIONAL_ENHKEY_USAGE_FLAG can be set in dwFindFlags to <br>' also match a certificate without either the extension or property. <br>' <br>' If CERT_FIND_NO_ENHKEY_USAGE_FLAG is set in dwFindFlags, finds <br>' certificates without the key usage extension or property. Setting this <br>' flag takes precedence over pvFindPara being NULL. <br>' <br>' If the CERT_FIND_EXT_ONLY_ENHKEY_USAGE_FLAG is set, then, only does a match <br>' using the extension. If pvFindPara is NULL or cUsageIdentifier is set to <br>' 0, finds certificates having the extension. If <br>' CERT_FIND_OPTIONAL_ENHKEY_USAGE_FLAG is set, also matches a certificate <br>' without the extension. If CERT_FIND_NO_ENHKEY_USAGE_FLAG is set, finds <br>' certificates without the extension. <br>' <br>' If the CERT_FIND_EXT_PROP_ENHKEY_USAGE_FLAG is set, then, only does a match <br>' using the property. If pvFindPara is NULL or cUsageIdentifier is set to <br>' 0, finds certificates having the property. If <br>' CERT_FIND_OPTIONAL_ENHKEY_USAGE_FLAG is set, also matches a certificate <br>' without the property. If CERT_FIND_NO_ENHKEY_USAGE_FLAG is set, finds <br>' certificates without the property. <br>'-------------------------------------------------------------------------- <br>Public Const CERT_FIND_OPTIONAL_ENHKEY_USAGE_FLAG As Long = &amp;H1 <br>Public Const CERT_FIND_EXT_ONLY_ENHKEY_USAGE_FLAG As Long = &amp;H2 <br>Public Const CERT_FIND_PROP_ONLY_ENHKEY_USAGE_FLAG As Long = &amp;H4 <br>Public Const CERT_FIND_NO_ENHKEY_USAGE_FLAG As Long = &amp;H8 <br>'+------------------------------------------------------------------------- <br>' Get the certificate context from the store for the first or next issuer <br>' of the specified subject certificate. Perform the enabled <br>' using the returned issuer certificate.) <br>' <br>' If the first or next issuer certificate isn't found, NULL is returned. <br>' Otherwise, a pointer to a read only CERT_CONTEXT is returned. CERT_CONTEXT <br>' must be freed by calling CertFreeCertificateContext or is freed when passed as the <br>' pPrevIssuerContext on a subsequent call. CertDuplicateCertificateContext <br>' can be called to make a duplicate. <br>' <br>' For a self signed subject certificate, NULL is returned with LastError set <br>' to CERT_STORE_SELF_SIGNED. The enabled verification checks are still done. <br>' <br>' The pSubjectContext may have been obtained from this store, another store <br>' or created by the caller application. When created by the caller, the <br>' CertCreateCertificateContext function must have been called. <br>' <br>' An issuer may have multiple certificates. This may occur when the validity <br>' period is about to change. pPrevIssuerContext MUST BE NULL on the first <br>' call to get the issuer. To get the next certificate for the issuer, the <br>' pPrevIssuerContext is set to the CERT_CONTEXT returned by a previous call. <br>' <br>' NOTE: a NON-NULL pPrevIssuerContext is always CertFreeCertificateContext'ed by <br>' this function, even for an error. <br>' <br>' The following flags can be set in *pdwFlags to enable verification checks <br>' on the subject certificate context: <br>' CERT_STORE_SIGNATURE_FLAG - use the public key in the returned <br>' issuer certificate to verify the <br>' signature on the subject certificate. <br>' Note, if pSubjectContext-&gt;hCertStore == <br>' hCertStore, the store provider might <br>' be able to eliminate a redo of <br>' the signature verify. <br>' CERT_STORE_TIME_VALIDITY_FLAG - get the current time and verify that <br>' its within the subject certificate's <br>' validity period <br>' CERT_STORE_REVOCATION_FLAG - check if the subject certificate is on <br>' the issuer's revocation list <br>' <br>' If an enabled verification check fails, then, its flag is set upon return. <br>' If CERT_STORE_REVOCATION_FLAG was enabled and the issuer doesn't have a <br>' CRL in the store, then, CERT_STORE_NO_CRL_FLAG is set in addition to <br>' the CERT_STORE_REVOCATION_FLAG. <br>' <br>' If CERT_STORE_SIGNATURE_FLAG or CERT_STORE_REVOCATION_FLAG is set, then, <br>' CERT_STORE_NO_ISSUER_FLAG is set if it doesn't have an issuer certificate <br>' in the store. <br>' <br>' For a verification check failure, a pointer to the issuer's CERT_CONTEXT <br>' is still returned and SetLastError isn't updated. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' Perform the enabled verification checks on the subject certificate <br>' using the issuer. Same checks and flags definitions as for the above <br>' CertGetIssuerCertificateFromStore. <br>' <br>' If you are only checking CERT_STORE_TIME_VALIDITY_FLAG, then, the <br>' issuer can be NULL. <br>' <br>' For a verification check failure, SUCCESS is still returned. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' Duplicate a certificate context <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' Create a certificate context from the encoded certificate. The created <br>' context isn't put in a store. <br>' <br>' Makes a copy of the encoded certificate in the created context. <br>' <br>' If unable to decode and create the certificate context, NULL is returned. <br>' Otherwise, a pointer to a read only CERT_CONTEXT is returned. <br>' CERT_CONTEXT must be freed by calling CertFreeCertificateContext. <br>' CertDuplicateCertificateContext can be called to make a duplicate. <br>' <br>' CertSetCertificateContextProperty and CertGetCertificateContextProperty can be called <br>' to store properties for the certificate. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' Free a certificate context <br>' <br>' There needs to be a corresponding free for each context obtained by a <br>' get, find, duplicate or create. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' Set the property for the specified certificate context. <br>' <br>' The type definition for pvData depends on the dwPropId value. There are <br>' five predefined types: <br>' CERT_KEY_PROV_HANDLE_PROP_ID - a HCRYPTPROV for the certificate's <br>' private key is passed in pvData. Updates the hCryptProv field <br>' of the CERT_KEY_CONTEXT_PROP_ID. If the CERT_KEY_CONTEXT_PROP_ID <br>' doesn't exist, its created with all the other fields zeroed out. If <br>' CERT_STORE_NO_CRYPT_RELEASE_FLAG isn't set, HCRYPTPROV is implicitly <br>' released when either the property is set to NULL or on the final <br>' free of the CertContext. <br>' <br>' CERT_KEY_PROV_INFO_PROP_ID - a PCRYPT_KEY_PROV_INFO for the certificate's <br>' private key is passed in pvData. <br>' <br>' CERT_SHA1_HASH_PROP_ID - <br>' CERT_MD5_HASH_PROP_ID - normally, either property is implicitly <br>' set by doing a CertGetCertificateContextProperty. pvData points to a <br>' CRYPT_HASH_BLOB. <br>' <br>' CERT_KEY_CONTEXT_PROP_ID - a PCERT_KEY_CONTEXT for the certificate's <br>' private key is passed in pvData. The CERT_KEY_CONTEXT contains both the <br>' hCryptProv and dwKeySpec for the private key. <br>' See the CERT_KEY_PROV_HANDLE_PROP_ID for more information about <br>' the hCryptProv field and dwFlags settings. Note, more fields may <br>' be added for this property. The cbSize field value will be adjusted <br>' accordingly. <br>' <br>' CERT_KEY_SPEC_PROP_ID - the dwKeySpec for the private key. pvData <br>' points to a DWORD containing the KeySpec <br>' <br>' CERT_ENHKEY_USAGE_PROP_ID - enhanced key usage definition for the <br>' certificate. pvData points to a CRYPT_DATA_BLOB containing an <br>' <br>' CERT_NEXT_UPDATE_LOCATION_PROP_ID - location of the next update. <br>' Currently only applicable to CTLs. pvData points to a CRYPT_DATA_BLOB <br>' <br>' CERT_FRIENDLY_NAME_PROP_ID - friendly name for the cert, CRL or CTL. <br>' pvData points to a CRYPT_DATA_BLOB. pbData is a pointer to a NULL <br>' terminated unicode, wide character string. <br>' <br>' For all the other PROP_IDs: an encoded PCRYPT_DATA_BLOB is passed in pvData. <br>' <br>' If the property already exists, then, the old value is deleted and silently <br>' replaced. Setting, pvData to NULL, deletes the property. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' Get the property for the specified certificate context. <br>' <br>' For CERT_KEY_PROV_HANDLE_PROP_ID, pvData points to a HCRYPTPROV. <br>' <br>' For CERT_KEY_PROV_INFO_PROP_ID, pvData points to a CRYPT_KEY_PROV_INFO structure. <br>' Elements pointed to by fields in the pvData structure follow the <br>' structure. Therefore, *pcbData may exceed the size of the structure. <br>' <br>' For CERT_KEY_CONTEXT_PROP_ID, pvData points to a CERT_KEY_CONTEXT structure. <br>' <br>' For CERT_KEY_SPEC_PROP_ID, pvData points to a DWORD containing the KeySpec. <br>' If the CERT_KEY_CONTEXT_PROP_ID exists, the KeySpec is obtained from there. <br>' Otherwise, if the CERT_KEY_PROV_INFO_PROP_ID exists, its the source <br>' of the KeySpec. <br>' <br>' For CERT_SHA1_HASH_PROP_ID or CERT_MD5_HASH_PROP_ID, if the hash <br>' and then set. pvData points to the computed hash. Normally, the length <br>' is 20 bytes for SHA and 16 for MD5. <br>' <br>' For all other PROP_IDs, pvData points to an encoded array of bytes. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' Enumerate the properties for the specified certificate context. <br>' <br>' To get the first property, set dwPropId to 0. The ID of the first <br>' property is returned. To get the next property, set dwPropId to the <br>' ID returned by the last call. To enumerate all the properties continue <br>' until 0 is returned. <br>' <br>' CertGetCertificateContextProperty is called to get the property's data. <br>' <br>' Note, since, the CERT_KEY_PROV_HANDLE_PROP_ID and CERT_KEY_SPEC_PROP_ID <br>' properties are stored as fields in the CERT_KEY_CONTEXT_PROP_ID <br>' property, they aren't enumerated individually. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' Get the first or next CRL context from the store for the specified <br>' issuer certificate. Perform the enabled verification checks on the CRL. <br>' <br>' If the first or next CRL isn't found, NULL is returned. <br>' Otherwise, a pointer to a read only CRL_CONTEXT is returned. CRL_CONTEXT <br>' must be freed by calling CertFreeCRLContext. However, the free must be <br>' pPrevCrlContext on a subsequent call. CertDuplicateCRLContext <br>' can be called to make a duplicate. <br>' <br>' The pIssuerContext may have been obtained from this store, another store <br>' or created by the caller application. When created by the caller, the <br>' CertCreateCertificateContext function must have been called. <br>' <br>' If pIssuerContext == NULL, finds all the CRLs in the store. <br>' <br>' An issuer may have multiple CRLs. For example, it generates delta CRLs <br>' using a X.509 v3 extension. pPrevCrlContext MUST BE NULL on the first <br>' call to get the CRL. To get the next CRL for the issuer, the <br>' pPrevCrlContext is set to the CRL_CONTEXT returned by a previous call. <br>' <br>' NOTE: a NON-NULL pPrevCrlContext is always CertFreeCRLContext'ed by <br>' this function, even for an error. <br>' <br>' The following flags can be set in *pdwFlags to enable verification checks <br>' on the returned CRL: <br>' CERT_STORE_SIGNATURE_FLAG - use the public key in the <br>' issuer's certificate to verify the <br>' signature on the returned CRL. <br>' Note, if pIssuerContext-&gt;hCertStore == <br>' hCertStore, the store provider might <br>' be able to eliminate a redo of <br>' the signature verify. <br>' CERT_STORE_TIME_VALIDITY_FLAG - get the current time and verify that <br>' its within the CRL's ThisUpdate and <br>' NextUpdate validity period. <br>' <br>' If an enabled verification check fails, then, its flag is set upon return. <br>' <br>' If pIssuerContext == NULL, then, an enabled CERT_STORE_SIGNATURE_FLAG <br>' always fails and the CERT_STORE_NO_ISSUER_FLAG is also set. <br>' <br>' For a verification check failure, a pointer to the first or next <br>' CRL_CONTEXT is still returned and SetLastError isn't updated. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' Duplicate a CRL context <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' Create a CRL context from the encoded CRL. The created <br>' context isn't put in a store. <br>' <br>' Makes a copy of the encoded CRL in the created context. <br>' <br>' If unable to decode and create the CRL context, NULL is returned. <br>' Otherwise, a pointer to a read only CRL_CONTEXT is returned. <br>' CRL_CONTEXT must be freed by calling CertFreeCRLContext. <br>' CertDuplicateCRLContext can be called to make a duplicate. <br>' <br>' CertSetCRLContextProperty and CertGetCRLContextProperty can be called <br>' to store properties for the CRL. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' Free a CRL context <br>' <br>' There needs to be a corresponding free for each context obtained by a <br>' get, duplicate or create. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' Set the property for the specified CRL context. <br>' <br>' Same Property Ids and semantics as CertSetCertificateContextProperty. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' Get the property for the specified CRL context. <br>' <br>' Same Property Ids and semantics as CertGetCertificateContextProperty. <br>' <br>' CERT_SHA1_HASH_PROP_ID or CERT_MD5_HASH_PROP_ID is the predefined <br>' property of most interest. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' Enumerate the properties for the specified CRL context. <br>' <br>' To get the first property, set dwPropId to 0. The ID of the first <br>' property is returned. To get the next property, set dwPropId to the <br>' ID returned by the last call. To enumerate all the properties continue <br>' until 0 is returned. <br>' <br>' CertGetCRLContextProperty is called to get the property's data. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' Add certificate/CRL, encoded, context or element disposition values. <br>'-------------------------------------------------------------------------- <br>Public Const CERT_STORE_ADD_NEW As Long = 1 <br>Public Const CERT_STORE_ADD_USE_EXISTING As Long = 2 <br>Public Const CERT_STORE_ADD_REPLACE_EXISTING As Long = 3 <br>Public Const CERT_STORE_ADD_ALWAYS As Long = 4 <br>'+------------------------------------------------------------------------- <br>' Add the encoded certificate to the store according to the specified <br>' disposition action. <br>' <br>' Makes a copy of the encoded certificate before adding to the store. <br>' <br>' dwAddDispostion specifies the action to take if the certificate <br>' already exists in the store. This parameter must be one of the following <br>' values: <br>' CERT_STORE_ADD_NEW <br>' Fails if the certificate already exists in the store. LastError <br>' is set to CRYPT_E_EXISTS. <br>' CERT_STORE_ADD_USE_EXISTING <br>' If the certifcate already exists, then, its used and if ppCertContext <br>' is non-NULL, the existing context is duplicated. <br>' CERT_STORE_ADD_REPLACE_EXISTING <br>' If the certificate already exists, then, the existing certificate <br>' context is deleted before creating and adding the new context. <br>' CERT_STORE_ADD_ALWAYS <br>' No check is made to see if the certificate already exists. A <br>' new certificate context is always created. This may lead to <br>' duplicates in the store. <br>' <br>' CertGetSubjectCertificateFromStore is called to determine if the <br>' certificate already exists in the store. <br>' <br>' ppCertContext can be NULL, indicating the caller isn't interested <br>' in getting the CERT_CONTEXT of the added or existing certificate. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' Add the certificate context to the store according to the specified <br>' disposition action. <br>' <br>' In addition to the encoded certificate, the context's properties are <br>' CERT_KEY_PROV_HANDLE_PROP_ID or CERT_KEY_SPEC_PROP_ID) isn't copied. <br>' <br>' Makes a copy of the certificate context before adding to the store. <br>' <br>' dwAddDispostion specifies the action to take if the certificate <br>' already exists in the store. This parameter must be one of the following <br>' values: <br>' CERT_STORE_ADD_NEW <br>' Fails if the certificate already exists in the store. LastError <br>' is set to CRYPT_E_EXISTS. <br>' CERT_STORE_ADD_USE_EXISTING <br>' If the certifcate already exists, then, its used and if ppStoreContext <br>' is non-NULL, the existing context is duplicated. Iterates <br>' through pCertContext's properties and only copies the properties <br>' that don't already exist. The SHA1 and MD5 hash properties aren't <br>' copied. <br>' CERT_STORE_ADD_REPLACE_EXISTING <br>' If the certificate already exists, then, the existing certificate <br>' context is deleted before creating and adding a new context. <br>' Properties are copied before doing the add. <br>' CERT_STORE_ADD_ALWAYS <br>' No check is made to see if the certificate already exists. A <br>' new certificate context is always created and added. This may lead to <br>' duplicates in the store. Properties are <br>' copied before doing the add. <br>' <br>' CertGetSubjectCertificateFromStore is called to determine if the <br>' certificate already exists in the store. <br>' <br>' ppStoreContext can be NULL, indicating the caller isn't interested <br>' in getting the CERT_CONTEXT of the added or existing certificate. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' Certificate Store Context Types <br>'-------------------------------------------------------------------------- <br>Public Const CERT_STORE_CERTIFICATE_CONTEXT As Long = 1 <br>Public Const CERT_STORE_CRL_CONTEXT As Long = 2 <br>Public Const CERT_STORE_CTL_CONTEXT As Long = 3 <br>'+------------------------------------------------------------------------- <br>' Certificate Store Context Bit Flags <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' Add the serialized certificate or CRL element to the store. <br>' <br>' The serialized element contains the encoded certificate, CRL or CTL and <br>' its properties, such as, CERT_KEY_PROV_INFO_PROP_ID. <br>' <br>' If hCertStore is NULL, creates a certificate, CRL or CTL context not <br>' residing in any store. <br>' <br>' dwAddDispostion specifies the action to take if the certificate or CRL <br>' already exists in the store. See CertAddCertificateContextToStore for a </code></pre>
<p>
</p>
<pre><code>' list of and actions taken. <br>' <br>' dwFlags currently isn't used and should be set to 0. <br>' <br>' dwContextTypeFlags specifies the set of allowable contexts. For example, to <br>' add either a certificate or CRL, set dwContextTypeFlags to: <br>' CERT_STORE_CERTIFICATE_CONTEXT_FLAG | CERT_STORE_CRL_CONTEXT_FLAG <br>' <br>' *pdwContextType is updated with the type of the context returned in <br>' *ppvContxt. pdwContextType or ppvContext can be NULL, indicating the <br>' caller isn't interested in getting the output. If *ppvContext is <br>' returned it must be freed by calling CertFreeCertificateContext or <br>' CertFreeCRLContext. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' Delete the specified certificate from the store. <br>' <br>' All subsequent gets or finds for the certificate will fail. However, <br>' memory allocated for the certificate isn't freed until all of its contexts <br>' have also been freed. <br>' <br>' The pCertContext is obtained from a get, enum, find or duplicate. <br>' <br>' Some store provider implementations might also delete the issuer's CRLs <br>' if this is the last certificate for the issuer in the store. <br>' <br>' NOTE: the pCertContext is always CertFreeCertificateContext'ed by <br>' this function, even for an error. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' Add the encoded CRL to the store according to the specified <br>' disposition option. <br>' <br>' Makes a copy of the encoded CRL before adding to the store. <br>' <br>' dwAddDispostion specifies the action to take if the CRL <br>' already exists in the store. See CertAddEncodedCertificateToStore for a <br>' list of and actions taken. <br>' <br>' Compares the CRL's Issuer to determine if the CRL already exists in the <br>' store. <br>' <br>' ppCrlContext can be NULL, indicating the caller isn't interested <br>' in getting the CRL_CONTEXT of the added or existing CRL. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' Add the CRL context to the store according to the specified <br>' disposition option. <br>' <br>' In addition to the encoded CRL, the context's properties are <br>' CERT_KEY_PROV_HANDLE_PROP_ID or CERT_KEY_SPEC_PROP_ID) isn't copied. <br>' <br>' Makes a copy of the encoded CRL before adding to the store. <br>' <br>' dwAddDispostion specifies the action to take if the CRL <br>' already exists in the store. See CertAddCertificateContextToStore for a <br>' list of and actions taken. <br>' <br>' Compares the CRL's Issuer, ThisUpdate and NextUpdate to determine <br>' if the CRL already exists in the store. <br>' <br>' ppStoreContext can be NULL, indicating the caller isn't interested <br>' in getting the CRL_CONTEXT of the added or existing CRL. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' Delete the specified CRL from the store. <br>' <br>' All subsequent gets for the CRL will fail. However, <br>' memory allocated for the CRL isn't freed until all of its contexts <br>' have also been freed. <br>' <br>' The pCrlContext is obtained from a get or duplicate. <br>' <br>' NOTE: the pCrlContext is always CertFreeCRLContext'ed by <br>' this function, even for an error. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' Serialize the certificate context's encoded certificate and its <br>' properties. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' Serialize the CRL context's encoded CRL and its properties. <br>'-------------------------------------------------------------------------- <br>'+========================================================================= <br>'========================================================================== <br>'+------------------------------------------------------------------------- <br>' Duplicate a CTL context <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' Create a CTL context from the encoded CTL. The created <br>' context isn't put in a store. <br>' <br>' Makes a copy of the encoded CTL in the created context. <br>' <br>' If unable to decode and create the CTL context, NULL is returned. <br>' Otherwise, a pointer to a read only CTL_CONTEXT is returned. <br>' CTL_CONTEXT must be freed by calling CertFreeCTLContext. <br>' CertDuplicateCTLContext can be called to make a duplicate. <br>' <br>' CertSetCTLContextProperty and CertGetCTLContextProperty can be called <br>' to store properties for the CTL. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' Free a CTL context <br>' <br>' There needs to be a corresponding free for each context obtained by a <br>' get, duplicate or create. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' Set the property for the specified CTL context. <br>' <br>' Same Property Ids and semantics as CertSetCertificateContextProperty. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' Get the property for the specified CTL context. <br>' <br>' Same Property Ids and semantics as CertGetCertificateContextProperty. <br>' <br>' CERT_SHA1_HASH_PROP_ID or CERT_NEXT_UPDATE_LOCATION_PROP_ID are the <br>' predefined properties of most interest. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' Enumerate the properties for the specified CTL context. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' Enumerate the CTL contexts in the store. <br>' <br>' If a CTL isn't found, NULL is returned. <br>' Otherwise, a pointer to a read only CTL_CONTEXT is returned. CTL_CONTEXT <br>' must be freed by calling CertFreeCTLContext or is freed when passed as the <br>' pPrevCtlContext on a subsequent call. CertDuplicateCTLContext <br>' can be called to make a duplicate. <br>' <br>' pPrevCtlContext MUST BE NULL to enumerate the first <br>' CTL in the store. Successive CTLs are enumerated by setting <br>' pPrevCtlContext to the CTL_CONTEXT returned by a previous call. <br>' <br>' NOTE: a NON-NULL pPrevCtlContext is always CertFreeCTLContext'ed by <br>' this function, even for an error. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' Attempt to find the specified subject in the CTL. <br>' <br>' For CTL_CERT_SUBJECT_TYPE, pvSubject points to a CERT_CONTEXT. The CTL's <br>' SubjectAlgorithm is examined to determine the representation of the <br>' subject's identity. Initially, only SHA1 or MD5 hash will be supported. <br>' The appropriate hash property is obtained from the CERT_CONTEXT. <br>' <br>' For CTL_ANY_SUBJECT_TYPE, pvSubject points to the CTL_ANY_SUBJECT_INFO <br>' structure which contains the SubjectAlgorithm to be matched in the CTL <br>' and the SubjectIdentifer to be matched in one of the CTL entries. <br>' <br>' The certificate's hash or the CTL_ANY_SUBJECT_INFO's SubjectIdentifier <br>' is used as the key in searching the subject entries. A binary <br>' memory comparison is done between the key and the entry's SubjectIdentifer. <br>' <br>' dwEncodingType isn't used for either of the above SubjectTypes. <br>'-------------------------------------------------------------------------- <br>' Subject Types: <br>' CTL_ANY_SUBJECT_TYPE, pvSubject points to following CTL_ANY_SUBJECT_INFO. <br>' CTL_CERT_SUBJECT_TYPE, pvSubject points to CERT_CONTEXT. <br>Public Const CTL_ANY_SUBJECT_TYPE As Long = 1 <br>Public Const CTL_CERT_SUBJECT_TYPE As Long = 2 <br>'+------------------------------------------------------------------------- <br>' Find the first or next CTL context in the store. <br>' <br>' The CTL is found according to the dwFindType and its pvFindPara. <br>' See below for a list of the find types and its parameters. <br>' <br>' Currently dwFindFlags isn't used and must be set to 0. <br>' <br>' Usage of dwMsgAndCertEncodingType depends on the dwFindType. <br>' <br>' If the first or next CTL isn't found, NULL is returned. <br>' Otherwise, a pointer to a read only CTL_CONTEXT is returned. CTL_CONTEXT <br>' must be freed by calling CertFreeCTLContext or is freed when passed as the <br>' pPrevCtlContext on a subsequent call. CertDuplicateCTLContext <br>' can be called to make a duplicate. <br>' <br>' pPrevCtlContext MUST BE NULL on the first <br>' call to find the CTL. To find the next CTL, the <br>' pPrevCtlContext is set to the CTL_CONTEXT returned by a previous call. <br>' <br>' NOTE: a NON-NULL pPrevCtlContext is always CertFreeCTLContext'ed by <br>' this function, even for an error. <br>'-------------------------------------------------------------------------- <br>Public Const CTL_FIND_ANY As Long = 0 <br>Public Const CTL_FIND_SHA1_HASH As Long = 1 <br>Public Const CTL_FIND_MD5_HASH As Long = 2 <br>Public Const CTL_FIND_USAGE As Long = 3 <br>Public Const CTL_FIND_SUBJECT As Long = 4 <br>Public Const CTL_FIND_NO_LIST_ID_CBDATA As Long = &amp;HFFFFFFFF <br>Public Const CTL_FIND_SAME_USAGE_FLAG As Long = &amp;H1 <br>'+------------------------------------------------------------------------- <br>' CTL_FIND_ANY <br>' <br>' Find any CTL. <br>' <br>' pvFindPara isn't used. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' CTL_FIND_SHA1_HASH <br>' CTL_FIND_MD5_HASH <br>' <br>' Find a CTL with the specified hash. <br>' <br>' pvFindPara points to a CRYPT_HASH_BLOB. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' CTL_FIND_USAGE <br>' <br>' Find a CTL having the specified usage identifiers, list identifier or <br>' signer. The CertEncodingType of the signer is obtained from the <br>' dwMsgAndCertEncodingType parameter. <br>' <br>' pvFindPara points to a CTL_FIND_USAGE_PARA data structure. The <br>' SubjectUsage.cUsageIdentifer can be 0 to match any usage. The <br>' ListIdentifier.cbData can be 0 to match any list identifier. To only match <br>' CTLs without a ListIdentifier, cbData must be set to <br>' CTL_FIND_NO_LIST_ID_CBDATA. pSigner can be NULL to match any signer. Only <br>' the Issuer and SerialNumber fields of the pSigner's PCERT_INFO are used. <br>' To only match CTLs without a signer, pSigner must be set to <br>' CTL_FIND_NO_SIGNER_PTR. <br>' <br>' The CTL_FIND_SAME_USAGE_FLAG can be set in dwFindFlags to <br>' only match CTLs with the same usage identifiers. CTLs having additional <br>' usage identifiers aren't matched. For example, if only "1.2.3" is specified <br>' in CTL_FIND_USAGE_PARA, then, for a match, the CTL must only contain <br>' "1.2.3" and not any additional usage identifers. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' CTL_FIND_SUBJECT <br>' <br>' Find a CTL having the specified subject. CertFindSubjectInCTL can be <br>' called to get a pointer to the subject's entry in the CTL. pUsagePara can <br>' optionally be set to enable the above CTL_FIND_USAGE matching. <br>' <br>' pvFindPara points to a CTL_FIND_SUBJECT_PARA data structure. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' Add the encoded CTL to the store according to the specified <br>' disposition option. <br>' <br>' Makes a copy of the encoded CTL before adding to the store. <br>' <br>' dwAddDispostion specifies the action to take if the CTL <br>' already exists in the store. See CertAddEncodedCertificateToStore for a <br>' list of and actions taken. <br>' <br>' Compares the CTL's SubjectUsage, ListIdentifier and any of its signers <br>' to determine if the CTL already exists in the store. <br>' <br>' ppCtlContext can be NULL, indicating the caller isn't interested <br>' in getting the CTL_CONTEXT of the added or existing CTL. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' Add the CTL context to the store according to the specified <br>' disposition option. <br>' <br>' In addition to the encoded CTL, the context's properties are <br>' CERT_KEY_PROV_HANDLE_PROP_ID or CERT_KEY_SPEC_PROP_ID) isn't copied. <br>' <br>' Makes a copy of the encoded CTL before adding to the store. <br>' <br>' dwAddDispostion specifies the action to take if the CTL <br>' already exists in the store. See CertAddCertificateContextToStore for a <br>' list of and actions taken. <br>' <br>' Compares the CTL's SubjectUsage, ListIdentifier and any of its signers <br>' to determine if the CTL already exists in the store. <br>' <br>' ppStoreContext can be NULL, indicating the caller isn't interested <br>' in getting the CTL_CONTEXT of the added or existing CTL. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' Serialize the CTL context's encoded CTL and its properties. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' Delete the specified CTL from the store. <br>' <br>' All subsequent gets for the CTL will fail. However, <br>' memory allocated for the CTL isn't freed until all of its contexts <br>' have also been freed. <br>' <br>' The pCtlContext is obtained from a get or duplicate. <br>' <br>' NOTE: the pCtlContext is always CertFreeCTLContext'ed by <br>' this function, even for an error. <br>'-------------------------------------------------------------------------- <br>'+========================================================================= <br>' Enhanced Key Usage Helper Functions <br>'========================================================================== <br>'+------------------------------------------------------------------------- <br>' Get the enhanced key usage extension or property from the certificate <br>' and decode. <br>' <br>' If the CERT_FIND_EXT_ONLY_ENHKEY_USAGE_FLAG is set, then, only get the <br>' extension. <br>' <br>' If the CERT_FIND_PROP_ONLY_ENHKEY_USAGE_FLAG is set, then, only get the <br>' property. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' Set the enhanced key usage property for the certificate. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' Add the usage identifier to the certificate's enhanced key usage property. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' Remove the usage identifier from the certificate's enhanced key usage <br>' property. <br>'-------------------------------------------------------------------------- <br>'+========================================================================= <br>' Cryptographic Message helper functions for verifying and signing a <br>' CTL. <br>'========================================================================== <br>'+------------------------------------------------------------------------- <br>' Get and verify the signer of a cryptographic message. <br>' <br>' To verify a CTL, the hCryptMsg is obtained from the CTL_CONTEXT's <br>' hCryptMsg field. <br>' <br>' If CMSG_TRUSTED_SIGNER_FLAG is set, then, treat the Signer stores as being <br>' trusted and only search them to find the certificate corresponding to the <br>' signer's issuer and serial number. Otherwise, the SignerStores are <br>' optionally provided to supplement the message's store of certificates. <br>' If a signer certificate is found, its public key is used to verify <br>' the message signature. The CMSG_SIGNER_ONLY_FLAG can be set to <br>' return the signer without doing the signature verify. <br>' <br>' If CMSG_USE_SIGNER_INDEX_FLAG is set, then, only get the signer specified <br>' by *pdwSignerIndex. Otherwise, iterate through all the signers <br>' until a signer verifies or no more signers. <br>' <br>' For a verified signature, *ppSigner is updated with certificate context <br>' of the signer and *pdwSignerIndex is updated with the index of the signer. <br>' ppSigner and/or pdwSignerIndex can be NULL, indicating the caller isn't <br>' interested in getting the CertContext and/or index of the signer. <br>'-------------------------------------------------------------------------- <br>Public Const CMSG_TRUSTED_SIGNER_FLAG As Long = &amp;H1 <br>Public Const CMSG_SIGNER_ONLY_FLAG As Long = &amp;H2 <br>Public Const CMSG_USE_SIGNER_INDEX_FLAG As Long = &amp;H4 <br>'+------------------------------------------------------------------------- <br>' Sign an encoded CTL. <br>' <br>' The pbCtlContent can be obtained via a CTL_CONTEXT's pbCtlContent <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' Encode the CTL and create a signed message containing the encoded CTL. <br>'-------------------------------------------------------------------------- <br>'+========================================================================= <br>' Certificate Verify CTL Usage Data Structures and APIs <br>'========================================================================== <br>Public Const CERT_VERIFY_INHIBIT_CTL_UPDATE_FLAG As Long = &amp;H1 <br>Public Const CERT_VERIFY_TRUSTED_SIGNERS_FLAG As Long = &amp;H2 <br>Public Const CERT_VERIFY_NO_TIME_CHECK_FLAG As Long = &amp;H4 <br>Public Const CERT_VERIFY_ALLOW_MORE_USAGE_FLAG As Long = &amp;H8 <br>Public Const CERT_VERIFY_UPDATED_CTL_FLAG As Long = &amp;H1 <br>'+------------------------------------------------------------------------- <br>' Verify that a subject is trusted for the specified usage by finding a <br>' signed and time valid CTL with the usage identifiers and containing the <br>' the subject. A subject can be identified by either its certificate context <br>' or any identifier such as its SHA1 hash. <br>' <br>' See CertFindSubjectInCTL for definition of dwSubjectType and pvSubject <br>' parameters. <br>' <br>' Via pVerifyUsagePara, the caller can specify the stores to be searched <br>' to find the CTL. The caller can also specify the stores containing <br>' acceptable CTL signers. By setting the ListIdentifier, the caller <br>' can also restrict to a particular signer CTL list. <br>' <br>' Via pVerifyUsageStatus, the CTL containing the subject, the subject's <br>' index into the CTL's array of entries, and the signer of the CTL <br>' are returned. If the caller is not interested, ppCtl and ppSigner can be set <br>' to NULL. Returned contexts must be freed via the store's free context APIs. <br>' <br>' If the CERT_VERIFY_INHIBIT_CTL_UPDATE_FLAG isn't set, then, a time <br>' invalid CTL in one of the CtlStores may be replaced. When replaced, the <br>' CERT_VERIFY_UPDATED_CTL_FLAG is set in pVerifyUsageStatus-&gt;dwFlags. <br>' <br>' If the CERT_VERIFY_TRUSTED_SIGNERS_FLAG is set, then, only the <br>' SignerStores specified in pVerifyUsageStatus are searched to find <br>' the signer. Otherwise, the SignerStores provide additional sources <br>' to find the signer's certificate. <br>' <br>' If CERT_VERIFY_NO_TIME_CHECK_FLAG is set, then, the CTLs aren't checked <br>' for time validity. <br>' <br>' If CERT_VERIFY_ALLOW_MORE_USAGE_FLAG is set, then, the CTL may contain <br>' additional usage identifiers than specified by pSubjectUsage. Otherwise, <br>' the found CTL will contain the same usage identifers and no more. <br>' <br>' CertVerifyCTLUsage will be implemented as a dispatcher to OID installable <br>' functions. First, it will try to find an OID function matching the first <br>' usage object identifier in the pUsage sequence. Next, it will dispatch <br>' to the default CertDllVerifyCTLUsage functions. <br>' <br>' If the subject is trusted for the specified usage, then, TRUE is <br>' returned. Otherwise, FALSE is returned with dwError set to one of the <br>' following: <br>' CRYPT_E_NO_VERIFY_USAGE_DLL <br>' CRYPT_E_NO_VERIFY_USAGE_CHECK <br>' CRYPT_E_VERIFY_USAGE_OFFLINE <br>' CRYPT_E_NOT_IN_CTL <br>' CRYPT_E_NO_TRUSTED_SIGNER <br>'-------------------------------------------------------------------------- <br>'+========================================================================= <br>' Certificate Revocation Data Structures and APIs <br>'========================================================================== <br>'+------------------------------------------------------------------------- <br>' The following data structure may be passed to CertVerifyRevocation to <br>' assist in finding the issuer of the context to be verified. <br>' <br>' When pIssuerCert is specified, pIssuerCert is the issuer of <br>' rgpvContext[cContext - 1]. <br>' <br>' When cCertStore and rgCertStore are specified, these stores may contain <br>' an issuer certificate. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' The following data structure is returned by CertVerifyRevocation to <br>' specify the status of the revoked or unchecked context. Review the <br>' following CertVerifyRevocation comments for details. <br>' <br>' Upon input to CertVerifyRevocation, cbSize must be set to a size <br>' returns FALSE and sets LastError to E_INVALIDARG. <br>' <br>' Upon input to the installed or registered CRYPT_OID_VERIFY_REVOCATION_FUNC <br>' functions, the dwIndex, dwError and dwReason have been zero'ed. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' Verifies the array of contexts for revocation. The dwRevType parameter <br>' indicates the type of the context data structure passed in rgpvContext. <br>' Currently only the revocation of certificates is defined. <br>' <br>' If the CERT_VERIFY_REV_CHAIN_FLAG flag is set, then, CertVerifyRevocation <br>' is verifying a chain of certs where, rgpvContext[i + 1] is the issuer <br>' of rgpvContext[i]. Otherwise, CertVerifyRevocation makes no assumptions <br>' about the order of the contexts. <br>' <br>' To assist in finding the issuer, the pRevPara may optionally be set. See <br>' the CERT_REVOCATION_PARA data structure for details. <br>' <br>' The contexts must contain enough information to allow the <br>' installable or registered revocation DLLs to find the revocation server. For <br>' certificates, this information would normally be conveyed in an <br>' extension such as the IETF's AuthorityInfoAccess extension. <br>' <br>' CertVerifyRevocation returns TRUE if all of the contexts were successfully <br>' checked and none were revoked. Otherwise, returns FALSE and updates the <br>' returned pRevStatus data structure as follows: <br>' dwIndex <br>' Index of the first context that was revoked or unable to <br>' be checked for revocation <br>' dwError <br>' Error status. LastError is also set to this error status. <br>' dwError can be set to one of the following error codes defined <br>' in winerror.h: <br>' ERROR_SUCCESS - good context <br>' CRYPT_E_REVOKED - context was revoked. dwReason contains the <br>' reason for revocation <br>' CRYPT_E_REVOCATION_OFFLINE - unable to connect to the <br>' revocation server <br>' CRYPT_E_NOT_IN_REVOCATION_DATABASE - the context to be checked <br>' was not found in the revocation server's database. <br>' CRYPT_E_NO_REVOCATION_CHECK - the called revocation function <br>' wasn't able to do a revocation check on the context <br>' CRYPT_E_NO_REVOCATION_DLL - no installed or registered Dll was <br>' found to verify revocation <br>' dwReason <br>' The dwReason is currently only set for CRYPT_E_REVOKED and contains <br>' the reason why the context was revoked. May be one of the following <br>' CRL_REASON_UNSPECIFIED 0 <br>' CRL_REASON_KEY_COMPROMISE 1 <br>' CRL_REASON_CA_COMPROMISE 2 <br>' CRL_REASON_AFFILIATION_CHANGED 3 <br>' CRL_REASON_SUPERSEDED 4 <br>' CRL_REASON_CESSATION_OF_OPERATION 5 <br>' CRL_REASON_CERTIFICATE_HOLD 6 <br>' <br>' For each entry in rgpvContext, CertVerifyRevocation iterates <br>' through the CRYPT_OID_VERIFY_REVOCATION_FUNC <br>' function set's list of installed DEFAULT functions. <br>' CryptGetDefaultOIDFunctionAddress is called with pwszDll = NULL. If no <br>' installed functions are found capable of doing the revocation verification, <br>' CryptVerifyRevocation iterates through CRYPT_OID_VERIFY_REVOCATION_FUNC's <br>' list of registered DEFAULT Dlls. CryptGetDefaultOIDDllList is called to <br>' get the list. CryptGetDefaultOIDFunctionAddress is called to load the Dll. <br>' <br>' The called functions have the same signature as CertVerifyRevocation. A <br>' called function returns TRUE if it was able to successfully check all of <br>' the contexts and none were revoked. Otherwise, the called function returns <br>' FALSE and updates pRevStatus. dwIndex is set to the index of <br>' the first context that was found to be revoked or unable to be checked. <br>' dwError and LastError are updated. For CRYPT_E_REVOKED, dwReason <br>' is updated. Upon input to the called function, dwIndex, dwError and <br>' dwReason have been zero'ed. cbSize has been checked to be &gt;= <br>' <br>' If the called function returns FALSE, and dwError isn't set to <br>' CRYPT_E_REVOKED, then, CertVerifyRevocation either continues on to the <br>' next DLL in the list for a returned dwIndex of 0 or for a returned <br>' dwIndex &gt; 0, restarts the process of finding a verify function by <br>' advancing the start of the context array to the returned dwIndex and <br>' decrementing the count of remaining contexts. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' Revocation types <br>'-------------------------------------------------------------------------- <br>Public Const CERT_CONTEXT_REVOCATION_TYPE As Long = 1 <br>'+------------------------------------------------------------------------- <br>' When the following flag is set, rgpvContext[] consists of a chain <br>' of certificates, where rgpvContext[i + 1] is the issuer of rgpvContext[i]. <br>'-------------------------------------------------------------------------- <br>Public Const CERT_VERIFY_REV_CHAIN_FLAG As Long = &amp;H1 <br>'+------------------------------------------------------------------------- <br>' CERT_CONTEXT_REVOCATION_TYPE <br>' <br>' pvContext points to a const CERT_CONTEXT. <br>'-------------------------------------------------------------------------- <br>'+========================================================================= <br>' Certificate Helper APIs <br>'========================================================================== <br>'+------------------------------------------------------------------------- <br>' Compare two multiple byte integer blobs to see if they are identical. <br>' <br>' Before doing the comparison, leading zero bytes are removed from a <br>' positive number and leading 0xFF bytes are removed from a negative <br>' number. <br>' <br>' The multiple byte integers are treated as Little Endian. pbData[0] is the <br>' least significant byte and pbData[cbData - 1] is the most significant <br>' byte. <br>' <br>' Returns TRUE if the integer blobs are identical after removing leading <br>' 0 or 0xFF bytes. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' Compare two certificates to see if they are identical. <br>' <br>' Since a certificate is uniquely identified by its Issuer and SerialNumber, <br>' these are the only fields needing to be compared. <br>' <br>' Returns TRUE if the certificates are identical. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' Compare two certificate names to see if they are identical. <br>' <br>' Returns TRUE if the names are identical. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' Compare the attributes in the certificate name with the specified <br>' The comparison iterates through the CERT_RDN attributes and looks for an <br>' attribute match in any of the certificate name's RDNs. <br>' Returns TRUE if all the attributes are found and match. <br>' <br>' The CERT_RDN_ATTR fields can have the following special values: <br>' pszObjId == NULL - ignore the attribute object identifier <br>' dwValueType == RDN_ANY_TYPE - ignore the value type <br>' <br>' Currently only an exact, case sensitive match is supported. <br>' <br>' CERT_UNICODE_IS_RDN_ATTRS_FLAG should be set if the pRDN was initialized <br>'-------------------------------------------------------------------------- <br>Public Const CERT_UNICODE_IS_RDN_ATTRS_FLAG As Long = &amp;H1 <br>'+------------------------------------------------------------------------- <br>' Compare two public keys to see if they are identical. <br>' <br>' Returns TRUE if the keys are identical. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' Verify the signature of a subject certificate or a CRL using the <br>' public key info <br>' <br>' Returns TRUE for a valid signature. <br>' <br>' hCryptProv specifies the crypto provider to use to verify the signature. <br>' It doesn't need to use a private key. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' Compute the hash of the "to be signed" information in the encoded <br>' <br>' hCryptProv specifies the crypto provider to use to compute the hash. <br>' It doesn't need to use a private key. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' Hash the encoded content. <br>' <br>' hCryptProv specifies the crypto provider to use to compute the hash. <br>' It doesn't need to use a private key. <br>' <br>' Algid specifies the CAPI hash algorithm to use. If Algid is 0, then, the <br>'-------------------------------------------------------------------------- </code></pre>
<p>
</p>
<pre><code>'+------------------------------------------------------------------------- <br>' Sign the "to be signed" information in the encoded signed content. <br>' <br>' hCryptProv specifies the crypto provider to use to do the signature. <br>' It uses the specified private key. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' Encode the "to be signed" information. Sign the encoded "to be signed". <br>' Encode the "to be signed" and the signature. <br>' <br>' hCryptProv specifies the crypto provider to use to do the signature. <br>' It uses the specified private key. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' Verify the time validity of a certificate. <br>' <br>' Returns -1 if before NotBefore, +1 if after NotAfter and otherwise 0 for <br>' a valid certificate <br>' <br>' If pTimeToVerify is NULL, uses the current time. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' Verify the time validity of a CRL. <br>' <br>' Returns -1 if before ThisUpdate, +1 if after NextUpdate and otherwise 0 for <br>' a valid CRL <br>' <br>' If pTimeToVerify is NULL, uses the current time. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' Verify that the subject's time validity nests within the issuer's time <br>' validity. <br>' <br>' Returns TRUE if it nests. Otherwise, returns FALSE. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' Verify that the subject certificate isn't on its issuer CRL. <br>' <br>' Returns true if the certificate isn't on the CRL. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' Convert the CAPI AlgId to the ASN.1 Object Identifier string <br>' <br>' Returns NULL if there isn't an ObjId corresponding to the AlgId. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' Convert the ASN.1 Object Identifier string to the CAPI AlgId. <br>' <br>' Returns 0 if there isn't an AlgId corresponding to the ObjId. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' Find an extension identified by its Object Identifier. <br>' <br>' If found, returns pointer to the extension. Otherwise, returns NULL. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' Find the first attribute identified by its Object Identifier. <br>' <br>' If found, returns pointer to the attribute. Otherwise, returns NULL. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' Find the first CERT_RDN attribute identified by its Object Identifier in <br>' the name's list of Relative Distinguished Names. <br>' <br>' If found, returns pointer to the attribute. Otherwise, returns NULL. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' Get the intended key usage bytes from the certificate. <br>' <br>' If the certificate doesn't have any intended key usage bytes, returns FALSE <br>' and *pbKeyUsage is zeroed. Otherwise, returns TRUE and up through <br>' cbKeyUsage bytes are copied into *pbKeyUsage. Any remaining uncopied <br>' bytes are zeroed. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' Export the public key info associated with the provider's corresponding <br>' private key. <br>' <br>' Calls CryptExportPublicKeyInfo with pszPublicKeyObjId = szOID_RSA_RSA, <br>' dwFlags = 0 and pvAuxInfo = NULL. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' Export the public key info associated with the provider's corresponding <br>' private key. <br>' <br>' Uses the dwCertEncodingType and pszPublicKeyObjId to call the <br>' installable CRYPT_OID_EXPORT_PUBLIC_KEY_INFO_FUNC. The called function <br>' has the same signature as CryptExportPublicKeyInfoEx. <br>' <br>' If unable to find an installable OID function for the pszPublicKeyObjId, <br>' <br>' The dwFlags and pvAuxInfo aren't used for szOID_RSA_RSA. <br>'-------------------------------------------------------------------------- <br>Public Const CRYPT_OID_EXPORT_PUBLIC_KEY_INFO_FUNC As String = "CryptDllExportPublicKeyInfoEx" <br>'+------------------------------------------------------------------------- <br>' Convert and import the public key info into the provider and return a <br>' handle to the public key. <br>' <br>' Calls CryptImportPublicKeyInfoEx with aiKeyAlg = 0, dwFlags = 0 and <br>' pvAuxInfo = NULL. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' Convert and import the public key info into the provider and return a <br>' handle to the public key. <br>' <br>' Uses the dwCertEncodingType and pInfo-&gt;Algorithm.pszObjId to call the <br>' installable CRYPT_OID_IMPORT_PUBLIC_KEY_INFO_FUNC. The called function <br>' has the same signature as CryptImportPublicKeyInfoEx. <br>' <br>' If unable to find an installable OID function for the pszObjId, <br>' <br>' For szOID_RSA_RSA: aiKeyAlg may be set to CALG_RSA_SIGN or CALG_RSA_KEYX. <br>' Defaults to CALG_RSA_KEYX. The dwFlags and pvAuxInfo aren't used. <br>'-------------------------------------------------------------------------- <br>Public Const CRYPT_OID_IMPORT_PUBLIC_KEY_INFO_FUNC As String = "CryptDllImportPublicKeyInfoEx" <br>'+------------------------------------------------------------------------- <br>' Compute the hash of the encoded public key info. <br>' <br>' The public key info is encoded and then hashed. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' Convert a Name Value to a null terminated char string <br>' <br>' Returns the number of characters converted including the terminating null <br>' character. If psz is NULL or csz is 0, returns the required size of the <br>' <br>' If psz != NULL &amp;&amp; csz != 0, returned psz is always NULL terminated. <br>' <br>' Note: csz includes the NULL char. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' Convert a Name Value to a null terminated char string <br>' <br>' Returns the number of characters converted including the terminating null <br>' character. If psz is NULL or csz is 0, returns the required size of the <br>' <br>' If psz != NULL &amp;&amp; csz != 0, returned psz is always NULL terminated. <br>' <br>' Note: csz includes the NULL char. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' Convert the certificate name blob to a null terminated char string. <br>' <br>' Follows the string representation of distinguished names specified in <br>' empty strings and don't quote strings containing consecutive spaces). <br>' RDN values of type CERT_RDN_ENCODED_BLOB or CERT_RDN_OCTET_STRING are <br>' <br>' The name string is formatted according to the dwStrType: <br>' CERT_SIMPLE_NAME_STR <br>' The object identifiers are discarded. CERT_RDN entries are separated <br>' by ", ". Multiple attributes per CERT_RDN are separated by " + ". <br>' For example: <br>' Microsoft, Joe Cool + Programmer <br>' CERT_OID_NAME_STR <br>' The object identifiers are included with a "=" separator from their <br>' attribute value. CERT_RDN entries are separated by ", ". <br>' Multiple attributes per CERT_RDN are separated by " + ". For example: <br>' 2.5.4.11=Microsoft, 2.5.4.3=Joe Cool + 2.5.4.12=Programmer <br>' CERT_X500_NAME_STR <br>' The object identifiers are converted to their X500 key name. Otherwise, <br>' same as CERT_OID_NAME_STR. If the object identifier doesn't have <br>' a corresponding X500 key name, then, the object identifier is used with <br>' a "OID." prefix. For example: <br>' OU=Microsoft, CN=Joe Cool + T=Programmer, OID.1.2.3.4.5.6=Unknown <br>' <br>' We quote the RDN value if it contains leading or trailing whitespace <br>' or one of the following characters: ",", "+", "=", """, "\n", "&lt;", "&gt;", <br>' "#" or ";". The quoting character is ". If the the RDN Value contains <br>' OU=" Microsoft", CN="Joe ""Cool""" + T="Programmer, Manager" <br>' <br>' CERT_NAME_STR_SEMICOLON_FLAG can be or'ed into dwStrType to replace <br>' the ", " separator with a "; " separator. <br>' <br>' CERT_NAME_STR_CRLF_FLAG can be or'ed into dwStrType to replace <br>' the ", " separator with a "\r\n" separator. <br>' <br>' CERT_NAME_STR_NO_PLUS_FLAG can be or'ed into dwStrType to replace the <br>' " + " separator with a single space, " ". <br>' <br>' CERT_NAME_STR_NO_QUOTING_FLAG can be or'ed into dwStrType to inhibit <br>' the above quoting. <br>' <br>' Returns the number of characters converted including the terminating null <br>' character. If psz is NULL or csz is 0, returns the required size of the <br>' <br>' If psz != NULL &amp;&amp; csz != 0, returned psz is always NULL terminated. <br>' <br>' Note: csz includes the NULL char. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' Certificate name string types <br>'-------------------------------------------------------------------------- <br>Public Const CERT_SIMPLE_NAME_STR As Long = 1 <br>Public Const CERT_OID_NAME_STR As Long = 2 <br>Public Const CERT_X500_NAME_STR As Long = 3 <br>'+------------------------------------------------------------------------- <br>' Certificate name string type flags OR'ed with the above types <br>'-------------------------------------------------------------------------- <br>Public Const CERT_NAME_STR_SEMICOLON_FLAG As Long = &amp;H40000000 <br>Public Const CERT_NAME_STR_NO_PLUS_FLAG As Long = &amp;H20000000 <br>Public Const CERT_NAME_STR_NO_QUOTING_FLAG As Long = &amp;H10000000 <br>Public Const CERT_NAME_STR_CRLF_FLAG As Long = &amp;H08000000 <br>Public Const CERT_NAME_STR_COMMA_FLAG As Long = &amp;H04000000 <br>'+------------------------------------------------------------------------- <br>' Convert the null terminated X500 string to an encoded certificate name. <br>' <br>' The input string is expected to be formatted the same as the output <br>' from the above CertNameToStr API. <br>' <br>' The CERT_SIMPLE_NAME_STR type isn't supported. Otherwise, when dwStrType <br>' is set to 0, CERT_OID_NAME_STR or CERT_X500_NAME_STR, allow either a <br>' <br>' If no flags are OR'ed into dwStrType, then, allow "," or ";" as RDN <br>' separators and "+" as the multiple RDN value separator. Quoting is <br>' supported. A quote may be included in a quoted value by double quoting, <br>' as ascii hex and converted to a CERT_RDN_OCTET_STRING. Embedded whitespace <br>' <br>' Whitespace surrounding the keys, object identifers and values is removed. <br>' <br>' CERT_NAME_STR_COMMA_FLAG can be or'ed into dwStrType to only allow the <br>' "," as the RDN separator. <br>' <br>' CERT_NAME_STR_SEMICOLON_FLAG can be or'ed into dwStrType to only allow the <br>' ";" as the RDN separator. <br>' <br>' CERT_NAME_STR_CRLF_FLAG can be or'ed into dwStrType to only allow <br>' "\r" or "\n" as the RDN separator. <br>' <br>' CERT_NAME_STR_NO_PLUS_FLAG can be or'ed into dwStrType to ignore "+" <br>' as a separator and not allow multiple values per RDN. <br>' <br>' CERT_NAME_STR_NO_QUOTING_FLAG can be or'ed into dwStrType to inhibit <br>' quoting. <br>' <br>' Support the following X500 Keys: <br>' <br>' --- ----------------- ----------------- <br>' CN szOID_COMMON_NAME Printable, T61 <br>' L szOID_LOCALITY_NAME Printable, T61 <br>' O szOID_ORGANIZATION_NAME Printable, T61 <br>' OU szOID_ORGANIZATIONAL_UNIT_NAME Printable, T61 <br>' Email szOID_RSA_emailAddr Only IA5 <br>' C szOID_COUNTRY_NAME Only Printable <br>' S szOID_STATE_OR_PROVINCE_NAME Printable, T61 <br>' ST szOID_STATE_OR_PROVINCE_NAME Printable, T61 <br>' STREET szOID_STREET_ADDRESS Printable, T61 <br>' T szOID_TITLE Printable, T61 <br>' Title szOID_TITLE Printable, T61 <br>' G szOID_GIVEN_NAME Printable, T61 <br>' GivenName szOID_GIVEN_NAME Printable, T61 <br>' I szOID_INITIALS Printable, T61 <br>' Initials szOID_INITIALS Printable, T61 <br>' SN szOID_SUR_NAME Printable, T61 <br>' DC szOID_DOMAIN_COMPONENT Only IA5 <br>' <br>' The T61 types are UTF-8 encoded. <br>' <br>' Returns TRUE if successfully parsed the input string and encoded <br>' the name. <br>' <br>' If the input string is detected to be invalid, *ppszError is updated <br>' to point to the beginning of the invalid character sequence. Otherwise, <br>' *ppszError is set to NULL. *ppszError is updated with a non-NULL pointer <br>' for the following errors: <br>' CRYPT_E_INVALID_X500_STRING <br>' CRYPT_E_INVALID_NUMERIC_STRING <br>' CRYPT_E_INVALID_PRINTABLE_STRING <br>' CRYPT_E_INVALID_IA5_STRING <br>' <br>' ppszError can be set to NULL if not interested in getting a pointer <br>' to the invalid character sequence. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>'-------------------------------------------------------------------------- <br>'+========================================================================= <br>' Simplified Cryptographic Message Data Structures and APIs <br>'========================================================================== <br>'+------------------------------------------------------------------------- <br>' Conventions for the *pb and *pcb output parameters: <br>' <br>' Upon entry to the function: <br>' if pcb is OPTIONAL &amp;&amp; pcb == NULL, then, <br>' No output is returned <br>' else if pb == NULL &amp;&amp; pcb != NULL, then, <br>' Length only determination. No length error is <br>' returned. <br>' Output is returned. If *pcb isn't big enough a <br>' length error is returned. In all cases *pcb is updated <br>' with the actual length needed/returned. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' Type definitions of the parameters used for doing the cryptographic <br>' operations. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' Callback to get and verify the signer's certificate. <br>' <br>' handle to its cryptographic signed message's cert store. <br>' <br>' For CRYPT_E_NO_SIGNER, called with pSignerId == NULL. <br>' <br>' For a valid signer certificate, returns a pointer to a read only <br>' CERT_CONTEXT. The returned CERT_CONTEXT is either obtained from a <br>' cert store or was created via CertCreateCertificateContext. For either case, <br>' its freed via CertFreeCertificateContext. <br>' <br>' If a valid certificate isn't found, this callback returns NULL with <br>' <br>' The NULL implementation tries to get the Signer certificate from the <br>' message cert store. It doesn't verify the certificate. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' The CRYPT_SIGN_MESSAGE_PARA are used for signing messages using the <br>' <br>' Either the CERT_KEY_PROV_HANDLE_PROP_ID or CERT_KEY_PROV_INFO_PROP_ID must <br>' be set for each rgpSigningCert[]. Either one specifies the private <br>' signature key to use. <br>' <br>' If any certificates and/or CRLs are to be included in the signed message, <br>' then, the MsgCert and MsgCrl parameters need to be updated. If the <br>' rgpSigningCerts are to be included, then, they must also be in the <br>' rgpMsgCert array. <br>' <br>' LastError will be updated with E_INVALIDARG. <br>' <br>' pvHashAuxInfo currently isn't used and must be set to NULL. <br>' <br>' dwFlags normally is set to 0. However, if the encoded output <br>' is to be a CMSG_SIGNED inner content of an outer cryptographic message, <br>' such as a CMSG_ENVELOPED, then, the CRYPT_MESSAGE_BARE_CONTENT_OUT_FLAG <br>' should be set. If not set, then it would be encoded as an inner content <br>' type of CMSG_DATA. <br>' <br>' dwInnerContentType is normally set to 0. It needs to be set if the <br>' ToBeSigned input is the encoded output of another cryptographic <br>' message, such as, an CMSG_ENVELOPED. When set, it's one of the cryptographic <br>' message types, for example, CMSG_ENVELOPED. <br>' <br>' the default), then, neither dwFlags or dwInnerContentType need to be set. <br>'-------------------------------------------------------------------------- <br>Public Const CRYPT_MESSAGE_BARE_CONTENT_OUT_FLAG As Long = &amp;H1 <br>'+------------------------------------------------------------------------- <br>' The CRYPT_VERIFY_MESSAGE_PARA are used to verify signed messages. <br>' <br>' hCryptProv is used to do hashing and signature verification. <br>' <br>' The dwCertEncodingType specifies the encoding type of the certificates <br>' and/or CRLs in the message. <br>' <br>' pfnGetSignerCertificate is called to get and verify the message signer's <br>' certificate. <br>' <br>' LastError will be updated with E_INVALIDARG. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' The CRYPT_ENCRYPT_MESSAGE_PARA are used for encrypting messages. <br>' <br>' hCryptProv is used to do content encryption, recipient key <br>' encryption, and recipient key export. Its private key <br>' isn't used. <br>' <br>' pvEncryptionAuxInfo currently isn't used and must be set to NULL. <br>' <br>' LastError will be updated with E_INVALIDARG. <br>' <br>' dwFlags normally is set to 0. However, if the encoded output <br>' is to be a CMSG_ENVELOPED inner content of an outer cryptographic message, <br>' such as a CMSG_SIGNED, then, the CRYPT_MESSAGE_BARE_CONTENT_OUT_FLAG <br>' should be set. If not set, then it would be encoded as an inner content <br>' type of CMSG_DATA. <br>' <br>' dwInnerContentType is normally set to 0. It needs to be set if the <br>' ToBeEncrypted input is the encoded output of another cryptographic <br>' message, such as, an CMSG_SIGNED. When set, it's one of the cryptographic <br>' message types, for example, CMSG_SIGNED. <br>' <br>' the default), then, neither dwFlags or dwInnerContentType need to be set. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' The CRYPT_DECRYPT_MESSAGE_PARA are used for decrypting messages. <br>' <br>' The CertContext to use for decrypting a message is obtained from one <br>' of the specified cert stores. An encrypted message can have one or <br>' and SerialNumber). The cert stores are searched to find the CertContext <br>' corresponding to the CertId. <br>' <br>' Only CertContexts in the store with either <br>' the CERT_KEY_PROV_HANDLE_PROP_ID or CERT_KEY_PROV_INFO_PROP_ID set <br>' can be used. Either property specifies the private exchange key to use. <br>' <br>' LastError will be updated with E_INVALIDARG. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' The CRYPT_HASH_MESSAGE_PARA are used for hashing or unhashing <br>' messages. <br>' <br>' hCryptProv is used to compute the hash. <br>' <br>' pvHashAuxInfo currently isn't used and must be set to NULL. <br>' <br>' LastError will be updated with E_INVALIDARG. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' The CRYPT_KEY_SIGN_MESSAGE_PARA are used for signing messages until a <br>' certificate has been created for the signature key. <br>' <br>' pvHashAuxInfo currently isn't used and must be set to NULL. <br>' <br>' LastError will be updated with E_INVALIDARG. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' The CRYPT_KEY_VERIFY_MESSAGE_PARA are used to verify signed messages without <br>' a certificate for the signer. <br>' <br>' Normally used until a certificate has been created for the key. <br>' <br>' hCryptProv is used to do hashing and signature verification. <br>' <br>' LastError will be updated with E_INVALIDARG. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' Sign the message. <br>' <br>' If fDetachedSignature is TRUE, the "to be signed" content isn't included <br>' in the encoded signed blob. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' Verify a signed message. <br>' <br>' If pbDecoded == NULL, then, *pcbDecoded is implicitly set to 0 on input. <br>' For *pcbDecoded == 0 &amp;&amp; ppSignerCert == NULL on input, the signer isn't <br>' verified. <br>' <br>' A message might have more than one signer. Set dwSignerIndex to iterate <br>' through all the signers. dwSignerIndex == 0 selects the first signer. <br>' <br>' pVerifyPara's pfnGetSignerCertificate is called to get the signer's <br>' certificate. <br>' <br>' For a verified signer and message, *ppSignerCert is updated <br>' with the CertContext of the signer. It must be freed by calling <br>' CertFreeCertificateContext. Otherwise, *ppSignerCert is set to NULL. <br>' <br>' ppSignerCert can be NULL, indicating the caller isn't interested <br>' in getting the CertContext of the signer. <br>' <br>' pcbDecoded can be NULL, indicating the caller isn't interested in getting <br>' the decoded content. Furthermore, if the message doesn't contain any <br>' content or signers, then, pcbDecoded must be set to NULL, to allow the <br>' pVerifyPara-&gt;pfnGetCertificate to be called. Normally, this would be <br>' the case when the signed message contains only certficates and CRLs. <br>' If pcbDecoded is NULL and the message doesn't have the indicated signer, <br>' pfnGetCertificate is called with pSignerId set to NULL. <br>' <br>' If the message doesn't contain any signers || dwSignerIndex &gt; message's <br>' SignerCount, then, an error is returned with LastError set to <br>' CRYPT_E_NO_SIGNER. Also, for CRYPT_E_NO_SIGNER, pfnGetSignerCertificate <br>' is still called with pSignerId set to NULL. <br>' <br>' Note, an alternative way to get the certificates and CRLs from a <br>' signed message is to call CryptGetMessageCertificates. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' Returns the count of signers in the signed message. For no signers, returns <br>' 0. For an error returns -1 with LastError updated accordingly. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' Returns the cert store containing the message's certs and CRLs. <br>' For an error, returns NULL with LastError updated. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' The "to be signed" content is passed in separately. No <br>' decoded output. Otherwise, identical to CryptVerifyMessageSignature. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' Decrypts the message. <br>' <br>' If pbDecrypted == NULL, then, *pcbDecrypted is implicitly set to 0 on input. <br>' For *pcbDecrypted == 0 &amp;&amp; ppXchgCert == NULL on input, the message isn't <br>' decrypted. <br>' <br>' For a successfully decrypted message, *ppXchgCert is updated <br>' with the CertContext used to decrypt. It must be freed by calling <br>' CertStoreFreeCert. Otherwise, *ppXchgCert is set to NULL. <br>' <br>' ppXchgCert can be NULL, indicating the caller isn't interested <br>' in getting the CertContext used to decrypt. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' followed with a CryptEncryptMessage. <br>' <br>' Note: this isn't the CMSG_SIGNED_AND_ENVELOPED. Its a CMSG_SIGNED <br>' inside of an CMSG_ENVELOPED. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' Decrypts the message and verifies the signer. Does a CryptDecryptMessage <br>' followed with a CryptVerifyMessageSignature. <br>' <br>' If pbDecrypted == NULL, then, *pcbDecrypted is implicitly set to 0 on input. <br>' For *pcbDecrypted == 0 &amp;&amp; ppSignerCert == NULL on input, the signer isn't <br>' verified. <br>' <br>' A message might have more than one signer. Set dwSignerIndex to iterate <br>' through all the signers. dwSignerIndex == 0 selects the first signer. <br>' <br>' The pVerifyPara's VerifySignerPolicy is called to verify the signer's <br>' certificate. <br>' <br>' For a successfully decrypted and verified message, *ppXchgCert and <br>' *ppSignerCert are updated. They must be freed by calling <br>' CertStoreFreeCert. Otherwise, they are set to NULL. <br>' <br>' ppXchgCert and/or ppSignerCert can be NULL, indicating the <br>' caller isn't interested in getting the CertContext. <br>' <br>' Note: this isn't the CMSG_SIGNED_AND_ENVELOPED. Its a CMSG_SIGNED <br>' inside of an CMSG_ENVELOPED. <br>' <br>' The message always needs to be decrypted to allow access to the <br>' signed message. Therefore, if ppXchgCert != NULL, its always updated. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' Decodes a cryptographic message which may be one of the following types: <br>' CMSG_DATA <br>' CMSG_SIGNED <br>' CMSG_ENVELOPED <br>' CMSG_SIGNED_AND_ENVELOPED <br>' CMSG_HASHED <br>' <br>' dwMsgTypeFlags specifies the set of allowable messages. For example, to <br>' decode either SIGNED or ENVELOPED messages, set dwMsgTypeFlags to: <br>' CMSG_SIGNED_FLAG | CMSG_ENVELOPED_FLAG. <br>' <br>' dwProvInnerContentType is only applicable when processing nested <br>' crytographic messages. When processing an outer crytographic message <br>' it must be set to 0. When decoding a nested cryptographic message <br>' its the dwInnerContentType returned by a previous CryptDecodeMessage <br>' of the outer message. The InnerContentType can be any of the CMSG types, <br>' for example, CMSG_DATA, CMSG_SIGNED, ... <br>' <br>' The optional *pdwMsgType is updated with the type of message. <br>' <br>' The optional *pdwInnerContentType is updated with the type of the inner <br>' message. Unless there is cryptographic message nesting, CMSG_DATA <br>' is returned. <br>' <br>' For CMSG_DATA: returns decoded content. <br>' For CMSG_SIGNED: same as CryptVerifyMessageSignature. <br>' For CMSG_ENVELOPED: same as CryptDecryptMessage. <br>' For CMSG_SIGNED_AND_ENVELOPED: same as CryptDecryptMessage plus <br>' CryptVerifyMessageSignature. <br>' For CMSG_HASHED: verifies the hash and returns decoded content. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' Hash the message. <br>' <br>' If fDetachedHash is TRUE, only the ComputedHash is encoded in the <br>' pbHashedBlob. Otherwise, both the ToBeHashed and ComputedHash <br>' are encoded. <br>' <br>' pcbHashedBlob or pcbComputedHash can be NULL, indicating the caller <br>' isn't interested in getting the output. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' Verify a hashed message. <br>' <br>' pcbToBeHashed or pcbComputedHash can be NULL, <br>' indicating the caller isn't interested in getting the output. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' Verify a hashed message containing a detached hash. <br>' The "to be hashed" content is passed in separately. No <br>' decoded output. Otherwise, identical to CryptVerifyMessageHash. <br>' <br>' pcbComputedHash can be NULL, indicating the caller isn't interested <br>' in getting the output. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' Sign the message using the provider's private key specified in the <br>' parameters. A dummy SignerId is created and stored in the message. <br>' <br>' Normally used until a certificate has been created for the key. <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' Verify a signed message using the specified public key info. <br>' <br>' Normally called by a CA until it has created a certificate for the <br>' key. <br>' <br>' pPublicKeyInfo contains the public key to use to verify the signed <br>' content may contain the PublicKeyInfo). <br>' <br>' pcbDecoded can be NULL, indicating the caller isn't interested <br>' in getting the decoded content. <br>'-------------------------------------------------------------------------- <br>'+========================================================================= <br>' System Certificate Store Data Structures and APIs <br>'========================================================================== <br>'+------------------------------------------------------------------------- <br>' Get a system certificate store based on a subsystem protocol. </code></pre>
<p>
</p>
<pre><code>' <br>' Current examples of subsystems protocols are: <br>' "MY" Cert Store hold certs with associated Private Keys <br>' "CA" Certifying Authority certs <br>' "ROOT" Root Certs <br>' "SPC" Software publisher certs <br>' <br>' <br>' If hProv is NULL the default provider "1" is opened for you. <br>' When the store is closed the provider is release. Otherwise <br>' if hProv is not NULL, no provider is created or released. <br>' <br>' The returned Cert Store can be searched for an appropriate Cert <br>' <br>' When done, the cert store should be closed using CertStoreClose <br>'-------------------------------------------------------------------------- <br>'+------------------------------------------------------------------------- <br>' Find all certificate chains tying the given issuer name to any certificate <br>' that the current user has a private key for. <br>' <br>' If no certificate chain is found, FALSE is returned with LastError set <br>' to CRYPT_E_NOT_FOUND and the counts zeroed. <br>' <br>' IE 3.0 ASSUMPTION: <br>' The client certificates are in the "My" system store. The issuer <br>' cerificates may be in the "Root", "CA" or "My" system stores. <br>'-------------------------------------------------------------------------- <br>' WINCRYPT32API This is not exported by crypt32, it is exported by softpub <br>'+-------------------------------------------------------------------------- <br>' <br>' Microsoft Windows <br>' <br>' File: cs.h <br>' <br>' Contents: Cert Server common definitions <br>' <br>' History: 25-Jul-96 vich created <br>' <br>'--------------------------------------------------------------------------- <br>Public Const VR_PENDING As Long = 0 <br>Public Const VR_INSTANT_OK As Long = 1 <br>Public Const VR_INSTANT_BAD As Long = 2 <br>' Certificate types: <br>Public Const CERT_TYPE_NONE As Long = 0 <br>Public Const CERT_TYPE_X509 As Long = 1 <br>Public Const CERT_TYPE_SDSI As Long = 2 <br>Public Const CERT_TYPE_PGP As Long = 3 <br>' Request types: <br>Public Const REQ_TYPE_NONE As Long = 0 <br>Public Const REQ_TYPE_PKCS10 As Long = 1 <br>Public Const REQ_TYPE_KEYGEN As Long = 2 <br>' RegisterNewRequest is called to deliver a new request to the certificate <br>' server. dwType indicates the type of request that has been received. <br>' The following values are valid: <br>Public Const RNR_T_UNK As Long = 0 <br>Public Const RNR_T_PKCS10 As Long = 1 <br>Public Const RNR_T_KEYGEN As Long = 2 <br>Public Const RNR_T_CUSTOM As Long = 3 <br>' Transport Info: <br>' The transport info structure is used several places in the certificate <br>' server to describe how request arrived, or how a certificate or CRL is to be <br>' sent. The structure can define an address in steps of precision. It can be <br>' just a type of transport, a specific transport mechanism, a transport <br>' address, or a specific authenticated user at an address. <br>' Address Types: <br>Public Const ADR_TYPE As Long = &amp;H00000001 <br>Public Const ADR_STYPE As Long = &amp;H00000002 <br>Public Const ADR_ADDR As Long = &amp;H00000004 <br>Public Const ADR_USER As Long = &amp;H00000008 <br>Public Const ADR_AUTH As Long = &amp;H00000010 <br>Public Const ADR_TIME As Long = &amp;H00000020 <br>' Transport Types: <br>Public Const TTYPE_FREE As Long = 0 <br>Public Const TTYPE_EMAIL As Long = 1 <br>Public Const TTYPE_DNS As Long = 2 <br>' EMAIL subtypes: <br>Public Const TSUB_MAIL_GENERIC As Long = 1 <br>Public Const TSUB_MAIL_PEM As Long = 2 <br>Public Const TSUB_MAIL_EXCHSEC As Long = 3 <br>Public Const TSUB_MAIL_PGP As Long = 4 <br>' DNS subtypes: <br>Public Const TSUB_DNS_FTP As Long = 1 <br>Public Const TSUB_DNS_HTTP As Long = 2 <br>Public Const TSUB_DNS_HTTPS As Long = 3 <br>' Authentication Types: <br>Public Const AAT_CERT As Long = 1 <br>Public Const AAT_NTLM As Long = 2 <br>Public Const AAT_SICILY As Long = 3 <br>' <br>' VOID <br>' PLIST_ENTRY ListHead <br>' ); <br>' <br>' <br>' VOID <br>' PLIST_ENTRY ListHead, <br>' PLIST_ENTRY Entry <br>' ); <br>' <br>' <br>' VOID <br>' PLIST_ENTRY Entry <br>' ); <br>' <br>'+-------------------------------------------------------------------------- <br>' <br>' Microsoft Windows <br>' <br>' File: csprop.h <br>' <br>' Contents: Cert Server Property interfaces <br>' <br>' History: 31-Jul-96 vich created <br>' <br>'--------------------------------------------------------------------------- <br>'+-------------------------------------------------------------------------- <br>' Name properties: <br>Public Const wszPROPDISTINGUISHEDNAME As String = "DistinguishedName" <br>Public Const wszPROPRAWNAME As String = "RawName" <br>Public Const wszPROPNAMETYPE As String = "NameType" <br>Public Const wszPROPCOUNTRY As String = "Country" <br>Public Const wszPROPORGANIZATION As String = "Organization" <br>Public Const wszPROPORGUNIT As String = "OrgUnit" <br>Public Const wszPROPCOMMONNAME As String = "CommonName" <br>Public Const wszPROPLOCALITY As String = "Locality" <br>Public Const wszPROPSTATE As String = "State" <br>Public Const wszPROPTITLE As String = "Title" <br>Public Const wszPROPGIVENNAME As String = "GivenName" <br>Public Const wszPROPINITIALS As String = "Initials" <br>Public Const wszPROPSURNAME As String = "SurName" <br>Public Const wszPROPDOMAINCOMPONENT As String = "DomainComponent" <br>Public Const wszPROPEMAIL As String = "EMail" <br>'+-------------------------------------------------------------------------- <br>' Subject Name properties: <br>Public Const wszPROPSUBJECTDOT As String = "Subject." <br>'+-------------------------------------------------------------------------- <br>' Issuer Name properties: <br>Public Const wszPROPISSUERDOT As String = "Issuer." <br>'+-------------------------------------------------------------------------- <br>' For mapping request attribute names to internal property names: <br>' Map to wszPROPSUBJECTCOMMONNAME: <br>Public Const wszATTRCOMMONNAME1 As String = "CN" <br>Public Const wszATTRCOMMONNAME2 As String = "CommonName" <br>' Map to wszPROPSUBJECTLOCALITY: <br>Public Const wszATTRLOCALITY1 As String = "" <br>Public Const wszATTRLOCALITY2 As String = "Locality" <br>' Map to wszPROPSUBJECTSTATE: <br>Public Const wszATTRSTATE1 As String = "S" <br>Public Const wszATTRSTATE2 As String = "State" <br>' Map to wszPROPSUBJECTCOUNTRY: <br>Public Const wszATTRCOUNTRY1 As String = "C" <br>Public Const wszATTRCOUNTRY2 As String = "Country" <br>' Map to wszPROPSUBJECTORGANIZATION: <br>Public Const wszATTRORG1 As String = "O" <br>Public Const wszATTRORG2 As String = "Org" <br>Public Const wszATTRORG3 As String = "Organization" <br>' Map to wszPROPSUBJECTORGUNIT: <br>Public Const wszATTRORGUNIT1 As String = "OU" <br>Public Const wszATTRORGUNIT2 As String = "OrgUnit" <br>Public Const wszATTRORGUNIT3 As String = "OrganizationUnit" <br>Public Const wszATTRORGUNIT4 As String = "OrganizationalUnit" <br>' Map to wszPROPSUBJECTDOMAINCOMPONENT: <br>Public Const wszATTRDOMAINCOMPONENT1 As String = "DC" <br>Public Const wszATTRDOMAINCOMPONENT2 As String = "DomainComponent" <br>' Map to wszPROPSUBJECTEMAIL: <br>Public Const wszATTREMAIL1 As String = "EMail" <br>'+-------------------------------------------------------------------------- <br>' Request properties: <br>Public Const wszPROPREQUESTREQUESTID As String = "RequestID" <br>Public Const wszPROPREQUESTRAWREQUEST As String = "RawRequest" <br>Public Const wszPROPREQUESTATTRIBUTES As String = "RequestAttributes" <br>Public Const wszPROPREQUESTTYPE As String = "RequestType" <br>Public Const wszPROPREQUESTFLAGS As String = "RequestFlags" <br>Public Const wszPROPREQUESTSTATUS As String = "Status" <br>Public Const wszPROPREQUESTSTATUSCODE As String = "StatusCode" <br>Public Const wszPROPREQUESTDISPOSITION As String = "Disposition" <br>Public Const wszPROPREQUESTDISPOSITIONMESSAGE As String = "DispositionMessage" <br>Public Const wszPROPREQUESTSUBMITTEDWHEN As String = "SubmittedWhen" <br>Public Const wszPROPREQUESTRESOLVEDWHEN As String = "ResolvedWhen" <br>Public Const wszPROPREQUESTREVOKEDWHEN As String = "RevokedWhen" <br>Public Const wszPROPREQUESTREVOKEDEFFECTIVEWHEN As String = "RevokedEffectiveWhen" <br>Public Const wszPROPREQUESTREVOKEDREASON As String = "RevokedReason" <br>Public Const wszPROPREQUESTSUBJECTNAMEID As String = "SubjectNameID" <br>Public Const wszPROPREQUESTERNAME As String = "RequesterName" <br>Public Const wszPROPREQUESTERADDRESS As String = "RequesterAddress" <br>'+-------------------------------------------------------------------------- <br>' Request attribute properties: <br>Public Const wszPROPCHALLENGE As String = "Challenge" <br>Public Const wszPROPEXPECTEDCHALLENGE As String = "ExpectedChallenge" <br>'+-------------------------------------------------------------------------- <br>' Certificate properties: <br>Public Const wszPROPCERTIFICATEREQUESTID As String = "RequestID" <br>Public Const wszPROPRAWCERTIFICATE As String = "RawCertificate" <br>Public Const wszPROPCERTIFICATETYPE As String = "CertificateType" <br>Public Const wszPROPCERTIFICATESERIALNUMBER As String = "SerialNumber" <br>Public Const wszPROPCERTIFICATEISSUERNAMEID As String = "IssuerNameID" <br>Public Const wszPROPCERTIFICATESUBJECTNAMEID As String = "SubjectNameID" <br>Public Const wszPROPCERTIFICATENOTBEFOREDATE As String = "NotBefore" <br>Public Const wszPROPCERTIFICATENOTAFTERDATE As String = "NotAfter" <br>Public Const wszPROPCERTIFICATERAWPUBLICKEY As String = "RawPublicKey" <br>Public Const wszPROPCERTIFICATEPUBLICKEYALGORITHM As String = "PublicKeyAlgorithm" <br>'+-------------------------------------------------------------------------- <br>' Certificate extension properties: <br>Public Const wszPROPCERTIFICATEEXTENSIONFLAGS As String = "Flags" <br>Public Const wszPROPCERTIFICATEEXTENSIONVALUE As String = "Value" <br>Public Const EXTENSION_CRITICAL_FLAG As Long = &amp;H00000001 <br>Public Const EXTENSION_DISABLE_FLAG As Long = &amp;H00000002 <br>Public Const EXTENSION_POLICY_MASK As Long = &amp;H0000ffff <br>Public Const EXTENSION_ORIGIN_REQUEST As Long = &amp;H00010000 <br>Public Const EXTENSION_ORIGIN_POLICY As Long = &amp;H00020000 <br>Public Const EXTENSION_ORIGIN_ADMIN As Long = &amp;H00030000 <br>Public Const EXTENSION_ORIGIN_SERVER As Long = &amp;H00040000 <br>Public Const EXTENSION_ORIGIN_MASK As Long = &amp;H000f0000 <br>'+-------------------------------------------------------------------------- <br>' GetProperty/SetProperty Flags: <br>' <br>' Choose one Type <br>Public Const PROPTYPE_LONG As Long = &amp;H00000001 <br>Public Const PROPTYPE_DATE As Long = &amp;H00000002 <br>Public Const PROPTYPE_BINARY As Long = &amp;H00000003 <br>Public Const PROPTYPE_STRING As Long = &amp;H00000004 <br>Public Const PROPTYPE_ANSI As Long = &amp;H00000005 <br>Public Const PROPTYPE_MASK As Long = &amp;H000000ff <br>' Choose one Caller: <br>Public Const PROPCALLER_SERVER As Long = &amp;H00000100 <br>Public Const PROPCALLER_POLICY As Long = &amp;H00000200 <br>Public Const PROPCALLER_EXIT As Long = &amp;H00000300 <br>Public Const PROPCALLER_ADMIN As Long = &amp;H00000400 <br>Public Const PROPCALLER_MASK As Long = &amp;H00000f00 <br>' Choose one Table: <br>Public Const PROPTABLE_REQUEST As Long = &amp;H00001000 <br>Public Const PROPTABLE_CERTIFICATE As Long = &amp;H00002000 <br>Public Const PROPTABLE_EXTENSIONS As Long = &amp;H00003000 <br>Public Const PROPTABLE_ATTRIBUTES As Long = &amp;H00004000 <br>Public Const PROPTABLE_MASK As Long = &amp;H0000f000 <br>' Internal use only <br>Public Const PROPTABLE_EXTENSIONFLAGS As Long = &amp;H00010000 <br>Public Const PROPTABLE_EXTENSIONVALUE As Long = &amp;H00020000 <br>Public Const cchSERIALNUMBERMAX As Long = 64 <br>Public Const cchOBJECTIDMAX As Long = 31 <br>Public Const cchDISTINGUISHEDNAMEMAX As Long = 254 <br>Public Const cchCOUNTRYNAMEMAX As Long = 2 <br>' Request Status property values: <br>Public Const REQSTATUS_ACTIVE As Long = 1 <br>Public Const REQSTATUS_ACCEPTED As Long = 2 <br>Public Const REQSTATUS_DENIED As Long = 3 <br>Public Const REQSTATUS_PENDING As Long = 4 <br>Public Const REQSTATUS_ERROR As Long = 5 <br>' CertIF property callback support: <br>' CertIF property enumeration callback support: <br>Public Const CIE_OBJECTID As Long = &amp;H00000001 <br>Public Const CIE_TABLE_EXTENSIONS As Long = &amp;H00000010 <br>Public Const CIE_TABLE_ATTRIBUTES As Long = &amp;H00000020 <br>Public Const CIE_TABLE_MASK As Long = &amp;H000000f0 <br>'+-------------------------------------------------------------------------- <br>' <br>' Microsoft Windows <br>' <br>' File: certreq.h <br>' <br>' Contents: ICertRequest definitions <br>' <br>' History: 03-Jan-97 vich created <br>' <br>'--------------------------------------------------------------------------- <br>'+-------------------------------------------------------------------------- <br>' Known request Attribute names and Value strings <br>' RequestType attribute name: <br>Public Const wszCERT_TYPE As String = "RequestType" <br>' RequestType attribute values: <br>' Not specified: <br>Public Const wszCERT_TYPE_CLIENT As String = "Client" <br>Public Const wszCERT_TYPE_SERVER As String = "Server" <br>Public Const wszCERT_TYPE_CODESIGN As String = "CodeSign" <br>Public Const wszCERT_TYPE_CUSTOMER As String = "SetCustomer" <br>Public Const wszCERT_TYPE_MERCHANT As String = "SetMerchant" <br>Public Const wszCERT_TYPE_PAYMENT As String = "SetPayment" <br>' Version attribute name: <br>Public Const wszCERT_VERSION As String = "Version" <br>' Version attribute values: <br>' Not specified: <br>Public Const wszCERT_VERSION_1 As String = "1" <br>Public Const wszCERT_VERSION_2 As String = "2" <br>Public Const wszCERT_VERSION_3 As String = "3" <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
