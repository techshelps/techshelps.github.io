<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>TABLE.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6158"></a>TABLE.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples.  <br>*       Copyright 1996 - 1998 Microsoft Corporation. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>// TABLE.C <br> <br>#include "cfiler.h" <br>#include &lt;malloc.h&gt; <br> <br>/******************************************************************\ <br>* CheckHeap() <br>* <br>* input:  <br>* <br>* message - buffer containing information to display on the <br>* debug window <br>* <br>* purpose: <br>* <br>* Calls _heapchk and outputs a formatted message onto the <br>* debug window. <br>\******************************************************************/ <br> <br>VOID CheckHeap(LPTSTR message) { <br>INT rv = _heapchk(); <br> <br>if (rv == _HEAPBADBEGIN) { <br>ErrorMsg(message); <br>ErrorMsg(TEXT("Initial header information is bad or cannot be found.")); <br>return; <br>} <br>else if (rv == _HEAPBADNODE) { <br>ErrorMsg(message); <br>ErrorMsg(TEXT("Bad node has been found or heap is damaged.")); <br>return; <br>} <br>else if (rv == _HEAPBADPTR) { <br>ErrorMsg(message); <br>ErrorMsg(TEXT("Pointer into heap is not valid.")); <br>return; <br>} <br>else if (rv == _HEAPEMPTY) { <br>ErrorMsg(message); <br>ErrorMsg(TEXT("Heap has not been initialized.")); <br>return; <br>} <br>else if (rv == _HEAPOK) { <br>ErrorMsg(message); <br>ErrorMsg(TEXT("Heap appears to be consistent.")); <br>return; <br>} <br>else { <br>ErrorMsg(message); <br>ErrorMsg(TEXT("_heapcheck did not return a valid value.")); <br>} <br>return; <br>} <br> <br>/******************************************************************\ <br>* GetSize() <br>* <br>* in parameters: <br>* pTable - pointer to string table <br>* <br>* returns <br>* number of elements of pTable <br>* -1 if error <br>\******************************************************************/ <br> <br>INT GetSize(TABLE pTable) { <br>if (!pTable) { <br>ErrorMsg(TEXT("GetSize: pTable is NULL.")); <br>return -1; <br>} <br> <br>return pTable-&gt;iNumElems; <br>} <br> <br>/******************************************************************\ <br>* TableNew() <br>* <br>* Returns a new string table with no elements or NULL <br>* if unsuccessful <br>\******************************************************************/ <br> <br>TABLE TableNew(VOID) { <br>TABLE pTable; <br> <br>pTable = malloc(sizeof(*pTable) + 100); <br> <br>if (!pTable) { <br>ErrorMsg(TEXT("TableNew: malloc failed.")); <br>return FALSE; <br>} <br> <br>pTable-&gt;iNumElems = 0; <br>pTable-&gt;pCurrentFiles = NULL; <br> <br>return pTable; <br>} <br> <br>/******************************************************************\ <br>* TableFree() <br>* <br>* input: pTable - pointer to a table <br>* <br>* purpose: <br>*  <br>* Frees the string table pointed to by pTable. <br>* <br>* return value: <br>* <br>* TRUE if successful <br>* FALSE if unsuccessful <br>\******************************************************************/ <br> <br>BOOL TableFree(TABLE pTable) { <br>ELEM *p, *q; <br> <br>    if (!pTable) { <br>    ErrorMsg(TEXT("TableFree: pTable is NULL.")); <br>    return FALSE; <br>    } <br>     <br>    for (p = pTable-&gt;pCurrentFiles; p; p = q) { <br>q = p-&gt;next; <br>free(p-&gt;hidden); <br>free(p-&gt;displayed); <br>free(p); <br>p = NULL; <br>} <br> <br>free(pTable); <br> <br>pTable = NULL; <br> <br>return TRUE; <br>} <br> <br>/******************************************************************\ <br>* TableFind() <br>* <br>* input: pTable - pointer to a table <br>* szFindString - string in question. <br>* <br>* purpose: <br>* Searches for szFindString in table pTable. <br>* <br>* return value: <br>* <br>* TRUE if szFindString is in table <br>* FALSE if otherwise <br>\******************************************************************/ <br> <br>BOOL TableFind(TABLE pTable, LPTSTR szFindString) { <br>ELEM *p, *q; <br> <br>    if (!pTable) { <br>    ErrorMsg(TEXT("TableFree: pTable is NULL.")); <br>    return FALSE; <br>    } <br>     <br>    for (p = pTable-&gt;pCurrentFiles; p; p = q) { <br>q = p-&gt;next; <br>if (!CFilerlstrcmp(p-&gt;displayed, szFindString)) { <br>return TRUE; <br>} <br>} <br> <br>return FALSE; <br>} <br> <br>/******************************************************************\ <br>* TableAdd() <br>* <br>* input: <br>* <br>* pTable - pointer to a string table <br>* <br>* szHidden, szDisplayed: pair of strings to insert into table <br>* <br>* <br>* purpose: <br>* <br>* Inserts a string pair at the end of the string table pointed <br>* to by pTable. <br>\******************************************************************/ <br> <br>BOOL TableAdd(TABLE pTable, TCHAR *szHidden, LPTSTR szDisplayed) { <br>return TableInsert(pTable, szHidden, szDisplayed, pTable-&gt;iNumElems); <br>} <br> <br>/******************************************************************\ <br>* TableInsert() <br>* <br>* input: <br>* <br>* pTable - pointer to a string table <br>* szHidden, szDisplayed : string pair to be inserted <br>* i - position to insert the string pair. <br>* <br>* purpose: <br>* inserts a string pair into the table pointed to by pTable <br>* at position indicated by i. <br>\******************************************************************/ <br> <br>BOOL TableInsert(TABLE pTable, LPTSTR szHidden, LPTSTR szDisplayed, INT i) { <br>ELEM *new, *p = NULL, *q = NULL; <br>INT j; <br> <br>if (!pTable) { <br>ErrorMsg(TEXT("TableInsert: pTable is NULL.")); <br>return FALSE; <br>} <br> <br>new = malloc(sizeof(*new) + 2); <br> <br>new-&gt;hidden = malloc(3 + sizeof(*szHidden) * lstrlen(szHidden)); <br>new-&gt;displayed = malloc(3 + sizeof(*szDisplayed) * lstrlen(szDisplayed)); <br>new-&gt;next = NULL; <br> <br>lstrcpy(new-&gt;hidden, szHidden); <br>lstrcpy(new-&gt;displayed, szDisplayed); <br> <br>if (!pTable-&gt;pCurrentFiles) { <br>pTable-&gt;pCurrentFiles = new; <br>pTable-&gt;iNumElems++; <br>return TRUE; <br>} <br> <br>if (!i) { <br>ELEM *t; <br>t = pTable-&gt;pCurrentFiles; <br>pTable-&gt;pCurrentFiles = new; <br>new-&gt;next = t; <br>pTable-&gt;iNumElems++; <br>return TRUE; <br>} <br> <br>for (j = 0, p = pTable-&gt;pCurrentFiles; j &lt; i; j++, p = p-&gt;next) <br>q = p; <br> <br>q-&gt;next = new; <br>new-&gt;next = p; <br> <br>pTable-&gt;iNumElems++; <br> <br>return TRUE; <br>} <br> <br>/******************************************************************\ <br>* TableRemove() <br>* <br>* input:  <br>* pTable - pointer to a string table <br>* i - index of element to be removed <br>* <br>* purpose:  <br>* Removes the element at position i in the string table  <br>* pointed to by pTable. <br>* <br>* Return values: <br>* TRUE if successful <br>* FALSE if unsuccessful <br>\******************************************************************/ <br> <br>BOOL TableRemove(TABLE pTable, INT i) { <br>INT j; <br>ELEM *p, *q; <br> <br>if (!pTable) { <br>ErrorMsg(TEXT("TableRemove: pTable is NULL.")); <br>return FALSE; <br>} <br> <br>if (!pTable-&gt;pCurrentFiles) { <br>pTable-&gt;iNumElems = 0; <br>return TRUE; <br>} <br> <br>if (!i) { <br>ELEM *t = pTable-&gt;pCurrentFiles-&gt;next; <br>p = pTable-&gt;pCurrentFiles; <br>free(p-&gt;hidden); <br>free(p-&gt;displayed); <br>free(p); <br>pTable-&gt;pCurrentFiles = t; <br>pTable-&gt;iNumElems--; <br>return TRUE; <br>} <br> <br>for (j = 0, p = pTable-&gt;pCurrentFiles; j &lt; i; j++, p = p-&gt;next) { <br>q = p; <br>} <br> <br>q-&gt;next = p-&gt;next; <br>free(p-&gt;hidden); <br>free(p-&gt;displayed); <br>free(p); <br> <br>pTable-&gt;iNumElems--; <br> <br>return TRUE; <br>} <br> <br>/******************************************************************\ <br>* TableSort() <br>* <br>* input: <br>* pTable - pointer to a string table <br>* compare - pointer to a compare function to be used in the <br>* sort process <br>* <br>* Purpose:  <br>* sorts the elements of the string table pointed to by pTable <br>* on the displayed field. <br>* <br>* Return values: <br>* TRUE if successful <br>* FALSE if unsuccessful <br>\******************************************************************/ <br> <br>BOOL TableSort(TABLE pTable, INT compare(LPCTSTR , LPCTSTR)) { <br>ELEM *p, *q, *min, *t; <br>INT i, j; <br> <br>if (!pTable) { <br>ErrorMsg(TEXT("TableSort: pTable is NULL.")); <br>return FALSE; <br>} <br> <br>t = malloc(sizeof(*t)); <br> <br>for (i = 0, p = pTable-&gt;pCurrentFiles; p &amp;&amp; i &lt; pTable-&gt;iNumElems - 1; i++, p = p-&gt;next) { <br>min = p; <br>for (q = p-&gt;next, j = 0; q &amp;&amp; j &lt; pTable-&gt;iNumElems; j++, q = q-&gt;next) { <br>if (!q-&gt;displayed || !p-&gt;displayed) { <br>ErrorMsg(TEXT("TableSort: parameters to compare are null.")); <br>return FALSE; <br>} <br>if (compare(q-&gt;displayed, min-&gt;displayed) &lt; 0) min = q; <br>} <br>t-&gt;displayed = min-&gt;displayed; <br>t-&gt;hidden = min-&gt;hidden;  <br>min-&gt;displayed = p-&gt;displayed;  <br>min-&gt;hidden = p-&gt;hidden; <br>p-&gt;displayed = t-&gt;displayed; <br>p-&gt;hidden = t-&gt;hidden; <br>} <br> <br>free(t); <br> <br>return TRUE; <br>} <br> <br>/******************************************************************\ <br>* TableSend() <br>* <br>* input: <br>* pTable - pointer to a string table <br>* mybox - handle to the listbox to which LB_ADDSTRING <br>* messages are to be sent <br>* <br>* Purpose: <br>* Sends the displayed members of the string table pointed to by <br>* pTable to the listbox whose handle is mybox <br>* by sending LB_ADDSTRING messages to the listbox for each <br>* element of the table. <br>* <br>* Return values: <br>* TRUE if successful <br>* FALSE if unsuccessful <br>\******************************************************************/ <br> <br>BOOL TableSend(TABLE pTable, HWND mybox) { <br>int j; <br>ELEM *p; <br>LRESULT result; <br> <br>if (!pTable) { <br>ErrorMsg(TEXT("TableSend: pTable is NULL.")); <br>return FALSE; <br>} <br> <br>for (j = 0, p = pTable-&gt;pCurrentFiles; j &lt; pTable-&gt;iNumElems; j++, p = p-&gt;next) { <br>result = SendMessage(mybox, LB_ADDSTRING, (WPARAM)0, (LPARAM)p-&gt;displayed); <br> <br>if (result == LB_ERR) { <br>ErrorMsg(TEXT("TableSend: LB_ADDSTRING failed.")); <br>return FALSE; <br>} <br>} <br> <br>return TRUE; <br>} <br> <br>/******************************************************************\ <br>* TableGetHidden() <br>* <br>* input: <br>* pTable - pointer to a string table <br>* i - index of hidden element to retrieve <br>* rv - (out parameter): buffer to store the hidden string <br>* <br>* Purpose: <br>* Retrieves the hidden memeber of the table stored at position i <br>* in the string table pointed to by pTable. <br>* <br>* Returns: <br>* TRUE if successful <br>* FALSE if unsuccessful <br>\******************************************************************/ <br> <br>BOOL TableGetHidden(TABLE pTable, INT i, LPTSTR rv) { <br>INT j; <br>ELEM *p, *q; <br> <br>if (!pTable) { <br>ErrorMsg(TEXT("TableGetHidden: pTable is NULL.")); <br>return FALSE; <br>} <br> <br>q = pTable-&gt;pCurrentFiles; <br> <br>if (q) { <br>for (p = pTable-&gt;pCurrentFiles, j = 0; j &lt;= i; j++, p = p-&gt;next) <br>q = p; <br>} <br>else { <br>ErrorMsg(TEXT("TableGetHidden: pTable-&gt;pCurrentFiles is NULL.")); <br>lstrcpy(rv, TEXT("error")); <br>return FALSE; <br>} <br> <br>if (q &amp;&amp; q-&gt;hidden) <br>lstrcpy(rv, q-&gt;hidden); <br> <br>return TRUE; <br>} <br> <br>/******************************************************************\ <br>* SimplifyFileName() <br>* <br>* input: <br>* szFileName - buffer of string to be "simplified" <br>* rv - (out parameter) - buffer where simplified string <br>* is to be stored <br>* <br>* purpose: <br>* strips the characters [, ], &gt;, |, and ; from szFileName and <br>* stores the result in rv. <br>* <br>* returns: <br>* TRUE if successful <br>* FALSE if unsuccessful <br>\******************************************************************/ <br> <br>BOOL SimplifyFileName(LPTSTR szFileName, LPTSTR rv) { <br>INT i, j; <br> <br>for (i = 0, j = 0; szFileName[i]; ) { <br>if (szFileName[i] == TEXT('[') ||  <br>szFileName[i] == TEXT(']') ||  <br>szFileName[i] == TEXT('|') ||  <br>szFileName[i] == TEXT('&gt;') || <br>szFileName[i] == TEXT(';')) <br>i++; <br>else { <br>rv[j] = szFileName[i]; <br>i++; <br>j++; <br>} <br>} <br> <br>rv[j] = TEXT('\0'); <br>return TRUE; <br>} <br> <br>/******************************************************************\ <br>* ReplaceEscapeCharacters() <br>* <br>* input: <br>* szFileName - input buffer <br>* rv - (out parameter) - output buffer <br>* <br>* purpose: <br>* replaces '&amp;' characters in szFileName with '\&amp;' and stores <br>* the result in rv. <br>* <br>* returns: <br>* TRUE if successful <br>* FALSE if unsuccessful <br>\******************************************************************/ <br> <br>BOOL ReplaceEscapeCharacters(LPTSTR szFileName, LPTSTR rv) { <br>INT i, j; <br> <br>for (i = 0, j = 0; szFileName[i]; ) { <br>if (szFileName[i] == TEXT('&amp;')) { <br>rv[j] = TEXT('&amp;'); <br>rv[j + 1] = TEXT('&amp;'); <br>i++; <br>j += 2; <br>} <br>else { <br>rv[j] = szFileName[i]; <br>i++; <br>j++; <br>} <br>} <br> <br>rv[j] = TEXT('\0'); <br>return TRUE; <br>} <br> <br>/******************************************************************\ <br>* CFilerlstrcmp: Case-insensitive comparison of the strings s and t. <br>* foo and |foo are the same. <br>* [foo] and |[foo] are the same. <br>* [foo] and foo are not the same. <br>\******************************************************************/ <br> <br>INT CFilerlstrcmp(LPCTSTR s, LPCTSTR t) <br>{ <br>int i = 0, j = 0; <br> <br>if (s[0] == TEXT('|') || s[0] == TEXT('&gt;') || s[0] == TEXT(';')) <br>i++; <br> <br>if (t[0] == TEXT('|') || t[0] == TEXT('&gt;') || t[0] == TEXT(';')) <br>j++; <br> <br>for ( ; toupper(s[i]) == toupper(t[j]); i++, j++) <br>if (toupper(s[i]) == TEXT('\0')) <br>return 0; <br> <br>return toupper(s[i]) - toupper(t[j]); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
