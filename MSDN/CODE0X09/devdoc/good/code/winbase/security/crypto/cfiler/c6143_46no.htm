<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CFILER.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6144"></a>CFILER.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples.  <br>*       Copyright 1996 - 1998 Microsoft Corporation. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>// CFILER.C <br>#include "cfiler.h" <br>#include "time.h" <br> <br>HANDLE  ghModule;                                     <br>HANDLE  ghDrvThread = NULL; <br>HWND    ghwndMain = NULL;                       <br>HWND    ghwndDrives;               <br>HWND    ghwndDrv; <br>HWND    ghFocusWnd;                    <br>HFONT   ghFont; <br>HMENUghMenu;                         <br>BOOL                gfDrvWndOrient = SIDE_BY_SIDE, <br>                    gfKeepCommandWin = FALSE; <br>DRVCHILDINFO        gDrvChildInfo; <br>LPDINFO             glpDrives = (LPDINFO)0;     <br>CRITICAL_SECTION    gDrvCS;                    <br>                                              <br>extern LPTSTR lpDriveStrings; <br>extern ALG_IDAlgidEncrypt; <br>extern ALG_IDAlgidSign; <br>extern CHARsPass[BUF_SIZE]; <br>extern TCHARszPassName[BUF_SIZE]; <br> <br>int WINAPI WinMain(HINSTANCE hInstance,  <br>   HINSTANCE hPrevInstance,  <br>   LPSTR lpCmdLine,  <br>   INT nCmdShow) { <br>    MSG    msg; <br>    HANDLE hAccel; <br> <br>    ghModule = hInstance; <br> <br>    if (!InitializeApp()) { <br>        ErrorMsg(TEXT("WinMain: InitializeApp failed.")); <br>        return 0; <br>    } <br> <br>    ShowWindow(ghwndMain, nCmdShow); <br> <br>    if (!(hAccel = LoadAccelerators (ghModule, MAKEINTRESOURCE(ACCEL_ID)))) <br>        ErrorMsg(TEXT("WinMain: LoadAccelerators failed.")); <br> <br>    while (GetMessage(&amp;msg, NULL, 0, 0)) { <br>        if( !TranslateAccelerator(ghwndMain, hAccel, &amp;msg) ) { <br>            TranslateMessage(&amp;msg); <br>            DispatchMessage(&amp;msg); <br>        } <br>    } <br> <br>    return 1; <br> <br>    UNREFERENCED_PARAMETER(lpCmdLine); <br>    UNREFERENCED_PARAMETER(hPrevInstance); <br>} <br> <br>BOOL InitializeApp(void) <br>{ <br>    WNDCLASS wc; <br>HWND FirsthWnd, FirstChildhWnd; <br> <br>if (FirsthWnd = FindWindow("CRYPTFILERClass", NULL)) <br>{ <br>   // Found another running application with the same class name. <br>   // Therefore, one instance is already running. <br> <br>   FirstChildhWnd = GetLastActivePopup(FirsthWnd); <br>   BringWindowToTop(FirsthWnd);         // bring main window to top <br> <br>   if (FirsthWnd != FirstChildhWnd) <br>      BringWindowToTop(FirstChildhWnd); // a pop-up window is active <br>                                        // bring it to the top too <br> <br>   return FALSE;                        // do not run second instance <br>} <br> <br>    srand(time(0)); <br>        <br>    lstrcpy(szPassName, TEXT("\0")); <br>     <br>    wc.style            = 0; <br>    wc.lpfnWndProc      = (WNDPROC)MainWndProc; <br>    wc.cbClsExtra       = 0; <br>    wc.cbWndExtra   = 0; <br>    wc.hInstance        = ghModule; <br>    wc.hIcon            = LoadIcon(ghModule, MAKEINTRESOURCE(UI_CRYPTFILERICON)); <br>    wc.hCursor          = 0; <br>    wc.hbrBackground    = (HBRUSH)(COLOR_APPWORKSPACE); <br>    wc.lpszMenuName     = TEXT("CRYPTFILERMenu"); <br>    wc.lpszClassName    = TEXT("CRYPTFILERClass"); <br> <br>    if (!RegisterClass(&amp;wc)) { <br>ErrorMsg(TEXT("InitializeApp: RegisterClass failed.")); <br>    return FALSE; <br>} <br> <br>    wc.lpfnWndProc  = DrvWndProc; <br>    wc.hIcon        = NULL; <br>    wc.lpszMenuName = NULL; <br>    wc.lpszClassName    = TEXT("DrvClass"); <br> <br>    if (!RegisterClass(&amp;wc)) { <br>        ErrorMsg(TEXT("InitializeApp: RegisterClass failed.")); <br>        return FALSE; <br>    } <br>     <br>    wc.style        = CS_HREDRAW | CS_VREDRAW | CS_OWNDC; <br>    wc.lpfnWndProc  = DriveBarProc; <br>    wc.hbrBackground    = (HBRUSH)(COLOR_BTNSHADOW); <br>    wc.lpszClassName    = TEXT("DriveBarClass"); <br> <br>    if (!RegisterClass(&amp;wc)) { <br>        ErrorMsg(TEXT("InitializeApp: RegisterClass failed.")); <br>        return FALSE; <br>} <br> <br>    wc.style        = CS_HREDRAW | CS_VREDRAW; <br>    wc.lpfnWndProc  = TextWndProc; <br>    wc.hbrBackground    = (HBRUSH)(COLOR_INACTIVECAPTION); <br>    wc.lpszClassName    = TEXT("TextClass"); <br> <br>    if (!RegisterClass(&amp;wc)) { <br>        ErrorMsg(TEXT("InitializeApp: RegisterClass failed.")); <br>        return FALSE; <br>} <br> <br>    ghMenu = LoadMenu(ghModule, TEXT("CRYPTFILERMenu")); <br> <br>    if (!ghMenu) <br>return FALSE;     <br>     <br>    AlgidEncrypt = CALG_RC2; <br>AlgidSign = CALG_MD4; <br> <br>ghwndMain = CreateWindow(TEXT("CRYPTFILERClass"), <br>                             TEXT("CRYPTFILER"), <br>                             WS_OVERLAPPEDWINDOW, <br>                             CW_USEDEFAULT, <br>                             CW_USEDEFAULT, <br>                             MAIN_WIDTH, <br>                             MAIN_HEIGHT, <br>                             HWND_DESKTOP, <br>                             ghMenu, <br>                             ghModule, <br>                             NULL); <br> <br>    if (!ghwndMain) { <br>ErrorMsg(TEXT("InitializeApp: CreateWindow failed.")); <br>return FALSE; <br>} <br> <br>if (!MakeHashDirectory()) { <br>ErrorMsg(TEXT("InitializeApp: MakeHashDirectory failed.")); <br>return FALSE; <br>} <br> <br>return TRUE; <br>} <br> <br>LRESULT WINAPI MainWndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam) <br>{ <br>    INT bRet; <br>     <br>    switch (message) { <br>    case WM_CREATE: {  <br>        LOGFONT    lf; <br>        HDC        hDC; <br>        HGDIOBJ    hOldFont; <br>HGDIOBJ   hFont; <br>        TEXTMETRIC tm; <br>        DWORD dwThreadID; <br>DWORD dwLastError = GetLastError(); <br>        LPCINFO lpCInfo; <br>         <br>        // <br>        // Initialize drive list and Set Directory critical sections. <br>        // <br>        InitializeCriticalSection(&amp;gDrvCS); <br>        <br>        ghDrvThread = CreateThread(NULL, 0, <br>                                   (LPTHREAD_START_ROUTINE)EnumDrives, <br>                                   (LPVOID)&amp;glpDrives, <br>                                   0, &amp;dwThreadID); <br> <br>if (!ghDrvThread) { <br>ErrorMsg(TEXT("MainWndProc: CreateThread failed.")); <br>return 0; <br>}        <br>         <br>        // <br>        // Compute default application font by creating a bold version <br>        //   of the system default icon font. <br>        // <br>        if (!SystemParametersInfo(SPI_GETICONTITLELOGFONT,  <br>          sizeof(lf),  <br>          (PVOID) &amp;lf,  <br>          FALSE)) { <br> <br>ErrorMsg(TEXT("MainWndProc: SystemParametersInfo failed.")); <br>return 0; <br>} <br> <br>        hDC = GetDC(hwnd); <br> <br>        if (!hDC) { <br>ErrorMsg(TEXT("MainWndProc: GetDC failed.")); <br>return 0; <br>} <br>         <br>        // <br>        // this is the height for 8 point size font in pixels. <br>        //  (1 point = 1/72 in.) <br>        // <br>        lf.lfHeight = 8 * GetDeviceCaps(hDC, LOGPIXELSY) / 72; <br>        lf.lfWeight = BOLD_FONT; <br> <br>        ghFont = CreateFontIndirect(&amp;lf); <br>if (!ghFont) { <br>ErrorMsg(TEXT("MainWndProc: CreateFontIndirect failed.")); <br>return 0; <br>} <br> <br>        hOldFont = SelectObject(hDC, ghFont); <br> <br>        if (!hOldFont || (HGDIOBJ)hOldFont == (HGDIOBJ)GDI_ERROR) { <br>ErrorMsg(TEXT("MainWndProc: SelectObject failed.")); <br>return 0; <br>} <br> <br>        if (!GetTextMetrics(hDC, &amp;tm)) { <br>ErrorMsg(TEXT("MainWndProc: GetTextMetrics failed.")); <br>return 0; <br>} <br> <br>        if (hOldFont) { <br>hFont = SelectObject(hDC, hOldFont); <br> if (!hFont || (HGDIOBJ)hFont == (HGDIOBJ)GDI_ERROR) { <br> ErrorMsg(TEXT("MainWndProc: SelectObject failed.")); <br> return 0; <br> } <br> }  <br>         <br>        if (!ReleaseDC(hwnd, hDC)) { <br>ErrorMsg(TEXT("MainWndProc: ReleaseDC failed.\r\n")); <br>return 0; <br>} <br> <br>        // <br>        // Create Drive windows <br>        // <br>        gDrvChildInfo.hParent = hwnd; <br>       <br>  ghwndDrv = CreateWindow(TEXT("DrvClass"), NULL, <br>                                 WS_CHILD | WS_CLIPSIBLINGS | WS_VISIBLE, <br>                                 0, 0, 0, 0, <br>                                 hwnd, (HMENU) 1, ghModule, <br>                                 (LPVOID)&amp;gDrvChildInfo); <br> <br>if (!ghwndDrv) { <br>ErrorMsg(TEXT("MainWndProc: CreateWindow failed.")); <br>dwLastError = GetLastError(); <br>return 0; <br>} <br> <br>        ghwndDrv = ghwndDrv; <br> <br>        // <br>        // Set initial focus to Drive Child 1's Directory listbox. <br>        // <br>        lpCInfo = (LPCINFO)GetWindowLong(ghwndDrv, GWL_USERDATA); <br> <br>        if (!lpCInfo) { <br>        ErrorMsg(TEXT("MainWndProc: WM_CREATE: lpCInfo is NULL.")); <br>        return 0; <br>        } <br>         <br>        ghFocusWnd = lpCInfo-&gt;hDirLB; <br> <br>        if (!ghFocusWnd) { <br>        ErrorMsg(TEXT("MainWndProc: GetWindowLong failed.")); <br>return 0; <br>} <br>         <br>        // Create DriveBar, FunctionBar and Command windows <br>         <br>        ghwndDrives = CreateWindow(TEXT("DriveBarClass"), NULL, <br>                                    WS_CHILD | WS_VISIBLE | WS_BORDER, <br>                                   0, 0, 0, 0, <br>                                   hwnd, (HMENU) 3, ghModule, <br>                                   (LPVOID)NULL); <br> <br>        if (!ghwndDrives) { <br>        ErrorMsg(TEXT("MainWndProc: CreateWindow failed.")); <br>        return 0; <br>        } <br> <br>        UpdateDrivesMenu(ghMenu, ghDrvThread); <br>             <br>      return 1; <br>      } <br> <br>      case WM_COMMAND:{ <br> <br>        // <br>        // The menu Identifiers for the drives are (potentially) <br>        // MM_DRIVE_NUM + 0 thru MM_DRIVE_NUM + 25. They all go to the <br>        // same case, so we will put the Menu ID in lParam, and <br>        // MM_DRIVE_NUM in LOWORD(wParam). <br>        // <br>        if( (LOWORD(wParam) - MM_DRIVE_NUM) &lt;= 25 &amp;&amp; <br>            (LOWORD(wParam) - MM_DRIVE_NUM) &gt;= 0 ){ <br>            lParam = LOWORD(wParam); <br>            wParam = MM_DRIVE_NUM; <br>        } <br> <br>        switch (LOWORD(wParam)) { <br>            // <br>            // If a drive is selected from the Drives menu, or clicked <br>            //  on the drives toolbar, the currently active child will <br>            //  switch to this drive. Message 'unconverted' (see top of <br>            //  WM_COMMAND case), and sent to DriveBarProc <br>            // <br>            case MM_DRIVE_NUM:{ <br> <br>                SendMessage(ghwndDrives, WM_COMMAND, <br>                            (WPARAM)lParam, (LPARAM)NULL); <br>                return 1; <br>            } <br> <br>            // <br>            // Passes these WM_COMMAND messages to the appropriate active child <br>            //  window proc for processing <br>            // <br>            case MM_TAB: <br>            case MM_ESCAPE: <br>            case MM_ENCRYPT_DECRYPT: <br>case MM_SIGN: <br>case MM_VERIFY: <br>            case MM_EXPAND:{ <br> <br>                SendMessage(ghwndDrv, WM_COMMAND, wParam, lParam); <br>                return 1; <br>            } <br> <br>            case MM_EXIT:{ <br>                SendMessage(ghwndMain, WM_CLOSE, wParam, lParam); <br>                return 1; <br>            } <br> <br>            // <br>            // Creates the drive enumeration thread to re-enumerate the <br>            //   available drives in the main menu.  Also sends a refresh <br>            //   to the active drive child, and repaints the window. <br>            // <br>            case MM_REFRESH: { <br>                DWORD   dwThreadID; <br> <br>                // <br>                // Initialize/Refresh Drives linked list <br>                // <br> <br>                if( WaitForSingleObject(ghDrvThread, 0) != WAIT_TIMEOUT ){ <br> <br>                    // <br>                    // Close previous Drive Thread handle before creating new handle. <br>                    // <br>                    CloseHandle( ghDrvThread ); <br> <br>                    ghDrvThread = CreateThread(NULL, 0, <br>                                           (LPTHREAD_START_ROUTINE)EnumDrives, <br>                                           (LPVOID)&amp;glpDrives, <br>                                           0, &amp;dwThreadID); <br> <br>                    // <br>                    // Refresh active child, drive toolbar, and drives menu <br>                    // <br>                    SendMessage(ghwndDrv, WM_COMMAND, wParam, lParam); <br>                    SendMessage(ghwndDrives, WM_COMMAND, wParam, lParam); <br>                    UpdateDrivesMenu(ghMenu, ghDrvThread); <br> <br>                    // <br>                    // Mark all for repaint <br>                    // <br>                    InvalidateRect(hwnd,NULL,TRUE); <br> <br>                } <br>                else <br>                    MessageBeep(MB_ICONASTERISK); <br> <br>                return 1; <br>            } <br> <br>            // <br>            // Swaps the directory and file list boxes of the active drv child. <br>            // <br>            case MM_SWAP:{ <br>                LPCINFO lpCInfo; <br>                RECT    rect; <br> <br>                lpCInfo = (LPCINFO)GetWindowLong(ghwndDrv, GWL_USERDATA); <br> <br>                if (!lpCInfo) { <br>                ErrorMsg(TEXT("MainWndProc: MM_SWAP: lpCInfo is NULL.")); <br>                return FALSE; <br>                } <br>                 <br>                // <br>                // Switch the flag which indicates which side the Directory <br>                //  LB is on.  This is used by the WM_SIZE case of DrvWndProc. <br>                // <br>                lpCInfo-&gt;fDirLeft = !lpCInfo-&gt;fDirLeft; <br> <br>                // <br>                // Send size message with current size to active child, <br>                //   in order to redraw the listboxes. <br>                // <br>                if( !GetClientRect( ghwndDrv, &amp;rect ) ) <br>                    return 0; <br> <br>                SendMessage( ghwndDrv, WM_SIZE, SIZENORMAL, <br>                             MAKELONG( rect.right - rect.left, <br>                                       rect.bottom - rect.top) ); <br>                return 1; <br>            } <br> <br>            case MM_KEEPCMD:{ <br> <br>                gfKeepCommandWin = !gfKeepCommandWin; <br> <br>                if( gfKeepCommandWin ) <br>                    CheckMenuItem( ghMenu, MM_KEEPCMD, <br>                                    MF_BYCOMMAND | MF_CHECKED); <br>                else <br>                    CheckMenuItem( ghMenu, MM_KEEPCMD, <br>                                MF_BYCOMMAND | MF_UNCHECKED); <br>            } <br>            break; <br> <br>            // <br>            // Toggles the relative Drive Child orientaion between <br>            // Over/under and side/side.  gfDrvWndOrient is a flag checked <br>            // by WM_SIZE to size Drv children <br>            // <br>            case MM_ORIENT:{ <br>                RECT    rect; <br> <br>                if( gfDrvWndOrient == OVER_UNDER ) <br>                    gfDrvWndOrient = SIDE_BY_SIDE; <br>                else <br>                    gfDrvWndOrient = OVER_UNDER; <br> <br>                // <br>                // Send size message with current size to self (main window), <br>                //   in order to redraw the Drv children. <br>                // <br>                if( !GetClientRect( hwnd, &amp;rect ) ) <br>                    return 0; <br> <br>                SendMessage( hwnd, WM_SIZE, SIZENORMAL, <br>                             MAKELONG( rect.right - rect.left, <br>                                       rect.bottom - rect.top) ); <br> <br>                InvalidateRect(ghwndDrv,NULL,TRUE); <br>            <br>                return 1; <br>            } <br> <br>            // <br>            // Launches the About DialogBox. <br>            // <br>            case MM_ABOUT:{ <br>                if (DialogBox(ghModule,  <br>                  TEXT("AboutBox"),  <br>                  ghwndMain,  <br>                  (DLGPROC)AboutProc) == -1) <br>                         <br>                ErrorMsg(TEXT("Main: About Dialog Creation Error!")); <br>                return 1; <br>            } <br> <br>            case ID_HELP: <br>        if (!WinHelp(hwnd, TEXT("cf.hlp"), HELP_CONTENTS, 0L)) { <br>ErrorMsg(TEXT("MainWndProc: WinHelp failed.")); <br>return 0; <br>} <br> <br>        return 1; <br> <br>case ID_ENCRYPTION_ALGORITHM: <br>bRet = DialogBox(ghModule,  <br>     TEXT("ENCRYPTION_ALGORITHM"),  <br>     ghwndMain,  <br>     EncryptDlgProc); <br>if (bRet == TRUE) <br>InvalidateRect(ghwndMain, NULL, TRUE); <br>else if (bRet == FALSE) <br>return FALSE; <br>return 1;  <br> <br>case ID_SIGNATURE_ALGORITHM: <br>bRet = DialogBox(ghModule, TEXT("HASH_ALGORITHM"), ghwndMain, HashDlgProc); <br>if (bRet == TRUE) <br>InvalidateRect(ghwndMain, NULL, TRUE); <br>else if (bRet == FALSE) <br>return FALSE; <br>return 1; <br> <br>case MM_PASS: <br>AlgidEncrypt = 0; <br>if (!GetPass(ghwndMain) || strlen(sPass) == 0) { <br>AlgidEncrypt = CALG_RC2; <br>return FALSE; <br>} <br>return 1; <br> <br>case ID_HIDE: { <br>DWORD cm; <br> <br>cm = CheckMenuItem(ghMenu, ID_HIDE, MF_CHECKED); <br> <br>if (cm == MF_CHECKED) { <br>if (ShowSignatures()) <br>CheckMenuItem(ghMenu, ID_HIDE, MF_UNCHECKED); <br>} <br>else if (cm == MF_UNCHECKED) { <br>if (HideSignatures()) <br>CheckMenuItem(ghMenu, ID_HIDE, MF_CHECKED); <br>} <br>else { <br>ErrorMsg(TEXT("ID_HIDE: CheckMenuItem failed.")); <br>return 0; <br>} <br> <br>return 1; <br>} <br> <br>default: <br>                return(DefWindowProc(hwnd, message, wParam, lParam)); <br>        } <br>        return 1; <br>      } <br>      // <br>      // Whenever the window is resized, its children have to be <br>      //  resized accordingly.  The GetWindowLong values are the height <br>      //  of the windows queried by this function, and are set in the <br>      //  WM_CREATE cases of their respective WNDPROCs. <br>      // <br>      case WM_SIZE:{ <br>        int DrvWndHeight; <br> <br>        // <br>        // Always put the drives toolbar at the top of the frame window <br>        // <br>        MoveWindow(ghwndDrives, <br>           0, <br>           0, <br>           LOWORD(lParam), <br>           GetWindowLong(ghwndDrives, GWL_USERDATA), <br>           TRUE); <br> <br>        // <br>        // Always size the Drive Children between the Drives and Command <br>        // windows. The width is set so that borders overlap. <br>        // <br> <br>        if( gfDrvWndOrient == OVER_UNDER ){ <br> <br>            DrvWndHeight = ( HIWORD(lParam) - <br>                           GetWindowLong(ghwndDrives, GWL_USERDATA)); <br> <br>            MoveWindow(ghwndDrv, <br>                       -1, <br>                       GetWindowLong(ghwndDrives, GWL_USERDATA), <br>                       (LOWORD(lParam) + 2), <br>                       DrvWndHeight, <br>                       TRUE); <br>        } <br>        else{ <br> <br>            DrvWndHeight = HIWORD(lParam) - <br>                           GetWindowLong(ghwndDrives, GWL_USERDATA); <br> <br>            MoveWindow(ghwndDrv, <br>                        -1, <br>                        GetWindowLong(ghwndDrives, GWL_USERDATA), <br>                        (LOWORD(lParam)/2 + 1)*2, <br>                        DrvWndHeight, <br>                        TRUE); <br>        } <br> <br>        return 1; <br>      } <br> <br>      case WM_DESTROY: { <br>        Logoff(hwnd); <br>        <br>   DeleteHashDirectory(); <br> <br>        free(lpDriveStrings); <br> <br>DestroyMenu(ghMenu); <br>         <br>        SendMessage(ghwndDrv, WM_CLOSE, 0, 0); <br>         <br>        // <br>        // Close last drive thread handle, <br>        //  the created font, and the Drive list critical section. <br>        // <br>        CloseHandle( ghDrvThread ); <br> <br>        DeleteObject(ghFont); <br> <br>        DeleteCriticalSection(&amp;gDrvCS); <br> <br>        PostQuitMessage(0); <br> <br>    return 1; <br>      } <br> <br>      default: <br>        return DefWindowProc(hwnd, message, wParam, lParam); <br>    } <br>} <br> <br>LRESULT WINAPI AboutProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam) <br>{ <br>    switch (message) { <br>      case WM_INITDIALOG:{ <br>        return TRUE; <br>      } <br> <br>      case WM_COMMAND:{ <br>        if (wParam == IDOK) <br>            EndDialog(hDlg, wParam); <br>        break; <br>      } <br>    } <br> <br>    return FALSE; <br> <br>    UNREFERENCED_PARAMETER(lParam); <br>    UNREFERENCED_PARAMETER(hDlg); <br>} <br> <br>/************************************************************************\ <br>* DriveBarProc() <br>* <br>* Drive Toolbar procedure for displaying available drive Icons. <br>*  A bitmap button is displayed corresponding to the drive type of the <br>*  given drive, with the drive letter alongside. <br>*  ghwndDrives is the global handle assoc. w/ this window procedure. <br>\***********************************************************************/ <br> <br>LRESULT WINAPI DriveBarProc (HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam) <br>{ <br>    static HBITMAP  hDrvBmp[NUM_BITMAPS]; <br>    static HBRUSH   hBrush;         // background brush <br>    static int      nDrvEntryWidth; // width of button/letter entry <br>    static int      yVal;           // y value in toolbar for top left of bmp <br>    static LPBINFO  lpDrvButtonRoot; <br>    static int      nActiveDrvIndex; <br> <br>    switch (message) <br>    { <br>        case WM_CREATE:{ <br>            HDC        hDC; <br>            HGDIOBJ    hOldFont; <br>            TEXTMETRIC tm; <br>            LONG       lHeight; <br> <br> <br>            lpDrvButtonRoot = NULL; <br> <br>            // <br>            // Load drive button bitmaps. <br>            // <br>            for(yVal = 0; yVal &lt; NUM_BITMAPS; yVal++) <br>                hDrvBmp[yVal] = LoadBitmap( ghModule, <br>                                      MAKEINTRESOURCE(UB_BMP_MARKER + yVal) ); <br> <br>            // <br>            // Sets background color of Toolbar non-modal dialog children. <br>            // <br>            hBrush = CreateSolidBrush(GetSysColor(COLOR_MENU)); <br> <br>            hDC = GetDC(hwnd); <br> <br>            hOldFont = SelectObject(hDC, ghFont); <br>            GetTextMetrics(hDC, &amp;tm); <br> <br>            // <br>            // base the height of the window on size of text <br>            // <br>            lHeight = tm.tmHeight + GetSystemMetrics(SM_CYBORDER) + 6; <br> <br>            // <br>            // saved the window height, drive button entry width <br>            //   and button y starting value for later reference <br>            // <br>            SetWindowLong(hwnd, GWL_USERDATA, lHeight); <br> <br>            // <br>            // Width of one button entry = spacing, button, sm. space, <br>            //   drive letter, spacing. <br>            // <br>            nDrvEntryWidth = DRIVE_BITMAP_SPACING + DRIVE_BITMAP_WIDTH + <br>                             DRIVE_LETTER_SPACING + tm.tmAveCharWidth + <br>                             DRIVE_BITMAP_SPACING; <br> <br>            // <br>            // Center bitmaps (by height) in drive toolbar. <br>            // <br>            yVal = (lHeight - DRIVE_BITMAP_HEIGHT)/2; <br> <br>            SelectObject(hDC, hOldFont); <br>            ReleaseDC(hwnd, hDC); <br> <br>            SendMessage(hwnd, WM_COMMAND, (WPARAM)MM_REFRESH, (LPARAM)NULL); <br> <br>            break; <br>        } <br> <br>        case WM_COMMAND:{ <br>            // <br>            // The button Identifiers for the drives are (potentially) <br>            // MM_DRIVE_NUM + 0 thru MM_DRIVE_NUM + 25. They all go to the <br>            // same case, so we will put the Menu ID in lParam, and <br>            // MM_DRIVE_NUM in LOWORD(wParam). <br>            // <br>            if( (LOWORD(wParam) - MM_DRIVE_NUM) &lt;= 25 &amp;&amp; <br>                (LOWORD(wParam) - MM_DRIVE_NUM) &gt;= 0 ){ <br>                lParam = LOWORD(wParam); <br>                wParam = MM_DRIVE_NUM; <br>            } <br> <br>            switch( LOWORD(wParam) ){ <br>              case MM_REFRESH:{ <br> <br>                LPDINFO lpWalk; <br>                LPBINFO lpBWalk, lpBHold; <br>                LPCINFO lpCInfo; <br>                int     xVal = 0; <br>intnCount = MM_DRIVE_NUM; <br>                <br>                lpCInfo = (LPCINFO)GetWindowLong(ghwndDrv, GWL_USERDATA); <br> <br>                if (!lpCInfo) { <br>                ErrorMsg(TEXT("DriveBarProc: MM_REFRESH: lpCInfo is NULL.")); <br>                return FALSE; <br>                } <br>                 <br>                // <br>                // Wait for Drive Thread to complete, if necessary. <br>                // <br>                WaitForSingleObject(ghDrvThread, INFINITE); <br>                EnterCriticalSection(&amp;gDrvCS); <br> <br>                // <br>                // Traverse DRVINFO linked list, creating drive buttons and <br>                //   allocating corresp. structures as necessary. <br>                // <br>                lpWalk = glpDrives; <br>                lpBWalk = lpDrvButtonRoot; <br> <br>                while( lpWalk != NULL ){ <br>                if( lpBWalk == NULL ){ //If at the end of the button list <br> <br>                        // Allocate a LPBINFO (button) structure <br> <br>                        lpBWalk = (LPBINFO)malloc((DWORD)sizeof(BINFO)); <br>                         <br>                        if (!lpBWalk) { <br>ErrorMsg(TEXT("DriveBarProc: MM_REFRESH: malloc failed.")); <br>return 0; <br>} <br> <br>                        lpBWalk-&gt;next = NULL; <br> <br>                        // Create a button window <br>                        lpBWalk-&gt;hButton = (HANDLE)CreateWindow(TEXT("BUTTON"), <br>                                                 lpWalk-&gt;DriveName, <br>                                                 WS_CHILD | WS_VISIBLE | <br>                                                 BS_OWNERDRAW , <br>                                                 xVal + DRIVE_BITMAP_SPACING, <br>                                                 yVal, <br>                                                 DRIVE_BITMAP_WIDTH, <br>                                                 DRIVE_BITMAP_HEIGHT, <br>                                                 hwnd, <br>                                                 (HMENU)nCount, <br>                                                 ghModule, <br>                                                 NULL); <br> <br>                        // Insert structure into list <br>                        if( lpDrvButtonRoot == NULL) <br>                            lpDrvButtonRoot = lpBHold = lpBWalk; <br>                        else{ <br>                            lpBHold-&gt;next = lpBWalk; <br>                            lpBWalk-&gt;next = NULL; <br>                        } <br> <br>                    } <br> <br>                    // An LPBINFO (button) structure exists: now initialize <br> <br>                    // Set Title of Button (Drive Letter) <br> <br>                    SetWindowText(lpBWalk-&gt;hButton, lpWalk-&gt;DriveName); <br> <br>                    // Set Child Window ID for Button <br>                    // SetMenu(lpBWalk-&gt;hButton, (HMENU)nCount); <br> <br>                    // Determine button up/down status <br>                    if( lpCInfo-&gt;lpDriveInfo == lpWalk ){ <br>                        nActiveDrvIndex = nCount; <br>                        lpBWalk-&gt;fButtonDown = TRUE; <br>                    } <br>                    else <br>                        lpBWalk-&gt;fButtonDown = FALSE; <br> <br>                    // Set a pointer to the corresponding drive in Drive list <br>                    lpBWalk-&gt;lpDrive = lpWalk; <br> <br>                    nCount++; <br>                    xVal += nDrvEntryWidth; <br>                    lpBHold = lpBWalk; <br>                    lpBWalk = lpBWalk-&gt;next; <br> <br>                    lpWalk = lpWalk-&gt;next; <br>                 <br>                } <br> <br>                LeaveCriticalSection(&amp;gDrvCS); <br> <br>                // <br>                // Free any remaining button windows. <br>                // <br>                while( lpBWalk != NULL ){ <br>                    // NULL out new end of list <br>                    lpBHold-&gt;next = NULL; <br> <br>                    // Assign pointer to doomed node <br>                    lpBHold = lpBWalk; <br>                    lpBWalk = lpBWalk-&gt;next; <br> <br>                    // Free doomed node resources <br>                    if( !DestroyWindow(lpBHold-&gt;hButton) ) <br>                        ErrorMsg(TEXT("DriveBarProc: Drive Button Destroy Error")); <br> <br>                    free(lpBHold); <br>                } <br> <br>                SendMessage(hwnd, WM_PAINT, (WPARAM)NULL, (LPARAM)NULL); <br>                 <br>break; <br>              } <br> <br> <br>              // <br>              // switches the drive button to the newly active drv child's <br>              //   current drive.  Called by WM_MOUSEACTIVATE in DrvWndProc, <br>              //   as well as ChangeDrive. <br>              //   lParam contains the drive linked list pointer of the active <br>              //   drv child's LPCINFO struct. <br>              // <br>              case MM_ACTIVEDRV:{ <br>                LPBINFO lpBWalk = lpDrvButtonRoot; <br>                int     nCount = 0; <br> <br>                // <br>                // 'unpush' old active button <br>                // <br>                for( nCount = MM_DRIVE_NUM; nCount &lt; nActiveDrvIndex; nCount++) <br>                    lpBWalk = lpBWalk-&gt;next; <br>                lpBWalk-&gt;fButtonDown = FALSE; <br> <br>                InvalidateRect(lpBWalk-&gt;hButton, NULL, FALSE); <br> <br>                // <br>                // change active drive to new before redrawing old. <br>                //  'push' new active button <br>                // <br>                lpBWalk = lpDrvButtonRoot; <br>                nCount = MM_DRIVE_NUM; <br>                while( lpBWalk-&gt;lpDrive != (LPDINFO)lParam){ <br>                    lpBWalk = lpBWalk-&gt;next; <br>                    nCount++; <br>                } <br> <br>                nActiveDrvIndex = nCount; <br> <br>                lpBWalk-&gt;fButtonDown = TRUE; <br> <br>                InvalidateRect(lpBWalk-&gt;hButton, NULL, FALSE); <br> <br>                break; <br>              } <br> <br>              // <br>              // Changes drive of active child.  ButtonID in lParam. <br>              // <br>              case MM_DRIVE_NUM:{ <br> <br>                LPBINFO lpBWalk = lpDrvButtonRoot; </code></pre>
<p>
</p>
<pre><code>int     nCount = 0; <br>                TCHAR    szDrvBuff[DIRECTORY_STRING_SIZE]; <br> <br>                // <br>                // if drive chosen is already current drive, leave. <br>                // <br>                if( nActiveDrvIndex == (int)lParam ) <br>                    break; <br> <br>                // <br>                // unpush' old active button <br>                // <br>                for( nCount = MM_DRIVE_NUM; nCount &lt; nActiveDrvIndex; nCount++) <br>                    lpBWalk = lpBWalk-&gt;next; <br>                lpBWalk-&gt;fButtonDown = FALSE; <br> <br>                // <br>                // change active drive to new before redrawing old. <br>                // <br>                nActiveDrvIndex = (int)lParam; <br> <br>                InvalidateRect(lpBWalk-&gt;hButton, NULL, FALSE); <br> <br>                // <br>                // 'push' new active button <br>                // <br>                lpBWalk = lpDrvButtonRoot; <br> <br>                for( nCount = MM_DRIVE_NUM; nCount &lt; nActiveDrvIndex; nCount++) <br>                    lpBWalk = lpBWalk-&gt;next; <br>                lpBWalk-&gt;fButtonDown = TRUE; <br> <br>                InvalidateRect(lpBWalk-&gt;hButton, NULL, FALSE); <br> <br>                GetWindowText(lpBWalk-&gt;hButton, szDrvBuff, <br>                              DIRECTORY_STRING_SIZE); <br> <br>                if( !ChangeDrive(szDrvBuff, (DWORD)nActiveDrvIndex) ){ <br>                    ErrorMsg(TEXT("Error changing Drives.\r\n")); <br>                    return 0; <br>                } <br> <br>                break; <br>              } <br>            } <br>            return 1; <br>        } <br> <br>        // <br>        // Sent by all created buttons for initialization purposes. <br>        // <br>        case WM_MEASUREITEM:{ <br>            LPMEASUREITEMSTRUCT lpMIS; <br> <br>            lpMIS = (LPMEASUREITEMSTRUCT)lParam; <br> <br>            lpMIS-&gt;CtlType = ODT_BUTTON; <br>            lpMIS-&gt;CtlID = (UINT)wParam; <br>            lpMIS-&gt;itemWidth = DRIVE_BITMAP_WIDTH; <br>            lpMIS-&gt;itemHeight = DRIVE_BITMAP_HEIGHT; <br> <br>            return 1; <br>        } <br> <br>        // <br>        // Sent by owner draw drive buttons when needing redrawing. <br>        // <br>        case WM_DRAWITEM:{ <br>            LPBINFO lpBWalk = lpDrvButtonRoot; <br>            int     nCount; <br>            int     nBmpIndex; <br>            HDC     hDC; <br>            HDC     hCompatDC; <br>            HGDIOBJ hOldBitmap; <br>            TCHAR    szDrvBuff[DIRECTORY_STRING_SIZE]; <br>            LPDRAWITEMSTRUCT    lpDIS; <br> <br>            lpDIS = (LPDRAWITEMSTRUCT)lParam; <br> <br>            for( nCount = MM_DRIVE_NUM; nCount &lt; (int)wParam; nCount++) <br>                lpBWalk = lpBWalk-&gt;next; <br> <br>            // <br>            // If not the current selected button, handle button stuff. <br>            // <br>            if( (int)wParam != nActiveDrvIndex ){ <br>                // <br>                // mousebutton is down... <br>                // <br>                if( lpDIS-&gt;itemAction &amp; ODA_SELECT ){ <br>                    // <br>                    // left button region, 'unpush' button <br>                    // <br>                    if( lpDIS-&gt;itemState == (UINT)ODS_FOCUS ) <br>                        lpBWalk-&gt;fButtonDown = FALSE; <br>                    // <br>                    // clicked on a button, draw 'pushed' button <br>                    // <br>                    if( lpDIS-&gt;itemState == (UINT)(ODS_SELECTED | ODS_FOCUS)) <br>                        lpBWalk-&gt;fButtonDown = TRUE; <br>                } <br>            } <br> <br>            // <br>            // draw current state of button. <br>            // <br>            GetWindowText(lpDIS-&gt;hwndItem, szDrvBuff, <br>                          DIRECTORY_STRING_SIZE); <br> <br>            szDrvBuff[1] = TEXT('\0'); <br> <br>            hCompatDC = CreateCompatibleDC(lpDIS-&gt;hDC); <br>            hOldBitmap = CreateCompatibleBitmap(hCompatDC, <br>                                                DRIVE_BITMAP_WIDTH, <br>                                                DRIVE_BITMAP_HEIGHT); <br> <br>            nBmpIndex = GetDriveBitmap(lpBWalk); <br> <br>            SelectObject( hCompatDC, hDrvBmp[nBmpIndex] ); <br> <br>            if( !hOldBitmap ) <br>                ErrorMsg(TEXT("WM_DRAWITEM: SelectObject failure.")); <br> <br>            if( !BitBlt(lpDIS-&gt;hDC, lpDIS-&gt;rcItem.left, lpDIS-&gt;rcItem.top, <br>                   DRIVE_BITMAP_WIDTH, <br>                   DRIVE_BITMAP_HEIGHT, <br>                   hCompatDC, 0, 0, SRCCOPY) ) <br>                ErrorMsg(TEXT("WM_DRAWITEM: BitBlt failure.")); <br> <br> <br>            SelectObject( hCompatDC, hOldBitmap); <br>            DeleteDC(hCompatDC); <br> <br>            hDC = GetDC(hwnd); <br>            SetBkMode(hDC, OPAQUE); <br>            SetTextColor(hDC, GetSysColor(COLOR_MENUTEXT) ); <br>            SetBkColor(hDC, GetSysColor(COLOR_MENU) ); <br> <br>            TextOut(hDC, <br>                    ((int)(wParam - MM_DRIVE_NUM) * nDrvEntryWidth) + <br>                        DRIVE_BITMAP_SPACING + DRIVE_BITMAP_WIDTH + <br>                        DRIVE_LETTER_SPACING, <br>                    (GetSystemMetrics(SM_CYBORDER) + 6)/2, <br>                    szDrvBuff, 1); <br> <br>            SetBkMode(hDC, OPAQUE); <br> <br>            ReleaseDC(hwnd, hDC); <br> <br>DeleteObject(hOldBitmap); <br> <br>            break; <br>        } <br> <br> <br>        case WM_PAINT:{ <br>            HDC     hCompatDC; <br>            RECT     rc; <br>            PAINTSTRUCT ps; <br> <br>            // <br>            // Paint btnshadow background. <br>            // <br>            GetClientRect(hwnd, &amp;rc); <br> <br>            BeginPaint(hwnd, &amp;ps); <br> <br>            hCompatDC = CreateCompatibleDC(ps.hdc); <br>            FillRect(ps.hdc, &amp;rc, hBrush); <br> <br>            EndPaint(hwnd, &amp;ps); <br> <br>            DeleteDC(hCompatDC); <br>             <br>            return(TRUE); <br>        } <br> <br>        case WM_DESTROY:{ <br>            LPBINFO p, q; <br>            LPDINFO p1, q1; <br> <br>            DeleteObject(hBrush); <br> <br>            for (p = lpDrvButtonRoot; p; p = q) { <br>q = p-&gt;next; <br>free(p); <br>} <br>             <br>            for (p1 = glpDrives; p1; p1 = q1) { <br>            q1 = p1-&gt;next; <br>            free(p1); <br>            p1 = NULL; <br>            } <br>             <br>            for(yVal = 0; yVal &lt; NUM_BITMAPS; yVal++) <br>                DeleteObject(hDrvBmp[yVal]); <br> <br>            break; <br>        } <br>    } <br>    return DefWindowProc(hwnd, message, wParam, lParam); <br>} <br> <br>/************************************************************************\ <br>* GetDriveBitmap() <br>* <br>* Determines the appropriate index into the drive button bitmap array <br>* (hDrvBmp[]), given a pointer to a drive info structure (LPDINFO) <br>* <br>* lpWalk          -   pointer to LPDINFO structure. <br>* lpCurrentDrv    -   pointer to current drive of active child. <br>\***********************************************************************/ <br> <br>int GetDriveBitmap(LPBINFO lpBWalk) <br>{ <br>    int nBmpIndex; <br> <br>    EnterCriticalSection(&amp;gDrvCS); <br> <br>    switch( lpBWalk-&gt;lpDrive-&gt;DriveType ){ <br>        case DRIVE_REMOVABLE:{ <br>          nBmpIndex = UB_FLOPPY1 - UB_BMP_MARKER; <br>          break; <br>        } <br> <br>        case DRIVE_REMOTE:{ <br>          nBmpIndex = UB_REMOTE1 - UB_BMP_MARKER; <br>            break; <br>        } <br> <br>        case DRIVE_CDROM:{ <br>          nBmpIndex = UB_CD1 - UB_BMP_MARKER; <br>            break; <br>        } <br> <br>        case DRIVE_FIXED: <br>        default:{ <br>          nBmpIndex = UB_FIXED1 - UB_BMP_MARKER; <br>            break; <br>        } <br>    } <br> <br>    LeaveCriticalSection(&amp;gDrvCS); <br> <br>    if( lpBWalk-&gt;fButtonDown == TRUE ) <br>        nBmpIndex++; <br> <br>    return(nBmpIndex); <br>} <br> <br>/********************************************************************************\ <br>* ChangeDrive() <br>* <br>*   Changes the current drive of the child.  Called by the MM_DRIVE_NUM <br>*   cases in MainWndProc and DriveBarProc.  This is caused by choosing a <br>*   Drive menu item or selecting a drive button from the drive toolbar. <br>* <br>*   lpszDriveName -   points to a buffer containing the name of the drive <br>*   DriveID       -   points to the ID of the Menu item or button, which <br>*                         corresponds to the index into the drives linked list <br>*                         of the new drive. <br>\********************************************************************************/ <br> <br>BOOL ChangeDrive(LPTSTR lpszDriveName, DWORD DriveIndex) <br>{ <br>    LPCINFO     lpCInfo; <br>    LPDINFO     lpWalk; <br>    DWORD       dwLoop; <br>    UINT        nDriveType; <br> <br>    // <br>    // Retrieve active child handle. <br>    // <br>    if( (ghwndDrv != ghwndDrv) ){ <br>        ErrorMsg(TEXT("A Drive Window Must be Active.")); <br>        return 0; <br>    } <br> <br>    // <br>    // Retrieving the child window's DRVCHILDINFO data <br>    // <br>    lpCInfo = (LPCINFO)GetWindowLong(ghwndDrv, GWL_USERDATA); <br> <br>    if (!lpCInfo) { <br>    ErrorMsg(TEXT("ChangeDrive: lpCInfo is NULL.")); <br>    return FALSE; <br>    } <br>     <br>    // <br>    // Enter Drive list critical section <br>    // <br>    EnterCriticalSection(&amp;gDrvCS); <br> <br>    // <br>    // if removable drive, check for existing media. <br>    // <br>    nDriveType = GetDriveType(lpszDriveName); <br>    if( nDriveType == DRIVE_REMOVABLE || <br>        nDriveType == DRIVE_CDROM ){ <br>        dwLoop = (DWORD)IDOK; <br> <br>        while( !CheckRM(lpszDriveName) &amp;&amp; (dwLoop == (DWORD)IDOK) ){ <br> <br>           dwLoop = (DWORD)MessageBox(ghwndMain, <br>                           TEXT("CRYPTFILER: Insert some media in drive"), <br>                           lpszDriveName, MB_OKCANCEL); <br>        } <br> <br>        if( dwLoop == (DWORD)IDCANCEL ){ <br>            SendMessage(ghwndDrives, WM_COMMAND, MM_ACTIVEDRV, <br>                        (LPARAM)lpCInfo-&gt;lpDriveInfo); <br>        LeaveCriticalSection(&amp;gDrvCS); <br>            return 0; <br>        } <br>    } <br> <br>    // <br>    // set lpDriveInfo member to associated drive struct. <br>    // <br>    lpWalk = glpDrives; <br>    for( dwLoop = 0; dwLoop &lt; DriveIndex - MM_DRIVE_NUM; <br>         dwLoop++) <br>         lpWalk = lpWalk-&gt;next; <br> <br>    lpCInfo-&gt;lpDriveInfo = lpWalk; <br> <br>    lstrcpy(lpCInfo-&gt;CaptionBarText, lpWalk-&gt;DriveName); <br> <br>    LeaveCriticalSection(&amp;gDrvCS); <br> <br>    // <br>    // This will terminate any currently running drive thread. <br>    // <br>    SendMessage(ghwndDrv, WM_COMMAND, MM_ESCAPE, (LPARAM)0); <br>    lpCInfo-&gt;fEscape = FALSE; <br> <br>    // <br>    // enact the drive change. <br>    // <br>    PostMessage(ghwndDrv, WM_COMMAND, MM_REFRESH, (LPARAM)0); <br> <br>    return 1; <br>} <br> <br>/********************************************************************************\ <br>* UpdateDrivesMenu() <br>* <br>* Adds current drives from the glpDrives linked list to the TEXT('Drives') menu <br>* <br>* Input: hDrivesMenu - handle to TEXT('Drives') Menu <br>*        hThread    - used to wait for drives thread to terminate <br>\********************************************************************************/ <br> <br>BOOL UpdateDrivesMenu(HMENU hMenu, HANDLE hThread) <br>{ <br>    HMENU   hDrivesMenu; <br>    int     NumMenuItems; <br>    DWORD   dwLoop; <br>    LPDINFO lpWalk; <br> <br>    // <br>    // Remove list of drive menu items from Drive menu, if any. <br>    // <br>    hDrivesMenu = GetSubMenu( hMenu, DRIVE_MENU_NUM); <br>    if(!hDrivesMenu){ <br>        ErrorMsg(TEXT("UpdateDrivesMenu: GetSubMenu error.")); <br>        return FALSE; <br>    } <br> <br>    if((NumMenuItems = GetMenuItemCount(hDrivesMenu)) == -1) { <br>        ErrorMsg(TEXT("Main Refresh: Menu Item Count Error.")); <br>return FALSE; <br>} <br> <br>    // <br>    // Delete previous menu items. <br>    // <br>    for( dwLoop = 0; dwLoop &lt; (DWORD)NumMenuItems; dwLoop++) <br>        if(!DeleteMenu(hDrivesMenu, 0, MF_BYPOSITION)){ <br>            ErrorMsg(TEXT("Main Refresh: Menu Item Delete Error.")); <br>            return FALSE; <br>        } <br> <br>    // <br>    // Wait for Enumdrv Thread to terminate, and <br>    //   enter drive list critical section <br>    // <br>    if (WaitForSingleObject(hThread, INFINITE) == WAIT_FAILED) { <br>ErrorMsg(TEXT("UpdateDrivesMenu: WaitForSingleObject failed.")); <br>return FALSE; <br>} <br> <br>    EnterCriticalSection(&amp;gDrvCS); <br> <br>    // <br>    // Fill drive menu from glpDrives linked list <br>    // <br>    NumMenuItems = 0; <br>    lpWalk = glpDrives; <br> <br>    while(lpWalk != NULL){ <br>        if(!InsertMenu(hDrivesMenu, NumMenuItems, MF_STRING | MF_BYPOSITION  <br>        | MF_ENABLED, MM_DRIVE_NUM + NumMenuItems, lpWalk-&gt;DriveName)) { <br>            ErrorMsg(TEXT("Main Refresh: Menu Item Insert Error.")); <br>return FALSE; <br>} <br>        NumMenuItems++; <br>        lpWalk = lpWalk-&gt;next; <br>    } <br> <br>    LeaveCriticalSection(&amp;gDrvCS); <br> <br>    return TRUE; <br>} <br> <br>/***************************************************************\ <br>* ErrorMsg() <br>* <br>*   Displays a Message Box with a given error message. <br>* <br>\***************************************************************/ <br> <br>void ErrorMsg(LPTSTR szMsg) <br>{ <br>    TCHAR szHold[DIRECTORY_STRING_SIZE + 1]; <br> <br>    lstrcpy( szHold, szMsg ); <br>    lstrcat( szHold, TEXT("\n") ); <br> <br>   OutputDebugString(szHold); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
