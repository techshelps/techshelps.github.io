<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DECRYPT.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6162"></a>DECRYPT.C</h2>
<pre><code>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples.  <br>*       Copyright 1996 - 1998 Microsoft Corporation. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;wincrypt.h&gt; <br> <br>#ifdef USE_BLOCK_CIPHER <br>    // defines for RC2 block cipher <br>    #define ENCRYPT_ALGORITHMCALG_RC2 <br>    #define ENCRYPT_BLOCK_SIZE8 <br>#else <br>    // defines for RC4 stream cipher <br>    #define ENCRYPT_ALGORITHMCALG_RC4 <br>    #define ENCRYPT_BLOCK_SIZE1 <br>#endif <br> <br>static BOOL CAPIDecryptFile(PCHAR szSource, PCHAR szDestination, PCHAR szPassword); <br> <br>/*****************************************************************************/ <br>void _cdecl main(int argc, char *argv[]) <br>{ <br>    PCHAR szSource= NULL; <br>    PCHAR szDestination = NULL; <br>    PCHAR szPassword= NULL; <br> <br>    // Validate argument count. <br>    if(argc != 3 &amp;&amp; argc != 4) { <br>printf("USAGE: decrypt &lt;source file&gt; &lt;dest file&gt; [ &lt;password&gt; ]\n"); <br>exit(1); <br>    } <br> <br>    // Parse arguments. <br>    szSource   = argv[1]; <br>    szDestination  = argv[2]; <br>    if(argc == 4) { <br>szPassword = argv[3]; <br>    } <br> <br>    if(!CAPIDecryptFile(szSource, szDestination, szPassword)) { <br>printf("Error encrypting file!\n"); <br>exit(1); <br>    } <br> <br>    exit(0); <br>} <br> <br>/*****************************************************************************/ <br>static BOOL CAPIDecryptFile(PCHAR szSource, PCHAR szDestination, PCHAR szPassword) <br>{ <br>    FILE *hSource      = NULL; <br>    FILE *hDestination = NULL; <br>    INT eof = 0; <br> <br>    HCRYPTPROV hProv   = 0; <br>    HCRYPTKEY hKey     = 0; <br>    HCRYPTHASH hHash   = 0; <br> <br>    PBYTE pbKeyBlob = NULL; <br>    DWORD dwKeyBlobLen; <br> <br>    PBYTE pbBuffer = NULL; <br>    DWORD dwBlockLen; <br>    DWORD dwBufferLen; <br>    DWORD dwCount; <br> <br>    BOOL status = FALSE; <br> <br>    // Open source file. <br>    if((hSource = fopen(szSource,"rb")) == NULL) { <br>printf("Error opening Ciphertext file!\n"); <br>        goto done; <br>    } <br> <br>    // Open destination file. <br>    if((hDestination = fopen(szDestination,"wb")) == NULL) { <br>printf("Error opening Plaintext file!\n"); <br>        goto done; <br>    } <br> <br>    // Get handle to the default provider. <br>    if(!CryptAcquireContext(&amp;hProv, NULL, NULL, PROV_RSA_FULL, 0)) { <br>        printf("Error %x during CryptAcquireContext!\n", GetLastError()); <br>        goto done; <br>    } <br> <br>    if(szPassword == NULL) { <br>// Decrypt the file with the saved session key. <br> <br>// Read key blob length from source file and allocate memory. <br>fread(&amp;dwKeyBlobLen, sizeof(DWORD), 1, hSource); <br>if(ferror(hSource) || feof(hSource)) { <br>    printf("Error reading file header!\n"); <br>    goto done; <br>} <br>if((pbKeyBlob = malloc(dwKeyBlobLen)) == NULL) { <br>    printf("Out of memory or improperly formatted source file!\n"); <br>    goto done; <br>} <br> <br>// Read key blob from source file. <br>fread(pbKeyBlob, 1, dwKeyBlobLen, hSource); <br>if(ferror(hSource) || feof(hSource)) { <br>    printf("Error reading file header!\n"); <br>    goto done; <br>} <br> <br>// Import key blob into CSP. <br>if(!CryptImportKey(hProv, pbKeyBlob, dwKeyBlobLen, 0, 0, &amp;hKey)) { <br>    printf("Error %x during CryptImportKey!\n", GetLastError()); <br>    goto done; <br>} <br>    } else { <br>// Decrypt the file with a session key derived from a password. <br> <br>// Create a hash object. <br>if(!CryptCreateHash(hProv, CALG_MD5, 0, 0, &amp;hHash)) { <br>    printf("Error %x during CryptCreateHash!\n", GetLastError()); <br>    goto done; <br>} <br> <br>// Hash in the password data. <br>if(!CryptHashData(hHash, szPassword, strlen(szPassword), 0)) { <br>    printf("Error %x during CryptHashData!\n", GetLastError()); <br>    goto done; <br>} <br> <br>// Derive a session key from the hash object. <br>if(!CryptDeriveKey(hProv, ENCRYPT_ALGORITHM, hHash, 0, &amp;hKey)) { <br>    printf("Error %x during CryptDeriveKey!\n", GetLastError()); <br>    goto done; <br>} <br> <br>// Destroy the hash object. <br>CryptDestroyHash(hHash); <br>hHash = 0; <br>    } <br> <br>    // Determine number of bytes to decrypt at a time. This must be a multiple <br>    // of ENCRYPT_BLOCK_SIZE. <br>    dwBlockLen = 1000 - 1000 % ENCRYPT_BLOCK_SIZE; <br>    dwBufferLen = dwBlockLen; <br> <br>    // Allocate memory. <br>    if((pbBuffer = malloc(dwBufferLen)) == NULL) { <br>printf("Out of memory!\n"); <br>goto done; <br>    } <br> <br>    // Decrypt source file and write to destination file. <br>    do { <br>// Read up to 'dwBlockLen' bytes from source file. <br>dwCount = fread(pbBuffer, 1, dwBlockLen, hSource); <br>if(ferror(hSource)) { <br>    printf("Error reading Ciphertext!\n"); <br>            goto done; <br>        } <br>eof = feof(hSource); <br> <br>        // Decrypt data <br>        if(!CryptDecrypt(hKey, 0, eof, 0, pbBuffer, &amp;dwCount)) { <br>            printf("Error %x during CryptDecrypt!\n", GetLastError()); <br>            goto done; <br>        } <br> <br>        // Write data to destination file. <br>fwrite(pbBuffer, 1, dwCount, hDestination); <br>if(ferror(hDestination)) { <br>    printf("Error writing Plaintext!\n"); <br>            goto done; <br>        } <br>    } while(!feof(hSource)); <br> <br>    status = TRUE; <br> <br>    printf("OK\n"); <br> <br>    done: <br> <br>    // Close files. <br>    if(hSource) fclose(hSource); <br>    if(hDestination) fclose(hDestination); <br> <br>    // Free memory. <br>    if(pbKeyBlob) free(pbKeyBlob); <br>    if(pbBuffer) free(pbBuffer); <br> <br>    // Destroy session key. <br>    if(hKey) CryptDestroyKey(hKey); <br> <br>    // Destroy hash object. <br>    if(hHash) CryptDestroyHash(hHash); <br> <br>    // Release provider handle. <br>    if(hProv) CryptReleaseContext(hProv, 0); <br> <br>    return(status); <br>} <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
