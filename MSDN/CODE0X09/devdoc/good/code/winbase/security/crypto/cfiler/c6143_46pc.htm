<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>ENUMDRV.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6150"></a>ENUMDRV.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples.  <br>*       Copyright 1996 - 1998 Microsoft Corporation. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>//    PROGRAM: ENUMDRV.C <br>// <br>//    PURPOSE: Determines all drives in the system, both local and remote, <br>//             and their file system type <br>// <br> <br>#define  STRICT <br> <br>#include "cfiler.h" <br> <br>LPTSTR lpDriveStrings = NULL; <br>extern CRITICAL_SECTION gDrvCS;  // Drive list critical section var. <br>extern LPDINFO          glpDrives; <br> <br>/********************************************************************************\ <br>*    FUNCTION: CheckRM(LPTSTR) <br>* <br>*    PURPOSE: Verifies that a removeable media drive contains a disk <br>* <br>*    COMMENTS: <br>* <br>*        This function is called each time a drive type is determined to be <br>*        removeable (DRIVE_REMOVEABLE).  An attempt is made to open a <br>*        file in the root directory of the drive.  If the attempt succeeds, <br>*        then media is present in the drive and subsequent calls to the <br>*        drive can be safely made.  If the call fails, then there is no media <br>*        present in the drive and no attempts should be made to access this <br>*        drive.  The Error Mode is temporarily set to 1 to allow failures <br>*        to immediately return to the calling program.  This eliminates <br>*        unwanted dialog boxes that prompt for disks to be placed in the <br>*        drive. <br>* <br>*    INPUT: szDriveName - removeable media drive name (ex - "a:") <br>* <br>*    OUTPUT: Returns TRUE if media present <br>*                    FALSE if media is not present <br>\*********************************************************************************/ <br> <br>BOOL CheckRM( LPTSTR lpszDriveName ) <br>{ <br>    TCHAR    szFileName[DIRECTORY_STRING_SIZE]; <br>    DWORD    dwHold; <br> <br>    SetErrorMode( SEM_FAILCRITICALERRORS ); <br> <br>    lstrcpy( szFileName, lpszDriveName ); <br>    lstrcat( szFileName, TEXT(".") ); <br> <br>    dwHold = GetFileAttributes( szFileName ); <br> <br>    SetErrorMode( 0 ); <br> <br>    //  If no error, media must be in drive. <br>    if( dwHold != 0xFFFFFFFF ){ <br>        return(TRUE); <br>    } <br>    else{ <br>        dwHold = GetLastError(); <br>        if( dwHold != ERROR_NOT_READY ) <br>            ErrorMsg(TEXT("CheckRM: Get Removable Media Info Failure.")); <br> <br>        return(FALSE); <br>    } <br> <br>} <br> <br>/*********************************************************************************\ <br>*    FUNCTION: DWORD EnumDrives(*LPDINFO) <br>* <br>*    PURPOSE: Enumerates available drives, and information on them. If the <br>*               DINFO structure passed in is NULL, it creates a linked list <br>*               of DINFO structures, reporting information on each available <br>*              drive.  If DINFO points to an existing structure, the list <br>*              is updated. <br>* <br>*   COMMENTS: <br>*       The number of available drives is first determined by a call to <br>*       GetLogicalDrives.  This provides a bit mask of all logical drives. <br>* <br>*       For each logical drive, a call is made to GetDriveType to determine <br>*       the drive type.  If the logical drive is not in the bit mask that <br>*       was created with the GetLogicalDrives call, then this drive is <br>*       bypassed. <br>* <br>*   INPUT:  LPDINFO dINfo: A pointer to a DRVINFO Structure. <br>* <br>*   OUTPUT: Returns the number of DINFO structures in the linked <br>*           list pointed to by dInfo.  Value is negative if error. <br>\**********************************************************************************/ <br> <br>void EnumDrives(LPDINFO *lplpRoot) <br>{ <br>  DWORD         dwDriveMask; <br>  DWORD         dwCount; <br>  LPTSTR        lpszRootPathName=TEXT("?:\\"); <br>   <br>  LPTSTR        lpParse; <br> <br>  LPDINFO       lpDInfo = (LPDINFO)0,                // new node ptr <br>                lpHold = (LPDINFO)0,                 // list walking ptrs <br>                lpBack = (LPDINFO)0, <br>                lpRoot = *lplpRoot;     // root ptr <br> <br> <br>  EnterCriticalSection(&amp;gDrvCS); <br> <br>  dwCount=GetLogicalDriveStrings( 0, lpDriveStrings); <br>  if( !dwCount ){ <br>    LeaveCriticalSection(&amp;gDrvCS); <br>    ErrorMsg(TEXT("EnumDrives: Get Drive Strings error")); <br>    ExitThread((DWORD)-1); <br>  } <br> <br>  // allocate memory, +1 for trailing NULL <br>  lpDriveStrings = (LPTSTR)malloc((dwCount + 1) * sizeof(TCHAR)); <br>  <br>  if( lpDriveStrings == NULL){ <br>      LeaveCriticalSection(&amp;gDrvCS); <br>      ErrorMsg(TEXT("EnumDrives: Allocation error")); <br>      ExitThread((DWORD)-2); <br>  } <br> <br>  if(dwCount &lt; GetLogicalDriveStrings( dwCount, lpDriveStrings) ){ <br>      LeaveCriticalSection(&amp;gDrvCS); <br>      ErrorMsg(TEXT("EnumDrives: Drive String size Changed!")); <br>      ExitThread((DWORD)-3); <br>  } <br>  lpParse = lpDriveStrings; <br> <br>  dwDriveMask=GetLogicalDrives(); <br> <br>  // <br>  // walk list, inserting, deleting, &amp; updating nodes as necessary <br>  // <br>  dwCount = 0; <br>  lpHold = lpBack = lpRoot; <br> <br>  for (*lpszRootPathName=TEXT('a');*lpszRootPathName&lt;=TEXT('z');(*lpszRootPathName)++){ <br>    if (dwDriveMask &amp; 1){   // drive exists. Insert or update. <br> <br>      dwCount++; <br> <br>      // <br>      // if lpHold (the list walking ptr) is NULL, or the drive that exists <br>      //  does not already have a node in the list, allocate a node. <br>      // <br>      if( !lpHold || lpHold-&gt;DriveLetter &gt; *lpszRootPathName ){ <br>        // <br>        // Allocating memory for DRVINFO node <br>        // <br>        lpDInfo = (LPDINFO) malloc((DWORD)sizeof(DRVINFO)); <br>       <br>        if( lpDInfo == NULL){ <br>          LeaveCriticalSection(&amp;gDrvCS); <br>          ErrorMsg(TEXT("EnumDrives: DRVINFO Allocation error")); <br>          ExitThread((DWORD)-4); <br>        } <br> <br>        // <br>        // insert new node into list <br>        // <br>        if( lpHold == lpRoot ){ <br>          lpDInfo-&gt;next = lpRoot; <br>          lpRoot = lpDInfo; <br>        } <br>        else{ <br>          lpDInfo-&gt;next = lpBack-&gt;next; <br>          lpBack-&gt;next = lpDInfo; <br>        } <br> <br>        lpBack = lpDInfo; <br>        lpHold = lpDInfo-&gt;next; <br> <br>        lpDInfo-&gt;DriveLetter = *lpszRootPathName; <br>      } <br>      else{ <br>        if( lpBack != lpHold ) <br>          lpBack = lpBack-&gt;next; <br>        lpHold = lpHold-&gt;next; <br>      } <br> <br>      lpBack-&gt;DriveType = GetDriveType(lpszRootPathName); <br>      <br>      lpBack-&gt;DriveName = lpParse; <br>      lpParse += lstrlen(lpParse)+1; <br>    } <br>    else{               // drive does not exist. <br>      if( lpHold )      //   if node exists, delete it. <br>        if( lpHold-&gt;DriveLetter == *lpszRootPathName ){ <br>          if( lpHold == lpRoot ) <br>            lpRoot = lpBack = lpHold-&gt;next; <br>          else <br>            lpBack-&gt;next = lpHold-&gt;next; <br> <br>          free((LPVOID)lpHold); <br> <br>          lpHold = lpBack-&gt;next; <br>        } <br>    } <br>    dwDriveMask &gt;&gt;= 1; <br>   <br>  } // end for <br> <br>  *lplpRoot = lpRoot; <br>   <br>  LeaveCriticalSection(&amp;gDrvCS); <br>    <br>  ExitThread(dwCount); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
