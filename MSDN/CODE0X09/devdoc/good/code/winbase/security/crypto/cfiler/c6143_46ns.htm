<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DRVPROC.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6148"></a>DRVPROC.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples.  <br>*       Copyright 1996 - 1998 Microsoft Corporation. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>// DRVPROC.C <br> <br>#include "cfiler.h" <br> <br>extern HANDLE   ghModule; <br>extern HANDLEghwndMain; <br>extern HFONT    ghFont; <br>extern HANDLE   ghDrvThread; <br>extern HANDLE   ghMenu; <br>extern HWND     ghwndDrives; <br>extern HWND   ghwndDrv; <br>extern HWND     ghFocusWnd; <br>extern LPDINFO  glpDrives; <br>extern CRITICAL_SECTION    gDrvCS;    <br> <br>/**********************************************************************\ <br>* DrawItem() <br>* <br>* in parmeters <br>* lpdis - Information the owner window must have to determine how  <br>* to paint the owner-draw listbox <br>* <br>* Calls DrawText to output a string with the right color in the <br>* rectangle contained in lpdis <br>\**********************************************************************/ <br> <br>VOID APIENTRY DrawItem(LPDRAWITEMSTRUCT lpdis) { <br>COLORREF crOldColor; <br>TCHARszFile[256]; <br>INT i, nLen; <br>TCHAR szBuf[275]; <br>TEXTMETRIC tm; <br>RECT rc; <br> <br>if (!lpdis) { <br>ErrorMsg(TEXT("DrawEntireItem: lpdis is NULL.")); <br>return; <br>} <br> <br>GetTextMetrics(lpdis-&gt;hDC, &amp;tm); <br> <br>  // Filenames such as Q&amp;A.DOC should look correct. <br>   <br>  ReplaceEscapeCharacters((LPTSTR)lpdis-&gt;itemData, szBuf); <br> <br>nLen = lstrlen(szBuf); <br> <br>if (nLen &gt; HEADER_SIZE) { <br>ErrorMsg(TEXT("fnKey has been Destroyed!")); <br>crOldColor = SetTextColor(lpdis-&gt;hDC, RGB(140, 140, 140)); <br>CopyRect(&amp;rc, &amp;lpdis-&gt;rcItem); <br>       rc.left += 1; <br>       lstrcpy(szFile, TEXT("RecoverMe")); <br>       DrawText(lpdis-&gt;hDC, szFile, lstrlen(szFile), (LPRECT)&amp;rc, DT_LEFT); <br>          SetTextColor(lpdis-&gt;hDC, crOldColor); <br>return; <br>} <br> <br>if (szBuf[0] == TEXT('|')) { <br> <br>// This is an encrypted file. Select gray as the color. <br> <br>crOldColor = SetTextColor(lpdis-&gt;hDC, RGB(140, 140, 140)); <br> <br>for (i = 0; i &lt; nLen - 1; i++) <br>szFile[i] = szBuf[i + 1]; <br> <br>szFile[i] = TEXT('\0'); <br>} <br>else if (szBuf[0] == TEXT('&gt;')) { <br> <br>// This is an encrypted and signed file. <br> <br>crOldColor = SetTextColor(lpdis-&gt;hDC, RGB(255, 140, 140)); <br> <br>for (i = 0; i &lt; nLen - 1; i++) <br>szFile[i] = szBuf[i + 1]; <br> <br>szFile[i] = TEXT('\0'); <br>} <br>else if (szBuf[0] == TEXT(';')) { <br> <br>// This is a signed only file. <br> <br>crOldColor = SetTextColor(lpdis-&gt;hDC, RGB(255, 0, 0)); <br> <br>for (i = 0; i &lt; nLen - 1; i++) <br>szFile[i] = szBuf[i + 1]; <br> <br>szFile[i] = TEXT('\0'); <br>} <br>else  <br>lstrcpy(szFile, szBuf); <br>               <br>       CopyRect(&amp;rc, &amp;lpdis-&gt;rcItem); <br>        <br>       rc.left += 1; <br>        <br>       DrawText(lpdis-&gt;hDC, szFile, lstrlen(szFile), (LPRECT)&amp;rc, DT_LEFT); <br>      <br>if (szBuf[0] == TEXT('|') || szBuf[0] == TEXT('&gt;') || szBuf[0] == TEXT(';')) <br>       SetTextColor(lpdis-&gt;hDC, crOldColor); <br> <br>       return; <br>} <br> <br>/**********************************************************************\ <br>* HandleSelectionState() <br>* <br>* in parmeters <br>* lpdis - Information the owner window must have to determine how  <br>* to paint the owner-draw listbox <br>* <br>* purpose: <br>* Handles a change in an item selection state. This function must <br>* check the current background color for the rectangle contained <br>* in the DRAWITEMSTRUCT pointer, lpdis. The background color and <br>* text color must be changed appropriately. <br>\**********************************************************************/ <br> <br>VOID APIENTRY HandleSelectionState(LPDRAWITEMSTRUCT lpdis) <br>{ <br>     if (!lpdis) { <br>     ErrorMsg(TEXT("HandleSelectionState: lpdis is NULL.")); <br>     return; <br>     } <br>      <br>     if (lpdis-&gt;itemState &amp; ODS_SELECTED) { <br> if (GetBkColor(lpdis-&gt;hDC) == GetSysColor(COLOR_HIGHLIGHT)) { <br>return; <br>} <br>else { <br>SetTextColor(lpdis-&gt;hDC, GetSysColor(COLOR_HIGHLIGHTTEXT)); <br>SetBkColor(lpdis-&gt;hDC, GetSysColor(COLOR_HIGHLIGHT)); <br>DrawItem(lpdis); <br>return; <br>} <br>} <br>else { <br>if (GetBkColor(lpdis-&gt;hDC) != GetSysColor(COLOR_WINDOW)) { <br>return; <br>} <br>else { <br>SetTextColor(lpdis-&gt;hDC, GetSysColor(COLOR_WINDOWTEXT)); <br>SetBkColor(lpdis-&gt;hDC, GetSysColor(COLOR_WINDOW)); <br>DrawItem(lpdis); <br>return; <br>} <br>} <br>} <br> <br>/**********************************************************************\ <br>* DrawEntireItem() <br>* <br>* in parmeters <br>* lpdis - Information the owner window must have to determine how  <br>* to paint the owner-draw listbox <br>* <br>* Sets the background color and the text color and calls DrawItem() <br>\**********************************************************************/ <br> <br>VOID APIENTRY DrawEntireItem(LPDRAWITEMSTRUCT lpdis) <br>{ <br>        if (!lpdis) { <br>        ErrorMsg(TEXT("DrawEntireItem: lpdis is NULL.")); <br>        return; <br>        } <br>         <br>        SetBkColor(lpdis-&gt;hDC, GetSysColor(COLOR_WINDOW)); <br>        SetTextColor(lpdis-&gt;hDC, GetSysColor(COLOR_WINDOWTEXT)); <br> <br>        DrawItem(lpdis); <br>          <br>    __try { <br>        if (!lpdis) { <br>        ErrorMsg(TEXT("DrawEntireItem: lpdis is NULL.")); <br>        return; <br>        } <br>         <br>        if (!lpdis-&gt;itemData) { <br>        ErrorMsg(TEXT("DrawEntireItem: lpdis-&gt;itemData is NULL.")); <br>        return; <br>        } <br>        } <br>        __except (EXCEPTION_EXECUTE_HANDLER) { <br>        ErrorMsg(TEXT("DrawEntireItem: lpdis is BOGUS.")); <br>        return; <br>        } <br>         <br>        /* Draw or erase appropriate frames */ <br>        __try { <br>        HandleSelectionState(lpdis); <br>} <br>__except (EXCEPTION_EXECUTE_HANDLER) { <br>ErrorMsg(TEXT("DrawEntireItem: Attempt to call HandleSelectionState raised an exception.")); <br>return; <br>} <br>} <br> <br>LRESULT  WINAPI DrvWndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam) { <br>    LPDRAWITEMSTRUCT lpdis; <br>    LPMEASUREITEMSTRUCT lpmis; <br>    LPCOMPAREITEMSTRUCT lpcis; <br>     <br>    DWORD dwDirStyle = WS_BORDER | WS_CHILD | WS_VISIBLE | <br>                              LBS_NOINTEGRALHEIGHT | LBS_NOTIFY | <br>                              LBS_HASSTRINGS | LBS_WANTKEYBOARDINPUT | <br>                              LBS_DISABLENOSCROLL | WS_HSCROLL | <br>                              WS_VSCROLL |LBS_USETABSTOPS; <br> <br>    DWORD dwFileStyle = WS_BORDER | WS_CHILD | WS_VISIBLE | <br>                              LBS_NOINTEGRALHEIGHT | LBS_NOTIFY | <br>                             LBS_OWNERDRAWFIXED | LBS_WANTKEYBOARDINPUT | <br>                              LBS_DISABLENOSCROLL | WS_HSCROLL | <br>                              LBS_EXTENDEDSEL | LBS_MULTIPLESEL | <br>                              LBS_MULTICOLUMN | LBS_SORT; <br> <br>    switch (message){ <br> <br>        // <br>        // Creates the text and listbox windows for this Drv child and <br>        //  saves its handle in the per Drv child DRVCHILDINFO data structure. <br>        // <br>        case WM_CREATE: { <br>            LPCINFO lpCInfo; <br> <br>            DWORD   dwLoop; <br> <br>            LPDINFO lpWalk; <br> <br>            LONG    lTabs = LISTBOX_TAB_SIZE; <br> <br>            // <br>            // Initialize DRVCHILDINFO structure <br>            // <br>            lpCInfo = (LPCINFO) ((LPCREATESTRUCT) lParam)-&gt;lpCreateParams; <br> <br>            if (!lpCInfo) { <br>            ErrorMsg(TEXT("DrvWndProc: lpCInfo is NULL.")); <br>            return 0; <br>         } <br>          <br>         lpCInfo-&gt;hwnd = hwnd; <br> <br>            // Create text window <br>            lpCInfo-&gt;hTextWnd = CreateWindow(TEXT("TextClass"), NULL, <br>                                   SS_LEFT | WS_CHILD | WS_VISIBLE | WS_BORDER, <br>                                    0, 0, 0, 0, <br>                                    lpCInfo-&gt;hwnd, <br>                                    (HMENU) TEXT_WINDOW_ID, <br>                                    ghModule, <br>                                    NULL); <br> <br>            if (!lpCInfo-&gt;hTextWnd) { <br>            ErrorMsg(TEXT("DrvWndProc: WM_CREATE: CreateWindow failed.")); <br>            return 0; <br>            } <br>             <br>            // Create Directory and File List boxes <br>            lpCInfo-&gt;hDirLB = CreateWindow(TEXT("LISTBOX"), NULL, <br>                                    dwDirStyle, <br>                                    0, 0, 0, 0, <br>                                    lpCInfo-&gt;hwnd, <br>                                    (HMENU) LISTDIR_ID, <br>                                    ghModule, <br>                                    NULL); <br> <br>            if (!lpCInfo-&gt;hDirLB) { <br>            ErrorMsg(TEXT("DrvWndProc: WM_CREATE: CreateWindow failed.")); <br>            return 0; <br>            } <br>             <br>            // Create directory listbox string table. <br>             <br>            lpCInfo-&gt;DirTable = TableNew(); <br> <br>if (!lpCInfo-&gt;DirTable) { <br>ErrorMsg(TEXT("WM_CREATE: TableNew failed.")); <br>return 0; <br>} <br>             <br>            lpCInfo-&gt;hFileLB = CreateWindow(TEXT("LISTBOX"), NULL, <br>                                    dwFileStyle, <br>                                    0, 0, 0, 0, <br>                                    lpCInfo-&gt;hwnd, <br>                                    (HMENU) LISTFILE_ID, <br>                                    ghModule, <br>                                    NULL); <br>             <br>            if (!lpCInfo-&gt;hFileLB) { <br>            ErrorMsg(TEXT("DrvWndProc: WM_CREATE: CreateWindow failed.")); <br>            return 0; <br>            } <br>             <br>            lpCInfo-&gt;FileTable = TableNew(); <br>             <br>            if (!lpCInfo-&gt;FileTable) { <br>            ErrorMsg(TEXT("WM_CREATE: TableNew failed.")); <br>            return 0; <br>            } <br>             <br>        if (!Logon(hwnd)) { <br>MessageBox(hwnd, TEXT("DrvWndProc: WM_CREATE: Logon failed. Terminating application."), NULL, MB_OK); <br>exit(1); <br>return 0; <br>} <br> <br>// <br>            // fDirLeft indicates whether the Directory ListBox defaults to <br>            //  the left side of each of the two drive windows. <br>            // fDirExpand indicates whether the Directory Listbox defaults <br>            //  to full expansion. <br>            // <br>            lpCInfo-&gt;fDirLeft = TRUE; <br>            lpCInfo-&gt;fDirExpand = FALSE; <br>            lpCInfo-&gt;fSuicide = FALSE; <br> <br>            // <br>            // Create Mutex associated with each list box <br>            // <br>            lpCInfo-&gt;hDirMutex = CreateMutex(NULL, FALSE, NULL); <br>            lpCInfo-&gt;hFileMutex = CreateMutex(NULL, FALSE, NULL); <br> <br>            // <br>            // Associate window with the current directory LPDINFO structure <br>            //   from the Drives linked list <br>            // <br>                             <br>            dwLoop = GetCurrentDirectory( DIRECTORY_STRING_SIZE, <br>                                          lpCInfo-&gt;CaptionBarText); <br>             <br>            CharUpper(lpCInfo-&gt;CaptionBarText); <br> <br>            WaitForSingleObject(ghDrvThread, INFINITE); <br>            EnterCriticalSection(&amp;gDrvCS); <br> <br>            lpWalk = glpDrives; <br> <br>            if(dwLoop &amp;&amp; dwLoop &lt;= DIRECTORY_STRING_SIZE) { <br>            while(lpWalk &amp;&amp; tolower(lpWalk-&gt;DriveName[0])  <br>            != tolower((lpCInfo-&gt;CaptionBarText)[0])) <br>                    lpWalk = lpWalk-&gt;next; <br> <br>                if( !lpWalk ){ <br>                    ErrorMsg(TEXT("Drive Child Create: Drive list failure.")); <br>                    LeaveCriticalSection(&amp;gDrvCS); <br>                    return(-1); <br>                } <br>            } <br>            else{ <br>                ErrorMsg(TEXT("Drive Child Create: GetCurrentDir failure.")); <br>                LeaveCriticalSection(&amp;gDrvCS); <br>                return(-1); <br>            } <br> <br>            LeaveCriticalSection(&amp;gDrvCS); <br> <br>            lpCInfo-&gt;lpDriveInfo = lpWalk; <br> <br>            // <br>            // Save the handle to DRVCHILDINFO in our window structure <br>            // <br>            SetWindowLong(hwnd, GWL_USERDATA, (LONG) lpCInfo); <br> <br>            // <br>            // Initialize child windows <br>            // <br>            if( !SendMessage(lpCInfo-&gt;hDirLB, LB_SETTABSTOPS, (WPARAM)1, <br>                            (LPARAM)&amp;lTabs) ) <br>                ErrorMsg(TEXT("Drv window Create: Set tab stop failure.")); <br> <br> <br>            // <br>            // Set default font. <br>            // <br>            SendMessage(lpCInfo-&gt;hDirLB, WM_SETFONT, (WPARAM)ghFont, (LPARAM)FALSE); <br>            SendMessage(lpCInfo-&gt;hFileLB, WM_SETFONT, (WPARAM)ghFont, (LPARAM)FALSE); <br> <br>            SendMessage(hwnd, WM_COMMAND, (WPARAM)MM_REFRESH, (LPARAM)NULL); <br> <br>            return 1; <br>        } <br> <br>        case WM_COMMAND: { <br>          static LPCINFO     lpCInfo; <br>          static SELECTINFO  Select; <br> <br>          // <br>          // Retrieving this child window's DRVCHILDINFO data for displaying <br>          //    messages in the text window <br>          // <br>          lpCInfo = (LPCINFO) GetWindowLong(hwnd, GWL_USERDATA); <br> <br>          if (!lpCInfo) { <br>          ErrorMsg(TEXT("DrvWndProc: WM_COMMAND: lpCInfo is NULL.")); <br>          return FALSE; <br>          } <br>           <br>          switch (LOWORD(wParam)){ <br> <br>            // <br>            //  Clears the selection in the active window. <br>            //  Sent when user hits escape key. <br>            // <br>            case MM_ESCAPE:{ <br>                // <br>                // If there is a directory expand in process, kill the <br>                //  thread, and leave the listbox in a semi-expanded state. <br>                //  Else, clear file selection, and switch to command window. <br>                // <br>                if( WaitForSingleObject( lpCInfo-&gt;hDirMutex, MUTEX_TIMEOUT) <br>                        == WAIT_TIMEOUT ){ <br>                    lpCInfo-&gt;fSuicide = TRUE; <br>                    lpCInfo-&gt;fEscape = TRUE; <br>                } <br>                else <br>                    ReleaseMutex( lpCInfo-&gt;hDirMutex ); <br> <br>                SendMessage(lpCInfo-&gt;hFileLB, LB_SETCURSEL, (WPARAM)-1, <br>                               (LPARAM)0); <br> <br>                return 1; <br>            } <br> <br>            case MM_ENCRYPT_DECRYPT: { <br>                if( ghFocusWnd == lpCInfo-&gt;hFileLB ) { <br>    RunListBoxItem(lpCInfo, ENCRYPT_DECRYPT); <br>                } <br>                else <br>                    if( ghFocusWnd == lpCInfo-&gt;hDirLB ){ <br>                        if( !PostMessage(hwnd, WM_COMMAND, MM_FILLDIR, <br>                                         (LPARAM)0) ){ <br>                            ErrorMsg(TEXT("MM_ENCRYPT_DECRYPT: Filldir failure.")); <br>                            return 0; <br>                        } <br>                    } <br>     <br>                    return 1; <br>            } <br> <br>case MM_SIGN: { <br>if( ghFocusWnd == lpCInfo-&gt;hFileLB ) { <br>    RunListBoxItem(lpCInfo, SIGN); <br>                } <br>                else <br>                    if( ghFocusWnd == lpCInfo-&gt;hDirLB ){ <br>                        if( !PostMessage(hwnd, WM_COMMAND, MM_FILLDIR, <br>                                         (LPARAM)0) ){ <br>                            ErrorMsg(TEXT("MM_SIGN: Filldir failure.")); <br>                            return 0; <br>                        } <br>                    } <br>              <br>                return 1; <br>            } <br> <br>case MM_VERIFY: { <br>if( ghFocusWnd == lpCInfo-&gt;hFileLB ) { <br>    RunListBoxItem(lpCInfo, VERIFY); <br>                } <br>                else <br>                    if( ghFocusWnd == lpCInfo-&gt;hDirLB ){ <br>                        if( !PostMessage(hwnd, WM_COMMAND, MM_FILLDIR, <br>                                         (LPARAM)0) ){ <br>                            ErrorMsg(TEXT("MM_VERIFY: Filldir failure.")); <br>                            return 0; <br>                        } <br>                    } <br> <br>                return 1; <br>            } <br>    <br>            case MM_EXPAND:{ <br> <br>                lpCInfo-&gt;fDirExpand = !lpCInfo-&gt;fDirExpand; <br> <br>                if( lpCInfo-&gt;fDirExpand ) <br>                    CheckMenuItem( ghMenu, MM_EXPAND, <br>                                    MF_BYCOMMAND | MF_CHECKED); <br>                else <br>                    CheckMenuItem( ghMenu, MM_EXPAND, <br>                                MF_BYCOMMAND | MF_UNCHECKED); <br> <br>                if( !SendMessage( (HWND)lpCInfo-&gt;hwnd, WM_COMMAND, <br>                                 (WPARAM)MM_REFRESH, (LPARAM)0 ) ){ <br>                    ErrorMsg(TEXT("MM_EXPAND:  MM_REFRESH failure.")); <br>                    return 0; <br>                } <br>                return 1; <br>            } <br> <br>            // <br>            // refreshes contents of directory and file ListBoxes. <br>            // <br>            case MM_REFRESH:{ <br> <br>                DWORD   dwThreadID; <br>                INT i, N; <br> <br>                if( WaitForSingleObject( lpCInfo-&gt;hDirMutex, MUTEX_TIMEOUT) <br>                        == WAIT_TIMEOUT ) <br>                    // <br>                    // If the full directory expand has been cancled, kill the <br>                    //  existing thread. <br>                    // <br>                    if( !lpCInfo-&gt;fDirExpand &amp;&amp; !lpCInfo-&gt;fSuicide){ <br>                        lpCInfo-&gt;fSuicide = TRUE; <br>                        return 1; <br>                    } <br>                    else{ <br>                        return 0; <br>                    } <br> <br>                // if set, clear the expand dir. user abort (escape key) flag. <br>                if( lpCInfo-&gt;fEscape ){ <br>                    lpCInfo-&gt;fEscape = FALSE; <br>                    ReleaseMutex( lpCInfo-&gt;hDirMutex ); <br>                    return 1; <br>                } <br> <br>                // At this point, the Dir LB mutex has been grabbed. <br> <br>                // Clear directory LB.  If expand flag is set, expand all <br>                //  directories.  Refill File LB. <br>                // <br>                         <br>                N = GetSize(lpCInfo-&gt;DirTable); <br>                                    <br>   for (i = 0; i &lt; N; i++) <br>   TableRemove(lpCInfo-&gt;DirTable, 0); <br>    <br>   if( SendMessage( lpCInfo-&gt;hDirLB, LB_RESETCONTENT, <br>                                 (WPARAM)0, (LPARAM)0 ) &lt; 0 ){ <br>                    ErrorMsg(TEXT("Refresh Drv window: Reset Dir LB content failure.")); <br>                    ReleaseMutex( lpCInfo-&gt;hDirMutex ); <br>                    return 0; <br>                } <br> <br>     // <br>                // This call puts the default root entry back into the empty <br>                //  LB.  Set suicide flag to false to ensure it will complete. <br>                // <br>                lpCInfo-&gt;fSuicide = FALSE; <br>                ExpDir( lpCInfo ); <br> <br>                // <br>                // All the Dir LB work is done.  Release Dir LB Mutex. <br>                // <br>                ReleaseMutex( lpCInfo-&gt;hDirMutex ); <br> <br>                if( lpCInfo-&gt;fDirExpand ){ <br> <br>                    CloseHandle( lpCInfo-&gt;hDirThread ); <br> <br>                    lpCInfo-&gt;hDirThread = CreateThread( NULL, 0, <br>                                  (LPTHREAD_START_ROUTINE)FullExpand, <br>                                  (LPVOID)lpCInfo, 0, &amp;dwThreadID); <br> <br>                    if( !lpCInfo-&gt;hDirThread ){ <br>                        ErrorMsg(TEXT("MM_REFRESH: FullExpand CreateThread failure.")); <br>                        return 0; <br>                    } <br>                } <br>                else <br>                    ExpDir( lpCInfo ); <br> <br>                if( !PostMessage(hwnd, WM_COMMAND, MM_FILLFILE, <br>                                 (LPARAM)0) ){ <br>                    ErrorMsg(TEXT("Refresh Drv window: Fillfile failure.")); <br>                    return 0; <br>                } <br> <br>                return 1; <br>            } <br> <br>            // <br>            //  Fill listbox in lParam with directory from Drv child's drive. <br>            //  Sent by MM_REFRESH. <br>            // <br>            //  lParam == 0 <br>            // <br>            case MM_FILLDIR:{ <br> <br>                DWORD   dwThreadID; <br> <br>                lpCInfo-&gt;fSuicide = FALSE; <br> <br>                CloseHandle( lpCInfo-&gt;hDirThread ); <br> <br>                lpCInfo-&gt;hDirThread = CreateThread( NULL, 0, <br>                              (LPTHREAD_START_ROUTINE)ExpDir, <br>                              (LPVOID)lpCInfo, 0, &amp;dwThreadID); <br> <br>                if( !(lpCInfo-&gt;hDirThread) ){ <br>                    ErrorMsg(TEXT("MM_FILLDIR: ExpDir CreateThread failure.")); <br>                    return 0; <br>                } <br> <br>                return 1; <br>            } <br> <br>            // <br>            //  Fill listbox in lParam with files from current directory. <br>            //  Sent by MM_REFRESH &amp; LBN_DBLCLK in DrvWndProc. <br>            // <br>            //  lParam == 0 <br>            // <br>            case MM_FILLFILE: <br>                ghFocusWnd = lpCInfo-&gt;hFileLB; <br>                return FillFile(lpCInfo, hwnd); <br>break; <br> <br>            // <br>            // The following WM_COMMAND messages are sent by the listboxes <br>            // <br>            // HIWORD(wParam) = LB notification message <br>            // lParam = LB window handle <br>            // <br>            case LISTFILE_ID:{ <br>              switch( HIWORD(wParam) ){ <br>                // <br>                // In case of double click on a directory, expand the file <br>                // Listbox. if on a file name, run or edit file. <br>                // <br>                case LBN_DBLCLK:{ <br>                    RunListBoxItem(lpCInfo, ENCRYPT_DECRYPT); <br>                    return 1; <br>                } <br>                break; <br> <br>                case LBN_SETFOCUS:{ <br>                    ghFocusWnd = lpCInfo-&gt;hFileLB; <br>                } <br>                break; <br> <br>                default: <br>                    return 1; <br>              } <br>            } // LISTFILE_ID <br>            break; <br> <br>            // <br>            // Notification from the Directory ListBox <br>            // <br>            case LISTDIR_ID:{ <br>              switch( HIWORD(wParam) ){ <br> <br>                case LBN_SETFOCUS:{ <br>                    ghFocusWnd = lpCInfo-&gt;hDirLB; <br>                } <br>                break; <br> <br>                // <br>                // Expand subdirectories in dir listbox <br>                // <br>                case LBN_DBLCLK:{ <br> <br>                    if( !PostMessage(hwnd, WM_COMMAND, MM_FILLDIR, <br>                                     (LPARAM)0) ){ <br>                        ErrorMsg(TEXT("Dir ListBox Notify: Filldir failure.")); <br>                        return 0; <br>                    } <br>                    return 1; <br>                } <br>                break; <br> <br>                case LBN_SELCHANGE:{ <br>                    // <br>                    // for the Directory LB, fill the <br>                    // corresp. File LB with items in the newly selected dir. <br>                    // <br>                    LONG lIndex; <br> <br>                    if( WaitForSingleObject( lpCInfo-&gt;hDirMutex, MUTEX_TIMEOUT) <br>                            == WAIT_TIMEOUT ){ <br>                        ErrorMsg(TEXT("Dir LB Notify: Dir LB Mutex Timeout.")); <br>                        return 0; <br>                    } <br> <br>                    // <br>                    // Retrieve selected (careted) item. <br>                    // <br>                    lIndex = SendMessage( (HWND)lParam, LB_GETCARETINDEX, <br>                                        (WPARAM)NULL, (LPARAM)NULL ); <br> <br>                    if( !ConstructDirName(lpCInfo, lIndex, <br>                                          lpCInfo-&gt;CaptionBarText) ){ <br>                        ErrorMsg(TEXT("Dir LB Notify:  ConstructDirName failure.")); <br>                        ReleaseMutex( lpCInfo-&gt;hDirMutex ); <br>                        return 0; <br>                    } <br> <br>                    ReleaseMutex( lpCInfo-&gt;hDirMutex ); <br> <br>                    if( !PostMessage(hwnd, WM_COMMAND, MM_FILLFILE, <br>                                     (LPARAM)0) ){ <br>                        ErrorMsg(TEXT("Dir ListBox Notify: Fillfile failure.")); <br>                        return 0; <br>                    } <br>                } // LBN_SELCHANGE <br>                break; <br> <br>                default: <br>                    return 1; <br>              } <br>            } //  LISTDIR_ID <br>            break; <br> <br>            default: <br>               return 1; <br>          } <br>        } <br>        break; <br> <br>        // <br>        // Whenever the Drv child window is resized, its children has to be <br>        //  resized accordingly.  The GetWindowLong GWL_USERDATA values <br>        //  contain the height of the windows queried, set in their respective <br>        //  WM_CREATE cases. <br>        // <br>        case WM_SIZE: { <br>            LPCINFO     lpCInfo; <br> <br>            int         nListHeight, <br>                        nListWidth; <br> <br>            HWND        hLeftLB, <br>                        hRightLB; <br> <br>            // <br>            // First, get the text window's handle from the per Drv child <br>            //  DRVCHILDINFO data structure <br>            // <br>            lpCInfo = (LPCINFO)GetWindowLong(hwnd, GWL_USERDATA); <br> <br>            if (!lpCInfo) { <br>            ErrorMsg(TEXT("DrvWndProc: WM_SIZE: lpCInfo is NULL.")); <br>            return 0; <br>            } <br>             <br>            nListHeight = HIWORD(lParam) - <br>                          GetWindowLong(lpCInfo-&gt;hTextWnd, GWL_USERDATA) <br>                          - LIST_BORDER * 2; <br> <br>            nListWidth = (LOWORD(lParam) - LIST_BORDER) / 2 - LIST_BORDER; <br> <br>            // <br>            // Always, put the text window at the top of the Drv window. <br>            // Increasing sides and bottom extents by 1 to overlap border <br>            //   with Drv child border <br>            // <br>            MoveWindow(lpCInfo-&gt;hTextWnd, <br>                       -1, <br>                       0, <br>                       LOWORD(lParam) + 2, <br>                       GetWindowLong(lpCInfo-&gt;hTextWnd, GWL_USERDATA) + 1, <br>                       TRUE); <br> <br>            if( lpCInfo-&gt;fDirLeft ){ <br>                hLeftLB = lpCInfo-&gt;hDirLB; <br>                hRightLB = lpCInfo-&gt;hFileLB; <br>            } <br>            else{ <br>                hLeftLB = lpCInfo-&gt;hFileLB; <br>                hRightLB = lpCInfo-&gt;hDirLB; <br>            } <br> <br>            MoveWindow(hLeftLB, <br>                       LIST_BORDER, <br>                       GetWindowLong(lpCInfo-&gt;hTextWnd, GWL_USERDATA) + 1 <br>                         + LIST_BORDER, <br>                       nListWidth, <br>                       nListHeight, <br>                       TRUE); <br> <br>            MoveWindow(hRightLB, <br>                       (LOWORD(lParam) + LIST_BORDER) / 2, <br>                       GetWindowLong(lpCInfo-&gt;hTextWnd, GWL_USERDATA) + 1 <br>                         + LIST_BORDER, <br>                       nListWidth, <br>                       nListHeight, <br>                       TRUE); <br> <br>        break; <br>        } <br> <br>        case WM_PARENTNOTIFY:{ <br>            LPCINFO lpCInfo; <br> <br>            if(wParam == WM_LBUTTONDOWN){ <br>                lpCInfo = (LPCINFO) GetWindowLong(hwnd, GWL_USERDATA); <br>                if(lpCInfo == NULL){ <br>                    ErrorMsg(TEXT("Drv child: Parent notify failure.")); <br>                    return 1; <br>                } <br>                if(HIWORD(wParam) == LISTDIR_ID) <br>                    SetFocus(lpCInfo-&gt;hDirLB); <br>                else <br>                    if(HIWORD(wParam) == LISTFILE_ID) <br>                        SetFocus(lpCInfo-&gt;hFileLB); <br>                    else <br>                        if(HIWORD(wParam) == TEXT_WINDOW_ID) <br>                            SetFocus(lpCInfo-&gt;hTextWnd); <br>            } <br> <br>            break; <br>        } <br> <br>        // <br>        // Same as MainWndProc's MM_ACTIVEDRV case.  The initial PostMessage <br>        //   is so the currently active Drv child will not process the message <br>        //   until it is no longer in focus. <br>        // <br>        case WM_MOUSEACTIVATE:{ <br>            LPCINFO lpCInfo; <br> <br>            PostMessage(ghwndDrv, WM_COMMAND, (WPARAM)MM_TOGGLE, <br>                        (LPARAM)NULL); <br>            ghwndDrv = hwnd; <br>            SendMessage(ghwndDrv, WM_COMMAND, (WPARAM)MM_TOGGLE, <br>                        (LPARAM)NULL); <br> <br>            lpCInfo = (LPCINFO) GetWindowLong(hwnd, GWL_USERDATA); <br>             <br>            if (!lpCInfo) { <br>            ErrorMsg(TEXT("DrvWndProc: lpCInfo is NULL.")); <br>            return FALSE; <br>            } <br>             <br>            SendMessage(ghwndDrives, WM_COMMAND, MM_ACTIVEDRV, <br>                        (LPARAM)lpCInfo-&gt;lpDriveInfo); <br> <br>            break; <br>        } <br> <br>        // <br>        // Free the DRVCHILDINFO data that associates with this window <br>        //  also, reset the menu. <br>        // <br>        case WM_CLOSE: { <br>            LPCINFO lpCInfo; <br> <br>            lpCInfo = (LPCINFO)GetWindowLong(hwnd, GWL_USERDATA); <br> <br>            if (!lpCInfo) { <br>            ErrorMsg(TEXT("DrvWndProc: WM_CLOSE: lpCInfo is NULL.")); <br>            return 0; <br>            } <br>             <br>            CloseHandle(lpCInfo-&gt;hDirThread); <br>            CloseHandle(lpCInfo-&gt;hDirMutex ); <br>            CloseHandle(lpCInfo-&gt;hFileMutex ); <br>TableFree(lpCInfo-&gt;DirTable); <br>TableFree(lpCInfo-&gt;FileTable); <br> <br>break; <br>        } <br> <br>                //   case WM_DELETEITEM: <br>            case WM_DRAWITEM: { <br>             <br>            // Get pointer to the DRAWITEMSTRUCT  <br>            lpdis = (LPDRAWITEMSTRUCT)lParam; <br> <br>            switch (lpdis-&gt;itemAction) </code></pre>
<p>
</p>
<pre><code>{ <br>            case ODA_DRAWENTIRE: <br>            DrawEntireItem(lpdis); <br>            break; <br> <br>            case ODA_SELECT: <br>            HandleSelectionState(lpdis); <br>            break; <br>             <br>            } <br>  <br>              // Return TRUE meaning that we processed this message.  <br>            return 1; <br>} <br> <br>        case WM_MEASUREITEM:{ <br>            <br>            lpmis = (LPMEASUREITEMSTRUCT)lParam; <br> <br> <br>            // All the items are the same height since the list box style is <br>            // LBS_OWNERDRAWFIXED <br>            // <br>            lpmis-&gt;itemHeight = 15; <br>            return 1; <br>}         <br>             <br>            case WM_COMPAREITEM: { <br>INT cv; <br> <br>lpcis = (LPCOMPAREITEMSTRUCT)lParam; <br> <br>if (!lpcis-&gt;itemData1) <br>ErrorMsg(TEXT("WM_COMPAREITEM: lpcis-&gt;itemData1 is NULL.")); <br> <br>if (!lpcis-&gt;itemData2) <br>ErrorMsg(TEXT("WM_COMPAREITEM: lpcis-&gt;itemData2 is NULL.")); <br> <br>cv = CFilerlstrcmp((LPTSTR)(lpcis-&gt;itemData1), (LPTSTR)(lpcis-&gt;itemData2)); <br> <br>if (cv &lt; 0) <br>return -1; <br>else if (cv == 0) <br>            return 0; <br>else if (cv &gt; 0) <br>            return 1; <br>             <br>} <br>             <br>            default: <br>            return DefWindowProc(hwnd, message, wParam, lParam); <br> <br>    } //switch <br>    return DefWindowProc(hwnd, message, wParam, lParam); <br>} <br> <br>/*************************************************************************************\ <br>* TextWndProc() <br>* <br>* Text Window procedure for displaying miscellaneous messages to user. <br>\*************************************************************************************/ <br> <br>LRESULT WINAPI TextWndProc (HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam) <br>{ <br> <br>    switch (message) <br>    { <br>    case WM_CREATE: <br>        { <br>        HDC        hDC; <br>        HGDIOBJ    hOldFont; <br>        TEXTMETRIC tm; <br>        LONG       lHeight; <br> <br>        hDC = GetDC(hwnd); <br> <br>        hOldFont = SelectObject(hDC, ghFont); <br>        GetTextMetrics(hDC, &amp;tm); <br> <br>        // <br>        // base the height of the window on size of text <br>        // <br>        lHeight = tm.tmHeight + GetSystemMetrics(SM_CYBORDER) + 6; <br> <br>        // <br>        // saved the height for later reference <br>        // <br>        SetWindowLong(hwnd, GWL_USERDATA, lHeight); <br> <br>            if(hOldFont) <br>                SelectObject(hDC, hOldFont); <br> <br>            ReleaseDC(hwnd, hDC); <br>            break; <br>        } <br> <br>    case WM_SETTEXT: <br>            DefWindowProc(hwnd, message, wParam, lParam); <br>            if( !InvalidateRect(hwnd, NULL, TRUE) ){ <br>                ErrorMsg(TEXT("Textwindow: Set text failure.")); <br>                return 1; <br>            } <br>            UpdateWindow(hwnd); <br>            return 1; <br> <br>    case WM_PAINT: <br>        { <br>            PAINTSTRUCT ps; <br>            RECT        rc; <br>            TCHAR       ach[BUF_SIZE]; <br>            int         len, nxBorder, nyBorder; <br>            HFONT       hOldFont = NULL; <br>            HBRUSH      hBrush; <br> <br>            BeginPaint(hwnd, &amp;ps); <br> <br>            GetClientRect(hwnd,&amp;rc); <br> <br>            len = GetWindowText(hwnd, ach, BUF_SIZE); <br> <br>            SetBkMode(ps.hdc, TRANSPARENT); <br> <br>            if( GetParent(hwnd) == ghwndDrv ){ <br>                hBrush = CreateSolidBrush( GetSysColor(COLOR_ACTIVECAPTION) ); <br>                SetTextColor( ps.hdc, GetSysColor(COLOR_CAPTIONTEXT) ); <br>            } <br>            else{ <br>                hBrush = CreateSolidBrush( GetSysColor(COLOR_INACTIVECAPTION) ); <br>                SetTextColor( ps.hdc, GetSysColor(COLOR_INACTIVECAPTIONTEXT) ); <br>            } <br> <br>            hOldFont = SelectObject(ps.hdc, ghFont); <br> <br>            FillRect(ps.hdc, &amp;rc, hBrush); <br> <br>            nxBorder = GetSystemMetrics(SM_CXBORDER); <br>            rc.left  += 9*nxBorder; <br>            rc.right -= 9*nxBorder; <br> <br>            nyBorder = GetSystemMetrics(SM_CYBORDER); <br>            rc.top    += 3*nyBorder; <br>            rc.bottom -= 3*nyBorder; <br> <br>            ExtTextOut(ps.hdc, rc.left+2*nxBorder, rc.top, ETO_CLIPPED, <br>                    &amp;rc, ach, len, NULL); <br> <br>            SetBkMode(ps.hdc, OPAQUE); <br> <br>            if (hOldFont) <br>                SelectObject(ps.hdc, hOldFont); <br> <br>            DeleteObject(hBrush); <br> <br>            EndPaint(hwnd, &amp;ps); <br>            return 1; <br>        } <br>    } <br>    return DefWindowProc(hwnd, message, wParam, lParam); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
