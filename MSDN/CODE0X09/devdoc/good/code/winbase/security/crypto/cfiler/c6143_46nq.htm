<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CRP.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6146"></a>CRP.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples.  <br>*       Copyright 1996 - 1998 Microsoft Corporation. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>// CRP.C <br>#include "cfiler.h" <br> <br>HCRYPTPROVhMe; <br>ALG_IDAlgidEncrypt; <br>ALG_IDAlgidSign; <br>TCHARsPass[BUF_SIZE]; <br>TCHARszPassName[BUF_SIZE]; <br> <br>extern HANDLE ghModule;  <br>extern HMENUghMenu;                                                                     <br> <br>/************************************************************************\ <br>* EnterPass() <br>* <br>* Dialog procedure for the "PASSWORD" dialog box. <br>* <br>* Stores the password entered by the user into  <br>* the global buffer sPass <br>\************************************************************************/ <br> <br>WINAPI EnterPass(HWND hDlg, UINT wMsgID, UINT wParam, LPARAM lParam)  { <br>TCHAR szMessage[BUF_SIZE]; <br> <br>switch(wMsgID) { <br>case WM_INITDIALOG: <br>lstrcpy(szMessage, TEXT("Enter password: ")); <br>lstrcat(szMessage, szPassName); <br>SetDlgItemText(hDlg, IDC_PASSTEXT, szMessage); <br>SetDlgItemText(hDlg, IDC_EDIT1, TEXT("\0")); <br>SetDlgItemText(hDlg, IDC_EDIT2, TEXT("\0")); <br> <br>return FALSE; <br> <br>case WM_COMMAND: <br>switch(LOWORD(wParam)) { <br>TCHAR szVerify[BUF_SIZE]; <br> <br>case IDOK: <br>if (!GetDlgItemText(hDlg, IDC_EDIT1, sPass, BUF_SIZE)) { <br>                if (MessageBox(hDlg, TEXT("No password entered."), NULL, MB_OK) == IDOK) { <br>EndDialog(hDlg, FALSE); <br>return FALSE; <br>} <br>} <br>                 <br>SetFocus(GetDlgItem(hDlg, IDC_EDIT2)); <br> <br>if (!GetDlgItemText(hDlg, IDC_EDIT2, szVerify, BUF_SIZE)) { <br>MessageBox(hDlg, TEXT("No password entered."), NULL, MB_OK); <br>EndDialog(hDlg, FALSE); <br>return FALSE; <br>} <br> <br>if (lstrcmp(sPass, szVerify)) { <br>MessageBox(hDlg, TEXT("Could not verify password."), NULL, MB_OK); <br>EndDialog(hDlg, FALSE); <br>return FALSE; <br>} <br> <br>EndDialog(hDlg, TRUE); <br> <br>return TRUE; <br> <br>case IDCANCEL: <br>EndDialog(hDlg, -1); <br>return -1; <br> <br>default: <br>return FALSE; <br>} <br>break; <br>} <br>return FALSE; <br>} <br> <br>/************************************************************************\ <br>* CryptDlgProc() <br>* <br>* Dialog procedure for all dialog boxes of the <br>* application besides "PASSWORD", "ENCRYPTION_ALGORITHM," <br>* and "HASH_ALGORITHM." <br>\************************************************************************/ <br> <br>LRESULT WINAPI CryptDlgProc(HWND hDlg, UINT wMsgID, UINT wParam, LPARAM lParam) { <br>switch(wMsgID) { <br>case WM_INITDIALOG: <br>return FALSE; <br> <br>case WM_COMMAND: <br>switch(LOWORD(wParam)) { <br>case IDOK: <br>EndDialog(hDlg, TRUE); <br>return TRUE; <br> <br>case IDCANCEL: <br>EndDialog(hDlg, FALSE); <br>return TRUE; <br> <br>default: <br>return FALSE; <br>} <br>break; <br>} <br>return FALSE; <br>} <br> <br>/************************************************************************\ <br>* EncryptDlgProc() <br>* <br>* Dialog procedure for "ENCRYPTION_ALGORITHM" dialog box. <br>\************************************************************************/ <br> <br>LRESULT WINAPI EncryptDlgProc(HWND hDlg, UINT wMsgID, UINT wParam, LPARAM lParam) { <br>switch(wMsgID) { <br>case WM_INITDIALOG: <br>if (AlgidEncrypt == CALG_RC4) <br>CheckRadioButton(hDlg, IDC_RC2, IDC_RC4, IDC_RC4); <br>else <br>CheckRadioButton(hDlg, IDC_RC2, IDC_RC4, IDC_RC2); <br>return FALSE; <br> <br>case WM_COMMAND: <br>switch(LOWORD(wParam)) { <br>case IDC_RC2: <br>AlgidEncrypt = CALG_RC2; <br>return TRUE; <br> <br>case IDC_RC4: <br>AlgidEncrypt = CALG_RC4; <br>return TRUE; <br> <br>case IDOK: <br>if (!AlgidEncrypt) <br>AlgidEncrypt = CALG_RC2; <br>EndDialog(hDlg, TRUE); <br>return TRUE; <br> <br>case IDCANCEL: <br>EndDialog(hDlg, FALSE); <br>return TRUE; <br> <br>default: <br>return FALSE; <br>} <br>break; <br>} <br>return FALSE; <br>} <br> <br>/************************************************************************\ <br>* HashDlgProc() <br>* <br>* Dialog procedure for "HASH_ALGORITHM" dialog box <br>\************************************************************************/ <br> <br>LRESULT WINAPI HashDlgProc(HWND hDlg, UINT wMsgID, UINT wParam, LPARAM lParam) { <br>switch(wMsgID) { <br>case WM_INITDIALOG: <br>if (AlgidSign == CALG_SHA) <br>CheckRadioButton(hDlg, IDC_MD4, IDC_SHA, IDC_SHA); <br>else if (AlgidSign == CALG_MD5) <br>CheckRadioButton(hDlg, IDC_MD4, IDC_SHA, IDC_MD5); <br>else <br>CheckRadioButton(hDlg, IDC_MD4, IDC_SHA, IDC_MD4); <br>return FALSE; <br> <br>case WM_COMMAND: <br>switch(LOWORD(wParam)) { <br>case IDC_MD4: <br>AlgidSign = CALG_MD4; <br>return TRUE; <br> <br>case IDC_MD5: <br>AlgidSign = CALG_MD5; <br>return TRUE; <br> <br>case IDC_SHA: <br>AlgidSign = CALG_SHA; <br>return TRUE; <br> <br>case IDOK: <br>EndDialog(hDlg, TRUE); <br>return TRUE; <br> <br>case IDCANCEL: <br>EndDialog(hDlg, FALSE); <br>return TRUE; <br> <br>default: <br>return FALSE; <br>} <br>break; <br>} <br>return FALSE; <br>} <br> <br>/************************************************************************\ <br>* GetPass() <br>* <br>* input: <br>* hWnd - HWND of caller <br>* <br>* purpose: <br>* Creates a dialog box prompting the user to enter a password. <br>* <br>* returns: <br>* TRUE if successful <br>* FALSE if unsuccessful <br>\************************************************************************/ <br> <br>BOOL GetPass(HWND hWnd) { <br>INT bRet = 0; <br> <br>do { <br>if (bRet == -1) <br>break; <br> <br>// Prompt the user to enter a password. <br> <br>bRet = DialogBox(ghModule, TEXT("PASSWORD"), hWnd, EnterPass); <br>} while (!bRet || !lstrcmp(sPass, TEXT("\0")) || !lstrcmp(sPass, TEXT(""))); <br> <br>AlgidEncrypt = 0; <br> <br>return TRUE; <br>} <br> <br>/************************************************************************\ <br>* GetfnKey() <br>* <br>* purpose: <br>* Retrieves fnKey from the registry. <br>* fnKey is used to encrypt and decrypt filenames. <br>* If fnKey does not exist in the registry, GetfnKey creates it. <br>* <br>* returns <br>* a valid key if successful <br>* 0 if unsuccessful. <br>\************************************************************************/ <br> <br>HCRYPTKEY GetfnKey(HWND hWnd) { <br>BYTE pbFileKeyBlob[BUF_SIZE]; <br>DWORD dwFileBlobLen = BUF_SIZE; <br>LONGlRv; <br>HKEYhKey; <br>DWORDdwType; <br>DWORDdwSize; <br>DWORDdwDisposition; <br>HCRYPTKEYphEncryptPubKey; <br>HCRYPTKEYhfnKey; <br> <br>if (!GetEncryptPublicKey(hWnd, &amp;phEncryptPubKey)) { <br>ErrorMsg(TEXT("GetfnKey: GetEncryptPublicKey failed.")); <br>return (HCRYPTKEY)0; <br>} <br> <br>#ifdef WIN95 <br> <br>lRv = RegOpenKeyEx(HKEY_CURRENT_USER,  <br>    TEXT("SOFTWARE\\Microsoft\\Cryptfiler.ini"),  <br>   0,  <br>   KEY_ALL_ACCESS, <br>   &amp;hKey); <br> <br>#else <br> <br>lRv = RegOpenKeyEx(HKEY_CURRENT_USER,  <br>    TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\IniFileMapping\\Cryptfiler.ini"),  <br>   0,  <br>   KEY_ALL_ACCESS, <br>   &amp;hKey); <br>#endif <br> <br>if (lRv != ERROR_SUCCESS) { <br> <br>// not in registry; we must create. <br> <br>#ifdef WIN95 <br> <br>lRv = RegCreateKeyEx(HKEY_CURRENT_USER,  <br>  TEXT("SOFTWARE\\Microsoft\\Cryptfiler.ini"),  <br> 0,  <br> NULL,  <br> REG_OPTION_NON_VOLATILE, <br> KEY_ALL_ACCESS, <br> NULL, <br> &amp;hKey, <br> &amp;dwDisposition); <br>#else <br>lRv = RegCreateKeyEx(HKEY_CURRENT_USER,  <br>  TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\IniFileMapping\\Cryptfiler.ini"),  <br> 0,  <br> NULL,  <br> REG_OPTION_NON_VOLATILE, <br> KEY_ALL_ACCESS, <br> NULL, <br> &amp;hKey, <br> &amp;dwDisposition); <br>#endif <br> <br>if (lRv != ERROR_SUCCESS) { <br>ErrorMsg(TEXT("GetfnKey: RegCreateKeyEx failed.")); <br>return (HCRYPTKEY)0; <br>} <br> <br>if (RCRYPT_FAILED(CryptGenKey(hMe, CALG_RC4, CRYPT_EXPORTABLE, &amp;hfnKey))) { <br>ErrorMsg(TEXT("GetfnKey: CryptGenKey failed.")); <br>return (HCRYPTKEY)0; <br>}  <br> <br>//Export the key so that it can be stored in the registry. <br> <br>if (RCRYPT_FAILED(CryptExportKey(hfnKey,  <br>  phEncryptPubKey,  <br>  SIMPLEBLOB,  <br>  0,  <br>  pbFileKeyBlob,  <br>  &amp;dwFileBlobLen))) { <br>ErrorMsg(TEXT("GetfnKey: CryptExportKey failed.")); <br>return (HCRYPTKEY)0; <br>} <br> <br>// Store the key blob in the registry. <br> <br>if (RegSetValueEx(hKey, <br>  TEXT("fnKey"), <br>  0, <br>  REG_BINARY, <br>  pbFileKeyBlob, <br>  dwFileBlobLen * sizeof(*pbFileKeyBlob)) != ERROR_SUCCESS) { <br> <br>ErrorMsg(TEXT("GetfnKey: RegSetValueEx failed.")); <br>return (HCRYPTKEY)0; <br>} <br>} <br>else { <br>// in registry. We must extract. <br> <br>dwType = 0; <br>dwFileBlobLen = 0; <br>dwSize = BUF_SIZE; <br> <br>if (RegQueryValueEx(hKey,  <br>TEXT("fnKey"), <br>NULL,  <br>&amp;dwType,  <br>pbFileKeyBlob,  <br>&amp;dwSize) != ERROR_SUCCESS) <br>{ <br>MessageBox(hWnd, TEXT("GetfnKey: RegQueryValueEx failed querrying pbFileKeyBlob."), NULL, MB_OK); <br>return (HCRYPTKEY)0; <br>}; <br> <br>// Read the key blob from the disk into a Buf. <br> <br>if (!dwSize || (dwSize &gt; BUF_SIZE)) { <br>ErrorMsg(TEXT("GetfnKey: dwSize is not in acceptable range.")); <br>return FALSE; <br>} <br> <br>// Import the key whose blob is contained in the Buf pbDecryptBlob <br> <br>dwFileBlobLen = dwSize; <br> <br>if (RCRYPT_FAILED(CryptImportKey(hMe,  <br>  pbFileKeyBlob,  <br>  dwFileBlobLen,  <br>  0,  <br>  0, <br>  &amp;hfnKey))) { <br> <br>MessageBox(hWnd, TEXT("GetfnKey: CryptImportKey failed"), NULL, MB_OK); <br>return (HCRYPTKEY)0; <br>} <br>} <br> <br>return hfnKey; <br>} <br> <br>/************************************************************************\ <br>* Logon() <br>* <br>* input: <br>* hWnd - HWND of caller <br>* <br>* purpose: <br>* Creates a dialog box which says "Performing context acquisition." <br>* Calls CryptAcquireContext. <br>* Destroys the dialog box <br>* <br>* returns: <br>* TRUE if successful <br>* FALSE if unsuccessful <br>\************************************************************************/ <br> <br>BOOL Logon(HWND hWnd) { <br>HWNDhwndDlg; <br>TCHARpszName[64]; <br> <br>pszName[0] = TEXT('\0'); <br>hwndDlg = CreateDialog(ghModule, TEXT("ACQUIRE_CONTEXT"), hWnd, CryptDlgProc); <br> <br>if (!hwndDlg) { <br>ErrorMsg(TEXT("Logon: CreateDialog failed.")); <br>return FALSE; <br>} <br> <br>if (RCRYPT_FAILED(CryptAcquireContext(&amp;hMe, pszName, MS_DEF_PROV, PROV_RSA_FULL, 0))) { <br>if (RCRYPT_FAILED(CryptAcquireContext(&amp;hMe,  <br>  pszName,  <br>  TEXT(MS_DEF_PROV),  <br>  PROV_RSA_FULL,  <br>  CRYPT_NEWKEYSET))) { <br>EndDialog(hwndDlg, FALSE); <br>MessageBox(hWnd, TEXT("Logon: CryptAcquireContext failed."), NULL, MB_OK); <br>return FALSE; <br>} <br>} <br> <br>EndDialog(hwndDlg, FALSE); <br>return TRUE; <br> <br>return FALSE; <br>} <br> <br>/************************************************************************\ <br>* Logoff() <br>* <br>* input: <br>* hWnd - HWND of caller <br>* <br>* purpose: <br>* Calls CryptReleaseContext. <br>* <br>* returns: <br>* TRUE if successful <br>* FALSE if unsuccessful <br>\************************************************************************/ <br> <br>BOOL Logoff(HWND hWnd)  <br>{ <br>if (hMe) { <br>if (RCRYPT_FAILED(CryptReleaseContext(hMe, 0))) { <br>        ErrorMsg(TEXT("Logoff: CryptReleaseContext failed.")); <br>        return FALSE; <br>    } <br>} <br>else { <br>ErrorMsg(TEXT("Logoff: hMe is NULL.")); <br>return FALSE; <br>} <br> <br>return TRUE; <br>} <br> <br>/************************************************************************\ <br>* GetEncryptPublicKey() <br>* <br>* input: <br>* hWnd - HWND specified by caller <br>* phEncryptPubKey - address to store key <br>* <br>* purpose: calls CryptGetUserKey to obtain the AT_KEYEXCHANGE public <br>* key. <br>* <br>* returns: <br>* TRUE if successful <br>* FALSE if unsuccessful <br>\************************************************************************/ <br> <br>BOOL GetEncryptPublicKey(HWND hWnd, HCRYPTKEY *phEncryptPubKey) { <br>if (!phEncryptPubKey) { <br>ErrorMsg(TEXT("GetEncryptPubKey: phEncryptPubKey is NULL.")); <br>return FALSE; <br>} <br> <br>if (RCRYPT_FAILED(CryptGetUserKey(hMe, AT_KEYEXCHANGE, phEncryptPubKey))) { <br>if (RCRYPT_FAILED(CryptGenKey(hMe, AT_KEYEXCHANGE, 0, phEncryptPubKey))) { <br>ErrorMsg(TEXT("GetEncryptPublicKey: CryptGenKey failed.")); <br>return TRUE; <br>} <br>} <br> <br>return TRUE; <br>} <br> <br>/************************************************************************\ <br>* GetSignaturePublicKey() <br>* <br>* input: <br>* hWnd - HWND specified by caller <br>* phSignaturePubKey - address to store key <br>* <br>* purpose: calls CryptGetUserKey to obtain the AT_SIGNATURE public <br>* key. <br>* <br>* returns: <br>* TRUE if successful <br>* FALSE if unsuccessful <br>\************************************************************************/ <br> <br>BOOL GetSignaturePublicKey(HWND hWnd, HCRYPTKEY *phSignaturePubKey) { <br>if (!phSignaturePubKey) { <br>ErrorMsg(TEXT("GetSignaturePublicKey: phSignaturePubKey is NULL.")); <br>return FALSE; <br>} <br> <br>if (RCRYPT_FAILED(CryptGetUserKey(hMe, AT_SIGNATURE, phSignaturePubKey))) { <br>if (RCRYPT_FAILED(CryptGenKey(hMe, AT_SIGNATURE, 0, phSignaturePubKey))) { <br>ErrorMsg(TEXT("GetSignaturePublicKey: CryptGenKey failed.")); <br>return FALSE; <br>} <br>} <br> <br>return TRUE; <br>} <br> <br>/************************************************************************\ <br>* MakeHashDirectory() <br>* <br>* purpose:  <br>* Creates the directory \sig on the same drive as the  <br>* system directory as a hidden directory if <br>* it doesn't exist and checks the menu item ID_HIDE. <br>* If it does exist and it is hidden it checks the menu item ID_HIDE. <br>* If it does exist and it is not hidden it sets the menu item ID_HIDE <br>* to be unchecked. <br>* <br>* returns:  <br>* TRUE if successful <br>* FALSE if unsuccessful <br>\************************************************************************/ <br> <br>BOOL MakeHashDirectory(VOID) { <br>DWORD dwFileAttributes; <br>TCHAR szSigDir[PATH_SIZE]; <br> <br>GetSigDir(szSigDir); <br> <br>// Does this directory exist? <br> <br>if (GetFileAttributes(szSigDir) == 0xFFFFFFFF) { <br>// Create the directory <br>if (!CreateDirectory(szSigDir, NULL)) { <br>ErrorMsg(TEXT("MakeHashDirectory: CreateDirectory failed.")); <br>return FALSE; <br>} <br>// Make the directory hidden <br>if (!SetFileAttributes(szSigDir, FILE_ATTRIBUTE_HIDDEN)) { <br>ErrorMsg(TEXT("Another process is using the \\sig directory.")); <br>return FALSE; <br>} <br>} <br> <br>dwFileAttributes = GetFileAttributes(szSigDir); <br> <br>// Toggle the "Hide Signatures" menu item appropriately. <br> <br>if (dwFileAttributes &amp; FILE_ATTRIBUTE_HIDDEN) <br>      CheckMenuItem(ghMenu, ID_HIDE, MF_CHECKED); <br>    else <br>    CheckMenuItem(ghMenu, ID_HIDE, MF_UNCHECKED); <br>      <br>    return TRUE; <br>} <br> <br>/************************************************************************\ <br>* DeleteHashDirectory() <br>* <br>* purpose:  <br>* Deletes the directory \sig on the same drive as the system directory <br>* if the \sig directory is empty. This function is called when the <br>* application terminates. <br>* <br>* returns:  <br>* TRUE if successful <br>* FALSE if unsuccessful <br>\************************************************************************/ <br> <br>BOOL DeleteHashDirectory(VOID) { <br>TCHAR szSigDir[PATH_SIZE]; <br>TCHAR szFiles[PATH_SIZE]; <br>WIN32_FIND_DATA FindFileData; <br>HANDLE hFindFile; <br> <br>GetSigDir(szSigDir); <br> <br>lstrcpy(szFiles, szSigDir); <br>lstrcat(szFiles, TEXT("\\*")); <br> <br>// Does this directory exist? <br> <br>if (GetFileAttributes(szSigDir) == 0xFFFFFFFF) { <br>return TRUE; <br>} <br> <br>hFindFile = FindFirstFile(szFiles, &amp;FindFileData); <br> <br>FindNextFile(hFindFile, &amp;FindFileData); <br> <br>if (!FindNextFile(hFindFile, &amp;FindFileData)) { <br>FindClose(hFindFile); <br>SetFileAttributes(szSigDir, FILE_ATTRIBUTE_NORMAL); <br>if (!RemoveDirectory(szSigDir)) { <br>ErrorMsg(TEXT("DeleteHashDirectory: RemoveDirectory failed.")); <br>return FALSE; <br>} <br>} <br>else      <br>    FindClose(hFindFile); <br>     <br>    return TRUE; <br>} <br> <br>/************************************************************************\ <br>* HideSignatures() <br>* <br>* purpose: <br>* Hides the directory \sig and its contents <br>* <br>* returns <br>* TRUE if successful <br>* FALSE if unsuccessful <br>\************************************************************************/ <br> <br>BOOL HideSignatures(VOID) { <br>WIN32_FIND_DATA FindFileData; <br>HANDLE hFindFile; <br>TCHAR szFiles[PATH_SIZE]; <br>TCHAR szFileName[PATH_SIZE]; <br>TCHAR szSigDir[PATH_SIZE]; <br> <br>GetSigDir(szSigDir); <br>lstrcpy(szFiles, szSigDir); <br>lstrcat(szFiles, TEXT("\\*")); <br> <br>// hide the directory. <br> <br>if (!SetFileAttributes(szSigDir, FILE_ATTRIBUTE_HIDDEN)) { <br>ErrorMsg(TEXT("Another process is using the \\sig directory.")); <br>return FALSE; <br>} <br> <br>hFindFile = FindFirstFile(szFiles, &amp;FindFileData); <br> <br>if (hFindFile == INVALID_HANDLE_VALUE) { <br>SetFileAttributes(szSigDir, FILE_ATTRIBUTE_NORMAL); <br>return FALSE; <br>} <br> <br>// Hide all the signature files. <br> <br>do { <br>lstrcpy(szFileName, szSigDir); <br>lstrcat(szFileName, TEXT("\\")); <br>lstrcat(szFileName, FindFileData.cFileName); <br> <br>if (!CFilerIsDirectory(szFileName)) { <br>if (!SetFileAttributes(szFileName, FILE_ATTRIBUTE_HIDDEN)) { <br>SetFileAttributes(szSigDir, FILE_ATTRIBUTE_NORMAL); <br>FindClose(hFindFile); <br>ErrorMsg(TEXT("Another process is using a signature file.")); <br>return FALSE; <br>} <br>} <br>} while (FindNextFile(hFindFile, &amp;FindFileData)  <br>|| GetLastError() != ERROR_NO_MORE_FILES); <br> <br>FindClose(hFindFile); <br> <br>return TRUE; <br>} <br> <br>/************************************************************************\ <br>* ShowSignatures() <br>* <br>* purpose: <br>* "unhides" the directory \sig and its contents <br>* <br>* returns <br>* TRUE if successful <br>* FALSE if unsuccessful <br>\************************************************************************/ <br> <br>BOOL ShowSignatures(VOID) { <br>WIN32_FIND_DATA FindFileData; <br>HANDLE hFindFile; <br>TCHAR szFiles[PATH_SIZE]; <br>TCHAR szFileName[PATH_SIZE]; <br>TCHAR szSigDir[PATH_SIZE]; <br> <br>GetSigDir(szSigDir); <br>lstrcpy(szFiles, szSigDir); <br>lstrcat(szFiles, TEXT("\\*")); <br> <br>// unhide the directory <br> <br>if (!SetFileAttributes(szSigDir, FILE_ATTRIBUTE_NORMAL)) { <br>ErrorMsg(TEXT("Another process is using the \\sig directory.")); <br>return FALSE; <br>} <br> <br>hFindFile = FindFirstFile(szFiles, &amp;FindFileData); <br> <br>if (hFindFile == INVALID_HANDLE_VALUE) { <br>SetFileAttributes(szSigDir, FILE_ATTRIBUTE_HIDDEN); <br>return FALSE; <br>} <br> <br>// unhide all the signature files. <br> <br>do { <br>lstrcpy(szFileName, szSigDir); <br>lstrcat(szFileName, TEXT("\\")); <br>lstrcat(szFileName, FindFileData.cFileName); <br> <br>if (!CFilerIsDirectory(szFileName)) { <br>if (!SetFileAttributes(szFileName, FILE_ATTRIBUTE_NORMAL)) { <br>SetFileAttributes(szSigDir, FILE_ATTRIBUTE_HIDDEN); <br>FindClose(hFindFile); <br>ErrorMsg(TEXT("Another process is using a signature file.")); <br>return FALSE; <br>} <br>} <br>} while (FindNextFile(hFindFile, &amp;FindFileData)  <br>|| GetLastError() != ERROR_NO_MORE_FILES); <br> <br>FindClose(hFindFile); <br> <br>return TRUE; <br>} <br> <br>/************************************************************************\ <br>* c2r64() <br>* <br>* input: <br>* i - integer value to be converted to a radix64 character <br>* c - address where character is to be stored <br>* <br>* purpose: <br>* converts an integer between 0 and 63 to a character. <br>* 0-25 -&gt; A-Z <br>* 26 - 51 -&gt; a-z <br>* 52 - 61 -&gt; 0-9 <br>* 62 -&gt; + <br>* 63 -&gt; _ <br>* <br>* returns: <br>* TRUE if successful <br>* FALSE if unsuccessful <br>\************************************************************************/ <br> <br>BOOL c2r64(INT i, LPTSTR c) { <br>if (!c) { <br>ErrorMsg(TEXT("c2r64: c is NULL.")); <br>return FALSE; <br>} <br> <br>if (0 &lt;= i &amp;&amp; i &lt;= 25) <br>*c = TEXT('A') + i; <br>else if (26 &lt;= i &amp;&amp; i &lt;= 51) <br>*c = TEXT('a') + i - 26; <br>else if (52 &lt;= i &amp;&amp; i &lt;= 61) <br>*c = TEXT('0') + i - 52; <br>else if (i == 62) <br>*c = TEXT('+'); <br>else if (i == 63) <br>*c = TEXT('_'); <br>else { <br>ErrorMsg(TEXT("c2r64: c is not between 0 and 63.")); <br>return FALSE; <br>} <br>return TRUE; <br>} <br> <br>/************************************************************************\ <br>* SHAtoRadix64 takes as input a SHA_SIZE-byte hash of the full  <br>* pathname of a file. It produces a 27-byte "Radix64"  <br>* representation of the hash, where each byte in the <br>* "Radix64" representation is between 0 and 2^6. <br>* It pretends that the SHZ_SIZE + 1st input byte is NULL. <br>\************************************************************************/ <br> <br>BOOL SHAtoRadix64(LPBYTE pbPathHash, LPTSTR szFileName) { <br>INT i, j; <br>TCHAR c1 = 0, c2 = 0, c3 = 0, c4 = 0; <br> <br>if (!pbPathHash) { <br>ErrorMsg(TEXT("SHAtoRadix64: pbPathHash is NULL.")); <br>return FALSE; <br>} <br> <br>if (!szFileName) { <br>ErrorMsg(TEXT("SHAtoRadix64: szFileName is NULL.")); <br>return FALSE; <br>} <br> <br>for (i = 0, j = 0; i &lt; 18 &amp;&amp; j &lt; 24; i += 3, j += 4) { <br>c1 = c1 | (((pbPathHash[i + 0] &gt;&gt; 7) &amp; 1) &lt;&lt; 5); <br>c1 = c1 | (((pbPathHash[i + 0] &gt;&gt; 6) &amp; 1) &lt;&lt; 4); <br>c1 = c1 | (((pbPathHash[i + 0] &gt;&gt; 5) &amp; 1) &lt;&lt; 3); <br>c1 = c1 | (((pbPathHash[i + 0] &gt;&gt; 4) &amp; 1) &lt;&lt; 2); <br>c1 = c1 | (((pbPathHash[i + 0] &gt;&gt; 3) &amp; 1) &lt;&lt; 1); <br>c1 = c1 | (((pbPathHash[i + 0] &gt;&gt; 2) &amp; 1) &lt;&lt; 0); <br> <br>c2 = c2 | (((pbPathHash[i + 0] &gt;&gt; 1) &amp; 1) &lt;&lt; 5); <br>c2 = c2 | (((pbPathHash[i + 0] &gt;&gt; 0) &amp; 1) &lt;&lt; 4); <br>c2 = c2 | (((pbPathHash[i + 1] &gt;&gt; 7) &amp; 1) &lt;&lt; 3); <br>c2 = c2 | (((pbPathHash[i + 1] &gt;&gt; 6) &amp; 1) &lt;&lt; 2); <br>c2 = c2 | (((pbPathHash[i + 1] &gt;&gt; 5) &amp; 1) &lt;&lt; 1); <br>c2 = c2 | (((pbPathHash[i + 1] &gt;&gt; 4) &amp; 1) &lt;&lt; 0); <br> <br>c3 = c3 | (((pbPathHash[i + 1] &gt;&gt; 3) &amp; 1) &lt;&lt; 5); <br>c3 = c3 | (((pbPathHash[i + 1] &gt;&gt; 2) &amp; 1) &lt;&lt; 4); <br>c3 = c3 | (((pbPathHash[i + 1] &gt;&gt; 1) &amp; 1) &lt;&lt; 3); <br>c3 = c3 | (((pbPathHash[i + 1] &gt;&gt; 0) &amp; 1) &lt;&lt; 2); <br>c3 = c3 | (((pbPathHash[i + 2] &gt;&gt; 7) &amp; 1) &lt;&lt; 1); <br>c3 = c3 | (((pbPathHash[i + 2] &gt;&gt; 6) &amp; 1) &lt;&lt; 0); <br> <br>c4 = c4 | (((pbPathHash[i + 2] &gt;&gt; 5) &amp; 1) &lt;&lt; 5); <br>c4 = c4 | (((pbPathHash[i + 2] &gt;&gt; 4) &amp; 1) &lt;&lt; 4); <br>c4 = c4 | (((pbPathHash[i + 2] &gt;&gt; 3) &amp; 1) &lt;&lt; 3); <br>c4 = c4 | (((pbPathHash[i + 2] &gt;&gt; 2) &amp; 1) &lt;&lt; 2); <br>c4 = c4 | (((pbPathHash[i + 2] &gt;&gt; 1) &amp; 1) &lt;&lt; 1); <br>c4 = c4 | (((pbPathHash[i + 2] &gt;&gt; 0) &amp; 1) &lt;&lt; 0); <br> <br>c2r64(c1, &amp;(szFileName[j + 0])); <br>c2r64(c2, &amp;(szFileName[j + 1])); <br>c2r64(c3, &amp;(szFileName[j + 2])); <br>c2r64(c4, &amp;(szFileName[j + 3])); <br> <br>c1 = 0; c2 = 0; c3 = 0; c4 = 0; <br>} <br> <br>c1 = c1 | (((pbPathHash[18] &gt;&gt; 7) &amp; 1) &lt;&lt; 5); <br>c1 = c1 | (((pbPathHash[18] &gt;&gt; 6) &amp; 1) &lt;&lt; 4); <br>c1 = c1 | (((pbPathHash[18] &gt;&gt; 5) &amp; 1) &lt;&lt; 3); <br>c1 = c1 | (((pbPathHash[18] &gt;&gt; 4) &amp; 1) &lt;&lt; 2); <br>c1 = c1 | (((pbPathHash[18] &gt;&gt; 3) &amp; 1) &lt;&lt; 1); <br>c1 = c1 | (((pbPathHash[18] &gt;&gt; 2) &amp; 1) &lt;&lt; 0); <br> <br>c2 = c2 | (((pbPathHash[18] &gt;&gt; 1) &amp; 1) &lt;&lt; 5); <br>c2 = c2 | (((pbPathHash[18] &gt;&gt; 0) &amp; 1) &lt;&lt; 4); <br>c2 = c2 | (((pbPathHash[19] &gt;&gt; 7) &amp; 1) &lt;&lt; 3); <br>c2 = c2 | (((pbPathHash[19] &gt;&gt; 6) &amp; 1) &lt;&lt; 2); <br>c2 = c2 | (((pbPathHash[19] &gt;&gt; 5) &amp; 1) &lt;&lt; 1); <br>c2 = c2 | (((pbPathHash[19] &gt;&gt; 4) &amp; 1) &lt;&lt; 0); <br> <br>c3 = c3 | (((pbPathHash[19] &gt;&gt; 3) &amp; 1) &lt;&lt; 5); <br>c3 = c3 | (((pbPathHash[19] &gt;&gt; 2) &amp; 1) &lt;&lt; 4); <br>c3 = c3 | (((pbPathHash[19] &gt;&gt; 1) &amp; 1) &lt;&lt; 3); <br>c3 = c3 | (((pbPathHash[19] &gt;&gt; 0) &amp; 1) &lt;&lt; 2); <br>c3 = c3 | (((0              &gt;&gt; 7) &amp; 1) &lt;&lt; 1); <br>c3 = c3 | (((0              &gt;&gt; 6) &amp; 1) &lt;&lt; 0); <br> <br>c2r64(c1, &amp;(szFileName[24])); <br>c2r64(c2, &amp;(szFileName[25])); <br>c2r64(c3, &amp;(szFileName[26])); <br> <br>szFileName[27] = TEXT('\0'); <br> <br>return TRUE; <br>} <br> <br>/************************************************************************\ <br>* Exit1 and Exit2 close handles, etc. for CFILEREncryptFile, <br>* CFILERDecryptFile, SignFile, and VerifyFile. <br>\************************************************************************/ <br> <br>void Exit1(HWND hWnd, LPTSTR message, HANDLE hFile1, HANDLE hFile2) { <br>CloseHandle(hFile1); <br>CloseHandle(hFile2); <br>MessageBox(hWnd, message, NULL, MB_OK); <br>return; <br>} <br> <br>void Exit2(HWND hWnd, LPTSTR message, HWND hwndDlg, HANDLE hFile1, HANDLE hFile2) { <br>CloseHandle(hFile1); <br>CloseHandle(hFile2); <br>EndDialog(hwndDlg, FALSE); <br>MessageBox(hWnd, message, NULL, MB_OK); <br>return; <br>} <br> <br> <br>/************************************************************************\ <br>* CFILEREncryptFile() <br>* <br>* input: <br>* hWnd - HWND specified by caller <br>* szFileName - buffer containing full pathname of file to encrypt <br>* <br>* Opens a file to encrypt and saves the file in <br>* encrypted form in the same path as the plaintext file. <br>* It is saved as a hidden file with a random filename. Its filename is <br>* encrypted with fnKey and is stored in the header of the file. <br>* Deletes the plaintext file. <br>* <br>* returns: <br>* TRUE if successful <br>* FALSE if unsuccessful <br>\************************************************************************/ <br> <br>BOOL CFILEREncryptFile(HWND hWnd, LPTSTR szFileName) { <br>TCHARszEncryptedFileName[PATH_SIZE]; <br>TCHARszFileName2[PATH_SIZE]; <br>TCHARszRandomName[PATH_SIZE]; <br>TCHARszDirBuf[PATH_SIZE]; <br>BYTEpEncryptBuf[2 * BUF_SIZE]; <br>DWORDdwNumBytesRead = BUF_SIZE; <br>DWORDdwNumBytesWritten; <br>DWORDdwEncryptLen = BUF_SIZE; <br>HWNDhwndDlg; <br>HCRYPTKEYhFileKey; <br>HCRYPTKEYphEncryptPubKey; <br>HCRYPTKEYhfnKey; <br>BYTE pbFileKeyBlob[BUF_SIZE]; <br>DWORD dwFileBlobLen = BUF_SIZE; <br>HANDLEhFileRead = INVALID_HANDLE_VALUE; <br>HANDLEhFileWrite = INVALID_HANDLE_VALUE; <br>HCRYPTHASHhHash; <br>DWORDdwBufLen = HEADER_SIZE * sizeof(TCHAR); <br>DWORDdwDataLen = HEADER_SIZE * sizeof(TCHAR); <br> <br>if (!szFileName) { <br>MessageBox(hWnd, TEXT("CFILEREncryptFile: szFileName is NULL."), NULL, MB_OK); <br>return FALSE; <br>} <br> <br>hfnKey = GetfnKey(hWnd); <br> <br>if (!hfnKey) { <br>MessageBox(hWnd, TEXT("CFILEREncryptFile: GetfnKey failed."), NULL, MB_OK); <br>return FALSE; <br>} <br> <br>SeparatePathName2(szFileName, szDirBuf, szEncryptedFileName); <br> <br>GetEncryptPublicKey(hWnd, &amp;phEncryptPubKey); <br>GenRandomName(szRandomName); <br> <br>// Generate a key to encrypt this file only if the user <br>// selected the password option <br> <br>if (!AlgidEncrypt) { <br>if (RCRYPT_FAILED(CryptCreateHash(hMe, CALG_MD4, 0, 0, &amp;hHash))) { <br>MessageBox(hWnd, TEXT("CFILEREncryptFile: CryptCreateHash failed."), NULL, MB_OK); <br>return FALSE; <br>} <br> <br>if (RCRYPT_FAILED(CryptHashData(hHash, (LPBYTE)sPass, lstrlen(sPass), 0))) { <br>MessageBox(hWnd, TEXT("CFILEREncryptFile: CryptHashData failed."), NULL, MB_OK); <br>return FALSE; <br>} <br> <br>if (RCRYPT_FAILED(CryptDeriveKey(hMe, CALG_RC2, hHash, CRYPT_EXPORTABLE, &amp;hFileKey))) { <br>MessageBox(hWnd, TEXT("CFILEREncryptFile: CryptDeriveKey failed."), NULL, MB_OK); <br>return FALSE; <br>} <br> <br>CryptDestroyHash(hHash); <br>} <br>// Generate a key to encrypt this file only (not derived from password). <br>else if (RCRYPT_FAILED(CryptGenKey(hMe, AlgidEncrypt, CRYPT_EXPORTABLE, &amp;hFileKey))) { <br>MessageBox(hWnd, TEXT("CFILEREncryptFile: CryptGenKey failed."), NULL, MB_OK); <br>return FALSE; <br>}  <br> <br>dwFileBlobLen = MAXBLOBLEN; <br> <br>//Export the key so that it can be stored on the disk. <br> <br>if (RCRYPT_FAILED(CryptExportKey(hFileKey,  <br>  phEncryptPubKey,  <br>  SIMPLEBLOB,  <br>  0,  <br>  pbFileKeyBlob,  <br>  &amp;dwFileBlobLen))) { <br>MessageBox(hWnd, TEXT("CFILEREncryptFile: CryptExportKey failed."), NULL, MB_OK); <br>return FALSE; <br>} <br> <br>   if (!AlgidEncrypt) <br>   dwFileBlobLen = 0; <br>    <br>   // Open a file to encrypt <br> <br>hFileRead = CreateFile(szFileName,  <br>   GENERIC_READ,  <br>   0,  <br>   0,  <br>   OPEN_EXISTING,  <br>   FILE_ATTRIBUTE_READONLY,  <br>   0); <br> <br>if (hFileRead == INVALID_HANDLE_VALUE) { <br>MessageBox(hWnd, TEXT("CFILEREncryptFile: CreateFile failed."), NULL, MB_OK); <br>return FALSE; <br>} <br>       <br>lstrcpy(szFileName2, szDirBuf); <br>lstrcat(szFileName2, TEXT("\\")); <br>lstrcat(szFileName2, szRandomName);  <br> <br>// Create a hidden .CRP file with a random filename. <br> <br>hFileWrite = CreateFile(szFileName2,  <br>GENERIC_READ | GENERIC_WRITE,  <br>0,  <br>0,  <br>CREATE_NEW,  <br>FILE_ATTRIBUTE_HIDDEN,  <br>0); <br> <br>if (hFileWrite == INVALID_HANDLE_VALUE) { <br>MessageBox(hWnd, TEXT("Cannot write to media."), NULL, MB_OK); <br>CloseHandle(hFileRead); <br>return FALSE; <br> <br>} <br> <br>// Tell the user that the program is busy encrypting data <br>hwndDlg = CreateDialog(ghModule, TEXT("ENCRYPTING"), hWnd, CryptDlgProc); <br> <br>if (!hwndDlg) { <br>Exit2(hWnd, TEXT("CFILEREncryptFile: CreateDialog failed."), hwndDlg, hFileRead, hFileWrite); <br>DeleteFile(szFileName2); <br>return FALSE; <br>} <br> <br>if (RCRYPT_FAILED(CryptEncrypt(hfnKey, 0, TRUE, 0, (LPBYTE)szEncryptedFileName, &amp;dwDataLen, dwBufLen))) { <br>Exit2(hWnd, TEXT("CFILEREncryptFile: CryptEncrypt failed."), hwndDlg, hFileRead, hFileWrite); <br>DeleteFile(szFileName2); <br>return FALSE; <br>} <br> <br>// Write the original file's encrypted name to disk. <br> <br>if (RCRYPT_FAILED(WriteFile(hFileWrite,  <br>      szEncryptedFileName,  <br>      HEADER_SIZE * sizeof(*szEncryptedFileName),  </code></pre>
<p>
</p>
<pre><code>&amp;dwNumBytesWritten,  <br>      0))) { <br>Exit2(hWnd, TEXT("CFILEREncryptFile: WriteFile failed."), hwndDlg, hFileRead, hFileWrite); <br>DeleteFile(szFileName2); <br>return FALSE; <br>} <br> <br>// Write the key blob length to disk. <br> <br>if (!WriteFile(hFileWrite, &amp;dwFileBlobLen, sizeof(dwFileBlobLen), &amp;dwNumBytesWritten, 0)) { <br>Exit2(hWnd, TEXT("CFILEREncryptFile: WriteFile failed."), hwndDlg, hFileRead, hFileWrite); <br>DeleteFile(szFileName2); <br>return FALSE; <br>} <br> <br>// Write the key blob to disk. <br> <br>if (dwFileBlobLen &amp;&amp; !WriteFile(hFileWrite,  <br>pbFileKeyBlob,  <br>dwFileBlobLen,  <br>&amp;dwNumBytesWritten,  <br>0)) { <br>Exit2(hWnd, TEXT("CFILEREncryptFile: WriteFile failed."), hwndDlg, hFileRead, hFileWrite); <br>DeleteFile(szFileName2); <br>return FALSE; <br>} <br> <br>// Encrypt the file by reading small amounts <br>// of data from the disk, encrypting those Bufs, and saving the <br>// encrypted Bufs to disk. The loop terminates as soon as there is <br>// not enough data left on the disk to read a full Buf. <br> <br>for ( ; ; ) { <br> <br>if (!ReadFile(hFileRead, pEncryptBuf, BUF_SIZE, &amp;dwNumBytesRead, 0)) { <br>Exit2(hWnd,  <br>TEXT("CFILEREncryptFile: ReadFile failed."), <br>hwndDlg,  <br>hFileRead,  <br>hFileWrite); <br>DeleteFile(szFileName2); <br>return FALSE; <br>} <br> <br>if (dwNumBytesRead != BUF_SIZE) <br>break; <br> <br>if (RCRYPT_FAILED(CryptEncrypt(hFileKey, 0, FALSE, 0, pEncryptBuf, &amp;dwEncryptLen, BUF_SIZE))) { <br>Exit2(hWnd,  <br>TEXT("CFILEREncryptFile: CryptEncrypt failed."), <br>hwndDlg,  <br>hFileRead,  <br>hFileWrite); <br>DeleteFile(szFileName2); <br>return FALSE; <br>} <br> <br>if (!WriteFile(hFileWrite, pEncryptBuf, dwEncryptLen, &amp;dwNumBytesWritten, 0)) { <br>Exit2(hWnd,  <br>TEXT("CFILEREncryptFile: WriteFile failed."), <br>hwndDlg,  <br>hFileRead,  <br>hFileWrite); <br>DeleteFile(szFileName2); <br>return FALSE; <br>} <br> <br>dwEncryptLen = BUF_SIZE; <br>} <br> <br>// Encrypt the last block of data. <br> <br>if (0 &lt; dwNumBytesRead &amp;&amp; dwNumBytesRead &lt; BUF_SIZE) { <br>dwEncryptLen = dwNumBytesRead; <br> <br>if (RCRYPT_FAILED(CryptEncrypt(hFileKey, 0, TRUE, 0, pEncryptBuf, &amp;dwEncryptLen, BUF_SIZE))) { <br>Exit2(hWnd, TEXT("CryptEncrypt failed."), hwndDlg, hFileRead, hFileWrite); <br>DeleteFile(szFileName2); <br>return FALSE; <br>} <br> <br>if (!WriteFile(hFileWrite, pEncryptBuf, dwEncryptLen, &amp;dwNumBytesWritten, 0)) { <br>Exit2(hWnd, TEXT("WriteFile failed."), hwndDlg, hFileRead, hFileWrite); <br>DeleteFile(szFileName2); <br>return FALSE; <br>} <br>} <br> <br>if (RCRYPT_FAILED(CryptDestroyKey(hFileKey))) { <br>Exit2(hWnd, TEXT("CryptDestroyKey failed."), hwndDlg, hFileRead,hFileWrite); <br>DeleteFile(szFileName2); <br>return FALSE; <br>} <br> <br>CloseHandle(hFileRead); <br> <br>if (!DeleteFile(szFileName)) { <br>EndDialog(hwndDlg, FALSE); <br>MessageBox(hWnd, TEXT("File cannot be deleted: It is either in use by another process, or it is a system file."), NULL, MB_OK); <br>CloseHandle(hFileWrite); <br>DeleteFile(szFileName2); <br>return FALSE; <br>} <br> <br>EndDialog(hwndDlg, FALSE); <br>CloseHandle(hFileWrite); <br>SetFileAttributes(szFileName2, FILE_ATTRIBUTE_HIDDEN); <br> <br>return TRUE; <br>} <br> <br>/************************************************************************\ <br>* CFILERDecryptFile() <br>* <br>* input: <br>* hWnd - HWND specified by caller <br>* szFileName - buffer containing full pathname of file to decrypt. <br>* <br>* purpose: <br>* decrypts the file specified by szFileName and stores the file in <br>* the same directory. Deletes the encrypted file. <br>* <br>* returns: <br>* TRUE if successful <br>* FALSE if unsuccessful <br>\************************************************************************/ <br> <br>BOOL CFILERDecryptFile(HWND hWnd, LPTSTR szFileName) <br>{ <br>TCHARszFileName2[PATH_SIZE]; <br>TCHARszDecryptedFileName[PATH_SIZE]; <br>TCHARszFile[PATH_SIZE]; <br>BYTEpDecryptBuf[2 * BUF_SIZE]; <br>DWORDdwNumBytesRead; <br>DWORDdwNumBytesWritten; <br>DWORDdwDecryptDataLen = BUF_SIZE; <br>HCRYPTKEYhFileKey; <br>HCRYPTKEYphEncryptPubKey; <br>BYTE pbDecryptBlob[BUF_SIZE]; <br>DWORD dwDecryptBlobLen; <br>HWNDhwndDlg; <br>HANDLEhFileRead; <br>HANDLEhFileWrite = INVALID_HANDLE_VALUE; <br>HCRYPTHASHhHash; <br>DWORDdwDataLen = HEADER_SIZE * sizeof(TCHAR); <br>//BYTEpHashData[BUF_SIZE]; <br>DWORDHashDataLen; <br> <br>if (!szFileName) { <br>MessageBox(hWnd, TEXT("CFILERDecryptFile: szFileName is NULL."), NULL, MB_OK); <br>return FALSE; <br>} <br> <br>GetEncryptPublicKey(hWnd, &amp;phEncryptPubKey); <br> <br>GetDecryptedFileName(hWnd,  <br> szFileName,  <br> szDecryptedFileName,  <br> &amp;hFileRead); <br> <br>// Read the key blob length from the disk. <br> <br>if (!ReadFile(hFileRead, &amp;dwDecryptBlobLen, sizeof(dwDecryptBlobLen), &amp;dwNumBytesRead, 0)) { <br>MessageBox(hWnd, TEXT("CFILERDecryptFile: ReadFile failed."), NULL, MB_OK); <br>CloseHandle(hFileRead); <br>return FALSE; <br>} <br> <br>// Read the key blob from the disk into a Buf. <br> <br>if (dwDecryptBlobLen &amp;&amp; !ReadFile(hFileRead,  <br>  pbDecryptBlob,  <br>  dwDecryptBlobLen,  <br>  &amp;dwNumBytesRead,  <br>  0)) { <br>MessageBox(hWnd, TEXT("CFILERDecryptFile: ReadFile failed."), NULL, MB_OK); <br>CloseHandle(hFileRead); <br>return FALSE; <br>}  <br> <br>// Import the key whose blob is contained in the Buf pbDecryptBlob <br> <br>if (dwDecryptBlobLen &amp;&amp; !CryptImportKey(hMe,  <br>pbDecryptBlob,  <br>dwDecryptBlobLen,  <br>0,  <br>0,  <br>&amp;hFileKey)) { <br>MessageBox(hWnd, TEXT("CFILERDecryptFile: CryptImportKey failed."), NULL, MB_OK); <br>CloseHandle(hFileRead); <br>return FALSE; <br>} <br> <br>SeparatePathName(szFileName, szFileName2, szFile); <br> <br>lstrcat(szFileName2, TEXT("\\")); <br>lstrcat(szFileName2, szDecryptedFileName); <br> <br>// Generate a key to decrypt this file if the user <br>// selected the password option <br> <br>if (!dwDecryptBlobLen) { <br>lstrcpy(szPassName, szFileName2); <br> <br>if (!GetPass(hWnd)) { <br>MessageBox(hWnd, TEXT("CFILERDecryptFile: GetPass failed."), NULL, MB_OK); <br>CloseHandle(hFileRead); <br>return FALSE; <br>} <br> <br>lstrcpy(szPassName, TEXT("\0")); <br> <br>if (RCRYPT_FAILED(CryptCreateHash(hMe, CALG_MD4, 0, 0, &amp;hHash))) { <br>MessageBox(hWnd, TEXT("CFILERDecryptFile: CryptCreateHash failed."), NULL, MB_OK); <br>CloseHandle(hFileRead); <br>return FALSE; <br>} <br> <br>if (RCRYPT_FAILED(CryptHashData(hHash, (LPBYTE)sPass, lstrlen(sPass), 0))) { <br>MessageBox(hWnd, TEXT("DecrypttFile: CryptHashData failed."), NULL, MB_OK); <br>return FALSE; <br>} <br> <br>HashDataLen = BUF_SIZE; <br> <br>if (RCRYPT_FAILED(CryptDeriveKey(hMe, CALG_RC2, hHash, CRYPT_EXPORTABLE, &amp;hFileKey))) { <br>MessageBox(hWnd, TEXT("CFILERDecryptFile: CryptDeriveKey failed."), NULL, MB_OK); <br>CloseHandle(hFileRead); <br>return FALSE; <br>} <br> <br>CryptDestroyHash(hHash); <br> <br>dwDecryptBlobLen = 0; <br>} <br> <br>// Recreate the plaintext file <br> <br>hFileWrite = CreateFile(szFileName2,  <br>GENERIC_READ | GENERIC_WRITE,  <br>0,  <br>0,  <br>CREATE_ALWAYS,  <br>FILE_ATTRIBUTE_NORMAL,  <br>0); <br> <br>if (hFileWrite == INVALID_HANDLE_VALUE) { <br>if (GetLastError() == ERROR_FILENAME_EXCED_RANGE) { <br>TCHAR szEmergencyName[PATH_SIZE]; <br>TCHAR szEmergencyRandomName[PATH_SIZE]; <br>TCHAR szDir1[PATH_SIZE]; <br>TCHAR szFile1[PATH_SIZE]; <br>SeparatePathName(szFileName, szDir1, szFile1); <br>GenRandomName2(szEmergencyRandomName); <br>lstrcpy(szEmergencyName, szDir1); <br>lstrcat(szEmergencyName, TEXT("\\recovered")); <br>lstrcat(szEmergencyName, szEmergencyRandomName); <br>hFileWrite = CreateFile(szEmergencyName, GENERIC_READ | GENERIC_WRITE, <br>0, 0, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, 0); <br>if (hFileWrite == INVALID_HANDLE_VALUE) { <br>ErrorMsg(TEXT("Could not recover file.")); <br>return FALSE; <br>} <br>} <br>else { <br>MessageBox(hWnd, TEXT("CFILERDecryptFile: CreateFile failed."), NULL, MB_OK); <br>CloseHandle(hFileRead); <br>return FALSE; <br>} <br>} <br> <br>// Create a dialog box to inform the user that the program is busy decrypting data. <br> <br>hwndDlg = CreateDialog(ghModule, TEXT("DECRYPTING"), hWnd, CryptDlgProc); <br> <br>if (!hwndDlg) { <br>Exit2(hWnd, TEXT("CFILERDecryptFile: CreateDialog failed."), hwndDlg, hFileRead, hFileWrite); <br>DeleteFile(szFileName2); <br>return FALSE; <br>} <br> <br>// The following for loop decrypts the data in units of BUF_SIZE <br>// at a time and stores the decrypted data into the file hFileWrite. <br>// The loop terminates when fewer than BUF_SIZE have been read. <br> <br>for ( ; ; ) { <br>if (!ReadFile(hFileRead, pDecryptBuf, BUF_SIZE, &amp;dwNumBytesRead, 0)) { <br>Exit2(hWnd,  <br>TEXT("CFILERDecryptFile: ReadFile failed."), <br>hwndDlg,  <br>hFileRead,  <br>hFileWrite); <br>DeleteFile(szFileName2); <br>return FALSE; <br>} <br> <br>if (dwNumBytesRead != BUF_SIZE) <br>break; <br> <br>if (RCRYPT_FAILED(CryptDecrypt(hFileKey, 0, FALSE, 0, pDecryptBuf, &amp;dwDecryptDataLen))) { <br>Exit2(hWnd,  <br>TEXT("CFILERDecryptFile: CryptDecrypt failed."), <br>hwndDlg,  <br>hFileRead,  <br>hFileWrite); <br>DeleteFile(szFileName2); <br>return FALSE; <br>} <br> <br>if (!WriteFile(hFileWrite, pDecryptBuf, dwDecryptDataLen, &amp;dwNumBytesWritten, 0)) { <br>Exit2(hWnd,  <br>TEXT("CFILERDecryptFile: WriteFile failed."), <br>hwndDlg,  <br>hFileRead,  <br>hFileWrite); <br>DeleteFile(szFileName2); <br>return FALSE; <br>} <br> <br>dwDecryptDataLen = BUF_SIZE; <br>} <br> <br>// Decrypt the final block of data. <br> <br>if (0 &lt; dwNumBytesRead &amp;&amp; dwNumBytesRead &lt; BUF_SIZE) { <br>dwDecryptDataLen = dwNumBytesRead; <br> <br>if (RCRYPT_FAILED(CryptDecrypt(hFileKey, 0, TRUE, 0, pDecryptBuf, &amp;dwDecryptDataLen))) { <br> <br>MessageBox(hWnd, TEXT("GetfnKey: CryptImportKey failed"), NULL, MB_OK); <br>Exit2(hWnd,  <br>TEXT("CFILERDecryptFile: CryptDecrypt failed."), <br>hwndDlg,  <br>hFileRead,  <br>hFileWrite); <br>DeleteFile(szFileName2); <br>return FALSE; <br>} <br> <br>if (!WriteFile(hFileWrite, pDecryptBuf, dwDecryptDataLen, &amp;dwNumBytesWritten, 0)) { <br>Exit2(hWnd,  <br>TEXT("CFILERDecryptFile: WriteFile failed."), <br>hwndDlg,  <br>hFileRead,  <br>hFileWrite); <br>DeleteFile(szFileName2); <br>return FALSE; <br>} <br>} <br> <br>if (!CryptDestroyKey(hFileKey)) { <br>Exit2(hWnd,  <br>TEXT("CFILERDecryptFile: CryptDestroyKey failed."), <br>hwndDlg,  <br>hFileRead,  <br>hFileWrite); <br>DeleteFile(szFileName2); <br>return FALSE; <br>} <br> <br>EndDialog(hwndDlg, FALSE); <br>CloseHandle(hFileRead); <br>CloseHandle(hFileWrite); <br> <br>if (!DeleteFile(szFileName)) { <br>MessageBox(hWnd, TEXT("CFILERDecryptFile: DeleteFile failed."), NULL, MB_OK); <br>DeleteFile(szFileName2); <br>} <br> <br>return TRUE; <br>} <br> <br>/************************************************************************\ <br>* SignFile: <br>* Opens a file, creates a hash value of the file, <br>* signs that hash value, and stores the result to disk. <br>\************************************************************************/ <br> <br>BOOL SignFile(HWND hWnd, LPTSTR szFileName) { <br>TCHAR szFilter1[] = TEXT("Signature Files (*.SGN)\0*.SGN\0"); <br>TCHAR szFilter2[] = TEXT("All Files (*.*)\0*.*\0"); <br>TCHARszFile[PATH_SIZE] = TEXT("\0"); <br>TCHARszFile2[PATH_SIZE] = TEXT("\0"); <br>TCHARszFileTitle[PATH_SIZE]; <br>TCHARszFileName2[PATH_SIZE]; <br>DWORDdwNumBytesRead = BUF_SIZE; <br>DWORDdwNumBytesWritten; <br>HWNDhwndDlg; <br>HANDLEhFileRead = INVALID_HANDLE_VALUE; <br>HANDLEhFileWrite = INVALID_HANDLE_VALUE; <br>HCRYPTKEYphSignaturePubKey; <br>HCRYPTHASHhHash; <br>BYTEpSignBuf[BUF_SIZE]; <br>BYTEpbHash[BUF_SIZE]; <br>DWORDdwHashLen; <br> <br>GetSignaturePublicKey(hWnd, &amp;phSignaturePubKey); <br> <br>if (!szFileName) { <br>MessageBox(hWnd, TEXT("SignFile: szFileName is NULL."), NULL, MB_OK); <br>return FALSE; <br>} <br> <br>lstrcpy(szFile, TEXT("")); <br>lstrcpy(szFileTitle, TEXT("")); <br> <br>// Open plaintext file <br> <br>hFileRead = CreateFile(szFileName,  <br>   GENERIC_READ,  <br>   0,  <br>   0,  <br>   OPEN_EXISTING,  <br>   FILE_ATTRIBUTE_READONLY,  <br>   0); <br> <br>if (hFileRead == INVALID_HANDLE_VALUE) { <br>MessageBox(hWnd, TEXT("SignFile: CreateFile failed."), NULL, MB_OK); <br>return FALSE; <br>} <br> <br>// hash the full pathname of the file. This will be the name of <br>// the signature file. <br> <br>if (!GetSigFileName(szFileName, szFileName2)) { <br>MessageBox(hWnd, TEXT("SignFile: GetSigFileName failed."), NULL, MB_OK); <br>return FALSE; <br>} <br> <br>// Create signature file. <br> <br>if (GetFileAttributes(szFileName2) == 0xFFFFFFFF) { <br> <br>hFileWrite = CreateFile(szFileName2,  <br>GENERIC_READ | GENERIC_WRITE,  <br>0,  <br>0,  <br>CREATE_NEW,  <br>FILE_ATTRIBUTE_HIDDEN,  <br>0); <br> <br>if (hFileWrite == INVALID_HANDLE_VALUE) { <br>Exit1(hWnd, TEXT("SignFile: CreateFile failed."), hFileRead, hFileWrite); <br>return FALSE; <br>}  <br>} <br>else { <br>if (MessageBox(hWnd,  <br>   TEXT("Delete signature?"),  <br>   TEXT("Signature file already exists."),  <br>   MB_OKCANCEL) == IDOK) { <br> <br>DeleteFile(szFileName2); <br> <br>hFileWrite = CreateFile(szFileName2, <br>GENERIC_READ | GENERIC_WRITE, <br>0, <br>0, <br>CREATE_NEW, <br>FILE_ATTRIBUTE_HIDDEN, <br>0); <br> <br>if (hFileWrite == INVALID_HANDLE_VALUE) { <br>Exit1(hWnd, TEXT("SignFile: CreateFile failed."), hFileRead, hFileWrite); <br>return FALSE; <br>} <br>} <br>else { <br>CloseHandle(hFileRead); <br> <br>return FALSE; <br>} <br>} <br> <br>// Create a dialog box to inform the user that the program is hashing data. <br> <br>hwndDlg = CreateDialog(ghModule, TEXT("SIGNING"), hWnd, CryptDlgProc); <br> <br>if (RCRYPT_FAILED(CryptCreateHash(hMe, AlgidSign, 0, 0, &amp;hHash))) { <br>Exit2(hWnd, TEXT("SignFile: CryptCreateHash failed."), hwndDlg, hFileRead, hFileWrite); <br>DeleteFile(szFileName2); <br>return FALSE; <br>} <br> <br>// The following for loop hashes the file in BUF_SIZE Bufs at a time. <br> <br>for (dwNumBytesRead = BUF_SIZE ; dwNumBytesRead == BUF_SIZE; ) { <br>if (!ReadFile(hFileRead, pSignBuf, BUF_SIZE, &amp;dwNumBytesRead, 0)) { <br>Exit2(hWnd,  <br>TEXT("SignFile: ReadFile failed."),  <br>hwndDlg,  <br>hFileRead,  <br>hFileWrite); <br>DeleteFile(szFileName2); <br>return FALSE; <br>} <br>else if (RCRYPT_FAILED(CryptHashData(hHash, pSignBuf, dwNumBytesRead, 0))) { <br>Exit2(hWnd,  <br>TEXT("SignFile: CryptHashData failed."),  <br>hwndDlg,  <br>hFileRead,  <br>hFileWrite); <br>DeleteFile(szFileName2); <br>return FALSE; <br>} <br>} <br> <br>dwHashLen = BUF_SIZE; <br> <br>if (RCRYPT_FAILED(CryptSignHash(hHash, AT_SIGNATURE, NULL, 0, pbHash, &amp;dwHashLen))) <br>{ <br> <br>MessageBox(hWnd, TEXT("SignFile: CryptSignHash failed"), NULL, MB_OK); <br> <br>Exit2(hWnd,  <br>TEXT("SignFile: CryptSignHash failed."),  <br>hwndDlg,  <br>hFileRead,  <br>hFileWrite); <br>DeleteFile(szFileName2); <br>return FALSE; <br>}  <br> <br>// Write ALG_ID to disk <br> <br>if (!WriteFile(hFileWrite, &amp;AlgidSign, sizeof(ALG_ID), &amp;dwNumBytesWritten, 0)) { <br>Exit2(hWnd, TEXT("SignFile: WriteFile failed."), hwndDlg, hFileRead, hFileWrite); <br>return FALSE; <br>} <br> <br>// Write hash to disk. <br> <br>if (!WriteFile(hFileWrite, pbHash, dwHashLen, &amp;dwNumBytesWritten, 0)) { <br>Exit2(hWnd,  <br>TEXT("SignFile: WriteFile failed."),  <br>hwndDlg,  <br>hFileRead,  <br>hFileWrite); <br>DeleteFile(szFileName2); <br>return FALSE; <br>} <br> <br>CryptDestroyHash(hHash); <br>EndDialog(hwndDlg, FALSE); <br>CloseHandle(hFileRead); <br>CloseHandle(hFileWrite); <br> <br>return TRUE; <br>} <br> <br>/************************************************************************\ <br>* VerifyFile <br>* Opens a signature file and the original file. <br>* Hashes the original file and tries to verify <br>* the hash. <br>\************************************************************************/ <br> <br>BOOL VerifyFile(HWND hWnd, LPTSTR szFileName) { <br>TCHAR szFilter1[] = TEXT("Signature Files (*.SGN)\0*.SGN\0"); <br>TCHAR szFilter2[] = TEXT("All Files (*.*)\0*.*\0"); <br>TCHARszFile[PATH_SIZE] = TEXT("\0"); <br>TCHARszFile2[PATH_SIZE] = TEXT("\0"); <br>TCHARszFileTitle[PATH_SIZE]; <br>TCHARszFileName2[PATH_SIZE]; <br>DWORDdwNumBytesRead; <br>DWORDdwNumBytesRead2; <br>HWNDhwndDlg; <br>HANDLEhFileOrig = INVALID_HANDLE_VALUE; <br>HANDLEhFileSig = INVALID_HANDLE_VALUE; <br>BYTEpbSig[BUF_SIZE]; <br>BYTEpVerifyBuf[BUF_SIZE]; <br>DWORDdwSigLen; <br>HCRYPTHASHhHash; <br>HCRYPTKEYphSignaturePubKey; <br>ALG_ID DiskAlgid; <br> <br>if (!szFileName) { <br>MessageBox(hWnd, TEXT("VerifyFile: szFileName is NULL."), NULL, MB_OK); <br>return FALSE; <br>} <br> <br>GetSignaturePublicKey(hWnd, &amp;phSignaturePubKey); <br> <br>// hash the full pathname of the file to determine the signature file <br>// to open. <br> <br>if (!GetSigFileName(szFileName, szFileName2)) { <br>MessageBox(hWnd, TEXT("VerifyFile: GetSigFileName failed."), NULL, MB_OK); <br>return FALSE; <br>} <br> <br>lstrcpy(szFile, TEXT("")); <br>lstrcpy(szFileTitle, TEXT("")); <br> <br>// Open the plaintext file to hash it. <br> <br>hFileOrig = CreateFile(szFileName,  <br>   GENERIC_READ,  <br>   0,  <br>   0,  <br>   OPEN_EXISTING,  <br>   FILE_ATTRIBUTE_READONLY,  <br>   0); <br> <br>if (hFileOrig == INVALID_HANDLE_VALUE) { <br>MessageBox(hWnd, TEXT("VerifyFile: CreateFile failed."), NULL, MB_OK); <br>CloseHandle(hFileOrig); <br>return FALSE; <br>} <br> <br>// Automatically open the signature file if it  <br>// exists in the same directory as the file to be verified. <br>// Otherwise, prompt the user to browse the directory tree  <br>// for the signature file. <br> <br>if (GetFileAttributes(szFileName2) != 0xFFFFFFFF) { <br> <br>hFileSig = CreateFile(szFileName2,  <br>  GENERIC_READ,  <br>  0,  <br>  0,  <br>  OPEN_EXISTING,  <br>  FILE_ATTRIBUTE_READONLY,  <br>  0); <br> <br>if (hFileSig == INVALID_HANDLE_VALUE) { <br>Exit1(hWnd, TEXT("VerifyFile: CreateFile failed."), hFileOrig, hFileSig); <br>return FALSE; <br>}  <br>} <br>else { <br>Exit1(hWnd, TEXT("Signature file does not exist."), hFileOrig, hFileSig); <br>return FALSE; <br>}  <br> <br>// Create a dialog box to tell the user that the program is busy hashing data. <br> <br>hwndDlg = CreateDialog(ghModule, TEXT("VERIFYING"), hWnd, CryptDlgProc); <br> <br>// Read the ALG_ID <br> <br>if (!ReadFile(hFileSig, &amp;DiskAlgid, sizeof(ALG_ID), &amp;dwNumBytesRead2, 0)) { <br>Exit2(hWnd, TEXT("VerifyFile: ReadFile failed."), hwndDlg, hFileOrig, hFileSig); <br>return FALSE; <br>} <br> <br>// Read the hash <br> <br>if (!ReadFile(hFileSig, pbSig, BUF_SIZE, &amp;dwSigLen, 0)) { <br>Exit2(hWnd, TEXT("VerifyFile: ReadFile failed."), hwndDlg, hFileOrig, hFileSig); <br>return FALSE; <br>} <br> <br>if (RCRYPT_FAILED(CryptCreateHash(hMe, DiskAlgid, 0, 0, &amp;hHash))) { <br>Exit2(hWnd, TEXT("VerifyFile: CryptCreateHash failed."), hwndDlg, hFileOrig, hFileSig); <br>return FALSE; <br>} <br> <br>// hash the file in BUF_SIZE chunks <br> <br>for (dwNumBytesRead = BUF_SIZE; dwNumBytesRead == BUF_SIZE; ) { <br>if (!ReadFile(hFileOrig, pVerifyBuf, BUF_SIZE, &amp;dwNumBytesRead, 0)) { <br>Exit2(hWnd, TEXT("VerifyFile: ReadFile failed."), hwndDlg, hFileOrig, hFileSig); <br>return FALSE; <br>} <br>if (RCRYPT_FAILED(CryptHashData(hHash, pVerifyBuf, dwNumBytesRead, 0))) { <br>Exit2(hWnd,  <br>TEXT("VerifyFile: CryptHashData failed."),  <br>hwndDlg,  <br>hFileOrig,  <br>hFileSig); <br>return FALSE; <br>} <br>} <br> <br> <br>if (RCRYPT_FAILED(CryptVerifySignature(hHash, pbSig, dwSigLen, phSignaturePubKey, 0, 0))) { <br>EndDialog(hwndDlg, FALSE); <br>MessageBox(hWnd,  <br>   TEXT("Could not verify signature."),  <br>   TEXT("Result"),  <br>   MB_OK | MB_ICONINFORMATION); <br>CloseHandle(hFileOrig); <br>CloseHandle(hFileSig); <br>return TRUE; <br>} <br> <br>if (RCRYPT_FAILED(CryptDestroyHash(hHash))) { <br>Exit2(hWnd,  <br>TEXT("Could not destroy hash."),  <br>hwndDlg,  <br>hFileOrig,  <br>hFileSig); <br>return FALSE; <br>} <br> <br>EndDialog(hwndDlg, FALSE); <br> <br>MessageBox(hWnd,  <br>   TEXT("Signature verified."),  <br>   TEXT("Result"),  <br>   MB_OK | MB_ICONINFORMATION); <br>CloseHandle(hFileOrig); <br>CloseHandle(hFileSig); <br> <br>return TRUE; <br>} <br> <br>/************************************************************************\ <br>* EncryptDir() <br>* <br>* in parameters <br>* hWnd - HWND specified by caller <br>* szDirName - full path of directory to encrypt <br>* lpCInfo - instance data for drive child <br>* <br>* purpose:  <br>* Encrypts szDirName and recursively encrypts all of its <br>* subdirectories. Confirmation is needed for each subdirectory. <br>* A random directory name is generated, and szDirName is <br>* renamed and given hidden attributes. <br>* dirinfo contains the fnKey-encrypted directory name. <br>* <br>* returns <br>* TRUE if successful <br>* FALSE if unsuccessful <br>\************************************************************************/ <br> <br>BOOL EncryptDir(HWND hWnd, LPTSTR szDirName, LPCINFO lpCInfo) { <br>TCHARszDirInfo[PATH_SIZE]; <br>TCHARszFileName[PATH_SIZE]; <br>TCHARszEncryptedDirName[PATH_SIZE]; <br>TCHARszRandom[PATH_SIZE]; <br>TCHARszRandomName[PATH_SIZE]; <br>TCHARszDir[PATH_SIZE]; <br>TCHARszFile[PATH_SIZE]; <br>TCHARszMessage[PATH_SIZE]; <br>TCHARszOldDir[PATH_SIZE]; <br>TCHARBuf[PATH_SIZE]; <br>TCHARszDirName2[PATH_SIZE]; <br>LPTSTRlpszDirName2; <br>HANDLE hFileDirInfo; <br>HANDLEhFindFile; <br>WIN32_FIND_DATAFindFileData; <br>BOOLfNextFile; <br>DWORDdwLastError; <br>DWORDdwDataLen = BUF_SIZE; <br>DWORDdwNumBytesWritten; <br>LONGlIndex; <br>LONGlCount; <br>HCRYPTKEYhfnKey; <br> <br>if (!szDirName) { <br>MessageBox(hWnd, TEXT("EncryptDir: szDirName is NULL."), NULL, MB_OK); <br>return FALSE; <br>} <br> <br>if (!lpCInfo) { <br>MessageBox(hWnd, TEXT("EncryptDir: lpCInfo is NULL."), NULL, MB_OK); <br>return FALSE; <br>} <br> <br>hfnKey = GetfnKey(hWnd); <br> <br>if (!hfnKey) { <br>MessageBox(hWnd, TEXT("EncryptDir: GetfnKey failed."), NULL, MB_OK); <br>return FALSE; <br>} <br> <br>SeparatePathName2(szDirName, szDir, szEncryptedDirName); <br> <br>lstrcpy(szMessage, TEXT("\0")); <br>wsprintf(szMessage, TEXT("Encrypt the directory %s?\n"), szDirName); <br> <br>// ask for confirmation about encrypting the directory <br> <br>if (MessageBox(hWnd, szMessage,  <br>TEXT("Confirmation needed."), MB_OKCANCEL) == IDCANCEL) <br>return FALSE; <br> <br>lstrcpy(szFileName, szDir); <br>lstrcat(szFileName, TEXT("\\")); <br>lstrcat(szFileName, szEncryptedDirName); <br> <br>if (!szDirName) { <br>MessageBox(hWnd, TEXT("EncryptDir: szDirName is NULL."), NULL, MB_OK); <br>return FALSE; <br>} <br> <br>GenRandomName(szRandom); <br> <br>lstrcpy(szRandomName, szDir); <br>lstrcat(szRandomName, TEXT("\\")); <br>lstrcat(szRandomName, szRandom); <br>lstrcpy(szDirInfo, szFileName); <br>lstrcat(szDirInfo, TEXT("\\dirinfo")); <br> <br>// Create a file called "dirinfo" in directory about to encrypted. <br>// This will contain the original directory name encrypted with fnKey. <br> <br>hFileDirInfo = CreateFile(szDirInfo,  <br>  GENERIC_READ | GENERIC_WRITE,  <br>  0,  <br>  0,  <br>  CREATE_ALWAYS,  <br>  FILE_ATTRIBUTE_HIDDEN,  <br>  0); <br> <br>if (hFileDirInfo == INVALID_HANDLE_VALUE) { <br>MessageBox(hWnd, TEXT("EncryptDir: CreateFile failed."), NULL, MB_OK); <br>return FALSE; <br> <br>} <br> <br>// Encrypt the directory name with fnKey. <br> <br>if (RCRYPT_FAILED(CryptEncrypt(hfnKey,  <br>  0,  <br>  TRUE,  <br>  0,  <br>  (LPBYTE)szEncryptedDirName,  <br>  &amp;dwDataLen,  <br>  HEADER_SIZE * sizeof(*szEncryptedDirName)))) { <br>MessageBox(hWnd, TEXT("EncryptDir: CryptEncrypt failed."), NULL, MB_OK); <br>CloseHandle(hFileDirInfo); <br>return FALSE; <br>} <br> <br>// Write the original directory's encrypted name to disk. <br> <br>if (!WriteFile(hFileDirInfo,  <br>   szEncryptedDirName,  <br>   HEADER_SIZE * sizeof(*szEncryptedDirName),  <br>   &amp;dwNumBytesWritten,  <br>   0)) { <br>MessageBox(hWnd, TEXT("EncryptDir: WriteFile failed."), NULL, MB_OK); <br>CloseHandle(hFileDirInfo); <br>return FALSE; <br>} <br> <br>CloseHandle(hFileDirInfo); <br> <br>SeparatePathName2(szDirName, szDir, szFile); <br> <br>lstrcpy(szDirName, szDir); <br>lstrcat(szDirName, TEXT("\\")); <br>lstrcat(szDirName, szFile); <br>lstrcpy(szOldDir, szDirName); <br>lstrcat(szDirName, TEXT("\\*")); <br> <br>if ((hFindFile = FindFirstFile(szDirName, &amp;FindFileData))  <br>== INVALID_HANDLE_VALUE) { <br>MessageBox(hWnd, TEXT("EncryptDir: FindFirstFile failed."), NULL, MB_OK); <br>return FALSE; <br>} <br> <br>// Loop through, calling FindNextFiles until no more files are left. <br> <br>do { <br> <br>lstrcpy(szFileName, szDir); <br>lstrcat(szFileName, TEXT("\\")); <br>lstrcat(szFileName, szFile); <br>lstrcat(szFileName, TEXT("\\")); <br>lstrcat(szFileName, FindFileData.cFileName); <br> <br>// is szFileName encrypted and not .., ., or dirinfo? <br>if (!IsEncrypted(szFileName) <br>   &amp;&amp; lstrcmp(FindFileData.cFileName, TEXT(".")) <br>   &amp;&amp; lstrcmp(FindFileData.cFileName, TEXT("..")) <br>   &amp;&amp; lstrcmp(FindFileData.cFileName, TEXT("dirinfo"))) { <br>// Is szFileName a directory? <br>if (CFilerIsDirectory(szFileName)) { <br>// Encrypt the directory szFileName. <br>if (!EncryptDir(hWnd, szFileName, lpCInfo)) { <br>MessageBox(hWnd, TEXT("EncryptDir: EncryptDir failed."), NULL, MB_OK); <br>return FALSE; <br>} <br>} <br>// encrypt the file szFileName. <br>else if (!CFILEREncryptFile(hWnd, szFileName)) { <br>MessageBox(hWnd, TEXT("EncryptDir: CFILEREncryptFile failed."), NULL, MB_OK); <br>return FALSE; <br>} <br>} <br> <br>fNextFile = FindNextFile(hFindFile, &amp;FindFileData); <br> <br>dwLastError = GetLastError(); <br> <br>} while (fNextFile || dwLastError != ERROR_NO_MORE_FILES); <br> <br>FindClose(hFindFile); <br> <br>lpszDirName2 = szDirName2; <br> <br>// Collapse the selected directory. <br> <br>lIndex = GetLBText(lpCInfo-&gt;hDirLB, Buf); <br>lCount = GetDirDepth(Buf, &amp;lpszDirName2); <br>CollapseDir(lpCInfo, lIndex, lCount); <br> <br>// rename the directory with a random name. <br>#ifdef UNICODE <br>if (_wrename((const wchar_t *)szOldDir, (const wchar_t *)szRandomName)) { <br>#else <br>if (rename(szOldDir, szRandomName)) { <br>#endif <br>MessageBox(hWnd, TEXT("Another process is using this directory."), NULL, MB_OK); <br>return FALSE; <br>} <br> <br>// hide the directory. <br> <br>SetFileAttributes(szRandomName, FILE_ATTRIBUTE_HIDDEN); <br> <br>return TRUE; <br>} <br> <br>/************************************************************************\ <br>* GenRandomName() <br>* <br>* out parameters <br>* szRandomName - buffer to receive random filename <br>* <br>* purpose: <br>* Uses the random number generator to generate a random filename with <br>* a .CRP extension. <br>* <br>* returns <br>* TRUE if successful <br>* FALSE if unsuccessful <br>\************************************************************************/ <br> <br>BOOL GenRandomName(LPTSTR szRandomName) { <br>INT i; <br> <br>if (!szRandomName) { <br>ErrorMsg(TEXT("GenRandomName: szRandomName is NULL.")); <br>return FALSE; <br>} <br> <br>for (i = 0; i &lt; RANDOM_NAME_LENGTH; i++) <br>szRandomName[i] = rand() % 26 + TEXT('a'); <br>szRandomName[i] = TEXT('\0'); <br> <br>lstrcat(szRandomName, TEXT(".CRP\0")); <br> <br>return TRUE; <br>} <br> <br>/************************************************************************\ <br>* GenRandomName2() <br>* <br>* out parameters <br>* szRandomName - buffer to receive random filename <br>* <br>* purpose: <br>* Uses the random number generator to generate a random filename without <br>* a .CRP extension. <br>* <br>* returns <br>* TRUE if successful <br>* FALSE if unsuccessful <br>\************************************************************************/ <br> <br>BOOL GenRandomName2(LPTSTR szRandomName) { <br>INT i; <br> <br>if (!szRandomName) { <br>ErrorMsg(TEXT("GenRandomName: szRandomName is NULL.")); <br>return FALSE; <br>} <br> <br>for (i = 0; i &lt; RANDOM_NAME_LENGTH; i++) <br>szRandomName[i] = rand() % 26 + TEXT('a'); <br>szRandomName[i] = TEXT('\0'); <br> <br>return TRUE; <br>} <br> <br>/************************************************************************\ <br>* GetSigFileName() <br>* <br>* input <br>* in parameters: <br>* szFileName - full path of filename <br>* out parameters: <br>* szOutName - buffer containing name of signature file. <br>* <br>* purpose: <br>* obtains the name of the signature file that corresponds to szFileName. <br>* by hashing it and converting it to ascii. <br>* <br>* returns <br>* TRUE if successful <br>* FALSE if unsuccessful <br>\************************************************************************/ <br> <br>BOOL GetSigFileName(LPTSTR szFileName, LPTSTR szOutName) { <br>HCRYPTHASH hHash; <br>BYTE pbHash[BUF_SIZE]; <br>DWORD dwHashLen; <br>TCHAR szFileBuf[PATH_SIZE]; <br>TCHAR szSigDir[PATH_SIZE]; <br> <br>if (!szFileName) { <br>ErrorMsg(TEXT("GetSigFileName: szFileName is NULL.")); <br>return FALSE; <br>} <br> <br>if (!szOutName) { <br>ErrorMsg(TEXT("GetSigFileName: szOutName is NULL.")); <br>return FALSE; <br>} <br> <br> GetSigDir(szSigDir); <br> <br>// Hash szFileName. <br> <br>if (RCRYPT_FAILED(CryptCreateHash(hMe, CALG_SHA, 0, 0, &amp;hHash))) { <br>ErrorMsg(TEXT("GetSigFileName: CryptCreateHash failed.")); <br>return FALSE; <br>} <br> <br>if (RCRYPT_FAILED(CryptHashData(hHash, (LPBYTE)szFileName, lstrlen(szFileName) * sizeof(*szFileName), 0))) { <br>ErrorMsg(TEXT("GetSigFileName: CryptHashData failed.")); <br>return FALSE; <br>} <br> <br>dwHashLen = SHA_SIZE; <br> <br>if (RCRYPT_FAILED(CryptGetHashParam(hHash, HP_HASHVAL, pbHash, &amp;dwHashLen, 0))) { <br>ErrorMsg(TEXT("GetSigFileName: CryptFinishHash failed.")); </code></pre>
<p>
</p>
<pre><code>return FALSE; <br>} <br> <br>// Convert the hash to ascii <br> <br>if (!SHAtoRadix64(pbHash, szFileBuf)) { <br>ErrorMsg(TEXT("DrvWndProc: FILLFILE: SHAtoRadix64 failed.")); <br>return 0; <br>} <br> <br>lstrcpy(szOutName, szSigDir); <br>lstrcat(szOutName, TEXT("\\")); <br>lstrcat(szOutName, szFileBuf); <br> <br>CryptDestroyHash(hHash); <br>} <br> <br>/************************************************************************\ <br>* HasSignature() <br>* <br>* in parameters <br>* szFileName - full path of filename in question <br>* sigtable - pointer to a string table with displayed fields containing <br>* the filenames of all the files in the \sig directory, which is located <br>* on the same drive as the system directory. <br>* <br>* out parameters <br>* bHasSignature - flag specifying whether szFileName has a signature <br>* <br>* purpose: <br>* determines whether \sig\szFileName has a signature by calling <br>* GetSigFileName. <br>* <br>* returns <br>* TRUE if such a file exists <br>* FALSE otherwise or if unsuccessful <br>\************************************************************************/ <br> <br>BOOL HasSignature(LPTSTR szFileName, TABLE sigtable, BOOL *bHasSignature) { <br>TCHAR szFileName2[PATH_SIZE]; <br> <br>if (!szFileName) { <br>ErrorMsg(TEXT("HasSignature: szFileName is NULL.")); <br>return FALSE; <br>} <br> <br>if (!bHasSignature) { <br>ErrorMsg(TEXT("HasSignature: bHasSignature is NULL.")); <br>return FALSE; <br>} <br> <br>if (!GetSigFileName(szFileName, szFileName2)) { <br>ErrorMsg(TEXT("HasSignature: GetSigFileName failed.")); <br>return FALSE; <br>} <br> <br>// Does this file exist? <br> <br>if (TableFind(sigtable, szFileName2)) <br>*bHasSignature = TRUE; <br>else <br>*bHasSignature = FALSE; <br>} <br> <br>/************************************************************************\ <br>* GetDecryptedFileName() <br>* <br>* in parameters <br>* hWnd - HWND specified by caller <br>* szFileName - full path of file <br>*  <br>* out parameters <br>* szDecryptedFileName - buffer to hold full decrypted path <br>* hFileRead - pointer to file handle <br>* <br>* purpose: <br>* reads HEADER_SIZE bytes from szFileName, decrypts it with fnKey, and <br>* stores the result on szDecryptedFileName, the decrypted file name. <br>* <br>* returns: <br>* TRUE if successful <br>* FALSE if unsuccessful <br>\************************************************************************/ <br> <br>BOOL GetDecryptedFileName(HWND hWnd,  <br>  LPTSTR szFileName,  <br>  LPTSTR szDecryptedFileName,  <br>  HANDLE *hFileRead) { <br>DWORD dwDataLen = HEADER_SIZE * sizeof(TCHAR); <br>DWORD dwNumBytesRead; <br>TCHAR szDir[PATH_SIZE]; <br>HCRYPTKEY hfnKey; <br> <br>if (!szFileName) { <br>MessageBox(hWnd, TEXT("GetDecryptedFileName: szFileName is NULL."), NULL, MB_OK); <br>return FALSE; <br>} <br> <br>if (!szDecryptedFileName) { <br>MessageBox(hWnd, TEXT("GetDecryptedFileName: szDecryptedFileName is NULL."), NULL, MB_OK); <br>return FALSE; <br>} <br> <br>hfnKey = GetfnKey(hWnd); <br> <br>if (!hfnKey) { <br>MessageBox(hWnd, TEXT("GetDecryptedFileName: GetfnKey failed."), NULL, MB_OK); <br>return FALSE; <br>} <br> <br>// Open encrypted file. <br> <br>*hFileRead = CreateFile(szFileName,  <br>   GENERIC_READ,  <br>   0,  <br>   0,  <br>   OPEN_EXISTING,  <br>   GetFileAttributes(szFileName), <br>   0); <br> <br>if (*hFileRead == INVALID_HANDLE_VALUE) { <br>MessageBox(hWnd, TEXT("GetDecryptedFileName: CreateFile failed."), NULL, MB_OK); <br>return FALSE; <br>} <br> <br>// Read the encrypted filename from the disk. <br> <br>if (!ReadFile(*hFileRead,  <br>   szDecryptedFileName,  <br>   HEADER_SIZE * sizeof(*szDecryptedFileName),  <br>   &amp;dwNumBytesRead,  <br>   0)) <br>return FALSE; <br> <br>if (dwNumBytesRead != HEADER_SIZE * sizeof(*szDecryptedFileName)) { <br>SeparatePathName2(szFileName, szDir, szDecryptedFileName); <br>return FALSE; <br>} <br> <br>// Decrypt the filename. <br> <br>CryptDecrypt(hfnKey, 0, TRUE, 0, (LPBYTE)szDecryptedFileName, &amp;dwDataLen); <br> <br>return TRUE; <br>} <br> <br>/************************************************************************\ <br>* GetDecryptedDirName() <br>* <br>* in parameters <br>* hWnd - HWND specified by caller <br>* szDirectoryName - full path of directory <br>* bDeldirinfo - flag: TRUE means caller wants dirinfo to be deleted <br>* <br>* out parameters <br>* szDecryptedDirName - buffer to hold full decrypted pathname of <br>* szDirName <br>* hFileRead - pointer to file handle <br>* <br>* purpose: <br>* reads HEADER_SIZE bytes from file dirinfo in directory szDirectoryName, <br>* decrypts it with fnKey, and stores the result in szDecryptedDirName, <br>* a buffer to hold the decrypted directory name. <br>* <br>* returns <br>* TRUE if successful <br>* FALSE if unsuccessful <br>\************************************************************************/ <br> <br>BOOL GetDecryptedDirName(HWND hWnd,  <br>   LPTSTR szDirectoryName,  <br>   LPTSTR szDecryptedDirName,  <br>   BOOL bDeldirinfo, <br>   HANDLE *hFileRead) { <br>DWORD dwDataLen = HEADER_SIZE * sizeof(TCHAR); <br>DWORD dwNumBytesRead; <br>TCHAR szDir[PATH_SIZE]; <br>TCHAR szBuf[PATH_SIZE]; <br>HCRYPTKEY hfnKey; <br> <br>hfnKey = GetfnKey(hWnd); <br> <br>if (!hfnKey) { <br>MessageBox(hWnd, TEXT("GetDecryptedFileName: GetfnKey failed."), NULL, MB_OK); <br>return FALSE; <br>} <br> <br>if (!szDirectoryName) { <br>MessageBox(hWnd, TEXT("GetDecryptedDirName: szDirectoryName is NULL."), NULL, MB_OK); <br>return FALSE; <br>} <br> <br>if (!szDecryptedDirName) { <br>MessageBox(hWnd, TEXT("GetDecryptedDirNAme: szDecryptedDirName is NULL."), NULL, MB_OK); <br>return FALSE; <br>} <br> <br>lstrcpy(szDir, szDirectoryName); <br> <br>if (szDir[lstrlen(szDir) - 1] != TEXT('\\')) <br>lstrcat(szDir, TEXT("\\")); <br> <br>lstrcat(szDir, TEXT("dirinfo")); <br> <br>// open dirinfo in szDirectoryName. <br> <br>*hFileRead = CreateFile(szDir, <br>   GENERIC_READ, <br>   0, <br>   0, <br>   OPEN_EXISTING, <br>   GetFileAttributes(szDir), <br>   0); <br> <br>if (*hFileRead == INVALID_HANDLE_VALUE) <br>return FALSE; <br> <br>// Read the encrypted filename from the disk. <br> <br>if (!ReadFile(*hFileRead, <br>   szDecryptedDirName, <br>   HEADER_SIZE * sizeof(*szDecryptedDirName), <br>   &amp;dwNumBytesRead, <br>   0)) <br>return FALSE; <br> <br>CloseHandle(*hFileRead); <br> <br>// Decrypt the directoryname. <br> <br>CryptDecrypt(hfnKey, 0, TRUE, 0, (LPBYTE)szDecryptedDirName, &amp;dwDataLen); <br> <br>// enclose the directory name with brackets. <br> <br>lstrcpy(szBuf, TEXT("[")); <br>lstrcat(szBuf, szDecryptedDirName); <br>lstrcat(szBuf, TEXT("]")); <br>lstrcpy(szDecryptedDirName, szBuf); <br> <br>if (bDeldirinfo) <br>DeleteFile(szDir); <br> <br>return TRUE; <br>} <br> <br>/************************************************************************\ <br>* DecryptDir() <br>* <br>* in parameters <br>* hWnd - HWND specified by caller <br>* szDirName - Full path of directory to be decrypted <br>* lpCInfo - instance data for drive child <br>* <br>* purpose: <br>* recursively decrypts szDirName and all of its subdirectories. <br>* <br>* returns <br>* TRUE if successful <br>* FALSE if unsuccessful <br>\************************************************************************/ <br> <br>BOOL DecryptDir(HWND hWnd, LPTSTR szDirName, LPCINFO lpCInfo) { <br>INT i, j; <br>TCHAR szDir[PATH_SIZE]; <br>TCHAR szDir2[PATH_SIZE]; <br>TCHAR szFile[PATH_SIZE]; <br>TCHAR szBuf2[PATH_SIZE]; <br>TCHAR Buf[PATH_SIZE]; <br>TCHAR szDecryptedDirName[PATH_SIZE]; <br>TCHAR szFileName[PATH_SIZE]; <br>TCHAR szDirName2[PATH_SIZE]; <br>LPTSTR lpszDirName2; <br>HANDLE hFileRead; <br>HANDLE hFindFile; <br>WIN32_FIND_DATA FindFileData; <br>BOOL fNextFile; <br>DWORD dwLastError; <br>LONG lIndex, lCount; <br> <br>if (!szDirName) { <br>MessageBox(hWnd, TEXT("DecryptDir: szDirName is NULL."), NULL, MB_OK); <br>return FALSE; <br>} <br> <br>if (!lpCInfo) { <br>MessageBox(hWnd, TEXT("DecryptDir: lpCInfo is NULL."), NULL, MB_OK); <br>return FALSE; <br>} <br> <br>GetDecryptedDirName(hWnd, szDirName, szDecryptedDirName, 1, &amp;hFileRead); <br> <br>// strip the brackets off szDecryptedDirName. <br> <br>if (szDecryptedDirName[0] == TEXT('[')) { <br>for (i = 1, j = 0; szDecryptedDirName[i]  <br>&amp;&amp; szDecryptedDirName[i] != TEXT(']'); i++, j++) <br>szBuf2[j] = szDecryptedDirName[i]; <br>szBuf2[j] = TEXT('\0'); <br>lstrcpy(szDecryptedDirName, szBuf2); <br>} <br> <br>CloseHandle(hFileRead); <br> <br>lpszDirName2 = szDirName2; <br> <br>// Collapse the selected directory in the directory listbox. <br> <br>lIndex = GetLBText(lpCInfo-&gt;hDirLB, Buf); <br>lCount = GetDirDepth(Buf, &amp;lpszDirName2); <br>CollapseDir(lpCInfo, lIndex, lCount); <br> <br>SeparatePathName2(szDirName, szDir, szFile); <br> <br>// unhide the directory. <br> <br>lstrcat(szDir, TEXT("\\")); <br>lstrcat(szDir, szDecryptedDirName); <br>SetFileAttributes(szDirName, GetFileAttributes(szDirName) ^ FILE_ATTRIBUTE_HIDDEN); <br> <br>// rename the directory to its original name. <br> <br>#ifdef UNICODE <br>if (_wrename((const wchar_t *)szDirName, (const wchar_t *)szDir)) { <br>#else <br>if (rename(szDirName, szDir)) { <br>#endif <br>MessageBox(hWnd, TEXT("Another process is using this directory."), NULL, MB_OK); <br>return FALSE; <br>} <br> <br>lstrcpy(szDir2, szDir); <br>lstrcat(szDir2, TEXT("\\*")); <br> <br>if ((hFindFile = FindFirstFile(szDir2, &amp;FindFileData)) == INVALID_HANDLE_VALUE) { <br>MessageBox(hWnd, TEXT("DecryptDir: FindFirstFile failed."), NULL, MB_OK); <br>return FALSE; <br>} <br> <br>// decrypt all the files in the directory, recursing on directories <br> <br>do { <br>lstrcpy(szFileName, szDir); <br>lstrcat(szFileName, TEXT("\\")); <br>lstrcat(szFileName, FindFileData.cFileName); <br> <br>// is szFileName encrypted? <br>if (IsEncrypted(szFileName) <br>   &amp;&amp; lstrcmp(FindFileData.cFileName, TEXT(".")) <br>   &amp;&amp; lstrcmp(FindFileData.cFileName, TEXT(".."))) { <br>// is szFileName a directory? <br>if (CFilerIsDirectory(szFileName)) { <br>// Decrypt the directory szFileName. <br>if (!DecryptDir(hWnd, szFileName, lpCInfo)) { <br>MessageBox(hWnd, TEXT("DecryptDir: DecryptDir failed."), NULL, MB_OK); <br>return FALSE; <br>} <br>} <br>// decrypt the file szFileName. <br>else if (!CFILERDecryptFile(hWnd, szFileName)) { <br>MessageBox(hWnd, TEXT("DecryptDir: CFILERDecryptFile failed."), NULL, MB_OK); <br>return FALSE; <br>} <br>} <br> <br>fNextFile = FindNextFile(hFindFile, &amp;FindFileData); <br> <br>dwLastError = GetLastError(); <br> <br>} while (fNextFile || dwLastError != ERROR_NO_MORE_FILES); <br> <br>FindClose(hFindFile); <br> <br>return TRUE; <br>} <br> <br>/************************************************************************\ <br>* GetSigDir() <br>* <br>* in parameters <br>* szSigDir - buffer to hold result <br>* <br>* purpose:  <br>* stores in buffer szSigDir the name of the directory containing <br>* the signatures <br>* <br>* returns <br>* TRUE if successful <br>* FALSE if unsuccessful <br>\************************************************************************/ <br> <br>BOOL GetSigDir(LPTSTR szSigDir) <br>{ <br>TCHAR szSystemDirectory[PATH_SIZE]; <br> <br>if (!szSigDir) { <br>ErrorMsg(TEXT("GetSigDir: szSigDir is NULL.")); <br>return FALSE; <br>} <br> <br>// [system directory drive]:\sig -&gt; szSigDir <br> <br>GetSystemDirectory(szSystemDirectory, PATH_SIZE * sizeof(*szSystemDirectory)); <br>szSigDir[0] = szSystemDirectory[0]; <br>szSigDir[1] = TEXT('\0'); <br>lstrcat(szSigDir, TEXT(":\\sig")); <br> <br>return TRUE; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
