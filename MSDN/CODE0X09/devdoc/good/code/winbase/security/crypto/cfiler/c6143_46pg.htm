<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>FILLFILE.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6154"></a>FILLFILE.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples.  <br>*       Copyright 1996 - 1998 Microsoft Corporation. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>// FILLFILE.C <br> <br>#include "cfiler.h" <br> <br>extern HANDLE   ghDrvThread; <br>extern HWND   ghwndDrv; <br> <br>/********************************************************************************\ <br>* FillFile() <br>* <br>* in parameters <br>* lpCInfo - instance data for drive child <br>* hwnd - HWND specified by caller <br>* <br>* purpose: <br>* Fills the file listbox with strings constructed from the contents of the  <br>* directory that is highlighted in the directory listbox. <br>* This is accomplished by building a file string table with hidden and displayed <br>* string pairs. The hidden strings are the full pathnames as they exist on the <br>* disk. The displayed strings are specially formatted strings containing file <br>* and directory names to be displayed in the owner-draw listbox. The listbox <br>* knows how to appropriately draw these file and directory names because the <br>* strings have some special characters at the beginning. Once the string table <br>* has been constructed, a function called TableSend is called, which generates <br>* LB_ADDSTRING messages to the listbox, one for each displayed string in the <br>* table. <br>* <br>* returns: <br>* TRUE if successful <br>* FALSE if unsuccessful <br>\********************************************************************************/ <br> <br>BOOL FillFile(LPCINFO lpCInfo, HWND hwnd) { <br>BOOLbHasSignature = FALSE; <br>    BOOLfNextFile = TRUE; <br>BOOLfSearchFlag = TRUE; <br>DWORDdwLastError = ERROR_SUCCESS; <br>HANDLEhFindFile; <br>HANDLEhFileRead; <br>INTi; <br>TCHARszDecryptedName[PATH_SIZE]; <br>TCHARszFileName[PATH_SIZE]; <br>TCHARszFind[PATH_SIZE]; <br>TCHAR               szFiles[PATH_SIZE]; <br>TCHARszBuf[PATH_SIZE]; <br>WIN32_FIND_DATAFindFileData; <br>LONGlIndex; <br>TABLEsigtable; <br> <br>    if (!lpCInfo) { <br>    ErrorMsg(TEXT("FillFile: lpCInfo is NULL.")); <br>    return FALSE; <br>    } <br>     <br>    if( WaitForSingleObject(lpCInfo-&gt;hFileMutex, MUTEX_TIMEOUT)  <br>                == WAIT_TIMEOUT) { <br>    ErrorMsg(TEXT("FillFile: File LB Mutex Timeout.")); <br>    return 0; <br>    } <br>      <br>TableFree(lpCInfo-&gt;FileTable); <br> <br>lpCInfo-&gt;FileTable = TableNew(); <br>        <br>if (!lpCInfo-&gt;FileTable) { <br>ErrorMsg(TEXT("MM_FILLFILE: TableNew failed.")); <br>return 0; <br>} <br>                    <br>SendMessage(lpCInfo-&gt;hFileLB, LB_RESETCONTENT, (WPARAM)NULL, (LPARAM)NULL); <br> <br>    // Put the full pathname of the directory into szFind <br>    // by accessing the directory string table. <br>                 <br>    lIndex = SendMessage( lpCInfo-&gt;hDirLB, LB_GETCARETINDEX, <br>              (WPARAM)NULL, (LPARAM)NULL ); <br>                           <br>if (!TableGetHidden(lpCInfo-&gt;DirTable, lIndex, szFind)) { <br>ErrorMsg(TEXT("FillFile: TableGetHidden failed.")); <br>return 0; <br>} <br>            <br>// if szFind has a '\' append a * otherwise append '\*' <br> <br>if (szFind[lstrlen(szFind) - 1] == TEXT('\\'))  <br>szFind[lstrlen(szFind) - 1] = TEXT('\0'); <br>   <br>lstrcpy(szFiles, szFind); <br> <br>lstrcat(szFind, TEXT("\\*")); <br> <br>if ((hFindFile = FindFirstFile(szFind, &amp;FindFileData))  <br>== INVALID_HANDLE_VALUE) { <br>ReleaseMutex(lpCInfo-&gt;hFileMutex); <br>ErrorMsg(TEXT("FillFile: FindFirstFile failed.")); <br>ReleaseMutex(lpCInfo-&gt;hFileMutex); <br>return 0; <br>} <br> <br>sigtable = TableNew(); <br> <br>if (!sigtable) { <br>ErrorMsg(TEXT("FillFile: TableNew failed.")); <br>return 0; <br>} <br> <br>BuildSigTable(sigtable); <br> <br>// Loop through, calling FindNextFiles until no more files are left. <br> <br>for (i = 0; fNextFile || dwLastError != ERROR_NO_MORE_FILES; i++) { <br>lstrcpy(szFileName, szFiles); <br>lstrcat(szFileName, TEXT("\\")); <br>lstrcat(szFileName, FindFileData.cFileName); <br>bHasSignature = FALSE; <br> <br>// If szFileName is not a directory, check if it has a signature. <br> <br>if (!CFilerIsDirectory(szFileName)) <br>HasSignature(szFileName, sigtable, &amp;bHasSignature); <br> <br>if (IsEncrypted(szFileName)) { <br>BOOL fIsValidEncryptedFile = TRUE; <br> <br>if (!CFilerIsDirectory(szFileName)) { <br>if (!GetDecryptedFileName(hwnd, szFileName, szDecryptedName, &amp;hFileRead)) { <br>fIsValidEncryptedFile = FALSE; <br>lstrcpy(szBuf, TEXT("\0")); <br>} <br>CloseHandle(hFileRead); <br>} <br>else <br>GetDecryptedDirName(hwnd, szFileName, szDecryptedName, 0, &amp;hFileRead); <br> <br>if (fIsValidEncryptedFile) { <br>if (!bHasSignature)  <br>// '|' indicates to the the owner-draw listbox <br>// an encrypted file or directory <br>// This is not unwholesome since '|' is not a legal <br>// character for a file or directory identifier. <br>lstrcpy(szBuf, TEXT("|"));  <br>else if (bHasSignature)  <br>// '&gt;' indicates an encrypted file that has been signed. <br>// This is not unwholesome since '&gt;' is not a legal character <br>// for a file or directory identifier. <br>lstrcpy(szBuf, TEXT("&gt;"));  <br>} <br> <br>lstrcat(szBuf, szDecryptedName); <br> <br>// add to string table. <br> <br>if (IsLegalToAdd(FindFileData.cFileName)) { <br> if (!TableAdd(lpCInfo-&gt;FileTable, FindFileData.cFileName, szBuf)) { <br>ErrorMsg(TEXT("FillFile: TableAdd failed.")); <br>return FALSE; <br>} <br>} <br>} <br>else { <br>// Not encrypted <br> <br>if (CFilerIsDirectory(szFileName)) { <br> <br>// For directories, enclose the directory name with brackets  <br>// before inserting into string table. <br> <br>lstrcpy(szBuf, TEXT("[")); <br>lstrcat(szBuf, FindFileData.cFileName); <br>lstrcat(szBuf, TEXT("]")); <br> <br>// Add directory name to string table. <br> <br>if (IsLegalToAdd(FindFileData.cFileName)) { <br>if (!TableAdd(lpCInfo-&gt;FileTable, szBuf, szBuf)) { <br>ErrorMsg(TEXT("FillFile: TableAdd failed.")); <br>return FALSE; <br>} <br>} <br>} <br>else if (!CFilerIsDirectory(szFileName)) { <br> <br>// Not a directory and not encrypted <br> <br>if (!bHasSignature) <br>lstrcpy(szBuf, FindFileData.cFileName); <br>else if (bHasSignature) { <br>// ';' indicates a signed file. This is <br>// not unwholesome since ';' is not a legal <br>// character for a filename. <br>lstrcpy(szBuf, TEXT(";")); <br>lstrcat(szBuf, FindFileData.cFileName); <br>} <br>// Add filename to string table. <br> <br>if (IsLegalToAdd(FindFileData.cFileName)) { <br> if (!TableAdd(lpCInfo-&gt;FileTable, FindFileData.cFileName, szBuf)) { <br>ErrorMsg(TEXT("FillFile: TableAdd failed.")); <br>return FALSE; <br>} <br>} <br>} <br>} <br> <br>fNextFile = FindNextFile(hFindFile, &amp;FindFileData); <br> <br>dwLastError = GetLastError(); <br>} <br> <br>// sort the file string table on its displayed members <br>// using the same string compare routine <br>// that the owner-draw listbox uses. <br> <br>if (!TableSort(lpCInfo-&gt;FileTable, CFilerlstrcmp)) { <br>ErrorMsg(TEXT("FillFile: selection failed.")); <br>return 0; <br>} <br> <br>// send all of the displayed members of the file string table <br>// to the owner-draw listbox. <br>// It does not matter in what order they are sent since the <br>// owner-draw listbox will sort them anyway. <br> <br>if (GetSize(lpCInfo-&gt;FileTable) &amp;&amp; !TableSend(lpCInfo-&gt;FileTable, lpCInfo-&gt;hFileLB)) { <br>ErrorMsg(TEXT("FillFile: TableSend failed.")); <br>return 0; <br>} <br> <br>// <br>//  Set selection to first file. <br>// <br>if (GetSize(lpCInfo-&gt;FileTable)) { <br>if(SendMessage(lpCInfo-&gt;hFileLB, LB_SETSEL, (WPARAM)TRUE, (LPARAM)0) == LB_ERR) { <br>ErrorMsg(TEXT("FillFile:  Listbox selection failure.")); <br>ReleaseMutex( lpCInfo-&gt;hFileMutex ); <br>return 0; <br>} <br>} <br> <br>if (!SetWindowText(lpCInfo-&gt;hTextWnd, lpCInfo-&gt;CaptionBarText)) { <br>ErrorMsg(TEXT("FillFile: SetWindowText failed.")); <br>return FALSE; <br>} <br> <br>TableFree(sigtable); <br> <br>ReleaseMutex( lpCInfo-&gt;hFileMutex ); <br> <br>FindClose(hFindFile); <br> <br>return TRUE; <br>} <br> <br>/************************************************************************\ <br>* BuildSigTable() <br>* <br>* input: <br>* sigtable - pointer to an empty string table <br>* <br>* purpose: <br>* Builds a string table with displayed fields containing <br>* the filenames of all the files in the \sig directory on the <br>* same drive as the system directory. <br>* <br>* returns <br>* TRUE if successful <br>* FALSE if unsuccessful <br>\************************************************************************/ <br> <br>BOOL BuildSigTable(TABLE sigtable) <br>{ <br>WIN32_FIND_DATA FindFileData; <br>HANDLE hFindFile; <br>TCHAR szFiles[PATH_SIZE]; <br>TCHAR szFileName[PATH_SIZE]; <br>TCHAR szSystemDirectory[PATH_SIZE]; <br>TCHAR szSigDir[PATH_SIZE]; <br> <br>// [system directory drive]:\sig -&gt; szSigDir <br> <br>GetSystemDirectory(szSystemDirectory, PATH_SIZE * sizeof(*szSystemDirectory)); <br>szSigDir[0] = szSystemDirectory[0]; <br>szSigDir[1] = TEXT('\0'); <br>lstrcat(szSigDir, TEXT(":\\sig")); <br>lstrcpy(szFiles, szSigDir); <br>lstrcat(szFiles, TEXT("\\*")); <br> <br>hFindFile = FindFirstFile(szFiles, &amp;FindFileData); <br> <br>if (hFindFile == INVALID_HANDLE_VALUE) { <br>return FALSE; <br>} <br> <br>// insert all the signature filenames into the table sigtable. <br> <br>do { <br>lstrcpy(szFileName, szSigDir); <br>lstrcat(szFileName, TEXT("\\")); <br>lstrcat(szFileName, FindFileData.cFileName); <br> <br>TableInsert(sigtable, TEXT("NULL"), szFileName, 0); <br>} while (FindNextFile(hFindFile, &amp;FindFileData)  <br>|| GetLastError() != ERROR_NO_MORE_FILES); <br> <br>FindClose(hFindFile); <br>} <br> <br>/*************************************************************************************\ <br>* GetLBText() <br>* <br>* Gets the text of the currently selected (careted) item in the given <br>*   listbox. <br>* <br>* Returns:  Index of selected item if successful, -1 on failure <br>\*************************************************************************************/ <br> <br>LONG GetLBText(HWND hActiveLB, PTCHAR szItemBuff) <br>{ <br>    LONG    lIndex; <br> <br>    // <br>    // Retrieve selected (careted) item. <br>    // <br>    lIndex = SendMessage( hActiveLB, LB_GETCARETINDEX, <br>                          (WPARAM)NULL, (LPARAM)NULL ); <br> <br>    if( SendMessage( hActiveLB, LB_GETTEXT, (WPARAM)lIndex, <br>                     (LPARAM)szItemBuff) == LB_ERR ){ <br>        ErrorMsg(TEXT("LBN_DBLCLK: Text retrieval failure.")); <br>        return(-1); <br>    } <br> <br>    return( lIndex ); <br>} <br> <br>/*************************************************************************************\ <br>* UpdateFileLB() <br>* <br>* Updates the file listbox of the drive child given by sending an MM_FILLFILE <br>*   message to it. <br>* <br>*  input:   hwnd    -   Handle of drive child to update file listbox of. <br>\*************************************************************************************/ <br> <br>VOID UpdateFileLB(HWND hwnd) <br>{ <br>    LPCINFO lpCInfo; <br> <br>    lpCInfo = (LPCINFO)GetWindowLong(hwnd, GWL_USERDATA); <br> <br>SendMessage(hwnd, WM_COMMAND, (WPARAM)MM_FILLFILE, (LPARAM)0); <br>} <br> <br>/*************************************************************************************\ <br>* RunListBoxItem() <br>* <br>*  input:   lpCInfo   -   pointer to Drv child's LPCINFO structure <br>*  cmd  -   integer specifying what action to perform on <br>*  the file corresponding to the selected  <br>*  file listbox text. <br>* <br>* purpose: <br>* 1. Obtains the full pathname of the selected directory or file <br>* in the file listbox. <br>* 2. Depending on whether a directory or file has been selected and <br>* depending on cmd, the appropriate action is taken: <br>* - CFILEREncryptFile() <br>* - EncryptDir() <br>* - CFILERDecryptFile() <br>* - DecryptDir() <br>* - SignFile() <br>* - VerifyFile() <br>* <br>* Returns TRUE if successful, FALSE if unsuccessful. <br>* If a user tries to sign a directory, RunListBoxItem returns FALSE. <br>\*************************************************************************************/ <br> <br>BOOL RunListBoxItem(LPCINFO lpCInfo, int cmd) <br>{ <br>    LONGlIndex; <br>TCHARszBuf[PATH_SIZE]; <br>    TCHARszFileName[PATH_SIZE]; <br>TCHARszBuf2[PATH_SIZE]; <br> <br>    if (!lpCInfo) { <br>    ErrorMsg(TEXT("RunListBoxItem: lpCInfo is NULL.")); <br>    return FALSE; <br>    } <br>     <br>    // get index of selected item in Directory listbox. <br>     <br>    lIndex = SendMessage( lpCInfo-&gt;hDirLB, LB_GETCARETINDEX, <br>                          (WPARAM)NULL, (LPARAM)NULL ); <br>                           <br>// obtain full pathname of directory corresponding to selected text in <br>// directory listbox by accessing the string table for the directory listbox. <br> <br>if (!TableGetHidden(lpCInfo-&gt;DirTable, lIndex, szFileName)) { <br>ErrorMsg(TEXT("RunListBoxItem: TableGetHidden failed.")); <br>return FALSE; <br>} <br>    <br>   // append a '\\' to the end of the full pathname if one isn't already there. <br>    <br>   if (szFileName[lstrlen(szFileName) - 1] != TEXT('\\')) { <br>   if (!lstrcat(szFileName, TEXT("\\"))) { <br>ErrorMsg(TEXT("RunListBoxItem: lstrcat failed.")); <br>return FALSE; <br>} <br>  }   <br> <br>    // <br>    // Retrieve selected (careted) item. <br>    // <br> <br>    // get index of selected item in the file listbox. <br>     <br>    lIndex = GetLBText(lpCInfo-&gt;hFileLB, szBuf); <br> <br>    if (lIndex == LB_ERR) { <br>ErrorMsg(TEXT("RunListBoxItem: GetLBText failed.")); <br>        return FALSE; <br>} <br>     <br>    // get the full pathname of the file corresponding to the selected text <br>    // in the file listbox by accessing the string table for the  <br>    // file listbox. <br>         <br>   if (!TableGetHidden(lpCInfo-&gt;FileTable, lIndex, szBuf)) { <br>ErrorMsg(TEXT("RunListBoxItem: TableGetHidden failed.")); <br>return FALSE; <br>} <br> <br>if (WaitForSingleObject(ghDrvThread, INFINITE) == WAIT_FAILED) { <br>ErrorMsg(TEXT("RunListBoxItem: WaitForSingleObject failed.")); <br>return FALSE; <br>} <br> <br>if (lpCInfo-&gt;hDirThread  <br>&amp;&amp; WaitForSingleObject(lpCInfo-&gt;hDirThread, INFINITE) == WAIT_FAILED) { <br>ErrorMsg(TEXT("RunListBoxItem: WaitForSingleObject failed.")); <br>return FALSE; <br>} <br> <br>lstrcpy(szBuf2, szBuf); <br>SimplifyFileName(szBuf2, szBuf); <br>lstrcat(szFileName, szBuf); <br> <br>// if szFileName is not encrypted and the user wants to encrypt/decrypt <br>if (!IsEncrypted(szFileName) &amp;&amp; cmd == ENCRYPT_DECRYPT) { <br>// if szFileName is a directory <br>if (CFilerIsDirectory(szFileName)) { <br>// encrypt the directory <br>if (!EncryptDir(ghwndDrv, szFileName, lpCInfo)) { <br>ErrorMsg(TEXT("RunListBoxItem: EncryptDir failed.")); <br>return FALSE; <br>} <br>} <br>// not a directory <br>else { <br>// encrypt the file <br>if(!CFILEREncryptFile(ghwndDrv, szFileName)) { <br>ErrorMsg(TEXT("RunListBoxItem: CFILEREncryptFile failed.")); <br>return FALSE; <br>} <br>} <br>UpdateFileLB(ghwndDrv); <br>    } <br>else if (cmd == ENCRYPT_DECRYPT) { <br>// if szFileName is a directory <br>if (CFilerIsDirectory(szFileName)) { <br>// decrypt the directory. <br>if (!DecryptDir(ghwndDrv, szFileName, lpCInfo)) { <br>ErrorMsg(TEXT("RunListBoxItme: DecryptDir failed.")); <br>return FALSE; <br>} <br>} <br>else { <br>// not a directory <br>if (!CFILERDecryptFile(ghwndDrv, szFileName)) { <br> ErrorMsg(TEXT("RunListBoxItem: CFILERDecryptFile failed.")); <br> return FALSE; <br>} <br>} <br>UpdateFileLB(ghwndDrv); <br>} <br>else if (cmd == SIGN) { <br>// sign file if szFileName is not a directory <br>if (!CFilerIsDirectory(szFileName) &amp;&amp; !SignFile(ghwndDrv, szFileName)) { <br> ErrorMsg(TEXT("RunListBoxItem: SignFile failed.")); <br> return FALSE; <br>} <br>UpdateFileLB(ghwndDrv); <br>} <br>else if (cmd == VERIFY) { <br>// verify file is szFileName is not a directory. <br>if (!CFilerIsDirectory(szFileName) &amp;&amp; !VerifyFile(ghwndDrv, szFileName)) { <br> ErrorMsg(TEXT("RunListBoxItem: VerifyFile failed.")); <br> return FALSE; <br>} <br>UpdateFileLB(ghwndDrv); <br>} <br> <br>    return TRUE; <br>} <br> <br>/*************************************************************************************\ <br>* CFilerIsDirectory() <br>* <br>* input - szDirName: In Parameter: Buffer containing full pathname of directory <br>* <br>* Purpose: returns TRUE if szDiretory is a directory or a hidden directory, <br>* FALSE otherwise or if error.  <br>\*************************************************************************************/ <br> <br>BOOL CFilerIsDirectory(LPTSTR szDirName) { <br>DWORD dwFileAttributes; <br> <br>if (!szDirName) { <br>ErrorMsg(TEXT("CFilerIsDirectory: szDirName is NULL.")); <br>return FALSE; <br>} <br> <br>dwFileAttributes = GetFileAttributes(szDirName); <br> <br>if (dwFileAttributes == FILE_ATTRIBUTE_DIRECTORY) <br>return TRUE; <br> <br>if (dwFileAttributes == (FILE_ATTRIBUTE_DIRECTORY | FILE_ATTRIBUTE_HIDDEN)) <br>return TRUE; <br> <br>return FALSE; <br>} <br> <br>/*************************************************************************************\ <br>* SeparatePathName() <br>* <br>* First parameter (in parameter): szFileName - full path name to be separated <br>* <br>* Second parameter (out parameter): szDir - buffer to hold full pathname of directory <br>* <br>* Third parameter (out parameter): szFile - buffer to hold filename (not full pathname) <br>* <br>* Example: C:\directory\[foo] -&gt; C:\directory + [foo] <br>\*************************************************************************************/ <br> <br>BOOL SeparatePathName(LPTSTR szFileName, LPTSTR szDir, LPTSTR szFile) { <br>INTi, j, nLen, nFileOffset; <br> <br>if (!szFileName) { <br>ErrorMsg(TEXT("SeparatePathName: szFileName is NULL.")); <br>return FALSE; <br>} <br> <br>if (!szDir) { <br>ErrorMsg(TEXT("SeparatePathName: szDir is NULL.")); <br>return FALSE; <br>} <br> <br>if (!szFile) { <br>ErrorMsg(TEXT("SeparatePathName: szFile is NULL.")); <br>return FALSE; <br>} <br> <br>lstrcpy(szDir, TEXT("\0")); <br>lstrcpy(szFile, TEXT("\0")); <br> <br>nLen = lstrlen(szFileName); <br> <br>if (szFileName[nLen - 1] == TEXT('\\')) <br>for (i = nLen - 1; szFileName[i] != TEXT('\\') &amp;&amp; i; i--); <br>else <br>for (i = nLen; szFileName[i] != TEXT('\\') &amp;&amp; i; i--); <br> <br>nFileOffset = i + 1; <br>     <br>    for (i = 0; i &lt; nFileOffset - 1; i++) <br>    szDir[i] = szFileName[i]; <br>    szDir[i] = TEXT('\0'); <br>     <br>    for (j = 0, i++; i &lt; lstrlen(szFileName); i++, j++) <br>        szFile[j] = szFileName[i]; <br>    szFile[j] = TEXT('\0');   <br>     <br>return TRUE; <br>} <br> <br>/*************************************************************************************\ <br>* SeparatePathName2() <br>* <br>* First parameter (in parameter): szFileName - full path name to be separated <br>* <br>* Second parameter (out parameter): szDir - buffer to hold full pathname of directory <br>* <br>* Third parameter (out parameter): szFile - buffer to hold filename (not full pathname) <br>* <br>* brackets are stripped from the filename before the filename is inserted into szFile. <br>* <br>* C:\directory\[foo] -&gt; C:\directory + foo <br>\*************************************************************************************/ <br> <br>BOOL SeparatePathName2(LPTSTR szFileName, LPTSTR szDir, LPTSTR szFile) { <br>INTi, j, nLen, nFileOffset; <br> <br>if (!szFileName) { <br>ErrorMsg(TEXT("SeparatePathName2: szFileName is NULL.")); <br>return FALSE; <br>} <br> <br>if (!szDir) { <br>ErrorMsg(TEXT("SeparatePathName2: szDir is NULL.")); <br>return FALSE; <br>} <br> <br>if (!szFile) { <br>ErrorMsg(TEXT("SeparatePathName2: szFile is NULL.")); <br>return FALSE; <br>} <br> <br>lstrcpy(szDir, TEXT("\0")); <br>lstrcpy(szFile, TEXT("\0")); <br> <br>nLen = lstrlen(szFileName); <br> <br>if (szFileName[nLen - 1] == TEXT('\\')) <br>for (i = nLen - 1; szFileName[i] != TEXT('\\') &amp;&amp; i; i--); <br>else <br>for (i = nLen; szFileName[i] != TEXT('\\') &amp;&amp; i; i--); <br> <br>nFileOffset = i + 1; <br>     <br>    for (i = 0; i &lt; nFileOffset - 1; i++) <br>    szDir[i] = szFileName[i]; <br>    szDir[i] = TEXT('\0'); <br>     <br>    for (j = 0, i++; i &lt; lstrlen(szFileName); ) { <br>    if (szFileName[i] == TEXT('[') || szFileName[i] == TEXT(']')) <br>i++; <br>    else { <br>    szFile[j] = szFileName[i]; <br>    i++; <br>j++; <br>} <br>} <br> <br>    szFile[j] = TEXT('\0');   <br>     <br>return TRUE; <br>} <br> <br>/*************************************************************************************\ <br>* IsEncrypted() <br>*  <br>* input: <br>* <br>* szFileName - In parameter: buffer containing filename <br>* <br>* If szFileName has a .CRP extension, IsEncrypted() returns TRUE, FALSE otherwise <br>* or if failure. <br>\*************************************************************************************/ <br> <br>BOOL IsEncrypted(LPTSTR szFileName) { <br>INT nLen; <br> <br>if (!szFileName) { <br>ErrorMsg(TEXT("IsEncrypted: szFileName is NULL.")); <br>return FALSE; <br>} <br> <br>nLen = lstrlen(szFileName); <br> <br>if (szFileName[nLen - 4] == TEXT('.') &amp;&amp; <br>  szFileName[nLen - 3] == TEXT('C') &amp;&amp; <br>szFileName[nLen - 2] == TEXT('R') &amp;&amp; <br>szFileName[nLen - 1] == TEXT('P')) <br>return TRUE; <br> <br>return FALSE; <br>} <br> <br>/*************************************************************************************\ <br>* IsLegalToAdd() <br>* <br>* input <br>* in parameters <br>* szFileName - buffer containing filename (not full pathname) of file in question <br>* <br>* purpose <br>* determines whether szFileName is a file or directory that should be added to <br>* the file listbox string table. <br>* <br>* returns <br>* TRUE if szFileName is legal <br>* FALSE otherwise <br>\*************************************************************************************/ <br> <br>BOOL IsLegalToAdd(LPTSTR szFileName) <br>{ <br>if (lstrcmp(szFileName, TEXT("..")) <br> &amp;&amp; lstrcmp(szFileName, TEXT(".")) <br> &amp;&amp; lstrcmp(szFileName, TEXT("dirinfo"))) <br> return TRUE; <br> <br>return FALSE; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
