<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>VERIFILE.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6169"></a>VERIFILE.C</h2>
<pre><code>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples.  <br>*       Copyright 1996 - 1998 Microsoft Corporation. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;wincrypt.h&gt; <br> <br>static BOOL VerifyFile(PCHAR szSourceFile, PCHAR szSignatureFile, PCHAR szDescription); <br> <br>/*****************************************************************************/ <br>void _cdecl main(int argc, char *argv[]) <br>{ <br>    PCHAR szSourceFile  = NULL; <br>    PCHAR szSignatureFile = NULL; <br>    PCHAR szDescription  = NULL; <br> <br>    // Validate argument count. <br>    if(argc != 4) { <br>printf("USAGE: signfile &lt;source file&gt; &lt;signature file&gt; &lt;description&gt;\n"); <br>exit(1); <br>    } <br> <br>    // Parse arguments. <br>    szSourceFile    = argv[1]; <br>    szSignatureFile = argv[2]; <br>    szDescription   = argv[3]; <br> <br>    if(!VerifyFile(szSourceFile, szSignatureFile, szDescription)) { <br>printf("Error verifying file!\n"); <br>exit(1); <br>    } <br> <br>    exit(0); <br>} <br> <br>/*****************************************************************************/ <br>static BOOL VerifyFile(PCHAR szSourceFile, PCHAR szSignatureFile, PCHAR szDescription) <br>{ <br>    FILE *hSourceFile = NULL; <br>    FILE *hSignatureFile = NULL; <br>    INT eof = 0; <br> <br>    HCRYPTPROV hProv = 0; <br>    HCRYPTHASH hHash = 0; <br>    HCRYPTKEY hSigPublicKey = 0; <br> <br>    PBYTE pbSignature = NULL; <br>    DWORD dwSignatureLen; <br> <br>    PBYTE pbBuffer = NULL; <br>    DWORD dwBufferLen; <br>    DWORD dwCount; <br> <br>    // Get handle to the default provider. <br>    if(!CryptAcquireContext(&amp;hProv, NULL, NULL, PROV_RSA_FULL, 0)) { <br>        printf("Error %x during CryptAcquireContext!\n", GetLastError()); <br>goto error; <br>    } <br> <br>    // <br>    // Hash source file. <br>    // <br> <br>    // Determine number of bytes to hash at once. <br>    dwBufferLen = 1000; <br> <br>    // Allocate memory for 'pbBuffer'. <br>    if((pbBuffer = malloc(dwBufferLen)) == NULL) { <br>printf("Out of memory 1!\n"); <br>goto error; <br>    } <br> <br>    // Open source file. <br>    if((hSourceFile = fopen(szSourceFile,"rb")) == NULL) { <br>printf("Error opening source file!\n"); <br>goto error; <br>    } <br> <br>    // Create a hash object. <br>    if(!CryptCreateHash(hProv, CALG_MD5, 0, 0, &amp;hHash)) { <br>printf("Error %x during CryptCreateHash!\n", GetLastError()); <br>goto error; <br>    } <br> <br>    // Hash source file. <br>    do { <br>// Read up to 'dwBufferLen' bytes from source file. <br>dwCount = fread(pbBuffer, 1, dwBufferLen, hSourceFile); <br>if(ferror(hSourceFile)) { <br>    printf("Error reading Plaintext!\n"); <br>    goto error; <br>        } <br>eof = feof(hSourceFile); <br> <br>// Add data to hash object. <br>if(!CryptHashData(hHash, pbBuffer, dwCount, 0)) { <br>    printf("Error %x during CryptHashData!\n", GetLastError()); <br>    goto error; <br>} <br>    } while(!feof(hSourceFile)); <br> <br>    // Close source file. <br>    fclose(hSourceFile); <br>    hSourceFile = 0; <br> <br>    // Free 'pbBuffer' memory. <br>    free(pbBuffer); <br>    pbBuffer = NULL; <br> <br> <br>    // <br>    // Read in signature file. <br>    // <br> <br>    // Determine size of signature. <br>    dwSignatureLen = 0; <br>    if(!CryptSignHash(hHash, AT_SIGNATURE, NULL, 0, NULL, &amp;dwSignatureLen)) { <br>printf("Error %x during CryptSignHash!\n", GetLastError()); <br>goto error; <br>    } <br> <br>    // Allocate memory for 'pbSignature'. <br>    if((pbSignature = malloc(dwSignatureLen)) == NULL) { <br>printf("Out of memory 2!\n"); <br>goto error; <br>    } <br> <br>    // Open signature file. <br>    if((hSignatureFile = fopen(szSignatureFile,"rb")) == NULL) { <br>printf("Error opening signature file!\n"); <br>goto error; <br>    } <br> <br>    // Read signature data. <br>    dwCount = fread(pbSignature, 1, dwSignatureLen, hSignatureFile); <br>    if(ferror(hSignatureFile)) { <br>printf("Error reading signature!\n"); <br>goto error; <br>    } <br> <br>    // Close signature file. <br>    fclose(hSignatureFile); <br>    hSignatureFile = 0; <br> <br> <br>    // <br>    // Verify signature. <br>    // <br> <br>    // Get handle to signature key. <br>    if(!CryptGetUserKey(hProv, AT_SIGNATURE, &amp;hSigPublicKey)) { <br>printf("Error %x during CryptGetUserKey!\n", GetLastError()); <br>goto error; <br>    } <br> <br>    // Verify signature. <br>    if(!CryptVerifySignature(hHash, pbSignature, dwSignatureLen, hSigPublicKey, szDescription, 0)) { <br>if(GetLastError() == NTE_BAD_SIGNATURE) { <br>    printf("Signature did not match!\n"); <br>} else { <br>    printf("Error %x during CryptVerifySignature!\n", GetLastError()); <br>} <br>goto error; <br>    } <br> <br>    // Release signature key. <br>    CryptDestroyKey(hSigPublicKey); <br>    hSigPublicKey = 0; <br> <br>    // Free 'pbSignature' memory. <br>    free(pbSignature); <br>    pbSignature = NULL; <br> <br>    // Destroy hash object. <br>    CryptDestroyHash(hHash); <br>    hHash = 0; <br> <br>    // Release provider handle. <br>    CryptReleaseContext(hProv, 0); <br>    hProv = 0; <br> <br>    printf("OK\n"); <br> <br>    return TRUE; <br> <br>    error: <br> <br>    // <br>    // Do cleanup <br>    // <br> <br>    // Close files. <br>    if(hSourceFile) fclose(hSourceFile); <br>    if(hSignatureFile) fclose(hSignatureFile); <br> <br>    // Free memory. <br>    if(pbSignature) free(pbSignature); <br>    if(pbBuffer) free(pbBuffer); <br> <br>    // Release crypto handles. <br>    if(hHash) CryptDestroyHash(hHash); <br>    if(hSigPublicKey) CryptDestroyKey(hSigPublicKey); <br>    if(hProv) CryptReleaseContext(hProv, 0); <br> <br>    return FALSE; <br>} <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
