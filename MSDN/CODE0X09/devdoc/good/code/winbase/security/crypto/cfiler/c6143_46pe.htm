<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>EXPDIR.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6152"></a>EXPDIR.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples.  <br>*       Copyright 1996 - 1998 Microsoft Corporation. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>//    PROGRAM: EXPDIR.C <br>// <br>//    PURPOSE: Directory Listbox expansion/collapse functions <br> <br>#define  STRICT <br> <br>#include "cfiler.h" <br> <br>extern HANDLE ghModule; <br> <br>/**********************************************************************************\ <br>* ExpDir() <br>* <br>* Thread Function <br>* Called when directory is selected (Enter or Double-click).  Expands subdirs <br>*  of selected directory if not expanded, indenting subdirs.  If <br>*  already expanded, deletes all subdirs from listbox <br>* <br>* Returns:  TRUE if successful, FALSE if error. <br>\***********************************************************************************/ <br> <br>BOOL ExpDir(LPCINFO lpCInfo) <br>{ <br>    HANDLE          hFile = NULL;   //  Find file handle <br>    WIN32_FIND_DATA FileData;       //  Find file info structure <br> <br>    TCHAR           szFileName[BUF_SIZE]; <br>TCHARszFileName2[BUF_SIZE]; <br>TCHARszInsertString[DIRECTORY_STRING_SIZE &lt;&lt; 1]; <br>TCHARszBuf[BUF_SIZE]; <br> <br>    PTCHAR          lpszHold;      //  Points to actual name in LB string <br> <br>    BOOL            fDone = FALSE;  //  Loop flag for finding files in dir <br> <br>    DWORD           dwAttrib;       //  Holds file attribute flags <br> <br>    LONG            lIndex,         //  Index of selected listbox member <br>                    lDirDepth; <br> <br>    INT i; <br> <br>   if (!lpCInfo) { <br>   ErrorMsg(TEXT("ExpDir: lpCInfo is NULL.")); <br>   return FALSE; <br>   } <br>    <br>   for (i = 0; i &lt; BUF_SIZE; i++) { <br>szFileName[i] = TEXT('\0'); <br>szFileName2[i] = TEXT('\0'); <br>} <br>     <br>    if( WaitForSingleObject( lpCInfo-&gt;hDirMutex, MUTEX_TIMEOUT) <br>            == WAIT_TIMEOUT ){ <br>        ErrorMsg(TEXT("ExpDir: Dir LB Mutex Timeout.")); <br>        return(0); <br>    } <br> <br>    // <br>    // If the LB is empty, we insert the root, unexpanded <br>    // <br>    if( !SendMessage( lpCInfo-&gt;hDirLB, LB_GETCOUNT, 0, 0) ){ <br> <br>        TCHAR   szHold[DIRECTORY_STRING_SIZE &lt;&lt; 1]; <br> <br>        szHold[0] = TEXT('+'); <br>        lstrcpy( &amp;(szHold[1]), lpCInfo-&gt;lpDriveInfo-&gt;DriveName ); <br> <br>        // <br>        // Also copy the DriveName to the Caption Bar. <br>        // <br>        lstrcpy(lpCInfo-&gt;CaptionBarText, lpCInfo-&gt;lpDriveInfo-&gt;DriveName ); <br> <br>        SendMessage(lpCInfo-&gt;hDirLB, LB_ADDSTRING, 0, <br>                    (LPARAM)szHold ); <br> <br>        if (!TableAdd(lpCInfo-&gt;DirTable, lpCInfo-&gt;lpDriveInfo-&gt;DriveName, szHold)) { <br>ErrorMsg(TEXT("ExpDir: TableAdd failed.")); <br>return FALSE; <br>} <br>         <br>        ReleaseMutex( lpCInfo-&gt;hDirMutex ); <br>        return(1); <br>    } <br> <br>    // <br>    // Retrieve index of selected (careted) directory. <br>    // <br>    lIndex = SendMessage( lpCInfo-&gt;hDirLB, LB_GETCARETINDEX, <br>                          (WPARAM)NULL, (LPARAM)NULL ); <br> <br>    if( SendMessage( lpCInfo-&gt;hDirLB, LB_GETTEXT, (WPARAM)lIndex, <br>                        (LPARAM)szFileName ) &lt; 0 ){ <br>        ErrorMsg(TEXT("Expand Directory:  Get listbox text failure")); <br>        ExpDirExit(lpCInfo, hFile); <br>        return(0); <br>    } <br> <br>    lDirDepth = GetDirDepth( szFileName, &amp;lpszHold ); <br> <br>    if( lDirDepth == -1 ){ <br>        ErrorMsg(TEXT(" Expand Directory:  GetDirDepth failure")); <br>        ExpDirExit(lpCInfo, hFile); <br>        return(0); <br>    } <br> <br>    // <br>    // If Directory is already expanded, collapse it, and vice versa. <br>    //  First, change the symbol. <br>    // <br>    if( *lpszHold == TEXT('-')) <br>        *lpszHold = TEXT('+'); <br>    else <br>        *lpszHold = TEXT('-'); <br> <br>    // <br>    // Clear WM_SETREDRAW flag, so changes will not be seen until entire <br>    //  expansion/collapse is complete.  Reset flag at end of function <br>    // <br>    if( SendMessage(lpCInfo-&gt;hDirLB, WM_SETREDRAW, (WPARAM)FALSE, <br>                (LPARAM)0 ) &lt; 0){ <br>        ErrorMsg(TEXT("Expand Directory:  Clear redraw flag failure")); <br>        ExpDirExit(lpCInfo, hFile); <br>        return(0); <br>    } <br> <br>    // <br>    // Delete old dir string, insert new, and reset the selection <br>    // <br>    if( SendMessage(lpCInfo-&gt;hDirLB, LB_DELETESTRING, (WPARAM)lIndex, <br>                (LPARAM)0 ) &lt; 0){ <br>        ErrorMsg(TEXT("Expand Directory:  Delete dir string failure")); <br>        ExpDirExit(lpCInfo, hFile); <br>        return(0); <br>    } <br>else { <br>if (!TableGetHidden(lpCInfo-&gt;DirTable, lIndex, szBuf)) { <br>ErrorMsg(TEXT("ExpDir: TableGetHidden failed.")); <br>return 0; <br>} <br>lstrcpy(szInsertString, szBuf); <br>TableRemove(lpCInfo-&gt;DirTable, lIndex); <br>} <br> <br>    if( SendMessage(lpCInfo-&gt;hDirLB, LB_INSERTSTRING, (WPARAM)lIndex, <br>               (LPARAM)szFileName ) &lt; 0){ <br>        ErrorMsg(TEXT("Expand Directory:  Insert dir string failure")); <br>        ExpDirExit(lpCInfo, hFile); <br>        return(0); <br>    } <br>else { <br>if (!TableInsert(lpCInfo-&gt;DirTable, szInsertString, szFileName, lIndex)) { <br>ErrorMsg(TEXT("ExpDir: TableInsert failed.")); <br>return 0; <br>} <br>} <br>     <br>    if( SendMessage(lpCInfo-&gt;hDirLB, LB_SETCURSEL, (WPARAM)lIndex, <br>               (LPARAM)0 ) &lt; 0){ <br>        ErrorMsg(TEXT("Expand Directory:  Insert dir string failure")); <br>        ExpDirExit(lpCInfo, hFile); <br>        return(0); <br>    } <br> <br>    // <br>    // The symbol has been changed, now collapse if needed, then reset <br>    //  redraw flag, leave critical section, and exit. <br>    // <br>    if( *lpszHold == TEXT('+') ){ <br>        CollapseDir( lpCInfo, lIndex, lDirDepth); <br>        ExpDirExit(lpCInfo, hFile); <br>        return(1); <br>    } <br> <br>    // <br>    // If we're here, directory needs to be expanded. <br>    //  Enumerate subdirectories beneath the dir entry in the listbox. <br>    // <br>    // First, Get the full path of the directory (in szFileName) <br>    // <br>    if (!TableGetHidden(lpCInfo-&gt;DirTable, lIndex, szBuf)) { <br>    ErrorMsg(TEXT("ExpDir: TableGetHidden failed.")); <br>    return FALSE; <br>    } <br>     <br>    lstrcpy(szFileName, szBuf); <br>         <br>    // <br>    // Check to see if there is a terminating backslash <br>    //  Then append a '*' as a wildcard for FindFirstFile. <br>    // <br>    lpszHold = &amp;szFileName[lstrlen(szFileName)]; <br> <br>    lpszHold--; <br>    if( *lpszHold != TEXT('\\') ){ <br>        lpszHold++; <br>        *lpszHold = TEXT('\\'); <br>    } <br> <br>    lstrcpy(szFileName2, szFileName); <br>     <br>    lpszHold++; <br>    lstrcpy( lpszHold, TEXT("*")); <br> <br>    // <br>    // Start a search on all the files within the directory <br>    // <br>    hFile = FindFirstFile( szFileName, &amp;FileData ); <br>    if( hFile == INVALID_HANDLE_VALUE ){ <br>        ErrorMsg(TEXT("Expand Directory: FindFirstFile failure.")); <br>        ExpDirExit(lpCInfo, hFile); <br>        return(0); <br>    } <br> <br>    // <br>    // Walk all the files in the directory. <br>    // <br>    while( !fDone ){ <br> <br>        // <br>        // Check to see if the thread has been requested to kill itself. <br>        //  This code does not clear the suicide flag for synchronization <br>        //  reasons - it is left to the calling code. <br>        // <br>        if( lpCInfo-&gt;fSuicide ){ <br>            ErrorMsg(TEXT("Expand Directory: killing thread per request.")); <br>            ExpDirExit(lpCInfo, hFile); <br> <br>            // <br>            // Post an MM_REFRESH Message if the user has re-collapsed the <br>            //  Dir LB. <br>            // <br>            if( !lpCInfo-&gt;fDirExpand ) <br>                if( !PostMessage(lpCInfo-&gt;hwnd, WM_COMMAND, MM_REFRESH, <br>                                 (LPARAM)0) ) <br>                    ErrorMsg(TEXT("ExpDir: MM_REFRESH call failure.")); <br> <br>            // <br>            // We must return failure (0) here, so if FullExpand is calling, <br>            //  it will terminate. <br>            // <br>            return(0); <br>        } <br> <br>        // <br>        // Append filename to path, and get attributes <br>        // <br>        lstrcpy(lpszHold, FileData.cFileName); <br>        dwAttrib = GetFileAttributes( szFileName ); <br> <br>        // <br>        // Check if file is a directory.  If not, or if '.' or '..', fall <br>        //  through.  If so, add it to the directory listbox. <br>        // <br>        if( dwAttrib &amp; FILE_ATTRIBUTE_DIRECTORY ) <br>            if( lstrcmp( FileData.cFileName,TEXT(".") ) ) <br>                if( lstrcmp( FileData.cFileName,TEXT("..") ) ){ <br>                    TCHAR   szLBEntry[DIRECTORY_STRING_SIZE &lt;&lt; 1]; <br>TCHARszHidden[DIRECTORY_STRING_SIZE &lt;&lt; 1]; <br> <br>lstrcpy(szHidden, szFileName2); <br>lstrcat(szHidden, FileData.cFileName); <br> <br>                    if (IsEncrypted(szHidden)) { <br>                    TCHARszDecryptedName[BUF_SIZE]; <br>HANDLEhFileRead; <br> <br>GetDecryptedDirName(lpCInfo-&gt;hDirLB,  <br>szHidden,  <br>szDecryptedName,  <br>0,  <br>&amp;hFileRead); <br>                    CloseHandle(hFileRead); <br>                     <br>if (!SimplifyFileName(szDecryptedName, szBuf)) { <br>ErrorMsg(TEXT("ExpDir: SimplifyFileName failed.")); <br>return FALSE; <br>} <br>                     <br>                    lstrcpy(szDecryptedName, szBuf); <br> <br>                    ConstructLBEntry(lDirDepth, szDecryptedName, szLBEntry); <br>                    } <br>else <br>ConstructLBEntry(lDirDepth, FileData.cFileName, szLBEntry); <br>                     <br>                    // <br>                    //  Increment index in order to add subdir after <br>                    //  dirs just inserted. <br>                    // <br>                    lIndex++; <br>                     <br>                    if( SendMessage(lpCInfo-&gt;hDirLB, LB_INSERTSTRING, <br>                                       (WPARAM)lIndex, <br>                                       (LPARAM)szLBEntry) &lt; 0){ <br>                        ErrorMsg(TEXT("Expand Directory: error inserting string.")); <br>                        ExpDirExit(lpCInfo, hFile); <br>                        return(0); <br>                    } <br>                     <br>                    if (!TableInsert(lpCInfo-&gt;DirTable, szHidden, szLBEntry, lIndex)) { <br>ErrorMsg(TEXT("ExpDir: TableInsert failed.")); <br>return FALSE; <br>} <br>     } <br> <br>        fDone = !FindNextFile( hFile, &amp;FileData ); <br>    } <br> <br>    ExpDirExit(lpCInfo, hFile); <br>    return(1); <br>} <br> <br>/***********************************************************************************\ <br>* ExpDirExit() <br>* <br>* Performs clean-up operations for ExpDir, closing handles, etc. <br>\***********************************************************************************/ <br> <br>void ExpDirExit(LPCINFO lpCInfo, HANDLE hFile) <br>{ <br>    if (!lpCInfo) { <br>    ErrorMsg(TEXT("ExpDirExit: lpCInfo is NULL.")); <br>    return; <br>    } <br>     <br>    // Reset redraw flag. Post this message, to avoid synchro problems <br>   <br>    if( PostMessage(lpCInfo-&gt;hDirLB, WM_SETREDRAW, (WPARAM)TRUE, <br>                (LPARAM)0 ) &lt; 0) <br>        ErrorMsg(TEXT("Expand Directory:  Clear redraw flag failure")); <br> <br>    // <br>    // Close FindFirstFile session <br>    // <br>    if( hFile != NULL) <br>        FindClose(hFile); <br> <br>    // <br>    // Release Dir LB Mutex <br>    // <br>    ReleaseMutex( lpCInfo-&gt;hDirMutex); <br>} <br> <br>/***********************************************************************************\ <br>* ConstructDirName() <br>* <br>* Builds the fully qualified path of the current directory, by walking back <br>*  through the Dir LB tree. <br>* <br>* Returns:  TRUE if successful, FALSE if error. <br>*           Returns the full directory path of given directory name in <br>*             lpszDirName. <br>\***********************************************************************************/ <br> <br>BOOL ConstructDirName(LPCINFO lpCInfo, LONG lIndex, LPTSTR lpszDirName) <br>{ <br>    LONG    lDirDepth,      //  Depth of selected directory <br>            lSeekDepth = LONG_MAX; <br> <br>    TCHAR   szFileName[DIRECTORY_STRING_SIZE &lt;&lt; 1];   // file buffer <br>    LPTSTR  lpszInfoPtr, <br>            lpszHold; <br> <br>    if (!lpCInfo) { <br>    ErrorMsg(TEXT("ConstructDirName: lpCInfo is NULL.")); <br>    return FALSE; <br>    } <br>     <br>    // <br>    // Clear the directory name buffer <br>    // <br>    *lpszDirName = TEXT('\0'); <br> <br>    // <br>    // Walk up the entries in the listbox, constructing the full path from <br>    //   the bottom up. <br>    // <br>    while( lIndex &gt;= 0 ){ <br> <br>        // <br>        // Get listbox text, and compute the depth of the directory <br>        // <br>        if( SendMessage( lpCInfo-&gt;hDirLB, LB_GETTEXT, (WPARAM)lIndex, <br>                            (LPARAM)szFileName ) &lt; 0 ){ <br>            ErrorMsg(TEXT(" Expand Directory:  Get listbox text failure")); <br>            return(0); <br>        } <br> <br>        lDirDepth = GetDirDepth(szFileName, &amp;lpszInfoPtr); <br>        if( lDirDepth == -1){ <br>            ErrorMsg(TEXT("ConstructDirName: GetDirDepth failed")); <br>            return(0); <br>        } <br> <br>        // <br>        // If we've reached the next level up, add to the directory name <br>        // <br>        if( lDirDepth &lt; lSeekDepth ){ <br>            lSeekDepth = lDirDepth; <br> <br>            // check if we will exceed the size of our buffer <br>            if( lstrlen(lpszInfoPtr) + lstrlen(lpszDirName) &gt; <br>                    (DIRECTORY_STRING_SIZE &lt;&lt; 1) ){ <br>                ErrorMsg(TEXT("ConstructDirName:  Exceeded Directory Size limit")); <br>                return(0); <br>            } <br> <br>            // Find the end of the directory name <br>            lpszHold = &amp;lpszInfoPtr[lstrlen(lpszInfoPtr)]; <br>            <br>            // If we're not at the root, add a '\' <br>            if( lIndex &amp;&amp; (*lpszDirName != TEXT('\0')) ) <br>                *lpszHold++ = TEXT('\\'); <br> <br>            // Append the heretofore computed path to the end of the dir name <br>            lstrcpy( lpszHold, lpszDirName); <br>            // Copy the whole path so far back into the final buffer <br>            lstrcpy( lpszDirName, ++lpszInfoPtr); <br>        } <br> <br>        // If the first level dir has been added, jump to the root, <br>        //   else go up to the previous entry in the listbox. <br>        if( lDirDepth == 1 ) <br>            lIndex = 0; <br>        else <br>            lIndex--; <br>    } <br> <br>return(TRUE); <br>} <br> <br>/***********************************************************************************\ <br>* GetDirDepth() <br>* <br>* Returns:  -1 if error <br>*           otherwise, the depth of the directory (i.e. root is depth 0, <br>*           c:\foo is depth 1, etc.  This is computed in perhaps not the <br>*           most efficient way, by counting the ' 's proceeding the name. <br>* <br>*           This function also returns in lpszDirName a pointer to the <br>*           end of the preceeding ' ' characters within the given listbox str. <br>*           If the function fails, this pointer value is undefined. <br>* <br>* The left shifted index is to skip the tab characters. See ConstructLBEntry(). <br>\***********************************************************************************/ <br> <br>LONG GetDirDepth(LPTSTR lpszLBString, LPTSTR *lpszDirName) <br>{ <br>    TCHAR cBar; <br>    LONG  lCount = 0; <br> <br>    do{ <br> <br>        cBar = lpszLBString[lCount &lt;&lt; 1]; <br> <br>        if( cBar == TEXT(' ') ) <br>            lCount++; <br>        else <br>            if( cBar != TEXT('+') &amp;&amp; cBar != TEXT('-') ){ <br>                ErrorMsg(TEXT("GetDirDepth: string parse error")); <br>                return(-1); <br>            } <br> <br>    }while( cBar != TEXT('+') &amp;&amp; cBar != TEXT('-') ); <br> <br>    *lpszDirName = &amp;(lpszLBString[lCount &lt;&lt; 1]); <br> <br>    return( lCount ); <br>} <br> <br>/***********************************************************************************\ <br>* CollapseDir() <br>* <br>* If directory is expanded, collapses it, by deleteing any subdirectory <br>*  entries below it. <br>* <br>* Returns:  TRUE if successful, FALSE if error <br>\***********************************************************************************/ <br> <br>BOOL CollapseDir(LPCINFO lpCInfo, LONG lIndex, LONG lDirDepth) <br>{ <br>    TCHAR   szFileName[DIRECTORY_STRING_SIZE &lt;&lt; 1];   // file name buffer <br>    LPTSTR  lpszNamePtr; <br> <br>    LONG    lDepthHold; <br>     <br>    if (!lpCInfo) { <br>    ErrorMsg(TEXT("CollapseDir: lpCInfo is NULL.")); <br>    return FALSE; <br>    } <br>     <br>    // <br>    // Remove any following LB entries until we return to same depth <br>    // <br>    do{ <br>    if (lpCInfo-&gt;DirTable-&gt;iNumElems == 1) <br>    return 1; <br>     <br>    if( SendMessage( lpCInfo-&gt;hDirLB, LB_GETTEXT, (WPARAM)lIndex + 1, <br>                            (LPARAM)szFileName ) &lt; 0 ){ <br>            ErrorMsg(TEXT(" Expand Directory:  Get listbox text failure")); <br>            return(0); <br>        } <br> <br>        lDepthHold = GetDirDepth( szFileName, &amp;lpszNamePtr); <br>        if( lDirDepth == -1 ){ <br>            ErrorMsg(TEXT(" Expand Directory:  GetDirDepth failure")); <br>            return(0); <br>        } <br> <br>        if( lDirDepth &lt; lDepthHold ) { <br>            if( SendMessage( lpCInfo-&gt;hDirLB, LB_DELETESTRING, (WPARAM)lIndex + 1, <br>                                (LPARAM)0 ) &lt; 0 ){ <br>                ErrorMsg(TEXT(" Expand Directory:  Delete String failure")); <br>                return(0); <br>            } <br>if (!TableRemove(lpCInfo-&gt;DirTable, lIndex + 1)) { <br>ErrorMsg(TEXT("CollapseDir: TableRemove failed.")); <br>return 0; <br>} <br>} <br>    }while( lDirDepth &lt; lDepthHold ); <br> <br>    return(1); <br>} <br> <br>/***********************************************************************************\ <br>* ConstructLBEntry() <br>* <br>* Given the parent's directory depth, and the subdirectory name, inserts <br>* ' 's equal to the depth+1 of the parent (plus tab character), and an <br>* unexpanded '+' directory marker, then the name of the subdirectory. <br>* <br>* The left shifted index is to skip the tab characters. <br>* <br>* Returns:  void.  the completed listbox entry is returned in szLBEntry. <br>\***********************************************************************************/ <br> <br>void ConstructLBEntry(LONG lDirDepth, LPTSTR szFileName, LPTSTR szLBEntry) <br>{ <br>    int i; <br> <br>    for(i = 0; i &lt;= lDirDepth; i++){ <br>        szLBEntry[i &lt;&lt; 1] = TEXT(' '); <br>        szLBEntry[(i &lt;&lt; 1) + 1] = 9; <br>    } <br> <br>    szLBEntry[i &lt;&lt; 1] = TEXT('+'); <br>    szLBEntry[(i &lt;&lt; 1) + 1] = TEXT('\0'); <br> <br>    lstrcat(szLBEntry, szFileName); <br>} <br> <br>/***********************************************************************************\ <br>* FullExpand() <br>* <br>* From the unexpanded root, walks down directory LB, expanding each directory <br>*  until it reaches the end of the tree. <br>\***********************************************************************************/ <br> <br>BOOL FullExpand(LPCINFO lpCInfo) <br>{ <br>    LONG lIndex = 0; <br> <br>    if (!lpCInfo) { <br>    ErrorMsg(TEXT("FullExpand: lpCInfo is NULL.")); <br>    return FALSE; <br>    } <br>     <br>    if( WaitForSingleObject( lpCInfo-&gt;hDirMutex, MUTEX_TIMEOUT) <br>            == WAIT_TIMEOUT ){ <br>        ErrorMsg(TEXT("FullExpand: Dir LB Mutex Timeout.")); <br>        return(0); <br>    } <br> <br>    while( SendMessage(lpCInfo-&gt;hDirLB, LB_SETCURSEL, <br>                        (WPARAM)lIndex, <br>                        (LPARAM)0) != LB_ERR ){ <br>        if( !ExpDir( lpCInfo ) ){ <br>            ErrorMsg(TEXT("Full Expand: ExpDir failure.")); <br>            ReleaseMutex( lpCInfo-&gt;hDirMutex ); <br> <br>            // This is in case the ExpDir failed because a change drive <br>            //  command caused a kill. <br>            if( !PostMessage(lpCInfo-&gt;hwnd, WM_COMMAND, MM_REFRESH, <br>                            (LPARAM)0) ) <br>                ErrorMsg(TEXT("ExpDir: MM_REFRESH call failure.")); <br>            return(0); <br>        } <br> <br>        lIndex++; <br>    } <br> <br>    //  Set selection in listboxes to first item. <br>    if( SendMessage(lpCInfo-&gt;hDirLB, LB_SETCURSEL, <br>                        (WPARAM)0, <br>                        (LPARAM)0) == LB_ERR ){ <br>        ErrorMsg(TEXT("Full Expand: Dir LB Set Selection Error")); <br>        ReleaseMutex( lpCInfo-&gt;hDirMutex ); <br>        return(0); <br>    } <br> <br>    ReleaseMutex( lpCInfo-&gt;hDirMutex ); <br>    return(1); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
