<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>ENCRYPT.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6161"></a>ENCRYPT.C</h2>
<pre><code>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples.  <br>*       Copyright 1996 - 1998 Microsoft Corporation. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;wincrypt.h&gt; <br> <br>#ifdef USE_BLOCK_CIPHER <br>    // defines for RC2 block cipher <br>    #define ENCRYPT_ALGORITHMCALG_RC2 <br>    #define ENCRYPT_BLOCK_SIZE8 <br>#else <br>    // defines for RC4 stream cipher <br>    #define ENCRYPT_ALGORITHMCALG_RC4 <br>    #define ENCRYPT_BLOCK_SIZE1 <br>#endif <br> <br>static BOOL CAPIEncryptFile(PCHAR szSource, PCHAR szDestination, PCHAR szPassword); <br> <br>/*****************************************************************************/ <br>void _cdecl main(int argc, char *argv[]) <br>{ <br>    PCHAR szSource= NULL; <br>    PCHAR szDestination = NULL; <br>    PCHAR szPassword= NULL; <br> <br>    // Validate argument count. <br>    if(argc != 3 &amp;&amp; argc != 4) { <br>printf("USAGE: encrypt &lt;source file&gt; &lt;dest file&gt; [ &lt;password&gt; ]\n"); <br>exit(1); <br>    } <br> <br>    // Parse arguments. <br>    szSource   = argv[1]; <br>    szDestination  = argv[2]; <br>    if(argc == 4) { <br>szPassword = argv[3]; <br>    } <br> <br>    if(!CAPIEncryptFile(szSource, szDestination, szPassword)) { <br>printf("Error encrypting file!\n"); <br>exit(1); <br>    } <br> <br>    exit(0); <br>} <br> <br>/*****************************************************************************/ <br>static BOOL CAPIEncryptFile(PCHAR szSource, PCHAR szDestination, PCHAR szPassword) <br>{ <br>    FILE *hSource      = NULL; <br>    FILE *hDestination = NULL; <br>    INT eof = 0; <br> <br>    HCRYPTPROV hProv   = 0; <br>    HCRYPTKEY hKey     = 0; <br>    HCRYPTKEY hXchgKey = 0; <br>    HCRYPTHASH hHash   = 0; <br> <br>    PBYTE pbKeyBlob = NULL; <br>    DWORD dwKeyBlobLen; <br> <br>    PBYTE pbBuffer = NULL; <br>    DWORD dwBlockLen; <br>    DWORD dwBufferLen; <br>    DWORD dwCount; <br> <br>    BOOL status = FALSE; <br> <br>    // Open source file. <br>    if((hSource = fopen(szSource,"rb")) == NULL) { <br>printf("Error opening Plaintext file!\n"); <br>        goto done; <br>    } <br> <br>    // Open destination file. <br>    if((hDestination = fopen(szDestination,"wb")) == NULL) { <br>printf("Error opening Ciphertext file!\n"); <br>        goto done; <br>    } <br> <br>    // Get handle to the default provider. <br>    if(!CryptAcquireContext(&amp;hProv, NULL, NULL, PROV_RSA_FULL, 0)) { <br>        printf("Error %x during CryptAcquireContext!\n", GetLastError()); <br>        goto done; <br>    } <br> <br>    if(szPassword == NULL) { <br>// Encrypt the file with a random session key. <br> <br>// Create a random session key. <br>if(!CryptGenKey(hProv, ENCRYPT_ALGORITHM, CRYPT_EXPORTABLE, &amp;hKey)) { <br>    printf("Error %x during CryptGenKey!\n", GetLastError()); <br>    goto done; <br>} <br> <br>// Get handle to key exchange public key. <br>if(!CryptGetUserKey(hProv, AT_KEYEXCHANGE, &amp;hXchgKey)) { <br>    printf("Error %x during CryptGetUserKey!\n", GetLastError()); <br>    goto done; <br>} <br> <br>// Determine size of the key blob and allocate memory. <br>if(!CryptExportKey(hKey, hXchgKey, SIMPLEBLOB, 0, NULL, &amp;dwKeyBlobLen)) { <br>    printf("Error %x computing blob length!\n", GetLastError()); <br>    goto done; <br>} <br>if((pbKeyBlob = malloc(dwKeyBlobLen)) == NULL) { <br>    printf("Out of memory!\n"); <br>    goto done; <br>} <br> <br>// Export session key into a simple key blob. <br>if(!CryptExportKey(hKey, hXchgKey, SIMPLEBLOB, 0, pbKeyBlob, &amp;dwKeyBlobLen)) { <br>    printf("Error %x during CryptExportKey!\n", GetLastError()); <br>    goto done; <br>} <br> <br>// Release key exchange key handle. <br>CryptDestroyKey(hXchgKey); <br>hXchgKey = 0; <br> <br>// Write size of key blob to destination file. <br>fwrite(&amp;dwKeyBlobLen, sizeof(DWORD), 1, hDestination); <br>if(ferror(hDestination)) { <br>    printf("Error writing header!\n"); <br>    goto done; <br>} <br> <br>// Write key blob to destination file. <br>fwrite(pbKeyBlob, 1, dwKeyBlobLen, hDestination); <br>if(ferror(hDestination)) { <br>    printf("Error writing header!\n"); <br>    goto done; <br>} <br> <br>    } else { <br>// Encrypt the file with a session key derived from a password. <br> <br>// Create a hash object. <br>if(!CryptCreateHash(hProv, CALG_MD5, 0, 0, &amp;hHash)) { <br>    printf("Error %x during CryptCreateHash!\n", GetLastError()); <br>    goto done; <br>} <br> <br>// Hash in the password data. <br>if(!CryptHashData(hHash, szPassword, strlen(szPassword), 0)) { <br>    printf("Error %x during CryptHashData!\n", GetLastError()); <br>    goto done; <br>} <br> <br>// Derive a session key from the hash object. <br>if(!CryptDeriveKey(hProv, ENCRYPT_ALGORITHM, hHash, 0, &amp;hKey)) { <br>    printf("Error %x during CryptDeriveKey!\n", GetLastError()); <br>    goto done; <br>} <br> <br>// Destroy the hash object. <br>CryptDestroyHash(hHash); <br>hHash = 0; <br>    } <br> <br>    // Determine number of bytes to encrypt at a time. This must be a multiple <br>    // of ENCRYPT_BLOCK_SIZE. <br>    dwBlockLen = 1000 - 1000 % ENCRYPT_BLOCK_SIZE; <br> <br>    // Determine the block size. If a block cipher is used this must have <br>    // room for an extra block. <br>    if(ENCRYPT_BLOCK_SIZE &gt; 1) { <br>dwBufferLen = dwBlockLen + ENCRYPT_BLOCK_SIZE; <br>    } else { <br>dwBufferLen = dwBlockLen; <br>    } <br> <br>    // Allocate memory. <br>    if((pbBuffer = malloc(dwBufferLen)) == NULL) { <br>printf("Out of memory!\n"); <br>goto done; <br>    } <br> <br>    // Encrypt source file and write to Source file. <br>    do { <br>// Read up to 'dwBlockLen' bytes from source file. <br>dwCount = fread(pbBuffer, 1, dwBlockLen, hSource); <br>if(ferror(hSource)) { <br>    printf("Error reading Plaintext!\n"); <br>            goto done; <br>        } <br>eof = feof(hSource); <br> <br>        // Encrypt data <br>if(!CryptEncrypt(hKey, 0, eof, 0, pbBuffer, &amp;dwCount, dwBufferLen)) { <br>            printf("bytes required:%d\n",dwCount); <br>            printf("Error %x during CryptEncrypt!\n", GetLastError()); <br>            goto done; <br>        } <br> <br>// Write data to destination file. <br>fwrite(pbBuffer, 1, dwCount, hDestination); <br>if(ferror(hDestination)) { <br>    printf("Error writing Ciphertext!\n"); <br>            goto done; <br>        } <br>    } while(!feof(hSource)); <br> <br>    status = TRUE; <br> <br>    printf("OK\n"); <br> <br>    done: <br> <br>    // Close files. <br>    if(hSource) fclose(hSource); <br>    if(hDestination) fclose(hDestination); <br> <br>    // Free memory. <br>    if(pbKeyBlob) free(pbKeyBlob); <br>    if(pbBuffer) free(pbBuffer); <br> <br>    // Destroy session key. <br>    if(hKey) CryptDestroyKey(hKey); <br> <br>    // Release key exchange key handle. <br>    if(hXchgKey) CryptDestroyKey(hXchgKey); <br> <br>    // Destroy hash object. <br>    if(hHash) CryptDestroyHash(hHash); <br> <br>    // Release provider handle. <br>    if(hProv) CryptReleaseContext(hProv, 0); <br> <br>    return(status); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
