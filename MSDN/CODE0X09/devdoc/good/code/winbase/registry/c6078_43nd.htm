<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>MONKEY.C</title>
<link disabled rel=stylesheet href=../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6079"></a>MONKEY.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples.  <br>*       Copyright 1993 - 1998 Microsoft Corporation. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>/*************************************************************************\ <br>* <br>*  PROGRAM: Monkey: the Registry Monkey Utility. <br>*  PURPOSE: To demonstrate Registry API. <br>*  COMMENTS: <br>* <br>\*************************************************************************/ <br> <br> <br>#define STRICT <br>#include &lt;windows.h&gt; <br>#include &lt;string.h&gt; <br>#define _MBCS <br>#include &lt;mbstring.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;stdio.h&gt; <br>#include "monkey.h" <br> <br> <br>HANDLE hInst; <br>HWND   hDlg; <br> <br>HANDLE hHeap; <br> <br> <br>/*************************************************************************\ <br>* <br>*  FUNCTION: WinMain(HANDLE, HANDLE, LPSTR, int) <br>* <br>*  PURPOSE: Creates the dialogbox. <br>* <br>*  COMMENTS: <br>* <br>\*************************************************************************/ <br> <br>int APIENTRY WinMain (HINSTANCE hInstance, <br>                      HINSTANCE hPrevInstance, <br>                      LPSTR     lpCmdLine, <br>                      int       nCmdShow) <br> <br> <br>{ <br>  DWORD retCode; <br> <br>  UNREFERENCED_PARAMETER( nCmdShow ); <br>  UNREFERENCED_PARAMETER( lpCmdLine ); <br>  UNREFERENCED_PARAMETER( hPrevInstance ); <br> <br>  hInst   = hInstance; <br>  hHeap   = HeapCreate (0, 0, 0); <br> <br>  retCode = DialogBox ((HANDLE)hInst, (LPCSTR)"MonkeyDlg", <br>                        NULL, (DLGPROC)MonkeyDlgProc); <br> <br>  HeapDestroy (hHeap); <br>  return  (retCode); <br> <br>} <br> <br>/************************************************************************\ <br>* <br>*  FUNCTION: MonkeyDlgProc(); <br>* <br>*  PURPOSE:  Handle the Monkey dialog box messages. <br>* <br>*  MESSAGES: <br>* <br>*    WM_INITDIALOG  - Posts WM_GETFIRSTKEY message. <br>* <br>*    WM_GETFIRSTKEY - Puts the first 4 pre-defined keys in the listbox. <br>* <br>*    IDL_LISTBOX    - Trapped when an item in the left hand listbox <br>*                     has been double clicked.  It posts a IDB_NEXT message. <br>* <br>*    IDL_LISTBOX2   - Trapped when an item in the right hand listbox has <br>*                     been double clicked.  It basically calls DisplayKeyData, <br>*                     which fills the Value edit fields with the data from <br>*                     the current key's specified value information. <br>* <br>*    IDB_PRINT      - Basically calls PrintTree() which does a recursive <br>*                     print of the Registry from the current key to the <br>*                     end of it's branches. <br>* <br>*    IDB_BACK       - Sets the dialog box with the information from the <br>*                     previously selected key (one closer to the root of <br>*                     the registry, the parent of the current key). <br>* <br>*    IDB_NEXT       - Sets the dialog box with the information on the <br>*                     selected key child. <br>* <br>*    IDR_FULL       - Sets a global variable used to determine if the <br>*                     user wants to print full Registry information <br>*                     or only information from keys that have value <br>*                     associated with it.  Variable is set to TRUE. <br>* <br>*    IDR_TRIMMED    - Same as above, only the variable is set to FALSE. <br>* <br>\************************************************************************/ <br> <br>int APIENTRY MonkeyDlgProc (HWND hDlg, WORD wMsg, LONG wParam, LONG lParam) <br>  { <br>   ULONG    KeyClassLength = 256; <br>   ULONG    KeyNameLength = 256; <br>   DWORD    indexLB; <br>   CHAR     *putNullAt; <br>   CHAR     lpBuffer1[128]; <br>   CHAR     lpBuffer2[128]; <br> <br>   static   CHAR     RegPath[MAX_PATH]  = ""; <br>   static   CHAR     NameLBSelect[256]  = ""; <br>   static   HKEY     hKeyRoot; <br>   static   DWORD    RegLevel; <br>   static   BOOL     FullBranches = TRUE; <br> <br>   static   HANDLE   hFile = INVALID_HANDLE_VALUE; <br>   static   HANDLE   hBootIni; <br> <br>  UNREFERENCED_PARAMETER( lParam ); <br> <br>  switch (wMsg) <br>    { <br>      case WM_INITDIALOG: <br>          // Post a message to get the first 4 pre-defined keys, and set <br>          // Full Branches to be the print default. <br>        PostMessage (hDlg, WM_GETFIRSTKEY, 0, 0); <br>        CheckDlgButton (hDlg, IDR_FULL, TRUE); <br>        return (0); <br> <br>      case WM_GETFIRSTKEY: <br>          // Initialize by putting the first 4 predefined keys of the <br>          // registry in the list box. <br> <br>        SendMessage (GetDlgItem(hDlg, IDL_LISTBOX), <br>                     LB_ADDSTRING, 0, (LONG)"HKEY_LOCAL_MACHINE"); <br> <br>        SendMessage (GetDlgItem(hDlg, IDL_LISTBOX), <br>                     LB_ADDSTRING, 0, (LONG)"HKEY_CURRENT_USER"); <br> <br>        SendMessage (GetDlgItem(hDlg, IDL_LISTBOX), <br>                     LB_ADDSTRING, 0, (LONG)"HKEY_USERS"); <br> <br>        SendMessage (GetDlgItem(hDlg, IDL_LISTBOX), <br>                     LB_ADDSTRING, 0, (LONG)"HKEY_CLASSES_ROOT"); <br> <br>        hKeyRoot = 0;                   // Initialize hKeyRoot. <br>        return (0); <br> <br>      case WM_SYSCOMMAND: <br>        if (wParam == SC_CLOSE) <br>          { <br>          EndDialog (hDlg, TRUE); <br>          if (hFile != INVALID_HANDLE_VALUE) <br>            CloseHandle (hFile); <br>          return (TRUE); <br>          } <br>        break; <br> <br>      case WM_COMMAND: <br> <br>        switch (LOWORD(wParam)) <br>          { <br>            case IDR_FULL: <br>                // If Full Branches pressed, set global var to TRUE. <br>              FullBranches = TRUE; <br>              return (0); <br> <br>            case IDR_TRIMMED: <br>                // If Trimmed Branches pressed, set global var to FALSE. <br>              FullBranches = FALSE; <br>              return (0); <br> <br>            case IDL_LISTBOX: <br>                 // If double click in left hand listbox, clear Value <br>                 // edit fields, and execute Next functionality. <br>               if ( HIWORD (wParam) == LBN_DBLCLK) <br>                { <br>                 SetDlgItemText (hDlg, IDE_VALUE1, ""); <br>                 SetDlgItemText (hDlg, IDE_VALUE2, ""); <br>                 PostMessage (hDlg, WM_COMMAND, IDB_NEXT, 0); <br>                } <br>               return (0); <br> <br>            case IDL_LISTBOX2: <br>                 // If double click right hand listbox, clear Value edit <br>                 // fields, then display the key's data. <br>               if ( HIWORD (wParam) == LBN_DBLCLK) <br>                { <br>                 SetDlgItemText (hDlg, IDE_VALUE1, ""); <br>                 SetDlgItemText (hDlg, IDE_VALUE2, ""); <br>                 DisplayKeyData (hDlg, RegPath, hKeyRoot); <br>                } <br>               return (0); <br> <br> <br>            case IDB_NEXT: <br>                 // Get the index of the cursor selection <br>                 // in the list box. <br>               indexLB = SendMessage (GetDlgItem (hDlg, IDL_LISTBOX), <br>                                      LB_GETCURSEL, 0, 0); <br> <br>                 // If nothing is selected, flag user and return, otherwise <br>                 // process the selected key. <br>                                       // LB_ERR indicates nothing selected. <br>               if (indexLB == LB_ERR) <br>                 { <br>                 LoadString(hInst, IDS_SELECTMSG, lpBuffer1, sizeof(lpBuffer1)); <br>                 LoadString(hInst, IDS_NAME, lpBuffer2, sizeof(lpBuffer2)); <br>                 MessageBox (hDlg, lpBuffer1, lpBuffer2, MB_OK); <br>                 return (0); <br>                 } <br> <br>                 // If listbox item 0 is pressed, user wants to move <br>                 // back up.  Execute the Back functionality. <br>               if (indexLB == 0 &amp;&amp; hKeyRoot) <br>                { <br>                PostMessage (hDlg, WM_COMMAND, IDB_BACK, 0); <br>                return (0); <br>                } <br> <br> <br>                                       // Get text from selection in LB. <br>               SendMessage (GetDlgItem (hDlg, IDL_LISTBOX), <br>                            LB_GETTEXT, indexLB, (LPARAM)NameLBSelect); <br> <br>                                       // Put name of chosen item in Name field. <br>               SetDlgItemText (hDlg, IDE_NAME, NameLBSelect); <br> <br>                                       // Then clear ListBox entries. <br>               SendMessage (GetDlgItem (hDlg, IDL_LISTBOX), <br>                            LB_RESETCONTENT, 0, 0); <br>               SendMessage (GetDlgItem (hDlg, IDL_LISTBOX2), <br>                            LB_RESETCONTENT, 0, 0); <br> <br>               EnumerateLevel (hDlg, NameLBSelect, RegPath, &amp;hKeyRoot); <br> <br>               return (0); <br> <br> <br> <br>            case IDB_BACK: <br> <br>                 // For this case (hRootKey = 0)you're at the top level already. <br>                 // Tell the user, then return <br>               if (!hKeyRoot) <br>                 { <br>                 LoadString(hInst, IDS_TOPLEVEL, lpBuffer1, sizeof(lpBuffer1)); <br>                 LoadString(hInst, IDS_NAME, lpBuffer2, sizeof(lpBuffer2)); <br>                 MessageBox (hDlg, lpBuffer1, lpBuffer2, MB_OK); <br>                 return (0); <br>                 } <br> <br>                 //For all remaining cases, clear the listboxes. <br>               SendMessage (GetDlgItem (hDlg, IDL_LISTBOX), <br>                            LB_RESETCONTENT, 0, 0); <br>               SendMessage (GetDlgItem (hDlg, IDL_LISTBOX2), <br>                            LB_RESETCONTENT, 0, 0); <br> <br> <br> <br>                 // If hRootKey has a value, but the pathname is blank, <br>                 // then you must be 1 level deep, reset to level 0 by <br>                 // posting WM_GETFIRSTKEY. <br>               if (strcmp (RegPath, "") == 0) <br>                 { <br>                 SetDlgItemText (hDlg, IDE_NAME, ""); <br>                 PostMessage (hDlg, WM_GETFIRSTKEY, 0, 0); <br>                 return (0); <br>                 } <br> <br> <br>                 // Two cases left.  One in which the path has only one <br>                 // key name in it, and no back slash character (meaning <br>                 // strrchr() will return NULL); and one the other case <br>                 // where there are more than one key name in the path ( <br>                 // and at least one back slash for strrchr().  If this <br>                 // is the first case, we want to fakeout EnumerateLevel <br>                 // into thinking we just picked one of the pre-defined keys, <br>                 // and then re-enumerate it's child keys. <br>               if ((putNullAt = _mbsrchr (RegPath, '\\')) == NULL) <br>                 { <br>                 RegPath[0] = '\0'; <br> <br>                 switch ((DWORD)hKeyRoot) <br>                   { <br>                   case (DWORD)HKEY_LOCAL_MACHINE: <br>                     strcpy (NameLBSelect, "HKEY_LOCAL_MACHINE"); <br>                     break; <br> <br>                   case (DWORD)HKEY_USERS: <br>                     strcpy (NameLBSelect, "HKEY_USERS"); <br>                     break; <br> <br>                   case (DWORD)HKEY_CURRENT_USER: <br>                     strcpy (NameLBSelect, "HKEY_CURRENT_USER"); <br>                     break; <br> <br>                   case (DWORD)HKEY_CLASSES_ROOT: <br>                     strcpy (NameLBSelect, "HKEY_CLASSES_ROOT"); <br>                     break; <br>                   } <br>                 SetDlgItemText (hDlg, IDE_NAME, NameLBSelect); <br>                 hKeyRoot = 0; <br>                 EnumerateLevel (hDlg, NameLBSelect, RegPath, &amp;hKeyRoot); <br>                 } <br>               else <br>                 { <br>                   // In the final case, we can just trim the last key <br>                   // name off the path, and re-enumerate the level. <br>                 *putNullAt = '\0'; <br>                 putNullAt = _mbsrchr (RegPath, '\\'); <br> <br>                 if (putNullAt) <br>                   { <br>                   strcpy (NameLBSelect, putNullAt+1); <br>                   *putNullAt = '\0'; <br>                   } <br>                 else <br>                   { <br>                   strcpy (NameLBSelect, RegPath); <br>                   *RegPath = '\0'; <br>                   } <br>                 SetDlgItemText (hDlg, IDE_NAME, NameLBSelect); <br>                 EnumerateLevel (hDlg, NameLBSelect, RegPath, &amp;hKeyRoot); <br>                 } <br>               return (0); <br> <br>            default: <br>               return (0); <br> <br>          } <br> <br>     } <br>    return (FALSE); <br> <br>  } <br> <br> <br> <br> <br>/************************************************************************\ <br>* <br>*  FUNCTION: EnumerateLevel(); <br>* <br>*  PURPOSE: To get a valid key handle (either to determine if the one sent <br>*           to the function was one of the pre-defined, or to open a key <br>*           specified by the path), and to pass that key handle along <br>*           to QueryKey(). <br>* <br>*           To enumerate the children of a key, you must have <br>*           an open handle to it.  The four top keys of the <br>*           Registry are predefined and open for use: <br>*           HKEY_LOCAL_MACHINE, HKEY_USERS, HKEY_CURRENT_USER, <br>*           and HKEY_CLASSES_ROOT.  These 4 can be used for <br>*           RegEnumKey as is; but to RegEnumKey on any of the <br>*           children of these you must first have an open key <br>*           handle to the child. <br>* <br>*           If hKeyRoot != 0, assume you are lower than the <br>*           first level of the Registry and the user is trying <br>*           to enumerate one of the children.  First calculate <br>*           the name of the child, and then use RegOpenKey to <br>*           get an open handle. <br>* <br>*           If hKeyRoot == 0, assume you are at the top level <br>*           of the Registry, and set the hKey to be enumerated <br>*           to be one of the 4 predefined values, the specific <br>*           one indicated by the ListBox selection. <br>* <br>\************************************************************************/ <br>  VOID EnumerateLevel (HWND hDlg, LPTSTR NameLBSelect, <br>                       LPTSTR RegPath, HKEY *hKeyRoot) <br>  { <br> <br>    HKEY hKey; <br>    DWORD  retCode; <br>    CHAR   Buf[100]; <br>    CHAR   lpBuffer[128]; <br> <br> <br>    if (*hKeyRoot) <br>      { <br>                                       // If RegPath is not NULL, then <br>                                       // you have to add a backslash to the <br>                                       // path name before appending the next <br>                                       // level child name. <br>      if (strcmp (RegPath, "") != 0) <br>        strcat (RegPath, "\\"); <br> <br>                                       // Add the next level child name. <br>      strcat (RegPath, NameLBSelect); <br> <br>                                       // Use RegOpenKeyEx() with the new <br>                                       // Registry path to get an open handle <br>                                       // to the child key you want to <br>                                       // enumerate. <br>      retCode = RegOpenKeyEx (*hKeyRoot, <br>                              RegPath, <br>                              0, <br>                              KEY_ENUMERATE_SUB_KEYS | <br>                              KEY_EXECUTE | <br>                              KEY_QUERY_VALUE, <br>                              &amp;hKey); <br> <br>      if (retCode != ERROR_SUCCESS) <br>        { <br>        if (retCode == ERROR_ACCESS_DENIED) { <br>          LoadString(hInst, IDS_CANTOPENKEY, lpBuffer, sizeof(lpBuffer)); <br>          wsprintf (Buf, lpBuffer); <br>        } <br>        else { <br>          LoadString(hInst, IDS_OPENKEYERR, lpBuffer, sizeof(lpBuffer)); <br>          wsprintf (Buf, lpBuffer, retCode, __LINE__); <br>        } <br>        MessageBox (hDlg, Buf, "", MB_OK); <br>        PostMessage (hDlg, WM_COMMAND, IDB_BACK, 0); <br>        return; <br>        } <br> <br>      } <br>    else <br>      { <br>                                       // Set the *hKeyRoot handle based <br>                                       // on the text taken from the ListBox. <br> <br>      if (strcmp (NameLBSelect, "HKEY_CLASSES_ROOT") == 0) <br>        *hKeyRoot = HKEY_CLASSES_ROOT; <br> <br>      if (strcmp (NameLBSelect, "HKEY_USERS") == 0) <br>        *hKeyRoot = HKEY_USERS; <br> <br>      if (strcmp (NameLBSelect, "HKEY_LOCAL_MACHINE") == 0) <br>        *hKeyRoot = HKEY_LOCAL_MACHINE; <br> <br>      if (strcmp (NameLBSelect, "HKEY_CURRENT_USER") == 0) <br>        *hKeyRoot = HKEY_CURRENT_USER; <br> <br>      hKey = *hKeyRoot;     // hKey is used in RegEnumKey(). <br> <br>      }//end if/else *hKeyRoot <br> <br>      QueryKey (hDlg, hKey); <br> <br> <br>      RegCloseKey (hKey);   // Close the key handle. <br> <br>//      rect.top = 0; rect.left = 5; rect.right = 1200; rect.bottom = 25; <br>//      hDC = GetDC (hDlg); <br>//      FillRect (hDC, &amp;rect, GetStockObject(WHITE_BRUSH)); <br>//      TextOut (hDC, 5, 5, RegPath, strlen(RegPath)); <br>//      ReleaseDC (hDlg, hDC); <br>      SetDlgItemText (hDlg, IDE_TEXTOUT, RegPath); <br> <br> <br>  } <br> <br> <br>/************************************************************************\ <br>* <br>*  FUNCTION: QueryKey(); <br>* <br>*  PURPOSE:  To display the key's children (subkeys) and the names of <br>*            the Values associated with it.  This function uses RegEnumKey, <br>*            RegEnumValue, and RegQueryInfoKey. <br>* <br>\************************************************************************/ <br>VOID QueryKey (HWND hDlg, HANDLE hKey) <br>  { <br>  CHAR     KeyName[MAX_PATH]; <br>  CHAR     ClassName[MAX_PATH] = ""; // Buffer for class name. <br>  DWORD    dwcClassLen = MAX_PATH;   // Length of class string. <br>  DWORD    dwcSubKeys;               // Number of sub keys. <br>  DWORD    dwcMaxSubKey;             // Longest sub key size. <br>  DWORD    dwcMaxClass;              // Longest class string. <br>  DWORD    dwcValues;                // Number of values for this key. <br>  DWORD    dwcMaxValueName;          // Longest Value name. <br>  DWORD    dwcMaxValueData;          // Longest Value data. <br>  DWORD    dwcSecDesc;               // Security descriptor. <br>  FILETIME ftLastWriteTime;          // Last write time. <br> <br>  DWORD i; <br>  DWORD retCode; <br> <br>  DWORD j; <br>  DWORD retValue; <br>  CHAR  ValueName[MAX_VALUE_NAME]; <br>  DWORD dwcValueName = MAX_VALUE_NAME; <br>  CHAR  Buf[80]; <br>  CHAR  lpBuffer[80]; <br> <br> <br>  // Get Class name, Value count. <br> <br>  RegQueryInfoKey (hKey,              // Key handle. <br>                   ClassName,         // Buffer for class name. <br>                   &amp;dwcClassLen,      // Length of class string. <br>                   NULL,              // Reserved. <br>                   &amp;dwcSubKeys,       // Number of sub keys. <br>                   &amp;dwcMaxSubKey,     // Longest sub key size. <br>                   &amp;dwcMaxClass,      // Longest class string. <br>                   &amp;dwcValues,        // Number of values for this key. <br>                   &amp;dwcMaxValueName,  // Longest Value name. <br>                   &amp;dwcMaxValueData,  // Longest Value data. <br>                   &amp;dwcSecDesc,       // Security descriptor. <br>                   &amp;ftLastWriteTime); // Last write time. <br> <br>  SetDlgItemText (hDlg, IDE_CLASS, ClassName); <br>  SetDlgItemInt  (hDlg, IDE_CVALUES, dwcValues, FALSE); <br> <br>  SendMessage (GetDlgItem (hDlg, IDL_LISTBOX), <br>               LB_ADDSTRING, 0, (LONG)".."); <br> <br>                                       // Loop until RegEnumKey fails, get <br>                                       // the name of each child and enter <br>                                       // it into the box. <br> <br>  // Enumerate the Child Keys. <br> <br>  SetCursor (LoadCursor (NULL, IDC_WAIT)); <br>  for (i=0, retCode = ERROR_SUCCESS; retCode == ERROR_SUCCESS; i++) <br>    { <br>    retCode = RegEnumKey (hKey, i, <br>                          KeyName, MAX_PATH); <br> <br>    if (retCode == (DWORD)ERROR_SUCCESS) <br>      SendMessage (GetDlgItem(hDlg, IDL_LISTBOX), <br>                   LB_ADDSTRING, 0, (LONG)KeyName); <br>    } <br>  SetCursor (LoadCursor (NULL, IDC_ARROW)); <br> <br> <br>  // Enumerate the Key Values <br>        SetCursor (LoadCursor (NULL, IDC_WAIT)); <br> <br>        if (dwcValues) <br>          for (j = 0, retValue = ERROR_SUCCESS; j &lt; dwcValues; j++) <br>            { <br>            dwcValueName = MAX_VALUE_NAME; <br>            ValueName[0] = '\0'; <br>            retValue = RegEnumValue (hKey, j, ValueName, <br>                                     &amp;dwcValueName, <br>                                     NULL, <br>                                     NULL,               //&amp;dwType, <br>                                     NULL,               //&amp;bData, <br>                                     NULL);              //&amp;bcData); <br>            if (retValue != (DWORD)ERROR_SUCCESS &amp;&amp; <br>                retValue != ERROR_INSUFFICIENT_BUFFER) <br>              { <br>              LoadString(hInst, IDS_REGERR, lpBuffer, sizeof(lpBuffer)); <br>              wsprintf (Buf, lpBuffer, __LINE__, j, retValue, dwcValueName); <br>              LoadString(hInst, IDS_DEBUG, lpBuffer, sizeof(lpBuffer)); <br>              MessageBox (hDlg, Buf, lpBuffer, MB_OK); <br>              } <br> <br>            Buf[0] = '\0'; <br>            if (!strlen(ValueName)) { <br>              LoadString(hInst, IDS_NONAME, lpBuffer, sizeof(lpBuffer)); <br>              strcpy (ValueName, lpBuffer); <br>            } <br>            wsprintf (Buf, "%d) %s ", j, ValueName); <br>            SendMessage (GetDlgItem (hDlg, IDL_LISTBOX2), <br>                           LB_ADDSTRING, 0, (LONG)Buf); <br> <br>            }// end for(;;) <br> <br>        SetCursor (LoadCursor (NULL, IDC_ARROW)); <br> <br>  } <br> <br> <br> <br>/************************************************************************\ <br>* <br>*  FUNCTION: DisplayKeyData(); <br>* <br>*  PURPOSE:  To display the keys values and value types to the Value edit <br>*            field.  This function is called when the right hand listbox <br>*            is double clicked.  The functionality is much like that found <br>*            in the function PrintTree, please see it for more details. <br>* <br>\************************************************************************/ <br> <br> <br>VOID DisplayKeyData (HWND hDlg, CHAR *RegPath, HANDLE hKeyRoot) <br>  { <br>  HKEY   hKey; <br>  DWORD  dwLBIndex; <br>  CHAR   Buf[LINE_LEN]; <br>  CHAR   ValueName[MAX_VALUE_NAME]; <br>  DWORD  cbValueName = MAX_VALUE_NAME; <br>  DWORD  dwType; <br>  DWORD  retCode; <br>  CHAR   lpBuffer[128]; <br>  CHAR   lpBuffer2[128]; <br> <br>  CHAR   ClassName[MAX_PATH]; <br>  DWORD  dwcClassLen = MAX_PATH; <br>  DWORD  dwcSubKeys; <br>  DWORD  dwcMaxSubKey; <br>  DWORD  dwcMaxClass; <br>  DWORD  dwcValues; <br>  DWORD  dwcMaxValueName; <br>  DWORD  dwcMaxValueData; <br>  DWORD  dwcSecDesc; <br>  FILETIME  ftLastWriteTime; <br> <br> <br>  BYTE   *bData; <br>  DWORD  cbData; <br> <br>  CHAR   *outBuf; <br>  DWORD  i; <br>  DWORD  cStrLen; <br> <br>  CHAR   *BinaryStrBuf; <br>  CHAR   ByteBuf[4]; <br> <br>  CHAR   *ptr; <br> <br>  // OPEN THE KEY. <br> <br>                                // LBIndex should == value index. <br>  dwLBIndex = SendMessage (GetDlgItem (hDlg, IDL_LISTBOX2), <br>                           LB_GETCURSEL, 0, 0); <br> <br>  retCode = RegOpenKeyEx (hKeyRoot,    // Key handle at root level. <br>                          RegPath,     // Path name of child key. <br>                          0,           // Reserved. <br>                          KEY_EXECUTE, // Requesting read access. <br>                          &amp;hKey);      // Address of key to be returned. <br> <br>  if (retCode) <br>    { <br>    LoadString(hInst, IDS_REGOPENERR, lpBuffer, sizeof(lpBuffer)); <br>    wsprintf (Buf, lpBuffer, retCode); <br>    MessageBox (hDlg, Buf, "DisplayKeyData()", MB_OK); <br>    return; <br>    } <br> <br>// ADD A QUERY AND ALLOCATE A BUFFER FOR BDATA. <br> <br>  retCode = <br>  RegQueryInfoKey (hKey,              // Key handle. <br>                   ClassName,         // Buffer for class name. <br>                   &amp;dwcClassLen,      // Length of class string. <br>                   NULL,              // Reserved. <br>                   &amp;dwcSubKeys,       // Number of sub keys. <br>                   &amp;dwcMaxSubKey,     // Longest sub key size. <br>                   &amp;dwcMaxClass,      // Longest class string. <br>                   &amp;dwcValues,        // Number of values for this key. <br>                   &amp;dwcMaxValueName,  // Longest Value name. <br>                   &amp;dwcMaxValueData,  // Longest Value data. <br>                   &amp;dwcSecDesc,       // Security descriptor. <br>                   &amp;ftLastWriteTime); // Last write time. <br> <br>   if (retCode) <br>    { <br>    LoadString(hInst, IDS_REGQUERYERR, lpBuffer, sizeof(lpBuffer)); <br>    wsprintf (Buf, lpBuffer, retCode, __LINE__); <br>    MessageBox (hDlg, Buf, "", MB_OK); <br>    } <br> <br>   bData = HeapAlloc (hHeap, 0, dwcMaxValueData); <br>   cbData = dwcMaxValueData; <br> <br> <br>  // ENUMERATE THE KEY. <br> <br>  retCode = RegEnumValue (hKey,        // Key handle returned from RegOpenKeyEx. <br>                          dwLBIndex,   // Value index, taken from listbox. <br>                          ValueName,   // Name of value. <br>                          &amp;cbValueName,// Size of value name. <br>                          NULL,        // Reserved, dword = NULL. <br>                          &amp;dwType,     // Type of data. <br>                          bData,       // Data buffer. <br>                          &amp;cbData);    // Size of data buffer. <br> <br>  if (retCode != ERROR_SUCCESS) <br>    { <br> <br>    if (dwType &lt; REG_FULL_RESOURCE_DESCRIPTOR) <br>      { <br>      LoadString(hInst, IDS_REGENUMERR, lpBuffer, sizeof(lpBuffer)); <br>      wsprintf (Buf, lpBuffer, retCode, cbData, __LINE__); <br>      MessageBox (hDlg, Buf, "", MB_OK); <br>      } <br>    } <br> <br> <br>  switch (dwType) <br>    { <br>//    REG_NONE                    ( 0 )   // No value type <br>//    REG_SZ                      ( 1 )   // Unicode nul terminated string <br>//    REG_EXPAND_SZ               ( 2 )   // Unicode nul terminated string <br>                                            // (with environment variable references) <br>//    REG_BINARY                  ( 3 )   // Free form binary <br>//    REG_DWORD                   ( 4 )   // 32-bit number <br>//    REG_DWORD_LITTLE_ENDIAN     ( 4 )   // 32-bit number (same as REG_DWORD) <br>//    REG_DWORD_BIG_ENDIAN        ( 5 )   // 32-bit number <br>//    REG_LINK                    ( 6 )   // Symbolic Link (unicode) <br>//    REG_MULTI_SZ                ( 7 )   // Multiple Unicode strings <br>//    REG_RESOURCE_LIST           ( 8 )   // Resource list in the resource map <br>//    REG_FULL_RESOURCE_DESCRIPTOR ( 9 )  // Resource list in the hardware description <br> <br>    case REG_NONE: <br>      LoadString(hInst, IDS_REGNONE, lpBuffer, sizeof(lpBuffer)); <br>      SetDlgItemText (hDlg, IDE_VALUE1, lpBuffer); <br>      break; <br> <br>    case REG_SZ: <br>      LoadString(hInst, IDS_REGSZ, lpBuffer, sizeof(lpBuffer)); <br>      SetDlgItemText (hDlg, IDE_VALUE1, lpBuffer); <br> <br>      outBuf = HeapAlloc (hHeap, 0, cbData + 2); <br>      *outBuf = '\0'; <br> <br>      strcat (outBuf, "\""); <br>      strcat (outBuf, bData); <br>      strcat (outBuf, "\""); <br> <br>      SetDlgItemText (hDlg, IDE_VALUE2, outBuf); <br>      HeapFree (hHeap, 0, outBuf); <br>      break; <br> <br>    case REG_EXPAND_SZ: <br>      LoadString(hInst, IDS_REGEXPSZ, lpBuffer, sizeof(lpBuffer)); <br>      SetDlgItemText (hDlg, IDE_VALUE1, lpBuffer); <br>      outBuf = HeapAlloc (hHeap, 0, cbData + 2); <br>      *outBuf = '\0'; <br> <br>      strcat (outBuf, "\""); <br>      strcat (outBuf, bData); <br>      strcat (outBuf, "\""); <br> <br>      SetDlgItemText (hDlg, IDE_VALUE2, outBuf); <br>      HeapFree (hHeap, 0, outBuf); <br>      break; <br> <br>    case REG_BINARY: <br>      LoadString(hInst, IDS_REGBIN, lpBuffer, sizeof(lpBuffer)); <br>      SetDlgItemText (hDlg, IDE_VALUE1, lpBuffer); <br>      SetCursor (LoadCursor (NULL, IDC_WAIT)); <br> <br>      BinaryStrBuf = HeapAlloc (hHeap, 0, (3 * cbData) + 1); <br>      if (BinaryStrBuf) <br>        { <br>        *BinaryStrBuf = '\0'; <br>        *ByteBuf = '\0'; <br>        for (i = 0; i &lt; cbData; i++) <br>          { <br>          sprintf (ByteBuf, "%02x ", (BYTE)bData[i]); <br>          strcat (BinaryStrBuf, ByteBuf); <br>          } <br>        SetDlgItemText (hDlg, IDE_VALUE2, BinaryStrBuf); <br>        } <br>      else <br>        { <br>        LoadString(hInst, IDS_MALLOCERR, lpBuffer, sizeof(lpBuffer)); <br>        LoadString(hInst, IDS_DBGTITLE, lpBuffer2, sizeof(lpBuffer2)); <br>        MessageBox (hDlg, lpBuffer, lpBuffer2, MB_OK); <br>        } <br>      SetDlgItemText (hDlg, IDL_LISTBOX2, BinaryStrBuf); <br>      HeapFree (hHeap, 0, BinaryStrBuf); <br>      SetCursor (LoadCursor (NULL, IDC_ARROW)); <br> <br>      break; <br> <br>    case REG_DWORD: <br>      LoadString(hInst, IDS_REGDWORD, lpBuffer, sizeof(lpBuffer)); <br>      SetDlgItemText (hDlg, IDE_VALUE1, lpBuffer); <br>      SetDlgItemInt (hDlg, IDE_VALUE2, *(UINT *)bData, FALSE); <br>      break; <br> <br>    case REG_DWORD_BIG_ENDIAN: <br>      LoadString(hInst, IDS_REGBIGEND, lpBuffer, sizeof(lpBuffer)); <br>      SetDlgItemText (hDlg, IDE_VALUE1, lpBuffer); <br>      SetDlgItemInt (hDlg, IDE_VALUE2, *(UINT *)bData, TRUE); <br>      break; <br> <br>    case REG_LINK: <br>      LoadString(hInst, IDS_REGLINK, lpBuffer, sizeof(lpBuffer)); <br>      SetDlgItemText (hDlg, IDE_VALUE1, lpBuffer); <br>      SetDlgItemText (hDlg, IDE_VALUE2, bData); <br>      break; <br> <br>    case REG_MULTI_SZ: <br>      LoadString(hInst, IDS_REGMULTI, lpBuffer, sizeof(lpBuffer)); <br>      SetDlgItemText (hDlg, IDE_VALUE1, lpBuffer); <br>      SetCursor (LoadCursor (NULL, IDC_WAIT)); <br>                                       // Count the NULLs in the buffer to <br>                                       // find out how many strings there are. <br> <br>      for (i=0, cStrLen=4; i &lt; cbData; i++) <br>        if (!bData[i]) <br>          cStrLen+=4;                  // Add room for two quotes and two <br>                                       // spaced per string. <br> <br>      outBuf = HeapAlloc (hHeap, 0, cbData + cStrLen); <br> <br>      ptr = bData;                     // Set ptr to beginning of buffer. <br>      *outBuf = '\0';                  // Initialize output string. <br> <br>      strcat (outBuf, "{ ");           // Do first bracket. <br>      while (*ptr)                     // Loop til you hit 2 NULLs in a row. <br>        { <br>         strcat (outBuf, "\"");        // Put quotes around each string. </code></pre>
<p>
</p>
<pre><code>strcat (outBuf, ptr); <br>         strcat (outBuf, "\"  "); <br>         ptr += strlen(ptr)+1; <br>        } <br>      strcat (outBuf, "}");            // Add final bracket. <br>      SetDlgItemText (hDlg, IDE_VALUE2, outBuf); <br> <br>      SetCursor (LoadCursor (NULL, IDC_ARROW)); <br>      HeapFree (hHeap, 0, outBuf);                 // free output string. <br>      break; <br> <br> <br>    case REG_RESOURCE_LIST:            // CM_RESOURCE_LIST is complex.  Print it <br>                                       // as a free formed binary data for now. <br> <br>      LoadString(hInst, IDS_REGRESLST, lpBuffer, sizeof(lpBuffer)); <br>      SetDlgItemText (hDlg, IDE_VALUE1, lpBuffer); <br> <br>      BinaryStrBuf = HeapAlloc (hHeap, 0, (3 * cbData) + 1); <br>      if (BinaryStrBuf) <br>        { <br>        *BinaryStrBuf = '\0'; <br>        *ByteBuf = '\0'; <br>        for (i = 0; i &lt; cbData; i++) <br>          { <br>          sprintf (ByteBuf, "%02x ", (BYTE)bData[i]); <br>          strcat (BinaryStrBuf, ByteBuf); <br>          } <br>        SetDlgItemText (hDlg, IDE_VALUE2, BinaryStrBuf); <br>        } <br>      else <br>        { <br>        LoadString(hInst, IDS_MALLOCERR, lpBuffer, sizeof(lpBuffer)); <br>        LoadString(hInst, IDS_DBGTITLE, lpBuffer2, sizeof(lpBuffer2)); <br>        MessageBox (hDlg, lpBuffer, lpBuffer2, MB_OK); <br>        } <br>      SetDlgItemText (hDlg, IDL_LISTBOX2, BinaryStrBuf); <br>      HeapFree (hHeap, 0, BinaryStrBuf); <br> <br>      break; <br> <br>    case REG_FULL_RESOURCE_DESCRIPTOR: <br>      LoadString(hInst, IDS_REGFULLDESC, lpBuffer, sizeof(lpBuffer)); <br>      SetDlgItemText (hDlg, IDE_VALUE1, lpBuffer); <br>      break; <br> <br> <br> <br>    default: <br>      LoadString(hInst, IDS_REGUNDEFINE, lpBuffer, sizeof(lpBuffer)); <br>      wsprintf (Buf, lpBuffer, dwType); <br>      SetDlgItemText (hDlg, IDE_VALUE1, Buf); <br>      break; <br> <br>    } // end switch <br> <br> <br>    HeapFree (hHeap, 0, bData); <br>  } </code></pre>
<p>&nbsp;</p></body>
</HTML>
