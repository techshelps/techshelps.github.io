<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>PROPLIST.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5962"></a>PROPLIST.CPP</h2>
<pre><code>///////////////////////////////////////////////////////////////////////////// <br>// <br>//Copyright (c) 1997 &lt;company name&gt; <br>// <br>//Module Name: <br>//PropList.cpp <br>// <br>//Abstract: <br>//Implementation of the CClusPropList class. <br>// <br>//Author: <br>//&lt;name&gt; (&lt;e-mail name&gt;) Mmmm DD, 1997 <br>// <br>//Revision History: <br>// <br>//Notes: <br>// <br>///////////////////////////////////////////////////////////////////////////// <br> <br>#include "stdafx.h" <br>#include "PropList.h" <br> <br>#ifdef _DEBUG <br>#define new DEBUG_NEW <br>#undef THIS_FILE <br>static char THIS_FILE[] = __FILE__; <br>#endif <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// Constant Definitions <br>///////////////////////////////////////////////////////////////////////////// <br> <br>#define BUFFER_GROWTH_FACTOR 256 <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// CClusPropList class <br>///////////////////////////////////////////////////////////////////////////// <br> <br>IMPLEMENT_DYNAMIC(CClusPropList, CObject) <br> <br>///////////////////////////////////////////////////////////////////////////// <br>//++ <br>// <br>//CClusPropList::CClusPropList <br>// <br>//Routine Description: <br>//Default constructor. <br>// <br>//Arguments: <br>//None. <br>// <br>//Return Value: <br>//None. <br>// <br>//-- <br>///////////////////////////////////////////////////////////////////////////// <br>CClusPropList::CClusPropList(IN BOOL bAlwaysAddProp) <br>{ <br>m_proplist.pList = NULL; <br>m_propCurrent.pb = NULL; <br>m_cbBufferSize = 0; <br>m_cbDataSize = 0; <br> <br>m_bAlwaysAddProp = bAlwaysAddProp; <br> <br>}  //*** CClusPropList::CClusPropList(); <br> <br>///////////////////////////////////////////////////////////////////////////// <br>//++ <br>// <br>//CClusPropList::~CClusPropList <br>// <br>//Routine Description: <br>//Destructor. <br>// <br>//Arguments: <br>//None. <br>// <br>//Return Value: <br>//None. <br>// <br>//-- <br>///////////////////////////////////////////////////////////////////////////// <br>CClusPropList::~CClusPropList(void) <br>{ <br>delete [] m_proplist.pb; <br> <br>}  //*** CClusPropList::~CClusPropList(); <br> <br>///////////////////////////////////////////////////////////////////////////// <br>//++ <br>// <br>//CClusPropList::AddProp <br>// <br>//Routine Description: <br>//Add a string property to a property list if it has changed. <br>// <br>//Arguments: <br>//pwszName[IN] Name of the property. <br>//rstrValue[IN] Value of the property to set in the list. <br>//rstrPrevValue[IN] Previous value of the property. <br>// <br>//Return Value: <br>//None. <br>// <br>//-- <br>///////////////////////////////////////////////////////////////////////////// <br>void CClusPropList::AddProp( <br>IN LPCWSTRpwszName, <br>IN const CString &amp;rstrValue, <br>IN const CString &amp;rstrPrevValue <br>) <br>{ <br>PCLUSPROP_PROPERTY_NAMEpName; <br>PCLUSPROP_SZpValue; <br> <br>ASSERT(pwszName != NULL); <br> <br>if (m_bAlwaysAddProp || (rstrValue != rstrPrevValue)) <br>{ <br>DWORDcbNameSize; <br>DWORDcbValueSize; <br> <br>// Calculate sizes and make sure we have a property list. <br>cbNameSize = sizeof(CLUSPROP_PROPERTY_NAME) <br>+ ALIGN_CLUSPROP((lstrlenW(pwszName) + 1) * sizeof(WCHAR)); <br>cbValueSize = sizeof(CLUSPROP_SZ) <br>+ ALIGN_CLUSPROP((rstrValue.GetLength() + 1) * sizeof(WCHAR)) <br>+ sizeof(CLUSPROP_SYNTAX); // value list endmark <br>AllocPropList(cbNameSize + cbValueSize); <br> <br>// Set the property name. <br>pName = m_propCurrent.pName; <br>CopyProp(pName, CLUSPROP_TYPE_NAME, pwszName); <br>m_propCurrent.pb += cbNameSize; <br> <br>// Set the property value. <br>pValue = m_propCurrent.pStringValue; <br>CopyProp(pValue, CLUSPROP_TYPE_LIST_VALUE, rstrValue); <br>m_propCurrent.pb += cbValueSize; <br> <br>// Increment the property count and buffer size. <br>m_proplist.pList-&gt;nPropertyCount++; <br>m_cbDataSize += cbNameSize + cbValueSize; <br>}  // if:  the value has changed <br> <br>}  //*** CClusPropList::AddProp(CString) <br> <br>///////////////////////////////////////////////////////////////////////////// <br>//++ <br>// <br>//CClusPropList::AddProp <br>// <br>//Routine Description: <br>//Add a DWORD property to a property list if it has changed. <br>// <br>//Arguments: <br>//pwszName[IN] Name of the property. <br>//dwValue[IN] Value of the property to set in the list. <br>//dwPrevValue[IN] Previous value of the property. <br>// <br>//Return Value: <br>//None. <br>// <br>//-- <br>///////////////////////////////////////////////////////////////////////////// <br>void CClusPropList::AddProp( <br>IN LPCWSTRpwszName, <br>IN DWORDdwValue, <br>IN DWORDdwPrevValue <br>) <br>{ <br>PCLUSPROP_PROPERTY_NAMEpName; <br>PCLUSPROP_DWORDpValue; <br> <br>ASSERT(pwszName != NULL); <br> <br>if (m_bAlwaysAddProp || (dwValue != dwPrevValue)) <br>{ <br>DWORDcbNameSize; <br>DWORDcbValueSize; <br> <br>// Calculate sizes and make sure we have a property list. <br>cbNameSize = sizeof(CLUSPROP_PROPERTY_NAME) <br>+ ALIGN_CLUSPROP((lstrlenW(pwszName) + 1) * sizeof(WCHAR)); <br>cbValueSize = sizeof(CLUSPROP_DWORD) <br>+ sizeof(CLUSPROP_SYNTAX); // value list endmark <br>AllocPropList(cbNameSize + cbValueSize); <br> <br>// Set the property name. <br>pName = m_propCurrent.pName; <br>CopyProp(pName, CLUSPROP_TYPE_NAME, pwszName); <br>m_propCurrent.pb += cbNameSize; <br> <br>// Set the property value. <br>pValue = m_propCurrent.pDwordValue; <br>CopyProp(pValue, CLUSPROP_TYPE_LIST_VALUE, dwValue); <br>m_propCurrent.pb += cbValueSize; <br> <br>// Increment the property count and buffer size. <br>m_proplist.pList-&gt;nPropertyCount++; <br>m_cbDataSize += cbNameSize + cbValueSize; <br>}  // if:  the value has changed <br> <br>}  //*** CClusPropList::AddProp(DWORD) <br> <br>///////////////////////////////////////////////////////////////////////////// <br>//++ <br>// <br>//CClusPropList::AddProp <br>// <br>//Routine Description: <br>//Add a binary property to a property list if it has changed. <br>// <br>//Arguments: <br>//pwszName[IN] Name of the property. <br>//pbValue[IN] Value of the property to set in the list. <br>//cbValue[IN] Count of bytes in pbValue. <br>//pbPrevValue[IN] Previous value of the property. <br>//cbPrevValue[IN] Count of bytes in pbPrevValue. <br>// <br>//Return Value: <br>//None. <br>// <br>//-- <br>///////////////////////////////////////////////////////////////////////////// <br>void CClusPropList::AddProp( <br>IN LPCWSTRpwszName, <br>IN const PBYTEpbValue, <br>IN DWORDcbValue, <br>IN const PBYTEpbPrevValue, <br>IN DWORDcbPrevValue <br>) <br>{ <br>BOOLbChanged = FALSE; <br>PCLUSPROP_PROPERTY_NAMEpName; <br>PCLUSPROP_BINARYpValue; <br> <br>ASSERT(pwszName != NULL); <br>ASSERT(((cbValue == 0) &amp;&amp; (cbPrevValue == 0)) || (pbValue != pbPrevValue)); <br> <br>// Determine if the buffer has changed. <br>if (m_bAlwaysAddProp || (cbValue != cbPrevValue)) <br>bChanged = TRUE; <br>else if (!((cbValue == 0) &amp;&amp; (cbPrevValue == 0))) <br>bChanged = memcmp(pbValue, pbPrevValue, cbValue) == 0; <br> <br>if (bChanged) <br>{ <br>DWORDcbNameSize; <br>DWORDcbValueSize; <br> <br>// Calculate sizes and make sure we have a property list. <br>cbNameSize = sizeof(CLUSPROP_PROPERTY_NAME) <br>+ ALIGN_CLUSPROP((lstrlenW(pwszName) + 1) * sizeof(WCHAR)); <br>cbValueSize = sizeof(CLUSPROP_BINARY) <br>+ ALIGN_CLUSPROP(cbValue) <br>+ sizeof(CLUSPROP_SYNTAX); // value list endmark <br>AllocPropList(cbNameSize + cbValueSize); <br> <br>// Set the property name. <br>pName = m_propCurrent.pName; <br>CopyProp(pName, CLUSPROP_TYPE_NAME, pwszName); <br>m_propCurrent.pb += cbNameSize; <br> <br>// Set the property value. <br>pValue = m_propCurrent.pBinaryValue; <br>CopyProp(pValue, CLUSPROP_TYPE_LIST_VALUE, pbValue, cbValue); <br>m_propCurrent.pb += cbValueSize; <br> <br>// Increment the property count and buffer size. <br>m_proplist.pList-&gt;nPropertyCount++; <br>m_cbDataSize += cbNameSize + cbValueSize; <br>}  // if:  the value changed <br> <br>}  //*** CClusPropList::AddProp(PBYTE) <br> <br>///////////////////////////////////////////////////////////////////////////// <br>//++ <br>// <br>//CClusPropList::CopyProp <br>// <br>//Routine Description: <br>//Copy a string property to a property structure. <br>// <br>//Arguments: <br>//pprop[OUT] Property structure to fill. <br>//proptype[IN] Type of string. <br>//pwsz[IN] String to copy. <br>//cbsz[IN] Count of bytes in pwsz string. <br>// <br>//Return Value: <br>//None. <br>// <br>//-- <br>///////////////////////////////////////////////////////////////////////////// <br>void CClusPropList::CopyProp( <br>OUT PCLUSPROP_SZpprop, <br>IN CLUSTER_PROPERTY_TYPEproptype, <br>IN LPCWSTRpwsz, <br>IN DWORDcbsz <br>) <br>{ <br>CLUSPROP_BUFFER_HELPERprops; <br> <br>ASSERT(pprop != NULL); <br>ASSERT(pwsz != NULL); <br> <br>pprop-&gt;Syntax.wFormat = CLUSPROP_FORMAT_SZ; <br>pprop-&gt;Syntax.wType = (WORD) proptype; <br>if (cbsz == 0) <br>cbsz = (lstrlenW(pwsz) + 1) * sizeof(WCHAR); <br>ASSERT(cbsz == (lstrlenW(pwsz) + 1) * sizeof(WCHAR)); <br>pprop-&gt;cbLength = cbsz; <br>lstrcpyW(pprop-&gt;sz, pwsz); <br> <br>// Set an endmark. <br>props.pStringValue = pprop; <br>props.pb += sizeof(*props.pStringValue) + ALIGN_CLUSPROP(cbsz); <br>props.pSyntax-&gt;dw = CLUSPROP_SYNTAX_ENDMARK; <br> <br>}  //*** CClusPropList::CopyProp(CString) <br> <br>///////////////////////////////////////////////////////////////////////////// <br>//++ <br>// <br>//CClusPropList::CopyProp <br>// <br>//Routine Description: <br>//Copy a DWORD property to a property structure. <br>// <br>//Arguments: <br>//pprop[OUT] Property structure to fill. <br>//proptype[IN] Type of DWORD. <br>//dw[IN] DWORD to copy. <br>// <br>//Return Value: <br>//None. <br>// <br>//-- <br>///////////////////////////////////////////////////////////////////////////// <br>void CClusPropList::CopyProp( <br>OUT PCLUSPROP_DWORDpprop, <br>IN CLUSTER_PROPERTY_TYPEproptype, <br>IN DWORDdw <br>) <br>{ <br>CLUSPROP_BUFFER_HELPERprops; <br> <br>ASSERT(pprop != NULL); <br> <br>pprop-&gt;Syntax.wFormat = CLUSPROP_FORMAT_DWORD; <br>pprop-&gt;Syntax.wType = (WORD) proptype; <br>pprop-&gt;cbLength = sizeof(DWORD); <br>pprop-&gt;dw = dw; <br> <br>// Set an endmark. <br>props.pDwordValue = pprop; <br>props.pb += sizeof(*props.pDwordValue); <br>props.pSyntax-&gt;dw = CLUSPROP_SYNTAX_ENDMARK; <br> <br>}  //*** CClusPropList::CopyProp(DWORD) <br> <br>///////////////////////////////////////////////////////////////////////////// <br>//++ <br>// <br>//CClusPropList::CopyProp <br>// <br>//Routine Description: <br>//Copy a binary property to a property structure. <br>// <br>//Arguments: <br>//pprop[OUT] Property structure to fill. <br>//proptype[IN] Type of string. <br>//pb[IN] Block to copy. <br>//cbsz[IN] Count of bytes in pb buffer. <br>// <br>//Return Value: <br>//None. <br>// <br>//-- <br>///////////////////////////////////////////////////////////////////////////// <br>void CClusPropList::CopyProp( <br>OUT PCLUSPROP_BINARYpprop, <br>IN CLUSTER_PROPERTY_TYPEproptype, <br>IN const PBYTEpb, <br>IN DWORDcb <br>) <br>{ <br>CLUSPROP_BUFFER_HELPERprops; <br> <br>ASSERT(pprop != NULL); <br> <br>pprop-&gt;Syntax.wFormat = CLUSPROP_FORMAT_BINARY; <br>pprop-&gt;Syntax.wType = (WORD) proptype; <br>pprop-&gt;cbLength = cb; <br>if (cb &gt; 0) <br>CopyMemory(pprop-&gt;rgb, pb, cb); <br> <br>// Set an endmark. <br>props.pBinaryValue = pprop; <br>props.pb += sizeof(*props.pStringValue) + ALIGN_CLUSPROP(cb); <br>props.pSyntax-&gt;dw = CLUSPROP_SYNTAX_ENDMARK; <br> <br>}  //*** CClusPropList::CopyProp(PBYTE) <br> <br>///////////////////////////////////////////////////////////////////////////// <br>//++ <br>// <br>//CClusPropList::AllocPropList <br>// <br>//Routine Description: <br>//Allocate a property list buffer that's big enough to hold the next <br>//property. <br>// <br>//Arguments: <br>//cbMinimum[IN] Minimum size of the property list. <br>// <br>//Return Value: <br>//None. <br>// <br>//Exceptions Thrown: <br>//Any exceptions thrown by BYTE::operator new(). <br>// <br>//-- <br>///////////////////////////////////////////////////////////////////////////// <br>void CClusPropList::AllocPropList( <br>IN DWORDcbMinimum <br>) <br>{ <br>DWORDcbTotal; <br> <br>ASSERT(cbMinimum &gt; 0); <br> <br>// Add the size of the item count and final endmark. <br>cbMinimum += sizeof(DWORD) + sizeof(CLUSPROP_SYNTAX); <br>cbTotal = m_cbDataSize + cbMinimum; <br> <br>if (m_cbBufferSize &lt; cbTotal) <br>{ <br>PBYTEpbNewProplist; <br> <br>cbMinimum = max(BUFFER_GROWTH_FACTOR, cbMinimum); <br>cbTotal = m_cbDataSize + cbMinimum; <br> <br>// Allocate and zero a new buffer. <br>pbNewProplist = new BYTE[cbTotal]; <br>ZeroMemory(pbNewProplist, cbTotal); <br> <br>// If there was a previous buffer, copy it and the delete it. <br>if (m_proplist.pb != NULL) <br>{ <br>if (m_cbDataSize != 0) <br>CopyMemory(pbNewProplist, m_proplist.pb, m_cbDataSize); <br>delete [] m_proplist.pb; <br>m_propCurrent.pb = pbNewProplist + (m_propCurrent.pb - m_proplist.pb); <br>}  // if:  there was a previous buffer <br>else <br>m_propCurrent.pb = pbNewProplist + sizeof(DWORD); // move past prop count <br> <br>// Save the new buffer. <br>m_proplist.pb = pbNewProplist; <br>m_cbBufferSize = cbTotal; <br>}  // if:  buffer isn't big enough <br> <br>}  //*** CClusPropList::AllocPropList(PBYTE) <br> <br>///////////////////////////////////////////////////////////////////////////// <br>//++ <br>// <br>//CClusPropList::DwGetNodeProperties <br>// <br>//Routine Description: <br>//Get properties on a node. <br>// <br>//Arguments: <br>//hNode[IN] Handle for the node to get properties from. <br>//dwControlCode[IN] Control code for the request. <br>//hHostNode[IN] Handle for the node to direct this request to. <br>//Defaults to NULL. <br>//lpInBuffer[IN] Input buffer for the request.  Defaults to NULL. <br>//cbInBufferSize[IN] Size of the input buffer.  Defaults to 0. <br>// <br>//Return Value: <br>//None. <br>// <br>//Exceptions Thrown: <br>//Any exceptions CClusPropList::AllocPropList(). <br>// <br>//-- <br>///////////////////////////////////////////////////////////////////////////// <br>DWORD CClusPropList::DwGetNodeProperties( <br>IN HNODEhNode, <br>IN DWORDdwControlCode, <br>IN HNODEhHostNode, <br>IN LPVOIDlpInBuffer, <br>IN DWORDcbInBufferSize <br>) <br>{ <br>DWORDdwStatus; <br>DWORDcbProps= 256; <br> <br>ASSERT(hNode != NULL); <br>ASSERT((dwControlCode &amp; (CLUSCTL_OBJECT_MASK &lt;&lt; CLUSCTL_OBJECT_SHIFT)) <br>== (CLUS_OBJECT_NODE &lt;&lt; CLUSCTL_OBJECT_SHIFT)); <br> <br>ASSERT(m_proplist.pb == NULL); <br>ASSERT(m_propCurrent.pb == NULL); <br>ASSERT(m_cbBufferSize == 0); <br>ASSERT(m_cbDataSize == 0); <br> <br>do <br>{ <br>// Allocate a default-sized buffer. <br>try <br>{ <br>AllocPropList(cbProps); <br>}  // try <br>catch (CMemoryException * pme) <br>{ <br>pme-&gt;Delete(); <br>return ERROR_NOT_ENOUGH_MEMORY; <br>}  // catch:  CMemoryException <br> <br>// Get properties. <br>dwStatus = ClusterNodeControl( <br>hNode, <br>hHostNode, <br>dwControlCode, <br>lpInBuffer, <br>cbInBufferSize, <br>m_proplist.pb, <br>m_cbBufferSize, <br>&amp;cbProps <br>); <br>} while (dwStatus == ERROR_MORE_DATA); <br> <br>if (dwStatus != ERROR_SUCCESS) <br>{ <br>delete [] m_proplist.pb; <br>m_proplist.pb = NULL; <br>m_propCurrent.pb = NULL; <br>m_cbBufferSize = 0; <br>m_cbDataSize = 0; <br>}  // if:  error getting properties. <br>else <br>m_cbDataSize = cbProps; <br> <br>return dwStatus; <br> <br>}  //*** CClusPropList::DwGetNodeProperties() <br> <br>///////////////////////////////////////////////////////////////////////////// <br>//++ <br>// <br>//CClusPropList::DwGetGroupProperties <br>// <br>//Routine Description: <br>//Get properties on a group. <br>// <br>//Arguments: <br>//hGroup[IN] Handle for the group to get properties from. <br>//dwControlCode[IN] Control code for the request. <br>//hHostNode[IN] Handle for the node to direct this request to. <br>//Defaults to NULL. <br>//lpInBuffer[IN] Input buffer for the request.  Defaults to NULL. <br>//cbInBufferSize[IN] Size of the input buffer.  Defaults to 0. <br>// <br>//Return Value: <br>//None. <br>// <br>//Exceptions Thrown: <br>//Any exceptions CClusPropList::AllocPropList(). <br>// <br>//-- <br>///////////////////////////////////////////////////////////////////////////// <br>DWORD CClusPropList::DwGetGroupProperties( <br>IN HGROUPhGroup, <br>IN DWORDdwControlCode, <br>IN HNODEhHostNode, <br>IN LPVOIDlpInBuffer, <br>IN DWORDcbInBufferSize <br>) <br>{ <br>DWORDdwStatus; <br>DWORDcbProps= 256; <br> <br>ASSERT(hGroup != NULL); <br>ASSERT((dwControlCode &amp; (CLUSCTL_OBJECT_MASK &lt;&lt; CLUSCTL_OBJECT_SHIFT)) <br>== (CLUS_OBJECT_GROUP &lt;&lt; CLUSCTL_OBJECT_SHIFT)); <br> <br>ASSERT(m_proplist.pb == NULL); <br>ASSERT(m_propCurrent.pb == NULL); <br>ASSERT(m_cbBufferSize == 0); <br>ASSERT(m_cbDataSize == 0); <br> <br>do <br>{ <br>// Allocate a default-sized buffer. <br>try <br>{ <br>AllocPropList(cbProps); <br>}  // try <br>catch (CMemoryException * pme) <br>{ <br>pme-&gt;Delete(); <br>return ERROR_NOT_ENOUGH_MEMORY; <br>}  // catch:  CMemoryException <br> <br>// Get properties. <br>dwStatus = ClusterGroupControl( <br>hGroup, <br>hHostNode, <br>dwControlCode, <br>lpInBuffer, <br>cbInBufferSize, <br>m_proplist.pb, <br>m_cbBufferSize, <br>&amp;cbProps <br>); <br>} while (dwStatus == ERROR_MORE_DATA); <br> <br>if (dwStatus != ERROR_SUCCESS) <br>{ <br>delete [] m_proplist.pb; <br>m_proplist.pb = NULL; <br>m_propCurrent.pb = NULL; <br>m_cbBufferSize = 0; <br>m_cbDataSize = 0; <br>}  // if:  error getting properties. <br>else <br>m_cbDataSize = cbProps; <br> <br>return dwStatus; <br> <br>}  //*** CClusPropList::DwGetGroupProperties() <br> <br>///////////////////////////////////////////////////////////////////////////// <br>//++ <br>// <br>//CClusPropList::DwGetResourceProperties <br>// <br>//Routine Description: <br>//Get properties on a resource. <br>// <br>//Arguments: <br>//hResource[IN] Handle for the resource to get properties from. <br>//dwControlCode[IN] Control code for the request. <br>//hHostNode[IN] Handle for the node to direct this request to. <br>//Defaults to NULL. <br>//lpInBuffer[IN] Input buffer for the request.  Defaults to NULL. <br>//cbInBufferSize[IN] Size of the input buffer.  Defaults to 0. <br>// <br>//Return Value: <br>//None. <br>// <br>//Exceptions Thrown: <br>//Any exceptions CClusPropList::AllocPropList(). <br>// <br>//-- <br>///////////////////////////////////////////////////////////////////////////// <br>DWORD CClusPropList::DwGetResourceProperties( <br>IN HRESOURCEhResource, <br>IN DWORDdwControlCode, <br>IN HNODEhHostNode, <br>IN LPVOIDlpInBuffer, <br>IN DWORDcbInBufferSize <br>) <br>{ <br>DWORDdwStatus; <br>DWORDcbProps= 256; <br> <br>ASSERT(hResource != NULL); <br>ASSERT((dwControlCode &amp; (CLUSCTL_OBJECT_MASK &lt;&lt; CLUSCTL_OBJECT_SHIFT)) <br>== (CLUS_OBJECT_RESOURCE &lt;&lt; CLUSCTL_OBJECT_SHIFT)); <br> <br>ASSERT(m_proplist.pb == NULL); <br>ASSERT(m_propCurrent.pb == NULL); <br>ASSERT(m_cbBufferSize == 0); <br>ASSERT(m_cbDataSize == 0); <br> <br>do <br>{ <br>// Allocate a default-sized buffer. <br>try <br>{ <br>AllocPropList(cbProps); <br>}  // try <br>catch (CMemoryException * pme) <br>{ <br>pme-&gt;Delete(); <br>return ERROR_NOT_ENOUGH_MEMORY; <br>}  // catch:  CMemoryException <br> <br>// Get properties. <br>dwStatus = ClusterResourceControl( <br>hResource, <br>hHostNode, <br>dwControlCode, <br>lpInBuffer, <br>cbInBufferSize, <br>m_proplist.pb, <br>m_cbBufferSize, <br>&amp;cbProps <br>); <br>} while (dwStatus == ERROR_MORE_DATA); <br> <br>if (dwStatus != ERROR_SUCCESS) <br>{ <br>delete [] m_proplist.pb; <br>m_proplist.pb = NULL; <br>m_propCurrent.pb = NULL; <br>m_cbBufferSize = 0; <br>m_cbDataSize = 0; <br>}  // if:  error getting properties. <br>else <br>m_cbDataSize = cbProps; <br> <br>return dwStatus; <br> <br>}  //*** CClusPropList::DwGetResourceProperties() <br> <br>///////////////////////////////////////////////////////////////////////////// <br>//++ <br>// <br>//CClusPropList::DwGetResourceTypeProperties <br>// <br>//Routine Description: <br>//Get properties on a resource type. <br>// <br>//Arguments: <br>//hCluster[IN] Handle for the cluster in which the resource <br>//type resides. <br>//pwszResTypeName[IN] Name of the resource type. <br>//dwControlCode[IN] Control code for the request. <br>//hHostNode[IN] Handle for the node to direct this request to. <br>//Defaults to NULL. <br>//lpInBuffer[IN] Input buffer for the request.  Defaults to NULL. <br>//cbInBufferSize[IN] Size of the input buffer.  Defaults to 0. <br>// <br>//Return Value: <br>//None. <br>// <br>//Exceptions Thrown: <br>//Any exceptions CClusPropList::AllocPropList(). <br>// <br>//-- <br>///////////////////////////////////////////////////////////////////////////// <br>DWORD CClusPropList::DwGetResourceTypeProperties( <br>IN HCLUSTERhCluster, <br>IN LPCWSTRpwszResTypeName, <br>IN DWORDdwControlCode, <br>IN HNODEhHostNode, <br>IN LPVOIDlpInBuffer, <br>IN DWORDcbInBufferSize <br>) <br>{ <br>DWORDdwStatus; <br>DWORDcbProps= 256; <br> <br>ASSERT(hCluster != NULL); <br>ASSERT(pwszResTypeName != NULL); <br>ASSERT(*pwszResTypeName != L'\0'); <br>ASSERT((dwControlCode &amp; (CLUSCTL_OBJECT_MASK &lt;&lt; CLUSCTL_OBJECT_SHIFT)) <br>== (CLUS_OBJECT_RESOURCE_TYPE &lt;&lt; CLUSCTL_OBJECT_SHIFT)); <br> <br>ASSERT(m_proplist.pb == NULL); <br>ASSERT(m_propCurrent.pb == NULL); <br>ASSERT(m_cbBufferSize == 0); <br>ASSERT(m_cbDataSize == 0); <br> <br>do <br>{ <br>// Allocate a default-sized buffer. <br>try <br>{ <br>AllocPropList(cbProps); <br>}  // try <br>catch (CMemoryException * pme) <br>{ <br>pme-&gt;Delete(); <br>return ERROR_NOT_ENOUGH_MEMORY; <br>}  // catch:  CMemoryException <br> <br>// Get properties. <br>dwStatus = ClusterResourceTypeControl( <br>hCluster, <br>pwszResTypeName, <br>hHostNode, <br>dwControlCode, <br>lpInBuffer, <br>cbInBufferSize, <br>m_proplist.pb, <br>m_cbBufferSize, <br>&amp;cbProps <br>); <br>} while (dwStatus == ERROR_MORE_DATA); <br> <br>if (dwStatus != ERROR_SUCCESS) <br>{ <br>delete [] m_proplist.pb; <br>m_proplist.pb = NULL; <br>m_propCurrent.pb = NULL; <br>m_cbBufferSize = 0; <br>m_cbDataSize = 0; <br>}  // if:  error getting properties. <br>else <br>m_cbDataSize = cbProps; <br> <br>return dwStatus; <br> <br>}  //*** CClusPropList::DwGetResourceTypeProperties() <br> <br>///////////////////////////////////////////////////////////////////////////// <br>//++ <br>// <br>//CClusPropList::DwGetNetworkProperties <br>// <br>//Routine Description: <br>//Get properties on a network. <br>// <br>//Arguments: <br>//hNetwork[IN] Handle for the network to get properties from. <br>//dwControlCode[IN] Control code for the request. <br>//hHostNode[IN] Handle for the node to direct this request to. <br>//Defaults to NULL. <br>//lpInBuffer[IN] Input buffer for the request.  Defaults to NULL. <br>//cbInBufferSize[IN] Size of the input buffer.  Defaults to 0. <br>// <br>//Return Value: <br>//None. <br>// <br>//Exceptions Thrown: <br>//Any exceptions CClusPropList::AllocPropList(). <br>// <br>//-- <br>///////////////////////////////////////////////////////////////////////////// <br>DWORD CClusPropList::DwGetNetworkProperties( <br>IN HNETWORKhNetwork, <br>IN DWORDdwControlCode, <br>IN HNODEhHostNode, <br>IN LPVOIDlpInBuffer, <br>IN DWORDcbInBufferSize <br>) <br>{ <br>DWORDdwStatus; <br>DWORDcbProps= 256; <br> <br>ASSERT(hNetwork != NULL); <br>ASSERT((dwControlCode &amp; (CLUSCTL_OBJECT_MASK &lt;&lt; CLUSCTL_OBJECT_SHIFT)) <br>== (CLUS_OBJECT_NETWORK &lt;&lt; CLUSCTL_OBJECT_SHIFT)); <br> <br>ASSERT(m_proplist.pb == NULL); <br>ASSERT(m_propCurrent.pb == NULL); <br>ASSERT(m_cbBufferSize == 0); <br>ASSERT(m_cbDataSize == 0); <br> <br>do <br>{ <br>// Allocate a default-sized buffer. <br>try <br>{ <br>AllocPropList(cbProps); <br>}  // try <br>catch (CMemoryException * pme) <br>{ <br>pme-&gt;Delete(); <br>return ERROR_NOT_ENOUGH_MEMORY; <br>}  // catch:  CMemoryException <br> <br>// Get properties. <br>dwStatus = ClusterNetworkControl( <br>hNetwork, <br>hHostNode, <br>dwControlCode, <br>lpInBuffer, <br>cbInBufferSize, <br>m_proplist.pb, <br>m_cbBufferSize, <br>&amp;cbProps <br>); <br>} while (dwStatus == ERROR_MORE_DATA); <br> <br>if (dwStatus != ERROR_SUCCESS) <br>{ <br>delete [] m_proplist.pb; <br>m_proplist.pb = NULL; <br>m_propCurrent.pb = NULL; <br>m_cbBufferSize = 0; <br>m_cbDataSize = 0; <br>}  // if:  error getting private properties. <br>else <br>m_cbDataSize = cbProps; <br> <br>return dwStatus; <br> <br>}  //*** CClusPropList::DwGetNetworkProperties() <br> <br>///////////////////////////////////////////////////////////////////////////// <br>//++ <br>// <br>//CClusPropList::DwGetNetInterfaceProperties <br>// <br>//Routine Description: <br>//Get properties on a network interface. <br>// <br>//Arguments: <br>//hNetInterface[IN] Handle for the network interface to get properties from. <br>//dwControlCode[IN] Control code for the request. <br>//hHostNode[IN] Handle for the node to direct this request to. <br>//Defaults to NULL. <br>//lpInBuffer[IN] Input buffer for the request.  Defaults to NULL. <br>//cbInBufferSize[IN] Size of the input buffer.  Defaults to 0. <br>// <br>//Return Value: <br>//None. <br>// <br>//Exceptions Thrown: <br>//Any exceptions CClusPropList::AllocPropList(). <br>// <br>//-- <br>///////////////////////////////////////////////////////////////////////////// <br>DWORD CClusPropList::DwGetNetInterfaceProperties( <br>IN HNETINTERFACEhNetInterface, <br>IN DWORDdwControlCode, <br>IN HNODEhHostNode, <br>IN LPVOIDlpInBuffer, <br>IN DWORDcbInBufferSize <br>) <br>{ <br>DWORDdwStatus; <br>DWORDcbProps= 256; <br> <br>ASSERT(hNetInterface != NULL); <br>ASSERT((dwControlCode &amp; (CLUSCTL_OBJECT_MASK &lt;&lt; CLUSCTL_OBJECT_SHIFT)) <br>== (CLUS_OBJECT_NETINTERFACE &lt;&lt; CLUSCTL_OBJECT_SHIFT)); <br> <br>ASSERT(m_proplist.pb == NULL); <br>ASSERT(m_propCurrent.pb == NULL); <br>ASSERT(m_cbBufferSize == 0); <br>ASSERT(m_cbDataSize == 0); <br> <br>do <br>{ <br>// Allocate a default-sized buffer. <br>try <br>{ <br>AllocPropList(cbProps); <br>}  // try <br>catch (CMemoryException * pme) <br>{ <br>pme-&gt;Delete(); <br>return ERROR_NOT_ENOUGH_MEMORY; <br>}  // catch:  CMemoryException <br> <br>// Get properties. <br>dwStatus = ClusterNetInterfaceControl( <br>hNetInterface, <br>hHostNode, <br>dwControlCode, <br>lpInBuffer, <br>cbInBufferSize, <br>m_proplist.pb, <br>m_cbBufferSize, <br>&amp;cbProps <br>); <br>} while (dwStatus == ERROR_MORE_DATA); <br> <br>if (dwStatus != ERROR_SUCCESS) <br>{ <br>delete [] m_proplist.pb; <br>m_proplist.pb = NULL; <br>m_propCurrent.pb = NULL; <br>m_cbBufferSize = 0; <br>m_cbDataSize = 0; <br>}  // if:  error getting private properties. <br>else <br>m_cbDataSize = cbProps; <br> <br>return dwStatus; <br> <br>}  //*** CClusPropList::DwGetNetInterfaceProperties() </code></pre>
<p>&nbsp;</p></body>
</HTML>
