<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SMBSMP.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5954"></a>SMBSMP.C</h2>
<pre><code>/*++ <br> <br>Copyright (c) 1997 &lt;company name&gt; <br> <br>Module Name: <br> <br>    SmbSmp.c <br> <br>Abstract: <br> <br>    Resource DLL for SMB Sample (SmbSmp). <br> <br>Author: <br> <br>    &lt;user&gt; (&lt;email-name&gt;) Mmmm DD, 1997 <br> <br>Revision History: <br> <br>--*/ <br> <br>#pragma comment(lib, "clusapi.lib") <br>#pragma comment(lib, "resutils.lib") <br>#pragma comment(lib, "advapi32.lib") <br>#pragma comment(lib, "netapi32.lib") <br> <br>#define UNICODE 1 <br> <br>#pragma warning( disable : 4115 )  // named type definition in parentheses <br>#pragma warning( disable : 4201 )  // nonstandard extension used : nameless struct/union <br>#pragma warning( disable : 4214 )  // nonstandard extension used : bit field types other than int <br> <br>#include &lt;windows.h&gt; <br> <br>#pragma warning( default : 4214 )  // nonstandard extension used : bit field types other than int <br>#pragma warning( default : 4201 )  // nonstandard extension used : nameless struct/union <br>#pragma warning( default : 4115 )  // named type definition in parentheses <br> <br>#include &lt;clusapi.h&gt; <br>#include &lt;resapi.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;lm.h&gt; <br>#include &lt;lmerr.h&gt; <br> <br>// <br>// Type and constant definitions. <br>// <br> <br>#define SMBSMP_RESNAME  L"SMB Sample" <br>#define SMBSMP_SVCNAME  TEXT("LanmanServer") <br> <br>#define DBG_PRINT printf <br> <br>// ADDPARAM: Add new parameters here. <br>#define PARAM_NAME__SHARENAME L"ShareName" <br>#define PARAM_NAME__PATH L"Path" <br>#define PARAM_NAME__REMARK L"Remark" <br> <br> <br>// ADDPARAM: Add new parameters here. <br>typedef struct _SMBSMP_PARAMS { <br>    PWSTR           ShareName; <br>    PWSTR           Path; <br>    PWSTR           Remark; <br>} SMBSMP_PARAMS, *PSMBSMP_PARAMS; <br> <br>typedef struct _SMBSMP_RESOURCE { <br>    RESID                   ResId; // for validation <br>    SMBSMP_PARAMS         Params; <br>    HKEY                    ParametersKey; <br>    RESOURCE_HANDLE         ResourceHandle; <br>    LPWSTR                  ResourceName; <br>    CLUS_WORKER             OnlineThread; <br>    CLUSTER_RESOURCE_STATE  State; <br>} SMBSMP_RESOURCE, *PSMBSMP_RESOURCE; <br> <br> <br>// <br>// Global data. <br>// <br> <br>// Event Logging routine. <br> <br>PLOG_EVENT_ROUTINE g_LogEvent = NULL; <br> <br>// Resource Status routine for pending Online and Offline calls. <br> <br>PSET_RESOURCE_STATUS_ROUTINE g_SetResourceStatus = NULL; <br> <br>// Forward reference to our RESAPI function table. <br> <br>extern CLRES_FUNCTION_TABLE g_SmbSmpFunctionTable; <br> <br>// <br>// SMB Sample resource read-write private properties. <br>// <br>RESUTIL_PROPERTY_ITEM <br>SmbSmpResourcePrivateProperties[] = { <br>    { PARAM_NAME__SHARENAME, NULL, CLUSPROP_FORMAT_SZ, 0, 0, 0, RESUTIL_PROPITEM_REQUIRED, FIELD_OFFSET(SMBSMP_PARAMS,ShareName) }, <br>    { PARAM_NAME__PATH, NULL, CLUSPROP_FORMAT_SZ, 0, 0, 0, RESUTIL_PROPITEM_REQUIRED, FIELD_OFFSET(SMBSMP_PARAMS,Path) }, <br>    { PARAM_NAME__REMARK, NULL, CLUSPROP_FORMAT_SZ, 0, 0, 0, 0, FIELD_OFFSET(SMBSMP_PARAMS,Remark) }, <br>    { 0 } <br>}; <br> <br> <br>// <br>// Function prototypes. <br>// <br> <br>DWORD <br>WINAPI <br>Startup( <br>    IN LPCWSTR ResourceType, <br>    IN DWORD MinVersionSupported, <br>    IN DWORD MaxVersionSupported, <br>    IN PSET_RESOURCE_STATUS_ROUTINE SetResourceStatus, <br>    IN PLOG_EVENT_ROUTINE LogEvent, <br>    OUT PCLRES_FUNCTION_TABLE *FunctionTable <br>    ); <br> <br>RESID <br>WINAPI <br>SmbSmpOpen( <br>    IN LPCWSTR ResourceName, <br>    IN HKEY ResourceKey, <br>    IN RESOURCE_HANDLE ResourceHandle <br>    ); <br> <br>VOID <br>WINAPI <br>SmbSmpClose( <br>    IN RESID ResourceId <br>    ); <br> <br>DWORD <br>WINAPI <br>SmbSmpOnline( <br>    IN RESID ResourceId, <br>    IN OUT PHANDLE EventHandle <br>    ); <br> <br>DWORD <br>WINAPI <br>SmbSmpOnlineThread( <br>    PCLUS_WORKER WorkerPtr, <br>    IN PSMBSMP_RESOURCE ResourceEntry <br>    ); <br> <br>DWORD <br>WINAPI <br>SmbSmpOffline( <br>    IN RESID ResourceId <br>    ); <br> <br>VOID <br>WINAPI <br>SmbSmpTerminate( <br>    IN RESID ResourceId <br>    ); <br> <br>DWORD <br>SmbSmpDoTerminate( <br>    IN PSMBSMP_RESOURCE ResourceEntry <br>    ); <br> <br>BOOL <br>WINAPI <br>SmbSmpLooksAlive( <br>    IN RESID ResourceId <br>    ); <br> <br>BOOL <br>WINAPI <br>SmbSmpIsAlive( <br>    IN RESID ResourceId <br>    ); <br> <br>BOOL <br>SmbSmpCheckIsAlive( <br>    IN PSMBSMP_RESOURCE ResourceEntry <br>    ); <br> <br>DWORD <br>WINAPI <br>SmbSmpResourceControl( <br>    IN RESID ResourceId, <br>    IN DWORD ControlCode, <br>    IN PVOID InBuffer, <br>    IN DWORD InBufferSize, <br>    OUT PVOID OutBuffer, <br>    IN DWORD OutBufferSize, <br>    OUT LPDWORD BytesReturned <br>    ); <br> <br>DWORD <br>SmbSmpGetPrivateResProperties( <br>    IN OUT PSMBSMP_RESOURCE ResourceEntry, <br>    OUT PVOID OutBuffer, <br>    IN DWORD OutBufferSize, <br>    OUT LPDWORD BytesReturned <br>    ); <br> <br>DWORD <br>SmbSmpValidatePrivateResProperties( <br>    IN OUT PSMBSMP_RESOURCE ResourceEntry, <br>    IN const PVOID InBuffer, <br>    IN DWORD InBufferSize, <br>    OUT PSMBSMP_PARAMS Params <br>    ); <br> <br>DWORD <br>SmbSmpSetPrivateResProperties( <br>    IN OUT PSMBSMP_RESOURCE ResourceEntry, <br>    IN const PVOID InBuffer, <br>    IN DWORD InBufferSize <br>    ); <br>  <br>BOOLEAN <br>WINAPI <br>DllMain( <br>    IN HINSTANCE    DllHandle, <br>    IN DWORD        Reason, <br>    IN LPVOID       Reserved <br>    ) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    Main DLL entry point. <br> <br>Arguments: <br> <br>    DllHandle - DLL instance handle. <br> <br>    Reason - Reason for being called. <br> <br>    Reserved - Reserved argument. <br> <br>Return Value: <br> <br>    TRUE - Success. <br> <br>    FALSE - Failure. <br> <br>--*/ <br> <br>{ <br>    switch( Reason ) { <br> <br>    case DLL_PROCESS_ATTACH: <br>        DisableThreadLibraryCalls( DllHandle ); <br>        break; <br> <br>    case DLL_PROCESS_DETACH: <br>        break; <br>    } <br> <br>    return(TRUE); <br> <br>} // DllMain <br> <br> <br>  <br>DWORD <br>WINAPI <br>Startup( <br>    IN LPCWSTR ResourceType, <br>    IN DWORD MinVersionSupported, <br>    IN DWORD MaxVersionSupported, <br>    IN PSET_RESOURCE_STATUS_ROUTINE SetResourceStatus, <br>    IN PLOG_EVENT_ROUTINE LogEvent, <br>    OUT PCLRES_FUNCTION_TABLE *FunctionTable <br>    ) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    Startup the resource DLL. This routine verifies that at least one <br>    currently supported version of the resource DLL is between <br>    MinVersionSupported and MaxVersionSupported. If not, then the resource <br>    DLL should return ERROR_REVISION_MISMATCH. <br> <br>    If more than one version of the resource DLL interface is supported by <br>    the resource DLL, then the highest version (up to MaxVersionSupported) <br>    should be returned as the resource DLL's interface. If the returned <br>    version is not within range, then startup fails. <br> <br>    The ResourceType is passed in so that if the resource DLL supports more <br>    than one ResourceType, it can pass back the correct function table <br>    associated with the ResourceType. <br> <br>Arguments: <br> <br>    ResourceType - The type of resource requesting a function table. <br> <br>    MinVersionSupported - The minimum resource DLL interface version  <br>        supported by the cluster software. <br> <br>    MaxVersionSupported - The maximum resource DLL interface version <br>        supported by the cluster software. <br> <br>    SetResourceStatus - Pointer to a routine that the resource DLL should  <br>        call to update the state of a resource after the Online or Offline  <br>        routine returns a status of ERROR_IO_PENDING. <br> <br>    LogEvent - Pointer to a routine that handles the reporting of events  <br>        from the resource DLL.  <br> <br>    FunctionTable - Returns a pointer to the function table defined for the <br>        version of the resource DLL interface returned by the resource DLL. <br> <br>Return Value: <br> <br>    ERROR_SUCCESS - The operation was successful. <br> <br>    ERROR_MOD_NOT_FOUND - The resource type is unknown by this DLL. <br> <br>    ERROR_REVISION_MISMATCH - The version of the cluster service doesn't <br>        match the versrion of the DLL. <br> <br>    Win32 error code - The operation failed. <br> <br>--*/ <br> <br>{ <br>    if ( (MinVersionSupported &gt; CLRES_VERSION_V1_00) || <br>         (MaxVersionSupported &lt; CLRES_VERSION_V1_00) ) { <br>        return(ERROR_REVISION_MISMATCH); <br>    } <br> <br>    if ( lstrcmpiW( ResourceType, SMBSMP_RESNAME ) != 0 ) { <br>        return(ERROR_MOD_NOT_FOUND); <br>    } <br> <br>    if ( !g_LogEvent ) { <br>        g_LogEvent = LogEvent; <br>        g_SetResourceStatus = SetResourceStatus; <br>    } <br> <br>    *FunctionTable = &amp;g_SmbSmpFunctionTable; <br> <br>    return(ERROR_SUCCESS); <br> <br>} // Startup <br> <br>  <br>RESID <br>WINAPI <br>SmbSmpOpen( <br>    IN LPCWSTR ResourceName, <br>    IN HKEY ResourceKey, <br>    IN RESOURCE_HANDLE ResourceHandle <br>    ) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    Open routine for SMB Sample resources. <br> <br>    Open the specified resource (create an instance of the resource).  <br>    Allocate all structures necessary to bring the specified resource  <br>    online. <br> <br>Arguments: <br> <br>    ResourceName - Supplies the name of the resource to open. <br> <br>    ResourceKey - Supplies handle to the resource's cluster configuration  <br>        database key. <br> <br>    ResourceHandle - A handle that is passed back to the resource monitor  <br>        when the SetResourceStatus or LogEvent method is called. See the  <br>        description of the SetResourceStatus and LogEvent methods on the <br>        SmbSmpStatup routine. This handle should never be closed or used <br>        for any purpose other than passing it as an argument back to the <br>        Resource Monitor in the SetResourceStatus or LogEvent callback. <br> <br>Return Value: <br> <br>    RESID of created resource. <br> <br>    NULL on failure. <br> <br>--*/ <br> <br>{ <br>    DWORD               status; <br>    DWORD               disposition; <br>    RESID               resid = 0; <br>    HKEY                parametersKey = NULL; <br>    PSMBSMP_RESOURCE resourceEntry = NULL; <br> <br>    // <br>    // Open the Parameters registry key for this resource. <br>    // <br> <br>    status = ClusterRegCreateKey( ResourceKey, <br>                                  L"Parameters", <br>                                  0, <br>                                  KEY_ALL_ACCESS, <br>                                  NULL, <br>                                  &amp;parametersKey, <br>                                  &amp;disposition ); <br> <br>    if ( status != ERROR_SUCCESS ) { <br>        (g_LogEvent)( <br>            ResourceHandle, <br>            LOG_ERROR, <br>            L"Unable to open Parameters key. Error: %1!u!.\n", <br>            status ); <br>        goto exit; <br>    } <br> <br>    // <br>    // Allocate a resource entry. <br>    // <br> <br>    resourceEntry = (PSMBSMP_RESOURCE) LocalAlloc( LMEM_FIXED, sizeof(SMBSMP_RESOURCE) ); <br> <br>    if ( resourceEntry == NULL ) { <br>        status = GetLastError(); <br>        (g_LogEvent)( <br>            ResourceHandle, <br>            LOG_ERROR, <br>            L"Unable to allocate resource entry structure. Error: %1!u!.\n", <br>            status ); <br>        goto exit; <br>    } <br> <br>    // <br>    // Initialize the resource entry.. <br>    // <br> <br>    ZeroMemory( resourceEntry, sizeof(SMBSMP_RESOURCE) ); <br> <br>    resourceEntry-&gt;ResId = (RESID)resourceEntry; // for validation <br>    resourceEntry-&gt;ResourceHandle = ResourceHandle; <br>    resourceEntry-&gt;ParametersKey = parametersKey; <br>    resourceEntry-&gt;State = ClusterResourceOffline; <br> <br>    // <br>    // Save the name of the resource. <br>    // <br>    resourceEntry-&gt;ResourceName = LocalAlloc( LMEM_FIXED, (lstrlenW( ResourceName ) + 1) * sizeof(WCHAR) ); <br>    if ( resourceEntry-&gt;ResourceName == NULL ) { <br>        goto exit; <br>    } <br>    lstrcpyW( resourceEntry-&gt;ResourceName, ResourceName ); <br> <br>    // <br>    // Startup for the resource. <br>    // <br>    // TODO: Add your resource startup code here. <br> <br> <br>    resid = (RESID)resourceEntry; <br> <br>exit: <br> <br>    if ( resid == 0 ) { <br>        if ( parametersKey != NULL ) { <br>            ClusterRegCloseKey( parametersKey ); <br>        } <br>        if ( resourceEntry != NULL ) { <br>            LocalFree( resourceEntry-&gt;ResourceName ); <br>            LocalFree( resourceEntry ); <br>        } <br>    } <br> <br>    if ( status != ERROR_SUCCESS ) { <br>        SetLastError( status ); <br>    } <br> <br>    return(resid); <br> <br>} // SmbSmpOpen <br> <br> <br>  <br>VOID <br>WINAPI <br>SmbSmpClose( <br>    IN RESID ResourceId <br>    ) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    Close routine for SMB Sample resources. <br> <br>    Close the specified resource and deallocate all structures, etc., <br>    allocated in the Open call. If the resource is not in the offline state, <br>    then the resource should be taken offline (by calling Terminate) before <br>    the close operation is performed. <br> <br>Arguments: <br> <br>    ResourceId - Supplies the RESID of the resource to close. <br> <br>Return Value: <br> <br>    None. <br> <br>--*/ <br> <br>{ <br>    PSMBSMP_RESOURCE resourceEntry; <br> <br>    resourceEntry = (PSMBSMP_RESOURCE)ResourceId; <br> <br>    if ( resourceEntry == NULL ) { <br>        DBG_PRINT( "SmbSmp: Close request for a nonexistent resource id %u\n", <br>                   ResourceId ); <br>        return; <br>    } <br> <br>    if ( resourceEntry-&gt;ResId != ResourceId ) { <br>        (g_LogEvent)( <br>            resourceEntry-&gt;ResourceHandle, <br>            LOG_ERROR, <br>            L"Close resource sanity check failed! ResourceId = %1!u!.\n", <br>            ResourceId ); <br>        return; <br>    } <br> <br>#ifdef LOG_VERBOSE <br>    (g_LogEvent)( <br>        resourceEntry-&gt;ResourceHandle, <br>        LOG_INFORMATION, <br>        L"Close request.\n" ); <br>#endif <br> <br>    // <br>    // Close the Parameters key. <br>    // <br> <br>    if ( resourceEntry-&gt;ParametersKey ) { <br>        ClusterRegCloseKey( resourceEntry-&gt;ParametersKey ); <br>    } <br> <br>    // <br>    // Deallocate the resource entry. <br>    // <br> <br>    // ADDPARAM: Add new parameters here. <br>    LocalFree( resourceEntry-&gt;Params.ShareName ); <br>    LocalFree( resourceEntry-&gt;Params.Path ); <br>    LocalFree( resourceEntry-&gt;Params.Remark ); <br> <br>    LocalFree( resourceEntry-&gt;ResourceName ); <br>    LocalFree( resourceEntry ); <br> <br>} // SmbSmpClose <br> <br> <br>  <br>DWORD <br>WINAPI <br>SmbSmpOnline( <br>    IN RESID ResourceId, <br>    IN OUT PHANDLE EventHandle <br>    ) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    Online routine for SMB Sample resources. <br> <br>    Bring the specified resource online (available for use). The resource <br>    DLL should attempt to arbitrate for the resource if it is present on a <br>    shared medium, like a shared SCSI bus. <br> <br>Arguments: <br> <br>    ResourceId - Supplies the resource id for the resource to be brought  <br>        online (available for use). <br> <br>    EventHandle - Returns a signalable handle that is signaled when the  <br>        resource DLL detects a failure on the resource. This argument is  <br>        NULL on input, and the resource DLL returns NULL if asynchronous  <br>        notification of failures is not supported, otherwise this must be  <br>        the address of a handle that is signaled on resource failures. <br> <br>Return Value: <br> <br>    ERROR_SUCCESS - The operation was successful, and the resource is now  <br>        online. <br> <br>    ERROR_RESOURCE_NOT_FOUND - RESID is not valid. <br> <br>    ERROR_RESOURCE_NOT_AVAILABLE - If the resource was arbitrated with some  <br>        other systems and one of the other systems won the arbitration. <br> <br>    ERROR_IO_PENDING - The request is pending, a thread has been activated  <br>        to process the online request. The thread that is processing the  <br>        online request will periodically report status by calling the  <br>        SetResourceStatus callback method, until the resource is placed into  <br>        the ClusterResourceOnline state (or the resource monitor decides to  <br>        timeout the online request and Terminate the resource. This pending  <br>        timeout value is settable and has a default value of 3 minutes.). <br> <br>    Win32 error code - The operation failed. <br> <br>--*/ <br> <br>{ <br>    PSMBSMP_RESOURCE resourceEntry = NULL; <br>    DWORD               status; <br> <br>    resourceEntry = (PSMBSMP_RESOURCE)ResourceId; <br> <br>    if ( resourceEntry == NULL ) { <br>        DBG_PRINT( "SmbSmp: Online request for a nonexistent resource id %u.\n", <br>                   ResourceId ); <br>        return(ERROR_RESOURCE_NOT_FOUND); <br>    } <br> <br>    if ( resourceEntry-&gt;ResId != ResourceId ) { <br>        (g_LogEvent)( <br>            resourceEntry-&gt;ResourceHandle, <br>            LOG_ERROR, <br>            L"Online service sanity check failed! ResourceId = %1!u!.\n", <br>            ResourceId ); <br>        return(ERROR_RESOURCE_NOT_FOUND); <br>    } <br> <br>#ifdef LOG_VERBOSE <br>    (g_LogEvent)( <br>        resourceEntry-&gt;ResourceHandle, <br>        LOG_INFORMATION, <br>        L"Online request.\n" ); <br>#endif <br> <br>    resourceEntry-&gt;State = ClusterResourceOffline; <br>    ClusWorkerTerminate( &amp;resourceEntry-&gt;OnlineThread ); <br>    status = ClusWorkerCreate( &amp;resourceEntry-&gt;OnlineThread, <br>                               SmbSmpOnlineThread, <br>                               resourceEntry ); <br>    if ( status != ERROR_SUCCESS ) { <br>        resourceEntry-&gt;State = ClusterResourceFailed; <br>        (g_LogEvent)( <br>            resourceEntry-&gt;ResourceHandle, <br>            LOG_ERROR, <br>            L"Online: Unable to start thread, status %1!u!.\n", <br>            status <br>            ); <br>    } else { <br>        status = ERROR_IO_PENDING; <br>    } <br> <br>    return(status); <br> <br>} // SmbSmpOnline <br> <br> <br>  <br>DWORD <br>WINAPI <br>SmbSmpOnlineThread( <br>    PCLUS_WORKER WorkerPtr, <br>    IN PSMBSMP_RESOURCE ResourceEntry <br>    ) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    Worker function which brings a resource from the resource table online. <br>    This function is executed in a separate thread. <br> <br>Arguments: <br> <br>    WorkerPtr - Supplies the worker structure <br> <br>    ResourceEntry - A pointer to the SMBSMP_RESOURCE block for this resource. <br> <br>Returns: <br> <br>    ERROR_SUCCESS - The operation completed successfully. <br>     <br>    Win32 error code - The operation failed. <br> <br>--*/ <br> <br>{ <br>    RESOURCE_STATUS     resourceStatus; <br>    DWORD               status; <br>    LPWSTR              nameOfPropInError; <br>    SHARE_INFO_2        shareInfo; <br> <br>    resourceStatus.ResourceState = ClusterResourceFailed; <br>    resourceStatus.WaitHint = 0; <br>    resourceStatus.CheckPoint = 1; <br> <br>    // <br>    // Read parameters. <br>    // <br>    status = ResUtilGetPropertiesToParameterBlock( ResourceEntry-&gt;ParametersKey, <br>                                                   SmbSmpResourcePrivateProperties, <br>                                                   (LPBYTE) &amp;ResourceEntry-&gt;Params, <br>                                                   TRUE, // CheckForRequiredProperties <br>                                                   &amp;nameOfPropInError ); <br>    if ( status != ERROR_SUCCESS ) { <br>        (g_LogEvent)( <br>            ResourceEntry-&gt;ResourceHandle, <br>            LOG_ERROR, <br>            L"Unable to read the '%1' property. Error: %2!u!.\n", <br>            (nameOfPropInError == NULL ? L"" : nameOfPropInError), <br>            status ); <br>        goto exit; <br>    } <br> <br>    // <br>    // Start the SmbSmp service <br>    // <br>    status = ResUtilStartResourceService( SMBSMP_SVCNAME, NULL ); <br>    if ( status == ERROR_SERVICE_ALREADY_RUNNING ) { <br>        status = ERROR_SUCCESS; <br>    } else if ( status != ERROR_SUCCESS ) { <br>        goto exit; <br>    } <br> <br>    // <br>    // Bring the resource online. <br>    // <br>    // TODO: Add code to bring your resource online. <br>    if ( status == ERROR_SUCCESS ) { <br>        shareInfo.shi2_netname =      ResourceEntry-&gt;Params.ShareName; <br>        shareInfo.shi2_type =         STYPE_DISKTREE; <br>        shareInfo.shi2_remark =       ResourceEntry-&gt;Params.Remark; <br>        shareInfo.shi2_permissions =  ACCESS_ALL; <br>        shareInfo.shi2_max_uses =     (DWORD)-1; <br>        shareInfo.shi2_current_uses = 0; <br>        shareInfo.shi2_path =         ResourceEntry-&gt;Params.Path; <br>        shareInfo.shi2_passwd =       NULL; <br> <br>        status = NetShareAdd( NULL, 2, (PBYTE)&amp;shareInfo, NULL ); <br>        if ( status != ERROR_SUCCESS ) { <br>            (g_LogEvent)( <br>                ResourceEntry-&gt;ResourceHandle, <br>                LOG_ERROR, <br>                L"Error creating share '%1'. Error: %2!u!.\n", <br>                ResourceEntry-&gt;Params.ShareName, <br>                status ); <br>            goto exit; <br>        } <br>    } <br> <br>exit: <br>    if ( status != ERROR_SUCCESS ) { <br>        (g_LogEvent)( <br>            ResourceEntry-&gt;ResourceHandle, <br>            LOG_ERROR, <br>            L"Error %1!u! bringing resource online.\n", <br>            status ); <br>    } else { <br>        resourceStatus.ResourceState = ClusterResourceOnline; <br>    } <br> <br>    // _ASSERTE(g_SetResourceStatus != NULL); <br>    g_SetResourceStatus( ResourceEntry-&gt;ResourceHandle, &amp;resourceStatus ); <br>    ResourceEntry-&gt;State = resourceStatus.ResourceState; <br> <br>    return(status); <br> <br>} // SmbSmpOnlineThread <br> <br> <br>  <br>DWORD <br>WINAPI <br>SmbSmpOffline( <br>    IN RESID ResourceId <br>    ) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    Offline routine for SMB Sample resources. <br> <br>    Take the specified resource offline gracefully (unavailable for use).   <br>    Wait for any cleanup operations to complete before returning. <br> <br>Arguments: <br> <br>    ResourceId - Supplies the resource id for the resource to be shutdown  <br>        gracefully. <br> <br>Return Value: <br> <br>    ERROR_SUCCESS - The request completed successfully and the resource is  <br>        offline. <br> <br>    ERROR_RESOURCE_NOT_FOUND - RESID is not valid. <br> <br>    ERROR_IO_PENDING - The request is still pending, a thread has been  <br>        activated to process the offline request. The thread that is  <br>        processing the offline will periodically report status by calling  <br>        the SetResourceStatus callback method, until the resource is placed  <br>        into the ClusterResourceOffline state (or the resource monitor decides  <br>        to timeout the offline request and Terminate the resource). <br>     <br>    Win32 error code - Will cause the resource monitor to log an event and  <br>        call the Terminate routine. <br> <br>--*/ <br> <br>{ <br>    PSMBSMP_RESOURCE resourceEntry; <br> <br>    resourceEntry = (PSMBSMP_RESOURCE)ResourceId; <br> <br>    if ( resourceEntry == NULL ) { <br>        DBG_PRINT( "SmbSmp: Offline request for a nonexistent resource id %u\n", <br>            ResourceId ); <br>        return(ERROR_RESOURCE_NOT_FOUND); <br>    } <br> <br>    if ( resourceEntry-&gt;ResId != ResourceId ) { <br>        (g_LogEvent)( <br>            resourceEntry-&gt;ResourceHandle, <br>            LOG_ERROR, <br>            L"Offline resource sanity check failed! ResourceId = %1!u!.\n", <br>            ResourceId ); <br>        return(ERROR_RESOURCE_NOT_FOUND); <br>    } <br> <br>#ifdef LOG_VERBOSE <br>    (g_LogEvent)( <br>        resourceEntry-&gt;ResourceHandle, <br>        LOG_INFORMATION, <br>        L"Offline request.\n" ); <br>#endif <br> <br>    // TODO: Offline code <br> <br>    // NOTE: Offline should try to shut the resource down gracefully, whereas <br>    // Terminate must shut the resource down immediately. If there are no <br>    // differences between a graceful shut down and an immediate shut down, <br>    // Terminate can be called for Offline, as it is below.  However, if there <br>    // are differences, replace the call to Terminate below with your graceful <br>    // shutdown code. <br> <br>    // <br>    // Terminate the resource. <br>    // <br>    return SmbSmpDoTerminate( resourceEntry ); <br> <br>} // SmbSmpOffline <br> <br> <br>  <br>VOID <br>WINAPI <br>SmbSmpTerminate( <br>    IN RESID ResourceId <br>    ) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    Terminate routine for SMB Sample resources. <br> <br>    Take the specified resource offline immediately (the resource is <br>    unavailable for use). <br> <br>Arguments: <br> <br>    ResourceId - Supplies the resource id for the resource to be brought  <br>        offline. <br> <br>Return Value: <br> <br>    None. <br> <br>--*/ <br> <br>{ <br>    PSMBSMP_RESOURCE resourceEntry; <br> <br>    resourceEntry = (PSMBSMP_RESOURCE)ResourceId; <br> <br>    if ( resourceEntry == NULL ) { <br>        DBG_PRINT( "SmbSmp: Terminate request for a nonexistent resource id %u\n", <br>            ResourceId ); <br>        return; <br>    } <br> <br>    if ( resourceEntry-&gt;ResId != ResourceId ) { <br>        (g_LogEvent)( <br>            resourceEntry-&gt;ResourceHandle, <br>            LOG_ERROR, <br>            L"Terminate resource sanity check failed! ResourceId = %1!u!.\n", <br>            ResourceId ); <br>        return; <br>    } <br> <br>#ifdef LOG_VERBOSE <br>    (g_LogEvent)( <br>        resourceEntry-&gt;ResourceHandle, <br>        LOG_INFORMATION, <br>        L"Terminate request.\n" ); <br>#endif <br> <br>    // <br>    // Terminate the resource. <br>    // <br>    SmbSmpDoTerminate( resourceEntry ); <br>    resourceEntry-&gt;State = ClusterResourceOffline; <br> <br>} // SmbSmpTerminate <br> <br> <br>  <br>DWORD <br>SmbSmpDoTerminate( <br>    IN PSMBSMP_RESOURCE ResourceEntry <br>    ) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    Do the actual Terminate work for SMB Sample resources. <br> <br>Arguments: <br> <br>    ResourceEntry - Supplies resource entry for resource to be terminated <br> <br>Return Value: <br> <br>    ERROR_SUCCESS - The request completed successfully and the resource is  <br>        offline. <br> <br>    Win32 error code - Will cause the resource monitor to log an event and  <br>        call the Terminate routine. <br> <br>--*/ <br> <br>{ <br>    DWORD       status = ERROR_SUCCESS; <br> <br>    // <br>    // Kill off any pending threads. <br>    // <br>    ClusWorkerTerminate( &amp;ResourceEntry-&gt;OnlineThread ); <br> <br>    // <br>    // Terminate the resource. <br>    // <br>    // TODO: Add code to terminate your resource. <br>    status = NetShareDel( NULL, ResourceEntry-&gt;Params.ShareName, 0 ); <br> <br>    if ( status != NO_ERROR ) { <br>        (g_LogEvent)( <br>            ResourceEntry-&gt;ResourceHandle, <br>            LOG_ERROR, <br>            L"Error removing share '%1'. Error %2!u!.\n", <br>            ResourceEntry-&gt;Params.ShareName, <br>            status ); <br>    } else { <br>        ResourceEntry-&gt;State = ClusterResourceOffline; <br>    } <br> <br>    return(status); <br> <br>} // SmbSmpDoTerminate <br> <br> <br>  <br>BOOL <br>WINAPI <br>SmbSmpLooksAlive( <br>    IN RESID ResourceId <br>    ) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    LooksAlive routine for SMB Sample resources. <br> <br>    Perform a quick check to determine if the specified resource is probably <br>    online (available for use).  This call should not block for more than <br>    300 ms, preferably less than 50 ms. <br> <br>Arguments: <br> <br>    ResourceId - Supplies the resource id for the resource to polled. <br> <br>Return Value: <br> <br>    TRUE - The specified resource is probably online and available for use. <br> <br>    FALSE - The specified resource is not functioning normally. <br> <br>--*/ <br> <br>{ <br>    PSMBSMP_RESOURCE  resourceEntry; <br> <br>    resourceEntry = (PSMBSMP_RESOURCE)ResourceId; <br> <br>    if ( resourceEntry == NULL ) { <br>        DBG_PRINT("SmbSmp: LooksAlive request for a nonexistent resource id %u\n", <br>            ResourceId ); <br>        return(FALSE); <br>    } <br> <br>    if ( resourceEntry-&gt;ResId != ResourceId ) { <br>        (g_LogEvent)( <br>            resourceEntry-&gt;ResourceHandle, <br>            LOG_ERROR, <br>            L"LooksAlive sanity check failed! ResourceId = %1!u!.\n", <br>            ResourceId ); <br>        return(FALSE); <br>    } <br> <br>#ifdef LOG_VERBOSE <br>    (g_LogEvent)( <br>        resourceEntry-&gt;ResourceHandle, <br>        LOG_INFORMATION, <br>        L"LooksAlive request.\n" ); <br>#endif <br> <br>    // TODO: LooksAlive code <br> <br>    // NOTE: LooksAlive should be a quick check to see if the resource is <br>    // available or not, whereas IsAlive should be a thorough check.  If <br>    // there are no differences between a quick check and a thorough check, <br>    // IsAlive can be called for LooksAlive, as it is below.  However, if there <br>    // are differences, replace the call to IsAlive below with your quick <br>    // check code. <br> <br>    // <br>    // Check to see if the resource is alive. <br>    // <br>    return(SmbSmpCheckIsAlive( resourceEntry )); <br> <br>} // SmbSmpLooksAlive <br> <br> <br>  <br>BOOL <br>WINAPI <br>SmbSmpIsAlive( <br>    IN RESID ResourceId <br>    ) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    IsAlive routine for SMB Sample resources. <br> <br>    Perform a thorough check to determine if the specified resource is online <br>    (available for use). This call should not block for more than 400 ms, <br>    preferably less than 100 ms. <br> <br>Arguments: <br> <br>    ResourceId - Supplies the resource id for the resource to polled. <br> <br>Return Value: <br> <br>    TRUE - The specified resource is online and functioning normally. <br> <br>    FALSE - The specified resource is not functioning normally. <br> <br>--*/ <br> <br>{ <br>    PSMBSMP_RESOURCE  resourceEntry; <br> <br>    resourceEntry = (PSMBSMP_RESOURCE)ResourceId; <br> <br>    if ( resourceEntry == NULL ) { <br>        DBG_PRINT("SmbSmp: IsAlive request for a nonexistent resource id %u\n", <br>            ResourceId ); <br>        return(FALSE); <br>    } <br> <br>    if ( resourceEntry-&gt;ResId != ResourceId ) { <br>        (g_LogEvent)( <br>            resourceEntry-&gt;ResourceHandle, <br>            LOG_ERROR, <br>            L"IsAlive sanity check failed! ResourceId = %1!u!.\n", <br>            ResourceId ); <br>        return(FALSE); <br>    } <br> <br>#ifdef LOG_VERBOSE <br>    (g_LogEvent)( <br>        resourceEntry-&gt;ResourceHandle, <br>        LOG_INFORMATION, <br>        L"IsAlive request.\n" ); <br>#endif <br> <br>    // <br>    // Check to see if the resource is alive. <br>    // <br>    return(SmbSmpCheckIsAlive( resourceEntry )); <br> <br>} // SmbSmpIsAlive <br> <br> <br>  <br>BOOL <br>SmbSmpCheckIsAlive( <br>    IN PSMBSMP_RESOURCE ResourceEntry <br>    ) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    Check to see if the resource is alive for SMB Sample resources. <br> <br>Arguments: <br> <br>    ResourceEntry - Supplies the resource entry for the resource to polled. <br> <br>Return Value: <br> <br>    TRUE - The specified resource is online and functioning normally. <br> <br>    FALSE - The specified resource is not functioning normally. </code></pre>
<p>
</p>
<pre><code><br>--*/ <br> <br>{ <br>    SHARE_INFO_2        shareInfo; <br>    DWORD               status; <br> <br>    // <br>    // Check to see if the resource is alive. <br>    // <br>    // TODO: Add code to determine if your resource is alive. <br>    status = NetShareGetInfo( NULL, <br>                              ResourceEntry-&gt;Params.ShareName, <br>                              2, // return a SHARE_INFO_2 structure <br>                              (LPBYTE *) &amp;shareInfo ); <br> <br>    if ( status == NERR_NetNameNotFound ) { <br>        (g_LogEvent)( <br>            ResourceEntry-&gt;ResourceHandle, <br>            LOG_ERROR, <br>            L"Error, share '%1' went away.\n", <br>            ResourceEntry-&gt;Params.ShareName ); <br>        return(FALSE); <br>    } else if ( status != ERROR_SUCCESS ) { <br>        (g_LogEvent)( <br>            ResourceEntry-&gt;ResourceHandle, <br>            LOG_ERROR, <br>            L"Error checking for share '%1'. Error %2!u!.\n", <br>            ResourceEntry-&gt;Params.ShareName, <br>            status ); <br>    } <br> <br>    return(TRUE); <br> <br>} // SmbSmpCheckIsAlive <br> <br> <br>  <br>DWORD <br>WINAPI <br>SmbSmpResourceControl( <br>    IN RESID ResourceId, <br>    IN DWORD ControlCode, <br>    IN PVOID InBuffer, <br>    IN DWORD InBufferSize, <br>    OUT PVOID OutBuffer, <br>    IN DWORD OutBufferSize, <br>    OUT LPDWORD BytesReturned <br>    ) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    ResourceControl routine for SMB Sample resources. <br> <br>    Perform the control request specified by ControlCode on the specified <br>    resource. <br> <br>Arguments: <br> <br>    ResourceId - Supplies the resource id for the specific resource. <br> <br>    ControlCode - Supplies the control code that defines the action <br>        to be performed. <br> <br>    InBuffer - Supplies a pointer to a buffer containing input data. <br> <br>    InBufferSize - Supplies the size, in bytes, of the data pointed <br>        to by InBuffer. <br> <br>    OutBuffer - Supplies a pointer to the output buffer to be filled in. <br> <br>    OutBufferSize - Supplies the size, in bytes, of the available space <br>        pointed to by OutBuffer. <br> <br>    BytesReturned - Returns the number of bytes of OutBuffer actually <br>        filled in by the resource. If OutBuffer is too small, BytesReturned <br>        contains the total number of bytes for the operation to succeed. <br> <br>Return Value: <br> <br>    ERROR_SUCCESS - The function completed successfully. <br> <br>    ERROR_RESOURCE_NOT_FOUND - RESID is not valid. <br> <br>    ERROR_INVALID_FUNCTION - The requested control code is not supported. <br>        In some cases, this allows the cluster software to perform the work. <br> <br>    Win32 error code - The function failed. <br> <br>--*/ <br> <br>{ <br>    DWORD               status; <br>    PSMBSMP_RESOURCE  resourceEntry; <br>    DWORD               required; <br> <br>    resourceEntry = (PSMBSMP_RESOURCE)ResourceId; <br> <br>    if ( resourceEntry == NULL ) { <br>        DBG_PRINT("SmbSmp: ResourceControl request for a nonexistent resource id %u\n", <br>            ResourceId ); <br>        return(ERROR_RESOURCE_NOT_FOUND); <br>    } <br> <br>    if ( resourceEntry-&gt;ResId != ResourceId ) { <br>        (g_LogEvent)( <br>            resourceEntry-&gt;ResourceHandle, <br>            LOG_ERROR, <br>            L"ResourceControl sanity check failed! ResourceId = %1!u!.\n", <br>            ResourceId ); <br>        return(ERROR_RESOURCE_NOT_FOUND); <br>    } <br> <br>    switch ( ControlCode ) { <br> <br>        case CLUSCTL_RESOURCE_UNKNOWN: <br>            *BytesReturned = 0; <br>            status = ERROR_SUCCESS; <br>            break; <br> <br>        case CLUSCTL_RESOURCE_ENUM_PRIVATE_PROPERTIES: <br>            status = ResUtilEnumProperties( SmbSmpResourcePrivateProperties, <br>                                            OutBuffer, <br>                                            OutBufferSize, <br>                                            BytesReturned, <br>                                            &amp;required ); <br>            if ( status == ERROR_MORE_DATA ) { <br>                *BytesReturned = required; <br>            } <br>            break; <br> <br>        case CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTIES: <br>            status = SmbSmpGetPrivateResProperties( resourceEntry, <br>                                                      OutBuffer, <br>                                                      OutBufferSize, <br>                                                      BytesReturned ); <br>            break; <br> <br>        case CLUSCTL_RESOURCE_VALIDATE_PRIVATE_PROPERTIES: <br>            status = SmbSmpValidatePrivateResProperties( resourceEntry, <br>                                                           InBuffer, <br>                                                           InBufferSize, <br>                                                           NULL ); <br>            break; <br> <br>        case CLUSCTL_RESOURCE_SET_PRIVATE_PROPERTIES: <br>            status = SmbSmpSetPrivateResProperties( resourceEntry, <br>                                                      InBuffer, <br>                                                      InBufferSize ); <br>            break; <br> <br>        default: <br>            status = ERROR_INVALID_FUNCTION; <br>            break; <br>    } <br> <br>    return(status); <br> <br>} // SmbSmpResourceControl <br> <br> <br>  <br>DWORD <br>WINAPI <br>SmbSmpResourceTypeControl( <br>    IN LPCWSTR ResourceTypeName, <br>    IN DWORD ControlCode, <br>    IN PVOID InBuffer, <br>    IN DWORD InBufferSize, <br>    OUT PVOID OutBuffer, <br>    IN DWORD OutBufferSize, <br>    OUT LPDWORD BytesReturned <br>    ) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    ResourceTypeControl routine for SMB Sample resources. <br> <br>    Perform the control request specified by ControlCode. <br> <br>Arguments: <br> <br>    ResourceTypeName - Supplies the name of the resource type. <br> <br>    ControlCode - Supplies the control code that defines the action <br>        to be performed. <br> <br>    InBuffer - Supplies a pointer to a buffer containing input data. <br> <br>    InBufferSize - Supplies the size, in bytes, of the data pointed <br>        to by InBuffer. <br> <br>    OutBuffer - Supplies a pointer to the output buffer to be filled in. <br> <br>    OutBufferSize - Supplies the size, in bytes, of the available space <br>        pointed to by OutBuffer. <br> <br>    BytesReturned - Returns the number of bytes of OutBuffer actually <br>        filled in by the resource. If OutBuffer is too small, BytesReturned <br>        contains the total number of bytes for the operation to succeed. <br> <br>Return Value: <br> <br>    ERROR_SUCCESS - The function completed successfully. <br> <br>    ERROR_INVALID_FUNCTION - The requested control code is not supported. <br>        In some cases, this allows the cluster software to perform the work. <br> <br>    Win32 error code - The function failed. <br> <br>--*/ <br> <br>{ <br>    DWORD               status; <br>    DWORD               required; <br> <br>    switch ( ControlCode ) { <br> <br>        case CLUSCTL_RESOURCE_TYPE_UNKNOWN: <br>            *BytesReturned = 0; <br>            status = ERROR_SUCCESS; <br>            break; <br> <br>        case CLUSCTL_RESOURCE_TYPE_ENUM_PRIVATE_PROPERTIES: <br>            status = ResUtilEnumProperties( SmbSmpResourcePrivateProperties, <br>                                            OutBuffer, <br>                                            OutBufferSize, <br>                                            BytesReturned, <br>                                            &amp;required ); <br>            if ( status == ERROR_MORE_DATA ) { <br>                *BytesReturned = required; <br>            } <br>            break; <br> <br>        default: <br>            status = ERROR_INVALID_FUNCTION; <br>            break; <br>    } <br> <br>    return(status); <br> <br>} // SmbSmpResourceTypeControl <br> <br> <br>  <br>DWORD <br>SmbSmpGetPrivateResProperties( <br>    IN OUT PSMBSMP_RESOURCE ResourceEntry, <br>    OUT PVOID OutBuffer, <br>    IN DWORD OutBufferSize, <br>    OUT LPDWORD BytesReturned <br>    ) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    Processes the CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTIES control function <br>    for resources of type SMB Sample. <br> <br>Arguments: <br> <br>    ResourceEntry - Supplies the resource entry on which to operate. <br> <br>    OutBuffer - Returns the output data. <br> <br>    OutBufferSize - Supplies the size, in bytes, of the data pointed <br>        to by OutBuffer. <br> <br>    BytesReturned - The number of bytes returned in OutBuffer. <br> <br>Return Value: <br> <br>    ERROR_SUCCESS - The function completed successfully. <br> <br>    ERROR_INVALID_PARAMETER - The data is formatted incorrectly. <br> <br>    ERROR_NOT_ENOUGH_MEMORY - An error occurred allocating memory. <br> <br>    Win32 error code - The function failed. <br> <br>--*/ <br> <br>{ <br>    DWORD           status; <br>    DWORD           required; <br> <br>    status = ResUtilGetAllProperties( ResourceEntry-&gt;ParametersKey, <br>                                      SmbSmpResourcePrivateProperties, <br>                                      OutBuffer, <br>                                      OutBufferSize, <br>                                      BytesReturned, <br>                                      &amp;required ); <br>    if ( status == ERROR_MORE_DATA ) { <br>        *BytesReturned = required; <br>    } <br> <br>    return(status); <br> <br>} // SmbSmpGetPrivateResProperties <br> <br> <br>  <br>DWORD <br>SmbSmpValidatePrivateResProperties( <br>    IN OUT PSMBSMP_RESOURCE ResourceEntry, <br>    IN PVOID InBuffer, <br>    IN DWORD InBufferSize, <br>    OUT PSMBSMP_PARAMS Params <br>    ) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    Processes the CLUSCTL_RESOURCE_VALIDATE_PRIVATE_PROPERTIES control <br>    function for resources of type SMB Sample. <br> <br>Arguments: <br> <br>    ResourceEntry - Supplies the resource entry on which to operate. <br> <br>    InBuffer - Supplies a pointer to a buffer containing input data. <br> <br>    InBufferSize - Supplies the size, in bytes, of the data pointed <br>        to by InBuffer. <br> <br>    Params - Supplies the parameter block to fill in. <br> <br>Return Value: <br> <br>    ERROR_SUCCESS - The function completed successfully. <br> <br>    ERROR_INVALID_PARAMETER - The data is formatted incorrectly. <br> <br>    ERROR_NOT_ENOUGH_MEMORY - An error occurred allocating memory. <br> <br>    Win32 error code - The function failed. <br> <br>--*/ <br> <br>{ <br>    DWORD           status = ERROR_SUCCESS; <br>    SMBSMP_PARAMS   params; <br>    PSMBSMP_PARAMS  pParams; <br> <br>    // <br>    // Check if there is input data. <br>    // <br>    if ( (InBuffer == NULL) || <br>         (InBufferSize &lt; sizeof(DWORD)) ) { <br>        return(ERROR_INVALID_DATA); <br>    } <br> <br>    // <br>    // Duplicate the resource parameter block. <br>    // <br>    if ( Params == NULL ) { <br>        pParams = &amp;params; <br>    } else { <br>        pParams = Params; <br>    } <br>    ZeroMemory( pParams, sizeof(SMBSMP_PARAMS) ); <br>    status = ResUtilDupParameterBlock( (LPBYTE) pParams, <br>                                       (LPBYTE) &amp;ResourceEntry-&gt;Params, <br>                                       SmbSmpResourcePrivateProperties ); <br>    if ( status != ERROR_SUCCESS ) { <br>        return(status); <br>    } <br> <br>    // <br>    // Parse and validate the properties. <br>    // <br>    status = ResUtilVerifyPropertyTable( SmbSmpResourcePrivateProperties, <br>                                         NULL, <br>                                         TRUE, // AllowUnknownProperties <br>                                         InBuffer, <br>                                         InBufferSize, <br>                                         (LPBYTE) pParams ); <br> <br>    if ( status == ERROR_SUCCESS ) { <br>        // <br>        // Validate the parameter values. <br>        // <br>        // TODO: Code to validate interactions between parameters goes here. <br>    } <br> <br>    // <br>    // Cleanup our parameter block. <br>    // <br>    if ( pParams == &amp;params ) { <br>        ResUtilFreeParameterBlock( (LPBYTE) &amp;params, <br>                                   (LPBYTE) &amp;ResourceEntry-&gt;Params, <br>                                   SmbSmpResourcePrivateProperties ); <br>    } <br> <br>    return status; <br> <br>} // SmbSmpValidatePrivateResProperties <br> <br> <br>  <br>DWORD <br>SmbSmpSetPrivateResProperties( <br>    IN OUT PSMBSMP_RESOURCE ResourceEntry, <br>    IN PVOID InBuffer, <br>    IN DWORD InBufferSize <br>    ) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    Processes the CLUSCTL_RESOURCE_SET_PRIVATE_PROPERTIES control function <br>    for resources of type SMB Sample. <br> <br>Arguments: <br> <br>    ResourceEntry - Supplies the resource entry on which to operate. <br> <br>    InBuffer - Supplies a pointer to a buffer containing input data. <br> <br>    InBufferSize - Supplies the size, in bytes, of the data pointed <br>        to by InBuffer. <br> <br>Return Value: <br> <br>    ERROR_SUCCESS - The function completed successfully. <br> <br>    ERROR_INVALID_PARAMETER - The data is formatted incorrectly. <br> <br>    ERROR_NOT_ENOUGH_MEMORY - An error occurred allocating memory. <br> <br>    Win32 error code - The function failed. <br> <br>--*/ <br> <br>{ <br>    DWORD           status = ERROR_SUCCESS; <br>    SMBSMP_PARAMS   params; <br> <br>    // <br>    // Parse the properties so they can be validated together. <br>    // This routine does individual property validation. <br>    // <br>    status = SmbSmpValidatePrivateResProperties( ResourceEntry, InBuffer, InBufferSize, &amp;params ); <br>    if ( status != ERROR_SUCCESS ) { <br>        ResUtilFreeParameterBlock( (LPBYTE) &amp;params, <br>                                   (LPBYTE) &amp;ResourceEntry-&gt;Params, <br>                                   SmbSmpResourcePrivateProperties ); <br>        return(status); <br>    } <br> <br>    // <br>    // Save the parameter values. <br>    // <br> <br>    status = ResUtilSetPropertyParameterBlock( ResourceEntry-&gt;ParametersKey, <br>                                               SmbSmpResourcePrivateProperties, <br>                                               NULL, <br>                                               (LPBYTE) &amp;params, <br>                                               InBuffer, <br>                                               InBufferSize, <br>                                               (LPBYTE) &amp;ResourceEntry-&gt;Params ); <br> <br>    ResUtilFreeParameterBlock( (LPBYTE) &amp;params, <br>                               (LPBYTE) &amp;ResourceEntry-&gt;Params, <br>                               SmbSmpResourcePrivateProperties ); <br> <br>    // <br>    // If the resource is online, return a non-success status. <br>    // <br>    // TODO: Modify the code below if your resource can handle <br>    // changes to properties while it is still online. <br>    if ( status == ERROR_SUCCESS ) { <br>        if ( ResourceEntry-&gt;State == ClusterResourceOnline ) { <br>            status = ERROR_RESOURCE_PROPERTIES_STORED; <br>        } else if ( ResourceEntry-&gt;State == ClusterResourceOnlinePending ) { <br>            status = ERROR_RESOURCE_PROPERTIES_STORED; <br>        } else { <br>            status = ERROR_SUCCESS; <br>        } <br>    } <br> <br>    return status; <br> <br>} // SmbSmpSetPrivateResProperties <br> <br> <br>//*********************************************************** <br>// <br>// Define Function Table <br>// <br>//*********************************************************** <br> <br>CLRES_V1_FUNCTION_TABLE( g_SmbSmpFunctionTable,     // Name <br>                         CLRES_VERSION_V1_00,         // Version <br>                         SmbSmp,                    // Prefix <br>                         NULL,                        // Arbitrate <br>                         NULL,                        // Release <br>                         SmbSmpResourceControl,     // ResControl <br>                         SmbSmpResourceTypeControl); // ResTypeControl <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
