<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>EXTOBJ.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5959"></a>EXTOBJ.CPP</h2>
<pre><code>///////////////////////////////////////////////////////////////////////////// <br>// <br>//Copyright (c) 1997 &lt;company name&gt; <br>// <br>//Module Name: <br>//ExtObj.cpp <br>// <br>//Abstract: <br>//Implementation of the CExtObject class, which implements the <br>//extension interfaces required by a Microsoft Windows NT Cluster <br>//Administrator Extension DLL. <br>// <br>//Author: <br>//&lt;name&gt; (&lt;e-mail name&gt;) Mmmm DD, 1997 <br>// <br>//Revision History: <br>// <br>//Notes: <br>// <br>///////////////////////////////////////////////////////////////////////////// <br> <br>#include "stdafx.h" <br>#include "SmbSmpEx.h" <br>#include "ExtObj.h" <br>#include "ResProp.h" <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// Global Variables <br>///////////////////////////////////////////////////////////////////////////// <br> <br>const WCHAR g_wszResourceTypeNames[] = <br>L"SMB Sample\0" <br>L"\0" <br>; <br>const DWORD g_cchResourceTypeNames= sizeof(g_wszResourceTypeNames) / sizeof(WCHAR); <br> <br>static CRuntimeClass * g_rgprtcResPSPages[]= { <br>RUNTIME_CLASS(CSmbSmpParamsPage), <br>NULL <br>}; <br>static CRuntimeClass ** g_rgpprtcResPSPages[]= { <br>g_rgprtcResPSPages, <br>}; <br>static CRuntimeClass ** g_rgpprtcResWizPages[]= { <br>g_rgprtcResPSPages, <br>}; <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// CExtObject <br>///////////////////////////////////////////////////////////////////////////// <br> <br>///////////////////////////////////////////////////////////////////////////// <br>//++ <br>// <br>//CExtObject::CExtObject <br>// <br>//Routine Description: <br>//Default constructor. <br>// <br>//Arguments: <br>//None. <br>// <br>//Return Value: <br>//None. <br>// <br>//-- <br>///////////////////////////////////////////////////////////////////////////// <br>CExtObject::CExtObject(void) <br>{ <br>m_piData = NULL; <br>m_piWizardCallback = NULL; <br>m_bWizard = FALSE; <br>m_istrResTypeName = 0; <br> <br>m_lcid = NULL; <br>m_hfont = NULL; <br>m_hicon = NULL; <br>m_hcluster = NULL; <br>m_cobj = 0; <br>m_podObjData = NULL; <br> <br>}  //*** CExtObject::CExtObject() <br> <br>///////////////////////////////////////////////////////////////////////////// <br>//++ <br>// <br>//CExtObject::~CExtObject <br>// <br>//Routine Description: <br>//Destructor. <br>// <br>//Arguments: <br>//None. <br>// <br>//Return Value: <br>//None. <br>// <br>//-- <br>///////////////////////////////////////////////////////////////////////////// <br>CExtObject::~CExtObject(void) <br>{ <br>// Release the data interface. <br>if (PiData() != NULL) <br>{ <br>PiData()-&gt;Release(); <br>m_piData = NULL; <br>}  // if:  we have a data interface pointer <br> <br>// Release the wizard callback interface. <br>if (PiWizardCallback() != NULL) <br>{ <br>PiWizardCallback()-&gt;Release(); <br>m_piWizardCallback = NULL; <br>}  // if:  we have a wizard callback interface pointer <br> <br>// Delete the pages. <br>{ <br>POSITIONpos; <br> <br>pos = Lpg().GetHeadPosition(); <br>while (pos != NULL) <br>delete Lpg().GetNext(pos); <br>}  // Delete the pages <br> <br>delete m_podObjData; <br> <br>}  //*** CExtObject::~CExtObject() <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// ISupportErrorInfo Implementation <br> <br>///////////////////////////////////////////////////////////////////////////// <br>//++ <br>// <br>//CExtObject::InterfaceSupportsErrorInfo (ISupportErrorInfo) <br>// <br>//Routine Description: <br>//Indicates whether an interface suportes the IErrorInfo interface. <br>//This interface is provided by ATL. <br>// <br>//Arguments: <br>//riidInterface ID. <br>// <br>//Return Value: <br>//S_OKInterface supports IErrorInfo. <br>//S_FALSEInterface does not support IErrorInfo. <br>// <br>//-- <br>///////////////////////////////////////////////////////////////////////////// <br>STDMETHODIMP CExtObject::InterfaceSupportsErrorInfo(REFIID riid) <br>{ <br>static const IID * rgiid[] =  <br>{ <br>&amp;IID_IWEExtendPropertySheet, <br>&amp;IID_IWEExtendWizard, <br>}; <br>intiiid; <br> <br>for (iiid = 0 ; iiid &lt; sizeof(rgiid) / sizeof(rgiid[0]) ; iiid++) <br>{ <br>if (InlineIsEqualGUID(*rgiid[iiid], riid)) <br>return S_OK; <br>} <br>return S_FALSE; <br> <br>}  //*** CExtObject::InterfaceSupportsErrorInfo() <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// IWEExtendPropertySheet Implementation <br> <br>///////////////////////////////////////////////////////////////////////////// <br>//++ <br>// <br>//CExtObject::CreatePropertySheetPages (IWEExtendPropertySheet) <br>// <br>//Routine Description: <br>//Create property sheet pages and add them to the sheet. <br>// <br>//Arguments: <br>//piDataIUnkown pointer from which to obtain interfaces <br>//for obtaining data describing the object for <br>//which the sheet is being displayed. <br>//piCallbackPointer to an IWCPropertySheetCallback interface <br>//for adding pages to the sheet. <br>// <br>//Return Value: <br>//NOERRORPages added successfully. <br>//E_INVALIDARGInvalid arguments to the function. <br>//E_OUTOFMEMORYError allocating memory. <br>//E_FAILError creating a page. <br>//E_NOTIMPLNot implemented for this type of data. <br>//Any error codes from IDataObject::GetData() (through HrSaveData()). <br>// <br>//-- <br>///////////////////////////////////////////////////////////////////////////// <br>STDMETHODIMP CExtObject::CreatePropertySheetPages( <br>IN IUnknown *piData, <br>IN IWCPropertySheetCallback *piCallback <br>) <br>{ <br>HRESULThr= NOERROR; <br>HPROPSHEETPAGEhpage= NULL; <br>CExceptionexc(FALSE /*bAutoDelete*/); <br>CRuntimeClass **pprtc= NULL; <br>intirtc; <br>CBasePropertyPage *ppage; <br> <br>AFX_MANAGE_STATE(AfxGetStaticModuleState()); <br> <br>// Validate the parameters. <br>if ((piData == NULL) || (piCallback == NULL)) <br>return E_INVALIDARG; <br> <br>try  <br>{ <br>// Get info about displaying UI. <br>hr = HrGetUIInfo(piData); <br>if (hr != NOERROR) <br>throw &amp;exc; <br> <br>// Save the data. <br>hr = HrSaveData(piData); <br>if (hr != NOERROR) <br>throw &amp;exc; <br> <br>// Delete any previous pages. <br>{ <br>POSITIONpos; <br> <br>pos = Lpg().GetHeadPosition(); <br>while (pos != NULL) <br>delete Lpg().GetNext(pos); <br>Lpg().RemoveAll(); <br>}  // Delete any previous pages <br> <br>// Create property pages. <br>ASSERT(PodObjData() != NULL); <br>switch (PodObjData()-&gt;m_cot) <br>{ <br>case CLUADMEX_OT_RESOURCE: <br>pprtc = g_rgpprtcResPSPages[IstrResTypeName()]; <br>break; <br>default: <br>hr = E_NOTIMPL; <br>throw &amp;exc; <br>break; <br>}  // switch:  object type <br> <br>// Create each page. <br>for (irtc = 0 ; pprtc[irtc] != NULL ; irtc++) <br>{ <br>// Create the page. <br>ppage = (CBasePropertyPage *) pprtc[irtc]-&gt;CreateObject(); <br>ASSERT(ppage-&gt;IsKindOf(pprtc[irtc])); <br> <br>// Add it to the list. <br>Lpg().AddTail(ppage); <br> <br>// Initialize the property page. <br>if (!ppage-&gt;BInit(this)) <br>throw &amp;exc; <br> <br>// Create the page. <br>hpage = ::CreatePropertySheetPage(&amp;ppage-&gt;m_psp); <br>if (hpage == NULL) <br>throw &amp;exc; <br> <br>// Save the hpage in the page itself. <br>ppage-&gt;SetHpage(hpage); <br> <br>// Add it to the property sheet. <br>hr = piCallback-&gt;AddPropertySheetPage((LONG *) hpage); <br>if (hr != NOERROR) <br>throw &amp;exc; <br>}  // for:  each page in the list <br> <br>}  // try <br>catch (CMemoryException * pme) <br>{ <br>TRACE(_T("CExtObject::CreatePropetySheetPages() - Failed to add property page\n")); <br>pme-&gt;Delete(); <br>hr = E_OUTOFMEMORY; <br>}  // catch:  anything <br>catch (CException * pe) <br>{ <br>TRACE(_T("CExtObject::CreatePropetySheetPages() - Failed to add property page\n")); <br>pe-&gt;Delete(); <br>if (hr == NOERROR) <br>hr = E_FAIL; <br>}  // catch:  anything <br> <br>if (hr != NOERROR) <br>{ <br>if (hpage != NULL) <br>::DestroyPropertySheetPage(hpage); <br>piData-&gt;Release(); <br>m_piData = NULL; <br>}  // if:  error occurred <br> <br>piCallback-&gt;Release(); <br>return hr; <br> <br>}  //*** CExtObject::CreatePropertySheetPages() <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// IWEExtendWizard Implementation <br> <br>///////////////////////////////////////////////////////////////////////////// <br>//++ <br>// <br>//CExtObject::CreateWizardPages (IWEExtendWizard) <br>// <br>//Routine Description: <br>//Create property sheet pages and add them to the wizard. <br>// <br>//Arguments: <br>//piDataIUnkown pointer from which to obtain interfaces <br>//for obtaining data describing the object for <br>//which the wizard is being displayed. <br>//piCallbackPointer to an IWCPropertySheetCallback interface <br>//for adding pages to the sheet. <br>// <br>//Return Value: <br>//NOERRORPages added successfully. <br>//E_INVALIDARGInvalid arguments to the function. <br>//E_OUTOFMEMORYError allocating memory. <br>//E_FAILError creating a page. <br>//E_NOTIMPLNot implemented for this type of data. <br>//Any error codes from IDataObject::GetData() (through HrSaveData()). <br>// <br>//-- <br>///////////////////////////////////////////////////////////////////////////// <br>STDMETHODIMP CExtObject::CreateWizardPages( <br>IN IUnknown *piData, <br>IN IWCWizardCallback *piCallback <br>) <br>{ <br>HRESULThr= NOERROR; <br>HPROPSHEETPAGEhpage= NULL; <br>CExceptionexc(FALSE /*bAutoDelete*/); <br>CRuntimeClass **pprtc= NULL; <br>intirtc; <br>CBasePropertyPage *ppage; <br> <br>AFX_MANAGE_STATE(AfxGetStaticModuleState()); <br> <br>// Validate the parameters. <br>if ((piData == NULL) || (piCallback == NULL)) <br>return E_INVALIDARG; <br> <br>try  <br>{ <br>// Get info about displaying UI. <br>hr = HrGetUIInfo(piData); <br>if (hr != NOERROR) <br>throw &amp;exc; <br> <br>// Save the data. <br>hr = HrSaveData(piData); <br>if (hr != NOERROR) <br>throw &amp;exc; <br> <br>// Delete any previous pages. <br>{ <br>POSITIONpos; <br> <br>pos = Lpg().GetHeadPosition(); <br>while (pos != NULL) <br>delete Lpg().GetNext(pos); <br>Lpg().RemoveAll(); <br>}  // Delete any previous pages <br> <br>m_piWizardCallback = piCallback; <br>m_bWizard = TRUE; <br> <br>// Create property pages. <br>ASSERT(PodObjData() != NULL); <br>switch (PodObjData()-&gt;m_cot) <br>{ <br>case CLUADMEX_OT_RESOURCE: <br>pprtc = g_rgpprtcResWizPages[IstrResTypeName()]; <br>break; <br>default: <br>hr = E_NOTIMPL; <br>throw &amp;exc; <br>break; <br>}  // switch:  object type <br> <br>// Create each page. <br>for (irtc = 0 ; pprtc[irtc] != NULL ; irtc++) <br>{ <br>// Create the page. <br>ppage = (CBasePropertyPage *) pprtc[irtc]-&gt;CreateObject(); <br>ASSERT(ppage-&gt;IsKindOf(pprtc[irtc])); <br> <br>// Add it to the list. <br>Lpg().AddTail(ppage); <br> <br>// Initialize the property page. <br>if (!ppage-&gt;BInit(this)) <br>throw &amp;exc; <br> <br>// Create the page. <br>hpage = ::CreatePropertySheetPage(&amp;ppage-&gt;m_psp); <br>if (hpage == NULL) <br>throw &amp;exc; <br> <br>// Save the hpage in the page itself. <br>ppage-&gt;SetHpage(hpage); <br> <br>// Add it to the property sheet. <br>hr = piCallback-&gt;AddWizardPage((LONG *) hpage); <br>if (hr != NOERROR) <br>throw &amp;exc; <br>}  // for:  each page in the list <br> <br>}  // try <br>catch (CMemoryException * pme) <br>{ <br>TRACE(_T("CExtObject::CreateWizardPages() - Failed to add wizard page\n")); <br>pme-&gt;Delete(); <br>hr = E_OUTOFMEMORY; <br>}  // catch:  anything <br>catch (CException * pe) <br>{ <br>TRACE(_T("CExtObject::CreateWizardPages() - Failed to add wizard page\n")); <br>pe-&gt;Delete(); <br>if (hr == NOERROR) <br>hr = E_FAIL; <br>}  // catch:  anything <br> <br>if (hr != NOERROR) <br>{ <br>if (hpage != NULL) <br>::DestroyPropertySheetPage(hpage); <br>piCallback-&gt;Release(); <br>piData-&gt;Release(); <br>m_piData = NULL; <br>}  // if:  error occurred <br> <br>return hr; <br> <br>}  //*** CExtObject::CreateWizardPages() <br> <br>///////////////////////////////////////////////////////////////////////////// <br>//++ <br>// <br>//CExtObject::HrGetUIInfo <br>// <br>//Routine Description: <br>//Get info about displaying UI. <br>// <br>//Arguments: <br>//piDataIUnkown pointer from which to obtain interfaces <br>//for obtaining data describing the object. <br>// <br>//Return Value: <br>//NOERRORData saved successfully. <br>//E_NOTIMPLNot implemented for this type of data. <br>//Any error codes from IUnknown::QueryInterface(), HrGetObjectName(), <br>//or HrGetResourceName(). <br>// <br>//-- <br>///////////////////////////////////////////////////////////////////////////// <br>HRESULT CExtObject::HrGetUIInfo(IUnknown * piData) <br>{ <br>HRESULThr= NOERROR; <br> <br>ASSERT(piData != NULL); <br> <br>// Save info about all types of objects. <br>{ <br>IGetClusterUIInfo *pi; <br> <br>hr = piData-&gt;QueryInterface(IID_IGetClusterUIInfo, (LPVOID *) &amp;pi); <br>if (hr != NOERROR) <br>return hr; <br> <br>m_lcid = pi-&gt;GetLocale(); <br>m_hfont = pi-&gt;GetFont(); <br>m_hicon = pi-&gt;GetIcon(); <br> <br>pi-&gt;Release(); <br>}  // Save info about all types of objects <br> <br>return hr; <br> <br>}  //*** CExtObject::HrGetUIInfo() <br> <br>///////////////////////////////////////////////////////////////////////////// <br>//++ <br>// <br>//CExtObject::HrSaveData <br>// <br>//Routine Description: <br>//Save data from the object so that it can be used for the life <br>//of the object. <br>// <br>//Arguments: <br>//piDataIUnkown pointer from which to obtain interfaces <br>//for obtaining data describing the object. <br>// <br>//Return Value: <br>//NOERRORData saved successfully. <br>//E_NOTIMPLNot implemented for this type of data. <br>//Any error codes from IUnknown::QueryInterface(), HrGetObjectName(), <br>//or HrGetResourceName(). <br>// <br>//-- <br>///////////////////////////////////////////////////////////////////////////// <br>HRESULT CExtObject::HrSaveData(IUnknown * piData) <br>{ <br>HRESULThr= NOERROR; <br> <br>ASSERT(piData != NULL); <br> <br>if (piData != m_piData) <br>{ <br>if (m_piData != NULL) <br>m_piData-&gt;Release(); <br>m_piData = piData; <br>}  // if:  different data interface pointer <br> <br>// Save info about all types of objects. <br>{ <br>IGetClusterDataInfo *pi; <br> <br>hr = piData-&gt;QueryInterface(IID_IGetClusterDataInfo, (LPVOID *) &amp;pi); <br>if (hr != NOERROR) <br>return hr; <br> <br>m_hcluster = pi-&gt;GetClusterHandle(); <br>m_cobj = pi-&gt;GetObjectCount(); <br>if (Cobj() != 1)// Only have support for one selected object. <br>hr = E_NOTIMPL; <br> <br>pi-&gt;Release(); <br>if (hr != NOERROR) <br>return hr; <br>}  // Save info about all types of objects <br> <br>// Save info about this object. <br>hr = HrGetObjectInfo(); <br>if (hr != NOERROR) <br>return hr; <br> <br>return hr; <br> <br>}  //*** CExtObject::HrSaveData() <br> <br>///////////////////////////////////////////////////////////////////////////// <br>//++ <br>// <br>//CExtObject::HrGetObjectInfo <br>// <br>//Routine Description: <br>//Get information about the object. <br>// <br>//Arguments: <br>//None. <br>// <br>//Return Value: <br>//NOERRORData saved successfully. <br>//E_OUTOFMEMORYError allocating memory. <br>//E_NOTIMPLNot implemented for this type of data. <br>//Any error codes from IUnknown::QueryInterface(), HrGetObjectName(), <br>//or HrGetResourceTypeName(). <br>// <br>//-- <br>///////////////////////////////////////////////////////////////////////////// <br>HRESULT CExtObject::HrGetObjectInfo(void) <br>{ <br>HRESULThr= NOERROR; <br>IGetClusterObjectInfo *piGcoi; <br>CLUADMEX_OBJECT_TYPEcot; <br>CExceptionexc(FALSE /*bAutoDelete*/); <br>const CString *pstrResTypeName; <br> <br>ASSERT(PiData() != NULL); <br> <br>// Get object info. <br>{ <br>// Get an IGetClusterObjectInfo interface pointer. <br>hr = PiData()-&gt;QueryInterface(IID_IGetClusterObjectInfo, (LPVOID *) &amp;piGcoi); <br>if (hr != NOERROR) <br>return hr; <br> <br>// Read the object data. <br>try <br>{ <br>// Delete the previous object data. <br>delete m_podObjData; <br>m_podObjData = NULL; <br> <br>// Get the type of the object. <br>cot = piGcoi-&gt;GetObjectType(0); <br>switch (cot) <br>{ <br>case CLUADMEX_OT_RESOURCE: <br>{ <br>IGetClusterResourceInfo *pi; <br> <br>m_podObjData = new CResData; <br> <br>// Get an IGetClusterResourceInfo interface pointer. <br>hr = PiData()-&gt;QueryInterface(IID_IGetClusterResourceInfo, (LPVOID *) &amp;pi); <br>if (hr != NOERROR) <br>throw &amp;exc; <br> <br>PrdResDataRW()-&gt;m_hresource = pi-&gt;GetResourceHandle(0); <br>ASSERT(PrdResDataRW()-&gt;m_hresource != NULL); <br>if (PrdResDataRW()-&gt;m_hresource == NULL) <br>hr = E_INVALIDARG; <br>else <br>hr = HrGetResourceTypeName(pi); <br>pi-&gt;Release(); <br>if (hr != NOERROR) <br>throw &amp;exc; <br> <br>pstrResTypeName = &amp;PrdResDataRW()-&gt;m_strResTypeName; <br>}  // if:  object is a node <br>break; <br>default: <br>hr = E_NOTIMPL; <br>throw &amp;exc; <br>}  // switch:  object type <br> <br>PodObjDataRW()-&gt;m_cot = cot; <br>hr = HrGetObjectName(piGcoi); <br>}  // try <br>catch (CException * pe) <br>{ <br>pe-&gt;Delete(); <br>}  // catch:  CException <br> <br>piGcoi-&gt;Release(); <br>if (hr != NOERROR) <br>return hr; <br>}  // Get object info <br> <br>// If this is a resource or resource type, see if we know about this type. <br>if (((cot == CLUADMEX_OT_RESOURCE) <br>|| (cot == CLUADMEX_OT_RESOURCETYPE)) <br>&amp;&amp; (hr == NOERROR)) <br>{ <br>LPCWSTRpwszResTypeName; <br> <br>// Find the resource type name in our list. <br>// Save the index for use in other arrays. <br>for (m_istrResTypeName = 0, pwszResTypeName = g_wszResourceTypeNames <br>; *pwszResTypeName != L'\0' <br>; m_istrResTypeName++, pwszResTypeName += lstrlenW(pwszResTypeName) + 1 <br>) <br>{ <br>if (pstrResTypeName-&gt;CompareNoCase(pwszResTypeName) == 0) <br>break; <br>}  // for:  each resource type in the list <br>if (*pwszResTypeName == L'\0') <br>hr = E_NOTIMPL; <br>}  // See if we know about this resource type <br> <br>return hr; <br> <br>}  //*** CExtObject::HrGetObjectInfo() <br> <br>///////////////////////////////////////////////////////////////////////////// <br>//++ <br>// <br>//CExtObject::HrGetObjectName <br>// <br>//Routine Description: <br>//Get the name of the object. <br>// <br>//Arguments: <br>//piDataIGetClusterObjectInfo interface pointer for getting <br>//the object name. <br>// <br>//Return Value: <br>//NOERRORData saved successfully. <br>//E_OUTOFMEMORYError allocating memory. <br>//E_NOTIMPLNot implemented for this type of data. <br>//Any error codes from IGetClusterObjectInfo::GetObjectInfo(). <br>// <br>//-- <br>///////////////////////////////////////////////////////////////////////////// <br>HRESULT CExtObject::HrGetObjectName( <br>IN OUT IGetClusterObjectInfo *pi <br>) <br>{ <br>HRESULThr= NOERROR; <br>WCHAR *pwszName= NULL; <br>LONGcchName; <br> <br>ASSERT(pi != NULL); <br> <br>hr = pi-&gt;GetObjectName(0, NULL, &amp;cchName); <br>if (hr != NOERROR) <br>return hr; <br> <br>try <br>{ <br>pwszName = new WCHAR[cchName]; <br>hr = pi-&gt;GetObjectName(0, pwszName, &amp;cchName); <br>if (hr != NOERROR) <br>{ <br>delete [] pwszName; <br>pwszName = NULL; <br>}  // if:  error getting object name <br> <br>PodObjDataRW()-&gt;m_strName = pwszName; <br>}  // try <br>catch (CMemoryException * pme) <br>{ <br>pme-&gt;Delete(); <br>hr = E_OUTOFMEMORY; <br>}  // catch:  CMemoryException <br> <br>delete [] pwszName; <br>return hr; <br> <br>}  //*** CExtObject::HrGetObjectName() <br> <br>///////////////////////////////////////////////////////////////////////////// <br>//++ <br>// <br>//CExtObject::HrGetResourceTypeName <br>// <br>//Routine Description: <br>//Get the name of the resource's type. <br>// <br>//Arguments: <br>//piDataIGetClusterResourceInfo interface pointer for getting <br>//the resource type name. <br>// <br>//Return Value: <br>//NOERRORData saved successfully. <br>//E_OUTOFMEMORYError allocating memory. <br>//E_NOTIMPLNot implemented for this type of data. <br>//Any error codes from IGetClusterResourceInfo::GetResourceTypeName(). <br>// <br>//-- <br>///////////////////////////////////////////////////////////////////////////// <br>HRESULT CExtObject::HrGetResourceTypeName( <br>IN OUT IGetClusterResourceInfo *pi <br>) <br>{ <br>HRESULThr= NOERROR; <br>WCHAR *pwszName= NULL; <br>LONGcchName; <br> <br>ASSERT(pi != NULL); <br> <br>hr = pi-&gt;GetResourceTypeName(0, NULL, &amp;cchName); <br>if (hr != NOERROR) <br>return hr; <br> <br>try <br>{ <br>pwszName = new WCHAR[cchName]; <br>hr = pi-&gt;GetResourceTypeName(0, pwszName, &amp;cchName); <br>if (hr != NOERROR) <br>{ <br>delete [] pwszName; <br>pwszName = NULL; <br>}  // if:  error getting resource type name <br> <br>PrdResDataRW()-&gt;m_strResTypeName = pwszName; <br>}  // try <br>catch (CMemoryException * pme) <br>{ <br>pme-&gt;Delete(); <br>hr = E_OUTOFMEMORY; <br>}  // catch:  CMemoryException <br> <br>delete [] pwszName; <br>return hr; <br> <br>}  //*** CExtObject::HrGetResourceTypeName() </code></pre>
<p>&nbsp;</p></body>
</HTML>
