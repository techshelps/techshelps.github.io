<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DEBDEBUG.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5976"></a>DEBDEBUG.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples.  <br>*       Copyright 1993 - 1998 Microsoft Corporation. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>// ************************************************************************ <br>// MODULE    : DEBDebug.C <br>// PURPOSE   : Debug support functions for the Debug Event Browser <br>// FUNCTIONS : <br>//   DebugEventThread()         - debug event processing thread <br>// COMMENTS  : <br>// <br>// ************************************************************************ <br>#define   STRICT               // enable strict typing <br>#include &lt;Windows.H&gt;           // required for all Windows applications <br>#include &lt;StdDef.H&gt;            // offsetof() <br> <br>#include "LinkList.H"          // include the linked list functions <br>#include "DEBMisc.H"           // include the misc. support functions <br>#include "DEBDebug.H"          // include the DEB debugging functions <br> <br>// internal global data <br>// ------------------------------------------------------------------------ <br>HANDLE hHeap;                  // local heap <br>PLIST  pProcessList;           // pointer to the process list <br>BOOL   fFinished = FALSE;      // set to TRUE if the DebugEventThread <br>                               //  is no longer needed (such as the <br>                               //  debuggee failed to load or the number <br>                               //  of debuggee threads goes to zero <br>                               //  indicating debug session termination <br> <br>static TCHAR szSourceFileName[] = TEXT(__FILE__); <br> <br>// internal function prototypes <br>// ------------------------------------------------------------------------ <br> <br>//-- debug event handling functions <br>BOOL HandleExceptionEvent( LPDEBUG_EVENT ); <br>BOOL HandleBreakPointException( LPDEBUG_EVENT ); <br>BOOL HandleCreateThreadEvent( LPDEBUG_EVENT ); <br>BOOL HandleCreateProcessEvent( LPDEBUG_EVENT ); <br>BOOL HandleExitThreadEvent( LPDEBUG_EVENT ); <br>BOOL HandleExitProcessEvent( LPDEBUG_EVENT ); <br>BOOL HandleLoadDllEvent( LPDEBUG_EVENT ); <br>BOOL HandleUnloadDllEvent( LPDEBUG_EVENT ); <br>BOOL HandleOutputDebugStringEvent( LPDEBUG_EVENT ); <br>BOOL HandleRipEvent( LPDEBUG_EVENT ); <br>BOOL HandleUnknownEvent( LPDEBUG_EVENT ); <br> <br>//-- misc debug event helper functions <br>BOOL  DebugNewProcess( LPTSTR, LPTSTR ); <br>BOOL  GetDllFileName( LPDEBUG_EVENT, LPTSTR, DWORD ); <br>BOOL  GetDllFileNameFromList( LPDEBUG_EVENT, LPTSTR, DWORD ); <br>BOOL  GetOutputDebugString( LPDEBUG_EVENT, LPTSTR, DWORD ); <br>DWORD GetModuleFileNameFromHeader( HANDLE, HANDLE, DWORD, LPTSTR, DWORD ); <br>#if defined(_MIPS_) || defined(_ALPHA_) || defined(_PPC_) <br> BOOL  SkipBreakPoint( HANDLE ); <br>#endif <br> <br>//-- linked list wrapper functions <br> <br>//-- process list and node specific linked list wrapper functions <br>int  ProcessOrderFunction( PNODE, PNODE ); <br>BOOL CreateProcessList( PLIST* ); <br>BOOL DestroyProcessList( PLIST ); <br>BOOL AllocProcessNode( PNODE*, PDEB_PROCESS_NODE_INFO* ); <br>BOOL InitProcessNodeInfo( PDEB_PROCESS_NODE_INFO*, LPDEBUG_EVENT ); <br>BOOL InsertProcessNode( PLIST, PNODE ); <br>BOOL SetCurrentProcessNode( PLIST, PNODE ); <br>BOOL DeleteProcessNode( PLIST, PNODE ); <br>BOOL FreeProcessNodeInfo( PNODE ); <br>BOOL DestroyProcessNode( PNODE ); <br>BOOL DeleteCurrentProcessNode( PLIST ); <br> <br>//-- thread list and node specific linked list wrapper functions <br>int  ThreadOrderFunction( PNODE, PNODE ); <br>BOOL CreateThreadList( PLIST* ); <br>BOOL DestroyThreadList( PLIST ); <br>BOOL AllocThreadNode( PNODE*, PDEB_THREAD_NODE_INFO* ); <br>BOOL InitThreadNodeInfo( PDEB_THREAD_NODE_INFO*, LPDEBUG_EVENT ); <br>BOOL InsertThreadNode( PLIST, PNODE ); <br>BOOL SetCurrentThreadNode( PLIST, PNODE ); <br>BOOL DeleteThreadNode( PLIST, PNODE ); <br>BOOL FreeThreadNodeInfo( PNODE ); <br>BOOL DestroyThreadNode( PNODE ); <br>BOOL DeleteCurrentThreadNode( PLIST ); <br> <br>//-- dll list and node specific linked list wrapper functions <br>int  DllOrderFunction( PNODE, PNODE ); <br>BOOL CreateDllList( PLIST* ); <br>BOOL DestroyDllList( PLIST ); <br>BOOL AllocDllNode( PNODE*, PDEB_DLL_NODE_INFO* ); <br>BOOL InitDllNodeInfo( PDEB_DLL_NODE_INFO*, LPDEBUG_EVENT ); <br>BOOL InsertDllNode( PLIST, PNODE ); <br>BOOL SetCurrentDllNode( PLIST, PNODE ); <br>BOOL DeleteDllNode( PLIST, PNODE ); <br>BOOL FreeDllNodeInfo( PNODE ); <br>BOOL DestroyDllNode( PNODE ); <br>BOOL DeleteCurrentDllNode( PLIST ); <br> <br> <br>// ************************************************************************ <br>// FUNCTION : DebugEventThread( PDEB_STARTUP_INFO ) <br>// PURPOSE  : Main debug event processing loop <br>// COMMENTS : <br>//   A new debug event thread is created for each Debuggee process. <br>//   Return TRUE (non 0) if success, else FALSE (0) <br>// ************************************************************************ <br>DWORD WINAPI <br>DebugEventThread( PDEB_STARTUP_INFO pDebStartupInfo ) <br>{ <br>  #define BUFFER_SIZE 256 <br> <br>  static BOOL  fFirstTime = TRUE; <br>  static TCHAR szDebuggeeTitle[128]; <br> <br>  DEBUG_EVENT  DebugEvent; <br> <br>  LPTSTR lpszDebugEventBuffer; <br>  LPTSTR lpszTempBuffer; <br> <br>  //-- set the minimum error level for debugging events <br>  SetDebugErrorLevel( Profile.DebugErrorLevel ); <br> <br>  if( fFirstTime ) { <br>    if( !LoadString( Global.hInstance, IDS_OFN_DEBUGGEE_TITLE, szDebuggeeTitle, <br>           sizeof(szDebuggeeTitle)/sizeof(TCHAR) ) ) <br>      ErrorMessageBox( TEXT("LoadString()"), <br>        Global.szApiFailed, szSourceFileName, __LINE__ ); <br>  } <br> <br>  //-- determine if 'attach to' or 'open new' debuggee <br>  if( pDebStartupInfo-&gt;fActive ) { <br>    if( !DebugActiveProcess( pDebStartupInfo-&gt;dwProcessId ) ) <br>      ErrorMessageBox( TEXT("DebugActiveProcess()"), <br>        Global.szApiFailed, szSourceFileName, __LINE__ ); <br>  } <br>  else { <br>    if( !DebugNewProcess( pDebStartupInfo-&gt;lpstrPathName, szDebuggeeTitle ) ) <br>    ExitThread( FALSE ); <br>  } <br> <br>  //-- increment active process count <br>  Global.dwActiveDebuggees++; <br> <br>  //-- create a local heap <br>  { <br>    SYSTEM_INFO SysInfo; <br> <br>    GetSystemInfo( &amp;SysInfo );  // get the system memory page size <br>    hHeap = HeapCreate( (DWORD) NULL, SysInfo.dwPageSize, 1000*SysInfo.dwPageSize ); <br>  } <br> <br>  //-- create and initialize the process list <br>  CreateProcessList( &amp;pProcessList ); <br> <br>  //-- alloc temporary (life of thread) string buffers <br>  lpszDebugEventBuffer = (LPTSTR) HeapAlloc( hHeap, (DWORD) NULL, BUFFER_SIZE ); <br>  lpszTempBuffer = (LPTSTR) HeapAlloc( hHeap, (DWORD) NULL, BUFFER_SIZE ); <br> <br>  // ---------------------------------------------------------------------- <br>  // begin debug event processing loop <br>  // ---------------------------------------------------------------------- <br>  for(;;) { <br> <br>    //-- wait for debug events <br>    if( !WaitForDebugEvent( &amp;DebugEvent, INFINITE ) ) { <br>      ListBoxPrintF( pDebStartupInfo-&gt;hWndListBox, TEXT( "%s" ), TEXT( "Failed to attach to Debuggee..." ) ); <br>      fFinished = TRUE; <br>      break; <br>    } <br> <br>    // -------------------------------------------------------------------- <br>    // display each debug event as it occurs and handle minimal debug <br>    // event processing <br>    // -------------------------------------------------------------------- <br>    MakeCommonDebugEventString( lpszDebugEventBuffer, &amp;DebugEvent ); <br> <br>    switch( DebugEvent.dwDebugEventCode ) { <br> <br>      // ------------------------------------------------------------------ <br>      // exception occured <br>      // ------------------------------------------------------------------ <br>      case EXCEPTION_DEBUG_EVENT: <br> <br>        //-- figure out which type of exception <br>        switch( DebugEvent.u.Exception.ExceptionRecord.ExceptionCode ) { <br> <br>          //--standard exceptions <br>          case EXCEPTION_ACCESS_VIOLATION: <br>            StringAppendF( lpszDebugEventBuffer, TEXT( "%s%s" ), <br>              TEXT( "Exception: " ), TEXT( "Access Violation" ) ); <br>            break; <br> <br>          case EXCEPTION_DATATYPE_MISALIGNMENT: <br>            StringAppendF( lpszDebugEventBuffer, TEXT( "%s%s" ), <br>              TEXT( "Exception: " ), TEXT( "Datatype Misalignment" ) ); <br>            break; <br> <br>          case EXCEPTION_BREAKPOINT: <br>            StringAppendF( lpszDebugEventBuffer, TEXT( "%s%s" ), <br>              TEXT( "Exception: " ), TEXT( "Breakpoint" ) ); <br>            break; <br> <br>          case EXCEPTION_SINGLE_STEP: <br>            StringAppendF( lpszDebugEventBuffer, TEXT( "%s%s" ), <br>              TEXT( "Exception: " ), TEXT( "Single Step" ) ); <br>            break; <br> <br>          case EXCEPTION_ARRAY_BOUNDS_EXCEEDED: <br>            StringAppendF( lpszDebugEventBuffer, TEXT( "%s%s" ), <br>              TEXT( "Exception: " ), TEXT( "Array Bound Exceeded" ) ); <br>            break; <br> <br>          case EXCEPTION_FLT_DENORMAL_OPERAND: <br>            StringAppendF( lpszDebugEventBuffer, TEXT( "%s%s %s" ), <br>              TEXT( "Exception: " ), TEXT( "Floating Point" ), <br>              TEXT( "Denormal Operand" ) ); <br>            break; <br> <br>          case EXCEPTION_FLT_DIVIDE_BY_ZERO: <br>            StringAppendF( lpszDebugEventBuffer, TEXT( "%s%s %s" ), <br>              TEXT( "Exception: " ), TEXT( "Floating Point" ), <br>              TEXT( "Divide By Zero" ) ); <br>            break; <br> <br>          case EXCEPTION_FLT_INEXACT_RESULT: <br>            StringAppendF( lpszDebugEventBuffer, TEXT( "%s%s %s" ), <br>              TEXT( "Exception: " ), TEXT( "Floating Point" ), <br>              TEXT( "Inexact Result" ) ); <br>            break; <br> <br>          case EXCEPTION_FLT_INVALID_OPERATION: <br>            StringAppendF( lpszDebugEventBuffer, TEXT( "%s%s %s" ), <br>              TEXT( "Exception: " ), TEXT( "Floating Point" ), <br>              TEXT( "Invalid Operation" ) ); <br>            break; <br> <br>          case EXCEPTION_FLT_OVERFLOW: <br>            StringAppendF( lpszDebugEventBuffer, TEXT( "%s%s %s" ), <br>              TEXT( "Exception: " ), TEXT( "Floating Point" ), <br>              TEXT( "Overflow" ) ); <br>            break; <br> <br>          case EXCEPTION_FLT_STACK_CHECK: <br>            StringAppendF( lpszDebugEventBuffer, TEXT( "%s%s %s" ), <br>              TEXT( "Exception: " ), TEXT( "Floating Point" ), <br>              TEXT( "Stack Check" ) ); <br>            break; <br> <br>          case EXCEPTION_FLT_UNDERFLOW: <br>            StringAppendF( lpszDebugEventBuffer, TEXT( "%s%s %s" ), <br>              TEXT( "Exception: " ), TEXT( "Floating Point" ), <br>              TEXT( "Underflow" ) ); <br>            break; <br> <br>          case EXCEPTION_INT_DIVIDE_BY_ZERO: <br>            StringAppendF( lpszDebugEventBuffer, TEXT( "%s%s %s" ), <br>              TEXT( "Exception: " ), TEXT( "Integer" ), <br>              TEXT( "Divide By Zero" ) ); <br>            break; <br> <br>          case EXCEPTION_INT_OVERFLOW: <br>            StringAppendF( lpszDebugEventBuffer, TEXT( "%s%s %s" ), <br>              TEXT( "Exception: " ), TEXT( "Integer" ), <br>              TEXT( "Overflow" ) ); <br>            break; <br> <br>          case EXCEPTION_PRIV_INSTRUCTION: <br>            StringAppendF( lpszDebugEventBuffer, TEXT( "%s%s" ), <br>              TEXT( "Exception: " ), TEXT( "Privileged Instruction" ) ); <br>            break; <br> <br>          case EXCEPTION_IN_PAGE_ERROR: <br>            StringAppendF( lpszDebugEventBuffer, TEXT( "%s%s" ), <br>              TEXT( "Exception: " ), TEXT( "In Page Error" ) ); <br>            break; <br> <br>          //-- Debug exceptions <br>          case DBG_TERMINATE_THREAD: <br>            StringAppendF( lpszDebugEventBuffer, TEXT( "%s%s" ), <br>              TEXT( "Debug Exception: " ), TEXT( "Terminate Thread" ) ); <br>            break; <br> <br>          case DBG_TERMINATE_PROCESS: <br>            StringAppendF( lpszDebugEventBuffer, TEXT( "%s%s" ), <br>              TEXT( "Debug Exception: " ), TEXT( "Terminate Process" ) ); <br>            break; <br> <br>          case DBG_CONTROL_C: <br>            StringAppendF( lpszDebugEventBuffer, TEXT( "%s%s" ), <br>              TEXT( "Debug Exception: " ), TEXT( "Control+C" ) ); <br>            break; <br> <br>          case DBG_CONTROL_BREAK: <br>            StringAppendF( lpszDebugEventBuffer, TEXT( "%s%s" ), <br>              TEXT( "Debug Exception: " ), TEXT( "Control+Break" ) ); <br>            break; <br> <br>          //-- RPC exceptions (some) <br>          case RPC_S_UNKNOWN_IF: <br>            StringAppendF( lpszDebugEventBuffer, TEXT( "%s%s" ), <br>              TEXT( "RPC Exception: " ), TEXT( "Unknown Interface" ) ); <br>            break; <br> <br>          case RPC_S_SERVER_UNAVAILABLE: <br>            StringAppendF( lpszDebugEventBuffer, TEXT( "%s%s" ), <br>              TEXT( "RPC Exception: " ), TEXT( "Server Unavailable" ) ); <br>            break; <br> <br>          //-- VDM exceptions (minimal information) <br>          case EXCEPTION_VDM_EVENT:  // see DEBDebug.H for definition <br>            StringAppendF( lpszDebugEventBuffer, TEXT( "%s" ), <br>              TEXT( "VDM Exception: " ) ); <br> <br>          default: <br>            StringAppendF( lpszDebugEventBuffer, TEXT( "%s%s%X%s" ), <br>              TEXT( "Exception: " ), TEXT( "Unknown [0x" ), <br>               DebugEvent.u.Exception.ExceptionRecord.ExceptionCode, <br>               TEXT( "]" ) ); <br>            break; <br> <br>        } <br>        if( Profile.fVerbose ) { <br>          StringAppendF( lpszDebugEventBuffer, TEXT( "\n + %s%d" ), <br>            TEXT( "dwFirstChance: " ), DebugEvent.u.Exception.dwFirstChance ); <br>        } <br>        else { <br>          if( DebugEvent.u.Exception.dwFirstChance != 0 ) <br>            StringAppendF( lpszDebugEventBuffer, TEXT( "%s" ), <br>              TEXT( " - First Chance" ) ); <br>          else <br>            StringAppendF( lpszDebugEventBuffer, TEXT( "%s" ), <br>              TEXT( " - Second Chance" ) ); <br>        } <br>        HandleExceptionEvent( &amp;DebugEvent ); <br>        break; <br> <br>      // ------------------------------------------------------------------ <br>      // new thread started <br>      // ------------------------------------------------------------------ <br>      case CREATE_THREAD_DEBUG_EVENT: <br>        StringAppendF( lpszDebugEventBuffer, TEXT( "%s" ), <br>          TEXT( "Create Thread: " ) ); <br>        if( Profile.fVerbose ) { <br>          StringAppendF( lpszDebugEventBuffer, TEXT( "\n + %s%d\n + %s%X\n + %s%d" ), <br>            TEXT( "hThread:0x" ), DebugEvent.u.CreateThread.hThread, <br>            TEXT( "lpThreadLocalBase:0x" ), DebugEvent.u.CreateThread.lpThreadLocalBase, <br>            TEXT( "lpStartAddress:0x" ), DebugEvent.u.CreateThread.lpStartAddress ); <br>        } <br>        HandleCreateThreadEvent( &amp;DebugEvent ); <br>        break; <br> <br>      // ------------------------------------------------------------------ <br>      // new process started <br>      // ------------------------------------------------------------------ <br>      case CREATE_PROCESS_DEBUG_EVENT: <br>        StringAppendF( lpszDebugEventBuffer, TEXT( "%s" ), <br>          TEXT( "Create Process: " ) ); <br>        if( Profile.fVerbose ) { <br>          StringAppendF( lpszDebugEventBuffer, <br>            TEXT( "\n + %s%X\n + %s%X\n + %s%X\n + %s%X\n + %s%d" ) <br>            TEXT( "\n + %s%d\n + %s%X\n + %s%X\n + %s%X\n + %s%d" ), <br>            TEXT( "hFile:0x" ), DebugEvent.u.CreateProcessInfo.hFile, <br>            TEXT( "hProcess:0x" ), DebugEvent.u.CreateProcessInfo.hProcess, <br>            TEXT( "hThread:0x" ), DebugEvent.u.CreateProcessInfo.hThread, <br>            TEXT( "lpBaseOfImage:0x" ), DebugEvent.u.CreateProcessInfo.lpBaseOfImage, <br>            TEXT( "dwDebugInfoFileOffset: " ), DebugEvent.u.CreateProcessInfo.dwDebugInfoFileOffset, <br>            TEXT( "nDebugInfoSize: " ), DebugEvent.u.CreateProcessInfo.nDebugInfoSize, <br>            TEXT( "lpThreadLocalBase:0x" ), DebugEvent.u.CreateProcessInfo.lpThreadLocalBase, <br>            TEXT( "lpStartAddress:0x" ), DebugEvent.u.CreateProcessInfo.lpStartAddress, <br>            TEXT( "lpImageName:0x" ), DebugEvent.u.CreateProcessInfo.lpImageName, <br>            TEXT( "fUnicode: " ), DebugEvent.u.CreateProcessInfo.fUnicode ); <br>        } <br>        HandleCreateProcessEvent( &amp;DebugEvent ); <br>        break; <br> <br>      // ------------------------------------------------------------------ <br>      // existing thread terminated <br>      // ------------------------------------------------------------------ <br>      case EXIT_THREAD_DEBUG_EVENT: <br>        StringAppendF( lpszDebugEventBuffer, TEXT( "%s" ), <br>          TEXT( "Exit Thread: " ) ); <br>        if( Profile.fVerbose ) { <br>          StringAppendF( lpszDebugEventBuffer, TEXT( "\n + %s%d" ), <br>            TEXT( "dwExitCode: " ), DebugEvent.u.ExitThread.dwExitCode ); <br>        } <br>        else { <br>          StringAppendF( lpszDebugEventBuffer, TEXT( "%s%d" ), <br>            TEXT( "Returned " ), DebugEvent.u.ExitThread.dwExitCode ); <br>        } <br>        HandleExitThreadEvent( &amp;DebugEvent ); <br>        break; <br> <br>      // ------------------------------------------------------------------ <br>      // existing process terminated <br>      // ------------------------------------------------------------------ <br>      case EXIT_PROCESS_DEBUG_EVENT: <br>        StringAppendF( lpszDebugEventBuffer, TEXT( "%s" ), <br>          TEXT( "Exit Process: " ) ); <br>        if( Profile.fVerbose ) { <br>          StringAppendF( lpszDebugEventBuffer, TEXT( "\n + %s%d" ), <br>            TEXT( "dwExitCode: " ), DebugEvent.u.ExitProcess.dwExitCode ); <br>        } <br>        else { <br>          StringAppendF( lpszDebugEventBuffer, TEXT( "%s%d" ), <br>            TEXT( "Returned " ), DebugEvent.u.ExitProcess.dwExitCode ); <br>        } <br>        HandleExitProcessEvent( &amp;DebugEvent ); <br>        break; <br> <br>      // ------------------------------------------------------------------ <br>      // new DLL loaded <br>      // ------------------------------------------------------------------ <br>      case LOAD_DLL_DEBUG_EVENT: <br>        StringAppendF( lpszDebugEventBuffer, TEXT( "%s" ), <br>          TEXT( "Load DLL: " ) ); <br>        lstrcpy( lpszTempBuffer, TEXT("Empty!") ); <br>        GetDllFileName( &amp;DebugEvent, lpszTempBuffer, BUFFER_SIZE ); <br>        StringAppendF( lpszDebugEventBuffer, TEXT( "%s" ), lpszTempBuffer ); <br>        if( Profile.fVerbose ) { <br>          StringAppendF( lpszDebugEventBuffer, <br>            TEXT( "\n + %s%X\n + %s%X\n + %s%d\n + %s%d\n + %s%X\n + %s%d" ), <br>            TEXT( "hFile:0x" ), DebugEvent.u.LoadDll.hFile, <br>            TEXT( "lpBaseOfDll:0x" ), DebugEvent.u.LoadDll.lpBaseOfDll, <br>            TEXT( "dwDebugInfoFileOffset: " ), DebugEvent.u.LoadDll.dwDebugInfoFileOffset, <br>            TEXT( "nDebugInfoSize: " ), DebugEvent.u.LoadDll.nDebugInfoSize, <br>            TEXT( "lpImageName:0x" ), DebugEvent.u.LoadDll.lpImageName, <br>            TEXT( "fUnicode: " ), DebugEvent.u.LoadDll.fUnicode ); <br>        } <br>        HandleLoadDllEvent( &amp;DebugEvent ); <br>        break; <br> <br>      // ------------------------------------------------------------------ <br>      // existing DLL explicitly unloaded <br>      // ------------------------------------------------------------------ <br>      case UNLOAD_DLL_DEBUG_EVENT: <br>        StringAppendF( lpszDebugEventBuffer, TEXT( "%s" ), TEXT( "Unload DLL: " ) ); <br>        GetDllFileNameFromList( &amp;DebugEvent, lpszTempBuffer, BUFFER_SIZE ); <br>        StringAppendF( lpszDebugEventBuffer, TEXT( "%s" ), lpszTempBuffer ); <br>        if( Profile.fVerbose ) { <br>          StringAppendF( lpszDebugEventBuffer, TEXT( "\n + %s%X" ), <br>            TEXT( "lpBaseOfDLL:0x" ), DebugEvent.u.UnloadDll.lpBaseOfDll ); <br>        } <br>        HandleUnloadDllEvent( &amp;DebugEvent ); <br>        break; <br> <br>      // ------------------------------------------------------------------ <br>      // OutputDebugString() occured <br>      // ------------------------------------------------------------------ <br>      case OUTPUT_DEBUG_STRING_EVENT: <br>        StringAppendF( lpszDebugEventBuffer, TEXT( "%s" ), <br>          TEXT( "Output Debug String: " ) ); <br>        GetOutputDebugString( &amp;DebugEvent, lpszTempBuffer, BUFFER_SIZE ); <br>        StringAppendF( lpszDebugEventBuffer, TEXT( "%s" ), lpszTempBuffer ); <br>        if( Profile.fVerbose ) { <br>          StringAppendF( lpszDebugEventBuffer, TEXT( "\n + %s%X\n + %s%d\n + %s%d" ), <br>            TEXT( "lpDebugStringData:0x" ), DebugEvent.u.DebugString.lpDebugStringData, <br>            TEXT( "fUnicode: " ), DebugEvent.u.DebugString.fUnicode, <br>            TEXT( "nDebugStringLength: " ), DebugEvent.u.DebugString.nDebugStringLength ); <br>        } <br>        HandleOutputDebugStringEvent( &amp;DebugEvent ); <br>        break; <br> <br>      // ------------------------------------------------------------------ <br>      // RIP occured <br>      // ------------------------------------------------------------------ <br>      case RIP_EVENT: <br>        StringAppendF( lpszDebugEventBuffer, TEXT( "%s" ), <br>          TEXT( "RIP" ) ); <br>        if( Profile.fVerbose ) { <br>          StringAppendF( lpszDebugEventBuffer, TEXT( "\n + %s%d\n + %s%d" ), <br>            TEXT( "dwError: " ), DebugEvent.u.RipInfo.dwError, <br>            TEXT( "dwType: " ), DebugEvent.u.RipInfo.dwType ); <br>        } <br>        HandleRipEvent( &amp;DebugEvent ); <br>        break; <br> <br>      // ------------------------------------------------------------------ <br>      // unknown debug event occured <br>      // ------------------------------------------------------------------ <br>      default: <br>        StringAppendF( lpszDebugEventBuffer, TEXT( "%s%X%s" ), <br>          TEXT( "Debug Event:Unknown [0x" ), <br>          DebugEvent.dwDebugEventCode, lpszTempBuffer, <br>          TEXT( "]" ) ); <br>        HandleUnknownEvent( &amp;DebugEvent ); <br>        break; <br>    } <br> <br>    //-- insert the debug event string into the listbox <br>    ListBoxPrintF( pDebStartupInfo-&gt;hWndListBox, TEXT( "%s" ), lpszDebugEventBuffer ); <br> <br>    //-- default action, just continue <br>    if( fFinished ) { <br>      fFinished = FALSE;   // reset the value <br>      break; <br>    } <br>    else <br>      ContinueDebugEvent( DebugEvent.dwProcessId, DebugEvent.dwThreadId, <br>        DBG_CONTINUE ); <br>  } <br> <br>  //-- free temporary (life of thread) string buffers <br>  HeapFree( hHeap, (DWORD) NULL, (PVOID) lpszDebugEventBuffer ); <br>  HeapFree( hHeap, (DWORD) NULL, (PVOID) lpszTempBuffer ); <br> <br>  //-- free list <br>  DestroyProcessList( pProcessList ); <br> <br>  //-- free the heap <br>  HeapDestroy( hHeap ); <br> <br>  //-- decrement active process count <br>  Global.dwActiveDebuggees--; <br>  ExitThread( TRUE ); <br> <br>  return( TRUE );  // avoid the "no return value" warning <br>} <br> <br> <br>// ======================================================================== <br>// debug event handling functions <br>// ======================================================================== <br> <br> <br>// ************************************************************************ <br>// FUNCTION : HandleExceptionEvent( LPDEBUG_EVENT lpDebugEvent ) <br>// PURPOSE  : handle EXCEPTION_DEBUG_EVENT <br>// COMMENTS : except for the BreakPoint event, continue and let the <br>//            application or system exception handlers to the work <br>// ************************************************************************ <br>BOOL <br>HandleExceptionEvent( LPDEBUG_EVENT lpDebugEvent ) <br>{ <br>  switch( lpDebugEvent-&gt;u.Exception.ExceptionRecord.ExceptionCode ) { <br> <br>    case EXCEPTION_BREAKPOINT: <br>      HandleBreakPointException( lpDebugEvent ); <br>      break; <br> <br>    default: <br>      ContinueDebugEvent( lpDebugEvent-&gt;dwProcessId, lpDebugEvent-&gt;dwThreadId, <br>        DBG_EXCEPTION_NOT_HANDLED ); <br> <br>  } <br> <br>  return( TRUE ); <br>} <br> <br> <br>// ************************************************************************ <br>// FUNCTION : HandleBreakPointException( LPDEBUG_EVENT lpDebugEvent ) <br>// PURPOSE  : handle the BREAKPOINT exception <br>// COMMENTS : search process list, search thread list, skip over breakpoint <br>// ************************************************************************ <br>BOOL <br>HandleBreakPointException( LPDEBUG_EVENT lpDebugEvent ) <br>{ <br>#if defined(_MIPS_) || defined(_ALPHA_) || defined(_PPC_) <br>  PNODE                  pProcessNode, pSearchProcessNode; <br>  PNODE                  pThreadNode, pSearchThreadNode; <br>  PDEB_PROCESS_NODE_INFO pProcessNodeInfo, pSearchProcessNodeInfo; <br>  PDEB_THREAD_NODE_INFO  pThreadNodeInfo, pSearchThreadNodeInfo; <br>  PDEB_THREAD_LIST_INFO  pThreadListInfo; <br> <br>  AllocProcessNode( &amp;pSearchProcessNode, &amp;pSearchProcessNodeInfo ); <br>  pSearchProcessNodeInfo-&gt;dwProcessId = lpDebugEvent-&gt;dwProcessId; <br>  SetCurrentProcessNode( pProcessList, pSearchProcessNode ); <br>  GetCurrentNode( pProcessList, &amp;pProcessNode ); <br>  pProcessNodeInfo = (PDEB_PROCESS_NODE_INFO) pProcessNode-&gt;pNodeData; <br>  pThreadListInfo = (PDEB_THREAD_LIST_INFO) pProcessNodeInfo-&gt;pThreadList-&gt;pListData; <br>  //-- if no thread nodes then hThread is stored in the process node <br>  if( !pThreadListInfo-&gt;dwActiveThreads ) { <br>    SkipBreakPoint( (pProcessNodeInfo-&gt;ProcessDebugInfo).hThread ); <br>  } <br>  else { <br>    AllocThreadNode( &amp;pSearchThreadNode, &amp;pSearchThreadNodeInfo ); <br>    pSearchThreadNodeInfo-&gt;dwThreadId = lpDebugEvent-&gt;dwThreadId; <br>    SetCurrentThreadNode( pProcessNodeInfo-&gt;pThreadList, pSearchThreadNode ); <br>    GetCurrentNode( pProcessNodeInfo-&gt;pThreadList, &amp;pThreadNode ); <br>    pThreadNodeInfo = (PDEB_THREAD_NODE_INFO) pThreadNode-&gt;pNodeData; <br>    SkipBreakPoint( (pThreadNodeInfo-&gt;ThreadDebugInfo).hThread ); <br>    DestroyThreadNode( pSearchThreadNode ); <br>  } <br>  DestroyProcessNode( pSearchProcessNode ); <br> #else <br>  ContinueDebugEvent( lpDebugEvent-&gt;dwProcessId, lpDebugEvent-&gt;dwThreadId, <br>    DBG_CONTINUE ); <br> #endif <br> <br>  return( TRUE ); <br>} <br> <br> <br>// ************************************************************************ <br>// FUNCTION : HandleCreateThreadEvent( LPDEBUG_EVENT ) <br>// PURPOSE  : handle CREATE_THREAD_DEBUG_EVENT <br>// COMMENTS : search process list, insert new thread node <br>// ************************************************************************ <br>BOOL <br>HandleCreateThreadEvent( LPDEBUG_EVENT lpDebugEvent ) <br>{ <br>  PNODE                  pProcessNode, pSearchProcessNode; <br>  PNODE                  pThreadNode; <br>  PDEB_PROCESS_NODE_INFO pProcessNodeInfo, pSearchProcessNodeInfo; <br>  PDEB_THREAD_NODE_INFO  pThreadNodeInfo; <br> <br>  AllocProcessNode( &amp;pSearchProcessNode, &amp;pSearchProcessNodeInfo ); <br>  pSearchProcessNodeInfo-&gt;dwProcessId = lpDebugEvent-&gt;dwProcessId; <br>  SetCurrentProcessNode( pProcessList, pSearchProcessNode ); <br>  GetCurrentNode( pProcessList, &amp;pProcessNode ); <br>  pProcessNodeInfo = (PDEB_PROCESS_NODE_INFO) pProcessNode-&gt;pNodeData; <br>  AllocThreadNode( &amp;pThreadNode, &amp;pThreadNodeInfo ); <br>  InitThreadNodeInfo( &amp;pThreadNodeInfo, lpDebugEvent ); <br>  InsertThreadNode( pProcessNodeInfo-&gt;pThreadList, pThreadNode ); <br>  DestroyProcessNode( pSearchProcessNode ); <br> <br>  return( TRUE ); <br>} <br> <br> <br>// ************************************************************************ <br>// FUNCTION : HandleCreateProcessEvent( LPDEBUG_EVENT ) <br>// PURPOSE  : handle CREATE_PROCESS_DEBUG_EVENT <br>// COMMENTS : insert new process node <br>// ************************************************************************ <br>BOOL <br>HandleCreateProcessEvent( LPDEBUG_EVENT lpDebugEvent ) <br>{ <br>  PNODE                  pProcessNode; <br>  PDEB_PROCESS_NODE_INFO pProcessNodeInfo; <br> <br>  AllocProcessNode( &amp;pProcessNode, &amp;pProcessNodeInfo ); <br>  InitProcessNodeInfo( &amp;pProcessNodeInfo, lpDebugEvent ); <br>  InsertProcessNode( pProcessList, pProcessNode ); <br> <br>  return( TRUE ); <br>} <br> <br> <br>// ************************************************************************ <br>// FUNCTION : HandleExitThreadEvent( LPDEBUG_EVENT ) <br>// PURPOSE  : handle EXIT_THREAD_DEBUG_EVENT <br>// COMMENTS : search process list, search thread list, delete existing <br>//            thread node <br>// ************************************************************************ <br>BOOL <br>HandleExitThreadEvent( LPDEBUG_EVENT lpDebugEvent ) <br>{ <br>  PNODE                  pProcessNode, pSearchProcessNode; <br>  PNODE                  pSearchThreadNode; <br>  PDEB_PROCESS_NODE_INFO pProcessNodeInfo, pSearchProcessNodeInfo; <br>  PDEB_THREAD_NODE_INFO  pSearchThreadNodeInfo; <br> <br>  AllocProcessNode( &amp;pSearchProcessNode, &amp;pSearchProcessNodeInfo ); <br>  pSearchProcessNodeInfo-&gt;dwProcessId = lpDebugEvent-&gt;dwProcessId; <br>  SetCurrentProcessNode( pProcessList, pSearchProcessNode ); <br>  GetCurrentNode( pProcessList, &amp;pProcessNode ); <br>  pProcessNodeInfo = (PDEB_PROCESS_NODE_INFO) pProcessNode-&gt;pNodeData; <br>  AllocThreadNode( &amp;pSearchThreadNode, &amp;pSearchThreadNodeInfo ); <br>  pSearchThreadNodeInfo-&gt;dwThreadId = lpDebugEvent-&gt;dwThreadId; <br>  DeleteThreadNode( pProcessNodeInfo-&gt;pThreadList, pSearchThreadNode ); <br>  DestroyThreadNode( pSearchThreadNode ); <br>  DestroyProcessNode( pSearchProcessNode ); <br> <br>  return( TRUE ); <br>} <br> <br> <br>// ************************************************************************ <br>// FUNCTION : HandleExitProcessEvent( LPDEBUG_EVENT ) <br>// PURPOSE  : handle EXIT_PROCESS_DEBUG_EVENT <br>// COMMENTS : search process list, delete existing process node, <br>// ************************************************************************ <br>BOOL <br>HandleExitProcessEvent( LPDEBUG_EVENT lpDebugEvent ) <br>{ <br>  PNODE                  pSearchProcessNode; <br>  PDEB_PROCESS_NODE_INFO pSearchProcessNodeInfo; <br>  PDEB_PROCESS_LIST_INFO pProcessListInfo; <br> <br>  AllocProcessNode( &amp;pSearchProcessNode, &amp;pSearchProcessNodeInfo ); <br>  pSearchProcessNodeInfo-&gt;dwProcessId = lpDebugEvent-&gt;dwProcessId; <br>  DeleteProcessNode( pProcessList, pSearchProcessNode ); <br>  //-- if last process? free all temporary memory, exit thread <br>  pProcessListInfo = (PDEB_PROCESS_LIST_INFO) pProcessList-&gt;pListData; <br>  if( !pProcessListInfo-&gt;dwActiveProcesses ) <br>    fFinished = TRUE; <br>  DestroyProcessNode( pSearchProcessNode ); <br> <br>  return( TRUE ); <br>} <br> <br> <br>// ************************************************************************ <br>// FUNCTION : HandleLoadDllEvent( LPDEBUG_EVENT ) <br>// PURPOSE  : handle LOAD_DLL_DEBUG_EVENT <br>// COMMENTS : search process list, insert new DLL node <br>// ************************************************************************ <br>BOOL <br>HandleLoadDllEvent( LPDEBUG_EVENT lpDebugEvent ) <br>{ <br>  PNODE                  pProcessNode, pSearchProcessNode; </code></pre>
<p>
</p>
<pre><code>PNODE                  pDllNode; <br>  PDEB_PROCESS_NODE_INFO pProcessNodeInfo, pSearchProcessNodeInfo; <br>  PDEB_DLL_NODE_INFO     pDllNodeInfo; <br> <br>  AllocProcessNode( &amp;pSearchProcessNode, &amp;pSearchProcessNodeInfo ); <br>  pSearchProcessNodeInfo-&gt;dwProcessId = lpDebugEvent-&gt;dwProcessId; <br>  SetCurrentProcessNode( pProcessList, pSearchProcessNode ); <br>  GetCurrentNode( pProcessList, &amp;pProcessNode ); <br>  pProcessNodeInfo = (PDEB_PROCESS_NODE_INFO) pProcessNode-&gt;pNodeData; <br>  AllocDllNode( &amp;pDllNode, &amp;pDllNodeInfo ); <br>  InitDllNodeInfo( &amp;pDllNodeInfo, lpDebugEvent ); <br>  InsertDllNode( pProcessNodeInfo-&gt;pDllList, pDllNode ); <br>  DestroyProcessNode( pSearchProcessNode ); <br> <br>  return( TRUE ); <br>} <br> <br> <br>// ************************************************************************ <br>// FUNCTION : HandleUnloadDllEvent( LPDEBUG_EVENT ) <br>// PURPOSE  : handle UNLOAD_DLL_DEBUG_EVENT <br>// COMMENTS : search process list, search DLL list, delete existing DLL <br>//            node <br>// ************************************************************************ <br>BOOL <br>HandleUnloadDllEvent( LPDEBUG_EVENT lpDebugEvent ) <br>{ <br>  PNODE                  pProcessNode, pSearchProcessNode; <br>  PNODE                  pSearchDllNode; <br>  PDEB_PROCESS_NODE_INFO pProcessNodeInfo, pSearchProcessNodeInfo; <br>  PDEB_DLL_NODE_INFO     pSearchDllNodeInfo; <br> <br>  AllocProcessNode( &amp;pSearchProcessNode, &amp;pSearchProcessNodeInfo ); <br>  pSearchProcessNodeInfo-&gt;dwProcessId = lpDebugEvent-&gt;dwProcessId; <br>  SetCurrentProcessNode( pProcessList, pSearchProcessNode ); <br>  GetCurrentNode( pProcessList, &amp;pProcessNode ); <br>  pProcessNodeInfo = (PDEB_PROCESS_NODE_INFO) pProcessNode-&gt;pNodeData; <br>  AllocDllNode( &amp;pSearchDllNode, &amp;pSearchDllNodeInfo ); <br>  pSearchDllNodeInfo-&gt;DllDebugInfo.lpBaseOfDll = lpDebugEvent-&gt;u.UnloadDll.lpBaseOfDll; <br>  DeleteDllNode( pProcessNodeInfo-&gt;pDllList, pSearchDllNode ); <br>  DestroyDllNode( pSearchDllNode ); <br>  DestroyProcessNode( pSearchProcessNode ); <br> <br>  return( TRUE ); <br>} <br> <br> <br>// ************************************************************************ <br>// FUNCTION : HandleOutputDebugStringEvent( LPDEBUG_EVENT ) <br>// PURPOSE  : handle OUTPUT_DEBUG_STRING_EVENT <br>// COMMENTS : do nothing <br>// ************************************************************************ <br>BOOL <br>HandleOutputDebugStringEvent( LPDEBUG_EVENT lpDebugEvent ) <br>{ <br>  return( TRUE ); <br>} <br> <br> <br>// ************************************************************************ <br>// FUNCTION : HandleRipEvent( LPDEBUG_EVENT ) <br>// PURPOSE  : handle RIP_EVENT <br>// COMMENTS : do nothing <br>// ************************************************************************ <br>BOOL <br>HandleRipEvent( LPDEBUG_EVENT lpDebugEvent ) <br>{ <br>  return( TRUE ); <br>} <br> <br> <br>// ************************************************************************ <br>// FUNCTION : HandleUnknownEvent( LPDEBUG_EVENT ) <br>// PURPOSE  : handle all unknown debug events <br>// COMMENTS : do nothing <br>// ************************************************************************ <br>BOOL <br>HandleUnknownEvent( LPDEBUG_EVENT lpDebugEvent ) <br>{ <br>  return( TRUE ); <br>} <br> <br> <br>// ======================================================================== <br>// misc debug event helper functions <br>// ======================================================================== <br> <br> <br>// ************************************************************************ <br>// FUNCTION : DebugNewProcess( LPTSTR, LPTSTR ) <br>// PURPOSE  : starts a new process as a debuggee <br>// COMMENTS : <br>// ************************************************************************ <br>BOOL <br>DebugNewProcess( LPTSTR lpszFileName, LPTSTR lpszTitle ) <br>{ <br>  static STARTUPINFO           StartupInfo; <br>  static LPSTARTUPINFO         lpStartupInfo = &amp;StartupInfo; <br>  static PROCESS_INFORMATION   ProcessInfo; <br>  static LPPROCESS_INFORMATION lpProcessInfo = &amp;ProcessInfo; <br> <br>  lpStartupInfo-&gt;cb          = sizeof( STARTUPINFO ); <br>  lpStartupInfo-&gt;lpDesktop   = NULL; <br>  lpStartupInfo-&gt;lpTitle     = lpszTitle; <br>  lpStartupInfo-&gt;dwX         = 0; <br>  lpStartupInfo-&gt;dwY         = 0; <br>  lpStartupInfo-&gt;dwXSize     = 0; <br>  lpStartupInfo-&gt;dwYSize     = 0; <br>  lpStartupInfo-&gt;dwFlags     = (DWORD) NULL; <br>  lpStartupInfo-&gt;wShowWindow = SW_SHOWDEFAULT; <br> <br>  lpProcessInfo-&gt;hProcess = NULL; <br> <br>  //-- create the Debuggee process instead <br>  if( !CreateProcess( <br>         NULL, <br>         lpszFileName, <br>         (LPSECURITY_ATTRIBUTES) NULL, <br>         (LPSECURITY_ATTRIBUTES) NULL, <br>         TRUE, <br>         Profile.DebugMode | Profile.DebuggeePriority | CREATE_NEW_CONSOLE, <br>         (LPVOID) NULL, <br>         (LPTSTR) NULL, <br>         lpStartupInfo, lpProcessInfo ) ) { <br> <br>    switch( GetLastError() ) { <br> <br>      case ERROR_FILE_NOT_FOUND: <br>        MessageBox( GetDesktopWindow(), TEXT( "This file does not exist." ), <br>          TEXT( "Open File Error" ), MB_OK | MB_APPLMODAL | MB_SETFOREGROUND ); <br>        break; <br>      case ERROR_ACCESS_DENIED: <br>        MessageBox( GetDesktopWindow(), TEXT( "Access denied." ), <br>          TEXT( "Open File Error" ), MB_OK | MB_APPLMODAL | MB_SETFOREGROUND ); <br>        break; <br>      case ERROR_FILE_INVALID: <br>        MessageBox( GetDesktopWindow(), TEXT( "Invalid file." ), <br>          TEXT( "Open File Error" ), MB_OK | MB_APPLMODAL | MB_SETFOREGROUND ); <br>        break; <br>      case ERROR_FILE_CORRUPT: <br>        MessageBox( GetDesktopWindow(), TEXT( "The file is corrupt." ), <br>          TEXT( "Open File Error" ), MB_OK | MB_APPLMODAL | MB_SETFOREGROUND ); <br>        break; <br>      case ERROR_BAD_EXE_FORMAT: <br>        MessageBox( GetDesktopWindow(), TEXT( "The file has a bad format." ), <br>          TEXT( "Open File Error" ), MB_OK | MB_APPLMODAL | MB_SETFOREGROUND ); <br>        break; <br>      default: <br>        ErrorMessageBox( TEXT( "CreateProcess()" ), <br>          Global.szApiFailed, szSourceFileName, __LINE__ ); <br>        break; <br> <br>    } <br>    return( FALSE ); <br> <br>  } <br>  else { <br>    CloseHandle( ProcessInfo.hProcess ); <br>    CloseHandle( ProcessInfo.hThread ); <br>  } <br> <br>  return( TRUE <br> ); <br>} <br> <br> <br>// ************************************************************************ <br>// FUNCTION : GetDllFileName( LPDEBUG_EVENT, LPTSTR, DWORD ) <br>// PURPOSE  : get DLL filename when LOAD_DLL_DEBUG_EVENT occurs <br>// COMMENTS : search process list, get DLL name from header <br>// ************************************************************************ <br>BOOL <br>GetDllFileName( LPDEBUG_EVENT lpDebugEvent, LPTSTR lpszBuffer, <br>  DWORD cchBuffer ) <br>{ <br>  PNODE                  pProcessNode, pSearchProcessNode; <br>  PDEB_PROCESS_NODE_INFO pProcessNodeInfo, pSearchProcessNodeInfo; <br> <br>  AllocProcessNode( &amp;pSearchProcessNode, &amp;pSearchProcessNodeInfo ); <br>  pSearchProcessNodeInfo-&gt;dwProcessId = lpDebugEvent-&gt;dwProcessId; <br>  SetCurrentProcessNode( pProcessList, pSearchProcessNode ); <br>  GetCurrentNode( pProcessList, &amp;pProcessNode ); <br>  pProcessNodeInfo = (PDEB_PROCESS_NODE_INFO) pProcessNode-&gt;pNodeData; <br>  GetModuleFileNameFromHeader( <br>    pProcessNodeInfo-&gt;ProcessDebugInfo.hProcess, <br>    lpDebugEvent-&gt;u.LoadDll.hFile, <br>    (DWORD) lpDebugEvent-&gt;u.LoadDll.lpBaseOfDll, <br>    lpszBuffer, cchBuffer); <br>  DestroyProcessNode( pSearchProcessNode ); <br> <br>  return( TRUE ); <br>} <br> <br> <br>// ************************************************************************ <br>// FUNCTION : GetDllFileNameFromList( LPDEBUG_EVENT, LPTSTR, DWORD ) <br>// PURPOSE  : get DLL filename when UNLOAD_DLL_DEBUG_EVENT occurs <br>// COMMENTS : search process list, search DLL list, get DLL name <br>// ************************************************************************ <br>BOOL <br>GetDllFileNameFromList( LPDEBUG_EVENT lpDebugEvent, LPTSTR lpszBuffer, <br>  DWORD cchBuffer ) <br>{ <br>  PNODE                  pProcessNode, pSearchProcessNode; <br>  PNODE                  pDllNode, pSearchDllNode; <br>  PDEB_PROCESS_NODE_INFO pProcessNodeInfo, pSearchProcessNodeInfo; <br>  PDEB_DLL_NODE_INFO     pDllNodeInfo, pSearchDllNodeInfo; <br> <br>  UNREFERENCED_PARAMETER( cchBuffer ); <br> <br>  AllocProcessNode( &amp;pSearchProcessNode, &amp;pSearchProcessNodeInfo ); <br>  pSearchProcessNodeInfo-&gt;dwProcessId = lpDebugEvent-&gt;dwProcessId; <br>  SetCurrentProcessNode( pProcessList, pSearchProcessNode ); <br>  GetCurrentNode( pProcessList, &amp;pProcessNode ); <br>  pProcessNodeInfo = (PDEB_PROCESS_NODE_INFO) pProcessNode-&gt;pNodeData; <br>  AllocDllNode( &amp;pSearchDllNode, &amp;pSearchDllNodeInfo ); <br>  pSearchDllNodeInfo-&gt;DllDebugInfo.lpBaseOfDll = lpDebugEvent-&gt;u.UnloadDll.lpBaseOfDll; <br>  SetCurrentDllNode( pProcessNodeInfo-&gt;pDllList, pSearchDllNode ); <br>  GetCurrentNode( pProcessNodeInfo-&gt;pDllList, &amp;pDllNode ); <br>  pDllNodeInfo = (PDEB_DLL_NODE_INFO) pDllNode-&gt;pNodeData; <br>  lstrcpy( lpszBuffer, pDllNodeInfo-&gt;lpstrFileName ); <br> <br>  return( TRUE ); <br>} <br> <br> <br>// ************************************************************************ <br>// FUNCTION : GetOutputDebugString( LPDEBUG_EVENT, LPTSTR, DWORD ) <br>// PURPOSE  : get the output debug string from the debuggee when <br>//            OUTPUT_DEBUG_STRING_EVENT occurs <br>// COMMENTS : search process list, read the string from the debuggee <br>// ************************************************************************ <br>BOOL <br>GetOutputDebugString( LPDEBUG_EVENT lpDebugEvent, LPTSTR lpszBuffer, <br>  DWORD cchBuffer ) <br>{ <br>  PNODE                  pProcessNode, pSearchProcessNode; <br>  PDEB_PROCESS_NODE_INFO pProcessNodeInfo, pSearchProcessNodeInfo; <br>  DWORD dwNumberOfBytesRead; <br> <br>  UNREFERENCED_PARAMETER( cchBuffer ); <br> <br>  AllocProcessNode( &amp;pSearchProcessNode, &amp;pSearchProcessNodeInfo ); <br>  pSearchProcessNodeInfo-&gt;dwProcessId = lpDebugEvent-&gt;dwProcessId; <br>  SetCurrentProcessNode( pProcessList, pSearchProcessNode ); <br>  GetCurrentNode( pProcessList, &amp;pProcessNode ); <br>  pProcessNode = (PNODE) pProcessList-&gt;pCurrentNode; <br>  pProcessNodeInfo = (PDEB_PROCESS_NODE_INFO) pProcessNode-&gt;pNodeData; <br>  ReadProcessMemory( <br>    pProcessNodeInfo-&gt;ProcessDebugInfo.hProcess, <br>    lpDebugEvent-&gt;u.DebugString.lpDebugStringData, <br>    lpszBuffer, lpDebugEvent-&gt;u.DebugString.nDebugStringLength, <br>    &amp;dwNumberOfBytesRead ); <br>  DestroyProcessNode( pSearchProcessNode ); <br> <br>  return( TRUE ); <br>} <br> <br> <br>// ************************************************************************ <br>// FUNCTION : GetModuleFileNameFromHeader( HANDLE, HANDLE, DWORD, LPTSTR, DWORD ) <br>// PURPOSE  : Retrieves the DLL module name for a given file handle of a <br>//            the module.  Reads the module name from the EXE header. <br>// COMMENTS : <br>//   Retrieves only the module name and not the pathname.  Returns the <br>//   number of characters copies to the buffer, else returns 0. <br>// ************************************************************************ <br>DWORD <br>GetModuleFileNameFromHeader( HANDLE hProcess, HANDLE hFile, DWORD BaseOfDll, <br>  LPTSTR lpszPath, DWORD cchPath ) <br>{ <br>  #define IMAGE_SECOND_HEADER_OFFSET    (15 * sizeof(ULONG)) // relative to file beginning <br>  #define IMAGE_BASE_OFFSET             (13 * sizeof(DWORD)) // relative to PE header base <br>  #define IMAGE_EXPORT_TABLE_RVA_OFFSET (30 * sizeof(DWORD)) // relative to PE header base <br>  #define IMAGE_NAME_RVA_OFFSET         offsetof(IMAGE_EXPORT_DIRECTORY, Name) <br> <br>  WORD   DosSignature; <br>  DWORD  NtSignature; <br>  DWORD  dwNumberOfBytesRead = 0; <br>  DWORD  PeHeader, ImageBase, ExportTableRVA, NameRVA; <br> <br>  //-- verify that the handle is not NULL <br>  if( !hFile ) { <br>    lstrcpy( lpszPath, TEXT("Invalid File Handle") ); <br>    return( 0 ); <br>  } <br> <br>  //-- verify that the handle is for a disk file <br>  if( GetFileType(hFile) != FILE_TYPE_DISK ) { <br>    lstrcpy( lpszPath, TEXT("Invalid File Type") ); <br>    return( 0 ); <br>  } <br> <br>  //-- Extract the filename from the EXE header <br>  SetFilePointer( hFile, 0L, NULL, FILE_BEGIN ); <br>  ReadFile( hFile, &amp;DosSignature, sizeof(DosSignature), &amp;dwNumberOfBytesRead, <br>    (LPOVERLAPPED) NULL); <br> <br>  //-- verify DOS signature found <br>  if( DosSignature != IMAGE_DOS_SIGNATURE ) { <br>    wsprintf( lpszPath, TEXT( "Bad MZ Signature: 0x%x" ), DosSignature ); <br>    return( 0 ); <br>  } <br> <br>  SetFilePointer( hFile, IMAGE_SECOND_HEADER_OFFSET, (LPLONG) NULL, <br>    FILE_BEGIN ); <br>  ReadFile( hFile, &amp;PeHeader, sizeof(PeHeader), &amp;dwNumberOfBytesRead, <br>    (LPOVERLAPPED) NULL ); <br>  SetFilePointer( hFile, PeHeader, (LPLONG) NULL, FILE_BEGIN ); <br>  ReadFile( hFile, &amp;NtSignature, sizeof(NtSignature), &amp;dwNumberOfBytesRead, <br>    (LPOVERLAPPED) NULL); <br> <br>  //-- verify Windows NT (PE) signature found <br>  if( NtSignature != IMAGE_NT_SIGNATURE ) { <br>    wsprintf( lpszPath, TEXT( "Bad PE Signature: 0x%x" ), DosSignature ); <br>    return( 0 ); <br>  } <br> <br>  SetFilePointer( hFile, PeHeader + IMAGE_BASE_OFFSET, (LPLONG) NULL, <br>    FILE_BEGIN ); <br>  ReadFile( hFile, &amp;ImageBase, sizeof(ImageBase), &amp;dwNumberOfBytesRead, <br>    (LPOVERLAPPED) NULL); <br>  SetFilePointer( hFile, PeHeader + IMAGE_EXPORT_TABLE_RVA_OFFSET, <br>    (LPLONG) NULL, FILE_BEGIN ); <br>  ReadFile( hFile, &amp;ExportTableRVA, sizeof(ExportTableRVA), <br>    &amp;dwNumberOfBytesRead, (LPOVERLAPPED) NULL); <br> <br>  //-- now read from the virtual address space in the process <br>  ReadProcessMemory( hProcess, <br>     (LPVOID) (BaseOfDll + ExportTableRVA + IMAGE_NAME_RVA_OFFSET), <br>     &amp;NameRVA, sizeof(NameRVA), &amp;dwNumberOfBytesRead ); <br>  lstrcpy( lpszPath, TEXT("Empty!") ); <br>  if( !ReadProcessMemory( hProcess, <br>         (LPVOID) (BaseOfDll + NameRVA), <br>         lpszPath, cchPath, &amp;dwNumberOfBytesRead ) ) <br>     lstrcpy( lpszPath, TEXT("Access Denied!") ); <br> <br>  return( dwNumberOfBytesRead ); <br>} <br> <br> <br>#if defined(_MIPS_) || defined(_ALPHA_) || defined(_PPC_) <br>// ************************************************************************ <br>// FUNCTION : SkipThreadBreakPoint( HANDLE ); <br>// PURPOSE  : Skip over the break point instruction belonging to <br>//            hThread. <br>// COMMENTS : <br>//   Only the MIPS R4x00 and DEC Alpha AXP require this. <br>// ************************************************************************ <br>BOOL <br>SkipBreakPoint( HANDLE hThread ) <br>{ <br>  static CONTEXT Context; <br> <br>  Context.ContextFlags = CONTEXT_CONTROL; <br>  if( !GetThreadContext( hThread, &amp;Context ) ) <br>    return( FALSE ); <br>#if defined(_PPC_) <br>  Context.Iar += 4L;  // Iar is the PC (program counter) <br>#else <br>  Context.Fir += 4L;  // Fir is the PC (program counter) <br>                      // BREAK (breakpoint instruction) occupies 4 bytes <br>#endif <br> <br>  // ----------------------------------------------------------------------- <br>  //  Below would be equivalent for the Intel 80x86 (if it were necessary) <br>  //  however the Intel x86 automatically increments ip past the 'int 3': <br>  //  Context.Eip += 1L;  // Eip is the PC (program counter) <br>  //  // int 3 (breakpoint instruction) occupies 1 byte <br>  // ----------------------------------------------------------------------- <br> <br>  if( !SetThreadContext( hThread, &amp;Context ) ) <br>    return( FALSE ); <br> <br>  return( TRUE ); <br>} <br>#endif <br> <br> <br> <br>// ======================================================================== <br>// wrapper functions to the linked list services <br>// ======================================================================== <br> <br>// ======================================================================== <br>// Debug Event Browser Data Structure Overview <br>// ------------------------------------------- <br>// <br>// The Debug Event Browser (DEB) maintains a rather involved data structure <br>// to store various debug event and debuggee process information.  It <br>// attempts to encapsulate the intricacies of what makes a process based on <br>// the occuring events.  Much of this stored information is never utilized <br>// by the Debug Event Browser but it is included to demonstrate what types <br>// of debug event may be useful to a full blown debugger application. <br>// <br>// This data structure uses the generalized, sorted, double-linked list <br>// package provided with the sample.  Each list can store list-specific <br>// instance data, list-specific node data, and maintain various pointers <br>// to these nodes.  The list is sorted via the insertion sort method where <br>// the programmer defines the list-specific sort function whose purpose is <br>// to compare two given nodes and return their relative sort location.  The <br>// list package in generalized in the sense that the list and node-specific <br>// data type is not known to this package at compile time or at runtime. <br>// The application programmer is merely responsible for defining the list <br>// and node-specific data structures and the sorting and optional searching <br>// functions and the list package keeps track of these nodes and provides <br>// easy access to them. <br>// <br>// DEB uses this list package to create three unique list types: process, <br>// thread and DLL lists. <br>// <br>// The backbone of the data structure is the process list.  The nodes of <br>// the process list are the individual debuggee processes.  DEB allows <br>// debugging (or should I say debug event browsing) of other processes that <br>// are spawned by the initial debuggee.  Thus each debug session may have <br>// multiple debuggees and thus the process becomes the logical node unit. <br>// <br>// A visual diagram of the process list is as follows: <br>// <br>//                 (ProcessList) <br>//                      | <br>//                      | <br>//                      v <br>//                 +-----------------+           +----------------------+ <br>//                 | -ProcessList-   |           | -ListData-           | <br>//                 |                 |           |                      | <br>//                 | ListData--------+----------&gt;| ActiveProcessCount=N | <br>//           +-----+-FirstNode       |           +----------------------+ <br>//           |   +-+ CurrentNode     | <br>//           |   | | LastNode--------+-----------------------+ <br>//           |   | | OrderFunction=&amp; |                       | <br>//           |   | | ListError=0     |                       | <br>//           |   | +-----------------+                       | <br>//           |   |                                           | <br>//           |   +-------------------+                       | <br>//           |                       |                       | <br>//           v                       v                       v <br>//         +------------+     +------------+             +------------+ <br>// NULL &lt;- |ProcessNode1| &lt;=&gt; |ProcessNode2| &lt;=&gt; ... &lt;=&gt; |ProcessNodeN| -&gt; NULL <br>//         +------------+     +------------+             +------------+ <br>// <br>// Each process node also contains two lists: the thread list and the DLL list. <br>// This node also stores some of the relevent debug event information <br>// particular to the create process event.  Visually it is as follows: <br>// <br>//    +------------------+         +--------------+ <br>//    | -ProcessNode-    | +------&gt;| -ThreadList- | <br>//    |                  | |       +--------------+ <br>//    | ProcessID=0      | | <br>//    | ThreadID=0       | |       +-----------+ <br>//    | FileName=""      | |   +--&gt;| -DllList- | <br>//    | PathName=""      | |   |   +-----------+ <br>//    | ThreadList-------+-+   | <br>//    | DllList----------+-----+   +-------------------+ <br>//    | ProcessDebugInfo-+--------&gt;|-ProcessDebugInfo- | <br>//    +------------------+         +-------------------+ <br>// <br>// Much like the process list, the visual diagram of the thread list is as <br>// follows: <br>// <br>//                 +-----------------+           +---------------------+ <br>//                 | -ThreadList-    |           | -ListData-          | <br>//                 |                 |           |                     | <br>//                 | ListData--------+----------&gt;| ActiveThreadCount=N | <br>//           +-----+-FirstNode       |           +---------------------+ <br>//           |   +-+ CurrentNode     | <br>//           |   | | LastNode--------+-----------------------+ <br>//           |   | | OrderFunction=&amp; |                       | <br>//           |   | | ListError=0     |                       | <br>//           |   | +-----------------+                       | <br>//           |   |                                           | <br>//           |   +-------------------+                       | <br>//           |                       |                       | <br>//           v                       v                       v <br>//          +-----------+     +-----------+             +-----------+ <br>//  NULL &lt;- |ThreadNode1| &lt;=&gt; |ThreadNode2| &lt;=&gt; ... &lt;=&gt; |ThreadNodeN| -&gt; NULL <br>//          +-----------+     +-----------+             +-----------+ <br>// <br>// The thread nodes store some of the relevent debug event information <br>// particular to the create thread event.  Visually it is as follows: <br>// <br>//    +--------------------+ <br>//    | -ThreadNode-       | <br>//    |                    | <br>//    | ProcessID=0        | <br>//    | ThreadID=0         | <br>//    | ThreadDebugInfo={} | <br>//    +--------------------+ <br>// <br>// Much like the process and thread lists, the visual diagram of the Dll list <br>// is as follows: <br>// <br>//                 +-----------------+           +------------------+ <br>//                 | -DllList-       |           | -ListData-       | <br>//                 |                 |           |                  | <br>//                 | ListData--------+----------&gt;| ActiveDllCount=N | <br>//           +-----+-FirstNode       |           +------------------+ <br>//           |   +-+ CurrentNode     | <br>//           |   | | LastNode--------+-----------------+ <br>//           |   | | OrderFunction=&amp; |                 | <br>//           |   | | ListError=0     |                 | <br>//           |   | +-----------------+                 | <br>//           |   |                                     | <br>//           |   +-------------+                       | <br>//           |                 |                       | <br>//           v                 v                       v <br>//          +--------+     +--------+             +--------+ <br>//  NULL &lt;- |DllNode1| &lt;=&gt; |DllNode2| &lt;=&gt; ... &lt;=&gt; |DllNodeN| -&gt; NULL <br>//          +--------+     +--------+             +--------+ <br>// <br>// The Dll nodes store some of the relevent debug event information particular <br>// to the Dll load event.  Visually it is as follows: <br>// <br>//    +----------------+ <br>//    | -DllNode-      | <br>//    |                | <br>//    | FileName=""    | <br>//    | PathName=""    | <br>//    | DllDebugInfo={}| <br>//    +----------------+ <br>// <br>// ======================================================================== <br> <br>// ------------------------------------------------------------------------ <br>// Process list and node specific linked list wrapper functions <br>// ------------------------------------------------------------------------ <br> <br> <br>// ************************************************************************ <br>// FUNCTION : ProcessOrderFunction( PNODE, PNODE ); <br>// PURPOSE  : Provides the sorting/search logic for the double linked <br>//            list package. <br>// COMMENTS : <br>//   Sorted by process ID value <br>// ************************************************************************ <br>int <br>ProcessOrderFunction( PNODE pNode1, PNODE pNode2 ) <br>{ <br>  PDEB_PROCESS_NODE_INFO pProcessNodeInfo1 = pNode1-&gt;pNodeData; <br>  PDEB_PROCESS_NODE_INFO pProcessNodeInfo2 = pNode2-&gt;pNodeData; <br> <br>  if( pProcessNodeInfo1-&gt;dwProcessId &lt; pProcessNodeInfo2-&gt;dwProcessId ) <br>    return( LIST_LEFT_OF ); <br> <br>  if( pProcessNodeInfo1-&gt;dwProcessId &gt; pProcessNodeInfo2-&gt;dwProcessId ) <br>    return( LIST_RIGHT_OF ); <br> <br>  return( LIST_MATCH ); <br>} <br> <br> <br>// ************************************************************************ <br>// FUNCTION : CreateProcessList( PLIST* ) <br>// PURPOSE  : <br>// COMMENTS : <br>// <br>// ************************************************************************ <br>BOOL <br>CreateProcessList( PLIST* ppProcessList ) <br>{ <br>  PDEB_PROCESS_LIST_INFO pProcessListInfo; <br> <br>  //-- create list <br>  CreateList( ppProcessList, ProcessOrderFunction ); <br> <br>  //-- alloc info data <br>  pProcessListInfo = (PDEB_PROCESS_LIST_INFO) HeapAlloc( hHeap, (DWORD) NULL, <br>                                                sizeof( DEB_PROCESS_LIST_INFO ) ); <br>  (*ppProcessList)-&gt;pListData = pProcessListInfo; <br> <br>  //-- init info data <br>  pProcessListInfo-&gt;dwActiveProcesses = 0; <br> <br>  return( TRUE ); <br>} <br> <br> <br>// ************************************************************************ <br>// FUNCTION : DestroyProcessList( PLIST ) <br>// PURPOSE  : <br>// COMMENTS : <br>// <br>// ************************************************************************ <br>BOOL <br>DestroyProcessList( PLIST pProcessList ) <br>{ <br>  PDEB_PROCESS_LIST_INFO pProcessListInfo = pProcessList-&gt;pListData; <br>  PNODE                  pDeleteNode; <br> <br>  //-- make sure all nodes are removed first <br>  while( pProcessListInfo-&gt;dwActiveProcesses ) { <br>    GetCurrentNode( pProcessList, &amp;pDeleteNode ); <br>    DeleteCurrentProcessNode( pProcessList ); <br>  } <br> <br>  //-- free info data <br>  HeapFree( hHeap, (DWORD) NULL, (PVOID) pProcessListInfo ); <br> <br>  //-- destroy list <br>  DestroyList( pProcessList ); <br> <br>  return( TRUE ); <br>} <br> <br> <br>// ************************************************************************ <br>// FUNCTION : AllocProcessNode( PNODE*, PDEB_PROCESS_NODE_INFO* ) <br>// PURPOSE  : <br>// COMMENTS : <br>// <br>// ************************************************************************ <br>BOOL <br>AllocProcessNode( PNODE* ppProcessNode, PDEB_PROCESS_NODE_INFO* ppProcessNodeInfo ) <br>{ <br>  //-- create node <br>  CreateNode( ppProcessNode ); <br> <br>  //-- alloc info data <br>  *ppProcessNodeInfo = (PDEB_PROCESS_NODE_INFO) HeapAlloc( hHeap, (DWORD) NULL, <br>                                              sizeof( DEB_PROCESS_NODE_INFO ) ); <br>  (*ppProcessNode)-&gt;pNodeData = *(ppProcessNodeInfo); <br> <br>  (*ppProcessNodeInfo)-&gt;lpstrFileName = (LPTSTR) HeapAlloc( hHeap, (DWORD) NULL, <br>                                               (DWORD) MAX_PATH ); <br>  (*ppProcessNodeInfo)-&gt;lpstrPathName = (LPTSTR) HeapAlloc( hHeap, (DWORD) NULL, <br>                                               (DWORD) MAX_PATH ); <br>  CreateThreadList( &amp;((*ppProcessNodeInfo)-&gt;pThreadList) ); <br>  CreateDllList( &amp;((*ppProcessNodeInfo)-&gt;pDllList) ); <br> <br>  return( TRUE ); <br>} <br> <br> <br>// ************************************************************************ <br>// FUNCTION : InitProcessNodeInfo( PDEB_PROCESS_NODE_INFO*, LPDEBUG_EVENT ) <br>// PURPOSE  : <br>// COMMENTS : <br>// <br>// ************************************************************************ <br>BOOL <br>InitProcessNodeInfo( PDEB_PROCESS_NODE_INFO* ppProcessNodeInfo, LPDEBUG_EVENT lpDebugEvent ) <br>{ <br>  //-- init info data <br>  (*ppProcessNodeInfo)-&gt;dwProcessId = lpDebugEvent-&gt;dwProcessId; <br>  (*ppProcessNodeInfo)-&gt;dwThreadId  = lpDebugEvent-&gt;dwThreadId; <br>  // Note:pThreadList initialized via previous CreateThreadList() call <br>  // Note:pDllList initialized via previous CreateDllList() call <br>  (*ppProcessNodeInfo)-&gt;ProcessDebugInfo = lpDebugEvent-&gt;u.CreateProcessInfo; <br> <br>  return( TRUE ); <br>} <br> <br> <br>// ************************************************************************ <br>// FUNCTION : InsertProcessNode( PLIST, PNODE ) <br>// PURPOSE  : <br>// COMMENTS : <br>// <br>// ************************************************************************ <br>BOOL <br>InsertProcessNode( PLIST pProcessList, PNODE pProcessNode ) <br>{ <br>  PDEB_PROCESS_LIST_INFO pProcessListInfo = pProcessList-&gt;pListData; <br> <br>  //-- insert the node <br>  InsertNode( pProcessList, pProcessNode ); <br> <br>  //-- increment dwActiveProcesss <br>  pProcessListInfo-&gt;dwActiveProcesses++; <br> <br>  return( TRUE ); <br>} <br> <br> <br>// ************************************************************************ <br>// FUNCTION : SetCurrentProcessNode( PLIST, PNODE ) <br>// PURPOSE  : <br>// COMMENTS : <br>// <br>// ************************************************************************ <br>BOOL <br>SetCurrentProcessNode( PLIST pProcessList, PNODE pProcessNode ) <br>{ <br>  SetCurrentNode( pProcessList, pProcessNode, pProcessList-&gt;OrderFunction ); <br> <br>  return( TRUE ); <br>} <br> <br> <br>// ************************************************************************ <br>// FUNCTION : DeleteProcessNode( PLIST, PNODE ) <br>// PURPOSE  : <br>// COMMENTS : <br>// <br>// ************************************************************************ <br>BOOL <br>DeleteProcessNode( PLIST pProcessList, PNODE pProcessNode ) <br>{ <br>  PNODE pDeleteNode; <br> <br>  SetCurrentNode( pProcessList, pProcessNode, pProcessList-&gt;OrderFunction ); <br>  GetCurrentNode( pProcessList, &amp;pDeleteNode ); <br>  DeleteCurrentProcessNode( pProcessList ); <br> <br>  return( TRUE ); <br>} <br> <br> <br>// ************************************************************************ <br>// FUNCTION : FreeProcessNodeInfo( PNODE ) <br>// PURPOSE  : <br>// COMMENTS : <br>// <br>// ************************************************************************ <br>BOOL <br>FreeProcessNodeInfo( PNODE pProcessNode ) <br>{ <br>  PDEB_PROCESS_NODE_INFO pProcessNodeInfo = (PDEB_PROCESS_NODE_INFO) pProcessNode-&gt;pNodeData; <br> <br>  //-- free info data <br>  DestroyDllList( pProcessNodeInfo-&gt;pDllList ); <br>  DestroyThreadList( pProcessNodeInfo-&gt;pThreadList ); <br>  HeapFree( hHeap, (DWORD) NULL, (PVOID) pProcessNodeInfo-&gt;lpstrPathName ); <br>  HeapFree( hHeap, (DWORD) NULL, (PVOID) pProcessNodeInfo-&gt;lpstrFileName ); <br>  HeapFree( hHeap, (DWORD) NULL, (PVOID) pProcessNodeInfo ); <br> <br>  return( TRUE ); <br>} <br> <br> <br>// ************************************************************************ <br>// FUNCTION : DestroyProcessNode( PNODE ) <br>// PURPOSE  : <br>// COMMENTS : Frees all memory associated with the node. <br>// ************************************************************************ <br>BOOL <br>DestroyProcessNode( PNODE pProcessNode ) <br>{ <br>  //-- free info data <br>  FreeProcessNodeInfo( pProcessNode ); <br> <br>  //-- destroy node <br>  DestroyNode( pProcessNode ); <br> <br>  return( TRUE ); <br>} <br> <br> <br>// ************************************************************************ <br>// FUNCTION : DeleteCurrentProcessNode( PLIST ) <br>// PURPOSE  : <br>// COMMENTS : <br>// <br>// ************************************************************************ <br>BOOL <br>DeleteCurrentProcessNode( PLIST pProcessList ) <br>{ <br>  PDEB_PROCESS_LIST_INFO pProcessListInfo = pProcessList-&gt;pListData; <br>  PNODE                  pProcessNode = (PNODE) pProcessList-&gt;pCurrentNode; <br> <br>  //-- free info data <br>  FreeProcessNodeInfo( pProcessNode ); </code></pre>
<p>
</p>
<pre><code><br>  //-- delete and destroy node <br>  DeleteCurrentNode( pProcessList ); <br> <br>  //-- decrement dwActiveProcesss <br>  pProcessListInfo-&gt;dwActiveProcesses--; <br> <br>  return( TRUE ); <br>} <br> <br> <br>// ------------------------------------------------------------------------ <br>// Thread list and node specific linked list wrapper functions <br>// ------------------------------------------------------------------------ <br> <br> <br>// ************************************************************************ <br>// FUNCTION : ThreadOrderFunction( PNODE, PNODE ); <br>// PURPOSE  : Provides the sorting/search logic for the double linked <br>//            list package. <br>// COMMENTS : <br>//   Sorted by thread ID value <br>// ************************************************************************ <br>int <br>ThreadOrderFunction( PNODE pNode1, PNODE pNode2 ) <br>{ <br>  PDEB_THREAD_NODE_INFO pThreadNodeInfo1 = pNode1-&gt;pNodeData; <br>  PDEB_THREAD_NODE_INFO pThreadNodeInfo2 = pNode2-&gt;pNodeData; <br> <br>  if( pThreadNodeInfo1-&gt;dwThreadId &lt; pThreadNodeInfo2-&gt;dwThreadId ) <br>    return( LIST_LEFT_OF ); <br> <br>  if( pThreadNodeInfo1-&gt;dwThreadId &gt; pThreadNodeInfo2-&gt;dwThreadId ) <br>    return( LIST_RIGHT_OF ); <br> <br>  return( LIST_MATCH ); <br>} <br> <br> <br>// ************************************************************************ <br>// FUNCTION : CreateThreadList( PLIST* ) <br>// PURPOSE  : <br>// COMMENTS : <br>// <br>// ************************************************************************ <br>BOOL <br>CreateThreadList( PLIST* ppThreadList ) <br>{ <br>  PDEB_THREAD_LIST_INFO pThreadListInfo; <br> <br>  //-- create list <br>  CreateList( ppThreadList, ThreadOrderFunction ); <br> <br>  //-- alloc info data <br>  pThreadListInfo = (PDEB_THREAD_LIST_INFO) HeapAlloc( hHeap, (DWORD) NULL, <br>                                                sizeof( DEB_THREAD_LIST_INFO ) ); <br>  (*ppThreadList)-&gt;pListData = pThreadListInfo; <br> <br>  //-- init info data <br>  pThreadListInfo-&gt;dwActiveThreads = 0; <br> <br>  return( TRUE ); <br>} <br> <br> <br>// ************************************************************************ <br>// FUNCTION : DestroyThreadList( PLIST ) <br>// PURPOSE  : <br>// COMMENTS : <br>// <br>// ************************************************************************ <br>BOOL <br>DestroyThreadList( PLIST pThreadList ) <br>{ <br>  PDEB_THREAD_LIST_INFO pThreadListInfo = pThreadList-&gt;pListData; <br>  PNODE                 pDeleteNode; <br> <br>  //-- make sure all nodes are removed first <br>  while( pThreadListInfo-&gt;dwActiveThreads ) { <br>    GetCurrentNode( pThreadList, &amp;pDeleteNode ); <br>    DeleteCurrentThreadNode( pThreadList ); <br>  } <br> <br>  //-- free info data <br>  HeapFree( hHeap, (DWORD) NULL, (PVOID) pThreadListInfo ); <br> <br>  //-- destroy list <br>  DestroyList( pThreadList ); <br> <br>  return( TRUE ); <br>} <br> <br> <br>// ************************************************************************ <br>// FUNCTION : AllocThreadNode( PNODE*, PDEB_THREAD_NODE_INFO* ) <br>// PURPOSE  : <br>// COMMENTS : <br>// <br>// ************************************************************************ <br>BOOL <br>AllocThreadNode( PNODE* ppThreadNode, PDEB_THREAD_NODE_INFO* ppThreadNodeInfo ) <br>{ <br>  //-- create node <br>  CreateNode( ppThreadNode ); <br> <br>  //-- alloc info data <br>  *ppThreadNodeInfo = (PDEB_THREAD_NODE_INFO) HeapAlloc( hHeap, (DWORD) NULL, <br>                                            (DWORD) sizeof( DEB_THREAD_NODE_INFO ) ); <br>  (*ppThreadNode)-&gt;pNodeData = *(ppThreadNodeInfo); <br> <br>  return( TRUE ); <br>} <br> <br> <br>// ************************************************************************ <br>// FUNCTION : InitThreadNodeInfo( PDEB_THREAD_NODE_INFO*, LPDEBUG_EVENT ) <br>// PURPOSE  : <br>// COMMENTS : <br>// <br>// ************************************************************************ <br>BOOL <br>InitThreadNodeInfo( PDEB_THREAD_NODE_INFO* ppThreadNodeInfo, <br>  LPDEBUG_EVENT lpDebugEvent ) <br>{ <br>  //-- init info data <br>  (*ppThreadNodeInfo)-&gt;dwProcessId     = lpDebugEvent-&gt;dwProcessId; <br>  (*ppThreadNodeInfo)-&gt;dwThreadId      = lpDebugEvent-&gt;dwThreadId; <br>  (*ppThreadNodeInfo)-&gt;ThreadDebugInfo = lpDebugEvent-&gt;u.CreateThread; <br> <br>  return( TRUE ); <br>} <br> <br> <br>// ************************************************************************ <br>// FUNCTION : InsertThreadNode( PLIST, PNODE ) <br>// PURPOSE  : <br>// COMMENTS : <br>// <br>// ************************************************************************ <br>BOOL <br>InsertThreadNode( PLIST pThreadList, PNODE pThreadNode ) <br>{ <br>  PDEB_THREAD_LIST_INFO pThreadListInfo = (PDEB_THREAD_LIST_INFO) pThreadList-&gt;pListData; <br> <br>  //-- insert the thread node <br>  InsertNode( pThreadList, pThreadNode ); <br> <br>  //-- increment dwActiveThreads <br>  pThreadListInfo-&gt;dwActiveThreads++; <br> <br>  return( TRUE ); <br>} <br> <br> <br>// ************************************************************************ <br>// FUNCTION : SetCurrentThreadNode( PLIST, PNODE ) <br>// PURPOSE  : <br>// COMMENTS : <br>// <br>// ************************************************************************ <br>BOOL <br>SetCurrentThreadNode( PLIST pThreadList, PNODE pThreadNode ) <br>{ <br>  SetCurrentNode( pThreadList, pThreadNode, pThreadList-&gt;OrderFunction ); <br> <br>  return( TRUE ); <br>} <br> <br> <br>// ************************************************************************ <br>// FUNCTION : DeleteThreadNode( PLIST, PNODE ) <br>// PURPOSE  : <br>// COMMENTS : <br>// <br>// ************************************************************************ <br>BOOL <br>DeleteThreadNode( PLIST pThreadList, PNODE pThreadNode ) <br>{ <br>  PNODE pDeleteNode; <br> <br>  SetCurrentNode( pThreadList, pThreadNode, pThreadList-&gt;OrderFunction ); <br>  GetCurrentNode( pThreadList, &amp;pDeleteNode ); <br>  DeleteCurrentThreadNode( pThreadList ); <br> <br>  return( TRUE ); <br>} <br> <br> <br>// ************************************************************************ <br>// FUNCTION : FreeThreadNodeInfo( PNODE ) <br>// PURPOSE  : <br>// COMMENTS : <br>// <br>// ************************************************************************ <br>BOOL <br>FreeThreadNodeInfo( PNODE pThreadNode ) <br>{ <br>  PDEB_THREAD_NODE_INFO pThreadNodeInfo = (PDEB_THREAD_NODE_INFO) pThreadNode-&gt;pNodeData; <br> <br>  //-- free info data <br>  HeapFree( hHeap, (DWORD) NULL, (PVOID) pThreadNodeInfo ); <br> <br>  return( TRUE ); <br>} <br> <br> <br>// ************************************************************************ <br>// FUNCTION : DestroyThreadNode( PNODE ) <br>// PURPOSE  : <br>// COMMENTS : Frees all memory associated with the node. <br>// ************************************************************************ <br>BOOL <br>DestroyThreadNode( PNODE pThreadNode ) <br>{ <br>  //-- free info data <br>  FreeThreadNodeInfo( pThreadNode ); <br> <br>  //-- destroy node <br>  DestroyNode( pThreadNode ); <br> <br>  return( TRUE ); <br>} <br> <br> <br>// ************************************************************************ <br>// FUNCTION : DeleteCurrentThreadNode( PLIST ) <br>// PURPOSE  : <br>// COMMENTS : <br>// <br>// ************************************************************************ <br>BOOL <br>DeleteCurrentThreadNode( PLIST pThreadList ) <br>{ <br>  PDEB_THREAD_LIST_INFO pThreadListInfo = pThreadList-&gt;pListData; <br>  PNODE                 pThreadNode = (PNODE) pThreadList-&gt;pCurrentNode; <br> <br>  //-- free info data <br>  FreeThreadNodeInfo( pThreadNode ); <br> <br>  //-- delete and destroy node <br>  DeleteCurrentNode( pThreadList ); <br> <br>  //-- decrement dwActiveThreads <br>  pThreadListInfo-&gt;dwActiveThreads--; <br> <br>  return( TRUE ); <br>} <br> <br> <br>// ------------------------------------------------------------------------ <br>// DLL list and node specific linked list wrapper functions <br>// ------------------------------------------------------------------------ <br> <br> <br>// ************************************************************************ <br>// FUNCTION : DllOrderFunction( PNODE, PNODE ); <br>// PURPOSE  : Provides the sorting/search logic for the double linked <br>//            list package. <br>// COMMENTS : <br>//   Sorted by base address of the DLL <br>// ************************************************************************ <br>int <br>DllOrderFunction( PNODE pNode1, PNODE pNode2 ) <br>{ <br>  PDEB_DLL_NODE_INFO pDllNodeInfo1 = pNode1-&gt;pNodeData; <br>  PDEB_DLL_NODE_INFO pDllNodeInfo2 = pNode2-&gt;pNodeData; <br> <br>  if( pDllNodeInfo1-&gt;DllDebugInfo.lpBaseOfDll &lt; pDllNodeInfo2-&gt;DllDebugInfo.lpBaseOfDll ) <br>    return( LIST_LEFT_OF ); <br> <br>  if( pDllNodeInfo1-&gt;DllDebugInfo.lpBaseOfDll &gt; pDllNodeInfo2-&gt;DllDebugInfo.lpBaseOfDll ) <br>    return( LIST_RIGHT_OF ); <br> <br>  return( LIST_MATCH ); <br>} <br> <br> <br>// ************************************************************************ <br>// FUNCTION : CreateDllList( PLIST* ) <br>// PURPOSE  : <br>// COMMENTS : <br>// <br>// ************************************************************************ <br>BOOL <br>CreateDllList( PLIST* ppDllList ) <br>{ <br>  PDEB_DLL_LIST_INFO pDllListInfo; <br> <br>  //-- create list <br>  CreateList( ppDllList, DllOrderFunction ); <br> <br>  //-- alloc info data <br>  pDllListInfo = (PDEB_DLL_LIST_INFO) HeapAlloc( hHeap, (DWORD) NULL, <br>                                                sizeof( DEB_DLL_LIST_INFO ) ); <br>  (*ppDllList)-&gt;pListData = pDllListInfo; <br> <br>  //-- init info data <br>  pDllListInfo-&gt;dwActiveDlls = 0; <br> <br>  return( TRUE ); <br>} <br> <br> <br>// ************************************************************************ <br>// FUNCTION : DestroyDllList( PLIST ) <br>// PURPOSE  : <br>// COMMENTS : <br>// <br>// ************************************************************************ <br>BOOL <br>DestroyDllList( PLIST pDllList ) <br>{ <br>  PDEB_DLL_LIST_INFO pDllListInfo = pDllList-&gt;pListData; <br>  PNODE              pDeleteNode; <br> <br>  //-- make sure all nodes are removed first <br>  while( pDllListInfo-&gt;dwActiveDlls ) { <br>    GetCurrentNode( pDllList, &amp;pDeleteNode ); <br>    DeleteCurrentDllNode( pDllList ); <br>  } <br> <br>  //-- free list data and destroy the list <br>  HeapFree( hHeap, (DWORD) NULL, (PVOID) pDllListInfo ); <br>  DestroyList( pDllList ); <br> <br>  return( TRUE ); <br>} <br> <br> <br>// ************************************************************************ <br>// FUNCTION : AllocDllNode( PNODE*, PDEB_DLL_NODE_INFO* ) <br>// PURPOSE  : <br>// COMMENTS : <br>// <br>// ************************************************************************ <br>BOOL <br>AllocDllNode( PNODE* ppDllNode, PDEB_DLL_NODE_INFO* ppDllNodeInfo ) <br>{ <br>  //-- create node <br>  CreateNode( ppDllNode ); <br> <br>  //-- alloc info data <br>  *ppDllNodeInfo = (PDEB_DLL_NODE_INFO) HeapAlloc( hHeap, (DWORD) NULL, <br>                                      sizeof( DEB_DLL_NODE_INFO ) ); <br>  (*ppDllNode)-&gt;pNodeData = *(ppDllNodeInfo); <br>  (*ppDllNodeInfo)-&gt;lpstrFileName = (LPTSTR) HeapAlloc( hHeap, (DWORD) NULL, (DWORD) MAX_PATH ); <br> <br>  return( TRUE ); <br>} <br> <br> <br>// ************************************************************************ <br>// FUNCTION : InitDllNodeInfo( PDEB_DLL_NODE_INFO*, LPDEBUG_EVENT ) <br>// PURPOSE  : <br>// COMMENTS : <br>// <br>// ************************************************************************ <br>BOOL <br>InitDllNodeInfo( PDEB_DLL_NODE_INFO* ppDllNodeInfo, <br>  LPDEBUG_EVENT lpDebugEvent ) <br>{ <br>  //-- init info data <br>  GetDllFileName( lpDebugEvent, (*ppDllNodeInfo)-&gt;lpstrFileName, MAX_PATH ); <br>  (*ppDllNodeInfo)-&gt;DllDebugInfo = lpDebugEvent-&gt;u.LoadDll; <br> <br>  return( TRUE ); <br>} <br> <br> <br>// ************************************************************************ <br>// FUNCTION : InsertDllNode( PLIST, PNODE ) <br>// PURPOSE  : <br>// COMMENTS : <br>// <br>// ************************************************************************ <br>BOOL <br>InsertDllNode( PLIST pDllList, PNODE pDllNode ) <br>{ <br>  PDEB_DLL_LIST_INFO pDllListInfo = pDllList-&gt;pListData; <br> <br>  // insert the node <br>  InsertNode( pDllList, pDllNode ); <br> <br>  //-- increment dwActiveDlls <br>  pDllListInfo-&gt;dwActiveDlls++; <br> <br>  return( TRUE ); <br>} <br> <br> <br>// ************************************************************************ <br>// FUNCTION : SetCurrentDllNode( PLIST, PNODE ) <br>// PURPOSE  : <br>// COMMENTS : <br>// <br>// ************************************************************************ <br>BOOL <br>SetCurrentDllNode( PLIST pDllList, PNODE pDllNode ) <br>{ <br>  SetCurrentNode( pDllList, pDllNode, pDllList-&gt;OrderFunction ); <br> <br>  return( TRUE ); <br>} <br> <br> <br>// ************************************************************************ <br>// FUNCTION : DeleteDllNode( PLIST, PNODE ) <br>// PURPOSE  : <br>// COMMENTS : <br>// <br>// ************************************************************************ <br>BOOL <br>DeleteDllNode( PLIST pDllList, PNODE pDllNode ) <br>{ <br>  PNODE pDeleteNode; <br> <br>  SetCurrentNode( pDllList, pDllNode, pDllList-&gt;OrderFunction ); <br>  GetCurrentNode( pDllList, &amp;pDeleteNode ); <br>  DeleteCurrentDllNode( pDllList ); <br> <br>  return( TRUE ); <br>} <br> <br> <br>// ************************************************************************ <br>// FUNCTION : FreeDllNodeInfo( PNODE ) <br>// PURPOSE  : <br>// COMMENTS : <br>// <br>// ************************************************************************ <br>BOOL <br>FreeDllNodeInfo( PNODE pDllNode ) <br>{ <br>  PDEB_DLL_NODE_INFO pDllNodeInfo = (PDEB_DLL_NODE_INFO) pDllNode-&gt;pNodeData; <br> <br>  //-- free info data <br>  HeapFree( hHeap, (DWORD) NULL, (PVOID) pDllNodeInfo-&gt;lpstrFileName ); <br>  HeapFree( hHeap, (DWORD) NULL, (PVOID) pDllNodeInfo ); <br> <br>  return( TRUE ); <br>} <br> <br> <br>// ************************************************************************ <br>// FUNCTION : DestroyDllNode( PNODE ) <br>// PURPOSE  : <br>// COMMENTS : Frees all memory associated with the node. <br>// ************************************************************************ <br>BOOL <br>DestroyDllNode( PNODE pDllNode ) <br>{ <br>  //-- free info data <br>  FreeDllNodeInfo( pDllNode ); <br> <br>  //-- destroy node <br>  DestroyNode( pDllNode ); <br> <br>  return( TRUE ); <br>} <br> <br> <br>// ************************************************************************ <br>// FUNCTION : DeleteCurrentDllNode( PLIST ) <br>// PURPOSE  : <br>// COMMENTS : Deletes the current DLL node from the list and frees all <br>//            memory associated with it. <br>// ************************************************************************ <br>BOOL <br>DeleteCurrentDllNode( PLIST pDllList ) <br>{ <br>  PDEB_DLL_LIST_INFO pDllListInfo = pDllList-&gt;pListData; <br>  PNODE              pDllNode = (PNODE) pDllList-&gt;pCurrentNode; <br> <br>  //-- free info data <br>  FreeDllNodeInfo( pDllNode ); <br> <br>  //-- delete and destroy node <br>  DeleteCurrentNode( pDllList ); <br> <br>  //-- decrement dwActiveDlls <br>  pDllListInfo-&gt;dwActiveDlls--; <br> <br>  return( TRUE ); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
