<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>LINKLIST.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5982"></a>LINKLIST.C</h2>
<pre><code>// ************************************************************************ <br>// <br>//                      Microsoft Developer Support <br>//             Copyright 1992 - 1998 Microsoft Corporation <br>// <br>// ************************************************************************ <br>// MODULE    : LinkList.C - Ordered Double Linked List Package <br>// PURPOSE   : Provide a general, sorted, double linked list package <br>// FUNCTIONS : <br>//   CreateList        - allocate memory for a new list, registers the <br>//                       ordering function <br>//   CreateNode        - allocate memory fpr a new node that can be put <br>//                       into the linked list <br>//   InsertNode        - insert a new node into the list <br>//   SetCurrentNode    - finds the 1st occurence of a node that matches <br>//                       a key(s) according to the match function <br>//                       and sets it as the current node <br>//   SetCurrentNodeEx  - finds the Nth occurence of a node that matches <br>//                       a key(s) according to the match function <br>//                       and sets it as the current node <br>//   GetCurrentNode    - get the current node <br>//   GetFirstNode      - get the first (left-most) node in the list <br>//   GetLastNode       - get the last (right-most) node in the list <br>//   GetNextNode       - get the next (right) node from the current <br>//   GetPrevNode       - get the previous (left) node from the current <br>//   DeleteCurrentNode - deletes the current node from the list and <br>//                       frees the memory associated with it <br>//   DestroyNode       - deallocates the memory associated with a node <br>//   DestroyList       - deallocates the memory associated with a list, <br>//                       does not delete any of the nodes <br>//   GetListError      - gets the current list error <br>// <br>// COMMENTS  : The application must serialize access to the linked list <br>// <br>//   Format of the Ordering and Matching functions is as follows: <br>//   ----------------------------------------------------------- <br>// <br>//   int OrderFunc( PNODE pNodeOne, PNODE pNodeTwo ) <br>//   { <br>//     if( (pNodeOne-&gt;pNodeData).SortKey &lt;  (pNodeTwo-&gt;pNodeData).SortKey ) <br>//       return( LIST_LEFT_OF  ); <br>//     if( (pNodeOne-&gt;pNodeData).SortKey == (pNodeTwo-&gt;pNodeData).SortKey ) <br>//       return( LIST_MATCH    ); <br>//     if( (pNodeOne-&gt;pNodeData).SortKey  &gt; (pNodeTwo-&gt;pNodeData).SortKey ) <br>//       return( LIST_RIGHT_OF ); <br>//   } <br>// <br>// ************************************************************************ <br>#include &lt;StdLib.H&gt;     // malloc(), free() <br>#include "LinkList.H" <br> <br>//-- NULL pointer dereferencing checking macro <br>#define CHECK_POINTER( ppNode )                                       \ <br>          if( ppNode == NULL ) {                                      \ <br>            return( pList-&gt;ListError = LIST_ERROR_DEREFERENCE_NULL ); \ <br>          } <br> <br> <br>// ************************************************************************ <br>// FUNCTION : CreateList( PLIST* ppList, int (*)(PNODE, PNODE) ) ) <br>// PURPOSE  : allocate a new list, registers the ordering function <br>// COMMENTS : sets all pointers to NULL <br>// ************************************************************************ <br>BOOL <br>CreateList( PLIST* ppList, int (*OrderFunction)( PNODE pNodeOne, PNODE pNodeTwo ) ) <br>{ <br>  *ppList = (PLIST) malloc( sizeof(LIST) ); <br>  if( ppList == NULL ) { <br>    (*ppList)-&gt;ListError = LIST_NO_ERROR; <br>    return( FALSE ); <br>  } <br> <br>  //-- register the link list data ordering function <br>  (*ppList)-&gt;OrderFunction = OrderFunction; <br> <br>  //-- initialize the general linked list node pointers to NULL <br>  (*ppList)-&gt;pFirstNode   = NULL; <br>  (*ppList)-&gt;pCurrentNode = NULL; <br>  (*ppList)-&gt;pLastNode    = NULL; <br> <br>  //-- indicate no error <br>  (*ppList)-&gt;ListError  = LIST_NO_ERROR; <br> <br>  return( TRUE ); <br>} <br> <br> <br>// ************************************************************************ <br>// FUNCTION : CreateNode( PNODE* ) <br>// PURPOSE  : create/allocate a new node that can be put into list <br>// COMMENTS : <br>// ************************************************************************ <br>BOOL <br>CreateNode( PNODE* ppNewNode ) <br>{ <br>  *ppNewNode = (PNODE) malloc( sizeof(NODE) ); <br>  if( *ppNewNode == NULL ) { <br>    return( FALSE ); <br>  } <br> <br>  //-- initialize the node pointers to NULL <br>  (*ppNewNode)-&gt;pRightLink = NULL; <br>  (*ppNewNode)-&gt;pLeftLink  = NULL; <br> <br>  return( TRUE ); <br>} <br> <br> <br>// ************************************************************************ <br>// FUNCTION : InsertNode( PLIST pList, PNODE ) <br>// PURPOSE  : insert a new node into the list <br>// COMMENTS : <br>//   All nodes must have a unique key entry (from order function), if a <br>//   match is found during an insert then the old node gets replaced with <br>//   the new node. <br>// <br>//  NOTE: changes pList-&gt;pCurrentNode <br>// ************************************************************************ <br>BOOL <br>InsertNode( PLIST pList, PNODE pNewNode ) <br>{ <br>  int Position; <br>  int LastPosition; <br> <br>  //-- if this is the first node in a new list <br>  if( pList-&gt;pFirstNode == NULL ) { <br>    pList-&gt;pFirstNode   = pNewNode; <br>    pList-&gt;pLastNode    = pNewNode; <br>    pList-&gt;pCurrentNode = pNewNode; <br>    pList-&gt;ListError    = LIST_NO_ERROR; <br>    return( TRUE ); <br>  } <br> <br>  Position = (*(pList-&gt;OrderFunction))( pNewNode, pList-&gt;pCurrentNode ); <br> <br>  //-- search for insertion point <br>  while( pList-&gt;pCurrentNode != NULL ) { <br> <br>    LastPosition = Position; <br>    Position = (*(pList-&gt;OrderFunction))(pNewNode, pList-&gt;pCurrentNode); <br> <br>    if( pList-&gt;pFirstNode == pList-&gt;pLastNode ) <br>      break; <br> <br>    if( Position != LastPosition ) <br>      break; <br> <br>    if( pList-&gt;pCurrentNode == pList-&gt;pFirstNode ) { <br>      if( Position == LIST_RIGHT_OF ) { <br>        pList-&gt;pCurrentNode = pList-&gt;pCurrentNode-&gt;pRightLink; <br>        continue; <br>      } <br>      break; <br>    } <br> <br>    if( pList-&gt;pCurrentNode == pList-&gt;pLastNode ) { <br>      if( Position == LIST_LEFT_OF ) { <br>        pList-&gt;pCurrentNode = pList-&gt;pCurrentNode-&gt;pLeftLink; <br>        continue; <br>      } <br>      break; <br>    } <br> <br>    if( Position == LastPosition ) { <br>      if( Position == LIST_LEFT_OF) { <br>        pList-&gt;pCurrentNode = pList-&gt;pCurrentNode-&gt;pLeftLink; <br>        continue; <br>      } <br>      if( Position == LIST_RIGHT_OF ) { <br>        pList-&gt;pCurrentNode = pList-&gt;pCurrentNode-&gt;pRightLink; <br>        continue; <br>      } <br>      break; <br>    } <br> <br>  } <br> <br>  //-- now, insert the pNewNode <br>  switch( Position ) { <br> <br>    case LIST_LEFT_OF: <br>      pNewNode-&gt;pRightLink = pList-&gt;pCurrentNode; <br>      pNewNode-&gt;pLeftLink  = pList-&gt;pCurrentNode-&gt;pLeftLink; <br>      if( pList-&gt;pCurrentNode == pList-&gt;pFirstNode ) <br>        pList-&gt;pFirstNode = pNewNode; <br>      else <br>        pList-&gt;pCurrentNode-&gt;pLeftLink-&gt;pRightLink = pNewNode; <br>      pList-&gt;pCurrentNode-&gt;pLeftLink = pNewNode; <br>      break; <br> <br>  #if 1  // replace duplicates with new data <br> <br>    case LIST_MATCH: <br>      pNewNode-&gt;pLeftLink  = pList-&gt;pCurrentNode-&gt;pLeftLink; <br>      pNewNode-&gt;pRightLink = pList-&gt;pCurrentNode-&gt;pRightLink; <br>      if( pList-&gt;pCurrentNode == pList-&gt;pLastNode ) <br>        pList-&gt;pLastNode = pNewNode; <br>      else <br>        pList-&gt;pCurrentNode-&gt;pRightLink-&gt;pLeftLink = pNewNode; <br>      if( pList-&gt;pCurrentNode == pList-&gt;pFirstNode ) <br>        pList-&gt;pFirstNode = pNewNode; <br>      else <br>        pList-&gt;pCurrentNode-&gt;pLeftLink-&gt;pRightLink = pNewNode; <br>      // note: doesn't destroy extra data associated with the node <br>      DestroyNode( pList-&gt;pCurrentNode ); <br>      break; <br> <br>  #else // or allow duplicates <br> <br>    case LIST_MATCH: <br> <br>  #endif <br> <br>    case LIST_RIGHT_OF: <br>      pNewNode-&gt;pLeftLink  = pList-&gt;pCurrentNode; <br>      pNewNode-&gt;pRightLink = pList-&gt;pCurrentNode-&gt;pRightLink; <br>      if( pList-&gt;pCurrentNode == pList-&gt;pLastNode ) <br>        pList-&gt;pLastNode = pNewNode; <br>      else <br>        pList-&gt;pCurrentNode-&gt;pRightLink-&gt;pLeftLink = pNewNode; <br>      pList-&gt;pCurrentNode-&gt;pRightLink = pNewNode; <br>      break; <br> <br>  } <br>  pList-&gt;pCurrentNode = pNewNode; <br>  pList-&gt;ListError    = LIST_NO_ERROR; <br> <br>  return( TRUE ); <br>} <br> <br> <br>// ************************************************************************ <br>// FUNCTION : SetCurrentNode( PLIST pList, PNODE, int (*)(PNODE, PNODE) ) <br>// PURPOSE  : finds the first occurence of a node from the list that matches <br>//            a key(s) according to the match function. <br>// COMMENTS : <br>//   May use the ordering function or a new matching function if not <br>//   searching for a match based on the primary ordering key. <br>//   NOTE: the matching and ordering functions have the same definition. <br>//   NOTE: changes pList-&gt;pCurrentNode. <br>// ************************************************************************ <br>BOOL <br>SetCurrentNode( PLIST pList, PNODE pKeyNode, <br>         int (*MatchFunction)( PNODE pNodeOne, PNODE pNodeTwo ) ) <br>{ <br>  return( SetCurrentNodeEx( pList, pKeyNode, MatchFunction, 1 ) ); <br>} <br> <br> <br>// ************************************************************************ <br>// FUNCTION : SetCurrentNodeEx( PLIST pList, PNODE, int (*)(PNODE, PNODE), int ) <br>// PURPOSE  : finds the Nth occurence of a node from the list that matches <br>//            a key(s) according to the match function. <br>// COMMENTS : <br>//   May use the ordering function or a new matching function if not <br>//   searching for a match based on the primary ordering key. <br>//   NOTE: the matching and ordering functions have the same definition. <br>//   NOTE: changes pList-&gt;pCurrentNode. <br>// ************************************************************************ <br>BOOL <br>SetCurrentNodeEx( PLIST pList, PNODE pKeyNode, <br>  int (*MatchFunction)( PNODE pNodeOne, PNODE pNodeTwo ), <br>  int Occurence ) <br>{ <br>  int Position; <br> <br>  //-- if list is empty, exit <br>  if( pList-&gt;pCurrentNode == NULL ) { <br>    pList-&gt;ListError = LIST_ERROR_NO_NODE; <br>    return( FALSE ); <br>  } <br> <br>  //-- if match and order are same function <br>  if( MatchFunction == (pList-&gt;OrderFunction) ) { <br>    int  LastPosition; <br> <br>    LastPosition = Position = (*MatchFunction)(pKeyNode, pList-&gt;pCurrentNode); <br> <br>    while( Occurence ) { <br>      if( ( Position == LIST_LEFT_OF ) &amp;&amp; ( LastPosition == LIST_LEFT_OF ) <br>          &amp;&amp; ( pList-&gt;pCurrentNode != pList-&gt;pFirstNode ) ) <br>        pList-&gt;pCurrentNode = pList-&gt;pCurrentNode-&gt;pLeftLink; <br>      else if( ( Position == LIST_RIGHT_OF ) &amp;&amp; ( LastPosition == LIST_RIGHT_OF ) <br>            &amp;&amp; ( pList-&gt;pCurrentNode != pList-&gt;pLastNode ) ) <br>        pList-&gt;pCurrentNode = pList-&gt;pCurrentNode-&gt;pRightLink; <br>      else { <br>        Occurence--; <br>        continue; <br>      } <br>      LastPosition = Position; <br>      Position = (*MatchFunction)(pKeyNode, pList-&gt;pCurrentNode); <br>    } <br> <br>  } <br>  //-- match and order are not the same function, thus start <br>  //   the search at the front of the list <br>  else { <br>    pList-&gt;pCurrentNode = pList-&gt;pFirstNode; <br>    while( (Occurence &gt; 0) &amp;&amp; ( (pList-&gt;pCurrentNode) != NULL ) ) { <br>      Position = (*MatchFunction)(pKeyNode, pList-&gt;pCurrentNode); <br>      if( Position == LIST_MATCH ) <br>        Occurence--; <br>      if( Occurence &gt; 0 ) <br>        pList-&gt;pCurrentNode = pList-&gt;pCurrentNode-&gt;pRightLink; <br>    } <br>  } <br> <br>  if( ( Position == LIST_MATCH ) &amp;&amp; ( Occurence == 0 ) ) { <br>    pList-&gt;ListError = LIST_NO_ERROR; <br>    return( TRUE ); <br>  } <br>  pList-&gt;ListError = LIST_ERROR_NO_MATCH; <br> <br>  return( FALSE ); <br>} <br> <br> <br>// ************************************************************************ <br>// FUNCTION : GetCurrentNode( PLIST pList, PNODE* ) <br>// PURPOSE  : gets the current node from the list <br>// COMMENTS : <br>//   Does not change pList-&gt;pCurrentNode. <br>//   Changes ppNode, thus do not pass in a ppNode which has additional <br>//   memory associated with it. <br>// ************************************************************************ <br>BOOL <br>GetCurrentNode( PLIST pList, PNODE* ppNode ) <br>{ <br>  CHECK_POINTER( ppNode ); <br>  if( pList-&gt;pCurrentNode == NULL ) { <br>    pList-&gt;ListError = LIST_ERROR_NO_NODE; <br>    return( FALSE ); <br>  } <br>  *ppNode = pList-&gt;pCurrentNode; <br>  pList-&gt;ListError = LIST_NO_ERROR; <br> <br>  return( TRUE ); <br>} <br> <br> <br>// ************************************************************************ <br>// FUNCTION : GetFirstNode( PLIST pList, PNODE* ) <br>// PURPOSE  : gets the first (left-most) node from the list <br>// COMMENTS : <br>//   Does not change pList-&gt;pCurrentNode. <br>//   Changes ppNode, thus do not pass in a ppNode which has additional <br>//   memory associated with it. <br>// ************************************************************************ <br>BOOL <br>GetFirstNode( PLIST pList, PNODE* ppNode ) <br>{ <br>  CHECK_POINTER( ppNode ); <br>  if( pList-&gt;pFirstNode == NULL ) { <br>    pList-&gt;ListError = LIST_ERROR_NO_NODE; <br>    return( FALSE ); <br>  } <br>  *ppNode = pList-&gt;pFirstNode; <br>  pList-&gt;ListError = LIST_NO_ERROR; <br> <br>  return( TRUE ); <br>} <br> <br> <br>// ************************************************************************ <br>// FUNCTION : GetLastNode( PLIST pList, PNODE* ) <br>// PURPOSE  : get the last (right-most) node from the List <br>// COMMENTS : <br>//   Does not change pList-&gt;pCurrentNode. <br>//   Changes ppNode, thus do not pass in a ppNode which has additional <br>//   memory associated with it. <br>// ************************************************************************ <br>BOOL <br>GetLastNode( PLIST pList, PNODE* ppNode ) <br>{ <br>  CHECK_POINTER( ppNode ); <br>  if( pList-&gt;pLastNode == NULL ) { <br>    pList-&gt;ListError = LIST_ERROR_NO_NODE; <br>    return( FALSE ); <br>  } <br>  *ppNode = pList-&gt;pLastNode; <br>  pList-&gt;ListError = LIST_NO_ERROR; <br> <br>  return( TRUE ); <br>} <br> <br> <br>// ************************************************************************ <br>// FUNCTION : GetNextNode( PLIST pList, PNODE* ) <br>// PURPOSE  : get the next (right) node from the pList-&gt;pCurrentNode <br>// COMMENTS : <br>//   Does not change pList-&gt;pCurrentNode. <br>//   Changes ppNode, thus do not pass in a ppNode which has additional <br>//   memory associated with it. <br>// ************************************************************************ <br>BOOL <br>GetNextNode( PLIST pList, PNODE* ppNode ) <br>{ <br>  CHECK_POINTER( ppNode ); <br>  if( (*ppNode)-&gt;pRightLink == NULL ) { <br>    pList-&gt;ListError = LIST_ERROR_NO_NODE; <br>    return( FALSE ); <br>  } <br>  *ppNode = (*ppNode)-&gt;pRightLink; <br>  pList-&gt;ListError = LIST_NO_ERROR; <br> <br>  return( TRUE ); <br>} <br> <br> <br>// ************************************************************************ <br>// FUNCTION : GetPrevNode( PLIST pList, PNODE* ) <br>// PURPOSE  : get the previous (left) node from the pList-&gt;pCurrentNode <br>// COMMENTS : <br>//   Does not change pList-&gt;pCurrentNode. <br>//   Changes ppNode, thus do not pass in a ppNode which has additional <br>//   memory associated with it. <br>// ************************************************************************ <br>BOOL <br>GetPrevNode( PLIST pList, PNODE* ppNode ) <br>{ <br>  CHECK_POINTER( ppNode ); <br>  if( (*ppNode)-&gt;pLeftLink == NULL ) { <br>    pList-&gt;ListError = LIST_ERROR_NO_NODE; <br>    return( FALSE ); <br>  } <br>  *ppNode = (*ppNode)-&gt;pLeftLink; <br>  pList-&gt;ListError = LIST_NO_ERROR; <br> <br>  return( TRUE ); <br>} <br> <br> <br>// ************************************************************************ <br>// FUNCTION : DeleteCurrentNode( PLIST pList ) <br>// PURPOSE  : deletes the current node from the list and frees the memory <br>//            associated with it <br>// COMMENTS : <br>//   Changes pList-&gt;pCurrentNode. <br>// <br>//   Typically, SetCurrentNode (or SetCurrentNodeEx) is called first to set <br>//   pList-&gt;pCurrentNode.  Also, any addtional memory associated with this <br>//   node should be freed first before calling this function. <br>// ************************************************************************ <br>BOOL <br>DeleteCurrentNode( PLIST pList ) <br>{ <br>  PNODE pOldCurrentNode; <br> <br>  if( pList-&gt;pCurrentNode != NULL ) { <br>    pOldCurrentNode = pList-&gt;pCurrentNode; <br> <br>    if( pOldCurrentNode == pList-&gt;pFirstNode ) { <br>      pList-&gt;pFirstNode   = pOldCurrentNode-&gt;pRightLink; <br>      pList-&gt;pCurrentNode = pOldCurrentNode-&gt;pRightLink; <br>    } <br>    else { <br>      pOldCurrentNode-&gt;pLeftLink-&gt;pRightLink = pOldCurrentNode-&gt;pRightLink; <br>      pList-&gt;pCurrentNode = pOldCurrentNode-&gt;pLeftLink; <br>    } <br> <br>    if( pOldCurrentNode == pList-&gt;pLastNode ) <br>      pList-&gt;pLastNode = pOldCurrentNode-&gt;pLeftLink; <br>    else <br>      pOldCurrentNode-&gt;pRightLink-&gt;pLeftLink = pOldCurrentNode-&gt;pLeftLink; <br> <br>    DestroyNode( pOldCurrentNode ); <br>    pList-&gt;ListError = LIST_NO_ERROR; <br>    return( TRUE ); <br>  } <br>  pList-&gt;ListError = LIST_NO_ERROR; <br> <br>  return( TRUE ); <br>} <br> <br> <br>// ************************************************************************ <br>// FUNCTION : DestroyNode( PNODE pNode ) <br>// PURPOSE  : deallocates a node <br>// COMMENTS : <br>// ************************************************************************ <br>BOOL <br>DestroyNode( PNODE pNode ) <br>{ <br>  free( pNode ); <br> <br>  return( TRUE ); <br>} <br> <br> <br>// ************************************************************************ <br>// FUNCTION : DestroyList( PLIST pList ) <br>// PURPOSE  : deallocates a list, does not free any nodes, if present <br>// COMMENTS : <br>// ************************************************************************ <br>BOOL <br>DestroyList( PLIST pList ) <br>{ <br>  free( pList ); <br>  pList-&gt;ListError = LIST_NO_ERROR; <br> <br>  return( TRUE ); <br>} <br> <br> <br>// ************************************************************************ <br>// FUNCTION : GetListError( PLIST pList ) <br>// PURPOSE  : get the last linked list error <br>// COMMENTS : <br>// ************************************************************************ <br>int <br>GetListError( PLIST pList ) <br>{ <br>  return( pList-&gt;ListError ); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
