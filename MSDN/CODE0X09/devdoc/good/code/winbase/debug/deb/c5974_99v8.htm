<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>TOOLBAR.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5984"></a>TOOLBAR.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples.  <br>*       Copyright 1993 - 1998 Microsoft Corporation. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>// ************************************************************************ <br>// MODULE    : ToolBar.C <br>// PURPOSE   : A Win32 DLL containing a simple text ToolBar <br>// FUNCTIONS : <br>//   DllMain()         - Dll entry point (via _DllMainCRTStartup) <br>//   TextButtonBar()   - generate a text button ToolBar <br>//   TextButtonBarProc - processes messages for the TextButtonBarWClass <br>// COMMENTS  : <br>// <br>// ************************************************************************ <br>#define   STRICT               // enable strict typing <br>#include &lt;Windows.H&gt;           // required for all Windows applications <br> <br>#include "ToolBar.H"           // specific to this program <br> <br>//-- internal data <br>HWND hWndToolBarOwner;         // window handle of Toolbar owner <br>                               // where all WM_COMMAND messages are sent <br> <br>//-- internal prototypes <br>LRESULT CALLBACK TextButtonBarProc( HWND, UINT, WPARAM, LPARAM ); <br> <br> <br>// ************************************************************************ <br>// FUNCTION : DllMain( HINSTANCE, DWORD, LPVOID ) <br>// PURPOSE  : DllMain is called by the C run-time library from the <br>//            _DllMainCRTStartup entry point.  The DLL entry point gets <br>//            called (entered) on the following events: "Process Attach", <br>//            "Thread Attach", "Thread Detach" or "Process Detach". <br>// COMMENTS : No initialization is needed here so this entry point simply <br>//            returns TRUE. <br>// ************************************************************************ <br>BOOL WINAPI <br>DllMain( HINSTANCE hInstDLL, DWORD fdwReason, LPVOID lpvReserved ) <br>{ <br>  UNREFERENCED_PARAMETER( hInstDLL ); <br>  UNREFERENCED_PARAMETER( fdwReason ); <br>  UNREFERENCED_PARAMETER( lpvReserved ); <br> <br>  return( TRUE ); <br>} <br> <br> <br>// ************************************************************************ <br>// FUNCTION : TextButtonBar( HWND, LPTEXTBUTTON, LPINT ) <br>// PURPOSE  : Generate a simple text button ToolBar <br>// COMMENTS : lpTextButton points to an array of TEXTBUTTON <br>//            structures.  The last structure must set the <br>//            member lpButtonText to NULL.  lpHeight contains the <br>//            height of the ToolBar window. <br>// ************************************************************************ <br>HWND <br>TextButtonBar( HWND hWndParent, LPTEXTBUTTON lpTextButton, LPINT lpHeight ) <br>{ <br>  #define BUTTON_BORDER    4 <br>  #define BUTTONBAR_BORDER 4 <br> <br>  static HWND         hWndTextButtonBar; <br> <br>  HDC          hDC; <br>  WNDCLASS     WndClass; <br>  LONG         ButtonWidth; <br>  LONG         ButtonHeight; <br>  INT          xPosButton; <br>  INT          ButtonSpacing; <br>  INT          ButtonSpace; <br>  LPTSTR       lpButtonString; <br>  LPTEXTBUTTON lpTempTextButton; <br>  TEXTMETRIC   tm; <br>  SIZE         ButtonTextSize; <br>  RECT         rect; <br> <br>  //-- store owner of Toolbar <br>  hWndToolBarOwner = hWndParent; <br> <br>  //-- register the TestButtonBar window class <br>  WndClass.style         = (UINT) NULL; <br>  WndClass.lpfnWndProc   = (WNDPROC) TextButtonBarProc; <br>  WndClass.cbClsExtra    = 0; <br>  WndClass.cbWndExtra    = 0; <br>  WndClass.hInstance     = NULL; <br>  WndClass.hIcon         = NULL; <br>  WndClass.hCursor       = NULL; <br>  WndClass.hbrBackground = (HBRUSH) GetStockObject(LTGRAY_BRUSH); <br>  WndClass.lpszMenuName  = NULL; <br>  WndClass.lpszClassName = TEXT( "TextButtonBarWClass" ); <br> <br>  if( !RegisterClass( &amp;WndClass ) ) <br>    return( FALSE ); <br> <br>  hDC = GetDC( hWndParent ); <br>  GetTextMetrics( hDC, &amp;tm ); <br>  ButtonHeight = 2 * BUTTON_BORDER + tm.tmHeight; <br>  *lpHeight = 2 * BUTTONBAR_BORDER + ButtonHeight; <br> <br>  GetWindowRect( GetDesktopWindow(), &amp;rect ); <br>  hWndTextButtonBar = CreateWindow( <br>                        TEXT( "TextButtonBarWClass" ), TEXT( "Toolbar" ), <br>                        WS_CHILD | WS_CLIPSIBLINGS, <br>                        0, 0, rect.right - rect.left, *lpHeight, <br>                        hWndToolBarOwner, <br>                        (HMENU) NULL, (HANDLE) NULL, NULL ); <br> <br>  SetWindowPos( hWndTextButtonBar, (HWND) 1, 0, 0, 0, 0, <br>    SWP_NOMOVE | SWP_NOSIZE ); <br> <br>  //-- button spacing information <br>  ButtonSpacing = BUTTON_BORDER / 2; <br>  ButtonSpace   = BUTTON_BORDER * 4; <br>  xPosButton    = BUTTON_BORDER * 2; <br> <br>  //-- Create all the button windows <br>  for( lpTempTextButton = lpTextButton; <br>         !( (lpTempTextButton-&gt;lpButtonText) == '\0' <br>           &amp;&amp; (lpTempTextButton-&gt;idButton) == (UINT) NULL); <br>         lpTempTextButton++ ) { <br> <br>    //-- if TB_SPACE then adjust new xPos and continue <br>    if( lpTempTextButton-&gt;idButton == TB_SPACE ) { <br>      xPosButton += ButtonSpace; <br>      continue; <br>    } <br> <br>    lpButtonString = lpTempTextButton-&gt;lpButtonText; <br>    GetTextExtentPoint( hDC, lpButtonString, lstrlen(lpButtonString), &amp;ButtonTextSize ); <br>    ButtonWidth = (4 * BUTTON_BORDER) + (LONG) ButtonTextSize.cx; <br> <br>    (lpTempTextButton-&gt;hWndButton) = CreateWindow( <br>         TEXT( "BUTTON" ), lpButtonString, <br>         WS_VISIBLE | BS_PUSHBUTTON | WS_CHILD, <br>         xPosButton, BUTTONBAR_BORDER, ButtonWidth, ButtonHeight, <br>         hWndTextButtonBar, <br>         (HMENU) lpTempTextButton-&gt;idButton, <br>         (HANDLE) NULL, NULL ); <br> <br>    xPosButton += ButtonWidth + ButtonSpacing; <br>  } <br>  ReleaseDC( hWndParent, hDC ); <br> <br>  return( hWndTextButtonBar ); <br>} <br> <br> <br>// ************************************************************************ <br>// FUNCTION : TextButtonBarProc( HWND, UINT, WPARAM, LPARAM ) <br>// PURPOSE  : Processes messages for the TextButtonBarWClass <br>// MESSAGES : <br>//  WM_COMMAND - forwarded to the owner window <br>//  WM_PAINT   - draws a 3D background <br>// COMMENTS : <br>// ************************************************************************ <br>LRESULT CALLBACK <br>TextButtonBarProc( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam ) <br>{ <br>  static HDC         hDC; <br>  static RECT        rect; <br>  static PAINTSTRUCT ps; <br> <br>  switch( uMsg ) { <br> <br>    case WM_COMMAND: <br>      SendMessage( hWndToolBarOwner, uMsg, wParam, lParam ); <br>      return( FALSE ); <br> <br>    case WM_PAINT: <br>      hDC = BeginPaint( hWnd, &amp;ps ); <br>      GetClientRect( hWnd, &amp;rect ); <br> <br>      SelectObject( hDC, GetStockObject(WHITE_PEN) ); <br>      MoveToEx( hDC, rect.left, rect.top, NULL ); <br>      LineTo( hDC, rect.right+1, rect.top ); <br> <br>      #define DKGRAY_PEN RGB(128, 128, 128) <br>      SelectObject( hDC, (HANDLE) CreatePen( PS_SOLID, 1, DKGRAY_PEN ) ); <br>      MoveToEx( hDC, rect.left, rect.bottom-2, NULL ); <br>      LineTo( hDC, rect.right+1, rect.bottom-2 ); <br> <br>      SelectObject( hDC, (HANDLE) CreatePen( PS_SOLID, 1, BLACK_PEN ) ); <br>      MoveToEx( hDC, rect.left, rect.bottom-1, NULL ); <br>      LineTo( hDC, rect.right+1, rect.bottom-1 ); <br> <br>      DeleteObject( SelectObject( hDC, GetStockObject(BLACK_PEN) ) ); <br>      EndPaint( hWnd, &amp;ps ); <br>      return( FALSE ); <br> <br>    default: <br>      return( DefWindowProc(hWnd, uMsg, wParam, lParam) ); <br>  } <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
