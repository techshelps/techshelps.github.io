<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DEBMISC.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5980"></a>DEBMISC.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples.  <br>*       Copyright 1993 - 1998 Microsoft Corporation. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>// ************************************************************************ <br>// MODULE    : DEBMisc.C <br>// PURPOSE   : Miscellaneous support functions for the Debug Event Browser <br>// FUNCTIONS : <br>//   StartDebuggee()               - starts a new debuggee process <br>//   AttachToDebuggee()            - attaches to an existing process <br>//   EnumProcessListFunc()         - enumeration func for active processes <br>//   GetDebuggeeFileName()         - get the name of a debugee file to open <br>//   ChooseNewFont()               - choose a new font <br>//   ChooseNewBackColor()          - choose a new background color <br>//   MakeCommonDebugEventString()  - create common debug event info string <br>//   CreateTextButtonBar()         - create a text button bar <br>//   CreateIconWindow()            - creates the icon window in the dialog <br>//   GetPrivateProfileSettings()   - gets stored profile settings <br>//   WritePrivateProfileSettings() - stores default settings in profile <br>//   WritePrivateProfileInt()      - opposite of GetPrivateProfileInt() <br>//   UpdateMenuSettings()          - update menu check marks <br>//   OutOfMemoryMessageBox()       - displays an out of memory message box <br>//   MaxDebuggeesMessageBox()      - displays max debuggees exceeded <br>//   ErrorMessageBox()             - displays an error message box <br>//   SubclassWindow()              - generic window subclass func <br>//   SendWmSizeMessage()           - sends WM_SIZE with current size <br>//   GetPathFromFullPathName()     - extracts path from a pathname <br>//   CopyListBoxToClipboard()      - copies a listbox into the clipboard <br>//   ListBoxInsert()               - insert a string into a listbox <br>//   ListBoxPrintF()               - printf for listboxes <br>//   StringPrintF()                - formats a string buffer <br>//   StringAppendF()               - appends a formated string <br>// COMMENTS  : <br>// <br>// ************************************************************************ <br>#define   STRICT               // enable strict typing <br>#include &lt;Windows.H&gt;           // required for all Windows applications <br>#include &lt;CommDlg.H&gt;           // GetOpenFileName(), ChooseFont(), etc. <br>#include &lt;Dlgs.H&gt;              // templates and defines for the common dialogs <br>#include &lt;StdArg.H&gt;            // va_list, va_start() <br> <br>#include "LinkList.H"          // <br>#include "ToolBar.H"           // <br>#include "DEBMisc.H"           // <br> <br> <br>// ************************************************************************ <br>// FUNCTION : StartDebuggee( LPTSTR, HWND ) <br>// PURPOSE  : starts a new debuggee process given a filename <br>// COMMENTS : <br>//   Return TRUE on success else FALSE. <br>// ************************************************************************ <br>BOOL <br>StartDebuggee( LPTSTR lpszDebuggeeFileName, HWND hWndListBox ) <br>{ <br>  static PDEB_STARTUP_INFO pDebStartupInfo; <br>  static BOOL              fFirstTime = TRUE; <br> <br>  static TCHAR szDebuggeeTitle[128]; <br> <br>  HANDLE hDebugEventThread; <br>  DWORD  idDebugEventThread; <br> <br>  //-- Load resource strings and init the OpenFileName struct <br>  //   (do this only one time) <br>  if( fFirstTime ) { <br>    fFirstTime = FALSE; <br>    LoadString( NULL, IDS_OFN_DEBUGGEE_TITLE, szDebuggeeTitle, <br>      sizeof(szDebuggeeTitle)/sizeof(TCHAR) ); <br>  } <br> <br>  //-- allocate the Debuggee Information structure <br>  pDebStartupInfo = NULL; <br>  pDebStartupInfo = (PDEB_STARTUP_INFO) VirtualAlloc( <br>                                    pDebStartupInfo, <br>                                    sizeof( DEB_STARTUP_INFO ), <br>                                    MEM_RESERVE | MEM_COMMIT, <br>                                    PAGE_READWRITE ); <br> <br>  //-- init the StartupInfo struct <br>  (pDebStartupInfo-&gt;StartupInfo).cb          = sizeof( STARTUPINFO ); <br>  (pDebStartupInfo-&gt;StartupInfo).lpDesktop   = NULL; <br>  (pDebStartupInfo-&gt;StartupInfo).lpTitle     = szDebuggeeTitle; <br>  (pDebStartupInfo-&gt;StartupInfo).dwX         = 0; <br>  (pDebStartupInfo-&gt;StartupInfo).dwY         = 0; <br>  (pDebStartupInfo-&gt;StartupInfo).dwXSize     = 0; <br>  (pDebStartupInfo-&gt;StartupInfo).dwYSize     = 0; <br>  (pDebStartupInfo-&gt;StartupInfo).dwFlags     = (DWORD) NULL; <br>  (pDebStartupInfo-&gt;StartupInfo).wShowWindow = SW_SHOWDEFAULT; <br> <br>  (pDebStartupInfo-&gt;ProcessInfo).hProcess = NULL; <br> <br>  //-- init other debuggee info <br>  pDebStartupInfo-&gt;fActive       = FALSE; <br>  pDebStartupInfo-&gt;dwProcessId   = (DWORD) NULL; <br>  pDebStartupInfo-&gt;lpstrFileName = NULL; <br>  pDebStartupInfo-&gt;lpstrPathName = lpszDebuggeeFileName; <br>  pDebStartupInfo-&gt;hWndListBox   = hWndListBox; <br> <br>  //-- now start and detach the debug event processing thread <br>  if( !( hDebugEventThread = CreateThread( <br>                               (LPSECURITY_ATTRIBUTES) NULL, <br>                               (DWORD) 0, <br>                               (LPTHREAD_START_ROUTINE) DebugEventThread, <br>                               (LPVOID) pDebStartupInfo, <br>                               (DWORD) NULL, <br>                               (LPDWORD) &amp;idDebugEventThread) ) ) { <br> <br>    VirtualFree( pDebStartupInfo, 0, MEM_RELEASE ); <br>    return( FALSE ); <br>  } <br>  else{ <br>    CloseHandle( hDebugEventThread ); <br>  } <br> <br>  return( TRUE ); <br>} <br> <br> <br>// ************************************************************************ <br>// FUNCTION : AttachToDebuggee( DWORD, HWND ) <br>// PURPOSE  : attaches to a currently running process <br>// COMMENTS : <br>//   Return TRUE on success else FALSE. <br>// ************************************************************************ <br>BOOL <br>AttachToDebuggee( DWORD dwProcessId, HWND hWndListBox ) <br>{ <br>  static PDEB_STARTUP_INFO pDebStartupInfo; <br>  static BOOL              fFirstTime = TRUE; <br> <br>  static TCHAR szDebuggeeTitle[128]; <br> <br>  HANDLE hDebugEventThread; <br>  DWORD  idDebugEventThread; <br> <br>  //-- Load resource strings and init the OpenFileName struct <br>  //   (do this only one time) <br>  if( fFirstTime ) { <br>    fFirstTime = FALSE; <br>    LoadString( NULL, IDS_OFN_DEBUGGEE_TITLE, szDebuggeeTitle, <br>      sizeof(szDebuggeeTitle)/sizeof(TCHAR) ); <br>  } <br> <br>  //-- allocate the Debuggee Information structure <br>  pDebStartupInfo = NULL; <br>  pDebStartupInfo = (PDEB_STARTUP_INFO) VirtualAlloc( <br>                                    pDebStartupInfo, <br>                                    sizeof( DEB_STARTUP_INFO ), <br>                                    MEM_RESERVE | MEM_COMMIT, <br>                                    PAGE_READWRITE ); <br> <br>  //-- init the StartupInfo struct <br>  (pDebStartupInfo-&gt;StartupInfo).cb          = sizeof( STARTUPINFO ); <br>  (pDebStartupInfo-&gt;StartupInfo).lpDesktop   = NULL; <br>  (pDebStartupInfo-&gt;StartupInfo).lpTitle     = szDebuggeeTitle; <br>  (pDebStartupInfo-&gt;StartupInfo).dwX         = 0; <br>  (pDebStartupInfo-&gt;StartupInfo).dwY         = 0; <br>  (pDebStartupInfo-&gt;StartupInfo).dwXSize     = 0; <br>  (pDebStartupInfo-&gt;StartupInfo).dwYSize     = 0; <br>  (pDebStartupInfo-&gt;StartupInfo).dwFlags     = (DWORD) NULL; <br>  (pDebStartupInfo-&gt;StartupInfo).wShowWindow = SW_SHOWDEFAULT; <br> <br>  (pDebStartupInfo-&gt;ProcessInfo).hProcess = NULL; <br> <br>  //-- init other debuggee info <br>  pDebStartupInfo-&gt;fActive       = TRUE; <br>  pDebStartupInfo-&gt;dwProcessId   = dwProcessId; <br>  pDebStartupInfo-&gt;lpstrFileName = NULL; <br>  pDebStartupInfo-&gt;lpstrPathName = NULL; <br>  pDebStartupInfo-&gt;hWndListBox   = hWndListBox; <br> <br>  //-- now start and detach the debug event processing thread <br>  if( !( hDebugEventThread = CreateThread( <br>                               (LPSECURITY_ATTRIBUTES) NULL, <br>                               (DWORD) 0, <br>                               (LPTHREAD_START_ROUTINE) DebugEventThread, <br>                               (LPVOID) pDebStartupInfo, <br>                               (DWORD) NULL, <br>                               (LPDWORD) &amp;idDebugEventThread) ) ) { <br> <br>    VirtualFree( pDebStartupInfo, 0, MEM_RELEASE ); <br>    return( FALSE ); <br>  } <br>  else{ <br>    CloseHandle( hDebugEventThread ); <br>  } <br> <br>  return( TRUE ); <br>} <br> <br> <br>// ************************************************************************ <br>// FUNCTION : EnumProcessListFunc( HWND, LPARAM ) <br>// PURPOSE  : Callback function for EnumWindows <br>// COMMENTS : Inserts found window title strings into the listbox. <br>//            Return !NULL to continue enumeration. <br>// ************************************************************************ <br>BOOL CALLBACK <br>EnumProcessListFunc( HWND hWnd, LPARAM lParam ) <br>{ <br>  static DWORD dwCurrentProcessId; <br>  static BOOL  fFirstTime = TRUE; <br>  static LONG  MaxStrLen  = 0; <br>  static TCHAR TextBuffer[256]; <br> <br>  if( fFirstTime ) { <br>    fFirstTime = FALSE; <br>    dwCurrentProcessId = GetCurrentProcessId(); <br>  } <br> <br>  if( hWnd ) { <br>    GetWindowText( hWnd, (LPTSTR) &amp;TextBuffer, sizeof(TextBuffer) ); <br>    if( *TextBuffer ) { <br>      DWORD  dwProcessId; <br> <br>      GetWindowThreadProcessId( hWnd, &amp;dwProcessId ); <br>      if( dwProcessId != dwCurrentProcessId ) { <br>        LONG Index; <br>        HWND hWndListBox = (HWND) lParam; <br> <br>        Index = ListBoxInsert( hWndListBox, &amp;MaxStrLen, TextBuffer ); <br>        SendMessage( hWndListBox, LB_SETITEMDATA, (WPARAM) Index, <br>          (LPARAM) dwProcessId ); <br>      } <br>    } <br>  } <br> <br>  return( TRUE ); <br>} <br> <br> <br>// ************************************************************************ <br>// FUNCTION : GetDebuggeeFileName( LPTSTR, HWND ) <br>// PURPOSE  : Get the name of a debugee file to open. <br>// COMMENTS : <br>//   Return TRUE on success else FALSE. <br>// ************************************************************************ <br>BOOL <br>GetDebuggeeFileName( LPTSTR lpszDebuggeeFileName, HWND hWnd ) <br>{ <br>  static BOOL  fFirstTime = TRUE; <br>  static TCHAR szFilter[128]         = TEXT(""); <br>  static TCHAR szTitle[64]           = TEXT(""); <br>  static TCHAR szFileTitle[MAX_PATH] = TEXT(""); <br>  static TCHAR szFile[MAX_PATH]      = TEXT(""); <br>  static TCHAR szDefExt[8]           = TEXT(""); <br>  static OPENFILENAME OpenFileName; <br> <br>  //-- Load resource strings and init the OpenFileName struct <br>  //   (do this only one time) <br>  if( fFirstTime ) { <br>    static UINT FilterNameLen; <br> <br>    fFirstTime = FALSE; <br>    FilterNameLen = (UINT) LoadString( NULL, IDS_OFN_FILTERNAME, <br>                             szFilter, sizeof(szFilter) ); <br>    FilterNameLen++; <br>    LoadString( NULL, IDS_OFN_FILTER, &amp;szFilter[FilterNameLen], <br>      sizeof(szFilter)-FilterNameLen ); <br>    LoadString( NULL, IDS_OFN_TITLE, szTitle, sizeof(szTitle) ); <br> <br>    OpenFileName.lStructSize       = sizeof(OPENFILENAME); <br>    OpenFileName.hwndOwner         = hWnd; <br>    OpenFileName.hInstance         = (HANDLE) NULL; <br>    OpenFileName.lpstrFilter       = szFilter; <br>    OpenFileName.lpstrCustomFilter = NULL; <br>    OpenFileName.nMaxCustFilter    = (DWORD) NULL; <br>    OpenFileName.nFilterIndex      = 1L; <br>    OpenFileName.lpstrFile         = szFile; <br>    OpenFileName.nMaxFile          = sizeof(szFile); <br>    OpenFileName.lpstrFileTitle    = szFileTitle; <br>    OpenFileName.nMaxFileTitle     = sizeof(szFileTitle); <br>    OpenFileName.lpstrInitialDir   = (Profile.fSavedDirectory ? Profile.szInitialDir : NULL); <br>    OpenFileName.lpstrTitle        = (LPTSTR) szTitle; <br>    OpenFileName.Flags             = OFN_HIDEREADONLY; <br>    OpenFileName.nFileOffset       = (WORD) NULL; <br>    OpenFileName.nFileExtension    = (WORD) NULL; <br>    OpenFileName.lpstrDefExt       = szDefExt; <br>    OpenFileName.lCustData         = (DWORD) NULL; <br>    OpenFileName.lpfnHook          = (LPOFNHOOKPROC) NULL; <br>    OpenFileName.lpTemplateName    = (LPTSTR) NULL; <br>  } <br> <br>  if( !GetOpenFileName( &amp;OpenFileName ) ) { <br>    return( FALSE ); <br>  } <br> <br>  //-- store recent directory by stripping off the EXE name from the full path <br>  GetPathFromFullPathName( (LPTSTR) OpenFileName.lpstrFile, Profile.szInitialDir, <br>    sizeof(Profile.szInitialDir) ); <br> <br>  //-- copy name to return buffer <br>  lstrcpy( lpszDebuggeeFileName, OpenFileName.lpstrFile ); <br> <br>  return( TRUE ); <br>} <br> <br> <br>// ************************************************************************ <br>// FUNCTION : ChooseFontHookProc(  ) <br>// PURPOSE  : Disable the Effects group and its contents <br>// COMMENTS : <br>// ************************************************************************ <br>LRESULT CALLBACK <br>ChooseFontHookProc( HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam ) <br>{ <br>  UNREFERENCED_PARAMETER( lParam ); <br>  UNREFERENCED_PARAMETER( wParam ); <br> <br>  switch( uMsg ) { <br> <br>    case WM_INITDIALOG: <br>      ShowWindow( GetDlgItem(hDlg, grp1), SW_HIDE ); <br>      ShowWindow( GetDlgItem(hDlg, chx1), SW_HIDE ); <br>      ShowWindow( GetDlgItem(hDlg, chx2), SW_HIDE ); <br>      break; <br> <br>  } <br> <br>  return( FALSE ); <br>} <br> <br> <br>// ************************************************************************ <br>// FUNCTION : ChooseNewFont( HWND ) <br>// PURPOSE  : Choose a new font for a listbox <br>// COMMENTS : Return TRUE on success else FALSE <br>// ************************************************************************ <br>BOOL <br>ChooseNewFont( HWND hWndListBox ) <br>{ <br>  static CHOOSEFONT ChooseFontStruct; <br>  static BOOL       fFirstTime = TRUE; <br>  HFONT             hFont; <br> <br>  if( fFirstTime ) { <br>    fFirstTime = FALSE; <br> <br>    ChooseFontStruct.lStructSize    = sizeof( CHOOSEFONT ); <br>    ChooseFontStruct.hwndOwner      = hWndListBox; <br>    ChooseFontStruct.hDC            = (HDC) NULL; <br>    ChooseFontStruct.lpLogFont      = &amp;(Profile.LogFont); <br>    ChooseFontStruct.iPointSize     = (INT) NULL; <br>    ChooseFontStruct.Flags          = CF_INITTOLOGFONTSTRUCT | <br>                                      CF_SCREENFONTS | CF_EFFECTS | <br>                                      CF_ENABLEHOOK; <br>    ChooseFontStruct.rgbColors      = Profile.rgbForeColor; <br>    ChooseFontStruct.lCustData      = (DWORD) NULL; <br>    ChooseFontStruct.lpfnHook       = (LPCFHOOKPROC) ChooseFontHookProc; <br>    ChooseFontStruct.lpTemplateName = (LPTSTR) NULL; <br>    ChooseFontStruct.hInstance      = (HANDLE) NULL; <br>    ChooseFontStruct.lpszStyle      = (LPTSTR) NULL; <br>    ChooseFontStruct.nFontType      = SCREEN_FONTTYPE; <br>    ChooseFontStruct.nSizeMin       = (INT) NULL; <br>    ChooseFontStruct.nSizeMax       = (INT) NULL; <br>  } <br> <br>  if( ChooseFont( &amp;ChooseFontStruct ) ) { <br>    HDC    hDC; <br> <br>    hFont = CreateFontIndirect( &amp;(Profile.LogFont) ); <br>    hDC = GetDC( hWndListBox ); <br>    SelectObject( hDC, hFont ); <br>    Profile.rgbForeColor = ChooseFontStruct.rgbColors; <br>    InvalidateRect( hWndListBox, NULL, TRUE ); <br>    SendMessage( hWndListBox, WM_CTLCOLORLISTBOX, (DWORD) hDC, <br>      (LONG) hWndListBox ); <br>    SendMessage( hWndListBox, WM_SETFONT, (DWORD) hFont, TRUE ); <br>    ReleaseDC( hWndListBox, hDC ); <br>  } <br> <br>  return( TRUE ); <br>} <br> <br> <br>// ************************************************************************ <br>// FUNCTION : ChooseNewBackColor( HWND ) <br>// PURPOSE  : Choose the background color for a listbox <br>// COMMENTS : Return TRUE on success else FALSE <br>// ************************************************************************ <br>BOOL <br>ChooseNewBackColor( HWND hWndListBox ) <br>{ <br>  static BOOL        fFirstTime = TRUE; <br>  static CHOOSECOLOR ChooseColorStruct; <br>  static DWORD       dwCustColors[16]; <br> <br>  if( fFirstTime ) { <br>    int i; <br> <br>    fFirstTime = FALSE; <br> <br>    //-- set the custom colors to white <br>    for( i = 0; i &lt; 16; i++ ) <br>      dwCustColors[i] = RGB(255,255,255); <br> <br>    ChooseColorStruct.lStructSize    = sizeof( CHOOSECOLOR ); <br>    ChooseColorStruct.hwndOwner      = hWndListBox; <br>    ChooseColorStruct.hInstance      = (HANDLE) NULL; <br>    ChooseColorStruct.rgbResult      = Profile.rgbBackColor; <br>    ChooseColorStruct.lpCustColors   = (LPDWORD) dwCustColors; <br>    ChooseColorStruct.Flags          = CC_RGBINIT; <br>    ChooseColorStruct.lCustData      = 0L; <br>    ChooseColorStruct.lpfnHook       = (LPCCHOOKPROC) NULL; <br>    ChooseColorStruct.lpTemplateName = (LPTSTR) NULL; <br>  } <br> <br>  if( ChooseColor( &amp;ChooseColorStruct ) ) { <br>    HDC    hDC; <br> <br>    Profile.rgbBackColor = (COLORREF) ChooseColorStruct.rgbResult; <br>    hDC = GetDC( hWndListBox ); <br>    SendMessage( hWndListBox, WM_CTLCOLORLISTBOX, (DWORD) hDC, <br>      (LONG) hWndListBox ); <br>    ReleaseDC( hWndListBox, hDC ); <br>    InvalidateRect( hWndListBox, NULL, TRUE ); <br>  } <br> <br>  return( TRUE ); <br>} <br> <br> <br>// ************************************************************************ <br>// FUNCTION : MakeCommonDebugEventString( LPTSTR, LPDEBUG_EVENT ) <br>// PURPOSE  : Fill in the Debug Event information into a string buffer <br>// COMMENTS : The string buffer contains the information common to all <br>//            debug events ( PID, TID ). <br>// ************************************************************************ <br>BOOL <br>MakeCommonDebugEventString( LPTSTR lpszBuffer, LPDEBUG_EVENT lpDebugEvent ) <br>{ <br>  StringPrintF( lpszBuffer, TEXT( "PID:0x%X \t TID:0x%X \t " ), <br>    lpDebugEvent-&gt;dwProcessId, lpDebugEvent-&gt;dwThreadId ); <br> <br>  return( TRUE ); <br>} <br> <br> <br>// ************************************************************************ <br>// FUNCTION : CreateTextButtonBar( HWND, LPINT ) <br>// PURPOSE  : Creates a Text Button Bar from the resource strings. <br>// COMMENTS : Returns window handle to the created text button bar <br>// ************************************************************************ <br>HWND <br>CreateTextButtonBar( HWND hWndParent, LPINT lpTextButtonBarHeight ) <br>{ <br>  TEXTBUTTON   TextButton[9]; <br>  static TCHAR szButtonOpen[32]; <br>  static TCHAR szButtonAttach[32]; <br>  static TCHAR szButtonCut[32]; <br>  static TCHAR szButtonCopy[32]; <br>  static TCHAR szButtonDelete[32]; <br>  static TCHAR szButtonHelp[32]; <br> <br>  LoadString( NULL, IDS_BUTTON_OPEN,   szButtonOpen,   sizeof(szButtonOpen)/sizeof(TCHAR)   ); <br>  LoadString( NULL, IDS_BUTTON_ATTACH, szButtonAttach, sizeof(szButtonAttach)/sizeof(TCHAR) ); <br>  LoadString( NULL, IDS_BUTTON_CUT,    szButtonCut,    sizeof(szButtonCut)/sizeof(TCHAR)    ); <br>  LoadString( NULL, IDS_BUTTON_COPY,   szButtonCopy,   sizeof(szButtonCopy)/sizeof(TCHAR)   ); <br>  LoadString( NULL, IDS_BUTTON_DELETE, szButtonDelete, sizeof(szButtonDelete)/sizeof(TCHAR) ); <br>  LoadString( NULL, IDS_BUTTON_HELP,   szButtonHelp,   sizeof(szButtonHelp)/sizeof(TCHAR)   ); <br> <br>  TextButton[0].lpButtonText = szButtonOpen; <br>  TextButton[0].idButton     = IDM_FILE_OPEN; <br>  TextButton[0].hWndButton   = NULL; <br> <br>  TextButton[1].lpButtonText = szButtonAttach; <br>  TextButton[1].idButton     = IDM_FILE_ATTACH; <br>  TextButton[1].hWndButton   = NULL; <br> <br>  TextButton[2].lpButtonText = NULL; <br>  TextButton[2].idButton     = TB_SPACE; <br>  TextButton[2].hWndButton   = NULL; <br> <br>  TextButton[3].lpButtonText = szButtonCut; <br>  TextButton[3].idButton     = IDM_EDIT_CUT; <br>  TextButton[3].hWndButton   = NULL; <br> <br>  TextButton[4].lpButtonText = szButtonCopy; <br>  TextButton[4].idButton     = IDM_EDIT_COPY; <br>  TextButton[4].hWndButton   = NULL; <br> <br>  TextButton[5].lpButtonText = szButtonDelete; <br>  TextButton[5].idButton     = IDM_EDIT_DELETE; <br>  TextButton[5].hWndButton   = NULL; <br> <br>  TextButton[6].lpButtonText = NULL; <br>  TextButton[6].idButton     = TB_SPACE; <br>  TextButton[6].hWndButton   = NULL; <br> <br>  TextButton[7].lpButtonText = szButtonHelp; <br>  TextButton[7].idButton     = IDM_HELP_CONTENTS; <br>  TextButton[7].hWndButton   = NULL; <br> <br>  TextButton[8].lpButtonText = (LPTSTR) NULL; <br>  TextButton[8].idButton     = (INT)   NULL; <br>  TextButton[8].hWndButton   = (HWND)  NULL; <br> <br>  return( TextButtonBar( hWndParent, TextButton, lpTextButtonBarHeight ) ); <br>} <br> <br> <br>// ************************************************************************ <br>// FUNCTION : CreateIconWindow( HWND, LPCTSTR ) <br>// PURPOSE  : <br>// COMMENTS : <br>// ************************************************************************ <br>HWND <br>CreateIconWindow( HWND hDlg, LPCTSTR lpstrIcon ) <br>{ <br>  return ( CreateWindow( TEXT( "static" ), lpstrIcon, <br>             WS_CHILD | WS_CLIPSIBLINGS | WS_VISIBLE | SS_ICON, <br>             7, 5, 0, 0, <br>             hDlg, NULL, GetModuleHandle( NULL ), NULL ) ); <br>} <br> <br> <br>// ************************************************************************ <br>// FUNCTION : GetPrivateProfileSettings( LPCTSTR, LPCTSTR, PPROFILE ) <br>// PURPOSE  : Retrieves the stored preferences and options from the <br>//            profile (registry) <br>// COMMENTS : <br>// ************************************************************************ <br>BOOL <br>GetPrivateProfileSettings( LPCTSTR lpszAppTitle, LPCTSTR lpszIniPathName, <br>  PPROFILE pProfile ) <br>{ <br>  pProfile-&gt;xPos       = (INT) GetPrivateProfileInt(  lpszAppTitle, TEXT( "xPos" ),       CW_USEDEFAULT, lpszIniPathName ); <br>  pProfile-&gt;yPos       = (INT) GetPrivateProfileInt(  lpszAppTitle, TEXT( "yPos" ),       CW_USEDEFAULT, lpszIniPathName ); <br>  pProfile-&gt;nWidth     = (INT) GetPrivateProfileInt(  lpszAppTitle, TEXT( "nWidth" ),     CW_USEDEFAULT, lpszIniPathName ); <br>  pProfile-&gt;nHeight    = (INT) GetPrivateProfileInt(  lpszAppTitle, TEXT( "nHeight" ),    CW_USEDEFAULT, lpszIniPathName ); <br>  pProfile-&gt;fMaximized = (BOOL) GetPrivateProfileInt( lpszAppTitle, TEXT( "fMaximized" ), (INT) FALSE,   lpszIniPathName ); <br>  pProfile-&gt;fMinimized = (BOOL) GetPrivateProfileInt( lpszAppTitle, TEXT( "fMinimized" ), (INT) FALSE,   lpszIniPathName ); <br> <br>  pProfile-&gt;fToolBar         = (BOOL) GetPrivateProfileInt( lpszAppTitle, TEXT( "fToolBar" ),         (INT) TRUE,  lpszIniPathName ); <br>  pProfile-&gt;fSavedDirectory  = (BOOL) GetPrivateProfileInt( lpszAppTitle, TEXT( "fSavedDirectory" ),  (INT) TRUE,  lpszIniPathName ); <br>  GetPrivateProfileString( lpszAppTitle, TEXT( "szInitialDir" ), NULL, pProfile-&gt;szInitialDir, <br>    sizeof( pProfile-&gt;szInitialDir ), lpszIniPathName ); <br> <br>  pProfile-&gt;LogFont.lfHeight         = (LONG) GetPrivateProfileInt( lpszAppTitle, TEXT( "lfHeight" ),         (INT) 13   ,       lpszIniPathName ); <br>  pProfile-&gt;LogFont.lfWidth          = (LONG) GetPrivateProfileInt( lpszAppTitle, TEXT( "lfWidth" ),          (INT) 0    ,       lpszIniPathName ); <br>  pProfile-&gt;LogFont.lfWeight         = (LONG) GetPrivateProfileInt( lpszAppTitle, TEXT( "lfWeight" ),         (INT) 400  ,       lpszIniPathName ); <br>  pProfile-&gt;LogFont.lfItalic         = (BYTE) GetPrivateProfileInt( lpszAppTitle, TEXT( "lfItalic" ),         (INT) FALSE,       lpszIniPathName ); <br>  pProfile-&gt;LogFont.lfUnderline      = (BYTE) GetPrivateProfileInt( lpszAppTitle, TEXT( "lfUnderline" ),      (INT) FALSE,       lpszIniPathName ); <br>  pProfile-&gt;LogFont.lfStrikeOut      = (BYTE) GetPrivateProfileInt( lpszAppTitle, TEXT( "lfStrikeOut" ),      (INT) FALSE,       lpszIniPathName ); <br>  pProfile-&gt;LogFont.lfPitchAndFamily = (BYTE) GetPrivateProfileInt( lpszAppTitle, TEXT( "lfPitchAndFamily" ), (INT) FF_DONTCARE, lpszIniPathName ); <br>  GetPrivateProfileString( lpszAppTitle, TEXT( "lfFaceName" ), TEXT( "System" ), pProfile-&gt;LogFont.lfFaceName, <br>    LF_FACESIZE, lpszIniPathName ); <br>  pProfile-&gt;rgbForeColor = (COLORREF) GetPrivateProfileInt( lpszAppTitle, TEXT( "rgbForeColor" ), <br>                            (INT) GetSysColor(COLOR_WINDOWTEXT), lpszIniPathName ); <br>  pProfile-&gt;rgbBackColor = (COLORREF) GetPrivateProfileInt( lpszAppTitle, TEXT( "rgbBackColor" ), <br>                            (INT) GetSysColor(COLOR_WINDOW), lpszIniPathName ); <br> <br>  pProfile-&gt;fClearOnNew      = (BOOL) GetPrivateProfileInt( lpszAppTitle, TEXT( "fClearOnNew" ),      (INT) TRUE,  lpszIniPathName ); <br>  pProfile-&gt;fVerbose         = (BOOL) GetPrivateProfileInt( lpszAppTitle, TEXT( "fVerbose" ),         (INT) FALSE, lpszIniPathName ); <br>  pProfile-&gt;fShowSymbols     = (BOOL) GetPrivateProfileInt( lpszAppTitle, TEXT( "fShowSymbols" ),     (INT) FALSE, lpszIniPathName ); <br>  pProfile-&gt;DebugMode        = (LONG) GetPrivateProfileInt( lpszAppTitle, TEXT( "DebugMode" ),        (INT) DEBUG_PROCESS        , lpszIniPathName ); <br>  pProfile-&gt;DebuggeePriority = (LONG) GetPrivateProfileInt( lpszAppTitle, TEXT( "DebuggeePriority" ), (INT) NORMAL_PRIORITY_CLASS, lpszIniPathName ); <br>  pProfile-&gt;DebugErrorLevel  = (DWORD) GetPrivateProfileInt( lpszAppTitle, TEXT( "DebugErrorLevel" ), (INT) 0, lpszIniPathName ); <br>  pProfile-&gt;fSavePreferences = (BOOL) GetPrivateProfileInt( lpszAppTitle, TEXT( "fSavePreferences" ), (INT) FALSE, lpszIniPathName ); <br> <br>  pProfile-&gt;fSaveOnExit      = (BOOL) GetPrivateProfileInt( lpszAppTitle, TEXT( "fSaveOnExit" ),      (INT) TRUE,  lpszIniPathName ); <br> <br>  return( TRUE ); <br>} <br> <br> <br>// ************************************************************************ <br>// FUNCTION : WritePrivateProfileSettings( LPCTSTR, LPCTSTR, PPROFILE ) <br>// PURPOSE  : Saves the preferences and options to the profile (registry) <br>// COMMENTS : <br>// ************************************************************************ <br>BOOL <br>WritePrivateProfileSettings( LPCTSTR lpszAppTitle, LPCTSTR lpszIniPathName, <br>  PPROFILE pProfile ) <br>{ <br>  if( pProfile-&gt;fSaveOnExit ) { <br>    WritePrivateProfileInt( lpszAppTitle, TEXT( "xPos" ),       (INT) pProfile-&gt;xPos,       lpszIniPathName ); <br>    WritePrivateProfileInt( lpszAppTitle, TEXT( "yPos" ),       (INT) pProfile-&gt;yPos,       lpszIniPathName ); <br>    WritePrivateProfileInt( lpszAppTitle, TEXT( "nWidth" ),     (INT) pProfile-&gt;nWidth,     lpszIniPathName ); <br>    WritePrivateProfileInt( lpszAppTitle, TEXT( "nHeight" ),    (INT) pProfile-&gt;nHeight,    lpszIniPathName ); <br>    WritePrivateProfileInt( lpszAppTitle, TEXT( "fMaximized" ), (INT) pProfile-&gt;fMaximized, lpszIniPathName ); <br>    WritePrivateProfileInt( lpszAppTitle, TEXT( "fMinimized" ), (INT) pProfile-&gt;fMinimized, lpszIniPathName ); <br> <br>    WritePrivateProfileInt( lpszAppTitle, TEXT( "fToolBar" ),         (INT) pProfile-&gt;fToolBar,         lpszIniPathName ); <br>    WritePrivateProfileInt( lpszAppTitle, TEXT( "fSavedDirectory" ),  (INT) pProfile-&gt;fSavedDirectory,  lpszIniPathName ); <br>    WritePrivateProfileString( lpszAppTitle, TEXT( "szInitialDir" ), pProfile-&gt;szInitialDir, lpszIniPathName ); <br> <br>    WritePrivateProfileInt( lpszAppTitle, TEXT( "lfHeight" ),         (INT) pProfile-&gt;LogFont.lfHeight,         lpszIniPathName ); <br>    WritePrivateProfileInt( lpszAppTitle, TEXT( "lfWidth" ),          (INT) pProfile-&gt;LogFont.lfWidth,          lpszIniPathName ); <br>    WritePrivateProfileInt( lpszAppTitle, TEXT( "lfWeight" ),         (INT) pProfile-&gt;LogFont.lfWeight,         lpszIniPathName ); <br>    WritePrivateProfileInt( lpszAppTitle, TEXT( "lfItalic" ),         (INT) pProfile-&gt;LogFont.lfItalic,         lpszIniPathName ); <br>    WritePrivateProfileInt( lpszAppTitle, TEXT( "lfUnderline" ),      (INT) pProfile-&gt;LogFont.lfUnderline,      lpszIniPathName ); <br>    WritePrivateProfileInt( lpszAppTitle, TEXT( "lfStrikeOut" ),      (INT) pProfile-&gt;LogFont.lfStrikeOut,      lpszIniPathName ); <br>    WritePrivateProfileInt( lpszAppTitle, TEXT( "lfPitchAndFamily" ), (INT) pProfile-&gt;LogFont.lfPitchAndFamily, lpszIniPathName ); <br>    WritePrivateProfileString( lpszAppTitle, TEXT( "lfFaceName" ), pProfile-&gt;LogFont.lfFaceName, lpszIniPathName ); <br>    WritePrivateProfileInt( lpszAppTitle, TEXT( "rgbForeColor" ), (INT) pProfile-&gt;rgbForeColor, lpszIniPathName ); <br>    WritePrivateProfileInt( lpszAppTitle, TEXT( "rgbBackColor" ), (INT) pProfile-&gt;rgbBackColor, lpszIniPathName ); <br> <br>    if( pProfile-&gt;fSavePreferences ) { <br>      WritePrivateProfileInt( lpszAppTitle, TEXT( "fClearOnNew" ),  (INT) pProfile-&gt;fClearOnNew,  lpszIniPathName ); <br>      WritePrivateProfileInt( lpszAppTitle, TEXT( "fVerbose" ),     (INT) pProfile-&gt;fVerbose,     lpszIniPathName ); <br>      WritePrivateProfileInt( lpszAppTitle, TEXT( "fShowSymbols" ), (INT) pProfile-&gt;fShowSymbols, lpszIniPathName ); <br>      WritePrivateProfileInt( lpszAppTitle, TEXT( "DebugMode" ),        (INT) pProfile-&gt;DebugMode,        lpszIniPathName ); <br>      WritePrivateProfileInt( lpszAppTitle, TEXT( "DebuggeePriority" ), (INT) pProfile-&gt;DebuggeePriority, lpszIniPathName ); <br>      WritePrivateProfileInt( lpszAppTitle, TEXT( "DebugErrorLevel" ), (INT) pProfile-&gt;DebugErrorLevel, lpszIniPathName ); <br>    } <br>    WritePrivateProfileInt( lpszAppTitle, TEXT( "fSavePreferences" ), (INT) pProfile-&gt;fSavePreferences, lpszIniPathName ); <br>  } <br>  WritePrivateProfileInt( lpszAppTitle, TEXT( "fSaveOnExit" ), (INT) pProfile-&gt;fSaveOnExit, lpszIniPathName ); <br> <br>  return( TRUE ); <br>} <br> <br> <br>// ************************************************************************ <br>// FUNCTION: WritePrivateProfileInt( LPCTSTR, LPCTSTR, INT, LPCTSTR ) <br>// PURPOSE : Writes the value of an integer from a specified keyname within <br>//           a specified section of the Private Profile <br>// COMMENTS: Matched pair to GetPrivateProfileInt <br>// ************************************************************************ <br>BOOL <br>WritePrivateProfileInt( LPCTSTR lpAppName, LPCTSTR lpKeyName, INT Value, LPCTSTR lpFileName ) <br>{ <br>  TCHAR ValBuf[16]; <br> <br>  wsprintf( ValBuf, TEXT( "%i" ), Value); <br> <br>  return( WritePrivateProfileString( lpAppName, lpKeyName, ValBuf, lpFileName ) ); <br>} <br> <br> <br>// ************************************************************************ <br>// FUNCTION : UpdateMenuSettings( HWND ) <br>// PURPOSE  : Adds check marks to active menu items <br>// COMMENTS : <br>// ************************************************************************ <br>BOOL <br>UpdateMenuSettings( HWND hWnd ) <br>{ <br>  if( Profile.fToolBar ) <br>    CheckMenuItem( GetMenu(hWnd), IDM_OPTIONS_TOOLBAR, MF_CHECKED ); <br>  if( Profile.fSavedDirectory ) <br>    CheckMenuItem( GetMenu(hWnd), IDM_OPTIONS_SAVEDDIR, MF_CHECKED ); <br>  if( Profile.fSaveOnExit ) <br>    CheckMenuItem( GetMenu(hWnd), IDM_OPTIONS_SAVEONEXIT, MF_CHECKED ); <br> <br>  return( TRUE ); <br>} <br> <br> <br>// ************************************************************************ <br>// FUNCTION : OutOfMemoryMessageBox( HWND ) <br>// PURPOSE  : If called, displays an "Out of Memory" message box <br>// COMMENTS : <br>// ************************************************************************ <br>BOOL <br>OutOfMemoryMessageBox( HWND hWndOwner ) </code></pre>
<p>
</p>
<pre><code>{ <br>  MessageBox( <br>    hWndOwner, <br>    TEXT( "Out of Memory" ), <br>    TEXT( "Memory Error" ), <br>    MB_ICONSTOP | MB_APPLMODAL ); <br> <br>  return( TRUE ); <br>} <br> <br> <br>// ************************************************************************ <br>// FUNCTION : MaxDebuggeesMessageBox( HWND ) <br>// PURPOSE  : If called, displays an "Max Debuggees" message box <br>// COMMENTS : <br>// ************************************************************************ <br>BOOL <br>MaxDebuggeesMessageBox( HWND hWndOwner ) <br>{ <br>  MessageBox( hWndOwner, <br>    TEXT( "This build of the Debug Event Browser\n" ) <br>    TEXT( "is limited to debugging only one debuggee\n" ) <br>    TEXT( "at a time." ), <br>    TEXT( "Cannot Open Debuggee" ), <br>    MB_OK | MB_ICONEXCLAMATION ); <br> <br>  return( TRUE ); <br>} <br> <br> <br>// ======================================================================== <br>// helper functions <br>// ======================================================================== <br> <br> <br>// ************************************************************************ <br>// FUNCTION : ErrorMessageBox( LPCTSTR, LPCTSTR, LPCTSTR, INT ) <br>// PURPOSE  : Displays an error message box with various error information <br>//            and allows the user to terminate or continue the process. <br>//            For a Win32 Application, GetLastError and FormatMessage are <br>//            used to retrieve the last API error code and error message. <br>// COMMENTS : <br>// ************************************************************************ <br>BOOL <br>ErrorMessageBox( LPCTSTR lpszText, LPCTSTR lpszTitle, LPCTSTR lpszFile, <br>  INT Line ) <br>{ <br>  #define ERROR_BUFFER_SIZE 512 <br> <br>  static TCHAR Format[] = <br>    TEXT( "%s\n\n"                                  ) <br>    TEXT( "-- Error Information --\n"               ) <br>    TEXT( "File : %s\n"                             ) <br>    TEXT( "Line : %d\n"                             ) <br>    TEXT( "Error Number : %d\n"                     ) <br>    TEXT( "Error Message : %s\n"                    ) <br>    TEXT( "\n"                                      ) <br>    TEXT( "Press OK to terminate this application." ); <br> <br>  LPTSTR lpFormatMessageBuffer; <br>  DWORD  dwFormatMessage; <br>  DWORD  dwGetLastError; <br>  HLOCAL hMessageBoxBuffer; <br>  LPVOID lpMessageBoxBuffer; <br> <br>  //-- perform a simple check on the needed buffer size <br>  if( lstrlen(lpszText) &gt; (ERROR_BUFFER_SIZE - lstrlen(Format)) ) <br>    return( FALSE ); <br> <br>  //-- allocate the message box buffer <br>  hMessageBoxBuffer  = LocalAlloc( LMEM_MOVEABLE, ERROR_BUFFER_SIZE ); <br>  lpMessageBoxBuffer = LocalLock( hMessageBoxBuffer ); <br> <br>  //-- get the system error and system error message <br>  dwGetLastError = GetLastError(); <br>  dwFormatMessage = FormatMessage( <br>                      FORMAT_MESSAGE_ALLOCATE_BUFFER <br>                      | FORMAT_MESSAGE_FROM_SYSTEM, <br>                      NULL, dwGetLastError, LANG_NEUTRAL, <br>                      (LPTSTR) &amp;lpFormatMessageBuffer, 0, NULL ); <br>  if( !dwFormatMessage ) <br>    lpFormatMessageBuffer = TEXT("FormatMessage() failed!"); <br> <br>  //-- format the error messge box string <br>  wsprintf( lpMessageBoxBuffer, Format, lpszText, lpszFile, Line, <br>    dwGetLastError, lpFormatMessageBuffer ); <br> <br>  // -- display the error and allow the user to terminate or continue <br>  if( MessageBox( NULL, lpMessageBoxBuffer, lpszTitle, <br>        MB_APPLMODAL | MB_ICONSTOP | MB_OKCANCEL ) <br>    == IDOK ) <br>    ExitProcess( 0 ); <br> <br>  //-- free all buffers <br>  if( dwFormatMessage ) <br>    LocalFree( (HLOCAL) lpFormatMessageBuffer ); <br>  LocalFree( (HLOCAL) hMessageBoxBuffer ); <br> <br>  return( TRUE ); <br>} <br> <br> <br> <br>// ************************************************************************ <br>// FUNCTION : SubclassWindow( HWND, WNDPROC ) <br>// PURPOSE  : Subclasses a window procedure <br>// COMMENTS : Returns the old window procedure <br>// ************************************************************************ <br>WNDPROC <br>SubclassWindow( HWND hWnd, WNDPROC NewWndProc) <br>{ <br>  WNDPROC OldWndProc; <br> <br>  OldWndProc = (WNDPROC) GetWindowLong( hWnd, GWL_WNDPROC ); <br>  SetWindowLong( hWnd, GWL_WNDPROC, (LONG) NewWndProc ); <br> <br>  return OldWndProc; <br>} <br> <br> <br>// ************************************************************************ <br>// FUNCTION : SendWmSizeMessage( HWND ) <br>// PURPOSE  : Sends a WM_SIZE message containing the current size <br>// COMMENTS : Forces a WM_SIZE message without actually changing the size <br>// ************************************************************************ <br>BOOL <br>SendWmSizeMessage( HWND hWnd ) <br>{ <br>  RECT Rect; <br> <br>  if( !GetClientRect( hWnd, &amp;Rect ) ) <br>    return( FALSE ); <br> <br>  return( SendMessage( hWnd, WM_SIZE, SIZENORMAL, <br>            MAKELONG( Rect.right - Rect.left, Rect.bottom - Rect.top) ) ); <br>} <br> <br> <br>// ************************************************************************ <br>// FUNCTION : GetPathFromFullPathName( LPCTSTR, LPTSTR, UINT ) <br>// PURPOSE  : Extracts the path given a full pathname <br>// COMMENTS : <br>// ************************************************************************ <br>UINT <br>GetPathFromFullPathName( LPCTSTR lpFullPathName, LPTSTR lpPathBuffer, <br>  UINT nPathBufferLength ) <br>{ <br>  UINT nLength; <br>  int i, j; <br> <br>  if( (nLength = (UINT) lstrlen( lpFullPathName ) ) &gt; nPathBufferLength ) <br>    return( nLength ); <br> <br>  lstrcpy( lpPathBuffer, lpFullPathName ); <br> <br>  for( j = 0, i = nLength; (UINT)j &lt; nLength; <br>                  j += IsDBCSLeadByte(lpPathBuffer[j]) ? 2 : 1){ <br>      if( lpPathBuffer[j] == '\\' || lpPathBuffer[j] == ':' ){ <br>          i = j; <br>      } <br>  } <br>  if( lpPathBuffer[i] == ':' ) <br>    lpPathBuffer[i+1] = '\0'; <br>  else <br>    lpPathBuffer[i] = '\0'; <br> <br>  return( (UINT) i ); <br>} <br> <br> <br>// ************************************************************************ <br>// FUNCTION : CopyListBoxToClipboard( HWND, LONG ) <br>// PURPOSE  : Copies the entire contents of a listbox into the clipboard. <br>// COMMENTS : Returns TRUE on success, FALSE otherwise <br>// ************************************************************************ <br>BOOL <br>CopyListBoxToClipboard( HWND hWndListBox, LONG MaxStrLen ) <br>{ <br>  LPTSTR  lpDataBuffer; <br>  HGLOBAL hDataBuffer; <br> <br>  TCHAR  TempBuffer[256]; <br>  DWORD  dwItemCount; <br>  DWORD  Count; <br>  LONG   StrLen; <br>  DWORD  dwMemSize; <br> <br>  dwItemCount = (DWORD) SendMessage( hWndListBox, LB_GETCOUNT, 0 , 0 ); <br>  dwMemSize = dwItemCount * (DWORD) MaxStrLen; <br> <br>  //-- limit the size copied to the clipboard <br>  if( dwMemSize &gt; 0xFFFFF ) <br>    dwMemSize = 0xFFFFF; <br> <br>  if( !(hDataBuffer = GlobalAlloc( GMEM_DDESHARE, dwMemSize ) ) ) { <br>    OutOfMemoryMessageBox( GetFocus() ); <br>    return( FALSE ); <br>  } <br>  if( !(lpDataBuffer = (LPTSTR) GlobalLock( hDataBuffer ) ) ) { <br>    GlobalFree( hDataBuffer ); <br>    OutOfMemoryMessageBox( GetFocus() ); <br>    return( FALSE ); <br>  } <br> <br>  *lpDataBuffer = '\0'; <br> <br>  for( Count = 0; Count &lt; dwItemCount; Count++ ) { <br>    StrLen = SendMessage( hWndListBox, LB_GETTEXTLEN, Count, 0L ); <br>    if( StrLen &gt; (sizeof(TempBuffer)-3) ) <br>      continue; <br>    StrLen = SendMessage( hWndListBox, LB_GETTEXT, Count, (LPARAM) TempBuffer ); <br>    TempBuffer[StrLen]   = '\r'; <br>    TempBuffer[StrLen+1] = '\n'; <br>    TempBuffer[StrLen+2] = '\0'; <br>    lstrcat( lpDataBuffer, TempBuffer ); <br>  } <br> <br>  GlobalUnlock( hDataBuffer ); <br> <br>  if( !OpenClipboard( hWndListBox ) ) { <br>    Sleep( 250 );  // wait a quarter second and try again. <br>    if( !OpenClipboard( hWndListBox ) ) { <br>      MessageBox( GetFocus(), <br>        TEXT( "Could not open the Clipboard!" ), <br>        TEXT( "Cannot Open Clipboard" ), <br>        MB_ICONSTOP | MB_APPLMODAL ); <br>      GlobalFree( hDataBuffer ); <br>      return( FALSE ); <br>    } <br>  } <br>  if( !EmptyClipboard() ) { <br>    MessageBox( GetFocus(), <br>      TEXT( "Could not empty the Clipboard!" ), <br>      TEXT( "Cannot Empty Clipboard" ), <br>      MB_ICONSTOP | MB_APPLMODAL ); <br>    GlobalFree( hDataBuffer ); <br>    return( FALSE ); <br>  } <br>  if( !SetClipboardData( CF_TEXT, hDataBuffer ) ) { <br>    MessageBox( GetFocus(), <br>      TEXT( "Could not copy data to the Clipboard!" ), <br>      TEXT( "Cannot Set Clipboard Data" ), <br>      MB_ICONSTOP | MB_APPLMODAL ); <br>    GlobalFree( hDataBuffer ); <br>    return( FALSE ); <br>  } <br>  CloseClipboard(); <br> <br>  return( TRUE ); <br>} <br> <br> <br>// ************************************************************************ <br>// FUNCTION : ListBoxInsert( HWND, LPLONG, LPCTSTR ) <br>// PURPOSE  : Inserts the string into the listbox. <br>// COMMENTS : Returns the index of the string inserted <br>// ************************************************************************ <br>LONG <br>ListBoxInsert( HWND hWndListBox, LPLONG lpMaxStrLen, LPCTSTR lpszString ) <br>{ <br>  static LONG MaxTextExtent = 0; <br> <br>  LONG        Index; <br> <br>  if( lpszString == NULL ) { <br>    MaxTextExtent = 0; <br>    SendMessage( hWndListBox, LB_SETHORIZONTALEXTENT, 0, 0 ); <br>    return( 0 ); <br>  } <br> <br>  if( hWndListBox != NULL ) { <br>    HDC  hDC; <br>    SIZE Size; <br>    LONG StrLen; <br> <br>    if( (StrLen = lstrlen( lpszString)) &gt; *lpMaxStrLen ) <br>      *lpMaxStrLen = StrLen; <br>    hDC = GetDC( hWndListBox ); <br>    GetTextExtentPoint( hDC, lpszString, StrLen, &amp;Size ); <br>    ReleaseDC( hWndListBox, hDC ); <br>    if( Size.cx &gt; MaxTextExtent ) { <br>      MaxTextExtent = Size.cx; <br>      SendMessage( hWndListBox, LB_SETHORIZONTALEXTENT, (WPARAM) (MaxTextExtent*1.1), 0 ); <br>    } <br>    Index = SendMessage( hWndListBox, LB_ADDSTRING, 0, (LPARAM) lpszString ); <br>    SendMessage( hWndListBox, LB_SETCURSEL, Index, 0 ); <br>  } <br> <br>  return( Index ); <br>} <br> <br> <br>// ************************************************************************ <br>// FUNCTION : ListBoxPrintF( HWND, LPCTSTR, ... ) <br>// PURPOSE  : Inserts the string format into the listbox. <br>// COMMENTS : Returns the index of the last string inserted <br>// ************************************************************************ <br>LONG <br>ListBoxPrintF( HWND hWndListBox, LPCTSTR szFormat, ... ) <br>{ <br>  static TCHAR szBuffer[ 1024 ]; <br> <br>  va_list valist; <br>  LONG    Index; <br>  LPTSTR  lpCurrentString, lpCurrentChar; <br> <br>  va_start( valist, szFormat ); <br>  wvsprintf( szBuffer, szFormat, valist ); <br>  va_end( valist ); <br> <br>  //-- insert strings line-by-line <br>  for( lpCurrentString = lpCurrentChar = szBuffer; *lpCurrentChar != '\0'; ) { <br>    if( *lpCurrentChar == '\n' ) { <br>      LPTSTR lpNextChar = CharNext( lpCurrentChar ); <br>      *lpCurrentChar = '\0'; <br>      Index = ListBoxInsert( hWndListBox, &amp;(Global.MaxStrLen), lpCurrentString ); <br>      lpCurrentString = lpCurrentChar = lpNextChar; <br>    } <br>    else <br>      lpCurrentChar = CharNext( lpCurrentChar ); <br>  } <br>  Index = ListBoxInsert( hWndListBox, &amp;(Global.MaxStrLen), lpCurrentString ); <br> <br>  return( Index ); <br>} <br> <br> <br>// ************************************************************************ <br>// FUNCTION : StringPrintF( LPTSTR, LPCTSTR, ... ) <br>// PURPOSE  : Formats a string buffer according to the format-control <br>//            string.  This function is wsprintf but the return <br>//            values is a pointer to the string instead of the count. <br>// COMMENTS : <br>// ************************************************************************ <br>LPTSTR <br>StringPrintF( LPTSTR lpString, LPCTSTR szFormat, ...  ) <br>{ <br>  va_list valist; <br> <br>  va_start( valist, szFormat ); <br>  wvsprintf( lpString, szFormat, valist ); <br>  va_end( valist ); <br> <br>  return( lpString ); <br>} <br> <br> <br>// ************************************************************************ <br>// FUNCTION : StringAppendF( LPTSTR, LPCTSTR, ... ) <br>// PURPOSE  : Append a variable number of characters and values to the end <br>//            of an existing string buffer according to the format string <br>//            (which uses standard printf() formating notation). <br>// COMMENTS : <br>// ************************************************************************ <br>BOOL <br>StringAppendF( LPTSTR lpszBuffer, LPCTSTR szFormat, ... ) <br>{ <br>  static TCHAR szLgBuffer[1024]; <br> <br>  va_list valist; <br>  int n; <br> <br>  //-- add event specific information <br>  va_start( valist, szFormat ); <br>  n = wvsprintf( szLgBuffer, szFormat, valist ); <br>  va_end( valist ); <br> <br>  //-- append information to the string buffer <br>  lstrcat( lpszBuffer, szLgBuffer ); <br> <br>  return( TRUE ); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
