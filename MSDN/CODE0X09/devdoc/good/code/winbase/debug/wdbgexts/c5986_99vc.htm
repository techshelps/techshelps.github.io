<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>WINDBGKD.H</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5988"></a>WINDBGKD.H</h2>
<pre><code>/*++ BUILD Version: 0045    // Increment this if a change has global effects <br> <br>Copyright 1990 - 1998 Microsoft Corporation <br> <br>Module Name: <br> <br>    windbgkd.h <br> <br>Abstract: <br> <br>    This module defines the 32-Bit Windows Kernel Debugger interface. <br> <br>Revision History: <br> <br>--*/ <br> <br>#ifndef _WINDBGKD_ <br>#define _WINDBGKD_ <br> <br>typedef LARGE_INTEGER PHYSICAL_ADDRESS, *PPHYSICAL_ADDRESS; <br> <br>#ifdef _X86_ <br> <br>// <br>// DBGKD_CONTROL_REPORT <br>// <br>// This structure contains machine specific data passed to the debugger <br>// when a Wait_State_Change message is sent.  Idea is to allow debugger <br>// to do what it needes without reading any more packets. <br>// Structure is filled in by KdpSetControlReport <br>// <br> <br>#define DBGKD_MAXSTREAM 16 <br> <br>typedef struct _DBGKD_CONTROL_REPORT { <br>    DWORD   Dr6; <br>    DWORD   Dr7; <br>    WORD    InstructionCount; <br>    WORD    ReportFlags; <br>    BYTE    InstructionStream[DBGKD_MAXSTREAM]; <br>    WORD    SegCs; <br>    WORD    SegDs; <br>    WORD    SegEs; <br>    WORD    SegFs; <br>    DWORD   EFlags; <br>} DBGKD_CONTROL_REPORT, *PDBGKD_CONTROL_REPORT; <br> <br>#define REPORT_INCLUDES_SEGS    0x0001  // this is for backward compatibility <br> <br>// <br>// DBGKD_CONTROL_SET <br>// <br>// This structure control value the debugger wants to set on every <br>// continue, and thus sets here to avoid packet traffic. <br>// <br> <br>typedef struct _DBGKD_CONTROL_SET { <br>    DWORD   TraceFlag;                  // WARNING: This must NOT be a BOOLEAN, <br>                                        //     or host and target will end <br>                                        //     up with different alignments! <br>    DWORD   Dr7; <br>    DWORD   CurrentSymbolStart;         // Range in which to trace locally <br>    DWORD   CurrentSymbolEnd; <br>} DBGKD_CONTROL_SET, *PDBGKD_CONTROL_SET; <br> <br>#endif //_X86_ <br> <br> <br>typedef struct _DESCRIPTOR_TABLE_ENTRY { <br>    DWORD Selector; <br>    LDT_ENTRY Descriptor; <br>} DESCRIPTOR_TABLE_ENTRY, *PDESCRIPTOR_TABLE_ENTRY; <br> <br> <br>#if defined(_MIPS_) | defined(_ALPHA_) | defined(_PPC_) <br> <br>// <br>// Define RISC specific kernel debugger information. <br>// <br>// The following structure contains machine specific data passed to <br>// the host system kernel debugger in a wait state change message. <br>// <br> <br>#define DBGKD_MAXSTREAM 16 <br> <br>typedef struct _DBGKD_CONTROL_REPORT { <br>    DWORD InstructionCount; <br>    BYTE  InstructionStream[DBGKD_MAXSTREAM]; <br>} DBGKD_CONTROL_REPORT, *PDBGKD_CONTROL_REPORT; <br> <br>// <br>// The following structure contains information that the host system <br>// kernel debugger wants to set on every continue operation and avoids <br>// the need to send extra packets of information. <br>// <br> <br>typedef DWORD DBGKD_CONTROL_SET, *PDBGKD_CONTROL_SET; <br> <br>#endif                          // RISC <br> <br>#ifdef _X86_ <br>// <br>// Special Registers for i386 <br>// <br> <br>typedef struct _DESCRIPTOR { <br>    WORD    Pad; <br>    WORD    Limit; <br>    DWORD   Base; <br>} KDESCRIPTOR, *PKDESCRIPTOR; <br> <br>typedef struct _KSPECIAL_REGISTERS { <br>    DWORD Cr0; <br>    DWORD Cr2; <br>    DWORD Cr3; <br>    DWORD Cr4; <br>    DWORD KernelDr0; <br>    DWORD KernelDr1; <br>    DWORD KernelDr2; <br>    DWORD KernelDr3; <br>    DWORD KernelDr6; <br>    DWORD KernelDr7; <br>    KDESCRIPTOR Gdtr; <br>    KDESCRIPTOR Idtr; <br>    WORD   Tr; <br>    WORD   Ldtr; <br>    DWORD Reserved[6]; <br>} KSPECIAL_REGISTERS, *PKSPECIAL_REGISTERS; <br> <br>// <br>// Processor State frame: Before a processor freezes itself, it <br>// dumps the processor state to the processor state frame for <br>// debugger to examine. <br>// <br> <br>typedef struct _KPROCESSOR_STATE { <br>    struct _CONTEXT ContextFrame; <br>    struct _KSPECIAL_REGISTERS SpecialRegisters; <br>} KPROCESSOR_STATE, *PKPROCESSOR_STATE; <br>#endif // _X86_ <br> <br>typedef struct _DBGKM_EXCEPTION { <br>    EXCEPTION_RECORD ExceptionRecord; <br>    DWORD FirstChance; <br>} DBGKM_EXCEPTION, *PDBGKM_EXCEPTION; <br> <br> <br>// <br>// DbgKd APIs are for the portable kernel debugger <br>// <br> <br>// <br>// KD_PACKETS are the low level data format used in KD. All packets <br>// begin with a packet leader, byte count, packet type. The sequence <br>// for accepting a packet is: <br>// <br>//  - read 4 bytes to get packet leader.  If read times out (10 seconds) <br>//    with a short read, or if packet leader is incorrect, then retry <br>//    the read. <br>// <br>//  - next read 2 byte packet type.  If read times out (10 seconds) with <br>//    a short read, or if packet type is bad, then start again looking <br>//    for a packet leader. <br>// <br>//  - next read 4 byte packet Id.  If read times out (10 seconds) <br>//    with a short read, or if packet Id is not what we expect, then <br>//    ask for resend and restart again looking for a packet leader. <br>// <br>//  - next read 2 byte byte count.  If read times out (10 seconds) with <br>//    a short read, or if byte count is greater than PACKET_MAX_SIZE, <br>//    then start again looking for a packet leader. <br>// <br>//  - next read 4 byte packet data checksum. <br>// <br>//  - The packet data immediately follows the packet.  There should be <br>//    ByteCount bytes following the packet header.  Read the packet <br>//    data, if read times out (10 seconds) then start again looking for <br>//    a packet leader. <br>// <br> <br> <br>typedef struct _KD_PACKET { <br>    DWORD PacketLeader; <br>    WORD   PacketType; <br>    WORD   ByteCount; <br>    DWORD PacketId; <br>    DWORD Checksum; <br>} KD_PACKET, *PKD_PACKET; <br> <br> <br>#define PACKET_MAX_SIZE 4000 <br>#define INITIAL_PACKET_ID 0x80800000    // DON't use 0 <br>#define SYNC_PACKET_ID    0x00000800    // Or in with INITIAL_PACKET_ID <br>                                        // to force a packet ID reset. <br> <br>// <br>// BreakIn packet <br>// <br> <br>#define BREAKIN_PACKET                  0x62626262 <br>#define BREAKIN_PACKET_BYTE             0x62 <br> <br>// <br>// Packet lead in sequence <br>// <br> <br>#define PACKET_LEADER                   0x30303030 //0x77000077 <br>#define PACKET_LEADER_BYTE              0x30 <br> <br>#define CONTROL_PACKET_LEADER           0x69696969 <br>#define CONTROL_PACKET_LEADER_BYTE      0x69 <br> <br>// <br>// Packet Trailing Byte <br>// <br> <br>#define PACKET_TRAILING_BYTE            0xAA <br> <br>// <br>// Packet Types <br>// <br> <br>#define PACKET_TYPE_UNUSED              0 <br>#define PACKET_TYPE_KD_STATE_CHANGE     1 <br>#define PACKET_TYPE_KD_STATE_MANIPULATE 2 <br>#define PACKET_TYPE_KD_DEBUG_IO         3 <br>#define PACKET_TYPE_KD_ACKNOWLEDGE      4       // Packet-control type <br>#define PACKET_TYPE_KD_RESEND           5       // Packet-control type <br>#define PACKET_TYPE_KD_RESET            6       // Packet-control type <br>#define PACKET_TYPE_MAX                 7 <br> <br>// <br>// If the packet type is PACKET_TYPE_KD_STATE_CHANGE, then <br>// the format of the packet data is as follows: <br>// <br> <br>#define DbgKdExceptionStateChange   0x00003030L <br>#define DbgKdLoadSymbolsStateChange 0x00003031L <br> <br>// <br>// Pathname Data follows directly <br>// <br> <br>typedef struct _DBGKD_LOAD_SYMBOLS { <br>    DWORD PathNameLength; <br>    PVOID BaseOfDll; <br>    DWORD ProcessId; <br>    DWORD CheckSum; <br>    DWORD SizeOfImage; <br>    BOOLEAN UnloadSymbols; <br>} DBGKD_LOAD_SYMBOLS, *PDBGKD_LOAD_SYMBOLS; <br> <br>typedef struct _DBGKD_WAIT_STATE_CHANGE { <br>    DWORD NewState; <br>    WORD   ProcessorLevel; <br>    WORD   Processor; <br>    DWORD NumberProcessors; <br>    PVOID Thread; <br>    PVOID ProgramCounter; <br>    union { <br>        DBGKM_EXCEPTION Exception; <br>        DBGKD_LOAD_SYMBOLS LoadSymbols; <br>    } u; <br>    DBGKD_CONTROL_REPORT ControlReport; <br>    CONTEXT Context; <br>} DBGKD_WAIT_STATE_CHANGE, *PDBGKD_WAIT_STATE_CHANGE; <br> <br>// <br>// If the packet type is PACKET_TYPE_KD_STATE_MANIPULATE, then <br>// the format of the packet data is as follows: <br>// <br>// Api Numbers for state manipulation <br>// <br> <br>#define DbgKdReadVirtualMemoryApi     0x00003130L <br>#define DbgKdWriteVirtualMemoryApi    0x00003131L <br>#define DbgKdGetContextApi            0x00003132L <br>#define DbgKdSetContextApi            0x00003133L <br>#define DbgKdWriteBreakPointApi       0x00003134L <br>#define DbgKdRestoreBreakPointApi     0x00003135L <br>#define DbgKdContinueApi              0x00003136L <br>#define DbgKdReadControlSpaceApi      0x00003137L <br>#define DbgKdWriteControlSpaceApi     0x00003138L <br>#define DbgKdReadIoSpaceApi           0x00003139L <br>#define DbgKdWriteIoSpaceApi          0x0000313AL <br>#define DbgKdRebootApi                0x0000313BL <br>#define DbgKdContinueApi2             0x0000313CL <br>#define DbgKdReadPhysicalMemoryApi    0x0000313DL <br>#define DbgKdWritePhysicalMemoryApi   0x0000313EL <br>#define DbgKdQuerySpecialCallsApi     0x0000313FL <br>#define DbgKdSetSpecialCallApi        0x00003140L <br>#define DbgKdClearSpecialCallsApi     0x00003141L <br>#define DbgKdSetInternalBreakPointApi 0x00003142L <br>#define DbgKdGetInternalBreakPointApi 0x00003143L <br>#define DbgKdReadIoSpaceExtendedApi   0x00003144L <br>#define DbgKdWriteIoSpaceExtendedApi  0x00003145L <br>#define DbgKdGetVersionApi            0x00003146L <br>#define DbgKdWriteBreakPointExApi     0x00003147L <br>#define DbgKdRestoreBreakPointExApi   0x00003148L <br>#define DbgKdCauseBugCheckApi         0x00003149L <br>#define DbgKdSwitchProcessor          0x00003150L <br> <br>// <br>// Response is a read memory message with data following <br>// <br> <br>typedef struct _DBGKD_READ_MEMORY { <br>    PVOID TargetBaseAddress; <br>    DWORD TransferCount; <br>    DWORD ActualBytesRead; <br>} DBGKD_READ_MEMORY, *PDBGKD_READ_MEMORY; <br> <br>// <br>// Data follows directly <br>// <br> <br>typedef struct _DBGKD_WRITE_MEMORY { <br>    PVOID TargetBaseAddress; <br>    DWORD TransferCount; <br>    DWORD ActualBytesWritten; <br>} DBGKD_WRITE_MEMORY, *PDBGKD_WRITE_MEMORY; <br> <br>// <br>// Response is a get context message with a full context record following <br>// <br> <br>typedef struct _DBGKD_GET_CONTEXT { <br>    DWORD ContextFlags; <br>} DBGKD_GET_CONTEXT, *PDBGKD_GET_CONTEXT; <br> <br>// <br>// Full Context record follows <br>// <br> <br>typedef struct _DBGKD_SET_CONTEXT { <br>    DWORD ContextFlags; <br>} DBGKD_SET_CONTEXT, *PDBGKD_SET_CONTEXT; <br> <br>typedef struct _DBGKD_WRITE_BREAKPOINT { <br>    PVOID BreakPointAddress; <br>    DWORD BreakPointHandle; <br>} DBGKD_WRITE_BREAKPOINT, *PDBGKD_WRITE_BREAKPOINT; <br> <br>typedef struct _DBGKD_RESTORE_BREAKPOINT { <br>    DWORD BreakPointHandle; <br>} DBGKD_RESTORE_BREAKPOINT, *PDBGKD_RESTORE_BREAKPOINT; <br> <br>typedef struct _DBGKD_BREAKPOINTEX { <br>    DWORD     BreakPointCount; <br>    DWORD     ContinueStatus; <br>} DBGKD_BREAKPOINTEX, *PDBGKD_BREAKPOINTEX; <br> <br>typedef struct _DBGKD_CONTINUE { <br>    DWORD    ContinueStatus; <br>} DBGKD_CONTINUE, *PDBGKD_CONTINUE; <br> <br>typedef struct _DBGKD_CONTINUE2 { <br>    DWORD    ContinueStatus; <br>    DBGKD_CONTROL_SET ControlSet; <br>} DBGKD_CONTINUE2, *PDBGKD_CONTINUE2; <br> <br>typedef struct _DBGKD_READ_WRITE_IO { <br>    DWORD DataSize;                     // 1, 2, 4 <br>    PVOID IoAddress; <br>    DWORD DataValue; <br>} DBGKD_READ_WRITE_IO, *PDBGKD_READ_WRITE_IO; <br> <br>typedef struct _DBGKD_READ_WRITE_IO_EXTENDED { <br>    DWORD DataSize;                     // 1, 2, 4 <br>    DWORD InterfaceType; <br>    DWORD BusNumber; <br>    DWORD AddressSpace; <br>    PVOID IoAddress; <br>    DWORD DataValue; <br>} DBGKD_READ_WRITE_IO_EXTENDED, *PDBGKD_READ_WRITE_IO_EXTENDED; <br> <br>typedef struct _DBGKD_QUERY_SPECIAL_CALLS { <br>    DWORD NumberOfSpecialCalls; <br>    // DWORD SpecialCalls[]; <br>} DBGKD_QUERY_SPECIAL_CALLS, *PDBGKD_QUERY_SPECIAL_CALLS; <br> <br>typedef struct _DBGKD_SET_SPECIAL_CALL { <br>    DWORD SpecialCall; <br>} DBGKD_SET_SPECIAL_CALL, *PDBGKD_SET_SPECIAL_CALL; <br> <br>typedef struct _DBGKD_SET_INTERNAL_BREAKPOINT { <br>    DWORD BreakpointAddress; <br>    DWORD Flags; <br>} DBGKD_SET_INTERNAL_BREAKPOINT, *PDBGKD_SET_INTERNAL_BREAKPOINT; <br> <br>typedef struct _DBGKD_GET_INTERNAL_BREAKPOINT { <br>    DWORD BreakpointAddress; <br>    DWORD Flags; <br>    DWORD Calls; <br>    DWORD MaxCallsPerPeriod; <br>    DWORD MinInstructions; <br>    DWORD MaxInstructions; <br>    DWORD TotalInstructions; <br>} DBGKD_GET_INTERNAL_BREAKPOINT, *PDBGKD_GET_INTERNAL_BREAKPOINT; <br> <br>#define DBGKD_INTERNAL_BP_FLAG_COUNTONLY 0x00000001 // don't count instructions <br>#define DBGKD_INTERNAL_BP_FLAG_INVALID   0x00000002 // disabled BP <br>#define DBGKD_INTERNAL_BP_FLAG_SUSPENDED 0x00000004 // temporarily suspended <br>#define DBGKD_INTERNAL_BP_FLAG_DYING     0x00000008 // kill on exit <br> <br>typedef struct _DBGKD_GET_VERSION { <br>    WORD    MajorVersion; <br>    WORD    MinorVersion; <br>    WORD    ProtocolVersion; <br>    WORD    Flags; <br>    DWORD   KernBase; <br>    DWORD   PsLoadedModuleList; <br>} DBGKD_GET_VERSION, *PDBGKD_GET_VERSION; <br> <br>#define DBGKD_VERS_FLAG_MP      0x0001      // kernel is MP built <br> <br> <br>typedef struct _DBGKD_MANIPULATE_STATE { <br>    DWORD ApiNumber; <br>    WORD   ProcessorLevel; <br>    WORD   Processor; <br>    DWORD    ReturnStatus; <br>    union { <br>        DBGKD_READ_MEMORY ReadMemory; <br>        DBGKD_WRITE_MEMORY WriteMemory; <br>        DBGKD_GET_CONTEXT GetContext; <br>        DBGKD_SET_CONTEXT SetContext; <br>        DBGKD_WRITE_BREAKPOINT WriteBreakPoint; <br>        DBGKD_RESTORE_BREAKPOINT RestoreBreakPoint; <br>        DBGKD_CONTINUE Continue; <br>        DBGKD_CONTINUE2 Continue2; <br>        DBGKD_READ_WRITE_IO ReadWriteIo; <br>        DBGKD_READ_WRITE_IO_EXTENDED ReadWriteIoExtended; <br>        DBGKD_QUERY_SPECIAL_CALLS QuerySpecialCalls; <br>        DBGKD_SET_SPECIAL_CALL SetSpecialCall; <br>        DBGKD_SET_INTERNAL_BREAKPOINT SetInternalBreakpoint; <br>        DBGKD_GET_INTERNAL_BREAKPOINT GetInternalBreakpoint; <br>        DBGKD_GET_VERSION GetVersion; <br>        DBGKD_BREAKPOINTEX BreakPointEx; <br>    } u; <br>} DBGKD_MANIPULATE_STATE, *PDBGKD_MANIPULATE_STATE; <br> <br>// <br>// This is the format for the trace data passed back from the kernel to <br>// the debugger to describe multiple calls that have returned since the <br>// last trip back.  The basic format is that there are a bunch of these <br>// (4 byte) unions stuck together.  Each union is of one of two types: a <br>// 4 byte unsigned long interger, or a three field struct, describing a <br>// call (where "call" is delimited by returning or exiting the symbol <br>// scope).  If the number of instructions executed is too big to fit <br>// into a WORD   -1, then the Instructions field has <br>// TRACE_DATA_INSTRUCTIONS_BIG and the next union is a LongNumber <br>// containing the real number of instructions executed. <br>// <br>// The very first union returned in each callback is a LongNumber <br>// containing the number of unions returned (including the "size" <br>// record, os it's always at least 1 even if there's no data to return). <br>// <br>// This is all returned to the debugger when one of two things <br>// happens: <br>// <br>//   1) The pc moves out of all defined symbol ranges <br>//   2) The buffer of trace data entries is filled. <br>// <br>// The "trace done" case is hacked around on the debugger side.  It <br>// guarantees that the pc address that indicates a trace exit never <br>// winds up in a defined symbol range. <br>// <br>// The only other complexity in this system is handling the SymbolNumber <br>// table.  This table is kept in parallel by the kernel and the <br>// debugger.  When the PC exits a known symbol range, the Begin and End <br>// symbol ranges are set by the debugger and are allocated to the next <br>// symbol slot upon return.  "The next symbol slot" means the numerical <br>// next slot number, unless we've filled all slots, in which case it is <br>// #0.  (ie., allocation is cyclic and not LRU or something).  The <br>// SymbolNumber table is flushed when a SpecialCalls call is made (ie., <br>// at the beginning of the WatchTrace). <br>// <br> <br>typedef union _DBGKD_TRACE_DATA { <br>    struct { <br>        BYTE  SymbolNumber; <br>        CHAR LevelChange; <br>        WORD   Instructions; <br>    } s; <br>    DWORD LongNumber; <br>} DBGKD_TRACE_DATA, *PDBGKD_TRACE_DATA; <br> <br>#define TRACE_DATA_INSTRUCTIONS_BIG 0xffff <br> <br>#define TRACE_DATA_BUFFER_MAX_SIZE 40 <br> <br>// <br>// If the packet type is PACKET_TYPE_KD_DEBUG_IO, then <br>// the format of the packet data is as follows: <br>// <br> <br>#define DbgKdPrintStringApi     0x00003230L <br>#define DbgKdGetStringApi       0x00003231L <br> <br>// <br>// For print string, the Null terminated string to print <br>// immediately follows the message <br>// <br>typedef struct _DBGKD_PRINT_STRING { <br>    DWORD LengthOfString; <br>} DBGKD_PRINT_STRING, *PDBGKD_PRINT_STRING; <br> <br>// <br>// For get string, the Null terminated promt string <br>// immediately follows the message. The LengthOfStringRead <br>// field initially contains the maximum number of characters <br>// to read. Upon reply, this contains the number of bytes actually <br>// read. The data read immediately follows the message. <br>// <br>// <br>typedef struct _DBGKD_GET_STRING { <br>    DWORD LengthOfPromptString; <br>    DWORD LengthOfStringRead; <br>} DBGKD_GET_STRING, *PDBGKD_GET_STRING; <br> <br>typedef struct _DBGKD_DEBUG_IO { <br>    DWORD ApiNumber; <br>    WORD   ProcessorLevel; <br>    WORD   Processor; <br>    union { <br>        DBGKD_PRINT_STRING PrintString; <br>        DBGKD_GET_STRING GetString; <br>    } u; <br>} DBGKD_DEBUG_IO, *PDBGKD_DEBUG_IO; <br> <br> <br>VOID <br>NTAPI <br>DbgKdSendBreakIn( <br>    VOID <br>    ); <br> <br>PBYTE <br>NTAPI <br>DbgKdGets( <br>    PBYTE  Buffer, <br>    WORD   Length <br>    ); <br> <br>DWORD <br>NTAPI <br>DbgKdWaitStateChange( <br>    OUT PDBGKD_WAIT_STATE_CHANGE StateChange, <br>    OUT PVOID Buffer, <br>    IN DWORD BufferLength <br>    ); <br> <br>DWORD <br>NTAPI <br>DbgKdContinue ( <br>    IN DWORD    ContinueStatus <br>    ); <br> <br>DWORD <br>NTAPI <br>DbgKdContinue2 ( <br>    IN DWORD    ContinueStatus, <br>    IN DBGKD_CONTROL_SET ControlSet <br>    ); <br> <br>DWORD <br>NTAPI <br>DbgKdReadVirtualMemory( <br>    IN PVOID TargetBaseAddress, <br>    OUT PVOID UserInterfaceBuffer, <br>    IN DWORD TransferCount, <br>    OUT PDWORD ActualBytesRead OPTIONAL <br>    ); <br> <br>DWORD <br>NTAPI <br>DbgKdWriteVirtualMemory( <br>    IN PVOID TargetBaseAddress, <br>    OUT PVOID UserInterfaceBuffer, <br>    IN DWORD TransferCount, <br>    OUT PDWORD ActualBytesWritten OPTIONAL <br>    ); <br> <br>DWORD <br>NTAPI <br>DbgKdReadPhysicalMemory( <br>    IN PHYSICAL_ADDRESS TargetBaseAddress, <br>    OUT PVOID UserInterfaceBuffer, <br>    IN DWORD TransferCount, <br>    OUT PDWORD ActualBytesRead OPTIONAL <br>    ); <br> <br>DWORD <br>NTAPI <br>DbgKdWritePhysicalMemory( <br>    IN PHYSICAL_ADDRESS TargetBaseAddress, <br>    OUT PVOID UserInterfaceBuffer, <br>    IN DWORD TransferCount, <br>    OUT PDWORD ActualBytesWritten OPTIONAL <br>    ); <br> <br>DWORD <br>NTAPI <br>DbgKdReadControlSpace( <br>    IN WORD   Processor, <br>    IN PVOID TargetBaseAddress, <br>    OUT PVOID UserInterfaceBuffer, <br>    IN DWORD TransferCount, <br>    OUT PDWORD ActualBytesRead OPTIONAL <br>    ); <br> <br>DWORD <br>NTAPI <br>DbgKdWriteControlSpace( <br>    IN WORD   Processor, <br>    IN PVOID TargetBaseAddress, <br>    OUT PVOID UserInterfaceBuffer, <br>    IN DWORD TransferCount, <br>    OUT PDWORD ActualBytesWritten OPTIONAL <br>    ); <br> <br>DWORD <br>NTAPI <br>DbgKdReadIoSpace( <br>    IN PVOID IoAddress, <br>    OUT PVOID ReturnedData, <br>    IN DWORD DataSize <br>    ); <br> <br>DWORD <br>NTAPI <br>DbgKdWriteIoSpace( <br>    IN PVOID IoAddress, <br>    IN DWORD DataValue, <br>    IN DWORD DataSize <br>    ); <br> <br>DWORD <br>NTAPI <br>DbgKdGetContext( <br>    IN WORD   Processor, <br>    IN OUT PCONTEXT Context <br>    ); <br> <br>DWORD <br>NTAPI <br>DbgKdSetContext( <br>    IN WORD   Processor, <br>    IN PCONTEXT Context <br>    ); <br> <br>DWORD <br>NTAPI <br>DbgKdWriteBreakPoint( <br>    IN PVOID BreakPointAddress, <br>    OUT PDWORD BreakPointHandle <br>    ); <br> <br>DWORD <br>NTAPI <br>DbgKdRestoreBreakPoint( <br>    IN DWORD BreakPointHandle <br>    ); <br> <br>DWORD <br>NTAPI <br>DbgKdReboot( <br>    VOID <br>    ); <br> <br>#ifdef _X86_ <br>DWORD <br>NTAPI <br>DbgKdLookupSelector( <br>    IN WORD   Processor, <br>    IN OUT PDESCRIPTOR_TABLE_ENTRY pDescriptorTableEntry <br>    ); <br>#endif <br> <br>#define DBG_EXCEPTION_HANDLED           ((DWORD   )0x00010001L) <br> <br>#endif // _WINDBGKD_ <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
