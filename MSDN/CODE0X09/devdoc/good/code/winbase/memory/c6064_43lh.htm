<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>MEMORY.C</title>
<link disabled rel=stylesheet href=../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6065"></a>MEMORY.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples. <br>*       Copyright 1993 - 1998 Microsoft Corporation. <br>*       All rights reserved. <br>*       This source code is only intended as a supplement to <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>/****************************** Module Header ******************************\ <br>* Module Name: memory.c <br>\***************************************************************************/ <br> <br> <br>#include &lt;windows.h&gt; <br>#include "memory.h" <br> <br> <br>HANDLE ghModule; <br>HWND   ghwndMain = NULL; <br>HWND   ghwndClient; <br> <br>HMENU  hMenu,       hMenuWindow; <br>HMENU  hServerMenu, hServerMenuWindow; <br>HMENU  hClientMenu, hClientMenuWindow; <br> <br>CHAR   gszFile[20]; <br>CHAR   gszMapName[20]; <br> <br> <br>typedef struct _PerWndInfo <br>{ <br>    HWND    hParent; <br>    HWND    hThisWnd;           // Used in locating the node <br>    RECT    rcClient; <br>    char    CaptionBarText[SIZEOFCAPTIONTEXT]; <br>} PERWNDINFO, *PPERWNDINFO; <br> <br> <br>typedef struct _node <br>{ <br>   PERWNDINFO      ChildWnd; <br>   HANDLE          hNext; <br>} NODE, *PNODE; <br> <br> <br>/* <br> * Forward declarations. <br> */ <br>BOOL InitializeApp   (void); <br>LONG APIENTRY MainWndProc     (HWND, UINT, DWORD, LONG); <br>LONG APIENTRY ServerWndProc   (HWND, UINT, DWORD, LONG); <br>LONG APIENTRY ClientWndProc   (HWND, UINT, DWORD, LONG); <br>BOOL CALLBACK About          (HWND, UINT, DWORD, LONG); <br>BOOL CALLBACK FileType       (HWND, UINT, DWORD, LONG); <br>BOOL CALLBACK MapFileName     (HWND, UINT, DWORD, LONG); <br>LONG APIENTRY TextWndProc     (HWND, UINT, DWORD, LONG); <br> <br>/***************************************************************************\ <br>* main <br>* <br>\***************************************************************************/ <br> <br>int WINAPI WinMain( <br>    HANDLE hInstance, <br>    HANDLE hPrevInstance, <br>    LPSTR lpCmdLine, <br>    int nShowCmd) <br>{ <br>    MSG msg; <br> <br>    // this will change to something more reasonable <br> <br>    ghModule = GetModuleHandle(NULL); <br>    if (!InitializeApp()) <br>    { <br>        MessageBox(ghwndMain, <br>                   GetStringRes(IDS_ERR_INITAPP_FAILED), <br>                   NULL, MB_OK); <br> <br>        return 0; <br>    } <br> <br>    while (GetMessage(&amp;msg, NULL, 0, 0)) <br>    { <br>        TranslateMessage(&amp;msg); <br>        DispatchMessage(&amp;msg); <br>    } <br> <br>    if (hMenuWindow &amp;&amp; IsWindow(hMenuWindow)) <br>        DestroyMenu(hMenuWindow); <br>    if (hClientMenuWindow &amp;&amp; IsWindow(hClientMenuWindow)) <br>        DestroyMenu(hClientMenuWindow); <br>    if (hServerMenuWindow &amp;&amp; IsWindow(hServerMenuWindow)) <br>        DestroyMenu(hServerMenuWindow); <br>    if (hMenu &amp;&amp; IsWindow(hMenu)) <br>        DestroyMenu(hMenu); <br>    if (hClientMenu &amp;&amp; IsWindow(hClientMenu)) <br>        DestroyMenu(hClientMenu); <br>    if (hServerMenu &amp;&amp; IsWindow(hServerMenu)) <br>        DestroyMenu(hServerMenu); <br> <br>    return 1; <br> <br>    UNREFERENCED_PARAMETER(lpCmdLine); <br>    UNREFERENCED_PARAMETER(nShowCmd); <br>    UNREFERENCED_PARAMETER(hInstance); <br>    UNREFERENCED_PARAMETER(hPrevInstance); <br>} <br> <br> <br>/***************************************************************************\ <br>* InitializeApp <br>* <br>\***************************************************************************/ <br> <br>BOOL InitializeApp(void) <br>{ <br>    WNDCLASS wc; <br> <br>    wc.style            = CS_OWNDC; <br>    wc.lpfnWndProc      = (WNDPROC)MainWndProc; <br>    wc.cbClsExtra       = 0; <br>    wc.cbWndExtra       = sizeof(LONG); <br>    wc.hInstance        = ghModule; <br>    wc.hIcon            = LoadIcon(NULL, IDI_APPLICATION); <br>    wc.hCursor          = LoadCursor(NULL, IDC_ARROW); <br>    wc.hbrBackground    = (HBRUSH)(COLOR_APPWORKSPACE); <br>    wc.lpszMenuName     = "MainMenu"; <br>    wc.lpszClassName    = "MemoryClass"; <br> <br>    if (!RegisterClass(&amp;wc)) <br>        return FALSE; <br> <br>    wc.style            = CS_OWNDC; <br>    wc.lpfnWndProc      = (WNDPROC)ServerWndProc; <br>    wc.cbClsExtra       = 0; <br>    wc.cbWndExtra       = 0;                      // LATER sizeof(LONG); <br>    wc.hInstance        = ghModule; <br>    wc.hIcon            = LoadIcon(NULL, IDI_APPLICATION); <br>    wc.hCursor          = LoadCursor(NULL, IDC_ARROW); <br>    wc.hbrBackground    = (HBRUSH)(COLOR_APPWORKSPACE); <br>    wc.lpszMenuName     = NULL; <br>    wc.lpszClassName    = "ServerClass"; <br> <br>    if (!RegisterClass(&amp;wc)) <br>        return FALSE; <br> <br>    wc.style            = CS_OWNDC; <br>    wc.lpfnWndProc      = (WNDPROC)ClientWndProc; <br>    wc.cbClsExtra       = 0; <br>    wc.cbWndExtra       = 0;                      // LATER sizeof(LONG); <br>    wc.hInstance        = ghModule; <br>    wc.hIcon            = LoadIcon(NULL, IDI_APPLICATION); <br>    wc.hCursor          = LoadCursor(NULL, IDC_ARROW); <br>    wc.hbrBackground    = (HBRUSH)(COLOR_APPWORKSPACE); <br>    wc.lpszMenuName     = NULL; <br>    wc.lpszClassName    = "ClientClass"; <br> <br>    if (!RegisterClass(&amp;wc)) <br>        return FALSE; <br> <br>    wc.style            = CS_OWNDC | CS_HREDRAW | CS_VREDRAW; <br>    wc.lpfnWndProc      = (WNDPROC)TextWndProc; <br>    wc.cbClsExtra       = 0; <br>    wc.cbWndExtra       = 0; <br>    wc.hInstance        = ghModule; <br>    wc.hIcon            = NULL; <br>    wc.hCursor          = LoadCursor(NULL, IDC_ARROW); <br>    wc.hbrBackground    = (HBRUSH)(COLOR_BTNSHADOW); <br>    wc.lpszMenuName     = NULL; <br>    wc.lpszClassName    = "Text"; <br> <br>    if (!RegisterClass(&amp;wc)) <br>            return FALSE; <br> <br> <br> <br>    hMenu       = LoadMenu(ghModule, "MainMenu"); <br>    hServerMenu = LoadMenu(ghModule, "ServerMenu"); <br>    hClientMenu = LoadMenu(ghModule, "ClientMenu"); <br>    hMenuWindow       = GetSubMenu(hMenu, 1); <br>    hServerMenuWindow = GetSubMenu(hServerMenu, 2); <br>    hClientMenuWindow = GetSubMenu(hClientMenu, 2); <br> <br>    ghwndMain = CreateWindowEx(0L, "MemoryClass", "Memory", <br>            WS_OVERLAPPED   | WS_CAPTION     | WS_BORDER       | <br>            WS_THICKFRAME   | WS_MAXIMIZEBOX | WS_MINIMIZEBOX  | <br>            WS_CLIPCHILDREN | WS_VISIBLE     | WS_SYSMENU, <br>            80, 70, 592, 300, <br>            NULL, hMenu, ghModule, NULL); <br> <br>    if (ghwndMain == NULL) <br>        return FALSE; <br> <br>    SetWindowLong(ghwndMain, GWL_USERDATA, 0L); <br> <br>    return TRUE; <br>} <br> <br> <br>/***************************************************************************\ <br>* MainWndProc <br>* <br>\***************************************************************************/ <br> <br>long APIENTRY MainWndProc( <br>                          HWND hwnd, <br>                          UINT message, <br>                          DWORD wParam, <br>                          LONG lParam) <br>{ <br>    static int         iSvrCount=1; <br>    static int         iCltCount=1; <br>    CLIENTCREATESTRUCT clientcreate; <br>    HWND               hwndChildWindow; <br>    BOOL               fSuccess; <br> <br> <br>    switch (message) <br>    { <br> <br>      case WM_CREATE: <br>        SetWindowLong(hwnd, 0, (LONG)NULL); <br> <br>        clientcreate.hWindowMenu  = hMenuWindow; <br>        clientcreate.idFirstChild = 1; <br> <br>        ghwndClient = CreateWindow("MDICLIENT", NULL, <br>                                    WS_CHILD | WS_CLIPCHILDREN | WS_VISIBLE, <br>                                    0,0,0,0, <br>                                    hwnd, NULL, ghModule, (LPVOID)&amp;clientcreate); <br>        return 0L; <br> <br>      case WM_DESTROY: { <br>        PostQuitMessage(0); <br>        return 0L; <br>      } <br> <br>      case WM_COMMAND: <br> <br>        switch (LOWORD(wParam)) <br>        { <br>            case IDM_TILE: <br>                SendMessage(ghwndClient, WM_MDITILE, 0L, 0L); <br>                return 0L; <br>            case IDM_CASCADE: <br>                SendMessage(ghwndClient, WM_MDICASCADE, 0L, 0L); <br>                return 0L; <br>            case IDM_ARRANGE: <br>                SendMessage(ghwndClient, WM_MDIICONARRANGE, 0L, 0L); <br>                return 0L; <br> <br>            case MM_SERVER: { <br>                BOOL fSucess = FALSE; <br>                HANDLE hNode, hHead; <br>                PNODE  pNode; <br>                MDICREATESTRUCT mdicreate; <br> <br>                hNode = LocalAlloc(LHND, (WORD) sizeof(NODE)); <br>                if (hNode &amp;&amp; (pNode = (PNODE)LocalLock(hNode))) <br>                { <br>                    wsprintf((LPSTR) &amp;(pNode-&gt;ChildWnd.CaptionBarText), <br>                             GetStringRes(IDS_SERVER), iSvrCount); <br> <br>                    mdicreate.szClass = "ServerClass"; <br>                    mdicreate.szTitle = (LPTSTR)&amp;(pNode-&gt;ChildWnd.CaptionBarText); <br>                    mdicreate.hOwner  = ghModule; <br>                    mdicreate.x       = <br>                    mdicreate.y       = <br>                    mdicreate.cx      = <br>                    mdicreate.cy      = CW_USEDEFAULT; <br>                    mdicreate.style   = 0l; <br>                    mdicreate.lParam  = 0L; <br> <br>                    /*Create Child Window*/ <br>                    hwndChildWindow = <br>                       (HWND) SendMessage(ghwndClient, WM_MDICREATE, <br>                                          0L, <br>                                          (LONG)(LPMDICREATESTRUCT)&amp;mdicreate); <br> <br>                    if (hwndChildWindow) <br>                    { <br>                       pNode-&gt;ChildWnd.hParent      = ghwndClient; <br>                       pNode-&gt;ChildWnd.hThisWnd     = hwndChildWindow; <br>                       hHead = (HANDLE)GetWindowLong(hwnd, 0); <br>                       pNode-&gt;hNext = hHead; <br>                       SetWindowLong(hwnd, 0, (LONG) hNode); <br> <br>                       iSvrCount++; <br>                       LocalUnlock(hNode); <br> <br>                       fSuccess = TRUE; <br>                    } <br>                    else <br>                    { <br>                       LocalUnlock (hNode); <br>                       LocalFree (hNode); <br> <br>                       fSuccess = FALSE; <br>                    } <br>                } <br>                if (!fSuccess) <br>                    MessageBox(ghwndMain, <br>                               GetStringRes(IDS_ERR_CREATE_CHILD_FAILED), <br>                               NULL, MB_OK); <br> <br>                 return 0L; <br>            } <br> <br>            case MM_CLIENT: <br>            { <br>                BOOL fResult = FALSE; <br>                HANDLE hNode, hHead; <br>                PNODE  pNode; <br>                MDICREATESTRUCT mdicreate; <br> <br>                hNode = LocalAlloc(LHND, (WORD) sizeof(NODE)); <br>                if (hNode &amp;&amp; (pNode = (PNODE)LocalLock(hNode))) <br>                { <br>                    wsprintf((LPSTR) &amp;(pNode-&gt;ChildWnd.CaptionBarText), <br>                             GetStringRes(IDS_CLIENT), iCltCount); <br> <br>                    mdicreate.szClass = "ClientClass"; <br>                    mdicreate.szTitle = (LPSTR) &amp;(pNode-&gt;ChildWnd.CaptionBarText); <br>                    mdicreate.hOwner  = ghModule; <br>                    mdicreate.x       = <br>                    mdicreate.y       = <br>                    mdicreate.cx      = <br>                    mdicreate.cy      = CW_USEDEFAULT; <br>                    mdicreate.style   = 0l; <br>                    mdicreate.lParam  = 0L; <br> <br>                    /*Create Child Window*/ <br>                    hwndChildWindow = <br>                        (HANDLE) SendMessage(ghwndClient, WM_MDICREATE, <br>                                             0L, <br>                                             (LONG)(LPMDICREATESTRUCT)&amp;mdicreate); <br> <br>                    if (hwndChildWindow) <br>                    { <br>                       pNode-&gt;ChildWnd.hParent      = ghwndClient; <br>                       pNode-&gt;ChildWnd.hThisWnd     = hwndChildWindow; <br>                       hHead = (HANDLE)GetWindowLong(hwnd, 0); <br>                       pNode-&gt;hNext = hHead; <br>                       SetWindowLong(hwnd, 0, (LONG) hNode); <br> <br>                       iCltCount++; <br>                       LocalUnlock(hNode); <br> <br>                       fSuccess = TRUE; <br>                    } <br>                    else <br>                    { <br>                       LocalUnlock (hNode); <br>                       LocalFree (hNode); <br> <br>                       fSuccess = FALSE; <br>                    } <br>                } <br>                if (!fSuccess) <br>                   MessageBox(ghwndMain, <br>                              GetStringRes(IDS_ERR_CREATE_CHILD_FAILED), <br>                              NULL, MB_OK); <br> <br>                return 0L; <br>            } <br> <br>            case MM_ABOUT: <br>                if (DialogBox(ghModule, "AboutBox", ghwndMain, (DLGPROC)About) == -1) <br>                   MessageBox(ghwndMain, <br>                              GetStringRes(IDS_ERR_CREATE_DLG_FAILED), NULL, MB_OK); <br>                return 0L; <br> <br>            case MM_OPT_1: <br>            case MM_OPT_2: <br>            case MM_OPT_3: <br>            case MM_OPT_4: <br>            case MM_OPT_5: <br>            case MM_OPT_6: <br>            case MM_OPT_7: <br>            case MM_OPT_8: <br>            { <br>                HWND hActiveChild; <br> <br>                hActiveChild = (HANDLE) SendMessage(ghwndClient, WM_MDIGETACTIVE, 0L, 0L); <br>                if (hActiveChild) <br>                    SendMessage(hActiveChild, WM_COMMAND, wParam, lParam); <br>                return 0L; <br>            } <br> <br>            default: <br>                return DefFrameProc(hwnd,  ghwndClient, message, wParam, lParam); <br>        } <br> <br>    default: <br> <br>        return DefFrameProc(hwnd,  ghwndClient, message, wParam, lParam); <br>    } <br>} <br> <br> <br>/***************************************************************************\ <br>* ServerWndProc <br>* <br>\***************************************************************************/ <br> <br>long APIENTRY ServerWndProc( HWND hwnd, <br>                             UINT message, <br>                             DWORD wParam, <br>                             LONG lParam) <br>{ <br>   static HANDLE MapFileHandle = NULL; <br>   static HANDLE hMem1         = NULL; <br>   static LPVOID pShrMem1      = NULL; <br>   static HANDLE hEdit; <br>   static BOOL   bDirty        = FALSE; <br>   static HWND   hTextWnd; <br>   BOOL          fSuccess; <br> <br>   switch (message) <br>   { <br>      case WM_COMMAND: <br>      { <br> <br>         switch (LOWORD(wParam)) <br>         { <br>            case MM_OPT_1: <br>            { //Create File <br> <br>               SetWindowText(hTextWnd, GetStringRes(IDS_CREATE_MAP_FILE)); <br> <br>               switch (DialogBox(ghModule, "FileType", hwnd, (DLGPROC)FileType)) <br>               { <br>                  case -1: <br>                     fSuccess = FALSE; <br>                     break; <br> <br>                  case IDBTN_MAP: <br>                     if (MapFileHandle = CreateMapFile(gszFile)) <br>                        fSuccess = TRUE; <br>                     else <br>                        fSuccess = FALSE; <br> <br>                     break; <br> <br>                  default: <br>                     MapFileHandle = (HANDLE) 0xFFFFFFFF; <br>                     fSuccess = TRUE; <br>                     break; <br>               } <br> <br>               if (fSuccess) <br>               { <br>                  EnableMenuItem(hServerMenu, MM_OPT_1, MF_GRAYED); <br>                  EnableMenuItem(hServerMenu, MM_OPT_2, MF_ENABLED); <br> <br>                  SetWindowText(hTextWnd, <br>                                GetStringRes(IDS_SEL_CREATE_FILE_MAPPING)); <br>               } <br>               else <br>               { <br>                  SetWindowText(hTextWnd, <br>                                GetStringRes (IDS_ERR_MAPFILE_FAILED)); <br> <br>               } <br>               return 0L; <br>            } <br> <br>            case MM_OPT_2: <br>            { //Create File Mapping <br> <br>               // This option should be disabled until MM_OPT_1 has been chosen. <br> <br>               SetWindowText(hTextWnd, <br>                             GetStringRes(IDS_CREATE_MAPPING)); <br> <br> <br>               if (MapFileHandle) <br>                  switch (DialogBox(ghModule, "MapName", hwnd, (DLGPROC)MapFileName)) <br>                  { <br>                     case IDBTN_OK: <br>                        if (hMem1 = CreateMap(MapFileHandle, gszMapName)) <br>                           fSuccess = TRUE; <br>                        else <br>                           fSuccess = FALSE; <br>                        break; <br> <br>                     default: <br>                        fSuccess = FALSE; <br>                        break; <br>                  } <br>               else <br>                  fSuccess = FALSE; <br> <br> <br>               if (fSuccess) <br>               { <br>                  EnableMenuItem(hServerMenu, MM_OPT_2, MF_GRAYED); <br>                  EnableMenuItem(hServerMenu, MM_OPT_3, MF_ENABLED); <br> <br>                  SetWindowText(hTextWnd, <br>                                GetStringRes (IDS_SEL_MAP_VIEW)); <br>               } <br>               else <br>               { <br>                  SetWindowText(hTextWnd, <br>                                GetStringRes (IDS_ERR_MAPPING_FAILED)); <br> <br>               } <br>               return 0L; <br>            } <br> <br>            case MM_OPT_3: <br>            { //Map View of File <br> <br>               SetWindowText(hTextWnd, GetStringRes (IDS_MAPPING_VIEW)); <br> <br> <br>               if (hMem1 &amp;&amp; (pShrMem1 = (LPVOID)MapView(hMem1))) <br>               { <br>                  EnableMenuItem(hServerMenu, MM_OPT_3, MF_GRAYED); <br>                  EnableMenuItem(hServerMenu, MM_OPT_4, MF_ENABLED); <br> <br>                  SetWindowText(hTextWnd, GetStringRes (IDS_SEL_ACCESS)); <br> <br>               } <br>               else <br>               { <br>                  SetWindowText(hTextWnd, GetStringRes(IDS_ERR_MAPVIEW_FAILED)); <br>               } <br>               return 0L; <br>            } <br> <br>            case MM_OPT_4: <br>            { //Access <br>               RECT    rcl; <br> <br>               SetWindowText(hTextWnd, <br>                             GetStringRes (IDS_ACCESSING_SERVER_WRITE)); <br> <br>               if (pShrMem1) <br>               { <br>                  GetClientRect(hwnd, &amp;rcl); <br>                  hEdit = CreateWindow("edit", (LPSTR) NULL, <br>                                        WS_CHILD      | WS_VISIBLE     | <br>                                        WS_HSCROLL    | WS_VSCROLL     | <br>                                        WS_BORDER     | ES_LEFT | <br>                                        ES_MULTILINE  | ES_AUTOHSCROLL | <br>                                        ES_AUTOVSCROLL, <br>                                        0,0, rcl.right - rcl.left, <br>                                        rcl.bottom - rcl.top - <br>                                        GetWindowLong(hTextWnd, GWL_USERDATA), <br>                                        hwnd, (HMENU)1, ghModule, (LPVOID)NULL); <br>                  if (hEdit) <br>                  { <br>                     EnableMenuItem(hServerMenu, MM_OPT_4, MF_GRAYED); <br>                     SetFocus(hEdit); <br>                     fSuccess = TRUE; <br>                  } <br>                  else <br>                     fSuccess = FALSE; <br>               } <br>               else <br>                  fSuccess = FALSE; <br> <br>               if (!fSuccess) <br>               { <br>                  MessageBox(ghwndMain, <br>                             GetStringRes(IDS_ERR_ACCESS_WRITE_FAILED), <br>                             NULL, MB_OK); <br>                  SetWindowText(hTextWnd, <br>                                GetStringRes (IDS_ERR_ACCESS_WRITE_FAILED)); <br>               } <br> <br>               return 0L; <br>            } <br>         } // End of switch (LOWORD(wParam)) <br> <br>         switch (HIWORD(wParam)) <br>         { <br>            case EN_UPDATE: <br>            { <br>               if (hEdit &amp;&amp; (hEdit == (HWND)lParam)) <br>               { <br>                  bDirty = TRUE; <br>               } <br>               return 0L; <br>            } <br>         } <br> <br>      } <br>      case WM_TIMER: <br>         if (bDirty &amp;&amp; IsWindow(hEdit)) <br>         { <br>            int     iCnt; <br>            iCnt = SendMessage(hEdit, WM_GETTEXT, (WPARAM)4000, (LPARAM)pShrMem1); <br> <br>            if (iCnt) <br>            { <br>               bDirty = FALSE; <br>            } <br> <br>         } <br>         return 0L; <br> <br>      case WM_MDIACTIVATE: <br>         if ((HWND) lParam == hwnd) <br>         { <br>            SendMessage(GetParent(hwnd), WM_MDISETMENU, <br>                        (DWORD)  hServerMenu, <br>                        (LONG)   hServerMenuWindow) ; <br>            DrawMenuBar(GetParent(GetParent(hwnd))) ; <br>         } <br>         return 0; <br> <br>      case WM_SIZE: <br>         if (hEdit) <br>            MoveWindow(hEdit, 0, 0, <br>                       LOWORD(lParam), <br>                       HIWORD(lParam)-GetWindowLong(hTextWnd, GWL_USERDATA), <br>                       TRUE); <br> <br>         MoveWindow(hTextWnd, 0, <br>                    HIWORD(lParam) - GetWindowLong(hTextWnd, GWL_USERDATA), <br>                    LOWORD(lParam), <br>                    HIWORD(lParam), TRUE); <br> <br>         return DefMDIChildProc(hwnd, message, wParam, lParam); <br> <br>      case WM_CREATE: <br>      { <br>         PPERWNDINFO      pWndInfo; <br>         PNODE            pHead; <br>         HANDLE           hHead, hTmp; <br>         RECT             rect; <br> <br>         GetClientRect(hwnd, &amp;rect); <br>         hTextWnd = CreateWindow("Text", NULL, <br>                                 WS_BORDER | SS_LEFT | WS_CHILD | WS_VISIBLE, <br>                                 0, 0, 0, 0, <br>                                 hwnd, <br>                                 (HMENU) 2, <br>                                 ghModule, <br>                                 NULL); <br> <br>         EnableMenuItem(hServerMenu, MM_OPT_1, MF_ENABLED); <br> <br> <br>         SetWindowText(hTextWnd, GetStringRes (IDS_SEL_CREATE_FILE)); <br> <br>         // now find match <br>         hHead = (HANDLE) GetWindowLong(ghwndMain, 0); <br>         if (hHead &amp;&amp; (pHead = (PNODE)LocalLock(hHead))) <br>         { <br>            while ((pHead-&gt;ChildWnd.hThisWnd != hwnd) &amp;&amp; (pHead-&gt;hNext)) <br>            { <br>               hTmp = hHead; <br>               hHead = pHead-&gt;hNext; <br>               LocalUnlock(hTmp); <br> <br>               pHead = (PNODE)LocalLock(hHead); <br>            } <br> <br>            if (pHead-&gt;ChildWnd.hThisWnd == hwnd) <br>            { <br>               pWndInfo = &amp;pHead-&gt;ChildWnd; <br>               GetClientRect(pWndInfo-&gt;hThisWnd, &amp;pWndInfo-&gt;rcClient); <br>            } <br> <br>            LocalUnlock(hHead); <br>         } <br>         return DefMDIChildProc(hwnd, message, wParam, lParam); <br>      } <br> <br>      case WM_CLOSE: <br>      { <br>         PPERWNDINFO      pWndInfo; <br>         PNODE            pHead, pTrail; <br>         HANDLE           hHead, hTmp; <br> <br>         EnableMenuItem(hServerMenu, MM_OPT_2, MF_GRAYED); <br>         EnableMenuItem(hServerMenu, MM_OPT_3, MF_GRAYED); <br>         EnableMenuItem(hServerMenu, MM_OPT_4, MF_GRAYED); <br> <br>         SendMessage(GetParent(hwnd), WM_MDISETMENU, (DWORD)hMenu, (LONG)hMenuWindow); <br>         DrawMenuBar(GetParent(GetParent(hwnd))) ; <br> <br> <br>         // Unmap view, close mapping and file! <br>         if (pShrMem1) <br>         { <br>            UnmapViewOfFile (pShrMem1); <br>            pShrMem1 = NULL; <br>         } <br> <br>         if (hMem1) <br>         { <br>            CloseHandle (hMem1); <br>            hMem1 = NULL; <br>         } <br> <br>         if (MapFileHandle &amp;&amp; MapFileHandle != INVALID_HANDLE_VALUE) <br>         { <br>            CloseHandle (MapFileHandle); <br>            MapFileHandle = NULL; <br>         } <br> <br>         // now find match <br>         hHead = (HANDLE) GetWindowLong(ghwndMain, 0); <br>         if ((hHead) &amp;&amp; (pHead = (PNODE)LocalLock(hHead))) <br>         { <br>            pTrail = pHead; <br>            while ((pHead-&gt;ChildWnd.hThisWnd != hwnd) &amp;&amp; (pHead-&gt;hNext)) <br>            { <br>               hTmp = hHead; <br>               pTrail = pHead; <br>               hHead = pHead-&gt;hNext; <br>               LocalUnlock(hTmp); <br> <br>               pHead = (PNODE) LocalLock(hHead); <br>            } <br> <br>            if (pHead-&gt;ChildWnd.hThisWnd == hwnd) <br>            { <br>               pWndInfo = &amp;pHead-&gt;ChildWnd; <br> <br>               if (pTrail == pHead) <br>                  SetWindowLong(ghwndMain, 0, (LONG) pHead-&gt;hNext); <br>               else <br>                  pTrail-&gt;hNext = pHead-&gt;hNext; <br> <br>               LocalUnlock(hHead); <br>               LocalFree(hHead); <br>            } <br>            else <br>            { <br>               LocalUnlock(hHead); <br>            } <br>         } <br>         return DefMDIChildProc(hwnd, message, wParam, lParam); <br>      } <br> <br>      case WM_DESTROY: <br>         KillTimer(hwnd, 1); <br>         return 0L; <br> <br>      case WM_PAINT: <br>         return DefMDIChildProc(hwnd, message, wParam, lParam); <br> <br>      default: <br>         return DefMDIChildProc(hwnd, message, wParam, lParam); <br>   } <br>} <br> <br> <br>/***************************************************************************\ <br>* ClientWndProc <br>* <br>\***************************************************************************/ <br> <br>long APIENTRY ClientWndProc( HWND hwnd, <br>                             UINT message, <br>                             DWORD wParam, <br>                             LONG lParam) <br>{ <br>    static HANDLE hMem1    = NULL; <br>    static LPVOID pShrMem1 = NULL; <br>    static HANDLE hEdit; <br>    static HANDLE hTextWnd; <br>    BOOL   fSuccess = FALSE; <br> <br>    switch (message) <br>    { <br>        case WM_COMMAND: <br>        { <br> <br>          switch (LOWORD(wParam)) <br>          { <br>             case MM_OPT_5: <br>             { //Open File Mapping <br> <br>                 SetWindowText(hTextWnd, GetStringRes (IDS_OPENING_FILE)); <br> <br>                 switch (DialogBox(ghModule, "MapName", hwnd, (DLGPROC)MapFileName)) <br>                 { <br>                     case IDBTN_OK: <br>                         if (hMem1 = OpenMap(gszMapName)) <br>                             fSuccess = TRUE; <br>                         else <br>                            fSuccess = FALSE; <br>                         break; <br> <br>                     default: <br>                         fSuccess = FALSE; <br>                         break; <br>                 } <br> <br>                 if (fSuccess) <br>                 { <br>                    EnableMenuItem(hClientMenu, MM_OPT_5, MF_GRAYED); <br>                    EnableMenuItem(hClientMenu, MM_OPT_6, MF_ENABLED); <br> <br>                    SetWindowText(hTextWnd, GetStringRes (IDS_SEL_MAP_VIEW)); <br>                 } <br>                 else <br>                 { <br>                    SetWindowText(hTextWnd, <br>                                  GetStringRes (IDS_ERR_OPEN_MAPPING_FAILED)); <br>                 } <br>                 return 0L; <br> <br>            } <br>            case MM_OPT_6: <br>            { //Map View of File <br> <br>                SetWindowText(hTextWnd, GetStringRes (IDS_MAPPING_VIEW)); <br> <br>                if (hMem1 &amp;&amp; (pShrMem1 = (LPVOID) MapView(hMem1))) <br>                { <br>                   EnableMenuItem(hClientMenu, MM_OPT_6, MF_GRAYED); <br>                   EnableMenuItem(hClientMenu, MM_OPT_7, MF_ENABLED); <br> <br>                   SetWindowText(hTextWnd, GetStringRes (IDS_SEL_ACCESS_READ)); <br>                } <br>                else <br>                { <br>                   SetWindowText(hTextWnd, <br>                                 GetStringRes(IDS_ERR_MAPVIEW_FAILED)); <br>                } <br> <br>                return 0L; <br>            } <br> <br>            case MM_OPT_7: <br>            { //Access <br>                RECT    rcl; <br> <br>                 SetWindowText(hTextWnd, <br>                               GetStringRes(IDS_ACCESSING_SERVER_READ)); <br> <br>                 fSuccess = FALSE;  // assume failure. <br> <br>                 if (pShrMem1) <br>                 { <br>                    GetClientRect(hwnd, &amp;rcl); <br> <br>                    hEdit = CreateWindow("edit", NULL, <br>                                   WS_CHILD     | WS_VISIBLE     | <br>                                   WS_HSCROLL   | WS_VSCROLL     | <br>                                   WS_BORDER    | ES_LEFT        | <br>                                   ES_MULTILINE | ES_AUTOHSCROLL | <br>                                   ES_READONLY  | ES_AUTOVSCROLL, <br>                                   0,0, rcl.right-rcl.left, <br>                                   rcl.bottom-rcl.top-GetWindowLong(hTextWnd, GWL_USERDATA), <br>                                   hwnd, (HMENU) 1, ghModule, NULL); <br>                    if (hEdit) <br>                    { <br>                       SetFocus(hEdit); <br>                       fSuccess = TRUE; <br>                    } <br>                 } <br> <br>                 if (fSuccess) <br>                 { <br>                    SendMessage(hEdit, WM_SETTEXT, 0L, (LONG)pShrMem1); <br>                    SetTimer(hwnd, 2, 1000, NULL); <br>                    EnableMenuItem(hClientMenu, MM_OPT_7, MF_GRAYED); <br>                    EnableMenuItem(hClientMenu, MM_OPT_8, MF_ENABLED); <br>                 } <br>                 else <br>                 { <br>                    MessageBox(ghwndMain, <br>                               GetStringRes (IDS_ERR_ACCESS_READ_FAILED), <br>                               NULL, MB_OK); <br>                    SetWindowText(hTextWnd, <br>                                  GetStringRes (IDS_ERR_ACCESS_READ_FAILED)); <br>                 } <br> <br>             return 0L; <br>             } <br> <br>            case MM_OPT_8: <br>            { // refresh now <br>               HANDLE hActive; <br> <br>               hActive = (HANDLE) SendMessage(GetParent(hwnd), WM_MDIGETACTIVE, 0L, 0L); <br>               SendMessage(hEdit, WM_SETTEXT, 0L, (LONG)pShrMem1); <br>               return 0L; <br>            } <br>        } <br>    } <br> <br>    case WM_TIMER: <br>    { <br>        HANDLE hActive; <br> <br>        if (IsWindow (hEdit) &amp;&amp; pShrMem1) <br>        { <br>           hActive = (HANDLE) SendMessage(GetParent(hwnd), WM_MDIGETACTIVE, 0L, 0L); <br>           SendMessage(hEdit, WM_SETTEXT, 0L, (LONG)pShrMem1); </code></pre>
<p>
</p>
<pre><code>} <br>        return 0L; <br>    } <br> <br>    case WM_MDIACTIVATE: <br>        if ((HWND) lParam == hwnd) <br>        { <br>           SendMessage(GetParent(hwnd), WM_MDISETMENU, <br>                       (DWORD)  hClientMenu, <br>                       (LONG)   hClientMenuWindow); <br>           DrawMenuBar(GetParent(GetParent(hwnd))) ; <br>        } <br>        return 0; <br> <br>    case WM_SIZE: <br>        if (hEdit) <br>           MoveWindow(hEdit, 0, 0, <br>                      LOWORD(lParam), <br>                      HIWORD(lParam)-GetWindowLong(hTextWnd, GWL_USERDATA), <br>                      TRUE); <br> <br>        MoveWindow(hTextWnd, 0, <br>                   HIWORD(lParam) - GetWindowLong(hTextWnd, GWL_USERDATA), <br>                   LOWORD(lParam), <br>                   HIWORD(lParam), TRUE); <br> <br>        return DefMDIChildProc(hwnd, message, wParam, lParam); <br> <br>    case WM_CREATE: <br>    { <br>        PPERWNDINFO      pWndInfo; <br>        PNODE            pHead; <br>        HANDLE           hHead, hTmp; <br>        RECT             rect; <br> <br>        GetClientRect(hwnd, &amp;rect); <br>        hTextWnd = CreateWindow("Text", NULL, <br>                                WS_BORDER | SS_LEFT | WS_CHILD | WS_VISIBLE, <br>                                0, 0, 0, 0, <br>                                hwnd, <br>                                (HMENU) 2, <br>                                ghModule, <br>                                NULL); <br> <br>        EnableMenuItem(hClientMenu, MM_OPT_5, MF_ENABLED); <br> <br>        SetWindowText(hTextWnd, GetStringRes (IDS_SEL_OPEN_FILE)); <br> <br>        // now find match <br>        hHead = (HANDLE) GetWindowLong(ghwndMain, 0); <br>        if (hHead &amp;&amp; (pHead = (PNODE)LocalLock(hHead))) <br>        { <br> <br>           while ((pHead-&gt;ChildWnd.hThisWnd != hwnd) &amp;&amp; (pHead-&gt;hNext)) <br>           { <br>              hTmp = hHead; <br>              hHead = pHead-&gt;hNext; <br>              LocalUnlock(hTmp); <br>              pHead = (PNODE) LocalLock(hHead); <br>           } <br> <br>           if (pHead-&gt;ChildWnd.hThisWnd == hwnd) <br>           { <br>              pWndInfo = &amp;pHead-&gt;ChildWnd; <br>              GetClientRect(pWndInfo-&gt;hThisWnd, &amp;pWndInfo-&gt;rcClient); <br>           } <br> <br>           LocalUnlock(hHead); <br>           return DefMDIChildProc(hwnd, message, wParam, lParam); <br>        } <br>        return DefMDIChildProc(hwnd, message, wParam, lParam); <br>    } <br> <br>    case WM_CLOSE: <br>    { <br>        PPERWNDINFO      pWndInfo; <br>        PNODE            pHead, pTrail; <br>        HANDLE           hHead, hTmp; <br> <br> <br>        EnableMenuItem(hClientMenu, MM_OPT_6, MF_GRAYED); <br>        EnableMenuItem(hClientMenu, MM_OPT_7, MF_GRAYED); <br>        EnableMenuItem(hClientMenu, MM_OPT_8, MF_GRAYED); <br> <br>        SendMessage(GetParent(hwnd), WM_MDISETMENU, <br>                    (DWORD) hMenu, <br>                    (LONG)   hMenuWindow) ; <br>        DrawMenuBar(GetParent(GetParent(hwnd))) ; <br> <br>        // Don't need to read from the edit control anymore <br>        KillTimer(hwnd, 2); <br> <br> <br>        // Unmap view, close mapping! <br>        if (pShrMem1) <br>        { <br>           UnmapViewOfFile (pShrMem1); <br>           pShrMem1 = NULL; <br>        } <br> <br>        if (hMem1) <br>        { <br>           CloseHandle (hMem1); <br>           hMem1 = NULL; <br>        } <br> <br> <br>        // now find match <br>        hHead = (HANDLE) GetWindowLong(ghwndMain, 0); <br>        if (hHead &amp;&amp; (pHead = (PNODE)LocalLock(hHead))) <br>        { <br>            pTrail = pHead; <br>            while ((pHead-&gt;ChildWnd.hThisWnd != hwnd) &amp;&amp; (pHead-&gt;hNext)) <br>            { <br>               hTmp = hHead; <br>               pTrail = pHead; <br>               hHead = pHead-&gt;hNext; <br>               LocalUnlock(hTmp); <br> <br>               pHead = (PNODE) LocalLock(hHead); <br>            } <br> <br>            if (pHead-&gt;ChildWnd.hThisWnd == hwnd) <br>            { <br>                pWndInfo = &amp;pHead-&gt;ChildWnd; <br> <br>                if (pTrail == pHead) <br>                    SetWindowLong(ghwndMain, 0, (LONG) pHead-&gt;hNext); <br>                else <br>                    pTrail-&gt;hNext = pHead-&gt;hNext; <br> <br>                LocalUnlock(hHead); <br>                LocalFree(hHead); <br>            } <br>            else <br>            { <br>                LocalUnlock(hHead); <br>            } <br>        } <br>        return DefMDIChildProc(hwnd, message, wParam, lParam); <br> <br>    } <br> <br>    case WM_DESTROY: <br>        return 0l; <br> <br>    default: <br>         return DefMDIChildProc(hwnd, message, wParam, lParam); <br>    } <br> <br>} <br> <br> <br> <br> <br>/***************************************************************************\ <br>* About <br>* <br>* About dialog proc. <br>* <br>\***************************************************************************/ <br> <br>BOOL CALLBACK APIENTRY About( HWND hDlg, <br>                              UINT message, <br>                              DWORD wParam, <br>                              LONG lParam) <br>{ <br>    switch (message) <br>    { <br>        case WM_INITDIALOG: <br>            return TRUE; <br> <br>        case WM_COMMAND: <br>            if (wParam == IDOK) <br>                EndDialog(hDlg, wParam); <br>            break; <br>    } <br>    return FALSE; <br> <br>    UNREFERENCED_PARAMETER(lParam); <br>    UNREFERENCED_PARAMETER(hDlg); <br>} <br> <br>/***************************************************************************\ <br>* MapFileName <br>* <br>* MapFileName dialog proc. <br>* <br>\***************************************************************************/ <br> <br>BOOL CALLBACK MapFileName( HWND hDlg, <br>                           UINT message, <br>                           DWORD wParam, <br>                           LONG lParam) <br>{ <br> <br>    switch (message) <br>    { <br>    case WM_INITDIALOG: <br>        return TRUE; <br> <br>    case WM_COMMAND: <br>        switch (wParam) <br>        { <br>            case IDBTN_OK: <br>            { <br>                if (!GetDlgItemText(hDlg, IDEDIT_MAPNAME, gszMapName, 20)) <br>                { <br>                   strncpy(gszMapName, "MapName1", 10);        // default name <br>                } <br>                EndDialog(hDlg, IDBTN_OK); <br>                break; <br>            } <br>        } <br>    } <br>    return FALSE; <br> <br>    UNREFERENCED_PARAMETER(lParam); <br>    UNREFERENCED_PARAMETER(hDlg); <br>} <br> <br>/***************************************************************************\ <br>* FileType <br>* <br>* FileType dialog proc. <br>* <br>\***************************************************************************/ <br> <br>BOOL CALLBACK FileType( HWND hDlg, <br>                        UINT message, <br>                        DWORD wParam, <br>                        LONG lParam) <br>{ <br> <br>    switch (message) <br>    { <br>       case WM_INITDIALOG: <br>           return TRUE; <br> <br>       case WM_COMMAND: <br>           switch (wParam) <br>           { <br>              case IDBTN_PAGE: <br>              { <br>                 EndDialog(hDlg, IDBTN_PAGE); <br>                 break; <br>              } <br> <br>              case IDBTN_MAP: <br>              { <br>                  if ((GetDlgItemText(hDlg, IDEDIT_MAPFILE, gszFile, 20)) == 0) <br>                      EndDialog(hDlg, IDBTN_PAGE);  // default to use PAGE file <br>                  else <br>                      EndDialog(hDlg, IDBTN_MAP); <br> <br>                  break; <br>              } <br>           } <br>    } <br>    return FALSE; <br> <br>    UNREFERENCED_PARAMETER(lParam); <br>    UNREFERENCED_PARAMETER(hDlg); <br>} <br> <br> <br>/************************************************************************* <br>* <br>* TextWndProc <br>* <br>* Text Window proc. <br>* <br>\***************************************************************************/ <br> <br>LONG APIENTRY TextWndProc (HWND hwnd, UINT message, DWORD wParam, LONG lParam) <br>{ <br>    static HFONT hFont = (HFONT) NULL; <br> <br>    switch (message) <br>    { <br>       case WM_CREATE: <br>       { <br>          LOGFONT    lf; <br>          HDC        hDC; <br>          HFONT      hOldFont; <br>          TEXTMETRIC tm; <br>          RECT       rect; <br>          LONG       lHeight; <br> <br>          SystemParametersInfo(SPI_GETICONTITLELOGFONT, sizeof(lf), &amp;lf, FALSE); <br> <br>          hDC = GetDC(hwnd); <br>          // this is the height for 8 point size font in pixels <br>          lf.lfHeight = 8 * GetDeviceCaps(hDC, LOGPIXELSY) / 72; <br> <br>          hFont = CreateFontIndirect(&amp;lf); <br>          hOldFont = SelectObject(hDC, hFont); <br>          GetTextMetrics(hDC, &amp;tm); <br>          GetClientRect(GetParent(hwnd), &amp;rect); <br> <br>          // base the height of the window on size of text <br>          lHeight = tm.tmHeight+6*GetSystemMetrics(SM_CYBORDER)+2; <br>          // saved the height for later reference <br>          SetWindowLong(hwnd, GWL_USERDATA, lHeight); <br>          SetWindowPos(hwnd, NULL, 0, rect.bottom-lHeight, <br>                       rect.right-rect.left, lHeight, <br>                       SWP_NOZORDER | SWP_NOMOVE); <br> <br>          ReleaseDC(hwnd, hDC); <br>          break; <br>       } <br> <br>    case WM_DESTROY: <br>       if (hFont) <br>          DeleteObject(hFont); <br>       break; <br> <br>    case WM_SETTEXT: <br>       DefWindowProc(hwnd, message, wParam, lParam); <br>       InvalidateRect(hwnd,NULL,FALSE); <br>       UpdateWindow(hwnd); <br>       return 0L; <br> <br>    case WM_PAINT: <br>    { <br>       PAINTSTRUCT ps; <br>       RECT   rc; <br>       char   ach[128]; <br>       int    len, nxBorder, nyBorder; <br>       HFONT  hOldFont = NULL; <br> <br>       BeginPaint(hwnd, &amp;ps); <br> <br>       GetClientRect(hwnd,&amp;rc); <br> <br>       nxBorder = GetSystemMetrics(SM_CXBORDER); <br>       rc.left  += 9*nxBorder; <br>       rc.right -= 9*nxBorder; <br> <br>       nyBorder = GetSystemMetrics(SM_CYBORDER); <br>       rc.top    += 3*nyBorder; <br>       rc.bottom -= 3*nyBorder; <br> <br>       // 3D Text <br>       len = GetWindowText(hwnd, ach, sizeof(ach)); <br>       SetBkColor(ps.hdc, GetSysColor(COLOR_BTNFACE)); <br> <br>       SetBkMode(ps.hdc, TRANSPARENT); <br>       SetTextColor(ps.hdc, RGB(64,96,96)); <br>       if (hFont) <br>           hOldFont = SelectObject(ps.hdc, hFont); <br>       ExtTextOut(ps.hdc, rc.left+2*nxBorder+2, rc.top+2, <br>                  ETO_OPAQUE | ETO_CLIPPED, &amp;rc, ach, len, NULL); <br> <br>       SetTextColor(ps.hdc, RGB(128,128,128)); <br>       if (hFont) <br>           hOldFont = SelectObject(ps.hdc, hFont); <br>       ExtTextOut(ps.hdc, rc.left+2*nxBorder+1, rc.top+1, ETO_CLIPPED, <br>                   &amp;rc, ach, len, NULL); <br> <br>       SetTextColor(ps.hdc, RGB(255,255,255)); <br>       if (hFont) <br>           hOldFont = SelectObject(ps.hdc, hFont); <br>       ExtTextOut(ps.hdc, rc.left+2*nxBorder, rc.top, ETO_CLIPPED, <br>                   &amp;rc, ach, len, NULL); <br> <br>       SetBkMode(ps.hdc, OPAQUE); <br> <br>       if (hOldFont) <br>           SelectObject(ps.hdc, hOldFont); <br> <br>       EndPaint(hwnd, &amp;ps); <br>       return 0L; <br>       } <br>    } <br>    return DefWindowProc(hwnd, message, wParam, lParam); <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>// <br>// FUNCTION:    GetStringRes (int id INPUT ONLY) <br>// <br>// COMMENTS:    Load the resource string with the ID given, and return a <br>//              pointer to it.  Notice that the buffer is common memory so <br>//              the string must be used before this call is made a second time. <br>// <br>//--------------------------------------------------------------------------- <br> <br>LPTSTR GetStringRes (int id) <br>{ <br>  static TCHAR buffer[MAX_PATH]; <br> <br>  buffer[0]=0; <br>  LoadString (GetModuleHandle (NULL), id, buffer, MAX_PATH); <br>  return buffer; <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
