<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>NTMSMLL.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6076"></a>NTMSMLL.CPP</h2>
<pre><code>/* <br> *  This is a part of the Microsoft Source Code Samples. <br> *  Copyright 1996 - 1998 Microsoft Corporation. <br> *  All rights reserved. <br> * <br> *This sample code shows the usage of some portions <br> *of the NTMS API. <br> * <br> *Return codes are, for the most part, not checked in <br> *this code. See the Programmer's reference for error <br> *return information. <br> * <br> * THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF <br> * ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO  <br> * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A <br> * PARTICULAR PURPOSE. <br> * <br> * Copyright 1997 - 1998 Microsoft Corporation.  All Rights Reserved. * <br> */ <br>#include &lt;windows.h&gt; <br>#include "ntmsmll.h" <br>#include "mtf_defs.h" <br>//#include &lt;crt\\wchar.h&gt; <br> <br>////////////////////////////// <br>//       PROTOTYPES         // <br>////////////////////////////// <br>DWORD GetMediaGuid(wchar_t *pDescription, WORD size, GUID &amp;gMediaGuid); <br> <br>DWORD ClaimMediaLabel(const BYTE * const pBuffer, const DWORD nBufferSize, <br>      MediaLabelInfo * const pLabelInfo) <br>{ <br>// local variables  <br>DWORD nError = NO_ERROR ; <br>MTF_TapeDBLK *pLabel ; <br>void *pTapeName, *pSoftwareName ; <br> <br> <br>pLabel = (MTF_TapeDBLK *) pBuffer ; <br>if (strncmp ((char *) pLabel-&gt;BlockHeader.BlockType, MTF_TapeDBLKLabel,  <br>MTF_TapeDBLKLabelSize) == 0) <br>{ <br>// this is an MTF tape ... make sure the TapeName and SoftwareName <br>// strings actually have data in them ... <br>if ((pLabel-&gt;TapeName.Size != 0) &amp;&amp; (pLabel-&gt;SoftwareName.Size != 0)) <br>{ <br>// there are strings in the MTF label ... find the strings that we need ... <br>pTapeName = (void *) ((DWORD) pLabel + (DWORD) pLabel-&gt;TapeName.Offset) ; <br>pSoftwareName = (void *) ((DWORD) pLabel + (DWORD) pLabel-&gt;SoftwareName.Offset) ; <br> <br>// if this MTF tape uses Unicode strings <br>if (pLabel-&gt;BlockHeader.StringType == UNICODE_STR) <br>{ <br>// if this is an NTMS API Demo tape ... <br>if (wcsncmp ((wchar_t *) pSoftwareName, MTF_MediaLabelType_NT_ApiDemo, <br>MTF_MediaLabelType_NT_ApiDemoSize) == 0)  <br>{ <br>// this is an NTMS API Demo tape ... copy the info into the LabelInfo ... <br>wcsncpy(pLabelInfo-&gt;LabelType, (wchar_t *) pSoftwareName, MTF_MediaLabelType_NT_ApiDemoSize) ; <br>pLabelInfo-&gt;LabelType[MTF_MediaLabelType_NT_ApiDemoSize] = '\0' ; <br> <br>// Copy the App Description <br>                    // copying unicode string ... divide the size in half ... <br>wcsncpy(pLabelInfo-&gt;LabelAppDescr, (wchar_t *) pTapeName, (pLabel-&gt;TapeName.Size / 2));  <br>pLabelInfo-&gt;LabelAppDescr[(pLabel-&gt;TapeName.Size / 2)] = '\0' ; <br> <br>                    // if this tape contains a real description/label <br>                    if ((TAPE_MEDIA_LABEL_BIT &amp; pLabel-&gt;TapeAttributes) &amp;&amp; <br>                        (0 &lt; pLabel-&gt;TapeDescription.Size)) <br>                    { <br>                        void *pDescription = (void *) ((DWORD)pLabel +  <br>                            (DWORD)pLabel-&gt;TapeDescription.Offset); <br>                        GUID   gMediaGuid; <br>                        DWORD result = NO_ERROR; <br>                        result = GetMediaGuid((wchar_t *)pDescription,  <br>                                              pLabel-&gt;TapeDescription.Size, <br>                                              gMediaGuid); <br>                        if (NO_ERROR == result) <br>                        { <br>                            // We found a good GUID in the description, use it <br>                            pLabelInfo-&gt;LabelIDSize = sizeof(gMediaGuid); <br>                            memcpy(pLabelInfo-&gt;LabelID,  <br>                                   &amp;gMediaGuid,  <br>                                   pLabelInfo-&gt;LabelIDSize); <br>                            return NO_ERROR; <br>                        } <br>                    } <br>pLabelInfo-&gt;LabelIDSize = sizeof (pLabel-&gt;TapeFamilyID) ; <br>memcpy(pLabelInfo-&gt;LabelID, &amp;pLabel-&gt;TapeFamilyID, pLabelInfo-&gt;LabelIDSize); <br>return NO_ERROR ; <br>} <br>} <br>else // strings are in ANSI form ... <br>{ <br>nError = ERROR_BAD_FORMAT ; <br>} <br>} <br>} <br> <br>// media label was not recognized ... return ERROR_BAD_FORMAT ... <br>return ERROR_BAD_FORMAT ; <br>} <br> <br>DWORD MaxMediaLabel (DWORD * const pMaxSize) <br>{ <br>// local variables  <br>DWORD nError = NO_ERROR ; <br> <br>// set the max size for the seagate label ... <br>*pMaxSize = 1024 ; <br> <br>return nError ; <br>} <br> <br>#define HEX_0 L'0' <br>#define HEX_9 L'9' <br>#define HEX_A L'A' <br>#define HEX_F L'F' <br>#define OUR_STRING wchar_t* <br>#define OUR_BAR L'|' <br>#define OUR_BRACE L'{' <br> <br>DWORD ConvertHex(OUR_STRING str,int length) <br>{ <br>DWORD value = 0; <br>OUR_STRING instr = str; <br>for(int i=0;i&lt;length;i++){ <br>value = value &lt;&lt; 4; <br>if(instr[i] &gt;= HEX_A &amp;&amp; instr[i] &lt;= HEX_F){ <br>value += instr[i]-'A'+10; <br>} else if(instr[i] &gt;= HEX_0 &amp;&amp; instr[i] &lt;= HEX_9){ <br>value += instr[i]-HEX_0; <br>} <br>} <br>return value; <br>} <br> <br>// <br>// TODO - This is the exact same code as in NTBackup.cpp <br>//        Need to make it a .lib somewhere!!! <br>// <br>DWORD GetMediaGuid(OUR_STRING pDescription, WORD size, GUID &amp;gMediaGuid) <br>{ <br>    // <br>    // pDescription is a string delimited by "|" characters <br>    // The GUID we are looking for is the 8th field and has  <br>    // the form "{XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX}" <br>    // we need to cram this into a GUID <br>    //   <br>    // <br>    int numChars = size / sizeof(wchar_t); <br>    // <br>    // Find the 7th "|" <br>    // <br>    WORD BarNum=0; <br>    int CheckChar = 0; <br>    while ((BarNum &lt; 7) &amp;&amp; (CheckChar &lt; numChars)) <br>    { <br>        if (pDescription[CheckChar++] == OUR_BAR) <br>        { <br>            BarNum++; <br>        } <br>    } <br>    if (!( <br>        (7 == BarNum) &amp;&amp;  <br>        (CheckChar &lt; numChars) &amp;&amp;  <br>        (pDescription[CheckChar] == OUR_BRACE)) <br>       ) <br>    { <br>        return ERROR_BAD_FORMAT; <br>    } <br> <br>OUR_STRING pId = &amp;pDescription[CheckChar]; <br>pId++; <br>gMediaGuid.Data1 = ConvertHex(pId,8); <br>pId += 9; <br>gMediaGuid.Data2 = (WORD)ConvertHex(pId,4); <br>pId += 5; <br>gMediaGuid.Data3 = (WORD)ConvertHex(pId,4); <br>pId += 5; <br>int i; <br>for(i=0;i&lt;2;i++){ <br>gMediaGuid.Data4[i] = (BYTE)ConvertHex(pId,2); <br>pId += 2; <br>} <br>pId++; <br>for(i=2;i&lt;8;i++){ <br>gMediaGuid.Data4[i] = (BYTE)ConvertHex(pId,2); <br>pId += 2; <br>} <br>pId++; <br> <br>    return NO_ERROR; <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
