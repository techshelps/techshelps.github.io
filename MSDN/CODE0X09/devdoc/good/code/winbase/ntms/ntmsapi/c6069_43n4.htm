<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>NTMSAPI.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6070"></a>NTMSAPI.CPP</h2>
<pre><code>/* <br> *  This is a part of the Microsoft Source Code Samples. <br> *  Copyright 1996 - 1998 Microsoft Corporation. <br> *  All rights reserved. <br> * <br> *This sample code shows the usage of some portions <br> *of the NTMS API. <br> * <br> *Return codes are, for the most part, not checked in <br> *this code. See the Programmer's reference for error <br> *return information. <br> * <br> * THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF <br> * ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO  <br> * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A <br> * PARTICULAR PURPOSE. <br> * <br> * Copyright 1997 - 1998 Microsoft Corporation.  All Rights Reserved. * <br> */ <br>#include &lt;stdio.h&gt; <br>#include &lt;windows.h&gt; <br>#include &lt;iostream.h&gt; <br>#include "NtmsApi.h" <br>#include "NtmsApiLabel.h" <br> <br>#define NO_CONTAINERNULL <br>#define SIZE_FOR_FIRST_TRY5 <br>#define NULL_PARTID((LPNTMS_NULLGUID)0) <br>#define ALLOCATE_WAIT0 <br>#defineMOUNT_WAITINFINITE <br>#defineREQUESTING_ONE_MOUNT1 <br>#define REQUESTING_ONE_DISMOUNTREQUESTING_ONE_MOUNT <br>#define LABEL_BUFFER_SIZE1024 <br> <br> <br>void writeOmid(HANDLE, BYTE *, DWORD *); <br>void persistPoolID(NTMS_GUID); <br>NTMS_GUID recallPoolID(); <br>void persistMediaID(NTMS_GUID); <br>NTMS_GUID recallMediaID(); <br> <br> <br> <br> <br> <br>// Find the first online library <br>bool <br>findLibrary( HANDLE hSession, NTMS_GUID &amp;gLibID, DWORD &amp;dwRetCode ) <br>{ <br>DWORD dwSize, i; <br>NTMS_GUID *gLibList = NULL; <br>NTMS_OBJECTINFORMATION oiLibraryInfo; <br> <br> <br>// Enumerate the libraries <br>dwSize = SIZE_FOR_FIRST_TRY; <br>for(;;) <br>{ <br>if(gLibList != NULL) <br>free(gLibList); <br>gLibList = (LPNTMS_GUID)malloc(dwSize*sizeof(NTMS_GUID)); <br> <br>dwRetCode = EnumerateNtmsObject(hSession, <br>NO_CONTAINER, <br>gLibList, <br>&amp;dwSize, <br>NTMS_LIBRARY, <br>0); <br> <br>if(dwRetCode == ERROR_INSUFFICIENT_BUFFER) continue; <br>if(dwRetCode == ERROR_SUCCESS) break; <br>free(gLibList); <br>return(false); <br>} <br> <br> <br>// Find the first on-line library  <br>oiLibraryInfo.dwSize = sizeof(oiLibraryInfo); <br>oiLibraryInfo.dwType = NTMS_LIBRARY; <br>for(i=0; i &lt; dwSize; ++i) <br>{ <br>dwRetCode = GetNtmsObjectInformation( hSession, <br>&amp;(gLibList[i]), <br>&amp;oiLibraryInfo); <br>if(oiLibraryInfo.Info.Library.LibraryType == NTMS_LIBRARYTYPE_ONLINE) <br>{ <br> gLibID = gLibList[i]; <br> free(gLibList); <br> return(true); <br>} <br>} <br> <br> <br>dwRetCode = ERROR_NOT_FOUND; <br>free(gLibList); <br>return (false); <br>} <br> <br> <br>// Find the first rewritable media type supported by this library <br>bool <br>findMediaType( HANDLE hSession, NTMS_GUID &amp;gMediaID, DWORD &amp;dwRetCode ) <br>{ <br>DWORD dwSize, i; <br>bool bRetCode; <br>NTMS_GUID *gTypeList = NULL; <br>NTMS_GUID gLib; <br>NTMS_OBJECTINFORMATION oiMediaTypeInfo; <br> <br> <br>// Get the GUID for the library <br>if((bRetCode = findLibrary(hSession, gLib, dwRetCode)) == false) <br>return(false); <br> <br> <br>// Get the list of media type GUIDS in the library <br>dwSize = SIZE_FOR_FIRST_TRY; <br>for(;;) <br>{ <br>if(gTypeList != NULL) <br>free(gTypeList); <br>gTypeList = (LPNTMS_GUID)malloc(dwSize*sizeof(NTMS_GUID)); <br> <br>dwRetCode = EnumerateNtmsObject(hSession, <br>&amp;gLib, <br>gTypeList, <br>&amp;dwSize, <br>NTMS_MEDIA_TYPE, <br>0); <br> <br>if(dwRetCode == ERROR_INSUFFICIENT_BUFFER) continue; <br>if(dwRetCode == ERROR_SUCCESS) break; <br>free(gTypeList); <br>return (false); <br>} <br> <br> <br>// Go through the guid list and find a rewritable media type <br>oiMediaTypeInfo.dwSize = sizeof(oiMediaTypeInfo); <br>oiMediaTypeInfo.dwType = NTMS_MEDIA_TYPE; <br>for (i=0; i &lt; dwSize; ++i) <br>{ <br>dwRetCode = GetNtmsObjectInformation( hSession, <br>&amp;(gTypeList[i]), <br>&amp;oiMediaTypeInfo); <br>if(oiMediaTypeInfo.Info.MediaType.ReadWriteCharacteristics == NTMS_MEDIARW_REWRITABLE) <br>{ <br>gMediaID = gTypeList[i]; <br>free(gTypeList); <br>return (true); <br>} <br>} <br> <br> <br>dwRetCode = ERROR_NOT_FOUND; <br>free(gTypeList); <br>return (false); <br> <br>} <br> <br> <br>// Find the import media pool <br>bool <br>findImportPool( HANDLE hSession, NTMS_GUID &amp;gIpID, DWORD &amp;dwRetCode ) <br>{ <br>DWORD dwSize, i; <br>NTMS_GUID *gPoolList = NULL, gTlPool, gMediaType; <br>NTMS_OBJECTINFORMATION oiMediaPoolInfo; <br>bool bRetCode; <br> <br> <br>// Get the GUID of the media type we're interested in <br>if((bRetCode = findMediaType(hSession, gMediaType, dwRetCode)) == false) <br>return(false); <br> <br> <br>// Get the list of pool GUIDS in the library <br>dwSize = SIZE_FOR_FIRST_TRY; <br>for(;;) <br>{ <br>if(gPoolList != NULL) <br>free(gPoolList); <br>gPoolList = (LPNTMS_GUID)malloc(dwSize*sizeof(NTMS_GUID)); <br> <br>dwRetCode = EnumerateNtmsObject(hSession, <br>NULL, <br>gPoolList, <br>&amp;dwSize, <br>NTMS_MEDIA_POOL, <br>0); <br> <br>if(dwRetCode == ERROR_INSUFFICIENT_BUFFER) continue; <br>if(dwRetCode == ERROR_SUCCESS) break; <br>free(gPoolList); <br>return (false); <br>} <br> <br> <br>// Go through the guid list and find the top level import pool <br>oiMediaPoolInfo.dwSize = sizeof(oiMediaPoolInfo); <br>oiMediaPoolInfo.dwType = NTMS_MEDIA_POOL; <br>for (i=0; i &lt; dwSize; ++i) <br>{ <br>dwRetCode = GetNtmsObjectInformation( hSession, <br>&amp;(gPoolList[i]), <br>&amp;oiMediaPoolInfo); <br>if(oiMediaPoolInfo.Info.MediaPool.PoolType == NTMS_POOLTYPE_IMPORT) <br>{ <br>gTlPool = gPoolList[i]; <br>break; <br>} <br>} <br>if(i == dwSize) <br>{ <br>dwRetCode = ERROR_NOT_FOUND; <br>free(gPoolList); <br>return(false); <br>} <br> <br> <br>// Now we need to find the media-specific pool beneath the top level pool, <br>// so get the list of pool GUIDS in the top level import pool <br>for(;;) <br>{ <br>dwRetCode = EnumerateNtmsObject(hSession, <br>&amp;gTlPool, <br>gPoolList, <br>&amp;dwSize, <br>NTMS_MEDIA_POOL, <br>0); <br> <br>if(dwRetCode == ERROR_INSUFFICIENT_BUFFER) <br>{ <br>free(gPoolList); <br>gPoolList = (LPNTMS_GUID)malloc(dwSize*sizeof(NTMS_GUID)); <br>continue; <br>} <br>if(dwRetCode == ERROR_SUCCESS) break; <br>free(gPoolList); <br>return (false); <br>} <br> <br> <br>// Go through the guid list and find the proper subpool <br>oiMediaPoolInfo.dwSize = sizeof(oiMediaPoolInfo); <br>oiMediaPoolInfo.dwType = NTMS_MEDIA_POOL; <br>for (i=0; i &lt; dwSize; ++i) <br>{ <br>dwRetCode = GetNtmsObjectInformation( hSession, <br>&amp;(gPoolList[i]), <br>&amp;oiMediaPoolInfo); <br>if(oiMediaPoolInfo.Info.MediaPool.MediaType == gMediaType) <br>{ <br>gIpID = gPoolList[i]; <br>free(gPoolList); <br>return (true); <br>} <br>} <br> <br> <br>dwRetCode = ERROR_NOT_FOUND; <br>free(gPoolList); <br>return (false); <br> <br>} <br> <br> <br>void <br>UseCase1() <br>{ <br>HANDLE hSession; <br>DWORD dwRetCode; <br>bool bRetCode; <br>NTMS_GUID gMediaType; <br>NTMS_GUID gMediaPool; <br>NTMS_OBJECTINFORMATION oiInfoBuffer; <br> <br> <br>// Start an NTMS session <br>hSession = OpenNtmsSession ("", "ApiSampleApp", 0); <br>if(hSession == INVALID_HANDLE_VALUE) <br>dwRetCode = GetLastError(); <br> <br> <br>// Get a GUID for a read/write media type <br>if((bRetCode = findMediaType(hSession, gMediaType, dwRetCode)) == false) <br>return; <br> <br> <br>// Create a pool for this app, returns a GUID  <br>dwRetCode = CreateNtmsMediaPool( hSession, <br>"API_Sample_Pool", <br>&amp;gMediaType, <br>NTMS_OPEN_ALWAYS, <br>NULL, <br>&amp;gMediaPool); <br> <br> <br>// Set this new pool to automatically draw media from the scratch pool <br>// when allocating by first reading the info associated with the <br>// pool GUID, changing the "allocate from scratch" bit and then setting <br>// the pool info <br>oiInfoBuffer.dwSize = sizeof(oiInfoBuffer); <br>oiInfoBuffer.dwType = NTMS_MEDIA_POOL; <br>dwRetCode = GetNtmsObjectInformation( hSession, <br>&amp;gMediaPool, <br>&amp;oiInfoBuffer); <br> <br>oiInfoBuffer.Info.MediaPool.AllocationPolicy =  <br> NTMS_ALLOCATE_FROMSCRATCH; <br> <br>dwRetCode = SetNtmsObjectInformation (hSession, <br>&amp;gMediaPool, <br>&amp;oiInfoBuffer); <br> <br> <br>// Remember the pool GUID for future use <br>persistPoolID(gMediaPool); <br> <br> <br>// That's all for this scenario <br>CloseNtmsSession(hSession); <br>} <br> <br> <br>void <br>UseCase2() <br>{ <br>HANDLE hSession, hDrive; <br>DWORD dwRetCode, labelBytesWritten = LABEL_BUFFER_SIZE; <br>NTMS_GUID gPoolID, gMediaID, gDriveID; <br>NTMS_OBJECTINFORMATION oiDriveInfo; <br>BYTE labelBuffer[LABEL_BUFFER_SIZE]; <br> <br> <br>// Start an NTMS session <br>hSession = OpenNtmsSession ("", "DemoApp", 0) ; <br>if(hSession == INVALID_HANDLE_VALUE) <br>dwRetCode = GetLastError(); <br> <br> <br>// We need to write some data, but don't have a piece of <br>// media to write it to. <br>// <br>// Get a piece of media to use and remember the guid <br>gPoolID = recallPoolID(); <br>dwRetCode = AllocateNtmsMedia(hSession, <br>&amp;gPoolID, <br>NULL, <br>&amp;gMediaID, <br>NTMS_ALLOCATE_NEW,  <br>ALLOCATE_WAIT); <br>persistMediaID(gMediaID); <br> <br> <br>// Mount the piece of media in a drive, returns a drive GUID <br>dwRetCode = MountNtmsMedia(hSession, <br>&amp;gMediaID, <br>&amp;gDriveID, <br>REQUESTING_ONE_MOUNT, <br>NTMS_MOUNT_ERROR_NOT_AVAILABLE, <br>NTMS_PRIORITY_NORMAL, <br>MOUNT_WAIT); <br> <br> <br>// Open the drive the media is in <br>oiDriveInfo.dwSize = sizeof(oiDriveInfo); <br>oiDriveInfo.dwType = NTMS_DRIVE; <br>dwRetCode = GetNtmsObjectInformation(hSession, <br>&amp;gDriveID, <br>&amp;oiDriveInfo); <br> <br>hDrive = CreateFile(oiDriveInfo.Info.Drive.szDeviceName, <br>                    GENERIC_READ | GENERIC_WRITE, <br>                    0, <br>                    NULL, <br>                    OPEN_EXISTING, <br>                    FILE_ATTRIBUTE_NORMAL, <br>                    NULL); <br> <br> <br>// Write the OMID and tell NTMS <br>writeOmid(hDrive, labelBuffer, &amp;labelBytesWritten); <br>dwRetCode = UpdateNtmsOmidInfo(hSession, <br>&amp;gMediaID, <br>NTMS_OMID_TYPE_RAW_LABEL, <br>labelBytesWritten, <br>(void *)labelBuffer); <br> <br> <br>// Write data via Win32 API calls, close device when done. <br> <br>// write, write, write, ... <br>CloseHandle(hDrive); <br> <br> <br>// Dismount the media <br>dwRetCode = DismountNtmsMedia( hSession, <br>&amp;gMediaID, <br>REQUESTING_ONE_DISMOUNT, <br>0); <br> <br> <br>// That's all for this scenario <br>CloseNtmsSession(hSession); <br>} <br> <br> <br> <br>void <br>UseCase3() <br>{ <br>HANDLE hSession, hDrive; <br>DWORD dwRetCode, labelBytesWritten = LABEL_BUFFER_SIZE; <br>NTMS_GUID gMediaID, gDriveID; <br>NTMS_OBJECTINFORMATION oiDriveInfo; <br> <br>// Start an NTMS session <br>hSession = OpenNtmsSession ("", "DemoApp", 0); <br>if(hSession == INVALID_HANDLE_VALUE) <br>dwRetCode = GetLastError(); <br> <br> <br>// Mount the piece of media in a drive <br>gMediaID = recallMediaID(); <br>dwRetCode = MountNtmsMedia(hSession, <br>&amp;gMediaID, <br>&amp;gDriveID, <br>REQUESTING_ONE_MOUNT, <br>NTMS_MOUNT_ERROR_NOT_AVAILABLE, <br>NTMS_PRIORITY_NORMAL, <br>MOUNT_WAIT); <br> <br> <br>// Open the drive the media is in <br>oiDriveInfo.dwSize = sizeof(oiDriveInfo); <br>oiDriveInfo.dwType = NTMS_DRIVE; <br>dwRetCode = GetNtmsObjectInformation(hSession, <br>&amp;gDriveID, <br>&amp;oiDriveInfo); <br> <br>hDrive = CreateFile(oiDriveInfo.Info.Drive.szDeviceName, <br>                    GENERIC_READ | GENERIC_WRITE, <br>                    0, <br>                    NULL, <br>                    OPEN_EXISTING, <br>                    FILE_ATTRIBUTE_NORMAL, <br>                    NULL); <br> <br> <br> <br>// Read (and/or write) data via Win32 API calls, Close device when done. <br> <br>// read, read, read, ... <br>CloseHandle(hDrive); <br> <br> <br>// Dismount the media <br>dwRetCode = DismountNtmsMedia( hSession, <br>&amp;gMediaID, <br>REQUESTING_ONE_DISMOUNT, <br>0); <br> <br> <br>// We've determined that we no longer need this piece of media <br>// so deallocate it. <br>dwRetCode = DeallocateNtmsMedia( hSession, <br>&amp;gMediaID, <br>0); <br> <br> <br>// That's all for this scenario <br>CloseNtmsSession(hSession); <br>} <br> <br> <br> <br>void <br>UseCase4() <br>{ <br>HANDLE hSession; <br>DWORD dwRetCode, i; <br>NTMS_GUID gIpID, *gPartitionList = NULL, gPoolID; <br>bool bRetCode; <br>DWORD dwSize; <br>NTMS_OBJECTINFORMATION oiPartitionInfo; <br> <br> <br>// Start an NTMS session <br>hSession = OpenNtmsSession ("", "DemoApp", 0); <br>if(hSession == INVALID_HANDLE_VALUE) <br>dwRetCode = GetLastError(); <br> <br> <br>// The method used here to find media in the import pool is actually the <br>// harder of two ways to do it.  The easier way  is to enumerate all the <br>// partitions in NTMS (instead of the media-specific import pool and check <br>// for ones with the partstate set to PARTSTATE_IMPORT.  This way is more <br>// efficient and gives you a flavor for traversing nested media pools (which  <br>// is done in findImportPool). <br> <br> <br>// Get the GUID of the media-specific import pool <br>if( (bRetCode = findImportPool(hSession, gIpID, dwRetCode)) == false) <br>return; <br> <br> <br>// Enumerate all the partitions in the media-specific import pool <br>dwSize = SIZE_FOR_FIRST_TRY; <br>for(;;) <br>{ <br>if(gPartitionList != NULL) <br>free(gPartitionList); <br>gPartitionList = (LPNTMS_GUID)malloc(dwSize*sizeof(NTMS_GUID)); <br> <br>dwRetCode = EnumerateNtmsObject(hSession, <br>&amp;gIpID, <br>gPartitionList, <br>&amp;dwSize, <br>NTMS_PARTITION, <br>0); <br> <br>if(dwRetCode == ERROR_INSUFFICIENT_BUFFER) continue; <br>if(dwRetCode == ERROR_SUCCESS) break; <br>return; <br>} <br> <br> <br>gPoolID = recallPoolID(); <br> <br>// Look at the label on each piece of media &amp; move it <br>// to this app's pool if it was written by this  <br>// app. <br>oiPartitionInfo.dwSize = sizeof(oiPartitionInfo); <br>oiPartitionInfo.dwType = NTMS_PARTITION; <br>for (i=0; i &lt; dwSize; ++i) <br>{ <br>dwRetCode = GetNtmsObjectInformation( hSession, <br>&amp;(gPartitionList[i]), <br>&amp;oiPartitionInfo); <br>if((dwRetCode = strncmp(oiPartitionInfo.Info.Partition.szOmidLabelType,  <br>"Microsoft NTMS API Demo", 23)) == 0) <br>{ <br>MoveToNtmsMediaPool(hSession,  <br>&amp;(oiPartitionInfo.Info.Partition.PhysicalMedia), &amp;gPoolID); <br>} <br>} <br> <br> <br>// That's all for this scenario <br>CloseNtmsSession(hSession); <br>} <br> <br>void  <br>main() <br>{ <br> <br> <br>UseCase1();// Stuff done during app initialization <br> <br> <br>UseCase2(); // Typical stuff done during app operations <br>//including media allocation <br> <br> <br>UseCase3(); // More typical stuff done during app operations <br>//including media deallocation <br> <br> <br>UseCase4();// Find each piece of media in the import pool that <br>//belong to this app and move it to this <br>//app's media pool <br> <br> <br> <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
