<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>NTMSLABL.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6072"></a>NTMSLABL.CPP</h2>
<pre><code>/* <br> *  This is a part of the Microsoft Source Code Samples. <br> * <br> *This sample code shows the usage of some portions <br> *of the NTMS API. <br> * <br> *Return codes are, for the most part, not checked in <br> *this code. See the Programmer's reference for error <br> *return information. <br> * <br> * THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF <br> * ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO  <br> * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A <br> * PARTICULAR PURPOSE. <br> * <br> * Copyright 1997 - 1998 Microsoft Corporation.  All Rights Reserved.  <br> */ <br>#include &lt;windows.h&gt; <br>#include &lt;iostream.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;time.h&gt; <br>#include &lt;rpc.h&gt; <br>#include &lt;NtmsMli.h&gt; <br>#include "mtf_defs.h" <br>#include "ntmsapilabel.h" <br> <br>WORD XORCheckSum(WORD *, DWORD ) ; <br> <br>void writeOmid (HANDLE hDevice, BYTE *Buffer, DWORD *BufferSizePtr)  <br>{ <br>// local variables ... <br>DWORD nError = NO_ERROR ; <br>MTF_TapeDBLK *plbl ; <br>BYTE LabelBuffer[1024] ; <br>time_t CurrentTime; <br>struct tm *GMTime ; <br>wchar_t DateString[10] ; <br>wchar_t TimeString[12] ; <br>wchar_t SoftwareName[80] ; <br>wchar_t TapeName[80] ; <br>WORD nSize ; <br>WORD nTapeNameLength, nSoftwareNameLength ; <br>BOOL nRetCode ; <br>DWORD nBytesWritten ; <br>BYTE TapeDate[4] ; <br>void *pTapeName, *pSoftwareName ; <br> <br>// create and fill in the MTF media label ... <br>memset (LabelBuffer, 0, 1024) ; <br>plbl = (MTF_TapeDBLK *) LabelBuffer ; <br>strncpy ((char *)plbl-&gt;BlockHeader.BlockType, MTF_TapeDBLKLabel, MTF_TapeDBLKLabelSize) ; <br>//plbl-&gt;BlockHeader.BlockAttributes = 0x30000 ; <br>//plbl-&gt;BlockHeader.OffsetToFirstStream = 0x400 ; <br>//plbl-&gt;BlockHeader.OSID = 0xe ; <br>plbl-&gt;BlockHeader.StringType = UNICODE_STR ; <br>plbl-&gt;BlockHeader.HeaderCheckSum =  <br>XORCheckSum((WORD *)&amp;plbl-&gt;BlockHeader,  <br>sizeof(plbl-&gt;BlockHeader) - sizeof(plbl-&gt;BlockHeader.HeaderCheckSum)) ; <br>//plbl-&gt;TapeSequenceNumber = 1 ; <br>//plbl-&gt;TapeCatalogType = 1 ;// MTF_OTC_TYPE <br>//plbl-&gt;AlignmentFactor = 1024 ;// 1k alignment factor ... <br>//plbl-&gt;MTFMajorVersion = 1 ;// MTF_FORMAT_VER_MAJOR <br> <br>// get the current time ... <br>time(&amp;CurrentTime); <br> <br>// create the date  and time string ... <br>GMTime = gmtime(&amp;CurrentTime) ; <br>wcsftime (DateString, 10, L"%m/%d/%y", GMTime) ; <br>wcsftime (TimeString, 12, L"%I:%M:%S %p", GMTime) ; <br> <br>// fill in the Tape Name and the Software Name fields ... <br>    swprintf(SoftwareName, L"%s (APIDEMO.EXE) Version 1.0 Rev 5", <br>                 MTF_MediaLabelType_NT_ApiDemo); <br>swprintf(TapeName, L"Tape created on %s", DateString); <br> <br>// copy the TapeName and the SoftwareName into the Media Label that we are creating ... <br>nSize = sizeof (MTF_TapeDBLK) ; <br>nTapeNameLength = wcslen (TapeName) ; <br>plbl-&gt;TapeName.Size = nTapeNameLength * 2 ;// strings are Unicode (i.e. 2 byte chars) <br>plbl-&gt;TapeName.Offset = nSize ;// size of the MTF_TapeDBLK ... <br>pTapeName = (void *) ((DWORD) plbl + (DWORD) plbl-&gt;TapeName.Offset) ; <br>wcsncpy ((wchar_t *) pTapeName, TapeName, nTapeNameLength) ; <br> <br>// setup the SoftwareName ... copy the SoftwareName into the label ... <br>nSoftwareNameLength = wcslen(SoftwareName) ;plbl-&gt;SoftwareName.Size = nSoftwareNameLength * 2 ;   // strings are Unicode (i.e. 2 byte chars) <br>plbl-&gt;SoftwareName.Offset = nSize + plbl-&gt;TapeName.Size ;  <br>pSoftwareName = (void *) ((DWORD) plbl + (DWORD) plbl-&gt;SoftwareName.Offset) ; <br>wcsncpy ((wchar_t *) pSoftwareName, SoftwareName, nSoftwareNameLength) ; <br> <br>// fill in the TapeDate and MediaID fields ... <br>TapeDate[0] = plbl-&gt;TapeDate.Time[1] ; <br>TapeDate[1] = plbl-&gt;TapeDate.Time[2] ; <br>TapeDate[2] = plbl-&gt;TapeDate.Time[3] ; <br>TapeDate[3] = plbl-&gt;TapeDate.Time[4] ; <br>memcpy ((void *)&amp;(plbl-&gt;TapeFamilyID), (void *) TapeDate, 4) ; <br> <br>// set the tape label bit <br>plbl-&gt;TapeAttributes = TAPE_MEDIA_LABEL_BIT; <br> <br>// write the data out to the media ... <br>nRetCode = WriteFile (hDevice, (void *) plbl, 1024,  <br>&amp;nBytesWritten, NULL) ; <br>if (nRetCode == FALSE) <br>{ <br>nError = GetLastError() ; <br>} <br>    else <br>    { <br>        if (BufferSizePtr != NULL) <br>        { <br>            if (NULL != Buffer) <br>            { <br>                if (*BufferSizePtr &gt;= nBytesWritten) <br>                { <br>                    *BufferSizePtr = nBytesWritten; <br>                    memcpy(Buffer, (void *)plbl, *BufferSizePtr); <br>                } <br>            } <br>            else <br>            { <br>                *BufferSizePtr = 0; <br>            } <br>        } <br>    } <br> <br>    // return  <br>return; <br>} <br> <br>// Routine to compute the WORD X-OR CheckSum of the bytes for the number of bytes <br>//   specified. <br>WORD XORCheckSum(WORD *pBuffer, DWORD nBytes) <br>{ <br>    WORD RetVal = 0; <br>    for (DWORD i = 0; i &lt; nBytes / sizeof(WORD); i++) <br>    { <br>        RetVal ^= pBuffer[i]; <br>    } <br> <br>    return RetVal; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
