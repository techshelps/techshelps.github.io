<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SIMPLE.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6306"></a>SIMPLE.C</h2>
<pre><code>// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF <br>// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO <br>// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A <br>// PARTICULAR PURPOSE. <br>// <br>// Copyright 1993 - 1998 Microsoft Corporation.  All Rights Reserved. <br>// <br>//  MODULE:   simple.c <br>// <br>//  PURPOSE:  Implements the body of the service. <br>//            The default behavior is to open a <br>//            named pipe, \\.\pipe\simple, and read <br>//            from it.  It the modifies the data and <br>//            writes it back to the pipe. <br>// <br>//  FUNCTIONS: <br>//            ServiceStart(DWORD dwArgc, LPTSTR *lpszArgv); <br>//            ServiceStop( ); <br>// <br>//  COMMENTS: The functions implemented in simple.c are <br>//            prototyped in service.h <br>//               <br>// <br>//  AUTHOR: Craig Link - Microsoft Developer Support <br>// <br> <br> <br>#include &lt;windows.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;process.h&gt; <br>#include &lt;tchar.h&gt; <br>#include "service.h" <br> <br>// this event is signalled when the <br>// service should end <br>// <br>HANDLE  hServerStopEvent = NULL; <br> <br> <br>// <br>//  FUNCTION: ServiceStart <br>// <br>//  PURPOSE: Actual code of the service <br>//           that does the work. <br>// <br>//  PARAMETERS: <br>//    dwArgc   - number of command line arguments <br>//    lpszArgv - array of command line arguments <br>// <br>//  RETURN VALUE: <br>//    none <br>// <br>//  COMMENTS: <br>//    The default behavior is to open a <br>//    named pipe, \\.\pipe\simple, and read <br>//    from it.  It the modifies the data and <br>//    writes it back to the pipe.  The service <br>//    stops when hServerStopEvent is signalled <br>// <br>VOID ServiceStart (DWORD dwArgc, LPTSTR *lpszArgv) <br>{ <br>    HANDLE                  hPipe = INVALID_HANDLE_VALUE; <br>    HANDLE                  hEvents[2] = {NULL, NULL}; <br>    OVERLAPPED              os; <br>    PSECURITY_DESCRIPTOR    pSD = NULL; <br>    SECURITY_ATTRIBUTES     sa; <br>    TCHAR                   szIn[80]; <br>    TCHAR                   szOut[80]; <br>    LPTSTR                  lpszPipeName = TEXT("\\\\.\\pipe\\simple"); <br>    BOOL                    bRet; <br>    DWORD                   cbRead; <br>    DWORD                   cbWritten; <br>    DWORD                   dwWait; <br>    UINT                    ndx; <br> <br>    /////////////////////////////////////////////////// <br>    // <br>    // Service initialization <br>    // <br> <br>    // report the status to the service control manager. <br>    // <br>    if (!ReportStatusToSCMgr( <br>        SERVICE_START_PENDING, // service state <br>        NO_ERROR,              // exit code <br>        3000))                 // wait hint <br>        goto cleanup; <br> <br>    // create the event object. The control handler function signals <br>    // this event when it receives the "stop" control code. <br>    // <br>    hServerStopEvent = CreateEvent( <br>        NULL,    // no security attributes <br>        TRUE,    // manual reset event <br>        FALSE,   // not-signalled <br>        NULL);   // no name <br> <br>    if ( hServerStopEvent == NULL) <br>        goto cleanup; <br> <br>    hEvents[0] = hServerStopEvent; <br> <br>    // report the status to the service control manager. <br>    // <br>    if (!ReportStatusToSCMgr( <br>        SERVICE_START_PENDING, // service state <br>        NO_ERROR,              // exit code <br>        3000))                 // wait hint <br>        goto cleanup; <br> <br>    // create the event object object use in overlapped i/o <br>    // <br>    hEvents[1] = CreateEvent( <br>        NULL,    // no security attributes <br>        TRUE,    // manual reset event <br>        FALSE,   // not-signalled <br>        NULL);   // no name <br> <br>    if ( hEvents[1] == NULL) <br>        goto cleanup; <br> <br>    // report the status to the service control manager. <br>    // <br>    if (!ReportStatusToSCMgr( <br>        SERVICE_START_PENDING, // service state <br>        NO_ERROR,              // exit code <br>        3000))                 // wait hint <br>        goto cleanup; <br> <br>    // create a security descriptor that allows anyone to write to <br>    //  the pipe... <br>    // <br>    pSD = (PSECURITY_DESCRIPTOR) malloc( SECURITY_DESCRIPTOR_MIN_LENGTH ); <br> <br>    if (pSD == NULL) <br>        goto cleanup; <br> <br>    if (!InitializeSecurityDescriptor(pSD, SECURITY_DESCRIPTOR_REVISION)) <br>        goto cleanup; <br> <br>    // add a NULL disc. ACL to the security descriptor. <br>    // <br>    if (!SetSecurityDescriptorDacl(pSD, TRUE, (PACL) NULL, FALSE)) <br>        goto cleanup; <br> <br>    sa.nLength = sizeof(sa); <br>    sa.lpSecurityDescriptor = pSD; <br>    sa.bInheritHandle = TRUE; <br> <br> <br>    // report the status to the service control manager. <br>    // <br>    if (!ReportStatusToSCMgr( <br>        SERVICE_START_PENDING, // service state <br>        NO_ERROR,              // exit code <br>        3000))                 // wait hint <br>        goto cleanup; <br> <br> <br>    // allow user tp define pipe name <br>    for ( ndx = 1; ndx &lt; dwArgc-1; ndx++ ) <br>    { <br> <br>        if ( ( (*(lpszArgv[ndx]) == TEXT('-')) || <br>               (*(lpszArgv[ndx]) == TEXT('/')) ) &amp;&amp; <br>             _tcsicmp( TEXT("pipe"), lpszArgv[ndx]+1 ) == 0 ) <br>        { <br>            lpszPipeName = lpszArgv[++ndx]; <br>        } <br> <br>    } <br> <br>    // open our named pipe... <br>    // <br>    hPipe = CreateNamedPipe( <br>                    lpszPipeName         ,  // name of pipe <br>                    FILE_FLAG_OVERLAPPED | <br>                    PIPE_ACCESS_DUPLEX,     // pipe open mode <br>                    PIPE_TYPE_MESSAGE | <br>                    PIPE_READMODE_MESSAGE | <br>                    PIPE_WAIT,              // pipe IO type <br>                    1,                      // number of instances <br>                    0,                      // size of outbuf (0 == allocate as necessary) <br>                    0,                      // size of inbuf <br>                    1000,                   // default time-out value <br>                    &amp;sa);                   // security attributes <br> <br>    if (hPipe == INVALID_HANDLE_VALUE) { <br>        AddToMessageLog(TEXT("Unable to create named pipe")); <br>        goto cleanup; <br>    } <br> <br> <br>    // report the status to the service control manager. <br>    // <br>    if (!ReportStatusToSCMgr( <br>        SERVICE_RUNNING,       // service state <br>        NO_ERROR,              // exit code <br>        0))                    // wait hint <br>        goto cleanup; <br> <br>    // <br>    // End of initialization <br>    // <br>    //////////////////////////////////////////////////////// <br> <br>    //////////////////////////////////////////////////////// <br>    // <br>    // Service is now running, perform work until shutdown <br>    // <br> <br>    while ( 1 ) <br>    { <br>        // init the overlapped structure <br>        // <br>        memset( &amp;os, 0, sizeof(OVERLAPPED) ); <br>        os.hEvent = hEvents[1]; <br>        ResetEvent( hEvents[1] ); <br> <br>        // wait for a connection... <br>        // <br>        ConnectNamedPipe(hPipe, &amp;os); <br> <br>        if ( GetLastError() == ERROR_IO_PENDING ) <br>        { <br>            dwWait = WaitForMultipleObjects( 2, hEvents, FALSE, INFINITE ); <br>            if ( dwWait != WAIT_OBJECT_0+1 )     // not overlapped i/o event - error occurred, <br>                break;                           // or server stop signaled <br>        } <br> <br>        // init the overlapped structure <br>        // <br>        memset( &amp;os, 0, sizeof(OVERLAPPED) ); <br>        os.hEvent = hEvents[1]; <br>        ResetEvent( hEvents[1] ); <br> <br>        // grab whatever's coming through the pipe... <br>        // <br>        bRet = ReadFile( <br>                    hPipe,          // file to read from <br>                    szIn,           // address of input buffer <br>                    sizeof(szIn),   // number of bytes to read <br>                    &amp;cbRead,        // number of bytes read <br>                    &amp;os);           // overlapped stuff, not needed <br> <br>        if ( !bRet &amp;&amp; ( GetLastError() == ERROR_IO_PENDING ) ) <br>        { <br>            dwWait = WaitForMultipleObjects( 2, hEvents, FALSE, INFINITE ); <br>            if ( dwWait != WAIT_OBJECT_0+1 )     // not overlapped i/o event - error occurred, <br>                break;                           // or server stop signaled <br>        } <br> <br>        // munge the string <br>        // <br>        _stprintf(szOut, TEXT("Hello! [%s]"), szIn); <br> <br>        // init the overlapped structure <br>        // <br>        memset( &amp;os, 0, sizeof(OVERLAPPED) ); <br>        os.hEvent = hEvents[1]; <br>        ResetEvent( hEvents[1] ); <br> <br>        // send it back out... <br>        // <br>        bRet = WriteFile( <br>                    hPipe,          // file to write to <br>                    szOut,          // address of output buffer <br>                    sizeof(szOut),  // number of bytes to write <br>                    &amp;cbWritten,     // number of bytes written <br>                    &amp;os);           // overlapped stuff, not needed <br> <br>        if ( !bRet &amp;&amp; ( GetLastError() == ERROR_IO_PENDING ) ) <br>        { <br>            dwWait = WaitForMultipleObjects( 2, hEvents, FALSE, INFINITE ); <br>            if ( dwWait != WAIT_OBJECT_0+1 )     // not overlapped i/o event - error occurred, <br>                break;                           // or server stop signaled <br>        } <br> <br>        // drop the connection... <br>        // <br>        DisconnectNamedPipe(hPipe); <br>    } <br> <br>  cleanup: <br> <br>    if (hPipe != INVALID_HANDLE_VALUE ) <br>        CloseHandle(hPipe); <br> <br>    if (hServerStopEvent) <br>        CloseHandle(hServerStopEvent); <br> <br>    if (hEvents[1]) // overlapped i/o event <br>        CloseHandle(hEvents[1]); <br> <br>    if ( pSD ) <br>        free( pSD ); <br> <br>} <br> <br> <br>// <br>//  FUNCTION: ServiceStop <br>// <br>//  PURPOSE: Stops the service <br>// <br>//  PARAMETERS: <br>//    none <br>// <br>//  RETURN VALUE: <br>//    none <br>// <br>//  COMMENTS: <br>//    If a ServiceStop procedure is going to <br>//    take longer than 3 seconds to execute, <br>//    it should spawn a thread to execute the <br>//    stop code, and return.  Otherwise, the <br>//    ServiceControlManager will believe that <br>//    the service has stopped responding. <br>//     <br>VOID ServiceStop() <br>{ <br>    if ( hServerStopEvent ) <br>        SetEvent(hServerStopEvent); <br>} <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
