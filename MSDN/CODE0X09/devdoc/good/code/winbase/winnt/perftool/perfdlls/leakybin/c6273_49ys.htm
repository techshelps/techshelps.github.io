<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>LEAKYBIN.C</title>
<link disabled rel=stylesheet href=../../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6274"></a>LEAKYBIN.C</h2>
<pre><code>//THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF <br>//ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO <br>//THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A <br>// PARTICULAR PURPOSE. <br>// <br>// Copyright 1996 - 1997 Microsoft Corporation.  All Rights Reserved. <br>// <br>// PROGRAM: Leakybin.c <br>// <br>// PURPOSE: Illustrates the use of Windows NT application performance <br>//              counters to measure GlobalAlloc usage <br>// <br>// PLATFORMS:  Windows NT only <br>// <br>// FUNCTIONS: <br>//    WinMain() - calls initialization function, processes message loop <br>//    InitApplication() - Initializes window data nd registers window <br>//    InitInstance() -saves instance handle and creates main window <br>//    WindProc() Processes messages <br>//    About() - Process menssages for "About" dialog box <br>//    MyRegisterClass() - Registers the application's window class <br>//    CenterWindow() -  Centers one window over another <br>// <br>// SPECIAL INSTRUCTIONS: N/A <br>// <br>#define APPNAME "Leakybin" <br> <br>// Windows Header Files: <br>#include &lt;windows.h&gt; <br> <br>// C RunTime Header Files <br>#include &lt;stdlib.h&gt; <br>#include &lt;malloc.h&gt; <br>#include &lt;memory.h&gt; <br>#include &lt;stdio.h&gt; <br> <br>// Local Header Files <br>#include "leakybin.h" <br> <br>// Makes it easier to determine appropriate code paths: <br>#define IS_WIN32    TRUE <br>#define IS_NT       IS_WIN32 &amp;&amp; (BOOL)(GetVersion() &lt; 0x80000000) <br> <br>// Global Variables: <br> <br>HINSTANCE hInst;      // current instance <br>char szAppName[100];  // Name of the app <br>char szTitle[100];    // The title bar text <br> <br>static int      TimerID = 0; <br>static BOOL     TimerRunning = FALSE; <br>static HMENU    hAppMenu, hTestMenu; <br>static MEMORY_ALLOC_BLOCK   mabListHead = {NULL}; <br> <br>// Foward declarations of functions included in this code module: <br> <br>ATOM MyRegisterClass(CONST WNDCLASS*); <br>BOOL InitApplication(HINSTANCE); <br>BOOL InitInstance(HINSTANCE, int); <br>LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM); <br>LRESULT CALLBACK About(HWND, UINT, WPARAM, LPARAM); <br>BOOL CenterWindow (HWND, HWND); <br>LPTSTR   GetStringRes (int id); <br> <br> <br>// <br>//  FUNCTION: WinMain(HANDLE, HANDLE, LPSTR, int) <br>// <br>//  PURPOSE: Entry point for the application. <br>// <br>//  COMMENTS: <br>// <br>// This function initializes the application and processes the <br>// message loop. <br>// <br>int APIENTRY WinMain(HINSTANCE hInstance, <br>                     HINSTANCE hPrevInstance, <br>                     LPSTR     lpCmdLine, <br>                     int       nCmdShow) <br>{ <br>   MSG msg; <br>   HANDLE hAccelTable; <br> <br>   // Initialize global strings <br>   lstrcpy (szAppName, APPNAME); <br>   LoadString (hInstance, IDS_APP_TITLE, szTitle, 100); <br> <br> <br>   if (!hPrevInstance) { <br>      // Perform instance initialization: <br>      if (!InitApplication(hInstance)) { <br>         return (FALSE); <br>      } <br>   } <br> <br>   // Perform application initialization: <br>   if (!InitInstance(hInstance, nCmdShow)) { <br>      return (FALSE); <br>   } <br> <br>   hAccelTable = LoadAccelerators (hInstance, szAppName); <br> <br>   // Main message loop: <br>   while (GetMessage(&amp;msg, NULL, 0, 0)) { <br>      if (!TranslateAccelerator (msg.hwnd, hAccelTable, &amp;msg)) { <br>         TranslateMessage(&amp;msg); <br>         DispatchMessage(&amp;msg); <br>      } <br>   } <br> <br>   return (msg.wParam); <br> <br>   lpCmdLine; // This will prevent 'unused formal parameter' warnings <br>} <br> <br>// <br>//  FUNCTION: MyRegisterClass(CONST WNDCLASS*) <br>// <br>//  PURPOSE: Registers the window class. <br>// <br>//  COMMENTS: <br>// <br>//    This function and its usage is only necessary if you want this code <br>//    to be compatible with Win32 systems prior to the 'RegisterClassEx' <br>// function that was added to Windows 95. It is important to call this function <br>//    so that the application will get 'well formed' small icons associated <br>//    with it. <br>// <br>ATOM MyRegisterClass(CONST WNDCLASS *lpwc) <br>{ <br>   HANDLE  hMod; <br>   FARPROC proc; <br>   WNDCLASSEX wcex; <br> <br>   hMod = GetModuleHandle ("USER32"); <br>   if (hMod != NULL) { <br> <br>#if defined (UNICODE) <br>      proc = GetProcAddress (hMod, "RegisterClassExW"); <br>#else <br>      proc = GetProcAddress (hMod, "RegisterClassExA"); <br>#endif <br> <br>      if (proc != NULL) { <br> <br>         wcex.style         = lpwc-&gt;style; <br>         wcex.lpfnWndProc   = lpwc-&gt;lpfnWndProc; <br>         wcex.cbClsExtra    = lpwc-&gt;cbClsExtra; <br>         wcex.cbWndExtra    = lpwc-&gt;cbWndExtra; <br>         wcex.hInstance     = lpwc-&gt;hInstance; <br>         wcex.hIcon         = lpwc-&gt;hIcon; <br>         wcex.hCursor       = lpwc-&gt;hCursor; <br>         wcex.hbrBackground = lpwc-&gt;hbrBackground; <br>                     wcex.lpszMenuName  = lpwc-&gt;lpszMenuName; <br>         wcex.lpszClassName = lpwc-&gt;lpszClassName; <br> <br>         // Added elements for Windows 95: <br>         wcex.cbSize = sizeof(WNDCLASSEX); <br>         wcex.hIconSm = LoadIcon(wcex.hInstance, "SMALL"); <br> <br>         return (*proc)(&amp;wcex);//return RegisterClassEx(&amp;wcex); <br>      } <br>   } <br>   return (RegisterClass(lpwc)); <br>} <br> <br> <br>// <br>//  FUNCTION: InitApplication(HANDLE) <br>// <br>//  PURPOSE: Initializes window data and registers window class <br>// <br>//  COMMENTS: <br>// <br>//       In this function, we initialize a window class by filling out a data <br>//       structure of type WNDCLASS and calling either RegisterClass or <br>//       the internal MyRegisterClass. <br>// <br>BOOL InitApplication(HINSTANCE hInstance) <br>{ <br>    WNDCLASS  wc; <br> <br>    // Fill in window class structure with parameters that describe <br>    // the main window. <br>    wc.style         = CS_HREDRAW | CS_VREDRAW; <br>    wc.lpfnWndProc   = (WNDPROC)WndProc; <br>    wc.cbClsExtra    = 0; <br>    wc.cbWndExtra    = 0; <br>    wc.hInstance     = hInstance; <br>    wc.hIcon         = LoadIcon (hInstance, szAppName); <br>    wc.hCursor       = LoadCursor(NULL, IDC_ARROW); <br>    wc.hbrBackground = (HBRUSH)(COLOR_WINDOW+1); <br>    wc.lpszMenuName  = szAppName; <br>    wc.lpszClassName = szAppName; <br> <br>    // Register the window class and return success/failure code. <br>    return RegisterClass(&amp;wc); <br>} <br> <br>// <br>//   FUNCTION: InitInstance(HANDLE, int) <br>// <br>//   PURPOSE: Saves instance handle and creates main window <br>// <br>//   COMMENTS: <br>// <br>//        In this function, we save the instance handle in a global variable and <br>//        create and display the main program window. <br>// <br>BOOL InitInstance(HINSTANCE hInstance, int nCmdShow) <br>{ <br>   HWND hWnd; <br> <br>   hInst = hInstance; // Store instance handle in our global variable <br> <br>   hWnd = CreateWindow(szAppName, szTitle, WS_OVERLAPPEDWINDOW, <br>      CW_USEDEFAULT, 0, CW_USEDEFAULT, 0, <br>      NULL, NULL, hInstance, NULL); <br> <br>   if (!hWnd) { <br>      return (FALSE); <br>   } <br> <br>   ShowWindow(hWnd, nCmdShow); <br>   UpdateWindow(hWnd); <br> <br>   return (TRUE); <br>} <br>void FreeAllocatedMemory() <br>{ <br>    { <br>    PMEMORY_ALLOC_BLOCKpNextMab, pMab; <br> <br>    pMab = mabListHead.pNext; <br> <br>    while (pMab != NULL) { <br>    pNextMab = pMab-&gt;pNext; <br>    G_FREE (pMab); <br>    pMab = pNextMab; <br>    } <br> <br>    mabListHead.pNext = NULL; <br>    } <br>} <br>// <br>//  FUNCTION: WndProc(HWND, unsigned, WORD, LONG) <br>// <br>//  PURPOSE:  Processes messages for the main window. <br>// <br>//  MESSAGES: <br>// <br>// WM_COMMAND - process the application menu <br>// WM_PAINT - Paint the main window <br>// WM_DESTROY - post a quit message and return <br>//    WM_DISPLAYCHANGE - message sent to Plug &amp; Play systems when the display changes <br>//    WM_RBUTTONDOWN - Right mouse click -- put up context menu here if appropriate <br>//    WM_NCRBUTTONUP - User has clicked the right button on the application's system menu <br>// <br>// <br>LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam) <br>{ <br>   int wmId, wmEvent; <br>   PAINTSTRUCT ps; <br>   HDC hdc; <br>      POINT pnt; <br>   HMENU hMenu; <br>      BOOL bGotHelp; <br> <br>   switch (message) { <br>      case WM_CREATE: <br>        // clear timer flags  <br>        TimerID = 0; <br>        TimerRunning = FALSE; <br> <br>        // enable "Start" menu selection <br>        hAppMenu = GetMenu (hWnd); <br>        hTestMenu  = GetSubMenu (hAppMenu, 1); <br>        EnableMenuItem (hTestMenu, IDM_STOP, MF_BYCOMMAND | MF_GRAYED); <br>        EnableMenuItem (hTestMenu, IDM_START, MF_BYCOMMAND | MF_ENABLED); <br>        break; <br> <br>      case WM_COMMAND: <br>         wmId    = LOWORD(wParam); // Remember, these are... <br>         wmEvent = HIWORD(wParam); // ...different for Win32! <br> <br>         //Parse the menu selections: <br>         switch (wmId) { <br> <br>            case IDM_EXIT: <br>               DestroyWindow (hWnd); <br>               break; <br> <br>            case IDM_START: <br>                if (!TimerRunning) { <br>                    TimerID = SetTimer (hWnd, LEAK_TIMER, TIME_INTERVAL, NULL); <br>                    if (TimerID != 0) { <br>                        TimerRunning = TRUE; <br>                        EnableMenuItem (hTestMenu, IDM_START, <br>                            MF_BYCOMMAND | MF_GRAYED); <br>                        EnableMenuItem (hTestMenu, IDM_STOP, <br>                            MF_BYCOMMAND | MF_ENABLED); <br>                    } else { <br>                        //unable to start timer <br>                        MessageBeep (MB_ICONEXCLAMATION); <br>                    } <br>                } <br>                InvalidateRect (hWnd, NULL, TRUE); <br>                break; <br> <br>            case IDM_STOP: <br>                if (TimerRunning) { <br>                    KillTimer (hWnd, LEAK_TIMER); <br>                    TimerID = 0; <br>                    TimerRunning = FALSE; <br>                    EnableMenuItem (hTestMenu, IDM_STOP, <br>                        MF_BYCOMMAND | MF_GRAYED); <br>                    EnableMenuItem (hTestMenu, IDM_START, <br>                        MF_BYCOMMAND | MF_ENABLED); <br>                } <br>                InvalidateRect (hWnd, NULL, TRUE); <br>                break; <br> <br>            case IDM_RESET: <br>                FreeAllocatedMemory(); <br>                InvalidateRect (hWnd, NULL, TRUE); <br>                break; <br> <br>            case IDM_ABOUT: <br>               DialogBox(hInst, "AboutBox", hWnd, (DLGPROC)About); <br>               break; <br> <br>            case IDM_HELPTOPICS: // Only called in Windows 95 <br>               bGotHelp = WinHelp (hWnd, APPNAME".HLP", HELP_FINDER,(DWORD)0); <br>               if (!bGotHelp) <br>               { <br>                  MessageBox (GetFocus(), GetStringRes(IDS_NO_HELP), <br>                              szAppName, MB_OK|MB_ICONHAND); <br>               } <br>               break; <br> <br>            default: <br>               return (DefWindowProc(hWnd, message, wParam, lParam)); <br>         } <br>         break; <br> <br>      case WM_TIMER: <br>        { <br>        PMEMORY_ALLOC_BLOCKpMab, pNewMab; <br> <br>        pNewMab = (PMEMORY_ALLOC_BLOCK)G_ALLOC (GPTR, ALLOCATION_SIZE); <br> <br>        if (pNewMab != NULL) { <br>        // save this pointer  <br>        pNewMab-&gt;pNext = NULL; <br>        if (mabListHead.pNext == NULL) { <br>        // this is the first entry <br>        mabListHead.pNext = pNewMab; <br>        } else { <br>        // go to end of list <br>        pMab = mabListHead.pNext; <br>        while (pMab-&gt;pNext != NULL) pMab = pMab-&gt;pNext; <br>        pMab-&gt;pNext = pNewMab; <br>        } <br>                InvalidateRect (hWnd, NULL, TRUE); <br>        } <br>        } <br>        break; <br> <br>      case WM_RBUTTONDOWN: // RightClick in windows client area... <br>            pnt.x = LOWORD(lParam); <br>            pnt.y = HIWORD(lParam); <br>            ClientToScreen(hWnd, (LPPOINT) &amp;pnt); <br>      // This is where you would determine the appropriate 'context' <br>      // menu to bring up. Since this app has no real functionality, <br>      // we will just bring up the 'Help' menu: <br>            hMenu = GetSubMenu (GetMenu (hWnd), 2); <br>            if (hMenu) { <br>                TrackPopupMenu (hMenu, 0, pnt.x, pnt.y, 0, hWnd, NULL); <br>            } else { <br>            // Couldn't find the menu... <br>                MessageBeep(0); <br>            } <br>            break; <br> <br> <br>      case WM_DISPLAYCHANGE: // Only comes through on plug'n'play systems <br>      { <br>         SIZE  szScreen; <br>         DWORD dwBitsPerPixel = (DWORD)wParam; <br> <br>         szScreen.cx = LOWORD(lParam); <br>         szScreen.cy = HIWORD(lParam); <br> <br>         MessageBox (GetFocus(), GetStringRes(IDS_DISPLAYCHANGED), <br>                     szAppName, 0); <br>      } <br>      break; <br> <br>      case WM_PAINT: <br>        { <br>        MEMORYSTATUSMemoryStatusData; <br>            LONGLONGllInUse; <br>        DWORDdwPercentUsed; <br> <br>            int     nX, nY; <br>            LONG    lTextOutReturn; <br>            int     nStringLength; <br>            CHAR            szOutputString[100]; <br> <br>            hdc = BeginPaint (hWnd, &amp;ps); <br>            // Add any drawing code here... <br>        GlobalMemoryStatus (&amp;MemoryStatusData); <br> <br>        llInUse = (LONGLONG)(MemoryStatusData.dwTotalPageFile - <br>                MemoryStatusData.dwAvailPageFile + 5 ); <br>        llInUse *= 1000; <br>        llInUse /= MemoryStatusData.dwTotalPageFile; <br>        llInUse /= 10; <br> <br>        dwPercentUsed = (DWORD)llInUse; <br> <br>            nX = 0; <br>            nY = 0; <br>            sprintf (szOutputString, "Reported Memory Load: \t%3.1d%%", <br>                MemoryStatusData.dwMemoryLoad); <br>            nStringLength = lstrlen (szOutputString) * sizeof (CHAR); <br>            lTextOutReturn = TabbedTextOut (hdc, nX, nY, <br>                szOutputString, nStringLength, 0, NULL, 0); <br>            nY += HIWORD (lTextOutReturn); <br> <br>            sprintf (szOutputString, "Page file in use:  \t%3.1d%%", <br>                dwPercentUsed); <br>            nStringLength = lstrlen (szOutputString) * sizeof (CHAR); <br>            lTextOutReturn = TabbedTextOut (hdc, nX, nY, <br>                szOutputString, nStringLength, 0, NULL, 0); <br>            nY += HIWORD (lTextOutReturn); <br> <br>            EndPaint (hWnd, &amp;ps); <br>        } <br>        break; <br> <br>      case WM_DESTROY: <br>         FreeAllocatedMemory(); <br>         // Tell WinHelp we don't need it any more... <br>               WinHelp (hWnd, APPNAME".HLP", HELP_QUIT,(DWORD)0); <br>         PostQuitMessage(0); <br>         break; <br> <br>      default: <br>         return (DefWindowProc(hWnd, message, wParam, lParam)); <br>   } <br>   return (0); <br>} <br> <br>// <br>//  FUNCTION: About(HWND, unsigned, WORD, LONG) <br>// <br>//  PURPOSE:  Processes messages for "About" dialog box <br>//       This version allows greater flexibility over the contents of the 'About' box, <br>//       by pulling out values from the 'Version' resource. <br>// <br>//  MESSAGES: <br>// <br>// WM_INITDIALOG - initialize dialog box <br>// WM_COMMAND    - Input received <br>// <br>// <br>LRESULT CALLBACK About(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam) <br>{ <br>   static  HFONT hfontDlg;    // Font for dialog text <br>   static   HFONT hFinePrint; // Font for 'fine print' in dialog <br>   DWORD   dwVerInfoSize;     // Size of version information block <br>   LPSTR   lpVersion;         // String pointer to 'version' text <br>   DWORD   dwVerHnd=0;        // An 'ignored' parameter, always '0' <br>   UINT    uVersionLen; <br>   WORD    wRootLen; <br>   BOOL    bRetCode; <br>   int     i; <br>   char    szFullPath[256]; <br>   char    szResult[256]; <br>   char    szGetName[256]; <br>   DWORD dwVersion; <br>   char  szVersion[40]; <br>   DWORD dwResult; <br> <br>   switch (message) { <br>        case WM_INITDIALOG: <br>         ShowWindow (hDlg, SW_HIDE); <br> <br>         if (PRIMARYLANGID(GetUserDefaultLangID()) == LANG_JAPANESE) <br>         { <br>            hfontDlg = CreateFont(14, 0, 0, 0, 0, 0, 0, 0, SHIFTJIS_CHARSET, 0, 0, 0, <br>                                  VARIABLE_PITCH | FF_DONTCARE, ""); <br>            hFinePrint = CreateFont(11, 0, 0, 0, 0, 0, 0, 0, SHIFTJIS_CHARSET, 0, 0, 0, <br>                                    VARIABLE_PITCH | FF_DONTCARE, ""); <br>         } <br>         else <br>         { <br>            hfontDlg = CreateFont(14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, <br>                                  VARIABLE_PITCH | FF_SWISS, ""); <br>            hFinePrint = CreateFont(11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, <br>                                    VARIABLE_PITCH | FF_SWISS, ""); <br>         } <br> <br>         CenterWindow (hDlg, GetWindow (hDlg, GW_OWNER)); <br>         GetModuleFileName (hInst, szFullPath, sizeof(szFullPath)); <br> <br>         // Now lets dive in and pull out the version information: <br>         dwVerInfoSize = GetFileVersionInfoSize(szFullPath, &amp;dwVerHnd); <br>         if (dwVerInfoSize) { <br>            LPSTR   lpstrVffInfo; <br>            HANDLE  hMem; <br>            hMem = GlobalAlloc(GMEM_MOVEABLE, dwVerInfoSize); <br>            lpstrVffInfo  = GlobalLock(hMem); <br>            GetFileVersionInfo(szFullPath, dwVerHnd, dwVerInfoSize, lpstrVffInfo); <br>            // The below 'hex' value looks a little confusing, but <br>            // essentially what it is, is the hexidecimal representation <br>            // of a couple different values that represent the language <br>            // and character set that we are wanting string values for. <br>            // 040904E4 is a very common one, because it means: <br>            //   US English, Windows MultiLingual characterset <br>            // Or to pull it all apart: <br>            // 04------        = SUBLANG_ENGLISH_USA <br>            // --09----        = LANG_ENGLISH <br>            // --11----        = LANG_JAPANESE <br>            // ----04E4 = 1252 = Codepage for Windows:Multilingual <br> <br>            lstrcpy(szGetName, GetStringRes(IDS_VER_INFO_LANG)); <br> <br>            wRootLen = lstrlen(szGetName); // Save this position <br> <br>            // Set the title of the dialog: <br>            lstrcat (szGetName, "ProductName"); <br>            bRetCode = VerQueryValue((LPVOID)lpstrVffInfo, <br>               (LPSTR)szGetName, <br>               (LPVOID)&amp;lpVersion, <br>               (UINT *)&amp;uVersionLen); <br> <br>            // Notice order of version and string... <br>            if (PRIMARYLANGID(GetUserDefaultLangID()) == LANG_JAPANESE) <br>            { <br>               lstrcpy(szResult, lpVersion); <br>               lstrcat(szResult, "    o [ W        "); <br>            } <br>            else <br>            { <br>               lstrcpy(szResult, "About "); <br>               lstrcat(szResult, lpVersion); <br>            } <br> <br>            // ----------------------------------------------------- <br> <br>            SetWindowText (hDlg, szResult); <br> <br>            // Walk through the dialog items that we want to replace: <br>            for (i = DLG_VERFIRST; i &lt;= DLG_VERLAST; i++) { <br>               GetDlgItemText(hDlg, i, szResult, sizeof(szResult)); <br>               szGetName[wRootLen] = (char)0; <br>               lstrcat (szGetName, szResult); <br>               uVersionLen   = 0; <br>               lpVersion     = NULL; <br>               bRetCode      =  VerQueryValue((LPVOID)lpstrVffInfo, <br>                  (LPSTR)szGetName, <br>                  (LPVOID)&amp;lpVersion, <br>                  (UINT *)&amp;uVersionLen); <br> <br>               if ( bRetCode &amp;&amp; uVersionLen &amp;&amp; lpVersion) { <br>               // Replace dialog item text with version info <br>                  lstrcpy(szResult, lpVersion); <br>                  SetDlgItemText(hDlg, i, szResult); <br>               } <br>               else <br>               { <br>                  dwResult = GetLastError(); <br> <br>                  wsprintf(szResult, GetStringRes(IDS_VERSION_ERROR), dwResult); <br>                  SetDlgItemText (hDlg, i, szResult); <br>               } <br>               SendMessage (GetDlgItem (hDlg, i), WM_SETFONT, <br>                  (UINT)((i==DLG_VERLAST)?hFinePrint:hfontDlg), <br>                  TRUE); <br>            } // for (i = DLG_VERFIRST; i &lt;= DLG_VERLAST; i++) <br> <br> <br>            GlobalUnlock(hMem); <br>            GlobalFree(hMem); <br> <br>         } else { <br>            // No version information available. <br>         } // if (dwVerInfoSize) <br> <br>            SendMessage (GetDlgItem (hDlg, IDC_LABEL), WM_SETFONT, <br>            (WPARAM)hfontDlg,(LPARAM)TRUE); <br> <br>         // We are  using GetVersion rather then GetVersionEx <br>         // because earlier versions of Windows NT and Win32s <br>         // didn't include GetVersionEx: <br>         dwVersion = GetVersion(); <br> <br>         if (dwVersion &lt; 0x80000000) { <br>            // Windows NT <br>            wsprintf (szVersion, "Microsoft Windows NT %u.%u (Build: %u)", <br>               (DWORD)(LOBYTE(LOWORD(dwVersion))), <br>               (DWORD)(HIBYTE(LOWORD(dwVersion))), <br>                    (DWORD)(HIWORD(dwVersion)) ); <br>         } else if (LOBYTE(LOWORD(dwVersion))&lt;4) { <br>            // Win32s <br>                wsprintf (szVersion, "Microsoft Win32s %u.%u (Build: %u)", <br>               (DWORD)(LOBYTE(LOWORD(dwVersion))), <br>               (DWORD)(HIBYTE(LOWORD(dwVersion))), <br>                    (DWORD)(HIWORD(dwVersion) &amp; ~0x8000) ); <br>         } else { <br>            // Windows 95 <br>                wsprintf (szVersion, "Microsoft Windows 95 %u.%u", <br>                    (DWORD)(LOBYTE(LOWORD(dwVersion))), <br>                    (DWORD)(HIBYTE(LOWORD(dwVersion))) ); <br>         } <br> <br>          SetWindowText (GetDlgItem(hDlg, IDC_OSVERSION), szVersion); <br>         ShowWindow (hDlg, SW_SHOW); <br>         return (TRUE); <br> <br>      case WM_COMMAND: <br>         if (LOWORD(wParam) == IDOK || LOWORD(wParam) == IDCANCEL) { <br>            EndDialog(hDlg, TRUE); <br>            DeleteObject (hfontDlg); <br>            DeleteObject (hFinePrint); <br>            return (TRUE); <br>         } <br>         break; <br>   } <br> <br>    return FALSE; <br>} <br> <br>// <br>//   FUNCTION: CenterWindow(HWND, HWND) <br>// <br>//   PURPOSE: Centers one window over another. <br>// <br>//   COMMENTS: <br>// <br>//        In this function, we save the instance handle in a global variable and <br>//        create and display the main program window. <br>// <br>//       This functionwill center one window over another ensuring that <br>//    the placement of the window is within the 'working area', meaning <br>//    that it is both within the display limits of the screen, and not <br>//    obscured by the tray or other framing elements of the desktop. <br>BOOL CenterWindow (HWND hwndChild, HWND hwndParent) <br>{ <br>   RECT    rChild, rParent, rWorkArea; <br>   int     wChild, hChild, wParent, hParent; <br>   int     xNew, yNew; <br>   BOOL  bResult; <br> <br>   // Get the Height and Width of the child window <br>   GetWindowRect (hwndChild, &amp;rChild); <br>   wChild = rChild.right - rChild.left; <br>   hChild = rChild.bottom - rChild.top; <br> <br>   // Get the Height and Width of the parent window <br>   GetWindowRect (hwndParent, &amp;rParent); <br>   wParent = rParent.right - rParent.left; <br>   hParent = rParent.bottom - rParent.top; <br> <br>   // Get the limits of the 'workarea' <br>   bResult = SystemParametersInfo( <br>      SPI_GETWORKAREA,  // system parameter to query or set <br>      sizeof(RECT), <br>      &amp;rWorkArea, <br>      0); <br>   if (!bResult) { <br>      rWorkArea.left = rWorkArea.top = 0; <br>      rWorkArea.right = GetSystemMetrics(SM_CXSCREEN); <br>      rWorkArea.bottom = GetSystemMetrics(SM_CYSCREEN); <br>   } <br> <br>   // Calculate new X position, then adjust for workarea <br>   xNew = rParent.left + ((wParent - wChild) /2); <br>   if (xNew &lt; rWorkArea.left) { <br>      xNew = rWorkArea.left; <br>   } else if ((xNew+wChild) &gt; rWorkArea.right) { <br>      xNew = rWorkArea.right - wChild; <br>   } <br> <br>   // Calculate new Y position, then adjust for workarea <br>   yNew = rParent.top  + ((hParent - hChild) /2); <br>   if (yNew &lt; rWorkArea.top) { <br>      yNew = rWorkArea.top; <br>   } else if ((yNew+hChild) &gt; rWorkArea.bottom) { <br>      yNew = rWorkArea.bottom - hChild; <br>   } <br> <br>   // Set it, and return <br>   return SetWindowPos (hwndChild, NULL, xNew, yNew, 0, 0, SWP_NOSIZE | SWP_NOZORDER); <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>// <br>// FUNCTION:    GetStringRes (int id INPUT ONLY) <br>// <br>// COMMENTS:    Load the resource string with the ID given, and return a <br>//              pointer to it.  Notice that the buffer is common memory so <br>//              the string must be used before this call is made a second time. <br>// <br>//--------------------------------------------------------------------------- <br> <br>LPTSTR   GetStringRes (int id) <br>{ <br>  static TCHAR buffer[MAX_PATH]; <br> <br>  buffer[0]=0; <br>  LoadString (GetModuleHandle (NULL), id, buffer, MAX_PATH); <br>  return buffer; <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
