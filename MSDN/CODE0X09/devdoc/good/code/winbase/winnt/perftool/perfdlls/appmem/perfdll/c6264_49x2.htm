<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>PERFMEM.C</title>
<link disabled rel=stylesheet href=../../../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6266"></a>PERFMEM.C</h2>
<pre><code>/*++ <br> <br>Copyright 1995 - 1998 Microsoft Corporation <br> <br>Module Name: <br> <br>    perfmem.c <br> <br>Abstract: <br> <br>    This file implements the Extensible Objects for  the application <br>    memory object <br> <br>Created: <br> <br>    Bob Watson 24 august 1995 <br> <br>Revision History <br> <br>    None <br> <br>--*/ <br>// <br>//  Include Files <br>// <br>#include &lt;windows.h&gt; <br>#include &lt;string.h&gt; <br>#include &lt;winperf.h&gt; <br>#include "..\inc\appmemi.h"     // definitions shared with the app. dll <br>#include "memctrs.h"            // error message definition <br>#include "perfmsg.h"            // message utilities <br>#include "perfutil.h"           // perf data utilities <br>#include "datamem.h"            // perf data structure definitions <br> <br>// <br>//  References to constants which initialize the Object type definitions <br>// <br>extern APPMEM_DATA_DEFINITION AppMemDataDefinition; <br> <br>static DWORD   dwOpenCount = 0;        // count of "Open" threads <br>static BOOL    bInitOK = FALSE;        // true = DLL initialized OK <br> <br>// <br>// App Mem counter data structures <br>// <br> <br>static  HANDLE  hAppMemSharedMemory = NULL; // Handle of counter Shared Memory <br>static  HANDLE  hAppMemMutex = NULL;        // sync mutex for memory <br> <br>static  PAPPMEM_DATA_HEADER pDataHeader = NULL; // pointer to header of shared mem <br>// <br>//  Function Prototypes <br>// <br>//      these are used to insure that the data collection functions <br>//      accessed by Perflib will have the correct calling format. <br>// <br> <br>PM_OPEN_PROC    OpenAppMemPerformanceData; <br>PM_COLLECT_PROC CollectAppMemPerformanceData; <br>PM_CLOSE_PROC   CloseAppMemPerformanceData; <br> <br>  <br>DWORD APIENTRY <br>OpenAppMemPerformanceData( <br>    LPWSTR lpDeviceNames <br>) <br>/*++ <br> <br>Routine Description: <br> <br>    This routine will open and map the memory used by the App Mem DLL to <br>    pass performance data in. This routine also initializes the data <br>    structures used to pass data back to the registry <br> <br>Arguments: <br> <br>    Pointer to object ID of each device to be opened <br> <br>Return Value: <br> <br>    None. <br> <br>--*/ <br> <br>{ <br>    LONG status; <br>    HKEY hKeyDriverPerf; <br>    DWORD size; <br>    DWORD type; <br>    DWORD dwFirstCounter; <br>    DWORD dwFirstHelp; <br>    APPMEM_COUNTERS     ac; <br> <br>    // <br>    //  Since WINLOGON is multi-threaded and will call this routine in <br>    //  order to service remote performance queries, this library <br>    //  must keep track of how many times it has been opened (i.e. <br>    //  how many threads have accessed it). the registry routines will <br>    //  limit access to the initialization routine to only one thread <br>    //  at a time so synchronization (i.e. reentrancy) should not be <br>    //  a problem <br>    // <br> <br>    if (dwOpenCount == 0) { // do this only on the first instance of the DLL <br>        // open Eventlog interface <br> <br>        hEventLog = MonOpenEventLog(); <br> <br>        // open/create shared memory used by the application to pass performance values <br>        status = GetSharedMemoryDataHeader ( <br>            &amp;hAppMemSharedMemory, &amp;hAppMemMutex, &amp;pDataHeader, <br>            TRUE); // only read access is required <br> <br>        if (status != ERROR_SUCCESS) { <br>            REPORT_ERROR_DATA (status, LOG_USER, NULL, 0); <br>            goto OpenExitPoint; <br>        } <br> <br>        // get counter and help index base values from registry <br>        //      Open key to registry entry <br>        //      read First Counter and First Help values <br>        //      update static data strucutures by adding base to <br>        //          offset value in structure. <br> <br>        status = RegOpenKeyEx ( <br>            HKEY_LOCAL_MACHINE, <br>            "SYSTEM\\CurrentControlSet\\Services\\AppMem\\Performance", <br>            0L, <br>            KEY_ALL_ACCESS, <br>            &amp;hKeyDriverPerf); <br> <br>        if (status != ERROR_SUCCESS) { <br>            REPORT_ERROR_DATA (APPMEM_UNABLE_OPEN_DRIVER_KEY, LOG_USER, <br>                &amp;status, sizeof(status)); <br>            // this is fatal, if we can't get the base values of the <br>            // counter or help names, then the names won't be available <br>            // to the requesting application  so there's not much <br>            // point in continuing. <br>            goto OpenExitPoint; <br>        } <br> <br>        size = sizeof (DWORD); <br>        status = RegQueryValueEx( <br>                    hKeyDriverPerf, <br>                    "First Counter", <br>                    0L, <br>                    &amp;type, <br>                    (LPBYTE)&amp;dwFirstCounter, <br>                    &amp;size); <br> <br>        if (status != ERROR_SUCCESS) { <br>            REPORT_ERROR_DATA (APPMEM_UNABLE_READ_FIRST_COUNTER, LOG_USER, <br>                &amp;status, sizeof(status)); <br>            // this is fatal, if we can't get the base values of the <br>            // counter or help names, then the names won't be available <br>            // to the requesting application  so there's not much <br>            // point in continuing. <br>            goto OpenExitPoint; <br>        } <br> <br>        size = sizeof (DWORD); <br>        status = RegQueryValueEx( <br>                    hKeyDriverPerf, <br>                    "First Help", <br>                    0L, <br>                    &amp;type, <br>                    (LPBYTE)&amp;dwFirstHelp, <br>                    &amp;size); <br> <br>        if (status != ERROR_SUCCESS) { <br>            REPORT_ERROR_DATA (APPMEM_UNABLE_READ_FIRST_HELP, LOG_USER, <br>                &amp;status, sizeof(status)); <br>            // this is fatal, if we can't get the base values of the <br>            // counter or help names, then the names won't be available <br>            // to the requesting application  so there's not much <br>            // point in continuing. <br>            goto OpenExitPoint; <br>        } <br> <br>        // <br>        //  NOTE: the initialization program could also retrieve <br>        //      LastCounter and LastHelp if they wanted to do <br>        //      bounds checking on the new number. e.g. <br>        // <br>        //      counter-&gt;CounterNameTitleIndex += dwFirstCounter; <br>        //      if (counter-&gt;CounterNameTitleIndex &gt; dwLastCounter) { <br>        //          LogErrorToEventLog (INDEX_OUT_OF_BOUNDS); <br>        //      } <br> <br>        AppMemDataDefinition.AppMemObjectType.ObjectNameTitleIndex += dwFirstCounter; <br>        AppMemDataDefinition.AppMemObjectType.ObjectHelpTitleIndex += dwFirstHelp; <br> <br>        AppMemDataDefinition.AppMemBytesAllocated.CounterNameTitleIndex += dwFirstCounter; <br>        AppMemDataDefinition.AppMemBytesAllocated.CounterHelpTitleIndex += dwFirstHelp; <br>        AppMemDataDefinition.AppMemBytesAllocated.CounterOffset +=  <br>            (DWORD)((LPBYTE)&amp;ac.dwAppMemBytesAllocated - (LPBYTE)&amp;ac); <br> <br>        AppMemDataDefinition.AppMemAllocs.CounterNameTitleIndex += dwFirstCounter; <br>        AppMemDataDefinition.AppMemAllocs.CounterHelpTitleIndex += dwFirstHelp; <br>        AppMemDataDefinition.AppMemAllocs.CounterOffset = <br>            (DWORD)((LPBYTE)&amp;ac.dwAppMemAllocs - (LPBYTE)&amp;ac); <br> <br>        AppMemDataDefinition.AppMemAllocsSec.CounterNameTitleIndex += dwFirstCounter; <br>        AppMemDataDefinition.AppMemAllocsSec.CounterHelpTitleIndex += dwFirstHelp; <br>        AppMemDataDefinition.AppMemAllocsSec.CounterOffset = <br>            (DWORD)((LPBYTE)&amp;ac.dwAppMemAllocsSec - (LPBYTE)&amp;ac); <br> <br>        AppMemDataDefinition.AppMemReAllocs.CounterNameTitleIndex += dwFirstCounter; <br>        AppMemDataDefinition.AppMemReAllocs.CounterHelpTitleIndex += dwFirstCounter; <br>        AppMemDataDefinition.AppMemReAllocs.CounterOffset= <br>            (DWORD)((LPBYTE)&amp;ac.dwAppMemReAllocs - (LPBYTE)&amp;ac); <br> <br>        AppMemDataDefinition.AppMemReAllocsSec.CounterNameTitleIndex += dwFirstCounter; <br>        AppMemDataDefinition.AppMemReAllocsSec.CounterHelpTitleIndex += dwFirstHelp; <br>        AppMemDataDefinition.AppMemReAllocsSec.CounterOffset = <br>            (DWORD)((LPBYTE)&amp;ac.dwAppMemReAllocsSec - (LPBYTE)&amp;ac); <br> <br>        AppMemDataDefinition.AppMemFrees.CounterNameTitleIndex += dwFirstCounter; <br>        AppMemDataDefinition.AppMemFrees.CounterHelpTitleIndex += dwFirstHelp; <br>        AppMemDataDefinition.AppMemFrees.CounterOffset = <br>            (DWORD)((LPBYTE)&amp;ac.dwAppMemFrees - (LPBYTE)&amp;ac); <br> <br>        AppMemDataDefinition.AppMemFreesSec.CounterNameTitleIndex += dwFirstCounter; <br>        AppMemDataDefinition.AppMemFreesSec.CounterHelpTitleIndex += dwFirstHelp; <br>        AppMemDataDefinition.AppMemFreesSec.CounterOffset = <br>            (DWORD)((LPBYTE)&amp;ac.dwAppMemFreesSec - (LPBYTE)&amp;ac); <br> <br>        RegCloseKey (hKeyDriverPerf); // close key to registry <br> <br>        bInitOK = TRUE; // ok to use this function <br>    } <br> <br>    dwOpenCount++;  // increment OPEN counter <br> <br>    status = ERROR_SUCCESS; // for successful exit <br> <br>OpenExitPoint: <br> <br>    return status; <br>} <br> <br>  <br>DWORD APIENTRY <br>CollectAppMemPerformanceData( <br>    IN      LPWSTR  lpValueName, <br>    IN OUT  LPVOID  *lppData, <br>    IN OUT  LPDWORD lpcbTotalBytes, <br>    IN OUT  LPDWORD lpNumObjectTypes <br>) <br>/*++ <br> <br>Routine Description: <br> <br>    This routine will return the data for the Application memory counters <br> <br>Arguments: <br> <br>   IN       LPWSTR   lpValueName <br>            pointer to a wide character string passed by registry. <br> <br>   IN OUT   LPVOID   *lppData <br>         IN: pointer to the address of the buffer to receive the completed <br>            PerfDataBlock and subordinate structures. This routine will <br>            append its data to the buffer starting at the point referenced <br>            by *lppData. <br>         OUT: points to the first byte after the data structure added by this <br>            routine. This routine updated the value at lppdata after appending <br>            its data. <br> <br>   IN OUT   LPDWORD  lpcbTotalBytes <br>         IN: the address of the DWORD that tells the size in bytes of the <br>            buffer referenced by the lppData argument <br>         OUT: the number of bytes added by this routine is writted to the <br>            DWORD pointed to by this argument <br> <br>   IN OUT   LPDWORD  NumObjectTypes <br>         IN: the address of the DWORD to receive the number of objects added <br>            by this routine <br>         OUT: the number of objects added by this routine is writted to the <br>            DWORD pointed to by this argument <br> <br>Return Value: <br> <br>      ERROR_MORE_DATA if buffer passed is too small to hold data <br>         any error conditions encountered are reported to the event log if <br>         event logging is enabled. <br> <br>      ERROR_SUCCESS  if success or any other error. Errors, however are <br>         also reported to the event log. <br> <br>--*/ <br>{ <br>    //  Variables for reformating the data <br> <br>    ULONG                       SpaceNeeded; <br>    PERF_INSTANCE_DEFINITION    *pPerfInstanceDef; <br>    APPMEM_DATA_DEFINITION      *pAppMemDataDefinition; <br>    DWORD                       dwQueryType; <br>    DWORD                       dwInstanceIndex; <br>    PAPPMEM_INSTANCE            pThisAppInstanceData = NULL; <br>    BOOL                        bFreeMutex; <br>    PAPPMEM_COUNTERS            pAC; <br> <br>    // <br>    // before doing anything else, see if Open went OK <br>    // <br>    if ((!bInitOK) || (pDataHeader == NULL)) { <br>        // unable to continue because open failed. <br>        *lpcbTotalBytes = (DWORD) 0; <br>        *lpNumObjectTypes = (DWORD) 0; <br>        return ERROR_SUCCESS; // yes, this is a successful exit <br>    } <br> <br>    // see if this is a foreign (i.e. non-NT) computer data request <br>    // <br>    dwQueryType = GetQueryType (lpValueName); <br> <br>    if (dwQueryType == QUERY_FOREIGN) { <br>        // this routine does not service requests for data from <br>        // Non-NT computers <br>        *lpcbTotalBytes = (DWORD) 0; <br>        *lpNumObjectTypes = (DWORD) 0; <br>        return ERROR_SUCCESS; <br>    } <br> <br>    if (dwQueryType == QUERY_ITEMS){ <br>        if ( !(IsNumberInUnicodeList (AppMemDataDefinition.AppMemObjectType.ObjectNameTitleIndex, lpValueName))) { <br>            // request received for data object not provided by this routine <br>            *lpcbTotalBytes = (DWORD) 0; <br>            *lpNumObjectTypes = (DWORD) 0; <br>            return ERROR_SUCCESS; <br>        } <br>    } <br> <br>    // if here, then this must be one for us so load data structures <br> <br>    pAppMemDataDefinition = (APPMEM_DATA_DEFINITION *) *lppData; <br> <br>    if (hAppMemMutex != NULL) { <br>        if (WaitForSingleObject (hAppMemMutex, SHARED_MEMORY_MUTEX_TIMEOUT) == WAIT_FAILED) { <br>            // unable to obtain a lock <br>            bFreeMutex = FALSE; <br>        } else { <br>            bFreeMutex = TRUE; <br>        } <br>    } else { <br>        bFreeMutex = FALSE; <br>    } <br>     <br>    // always return an "instance sized" buffer after the definition blocks <br>    // to prevent perfmon from reading bogus data. This is strictly a hack <br>    // to accomodate how PERFMON handles the "0" instance case. <br>    //  By doing this, perfmon won't choke when there are no instances <br>    //  and the counter object &amp; counters will be displayed in the <br>    //  list boxes, even though no instances will be listed. <br> <br>    SpaceNeeded = sizeof(APPMEM_DATA_DEFINITION) + <br>        ((pDataHeader-&gt;dwInstanceCount &gt; 0 ? pDataHeader-&gt;dwInstanceCount : 1) * ( <br>            sizeof(PERF_INSTANCE_DEFINITION) + <br>            MAX_SIZEOF_INSTANCE_NAME + <br>            sizeof(APPMEM_COUNTERS))); <br> <br>    if ( *lpcbTotalBytes &lt; SpaceNeeded ) { <br>        // not enough room so return nothing. <br>        *lpcbTotalBytes = (DWORD) 0; <br>        *lpNumObjectTypes = (DWORD) 0; <br>        return ERROR_MORE_DATA; <br>    } <br> <br>    // copy the object &amp; counter definition information <br> <br>    memmove(pAppMemDataDefinition, <br>        &amp;AppMemDataDefinition, <br>        sizeof(APPMEM_DATA_DEFINITION)); <br> <br>    // prepare to read the instance data <br>    pPerfInstanceDef = (PERF_INSTANCE_DEFINITION *) &amp;pAppMemDataDefinition[1]; <br> <br>    // point to the first instance structure in the shared buffer <br>    pThisAppInstanceData = FIRST_INUSE(pDataHeader); <br> <br>    // process each of the instances in the shared memory buffer <br>    dwInstanceIndex = 0; <br>    while ((dwInstanceIndex &lt; pDataHeader-&gt;dwInstanceCount) &amp;&amp; <br>            (pThisAppInstanceData != NULL)){ <br>        // initialize this instance <br>        MonBuildInstanceDefinition ( <br>            pPerfInstanceDef, <br>            &amp;pAC, // pointer to first byte after instance def <br>            0,  // no parent <br>            0,  //  object to reference <br>            (DWORD)PERF_NO_UNIQUE_ID, <br>            pThisAppInstanceData-&gt;wcszInstanceName); <br>        // <br>        //    collect and format app memory perf data from shared memory <br>        // <br> <br>        pAC-&gt;CounterBlock.ByteLength = sizeof(APPMEM_COUNTERS); <br> <br>        // set pointer to first counter data field <br>         <br>        pAC-&gt;dwAppMemBytesAllocated = pThisAppInstanceData-&gt;dwApplicationBytes; <br>        pAC-&gt;dwAppMemAllocs = pThisAppInstanceData-&gt;dwAllocCalls; <br>        pAC-&gt;dwAppMemAllocsSec = pThisAppInstanceData-&gt;dwAllocCalls; <br>        pAC-&gt;dwAppMemReAllocs = pThisAppInstanceData-&gt;dwReAllocCalls; <br>        pAC-&gt;dwAppMemReAllocsSec = pThisAppInstanceData-&gt;dwReAllocCalls; <br>        pAC-&gt;dwAppMemFrees = pThisAppInstanceData-&gt;dwFreeCalls; <br>        pAC-&gt;dwAppMemFreesSec = pThisAppInstanceData-&gt;dwFreeCalls; <br> <br>        // setup for the next instance <br>        dwInstanceIndex++; <br>        pThisAppInstanceData = <br>            APPMEM_INST(pDataHeader, pThisAppInstanceData-&gt;dwOffsetOfNext); <br>        pPerfInstanceDef = <br>            (PERF_INSTANCE_DEFINITION *)((LPBYTE)pAC + sizeof(APPMEM_COUNTERS)); <br>    } <br> <br>    if (dwInstanceIndex == 0) { <br>        // zero fill one instance sized block of data if there are no <br>        // data instances <br> <br>        memset (pPerfInstanceDef, 0, <br>            (sizeof(PERF_INSTANCE_DEFINITION) + <br>            MAX_SIZEOF_INSTANCE_NAME + <br>            sizeof(APPMEM_COUNTERS))); <br> <br>        // adjust pointer to point to end of zeroed block <br>        (BYTE *)pPerfInstanceDef += (sizeof(PERF_INSTANCE_DEFINITION) + <br>            MAX_SIZEOF_INSTANCE_NAME + <br>            sizeof(APPMEM_COUNTERS)); <br> <br>    } <br> <br>    // done with the shared memory so free the mutex if one was  <br>    // acquired <br> <br>    if (bFreeMutex) { <br>        ReleaseMutex (hAppMemMutex); <br>    } <br> <br>    *lppData = (PVOID)pPerfInstanceDef; <br> <br>    // update arguments for return <br> <br>    *lpNumObjectTypes = 1; <br>    pAppMemDataDefinition-&gt;AppMemObjectType.NumInstances = dwInstanceIndex; <br> <br>    pAppMemDataDefinition-&gt;AppMemObjectType.TotalByteLength = <br>    *lpcbTotalBytes = (DWORD)((PBYTE)pPerfInstanceDef - <br>                              (PBYTE) pAppMemDataDefinition); <br> <br>    return ERROR_SUCCESS; <br>} <br>  <br>DWORD APIENTRY <br>CloseAppMemPerformanceData( <br>) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    This routine closes the open handles to Application Memory <br>        usage performance counters <br> <br>Arguments: <br> <br>    None. <br> <br> <br>Return Value: <br> <br>    ERROR_SUCCESS <br> <br>--*/ <br> <br>{ <br>    if ((--dwOpenCount) == 0) { // when this is the last thread... <br> <br>        if (hAppMemSharedMemory != NULL) CloseHandle(hAppMemSharedMemory); <br>        if (hAppMemMutex != NULL)       CloseHandle(hAppMemMutex); <br> <br>        pDataHeader = NULL; <br> <br>        MonCloseEventLog(); <br>    } <br> <br>    return ERROR_SUCCESS; <br> <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
