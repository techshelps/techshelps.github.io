<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>PERFUTIL.C</title>
<link disabled rel=stylesheet href=../../../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6268"></a>PERFUTIL.C</h2>
<pre><code>/*++ BUILD Version: 0001    // Increment this if a change has global effects <br> <br>Copyright (c) 1992  Microsoft Corporation <br> <br>Module Name: <br> <br>    perfutil.c <br> <br>Abstract: <br> <br>    This file implements the utility routines used to construct the <br>common parts of a PERF_INSTANCE_DEFINITION (see winperf.h) and <br>    perform event logging functions. <br> <br>Created: <br> <br>    Russ Blake  07/30/92 <br> <br>Revision History: <br> <br>--*/ <br>// <br>//  include files <br>// <br>//#include &lt;nt.h&gt; <br>//#include &lt;ntrtl.h&gt; <br>//#include &lt;nturtl.h&gt; <br>#include &lt;windows.h&gt; <br>#include &lt;string.h&gt; <br>#include &lt;winperf.h&gt; <br>#include "memctrs.h" // error message definition <br>#include "perfmsg.h" <br>#include "perfutil.h" <br> <br>#define INITIAL_SIZE     1024L <br>#define EXTEND_SIZE      1024L <br> <br>// <br>// Global data definitions. <br>// <br> <br>ULONG                   ulInfoBufferSize = 0; <br> <br>HANDLE hEventLog = NULL;      // event log handle for reporting events <br>                              // initialized in Open... routines <br>DWORD  dwLogUsers = 0;        // count of functions using event log <br> <br>DWORD MESSAGE_LEVEL = 0; <br> <br>WCHAR GLOBAL_STRING[] = L"Global"; <br>WCHAR FOREIGN_STRING[] = L"Foreign"; <br>WCHAR COSTLY_STRING[] = L"Costly"; <br> <br>WCHAR NULL_STRING[] = L"\0";    // pointer to null string <br> <br>// test for delimiter, end of line and non-digit characters <br>// used by IsNumberInUnicodeList routine <br>// <br>#define DIGIT       1 <br>#define DELIMITER   2 <br>#define INVALID     3 <br> <br>#define EvalThisChar(c,d) ( \ <br>     (c == d) ? DELIMITER : \ <br>     (c == 0) ? DELIMITER : \ <br>     (c &lt; (WCHAR)'0') ? INVALID : \ <br>     (c &gt; (WCHAR)'9') ? INVALID : \ <br>     DIGIT) <br> <br>  <br>BOOL <br>MonBuildInstanceDefinition( <br>    PERF_INSTANCE_DEFINITION *pBuffer, <br>    PVOID *pBufferNext, <br>    DWORD ParentObjectTitleIndex, <br>    DWORD ParentObjectInstance, <br>    DWORD UniqueID, <br>    LPWSTR  Name <br>    ) <br>/*++ <br> <br>    MonBuildInstanceDefinition  -   Build an instance of an object <br> <br>        Inputs: <br> <br>            pBuffer         -   pointer to buffer where instance is to <br>                                be constructed <br> <br>            pBufferNext     -   pointer to a pointer which will contain <br>                                next available location, DWORD aligned <br> <br>            ParentObjectTitleIndex <br>                            -   Title Index of parent object type; 0 if <br>                                no parent object <br> <br>            ParentObjectInstance <br>                            -   Index into instances of parent object <br>                                type, starting at 0, for this instances <br>                                parent object instance <br> <br>            UniqueID        -   a unique identifier which should be used <br>                                instead of the Name for identifying <br>                                this instance <br> <br>            Name            -   Name of this instance <br>--*/ <br>{ <br>    DWORD NameLength = 0; <br>    WCHAR *pName; <br> <br>    // <br>    //  Include trailing null in name size <br>    // <br> <br>    NameLength = lstrlenW(Name) * sizeof(WCHAR); <br>    if (NameLength &gt; 0) { <br>        NameLength += sizeof(WCHAR); // to include the terminating NULL <br>    } <br> <br>    pBuffer-&gt;ByteLength = sizeof(PERF_INSTANCE_DEFINITION) + <br>                          DWORD_MULTIPLE(NameLength); <br> <br>    pBuffer-&gt;ParentObjectTitleIndex = ParentObjectTitleIndex; <br>    pBuffer-&gt;ParentObjectInstance = ParentObjectInstance; <br>    pBuffer-&gt;UniqueID = UniqueID; <br>    pBuffer-&gt;NameOffset = sizeof(PERF_INSTANCE_DEFINITION); <br>    pBuffer-&gt;NameLength = NameLength; <br> <br>    pName = (PWCHAR)&amp;pBuffer[1]; <br>    lstrcpyW (pName, Name); <br> <br>    *pBufferNext = (PVOID) ((PCHAR) pBuffer + pBuffer-&gt;ByteLength); <br>    return TRUE; <br>} <br> <br>  <br>HANDLE <br>MonOpenEventLog ( <br>) <br>/*++ <br> <br>Routine Description: <br> <br>    Reads the level of event logging from the registry and opens the <br>        channel to the event logger for subsequent event log entries. <br> <br>Arguments: <br> <br>      None <br> <br>Return Value: <br> <br>    Handle to the event log for reporting events. <br>    NULL if open not successful. <br> <br>--*/ <br>{ <br>    HKEY hAppKey; <br>    TCHAR LogLevelKeyName[] = "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Perflib"; <br>    TCHAR LogLevelValueName[] = "EventLogLevel"; <br> <br>    LONG lStatus; <br> <br>    DWORD dwLogLevel; <br>    DWORD dwValueType; <br>    DWORD dwValueSize; <br> <br>    // if global value of the logging level not initialized or is disabled, <br>    //  check the registry to see if it should be updated. <br> <br>    if (!MESSAGE_LEVEL) { <br> <br>       lStatus = RegOpenKeyEx (HKEY_LOCAL_MACHINE, <br>                               LogLevelKeyName, <br>                               0, <br>                               KEY_READ, <br>                               &amp;hAppKey); <br> <br>       dwValueSize = sizeof (dwLogLevel); <br> <br>       if (lStatus == ERROR_SUCCESS) { <br>            lStatus = RegQueryValueEx (hAppKey, <br>                               LogLevelValueName, <br>                               (LPDWORD)NULL, <br>                               &amp;dwValueType, <br>                               (LPBYTE)&amp;dwLogLevel, <br>                               &amp;dwValueSize); <br> <br>            if (lStatus == ERROR_SUCCESS) { <br>               MESSAGE_LEVEL = dwLogLevel; <br>            } else { <br>               MESSAGE_LEVEL = MESSAGE_LEVEL_DEFAULT; <br>            } <br>            RegCloseKey (hAppKey); <br>       } else { <br>         MESSAGE_LEVEL = MESSAGE_LEVEL_DEFAULT; <br>       } <br>    } <br> <br>    if (hEventLog == NULL){ <br>         hEventLog = RegisterEventSource ( <br>            (LPTSTR)NULL,            // Use Local Machine <br>            APP_NAME);               // event log app name to find in registry <br> <br>         if (hEventLog != NULL) { <br>            REPORT_INFORMATION (UTIL_LOG_OPEN, LOG_DEBUG); <br>         } <br>    } <br> <br>    if (hEventLog != NULL) { <br>         dwLogUsers++;           // increment count of perfctr log users <br>    } <br>    return (hEventLog); <br>} <br> <br>  <br>VOID <br>MonCloseEventLog ( <br>) <br>/*++ <br> <br>Routine Description: <br> <br>      Closes the handle to the event logger if this is the last caller <br> <br>Arguments: <br> <br>      None <br> <br>Return Value: <br> <br>      None <br> <br>--*/ <br>{ <br>    if (hEventLog != NULL) { <br>        dwLogUsers--;         // decrement usage <br>        if (dwLogUsers &lt;= 0) {    // and if we're the last, then close up log <br>            REPORT_INFORMATION (UTIL_CLOSING_LOG, LOG_DEBUG); <br>            DeregisterEventSource (hEventLog); <br>        } <br>    } <br>} <br>  <br>DWORD <br>GetQueryType ( <br>    IN LPWSTR lpValue <br>) <br>/*++ <br> <br>GetQueryType <br> <br>    returns the type of query described in the lpValue string so that <br>    the appropriate processing method may be used <br> <br>Arguments <br> <br>    IN lpValue <br>        string passed to PerfRegQuery Value for processing <br> <br>Return Value <br> <br>    QUERY_GLOBAL <br>        if lpValue == 0 (null pointer) <br>           lpValue == pointer to Null string <br>           lpValue == pointer to "Global" string <br> <br>    QUERY_FOREIGN <br>        if lpValue == pointer to "Foriegn" string <br> <br>    QUERY_COSTLY <br>        if lpValue == pointer to "Costly" string <br> <br>    otherwise: <br> <br>    QUERY_ITEMS <br> <br>--*/ <br>{ <br>    WCHAR   *pwcArgChar, *pwcTypeChar; <br>    BOOL    bFound; <br> <br>    if (lpValue == 0) { <br>        return QUERY_GLOBAL; <br>    } else if (*lpValue == 0) { <br>        return QUERY_GLOBAL; <br>    } <br> <br>    // check for "Global" request <br> <br>    pwcArgChar = lpValue; <br>    pwcTypeChar = GLOBAL_STRING; <br>    bFound = TRUE;  // assume found until contradicted <br> <br>    // check to the length of the shortest string <br> <br>    while ((*pwcArgChar != 0) &amp;&amp; (*pwcTypeChar != 0)) { <br>        if (*pwcArgChar++ != *pwcTypeChar++) { <br>            bFound = FALSE; // no match <br>            break;          // bail out now <br>        } <br>    } <br> <br>    if (bFound) return QUERY_GLOBAL; <br> <br>    // check for "Foreign" request <br> <br>    pwcArgChar = lpValue; <br>    pwcTypeChar = FOREIGN_STRING; <br>    bFound = TRUE;  // assume found until contradicted <br> <br>    // check to the length of the shortest string <br> <br>    while ((*pwcArgChar != 0) &amp;&amp; (*pwcTypeChar != 0)) { <br>        if (*pwcArgChar++ != *pwcTypeChar++) { <br>            bFound = FALSE; // no match <br>            break;          // bail out now <br>        } <br>    } <br> <br>    if (bFound) return QUERY_FOREIGN; <br> <br>    // check for "Costly" request <br> <br>    pwcArgChar = lpValue; <br>    pwcTypeChar = COSTLY_STRING; <br>    bFound = TRUE;  // assume found until contradicted <br> <br>    // check to the length of the shortest string <br> <br>    while ((*pwcArgChar != 0) &amp;&amp; (*pwcTypeChar != 0)) { <br>        if (*pwcArgChar++ != *pwcTypeChar++) { <br>            bFound = FALSE; // no match <br>            break;          // bail out now <br>        } <br>    } <br> <br>    if (bFound) return QUERY_COSTLY; <br> <br>    // if not Global and not Foreign and not Costly, <br>    // then it must be an item list <br> <br>    return QUERY_ITEMS; <br> <br>} <br>  <br>BOOL <br>IsNumberInUnicodeList ( <br>    IN DWORD   dwNumber, <br>    IN LPWSTR  lpwszUnicodeList <br>) <br>/*++ <br> <br>IsNumberInUnicodeList <br> <br>Arguments: <br> <br>    IN dwNumber <br>        DWORD number to find in list <br> <br>    IN lpwszUnicodeList <br>        Null terminated, Space delimited list of decimal numbers <br> <br>Return Value: <br> <br>    TRUE: <br>            dwNumber was found in the list of unicode number strings <br> <br>    FALSE: <br>            dwNumber was not found in the list. <br> <br>--*/ <br>{ <br>    DWORD   dwThisNumber; <br>    WCHAR   *pwcThisChar; <br>    BOOL    bValidNumber; <br>    BOOL    bNewItem; <br>    WCHAR   wcDelimiter;    // could be an argument to be more flexible <br> <br>    if (lpwszUnicodeList == 0) return FALSE;    // null pointer, # not founde <br> <br>    pwcThisChar = lpwszUnicodeList; <br>    dwThisNumber = 0; <br>    wcDelimiter = (WCHAR)' '; <br>    bValidNumber = FALSE; <br>    bNewItem = TRUE; <br> <br>    while (TRUE) { <br>        switch (EvalThisChar (*pwcThisChar, wcDelimiter)) { <br>            case DIGIT: <br>                // if this is the first digit after a delimiter, then <br>                // set flags to start computing the new number <br>                if (bNewItem) { <br>                    bNewItem = FALSE; <br>                    bValidNumber = TRUE; <br>                } <br>                if (bValidNumber) { <br>                    dwThisNumber *= 10; <br>                    dwThisNumber += (*pwcThisChar - (WCHAR)'0'); <br>                } <br>                break; <br> <br>            case DELIMITER: <br>                // a delimter is either the delimiter character or the <br>                // end of the string ('\0') if when the delimiter has been <br>                // reached a valid number was found, then compare it to the <br>                // number from the argument list. if this is the end of the <br>                // string and no match was found, then return. <br>                // <br>                if (bValidNumber) { <br>                    if (dwThisNumber == dwNumber) return TRUE; <br>                    bValidNumber = FALSE; <br>                } <br>                if (*pwcThisChar == 0) { <br>                    return FALSE; <br>                } else { <br>                    bNewItem = TRUE; <br>                    dwThisNumber = 0; <br>                } <br>                break; <br> <br>            case INVALID: <br>                // if an invalid character was encountered, ignore all <br>                // characters up to the next delimiter and then start fresh. <br>                // the invalid number is not compared. <br>                bValidNumber = FALSE; <br>                break; <br> <br>            default: <br>                break; <br> <br>        } <br>        pwcThisChar++; <br>    } <br> <br>}   // IsNumberInUnicodeList </code></pre>
<p>&nbsp;</p></body>
</HTML>
