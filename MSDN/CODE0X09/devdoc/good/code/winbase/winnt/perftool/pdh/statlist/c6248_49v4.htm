<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>MAINWND.C</title>
<link disabled rel=stylesheet href=../../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6250"></a>MAINWND.C</h2>
<pre><code>//THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF <br>//ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO <br>//THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A <br>// PARTICULAR PURPOSE. <br>// <br>// Copyright 1996 - 1997 Microsoft Corporation.  All Rights Reserved. <br>// <br>// Mainwnd: mainwnd.c <br>// <br>// PURPOSE: main window functions <br>// <br>// PLATFORMS:  Windows NT (only) <br>// <br>// FUNCTIONS: <br>//  DeleteAllCounters()     clears counters from query <br>//  On_WM_CREATE()          processes WM_CREATE message <br>//  On_IDM_GET_DATA()       gets the current perf data and updates window <br>//  On_IDM_ADD_COUNTERS()   displays browser &amp; adds perf. counter to display <br>//  On_IDM_CLEAR_ALL()      clear all counters &amp; refresh display <br>//  On_WM_COMMAND()         processes WM_COMMAND messages <br>//  On_WM_RBUTTONDOWN()     processes Right Mouse button clicks <br>//  On_WM_PAINT()           draws the current data in the main window <br>//  On_WM_DESTROY()         closes any open interfaces &amp; memory allocations <br>//  WndProc()               main window procedure for this app's window <br>// <br>// SPECIAL INSTRUCTIONS: N/A <br>// <br>#define WIN32_LEAN_AND_MEAN 1 <br>#include &lt;windows.h&gt; <br>#include &lt;winperf.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;pdh.h&gt; <br>#include &lt;pdhmsg.h&gt; <br> <br>#include "statlist.h" <br>#include "winutils.h" <br>#include "mainwnd.h" <br>#include "aboutdlg.h" <br> <br>// font for text in window <br>static   HFONT hFinePrint = NULL;  <br> <br>// PDH Query Handle for these counters <br>static HQUERY   hQuery = NULL; <br> <br>// pointer to first item in counter list <br>static PCIB    pFirstCib = NULL; <br> <br>int nTabStops[] = {300, 400, 500, 600, 700}; <br>int nNumTabStops = sizeof(nTabStops) / sizeof(int); <br> <br>#define NUM_STAT_SAMPLES    100 <br>  <br>static <br>void <br>DeleteAllCounters () <br>{ <br>    PCIB   pCib, pCibOld; <br> <br>    // close PDH Query <br>    // this removes all counters from the query as well as <br>    // removes the query item itself <br>    if (hQuery != NULL) { <br>        PdhCloseQuery (hQuery); <br>        hQuery = NULL; <br>    } <br> <br>    // clean up any memory allocations <br>    pCib = pFirstCib; <br>    while ( pCib != NULL) { <br>        pCibOld = pCib; <br>        if (pCibOld-&gt;pCounterArray != NULL) { <br>            HeapFree (GetProcessHeap(), 0, pCibOld-&gt;pCounterArray); <br>        } <br>        pCib = pCib-&gt;pNext; <br>        HeapFree (GetProcessHeap(), 0, pCibOld); <br>    } <br>    pFirstCib = NULL; <br>} <br>  <br>// windows message functions <br>static <br>LRESULT <br>On_WM_CREATE ( <br>    HWND hWnd, <br>    WPARAM wParam, <br>    LPARAM lParam) <br>{ <br>    PDH_STATUS  pdhStatus; <br> <br>    if (hQuery == NULL) { <br>        pdhStatus = PdhOpenQuery (NULL, 0, &amp;hQuery); <br>    } <br>    if (hFinePrint == NULL) { <br>        hFinePrint = CreateFont(11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, <br>                                    VARIABLE_PITCH | FF_SWISS, ""); <br>    } <br>    return ERROR_SUCCESS; <br>} <br>  <br>static <br>LRESULT <br>On_IDM_GET_DATA ( <br>    HWND hWnd, <br>    WPARAM wParam, <br>    LPARAM lParam) <br>{ <br>    PDH_STATUS  pdhStatus; <br>    DWORD       dwType; <br>    PCIB        pCib; <br>    PDH_FMT_COUNTERVALUE    pValue; <br>    PDH_RAW_COUNTER         pRaw; <br>     <br>    if (hQuery != NULL) { <br>        // get the current values of the query data <br>        pdhStatus = PdhCollectQueryData (hQuery); <br>        if (pdhStatus == ERROR_SUCCESS) { <br>            // loop through all counters and update the display values <br>            // and statistics <br>            for (pCib = pFirstCib; pCib != NULL; pCib = pCib-&gt;pNext) { <br>                // update "Last value" <br>                pdhStatus = PdhGetFormattedCounterValue ( <br>                    pCib-&gt;hCounter, PDH_FMT_DOUBLE, &amp;dwType, &amp;pValue); <br>                pCib-&gt;dLastValue = pValue.doubleValue; <br>                // update "Raw Value" and statistics <br>                pdhStatus = PdhGetRawCounterValue ( <br>                    pCib-&gt;hCounter, &amp;dwType, &amp;pRaw); <br>                pCib-&gt;pCounterArray[pCib-&gt;dwNextIndex] = pRaw; <br>                pdhStatus = PdhComputeCounterStatistics ( <br>                    pCib-&gt;hCounter, <br>                    PDH_FMT_DOUBLE, <br>                    pCib-&gt;dwFirstIndex, <br>                    ++pCib-&gt;dwLastIndex, <br>                    pCib-&gt;pCounterArray, <br>                    &amp;pCib-&gt;pdhCurrentStats); <br>                // update pointers &amp; indeces <br>                if (pCib-&gt;dwLastIndex &lt; NUM_STAT_SAMPLES) { <br>                    pCib-&gt;dwNextIndex = ++pCib-&gt;dwNextIndex % NUM_STAT_SAMPLES; <br>                } else { <br>                    --pCib-&gt;dwLastIndex; <br>                    pCib-&gt;dwNextIndex = pCib-&gt;dwFirstIndex; <br>                    pCib-&gt;dwFirstIndex = ++pCib-&gt;dwFirstIndex % NUM_STAT_SAMPLES; <br>                } <br>            } <br>            // cause the window to be repainted with the new values <br>            // (NOTE: This isn't the most efficient method of <br>            // display updating.) <br>            InvalidateRect (hWnd, NULL, TRUE); <br>        } <br>    } <br>    return ERROR_SUCCESS; <br>} <br>  <br>static <br>LRESULT <br>On_IDM_ADD_COUNTERS ( <br>    HWND hWnd, <br>    WPARAM wParam, <br>    LPARAM lParam) <br>{ <br>    PDH_BROWSE_DLG_CONFIG  BrowseInfo; <br>    CHAR            szCounterBuffer[MAX_PATH]; <br>    PDH_STATUS      pdhStatus; <br>    PCIB            pNewCib; <br> <br>    BrowseInfo.bIncludeInstanceIndex = FALSE; <br>    BrowseInfo.bSingleCounterPerAdd = TRUE; <br>    BrowseInfo.bSingleCounterPerDialog = TRUE; <br>    BrowseInfo.bLocalCountersOnly = FALSE; <br>    BrowseInfo.bWildCardInstances = FALSE; <br>    BrowseInfo.bHideDetailBox = FALSE; <br>    BrowseInfo.bDisableMachineSelection = FALSE; <br>    BrowseInfo.bInitializePath = FALSE; <br>    BrowseInfo.bIncludeCostlyObjects = TRUE; <br>    BrowseInfo.hWndOwner = hWnd; <br>    BrowseInfo.szReturnPathBuffer = szCounterBuffer; <br>    BrowseInfo.cchReturnPathLength = MAX_PATH; <br>    BrowseInfo.pCallBack = NULL; <br>    BrowseInfo.dwCallBackArg = 0; <br>    BrowseInfo.CallBackStatus = ERROR_SUCCESS; <br>    BrowseInfo.dwDefaultDetailLevel = PERF_DETAIL_WIZARD; <br>    BrowseInfo.szDialogBoxCaption = "Select a counter to monitor"; <br> <br> <br>    pdhStatus = PdhBrowseCounters (&amp;BrowseInfo); <br> <br>    if (pdhStatus == ERROR_SUCCESS) { <br>        // add counter to the list <br>        pNewCib = (PCIB) HeapAlloc(GetProcessHeap(), <br>            HEAP_ZERO_MEMORY, sizeof(CIB)); <br>        if (pNewCib != NULL) { <br>            // try to add the counter to the query <br>            pdhStatus = PdhAddCounter (hQuery, <br>                szCounterBuffer, 0, &amp;pNewCib-&gt;hCounter); <br>            if (pdhStatus == ERROR_SUCCESS) { <br>                lstrcpy(pNewCib-&gt;szCounterPath, szCounterBuffer); <br>                // allocate the raw data buffer here <br>                pNewCib-&gt;pCounterArray = (PPDH_RAW_COUNTER)HeapAlloc ( <br>                    GetProcessHeap(), HEAP_ZERO_MEMORY, <br>                    (sizeof(PDH_RAW_COUNTER) * NUM_STAT_SAMPLES)); <br>                pNewCib-&gt;dwFirstIndex = 0; <br>                pNewCib-&gt;dwNextIndex = 0; <br>                pNewCib-&gt;dwLastIndex = 0; <br>                pNewCib-&gt;dLastValue = 0.0f; <br>                pNewCib-&gt;pdhCurrentStats.dwFormat = 0; <br>                pNewCib-&gt;pdhCurrentStats.count = 0; <br>                pNewCib-&gt;pdhCurrentStats.min.CStatus = PDH_CSTATUS_INVALID_DATA; <br>                pNewCib-&gt;pdhCurrentStats.min.largeValue = 0; <br>                pNewCib-&gt;pdhCurrentStats.max.CStatus = PDH_CSTATUS_INVALID_DATA; <br>                pNewCib-&gt;pdhCurrentStats.max.largeValue = 0; <br>                pNewCib-&gt;pdhCurrentStats.mean.CStatus = PDH_CSTATUS_INVALID_DATA; <br>                pNewCib-&gt;pdhCurrentStats.mean.largeValue = 0; <br> <br>                //add to the top of the list <br>                pNewCib-&gt;pNext = pFirstCib; <br>                pFirstCib = pNewCib; <br> <br>                // repaint window to get new entry <br>                InvalidateRect (hWnd, NULL, TRUE); <br>            } // else unable to add counter <br>        } // else unable to allocate pointer <br>    } // else user cancelled <br>    return ERROR_SUCCESS; <br>} <br>  <br>static <br>LRESULT <br>On_IDM_CLEAR_ALL ( <br>    HWND hWnd, <br>    WPARAM wParam, <br>    LPARAM lParam) <br>{ <br>    PDH_STATUS  pdhStatus; <br> <br>    // delete all current counters, then create a new query <br>    DeleteAllCounters(); <br> <br>    pdhStatus = PdhOpenQuery (NULL, 0, &amp;hQuery); <br> <br>    InvalidateRect (hWnd, NULL, TRUE); <br> <br>    return ERROR_SUCCESS; <br>} <br>  <br>static <br>LRESULT <br>On_WM_COMMAND ( <br>    HWND hWnd, <br>    WPARAM wParam, <br>    LPARAM lParam) <br>{ <br>    int wmId, wmEvent; <br>    char szHelpFileName[MAX_PATH]; <br>    BOOL bGotHelp; <br> <br>    wmId    = LOWORD(wParam); // Remember, these are... <br>    wmEvent = HIWORD(wParam); // ...different for Win32! <br> <br>    //Parse the menu selections: <br>    switch (wmId) { <br>         // File Menu Item <br>        case IDM_NEW: <br>        case IDM_OPEN: <br>        case IDM_SAVE: <br>        case IDM_SAVEAS: <br>           return (DefWindowProc(hWnd, WM_COMMAND, wParam, lParam)); <br> <br>        case IDM_EXIT: <br>           DestroyWindow (hWnd); <br>           return ERROR_SUCCESS; <br> <br>        // configure menu item <br>        case IDM_ADD_COUNTERS: <br>            return On_IDM_ADD_COUNTERS (hWnd, wParam, lParam); <br> <br>        case IDM_CLEAR_ALL: <br>            return On_IDM_CLEAR_ALL (hWnd, wParam, lParam); <br> <br>        // get data menu item <br>        case IDM_GET_DATA: <br>           return On_IDM_GET_DATA (hWnd, wParam, lParam); <br> <br> <br>        // Help Menu Item <br>        case IDM_HELPTOPICS:  <br>           lstrcpy (szHelpFileName, APPNAME); <br>           lstrcat (szHelpFileName, ".HLP"); <br>           bGotHelp = WinHelp (hWnd, szHelpFileName, HELP_FINDER,(DWORD)0); <br>           if (!bGotHelp) <br>           { <br>              MessageBox (GetFocus(), GetStringRes(IDS_NO_HELP), <br>                          APPNAME, MB_OK|MB_ICONHAND); <br>           } <br>           return ERROR_SUCCESS; <br> <br>        case IDM_ABOUT: <br>           DialogBox((HINSTANCE)(GetWindowLong(hWnd, GWL_HINSTANCE)),  <br>               "AboutBox", hWnd, (DLGPROC)About); <br>           return ERROR_SUCCESS; <br> <br>        default: <br>           return (DefWindowProc(hWnd, WM_COMMAND, wParam, lParam)); <br>    } <br>} <br>  <br>static LRESULT <br>On_WM_RBUTTONDOWN ( <br>    HWND hWnd, <br>    WPARAM wParam, <br>    LPARAM lParam) <br>{ <br>    POINT pnt; <br>    HMENU hMenu; <br> <br>    pnt.x = LOWORD(lParam); <br>    pnt.y = HIWORD(lParam); <br>    ClientToScreen(hWnd, (LPPOINT) &amp;pnt); <br>    // This is where you would determine the appropriate 'context' <br>    // menu to bring up. Since this app has no real functionality, <br>    // we will just bring up the 'configure' menu: <br>    hMenu = GetSubMenu (GetMenu (hWnd), 1); <br>    if (hMenu) { <br>        TrackPopupMenu (hMenu, 0, pnt.x, pnt.y, 0, hWnd, NULL); <br>    } else { <br>    // Couldn't find the menu... <br>        MessageBeep(0); <br>    } <br> <br>    return ERROR_SUCCESS; <br>} <br>  <br>static LRESULT <br>On_WM_PAINT ( <br>    HWND hWnd, <br>    WPARAM wParam, <br>    LPARAM lParam) <br>{ <br>    PAINTSTRUCT ps; <br>    HDC hdc; <br>    PCIB    pCib; <br>    int     nX, nY; <br>    LONG    lTextOutReturn; <br>    char    szOutputString[MAX_PATH]; <br>    int     nStringLength; <br> <br>    hdc = BeginPaint (hWnd, &amp;ps); <br> <br>    nX = 0; <br>    nY = 0; <br>    // draw Title text <br>    lstrcpy (szOutputString, "Performance Counter\tLast Value\tMinimum\tMaximum\tAverage"); <br>    nStringLength = lstrlen(szOutputString) * sizeof(TCHAR); <br>    lTextOutReturn = TabbedTextOut (hdc, nX, nY, <br>        szOutputString, nStringLength, <br>        nNumTabStops, nTabStops, 0); <br>    nY += HIWORD(lTextOutReturn); <br> <br>    // select the fine print font for this window <br>    SelectObject(hdc, hFinePrint); <br> <br>    // for each CIB in the list draw the current text and value <br>    for (pCib = pFirstCib; pCib != NULL; pCib = pCib-&gt;pNext) { <br>        nStringLength = sprintf (szOutputString, "%s\t%f\t%f\t%f\t%f", <br>            pCib-&gt;szCounterPath, pCib-&gt;dLastValue, <br>            pCib-&gt;pdhCurrentStats.min.doubleValue,  <br>            pCib-&gt;pdhCurrentStats.max.doubleValue, <br>            pCib-&gt;pdhCurrentStats.mean.doubleValue); <br>        lTextOutReturn = TabbedTextOut (hdc, nX, nY, <br>            szOutputString, nStringLength, <br>            nNumTabStops, nTabStops, 0); <br>        nY += HIWORD(lTextOutReturn); <br>    } <br> <br>    EndPaint (hWnd, &amp;ps); <br>    return ERROR_SUCCESS; <br>} <br>  <br>static LRESULT <br>On_WM_DESTROY ( <br>    HWND hWnd, <br>    WPARAM wParam, <br>    LPARAM lParam) <br>{ <br>     char szHelpFileName[MAX_PATH]; <br> <br>     lstrcpy (szHelpFileName, APPNAME); <br>     lstrcat (szHelpFileName, ".HLP"); <br>     // Tell WinHelp we don't need it any more... <br>     WinHelp (hWnd, szHelpFileName, HELP_QUIT,(DWORD)0); <br> <br>     DeleteAllCounters(); <br> <br>     PostQuitMessage(0); <br>     return ERROR_SUCCESS; <br>} <br>  <br>//  FUNCTION: WndProc(HWND, unsigned, WORD, LONG) <br>// <br>//  PURPOSE:  Processes messages for the main window. <br>// <br>//  MESSAGES: <br>// <br>//    WM_COMMAND - process the application menu <br>//    WM_PAINT - Paint the main window <br>//    WM_DESTROY - post a quit message and return <br>//    WM_RBUTTONDOWN - Right mouse click -- put up context menu here if appropriate <br>// <br>// <br>LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam) <br>{ <br>    switch (message) { <br>        case WM_CREATE: <br>            return On_WM_CREATE (hWnd, wParam, lParam); <br> <br>        case WM_COMMAND: <br>            return On_WM_COMMAND (hWnd, wParam, lParam); <br> <br>        case WM_RBUTTONDOWN: // RightClick in windows client area... <br>            return On_WM_RBUTTONDOWN (hWnd, wParam, lParam); <br>            <br>        case WM_PAINT: <br>            return On_WM_PAINT (hWnd, wParam, lParam); <br> <br>        case WM_DESTROY: <br>            return On_WM_DESTROY (hWnd, wParam, lParam); <br> <br>        default: <br>            return (DefWindowProc(hWnd, message, wParam, lParam)); <br>   } <br>   return (0); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
