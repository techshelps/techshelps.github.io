<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DLLINIT.C</title>
<link disabled rel=stylesheet href=../../../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6262"></a>DLLINIT.C</h2>
<pre><code>/*++ <br> <br>Copyright (c) 1990  Microsoft Corporation <br> <br>Module Name: <br> <br>    dllinit.c <br> <br>Abstract: <br> <br>    This module contians the DLL attach/detach event entry point for <br>    the Application memory usage performance DLL. <br> <br>    When the dll is opened by the calling application. The initialization <br>    function (DllProcessAttach) opens or creates the shared memory file <br>    that is used to communicate data from the application to the performance <br>    monitor extensible counter DLL. This shared memory file is used by all <br>    applications that have been compiled to provide the memory statistics. <br> <br>    The shared memory file is formatted by the first application to <br>    create it. The format of the memory is a data header (at the base <br>    of the address space) followed by an array of APPMEM_INSTANCE structures. <br>    The APPMEM_INSTANCE structures are managed as two linked lists: a <br>    Free List and an InUse List. The pointers to the first entry in each <br>    list are maintained in the data header structure. As applications are <br>    started, the first item in the Free list is moved to the InUse List <br>    and as applications finish with the data block, their entries are moved <br>    back to the Head of the Free List. All operations on the data in <br>    this shared memory file are protected by a mutex such that only <br>    one process can read or write to the file at a time. <br> <br>    Note that references are by offset from the base of the memory <br>    block not absolute virtual addresses. This is because the same <br>    shared memory file may be mapped to different addresses in <br>    different processes making a virtual address valid within the <br>    context of a single process only. <br> <br>Author: <br> <br>    Bob Watson (a-robw) Aug 95 <br> <br>Revision History: <br> <br>--*/ <br> <br>#include &lt;windows.h&gt; <br>#include "appmema.h" <br> <br>HANDLE ThisDLLHandle = NULL; <br> <br>HANDLE  hAppMemSharedMemory = NULL;// Handle of counter Shared Memory <br>HANDLE  hAppMemMutex = NULL;            // sync mutex for memory <br> <br>PAPPMEM_DATA_HEADER pDataHeader = NULL; // pointer to header of shared mem <br>PAPPMEM_INSTANCE    pAppData = NULL;    // pointer to the app data for this app <br>  <br>static <br>BOOL <br>TrimProcessName ( <br>    LPCWSTR  wcszLongName, <br>    LPWSTR  wcszShortName <br>) <br>/*++ <br> <br>Description: <br> <br>    strips the leading directory path and trailing file extension from the <br>    input path string to return the base filename. <br> <br>Arguments: <br> <br>    wcszLongName    pointer to a Wide Character string containing the <br>                    process's image file path name <br> <br>    wcszShortName   buffer to receive the "short" version of the image <br>                    file name, i.e. the base file name with no extension or <br>                    directory path. <br> <br>NOTE: the buffer size is not checked!!! The caller must guarantee sufficient <br>    space for the conversion. <br> <br>Return Value: <br> <br>    TRUE if name trimmed successfully <br>    FALSE if error <br> <br>--*/ <br>{ <br>    DWORD   dwLength; <br>    LPWSTR  pSlash; <br>    LPWSTR  pPeriod; <br>    LPWSTR  pThisChar; <br>    LPWSTR  pSrc, pDest; <br>    WORD    wThisChar; <br> <br>    // validate the input arguments <br>    if ((wcszLongName == NULL) || (wcszShortName == 0)) { <br>        return FALSE; <br>    } <br> <br>    // get the length of the string passed in  <br>    dwLength = lstrlenW (wcszLongName); <br> <br>    if (*wcszLongName &gt; 0) {   // some name has been passed in <br> <br>        pSlash =  <br>         pPeriod = <br>         pThisChar = (LPWSTR)wcszLongName; <br>        wThisChar = 0; <br> <br>        // <br>        //  go from beginning to end and find last backslash and <br>        //  last period in name <br>        // <br> <br>        while (*pThisChar != 0) { // go until null <br>            if (*pThisChar == L'\\') { <br>                pSlash = pThisChar; <br>            } else if (*pThisChar == L'.') { <br>                pPeriod = pThisChar; <br>            } <br>            pThisChar++;    // point to next char <br>            wThisChar++; <br>            if ((DWORD)wThisChar &gt;= dwLength) { <br>                break; <br>            } <br>        } <br> <br>        // if pPeriod is still pointing to the beginning of the <br>        // string, then no period was found <br> <br>        if (pPeriod == (LPWSTR)wcszLongName) { <br>            pPeriod = pThisChar; // set to end of string; <br>        } else { <br>            // if a period was found, then see if the extension is <br>            // .EXE, if so leave it, if not, then use end of string <br>            // (i.e. include extension in name) <br> <br>            if (lstrcmpiW(pPeriod, L".EXE") != 0) { <br>                pPeriod = pThisChar; <br>            } <br>        } <br> <br>        if (pSlash != wcszLongName) { <br>            pSlash++; // point to first char past slash <br>        } <br> <br>        // copy characters between period (or end of string) and <br>        // slash (or start of string) to make image name <br> <br>        pSrc = pSlash; <br>        pDest = wcszShortName; <br> <br>        while (pSrc &lt; pPeriod) { <br>            *pDest++ = *pSrc++; <br>        } <br>        *pDest = 0; <br>    } <br>    return TRUE; <br>} <br>  <br>static <br>BOOL <br>DllProcessAttach ( <br>    IN  HANDLE DllHandle <br>) <br>/*++ <br> <br>Description: <br> <br>    Initializes the interface to the performance counters DLL by <br>    opening the Shared Memory file used to communicate statistics <br>    from the application to the counter DLL. If the Shared memory <br>    file does not exist, it is created, formatted and initialized. <br>    If the file has already been created and formatted, then the <br>    next available APPMEM_INSTANCE entry is moved from the free list <br>    to the InUse list and the corresponding pointer is saved for <br>    subsequent use by this application <br>    <br>--*/ <br>{ <br>    LONG    status; <br>    TCHAR   szMappedObject[] = SHARED_MEMORY_OBJECT_NAME; <br>    WCHAR   szLongName[MAX_PATH]; <br> <br>    // save this DLL handle <br>    ThisDLLHandle = DllHandle; <br> <br>    // disable thread attach &amp; detach calls to save the overhead <br>    // since we don't care about them. <br>    DisableThreadLibraryCalls (DllHandle); <br> <br>    // open &amp; initialize shared memory file <br>    SetLastError (ERROR_SUCCESS);   // just to clear it out <br> <br>    // open/create shared memory used by the application to pass performance values <br>    status = GetSharedMemoryDataHeader ( <br>        &amp;hAppMemSharedMemory, &amp;hAppMemMutex, &amp;pDataHeader, <br>        FALSE); // read/write access is required <br>    // here the memory block should be initialized and ready for use <br>    if (status == ERROR_SUCCESS) { <br>        if (pDataHeader-&gt;dwFirstFreeOffset != 0) { <br>            // then there are blocks left so get the next free <br>            pAppData = FIRST_FREE(pDataHeader); <br>            // update free list to make next item the first in list <br>            pDataHeader-&gt;dwFirstFreeOffset = pAppData-&gt;dwOffsetOfNext; <br> <br>            // insert the new item into the head of the in use list <br>            pAppData-&gt;dwOffsetOfNext = pDataHeader-&gt;dwFirstInUseOffset; <br>            pDataHeader-&gt;dwFirstInUseOffset = (DWORD)((LPBYTE)pAppData - <br>                                                        (LPBYTE)pDataHeader); <br> <br>            // now initialize this instance's data <br>            pAppData-&gt;dwProcessId = GetCurrentProcessId(); <br>            pAppData-&gt;hProcessHeap = NULL; <br> <br>            pAppData-&gt;dwApplicationBytes = 0; <br>            pAppData-&gt;dwAllocCalls = 0; <br>            pAppData-&gt;dwReAllocCalls = 0; <br>            pAppData-&gt;dwFreeCalls = 0; <br>            pAppData-&gt;dwReserved1 = 0; <br>            pAppData-&gt;dwReserved2 = 0; <br> <br>            GetModuleFileNameW (NULL, <br>                szLongName, MAX_PATH); <br> <br>            TrimProcessName ( <br>                szLongName, <br>                pAppData-&gt;wcszInstanceName); <br> <br>            pDataHeader-&gt;dwInstanceCount++;    // increment count <br>        } else { <br>            // no more free slots left <br>        } <br>    } else { <br>        // unable to open shared memory file <br>        // even though this is an error we should return true so as to  <br>        // not abort the application. No performance data will be  <br>        // collected though. <br>    } <br>    return TRUE; <br>} <br>  <br>static <br>BOOL <br>DllProcessDetach ( <br>    IN  HANDLE DllHandle <br>) <br>{ <br>    BOOL    bFreeMutex; <br>    PAPPMEM_INSTANCE    pPrevItem; <br> <br>    // remove instance for this app <br>    if ((pAppData != NULL) &amp;&amp; (pDataHeader != NULL)) { <br>        // lock memory block <br>        if (hAppMemMutex != NULL) { <br>            if (WaitForSingleObject (hAppMemMutex, SHARED_MEMORY_MUTEX_TIMEOUT) == WAIT_FAILED) { <br>                // unable to obtain a lock <br>                bFreeMutex = FALSE; <br>            } else { <br>                bFreeMutex = TRUE; <br>            } <br>        } else { <br>            bFreeMutex = FALSE; <br>        } <br>        // zero the fields out first <br>        pAppData-&gt;dwProcessId = 0; <br>        pAppData-&gt;hProcessHeap = NULL; <br>        pAppData-&gt;dwApplicationBytes = 0; <br>        pAppData-&gt;dwAllocCalls = 0; <br>        pAppData-&gt;dwReAllocCalls = 0; <br>        pAppData-&gt;dwFreeCalls = 0; <br>        memset (&amp;pAppData-&gt;wcszInstanceName[0], 0, (MAX_SIZEOF_INSTANCE_NAME * sizeof (WCHAR))); <br>        pAppData-&gt;dwReserved1 = 0; <br>        pAppData-&gt;dwReserved2 = 0; <br>        // move from in use (busy) list back to the free list <br>        if ((pDataHeader-&gt;dwFirstFreeOffset != 0) &amp;&amp; (pDataHeader-&gt;dwFirstInUseOffset != 0)) { <br>            // find previous item in busy list <br>            if (FIRST_INUSE(pDataHeader) != pAppData) { <br>                // not the first so walk down the list <br>                pPrevItem = FIRST_INUSE(pDataHeader); <br>                while (APPMEM_INST(pDataHeader, pPrevItem-&gt;dwOffsetOfNext) != pAppData) { <br>                    pPrevItem = APPMEM_INST(pDataHeader, pPrevItem-&gt;dwOffsetOfNext); <br>                    if (pPrevItem-&gt;dwOffsetOfNext == 0) break; // end of list <br>                } <br>                if (APPMEM_INST(pDataHeader, pPrevItem-&gt;dwOffsetOfNext) == pAppData) { <br>                    APPMEM_INST(pDataHeader, pPrevItem-&gt;dwOffsetOfNext)-&gt;dwOffsetOfNext = <br>                        pAppData-&gt;dwOffsetOfNext; <br>                } else { <br>                    // it was never in the busy list (?!?) <br>                } <br>            } else { <br>                // this is the first in the list so update it <br>                pDataHeader-&gt;dwFirstInUseOffset = pAppData-&gt;dwOffsetOfNext; <br>            } <br>            // here, pAppData has been removed from the InUse list and now <br>            // it must be inserted back at the beginning of the free list <br>            pAppData-&gt;dwOffsetOfNext = pDataHeader-&gt;dwFirstFreeOffset; <br>            pDataHeader-&gt;dwFirstFreeOffset = (DWORD)((LPBYTE)pAppData - (LPBYTE)pDataHeader); <br>        } <br>    } <br> <br>    // decrement instance counter <br>    pDataHeader-&gt;dwInstanceCount--;    // decrement count <br> <br>    if (bFreeMutex) { <br>        ReleaseMutex (hAppMemMutex); <br>    } <br> <br>    // close shared memory file handle <br> <br>    if (hAppMemSharedMemory != NULL) CloseHandle (hAppMemSharedMemory); <br>    if (hAppMemMutex != NULL)       CloseHandle(hAppMemMutex); <br> <br>    // clear pointers <br>    hAppMemSharedMemory = NULL; <br>    pDataHeader = NULL; <br>    pAppData = NULL; <br> <br>    return TRUE; <br>} <br>  <br>BOOL <br>__stdcall <br>DllInit( <br>    IN HANDLE DLLHandle, <br>    IN DWORD  Reason, <br>    IN LPVOID ReservedAndUnused <br>) <br>{ <br>    ReservedAndUnused; <br> <br>    switch(Reason) { <br>        case DLL_PROCESS_ATTACH: <br>            return DllProcessAttach (DLLHandle); <br> <br>        case DLL_PROCESS_DETACH: <br>            return DllProcessDetach (DLLHandle); <br> <br>        case DLL_THREAD_ATTACH: <br>        case DLL_THREAD_DETACH: <br>            return TRUE; <br>    } <br>} <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
