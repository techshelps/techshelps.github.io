<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>PERFGEN.C</title>
<link disabled rel=stylesheet href=../../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6280"></a>PERFGEN.C</h2>
<pre><code>/*++  <br> <br>Copyright (c) 1995-6  Microsoft Corporation <br> <br>Module Name: <br> <br>    perfgen.c <br> <br>Abstract: <br> <br>    This file implements an Extensible Performance Object that displays <br>    generated signals <br> <br>Created:     <br> <br>    Bob Watson  28-Jul-1995 <br> <br>Revision History <br> <br> <br>--*/ <br> <br>// <br>//  Include Files <br>// <br> <br>#include &lt;windows.h&gt; <br>#include &lt;string.h&gt; <br>#include &lt;winperf.h&gt; <br>#include &lt;math.h&gt; <br>#include "genctrs.h" // error message definition <br>#include "perfmsg.h" <br>#include "perfutil.h" <br>#include "datagen.h" <br> <br>//  define constant value counter's value here, any number will do. <br> <br>#define CONSTANT_VALUE_VALUE    49 <br>// <br>//  References to constants which initialize the Object type definitions <br>// <br> <br>extern SIGGEN_DATA_DEFINITION SigGenDataDefinition; <br>     <br>DWORD   dwOpenCount = 0;        // count of "Open" threads <br>BOOL    bInitOK = FALSE;        // true = DLL initialized OK <br> <br>// <br>//  Function Prototypes <br>// <br>//      these are used to insure that the data collection functions <br>//      accessed by Perflib will have the correct calling format. <br>// <br> <br>PM_OPEN_PROC    OpenSigGenPerformanceData; <br>PM_COLLECT_PROC CollectSigGenPerformanceData; <br>PM_CLOSE_PROC   CloseSigGenPerformanceData; <br> <br>typedef struct _WAVE_DATA { <br>    DWORD   dwPeriod; <br>    DWORD   dwAmplitude; <br>    LPWSTR  szInstanceName; <br>} WAVE_DATA, *PWAVE_DATA; <br> <br>static WAVE_DATA wdInstance[]  = <br>{ <br>    {1000,      100, L"  1 Second"}, <br>    {10000,     100, L" 10 Second"}, <br>    {20000,     100, L" 20 Second"}, <br>    {50000,     100, L" 50 Second"}, <br>    {100000,    100, L"100 Second"} <br>}; <br> <br>static const DWORD    NUM_INSTANCES =  <br>    (sizeof(wdInstance)/sizeof(wdInstance[0])); <br> <br>static double   dPi = 3.1415926590; <br>static double   d2Pi = 2.0 * 3.1415926590; <br> <br>  <br>static <br>DWORD <br>GetTimeInMilliSeconds () <br>{ <br>    SYSTEMTIME  st; <br>    DWORD       dwReturn; <br> <br>    GetSystemTime (&amp;st); <br>    dwReturn = (DWORD)st.wMilliseconds; <br>    dwReturn += (DWORD)st.wSecond * 1000L; <br>    dwReturn += (DWORD)st.wMinute * 60000L; <br>    dwReturn += (DWORD)st.wHour * 3600000L; <br>    dwReturn += (DWORD)st.wDay * 86500000L; <br> <br>    // that's good enough for what it's for <br> <br>    return dwReturn; <br>} <br>  <br>DWORD APIENTRY <br>OpenSigGenPerformanceData( <br>    LPWSTR lpDeviceNames <br>    ) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    This routine will initialize the data structures used to pass <br>    data back to the registry <br> <br>Arguments: <br> <br>    Pointer to object ID of each device to be opened (PerfGen) <br> <br>Return Value: <br> <br>    None. <br> <br>--*/ <br> <br>{ <br>    LONG status; <br>    HKEY hKeyDriverPerf; <br>    DWORD size; <br>    DWORD type; <br>    DWORD dwFirstCounter; <br>    DWORD dwFirstHelp; <br> <br>    // <br>    //  Since WINLOGON is multi-threaded and will call this routine in <br>    //  order to service remote performance queries, this library <br>    //  must keep track of how many times it has been opened (i.e. <br>    //  how many threads have accessed it). the registry routines will <br>    //  limit access to the initialization routine to only one thread  <br>    //  at a time so synchronization (i.e. reentrancy) should not be  <br>    //  a problem <br>    // <br> <br>    if (!dwOpenCount) { <br>        // open Eventlog interface <br> <br>        hEventLog = MonOpenEventLog(); <br> <br>        // get counter and help index base values from registry <br>        //      Open key to registry entry <br>        //      read First Counter and First Help values <br>        //      update static data strucutures by adding base to  <br>        //          offset value in structure. <br> <br>        status = RegOpenKeyEx ( <br>            HKEY_LOCAL_MACHINE, <br>        "SYSTEM\\CurrentControlSet\\Services\\PerfGen\\Performance", <br>            0L, <br>        KEY_READ, <br>            &amp;hKeyDriverPerf); <br> <br>        if (status != ERROR_SUCCESS) { <br>            REPORT_ERROR_DATA (GENPERF_UNABLE_OPEN_DRIVER_KEY, LOG_USER, <br>                &amp;status, sizeof(status)); <br>            // this is fatal, if we can't get the base values of the  <br>            // counter or help names, then the names won't be available <br>            // to the requesting application  so there's not much <br>            // point in continuing. <br>            goto OpenExitPoint; <br>        } <br> <br>        size = sizeof (DWORD); <br>        status = RegQueryValueEx( <br>                    hKeyDriverPerf,  <br>            "First Counter", <br>                    0L, <br>                    &amp;type, <br>                    (LPBYTE)&amp;dwFirstCounter, <br>                    &amp;size); <br> <br>        if (status != ERROR_SUCCESS) { <br>            REPORT_ERROR_DATA (GENPERF_UNABLE_READ_FIRST_COUNTER, LOG_USER, <br>                &amp;status, sizeof(status)); <br>            // this is fatal, if we can't get the base values of the  <br>            // counter or help names, then the names won't be available <br>            // to the requesting application  so there's not much <br>            // point in continuing. <br>            goto OpenExitPoint; <br>        } <br> <br>        size = sizeof (DWORD); <br>        status = RegQueryValueEx( <br>                    hKeyDriverPerf,  <br>            "First Help", <br>                    0L, <br>                    &amp;type, <br>                    (LPBYTE)&amp;dwFirstHelp, <br>    &amp;size); <br> <br>        if (status != ERROR_SUCCESS) { <br>            REPORT_ERROR_DATA (GENPERF_UNABLE_READ_FIRST_HELP, LOG_USER, <br>                &amp;status, sizeof(status)); <br>            // this is fatal, if we can't get the base values of the  <br>            // counter or help names, then the names won't be available <br>            // to the requesting application  so there's not much <br>            // point in continuing. <br>            goto OpenExitPoint; <br>        } <br>  <br>        // <br>        //  NOTE: the initialization program could also retrieve <br>        //      LastCounter and LastHelp if they wanted to do  <br>        //      bounds checking on the new number. e.g. <br>        // <br>        //      counter-&gt;CounterNameTitleIndex += dwFirstCounter; <br>        //      if (counter-&gt;CounterNameTitleIndex &gt; dwLastCounter) { <br>        //          LogErrorToEventLog (INDEX_OUT_OF_BOUNDS); <br>        //      } <br> <br>        SigGenDataDefinition.SigGenObjectType.ObjectNameTitleIndex += dwFirstCounter; <br>        SigGenDataDefinition.SigGenObjectType.ObjectHelpTitleIndex += dwFirstHelp; <br> <br>        // assign index of default counter (Sine Wave) <br>        SigGenDataDefinition.SigGenObjectType.DefaultCounter = 0; <br> <br>        SigGenDataDefinition.SineWaveDef.CounterNameTitleIndex += dwFirstCounter; <br>        SigGenDataDefinition.SineWaveDef.CounterHelpTitleIndex += dwFirstHelp; <br> <br>        SigGenDataDefinition.TriangleWaveDef.CounterNameTitleIndex += dwFirstCounter; <br>        SigGenDataDefinition.TriangleWaveDef.CounterHelpTitleIndex += dwFirstHelp; <br> <br>        SigGenDataDefinition.SquareWaveDef.CounterNameTitleIndex += dwFirstCounter; <br>        SigGenDataDefinition.SquareWaveDef.CounterHelpTitleIndex += dwFirstHelp; <br> <br>        SigGenDataDefinition.ConstantValueDef.CounterNameTitleIndex += dwFirstCounter; <br>        SigGenDataDefinition.ConstantValueDef.CounterHelpTitleIndex += dwFirstHelp; <br> <br>        RegCloseKey (hKeyDriverPerf); // close key to registry <br> <br>        bInitOK = TRUE; // ok to use this function <br>    } <br> <br>    dwOpenCount++;  // increment OPEN counter <br> <br>    status = ERROR_SUCCESS; // for successful exit <br> <br>OpenExitPoint: <br> <br>    return status; <br>} <br> <br>  <br>DWORD APIENTRY <br>CollectSigGenPerformanceData( <br>    IN      LPWSTR  lpValueName, <br>    IN OUT  LPVOID  *lppData, <br>    IN OUT  LPDWORD lpcbTotalBytes, <br>    IN OUT  LPDWORD lpNumObjectTypes <br>) <br>/*++ <br> <br>Routine Description: <br> <br>    This routine will return the data for the Signal Generator counters. <br> <br>Arguments: <br> <br>   IN       LPWSTR   lpValueName <br>         pointer to a wide character string passed by registry. <br> <br>   IN OUT   LPVOID   *lppData <br>         IN: pointer to the address of the buffer to receive the completed  <br>            PerfDataBlock and subordinate structures. This routine will <br>            append its data to the buffer starting at the point referenced <br>            by *lppData. <br>         OUT: points to the first byte after the data structure added by this <br>            routine. This routine updated the value at lppdata after appending <br>            its data. <br> <br>   IN OUT   LPDWORD  lpcbTotalBytes <br>         IN: the address of the DWORD that tells the size in bytes of the  <br>            buffer referenced by the lppData argument <br>         OUT: the number of bytes added by this routine is writted to the  <br>            DWORD pointed to by this argument <br> <br>   IN OUT   LPDWORD  NumObjectTypes <br>         IN: the address of the DWORD to receive the number of objects added  <br>            by this routine  <br>         OUT: the number of objects added by this routine is writted to the  <br>            DWORD pointed to by this argument <br> <br>Return Value: <br> <br>      ERROR_MORE_DATA if buffer passed is too small to hold data <br>         any error conditions encountered are reported to the event log if <br>         event logging is enabled. <br> <br>      ERROR_SUCCESS  if success or any other error. Errors, however are <br>         also reported to the event log. <br> <br>--*/ <br>{ <br>    //  Variables for reformating the data <br> <br>    PERF_INSTANCE_DEFINITION *pPerfInstanceDefinition; <br>    DWORD   dwThisInstance; <br>    ULONG SpaceNeeded; <br>    SIGGEN_DATA_DEFINITION *pSigGenDataDefinition; <br>    DWORD   dwQueryType; <br>    DWORD   dwTime; <br>    DWORD   dwPhase; <br>    double  dPhase, dSin; <br>    LONG    lValue; <br>    PSIGGEN_COUNTER   pSC; <br> <br>    // <br>    // before doing anything else, see if Open went OK <br>    // <br>    if (!bInitOK) { <br>        // unable to continue because open failed. <br>    *lpcbTotalBytes = (DWORD) 0; <br>    *lpNumObjectTypes = (DWORD) 0; <br>        return ERROR_SUCCESS; // yes, this is a successful exit <br>    } <br>     <br>    // see if this is a foreign (i.e. non-NT) computer data request  <br>    // <br>    dwQueryType = GetQueryType (lpValueName); <br>     <br>    if (dwQueryType == QUERY_FOREIGN) { <br>        // this routine does not service requests for data from <br>        // Non-NT computers <br>    *lpcbTotalBytes = (DWORD) 0; <br>    *lpNumObjectTypes = (DWORD) 0; <br>        return ERROR_SUCCESS; <br>    } <br> <br>    if (dwQueryType == QUERY_ITEMS){ <br>if ( !(IsNumberInUnicodeList (SigGenDataDefinition.SigGenObjectType.ObjectNameTitleIndex, lpValueName))) { <br>            // request received for data object not provided by this routine <br>            *lpcbTotalBytes = (DWORD) 0; <br>        *lpNumObjectTypes = (DWORD) 0; <br>            return ERROR_SUCCESS; <br>        } <br>    } <br> <br>    pSigGenDataDefinition = (SIGGEN_DATA_DEFINITION *) *lppData; <br> <br>    SpaceNeeded = sizeof(SIGGEN_DATA_DEFINITION) + <br>          (NUM_INSTANCES * (sizeof(PERF_INSTANCE_DEFINITION) + <br>          (24) +    // size of instance names <br>          sizeof (SIGGEN_COUNTER))); <br> <br>    if ( *lpcbTotalBytes &lt; SpaceNeeded ) { <br>    *lpcbTotalBytes = (DWORD) 0; <br>    *lpNumObjectTypes = (DWORD) 0; <br>        return ERROR_MORE_DATA; <br>    } <br> <br>    // Get current time for this sample <br>    // <br>    dwTime = GetTimeInMilliSeconds(); <br>    // <br>    // Copy the (constant, initialized) Object Type and counter definitions <br>    //  to the caller's data buffer <br>    // <br>    memmove(pSigGenDataDefinition, <br>   &amp;SigGenDataDefinition, <br>   sizeof(SIGGEN_DATA_DEFINITION)); <br>    // <br>    //Create data for return for each instance <br>    // <br>    pPerfInstanceDefinition = (PERF_INSTANCE_DEFINITION *) <br>                                 &amp;pSigGenDataDefinition[1]; <br> <br>    for (dwThisInstance = 0; dwThisInstance &lt; NUM_INSTANCES; dwThisInstance++) { <br> <br>        MonBuildInstanceDefinition( <br>            pPerfInstanceDefinition, <br>            (PVOID *)&amp;pSC, <br>            0, <br>            0, <br>            (DWORD)-1, // use name <br>            wdInstance[dwThisInstance].szInstanceName); <br> <br>        pSC-&gt;CounterBlock.ByteLength = sizeof (SIGGEN_COUNTER); <br> <br>        //********************************************************** <br>        // <br>        // for this particular example, the data is "created" here. <br>        // normally it would be read from the appropriate device or  <br>        // application program. <br>        // <br>        //********************************************************** <br>     <br>        // comput phase for this instance period <br>        dwPhase = dwTime % wdInstance[dwThisInstance].dwPeriod; <br>        // <br>        // compute sinewave value here <br>        // <br>        dPhase = (double)dwPhase / (double)wdInstance[dwThisInstance].dwPeriod; <br>        dPhase *= d2Pi; <br> <br>        // the cosine function is used to keep the phase aligned with the <br>        // other wave forms <br>        dSin = -cos(dPhase); <br>        // adjust amplitude and add .5 to round to integer correctly <br>        dSin *= (double)((wdInstance[dwThisInstance].dwAmplitude) / 2.0) + 0.5 ; <br>     <br>        lValue = (LONG)dSin; <br>        lValue += wdInstance[dwThisInstance].dwAmplitude / 2;   // to move negative values above 0 <br> <br>        // save sine value <br>        pSC-&gt;dwSineWaveValue = (DWORD)lValue; <br> <br>        // compute triangle wave value here <br> <br>        if (dwPhase &lt; (wdInstance[dwThisInstance].dwPeriod / 2)) { <br>            lValue = (LONG)((dwPhase * wdInstance[dwThisInstance].dwAmplitude) / (wdInstance[dwThisInstance].dwPeriod / 2)); <br>        } else { <br>            lValue = (LONG)(((wdInstance[dwThisInstance].dwPeriod - dwPhase) * wdInstance[dwThisInstance].dwAmplitude) / <br>                    (wdInstance[dwThisInstance].dwPeriod / 2)); <br>        } <br>        // save triangle value <br>        pSC-&gt;dwTriangleWaveValue = (DWORD) lValue; <br> <br>        // <br>        //  compute square wave value <br>        // <br>        if (dwPhase &lt;= (wdInstance[dwThisInstance].dwPeriod / 2)) { <br>            lValue = 0; <br>        } else { <br>            lValue = (LONG)wdInstance[dwThisInstance].dwAmplitude; <br>        } <br>        // save square value <br>        pSC-&gt;dwSquareWaveValue = (DWORD) lValue; <br> <br>        // finally the constant value (same fore every instance) <br>        pSC-&gt;dwConstantValue = (DWORD)CONSTANT_VALUE_VALUE; <br> <br>        // update instance pointer for next instance <br>        pPerfInstanceDefinition = (PERF_INSTANCE_DEFINITION *)&amp;pSC[1]; <br>    } <br>    // update arguments for return <br> <br>    *lppData = (PVOID)pPerfInstanceDefinition; <br>     <br>    *lpNumObjectTypes = 1; <br> <br>    pSigGenDataDefinition-&gt;SigGenObjectType.TotalByteLength =  <br>        *lpcbTotalBytes = (PBYTE)pPerfInstanceDefinition - <br>                          (PBYTE) pSigGenDataDefinition; <br> <br>    // update instance count <br>    pSigGenDataDefinition-&gt;SigGenObjectType.NumInstances = NUM_INSTANCES; <br>     <br>    return ERROR_SUCCESS; <br>} <br> <br>  <br>DWORD APIENTRY <br>CloseSigGenPerformanceData( <br>) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    This routine closes the open handles to the Signal Gen counters. <br> <br>Arguments: <br> <br>    None. <br> <br> <br>Return Value: <br> <br>    ERROR_SUCCESS <br> <br>--*/ <br> <br>{ <br>    if (!(--dwOpenCount)) { // when this is the last thread... <br> <br>        MonCloseEventLog(); <br>    } <br> <br>    return ERROR_SUCCESS; <br> <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
