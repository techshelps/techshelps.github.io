<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SHAREMEM.C</title>
<link disabled rel=stylesheet href=../../../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6270"></a>SHAREMEM.C</h2>
<pre><code>/*++ <br> <br>    Copyright (c) 1996 -- Microsoft Corporation. <br> <br>    sharemem.c <br> <br>    shared memory functions used by both application and performance <br>    dlls <br> <br>--*/ <br>// <br>//  Include Files <br>// <br>#include &lt;windows.h&gt; <br>#include &lt;string.h&gt; <br>#include &lt;winperf.h&gt; <br>#include "..\inc\appmemi.h"     // definitions shared with the app. dll <br>#include "memctrs.h"            // error message definition <br> <br>LONG <br>_stdcall <br>GetSharedMemoryDataHeader ( <br>    IN  HANDLE              *phAppMemSharedMemory, <br>    IN  HANDLE              *phAppMemMutex, <br>    IN  PAPPMEM_DATA_HEADER *pHeader, <br>    IN  BOOL                bReadOnlyAccess <br>) <br>{ <br>    LONG    Status, MemStatus; <br>    TCHAR   szMappedObject[] = SHARED_MEMORY_OBJECT_NAME; <br>    BOOL    bFreeMutex; <br>    PAPPMEM_INSTANCE    pLastItem; <br>    PAPPMEM_INSTANCE    pAppData; <br>    DWORD   dwInstance; <br> <br>    SetLastError (ERROR_SUCCESS);   // just to clear it out <br> <br>    *phAppMemSharedMemory = CreateFileMapping( <br>                    (HANDLE)0xFFFFFFFF,     // to create a temp file <br>                    NULL,                   // no security <br>                    PAGE_READWRITE,         // to allow read &amp; write access <br>                    0, <br>    SHARED_MEMORY_OBJECT_SIZE,  // file size <br>    szMappedObject);        // object name <br> <br>    MemStatus = GetLastError();    // to see if this is the first opening <br> <br>    // return error if unsuccessful <br>    if (*phAppMemSharedMemory == NULL) { <br>        Status = APPMEM_OPEN_FILE_MAPPING_ERROR; <br>        // this is fatal, if we can't get data then there's no <br>        // point in continuing. <br>    } else { <br>        // the application memory file was created/access successfully <br>        // so we need to get the sync. mutex before we use it <br>        *phAppMemMutex = CreateMutex (NULL, FALSE, SHARED_MEMORY_MUTEX_NAME); <br> <br>        // if successful then wait for ownership, otherwise, <br>        // we'll just take our chances. <br> <br>        if (*phAppMemMutex != NULL) { <br>            if (WaitForSingleObject (*phAppMemMutex, <br>                SHARED_MEMORY_MUTEX_TIMEOUT) == WAIT_FAILED) { <br>                // unable to obtain a lock <br>                bFreeMutex = FALSE; <br>            } else { <br>                bFreeMutex = TRUE; <br>            } <br>        } else { <br>            bFreeMutex = FALSE; <br>        } <br> <br>        if (MemStatus != ERROR_ALREADY_EXISTS) { <br>            // this is the first access to the file so initialize the <br>            // instance count <br>        *pHeader = (PAPPMEM_DATA_HEADER)MapViewOfFile( <br>                            *phAppMemSharedMemory,  // shared mem handle <br>            FILE_MAP_WRITE,         // access desired <br>            0,                      // starting offset <br>            0, <br>            0);                     // map the entire object <br>            if (*pHeader != NULL) { <br>                // if here, then pdwInstanceCount should be valid <br>                // so initialize the shared memory structure <br>                // clear memory block <br>                memset (*pHeader, 0, SHARED_MEMORY_OBJECT_SIZE); <br> <br>                // initialize application data header <br>                (*pHeader)-&gt;dwInstanceCount = 0;       // no instances <br>                (*pHeader)-&gt;dwFirstInUseOffset = 0;    // no busy items yet <br>                (*pHeader)-&gt;dwFirstFreeOffset = <br>                    (DWORD)((LPBYTE)&amp;(*pHeader)[1] - <br>                            (LPBYTE)*pHeader); <br> <br>                pLastItem = FIRST_FREE((*pHeader)); <br> <br>                // set pointers in each item of block <br>                pAppData = pLastItem + 1; <br>                for (dwInstance = (SHARED_MEMORY_ITEM_COUNT -1); dwInstance &gt; 0; dwInstance--) { <br>                    pLastItem-&gt;dwOffsetOfNext = (DWORD)((LPBYTE)pAppData - <br>                                                (LPBYTE)(*pHeader)); <br>                    pLastItem = pAppData; <br>                    pAppData++; <br>                } <br>                pAppData-&gt;dwOffsetOfNext = 0; // end of list <br>                Status = ERROR_SUCCESS; <br>            } else { <br>                Status = APPMEM_UNABLE_MAP_VIEW_OF_FILE; <br>            } <br>        } else { <br>            // the status is ERROR_ALREADY_EXISTS which is successful <br>            Status = ERROR_SUCCESS; <br>        } <br>        // see if Read Only access is required <br>        if (Status == ERROR_SUCCESS) { <br>            // by now the shared memory has already been initialized so <br>            // we if we don't need write access any more or if it has <br>            // already been opened, then open with the desired access <br>        *pHeader = (PAPPMEM_DATA_HEADER)MapViewOfFile( <br>                            *phAppMemSharedMemory,  // shared mem handle <br>            (bReadOnlyAccess ? FILE_MAP_READ : <br>            FILE_MAP_WRITE),    // access desired <br>            0,                      // starting offset <br>            0, <br>            0);                     // map the entire object <br>        if (*pHeader == NULL) { <br>                Status = APPMEM_UNABLE_MAP_VIEW_OF_FILE; <br>                // this is fatal, if we can't get data then there's no <br>                // point in continuing. <br>        } else { <br>                Status = ERROR_SUCCESS; <br>            } <br>        } <br> <br>        // done with the shared memory so free the mutex if one was <br>        // acquired <br> <br>        if (bFreeMutex) { <br>            ReleaseMutex (*phAppMemMutex); <br>        } <br>    } <br>    return Status; <br>} <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
