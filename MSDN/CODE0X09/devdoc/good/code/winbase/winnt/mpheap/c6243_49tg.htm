<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>MPHEAP.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6244"></a>MPHEAP.C</h2>
<pre><code>/*++ <br> <br>Copyright (c) 1995  Microsoft Corporation <br> <br>Module Name: <br> <br>    mpheap.c <br> <br>Abstract: <br> <br>    This DLL is a wrapper that sits on top of the Win32 Heap* api.  It <br>    provides multiple heaps and handles all the serialization itself. <br> <br>    Many multithreaded applications that use the standard memory allocation <br>    routines (malloc/free, LocalAlloc/LocalFree, HeapAlloc/HeapFree) suffer <br>    a significant a significant performance penalty when running on a <br>    multi-processor machine.  This is due to the serialization used by the <br>    default heap package.  On a multiprocessor machine, more than one <br>    thread may simultaneously try to allocate memory.  One thread will <br>    block on the critical section guarding the heap.  The other thread must <br>    then signal the critical section when it is finished to unblock the <br>    waiting thread.  The additional codepath of blocking and signalling adds <br>    significant overhead to the frequent memory allocation path. <br> <br>    By providing multiple heaps, this DLL allows simultaneous operations on <br>    each heap.  A thread on processor 0 can allocate memory from one heap <br>    at the same time that a thread on processor 1 is allocating from a <br>    different heap.  The additional overhead in this DLL is compensated by <br>    drastically reducing the number of times a thread must wait for heap <br>    access. <br> <br>    The basic scheme is to attempt to lock each heap in turn with the new <br>    TryEnterCriticalSection API.  This will enter the critical section if <br>    it is unowned.  If the critical section is owned by a different thread, <br>    TryEnterCriticalSection returns failure instead of blocking until the <br>    other thread leaves the critical section. <br> <br>    Another trick to increase performance is the use of a lookaside list to <br>    satisfy frequent allocations.  By using InterlockedExchange to remove <br>    lookaside list entries and InterlockedCompareExchange to add lookaside <br>    list entries, allocations and frees can be completed without needing a <br>    critical section lock. <br> <br>    The final trick is the use of delayed frees.  If a chunk of memory is <br>    being freed, and the required lock is already held by a different <br>    thread, the free block is simply added to a delayed free list and the <br>    API completes immediately.  The next thread to acquire the heap lock <br>    will free everything on the list. <br> <br>    Every application uses memory allocation routines in different ways. <br>    In order to allow better tuning of this package, MpHeapGetStatistics <br>    allows an application to monitor the amount of contention it is <br>    getting.  Increasing the number of heaps increases the potential <br>    concurrency, but also increases memory overhead.  Some experimentation <br>    is recommended to determine the optimal settings for a given number of <br>    processors. <br> <br>    Some applications can benefit from additional techniques.  For example, <br>    per-thread lookaside lists for common allocation sizes can be very <br>    effective.  No locking is required for a per-thread structure, since no <br>    other thread will ever be accessing it.  Since each thread reuses the <br>    same memory, per-thread structures also improve locality of reference. <br> <br>--*/ <br>#include &lt;windows.h&gt; <br>#include "mpheap.h" <br> <br>#define MPHEAP_VALID_OPTIONS  (MPHEAP_GROWABLE                 | \ <br>                               MPHEAP_REALLOC_IN_PLACE_ONLY    | \ <br>                               MPHEAP_TAIL_CHECKING_ENABLED    | \ <br>                               MPHEAP_FREE_CHECKING_ENABLED    | \ <br>                               MPHEAP_DISABLE_COALESCE_ON_FREE | \ <br>                               MPHEAP_ZERO_MEMORY              | \ <br>                               MPHEAP_COLLECT_STATS) <br> <br>// <br>// Flags that are not passed on to the Win32 heap package <br>// <br>#define MPHEAP_PRIVATE_FLAGS (MPHEAP_COLLECT_STATS | MPHEAP_ZERO_MEMORY); <br> <br>// <br>// Define the heap header that gets tacked on the front of <br>// every allocation. Eight bytes is a lot, but we can't make <br>// it any smaller or else the allocation will not be properly <br>// aligned for 64-bit quantities. <br>// <br>typedef struct _MP_HEADER { <br>    union { <br>        struct _MP_HEAP_ENTRY *HeapEntry; <br>        PSINGLE_LIST_ENTRY Next; <br>    }; <br>    ULONG LookasideIndex; <br>} MP_HEADER, *PMP_HEADER; <br>// <br>// Definitions and structures for lookaside list <br>// <br>#define LIST_ENTRIES 128 <br> <br>typedef struct _MP_HEAP_LOOKASIDE { <br>    PMP_HEADER Entry; <br>} MP_HEAP_LOOKASIDE, *PMP_HEAP_LOOKASIDE; <br> <br>#define NO_LOOKASIDE 0xffffffff <br>#define MaxLookasideSize (8*LIST_ENTRIES-7) <br>#define LookasideIndexFromSize(s) ((s &lt; MaxLookasideSize) ? ((s) &gt;&gt; 3) : NO_LOOKASIDE) <br> <br>// <br>// Define the structure that describes the entire MP heap. <br>// <br>// There is one MP_HEAP_ENTRY structure for each Win32 heap <br>// and a MP_HEAP structure that contains them all. <br>// <br>// Each MP_HEAP structure contains a lookaside list for quick <br>// lock-free alloc/free of various size blocks. <br>// <br> <br>typedef struct _MP_HEAP_ENTRY { <br>    HANDLE Heap; <br>    PSINGLE_LIST_ENTRY DelayedFreeList; <br>    CRITICAL_SECTION Lock; <br>    DWORD Allocations; <br>    DWORD Frees; <br>    DWORD LookasideAllocations; <br>    DWORD LookasideFrees; <br>    DWORD DelayedFrees; <br>    MP_HEAP_LOOKASIDE Lookaside[LIST_ENTRIES]; <br>} MP_HEAP_ENTRY, *PMP_HEAP_ENTRY; <br> <br> <br>typedef struct _MP_HEAP { <br>    DWORD HeapCount; <br>    DWORD Flags; <br>    DWORD Hint; <br>    DWORD PadTo32Bytes; <br>    MP_HEAP_ENTRY Entry[1];     // variable size <br>} MP_HEAP, *PMP_HEAP; <br> <br>VOID <br>ProcessDelayedFreeList( <br>    IN PMP_HEAP_ENTRY HeapEntry <br>    ); <br> <br>// <br>// HeapHint is a per-thread variable that offers a hint as to which heap to <br>// check first.  By giving each thread affinity towards a different heap, <br>// it is more likely that the first heap a thread picks for its allocation <br>// will be available.  It also improves a thread's locality of reference, <br>// which is very important for good MP performance <br>// <br>__declspec(thread) DWORD HeapHint; <br> <br>HANDLE <br>WINAPI <br>MpHeapCreate( <br>    DWORD flOptions, <br>    DWORD dwInitialSize, <br>    DWORD dwParallelism <br>    ) <br>/*++ <br> <br>Routine Description: <br> <br>    This routine creates an MP-enhanced heap. An MP heap consists of a <br>    collection of standard Win32 heaps whose serialization is controlled <br>    by the routines in this module to allow multiple simultaneous allocations. <br> <br>Arguments: <br> <br>    flOptions - Supplies the options for this heap. <br> <br>        Currently valid flags are: <br> <br>            MPHEAP_GROWABLE <br>            MPHEAP_REALLOC_IN_PLACE_ONLY <br>            MPHEAP_TAIL_CHECKING_ENABLED <br>            MPHEAP_FREE_CHECKING_ENABLED <br>            MPHEAP_DISABLE_COALESCE_ON_FREE <br>            MPHEAP_ZERO_MEMORY <br>            MPHEAP_COLLECT_STATS <br> <br>    dwInitialSize - Supplies the initial size of the combined heaps. <br> <br>    dwParallelism - Supplies the number of Win32 heaps that will make up the <br>        MP heap. A value of zero defaults to three + # of processors. <br> <br>Return Value: <br> <br>    HANDLE - Returns a handle to the MP heap that can be passed to the <br>             other routines in this package. <br> <br>    NULL - Failure, GetLastError() specifies the exact error code. <br> <br>--*/ <br>{ <br>    DWORD Error; <br>    DWORD i; <br>    HANDLE Heap; <br>    PMP_HEAP MpHeap; <br>    DWORD HeapSize; <br>    DWORD PrivateFlags; <br> <br>    if (flOptions &amp; ~MPHEAP_VALID_OPTIONS) { <br>        SetLastError(ERROR_INVALID_PARAMETER); <br>        return(NULL); <br>    } <br> <br>    flOptions |= HEAP_NO_SERIALIZE; <br> <br>    PrivateFlags = flOptions &amp; MPHEAP_PRIVATE_FLAGS; <br> <br>    flOptions &amp;= ~MPHEAP_PRIVATE_FLAGS; <br> <br>    if (dwParallelism == 0) { <br>        SYSTEM_INFO SystemInfo; <br> <br>        GetSystemInfo(&amp;SystemInfo); <br>        dwParallelism = 3 + SystemInfo.dwNumberOfProcessors; <br>    } <br> <br>    HeapSize = dwInitialSize / dwParallelism; <br> <br>    // <br>    // The first heap is special, since the MP_HEAP structure itself <br>    // is allocated from there. <br>    // <br>    Heap = HeapCreate(flOptions,HeapSize,0); <br>    if (Heap == NULL) { <br>        // <br>        // HeapCreate has already set last error appropriately. <br>        // <br>        return(NULL); <br>    } <br> <br>    MpHeap = HeapAlloc(Heap,0,sizeof(MP_HEAP) + <br>                              (dwParallelism-1)*sizeof(MP_HEAP_ENTRY)); <br>    if (MpHeap==NULL) { <br>        SetLastError(ERROR_NOT_ENOUGH_MEMORY); <br>        HeapDestroy(Heap); <br>        return(NULL); <br>    } <br> <br>    // <br>    // Initialize the MP heap structure <br>    // <br>    MpHeap-&gt;HeapCount = 1; <br>    MpHeap-&gt;Flags = PrivateFlags; <br>    MpHeap-&gt;Hint = 0; <br> <br>    // <br>    // Initialize the first heap <br>    // <br>    MpHeap-&gt;Entry[0].Heap = Heap; <br>    InitializeCriticalSection(&amp;MpHeap-&gt;Entry[0].Lock); <br>    MpHeap-&gt;Entry[0].DelayedFreeList = NULL; <br>    ZeroMemory(MpHeap-&gt;Entry[0].Lookaside, sizeof(MpHeap-&gt;Entry[0].Lookaside)); <br> <br>    // <br>    // Initialize the remaining heaps. Note that the heap has been <br>    // sufficiently initialized to use MpHeapDestroy for cleanup <br>    // if something bad happens. <br>    // <br>    for (i=1; i&lt;dwParallelism; i++) { <br>        MpHeap-&gt;Entry[i].Heap = HeapCreate(flOptions, HeapSize, 0); <br>        if (MpHeap-&gt;Entry[i].Heap == NULL) { <br>            Error = GetLastError(); <br>            MpHeapDestroy((HANDLE)MpHeap); <br>            SetLastError(Error); <br>            return(NULL); <br>        } <br>        InitializeCriticalSection(&amp;MpHeap-&gt;Entry[i].Lock); <br>        MpHeap-&gt;Entry[i].DelayedFreeList = NULL; <br>        ZeroMemory(MpHeap-&gt;Entry[i].Lookaside, sizeof(MpHeap-&gt;Entry[i].Lookaside)); <br>        ++MpHeap-&gt;HeapCount; <br>    } <br> <br>    return((HANDLE)MpHeap); <br>} <br> <br>BOOL <br>WINAPI <br>MpHeapDestroy( <br>    HANDLE hMpHeap <br>    ) <br>{ <br>    DWORD i; <br>    DWORD HeapCount; <br>    PMP_HEAP MpHeap; <br>    BOOL Success = TRUE; <br> <br>    MpHeap = (PMP_HEAP)hMpHeap; <br>    HeapCount = MpHeap-&gt;HeapCount; <br> <br>    // <br>    // Lock down all the heaps so we don't end up hosing people <br>    // who may be allocating things while we are deleting the heaps. <br>    // By setting MpHeap-&gt;HeapCount = 0 we also attempt to prevent <br>    // people from getting hosed as soon as we delete the critical <br>    // sections and heaps. <br>    // <br>    MpHeap-&gt;HeapCount = 0; <br>    for (i=0; i&lt;HeapCount; i++) { <br>        EnterCriticalSection(&amp;MpHeap-&gt;Entry[i].Lock); <br>    } <br> <br>    // <br>    // Delete the heaps and their associated critical sections. <br>    // Note that the order is important here. Since the MpHeap <br>    // structure was allocated from MpHeap-&gt;Heap[0] we must <br>    // delete that last. <br>    // <br>    for (i=HeapCount-1; i&gt;0; i--) { <br>        DeleteCriticalSection(&amp;MpHeap-&gt;Entry[i].Lock); <br>        if (!HeapDestroy(MpHeap-&gt;Entry[i].Heap)) { <br>            Success = FALSE; <br>        } <br>    } <br>    return(Success); <br>} <br> <br>BOOL <br>WINAPI <br>MpHeapValidate( <br>    HANDLE hMpHeap, <br>    LPVOID lpMem <br>    ) <br>{ <br>    PMP_HEAP MpHeap; <br>    DWORD i; <br>    BOOL Success; <br>    PMP_HEADER Header; <br>    PMP_HEAP_ENTRY Entry; <br> <br>    MpHeap = (PMP_HEAP)hMpHeap; <br> <br>    if (lpMem == NULL) { <br> <br>        // <br>        // Lock and validate each heap in turn. <br>        // <br>        for (i=0; i &lt; MpHeap-&gt;HeapCount; i++) { <br>            Entry = &amp;MpHeap-&gt;Entry[i]; <br>            try { <br>                EnterCriticalSection(&amp;Entry-&gt;Lock); <br>                Success = HeapValidate(Entry-&gt;Heap, 0, NULL); <br>                LeaveCriticalSection(&amp;Entry-&gt;Lock); <br>            } except (EXCEPTION_EXECUTE_HANDLER) { <br>                return(FALSE); <br>            } <br> <br>            if (!Success) { <br>                return(FALSE); <br>            } <br>        } <br>        return(TRUE); <br>    } else { <br> <br>        // <br>        // Lock and validate the given heap entry <br>        // <br>        Header = ((PMP_HEADER)lpMem) - 1; <br>        try { <br>            EnterCriticalSection(&amp;Header-&gt;HeapEntry-&gt;Lock); <br>            Success = HeapValidate(Header-&gt;HeapEntry-&gt;Heap, 0, Header); <br>            LeaveCriticalSection(&amp;Header-&gt;HeapEntry-&gt;Lock); <br>        } except (EXCEPTION_EXECUTE_HANDLER) { <br>            return(FALSE); <br>        } <br>        return(Success); <br>    } <br>} <br> <br>UINT <br>WINAPI <br>MpHeapCompact( <br>    HANDLE hMpHeap <br>    ) <br>{ <br>    PMP_HEAP MpHeap; <br>    DWORD i; <br>    DWORD LargestFreeSize=0; <br>    DWORD FreeSize; <br>    PMP_HEAP_ENTRY Entry; <br> <br>    MpHeap = (PMP_HEAP)hMpHeap; <br> <br>    // <br>    // Lock and compact each heap in turn. <br>    // <br>    for (i=0; i &lt; MpHeap-&gt;HeapCount; i++) { <br>        Entry = &amp;MpHeap-&gt;Entry[i]; <br>        EnterCriticalSection(&amp;Entry-&gt;Lock); <br>        FreeSize = HeapCompact(Entry-&gt;Heap, 0); <br>        LeaveCriticalSection(&amp;Entry-&gt;Lock); <br> <br>        if (FreeSize &gt; LargestFreeSize) { <br>            LargestFreeSize = FreeSize; <br>        } <br>    } <br> <br>    return(LargestFreeSize); <br> <br>} <br> <br>  <br>LPVOID <br>WINAPI <br>MpHeapAlloc( <br>    HANDLE hMpHeap, <br>    DWORD flOptions, <br>    DWORD dwBytes <br>    ) <br>{ <br>    PMP_HEADER Header; <br>    PMP_HEAP MpHeap; <br>    DWORD i; <br>    PMP_HEAP_ENTRY Entry; <br>    DWORD Index; <br>    DWORD Size; <br> <br>    MpHeap = (PMP_HEAP)hMpHeap; <br> <br>    flOptions |= MpHeap-&gt;Flags; <br> <br>    Size = ((dwBytes + 7) &amp; (ULONG)~7) + sizeof(MP_HEADER); <br>    Index=LookasideIndexFromSize(Size); <br> <br>    // <br>    // Iterate through the heap locks looking for one <br>    // that is not owned. <br>    // <br>    i=HeapHint; <br>    if (i&gt;=MpHeap-&gt;HeapCount) { <br>        i=0; <br>        HeapHint=0; <br>    } <br>    Entry = &amp;MpHeap-&gt;Entry[i]; <br>    do { <br>        // <br>        // Check the lookaside list for a suitable allocation. <br>        // <br>        if ((Index != NO_LOOKASIDE) &amp;&amp; <br>            (Entry-&gt;Lookaside[Index].Entry != NULL)) { <br>            if ((Header = (PMP_HEADER)InterlockedExchange((PLONG)&amp;Entry-&gt;Lookaside[Index].Entry, <br>                                                          (LONG)NULL)) != NULL) { <br>                // <br>                // We have a lookaside hit, return it immediately. <br>                // <br>                ++Entry-&gt;LookasideAllocations; <br>                if (flOptions &amp; MPHEAP_ZERO_MEMORY) { <br>                    ZeroMemory(Header + 1, dwBytes); <br>                } <br>                HeapHint=i; <br>                return(Header + 1); <br>            } <br>        } <br> <br>        // <br>        // Attempt to lock this heap without blocking. <br>        // <br>        if (TryEnterCriticalSection(&amp;Entry-&gt;Lock)) { <br>            // <br>            // success, go allocate immediately <br>            // <br>            goto LockAcquired; <br>        } <br> <br>        // <br>        // This heap is owned by another thread, try <br>        // the next one. <br>        // <br>        i++; <br>        Entry++; <br>        if (i==MpHeap-&gt;HeapCount) { <br>            i=0; <br>            Entry=&amp;MpHeap-&gt;Entry[0]; <br>        } <br>    } while ( i != HeapHint ); <br> <br>    // <br>    // All of the critical sections were owned by someone else, <br>    // so we have no choice but to wait for a critical section. <br>    // <br>    EnterCriticalSection(&amp;Entry-&gt;Lock); <br> <br>LockAcquired: <br>    ++Entry-&gt;Allocations; <br>    if (Entry-&gt;DelayedFreeList != NULL) { <br>        ProcessDelayedFreeList(Entry); <br>    } <br>    Header = HeapAlloc(Entry-&gt;Heap, 0, Size); <br>    LeaveCriticalSection(&amp;Entry-&gt;Lock); <br>    if (Header != NULL) { <br>        Header-&gt;HeapEntry = Entry; <br>        Header-&gt;LookasideIndex = Index; <br>        if (flOptions &amp; MPHEAP_ZERO_MEMORY) { <br>            ZeroMemory(Header + 1, dwBytes); <br>        } <br>        HeapHint = i; <br>        return(Header + 1); <br>    } else { <br>        return(NULL); <br>    } <br>} <br> <br>LPVOID <br>WINAPI <br>MpHeapReAlloc( <br>    HANDLE hMpHeap, <br>    LPVOID lpMem, <br>    DWORD dwBytes <br>    ) <br>{ <br>    PMP_HEADER Header; <br>    PCRITICAL_SECTION Lock; <br> <br>    Header = ((PMP_HEADER)lpMem) - 1; <br>    Lock = &amp;Header-&gt;HeapEntry-&gt;Lock; <br>    dwBytes = ((dwBytes + 7) &amp; (ULONG)~7) + sizeof(MP_HEADER); <br> <br>    EnterCriticalSection(Lock); <br>    Header = HeapReAlloc(Header-&gt;HeapEntry-&gt;Heap, 0, Header, dwBytes); <br>    LeaveCriticalSection(Lock); <br> <br>    if (Header != NULL) { <br>        Header-&gt;LookasideIndex = LookasideIndexFromSize(dwBytes); <br>        return(Header + 1); <br>    } else { <br>        return(NULL); <br>    } <br>} <br> <br>BOOL <br>WINAPI <br>MpHeapFree( <br>    HANDLE hMpHeap, <br>    LPVOID lpMem <br>    ) <br>{ <br>    PMP_HEADER Header; <br>    PCRITICAL_SECTION Lock; <br>    BOOL Success; <br>    PMP_HEAP_ENTRY HeapEntry; <br>    PSINGLE_LIST_ENTRY Next; <br>    PMP_HEAP MpHeap; <br> <br>    Header = ((PMP_HEADER)lpMem) - 1; <br>    HeapEntry = Header-&gt;HeapEntry; <br>    MpHeap = (PMP_HEAP)hMpHeap; <br> <br>    HeapHint = HeapEntry - &amp;MpHeap-&gt;Entry[0]; <br> <br>    if (Header-&gt;LookasideIndex != NO_LOOKASIDE) { <br>        // <br>        // Try and put this back on the lookaside list <br>        // <br>        if (InterlockedCompareExchange((PVOID *)&amp;HeapEntry-&gt;Lookaside[Header-&gt;LookasideIndex], <br>                                       (PVOID)Header, <br>                                       NULL) == NULL) { <br>            // <br>            // Successfully freed to lookaside list. <br>            // <br>            ++HeapEntry-&gt;LookasideFrees; <br>            return(TRUE); <br>        } <br>    } <br>    Lock = &amp;HeapEntry-&gt;Lock; <br> <br>    if (TryEnterCriticalSection(Lock)) { <br>        ++HeapEntry-&gt;Frees; <br>        Success = HeapFree(HeapEntry-&gt;Heap, 0, Header); <br>        LeaveCriticalSection(Lock); <br>        return(Success); <br>    } <br>    // <br>    // The necessary heap critical section could not be immediately <br>    // acquired. Post this free onto the Delayed free list and let <br>    // whoever has the lock process it. <br>    // <br>    do { <br>        Next = HeapEntry-&gt;DelayedFreeList; <br>        Header-&gt;Next = Next; <br>    } while ( InterlockedCompareExchange(&amp;HeapEntry-&gt;DelayedFreeList, <br>                                         &amp;Header-&gt;Next, <br>                                         Next) != Next); <br>    return(TRUE); <br>} <br> <br>VOID <br>ProcessDelayedFreeList( <br>    IN PMP_HEAP_ENTRY HeapEntry <br>    ) <br>{ <br>    PSINGLE_LIST_ENTRY FreeList; <br>    PSINGLE_LIST_ENTRY Next; <br>    PMP_HEADER Header; <br> <br>    // <br>    // Capture the entire delayed free list with a single interlocked exchange. <br>    // Once we have removed the entire list, free each entry in turn. <br>    // <br>    FreeList = (PSINGLE_LIST_ENTRY)InterlockedExchange((LPLONG)&amp;HeapEntry-&gt;DelayedFreeList, (LONG)NULL); <br>    while (FreeList != NULL) { <br>        Next = FreeList-&gt;Next; <br>        Header = CONTAINING_RECORD(FreeList, MP_HEADER, Next); <br>        ++HeapEntry-&gt;DelayedFrees; <br>        HeapFree(HeapEntry-&gt;Heap, 0, Header); <br>        FreeList = Next; <br>    } <br>} <br> <br>DWORD <br>MpHeapGetStatistics( <br>    HANDLE hMpHeap, <br>    LPDWORD lpdwSize, <br>    MPHEAP_STATISTICS Stats[] <br>    ) <br>{ <br>    PMP_HEAP MpHeap; <br>    PMP_HEAP_ENTRY Entry; <br>    DWORD i; <br>    DWORD RequiredSize; <br> <br>    MpHeap = (PMP_HEAP)hMpHeap; <br>    RequiredSize = MpHeap-&gt;HeapCount * sizeof(MPHEAP_STATISTICS); <br>    if (*lpdwSize &lt; RequiredSize) { <br>        *lpdwSize = RequiredSize; <br>        return(ERROR_MORE_DATA); <br>    } <br>    ZeroMemory(Stats, MpHeap-&gt;HeapCount * sizeof(MPHEAP_STATISTICS)); <br>    for (i=0; i &lt; MpHeap-&gt;HeapCount; i++) { <br>        Entry = &amp;MpHeap-&gt;Entry[i]; <br> <br>        Stats[i].Contention = Entry-&gt;Lock.DebugInfo-&gt;ContentionCount; <br>        Stats[i].TotalAllocates = (Entry-&gt;Allocations + Entry-&gt;LookasideAllocations); <br>        Stats[i].TotalFrees = (Entry-&gt;Frees + Entry-&gt;LookasideFrees + Entry-&gt;DelayedFrees); <br>        Stats[i].LookasideAllocates = Entry-&gt;LookasideAllocations; <br>        Stats[i].LookasideFrees = Entry-&gt;LookasideFrees; <br>        Stats[i].DelayedFrees = Entry-&gt;DelayedFrees; <br>    } <br>    *lpdwSize = RequiredSize; <br>    return(ERROR_SUCCESS); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
