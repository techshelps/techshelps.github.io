<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>TMPHEAP.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6246"></a>TMPHEAP.C</h2>
<pre><code>/*++ <br> <br>Copyright (c) 1992  Microsoft Corporation <br> <br>Module Name: <br> <br>    tmpheap.c <br> <br>Abstract: <br> <br>    Test program for the MP heap package. <br> <br>Author: <br> <br>    John Vert (jvert) 10-Jul-1995 <br> <br>Revision History: <br> <br>--*/ <br>#include "windows.h" <br>#include "stdio.h" <br>#include "string.h" <br>#include "stdlib.h" <br>#include "mpheap.h" <br> <br>DWORD <br>WINAPI <br>ThreadStartup( <br>    LPVOID Parameter <br>    ); <br> <br>LPVOID Malloc(DWORD dwBytes); <br>VOID Free(LPVOID lpMem); <br> <br>BOOL Suicide = FALSE; <br> <br>HANDLE MpHeap; <br> <br>LPVOID <br>Malloc( <br>    DWORD dwBytes <br>    ) <br>{ <br>    return(MpHeapAlloc(MpHeap,0,dwBytes)); <br>} <br> <br>VOID <br>Free( <br>    LPVOID lpMem <br>    ) <br>{ <br>    MpHeapFree(MpHeap,lpMem); <br>} <br> <br>// int <br>// _CRTAPI1 <br>main (argc, argv) <br>    int argc; <br>    char *argv[]; <br>{ <br>    ULONG NumThreads; <br>    ULONG i; <br>    HANDLE *h; <br>    DWORD ThreadId; <br>    DWORD Parallelism; <br>    DWORD Seconds; <br>    LPMPHEAP_STATISTICS HeapStats; <br>    DWORD StatSize; <br>    DWORD Error; <br> <br>    if (argc != 4) { <br>        fprintf(stderr, "Usage: tmpheap NumThreads HeapParallelism Seconds\n"); <br>        exit(1); <br>    } <br>    NumThreads = atoi(argv[1]); <br>    Parallelism = atoi(argv[2]); <br>    Seconds = atoi(argv[3]); <br> <br>    MpHeap = MpHeapCreate(0, 0, Parallelism); <br>    if (MpHeap == NULL) { <br>        fprintf(stderr, "MpHeapCreate failed error %d\n",GetLastError); <br>        exit(1); <br>    } <br>    h = Malloc(NumThreads * sizeof(HANDLE)); <br>    if (h==NULL) { <br>        fprintf(stderr, "Malloc thread handle array failed\n"); <br>        exit(1); <br>    } <br>    for (i=0; i&lt;NumThreads; i++) { <br>        h[i] = CreateThread(NULL, <br>                            0, <br>                            ThreadStartup, <br>                            NULL, <br>                            0, <br>                            &amp;ThreadId); <br>        if (h==NULL) { <br>            fprintf(stderr, "CreateThread %d failed %d\n",i,GetLastError()); <br>            exit(1); <br>        } <br>    } <br> <br>    Sleep(Seconds * 1000); <br>    Suicide = TRUE; <br>    WaitForMultipleObjects(NumThreads, h, TRUE, INFINITE); <br>    StatSize = Parallelism * sizeof(MPHEAP_STATISTICS); <br>    HeapStats = (LPMPHEAP_STATISTICS)LocalAlloc(LMEM_FIXED, StatSize); <br>    if (HeapStats != NULL) { <br>        Error = MpHeapGetStatistics(MpHeap,&amp;StatSize, HeapStats); <br>        if (Error==ERROR_SUCCESS) { <br>            for (i=0; i&lt;StatSize/sizeof(MPHEAP_STATISTICS);i++) { <br>                printf("HEAP %d\n",i); <br>                printf("  Allocations:      %8d\n",HeapStats[i].TotalAllocates); <br>                if (0 == HeapStats[i].TotalAllocates) continue;  // avoid divide by 0 <br>                printf("  Contention :      %8d (%d%%)\n",HeapStats[i].Contention, <br>                        100*HeapStats[i].Contention/HeapStats[i].TotalAllocates); <br>                printf("  Lookaside Allocs: %8d (%d%%)\n", <br>                        HeapStats[i].LookasideAllocates, <br>                        100*HeapStats[i].LookasideAllocates/HeapStats[i].TotalAllocates); <br>                printf("  Frees:            %8d\n",HeapStats[i].TotalFrees); <br>                printf("  Lookaside Frees:  %8d (%d%%)\n", <br>                        HeapStats[i].LookasideFrees, <br>                        100*HeapStats[i].LookasideFrees/HeapStats[i].TotalFrees); <br>                printf("  Delayed Frees:    %8d (%d%%)\n", <br>                        HeapStats[i].DelayedFrees, <br>                        100*HeapStats[i].DelayedFrees/HeapStats[i].TotalFrees); <br>            } <br>        } else { <br>            fprintf(stderr, "MpHeapStatistics failed with error %d\n",Error); <br>        } <br>        MpHeapDestroy(MpHeap); <br>        LocalFree(HeapStats); <br>    } <br> <br>    return(0); <br>} <br> <br>DWORD <br>WINAPI <br>ThreadStartup( <br>    LPVOID Parameter <br>    ) <br>{ <br>    DWORD Seed = GetCurrentThreadId(); <br>    PULONG Buffer = NULL; <br>    DWORD BufferSize; <br>    DWORD Delay; <br>    DWORD i,j; <br>    DWORD Fill; <br>    PULONG Last = NULL; <br>    BOOL AllocAgain; <br>    DWORD MaxSize=0; <br>    DWORD CurrentSize=0; <br>    DWORD CurrentAllocs = 0; <br>    DWORD MaxAllocs = 0; <br> <br>    // <br>    // Loop allocating/filling/freeing random chunks <br>    // of memory. <br>    // <br>    Fill = GetCurrentThreadId(); <br>    while (!Suicide) { <br>        // <br>        // Decide whether to allocate a new chunk or free the <br>        // last chunk. <br>        // <br>        AllocAgain = (BOOL)((rand() &amp; 0xff) &gt; 0x80); <br>        if (AllocAgain) { <br>            BufferSize = (rand() &amp; 0xfff) + sizeof(PUCHAR) + sizeof(ULONG); <br> <br>            CurrentAllocs++; <br>            if (CurrentAllocs &gt; MaxAllocs) { <br>                MaxAllocs = CurrentAllocs; <br>            } <br>            Buffer = Malloc(BufferSize); <br>            if (Buffer == NULL) { <br>                fprintf(stderr,"malloc of %d returned NULL\n",BufferSize); <br>                return(0); <br>            } <br>            CurrentSize += BufferSize; <br>            if (CurrentSize &gt; MaxSize) { <br>                if ((CurrentSize &gt;&gt; 18) != (MaxSize &gt;&gt; 18)) { <br>                    printf("Thread %x up to %d bytes %d allocs\n", <br>                            GetCurrentThreadId(), <br>                            CurrentSize, <br>                            CurrentAllocs); <br>                } <br>                MaxSize = CurrentSize; <br>            } <br>            if ((CurrentSize &gt; MaxSize) &amp;&amp; <br>                (CurrentSize-MaxSize &gt; 0x10000)) { <br>            } <br>            for (j=0; j&lt;BufferSize/sizeof(ULONG); j++) { <br>                Buffer[j] = Fill; <br>            } <br>            Buffer[0] = (ULONG)Last; <br>            Buffer[1] = BufferSize; <br>            Last = Buffer; <br>        } else if (Buffer != NULL) { <br>            Last = (PULONG)Buffer[0]; <br>            CurrentSize -= Buffer[1]; <br>            --CurrentAllocs; <br>            Free(Buffer); <br>            Buffer = Last; <br>        } <br> <br>        Delay = rand() &amp; 0x1ff; <br>        for (i=0; i&lt; Delay; i++) { <br>            Fill = GetCurrentThreadId(); <br>        } <br>        if ((rand() &amp; 0xffff) &lt; (int)CurrentAllocs) { <br>            // <br>            // Magic number, free EVERYTHING! <br>            // <br>            while (Buffer != NULL) { <br>                Last = (PULONG)Buffer[0]; <br>                CurrentSize -= Buffer[1]; <br>                --CurrentAllocs; <br>                Free(Buffer); <br>                Buffer = Last; <br>            } <br>        } <br>    } <br>    return(0); <br>} <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
