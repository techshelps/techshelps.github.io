<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>THREADS.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6301"></a>THREADS.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples. <br>*       Copyright 1992 - 1998 Microsoft Corporation. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  File:       pop3.c <br>// <br>//  Contents: <br>// <br>//  Classes: <br>// <br>//  Functions: <br>// <br>//---------------------------------------------------------------------------- <br> <br>#include "pop3srvp.h" <br>#pragma hdrstop <br> <br>extern BOOL bServiceTerminating; <br> <br>DWORD <br>WINAPI <br>WorkerThread ( <br>    LPVOID WorkContext <br>    ); <br> <br>  <br>HANDLE <br>InitializeThreads ( <br>    VOID <br>    ) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    Starts up the POP3SRV worker threads.  We use two worker threads <br>    for eachprocessor on the system--this is choosen as a good balance <br>    that ensures that there are a sufficient number of threads available <br>    to get useful work done but not too many that context switches <br>    consume significant overhead. <br> <br>Arguments: <br> <br>    None. <br> <br>Return Value: <br> <br>    HANDLE - A handle to the completion port if everything was  <br>        successful, or NULL if there was a failure.   <br> <br>--*/ <br> <br>{ <br> <br>    SOCKET s; <br>    DWORD i; <br>    HANDLE hCompletionPort; <br>    HANDLE hThreadHandle; <br>    DWORD dwThreadId; <br>    SYSTEM_INFO systemInfo; <br> <br>    // <br>    // First open a temporary socket that we will use to create the <br>    // completion port.  In NT 3.51 it will not be necessary to specify <br>    // the FileHandle parameter of CreateIoCompletionPort()--it will <br>    // be legal to specify FileHandle as NULL.  However, for NT 3.5 <br>    // we need an overlapped file handle. <br>    // <br> <br>    s = socket( AF_INET, SOCK_DGRAM, 0 ); <br>    if ( s == INVALID_SOCKET ) { <br>        return NULL; <br>    } <br> <br>    // <br>    // Create the completion port that will be used by all the worker <br>    // threads. <br>    // <br> <br>    hCompletionPort = CreateIoCompletionPort( (HANDLE)s, NULL, 0, 0 ); <br>    if ( hCompletionPort == NULL ) { <br>        closesocket( s ); <br>        return NULL; <br>    } <br> <br>    // <br>    // Close the socket, we don't need it any longer. <br>    // <br> <br>    closesocket( s ); <br> <br>    // <br>    // Determine how many processors are on the system. <br>    // <br> <br>    GetSystemInfo( &amp;systemInfo ); <br> <br>    // <br>    // Create worker threads that will service the actual overlapped <br>    // I/O requests.  Create two worker threads for each processor <br>    // on the system. <br>    // <br> <br>    for ( i = 0; i &lt; systemInfo.dwNumberOfProcessors*2; i++ ) { <br> <br>        hThreadHandle = CreateThread( <br>                            NULL, <br>                            0, <br>                            WorkerThread, <br>                            hCompletionPort, <br>                            0, <br>                            &amp;dwThreadId <br>                            ); <br>        if ( hThreadHandle == NULL ) { <br>            CloseHandle( hCompletionPort ); <br>            return NULL; <br>        } <br> <br>        // <br>        // Close each thread handle as we open them.  We do not need <br>        // the thread handles.  Note that each thread will continue <br>        // executing. <br>        // <br> <br>        CloseHandle( hThreadHandle ); <br>    } <br> <br>    // <br>    // All was successful. <br>    // <br> <br>    return hCompletionPort; <br> <br>} // InitializeThreads <br> <br>  <br>DWORD <br>WINAPI <br>WorkerThread ( <br>    LPVOID WorkContext <br>    ) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    This is the main worker routine for the POP3SRV worker threads.   <br>    Worker threads wait on a completion port for I/O to complete.  When  <br>    it completes, the worker thread processes the I/O, then either pends  <br>    new I/O or closes the client's connection.  When the service shuts  <br>    down, other code closes the completion port which causes  <br>    GetQueuedCompletionStatus() to wake up and the worker thread then  <br>    exits.   <br> <br>Arguments: <br> <br>    WorkContext - the completion port handle that will get I/O completion <br>        notifications. <br> <br>Return Value: <br> <br>    DWORD - status of the thread. <br> <br>--*/ <br> <br>{ <br>    HANDLE hCompletionPort = WorkContext; <br>    BOOL bSuccess; <br>    DWORD dwIoSize; <br>    LPOVERLAPPED lpOverlapped; <br>    PCLIENT_CONTEXT lpClientContext; <br>    Pop3Disposition Disposition; <br>    HANDLE hFile; <br>    CHAR * OutputBuffer; <br>    DWORD OutputBufferLen; <br>    TRANSMIT_FILE_BUFFERS TranfileBuffers; <br> <br>    // <br>    // Loop servicing I/O completions. <br>    // <br> <br>    while ( TRUE ) { <br> <br>        // --- DavidTr: Slide 14(b) ------------------------------------------ <br>        // <br>        // Get a completed IO request. <br>        // <br> <br>        bSuccess = GetQueuedCompletionStatus( <br>                       hCompletionPort, <br>                       &amp;dwIoSize, <br>                       (LPDWORD)&amp;lpClientContext, <br>                       &amp;lpOverlapped, <br>                       (DWORD)-1 <br>                       ); <br> <br>        // <br>        // If the service is terminating, exit this thread. <br>        // <br> <br>        if ( bServiceTerminating ) { <br>            return 0; <br>        } <br> <br>        // <br>        // If the IO failed, close the socket and free context. <br>        // <br> <br>        if ( !bSuccess ) { <br>            CloseClient( lpClientContext, FALSE ); <br>            continue; <br>        } <br> <br>        // <br>        // If the request was a read, process the client request. <br>        // <br> <br>        if ( lpClientContext-&gt;LastClientIo == ClientIoRead ) { <br> <br>            // <br>            // BUGBUG: if this were a real production piece of code, <br>            // we would check here for an incomplete read.  Because <br>            // TCP/IP is a stream oriented protocol, it is feasible <br>            // that we could receive part of a client request. <br>            // Therefore, we should check for the CRLF that ends a <br>            // client request. <br>            // <br> <br>            // <br>            // Process the request.  Pop3Dispatch() handles all aspects  <br>            // of the request and tells us how to respond to the client.   <br>            // <br> <br>            Disposition = Pop3Dispatch( <br>                              lpClientContext-&gt;Context, <br>                              lpClientContext-&gt;Buffer, <br>                              dwIoSize, <br>                              &amp;hFile, <br>                              &amp;OutputBuffer, <br>                              &amp;OutputBufferLen <br>                              ); <br> <br>            // <br>            // Act based on the Disposition. <br>            // <br> <br>            switch ( Disposition ) { <br> <br>            case Pop3_Discard: <br>                break; <br> <br>            case Pop3_SendError: <br>            case Pop3_SendBuffer: <br> <br>                // --- DavidTr: Slide 7(a) ----------------------------------- <br>                // <br>                // Set up context information and perform an overlapped  <br>                // write on the socket.   <br>                // <br> <br>                lpClientContext-&gt;LastClientIo = ClientIoWrite; <br>                lpClientContext-&gt;TransmittedBuffer = OutputBuffer; <br> <br>                bSuccess = WriteFile( <br>                               (HANDLE)lpClientContext-&gt;Socket, <br>                               OutputBuffer, <br>                               OutputBufferLen, <br>                               &amp;dwIoSize, <br>                               &amp;lpClientContext-&gt;Overlapped <br>                               ); <br>                if ( !bSuccess &amp;&amp; GetLastError( ) != ERROR_IO_PENDING ) { <br>                    CloseClient( lpClientContext, FALSE ); <br>                    continue; <br>                } <br> <br>                // <br>                // Continue looping to get completed IO requests--we <br>                // do not want to pend another read now. <br>                // <br> <br>                continue; <br> <br>            case Pop3_SendFile: <br>            case Pop3_SendBufferThenFile: <br> <br>                // <br>                // Determine based on the disposition whether we will <br>                // need to send a head or tail buffer. <br>                // <br> <br>                if ( Disposition == Pop3_SendFile ) { <br>                    TranfileBuffers.Head = NULL; <br>                    TranfileBuffers.HeadLength = 0; <br>                } else if ( Disposition == Pop3_SendBufferThenFile ) { <br>                    TranfileBuffers.Head = OutputBuffer; <br>                    TranfileBuffers.HeadLength = OutputBufferLen; <br>                } <br> <br>                // <br>                // After the file, we're going to send a .CRLF sequence  <br>                // so that the client detects EOF.  Note that  <br>                // TransmitFile() will send this terminator in the same  <br>                // packet as the last chunk of the file, thereby saving  <br>                // network traffic.   <br>                // <br> <br>                TranfileBuffers.Tail = ".\r\n"; <br>                TranfileBuffers.TailLength = 3; <br> <br>                // <br>                // Set up context for the I/O so that we know how to act  <br>                // when the I/O completes.   <br>                // <br> <br>                lpClientContext-&gt;LastClientIo = ClientIoTransmitFile; <br>                lpClientContext-&gt;TransmittedFile = hFile; <br>                lpClientContext-&gt;TransmittedBuffer = OutputBuffer; <br> <br>                // --- DavidTr: Slide 21 --------------------------------- <br>                // <br>                // Now transmit the file and the data buffers. <br>                // <br> <br>                bSuccess = TransmitFile( <br>                               lpClientContext-&gt;Socket, <br>                               hFile, <br>                               0, <br>                               0, <br>                               &amp;lpClientContext-&gt;Overlapped, <br>                               &amp;TranfileBuffers, <br>                               0 <br>                               ); <br>                if ( !bSuccess &amp;&amp; GetLastError( ) != ERROR_IO_PENDING ) { <br>                    CloseClient( lpClientContext, FALSE ); <br>                    continue; <br>                } <br> <br>                // <br>                // Continue looping to get completed IO requests--we <br>                // do not want to pend another read now. <br>                // <br> <br>                continue; <br>            } <br> <br>        } else if ( lpClientContext-&gt;LastClientIo == ClientIoWrite ) { <br> <br>            // <br>            // Clean up after the WriteFile(). <br>            // <br> <br>            LocalFree( lpClientContext-&gt;TransmittedBuffer ); <br> <br>        } else if ( lpClientContext-&gt;LastClientIo == ClientIoTransmitFile ) { <br> <br>            // <br>            // Clean up after the TransmitFile(). <br>            // <br> <br>            CloseHandle( lpClientContext-&gt;TransmittedFile ); <br>            LocalFree( lpClientContext-&gt;TransmittedBuffer ); <br>        }  <br> <br>        // --- DavidTr: Slide 7(b) --------------------------------------- <br>        // <br>        // Pend another read request to get the next client request. <br>        // <br> <br>        lpClientContext-&gt;LastClientIo = ClientIoRead; <br>        lpClientContext-&gt;BytesReadSoFar = 0; <br> <br>        bSuccess = ReadFile( <br>                       (HANDLE)lpClientContext-&gt;Socket, <br>                       lpClientContext-&gt;Buffer, <br>                       sizeof(lpClientContext-&gt;Buffer), <br>                       &amp;dwIoSize, <br>                       &amp;lpClientContext-&gt;Overlapped <br>                       ); <br>        if ( !bSuccess &amp;&amp; GetLastError( ) != ERROR_IO_PENDING ) { <br>            CloseClient( lpClientContext, FALSE ); <br>            continue; <br>        } <br> <br>        // <br>        // Loop around to get another completed IO request. <br>        // <br>    } <br> <br>    return 0; <br> <br>} // WorkThread <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
