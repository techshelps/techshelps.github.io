<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>POPFILE.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6295"></a>POPFILE.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples. <br>*       Copyright 1992 - 1998 Microsoft Corporation. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  File:       popfile.c <br>// <br>//  Contents: <br>// <br>//  Classes: <br>// <br>//  Functions: <br>// <br>//---------------------------------------------------------------------------- <br> <br>#include "pop3srvp.h" <br>#pragma hdrstop <br> <br>#define POP3_LOCKFILE       TEXT("poplock") <br>#define POP3_LOCKFILE_NAME  TEXT("\\") POP3_LOCKFILE <br>#define POP3_SEARCH         TEXT("\\*.*") <br> <br> <br>WCHAR   BaseDirectory[MAX_PATH]; <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Function:   LockMailDirectory <br>// <br>//  Synopsis:   Attempts to lock the mail directory <br>// <br>//  Arguments:  [hUserToken] -- Token of user <br>//              [pszPath]    -- path to the mail directory <br>// <br>//  Returns:    Handle of lock file on success, or NULL <br>// <br>//  History:    1-06-95   RichardW   Created <br>// <br>//  Notes: <br>// <br>//---------------------------------------------------------------------------- <br>HANDLE <br>LockMailDirectory( <br>    HANDLE          hUserToken, <br>    PCHAR           pszPath) <br>{ <br> <br>    WCHAR   PathToOpen[MAX_PATH]; <br>    WCHAR   WidePath[64]; <br>    HANDLE  hLockFile; <br> <br>    // <br>    // Build lock file name <br>    // <br>    MultiByteToWideChar( <br>        CP_ACP, MB_PRECOMPOSED, <br>        pszPath, -1, <br>        WidePath, sizeof(WidePath) / sizeof(WCHAR) ); <br> <br>    wcscpy(PathToOpen, BaseDirectory); <br>    wcscat(PathToOpen, WidePath); <br>    wcscat(PathToOpen, POP3_LOCKFILE_NAME); <br> <br>    // <br>    // Impersonate the client <br>    // <br>#ifdef SECURE_BUILD <br> <br>    ImpersonateLoggedOnUser(hUserToken); <br> <br>#endif <br> <br>    // <br>    // Attempt to create the file.  This will fail if it already exists, <br>    // which would indicate that another thread/client is accessing this <br>    // mailbox. <br>    // <br>    DebugLog((DEB_TRACE, "Opening lock file as %ws\n", PathToOpen)); <br> <br>    hLockFile = CreateFile( PathToOpen, <br>                            GENERIC_READ | GENERIC_WRITE, <br>                            0, <br>                            NULL, <br>                            CREATE_NEW, <br>                            FILE_ATTRIBUTE_NORMAL | <br>                            FILE_FLAG_DELETE_ON_CLOSE, <br>                            NULL); <br> <br>    // <br>    // Done being the client.  Back to server security <br>    // <br>    RevertToSelf(); <br> <br>    // <br>    // Return a handle, or NULL if failed <br>    // <br>    return(hLockFile != INVALID_HANDLE_VALUE ? hLockFile : NULL); <br> <br>} <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Function:   OpenMailMessage <br>// <br>//  Synopsis:   Opens the specified mail message as the user <br>// <br>//  Arguments:  [MessageId]  -- <br>//              [pDir]       -- <br>//              [hUserToken] -- <br>// <br>//  History:    1-08-95   RichardW   Created <br>// <br>//  Notes: <br>// <br>//---------------------------------------------------------------------------- <br>HANDLE <br>OpenMailMessage( <br>    DWORD               MessageId, <br>    PPopMailDirectory   pDir, <br>    HANDLE              hUserToken) <br>{ <br>    HANDLE  hMailFile; <br>    WCHAR   Path[MAX_PATH]; <br> <br>    // <br>    // Impersonate the client <br>    // <br>#ifdef SECURE_BUILD <br> <br>    ImpersonateLoggedOnUser(hUserToken); <br> <br>#endif <br> <br>    // <br>    // Attempt to create the file.  This will fail if it already exists, <br>    // which would indicate that another thread/client is accessing this <br>    // mailbox. <br>    // <br>    wcscpy(Path, pDir-&gt;pBaseDir); <br>    wcscat(Path, TEXT("\\")); <br>    wcscat(Path, pDir-&gt;Messages[MessageId].pszFileName); <br> <br>    hMailFile = CreateFile( Path, <br>                            GENERIC_READ | GENERIC_WRITE, <br>                            0, <br>                            NULL, <br>                            OPEN_EXISTING, <br>                            FILE_ATTRIBUTE_HIDDEN, <br>                            NULL); <br> <br>    // <br>    // Done being the client.  Back to server security <br>    // <br>    RevertToSelf(); <br> <br>    // <br>    // Return a handle, or NULL if failed <br>    // <br>    return(hMailFile != INVALID_HANDLE_VALUE ? hMailFile : NULL); <br>} <br> <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Function:   UnlockMailDirectory <br>// <br>//  Synopsis:   Unlocks the mail directory <br>// <br>//  Arguments:  [hLockFile] -- Handle of lock file to close <br>// <br>//  Returns:    TRUE if success, FALSE if failure <br>// <br>//  History:    1-06-95   RichardW   Created <br>// <br>//  Notes: <br>// <br>//---------------------------------------------------------------------------- <br>BOOL <br>UnlockMailDirectory( <br>    HANDLE      hLockFile) <br>{ <br>    // <br>    // Since the lock file was opened with DELETE_ON_CLOSE semantics, it will <br>    // softly and silently vanish away when we close this, the one handle to <br>    // it. <br>    // <br> <br>    return(CloseHandle(hLockFile)); <br>} <br> <br> <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Function:   ReadMailDirectory <br>// <br>//  Synopsis:   Reads in a list of all the files in the directory <br>// <br>//  Arguments:  [hUserToken] -- <br>//              [pszPath]    -- <br>// <br>//  Returns: <br>// <br>//  History:    1-08-95   RichardW   Created <br>// <br>//  Notes: <br>// <br>//---------------------------------------------------------------------------- <br>PPopMailDirectory <br>ReadMailDirectory( <br>    HANDLE          hUserToken, <br>    PCHAR           pszPath) <br>{ <br>    WIN32_FIND_DATA     FindData; <br>    PPopMailDirectory   pDir; <br>    WCHAR               MailDir[MAX_PATH]; <br>    WCHAR               WidePath[64]; <br>    HANDLE              hSearch; <br>    PPopMessageHeader   pExtraHeaders; <br>    PPopMessageHeader   pHeader; <br>    DWORD               RemainingHeaders; <br> <br>    MultiByteToWideChar( <br>        CP_ACP, MB_PRECOMPOSED, <br>        pszPath, -1, <br>        WidePath, sizeof(WidePath) / sizeof(WCHAR) ); <br>    wcscpy(MailDir, BaseDirectory); <br>    wcscat(MailDir, WidePath); <br> <br>    pDir = LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, sizeof(PopMailDirectory)); <br>    pDir-&gt;pBaseDir = LocalAlloc(LMEM_FIXED, (wcslen(MailDir) + 1) * sizeof(WCHAR)); <br>    wcscpy(pDir-&gt;pBaseDir, MailDir); <br> <br>    wcscat(MailDir, POP3_SEARCH); <br> <br>#ifdef SECURE_BUILD <br> <br>    ImpersonateLoggedOnUser(hUserToken); <br> <br>#endif <br> <br>    hSearch = FindFirstFile(MailDir, &amp;FindData); <br> <br>    if (hSearch == INVALID_HANDLE_VALUE) <br>    { <br>        DebugLog((DEB_TRACE, "FindFirst FAILED!, %d\n", GetLastError())); <br>        RevertToSelf(); <br> <br>        return(NULL); <br>    } <br> <br>    pExtraHeaders = LocalAlloc(LMEM_FIXED, sizeof(PopMessageHeader) * 10); <br>    RemainingHeaders = 10; <br>    pHeader = pExtraHeaders; <br> <br>    do <br>    { <br>        if (FindData.dwFileAttributes &amp; (FILE_ATTRIBUTE_DIRECTORY | <br>                                        FILE_ATTRIBUTE_SYSTEM | <br>                                        FILE_ATTRIBUTE_HIDDEN) ) <br>        { <br>            continue;   // Skip non-normal files <br>        } <br>        if (wcsicmp(FindData.cFileName,POP3_LOCKFILE) == 0) <br>        { <br>            continue;   // Skip our lock file <br>        } <br>        DebugLog((DEB_TRACE, "ReadDir:  Message %ws, size %d\n", <br>                FindData.cFileName, FindData.nFileSizeLow)); <br> <br>        pHeader-&gt;Flags = 0; <br>        pDir-&gt;TotalSize += FindData.nFileSizeLow; <br>        pHeader-&gt;Size = FindData.nFileSizeLow; <br> <br>        pHeader-&gt;pszFileName = LocalAlloc(LMEM_FIXED, <br>                            (wcslen(FindData.cFileName) + 1) * sizeof(WCHAR) ); <br> <br>        wcscpy(pHeader-&gt;pszFileName, FindData.cFileName); <br>        pHeader++; <br>        RemainingHeaders--; <br> <br> <br> <br>        if (RemainingHeaders == 0) <br>        { <br>            PPopMessageHeader   pTemp; <br> <br> <br>            pTemp = LocalAlloc(LMEM_FIXED, sizeof(PopMessageHeader) * (pDir-&gt;cMessages + 20)); <br> <br>            CopyMemory(pTemp, pExtraHeaders, sizeof(PopMessageHeader) * (pDir-&gt;cMessages + 10)); <br> <br>            LocalFree(pExtraHeaders); <br> <br>            pExtraHeaders = pTemp; <br> <br>            RemainingHeaders = 10; <br> <br>            pDir-&gt;cMessages += 10; <br>        } <br> <br>    } while (FindNextFile(hSearch, &amp;FindData)); <br> <br>    pDir-&gt;cMessages += (10 - RemainingHeaders); <br>    pDir-&gt;Messages = pExtraHeaders; <br> <br>    FindClose(hSearch); <br> <br>    pDir-&gt;cAvailMessages = pDir-&gt;cMessages; <br>    pDir-&gt;AvailSize = pDir-&gt;TotalSize; <br> <br>    RevertToSelf(); <br> <br>    return(pDir); <br>} <br> <br>BOOL <br>CommitMailDirectory( <br>    PPopMailDirectory   pDir, <br>    HANDLE              hUserToken) <br>{ <br>    DWORD   i; <br>    WCHAR   Path[MAX_PATH]; <br>    PWSTR   pszPath; <br> <br>    wcscpy(Path, pDir-&gt;pBaseDir); <br>    wcscat(Path, TEXT("\\")); <br>    pszPath = Path + wcslen(Path); <br> <br> <br>#ifdef SECURE_BUILD <br> <br>    ImpersonateLoggedOnUser(hUserToken); <br> <br>#endif <br> <br>    for (i = 0; i &lt; pDir-&gt;cMessages ; i++) <br>    { <br>        if (pDir-&gt;Messages[i].Flags &amp; POP3_MESSAGE_DELETE) <br>        { <br>            wcscpy(pszPath, pDir-&gt;Messages[i].pszFileName); <br>            DeleteFile(Path); <br>        } <br>    } <br> <br>    RevertToSelf(); <br> <br>    return(TRUE); <br>} <br> <br>void <br>FreeMailDirectory( <br>    PPopMailDirectory   pDir) <br>{ <br>    DWORD   i; <br> <br>    for (i = 0 ; i &lt; pDir-&gt;cMessages ; i++ ) <br>    { <br>        LocalFree(pDir-&gt;Messages[i].pszFileName); <br>    } <br> <br>    LocalFree(pDir-&gt;Messages); <br>    LocalFree(pDir); <br> <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
