<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>POP3.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6290"></a>POP3.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples. <br>*       Copyright 1992 - 1998 Microsoft Corporation. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  File:       pop3.c <br>// <br>//  Contents:   This file contains the code to handle each pop command <br>// <br>//---------------------------------------------------------------------------- <br> <br>#include "pop3srvp.h" <br>#pragma hdrstop <br> <br>char *  PopCommands[] = {   POP3_HELO, <br>                            POP3_USER, <br>                            POP3_PASS, <br>                            POP3_QUIT, <br>                            POP3_STAT, <br>                            POP3_LIST, <br>                            POP3_RETR, <br>                            POP3_DELE, <br>                            POP3_LAST, <br>                            POP3_RSET }; <br> <br>Pop3DispatchFn  Pop3DispatchTable[] = { <br>                            HeloDispatch, <br>                            UserDispatch, <br>                            PassDispatch, <br>                            QuitDispatch, <br>                            StatDispatch, <br>                            ListDispatch, <br>                            RetrDispatch, <br>                            DeleDispatch, <br>                            LastDispatch, <br>                            RsetDispatch }; <br> <br>#define POP3_STAT_RESPONSE  POP3_GOOD_RESPONSE " %d %d\r\n" <br>#define POP3_GOOD_RESPLINE  POP3_GOOD_RESPONSE "\r\n" <br>#define POP3_LIST_RESPLINE  "%d %d\r\n" <br>#define POP3_TERMINATOR     ".\r\n" <br>#define POP3_RETR_RESPONSE  POP3_GOOD_RESPONSE " %d octets\r\n" <br>#define POP3_LAST_RESPONSE  POP3_GOOD_RESPONSE " %d\r\n" <br> <br>#define BANNER_STRING   POP3_GOOD_RESPONSE " POP3 Example Server Ready\r\n" <br>#define ERROR_POP3_INVALID_STATE     POP3_BAD_RESPONSE " Command not valid in this state\r\n" <br>#define ERROR_INVALID_USERNAME  POP3_BAD_RESPONSE " Username not valid\r\n" <br>#define ERROR_AUTH_FAILED       POP3_BAD_RESPONSE " Unable to log on\r\n" <br>#define ERROR_LOCK_FAILED_S     POP3_BAD_RESPONSE " Unable to lock directory\r\n" <br>#define ERROR_UNKNOWN_MESSAGE   POP3_BAD_RESPONSE " Unknown message\r\n" <br>#define ERROR_READ_FAILED_S     POP3_BAD_RESPONSE " Unable to read directory\r\n" <br>#define ERROR_SERVER_FAILURE    POP3_BAD_RESPONSE " General failure on server\r\n" <br> <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Function:   Pop3CrackCommand <br>// <br>//  Synopsis:   Takes an input buffer as received from a client, and cracks <br>//              it to determine the command to execute <br>// <br>//  Arguments:  [Request]    -- Input buffer <br>//              [RequestLen] -- Input buffer length <br>// <br>//  History:    1-11-95   RichardW   Created <br>// <br>//  Notes: <br>// <br>//---------------------------------------------------------------------------- <br>int <br>Pop3CrackCommand( <br>    PUCHAR      Request, <br>    DWORD       RequestLen) <br>{ <br>    int i; <br> <br>    if (RequestLen &lt; 4) <br>    { <br>        return(-1); <br>    } <br> <br>    for (i = 0; i &lt; MAX_POP3_COMMAND ; i++ ) <br>    { <br>        if (_strnicmp((PCHAR) Request, PopCommands[i], 4) == 0 ) <br>        { <br>            return(i); <br>        } <br>    } <br> <br>    return(-1); <br>} <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Function:   CreatePop3Context <br>// <br>//  Synopsis:   Creates a client context to keep associated with the socket <br>// <br>//  Arguments:  (none) <br>// <br>//  History:    1-11-95   RichardW   Created <br>// <br>//  Notes: <br>// <br>//---------------------------------------------------------------------------- <br>PVOID <br>CreatePop3Context(void) <br>{ <br>    PPopContext pContext; <br> <br>    pContext = LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, sizeof(PopContext)); <br>    if (pContext) <br>    { <br>        pContext-&gt;State = PopAuthorization; <br>        ReportServiceEvent( <br>            EVENTLOG_INFORMATION_TYPE, <br>            POP3EVENT_USER_CONNECT, <br>            0, NULL, 0); <br>    } <br>    return(pContext); <br>} <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Function:   DeletePop3Context <br>// <br>//  Synopsis:   Gets rid of the context when the socket closes <br>// <br>//  Arguments:  [pvContext] -- <br>// <br>//  History:    1-11-95   RichardW   Created <br>// <br>//  Notes: <br>// <br>//---------------------------------------------------------------------------- <br>VOID <br>DeletePop3Context(PVOID pvContext) <br>{ <br>    PPopContext pContext; <br> <br>    pContext = (PPopContext) pvContext; <br> <br>    if (pContext-&gt;pDirectory) <br>    { <br>        FreeMailDirectory(pContext-&gt;pDirectory); <br>        UnlockMailDirectory(pContext-&gt;hDirectoryLock); <br>        CloseHandle(pContext-&gt;hUserToken); <br>    } <br> <br>    LocalFree(pContext); <br> <br>} <br> <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Function:   AllocAndCopyString <br>// <br>//  Synopsis:   Copies a string into local alloc memory, so that socket code <br>//              can send it off, then free it. <br>// <br>//  Arguments:  [pszString] -- string to copy <br>//              [pcbString] -- returned length of string <br>// <br>//  History:    1-11-95   RichardW   Created <br>// <br>//  Notes: <br>// <br>//---------------------------------------------------------------------------- <br>PUCHAR <br>AllocAndCopyString( <br>    PCHAR   pszString, <br>    PDWORD  pcbString) <br>{ <br>    PCHAR   pszNewString; <br> <br>    *pcbString = strlen(pszString); <br>    pszNewString = LocalAlloc(LMEM_FIXED, *pcbString + 1); <br>    if (pszNewString) <br>    { <br>        strcpy(pszNewString, pszString); <br>    } <br>    return((PUCHAR) pszNewString); <br>} <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Function:   HeloDispatch <br>// <br>//  Synopsis:   Handles the HELO command, which, perversely, never gets sent <br>//              by most clients. <br>// <br>//  Arguments:  [pContext]        -- <br>//              [InputBuffer]     -- <br>//              [InputBufferLen]  -- <br>//              [SendHandle]      -- <br>//              [OutputBuffer]    -- <br>//              [OutputBufferLen] -- <br>// <br>//  History:    1-11-95   RichardW   Created <br>// <br>//  Notes: <br>// <br>//---------------------------------------------------------------------------- <br>Pop3Disposition <br>HeloDispatch( <br>    PPopContext pContext, <br>    PUCHAR      InputBuffer, <br>    DWORD       InputBufferLen, <br>    PHANDLE     SendHandle, <br>    PUCHAR *    OutputBuffer, <br>    PDWORD      OutputBufferLen) <br>{ <br>    DebugLog((DEB_TRACE_PROT, "Received HELO\n")); <br> <br>    // <br>    // Verify context, and that the context says we can receive this command <br>    // <br> <br>    if (!pContext) <br>    { <br>        return(Pop3_Discard); <br>    } <br> <br>    if ((pContext-&gt;State == PopTransact) || <br>        (pContext-&gt;State == PopUpdate) ) <br>    { <br>        *OutputBuffer = ERROR_POP3_INVALID_STATE; <br>        *OutputBufferLen = sizeof(ERROR_POP3_INVALID_STATE); <br>        return(Pop3_SendError); <br>    } <br> <br>    // <br>    // Put us into Authorization state <br>    // <br>    pContext-&gt;State = PopAuthorization; <br> <br>    // <br>    // No file, but copy the banner string and return it. <br>    // <br>    *SendHandle = NULL; <br>    *OutputBuffer = AllocAndCopyString(BANNER_STRING, OutputBufferLen); <br> <br>    return(Pop3_SendBuffer); <br> <br>} <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Function:   UserDispatch <br>// <br>//  Synopsis:   Handles the USER command <br>// <br>//  Arguments:  [pContext]        -- <br>//              [InputBuffer]     -- <br>//              [InputBufferLen]  -- <br>//              [SendHandle]      -- <br>//              [OutputBuffer]    -- <br>//              [OutputBufferLen] -- <br>// <br>//  History:    1-11-95   RichardW   Created <br>// <br>//  Notes: <br>// <br>//---------------------------------------------------------------------------- <br>Pop3Disposition <br>UserDispatch( <br>    PPopContext pContext, <br>    PUCHAR      InputBuffer, <br>    DWORD       InputBufferLen, <br>    PHANDLE     SendHandle, <br>    PUCHAR *    OutputBuffer, <br>    PDWORD      OutputBufferLen) <br>{ <br>    char * Src; <br>    char * Dst; <br> <br>    DebugLog((DEB_TRACE_PROT, "Received USER\n")); <br> <br> <br>    // <br>    // Verify context, and that the context says we can receive this command <br>    // <br>    if (!pContext) <br>    { <br>        return(Pop3_Discard); <br>    } <br> <br>    if (pContext-&gt;State != PopAuthorization) <br>    { <br>        *OutputBuffer = ERROR_POP3_INVALID_STATE; <br>        *OutputBufferLen = sizeof(ERROR_POP3_INVALID_STATE); <br>        return(Pop3_SendError); <br>    } <br> <br>    if (InputBufferLen - POP3_COMMAND_LENGTH &gt; USERNAME_LENGTH) <br>    { <br>        *OutputBuffer = ERROR_INVALID_USERNAME; <br>        *OutputBufferLen = sizeof(ERROR_INVALID_USERNAME); <br>        return(Pop3_SendError); <br>    } <br> <br>    // <br>    // Copy in the user name without trailing \r or \n. <br>    // <br> <br>    Src = InputBuffer + POP3_COMMAND_LENGTH; <br>    Dst = pContext-&gt;UserName; <br>    while (*Src &amp;&amp; (*Src != '\r') &amp;&amp; (*Src != '\n')) <br>    { <br>        *Dst++ = *Src++; <br>    } <br>    *Dst = '\0'; <br> <br>    // <br>    // Set the state so that we are expecting the password <br>    // <br>    pContext-&gt;State = PopAuthorization2; <br> <br>    *SendHandle = NULL; <br>    *OutputBuffer = AllocAndCopyString(POP3_GOOD_RESPLINE, OutputBufferLen); <br> <br>    return(Pop3_SendBuffer); <br> <br>} <br> <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Function:   PassDispatch <br>// <br>//  Synopsis:   Handles the PASS command <br>// <br>//  Arguments:  [pContext]        -- <br>//              [InputBuffer]     -- <br>//              [InputBufferLen]  -- <br>//              [SendHandle]      -- <br>//              [OutputBuffer]    -- <br>//              [OutputBufferLen] -- <br>// <br>//  History:    1-11-95   RichardW   Created <br>// <br>//  Notes: <br>// <br>//---------------------------------------------------------------------------- <br>Pop3Disposition <br>PassDispatch( <br>    PPopContext pContext, <br>    PUCHAR      InputBuffer, <br>    DWORD       InputBufferLen, <br>    PHANDLE     SendHandle, <br>    PUCHAR *    OutputBuffer, <br>    PDWORD      OutputBufferLen) <br>{ <br>    CHAR    pass[MAX_PATH]; <br>    char *  Dst; <br>    char *  Src; <br> <br> <br>    DebugLog((DEB_TRACE_PROT, "Received PASS\n")); <br> <br> <br>    // <br>    // Verify context, and that the context says we can receive this command <br>    // <br> <br>    if (!pContext) <br>    { <br>        return(Pop3_Discard); <br>    } <br> <br>    if (pContext-&gt;State != PopAuthorization2) <br>    { <br>        *OutputBuffer = ERROR_POP3_INVALID_STATE; <br>        *OutputBufferLen = sizeof(ERROR_POP3_INVALID_STATE); <br>        return(Pop3_SendError); <br>    } <br> <br>    // <br>    // Copy in the password without trailing \r or \n. <br>    // <br> <br>    Src = InputBuffer + POP3_COMMAND_LENGTH; <br>    Dst = pass; <br>    while (*Src &amp;&amp; (*Src != '\r') &amp;&amp; (*Src != '\n')) <br>    { <br>        *Dst++ = *Src++; <br>    } <br>    *Dst = '\0'; <br> <br> <br>#ifdef SECURE_BUILD <br> <br>    // <br>    // Attempt to log the user on, meaning verify the name and password <br>    // provided, and get a token back.  The "." we're passing in means <br>    // use the domain if this machine is part of a domain, or use the local <br>    // accounts domain. <br>    // <br>    if (!LogonUserA(    pContext-&gt;UserName, <br>                        ".", <br>                        pass, <br>                        LOGON32_LOGON_INTERACTIVE, <br>                        LOGON32_PROVIDER_DEFAULT, <br>                        &amp;pContext-&gt;hUserToken) ) <br>    { <br>        pContext-&gt;State = PopAuthorization; <br>        ReportServiceEvent( <br>            EVENTLOG_WARNING_TYPE, <br>            POP3EVENT_LOGON_FAILURE, <br>            0, NULL, <br>            0); <br> <br>        *OutputBuffer = ERROR_AUTH_FAILED; <br>        *OutputBufferLen = sizeof(ERROR_AUTH_FAILED); <br>        return(Pop3_SendError); <br>    } <br> <br>#endif <br> <br>    // <br>    // Now, open and read the mail drop directory <br>    // <br> <br>    pContext-&gt;hDirectoryLock = LockMailDirectory(pContext-&gt;hUserToken, <br>                                                 pContext-&gt;UserName); <br> <br>    if (!pContext-&gt;hDirectoryLock) <br>    { <br>        // <br>        // Could not lock directory.  Basically, we shut down this connection, <br>        // and let it go. <br>        // <br> <br>        DebugLog((DEB_ERROR, "Unable to lock directory, %d\n", GetLastError())); <br> <br>        pContext-&gt;State = PopAuthorization; <br> <br>        // <br>        // Close the token.  This logs the user off. <br>        // <br>        CloseHandle(pContext-&gt;hUserToken); <br>        pContext-&gt;hUserToken = NULL; <br> <br>        *OutputBuffer = ERROR_LOCK_FAILED_S; <br>        *OutputBufferLen = sizeof(ERROR_LOCK_FAILED_S); <br>        return(Pop3_SendError); <br>    } <br> <br>    pContext-&gt;pDirectory = ReadMailDirectory(pContext-&gt;hUserToken, <br>                                             pContext-&gt;UserName); <br> <br>    if (!pContext-&gt;pDirectory) <br>    { <br>        // <br>        // Couldn't read the directory.  So, we panic and <br>        // throw it all away. <br>        // <br> <br>        DebugLog((DEB_ERROR, "Unable to read directory!\n")); <br> <br>        pContext-&gt;State = PopAuthorization; <br>        UnlockMailDirectory(pContext-&gt;hDirectoryLock); <br>        pContext-&gt;hDirectoryLock = NULL; <br>        CloseHandle(pContext-&gt;hUserToken); <br> <br>        *OutputBuffer = ERROR_READ_FAILED_S; <br>        *OutputBufferLen = sizeof(ERROR_LOCK_FAILED_S); <br>        return(Pop3_SendError); <br>    } <br> <br>    pContext-&gt;State = PopTransact; <br>    *OutputBuffer = AllocAndCopyString(POP3_GOOD_RESPLINE, OutputBufferLen); <br>    return(Pop3_SendBuffer); <br> <br>} <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Function:   QuitDispatch <br>// <br>//  Synopsis:   Handles the QUIT command <br>// <br>//  Arguments:  [pContext]        -- <br>//              [InputBuffer]     -- <br>//              [InputBufferLen]  -- <br>//              [SendHandle]      -- <br>//              [OutputBuffer]    -- <br>//              [OutputBufferLen] -- <br>// <br>//  History:    1-11-95   RichardW   Created <br>// <br>//  Notes: <br>// <br>//---------------------------------------------------------------------------- <br>Pop3Disposition <br>QuitDispatch( <br>    PPopContext pContext, <br>    PUCHAR      InputBuffer, <br>    DWORD       InputBufferLen, <br>    PHANDLE     SendHandle, <br>    PUCHAR *    OutputBuffer, <br>    PDWORD      OutputBufferLen) <br>{ <br> <br>    DebugLog((DEB_TRACE_PROT, "Received QUIT\n")); <br> <br>    // <br>    // Verify context, and that the context says we can receive this command <br>    // <br> <br>    if (!pContext) <br>    { <br>        return(Pop3_Discard); <br>    } <br> <br>    if (pContext-&gt;State == PopTransact) <br>    { <br>        pContext-&gt;State = PopUpdate; <br> <br>        CommitMailDirectory(pContext-&gt;pDirectory, pContext-&gt;hUserToken); <br>        FreeMailDirectory(pContext-&gt;pDirectory); <br>        UnlockMailDirectory(pContext-&gt;hDirectoryLock); <br>        CloseHandle(pContext-&gt;hUserToken); <br>    } <br> <br>    pContext-&gt;State = PopShutdown; <br> <br>    *OutputBuffer = AllocAndCopyString(POP3_GOOD_RESPLINE, OutputBufferLen); <br> <br>    return(Pop3_SendBuffer); <br> <br>} <br> <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Function:   StatDispatch <br>// <br>//  Synopsis:   Handles the STAT command <br>// <br>//  Arguments:  [pContext]        -- <br>//              [InputBuffer]     -- <br>//              [InputBufferLen]  -- <br>//              [SendHandle]      -- <br>//              [OutputBuffer]    -- <br>//              [OutputBufferLen] -- <br>// <br>//  History:    1-11-95   RichardW   Created <br>// <br>//  Notes: <br>// <br>//---------------------------------------------------------------------------- <br>Pop3Disposition <br>StatDispatch( <br>    PPopContext pContext, <br>    PUCHAR      InputBuffer, <br>    DWORD       InputBufferLen, <br>    PHANDLE     SendHandle, <br>    PUCHAR *    OutputBuffer, <br>    PDWORD      OutputBufferLen) <br>{ <br> <br>    char    StatResp[80]; <br> <br>    DebugLog((DEB_TRACE_PROT, "Received STAT\n")); <br> <br>    // <br>    // Verify context, and that the context says we can receive this command <br>    // <br> <br>    if (!pContext) <br>    { <br>        return(Pop3_Discard); <br>    } <br> <br>    if (pContext-&gt;State != PopTransact) <br>    { <br>        *OutputBuffer = ERROR_POP3_INVALID_STATE; <br>        *OutputBufferLen = sizeof(ERROR_POP3_INVALID_STATE); <br>        return(Pop3_SendError); <br>    } <br> <br>    // <br>    // Print the response into the buffer, then copy it and return it. <br>    // <br> <br>    sprintf(StatResp, POP3_STAT_RESPONSE, pContext-&gt;pDirectory-&gt;cAvailMessages, <br>                        pContext-&gt;pDirectory-&gt;AvailSize); <br> <br>    *OutputBuffer = AllocAndCopyString(StatResp, OutputBufferLen); <br>    *SendHandle = NULL; <br> <br>    DebugLog((DEB_TRACE_PROT, "STAT: Sending %s\n", StatResp)); <br> <br>    return(Pop3_SendBuffer); <br> <br>} <br> <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Function:   ListDispatch <br>// <br>//  Synopsis:   Handles the LIST command <br>// <br>//  Arguments:  [pContext]        -- <br>//              [InputBuffer]     -- <br>//              [InputBufferLen]  -- <br>//              [SendHandle]      -- <br>//              [OutputBuffer]    -- <br>//              [OutputBufferLen] -- <br>// <br>//  History:    1-11-95   RichardW   Created <br>// <br>//  Notes: <br>// <br>//---------------------------------------------------------------------------- <br>Pop3Disposition <br>ListDispatch( <br>    PPopContext pContext, <br>    PUCHAR      InputBuffer, <br>    DWORD       InputBufferLen, <br>    PHANDLE     SendHandle, <br>    PUCHAR *    OutputBuffer, <br>    PDWORD      OutputBufferLen) <br>{ <br>    PCHAR       pszBuffer; <br>    PCHAR       pszWalk; <br>    DWORD       TotalAlloc; <br>    DWORD       UsedAlloc; <br>    DWORD       CharCount; <br>    DWORD       SingleMessage; <br>    DWORD       i; <br>    char        SingleLine[80]; <br> <br> <br>    DebugLog((DEB_TRACE_PROT, "Received LIST\n")); <br> <br>    // <br>    // Verify context, and that the context says we can receive this command <br>    // <br> <br>    if (!pContext) <br>    { <br>        return(Pop3_Discard); <br>    } <br> <br>    if (pContext-&gt;State != PopTransact) <br>    { <br>        *OutputBuffer = ERROR_POP3_INVALID_STATE; <br>        *OutputBufferLen = sizeof(ERROR_POP3_INVALID_STATE); <br>        return(Pop3_SendError); <br>    } <br> <br>    // <br>    // If there is a parameter, process it so we can find out what specific <br>    // message they want <br>    // <br> <br>    if (InputBufferLen &gt; POP3_COMMAND_LENGTH) <br>    { <br>        SingleMessage = (DWORD) -1; <br>        sscanf(&amp;InputBuffer[POP3_COMMAND_LENGTH], " %d", &amp;SingleMessage); <br> <br>        // <br>        // Pop is 1-based, we're 0-based <br>        // <br>        SingleMessage--; <br> <br>        if ((SingleMessage &gt; pContext-&gt;pDirectory-&gt;cMessages) || <br>            (pContext-&gt;pDirectory-&gt;Messages[SingleMessage].Flags &amp; POP3_MESSAGE_DELETE)) <br>        { <br>            *OutputBuffer = ERROR_UNKNOWN_MESSAGE; <br>            *OutputBufferLen = sizeof(ERROR_UNKNOWN_MESSAGE); <br>            return(Pop3_SendError); <br>        } <br> <br>        sprintf(SingleLine, POP3_STAT_RESPONSE, SingleMessage + 1, <br>                    pContext-&gt;pDirectory-&gt;Messages[SingleMessage].Size); <br> <br>        *OutputBuffer = AllocAndCopyString(SingleLine, OutputBufferLen); <br>        DebugLog((DEB_TRACE_PROT, "LIST: Sending %s", SingleLine)); <br>        return(Pop3_SendBuffer); <br>    } <br> <br>    // <br>    // If they want the whole list, send the whole list <br>    // <br>    TotalAlloc = pContext-&gt;pDirectory-&gt;cAvailMessages * 16 + 24; <br>    pszBuffer = LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, TotalAlloc); <br>    if (!pszBuffer) <br>    { <br>        *OutputBuffer = ERROR_SERVER_FAILURE; <br>        *OutputBufferLen = sizeof(ERROR_SERVER_FAILURE); <br>        return(Pop3_SendError); <br>         <br>    } <br>    pszWalk = pszBuffer; <br>    UsedAlloc = 0; <br> <br>    // <br>    // Copy the header <br>    // <br>    CharCount = sprintf(pszWalk, POP3_STAT_RESPONSE, <br>                        pContext-&gt;pDirectory-&gt;cAvailMessages, <br>                        pContext-&gt;pDirectory-&gt;AvailSize); <br> <br>    pszWalk += CharCount; <br>    UsedAlloc += CharCount; <br>    for (i = 0; i &lt; pContext-&gt;pDirectory-&gt;cMessages ; i++ ) <br>    { <br>        // <br>        // For every message not marked deleted, copy it in <br>        // <br>        if ((pContext-&gt;pDirectory-&gt;Messages[i].Flags &amp; POP3_MESSAGE_DELETE) == 0) <br>        { <br>            CharCount = sprintf(pszWalk, POP3_LIST_RESPLINE, <br>                                i+1, pContext-&gt;pDirectory-&gt;Messages[i].Size); <br>            pszWalk += CharCount; <br>            UsedAlloc += CharCount; <br>        } <br>    } <br> <br>    strcpy(pszWalk, POP3_TERMINATOR); <br>    UsedAlloc += 3; <br> <br>    *OutputBuffer = pszBuffer; <br>    *OutputBufferLen = UsedAlloc; <br> <br>    DebugLog((DEB_TRACE_PROT, "LIST: Sending %s\n", pszBuffer)); <br> <br>    return(Pop3_SendBuffer); <br> <br>} <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Function:   RetrDispatch <br>// <br>//  Synopsis:   Handles the RETR command <br>// <br>//  Arguments:  [pContext]        -- <br>//              [InputBuffer]     -- <br>//              [InputBufferLen]  -- <br>//              [SendHandle]      -- <br>//              [OutputBuffer]    -- <br>//              [OutputBufferLen] -- <br>// <br>//  History:    1-11-95   RichardW   Created <br>// <br>//  Notes: <br>// <br>//---------------------------------------------------------------------------- <br>Pop3Disposition <br>RetrDispatch( <br>    PPopContext pContext, <br>    PUCHAR      InputBuffer, <br>    DWORD       InputBufferLen, <br>    PHANDLE     SendHandle, <br>    PUCHAR *    OutputBuffer, <br>    PDWORD      OutputBufferLen) <br>{ <br>    DWORD   MessageId; <br>    char    Line[40]; <br> <br> <br>    DebugLog((DEB_TRACE_PROT, "Received RETR\n")); <br> <br>    // <br>    // Verify context, and that the context says we can receive this command <br>    // <br> <br>    if (!pContext) <br>    { <br>        return(Pop3_Discard); <br>    } <br> <br>    if (pContext-&gt;State != PopTransact) <br>    { <br>        *OutputBuffer = ERROR_POP3_INVALID_STATE; <br>        *OutputBufferLen = sizeof(ERROR_POP3_INVALID_STATE); <br>        return(Pop3_SendError); <br>    } <br> <br>    MessageId = (DWORD) -1; <br> <br>    if (InputBufferLen &gt; POP3_COMMAND_LENGTH) <br>    { <br>        sscanf(&amp;InputBuffer[POP3_COMMAND_LENGTH], "%d", &amp;MessageId); <br>    } <br> <br>    // <br>    // Pop is 1-based, we're 0-based <br>    // <br>    MessageId--; <br> <br>    if ((MessageId &gt; pContext-&gt;pDirectory-&gt;cMessages) || <br>        (pContext-&gt;pDirectory-&gt;Messages[MessageId].Flags &amp; POP3_MESSAGE_DELETE)) <br>    { <br>        *OutputBuffer = ERROR_UNKNOWN_MESSAGE; <br>        *OutputBufferLen = sizeof(ERROR_UNKNOWN_MESSAGE); <br>        return(Pop3_SendError); <br>    } <br> <br> <br>    // <br>    // Open the mail message.  We pass in the user's token, so that <br>    // we can impersonate when we do the open. <br>    // <br> <br>    *SendHandle = OpenMailMessage(  MessageId, <br>                                    pContext-&gt;pDirectory, <br>                                    pContext-&gt;hUserToken); <br> <br>    if (*SendHandle) <br>    { <br>        sprintf(Line, POP3_RETR_RESPONSE, <br>                pContext-&gt;pDirectory-&gt;Messages[MessageId].Size); <br>        *OutputBuffer = AllocAndCopyString(Line, OutputBufferLen); <br>        if (pContext-&gt;pDirectory-&gt;NextMessage &lt; MessageId) <br>        { <br>            pContext-&gt;pDirectory-&gt;NextMessage = MessageId; <br>        } <br> <br>        return(Pop3_SendBufferThenFile); <br> <br>    } <br> <br>    *OutputBuffer = ERROR_SERVER_FAILURE; <br>    *OutputBufferLen = sizeof(ERROR_SERVER_FAILURE); <br>    return(Pop3_SendError); <br>} <br> <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Function:   DeleDispatch <br>// <br>//  Synopsis:   Handles the DELE command <br>// <br>//  Arguments:  [pContext]        -- <br>//              [InputBuffer]     -- <br>//              [InputBufferLen]  -- <br>//              [SendHandle]      -- <br>//              [OutputBuffer]    -- <br>//              [OutputBufferLen] -- <br>// <br>//  History:    1-11-95   RichardW   Created <br>// <br>//  Notes: <br>// <br>//---------------------------------------------------------------------------- <br>Pop3Disposition <br>DeleDispatch( <br>    PPopContext pContext, <br>    PUCHAR      InputBuffer, <br>    DWORD       InputBufferLen, <br>    PHANDLE     SendHandle, <br>    PUCHAR *    OutputBuffer, <br>    PDWORD      OutputBufferLen) <br>{ <br>    DWORD   MessageId; <br> <br> <br>    DebugLog((DEB_TRACE_PROT, "Received DELE\n")); <br> <br>    // <br>    // Verify context, and that the context says we can receive this command <br>    // <br> <br>    if (!pContext) <br>    { <br>        return(Pop3_Discard); <br>    } <br> <br>    if (pContext-&gt;State != PopTransact) <br>    { <br>        *OutputBuffer = ERROR_POP3_INVALID_STATE; <br>        *OutputBufferLen = sizeof(ERROR_POP3_INVALID_STATE); <br>        return(Pop3_SendError); <br>    } <br> <br>    MessageId = (DWORD) -1; <br> <br>    if (InputBufferLen &gt; POP3_COMMAND_LENGTH) <br>    { <br>        sscanf(&amp;InputBuffer[POP3_COMMAND_LENGTH], "%d", &amp;MessageId); <br>    } <br> <br>    // <br>    // Pop is 1-based, we're 0-based <br>    // <br>    MessageId--; <br> <br>    if (MessageId &gt; pContext-&gt;pDirectory-&gt;cMessages || <br>        (pContext-&gt;pDirectory-&gt;Messages[MessageId].Flags &amp; POP3_MESSAGE_DELETE)) <br>    { <br>        *OutputBuffer = ERROR_UNKNOWN_MESSAGE; <br>        *OutputBufferLen = sizeof(ERROR_UNKNOWN_MESSAGE); <br>        return(Pop3_SendError); <br>    } <br> <br>    // <br>    // Update directory with "deleted" file <br>    // <br>    pContext-&gt;pDirectory-&gt;Messages[MessageId].Flags |= POP3_MESSAGE_DELETE; <br>    pContext-&gt;pDirectory-&gt;cAvailMessages--; <br>    pContext-&gt;pDirectory-&gt;AvailSize -= pContext-&gt;pDirectory-&gt;Messages[MessageId].Size; <br> <br>    *OutputBuffer = AllocAndCopyString(POP3_GOOD_RESPLINE, OutputBufferLen); <br>    return(Pop3_SendBuffer); <br>} <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Function:   NoopDispatch <br>// <br>//  Synopsis:   Handles the NOOP command <br>// <br>//  Arguments:  [pContext]        -- <br>//              [InputBuffer]     -- <br>//              [InputBufferLen]  -- <br>//              [SendHandle]      -- <br>//              [OutputBuffer]    -- <br>//              [OutputBufferLen] -- <br>// <br>//  History:    1-11-95   RichardW   Created <br>// <br>//  Notes: <br>// <br>//---------------------------------------------------------------------------- <br>Pop3Disposition <br>NoopDispatch( <br>    PPopContext pContext, <br>    PUCHAR      InputBuffer, <br>    DWORD       InputBufferLen, <br>    PHANDLE     SendHandle, <br>    PUCHAR *    OutputBuffer, <br>    PDWORD      OutputBufferLen) <br>{ <br> <br>    DebugLog((DEB_TRACE_PROT, "Received NOOP\n")); <br> <br>    // <br>    // Verify context, and that the context says we can receive this command <br>    // <br> <br>    if (!pContext) <br>    { <br>        return(Pop3_Discard); <br>    } <br> <br>    if (pContext-&gt;State != PopTransact) <br>    { <br>        *OutputBuffer = ERROR_POP3_INVALID_STATE; <br>        *OutputBufferLen = sizeof(ERROR_POP3_INVALID_STATE); <br>        return(Pop3_SendError); <br>    } <br> <br>    *OutputBuffer = AllocAndCopyString(POP3_GOOD_RESPLINE, OutputBufferLen); <br>    return(Pop3_SendBuffer); <br>} <br> <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Function:   LastDispatch <br>// <br>//  Synopsis:   Handles the LAST command <br>// <br>//  Arguments:  [pContext]        -- <br>//              [InputBuffer]     -- <br>//              [InputBufferLen]  -- <br>//              [SendHandle]      -- <br>//              [OutputBuffer]    -- <br>//              [OutputBufferLen] -- <br>// <br>//  History:    1-11-95   RichardW   Created <br>// <br>//  Notes: <br>// <br>//---------------------------------------------------------------------------- <br>Pop3Disposition <br>LastDispatch( <br>    PPopContext pContext, <br>    PUCHAR      InputBuffer, <br>    DWORD       InputBufferLen, <br>    PHANDLE     SendHandle, <br>    PUCHAR *    OutputBuffer, <br>    PDWORD      OutputBufferLen) <br>{ <br>    char    Line[40]; <br> <br>    DebugLog((DEB_TRACE_PROT, "Received LAST\n")); <br> <br>    if (!pContext) <br>    { <br>        return(Pop3_Discard); <br>    } <br> <br>    if (pContext-&gt;State != PopTransact) <br>    { <br>        *OutputBuffer = ERROR_POP3_INVALID_STATE; <br>        *OutputBufferLen = sizeof(ERROR_POP3_INVALID_STATE); <br>        return(Pop3_SendError); <br>    } <br> <br>    sprintf(Line, POP3_LAST_RESPONSE, pContext-&gt;pDirectory-&gt;NextMessage+1); <br>    *OutputBuffer = AllocAndCopyString(Line, OutputBufferLen); <br> <br>    return(Pop3_SendBuffer); <br>} <br> <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Function:   RsetDispatch <br>// <br>//  Synopsis:   Handles the RSET command <br>// <br>//  Arguments:  [pContext]        -- <br>//              [InputBuffer]     -- <br>//              [InputBufferLen]  -- <br>//              [SendHandle]      -- <br>//              [OutputBuffer]    -- <br>//              [OutputBufferLen] -- <br>// <br>//  History:    1-11-95   RichardW   Created <br>// <br>//  Notes: <br>// <br>//---------------------------------------------------------------------------- <br>Pop3Disposition <br>RsetDispatch( <br>    PPopContext pContext, <br>    PUCHAR      InputBuffer, <br>    DWORD       InputBufferLen, <br>    PHANDLE     SendHandle, <br>    PUCHAR *    OutputBuffer, <br>    PDWORD      OutputBufferLen) <br>{ <br>    DWORD   i; <br> <br>    DebugLog((DEB_TRACE_PROT, "Received LAST\n")); </code></pre>
<p>
</p>
<pre><code><br>    if (!pContext) <br>    { <br>        return(Pop3_Discard); <br>    } <br> <br>    if (pContext-&gt;State != PopTransact) <br>    { <br>        *OutputBuffer = ERROR_POP3_INVALID_STATE; <br>        *OutputBufferLen = sizeof(ERROR_POP3_INVALID_STATE); <br>        return(Pop3_SendError); <br>    } <br> <br>    for (i = 0; i &lt; pContext-&gt;pDirectory-&gt;cMessages ; i++ ) <br>    { <br>        pContext-&gt;pDirectory-&gt;Messages[i].Flags = 0; <br>    } <br> <br>    pContext-&gt;pDirectory-&gt;NextMessage = 0; <br>    pContext-&gt;pDirectory-&gt;cAvailMessages = pContext-&gt;pDirectory-&gt;cMessages; <br>    pContext-&gt;pDirectory-&gt;AvailSize = pContext-&gt;pDirectory-&gt;TotalSize; <br> <br>    *OutputBuffer = AllocAndCopyString(POP3_GOOD_RESPLINE, OutputBufferLen); <br>    return(Pop3_SendBuffer); <br>} <br> <br> <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Function:   Pop3Dispatch <br>// <br>//  Synopsis:   Dispatch the command <br>// <br>//  Arguments:  [pContext]        --    Context for client connection <br>//              [InputBuffer]     --    Input Buffer (stuff from client) <br>//              [InputBufferLen]  --    How much stuff <br>//              [SendHandle]      --    Handle to Transmit, if so required <br>//              [OutputBuffer]    --    (returned) pointer of stuff to send <br>//              [OutputBufferLen] --    (returned) size of stuff to send <br>// <br>//  Returns:    a Pop3Disposition, which indicates what the socket code <br>//              should do with this stuff.  See pop3ctx.h for the dispositions <br>// <br>//  History:    1-11-95   RichardW   Created <br>// <br>//  Notes: <br>// <br>//---------------------------------------------------------------------------- <br>Pop3Disposition <br>Pop3Dispatch( <br>    PVOID       pContext, <br>    PUCHAR      InputBuffer, <br>    DWORD       InputBufferLen, <br>    PHANDLE     SendHandle, <br>    PUCHAR *    OutputBuffer, <br>    PDWORD      OutputBufferLen <br>    ) <br> <br>{ <br>    PPopContext pPopContext; <br>    int     Command; <br> <br>    pPopContext = (PPopContext) pContext; <br> <br>    // <br>    // Null terminate, so string functions won't get confused later. <br>    // <br> <br>    InputBuffer[InputBufferLen] = L'\0'; <br> <br>    // <br>    // Figure the command out <br>    // <br> <br>    Command = Pop3CrackCommand(InputBuffer, InputBufferLen); <br> <br>    // <br>    // If it didn't parse, throw it away <br>    // <br>    if (Command == -1) <br>    { <br>        return(Pop3_Discard); <br>    } <br> <br>    // <br>    // Let the command handlers do their thing <br>    // <br>    return(Pop3DispatchTable[Command](  pPopContext, <br>                                        InputBuffer, <br>                                        InputBufferLen, <br>                                        SendHandle, <br>                                        OutputBuffer, <br>                                        OutputBufferLen) ); <br> <br> <br>} <br> <br>#if DBG <br> <br>// <br>// Interactive debug testing <br>// <br>void TestLoop(void) <br>{ <br>    char    InputBuffer[256]; <br>    DWORD   InputBufferLen; <br>    char *  OutputBuffer; <br>    DWORD   OutputBufferLen; <br>    HANDLE  hTest; <br>    PVOID   pContext; <br>    Pop3Disposition Disposition; <br>    extern WCHAR BaseDirectory[]; <br> <br>    printf("-------------------\n"); <br>    printf("Interactive Test Mode\n"); <br> <br>    pContext = CreatePop3Context(); <br>    do <br>    { <br>        gets(InputBuffer); <br>        InputBufferLen = strlen(InputBuffer); <br>        if (InputBufferLen) <br>        { <br>            Disposition = Pop3Dispatch( pContext, <br>                                        InputBuffer, <br>                                        InputBufferLen, <br>                                        &amp;hTest, <br>                                        &amp;OutputBuffer, <br>                                        &amp;OutputBufferLen); <br> <br>            switch (Disposition) <br>            { <br>                case Pop3_Discard: <br>                    printf("[Discard message]\n"); <br>                    break; <br> <br>                case Pop3_SendError: <br>                    printf("%s", OutputBuffer); <br>                    break; <br> <br>                case Pop3_SendBuffer: <br>                    printf("%s", OutputBuffer); <br>                    LocalFree(OutputBuffer); <br>                    break; <br> <br>                case Pop3_SendFile: <br>                    printf("Transmit file %x\n", hTest); <br>                    printf(".\r\n"); <br>                    CloseHandle(hTest); <br>                    break; <br> <br>                case Pop3_SendBufferThenFile: <br>                    printf("%s", OutputBuffer); <br>                    printf("Transmit file %x\n", hTest); <br>                    printf(".\r\n"); <br>                    CloseHandle(hTest); <br>                    LocalFree(OutputBuffer); <br>                    break; <br> <br>                case Pop3_SendFileThenBuffer: <br>                    printf("Transmit file %x\n", hTest); <br>                    printf("%s", OutputBuffer); <br>                    CloseHandle(hTest); <br>                    LocalFree(OutputBuffer); <br>                    break; <br> <br>            } <br> <br>        } <br> <br>    } while (InputBufferLen); <br> <br>} <br>#endif </code></pre>
<p>&nbsp;</p></body>
</HTML>
