<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SOCKET.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6300"></a>SOCKET.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples. <br>*       Copyright 1992 - 1998 Microsoft Corporation. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  File:       pop3svr.c <br>// <br>//  Contents: <br>// <br>//  Classes: <br>// <br>//  Functions: <br>// <br>//---------------------------------------------------------------------------- <br> <br>#include "pop3srvp.h" <br>#pragma hdrstop <br> <br>extern BOOL bServiceTerminating; <br>extern SOCKET sListener; <br> <br>#define POP3_PORT 110 <br> <br>PCHAR Welcome = "+OK Welcome to the NT Example POP3 Server (POP3SRV)\r\n"; <br> <br>BOOL <br>AcceptClients ( <br>    HANDLE hCompletionPort <br>    ) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    This routine sets up a listening socket on the POP3 port, then <br>    loops accepting incoming connections from clients.  Whenever <br>    it gets a connection, it sends the greeting message and starts <br>    a read on the newly connected socket. <br> <br>Arguments: <br> <br>    hCompletionPort - the completion port that the POP3SRV worker  <br>        threads are waiting on.   <br> <br>Return Value: <br> <br>    BOOL - FALSE if there was an error in starting the listening <br>        socket. <br> <br>--*/ <br> <br>{ <br>    SOCKET s; <br>    SOCKADDR_IN sin; <br>    int err; <br>    BOOL bSuccess; <br>    PCLIENT_CONTEXT lpClientContext; <br>    DWORD dwBytesRead; <br>    int zero; <br> <br>    // <br>    // Create a listening socket that we'll use to accept incoming <br>    // conections. <br>    // <br> <br>    sListener = socket( AF_INET, SOCK_STREAM, 0 ); <br>    if ( sListener == INVALID_SOCKET ) { <br>        return FALSE; <br>    } <br> <br>    // <br>    // Bind the socket to the POP3 well-known port. <br>    // <br> <br>    sin.sin_family = AF_INET; <br>    sin.sin_port = htons( POP3_PORT ); <br>    sin.sin_addr.s_addr = INADDR_ANY; <br> <br>    err = bind( sListener, (LPSOCKADDR)&amp;sin, sizeof(sin) ); <br>    if ( err == SOCKET_ERROR ) { <br>        closesocket( sListener ); <br>        return FALSE; <br>    } <br> <br>    // <br>    // Listen for incoming connections on the socket. <br>    // <br> <br>    err = listen( sListener, 5 ); <br>    if ( err == SOCKET_ERROR ) { <br>        closesocket( sListener ); <br>        return FALSE; <br>    } <br> <br>    // <br>    // Loop forever accepting connections from clients. <br>    // <br> <br>    while ( TRUE ) { <br> <br>        s = accept( sListener, NULL, NULL ); <br>        if ( s == INVALID_SOCKET ) { <br>            closesocket( sListener ); <br>            return FALSE; <br>        } <br> <br>        // <br>        // If the service if terminating, exit this thread. <br>        // <br> <br>        if ( bServiceTerminating ) { <br>            return FALSE; <br>        } <br> <br>        // <br>        // Allocate a socket context for the new connection.  We use <br>        // this context structure to track socket-level information <br>        // about the client. <br>        // <br> <br>        lpClientContext = LocalAlloc( 0, sizeof(*lpClientContext) ); <br>        if ( lpClientContext == NULL ) { <br>            closesocket( s ); <br>            continue; <br>        } <br> <br>        // <br>        // Initialize the context structure. <br>        // <br> <br>        lpClientContext-&gt;Socket = s; <br>        lpClientContext-&gt;Context = CreatePop3Context( ); <br>        lpClientContext-&gt;Overlapped.Internal = 0; <br>        lpClientContext-&gt;Overlapped.InternalHigh = 0; <br>        lpClientContext-&gt;Overlapped.Offset = 0; <br>        lpClientContext-&gt;Overlapped.OffsetHigh = 0; <br>        lpClientContext-&gt;Overlapped.hEvent = NULL; <br> <br>        // <br>        // Send the welcome banner. <br>        // <br> <br>        err = send( s, Welcome, strlen(Welcome), 0 ); <br>        if ( err == SOCKET_ERROR ) { <br>            LocalFree( lpClientContext ); <br>            closesocket( s ); <br>            continue; <br>        } <br> <br>        // --- DavidTr: Slide 14(a) ---------------------------------------- <br>        // <br>        // Associate the new socket with a completion port. <br>        // <br> <br>        hCompletionPort = CreateIoCompletionPort( <br>                              (HANDLE)s, <br>                              hCompletionPort, <br>                              (DWORD)lpClientContext, <br>                              0 <br>                              ); <br>        if ( hCompletionPort == NULL ) { <br>            LocalFree( lpClientContext ); <br>            closesocket( s ); <br>            closesocket( sListener ); <br>            return FALSE; <br>        } <br> <br>        // --- DavidTr: Slide 16 ------------------------------------------- <br>        // <br>        // Disable send bufferring on the socket.  Setting SO_SNDBUF <br>        // to 0 causes winsock to stop bufferring sends and perform <br>        // sends directly from our buffers, thereby reducing CPU <br>        // usage. <br>        // <br> <br>        zero = 0; <br>        err = setsockopt( s, SOL_SOCKET, SO_SNDBUF, (char *)&amp;zero, sizeof(zero) ); <br>        if ( err == SOCKET_ERROR ) { <br>            LocalFree( lpClientContext ); <br>            closesocket( s ); <br>            closesocket( sListener ); <br>            return FALSE; <br>        } <br> <br>        // <br>        // Start an overlapped read on the socket.  This read will <br>        // complete in one of the worker threads, which will continue <br>        // processing of the client. <br>        // <br> <br>        lpClientContext-&gt;LastClientIo = ClientIoRead; <br>        lpClientContext-&gt;BytesReadSoFar = 0; <br> <br>        bSuccess = ReadFile( <br>                       (HANDLE)s, <br>                       lpClientContext-&gt;Buffer, <br>                       sizeof(lpClientContext-&gt;Buffer), <br>                       &amp;dwBytesRead, <br>                       &amp;lpClientContext-&gt;Overlapped <br>                       ); <br>        if ( !bSuccess &amp;&amp; GetLastError( ) != ERROR_IO_PENDING ) { <br>            LocalFree( lpClientContext ); <br>            closesocket( s ); <br>            continue; <br>        } <br>    } <br> <br>} // AcceptClients <br> <br>  <br>VOID <br>CloseClient ( <br>    PCLIENT_CONTEXT lpClientContext, <br>    BOOL bGraceful <br>    ) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    Terminates a connection with a client and frees up resources. <br> <br>Arguments: <br> <br>    lpClientContext - a pointer to the context structure that contains <br>        information about this client. <br> <br>    bGraceful - TRUE if the close should be graceful, FALSE otherwise. <br> <br>Return Value: <br> <br>    None. <br> <br>--*/ <br> <br>{ <br>    LINGER lingerStruct; <br> <br>    // <br>    // If we're supposed to abort the connection, set the linger value <br>    // on the socket to 0. <br>    // <br> <br>    if ( !bGraceful ) { <br>        lingerStruct.l_onoff = 1; <br>        lingerStruct.l_linger = 0; <br>        setsockopt( lpClientContext-&gt;Socket, SOL_SOCKET, SO_LINGER, <br>                    (char *)&amp;lingerStruct, sizeof(lingerStruct) ); <br>    } <br> <br>    // <br>    // Now close the socket handle.  This will do an abortive or  <br>    // graceful close, as requested.   <br>    // <br> <br>    closesocket( lpClientContext-&gt;Socket ); <br> <br>    // <br>    // Free context structuyres. <br>    // <br> <br>    LocalFree( lpClientContext-&gt;Context ); <br>    LocalFree( lpClientContext ); <br> <br>    return; <br>     <br>} // CloseClient </code></pre>
<p>&nbsp;</p></body>
</HTML>
