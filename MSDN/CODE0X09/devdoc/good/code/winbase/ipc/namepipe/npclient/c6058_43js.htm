<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>README.TXT</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6058"></a>README.TXT</h2>
<pre><code>Sample: Named Pipe Client/Server Demonstration <br> <br>Summary: <br> <br>NPCLIENT and NPSERVER demonstrate the use of named pipes. <br>The basic design consist of a server application serving <br>multiple client applications.  The user can use the client <br>applications as an interface to all of the other client <br>applications via the server.  The effect is a simple <br>communication program that can be used over the network <br>between multiple clients. <br> <br>More Information: <br> <br>The actual implementation works by having the NPSERVER <br>application launch a new thread, which creates and services <br>a new instance of the server side of the named pipe every <br>time a client connects to it.  You need only start one <br>instance of the NPSERVER application.  It will service up to <br>100 instances of the NPCLIENT application.  (Note that the <br>100 instance limit is hard coded into the sample.  It does <br>not reflect the number of named pipe instances you can <br>create, which is virtually infinite.) <br> <br>TO USE: <br> <br>Start an instance of NPSERVER.  A window will appear. <br> <br>Start an instance of NPCLIENT.  Two dialog boxes will <br>appear, one on top of the other.  The top level dialog box <br>will prompt you for a share name and a client or user name. <br>If the instance of NPCLIENT is local to (on the same machine <br>as) the NPSERVER instance, enter a '.' for the share name. <br>Otherwise, enter the machine name of the server that the <br>NPSERVER instance was started on, i.e. 'FoobarServer'.  For <br>the client or user name, enter any name you wish to be <br>identified with.  Hit enter or click the OK button. <br> <br>The upper dialog box will go away, and you'll see the Client <br>dialog box of NPCLIENT.  It consists of two edit fields and <br>a 'Send' button.  You will be able to read messages from <br>other clients (and yourself) in the larger/upper edit field. <br>(Note, if the message seems garbled, make sure the cursor of <br>the edit field is located in the lower left hand corner of <br>the field.)  The smaller edit field is used to type <br>messages.  To send a message: type something in the <br>lower/smaller edit field, and hit enter or click the Send <br>button.  The message will appear in the larger edit field of <br>all the clients connected to the NPSERVER instance; <br>prepended by the user name you selected.  Note that the user <br>name you selected will be entered into the caption bar of <br>the NPCLIENT instance.  This allows you to more easily keep <br>track of multiple instances of NPCLIENT on the same machine. <br> <br>At the same time the top level dialog box was dismissed from <br>the NPCLIENT instance, the NPSERVER window was updated with <br>the picture of a red spool of thread accompanied by the user <br>name you selected.  This red spool indicates an active <br>client thread connected to NPSERVER.  The spool may be <br>connected to other spools with a thin blue line (similar to <br>the way the File Manager connects files or directories). <br>Any time a client disconnects from NPSERVER; the spool <br>representing it will be grayed out. <br> <br>DESIGN: <br> <br>Basically, the NPSERVER application launches multiple <br>instances of a server thread.  When the application is <br>started, the first thread is created.  It creates an <br>instance of the server side of the named pipe, and waits for <br>a client to connect.  Once a client connects, another thread <br>is started and it too blocks waiting for a client. <br>Meanwhile, the first thread updates a global array of client <br>information with this specific client's information.  The <br>thread then enters a loop reading from this client.  Any <br>time this specific client sends a message, this server <br>thread will call a function (TellAll) which will write the <br>message to all the clients that have been listed in the <br>global array. <br> <br>On the client side, NPCLIENT tries to connect to the named <br>pipe with a CreateFile call.  Once it has connected, it <br>creates a thread which loops and reads any message from the <br>server side.  Once a message is read, it is printed in the <br>larger edit field.  Any time the user hits the Send button, <br>the main thread grabs any text in the lower edit field, and <br>writes it to the server. <br> <br>The steps between NPSERVER and an instance of NPCLIENT looks <br>like this: <br> <br>   NPSERVER                          NPCLIENT <br>   --------                          -------- <br> <br>   CreateNamedPipe() <br>   ConnectPipe()   // Blocks <br>                                      CreateFile()  //Connects to pipe. <br>                                      spawn separate thread to read pipe <br>   return from block <br>   updates array of clients <br>   spawn another server thread <br>   Loop <br>     ReadFile() // Blocks on overlap <br>                                      WriteFile() // User hits Send. <br> <br>     return from block <br>     WriteFile() // Broadcast to clients <br>   End loop      // When client breaks pipe. <br> <br> <br>                                      ReadPipe Thread: <br>                                        Loop <br>                                          ReadFile() <br>                                            block till server broadcasts <br> <br>                                            return from block. <br>                                            put string in edit field. <br> <br>                                         End loop // when server breaks. <br> <br>The overlapped structure should be used anytime a pipe is <br>expected to block for any length of time on a read or write. <br>This allows the thread to return immediately from a read or <br>write to service any other part of your application.  The <br>overlapped structure should also be used on a named pipe <br>anytime you expect to do simultaneous reads and writes. </code></pre>
<p>&nbsp;</p></body>
</HTML>
