<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CLIENT32.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6060"></a>CLIENT32.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples.  <br>*       Copyright 1993 - 1998 Microsoft Corporation. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>/*************************************************************************\ <br>*  PROGRAM: client32.c <br>* <br>*  PURPOSE: <br>* <br>*     To demonstrate the use of named pipes and the overlapped structure. <br>*     This code serves as the client side of the named pipe instances. <br>*     For more details on an overview of this codes designs or use, see <br>*     the README file.  For details on the implementation, see the comments <br>*     in this code. <br>* <br>* <br>\*************************************************************************/ <br> <br>#define  STRICT <br>#include &lt;windows.h&gt; <br>#include "client32.h" <br> <br>#include &lt;string.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;stdlib.h&gt; <br> <br>HANDLE hInst; <br>HWND   hWndClient; <br> <br>CHAR ShrName[LINE_LEN];                 // Global: net share name. <br>CHAR ClntName[NAME_SIZE];               // Global: user or pipe client name. <br>CHAR lpBuffer[255];                     // Global: buffer for string resources                                                  <br> <br>/*************************************************************************\ <br>* <br>*  FUNCTION: WinMain(HANDLE, HANDLE, LPSTR, int) <br>* <br>*  PURPOSE: Launches the Client's dialog box. <br>* <br>*  COMMENTS: <br>* <br>\*************************************************************************/ <br> <br>int APIENTRY WinMain (HINSTANCE hInstance, <br>                      HINSTANCE hPrevInstance, <br>                      LPSTR     lpCmdLine, <br>                      int       nCmdShow) <br> <br> <br>{ <br>  DWORD retCode; <br> <br>  UNREFERENCED_PARAMETER( nCmdShow ); <br>  UNREFERENCED_PARAMETER( lpCmdLine ); <br>  UNREFERENCED_PARAMETER( hPrevInstance ); <br> <br>  hInst   = hInstance; <br>  retCode = DialogBox ((HANDLE)hInst, (LPCTSTR)"ClientDialog", <br>                       NULL, (DLGPROC)ClientDlgProc); <br>  return  (retCode); <br> <br>} <br> <br> <br>/*************************************************************************\ <br>* <br>*  PROCEDURE: InitDlgProc (HWND hDlg, WORD wMsg, LONG wParam, LONG lParam) <br>* <br>*  PURPOSE:  This dialog box prompts the user for a net share name and <br>*            a client or user name.  These values are placed into global <br>*            strings ShrName and ClntName. <br>* <br>*  CALLED BY: <br>* <br>*    ClientDlgProc(); <br>* <br>\*************************************************************************/ <br> <br>LONG CALLBACK InitDlgProc (HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam) <br>  { <br> <br>  UNREFERENCED_PARAMETER(lParam); <br> <br>  switch (wMsg) <br>    { <br>    case WM_INITDIALOG: <br>      PostMessage (GetDlgItem (hDlg, IDD_SVREDIT), <br>                   EM_LIMITTEXT, LINE_LEN, 0); <br> <br>      PostMessage (GetDlgItem (hDlg, IDD_CLNTEDIT), <br>                   EM_LIMITTEXT, NAME_SIZE, 0); <br>    case WM_COMMAND: <br>      switch (LOWORD(wParam)) <br>        {                            // When the user clicks okay, get the <br>        case IDB_INITOK:             // share name and user name from the <br>                                     // edit fields. <br>          GetWindowText (GetDlgItem (hDlg, IDD_SVREDIT), ShrName, LINE_LEN); <br>          GetWindowText (GetDlgItem (hDlg, IDD_CLNTEDIT), ClntName, NAME_SIZE); <br>          EndDialog(hDlg, 0); <br>          return (0); <br> <br>        default: <br>          return (0); <br>        } <br>    default: <br>      return (0); <br>    } <br>  return (0); <br>  } <br> <br> <br>/*************************************************************************\ <br>* <br>*  PROCEDURE: ClientDlgProc (HWND hDlg, WORD wMsg, LONG wParam, LONG lParam) <br>* <br>*  PURPOSE:  This procedure services the dialog box that serves as an interface <br>*            to the named pipe server instance.  The larger edit field is used <br>*            to read messages from the server instance.  The smaller edit field <br>*            is used to type messages to the server instance.  This procedure <br>*            is responsible for connecting to the named pipe, creating a <br>*            seperate thread to read the pipe, and sending to the pipe. <br>* <br>*  CALLED BY: <br>* <br>*    WinMain(); <br>* <br>*  CALLS TO: <br>* <br>*    InitDlgProc(); <br>*    ReadPipe(); <br>* <br>\**************************************************************************/ <br> <br>LONG CALLBACK ClientDlgProc (HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam) <br>  { <br>  DWORD  retCode;                      // Return code. <br>  CHAR   errorBuf[LINE_LEN] = "";      // Error message buffer. <br>  CHAR   outBuf[OUT_BUF_SIZE]  = "";   // Buffer trapping message to send. <br>  CHAR   sendBuf[OUT_BUF_SIZE] = "";   // Buffer used to modify message. <br>  DWORD  bytesWritten;                 // Used for WriteFile(). <br>  DWORD  threadID;                     // Used for CreateThread(). <br>  CHAR   fileName[LINE_LEN+NAME_SIZE+2]; // Used to modify pipe/file name. <br>  DWORD  lastError;                    // Used to get returns from GetLastError. <br> <br>  static HANDLE hPipe;                 // File or Pipe handle. <br>  static OVERLAPPED OverLapWrt;        // Overlapped structure <br>  static HANDLE     hEventWrt;         // Event handle for overlapped writes. <br> <br>  UNREFERENCED_PARAMETER( lParam ); <br> <br>  hWndClient = hDlg; <br> <br>  switch (wMsg) <br>    { <br> <br>    case WM_COMMAND: <br>      switch (LOWORD(wParam)) <br>        { <br> <br>        // When the user presses Send: capture the string from the edit <br>        // field, prepend it with the user name, and overlap write it to <br>        // the server instance of the named pipe. <br> <br>        case IDB_SEND:                 // Get the text from the edit field. <br>          GetWindowText (GetDlgItem(hDlg,IDD_EDITWRITE), <br>                         outBuf, PLEASE_WRITE); <br> <br>                                       // Prepend it with the user name, and <br>                                       // terminate it with a new line <br>                                       // character. <br> <br>          wsprintf (sendBuf, "%s%s %s\n", ClntName, ":", outBuf); <br> <br>                                       // Do the overlapped write. <br>          retCode = WriteFile (hPipe, sendBuf, PLEASE_WRITE, <br>                     &amp;bytesWritten, &amp;OverLapWrt); <br>          if (!retCode) <br>            { <br>            lastError = GetLastError(); <br>                                       // If Error = IO_PENDING, wait til <br>                                       // the event signals success. <br>            if (lastError == ERROR_IO_PENDING) <br>              WaitForSingleObject (hEventWrt, (DWORD)-1); <br>            } <br> <br>          return (0); <br> <br>        default: <br>          return (0); <br> <br>        } <br> <br> <br>    case WM_INITCLIENT: <br> <br>       // On initialization, use the Init dialog box prompt the user for a <br>       // net share name and a client or user name.  A share name of "." <br>       // means that the named pipe is local to this machine.  Named pipe <br>       // names should have the form '\\.\PIPE\&lt;pipename&gt;', for a local machine <br>       // or '\\&lt;machinename&gt;\PIPE\&lt;pipename&gt;' for remote machines. <br>       // Once the share name is captured from the Init dialog box, <br>       // convert the name into the proper form; then do a CreateFile() <br>       // to connect to the pipe.  Handle any error from the CreateFile(). <br>       // Then write the user name to the server instance of the named <br>       // pipe.  Finally, create a thread to read the named pipe. <br> <br>                                       // Launch Init dialog box to capture <br>                                       // share name and user name. <br>       DialogBox ((HANDLE)GetModuleHandle(NULL), <br>                  (LPCTSTR)"InitDialog", <br>                  (HWND)hDlg, <br>                  (DLGPROC)InitDlgProc); <br> <br>                                       // Put captured user name in window <br>                                       // caption. <br>       SetWindowText (hDlg, ClntName); <br> <br>                                       // Construct file/pipe name. <br>       wsprintf (fileName, "%s%s%s", "\\\\", ShrName, "\\PIPE\\test"); <br> <br>                                       // Do CreateFile() to connect to the <br>                                       // named pipe. <br>       hPipe = CreateFile (fileName,              // Pipe name. <br>                           GENERIC_WRITE          // Generic access, read/write. <br>                           | GENERIC_READ, <br>                           FILE_SHARE_READ        // Share both read and write. <br>                           | FILE_SHARE_WRITE , <br>                           NULL,                  // No security. <br>                           OPEN_EXISTING,         // Fail if not existing. <br>                           FILE_FLAG_OVERLAPPED,  // Use overlap. <br>                           NULL);                 // No template. <br> <br>                                       // Do some error checking. <br>       if ((DWORD)hPipe == 0xFFFFFFFF) <br>         { <br>         retCode = GetLastError(); <br> <br>                                       // This error means pipe wasn't found. <br>         if ((retCode == ERROR_SEEK_ON_DEVICE) || <br>             (retCode == ERROR_FILE_NOT_FOUND)) { <br>             LoadString(hInst, IDS_CANTFINDPIPE, lpBuffer, sizeof(lpBuffer)); <br>             MessageBox (hDlg, lpBuffer, "", MB_OK); <br>         } <br>         else <br>           {                           // Flagging unknown errors. <br>             LoadString(hInst, IDS_GENERALERROR, lpBuffer, sizeof(lpBuffer)); <br>             wsprintf (errorBuf, lpBuffer, retCode); <br>             LoadString(hInst, IDS_DEBUGTITLE, lpBuffer, sizeof(lpBuffer)); <br>             MessageBox (hDlg, errorBuf, lpBuffer, <br>                       MB_ICONINFORMATION | MB_OK | MB_APPLMODAL); <br>           } <br> <br>         EndDialog (hDlg, 0);          // Kill app if pipe didn't connect. <br>         }; <br> <br>                                       // Create and init overlapped structure <br>                                       // for writes. <br>       hEventWrt = CreateEvent (NULL, TRUE, FALSE, NULL); <br>       OverLapWrt.hEvent = hEventWrt; <br> <br>                                       // Write the client name to server. <br>       retCode = WriteFile (hPipe, ClntName, PLEASE_WRITE, <br>                            &amp;bytesWritten, &amp;OverLapWrt); <br> <br>       if (!retCode)                   // Wait on overlapped if need be. <br>         { <br>         lastError = GetLastError(); <br>         if (lastError == ERROR_IO_PENDING) <br>           WaitForSingleObject (hEventWrt, (DWORD)-1); <br>         } <br>                                       // Create a thread to read the pipe. <br>       CreateThread (NULL, <br>                     0, <br>                     (LPTHREAD_START_ROUTINE)ReadPipe, <br>                     (LPVOID)&amp;hPipe, <br>                     0, <br>                     &amp;threadID); <br>       return (0); <br> <br> <br> <br>     case WM_INITDIALOG: <br>                                       // PostMessage() give time for the <br>                                       // dialog box to be created. <br>       PostMessage (hDlg, WM_INITCLIENT, 0, 0); <br>       return (0); <br> <br> <br> <br>     case WM_GO_AWAY: <br>       CloseHandle (hPipe); <br>       CloseHandle (hEventWrt); <br>       EndDialog (hDlg, TRUE); <br>       return TRUE; <br> <br> <br> <br>     case WM_SYSCOMMAND: <br>       if (wParam == SC_CLOSE) <br>         { <br>         CloseHandle (hPipe); <br>         CloseHandle (hEventWrt); <br>         EndDialog(hDlg, TRUE); <br>         return TRUE; <br>         } <br>       break; <br>     } <br>    return (FALSE); <br> <br>  } <br> <br>/*************************************************************************\ <br>* <br>*  PROCEDURE: ReadPipe (HANDLE *hRead) <br>* <br>*  PURPOSE:  This is a thread function which loops and reads the named pipe. <br>* <br>*  CALLED BY: <br>* <br>*    ClientDlgProc. <br>* <br>* <br>\*************************************************************************/ <br> <br>VOID ReadPipe (HANDLE *hPipe) <br>  { <br>    CHAR       inBuf[IN_BUF_SIZE] = "";// Input buffer. <br>    DWORD      bytesRead;              // Used for ReadFile() <br>    DWORD      retCode;                // Used to trap return codes. <br>    CHAR       Buf[80];                // Message box buffer. <br>    DWORD      lastError;              // Used to trap returns from GetLastError. <br> <br>    HANDLE     hEventRd;               // Event handle for overlapped reads. <br>    OVERLAPPED OverLapRd;              // Overlapped structure. <br>    DWORD      bytesTrans;             // Bytes transferred in read. <br> <br>                                       // Create and init overlap structure. <br>    hEventRd = CreateEvent (NULL, TRUE, FALSE, NULL); <br>    memset (&amp;OverLapRd, 0, sizeof(OVERLAPPED)); <br>    OverLapRd.hEvent = hEventRd; <br> <br>    // Loop, reading the named pipe until it is broken.  The ReadFile() uses <br>    // an overlapped structure.  When the event handle signals a completed <br>    // read, this loop writes the message to the larger edit field. <br> <br>    do{ <br>                                       // Read the pipe handle. <br>      retCode = ReadFile (*hPipe, inBuf, IN_BUF_SIZE, &amp;bytesRead, &amp;OverLapRd); <br> <br>      if (!retCode) {                  // Do some error checking. <br>    <br>        lastError = GetLastError(); <br>                                       // Check for 3 kinds of errors: <br>                                       // IO_PENDING, BROKEN_PIPE, or <br>                                       // other. <br>                                       // If Error = IO_PENDING, wait for <br>                                       // event handle to signal success. <br>        if (lastError == ERROR_IO_PENDING) <br>          { <br>          WaitForSingleObject (hEventRd, (DWORD)-1); <br> <br>          } <br>        else {                         // If pipe is broken, tell user and break. <br> <br>          if (lastError == (DWORD)ERROR_BROKEN_PIPE) { <br>            LoadString(hInst, IDS_CONNECTBROKEN, lpBuffer, sizeof(lpBuffer)); <br>            MessageBox (hWndClient, lpBuffer, "", MB_OK); <br>          } <br>          else {                       // Or flag unknown errors, and break. <br>             LoadString(hInst, IDS_READFAILED, lpBuffer, sizeof(lpBuffer)); <br>             wsprintf (Buf, lpBuffer, GetLastError()); <br>             LoadString(hInst, IDS_CLIENTDBG, lpBuffer, sizeof(lpBuffer)); <br>             MessageBox (hWndClient, Buf, lpBuffer, MB_OK); <br>          } <br>          break; <br>        } <br>      } <br>                                       // NULL terminate string. <br>      GetOverlappedResult (*hPipe, &amp;OverLapRd, &amp;bytesTrans, FALSE); <br>      inBuf[bytesTrans] = '\0'; <br> <br>                                       // Write message to larger edit field. <br>      SendMessage (GetDlgItem (hWndClient, IDD_EDITREAD), <br>                   EM_REPLACESEL, <br>                   0, (LONG)inBuf); <br>                                       // Add a new line. <br>      SendMessage (GetDlgItem (hWndClient, IDD_EDITREAD), <br>                   EM_REPLACESEL, <br>                   0, (LONG)"\r\n"); <br>      }while(1); <br> <br>                                       // When pipe is broken, send quit <br>                                       // messages to Client dialog box. <br>    PostMessage (hWndClient, WM_GO_AWAY, 0,0); <br>    ExitThread(0); <br>  } <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
