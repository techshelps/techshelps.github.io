<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SERVER32.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6062"></a>SERVER32.C</h2>
<pre><code>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples.  <br>*       Copyright 1993 - 1998 Microsoft Corporation. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>/*************************************************************************\ <br>*  PROGRAM: server32.c <br>* <br>*  PURPOSE: <br>* <br>*     To demonstrate the use of named pipes and the overlapped structure. <br>*     This code serves as the server side of the named pipe instances. <br>*     For more details on an overview of this codes designs or use, see <br>*     the README file.  For details on the implementation, see the comments <br>*     in this code. <br>* <br>* <br>\*************************************************************************/ <br> <br>#define  STRICT <br>#include &lt;windows.h&gt; <br>#include "server32.h" <br> <br>#include &lt;string.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;stdlib.h&gt; <br> <br>                                       // clients[] is a global array of <br>                                       // structures used to keep track <br>                                       // of the multiple instances of <br>                                       // the server side of the named <br>                                       // pipe.  As a client connects <br>                                       // to a given instance, a new <br>                                       // server thread is created and <br>                                       // added to the array. <br>WRTHANDLE clients[MAX_PIPE_INSTANCES]; <br>DWORD     clientCount = 0;             // Global count of connected clients. <br> <br>HWND   hWnd; <br>HANDLE hInst; <br>CHAR   lpBuffer[255]; <br> <br> <br>/*************************************************************************\ <br>* <br>*  FUNCTION: WinMain(HANDLE, HANDLE, LPSTR, int) <br>* <br>*  PURPOSE: calls initialization function, processes message loop <br>* <br>*  COMMENTS: <br>* <br>\*************************************************************************/ <br> <br>int APIENTRY WinMain (HINSTANCE hInstance, <br>                      HINSTANCE hPrevInstance, <br>                      LPSTR  lpCmdLine, <br>                      int    nCmdShow) <br> <br> <br>{ <br> <br>  MSG  msg; <br>  WNDCLASS wc; <br> <br> <br>  UNREFERENCED_PARAMETER( lpCmdLine ); <br>  UNREFERENCED_PARAMETER( hPrevInstance ); <br> <br>  // <br>  // Detect platform and exit gracefully if not Windows NT. <br>  // <br> <br>  { <br>    OSVERSIONINFO osvi; <br>    osvi.dwOSVersionInfoSize = sizeof (OSVERSIONINFO); <br> <br>    GetVersionEx (&amp;osvi); <br>    if (osvi.dwPlatformId != VER_PLATFORM_WIN32_NT) { <br>  LoadString(hInst, IDS_WRONGOS, lpBuffer, sizeof(lpBuffer));  <br>      MessageBox (NULL, lpBuffer, "SERVER32", MB_OK | MB_ICONSTOP); <br>      return 0; <br>    } <br>  } <br> <br> <br> <br>  hInst = hInstance; <br> <br>  wc.style = 0; <br>  wc.lpfnWndProc = (WNDPROC)MainWndProc; <br>  wc.cbClsExtra = 0; <br>  wc.cbWndExtra = 0; <br>  wc.hInstance = hInstance; <br>  wc.hIcon = LoadIcon (hInstance, "npserver"); <br>  wc.hCursor = LoadCursor (NULL, IDC_ARROW); <br>  wc.hbrBackground = GetStockObject (WHITE_BRUSH); <br>  wc.lpszMenuName = "PipeMenu"; <br>  wc.lpszClassName = "PipeWClass"; <br> <br>  RegisterClass(&amp;wc); <br> <br>  LoadString(hInst, IDS_WINDOWTITLE, lpBuffer, sizeof(lpBuffer));  <br>  hWnd = CreateWindow ("PipeWClass", <br>                       lpBuffer, <br>                       WS_OVERLAPPEDWINDOW, <br>                       CW_USEDEFAULT, <br>                       CW_USEDEFAULT, <br>                       CW_USEDEFAULT, <br>                       CW_USEDEFAULT, <br>                       NULL, <br>                       NULL, <br>                       hInstance, <br>                       NULL); <br> <br> <br>  ShowWindow (hWnd, nCmdShow); <br> <br>  while (GetMessage (&amp;msg, NULL, 0, 0)) <br>    DispatchMessage (&amp;msg); <br> <br>  return (msg.wParam); <br> <br>} <br> <br>/*************************************************************************\ <br>* <br>*  FUNCTION:  MainWndProc (HWND, UINT, WPARAM, LPARAM) <br>* <br>*  PURPOSE:   To process messages.  To launch client and server threads <br>* <br>\*************************************************************************/ <br> <br>LONG CALLBACK MainWndProc (HWND   hwnd, <br>                           UINT   message, <br>                           WPARAM wParam, <br>                           LPARAM lParam) <br>{ <br> <br>  LONG        lpServerThreadID; <br>  PAINTSTRUCT paintStruct; <br>  HDC         hDC; <br> <br>  switch (message) <br>      { <br>        case WM_PAINT: <br>           // DrawBranch is used to paint the spools and text to the window. <br>           hDC = BeginPaint (hwnd, &amp;paintStruct); <br>           DrawBranch (hDC); <br>           EndPaint (hwnd, &amp;paintStruct); <br>           return(0); <br> <br>        case WM_CREATE : <br>           // Create the first instance of a server side of the pipe. <br>           CreateThread ((LPSECURITY_ATTRIBUTES)NULL,       // No security. <br>                         (DWORD)0,                          // Same stack size. <br>                         (LPTHREAD_START_ROUTINE)ServerProc,// Thread procedure. <br>                         (LPVOID)&amp;hwnd,                     // Parameter. <br>                         (DWORD)0,                          // Start immediatly. <br>                         (LPDWORD)&amp;lpServerThreadID);       // Thread ID. <br>           return (0); <br> <br>        case WM_DESTROY : <br>           PostQuitMessage (0); <br>           return (0); <br>       } <br>    return DefWindowProc (hwnd, message, wParam, lParam); <br>} <br> <br> <br> <br>/*************************************************************************\ <br>* <br>*  PROCEDURE: ServerProc (HWND *hWnd) <br>* <br>*  PURPOSE: <br>* <br>*    A thread procedure, which creates an instance of the server side of <br>*    the named pipe, and then blocks waiting for a client to connect. <br>*    Once the client connects, a global array is updated with the specific <br>*    clients information, and this procedure is called again <br>*    to launch another waiting server thread.  After launching the new <br>*    thread, this thread begins to loop, reading the named pipe.  When <br>*    a message comes from it's client, it uses TellAll() to broadcast <br>*    the message to the other clients in the array. <br>* <br>*  CALLED BY: <br>* <br>*    ServerProc(); <br>*    WinMain(); <br>* <br>*  CALLS TO: <br>* <br>*    TellAll(); <br>*    ServerProc(). <br>* <br>*  COMMENTS: <br>* <br>*    Clients is a global array which hold information on each client <br>*    connected to the named pipe.  This procedure recieves a buffer. <br>*    It then steps through this global array, and for each client it <br>*    writes the buffer. <br>* <br>\*************************************************************************/ <br> <br>VOID ServerProc(HWND *hWnd) <br> { <br>   HANDLE hPipe;                       // Pipe handle. <br>   CHAR   inBuf[IN_BUF_SIZE] = "";     // Input buffer for pipe. <br>   DWORD  ServerThreadID;              // Used for CreateThread(). <br> <br>   CHAR   errorBuf[LINE_LEN] = "";     // Used for error messages. <br>   DWORD  bytesRead;                   // Used in ReadFile(). <br>   DWORD  retCode;                     // Used to trap return codes. <br>   DWORD  clientIndex;                 // Index into global array, for this <br>                                       // instances client. <br>   DWORD  lastError;                   // Traps returns from GetLastError(). <br>   BOOL   ExitLoop = FALSE;            // Boolean Flag to exit loop. <br> <br>   OVERLAPPED OverLapWrt;              // Overlapped structure for writing. <br>   HANDLE     hEventWrt;               // Event handle for overlapped write. <br> <br>   OVERLAPPED OverLapRd;               // Overlapped structure for reading. <br>   HANDLE     hEventRd;                // Event handle for overlapped reads. <br>   DWORD        bytesTransRd;          // Bytes transferred by overlapped. <br>   PSECURITY_DESCRIPTOR    pSD; <br>   SECURITY_ATTRIBUTES     sa; <br> <br>                                       // create a security NULL security <br>                                       // descriptor, one that allows anyone <br>                                       // to write to the pipe... WARNING <br>                                       // entering NULL as the last attribute <br>                                       // of the CreateNamedPipe() will <br>                                       // indicate that you wish all <br>                                       // clients connecting to it to have <br>                                       // all of the same security attributes <br>                                       // as the user that started the <br>                                       // pipe server. <br> <br>   pSD = (PSECURITY_DESCRIPTOR) LocalAlloc(LPTR, <br>               SECURITY_DESCRIPTOR_MIN_LENGTH); <br> <br>   if (pSD == NULL) <br>     { <br>     MessageBox (*hWnd, "Error in LocalAlloc for pSD", <br>                 "Debug: ServerProc()", MB_OK); <br>     return; <br>     } <br> <br>   if (!InitializeSecurityDescriptor(pSD, SECURITY_DESCRIPTOR_REVISION)) <br>     { <br>     wsprintf (errorBuf, "Error: InitializeSecurityDescriptor() %d", <br>               GetLastError()); <br>     MessageBox (*hWnd, errorBuf, "Debug: ServerProc()", MB_OK); <br>       LocalFree((HLOCAL)pSD); <br>       return; <br>     } <br> <br>                                       // add a NULL disc. ACL to the <br>                                       // security descriptor. <br> <br>   if (!SetSecurityDescriptorDacl(pSD, TRUE, (PACL) NULL, FALSE)) <br>     { <br>     wsprintf (errorBuf, "Error: SetSecurityDescriptorDacl() %d", <br>                GetLastError()); <br>     MessageBox (*hWnd, errorBuf, "Debug: ServerProc()", MB_OK); <br>     LocalFree((HLOCAL)pSD); <br>     return; <br>     } <br> <br>   sa.nLength = sizeof(sa); <br>   sa.lpSecurityDescriptor = pSD; <br>   sa.bInheritHandle = TRUE; <br> <br>                                       // Create a local named pipe with <br>                                       // the name '\\.\PIPE\test'.  The <br>                                       // '.' signifies local pipe. <br>   hPipe = CreateNamedPipe ("\\\\.\\PIPE\\test", // Pipe name = 'test'. <br>               PIPE_ACCESS_DUPLEX                // 2 way pipe. <br>               | FILE_FLAG_OVERLAPPED,           // Use overlapped structure. <br>               PIPE_WAIT                         // Wait on messages. <br>               | PIPE_READMODE_MESSAGE           // Specify message mode pipe. <br>               | PIPE_TYPE_MESSAGE, <br>               MAX_PIPE_INSTANCES,               // Maximum instance limit. <br>               OUT_BUF_SIZE,                     // Buffer sizes. <br>               IN_BUF_SIZE, <br>               TIME_OUT,                         // Specify time out. <br>               &amp;sa);                             // Security attributes. <br> <br>                                       // Check Errors. <br>    if ((DWORD)hPipe == 0xFFFFFFFF) <br>     { <br> <br>     retCode = GetLastError();         // Report any error, it should always succeed. <br>     LoadString(hInst, IDS_ERRORCODE, lpBuffer, sizeof(lpBuffer)); <br>     wsprintf (errorBuf, lpBuffer, retCode); <br>     LoadString(hInst, IDS_DEBUGTITLE, lpBuffer, sizeof(lpBuffer)); <br>     MessageBox (*hWnd, errorBuf, lpBuffer, <br>                 MB_ICONINFORMATION | MB_OK | MB_APPLMODAL); <br>     }; <br> <br>                                       // Block until a client connects. <br>   ConnectNamedPipe(hPipe, NULL); <br> <br>                                       // Create and init overlap for writing. <br>   hEventWrt = CreateEvent (NULL, TRUE, FALSE, NULL); <br>   memset (&amp;OverLapWrt, 0, sizeof(OVERLAPPED)); <br>   OverLapWrt.hEvent = hEventWrt; <br> <br>                                       // Set the clientIndex, then increment <br>                                       // the count.  Fill in the structure <br>                                       // for this client in the array. <br>   clientIndex = clientCount++; <br>   clients[clientIndex].hPipe   = hPipe; <br>   clients[clientIndex].live    = TRUE; <br>   clients[clientIndex].overLap = OverLapWrt; <br>   clients[clientIndex].hEvent  = hEventWrt; <br> <br>                                       // Create and init overlap for reading. <br>   hEventRd = CreateEvent(NULL,TRUE,FALSE,NULL); <br>   memset (&amp;OverLapRd, 0, sizeof(OVERLAPPED)); <br>   OverLapRd.hEvent = hEventRd; <br> <br>                                       // Read from the client, the first <br>                                       // first message should always be <br>                                       // the clients user name. <br>   retCode = ReadFile (hPipe, inBuf, PLEASE_READ, &amp;bytesRead, &amp;OverLapRd); <br> <br>   if (!retCode) <br>    lastError = GetLastError(); <br> <br>   if (lastError == ERROR_IO_PENDING)  // Wait on read if need be. <br>     WaitForSingleObject (hEventRd, (DWORD)-1); <br> <br>                                       // Put client's name in the array. <br>   strcpy (clients[clientIndex].Name, inBuf); <br> <br>                                       // Create a thread which will make <br>                                       // another server instance of the <br>                                       // named pipe. <br>   CreateThread ((LPSECURITY_ATTRIBUTES)NULL,        // No security attributes. <br>                 (DWORD)0,                           // Use same stack size. <br>                 (LPTHREAD_START_ROUTINE)ServerProc, // Thread procedure. <br>                 (LPVOID)hWnd,                       // Parameter to pass. <br>                 (DWORD)0,                           // Run immediately. <br>                 (LPDWORD)&amp;ServerThreadID);          // Thread identifier. <br> <br>   TellAll("");                        // Forces a paint, draws a red spool <br>                                       // and name for this client. <br> <br>                                       // Do loop which basically reads from <br>                                       // this specific client, and then <br>                                       // uses TellAll() to broadcast the <br>                                       // message to all the connected <br>                                       // clients. <br>   do{ <br>                                       // Read the pipe. <br>      retCode = ReadFile (hPipe, inBuf, PLEASE_READ, &amp;bytesRead, &amp;OverLapRd); <br> <br>                                       // Check for three kinds of errors: <br>                                       // If Error = IO_PENDING, wait til <br>                                       // the event handle signals success, <br>                                       // If BROKEN_PIPE, exit the do loop. <br>                                       // Any other error, flag it to the <br>                                       // user and exit the do loop. <br>      if (!retCode) <br>        { <br>        lastError = GetLastError(); <br> <br>        switch (lastError) <br>          { <br>                                       // IO_PENDING, wait on the event. <br>           case ERROR_IO_PENDING: <br>             WaitForSingleObject (hEventRd, (DWORD)-1); <br>             break; <br>                                       // Pipe is broken, exit the loop. <br>           case ERROR_BROKEN_PIPE: <br>             ExitLoop = TRUE; <br>             break; <br>                                       // Something else is wrong, exit the <br>                                       // the loop after telling the user. <br>           default: <br>             LoadString(hInst, IDS_READERROR, lpBuffer, sizeof(lpBuffer)); <br>             wsprintf (errorBuf, lpBuffer, lastError); <br>             LoadString(hInst, IDS_DEBUGINFO, lpBuffer, sizeof(lpBuffer)); <br>             MessageBox (*hWnd, errorBuf, lpBuffer, MB_OK); <br>             ExitLoop = TRUE; <br>             break; <br>          } <br>        } <br> <br>      if (!ExitLoop) <br>        { <br>        GetOverlappedResult (hPipe, &amp;OverLapRd, &amp;bytesTransRd, FALSE); <br> <br>                                       // Use TellAll to broadcast the message. <br>        if (bytesTransRd) <br>          TellAll(inBuf); <br>        else <br>          TellAll(""); <br>        } <br> <br>   }while(!ExitLoop); <br> <br>   clients[clientIndex].live = FALSE;  // Turns spool gray. <br>   CloseHandle (hPipe);                // Close handles. <br>   CloseHandle (hEventRd); <br>   CloseHandle (hEventWrt); <br>   DisconnectNamedPipe (hPipe);        // Close pipe instance. <br>   ExitThread(0);                      // Clean up and die. <br>  } <br> <br> <br>/*************************************************************************\ <br>* <br>*  PROCEDURE: TellAll (CHAR *buffer) <br>* <br>*  PURPOSE: <br>* <br>*    To write the buffer (input parameter) to all of the clients listed <br>*    in the global array "clients". <br>* <br>*  CALLED BY: <br>* <br>*    ServerProc(); <br>* <br>*  COMMENTS: <br>* <br>*    Clients is a global array which hold information on each client <br>*    connected to the named pipe.  This procedure recieves a buffer. <br>*    It then steps through this global array, and for each client it <br>*    writes the buffer. <br>* <br>\*************************************************************************/ <br> <br>VOID TellAll( CHAR *buffer ) <br>  { <br>    DWORD i;                           // Index through array. <br>    DWORD bytesWritten;                // Used in WriteFile(). <br>    DWORD retCode;                     // Traps return codes. <br>    CHAR  Buf[LINE_LEN];               // Message Buffer. <br>    DWORD lastError;                   // Traps returns from GetLastError(). <br> <br>    for(i=0; i &lt; clientCount; i++)     // For all clients in the array. <br>      { <br>                                       // If client isn't alive, don't waste <br>                                       // time writing to it. <br>      if (clients[i].live) <br>        { <br>        retCode = WriteFile (clients[i].hPipe, buffer, strlen(buffer), <br>                             &amp;bytesWritten, &amp;clients[i].overLap); <br> <br>                                       // Check 3 kinds of errors: IO_PENDING, <br>                                       // NO_DATA, or other.  Wait on event <br>                                       // handle if IO_PENDING, else, if it's <br>                                       // anything other than NO_DATA (pipe <br>                                       // client disconnected), flag the user. <br>                                       // In any case, if it's not IO_PENDING, <br>                                       // clients[i].live = FALSE, spool turns <br>                                       // gray. <br>        if (!retCode) <br>          { <br>          lastError = GetLastError(); <br> <br>                                       // IO_PENDING, wait on event handle. <br>          if (lastError == ERROR_IO_PENDING) <br>            { <br>            WaitForSingleObject (clients[i].hEvent, (DWORD)-1); <br>            } <br>          else <br>            { <br>                                       // If not NO_DATA, flag user. <br>            if (lastError != ERROR_NO_DATA) <br>              { <br>              LoadString(hInst, IDS_DEBUGLAST, lpBuffer, sizeof(lpBuffer)); <br>              wsprintf (Buf, "%s = %d", buffer, GetLastError()); <br>              MessageBox(hWnd, Buf, lpBuffer, MB_OK); <br>              } <br>            clients[i].live = FALSE; <br>            } <br>          } <br>        } //if client.live <br>      } // for loop <br>                                       // Paint window with new information. <br>    InvalidateRect(hWnd, NULL, TRUE); <br>  } <br> <br> <br> <br>/*************************************************************************\ <br>* <br>*  PROCEDURE: DrawBranch (HDC hDC) <br>* <br>*  PURPOSE: <br>* <br>*    To draw one of four bitmaps for each client, depending upon the clients <br>*    status (alive = red spool, dead or disconnected = gray), and location in <br>*    the array.  It also draws the clients user name beside the spool. <br>*    This procedure is executed when the WM_PAINT message is trapped. <br>* <br>*  CALLED BY: <br>* <br>*    WinMain(); <br>* <br>*  COMMENTS: <br>* <br>\*************************************************************************/ <br>VOID DrawBranch(HDC hDC) <br>{ <br>                                       // Spool bitmaps. <br>  HBITMAP hEndLive, hEndDead, hMidLive, hMidDead, hBitMap; <br> <br>  HDC hDCMem; <br>  int X, Y; <br>  BITMAP bm; <br>  POINT ptSize, ptOrg; <br>  DWORD index; <br> <br>                                       // Load bitmaps: two red (live), <br>                                       // two dead (gray).  End = end <br>                                       // of tree (last client to connect), <br>                                       // mid means in the middle somewhere. <br>       hEndLive = LoadBitmap (hInst, "EndLive"); <br>       hEndDead = LoadBitmap (hInst, "EndDead"); <br> <br>       hMidLive = LoadBitmap (hInst, "MidLive"); <br>       hMidDead = LoadBitmap (hInst, "MidDead"); <br> <br>                                       // For each client, determine if <br>                                       // if alive or not, and position; <br>                                       // then blt appropriate map and <br>                                       // clients name. <br>    for (index = 0; index &lt; clientCount; index++) <br>      { <br> <br>      if (index &lt; clientCount - 1)     // ClientCount - 1 = last (end) client. <br>       { <br>        if(clients[index].live)        // If live = red, else = gray. <br>         hBitMap = hMidLive; <br>        else <br>         hBitMap = hMidDead; <br>       } <br>      else <br>       { <br>        if(clients[index].live)        // If live = red, else = gray. <br>         hBitMap = hEndLive; <br>        else <br>         hBitMap = hEndDead; <br>       } <br>                                       // Calculate coordinates: <br>      X = BITMAP_X;                    // X position is constant. <br>      Y = index * BITMAP_Y;            // Y is based on index in the array. <br> <br>                                       // Blt the chosen map. <br>      hDCMem = CreateCompatibleDC(hDC); <br>      SelectObject(hDCMem, hBitMap); <br>      SetMapMode(hDCMem, GetMapMode(hDC)); <br> <br>      GetObject(hBitMap, sizeof(BITMAP), &amp;bm); <br> <br>      ptSize.x = bm.bmWidth; <br>      ptSize.y = bm.bmHeight; <br>      DPtoLP (hDC, &amp;ptSize, 1); <br> <br>      ptOrg.x = 0; <br>      ptOrg.y = 0; <br>      DPtoLP (hDCMem, &amp;ptOrg, 1); <br> <br>      BitBlt(hDC, X, Y, ptSize.x, ptSize.y, <br>             hDCMem, ptOrg.x, ptOrg.y, SRCCOPY); <br> <br> <br>      X =  NAME_X;                     // Relocate X,Y for clients name. <br>      Y += NAME_Y; <br>                                       // Write name next to spool. <br>      TextOut (hDC, X, Y, clients[index].Name, strlen(clients[index].Name)); <br>      DeleteDC(hDCMem); <br>      } <br> <br> <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
