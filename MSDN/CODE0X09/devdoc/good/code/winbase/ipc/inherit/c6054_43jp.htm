<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>INHERIT.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6055"></a>INHERIT.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples.  <br>*       Copyright (C) 1992-1996 Microsoft Corporation. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>/******************************************************************** <br>* This program is to demonstrate the use of anonymous pipes used as * <br>* stdout and stderr replacements. One of two techniques can be      * <br>* chose to do this: the SetStdHandle technique or the               * <br>* STARTF_USESTDHANDLES technique. The SetStdHandle technique sets   * <br>* the standard output handles to the pipe that we will read from,   * <br>* which the child will inherit. The STARTF_USESTDHANDLES technique  * <br>* passes the pipe handles to the child as standard handles via the  * <br>* STARTUPINFO structure. The STARTF_USESTDHANDLES technique *must*  * <br>* be used for "console-less" processes such as GUI applications or  * <br>* detached processes.                                               * <br>*                                                                   * <br>* This program demonstrates the use of the following Win32 APIs:    * <br>*   CreatePipe, CreateProcess.                                      * <br>*                                                                   * <br>* This program also uses the following Win32 APIs:                  * <br>*   GetLastError, CreateFile, CloseHandle, CreateProcess, ReadFile, * <br>*   WriteFile.                                                      * <br>*                                                                   * <br>*                                                                   * <br>* Execution instructions:                                           * <br>*                                                                   * <br>*   inherit &lt;trace file&gt; &lt;command to execute&gt;                       * <br>*   trace file is the name of the file where the stdout             * <br>*     and stderr of command will be redirected                      * <br>*                                                                   * <br>*   command to execute can be either an external executable or an   * <br>*     internal cmd.exe command.                                     * <br>*                                                                   * <br>*   Examples:                                                       * <br>*                                                                   * <br>*   inherit chkdsk.dat chkdsk d:                                    * <br>*   inherit nmake.txt nmake /f foo.mak                              * <br>*                                                                   * <br>********************************************************************/ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;string.h&gt; <br> <br>/* define USESTDHANDLES to use the new technique of passing the <br>standard handles to the child process via the STARTUPINFO structure. <br>This technique must be used for "console-less" parents such as GUI <br>applications or detached applications. */ <br> <br>#define USESTDHANDLES <br> <br>/* Standard error macro for reporting API errors */ <br>//#define PERR(bSuccess, api) {if (!(bSuccess)) printf("%s: Error %d from %s  <br>//    on line %d\n", __FILE__, GetLastError(), api, __LINE__);} <br> <br>void PERR(BOOL bSuccess, char * api); <br> <br>int main(int argc, char *argv[]) <br>{ <br>  char chReadBuffer[64];  /* pipe read buffer */ <br>  BOOL bSuccess;  /* BOOL return code for APIs */ <br>  int j; <br>  HANDLE hOutFile;  /* handle to log file */ <br>  /* handles to the anonymous pipe */ <br>  HANDLE hReadPipe, hWritePipe, hWritePipe2; <br>  char szArgs[256];  /* child process argument buffer */ <br>  char *p;  /* temporary pointer into szArgs */ <br>  DWORD cchReadBuffer;  /* number of bytes read or to be written */ <br>  STARTUPINFO si;  /* for CreateProcess call */ <br>  PROCESS_INFORMATION pi;  /* for CreateProcess call */ <br>  SECURITY_ATTRIBUTES saPipe;  /* security for anonymous pipe */ <br>  OSVERSIONINFO os; /* operating system specs */ <br> <br>  os.dwOSVersionInfoSize = sizeof(OSVERSIONINFO); // required assignment <br> <br>  // check if running on Windows NT, if not, display notice and terminate <br>  if ( GetVersionEx(&amp;os) ) <br>  { <br>      if( os.dwPlatformId != VER_PLATFORM_WIN32_WINDOWS &amp;&amp;  <br>          os.dwPlatformId != VER_PLATFORM_WIN32_NT) <br>      { <br>           MessageBox( NULL, <br>           "This sample application can only run on Windows NT and Windows 95.\n" <br>           "This application will now terminate.", <br>           "Inherit", <br>           MB_OK | MB_ICONSTOP | MB_SETFOREGROUND ); <br>            <br>           return( 1 ); <br>      } <br>  } <br>  else <br>  { <br>       MessageBox( NULL, <br>       "Unable to test for OS version.", <br>       "Inherit Error", <br>       MB_OK | MB_ICONSTOP | MB_SETFOREGROUND ); <br>        <br>       return( 1 ); <br>  } <br> <br>  if (argc &lt; 3) <br>    { <br>    puts("format: inherit &lt;trace file&gt; &lt;command to execute&gt;"); <br>    puts("trace file is the name of the file where the stdout"); <br>    puts("and stderr of command will be redirected\n"); <br>    puts("command to execute is command line of the function"); <br>    puts("you wish to perform.\n"); <br>    puts("Examples:\n"); <br>    puts("  inherit trace.txt chkdsk d:"); <br>    puts("  inherit trace.txt nmake /f foo.mak"); <br>    return(1); <br>    } <br> <br>  /* create the log file where we will save all output from child */ <br>  hOutFile = CreateFile(argv[1],  /* file to open */ <br>      GENERIC_WRITE,  /* access mode */ <br>      FILE_SHARE_READ,  /* share mode */ <br>      NULL,  /* security attributes */ <br>      CREATE_ALWAYS,  /* creation flags - trash existing file */ <br>      FILE_ATTRIBUTE_NORMAL,  /* file attributes */ <br>      NULL); <br>  PERR(hOutFile != INVALID_HANDLE_VALUE, "CreateFile"); <br> <br>  /* set up the security attributes for the anonymous pipe */ <br>  saPipe.nLength = sizeof(SECURITY_ATTRIBUTES); <br>  saPipe.lpSecurityDescriptor = NULL; <br>  /* In order for the child to be able to write to the pipe, the handle */ <br>  /* must be marked as inheritable by setting this flag: */ <br>  saPipe.bInheritHandle = TRUE; <br> <br>  /* create the anonymous pipe */ <br>  bSuccess = CreatePipe(&amp;hReadPipe,  /* read handle */ <br>      &amp;hWritePipe,  /* write handle, used as stdout by child */ <br>      &amp;saPipe,  /* security descriptor */ <br>      0);  /* pipe buffer size */ <br>  PERR(bSuccess, "CreatePipe"); <br> <br>  /* Now we need to change the inheritable property for the readable <br>  end of the pipe so that the child will not inherit that handle as <br>  a "garbage" handle. This will keep us from having extra, <br>  unclosable handles to the pipe. Alternatively, we could have <br>  opened the pipe with saPipe.bInheritHandle = FALSE and changed the <br>  inherit property on the *write* handle of the pipe to TRUE. */ <br> <br>  bSuccess = DuplicateHandle(GetCurrentProcess(), /* source process */ <br>      hReadPipe, /* handle to duplicate */ <br>      GetCurrentProcess(), /* destination process */ <br>      NULL, /* new handle - don't want one, change original handle */ <br>      0, /* new access flags - ignored since DUPLICATE_SAME_ACCESS */ <br>      FALSE, /* make it *not* inheritable */ <br>      DUPLICATE_SAME_ACCESS); <br>  PERR(bSuccess, "DuplicateHandle"); <br> <br>  /* I most cases you can get away with using the same anonymous <br>  pipe write handle for both the child's standard output and <br>  standard error, but this may cause problems if the child app <br>  explicitly closes one of its standard output or error handles. If <br>  that happens, the anonymous pipe will close, since the child's <br>  standard output and error handles are really the same handle. The <br>  child won't be able to write to the other write handle since the <br>  pipe is now gone, and parent reads from the pipe will return <br>  ERROR_BROKEN_PIPE and child output will be lost. To solve this <br>  problem, simply duplicate the write end of the pipe to create <br>  another distinct, separate handle to the write end of the pipe. <br>  One pipe write handle will serve as standard out, the other as <br>  standard error. Now *both* write handles must be closed before the <br>  write end of the pipe actually closes. */ <br> <br>  bSuccess = DuplicateHandle(GetCurrentProcess(), /* source process */ <br>      hWritePipe, /* handle to duplicate */ <br>      GetCurrentProcess(), /* destination process */ <br>      &amp;hWritePipe2, /* new handle, used as stderr by child */ <br>      0, /* new access flags - ignored since DUPLICATE_SAME_ACCESS */ <br>      TRUE, /* it's inheritable */ <br>      DUPLICATE_SAME_ACCESS); <br>  PERR(bSuccess, "DuplicateHandle"); <br> <br>  /* Set up the STARTUPINFO structure for the CreateProcess() call */ <br>  memset(&amp;si, 0, sizeof(si)); <br>  si.cb = sizeof(si); <br> <br>  /* Set up the command-line buffer for the child for CreateProcess() */ <br>  memset(szArgs, 0, sizeof(szArgs)); <br>  strcpy(szArgs, argv[2]); <br>  if (strchr(szArgs, '.') == NULL)  /* does it have a '.'? */ <br>    strcat(szArgs, ".exe");  /* if not, assume it's an .exe */ <br>  strcat(szArgs, " "); <br>  p = strchr(szArgs, 0);  /* point to the terminating null */ <br>  for (j = 3; j &lt; argc; j++) <br>    { <br>    strcat(p, argv[j]); <br>    /* the program and parameters are delimited by spaces */ <br>    strcat(p, " "); <br>    } <br> <br>#ifdef USESTDHANDLES <br>  /* If using the STARTUPINFO STARTF_USESTDHANDLES flag, be sure to <br>  set the CreateProcess fInheritHandles parameter too TRUE so that <br>  the file handles specified in the STARTUPINFO structure will be <br>  inheritied by the child. Note that we don't specify a standard <br>  input handle; the child will not inherit a valid input handle, so <br>  if it reads from stdin, it will encounter errors. */ <br> <br>  si.hStdInput = hWritePipe2; /* hStdInput needs a valid handle in case it is checked by the child */ <br>  si.hStdOutput = hWritePipe; /* write end of the pipe */ <br>  si.hStdError = hWritePipe2; /* duplicate of write end of the pipe */ <br>  si.dwFlags = STARTF_USESTDHANDLES; <br>#else <br>  /* If we're not using the STARTF_USESTDHANDLES flag, set the <br>  standard output and error handles to the end of the pipe we want <br>  the child to inherit with SetStdHandle(). For this program, we <br>  don't want standard input inherited so we'll also change the <br>  handle inheritance property of standard input so that it is not <br>  inherited */ <br>  bSuccess = SetStdHandle(STD_INPUT_HANDLE, hWritePipe2); <br>  PERR(bSuccess, "SetStdHandle"); <br>  bSuccess = SetStdHandle(STD_OUTPUT_HANDLE, hWritePipe); <br>  PERR(bSuccess, "SetStdHandle"); <br>  bSuccess = SetStdHandle(STD_ERROR_HANDLE, hWritePipe2); <br>  PERR(bSuccess, "SetStdHandle"); <br>  bSuccess = DuplicateHandle(GetCurrentProcess(), /* source process */ <br>      GetStdHandle(STD_INPUT_HANDLE), /* handle to duplicate */ <br>      GetCurrentProcess(), /* destination process */ <br>      NULL, /* new handle - don't want one, change original handle */ <br>      0, /* new access flags - ignored since DUPLICATE_SAME_ACCESS */ <br>      FALSE, /* it's *not* inheritable */ <br>      DUPLICATE_SAME_ACCESS); <br>  PERR(bSuccess, "DuplicateHandle"); <br>#endif <br> <br>  /* Now create the child process, inheriting handles */ <br> <br>  bSuccess = CreateProcess(NULL,  /* filename */ <br>      szArgs,  /* full command line for child */ <br>      NULL,  /* process security descriptor */ <br>      NULL,  /* thread security descriptor */ <br>      TRUE,  /* inherit handles? Also use if STARTF_USESTDHANDLES */ <br>      0,  /* creation flags */ <br>      NULL,  /* inherited environment address */ <br>      NULL,  /* startup dir; NULL = start in current */ <br>      &amp;si,  /* pointer to startup info (input) */ <br>      &amp;pi);  /* pointer to process info (output) */ <br>  PERR(bSuccess, "CreateProcess"); <br> <br>  /* We can close the returned child process handle and thread <br>  handle as we won't be needing them; you could, however, wait on <br>  the process handle to wait until the child process terminates. */ <br> <br>  CloseHandle(pi.hThread); <br>  CloseHandle(pi.hProcess); <br> <br>  /* We need to close our instances of the inheritable pipe write <br>  handle now that it's been inherited so that all open handles to <br>  the pipe are closed when the child process ends and closes its <br>  handles to the pipe. */ <br> <br>  bSuccess = CloseHandle(hWritePipe); <br>  PERR(bSuccess, "CloseHandle"); <br>  bSuccess = CloseHandle(hWritePipe2); <br>  PERR(bSuccess, "CloseHandle"); <br> <br>  /* read from the pipe until we get an ERROR_BROKEN_PIPE */ <br>  for (;;) <br>    { <br>    bSuccess = ReadFile(hReadPipe,  /* read handle */ <br>        chReadBuffer,  /* buffer for incoming data */ <br>        sizeof(chReadBuffer),  /* number of bytes to read */ <br>        &amp;cchReadBuffer,  /* number of bytes actually read */ <br>        NULL);  /* no overlapped reading */ <br>    if (!bSuccess &amp;&amp; (GetLastError() == ERROR_BROKEN_PIPE)) <br>        break;  /* child has died */ <br> <br>    PERR(bSuccess, "ReadFile"); <br>    if (bSuccess &amp;&amp; cchReadBuffer) <br>      { <br>      /* write the data from the child to the file */ <br>      bSuccess = WriteFile(hOutFile,  /* write handle */ <br>          chReadBuffer,  /* buffer to write */ <br>          cchReadBuffer,  /* number of bytes to write */ <br>          &amp;cchReadBuffer,  /* number of bytes actually written */ <br>          NULL);  /* no overlapped writing */ <br>      PERR(bSuccess, "WriteFile"); <br> <br>      /* write buffer (of specified length) to console */ <br>      printf("%.*s", cchReadBuffer, chReadBuffer); <br>      } <br>    } <br>  /* close the trace file, pipe handles */ <br>  CloseHandle(hOutFile); <br>  CloseHandle(hReadPipe); <br>  return(0); <br>} <br> <br>void PERR(BOOL bSuccess, char * api)  <br>{ <br>    DWORD       dwError; <br>    TCHAR       szMsgBuf[500]; <br> <br>    if (!(bSuccess))  <br>    { <br>        dwError = GetLastError(); <br>        printf("\nFile:%s\nError occured in %s on line %d\n", __FILE__, api, __LINE__); <br> <br>    FormatMessage( <br>        FORMAT_MESSAGE_FROM_SYSTEM, <br>        NULL,                               // ignored <br>        dwError,                     // message id <br>        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),   // message language <br>        szMsgBuf,                   // address of buffer pointer <br>        500,                                  // minimum buffer size <br>        NULL );                              // no other arguments <br> <br>        printf("\nError:(%ld)%s ", dwError, szMsgBuf); <br>     } <br>} <br> <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
