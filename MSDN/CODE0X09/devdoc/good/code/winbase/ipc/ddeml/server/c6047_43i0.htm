<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DDEMLSV.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6048"></a>DDEMLSV.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples. <br>*       Copyright 1993 - 1998 Microsoft Corporation. <br>*       All rights reserved. <br>*       This source code is only intended as a supplement to <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>/**************************************************************************** <br> <br>    PROGRAM: Server.c <br> <br>    PURPOSE: Server template for Windows applications <br> <br>    FUNCTIONS: <br> <br>        WinMain() - calls initialization function, processes message loop <br>        InitApplication() - initializes window data and registers window <br>        InitInstance() - saves instance handle and creates main window <br>        MainWndProc() - processes messages <br>        About() - processes messages for "About" dialog box <br> <br>    COMMENTS: <br> <br>        Windows can have several copies of your application running at the <br>        same time.  The variable hInst keeps track of which instance this <br>        application is so that processing will be to the correct window. <br> <br>****************************************************************************/ <br> <br>#include &lt;stdio.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;string.h&gt; <br>#include &lt;tchar.h&gt; <br>#include "server.h"                 /* specific to this program              */ <br>#include "huge.h" <br> <br>DWORD idInst = 0; <br>CONVCONTEXT CCFilter = { sizeof(CONVCONTEXT), 0, 0, 0, 0L, 0L, <br>    { <br>        sizeof(SECURITY_QUALITY_OF_SERVICE), <br>        SecurityImpersonation, <br>        SECURITY_STATIC_TRACKING, <br>        TRUE <br>    } <br>}; <br>HANDLE hInst;                       /* current instance                      */ <br>HWND hwndServer; <br>RECT rcRand; <br>RECT rcCount; <br>RECT rcComment; <br>RECT rcExec; <br>RECT rcConnCount; <br>RECT rcRndrDelay; <br>RECT rcRunaway; <br>RECT rcAllBlock; <br>RECT rcNextAction; <br>RECT rcHugeSize; <br>RECT rcAppowned; <br>BOOL fAllBlocked = FALSE; <br>BOOL fAllEnabled = TRUE; <br>BOOL fEnableOneCB = FALSE; <br>BOOL fBlockNextCB = FALSE; <br>BOOL fTermNextCB = FALSE; <br>BOOL fAppowned = FALSE; <br>WORD cRunaway = 0; <br>WORD RenderDelay = 0; <br>DWORD count = 0; <br>WORD seed = 0; <br>HSZ hszAppName = 0; <br>TCHAR szClass[] = TEXT("ServerWClass"); <br>TCHAR szTopic[MAX_TOPIC] = TEXT("Test"); <br>TCHAR szServer[MAX_TOPIC] = TEXT("Server"); <br>TCHAR szComment[MAX_COMMENT] = TEXT(""); <br>TCHAR szExec[MAX_EXEC] = TEXT(""); <br>TCHAR *pszComment = szComment; <br>WORD cyText; <br>WORD cServers = 0; <br>HDDEDATA hDataHelp[CFORMATS] = {0}; <br>HDDEDATA hDataCount[CFORMATS] = {0}; <br>HDDEDATA hDataRand[CFORMATS] = {0}; <br>HDDEDATA hDataHuge[CFORMATS] = {0}; <br>DWORD cbHuge = 0; <br> <br>TCHAR szDdeHelp[] = TEXT("DDEML test server help:\r\n\n")\ <br>    TEXT("The 'Server'(service) and 'Test'(topic) names may change.\r\n\n")\ <br>    TEXT("Items supported under the 'Test' topic are:\r\n")\ <br>    TEXT("\tCount:\tThis value increments on each data change.\r\n")\ <br>    TEXT("\tRand:\tThis value is randomly generated each data change.\r\n")\ <br>    TEXT("\tHuge:\tThis is randomlly generated text data &gt;64k that the\r\n")\ <br>    TEXT("\t\tDDEML test client can verify.\r\n")\ <br>    TEXT("The above items change after any request if in Runaway mode and \r\n")\ <br>    TEXT("can bo POKEed in order to change their values.  POKEed Huge data \r\n")\ <br>    TEXT("must be in a special format to verify the correctness of the data \r\n")\ <br>    TEXT("or it will not be accepted.\r\n")\ <br>    TEXT("If the server is set to use app owned data handles, all data sent \r\n")\ <br>    TEXT("uses HDATA_APPOWNED data handles.")\ <br>    ; <br> <br>FORMATINFO aFormats[CFORMATS] = { <br>#ifdef UNICODE <br>    { 0, TEXT("CF_UNICODETEXT") },       // exception!  predefined format <br>#else <br>    { 0, TEXT("CF_TEXT") },       // exception!  predefined format <br>#endif <br>    { 0, TEXT("Dummy1")  }, <br>    { 0, TEXT("Dummy2")  }, <br>}; <br> <br> <br>/* <br> *          Topic and Item tables supported by this application. <br> */ <br> <br>/*   HSZ    PROCEDURE       PSZ        */ <br> <br>ITEMLIST SystemTopicItemList[CSYSTEMITEMS] = { <br> <br>    { 0, TopicListXfer,  SZDDESYS_ITEM_TOPICS   }, <br>    { 0, ItemListXfer,   SZDDESYS_ITEM_SYSITEMS }, <br>    { 0, sysFormatsXfer, SZDDESYS_ITEM_FORMATS  }, <br>    { 0, HelpXfer,       SZDDESYS_ITEM_HELP}, <br>  }; <br> <br> <br>ITEMLIST TestTopicItemList[CTESTITEMS] = { <br> <br>    { 0, TestRandomXfer, TEXT("Rand") },   // 0 index <br>    { 0, TestCountXfer,  TEXT("Count")},   // 1 index <br>    { 0, TestHugeXfer,   TEXT("Huge") },   // 2 index <br>    { 0, ItemListXfer,   SZDDESYS_ITEM_SYSITEMS },  // 3 index <br>  }; <br> <br> <br>/* The system topic is always assumed to be first. */ <br>/*   HSZ   PROCEDURE            #ofITEMS        PSZ     */ <br>TOPICLIST topicList[CTOPICS] = { <br> <br>    { 0, SystemTopicItemList,   CSYSTEMITEMS,   SZDDESYS_TOPIC},    // 0 index <br>    { 0, TestTopicItemList,     CTESTITEMS,     szTopic},           // 1 index <br>  }; <br> <br> <br> <br> <br> <br> <br>/**************************************************************************** <br> <br>    FUNCTION: WinMain(HANDLE, HANDLE, LPTSTR, int) <br> <br>    PURPOSE: calls initialization function, processes message loop <br> <br>    COMMENTS: <br> <br>        Windows recognizes this function by name as the initial entry point <br>        for the program.  This function calls the application initialization <br>        routine, if no other instance of the program is running, and always <br>        calls the instance initialization routine.  It then executes a message <br>        retrieval and dispatch loop that is the top-level control structure <br>        for the remainder of execution.  The loop is terminated when a WM_QUIT <br>        message is received, at which time this function exits the application <br>        instance by returning the value passed by PostQuitMessage(). <br> <br>        If this function must abort before entering the message loop, it <br>        returns the conventional value NULL. <br> <br>****************************************************************************/ <br> <br>INT WINAPI WinMain( <br>HINSTANCE hInstance, <br>HINSTANCE hPrevInstance, <br>LPSTR lpCmdLine, <br>INT nCmdShow) <br>{ <br>    MSG msg;                                 /* message                      */ <br> <br>    if (!hPrevInstance)                  /* Other instances of app running? */ <br>        if (!InitApplication(hInstance)) /* Initialize shared things */ <br>            return (FALSE);              /* Exits if unable to initialize     */ <br> <br>    /* Perform initializations that apply to a specific instance */ <br> <br>    if (!InitInstance(hInstance, nCmdShow)) <br>        return (FALSE); <br> <br>    /* Acquire and dispatch messages until a WM_QUIT message is received. */ <br> <br>    while (GetMessage(&amp;msg,     /* message structure                      */ <br>            0,                  /* handle of window receiving the message */ <br>            0,                  /* lowest message to examine              */ <br>            0))                 /* highest message to examine             */ <br>        { <br>        TranslateMessage(&amp;msg);    /* Translates virtual key codes           */ <br>        DispatchMessage(&amp;msg);     /* Dispatches message to window           */ <br>    } <br> <br>    UnregisterClass(szClass, hInstance); <br>    return (msg.wParam);           /* Returns the value from PostQuitMessage */ <br>} <br> <br> <br>/**************************************************************************** <br> <br>    FUNCTION: InitApplication(HANDLE) <br> <br>    PURPOSE: Initializes window data and registers window class <br> <br>    COMMENTS: <br> <br>        This function is called at initialization time only if no other <br>        instances of the application are running.  This function performs <br>        initialization tasks that can be done once for any number of running <br>        instances. <br> <br>        In this case, we initialize a window class by filling out a data <br>        structure of type WNDCLASS and calling the Windows RegisterClass() <br>        function.  Since all instances of this application use the same window <br>        class, we only need to do this when the first instance is initialized. <br> <br> <br>****************************************************************************/ <br> <br>BOOL InitApplication(hInstance) <br>HANDLE hInstance;                              /* current instance           */ <br>{ <br>    WNDCLASS  wc; <br> <br>    /* Fill in window class structure with parameters that describe the       */ <br>    /* main window.                                                           */ <br> <br>    wc.style = 0;                       /* Class style(s).                    */ <br>    wc.lpfnWndProc = MainWndProc;       /* Function to retrieve messages for  */ <br>                                        /* windows of this class.             */ <br>    wc.cbClsExtra = 0;                  /* No per-class extra data.           */ <br>    wc.cbWndExtra = 0;                  /* No per-window extra data.          */ <br>    wc.hInstance = hInstance;           /* Application that owns the class.   */ <br>    wc.hIcon = LoadIcon(hInstance, TEXT("server")); <br>    wc.hCursor = LoadCursor(NULL, IDC_ARROW); <br>    wc.hbrBackground = (HANDLE)(COLOR_APPWORKSPACE+1); <br>    wc.lpszMenuName =  TEXT("ServerMenu");   /* Name of menu resource in .RC file. */ <br>    wc.lpszClassName = TEXT("ServerWClass"); /* Name used in call to CreateWindow. */ <br> <br>    /* Register the window class and return success/failure code. */ <br> <br>    return (RegisterClass(&amp;wc)); <br> <br>} <br> <br> <br>/**************************************************************************** <br> <br>    FUNCTION:  InitInstance(HANDLE, int) <br> <br>    PURPOSE:  Saves instance handle and creates main window <br> <br>    COMMENTS: <br> <br>        This function is called at initialization time for every instance of <br>        this application.  This function performs initialization tasks that <br>        cannot be shared by multiple instances. <br> <br>        In this case, we save the instance handle in a static variable and <br>        create and display the main program window. <br> <br>****************************************************************************/ <br> <br>BOOL InitInstance(hInstance, nCmdShow) <br>    HANDLE          hInstance;          /* Current instance identifier.       */ <br>    INT             nCmdShow;           /* Param for first ShowWindow() call. */ <br>{ <br>    INT i; <br>    RECT Rect; <br>    TEXTMETRIC metrics; <br>    HDC hdc; <br>    TCHAR szTitle[40] = <br>#ifdef UNICODE <br>        TEXT("Server|Test (Unicode)"); <br>#else <br>        TEXT("Server|Test"); <br>#endif <br> <br>    /* Save the instance handle in static variable, which will be used in  */ <br>    /* many subsequence calls from this application to Windows.            */ <br> <br>    hInst = hInstance; <br> <br> <br>    /* Create a main window for this application instance.  */ <br> <br>    hwndServer = CreateWindow( <br>        TEXT("ServerWClass"),                /* See RegisterClass() call.          */ <br>        szTitle, <br>        WS_OVERLAPPEDWINDOW,            /* Window style.                      */ <br>        CW_USEDEFAULT,                  /* Default horizontal position.       */ <br>        CW_USEDEFAULT,                  /* Default vertical position.         */ <br>        400, <br>        200, <br>        NULL,                           /* Overlapped windows have no parent. */ <br>        NULL,                           /* Use the window class menu.         */ <br>        hInstance,                      /* This instance owns this window.    */ <br>        NULL                            /* Pointer not needed.                */ <br>    ); <br> <br>    GetClientRect(hwndServer, (LPRECT) &amp;Rect); <br> <br>    /* If window could not be created, return "failure" */ <br> <br>    if (!hwndServer) <br>        return (FALSE); <br> <br>    hdc = GetDC(hwndServer); <br>    GetTextMetrics(hdc, &amp;metrics); <br>    cyText = (WORD)(metrics.tmHeight + metrics.tmExternalLeading); <br>    ReleaseDC(hwndServer, hdc); <br> <br>#ifdef UNICODE <br>    aFormats[0].atom = CF_UNICODETEXT; // exception - predefined. <br>#else <br>    aFormats[0].atom = CF_TEXT; // exception - predefined. <br>#endif <br>    for (i = 1; i &lt; CFORMATS; i++) { <br>        aFormats[i].atom = RegisterClipboardFormat(aFormats[i].sz); <br>    } <br> <br>    /* Make the window visible; update its client area; and return "success" */ <br> <br>    ShowWindow(hwndServer, nCmdShow);  /* Show the window                        */ <br>    UpdateWindow(hwndServer);          /* Sends WM_PAINT message                 */ <br>    seed = 1; <br>    srand(1); <br>    CCFilter.iCodePage = CP_WINANSI;   // initial default codepage <br>    if (!DdeInitialize(&amp;idInst, (PFNCALLBACK)MakeProcInstance((FARPROC)DdeCallback, <br>                hInstance), APPCMD_FILTERINITS, 0)) { <br>        Hszize(); <br>        DdeNameService(idInst, hszAppName, 0, DNS_REGISTER); <br>        return(TRUE); <br>    } <br>    return (FALSE); <br> <br>} <br> <br>/**************************************************************************** <br> <br>    FUNCTION: MainWndProc(HWND, unsigned, WORD, LONG) <br> <br>    PURPOSE:  Processes messages <br> <br>    MESSAGES: <br> <br>        WM_COMMAND    - application menu (About dialog box) <br>        WM_DESTROY    - destroy window <br> <br>    COMMENTS: <br> <br>        To process the IDM_ABOUT message, call MakeProcInstance() to get the <br>        current instance address of the About() function.  Then call Dialog <br>        box which will create the box according to the information in your <br>        server.rc file and turn control over to the About() function.   When <br>        it returns, free the intance address. <br> <br>****************************************************************************/ <br> <br>LONG  APIENTRY MainWndProc(hWnd, message, wParam, lParam) <br>HWND hWnd;                                /* window handle                   */ <br>UINT message;                         /* type of message                 */ <br>WPARAM wParam;                              /* additional information          */ <br>LPARAM lParam;                              /* additional information          */ <br>{ <br>    switch (message) { <br>    case WM_INITMENU: <br>        if (GetMenu(hWnd) != (HMENU)wParam) <br>            break; <br> <br>        CheckMenuItem((HMENU)wParam, IDM_BLOCKALLCBS, <br>                fAllBlocked ? MF_CHECKED : MF_UNCHECKED); <br>        CheckMenuItem((HMENU)wParam, IDM_UNBLOCKALLCBS, <br>                fAllEnabled ? MF_CHECKED : MF_UNCHECKED); <br>        CheckMenuItem((HMENU)wParam, IDM_BLOCKNEXTCB, <br>                fBlockNextCB ? MF_CHECKED : MF_UNCHECKED); <br>        CheckMenuItem((HMENU)wParam, IDM_TERMNEXTCB, <br>                fTermNextCB ? MF_CHECKED : MF_UNCHECKED); <br>        CheckMenuItem((HMENU)wParam, IDM_RUNAWAY, <br>                cRunaway ? MF_CHECKED : MF_UNCHECKED); <br>        CheckMenuItem((HMENU)wParam, IDM_APPOWNED, <br>                fAppowned ? MF_CHECKED : MF_UNCHECKED); <br>        break; <br> <br>    case WM_COMMAND:           /* message: command from application menu */ <br>        switch (LOWORD(wParam)) { <br>        case IDM_ENABLEONECB: <br>            DdeEnableCallback(idInst, 0, EC_ENABLEONE); <br>            fAllBlocked = FALSE; <br>            fAllEnabled = FALSE; <br>            InvalidateRect(hwndServer, &amp;rcAllBlock, TRUE); <br>            break; <br> <br>        case IDM_TERMNEXTCB: <br>            fTermNextCB = !fTermNextCB; <br>            InvalidateRect(hwndServer, &amp;rcNextAction, TRUE); <br>            break; <br> <br>        case IDM_BLOCKNEXTCB: <br>            fBlockNextCB = !fBlockNextCB; <br>            InvalidateRect(hwndServer, &amp;rcNextAction, TRUE); <br>            break; <br> <br>        case IDM_BLOCKALLCBS: <br>            DdeEnableCallback(idInst, 0, EC_DISABLE); <br>            fAllBlocked = TRUE; <br>            fAllEnabled = FALSE; <br>            InvalidateRect(hwndServer, &amp;rcAllBlock, TRUE); <br>            break; <br> <br>        case IDM_UNBLOCKALLCBS: <br>            DdeEnableCallback(idInst, 0, EC_ENABLEALL); <br>            fAllEnabled = TRUE; <br>            fAllBlocked = FALSE; <br>            InvalidateRect(hwndServer, &amp;rcAllBlock, TRUE); <br>            break; <br> <br>        case IDM_APPOWNED: <br>            fAppowned = !fAppowned; <br>            if (!fAppowned) { <br>                WORD iFmt; <br>                for (iFmt = 0; iFmt &lt; CFORMATS; iFmt++) { <br>                    if (hDataHuge[iFmt]) { <br>                        DdeFreeDataHandle(hDataHuge[iFmt]); <br>                        hDataHuge[iFmt] = 0; <br>                        InvalidateRect(hwndServer, &amp;rcHugeSize, TRUE); <br>                    } <br>                    if (hDataCount[iFmt]) { <br>                        DdeFreeDataHandle(hDataCount[iFmt]); <br>                        hDataCount[iFmt] = 0; <br>                    } <br>                    if (hDataRand[iFmt]) { <br>                        DdeFreeDataHandle(hDataRand[iFmt]); <br>                        hDataRand[iFmt] = 0; <br>                    } <br>                    if (hDataHelp[iFmt]) { <br>                        DdeFreeDataHandle(hDataHelp[iFmt]); <br>                        hDataHelp[iFmt] = 0; <br>                    } <br>                } <br>            } <br>            InvalidateRect(hwndServer, &amp;rcAppowned, TRUE); <br>            break; <br> <br>        case IDM_RUNAWAY: <br>            cRunaway = !cRunaway; <br>            InvalidateRect(hwndServer, &amp;rcRunaway, TRUE); <br>            if (!cRunaway) { <br>                break; <br>            } <br>            // fall through <br> <br>        case IDM_CHANGEDATA: <br>            PostMessage(hwndServer, UM_CHGDATA, 1, 0);  // rand <br>            PostMessage(hwndServer, UM_CHGDATA, 1, 1);  // count <br>            break; <br> <br>        case IDM_RENDERDELAY: <br>            DoDialog(MAKEINTRESOURCE(DID_VALUEENTRY), (DLGPROC)RenderDelayDlgProc, 0, TRUE); <br>            InvalidateRect(hwndServer, &amp;rcRndrDelay, TRUE); <br>            break; <br> <br>        case IDM_SETSERVER: <br>            DoDialog(MAKEINTRESOURCE(DID_VALUEENTRY), (DLGPROC)SetServerDlgProc, 0, TRUE); <br>            break; <br> <br>        case IDM_SETTOPIC: <br>            DoDialog(MAKEINTRESOURCE(DID_VALUEENTRY), (DLGPROC)SetTopicDlgProc, 0, TRUE); <br>            break; <br> <br>        case IDM_CONTEXT: <br>            DoDialog(MAKEINTRESOURCE(DID_CONTEXT), (DLGPROC)ContextDlgProc, 0, TRUE); <br>            break; <br> <br>        case IDM_ABOUT: <br>            DoDialog(MAKEINTRESOURCE(DID_ABOUT), (DLGPROC)About, 0, TRUE); <br>            break; <br> <br>        case IDM_HELP: <br>           break; <br> <br>        default: <br>            return (DefWindowProc(hWnd, message, wParam, lParam)); <br>        } <br>        break; <br> <br>    case WM_PAINT: <br>        PaintServer(hWnd); <br>        break; <br> <br>    case UM_CHGDATA: <br>        { <br>            WORD iFmt; <br> <br>            // wParam = TopicIndex, <br>            // LOWORD(lParam) = ItemIndex <br>            // We asynchronously do DdePostAdvise() calls to prevent infinite <br>            // loops when in runaway mode. <br>            if (wParam == 1) {  // test topic <br>                if (lParam == 0) {  // rand item <br>                    seed = rand(); <br>                    for (iFmt = 0; iFmt &lt; CFORMATS ; iFmt++) { <br>                        if (hDataRand[iFmt]) { <br>                            DdeFreeDataHandle(hDataRand[iFmt]); <br>                            hDataRand[iFmt] = 0; <br>                        } <br>                    } <br>                    InvalidateRect(hwndServer, &amp;rcRand, TRUE); <br>                    DdePostAdvise(idInst, topicList[wParam].hszTopic, <br>                            (HSZ)topicList[wParam].pItemList[lParam].hszItem); <br>                } <br>                if (lParam == 1) {  // count item <br>                    count++; <br>                    for (iFmt = 0; iFmt &lt; CFORMATS ; iFmt++) { <br>                        if (hDataCount[iFmt]) { <br>                            DdeFreeDataHandle(hDataCount[iFmt]); <br>                            hDataCount[iFmt] = 0; <br>                        } <br>                    } <br>                    InvalidateRect(hwndServer, &amp;rcCount, TRUE); <br>                    DdePostAdvise(idInst, topicList[wParam].hszTopic, <br>                            (HSZ)topicList[wParam].pItemList[lParam].hszItem); <br>                } <br>                // Huge item does not runaway - too slow. <br>            } <br>            if (cRunaway) { <br>                Delay(50, TRUE); <br>                        // This gives enough time for the system to remain <br>                        // useable in runaway mode. <br>                PostMessage(hwndServer, UM_CHGDATA, wParam, lParam); <br>            } <br>        } <br>        break; <br> <br>    case WM_DESTROY:                  /* message: window being destroyed */ <br>        if (fAppowned) <br>            SendMessage(hwndServer, WM_COMMAND, (WPARAM)MAKELONG(IDM_APPOWNED, 0), (LONG)(0)); <br>        DdeNameService(idInst, 0, 0, DNS_UNREGISTER); // unregister all services <br>        UnHszize(); <br>        DdeUninitialize(idInst); <br>        PostQuitMessage(0); <br>        break; <br> <br>    default: <br>        return (DefWindowProc(hWnd, message, wParam, lParam)); <br>    } <br>    return(0); <br>} <br> <br> <br> <br> <br> <br>VOID Delay( <br>DWORD delay, <br>BOOL fModal) <br>{ <br>    MSG msg; <br>    delay = GetCurrentTime() + delay; <br>    while (GetCurrentTime() &lt; delay) { <br>        if (fModal &amp;&amp; PeekMessage(&amp;msg, 0, 0, 0, PM_REMOVE)) { <br>            TranslateMessage(&amp;msg); <br>            DispatchMessage(&amp;msg); <br>        } <br>    } <br>} <br> <br> <br> <br>/* <br> * This function not only paints the server client area with current info, <br> * it also has the side effect of setting the global RECTs that bound each <br> * info area.  This way flashing is reduced. <br> */ <br>VOID PaintServer( <br>HWND hwnd) <br>{ <br>    PAINTSTRUCT ps; <br>    RECT rc; <br>    TCHAR szT[MAX_COMMENT]; <br> <br>    BeginPaint(hwnd, &amp;ps); <br>    SetBkMode(ps.hdc, TRANSPARENT); <br>    GetClientRect(hwnd, &amp;rc); <br>    rc.bottom = rc.top + cyText;    // all rects are cyText in height. <br> <br>    rcComment = rc; <br>    DrawTextLine(ps.hdc, &amp;ps.rcPaint, &amp;rc, pszComment); <br> <br>    wsprintf(szT, TEXT("# of connections:%d"), cServers); <br>    rcConnCount = rc; <br>    DrawTextLine(ps.hdc, &amp;ps.rcPaint, &amp;rc, szT); <br> <br>    szT[0] = TEXT('\0'); <br>    rcAllBlock = rc; <br>    if (fAllEnabled) <br>        DrawTextLine(ps.hdc, &amp;ps.rcPaint, &amp;rc, TEXT("All Conversations are Enabled.")); <br>    else if (fAllBlocked) <br>        DrawTextLine(ps.hdc, &amp;ps.rcPaint, &amp;rc, TEXT("All Conversations are Blocked.")); <br>    else <br>        DrawTextLine(ps.hdc, &amp;ps.rcPaint, &amp;rc, szT); <br> <br>    rcNextAction = rc; <br>    if (fBlockNextCB) <br>        DrawTextLine(ps.hdc, &amp;ps.rcPaint, &amp;rc, TEXT("Next callback will block.")); <br>    else if (fTermNextCB) <br>        DrawTextLine(ps.hdc, &amp;ps.rcPaint, &amp;rc, TEXT("Next callback will terminate.")); <br>    else <br>        DrawTextLine(ps.hdc, &amp;ps.rcPaint, &amp;rc, szT); <br> <br>    wsprintf(szT, TEXT("Count item = %ld"), count); <br>    rcCount = rc; <br>    DrawTextLine(ps.hdc, &amp;ps.rcPaint, &amp;rc, szT); <br> <br>    wsprintf(szT, TEXT("Rand item = %d"), seed); <br>    rcRand = rc; <br>    DrawTextLine(ps.hdc, &amp;ps.rcPaint, &amp;rc, szT); <br> <br>    wsprintf(szT, TEXT("Huge item size = %ld"), cbHuge); <br>    rcHugeSize = rc; <br>    DrawTextLine(ps.hdc, &amp;ps.rcPaint, &amp;rc, szT); <br> <br>    wsprintf(szT, TEXT("Render delay is %d milliseconds."), RenderDelay); <br>    rcRndrDelay = rc; <br>    DrawTextLine(ps.hdc, &amp;ps.rcPaint, &amp;rc, szT); <br> <br>    rcExec = rc; <br>    DrawTextLine(ps.hdc, &amp;ps.rcPaint, &amp;rc, szExec); <br> <br>    rcRunaway = rc; <br>    DrawTextLine(ps.hdc, &amp;ps.rcPaint, &amp;rc, cRunaway ? TEXT("Runaway active.") : TEXT("")); <br> <br>    rcAppowned = rc; <br>    DrawTextLine(ps.hdc, &amp;ps.rcPaint, &amp;rc, fAppowned ? TEXT("Using AppOwned Data Handles.") : TEXT("")); <br> <br>    EndPaint(hwnd, &amp;ps); <br>} <br> <br> <br>VOID DrawTextLine( <br>HDC hdc, <br>RECT *prcClip, <br>RECT *prcText, <br>PTSTR psz) <br>{ <br>    RECT rc; <br> <br>    if (IntersectRect(&amp;rc, prcText, prcClip)) { <br>        DrawText(hdc, psz, -1, prcText, <br>                DT_LEFT | DT_EXTERNALLEADING | DT_SINGLELINE | DT_EXPANDTABS | <br>                DT_NOCLIP | DT_NOPREFIX); <br>    } <br>    OffsetRect(prcText, 0, cyText); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
