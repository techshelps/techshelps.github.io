<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DDEMLCL.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6019"></a>DDEMLCL.C</h2>
<pre><code><br> <br> <br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples. <br>*       Copyright 1993 - 1998 Microsoft Corporation. <br>*       All rights reserved. <br>*       This source code is only intended as a supplement to <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>/*************************************************************************** <br> *                                                                         * <br> *  PROGRAM     : client.c                                                 * <br> *                                                                         * <br> *  PURPOSE     : To demonstrate how to use the DDEML library from the     * <br> *                client side and for basic testing of the DDEML API.      * <br> *                                                                         * <br> ***************************************************************************/ <br> <br>#include "client.h" <br>#include &lt;string.h&gt; <br>#include &lt;memory.h&gt; <br>#include "infoctrl.h" <br> <br>/* global variables used in this module or among more than one module */ <br>CONVCONTEXT CCFilter = { sizeof(CONVCONTEXT), 0, 0, 0, 0L, 0L, <br>    { <br>        sizeof(SECURITY_QUALITY_OF_SERVICE), <br>        SecurityImpersonation, <br>        SECURITY_STATIC_TRACKING, <br>        TRUE <br>    } <br>}; <br>DWORD idInst = 0; <br>HANDLE hInst;                       /* Program instance handle               */ <br>HANDLE hAccel;                      /* Main accelerator resource             */ <br>HWND hwndFrame           = NULL;    /* Handle to main window                 */ <br>HWND hwndMDIClient       = NULL;    /* Handle to MDI client                  */ <br>HWND hwndActive          = NULL;    /* Handle to currently activated child   */ <br>LONG DefTimeout      = DEFTIMEOUT;  /* default synchronous transaction timeout */ <br>DWORD wDelay = 0; <br>BOOL fBlockNextCB = FALSE;     /* set if next callback causes a CBR_BLOCK    */ <br>BOOL fTermNextCB = FALSE;      /* set to call DdeDisconnect() on next callback */ <br>BOOL fAutoReconnect = FALSE;   /* set if DdeReconnect() is to be called on XTYP_DISCONNECT callbacks */ <br>HDDEDATA hDataOwned = 0;       /* Current owned huge data handle             */ <br>DWORD fmtLink = 0;                  /* link clipboard format number          */ <br>DWORD DefOptions = 0;               /* default transaction optons            */ <br>OWNED aOwned[MAX_OWNED];            /* list of all owned handles.            */ <br>DWORD cOwned = 0;                   /* number of existing owned handles.     */ <br>FARPROC lpMsgFilterProc;            /* instance proc from MSGF_DDEMGR filter */ <br>HSZ hszHuge;                        /* used for checking huge item data */ <br>HHOOK ghhk = 0; <br> <br>/* <br> * This is the array of formats we support <br> */ <br>FORMATINFO aFormats[] = { <br>#ifdef UNICODE <br>    { CF_UNICODETEXT, TEXT("CF_UNICODETEXT") },       // exception!  predefined format <br>#else <br>    { CF_TEXT, TEXT("CF_TEXT") },       // exception!  predefined format <br>#endif <br>    { 0, TEXT("Dummy1")  }, <br>    { 0, TEXT("Dummy2")  }, <br>}; <br> <br>/* Forward declarations of helper functions in this module */ <br>VOID NEAR PASCAL CloseAllChildren(VOID); <br>VOID NEAR PASCAL InitializeMenu (HANDLE); <br>VOID NEAR PASCAL CommandHandler (HWND,DWORD); <br>VOID NEAR PASCAL SetWrap (HWND,BOOL); <br> <br>/**************************************************************************** <br> *                                                                          * <br> *  FUNCTION   : WinMain(HANDLE, HANDLE, LPTSTR, int)                        * <br> *                                                                          * <br> *  PURPOSE    : Creates the "frame" window, does some initialization and   * <br> *               enters the message loop.                                   * <br> *                                                                          * <br> ****************************************************************************/ <br>int WINAPI WinMain( <br>HINSTANCE hInstance, <br>HINSTANCE hPrevInstance, <br>LPSTR  lpszCmdLine, <br>INT    nCmdShow) <br>{ <br>    MSG msg; <br> <br>    hInst = hInstance; <br> <br>    /* If this is the first instance of the app. register window classes */ <br>    if (!hPrevInstance){ <br>        if (!InitializeApplication ()) <br>            return 0; <br>    } <br> <br>    /* Create the frame and do other initialization */ <br>    if (!InitializeInstance(nCmdShow)) <br>        return 0; <br> <br>    /* Enter main message loop */ <br>    while (GetMessage (&amp;msg, NULL, 0, 0)){ <br>        ((HOOKPROC)*lpMsgFilterProc)(MSGF_DDEMGR, 0, (LONG)(LPMSG)&amp;msg); <br>    } <br> <br>    // free up any appowned handles <br>    while (cOwned) { <br>        DdeFreeDataHandle(aOwned[--cOwned].hData); <br>    } <br>    DdeFreeStringHandle(idInst, hszHuge); <br>    DdeUninitialize(idInst); <br> <br>    UnhookWindowsHook(WH_MSGFILTER, (HOOKPROC)lpMsgFilterProc); <br>    FreeProcInstance(lpMsgFilterProc); <br> <br>    return 0; <br>} <br> <br>/**************************************************************************** <br> *                                                                          * <br> *  FUNCTION   : FrameWndProc (hwnd, msg, wParam, lParam )                  * <br> *                                                                          * <br> *  PURPOSE    : The window function for the "frame" window, which controls * <br> *               the menu and encompasses all the MDI child windows. Does   * <br> *               the major part of the message processing. Specifically, in * <br> *               response to:                                               * <br> *                                                                          * <br> ****************************************************************************/ <br>LONG  APIENTRY FrameWndProc ( hwnd, msg, wParam, lParam ) <br>HWND   hwnd; <br>UINT   msg; <br>WPARAM wParam; <br>LPARAM lParam; <br> <br>{ <br>    switch (msg){ <br>        case WM_CREATE:{ <br>            CLIENTCREATESTRUCT ccs; <br> <br>            /* Find window menu where children will be listed */ <br>            ccs.hWindowMenu = GetSubMenu (GetMenu(hwnd),WINDOWMENU); <br>            ccs.idFirstChild = IDM_WINDOWCHILD; <br> <br>            /* Create the MDI client filling the client area */ <br>            hwndMDIClient = CreateWindow (TEXT("mdiclient"), <br>                                          NULL, <br>                                          WS_CHILD | WS_CLIPCHILDREN | <br>                                          WS_VSCROLL | WS_HSCROLL, <br>                                          0, <br>                                          0, <br>                                          0, <br>                                          0, <br>                                          hwnd, <br>                                          (HMENU)0xCAC, <br>                                          hInst, <br>                                          (LPTSTR)&amp;ccs); <br> <br> <br>            ShowWindow (hwndMDIClient,SW_SHOW); <br>            break; <br>        } <br> <br>        case WM_INITMENU: <br>            InitializeMenu ((HMENU)wParam); <br>            break; <br> <br>        case WM_COMMAND: <br>            CommandHandler (hwnd, LOWORD(wParam)); <br>            break; <br> <br>        case WM_CLOSE: <br>            CloseAllChildren(); <br>            DestroyWindow(hwnd); <br>            break; <br> <br>        case WM_DESTROY: <br>            PostQuitMessage(0); <br>            break; <br> <br>        default: <br>            /*  use DefFrameProc() instead of DefWindowProc() since there <br>             *  are things that have to be handled differently because of MDI <br>             */ <br>            return DefFrameProc (hwnd,hwndMDIClient,msg,wParam,lParam); <br>    } <br>    return 0; <br>} <br> <br> <br> <br> <br> <br>/**************************************************************************** <br> *                                                                          * <br> *  FUNCTION   : MDIChildWndProc                                            * <br> *                                                                          * <br> *  PURPOSE    : The window function for the "child" conversation and list  * <br> *               windows.                                                   * <br> *                                                                          * <br> ****************************************************************************/ <br>LONG  APIENTRY MDIChildWndProc( hwnd, msg, wParam, lParam ) <br>HWND   hwnd; <br>UINT   msg; <br>WPARAM wParam; <br>LPARAM lParam; <br>{ <br>    MYCONVINFO *pmci; <br>    RECT rc; <br> <br>    switch (msg){ <br>    case WM_CREATE: <br>        /* <br>         * Create a coresponding conversation info structure to link this <br>         * window to the conversation or conversation list it represents. <br>         * <br>         * lParam: points to the conversation info to initialize our copy to. <br>         */ <br>        pmci = (MYCONVINFO *)MyAlloc(sizeof(MYCONVINFO)); <br>        if (pmci != NULL) { <br>            memcpy(pmci, <br>                    (LPTSTR)((LPMDICREATESTRUCT)((LPCREATESTRUCT)lParam)-&gt;lpCreateParams)-&gt;lParam, <br>                    sizeof(MYCONVINFO)); <br>            pmci-&gt;hwndXaction = 0;              /* no current transaction yet */ <br>            pmci-&gt;x = pmci-&gt;y = 0;              /* new transaction windows start here */ <br>            DdeKeepStringHandle(idInst, pmci-&gt;hszTopic);/* keep copies of the hszs for us */ <br>            DdeKeepStringHandle(idInst, pmci-&gt;hszApp); <br> <br>             // link hConv and hwnd together <br>            SetWindowLong(hwnd, 0, (DWORD)pmci); <br> <br>            /* <br>             * non-list windows link the conversations to the windows via the <br>             * conversation user handle. <br>             */ <br>            if (!pmci-&gt;fList) <br>                DdeSetUserHandle(pmci-&gt;hConv, QID_SYNC, (DWORD)hwnd); <br>        } <br>        goto CallDCP; <br>        break; <br> <br>    case UM_GETNEXTCHILDX: <br>    case UM_GETNEXTCHILDY: <br>        /* <br>         * Calculate the next place to put the next transaction window. <br>         */ <br>        { <br>            pmci = (MYCONVINFO *)GetWindowLong(hwnd, 0); <br>            GetClientRect(hwnd, &amp;rc); <br>            if (msg == UM_GETNEXTCHILDX) { <br>                pmci-&gt;x += 14; <br>                if (pmci-&gt;x &gt; (rc.right - 200 - rc.left)) <br>                    pmci-&gt;x = 0; <br>                return(pmci-&gt;x); <br>            } else { <br>                pmci-&gt;y += 12; <br>                if (pmci-&gt;y &gt; (rc.bottom - 100 - rc.top)) <br>                    pmci-&gt;y = 0; <br>                return(pmci-&gt;y); <br>            } <br>        } <br>        break; <br> <br>    case UM_DISCONNECTED: <br>        /* <br>         * Disconnected conversations can't have any transactions so we <br>         * remove all the transaction windows here to show whats up. <br>         */ <br>        { <br>            HWND hwndT; <br>            while (hwndT = GetWindow(hwnd, GW_CHILD)) <br>                DestroyWindow(hwndT); <br>            InvalidateRect(hwnd, NULL, TRUE); <br>        } <br>        break; <br> <br>    case WM_DESTROY: <br>        /* <br>         * Cleanup our conversation info structure, and disconnect all <br>         * conversations associated with this window. <br>         */ <br>        pmci = (MYCONVINFO *)GetWindowLong(hwnd, 0); <br>        pmci-&gt;hwndXaction = 0;      /* clear this to avoid focus problems */ <br>        if (pmci-&gt;hConv) { <br>            if (pmci-&gt;fList) { <br>                DdeDisconnectList((HCONVLIST)pmci-&gt;hConv); <br>            } else { <br>                MyDisconnect(pmci-&gt;hConv); <br>            } <br>        } <br>        DdeFreeStringHandle(idInst, pmci-&gt;hszTopic); <br>        DdeFreeStringHandle(idInst, pmci-&gt;hszApp); <br>        MyFree(pmci); <br>        goto CallDCP; <br>        break; <br> <br>    case WM_SETFOCUS: <br>        /* <br>         * This catches focus changes caused by dialogs. <br>         */ <br>        lParam = (LPARAM)hwnd; <br>        // fall through <br> <br>    case WM_MDIACTIVATE: <br>        hwndActive = (HWND)(lParam); <br>        pmci = (MYCONVINFO *)GetWindowLong(hwnd, 0); <br>        /* <br>         * pass the focus onto the current transaction window. <br>         */ <br>        if ((lParam == (LONG)hwnd) &amp;&amp; <br>                IsWindow(pmci-&gt;hwndXaction)) <br>            SetFocus(pmci-&gt;hwndXaction); <br>        break; <br> <br>    case ICN_HASFOCUS: <br>        /* <br>         * update which transaction window is the main one. <br>         */ <br>        pmci = (MYCONVINFO *)GetWindowLong(hwnd, 0); <br>        pmci-&gt;hwndXaction = wParam ? (HWND)lParam : NULL; <br>        break; <br> <br>    case ICN_BYEBYE: <br>        /* <br>         * Transaction window is closing... <br>         * <br>         * wParam = hwndXact <br>         * lParam = lpxact <br>         */ <br>        pmci = (MYCONVINFO *)GetWindowLong(hwnd, 0); <br>        if (pmci != NULL) { <br>            XACT *pxact; <br> <br>            pxact = (XACT *)lParam; <br>            if (pxact != NULL) { <br>                /* <br>                 * If this transaction is active, abandon it first. <br>                 */ <br>                if (pxact-&gt;fsOptions &amp; XOPT_ASYNC &amp;&amp; <br>                        !(pxact-&gt;fsOptions &amp; XOPT_COMPLETED)) { <br>                    DdeAbandonTransaction(idInst, pmci-&gt;hConv, pxact-&gt;Result); <br>                } <br>                /* <br>                 * release resources associated with transaction. <br>                 */ <br>                DdeFreeStringHandle(idInst, pxact-&gt;hszItem); <br>                MyFree((PTSTR)pxact); <br>                /* <br>                 * Locate next apropriate transaction window to get focus. <br>                 */ <br>                if (!pmci-&gt;hwndXaction || pmci-&gt;hwndXaction == (HWND)wParam) <br>                    pmci-&gt;hwndXaction = GetWindow(hwnd, GW_CHILD); <br>                if (pmci-&gt;hwndXaction == (HWND)wParam) <br>                    pmci-&gt;hwndXaction = GetWindow((HWND)wParam, GW_HWNDNEXT); <br>                if (pmci-&gt;hwndXaction == (HWND)wParam || <br>                        !IsWindow(pmci-&gt;hwndXaction) || <br>                        !IsChild(hwnd, pmci-&gt;hwndXaction)) <br>                    pmci-&gt;hwndXaction = NULL; <br>                else <br>                    SetFocus(pmci-&gt;hwndXaction); <br>            } <br>        } <br>        break; <br> <br>    case WM_PAINT: <br>        /* <br>         * Paint this conversation's related information. <br>         */ <br>        pmci = (MYCONVINFO *)GetWindowLong(hwnd, 0); <br>        { <br>            PAINTSTRUCT ps; <br>            PTSTR psz; <br> <br>            BeginPaint(hwnd, &amp;ps); <br>            SetBkMode(ps.hdc, TRANSPARENT); <br>            psz = pmci-&gt;fList ? GetConvListText((HCONVLIST)pmci-&gt;hConv) : <br>                    GetConvInfoText(pmci-&gt;hConv, &amp;pmci-&gt;ci); <br>            if (psz) { <br>                GetClientRect(hwnd, &amp;rc); <br>                DrawText(ps.hdc, psz, -1, &amp;rc, <br>                        DT_WORDBREAK | DT_LEFT | DT_NOPREFIX | DT_TABSTOP); <br>                MyFree(psz); <br>            } <br>            EndPaint(hwnd, &amp;ps); <br>        } <br>        break; <br> <br>    case WM_QUERYENDSESSION: <br>        return TRUE; <br> <br>    default: <br>CallDCP: <br>        /* Again, since the MDI default behaviour is a little different, <br>         * call DefMDIChildProc instead of DefWindowProc() <br>         */ <br>        return DefMDIChildProc (hwnd, msg, wParam, lParam); <br>    } <br>    return FALSE; <br>} <br> <br> <br>/**************************************************************************** <br> *                                                                          * <br> *  FUNCTION   : Initializemenu ( hMenu )                                   * <br> *                                                                          * <br> *  PURPOSE    : Sets up greying, enabling and checking of main menu items  * <br> *               based on the app's state.                                  * <br> *                                                                          * <br> ****************************************************************************/ <br>VOID NEAR PASCAL InitializeMenu ( hmenu ) <br>HANDLE hmenu; <br>{ <br>    BOOL fLink      = FALSE; // set if Link format is on the clipboard; <br>    BOOL fAny       = FALSE; // set if hwndActive exists <br>    BOOL fList      = FALSE; // set if hwndActive is a list window <br>    BOOL fConnected = FALSE; // set if hwndActive is a connection conversation. <br>    BOOL fXaction   = FALSE; // set if hwndActive has a selected transaction window <br>    BOOL fXactions  = FALSE; // set if hwndActive contains transaction windows <br>    BOOL fBlocked   = FALSE; // set if hwndActive conversation is blocked. <br>    BOOL fBlockNext = FALSE; // set if handActive conversation is blockNext. <br>    MYCONVINFO *pmci = NULL; <br> <br>    if (OpenClipboard(hwndFrame)) { <br>        fLink = (IsClipboardFormatAvailable(fmtLink)); <br>        CloseClipboard(); <br>    } <br> <br>    if (fAny = (IsWindow(hwndActive) &amp;&amp; <br>            (pmci = (MYCONVINFO *)GetWindowLong(hwndActive, 0)))) { <br>        fXactions = (BOOL)GetWindow(hwndActive, GW_CHILD); <br>        if (!(fList = pmci-&gt;fList)) { <br>            CONVINFO ci; <br> <br>            ci.cb = sizeof(CONVINFO); <br>            DdeQueryConvInfo(pmci-&gt;hConv, QID_SYNC, &amp;ci); <br>            fConnected = ci.wStatus &amp; ST_CONNECTED; <br>            fXaction = IsWindow(pmci-&gt;hwndXaction); <br>            fBlocked = ci.wStatus &amp; ST_BLOCKED; <br>            fBlockNext = ci.wStatus &amp; ST_BLOCKNEXT; <br>        } <br>    } <br> <br>    EnableMenuItem(hmenu,   IDM_EDITPASTE, <br>            fLink           ? MF_ENABLED    : MF_GRAYED); <br> <br>    // IDM_CONNECTED - always enabled. <br> <br>    EnableMenuItem(hmenu,   IDM_RECONNECT, <br>            fList           ? MF_ENABLED    : MF_GRAYED); <br> <br>    EnableMenuItem (hmenu,  IDM_DISCONNECT, <br>            fConnected &amp;&amp; !(fXaction || fXactions) ? MF_ENABLED : MF_GRAYED); <br> <br>    EnableMenuItem (hmenu,  IDM_TRANSACT, <br>            fConnected      ? MF_ENABLED    : MF_GRAYED); <br> <br>    EnableMenuItem(hmenu,   IDM_ABANDON, <br>            fXaction        ? MF_ENABLED    : MF_GRAYED); <br> <br>    EnableMenuItem(hmenu,   IDM_ABANDONALL, <br>            fXactions ? MF_ENABLED : MF_GRAYED); <br> <br> <br>    EnableMenuItem (hmenu,  IDM_BLOCKCURRENT, <br>            fConnected &amp;&amp; !fBlocked ? MF_ENABLED    : MF_GRAYED); <br>    CheckMenuItem(hmenu, IDM_BLOCKCURRENT, <br>            fBlocked        ? MF_CHECKED    : MF_UNCHECKED); <br> <br>    EnableMenuItem (hmenu,  IDM_ENABLECURRENT, <br>            fConnected &amp;&amp; (fBlocked || fBlockNext) ? MF_ENABLED : MF_GRAYED); <br>    CheckMenuItem(hmenu,    IDM_ENABLECURRENT, <br>            !fBlocked       ? MF_CHECKED    : MF_UNCHECKED); <br> <br>    EnableMenuItem (hmenu,  IDM_ENABLEONECURRENT, <br>            fConnected &amp;&amp; (fBlocked) ? MF_ENABLED : MF_GRAYED); <br>    CheckMenuItem(hmenu,    IDM_ENABLEONECURRENT, <br>            fBlockNext      ? MF_CHECKED    : MF_UNCHECKED); <br> <br>    EnableMenuItem (hmenu,  IDM_BLOCKALLCBS, <br>            fAny            ? MF_ENABLED    : MF_GRAYED); <br> <br>    EnableMenuItem (hmenu,  IDM_ENABLEALLCBS, <br>            fAny            ? MF_ENABLED    : MF_GRAYED); <br> <br>    EnableMenuItem (hmenu,  IDM_ENABLEONECB, <br>            fAny            ? MF_ENABLED    : MF_GRAYED); <br> <br>    EnableMenuItem(hmenu,   IDM_BLOCKNEXTCB, <br>            fAny || fBlockNextCB ? MF_ENABLED    : MF_GRAYED); <br>    CheckMenuItem(hmenu,    IDM_BLOCKNEXTCB, <br>            fBlockNextCB    ? MF_CHECKED    : MF_UNCHECKED); <br> <br>    EnableMenuItem(hmenu,   IDM_TERMNEXTCB, <br>            fAny || fTermNextCB ? MF_ENABLED    : MF_GRAYED); <br>    CheckMenuItem(hmenu,    IDM_TERMNEXTCB, <br>            fTermNextCB     ? MF_CHECKED    : MF_UNCHECKED); <br> <br>    // IDM_DELAY - always enabled. <br> <br>    // IDM_TIMEOUT - alwasy enabled. <br> <br>    EnableMenuItem (hmenu,  IDM_WINDOWTILE, <br>            fAny            ? MF_ENABLED    : MF_GRAYED); <br> <br>    EnableMenuItem (hmenu,  IDM_WINDOWCASCADE, <br>            fAny            ? MF_ENABLED    : MF_GRAYED); <br> <br>    EnableMenuItem (hmenu,  IDM_WINDOWICONS, <br>            fAny            ? MF_ENABLED    : MF_GRAYED); <br> <br>    EnableMenuItem (hmenu,  IDM_WINDOWCLOSEALL, <br>            fAny            ? MF_ENABLED    : MF_GRAYED); <br> <br>    EnableMenuItem (hmenu,  IDM_XACTTILE, <br>            fXactions       ? MF_ENABLED    : MF_GRAYED); <br> <br>    EnableMenuItem (hmenu,  IDM_XACTCASCADE, <br>            fXactions       ? MF_ENABLED    : MF_GRAYED); <br> <br>    CheckMenuItem(hmenu,   IDM_AUTORECONNECT, <br>            fAutoReconnect  ? MF_CHECKED    : MF_UNCHECKED); <br> <br>    // IDM_HELPABOUT - always enabled. <br>} <br> <br> <br> <br>/**************************************************************************** <br> *                                                                          * <br> *  FUNCTION   : CloseAllChildren ()                                        * <br> *                                                                          * <br> *  PURPOSE    : Destroys all MDI child windows.                            * <br> *                                                                          * <br> ****************************************************************************/ <br>VOID NEAR PASCAL CloseAllChildren () <br>{ <br>    HWND hwndT; <br> <br>    /* hide the MDI client window to avoid multiple repaints */ <br>    ShowWindow(hwndMDIClient,SW_HIDE); <br> <br>    /* As long as the MDI client has a child, destroy it */ <br>    while ( hwndT = GetWindow (hwndMDIClient, GW_CHILD)){ <br> <br>        /* Skip the icon title windows */ <br>        while (hwndT &amp;&amp; GetWindow (hwndT, GW_OWNER)) <br>            hwndT = GetWindow (hwndT, GW_HWNDNEXT); <br> <br>        if (!hwndT) <br>            break; <br> <br>        SendMessage(hwndMDIClient, WM_MDIDESTROY, (DWORD)hwndT, 0L); <br>    } <br> <br>    ShowWindow( hwndMDIClient, SW_SHOW); <br>} <br> <br>/**************************************************************************** <br> *                                                                          * <br> *  FUNCTION   : CommandHandler ()                                          * <br> *                                                                          * <br> *  PURPOSE    : Processes all "frame" WM_COMMAND messages.                 * <br> *                                                                          * <br> ****************************************************************************/ <br>VOID NEAR PASCAL CommandHandler ( <br>HWND hwnd, <br>DWORD id) <br> <br>{ <br>    MYCONVINFO *pmci = NULL; <br> <br>    if (hwndActive) <br>        pmci = (MYCONVINFO *)GetWindowLong(hwndActive, 0); <br> <br>    switch (id){ <br>        case IDM_EDITPASTE: <br>            { <br>                HANDLE hClipData; <br>                LPTSTR psz; <br>                XACT xact; <br> <br>                if (OpenClipboard(hwnd)) { <br>                    if (hClipData = GetClipboardData(fmtLink)) { <br>                        if (psz = GlobalLock(hClipData)) { <br>                            /* <br>                             * Create a conversation with the link app and <br>                             * begin a request and advise start transaction. <br>                             */ <br>                            xact.hConv = CreateConv(DdeCreateStringHandle(idInst, psz, 0), <br>                                    DdeCreateStringHandle(idInst, &amp;psz[_tcslen(psz) + 1], 0), <br>                                    FALSE); <br>                            if (xact.hConv) { <br>                                psz += _tcslen(psz) + 1; <br>                                psz += _tcslen(psz) + 1; <br>                                xact.ulTimeout = DefTimeout; <br>                                xact.wType = XTYP_ADVSTART; <br>                                xact.hDdeData = 0; <br>#ifdef UNICODE <br>                                xact.wFmt = CF_UNICODETEXT; <br>#else <br>                                xact.wFmt = CF_TEXT; <br>#endif <br>                                xact.hszItem = DdeCreateStringHandle(idInst, psz, 0); <br>                                xact.fsOptions = 0; <br>                                ProcessTransaction(&amp;xact); <br>                                xact.wType = XTYP_REQUEST; <br>                                ProcessTransaction(&amp;xact); <br>                            } <br>                            GlobalUnlock(hClipData); <br>                        } <br>                    } <br>                    CloseClipboard(); <br>                } <br>            } <br>            break; <br> <br>        case IDM_CONNECT: <br>        case IDM_RECONNECT: <br>            DoDialog(MAKEINTRESOURCE(IDD_CONNECT), (DLGPROC)ConnectDlgProc, <br>                    id == IDM_RECONNECT, FALSE); <br>            break; <br> <br>        case IDM_DISCONNECT: <br>            if (hwndActive) { <br>                SendMessage(hwndMDIClient, WM_MDIDESTROY, (DWORD)hwndActive, 0L); <br>            } <br>            break; <br> <br>        case IDM_TRANSACT: <br>            if (DoDialog(MAKEINTRESOURCE(IDD_TRANSACT), (DLGPROC)TransactDlgProc, <br>                    (DWORD)(LPTSTR)pmci-&gt;hConv, FALSE)) <br>                SetFocus(GetWindow(hwndActive, GW_CHILD)); <br>            break; <br> <br>        case IDM_ABANDON: <br>            if (pmci != NULL &amp;&amp; IsWindow(pmci-&gt;hwndXaction)) { <br>                DestroyWindow(pmci-&gt;hwndXaction); <br>            } <br>            break; <br> <br>        case IDM_ABANDONALL: <br>            DdeAbandonTransaction(idInst, pmci-&gt;hConv, 0L); <br>            { <br>                HWND hwndXaction; <br> <br>                hwndXaction = GetWindow(hwndActive, GW_CHILD); <br>                while (hwndXaction) { <br>                    DestroyWindow(hwndXaction); <br>                    hwndXaction = GetWindow(hwndActive, GW_CHILD); <br>                } <br>            } <br>            break; <br> <br>        case IDM_BLOCKCURRENT: <br>            DdeEnableCallback(idInst, pmci-&gt;hConv, EC_DISABLE); <br>            InvalidateRect(hwndActive, NULL, TRUE); <br>            break; <br> <br>        case IDM_ENABLECURRENT: <br>            DdeEnableCallback(idInst, pmci-&gt;hConv, EC_ENABLEALL); <br>            InvalidateRect(hwndActive, NULL, TRUE); <br>            break; <br> <br>        case IDM_ENABLEONECURRENT: <br>            DdeEnableCallback(idInst, pmci-&gt;hConv, EC_ENABLEONE); <br>            InvalidateRect(hwndActive, NULL, TRUE); <br>            break; <br> <br>        case IDM_BLOCKALLCBS: <br>            DdeEnableCallback(idInst, 0, EC_DISABLE); <br>            InvalidateRect(hwndMDIClient, NULL, TRUE); <br>            break; <br> <br>        case IDM_ENABLEALLCBS: <br>            DdeEnableCallback(idInst, 0, EC_ENABLEALL); <br>            InvalidateRect(hwndMDIClient, NULL, TRUE); <br>            break; <br> <br>        case IDM_ENABLEONECB: <br>            DdeEnableCallback(idInst, 0, EC_ENABLEONE); <br>            InvalidateRect(hwndMDIClient, NULL, TRUE); <br>            break; <br> <br>        case IDM_BLOCKNEXTCB: <br>            fBlockNextCB = !fBlockNextCB; <br>            break; <br> <br>        case IDM_TERMNEXTCB: <br>            fTermNextCB = !fTermNextCB; <br>            break; <br> <br>        case IDM_DELAY: <br>            DoDialog(MAKEINTRESOURCE(IDD_VALUEENTRY), (DLGPROC)DelayDlgProc, 0, <br>                    TRUE); <br>            break; <br> <br>        case IDM_TIMEOUT: <br>            DoDialog(MAKEINTRESOURCE(IDD_VALUEENTRY), (DLGPROC)TimeoutDlgProc, 0, <br>                    TRUE); <br>            break; <br> <br>        case IDM_CONTEXT: <br>            DoDialog(MAKEINTRESOURCE(IDD_CONTEXT), (DLGPROC)ContextDlgProc, 0, TRUE); <br>            break; <br> <br>        case IDM_AUTORECONNECT: <br>            fAutoReconnect = !fAutoReconnect; <br>            break; <br> <br>        /* The following are window commands - these are handled by the <br>         * MDI Client. <br>         */ <br>        case IDM_WINDOWTILE: <br>            /* Tile MDI windows */ <br>            SendMessage (hwndMDIClient, WM_MDITILE, 0, 0L); <br>            break; <br> <br>        case IDM_WINDOWCASCADE: <br>            /* Cascade MDI windows */ <br>            SendMessage (hwndMDIClient, WM_MDICASCADE, 0, 0L); <br>            break; <br> <br>        case IDM_WINDOWICONS: <br>            /* Auto - arrange MDI icons */ <br>            SendMessage (hwndMDIClient, WM_MDIICONARRANGE, 0, 0L); <br>            break; <br> <br>        case IDM_WINDOWCLOSEALL: <br>            CloseAllChildren(); <br>            break; <br> <br>        case IDM_XACTTILE: <br>            TileChildWindows(hwndActive); <br>            break; <br> <br>        case IDM_XACTCASCADE: <br>            MyCascadeChildWindows(hwndActive); <br>            break; <br> <br>        case IDM_HELPABOUT:{ <br>            DoDialog(MAKEINTRESOURCE(IDD_ABOUT), (DLGPROC)AboutDlgProc, 0, TRUE); <br>            break; <br>        } <br> <br>        default: <br>           /* <br>            * This is essential, since there are frame WM_COMMANDS generated <br>            * by the MDI system for activating child windows via the <br>            * window menu. <br>            */ <br>            DefFrameProc(hwnd, hwndMDIClient, WM_COMMAND, <br>                    (WPARAM)MAKELONG(id, 0), (LONG)(0)); <br>    } <br>} <br> <br> <br>/**************************************************************************** <br> *                                                                          * <br> *  FUNCTION   : MPError (flags, id, ...)                            * <br> *                                                                          * <br> *  PURPOSE    : Flashes a Message Box to the user. The format string is    * <br> *               taken from the STRINGTABLE.                                * <br> *                                                                          * <br> *  RETURNS    : Returns value returned by MessageBox() to the caller.      * <br> *                                                                          * <br> ****************************************************************************/ <br>INT FAR cdecl MPError( <br>DWORD bFlags, <br>DWORD id, <br>...) <br>{ <br>    TCHAR sz[160]; <br>    TCHAR szFmt[128]; <br>    va_list args; <br>    va_start(args, id); <br> <br>    LoadString (hInst, id, szFmt, sizeof(szFmt)); <br>    wvsprintf (sz, szFmt, args); <br>    LoadString (hInst, IDS_APPNAME, szFmt, sizeof(szFmt)); <br>    return MessageBox (hwndFrame, sz, szFmt, bFlags); <br>} <br> <br> <br> <br>/**************************************************************************** <br> *                                                                          * <br> *  FUNCTION   : CreateConv()                                               * <br> *                                                                          * </code></pre>
<p>
</p>
<pre><code>*  PURPOSE    :                                                            * <br> *                                                                          * <br> *  RETURNS    :                                                            * <br> *                                                                          * <br> ****************************************************************************/ <br>HCONV CreateConv( <br>HSZ hszApp, <br>HSZ hszTopic, <br>BOOL fList) <br>{ <br>    HCONV hConv; <br>    HWND hwndConv = 0; <br>    CONVINFO ci; <br> <br>    if (fList) { <br>        hConv = (HCONV)DdeConnectList(idInst, hszApp, hszTopic, 0, &amp;CCFilter); <br>    } else { <br>        hConv = DdeConnect(idInst, hszApp, hszTopic, &amp;CCFilter); <br>    } <br>    if (hConv) { <br>        if (fList) { <br>            ci.hszSvcPartner = hszApp; <br>            ci.hszTopic = hszTopic; <br>        } else { <br>            ci.cb = sizeof(CONVINFO); <br>            DdeQueryConvInfo(hConv, QID_SYNC, &amp;ci); <br>        } <br>        hwndConv = AddConv(ci.hszSvcPartner, ci.hszTopic, hConv, fList); <br>        // HSZs get freed when window dies. <br>    } <br>    if (!hwndConv) { <br>        DdeFreeStringHandle(idInst, hszApp); <br>        DdeFreeStringHandle(idInst, hszTopic); <br>    } <br>    return(hConv); <br>} <br> <br> <br> <br> <br> <br> <br>/**************************************************************************** <br> *                                                                          * <br> *  FUNCTION   : AddConv()                                                  * <br> *                                                                          * <br> *  PURPOSE    : Creates an MDI window representing a conversation          * <br> *               (fList = FALSE) or a set of MID windows for the list of    * <br> *               conversations (fList = TRUE).                              * <br> *                                                                          * <br> *  EFFECTS    : Sets the hUser for the conversation to the created MDI     * <br> *               child hwnd.  Keeps the hszs if successful.                 * <br> *                                                                          * <br> *  RETURNS    : created MDI window handle.                                 * <br> *                                                                          * <br> ****************************************************************************/ <br>HWND  APIENTRY AddConv( <br>HSZ hszApp, <br>HSZ hszTopic, <br>HCONV hConv, <br>BOOL fList) <br>{ <br>    HWND hwnd; <br>    MDICREATESTRUCT mcs; <br>    MYCONVINFO mci; <br> <br>    if (fList) { <br>        /* <br>         * Create all child windows FIRST so we have info for list window. <br>         */ <br>        CONVINFO ci; <br>        HCONV hConvChild = 0; <br> <br>        ci.cb = sizeof(CONVINFO); <br>        while (hConvChild = DdeQueryNextServer((HCONVLIST)hConv, hConvChild)) { <br>            if (DdeQueryConvInfo(hConvChild, QID_SYNC, &amp;ci)) { <br>                AddConv(ci.hszSvcPartner, ci.hszTopic, hConvChild, FALSE); <br>            } <br>        } <br>    } <br> <br>    mcs.szTitle = GetConvTitleText(hConv, hszApp, hszTopic, fList); <br> <br>    mcs.szClass = fList ? szList : szChild; <br>    mcs.hOwner  = hInst; <br>    mcs.x = mcs.cx = CW_USEDEFAULT; <br>    mcs.y = mcs.cy = CW_USEDEFAULT; <br>    mcs.style = GetWindow(hwndMDIClient, GW_CHILD) ? <br>            WS_CLIPCHILDREN : (WS_MAXIMIZE | WS_CLIPCHILDREN); <br> <br>    // mci.hwndXaction = <br>    mci.fList = fList; <br>    mci.hConv = hConv; <br>    mci.hszTopic = hszTopic; <br>    mci.hszApp = hszApp; <br>    // mci.x = <br>    // mci.y = <br>    // mci.ci = <br>    mcs.lParam = (DWORD)(LPTSTR)&amp;mci; <br> <br>    hwnd = (HWND)SendMessage (hwndMDIClient, WM_MDICREATE, 0, <br>             (LONG)(LPMDICREATESTRUCT)&amp;mcs); <br> <br>    MyFree((PTSTR)(DWORD)mcs.szTitle); <br> <br>    return hwnd; <br>} <br> <br> <br> <br> <br> <br>/**************************************************************************** <br> *                                                                          * <br> *  FUNCTION   : GetConvListText()                                          * <br> *                                                                          * <br> *  RETURN     : Returns a ponter to a string containing a list of          * <br> *               conversations contained in the given hConvList freeable    * <br> *               by MyFree();                                               * <br> *                                                                          * <br> ****************************************************************************/ <br>PTSTR GetConvListText( <br>HCONVLIST hConvList) <br>{ <br>    HCONV hConv = 0; <br>    DWORD cConv = 0; <br>    CONVINFO ci; <br>    DWORD cb = 0; <br>    DWORD d; <br>    TCHAR *psz, *pszStart; <br> <br>    ci.cb = sizeof(CONVINFO); <br> <br>    // find out size needed. <br> <br>    while (hConv = DdeQueryNextServer(hConvList, hConv)) { <br>        if (DdeQueryConvInfo(hConv, QID_SYNC, &amp;ci)) { <br>            if (!IsWindow((HWND)ci.hUser)) { <br>                if (ci.wStatus &amp; ST_CONNECTED) { <br>                    /* <br>                     * This conversation doesn't have a corresponding <br>                     * MDI window.  This is probably due to a reconnection. <br>                     */ <br>                    ci.hUser = (DWORD)AddConv(ci.hszSvcPartner, ci.hszTopic, hConv, FALSE); <br>                } else { <br>                    continue;   // skip this guy - he was closed locally. <br>                } <br>            } <br>            cb += GetWindowTextLength((HWND)ci.hUser); <br>            if (cConv++) <br>                cb += 2;        // room for CRLF <br>        } <br>    } <br>    cb++;                       // for terminator. <br> <br>    // allocate and fill <br> <br>    if (pszStart = psz = MyAlloc(cb * sizeof(TCHAR))) { <br>        *psz = TEXT('\0'); <br>        while (hConv = DdeQueryNextServer(hConvList, hConv)) { <br>            if (DdeQueryConvInfo(hConv, QID_SYNC, &amp;ci) &amp;&amp; <br>                    IsWindow((HWND)ci.hUser)) { <br>                d = GetWindowText((HWND)ci.hUser, psz, cb); <br>                psz += d; <br>                cb -= d; <br>                if (--cConv) { <br>                    *psz++ = TEXT('\r'); <br>                    *psz++ = TEXT('\n'); <br>                    cb -= 2; <br>                } <br>            } <br>        } <br>    } <br>    return(pszStart); <br>} <br> <br> <br>/**************************************************************************** <br> *                                                                          * <br> *  FUNCTION   : GetConvInfoText()                                          * <br> *                                                                          * <br> *  PURPOSE    : Returns a pointer to a string that reflects a              * <br> *               conversation's information.  Freeable by MyFree();         * <br> *                                                                          * <br> ****************************************************************************/ <br>PTSTR GetConvInfoText( <br>HCONV hConv, <br>CONVINFO *pci) <br>{ <br>    PTSTR psz; <br>    PTSTR szApp; <br> <br>    psz = MyAlloc(300 * sizeof(TCHAR)); <br>    pci-&gt;cb = sizeof(CONVINFO); <br>    if (hConv) { <br>        if (!DdeQueryConvInfo(hConv, QID_SYNC, (PCONVINFO)pci)) { <br>            _tcscpy(psz, TEXT("State=Disconnected")); <br>            return(psz); <br>        } <br>        szApp = GetHSZName(pci-&gt;hszServiceReq); <br>        wsprintf(psz, <br>                TEXT("hUser=0x%lx\r\nhConvPartner=0x%lx\r\nhszServiceReq=%s\r\nStatus=%s\r\nState=%s\r\nLastError=%s"), <br>                pci-&gt;hUser, pci-&gt;hConvPartner, (LPTSTR)szApp, <br>                (LPTSTR)Status2String(pci-&gt;wStatus), <br>                (LPTSTR)State2String(pci-&gt;wConvst), <br>                (LPTSTR)Error2String(pci-&gt;wLastError)); <br>        MyFree(szApp); <br>    } else { <br>        _tcscpy(psz, Error2String(DdeGetLastError(idInst))); <br>    } <br>    return(psz); <br>} <br> <br> <br> <br>/**************************************************************************** <br> *                                                                          * <br> *  FUNCTION   : GetConvTitleText()                                         * <br> *                                                                          * <br> *  PURPOSE    : Creates standard window title text based on parameters.    * <br> *                                                                          * <br> *  RETURNS    : psz freeable by MyFree()                                   * <br> *                                                                          * <br> ****************************************************************************/ <br>PTSTR GetConvTitleText( <br>HCONV hConv, <br>HSZ hszApp, <br>HSZ hszTopic, <br>BOOL fList) <br>{ <br>    DWORD cb; <br>    PTSTR psz; <br> <br>    cb = (DWORD)DdeQueryString(idInst, hszApp, NULL, 0, 0) + <br>            (DWORD)DdeQueryString(idInst, hszTopic, (LPTSTR)NULL, 0, 0) + <br>            (fList ? 30 : 20); <br> <br>    if (psz = MyAlloc(cb * sizeof(TCHAR))) { <br>        DdeQueryString(idInst, hszApp, psz, cb, 0); <br>        _tcscat(psz, TEXT("|")); <br>        DdeQueryString(idInst, hszTopic, &amp;psz[_tcslen(psz)], cb, 0); <br>        if (fList) <br>            _tcscat(psz, TEXT(" - LIST")); <br>        wsprintf(&amp;psz[_tcslen(psz)], TEXT(" - (%lx)"), hConv); <br>    } <br>    return(psz); <br>} <br> <br> <br> <br>/**************************************************************************** <br> *                                                                          * <br> *  FUNCTION   : Status2String()                                            * <br> *                                                                          * <br> *  PURPOSE    : Converts a conversation status word to a string and        * <br> *               returns a pointer to that string.  The string is valid     * <br> *               till the next call to this function.                       * <br> *                                                                          * <br> ****************************************************************************/ <br>PTSTR Status2String( <br>DWORD status) <br>{ <br>    DWORD c, i; <br>    static TCHAR szStatus[6 * 18]; <br>    static struct { <br>        TCHAR *szStatus; <br>        DWORD status; <br>    } s2s[] = { <br>        { TEXT("Connected")    ,   ST_CONNECTED }, <br>        { TEXT("Advise")       ,   ST_ADVISE }, <br>        { TEXT("IsLocal")      ,   ST_ISLOCAL }, <br>        { TEXT("Blocked")      ,   ST_BLOCKED }, <br>        { TEXT("Client")       ,   ST_CLIENT }, <br>        { TEXT("Disconnected") ,   ST_TERMINATED }, <br>        { TEXT("BlockNext")    ,   ST_BLOCKNEXT }, <br>    }; <br>#define CFLAGS 7 <br>    szStatus[0] = TEXT('\0'); <br>    c = 0; <br>    for (i = 0; i &lt; CFLAGS; i++) { <br>        if (status &amp; s2s[i].status) { <br>            if (c++) <br>                _tcscat(szStatus, TEXT(" | ")); <br>            _tcscat(szStatus, s2s[i].szStatus); <br>        } <br>    } <br>    return szStatus; <br>#undef CFLAGS <br>} <br> <br> <br> <br> <br>/**************************************************************************** <br> *                                                                          * <br> *  FUNCTION   : State2String()                                             * <br> *                                                                          * <br> *  PURPOSE    : converts a conversation state word to a string and         * <br> *               returns a pointer to that string.  The string is valid     * <br> *               till the next call to this routine.                        * <br> *                                                                          * <br> ****************************************************************************/ <br>PTSTR State2String( <br>DWORD state) <br>{ <br>    static TCHAR *s2s[] = { <br>        TEXT("NULL")             , <br>        TEXT("Incomplete")       , <br>        TEXT("Standby")          , <br>        TEXT("Initiating")       , <br>        TEXT("ReqSent")          , <br>        TEXT("DataRcvd")         , <br>        TEXT("PokeSent")         , <br>        TEXT("PokeAckRcvd")      , <br>        TEXT("ExecSent")         , <br>        TEXT("ExecAckRcvd")      , <br>        TEXT("AdvSent")          , <br>        TEXT("UnadvSent")        , <br>        TEXT("AdvAckRcvd")       , <br>        TEXT("UnadvAckRcvd")     , <br>        TEXT("AdvDataSent")      , <br>        TEXT("AdvDataAckRcvd")   , <br>        TEXT("?")                ,    // 16 <br>    }; <br> <br>    if (state &gt;= 17) <br>        return s2s[17]; <br>    else <br>        return s2s[state]; <br>} <br> <br>/**************************************************************************** <br> *                                                                          * <br> *  FUNCTION   : Error2String()                                             * <br> *                                                                          * <br> *  PURPOSE    : Converts an error code to a string and returns a pointer   * <br> *               to that string.  The string is valid until the next call   * <br> *               to this function.                                          * <br> *                                                                          * <br> ****************************************************************************/ <br>PTSTR Error2String( <br>DWORD error) <br>{ <br>    static TCHAR szErr[23]; <br>    static TCHAR *e2s[] = { <br>        TEXT("Advacktimeout")              , <br>        TEXT("Busy")                       , <br>        TEXT("Dataacktimeout")             , <br>        TEXT("Dll_not_initialized")        , <br>        TEXT("Dll_usage")                  , <br>        TEXT("Execacktimeout")             , <br>        TEXT("Invalidparameter")           , <br>        TEXT("Low Memory warning")         , <br>        TEXT("Memory_error")               , <br>        TEXT("Notprocessed")               , <br>        TEXT("No_conv_established")        , <br>        TEXT("Pokeacktimeout")             , <br>        TEXT("Postmsg_failed")             , <br>        TEXT("Reentrancy")                 , <br>        TEXT("Server_died")                , <br>        TEXT("Sys_error")                  , <br>        TEXT("Unadvacktimeout")            , <br>        TEXT("Unfound_queue_id")           , <br>    }; <br>    if (!error) { <br>        _tcscpy(szErr, TEXT("0")); <br>    } else if (error &gt; DMLERR_LAST || error &lt; DMLERR_FIRST) { <br>        _tcscpy(szErr, TEXT("???")); <br>    } else { <br>        _tcscpy(szErr, e2s[error - DMLERR_FIRST]); <br>    } <br>    return(szErr); <br>} <br> <br> <br> <br> <br> <br>/**************************************************************************** <br> *                                                                          * <br> *  FUNCTION   : Type2String()                                              * <br> *                                                                          * <br> *  PURPOSE    : Converts a wType word and fsOption flags to a string and   * <br> *               returns a pointer to that string.  the string is valid     * <br> *               until the next call to this function.                      * <br> *                                                                          * <br> ****************************************************************************/ <br>PTSTR Type2String( <br>DWORD wType, <br>DWORD fsOptions) <br>{ <br>    static TCHAR sz[30]; <br>    static TCHAR o2s[] = TEXT("^!#$X*&lt;?"); <br>    static TCHAR *t2s[] = { <br>        TEXT("")                 , <br>        TEXT("AdvData")          , <br>        TEXT("AdvReq")           , <br>        TEXT("AdvStart")         , <br>        TEXT("AdvStop")          , <br>        TEXT("Execute")          , <br>        TEXT("Connect")          , <br>        TEXT("ConnectConfirm")   , <br>        TEXT("XactComplete")    , <br>        TEXT("Poke")             , <br>        TEXT("Register")         , <br>        TEXT("Request")          , <br>        TEXT("Term")             , <br>        TEXT("Unregister")       , <br>        TEXT("WildConnect")      , <br>        TEXT("")                 , <br>    }; <br>    DWORD bit, c, i; <br> <br>    _tcscpy(sz, t2s[((wType &amp; XTYP_MASK) &gt;&gt; XTYP_SHIFT)]); <br>    c = _tcslen(sz); <br>    sz[c++] = TEXT(' '); <br>    for (i = 0, bit = 1; i &lt; 7; bit = bit &lt;&lt; 1, i++) { <br>        if (fsOptions &amp; bit) <br>            sz[c++] = o2s[i]; <br>    } <br>    sz[c] = TEXT('\0'); <br>    return(sz); <br>} <br> <br> <br> <br> <br>/**************************************************************************** <br> *                                                                          * <br> *  FUNCTION   : GetHSZName()                                               * <br> *                                                                          * <br> *  PURPOSE    : Allocates local memory for and retrieves the string form   * <br> *               of an HSZ.  Returns a pointer to the local memory or NULL  * <br> *               if failure.  The string must be freed via MyFree().        * <br> *                                                                          * <br> ****************************************************************************/ <br>PTSTR GetHSZName( <br>HSZ hsz) <br>{ <br>    PTSTR psz; <br>    DWORD cb; <br> <br>    cb = (DWORD)DdeQueryString(idInst, hsz, NULL, 0, 0) + 1; <br>    psz = MyAlloc(cb * sizeof(TCHAR)); <br>    DdeQueryString(idInst, hsz, psz, cb, 0); <br>    return(psz); <br>} <br> <br> <br>/**************************************************************************** <br> * <br> *  FUNCTION   : MyMsgFilterProc <br> * <br> *  PURPOSE    : This filter proc gets called for each message we handle. <br> *               This allows our application to properly dispatch messages <br> *               that we might not otherwise see because of DDEMLs modal <br> *               loop that is used while processing synchronous transactions. <br> * <br> *               Generally, applications that only do synchronous transactions <br> *               in response to user input (as this app does) does not need <br> *               to install such a filter proc because it would be very rare <br> *               that a user could command the app fast enough to cause <br> *               problems.  However, this is included as an example. <br> * <br> ****************************************************************************/ <br>LRESULT CALLBACK MyMsgFilterProc( <br>int nCode, <br>WPARAM wParam, <br>LPARAM lParam) <br>{ <br>    UNREFERENCED_PARAMETER(wParam); <br> <br>#define lpmsg ((LPMSG)lParam) <br>    if (nCode == MSGF_DDEMGR) { <br> <br>        /* If a keyboard message is for the MDI , let the MDI client <br>         * take care of it.  Otherwise, check to see if it's a normal <br>         * accelerator key.  Otherwise, just handle the message as usual. <br>         */ <br> <br>        if ( !TranslateMDISysAccel (hwndMDIClient, lpmsg) &amp;&amp; <br>             !TranslateAccelerator (hwndFrame, hAccel, lpmsg)){ <br>            TranslateMessage (lpmsg); <br>            DispatchMessage (lpmsg); <br>        } <br>        return(1); <br>    } <br>    if (nCode &lt; 0) { <br>        CallNextHookEx(ghhk, nCode, wParam, lParam); <br>    } <br>    return(0); <br>#undef lpmsg <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
