<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DDE.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6018"></a>DDE.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples. <br>*       Copyright 1993 - 1998 Microsoft Corporation. <br>*       All rights reserved. <br>*       This source code is only intended as a supplement to <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>/*************************************************************************** <br> *                                                                         * <br> *  MODULE      : dde.c                                                    * <br> *                                                                         * <br> *  PURPOSE     : Contains routines for handling of DDE interaction with   * <br> *                DDEML.                                                   * <br> *                                                                         * <br> ***************************************************************************/ <br>#include "client.h" <br>#include &lt;string.h&gt; <br>#include &lt;memory.h&gt; <br>#include "infoctrl.h" <br>#include "huge.h" <br> <br>TCHAR szT[100]; <br> <br>/**************************************************************************** <br> *                                                                          * <br> *  FUNCTION   : CreateXactionWindow()                                      * <br> *                                                                          * <br> *  PURPOSE    : Creates a transaction window for the given transaction     * <br> *               under the given conversation window.                       * <br> *                                                                          * <br> *  RETURNS    : TRUE  - If successful.                                     * <br> *               FALSE - otherwise.                                         * <br> *                                                                          * <br> ****************************************************************************/ <br>HWND CreateXactionWindow( <br>HWND hwndMDI, <br>XACT *pxact) <br>{ <br>    PTSTR pszFmt, pszItem; <br>    PTSTR pData; <br>    HWND hwnd; <br> <br>    pszItem = GetHSZName(pxact-&gt;hszItem); <br>    pszFmt = GetFormatName(pxact-&gt;wFmt); <br>    pData = GetTextData(pxact-&gt;hDdeData); <br> <br>    /* <br>     *    type/opts        ITEM                ret      GWL_USER=pxact <br>     *                                               <br>     *                                               <br>     *                                               <br>     *                                               <br>     *                     DATA                      <br>     *                                               <br>     *                                               <br>     *                                               <br>     *                                               <br>     *    state/error      FORMAT           Result   <br>     */ <br>    hwnd = CreateInfoCtrl((LPTSTR)pData, <br>            (INT)SendMessage(hwndMDI, UM_GETNEXTCHILDX, 0, 0L), <br>            (INT)SendMessage(hwndMDI, UM_GETNEXTCHILDY, 0, 0L), <br>            200, 100, hwndMDI, hInst, <br>            Type2String(pxact-&gt;wType, pxact-&gt;fsOptions), pszItem, NULL, <br>            TEXT("Starting"), (LPTSTR)pszFmt, NULL, <br>            ICSTY_SHOWFOCUS, 0, (DWORD)(LPTSTR)pxact); <br>    MyFree(pszItem); <br>    MyFree(pszFmt); <br>    MyFree(pData); <br>    return(hwnd); <br>} <br> <br> <br> <br> <br>/**************************************************************************** <br> *                                                                          * <br> *  FUNCTION   : ProcessTransaction()                                       * <br> *                                                                          * <br> *  PURPOSE    : Processes synchronous transactions entirely and starts     * <br> *               async transactions.  Transaction attempts result in a      * <br> *               transaction window being created which displays the state  * <br> *               or results of the transaction.  (the callback function     * <br> *               updates these windows as it gets calls) Transaction        * <br> *               windows stay around until abandoned by the user or until   * <br> *               the conversation is disconnected.  Advise Data and Advise  * <br> *               Stop transactions are special.  We don't create a new      * <br> *               window if the associated advise start transaction window   * <br> *               can be found.                                              * <br> *                                                                          * <br> *  RETURNS    : TRUE  - If successful.                                     * <br> *               FALSE - otherwise.                                         * <br> *                                                                          * <br> ****************************************************************************/ <br>BOOL ProcessTransaction( <br>XACT *pxact) <br>{ <br>    CONVINFO ci; <br>    HWND hwndInfoCtrl = 0; <br> <br>    /* create transaction window to show we tried (except in ADVSTOP case) */ <br> <br>    pxact = (XACT *)memcpy(MyAlloc(sizeof(XACT)), (PTSTR)pxact, sizeof(XACT)); <br>    ci.cb = sizeof(CONVINFO); <br>    DdeQueryConvInfo(pxact-&gt;hConv, QID_SYNC, &amp;ci); // ci.hUser==hConv <br>    if (pxact-&gt;wType == XTYP_ADVSTOP) { <br>        hwndInfoCtrl = FindAdviseChild((HWND)ci.hUser, pxact-&gt;hszItem, <br>                pxact-&gt;wFmt); <br>        if (hwndInfoCtrl) { <br>            SendMessage(hwndInfoCtrl, ICM_SETSTRING, ICSID_UL, <br>                    (DWORD)(LPTSTR)Type2String(pxact-&gt;wType, pxact-&gt;fsOptions)); <br>            DdeFreeStringHandle(idInst, pxact-&gt;hszItem); <br>        } <br>    } <br>    /* <br>     * If we still need to create a transaction window, do so here. <br>     */ <br>    if (!hwndInfoCtrl) { <br>        hwndInfoCtrl = CreateXactionWindow((HWND)ci.hUser, pxact); <br>        if (!hwndInfoCtrl) { <br>            MyFree(pxact); <br>            return 0; <br>        } <br>        SetFocus(hwndInfoCtrl); <br>    } <br>    /* <br>     * Disable callbacks for this conversation now if the XOPT_DISABLEFIRST <br>     * option is set.  This tests disabling asynchronous transactions <br>     * before they are completed. <br>     */ <br>    if (pxact-&gt;fsOptions &amp; XOPT_DISABLEFIRST) <br>        DdeEnableCallback(idInst, pxact-&gt;hConv, EC_DISABLE); <br>    /* <br>     * Adjust the timeout for asynchronous transactions. <br>     */ <br>    if (pxact-&gt;fsOptions &amp; XOPT_ASYNC) <br>        pxact-&gt;ulTimeout = TIMEOUT_ASYNC; <br> <br>    /* <br>     * start transaction with DDEML here <br>     */ <br>    pxact-&gt;ret = (DWORD) DdeClientTransaction((LPBYTE)pxact-&gt;hDdeData, 0xFFFFFFFF, <br>            pxact-&gt;hConv, pxact-&gt;hszItem, pxact-&gt;wFmt, <br>            pxact-&gt;wType, <br>            pxact-&gt;ulTimeout, (LPDWORD)&amp;pxact-&gt;Result); <br> <br>    /* <br>     * show return value in transaction window <br>     */ <br>    wsprintf(szT, TEXT("ret=%lx"), pxact-&gt;ret); <br>    SendMessage(hwndInfoCtrl, ICM_SETSTRING, ICSID_UR, (DWORD)(LPTSTR)szT); <br> <br>    /* <br>     * show result or ID value in transaction window <br>     */ <br>    wsprintf(szT, pxact-&gt;fsOptions &amp; XOPT_ASYNC ? TEXT("ID=%ld") : <br>            TEXT("result=0x%lx"), pxact-&gt;Result); <br>    SendMessage(hwndInfoCtrl, ICM_SETSTRING, ICSID_LR, (DWORD)(LPTSTR)szT); <br> <br>    if ((pxact-&gt;fsOptions &amp; XOPT_ASYNC) &amp;&amp; pxact-&gt;ret) { <br>        /* <br>         * asynchronous successful start - link transaction to window. <br>         */ <br>        DdeSetUserHandle(pxact-&gt;hConv, pxact-&gt;Result, (DWORD)hwndInfoCtrl); <br> <br>        /* <br>         * Abandon started async transaction after initiated if <br>         * XOPT_ABANDONAFTERSTART is chosen.  This tests the mid-transaction <br>         * abandoning code. <br>         */ <br>        if (pxact-&gt;fsOptions &amp; XOPT_ABANDONAFTERSTART) <br>            DdeAbandonTransaction(idInst, pxact-&gt;hConv, pxact-&gt;Result); <br>        /* <br>         * show actual status <br>         */ <br>        ci.cb = sizeof(CONVINFO); <br>        DdeQueryConvInfo(pxact-&gt;hConv, pxact-&gt;Result, &amp;ci); <br>        SendMessage(hwndInfoCtrl, ICM_SETSTRING, ICSID_LL, <br>                (DWORD)(LPTSTR)State2String(ci.wConvst)); <br>    } else { <br>        /* <br>         * Synchronous transactions are completed already so pass on to <br>         * CompleteTransaction right away. <br>         */ <br>        CompleteTransaction(hwndInfoCtrl, pxact); <br>    } <br>    return TRUE; <br>} <br> <br> <br> <br> <br> <br>/**************************************************************************** <br> *                                                                          * <br> *  FUNCTION   : CompleteTransaction()                                      * <br> *                                                                          * <br> *  PURPOSE    : This handles completed synchronous and asynchronous        * <br> *               transactions as well as failed attempted transactions.     * <br> *                                                                          * <br> *  RETURNS    : TRUE  - If successful.                                     * <br> *               FALSE - otherwise.                                         * <br> *                                                                          * <br> ****************************************************************************/ <br>VOID CompleteTransaction( <br>HWND hwndInfoCtrl, <br>XACT *pxact) <br>{ <br>    PTSTR psz; <br> <br>    if (pxact-&gt;ret) { <br>        /* <br>         * Successful transaction case <br>         */ <br>        SendMessage(hwndInfoCtrl, ICM_SETSTRING, ICSID_LL, <br>                (DWORD)(LPTSTR)TEXT("Completed")); <br> <br>        if (pxact-&gt;wType == XTYP_REQUEST) { <br>            /* <br>             * Show resulting data <br>             */ <br>            psz = GetTextData((HDDEDATA)pxact-&gt;ret); <br>            if (!DdeCmpStringHandles(pxact-&gt;hszItem, hszHuge) &amp;&amp; <br>                    !CheckHugeData((HDDEDATA)pxact-&gt;ret)) { <br>                SendMessage(hwndInfoCtrl, ICM_SETSTRING, ICSID_CENTER, <br>                        (DWORD)(LPTSTR)TEXT("Invalid Huge Data")); <br>            } else { <br>                SendMessage(hwndInfoCtrl, ICM_SETSTRING, ICSID_CENTER, <br>                        (DWORD)(LPTSTR)psz); <br>            } <br>            MyFree(psz); <br>            /* <br>             * free returned data since it is displayed. <br>             */ <br>            DdeFreeDataHandle((HDDEDATA)pxact-&gt;ret); <br>            pxact-&gt;ret = 0L; <br>            SendMessage(hwndInfoCtrl, ICM_SETSTRING, ICSID_UR, 0); <br>        } <br>    } else { <br>        /* <br>         * failed - show error result. <br>         */ <br>        SendMessage(hwndInfoCtrl, ICM_SETSTRING, ICSID_LL, <br>                (DWORD)(LPTSTR)Error2String(DdeGetLastError(idInst))); <br>    } <br>    pxact-&gt;fsOptions |= XOPT_COMPLETED; <br>} <br> <br> <br> <br> <br>/**************************************************************************** <br> *                                                                          * <br> *  FUNCTION   : DdeCallback()                                              * <br> *                                                                          * <br> *  PURPOSE    : This handles all callbacks from the DDEML.  This handles   * <br> *               updating of the associated conversation and any special    * <br> *               testing cases such as blocking callbacks etc.              * <br> *                                                                          * <br> *               For the most part, clients only handle advise data and     * <br> *               asynchronous transaction completion here.                  * <br> *                                                                          * <br> *  RETURNS    : Results vary depending on transaction type.                * <br> *                                                                          * <br> ****************************************************************************/ <br>HDDEDATA CALLBACK DdeCallback( <br>UINT wType, <br>UINT wFmt, <br>HCONV hConv, <br>HSZ hsz1, <br>HSZ hsz2, <br>HDDEDATA hData, <br>DWORD lData1, <br>DWORD lData2) <br>{ <br>    HWND hwnd; <br>    CONVINFO ci; <br>    XACT *pxact; <br> <br>    if (hConv) { <br>        /* <br>         * update conversation status if it changed. <br>         */ <br>        MYCONVINFO *pmci; <br> <br>        ci.cb = sizeof(CONVINFO); <br>        if (!DdeQueryConvInfo(hConv, QID_SYNC, &amp;ci) || (!IsWindow((HWND)ci.hUser))) { <br>            /* <br>             * This conversation does not yet have a corresponding MDI window <br>             * or is disconnected. <br>             */ <br>            return 0; <br>        } <br>        if (pmci = (MYCONVINFO *)GetWindowLong((HWND)ci.hUser, 0)) { <br>            if (pmci-&gt;ci.wStatus != ci.wStatus || <br>                    pmci-&gt;ci.wConvst != ci.wConvst || <br>                    pmci-&gt;ci.wLastError != ci.wLastError) { <br>                /* <br>                 * Things have changed, updated the conversation window. <br>                 */ <br>                InvalidateRect((HWND)ci.hUser, NULL, TRUE); <br>            } <br>            if (ci.wConvst &amp; ST_INLIST) { <br>                /* <br>                 * update the associated list window (if any) as well. <br>                 */ <br>                if (hwnd = FindListWindow(ci.hConvList)) <br>                    InvalidateRect(hwnd, NULL, TRUE); <br>            } <br>        } <br>    } <br> <br>    /* <br>     * handle special block on next callback option here.  This demonstrates <br>     * the CBR_BLOCK feature. <br>     */ <br>    if (fBlockNextCB &amp;&amp; !(wType &amp; XTYPF_NOBLOCK)) { <br>        fBlockNextCB = FALSE; <br>        return(CBR_BLOCK); <br>    } <br> <br>    /* <br>     * handle special termination here.  This demonstrates that at any time <br>     * a client can drop a conversation. <br>     */ <br>    if (fTermNextCB &amp;&amp; hConv &amp;&amp; wType != XTYP_DISCONNECT) { <br>        fTermNextCB = FALSE; <br>        MyDisconnect(hConv); <br>        return(0); <br>    } <br> <br>    /* <br>     * Now we begin sort out what to do. <br>     */ <br>    switch (wType) { <br>    case XTYP_REGISTER: <br>    case XTYP_UNREGISTER: <br>        /* <br>         * This is where the client would insert code to keep track of <br>         * what servers are available.  This could cause the initiation <br>         * of some conversations. <br>         */ <br>        break; <br> <br>    case XTYP_DISCONNECT: <br>        if (fAutoReconnect) { <br>            /* <br>             * attempt a reconnection <br>             */ <br>            if (hConv = DdeReconnect(hConv)) { <br>                AddConv(ci.hszServiceReq, ci.hszTopic, hConv, FALSE); <br>                return 0; <br>            } <br>        } <br> <br>        /* <br>         * update conv window to show its new state. <br>         */ <br>        SendMessage((HWND)ci.hUser, UM_DISCONNECTED, 0, 0); <br>        return 0; <br>        break; <br> <br>    case XTYP_ADVDATA: <br>        /* <br>         * data from an active advise loop (from a server) <br>         */ <br>        Delay(wDelay); <br>        hwnd = FindAdviseChild((HWND)ci.hUser, hsz2, wFmt); <br>        if (!IsWindow(hwnd)) { <br>            PTSTR pszItem, pszFmt; <br>            /* <br>             * AdviseStart window is gone, make a new one. <br>             */ <br>            pxact = (XACT *)MyAlloc(sizeof(XACT)); <br>            pxact-&gt;wType = wType; <br>            pxact-&gt;hConv = hConv; <br>            pxact-&gt;wFmt = wFmt; <br>            pxact-&gt;hszItem = hsz2; <br>            DdeKeepStringHandle(idInst, hsz2); <br> <br>            pszItem = GetHSZName(hsz2); <br>            pszFmt = GetFormatName(wFmt); <br> <br>            hwnd = CreateInfoCtrl(NULL, <br>                    (INT)SendMessage((HWND)ci.hUser, UM_GETNEXTCHILDX, 0, 0L), <br>                    (INT)SendMessage((HWND)ci.hUser, UM_GETNEXTCHILDY, 0, 0L), <br>                    200, 100, <br>                    (HWND)ci.hUser, hInst, <br>                    Type2String(wType, 0), (LPTSTR)pszItem, NULL, <br>                    NULL, (LPTSTR)pszFmt, NULL, <br>                    ICSTY_SHOWFOCUS, 0, (DWORD)(LPTSTR)pxact); <br> <br>            MyFree(pszFmt); <br>            MyFree(pszItem); <br> <br>            if (!IsWindow(hwnd)) <br>                return(DDE_FNOTPROCESSED); <br>        } <br>        if (!hData) { <br>            /* <br>             * XTYPF_NODATA case - request the info. (we do this synchronously <br>             * for simplicity) <br>             */ <br>            hData = DdeClientTransaction(NULL, 0L, hConv, hsz2, wFmt, <br>                    XTYP_REQUEST, DefTimeout, NULL); <br>        } <br>        if (hData) { <br>            PTSTR pData; <br>            /* <br>             * Show incomming data on corresponding transaction window. <br>             */ <br>            pData = GetTextData(hData); <br>            SendMessage(hwnd, ICM_SETSTRING, ICSID_CENTER, (DWORD)(LPTSTR)pData); <br>            MyFree(pData); <br>            DdeFreeDataHandle(hData); <br>        } <br>        SendMessage(hwnd, ICM_SETSTRING, ICSID_LL, (DWORD)(LPTSTR)TEXT("Advised")); <br>        return((HDDEDATA)DDE_FACK); <br>        break; <br> <br>    case XTYP_XACT_COMPLETE: <br>        /* <br>         * An asynchronous transaction has completed.  Show the results. <br>         * <br>         * ...unless the XOPT_BLOCKRESULT is chosen. <br>         */ <br> <br>        ci.cb = sizeof(CONVINFO); <br>        if (DdeQueryConvInfo(hConv, lData1, &amp;ci) &amp;&amp; <br>                IsWindow((HWND)ci.hUser) &amp;&amp; <br>                (pxact = (XACT *)GetWindowLong((HWND)ci.hUser, GWL_USER))) { <br> <br>            if (pxact-&gt;fsOptions &amp; XOPT_BLOCKRESULT) { <br>                pxact-&gt;fsOptions &amp;= ~XOPT_BLOCKRESULT; <br>                return(CBR_BLOCK); <br>            } <br> <br>            pxact-&gt;Result = lData2; <br>            pxact-&gt;ret = (DWORD)hData; <br>            CompleteTransaction((HWND)ci.hUser, pxact); <br>        } <br>        break; <br>    } <br>} <br> <br> <br> <br> <br> <br> <br> <br>/**************************************************************************** <br> *                                                                          * <br> *  FUNCTION   : FindAdviseChild()                                          * <br> *                                                                          * <br> *  PURPOSE    : Search through the child windows of hwndMDI for an info    * <br> *               ctrl that has the same Item and format and is an           * <br> *               ADVSTART ADVSTOP or ADVDATA transaction window.            * <br> *                                                                          * <br> *               We use these to show the associated advise data.           * <br> *                                                                          * <br> *  RETURNS    : The transaction window handle or 0 on failure.             * <br> *                                                                          * <br> ****************************************************************************/ <br>HWND FindAdviseChild( <br>HWND hwndMDI, <br>HSZ hszItem, <br>DWORD wFmt) <br>{ <br>    HWND hwnd, hwndStart; <br>    XACT *pxact; <br> <br>    if (!IsWindow(hwndMDI)) <br>        return 0; <br> <br>    hwnd = hwndStart = GetWindow(hwndMDI, GW_CHILD); <br>    while (hwnd &amp;&amp; IsChild(hwndMDI, hwnd)) { <br>        pxact = (XACT *)GetWindowLong(hwnd, GWL_USER); <br>        if (pxact &amp;&amp; <br>                (pxact)-&gt;wFmt == wFmt &amp;&amp; <br>                (pxact)-&gt;hszItem == hszItem &amp;&amp; <br>                ( <br>                    ((pxact-&gt;wType &amp; XTYP_ADVSTART) == XTYP_ADVSTART) || <br>                    (pxact-&gt;wType == XTYP_ADVSTOP) || <br>                    (pxact-&gt;wType == XTYP_ADVDATA) <br>                ) <br>           ) { <br>            return(hwnd); <br>        } <br>        hwnd = GetWindow(hwnd, GW_HWNDNEXT); <br>        if (hwnd == hwndStart) <br>            return 0; <br>    } <br>    return 0; <br>} <br> <br> <br> <br>/**************************************************************************** <br> *                                                                          * <br> *  FUNCTION   : FindListWindow()                                           * <br> *                                                                          * <br> *  PURPOSE    : Locates the list window associated with this conversation  * <br> *               list.                                                      * <br> *                                                                          * <br> *  RETURNS    : The window handle of the list window or 0 on failure.      * <br> *                                                                          * <br> ****************************************************************************/ <br>HWND FindListWindow( <br>HCONVLIST hConvList) <br>{ <br>    HWND hwnd; <br>    MYCONVINFO *pmci; <br> <br>    hwnd = GetWindow(hwndMDIClient, GW_CHILD); <br>    while (hwnd) { <br>        if (GetWindowLong(hwnd, GWL_WNDPROC) == (LONG)MDIChildWndProc) { <br>            pmci = (MYCONVINFO *)GetWindowLong(hwnd, 0); <br>            if (pmci != NULL &amp;&amp; pmci-&gt;fList &amp;&amp; <br>                    pmci-&gt;hConv == (HCONV)hConvList) <br>                return(hwnd); <br>        } <br>        hwnd = GetWindow(hwnd, GW_HWNDNEXT); <br>    } <br>    return 0; <br>} <br> <br> <br> <br> <br>/**************************************************************************** <br> *                                                                          * <br> *  FUNCTION   : GetTextData()                                              * <br> *                                                                          * <br> *  PURPOSE    : Allocates and returns a pointer to the data contained in   * <br> *               hData.  This assumes that hData points to text data and    * <br> *               will properly handle huge text data by leaving out the     * <br> *               middle of the string and placing the size of the string    * <br> *               into this string portion.                                  * <br> *                                                                          * <br> *  RETURNS    : A pointer to the allocated string.                         * <br> *                                                                          * <br> ****************************************************************************/ <br>PTSTR GetTextData( <br>HDDEDATA hData) <br>{ <br>    PTSTR psz; <br>    DWORD cb; <br> <br>#define MAXCCH  1024 <br> <br>    if (hData == 0) { <br>        return(NULL); <br>    } <br> <br>    cb = DdeGetData(hData, NULL, 0, 0); <br>    if (!hData || !cb) <br>        return NULL; <br> <br>    if (cb &gt; MAXCCH) {                // possibly HUGE object! <br>        psz = MyAlloc(MAXCCH * sizeof(TCHAR)); <br>        DdeGetData(hData, (PBYTE)psz, MAXCCH - 46 * sizeof(TCHAR), 0L); <br>        wsprintf(&amp;psz[MAXCCH - 46], TEXT("&lt;---Size=%ld"), cb); <br>    } else { <br>        psz = MyAlloc((DWORD)cb); <br>        DdeGetData(hData, (LPBYTE)psz, cb, 0L); <br>    } <br>    return psz; <br>#undef MAXCCH <br>} <br> <br> <br> <br> <br> <br> <br> <br>/**************************************************************************** <br> *                                                                          * <br> *  FUNCTION   : MyGetClipboardFormatName()                                 * <br> *                                                                          * <br> *  PURPOSE    : Properly retrieves the string associated with a clipboard  * <br> *               format.  If the format does not have a string associated   * <br> *               with it, the string #dddd is returned.                     * <br> *                                                                          * <br> *  RETURNS    : The number of characters copied into lpstr or 0 on error.  * <br> *                                                                          * <br> ****************************************************************************/ <br>INT MyGetClipboardFormatName( <br>DWORD fmt, <br>LPTSTR lpstr, <br>INT cbMax) <br>{ <br>    if (fmt &lt; 0xc000) { <br>        // predefined or integer format - just get the atom string <br>        // wierdly enough, GetClipboardFormatName() doesn't support this. <br>        return(GlobalGetAtomName((ATOM)fmt, lpstr, cbMax)); <br>    } else { <br>        return(GetClipboardFormatName(fmt, lpstr, cbMax)); <br>    } <br>} <br> <br> <br> <br> <br> <br>/**************************************************************************** <br> *                                                                          * <br> *  FUNCTION   : GetFormatName()                                            * <br> *                                                                          * <br> *  PURPOSE    : allocates and returns a pointer to a string representing   * <br> *               a format.  Use MyFree() to free this string.               * <br> *                                                                          * <br> *  RETURNS    : The number of characters copied into lpstr or 0 on error.  * <br> *                                                                          * <br> ****************************************************************************/ <br>PTSTR GetFormatName( <br>DWORD wFmt) <br>{ <br>    PTSTR psz; <br>    DWORD cb; <br> <br>    if (wFmt == CF_UNICODETEXT) { <br>       psz = MyAlloc(40); <br>       _tcscpy(psz, TEXT("CF_UNICODETEXT")); <br>       return psz; <br>    } <br>    if (wFmt == CF_TEXT) { <br>        psz = MyAlloc(40); <br>        _tcscpy(psz, TEXT("CF_TEXT")); <br>        return psz; <br>    } <br>    psz = MyAlloc(255); <br>    *psz = TEXT('\0'); <br>    cb = GetClipboardFormatName(wFmt, psz, 255) + 1; <br>    return((PTSTR)LocalReAlloc((HANDLE)psz, cb, LMEM_MOVEABLE)); <br>} <br> <br> <br> <br> <br>/**************************************************************************** <br> *                                                                          * <br> *  FUNCTION   : MyDisconnect()                                             * <br> *                                                                          * <br> *  PURPOSE    : Disconnects the given conversation after updating the      * <br> *               associated conversation window.                            * <br> *                                                                          * <br> *  RETURNS    : TRUE on success, FALSE on failuer.                         * <br> *                                                                          * <br> ****************************************************************************/ <br>BOOL MyDisconnect( <br>HCONV hConv) <br>{ <br>    CONVINFO ci; <br>    HWND hwnd; <br>    // before we disconnect, invalidate the associated list window - if <br>    // applicable. <br> <br>    ci.cb = sizeof(CONVINFO); <br> <br>    if (DdeQueryConvInfo(hConv, QID_SYNC, &amp;ci) &amp;&amp; ci.hConvList &amp;&amp; <br>            (hwnd = FindListWindow(ci.hConvList))) <br>        InvalidateRect(hwnd, NULL, TRUE); <br>    return(DdeDisconnect(hConv)); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
