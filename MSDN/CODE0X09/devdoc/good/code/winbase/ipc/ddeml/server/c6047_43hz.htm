<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DDE.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6047"></a>DDE.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples. <br>*       Copyright 1993 - 1998 Microsoft Corporation. <br>*       All rights reserved. <br>*       This source code is only intended as a supplement to <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>/* <br> * This module serves to demonstrate one way a sophisticated DDE server <br> * that uses enumerable topics and items might be implemented.  It takes <br> * full advantage of appowned data handles (when fAppowned is set) to <br> * minimize the need for repeated rendering of data when shared with <br> * multiple clients. <br> * <br> * The server supports full system topic information plus help and non <br> * system topic item enumeration for the benefit of browsing clients <br> * that are wondering what's around. <br> * <br> * This server can be made secure by altering the conversation context <br> * filter. <br> * <br> * This server can appear to support alternate codepages and languages <br> * by altering the conversation context filter.   On Windows this is <br> * pretty much moot since there is not yet a clearly defined way of <br> * doing international communication and because the atom manager restricts <br> * what topic and item strings can be used on the system. <br> */ <br> <br>#include &lt;string.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;memory.h&gt; <br>#include "server.h" <br>#include "huge.h" <br> <br>/* <br> * This function verifies that the incomming conversation context fits the <br> * server's context filter's requirements. <br> */ <br>BOOL ValidateContext( <br>PCONVCONTEXT pCC) <br>{ <br>    // make sure our CCFilter allows it...mock security, language support <br>    // old DDE app client case...pCC == NULL <br>    if (pCC == NULL &amp;&amp; <br>            CCFilter.dwSecurity == 0 &amp;&amp;      // were nonsecure <br>            CCFilter.iCodePage == CP_WINANSI &amp;&amp; // were normal cp <br>            CCFilter.qos.ImpersonationLevel == SecurityImpersonation <br>            ) { <br>        return(TRUE); <br>    } <br> <br>    if (pCC &amp;&amp; <br>            pCC-&gt;wFlags == CCFilter.wFlags &amp;&amp; // no special flags needed <br>            pCC-&gt;iCodePage == CCFilter.iCodePage &amp;&amp; // codepages match <br>            pCC-&gt;dwSecurity == CCFilter.dwSecurity &amp;&amp; // security passes <br>            pCC-&gt;qos.ImpersonationLevel &gt;= CCFilter.qos.ImpersonationLevel) { <br>        // dont care about language and country. <br>        return(TRUE); <br>    } <br>    return(FALSE);  // disallow no match <br>} <br> <br> <br>/***************************** Public  Function ****************************\ <br>* <br>* This function is called by the DDE manager DLL and passes control onto <br>* the apropriate function pointed to by the global topic and item arrays. <br>* It handles all DDE interaction generated by external events. <br>* <br>\***************************************************************************/ <br>HDDEDATA CALLBACK DdeCallback( <br>UINT wType, <br>UINT wFmt, <br>HCONV hConv, <br>HSZ hszTopic, <br>HSZ hszItem, <br>HDDEDATA hData, <br>DWORD lData1, <br>DWORD lData2) <br>{ <br>    WORD i, j; <br>    register ITEMLIST *pItemList; <br>    WORD cItems, iFmt; <br>    HDDEDATA hDataRet; <br> <br>    /* <br>     * Block this callback if its blockable and we are supposed to. <br>     */ <br>    if (fBlockNextCB &amp;&amp; !(wType &amp; XTYPF_NOBLOCK)) { <br>        fBlockNextCB = FALSE; <br>        fAllEnabled = FALSE; <br>        return(CBR_BLOCK); <br>    } <br> <br>    /* <br>     * Block this callback if its associated with a conversation and we <br>     * are supposed to. <br>     */ <br>    if (fTermNextCB &amp;&amp; hConv) { <br>        fTermNextCB = FALSE; <br>        DdeDisconnect(hConv); <br>        wType = XTYP_DISCONNECT; <br>    } <br> <br>    /* <br>     * Keep a count of connections <br>     */ <br>    if (wType == XTYP_CONNECT_CONFIRM) { <br>        cServers++; <br>        InvalidateRect(hwndServer, &amp;rcConnCount, TRUE); <br>        return(0); <br>    } <br>    if (wType == XTYP_DISCONNECT) { <br>        cServers--; <br>        InvalidateRect(hwndServer, &amp;rcConnCount, TRUE); <br>        return(0); <br>    } <br> <br> <br>    /* <br>     * only allow transactions on the formats we support if they have a format. <br>     */ <br>    if (wFmt) { <br>        for (iFmt = 0; iFmt &lt; CFORMATS; iFmt++) { <br>            if ((ATOM)wFmt == aFormats[iFmt].atom) <br>                break; <br>        } <br>        if (iFmt == CFORMATS) <br>            return(0);          // illegal format - ignore now. <br>    } <br> <br>    /* <br>     * Executes are allowed only on the system topic.  This is a general <br>     * convention, not a requirement. <br>     * <br>     * Any executes received result in the execute text being shown in <br>     * the server client area.  No real action is taken. <br>     */ <br>    if (wType == XTYP_EXECUTE) { <br>        if (hszTopic == topicList[0].hszTopic) {    // must be on system topic <br>            // Format is assumed to be CF_TEXT. <br>            DdeGetData(hData, (LPBYTE)szExec, MAX_EXEC, 0); <br>            szExec[MAX_EXEC - 1] = TEXT('\0'); <br>            InvalidateRect(hwndServer, &amp;rcExec, TRUE); <br>            hDataRet = (HDDEDATA)TRUE; <br>            goto ReturnSpot; <br>        } <br>        pszComment = TEXT("Execute received on non-system topic - ignored"); <br>        InvalidateRect(hwndServer, &amp;rcComment, TRUE); <br>        return(0); <br>    } <br> <br>    /* <br>     * Process wild initiates here <br>     */ <br>    if (wType == XTYP_WILDCONNECT) { <br>        HSZ ahsz[(CTOPICS + 1) * 2]; <br>        /* <br>         * He wants a hsz list of all our available app/topic pairs <br>         * that conform to hszTopic and hszItem(App). <br>         */ <br> <br>        if (!ValidateContext((PCONVCONTEXT)lData1)) { <br>            return(FALSE); <br>        } <br> <br>        if (hszItem != hszAppName &amp;&amp; hszItem != 0) { <br>            // we only support the hszAppName service <br>            return(0); <br>        } <br> <br>        // scan the topic table and create hsz pairs <br>        j = 0; <br>        for (i = 0; i &lt; CTOPICS; i++) { <br>            if (hszTopic == 0 || hszTopic == topicList[i].hszTopic) { <br>                ahsz[j++] = hszAppName; <br>                ahsz[j++] = topicList[i].hszTopic; <br>            } <br>        } <br> <br>        // cap off the list with 0s <br>        ahsz[j++] = ahsz[j++] = 0L; <br> <br>        // send it back <br>        return(DdeCreateDataHandle(idInst, (LPBYTE)&amp;ahsz[0], sizeof(HSZ) * j, 0L, 0, wFmt, 0)); <br>    } <br> <br>    /* <br>     * Check our hsz tables and send to the apropriate proc. to process. <br>     * We use DdeCmpStringHandles() which is the portable case-insensitive <br>     * method of comparing string handles.  (this is a macro on windows so <br>     * there is no real speed hit.)  On WINDOWS, HSZs are case-insensitive <br>     * anyway, but this may not be the case on other platforms. <br>     */ <br>    for (i = 0; i &lt; CTOPICS; i++) { <br>        if (DdeCmpStringHandles(topicList[i].hszTopic, hszTopic) == 0) { <br> <br>            /* <br>             * connections must be on a topic we support. <br>             */ <br>            if (wType == XTYP_CONNECT) { <br>                return((HDDEDATA)ValidateContext((PCONVCONTEXT)lData1)); <br>            } <br> <br>            pItemList = topicList[i].pItemList; <br>            cItems = topicList[i].cItems; <br>            for (j = 0; j &lt; cItems; j++) { <br>                if (DdeCmpStringHandles(pItemList[j].hszItem, hszItem) == 0) { <br>                    XFERINFO xi; <br> <br>                    /* <br>                     * If Win32s - security isn't supported <br>                     */ <br>                    if(GetVersion() &amp; 0x80000000) { <br>                        /* <br>                         * Make call to worker function here... <br>                         */ <br>                        xi.wType = wType; <br>                        xi.wFmt = wFmt; <br>                        xi.hConv = hConv; <br>                        xi.hszTopic = hszTopic; <br>                        xi.hszItem = hszItem; <br>                        xi.hData = hData; <br>                        xi.lData1 = lData1; <br>                        xi.lData2 = lData2; <br>                        hDataRet = (*pItemList[j].npfnCallback)(&amp;xi, iFmt); <br>                     } else { <br>                        /* <br>                         * Windows NT - impersonate client here <br>                         */ <br>                        if (DdeImpersonateClient(hConv)) { <br>                            /* <br>                             * Make call to worker function here... <br>                             */ <br>                            xi.wType = wType; <br>                            xi.wFmt = wFmt; <br>                            xi.hConv = hConv; <br>                            xi.hszTopic = hszTopic; <br>                            xi.hszItem = hszItem; <br>                            xi.hData = hData; <br>                            xi.lData1 = lData1; <br>                            xi.lData2 = lData2; <br>                            hDataRet = (*pItemList[j].npfnCallback)(&amp;xi, iFmt); <br>                            RevertToSelf(); <br>                        } else { <br>                            pszComment = TEXT("Impersonation failed."); <br>                            InvalidateRect(hwndServer, &amp;rcComment, TRUE); <br>                            hDataRet = 0; <br>                        } <br>                     } <br> <br>ReturnSpot: <br>                    /* <br>                     * The table functions return a boolean or data. <br>                     * It gets translated here. <br>                     */ <br>                    switch (wType &amp; XCLASS_MASK) { <br>                    case XCLASS_DATA: <br>                        return(hDataRet); <br>                        break; <br>                    case XCLASS_FLAGS: <br>                        return(HDDEDATA)(hDataRet ? DDE_FACK : DDE_FNOTPROCESSED); <br>                        break; <br>                    case XCLASS_BOOL: <br>                        return((HDDEDATA)TRUE); <br>                    default: // XCLASS_NOTIFICATION <br>                        return(0); <br>                        break; <br>                    } <br>                    break; <br>                } <br>            } <br>            break; <br>        } <br>    } <br> <br>    /* <br>     * anything else fails - DDEML is designed so that a 0 return is ALWAYS ok. <br>     */ <br>    return(0); <br>} <br> <br> <br> <br> <br> <br>/***************************** Private Function ****************************\ <br>* This passes out a standard tab-delimited list of topic names for this <br>* application. <br>* <br>* This support is required for other apps to be able to <br>* find out about us.  This kind of support should be in every DDE <br>* application. <br>* <br>\***************************************************************************/ <br>HDDEDATA TopicListXfer( <br>PXFERINFO pXferInfo, <br>WORD iFmt) <br>{ <br>    WORD cbAlloc, i; <br>    LPTSTR pszTopicList; <br>    HDDEDATA hData; <br> <br>    if (pXferInfo-&gt;wType == XTYP_ADVSTART) <br>        return((HDDEDATA)TRUE); <br> <br>    if (pXferInfo-&gt;wType != XTYP_REQUEST &amp;&amp; <br>            pXferInfo-&gt;wType != XTYP_ADVREQ) <br>        return(0); <br>    /* <br>     * construct the list of topics we have <br>     */ <br>    cbAlloc = 0; <br>    for (i = 0; i &lt; CTOPICS; i++) <br>        cbAlloc += (_tcslen(topicList[i].pszTopic) + 1) * sizeof(TCHAR);  // 1 for tab <br> <br>    // allocate a data handle big enough for the list. <br>    hData = DdeCreateDataHandle(idInst, NULL, 0, cbAlloc, pXferInfo-&gt;hszItem, <br>            pXferInfo-&gt;wFmt, 0); <br>    pszTopicList = (LPTSTR)DdeAccessData(hData, NULL); <br>    if (pszTopicList) { <br>        for (i = 0; i &lt; CTOPICS; i++) { <br>            _tcscpy(pszTopicList, topicList[i].pszTopic); <br>            pszTopicList += _tcslen(topicList[i].pszTopic); <br>            *pszTopicList++ = TEXT('\t'); <br>        } <br>        *--pszTopicList = TEXT('\0'); <br>        DdeUnaccessData(hData); <br>        return(hData); <br>    } <br>    return(0); <br>} <br> <br> <br> <br> <br>/***************************** Private Function ****************************\ <br>* This passes out a standard tab-delimited list of item names for the <br>* specified topic. <br>* <br>* This support is required for other apps to be able to <br>* find out about us.  This kind of support should be in every DDE <br>* application. <br>* <br>\***************************************************************************/ <br>HDDEDATA ItemListXfer( <br>PXFERINFO pXferInfo, <br>WORD iFmt) <br>{ <br>    WORD cbAlloc, i, iItem, cItems; <br>    ITEMLIST *pItemList = 0; <br>    LPTSTR pszItemList; <br>    HDDEDATA hData; <br> <br>    if (pXferInfo-&gt;wType == XTYP_ADVSTART) <br>        return((HDDEDATA)TRUE); <br> <br>    if (pXferInfo-&gt;wType != XTYP_REQUEST &amp;&amp; <br>                pXferInfo-&gt;wType != XTYP_ADVREQ) <br>        return(0); <br>    /* <br>     * construct the list of items we support for this topic - this supports <br>     * more than the minimum standard which would support SysItems only on <br>     * the system topic. <br>     */ <br> <br>    // locate the requested topic item table <br>    for (i = 0; i &lt; CTOPICS; i++) { <br>        if (pXferInfo-&gt;hszTopic == topicList[i].hszTopic) { <br>            pItemList = topicList[i].pItemList; <br>            cItems = topicList[i].cItems; <br>            break; <br>        } <br>    } <br> <br>    if (!pItemList) <br>        return(0);  // item not found <br> <br>    cbAlloc = 0; <br>    for (iItem = 0; iItem &lt; cItems; iItem++) <br>        cbAlloc += (_tcslen(pItemList[iItem].pszItem) + 1) * sizeof(TCHAR); // 1 for tab <br> <br>    // allocate a data handle big enough for the list. <br>    hData = DdeCreateDataHandle(idInst, NULL, 0, cbAlloc, pXferInfo-&gt;hszItem, <br>            pXferInfo-&gt;wFmt, 0); <br>    pszItemList = (LPTSTR)DdeAccessData(hData, NULL); <br>    if (pszItemList) { <br>        for (i = 0; i &lt; cItems; i++) { <br>            _tcscpy(pszItemList, pItemList[i].pszItem); <br>            pszItemList += _tcslen(pItemList[i].pszItem); <br>            *pszItemList++ = TEXT('\t'); <br>        } <br>        *--pszItemList = TEXT('\0'); <br>        DdeUnaccessData(hData); <br>        return(hData); <br>    } <br>    return(0); <br>} <br> <br> <br> <br> <br> <br>/***************************** Private Function ****************************\ <br>* Gives out a 0 terminated array of dde format numbers supported by this app. <br>* <br>* This support is required for other apps to be able to <br>* find out about us.  This kind of support should be in every DDE <br>* application. <br>* <br>\***************************************************************************/ <br>HDDEDATA sysFormatsXfer( <br>PXFERINFO pXferInfo, <br>WORD iFmt) <br>{ <br>    INT i, cb; <br>    LPTSTR psz, pszT; <br>    HDDEDATA hData; <br> <br>    if (pXferInfo-&gt;wType == XTYP_ADVSTART) <br>        return((HDDEDATA)TRUE); <br> <br>    if (pXferInfo-&gt;wType != XTYP_REQUEST &amp;&amp; <br>            pXferInfo-&gt;wType != XTYP_ADVREQ) <br>        return(0); <br> <br>    for (i = 0, cb = 0; i &lt; CFORMATS; i++) <br>        cb += (_tcslen(aFormats[i].sz) + 1) * sizeof(TCHAR); <br> <br>    hData = DdeCreateDataHandle(idInst, NULL, (DWORD)cb, <br>            0L, pXferInfo-&gt;hszItem, pXferInfo-&gt;wFmt, 0); <br>    psz = pszT = (LPTSTR)DdeAccessData(hData, NULL); <br>    for (i = 0; i &lt; CFORMATS; i++) { <br>        _tcscpy(pszT, aFormats[i].sz); <br>        pszT += _tcslen(pszT); <br>        *pszT++ = TEXT('\t'); <br>    } <br>    *(--pszT) = TEXT('\0'); <br>    DdeUnaccessData(hData); <br>    return(hData); <br>} <br> <br> <br> <br>/* <br> * This is a runaway item.  Each time it is requested, it changes. <br> * pokes just make it change again. <br> */ <br>HDDEDATA TestRandomXfer( <br>PXFERINFO pXferInfo, <br>WORD iFmt) <br>{ <br>    TCHAR szT[10];   // SS==DS! <br>    LPTSTR pszData; <br>    HDDEDATA hData; <br>    WORD i; <br> <br>    switch (pXferInfo-&gt;wType) { <br>    case XTYP_POKE: <br>        // we expect an ascii number to replace the current seed. <br>        pszComment = TEXT("Rand poke received."); <br>        InvalidateRect(hwndServer, &amp;rcComment, TRUE); <br>        InvalidateRect(hwndServer, &amp;rcRand, TRUE); <br>        if (DdeGetData(pXferInfo-&gt;hData, (PBYTE)szT, 10, 0)) { <br>            szT[9] = TEXT('\0');  // just incase we overran. <br>            _stscanf(szT, TEXT("%d"), &amp;seed); <br>            for (i = 0; i &lt; CFORMATS; i++) { <br>                if (hDataRand[i]) <br>                    DdeFreeDataHandle(hDataRand[i]); <br>                hDataRand[i] = 0; <br>            } <br>            DdePostAdvise(idInst, pXferInfo-&gt;hszTopic, pXferInfo-&gt;hszItem); <br>            return((HDDEDATA)1); <br>        } <br>        break; <br> <br>    case XTYP_REQUEST: <br>        pszComment = TEXT("Rand data requested."); <br>        InvalidateRect(hwndServer, &amp;rcComment, TRUE); <br>    case XTYP_ADVREQ: <br>        Delay(RenderDelay, FALSE); <br>        if (!hDataRand[iFmt]) { <br>            hDataRand[iFmt] = DdeCreateDataHandle(idInst, NULL, 0, 10, <br>                    pXferInfo-&gt;hszItem, (UINT)pXferInfo-&gt;wFmt, <br>                    fAppowned ? HDATA_APPOWNED : 0); <br>            if (pszData = (LPTSTR)DdeAccessData(hDataRand[iFmt], NULL)) { <br>                wsprintf(pszData, TEXT("%d"), seed); <br>                DdeUnaccessData(hDataRand[iFmt]); <br>            } <br>        } <br>        hData = hDataRand[iFmt]; <br>        if (!fAppowned) <br>            hDataRand[iFmt] = 0; <br>        return(hData); <br>        break; <br> <br>    case XTYP_ADVSTART: <br>        return((HDDEDATA)1); <br>    } <br>    return(0); <br>} <br> <br>/* <br> * This is a runaway item.  Each time it is requested, it changes. <br> * pokes just make it change again. <br> */ <br>HDDEDATA TestCountXfer( <br>PXFERINFO pXferInfo, <br>WORD iFmt) <br>{ <br>    TCHAR szT[16];   // SS==DS! <br>    LPTSTR pszData; <br>    HDDEDATA hData; <br>    WORD i; <br> <br>    switch (pXferInfo-&gt;wType) { <br>    case XTYP_POKE: <br>        // we expect an ascii number to replace the current count. <br>        pszComment = TEXT("Count poke received"); <br>        InvalidateRect(hwndServer, &amp;rcComment, TRUE); <br>        InvalidateRect(hwndServer, &amp;rcCount, TRUE); <br>        if (DdeGetData(pXferInfo-&gt;hData, (PBYTE)szT, 10, 0)) { <br>            szT[9] = TEXT('\0');  // just incase we overran. <br>            _stscanf(szT, TEXT("%ld"), &amp;count); <br>            for (i = 0; i &lt; CFORMATS; i++) { <br>                if (hDataCount[i]) <br>                    DdeFreeDataHandle(hDataCount[i]); <br>                hDataCount[i] = 0; <br>            } <br>            DdePostAdvise(idInst, pXferInfo-&gt;hszTopic, pXferInfo-&gt;hszItem); <br>            return((HDDEDATA)1); <br>        } <br>        break; <br> <br>    case XTYP_REQUEST: <br>        pszComment = TEXT("Count data requested."); <br>        InvalidateRect(hwndServer, &amp;rcComment, TRUE); <br>    case XTYP_ADVREQ: <br>        Delay(RenderDelay, FALSE); <br>        if (!hDataCount[iFmt]) { <br>            hDataCount[iFmt] = DdeCreateDataHandle(idInst, NULL, 0, 10, pXferInfo-&gt;hszItem, <br>                    pXferInfo-&gt;wFmt, fAppowned ? HDATA_APPOWNED : 0); <br>            if (pszData = (LPTSTR)DdeAccessData(hDataCount[iFmt], NULL)) { <br>                wsprintf(pszData, TEXT("%ld"), count); <br>                DdeUnaccessData(hDataCount[iFmt]); <br>            } <br>        } <br>        hData = hDataCount[iFmt]; <br>        if (!fAppowned) <br>            hDataCount[iFmt] = 0; <br>        return(hData); <br>        break; <br> <br>    case XTYP_ADVSTART: <br>        return((HDDEDATA)1); <br>    } <br>    return(0); <br>} <br> <br> <br>/* <br> * This is not a runaway item.  Only Pokes make it change. <br> */ <br>HDDEDATA TestHugeXfer( <br>PXFERINFO pXferInfo, <br>WORD iFmt) <br>{ <br>    BOOL fSuccess; <br>    DWORD ulcb; <br>    LPBYTE lpData; <br>    WORD i; <br>    HDDEDATA hData; <br> <br>    switch (pXferInfo-&gt;wType) { <br>    case XTYP_POKE: <br>        ulcb = DdeGetData(pXferInfo-&gt;hData, NULL, 0, 0); <br>        fSuccess = CheckHugeData(pXferInfo-&gt;hData); <br>        if (fSuccess) { <br>            pszComment = TEXT("Huge poke data successfully received."); <br>        } else { <br>            wsprintf(szComment, TEXT("%ld bytes of invalid Huge data received."), ulcb); <br>            pszComment = szComment; <br>        } <br>        InvalidateRect(hwndServer, &amp;rcComment, TRUE); <br>        InvalidateRect(hwndServer, &amp;rcHugeSize, TRUE); <br>        if (fSuccess) { <br>            for (i = 0; i &lt; CFORMATS; i++) { <br>                if (hDataHuge[i]) { <br>                    DdeFreeDataHandle(hDataHuge[i]); <br>                    hDataHuge[i] = 0; <br>                } <br>            } <br>            /* <br>             * Since callback data handles are only good for the duration of <br>             * the callback, we must copy the data to our own data handle. <br>             */ <br>            lpData = DdeAccessData(pXferInfo-&gt;hData, &amp;cbHuge); <br>            hDataHuge[iFmt] = DdeCreateDataHandle(idInst, lpData, cbHuge, 0, <br>                    pXferInfo-&gt;hszItem, pXferInfo-&gt;wFmt, fAppowned ? HDATA_APPOWNED : 0); <br>            DdeUnaccessData(pXferInfo-&gt;hData); <br>            DdePostAdvise(idInst, pXferInfo-&gt;hszTopic, pXferInfo-&gt;hszItem); <br>        } <br>        return((HDDEDATA)fSuccess); <br>        break; <br> <br>    case XTYP_REQUEST: <br>        pszComment = TEXT("Huge data requested."); <br>        InvalidateRect(hwndServer, &amp;rcComment, TRUE); <br>    case XTYP_ADVREQ: <br>        Delay(RenderDelay, FALSE); <br>        if (!hDataHuge[iFmt]) { <br>            cbHuge = (DWORD)rand() * 64L + 0x10000L; <br>            wsprintf(szComment, TEXT("Generating huge data - length=%ld..."), cbHuge); <br>            pszComment = szComment; <br>            InvalidateRect(hwndServer, &amp;rcComment, TRUE); <br>            UpdateWindow(hwndServer); <br>            hDataHuge[iFmt] = CreateHugeDataHandle((LONG)cbHuge, 4325, 345, 5, <br>                    pXferInfo-&gt;hszItem, <br>                    pXferInfo-&gt;wFmt, (WORD)(fAppowned ? HDATA_APPOWNED : 0)); <br>            pszComment = TEXT(""); <br>            InvalidateRect(hwndServer, &amp;rcComment, TRUE); <br>            InvalidateRect(hwndServer, &amp;rcHugeSize, TRUE); <br>        } <br>        hData = hDataHuge[iFmt]; <br>        if (!fAppowned) <br>            hDataHuge[iFmt] = 0; <br>        return(hData); <br>        break; <br> <br>    case XTYP_ADVSTART: <br>        return((HDDEDATA)1); <br>    } <br>    return(0); <br>} <br> <br> <br>HDDEDATA HelpXfer( <br>PXFERINFO pXferInfo, <br>WORD iFmt) <br>{ <br>    HDDEDATA hData; <br> <br>    switch (pXferInfo-&gt;wType) { <br>    case XTYP_REQUEST: <br>        pszComment = TEXT("Help text requested."); <br>        InvalidateRect(hwndServer, &amp;rcComment, TRUE); <br>    case XTYP_ADVREQ: <br>        if (!hDataHelp[iFmt]) { <br>           hDataHelp[iFmt] = DdeCreateDataHandle(idInst, <br>                    (PBYTE)szDdeHelp, <br>                    (_tcslen(szDdeHelp) + 1) * sizeof(TCHAR), <br>                    0, pXferInfo-&gt;hszItem, pXferInfo-&gt;wFmt, <br>                    fAppowned ? HDATA_APPOWNED : 0); <br>        } <br>        hData = hDataHelp[iFmt]; <br>        if (!fAppowned) <br>            hDataHelp[iFmt] = 0; <br>        return(hData); <br>        break; <br> <br>    case XTYP_ADVSTART: <br>        return((HDDEDATA)1); <br>    } <br>    return(0); <br>} <br> <br> <br>/***************************** Private Function ****************************\ <br>*  This creates often used global hszs from standard global strings. <br>*  It also fills the hsz fields of the topic and item tables. <br>* <br>\***************************************************************************/ <br>VOID Hszize() <br>{ <br>    register ITEMLIST *pItemList; <br>    int iTopic, iItem; <br> <br>    hszAppName = DdeCreateStringHandle(idInst, szServer, 0); <br> <br>    for (iTopic = 0; iTopic &lt; CTOPICS; iTopic++) { <br>        topicList[iTopic].hszTopic = <br>                DdeCreateStringHandle(idInst, topicList[iTopic].pszTopic, 0); <br>        pItemList = topicList[iTopic].pItemList; <br>        for (iItem = 0; iItem &lt; (int)topicList[iTopic].cItems; iItem++) { <br>            pItemList[iItem].hszItem = <br>                    DdeCreateStringHandle(idInst, pItemList[iItem].pszItem, 0); <br>        } <br>    } <br>} <br> <br> <br> <br> <br> <br>/***************************** Private Function ****************************\ <br>*  This destroys often used global hszs from standard global strings. <br>* <br>\***************************************************************************/ <br>VOID UnHszize() <br>{ <br>    register ITEMLIST *pItemList; <br>    int iTopic, iItem; <br> <br>    DdeFreeStringHandle(idInst, hszAppName); <br> <br>    for (iTopic = 0; iTopic &lt; CTOPICS; iTopic++) { <br>        DdeFreeStringHandle(idInst, topicList[iTopic].hszTopic); <br>        pItemList = topicList[iTopic].pItemList; <br>        for (iItem = 0; iItem &lt; (int)topicList[iTopic].cItems; iItem++) { <br>            DdeFreeStringHandle(idInst, pItemList[iItem].hszItem); <br>        } <br>    } <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
