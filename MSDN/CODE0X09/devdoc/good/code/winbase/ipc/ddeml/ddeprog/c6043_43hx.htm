<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>PROGHELP.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6045"></a>PROGHELP.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples.  <br>*       Copyright 1993 - 1998 Microsoft Corporation. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>/*****************************************************************************\ <br>* PROGHELP.C <br>* <br>* Main module to implement a simple DDEML service DLL that makes interaction <br>* with progman simple. <br>\*****************************************************************************/ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;ddeml.h&gt; <br>#include &lt;string.h&gt; <br> <br>typedef struct { <br>    HCONV hConv; <br>    DWORD idInst; <br>} THREADINFO; <br> <br>DWORD TlsIndex; <br> <br>/* <br> * This is the default DDEML callback function for ProgHelp <br> */ <br>HDDEDATA CALLBACK ProgHelpDdeCallback( <br>UINT wType, <br>UINT wFmt, <br>HCONV hConv, <br>HSZ hsz1, <br>HSZ hsz2, <br>HDDEDATA hData, <br>DWORD dwData1, <br>DWORD dwData2) <br>{ <br>    return(0); <br>} <br> <br> <br>/* <br> * This is the DLL init routine called by the system at attach/detatch time. <br> * <br> * We allocate a Tls for each thread that calls this DLL so that their state <br> * can be tracked independently. <br> */ <br>BOOLEAN APIENTRY DllMain( <br>IN PVOID hmod, <br>ULONG Reason, <br>IN PCONTEXT pctx OPTIONAL) <br>{ <br>    THREADINFO *pti; <br>    UNREFERENCED_PARAMETER(hmod); <br>    UNREFERENCED_PARAMETER(pctx); <br> <br>    switch (Reason) { <br>    case DLL_PROCESS_ATTACH: <br>        TlsIndex = TlsAlloc(); <br> <br>    case DLL_THREAD_ATTACH: <br>        pti = (THREADINFO *)LocalAlloc(LPTR, sizeof(THREADINFO)); <br>        if (!pti) { <br>            return(FALSE); <br>        } <br>        TlsSetValue(TlsIndex, pti); <br>        break; <br> <br>    case DLL_THREAD_DETACH: <br>    case DLL_PROCESS_DETACH: <br>        pti = TlsGetValue(TlsIndex); <br>        LocalFree(pti); <br>        if (Reason == DLL_PROCESS_DETACH) { <br>            TlsFree(TlsIndex); <br>        } <br>        break; <br>    } <br>    return TRUE; <br>} <br> <br>/* <br> * An application must call this API first to establish a conversation <br> * with progman.  DDEML initialization is done automatically if needed. <br> */ <br>BOOL ConnectToProgmanA() <br>{ <br>    THREADINFO *pti; <br>    HSZ hszProgman; <br> <br>    pti = TlsGetValue(TlsIndex); <br> <br>    if (!pti-&gt;idInst) { <br>        if (DdeInitializeA(&amp;(pti-&gt;idInst), ProgHelpDdeCallback, <br>                APPCMD_CLIENTONLY | CBF_SKIP_ALLNOTIFICATIONS, <br>                0L) != DMLERR_NO_ERROR) { <br>            return(FALSE); <br>        } <br>    } <br> <br>    if (pti-&gt;hConv == 0) { <br>        hszProgman = DdeCreateStringHandleA(pti-&gt;idInst, "Progman", 0); <br>        pti-&gt;hConv = DdeConnect(pti-&gt;idInst, hszProgman, hszProgman, NULL); <br>    } <br>    return(pti-&gt;hConv != 0); <br>} <br> <br> <br> <br>BOOL ConnectToProgmanW() <br>{ <br>    THREADINFO *pti; <br>    HSZ hszProgman; <br> <br>    pti = TlsGetValue(TlsIndex); <br> <br>    if (!pti-&gt;idInst) { <br>        if (DdeInitializeW(&amp;(pti-&gt;idInst), ProgHelpDdeCallback, <br>                APPCMD_CLIENTONLY | CBF_SKIP_ALLNOTIFICATIONS, <br>                0L) != DMLERR_NO_ERROR) { <br>            return(FALSE); <br>        } <br>    } <br> <br>    if (pti-&gt;hConv == 0) { <br>        hszProgman = DdeCreateStringHandleA(pti-&gt;idInst, "Progman", 0); <br>        pti-&gt;hConv = DdeConnect(pti-&gt;idInst, hszProgman, hszProgman, NULL); <br>    } <br>    return(pti-&gt;hConv != 0); <br>} <br> <br> <br> <br>/* <br> * This API should be called when operations with progman are complete. <br> * We shutdown DDEML here as well so we don't have to deal with it <br> * at DLL detatch time. <br> */ <br>BOOL DisconnectFromProgman() <br>{ <br>    THREADINFO *pti; <br> <br>    pti = TlsGetValue(TlsIndex); <br> <br>    if (!pti-&gt;idInst) { <br>        return(TRUE); <br>    } <br> <br>    if (pti-&gt;hConv) { <br>        DdeDisconnect(pti-&gt;hConv); <br>        pti-&gt;hConv = 0; <br>    } <br> <br>    DdeUninitialize(pti-&gt;idInst); <br>    pti-&gt;idInst = 0; <br>    return(TRUE); <br>} <br> <br> <br>/* <br> * This API sends an ASCII execute string to progman.  It immediately returns <br> * and the results of the execute are not known.  Calling applications should <br> * be aware that these transactions are done asynchronously.  This allows <br> * this API to work under modal-loop conditions.  DisconnectFromProgman() <br> * will not succeed until all transactions are complete. <br> */ <br>BOOL ProgmanExecuteStringA( <br>LPSTR pszExec) <br>{ <br>    THREADINFO *pti; <br>    DWORD dwResult; <br> <br>    pti = TlsGetValue(TlsIndex); <br> <br>    if (!pti-&gt;idInst || !pti-&gt;hConv) { <br>        return(FALSE); <br>    } <br>    if (!DdeClientTransaction((PBYTE)pszExec, strlen(pszExec) + 1, <br>            pti-&gt;hConv, 0, 0, XTYP_EXECUTE, TIMEOUT_ASYNC, &amp;dwResult)) { <br>        return(FALSE); <br>    } <br>    return(TRUE); <br>} <br> <br> <br> <br>BOOL ProgmanExecuteStringW( <br>LPWSTR pszExec) <br>{ <br>    THREADINFO *pti; <br>    DWORD dwResult; <br> <br>    pti = TlsGetValue(TlsIndex); <br> <br>    if (!pti-&gt;idInst || !pti-&gt;hConv) { <br>        return(FALSE); <br>    } <br>    if (!DdeClientTransaction((PBYTE)pszExec, <br>            (wcslen(pszExec) + 1)  * sizeof(WCHAR), <br>            pti-&gt;hConv, 0, 0, XTYP_EXECUTE, TIMEOUT_ASYNC, &amp;dwResult)) { <br>        return(FALSE); <br>    } <br>    return(TRUE); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
