<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DDEINST.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6035"></a>DDEINST.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples.  <br>*       Copyright 1993 - 1998 Microsoft Corporation. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>/* <br>   ddeinst.c <br>*/ <br> <br>#include &lt;windows.h&gt; <br>#include "ddeinst.h" <br>#include "ddextrn.h" <br> <br>#include &lt;stdio.h&gt; <br>#include &lt;string.h&gt; <br> <br>extern CONVCONTEXT CCFilter; <br> <br>/******************************************************************** <br> <br>   StartTraverseThread <br> <br>   Function that starts thread to traverse the specified directory. <br> <br>********************************************************************/ <br>BOOL StartTraverseThread (LPSTR lpArg) { <br>   HANDLE   hThread; <br>   LONG     lThreadId; <br> <br>   hThread = CreateThread (NULL, 0, (LPTHREAD_START_ROUTINE) TraversePath, <br>      lpArg, CREATE_SUSPENDED | STANDARD_RIGHTS_REQUIRED, &amp;lThreadId); <br>   if (hThread) { <br>      // SetThreadPriority (hThread, THREAD_PRIORITY_BELOW_NORMAL); <br>      ResumeThread(hThread); <br> <br>/* Close the handle since we don't need it anymore */ <br> <br>      CloseHandle (hThread); <br>      return (TRUE); <br>   }/*endIf*/ <br>   return (FALSE); <br>}/* end StartTraverseThread */ <br> <br> <br>int   iRecurse = 0; <br> <br>/******************************************************************** <br> <br>   TraversePath <br> <br>   Function that recursively descends a specified directory looking <br>   for files that have the .exe extension. <br> <br>********************************************************************/ <br> <br>BOOL TraversePath (LPSTR szPath) { <br>   HANDLE            hSearch; <br>   WIN32_FIND_DATA   findData; <br>   LPSTR             szTemp; <br>   LPSTR             szNewPath; <br>   LPSTR             szTempName; <br>   LPSTR             szFullPath; <br>   int               iLen; <br>   long              lError; <br>   long              lPos; <br>   long              lTemp; <br>   long              lNewPath; <br> <br>// If there is no path then we need to exit. <br>   if (!szPath || (strlen (szPath) &gt; (MAX_PATH - 5))) { <br>      return (FALSE); <br>   }/*endIf*/ <br> <br>// Increment the recursion level. <br>   iRecurse++; <br> <br>// Get the length of the path plus room for the wildcard and nul. <br>   lTemp = strlen (szPath) + 5; <br> <br>// allocate some memory <br>   szTemp = VirtualAlloc (NULL, lTemp, MEM_COMMIT, PAGE_READWRITE); <br> <br>// Append the wildcard <br>   sprintf (szTemp, "%s\\*.*", szPath); <br> <br>// Look for a file <br>   hSearch = FindFirstFile (szTemp, &amp;findData); <br> <br>// If nothing found then return. <br>   if (!hSearch || hSearch == (HANDLE) -1) { <br>      VirtualFree (szTemp, lTemp, MEM_DECOMMIT); <br>      iRecurse--; <br>      return (FALSE); <br>   }/*endIf*/ <br> <br>// Loop through the current directory looking for exectuables. <br>   do { <br>      if (strcmp (findData.cFileName, ".") &amp;&amp; <br>            strcmp (findData.cFileName, "..")) { <br> <br>      // Ignore '.' and '..' <br>         if (findData.dwFileAttributes &amp; FILE_ATTRIBUTE_DIRECTORY) { <br> <br>         // If it is a directory then recurse. <br> <br>            lNewPath = strlen (szPath) + strlen (findData.cFileName) + 1; <br>            szNewPath = VirtualAlloc (NULL, lNewPath, MEM_COMMIT, <br>                  PAGE_READWRITE); <br>            sprintf (szNewPath, "%s\\%s", szPath, findData.cFileName); <br>            TraversePath (szNewPath); <br>            VirtualFree (szNewPath, lNewPath, MEM_DECOMMIT); <br>         } else { <br> <br>         // See if it ends in .exe <br> <br>            iLen = strlen (findData.cFileName) - 4; <br>            szTempName = findData.cFileName + iLen; <br>            if (!strnicmp (szTempName, ".exe", 4)) { <br> <br>            // Add the file name to the list of files. <br> <br>               if (!(lPos = SendMessage (hwndFileList, LB_ADDSTRING, <br>                  (WPARAM) NULL, (LPARAM) findData.cFileName))) { <br> <br>               // Debugging code <br> <br>                  lError = GetLastError (); <br>               }/*endIf*/ <br>               szTempName = VirtualAlloc (NULL, iLen + 4, MEM_COMMIT, <br>                     PAGE_READWRITE); <br>               strncpy (szTempName, findData.cFileName, iLen); <br> <br>            // Add the constructed file name to the list of names <br> <br>               SendMessage (hwndFileList2, LB_INSERTSTRING, (WPARAM) lPos, <br>                     (LPARAM) szTempName); <br>               VirtualFree (szTempName, iLen + 4, MEM_DECOMMIT); <br>               iLen = strlen (szPath) + iLen + 4; <br> <br>            // Construct a full pathname to the file. <br> <br>               szFullPath = VirtualAlloc (NULL, iLen, MEM_COMMIT, <br>                     PAGE_READWRITE); <br>               sprintf (szFullPath, "%s\\%s", szPath, findData.cFileName); <br> <br>            // Add the full path to the hidden list. <br> <br>               SendMessage (hwndPathList, LB_INSERTSTRING, (WPARAM) lPos, <br>                     (LPARAM) szFullPath); <br>               VirtualFree (szFullPath, iLen, MEM_DECOMMIT); <br>            }/*endIf*/ <br>         }/*endIf*/ <br>      }/*endIf*/ <br> <br>   // Keep looping until no more files. <br> <br>   } while (FindNextFile (hSearch, &amp;findData)); <br> <br>// End the search. <br> <br>   FindClose (hSearch); <br>   VirtualFree (szTemp, lTemp, MEM_DECOMMIT); <br> <br>// Decrement the recursion count. <br> <br>   iRecurse--; <br>   if (!iRecurse) { <br> <br>   // If recursion count == 0 then we are done so inform the primary thread. <br> <br>      PostMessage (ghwndMain, WM_USER_THREAD_DONE, 0, 0L); <br>   }/*endIf*/ <br>   return (TRUE); <br>}/* end TraversePath */ <br> <br>/******************************************************************** <br> <br>   StartGroupRetrievalThread <br> <br>   Function that starts thread to retrieve the names of existing groups <br>   from the Program Manager. <br> <br>********************************************************************/ <br> <br> <br>BOOL StartGroupRetrievalThread () { <br>   HANDLE   hThread; <br>   LONG     lThreadId; <br> <br>   hThread = CreateThread (NULL, 0, (LPTHREAD_START_ROUTINE) GroupRetrieval, <br>      "test", CREATE_SUSPENDED | STANDARD_RIGHTS_REQUIRED, &amp;lThreadId); <br>   if (hThread) { <br>      SetThreadPriority (hThread, THREAD_PRIORITY_BELOW_NORMAL); <br>      ResumeThread (hThread); <br> <br>/* Close the handle since we don't need it anymore */ <br> <br>      CloseHandle (hThread); <br>      return (TRUE); <br>   }/*endIf*/ <br>   return (FALSE); <br>}/* end StartGroupRetrievalThread */ <br> <br> <br>// Prototype for DDECallback function. <br>HDDEDATA CALLBACK GroupDDECallback (UINT, UINT, HANDLE, HSZ, HSZ, HDDEDATA, <br>      LONG, LONG); <br> <br> <br>/******************************************************************** <br> <br>   GroupRetrieval <br>   Function to obtain the names of all of the defined program groups in <br>   the Program Manager. <br> <br>********************************************************************/ <br> <br>BOOL GroupRetrieval (LPSTR lpDummy) { <br>   LPBYTE     lpByte; <br>   LPSTR      szGroups; <br>   LPSTR      szToken; <br>   LPSTR      szMem; <br>   LPSTR      szToken2; <br>   long       lResult; <br>   LONG       lIdLocal; <br>   CRITICAL_SECTION lpCritical; <br>   HCONV      hConv; <br>   HDDEDATA   hDdeData; <br>   HSZ        szProgMan; <br>   HSZ        szTopic; <br> <br> <br>// Initialize the Dde id to 0 <br> <br>   lIdLocal = 0L; <br>   szGroups = NULL; <br> <br>// Attempt to initialize a conversation. <br> <br>   if (DdeInitialize (&amp;lIdLocal, (PFNCALLBACK) GroupDDECallback, <br>         (DWORD) APPCMD_CLIENTONLY, 0L)) {  <br>      return (FALSE); <br>   }/*endIf*/ <br> <br>// Start a critical section. This fixes a problem where the DDEML <br>// Can hang under threaded conditions. <br> <br>   InitializeCriticalSection (&amp;lpCritical); <br>   EnterCriticalSection (&amp;lpCritical); <br> <br>// Create a string handle for the Dde conversation. <br> <br>   szProgMan = DdeCreateStringHandle (lIdLocal, "PROGMAN", CP_WINANSI); <br>    <br>// Connect to the program manager. <br> <br>   hConv = DdeConnect (lIdLocal, szProgMan, szProgMan, &amp;CCFilter); <br> <br>   PostMessage (hwndStatus, WM_USER_UPDATE_STATUS, 0, ID_DDEML_CONNECT); <br> <br>// Create a handle for the Group topic. <br> <br>   szTopic = DdeCreateStringHandle (lIdLocal, "Groups", CP_WINANSI); <br> <br>// Execute a request for the group names. <br> <br>   hDdeData = DdeClientTransaction (NULL, 0L, hConv, szTopic, CF_TEXT, <br>         XTYP_REQUEST, 1000, &amp;lResult); <br> <br>   PostMessage (hwndStatus, WM_USER_UPDATE_STATUS, 0, ID_DDEML_RETRIEVING); <br>// Release the two string handles. <br> <br>   DdeFreeStringHandle (lIdLocal, szProgMan); <br>   DdeFreeStringHandle (lIdLocal, szTopic); <br> <br>// Disconnect the conversation. <br> <br>   DdeDisconnect (hConv); <br> <br>   PostMessage (hwndStatus, WM_USER_UPDATE_STATUS, 0, ID_DDEML_COMPLETE); <br> <br>// Exit and delete the critical section. <br> <br>   LeaveCriticalSection (&amp;lpCritical); <br>   DeleteCriticalSection (&amp;lpCritical); <br> <br>// Verify that we got something back. <br> <br>   if (hDdeData &amp;&amp; (hDdeData != (HDDEDATA) TRUE)) { <br> <br>   // Access the data to get a character pointer. <br> <br>      lpByte = DdeAccessData (hDdeData, &amp;lResult); <br> <br>   // allocate a block of memory to use. <br> <br>      szGroups = szMem = VirtualAlloc (NULL, lResult, MEM_COMMIT, <br>         PAGE_READWRITE); <br>      if (!szMem) { <br>         lResult = GetLastError (); <br>      } else { <br> <br>      // Copy the Dde data to our own block. <br> <br>         memcpy (szGroups, lpByte, lResult); <br>      }/*endIf*/ <br> <br>   // Free the Dde data that is there. This is our responsibility. <br> <br>      DdeUnaccessData (hDdeData); <br>      DdeFreeDataHandle (hDdeData); <br>   }/*endIf*/ <br> <br>// If we have a memory block then parse it. <br> <br>   if (szMem != NULL) { <br> <br>   // Search for 'cr'. <br> <br>      szToken = strtok (szGroups, "\n"); <br> <br>   // While we have a token use it. <br> <br>      while (szToken) { <br> <br>      // We have to strip out line feeds. <br> <br>         if (szToken2 = strrchr (szToken, 0x0d)) { <br>            *szToken2 = '\0'; <br>         }/*endIf*/ <br>       <br>      // Add the resulting string to the combo box of groups. <br> <br>         SendMessage (hwndCombo, CB_ADDSTRING, (WPARAM) 0, (LPARAM) szToken); <br> <br>      // Find the next 'cr'. <br> <br>         szToken = strtok (NULL, "\n"); <br>      }/*endWhile*/ <br> <br>   // Release the memory block. <br> <br>      VirtualFree (szMem, lResult, MEM_DECOMMIT); <br>   }/*endIf*/ <br> <br>// If there is a default name defined then use it. And enable the AddGroup <br>// Button. <br> <br>   if (strlen (szUserGroup)) { <br>      SetWindowText (hwndCombo, szUserGroup); <br>      EnableWindow (hwndAddGroupButton, TRUE); <br>   } else { <br> <br>   // There is no default group so disable the button. <br> <br>      EnableWindow (hwndAddGroupButton, FALSE); <br>   }/*endIf*/ <br> <br>// Release the DDEML. <br> <br>   DdeUninitialize (lIdLocal); <br> <br>// Inform the primary thread that the group retrieval is completed. <br> <br>   PostMessage (ghwndMain, WM_USER_THREAD_DONE, 0, 0L); <br>   return (TRUE); <br>}/* end GroupRetrieval */ <br> <br> <br>/******************************************************************** <br> <br>   GroupDDECallback. <br>    <br>   Function exists for compatibility. Does nothing. <br> <br>********************************************************************/ <br> <br>HDDEDATA CALLBACK GroupDDECallback (UINT uiType, UINT uiFmt, HANDLE hConv, <br>      HSZ sz1, HSZ sz2, HDDEDATA hData, LONG lData1, LONG lData2) { <br>   switch (uiType) { <br> <br>   }/*endSwitch*/ <br>   return ((HDDEDATA) NULL); <br>}/* end GroupDDECallback */ </code></pre>
<p>&nbsp;</p></body>
</HTML>
