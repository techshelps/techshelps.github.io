<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DDEMO.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6042"></a>DDEMO.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples.  <br>*       Copyright 1993 - 1998 Microsoft Corporation. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>/*****************************************************************************\ <br>* <br>* DDEMO.C <br>* <br>* This file implements a simple DDEML sample application that demonstrates <br>* some of the ways the DDEML APIs can be used. <br>* <br>* Each instance of this application becomes both a DDE client and a DDE <br>* server with any other instances of this application that are found. <br>* <br>* Since it assumes it is talking to itself, this program takes some liberties <br>* to simplify things.  For instance, this application does not support the <br>* standard SysTopic topic and does not use any standard formats. <br>* <br>* The basic concepts this application will show you are: <br>* <br>*   How to use lists of conversations properly <br>*   How to handle links <br>*   How to handle simple asynchronous transactions <br>*   How to use your own custom formats <br>* <br>\*****************************************************************************/ <br>#include &lt;windows.h&gt; <br>#include &lt;ddeml.h&gt; <br>//#ifdef UNICODE <br>//#include &lt;wchar.h&gt; <br>//#endif // UNICODE <br>#include &lt;stdlib.h&gt; <br>#include &lt;string.h&gt; <br> <br>#ifdef UNICODE <br>#define STRICMP wcsicmp <br>#define ITOA(c, sz, b) (itoa(sizeof(szA), szA, b), mbstowcs(sz, szA, b), sz) <br>#else <br>#define STRICMP stricmp <br>#define ITOA itoa <br>#endif  // UNICODE <br> <br>HDDEDATA CALLBACK DdeCallback(WORD wType, WORD wFmt, HCONV hConv, HSZ hszTopic, <br>        HSZ hszItem, HDDEDATA hData, DWORD lData1, DWORD lData2); <br>VOID PaintDemo(HWND hwnd); <br>LONG  APIENTRY MainWndProc(HWND hwnd, UINT message, WPARAM wParam, <br>        LONG lParam); <br>VOID BroadcastTransaction(PBYTE pSrc,DWORD cbData,UINT fmt,UINT xtyp); <br> <br>/* <br> * Define this value to limit how fast data changes.  If we just let data <br> * change as fast a possible, we might bog down the system with DDE <br> * messages. <br> */ <br>#define BASE_TIMEOUT 100 <br> <br>BOOL        fActive;                    // indicates data is changing <br>DWORD       idInst = 0;                 // our DDEML instance object <br>HANDLE      hInst;                      // our instance/module handle <br>HCONVLIST   hConvList = 0;              // the list of all convs we have open <br>HSZ         hszAppName = 0;             // the generic hsz for everything <br>HWND        hwndMain;                   // our main window handle <br>TCHAR       szT[20];                    // static buffer for painting <br>#ifdef UNICODE <br>CHAR        szA[20];                    // static buffer for UNICODE conversion <br>TCHAR       szTitle[] = TEXT("DDEmo (U)"); <br>#else <br>TCHAR       szTitle[] = TEXT("DDEmo"); <br>#endif <br>TCHAR       szApp[] = TEXT("DDEmo");    // DDE service name <br>TCHAR       szPause[] = TEXT("PAUSE");  // DDE Execute command <br>TCHAR       szResume[] = TEXT("RESUME");// DDE Execute command <br>UINT        OurFormat;                  // our custom registered format <br>int         InCount = 0;                // static buffer to hold incomming data <br>int         cConvs = 0;                 // number of active conversations <br>int         count = 0;                  // our data <br>int         cyText, cxText, cyTitle;    // sizes for painting <br> <br>int WINAPI WinMain( <br>HINSTANCE hInstance, <br>HINSTANCE hPrevInstance, <br>LPSTR lpCmdLine, <br>INT nCmdShow) <br>{ <br>    MSG msg; <br>    WNDCLASS  wc; <br>    TEXTMETRIC metrics; <br>    HDC hdc; <br> <br>    wc.style = 0; <br>    wc.lpfnWndProc = MainWndProc; <br>    wc.cbClsExtra = 0; <br>    wc.cbWndExtra = 0; <br>    wc.hInstance = hInstance; <br>    wc.hIcon = NULL; <br>    wc.hCursor = LoadCursor(NULL, IDC_ARROW); <br>    wc.hbrBackground = NULL; <br>    wc.lpszMenuName =  NULL; <br>    wc.lpszClassName = szTitle; <br> <br>    if (!RegisterClass(&amp;wc)) <br>        return(FALSE); <br> <br>    /* <br>     * Here we tell DDEML what we will be doing. <br>     * <br>     * 1) We let it know our callback proc address - MakeProcInstance <br>     *      is called just to be more portable. <br>     * 2) Filter-inits - don't accept any WM_DDE_INITIATE messages for <br>     *      anything but our registered service name. <br>     * 3) Don't bother to notify us of confirmed connections <br>     * 4) Don't allow connections with ourselves. <br>     * 5) Don't bother us with XTYP_POKE transactions. <br>     */ <br>    if (DdeInitialize(&amp;idInst, <br>            (PFNCALLBACK)MakeProcInstance((FARPROC)DdeCallback, hInstance), <br>            APPCMD_FILTERINITS | <br>            CBF_SKIP_CONNECT_CONFIRMS | <br>            CBF_FAIL_SELFCONNECTIONS | <br>            CBF_FAIL_POKES, <br>            0)) <br>        return(FALSE); <br> <br>    hInst = hInstance; <br>    hwndMain = CreateWindow( <br>        szTitle, <br>        szTitle, <br>        WS_CAPTION | WS_BORDER | WS_SYSMENU, <br>        CW_USEDEFAULT, <br>        CW_USEDEFAULT, <br>        0, <br>        0, <br>        NULL, <br>        NULL, <br>        hInstance, <br>        NULL <br>    ); <br> <br>    if (!hwndMain) { <br>        DdeUninitialize(idInst); <br>        return(FALSE); <br>    } <br> <br>    hdc = GetDC(hwndMain); <br>    GetTextMetrics(hdc, &amp;metrics); <br>    cyText = metrics.tmHeight + metrics.tmExternalLeading; <br>    cxText = metrics.tmMaxCharWidth * 8; <br>    cyTitle = GetSystemMetrics(SM_CYCAPTION); <br>    ReleaseDC(hwndMain, hdc); <br> <br>     /* <br>     * Initialize all our string handles for lookups later <br>     */ <br>    hszAppName = DdeCreateStringHandle(idInst, szApp, 0); <br>    /* <br>     * Register our formats <br>     */ <br>    OurFormat = RegisterClipboardFormat(szApp); <br>    /* <br>     * Register our service - <br>     *  This will cause DDEML to notify DDEML clients about the existance <br>     *  of a new DDE service. <br>     */ <br>    DdeNameService(idInst, hszAppName, 0, DNS_REGISTER); <br>    /* <br>     * Connect to any other instances of ourselves that may already be <br>     * running. <br>     */ <br>    hConvList = DdeConnectList(idInst, hszAppName, hszAppName, hConvList, NULL); <br>    BroadcastTransaction(NULL, 0, OurFormat, XTYP_ADVSTART); <br> <br>    SetWindowPos(hwndMain, 0, 0, 0, cxText, <br>                (cyText * (cConvs + 1)) + cyTitle, SWP_NOMOVE | SWP_NOZORDER); <br>    ShowWindow(hwndMain, nCmdShow); <br>    UpdateWindow(hwndMain); <br> <br>    while (GetMessage(&amp;msg, 0, 0, 0)) { <br>        TranslateMessage(&amp;msg); <br>        DispatchMessage(&amp;msg); <br>    } <br> <br>    DestroyWindow(hwndMain); <br>    UnregisterClass(szTitle, hInstance); <br>    return(FALSE); <br>} <br> <br> <br>/* <br> * BroadcastTransaction <br> * <br> * Does the specified transaction on all conversations in hConvList <br> */ <br>VOID BroadcastTransaction( <br>PBYTE pSrc, <br>DWORD cbData, <br>UINT fmt, <br>UINT xtyp) <br>{ <br>    HCONV hConv; <br>    DWORD dwResult; <br>    int cConvsOrg; <br> <br>    cConvsOrg = cConvs; <br>    cConvs = 0; <br>    if (hConvList) { <br>        /* <br>         * Enumerate all the conversations within this list - note that <br>         * DDEML will only return active conversations.  Inactive conversations <br>         * are automatically removed. <br>         */ <br>        hConv = DdeQueryNextServer(hConvList, 0); <br>        while (hConv) { <br>            /* <br>             * Count the active conversations while we're at it. <br>             */ <br>            cConvs++; <br>            /* <br>             * Spawn an asynchronous transaction - this was chosen because <br>             * we have not particular action if an error ocurrs so we just <br>             * don't care too much about the results - this technique will <br>             * NOT do for XTYP_REQUEST transactions though. <br>             */ <br>            if (DdeClientTransaction(pSrc, cbData, hConv, hszAppName, fmt, <br>                    xtyp, TIMEOUT_ASYNC, &amp;dwResult)) { <br>                /* <br>                 * We immediately abandon the transaction so we don't get <br>                 * a bothersome XTYP_XACT_COMPLETE callback which we don't <br>                 * care about. <br>                 */ <br>                DdeAbandonTransaction(idInst, hConv, dwResult); <br>            } <br> <br>            hConv = DdeQueryNextServer(hConvList, hConv); <br>        } <br>    } <br>    if (cConvs != cConvsOrg) { <br>        /* <br>         * Oh, the number of active conversations has changed.  Time to <br>         * repaint! <br>         */ <br>        InvalidateRect(hwndMain, NULL, TRUE); <br>    } <br>} <br> <br> <br>/* <br> * MyProcessKey <br> * <br> * We demonstrate the robustness of NT here by forcing a GP anytime the <br> * 'B' key is pressed while this window has the focus.  NT should properly <br> * fake termination to all other apps connected to us. <br> */ <br>VOID MyProcessKey( <br>TCHAR tchCode, <br>LONG lKeyData) <br>{ <br>    switch (tchCode) { <br>    case TEXT('B'): <br>    case TEXT('b'): <br>        *((PBYTE)(-1)) = 0;    // Cause GP fault! <br>        break; <br>    } <br>} <br> <br> <br> <br>LONG  APIENTRY MainWndProc( <br>HWND hwnd, <br>UINT message, <br>WPARAM wParam, <br>LONG lParam) <br>{ <br>    RECT rc; <br> <br>    switch (message) { <br>    case WM_CREATE: <br>        /* <br>         * initially we are inactive - this reduces some of the message <br>         * traffic while we are initializing - but we could start active fine. <br>         */ <br>        fActive = FALSE; <br>        break; <br> <br>    case WM_RBUTTONDOWN: <br>        if (GetKeyState(VK_CONTROL) &amp; 0x8000) { <br>            /* <br>             * A CTRL R_BUTTON click will cause ALL instances of this app <br>             * to become inactive. <br>             */ <br>            BroadcastTransaction((PBYTE)szPause, sizeof(szPause), 0, XTYP_EXECUTE); <br>            MessageBeep(0); <br>        } <br>        /* <br>         * A R_BUTTON click makes us inactive.  Repaint to show state change. <br>         * We do a synchronous update in case there is too much DDE message <br>         * activity to allow the WM_PAINT messages through.  Remember DDE <br>         * messages have priority over others! <br>         */ <br>        KillTimer(hwndMain, 1); <br>        fActive = FALSE; <br>        InvalidateRect(hwnd, NULL, TRUE); <br>        UpdateWindow(hwnd); <br>        break; <br> <br>    case WM_LBUTTONDOWN: <br>        if (GetKeyState(VK_CONTROL) &amp; 0x8000) { <br>            /* <br>             * A CTRL L_BUTTON click will cause ALL instances of this app <br>             * to become active. <br>             */ <br>            BroadcastTransaction((PBYTE)szResume, sizeof(szResume), 0, XTYP_EXECUTE); <br>            MessageBeep(0); <br>        } <br>        /* <br>         * An L_BUTTON click makes us active.  Repaint to show state change. <br>         */ <br>        SetTimer(hwndMain, 1, BASE_TIMEOUT + (rand() &amp; 0xff), NULL); <br>        fActive = TRUE; <br>        InvalidateRect(hwnd, NULL, TRUE); <br>        UpdateWindow(hwnd); <br>        break; <br> <br>    case WM_CHAR: <br>        MyProcessKey((TCHAR)wParam, lParam); <br>        break; <br> <br>    case WM_TIMER: <br>        /* <br>         * We use timers for simplicity.  On Win3.1 we could run out of <br>         * timers easily but we don't have this worry on NT. <br>         * <br>         * Each tick, we increment our data and call DdePostAdvise() to <br>         * update any links there may be on this data.  DDEML makes link <br>         * updates on specific items quite easy. <br>         */ <br>        count++; <br>        DdePostAdvise(idInst, hszAppName, hszAppName); <br>        /* <br>         * Invalidate the part of ourselves that shows our data and <br>         * synchronously update it in case DDE message activity is blocking <br>         * paints. <br>         */ <br>        SetRect(&amp;rc, 0, 0, cxText, cyText); <br>        InvalidateRect(hwndMain, &amp;rc, TRUE); <br>        UpdateWindow(hwndMain); <br>        break; <br> <br>    case WM_PAINT: <br>        PaintDemo(hwnd); <br>        break; <br> <br>    case WM_CLOSE: <br>        KillTimer(hwnd, 1); <br>        /* <br>         * We do DDE cleanup here.  It is best to do DDE cleanup while <br>         * still in the message loop to allow DDEML to recieve messages <br>         * while shutting down. <br>         */ <br>        DdeDisconnectList(hConvList); <br>        DdeNameService(idInst, 0, 0, DNS_UNREGISTER); <br>        DdeFreeStringHandle(idInst, hszAppName); <br>        DdeUninitialize(idInst); <br>        PostQuitMessage(0); <br>        break; <br> <br>    default: <br>        return (DefWindowProc(hwnd, message, wParam, lParam)); <br>    } <br>    return(0); <br>} <br> <br> <br>VOID PaintDemo( <br>HWND hwnd) <br>{ <br>    PAINTSTRUCT ps; <br>    RECT rc; <br>    HCONV hConv; <br>    CONVINFO ci; <br>    int cConvsOrg = cConvs; <br> <br>    BeginPaint(hwnd, &amp;ps); <br>    /* <br>     * Draw our data on top - Black for active, Grey for inactive. <br>     */ <br>    SetRect(&amp;rc, 0, 0, cxText, cyText); <br>    SetBkMode(ps.hdc, TRANSPARENT); <br>    SetTextColor(ps.hdc, 0x00FFFFFF);   // white text <br>    FillRect(ps.hdc, &amp;rc, GetStockObject(fActive ? BLACK_BRUSH : GRAY_BRUSH)); <br>    DrawText(ps.hdc, ITOA(count, szT, 10), -1, &amp;rc, DT_CENTER | DT_VCENTER); <br> <br>    /* <br>     * Now draw the most recently recieved data from each server we are <br>     * connected to. <br>     */ <br>    if (hConvList) { <br>        OffsetRect(&amp;rc, 0, cyText); <br>        SetTextColor(ps.hdc, 0);    // draw black text <br>        cConvs = 0; <br>        hConv = DdeQueryNextServer(hConvList, 0); <br>        while (hConv) { <br>            cConvs++; <br>            /* <br>             * count how many conversations are active while we're at it. <br>             */ <br>            ci.cb = sizeof(CONVINFO); <br>            DdeQueryConvInfo(hConv, QID_SYNC, &amp;ci); <br>            FillRect(ps.hdc, &amp;rc, GetStockObject(WHITE_BRUSH));  // white bkgnd <br>            DrawText(ps.hdc, ITOA(ci.hUser, szT, 10), -1, &amp;rc, <br>                    DT_CENTER | DT_VCENTER); <br>            OffsetRect(&amp;rc, 0, cyText); <br>            hConv = DdeQueryNextServer(hConvList, hConv); <br>        } <br>    } <br>    EndPaint(hwnd, &amp;ps); <br>    if (cConvsOrg != cConvs) { <br>        /* <br>         * The number of active conversations changed!  Resize to fit. <br>         */ <br>        SetWindowPos(hwndMain, 0, 0, 0, cxText, <br>                (cyText * (cConvs + 1)) + cyTitle, <br>                SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE); <br>    } <br>} <br> <br> <br> <br>/* <br> * This is the main DDEML callback proc.  It handles all interaction with <br> * DDEML that is DDEML originated. <br> */ <br>HDDEDATA CALLBACK DdeCallback( <br>WORD wType, <br>WORD wFmt, <br>HCONV hConv, <br>HSZ hszTopic, <br>HSZ hszItem, <br>HDDEDATA hData, <br>DWORD lData1, <br>DWORD lData2) <br>{ <br>    LPTSTR pszExec; <br> <br>    switch (wType) { <br>    case XTYP_CONNECT: <br>        /* <br>         * Only allow connections to us.  We can always return TRUE because <br>         * the CBF_FILTERINITS bit given to DdeInitialize() told DDEML to <br>         * never bother us with connections to any service names other than <br>         * what we have registered. <br>         * <br>         * Note that we do not handle the XTYP_WILD_CONNECT transaction. <br>         * This means that no wild-card initiates to us will work. <br>         */ <br>        return((HDDEDATA)TRUE); <br> <br>    case XTYP_ADVREQ: <br>    case XTYP_REQUEST: <br>        /* <br>         * These two transactions are the only ones that require us to <br>         * render our data.  By using a custom format, we don't have to <br>         * convert our count to text form to support CF_TEXT. <br>         */ <br>        return(DdeCreateDataHandle(idInst, (PBYTE)&amp;count, sizeof(count), 0, <br>                hszAppName, OurFormat, 0)); <br> <br>    case XTYP_ADVSTART: <br>        /* <br>         * Only allow links to our Item in our format. <br>         */ <br>        return(HDDEDATA) ((UINT)wFmt == OurFormat &amp;&amp; hszItem == hszAppName); <br> <br>    case XTYP_ADVDATA: <br>        /* <br>         * Data is comming in.  We don't bother with XTYP_POKE transactions, <br>         * but if we did, they would go here.  Since we only allow links <br>         * on our item and our format, we need not check these here. <br>         */ <br>        if (DdeGetData(hData, (PBYTE)&amp;InCount, sizeof(InCount), 0)) { <br>            DdeSetUserHandle(hConv, QID_SYNC, InCount); <br>        } <br>        /* <br>         * update ourselves to reflect the new incomming data. <br>         */ <br>        InvalidateRect(hwndMain, NULL, TRUE); <br>        /* <br>         * This transaction requires a flag return value.  We could also <br>         * stick other status bits here if needed but its not recommended. <br>         */ <br>        return((HDDEDATA)DDE_FACK); <br> <br>    case XTYP_EXECUTE: <br>        /* <br>         * Another instance wants us to do something.  DdeAccessData() <br>         * makes parsing of execute strings easy.  Also note, that DDEML <br>         * will automatically give us the string in the right form <br>         * (UNICODE vs ASCII) depending on which form of DdeInitialize() <br>         * we called. <br>         */ <br>        pszExec = (LPTSTR)DdeAccessData(hData, NULL); <br>        if (pszExec) { <br>            if (fActive &amp;&amp; !STRICMP(szPause, pszExec)) { <br>                KillTimer(hwndMain, 1); <br>                fActive = FALSE; <br>                InvalidateRect(hwndMain, NULL, TRUE); <br>                UpdateWindow(hwndMain); <br>            } else if (!fActive &amp;&amp; !STRICMP(szResume, pszExec)) { <br>                SetTimer(hwndMain, 1, BASE_TIMEOUT + (rand() &amp; 0xff), NULL); <br>                fActive = TRUE; <br>                InvalidateRect(hwndMain, NULL, TRUE); <br>                UpdateWindow(hwndMain); <br>            } <br>            /* <br>             * The beep gives good feedback on how fast the execute was. <br>             */ <br>            MessageBeep(0); <br>        } <br>        break; <br> <br>    case XTYP_DISCONNECT: <br>        /* <br>         * Somebody went away, repaint so we update our cConvs count. <br>         */ <br>        InvalidateRect(hwndMain, NULL, TRUE); <br>        break; <br> <br>    case XTYP_REGISTER: <br>        /* <br>         * Since a new server just arrived, lets make sure our links are <br>         * up to date.  Note that only one link on a <br>         * conversation/topic/item/format set will work anyway so we don't <br>         * worry about duplicate links. <br>         * <br>         * Note also that we are using hszItem - which is the InstanceSpecific <br>         * name of the server that is registering.  This greatly reduces the <br>         * number of messages that go flying around. <br>         */ <br>BroadcastTransaction( NULL, 0, OurFormat, XTYP_ADVSTOP ); <br>        hConvList = DdeConnectList(idInst, hszItem, hszAppName, hConvList, NULL); <br>        BroadcastTransaction(NULL, 0, OurFormat, XTYP_ADVSTART); <br>        SetWindowPos(hwndMain, 0, 0, 0, cxText, <br>                (cyText * (cConvs + 1)) + cyTitle, SWP_NOMOVE | SWP_NOZORDER); <br>        UpdateWindow(hwndMain); <br>        return((HDDEDATA)TRUE); <br>    } <br>    return(0); <br>} <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
