<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>INFOCTRL.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6024"></a>INFOCTRL.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples. <br>*       Copyright 1993 - 1998 Microsoft Corporation. <br>*       All rights reserved. <br>*       This source code is only intended as a supplement to <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>/*************************************************************************** <br> *                                                                         * <br> *  MODULE      : infoctrl.c                                               * <br> *                                                                         * <br> *  PURPOSE     : Functions for the infoctrl control class                 * <br> *                                                                         * <br> ***************************************************************************/ <br>/* <br> * INFOCTRL.C <br> * <br> * This module implements a custom information display control which <br> * can present up to 7 seperate strings of information at once and is <br> * sizeable and moveable with the mouse. <br> */ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;string.h&gt; <br>#include &lt;tchar.h&gt; <br>#include &lt;memory.h&gt; <br>#include "infoctrl.h" <br>#include "track.h" <br> <br>TCHAR szClass[] = TEXT("InfoCtrl_class"); <br>DWORD cCreated = 0; <br>TCHAR szNULL[] = TEXT(""); <br>INT cxMargin = 0; <br>INT cyMargin = 0; <br>HBRUSH hFocusBrush; <br> <br> <br>LONG  APIENTRY InfoCtrlWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam); <br>VOID MyDrawText(HDC hdc, LPRECT lprc, PTSTR psz, DWORD wFormat); <br>VOID DrawFocus(HDC hdc, HWND hwnd, DWORD style); <br>INT CountWindows(HWND hwndParent); <br>VOID GetCascadeWindowPos(HWND hwndParent, INT  iWindow, LPRECT lprc); <br> <br> <br>/**************************************************************************** <br> *                                                                          * <br> *  FUNCTION   :                                                            * <br> *                                                                          * <br> *  PURPOSE    :                                                            * <br> *                                                                          * <br> *  RETURNS    :                                                            * <br> *                                                                          * <br> ****************************************************************************/ <br>HWND CreateInfoCtrl( <br>LPTSTR pszCenter,              // NULL is ok. <br>INT x, <br>INT y, <br>INT cx, <br>INT cy, <br>HWND hwndParent, <br>HANDLE hInst, <br>LPTSTR pszUL,                // NULLs here are fine. <br>LPTSTR pszUC, <br>LPTSTR pszUR, <br>LPTSTR pszLL, <br>LPTSTR pszLC, <br>LPTSTR pszLR, <br>DWORD  style, <br>HMENU id, <br>DWORD dwUser) <br>{ <br>    INFOCTRL_DATA *picd; <br>    HWND hwnd; <br> <br>    if (!cCreated) { <br>        WNDCLASS wc; <br>        TEXTMETRIC metrics; <br>        HDC hdc; <br> <br>        wc.style = CS_VREDRAW | CS_HREDRAW; <br>        wc.lpfnWndProc = InfoCtrlWndProc; <br>        wc.cbClsExtra = 0; <br>        wc.cbWndExtra = ICCBWNDEXTRA; <br>        wc.hInstance = hInst; <br>        wc.hIcon = NULL; <br>        wc.hCursor = NULL; <br>        wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1); <br>        wc.lpszMenuName =  NULL; <br>        wc.lpszClassName = szClass; <br> <br>        RegisterClass(&amp;wc); <br> <br>        hdc = GetDC(hwndParent); <br>        GetTextMetrics(hdc, &amp;metrics); <br>        cyMargin = metrics.tmHeight; <br>        cxMargin = metrics.tmAveCharWidth * 2; <br>        ReleaseDC(hwndParent, hdc); <br>        hFocusBrush = CreateSolidBrush(RGB(0, 0, 255)); <br>    } <br> <br>    if (!(picd = (INFOCTRL_DATA *)LocalAlloc(LPTR, sizeof(INFOCTRL_DATA)))) <br>        return(FALSE); <br> <br>    if (pszCenter) { <br>        picd-&gt;pszCenter = (PTSTR)(PTSTR)LocalAlloc(LPTR, <br>                (_tcslen(pszCenter) + 1) * sizeof(TCHAR)); <br>        _tcscpy(picd-&gt;pszCenter, pszCenter); <br>    } else { <br>        picd-&gt;pszCenter = NULL; <br>    } <br> <br>    if (pszUL) { <br>        picd-&gt;pszUL = (PTSTR)(PTSTR)LocalAlloc(LPTR, <br>            (_tcslen(pszUL) + 1) * sizeof(TCHAR)); <br>        _tcscpy(picd-&gt;pszUL, pszUL); <br>    } else { <br>        picd-&gt;pszUL = NULL; <br>    } <br>    if (pszUC) { <br>        picd-&gt;pszUC = (PTSTR)LocalAlloc(LPTR, <br>            (_tcslen(pszUC) + 1) * sizeof(TCHAR)); <br>        _tcscpy(picd-&gt;pszUC, pszUC); <br>    } else { <br>        picd-&gt;pszUC = NULL; <br>    } <br>    if (pszUR) { <br>        picd-&gt;pszUR = (PTSTR)LocalAlloc(LPTR, <br>            (_tcslen(pszUR) + 1) * sizeof(TCHAR)); <br>        _tcscpy(picd-&gt;pszUR, pszUR); <br>    } else { <br>        picd-&gt;pszUR = NULL; <br>    } <br>    if (pszLL) { <br>        picd-&gt;pszLL = (PTSTR)LocalAlloc(LPTR, <br>            (_tcslen(pszLL) + 1) * sizeof(TCHAR)); <br>        _tcscpy(picd-&gt;pszLL, pszLL); <br>    } else { <br>        picd-&gt;pszLL = NULL; <br>    } <br>    if (pszLC) { <br>        picd-&gt;pszLC = (PTSTR)LocalAlloc(LPTR, <br>            (_tcslen(pszLC) + 1) * sizeof(TCHAR)); <br>        _tcscpy(picd-&gt;pszLC, pszLC); <br>    } else { <br>        picd-&gt;pszLC = NULL; <br>    } <br>    if (pszLR) { <br>        picd-&gt;pszLR = (PTSTR)LocalAlloc(LPTR, <br>            (_tcslen(pszLR) + 1) * sizeof(TCHAR)); <br>        _tcscpy(picd-&gt;pszLR, pszLR); <br>    } else { <br>        picd-&gt;pszLR = NULL; <br>    } <br> <br>    picd-&gt;style = style; <br>    picd-&gt;hInst = hInst; <br> <br>    if (hwnd = CreateWindow(szClass, szNULL, <br>            WS_CHILD | WS_VISIBLE | WS_CLIPSIBLINGS, <br>            x, y, cx, cy, hwndParent, id, hInst, (LPTSTR)picd)) { <br>        cCreated++; <br>        SetWindowLong(hwnd, GWL_USER, dwUser); <br>        BringWindowToTop(hwnd); <br>        ShowWindow(hwnd, SW_SHOW); <br>        return(hwnd); <br>    } <br>    return(FALSE); <br>} <br> <br> <br> <br> <br>/**************************************************************************** <br> *                                                                          * <br> *  FUNCTION   : MyDrawText                                                 * <br> *                                                                          * <br> *  PURPOSE    : Draws psz within lprc in hdc according to wFormat.         * <br> *                                                                          * <br> *  RETURNS    : Nothing.                                                   * <br> *                                                                          * <br> ****************************************************************************/ <br>VOID MyDrawText( <br>HDC hdc, <br>LPRECT lprc, <br>PTSTR psz, <br>DWORD wFormat) <br>{ <br>    RECT rc; <br>    DWORD cx; <br> <br>    if (psz == NULL || !*psz) <br>        return; // notin to draw dude. <br> <br>    SetRect(&amp;rc, 0, 0, 1, 0); <br>    DrawText(hdc, psz, -1, &amp;rc, DT_CALCRECT | DT_NOCLIP | DT_SINGLELINE); <br>    cx = min(rc.right - rc.left, lprc-&gt;right - lprc-&gt;left); <br>    CopyRect(&amp;rc, lprc); <br>    switch (wFormat &amp; (DT_LEFT | DT_CENTER | DT_RIGHT)) { <br>    case DT_LEFT: <br>        rc.right = rc.left + cx; <br>        break; <br> <br>    case DT_CENTER: <br>        cx = (rc.right - rc.left - cx) / 2; <br>        rc.right -= cx; <br>        rc.left += cx; <br>        break; <br> <br>    case DT_RIGHT: <br>        rc.left = rc.right - cx; <br>        break; <br>    } <br>    DrawText(hdc, psz, -1, &amp;rc, wFormat | DT_VCENTER); <br>} <br> <br> <br> <br> <br>/**************************************************************************** <br> *                                                                          * <br> *  FUNCTION   : InfoCtrlWndProc                                            * <br> *                                                                          * <br> *  PURPOSE    : Main window proc for info controls                         * <br> *                                                                          * <br> *  RETURNS    : case dependent                                             * <br> *                                                                          * <br> ****************************************************************************/ <br>LONG  APIENTRY InfoCtrlWndProc( <br>HWND hwnd, <br>UINT msg, <br>WPARAM wParam, <br>LPARAM lParam) <br>{ <br>    INFOCTRL_DATA *picd; <br>    INT i; <br>    RECT rc; <br>    HDC hdc; <br> <br>    switch (msg) { <br>    case WM_CREATE: <br>        /* <br>         * Info controls keep their information in the GWL_INFODATA window <br>         * word. <br>         */ <br>        SetWindowLong(hwnd, GWL_INFODATA, <br>                (DWORD)(DWORD)(((LPCREATESTRUCT)lParam)-&gt;lpCreateParams)); <br>        break; <br> <br>    case WM_SIZE: <br>        /* <br>         * size the info control, updating the hittest rectangles. <br>         * The window is only allowed to get so small. <br>         */ <br>        if ((short)LOWORD(lParam) &lt; 2 * cxMargin || (short)HIWORD(lParam) &lt; 2 * cyMargin) { <br>            MoveWindow(hwnd, 0, 0, max((short)LOWORD(lParam), 2 * cxMargin), <br>                max((short)HIWORD(lParam), 2 * cyMargin), TRUE); <br>        } else { <br>            picd = (INFOCTRL_DATA *)GetWindowLong(hwnd, GWL_INFODATA); <br>            SetRect(&amp;picd-&gt;rcFocusUL, 0, 0, cxMargin, cyMargin); <br>            SetRect(&amp;picd-&gt;rcFocusUR, (short)LOWORD(lParam) - cxMargin, 0, <br>                    (short)LOWORD(lParam), cyMargin); <br>            SetRect(&amp;picd-&gt;rcFocusLL, 0, (short)HIWORD(lParam) - cyMargin, <br>                    cxMargin, (INT)HIWORD(lParam)); <br>            SetRect(&amp;picd-&gt;rcFocusLR, picd-&gt;rcFocusUR.left, picd-&gt;rcFocusLL.top, <br>                    picd-&gt;rcFocusUR.right, picd-&gt;rcFocusLL.bottom); <br>        } <br>        break; <br> <br> <br>    case WM_DESTROY: <br>        /* <br>         * Info control death: <br>         * <br>         * Inform out parent - last chance to access GWL_USER. <br>         * Free our information if it still exists. <br>         * Free all strings associated with this control. <br>         */ <br>        { <br>            PTSTR *ppsz; <br> <br>            SendMessage(GetParent(hwnd), ICN_BYEBYE, (WPARAM)hwnd, <br>                    GetWindowLong(hwnd, GWL_USER)); <br>            SetWindowLong(hwnd, GWL_USER, 0); <br> <br>            picd = (INFOCTRL_DATA *)GetWindowLong(hwnd, GWL_INFODATA); <br>            if (picd) { <br>                ppsz = &amp;picd-&gt;pszUL; <br>                for (i = 0; i &lt; 5; i++, ppsz++) { <br>                    if (*ppsz) { <br>                        LocalUnlock((HANDLE)*ppsz); <br>                        *ppsz = (PTSTR)LocalFree((HANDLE)*ppsz); <br>                    } <br>                } <br>                LocalUnlock((HANDLE)picd); <br>                LocalFree((HANDLE)picd); <br>                SetWindowLong(hwnd, GWL_INFODATA, 0); <br>            } <br>        } <br>        break; <br> <br>    case WM_SETFOCUS: <br>    case WM_KILLFOCUS: <br>        /* <br>         * When focus changes: <br>         * <br>         * Alter our look apropriately <br>         * Bring ourselves to the top if necessary. <br>         * Inform our parent. <br>         * Repaint the focus portion of ourselves. <br>         * Call DefWindowProc() <br>         */ <br>        picd = (INFOCTRL_DATA *)GetWindowLong(hwnd, GWL_INFODATA); <br>        if (picd != NULL) { <br>            if (picd-&gt;style &amp; ICSTY_SHOWFOCUS) { <br>                if (msg == WM_SETFOCUS) <br>                    picd-&gt;style |= ICSTY_HASFOCUS; <br>                else <br>                    picd-&gt;style &amp;= ~ICSTY_HASFOCUS; <br>                BringWindowToTop(hwnd); <br>                // notify parent <br>                SendMessage(GetParent(hwnd), ICN_HASFOCUS, <br>                        msg == WM_SETFOCUS, (LPARAM)hwnd); <br>            } else { <br>                picd-&gt;style &amp;= ~ICSTY_HASFOCUS; <br>            } <br>            hdc = GetDC(hwnd); <br>            DrawFocus(hdc, hwnd, picd-&gt;style); <br>            ReleaseDC(hwnd, hdc); <br>        } <br>        goto DoDWP; <br>        break; <br> <br>    case WM_MOUSEMOVE: <br>        /* <br>         * Keep the cursor updated to show sizing or moving state. <br>         */ <br>        { <br>            LPTSTR cursor; <br> <br>            picd = (INFOCTRL_DATA *)GetWindowLong(hwnd, GWL_INFODATA); <br>            if (picd-&gt;style &amp; ICSTY_SHOWFOCUS) { <br> <br>                if ((INT)HIWORD(lParam) &lt; cyMargin) { <br>                    if ((short)LOWORD(lParam) &lt; cxMargin) { <br>                        cursor = IDC_SIZENWSE; <br>                    } else if ((short)LOWORD(lParam) &gt; picd-&gt;rcFocusUR.left) { <br>                        cursor = IDC_SIZENESW; <br>                    } else { <br>                        cursor = IDC_SIZENS; <br>                    } <br>                } else if ((INT)HIWORD(lParam) &gt; picd-&gt;rcFocusLL.top) { <br>                    if ((short)LOWORD(lParam) &lt; cxMargin) { <br>                        cursor = IDC_SIZENESW; <br>                    } else if ((short)LOWORD(lParam) &gt; picd-&gt;rcFocusUR.left) { <br>                        cursor = IDC_SIZENWSE; <br>                    } else { <br>                        cursor = IDC_SIZENS; <br>                    } <br>                } else { <br>                    if ((short)LOWORD(lParam) &lt; cxMargin) { <br>                        cursor = IDC_SIZEWE; <br>                    } else if ((short)LOWORD(lParam) &gt; picd-&gt;rcFocusUR.left) { <br>                        cursor = IDC_SIZEWE; <br>                    } else { <br>                        cursor = IDC_CROSS; <br>                    } <br>                } <br>            } else { <br>                cursor = IDC_ARROW; <br>            } <br>            SetCursor(LoadCursor(NULL, cursor)); <br>        } <br>        break; <br> <br>    case WM_LBUTTONDOWN: <br>        /* <br>         * Track window according do mouse location. <br>         */ <br>        picd = (INFOCTRL_DATA *)GetWindowLong(hwnd, GWL_INFODATA); <br>        if (picd-&gt;style &amp; ICSTY_SHOWFOCUS) { <br>            DWORD fs = 0; <br> <br>            if (!(picd-&gt;style &amp; ICSTY_HASFOCUS)) { <br>                SetFocus(hwnd); <br>            } <br> <br>            if ((short)HIWORD(lParam) &lt; cyMargin) { <br>                fs = TF_TOP; <br>            } else if ((INT)HIWORD(lParam) &gt; picd-&gt;rcFocusLL.top) { <br>                fs = TF_BOTTOM; <br>            } <br>            if ((short)LOWORD(lParam) &lt; cxMargin) { <br>                fs |= TF_LEFT; <br>            } else if ((short)LOWORD(lParam) &gt; picd-&gt;rcFocusUR.left) { <br>                fs |= TF_RIGHT; <br>            } else if (fs == 0) { <br>                fs = TF_MOVE; <br>            } <br> <br>            GetClientRect(hwnd, &amp;rc); <br>            ClientToScreen(hwnd, (LPPOINT)&amp;rc.left); <br>            ClientToScreen(hwnd, (LPPOINT)&amp;rc.right); <br>            ScreenToClient(GetParent(hwnd), (LPPOINT)&amp;rc.left); <br>            ScreenToClient(GetParent(hwnd), (LPPOINT)&amp;rc.right); <br>            if (TrackRect(picd-&gt;hInst, GetParent(hwnd), <br>                    rc.left, rc.top, rc.right, rc.bottom, <br>                    2 * cxMargin, 2 * cyMargin, <br>                    fs | TF_ALLINBOUNDARY, &amp;rc)) { <br> <br>                MoveWindow(hwnd, rc.left, rc.top, rc.right - rc.left, <br>                        rc.bottom - rc.top, TRUE); <br>            } <br>        } <br>        break; <br> <br>    case ICM_SETSTRING: <br>        /* <br>         * This message is sent when a info control string value is changeing. <br>         * <br>         * wParam = ICSID_ constant <br>         * lParam = new string. <br>         * <br>         * If new string is different from old, free old and allocate space <br>         * for new one and copy in. <br>         * Redraw invalidated part of info control. <br>         */ <br>        { <br>            PTSTR *ppsz; <br> <br>            picd = (INFOCTRL_DATA *)GetWindowLong(hwnd, GWL_INFODATA); <br>            ppsz = (PTSTR *)&amp;picd-&gt;pszUL + wParam; <br> <br>            if (lParam == 0) <br>                lParam = (DWORD)(LPTSTR)szNULL; <br> <br>            if (*ppsz) { <br>                if (!_tcscmp(*ppsz, (LPTSTR)lParam)) { <br>                    return 0; <br>                } <br>                LocalUnlock((HANDLE)*ppsz); <br>                *ppsz = (PTSTR)LocalFree((HANDLE)*ppsz); <br>            } <br>            if (lParam) { <br>                *ppsz = (PTSTR)LocalAlloc(LPTR, <br>                    (_tcslen((LPTSTR)lParam) + 1) * sizeof(TCHAR)); <br>                _tcscpy((LPTSTR)*ppsz, (LPTSTR)lParam); <br>            } <br>            GetClientRect(hwnd, &amp;rc); <br>            switch (wParam) { <br>            case ICSID_UL: <br>            case ICSID_UC: <br>            case ICSID_UR: <br>                rc.bottom = cyMargin; <br>                break; <br> <br>            case ICSID_LL: <br>            case ICSID_LC: <br>            case ICSID_LR: <br>                rc.top = rc.bottom - cyMargin; <br>                break; <br> <br>            case ICSID_CENTER: <br>                InflateRect(&amp;rc, -cxMargin, -cyMargin); <br>                break; <br>            } <br>            InvalidateRect(hwnd, &amp;rc, TRUE); <br>            UpdateWindow(hwnd); <br>        } <br>        break; <br> <br>    case WM_PAINT: <br>        /* <br>         * Paint ourselves. <br>         * <br>         * Draw frame. <br>         * Draw info strings. <br>         * Send ownerdraw message to parent if ICSTY_OWNERDRAW. <br>         */ <br>        { <br>            PAINTSTRUCT ps; <br>            HANDLE brush; <br> <br>            picd = (INFOCTRL_DATA *)GetWindowLong(hwnd, GWL_INFODATA); <br>            BeginPaint(hwnd, &amp;ps); <br>            // erasure should have already been done for us. <br>            GetClientRect(hwnd, &amp;rc); <br>            brush = GetStockObject(BLACK_BRUSH); <br>            InflateRect(&amp;rc, -cxMargin / 2, -cyMargin / 2); <br>            FrameRect(ps.hdc, &amp;rc, brush); <br>            InflateRect(&amp;rc, cxMargin / 2, cyMargin / 2); <br>            SetRect(&amp;rc, picd-&gt;rcFocusUL.right, 0, picd-&gt;rcFocusUR.left, <br>                    cyMargin); <br>            MyDrawText(ps.hdc, &amp;rc, picd-&gt;pszUR, DT_RIGHT); <br>            MyDrawText(ps.hdc, &amp;rc, picd-&gt;pszUL, DT_LEFT); <br>            MyDrawText(ps.hdc, &amp;rc, picd-&gt;pszUC, DT_CENTER); <br>            SetRect(&amp;rc, picd-&gt;rcFocusLL.right, picd-&gt;rcFocusLL.top, <br>                    picd-&gt;rcFocusLR.left, picd-&gt;rcFocusLR.bottom); <br>            MyDrawText(ps.hdc, &amp;rc, picd-&gt;pszLR, DT_RIGHT); <br>            MyDrawText(ps.hdc, &amp;rc, picd-&gt;pszLL, DT_LEFT); <br>            MyDrawText(ps.hdc, &amp;rc, picd-&gt;pszLC, DT_CENTER); <br> <br>            GetClientRect(hwnd, &amp;rc); <br>            InflateRect(&amp;rc, -cxMargin, -cyMargin); <br>            if (picd-&gt;style &amp; ICSTY_OWNERDRAW) { <br>                OWNERDRAWPS odps; <br> <br>                if (IntersectRect(&amp;odps.rcPaint, &amp;rc, &amp;ps.rcPaint)) { <br>                    if (IntersectClipRect(ps.hdc, rc.left, rc.top, rc.right, <br>                            rc.bottom) != NULLREGION) { <br>                        odps.rcBound = rc; <br>                        odps.hdc = ps.hdc; <br>                        odps.dwUser = GetWindowLong(hwnd, GWL_USER); <br>                        SendMessage(GetParent(hwnd), ICN_OWNERDRAW, <br>                                GetWindowLong(hwnd, GWL_ID), (DWORD)(LPTSTR)&amp;odps); <br>                    } <br>                } <br>            } else { <br>                MyDrawText(ps.hdc, &amp;rc, picd-&gt;pszCenter, DT_LEFT | DT_WORDBREAK | DT_EXPANDTABS); <br>            } <br>            DrawFocus(ps.hdc, hwnd, picd-&gt;style); <br>            EndPaint(hwnd, &amp;ps); <br>        } <br>        break; <br> <br>DoDWP: <br>    default: <br>        return (DefWindowProc(hwnd, msg, wParam, lParam)); <br>    } <br>    return (0); <br>} <br> <br> <br>/**************************************************************************** <br> *                                                                          * <br> *  FUNCTION   : DrawFocus                                                  * <br> *                                                                          * <br> *  PURPOSE    : To draw focus part of info control.                        * <br> *                                                                          * <br> *  RETURNS    : nothing                                                    * <br> *                                                                          * <br> ****************************************************************************/ <br>VOID DrawFocus( <br>HDC hdc, <br>HWND hwnd, <br>DWORD style) <br>{ <br>    RECT rc; <br> <br>    GetClientRect(hwnd, &amp;rc); <br>    FrameRect(hdc, &amp;rc, style &amp; ICSTY_HASFOCUS ? <br>            hFocusBrush : GetStockObject(GRAY_BRUSH)); <br>} <br> <br> <br> <br> <br>/**************************************************************************** <br> *                                                                          * <br> *  FUNCTION   : CountWindows                                               * <br> *                                                                          * <br> *  PURPOSE    : Counts how many info controls the parent of this window has* <br> *                                                                          * <br> *  RETURNS    : the count.                                                 * <br> *                                                                          * <br> ****************************************************************************/ <br>INT CountWindows( <br>register HWND hwndParent) <br>{ <br>  INT cWindows = 0; <br>  register HWND hwnd; <br> <br>  for (hwnd=GetWindow(hwndParent, GW_CHILD); <br>        hwnd; <br>        hwnd= GetWindow(hwnd, GW_HWNDNEXT)) { <br>      cWindows++; <br>  } <br>  return(cWindows); <br>} <br> <br> <br> <br>/**************************************************************************** <br> *                                                                          * <br> *  FUNCTION   : GetCascadeWindowPos                                        * <br> *                                                                          * <br> *  PURPOSE    : Based on a window index and the parent window size,        * <br> *               calculates where to place a cascaded window.               * <br> *                                                                          * <br> *  RETURNS    : rectangle in lprc.                                         * <br> *                                                                          * <br> ****************************************************************************/ <br>VOID GetCascadeWindowPos( <br>HWND hwndParent, <br>INT  iWindow, <br>LPRECT lprc) <br>{ <br>  RECT      rc; <br>  INT       cStack; <br>  register INT dxClient, dyClient; <br> <br>  /* Compute the width and breadth of the situation. */ <br>  GetClientRect(hwndParent, (LPRECT)&amp;rc); <br>  dxClient = rc.right - rc.left; <br>  dyClient = rc.bottom - rc.top; <br> <br>  /* How many windows per stack? */ <br>  cStack = dyClient / (3 * cyMargin); <br> <br>  lprc-&gt;right = dxClient - (cStack * cxMargin); <br>  lprc-&gt;bottom = dyClient - (cStack * cyMargin); <br> <br>  cStack++;             /* HACK!: Mod by cStack+1 */ <br> <br>  lprc-&gt;left = (iWindow % cStack) * cxMargin; <br>  lprc-&gt;top = (iWindow % cStack) * cyMargin; <br>} <br> <br> <br> <br> <br>/**************************************************************************** <br> *                                                                          * <br> *  FUNCTION   : MyCascadeChildWindows                                      * <br> *                                                                          * <br> *  PURPOSE    : Cascades all children of a parent window                   * <br> *                                                                          * <br> *  RETURNS    : nothing                                                    * <br> *                                                                          * <br> ****************************************************************************/ <br>VOID MyCascadeChildWindows( <br>register HWND hwndParent) <br>{ <br>  INT       i; <br>  INT       cWindows; <br>  RECT      rc; <br>  DWORD      wFlags; <br>  register HWND hwndMove; <br>  HANDLE    hDefer; <br> <br>  cWindows = CountWindows(hwndParent); <br> <br>  if (!cWindows) <br>      return; <br> <br>  hwndMove = GetWindow(hwndParent, GW_CHILD); <br> <br>  hDefer = BeginDeferWindowPos(cWindows); <br> <br>  for (i=0; i &lt; cWindows; i++) { <br>      GetCascadeWindowPos(hwndParent, i, (LPRECT)&amp;rc); <br> <br>      wFlags = SWP_NOZORDER | SWP_NOACTIVATE | SWP_NOCOPYBITS; <br> <br>      /* Size the window. */ <br>      hDefer = DeferWindowPos(hDefer, <br>                 hwndMove, NULL, <br>                 rc.left, rc.top, <br>                 rc.right, rc.bottom, <br>                 wFlags); <br> <br>      hwndMove = GetWindow(hwndMove, GW_HWNDNEXT); <br>  } <br> <br>  EndDeferWindowPos(hDefer); <br>} <br> <br> <br>/**************************************************************************** <br> *                                                                          * <br> *  FUNCTION   : TileChildWindows                                           * <br> *                                                                          * <br> *  PURPOSE    : Tiles all children of a parent window                      * <br> *                                                                          * <br> *  RETURNS    : nothing.                                                   * <br> *                                                                          * <br> ****************************************************************************/ <br>VOID TileChildWindows( <br>register HWND hwndParent) <br>{ <br>  INT       i; <br>  INT       dx; <br>  INT       dy; <br>  INT       xRes; <br>  INT       yRes; <br>  INT       iCol; <br>  INT       iRow; <br>  INT       cCols; <br>  INT       cRows; <br>  INT       cExtra; <br>  INT       cWindows; <br>  register HWND hwndMove; <br>  RECT      rcClient; <br>  HANDLE    hDefer; <br>  DWORD      wFlags; <br> <br>  cWindows = CountWindows(hwndParent); <br> <br>  if (!cWindows) <br>      return; <br> <br>  /* Compute the smallest nearest square. */ <br>  for (i=2; i * i &lt;= cWindows; i++); <br> <br>  cRows = i - 1; <br>  cCols = cWindows / cRows; <br>  cExtra = cWindows % cRows; <br> <br>  GetClientRect(hwndParent, (LPRECT)&amp;rcClient); <br>  xRes = rcClient.right - rcClient.left; <br>  yRes = rcClient.bottom - rcClient.top; <br> <br>  if (xRes&lt;=0 || yRes&lt;=0) <br>      return; <br> <br>  hwndMove = GetWindow(hwndParent, GW_CHILD); <br> <br>  hDefer = BeginDeferWindowPos(cWindows); <br> <br>  for (iCol=0; iCol &lt; cCols; iCol++) { <br>      if ((cCols-iCol) &lt;= cExtra) <br>      cRows++; <br> <br>      for (iRow=0; iRow &lt; cRows; iRow++) { <br>          dx = xRes / cCols; <br>          dy = yRes / cRows; <br> <br>          wFlags = SWP_NOZORDER | SWP_NOACTIVATE | SWP_NOCOPYBITS; <br> <br>          /* Position and size the window. */ <br>          hDefer = DeferWindowPos(hDefer, hwndMove, NULL, <br>                     dx * iCol, <br>                     dy * iRow, <br>                     dx, <br>                     dy, <br>                     wFlags); <br> <br>          hwndMove = GetWindow(hwndMove, GW_HWNDNEXT); <br>      } <br> <br>      if ((cCols-iCol) &lt;= cExtra) { <br>          cRows--; <br>          cExtra--; <br>      } <br>  } <br> <br>  EndDeferWindowPos(hDefer); <br> <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
