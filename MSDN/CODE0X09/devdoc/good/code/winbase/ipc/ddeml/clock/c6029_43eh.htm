<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CLOCK.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6029"></a>CLOCK.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples.  <br>*       Copyright 1993 - 1998 Microsoft Corporation. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>/* <br> *  CLOCK.C - Windows DDEML Clock <br> * <br> *  DDE Transactions: <br> *  ---------------- <br> *  Service: Clock <br> *  Topic  : Time <br> *  Item   : Now <br> * <br> *  Use Request or Advise to get the time or use Poke to change the time. <br> *  Time Format Hour:Minute:Seconds where <br> *   Hour    = 0-23 <br> *   Minute  = 0-59 <br> *   Seconds = 0-59 <br> */ <br> <br>#include &lt;time.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;string.h&gt; <br>#include "windows.h" <br>#include &lt;ddeml.h&gt; <br>#include "clock.h" <br> <br> <br>DWORD   idInst = 0; <br> <br>CLOCKDISPSTRUCT ClockDisp; <br> <br>HANDLE  hInst; <br>HWND    hWindow; <br> <br>HBRUSH  hbrBackground; <br>HBRUSH  hbrColorWindow; <br>HBRUSH  hbrColorBlack; <br>HBRUSH  hbrForeground; <br>HFONT   hFont; <br>HPEN    hpenForeground; <br>HPEN    hpenBackground; <br> <br>INT     nLeadZero   = 0; <br>INT     TimerID     = 1;    /* number used for timer-id */ <br>INT     clockRadius; <br>INT     HorzRes; <br>INT     VertRes; <br> <br>LONG    aspectD; <br>LONG    aspectN; <br> <br>CHAR    szBuffer[BUFLEN];    /* buffer for stringtable stuff */ <br>CHAR    szFontFile[20]; <br>CHAR    szIniFile[20]; <br>CHAR    szSection[30]; <br> <br>POINT   clockCenter; <br> <br>TIME    oTime; <br> <br>RECT    clockRect; <br>RECT    rCoordRect; <br> <br>HDDEDATA CALLBACK DdeCallback(WORD usType, WORD usFmt, HCONV hConv, HSZ hsz1, <br>        HSZ hsz2, HDDEDATA hData, DWORD lData1, DWORD lData2); <br>HSZ hszTime, hszNow, hszClock;    /* Hszs for DDEML use */ <br> <br>/* <br> *  Function Prototypes <br> */ <br> <br>LONG APIENTRY ClockWndProc(register HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam); <br> <br>void NEAR PASCAL ClockCreate(HWND hWnd); <br>BOOL NEAR PASCAL ClockInit(HANDLE hInstance); <br>void NEAR PASCAL ClockPaint(HWND hWnd, register HDC hDC, INT hint); <br>void NEAR PASCAL ClockSize(register HWND hWnd,INT newWidth,INT newHeight, WORD SizeWord); <br>void NEAR PASCAL ClockTimer(HWND hWnd, UINT msg); <br>void NEAR PASCAL CompClockDim(void); <br>void NEAR PASCAL CreateTools(void); <br>void NEAR PASCAL DeleteTools(void); <br>void NEAR PASCAL DrawBorder(HWND hWnd, register HDC hDC); <br>void NEAR PASCAL DrawFace(HDC hDC); <br>void NEAR PASCAL DrawHand(register HDC hDC, INT pos, HPEN hPen, INT scale, INT patMode); <br>void NEAR PASCAL DrawFatHand(register HDC hDC, INT pos, HPEN hPen, BOOL hHand); <br>void NEAR PASCAL FormatInit(register HANDLE hInstance, BOOL fModeChange); <br>void NEAR PASCAL SizeFont(HWND hWnd, INT newHeight, INT newWidth, INT wlen); <br>void NEAR PASCAL SetMenuBar( HWND hWnd ); <br> <br> <br>/* <br> *  CreateTools() <br> */ <br> <br>void NEAR PASCAL CreateTools(void) <br> <br>{ <br>  hbrForeground  = CreateSolidBrush(GetSysColor(COLOR_WINDOWTEXT)); <br>  hbrColorWindow = CreateSolidBrush(GetSysColor(COLOR_WINDOW)); <br>  hbrColorBlack  = CreateSolidBrush(0L); <br>  hbrBackground  = hbrColorWindow; <br>  hpenForeground = CreatePen(0, 1, GetSysColor(COLOR_WINDOWTEXT)); <br>  hpenBackground = CreatePen(0, 1, GetSysColor(COLOR_WINDOW)); <br>} <br> <br> <br>/* <br> *  DeleteTools() <br> */ <br> <br>void NEAR PASCAL DeleteTools(void) <br> <br>{ <br>  DeleteObject(hbrForeground); <br>  DeleteObject(hbrColorWindow); <br>  DeleteObject(hbrColorBlack); <br>  DeleteObject(hpenForeground); <br>  DeleteObject(hpenBackground); <br>} <br> <br> <br>/* <br> * SizeFont() - size font according to window size <br> */ <br> <br>void NEAR PASCAL SizeFont(HWND hWnd, INT newHeight, INT newWidth, INT wlen) <br>{ <br>register HDC    hDC; <br>TEXTMETRIC    tm; <br>LOGFONT    FontStruct; <br> <br>    hDC = GetDC(hWnd); <br>    GetTextMetrics(hDC, &amp;tm); <br> <br>    if (ClockDisp.wFormat == IDM_DIGITAL) { <br>        if (hFont != NULL) <br>            DeleteObject(hFont); <br> <br>        FontStruct.lfUnderline = FALSE; <br>        FontStruct.lfStrikeOut = FALSE; <br>        FontStruct.lfItalic    = FALSE; <br>        FontStruct.lfEscapement = FALSE; <br>        FontStruct.lfOrientation = FALSE; <br>        FontStruct.lfOutPrecision = OUT_DEFAULT_PRECIS; <br>        FontStruct.lfClipPrecision = CLIP_DEFAULT_PRECIS; <br> <br>        /* Note that the numbers used in this formula depend on the <br>         * size of the numbers in the fonts which are 12 vert, 7 horz. <br>        */ <br>        if (!ClockDisp.bIconic)  { <br>            FontStruct.lfHeight = (SHORT)min(newHeight/2, 45); <br> <br>            /* The formula at the end is somewhat empirical. */ <br>            FontStruct.lfWidth = (SHORT)min(25, newWidth/(wlen*3/2)); <br> <br>            /* This if is here because of a problem where:  if a clock <br>             * existed with a maximum size font, any new clock with a <br>             * smaller client area would get the same font that would not <br>             * fit in the Window.  So here, if the width does not match <br>             * maximum font dimensions, don't use the maximum height. <br>             */ <br>            if (FontStruct.lfWidth != 25 &amp;&amp; FontStruct.lfHeight == 45) <br>                FontStruct.lfHeight = 40; <br>        } <br>        else { <br>            FontStruct.lfHeight = (SHORT)(newHeight/3); <br>            FontStruct.lfWidth  = (SHORT)(newWidth/5); <br>        } <br> <br>        FontStruct.lfCharSet      = ANSI_CHARSET; <br>        FontStruct.lfQuality      = DRAFT_QUALITY; <br>        FontStruct.lfWeight      = FW_NORMAL; <br>        FontStruct.lfPitchAndFamily = VARIABLE_PITCH | FF_SWISS; <br> <br>        lstrcpy(FontStruct.lfFaceName, "DIGITAL"); <br> <br>        hFont = CreateFontIndirect(&amp;FontStruct); <br> <br>        SelectObject(hDC, hFont); <br>        GetTextMetrics(hDC, &amp;tm); <br>        SelectObject(hDC, GetStockObject(SYSTEM_FONT)); <br>    } <br> <br>    ReleaseDC(hWnd, hDC); <br> <br>    /* Compute placement for digital text. */ <br>    ClockDisp.line1.x = (newWidth) / 2; <br>    ClockDisp.line1.y = (newHeight - (tm.tmHeight)) / 2; <br>    ClockDisp.yline2  = ClockDisp.line1.y + tm.tmHeight; <br>} <br> <br> <br>/* <br> *  CompClockDim() - Recompute the clock's dimensions. <br> */ <br> <br>void NEAR PASCAL CompClockDim(void) <br> <br>{ <br>INT        i; <br>register INT    tWidth; <br>register INT    tHeight; <br> <br>    tWidth = clockRect.right - clockRect.left; <br>    tHeight = clockRect.bottom - clockRect.top; <br> <br>    if (tWidth &gt; (INT)((tHeight * aspectD) / aspectN)) { <br>        i = (INT)((tHeight * aspectD) / aspectN); <br>        clockRect.left += (tWidth - i) &gt;&gt; 1; <br>        clockRect.right = clockRect.left + i; <br>    } <br>    else { <br>        i = (INT)((tWidth * aspectN) / aspectD); <br>        clockRect.top += (tHeight - i) &gt;&gt; 1; <br>        clockRect.bottom = clockRect.top + i; <br>    } <br>} <br> <br> <br>/* <br> *  ClockSize() <br> */ <br> <br>void NEAR PASCAL ClockSize(register HWND hWnd, <br>               INT       newWidth, <br>               INT       newHeight, <br>               WORD      SizeWord) <br>{ <br>    SetRect((LPRECT)&amp;(clockRect), 0, 0, newWidth, newHeight); <br>    CompClockDim(); <br> <br>    if (SizeWord == SIZEICONIC) { <br>        /* Update once every 1/2 minute in the iconic state */ <br>        KillTimer(hWnd, TimerID); <br>        SetTimer(hWnd, TimerID, (WORD)ICON_TLEN, 0L); <br>        ClockDisp.bIconic = TRUE; <br>    } <br>    else if (ClockDisp.bIconic) { <br>        /* Update every 1/2 second in the opened state. */ <br>        KillTimer(hWnd, TimerID); <br>        SetTimer(hWnd, TimerID, OPEN_TLEN, 0L); <br>        ClockDisp.bIconic = FALSE; <br>    } <br> <br>    /* Compute where the digital readout should go. */ <br>    SizeFont(hWnd, newHeight, newWidth, ClockDisp.wDigTimeLen); <br>} <br> <br> <br>/* <br> *  DrawBorder() - Draws a Red Border around either clock. <br> */ <br> <br>void NEAR PASCAL DrawBorder(HWND hWnd, register HDC hDC) <br>{ <br>RECT Rect; <br>HPEN hPen; <br> <br>    GetClientRect(hWnd, (LPRECT) &amp;Rect); <br> <br>    hPen = CreatePen(PS_SOLID, (ClockDisp.bIconic) ? 1 : 2, <br>               (ClockDisp.bColor)  ? RGB(255,0,0) : RGB(255,255,255)); <br> <br>    SelectObject(hDC, hPen); <br>    Rectangle(hDC, Rect.left+1, Rect.top+1, Rect.right, Rect.bottom); <br>    SelectObject(hDC, GetStockObject(BLACK_PEN)); <br> <br>    DeleteObject(hPen); <br> <br>    /* Draw an external black border on an icon without killing the client area. */ <br>    if (ClockDisp.bIconic) { <br>        MoveToEx(hDC, Rect.left, Rect.top, NULL); <br>        LineTo(hDC, Rect.left,  Rect.bottom); <br>        LineTo(hDC, Rect.right, Rect.bottom); <br>        LineTo(hDC, Rect.right, Rect.top); <br>        LineTo(hDC, Rect.left,  Rect.top); <br>    } <br>} <br> <br> <br>/* <br> *  DrawFace() <br> */ <br> <br>void NEAR PASCAL DrawFace(HDC hDC) <br>{ <br>INT        i; <br>RECT       tRect; <br>INT        blobHeight, blobWidth; <br> <br>    blobWidth = (INT)((MAXBLOBWIDTH * (LONG)(clockRect.right - clockRect.left)) / HorzRes); <br>    blobHeight = (INT)((blobWidth * aspectN) / aspectD); <br> <br>    if (blobHeight &lt; 2) <br>        blobHeight = 1; <br> <br>    if (blobWidth &lt; 2) <br>        blobWidth = 2; <br> <br>    InflateRect((LPRECT)&amp;clockRect, -(blobHeight &gt;&gt; 1), -(blobWidth &gt;&gt; 1)); <br> <br>    clockRadius = (clockRect.right - clockRect.left-6) &gt;&gt; 1; <br>    clockCenter.y = clockRect.top + ((clockRect.bottom - clockRect.top) &gt;&gt; 1); <br>    clockCenter.x = clockRect.left + clockRadius+3; <br> <br>    for (i=0; i &lt; 60; i++) { <br>        tRect.top  = (INT)(((LONG)(CirTab[i].cos) * clockRadius) / CLKSCALE + clockCenter.y); <br>        tRect.left = (INT)(((LONG)(CirTab[i].sin) * clockRadius) / CLKSCALE + clockCenter.x); <br> <br>        if (i % 5) { <br>            /* Draw a dot. */ <br>            if (blobWidth &gt; 2 &amp;&amp; blobHeight &gt;= 2) { <br>                tRect.right = tRect.left + 1; <br>                tRect.bottom = tRect.top + 1; <br>                FillRect(hDC, (LPRECT)&amp;tRect, hbrForeground); <br>            } <br>        } <br>        else { <br>            tRect.right = tRect.left + blobWidth; <br>            tRect.bottom = tRect.top + blobHeight; <br>            OffsetRect((LPRECT)&amp;tRect, -(blobWidth &gt;&gt; 1) , -(blobHeight &gt;&gt; 1)); <br>            FillRect(hDC, (LPRECT)&amp;tRect, hbrForeground); <br>        } <br>    } <br>    InflateRect((LPRECT)&amp;clockRect, (blobHeight &gt;&gt; 1), (blobWidth &gt;&gt; 1)); <br>} <br> <br> <br>/* <br> *  DrawHand() - Draw the second hand using XOR mode. <br> */ <br> <br>void NEAR PASCAL DrawHand(register HDC hDC, <br>              INT          pos, <br>              HPEN         hPen, <br>              INT          scale, <br>              INT          patMode) <br>{ <br>INT       radius; <br> <br>    MoveToEx(hDC, clockCenter.x, clockCenter.y, NULL); <br>    radius = (INT)(((LONG)clockRadius * scale) / 100); <br>    SetROP2(hDC, patMode); <br>    SelectObject(hDC, hPen); <br> <br>    LineTo(hDC, clockCenter.x + (INT)(((LONG)(CirTab[pos].sin) * (radius)) / CLKSCALE), <br>        clockCenter.y + (INT)(((LONG)(CirTab[pos].cos) * (radius)) / CLKSCALE)); <br>} <br> <br> <br>/* <br> *  DrawFatHand() - Draws either hour or minute hand. <br> */ <br> <br>void NEAR PASCAL DrawFatHand(register HDC hDC, INT pos, HPEN hPen, BOOL hHand) <br>{ <br>register INT    m; <br>INT        n; <br>INT        scale; <br>POINT      tip; <br>POINT      stip; <br> <br>    SetROP2(hDC, R2_COPYPEN); <br> <br>    SelectObject(hDC, hPen); <br> <br>    scale = hHand ? 7 : 5; <br> <br>    n = (pos+15)%60; <br>    m = (INT)((((LONG)clockRadius*scale) / 100)); <br>    stip.y = (INT)((LONG)(CirTab[n].cos) * m / CLKSCALE); <br>    stip.x = (INT)((LONG)(CirTab[n].sin) * m / CLKSCALE); <br> <br>    scale = hHand ? 65 : 80; <br>    tip.y = (INT)((LONG)(CirTab[pos].cos) * (((LONG)clockRadius * scale) / 100) / CLKSCALE); <br>    tip.x = (INT)((LONG)(CirTab[pos].sin) * (((LONG)clockRadius * scale) / 100) / CLKSCALE); <br> <br>    MoveToEx(hDC, clockCenter.x+stip.x, clockCenter.y+stip.y, NULL); <br>    LineTo(hDC, clockCenter.x+tip.x,  clockCenter.y+tip.y); <br>    MoveToEx(hDC, clockCenter.x-stip.x, clockCenter.y-stip.y, NULL); <br>    LineTo(hDC, clockCenter.x+tip.x,  clockCenter.y+tip.y); <br> <br>    scale = hHand ? 15 : 20; <br> <br>    n = (pos + 30) % 60; <br>    m = (INT)(((LONG)clockRadius * scale) / 100); <br>    tip.y = (INT)((LONG)(CirTab[n].cos) * m / CLKSCALE); <br>    tip.x = (INT)((LONG)(CirTab[n].sin) * m / CLKSCALE); <br>    MoveToEx(hDC, clockCenter.x+stip.x, clockCenter.y+stip.y, NULL); <br>    LineTo(hDC, clockCenter.x+tip.x,  clockCenter.y+tip.y); <br>    MoveToEx(hDC, clockCenter.x-stip.x, clockCenter.y-stip.y, NULL); <br>    LineTo(hDC, clockCenter.x+tip.x,  clockCenter.y+tip.y); <br>} <br> <br> <br>/* <br> *  ClockPaint() <br> */ <br> <br>void NEAR PASCAL ClockPaint(HWND hWnd, register HDC hDC, INT hint) <br>{ <br>INT     hour; <br>CHAR    *pszTime; <br>RECT    Rect; <br>TIME    nTime; <br>DWORD   rgbCol; <br>HBRUSH  hBr; <br> <br>    GetClientRect(hWnd, (LPRECT) &amp;Rect); <br> <br>    GetTime(&amp;nTime); <br> <br>    if (ClockDisp.wFormat == IDM_DIGITAL) {  /* Digital Display */ <br>        if (hint == REPAINT || ClockDisp.bIconic) { <br>            SelectObject(hDC, GetStockObject(BLACK_BRUSH)); <br>            DrawBorder(hWnd, hDC); <br> <br>            /* Set old values as undefined, so entire clock updated. */ <br>            oTime.hour24 = 25; <br>            oTime.minute = 60; <br>            oTime.ampm   = 2; <br>        } <br> <br>        if (oTime.hour24 != nTime.hour24) { <br>            if (ClockDisp.wTimeFormat) <br>                hour = nTime.hour24; <br>            else <br>                hour = nTime.hour12; <br> <br>            ClockDisp.szDigTime[0] = (CHAR)('0' + hour / 10); <br>            ClockDisp.szDigTime[1] = (CHAR)('0' + hour % 10); <br>        } <br> <br>        if (oTime.minute != nTime.minute) { <br>            ClockDisp.szDigTime[3]  = (CHAR)('0' + nTime.minute / 10); <br>            ClockDisp.szDigTime[4]  = (CHAR)('0' + nTime.minute % 10); <br>        } <br> <br>        /* Kill Leading zero if needed. */ <br>        if (nLeadZero == 0 &amp;&amp; ClockDisp.szDigTime[0] == '0') <br>            pszTime = ClockDisp.szDigTime + 1; <br>        else <br>            pszTime = ClockDisp.szDigTime; <br> <br>        SetTextColor(hDC, (ClockDisp.bColor) ? RGB(0,255,0) : RGB(255,255,255)); <br>        SetBkColor(hDC, 0L); <br>        SetTextAlign(hDC, TA_CENTER); <br> <br>        ClockDisp.wDigTimeLen = (WORD)((ClockDisp.bIconic ? 5 : 8) + ClockDisp.szDigTime - pszTime); <br> <br>        /* Is the font ready yet? */ <br>        if (hFont == 0 || ClockDisp.bNewFont)  { <br>            /* Create a suitable font */ <br>            SizeFont(hWnd, Rect.bottom - Rect.top, Rect.right - Rect.left, ClockDisp.wDigTimeLen); <br>            ClockDisp.bNewFont = FALSE; <br>        } <br> <br>        SelectObject(hDC, hFont); <br>        ClockDisp.szDigTime[6] = (CHAR)('0' + nTime.second / 10); <br>        ClockDisp.szDigTime[7] = (CHAR)('0' + nTime.second % 10); <br> <br>        Rect.left += 4; <br>        Rect.right -= 4; <br>        Rect.top = ClockDisp.line1.y; <br>        Rect.bottom = ClockDisp.yline2; <br>        ExtTextOut(hDC, ClockDisp.line1.x, ClockDisp.line1.y, ETO_OPAQUE | ETO_CLIPPED, <br>          (LPRECT)&amp;Rect, pszTime, (UINT)ClockDisp.wDigTimeLen, (LPINT)NULL); <br>        SelectObject(hDC, GetStockObject(SYSTEM_FONT)); <br>    } <br>    else { <br>        /* Analog display */ <br>        SetBkMode(hDC, TRANSPARENT); <br>        if (hint == REPAINT) { <br>            SetBkMode(hDC, OPAQUE); <br>            /* When switching from Digital to analog, the brush selected <br>             *  continued to be black; So, the current background is to be <br>             * selected; <br>             * Fix for Bug #6385 -- SANKAR -- 11-26-89 */ <br>            SelectObject(hDC, hbrBackground); <br> <br>            /* Make a temp brush to color the background.  This is to <br>             * force use of a solid color so the hand motion is painted <br>             * correctly. <br>             */ <br>            rgbCol = GetNearestColor(hDC, GetSysColor(COLOR_WINDOW)); <br>            hBr = CreateSolidBrush(rgbCol); <br> <br>            FillRect(hDC, &amp;Rect, hBr); <br> <br>            DeleteObject(hBr); <br> <br>            SetBkMode(hDC, TRANSPARENT); <br> <br>            DrawBorder(hWnd, hDC); <br>            DrawFace(hDC); <br>            DrawFatHand(hDC, oTime.hour * 5 + (oTime.minute / 12), hpenForeground, HHAND); <br>            DrawFatHand(hDC, oTime.minute, hpenForeground, MHAND); <br> <br>            if (!ClockDisp.bIconic)       /* Draw the second hand. */ <br>                DrawHand(hDC, oTime.second, hpenBackground, SECONDSCALE, R2_NOT); <br> <br>            /* NOTE: Don't update oTime in this case! */ <br> <br>            return; <br>        } <br>        else if (hint == HANDPAINT) { <br>            if ((!ClockDisp.bIconic) &amp;&amp; nTime.second != oTime.second) /* Erase the old second hand. */ <br>                DrawHand(hDC, oTime.second, hpenBackground, SECONDSCALE, R2_NOT); <br> <br>            if (nTime.minute != oTime.minute || nTime.hour != oTime.hour) { <br>                if (ClockDisp.bIconic) { <br>                    DrawHand(hDC, oTime.minute, hpenBackground, MINUTESCALE, R2_COPYPEN); <br>                    DrawHand(hDC, oTime.hour * 5 + (oTime.minute / 12), hpenBackground, HOURSCALE, R2_COPYPEN); <br>                    DrawHand(hDC, nTime.minute, hpenForeground, MINUTESCALE, R2_COPYPEN); <br>                    DrawHand(hDC, nTime.hour * 5 + (nTime.minute / 12), hpenForeground, HOURSCALE, R2_COPYPEN); <br>                } <br>                else { <br>                    DrawFatHand(hDC, oTime.minute, hpenBackground, MHAND); <br>                    DrawFatHand(hDC, oTime.hour*5+(oTime.minute/12), hpenBackground, HHAND); <br>                   DrawFatHand(hDC, nTime.minute, hpenForeground, MHAND); <br>                    DrawFatHand(hDC, (nTime.hour) * 5 + (nTime.minute / 12), hpenForeground, HHAND ); <br>                } <br>            } <br> <br>            if (!ClockDisp.bIconic &amp;&amp; nTime.second != oTime.second) /* Draw new second hand */ <br>                DrawHand(hDC, nTime.second, hpenBackground, SECONDSCALE, R2_NOT); <br>        } <br>    } <br>    oTime = nTime; <br>} <br> <br> <br>/* <br> *  ClockTimer() <br> * <br> *  msg - timer ID <br> * <br> * Called by windows to tell CLOCK there has been a time change. <br> * <br> */ <br> <br>void NEAR PASCAL ClockTimer(HWND hWnd, UINT msg) <br>{ <br>HDC    hDC; <br>TIME    nTime; <br> <br>    GetTime(&amp;nTime); <br> <br>    /* It's possible to change any part of the system at any time <br>     * through the Control Panel.  So we check everything. <br>     */ <br>    if (((nTime.second == oTime.second) || ClockDisp.bIconic) &amp;&amp; <br>        (nTime.minute == oTime.minute)          &amp;&amp; <br>        (nTime.hour24 == oTime.hour24)) <br>        return; <br> <br>    hDC = GetDC(hWnd); <br>    ClockPaint(hWnd, hDC, HANDPAINT); <br>    ReleaseDC(hWnd, hDC); <br>    DdePostAdvise(idInst, hszTime, hszNow); <br>      UNREFERENCED_PARAMETER(msg); <br>} <br> <br> <br>/* <br> *  ClockCreate() <br> */ <br> <br>void NEAR PASCAL ClockCreate(HWND hWnd) <br>{ <br>INT        i; <br>register HDC    hDC; <br>INT        HorzSize; <br>INT        VertSize; <br> <br>    hDC = GetDC(hWnd); <br>    VertRes = GetDeviceCaps(hDC, VERTRES); <br>    HorzRes = GetDeviceCaps(hDC, HORZRES); <br>    VertSize= GetDeviceCaps(hDC, VERTSIZE); <br>    HorzSize= GetDeviceCaps(hDC, HORZSIZE); <br>    ReleaseDC(hWnd, hDC); <br> <br>    aspectN = ((LONG)VertRes * 100) / (LONG)VertSize; <br>    aspectD = ((LONG)HorzRes * 100) / (LONG)HorzSize; <br> <br>    CreateTools(); <br> <br>    /* Scale sines for aspect ratio if this is the first instance */ <br>    for (i=0; i &lt; 60; i++) { <br>        CirTab[i].sin = (SHORT)((CirTab[i].sin * aspectN) / aspectD); <br>    } <br>} <br> <br> <br> <br>/* <br> *  FormatInit() -  International initialization. <br> */ <br> <br>void NEAR PASCAL FormatInit(register HANDLE hInstance, BOOL fModeChange) <br>{ <br>WORD i, ii; <br>CHAR szWinHeader[21], szKeyName[21], szRetVal[21]; <br> <br>    for (i=0; i &lt; 11; i++) <br>        ClockDisp.szDigTime[i] = ' '; <br> <br>    LoadString(hInstance, IDS_INTL, (LPSTR)szWinHeader, 20); <br> <br>    LoadString(hInstance, IDS_ITIME, (LPSTR)szKeyName, 20); <br>    ClockDisp.wTimeFormat = (WORD)GetProfileInt((LPSTR)szWinHeader, (LPSTR)szKeyName, 0); <br> <br>    LoadString(hInstance, IDS_S1159, (LPSTR)szKeyName, 20); <br>    LoadString(hInstance, IDS_1159, (LPSTR)szRetVal, 20); <br>    i = (WORD)GetProfileString((LPSTR)szWinHeader, (LPSTR)szKeyName, (LPSTR)szRetVal, (LPSTR)&amp;ClockDisp.szAMPM[0][0], 7); <br> <br>    LoadString(hInstance, IDS_S2359, (LPSTR)szKeyName, 20); <br>    LoadString(hInstance, IDS_2359, (LPSTR)szRetVal, 20); <br>    ii = (WORD)GetProfileString((LPSTR)szWinHeader, (LPSTR)szKeyName, (LPSTR)szRetVal, (LPSTR)&amp;ClockDisp.szAMPM[1][0], 7); <br> <br>    nLeadZero = GetProfileInt((LPSTR)szWinHeader, "iTLzero", 0); <br> <br>    LoadString(hInstance, IDS_STIME, (LPSTR)szKeyName, 20); <br>    LoadString(hInstance, IDS_TIMESEP, (LPSTR)szRetVal, 20); <br> <br>    GetProfileString((LPSTR)szWinHeader, (LPSTR)szKeyName, (LPSTR)szRetVal, (LPSTR)szRetVal, 20); <br>    ClockDisp.cTimeSep = szRetVal[0]; <br> <br>    ClockDisp.szDigTime[2] = ClockDisp.cTimeSep; <br>    ClockDisp.szDigTime[5] = ClockDisp.cTimeSep; <br> <br>    LoadString(hInstance, IDS_USNAME, (LPSTR)szWinHeader, 20); <br>    LoadString(hInstance, IDS_CLKFORMAT, (LPSTR)szKeyName, 20); <br> <br>    /* We will read the new mode (DIGITAL/ANALOG) only during init time. */ <br>    if (fModeChange) <br>    { <br>        if (GetPrivateProfileInt((LPSTR)szWinHeader, (LPSTR)szKeyName, 1, (LPSTR)szIniFile)) <br>            ClockDisp.wFormat = IDM_ANALOG; <br>        else <br>            ClockDisp.wFormat = IDM_DIGITAL; <br>    } <br> <br>    if (ClockDisp.wFormat == IDM_ANALOG) <br>        hbrBackground = hbrColorWindow; <br>    else <br>        hbrBackground = hbrColorBlack; <br> <br>    ClockDisp.wDigTimeLen = 2+1+2+1+2+1; <br> <br>    if (!ClockDisp.wTimeFormat) <br>        ClockDisp.wDigTimeLen += ((i &gt; ii) ? (i) : (ii)); <br>} <br> <br> <br>/* <br> *  ClockInit() <br> */ <br> <br>BOOL NEAR PASCAL ClockInit(HANDLE hInstance) <br>{ <br>HDC       hDC; <br>WNDCLASS  ClockClass; <br> <br>    FormatInit(hInstance, TRUE); <br> <br>    ClockClass.style         = CS_VREDRAW | CS_HREDRAW | CS_DBLCLKS; <br>    ClockClass.lpfnWndProc   = ClockWndProc; <br>    ClockClass.cbClsExtra    = 0; <br>    ClockClass.cbWndExtra    = 0; <br>    ClockClass.hInstance     = hInstance; <br>    ClockClass.hIcon         = NULL; <br>    ClockClass.hCursor       = LoadCursor(NULL, IDC_ARROW); <br>    ClockClass.hbrBackground = (HBRUSH) NULL; <br>    ClockClass.lpszMenuName  = (LPSTR)"Clock"; <br>    ClockClass.lpszClassName = (LPSTR)"Clock"; <br> <br>    if (!RegisterClass((LPWNDCLASS)&amp;ClockClass)) <br>        return(FALSE); <br> <br>    LoadString(hInstance, IDS_FONTFILE, (LPSTR)szFontFile, 20); <br>    AddFontResource(szFontFile); <br> <br>    /* Check the number of colors that the display is capable of. */ <br>    hDC = CreateDC("DISPLAY", NULL, NULL, NULL); <br>    ClockDisp.bColor = (GetDeviceCaps(hDC, NUMCOLORS) &gt; 2); <br>    ClockDisp.bColor = FALSE; <br>    DeleteDC(hDC); <br> <br>    ClockDisp.bTmpHide = FALSE; <br>    ClockDisp.bNewFont = FALSE; <br>    ClockDisp.bColor   = TRUE; <br>    ClockDisp.bNewFont = TRUE; <br> <br>    return(TRUE); <br>} <br> <br>/* <br> *  SetMenuBar() - places or removes the menu bar, etc. <br> * <br> *  Based on the flag ClockDisp.bNoTitle (ie: do we want a menu/title <br> *  bar or not?), adds or removes the window title and menu bar: <br> *    Gets current style, toggles the bits, and re-sets the style. <br> *    Must then resize the window frame and show it. <br> */ <br> <br>void NEAR PASCAL SetMenuBar( HWND hWnd ) <br>{ <br>    static DWORD wID; <br>    DWORD   dwStyle; <br> <br>    dwStyle = GetWindowLong( hWnd, GWL_STYLE ); <br>    if( ClockDisp.bNoTitle ) { <br>        /* remove caption &amp; menu bar, etc. */ <br>        dwStyle &amp;= ~(WS_DLGFRAME | WS_SYSMENU | <br>                   WS_MINIMIZEBOX | WS_MAXIMIZEBOX ); <br>        wID = SetWindowLong( hWnd, GWL_ID, 0 ); <br>    } <br>    else { <br>        /* put menu bar &amp; caption back in */ <br>        dwStyle = WS_TILEDWINDOW | dwStyle; <br>        SetWindowLong( hWnd, GWL_ID, wID ); <br>    } <br>    SetWindowLong( hWnd, GWL_STYLE, dwStyle ); <br>    SetWindowPos( hWnd, NULL, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | <br>        SWP_NOZORDER | SWP_FRAMECHANGED ); <br>    ShowWindow( hWnd, SW_SHOW ); <br>} <br> <br>/* <br> *  AboutDlgProc() <br> */ <br> <br>BOOL APIENTRY AboutDlgProc ( hwnd, msg, wParam, lParam ) <br>HWND          hwnd; <br>UINT msg; <br>WPARAM wParam; <br>LPARAM lParam; <br>{ <br>    switch (msg) { <br>        case WM_INITDIALOG: <br>            /* nothing to initialize */ <br>            break; <br> <br>        case WM_COMMAND: <br>            switch (LOWORD(wParam)) { <br>                case IDOK: <br>                case IDCANCEL: <br>                    EndDialog(hwnd, 0); <br>                    break; <br> <br>                default: <br>                    return FALSE; <br>            } <br>            break; <br> <br>        default: <br>            return(FALSE); <br>    } <br> <br>    return TRUE; <br>} <br> <br> <br> <br>/* <br> *  ClockWndProc() <br> */ <br> <br>LONG APIENTRY ClockWndProc(register HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam) <br>{ <br>HMENU       hMenu; <br>static CHAR szAppName[12];  /* application name buffer */ <br>PAINTSTRUCT ps; <br> <br>    switch (message) { <br>        case WM_COMMAND: <br>        switch (wParam)  { <br> <br>            case IDM_ANALOG: <br>            case IDM_DIGITAL: <br>                if ((WORD)wParam != ClockDisp.wFormat) { <br>                    /* Switch flag to other choice */ <br>                    hMenu = GetMenu(hWnd); <br>                    CheckMenuItem(hMenu, ClockDisp.wFormat, MF_BYCOMMAND | MF_UNCHECKED); <br>                    CheckMenuItem(hMenu, ClockDisp.wFormat = (WORD) wParam, MF_BYCOMMAND | MF_CHECKED); <br>                    InvalidateRect(hWnd, (LPRECT) NULL, TRUE); <br>                } <br>            break; <br> <br>            case IDM_NOTITLE: <br>                goto toggle_title; <br> <br>            case IDM_ABOUT: { <br>                DialogBox(hInst, MAKEINTRESOURCE(IDD_ABOUT), hWnd, (DLGPROC)AboutDlgProc); <br>                break; <br>            } <br> <br>            default: <br>                goto defproc; <br>        } <br>        break; <br> <br>        case WM_SIZE: <br>            ClockDisp.bNewFont = TRUE; <br>            ClockSize(hWnd, LOWORD(lParam), HIWORD(lParam), (WORD)wParam); <br>            UpdateWindow(hWnd); <br>            break; <br> <br>        case WM_QUERYDRAGICON: <br>            return (LONG)LoadIcon(hInst, "cckk"); <br> <br>        case WM_CLOSE: <br>        case WM_ENDSESSION: <br>          DestroyWindow( hWnd ); <br>          break; <br> <br>        case WM_DESTROY: { <br>            CHAR           szInt[10]; <br>            HCURSOR        hTempCursor; <br> <br>            KillTimer(hWnd, TimerID); <br>            DeleteTools(); <br>            if (hFont) <br>                DeleteObject(hFont); <br>            RemoveFontResource(szFontFile); <br> <br>            SetCapture(hWnd); <br>            hTempCursor=SetCursor(LoadCursor(NULL, IDC_WAIT)); <br> <br>            if (!(IsIconic(hWnd) || IsZoomed(hWnd))) <br>                GetWindowRect(hWnd, &amp;rCoordRect); <br> <br>            /* Write new configuration to DDEMLCLK.INI */ <br>            LoadString(hInst, IDS_CLKFORMAT, (LPSTR)szBuffer, BUFLEN-1); <br>            szInt[0] = (CHAR)('0' + (ClockDisp.wFormat == IDM_ANALOG)); <br>            szInt[1] = 0; <br>            WritePrivateProfileString((LPSTR)szSection, <br>                                      (LPSTR)szBuffer, <br>                                      (LPSTR)szInt, <br>                                      (LPSTR)szIniFile); <br>            wsprintf((LPSTR)szInt, (LPSTR)"%i", (INT)IsIconic(hWnd)); <br>            WritePrivateProfileString((LPSTR)szSection, <br>                                      (LPSTR)"Minimized", <br>                                      (LPSTR)szInt, <br>                                      (LPSTR)szIniFile); <br>            wsprintf((LPSTR)szInt, (LPSTR)"%i", (INT)IsZoomed(hWnd)); <br>            WritePrivateProfileString((LPSTR)szSection, <br>                                      (LPSTR)"Maximized", <br>                                      (LPSTR)szInt, <br>                                      (LPSTR)szIniFile); <br>            wsprintf((LPSTR)szInt, (LPSTR)"%i", (INT)rCoordRect.left); <br>            WritePrivateProfileString((LPSTR)szSection, <br>                                      (LPSTR)"Left", <br>                                      (LPSTR)szInt, <br>                                      (LPSTR)szIniFile); <br>            wsprintf((LPSTR)szInt, (LPSTR)"%i", (INT)rCoordRect.top); <br>            WritePrivateProfileString((LPSTR)szSection, <br>                                      (LPSTR)"Top", <br>                                      (LPSTR)szInt, <br>                                      (LPSTR)szIniFile); <br>            wsprintf((LPSTR)szInt, (LPSTR)"%i", (INT)rCoordRect.right); <br>            WritePrivateProfileString((LPSTR)szSection, <br>                                      (LPSTR)"Right", <br>                                      (LPSTR)szInt, <br>                                      (LPSTR)szIniFile); <br>            wsprintf((LPSTR)szInt, (LPSTR)"%i", (INT)rCoordRect.bottom); <br>            WritePrivateProfileString((LPSTR)szSection, <br>                                      (LPSTR)"Bottom", <br>                                      (LPSTR)szInt, <br>                                      (LPSTR)szIniFile); <br>            wsprintf((LPSTR)szInt, (LPSTR)"%i", (INT)ClockDisp.bTopMost); <br>            WritePrivateProfileString((LPSTR)szSection, <br>                                      (LPSTR)"TopMost", <br>                                      (LPSTR)szInt, <br>                                      (LPSTR)szIniFile); <br>            wsprintf((LPSTR)szInt, (LPSTR)"%i", (INT)ClockDisp.bNoTitle); <br>            WritePrivateProfileString((LPSTR)szSection, <br>                                      (LPSTR)"NoTitle", <br>                                      (LPSTR)szInt, <br>                                      (LPSTR)szIniFile); <br>            PostQuitMessage(0); <br>            break; <br>        } <br> <br>        case WM_WININICHANGE: <br>            /* FALSE indicates that we don't want to change the display format */ <br>            FormatInit(hInst, FALSE); <br>            InvalidateRect(hWnd, (LPRECT)NULL, TRUE); <br>            break; <br> <br>        case WM_PAINT: <br>            /* Added to force total repaint to solve <br>             * problem of garbage under second hand when hidden <br>             * by menu or popup. <br>             */ <br>            InvalidateRect(hWnd, (LPRECT)NULL, TRUE); <br>            BeginPaint(hWnd, (LPPAINTSTRUCT)&amp;ps); </code></pre>
<p>
</p>
<pre><code><br>            if (ClockDisp.wFormat == IDM_DIGITAL) { <br>                hbrBackground = hbrColorBlack; <br>                FillRect(ps.hdc, (LPRECT)&amp;clockRect, hbrBackground); <br>            } <br>            else <br>                hbrBackground=hbrColorWindow; <br> <br>            ClockPaint(hWnd, ps.hdc, REPAINT); <br>            EndPaint(hWnd, (LPPAINTSTRUCT)&amp;ps); <br>            break; <br> <br>        case WM_TIMECHANGE: <br>            /* Redraw. */ <br>            InvalidateRect(hWnd, (LPRECT)NULL, TRUE); <br> <br>        case WM_TIMER: <br>            ClockTimer(hWnd, (WORD)wParam); <br>            break; <br> <br>        case WM_SYSCOMMAND: <br>            switch (wParam)  { <br> <br>                case SC_MINIMIZE: <br>                    if (!IsZoomed(hWnd)) <br>                        GetWindowRect(hWnd, (LPRECT)&amp;rCoordRect); <br>                    ClockDisp.bMinimized = TRUE; <br>                    ClockDisp.bMaximized = FALSE; <br>                    break; <br>                case SC_MAXIMIZE: <br>                    if (!IsIconic(hWnd)) <br>                        GetWindowRect(hWnd, (LPRECT)&amp;rCoordRect); <br>                    ClockDisp.bMinimized = FALSE; <br>                    ClockDisp.bMaximized = TRUE; <br>                    break; <br> <br>                case IDM_TOPMOST: { <br>                    /* toggles topmost option <br>                     */ <br>                    hMenu = GetSystemMenu(hWnd, FALSE); <br>                    if( ClockDisp.bTopMost )  { <br>                        CheckMenuItem( hMenu, IDM_TOPMOST, MF_BYCOMMAND | MF_UNCHECKED ); <br>                        SetWindowPos( hWnd, HWND_NOTOPMOST, 0, 0, 0, 0, <br>                                       SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE); <br>                        ClockDisp.bTopMost = FALSE; <br>                    } <br>                    else { <br>                        CheckMenuItem( hMenu, IDM_TOPMOST, MF_BYCOMMAND | MF_CHECKED ); <br>                        SetWindowPos( hWnd, HWND_TOPMOST, 0, 0, 0, 0, <br>                                         SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE); <br>                        ClockDisp.bTopMost = TRUE; <br>                    } <br>                    break; <br>                } <br> <br>            } <br>            return(DefWindowProc(hWnd, message, wParam, lParam)); <br>            break; <br> <br>        case WM_MOUSEACTIVATE: <br>            /* right button temporarily hides the window if topmost is <br>             * enabled (window re-appears when right button is released). <br>             * When this happens, we don't want to activate the clock window <br>             * just before hiding it (it would look really bad), so we <br>             * intercept the activate message. <br>             */ <br>            if( GetAsyncKeyState( VK_RBUTTON ) &amp; 0x8000 ) <br>                return( MA_NOACTIVATE ); <br>            else <br>                goto defproc; <br>            break; <br> <br>        case WM_RBUTTONDOWN: <br>        case WM_NCRBUTTONDOWN: <br>            /* right button temporarily hides the window, if the window <br>             * is topmost, and if no menu is currently "active" <br>             */ <br>            if( !ClockDisp.bTmpHide &amp;&amp; ClockDisp.bTopMost ) { <br>                ShowWindow( hWnd, SW_HIDE ); <br>                SetCapture( hWnd ); <br>                ClockDisp.bTmpHide = TRUE; <br>            } <br>            break; <br> <br>        case WM_RBUTTONUP: <br>        case WM_NCRBUTTONUP: <br>            /* if window is currently hidden, right button up brings it <br>             * back. Must make sure we show it in its previous state - ie: <br>             * minimized, maximized or normal. <br>             */ <br>            if( ClockDisp.bTmpHide ) { <br>                ReleaseCapture(); <br>                if( IsIconic(hWnd) ) <br>                    ShowWindow( hWnd, SW_SHOWMINNOACTIVE ); <br>                else if( IsZoomed( hWnd ) ) <br>                    ShowWindow( hWnd, SW_SHOWMAXIMIZED ); <br>                else <br>                    ShowWindow( hWnd, SW_SHOWNOACTIVATE ); <br>                ClockDisp.bTmpHide = FALSE; <br>            } <br>            break; <br> <br>        case WM_KEYDOWN: <br>            /* ESC key toggles the menu/title bar (just like a double click <br>             * on the client area of the window. <br>             */ <br>            if( (wParam == VK_ESCAPE) &amp;&amp; !(HIWORD( lParam ) &amp; 0x4000) ) <br>                goto toggle_title; <br>            break; <br> <br>        case WM_NCLBUTTONDBLCLK: <br>            if( !ClockDisp.bNoTitle ) <br>                /* if we have title bars etc. let the normal stuff take place */ <br>                goto defproc; <br> <br>            /* else: no title bars, then this is actually a request to bring <br>             * the title bars back... <br>             */ <br> <br>            /* fall through */ <br> <br>        case WM_LBUTTONDBLCLK: <br>toggle_title: <br>            ClockDisp.bNoTitle = (ClockDisp.bNoTitle ? FALSE : TRUE ); <br>            SetMenuBar( hWnd ); <br>           break; <br> <br>        case WM_NCHITTEST: <br>            /* if we have no title/menu bar, clicking and dragging the client <br>             * area moves the window. To do this, return HTCAPTION. <br>             * Note dragging not allowed if window maximized, or if caption <br>             * bar is present. <br>             */ <br>            wParam = DefWindowProc(hWnd, message, wParam, lParam); <br>            if( ClockDisp.bNoTitle &amp;&amp; (wParam == HTCLIENT) &amp;&amp; !IsZoomed(hWnd) ) <br>                return HTCAPTION; <br>            else <br>              return wParam; <br> <br>        case WM_SYSCOLORCHANGE: <br>            DeleteTools(); <br>            CreateTools(); <br>            break; <br> <br>        case WM_ERASEBKGND: { <br>            RECT rect; <br> <br>            GetClientRect(hWnd, (LPRECT)&amp;rect); <br>            SelectObject((HDC)wParam, hbrBackground); <br>            FillRect((HDC)wParam, (LPRECT)&amp;rect, hbrBackground); <br>            break; <br>        } <br> <br>        default: <br>defproc: <br>        return(DefWindowProc(hWnd, message, wParam, lParam)); <br>    } <br>    return(0L); <br>} <br> <br> <br>/* <br> *  WinMain() <br> */ <br> <br>INT PASCAL WinMain( <br>HINSTANCE hInstance, <br>HINSTANCE hPrev, <br>LPSTR lpszCmdLine, <br>INT cmdShow) <br>{ <br>register HWND hWnd; <br>MSG           msg; <br>TIME          nTime; <br>PSTR          szTooMany; <br>HMENU         hMenu; <br>CHAR          szTopmost[80]; <br> <br>    LoadString(hInstance, IDS_USNAME, (LPSTR)szBuffer, BUFLEN); <br>    LoadString(hInstance, IDS_INIFILE, (LPSTR)szIniFile, 20); <br>    LoadString(hInstance, IDS_USNAME, (LPSTR)szSection, 30); <br> <br>    if (!ClockInit(hInstance)) <br>        return(FALSE); <br> <br>    ClockCreate((HWND)NULL); <br> <br>    LoadString(hInstance, IDS_APPNAME, (LPSTR)szBuffer, BUFLEN); <br> <br>    rCoordRect.top=GetPrivateProfileInt((LPSTR)szSection, <br>                                         (LPSTR)"Top", <br>                                         (DWORD)-1, (LPSTR)szIniFile); <br>    rCoordRect.left=GetPrivateProfileInt((LPSTR)szSection, <br>                                         (LPSTR)"Left", <br>                                         (DWORD)-1, (LPSTR)szIniFile); <br>    rCoordRect.right=GetPrivateProfileInt((LPSTR)szSection, <br>                                         (LPSTR)"Right", <br>                                         (DWORD)-1, (LPSTR)szIniFile); <br>    rCoordRect.bottom=GetPrivateProfileInt((LPSTR)szSection, <br>                                         (LPSTR)"Bottom", <br>                                         (DWORD)-1, (LPSTR)szIniFile); <br> <br>    hWnd = CreateWindow((LPSTR)"Clock",    /* The class name.           */ <br>            (LPSTR)szBuffer,               /* The window instance name. */ <br>            WS_TILEDWINDOW, <br>            (rCoordRect.left &lt; 0) ? CW_USEDEFAULT : rCoordRect.left, <br>            (rCoordRect.top  &lt; 0) ? CW_USEDEFAULT : rCoordRect.top, <br>            (rCoordRect.left &lt; 0) ? (INT)( (HorzRes/3) + GetSystemMetrics(SM_CXFRAME)*2 ) <br>                  : rCoordRect.right - rCoordRect.left, <br>            (rCoordRect.left &lt; 0) ? (INT)( (((HorzRes/3)*aspectN)/aspectD)+GetSystemMetrics(SM_CYCAPTION)+GetSystemMetrics(SM_CYFRAME)*2 ) <br>                  : rCoordRect.bottom - rCoordRect.top, <br>            NULL, <br>            NULL, <br>            hInstance, <br>            (LPSTR)NULL); <br> <br>    hWindow=hWnd; <br> <br>    // Loop if control panel time being changed. <br>    GetTime((TIME *)&amp;nTime); <br>    do { <br>        GetTime((TIME *)&amp;oTime); <br>    } while (nTime.second == oTime.second &amp;&amp; nTime.minute == oTime.minute &amp;&amp; <br>           nTime.hour24 == oTime.hour24); <br> <br>    if (!SetTimer(hWnd, TimerID, OPEN_TLEN, 0L) )  { <br>        /* Windows only supports 16 public timers */ <br>        szTooMany = (PSTR)LocalAlloc(LPTR, 160); <br>        LoadString(hInstance, IDS_TOOMANY, (LPSTR)szTooMany, 160); <br>        MessageBox((HWND)NULL, (LPSTR)szTooMany, (LPSTR)szBuffer, MB_OK | MB_ICONHAND | MB_SYSTEMMODAL); <br>        DeleteTools(); <br>        return(FALSE); <br>    } <br> <br>    /* Add the topmost system menu item */ <br>    hMenu = GetSystemMenu( hWnd, FALSE ); <br>    AppendMenu( hMenu, MF_SEPARATOR, 0, NULL ); <br>    LoadString(hInstance, IDS_TOPMOST, szTopmost, 79); <br> <br>    /* Check the default setting to the clock as topmost or not */ <br>    ClockDisp.bTopMost=GetPrivateProfileInt((LPSTR)szSection, <br>                                         (LPSTR)"TopMost", <br>                                         0, (LPSTR)szIniFile); <br>    if( ClockDisp.bTopMost ) { <br>        AppendMenu( hMenu, MF_ENABLED | MF_CHECKED | MF_STRING, IDM_TOPMOST, <br>                    szTopmost ); <br>        SetWindowPos( hWnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE); <br>    } <br>    else <br>        AppendMenu( hMenu, MF_ENABLED | MF_UNCHECKED | MF_STRING, IDM_TOPMOST, <br>                    szTopmost ); <br> <br>    /* Check the default menu item either analog or digital */ <br>    CheckMenuItem(GetMenu(hWnd), ClockDisp.wFormat, MF_BYCOMMAND | MF_CHECKED); <br> <br>    /* Check the default setting to show title bar or not */ <br>    ClockDisp.bNoTitle=GetPrivateProfileInt((LPSTR)szSection, <br>                                         (LPSTR)"NoTitle", <br>                                         0, (LPSTR)szIniFile); <br>    if( ClockDisp.bNoTitle ) { <br>        SetMenuBar( hWnd ); <br>    } <br> <br>    hInst = hInstance; <br> <br>    /* Check the default minimized state, minimized or not */ <br>    ClockDisp.bMinimized=GetPrivateProfileInt((LPSTR)szSection, <br>                                         (LPSTR)"Minimized", <br>                                         0, (LPSTR)szIniFile); <br>    if (!ClockDisp.bMinimized) { <br>        ClockDisp.bMaximized=GetPrivateProfileInt((LPSTR)szSection, <br>                                         (LPSTR)"Maximized", <br>                                         0, (LPSTR)szIniFile); <br>        if (ClockDisp.bMaximized) <br>            ShowWindow(hWnd, SW_MAXIMIZE); <br>        else { <br>            ShowWindow(hWnd, cmdShow); <br>            GetWindowRect(hWnd, (LPRECT)&amp;rCoordRect); <br>        } <br>    } <br>    else <br>        ShowWindow(hWnd, SW_MINIMIZE); <br> <br>    DdeInitialize(&amp;idInst, (PFNCALLBACK)MakeProcInstance((FARPROC)DdeCallback, hInstance), <br>            CBF_FAIL_EXECUTES | CBF_SKIP_ALLNOTIFICATIONS, 0L); <br>    hszTime = DdeCreateStringHandle(idInst, "Time", 0); <br>    hszNow = DdeCreateStringHandle(idInst, "Now", 0); <br>    hszClock = DdeCreateStringHandle(idInst, "Clock", 0); <br>    DdeNameService(idInst, hszClock, 0L, DNS_REGISTER); <br> <br> <br> <br>    while (GetMessage((LPMSG)&amp;msg, NULL, 0, 0) ) { <br>        TranslateMessage((LPMSG)&amp;msg); <br>        DispatchMessage((LPMSG)&amp;msg); <br>    } <br> <br>    DdeUninitialize(idInst); <br> <br>    return(msg.wParam); <br>} <br> <br> <br>/* <br> *  GetTime() <br> */ <br> <br>VOID GetTime( <br>TIME *ptime) <br>{ <br>    time_t t; <br>    struct tm *ptm; <br> <br>    time(&amp;t); <br>    ptm = localtime(&amp;t); <br>    ptime-&gt;second = ptm-&gt;tm_sec; <br>    ptime-&gt;minute = ptm-&gt;tm_min; <br>    ptime-&gt;hour12 = <br>    ptime-&gt;hour = ptm-&gt;tm_hour &gt; 12 ? ptm-&gt;tm_hour - 12 : ptm-&gt;tm_hour; <br>    ptime-&gt;hour24 = ptm-&gt;tm_hour; <br>    ptime-&gt;ampm = ptm-&gt;tm_hour &gt; 12 ? 1 : 0; <br>} <br> <br> <br>/* <br> *  DdeCallback() <br> */ <br> <br>HDDEDATA CALLBACK DdeCallback( <br>WORD usType, <br>WORD usFmt, <br>HCONV hConv, <br>HSZ hsz1, <br>HSZ hsz2, <br>HDDEDATA hData, <br>DWORD lData1, <br>DWORD lData2) <br>{ <br> <br>static HANDLE           hToken; <br>static TOKEN_PRIVILEGES tp; <br>static LUID             luid; <br> <br>    if (usType == XTYP_CONNECT) { <br>        return((HDDEDATA)TRUE); <br>    } <br> <br>    if (usType == XTYP_WILDCONNECT) { <br>        HDDEDATA hData; <br>        HSZPAIR FAR *phszp; <br>        DWORD cb; <br> <br>        if ((!hsz1 || hsz1 == hszTime) &amp;&amp; (!hsz2 || hsz2 == hszClock)) { <br>            if ((hData = DdeCreateDataHandle(idInst, NULL, <br>                    2 * sizeof(HSZPAIR), 0L, 0, 0, 0))) { <br>                phszp = (HSZPAIR FAR *)DdeAccessData(hData, &amp;cb); <br>                phszp[0].hszSvc = hszClock; <br>                phszp[0].hszTopic = hszTime; <br>                phszp[1].hszSvc = phszp[1].hszTopic = 0; <br>                DdeUnaccessData(hData); <br>                return(hData); <br>            } <br>        } <br>        return(0); <br>    } <br> <br>    if (usFmt == CF_TEXT) { <br>        CHAR sz[40]; <br> <br>        if (usType == XTYP_ADVSTART || usType == XTYP_ADVSTOP) { <br>            return((HDDEDATA)TRUE); <br>        } <br> <br>        if (hsz1 == hszTime &amp;&amp; hsz2 == hszNow) { <br>            if (usType == XTYP_REQUEST || usType == XTYP_ADVREQ) { <br> <br>                itoa(oTime.hour, sz, 10); <br>                strcat(sz, ":"); <br>                itoa(oTime.minute, &amp;sz[strlen(sz)], 10); <br>                strcat(sz, ":"); <br>                itoa(oTime.second, &amp;sz[strlen(sz)], 10); <br>                return(DdeCreateDataHandle(idInst, (LPBYTE)sz, strlen(sz) + 1, 0L, <br>                        hszNow, CF_TEXT, 0)); <br>            } <br>            if (usType == XTYP_POKE) { <br>                SYSTEMTIME SysTime; <br> <br>                DdeGetData(hData, (LPBYTE)sz, 40L, 0L); <br>                GetLocalTime(&amp;SysTime); <br>                sscanf(sz, "%2d:%2d:%2d", &amp;SysTime.wHour, &amp;SysTime.wMinute, &amp;SysTime.wSecond); <br> <br>                /* enable system-time privilege, set time, disable privilege */ <br>                OpenProcessToken( GetCurrentProcess(), <br>                  TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &amp;hToken ) ; <br>                LookupPrivilegeValue( NULL, "SeSystemTimePrivilege", &amp;luid ); <br>                tp.PrivilegeCount           = 1; <br>                tp.Privileges[0].Luid       = luid; <br>                tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED; <br>                AdjustTokenPrivileges( hToken, FALSE, &amp;tp, <br>                  sizeof(TOKEN_PRIVILEGES), NULL, NULL ); <br>                SetLocalTime(&amp;SysTime); <br>                AdjustTokenPrivileges( hToken, TRUE, &amp;tp, <br>                  sizeof(TOKEN_PRIVILEGES), NULL, NULL ); <br> <br>                DdePostAdvise(idInst, hszTime, hszNow); <br>                return((HDDEDATA)DDE_FACK); <br>            } <br>        } <br>    } <br>    return(0); <br> <br>    UNREFERENCED_PARAMETER(lData1); <br>    UNREFERENCED_PARAMETER(lData2); <br>    UNREFERENCED_PARAMETER(hConv); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
