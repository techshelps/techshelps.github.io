<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DIALOG.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6020"></a>DIALOG.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples. <br>*       Copyright 1993 - 1998 Microsoft Corporation. <br>*       All rights reserved. <br>*       This source code is only intended as a supplement to <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>/*************************************************************************** <br> *                                                                         * <br> *  MODULE      : dialog.c                                                 * <br> *                                                                         * <br> *  PURPOSE     : Contains all dialog procedures and related functions.    * <br> *                                                                         * <br> ***************************************************************************/ <br>#include "client.h" <br>#include "infoctrl.h" <br>#include &lt;string.h&gt; <br>#include &lt;stdio.h&gt; <br>#include "huge.h" <br> <br>#define MAX_NAME 100    // max size for edit controls with app/topic/item names. <br>TCHAR szWild[] = TEXT("*");    // used to indicate wild names ("" is also cool) <br>TCHAR szT[MAX_NAME];     // temp buf for munging names. <br> <br> <br> <br>/**************************************************************************** <br> *                                                                          * <br> *  FUNCTION   : DoDialog()                                                 * <br> *                                                                          * <br> *  PURPOSE    : Generic dialog invocation routine.  Handles procInstance   * <br> *               stuff, focus management and param passing.                 * <br> *  RETURNS    : result of dialog procedure.                                * <br> *                                                                          * <br> ****************************************************************************/ <br>INT FAR DoDialog( <br>LPTSTR lpTemplateName, <br>DLGPROC lpDlgProc, <br>LONG param, <br>BOOL fRememberFocus) <br>{ <br>    INT iRet; <br>    HWND hwndFocus; <br> <br>    if (fRememberFocus) <br>        hwndFocus = GetFocus(); <br>    lpDlgProc = MakeProcInstance(lpDlgProc, hInst); <br>    iRet = DialogBoxParam(hInst, lpTemplateName, hwndFrame, lpDlgProc, param); <br>    FreeProcInstance(lpDlgProc); <br>    if (fRememberFocus) <br>        SetFocus(hwndFocus); <br>    return iRet; <br>} <br> <br> <br> <br>/**************************************************************************** <br> *                                                                          * <br> *  FUNCTION   :                                                            * <br> *                                                                          * <br> *  PURPOSE    :                                                            * <br> *                                                                          * <br> *  RETURNS    :                                                            * <br> *                                                                          * <br> ****************************************************************************/ <br>BOOL  APIENTRY AboutDlgProc ( hwnd, msg, wParam, lParam ) <br>HWND          hwnd; <br>UINT msg; <br>WPARAM wParam; <br>LPARAM lParam; <br>{ <br>    switch (msg){ <br>        case WM_INITDIALOG: <br>            /* nothing to initialize */ <br>            break; <br> <br>        case WM_COMMAND: <br>            switch (LOWORD(wParam)) { <br>                case IDOK: <br>                case IDCANCEL: <br>                    EndDialog(hwnd, 0); <br>                    break; <br> <br>                default: <br>                    return FALSE; <br>            } <br>            break; <br> <br>        default: <br>            return(FALSE); <br>    } <br> <br>    return TRUE; <br>} <br> <br> <br> <br> <br>/**************************************************************************** <br> *                                                                          * <br> *  FUNCTION   :                                                            * <br> *                                                                          * <br> *  PURPOSE    :                                                            * <br> *                                                                          * <br> *  RETURNS    :                                                            * <br> *                                                                          * <br> ****************************************************************************/ <br>BOOL  APIENTRY ConnectDlgProc( <br>HWND          hwnd, <br>UINT msg, <br>WPARAM wParam, <br>LPARAM lParam) <br>{ <br>    static BOOL fReconnect; <br>    TCHAR szT[MAX_NAME]; <br>    HSZ hszApp, hszTopic; <br>    MYCONVINFO *pmci; <br> <br>    switch (msg){ <br>    case WM_INITDIALOG: <br>        SendDlgItemMessage(hwnd, IDEF_APPLICATION, EM_LIMITTEXT, MAX_NAME, 0); <br>        SendDlgItemMessage(hwnd, IDEF_TOPIC, EM_LIMITTEXT, MAX_NAME, 0); <br>        fReconnect = (BOOL)lParam; <br>        if (fReconnect) { <br>            PTSTR psz; <br> <br>            pmci = (MYCONVINFO *)GetWindowLong(hwndActive, 0); <br>            SetWindowText(hwnd, TEXT("DDE Reconnect List")); <br>            psz = GetHSZName(pmci-&gt;hszApp); <br>            SetDlgItemText(hwnd, IDEF_APPLICATION, psz); <br>            MyFree(psz); <br>            psz = GetHSZName(pmci-&gt;hszTopic); <br>            SetDlgItemText(hwnd, IDEF_TOPIC, psz); <br>            MyFree(psz); <br>            ShowWindow(GetDlgItem(hwnd, IDCH_CONNECTLIST), SW_HIDE); <br>        } <br>        break; <br> <br>    case WM_COMMAND: <br>        switch (LOWORD(wParam)) { <br>        case IDOK: <br>            GetDlgItemText(hwnd, IDEF_APPLICATION, szT, MAX_NAME); <br>            if (!_tcscmp(szT, szWild)) <br>                szT[0] = TEXT('\0'); <br>            hszApp = DdeCreateStringHandle(idInst, szT, 0); <br> <br>            GetDlgItemText(hwnd, IDEF_TOPIC, szT, MAX_NAME); <br>            if (!_tcscmp(szT, szWild)) <br>                szT[0] = TEXT('\0'); <br>            hszTopic = DdeCreateStringHandle(idInst, szT, 0); <br> <br>            if (fReconnect) { <br>                HCONV hConv; <br>                CONVINFO ci; <br>                DWORD cHwnd; <br>                HWND *aHwnd, *pHwnd, hwndSave; <br> <br>                ci.cb = sizeof(CONVINFO); <br>                pmci = (MYCONVINFO *)GetWindowLong(hwndActive, 0); <br>                hwndSave = hwndActive; <br> <br>                // count the existing conversations and allocate aHwnd <br> <br>                cHwnd = 0; <br>                hConv = 0; <br>                while (hConv = DdeQueryNextServer((HCONVLIST)pmci-&gt;hConv, hConv)) <br>                    cHwnd++; <br>                aHwnd = (HWND *)MyAlloc(cHwnd * sizeof(HWND)); <br> <br>                // save all the old conversation windows into aHwnd. <br> <br>                pHwnd = aHwnd; <br>                hConv = 0; <br>                while (hConv = DdeQueryNextServer((HCONVLIST)pmci-&gt;hConv, hConv)) { <br>                    DdeQueryConvInfo(hConv, QID_SYNC, &amp;ci); <br>                    *pHwnd++ = (HWND)ci.hUser; <br>                } <br> <br>                // reconnect <br> <br>                if (!(hConv = (HCONV)DdeConnectList(idInst, hszApp, hszTopic, <br>                        (HCONVLIST)pmci-&gt;hConv, &amp;CCFilter))) { <br>                    MPError(MB_OK, IDS_DDEMLERR, <br>                            (LPTSTR)Error2String(DdeGetLastError(idInst))); <br>                    DdeFreeStringHandle(idInst, hszApp); <br>                    DdeFreeStringHandle(idInst, hszTopic); <br>                    return 0; <br>                } <br> <br>                // fixup windows corresponding to the new conversations. <br> <br>                pmci-&gt;hConv = hConv; <br>                hConv = 0; <br>                while (hConv = DdeQueryNextServer((HCONVLIST)pmci-&gt;hConv, hConv)) { <br>                    DdeQueryConvInfo(hConv, QID_SYNC, &amp;ci); <br>                    // preserve corresponding window by setting its list <br>                    // entry to 0 <br>                    for (pHwnd = aHwnd; pHwnd &lt; &amp;aHwnd[cHwnd]; pHwnd++) { <br>                        if (*pHwnd == (HWND)ci.hUser) { <br>                            *pHwnd = NULL; <br>                            break; <br>                        } <br>                    } <br>                } <br> <br>                // destroy all windows left in the old list <br> <br>                for (pHwnd = aHwnd; pHwnd &lt; &amp;aHwnd[cHwnd]; pHwnd++) <br>                    if (*pHwnd) { <br>                        SendMessage(hwndMDIClient, WM_MDIDESTROY, <br>                                (WPARAM)*pHwnd, 0L); <br>                    } <br>                MyFree((PTSTR)aHwnd); <br> <br>                // create any new windows needed <br> <br>                hConv = 0; <br>                while (hConv = DdeQueryNextServer((HCONVLIST)pmci-&gt;hConv, hConv)) { <br>                    DdeQueryConvInfo(hConv, QID_SYNC, &amp;ci); <br>                    if (ci.hUser) { <br>                        InvalidateRect((HWND)ci.hUser, NULL, TRUE); <br>                    } else { <br>                        AddConv(ci.hszSvcPartner, ci.hszTopic, hConv, FALSE); <br>                    } <br>                } <br> <br>                // make list window update itself <br> <br>                InvalidateRect(hwndSave, NULL, TRUE); <br>                SetFocus(hwndSave); <br>            } else { <br>                if (!CreateConv(hszApp, hszTopic, <br>                        IsDlgButtonChecked(hwnd, IDCH_CONNECTLIST))) { <br>                    MPError(MB_OK, IDS_DDEMLERR, (LPTSTR)Error2String(DdeGetLastError(idInst))); <br>                    return 0; <br>                } <br>            } <br>            DdeFreeStringHandle(idInst, hszApp); <br>            DdeFreeStringHandle(idInst, hszTopic); <br>            // fall through <br>        case IDCANCEL: <br>            EndDialog(hwnd, 0); <br>            break; <br> <br>        default: <br>            return(FALSE); <br>        } <br>        break; <br> <br>    default: <br>        return(FALSE); <br>    } <br>} <br> <br> <br> <br> <br>/* <br> * Fills a XACT structure and calls ProcessTransaction. <br> * <br> * On initiation lParam == hConv. <br> */ <br>/**************************************************************************** <br> *                                                                          * <br> *  FUNCTION   :                                                            * <br> *                                                                          * <br> *  PURPOSE    :                                                            * <br> *                                                                          * <br> *  RETURNS    :                                                            * <br> *                                                                          * <br> ****************************************************************************/ <br>BOOL  APIENTRY TransactDlgProc( <br>HWND          hwnd, <br>UINT msg, <br>WPARAM wParam, <br>LPARAM lParam) <br>{ <br>    static DWORD id2type[] = { <br>        XTYP_REQUEST,       // IDCH_REQUEST <br>        XTYP_ADVSTART,      // IDCH_ADVISE <br>        XTYP_ADVSTOP,       // IDCH_UNADVISE <br>        XTYP_POKE,          // IDCH_POKE <br>        XTYP_EXECUTE,       // IDCH_EXECUTE <br>    }; <br>    static XACT *pxact;     // ONLY ONE AT A TIME! <br>    INT i; <br> <br>    switch (msg){ <br>    case WM_INITDIALOG: <br>        pxact = (XACT *)MyAlloc(sizeof(XACT)); <br>        pxact-&gt;hConv = (HCONV)lParam; <br>        pxact-&gt;fsOptions = DefOptions; <br>        pxact-&gt;ulTimeout = DefTimeout; <br> <br>        // The item index == the index to the format atoms in aFormats[]. <br>        for (i = 0; i &lt; CFORMATS; i++) <br>            SendDlgItemMessage(hwnd, IDCB_FORMAT, CB_INSERTSTRING, i, <br>                    (DWORD)(LPTSTR)aFormats[i].sz); <br>        SendDlgItemMessage(hwnd, IDCB_FORMAT, CB_INSERTSTRING, i, <br>                (DWORD)(LPTSTR)TEXT("NULL")); <br>        SendDlgItemMessage(hwnd, IDCB_FORMAT, CB_SETCURSEL, 0, 0); <br>        CheckRadioButton(hwnd, IDCH_REQUEST, IDCH_EXECUTE, IDCH_REQUEST); <br>        SendDlgItemMessage(hwnd, IDEF_ITEM, EM_LIMITTEXT, MAX_NAME, 0); <br> <br>        // If there is a top transaction window, use its contents to <br>        // anticipate what the user will want to do. <br> <br>        if (IsWindow(hwndActive)) { <br>            HWND hwndXaction; <br>            XACT *pxact; <br>            PTSTR pszItem; <br> <br>            hwndXaction = GetWindow(hwndActive, GW_CHILD); <br>            if (IsWindow(hwndXaction)) { <br>                pxact = (XACT *)GetWindowLong(hwndXaction, GWL_USER); <br>                pszItem = GetHSZName(pxact-&gt;hszItem); <br>                if ((pxact-&gt;wType &amp; XTYP_ADVSTART) == XTYP_ADVSTART || <br>                        pxact-&gt;wType == XTYP_ADVDATA) { <br>                    CheckRadioButton(hwnd, IDCH_REQUEST, IDCH_EXECUTE, IDCH_UNADVISE); <br>                } <br>                SetDlgItemText(hwnd, IDEF_ITEM, pszItem); <br>                for (i = 0; i &lt; CFORMATS; i++) { <br>                    if (aFormats[i].fmt == pxact-&gt;wFmt) { <br>                        SendDlgItemMessage(hwnd, IDCB_FORMAT, CB_SETCURSEL, i, 0); <br>                        break; <br>                    } <br>                } <br>                MyFree(pszItem); <br>            } <br>        } <br>        break; <br> <br>    case WM_COMMAND: <br>        switch (LOWORD(wParam)) { <br>        case IDCH_EXECUTE: <br>            SetDlgItemText(hwnd, IDEF_ITEM, TEXT("")); <br>        case IDCH_REQUEST: <br>        case IDCH_ADVISE: <br>        case IDCH_UNADVISE: <br>        case IDCH_POKE: <br>            EnableWindow(GetDlgItem(hwnd, IDEF_ITEM), LOWORD(wParam) != IDCH_EXECUTE); <br>            EnableWindow(GetDlgItem(hwnd, IDTX_ITEM), LOWORD(wParam) != IDCH_EXECUTE); <br>            break; <br> <br>        case IDOK: <br>        case IDBN_OPTIONS: <br>            { <br>                INT id; <br> <br>                // set pxact-&gt;wType <br> <br>                for (id = IDCH_REQUEST; id &lt;= IDCH_EXECUTE; id++) { <br>                    if (IsDlgButtonChecked(hwnd, id)) { <br>                        pxact-&gt;wType = id2type[id - IDCH_REQUEST]; <br>                        break; <br>                    } <br>                } <br> <br>                if (LOWORD(wParam) == IDBN_OPTIONS) { <br>                    DoDialog(MAKEINTRESOURCE(IDD_ADVISEOPTS), <br>                            (DLGPROC)AdvOptsDlgProc, (LONG)pxact, TRUE); <br>                    return 0; <br>                } <br> <br>                id = (INT)SendDlgItemMessage(hwnd, IDCB_FORMAT, CB_GETCURSEL, 0, 0); <br>                if (id == LB_ERR) { <br>                    return 0; <br>                } <br>                if (id == CFORMATS) <br>                    pxact-&gt;wFmt = 0; <br>                else <br>                    pxact-&gt;wFmt = aFormats[id].fmt; <br> <br>                if (pxact-&gt;wType == XTYP_ADVSTART) { <br>                    if (pxact-&gt;fsOptions &amp; XOPT_NODATA) <br>                        pxact-&gt;wType |= XTYPF_NODATA; <br>                    if (pxact-&gt;fsOptions &amp; XOPT_ACKREQ) <br>                        pxact-&gt;wType |= XTYPF_ACKREQ; <br>                } <br> <br>                GetDlgItemText(hwnd, IDEF_ITEM, szT, MAX_NAME); <br>                pxact-&gt;hszItem = DdeCreateStringHandle(idInst, szT, 0); <br> <br>                pxact-&gt;hDdeData = 0; <br>                /* <br>                 * If this transaction needs data, invoke data input dialog. <br>                 */ <br>                if (pxact-&gt;wType == XTYP_POKE || pxact-&gt;wType == XTYP_EXECUTE) { <br>                    if (!DoDialog(MAKEINTRESOURCE(IDD_TEXTENTRY), <br>                            (DLGPROC)TextEntryDlgProc, (DWORD)(LPTSTR)pxact, <br>                            TRUE)) <br>                        return 0; <br>                } <br> <br>                // now start the transaction <br> <br>                ProcessTransaction(pxact); <br>                MyFree((PTSTR)pxact); <br>            } <br>            EndDialog(hwnd, 1); <br>            break; <br> <br>        case IDCANCEL: <br>            MyFree((PTSTR)pxact); <br>            EndDialog(hwnd, 0); <br>            break; <br> <br>        default: <br>            return(FALSE); <br>        } <br>        break; <br> <br>    case WM_DESTROY: <br>        break; <br> <br>    default: <br>        return(FALSE); <br>    } <br>    return 0; <br>} <br> <br> <br> <br> <br> <br> <br> <br>/**************************************************************************** <br> *                                                                          * <br> *  FUNCTION   : AdvOptsDlgProc                                             * <br> *                                                                          * <br> *  LIMITATIONS: Because we use Get/SetDlgItemInt() the timeout value used  * <br> *               can't be greater than 65K ms.                              * <br> *                                                                          * <br> *  RETURNS    :                                                            * <br> *                                                                          * <br> ****************************************************************************/ <br>BOOL  APIENTRY AdvOptsDlgProc( <br>HWND          hwnd, <br>UINT msg, <br>WPARAM wParam, <br>LPARAM lParam) <br>{ <br>    static struct { <br>        DWORD id; <br>        DWORD opt; <br>    } id2Opt[] = { <br>        {   IDCH_NODATA        ,   XOPT_NODATA             }   , <br>        {   IDCH_ACKREQ        ,   XOPT_ACKREQ             }   , <br>        {   IDCH_DISABLEFIRST  ,   XOPT_DISABLEFIRST       }   , <br>        {   IDCH_ABANDON       ,   XOPT_ABANDONAFTERSTART  }   , <br>        {   IDCH_BLOCKRESULT   ,   XOPT_BLOCKRESULT        }   , <br>        {   IDCH_ASYNC         ,   XOPT_ASYNC              }   , <br>    }; <br>#define CCHBOX  6 <br>    INT i; <br>    static XACT *pxact; // only one instance at a time!! <br> <br>    switch (msg){ <br>    case WM_INITDIALOG: <br>        pxact = (XACT *)lParam; <br> <br>        for (i = 0; i &lt; CCHBOX; i++) { <br>            CheckDlgButton(hwnd, id2Opt[i].id, pxact-&gt;fsOptions &amp; id2Opt[i].opt); <br>        } <br>        SetDlgItemInt(hwnd, IDEF_TIMEOUT, (DWORD)pxact-&gt;ulTimeout, FALSE); <br>        if (pxact-&gt;wType != XTYP_ADVSTART) { <br>            EnableWindow(GetDlgItem(hwnd, IDCH_NODATA), FALSE); <br>            EnableWindow(GetDlgItem(hwnd, IDCH_ACKREQ), FALSE); <br>        } <br>        SendMessage(hwnd, WM_COMMAND, (WPARAM)MAKELONG(IDCH_ASYNC, 0), (LONG)(0));   // enable async checkboxes <br>        break; <br> <br>    case WM_COMMAND: <br>        switch (LOWORD(wParam)) { <br>        case IDCH_ASYNC: <br>            { <br>                BOOL fEnable; <br> <br>                fEnable = IsDlgButtonChecked(hwnd, IDCH_ASYNC); <br>                EnableWindow(GetDlgItem(hwnd, IDCH_DISABLEFIRST), fEnable); <br>                EnableWindow(GetDlgItem(hwnd, IDCH_ABANDON), fEnable); <br>                EnableWindow(GetDlgItem(hwnd, IDCH_BLOCKRESULT), fEnable); <br>                EnableWindow(GetDlgItem(hwnd, IDEF_TIMEOUT), !fEnable); <br>            } <br>            break; <br> <br>        case IDOK: <br>            pxact-&gt;fsOptions = 0; <br>            for (i = 0; i &lt; CCHBOX; i++) { <br>                if (IsDlgButtonChecked(hwnd, id2Opt[i].id)) <br>                    pxact-&gt;fsOptions |= id2Opt[i].opt; <br>            } <br>            if (!(pxact-&gt;fsOptions &amp; XOPT_ASYNC)) <br>                pxact-&gt;ulTimeout = (DWORD)GetDlgItemInt(hwnd, IDEF_TIMEOUT, <br>                    (BOOL *)&amp;i, FALSE); <br>            // fall through <br>        case IDCANCEL: <br>            EndDialog(hwnd, 0); <br>            break; <br>        } <br>        break; <br> <br>    default: <br>        return(FALSE); <br>    } <br>    return 0; <br>#undef CCHBOX <br>} <br> <br> <br> <br> <br> <br> <br>/**************************************************************************** <br> *                                                                          * <br> *  FUNCTION   : TextEntryDlgProc                                           * <br> *                                                                          * <br> *  PURPOSE    : Allows user to enter text data which is to be sent to a    * <br> *               server.  The user can opt to have a huge text piece of     * <br> *               data created automaticlly.                                 * <br> *               It uses the XACT structure for passing info in and out.    * <br> *               Must have wFmt and hszItem set on entry.                   * <br> *               Sets hDDEData on return if TRUE was returned.              * <br> *                                                                          * <br> *  RETURNS    : TRUE on success, FALSE on failure or cancel                * <br> *                                                                          * <br> ****************************************************************************/ <br>BOOL  APIENTRY TextEntryDlgProc( <br>HWND          hwnd, <br>UINT msg, <br>WPARAM wParam, <br>LPARAM lParam) <br>{ <br>    static XACT FAR *pxact; <br>    DWORD cb; <br>    LONG length; <br>    LPBYTE pData; <br>    BOOL fOwned; <br>    INT id, i; <br> <br>    switch (msg){ <br>    case WM_INITDIALOG: <br>        pxact = (XACT FAR *)lParam; <br>        fOwned = FALSE; <br>        for (i = 0; i &lt; (INT)cOwned; i++) { <br>            if (aOwned[i].wFmt == pxact-&gt;wFmt &amp;&amp; <br>                    aOwned[i].hszItem == pxact-&gt;hszItem) { <br>                fOwned = TRUE; <br>                break; <br>            } <br>        } <br>        EnableWindow(GetDlgItem(hwnd, IDBN_USEOWNED), fOwned); <br>        CheckDlgButton(hwnd, IDCH_MAKEOWNED, 0); <br>        EnableWindow(GetDlgItem(hwnd, IDCH_MAKEOWNED), cOwned &lt; MAX_OWNED); <br>        break; <br> <br>    case WM_COMMAND: <br>        switch (LOWORD(wParam)) { <br>        case IDOK: <br>        case IDBN_GENHUGE: <br>            fOwned = IsDlgButtonChecked(hwnd, IDCH_MAKEOWNED); <br>            cb = (SendDlgItemMessage(hwnd, IDEF_DATA, WM_GETTEXTLENGTH, 0, 0) + 1) * sizeof(TCHAR); <br>            pxact-&gt;hDdeData = DdeCreateDataHandle(idInst, NULL, 0, <br>                    cb, pxact-&gt;hszItem, <br>                    pxact-&gt;wFmt, fOwned ? HDATA_APPOWNED : 0); <br>            if (pxact-&gt;hDdeData == 0) { <br>                MessageBeep(0); <br>                return(0); <br>            } <br>            // <br>            // Note that at this time we have not yet given the data handle <br>            // to DDEML for transmission to any application, therefore, we <br>            // are at liberty to write to it using DdeAccessData() or any <br>            // other DDEML api.  It is only data handles received from DDEML <br>            // or given to DDEML for transmission that are readonly. <br>            // <br>            pData = DdeAccessData(pxact-&gt;hDdeData, NULL); <br>            if (pData == NULL) { <br>                MessageBeep(0); <br>                return(0); <br>            } <br>            GetDlgItemText(hwnd, IDEF_DATA, (LPTSTR)pData, (DWORD)cb); <br>            DdeUnaccessData(pxact-&gt;hDdeData); <br>            if (LOWORD(wParam) == IDBN_GENHUGE) { <br>                TCHAR szT[40]; <br> <br>                /* <br>                 * we assume in this case that the text entered is the decimal <br>                 * value of the size of the huge object desired.  We parse <br>                 * this string and create a randomly generated huge block <br>                 * of text data and place it into pxact-&gt;hDdeData. <br>                 */ <br>                memcpy(szT, pData, min((DWORD)cb, 40)); <br>                szT[39] = TEXT('\0'); <br>                if (_stscanf(szT, TEXT("%ld"), &amp;length) == 1) { <br>                    DdeFreeDataHandle(pxact-&gt;hDdeData); <br>                    pxact-&gt;hDdeData = CreateHugeDataHandle(length, 4325, <br>                            345, 5, pxact-&gt;hszItem, pxact-&gt;wFmt, <br>                            fOwned ? HDATA_APPOWNED : 0); <br>                } else { <br>                    /* <br>                     * The string cannot be parsed.  Inform the user of <br>                     * what is expected. <br>                     */ <br>                    MPError(MB_OK, IDS_BADLENGTH); <br>                    return 0; <br>                } <br>            } <br>            if (fOwned) { <br>                aOwned[cOwned].hData = pxact-&gt;hDdeData; <br>                aOwned[cOwned].hszItem = pxact-&gt;hszItem; <br>                aOwned[cOwned].wFmt = pxact-&gt;wFmt; <br>                cOwned++; <br>            } <br>            EndDialog(hwnd, TRUE); <br>            break; <br> <br>        case IDBN_USEOWNED: <br>            /* <br>             * the user has chosen to use an existing owned data for sending <br>             * to the server. <br>             */ <br>            id = DoDialog(MAKEINTRESOURCE(IDD_HDATAVIEW), (DLGPROC)ViewHandleDlgProc, <br>                    (LONG)pxact, TRUE); <br> <br>            switch (id) { <br>            case IDCANCEL: <br>                return(0); <br> <br>            case IDOK: <br>                EndDialog(hwnd, TRUE); <br> <br>            case IDBN_VIEW: <br>                pData = DdeAccessData(pxact-&gt;hDdeData, NULL); <br>                SetDlgItemText(hwnd, IDEF_DATA, (LPTSTR)pData); <br>                DdeUnaccessData(pxact-&gt;hDdeData); <br>                break; <br>            } <br>            break; <br> <br>        case IDCANCEL: <br>            EndDialog(hwnd, FALSE); <br>            break; <br>        } <br>        break; <br> <br>    default: <br>        return(FALSE); <br>    } <br>} <br> <br> <br> <br>BOOL  APIENTRY ViewHandleDlgProc( <br>HWND          hwnd, <br>UINT msg, <br>WPARAM wParam, <br>LPARAM lParam) <br>{ <br>    static XACT FAR *pxact; <br>    INT i, itm; <br> <br>    switch (msg){ <br>    case WM_INITDIALOG: <br>        pxact = (XACT FAR *)lParam; <br>        // load listbox with handles that fit pxact constraints <br> <br>        for (i = 0; i &lt; (INT)cOwned; i++) { <br>            if (aOwned[i].hszItem == pxact-&gt;hszItem &amp;&amp; <br>                    aOwned[i].wFmt == pxact-&gt;wFmt) { <br>                wsprintf(szT, TEXT("[%d] %lx : length=%ld"), i, aOwned[i].hData, <br>                        DdeGetData(aOwned[i].hData, NULL, 0, 0)); <br>                SendDlgItemMessage(hwnd, IDLB_HANDLES, LB_ADDSTRING, 0, (LONG)(LPTSTR)szT); <br>            } <br>        } <br>        SendDlgItemMessage(hwnd, IDLB_HANDLES, LB_SETCURSEL, 0, 0); <br>        break; <br> <br>    case WM_COMMAND: <br>        switch (LOWORD(wParam)) { <br>        case IDOK:          // use selectted handle <br>        case IDBN_DELETE:   // delete selected handle <br>        case IDBN_VIEW:     // view selected handle <br>            itm = (INT)SendDlgItemMessage(hwnd, IDLB_HANDLES, LB_GETCURSEL, 0, 0); <br>            if (itm != LB_ERR) { <br>                SendDlgItemMessage(hwnd, IDLB_HANDLES, LB_GETTEXT, itm, (LONG)(LPTSTR)szT); <br>                _stscanf(szT, TEXT("[%d]"), &amp;i); <br>                pxact-&gt;hDdeData = aOwned[i].hData; <br>                switch (LOWORD(wParam)) { <br>                case IDOK:          // use selectted handle <br>                    EndDialog(hwnd, LOWORD(wParam)); <br>                    break; <br> <br>                case IDBN_DELETE:   // delete selected handle <br>                    DdeFreeDataHandle(aOwned[i].hData); <br>                    aOwned[i] = aOwned[--cOwned]; <br>                    SendDlgItemMessage(hwnd, IDLB_HANDLES, LB_DELETESTRING, itm, 0); <br>                    if (SendDlgItemMessage(hwnd, IDLB_HANDLES, LB_GETCOUNT, 0, 0) == 0) <br>                        EndDialog(hwnd, IDCANCEL); <br>                    break; <br> <br>                case IDBN_VIEW:     // view selected handle <br>                    EndDialog(hwnd, LOWORD(wParam)); <br>                } <br>            } <br>            break; <br> <br>        case IDCANCEL: <br>            EndDialog(hwnd, FALSE); <br>            break; <br>        } <br>        break; <br> <br>    default: <br>        return(FALSE); <br>    } <br>} <br> <br> <br> <br>BOOL  APIENTRY DelayDlgProc( <br>HWND          hwnd, <br>UINT msg, <br>WPARAM wParam, <br>LPARAM lParam) <br>{ <br>    switch (msg){ <br>    case WM_INITDIALOG: <br>        SetWindowText(hwnd, TEXT("Advise data response time")); <br>        SetDlgItemInt(hwnd, IDEF_VALUE, wDelay, FALSE); <br>        SetDlgItemText(hwnd, IDTX_VALUE, TEXT("Delay in milliseconds:")); <br>        break; <br> <br>    case WM_COMMAND: <br>        switch (LOWORD(wParam)) { <br>        case IDOK: <br>            wDelay = (DWORD)GetDlgItemInt(hwnd, IDEF_VALUE, NULL, FALSE); <br>        case IDCANCEL: <br>            EndDialog(hwnd, 0); <br>            break; <br> <br>        default: <br>            return(FALSE); <br>        } <br>        break; <br> <br>    default: <br>        return(FALSE); <br>    } <br>} <br> <br> <br> <br> <br> <br>/**************************************************************************** <br> *                                                                          * <br> *  FUNCTION   : TimeoutDlgProc()                                           * <br> *                                                                          * <br> *  PURPOSE    : Allows user to alter the synchronous timeout value.        * <br> *                                                                          * <br> *  RETURNS    : TRUE on success, FALSE on cancel or failure.               * <br> *                                                                          * <br> ****************************************************************************/ <br>BOOL  APIENTRY TimeoutDlgProc( <br>HWND          hwnd, <br>UINT msg, <br>WPARAM wParam, <br>LPARAM lParam) <br>{ <br>    switch (msg){ <br>    case WM_INITDIALOG: <br>        SetWindowText(hwnd, TEXT("Synchronous transaction timeout")); <br>        SetDlgItemInt(hwnd, IDEF_VALUE, (INT)DefTimeout, FALSE); <br>        SetDlgItemText(hwnd, IDTX_VALUE, TEXT("Timeout in milliseconds:")); <br>        break; <br> <br>    case WM_COMMAND: <br>        switch (LOWORD(wParam)) { <br>        case IDOK: <br>            DefTimeout = GetDlgItemInt(hwnd, IDEF_VALUE, NULL, FALSE); <br>        case IDCANCEL: <br>            EndDialog(hwnd, 0); <br>            break; <br> <br>        default: <br>            return(FALSE); <br>        } <br>        break; <br> <br>    default: <br>        return(FALSE); <br>    } <br>} <br> <br> <br> <br> <br>BOOL  APIENTRY ContextDlgProc( <br>HWND hwnd, <br>UINT msg, <br>WPARAM wParam, <br>LPARAM lParam) <br>{ <br>    BOOL fSuccess; <br> <br>    switch (msg){ <br>    case WM_INITDIALOG: <br>        SetDlgItemInt(hwnd, IDEF_FLAGS, CCFilter.wFlags, FALSE); <br>        SetDlgItemInt(hwnd, IDEF_COUNTRY, CCFilter.wCountryID, FALSE); <br>        SetDlgItemInt(hwnd, IDEF_CODEPAGE, CCFilter.iCodePage, TRUE); <br>        SetDlgItemInt(hwnd, IDEF_LANG, CCFilter.dwLangID, FALSE); </code></pre>
<p>
</p>
<pre><code>SetDlgItemInt(hwnd, IDEF_SECURITY, CCFilter.dwSecurity, FALSE); <br>        CheckRadioButton(hwnd, IDRB_IL_ANON, IDRB_IL_DELEGATE, <br>                IDRB_IL_ANON + (int)CCFilter.qos.ImpersonationLevel); <br>        return(1); <br>        break; <br> <br>    case WM_COMMAND: <br>        switch (LOWORD(wParam)) { <br>        case IDOK: <br>            CCFilter.wFlags = (WORD)GetDlgItemInt(hwnd, IDEF_FLAGS, &amp;fSuccess, FALSE); <br>            if (!fSuccess) return(0); <br>            CCFilter.wCountryID = (WORD)GetDlgItemInt(hwnd, IDEF_COUNTRY, &amp;fSuccess, FALSE); <br>            if (!fSuccess) return(0); <br>            CCFilter.iCodePage = GetDlgItemInt(hwnd, IDEF_CODEPAGE, &amp;fSuccess, TRUE); <br>            if (!fSuccess) return(0); <br>            CCFilter.dwLangID = (DWORD)GetDlgItemInt(hwnd, IDEF_LANG, &amp;fSuccess, FALSE); <br>            if (!fSuccess) return(0); <br>            CCFilter.dwSecurity = (DWORD)GetDlgItemInt(hwnd, IDEF_SECURITY, &amp;fSuccess, FALSE); <br>            if (!fSuccess) return(0); <br>            if (IsDlgButtonChecked(hwnd, IDRB_IL_ANON)) { <br>                CCFilter.qos.ImpersonationLevel = SecurityAnonymous; <br>            } else if (IsDlgButtonChecked(hwnd, IDRB_IL_ID)) { <br>                CCFilter.qos.ImpersonationLevel = SecurityIdentification; <br>            } else if (IsDlgButtonChecked(hwnd, IDRB_IL_IMP)) { <br>                CCFilter.qos.ImpersonationLevel = SecurityImpersonation; <br>            } else if (IsDlgButtonChecked(hwnd, IDRB_IL_DELEGATE)) { <br>                CCFilter.qos.ImpersonationLevel = SecurityDelegation; <br>            } <br>            // fall through <br>        case IDCANCEL: <br>            EndDialog(hwnd, 0); <br>            break; <br> <br>        default: <br>            return(FALSE); <br>        } <br>        break; <br>    } <br>    return(FALSE); <br>} <br> <br> <br>VOID Delay( <br>DWORD delay) <br>{ <br>    MSG msg; <br> <br>    delay = GetCurrentTime() + delay; <br>    while (GetCurrentTime() &lt; delay) { <br>        if (PeekMessage(&amp;msg,NULL,0,0,PM_REMOVE)) { <br>            TranslateMessage(&amp;msg); <br>            DispatchMessage(&amp;msg); <br>        } <br>    } <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
