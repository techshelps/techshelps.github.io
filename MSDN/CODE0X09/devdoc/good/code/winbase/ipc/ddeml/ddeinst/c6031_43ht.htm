<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DDEADD.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6041"></a>DDEADD.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples.  <br>*       Copyright 1993 - 1998 Microsoft Corporation. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>/* <br> <br>   ddeadd.c <br>   DDEML Execute functions to add selected items <br>   and create new group if specified. <br> <br>*/ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;string.h&gt; <br> <br>#include "ddeinst.h" <br>#include "ddextrn.h"  <br>#include "dialogs.h" <br> <br>CONVCONTEXT   CCFilter = { sizeof (CONVCONTEXT), 0, 0, 0, 0L, 0L }; <br> <br> <br>/******************************************************************** <br> <br>   StartAddThread <br> <br>   Function to Start the program item addition thread. <br> <br>********************************************************************/ <br> <br>BOOL StartAddThread () { <br>   HANDLE hThread; <br>   LONG   lThreadId; <br> <br>   hThread = CreateThread (NULL, 0, (LPTHREAD_START_ROUTINE) AddProgramItems, <br>         "Dummy", CREATE_SUSPENDED | STANDARD_RIGHTS_REQUIRED, &amp;lThreadId); <br>   if (hThread) { <br>      SetThreadPriority (hThread, THREAD_PRIORITY_BELOW_NORMAL); <br>      ResumeThread (hThread); <br> <br>/* Close the handle since we don't need it anymore */ <br> <br>      CloseHandle (hThread); <br>      return (TRUE); <br>   }/*endIf*/ <br>   return (FALSE); <br>}/* end StartAddThread */ <br> <br>/******************************************************************** <br> <br>   CreateGroup <br> <br>   Function that creates a group in the Program Manager. If the specified <br>   name already exists the group is activated. <br> <br>********************************************************************/ <br> <br>BOOL CreateGroup () { <br>   HDDEDATA   hData; <br>   LPSTR      szText; <br>   LPSTR      szCommand; <br>   HCONV      hConv; <br>   HSZ        szProgMan; <br>   LONG       lResult; <br> <br>// Allocate a block of memory for the group name that the user has selected. <br>   szText = VirtualAlloc (NULL, 64, MEM_COMMIT, PAGE_READWRITE); <br> <br>// Allocate a block of memory for the command to send to the Program Manager. <br>   szCommand = VirtualAlloc (NULL, 128, MEM_COMMIT, PAGE_READWRITE); <br>   if (szText) { <br>   // We got the memory so we can proceed. <br> <br>   // Initialize the DDE conversation here. <br> <br>      if (DdeInitialize (&amp;lIdInst, (PFNCALLBACK) GroupDDECallback, <br>            (DWORD) APPCMD_CLIENTONLY, 0L)) { <br>         MessageBox (ghwndMain, "DDEML Initialization Failure", "Error", MB_OK); <br>         VirtualFree (szText, 128, MEM_DECOMMIT); <br>         return (FALSE); <br>      }/*endIf*/ <br> <br>   // Create a DDEML string handle for the Program Manager. <br>      szProgMan = DdeCreateStringHandle (lIdInst, "PROGMAN", CP_WINANSI); <br>      if (szProgMan) { <br> <br>      // String handle created so continue. <br> <br>// Establish a conversation with the Program Manager. <br>         hConv = DdeConnect (lIdInst, szProgMan, szProgMan, &amp;CCFilter); <br> <br>         PostMessage (hwndStatus, WM_USER_UPDATE_STATUS, 0, <br>               ID_DDEML_CONNECT); <br> <br>// Retrieve the text of the combo control. This will return back what the <br>// user has typed in if nothing has been selected. <br>         GetWindowText (hwndCombo, szText, 64); <br> <br>// Find out if this string is in the list or not. If not create a group <br>// Otherwise just activate the group. <br>         lResult = (LONG) SendMessage (hwndCombo, CB_FINDSTRING, (WPARAM) -1, <br>               (LPARAM) (LPCSTR) szText); <br>         if (lResult == CB_ERR) { <br> <br>// Create the group by creating the command line. <br>// The program manager will activate an existing group if the name matches <br>// a DDE attempt to create a new group so the create versus show is somewhat <br>// redundant. <br>            sprintf (szCommand, "[CreateGroup(%s)]", szText); <br> <br>// Create a DDEML data handle for the command. <br>            hData = DdeCreateDataHandle (lIdInst, szCommand, <br>                  strlen (szCommand) + 1, 0, (HSZ) NULL, CF_TEXT, 0L); <br> <br>// Send the transaction to the server waiting a maximum of 10 seconds. <br>// The server will release the data handle. <br>            if (!DdeClientTransaction ((LPBYTE) hData, 0xFFFFFFFF, hConv, <br>                  (HSZ) NULL, 0, XTYP_EXECUTE, 10000, &amp;lResult)) { <br> <br>// If it fails get the error code. <br>               lResult = DdeGetLastError (lIdInst); <br>               MessageBox (NULL, "DdeClientTransaction Failed", "Error", <br>                  MB_OK); <br>            }/*endIf*/ <br> <br>            PostMessage (hwndStatus, WM_USER_UPDATE_STATUS, 0, <br>                  ID_DDEML_CREATE); <br> <br>         } else { <br> <br>// Group already exists so activate it. <br>            sprintf (szCommand, "[ShowGroup(%s,1)]", szText); <br> <br>// Create a DDEML data handle for the command. <br>            hData = DdeCreateDataHandle (lIdInst, szCommand, strlen (szCommand), <br>                  0, (HSZ) NULL, CF_TEXT, 0L); <br> <br>// Send the transaction to the server waiting a maximum of 10 seconds. <br>// The server will release the data handle. <br>            if (!DdeClientTransaction ((LPBYTE) hData, 0xFFFFFFFF, hConv, <br>                  (HSZ) NULL, 0, XTYP_EXECUTE, 10000, &amp;lResult)) { <br> <br>// If it fails get the error code. <br>               lResult = DdeGetLastError (lIdInst); <br>            }/*endIf*/ <br> <br>            PostMessage (hwndStatus, WM_USER_UPDATE_STATUS, 0, <br>                  ID_DDEML_ACTIVATE); <br> <br>         }/*endIf*/ <br> <br>// Release the Program Manager string handle. <br>         DdeFreeStringHandle (lIdInst, szProgMan); <br> <br>// Disconnect from the server. <br>         DdeDisconnect (hConv); <br>         PostMessage (hwndStatus, WM_USER_UPDATE_STATUS, 0, <br>                  ID_DDEML_COMPLETE); <br>      } else { <br>         lResult = DdeGetLastError (lIdInst); <br>      }/*endIf*/ <br> <br>// Free the two blocks of memory that were allocated. <br>      VirtualFree (szText, 64, MEM_DECOMMIT); <br>      VirtualFree (szCommand, 64, MEM_DECOMMIT); <br>      EnableWindow (hwndAddButton, TRUE); <br> <br>   // Uninitialize the conversation here so that resources are freed. <br> <br>      DdeUninitialize (lIdInst); <br>      lIdInst = 0L; <br>      return (TRUE); <br>   } else { <br>      MessageBox (NULL, "Memory Allocation failure", "Error", MB_OK); <br>   }/*endIf*/ <br>   EnableWindow (hwndAddButton, FALSE); <br>   return (FALSE); <br>}/* end CreateGroup */ <br> <br> <br>// Local function <br>void UpdateProgressBar (int, int); <br> <br>// Flag for progress bar update <br>BOOL   fFirst; <br> <br>/******************************************************************** <br> <br>   AddProgramItems <br> <br>   Function that uses DDEML to add program items to group in Program <br>   Manager. <br> <br>********************************************************************/ <br> <br>BOOL AddProgramItems (LPSTR szDummy) { <br>   char      szPercent[8]; <br>   HDDEDATA  hData; <br>   HCONV     hConv; <br>   HSZ       szProgMan; <br>   int       lSelCount; <br>   LONG      lResult; <br>   LPLONG    lpSelection; <br>   LPSTR     szProgName; <br>   LPSTR     szExePath; <br>   LPSTR     szExecuteString; <br>   int       iIndex; <br>   int       iGroupCount; <br> <br>   fFirst = FALSE; <br>   iGroupCount = 2; <br>// Retrieve the number of selected items from the file list. <br>   lSelCount = (int) SendMessage (hwndFileList, LB_GETSELCOUNT, 0, 0L); <br> <br>// Allocate a block of memory to hold the indexes of the list selection. <br>   lpSelection = VirtualAlloc (NULL, lSelCount * sizeof (int), MEM_COMMIT, <br>         PAGE_READWRITE); <br>   if (lpSelection) { <br> <br>// Establish a new conversation. <br>      if (DdeInitialize (&amp;lIdInst2, (PFNCALLBACK) GroupDDECallback, <br>            (DWORD) APPCMD_CLIENTONLY, 0L)) { <br>         VirtualFree (lpSelection, lSelCount * sizeof (int), MEM_DECOMMIT); <br>         return (FALSE); <br>      }/*endIf*/ <br> <br>// Create a DDEML string handle for the Program Manager. <br>      szProgMan = DdeCreateStringHandle (lIdInst2, "PROGMAN", CP_WINANSI); <br> <br>// Establish the conversation. <br>      hConv = DdeConnect (lIdInst2, szProgMan, szProgMan, &amp;CCFilter); <br> <br>      PostMessage (hwndStatus, WM_USER_UPDATE_STATUS, 0, <br>           ID_DDEML_CONNECT); <br> <br> <br>// Release the string handle that we created. <br>      DdeFreeStringHandle (lIdInst2, szProgMan); <br> <br> <br>// Allocate a block of memory to hold the path and name of the item. <br>      szProgName = VirtualAlloc (NULL, MAX_PATH * 2, MEM_COMMIT, <br>            PAGE_READWRITE); <br>      szExePath = szProgName + MAX_PATH; <br> <br>// Allocate some memory to hold the command string. <br>      szExecuteString = VirtualAlloc (NULL, MAX_PATH * 4, MEM_COMMIT, <br>            PAGE_READWRITE); <br> <br>// Retrieve the array of list selections. <br>      SendMessage (hwndFileList, LB_GETSELITEMS, (WPARAM) lSelCount, <br>            (LPARAM) lpSelection); <br> <br>// Loop through the array of selections. <br>      for (iIndex = 0; iIndex &lt; lSelCount; iIndex++) { <br> <br>// Work around for limitation for in ProgMan (no more than 50 items per group) <br>         if (!(iIndex % 50) &amp;&amp; (iIndex &gt; 0)) { <br>            LPSTR      szText; <br>            LPSTR      szText2; <br> <br>         // Allocate a block of memory for the group name  <br>            szText = VirtualAlloc (NULL, 64, MEM_COMMIT, PAGE_READWRITE); <br>            szText2 = VirtualAlloc (NULL, 256, MEM_COMMIT, PAGE_READWRITE); <br>            if (szText &amp;&amp; szText2) { <br>               GetWindowText (hwndCombo, szText, 64); <br>               sprintf (szText2, "[CreateGroup(%s Part %ld )]", szText, <br>                     iGroupCount++); <br> <br>         // Create a DDEML data handle for the command. <br>               hData = DdeCreateDataHandle (lIdInst2, szText2, <br>                  strlen (szText2) + 1, 0, (HSZ) NULL, CF_TEXT, 0L); <br> <br>         // Send the transaction to the server waiting a maximum of 10 seconds. <br>         // The server will release the data handle. <br>               if (!DdeClientTransaction ((LPBYTE) hData, 0xFFFFFFFF, hConv, <br>                     (HSZ) NULL, 0, XTYP_EXECUTE, 10000, &amp;lResult)) { <br>         // If it fails get the error code. <br>                  lResult = DdeGetLastError (lIdInst); <br>                  MessageBox (NULL, "DdeClientTransaction Failed", <br>                        "Error", MB_OK); <br>               }/*endIf*/ <br>               VirtualFree (szText, 64, MEM_DECOMMIT); <br>               VirtualFree (szText2, 256, MEM_DECOMMIT); <br>            } <br>         }/*endIf*/ <br> <br>// Retrieve the Name of the Program Item to add. <br>         SendMessage (hwndFileList2, LB_GETTEXT, (WPARAM) lpSelection[iIndex], <br>               (LPARAM) szProgName); <br> <br>// Set the name in the progress dialog <br>         SetDlgItemText (hwndDialog, IDL_ITEMNAME, szProgName); <br> <br>// Retrieve the absolute path of the item to add. <br>         SendMessage (hwndPathList, LB_GETTEXT, (WPARAM) lpSelection[iIndex], <br>               (LPARAM) szExePath); <br> <br>// Set the path in the progress dialog <br>         SetDlgItemText (hwndDialog, IDL_EXEPATH, szExePath); <br> <br>// Set the percentage in the progress dialog <br>         sprintf (szPercent, "%d%%", (iIndex * 100) / lSelCount); <br>         SetDlgItemText (hwndDialog, IDL_PERCENTAGE, szPercent); <br>         UpdateProgressBar (iIndex + 1, lSelCount); <br> <br>// Create the command string to add the item. <br>         sprintf (szExecuteString, "[AddItem(%s,%s)]", szExePath, <br>               (LPARAM) szProgName); <br> <br>// Create a DDEML Data handle for the command string. <br>         hData = DdeCreateDataHandle (lIdInst2, szExecuteString, <br>               strlen (szExecuteString) + 1, 0, (HSZ) NULL, CF_TEXT, 0L); <br> <br>// Send the command over to the program manager. <br>         if (!DdeClientTransaction ((LPBYTE) hData, 0xFFFFFFFF, <br>               hConv, (HSZ) NULL, 0, XTYP_EXECUTE, 1000, &amp;lResult)) { <br>            lResult = DdeGetLastError (lIdInst2); <br>         }/*endIf*/ <br>      }/*endFor*/ <br> <br>// Release the memory allocated for path and name retrieval. <br>      VirtualFree (szProgName, MAX_PATH * 2, MEM_DECOMMIT); <br> <br>// Release the command line memory. <br>      VirtualFree (szExecuteString, MAX_PATH * 4, MEM_DECOMMIT); <br> <br>// Disoconnect the DDEML Conversation <br>      DdeDisconnect (hConv); <br> <br>// Release the memory allocate for the list selections. <br>      VirtualFree (lpSelection, lSelCount * sizeof (int), MEM_DECOMMIT); <br>   }/*endIf*/ <br> <br>// Clear the selection in the lists. <br> <br>   SendMessage (hwndFileList, LB_SETSEL, (WPARAM) FALSE, (LPARAM) -1); <br>   SendMessage (hwndFileList2, LB_SETSEL, (WPARAM) FALSE, (LPARAM) -1); <br>   EnableWindow (hwndAddAll, FALSE); <br> <br>// Uninitialize the local conversation. <br>   DdeUninitialize (lIdInst2); <br>    <br>   if (hwndDialog) { <br>      PostMessage (ghwndMain, WM_USER_CLOSE_DIALOG, 0, 0L); <br>   }/*endIf*/ <br>   lIdInst2 = 0L; <br>   if (fBatch) { <br>      PostMessage (ghwndMain, WM_COMMAND, (WPARAM) <br>            (WPARAM) MAKELONG (ID_EXITBUTTON, BN_CLICKED), <br>            (LPARAM) hwndExitButton); <br>   }/*endIf*/ <br>   return (TRUE); <br>}/* end AddProgramItems */ <br> <br> <br>HWND   hwndBar; <br>RECT   rc; <br>double iStep; <br>HBRUSH hBrush; <br> <br>/******************************************************************** <br> <br>   UpdateProgressBar <br> <br>   Function to update the progress bar in the dialog while items are <br>   added to the Program Manager. <br> <br>********************************************************************/ <br> <br>void UpdateProgressBar (int iIndex, int iCount) { <br>   HDC  hdc; <br> <br>   if (!fFirst) { <br>      hwndBar = GetDlgItem (hwndDialog, IDL_PROGRESSBAR); <br>      if (hwndBar) { <br>         GetClientRect (hwndBar, &amp;rc); <br>         fFirst = TRUE; <br>      } else { <br>         return; <br>      }/*endIf*/ <br>      iStep = (double) rc.right / (double) iCount; <br>      hBrush = GetStockObject (BLACK_BRUSH); <br>   }/*endIf*/ <br>   hdc = GetDC (hwndBar); <br>   rc.right = (int) (iStep * (double) iIndex); <br>   FillRect (hdc, &amp;rc, hBrush); <br>   ReleaseDC (hwndBar, hdc); <br> <br>   PostMessage (hwndStatus, WM_USER_UPDATE_STATUS, iIndex, ID_DDEML_ADD); <br>}/* end UpdateProgressBar */ <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
