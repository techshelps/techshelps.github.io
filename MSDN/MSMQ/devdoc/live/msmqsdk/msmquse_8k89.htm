<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Reading Messages Using a Cursor</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h3><a name="_mq_reading_messages_using_a_cursor_api"></a>Reading Messages Using a Cursor</h3>
<p>
Cursors allow you to read a message that is not at the front of the queue. The cursor always maintains its position relative to the message to which it points.</p>
<p>
The two functions used to manage the cursor are <a href="mqfunc_3bn6.htm"><b>MQCreateCursor</b></a> and <a href="mqfunc_7v02.htm"><b>MQCloseCursor</b></a>. <b>MQCreateCursor</b> returns a cursor handle that is used in <a href="mqfunc_2cdh.htm"><b>MQReceiveMessage</b></a>, and <b>MQCloseCursor</b> releases the cursor's resources.</p>
<h5><img src="../../images/wedge.gif" border=0>&nbsp;&nbsp;&nbsp;&nbsp;To find a specific message</h5>
<ol>
<li>
Call <a href="mqfunc_42hx.htm"><b>MQOpenQueue</b></a> to open the queue with either receive access or peek access. Opening the queue for receive access allows you to peek at the messages as well as receive them.<pre><code>hr = MQOpenQueue(
    wszFormatNameBuffer,
    MQ_RECEIVE_ACCESS,
    0,
    &amp;hQueue
    );
 </code></pre>
</li>
<li>
Call <a href="mqfunc_3bn6.htm"><b>MQCreateCursor</b></a> to create the cursor.<pre><code>hr = MQCreateCursor(
   hQueue,              //Queue handle
  &amp;hCursor 
  );
 </code></pre>
</li>
<li>
Specify the message properties you want to retrieve.<pre><code>MQMSGPROPS MsgProps;
MQPROPVARIANT aVariant[10];
MSGPROPID aPropId[10];
DWORD PropIdCount = 0;
    
#define MSG_BODY_LEN 500
unsigned char ucMsgBody[MSG_BODY_LEN];
DWORD dwAppspecificIndex;
    
// Set the PROPID_M_BODY property.
aPropId[PropIdCount] = PROPID_M_BODY;               //PropId
aVariant[PropIdCount].vt = VT_VECTOR|VT_UI1;        //Type
aVariant[PropIdCount].caub.cElems = MSG_BODY_LEN;   //Value
aVariant[PropIdCount].caub.pElems = ucMsgBody;
PropIdCount++;
    
//Set the PROPID_M_APPSPECIFIC property.
aPropId[PropIdCount] = PROPID_M_APPSPECIFIC;       //PropId
aVariant[PropIdCount].vt = VT_UI4;                 //Type
dwAppspecificIndex = PropIdCount;
PropIdCount++;
    
//Set the MQMSGPROPS structure.
MsgProps.cProp = PropIdCount;       //Number of properties.
MsgProps.aPropID = aPropId;         //Ids of properties.
MsgProps.aPropVar = aVariant;       //Values of properties.
MsgProps.aStatus  = NULL;           //No Error report.
    </code></pre>
</li>
<li>
Call <a href="mqfunc_2cdh.htm"><b>MQReceiveMessage</b></a> until the message is found.<pre><code>DWORD dwAction = MQ_ACTION_PEEK_CURRENT;  //Peek at first msg.
do 
 {
 hr = MQReceiveMessage(
    hQueue,             // handle to the Queue.
    5 * 60 * 1000,      // Max time (msec) to wait for msg.
    dwAction,           // Action.
    &amp;MsgProps,          // properties to retrieve.
    NULL,               // No overlapped structure.
    NULL,               // No callback function.
    hCursor,            // Cursor handle.
    NULL                // No transaction.
 );
 if (FAILED(hr))
 {
 //  Handle failure
 }
    
 dwAction = MQ_ACTION_PEEK_NEXT;  //Peek at next message.
} while (MsgProps.aPropVar[dwAppspecificIndex].ulVal != 1);
    </code></pre>
</li>
<li>
Call <a href="mqfunc_7v02.htm"><b>MQCloseCursor</b></a> to release the cursor handle's resources.<pre><code>hr = MQCloseCursor(
  hCursor        //Cursor handle
  );
    </code></pre>
</li>
</ol>
<h4>Example</h4>
<p>
The following example locates a message whose application-specific property is equal to 1. It uses MQ_PEEK_CURRENT to look at the first message in the queue and uses MQ_PEEK_NEXT to look at the next message in the queue. MQ_PEEK_NEXT looks at the next message, and then moves the cursor.</p>
<pre><code>HRESULT hr;
QUEUEHANDLE hQueue;


//////////////////////////////////
// Open queue with receive access.
/////////////////////////////////
hr = MQOpenQueue(
    wszFormatNameBuffer,
    MQ_RECEIVE_ACCESS,
    0,
    &amp;hQueue
    );
if (FAILED(hr))
{
//
//  Handle failure
//
}


//////////////////////////////////
// Create the cursor.
/////////////////////////////////
HANDLE hCursor;

hr = MQCreateCursor(
   hQueue,              //Queue handle
  &amp;hCursor 
  );
if (FAILED(hr))
{
//
//  Handle failure
//
}


////////////////////////////////////////
// Specify the message properties you 
// want to retrieve.
///////////////////////////////////////

MQMSGPROPS MsgProps;
MQPROPVARIANT aVariant[10];
MSGPROPID aPropId[10];
DWORD PropIdCount = 0;

#define MSG_BODY_LEN 500
unsigned char ucMsgBody[MSG_BODY_LEN];
DWORD dwAppspecificIndex;

// Set the PROPID_M_BODY property.
aPropId[PropIdCount] = PROPID_M_BODY;               //PropId
aVariant[PropIdCount].vt = VT_VECTOR|VT_UI1;        //Type
aVariant[PropIdCount].caub.cElems = MSG_BODY_LEN;   //Value
aVariant[PropIdCount].caub.pElems = ucMsgBody;
PropIdCount++;

//Set the PROPID_M_APPSPECIFIC property.
aPropId[PropIdCount] = PROPID_M_APPSPECIFIC;       //PropId
aVariant[PropIdCount].vt = VT_UI4;                 //Type
dwAppspecificIndex = PropIdCount;                  //Value
PropIdCount++;

//Set the MQMSGPROPS structure.
MsgProps.cProp = PropIdCount;       //Number of properties.
MsgProps.aPropID = aPropId;         //Ids of properties.
MsgProps.aPropVar = aVariant;       //Values of properties.
MsgProps.aStatus  = NULL;           //No Error report.


///////////////////////////////////
// Peek until you find the message 
// where APPSPECIFIC = 1.
///////////////////////////////////

DWORD dwAction = MQ_ACTION_PEEK_CURRENT;  //Peek at first msg.
do 
 {
 hr = MQReceiveMessage(
    hQueue,             // handle to the Queue.
    5 * 60 * 1000,      // Max time (msec) to wait for msg.
    dwAction,           // Action.
    &amp;MsgProps,          // properties to retrieve.
    NULL,               // No overlapped structure.
    NULL,               // No callback function.
    hCursor,            // Cursor handle.
    NULL                // No transaction.
 );
 if (FAILED(hr))
 {
 //  Handle failure
 break;
 }

 dwAction = MQ_ACTION_PEEK_NEXT;  //Peek at next message.
} while (MsgProps.aPropVar[dwAppspecificIndex].ulVal != 1);

hr = MQCloseCursor(
     hCursor
    );
</code></pre>
<p>&nbsp;</p></body>
</HTML>
