<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Passing Authenticated Messages</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h3><a name="_mq_passing_authenticated_messages"></a>Passing Authenticated Messages</h3>
<p>
To pass authenticated messages between MSMQ and another message queue system, the connector application (both transparent and non-transparent applications) must retrieve all the properties needed for authentication. This includes the property that contains the signature of the sender, the sender's public key, the cryptographic provider needed to verify the signature, the hash algorithm used to create the signature, and all the message properties used in the signature.</p>
<p>
The properties used to authenticate messages are:</p>
<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=49%>Property</th>
<th align=left width=51%>Description</th>
</tr>
<tr valign=top>
<td colspan=2 width=100%></td>
</tr>
<tr valign=top>
<td width=49%><a href="mqprop_1hwl.htm">PROPID_M_SIGNATURE</a></td>
<td width=51%>Contains signature.</td>
</tr>
<tr valign=top>
<td width=49%><a href="mqprop_2nsk.htm">PROPID_M_SENDER_CERT</a></td>
<td width=51%>Contains public key of sender.</td>
</tr>
<tr valign=top>
<td width=49%><a href="mqprop_9tt1.htm">PROPID_M_PROV_NAME</a></td>
<td width=51%>Name of cryptographic provider needed to verify signature.</td>
</tr>
<tr valign=top>
<td width=49%><a href="mqprop_5nfp.htm">PROPID_M_PROV_TYPE</a></td>
<td width=51%>Type of cryptographic provider needed to verify signature.</td>
</tr>
<tr valign=top>
<td width=49%><a href="mqprop_4dpj.htm">PROPID_M_HASH_ALG</a></td>
<td width=51%>Hash algorithm used to create signature.</td>
</tr>
</table><br>
<p>
The properties used in the digital signature include:</p>
<table cellspacing=4 cols=1>
<tr valign=top>
<td width=100%><a href="mqprop_0hwk.htm">PROPID_M_CORRELATIONID</a></td>
</tr>
<tr valign=top>
<td width=100%><a href="mqprop_4gpv.htm">PROPID_M_APPSPECIFIC</a></td>
</tr>
<tr valign=top>
<td width=100%><a href="mqprop_6wzd.htm">PROPID_M_BODY</a></td>
</tr>
<tr valign=top>
<td width=100%><a href="mqprop_9pnw.htm">PROPID_M_LABEL</a></td>
</tr>
<tr valign=top>
<td width=100%><a href="mqprop_204l.htm">PROPID_M_RESP_QUEUE</a></td>
</tr>
<tr valign=top>
<td width=100%><a href="mqprop_0yp1.htm">PROPID_M_ADMIN_QUEUE</a></td>
</tr>
</table><br>
<p>
Transparent connector applications must perform different operations depending on the direction of the messages. If the message is going from the foreign application to MSMQ, the connector application needs to translate new property values and pass the new values on to MSMQ. If the messages are being sent from MSMQ to the other message queue system, the connector application must translate new property values and pass both these and the original values on to the foreign application. The original values are needed to generate the hash value used to authenticate the signature.</p>
<p>
Non-transparent applications perform the security operations (verify signature) so there is no need to pass on security properties. However, the applications do need to indicate that the message was verified when it passes on the message.</p>
<p>
The code needed to perform security operations varies for each application. However, the pseudo-code provided in the following sample shows the basic elements needed to authenticate a message.</p>
<p>
When messages are being sent from another message queue system to MSMQ, non-transparent applications must have access to the <a href="msmqglos_3wvk.htm#_mq_private_signing_key_gly">private signing keys</a> of all the users on the foreign side. The application must compute the message's hash value, encrypt the hash value by applying the user's private signing key, and pass the message on to MSMQ.</p>
<p>
<b>Note</b>&nbsp;&nbsp;For foreign message properties not supported by MSMQ, use <a href="mqprop_8h4e.htm">PROPID_M_EXTENSION</a> and <a href="mqprop_1goe.htm">PROPID_M_EXTENSION_LEN</a>.</p>

<h4><a name="_mq_signature_verification_pseudo_code"></a>Signature Verification Pseudo-code</h4>
<h5><img src="../../images/wedge.gif" border=0>&nbsp;&nbsp;&nbsp;&nbsp;The following code describes the basic elements needed to authenticate a message</h5>
<ol>
<li>
Retrieve cryptographic provider information needed to perform the cryptographic operation required for signature verification.<pre><code>CryptProvName = GetMessageProperty(Message, PROPID_M_PROV_NAME)
CryptProvType = GetMessageProperty(Message, PROPID_M_PROV_TYPE)
 </code></pre>
</li>
<li>
Initialize the crpytographic provider.<pre><code>CryptProvider = AcquireCrpytoraphicConext(
                               CryptProvName,
                               CryptProvType)
 </code></pre>
</li>
<li>
Get the hash algorithm identifier and initialize a hash object. This object is used to perform the hashing and signature-verification operations.<pre><code>HashAlogorithm = GetMessageProperty(Message, PROPID_M_HASH_ALG)
HashObject = GetHashObject(CryptProvider, HashAlogorithm)
 </code></pre>
</li>
<li>
Get the six message properties that are required for calculating the hash value for the message.<pre><code>CorrelationId = GetMessageProperty(Message, PROPID_M_CORRELATIONID)
AppSpecific = GetMessageProperty(Message, PROPID_M_APPSPECIFIC)
MessageBody = GetMessageProperty(Message, PROPID_M_BODY)
MessageLabel = GetMessageProperty(Message,  PROPID_M_LABEL)
RespQueueFormat = GetMessageProperty(Message, PROPID_M_RESP_QUEUE)
AdminQueueFormat = GetMessageProperty(Message,  PROPID_M_ADMIN_QUEUE)
 </code></pre>
</li>
<li>
Compute the hash value for the message by adding (in order) each message property to the hash value. The order in which the properties are added is important. Changing the calculation order of the message properties causes signature verification to fail.<pre><code>HashData(HashObject, CorrelationId)
HashData(HashObject, AppSpecific)
if NotEmpty(MessageBody)
        HashData(HashObject, MessageBody)
if NotEmpty(MessageLabel)
        HashData(HashObject, MessageLabel)
if NotEmpty(RespQueueFormat)
        HashData(HashObject, RespQueueFormat)
if NotEmpty(AdminQueueFormat)
        HashData(HashObject, AdminQueueFormat)
 </code></pre>
</li>
<li>
Get the message signature.<pre><code>MessageSignature = GetMessageProperty(Message, PROPID_M_SIGNATURE)
 </code></pre>
</li>
<li>
Get the sender's certificate.<pre><code>SenderCert = GetMessageProperty(Message, PROPID_M_SENDER_CERT)
 </code></pre>
</li>
<li>
Get the sender's public key out from the sender's certificate.<pre><code>SenderPublicKey = GetPublicKeyFromCertificate(CryptProvider,
                  SenderCert)
 </code></pre>
</li>
<li>
Verify the signature of the message according to the message hash value and the sender's public key.<pre><code>VerifySignature(HashObject, SenderPublicKey, MessageSignature)
 </code></pre>
</li>
</ol>
<p>
The result of the verify signature function indicates whether the signature is valid.</p>
<p>&nbsp;</p></body>
</HTML>
