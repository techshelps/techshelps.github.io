<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Reading Messages in a Dead Letter Queue</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h3><a name="_mq_reading_messages_in_a_dead_letter_queue_api"></a>Reading Messages in a Dead Letter Queue</h3>
<p>
Reading messages in a dead letter queue is typically a three-function operation: a call to <a href="mqfunc_2ysz.htm"><b>MQGetMachineProperties</b></a> to retrieve the local computer identifier (its machine GUID), a call to <a href="mqfunc_42hx.htm"><b>MQOpenQueue</b></a> to open the queue with receive access, and a call to <a href="mqfunc_2cdh.htm"><b>MQReceiveMessage</b></a> to read the message.</p>
<h5><img src="../../images/wedge.gif" border=0>&nbsp;&nbsp;&nbsp;&nbsp;To read a message in a dead letter queue</h5>
<ol>
<li>
Define an MQQMProps structure that includes PROPID_QM_MACHINE_ID.<pre><code>MQQMPROPS QMProps;
MQPROPVARIANT Variant;
MSGPROPID PropId;
GUID    guidMachineId;
    
PropId = PROPID_QM_MACHINE_ID;                 //PropId
Variant.vt = VT_CLSID;                         //Type
Variant.puuid = &amp;guidMachineId;                //Value
    
QMProps.cProp = 1;                //Number of properties.
QMProps.aPropID = &amp;PropId;        //Id of property.
QMProps.aPropVar = &amp;Variant;      //Value of property.
QMProps.aStatus  = NULL;          //No Error report.
 </code></pre>
</li>
<li>
Call <a href="mqfunc_2ysz.htm"><b>MQGetMachineProperties</b></a> to retrieve the machine identifier (PROPID_QM_MACHINE_ID) of the local computer.<pre><code>hr = MQGetMachineProperties(
        NULL,
        NULL,
        &amp;QMProps    
        );
if (FAILED(hr))
 </code></pre>
</li>
<li>
Translate the machine GUID into a string.<pre><code>WCHAR wszMachineGuid[40];
TBYTE* pszUuid = 0;
if(UuidToString(&amp;guidMachineId, &amp;pszUuid) != RPC_S_OK)
{
  //  Handle failure
}
else
{
    wcscpy( wszMachineGuid, pszUuid );
    RpcStringFree(&amp;pszUuid);
}
 </code></pre>
</li>
<li>
Prepare the format name of the dead letter queue.<pre><code>wsprintf( wszFormatNameBuffer,
          L"MACHINE=%s%s",
          wszMachineGuid,
          L";DEADLETTER"
          );
 </code></pre>
</li>
<li>
Call <a href="mqfunc_42hx.htm"><b>MQOpenQueue</b></a> and open the queue with receive access.<pre><code>QUEUEHANDLE hQueue;
    
hr = MQOpenQueue(
    wszFormatNameBuffer,
    MQ_RECEIVE_ACCESS,
    0,
    &amp;hQueue
    );
if (FAILED(hr))
 </code></pre>
</li>
<li>
Define an <b>MQMSGPROPS</b> structure for the message properties to be retrieved.<pre><code>MQMSGPROPS MsgProps;
MQPROPVARIANT aVariant[10];
MSGPROPID aPropId[10];
DWORD PropIdCount = 0;
    
// Prepare property array (PROPVARIANT).
#define MSG_BODY_LEN    500
unsigned char ucMsgBody[MSG_BODY_LEN];
DWORD dwAppspecificIndex;
    
// Set the PROPID_M_BODY property.
aPropId[PropIdCount] = PROPID_M_BODY;                 //PropId
aVariant[PropIdCount].vt = VT_VECTOR|VT_UI1;          //Type
aVariant[PropIdCount].caub.cElems = MSG_BODY_LEN;     //Value
aVariant[PropIdCount].caub.pElems = ucMsgBody;
   
PropIdCount++;
    
// Set the MQMSGPROPS structure
MsgProps.cProp = PropIdCount;       //Number of properties.
MsgProps.aPropID = aPropId;         //Ids of properties.
MsgProps.aPropVar = aVariant;       //Values of properties.
MsgProps.aStatus  = NULL;           //No Error report.
 
 </code></pre>
</li>
<li>
Call <a href="mqfunc_2cdh.htm">MQReceiveMessage</a> and retrieve the messages in the queue. The following call retrieves the first message in the queue.<pre><code>hr = MQReceiveMessage(
     hQueue,               // handle to the Queue.
     5 * 60 * 1000,        // Max time (msec) to wait for message.
     MQ_ACTION_RECEIVE,    // Action.
     &amp;MsgProps,            // properties to retrieve.
    NULL,                  // No overlapped structure.
    NULL,                  // No callback function.
    NULL,                  // NO cursor.
    NULL                   // No transaction
    );
if (FAILED(hr))
 </code></pre>
</li>
</ol>
<h4>Example</h4>
<p>
The following example opens a dead letter queue and retrieves the message body of the first message in the queue. </p>
<pre><code>HRESULT hr;
#define FORMAT_NAME_LEN 80
WCHAR wszFormatNameBuffer[ FORMAT_NAME_LEN];
 
//////////////////////////////////
//  Define an MQQMPROPS structure 
//  for PROPID_QM_MACHINE_ID.
//////////////////////////////////

MQQMPROPS QMProps;
MQPROPVARIANT Variant;
MSGPROPID PropId;
GUID    guidMachineId;

// Set the PROPID_QM_MACHINE_ID property.
PropId = PROPID_QM_MACHINE_ID;                 //PropId
Variant.vt = VT_CLSID;                         //Type
Variant.puuid = &amp;guidMachineId;                //Value

// Set the MQQMPROPS structure
QMProps.cProp = 1;                //Number of properties.
QMProps.aPropID = &amp;PropId;        //Id of properties.
QMProps.aPropVar = &amp;Variant;      //Value of properties.
QMProps.aStatus  = NULL;          //No Error report.


/////////////////////////////////////
//  Retrieving the identifier of the 
//  local computer (machine GUID).
//////////////////////////////////////
hr = MQGetMachineProperties(
       NULL,
       NULL,
       &amp;QMProps 
       );
if (FAILED(hr))
{
    //
    //  Handle failure
    //
}


///////////////////////////////////
//  Translating the machine GUID
//  into a string
//////////////////////////////////
WCHAR wszMachineGuid[40];
WBYTE* pszUuid = 0;
if(UuidToString(&amp;guidMachineId, &amp;pszUuid) != RPC_S_OK)
{
    //
    //  Handle failure
    //
}
else
{
    wcscpy( wszMachineGuid, pszUuid );
    RpcStringFree(&amp;pszUuid);
}


////////////////////////////////
//  Preparing the format name of
//  the dead letter queue.
///////////////////////////////
wsprintf( wszFormatNameBuffer,
          L"MACHINE=%s%s",
          wszMachineGuid,
          L";DEADLETTER"
          );


//////////////////////////////
//  Open the queue for receive
//////////////////////////////

QUEUEHANDLE hQueue;

hr = MQOpenQueue(
    wszFormatNameBuffer,
    MQ_RECEIVE_ACCESS,
    0,
    &amp;hQueue
    );
if (FAILED(hr))
{
    //
    //  Handle failure
    //
}

//////////////////////////////////
//  Define an MQMSGPROPS structure 
//  for the message properties to 
//  be retrieved.
//////////////////////////////////

MQMSGPROPS MsgProps;
MQPROPVARIANT aVariant[10];
MSGPROPID aPropId[10];
DWORD PropIdCount = 0;

// Prepare property array (PROPVARIANT).
#define MSG_BODY_LEN    500
unsigned char ucMsgBody[MSG_BODY_LEN];
DWORD dwAppspecificIndex;

// Set the PROPID_M_BODY property.
aPropId[PropIdCount] = PROPID_M_BODY;                 //PropId
aVariant[PropIdCount].vt = VT_VECTOR|VT_UI1;          //Type
aVariant[PropIdCount].caub.cElems = MSG_BODY_LEN;     //Value
aVariant[PropIdCount].caub.pElems = ucMsgBody;

PropIdCount++;

// Set the MQMSGPROPS structure
MsgProps.cProp = PropIdCount;       //Number of properties.
MsgProps.aPropID = aPropId;         //Ids of properties.
MsgProps.aPropVar = aVariant;       //Values of properties.
MsgProps.aStatus  = NULL;           //No Error report.


/////////////////////////////////////
// Read first message in dead 
// letter queue.
/////////////////////////////////////

hr = MQReceiveMessage(
 hQueue,               // handle to the Queue.
     5 * 60 * 1000,        // Max time (msec) to wait for message.
     MQ_ACTION_RECEIVE,    // Action.
     &amp;MsgProps,            // properties to retrieve.
    NULL,                  // No overlapped structure.
    NULL,                  // No callback function.
    NULL,                  // NO cursor.
    NULL                   // No transaction
    );
if (FAILED(hr))
{
//
//  Handle failure
//
}
 </code></pre>
<p>&nbsp;</p></body>
</HTML>
