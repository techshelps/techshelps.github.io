<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Returning an Acknowledgment Message by a Connector Application</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h2><a name="_mq_returning_an_acknowledgment_message_by_a_connector_application"></a>Returning an Acknowledgment Message by a Connector Application</h2>
<p>
Acknowledgment messages returned by the <a href="msmqglos_3wv7.htm#_mq_connector_application_gly">connector application</a> must be sent to the administration queue specified by the original message. Several properties must be set to the acknowledgment message values shown below, and others should be set to the values specified by the original message.</p>
<p>
The following properties must be set to acknowledgment message values shown below.</p>
<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=56%>Property</th>
<th align=left width=44%>Setting</th>
</tr>
<tr valign=top>
<td width=56%><a href="mqprop_9411.htm">PROPID_M_ACKNOWLEDGE</a></td>
<td width=44%>MQMSG_ACKNOWLEDGMENT_NONE</td>
</tr>
<tr valign=top>
<td width=56%><a href="mqprop_1gz0.htm">PROPID_M_AUTH_LEVEL</a> </td>
<td width=44%>MQMSG_AUTH_LEVEL_NONE</td>
</tr>
<tr valign=top>
<td width=56%><a href="mqprop_6wzd.htm">PROPID_M_BODY</a></td>
<td width=44%>For positive acknowledgments set to NULL. For negative acknowledgments (with the exception of encrypted message bodies), set to the body of the original message.</td>
</tr>
<tr valign=top>
<td width=56%><a href="mqprop_0hwk.htm">PROPID_M_CORRELATIONID</a></td>
<td width=44%>Message identifier of original message.</td>
</tr>
<tr valign=top>
<td width=56%><a href="mqprop_53qr.htm">PROPID_M_CLASS</a> </td>
<td width=44%>Appropriate acknowledgment class.</td>
</tr>
<tr valign=top>
<td width=56%><a href="mqprop_20q4.htm">PROPID_M_JOURNAL</a>  </td>
<td width=44%>MQMSG_JOURNAL_NONE</td>
</tr>
<tr valign=top>
<td width=56%><a href="mqprop_204l.htm">PROPID_M_RESP_QUEUE</a></td>
<td width=44%>Destination queue of the original message.</td>
</tr>
<tr valign=top>
<td width=56%><a href="mqprop_531g.htm">PROPID_M_TIME_TO_BE_RECEIVED</a></td>
<td width=44%>INFINITE</td>
</tr>
<tr valign=top>
<td width=56%><a href="mqprop_8ahx.htm">PROPID_M_TIME_TO_REACH_QUEUE</a>  </td>
<td width=44%>INFINITE</td>
</tr>
</table><br>
<p>
All the other properties are set to the same values as the original message.</p>
<h5><img src="../../images/wedge.gif" border=0>&nbsp;&nbsp;&nbsp;&nbsp;To send an acknowledgment message</h5>
<ol>
<li>
Open the administration queue specified by the original application.<pre><code>hr = MQOpenQueue(lpstrAdminQueue,MQ_SEND_ACCESS,0, &amp;hQueue);
if (FAILED(hr))
{
// Handle failure
// Return hr;
}
</code></pre>
</li>
<li>
Set the acknowledgment default value required by MSMQ.<pre><code>aPropID[cProp] = PROPID_M_CLASS;
aPropVar[cProp].vt = VT_UI2;
aPropVar[cProp].uiVal = AckValue;
cProp++;

aPropID[cProp] = PROPID_M_ACKNOWLEDGE;
aPropVar[cProp].vt = VT_UI1;
aPropVar[cProp].bVal = MQMSG_ACKNOWLEDGMENT_NONE;
cProp++;

aPropID[cProp] = PROPID_M_TIME_TO_BE_RECEIVED;
aPropVar[cProp].vt = VT_UI4;
aPropVar[cProp].ulVal = INFINITE;
cProp++;

aPropID[cProp] = PROPID_M_TIME_TO_REACH_QUEUE;
aPropVar[cProp].vt = VT_UI4;
aPropVar[cProp].ulVal = INFINITE;
cProp++;

aPropID[cProp] = MQMSG_JOURNAL_NONE;
aPropVar[cProp].vt = VT_UI1;
aPropVar[cProp].bVal = pMsgProps-&gt;aPropVar[i].bVal;
cProp++;
</code></pre>
</li>
<li>
Set the remaining message properties. Set PROPID_M_BODY, PROPID_M_CORRELATIONID, PROPID_M_CLASS, and PROPID_M_RESP_QUEUE to the values specified above.</li>
<li>
Set PROPID_M_CONNECTION_TYPE. This tells the application reading the acknowledgment message that the message was not created by MSMQ.<pre><code>aPropID[cProp] = PROPID_M_CONNECTOR_TYPE;
aPropVar[cProp].vt = VT_CLSID;
aPropVar[cProp].puuid = &amp;g_gConnectorType;
cProp++;
 </code></pre>
</li>
<li>
Call <a href="mqfunc_8ip1.htm"><b>MQSendMessage</b></a> to send the message.<pre><code>hr = MQSendMessage(hQueue, &amp;SendMsgProp, NULL);
</code></pre>
</li>
</ol>
<h4>Example</h4>
<p>
The following example creates an acknowledgment message and sends it back to the administration queue specified by the original message. It assumes that the format name of the administration queue (<i>lpstrAdimQueue</i>), all original message properties (<i>pMsgProps</i>), and the value of the acknowledgment (<i>ackValue</i>) are all available.</p>
<pre><code>HRESULT CreateAck(LPWSTR lpstrAdminQueue,
                 USHORT AckValue,
                 MQMSGPROPS* pMsgProps
                 )

{
MQMSGPROPS SendMsgProp;
MSGPROPID     aPropID[40];
MQPROPVARIANT  aPropVar[40];
HRESULT        aStatus[40];
HRESULT        hr;
HANDLE hQueue = NULL;
DWORD cProp = 0;
 
//////////////////////////////////
// Open the administration queue 
// specified by the original message.
/////////////////////////////////
hr = MQOpenQueue(lpstrAdminQueue,MQ_SEND_ACCESS,0, &amp;hQueue);
if (FAILED(hr))
{
// Handle failure
// Return hr;
}

DWORD dwExtensionMsgSize = 0;
DWORD dwSenderidLen = 0;
DWORD dwBodySize = 0;
BOOL fEncrypted = FALSE;
DWORD i;


//////////////////////////////////////////////////
// Set the acknowledgment message default values.
//////////////////////////////////////////////////
aPropID[cProp] = PROPID_M_CLASS;
aPropVar[cProp].vt = VT_UI2;
aPropVar[cProp].uiVal = AckValue;
cProp++;

aPropID[cProp] = PROPID_M_ACKNOWLEDGE;
aPropVar[cProp].vt = VT_UI1;
aPropVar[cProp].bVal = MQMSG_ACKNOWLEDGMENT_NONE;
cProp++;

aPropID[cProp] = PROPID_M_TIME_TO_BE_RECEIVED;
aPropVar[cProp].vt = VT_UI4;
aPropVar[cProp].ulVal = INFINITE;
cProp++;

aPropID[cProp] = PROPID_M_TIME_TO_REACH_QUEUE;
aPropVar[cProp].vt = VT_UI4;
aPropVar[cProp].ulVal = INFINITE;
cProp++;

aPropID[cProp] = MQMSG_JOURNAL_NONE;
aPropVar[cProp].vt = VT_UI1;
aPropVar[cProp].bVal = pMsgProps-&gt;aPropVar[i].bVal;
cProp++;


//////////////////////////////////////
// Set all other message properties to 
// the values of the original message.
//////////////////////////////////////


// Get size and length of properties.

for (i = 0; i &lt; pMsgProps-&gt;cProp ; i++)
{
switch(pMsgProps-&gt;aPropID[i])
{
    case PROPID_M_EXTENSION:
         dwExtensionMsgSize = pMsgProps-&gt;aPropVar[i].ulVal;    
         break;
         
    case PROPID_M_SENDERID_LEN:
         dwSenderidLen = pMsgProps-&gt;aPropVar[i].ulVal;
         break;
         
    case PROPID_M_BODY_SIZE:
         dwBodySize = pMsgProps-&gt;aPropVar[i].ulVal;
         break;
         
    case PROPID_M_PRIV_LEVEL:
         fEncrypted = (pMsgProps-&gt;aPropVar[i].ulVal == MQMSG_PRIV_LEVEL_BODY);
            break;
             
             default:
             break;
   }
}

for (i = 0; i &lt; pMsgProps-&gt;cProp ; i++)
{
switch (pMsgProps-&gt;aPropID[i])
{

         // Set correlation identifier 
        case PROPID_M_MSGID:
            aPropID[cProp] = PROPID_M_CORRELATIONID;
            aPropVar[cProp].vt = VT_UI1|VT_VECTOR;
            aPropVar[cProp].caub.cElems = pMsgProps-&gt;aPropVar[i].caub.cElems;
            aPropVar[cProp].caub.pElems = pMsgProps-&gt;aPropVar[i].caub.pElems;
            cProp++;
            break;
        
        // Set message priority.
        case PROPID_M_PRIORITY:
            aPropID[cProp] = PROPID_M_PRIORITY;
            aPropVar[cProp].vt = VT_UI1;
            aPropVar[cProp].bVal = pMsgProps-&gt;aPropVar[i].bVal;
            cProp++;
            break;
        
        // Set delivery mode.
        case PROPID_M_DELIVERY:
            aPropID[cProp] = PROPID_M_DELIVERY;
            aPropVar[cProp].vt = VT_UI1;
            aPropVar[cProp].bVal = pMsgProps-&gt;aPropVar[i].bVal;
            cProp++;
            break;
        
        // Set application specific information
       case PROPID_M_APPSPECIFIC:
            aPropID[cProp] = PROPID_M_APPSPECIFIC;
            aPropVar[cProp].vt = VT_UI4;
            aPropVar[cProp].ulVal = pMsgProps-&gt;aPropVar[i].ulVal;
            cProp++;
            break;
        
        // Set message label to the same 
        case PROPID_M_LABEL:
            aPropID[cProp] = PROPID_M_LABEL;
            aPropVar[cProp].vt = VT_LPWSTR;
            aPropVar[cProp].pwszVal = pMsgProps-&gt;aPropVar[i].pwszVal;
                cProp++;
                break;
            //
            
        // Set extension information.
        case PROPID_M_EXTENSION:
            aPropID[cProp] = PROPID_M_EXTENSION;
            aPropVar[cProp].vt = VT_UI1|VT_VECTOR;
            aPropVar[cProp].caub.cElems = dwExtensionMsgSize;
            aPropVar[cProp].caub.pElems = pMsgProps-&gt;aPropVar[i].caub.pElems;
                cProp++;
                break;
        
        // Set acknowledge message response queue to 
        // the destination queue of the original message.
        case PROPID_M_DEST_QUEUE:
            aPropID[cProp] = PROPID_M_RESP_QUEUE;
            aPropVar[cProp].vt = VT_LPWSTR;
            aPropVar[cProp].pwszVal = pMsgProps-&gt;aPropVar[i].pwszVal;
            cProp++;           
            break;
        
        //////////////////////////////////////////////
        // Set message body. If acknowledge is negative 
        // and the original message isn't encrypted, add 
        // message body of original message.
        //////////////////////////////////////////////
        case PROPID_M_BODY:
            if (MQCLASS_NACK(AckValue) &amp;&amp; ! fEncrypted)
            {
                aPropID[cProp] = PROPID_M_BODY;
                aPropVar[cProp].vt = VT_UI1|VT_VECTOR;
                aPropVar[cProp].caub.cElems = dwBodySize;
                aPropVar[cProp].caub.pElems = pMsgProps-&gt;aPropVar[i].caub.pElems;
                cProp++;
            }
            break;

        default:
            break;
    }
}


//////////////////////////////////////////////////
// Set the connector type identifier (GUID) to 
// indicate who generated the acknowledge message.
//////////////////////////////////////////////////
aPropID[cProp] = PROPID_M_CONNECTOR_TYPE;
aPropVar[cProp].vt = VT_CLSID;
aPropVar[cProp].puuid = &amp;g_gConnectorType;
cProp++;

SendMsgProp.aStatus = aStatus;
SendMsgProp.aPropID = aPropID;
SendMsgProp.aPropVar = aPropVar;
SendMsgProp.cProp =cProp;


////////////////////////////////////////////////
// Send the acknowledge message back to the 
// administration queue specified by the 
// original message.
/////////////////////////////////////////////////
hr = MQSendMessage(hQueue, &amp;SendMsgProp, NULL);

MQCloseQueue(hQueue);

return hr;
}
 </code></pre>
<p>&nbsp;</p></body>
</HTML>
