<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Reading Messages Asynchronously</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h3><a name="_mq_reading_messages_asynchronously_api"></a>Reading Messages Asynchronously</h3>
<p>
Applications can use a callback function, a Windows Event mechanism, or a Microsoft® Windows NT® completion port to read messages asynchronously. When reading messages asynchronously, the application is notified if a message is available or if a timeout has occurred. </p>
<p>
For information, see <a href="mqfunc_2cdh.htm"><b>MQReceiveMessage</b></a>.</p>
<p>
<b>Note</b>&nbsp;&nbsp;In the following two examples, the first uses a callback function to retrieve the messages, and the second uses a Windows Event mechanism. Both examples read the first message in the queue.</p>
<h5><img src="../../images/wedge.gif" border=0>&nbsp;&nbsp;&nbsp;&nbsp;To read a message asynchronously using a callback function</h5>
<ol>
<li>
Write the callback function. <pre><code>void APIENTRY ReceiveCallbackRoutine(
    HRESULT hrStatus,
    QUEUEHANDLE hSource,
    DWORD dwTimeout,
    DWORD dwAction,
    MQMSGPROPS* pMessageProps,
    LPOVERLAPPED lpOverlapped,
    HANDLE hCursor
)
 {
   // Process message.
 }
</code></pre>
</li>
<li>
Open the queue with receive or peek access. If the queue is opened with receive access, the application can still peek at the messages in the queue.<pre><code>hr = MQOpenQueue(
    szwFormatNameBuffer,    // Format name of the queue.
    MQ_RECEIVE_ACCESS,      // Access rights to the queue.
    0,                      // No receive Exclusive.
    &amp;hQueue                 // OUT: handle to the opened queue.
               );
 </code></pre>
</li>
<li>
Specify the message properties to be retrieved, retrieving only those properties that are needed. For example, if you only need to look at the body of the message, only specify <a href="mqprop_6wzd.htm">PROPID_M_BODY</a>.<pre><code>// Set the PROPID_M_BODY property.
paPropId[dwPropIdCount] = PROPID_M_BODY;                //PropId
paVariant[dwPropIdCount].vt = VT_VECTOR|VT_UI1;         //Type
paVariant[dwPropIdCount].caub.cElems = MSG_BODY_LEN ;   //Value
paVariant[dwPropIdCount].caub.pElems = new unsigned char[ MSG_BODY_LEN];
 
 dwPropIdCount++;
 </code></pre>
</li>
<li>
Set the <b>MQMSGPROPS</b> structure.<pre><code>// Set the MQMSGPROPS structure.
MsgProps.cProp = PropIdCount;       //Number of properties.
MsgProps.aPropID = aPropId;         //Ids of properties.
MsgProps.aPropVar = aVariant;       //Values of properties.
MsgProps.aStatus  = NULL;           //No Error report.
 </code></pre>
</li>
<li>
Read message from the queue, using ReceiveCallbackRoutine as the callback function.<pre><code>hr = MQReceiveMessage(
    hQueue,                     // handle to the Queue.
    5 * 60 * 1000,              // Max time (msec) to wait.
    MQ_ACTION_RECEIVE,          // Action.
    pMsgProps,                  // Properties to retrieve.
    NULL,                       // No overlapped structure.
    ReceiveCallbackRoutine,     // Callback function.
    NULL,                       // No Cursor.
    NULL                        // No transaction
              );
 </code></pre>
</li>
</ol>
<h4>Callback Function Example</h4>
<p>
The following example specifies a callback function, opens a queue with receive access, specifies the body of the message as the only message property to retrieve, and reads the first message of the queue using the callback function.</p>
<pre><code>//////////////////////////////
// Receive callback function.
/////////////////////////////
 
void APIENTRY ReceiveCallbackRoutine(
   HRESULT hr,
   QUEUEHANDLE hSource,
   DWORD dwTimeout,
   DWORD dwAction,
   MQMSGPROPS* pMessageProps,
   LPOVERLAPPED lpOverlapped,
   HANDLE hCursor
  )
 {
  if (FAILED(hr))
   {
    // Error handler for Callback routine.
   }
  else
  {
   // Process message.
  }
 }

//////////////
// Open Queue
//////////////
 
HRESULT hr;
QUEUEHANDLE hQueue;
 
hr = MQOpenQueue(
     szwFormatNameBuffer,    // Format Name of the queue to be opened.
     MQ_RECEIVE_ACCESS,      // Access rights to the Queue.
     0,                      // No receive Exclusive.
     &amp;hQueue                 // OUT: handle to the opened Queue.
);
 
if (FAILED(hr))
{
 // Error handler for MQOpenQueue.
}
 
 
MQMSGPROPS * pMsgProps;
MQPROPVARIANT *paVariant;
MSGPROPID * paPropId;
DWORD dwPropIdCount = 0;
 
//
//  The output parameters to an asynchronous call to MQReceiveMessage 
//  should be kept intact until the operation completes, you should 
//  not free or reuse them until the operation is complete.
//
pMsgProps = new MQMSGPROPS;
paVariant = new MQPROPVARIANT[ 10];
paPropId = new MSGPROPID[ 10];
 
    
//////////////////////////////////////////////////
// Prepare the message properties to be retrieved.
/////////////////////////////////////////////////
 
 
// Set the PROPID_M_BODY property.
paPropId[dwPropIdCount] = PROPID_M_BODY;                //PropId
paVariant[dwPropIdCount].vt = VT_VECTOR|VT_UI1;         //Type
paVariant[dwPropIdCount].caub.cElems = MSG_BODY_LEN ;    //Value
paVariant[dwPropIdCount].caub.pElems = new unsigned char[ MSG_BODY_LEN];
 
 dwPropIdCount++;
 
////////////////////////////////
// Set the MQMSGPROPS structure
///////////////////////////////
pMsgProps-&gt;cProp = dwPropIdCount;     //Number of properties.
pMsgProps-&gt;aPropID = paPropId;        //Ids of properties.
pMsgProps-&gt;aPropVar = paVariant;      //Values of properties.
pMsgProps-&gt;aStatus  = NULL;           //No Error report.
 
 
///////////////////////////////////////////////
//  Receive the message using callback function
//  ReceiveCallbackRoutine.
///////////////////////////////////////////////
 
hr = MQReceiveMessage(
    hQueue,                     // handle to the Queue.
    5 * 60 * 1000,              // Max time (msec) to wait.
    MQ_ACTION_RECEIVE,          // Action.
    pMsgProps,                  // properties to retrieve.
    NULL,                       // No overlapped structure.
    ReceiveCallbackRoutine,     // Callback function.
    NULL,                       // No Cursor.
    NULL                        // No transaction
              );
 
if (FAILED(hr))
   {
     //  Error handler for MQReceiveMessage.
    }
 </code></pre>
<h5><img src="../../images/wedge.gif" border=0>&nbsp;&nbsp;&nbsp;&nbsp;To read a message asynchronously using a Windows Event mechanism</h5>
<ol>
<li>
Open the queue with receive or peek access. The access mode used to open the queue does not determine how the messages are read from the queue. For example, if the queue is opened with receive access, the application can still peek at the messages in the queue.<pre><code>hr = MQOpenQueue(
    szwFormatNameBuffer,    // Format name of the queue.
    MQ_RECEIVE_ACCESS,      // Access rights to the Queue.
    0,                      // No receive Exclusive.
    &amp;hQueue                 // OUT: handle to the opened Queue.
               );
 </code></pre>
</li>
<li>
Specify the message properties to be retrieved. If you only need to look at the body of the message, only specify <a href="mqprop_6wzd.htm">PROPID_M_BODY</a>.<pre><code>// Set the PROPID_M_BODY property.
paPropId[dwPropIdCount] = PROPID_M_BODY;                //PropId
paVariant[dwPropIdCount].vt = VT_VECTOR|VT_UI1;         //Type
paVariant[dwPropIdCount].caub.cElems = MSG_BODY_LEN ;   //Value
paVariant[dwPropIdCount].caub.pElems = new unsigned char[ MSG_BODY_LEN];
 
 dwPropIdCount++;
 </code></pre>
</li>
<li>
Set the <b>MQMSGPROPS</b> structure.<pre><code>// Set the MQMSGPROPS structure.
MsgProps.cProp = PropIdCount;       //Number of properties.
MsgProps.aPropID = aPropId;         //Ids of properties.
MsgProps.aPropVar = aVariant;       //Values of properties.
MsgProps.aStatus  = NULL;           //No Error report.
 </code></pre>
</li>
<li>
Create the Event object using overlapped structure.<pre><code>OVERLAPPED *pov = new OVERLAPPED ;
pov-&gt;hEvent = CreateEvent(0, TRUE, TRUE, 0);
 </code></pre>
</li>
<li>
Read the message from the queue.<pre><code>hr = MQReceiveMessage(
    hQueue,                     // handle to the Queue.
    5 * 60 * 1000,              // Max time (msec) to wait.
    MQ_ACTION_RECEIVE,          // Action.
    pMsgProps,                  // Properties to retrieve.
    pov,                        // Overlapped structure.
    NULL,                       // Callback function.
    NULL,                       // No Cursor.
    NULL                        // No transaction
              );
 </code></pre>
</li>
<li>
Write Windows Event handler (typically a separate thread) and close the handle to the overlapped structure.<pre><code>if(hr == MQ_INFORMATION_OPERATION_PENDING)
{
    WaitForSingleObject(pov-&gt;hEvent, INFINITE);
//
// Parse recieved results
//
}
 
CloseHandle(pov-&gt;hEvent);
 </code></pre>
</li>
</ol>
<h4>Windows Event Mechanism Example</h4>
<p>
The following example opens a queue with receive access, specifies the body of the message as the only message property to retrieve, and uses a Windows Event mechanism to read the first message of the queue.</p>
<pre><code>//////////////
// Open Queue
//////////////
 
HRESULT hr;
QUEUEHANDLE hQueue;
 
hr = MQOpenQueue(
     szwFormatNameBuffer,    // Format Name of the queue to be opened.
     MQ_RECEIVE_ACCESS,      // Access rights to the Queue.
     0,                      // No receive Exclusive.
     &amp;hQueue                 // OUT: handle to the opened Queue.
                );
 
if (FAILED(hr))
{
 // Error handler for MQOpenQueue.
}
 

MQMSGPROPS * pMsgProps;
MQPROPVARIANT *paVariant;
MSGPROPID * paPropId;
DWORD dwPropIdCount = 0;
 
//
//  The output parameters of an asynchronous call to MQReceiveMessage 
//  should be kept intact until the operation completes, you cannot
//  free them or reuse them.
//
pMsgProps = new MQMSGPROPS;
paVariant = new MQPROPVARIANT[ 10];
paPropId = new MSGPROPID[ 10];
 
 
//////////////////////////////////////////////////
// Prepare the message properties to be retrieved.
/////////////////////////////////////////////////
 
 
// Set the PROPID_M_BODY property.
paPropId[dwPropIdCount] = PROPID_M_BODY;                //PropId
paVariant[dwPropIdCount].vt = VT_VECTOR|VT_UI1;         //Type
paVariant[dwPropIdCount].caub.cElems = MSG_BODY_LEN ;    //Value
paVariant[dwPropIdCount].caub.pElems = new unsigned char[ MSG_BODY_LEN];
 
 dwPropIdCount++;
 
 
////////////////////////////////
// Set the MQMSGPROPS structure
///////////////////////////////
 
pMsgProps-&gt;cProp = dwPropIdCount;     //Number of properties.
pMsgProps-&gt;aPropID = paPropId;        //Ids of properties.
pMsgProps-&gt;aPropVar = paVariant;      //Values of properties.
pMsgProps-&gt;aStatus  = NULL;           //No Error report.
 
 
/////////////////////////////////////////
//  Create Event object using overlapped
//  structure.
/////////////////////////////////////////
 
OVERLAPPED *pov = new OVERLAPPED ;
pov-&gt;hEvent = CreateEvent(0, TRUE, TRUE, 0);
 
 
/////////////////////////////////////////
//  Retrieve the message using overlapped 
//  structure.
/////////////////////////////////////////
 
hr = MQReceiveMessage(
    hQueue,                     // handle to the Queue.
    5 * 60 * 1000,              // Max time (msec) to wait.
    MQ_ACTION_RECEIVE,          // Action.
    pMsgProps,                  // properties to retrieve.
    pov,                        // Overlapped structure.
    NULL,                       // No callback function.
    NULL,                       // No Cursor.
    NULL                        // No transaction
              );
 
if (FAILED(hr))
    {
        //  Error handler for MQReceiveMessage.
    }
 
 
//////////////////////////////
// Windows Event handler.
//////////////////////////////
 
if (hr == MQ_INFORMATION_OPERATION_PENDING)
    {
        WaitForSingleObject(pov-&gt;hEvent, INFINITE);
    //
    // Parse recieved results
    //
    }
 
CloseHandle(pov-&gt;hEvent);
delete paVariant;  //Free resources.
delete paPropId;  
 </code></pre>
<p>&nbsp;</p></body>
</HTML>
