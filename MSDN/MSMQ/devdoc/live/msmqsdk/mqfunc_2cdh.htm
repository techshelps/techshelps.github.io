<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>MQReceiveMessage</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_mq_mqreceivemessage"></a>MQReceiveMessage</h1>
<p>
The <b>MQReceiveMessage</b> function allows you to read messages in the queue. When reading messages, you can either peek at (not removing them) or retrieve the messages (removing them) in the queue.</p>
<p>
Messages can be read either synchronously, asynchronously, or through a transaction.</p>
<pre><code><b>HRESULT APIENTRY MQReceiveMessage(
  QUEUEHANDLE</b><i> hSource</i><b>,                   </b>
<b>  DWORD</b><i> dwTimeout</i><b>,                       </b>
<b>  DWORD</b><i> dwAction</i><b>,                        </b>
<b>  MQMSGPROPS </b><i>pMessageProps</i><b>,              </b>
<b>  LPOVERLAPPED</b><i> lpOverlapped</i><b>,             </b>
<b>  PMQRECEIVECALLBACK</b><i> fnReceiveCallback</i><b>,  </b>
<b>  HANDLE</b><i> hCursor</i><b>,                        </b>
<b>  Transaction </b><i>*pTransaction              </i>
<b>);</b>
 </code></pre>
<h4>Parameters</h4>
<dl>
<dt>
<i>hSource</i></dt>
<dd>
[in] Handle to the queue that contains the message. For transactions, specify a queue on a local computer.</dd>
<dt>
<i>dwTimeout</i></dt>
<dd>
[in] Time, in milliseconds, to wait for the message. Can be set to INFINITE. </dd>
<dt>
<i>dwAction</i></dt>
<dd>
[in] How the message is read in the queue. Specify one of the following:
<dl>
<dt>
MQ_ACTION_RECEIVE</dt>
<dd>
Reads the message at the current cursor location and removes it from the queue.</dd>
<dt>
MQ_ACTION_PEEK_CURRENT</dt>
<dd>
Reads the message at the current cursor location but does not remove it from the queue. The cursor remains pointing at the current message.
<p>
If a cursor was not created by <a href="mqfunc_3bn6.htm"><b>MQCreateCursor</b></a> (<i>hCursor</i> is NULL), the queue's cursor can only point to the first message in the queue.
</dd>
<dt>
MQ_ACTION_PEEK_NEXT</dt>
<dd>
Reads the next message in the queue (skipping the message at the current cursor location) but does not remove it from the queue.
<p>
<a href="mqfunc_3bn6.htm"><b>MQCreateCursor</b></a> must be called (<i>hCursor</i> is not NULL) before MQ_ACTION_PEEK_NEXT can be used.
</dd>
</dl>
</dd>
<dt>
<i>pMessageProps</i></dt>
<dd>
[in, out] On input, a pointer to an <a href="mqstruc_559v.htm"><b>MQMSGPROPS</b></a> structure that specifies which message properties will be received. Can be set to NULL.
<p>
On output, it contains the received message property values.
</dd>
<dt>
<i>lpOverlapped</i></dt>
<dd>
[in, out] Pointer to an <b>Overlapped</b> structure. Set to NULL for synchronous receive and transactions.</dd>
<dt>
<i>fnReceiveCallback</i></dt>
<dd>
[in] Pointer to the callback function. Set to NULL for synchronous receive and transactions. For information on using a callback function, see the callback example in <a href="msmquse_9ii1.htm">Reading Messages Asynchronously</a>.</dd>
<dt>
<i>hCursor</i></dt>
<dd>
[in] Handle to cursor for looking at messages in the queue. Can be set to NULL. See the following Remarks section.</dd>
<dt>
<i>pTransaction</i></dt>
<dd>
[in] Must be a pointer to a transaction object, a constant, or NULL.
<p>
Transaction object can be obtained internally from MSMQ (by calling <a href="mqfunc_2xta.htm"><b>MQBeginTransaction</b></a>), or externally from Microsoft® DTC (Distributed Transaction Coordinator).

<p>
Constants include: 

<dl>
<dt>
MQ_NO_TRANSACTION</dt>
<dd>
Specifies that the call is not part of a transaction.</dd>
<dt>
MQ_MTS_TRANSACTION</dt>
<dd>
Specifies that the current MTS (Microsoft® Transaction Server) transaction is used to retrieve the message.</dd>
<dt>
MQ_XA_TRANSACTION</dt>
<dd>
Specifies that the call is part of an externally coordinated, XA-compliant transaction.</dd>
</dl>

<p>
NULL indicates the message is not retrieved as part of a transaction.

</dd>
</dl>
<h4>Return Values</h4>
<dl>
<dt>
MQ_OK</dt>
<dd>
Indicates success.</dd>
<dt>
MQ_ERROR_ACCESS_DENIED</dt>
<dd>
The action specified in <i>dwAction</i> does not agree with the access rights the queue was opened with.</dd>
<dt>
MQ_ERROR_BUFFER_OVERFLOW</dt>
<dd>
The supplied buffer for the message body is too small. The part of the message body that fits into the buffer is copied, but the message is not removed from the queue.</dd>
<dt>
MQ_ERROR_SENDERID_BUFFER_TOO_SMALL</dt>
<dd>
The supplied sender identification buffer is too small to hold the sender identification.</dd>
<dt>
MQ_ERROR_SYMM_KEY_BUFFER_TOO_SMALL</dt>
<dd>
The supplied symmetric key buffer is too small to hold the symmetric key.</dd>
<dt>
MQ_ERROR_SENDER_CERT_BUFFER_TOO_SMALL</dt>
<dd>
The supplied sender certificate buffer is too small to hold the security certificate.</dd>
<dt>
MQ_ERROR_SIGNATURE_BUFFER_TOO_SMALL</dt>
<dd>
The supplied signature buffer is too small to hold the message's digital signature.</dd>
<dt>
MQ_ERROR_PROV_NAME_BUFFER_TOO_SMALL</dt>
<dd>
The supplied provider name buffer is too small to hold the cryptographic service provider's name.</dd>
<dt>
MQ_ERROR_LABEL_BUFFER_TOO_SMALL</dt>
<dd>
The supplied message label buffer is too small to hold the message's label.</dd>
<dt>
MQ_ERROR_FORMATNAME_BUFFER_TOO_SMALL</dt>
<dd>
The supplied format name buffer is too small to hold the format name of the queue.</dd>
<dt>
MQ_ERROR_DTC_CONNECT</dt>
<dd>
MSMQ was unable to connect to the MS DTC.</dd>
<dt>
MQ_ERROR_INSUFFICIENT_PROPERTIES</dt>
<dd>
One of the following message properties was specified (in <i>pMessageProps</i>) without its associated length property: <a href="mqprop_0yp1.htm">PROPID_M_ADMIN_QUEUE</a>, <a href="mqprop_1let.htm">PROPID_M_DEST_QUEUE</a>, <a href="mqprop_9pnw.htm">PROPID_M_LABEL</a>, <a href="mqprop_204l.htm">PROPID_M_RESP_QUEUE</a>,<a href="mqprop_30dh.htm"> PROPID_M_XACT_STATUS_QUEUE</a>, or <a href="mqprop_9tt1.htm">PROPID_M_PROV_NAME</a>.</dd>
<dt>
MQ_ERROR_INVALID_HANDLE</dt>
<dd>
The queue handle specified in <i>hSource</i> is not valid.</dd>
<dt>
MQ_ERROR_IO_TIMEOUT</dt>
<dd>
No message was received within the time-out period specified by <i>dwTimeout</i>.</dd>
<dt>
MQ_ERROR_MESSAGE_ALREADY_RECEIVED</dt>
<dd>
A message that is currently pointed at by the cursor has been removed from the queue. It can be removed by another process or by another call to <b>MQReceiveMessage</b> using a different cursor, or the message <i>time-to-be-received</i> timer has expired.</dd>
<dt>
MQ_ERROR_OPERATION_CANCELLED</dt>
<dd>
The operation was canceled before it could be completed. For example, the queue handle was closed by another thread while waiting for a message.</dd>
<dt>
MQ_ERROR_PROPERTY</dt>
<dd>
One or more message properties specified in <i>pMessageProps</i> resulted in an error.</dd>
<dt>
MQ_ERROR_QUEUE_DELETED</dt>
<dd>
The queue was deleted before the message could be read. The specified queue handle is no longer valid and the queue handle must be closed.</dd>
<dt>
MQ_ERROR_ILLEGAL_CURSOR_ACTION</dt>
<dd>
MQ_ACTION_PEEK_NEXT cannot be used with the current cursor position.</dd>
<dt>
MQ_ERROR_SERVICE_NOT_AVAILABLE</dt>
<dd>
Cannot connect to the Queue Manager.</dd>
<dt>
MQ_ERROR_STALE_HANDLE</dt>
<dd>
The specified queue handle was obtained in a previous session of the Queue Manager service. Close the queue and open it again to obtain a fresh handle.</dd>
<dt>
MQ_ERROR_TRANSACTION_USAGE</dt>
<dd>
Transaction error. An attempt was made to open a remote queue for read access from within a transaction, or an attempt was made to read a message from a <a href="msmqglos_3wvi.htm#_mq_non_transaction_queue_gly">non-transaction queue</a> from within a transaction.</dd>
<dt>
MQ_INFORMATION_PROPERTY</dt>
<dd>
One or more of the properties specified in <i>pMessageProps</i> resulted in a warning code even though the function is completed.
</dd>
</dl>
<h4>Remarks</h4>
<p>
All message properties can be read. However, only those properties specified in the <i>pMessageProps</i> parameter are returned to the calling application; other properties are simply discarded when the message is read. For example, when browsing for messages, some applications may choose to retrieve the size of the message without retrieving the message body itself. To do this, <a href="mqprop_7b6t.htm">PROPID_M_BODY_SIZE</a> is included in <i>pMessageProps</i> and <a href="mqprop_6wzd.htm">PROPID_M_BODY</a> is not; the size of the message is returned to the calling application and the message body is not.</p>
<p>
The <i>hCursor</i> parameter contains the handle to a cursor created by <a href="mqfunc_3bn6.htm"><b>MQCreateCursor</b></a>. Using a cursor is optional and is only needed when you want to read messages that are not at the front of the queue.</p>
<p>
When using a cursor, you must peek at the first message in the queue by setting<i> dwAction</i> to MQ_ACTION_PEEK_CURRENT followed by subsequent calls with<i> dwAction</i> set to MQ_ACTION_PEEK_NEXT.</p>
<p>
The <i>dwAction</i> parameter specifies how MSMQ reads the message (either peek or receive) and which message is read. For a description of how MSMQ reads the messages in the queue, see:
<ul>
<li>
<a href="msmq_guide_5a9e.htm#_mq_peeking_at_a_message_in_a_queue">Peeking at a Message in a Queue</a> </li>
<li>
<a href="msmq_guide_5a9e.htm#_mq_peeking_at_the_next_message_in_a_queue">Peeking at the Next Message in a Queue</a> </li>
<li>
<a href="msmq_guide_5a9e.htm#_mq_retrieving_the_first_message">Retrieving the First Message</a> </li>
<li>
<a href="msmq_guide_5a9e.htm#_mq_retrieving_a_message_in_a_queue">Retrieving a Message in a Queue</a> </li>
</ul>
<p>
To retrieve the message body, <a href="mqprop_6wzd.htm">PROPID_M_BODY</a> must be specified in <i>pMessageProps</i>. The <b>VT</b> field of the corresponding element in the <b>aPropVar</b> array should be set to VT_UI1 | VT_VECTOR, allowing MSMQ to use the buffer specified in <b>CAUI1</b> to store the message. If the supplied buffer is too small to contain the entire message body, <b>MQReceiveMessage</b> fails and MQ_ERROR_BUFFER_OVERFLOW is returned. The buffer is filled to capacity, and the full message remains in the queue. When this happens, the other properties specified by <i>pMessageProps</i> are still read.</p>
<p>
To retrieve the size of the message, specify <a href="mqprop_7b6t.htm">PROPID_M_BODY_SIZE</a> in <i>pMessageProps</i>. MSMQ sets PROPID_M_BODY_SIZE to the size of the message body, even if <b>MQReceiveMessage</b> fails because the message body exceeded the buffer allocated by PROPID_M_BODY. When retrieving the message body size, the <b>CAUI1 </b>structure associated with the PROPID_M_BODY property does not indicate the size. The <i>cElems </i>field of the <b>CAUI1</b> structure merely indicates the maximum message body, which could be copied into the <i>pElems</i> buffer. The <i>cElems</i> field is never modified by MSMQ.</p>
<p>
Not all properties require the application to specify the property type in the <b>VT</b> field of the <b>aPropVar </b>array. For these properties, the corresponding <b>VT</b> field in the <b>aPropVar</b> array can be set to VT_NULL.</p>
<p>
When reading messages in a queue, the function's time-out timer (<i>dwTimeout</i>) can be set to 0, a specific amount of time, or INFINITE. A message can be retrieved if it is available at that period of time.</p>
<h5>Synchronously Reading Messages</h5>
<p>
To synchronously read messages, <i>fnReceiveCallback</i> and <i>lpOverlapped</i> must be set to NULL. When this is done, the calling thread is blocked until a suitable message is available or a time-out occurs.</p>
<p>
For an example of using <b>MQReceiveMessage</b> to read messages synchronously, see <a href="actvxuse_4794.htm">Reading Messages Synchronously</a>.</p>
<h5>Asynchronously Reading Messages</h5>
<p>
When asynchronously reading messages, <b>MQReceiveMessage</b> returns a SUCCESS value as soon as a suitable message is found. Otherwise, the function returns immediately with the return value MQ_INFORMATION_OPERATION_PENDING. This return value indicates that the operation is pending and will be completed as soon as a suitable message can be found. Asynchronous receive is based on standard Microsoft® Win32® mechanisms.</p>
<p>
There are three possible ways to read messages asynchronously:
<ul>
<li>
By using a callback function (<i>fnReceiveCallback</i> is not NULL). In this case, the message is not retrieved by <b>MQReceiveMessage</b>. It is retrieved by the registered callback function. Once registered, a callback function cannot be unregistered.<p>
When multiple asynchronous <b>MQReceiveMessage</b> calls are outstanding, several callbacks are registered; upon arrival of a message, the first registered callback is called.
</li>
<li>
By using a Windows Event mechanism (<i>fnReceiveCallback</i> is NULL and <i>lpOverlapped</i> is not NULL). In this case, the <b>hEvent</b> member of the specified <b>OVERLAPPED</b> structure contains a valid handle to an event object. When a suitable message arrives, or a time-out occurs, the event object is set to the signaled state.<p>
For more information on the <b>OVERLAPPED</b> structure, see the Microsoft Platform SDK.
</li>
<li>
By using a Windows NT completion port mechanism (<i>fnReceiveCallback</i> is NULL and <i>lpOverlapped</i> is not NULL). A queue handle can be associated with a completion port to receive messages asynchronously.<p>
For more information, see <b>CreateIOCompletionPort </b>in the Microsoft Platform SDK.
</li>
</ul>
<p>
The output parameters to an asynchronous call to <b>MQReceiveMessage</b> should be kept intact until the operation completes (that is, you cannot free them or reuse them). Use automatic variables with caution.</p>
<p>
For an example of using <b>MQReceiveMessage</b> to read messages asynchronously, see <a href="msmquse_9ii1.htm">Reading Messages Asynchronously</a>.</p>
<h5>Reading Message in Transactions</h5>
<p>
If <b>MQReceiveMessage</b> is called as part of a transaction (<i>pTransaction</i> is not set to MQ_NO_TRANSACTION or NULL), the following parameters must be set accordingly:
<ul>
<li>
The <i>lpOverlapped</i> and <i>fnReceiveCallback</i> parameters must be set to NULL. The operation must be synchronous receive.</li>
<li>
The <i>hSource</i> parameter must specify a queue on a local computer.</li>
</ul>
<p>
When the call is made, MSMQ performs the following tasks.
<ul>
<li>
In the case of a subsequent Abort, the message is returned to its original place in the queue.</li>
<li>
In the case of a Commit, a positive acknowledgment message is sent to the sender's <a href="msmqglos_3wv5.htm#_mq_administration_queue_gly">administration queue</a>. The class property of the acknowledgment message is MQMSG_CLASS_ACK_RECEIVE. For information on lTransaction::Commit, see the Platform SDK.</li>
</ul>
<p>
For more information about MSMQ transactions, see <a href="msmq_guide_5g4z.htm">MSMQ Transactions</a>.</p>
<h5>Messages in Administration Queues</h5>
<p>
When reading acknowledgment messages in an administration queue, you can see if the original message failed by looking at the class property (<a href="mqprop_53qr.htm">PROPID_M_CLASS</a>) of the acknowledgment message. The class property will contain a positive or negative acknowledgment.</p>
<p>
If the class property is positive, the original message body is not included in the acknowledgment message. If the class property is negative, the message body is included as the message body of the acknowledgment message. For a complete description of all the properties of the acknowledgment message, see <a href="msmq_guide_76wj.htm">Acknowledgment Messages</a>.</p>
<h5>Responding to Messages</h5>
<p>
The receiving application can pass <a href="mqprop_204l.htm">PROPID_M_RESP_QUEUE</a> to <b>MQReceiveMessage</b> to see if the sending application expects a response to the message. The messages sent back to the response queue specified by this property must be understood by the original sending application.</p>
<p>
When receiving a message, always check PROPID_M_RESP_QUEUE to see if it is not NULL. If it is not NULL, send responses to the specified response queue.</p>
<p>
Response queue handles returned by <a href="mqfunc_42hx.htm"><b>MQOpenQueue</b></a> can be cached to eliminate the need to call <b>MQOpenQueue</b> several times for the same response queue.</p>
<p>
For an example of sending response messages, see <a href="msmquse_8w2x.htm">Sending Messages that Request a Response</a>.</p>
<h4>Examples</h4>
<p>
For examples of using <b>MQReceiveMessage</b>, see <a href="msmquse_8k89.htm">Reading Messages Using a Cursor</a>.</p>
<h4>QuickInfo</h4>
<p>
<b>&nbsp;&nbsp;Windows NT: </b>Requires version 4.0 SP3 or later.<br>
<b>&nbsp;&nbsp;Windows: </b>Requires Windows 95 or later.<br>
<b>&nbsp;&nbsp;Windows CE: </b>Unsupported.<br>
<b>&nbsp;&nbsp;Header: </b>Declared in mq.h.<br>
<b>&nbsp;&nbsp;Import Library: </b>Use mqrt.lib.<br>
<b>&nbsp;&nbsp;Unicode: </b>Defined only as Unicode.</p>
<h4>See Also</h4>
<p>
<a href="mqfunc_3bn6.htm"><b>MQCreateCursor</b></a>, <a href="mqstruc_559v.htm"><b>MQMSGPROPS</b></a>, <a href="mqfunc_42hx.htm"><b>MQOpenQueue</b></a>, <a href="mqstruc_93lg.htm"><b>PROPVARIANT</b></a>, <a href="mqfunc_4rg9.htm"><b>MQSetQueueSecurity</b></a>, <a href="mqprop_6wzd.htm">PROPID_M_BODY</a>, <a href="mqprop_7b6t.htm">PROPID_M_BODY_SIZE</a>, <a href="mqprop_53qr.htm">PROPID_M_CLASS</a>, <a href="mqprop_204l.htm">PROPID_M_RESP_QUEUE</a> </p>
<p>&nbsp;</p></body>
</HTML>
