<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>UTIL.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context4553"></a>UTIL.CPP</h2>
<pre><code>//**************************************************************************** <br>//  Module:     NMUI.EXE      <br>//  File:       UTIL.CPP <br>//  Content:     <br>//               <br>// <br>//  Copyright (c) Microsoft Corporation 1995-1997 <br>// <br>// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF  <br>// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO  <br>// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A  <br>// PARTICULAR PURPOSE. <br>//**************************************************************************** <br> <br>#include "precomp.h" <br>#include "shlobj.h" <br> <br> <br>//**************************************************************************** <br>// <br>// BOOL GetIniBool(LPTSTR pszEntry, BOOL fDefault) <br>// <br>// Get the boolean data for an entry <br>// <br>//**************************************************************************** <br> <br>BOOL GetIniBool(LPTSTR pszEntry, BOOL fDefault) <br>{ <br>return GetPrivateProfileInt(gszAppName, pszEntry, fDefault, gszIniName) != 0; <br>} <br> <br>//**************************************************************************** <br>// <br>// DWORD GetIniInt(LPTSTR pszEntry, DWORD dwDefault) <br>// <br>// Get the numeric data for an entry <br>// <br>//**************************************************************************** <br> <br>DWORD GetIniInt(LPTSTR pszEntry, DWORD dwDefault) <br>{ <br>return GetPrivateProfileInt(gszAppName, pszEntry, dwDefault, gszIniName); <br>} <br> <br>//**************************************************************************** <br>// <br>// LPTSTR GetIniStr(LPTSTR pszEntry, LPTSTR pszDefault) <br>// <br>// Get the string data for an entry <br>// <br>//**************************************************************************** <br> <br>LPTSTR GetIniStr(LPTSTR pszEntry, LPTSTR pszDefault) <br>{ <br>int     cch; <br>LPTSTR  pszRet; <br>TCHAR   sz[MAX_PATH]; <br> <br>cch = GetPrivateProfileString(gszAppName, pszEntry, pszDefault, sz, MAX_PATH, gszIniName); <br>if (cch == 0) <br>{ <br>if (NULL == pszDefault) <br>return NULL; <br> <br>cch = lstrlen(pszDefault); <br>lstrcpy(sz, pszDefault); <br>} <br>pszRet = PszAlloc(cch); <br>if (pszRet == NULL) <br>return NULL; <br> <br>lstrcpy(pszRet, sz); <br> <br>return pszRet; <br>} <br> <br> <br>//**************************************************************************** <br>// <br>// VOID GetIniHex(LPTSTR pszEntry, LPVOID lpv, int cb) <br>// <br>// Convert the hex data into binary. <br>// If no entry is found, lpv isn't modified <br>// <br>//**************************************************************************** <br> <br>VOID GetIniHex(LPTSTR pszEntry, LPVOID lpv, int cb) <br>{ <br>TCHAR sz[MAX_PATH]; <br> <br>if (GetPrivateProfileString(gszAppName, pszEntry, "", sz, MAX_PATH, gszIniName) != 0) <br>{ <br>HexToData(sz, lpv, cb); <br>} <br>} <br> <br> <br>//**************************************************************************** <br>// <br>// VOID WriteIniStr(LPTSTR pszEntry, LPTSTR pszData) <br>// <br>// Write the data to an entry in the ini file <br>// <br>//**************************************************************************** <br> <br>VOID WriteIniStr(LPTSTR pszEntry, LPTSTR pszData) <br>{ <br>WritePrivateProfileString(gszAppName, pszEntry, pszData, gszIniName); <br>} <br> <br> <br>//**************************************************************************** <br>// <br>// VOID WriteIniInt(LPTSTR pszEntry, DWORD dw) <br>// <br>// Write the numeric data to an entry in the ini file <br>// <br>//**************************************************************************** <br> <br>VOID WriteIniInt(LPTSTR pszEntry, DWORD dw) <br>{ <br>TCHAR szData[MAX_PATH]; <br> <br>wsprintf(szData, TEXT("%d"), dw); <br>WritePrivateProfileString(gszAppName, pszEntry, szData, gszIniName); <br>} <br> <br> <br>//**************************************************************************** <br>// <br>// VOID WriteIniBool(LPTSTR pszEntry, BOOL f) <br>// <br>// Write the boolean value to an entry in the registery <br>// <br>//**************************************************************************** <br> <br>VOID WriteIniBool(LPTSTR pszEntry, BOOL f) <br>{ <br>WritePrivateProfileString(gszAppName, pszEntry, f ? TEXT("1") : TEXT("0"), gszIniName); <br>} <br> <br> <br>//**************************************************************************** <br>// <br>// VOID WriteIniHex(LPTSTR pszEntry, LPVOID lpv, int cb) <br>// <br>//**************************************************************************** <br>VOID WriteIniHex(LPTSTR pszEntry, LPVOID lpv, int cb) <br>{ <br>TCHAR sz[MAX_PATH]; <br> <br>DataToHex((LPTSTR) lpv, sz, cb); <br> <br>WriteIniStr(pszEntry, sz); <br>} <br> <br> <br>//**************************************************************************** <br>// <br>// VOID CenterWindow(HWND hwndChild, HWND hwndParent) <br>// <br>// Center a window over another window. <br>// <br>//**************************************************************************** <br> <br>VOID CenterWindow(HWND hwndChild, HWND hwndParent) <br>{ <br>int   xNew, yNew; <br>int   cxChild, cyChild; <br>int   cxParent, cyParent; <br>int   cxScreen, cyScreen; <br>RECT  rcChild, rcParent; <br>HDC   hdc; <br> <br>// Get the Height and Width of the child window <br>GetWindowRect(hwndChild, &amp;rcChild); <br>cxChild = rcChild.right - rcChild.left; <br>cyChild = rcChild.bottom - rcChild.top; <br> <br>// Get the Height and Width of the parent window <br>GetWindowRect(hwndParent, &amp;rcParent); <br>cxParent = rcParent.right - rcParent.left; <br>cyParent = rcParent.bottom - rcParent.top; <br> <br>// Get the display limits <br>hdc = GetDC(hwndChild); <br>if (hdc == NULL) { <br>// major problems - move window to 0,0 <br>xNew = yNew = 0; <br>} else { <br>cxScreen = GetDeviceCaps(hdc, HORZRES); <br>cyScreen = GetDeviceCaps(hdc, VERTRES); <br>ReleaseDC(hwndChild, hdc); <br> <br>if (hwndParent == hwndNil) { <br>cxParent = cxScreen; <br>cyParent = cyScreen; <br>SetRect(&amp;rcParent, 0, 0, cxScreen, cyScreen); <br>} <br> <br>// Calculate new X position, then adjust for screen <br>xNew = rcParent.left + ((cxParent - cxChild) / 2); <br>if (xNew &lt; 0) { <br>xNew = 0; <br>} else if ((xNew + cxChild) &gt; cxScreen) { <br>xNew = cxScreen - cxChild; <br>} <br> <br>// Calculate new Y position, then adjust for screen <br>yNew = rcParent.top  + ((cyParent - cyChild) / 2); <br>if (yNew &lt; 0) { <br>yNew = 0; <br>} else if ((yNew + cyChild) &gt; cyScreen) { <br>yNew = cyScreen - cyChild; <br>} <br> <br>} <br> <br>SetWindowPos(hwndChild, NULL, xNew, yNew,0, 0, <br>SWP_NOSIZE | SWP_NOZORDER); <br>} <br> <br> <br>//**************************************************************************** <br>// <br>// LPVOID LpvAlloc(int cb) <br>// <br>// Return a pointer to an allocated array of bytes <br>// <br>//**************************************************************************** <br> <br>LPVOID LpvAlloc(int cb) <br>{ <br>return LocalAlloc(LMEM_FIXED, cb); <br>} <br> <br> <br>//**************************************************************************** <br>// <br>// LPTSTR PszAlloc(int cch) <br>// <br>//**************************************************************************** <br> <br>LPTSTR PszAlloc(int cch) <br>{ <br>return (LPTSTR) LocalAlloc(LMEM_FIXED, sizeof(TCHAR) * (cch+1)); <br>} <br> <br> <br>//**************************************************************************** <br>// <br>// VOID FreePlpv(LPVOID plpv) <br>// <br>// Free the data pointed to by plpv and set *plpv to NULL <br>// <br>//**************************************************************************** <br> <br>VOID FreePlpv(LPVOID plpv) <br>{ <br>if ((plpv == NULL) || (*(VOID FAR * FAR *)plpv == NULL)) { <br>return; <br>} <br> <br>LocalFree(*(VOID FAR * FAR *)plpv); <br>*(VOID FAR * FAR *)plpv = NULL; <br>} <br> <br> <br>//**************************************************************************** <br>// <br>// TCHAR ChFromHex(LPTSTR lpch) <br>// <br>// Convert from Hex data to ascii character <br>// <br>//**************************************************************************** <br> <br>TCHAR ChFromHex(LPTSTR lpch) <br>{ <br>int i = 0; <br>int cch = 2; <br>char ch; <br> <br>while (cch-- &gt; 0) { <br>ch = *lpch++; <br>if (ch &gt;= 'A') { <br>i = (i*16) + (ch - ('A'-10)); <br>} else { <br>i = (i*16) + (ch - '0'); <br>} <br>} <br> <br>return (TCHAR) i; <br>} <br> <br> <br>//**************************************************************************** <br>// <br>// VOID HexToData(LPTSTR lpchSrc, LPVOID lpvDest, int cb) <br>// <br>// Convert from Hex data to ascii character <br>// <br>//**************************************************************************** <br> <br>VOID HexToData(LPTSTR lpchSrc, LPVOID lpvDest, int cb) <br>{ <br>PTCHAR lpchDest = (PTCHAR) lpvDest; <br> <br>CharUpperBuff(lpchSrc, cb*2); <br> <br>while (cb-- &gt; 0) <br>{ <br>*lpchDest++ = ChFromHex(lpchSrc); <br>lpchSrc += 2; <br>} <br>} <br> <br> <br>//**************************************************************************** <br>// <br>// LPSTR HexToBin(LPSTR lpchSrc, LPVOID lpvDest, int cb) <br>// <br>// Convert from Hex data to ascii character <br>// <br>//**************************************************************************** <br> <br>LPSTR HexToBin(LPSTR lpchSrc, LPVOID lpvDest, int cb) <br>{ <br>PTCHAR lpchDest = ((CHAR *) lpvDest) + cb; <br> <br>CharUpperBuff(lpchSrc, cb); <br> <br>while (cb-- &gt; 0) <br>{ <br>lpchDest--; <br>*lpchDest = ChFromHex(lpchSrc); <br>lpchSrc += 2; <br>} <br>return lpchSrc; <br>} <br> <br>//**************************************************************************** <br>// <br>// VOID DataToHex(LPTSTR lpchSrc, LPTSTR lpchDest, int cb) <br>// <br>//**************************************************************************** <br> <br>VOID DataToHex(LPTSTR lpchSrc, LPTSTR lpchDest, int cb) <br>{ <br>TCHAR ch; <br> <br>if (lpchSrc == lpNil) <br>{ <br>SetEmptySz(lpchDest); <br>return; <br>} <br> <br>while (cb-- &gt; 0) { <br>ch = 0x00FF &amp; (unsigned char) (*lpchSrc++); <br>wsprintf(lpchDest, "%02X", ch); <br>lpchDest += 2; <br>} <br>} <br> <br> <br>//**************************************************************************** <br>// <br>// VOID SetMenuCheck(UINT idm, BOOL fCheck) <br>// <br>// Set the menu item's check mark. <br>// <br>//**************************************************************************** <br> <br>VOID SetMenuCheck(UINT idm, BOOL fCheck) <br>{ <br>CheckMenuItem(ghMenu, idm, <br>fCheck ? (MF_CHECKED  | MF_BYCOMMAND) : (MF_UNCHECKED | MF_BYCOMMAND)); <br>} <br> <br> <br>//**************************************************************************** <br>// <br>// VOID MaybeDeleteObject(HGDIOBJ * phgdi) <br>// <br>// Check usage count, delete if we can <br>// <br>//**************************************************************************** <br> <br>VOID MaybeDeleteObject(HGDIOBJ * phgdi) <br>{ <br>if (*phgdi == hgdiNil) <br>return; <br> <br>DeleteObject(*phgdi); <br>*phgdi = hgdiNil; <br>} <br> <br> <br>static TCHAR _szFilter[] = TEXT("All Files\0*.*\0Text Files (*.txt)\0*.TXT\0"); <br>static TCHAR _szPickMsg[] = TEXT("Pick a file to send"); <br>static TCHAR _szPickDir[] = TEXT("Select a Directory"); <br> <br> <br>//**************************************************************************** <br>// <br>// BOOL FGetFileName(LPTSTR szFileName) <br>// <br>//**************************************************************************** <br> <br>BOOL FGetFileName(LPTSTR szFileName) <br>{ <br>OPENFILENAME ofn; <br> <br>SetEmptySz(szFileName); <br>ClearStruct(&amp;ofn); <br> <br>ofn.lStructSize   = sizeof(OPENFILENAME); <br>ofn.hwndOwner     = ghwndMain; <br>ofn.hInstance     = (HINSTANCE) ghInst; <br>ofn.lpstrFilter   = _szFilter; <br>ofn.nFilterIndex  = 1L; <br>ofn.lpstrFile     = (LPSTR) szFileName; <br>ofn.nMaxFile      = MAX_PATH; // really CCHMAX(szFileName) <br>ofn.lpstrTitle    = _szPickMsg; <br>ofn.lpstrInitialDir = NULL; <br>ofn.Flags = OFN_HIDEREADONLY | OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST | OFN_EXPLORER; <br> <br>if (!GetOpenFileName(&amp;ofn)) <br>return FALSE; <br> <br>return TRUE; <br>} <br> <br> <br>//**************************************************************************** <br>// <br>// BOOL FGetDirectory(LPTSTR szDir) <br>// <br>//**************************************************************************** <br> <br>BOOL FGetDirectory(LPTSTR szDir) <br>{ <br>BOOL  fRet; <br>TCHAR  szPath[MAX_PATH]; <br>LPITEMIDLIST pidl; <br>LPITEMIDLIST pidlRoot; <br>LPMALLOC lpMalloc; <br> <br>BROWSEINFO bi = { <br>ghwndMain, <br>NULL, <br>szPath, <br>_szPickDir, <br>BIF_RETURNONLYFSDIRS, <br>NULL, 0L, 0}; <br> <br>if (0 != SHGetSpecialFolderLocation(HWND_DESKTOP, CSIDL_DRIVES, &amp;pidlRoot)) <br>return FALSE; <br>if (NULL == pidlRoot) <br>return FALSE; <br> <br>bi.pidlRoot = pidlRoot; <br>pidl = SHBrowseForFolder(&amp;bi); <br> <br>if (NULL != pidl) <br>fRet = SHGetPathFromIDList(pidl, szDir); <br>else <br>fRet = FALSE; <br> <br>// Get the shell's allocator to free PIDLs <br>if (!SHGetMalloc(&amp;lpMalloc) &amp;&amp; (NULL != lpMalloc)) <br>{ <br>if (NULL != pidlRoot) <br>{ <br>lpMalloc-&gt;Free(pidlRoot); <br>} <br> <br>if (NULL != pidl) <br>{ <br>lpMalloc-&gt;Free(pidl); <br>} <br> <br>lpMalloc-&gt;Release(); <br>} <br> <br>return fRet; <br>} <br> <br> <br>//**************************************************************************** <br>// <br>// VOID GetDlgItemPsz(HWND hdlg, UINT id, LPTSTR *ppsz) <br>// <br>// Get the text in the dialog item and retun a pointer to it in *ppsz. <br>// Note: Any previous data in ppsz is released. <br>// <br>//**************************************************************************** <br> <br>VOID GetDlgItemPsz(HWND hdlg, UINT id, LPTSTR *ppsz) <br>{ <br>UINT cch; <br>TCHAR sz[MAX_PATH]; <br> <br>FreePlpv(ppsz); <br>cch = GetDlgItemText(hdlg, id, sz, CCHMAX(sz)); <br>if (0 == cch) <br>return; <br>*ppsz = (LPTSTR) PszAlloc(cch); <br>if (NULL == *ppsz) <br>return; <br> <br>lstrcpy(*ppsz, sz); <br>} <br> <br> <br>//**************************************************************************** <br>// <br>// int GetRadioButton(HWND hdlg, int idrFirst, int idrLast) <br>// <br>//**************************************************************************** <br> <br>int GetRadioButton(HWND hdlg, int idrFirst, int idrLast) <br>{ <br>int id; <br> <br>for (id = idrFirst; id &lt;= idrLast; id++) <br>{ <br>if (IsDlgButtonChecked(hdlg, id)) <br>return id; <br>} <br>return idrFirst; <br>} <br> <br>//**************************************************************************** <br>// <br>// VOID GuidToSz(GUID * pguid, LPTSTR lpchDest) <br>// <br>// Convert the guid to a special hex string. <br>// Assumes lpchDest has space for at least sizeof(GUID)*2 +6 chars. <br>// LENGTH_SZGUID_FORMATTED is 30 and includes space for the null terminator. <br>// <br>// Note the difference between this and UuidToString (or StringFromGUID2) <br>// <br>// GUID Format: {12345678-1234-1234-1234-567890123456} <br>// <br>//**************************************************************************** <br> <br>VOID GuidToSz(GUID * pguid, LPTSTR lpchDest) <br>{ <br>ASSERT(NULL != pguid); <br>ASSERT(NULL != lpchDest); <br> <br>wsprintf(lpchDest, TEXT("{%08X-%04X-%04X-%02X%02X-"), <br>pguid-&gt;Data1, pguid-&gt;Data2, pguid-&gt;Data3, pguid-&gt;Data4[0], pguid-&gt;Data4[1]); <br>lpchDest += 1+8+1+4+1+4+1+2+2+1; <br> <br>for (int i = 2; i &lt; 8; i++) <br>{ <br>wsprintf(lpchDest, TEXT("%02X"), pguid-&gt;Data4[i]); <br>lpchDest += 2; <br>} <br>lstrcpy(lpchDest, TEXT("}") ); <br>} <br> <br> <br>//**************************************************************************** <br>// <br>// VOID SzToGuid(LPTSTR lpchSrc, GUID * pguid) <br>// <br>//**************************************************************************** <br> <br>VOID SzToGuid(LPTSTR lpchSrc, GUID * pguid) <br>{ <br>if (FEmptySz(lpchSrc) || (lstrlen(lpchSrc) &lt; sizeof(GUID)*2)) <br>{ <br>ClearStruct(pguid); <br>return; <br>} <br> <br>ClearStruct(pguid); <br> <br>if (_T('{') != *lpchSrc++) <br>return; <br>lpchSrc = HexToBin(lpchSrc, &amp;pguid-&gt;Data1, sizeof(pguid-&gt;Data1)); <br>if (_T('-') != *lpchSrc++) <br>return; <br>lpchSrc = HexToBin(lpchSrc, &amp;pguid-&gt;Data2, sizeof(pguid-&gt;Data2)); <br>if (_T('-') != *lpchSrc++) <br>return; <br>lpchSrc = HexToBin(lpchSrc, &amp;pguid-&gt;Data3, sizeof(pguid-&gt;Data3)); <br>if (_T('-') != *lpchSrc++) <br>return; <br>lpchSrc = HexToBin(lpchSrc, &amp;pguid-&gt;Data4[0], sizeof(BYTE)); <br>lpchSrc = HexToBin(lpchSrc, &amp;pguid-&gt;Data4[1], sizeof(BYTE)); <br>if (_T('-') != *lpchSrc++) <br>return; <br>HexToData(lpchSrc, &amp;pguid-&gt;Data4[2], sizeof(pguid-&gt;Data4) - 2*sizeof(BYTE)); <br>} <br> <br> <br>//**************************************************************************** <br>// <br>// LPTSTR SzFindLastCh(LPTSTR lpsz, TCHAR ch) <br>// <br>// Returns a pointer to the ch within the lpsz or NULL if not found <br>// <br>//**************************************************************************** <br> <br>LPTSTR SzFindLastCh(LPTSTR lpsz, TCHAR ch) <br>{ <br>LPTSTR lpchRet; <br> <br>for (lpchRet = NULL; *lpsz; lpsz = CharNext(lpsz)) <br>{ <br>if (ch == *lpsz) <br>lpchRet = lpsz; <br>} <br> <br>return lpchRet; <br>} <br> <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
