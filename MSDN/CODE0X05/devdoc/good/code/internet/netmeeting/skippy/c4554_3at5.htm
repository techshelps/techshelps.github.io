<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>MAIN.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context4559"></a>MAIN.CPP</h2>
<pre><code>//**************************************************************************** <br>// <br>//  SKIPPY! sample app for Microsoft NetMeeting SDK <br>// <br>//  File:       main.cpp <br>//  Content:    This file contains the application's WinMain and init  <br>//              functions. GUID. <br>// <br>//  Copyright (c) Microsoft Corporation 1997 <br>//  All rights reserved <br>// <br>//**************************************************************************** <br> <br>#include "ilstest.h" <br> <br>#define INC_OLE2 <br>#include &lt;initguid.h&gt; <br>#include &lt;olectl.h&gt; <br>#include &lt;ilsguid.h&gt; <br>#include "appguid.h" <br> <br>#include "notify.h" <br> <br> <br>//**************************************************************************** <br>// Global parameters <br>//**************************************************************************** <br> <br>HINSTANCE          ghInstance = NULL; <br>LPILS_MAIN         g_pIls = NULL; <br>IConnectionPoint   *g_pcnp = NULL; <br>CIlsNotify         *g_pIlsNotify = NULL; <br>HWND               g_hwndMain = NULL; <br>CHAR               g_szServer[MAX_PATH]; <br>IIlsServer         *g_pServer = NULL; <br>IIlsFilter         *g_pProtFilter = NULL; <br>IIlsFilter         *g_pUserFilter = NULL; <br>COBLIST            *g_pServerList; <br>COBLIST            *g_pUserList; <br>GUID               g_GUID; <br> <br>#define WM_START   (WM_USER+10) <br> <br>//**************************************************************************** <br>// Global constant strings <br>//**************************************************************************** <br> <br>const TCHAR g_szOptions[]   = TEXT("Options"); <br>const TCHAR g_szPosition[]  = TEXT("Placement"); <br>const TCHAR g_szIni[]       = TEXT("skippy.ini"); <br>const TCHAR g_szAppID[]   = TEXT("ms-netmeeting"); // Use this string so NM can see you on the server <br>const TCHAR g_szProtID[]   = TEXT("h323"); // Default to this protocol ID for now <br> <br>const TCHAR g_szExe[]       = TEXT("skippy.exe"); <br> <br> <br>//**************************************************************************** <br>// Function prototypes <br>//**************************************************************************** <br> <br>long CALLBACK App_WndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam); <br> <br>//**************************************************************************** <br>// <br>// HRESULT OnIlsAdviseUnadvise(HWND hwnd, BOOL fAdvise) <br>// <br>// This function enables/disables the Ils object's notifications. <br>// <br>//**************************************************************************** <br> <br>HRESULT OnIlsAdviseUnadvise(HWND hwnd, BOOL fAdvise) <br>{ <br>HRESULT hr; <br> <br>if (fAdvise) <br>{ <br>DWORD dwCookie; <br> <br>g_pIlsNotify = new CIlsNotify (hwnd); <br>hr = g_pcnp-&gt;Advise((IUnknown *)g_pIlsNotify, &amp;dwCookie); <br> <br>if (hr == S_OK) <br>{ <br>g_pIlsNotify-&gt;AddRef(); <br>g_pIlsNotify-&gt;SetCookie(dwCookie); <br>}; <br>} <br>else <br>{ <br>hr = g_pcnp-&gt;Unadvise(g_pIlsNotify-&gt;GetCookie()); <br> <br>if (hr == S_OK) <br>{ <br>g_pIlsNotify-&gt;Release(); <br>g_pIlsNotify = NULL; <br>}; <br>}; <br>return hr; <br>} <br> <br>//**************************************************************************** <br>// <br>// void InitConnectableObject(HWND hwnd) <br>// <br>// This function initializes the Ils connectable object. <br>// <br>//**************************************************************************** <br> <br>void InitConnectableObject(HWND hwnd) <br>{ <br>IConnectionPointContainer *pcnpcnt; <br>HRESULT hr; <br> <br>// Get the ConnectionPointContainer <br>// <br>hr = g_pIls-&gt;QueryInterface(IID_IConnectionPointContainer, (void**)&amp;pcnpcnt); <br>if (hr != S_OK) <br>{ <br>ErrorMessage(NULL, TEXT("Cannot query IID_IConnectionPointContainer: returns "), <br>hr); <br>} <br>else <br>{ <br>IEnumConnectionPoints *pEnum; <br> <br>// Instead of an easy thing as follows <br>// hr = pcnpcnt-&gt;FindConnectionPoint(IID_IIlsNotify, &amp;g_pcnp); <br>// Let's do the hard thing through enumeration <br>// <br>hr = pcnpcnt-&gt;EnumConnectionPoints(&amp;pEnum); <br>if (hr != S_OK) <br>{ <br>ErrorMessage(NULL, TEXT("Cannot enumerate ConnectionPoint: returns "), <br>hr);                 <br>} <br>else <br>{ <br>IConnectionPoint *pcnp; <br>ULONG            cFetched; <br> <br>while(pEnum-&gt;Next(1, &amp;pcnp, &amp;cFetched) == S_OK) <br>{ <br>IID riid; <br> <br>if ((pcnp-&gt;GetConnectionInterface(&amp;riid) == S_OK) &amp;&amp; <br>(riid == IID_IIlsNotify)) <br>{ <br>g_pcnp = pcnp; <br>OnIlsAdviseUnadvise(hwnd, TRUE); <br>break; <br>}; <br>pcnp-&gt;Release(); <br>}; <br> <br>if (g_pcnp == NULL) <br>{ <br>ErrorMessage(NULL, TEXT("Cannot find ConnectionPoint: returns "), <br>hr);                 <br>}; <br> <br>pEnum-&gt;Release(); <br>}; <br>pcnpcnt-&gt;Release(); <br>}; <br>} <br> <br>//**************************************************************************** <br>// <br>// BOOL InitAppInstance (HINSTANCE hInstance) <br>// <br>// This function initializes this instance of the application. <br>// <br>//**************************************************************************** <br> <br>BOOL InitAppInstance (HINSTANCE hInstance) <br>{ <br>HRESULT hr; <br>LPCLASSFACTORY pcf; <br>BOOL    fRet = FALSE; <br> <br>// Remember the application instance <br>// <br>ghInstance = hInstance; <br> <br>// Create the main window with a dialog template <br>// <br>InitCommonControls(); <br>g_hwndMain = CreateDialog(hInstance, MAKEINTRESOURCE(IDD_DLG_APP), <br>NULL, (DLGPROC)App_WndProc); <br> <br>if (g_hwndMain == NULL) <br>return FALSE; <br> <br>// Create linked lists for users and servers <br>// <br>g_pUserList = new COBLIST; <br>g_pServerList = new COBLIST; <br> <br>// Do the OLE thing <br>// <br>hr = CoInitialize(NULL); <br>if (FAILED(hr)) <br>{ <br>ErrorMessage(NULL, TEXT("CoInitialize"), hr); <br>return FALSE; <br>} <br> <br>// Notify the system we want to use the Ils services <br>// by creating a Ils object <br>// <br>hr = CoGetClassObject(CLSID_InternetLocationServices, <br>CLSCTX_INPROC_SERVER, <br>NULL, <br>IID_IClassFactory, <br>(void**)&amp;pcf); <br>if (FAILED(hr)) <br>{ <br>ErrorMessage(NULL, TEXT("CoGetClassObject"), hr); <br>} <br>else <br>{ <br>// Get the IlsMain object <br>// <br>hr = pcf-&gt;CreateInstance(NULL, IID_IIlsMain, (void**)&amp;g_pIls); <br>if (hr != S_OK) <br>{ <br>ErrorMessage(NULL, TEXT("Cannot create a IlsMain object: returns "), hr); <br>} <br>else <br>{ <br>// Connect to the IlsMain object <br>// <br>InitConnectableObject(g_hwndMain); <br> <br>// Determine how to start the application and <br>// start the application <br>// <br>PostMessage(g_hwndMain, WM_START, 0, 0); <br>fRet = TRUE; <br>}; <br> <br>pcf-&gt;Release(); <br>}; <br> <br>return fRet; <br>} <br> <br>//**************************************************************************** <br>// <br>// void DeinitAppInstance (HINSTANCE hInstance) <br>// <br>// This function initializes this instance of the application. <br>// <br>//**************************************************************************** <br> <br>void DeinitAppInstance(HINSTANCE hInstance) <br>{ <br>// Unregister all the users we created <br>UnregisterAllUsers(g_hwndMain); <br> <br>// Remove the connection points <br>// <br>if (g_pcnp != NULL) <br>{ <br>OnIlsAdviseUnadvise(g_hwndMain, FALSE); <br>g_pcnp-&gt;Release(); <br>}; <br> <br>// Free the main interface <br>// <br>if (g_pIls != NULL) <br>{ <br>g_pIls-&gt;Uninitialize(); <br>g_pIls-&gt;Release(); <br>}; <br>CoUninitialize(); <br> <br>// clear the user and server lists <br>// <br>g_pServerList-&gt;EmptyList(); <br>g_pUserList-&gt;EmptyList(); <br> <br>delete g_pUserList; <br>delete g_pServerList; <br> <br>// Destroy the main window <br>DestroyWindow(g_hwndMain); <br> <br>return; <br>} <br> <br>//**************************************************************************** <br>// <br>//    FUNCTION: WinMain(HANDLE, HANDLE, LPSTR, int) <br>// <br>//    PURPOSE: calls initialization function, processes message loop <br>// <br>//    COMMENTS: <br>// <br>//        Windows recognizes this function by name as the initial entry point  <br>//        for the program.  This function calls the application initialization  <br>//        routine, if no other instance of the program is running, and always  <br>//        calls the instance initialization routine.  It then executes a message  <br>//        retrieval and dispatch loop that is the top-level control structure  <br>//        for the remainder of execution.  The loop is terminated when a WM_QUIT  <br>//        message is received, at which time this function exits the application  <br>//        instance by returning the value passed by PostQuitMessage().  <br>// <br>//        If this function must abort before entering the message loop, it  <br>//        returns the conventional value NULL.   <br>// <br>//**************************************************************************** <br> <br>int PASCAL WinMain( <br>HINSTANCE hInstance,        /* current instance     */ <br>HINSTANCE hPrevInstance,    /* previous instance    */ <br>LPSTR     lpCmdLine,        /* command line         */ <br>int       nCmdShow)         /* show-window type (open/icon)  */ <br>{ <br>MSG     msg;            /* message              */ <br> <br>if (!InitAppInstance(hInstance)) /* Initialize shared things         */ <br>return (FALSE);              /* Exits if unable to initialize    */ <br> <br>/* Acquire and dispatch messages until a WM_QUIT message is received.*/ <br> <br>while (GetMessage(&amp;msg,    /* message structure                      */ <br>NULL,                  /* handle of window receiving the message */ <br>0,                     /* lowest message to examine              */ <br>0))                    /* highest message to examine             */ <br>{ <br>if (!IsDialogMessage(g_hwndMain, &amp;msg)) <br>{ <br>TranslateMessage(&amp;msg);    /* Translates virtual key codes       */ <br>DispatchMessage(&amp;msg);     /* Dispatches message to window       */ <br>}; <br>} <br> <br>DeinitAppInstance(hInstance); <br>return (msg.wParam);       /* Returns the value from PostQuitMessage */ <br>} <br> <br>//**************************************************************************** <br>// <br>// void InitializeWindow(HWND hwnd) <br>// <br>// This function is called when the main window is initialized. <br>// <br>//**************************************************************************** <br> <br>void InitializeWindow(HWND hwnd) <br>{ <br>HICON hIcon; <br>HMENU hMenu; <br>WINDOWPLACEMENT wp; <br> <br>// Initialize application icon <br>// <br>hIcon = LoadIcon(ghInstance, MAKEINTRESOURCE(IDI_APP_ICON));     <br>SendMessage(hwnd, WM_SETICON, TRUE, (LPARAM)hIcon); <br>SendMessage(hwnd, WM_SETICON, FALSE, (LPARAM)hIcon); <br> <br>// Get window placement <br>// <br>if (GetPrivateProfileStruct(g_szOptions, g_szPosition, <br>(LPVOID)&amp;wp, sizeof(wp), g_szIni)) <br>{ <br>SetWindowPlacement(hwnd, &amp;wp); <br>}; <br> <br>// Turn on/off the correct menu items <br>hMenu = GetMenu(hwnd); <br>EnableMenuItem(hMenu, IDM_DESTROYUSER, MF_BYCOMMAND | MF_GRAYED); <br>EnableMenuItem(hMenu, IDM_DESTROYSERVER, MF_BYCOMMAND | MF_GRAYED); <br>EnableMenuItem(hMenu, IDM_ENUMUSERS, MF_BYCOMMAND | MF_GRAYED); <br>EnableMenuItem(hMenu, IDM_ENUMUSERNAMES, MF_BYCOMMAND | MF_GRAYED); <br>EnableMenuItem(hMenu, IDM_REGISTERUSER, MF_BYCOMMAND | MF_GRAYED); <br>EnableMenuItem(hMenu, IDM_UNREGISTERUSER, MF_BYCOMMAND | MF_GRAYED); <br>EnableMenuItem(hMenu, IDM_CLONEUSER, MF_BYCOMMAND | MF_GRAYED); <br>EnableMenuItem(hMenu, IDM_MODIFYUSER, MF_BYCOMMAND | MF_GRAYED); <br>EnableMenuItem(hMenu, IDM_GETUSERINFO, MF_BYCOMMAND | MF_GRAYED); <br>EnableMenuItem(hMenu, IDM_CREATE_PROT, MF_BYCOMMAND | MF_GRAYED); <br>EnableMenuItem(hMenu, IDM_DESTROY_PROT, MF_BYCOMMAND | MF_GRAYED); <br>EnableMenuItem(hMenu, IDM_DESTROY_PROTFILTER, MF_BYCOMMAND | MF_GRAYED); <br>EnableMenuItem(hMenu, IDM_DESTROY_USERFILTER, MF_BYCOMMAND | MF_GRAYED); <br> <br>return; <br>} <br> <br>//**************************************************************************** <br>// <br>// void TerminateWindow(HWND hwnd) <br>// <br>// This function is called when the main window is terminated. <br>// <br>//**************************************************************************** <br> <br>void TerminateWindow(HWND hwnd) <br>{ <br>WINDOWPLACEMENT wp; <br> <br>// Remember the last position <br>// <br>wp.length = sizeof(wp); <br>if (GetWindowPlacement(hwnd, &amp;wp)) <br>{ <br>WritePrivateProfileStruct(g_szOptions, g_szPosition, <br>(LPVOID)&amp;wp, sizeof(wp), g_szIni); <br>}; <br>PostQuitMessage(0); <br>return; <br>} <br> <br>//**************************************************************************** <br>// <br>// long CALLBACK App_WndProc(HWND hwnd, UINT message, <br>//                           WPARAM wParam, LPARAM lParam) <br>// <br>// This function is the main window procedure. <br>// <br>//**************************************************************************** <br> <br>long CALLBACK App_WndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam) <br>{ <br>int iCommand; <br> <br>switch (message) <br>{ <br>case WM_INITDIALOG: <br>InitializeWindow(hwnd); <br>break; <br> <br>case WM_CLOSE: <br>TerminateWindow(hwnd); <br>break; <br> <br>case WM_START: <br>{ <br>HRESULT hr; <br> <br>// Initialize the Ils object <br>// <br>hr = g_pIls-&gt;Initialize(); <br>if (FAILED(hr)) <br>ErrorMessage(NULL, TEXT("IIls::Initialize returns"), hr); <br>} <br> <br>case WM_COMMAND: <br>{ <br>// Process the menu selections <br>// <br>iCommand = GET_WM_COMMAND_ID(wParam, lParam); <br> <br>switch (iCommand) <br>{ <br>case IDM_EXIT: <br>TerminateWindow(hwnd); <br>break; <br> <br>case IDM_NEWUSER: <br>NewUserDialog(hwnd); <br>break; <br> <br>case IDM_MODIFYUSER: <br>ModifyUserDialog(hwnd); <br>break; <br> <br>case IDM_CLONEUSER: <br>CloneUserDialog(hwnd); <br>break; <br> <br>case IDM_DESTROYUSER: <br>RemoveUserDialog(hwnd); <br>break; <br> <br>case IDM_CREATESERVER: <br>NewServerDialog(hwnd); <br>break; <br> <br>case IDM_DESTROYSERVER: <br>RemoveServerDialog(hwnd); <br>break; <br> <br>case IDM_ENUMUSERS: <br>EnumUsers(hwnd, FALSE); <br>break; <br> <br>case IDM_ENUMUSERNAMES: <br>EnumUsers(hwnd, TRUE); <br>break; <br> <br>case IDM_REGISTERUSER: <br>RegUnregUserDialog(hwnd, TRUE); <br>break; <br> <br>case IDM_UNREGISTERUSER: <br>RegUnregUserDialog(hwnd, FALSE); <br>break; <br> <br>case IDM_GETUSERINFO: <br>GetUserInfoDialog(hwnd); <br>break; <br> <br>case IDM_USER_FILTER: <br>CreateFilterDialog(hwnd, USERFILTER); <br>break; <br> <br>case IDM_PROTOCOL_FILTER: <br>CreateFilterDialog(hwnd, PROTFILTER); <br>break; <br> <br>case IDM_DESTROY_USERFILTER: <br>DestroyFilter(hwnd, USERFILTER); <br>break; <br> <br>case IDM_DESTROY_PROTFILTER: <br>DestroyFilter(hwnd, PROTFILTER); <br>break; <br> <br>case IDM_CREATE_PROT: <br>CreateProtocolDialog(hwnd); <br>break; <br> <br>case IDM_DESTROY_PROT: <br>DestroyProtocolDialog(hwnd); <br>break; <br> <br>case IDM_ABOUT: <br>DisplayAboutBox(hwnd); <br>break; <br> <br>default: <br>break; <br>}; <br>break; <br>}; <br> <br>// Handle messages posted from the callbacks <br>// <br>case WM_IT_ENUM_NAMES_RESULT: <br>DisplayIlsNames(hwnd, (IEnumIlsNames *)lParam, "names"); <br>break; <br> <br>case WM_IT_ENUM_USERS_RESULT: <br>DisplayIlsUsers(hwnd, (IEnumIlsUsers *)lParam); <br>break; <br> <br>case WM_IT_RESOLVE_PROT_RESULT: <br>DisplayProtocolInfo(hwnd, (IIlsProtocol *)lParam); <br>break; <br> <br>case WM_IT_RESOLVE_USER_RESULT: <br>{ <br>USERNODE un; <br>PUSERNODE pun = &amp;un; <br>IIlsUser *pUser = (IIlsUser *)lParam; <br> <br>pun-&gt;pu = pUser; <br> <br>// Hookup the notification callback <br>OnILSUserAdviseUnadvise(hwnd, pun, TRUE); <br> <br>// Display the information dialog <br>DisplayIlsUserDialog(hwnd, pUser); <br> <br>// Remove the callback <br>OnILSUserAdviseUnadvise(hwnd, pun, FALSE); <br> <br>// release the user object. <br>pUser-&gt;Release(); <br> <br>            } <br>break; <br> <br>default: <br>break; <br>} <br> <br>return 0L; <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
