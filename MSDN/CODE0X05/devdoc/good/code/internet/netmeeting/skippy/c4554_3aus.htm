<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>PROTO.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context4564"></a>PROTO.CPP</h2>
<pre><code>//**************************************************************************** <br>// <br>//  SKIPPY! sample for Microsoft NetMeeting SDK <br>// <br>//  File:       proto.cpp <br>//  Content:    This file contains protocol functions. <br>// <br>//  Copyright (c) Microsoft Corporation 1997 <br>//  All rights reserved <br>// <br>//**************************************************************************** <br> <br>#include "ilstest.h" <br> <br> <br> <br>//**************************************************************************** <br>// <br>// int EnumUserProtocols(HWND hwnd, IIlsUser *pu) <br>// <br>// <br>//**************************************************************************** <br> <br>HRESULT EnumUserProtocols(HWND hwnd, IIlsUser *pu) <br>{ <br>HRESULT hr = E_FAIL; <br>IIlsFilter *pFilter; <br>IIlsAttributes *pAttributes = NULL; <br>ULONG uReqID; <br> <br>// use the global PROT filter, if not defined it will be NULL <br>// <br>pFilter = g_pProtFilter; <br> <br>// The third param is unused and must be NULL <br>// <br>hr = pu-&gt;EnumProtocols(pFilter, pAttributes, NULL, &amp;uReqID); <br> <br>if (SUCCEEDED(hr)) <br>MyTextOut(TEXT("IIlsUser::EnumProtocols(%x) pending.\r\n"), uReqID); <br>else <br>ErrorMessage(hwnd, TEXT("IIlsUser::EnumProtocols fails."), hr); <br> <br>return hr; <br>} <br> <br> <br>//**************************************************************************** <br>// <br>// int DisplayProtocol(HWND hwnd, IIlsUser *pu) <br>// <br>// <br>//**************************************************************************** <br>HRESULT DisplayProtocol(HWND hwnd, IIlsUser *pu) <br>{ <br>HRESULT hr = E_FAIL; <br>IIlsFilter *pFilter; <br>IIlsAttributes *pAttributes = NULL; <br>ULONG uReqID; <br>BSTR bstrProtID; <br>char szProtID[MAX_NAME]; <br> <br> <br>// use the global PROT filter, if not defined it will be NULL <br>// <br>pFilter = g_pProtFilter; <br>pAttributes = NULL; <br> <br>// Ask which user to query (need to get a better dialog box) <br>// <br>if(DialogBoxParam(ghInstance, MAKEINTRESOURCE(IDD_DLG_USERNAME), <br>hwnd, (DLGPROC)ProtoNameDlgProc, (LPARAM)szProtID) == IDOK) <br>{ <br>LPTSTR_to_BSTR(&amp;bstrProtID, szProtID); <br> <br>// The third param is unused and must be NULL <br>// <br>hr = pu-&gt;GetProtocol(bstrProtID, pAttributes, NULL, &amp;uReqID); <br> <br>if (SUCCEEDED(hr)) <br>MyTextOut(TEXT("IIlsUser::GetProtocol(%x) pending.\r\n"), uReqID); <br>else <br>ErrorMessage(hwnd, TEXT("IIlsUser::GetProtocol fails."), hr); <br>} <br>else <br>{ <br>//User cancelled <br>MyTextOut(TEXT("GetProtocol cancelled.\r\n")); <br>} <br> <br>return hr; <br>} <br> <br> <br> <br>//**************************************************************************** <br>// <br>// int ProtocolDlgProc (HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam) <br>// <br>// This function is the dialog procedure for the protocol dialog box. <br>// <br>//**************************************************************************** <br> <br>int ProtocolDlgProc (HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam) <br>{ <br>PROTOCOLINFO *ppi; <br> <br>switch (msg) <br>{ <br>case WM_INITDIALOG: <br>{ <br>SetWindowLong (hwnd, DWL_USER, lParam); <br>SetFocus (GetDlgItem(hwnd, IDC_PROT_NAME)); <br>break; <br>} <br> <br>case WM_COMMAND: <br>{ <br>switch (GET_WM_COMMAND_ID(wParam, lParam)) <br>{ <br>case IDOK: <br>ppi = (PPROTOCOLINFO)GetWindowLong(hwnd, DWL_USER); <br>SaveProtInfo(hwnd, ppi); <br>// FALL THROUGH !!! <br> <br>case IDCANCEL: <br>EndDialog(hwnd, GET_WM_COMMAND_ID(wParam, lParam)); <br>break; <br> <br>default: <br>break; <br>}; <br>break; <br>} <br> <br>default: <br>break; <br>}; <br> <br>return 0; <br>} <br> <br> <br> <br>//**************************************************************************** <br>// <br>// void SaveProtInfo(HWND hwnd, PPROTOCOLINFO ppi) <br>// <br>//**************************************************************************** <br>void SaveProtInfo(HWND hwnd, PPROTOCOLINFO ppi) <br>{ <br> <br>TCHAR szTemp[MAX_PATH]; <br>BOOL fSuccess; <br> <br>// retrieve the protocol name <br>// <br>GetDlgItemText(hwnd, IDC_PROT_NAME, szTemp, MAX_PATH); <br>ppi-&gt;szProtName = AllocLPTSTR(lstrlen(szTemp) + 1); <br>strcpy(ppi-&gt;szProtName, szTemp); <br> <br> <br>// retrieve the mime type <br>// <br>GetDlgItemText(hwnd, IDC_PROT_MIME, szTemp, MAX_PATH); <br>ppi-&gt;szProtMime = AllocLPTSTR(lstrlen(szTemp) + 1); <br>strcpy(ppi-&gt;szProtMime, szTemp); <br> <br> <br>// retrieve the protocol port to use <br>// <br>ppi-&gt;uPortNumber = GetDlgItemInt(hwnd, IDC_PROT_PORT, &amp;fSuccess, FALSE); <br> <br>} <br> <br> <br> <br>//**************************************************************************** <br>// <br>// void CreateProtocolDialog(HWND hwnd) <br>// <br>//**************************************************************************** <br>void CreateProtocolDialog(HWND hwnd) <br>{ <br>PROTOCOLINFO ProtInfo; <br>PROTOCOLINFO *pProtInfo = &amp;ProtInfo; <br>HRESULT hr; <br>BSTR bstrName, bstrMIME; <br>IIlsProtocol *pp; <br>ULONG uReqID; <br>char szUserName[MAX_NAME]; <br>PUSERNODE pun; <br>POSITION pos; <br>LPTSTR psz; <br> <br> <br>pProtInfo-&gt;szProtName = NULL; <br>pProtInfo-&gt;szProtMime = NULL; <br>pProtInfo-&gt;uPortNumber = 0; <br> <br> <br>// Prompt for the user  <br>// <br>if(DialogBoxParam(ghInstance, MAKEINTRESOURCE(IDD_DLG_LIST), <br>hwnd, (DLGPROC)UserListDlgProc, (LPARAM)szUserName) == IDOK) <br>{ <br> <br>if(!MyIsGoodString(szUserName)) <br>{ <br>MyTextOut(TEXT("User name is empty.\r\n")); <br>hr = E_FAIL; <br>goto MyExit; <br>} <br> <br>// match name to usernode <br>// <br>pos = g_pUserList-&gt;GetHeadPosition(); <br> <br>while(pos) <br>{ <br>pun = (PUSERNODE)g_pUserList-&gt;GetFromPosition(pos); <br> <br>hr = pun-&gt;pu-&gt;GetStandardAttribute(ILS_STDATTR_USER_ID, &amp;bstrName); <br>BSTR_to_LPTSTR(&amp;psz, bstrName); <br>if(strcmp(psz, szUserName) == 0) <br>{ <br>FreeLPTSTR(psz); <br>break; <br>} <br>g_pUserList-&gt;GetNext(pos); <br>FreeLPTSTR(psz); <br>} <br> <br>// Got the right user, get the protocol details... <br>// <br>if(DialogBoxParam(ghInstance, MAKEINTRESOURCE(IDD_DLG_PROTOCOL), <br>hwnd, (DLGPROC)ProtocolDlgProc, (LPARAM)pProtInfo) == IDOK) <br>{ <br> <br>if(!MyIsGoodString(pProtInfo-&gt;szProtName)) <br>{ <br>MyTextOut(TEXT("Protocol name is emtpy - no protocol object created.\r\n")); <br>hr = E_FAIL; <br>goto MyExit; <br>} <br> <br> <br>// Create the protocol for the user <br>// <br>LPTSTR_to_BSTR(&amp;bstrName, pProtInfo-&gt;szProtName); <br>LPTSTR_to_BSTR(&amp;bstrMIME, pProtInfo-&gt;szProtMime); <br> <br>hr = pun-&gt;pu-&gt;CreateProtocol(bstrName, pProtInfo-&gt;uPortNumber, bstrMIME, &amp;pp); <br> <br>SysFreeString(bstrName); <br>SysFreeString(bstrMIME); <br> <br>if(SUCCEEDED(hr)) <br>MyTextOut(TEXT("IIlsUser::CreateProtocol succeeded.\r\n")); <br>else <br>{ <br>ErrorMessage(hwnd, TEXT("IIlsUser::CreateProtocol fails."), hr); <br>goto MyExit; <br>} <br> <br>// Add the protocol to the user <br>// <br>hr = pun-&gt;pu-&gt;AddProtocol(pp, &amp;uReqID); <br>if (SUCCEEDED(hr)) <br>{ <br>ILS_STATE pState; <br> <br>// Adding is sync if the user is not yet registered <br>// <br>hr = pun-&gt;pu-&gt;GetState(&amp;pState); <br>if(pState == ILS_REGISTERED) <br>MyTextOut(TEXT("IIlsUser::AddProtocol(%x) pending.\r\n"), uReqID); <br>else if (pState == ILS_UNREGISTERED) <br>MyTextOut(TEXT("IIlsUser::AddProtocol returns %s.\r\n"), GetErrorString(hr)); <br>else <br>MyTextOut(TEXT("Hmm.. not sure of user's state on the server.\r\n")); <br> <br>// Add this protocol to the list for this user <br>// TODO - should really post a message in the callback and handle it in the <br>// main wndproc. <br>pun-&gt;pProtList-&gt;AddTail(pp); <br>} <br>else <br>ErrorMessage(hwnd, TEXT("IIlsMain::AddProtocol fails."), hr); <br> <br>} <br>else <br>{ <br>//  User cancelled <br>MyTextOut(TEXT("Create Protocol cancelled.\r\n")); <br>} <br>} <br>else <br>{ <br>//  User cancelled <br>MyTextOut(TEXT("User list cancelled.\r\n")); <br>} <br> <br>if(pProtInfo-&gt;szProtName != NULL) <br>FreeLPTSTR(pProtInfo-&gt;szProtName); <br>if(pProtInfo-&gt;szProtMime != NULL) <br>FreeLPTSTR(pProtInfo-&gt;szProtMime); <br> <br> <br> <br>MyExit: <br>return; <br>} <br> <br>//**************************************************************************** <br>// <br>// void DestroyProtocolDialog(HWND hwnd) <br>// <br>//**************************************************************************** <br>void DestroyProtocolDialog(HWND hwnd) <br>{ <br>PROTOCOLINFO ProtInfo; <br>PROTOCOLINFO *pProtInfo = &amp;ProtInfo; <br>HRESULT hr; <br>BSTR bstrName; <br>char szUserName[MAX_NAME]; <br>PUSERNODE pun; <br>POSITION pos; <br>LPTSTR psz; <br> <br>ENUMPROTINFO epi; <br>PENUMPROTINFO pepi = &amp;epi; <br> <br> <br>// Prompt for the user  <br>if(DialogBoxParam(ghInstance, MAKEINTRESOURCE(IDD_DLG_LIST), <br>hwnd, (DLGPROC)UserListDlgProc, (LPARAM)szUserName) == IDOK) <br>{ <br>if(!MyIsGoodString(szUserName)) <br>{ <br>MyTextOut(TEXT("User name is empty.\r\n")); <br>hr = E_FAIL; <br>goto MyExit; <br>} <br> <br> <br>// match name to usernode <br>pos = g_pUserList-&gt;GetHeadPosition(); <br> <br>while(pos) <br>{ <br>pun = (PUSERNODE)g_pUserList-&gt;GetFromPosition(pos); <br> <br>hr = pun-&gt;pu-&gt;GetStandardAttribute(ILS_STDATTR_USER_ID, &amp;bstrName); <br>BSTR_to_LPTSTR(&amp;psz, bstrName); <br>if(strcmp(psz, szUserName) == 0) <br>{ <br>FreeLPTSTR(psz); <br>break; <br>} <br>g_pUserList-&gt;GetNext(pos); <br>FreeLPTSTR(psz); <br>} <br> <br>// Got the right user, Enum the protocols... <br>// <br>pepi-&gt;pun = pun; <br> <br>if(DialogBoxParam(ghInstance, MAKEINTRESOURCE(IDD_DLG_LIST), <br>hwnd, (DLGPROC)ProtoListDlgProc, (LPARAM)pepi) == IDOK) <br>{ <br>// Everything is done in the ProtoListDlgProc function <br>} <br>else <br>{ <br>//User cancelled <br>MyTextOut(TEXT("Destroy Protocol cancelled.\r\n")); <br> <br>} <br>} <br>else <br>{ <br>//User cancelled <br>MyTextOut(TEXT("User list cancelled.\r\n")); <br>} <br>MyExit: <br>return; <br>} <br> <br> <br> <br> <br>//**************************************************************************** <br>// <br>// int ProtoListDlgProc (HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam) <br>// <br>// This function is the dialog proc that displays the protocols for the  <br>// current user objects and returns the chosen item. <br>// <br>//**************************************************************************** <br>int ProtoListDlgProc (HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam) <br>{ <br>HWND hwndList; <br>int iIndex; <br>HRESULT hr = E_FAIL; <br>ULONG uReqID; <br>PENUMPROTINFO pepi; <br>BSTR bstrName; <br>LPTSTR szName; <br>POSITION pos; <br>IIlsProtocol *pp; <br> <br>pp = NULL; <br> <br>switch (msg) <br>{ <br>case WM_INITDIALOG: <br>{ <br>hwndList = GetDlgItem(hwnd, IDC_LIST); <br> <br>pepi = (ENUMPROTINFO *)lParam; <br> <br>SetWindowLong (hwnd, DWL_USER, lParam); <br>SetWindowText(hwnd, "Protocol List"); <br> <br>// walk the list of Protocols and add the names to the list box <br>pos = pepi-&gt;pun-&gt;pProtList-&gt;GetHeadPosition(); <br> <br>while(pos) <br>{ <br>pp = (IIlsProtocol *)pepi-&gt;pun-&gt;pProtList-&gt;GetFromPosition(pos); <br> <br>hr = pp-&gt;GetStandardAttribute(ILS_STDATTR_PROTOCOL_NAME, &amp;bstrName); <br>BSTR_to_LPTSTR(&amp;szName, bstrName); <br>SendMessage(hwndList, LB_ADDSTRING, 0, (LPARAM)szName); <br>pepi-&gt;pun-&gt;pProtList-&gt;GetNext(pos); <br>FreeLPTSTR(szName); <br>} <br> <br>break; <br>} <br> <br>case WM_COMMAND: <br>{ <br>switch (GET_WM_COMMAND_ID(wParam, lParam)) <br>{ <br>case IDOK: <br>{ <br>TCHAR szTemp[256]; <br>hwndList = GetDlgItem(hwnd, IDC_LIST); <br> <br>// return the name of the user chosen  <br>pepi = (ENUMPROTINFO *)GetWindowLong(hwnd, DWL_USER); <br>iIndex = SendMessage(hwndList, LB_GETCURSEL, 0,0); <br>if(iIndex = -1)  <br>iIndex = 0; <br>iIndex = SendMessage(hwndList, LB_GETTEXT, iIndex, (LPARAM)szTemp); <br> <br>// walk the list of protocols until we find the one selected <br>pos = pepi-&gt;pun-&gt;pProtList-&gt;GetHeadPosition(); <br> <br>while(pos) <br>{ <br>pp = (IIlsProtocol *)pepi-&gt;pun-&gt;pProtList-&gt;GetFromPosition(pos); <br> <br>hr = pp-&gt;GetStandardAttribute(ILS_STDATTR_PROTOCOL_NAME, &amp;bstrName); <br>BSTR_to_LPTSTR(&amp;szName, bstrName); <br>if(strcmp(szName, szTemp) == 0) <br>{ <br>// TODO - really should post a message in the callback and  <br>// handle this in the main wndproc. <br>FreeLPTSTR(szName); <br>pepi-&gt;pun-&gt;pProtList-&gt;RemoveAt(pos); <br>break; <br>} <br>pepi-&gt;pun-&gt;pProtList-&gt;GetNext(pos); <br>FreeLPTSTR(szName); <br>} <br> <br>hr = pepi-&gt;pun-&gt;pu-&gt;RemoveProtocol(pp, &amp;uReqID); <br> <br>if(SUCCEEDED(hr)) <br>{ <br>ILS_STATE pState; <br> <br>// Removing is sync if the user is not yet registered <br>// <br>hr = pepi-&gt;pun-&gt;pu-&gt;GetState(&amp;pState); <br>if(pState == ILS_REGISTERED) <br>MyTextOut(TEXT("IIlsUser::RemoveProtocol(%x) pending.\r\n"), uReqID); <br>else if (pState == ILS_UNREGISTERED) <br>MyTextOut(TEXT("IIlsUser::RemoveProtocol returns %s.\r\n"), GetErrorString(hr)); <br>else <br>MyTextOut(TEXT("Hmm.. not sure of user's state on the server.\r\n"));  // TODO - better error handling here. <br>} <br>else <br>{ <br>ErrorMessage(hwnd, TEXT("RemoveProtocol failed"), hr); <br>} <br> <br> <br> <br>} <br> <br>// Fall through to end the dialog!! <br> <br>case IDCANCEL: <br>EndDialog(hwnd, GET_WM_COMMAND_ID(wParam, lParam)); <br>break; <br> <br>default: <br>break; <br>}; <br>break; <br>} <br> <br>default: <br>break; <br>}; <br> <br>return 0; <br>} <br> <br> <br>//**************************************************************************** <br>// <br>// int DisplayProtocolInfo(HWND hwnd, IIlsProtocol *pp) <br>// <br>// <br>//**************************************************************************** <br>HRESULT DisplayProtocolInfo(HWND hwnd, IIlsProtocol *pp) <br>{ <br>HRESULT hr = E_FAIL; <br>BSTR bstrTemp = NULL; <br>LPTSTR szTemp; <br>BOOL pValue; <br> <br>MyTextOut(" ---------------\r\n"); <br> <br>// Print out the protocol information  <br>// <br>hr = pp-&gt;IsWritable(&amp;pValue); <br>if (SUCCEEDED(hr)) <br>{ <br>if(pValue) <br>MyTextOut("Protocol is writable.\r\n"); <br>else <br>MyTextOut("Protocol is read only.\r\n"); <br>} <br>else <br>{ <br>ErrorMessage(hwnd, TEXT("IIlsProtocol::IsWritable fails."), hr); <br>} <br> <br> <br> <br>hr = pp-&gt;GetStandardAttribute(ILS_STDATTR_PROTOCOL_NAME, &amp;bstrTemp); <br>if (SUCCEEDED(hr)) <br>{ <br>BSTR_to_LPTSTR(&amp;szTemp, bstrTemp); <br>MyTextOut("Protocol name is %s.\r\n", szTemp); <br>SysFreeString(bstrTemp); <br>} <br>else <br>ErrorMessage(hwnd, TEXT("IIlsUser::GetStandardAttribute fails."), hr); <br> <br>hr = pp-&gt;GetStandardAttribute(ILS_STDATTR_PROTOCOL_MIME_TYPE, &amp;bstrTemp); <br>if (SUCCEEDED(hr)) <br>{ <br>BSTR_to_LPTSTR(&amp;szTemp, bstrTemp); <br>MyTextOut("Mime Type is %s.\r\n", szTemp); <br>SysFreeString(bstrTemp); <br>} <br>else <br>ErrorMessage(hwnd, TEXT("IIlsUser::GetStandardAttribute fails."), hr); <br> <br>hr = pp-&gt;GetStandardAttribute(ILS_STDATTR_PROTOCOL_PORT, &amp;bstrTemp); <br>if (SUCCEEDED(hr)) <br>{ <br>BSTR_to_LPTSTR(&amp;szTemp, bstrTemp); <br>MyTextOut("Port is %s.\r\n", szTemp); <br>SysFreeString(bstrTemp); <br>} <br>else <br>ErrorMessage(hwnd, TEXT("IIlsUser::GetStandardAttribute fails."), hr); <br> <br>MyTextOut(" ---------------\r\n"); <br> <br>return hr; <br>} <br> <br> <br> <br> <br> <br> <br>//**************************************************************************** <br>// <br>// int ProtoNameDlgProc (HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam) <br>// <br>// This function is the dialog proc that prompts the user for a protocol name <br>// <br>//**************************************************************************** <br>int ProtoNameDlgProc (HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam) <br>{ <br>LPTSTR pszTemp; <br>HRESULT hr = E_FAIL; <br> <br> <br>switch (msg) <br>{ <br>case WM_INITDIALOG: <br>{ <br>SetWindowLong (hwnd, DWL_USER, lParam); <br>SetFocus(GetDlgItem(hwnd, IDC_USER_NAME)); <br>SetWindowText(hwnd, "Protocol name"); <br> <br>break; <br>} <br> <br>case WM_COMMAND: <br>{ <br>switch (GET_WM_COMMAND_ID(wParam, lParam)) <br>{ <br>case IDOK: <br>// return the name of the user chosen  <br>pszTemp = (LPTSTR)GetWindowLong(hwnd, DWL_USER); <br>GetDlgItemText(hwnd, IDC_USER_NAME, pszTemp, MAX_NAME); <br> <br>// Fall through to end the dialog!! <br> <br>case IDCANCEL: <br>EndDialog(hwnd, GET_WM_COMMAND_ID(wParam, lParam)); <br>break; <br> <br>default: <br>break; <br>}; <br>break; <br>} <br> <br>default: <br>break; <br>}; <br> <br>return 0; <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
