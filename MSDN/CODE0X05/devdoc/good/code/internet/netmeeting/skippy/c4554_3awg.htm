<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>UTILS.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context4570"></a>UTILS.CPP</h2>
<pre><code>//**************************************************************************** <br>// <br>//  SKIPPY! sample for Microsoft NetMeeting SDK <br>// <br>//  File:       utils.cpp <br>//  Content:    This file contains utility functions. <br>// <br>//  Copyright (c) Microsoft Corporation 1997 <br>//  All rights reserved <br>// <br>//**************************************************************************** <br> <br>#include "ilstest.h" <br> <br>// <br>int g_nOpen, g_nClosed, g_nDocument; <br> <br> <br>//**************************************************************************** <br>//  <br>// void _cdecl MyTextOut (LPCTSTR szFmt, ...) <br>// <br>// This function displays the textual message in the application log box. <br>//  <br>//**************************************************************************** <br> <br>void _cdecl MyTextOut (LPCTSTR szFmt, ...) <br>{ <br>HWND hEdit; <br>va_list VarArg; <br>TCHAR   szText[256]; <br> <br>va_start(VarArg,szFmt); <br>wvsprintf(szText, szFmt, VarArg); <br> <br>hEdit = GetDlgItem(g_hwndMain, IDC_ACT_EDIT); <br>Edit_SetSel(hEdit, 0xFFFF, 0xFFFF); <br>Edit_ReplaceSel(hEdit, szText); <br>return; <br>} <br> <br>//**************************************************************************** <br>//  <br>// void ErrorMessage(HWND hwnd, LPCTSTR szPrefix, HRESULT hr) <br>// <br>// This function prompts the end-user with the error message box. <br>//  <br>//**************************************************************************** <br> <br>void ErrorMessage(HWND hwnd, LPCTSTR szPrefix, HRESULT hr) <br>{ <br>TCHAR   szMessage[256]; <br> <br>if (HRESULT_FACILITY(hr) == FACILITY_WINDOWS) <br>hr = HRESULT_CODE(hr); <br>  <br>wsprintf (szMessage, TEXT("\r\n%s: returns %s (%lx)\r\n"), szPrefix, GetErrorString(hr), hr); <br>MessageBox(hwnd, szMessage, TEXT("Function return"), MB_OK | MB_ICONERROR); <br>return; <br>} <br> <br>//**************************************************************************** <br>// <br>// LPTSTR AllocLPTSTR (ULONG cb) <br>// <br>// This function allocates a LPTSTR <br>// <br>//**************************************************************************** <br> <br>LPTSTR AllocLPTSTR (ULONG cb) <br>{ <br>LPTSTR psz; <br> <br>psz = (LPTSTR)LocalAlloc(LMEM_FIXED, cb*sizeof(TCHAR)); <br>return psz; <br>} <br> <br>//**************************************************************************** <br>// <br>// HRESULT FreeLPTSTR (LPTSTR psz) <br>// <br>// This function frees the LPTSTR  <br>// <br>//**************************************************************************** <br> <br>HRESULT FreeLPTSTR (LPTSTR psz) <br>{ <br>HLOCAL hRet; <br>hRet = LocalFree(psz); <br>return( hRet == NULL ? S_OK : E_FAIL); <br>} <br> <br>//**************************************************************************** <br>// <br>// HRESULT SetLPTSTR (LPTSTR *ppszName, LPCTSTR pszUserName) <br>// <br>// This function creates a name buffer <br>// <br>//**************************************************************************** <br> <br>HRESULT SetLPTSTR (LPTSTR *ppszName, LPCTSTR pszUserName) <br>{ <br>LPTSTR pszNew; <br> <br>// Allocate a name buffer <br>// <br>pszNew = AllocLPTSTR(lstrlen(pszUserName)+1); <br> <br>// It would be bad if the name buffer cannot be allocated, <br>// but we can live with it. <br>// <br>if (pszNew != NULL) <br>{ <br>lstrcpy(pszNew, pszUserName); <br> <br>// Free the old name <br>// <br>if (*ppszName != NULL) <br>{ <br>FreeLPTSTR(*ppszName); <br>}; <br>*ppszName = pszNew; <br>return S_OK; <br>} <br>else <br>{ <br>return E_OUTOFMEMORY; <br>}; <br>} <br> <br>//**************************************************************************** <br>// <br>// HRESULT LPTSTR_to_BSTR (BSTR *pbstr, LPCTSTR psz) <br>// <br>//**************************************************************************** <br> <br>HRESULT LPTSTR_to_BSTR (BSTR *pbstr, LPCTSTR psz) <br>{ <br>#ifndef UNICODE <br> <br>BSTR bstr; <br>int i; <br>HRESULT hr; <br> <br> <br>// compute the length of the required BSTR <br>// <br>i =  MultiByteToWideChar(CP_ACP, 0, psz, -1, NULL, 0); <br>if (i &lt;= 0) <br>{ <br>return E_UNEXPECTED; <br>}; <br> <br>// allocate the widestr, +1 for terminating null <br>// <br>bstr = SysAllocStringLen(NULL, i-1); // SysAllocStringLen adds 1 <br> <br>if (bstr != NULL) <br>{  <br>MultiByteToWideChar(CP_ACP, 0, psz, -1, (LPWSTR)bstr, i); <br>((LPWSTR)bstr)[i - 1] = 0; <br>*pbstr = bstr; <br>hr = S_OK; <br>} <br>else <br>{ <br>hr = E_OUTOFMEMORY; <br>}; <br>return hr; <br> <br>#else <br> <br>BSTR bstr; <br> <br>bstr = SysAllocString(psz); <br> <br>if (bstr != NULL) <br>{ <br>*pbstr = bstr; <br>return S_OK; <br>} <br>else <br>{ <br>return E_OUTOFMEMORY; <br>}; <br> <br>#endif // UNICODE <br>} <br> <br>//**************************************************************************** <br>// <br>// HRESULT BSTR_to_LPTSTR (LPTSTR *ppsz, BSTR bstr) <br>// <br>//**************************************************************************** <br> <br>HRESULT BSTR_to_LPTSTR (LPTSTR *ppsz, BSTR bstr) <br>{ <br>#ifndef UNICODE <br> <br>LPTSTR psz; <br>int i; <br>HRESULT hr; <br> <br>// Whoa... handle the NULL string first. <br>// <br>if(bstr == NULL)  // if bstr is NULL we return E_UNEXPECTED and pass a default string <br>{ <br>psz = AllocLPTSTR(lstrlen("")+1); <br>if(psz != NULL) <br>{ <br>strcpy(psz, ""); <br>*ppsz = psz; <br>} <br>return E_UNEXPECTED; <br>} <br> <br>// compute the length of the required BSTR <br>// <br>i =  WideCharToMultiByte(CP_ACP, 0, (LPWSTR)bstr, -1, NULL, 0, NULL, NULL); <br>if (i &lt;= 0) <br>{ <br>return E_UNEXPECTED; <br>}; <br> <br>// allocate the widestr, +1 for terminating null <br>// <br>psz = AllocLPTSTR(i); <br> <br>if (psz != NULL) <br>{  <br>WideCharToMultiByte(CP_ACP, 0, (LPWSTR)bstr, -1, psz, i, NULL, NULL); <br>*ppsz = psz; <br>hr = S_OK; <br>} <br>else <br>{ <br>hr = E_OUTOFMEMORY; <br>}; <br>return hr; <br> <br>#else <br> <br>LPTSTR psz = NULL; <br>HRESULT hr; <br> <br>hr = SetName(&amp;psz, (LPTSTR)bstr); <br> <br>if (hr == S_OK) <br>{ <br>*ppsz = psz; <br>}; <br>return hr; <br> <br>#endif // UNICODE <br>} <br> <br>//**************************************************************************** <br>// <br>// HRESULT DisplayIlsNames(HWND hwnd, IEnumIlsNames *pEnum, LPTSTR szString) <br>// <br>// This function displays enumerated text in the output <br>// <br>//**************************************************************************** <br> <br>HRESULT DisplayIlsNames(HWND hwnd, IEnumIlsNames *pEnum, LPTSTR szString) <br>{ <br>BSTR bstrName; <br>LPTSTR pszName; <br>ULONG iIndex = 1; <br> <br>// For each name <br>// <br>MyTextOut(TEXT("******** Found the following %s ************\r\n"), szString); <br> <br>while (pEnum-&gt;Next(1, &amp;bstrName, NULL) == NOERROR) <br>{ <br>BSTR_to_LPTSTR(&amp;pszName, bstrName); <br>MyTextOut(TEXT("\t%d&gt; %s\r\n"), iIndex, pszName); <br>iIndex++; <br>SysFreeString(bstrName); <br>FreeLPTSTR(pszName); <br>}; <br>pEnum-&gt;Release(); <br> <br>MyTextOut(TEXT("*****************************************************\r\n")); <br>return NOERROR; <br>} <br> <br> <br> <br>//**************************************************************************** <br>// <br>// HRESULT DisplayAboutBox(HWND hwnd) <br>// <br>// This function displays the application's about box <br>// <br>//**************************************************************************** <br> <br>VOID DisplayAboutBox(HWND hwnd) <br>{ <br>char szVersion[MAX_PATH]; <br> <br>LoadString(ghInstance, IDS_VERSION, szVersion, sizeof(szVersion)); <br> <br>ShellAbout(hwnd, szVersion, NULL, LoadIcon(ghInstance, MAKEINTRESOURCE(IDI_APP_ICON))); <br>} <br> <br> <br>// STRING_CASE turns a #define into a case statement <br>#define STRING_CASE(val)  case val: pcsz = #val; break <br> <br> <br>//**************************************************************************** <br>// <br>// int GetErrorString(HRESULT hr) <br>// <br>// This function returns a pointer a string describing the error condition <br>// The error strings are lifted from ULS.H <br>// <br>//**************************************************************************** <br>LPCTSTR GetErrorString(HRESULT hr) <br>{ <br>LPCTSTR pcsz; <br>static CHAR sz[MAX_PATH]; <br> <br>switch (hr) <br>{ <br>default: <br>wsprintf(sz, "(unknown)"); <br>pcsz = sz; <br>break; <br> <br>STRING_CASE(S_OK); <br>STRING_CASE(S_FALSE); <br> <br>// The one success code  <br> <br>STRING_CASE(ILS_S_SERVER_MAY_NOT_SUPPORT); <br> <br> <br>// overloaded error codes <br> <br>STRING_CASE(ILS_E_FAIL); <br>STRING_CASE(ILS_E_POINTER); <br>STRING_CASE(ILS_E_HANDLE); <br>STRING_CASE(ILS_E_ABORT); <br>STRING_CASE(ILS_E_ACCESS_DENIED); <br>STRING_CASE(ILS_E_NOT_IMPL); <br>STRING_CASE(ILS_E_NO_INTERFACE); <br>STRING_CASE(ILS_E_MEMORY); <br>STRING_CASE(ILS_E_PARAMETER); <br> <br>//  General error codes <br> <br>STRING_CASE(ILS_E_SERVER_SERVICE); <br>STRING_CASE(ILS_E_SERVER_NAME); <br>STRING_CASE(ILS_E_TIMEOUT); <br>STRING_CASE(ILS_E_BIND); <br>STRING_CASE(ILS_E_THREAD); <br>STRING_CASE(ILS_E_SERVER_EXEC); <br>STRING_CASE(ILS_E_WINSOCK); <br>STRING_CASE(ILS_E_NO_MORE); <br>STRING_CASE(ILS_E_NOT_INITIALIZED); <br>STRING_CASE(ILS_E_NOTIFY_ID); <br>STRING_CASE(ILS_E_NO_SUCH_OBJECT); <br>STRING_CASE(ILS_E_NEED_RELOGON); <br>STRING_CASE(ILS_E_NAME_CONFLICTS); <br>STRING_CASE(ILS_E_NETWORK_DOWN); <br>STRING_CASE(ILS_E_FILTER_STRING); <br>STRING_CASE(ILS_E_FILTER_OBJECT); <br>STRING_CASE(ILS_E_FILTER_TYPE); <br>STRING_CASE(ILS_E_ACCESS_CONTROL); <br>STRING_CASE(ILS_E_NOT_REGISTERED); <br>STRING_CASE(ILS_E_NO_SUCH_MEMBER); <br>STRING_CASE(ILS_E_NO_WRITE_ACCESS); <br>STRING_CASE(ILS_E_ALREADY_REGISTERED); <br> <br>//  LDAP specific error codes <br> <br>STRING_CASE(ILS_E_LDAP_OPERATIONS_ERROR); <br>STRING_CASE(ILS_E_LDAP_PROTOCOL_ERROR); <br>STRING_CASE(ILS_E_LDAP_TIMELIMIT_EXCEEDED); <br>STRING_CASE(ILS_E_LDAP_SIZELIMIT_EXCEEDED); <br>STRING_CASE(ILS_E_LDAP_COMPARE_FALSE); <br>STRING_CASE(ILS_E_LDAP_COMPARE_TRUE); <br>STRING_CASE(ILS_E_LDAP_AUTH_METHOD_NOT_SUPPORTED); <br>STRING_CASE(ILS_E_LDAP_STRONG_AUTH_REQUIRED); <br>STRING_CASE(ILS_E_LDAP_REFERRAL_V2); <br>STRING_CASE(ILS_E_LDAP_PARTIAL_RESULTS); <br>STRING_CASE(ILS_E_LDAP_REFERRAL); <br>STRING_CASE(ILS_E_LDAP_ADMIN_LIMIT_EXCEEDED); <br>STRING_CASE(ILS_E_LDAP_UNAVAILABLE_CRIT_EXTENSION); <br> <br>STRING_CASE(ILS_E_LDAP_NO_SUCH_ATTRIBUTE); <br>STRING_CASE(ILS_E_LDAP_UNDEFINED_TYPE); <br>STRING_CASE(ILS_E_LDAP_INAPPROPRIATE_MATCHING); <br>STRING_CASE(ILS_E_LDAP_CONSTRAINT_VIOLATION); <br>STRING_CASE(ILS_E_LDAP_ATTRIBUTE_OR_VALUE_EXISTS); <br>STRING_CASE(ILS_E_LDAP_INVALID_SYNTAX); <br> <br>STRING_CASE(ILS_E_LDAP_ALIAS_PROBLEM); <br>STRING_CASE(ILS_E_LDAP_INVALID_DN_SYNTAX); <br>STRING_CASE(ILS_E_LDAP_IS_LEAF); <br>STRING_CASE(ILS_E_LDAP_ALIAS_DEREF_PROBLEM); <br> <br>STRING_CASE(ILS_E_LDAP_INAPPROPRIATE_AUTH); <br>STRING_CASE(ILS_E_LDAP_INVALID_CREDENTIALS); <br>STRING_CASE(ILS_E_LDAP_INSUFFICIENT_RIGHTS); <br>STRING_CASE(ILS_E_LDAP_BUSY); <br>STRING_CASE(ILS_E_LDAP_UNAVAILABLE); <br>STRING_CASE(ILS_E_LDAP_UNWILLING_TO_PERFORM); <br>STRING_CASE(ILS_E_LDAP_LOOP_DETECT); <br> <br>STRING_CASE(ILS_E_LDAP_NAMING_VIOLATION); <br>STRING_CASE(ILS_E_LDAP_OBJECT_CLASS_VIOLATION); <br>STRING_CASE(ILS_E_LDAP_NOT_ALLOWED_ON_NONLEAF); <br>STRING_CASE(ILS_E_LDAP_NOT_ALLOWED_ON_RDN); <br>STRING_CASE(ILS_E_LDAP_NO_OBJECT_CLASS_MODS); <br>STRING_CASE(ILS_E_LDAP_RESULTS_TOO_LARGE); <br>STRING_CASE(ILS_E_LDAP_AFFECTS_MULTIPLE_DSAS); <br> <br>STRING_CASE(ILS_E_LDAP_OTHER); <br>STRING_CASE(ILS_E_LDAP_SERVER_DOWN); <br>STRING_CASE(ILS_E_LDAP_LOCAL_ERROR); <br>STRING_CASE(ILS_E_LDAP_ENCODING_ERROR); <br>STRING_CASE(ILS_E_LDAP_DECODING_ERROR); <br>STRING_CASE(ILS_E_LDAP_TIMEOUT); <br>STRING_CASE(ILS_E_LDAP_AUTH_UNKNOWN); <br>STRING_CASE(ILS_E_LDAP_FILTER_ERROR); <br>STRING_CASE(ILS_E_LDAP_USER_CANCELLED); <br>STRING_CASE(ILS_E_LDAP_NO_MEMORY); <br>} <br>return pcsz; <br>} <br> <br> <br> <br> <br> <br>//********************************************************** <br>// DisplayStdAttr - display all the standard attribute information <br>// <br>//     <br>//********************************************************** <br>void DisplayStdAtt(void *pobj, ILS_STD_ATTR_NAME stdAttr, LPTSTR szDesc, OBJECT_TYPE ot) <br>{ <br>HRESULT hr = E_FAIL; <br>BSTR bstr = NULL; <br>LPTSTR sz = NULL; <br> <br>switch(ot) <br>{ <br>case USER:  // user objects <br>{ <br>IIlsUser *pObject = (IIlsUser *)pobj; <br>hr = pObject-&gt;GetStandardAttribute(stdAttr, &amp;bstr); <br>break; <br>} <br>case PROTOCOL:  // protocol objects <br>{ <br>IIlsProtocol *pObject = (IIlsProtocol *)pobj; <br>hr = pObject-&gt;GetStandardAttribute(stdAttr, &amp;bstr); <br>break; <br>} <br>default: <br>MyTextOut(TEXT("ERROR - hit default in DumpStdAttr, no type?")); <br>} <br> <br>if(SUCCEEDED(hr)) <br>{ <br>// retrieved the correct object, print out its value <br>hr = BSTR_to_LPTSTR(&amp;sz, bstr); <br>if(!sz) <br>MyTextOut(TEXT("%s    = &lt;NULL&gt;\r\n"), szDesc); <br>else <br>MyTextOut(TEXT("%s    = %s\r\n"), szDesc, sz); <br>} <br>else <br>{ <br>MyTextOut(TEXT("ERROR retrieving %s, returns %s.\r\n"), szDesc, GetErrorString(hr)); <br>} <br> <br>if(sz) <br>FreeLPTSTR(sz); <br> <br>} <br> <br> <br> <br> <br> <br> <br>//********************************************************** <br>// DisplayExtAttr - display the requested extended attribute  <br>// information <br>// <br>//     <br>//********************************************************** <br>void DisplayExtAtt(void *pobj, DWORD dwExtAttr, LPTSTR szDesc, OBJECT_TYPE ot) <br>{ <br>HRESULT hr = E_FAIL; <br>BSTR bstr = NULL, bstrName = NULL; <br>LPTSTR sz = NULL; <br>TCHAR szProperty[100]; <br> <br>switch(ot) <br>{ <br>case USER:  // user objects <br>{ <br>IIlsUser *pObject = (IIlsUser *)pobj; <br>wsprintf(szProperty, TEXT("%lu"), PROP_TAG(PT_STRING8, dwExtAttr)); <br>LPTSTR_to_BSTR(&amp;bstrName, szProperty); <br>hr = pObject-&gt;GetExtendedAttribute(bstrName, &amp;bstr); <br>break; <br>} <br>case PROTOCOL:  // protocol objects <br>{ <br>IIlsProtocol *pObject = (IIlsProtocol *)pobj; <br>wsprintf(szProperty, TEXT("%lu"), PROP_TAG(PT_STRING8, dwExtAttr)); <br>LPTSTR_to_BSTR(&amp;bstrName, szProperty); <br>hr = pObject-&gt;GetExtendedAttribute(bstrName, &amp;bstr); <br>break; <br>} <br>default: <br>MyTextOut(TEXT("ERROR - hit default in DumpExtAttr, no type?")); <br>} <br> <br>if(SUCCEEDED(hr)) <br>{ <br>// retrieved the correct object, convert back to a string <br>hr = BSTR_to_LPTSTR(&amp;sz, bstr); <br> <br>if(!sz)  // retrieved an empty string for some reason !!! <br>MyTextOut(TEXT("%s    = &lt;NULL&gt;\r\n"), szDesc); <br>else <br>if( dwExtAttr == NM_RESTRICTION) <br>{ <br>CHAR szType[MAX_PATH]; <br> <br>switch (sz[0]) <br>{ <br>case '1': <br>wsprintf(szType, "Business"); <br>break; <br>case '2': <br>wsprintf(szType, "Personal"); <br>break; <br>case '4': <br>wsprintf(szType, "Adult"); <br>break; <br>default: <br>wsprintf(szType, "(unknown)"); <br> <br>} <br> <br>MyTextOut(TEXT("%s    = %s\r\n"), szDesc, szType); <br> <br>} <br>else <br>MyTextOut(TEXT("%s    = %s\r\n"), szDesc,  <br>(lstrcmp(sz, "1") == 0) ? "yes" : "no"); <br>} <br>else <br>{ <br>MyTextOut(TEXT("ERROR retrieving %s, returns %s.\r\n"), szDesc, GetErrorString(hr)); <br>} <br> <br>if(sz) <br>FreeLPTSTR(sz); <br> <br>} <br> <br> <br> <br>//**************************************************************************** <br>// <br>// int StringFromGuid (REFIID riid, LPTSTR pszBuf) <br>// <br>// This function returns a string from a CLSID or GUID <br>// <br>//**************************************************************************** <br> <br>int StringFromGuid (REFIID   riid, LPTSTR pszBuf) <br>{ <br>return wsprintf(pszBuf,  <br>TEXT("{%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}"), <br>riid.Data1, riid.Data2, riid.Data3, riid.Data4[0], riid.Data4[1],  <br>riid.Data4[2], riid.Data4[3], riid.Data4[4], riid.Data4[5],  <br>riid.Data4[6], riid.Data4[7]); <br>} <br> <br> <br>//**************************************************************************** <br>//  <br>// int GetRadioButton(HWND hdlg, int idrFirst, int idrLast); <br>// <br>// return the id of the radio button in a given range <br>// <br>//**************************************************************************** <br>int GetRadioButton(HWND hdlg, int idrFirst, int idrLast) <br>{ <br>int id; <br>for (id = idrFirst; id&lt;=idrLast; id++) <br>{ <br>if(IsDlgButtonChecked(hdlg, id)) <br>return id; <br>} <br> <br>return idrFirst; <br>} <br> <br> <br>//**************************************************************************** <br>//  <br>// BOOL MyIsGoodString(LPTSTR psz) <br>// <br>// determine if a string is NULL or empty <br>// <br>//**************************************************************************** <br>BOOL MyIsGoodString(LPTSTR psz) <br>{ <br>if((psz == NULL) || 0 == strcmp(psz, "")) <br>return FALSE; <br>else <br>return TRUE; <br> <br>} <br> <br> <br>//**************************************************************************** <br>//  <br>// HRESULT GetNMAttributesObject( IIlsAttributes **ppa ) <br>// <br>// return a pointer to an Attribute object with NetMeeting <br>// ExtendedAttributes specified. <br>// <br>//**************************************************************************** <br>HRESULT GetNMAttributesObject( IIlsMain *pIls, IIlsAttributes **ppa ) <br>{ <br>HRESULT hr = E_FAIL; <br>IIlsAttributes *pAttrib = NULL; <br> <br> <br>hr = pIls-&gt;CreateAttributes(ILS_ATTRTYPE_NAME_VALUE, &amp;pAttrib); <br> <br>if (SUCCEEDED(hr)) <br>{ <br> <br>// got an Attributes object, now fill it in. <br>BSTR bstrEmpty = NULL, bstrName = NULL; <br>TCHAR szProperty[100]; <br> <br>LPTSTR_to_BSTR(&amp;bstrEmpty, ""); <br> <br>wsprintf(szProperty, TEXT("%lu"), PROP_TAG(PT_STRING8, NM_IN_A_CALL));  // 400 <br>LPTSTR_to_BSTR(&amp;bstrName, szProperty); <br>hr = pAttrib-&gt;SetAttribute(bstrName, bstrEmpty); <br> <br>wsprintf(szProperty, TEXT("%lu"), PROP_TAG(PT_STRING8, NM_RESTRICTION));  // 600 <br>LPTSTR_to_BSTR(&amp;bstrName, szProperty); <br>hr = pAttrib-&gt;SetAttribute(bstrName, bstrEmpty); <br> <br>wsprintf(szProperty, TEXT("%lu"), PROP_TAG(PT_STRING8, NM_SEND_AUDIO));  // 501 <br>LPTSTR_to_BSTR(&amp;bstrName, szProperty); <br>hr = pAttrib-&gt;SetAttribute(bstrName, bstrEmpty); <br> <br>wsprintf(szProperty, TEXT("%lu"), PROP_TAG(PT_STRING8, NM_SEND_VIDEO));  // 503 <br>LPTSTR_to_BSTR(&amp;bstrName, szProperty); <br>hr = pAttrib-&gt;SetAttribute(bstrName, bstrEmpty); <br> <br>} <br>*ppa = pAttrib; <br> <br>return hr; <br>} <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
