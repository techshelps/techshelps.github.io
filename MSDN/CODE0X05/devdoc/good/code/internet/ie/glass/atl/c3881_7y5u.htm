<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>ATLWIN.H</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3882"></a>ATLWIN.H</h2>
<pre><code>// This is a part of the Active Template Library. <br>// Copyright (C) 1996-1997 Microsoft Corporation <br>// All rights reserved. <br>// <br>// This source code is only intended as a supplement to the <br>// Active Template Library Reference and related <br>// electronic documentation provided with the library. <br>// See these sources for detailed information regarding the <br>// Active Template Library product. <br> <br>#ifndef __ATLWIN_H__ <br>#define __ATLWIN_H__ <br> <br>#ifndef __cplusplus <br>#error ATL requires C++ compilation (use a .cpp suffix) <br>#endif <br> <br>#ifndef __ATLBASE_H__ <br>#error atlwin.h requires atlbase.h to be included first <br>#endif <br> <br>#ifndef ATL_NO_NAMESPACE <br>namespace ATL <br>{ <br>#endif <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// Forward declarations <br> <br>class CWindow; <br>class CMessageMap; <br>class CDynamicChain; <br>class CWndClassInfo; <br>template &lt;class T&gt; class CWindowImpl; <br>template &lt;class T&gt; class CDialogImpl; <br>class CContainedWindow; <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// CWindow - client side for a Windows window <br> <br>class CWindow <br>{ <br>public: <br>HWND m_hWnd; <br> <br>CWindow(HWND hWnd = NULL) <br>{ <br>m_hWnd = hWnd; <br>} <br> <br>CWindow&amp; operator=(HWND hWnd) <br>{ <br>m_hWnd = hWnd; <br>return *this; <br>} <br> <br>void Attach(HWND hWndNew) <br>{ <br>_ASSERTE(::IsWindow(hWndNew)); <br>m_hWnd = hWndNew; <br>} <br> <br>HWND Detach() <br>{ <br>HWND hWnd = m_hWnd; <br>m_hWnd = NULL; <br>return hWnd; <br>} <br> <br>BOOL DestroyWindow() <br>{ <br>_ASSERTE(::IsWindow(m_hWnd)); <br> <br>if(!::DestroyWindow(m_hWnd)) <br>return FALSE; <br> <br>m_hWnd = NULL; <br>return TRUE; <br>} <br> <br>// Attributes <br> <br>operator HWND() const { return m_hWnd; } <br> <br>DWORD GetStyle() const <br>{ <br>_ASSERTE(::IsWindow(m_hWnd)); <br>return (DWORD)::GetWindowLong(m_hWnd, GWL_STYLE); <br>} <br> <br>DWORD GetExStyle() const <br>{ <br>_ASSERTE(::IsWindow(m_hWnd)); <br>return (DWORD)::GetWindowLong(m_hWnd, GWL_EXSTYLE); <br>} <br> <br>BOOL ModifyStyle(DWORD dwRemove, DWORD dwAdd, UINT nFlags = 0); <br>BOOL ModifyStyleEx(DWORD dwRemove, DWORD dwAdd, UINT nFlags = 0); <br> <br>LONG GetWindowLong(int nIndex) const <br>{ <br>_ASSERTE(::IsWindow(m_hWnd)); <br>return ::GetWindowLong(m_hWnd, nIndex); <br>} <br> <br>LONG SetWindowLong(int nIndex, LONG dwNewLong) <br>{ <br>_ASSERTE(::IsWindow(m_hWnd)); <br>return ::SetWindowLong(m_hWnd, nIndex, dwNewLong); <br>} <br> <br>WORD GetWindowWord(int nIndex) const <br>{ <br>_ASSERTE(::IsWindow(m_hWnd)); <br>return ::GetWindowWord(m_hWnd, nIndex); <br>} <br> <br>WORD SetWindowWord(int nIndex, WORD wNewWord) <br>{ <br>_ASSERTE(::IsWindow(m_hWnd)); <br>return ::SetWindowWord(m_hWnd, nIndex, wNewWord); <br>} <br> <br>// Message Functions <br> <br>LRESULT SendMessage(UINT message, WPARAM wParam = 0, LPARAM lParam = 0) <br>{ <br>_ASSERTE(::IsWindow(m_hWnd)); <br>return ::SendMessage(m_hWnd,message,wParam,lParam); <br>} <br> <br>BOOL PostMessage(UINT message, WPARAM wParam = 0, LPARAM lParam = 0) <br>{ <br>_ASSERTE(::IsWindow(m_hWnd)); <br>return ::PostMessage(m_hWnd,message,wParam,lParam); <br>} <br> <br>BOOL SendNotifyMessage(UINT message, WPARAM wParam = 0, LPARAM lParam = 0) <br>{ <br>_ASSERTE(::IsWindow(m_hWnd)); <br>return ::SendNotifyMessage(m_hWnd, message, wParam, lParam); <br>} <br> <br>// Window Text Functions <br> <br>BOOL SetWindowText(LPCTSTR lpszString) <br>{ <br>_ASSERTE(::IsWindow(m_hWnd)); <br>return ::SetWindowText(m_hWnd, lpszString); <br>} <br> <br>int GetWindowText(LPTSTR lpszStringBuf, int nMaxCount) const <br>{ <br>_ASSERTE(::IsWindow(m_hWnd)); <br>return ::GetWindowText(m_hWnd, lpszStringBuf, nMaxCount); <br>} <br> <br>int GetWindowTextLength() const <br>{ <br>_ASSERTE(::IsWindow(m_hWnd)); <br>return ::GetWindowTextLength(m_hWnd); <br>} <br> <br>BOOL GetWindowText(BSTR&amp; bstrText); <br> <br>// Font Functions <br> <br>void SetFont(HFONT hFont, BOOL bRedraw = TRUE) <br>{ <br>_ASSERTE(::IsWindow(m_hWnd)); <br>::SendMessage(m_hWnd, WM_SETFONT, (WPARAM)hFont, MAKELPARAM(bRedraw, 0)); <br>} <br> <br>HFONT GetFont() const <br>{ <br>_ASSERTE(::IsWindow(m_hWnd)); <br>return (HFONT)::SendMessage(m_hWnd, WM_GETFONT, 0, 0); <br>} <br> <br>// Menu Functions (non-child windows only) <br> <br>HMENU GetMenu() const <br>{ <br>_ASSERTE(::IsWindow(m_hWnd)); <br>return ::GetMenu(m_hWnd); <br>} <br> <br>BOOL SetMenu(HMENU hMenu) <br>{ <br>_ASSERTE(::IsWindow(m_hWnd)); <br>return ::SetMenu(m_hWnd, hMenu); <br>} <br> <br>BOOL DrawMenuBar() <br>{ <br>_ASSERTE(::IsWindow(m_hWnd)); <br>return ::DrawMenuBar(m_hWnd); <br>} <br> <br>HMENU GetSystemMenu(BOOL bRevert) const <br>{ <br>_ASSERTE(::IsWindow(m_hWnd)); <br>return ::GetSystemMenu(m_hWnd, bRevert); <br>} <br> <br>BOOL HiliteMenuItem(HMENU hMenu, UINT uItemHilite, UINT uHilite) <br>{ <br>_ASSERTE(::IsWindow(m_hWnd)); <br>return ::HiliteMenuItem(m_hWnd, hMenu, uItemHilite, uHilite); <br>} <br> <br>// Window Size and Position Functions <br> <br>BOOL IsIconic() const <br>{ <br>_ASSERTE(::IsWindow(m_hWnd)); <br>return ::IsIconic(m_hWnd); <br>} <br> <br>BOOL IsZoomed() const <br>{ <br>_ASSERTE(::IsWindow(m_hWnd)); <br>return ::IsZoomed(m_hWnd); <br>} <br> <br>BOOL MoveWindow(int x, int y, int nWidth, int nHeight, BOOL bRepaint = TRUE) <br>{ <br>_ASSERTE(::IsWindow(m_hWnd)); <br>return ::MoveWindow(m_hWnd, x, y, nWidth, nHeight, bRepaint); <br>} <br> <br>BOOL MoveWindow(LPCRECT lpRect, BOOL bRepaint = TRUE) <br>{ <br>_ASSERTE(::IsWindow(m_hWnd)); <br>return ::MoveWindow(m_hWnd, lpRect-&gt;left, lpRect-&gt;top, lpRect-&gt;right - lpRect-&gt;left, lpRect-&gt;bottom - lpRect-&gt;top, bRepaint); <br>} <br> <br>BOOL SetWindowPos(HWND hWndInsertAfter, int x, int y, int cx, int cy, UINT nFlags) <br>{ <br>_ASSERTE(::IsWindow(m_hWnd)); <br>return ::SetWindowPos(m_hWnd, hWndInsertAfter, x, y, cx, cy, nFlags); <br>} <br> <br>BOOL SetWindowPos(HWND hWndInsertAfter, LPCRECT lpRect, UINT nFlags) <br>{ <br>_ASSERTE(::IsWindow(m_hWnd)); <br>return ::SetWindowPos(m_hWnd, hWndInsertAfter, lpRect-&gt;left, lpRect-&gt;top, lpRect-&gt;right - lpRect-&gt;left, lpRect-&gt;bottom - lpRect-&gt;top, nFlags); <br>} <br> <br>UINT ArrangeIconicWindows() <br>{ <br>_ASSERTE(::IsWindow(m_hWnd)); <br>return ::ArrangeIconicWindows(m_hWnd); <br>} <br> <br>BOOL BringWindowToTop() <br>{ <br>_ASSERTE(::IsWindow(m_hWnd)); <br>return ::BringWindowToTop(m_hWnd); <br>} <br> <br>BOOL GetWindowRect(LPRECT lpRect) const <br>{ <br>_ASSERTE(::IsWindow(m_hWnd)); <br>return ::GetWindowRect(m_hWnd, lpRect); <br>} <br> <br>BOOL GetClientRect(LPRECT lpRect) const <br>{ <br>_ASSERTE(::IsWindow(m_hWnd)); <br>return ::GetClientRect(m_hWnd, lpRect); <br>} <br> <br>BOOL GetWindowPlacement(WINDOWPLACEMENT FAR* lpwndpl) const <br>{ <br>_ASSERTE(::IsWindow(m_hWnd)); <br>return ::GetWindowPlacement(m_hWnd, lpwndpl); <br>} <br> <br>BOOL SetWindowPlacement(const WINDOWPLACEMENT FAR* lpwndpl) <br>{ <br>_ASSERTE(::IsWindow(m_hWnd)); <br>return ::SetWindowPlacement(m_hWnd, lpwndpl); <br>} <br> <br>// Coordinate Mapping Functions <br> <br>BOOL ClientToScreen(LPPOINT lpPoint) const <br>{ <br>_ASSERTE(::IsWindow(m_hWnd)); <br>return ::ClientToScreen(m_hWnd, lpPoint); <br>} <br> <br>BOOL ClientToScreen(LPRECT lpRect) const <br>{ <br>_ASSERTE(::IsWindow(m_hWnd)); <br>if(!::ClientToScreen(m_hWnd, (LPPOINT)lpRect)) <br>return FALSE; <br>return ::ClientToScreen(m_hWnd, ((LPPOINT)lpRect)+1); <br>} <br> <br>BOOL ScreenToClient(LPPOINT lpPoint) const <br>{ <br>_ASSERTE(::IsWindow(m_hWnd)); <br>return ::ScreenToClient(m_hWnd, lpPoint); <br>} <br> <br>BOOL ScreenToClient(LPRECT lpRect) const <br>{ <br>_ASSERTE(::IsWindow(m_hWnd)); <br>if(!::ScreenToClient(m_hWnd, (LPPOINT)lpRect)) <br>return FALSE; <br>return ::ScreenToClient(m_hWnd, ((LPPOINT)lpRect)+1); <br>} <br> <br>int MapWindowPoints(HWND hWndTo, LPPOINT lpPoint, UINT nCount) const <br>{ <br>_ASSERTE(::IsWindow(m_hWnd)); <br>return ::MapWindowPoints(m_hWnd, hWndTo, lpPoint, nCount); <br>} <br> <br>int MapWindowPoints(HWND hWndTo, LPRECT lpRect) const <br>{ <br>_ASSERTE(::IsWindow(m_hWnd)); <br>return ::MapWindowPoints(m_hWnd, hWndTo, (LPPOINT)lpRect, 2); <br>} <br> <br>// Update and Painting Functions <br> <br>HDC BeginPaint(LPPAINTSTRUCT lpPaint) <br>{ <br>_ASSERTE(::IsWindow(m_hWnd)); <br>return ::BeginPaint(m_hWnd, lpPaint); <br>} <br> <br>void EndPaint(LPPAINTSTRUCT lpPaint) <br>{ <br>_ASSERTE(::IsWindow(m_hWnd)); <br>::EndPaint(m_hWnd, lpPaint); <br>} <br> <br>HDC GetDC() <br>{ <br>_ASSERTE(::IsWindow(m_hWnd)); <br>return ::GetDC(m_hWnd); <br>} <br> <br>HDC GetWindowDC() <br>{ <br>_ASSERTE(::IsWindow(m_hWnd)); <br>return ::GetWindowDC(m_hWnd); <br>} <br> <br>int ReleaseDC(HDC hDC) <br>{ <br>_ASSERTE(::IsWindow(m_hWnd)); <br>return ::ReleaseDC(m_hWnd, hDC); <br>} <br> <br>void Print(HDC hDC, DWORD dwFlags) const <br>{ <br>_ASSERTE(::IsWindow(m_hWnd)); <br>::SendMessage(m_hWnd, WM_PRINT, (WPARAM)hDC, dwFlags); <br>} <br> <br>void PrintClient(HDC hDC, DWORD dwFlags) const <br>{ <br>_ASSERTE(::IsWindow(m_hWnd)); <br>::SendMessage(m_hWnd, WM_PRINTCLIENT, (WPARAM)hDC, dwFlags); <br>} <br> <br>BOOL UpdateWindow() <br>{ <br>_ASSERTE(::IsWindow(m_hWnd)); <br>return ::UpdateWindow(m_hWnd); <br>} <br> <br>void SetRedraw(BOOL bRedraw = TRUE) <br>{ <br>_ASSERTE(::IsWindow(m_hWnd)); <br>::SendMessage(m_hWnd, WM_SETREDRAW, (WPARAM)bRedraw, 0); <br>} <br> <br>BOOL GetUpdateRect(LPRECT lpRect, BOOL bErase = FALSE) <br>{ <br>_ASSERTE(::IsWindow(m_hWnd)); <br>return ::GetUpdateRect(m_hWnd, lpRect, bErase); <br>} <br> <br>int GetUpdateRgn(HRGN hRgn, BOOL bErase = FALSE) <br>{ <br>_ASSERTE(::IsWindow(m_hWnd)); <br>return ::GetUpdateRgn(m_hWnd, hRgn, bErase); <br>} <br> <br>BOOL Invalidate(BOOL bErase = TRUE) <br>{ <br>_ASSERTE(::IsWindow(m_hWnd)); <br>return ::InvalidateRect(m_hWnd, NULL, bErase); <br>} <br> <br>BOOL InvalidateRect(LPCRECT lpRect, BOOL bErase = TRUE) <br>{ <br>_ASSERTE(::IsWindow(m_hWnd)); <br>return ::InvalidateRect(m_hWnd, lpRect, bErase); <br>} <br> <br>void InvalidateRgn(HRGN hRgn, BOOL bErase = TRUE) <br>{ <br>_ASSERTE(::IsWindow(m_hWnd)); <br>::InvalidateRgn(m_hWnd, hRgn, bErase); <br>} <br> <br>BOOL ValidateRect(LPCRECT lpRect) <br>{ <br>_ASSERTE(::IsWindow(m_hWnd)); <br>return ::ValidateRect(m_hWnd, lpRect); <br>} <br> <br>BOOL ValidateRgn(HRGN hRgn) <br>{ <br>_ASSERTE(::IsWindow(m_hWnd)); <br>return ::ValidateRgn(m_hWnd, hRgn); <br>} <br> <br>BOOL ShowWindow(int nCmdShow) <br>{ <br>_ASSERTE(::IsWindow(m_hWnd)); <br>return ::ShowWindow(m_hWnd, nCmdShow); <br>} <br> <br>BOOL IsWindowVisible() const <br>{ <br>_ASSERTE(::IsWindow(m_hWnd)); <br>return ::IsWindowVisible(m_hWnd); <br>} <br> <br>BOOL ShowOwnedPopups(BOOL bShow = TRUE) <br>{ <br>_ASSERTE(::IsWindow(m_hWnd)); <br>return ::ShowOwnedPopups(m_hWnd, bShow); <br>} <br> <br>HDC GetDCEx(HRGN hRgnClip, DWORD flags) <br>{ <br>_ASSERTE(::IsWindow(m_hWnd)); <br>return ::GetDCEx(m_hWnd, hRgnClip, flags); <br>} <br> <br>BOOL LockWindowUpdate(BOOL bLock = TRUE) <br>{ <br>_ASSERTE(::IsWindow(m_hWnd)); <br>return ::LockWindowUpdate(bLock ? m_hWnd : NULL); <br>} <br> <br>BOOL RedrawWindow(LPCRECT lpRectUpdate = NULL, HRGN hRgnUpdate = NULL, UINT flags = RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE) <br>{ <br>_ASSERTE(::IsWindow(m_hWnd)); <br>return ::RedrawWindow(m_hWnd, lpRectUpdate, hRgnUpdate, flags); <br>} <br> <br>// Timer Functions <br> <br>UINT SetTimer(UINT nIDEvent, UINT nElapse, void (CALLBACK* lpfnTimer)(HWND, UINT, UINT, DWORD)) <br>{ <br>_ASSERTE(::IsWindow(m_hWnd)); <br>return ::SetTimer(m_hWnd, nIDEvent, nElapse, (TIMERPROC)lpfnTimer); <br>} <br> <br>BOOL KillTimer(UINT nIDEvent) <br>{ <br>_ASSERTE(::IsWindow(m_hWnd)); <br>return ::KillTimer(m_hWnd, nIDEvent); <br>} <br> <br>// Window State Functions <br> <br>BOOL IsWindowEnabled() const <br>{ <br>_ASSERTE(::IsWindow(m_hWnd)); <br>return ::IsWindowEnabled(m_hWnd); <br>} <br> <br>BOOL EnableWindow(BOOL bEnable = TRUE) <br>{ <br>_ASSERTE(::IsWindow(m_hWnd)); <br>return ::EnableWindow(m_hWnd, bEnable); <br>} <br> <br>HWND SetActiveWindow() <br>{ <br>_ASSERTE(::IsWindow(m_hWnd)); <br>return ::SetActiveWindow(m_hWnd); <br>} <br> <br>HWND SetCapture() <br>{ <br>_ASSERTE(::IsWindow(m_hWnd)); <br>return ::SetCapture(m_hWnd); <br>} <br> <br>HWND SetFocus() <br>{ <br>_ASSERTE(::IsWindow(m_hWnd)); <br>return ::SetFocus(m_hWnd); <br>} <br> <br>// Dialog-Box Item Functions <br> <br>BOOL CheckDlgButton(int nIDButton, UINT nCheck) <br>{ <br>_ASSERTE(::IsWindow(m_hWnd)); <br>return ::CheckDlgButton(m_hWnd, nIDButton, nCheck); <br>} <br> <br>BOOL CheckRadioButton(int nIDFirstButton, int nIDLastButton, int nIDCheckButton) <br>{ <br>_ASSERTE(::IsWindow(m_hWnd)); <br>return ::CheckRadioButton(m_hWnd, nIDFirstButton, nIDLastButton, nIDCheckButton); <br>} <br> <br>int DlgDirList(LPTSTR lpPathSpec, int nIDListBox, int nIDStaticPath, UINT nFileType) <br>{ <br>_ASSERTE(::IsWindow(m_hWnd)); <br>return ::DlgDirList(m_hWnd, lpPathSpec, nIDListBox, nIDStaticPath, nFileType); <br>} <br> <br>int DlgDirListComboBox(LPTSTR lpPathSpec, int nIDComboBox, int nIDStaticPath, UINT nFileType) <br>{ <br>_ASSERTE(::IsWindow(m_hWnd)); <br>return ::DlgDirListComboBox(m_hWnd, lpPathSpec, nIDComboBox, nIDStaticPath, nFileType); <br>} <br> <br>BOOL DlgDirSelect(LPTSTR lpString, int nCount, int nIDListBox) <br>{ <br>_ASSERTE(::IsWindow(m_hWnd)); <br>return ::DlgDirSelectEx(m_hWnd, lpString, nCount, nIDListBox); <br>} <br> <br>BOOL DlgDirSelectComboBox(LPTSTR lpString, int nCount, int nIDComboBox) <br>{ <br>_ASSERTE(::IsWindow(m_hWnd)); <br>return ::DlgDirSelectComboBoxEx(m_hWnd, lpString, nCount, nIDComboBox); <br>} <br> <br>UINT GetDlgItemInt(int nID, BOOL* lpTrans = NULL, BOOL bSigned = TRUE) const <br>{ <br>_ASSERTE(::IsWindow(m_hWnd)); <br>return ::GetDlgItemInt(m_hWnd, nID, lpTrans, bSigned); <br>} <br> <br>UINT GetDlgItemText(int nID, LPTSTR lpStr, int nMaxCount) const <br>{ <br>_ASSERTE(::IsWindow(m_hWnd)); <br>return ::GetDlgItemText(m_hWnd, nID, lpStr, nMaxCount); <br>} <br> <br>BOOL GetDlgItemText(int nID, BSTR&amp; bstrText) const <br>{ <br>_ASSERTE(::IsWindow(m_hWnd)); <br> <br>HWND hWndCtl = GetDlgItem(nID); <br>if(hWndCtl == NULL) <br>return FALSE; <br> <br>return CWindow(hWndCtl).GetWindowText(bstrText); <br>} <br> <br>HWND GetNextDlgGroupItem(HWND hWndCtl, BOOL bPrevious = FALSE) const <br>{ <br>_ASSERTE(::IsWindow(m_hWnd)); <br>return ::GetNextDlgGroupItem(m_hWnd, hWndCtl, bPrevious); <br>} <br> <br>HWND GetNextDlgTabItem(HWND hWndCtl, BOOL bPrevious = FALSE) const <br>{ <br>_ASSERTE(::IsWindow(m_hWnd)); <br>return ::GetNextDlgTabItem(m_hWnd, hWndCtl, bPrevious); <br>} <br> <br>UINT IsDlgButtonChecked(int nIDButton) const <br>{ <br>_ASSERTE(::IsWindow(m_hWnd)); <br>return ::IsDlgButtonChecked(m_hWnd, nIDButton); <br>} <br> <br>LRESULT SendDlgItemMessage(int nID, UINT message, WPARAM wParam = 0, LPARAM lParam = 0) <br>{ <br>_ASSERTE(::IsWindow(m_hWnd)); <br>return ::SendDlgItemMessage(m_hWnd, nID, message, wParam, lParam); <br>} <br> <br>BOOL SetDlgItemInt(int nID, UINT nValue, BOOL bSigned = TRUE) <br>{ <br>_ASSERTE(::IsWindow(m_hWnd)); <br>return ::SetDlgItemInt(m_hWnd, nID, nValue, bSigned); <br>} <br> <br>BOOL SetDlgItemText(int nID, LPCTSTR lpszString) <br>{ <br>_ASSERTE(::IsWindow(m_hWnd)); <br>return ::SetDlgItemText(m_hWnd, nID, lpszString); <br>} <br> <br>// Scrolling Functions <br> <br>int GetScrollPos(int nBar) const <br>{ <br>_ASSERTE(::IsWindow(m_hWnd)); <br>return ::GetScrollPos(m_hWnd, nBar); <br>} <br> <br>BOOL GetScrollRange(int nBar, LPINT lpMinPos, LPINT lpMaxPos) const <br>{ <br>_ASSERTE(::IsWindow(m_hWnd)); <br>return ::GetScrollRange(m_hWnd, nBar, lpMinPos, lpMaxPos); <br>} <br> <br>BOOL ScrollWindow(int xAmount, int yAmount, LPCRECT lpRect = NULL, LPCRECT lpClipRect = NULL) <br>{ <br>_ASSERTE(::IsWindow(m_hWnd)); <br>return ::ScrollWindow(m_hWnd, xAmount, yAmount, lpRect, lpClipRect); <br>} <br> <br>int ScrollWindowEx(int dx, int dy, LPCRECT lpRectScroll, LPCRECT lpRectClip, HRGN hRgnUpdate, LPRECT lpRectUpdate, UINT flags) <br>{ <br>_ASSERTE(::IsWindow(m_hWnd)); <br>return ::ScrollWindowEx(m_hWnd, dx, dy, lpRectScroll, lpRectClip, hRgnUpdate, lpRectUpdate, flags); <br>} <br> <br>int SetScrollPos(int nBar, int nPos, BOOL bRedraw = TRUE) <br>{ <br>_ASSERTE(::IsWindow(m_hWnd)); <br>return ::SetScrollPos(m_hWnd, nBar, nPos, bRedraw); <br>} <br> <br>BOOL SetScrollRange(int nBar, int nMinPos, int nMaxPos, BOOL bRedraw = TRUE) <br>{ <br>_ASSERTE(::IsWindow(m_hWnd)); <br>return ::SetScrollRange(m_hWnd, nBar, nMinPos, nMaxPos, bRedraw); <br>} <br> <br>BOOL ShowScrollBar(UINT nBar, BOOL bShow = TRUE) <br>{ <br>_ASSERTE(::IsWindow(m_hWnd)); <br>return ::ShowScrollBar(m_hWnd, nBar, bShow); <br>} <br> <br>BOOL EnableScrollBar(UINT uSBFlags, UINT uArrowFlags = ESB_ENABLE_BOTH) <br>{ <br>_ASSERTE(::IsWindow(m_hWnd)); <br>return ::EnableScrollBar(m_hWnd, uSBFlags, uArrowFlags); <br>} <br> <br>// Window Access Functions <br> <br>HWND ChildWindowFromPoint(POINT point) const <br>{ <br>_ASSERTE(::IsWindow(m_hWnd)); <br>return ::ChildWindowFromPoint(m_hWnd, point); <br>} <br> <br>HWND ChildWindowFromPointEx(POINT point, UINT uFlags) const <br>{ <br>_ASSERTE(::IsWindow(m_hWnd)); <br>return ::ChildWindowFromPointEx(m_hWnd, point, uFlags); <br>} <br> <br>HWND GetTopWindow() const <br>{ <br>_ASSERTE(::IsWindow(m_hWnd)); <br>return ::GetTopWindow(m_hWnd); <br>} <br> <br>HWND GetWindow(UINT nCmd) const <br>{ <br>_ASSERTE(::IsWindow(m_hWnd)); <br>return ::GetWindow(m_hWnd, nCmd); <br>} <br> <br>HWND GetLastActivePopup() const <br>{ <br>_ASSERTE(::IsWindow(m_hWnd)); <br>return ::GetLastActivePopup(m_hWnd); <br>} <br> <br>BOOL IsChild(HWND hWnd) const <br>{ <br>_ASSERTE(::IsWindow(m_hWnd)); <br>return ::IsChild(m_hWnd, hWnd); <br>} <br> <br>HWND GetParent() const <br>{ <br>_ASSERTE(::IsWindow(m_hWnd)); <br>return ::GetParent(m_hWnd); <br>} <br> <br>HWND SetParent(HWND hWndNewParent) <br>{ <br>_ASSERTE(::IsWindow(m_hWnd)); <br>return ::SetParent(m_hWnd, hWndNewParent); <br>} <br> <br>// Window Tree Access <br> <br>int GetDlgCtrlID() const <br>{ <br>_ASSERTE(::IsWindow(m_hWnd)); <br>return ::GetDlgCtrlID(m_hWnd); <br>} <br> <br>int SetDlgCtrlID(int nID) <br>{ <br>_ASSERTE(::IsWindow(m_hWnd)); <br>return (int)::SetWindowLong(m_hWnd, GWL_ID, nID); <br>} <br> <br>HWND GetDlgItem(int nID) const <br>{ <br>_ASSERTE(::IsWindow(m_hWnd)); <br>return ::GetDlgItem(m_hWnd, nID); <br>} <br> <br>HWND GetDescendantWindow(int nID) const; <br> <br>void SendMessageToDescendants(UINT message, WPARAM wParam = 0, LPARAM lParam = 0, BOOL bDeep = TRUE); <br> <br>// Alert Functions <br> <br>BOOL FlashWindow(BOOL bInvert) <br>{ <br>_ASSERTE(::IsWindow(m_hWnd)); <br>return ::FlashWindow(m_hWnd, bInvert); <br>} <br> <br>int MessageBox(LPCTSTR lpszText, LPCTSTR lpszCaption = NULL, UINT nType = MB_OK) <br>{ <br>_ASSERTE(::IsWindow(m_hWnd)); <br>return ::MessageBox(m_hWnd, lpszText, lpszCaption, nType); <br>} <br> <br>// Clipboard Functions <br> <br>BOOL ChangeClipboardChain(HWND hWndNewNext) <br>{ <br>_ASSERTE(::IsWindow(m_hWnd)); <br>return ::ChangeClipboardChain(m_hWnd, hWndNewNext); <br>} <br> <br>HWND SetClipboardViewer() <br>{ <br>_ASSERTE(::IsWindow(m_hWnd)); <br>return ::SetClipboardViewer(m_hWnd); <br>} <br> <br>BOOL OpenClipboard() <br>{ <br>_ASSERTE(::IsWindow(m_hWnd)); <br>return ::OpenClipboard(m_hWnd); <br>} <br> <br>// Caret Functions <br> <br>BOOL CreateCaret(HBITMAP hBitmap) <br>{ <br>_ASSERTE(::IsWindow(m_hWnd)); <br>return ::CreateCaret(m_hWnd, hBitmap, 0, 0); <br>} <br> <br>BOOL CreateSolidCaret(int nWidth, int nHeight) <br>{ <br>_ASSERTE(::IsWindow(m_hWnd)); <br>return ::CreateCaret(m_hWnd, (HBITMAP)0, nWidth, nHeight); <br>} <br> <br>BOOL CreateGrayCaret(int nWidth, int nHeight) <br>{ <br>_ASSERTE(::IsWindow(m_hWnd)); <br>return ::CreateCaret(m_hWnd, (HBITMAP)1, nWidth, nHeight); <br>} <br> <br>BOOL HideCaret() <br>{ <br>_ASSERTE(::IsWindow(m_hWnd)); <br>return ::HideCaret(m_hWnd); <br>} <br> <br>BOOL ShowCaret() <br>{ <br>_ASSERTE(::IsWindow(m_hWnd)); <br>return ::ShowCaret(m_hWnd); <br>} <br> <br>// Drag-Drop Functions <br> <br>void DragAcceptFiles(BOOL bAccept = TRUE) <br>{ <br>_ASSERTE(::IsWindow(m_hWnd)); ::DragAcceptFiles(m_hWnd, bAccept); <br>} <br> <br>// Icon Functions <br> <br>HICON SetIcon(HICON hIcon, BOOL bBigIcon = TRUE) <br>{ <br>_ASSERTE(::IsWindow(m_hWnd)); <br>return (HICON)::SendMessage(m_hWnd, WM_SETICON, bBigIcon, (LPARAM)hIcon); <br>} <br> <br>HICON GetIcon(BOOL bBigIcon = TRUE) const <br>{ <br>_ASSERTE(::IsWindow(m_hWnd)); <br>return (HICON)::SendMessage(m_hWnd, WM_GETICON, bBigIcon, 0); <br>} <br> <br>// Help Functions <br> <br>BOOL WinHelp(LPCTSTR lpszHelp, UINT nCmd = HELP_CONTEXT, DWORD dwData = 0) <br>{ <br>_ASSERTE(::IsWindow(m_hWnd)); <br>return ::WinHelp(m_hWnd, lpszHelp, nCmd, dwData); <br>} <br> <br>BOOL SetWindowContextHelpId(DWORD dwContextHelpId) <br>{ <br>_ASSERTE(::IsWindow(m_hWnd)); <br>return ::SetWindowContextHelpId(m_hWnd, dwContextHelpId); <br>} <br> <br>DWORD GetWindowContextHelpId() const <br>{ <br>_ASSERTE(::IsWindow(m_hWnd)); <br>return ::GetWindowContextHelpId(m_hWnd); <br>} <br> <br>// Hot Key Functions <br> <br>int SetHotKey(WORD wVirtualKeyCode, WORD wModifiers) <br>{ <br>_ASSERTE(::IsWindow(m_hWnd)); <br>return (int)::SendMessage(m_hWnd, WM_SETHOTKEY, MAKEWORD(wVirtualKeyCode, wModifiers), 0); <br>} <br> <br>DWORD GetHotKey(WORD&amp; /* wVirtualKeyCode */, WORD&amp; /* wModifiers */) const <br>{ <br>_ASSERTE(::IsWindow(m_hWnd)); <br>return ::SendMessage(m_hWnd, WM_GETHOTKEY, 0, 0); <br>} <br> <br>// Misc. Operations <br> <br>BOOL CenterWindow(HWND hWndCenter = NULL); <br> <br>HWND GetTopLevelParent() const; <br>HWND GetTopLevelWindow() const; <br>}; <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// WindowProc thunks <br> <br>#if defined(_M_PPC) <br>#error PPC not yet implemented <br>#elif defined (_M_ALPHA) <br>// For ALPHA we will stick the this pointer into a0, which is where <br>// the HWND is.  However, we don't actually need the HWND so this is OK. <br>#pragma pack(push,4) <br>struct _WndProcThunk //this should come out to 20 bytes <br>{ <br>DWORD ldah_at;      //  ldah    at, HIWORD(func) <br>DWORD ldah_a0;      //  ldah    a0, HIWORD(this) <br>DWORD lda_at;       //  lda     at, LOWORD(func)(at) <br>DWORD lda_a0;       //  lda     a0, LOWORD(this)(a0) <br>DWORD jmp;          //  jmp     zero,(at),0 <br>}; <br>#pragma pack(pop) <br>#elif defined (_M_IX86) <br>#pragma pack(push,1) <br>struct _WndProcThunk <br>{ <br>BYTE    m_mov;          // mov ecx, pThis <br>DWORD   m_this;         // <br>BYTE    m_jmp;          // jmp WndProc <br>DWORD   m_relproc;      // relative jmp <br>}; <br>#pragma pack(pop) <br>#else <br>#error Only PPC, ALPHA, and X86 supported <br>#endif <br> <br>class CWndProcThunk <br>{ <br>public: <br>union <br>{ <br>_AtlCreateWndData cd; <br>_WndProcThunk thunk; <br>}; <br>void Init(WNDPROC proc, void* pThis); <br>}; <br> <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// CMessageMap - abstract class that provides an interface for message maps <br> <br>class ATL_NO_VTABLE CMessageMap <br>{ <br>public: <br>virtual BOOL ProcessWindowMessage(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam, <br>LRESULT&amp; lResult, DWORD dwMsgMapID) = 0; <br>}; <br> <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// Message map <br> <br>#define BEGIN_MSG_MAP(theClass) \ <br>public: \ <br>BOOL ProcessWindowMessage(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT&amp; lResult, DWORD dwMsgMapID = 0) \ <br>{ \ <br>BOOL bHandled = TRUE; \ <br>hWnd; \ <br>switch(dwMsgMapID) \ <br>{ \ <br>case 0: <br> <br>#define ALT_MSG_MAP(msgMapID) \ <br>break; \ <br>case msgMapID: <br> <br>#define MESSAGE_HANDLER(msg, func) \ <br>if(uMsg == msg) \ <br>{ \ <br>bHandled = TRUE; \ <br>lResult = func(uMsg, wParam, lParam, bHandled); \ <br>if(bHandled) \ <br>return TRUE; \ <br>} <br> <br>#define MESSAGE_RANGE_HANDLER(msgFirst, msgLast, func) \ <br>if(uMsg &gt;= msgFirst &amp;&amp; uMsg &lt;= msgLast) \ <br>{ \ <br>bHandled = TRUE; \ <br>lResult = func(uMsg, wParam, lParam, bHandled); \ <br>if(bHandled) \ <br>return TRUE; \ <br>} <br> <br>#define COMMAND_HANDLER(id, code, func) \ <br>if(uMsg == WM_COMMAND &amp;&amp; id == LOWORD(wParam) &amp;&amp; code == HIWORD(wParam)) \ <br>{ \ <br>bHandled = TRUE; \ <br>lResult = func(HIWORD(wParam), LOWORD(wParam), (HWND)lParam, bHandled); \ <br>if(bHandled) \ <br>return TRUE; \ <br>} <br> <br>#define COMMAND_ID_HANDLER(id, func) \ <br>if(uMsg == WM_COMMAND &amp;&amp; id == LOWORD(wParam)) \ <br>{ \ <br>bHandled = TRUE; \ <br>lResult = func(HIWORD(wParam), LOWORD(wParam), (HWND)lParam, bHandled); \ <br>if(bHandled) \ <br>return TRUE; \ <br>} <br> <br>#define COMMAND_CODE_HANDLER(code, func) \ <br>if(uMsg == WM_COMMAND &amp;&amp; code == HIWORD(wParam)) \ <br>{ \ <br>bHandled = TRUE; \ <br>lResult = func(HIWORD(wParam), LOWORD(wParam), (HWND)lParam, bHandled); \ <br>if(bHandled) \ <br>return TRUE; \ <br>} <br> <br>#define COMMAND_RANGE_HANDLER(idFirst, idLast, func) \ <br>if(uMsg == WM_COMMAND &amp;&amp; LOWORD(wParam) &gt;= idFirst  &amp;&amp; LOWORD(wParam) &lt;= idLast) \ <br>{ \ <br>bHandled = TRUE; \ <br>lResult = func(HIWORD(wParam), LOWORD(wParam), (HWND)lParam, bHandled); \ <br>if(bHandled) \ <br>return TRUE; \ <br>} <br> <br>#define NOTIFY_HANDLER(id, cd, func) \ <br>if(uMsg == WM_NOTIFY &amp;&amp; id == ((LPNMHDR)lParam)-&gt;idFrom &amp;&amp; cd == ((LPNMHDR)lParam)-&gt;code) \ <br>{ \ <br>bHandled = TRUE; \ <br>lResult = func((int)wParam, (LPNMHDR)lParam, bHandled); \ <br>if(bHandled) \ <br>return TRUE; \ <br>} <br> <br>#define NOTIFY_ID_HANDLER(id, func) \ <br>if(uMsg == WM_NOTIFY &amp;&amp; id == ((LPNMHDR)lParam)-&gt;idFrom) \ <br>{ \ <br>bHandled = TRUE; \ <br>lResult = func((int)wParam, (LPNMHDR)lParam, bHandled); \ <br>if(bHandled) \ <br>return TRUE; \ <br>} <br> <br>#define NOTIFY_CODE_HANDLER(cd, func) \ <br>if(uMsg == WM_NOTIFY &amp;&amp; cd == ((LPNMHDR)lParam)-&gt;code) \ <br>{ \ <br>bHandled = TRUE; \ <br>lResult = func((int)wParam, (LPNMHDR)lParam, bHandled); \ <br>if(bHandled) \ <br>return TRUE; \ <br>} <br> <br>#define NOTIFY_RANGE_HANDLER(idFirst, idLast, func) \ <br>if(uMsg == WM_NOTIFY &amp;&amp; ((LPNMHDR)lParam)-&gt;idFrom &gt;= idFirst &amp;&amp; ((LPNMHDR)lParam)-&gt;idFrom &lt;= idLast) \ <br>{ \ <br>bHandled = TRUE; \ <br>lResult = func((int)wParam, (LPNMHDR)lParam, bHandled); \ <br>if(bHandled) \ <br>return TRUE; \ <br>} <br> <br>#define CHAIN_MSG_MAP(theChainClass) \ <br>{ \ <br>if(theChainClass::ProcessWindowMessage(hWnd, uMsg, wParam, lParam, lResult)) \ <br>return TRUE; \ <br>} <br> <br>#define CHAIN_MSG_MAP_MEMBER(theChainMember) \ <br>{ \ <br>if(theChainMember.ProcessWindowMessage(hWnd, uMsg, wParam, lParam, lResult)) \ <br>return TRUE; \ <br>} <br> <br>#define CHAIN_MSG_MAP_ALT(theChainClass, msgMapID) \ <br>{ \ <br>if(theChainClass::ProcessWindowMessage(hWnd, uMsg, wParam, lParam, lResult, msgMapID)) \ <br>return TRUE; \ <br>} <br> <br>#define CHAIN_MSG_MAP_ALT_MEMBER(theChainMember, msgMapID) \ <br>{ \ <br>if(theChainMember.ProcessWindowMessage(hWnd, uMsg, wParam, lParam, lResult, msgMapID)) \ <br>return TRUE; \ <br>} <br> <br>#define CHAIN_MSG_MAP_DYNAMIC(dynaChainID) \ <br>{ \ <br>if(CDynamicChain::CallChain(dynaChainID, hWnd, uMsg, wParam, lParam, lResult)) \ <br>return TRUE; \ <br>} <br> <br>#define CHAIN_MSG_MAP_ALT_DYNAMIC(dynaChainID, msgMapID) \ <br>{ \ <br>if(CDynamicChain::CallChain(dynaChainID, hWnd, uMsg, wParam, lParam, lResult, msgMapID)) \ <br>return TRUE; \ <br>} <br> <br>#define END_MSG_MAP() \ <br>break; \ <br>default: \ <br>ATLTRACE(_T("Invalid message map ID (%i)\n"), dwMsgMapID); \ <br>_ASSERTE(FALSE); \ <br>break; \ <br>} \ <br>return FALSE; \ <br>} <br> <br> <br>// Handler prototypes: <br>//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL&amp; bHandled); <br>//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL&amp; bHandled); <br>//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL&amp; bHandled); <br> <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// CDynamicChain - provides support for dynamic chaining <br> <br>class CDynamicChain <br>{ <br>public: <br>struct ATL_CHAIN_ENTRY <br>{ <br>DWORD m_dwChainID; <br>CMessageMap* m_pObject; <br>DWORD m_dwMsgMapID; <br>}; <br> <br>int m_nEntries; <br>ATL_CHAIN_ENTRY** m_pChainEntry; <br> <br>CDynamicChain() : m_nEntries(0), m_pChainEntry(NULL) <br>{ } <br> <br>~CDynamicChain(); <br>BOOL SetChainEntry(DWORD dwChainID, CMessageMap* pObject, DWORD dwMsgMapID = 0); <br>BOOL RemoveChainEntry(DWORD dwChainID); <br>BOOL CallChain(DWORD dwChainID, HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT&amp; lResult); <br>}; <br> <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// CWndClassInfo - Manages Windows class information <br> <br>class CWndClassInfo <br>{ <br>public: <br>WNDCLASSEX m_wc; <br>LPCTSTR m_lpszOrigName; <br>WNDPROC pWndProc; <br>LPCTSTR m_lpszCursorID; <br>BOOL m_bSystemCursor; <br>ATOM m_atom; <br>TCHAR m_szAutoName[13]; <br>ATOM Register(WNDPROC*); <br>}; <br> <br>#define DECLARE_WND_CLASS(WndClassName) \ <br>static CWndClassInfo&amp; GetWndClassInfo() \ <br>{ \ <br>static CWndClassInfo wc = \ <br>{ \ <br>{ sizeof(WNDCLASSEX), CS_HREDRAW|CS_VREDRAW, StartWindowProc, \ <br>  0, 0, 0, 0, 0, (HBRUSH)(COLOR_WINDOW+1), 0, WndClassName, 0 }, \ <br>NULL, NULL, IDC_ARROW, TRUE, 0, _T("") \ <br>}; \ <br>return wc; \ <br>} <br> <br>#define DECLARE_WND_SUPERCLASS(WndClassName, OrigWndClassName) \ <br>static CWndClassInfo&amp; GetWndClassInfo() \ <br>{ \ <br>static CWndClassInfo wc = \ <br>{ \ <br>{ sizeof(WNDCLASSEX), NULL, StartWindowProc, \ <br>  0, 0, 0, 0, 0, NULL, 0, WndClassName, 0 }, \ <br>OrigWndClassName, NULL, NULL, TRUE, 0, _T("") \ <br>}; \ <br>return wc; \ <br>} <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// CWindowImpl - Implements a window <br> <br>class ATL_NO_VTABLE CWindowImplBase : public CWindow, public CMessageMap <br>{ <br>public: <br>CWndProcThunk m_thunk; <br>WNDPROC m_pfnSuperWindowProc; <br> <br>CWindowImplBase() : m_pfnSuperWindowProc(::DefWindowProc) <br>{} <br> <br>static LRESULT CALLBACK StartWindowProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam); <br>static LRESULT CALLBACK WindowProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam); <br>HWND Create(HWND hWndParent, RECT&amp; rcPos, LPCTSTR szWindowName, </code></pre>
<p>
</p>
<pre><code>DWORD dwStyle, DWORD dwExStyle, UINT nID, ATOM atom); <br>BOOL SubclassWindow(HWND hWnd); <br>HWND UnsubclassWindow(); <br> <br>LRESULT DefWindowProc(UINT uMsg, WPARAM wParam, LPARAM lParam) <br>{ <br>#ifdef STRICT <br>return ::CallWindowProc(m_pfnSuperWindowProc, m_hWnd, uMsg, wParam, lParam); <br>#else <br>return ::CallWindowProc((FARPROC)m_pfnSuperWindowProc, m_hWnd, uMsg, wParam, lParam); <br>#endif <br>} <br>}; <br> <br>template &lt;class T&gt; <br>class ATL_NO_VTABLE CWindowImpl : public CWindowImplBase <br>{ <br>public: <br>DECLARE_WND_CLASS(NULL) <br> <br>HWND Create(HWND hWndParent, RECT&amp; rcPos, LPCTSTR szWindowName = NULL, <br>DWORD dwStyle = WS_CHILD | WS_VISIBLE, DWORD dwExStyle = 0, <br>UINT nID = 0) <br>{ <br>ATOM atom = T::GetWndClassInfo().Register(&amp;m_pfnSuperWindowProc); <br>return CWindowImplBase::Create(hWndParent, rcPos, szWindowName, dwStyle, dwExStyle, <br>nID, atom); <br>} <br>}; <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// CDialog - Implements a dialog box <br> <br>class ATL_NO_VTABLE CDialogImplBase : public CWindow, public CMessageMap <br>{ <br>public: <br>CWndProcThunk m_thunk; <br> <br>static LRESULT CALLBACK StartDialogProc(HWND hWnd, UINT uMsg, <br>WPARAM wParam, LPARAM lParam); <br>static LRESULT CALLBACK DialogProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam); <br>BOOL EndDialog(int nRetCode); <br>}; <br> <br>template &lt;class T&gt; <br>class ATL_NO_VTABLE CDialogImpl : public CDialogImplBase <br>{ <br>public: <br>int DoModal(HWND hWndParent = ::GetActiveWindow()) <br>{ <br>_ASSERTE(m_hWnd == NULL); <br>_Module.AddCreateWndData(&amp;m_thunk.cd, (CDialogImplBase*)this); <br>int nRet = ::DialogBoxParam(_Module.GetResourceInstance(), <br>MAKEINTRESOURCE(T::IDD), <br>hWndParent, <br>(DLGPROC)T::StartDialogProc, <br>NULL); <br>m_hWnd = NULL; <br>return nRet; <br>} <br> <br>HWND Create(HWND hWndParent) <br>{ <br>_ASSERTE(m_hWnd == NULL); <br>_Module.AddCreateWndData(&amp;m_thunk.cd, (CDialogImplBase*)this); <br>HWND hWnd = ::CreateDialogParam(_Module.GetResourceInstance(), <br>MAKEINTRESOURCE(T::IDD), <br>hWndParent, <br>(DLGPROC)T::StartDialogProc, <br>NULL); <br>_ASSERTE(m_hWnd == hWnd); <br>return hWnd; <br>} <br>}; <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// CContainedWindow - Implements a contained window <br> <br>class CContainedWindow : public CWindow <br>{ <br>public: <br>CWndProcThunk m_thunk; <br>LPTSTR m_lpszClassName; <br>WNDPROC m_pfnSuperWindowProc; <br>CMessageMap* m_pObject; <br>DWORD m_dwMsgMapID; <br> <br>CContainedWindow(LPTSTR lpszClassName, CMessageMap* pObject, DWORD dwMsgMapID = 0) <br>: m_lpszClassName(lpszClassName), <br>m_pfnSuperWindowProc(::DefWindowProc), <br>m_pObject(pObject), m_dwMsgMapID(dwMsgMapID) <br>{ } <br> <br>void SwitchMessageMap(DWORD dwMsgMapID) <br>{ <br>m_dwMsgMapID = dwMsgMapID; <br>} <br> <br>static LRESULT CALLBACK StartWindowProc(HWND hWnd, UINT uMsg, <br>WPARAM wParam, LPARAM lParam); <br>static LRESULT CALLBACK WindowProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam); <br>ATOM RegisterWndSuperclass(); <br>HWND Create(HWND hWndParent, RECT&amp; rcPos, LPCTSTR szWindowName = NULL, <br>DWORD dwStyle = WS_CHILD | WS_VISIBLE, DWORD dwExStyle = 0, <br>UINT nID = 0); <br>BOOL SubclassWindow(HWND hWnd); <br>HWND UnsubclassWindow(); <br> <br>LRESULT DefWindowProc(UINT uMsg, WPARAM wParam, LPARAM lParam) <br>{ <br>#ifdef STRICT <br>return ::CallWindowProc(m_pfnSuperWindowProc, m_hWnd, uMsg, wParam, lParam); <br>#else <br>return ::CallWindowProc((FARPROC)m_pfnSuperWindowProc, m_hWnd, uMsg, wParam, lParam); <br>#endif <br>} <br>}; <br> <br> <br>#ifndef ATL_NO_NAMESPACE <br>}; //namespace ATL <br>#endif <br> <br>#endif // __ATLWIN_H__ </code></pre>
<p>&nbsp;</p></body>
</HTML>
