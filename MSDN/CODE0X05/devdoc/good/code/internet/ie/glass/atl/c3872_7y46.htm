<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>ATLCTL.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3876"></a>ATLCTL.CPP</h2>
<pre><code>// This is a part of the Active Template Library. <br>// Copyright (C) 1996-1997 Microsoft Corporation <br>// All rights reserved. <br>// <br>// This source code is only intended as a supplement to the <br>// Active Template Library Reference and related <br>// electronic documentation provided with the library. <br>// See these sources for detailed information regarding the <br>// Active Template Library product. <br> <br>#ifndef ATL_NO_NAMESPACE <br>namespace ATL <br>{ <br>#endif <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// CComDispatchDriver support <br> <br>HRESULT CComDispatchDriver::GetProperty(IDispatch* pDisp, DISPID dwDispID, <br>VARIANT* pVar) <br>{ <br>ATLTRACE(_T("CPropertyHelper::GetProperty\n")); <br>DISPPARAMS dispparamsNoArgs = {NULL, NULL, 0, 0}; <br>return pDisp-&gt;Invoke(dwDispID, IID_NULL, <br>LOCALE_USER_DEFAULT, DISPATCH_PROPERTYGET, <br>&amp;dispparamsNoArgs, pVar, NULL, NULL); <br>} <br> <br>HRESULT CComDispatchDriver::PutProperty(IDispatch* pDisp, DISPID dwDispID, <br>VARIANT* pVar) <br>{ <br>ATLTRACE(_T("CPropertyHelper::PutProperty\n")); <br>DISPPARAMS dispparams = {NULL, NULL, 1, 1}; <br>dispparams.rgvarg = pVar; <br>DISPID dispidPut = DISPID_PROPERTYPUT; <br>dispparams.rgdispidNamedArgs = &amp;dispidPut; <br> <br>if (pVar-&gt;vt == VT_UNKNOWN || pVar-&gt;vt == VT_DISPATCH ||  <br>(pVar-&gt;vt &amp; VT_ARRAY) || (pVar-&gt;vt &amp; VT_BYREF)) <br>{ <br>HRESULT hr = pDisp-&gt;Invoke(dwDispID, IID_NULL, <br>LOCALE_USER_DEFAULT, DISPATCH_PROPERTYPUTREF, <br>&amp;dispparams, NULL, NULL, NULL); <br>if (SUCCEEDED(hr)) <br>return hr; <br>} <br> <br>return pDisp-&gt;Invoke(dwDispID, IID_NULL, <br>LOCALE_USER_DEFAULT, DISPATCH_PROPERTYPUT, <br>&amp;dispparams, NULL, NULL, NULL); <br>} <br> <br>////////////////////////////////////////////////////////////////////////////// <br>// CFirePropNotifyEvent <br> <br>HRESULT CFirePropNotifyEvent::FireOnRequestEdit(IUnknown* pUnk, DISPID dispID) <br>{ <br>CComQIPtr&lt;IConnectionPointContainer, &amp;IID_IConnectionPointContainer&gt; pCPC(pUnk); <br>if (!pCPC) <br>return S_OK; <br>CComPtr&lt;IConnectionPoint&gt; pCP; <br>pCPC-&gt;FindConnectionPoint(IID_IPropertyNotifySink, &amp;pCP); <br>if (!pCP) <br>return S_OK; <br>CComPtr&lt;IEnumConnections&gt; pEnum; <br> <br>if (FAILED(pCP-&gt;EnumConnections(&amp;pEnum))) <br>return S_OK; <br>CONNECTDATA cd; <br>while (pEnum-&gt;Next(1, &amp;cd, NULL) == S_OK) <br>{ <br>if (cd.pUnk) <br>{ <br>HRESULT hr = S_OK; <br>CComQIPtr&lt;IPropertyNotifySink, &amp;IID_IPropertyNotifySink&gt; pSink(cd.pUnk); <br>if (pSink) <br>hr = pSink-&gt;OnRequestEdit(dispID); <br>cd.pUnk-&gt;Release(); <br>if (hr == S_FALSE) <br>return S_FALSE; <br>} <br>} <br>return S_OK; <br>} <br> <br>HRESULT CFirePropNotifyEvent::FireOnChanged(IUnknown* pUnk, DISPID dispID) <br>{ <br>CComQIPtr&lt;IConnectionPointContainer, &amp;IID_IConnectionPointContainer&gt; pCPC(pUnk); <br>if (!pCPC) <br>return S_OK; <br>CComPtr&lt;IConnectionPoint&gt; pCP; <br>pCPC-&gt;FindConnectionPoint(IID_IPropertyNotifySink, &amp;pCP); <br>if (!pCP) <br>return S_OK; <br>CComPtr&lt;IEnumConnections&gt; pEnum; <br> <br>if (FAILED(pCP-&gt;EnumConnections(&amp;pEnum))) <br>return S_OK; <br>CONNECTDATA cd; <br>while (pEnum-&gt;Next(1, &amp;cd, NULL) == S_OK) <br>{ <br>if (cd.pUnk) <br>{ <br>CComQIPtr&lt;IPropertyNotifySink, &amp;IID_IPropertyNotifySink&gt; pSink(cd.pUnk); <br>if (pSink) <br>pSink-&gt;OnChanged(dispID); <br>cd.pUnk-&gt;Release(); <br>} <br>} <br>return S_OK; <br>} <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// Control support <br> <br>HRESULT CComControlBase::IQuickActivate_QuickActivate(QACONTAINER *pQACont, <br>QACONTROL *pQACtrl) <br>{ <br>_ASSERTE(pQACont != NULL); <br>_ASSERTE(pQACtrl != NULL); <br>_ASSERTE(pQACont-&gt;cbSize &gt;= sizeof(QACONTAINER)); <br>_ASSERTE(pQACtrl-&gt;cbSize &gt;= sizeof(QACONTROL)); <br> <br>if (!pQACont || !pQACtrl) <br>return E_POINTER; <br> <br>HRESULT hRes; <br>memset(pQACtrl, 0, sizeof(QACONTROL)); <br>pQACtrl-&gt;cbSize = sizeof(QACONTROL); <br> <br>// get all interfaces we are going to need <br>CComPtr&lt;IOleObject&gt; pOO; <br>ControlQueryInterface(IID_IOleObject, (void**)&amp;pOO); <br>CComPtr&lt;IViewObjectEx&gt; pVOEX; <br>ControlQueryInterface(IID_IViewObjectEx, (void**)&amp;pVOEX); <br>CComPtr&lt;IPointerInactive&gt; pPI; <br>ControlQueryInterface(IID_IPointerInactive, (void**)&amp;pPI); <br>CComPtr&lt;IProvideClassInfo2&gt; pPCI; <br>ControlQueryInterface(IID_IProvideClassInfo2, (void**)&amp;pPCI); <br> <br>if (pOO == NULL || pVOEX == NULL) <br>return E_FAIL; <br> <br>pOO-&gt;SetClientSite(pQACont-&gt;pClientSite); <br> <br>if (pQACont-&gt;pAdviseSink != NULL) <br>{ <br>ATLTRACE(_T("Setting up IOleObject Advise\n")); <br>pVOEX-&gt;SetAdvise(DVASPECT_CONTENT, 0, pQACont-&gt;pAdviseSink); <br>} <br> <br>CComPtr&lt;IConnectionPointContainer&gt; pCPC; <br>ControlQueryInterface(IID_IConnectionPointContainer, (void**)&amp;pCPC); <br> <br>if (pQACont-&gt;pPropertyNotifySink) <br>{ <br>ATLTRACE(_T("Setting up PropNotify CP\n")); <br>CComPtr&lt;IConnectionPoint&gt; pCP; <br>if (pCPC != NULL) <br>{ <br>hRes = pCPC-&gt;FindConnectionPoint(IID_IPropertyNotifySink, &amp;pCP); <br>if (SUCCEEDED(hRes)) <br>pCP-&gt;Advise(pQACont-&gt;pPropertyNotifySink, &amp;pQACtrl-&gt;dwPropNotifyCookie); <br>} <br>} <br> <br>if (pPCI) <br>{ <br>GUID iidDefaultSrc; <br>if (SUCCEEDED(pPCI-&gt;GetGUID(GUIDKIND_DEFAULT_SOURCE_DISP_IID, <br>&amp;iidDefaultSrc))) <br>{ <br>if (pQACont-&gt;pUnkEventSink) <br>{ <br>ATLTRACE(_T("Setting up Default Out Going Interface\n")); <br>CComPtr&lt;IConnectionPoint&gt; pCP; <br>if (pCPC != NULL) <br>{ <br>hRes = pCPC-&gt;FindConnectionPoint(iidDefaultSrc, &amp;pCP); <br>if (SUCCEEDED(hRes)) <br>pCP-&gt;Advise(pQACont-&gt;pUnkEventSink, &amp;pQACtrl-&gt;dwEventCookie); <br>} <br>} <br>} <br>} <br>// give information to container <br>if (pOO != NULL) <br>pOO-&gt;GetMiscStatus(DVASPECT_CONTENT, &amp;pQACtrl-&gt;dwMiscStatus); <br> <br>if (pVOEX != NULL) <br>pVOEX-&gt;GetViewStatus(&amp;pQACtrl-&gt;dwViewStatus); <br> <br>if (pPI != NULL) <br>pPI-&gt;GetActivationPolicy(&amp;pQACtrl-&gt;dwPointerActivationPolicy); <br>return S_OK; <br>} <br> <br>HRESULT CComControlBase::IPersistPropertyBag_Load(LPPROPERTYBAG pPropBag, <br>LPERRORLOG pErrorLog, ATL_PROPMAP_ENTRY* pMap) <br>{ <br>USES_CONVERSION; <br>CComPtr&lt;IDispatch&gt; pDispatch; <br>const IID* piidOld = NULL; <br>for(int i = 0; pMap[i].pclsidPropPage != NULL; i++) <br>{ <br>if (pMap[i].szDesc == NULL) <br>continue; <br>CComVariant var; <br> <br>if(pMap[i].piidDispatch != piidOld) <br>{ <br>pDispatch.Release(); <br>if(FAILED(ControlQueryInterface(*pMap[i].piidDispatch, (void**)&amp;pDispatch))) <br>{ <br>ATLTRACE(_T("Failed to get a dispatch pointer for property #%i\n"), i); <br>return E_FAIL; <br>} <br>piidOld = pMap[i].piidDispatch; <br>} <br> <br>if (FAILED(CComDispatchDriver::GetProperty(pDispatch, pMap[i].dispid, &amp;var))) <br>{ <br>ATLTRACE(_T("Invoked failed on DISPID %x\n"), pMap[i].dispid); <br>return E_FAIL; <br>} <br> <br>HRESULT hr = pPropBag-&gt;Read(pMap[i].szDesc, &amp;var, pErrorLog); <br>if (FAILED(hr)) <br>{ <br>if (hr == E_INVALIDARG) <br>{ <br>ATLTRACE(_T("Property %s not in Bag\n"), OLE2CT(pMap[i].szDesc)); <br>} <br>else <br>{ <br>// Many containers return different ERROR values for Member not found <br>ATLTRACE(_T("Error attempting to read Property %s from PropertyBag \n"), OLE2CT(pMap[i].szDesc)); <br>} <br>continue; <br>} <br> <br>if (FAILED(CComDispatchDriver::PutProperty(pDispatch, pMap[i].dispid, &amp;var))) <br>{ <br>ATLTRACE(_T("Invoked failed on DISPID %x\n"), pMap[i].dispid); <br>return E_FAIL; <br>} <br>} <br>return S_OK; <br> <br>} <br> <br>HRESULT CComControlBase::IPersistPropertyBag_Save(LPPROPERTYBAG pPropBag, <br>BOOL fClearDirty, BOOL /*fSaveAllProperties*/, ATL_PROPMAP_ENTRY* pMap) <br>{ <br>if (pPropBag == NULL) <br>{ <br>ATLTRACE(_T("PropBag pointer passed in was invalid\n")); <br>return E_POINTER; <br>} <br> <br>CComPtr&lt;IDispatch&gt; pDispatch; <br>const IID* piidOld = NULL; <br>for(int i = 0; pMap[i].pclsidPropPage != NULL; i++) <br>{ <br>if (pMap[i].szDesc == NULL) <br>continue; <br>CComVariant var; <br> <br>if(pMap[i].piidDispatch != piidOld) <br>{ <br>pDispatch.Release(); <br>if(FAILED(ControlQueryInterface(*pMap[i].piidDispatch, (void**)&amp;pDispatch))) <br>{ <br>ATLTRACE(_T("Failed to get a dispatch pointer for property #%i\n"), i); <br>return E_FAIL; <br>} <br>piidOld = pMap[i].piidDispatch; <br>} <br> <br>if (FAILED(CComDispatchDriver::GetProperty(pDispatch, pMap[i].dispid, &amp;var))) <br>{ <br>ATLTRACE(_T("Invoked failed on DISPID %x\n"), pMap[i].dispid); <br>return E_FAIL; <br>} <br> <br>if (var.vt == VT_UNKNOWN || var.vt == VT_DISPATCH) <br>{ <br>if (var.punkVal == NULL) <br>{ <br>ATLTRACE(_T("Warning skipping empty IUnknown in Save\n")); <br>continue; <br>} <br>} <br> <br>HRESULT hr = pPropBag-&gt;Write(pMap[i].szDesc, &amp;var); <br>if (FAILED(hr)) <br>return hr; <br>} <br>m_bRequiresSave = FALSE; <br>return S_OK; <br>} <br> <br>HRESULT CComControlBase::ISpecifyPropertyPages_GetPages(CAUUID* pPages, <br>ATL_PROPMAP_ENTRY* pMap) <br>{ <br>_ASSERTE(pMap != NULL); <br>int nCnt = 0; <br>// Get count of unique pages <br>for(int i = 0; pMap[i].pclsidPropPage != NULL; i++) <br>{ <br>if (!InlineIsEqualGUID(*pMap[i].pclsidPropPage, CLSID_NULL)) <br>nCnt++; <br>} <br>pPages-&gt;pElems = NULL; <br>pPages-&gt;pElems = (GUID*) CoTaskMemAlloc(sizeof(CLSID)*nCnt); <br>if (pPages-&gt;pElems == NULL) <br>return E_OUTOFMEMORY; <br>nCnt = 0; <br>for(i = 0; pMap[i].pclsidPropPage != NULL; i++) <br>{ <br>if (!InlineIsEqualGUID(*pMap[i].pclsidPropPage, CLSID_NULL)) <br>{ <br>BOOL bMatch = FALSE; <br>for (int j=0;j&lt;nCnt;j++) <br>{ <br>if (InlineIsEqualGUID(*(pMap[i].pclsidPropPage), pPages-&gt;pElems[j])) <br>{ <br>bMatch = TRUE; <br>break; <br>} <br>} <br>if (!bMatch) <br>pPages-&gt;pElems[nCnt++] = *pMap[i].pclsidPropPage; <br>} <br>} <br>pPages-&gt;cElems = nCnt; <br>return S_OK; <br>} <br> <br>BOOL CComControlBase::SetControlFocus(BOOL bGrab) <br>{ <br>if (m_bWndLess) <br>{ <br>if (!m_bUIActive &amp;&amp; bGrab) <br>if (FAILED(InPlaceActivate(OLEIVERB_UIACTIVATE))) <br>return FALSE; <br> <br>return (m_spInPlaceSite-&gt;SetFocus(bGrab) == S_OK); <br>} <br>else <br>{ <br>// we've got a window. <br>// <br>if (m_bInPlaceActive) <br>{ <br>HWND hwnd = (bGrab) ? m_hWndCD : ::GetParent(m_hWndCD); <br>if (!m_bUIActive &amp;&amp; bGrab) <br>return SUCCEEDED(InPlaceActivate(OLEIVERB_UIACTIVATE)); <br>else <br>return (::SetFocus(hwnd) != NULL); <br>} <br>} <br>return FALSE; <br>} <br> <br>HRESULT CComControlBase::DoVerbProperties(LPCRECT /* prcPosRect */, HWND hwndParent) <br>{ <br>HRESULT hr = S_OK; <br>CComQIPtr &lt;ISpecifyPropertyPages, &amp;IID_ISpecifyPropertyPages&gt; spPages; <br>CComQIPtr &lt;IOleObject, &amp;IID_IOleObject&gt; spObj; <br>CComQIPtr &lt;IOleControlSite, &amp;IID_IOleControlSite&gt; spSite(m_spClientSite); <br> <br>if (spSite) <br>{ <br>hr = spSite-&gt;ShowPropertyFrame(); <br>if (SUCCEEDED(hr)) <br>return hr; <br>} <br> <br>CComPtr&lt;IUnknown&gt; pUnk; <br>ControlQueryInterface(IID_IUnknown, (void**)&amp;pUnk); <br>_ASSERTE(pUnk != NULL); <br>CAUUID pages; <br>spPages = pUnk; <br>if (spPages) <br>{ <br>spPages-&gt;GetPages(&amp;pages); <br>spObj = pUnk; <br>if (spObj) <br>{ <br>LPOLESTR szTitle = NULL; <br> <br>spObj-&gt;GetUserType(USERCLASSTYPE_SHORT, &amp;szTitle); <br> <br>hr = OleCreatePropertyFrame(hwndParent, m_rcPos.top, m_rcPos.left, szTitle, <br>1, &amp;pUnk.p, pages.cElems, pages.pElems, LOCALE_USER_DEFAULT, 0, 0); <br> <br>CoTaskMemFree(szTitle); <br>} <br>else <br>{ <br>hr = OLEOBJ_S_CANNOT_DOVERB_NOW; <br>} <br>} <br>else <br>{ <br>hr = OLEOBJ_S_CANNOT_DOVERB_NOW; <br>} <br> <br>return hr; <br>} <br> <br>HRESULT CComControlBase::InPlaceActivate(LONG iVerb, const RECT* prcPosRect) <br>{ <br>HRESULT hr; <br> <br>if (m_spClientSite == NULL) <br>return S_OK; <br> <br>CComPtr&lt;IOleInPlaceObject&gt; pIPO; <br>ControlQueryInterface(IID_IOleInPlaceObject, (void**)&amp;pIPO); <br>_ASSERTE(pIPO != NULL); <br>if (prcPosRect != NULL) <br>pIPO-&gt;SetObjectRects(prcPosRect, prcPosRect); <br> <br>if (!m_bNegotiatedWnd) <br>{ <br>if (!m_bWindowOnly) <br>// Try for windowless site <br>hr = m_spClientSite-&gt;QueryInterface(IID_IOleInPlaceSiteWindowless, (void **)&amp;m_spInPlaceSite); <br> <br>if (m_spInPlaceSite) <br>{ <br>m_bInPlaceSiteEx = TRUE; <br>m_bWndLess = SUCCEEDED(m_spInPlaceSite-&gt;CanWindowlessActivate()); <br>m_bWasOnceWindowless = TRUE; <br>} <br>else <br>{ <br>m_spClientSite-&gt;QueryInterface(IID_IOleInPlaceSiteEx, (void **)&amp;m_spInPlaceSite); <br>if (m_spInPlaceSite) <br>m_bInPlaceSiteEx = TRUE; <br>else <br>hr = m_spClientSite-&gt;QueryInterface(IID_IOleInPlaceSite, (void **)&amp;m_spInPlaceSite); <br>} <br>} <br> <br>_ASSERTE(m_spInPlaceSite); <br>if (!m_spInPlaceSite) <br>return E_FAIL; <br> <br>m_bNegotiatedWnd = TRUE; <br> <br>if (!m_bInPlaceActive) <br>{ <br> <br>BOOL bNoRedraw = FALSE; <br>if (m_bWndLess) <br>m_spInPlaceSite-&gt;OnInPlaceActivateEx(&amp;bNoRedraw, ACTIVATE_WINDOWLESS); <br>else <br>{ <br>if (m_bInPlaceSiteEx) <br>m_spInPlaceSite-&gt;OnInPlaceActivateEx(&amp;bNoRedraw, 0); <br>else <br>{ <br>HRESULT hr = m_spInPlaceSite-&gt;CanInPlaceActivate(); <br>if (FAILED(hr)) <br>return hr; <br>m_spInPlaceSite-&gt;OnInPlaceActivate(); <br>} <br>} <br>} <br> <br>m_bInPlaceActive = TRUE; <br> <br>// get location in the parent window, <br>// as well as some information about the parent <br>// <br>OLEINPLACEFRAMEINFO frameInfo; <br>RECT rcPos, rcClip; <br>CComPtr&lt;IOleInPlaceFrame&gt; spInPlaceFrame; <br>CComPtr&lt;IOleInPlaceUIWindow&gt; spInPlaceUIWindow; <br>frameInfo.cb = sizeof(OLEINPLACEFRAMEINFO); <br>HWND hwndParent; <br>if (m_spInPlaceSite-&gt;GetWindow(&amp;hwndParent) == S_OK) <br>{ <br>m_spInPlaceSite-&gt;GetWindowContext(&amp;spInPlaceFrame, <br>&amp;spInPlaceUIWindow, &amp;rcPos, &amp;rcClip, &amp;frameInfo); <br> <br>if (!m_bWndLess) <br>{ <br>if (m_hWndCD) <br>{ <br>ShowWindow(m_hWndCD, SW_SHOW); <br>SetFocus(m_hWndCD); <br>} <br>else <br>{ <br>HWND h = CreateControlWindow(hwndParent, rcPos); <br>_ASSERTE(h == m_hWndCD); <br>} <br>} <br> <br>pIPO-&gt;SetObjectRects(&amp;rcPos, &amp;rcClip); <br>} <br> <br>CComPtr&lt;IOleInPlaceActiveObject&gt; spActiveObject; <br>ControlQueryInterface(IID_IOleInPlaceActiveObject, (void**)&amp;spActiveObject); <br> <br>// Gone active by now, take care of UIACTIVATE <br>if (DoesVerbUIActivate(iVerb)) <br>{ <br>if (!m_bUIActive) <br>{ <br>m_bUIActive = TRUE; <br>hr = m_spInPlaceSite-&gt;OnUIActivate(); <br>if (FAILED(hr)) <br>return hr; <br> <br>SetControlFocus(TRUE); <br>// set ourselves up in the host. <br>// <br>if (spActiveObject) <br>{ <br>if (spInPlaceFrame) <br>spInPlaceFrame-&gt;SetActiveObject(spActiveObject, NULL); <br>if (spInPlaceUIWindow) <br>spInPlaceUIWindow-&gt;SetActiveObject(spActiveObject, NULL); <br>} <br> <br>if (spInPlaceFrame) <br>spInPlaceFrame-&gt;SetBorderSpace(NULL); <br>if (spInPlaceUIWindow) <br>spInPlaceUIWindow-&gt;SetBorderSpace(NULL); <br>} <br>} <br> <br>m_spClientSite-&gt;ShowObject(); <br> <br>return S_OK; <br>} <br> <br>HRESULT CComControlBase::IPersistStreamInit_Load(LPSTREAM pStm, ATL_PROPMAP_ENTRY* pMap) <br>{ <br>_ASSERTE(pMap != NULL); <br>HRESULT hr = S_OK; <br>DWORD dwVer; <br>hr = pStm-&gt;Read(&amp;dwVer, sizeof(DWORD), NULL); <br>if (SUCCEEDED(hr) &amp;&amp; dwVer &lt;= _ATL_VER) <br>hr = pStm-&gt;Read(&amp;m_sizeExtent, sizeof(m_sizeExtent), NULL); <br>if (FAILED(hr)) <br>return hr; <br> <br>CComPtr&lt;IDispatch&gt; pDispatch; <br>const IID* piidOld = NULL; <br>for(int i = 0; pMap[i].pclsidPropPage != NULL; i++) <br>{ <br>if (pMap[i].szDesc == NULL) <br>continue; <br>CComVariant var; <br> <br>HRESULT hr = var.ReadFromStream(pStm); <br>if (FAILED(hr)) <br>break; <br> <br>if(pMap[i].piidDispatch != piidOld) <br>{ <br>if(FAILED(ControlQueryInterface(*pMap[i].piidDispatch, (void**)&amp;pDispatch))) <br>{ <br>ATLTRACE(_T("Failed to get a dispatch pointer for property #%i\n"), i); <br>hr = E_FAIL; <br>break; <br>} <br>piidOld = pMap[i].piidDispatch; <br>} <br> <br>if (FAILED(CComDispatchDriver::PutProperty(pDispatch, pMap[i].dispid, &amp;var))) <br>{ <br>ATLTRACE(_T("Invoked failed on DISPID %x\n"), pMap[i].dispid); <br>hr = E_FAIL; <br>break; <br>} <br>} <br>return hr; <br>} <br> <br>HRESULT CComControlBase::IPersistStreamInit_Save(LPSTREAM pStm, BOOL /* fClearDirty */, ATL_PROPMAP_ENTRY* pMap) <br>{ <br>_ASSERTE(pMap != NULL); <br>DWORD dw = _ATL_VER; <br>HRESULT hr = pStm-&gt;Write(&amp;dw, sizeof(DWORD), NULL); <br>if (FAILED(hr)) <br>return hr; <br>hr = pStm-&gt;Write(&amp;m_sizeExtent, sizeof(m_sizeExtent), NULL); <br>if (FAILED(hr)) <br>return hr; <br> <br>CComPtr&lt;IDispatch&gt; pDispatch; <br>const IID* piidOld = NULL; <br>for(int i = 0; pMap[i].pclsidPropPage != NULL; i++) <br>{ <br>if (pMap[i].szDesc == NULL) <br>continue; <br>CComVariant var; <br> <br>if(pMap[i].piidDispatch != piidOld) <br>{ <br>if(FAILED(ControlQueryInterface(*pMap[i].piidDispatch, (void**)&amp;pDispatch))) <br>{ <br>ATLTRACE(_T("Failed to get a dispatch pointer for property #%i\n"), i); <br>hr = E_FAIL; <br>break; <br>} <br>piidOld = pMap[i].piidDispatch; <br>} <br> <br>if (FAILED(CComDispatchDriver::GetProperty(pDispatch, pMap[i].dispid, &amp;var))) <br>{ <br>ATLTRACE(_T("Invoked failed on DISPID %x\n"), pMap[i].dispid); <br>hr = E_FAIL; <br>break; <br>} <br> <br>HRESULT hr = var.WriteToStream(pStm); <br>if (FAILED(hr)) <br>break; <br>} <br>if (SUCCEEDED(hr)) <br>m_bRequiresSave = FALSE; <br> <br>return hr; <br>} <br> <br>HRESULT CComControlBase::SendOnDataChange(DWORD advf) <br>{ <br>HRESULT hRes = S_OK; <br>if (m_spDataAdviseHolder) <br>{ <br>CComPtr&lt;IDataObject&gt; pdo; <br>if (SUCCEEDED(ControlQueryInterface(IID_IDataObject, (void**)&amp;pdo))) <br>hRes = m_spDataAdviseHolder-&gt;SendOnDataChange(pdo, 0, advf); <br>} <br>return hRes; <br>} <br> <br>HRESULT CComControlBase::IOleObject_SetClientSite(IOleClientSite *pClientSite) <br>{ <br>_ASSERTE(pClientSite == NULL || m_spClientSite == NULL); <br>m_spClientSite = pClientSite; <br>m_spAmbientDispatch.Release(); <br>if (m_spClientSite != NULL) <br>{ <br>m_spClientSite-&gt;QueryInterface(IID_IDispatch, <br>(void**) &amp;m_spAmbientDispatch.p); <br>} <br>return S_OK; <br>} <br> <br>HRESULT CComControlBase::IOleObject_GetClientSite(IOleClientSite **ppClientSite) <br>{ <br>_ASSERTE(ppClientSite); <br>HRESULT hRes = E_POINTER; <br>if (ppClientSite != NULL) <br>{ <br>*ppClientSite = m_spClientSite; <br>m_spClientSite-&gt;AddRef(); <br>hRes = S_OK; <br>} <br>return hRes; <br>} <br> <br>HRESULT CComControlBase::IOleObject_Advise(IAdviseSink *pAdvSink, <br>DWORD *pdwConnection) <br>{ <br>HRESULT hr = S_OK; <br>if (m_spOleAdviseHolder == NULL) <br>hr = CreateOleAdviseHolder(&amp;m_spOleAdviseHolder); <br>if (SUCCEEDED(hr)) <br>hr = m_spOleAdviseHolder-&gt;Advise(pAdvSink, pdwConnection); <br>return hr; <br>} <br> <br>HRESULT CComControlBase::IOleObject_Close(DWORD dwSaveOption) <br>{ <br>CComPtr&lt;IOleInPlaceObject&gt; pIPO; <br>ControlQueryInterface(IID_IOleInPlaceObject, (void**)&amp;pIPO); <br>_ASSERTE(pIPO != NULL); <br>if (m_hWndCD) <br>{ <br>if (m_spClientSite) <br>m_spClientSite-&gt;OnShowWindow(FALSE); <br>} <br> <br>if (m_bInPlaceActive) <br>{ <br>HRESULT hr = pIPO-&gt;InPlaceDeactivate(); <br>if (FAILED(hr)) <br>return hr; <br>_ASSERTE(!m_bInPlaceActive); <br>} <br>if (m_hWndCD) <br>{ <br>ATLTRACE(_T("Destroying Window\n")); <br>if (::IsWindow(m_hWndCD)) <br>DestroyWindow(m_hWndCD); <br>m_hWndCD = NULL; <br>} <br> <br>// handle the save flag. <br>// <br>if ((dwSaveOption == OLECLOSE_SAVEIFDIRTY || <br>dwSaveOption == OLECLOSE_PROMPTSAVE) &amp;&amp; m_bRequiresSave) <br>{ <br>if (m_spClientSite) <br>m_spClientSite-&gt;SaveObject(); <br>SendOnSave(); <br>} <br> <br>m_spInPlaceSite.Release(); <br>m_bNegotiatedWnd = FALSE; <br>m_bWndLess = FALSE; <br>m_bInPlaceSiteEx = FALSE; <br>m_spAdviseSink.Release(); <br>return S_OK; <br>} <br> <br>HRESULT CComControlBase::IOleInPlaceObject_InPlaceDeactivate(void) <br>{ <br>CComPtr&lt;IOleInPlaceObject&gt; pIPO; <br>ControlQueryInterface(IID_IOleInPlaceObject, (void**)&amp;pIPO); <br>_ASSERTE(pIPO != NULL); <br> <br>if (!m_bInPlaceActive) <br>return S_OK; <br>pIPO-&gt;UIDeactivate(); <br> <br>m_bInPlaceActive = FALSE; <br> <br>// if we have a window, tell it to go away. <br>// <br>if (m_hWndCD) <br>{ <br>ATLTRACE(_T("Destroying Window\n")); <br>if (::IsWindow(m_hWndCD)) <br>DestroyWindow(m_hWndCD); <br>m_hWndCD = NULL; <br>} <br> <br>if (m_spInPlaceSite) <br>m_spInPlaceSite-&gt;OnInPlaceDeactivate(); <br> <br>return S_OK; <br>} <br> <br>HRESULT CComControlBase::IOleInPlaceObject_UIDeactivate(void) <br>{ <br>// if we're not UIActive, not much to do. <br>// <br>if (!m_bUIActive) <br>return S_OK; <br> <br>m_bUIActive = FALSE; <br> <br>// notify frame windows, if appropriate, that we're no longer ui-active. <br>// <br>CComPtr&lt;IOleInPlaceFrame&gt; spInPlaceFrame; <br>CComPtr&lt;IOleInPlaceUIWindow&gt; spInPlaceUIWindow; <br>OLEINPLACEFRAMEINFO frameInfo; <br>frameInfo.cb = sizeof(OLEINPLACEFRAMEINFO); <br>RECT rcPos, rcClip; <br> <br>HWND hwndParent;  <br>// This call to GetWindow is a fix for Delphi <br>if (m_spInPlaceSite-&gt;GetWindow(&amp;hwndParent) == S_OK) <br>{ <br>m_spInPlaceSite-&gt;GetWindowContext(&amp;spInPlaceFrame, <br>&amp;spInPlaceUIWindow, &amp;rcPos, &amp;rcClip, &amp;frameInfo); <br>if (spInPlaceUIWindow) <br>spInPlaceUIWindow-&gt;SetActiveObject(NULL, NULL); <br>if (spInPlaceFrame) <br>spInPlaceFrame-&gt;SetActiveObject(NULL, NULL); <br>} <br>// we don't need to explicitly release the focus here since somebody <br>// else grabbing the focus is what is likely to cause us to get lose it <br>// <br>m_spInPlaceSite-&gt;OnUIDeactivate(FALSE); <br> <br>return S_OK; <br>} <br> <br>HRESULT CComControlBase::IOleInPlaceObject_SetObjectRects(LPCRECT prcPos,LPCRECT prcClip) <br>{ <br>if (prcPos == NULL || prcClip == NULL) <br>return E_POINTER; <br> <br>m_rcPos = *prcPos; <br>if (m_hWndCD) <br>{ <br>// the container wants us to clip, so figure out if we really <br>// need to <br>// <br>RECT rcIXect; <br>BOOL b = IntersectRect(&amp;rcIXect, prcPos, prcClip); <br>HRGN tempRgn = NULL; <br>if (b &amp;&amp; !EqualRect(&amp;rcIXect, prcPos)) <br>{ <br>OffsetRect(&amp;rcIXect, -(prcPos-&gt;left), -(prcPos-&gt;top)); <br>tempRgn = CreateRectRgnIndirect(&amp;rcIXect); <br>} <br> <br>SetWindowRgn(m_hWndCD, tempRgn, TRUE); <br> <br>// set our control's location, but don't change it's size at all <br>// [people for whom zooming is important should set that up here] <br>// <br>SIZEL size = {prcPos-&gt;right - prcPos-&gt;left, prcPos-&gt;bottom - prcPos-&gt;top}; <br>SetWindowPos(m_hWndCD, NULL, prcPos-&gt;left, <br> prcPos-&gt;top, size.cx, size.cy, SWP_NOZORDER | SWP_NOACTIVATE); <br>} <br> <br>return S_OK; <br>} <br> <br>HRESULT CComControlBase::IOleObject_SetExtent(DWORD dwDrawAspect, SIZEL *psizel) <br>{ <br>if (dwDrawAspect != DVASPECT_CONTENT) <br>return DV_E_DVASPECT; <br>if (psizel == NULL) <br>return E_POINTER; <br> <br>BOOL bSizeMatchesNatural = <br>memcmp(psizel, &amp;m_sizeNatural, sizeof(SIZE)) == 0; <br> <br>if (m_bAutoSize) //object can't do any other size <br>return (bSizeMatchesNatural) ? S_OK : E_FAIL; <br> <br>BOOL bResized = FALSE; <br>if (memcmp(psizel, &amp;m_sizeExtent, sizeof(SIZE)) != 0) <br>{ <br>m_sizeExtent = *psizel; <br>bResized = TRUE; <br>} <br>if (m_bResizeNatural &amp;&amp; !bSizeMatchesNatural) <br>{ <br>m_sizeNatural = *psizel; <br>bResized = TRUE; <br>} <br> <br>if (m_bRecomposeOnResize &amp;&amp; bResized) <br>{ <br>SendOnDataChange(); <br>FireViewChange(); <br>} <br>return S_OK; <br>} <br> <br>HRESULT CComControlBase::IViewObject_Draw(DWORD dwDrawAspect, LONG lindex, <br>void *pvAspect, DVTARGETDEVICE *ptd, HDC hicTargetDev, HDC hdcDraw, <br>LPCRECTL prcBounds, LPCRECTL prcWBounds) <br>{ <br>ATLTRACE(_T("Draw dwDrawAspect=%x lindex=%d ptd=%x hic=%x hdc=%x\n"), <br>dwDrawAspect, lindex, ptd, hicTargetDev, hdcDraw); <br>#ifdef _DEBUG <br>if (prcBounds == NULL) <br>ATLTRACE(_T("\tprcBounds=NULL\n")); <br>else <br>ATLTRACE(_T("\tprcBounds=%d,%d,%d,%d\n"), prcBounds-&gt;left, <br>prcBounds-&gt;top, prcBounds-&gt;right, prcBounds-&gt;bottom); <br>if (prcWBounds == NULL) <br>ATLTRACE(_T("\tprcWBounds=NULL\n")); <br>else <br>ATLTRACE(_T("\tprcWBounds=%d,%d,%d,%d\n"), prcWBounds-&gt;left, <br>prcWBounds-&gt;top, prcWBounds-&gt;right, prcWBounds-&gt;bottom); <br>#endif <br>_ASSERTE(prcBounds != NULL | m_bWndLess); <br> <br>if (prcBounds == NULL) <br>{ <br>if (!m_bWndLess) <br>return E_INVALIDARG; <br>prcBounds = (RECTL*)&amp;m_rcPos; <br>} <br> <br>// support the aspects required for multi-pass drawing <br>switch (dwDrawAspect) <br>{ <br>case DVASPECT_CONTENT: <br>case DVASPECT_OPAQUE: <br>case DVASPECT_TRANSPARENT: <br>break; <br>default: <br>_ASSERTE(FALSE); <br>return DV_E_DVASPECT; <br>break; <br>} <br> <br>// make sure nobody forgets to do this <br>if (ptd == NULL) <br>hicTargetDev = NULL; <br> <br>BOOL bOptimize = FALSE; <br>if (pvAspect &amp;&amp; ((DVASPECTINFO *)pvAspect)-&gt;cb &gt;= sizeof(DVASPECTINFO)) <br>bOptimize = (((DVASPECTINFO *)pvAspect)-&gt;dwFlags &amp; DVASPECTINFOFLAG_CANOPTIMIZE); <br> <br>ATL_DRAWINFO di; <br>memset(&amp;di, 0, sizeof(di)); <br>di.cbSize = sizeof(di); <br>di.dwDrawAspect = dwDrawAspect; <br>di.lindex = lindex; <br>di.ptd = ptd; <br>di.hicTargetDev = hicTargetDev; <br>di.hdcDraw = hdcDraw; <br>di.prcBounds = prcBounds; <br>di.prcWBounds = prcWBounds; <br>di.bOptimize = bOptimize; <br>return OnDrawAdvanced(di); <br>} <br> <br>HRESULT CComControlBase::IDataObject_GetData(FORMATETC *pformatetcIn, <br>STGMEDIUM *pmedium) <br>{ <br>if (pmedium == NULL) <br>return E_POINTER; <br>memset(pmedium, 0, sizeof(STGMEDIUM)); <br>ATLTRACE(_T("Format = %x\n"), pformatetcIn-&gt;cfFormat); <br>ATLTRACE(_T("TYMED = %x\n"), pformatetcIn-&gt;tymed); <br> <br>if ((pformatetcIn-&gt;tymed &amp; TYMED_MFPICT) == 0) <br>return DATA_E_FORMATETC; <br> <br>SIZEL sizeMetric, size; <br>if (m_bDrawFromNatural) <br>sizeMetric = m_sizeNatural; <br>else <br>sizeMetric = m_sizeExtent; <br>if (!m_bDrawGetDataInHimetric) <br>AtlHiMetricToPixel(&amp;sizeMetric, &amp;size); <br>else <br>size = sizeMetric; <br>RECTL rectl = {0 ,0, size.cx, size.cy}; <br> <br>ATL_DRAWINFO di; <br>memset(&amp;di, 0, sizeof(di)); <br>di.cbSize = sizeof(di); <br>di.dwDrawAspect = DVASPECT_CONTENT; <br>di.lindex = -1; <br>di.ptd = NULL; <br>di.hicTargetDev = NULL; <br>di.prcBounds = &amp;rectl; <br>di.prcWBounds = &amp;rectl; <br>di.bOptimize = TRUE; //we do a SaveDC/RestoreDC <br>di.bRectInHimetric = m_bDrawGetDataInHimetric; <br>// create appropriate memory metafile DC <br>di.hdcDraw = CreateMetaFile(NULL); <br> <br>// create attribute DC according to pformatetcIn-&gt;ptd <br> <br>SaveDC(di.hdcDraw); <br>SetWindowOrgEx(di.hdcDraw, 0, 0, NULL); <br>SetWindowExtEx(di.hdcDraw, rectl.right, rectl.bottom, NULL); <br>OnDrawAdvanced(di); <br>RestoreDC(di.hdcDraw, -1); <br> <br>HMETAFILE hMF = CloseMetaFile(di.hdcDraw); <br>if (hMF == NULL) <br>return E_UNEXPECTED; <br> <br>HGLOBAL hMem=GlobalAlloc(GMEM_SHARE | GMEM_MOVEABLE, sizeof(METAFILEPICT)); <br> <br>if (NULL==hMem) <br>{ <br>DeleteMetaFile(hMF); <br>return ResultFromScode(STG_E_MEDIUMFULL); <br>} <br> <br>LPMETAFILEPICT pMF=(LPMETAFILEPICT)GlobalLock(hMem); <br>pMF-&gt;hMF=hMF; <br>pMF-&gt;mm=MM_ANISOTROPIC; <br>pMF-&gt;xExt=sizeMetric.cx; <br>pMF-&gt;yExt=sizeMetric.cy; <br>GlobalUnlock(hMem); <br> <br>pmedium-&gt;tymed = TYMED_MFPICT; <br>pmedium-&gt;hGlobal = hMem; <br>pmedium-&gt;pUnkForRelease = NULL; <br> <br>return S_OK; <br> <br>} <br> <br>HRESULT CComControlBase::FireViewChange() <br>{ <br>if (m_bInPlaceActive) <br>{ <br>// Active <br>if (m_hWndCD != NULL) <br>return ::InvalidateRect(m_hWndCD, NULL, TRUE); // Window based <br>if (m_spInPlaceSite != NULL) <br>return m_spInPlaceSite-&gt;InvalidateRect(NULL, TRUE); // Windowless <br>} <br>// Inactive <br>SendOnViewChange(DVASPECT_CONTENT); <br>return S_OK; <br>} <br> <br>void CComControlBase::GetZoomInfo(ATL_DRAWINFO&amp; di) <br>{ <br>const RECTL&amp; rcPos = *di.prcBounds; <br>SIZEL sizeDen; <br>if (m_bDrawFromNatural) <br>sizeDen = m_sizeNatural; <br>else <br>sizeDen = m_sizeExtent; <br>if (!di.bRectInHimetric) <br>AtlHiMetricToPixel(&amp;sizeDen, &amp;sizeDen); <br>SIZEL sizeNum = {rcPos.right-rcPos.left, rcPos.bottom-rcPos.top}; <br>di.ZoomNum.cx = sizeNum.cx; <br>di.ZoomNum.cy = sizeNum.cy; <br>di.ZoomDen.cx = sizeDen.cx; <br>di.ZoomDen.cy = sizeDen.cy; <br>if (sizeDen.cx == 0 || sizeDen.cy == 0 || <br>sizeNum.cx == 0 || sizeNum.cy == 0) <br>{ <br>di.ZoomNum.cx = di.ZoomNum.cy = di.ZoomDen.cx = di.ZoomDen.cy = 1; <br>di.bZoomed = FALSE; <br>} <br>else if (sizeNum.cx != sizeDen.cx || sizeNum.cy != sizeDen.cy) <br>di.bZoomed = TRUE; <br>else <br>di.bZoomed = FALSE; <br>} <br> <br>HRESULT CComControlBase::OnDrawAdvanced(ATL_DRAWINFO&amp; di) <br>{ <br>BOOL bDeleteDC = FALSE; <br>if (di.hicTargetDev == NULL) <br>{ <br>di.hicTargetDev = AtlCreateTargetDC(di.hdcDraw, di.ptd); <br>bDeleteDC = (di.hicTargetDev != di.hdcDraw); <br>} <br>RECTL rectBoundsDP = *di.prcBounds; <br>BOOL bMetafile = GetDeviceCaps(di.hdcDraw, TECHNOLOGY) == DT_METAFILE; <br>if (!bMetafile) <br>{ <br>::LPtoDP(di.hicTargetDev, (LPPOINT)&amp;rectBoundsDP, 2); <br>SaveDC(di.hdcDraw); <br>SetMapMode(di.hdcDraw, MM_TEXT); <br>SetWindowOrgEx(di.hdcDraw, 0, 0, NULL); <br>SetViewportOrgEx(di.hdcDraw, 0, 0, NULL); <br>di.bOptimize = TRUE; //since we save the DC we can do this <br>} <br>di.prcBounds = &amp;rectBoundsDP; <br>GetZoomInfo(di); <br> <br>HRESULT hRes = OnDraw(di); <br>if (bDeleteDC) <br>::DeleteDC(di.hicTargetDev); <br>if (!bMetafile) <br>RestoreDC(di.hdcDraw, -1); <br>return hRes; <br>} <br> <br>LRESULT CComControlBase::OnPaint(UINT /* nMsg */, WPARAM /* wParam */, <br>LPARAM /* lParam */, BOOL&amp; /* lResult */) <br>{ <br>RECT rc; <br>PAINTSTRUCT ps; <br> <br>HDC hdc = ::BeginPaint(m_hWndCD, &amp;ps); <br>if (hdc == NULL) <br>return 0; <br>::GetClientRect(m_hWndCD, &amp;rc); <br> <br>ATL_DRAWINFO di; <br>memset(&amp;di, 0, sizeof(di)); <br>di.cbSize = sizeof(di); <br>di.dwDrawAspect = DVASPECT_CONTENT; <br>di.lindex = -1; <br>di.hdcDraw = hdc; <br>di.prcBounds = (LPCRECTL)&amp;rc; <br> <br>OnDrawAdvanced(di); <br>::EndPaint(m_hWndCD, &amp;ps); <br>return 0; <br>} <br> <br>#ifndef ATL_NO_NAMESPACE <br>}; //namespace ATL <br>#endif <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//All Global stuff goes below this line <br>/////////////////////////////////////////////////////////////////////////////// <br> <br>#ifndef _ATL_DLL <br>ATLAPI_(HDC) AtlCreateTargetDC(HDC hdc, DVTARGETDEVICE* ptd) <br>{ <br>USES_CONVERSION; <br> <br>// cases  hdc, ptd, hdc is metafile, hic <br>//  NULL,    NULL,  n/a,    Display <br>//  NULL,   !NULL,  n/a,    ptd <br>//  !NULL,   NULL,  FALSE,  hdc <br>//  !NULL,   NULL,  TRUE,   display <br>//  !NULL,  !NULL,  FALSE,  ptd <br>//  !NULL,  !NULL,  TRUE,   ptd <br> <br>if (ptd != NULL) <br>{ <br>LPDEVMODEOLE lpDevMode; <br>LPOLESTR lpszDriverName; <br>LPOLESTR lpszDeviceName; <br>LPOLESTR lpszPortName; </code></pre>
<p>
</p>
<pre><code><br>if (ptd-&gt;tdExtDevmodeOffset == 0) <br>lpDevMode = NULL; <br>else <br>lpDevMode  = (LPDEVMODEOLE) ((LPSTR)ptd + ptd-&gt;tdExtDevmodeOffset); <br> <br>lpszDriverName = (LPOLESTR)((BYTE*)ptd + ptd-&gt;tdDriverNameOffset); <br>lpszDeviceName = (LPOLESTR)((BYTE*)ptd + ptd-&gt;tdDeviceNameOffset); <br>lpszPortName   = (LPOLESTR)((BYTE*)ptd + ptd-&gt;tdPortNameOffset); <br> <br>return ::CreateDC(OLE2CT(lpszDriverName), OLE2CT(lpszDeviceName), <br>OLE2CT(lpszPortName), DEVMODEOLE2T(lpDevMode)); <br>} <br>else if (hdc == NULL || GetDeviceCaps(hdc, TECHNOLOGY) == DT_METAFILE) <br>return ::CreateDC(_T("DISPLAY"), NULL, NULL, NULL); <br>else <br>return hdc; <br>} <br> <br>#define HIMETRIC_PER_INCH   2540 <br>#define MAP_PIX_TO_LOGHIM(x,ppli)   ( (HIMETRIC_PER_INCH*(x) + ((ppli)&gt;&gt;1)) / (ppli) ) <br>#define MAP_LOGHIM_TO_PIX(x,ppli)   ( ((ppli)*(x) + HIMETRIC_PER_INCH/2) / HIMETRIC_PER_INCH ) <br> <br>ATLAPI_(void) AtlHiMetricToPixel(const SIZEL * lpSizeInHiMetric, LPSIZEL lpSizeInPix) <br>{ <br>int nPixelsPerInchX;    // Pixels per logical inch along width <br>int nPixelsPerInchY;    // Pixels per logical inch along height <br> <br>HDC hDCScreen = GetDC(NULL); <br>_ASSERTE(hDCScreen != NULL); <br>nPixelsPerInchX = GetDeviceCaps(hDCScreen, LOGPIXELSX); <br>nPixelsPerInchY = GetDeviceCaps(hDCScreen, LOGPIXELSY); <br>ReleaseDC(NULL, hDCScreen); <br> <br>lpSizeInPix-&gt;cx = MAP_LOGHIM_TO_PIX(lpSizeInHiMetric-&gt;cx, nPixelsPerInchX); <br>lpSizeInPix-&gt;cy = MAP_LOGHIM_TO_PIX(lpSizeInHiMetric-&gt;cy, nPixelsPerInchY); <br>} <br> <br>ATLAPI_(void) AtlPixelToHiMetric(const SIZEL * lpSizeInPix, LPSIZEL lpSizeInHiMetric) <br>{ <br>int nPixelsPerInchX;    // Pixels per logical inch along width <br>int nPixelsPerInchY;    // Pixels per logical inch along height <br> <br>HDC hDCScreen = GetDC(NULL); <br>_ASSERTE(hDCScreen != NULL); <br>nPixelsPerInchX = GetDeviceCaps(hDCScreen, LOGPIXELSX); <br>nPixelsPerInchY = GetDeviceCaps(hDCScreen, LOGPIXELSY); <br>ReleaseDC(NULL, hDCScreen); <br> <br>lpSizeInHiMetric-&gt;cx = MAP_PIX_TO_LOGHIM(lpSizeInPix-&gt;cx, nPixelsPerInchX); <br>lpSizeInHiMetric-&gt;cy = MAP_PIX_TO_LOGHIM(lpSizeInPix-&gt;cy, nPixelsPerInchY); <br>} <br>#endif </code></pre>
<p>&nbsp;</p></body>
</HTML>
