<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>GLASSCTL.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3867"></a>GLASSCTL.CPP</h2>
<pre><code>// GlassControl.cpp : Implementation of CGlassControl <br>#include "stdafx.h" <br>#include "initguid.h" <br>#include "Glass.h" <br>#include "GlassCtl.h" <br>#include &lt;stdio.h&gt; <br>#include "COMDEF.h" <br> <br>short _GetShiftState(void); <br>short _GetButtonState(WPARAM wParam); <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// CGlassControl <br> <br>//=--------------------------------------------------------------------------= <br>// CGlassControl::CGlassControl <br>//=--------------------------------------------------------------------------= <br>// <br>// Notes: <br>// <br>CGlassControl::CGlassControl() <br>{ <br>    m_state.Brightness      = 64; <br>    m_state.iWidth          = 10; <br>    m_state.FadeInterval    = 5; <br>    m_state.fFreeze         = 0; <br>    m_state.fEnabled        = TRUE; <br>    m_state.fInvalid        = TRUE; <br>    m_pDirectDraw3          = NULL; <br>    m_pTimer                = NULL; <br>    m_pTimerSink            = NULL; <br>    m_TimerCookie           = 0; <br>    m_timeLastAdvise        = 0; <br> <br>    m_pSource               = NULL; <br>    m_pSite                 = NULL; <br>    SetRect(&amp;m_rc, 0, 0, 0, 0); <br>    m_pCSSSite              = NULL; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// CGlassControl::~CGlassControl <br>//=--------------------------------------------------------------------------= <br>// <br>// Notes: Our timer sink is not part of this object to avoid circular  <br>//        references, but the sink must be told that the control is <br>//        no longer around to be called. <br>// <br>CGlassControl::~CGlassControl () <br>{ <br>    if ( m_pTimerSink ) <br>        m_pTimerSink-&gt;m_pGC = NULL;     // Sink is on its own <br>    if ( m_pDirectDraw3 ) <br>        m_pDirectDraw3-&gt;Release(); <br>    if ( m_pTimer ) <br>        m_pTimer-&gt;Release(); <br> <br>    if (m_pSource) <br>    { <br>        m_pSource-&gt;SetSite(0); <br>        m_pSource-&gt;Release(); <br>    } <br>    if (m_pSite) <br>        m_pSite-&gt;Release(); <br> <br>    if (m_pCSSSite) <br>        m_pCSSSite-&gt;Release(); <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// CGlassControl::OnDraw <br>//=--------------------------------------------------------------------------= <br>// <br>// Parameters: <br>//    ATL_DRAWINGO       - [in]  HDC, rects, and all that stuff <br>// <br>// Output: <br>//    HRESULT <br>// <br>// Notes: <br>// <br> <br>HRESULT CGlassControl::OnDraw(ATL_DRAWINFO&amp; di) <br>{ <br>    HBRUSH              hbrold; <br>    HPEN                hpen, hpenold; <br>    IDirectDrawSurface *pDDSurface = NULL; <br>    DDSURFACEDESC       desc; <br>    HRESULT             hr = S_OK; <br>    RECT                rc, rcLens, rcClip; <br>    HPALETTE            hpal = NULL; <br>    BYTE                itoi[256]; <br>    VOID               *pBits = NULL; <br>    long                pitch; <br>    long                x, y; <br>int            bpp = 0, i; <br>    BYTE*               prow; <br>    BYTE*               pput; <br> <br>    //  <br>    // draw a thick, green rectangle border <br>    // <br>    hpen = CreatePen(PS_INSIDEFRAME, m_state.iWidth, RGB(0, 255, 0)); <br>    if (!hpen) return E_FAIL; <br>    hpenold = (HPEN)SelectObject(di.hdcDraw, hpen); <br>    if (!m_bInPlaceActive || m_bWndLess) <br>        hbrold = (HBRUSH)SelectObject(di.hdcDraw, GetStockObject(HOLLOW_BRUSH)); <br>    Rectangle(di.hdcDraw, di.prcBounds-&gt;left, di.prcBounds-&gt;top, di.prcBounds-&gt;right, di.prcBounds-&gt;bottom); <br>    if (!di.bOptimize) { <br>        if (!m_bInPlaceActive || m_bWndLess) <br>            SelectObject(di.hdcDraw, hbrold); <br>        SelectObject(di.hdcDraw, hpenold); <br>    } <br> <br>    rcLens = *(RECT*)di.prcBounds; <br>    InflateRect(&amp;rcLens, -m_state.iWidth, -m_state.iWidth); <br> <br>    GetClipBox(di.hdcDraw, &amp;rcClip); <br>    if (!IntersectRect(&amp;rcLens, &amp;rcClip, &amp;rcLens)) <br>        // no intersection with interior "lens" area; nothing to do <br>        goto Cleanup; <br> <br>    // get surface factory via service provider <br>    if (!m_pDirectDraw3) <br>    { <br>        IServiceProvider * serviceProvider = 0; <br> <br>        if ( m_spClientSite )       // this is if we are an ole object thru the &lt;OBJECT&gt; tag <br>            m_spClientSite-&gt;QueryInterface( <br>                    IID_IServiceProvider, <br>    (void**)&amp;serviceProvider); <br>        else if ( m_pCSSSite )      // this is if we are a CSS Extension (Filter) object <br>        { <br>            hr = m_pCSSSite-&gt;QueryInterface( IID_IServiceProvider,  <br>                                             (void**)&amp;serviceProvider); <br>            if ( hr ) <br>                goto ErrorExit; <br>        } <br>        else <br>            goto ErrorExit; <br> <br>        if (FAILED(hr)) <br>            goto ErrorExit; <br>        hr = serviceProvider-&gt;QueryService( <br>                SID_SDirectDraw3, <br>                IID_IDirectDraw3, <br>                (void**)&amp;m_pDirectDraw3); <br>        serviceProvider-&gt;Release(); <br>        if (FAILED(hr)) <br>            goto ErrorExit; <br>    } <br>    // get DDSurface pointer <br>    hr = m_pDirectDraw3-&gt;GetSurfaceFromDC(di.hdcDraw, &amp;pDDSurface); <br>    if (FAILED(hr)) <br>        goto ErrorExit; <br> <br>    // map our rect into the surface coords <br>    rc = rcLens; <br>    LPtoDP(di.hdcDraw, (POINT*)&amp;rcLens, 2); <br> <br>    // lock it to get pbits <br>    desc.dwSize = sizeof(desc); <br>    hr = pDDSurface-&gt;Lock(&amp;rcLens, &amp;desc, DDLOCK_SURFACEMEMORYPTR | DDLOCK_WAIT, NULL); <br>    if (FAILED(hr)) <br>        goto ErrorExit; <br>    pBits = desc.lpSurface; <br>    pitch = desc.lPitch; <br>    bpp = desc.ddpfPixelFormat.dwRGBBitCount; <br>    if (bpp == 16 <br>        &amp;&amp; desc.ddpfPixelFormat.dwRBitMask == 0x7C00 <br>        &amp;&amp; desc.ddpfPixelFormat.dwGBitMask == 0x03E0 <br>        &amp;&amp; desc.ddpfPixelFormat.dwBBitMask == 0x001F) <br>    { <br>        bpp = 15; <br>    } <br> <br>    switch (bpp) <br>    { <br>    case 8: <br>        // <br>        // 8-bpp paletted case <br>        // <br> <br>        // <br>        // modify the bits directly <br>        // <br>struct  <br>        { <br>            WORDpalVersion; <br>            WORDpalNumEntries; <br>            PALETTEENTRY    palPalEntry[256]; <br>        } logpal; <br> <br>        logpal.palNumEntries = 256; <br>logpal.palVersion = 0x300; <br>IDirectDrawPalette* pDDPalette; <br>hr = pDDSurface-&gt;GetPalette(&amp;pDDPalette); <br>if (SUCCEEDED(hr)) <br>{ <br>hr = pDDPalette-&gt;GetEntries(0, 0, 256, logpal.palPalEntry); <br>pDDPalette-&gt;Release(); <br>} <br>        if (SUCCEEDED(hr)) <br>        { <br>                int     r,g,b; <br>HPALETTE    hpal; <br>                hpal = (HPALETTE)GetCurrentObject(di.hdcDraw, OBJ_PAL); <br>                 <br>                for (i = 0; i &lt; logpal.palNumEntries; ++i) <br>                { <br>                    r = max(0, min(255, logpal.palPalEntry[i].peRed   + m_state.Brightness)); <br>                    g = max(0, min(255, logpal.palPalEntry[i].peGreen + m_state.Brightness)); <br>                    b = max(0, min(255, logpal.palPalEntry[i].peBlue  + m_state.Brightness)); <br>                    itoi[i] = GetNearestPaletteIndex(hpal, RGB(r,g,b)); <br>                } <br>DeleteObject(hpal); <br> <br>                // then use the map to translate the pixels <br>                prow = (BYTE*)pBits; <br>                for (y = rcLens.top; y &lt; rcLens.bottom; ++y) <br>                { <br>                    pput = prow; <br>                    for (x = rcLens.left; x &lt; rcLens.right; ++x) <br>                    { <br>                        *pput = itoi[*pput]; <br>                        pput++; <br>                    } <br>                    prow += pitch; <br>                } <br>        } <br>break; <br> <br>case 24: <br>        // <br>        // 24-bpp case <br>        // <br>        int p; <br>        for (i = 0; i &lt;= 255; ++i) <br>            itoi[i] = max(0, min(255, i + m_state.Brightness)); <br>        prow = (BYTE*)pBits; <br>        for (y = rcLens.top; y &lt; rcLens.bottom; ++y) <br>        { <br>            pput = prow; <br>            for (x = rcLens.left; x &lt; rcLens.right; ++x) <br>            { <br>                for (p = 1; p &lt;= 3; ++p) <br>                { <br>                    *pput = itoi[*pput]; <br>                    pput++; <br>                } <br>            } <br>            prow += pitch; <br>} <br>        break; <br> <br>    case 32: <br>        // <br>        // 32-bpp case; same as 24-bpp, but 4 bytes per pixel <br>        // <br>        for (i = 0; i &lt;= 255; ++i) <br>            itoi[i] = max(0, min(255, i + m_state.Brightness)); <br>        prow = (BYTE*)pBits; <br>        for (y = rcLens.top; y &lt; rcLens.bottom; ++y) <br>        { <br>            pput = prow; <br>            for (x = rcLens.left; x &lt; rcLens.right; ++x) <br>            { <br>                for (p = 1; p &lt;= 3; ++p) <br>                { <br>                    *pput = itoi[*pput]; <br>                    pput++; <br>                } <br>                pput++; // do that extra dummy byte <br>            } <br>            prow += pitch; <br>        } <br>break; <br> <br>    case 15: <br>        { <br>            // <br>            // 16-bpp 555 case <br>            // <br>            typedef struct <br>            { <br>                unsigned short r:5; <br>                unsigned short g:5; <br>                unsigned short b:5; <br>            } W555; <br>            W555* pputw; <br>            W555 w; <br>            for (i = 0; i &lt;= 31; ++i) <br>                itoi[i] = max(0, min(31, ((i &lt;&lt; 3) + m_state.Brightness + 3) &gt;&gt; 3)); <br>            prow = (BYTE*)pBits; <br>            for (y = rcLens.top; y &lt; rcLens.bottom; ++y) <br>            { <br>                pputw = (W555*)prow; <br>                for (x = rcLens.left; x &lt; rcLens.right; ++x) <br>                { <br>                    w = *pputw; <br>                    w.r = itoi[w.r]; <br>                    w.g = itoi[w.g]; <br>                    w.b = itoi[w.b]; <br>                    *pputw++ = w; <br>                } <br>                prow += pitch; <br>            } <br>        } <br>break; <br> <br>    case 16: <br>        { <br>            // <br>            // 16-bpp 565 case <br>            // <br>            typedef struct <br>            { <br>                unsigned short r:5; <br>                unsigned short g:6; <br>                unsigned short b:5; <br>            } W565; <br>            W565* pputw; <br>            W565 w; <br>            for (i = 0; i &lt;= 31; ++i) <br>                itoi[i] = max(0, min(31, ((i &lt;&lt; 3) + m_state.Brightness + 4) &gt;&gt; 3)); <br>            for (i = 0; i &lt;= 63; ++i) <br>                itoi[i+32] = max(0, min(63, ((i &lt;&lt; 2) + m_state.Brightness + 1) &gt;&gt; 2)); <br>            prow = (BYTE*)pBits; <br>            for (y = rcLens.top; y &lt; rcLens.bottom; ++y) <br>            { <br>                pputw = (W565*)prow; <br>                for (x = rcLens.left; x &lt; rcLens.right; ++x) <br>                { <br>                    w = *pputw; <br>                    w.r = itoi[w.r]; <br>                    w.g = itoi[w.g+32]; <br>                    w.b = itoi[w.b]; <br>                    *pputw++ = w; <br>                } <br>                prow += pitch; <br>            } <br>        } <br>break; <br> <br>    case 4: <br>        // <br>        // 4-bpp case <br>        // <br>        prow = (BYTE*)pBits; <br>        for (y = rcLens.top; y &lt; rcLens.bottom; ++y) <br>        { <br>            pput = prow; <br>            for (x = rcLens.left; x &lt; rcLens.right; ++x) <br>            { <br>                // just an inversion, for demo purposes <br>                if (x &amp; 1) <br>                { <br>                    *pput = *pput ^ 0x0F; <br>                    ++pput; <br>                } <br>                else <br>                { <br>                    *pput = *pput ^ 0xF0; <br>                } <br>            } <br>            prow += pitch; <br>        } <br>break; <br> <br>    case 1: <br>        { <br>            // <br>            // 1-bpp case <br>            // <br>            static BYTE msk[8] = { 0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01 }; <br>            prow = (BYTE*)pBits; <br>            for (y = rcLens.top; y &lt; rcLens.bottom; ++y) <br>            { <br>                pput = prow; <br>                for (x = rcLens.left; x &lt; rcLens.right; ++x) <br>                { <br>                    // just an inversion, for demo purposes <br>                    *pput = *pput ^ msk[x &amp; 0x7]; <br>                    if ((x &amp; 0x7) == 7) <br>                        ++pput; <br>                } <br>                prow += pitch; <br>            } <br>        } <br>break; <br> <br>    default: <br>        _ASSERT("Unsupported Buffer Depth"); <br>break; <br>} <br> <br>Cleanup: <br>    if (pDDSurface) <br>    { <br>        // unlock pbits <br>        if (pBits) <br>            pDDSurface-&gt;Unlock(pBits); <br>        pDDSurface-&gt;Release(); <br>    } <br>    DeleteObject(hpen); <br> <br>    return S_OK; <br> <br>ErrorExit: <br>    // mark control with big X to let user know something went wrong <br>    MoveToEx(di.hdcDraw, di.prcBounds-&gt;left+m_state.iWidth, di.prcBounds-&gt;top+m_state.iWidth, NULL); <br>    LineTo(  di.hdcDraw, di.prcBounds-&gt;right-m_state.iWidth, di.prcBounds-&gt;bottom-m_state.iWidth); <br>    MoveToEx(di.hdcDraw, di.prcBounds-&gt;right-m_state.iWidth, di.prcBounds-&gt;top+m_state.iWidth, NULL); <br>    LineTo(  di.hdcDraw, di.prcBounds-&gt;left+m_state.iWidth, di.prcBounds-&gt;bottom-m_state.iWidth); <br>    goto Cleanup; <br>} <br> <br> <br>//=--------------------------------------------------------------------------= <br>// CGlassControl::OnMouse <br>//=--------------------------------------------------------------------------= <br>// Handles Mouse events and forwards them on. <br>// <br>// Parameters: <br>//     see win32sdk on window procs [sans HWND -- it's in m_hwnd if you have one] <br>// <br>// Notes: <br>// <br>LRESULT  <br>CGlassControl::OnMouse(UINT msg, WPARAM wParam, LPARAM lParam, BOOL&amp; bHandled) <br>{ <br>    switch (msg) { <br>        case WM_LBUTTONDOWN: <br>        case WM_RBUTTONDOWN: <br>        case WM_MBUTTONDOWN: <br>            OnMouseDown(_GetButtonState(wParam), _GetShiftState(),  <br>                      (long)LOWORD(lParam), (long)HIWORD(lParam)); <br>            m_spInPlaceSite-&gt;SetCapture(TRUE); <br>            break; <br> <br>        case WM_LBUTTONUP: <br>        case WM_RBUTTONUP: <br>        case WM_MBUTTONUP: <br>            OnMouseUp(_GetButtonState(wParam), _GetShiftState(),  <br>                    (long)LOWORD(lParam), (long)HIWORD(lParam)); <br>            m_spInPlaceSite-&gt;SetCapture(FALSE); <br>            break; <br>        case WM_MOUSEMOVE: <br>            OnMouseMove(_GetButtonState(wParam), _GetShiftState(),  <br>                      (long)LOWORD(lParam), (long)HIWORD(lParam)); <br>            break; <br>    } <br>    return 0; <br>} <br> <br> <br>//=--------------------------------------------------------------------------= <br>// CGlassControl::get_LineWidth    [IGlass] <br>//=--------------------------------------------------------------------------= <br>// returns out current width <br>// <br>// Parameters: <br>//    long *                - [out] <br>// <br>// Output: <br>//    HRESULT <br>// <br>// Notes: <br>// <br>STDMETHODIMP CGlassControl::get_LineWidth <br>( <br>    long *plWidth <br>) <br>{ <br>    CHECK_POINTER(plWidth); <br> <br>    *plWidth = m_state.iWidth; <br>    return S_OK; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// CGlassControl::put_LineWidth    [IGlass] <br>//=--------------------------------------------------------------------------= <br>// sets the current width <br>// <br>// Parameters: <br>//    long              - [in]  new value <br>// <br>// Output: <br>//    HRESULT <br>// <br>// Notes: <br>// <br>STDMETHODIMP CGlassControl::put_LineWidth <br>( <br>    long lWidth <br>) <br>{ <br>    // sanity checking! <br>    // <br>    if (lWidth &lt; 0 || lWidth &gt; 255) <br>        return CTL_E_INVALIDPROPERTYVALUE; <br> <br>    // set the value, tell everybody about it, and force a repaint. <br>    // <br>    m_state.iWidth = lWidth; <br>    SetDirty(TRUE); <br>    if ( m_pSite )       // if we're a filter, normal ole control invalidation doesn't work <br>        InvalidateRect(NULL, FALSE); <br>    else <br>        FireViewChange(); <br>    return S_OK; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// CGlassControl::get_Brightness    [IGlass] <br>//=--------------------------------------------------------------------------= <br>// returns out current Brightness <br>// <br>// Parameters: <br>//    long *                - [out] <br>// <br>// Output: <br>//    HRESULT <br>// <br>// Notes: <br>// <br>STDMETHODIMP CGlassControl::get_Brightness <br>( <br>    long *plBrightness <br>) <br>{ <br>    CHECK_POINTER(plBrightness); <br> <br>    *plBrightness = m_state.Brightness; <br>    return S_OK; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// CGlassControl::put_Brightness    [IGlass] <br>//=--------------------------------------------------------------------------= <br>// sets the current Brightness <br>// <br>// Parameters: <br>//    long              - [in]  new value <br>// <br>// Output: <br>//    HRESULT <br>// <br>// Notes: <br>// <br>STDMETHODIMP CGlassControl::put_Brightness <br>( <br>    long lBrightness <br>) <br>{ <br>    // sanity checking! <br>    // <br>    if (lBrightness &lt; -255 || lBrightness &gt; 255) <br>        return CTL_E_INVALIDPROPERTYVALUE; <br> <br>    // set the value, tell everybody about it, and force a repaint. <br>    // <br>    m_state.Brightness = lBrightness; <br>    SetDirty(TRUE); <br>    if ( m_pSite )       // if we're a filter, normal ole control invalidation doesn't work <br>        InvalidateRect(NULL, FALSE); <br>    else <br>        FireViewChange(); <br>    return S_OK; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// CGlassControl::get_DynamicFade    [IGlass] <br>//=--------------------------------------------------------------------------= <br>// returns out current DynamicFade <br>// <br>// Parameters: <br>//    long *                - [out] <br>// <br>// Output: <br>//    HRESULT <br>// <br>// Notes: <br>// <br>STDMETHODIMP CGlassControl::get_DynamicFade <br>( <br>    long *plDynamicFade <br>) <br>{ <br>    CHECK_POINTER(plDynamicFade); <br> <br>    *plDynamicFade = m_state.DynamicFade; <br>    return S_OK; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// CGlassControl::put_DynamicFade    [IGlass] <br>//=--------------------------------------------------------------------------= <br>// sets the current DynamicFade <br>// <br>// Parameters: <br>//    long              - [in]  new value <br>// <br>// Output: <br>//    HRESULT <br>// <br>// Notes: <br>// <br>STDMETHODIMP CGlassControl::put_DynamicFade <br>( <br>    long lDynamicFade <br>) <br>{ <br>    VARIANT vtimeMin, vtimeMax, vtimeInt, vtimeGet; <br> <br>    // set the value, tell everybody about it <br>    // <br>    m_state.DynamicFade = (lDynamicFade &gt; 0 ? lDynamicFade:0); <br>    VariantInit( &amp;vtimeMin ); <br>    VariantInit( &amp;vtimeMax ); <br>    VariantInit( &amp;vtimeInt ); <br>    VariantInit( &amp;vtimeGet ); <br>    V_VT(&amp;vtimeMin) = VT_UI4; <br>    V_VT(&amp;vtimeMax) = VT_UI4; <br>    V_VT(&amp;vtimeInt) = VT_UI4; <br>    V_VT(&amp;vtimeGet) = VT_UI4; <br> <br>    if ( m_state.DynamicFade &gt; 0 ) <br>    { <br>        if ( m_TimerCookie &gt; 0 &amp;&amp; m_pTimer ) <br>        {       // junk old advise <br>            m_pTimer-&gt;Unadvise( m_TimerCookie ); <br>            m_TimerCookie = 0; <br>        } <br>        if ( !m_pTimer ) <br>        {       // get a timer <br>            HRESULT hr; <br>            IServiceProvider * serviceProvider = 0; <br>            ITimerService *pTimerService = 0;  <br> <br>            hr = m_spClientSite-&gt;QueryInterface( <br>                        IID_IServiceProvider, <br>        (void**)&amp;serviceProvider); <br>            if (FAILED(hr)) <br>                return hr; <br> <br>            hr = serviceProvider-&gt;QueryService( <br>                    SID_STimerService, <br>                    IID_ITimerService, <br>                    (void**)&amp;pTimerService); <br>            serviceProvider-&gt;Release(); <br>             <br>            hr = pTimerService-&gt;CreateTimer(NULL, &amp;m_pTimer); <br>            if (FAILED(hr)) <br>            { <br>                _ASSERTE(0 &amp;&amp; "Timer creation failed" ); <br>                return hr; <br>            } <br>            pTimerService-&gt;Release(); <br>        } <br> <br>        // make sure we have our sink ready <br>        if ( !m_pTimerSink ) <br>        { <br>            m_pTimerSink = new CGlassControlSink( this ); <br>            if ( !m_pTimerSink ) <br>                return E_OUTOFMEMORY; <br>        } <br> <br>        m_timeLastAdvise = 0;       // reset interval counter <br>        m_pTimer-&gt;GetTime(&amp;vtimeGet); <br>        V_UI4(&amp;vtimeMin) = V_UI4(&amp;vtimeGet); <br>        V_UI4(&amp;vtimeMax) = 0; <br>        V_UI4(&amp;vtimeInt) = (unsigned)m_state.DynamicFade; <br> <br>        m_pTimer-&gt;Advise( vtimeMin, vtimeMax, vtimeInt, 0,  <br>                          (ITimerSink *)m_pTimerSink, &amp;m_TimerCookie ); <br>         <br>    } <br>    else <br>    { <br>        if ( m_pTimer &amp;&amp; m_TimerCookie &gt; 0 ) <br>        { <br>            m_pTimer-&gt;Unadvise( m_TimerCookie ); <br>            m_TimerCookie = 0; <br>        } <br>    } <br>    return S_OK; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// CGlassControl::get_FadeInterval    [IGlass] <br>//=--------------------------------------------------------------------------= <br>// returns out current FadeInterval <br>// <br>// Parameters: <br>//    long *                - [out] <br>// <br>// Output: <br>//    HRESULT <br>// <br>// Notes: <br>// <br>STDMETHODIMP CGlassControl::get_FadeInterval <br>( <br>    long *plFadeInterval <br>) <br>{ <br>    CHECK_POINTER(plFadeInterval); <br> <br>    *plFadeInterval = m_state.FadeInterval; <br>    return S_OK; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// CGlassControl::put_FadeInterval    [IGlass] <br>//=--------------------------------------------------------------------------= <br>// sets the current FadeInterval <br>// <br>// Parameters: <br>//    long              - [in]  new value <br>// <br>// Output: <br>//    HRESULT <br>// <br>// Notes: <br>// <br>STDMETHODIMP CGlassControl::put_FadeInterval <br>( <br>    long lFadeInterval <br>) <br>{ <br> <br>    // set the value, tell everybody about it <br>    // <br>    m_state.FadeInterval = (lFadeInterval &gt; 0 ? lFadeInterval:0); <br>    return S_OK; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// CGlassControl::get_Freeze    [IGlass]  <br>//=--------------------------------------------------------------------------= <br>// returns out current Freeze <br>// <br>// Parameters: <br>//    long *                - [out] <br>// <br>// Output: <br>//    HRESULT <br>// <br>// Notes: <br>// <br>STDMETHODIMP CGlassControl::get_Freeze <br>( <br>    long *plFreeze <br>) <br>{ <br>    CHECK_POINTER(plFreeze); <br> <br>    *plFreeze = m_state.fFreeze; <br>    return S_OK; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// CGlassControl::put_Freeze    [IGlass]  <br>//=--------------------------------------------------------------------------= <br>// sets the current Freeze <br>// <br>// Parameters: <br>//    long              - [in]  new value <br>// <br>// Output: <br>//    HRESULT <br>// <br>// Notes: <br>// <br>STDMETHODIMP CGlassControl::put_Freeze <br>( <br>    long lFreeze <br>) <br>{ <br>    m_state.fFreeze = !!lFreeze; <br>    if ( m_pTimer ) <br>    { <br>        m_pTimer-&gt;Freeze( m_state.fFreeze ); <br>    } <br>    return S_OK; <br>} <br> <br> <br>//=--------------------------------------------------------------------------= <br>// CGlassControl::get_Enabled    [IGlass]  <br>//=--------------------------------------------------------------------------= <br>// returns out current Enabled <br>// <br>// Parameters: <br>//    long *                - [out] <br>// <br>// Output: <br>//    HRESULT <br>// <br>// Notes: <br>// <br>STDMETHODIMP CGlassControl::get_Enabled <br>( <br>    long *plEnabled <br>) <br>{ <br>    CHECK_POINTER(plEnabled); <br> <br>    *plEnabled = m_state.fEnabled; <br>    return S_OK; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// CGlassControl::put_Enabled    [IGlass]  <br>//=--------------------------------------------------------------------------= <br>// sets the current Enabled <br>// <br>// Parameters: <br>//    long              - [in]  new value <br>// <br>// Output: <br>//    HRESULT <br>// <br>// Notes: <br>// <br>STDMETHODIMP CGlassControl::put_Enabled <br>( <br>    long lEnabled <br>) <br>{ <br>    // set the value, tell everybody about it <br>    // Probably should freeze the timer, but then calling enabled true multiple <br>    // times, or false multiple times, could get dicy, so we won't bother. <br>    m_state.fEnabled = !!lEnabled; <br>    if ( m_pSite )       // if we're a filter, normal ole control invalidation doesn't work <br>        InvalidateRect(NULL, FALSE); <br>    else <br>        FireViewChange(); <br>    return S_OK; <br>} <br> <br> <br>//=--------------------------------------------------------------------------= <br>// CGlassControl::QueryHitPoint    [IViewObjectEx] <br>//=--------------------------------------------------------------------------= <br>// asks whether or not the user has clicked on a portion of the control, or <br>// on a transparent portion <br>// <br>// Parameters: <br>//    DWORD                - [in]  aspect <br>//    LPCRECT              - [in]  Bounds rectangle <br>//    POINT                - [in]  hit location client coordinates <br>//    LONG                 - [in]  what the container considers close <br>//    DWORD *              - [out] info about the hit <br>// <br>// Output: <br>//    HRESULT <br>// <br>// Notes: <br>// <br>STDMETHODIMP CGlassControl::QueryHitPoint <br>( <br>    DWORD    dvAspect, <br>    LPCRECT  prcBounds, <br>    POINT    ptLocation, <br>    LONG     lCloseHint, <br>    DWORD   *pdwHitResult <br>) <br>{ <br>    RECT rcSmall; <br> <br>    CHECK_POINTER(pdwHitResult); <br> <br>    rcSmall = *prcBounds; <br>    InflateRect(&amp;rcSmall, -m_state.iWidth, -m_state.iWidth); <br> <br>    // if it's within the outer retangle, but not within iWidth pixels of it, <br>    // then it's not a hit. <br>    // <br>    *pdwHitResult = (PtInRect(prcBounds, ptLocation) &amp;&amp;  <br>                    !PtInRect(&amp;rcSmall, ptLocation)) ? HITRESULT_HIT : HITRESULT_TRANSPARENT; <br>    return S_OK; <br>} <br> <br> <br>//=--------------------------------------------------------------------------= <br>// CGlassControl::HandleOnTimer         [Helper] <br>//=--------------------------------------------------------------------------= <br>// Real handler for OnTimer call on TimerSink help class. <br>// <br>// Parameters: <br>//    TIME              - [in]  scheduled time of event <br>// <br>// Output: <br>//    HRESULT <br>// <br>// Notes: Brightness delta is time sensitive, so if some notifications get <br>//        dropped it won't effect the perceived speed of the fading. <br>// <br>STDMETHODIMP CGlassControl::HandleOnTimer <br>( <br>    DWORD timeAdvise <br>) <br>{ <br>    int cInterval = 1; <br> <br>    if ( m_timeLastAdvise != 0 &amp;&amp; m_state.DynamicFade &gt; 0 &amp;&amp; <br>        timeAdvise &gt; m_timeLastAdvise ) <br>        { <br>        cInterval = (timeAdvise - m_timeLastAdvise) / m_state.DynamicFade; <br>        } <br>    m_timeLastAdvise = timeAdvise; <br> <br>    while ( cInterval-- &gt; 0 ) <br>    { <br>        m_state.Brightness += m_state.FadeInterval; <br>        if ( m_state.Brightness &gt;= 255 ) <br>        { <br>            m_state.FadeInterval = -m_state.FadeInterval; <br>            m_state.Brightness = 255; <br>        }  <br>        else if ( m_state.Brightness &lt;= -255 ) <br>        { <br>            m_state.FadeInterval = -m_state.FadeInterval; <br>            m_state.Brightness = -255; <br>        } <br>    } <br> <br>    // set the value, tell everybody about it <br>    // <br>    SetDirty(TRUE); <br>    if ( m_pSite )       // if we're a filter, normal ole control invalidation doesn't work <br>        InvalidateRect(NULL, FALSE); <br>    else <br>        FireViewChange(); <br> <br>    return S_OK; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// CGlassControlSink::***           [IUnknown] <br>//=--------------------------------------------------------------------------= <br>// Usual IUnknown implementation <br>// <br>ULONG <br>CGlassControlSink::AddRef() <br>{ <br>    return ++m_cRefs; <br>} <br> <br>ULONG <br>CGlassControlSink::Release() <br>{ <br>    if ( 0 == --m_cRefs ) <br>    { <br>        ULONG refCount = m_cRefs; <br>        delete this; <br>        return refCount; <br>    } <br>    return m_cRefs; <br>} <br> <br>HRESULT  <br>CGlassControlSink::QueryInterface(REFIID riid, void **ppv) <br>{ <br>    if ( !ppv ) <br>        return E_POINTER; <br> <br>    *ppv = NULL; <br>    if (IID_IUnknown == riid) { <br>        *ppv = (void *)(IUnknown *)this; <br>    } else if (IID_ITimerSink == riid) { <br>        *ppv = (void *)(ITimerSink *)this; <br>    } <br> <br>    if (*ppv) <br>    { <br>        ((IUnknown *)*ppv)-&gt;AddRef(); <br>        return S_OK; <br>    } <br> <br>    return E_NOINTERFACE; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// CGlassControlSink::OnTimer           [ITimerSink] <br>//=--------------------------------------------------------------------------= <br>// callback proc for Timer notifications <br>// <br>// Parameters: <br>//    TIME              - [in]  scheduled time of event <br>// <br>// Output: <br>//    HRESULT <br>// <br>// Notes: <br>// <br>STDMETHODIMP CGlassControlSink::OnTimer <br>( <br>    VARIANT timeAdvise <br>) <br>{ <br>    _ASSERTE( VT_UI4 == V_VT(&amp;timeAdvise) &amp;&amp; "Variant type mismatch" ); <br>    return( m_pGC?m_pGC-&gt;HandleOnTimer(V_UI4(&amp;timeAdvise)):S_OK ); <br>} <br> <br> <br>//=--------------------------------------------------------------------------= <br>// _GetShiftState    [standard helper!] <br>//=--------------------------------------------------------------------------= <br>// used by people to get shift state information <br>// <br>// Output: <br>//    short        - mask of shift, ctrl and alt keys <br>// <br>// Notes: <br>// <br>short _GetShiftState(void) <br>{ <br>    BOOL bShift = (GetKeyState(VK_SHIFT) &lt; 0); <br>    BOOL bCtrl  = (GetKeyState(VK_CONTROL) &lt; 0); <br>    BOOL bAlt   = (GetKeyState(VK_MENU) &lt; 0); <br> <br>    return (short)(bShift + (bCtrl &lt;&lt; 1) + (bAlt &lt;&lt; 2)); <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// _GetButtonState    [standard helper!] <br>//=--------------------------------------------------------------------------= <br>// Returns which button was pressed. Does not handle cords <br>// <br>// Output: <br>//    short        - Left, Middle, Right, or no button </code></pre>
<p>
</p>
<pre><code>// <br>// Notes: <br>// <br>short _GetButtonState(WPARAM wParam) <br>{ <br>    return (short)(wParam &amp; MK_LBUTTON) ? LEFT_BUTTON :  <br>                  ((wParam &amp; MK_RBUTTON) ? RIGHT_BUTTON :  <br>                  ((wParam &amp; MK_MBUTTON) ? MIDDLE_BUTTON : 0)); <br>} <br> <br> <br> <br>// <br>// IViewFilter and IViewFilterSite interface method implementations <br>// This is for making the Glass control a VISUAL filter <br>// <br> <br>STDMETHODIMP CGlassControl::SetSource(IViewFilter *pFilter) <br>{ <br>    if (m_pSource) <br>    { <br>        m_pSource-&gt;SetSite(NULL); <br>        m_pSource-&gt;Release(); <br>    } <br> <br>    m_pSource = pFilter; <br>    if (m_pSource) <br>    { <br>        m_pSource-&gt;AddRef(); <br>        m_pSource-&gt;SetSite((IViewFilterSite*)this); <br>    } <br>    return S_OK; <br>} <br> <br>STDMETHODIMP CGlassControl::GetSource(IViewFilter **ppFilter) <br>{ <br>    if (ppFilter == 0) <br>        return E_POINTER; <br>    *ppFilter = m_pSource; <br>    if (m_pSource) <br>    { <br>        m_pSource-&gt;AddRef(); <br>    } <br>    return S_OK; <br>} <br> <br>STDMETHODIMP CGlassControl::SetSite(IViewFilterSite *pSink) <br>{ <br>    if (m_pSite) <br>        m_pSite-&gt;Release(); <br>    m_pSite = pSink; <br> <br>    if (m_pSite) <br>    { <br>        m_pSite-&gt;AddRef(); <br>    } <br>    return S_OK; <br>} <br> <br>STDMETHODIMP CGlassControl::GetSite(IViewFilterSite **ppSink) <br>{ <br>    if (ppSink == 0) <br>        return E_POINTER; <br>    *ppSink = m_pSite; <br>    if (m_pSite) <br>        m_pSite-&gt;AddRef(); <br>    return S_OK; <br>} <br> <br>STDMETHODIMP CGlassControl::GetStatusBits(DWORD *pdwFlags) <br>{ <br>    HRESULT hr = S_OK; <br> <br>    if (m_pSource) <br>    { <br>        HRESULT hr = m_pSource-&gt;GetStatusBits(pdwFlags); <br>        if (SUCCEEDED(hr)) <br>        { <br>            *pdwFlags &amp;= ~FILTER_STATUS_OPAQUE; <br>        } <br>    } <br>    return hr; <br>} <br> <br>STDMETHODIMP CGlassControl::SetPosition(LPCRECT prc) <br>{ <br>    m_rc = *prc; <br> <br>    if (m_pSource) <br>    { <br>        return m_pSource-&gt;SetPosition(prc); <br>    } <br>    return S_OK; <br>} <br> <br>STDMETHODIMP CGlassControl::Draw(HDC hdc, LPCRECT prcBounds) <br>{ <br>    HRESULT         hr; <br>    ATL_DRAWINFO    di; <br>     <br>    if (m_pSource == 0) <br>        return VIEW_E_DRAW; <br>     <br>    if (prcBounds == 0) <br>        return E_POINTER; <br>     <br>    // fill the hdc with the element we are attached to <br>    hr = m_pSource-&gt;Draw(hdc, prcBounds); <br>    if ( FAILED(hr) || !m_state.fEnabled ) <br>        return hr; <br> <br>    // Just Call through to OnDraw, but first fill in ATL_DRAWINFO <br>    // struct with bare info <br>    di.cbSize = sizeof(di); <br>    di.hicTargetDev = hdc; <br>    di.hdcDraw = hdc; <br>    memcpy( &amp;(di.prcBounds), &amp;prcBounds, sizeof(RECT) ); <br>    memcpy( &amp;(di.prcWBounds), &amp;prcBounds, sizeof(RECT) ); <br>    di.bOptimize = FALSE; <br>    di.bZoomed = FALSE; <br>    hr = OnDraw(di); <br>    return hr; <br>     <br>} <br> <br>STDMETHODIMP CGlassControl::InvalidateRect(LPCRECT prc, BOOL fErase) <br>{ <br>    if (m_pSite) <br>        return m_pSite-&gt;InvalidateRect(prc, fErase); <br>    return S_OK; <br>} <br> <br>STDMETHODIMP CGlassControl::InvalidateRgn(HRGN hrgn, BOOL fErase) <br>{ <br>    if (m_pSite) <br>        return m_pSite-&gt;InvalidateRgn(hrgn, fErase); <br>    return S_OK; <br>} <br> <br>STDMETHODIMP CGlassControl::GetDC(LPCRECT prc, DWORD dwFlags, HDC *phdc) <br>{ <br>    // THIS SAMPLE IS JUST IGNORING THIS FOR NOW! <br>    // can either return E_NOTIMPL or go thru site for default behavior <br>    if (m_pSite) <br>        return m_pSite-&gt;GetDC(prc, dwFlags, phdc); <br>    return E_NOTIMPL; <br>} <br> <br>STDMETHODIMP CGlassControl::ReleaseDC(HDC hdc) <br>{ <br>    // THIS SAMPLE IS JUST IGNORING THIS FOR NOW! <br>    // can either return E_NOTIMPL or go thru site for default behavior <br>    if (m_pSite) <br>        return m_pSite-&gt;ReleaseDC(hdc); <br>    return E_NOTIMPL; <br>} <br> <br>STDMETHODIMP CGlassControl::OnStatusBitsChange(DWORD dwFlags) <br>{ <br>    HRESULT hr = S_OK; <br>    if (m_pSite) <br>    { <br>        dwFlags &amp;= ~FILTER_STATUS_OPAQUE; <br>        hr = m_pSite-&gt;OnStatusBitsChange(dwFlags); <br>    } <br>    return hr; <br>} <br> <br>// <br>// ICSSFilter interface method implementations <br>// This is for making the Glass control a CSS filter <br>// <br> <br>STDMETHODIMP CGlassControl::SetSite(ICSSFilterSite *pSite) <br>{ <br>    IHTMLElement *pElem = NULL; <br>    IHTMLControlElement *pCtrlElem = NULL; <br>    IUnknown *pUnk = NULL; <br>    HRESULT hr = S_OK; <br>     <br>    if ( m_pCSSSite ) <br>    { <br>        if ( SUCCEEDED(m_pCSSSite-&gt;GetElement( &amp;pElem )) ) <br>        { <br>            if ( SUCCEEDED(pElem-&gt;QueryInterface( IID_IHTMLControlElement,  <br>                                                  (void **)&amp;pCtrlElem )) ) <br>            { <br>                ControlQueryInterface( IID_IUnknown, (void **)&amp;pUnk ); <br>                hr = pCtrlElem-&gt;removeFilter( pUnk ); <br>            } <br>        } <br>        m_pCSSSite-&gt;Release(); <br>    } <br> <br>m_pCSSSite = pSite; <br> <br>if ( m_pCSSSite ) <br>{ <br>m_pCSSSite-&gt;AddRef(); <br> <br>        // hook up with IViewFilter stuff now. <br>        if ( SUCCEEDED(hr=m_pCSSSite-&gt;GetElement( &amp;pElem )) ) <br>        { <br>            if ( SUCCEEDED(hr=pElem-&gt;QueryInterface( IID_IHTMLControlElement,  <br>                                                     (void **)&amp;pCtrlElem )) ) <br>            { <br>                hr = ControlQueryInterface( IID_IUnknown, (void **)&amp;pUnk ); <br>                hr = pCtrlElem-&gt;addFilter( pUnk ); <br>            } <br>        } <br>        if ( FAILED(hr) ) <br>            goto error; <br>    } <br> <br>cleanup: <br>    if ( pUnk ) <br>        pUnk-&gt;Release(); <br>    if ( pCtrlElem ) <br>        pCtrlElem-&gt;Release(); <br>    if ( pElem ) <br>        pElem-&gt;Release(); <br> <br>return hr; <br> <br>error: <br>    // Sorry, if I can't connect with a Site, I don't connect at all <br>    if ( m_pCSSSite ) <br>    { <br>        m_pCSSSite-&gt;Release(); <br>        m_pCSSSite = NULL; <br>    } <br>    goto cleanup; <br>} <br> <br>STDMETHODIMP CGlassControl::OnAmbientPropertyChange( DISPID dispid ) <br>{ <br>    return E_NOTIMPL; <br>} <br> <br>// <br>// IPersistPropertyBag overrides <br>// <br> <br>STDMETHODIMP CGlassControl::Load( IPropertyBag *pPropBag, IErrorLog *pErrorLog ) <br>{ <br>    _variant_t  vBrightness; <br>    HRESULT hr = pPropBag-&gt;Read(L"brightness", &amp;vBrightness, NULL); <br>    if (SUCCEEDED(hr)) <br>    { <br>        m_state.Brightness = (long)vBrightness; <br>    } <br> <br>_variant_t vEnabled; <br>hr = pPropBag-&gt;Read(L"enabled", &amp;vEnabled, NULL); <br>    if (SUCCEEDED(hr)) <br>    { <br>        m_state.fEnabled = (bool)vEnabled; <br>    } <br>    return S_OK; <br>} <br> <br>// <br>// IObjectSafety overrides <br>// <br> <br>STDMETHODIMP  <br>CGlassControl::GetInterfaceSafetyOptions( REFIID riid,  <br>                                          DWORD *pdwSupportedOptions,  <br>                                          DWORD *pdwEnabledOptions ) <br>{ <br>    HRESULT hr; <br> <br>    if ( pdwSupportedOptions == NULL || pdwEnabledOptions == NULL )  <br>        return E_POINTER; <br> <br>if ( riid == IID_IDispatch ) <br>    { <br>        *pdwSupportedOptions = INTERFACESAFE_FOR_UNTRUSTED_CALLER; <br>        *pdwEnabledOptions = m_dwSafety &amp; INTERFACESAFE_FOR_UNTRUSTED_CALLER; <br>    } <br>    else if ( riid == IID_IPersistPropertyBag ) <br>    { <br>        *pdwSupportedOptions = INTERFACESAFE_FOR_UNTRUSTED_DATA; <br>        *pdwEnabledOptions = m_dwSafety &amp; INTERFACESAFE_FOR_UNTRUSTED_DATA; <br>    } <br>    else <br>    { <br>        IUnknown *pUnk; <br>        *pdwSupportedOptions = 0; <br>        *pdwEnabledOptions = 0; <br>        hr = _InternalQueryInterface(riid, (void**)&amp;pUnk); <br>        if ( SUCCEEDED(hr) ) { <br>            pUnk-&gt;Release(); <br>            hr = E_FAIL; <br>        } <br>    } <br>    return hr; <br>} <br> <br>STDMETHODIMP <br>CGlassControl::SetInterfaceSafetyOptions( REFIID riid,  <br>                                          DWORD dwOptionSetMask,  <br>                                          DWORD dwEnabledOptions ) <br>{ <br>    HRESULT hr = S_OK; <br>    // If we're being asked to set our safe for initializing or  <br>    // scripting option then oblige <br>    if ( riid == IID_IDispatch ) <br>    { <br>        // Store our current safety level to return in GetInterfaceSafetyOptions <br>        m_dwSafety = dwEnabledOptions &amp; dwOptionSetMask; <br>    } <br>    else if ( riid == IID_IPersistPropertyBag ) <br>    { <br>        // Store our current safety level to return in GetInterfaceSafetyOptions <br>        m_dwSafety = dwEnabledOptions &amp; dwOptionSetMask; <br>    } <br>    else <br>    { <br>        IUnknown *pUnk; <br>        hr = _InternalQueryInterface(riid, (void**)&amp;pUnk); <br>        if ( SUCCEEDED(hr) ) { <br>            pUnk-&gt;Release(); <br>            hr = E_FAIL; <br>        } <br>    } <br>    return hr; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
