<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>ATLWIN.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3881"></a>ATLWIN.CPP</h2>
<pre><code>// This is a part of the Active Template Library. <br>// Copyright (C) 1996-1997 Microsoft Corporation <br>// All rights reserved. <br>// <br>// This source code is only intended as a supplement to the <br>// Active Template Library Reference and related <br>// electronic documentation provided with the library. <br>// See these sources for detailed information regarding the <br>// Active Template Library product. <br> <br>#ifndef __ATLWIN_H__ <br>#error atlwin.cpp requires atlwin.h to be included first <br>#endif <br> <br>#ifndef ATL_NO_NAMESPACE <br>namespace ATL <br>{ <br>#endif <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// CWndProcThunk <br> <br>void CWndProcThunk::Init(WNDPROC proc, void* pThis) <br>{ <br>#if defined(_M_PPC) <br>#error PPC not yet implemented <br>#elif defined (_M_ALPHA) <br>thunk.ldah_at = 0x279f0000 | HIWORD(proc); <br>thunk.ldah_a0 = 0x261f0000 | HIWORD(pThis); <br>thunk.lda_at = 0x239c0000 | LOWORD(proc); <br>thunk.lda_a0 = 0x22100000 | LOWORD(pThis); <br>thunk.jmp = 0x6bfc0000; <br>#elif defined (_M_IX86) <br>thunk.m_mov = 0xb9; <br>thunk.m_this = (DWORD)pThis; <br>thunk.m_jmp = 0xe9; <br>thunk.m_relproc = (int)proc - ((int)this+sizeof(_WndProcThunk)); <br>#endif <br>} <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// CWindow <br> <br>HWND CWindow::GetDescendantWindow(int nID) const <br>{ <br>_ASSERTE(::IsWindow(m_hWnd)); <br> <br>// GetDlgItem recursive (return first found) <br>// breadth-first for 1 level, then depth-first for next level <br> <br>// use GetDlgItem since it is a fast USER function <br>HWND hWndChild, hWndTmp; <br>CWindow wnd; <br>if((hWndChild = ::GetDlgItem(m_hWnd, nID)) != NULL) <br>{ <br>if(::GetTopWindow(hWndChild) != NULL) <br>{ <br>// children with the same ID as their parent have priority <br>wnd.Attach(hWndChild); <br>hWndTmp = wnd.GetDescendantWindow(nID); <br>if(hWndTmp != NULL) <br>return hWndTmp; <br>} <br>return hWndChild; <br>} <br> <br>// walk each child <br>for(hWndChild = ::GetTopWindow(m_hWnd); hWndChild != NULL; <br>hWndChild = ::GetNextWindow(hWndChild, GW_HWNDNEXT)) <br>{ <br>wnd.Attach(hWndChild); <br>hWndTmp = wnd.GetDescendantWindow(nID); <br>if(hWndTmp != NULL) <br>return hWndTmp; <br>} <br> <br>return NULL;    // not found <br>} <br> <br>void CWindow::SendMessageToDescendants(UINT message, WPARAM wParam/*= 0*/, LPARAM lParam/*= 0*/, BOOL bDeep/* = TRUE*/) <br>{ <br>CWindow wnd; <br>for(HWND hWndChild = ::GetTopWindow(m_hWnd); hWndChild != NULL; <br>hWndChild = ::GetNextWindow(hWndChild, GW_HWNDNEXT)) <br>{ <br>::SendMessage(hWndChild, message, wParam, lParam); <br> <br>if(bDeep &amp;&amp; ::GetTopWindow(hWndChild) != NULL) <br>{ <br>// send to child windows after parent <br>wnd.Attach(hWndChild); <br>wnd.SendMessageToDescendants(message, wParam, lParam, bDeep); <br>} <br>} <br>} <br> <br>BOOL CWindow::CenterWindow(HWND hWndCenter/* = NULL*/) <br>{ <br>_ASSERTE(::IsWindow(m_hWnd)); <br> <br>// determine owner window to center against <br>DWORD dwStyle = GetStyle(); <br>if(hWndCenter == NULL) <br>{ <br>if(dwStyle &amp; WS_CHILD) <br>hWndCenter = ::GetParent(m_hWnd); <br>else <br>hWndCenter = ::GetWindow(m_hWnd, GW_OWNER); <br>} <br> <br>// get coordinates of the window relative to its parent <br>RECT rcDlg; <br>::GetWindowRect(m_hWnd, &amp;rcDlg); <br>RECT rcArea; <br>RECT rcCenter; <br>HWND hWndParent; <br>if(!(dwStyle &amp; WS_CHILD)) <br>{ <br>// don't center against invisible or minimized windows <br>if(hWndCenter != NULL) <br>{ <br>DWORD dwStyle = ::GetWindowLong(hWndCenter, GWL_STYLE); <br>if(!(dwStyle &amp; WS_VISIBLE) || (dwStyle &amp; WS_MINIMIZE)) <br>hWndCenter = NULL; <br>} <br> <br>// center within screen coordinates <br>::SystemParametersInfo(SPI_GETWORKAREA, NULL, &amp;rcArea, NULL); <br> <br>if(hWndCenter == NULL) <br>rcCenter = rcArea; <br>else <br>::GetWindowRect(hWndCenter, &amp;rcCenter); <br>} <br>else <br>{ <br>// center within parent client coordinates <br>hWndParent = ::GetParent(m_hWnd); <br>_ASSERTE(::IsWindow(hWndParent)); <br> <br>::GetClientRect(hWndParent, &amp;rcArea); <br>_ASSERTE(::IsWindow(hWndCenter)); <br>::GetClientRect(hWndCenter, &amp;rcCenter); <br>::MapWindowPoints(hWndCenter, hWndParent, (POINT*)&amp;rcCenter, 2); <br>} <br> <br>int DlgWidth = rcDlg.right - rcDlg.left; <br>int DlgHeight = rcDlg.bottom - rcDlg.top; <br> <br>// find dialog's upper left based on rcCenter <br>int xLeft = (rcCenter.left + rcCenter.right) / 2 - DlgWidth / 2; <br>int yTop = (rcCenter.top + rcCenter.bottom) / 2 - DlgHeight / 2; <br> <br>// if the dialog is outside the screen, move it inside <br>if(xLeft &lt; rcArea.left) <br>xLeft = rcArea.left; <br>else if(xLeft + DlgWidth &gt; rcArea.right) <br>xLeft = rcArea.right - DlgWidth; <br> <br>if(yTop &lt; rcArea.top) <br>yTop = rcArea.top; <br>else if(yTop + DlgHeight &gt; rcArea.bottom) <br>yTop = rcArea.bottom - DlgHeight; <br> <br>// map screen coordinates to child coordinates <br>return ::SetWindowPos(m_hWnd, NULL, xLeft, yTop, -1, -1, <br>SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE); <br>} <br> <br>BOOL CWindow::ModifyStyle(DWORD dwRemove, DWORD dwAdd, UINT nFlags) <br>{ <br>_ASSERTE(::IsWindow(m_hWnd)); <br> <br>DWORD dwStyle = ::GetWindowLong(m_hWnd, GWL_STYLE); <br>DWORD dwNewStyle = (dwStyle &amp; ~dwRemove) | dwAdd; <br>if(dwStyle == dwNewStyle) <br>return FALSE; <br> <br>::SetWindowLong(m_hWnd, GWL_STYLE, dwNewStyle); <br>if(nFlags != 0) <br>{ <br>::SetWindowPos(m_hWnd, NULL, 0, 0, 0, 0, <br>SWP_NOSIZE | SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE | nFlags); <br>} <br> <br>return TRUE; <br>} <br> <br>BOOL CWindow::ModifyStyleEx(DWORD dwRemove, DWORD dwAdd, UINT nFlags) <br>{ <br>_ASSERTE(::IsWindow(m_hWnd)); <br> <br>DWORD dwStyle = ::GetWindowLong(m_hWnd, GWL_EXSTYLE); <br>DWORD dwNewStyle = (dwStyle &amp; ~dwRemove) | dwAdd; <br>if(dwStyle == dwNewStyle) <br>return FALSE; <br> <br>::SetWindowLong(m_hWnd, GWL_EXSTYLE, dwNewStyle); <br>if(nFlags != 0) <br>{ <br>::SetWindowPos(m_hWnd, NULL, 0, 0, 0, 0, <br>SWP_NOSIZE | SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE | nFlags); <br>} <br> <br>return TRUE; <br>} <br> <br>BOOL CWindow::GetWindowText(BSTR&amp; bstrText) <br>{ <br>USES_CONVERSION; <br>_ASSERTE(::IsWindow(m_hWnd)); <br> <br>int nLen = ::GetWindowTextLength(m_hWnd); <br>if(nLen == 0) <br>return FALSE; <br> <br>LPTSTR lpszText = (LPTSTR)_alloca((nLen+1)*sizeof(TCHAR)); <br> <br>if(!::GetWindowText(m_hWnd, lpszText, nLen+1)) <br>return FALSE; <br> <br>bstrText = ::SysAllocString(T2OLE(lpszText)); <br> <br>return (bstrText != NULL) ? TRUE : FALSE; <br>} <br> <br>HWND CWindow::GetTopLevelParent() const <br>{ <br>_ASSERTE(::IsWindow(m_hWnd)); <br> <br>HWND hWndParent = m_hWnd; <br>HWND hWndTmp; <br>while((hWndTmp = ::GetParent(hWndParent)) != NULL) <br>hWndParent = hWndTmp; <br> <br>return hWndParent; <br>} <br> <br>HWND CWindow::GetTopLevelWindow() const <br>{ <br>_ASSERTE(::IsWindow(m_hWnd)); <br> <br>HWND hWndParent = m_hWnd; <br>HWND hWndTmp = hWndParent; <br> <br>while(hWndTmp != NULL) <br>{ <br>hWndTmp = (::GetWindowLong(hWndParent, GWL_STYLE) &amp; WS_CHILD) ? ::GetParent(hWndParent) : ::GetWindow(hWndParent, GW_OWNER); <br>hWndParent = hWndTmp; <br>} <br> <br>return hWndParent; <br>} <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// CDynamicChain <br> <br>CDynamicChain::~CDynamicChain() <br>{ <br>if(m_pChainEntry != NULL) <br>{ <br>for(int i = 0; i &lt; m_nEntries; i++) <br>{ <br>if(m_pChainEntry[i] != NULL) <br>delete m_pChainEntry[i]; <br>} <br> <br>delete [] m_pChainEntry; <br>} <br>} <br> <br>BOOL CDynamicChain::SetChainEntry(DWORD dwChainID, CMessageMap* pObject, DWORD dwMsgMapID /* = 0 */) <br>{ <br>// first search for an existing entry <br> <br>for(int i = 0; i &lt; m_nEntries; i++) <br>{ <br>if(m_pChainEntry[i] != NULL &amp;&amp; m_pChainEntry[i]-&gt;m_dwChainID == dwChainID) <br>{ <br>m_pChainEntry[i]-&gt;m_pObject = pObject; <br>m_pChainEntry[i]-&gt;m_dwMsgMapID = dwMsgMapID; <br>return TRUE; <br>} <br>} <br> <br>// create a new one <br> <br>ATL_CHAIN_ENTRY* pEntry = NULL; <br>ATLTRY(pEntry = new ATL_CHAIN_ENTRY); <br> <br>if(pEntry == NULL) <br>return FALSE; <br> <br>// search for an empty one <br> <br>for(i = 0; i &lt; m_nEntries; i++) <br>{ <br>if(m_pChainEntry[i] == NULL) <br>{ <br>m_pChainEntry[i] = pEntry; <br>return TRUE; <br>} <br>} <br> <br>// add a new one <br> <br>ATL_CHAIN_ENTRY** ppNew = NULL; <br>ATLTRY(ppNew = new ATL_CHAIN_ENTRY*[m_nEntries + 1]); <br> <br>if(ppNew == NULL) <br>{ <br>delete pEntry; <br>return FALSE; <br>} <br> <br>pEntry-&gt;m_dwChainID = dwChainID; <br>pEntry-&gt;m_pObject = pObject; <br>pEntry-&gt;m_dwMsgMapID = dwMsgMapID; <br> <br>if(m_pChainEntry != NULL) <br>{ <br>memcpy(ppNew, m_pChainEntry, m_nEntries * sizeof(ATL_CHAIN_ENTRY*)); <br>delete [] m_pChainEntry; <br>} <br> <br>m_pChainEntry = ppNew; <br> <br>m_pChainEntry[m_nEntries] = pEntry; <br> <br>m_nEntries++; <br> <br>return TRUE; <br>} <br> <br>BOOL CDynamicChain::RemoveChainEntry(DWORD dwChainID) <br>{ <br>for(int i = 0; i &lt; m_nEntries; i++) <br>{ <br>if(m_pChainEntry[i] != NULL &amp;&amp; m_pChainEntry[i]-&gt;m_dwChainID == dwChainID) <br>{ <br>delete m_pChainEntry[i]; <br>m_pChainEntry[i] = NULL; <br>return TRUE; <br>} <br>} <br> <br>return FALSE; <br>} <br> <br>BOOL CDynamicChain::CallChain(DWORD dwChainID, HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT&amp; lResult) <br>{ <br>for(int i = 0; i &lt; m_nEntries; i++) <br>{ <br>if(m_pChainEntry[i] != NULL &amp;&amp; m_pChainEntry[i]-&gt;m_dwChainID == dwChainID) <br>return (m_pChainEntry[i]-&gt;m_pObject)-&gt;ProcessWindowMessage(hWnd, uMsg, wParam, lParam, lResult, m_pChainEntry[i]-&gt;m_dwMsgMapID); <br>} <br> <br>return FALSE; <br>} <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// CWndClassInfo <br> <br>ATOM CWndClassInfo::Register(WNDPROC* pProc) <br>{ <br>if (m_atom == 0) <br>{ <br>::EnterCriticalSection(&amp;_Module.m_csWindowCreate); <br>if(m_atom == 0) <br>{ <br>HINSTANCE hInst = _Module.GetModuleInstance(); <br>if (m_lpszOrigName != NULL) <br>{ <br>_ASSERTE(pProc != NULL); <br>LPCTSTR lpsz = m_wc.lpszClassName; <br>WNDPROC proc = m_wc.lpfnWndProc; <br> <br>WNDCLASSEX wc; <br>wc.cbSize = sizeof(WNDCLASSEX); <br>if(!::GetClassInfoEx(NULL, m_lpszOrigName, &amp;wc)) <br>{ <br>::LeaveCriticalSection(&amp;_Module.m_csWindowCreate); <br>return 0; <br>} <br>memcpy(&amp;m_wc, &amp;wc, sizeof(WNDCLASSEX)); <br>pWndProc = m_wc.lpfnWndProc; <br>m_wc.lpszClassName = lpsz; <br>m_wc.lpfnWndProc = proc; <br>} <br>else <br>{ <br>m_wc.hCursor = ::LoadCursor(m_bSystemCursor ? NULL : hInst, <br>m_lpszCursorID); <br>} <br> <br>m_wc.hInstance = hInst; <br>if (m_wc.lpszClassName == NULL) <br>{ <br>wsprintf(m_szAutoName, _T("ATL:%8.8X"), (DWORD)&amp;m_wc); <br>m_wc.lpszClassName = m_szAutoName; <br>} <br>WNDCLASSEX wcTemp; <br>memcpy(&amp;wcTemp, &amp;m_wc, sizeof(WNDCLASSEX)); <br>m_atom = ::GetClassInfoEx(m_wc.hInstance, m_szAutoName, &amp;wcTemp); <br>if (m_atom == 0) <br>m_atom = ::RegisterClassEx(&amp;m_wc); <br>} <br>::LeaveCriticalSection(&amp;_Module.m_csWindowCreate); <br>} <br> <br>if (m_lpszOrigName != NULL) <br>{ <br>_ASSERTE(pProc != NULL); <br>_ASSERTE(pWndProc != NULL); <br>*pProc = pWndProc; <br>} <br>return m_atom; <br>} <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// CWindowImpl <br> <br>LRESULT CALLBACK CWindowImplBase::StartWindowProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam) <br>{ <br>CWindowImplBase* pT = (CWindowImplBase*)_Module.ExtractCreateWndData(); <br>_ASSERTE(pT != NULL); <br>pT-&gt;m_hWnd = hWnd; <br>pT-&gt;m_thunk.Init(WindowProc, pT); <br>WNDPROC pProc = (WNDPROC)&amp;(pT-&gt;m_thunk.thunk); <br>::SetWindowLong(hWnd, GWL_WNDPROC, (LONG)pProc); <br>// if somebody has subclassed us already we can't do anything, <br>// so discard return value from SetWindowLong <br>return pProc(hWnd, uMsg, wParam, lParam); <br>} <br> <br>LRESULT CALLBACK CWindowImplBase::WindowProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam) <br>{ <br>#ifdef _M_IX86 <br>__asm mov dword ptr[hWnd], ecx <br>#endif <br>CWindowImplBase* pT = (CWindowImplBase*)hWnd; <br>LRESULT lRes; <br>BOOL bRet = pT-&gt;ProcessWindowMessage(pT-&gt;m_hWnd, uMsg, wParam, lParam, lRes, 0); <br>if(uMsg == WM_NCDESTROY) <br>pT-&gt;m_hWnd = NULL; <br>if(bRet) <br>return lRes; <br>return pT-&gt;DefWindowProc(uMsg, wParam, lParam); <br>} <br> <br>HWND CWindowImplBase::Create(HWND hWndParent, RECT&amp; rcPos, LPCTSTR szWindowName, <br>DWORD dwStyle, DWORD dwExStyle, UINT nID, ATOM atom) <br>{ <br>_ASSERTE(m_hWnd == NULL); <br> <br>if(atom == 0) <br>return NULL; <br> <br>_Module.AddCreateWndData(&amp;m_thunk.cd, this); <br> <br>if(nID == 0 &amp;&amp; (dwStyle &amp; WS_CHILD)) <br>nID = (UINT)this; <br> <br>HWND hWnd = ::CreateWindowEx(dwExStyle, (LPCTSTR)MAKELONG(atom, 0), szWindowName, <br>dwStyle, rcPos.left, rcPos.top, rcPos.right - rcPos.left, <br>rcPos.bottom - rcPos.top, hWndParent, (HMENU)nID, <br>_Module.GetModuleInstance(), NULL); <br> <br>_ASSERTE(m_hWnd == hWnd); <br> <br>return hWnd; <br>} <br> <br>BOOL CWindowImplBase::SubclassWindow(HWND hWnd) <br>{ <br>_ASSERTE(m_hWnd == NULL); <br>_ASSERTE(::IsWindow(hWnd)); <br>m_thunk.Init(WindowProc, this); <br>WNDPROC pProc = (WNDPROC)&amp;(m_thunk.thunk); <br>WNDPROC pfnWndProc = (WNDPROC)::SetWindowLong(hWnd, GWL_WNDPROC, (LONG)pProc); <br>if(pfnWndProc == NULL) <br>return FALSE; <br>m_pfnSuperWindowProc = pfnWndProc; <br>m_hWnd = hWnd; <br>return TRUE; <br>} <br> <br>HWND CWindowImplBase::UnsubclassWindow() <br>{ <br>_ASSERTE(m_hWnd != NULL); <br> <br>if(!::SetWindowLong(m_hWnd, GWL_WNDPROC, (LONG)m_pfnSuperWindowProc)) <br>return NULL; <br> <br>m_pfnSuperWindowProc = ::DefWindowProc; <br> <br>HWND hWnd = m_hWnd; <br>m_hWnd = NULL; <br> <br>return hWnd; <br>} <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// CDialogImplBase <br> <br>LRESULT CALLBACK CDialogImplBase::StartDialogProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam) <br>{ <br>CDialogImplBase* pT = (CDialogImplBase*)_Module.ExtractCreateWndData(); <br>_ASSERTE(pT != NULL); <br>pT-&gt;m_hWnd = hWnd; <br>pT-&gt;m_thunk.Init(DialogProc, pT); <br>WNDPROC pProc = (WNDPROC)&amp;(pT-&gt;m_thunk.thunk); <br>WNDPROC pOldProc = (WNDPROC)::SetWindowLong(hWnd, DWL_DLGPROC, (LONG)pProc); <br>// check if somebody has subclassed us already since we don't hold onto it <br>ATLTRACE(_T("Subclassing through a hook discarded.\n")); <br>return pProc(hWnd, uMsg, wParam, lParam); <br>} <br> <br>LRESULT CALLBACK CDialogImplBase::DialogProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam) <br>{ <br>#ifdef _M_IX86 <br>__asm mov dword ptr[hWnd], ecx <br>#endif <br>CDialogImplBase* pT = (CDialogImplBase*)hWnd; <br>LRESULT lRes; <br>if(pT-&gt;ProcessWindowMessage(pT-&gt;m_hWnd, uMsg, wParam, lParam, lRes, 0)) <br>{ <br>switch (uMsg) <br>{ <br>case WM_COMPAREITEM: <br>case WM_VKEYTOITEM: <br>case WM_CHARTOITEM: <br>case WM_INITDIALOG: <br>case WM_QUERYDRAGICON: <br>return lRes; <br>break; <br>} <br>if (lRes != 0) <br>::SetWindowLong(pT-&gt;m_hWnd, DWL_MSGRESULT, lRes); <br>return TRUE; <br>} <br>return FALSE; <br>} <br> <br>BOOL CDialogImplBase::EndDialog(int nRetCode) <br>{ <br>_ASSERTE(m_hWnd); <br>return ::EndDialog(m_hWnd, nRetCode); <br>} <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// CContainedWindow <br> <br>LRESULT CALLBACK CContainedWindow::StartWindowProc(HWND hWnd, UINT uMsg, <br>WPARAM wParam, LPARAM lParam) <br>{ <br>CContainedWindow* pThis = (CContainedWindow*)_Module.ExtractCreateWndData(); <br>_ASSERTE(pThis != NULL); <br>pThis-&gt;m_hWnd = hWnd; <br>pThis-&gt;m_thunk.Init(pThis-&gt;WindowProc, pThis); <br>WNDPROC pProc = (WNDPROC)&amp;(pThis-&gt;m_thunk.thunk); <br>WNDPROC pOldProc = (WNDPROC)::SetWindowLong(hWnd, GWL_WNDPROC, (LONG)pProc); <br>// check if somebody has subclassed us already since we don't hold onto it <br>ATLTRACE(_T("Subclassing through a hook discarded.\n")); <br>return pProc(hWnd, uMsg, wParam, lParam); <br>} <br> <br>LRESULT CALLBACK CContainedWindow::WindowProc(HWND hWnd, UINT uMsg, WPARAM wParam, <br>LPARAM lParam) <br>{ <br>#ifdef _M_IX86 <br>__asm mov dword ptr[hWnd], ecx <br>#endif <br>CContainedWindow* pT = (CContainedWindow*)hWnd; <br>_ASSERTE(pT-&gt;m_hWnd != NULL); <br>_ASSERTE(pT-&gt;m_pObject != NULL); <br> <br>LRESULT lRes; <br>BOOL bRet = pT-&gt;m_pObject-&gt;ProcessWindowMessage(pT-&gt;m_hWnd, uMsg, wParam, lParam, lRes, pT-&gt;m_dwMsgMapID); <br>if(uMsg == WM_NCDESTROY) <br>pT-&gt;m_hWnd = NULL; <br>if(bRet) <br>return lRes; <br>return pT-&gt;DefWindowProc(uMsg, wParam, lParam); <br>} <br> <br>ATOM CContainedWindow::RegisterWndSuperclass() <br>{ <br>ATOM atom = 0; <br>LPTSTR szBuff = (LPTSTR)_alloca((lstrlen(m_lpszClassName) + 14) * sizeof(TCHAR)); <br> <br>WNDCLASSEX wc; <br>wc.cbSize = sizeof(WNDCLASSEX); <br> <br>if(::GetClassInfoEx(NULL, m_lpszClassName, &amp;wc)) <br>{ <br>m_pfnSuperWindowProc = wc.lpfnWndProc; <br> <br>wsprintf(szBuff, _T("ATL:%s"), m_lpszClassName); <br> <br>WNDCLASSEX wc1; <br>wc1.cbSize = sizeof(WNDCLASSEX); <br>atom = (ATOM)::GetClassInfoEx(_Module.GetModuleInstance(), szBuff, &amp;wc1); <br> <br>if(atom == 0)   // register class <br>{ <br>wc.lpszClassName = szBuff; <br>wc.lpfnWndProc = StartWindowProc; <br>wc.hInstance = _Module.GetModuleInstance(); <br> <br>atom = ::RegisterClassEx(&amp;wc); <br>} <br>} <br> <br>return atom; <br>} <br> <br>HWND CContainedWindow::Create(HWND hWndParent, RECT&amp; rcPos, <br>LPCTSTR szWindowName, DWORD dwStyle, DWORD dwExStyle, UINT nID) <br>{ <br>_ASSERTE(m_hWnd == NULL); <br> <br>ATOM atom = RegisterWndSuperclass(); <br>if(atom == 0) <br>return NULL; <br> <br>_Module.AddCreateWndData(&amp;m_thunk.cd, this); <br> <br>if(nID == 0 &amp;&amp; (dwStyle &amp; WS_CHILD)) <br>nID = (UINT)this; <br> <br>HWND hWnd = ::CreateWindowEx(dwExStyle, (LPCTSTR)MAKELONG(atom, 0), szWindowName, <br>dwStyle, <br>rcPos.left, rcPos.top, <br>rcPos.right - rcPos.left, <br>rcPos.bottom - rcPos.top, <br>hWndParent, (HMENU)nID, <br>_Module.GetModuleInstance(), this); <br> <br>_ASSERTE(m_hWnd == hWnd); <br>return hWnd; <br>} <br> <br>BOOL CContainedWindow::SubclassWindow(HWND hWnd) <br>{ <br>_ASSERTE(m_hWnd == NULL); <br>_ASSERTE(::IsWindow(hWnd)); <br> <br>m_thunk.Init(WindowProc, this); <br>WNDPROC pProc = (WNDPROC)&amp;m_thunk.thunk; <br>WNDPROC pfnWndProc = (WNDPROC)::SetWindowLong(hWnd, GWL_WNDPROC, (LONG)pProc); <br>if(pfnWndProc == NULL) <br>return FALSE; <br>m_pfnSuperWindowProc = pfnWndProc; <br>m_hWnd = hWnd; <br>return TRUE; <br>} <br> <br>HWND CContainedWindow::UnsubclassWindow() <br>{ <br>_ASSERTE(m_hWnd != NULL); <br> <br>if(!::SetWindowLong(m_hWnd, GWL_WNDPROC, (LONG)m_pfnSuperWindowProc)) <br>return NULL; <br>m_pfnSuperWindowProc = ::DefWindowProc; <br> <br>HWND hWnd = m_hWnd; <br>m_hWnd = NULL; <br> <br>return hWnd; <br>} <br> <br>#ifndef ATL_NO_NAMESPACE <br>}; //namespace ATL <br>#endif <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//All Global stuff goes below this line <br>/////////////////////////////////////////////////////////////////////////////// </code></pre>
<p>&nbsp;</p></body>
</HTML>
