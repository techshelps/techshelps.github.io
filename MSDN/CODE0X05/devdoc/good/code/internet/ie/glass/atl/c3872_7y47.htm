<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>ATLCTL.H</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3877"></a>ATLCTL.H</h2>
<pre><code>// This is a part of the Active Template Library. <br>// Copyright (C) 1996-1997 Microsoft Corporation <br>// All rights reserved. <br>// <br>// This source code is only intended as a supplement to the <br>// Active Template Library Reference and related <br>// electronic documentation provided with the library. <br>// See these sources for detailed information regarding the <br>// Active Template Library product. <br> <br>#ifndef __ATLCTL_H__ <br>#define __ATLCTL_H__ <br> <br>#ifndef __cplusplus <br>#error ATL requires C++ compilation (use a .cpp suffix) <br>#endif <br> <br>#include &lt;atlwin.h&gt; <br>#include &lt;objsafe.h&gt; <br>#include &lt;urlmon.h&gt; <br> <br>#pragma comment(lib, "gdi32.lib") <br>#pragma comment(lib, "urlmon.lib") <br> <br>ATLAPI_(void) AtlHiMetricToPixel(const SIZEL * lpSizeInHiMetric, LPSIZEL lpSizeInPix); <br>ATLAPI_(void) AtlPixelToHiMetric(const SIZEL * lpSizeInPix, LPSIZEL lpSizeInHiMetric); <br>ATLAPI_(HDC) AtlCreateTargetDC(HDC hdc, DVTARGETDEVICE* ptd); <br> <br>// Include GUIDs for the new stock property dialogs contained in the dll MSStkProp.DLL <br>#include "msstkppg.h" <br>#define CLSID_MSStockFont CLSID_StockFontPage <br>#define CLSID_MSStockColor CLSID_StockColorPage <br>#define CLSID_MSStockPicture CLSID_StockPicturePage <br> <br>#ifndef ATL_NO_NAMESPACE <br>namespace ATL <br>{ <br>#endif <br> <br>#pragma pack(push, _ATL_PACKING) <br> <br>// Forward declarations <br>// <br>class ATL_NO_VTABLE CComControlBase; <br>template &lt;class T&gt; class CComControl; <br>class CComDispatchDriver; <br> <br>struct ATL_PROPMAP_ENTRY <br>{ <br>LPCOLESTR szDesc; <br>DISPID dispid; <br>const CLSID* pclsidPropPage; <br>const IID* piidDispatch; <br> <br>}; <br> <br>struct ATL_DRAWINFO <br>{ <br>UINT cbSize; <br>DWORD dwDrawAspect; <br>LONG lindex; <br>DVTARGETDEVICE* ptd; <br>HDC hicTargetDev; <br>HDC hdcDraw; <br>LPCRECTL prcBounds; //Rectangle in which to draw <br>LPCRECTL prcWBounds; //WindowOrg and Ext if metafile <br>BOOL bOptimize; <br>BOOL bZoomed; <br>BOOL bRectInHimetric; <br>SIZEL ZoomNum;      //ZoomX = ZoomNum.cx/ZoomNum.cy <br>SIZEL ZoomDen; <br>}; <br> <br>////////////////////////////////////////////////////////////////////////////// <br>// CComDispatchDriver / Specialization of CComQIPtr&lt;IDispatch, IID_IDispatch&gt; <br>class CComDispatchDriver <br>{ <br>public: <br>CComDispatchDriver() <br>{ <br>p = NULL; <br>} <br>CComDispatchDriver(IDispatch* lp) <br>{ <br>if ((p = lp) != NULL) <br>p-&gt;AddRef(); <br>} <br>CComDispatchDriver(IUnknown* lp) <br>{ <br>p=NULL; <br>if (lp != NULL) <br>lp-&gt;QueryInterface(IID_IDispatch, (void **)&amp;p); <br>} <br>~CComDispatchDriver() { if (p) p-&gt;Release(); } <br>void Release() {if (p) p-&gt;Release(); p=NULL;} <br>operator IDispatch*() {return p;} <br>IDispatch&amp; operator*() {_ASSERTE(p!=NULL); return *p; } <br>IDispatch** operator&amp;() {_ASSERTE(p==NULL); return &amp;p; } <br>IDispatch* operator-&gt;() {_ASSERTE(p!=NULL); return p; } <br>IDispatch* operator=(IDispatch* lp){return (IDispatch*)AtlComPtrAssign((IUnknown**)&amp;p, lp);} <br>IDispatch* operator=(IUnknown* lp) <br>{ <br>return (IDispatch*)AtlComQIPtrAssign((IUnknown**)&amp;p, lp, IID_IDispatch); <br>} <br>BOOL operator!(){return (p == NULL) ? TRUE : FALSE;} <br> <br>HRESULT GetProperty(DISPID dwDispID, VARIANT* pVar) <br>{ <br>_ASSERTE(p); <br>return GetProperty(p, dwDispID, pVar); <br>} <br>HRESULT PutProperty(DISPID dwDispID, VARIANT* pVar) <br>{ <br>_ASSERTE(p); <br>return PutProperty(p, dwDispID, pVar); <br>} <br> <br>static HRESULT GetProperty(IDispatch* pDisp, DISPID dwDispID, VARIANT* pVar); <br>static HRESULT PutProperty(IDispatch* pDisp, DISPID dwDispID, VARIANT* pVar); <br>IDispatch* p; <br>}; <br> <br>////////////////////////////////////////////////////////////////////////////// <br>// CFirePropNotifyEvent <br>class CFirePropNotifyEvent <br>{ <br>public: <br>static HRESULT FireOnRequestEdit(IUnknown* pUnk, DISPID dispID); <br>static HRESULT FireOnChanged(IUnknown* pUnk, DISPID dispID); <br>}; <br> <br> <br>////////////////////////////////////////////////////////////////////////////// <br>// CFakeFirePropNotifyEvent <br>class CFakeFirePropNotifyEvent <br>{ <br>public: <br>static HRESULT FireOnRequestEdit(IUnknown* /*pUnk*/, DISPID /*dispID*/) <br>{ <br>return S_OK; <br>} <br>static HRESULT FireOnChanged(IUnknown* /*pUnk*/, DISPID /*dispID*/) <br>{ <br>return S_OK; <br>} <br>}; <br> <br> <br>typedef CFakeFirePropNotifyEvent _ATL_PROP_NOTIFY_EVENT_CLASS; <br> <br>////////////////////////////////////////////////////////////////////////////// <br>// CComControl <br>class ATL_NO_VTABLE CComControlBase <br>{ <br>public: <br>CComControlBase(HWND&amp; h) : m_hWndCD(h) <br>{ <br>memset(this, 0, sizeof(CComControlBase)); <br>m_phWndCD = &amp;h; <br>m_sizeExtent.cx = 2*2540; <br>m_sizeExtent.cy = 2*2540; <br>m_sizeNatural = m_sizeExtent; <br>} <br>~CComControlBase() <br>{ <br>if (m_hWndCD != NULL) <br>::DestroyWindow(m_hWndCD); <br>ATLTRACE(_T("Control Destroyed\n")); <br>} <br> <br>// methods <br>public: <br>// Control helper functions can go here <br>// non-virtuals only please <br>void SetDirty(BOOL bDirty) <br>{ <br>m_bRequiresSave = bDirty; <br>} <br>BOOL GetDirty() <br>{ <br>return m_bRequiresSave ? TRUE : FALSE; <br>} <br>void GetZoomInfo(ATL_DRAWINFO&amp; di); <br>HRESULT SendOnRename(IMoniker *pmk) <br>{ <br>HRESULT hRes = S_OK; <br>if (m_spOleAdviseHolder) <br>hRes = m_spOleAdviseHolder-&gt;SendOnRename(pmk); <br>return hRes; <br>} <br>HRESULT SendOnSave() <br>{ <br>HRESULT hRes = S_OK; <br>if (m_spOleAdviseHolder) <br>hRes = m_spOleAdviseHolder-&gt;SendOnSave(); <br>return hRes; <br>} <br>HRESULT SendOnClose() <br>{ <br>HRESULT hRes = S_OK; <br>if (m_spOleAdviseHolder) <br>hRes = m_spOleAdviseHolder-&gt;SendOnClose(); <br>return hRes; <br>} <br>HRESULT SendOnDataChange(DWORD advf = 0); <br>HRESULT SendOnViewChange(DWORD dwAspect, LONG lindex = -1) <br>{ <br>if (m_spAdviseSink) <br>m_spAdviseSink-&gt;OnViewChange(dwAspect, lindex); <br>return S_OK; <br>} <br>LRESULT OnSetFocus(UINT /* nMsg */, WPARAM /* wParam */, LPARAM /* lParam */, BOOL&amp; /* bHandled */) <br>{ <br>CComQIPtr &lt;IOleControlSite, &amp;IID_IOleControlSite&gt; spSite(m_spClientSite); <br>if (m_bInPlaceActive &amp;&amp; spSite) <br>spSite-&gt;OnFocus(TRUE); <br>return 0; <br>} <br> <br>LRESULT OnKillFocus(UINT /* nMsg */, WPARAM /* wParam */, LPARAM /* lParam */, BOOL&amp; /* bHandled */) <br>{ <br>CComQIPtr &lt;IOleControlSite, &amp;IID_IOleControlSite&gt; spSite(m_spClientSite); <br>if (m_bInPlaceActive &amp;&amp; spSite) <br>spSite-&gt;OnFocus(FALSE); <br>return 0; <br>} <br>LRESULT OnGetDlgCode(UINT /* nMsg */, WPARAM /* wParam */, LPARAM /* lParam */, BOOL&amp; /* bHandled */) <br>{ <br>return 0; <br>} <br> <br>HRESULT GetAmbientProperty(DISPID dispid, VARIANT&amp; var) <br>{ <br>HRESULT hRes = E_FAIL; <br>if (m_spAmbientDispatch.p != NULL) <br>hRes = m_spAmbientDispatch.GetProperty(dispid, &amp;var); <br>return hRes; <br>} <br>HRESULT GetAmbientAppearance(short&amp; nAppearance) <br>{ <br>CComVariant var; <br>HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_APPEARANCE, var); <br>_ASSERTE(var.vt == VT_I2 || FAILED(hRes)); <br>nAppearance = var.iVal; <br>return hRes; <br>} <br>HRESULT GetAmbientBackColor(OLE_COLOR&amp; BackColor) <br>{ <br>CComVariant var; <br>HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_BACKCOLOR, var); <br>_ASSERTE(var.vt == VT_I4 || FAILED(hRes)); <br>BackColor = var.lVal; <br>return hRes; <br>} <br>HRESULT GetAmbientDisplayName(BSTR&amp; bstrDiaplayName) <br>{ <br>CComVariant var; <br>HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_DISPLAYNAME, var); <br>_ASSERTE(var.vt == VT_BSTR || FAILED(hRes)); <br>bstrDiaplayName = var.bstrVal; <br>return hRes; <br>} <br>HRESULT GetAmbientFont(IFont** ppFont) <br>{ <br>// caller MUST Release the font! <br>if (ppFont == NULL) <br>return E_POINTER; <br>CComVariant var; <br>HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_FONT, var); <br>_ASSERTE((var.vt == VT_UNKNOWN || var.vt == VT_DISPATCH) || FAILED(hRes)); <br>if (SUCCEEDED(hRes) &amp;&amp; var.pdispVal) <br>{ <br>if (var.vt == VT_UNKNOWN || var.vt == VT_DISPATCH) <br>hRes = var.pdispVal-&gt;QueryInterface(IID_IFont, (void**)ppFont); <br>else <br>hRes = DISP_E_BADVARTYPE; <br>} <br>return hRes; <br>} <br>HRESULT GetAmbientForeColor(OLE_COLOR&amp; ForeColor) <br>{ <br>CComVariant var; <br>HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_FORECOLOR, var); <br>_ASSERTE(var.vt == VT_I4 || FAILED(hRes)); <br>ForeColor = var.lVal; <br>return hRes; <br>} <br>HRESULT GetAmbientLocaleID(LCID&amp; lcid) <br>{ <br>CComVariant var; <br>HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_LOCALEID, var); <br>_ASSERTE(var.vt == VT_I4 || FAILED(hRes)); <br>lcid = var.lVal; <br>return hRes; <br>} <br>HRESULT GetAmbientScaleUnits(BSTR&amp; bstrScaleUnits) <br>{ <br>CComVariant var; <br>HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_SCALEUNITS, var); <br>_ASSERTE(var.vt == VT_BSTR || FAILED(hRes)); <br>bstrScaleUnits = var.bstrVal; <br>return hRes; <br>} <br>HRESULT GetAmbientTextAlign(short&amp; nTextAlign) <br>{ <br>CComVariant var; <br>HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_TEXTALIGN, var); <br>_ASSERTE(var.vt == VT_I2 || FAILED(hRes)); <br>nTextAlign = var.iVal; <br>return hRes; <br>} <br>HRESULT GetAmbientUserMode(BOOL&amp; bUserMode) <br>{ <br>CComVariant var; <br>HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_USERMODE, var); <br>_ASSERTE(var.vt == VT_BOOL || FAILED(hRes)); <br>bUserMode = var.boolVal; <br>return hRes; <br>} <br>HRESULT GetAmbientUIDead(BOOL&amp; bUIDead) <br>{ <br>CComVariant var; <br>HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_UIDEAD, var); <br>_ASSERTE(var.vt == VT_BOOL || FAILED(hRes)); <br>bUIDead = var.boolVal; <br>return hRes; <br>} <br>HRESULT GetAmbientShowGrabHandles(BOOL&amp; bShowGrabHandles) <br>{ <br>CComVariant var; <br>HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_SHOWGRABHANDLES, var); <br>_ASSERTE(var.vt == VT_BOOL || FAILED(hRes)); <br>bShowGrabHandles = var.boolVal; <br>return hRes; <br>} <br>HRESULT GetAmbientShowHatching(BOOL&amp; bShowHatching) <br>{ <br>CComVariant var; <br>HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_SHOWHATCHING, var); <br>_ASSERTE(var.vt == VT_BOOL || FAILED(hRes)); <br>bShowHatching = var.boolVal; <br>return hRes; <br>} <br>HRESULT GetAmbientMessageReflect(BOOL&amp; bMessageReflect) <br>{ <br>CComVariant var; <br>HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_MESSAGEREFLECT, var); <br>_ASSERTE(var.vt == VT_BOOL || FAILED(hRes)); <br>bMessageReflect = var.boolVal; <br>return hRes; <br>} <br>HRESULT GetAmbientAutoClip(BOOL&amp; bAutoClip) <br>{ <br>CComVariant var; <br>HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_AUTOCLIP, var); <br>_ASSERTE(var.vt == VT_BOOL || FAILED(hRes)); <br>bAutoClip = var.boolVal; <br>return hRes; <br>} <br>HRESULT GetAmbientDisplayAsDefault(BOOL&amp; bDisplaysDefault) <br>{ <br>CComVariant var; <br>HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_DISPLAYASDEFAULT, var); <br>_ASSERTE(var.vt == VT_BOOL || FAILED(hRes)); <br>bDisplaysDefault = var.boolVal; <br>return hRes; <br>} <br>HRESULT GetAmbientSupportsMnemonics(BOOL&amp; bSupportMnemonics) <br>{ <br>CComVariant var; <br>HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_SUPPORTSMNEMONICS, var); <br>_ASSERTE(var.vt == VT_BOOL || FAILED(hRes)); <br>bSupportMnemonics = var.boolVal; <br>return hRes; <br>} <br>HRESULT GetAmbientPalette(HPALETTE&amp; hPalette) <br>{ <br>CComVariant var; <br>HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_PALETTE, var); <br>_ASSERTE(var.vt == VT_I4 || FAILED(hRes)); <br>hPalette = reinterpret_cast&lt;HPALETTE&gt;(var.lVal); <br>return hRes; <br>} <br> <br>BOOL DoesVerbUIActivate(LONG iVerb) <br>{ <br>BOOL b = FALSE; <br>switch (iVerb) <br>{ <br>case OLEIVERB_UIACTIVATE: <br>case OLEIVERB_PRIMARY: <br>b = TRUE; <br>break; <br>} <br>// if no ambient dispatch then in old style OLE container <br>if (DoesVerbActivate(iVerb) &amp;&amp; m_spAmbientDispatch.p == NULL) <br>b = TRUE; <br>return b; <br>} <br> <br>BOOL DoesVerbActivate(LONG iVerb) <br>{ <br>BOOL b = FALSE; <br>switch (iVerb) <br>{ <br>case OLEIVERB_UIACTIVATE: <br>case OLEIVERB_PRIMARY: <br>case OLEIVERB_SHOW: <br>case OLEIVERB_INPLACEACTIVATE: <br>b = TRUE; <br>break; <br>} <br>return b; <br>} <br> <br>BOOL SetControlFocus(BOOL bGrab); <br>HRESULT IQuickActivate_QuickActivate(QACONTAINER *pQACont, <br>QACONTROL *pQACtrl); <br>HRESULT IPersistPropertyBag_Load(LPPROPERTYBAG pPropBag, <br>LPERRORLOG pErrorLog, ATL_PROPMAP_ENTRY* pMap); <br>HRESULT IPersistPropertyBag_Save(LPPROPERTYBAG pPropBag, <br>BOOL fClearDirty, BOOL fSaveAllProperties, ATL_PROPMAP_ENTRY* pMap); <br>HRESULT ISpecifyPropertyPages_GetPages(CAUUID* pPages, <br>ATL_PROPMAP_ENTRY* pMap); <br>HRESULT DoVerbProperties(LPCRECT /* prcPosRect */, HWND hwndParent); <br>HRESULT InPlaceActivate(LONG iVerb, const RECT* prcPosRect = NULL); <br>HRESULT IPersistStreamInit_Load(LPSTREAM pStm, ATL_PROPMAP_ENTRY* pMap); <br>HRESULT IPersistStreamInit_Save(LPSTREAM pStm, BOOL /* fClearDirty */, <br>ATL_PROPMAP_ENTRY* pMap); <br> <br>HRESULT IOleObject_SetClientSite(IOleClientSite *pClientSite); <br>HRESULT IOleObject_GetClientSite(IOleClientSite **ppClientSite); <br>HRESULT IOleObject_Advise(IAdviseSink *pAdvSink, DWORD *pdwConnection); <br>HRESULT IOleObject_Close(DWORD dwSaveOption); <br>HRESULT IOleObject_SetExtent(DWORD dwDrawAspect, SIZEL *psizel); <br>HRESULT IOleInPlaceObject_InPlaceDeactivate(void); <br>HRESULT IOleInPlaceObject_UIDeactivate(void); <br>HRESULT IOleInPlaceObject_SetObjectRects(LPCRECT prcPos,LPCRECT prcClip); <br>HRESULT IViewObject_Draw(DWORD dwDrawAspect, LONG lindex, void *pvAspect, <br>DVTARGETDEVICE *ptd, HDC hicTargetDev, HDC hdcDraw, <br>LPCRECTL prcBounds, LPCRECTL prcWBounds); <br>HRESULT IDataObject_GetData(FORMATETC *pformatetcIn, STGMEDIUM *pmedium); <br> <br>HRESULT FireViewChange(); <br>LRESULT OnPaint(UINT /* nMsg */, WPARAM /* wParam */, LPARAM /* lParam */, <br>BOOL&amp; /* lResult */); <br> <br>virtual HWND CreateControlWindow(HWND hWndParent, RECT&amp; rcPos) = 0; <br>virtual HRESULT ControlQueryInterface(const IID&amp; iid, void** ppv) = 0; <br>virtual HRESULT OnDrawAdvanced(ATL_DRAWINFO&amp; di); <br>virtual HRESULT OnDraw(ATL_DRAWINFO&amp; di) <br>{ <br>return S_OK; <br>} <br> <br> <br>// Attributes <br>public: <br>CComPtr&lt;IOleInPlaceSiteWindowless&gt; m_spInPlaceSite; <br>CComPtr&lt;IDataAdviseHolder&gt; m_spDataAdviseHolder; <br>CComPtr&lt;IOleAdviseHolder&gt; m_spOleAdviseHolder; <br>CComPtr&lt;IOleClientSite&gt; m_spClientSite; <br>CComPtr&lt;IAdviseSink&gt; m_spAdviseSink; <br>CComDispatchDriver m_spAmbientDispatch; <br> <br>SIZE m_sizeNatural; //unscaled size in himetric <br>SIZE m_sizeExtent;  //current extents in himetric <br>RECT m_rcPos; // position in pixels <br>union <br>{ <br>HWND&amp; m_hWndCD; <br>HWND* m_phWndCD; <br>}; <br>union <br>{ <br>// m_nFreezeEvents is the only one actually used <br>int m_nFreezeEvents; // count of freezes versus thaws <br> <br>// These are here to make stock properties work <br>IPictureDisp* m_pMouseIcon; <br>IPictureDisp* m_pPicture; <br>IFontDisp* m_pFont; <br>OLE_COLOR m_clrBackColor; <br>OLE_COLOR m_clrBorderColor; <br>OLE_COLOR m_clrFillColor; <br>OLE_COLOR m_clrForeColor; <br>BSTR m_bstrText; <br>BSTR m_bstrCaption; <br>BOOL m_bValid; <br>BOOL m_bTabStop; <br>BOOL m_bBorderVisible; <br>BOOL m_bEnabled; <br>long m_nBackStyle; <br>long m_nBorderStyle; <br>long m_nBorderWidth; <br>long m_nDrawMode; <br>long m_nDrawStyle; <br>long m_nDrawWidth; <br>long m_nFillStyle; <br>long m_nAppearance; <br>long m_nMousePointer; <br>long m_nReadyState; <br>}; <br> <br>unsigned m_bNegotiatedWnd:1; <br>unsigned m_bWndLess:1; <br>unsigned m_bInPlaceActive:1; <br>unsigned m_bUIActive:1; <br>unsigned m_bUsingWindowRgn:1; <br>unsigned m_bInPlaceSiteEx:1; <br>unsigned m_bWindowOnly:1; <br>unsigned m_bRequiresSave:1; <br>unsigned m_bWasOnceWindowless:1; <br>unsigned m_bAutoSize:1; //SetExtent fails if size doesn't match existing <br>unsigned m_bRecomposeOnResize:1; //implies OLEMISC_RECOMPOSEONRESIZE <br>unsigned m_bResizeNatural:1;  //resize natural extent on SetExtent <br>unsigned m_bDrawFromNatural:1; //instead of m_sizeExtent <br>unsigned m_bDrawGetDataInHimetric:1; //instead of pixels <br>}; <br> <br>template &lt;class T&gt; <br>class ATL_NO_VTABLE CComControl :  public CComControlBase, public CWindowImpl&lt;T&gt; <br>{ <br>public: <br>CComControl() : CComControlBase(m_hWnd) {} <br>HRESULT FireOnRequestEdit(DISPID dispID) <br>{ <br>T* pT = static_cast&lt;T*&gt;(this); <br>return T::__ATL_PROP_NOTIFY_EVENT_CLASS::FireOnRequestEdit(pT-&gt;GetUnknown(), dispID); <br>} <br>HRESULT FireOnChanged(DISPID dispID) <br>{ <br>T* pT = static_cast&lt;T*&gt;(this); <br>return T::__ATL_PROP_NOTIFY_EVENT_CLASS::FireOnChanged(pT-&gt;GetUnknown(), dispID); <br>} <br>virtual HRESULT ControlQueryInterface(const IID&amp; iid, void** ppv) <br>{ <br>T* pT = static_cast&lt;T*&gt;(this); <br>return pT-&gt;_InternalQueryInterface(iid, ppv); <br>} <br>virtual HWND CreateControlWindow(HWND hWndParent, RECT&amp; rcPos) <br>{ <br>T* pT = static_cast&lt;T*&gt;(this); <br>return pT-&gt;Create(hWndParent, rcPos); <br>} <br>}; <br> <br>// Forward declarations <br>// <br>template &lt;class T&gt; class IPersistImpl; <br>template &lt;class T&gt; class IPersistStreamInitImpl; <br>template &lt;class T&gt; class IPersistStorageImpl; <br>template &lt;class T&gt; class IPersistPropertyBagImpl; <br> <br>template &lt;class T&gt; class IOleControlImpl; <br>template &lt;class T&gt; class IRunnableObjectImpl; <br>template &lt;class T&gt; class IQuickActivateImpl; <br>template &lt;class T&gt; class IOleObjectImpl; <br>template &lt;class T&gt; class IPropertyPageImpl; <br>template &lt;class T&gt; class IPropertyPage2Impl; <br>template &lt;class T&gt; class IPerPropertyBrowsingImpl; <br>template &lt;class T&gt; class IViewObjectExImpl; <br>template &lt;class T&gt; class IOleWindowImpl; <br>template &lt;class T&gt; class ISpecifyPropertyPagesImpl; <br>template &lt;class T&gt; class IPointerInactiveImpl; <br>template &lt;class T, class CDV&gt; class IPropertyNotifySinkCP; <br>template &lt;class T&gt; class IBindStatusCallbackImpl; <br>template &lt;class T&gt; class CBindStatusCallback; <br> <br>////////////////////////////////////////////////////////////////////////////// <br>// IPersistImpl <br>template &lt;class T&gt; <br>class ATL_NO_VTABLE IPersistImpl <br>{ <br>public: <br>// IUnknown <br>// <br>STDMETHOD(QueryInterface)(REFIID riid, void ** ppvObject) = 0; <br>_ATL_DEBUG_ADDREF_RELEASE_IMPL(IPersistImpl) <br> <br>// IPersist <br>STDMETHOD(GetClassID)(CLSID *pClassID) <br>{ <br>ATLTRACE(_T("IPersistImpl::GetClassID\n")); <br>T* pT = static_cast&lt;T*&gt;(this); <br>*pClassID = pT-&gt;GetObjectCLSID(); <br>return S_OK; <br>} <br>}; <br> <br>#define BEGIN_PROPERTY_MAP(theClass) \ <br>typedef _ATL_PROP_NOTIFY_EVENT_CLASS __ATL_PROP_NOTIFY_EVENT_CLASS; \ <br>static ATL_PROPMAP_ENTRY* GetPropertyMap()\ <br>{\ <br>static ATL_PROPMAP_ENTRY pPropMap[] = \ <br>{ <br> <br>#define PROP_ENTRY(szDesc, dispid, clsid) \ <br>{OLESTR(szDesc), dispid, &amp;clsid, &amp;IID_IDispatch}, <br> <br>#define PROP_ENTRY_EX(szDesc, dispid, clsid, iidDispatch) \ <br>{OLESTR(szDesc), dispid, &amp;clsid, &amp;iidDispatch}, <br> <br>#define PROP_PAGE(clsid) \ <br>{NULL, NULL, &amp;clsid, &amp;IID_NULL}, <br> <br>#define END_PROPERTY_MAP() \ <br>{NULL, 0, NULL, &amp;IID_NULL} \ <br>}; \ <br>return pPropMap; \ <br>} <br> <br> <br>////////////////////////////////////////////////////////////////////////////// <br>// IPersistStreamInitImpl <br>template &lt;class T&gt; <br>class ATL_NO_VTABLE IPersistStreamInitImpl <br>{ <br>public: <br>// IUnknown <br>// <br>STDMETHOD(QueryInterface)(REFIID riid, void ** ppvObject) = 0; <br>_ATL_DEBUG_ADDREF_RELEASE_IMPL(IPersistStreamInitImpl) <br> <br>// IPersist <br>STDMETHOD(GetClassID)(CLSID *pClassID) <br>{ <br>ATLTRACE(_T("IPersistStreamInitImpl::GetClassID\n")); <br>T* pT = static_cast&lt;T*&gt;(this); <br>*pClassID = pT-&gt;GetObjectCLSID(); <br>return S_OK; <br>} <br> <br>// IPersistStream <br>STDMETHOD(IsDirty)() <br>{ <br>ATLTRACE(_T("IPersistStreamInitImpl::IsDirty\n")); <br>T* pT = static_cast&lt;T*&gt;(this); <br>return (pT-&gt;m_bRequiresSave) ? S_OK : S_FALSE; <br>} <br>STDMETHOD(Load)(LPSTREAM pStm) <br>{ <br>ATLTRACE(_T("IPersistStreamInitImpl::Load\n")); <br>T* pT = static_cast&lt;T*&gt;(this); <br>return pT-&gt;IPersistStreamInit_Load(pStm, T::GetPropertyMap()); <br>} <br>STDMETHOD(Save)(LPSTREAM pStm, BOOL fClearDirty) <br>{ <br>T* pT = static_cast&lt;T*&gt;(this); <br>ATLTRACE(_T("IPersistStreamInitImpl::Save\n")); <br>return pT-&gt;IPersistStreamInit_Save(pStm, fClearDirty, T::GetPropertyMap()); <br>} <br>STDMETHOD(GetSizeMax)(ULARGE_INTEGER FAR* /* pcbSize */) <br>{ <br>ATLTRACENOTIMPL(_T("IPersistStreamInitImpl::GetSizeMax")); <br>} <br> <br>// IPersistStreamInit <br>STDMETHOD(InitNew)() <br>{ <br>T* pT = static_cast&lt;T*&gt;(this); <br>ATLTRACE(_T("IPersistStreamInitImpl::InitNew\n")); <br>pT-&gt;SendOnDataChange(); <br>return S_OK; <br>} <br> <br>}; <br> <br> <br>////////////////////////////////////////////////////////////////////////////// <br>// IPersistStorageImpl <br>template &lt;class T&gt; <br>class ATL_NO_VTABLE IPersistStorageImpl <br>{ <br>public: <br>// IUnknown <br>// <br>STDMETHOD(QueryInterface)(REFIID riid, void ** ppvObject) = 0; <br>_ATL_DEBUG_ADDREF_RELEASE_IMPL(IPersistStorageImpl) <br> <br>// IPersist <br>STDMETHOD(GetClassID)(CLSID *pClassID) <br>{ <br>ATLTRACE(_T("IPersistStorageImpl::GetClassID\n")); <br>T* pT = static_cast&lt;T*&gt;(this); <br>*pClassID = pT-&gt;GetObjectCLSID(); <br>return S_OK; <br>} <br> <br>// IPersistStorage <br>STDMETHOD(IsDirty)(void) <br>{ <br>ATLTRACE(_T("IPersistStorageImpl::IsDirty\n")); <br>T* pT = static_cast&lt;T*&gt;(this); <br>CComPtr&lt;IPersistStreamInit&gt; p; <br>p.p = IPSI_GetIPersistStreamInit(); <br>return (p != NULL) ? p-&gt;IsDirty() : E_FAIL; <br>} <br>STDMETHOD(InitNew)(IStorage*) <br>{ <br>ATLTRACE(_T("IPersistStorageImpl::InitNew\n")); <br>T* pT = static_cast&lt;T*&gt;(this); <br>CComPtr&lt;IPersistStreamInit&gt; p; <br>p.p = IPSI_GetIPersistStreamInit(); <br>return (p != NULL) ? p-&gt;InitNew() : E_FAIL; <br>} <br>STDMETHOD(Load)(IStorage* pStorage) <br>{ <br>ATLTRACE(_T("IPersistStorageImpl::Load\n")); <br>T* pT = static_cast&lt;T*&gt;(this); <br>CComPtr&lt;IPersistStreamInit&gt; p; <br>p.p = IPSI_GetIPersistStreamInit(); <br>HRESULT hr = E_FAIL; <br>if (p != NULL) <br>{ <br>CComPtr&lt;IStream&gt; spStream; <br>hr = pStorage-&gt;OpenStream(OLESTR("Contents"), NULL, <br>STGM_DIRECT | STGM_SHARE_EXCLUSIVE, 0, &amp;spStream); <br>if (SUCCEEDED(hr)) <br>hr = p-&gt;Load(spStream); <br>} <br>return hr; <br>} <br>STDMETHOD(Save)(IStorage* pStorage, BOOL fSameAsLoad) <br>{ <br>ATLTRACE(_T("IPersistStorageImpl::Save\n")); <br>T* pT = static_cast&lt;T*&gt;(this); <br>CComPtr&lt;IPersistStreamInit&gt; p; <br>p.p = IPSI_GetIPersistStreamInit(); <br>HRESULT hr = E_FAIL; <br>if (p != NULL) <br>{ <br>CComPtr&lt;IStream&gt; spStream; <br>static LPCOLESTR vszContents = OLESTR("Contents"); <br>hr = pStorage-&gt;CreateStream(vszContents, <br>STGM_READWRITE | STGM_SHARE_EXCLUSIVE | STGM_CREATE, <br>0, 0, &amp;spStream); <br>if (SUCCEEDED(hr)) <br>hr = p-&gt;Save(spStream, fSameAsLoad); <br>} <br>return hr; <br>} <br>STDMETHOD(SaveCompleted)(IStorage* /* pStorage */) <br>{ <br>ATLTRACE(_T("IPersistStorageImpl::SaveCompleted\n")); <br>return S_OK; <br>} <br>STDMETHOD(HandsOffStorage)(void) <br>{ <br>ATLTRACE(_T("IPersistStorageImpl::HandsOffStorage\n")); <br>return S_OK; <br>} <br>private: <br>IPersistStreamInit* IPSI_GetIPersistStreamInit(); <br>}; <br> <br>template &lt;class T&gt; <br>IPersistStreamInit* IPersistStorageImpl&lt;T&gt;::IPSI_GetIPersistStreamInit() <br>{ <br>T* pT = static_cast&lt;T*&gt;(this); <br>IPersistStreamInit* p; <br>if (FAILED(pT-&gt;GetUnknown()-&gt;QueryInterface(IID_IPersistStreamInit, (void**)&amp;p))) <br>pT-&gt;_InternalQueryInterface(IID_IPersistStreamInit, (void**)&amp;p); <br>return p; <br>} <br> <br>////////////////////////////////////////////////////////////////////////////// <br>// IPersistPropertyBagImpl <br>template &lt;class T&gt; <br>class ATL_NO_VTABLE IPersistPropertyBagImpl <br>{ <br>public: <br> <br>// IUnknown <br>// <br>STDMETHOD(QueryInterface)(REFIID riid, void ** ppvObject) = 0; <br>_ATL_DEBUG_ADDREF_RELEASE_IMPL(IPersistPropertyBagImpl) <br> <br>// IPersist <br>STDMETHOD(GetClassID)(CLSID *pClassID) <br>{ <br>ATLTRACE(_T("IPersistPropertyBagImpl::GetClassID\n")); <br>T* pT = static_cast&lt;T*&gt;(this); <br>*pClassID = pT-&gt;GetObjectCLSID(); <br>return S_OK; <br>} <br> <br>// IPersistPropertyBag <br>// <br>STDMETHOD(InitNew)() <br>{ <br>ATLTRACE(_T("IPersistPropertyBagImpl::InitNew\n")); <br>return S_OK; <br>} <br>STDMETHOD(Load)(LPPROPERTYBAG pPropBag, LPERRORLOG pErrorLog) <br>{ <br>ATLTRACE(_T("IPersistPropertyBagImpl::Load\n")); <br>T* pT = static_cast&lt;T*&gt;(this); <br>ATL_PROPMAP_ENTRY* pMap = T::GetPropertyMap(); <br>_ASSERTE(pMap != NULL); <br>return pT-&gt;IPersistPropertyBag_Load(pPropBag, pErrorLog, pMap); <br>} <br>STDMETHOD(Save)(LPPROPERTYBAG pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties) <br>{ <br>ATLTRACE(_T("IPersistPropertyBagImpl::Save\n")); <br>T* pT = static_cast&lt;T*&gt;(this); <br>ATL_PROPMAP_ENTRY* pMap = T::GetPropertyMap(); <br>_ASSERTE(pMap != NULL); <br>return pT-&gt;IPersistPropertyBag_Save(pPropBag, fClearDirty, fSaveAllProperties, pMap); <br>} <br>}; <br> <br> <br>////////////////////////////////////////////////////////////////////////////// <br>// IOleControlImpl <br>template &lt;class T&gt; <br>class ATL_NO_VTABLE IOleControlImpl <br>{ <br>public: <br>// IUnknown <br>// <br>STDMETHOD(QueryInterface)(REFIID riid, void ** ppvObject) = 0; <br>_ATL_DEBUG_ADDREF_RELEASE_IMPL(IOleControlImpl) <br> <br>// IOleControl methods <br>// <br>STDMETHOD(GetControlInfo)(LPCONTROLINFO /* pCI */) <br>{ <br>ATLTRACENOTIMPL(_T("IOleControlImpl::GetControlInfo")); <br>} <br>STDMETHOD(OnMnemonic)(LPMSG /* pMsg */) <br>{ <br>ATLTRACENOTIMPL(_T("IOleControlImpl::OnMnemonic")); <br>} <br>STDMETHOD(OnAmbientPropertyChange)(DISPID dispid) <br>{ <br>dispid; <br>ATLTRACE(_T("IOleControlImpl::OnAmbientPropertyChange\n")); <br>ATLTRACE(_T(" -- DISPID = %d (%d)\n"), dispid); <br>return S_OK; <br>} <br>STDMETHOD(FreezeEvents)(BOOL bFreeze) <br>{ <br>T* pT = static_cast&lt;T*&gt;(this); <br>ATLTRACE(_T("IOleControlImpl::FreezeEvents\n")); <br>if (bFreeze) <br>pT-&gt;m_nFreezeEvents++; <br>else <br>pT-&gt;m_nFreezeEvents--; <br>return S_OK; <br>} <br>}; <br> <br> <br>////////////////////////////////////////////////////////////////////////////// <br>// IQuickActivateImpl <br>template &lt;class T&gt; <br>class ATL_NO_VTABLE IQuickActivateImpl <br>{ <br>public: <br>// IUnknown <br>// <br>STDMETHOD(QueryInterface)(REFIID riid, void ** ppvObject) = 0; <br>_ATL_DEBUG_ADDREF_RELEASE_IMPL(IQuickActivateImpl) <br> <br>// IQuickActivate <br>// <br>STDMETHOD(QuickActivate)(QACONTAINER *pQACont, QACONTROL *pQACtrl) <br>{ <br>T* pT = static_cast&lt;T*&gt;(this); <br>ATLTRACE(_T("IQuickActivateImpl::QuickActivate\n")); <br>return pT-&gt;IQuickActivate_QuickActivate(pQACont, pQACtrl); <br>} <br>STDMETHOD(SetContentExtent)(LPSIZEL pSize) <br>{ <br>T* pT = static_cast&lt;T*&gt;(this); <br>ATLTRACE(_T("IQuickActivateImpl::SetContentExtent\n")); <br>return pT-&gt;IOleObjectImpl&lt;T&gt;::SetExtent(DVASPECT_CONTENT, pSize); <br>} <br>STDMETHOD(GetContentExtent)(LPSIZEL pSize) <br>{ <br>T* pT = static_cast&lt;T*&gt;(this); <br>ATLTRACE(_T("IQuickActivateImpl::GetContentExtent\n")); <br>return pT-&gt;IOleObjectImpl&lt;T&gt;::GetExtent(DVASPECT_CONTENT, pSize); <br>} <br>}; <br> <br> <br>////////////////////////////////////////////////////////////////////////////// <br>// IOleObjectImpl <br>template &lt;class T&gt; <br>class ATL_NO_VTABLE IOleObjectImpl <br>{ <br>public: <br>// IUnknown <br>// <br>STDMETHOD(QueryInterface)(REFIID riid, void ** ppvObject) = 0; <br>_ATL_DEBUG_ADDREF_RELEASE_IMPL(IOleObjectImpl) <br> <br>// IOleObject <br>// <br>STDMETHOD(SetClientSite)(IOleClientSite *pClientSite) <br>{ <br>T* pT = static_cast&lt;T*&gt;(this); <br>ATLTRACE(_T("IOleObjectImpl::SetClientSite\n")); <br>return pT-&gt;IOleObject_SetClientSite(pClientSite); <br>} <br>STDMETHOD(GetClientSite)(IOleClientSite **ppClientSite) <br>{ <br>T* pT = static_cast&lt;T*&gt;(this); <br>ATLTRACE(_T("IOleObjectImpl::GetClientSite\n")); <br>return pT-&gt;IOleObject_GetClientSite(ppClientSite); <br>} <br>STDMETHOD(SetHostNames)(LPCOLESTR /* szContainerApp */, LPCOLESTR /* szContainerObj */) <br>{ <br>ATLTRACE(_T("IOleObjectImpl::SetHostNames\n")); <br>return S_OK; <br>} <br>STDMETHOD(Close)(DWORD dwSaveOption) <br>{ <br>T* pT = static_cast&lt;T*&gt;(this); <br>ATLTRACE(_T("IOleObjectImpl::Close\n")); <br>return pT-&gt;IOleObject_Close(dwSaveOption); <br>} <br>STDMETHOD(SetMoniker)(DWORD /* dwWhichMoniker */, IMoniker* /* pmk */) <br>{ <br>ATLTRACENOTIMPL(_T("IOleObjectImpl::SetMoniker")); <br>} <br>STDMETHOD(GetMoniker)(DWORD /* dwAssign */, DWORD /* dwWhichMoniker */, IMoniker** /* ppmk */) <br>{ <br>ATLTRACENOTIMPL(_T("IOleObjectImpl::GetMoniker")); <br>} <br>STDMETHOD(InitFromData)(IDataObject* /* pDataObject */, BOOL /* fCreation */, DWORD /* dwReserved */) <br>{ <br>ATLTRACENOTIMPL(_T("IOleObjectImpl::InitFromData")); <br>} <br>STDMETHOD(GetClipboardData)(DWORD /* dwReserved */, IDataObject** /* ppDataObject */) <br>{ <br>ATLTRACENOTIMPL(_T("IOleObjectImpl::GetClipboardData")); <br>} <br> <br>// Helpers for DoVerb - Over-rideable in user class <br>HRESULT DoVerbPrimary(LPCRECT prcPosRect, HWND hwndParent) <br>{ <br>T* pT = static_cast&lt;T*&gt;(this); <br>BOOL bDesignMode = FALSE; <br>CComVariant var; <br>// if container doesn't support this property <br>// don't allow design mode <br>HRESULT hRes = pT-&gt;GetAmbientProperty(DISPID_AMBIENT_USERMODE, var); <br>if (SUCCEEDED(hRes) &amp;&amp; var.vt == VT_BOOL &amp;&amp; !var.boolVal) <br>bDesignMode = TRUE; <br>if (bDesignMode) <br>return pT-&gt;DoVerbProperties(prcPosRect, hwndParent); <br>else <br>return pT-&gt;DoVerbInPlaceActivate(prcPosRect, hwndParent); <br>} <br>HRESULT DoVerbShow(LPCRECT prcPosRect, HWND /* hwndParent */) <br>{ <br>T* pT = static_cast&lt;T*&gt;(this); <br>return pT-&gt;InPlaceActivate(OLEIVERB_SHOW, prcPosRect); <br>} <br>HRESULT DoVerbInPlaceActivate(LPCRECT prcPosRect, HWND /* hwndParent */) <br>{ <br>T* pT = static_cast&lt;T*&gt;(this); <br>return pT-&gt;InPlaceActivate(OLEIVERB_INPLACEACTIVATE, prcPosRect); <br>} <br>HRESULT DoVerbUIActivate(LPCRECT prcPosRect, HWND /* hwndParent */) <br>{ <br>T* pT = static_cast&lt;T*&gt;(this); <br>return pT-&gt;InPlaceActivate(OLEIVERB_UIACTIVATE, prcPosRect); <br>} <br>HRESULT DoVerbHide(LPCRECT /* prcPosRect */, HWND /* hwndParent */) <br>{ <br>T* pT = static_cast&lt;T*&gt;(this); <br>pT-&gt;UIDeactivate(); <br>if (pT-&gt;m_hWnd) <br>pT-&gt;ShowWindow(SW_HIDE); <br>return S_OK; <br>} <br>HRESULT DoVerbOpen(LPCRECT /* prcPosRect */, HWND /* hwndParent */) <br>{ <br>return S_OK; <br>} <br>HRESULT DoVerbDiscardUndo(LPCRECT /* prcPosRect */, HWND /* hwndParent */) <br>{ <br>return S_OK; <br>} <br>STDMETHOD(DoVerb)(LONG iVerb, LPMSG /* lpmsg */, IOleClientSite* /* pActiveSite */, LONG /* lindex */, <br> HWND hwndParent, LPCRECT lprcPosRect) <br>{ </code></pre>
<p>
</p>
<pre><code>T* pT = static_cast&lt;T*&gt;(this); <br>ATLTRACE(_T("IOleObjectImpl::DoVerb\n")); <br>_ASSERTE(pT-&gt;m_spClientSite); <br> <br>HRESULT hr = E_NOTIMPL; <br>switch (iVerb) <br>{ <br>case OLEIVERB_PRIMARY: <br>hr = pT-&gt;DoVerbPrimary(lprcPosRect, hwndParent); <br>break; <br>case OLEIVERB_SHOW: <br>hr = pT-&gt;DoVerbShow(lprcPosRect, hwndParent); <br>break; <br>case OLEIVERB_INPLACEACTIVATE: <br>hr = pT-&gt;DoVerbInPlaceActivate(lprcPosRect, hwndParent); <br>break; <br>case OLEIVERB_UIACTIVATE: <br>hr = pT-&gt;DoVerbUIActivate(lprcPosRect, hwndParent); <br>break; <br>case OLEIVERB_HIDE: <br>hr = pT-&gt;DoVerbHide(lprcPosRect, hwndParent); <br>break; <br>case OLEIVERB_OPEN: <br>hr = pT-&gt;DoVerbOpen(lprcPosRect, hwndParent); <br>break; <br>case OLEIVERB_DISCARDUNDOSTATE: <br>hr = pT-&gt;DoVerbDiscardUndo(lprcPosRect, hwndParent); <br>break; <br>case OLEIVERB_PROPERTIES: <br>hr = pT-&gt;DoVerbProperties(lprcPosRect, hwndParent); <br>} <br>return hr; <br>} <br>STDMETHOD(EnumVerbs)(IEnumOLEVERB **ppEnumOleVerb) <br>{ <br>ATLTRACE(_T("IOleObjectImpl::EnumVerbs\n")); <br>_ASSERTE(ppEnumOleVerb); <br>if (!ppEnumOleVerb) <br>return E_POINTER; <br>return OleRegEnumVerbs(T::GetObjectCLSID(), ppEnumOleVerb); <br>} <br>STDMETHOD(Update)(void) <br>{ <br>ATLTRACE(_T("IOleObjectImpl::Update\n")); <br>return S_OK; <br>} <br>STDMETHOD(IsUpToDate)(void) <br>{ <br>ATLTRACE(_T("IOleObjectImpl::IsUpToDate\n")); <br>return S_OK; <br>} <br>STDMETHOD(GetUserClassID)(CLSID *pClsid) <br>{ <br>ATLTRACE(_T("IOleObjectImpl::GetUserClassID\n")); <br>_ASSERTE(pClsid); <br>if (!pClsid) <br>return E_POINTER; <br>*pClsid = T::GetObjectCLSID(); <br>return S_OK; <br>} <br>STDMETHOD(GetUserType)(DWORD dwFormOfType, LPOLESTR *pszUserType) <br>{ <br>ATLTRACE(_T("IOleObjectImpl::GetUserType\n")); <br>return OleRegGetUserType(T::GetObjectCLSID(), dwFormOfType, pszUserType); <br>} <br>STDMETHOD(SetExtent)(DWORD dwDrawAspect, SIZEL *psizel) <br>{ <br>T* pT = static_cast&lt;T*&gt;(this); <br>ATLTRACE(_T("IOleObjectImpl::SetExtent\n")); <br>return pT-&gt;IOleObject_SetExtent(dwDrawAspect, psizel); <br>} <br>STDMETHOD(GetExtent)(DWORD dwDrawAspect, SIZEL *psizel) <br>{ <br>T* pT = static_cast&lt;T*&gt;(this); <br>ATLTRACE(_T("IOleObjectImpl::GetExtent\n")); <br>if (dwDrawAspect != DVASPECT_CONTENT) <br>return E_FAIL; <br>if (psizel == NULL) <br>return E_POINTER; <br>*psizel = pT-&gt;m_sizeExtent; <br>return S_OK; <br>} <br>STDMETHOD(Advise)(IAdviseSink *pAdvSink, DWORD *pdwConnection) <br>{ <br>T* pT = static_cast&lt;T*&gt;(this); <br>ATLTRACE(_T("IOleObjectImpl::Advise\n")); <br>return pT-&gt;IOleObject_Advise(pAdvSink, pdwConnection); <br>} <br>STDMETHOD(Unadvise)(DWORD dwConnection) <br>{ <br>T* pT = static_cast&lt;T*&gt;(this); <br>ATLTRACE(_T("IOleObjectImpl::Unadvise\n")); <br>HRESULT hRes = E_FAIL; <br>if (pT-&gt;m_spOleAdviseHolder != NULL) <br>hRes = pT-&gt;m_spOleAdviseHolder-&gt;Unadvise(dwConnection); <br>return hRes; <br>} <br>STDMETHOD(EnumAdvise)(IEnumSTATDATA **ppenumAdvise) <br>{ <br>T* pT = static_cast&lt;T*&gt;(this); <br>ATLTRACE(_T("IOleObjectImpl::EnumAdvise\n")); <br>HRESULT hRes = E_FAIL; <br>if (pT-&gt;m_spOleAdviseHolder != NULL) <br>hRes = pT-&gt;m_spOleAdviseHolder-&gt;EnumAdvise(ppenumAdvise); <br>return hRes; <br>} <br>STDMETHOD(GetMiscStatus)(DWORD dwAspect, DWORD *pdwStatus) <br>{ <br>ATLTRACE(_T("IOleObjectImpl::GetMiscStatus\n")); <br>return OleRegGetMiscStatus(T::GetObjectCLSID(), dwAspect, pdwStatus); <br>} <br>STDMETHOD(SetColorScheme)(LOGPALETTE* /* pLogpal */) <br>{ <br>ATLTRACENOTIMPL(_T("IOleObjectImpl::SetColorScheme")); <br>} <br>}; <br> <br>//local struct used for implementation <br>#pragma pack(push, 1) <br>struct _ATL_DLGTEMPLATEEX <br>{ <br>WORD dlgVer; <br>WORD signature; <br>DWORD helpID; <br>DWORD exStyle; <br>DWORD style; <br>WORD cDlgItems; <br>short x; <br>short y; <br>short cx; <br>short cy; <br>}; <br>#pragma pack(pop) <br> <br>////////////////////////////////////////////////////////////////////////////// <br>// IPropertyPageImpl <br>template &lt;class T&gt; <br>class ATL_NO_VTABLE IPropertyPageImpl <br>{ <br> <br>public: <br>// IUnknown <br>// <br>STDMETHOD(QueryInterface)(REFIID riid, void ** ppvObject) = 0; <br>_ATL_DEBUG_ADDREF_RELEASE_IMPL(IOleControlImpl) <br> <br>void SetDirty(BOOL bDirty) <br>{ <br>T* pT = static_cast&lt;T*&gt;(this); <br>if (!pT-&gt;m_bDirty &amp;&amp; bDirty) <br>pT-&gt;m_pPageSite-&gt;OnStatusChange(PROPPAGESTATUS_DIRTY | PROPPAGESTATUS_VALIDATE); <br>pT-&gt;m_bDirty = bDirty; <br>} <br> <br>IPropertyPageImpl() <br>{ <br>T* pT = static_cast&lt;T*&gt;(this); <br>pT-&gt;m_pPageSite = NULL; <br>pT-&gt;m_size.cx = 0; <br>pT-&gt;m_size.cy = 0; <br>pT-&gt;m_dwTitleID = 0; <br>pT-&gt;m_dwHelpFileID = 0; <br>pT-&gt;m_dwDocStringID = 0; <br>pT-&gt;m_dwHelpContext = 0; <br>pT-&gt;m_ppUnk = NULL; <br>pT-&gt;m_nObjects = 0; <br>pT-&gt;m_bDirty = FALSE; <br>pT-&gt;m_hWnd = NULL; <br>} <br> <br>~IPropertyPageImpl() <br>{ <br>T* pT = static_cast&lt;T*&gt;(this); <br>if (pT-&gt;m_pPageSite != NULL) <br>pT-&gt;m_pPageSite-&gt;Release(); <br> <br>for (UINT i = 0; i &lt; m_nObjects; i++) <br>pT-&gt;m_ppUnk[i]-&gt;Release(); <br> <br>delete[] pT-&gt;m_ppUnk; <br>} <br> <br>// IPropertyPage <br>// <br>STDMETHOD(SetPageSite)(IPropertyPageSite *pPageSite) <br>{ <br>T* pT = static_cast&lt;T*&gt;(this); <br>ATLTRACE(_T("IPropertyPageImpl::SetPageSite\n")); <br> <br>if (!pPageSite &amp;&amp; pT-&gt;m_pPageSite) <br>{ <br>pT-&gt;m_pPageSite-&gt;Release(); <br>return S_OK; <br>} <br> <br>if (!pPageSite &amp;&amp; !pT-&gt;m_pPageSite) <br>return S_OK; <br> <br>if (pPageSite &amp;&amp; pT-&gt;m_pPageSite) <br>{ <br>ATLTRACE(_T("Error : setting page site again with non NULL value\n")); <br>return E_UNEXPECTED; <br>} <br> <br>pT-&gt;m_pPageSite = pPageSite; <br>pT-&gt;m_pPageSite-&gt;AddRef(); <br>return S_OK; <br>} <br>STDMETHOD(Activate)(HWND hWndParent, LPCRECT pRect, BOOL /* bModal */) <br>{ <br>T* pT = static_cast&lt;T*&gt;(this); <br>ATLTRACE(_T("IPropertyPageImpl::Activate\n")); <br> <br>if (pRect == NULL) <br>{ <br>ATLTRACE(_T("Error : Passed a NULL rect\n")); <br>return E_POINTER; <br>} <br> <br>pT-&gt;m_hWnd = pT-&gt;Create(hWndParent); <br>Move(pRect); <br> <br>m_size.cx = pRect-&gt;right - pRect-&gt;left; <br>m_size.cy = pRect-&gt;bottom - pRect-&gt;top; <br> <br>return S_OK; <br> <br>} <br>STDMETHOD(Deactivate)( void) <br>{ <br>T* pT = static_cast&lt;T*&gt;(this); <br>ATLTRACE(_T("IPropertyPageImpl::Deactivate\n")); <br> <br>if (pT-&gt;m_hWnd) <br>{ <br>ATLTRACE(_T("Destroying Dialog\n")); <br>if (::IsWindow(pT-&gt;m_hWnd)) <br>pT-&gt;DestroyWindow(); <br>pT-&gt;m_hWnd = NULL; <br>} <br> <br>return S_OK; <br> <br>} <br>STDMETHOD(GetPageInfo)(PROPPAGEINFO *pPageInfo) <br>{ <br>T* pT = static_cast&lt;T*&gt;(this); <br>ATLTRACE(_T("IPropertyPageImpl::GetPageInfo\n")); <br> <br>if (pPageInfo == NULL) <br>{ <br>ATLTRACE(_T("Error : PROPPAGEINFO passed == NULL\n")); <br>return E_POINTER; <br>} <br> <br>HRSRC hRsrc = FindResource(_Module.GetResourceInstance(), <br>   MAKEINTRESOURCE(T::IDD), RT_DIALOG); <br>if (hRsrc == NULL) <br>{ <br>ATLTRACE(_T("Could not find resource template\n")); <br>return E_UNEXPECTED; <br>} <br> <br>HGLOBAL hGlob = LoadResource(_Module.GetResourceInstance(), hRsrc); <br>DLGTEMPLATE* pTemp = (DLGTEMPLATE*)LockResource(hGlob); <br>if (pTemp == NULL) <br>{ <br>ATLTRACE(_T("Could not load resource template\n")); <br>return E_UNEXPECTED; <br>} <br>pT-&gt;GetDialogSize(pTemp, &amp;m_size); <br> <br>pPageInfo-&gt;cb = sizeof(PROPPAGEINFO); <br>pPageInfo-&gt;pszTitle = LoadStringHelper(pT-&gt;m_dwTitleID); <br>pPageInfo-&gt;size = m_size; <br>pPageInfo-&gt;pszHelpFile = LoadStringHelper(pT-&gt;m_dwHelpFileID); <br>pPageInfo-&gt;pszDocString = LoadStringHelper(pT-&gt;m_dwDocStringID); <br>pPageInfo-&gt;dwHelpContext = pT-&gt;m_dwHelpContext; <br> <br>return S_OK; <br>} <br> <br>STDMETHOD(SetObjects)(ULONG nObjects, IUnknown **ppUnk) <br>{ <br>T* pT = static_cast&lt;T*&gt;(this); <br>ATLTRACE(_T("IPropertyPageImpl::SetObjects\n")); <br> <br>if (ppUnk == NULL) <br>return E_POINTER; <br> <br>if (pT-&gt;m_ppUnk != NULL &amp;&amp; pT-&gt;m_nObjects &gt; 0) <br>{ <br>for (UINT iObj = 0; iObj &lt; pT-&gt;m_nObjects; iObj++) <br>pT-&gt;m_ppUnk[iObj]-&gt;Release(); <br> <br>delete [] pT-&gt;m_ppUnk; <br>} <br> <br>pT-&gt;m_ppUnk = NULL; <br>ATLTRY(pT-&gt;m_ppUnk = new IUnknown*[nObjects]); <br> <br>if (pT-&gt;m_ppUnk == NULL) <br>return E_OUTOFMEMORY; <br> <br>for (UINT i = 0; i &lt; nObjects; i++) <br>{ <br>ppUnk[i]-&gt;AddRef(); <br>pT-&gt;m_ppUnk[i] = ppUnk[i]; <br>} <br> <br>pT-&gt;m_nObjects = nObjects; <br> <br>return S_OK; <br>} <br>STDMETHOD(Show)(UINT nCmdShow) <br>{ <br>T* pT = static_cast&lt;T*&gt;(this); <br>ATLTRACE(_T("IPropertyPageImpl::Show\n")); <br> <br>if (pT-&gt;m_hWnd == NULL) <br>return E_UNEXPECTED; <br> <br>ShowWindow(pT-&gt;m_hWnd, nCmdShow); <br>return S_OK; <br>} <br>STDMETHOD(Move)(LPCRECT pRect) <br>{ <br>T* pT = static_cast&lt;T*&gt;(this); <br>ATLTRACE(_T("IPropertyPageImpl::Move\n")); <br> <br>if (pT-&gt;m_hWnd == NULL) <br>return E_UNEXPECTED; <br> <br>if (pRect == NULL) <br>return E_POINTER; <br> <br>MoveWindow(pT-&gt;m_hWnd, pRect-&gt;left, pRect-&gt;top, pRect-&gt;right - pRect-&gt;left, <br> pRect-&gt;bottom - pRect-&gt;top, TRUE); <br> <br>return S_OK; <br> <br>} <br>STDMETHOD(IsPageDirty)(void) <br>{ <br>T* pT = static_cast&lt;T*&gt;(this); <br>ATLTRACE(_T("IPropertyPageImpl::IsPageDirty\n")); <br>return pT-&gt;m_bDirty ? S_OK : S_FALSE; <br>} <br>STDMETHOD(Apply)(void) <br>{ <br>T* pT = static_cast&lt;T*&gt;(this); <br>ATLTRACE(_T("IPropertyPageImpl::Apply\n")); <br>return S_OK; <br>} <br>STDMETHOD(Help)(LPCOLESTR pszHelpDir) <br>{ <br>T* pT = static_cast&lt;T*&gt;(this); <br>USES_CONVERSION; <br> <br>ATLTRACE(_T("IPropertyPageImpl::Help\n")); <br>WinHelp(pT-&gt;m_hWnd, OLE2CT(pszHelpDir), HELP_CONTEXTPOPUP, NULL); <br>return S_OK; <br>} <br>STDMETHOD(TranslateAccelerator)(MSG *pMsg) <br>{ <br>T* pT = static_cast&lt;T*&gt;(this); <br>ATLTRACE(_T("IPropertyPageImpl::TranslateAccelerator\n")); <br>if (pMsg == NULL) <br>return E_POINTER; <br>LRESULT lRes; <br>return pT-&gt;ProcessWindowMessage(pT-&gt;m_hWnd, pMsg-&gt;message, pMsg-&gt;wParam, pMsg-&gt;lParam, lRes) ? S_OK : S_FALSE; <br>} <br> <br>IPropertyPageSite* m_pPageSite; <br>IUnknown** m_ppUnk; <br>ULONG m_nObjects; <br>SIZE m_size; <br>UINT m_dwTitleID; <br>UINT m_dwHelpFileID; <br>UINT m_dwDocStringID; <br>DWORD m_dwHelpContext; <br>BOOL m_bDirty; <br> <br>//methods <br>public: <br> <br>BEGIN_MSG_MAP(IPropertyPageImpl&lt;T&gt;) <br>MESSAGE_HANDLER(WM_STYLECHANGING, OnStyleChange) <br>END_MSG_MAP() <br> <br>LRESULT OnStyleChange(UINT, WPARAM wParam, LPARAM lParam, BOOL&amp;) <br>{ <br>if (wParam == GWL_EXSTYLE) <br>{ <br>LPSTYLESTRUCT lpss = (LPSTYLESTRUCT) lParam; <br>lpss-&gt;styleNew |= WS_EX_CONTROLPARENT; <br>return 0; <br>} <br>return 1; <br>} <br> <br>LPOLESTR LoadStringHelper(UINT idRes) <br>{ <br>USES_CONVERSION; <br> <br>TCHAR szTemp[_MAX_PATH]; <br>LPOLESTR sz = (LPOLESTR)CoTaskMemAlloc(_MAX_PATH*sizeof(OLECHAR)); <br>if (sz == NULL) <br>return NULL; <br>sz[0] = NULL; <br> <br>if (LoadString(_Module.GetResourceInstance(), idRes, szTemp, _MAX_PATH)) <br>ocscpy(sz, T2OLE(szTemp)); <br>else <br>{ <br>ATLTRACE(_T("Error : Failed to load string from res\n")); <br>} <br> <br>return sz; <br>} <br> <br>void GetDialogSize(const DLGTEMPLATE* pTemplate, SIZE* pSize) <br>{ <br>// If the dialog has a font we use it otherwise we default <br>// to the system font. <br>if (HasFont(pTemplate)) <br>{ <br>TCHAR szFace[LF_FACESIZE]; <br>WORD  wFontSize = 0; <br>GetFont(pTemplate, szFace, &amp;wFontSize); <br>GetSizeInDialogUnits(pTemplate, pSize); <br>ConvertDialogUnitsToPixels(szFace, wFontSize, pSize); <br>} <br>else <br>{ <br>GetSizeInDialogUnits(pTemplate, pSize); <br>LONG nDlgBaseUnits = GetDialogBaseUnits(); <br>pSize-&gt;cx = MulDiv(pSize-&gt;cx, LOWORD(nDlgBaseUnits), 4); <br>pSize-&gt;cy = MulDiv(pSize-&gt;cy, HIWORD(nDlgBaseUnits), 8); <br>} <br>} <br> <br>static void ConvertDialogUnitsToPixels(LPCTSTR pszFontFace, WORD wFontSize, SIZE* pSizePixel) <br>{ <br>// Attempt to create the font to be used in the dialog box <br>UINT cxSysChar, cySysChar; <br>LOGFONT lf; <br>HDC hDC = ::GetDC(NULL); <br>int cxDlg = pSizePixel-&gt;cx; <br>int cyDlg = pSizePixel-&gt;cy; <br> <br>ZeroMemory(&amp;lf, sizeof(LOGFONT)); <br>lf.lfHeight = -MulDiv(wFontSize, GetDeviceCaps(hDC, LOGPIXELSY), 72); <br>lf.lfWeight = FW_NORMAL; <br>lf.lfCharSet = DEFAULT_CHARSET; <br>lstrcpy(lf.lfFaceName, pszFontFace); <br> <br>HFONT hNewFont = CreateFontIndirect(&amp;lf); <br>if (hNewFont != NULL) <br>{ <br>TEXTMETRIC  tm; <br>SIZE        size; <br>HFONT       hFontOld = (HFONT)SelectObject(hDC, hNewFont); <br>GetTextMetrics(hDC, &amp;tm); <br>cySysChar = tm.tmHeight + tm.tmExternalLeading; <br>::GetTextExtentPoint(hDC, <br>_T("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"), 52, <br>&amp;size); <br>cxSysChar = (size.cx + 26) / 52; <br>SelectObject(hDC, hFontOld); <br>DeleteObject(hNewFont); <br>} <br>else <br>{ <br>// Could not create the font so just use the system's values <br>cxSysChar = LOWORD(GetDialogBaseUnits()); <br>cySysChar = HIWORD(GetDialogBaseUnits()); <br>} <br>::ReleaseDC(NULL, hDC); <br> <br>// Translate dialog units to pixels <br>pSizePixel-&gt;cx = MulDiv(cxDlg, cxSysChar, 4); <br>pSizePixel-&gt;cy = MulDiv(cyDlg, cySysChar, 8); <br>} <br> <br>static BOOL IsDialogEx(const DLGTEMPLATE* pTemplate) <br>{ <br>return ((_ATL_DLGTEMPLATEEX*)pTemplate)-&gt;signature == 0xFFFF; <br>} <br> <br>static BOOL HasFont(const DLGTEMPLATE* pTemplate) <br>{ <br>return (DS_SETFONT &amp; <br>(IsDialogEx(pTemplate) ? <br>((_ATL_DLGTEMPLATEEX*)pTemplate)-&gt;style : pTemplate-&gt;style)); <br>} <br> <br>static BYTE* GetFontSizeField(const DLGTEMPLATE* pTemplate) <br>{ <br>BOOL bDialogEx = IsDialogEx(pTemplate); <br>WORD* pw; <br> <br>if (bDialogEx) <br>pw = (WORD*)((_ATL_DLGTEMPLATEEX*)pTemplate + 1); <br>else <br>pw = (WORD*)(pTemplate + 1); <br> <br>if (*pw == (WORD)-1)        // Skip menu name string or ordinal <br>pw += 2; // WORDs <br>else <br>while(*pw++); <br> <br>if (*pw == (WORD)-1)        // Skip class name string or ordinal <br>pw += 2; // WORDs <br>else <br>while(*pw++); <br> <br>while (*pw++);          // Skip caption string <br> <br>return (BYTE*)pw; <br>} <br> <br>static BOOL GetFont(const DLGTEMPLATE* pTemplate, TCHAR* pszFace, WORD* pFontSize) <br>{ <br>USES_CONVERSION; <br>if (!HasFont(pTemplate)) <br>return FALSE; <br> <br>BYTE* pb = GetFontSizeField(pTemplate); <br>*pFontSize = *(WORD*)pb; <br>// Skip over font attributes to get to the font name <br>pb += sizeof(WORD) * (IsDialogEx(pTemplate) ? 3 : 1); <br> <br>_tcscpy(pszFace, W2T((WCHAR*)pb)); <br>return TRUE; <br>} <br> <br>static void GetSizeInDialogUnits(const DLGTEMPLATE* pTemplate, SIZE* pSize) <br>{ <br>if (IsDialogEx(pTemplate)) <br>{ <br>pSize-&gt;cx = ((_ATL_DLGTEMPLATEEX*)pTemplate)-&gt;cx; <br>pSize-&gt;cy = ((_ATL_DLGTEMPLATEEX*)pTemplate)-&gt;cy; <br>} <br>else <br>{ <br>pSize-&gt;cx = pTemplate-&gt;cx; <br>pSize-&gt;cy = pTemplate-&gt;cy; <br>} <br>} <br>}; <br> <br> <br>////////////////////////////////////////////////////////////////////////////// <br>// IPropertyPage2Impl <br>template &lt;class T&gt; <br>class ATL_NO_VTABLE IPropertyPage2Impl : public IPropertyPageImpl&lt;T&gt; <br>{ <br>public: <br> <br>STDMETHOD(EditProperty)(DISPID dispID) <br>{ <br>ATLTRACENOTIMPL(_T("IPropertyPage2Impl::EditProperty\n")); <br>} <br>}; <br> <br> <br> <br>////////////////////////////////////////////////////////////////////////////// <br>// IPerPropertyBrowsingImpl <br>template &lt;class T&gt; <br>class ATL_NO_VTABLE IPerPropertyBrowsingImpl <br>{ <br>public: <br>// IUnknown <br>// <br>STDMETHOD(QueryInterface)(REFIID riid, void ** ppvObject) = 0; <br>_ATL_DEBUG_ADDREF_RELEASE_IMPL(IPerPropertyBrowsingImpl) <br> <br>STDMETHOD(GetDisplayString)(DISPID dispID,BSTR *pBstr) <br>{ <br>ATLTRACE(_T("IPerPropertyBrowsingImpl::GetDisplayString\n")); <br>T* pT = static_cast&lt;T*&gt;(this); <br>CComVariant var; <br>if (FAILED(CComDispatchDriver::GetProperty(pT, dispID, &amp;var))) <br>{ <br>*pBstr = NULL; <br>return S_FALSE; <br>} <br> <br>BSTR bstrTemp = var.bstrVal; <br>if (var.vt != VT_BSTR) <br>{ <br>CComVariant varDest; <br>if (FAILED(::VariantChangeType(&amp;varDest, &amp;var, VARIANT_NOVALUEPROP, VT_BSTR))) <br>{ <br>*pBstr = NULL; <br>return S_FALSE; <br>} <br>bstrTemp = varDest.bstrVal; <br>} <br>*pBstr = SysAllocString(bstrTemp); <br>return S_OK; <br>} <br> <br>STDMETHOD(MapPropertyToPage)(DISPID dispID, CLSID *pClsid) <br>{ <br>ATLTRACE(_T("IPerPropertyBrowsingImpl::MapPropertyToPage\n")); <br>T* pT = static_cast&lt;T*&gt;(this); <br>ATL_PROPMAP_ENTRY* pMap = T::GetPropertyMap(); <br>_ASSERTE(pMap != NULL); <br>for(int i = 0; pMap[i].pclsidPropPage != NULL; i++) <br>{ <br>if (pMap[i].szDesc == NULL) <br>continue; <br>if (pMap[i].dispid == dispID) <br>{ <br>_ASSERTE(pMap[i].pclsidPropPage != NULL); <br>*pClsid = *(pMap[i].pclsidPropPage); <br>return S_OK; <br>} <br>} <br>*pClsid = CLSID_NULL; <br>return E_INVALIDARG; <br>} <br>STDMETHOD(GetPredefinedStrings)(DISPID dispID, CALPOLESTR *pCaStringsOut,CADWORD *pCaCookiesOut) <br>{ <br>dispID; <br>ATLTRACE(_T("IPerPropertyBrowsingImpl::GetPredefinedStrings\n")); <br>if (pCaStringsOut == NULL || pCaCookiesOut == NULL) <br>return E_POINTER; <br> <br>pCaStringsOut-&gt;cElems = 0; <br>pCaStringsOut-&gt;pElems = NULL; <br>pCaCookiesOut-&gt;cElems = 0; <br>pCaCookiesOut-&gt;pElems = NULL; <br>return S_OK; <br>} <br>STDMETHOD(GetPredefinedValue)(DISPID /*dispID*/, DWORD /*dwCookie*/, VARIANT* /*pVarOut*/) <br>{ <br>ATLTRACENOTIMPL(_T("IPerPropertyBrowsingImpl::GetPredefinedValue")); <br>} <br>}; <br> <br>////////////////////////////////////////////////////////////////////////////// <br>// IViewObjectExImpl <br>template &lt;class T&gt; <br>class ATL_NO_VTABLE IViewObjectExImpl <br>{ <br>public: <br>// IUnknown <br>// <br>STDMETHOD(QueryInterface)(REFIID riid, void ** ppvObject) = 0; <br>_ATL_DEBUG_ADDREF_RELEASE_IMPL(IViewObjectExImpl) <br> <br>// IViewObject <br>// <br>STDMETHOD(Draw)(DWORD dwDrawAspect, LONG lindex, void *pvAspect, <br>DVTARGETDEVICE *ptd, HDC hicTargetDev, HDC hdcDraw, <br>LPCRECTL prcBounds, LPCRECTL prcWBounds, <br>BOOL (__stdcall * /*pfnContinue*/)(DWORD dwContinue), <br>DWORD /*dwContinue*/) <br>{ <br>T* pT = static_cast&lt;T*&gt;(this); <br>ATLTRACE(_T("IViewObjectExImpl::Draw\n")); <br>return pT-&gt;IViewObject_Draw(dwDrawAspect, lindex, pvAspect, ptd, hicTargetDev, hdcDraw, <br>prcBounds, prcWBounds); <br>} <br> <br>STDMETHOD(GetColorSet)(DWORD /* dwDrawAspect */,LONG /* lindex */, void* /* pvAspect */, DVTARGETDEVICE* /* ptd */, HDC /* hicTargetDev */, LOGPALETTE** /* ppColorSet */) <br>{ <br>ATLTRACENOTIMPL(_T("IViewObjectExImpl::GetColorSet")); <br>} <br>STDMETHOD(Freeze)(DWORD /* dwDrawAspect */, LONG /* lindex */, void* /* pvAspect */,DWORD* /* pdwFreeze */) <br>{ <br>ATLTRACENOTIMPL(_T("IViewObjectExImpl::Freeze")); <br>} <br>STDMETHOD(Unfreeze)(DWORD /* dwFreeze */) <br>{ <br>ATLTRACENOTIMPL(_T("IViewObjectExImpl::Unfreeze")); <br>} <br>STDMETHOD(SetAdvise)(DWORD /* aspects */, DWORD /* advf */, IAdviseSink* pAdvSink) <br>{ <br>T* pT = static_cast&lt;T*&gt;(this); <br>ATLTRACE(_T("IViewObjectExImpl::SetAdvise\n")); <br>pT-&gt;m_spAdviseSink = pAdvSink; <br>return S_OK; <br>} <br>STDMETHOD(GetAdvise)(DWORD* /* pAspects */, DWORD* /* pAdvf */, IAdviseSink** ppAdvSink) <br>{ <br>T* pT = static_cast&lt;T*&gt;(this); <br>ATLTRACE(_T("IViewObjectExImpl::GetAdvise\n")); <br>if (ppAdvSink != NULL) <br>{ <br>*ppAdvSink = pT-&gt;m_spAdviseSink; <br>if (pT-&gt;m_spAdviseSink) <br>pT-&gt;m_spAdviseSink-&gt;AddRef(); <br>} <br>return S_OK; <br>} <br> <br>// IViewObject2 <br>// <br>STDMETHOD(GetExtent)(DWORD /* dwDrawAspect */, LONG /* lindex */, DVTARGETDEVICE* /* ptd */, LPSIZEL lpsizel) <br>{ <br>T* pT = static_cast&lt;T*&gt;(this); <br>ATLTRACE(_T("IViewObjectExImpl::GetExtent\n")); <br>*lpsizel = pT-&gt;m_sizeExtent; <br>return S_OK; <br>} <br> <br>// IViewObjectEx <br>// <br>STDMETHOD(GetRect)(DWORD /* dwAspect */, LPRECTL /* pRect */) <br>{ <br>ATLTRACENOTIMPL(_T("IViewObjectExImpl::GetRect")); <br>} <br>STDMETHOD(GetViewStatus)(DWORD* pdwStatus) <br>{ <br>ATLTRACE(_T("IViewObjectExImpl::GetViewStatus\n")); <br>*pdwStatus = <br>//          VIEWSTATUS_DVASPECTOPAQUE | VIEWSTATUS_DVASPECTTRANSPARENT | <br>//          VIEWSTATUS_SOLIDBKGND | <br>VIEWSTATUS_OPAQUE; <br> <br>return S_OK; <br>} <br>STDMETHOD(QueryHitPoint)(DWORD dwAspect, LPCRECT pRectBounds, POINT ptlLoc, LONG /* lCloseHint */, DWORD *pHitResult) <br>{ <br>ATLTRACE(_T("IViewObjectExImpl::QueryHitPoint\n")); <br>if (dwAspect == DVASPECT_CONTENT) <br>{ <br>*pHitResult = PtInRect(pRectBounds, ptlLoc) ? HITRESULT_HIT : HITRESULT_OUTSIDE; <br>return S_OK; <br>} <br>ATLTRACE(_T("Wrong DVASPECT\n")); <br>return E_FAIL; <br>} <br>STDMETHOD(QueryHitRect)(DWORD dwAspect, LPCRECT pRectBounds, LPCRECT prcLoc, LONG /* lCloseHint */, DWORD* pHitResult) <br>{ <br>ATLTRACE(_T("IViewObjectExImpl::QueryHitRect\n")); <br>if (dwAspect == DVASPECT_CONTENT) <br>{ <br>RECT rc; <br>*pHitResult = UnionRect(&amp;rc, pRectBounds, prcLoc) ? HITRESULT_HIT : HITRESULT_OUTSIDE; <br>return S_OK; <br>} <br>ATLTRACE(_T("Wrong DVASPECT\n")); <br>return E_FAIL; <br>} <br>STDMETHOD(GetNaturalExtent)(DWORD dwAspect, LONG /* lindex */, DVTARGETDEVICE* /* ptd */, HDC /* hicTargetDev */, DVEXTENTINFO* pExtentInfo , LPSIZEL psizel) <br>{ <br>T* pT = static_cast&lt;T*&gt;(this); <br>ATLTRACE(_T("IViewObjectExImpl::GetNaturalExtent\n")); <br>HRESULT hRes = E_FAIL; <br>if (dwAspect == DVASPECT_CONTENT) <br>{ <br>if (pExtentInfo-&gt;dwExtentMode == DVEXTENT_CONTENT) <br>{ <br>*psizel = pT-&gt;m_sizeNatural; <br>hRes = S_OK; <br>} <br>} <br>return hRes; <br>} <br> <br>public: <br>}; <br> <br>////////////////////////////////////////////////////////////////////////////// <br>// IOleInPlaceObjectWindowlessImpl <br>// <br>template &lt;class T&gt; <br>class ATL_NO_VTABLE IOleInPlaceObjectWindowlessImpl <br>{ <br>public: <br>// IUnknown <br>// <br>STDMETHOD(QueryInterface)(REFIID riid, void ** ppvObject) = 0; <br>_ATL_DEBUG_ADDREF_RELEASE_IMPL(IOleInPlaceObjectWindowlessImpl) <br> <br>// IOleWindow <br>// <br> <br>// Change IOleInPlaceActiveObject::GetWindow as well <br>STDMETHOD(GetWindow)(HWND* phwnd) <br>{ <br>ATLTRACE(_T("IOleInPlaceObjectWindowlessImpl::GetWindow\n")); <br>T* pT = static_cast&lt;T*&gt;(this); <br>HRESULT hRes = E_POINTER; <br> <br>if (pT-&gt;m_bWasOnceWindowless) <br>return E_FAIL; <br> <br>if (phwnd != NULL) <br>{ <br>*phwnd = pT-&gt;m_hWnd; <br>hRes = (*phwnd == NULL) ? E_UNEXPECTED : S_OK; <br>} <br>return hRes; <br>} <br>STDMETHOD(ContextSensitiveHelp)(BOOL /* fEnterMode */) <br>{ <br>ATLTRACENOTIMPL(_T("IOleInPlaceObjectWindowlessImpl::ContextSensitiveHelp")); <br>} <br> <br>// IOleInPlaceObject <br>// <br>STDMETHOD(InPlaceDeactivate)(void) <br>{ <br>T* pT = static_cast&lt;T*&gt;(this); <br>ATLTRACE(_T("IOleInPlaceObjectWindowlessImpl::InPlaceDeactivate\n")); <br>return pT-&gt;IOleInPlaceObject_InPlaceDeactivate(); <br>} <br>STDMETHOD(UIDeactivate)(void) <br>{ <br>T* pT = static_cast&lt;T*&gt;(this); <br>ATLTRACE(_T("IOleInPlaceObjectWindowlessImpl::UIDeactivate\n")); <br>return pT-&gt;IOleInPlaceObject_UIDeactivate(); <br>} <br>STDMETHOD(SetObjectRects)(LPCRECT prcPos,LPCRECT prcClip) <br>{ <br>T* pT = static_cast&lt;T*&gt;(this); <br>ATLTRACE(_T("IOleInPlaceObjectWindowlessImpl::SetObjectRects\n")); <br>return pT-&gt;IOleInPlaceObject_SetObjectRects(prcPos, prcClip); <br>} <br>STDMETHOD(ReactivateAndUndo)(void) <br>{ <br>ATLTRACENOTIMPL(_T("IOleInPlaceObjectWindowlessImpl::ReactivateAndUndo")); <br>} <br> <br>// IOleInPlaceObjectWindowless <br>// <br>STDMETHOD(OnWindowMessage)(UINT msg, WPARAM wParam, LPARAM lParam, LRESULT *plResult) <br>{ <br>ATLTRACE(_T("IOleInPlaceObjectWindowlessImpl::OnWindowMessage\n")); <br>T* pT = static_cast&lt;T*&gt;(this); <br>return pT-&gt;ProcessWindowMessage(pT-&gt;m_hWnd, msg, wParam, lParam, *plResult); <br>} <br> <br>STDMETHOD(GetDropTarget)(IDropTarget** /* ppDropTarget */) <br>{ <br>ATLTRACENOTIMPL(_T("IOleInPlaceObjectWindowlessImpl::GetDropTarget")); <br>} <br>}; <br> <br> <br>////////////////////////////////////////////////////////////////////////////// <br>// IOleInPlaceActiveObjectImpl <br>// <br>template &lt;class T&gt; <br>class ATL_NO_VTABLE IOleInPlaceActiveObjectImpl <br>{ <br>public: <br>// IUnknown <br>// <br>STDMETHOD(QueryInterface)(REFIID riid, void ** ppvObject) = 0; <br>_ATL_DEBUG_ADDREF_RELEASE_IMPL(IOleInPlaceActiveObjectImpl) <br> <br>// IOleWindow <br>// <br> <br>// Change IOleInPlaceObjectWindowless::GetWindow as well <br>STDMETHOD(GetWindow)(HWND *phwnd) <br>{ <br>ATLTRACE(_T("IOleInPlaceActiveObjectImpl::GetWindow\n")); <br>T* pT = static_cast&lt;T*&gt;(this); <br>HRESULT hRes = E_POINTER; <br> <br>if (pT-&gt;m_bWasOnceWindowless) <br>return E_FAIL; <br> <br>if (phwnd != NULL) <br>{ <br>*phwnd = pT-&gt;m_hWnd; <br>hRes = (*phwnd == NULL) ? E_UNEXPECTED : S_OK; <br>} <br>return hRes; <br>} <br>STDMETHOD(ContextSensitiveHelp)(BOOL /* fEnterMode */) <br>{ <br>ATLTRACENOTIMPL(_T("IOleInPlaceActiveObjectImpl::ContextSensitiveHelp")); <br>} <br> <br>// IOleInPlaceActiveObject <br>// <br>STDMETHOD(TranslateAccelerator)(LPMSG /* lpmsg */) <br>{ <br>ATLTRACE(_T("IOleInPlaceActiveObjectImpl::TranslateAccelerator\n")); <br>return E_NOTIMPL; <br>} <br>STDMETHOD(OnFrameWindowActivate)(BOOL /* fActivate */) <br>{ <br>ATLTRACE(_T("IOleInPlaceActiveObjectImpl::OnFrameWindowActivate\n")); <br>return S_OK; <br>} <br>STDMETHOD(OnDocWindowActivate)(BOOL /* fActivate */) <br>{ <br>ATLTRACE(_T("IOleInPlaceActiveObjectImpl::OnDocWindowActivate\n")); <br>return S_OK; <br>} <br>STDMETHOD(ResizeBorder)(LPCRECT /* prcBorder */, IOleInPlaceUIWindow* /* pUIWindow */, BOOL /* fFrameWindow */) <br>{ <br>ATLTRACE(_T("IOleInPlaceActiveObjectImpl::ResizeBorder\n")); <br>return S_OK; <br>} <br>STDMETHOD(EnableModeless)(BOOL /* fEnable */) <br>{ <br>ATLTRACE(_T("IOleInPlaceActiveObjectImpl::EnableModeless\n")); <br>return S_OK; <br>} <br>}; <br> <br> <br>////////////////////////////////////////////////////////////////////////////// <br>// ISpecifyPropertyPagesImpl <br>template &lt;class T&gt; <br>class ATL_NO_VTABLE ISpecifyPropertyPagesImpl <br>{ <br>public: <br>// IUnknown <br>// <br>STDMETHOD(QueryInterface)(REFIID riid, void ** ppvObject) = 0; <br>_ATL_DEBUG_ADDREF_RELEASE_IMPL(ISpecifyPropertyPagesImpl) <br> <br>// ISpecifyPropertyPages <br>// <br>STDMETHOD(GetPages)(CAUUID* pPages) <br>{ <br>ATLTRACE(_T("ISpecifyPropertyPagesImpl::GetPages\n")); <br>T* pT = static_cast&lt;T*&gt;(this); <br>ATL_PROPMAP_ENTRY* pMap = T::GetPropertyMap(); <br>return pT-&gt;ISpecifyPropertyPages_GetPages(pPages, pMap); <br>} <br>}; <br> <br>////////////////////////////////////////////////////////////////////////////// <br>// IPointerInactiveImpl <br>template &lt;class T&gt; <br>class ATL_NO_VTABLE IPointerInactiveImpl <br>{ <br>public: <br>// IUnknown <br>// <br>STDMETHOD(QueryInterface)(REFIID riid, void ** ppvObject) = 0; <br>_ATL_DEBUG_ADDREF_RELEASE_IMPL(IPointerInactiveImpl) <br> <br>// IPointerInactive <br>// <br>STDMETHOD(GetActivationPolicy)(DWORD *pdwPolicy) <br>{ <br>ATLTRACENOTIMPL(_T("IPointerInactiveImpl::GetActivationPolicy")); <br>} <br>STDMETHOD(OnInactiveMouseMove)(LPCRECT pRectBounds, long x, long y, DWORD dwMouseMsg) <br>{ <br>ATLTRACENOTIMPL(_T("IPointerInactiveImpl::OnInactiveMouseMove")); <br>} <br>STDMETHOD(OnInactiveSetCursor)(LPCRECT pRectBounds, long x, long y, DWORD dwMouseMsg, BOOL fSetAlways) <br>{ <br>ATLTRACENOTIMPL(_T("IPointerInactiveImpl::OnInactiveSetCursor")); <br>} <br>}; <br> <br>////////////////////////////////////////////////////////////////////////////// <br>// IRunnableObjectImpl <br>template &lt;class T&gt; <br>class ATL_NO_VTABLE IRunnableObjectImpl <br>{ <br>public: <br>// IUnknown <br>// <br>STDMETHOD(QueryInterface)(REFIID riid, void ** ppvObject) = 0; <br>_ATL_DEBUG_ADDREF_RELEASE_IMPL(IRunnableObjectImpl) <br> <br>// IRunnableObject <br>// <br>STDMETHOD(GetRunningClass)(LPCLSID lpClsid) <br>{ <br>ATLTRACE(_T("IRunnableObjectImpl::GetRunningClass\n")); <br>T* pT = static_cast&lt;T*&gt;(this); <br>*lpClsid = GUID_NULL; <br>return E_UNEXPECTED; <br>} <br>STDMETHOD(Run)(LPBINDCTX) <br>{ <br>ATLTRACE(_T("IRunnableObjectImpl::Run\n")); <br>return S_OK; <br>} <br>virtual BOOL STDMETHODCALLTYPE IsRunning() <br>{ <br>ATLTRACE(_T("IRunnableObjectImpl::IsRunning\n")); <br>return TRUE; <br>} <br>STDMETHOD(LockRunning)(BOOL /*fLock*/, BOOL /*fLastUnlockCloses*/) <br>{ <br>ATLTRACE(_T("IRunnableObjectImpl::LockRunning\n")); <br>return S_OK; <br>} <br>STDMETHOD(SetContainedObject)(BOOL /*fContained*/) <br>{ <br>ATLTRACE(_T("IRunnableObjectImpl::SetContainedObject\n")); <br>return S_OK; <br>} <br>}; <br> <br> <br>////////////////////////////////////////////////////////////////////////////// <br>// IDataObjectImpl <br>template &lt;class T&gt; <br>class ATL_NO_VTABLE IDataObjectImpl <br>{ <br>public: <br>// IUnknown <br>// <br>STDMETHOD(QueryInterface)(REFIID riid, void ** ppvObject) = 0; <br>_ATL_DEBUG_ADDREF_RELEASE_IMPL(IDataObjectImpl) <br> <br>// IDataObject <br>// <br>STDMETHOD(GetData)(FORMATETC *pformatetcIn, STGMEDIUM *pmedium) <br>{ <br>ATLTRACE(_T("IDataObjectImpl::GetData\n")); <br>T* pT = (T*) this; <br>return pT-&gt;IDataObject_GetData(pformatetcIn, pmedium); <br>} <br>STDMETHOD(GetDataHere)(FORMATETC* /* pformatetc */, STGMEDIUM* /* pmedium */) <br>{ <br>ATLTRACENOTIMPL(_T("IDataObjectImpl::GetDataHere")); <br>} <br>STDMETHOD(QueryGetData)(FORMATETC* /* pformatetc */) <br>{ <br>ATLTRACENOTIMPL(_T("IDataObjectImpl::QueryGetData")); <br>} <br>STDMETHOD(GetCanonicalFormatEtc)(FORMATETC* /* pformatectIn */,FORMATETC* /* pformatetcOut */) <br>{ <br>ATLTRACENOTIMPL(_T("IDataObjectImpl::GetCanonicalFormatEtc")); <br>} <br>STDMETHOD(SetData)(FORMATETC* /* pformatetc */, STGMEDIUM* /* pmedium */, BOOL /* fRelease */) <br>{ <br>ATLTRACENOTIMPL(_T("IDataObjectImpl::SetData")); <br>} <br>STDMETHOD(EnumFormatEtc)(DWORD /* dwDirection */, IEnumFORMATETC** /* ppenumFormatEtc */) <br>{ <br>ATLTRACENOTIMPL(_T("IDataObjectImpl::EnumFormatEtc")); <br>} <br>STDMETHOD(DAdvise)(FORMATETC *pformatetc, DWORD advf, IAdviseSink *pAdvSink, <br>DWORD *pdwConnection) <br>{ <br>ATLTRACE(_T("IDataObjectImpl::DAdvise\n")); <br>T* pT = static_cast&lt;T*&gt;(this); <br>HRESULT hr = S_OK; <br>if (pT-&gt;m_spDataAdviseHolder == NULL) <br>hr = CreateDataAdviseHolder(&amp;pT-&gt;m_spDataAdviseHolder); <br> <br>if (hr == S_OK) <br>hr = pT-&gt;m_spDataAdviseHolder-&gt;Advise((IDataObject*)this, pformatetc, advf, pAdvSink, pdwConnection); <br> <br>return hr; <br>} <br>STDMETHOD(DUnadvise)(DWORD dwConnection) <br>{ <br>ATLTRACE(_T("IDataObjectImpl::DUnadvise\n")); <br>T* pT = static_cast&lt;T*&gt;(this); <br>HRESULT hr = S_OK; <br>if (pT-&gt;m_spDataAdviseHolder == NULL) <br>hr = OLE_E_NOCONNECTION; </code></pre>
<p>
</p>
<pre><code>else <br>hr = pT-&gt;m_spDataAdviseHolder-&gt;Unadvise(dwConnection); <br>return hr; <br>} <br>STDMETHOD(EnumDAdvise)(IEnumSTATDATA **ppenumAdvise) <br>{ <br>ATLTRACE(_T("IDataObjectImpl::EnumDAdvise\n")); <br>T* pT = static_cast&lt;T*&gt;(this); <br>HRESULT hr = E_FAIL; <br>if (pT-&gt;m_spDataAdviseHolder != NULL) <br>hr = pT-&gt;m_spDataAdviseHolder-&gt;EnumAdvise(ppenumAdvise); <br>return hr; <br>} <br>}; <br> <br>////////////////////////////////////////////////////////////////////////////// <br>// IPropertyNotifySinkCP <br>template &lt;class T, class CDV = CComDynamicUnkArray &gt; <br>class ATL_NO_VTABLE IPropertyNotifySinkCP : <br>public IConnectionPointImpl&lt;T, &amp;IID_IPropertyNotifySink, CDV&gt; <br>{ <br>public: <br>typedef CFirePropNotifyEvent _ATL_PROP_NOTIFY_EVENT_CLASS; <br>}; <br> <br> <br>////////////////////////////////////////////////////////////////////////////// <br>// IObjectSafety <br>// <br> <br>template &lt;class T&gt; <br>class ATL_NO_VTABLE IObjectSafetyImpl <br>{ <br>public: <br>IObjectSafetyImpl() <br>{ <br>m_dwSafety = 0; <br>} <br> <br>// IUnknown <br>// <br>STDMETHOD(QueryInterface)(REFIID riid, void ** ppvObject) = 0; <br>_ATL_DEBUG_ADDREF_RELEASE_IMPL(IObjectSafetyImpl) <br> <br>// IObjectSafety <br>// <br>STDMETHOD(GetInterfaceSafetyOptions)(REFIID riid, DWORD *pdwSupportedOptions, DWORD *pdwEnabledOptions) <br>{ <br>ATLTRACE(_T("IObjectSafetyImpl::GetInterfaceSafetyOptions\n")); <br>if (pdwSupportedOptions == NULL || pdwEnabledOptions == NULL) <br>return E_POINTER; <br>HRESULT hr = S_OK; <br>if (riid == IID_IDispatch) <br>{ <br>*pdwSupportedOptions = INTERFACESAFE_FOR_UNTRUSTED_CALLER; <br>*pdwEnabledOptions = m_dwSafety &amp; INTERFACESAFE_FOR_UNTRUSTED_CALLER; <br>} <br>else <br>{ <br>*pdwSupportedOptions = 0; <br>*pdwEnabledOptions = 0; <br>hr = E_NOINTERFACE; <br>} <br>return hr; <br>} <br>STDMETHOD(SetInterfaceSafetyOptions)(REFIID riid, DWORD dwOptionSetMask, DWORD dwEnabledOptions) <br>{ <br>ATLTRACE(_T("IObjectSafetyImpl::SetInterfaceSafetyOptions\n")); <br>// If we're being asked to set our safe for scripting option then oblige <br>if (riid == IID_IDispatch) <br>{ <br>// Store our current safety level to return in GetInterfaceSafetyOptions <br>m_dwSafety = dwEnabledOptions &amp; dwOptionSetMask; <br>return S_OK; <br>} <br>return E_NOINTERFACE; <br>} <br> <br>DWORD m_dwSafety; <br>}; <br> <br> <br>template &lt;class T&gt; <br>class ATL_NO_VTABLE IOleLinkImpl <br>{ <br>// IUnknown <br>// <br>STDMETHOD(QueryInterface)(REFIID riid, void ** ppvObject) = 0; <br>_ATL_DEBUG_ADDREF_RELEASE_IMPL(IOleLinkImpl) <br> <br>STDMETHOD(SetUpdateOptions)(DWORD /* dwUpdateOpt */) <br>{ <br>ATLTRACENOTIMPL(_T("IOleLinkImpl::SetUpdateOptions")); <br>} <br> <br>STDMETHOD(GetUpdateOptions)(DWORD* /* pdwUpdateOpt */) <br>{ <br>ATLTRACENOTIMPL(_T("IOleLinkImpl::GetUpdateOptions")); <br>} <br> <br>STDMETHOD(SetSourceMoniker)(IMoniker* /* pmk */, REFCLSID /* rclsid */) <br>{ <br>ATLTRACENOTIMPL(_T("IOleLinkImpl::SetSourceMoniker")); <br>} <br> <br>STDMETHOD(GetSourceMoniker)(IMoniker** /* ppmk */) <br>{ <br>ATLTRACENOTIMPL(_T("IOleLinkImpl::GetSourceMoniker")); <br>}; <br> <br>STDMETHOD(SetSourceDisplayName)(LPCOLESTR /* pszStatusText */) <br>{ <br>ATLTRACENOTIMPL(_T("IOleLinkImpl::SetSourceDisplayName")); <br>} <br> <br>STDMETHOD(GetSourceDisplayName)(LPOLESTR *ppszDisplayName) <br>{ <br>ATLTRACE(_T("IOleLink::GetSourceDisplayName\n")); <br>*ppszDisplayName = NULL; <br>return E_FAIL; <br>} <br> <br>STDMETHOD(BindToSource)(DWORD /* bindflags */, IBindCtx* /* pbc */) <br>{ <br>ATLTRACENOTIMPL(_T("IOleLinkImpl::BindToSource\n")); <br>}; <br> <br>STDMETHOD(BindIfRunning)() <br>{ <br>ATLTRACE(_T("IOleLinkImpl::BindIfRunning\n")); <br>return S_OK; <br>}; <br> <br>STDMETHOD(GetBoundSource)(IUnknown** /* ppunk */) <br>{ <br>ATLTRACENOTIMPL(_T("IOleLinkImpl::GetBoundSource")); <br>}; <br> <br>STDMETHOD(UnbindSource)() <br>{ <br>ATLTRACENOTIMPL(_T("IOleLinkImpl::UnbindSource")); <br>}; <br> <br>STDMETHOD(Update)(IBindCtx* /* pbc */) <br>{ <br>ATLTRACENOTIMPL(_T("IOleLinkImpl::Update")); <br>}; <br>}; <br> <br> <br>template &lt;class T&gt; <br>class ATL_NO_VTABLE IBindStatusCallbackImpl <br>{ <br>public: <br>// IUnknown <br>// <br>STDMETHOD(QueryInterface)(REFIID riid, void ** ppvObject) = 0; <br>_ATL_DEBUG_ADDREF_RELEASE_IMPL(IBindStatusCallbackImpl) <br> <br>// IBindStatusCallback <br>// <br>STDMETHOD(OnStartBinding)(DWORD /* dwReserved */, IBinding *pBinding) <br>{ <br>ATLTRACE(_T("IBindStatusCallbackImpl::OnStartBinding\n")); <br>return S_OK; <br>} <br> <br>STDMETHOD(GetPriority)(LONG* /* pnPriority */) <br>{ <br>ATLTRACENOTIMPL(_T("IBindStatusCallbackImpl::GetPriority")); <br>} <br> <br>STDMETHOD(OnLowResource)(DWORD /* reserved */) <br>{ <br>ATLTRACE(_T("IBindStatusCallbackImpl::OnLowResource\n")); <br>return S_OK; <br>} <br> <br>STDMETHOD(OnProgress)(ULONG /* ulProgress */, ULONG /* ulProgressMax */, ULONG /* ulStatusCode */, LPCWSTR /* szStatusText */) <br>{ <br>ATLTRACE(_T("IBindStatusCallbackImpl::OnProgress\n")); <br>return S_OK; <br>} <br> <br>STDMETHOD(OnStopBinding)(HRESULT /* hresult */, LPCWSTR /* szError */) <br>{ <br>ATLTRACE(_T("IBindStatusCallbackImpl::OnStopBinding\n")); <br>return S_OK; <br>} <br> <br>STDMETHOD(GetBindInfo)(DWORD* /* pgrfBINDF */, BINDINFO* /* pBindInfo */) <br>{ <br>ATLTRACE(_T("IBindStatusCallbackImpl::GetBindInfo\n")); <br>return S_OK; <br>} <br> <br>STDMETHOD(OnDataAvailable)(DWORD grfBSCF, DWORD dwSize, FORMATETC *pformatetc, STGMEDIUM *pstgmed) <br>{ <br>ATLTRACE(_T("IBindStatusCallbackImpl::OnDataAvailable\n")); <br>return S_OK; <br>} <br> <br>STDMETHOD(OnObjectAvailable)(REFIID /* riid */, IUnknown* /* punk */) <br>{ <br>ATLTRACE(_T("IBindStatusCallbackImpl::OnObjectAvailable\n")); <br>return S_OK; <br>} <br>}; <br> <br> <br>template &lt;class T&gt; <br>class ATL_NO_VTABLE CBindStatusCallback : <br>public CComObjectRootEx&lt;T::_ThreadModel::ThreadModelNoCS&gt;, <br>public IBindStatusCallbackImpl&lt;T&gt; <br>{ <br>typedef void (T::*ATL_PDATAAVAILABLE)(CBindStatusCallback&lt;T&gt;* pbsc, BYTE* pBytes, DWORD dwSize); <br> <br>public: <br> <br>BEGIN_COM_MAP(CBindStatusCallback&lt;T&gt;) <br>COM_INTERFACE_ENTRY_IID(IID_IBindStatusCallback, IBindStatusCallbackImpl&lt;T&gt;) <br>END_COM_MAP() <br> <br> <br>CBindStatusCallback() <br>{ <br>m_pT = NULL; <br>m_pFunc = NULL; <br>} <br>~CBindStatusCallback() <br>{ <br>ATLTRACE(_T("~CBindStatusCallback\n")); <br>} <br> <br>STDMETHOD(OnStartBinding)(DWORD dwReserved, IBinding *pBinding) <br>{ <br>ATLTRACE(_T("CBindStatusCallback::OnStartBinding\n")); <br>m_spBinding = pBinding; <br>return S_OK; <br>} <br> <br>STDMETHOD(GetPriority)(LONG *pnPriority) <br>{ <br>ATLTRACENOTIMPL(_T("CBindStatusCallback::GetPriority")); <br>} <br> <br>STDMETHOD(OnLowResource)(DWORD reserved) <br>{ <br>ATLTRACENOTIMPL(_T("CBindStatusCallback::OnLowResource")); <br>} <br> <br>STDMETHOD(OnProgress)(ULONG ulProgress, ULONG ulProgressMax, ULONG ulStatusCode, LPCWSTR szStatusText) <br>{ <br>ATLTRACENOTIMPL(_T("CBindStatusCallback::OnProgress")); <br>} <br> <br>STDMETHOD(OnStopBinding)(HRESULT hresult, LPCWSTR szError) <br>{ <br>ATLTRACE(_T("CBindStatusCallback::OnStopBinding\n")); <br>m_spBinding.Release(); <br>return S_OK; <br>} <br> <br>STDMETHOD(GetBindInfo)(DWORD *pgrfBINDF, BINDINFO *pbindInfo) <br>{ <br>ATLTRACE(_T("CBindStatusCallback::GetBindInfo\n")); <br>*pgrfBINDF = BINDF_ASYNCHRONOUS | BINDF_ASYNCSTORAGE | <br>BINDF_GETNEWESTVERSION | BINDF_NOWRITECACHE; <br>pbindInfo-&gt;cbSize = sizeof(BINDINFO); <br>pbindInfo-&gt;szExtraInfo = NULL; <br>memset(&amp;pbindInfo-&gt;stgmedData, 0, sizeof(STGMEDIUM)); <br>pbindInfo-&gt;grfBindInfoF = 0; <br>pbindInfo-&gt;dwBindVerb = BINDVERB_GET; <br>pbindInfo-&gt;szCustomVerb = NULL; <br>return S_OK; <br>} <br> <br>STDMETHOD(OnDataAvailable)(DWORD grfBSCF, DWORD dwSize, FORMATETC *pformatetc, STGMEDIUM *pstgmed) <br>{ <br>ATLTRACE(_T("CBindStatusCallback::OnDataAvailable\n")); <br>HRESULT hr = S_OK; <br> <br>// Get the Stream passed <br>if (BSCF_FIRSTDATANOTIFICATION &amp; grfBSCF) <br>{ <br>if (!m_spStream &amp;&amp; pstgmed-&gt;tymed == TYMED_ISTREAM) <br>{ <br>m_spStream = pstgmed-&gt;pstm; <br>if (m_spStream) <br>m_spStream-&gt;AddRef(); <br>} <br>} <br> <br>DWORD dwRead = dwSize - m_dwTotalRead; // Minimum amount available that hasn't been read <br>DWORD dwActuallyRead = 0;            // Placeholder for amount read during this pull <br> <br>// If there is some data to be read then go ahead and read them <br>if (m_spStream) <br>{ <br>if (dwRead &gt; 0) <br>{ <br>BYTE* pBytes = NULL; <br>ATLTRY(pBytes = new BYTE[dwRead + 1]); <br>if (pBytes == NULL) <br>return S_FALSE; <br>hr = m_spStream-&gt;Read(pBytes, dwRead, &amp;dwActuallyRead); <br>if (SUCCEEDED(hr)) <br>{ <br>pBytes[dwActuallyRead] = 0; <br>if (dwActuallyRead&gt;0) <br>{ <br>(m_pT-&gt;*m_pFunc)(this, pBytes, dwActuallyRead); <br>m_dwTotalRead += dwActuallyRead; <br>} <br>} <br>delete[] pBytes; <br>} <br>} <br> <br>if (BSCF_LASTDATANOTIFICATION &amp; grfBSCF) <br>m_spStream.Release(); <br>return hr; <br>} <br> <br>STDMETHOD(OnObjectAvailable)(REFIID riid, IUnknown *punk) <br>{ <br>ATLTRACENOTIMPL(_T("CBindStatusCallback::OnObjectAvailable")); <br>} <br> <br>HRESULT _StartAsyncDownload(BSTR bstrURL, IUnknown* pUnkContainer, BOOL bRelative) <br>{ <br>m_dwTotalRead = 0; <br>m_dwAvailableToRead = 0; <br>HRESULT hr = S_OK; <br>CComQIPtr&lt;IServiceProvider, &amp;IID_IServiceProvider&gt; spServiceProvider(pUnkContainer); <br>CComPtr&lt;IBindHost&gt; spBindHost; <br>if (spServiceProvider) <br>spServiceProvider-&gt;QueryService(SID_IBindHost, IID_IBindHost, (void**)&amp;spBindHost); <br> <br>if (spBindHost == NULL) <br>{ <br>if (bRelative) <br>return E_NOINTERFACE;  // relative asked for, but no IBindHost <br>hr = CreateURLMoniker(NULL, bstrURL, &amp;m_spMoniker); <br>if (SUCCEEDED(hr)) <br>hr = CreateBindCtx(0, &amp;m_spBindCtx); <br> <br>if (SUCCEEDED(hr)) <br>hr = RegisterBindStatusCallback(m_spBindCtx, reinterpret_cast&lt;IBindStatusCallback*&gt;(static_cast&lt;IBindStatusCallbackImpl&lt;T&gt;*&gt;(this)), 0, 0L); <br>else <br>m_spMoniker.Release(); <br> <br>if (SUCCEEDED(hr)) <br>{ <br>IStream* pStream; <br>hr = m_spMoniker-&gt;BindToStorage(m_spBindCtx, 0, IID_IStream, (void**)&amp;pStream); <br>} <br>} <br>else <br>{ <br>hr = CreateBindCtx(0, &amp;m_spBindCtx); <br>if (SUCCEEDED(hr)) <br>hr = RegisterBindStatusCallback(m_spBindCtx, reinterpret_cast&lt;IBindStatusCallback*&gt;(static_cast&lt;IBindStatusCallbackImpl&lt;T&gt;*&gt;(this)), 0, 0L); <br> <br>if (SUCCEEDED(hr)) <br>{ <br>if (bRelative) <br>hr = spBindHost-&gt;CreateMoniker(bstrURL, m_spBindCtx, &amp;m_spMoniker, 0); <br>else <br>hr = CreateURLMoniker(NULL, bstrURL, &amp;m_spMoniker); <br>} <br> <br>if (SUCCEEDED(hr)) <br>{ <br>IStream* pStream; <br>hr = spBindHost-&gt;MonikerBindToStorage(m_spMoniker, NULL, reinterpret_cast&lt;IBindStatusCallback*&gt;(static_cast&lt;IBindStatusCallbackImpl&lt;T&gt;*&gt;(this)), IID_IStream, (void**)&amp;pStream); <br>ATLTRACE(_T("Bound")); <br>} <br>} <br>return hr; <br>} <br> <br>HRESULT StartAsyncDownload(T* pT, ATL_PDATAAVAILABLE pFunc, BSTR bstrURL, IUnknown* pUnkContainer = NULL, BOOL bRelative = FALSE) <br>{ <br>m_pT = pT; <br>m_pFunc = pFunc; <br>return  _StartAsyncDownload(bstrURL, pUnkContainer, bRelative); <br>} <br> <br>static HRESULT Download(T* pT, ATL_PDATAAVAILABLE pFunc, BSTR bstrURL, IUnknown* pUnkContainer = NULL, BOOL bRelative = FALSE) <br>{ <br>CComObject&lt;CBindStatusCallback&lt;T&gt; &gt; *pbsc; <br>HRESULT hRes = CComObject&lt;CBindStatusCallback&lt;T&gt; &gt;::CreateInstance(&amp;pbsc); <br>if (FAILED(hRes)) <br>return hRes; <br>return pbsc-&gt;StartAsyncDownload(pT, pFunc, bstrURL, pUnkContainer, bRelative); <br>} <br> <br>CComPtr&lt;IMoniker&gt; m_spMoniker; <br>CComPtr&lt;IBindCtx&gt; m_spBindCtx; <br>CComPtr&lt;IBinding&gt; m_spBinding; <br>CComPtr&lt;IStream&gt; m_spStream; <br>T* m_pT; <br>ATL_PDATAAVAILABLE m_pFunc; <br>DWORD m_dwTotalRead; <br>DWORD m_dwAvailableToRead; <br>}; <br> <br>#define IMPLEMENT_STOCKPROP(type, fname, pname, dispid) \ <br>HRESULT STDMETHODCALLTYPE put_##fname(type pname) \ <br>{ \ <br>T* pT = (T*) this; \ <br>if (pT-&gt;FireOnRequestEdit(dispid) == S_FALSE) \ <br>return S_FALSE; \ <br>pT-&gt;m_##pname = pname; \ <br>pT-&gt;m_bRequiresSave = TRUE; \ <br>pT-&gt;FireOnChanged(dispid); \ <br>pT-&gt;FireViewChange(); \ <br>return S_OK; \ <br>} \ <br>HRESULT STDMETHODCALLTYPE get_##fname(type* p##pname) \ <br>{ \ <br>T* pT = (T*) this; \ <br>*p##pname = pT-&gt;m_##pname; \ <br>return S_OK; \ <br>} <br> <br>#define IMPLEMENT_BOOL_STOCKPROP(fname, pname, dispid) \ <br>HRESULT STDMETHODCALLTYPE put_##fname(VARIANT_BOOL pname) \ <br>{ \ <br>T* pT = (T*) this; \ <br>if (pT-&gt;FireOnRequestEdit(dispid) == S_FALSE) \ <br>return S_FALSE; \ <br>pT-&gt;m_##pname = pname; \ <br>pT-&gt;m_bRequiresSave = TRUE; \ <br>pT-&gt;FireOnChanged(dispid); \ <br>pT-&gt;FireViewChange(); \ <br>return S_OK; \ <br>} \ <br>HRESULT STDMETHODCALLTYPE get_##fname(VARIANT_BOOL* p##pname) \ <br>{ \ <br>T* pT = (T*) this; \ <br>*p##pname = pT-&gt;m_##pname ? VARIANT_TRUE : VARIANT_FALSE; \ <br>return S_OK; \ <br>} <br> <br>#define IMPLEMENT_BSTR_STOCKPROP(fname, pname, dispid) \ <br>HRESULT STDMETHODCALLTYPE put_##fname(BSTR pname) \ <br>{ \ <br>T* pT = (T*) this; \ <br>if (pT-&gt;FireOnRequestEdit(dispid) == S_FALSE) \ <br>return S_FALSE; \ <br>*(&amp;(pT-&gt;m_##pname)) = SysAllocString(pname); \ <br>pT-&gt;m_bRequiresSave = TRUE; \ <br>pT-&gt;FireOnChanged(dispid); \ <br>pT-&gt;FireViewChange(); \ <br>return S_OK; \ <br>} \ <br>HRESULT STDMETHODCALLTYPE get_##fname(BSTR* p##pname) \ <br>{ \ <br>T* pT = (T*) this; \ <br>*p##pname = SysAllocString(pT-&gt;m_##pname); \ <br>return S_OK; \ <br>} <br> <br>template &lt; class T, class InterfaceName, const IID* piid, const GUID* plibid&gt; <br>class ATL_NO_VTABLE CStockPropImpl : public IDispatchImpl&lt; InterfaceName, piid, plibid &gt; <br>{ <br>public: <br>// Font <br>HRESULT STDMETHODCALLTYPE put_Font(IFontDisp* pFont) <br>{ <br>T* pT = (T*) this; <br>if (pT-&gt;FireOnRequestEdit(DISPID_FONT) == S_FALSE) <br>return S_FALSE; <br>pT-&gt;m_pFont = 0; <br>if (pFont) <br>{ <br>CComQIPtr&lt;IFont, &amp;IID_IFont&gt; p(pFont); <br>if (p) <br>{ <br>CComPtr&lt;IFont&gt; pFont; <br>p-&gt;Clone(&amp;pFont); <br>if (pFont) <br>pFont-&gt;QueryInterface(IID_IFontDisp, (void**) &amp;pT-&gt;m_pFont); <br>} <br>} <br>pT-&gt;m_bRequiresSave = TRUE; <br>pT-&gt;FireOnChanged(DISPID_FONT); <br>pT-&gt;FireViewChange(); <br>return S_OK; <br>} <br>HRESULT STDMETHODCALLTYPE putref_Font(IFontDisp* pFont) <br>{ <br>T* pT = (T*) this; <br>if (pT-&gt;FireOnRequestEdit(DISPID_FONT) == S_FALSE) <br>return S_FALSE; <br>pT-&gt;m_pFont = pFont; <br>pT-&gt;m_bRequiresSave = TRUE; <br>pT-&gt;FireOnChanged(DISPID_FONT); <br>pT-&gt;FireViewChange(); <br>return S_OK; <br>} <br>HRESULT STDMETHODCALLTYPE get_Font(IFontDisp** ppFont) <br>{ <br>T* pT = (T*) this; <br>*ppFont = pT-&gt;m_pFont; <br>if (*ppFont != NULL) <br>(*ppFont)-&gt;AddRef(); <br>return S_OK; <br>} <br>// Picture <br>HRESULT STDMETHODCALLTYPE put_Picture(IPictureDisp* pPicture) <br>{ <br>T* pT = (T*) this; <br>if (pT-&gt;FireOnRequestEdit(DISPID_PICTURE) == S_FALSE) <br>return S_FALSE; <br>pT-&gt;m_pPicture = 0; <br>if (pPicture) <br>{ <br>CComQIPtr&lt;IPersistStream, &amp;IID_IPersistStream&gt; p(pPicture); <br>if (p) <br>{ <br>ULARGE_INTEGER l; <br>p-&gt;GetSizeMax(&amp;l); <br>HGLOBAL hGlob = GlobalAlloc(GHND, l.LowPart); <br>if (hGlob) <br>{ <br>CComPtr&lt;IStream&gt; spStream; <br>CreateStreamOnHGlobal(hGlob, TRUE, &amp;spStream); <br>if (spStream) <br>{ <br>if (SUCCEEDED(p-&gt;Save(spStream, FALSE))) <br>{ <br>LARGE_INTEGER l; <br>l.QuadPart = 0; <br>spStream-&gt;Seek(l, STREAM_SEEK_SET, NULL); <br>OleLoadPicture(spStream, l.LowPart, FALSE, IID_IPictureDisp, (void**)&amp;pT-&gt;m_pPicture); <br>} <br>spStream.Release(); <br>} <br>GlobalFree(hGlob); <br>} <br>} <br>} <br>pT-&gt;m_bRequiresSave = TRUE; <br>pT-&gt;FireOnChanged(DISPID_PICTURE); <br>pT-&gt;FireViewChange(); <br>return S_OK; <br>} <br>HRESULT STDMETHODCALLTYPE putref_Picture(IPictureDisp* pPicture) <br>{ <br>T* pT = (T*) this; <br>if (pT-&gt;FireOnRequestEdit(DISPID_PICTURE) == S_FALSE) <br>return S_FALSE; <br>pT-&gt;m_pPicture = pPicture; <br>pT-&gt;m_bRequiresSave = TRUE; <br>pT-&gt;FireOnChanged(DISPID_PICTURE); <br>pT-&gt;FireViewChange(); <br>return S_OK; <br>} <br>HRESULT STDMETHODCALLTYPE get_Picture(IPictureDisp** ppPicture) <br>{ <br>T* pT = (T*) this; <br>*ppPicture = pT-&gt;m_pPicture; <br>if (*ppPicture != NULL) <br>(*ppPicture)-&gt;AddRef(); <br>return S_OK; <br>} <br>// MouseIcon <br>HRESULT STDMETHODCALLTYPE put_MouseIcon(IPictureDisp* pPicture) <br>{ <br>T* pT = (T*) this; <br>if (pT-&gt;FireOnRequestEdit(DISPID_MOUSEICON) == S_FALSE) <br>return S_FALSE; <br>pT-&gt;m_pMouseIcon = 0; <br>if (pPicture) <br>{ <br>CComQIPtr&lt;IPersistStream, &amp;IID_IPersistStream&gt; p(pPicture); <br>if (p) <br>{ <br>ULARGE_INTEGER l; <br>p-&gt;GetSizeMax(&amp;l); <br>HGLOBAL hGlob = GlobalAlloc(GHND, l.LowPart); <br>if (hGlob) <br>{ <br>CComPtr&lt;IStream&gt; spStream; <br>CreateStreamOnHGlobal(hGlob, TRUE, &amp;spStream); <br>if (spStream) <br>{ <br>if (SUCCEEDED(p-&gt;Save(spStream, FALSE))) <br>{ <br>LARGE_INTEGER l; <br>l.QuadPart = 0; <br>spStream-&gt;Seek(l, STREAM_SEEK_SET, NULL); <br>OleLoadPicture(spStream, l.LowPart, FALSE, IID_IPictureDisp, (void**)&amp;pT-&gt;m_pMouseIcon); <br>} <br>spStream.Release(); <br>} <br>GlobalFree(hGlob); <br>} <br>} <br>} <br>pT-&gt;m_bRequiresSave = TRUE; <br>pT-&gt;FireOnChanged(DISPID_MOUSEICON); <br>pT-&gt;FireViewChange(); <br>return S_OK; <br>} <br>HRESULT STDMETHODCALLTYPE putref_MouseIcon(IPictureDisp* pPicture) <br>{ <br>T* pT = (T*) this; <br>if (pT-&gt;FireOnRequestEdit(DISPID_MOUSEICON) == S_FALSE) <br>return S_FALSE; <br>pT-&gt;m_pMouseIcon = pPicture; <br>pT-&gt;m_bRequiresSave = TRUE; <br>pT-&gt;FireOnChanged(DISPID_MOUSEICON); <br>pT-&gt;FireViewChange(); <br>return S_OK; <br>} <br>HRESULT STDMETHODCALLTYPE get_MouseIcon(IPictureDisp** ppPicture) <br>{ <br>T* pT = (T*) this; <br>*ppPicture = pT-&gt;m_pMouseIcon; <br>if (*ppPicture != NULL) <br>(*ppPicture)-&gt;AddRef(); <br>return S_OK; <br>} <br>IMPLEMENT_STOCKPROP(OLE_COLOR, BackColor, clrBackColor, DISPID_BACKCOLOR) <br>IMPLEMENT_STOCKPROP(OLE_COLOR, BorderColor, clrBorderColor, DISPID_BORDERCOLOR) <br>IMPLEMENT_STOCKPROP(OLE_COLOR, FillColor, clrFillColor, DISPID_FILLCOLOR) <br>IMPLEMENT_STOCKPROP(OLE_COLOR, ForeColor, clrForeColor, DISPID_FORECOLOR) <br>IMPLEMENT_BOOL_STOCKPROP(AutoSize, bAutoSize, DISPID_AUTOSIZE) <br>IMPLEMENT_BOOL_STOCKPROP(Valid, bValid, DISPID_VALID) <br>IMPLEMENT_BOOL_STOCKPROP(Enabled, bEnabled, DISPID_ENABLED) <br>IMPLEMENT_BOOL_STOCKPROP(TabStop, bTabStop, DISPID_TABSTOP) <br>IMPLEMENT_BOOL_STOCKPROP(BorderVisible, bBorderVisible, DISPID_BORDERVISIBLE) <br>IMPLEMENT_BSTR_STOCKPROP(Text, bstrText, DISPID_TEXT) <br>IMPLEMENT_BSTR_STOCKPROP(Caption, bstrCaption, DISPID_CAPTION) <br>HRESULT STDMETHODCALLTYPE put_Window(long /*hWnd*/) <br>{ <br>return E_FAIL; <br>} <br>HRESULT STDMETHODCALLTYPE get_Window(long* phWnd) <br>{ <br>T* pT = (T*) this; <br>*phWnd = (long)pT-&gt;m_hWnd; <br>return S_OK; <br>} <br>IMPLEMENT_STOCKPROP(long, BackStyle, nBackStyle, DISPID_BACKSTYLE) <br>IMPLEMENT_STOCKPROP(long, BorderStyle, nBorderStyle, DISPID_BORDERSTYLE) <br>IMPLEMENT_STOCKPROP(long, BorderWidth, nBorderWidth, DISPID_BORDERWIDTH) <br>IMPLEMENT_STOCKPROP(long, DrawMode, nDrawMode, DISPID_DRAWMODE) <br>IMPLEMENT_STOCKPROP(long, DrawStyle, nDrawStyle, DISPID_DRAWSTYLE) <br>IMPLEMENT_STOCKPROP(long, DrawWidth, nDrawWidth, DISPID_DRAWWIDTH) <br>IMPLEMENT_STOCKPROP(long, FillStyle, nFillStyle, DISPID_FILLSTYLE) <br>IMPLEMENT_STOCKPROP(long, Appearance, nAppearance, DISPID_APPEARANCE) <br>IMPLEMENT_STOCKPROP(long, MousePointer, nMousePointer, DISPID_MOUSEPOINTER) <br>IMPLEMENT_STOCKPROP(long, ReadyState, nReadyState, DISPID_READYSTATE) <br>}; <br> <br>#ifndef ATL_NO_NAMESPACE <br>}; //namespace ATL <br>#endif <br> <br>#endif // __ATLCTL_H__ </code></pre>
<p>&nbsp;</p></body>
</HTML>
