<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>ATLCONV.H</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3875"></a>ATLCONV.H</h2>
<pre><code>// This is a part of the Active Template Library. <br>// Copyright (C) 1996-1997 Microsoft Corporation <br>// All rights reserved. <br>// <br>// This source code is only intended as a supplement to the <br>// Active Template Library Reference and related <br>// electronic documentation provided with the library. <br>// See these sources for detailed information regarding the <br>// Active Template Library product. <br> <br>#ifndef __ATLCONV_H__ <br>#define __ATLCONV_H__ <br> <br>#ifndef __cplusplus <br>#error ATL requires C++ compilation (use a .cpp suffix) <br>#endif <br> <br>#ifndef _INC_MALLOC <br>#include &lt;malloc.h&gt; <br>#endif // _INC_MALLOC <br> <br>#pragma pack(push,8) <br> <br>// Make sure MFC's afxconv.h hasn't already been loaded to do this <br>#ifndef USES_CONVERSION <br> <br>#ifndef _DEBUG <br>#define USES_CONVERSION int _convert; _convert <br>#else <br>#define USES_CONVERSION int _convert = 0 <br>#endif <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// Global UNICODE&lt;&gt;ANSI translation helpers <br>LPWSTR WINAPI AtlA2WHelper(LPWSTR lpw, LPCSTR lpa, int nChars); <br>LPSTR WINAPI AtlW2AHelper(LPSTR lpa, LPCWSTR lpw, int nChars); <br> <br>#ifndef ATLA2WHELPER <br>#define ATLA2WHELPER AtlA2WHelper <br>#define ATLW2AHELPER AtlW2AHelper <br>#endif <br> <br>#define A2W(lpa) (\ <br>((LPCSTR)lpa == NULL) ? NULL : (\ <br>_convert = (lstrlenA(lpa)+1),\ <br>ATLA2WHELPER((LPWSTR) alloca(_convert*2), lpa, _convert))) <br> <br>#define W2A(lpw) (\ <br>((LPCWSTR)lpw == NULL) ? NULL : (\ <br>_convert = (lstrlenW(lpw)+1)*2,\ <br>ATLW2AHELPER((LPSTR) alloca(_convert), lpw, _convert))) <br> <br>#define A2CW(lpa) ((LPCWSTR)A2W(lpa)) <br>#define W2CA(lpw) ((LPCSTR)W2A(lpw)) <br> <br>#if defined(_UNICODE) <br>// in these cases the default (TCHAR) is the same as OLECHAR <br>inline size_t ocslen(LPCOLESTR x) { return lstrlenW(x); } <br>inline OLECHAR* ocscpy(LPOLESTR dest, LPCOLESTR src) { return lstrcpyW(dest, src); } <br>inline LPCOLESTR T2COLE(LPCTSTR lp) { return lp; } <br>inline LPCTSTR OLE2CT(LPCOLESTR lp) { return lp; } <br>inline LPOLESTR T2OLE(LPTSTR lp) { return lp; } <br>inline LPTSTR OLE2T(LPOLESTR lp) { return lp; } <br>#elif defined(OLE2ANSI) <br>// in these cases the default (TCHAR) is the same as OLECHAR <br>inline size_t ocslen(LPCOLESTR x) { return lstrlen(x); } <br>inline OLECHAR* ocscpy(LPOLESTR dest, LPCOLESTR src) { return lstrcpy(dest, src); } <br>inline LPCOLESTR T2COLE(LPCTSTR lp) { return lp; } <br>inline LPCTSTR OLE2CT(LPCOLESTR lp) { return lp; } <br>inline LPOLESTR T2OLE(LPTSTR lp) { return lp; } <br>inline LPTSTR OLE2T(LPOLESTR lp) { return lp; } <br>#else <br>inline size_t ocslen(LPCOLESTR x) { return lstrlenW(x); } <br>//lstrcpyW doesn't work on Win95, so we do this <br>inline OLECHAR* ocscpy(LPOLESTR dest, LPCOLESTR src) <br>{return (LPOLESTR) memcpy(dest, src, (lstrlenW(src)+1)*sizeof(WCHAR));} <br>//CharNextW doesn't work on Win95 so we use this <br>#define T2COLE(lpa) A2CW(lpa) <br>#define T2OLE(lpa) A2W(lpa) <br>#define OLE2CT(lpo) W2CA(lpo) <br>#define OLE2T(lpo) W2A(lpo) <br>#endif <br> <br>#ifdef OLE2ANSI <br>inline LPOLESTR A2OLE(LPSTR lp) { return lp;} <br>inline LPSTR OLE2A(LPOLESTR lp) { return lp;} <br>#define W2OLE W2A <br>#define OLE2W A2W <br>inline LPCOLESTR A2COLE(LPCSTR lp) { return lp;} <br>inline LPCSTR OLE2CA(LPCOLESTR lp) { return lp;} <br>#define W2COLE W2CA <br>#define OLE2CW A2CW <br>#else <br>inline LPOLESTR W2OLE(LPWSTR lp) { return lp; } <br>inline LPWSTR OLE2W(LPOLESTR lp) { return lp; } <br>#define A2OLE A2W <br>#define OLE2A W2A <br>inline LPCOLESTR W2COLE(LPCWSTR lp) { return lp; } <br>inline LPCWSTR OLE2CW(LPCOLESTR lp) { return lp; } <br>#define A2COLE A2CW <br>#define OLE2CA W2CA <br>#endif <br> <br>#ifdef _UNICODE <br>#define T2A W2A <br>#define A2T A2W <br>inline LPWSTR T2W(LPTSTR lp) { return lp; } <br>inline LPTSTR W2T(LPWSTR lp) { return lp; } <br>#define T2CA W2CA <br>#define A2CT A2CW <br>inline LPCWSTR T2CW(LPCTSTR lp) { return lp; } <br>inline LPCTSTR W2CT(LPCWSTR lp) { return lp; } <br>#else <br>#define T2W A2W <br>#define W2T W2A <br>inline LPSTR T2A(LPTSTR lp) { return lp; } <br>inline LPTSTR A2T(LPSTR lp) { return lp; } <br>#define T2CW A2CW <br>#define W2CT W2CA <br>inline LPCSTR T2CA(LPCTSTR lp) { return lp; } <br>inline LPCTSTR A2CT(LPCSTR lp) { return lp; } <br>#endif <br> <br>inline BSTR OLE2BSTR(LPCOLESTR lp) {return ::SysAllocString(lp);} <br>#if defined(_UNICODE) <br>// in these cases the default (TCHAR) is the same as OLECHAR <br>inline BSTR T2BSTR(LPCTSTR lp) {return ::SysAllocString(lp);} <br>inline BSTR A2BSTR(LPCSTR lp) {USES_CONVERSION; return ::SysAllocString(A2COLE(lp));} <br>inline BSTR W2BSTR(LPCWSTR lp) {return ::SysAllocString(lp);} <br>#elif defined(OLE2ANSI) <br>// in these cases the default (TCHAR) is the same as OLECHAR <br>inline BSTR T2BSTR(LPCTSTR lp) {return ::SysAllocString(lp);} <br>inline BSTR A2BSTR(LPCSTR lp) {return ::SysAllocString(lp);} <br>inline BSTR W2BSTR(LPCWSTR lp) {USES_CONVERSION; return ::SysAllocString(W2COLE(lp));} <br>#else <br>inline BSTR T2BSTR(LPCTSTR lp) {USES_CONVERSION; return ::SysAllocString(T2COLE(lp));} <br>inline BSTR A2BSTR(LPCSTR lp) {USES_CONVERSION; return ::SysAllocString(A2COLE(lp));} <br>inline BSTR W2BSTR(LPCWSTR lp) {return ::SysAllocString(lp);} <br>#endif <br> <br>#ifdef _WINGDI_ <br>///////////////////////////////////////////////////////////////////////////// <br>// Global UNICODE&lt;&gt;ANSI translation helpers <br>LPDEVMODEW AtlDevModeA2W(LPDEVMODEW lpDevModeW, LPDEVMODEA lpDevModeA); <br>LPDEVMODEA AtlDevModeW2A(LPDEVMODEA lpDevModeA, LPDEVMODEW lpDevModeW); <br>LPTEXTMETRICW AtlTextMetricA2W(LPTEXTMETRICW lptmW, LPTEXTMETRICA pltmA); <br>LPTEXTMETRICA AtlTextMetricW2A(LPTEXTMETRICA lptmA, LPTEXTMETRICW pltmW); <br> <br>#ifndef ATLDEVMODEA2W <br>#define ATLDEVMODEA2W AtlDevModeA2W <br>#define ATLDEVMODEW2A AtlDevModeW2A <br>#define ATLTEXTMETRICA2W AtlTextMetricA2W <br>#define ATLTEXTMETRICW2A AtlTextMetricW2A <br>#endif <br> <br>#define DEVMODEW2A(lpw)\ <br>((lpw == NULL) ? NULL : ATLDEVMODEW2A((LPDEVMODEA)alloca(sizeof(DEVMODEA)+lpw-&gt;dmDriverExtra), lpw)) <br>#define DEVMODEA2W(lpa)\ <br>((lpa == NULL) ? NULL : ATLDEVMODEA2W((LPDEVMODEW)alloca(sizeof(DEVMODEW)+lpa-&gt;dmDriverExtra), lpa)) <br>#define TEXTMETRICW2A(lptmw)\ <br>((lptmw == NULL) ? NULL : ATLTEXTMETRICW2A((LPTEXTMETRICA)alloca(sizeof(TEXTMETRICA)), lptmw)) <br>#define TEXTMETRICA2W(lptma)\ <br>((lptma == NULL) ? NULL : ATLTEXTMETRICA2W((LPTEXTMETRICW)alloca(sizeof(TEXTMETRICW)), lptma)) <br> <br>#ifdef OLE2ANSI <br>#define DEVMODEOLE DEVMODEA <br>#define LPDEVMODEOLE LPDEVMODEA <br>#define TEXTMETRICOLE TEXTMETRICA <br>#define LPTEXTMETRICOLE LPTEXTMETRICA <br>#else <br>#define DEVMODEOLE DEVMODEW <br>#define LPDEVMODEOLE LPDEVMODEW <br>#define TEXTMETRICOLE TEXTMETRICW <br>#define LPTEXTMETRICOLE LPTEXTMETRICW <br>#endif <br> <br>#if defined(_UNICODE) <br>// in these cases the default (TCHAR) is the same as OLECHAR <br>inline LPDEVMODEW DEVMODEOLE2T(LPDEVMODEOLE lp) { return lp; } <br>inline LPDEVMODEOLE DEVMODET2OLE(LPDEVMODEW lp) { return lp; } <br>inline LPTEXTMETRICW TEXTMETRICOLE2T(LPTEXTMETRICOLE lp) { return lp; } <br>inline LPTEXTMETRICOLE TEXTMETRICT2OLE(LPTEXTMETRICW lp) { return lp; } <br>#elif defined(OLE2ANSI) <br>// in these cases the default (TCHAR) is the same as OLECHAR <br>inline LPDEVMODE DEVMODEOLE2T(LPDEVMODEOLE lp) { return lp; } <br>inline LPDEVMODEOLE DEVMODET2OLE(LPDEVMODE lp) { return lp; } <br>inline LPTEXTMETRIC TEXTMETRICOLE2T(LPTEXTMETRICOLE lp) { return lp; } <br>inline LPTEXTMETRICOLE TEXTMETRICT2OLE(LPTEXTMETRIC lp) { return lp; } <br>#else <br>#define DEVMODEOLE2T(lpo) DEVMODEW2A(lpo) <br>#define DEVMODET2OLE(lpa) DEVMODEA2W(lpa) <br>#define TEXTMETRICOLE2T(lptmw) TEXTMETRICW2A(lptmw) <br>#define TEXTMETRICT2OLE(lptma) TEXTMETRICA2W(lptma) <br>#endif <br> <br>#endif //_WINGDI_ <br> <br>#else //!USES_CONVERSION <br> <br>// if USES_CONVERSION already defined (i.e. MFC_VER &lt; 4.21 ) <br>// flip this switch to avoid atlconv.cpp <br>#define _ATL_NO_CONVERSIONS <br> <br>#endif //!USES_CONVERSION <br> <br>// Define these even if MFC already included <br>#if defined(_UNICODE) <br>// in these cases the default (TCHAR) is the same as OLECHAR <br>inline LPOLESTR CharNextO(LPCOLESTR lp) {return CharNextW(lp);} <br>#elif defined(OLE2ANSI) <br>// in these cases the default (TCHAR) is the same as OLECHAR <br>inline LPOLESTR CharNextO(LPCOLESTR lp) {return CharNext(lp);} <br>#else <br>inline LPOLESTR CharNextO(LPCOLESTR lp) {return (LPOLESTR)(lp+1);} <br>#endif <br> <br>#pragma pack(pop) <br> <br>#endif // __ATLCONV_H__ <br> <br>///////////////////////////////////////////////////////////////////////////// </code></pre>
<p>&nbsp;</p></body>
</HTML>
