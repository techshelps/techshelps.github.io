<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>ATLBASE.H</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3872"></a>ATLBASE.H</h2>
<pre><code>// This is a part of the Active Template Library. <br>// Copyright (C) 1996-1997 Microsoft Corporation <br>// All rights reserved. <br>// <br>// This source code is only intended as a supplement to the <br>// Active Template Library Reference and related <br>// electronic documentation provided with the library. <br>// See these sources for detailed information regarding the <br>// Active Template Library product. <br> <br>#ifndef __ATLBASE_H__ <br>#define __ATLBASE_H__ <br> <br>#ifndef __cplusplus <br>#error ATL requires C++ compilation (use a .cpp suffix) <br>#endif <br> <br>#ifdef _UNICODE <br>#ifndef UNICODE <br>#define UNICODE         // UNICODE is used by Windows headers <br>#endif <br>#endif <br> <br>#ifdef UNICODE <br>#ifndef _UNICODE <br>#define _UNICODE        // _UNICODE is used by C-runtime/MFC headers <br>#endif <br>#endif <br> <br>#ifdef _DEBUG <br>#ifndef DEBUG <br>#define DEBUG <br>#endif <br>#endif <br> <br>// namespace and our templates don't quite work with earlier compiler <br>// Can turn off namespace support directly, also <br>#if _MSC_VER&lt;1100 <br>#ifndef ATL_NO_NAMESPACE <br>#define ATL_NO_NAMESPACE <br>#endif <br>#endif <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// __declspec(novtable) is used on a class declaration to prevent the vtable <br>// pointer from being initialized in the constructor and destructor for the <br>// class.  This has many benefits because the linker can now eliminate the <br>// vtable and all the functions pointed to by the vtable.  Also, the actual <br>// constructor and destructor code are now smaller. <br>/////////////////////////////////////////////////////////////////////////////// <br>// This should only be used on a class that is not directly createable but is <br>// rather only used as a base class.  Additionally, the constructor and <br>// destructor (if provided by the user) should not call anything that may cause <br>// a virtual function call to occur back on the object. <br>/////////////////////////////////////////////////////////////////////////////// <br>// By default, the wizards will generate new ATL object classes with this <br>// attribute (through the ATL_NO_VTABLE macro).  This is normally safe as long <br>// the restriction mentioned above is followed.  It is always safe to remove <br>// this macro from your class, so if in doubt, remove it. <br>/////////////////////////////////////////////////////////////////////////////// <br> <br>#if _MSC_VER&lt;1100 <br>#define ATL_NO_VTABLE <br>#else <br>#ifdef _ATL_DISABLE_NO_VTABLE <br>#define ATL_NO_VTABLE <br>#else <br>#define ATL_NO_VTABLE __declspec(novtable) <br>#endif <br>#endif <br> <br>#ifndef _ATL_NO_PRAGMA_WARNINGS <br>#pragma warning(disable: 4201) // nameless unions are part of C++ <br>#pragma warning(disable: 4127) // constant expression <br>#pragma warning(disable: 4512) // can't generate assignment operator (so what?) <br>#pragma warning(disable: 4514) // unreferenced inlines are common <br>#pragma warning(disable: 4103) // pragma pack <br>#pragma warning(disable: 4702) // unreachable code <br>#pragma warning(disable: 4237) // bool <br>#pragma warning(disable: 4710) // function couldn't be inlined <br>#pragma warning(disable: 4355) // 'this' : used in base member initializer list <br>#pragma warning(disable: 4097) // typedef name used as synonym for class-name <br>#endif //!_ATL_NO_PRAGMA_WARNINGS <br> <br>#include &lt;windows.h&gt; <br>#include &lt;winnls.h&gt; <br>#include &lt;ole2.h&gt; <br> <br>#include &lt;stddef.h&gt; <br>#include &lt;tchar.h&gt; <br>#include &lt;malloc.h&gt; <br>#ifndef _ATL_NO_DEBUG_CRT <br>// Warning: if you define the above symbol, you will have <br>// to provide your own definition of the _ASSERTE(x) macro <br>// in order to compile ATL <br>#include &lt;crtdbg.h&gt; <br>#endif <br> <br>#include &lt;olectl.h&gt; <br>#include &lt;winreg.h&gt; <br>#include &lt;atliface.h&gt; <br> <br>#ifndef _ATL_PACKING <br>#define _ATL_PACKING 8 <br>#endif <br>#pragma pack(push, _ATL_PACKING) <br> <br>#include &lt;atlconv.h&gt; <br> <br>#if defined(_ATL_DLL) <br>#pragma comment(lib, "atl.lib") <br>#define ATLAPI extern "C" HRESULT __stdcall <br>#define ATLAPI_(x) extern "C" x __stdcall <br>#elif defined(_ATL_DLL_IMPL) <br>#define ATLAPI extern "C" HRESULT __declspec(dllexport) __stdcall <br>#define ATLAPI_(x) extern "C" x __declspec(dllexport) __stdcall <br>#else <br>#define ATLAPI HRESULT __stdcall <br>#define ATLAPI_(x) x __stdcall <br>#endif <br> <br>#ifndef ATL_NO_NAMESPACE <br>#ifndef _ATL_DLL_IMPL <br>namespace ATL <br>{ <br>#endif <br>#endif <br> <br>typedef HRESULT (WINAPI _ATL_CREATORFUNC)(void* pv, REFIID riid, LPVOID* ppv); <br>typedef HRESULT (WINAPI _ATL_CREATORARGFUNC)(void* pv, REFIID riid, LPVOID* ppv, DWORD dw); <br>typedef HRESULT (WINAPI _ATL_MODULEFUNC)(DWORD dw); <br>typedef LPCTSTR (WINAPI _ATL_DESCRIPTIONFUNC)(); <br> <br>struct _ATL_OBJMAP_ENTRY <br>{ <br>const CLSID* pclsid; <br>HRESULT (WINAPI *pfnUpdateRegistry)(BOOL bRegister); <br>_ATL_CREATORFUNC* pfnGetClassObject; <br>_ATL_CREATORFUNC* pfnCreateInstance; <br>IUnknown* pCF; <br>DWORD dwRegister; <br>_ATL_DESCRIPTIONFUNC* pfnGetObjectDescription; <br>HRESULT WINAPI RevokeClassObject() <br>{ <br>return CoRevokeClassObject(dwRegister); <br>} <br>HRESULT WINAPI RegisterClassObject(DWORD dwClsContext, DWORD dwFlags) <br>{ <br>IUnknown* p = NULL; <br>HRESULT hRes = pfnGetClassObject(pfnCreateInstance, IID_IUnknown, (LPVOID*) &amp;p); <br>if (SUCCEEDED(hRes)) <br>hRes = CoRegisterClassObject(*pclsid, p, dwClsContext, dwFlags, &amp;dwRegister); <br>if (p != NULL) <br>p-&gt;Release(); <br>return hRes; <br>} <br>}; <br> <br>struct _ATL_REGMAP_ENTRY <br>{ <br>LPCOLESTR     szKey; <br>LPCOLESTR     szData; <br>}; <br> <br>struct _ATL_MODULE <br>{ <br>// Attributes <br>public: <br>UINT cbSize; <br>HINSTANCE m_hInst; <br>HINSTANCE m_hInstResource; <br>HINSTANCE m_hInstTypeLib; <br>_ATL_OBJMAP_ENTRY* m_pObjMap; <br>LONG m_nLockCnt; <br>HANDLE m_hHeap; <br>CRITICAL_SECTION m_csTypeInfoHolder; <br>CRITICAL_SECTION m_csWindowCreate; <br>CRITICAL_SECTION m_csObjMap; <br>}; <br> <br>//This define makes debugging asserts easier. <br>#define _ATL_SIMPLEMAPENTRY ((_ATL_CREATORARGFUNC*)1) <br> <br>struct _ATL_INTMAP_ENTRY <br>{ <br>const IID* piid;       // the interface id (IID) <br>DWORD dw; <br>_ATL_CREATORARGFUNC* pFunc; //NULL:end, 1:offset, n:ptr <br>}; <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// QI Support <br> <br>ATLAPI AtlInternalQueryInterface(void* pThis, <br>const _ATL_INTMAP_ENTRY* pEntries, REFIID iid, void** ppvObject); <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// Smart Pointer helpers <br> <br>ATLAPI_(IUnknown*) AtlComPtrAssign(IUnknown** pp, IUnknown* lp); <br>ATLAPI_(IUnknown*) AtlComQIPtrAssign(IUnknown** pp, IUnknown* lp, REFIID riid); <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// Inproc Marshaling helpers <br>ATLAPI AtlFreeMarshalStream(IStream* pStream); <br>ATLAPI AtlMarshalPtrInProc(IUnknown* pUnk, const IID&amp; iid, IStream** ppStream); <br>ATLAPI AtlUnmarshalPtr(IStream* pStream, const IID&amp; iid, IUnknown** ppUnk); <br> <br>ATLAPI_(BOOL) AtlWaitWithMessageLoop(HANDLE hEvent); <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// Connection Point Helpers <br> <br>ATLAPI AtlAdvise(IUnknown* pUnkCP, IUnknown* pUnk, const IID&amp; iid, LPDWORD pdw); <br>ATLAPI AtlUnadvise(IUnknown* pUnkCP, const IID&amp; iid, DWORD dw); <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// IDispatch Error handling <br> <br>ATLAPI AtlSetErrorInfo(const CLSID&amp; clsid, LPCOLESTR lpszDesc, <br>DWORD dwHelpID, LPCOLESTR lpszHelpFile, const IID&amp; iid, HRESULT hRes, <br>HINSTANCE hInst); <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// Module <br> <br>ATLAPI AtlModuleInit(_ATL_MODULE* pM, _ATL_OBJMAP_ENTRY* p, HINSTANCE h); <br>ATLAPI AtlModuleRegisterClassObjects(_ATL_MODULE* pM, DWORD dwClsContext, DWORD dwFlags); <br>ATLAPI AtlModuleRevokeClassObjects(_ATL_MODULE* pM); <br>ATLAPI AtlModuleGetClassObject(_ATL_MODULE* pM, REFCLSID rclsid, REFIID riid, LPVOID* ppv); <br>ATLAPI AtlModuleTerm(_ATL_MODULE* pM); <br>ATLAPI AtlModuleRegisterServer(_ATL_MODULE* pM, BOOL bRegTypeLib, const CLSID* pCLSID = NULL); <br>ATLAPI AtlModuleUnregisterServer(_ATL_MODULE* pM, const CLSID* pCLSID = NULL); <br>ATLAPI AtlModuleUpdateRegistryFromResourceD(_ATL_MODULE*pM, LPCOLESTR lpszRes, <br>BOOL bRegister, struct _ATL_REGMAP_ENTRY* pMapEntries, IRegistrar* pReg = NULL); <br>ATLAPI AtlModuleRegisterTypeLib(_ATL_MODULE* pM, LPCOLESTR lpszIndex); <br> <br>#ifndef ATL_NO_NAMESPACE <br>#ifndef _ATL_DLL_IMPL <br>}; //namespace ATL <br>#endif <br>#endif <br> <br>#ifndef ATL_NO_NAMESPACE <br>namespace ATL <br>{ <br>#endif <br> <br>#if defined (_CPPUNWIND) &amp; (defined(_ATL_EXCEPTIONS) | defined(_AFX)) <br>#define ATLTRY(x) try{x;} catch(...) {} <br>#else <br>#define ATLTRY(x) x; <br>#endif <br> <br>#ifdef _DEBUG <br>void _cdecl AtlTrace(LPCTSTR lpszFormat, ...); <br>#ifndef ATLTRACE <br>#define ATLTRACE            AtlTrace <br>#endif <br>#define ATLTRACENOTIMPL(funcname)   ATLTRACE(_T("%s not implemented.\n"), funcname); return E_NOTIMPL <br>#else <br>inline void _cdecl AtlTrace(LPCTSTR , ...){} <br>#ifndef ATLTRACE <br>#define ATLTRACE            1 ? (void)0 : AtlTrace <br>#endif <br>#define ATLTRACENOTIMPL(funcname)   return E_NOTIMPL <br>#endif //_DEBUG <br> <br>#define offsetofclass(base, derived) ((DWORD)(static_cast&lt;base*&gt;((derived*)8))-8) <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// Master version numbers <br> <br>#define _ATL     1      // Active Template Library <br>#define _ATL_VER 0x0200 // Active Template Library version 2.00 <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// Win32 libraries <br> <br>#ifndef _ATL_NO_FORCE_LIBS <br>#pragma comment(lib, "kernel32.lib") <br>#pragma comment(lib, "user32.lib") <br>#pragma comment(lib, "ole32.lib") <br>#pragma comment(lib, "oleaut32.lib") <br>#pragma comment(lib, "olepro32.lib") <br>#pragma comment(lib, "uuid.lib") <br>#pragma comment(lib, "advapi32.lib") <br>#endif // _ATL_NO_FORCE_LIBS <br> <br>template &lt;class T&gt; <br>class CComPtr <br>{ <br>public: <br>typedef T _PtrClass; <br>CComPtr() {p=NULL;} <br>CComPtr(T* lp) <br>{ <br>if ((p = lp) != NULL) <br>p-&gt;AddRef(); <br>} <br>CComPtr(const CComPtr&lt;T&gt;&amp; lp) <br>{ <br>if ((p = lp.p) != NULL) <br>p-&gt;AddRef(); <br>} <br>~CComPtr() {if (p) p-&gt;Release();} <br>void Release() {if (p) p-&gt;Release(); p=NULL;} <br>operator T*() {return (T*)p;} <br>T&amp; operator*() {_ASSERTE(p!=NULL); return *p; } <br>//The assert on operator&amp; usually indicates a bug.  If this is really <br>//what is needed, however, take the address of the p member explicitly. <br>T** operator&amp;() { _ASSERTE(p==NULL); return &amp;p; } <br>T* operator-&gt;() { _ASSERTE(p!=NULL); return p; } <br>T* operator=(T* lp){return (T*)AtlComPtrAssign((IUnknown**)&amp;p, lp);} <br>T* operator=(const CComPtr&lt;T&gt;&amp; lp) <br>{ <br>return (T*)AtlComPtrAssign((IUnknown**)&amp;p, lp.p); <br>} <br>#if _MSC_VER&gt;1020 <br>bool operator!(){return (p == NULL);} <br>#else <br>BOOL operator!(){return (p == NULL) ? TRUE : FALSE;} <br>#endif <br>T* p; <br>}; <br> <br>//Note: CComQIPtr&lt;IUnknown, &amp;IID_IUnknown&gt; is not meaningful <br>//      Use CComPtr&lt;IUnknown&gt; <br>template &lt;class T, const IID* piid&gt; <br>class CComQIPtr <br>{ <br>public: <br>typedef T _PtrClass; <br>CComQIPtr() {p=NULL;} <br>CComQIPtr(T* lp) <br>{ <br>if ((p = lp) != NULL) <br>p-&gt;AddRef(); <br>} <br>CComQIPtr(const CComQIPtr&lt;T,piid&gt;&amp; lp) <br>{ <br>if ((p = lp.p) != NULL) <br>p-&gt;AddRef(); <br>} <br>// If you get an error that this member is already defined, you are probably <br>// using a CComQIPtr&lt;IUnknown, &amp;IID_IUnknown&gt;.  This is not necessary. <br>// Use CComPtr&lt;IUnknown&gt; <br>CComQIPtr(IUnknown* lp) <br>{ <br>p=NULL; <br>if (lp != NULL) <br>lp-&gt;QueryInterface(*piid, (void **)&amp;p); <br>} <br>~CComQIPtr() {if (p) p-&gt;Release();} <br>void Release() {if (p) p-&gt;Release(); p=NULL;} <br>operator T*() {return p;} <br>T&amp; operator*() {_ASSERTE(p!=NULL); return *p; } <br>//The assert on operator&amp; usually indicates a bug.  If this is really <br>//what is needed, however, take the address of the p member explicitly. <br>T** operator&amp;() { _ASSERTE(p==NULL); return &amp;p; } <br>T* operator-&gt;() {_ASSERTE(p!=NULL); return p; } <br>T* operator=(T* lp){return (T*)AtlComPtrAssign((IUnknown**)&amp;p, lp);} <br>T* operator=(const CComQIPtr&lt;T,piid&gt;&amp; lp) <br>{ <br>return (T*)AtlComPtrAssign((IUnknown**)&amp;p, lp.p); <br>} <br>T* operator=(IUnknown* lp) <br>{ <br>return (T*)AtlComQIPtrAssign((IUnknown**)&amp;p, lp, *piid); <br>} <br>#if _MSC_VER&gt;1020 <br>bool operator!(){return (p == NULL);} <br>#else <br>BOOL operator!(){return (p == NULL) ? TRUE : FALSE;} <br>#endif <br>T* p; <br>}; <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// CComBSTR <br>class CComBSTR <br>{ <br>public: <br>BSTR m_str; <br>CComBSTR() <br>{ <br>m_str = NULL; <br>} <br>/*explicit*/ CComBSTR(int nSize, LPCOLESTR sz = NULL) <br>{ <br>m_str = ::SysAllocStringLen(sz, nSize); <br>} <br>/*explicit*/ CComBSTR(LPCOLESTR pSrc) <br>{ <br>m_str = ::SysAllocString(pSrc); <br>} <br>/*explicit*/ CComBSTR(const CComBSTR&amp; src) <br>{ <br>m_str = src.Copy(); <br>} <br>CComBSTR&amp; operator=(const CComBSTR&amp; src); <br>CComBSTR&amp; operator=(LPCOLESTR pSrc); <br>~CComBSTR() <br>{ <br>::SysFreeString(m_str); <br>} <br>unsigned int Length() const <br>{ <br>return SysStringLen(m_str); <br>} <br>operator BSTR() const <br>{ <br>return m_str; <br>} <br>BSTR* operator&amp;() <br>{ <br>return &amp;m_str; <br>} <br>BSTR Copy() const <br>{ <br>return ::SysAllocStringLen(m_str, ::SysStringLen(m_str)); <br>} <br>void Attach(BSTR src) <br>{ <br>_ASSERTE(m_str == NULL); <br>m_str = src; <br>} <br>BSTR Detach() <br>{ <br>BSTR s = m_str; <br>m_str = NULL; <br>return s; <br>} <br>void Empty() <br>{ <br>::SysFreeString(m_str); <br>m_str = NULL; <br>} <br>#if _MSC_VER&gt;1020 <br>bool operator!() <br>{ <br>return (m_str == NULL); <br>} <br>#else <br>BOOL operator!() <br>{ <br>return (m_str == NULL) ? TRUE : FALSE; <br>} <br>#endif <br>void Append(const CComBSTR&amp; bstrSrc) <br>{ <br>Append(bstrSrc.m_str, SysStringLen(bstrSrc.m_str)); <br>} <br>void Append(LPCOLESTR lpsz) <br>{ <br>Append(lpsz, ocslen(lpsz)); <br>} <br>// a BSTR is just a LPCOLESTR so we need a special version to signify <br>// that we are appending a BSTR <br>void AppendBSTR(BSTR p) <br>{ <br>Append(p, SysStringLen(p)); <br>} <br>void Append(LPCOLESTR lpsz, int nLen); <br> <br>CComBSTR&amp; operator+=(const CComBSTR&amp; bstrSrc) <br>{ <br>AppendBSTR(bstrSrc.m_str); <br>return *this; <br>} <br>#ifndef OLE2ANSI <br>/*explicit*/ CComBSTR(LPCSTR pSrc); <br>/*explicit*/ CComBSTR(int nSize, LPCSTR sz = NULL); <br>CComBSTR&amp; operator=(LPCSTR pSrc); <br>void Append(LPCSTR); <br>#endif <br>HRESULT WriteToStream(IStream* pStream); <br>HRESULT ReadFromStream(IStream* pStream); <br>}; <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// CComVariant <br> <br>class CComVariant : public tagVARIANT <br>{ <br>// Constructors <br>public: <br>CComVariant() <br>{ <br>::VariantInit(this); <br>} <br>~CComVariant() <br>{ <br>Clear(); <br>} <br> <br>CComVariant(const VARIANT&amp; varSrc) <br>{ <br>::VariantInit(this); <br>InternalCopy(&amp;varSrc); <br>} <br> <br>CComVariant(const CComVariant&amp; varSrc) <br>{ <br>::VariantInit(this); <br>InternalCopy(&amp;varSrc); <br>} <br> <br>CComVariant(BSTR bstrSrc) <br>{ <br>::VariantInit(this); <br>*this = bstrSrc; <br>} <br>CComVariant(LPCOLESTR lpszSrc) <br>{ <br>::VariantInit(this); <br>*this = lpszSrc; <br>} <br> <br>#ifndef OLE2ANSI <br>CComVariant(LPCSTR lpszSrc) <br>{ <br>::VariantInit(this); <br>*this = lpszSrc;} <br>#endif <br> <br>#if _MSC_VER&gt;1020 <br>CComVariant(bool bSrc) <br>{ <br>::VariantInit(this); <br>vt = VT_BOOL; <br>#pragma warning(disable: 4310) // cast truncates constant value <br>boolVal = bSrc ? VARIANT_TRUE : VARIANT_FALSE; <br>#pragma warning(default: 4310) // cast truncates constant value <br>} <br>#endif <br> <br>CComVariant(int nSrc) <br>{ <br>::VariantInit(this); <br>vt = VT_I4; <br>lVal = nSrc; <br>} <br>CComVariant(BYTE nSrc) <br>{ <br>::VariantInit(this); <br>vt = VT_UI1; <br>bVal = nSrc; <br>} <br>CComVariant(short nSrc) <br>{ <br>::VariantInit(this); <br>vt = VT_I2; <br>iVal = nSrc; <br>} <br>CComVariant(long nSrc, VARTYPE vtSrc = VT_I4) <br>{ <br>_ASSERTE(vtSrc == VT_I4 || vtSrc == VT_ERROR); <br>::VariantInit(this); <br>vt = vtSrc; <br>lVal = nSrc; <br>} <br>CComVariant(float fltSrc) <br>{ <br>::VariantInit(this); <br>vt = VT_R4; <br>fltVal = fltSrc; <br>} <br>CComVariant(double dblSrc) <br>{ <br>::VariantInit(this); <br>vt = VT_R8; <br>dblVal = dblSrc; <br>} <br>CComVariant(CY cySrc) <br>{ <br>::VariantInit(this); <br>vt = VT_CY; <br>cyVal.Hi = cySrc.Hi; <br>cyVal.Lo = cySrc.Lo; <br>} <br>CComVariant(IDispatch* pSrc) <br>{ <br>::VariantInit(this); <br>vt = VT_DISPATCH; <br>pdispVal = pSrc; <br>// Need to AddRef as VariantClear will Release <br>if (pdispVal != NULL) <br>pdispVal-&gt;AddRef(); <br>} <br>CComVariant(IUnknown* pSrc) <br>{ <br>::VariantInit(this); <br>vt = VT_UNKNOWN; <br>punkVal = pSrc; <br>// Need to AddRef as VariantClear will Release <br>if (punkVal != NULL) <br>punkVal-&gt;AddRef(); <br>} <br> <br>// Assignment Operators <br>public: <br>CComVariant&amp; operator=(const CComVariant&amp; varSrc) <br>{ <br>InternalCopy(&amp;varSrc); <br>return *this; <br>} <br>CComVariant&amp; operator=(const VARIANT&amp; varSrc) <br>{ <br>InternalCopy(&amp;varSrc); <br>return *this; <br>} <br> <br>CComVariant&amp; operator=(BSTR bstrSrc); <br>CComVariant&amp; operator=(LPCOLESTR lpszSrc); <br> <br>#ifndef OLE2ANSI <br>CComVariant&amp; operator=(LPCSTR lpszSrc); <br>#endif <br> <br>#if _MSC_VER&gt;1020 <br>CComVariant&amp; operator=(bool bSrc); <br>#endif <br>CComVariant&amp; operator=(int nSrc); <br>CComVariant&amp; operator=(BYTE nSrc); <br>CComVariant&amp; operator=(short nSrc); <br>CComVariant&amp; operator=(long nSrc); <br>CComVariant&amp; operator=(float fltSrc); <br>CComVariant&amp; operator=(double dblSrc); <br>CComVariant&amp; operator=(CY cySrc); <br> <br>CComVariant&amp; operator=(IDispatch* pSrc); <br>CComVariant&amp; operator=(IUnknown* pSrc); <br> <br>// Comparison Operators <br>public: <br>#if _MSC_VER&gt;1020 <br>bool operator==(const VARIANT&amp; varSrc); <br>bool operator!=(const VARIANT&amp; varSrc) {return !operator==(varSrc);} <br>#else <br>BOOL operator==(const VARIANT&amp; varSrc); <br>BOOL operator!=(const VARIANT&amp; varSrc) {return !operator==(varSrc);} <br>#endif <br> <br>// Operations <br>public: <br>HRESULT Clear() { return ::VariantClear(this); } <br>HRESULT Copy(const VARIANT* pSrc) { return ::VariantCopy(this, const_cast&lt;VARIANT*&gt;(pSrc)); } <br>HRESULT Attach(VARIANT* pSrc); <br>HRESULT Detach(VARIANT* pDest); <br>HRESULT ChangeType(VARTYPE vtNew, const VARIANT* pSrc = NULL); <br>HRESULT WriteToStream(IStream* pStream); <br>HRESULT ReadFromStream(IStream* pStream); <br> <br>// Implementation <br>public: <br>HRESULT InternalClear(); <br>void InternalCopy(const VARIANT* pSrc); <br>}; <br>///////////////////////////////////////////////////////////////////////////// <br>// GUID comparison <br> <br>inline BOOL InlineIsEqualGUID(REFGUID rguid1, REFGUID rguid2) <br>{ <br>   return ( <br>  ((PLONG) &amp;rguid1)[0] == ((PLONG) &amp;rguid2)[0] &amp;&amp; <br>  ((PLONG) &amp;rguid1)[1] == ((PLONG) &amp;rguid2)[1] &amp;&amp; <br>  ((PLONG) &amp;rguid1)[2] == ((PLONG) &amp;rguid2)[2] &amp;&amp; <br>  ((PLONG) &amp;rguid1)[3] == ((PLONG) &amp;rguid2)[3]); <br>} <br> <br>inline BOOL InlineIsEqualUnknown(REFGUID rguid1) <br>{ <br>   return ( <br>  ((PLONG) &amp;rguid1)[0] == 0 &amp;&amp; <br>  ((PLONG) &amp;rguid1)[1] == 0 &amp;&amp; <br>#ifdef _MAC <br>  ((PLONG) &amp;rguid1)[2] == 0xC0000000 &amp;&amp; <br>  ((PLONG) &amp;rguid1)[3] == 0x00000046); <br>#else <br>  ((PLONG) &amp;rguid1)[2] == 0x000000C0 &amp;&amp; <br>  ((PLONG) &amp;rguid1)[3] == 0x46000000); <br>#endif <br>} <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// Threading Model Support <br> <br>class CComCriticalSection <br>{ <br>public: <br>void Lock() {EnterCriticalSection(&amp;m_sec);} <br>void Unlock() {LeaveCriticalSection(&amp;m_sec);} <br>void Init() {InitializeCriticalSection(&amp;m_sec);} <br>void Term() {DeleteCriticalSection(&amp;m_sec);} <br>CRITICAL_SECTION m_sec; <br>}; <br> <br>class CComAutoCriticalSection <br>{ <br>public: <br>void Lock() {EnterCriticalSection(&amp;m_sec);} <br>void Unlock() {LeaveCriticalSection(&amp;m_sec);} <br>CComAutoCriticalSection() {InitializeCriticalSection(&amp;m_sec);} <br>~CComAutoCriticalSection() {DeleteCriticalSection(&amp;m_sec);} <br>CRITICAL_SECTION m_sec; <br>}; <br> <br>class CComFakeCriticalSection <br>{ <br>public: <br>void Lock() {} <br>void Unlock() {} <br>void Init() {} <br>void Term() {} <br>}; <br> <br>class CComMultiThreadModelNoCS <br>{ <br>public: <br>static ULONG WINAPI Increment(LPLONG p) {return InterlockedIncrement(p);} <br>static ULONG WINAPI Decrement(LPLONG p) {return InterlockedDecrement(p);} <br>typedef CComFakeCriticalSection AutoCriticalSection; <br>typedef CComFakeCriticalSection CriticalSection; <br>typedef CComMultiThreadModelNoCS ThreadModelNoCS; <br>}; <br> <br>class CComMultiThreadModel <br>{ <br>public: <br>static ULONG WINAPI Increment(LPLONG p) {return InterlockedIncrement(p);} <br>static ULONG WINAPI Decrement(LPLONG p) {return InterlockedDecrement(p);} <br>typedef CComAutoCriticalSection AutoCriticalSection; <br>typedef CComCriticalSection CriticalSection; <br>typedef CComMultiThreadModelNoCS ThreadModelNoCS; <br>}; <br> <br>class CComSingleThreadModel <br>{ <br>public: <br>static ULONG WINAPI Increment(LPLONG p) {return ++(*p);} <br>static ULONG WINAPI Decrement(LPLONG p) {return --(*p);} <br>typedef CComFakeCriticalSection AutoCriticalSection; <br>typedef CComFakeCriticalSection CriticalSection; <br>typedef CComSingleThreadModel ThreadModelNoCS; <br>}; <br> <br>#ifndef _ATL_SINGLE_THREADED <br>#ifndef _ATL_APARTMENT_THREADED <br>#ifndef _ATL_FREE_THREADED <br>#define _ATL_FREE_THREADED <br>#endif <br>#endif <br>#endif <br> <br>#if defined(_ATL_SINGLE_THREADED) <br>typedef CComSingleThreadModel CComObjectThreadModel; <br>typedef CComSingleThreadModel CComGlobalsThreadModel; <br>#elif defined(_ATL_APARTMENT_THREADED) <br>typedef CComSingleThreadModel CComObjectThreadModel; <br>typedef CComMultiThreadModel CComGlobalsThreadModel; <br>#else <br>typedef CComMultiThreadModel CComObjectThreadModel; <br>typedef CComMultiThreadModel CComGlobalsThreadModel; <br>#endif <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// CComModule <br> <br>#define THREADFLAGS_APARTMENT 0x1 <br>#define THREADFLAGS_BOTH 0x2 <br>#define AUTPRXFLAG 0x4 <br> <br>struct _AtlCreateWndData <br>{ <br>void* m_pThis; <br>DWORD m_dwThreadID; <br>_AtlCreateWndData* m_pNext; <br>}; <br> <br>class CComModule : public _ATL_MODULE <br>{ <br>// Operations <br>public: <br>_AtlCreateWndData* m_pCreateWndList; <br> <br>void AddCreateWndData(_AtlCreateWndData* pData, void* pObject); <br>void* ExtractCreateWndData(); <br> <br>void Init(_ATL_OBJMAP_ENTRY* p, HINSTANCE h) <br>{ <br>cbSize = sizeof(_ATL_MODULE); <br>m_pCreateWndList = NULL; <br>AtlModuleInit(this, p, h); <br>} <br>void Term() <br>{ <br>AtlModuleTerm(this); <br>} <br> <br>LONG Lock() {return CComGlobalsThreadModel::Increment(&amp;m_nLockCnt);} <br>LONG Unlock() {return CComGlobalsThreadModel::Decrement(&amp;m_nLockCnt);} <br>LONG GetLockCount() {return m_nLockCnt;} <br> <br>HINSTANCE GetModuleInstance() {return m_hInst;} <br>HINSTANCE GetResourceInstance() {return m_hInstResource;} <br>HINSTANCE GetTypeLibInstance() {return m_hInstTypeLib;} <br> <br>// Registry support (helpers) <br>HRESULT RegisterTypeLib() <br>{ <br>return AtlModuleRegisterTypeLib(this, NULL); <br>} <br>HRESULT RegisterTypeLib(LPCTSTR lpszIndex) <br>{ <br>USES_CONVERSION; <br>return AtlModuleRegisterTypeLib(this, T2COLE(lpszIndex)); <br>} <br>HRESULT RegisterServer(BOOL bRegTypeLib = FALSE, const CLSID* pCLSID = NULL) <br>{ <br>return AtlModuleRegisterServer(this, bRegTypeLib, pCLSID); <br>} <br> <br>HRESULT UnregisterServer(const CLSID* pCLSID = NULL) <br>{ <br>return AtlModuleUnregisterServer(this, pCLSID); <br>} <br> <br>// Resource-based Registration <br>HRESULT WINAPI UpdateRegistryFromResourceD(LPCTSTR lpszRes, BOOL bRegister, <br>struct _ATL_REGMAP_ENTRY* pMapEntries = NULL) <br>{ <br>USES_CONVERSION; <br>return AtlModuleUpdateRegistryFromResourceD(this, T2COLE(lpszRes), bRegister, <br>pMapEntries); <br>} <br>HRESULT WINAPI UpdateRegistryFromResourceD(UINT nResID, BOOL bRegister, <br>struct _ATL_REGMAP_ENTRY* pMapEntries = NULL) <br>{ <br>return AtlModuleUpdateRegistryFromResourceD(this, <br>(LPCOLESTR)MAKEINTRESOURCE(nResID), bRegister, pMapEntries); <br>} <br> <br>#ifdef _ATL_STATIC_REGISTRY <br>// Statically linking to Registry Ponent <br>HRESULT WINAPI UpdateRegistryFromResourceS(LPCTSTR lpszRes, BOOL bRegister, <br>struct _ATL_REGMAP_ENTRY* pMapEntries = NULL); <br>HRESULT WINAPI UpdateRegistryFromResourceS(UINT nResID, BOOL bRegister, <br>struct _ATL_REGMAP_ENTRY* pMapEntries = NULL); <br>#endif //_ATL_STATIC_REGISTRY <br> <br>// Standard Registration <br>HRESULT WINAPI UpdateRegistryClass(const CLSID&amp; clsid, LPCTSTR lpszProgID, <br>LPCTSTR lpszVerIndProgID, UINT nDescID, DWORD dwFlags, BOOL bRegister); <br>HRESULT WINAPI RegisterClassHelper(const CLSID&amp; clsid, LPCTSTR lpszProgID, <br>LPCTSTR lpszVerIndProgID, UINT nDescID, DWORD dwFlags); <br>HRESULT WINAPI UnregisterClassHelper(const CLSID&amp; clsid, LPCTSTR lpszProgID, <br>LPCTSTR lpszVerIndProgID); <br> <br>// Register/Revoke All Class Factories with the OS (EXE only) <br>HRESULT RegisterClassObjects(DWORD dwClsContext, DWORD dwFlags) <br>{ <br>return AtlModuleRegisterClassObjects(this, dwClsContext, dwFlags); <br>} <br>HRESULT RevokeClassObjects() <br>{ <br>return AtlModuleRevokeClassObjects(this); <br>} <br> <br>// Obtain a Class Factory (DLL only) <br>HRESULT GetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv) <br>{ <br>return AtlModuleGetClassObject(this, rclsid, riid, ppv); <br>} <br> <br>// Only used in CComAutoThreadModule <br>HRESULT CreateInstance(void* /*pfnCreateInstance*/, REFIID /*riid*/, void** /*ppvObj*/) <br>{ <br>return S_OK; <br>} <br>}; <br> <br>///////////////////////////////////////////////////////////////////////////////////////////// <br>// Thread Pooling classes <br> <br>class _AtlAptCreateObjData <br>{ <br>public: <br>_ATL_CREATORFUNC* pfnCreateInstance; <br>const IID* piid; <br>HANDLE hEvent; <br>LPSTREAM pStream; <br>HRESULT hRes; <br>}; <br> <br>class CComApartment <br>{ <br>public: <br>static UINT ATL_CREATE_OBJECT; <br>static DWORD WINAPI _Apartment(void* pv) <br>{ <br>return ((CComApartment*)pv)-&gt;Apartment(); <br>} <br>DWORD Apartment() <br>{ <br>CoInitialize(NULL); <br>MSG msg; <br>while(GetMessage(&amp;msg, 0, 0, 0)) <br>{ <br>if (msg.message == ATL_CREATE_OBJECT) <br>{ <br>_AtlAptCreateObjData* pdata = (_AtlAptCreateObjData*)msg.lParam; <br>IUnknown* pUnk = NULL; <br>pdata-&gt;hRes = pdata-&gt;pfnCreateInstance(NULL, IID_IUnknown, (void**)&amp;pUnk); <br>if (SUCCEEDED(pdata-&gt;hRes)) <br>pdata-&gt;hRes = CoMarshalInterThreadInterfaceInStream(*pdata-&gt;piid, pUnk, &amp;pdata-&gt;pStream); <br>if (SUCCEEDED(pdata-&gt;hRes)) <br>{ <br>pUnk-&gt;Release(); <br>ATLTRACE(_T("Object created on thread = %d\n"), GetCurrentThreadId()); <br>} <br>SetEvent(pdata-&gt;hEvent); <br>} <br>DispatchMessage(&amp;msg); <br>} <br>CoUninitialize(); <br>return 0; <br>} <br>LONG Lock() {return CComGlobalsThreadModel::Increment(&amp;m_nLockCnt);} <br>LONG Unlock(){return CComGlobalsThreadModel::Decrement(&amp;m_nLockCnt); <br>} <br>LONG GetLockCount() {return m_nLockCnt;} <br> <br>DWORD m_dwThreadID; <br>HANDLE m_hThread; <br>LONG m_nLockCnt; <br>}; <br> <br>class CComSimpleThreadAllocator <br>{ <br>public: <br>CComSimpleThreadAllocator() <br>{ <br>m_nThread = 0; <br>} <br>int GetThread(CComApartment* /*pApt*/, int nThreads) <br>{ <br>if (++m_nThread == nThreads) <br>m_nThread = 0; <br>return m_nThread; <br>} <br>int m_nThread; <br>}; <br> <br>#if _MSC_VER&gt;1020 <br>template &lt;class ThreadAllocator = CComSimpleThreadAllocator&gt; <br>#else <br>template &lt;class ThreadAllocator&gt; <br>#endif <br>class CComAutoThreadModule : public CComModule <br>{ <br>public: <br>void Init(_ATL_OBJMAP_ENTRY* p, HINSTANCE h, int nThreads = GetDefaultThreads()); <br>~CComAutoThreadModule(); <br>HRESULT CreateInstance(void* pfnCreateInstance, REFIID riid, void** ppvObj); <br>LONG Lock(); <br>LONG Unlock(); <br>DWORD dwThreadID; <br>int m_nThreads; <br>CComApartment* m_pApartments; <br>ThreadAllocator m_Allocator; <br>static int GetDefaultThreads() <br>{ <br>SYSTEM_INFO si; <br>GetSystemInfo(&amp;si); <br>return si.dwNumberOfProcessors * 4; <br>} <br>}; <br> <br> <br> <br> <br>#ifdef _ATL_STATIC_REGISTRY <br>#define UpdateRegistryFromResource UpdateRegistryFromResourceS <br>#else <br>#define UpdateRegistryFromResource UpdateRegistryFromResourceD <br>#endif <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// CRegKey <br> <br>class CRegKey <br>{ <br>public: <br>CRegKey(); <br>~CRegKey(); <br> <br>// Attributes <br>public: <br>operator HKEY() const; <br>HKEY m_hKey; <br> <br>// Operations <br>public: <br>LONG SetValue(DWORD dwValue, LPCTSTR lpszValueName); <br>LONG QueryValue(DWORD&amp; dwValue, LPCTSTR lpszValueName); <br>LONG QueryValue(LPTSTR szValue, LPCTSTR lpszValueName, DWORD* pdwCount); <br>LONG SetValue(LPCTSTR lpszValue, LPCTSTR lpszValueName = NULL); <br> <br>LONG SetKeyValue(LPCTSTR lpszKeyName, LPCTSTR lpszValue, LPCTSTR lpszValueName = NULL); <br>static LONG WINAPI SetValue(HKEY hKeyParent, LPCTSTR lpszKeyName, <br>LPCTSTR lpszValue, LPCTSTR lpszValueName = NULL); <br> <br>LONG Create(HKEY hKeyParent, LPCTSTR lpszKeyName, <br>LPTSTR lpszClass = REG_NONE, DWORD dwOptions = REG_OPTION_NON_VOLATILE, <br>REGSAM samDesired = KEY_ALL_ACCESS, <br>LPSECURITY_ATTRIBUTES lpSecAttr = NULL, <br>LPDWORD lpdwDisposition = NULL); <br>LONG Open(HKEY hKeyParent, LPCTSTR lpszKeyName, <br>REGSAM samDesired = KEY_ALL_ACCESS); <br>LONG Close(); <br>HKEY Detach(); <br>void Attach(HKEY hKey); <br>LONG DeleteSubKey(LPCTSTR lpszSubKey); <br>LONG RecurseDeleteKey(LPCTSTR lpszKey); <br>LONG DeleteValue(LPCTSTR lpszValue); <br>}; <br> <br>inline CRegKey::CRegKey() <br>{m_hKey = NULL;} <br> <br>inline CRegKey::~CRegKey() <br>{Close();} <br> <br>inline CRegKey::operator HKEY() const <br>{return m_hKey;} <br> <br>inline HKEY CRegKey::Detach() <br>{ <br>HKEY hKey = m_hKey; <br>m_hKey = NULL; <br>return hKey; <br>} <br> <br>inline void CRegKey::Attach(HKEY hKey) <br>{ <br>_ASSERTE(m_hKey == NULL); <br>m_hKey = hKey; <br>} <br> <br>inline LONG CRegKey::DeleteSubKey(LPCTSTR lpszSubKey) <br>{ <br>_ASSERTE(m_hKey != NULL); <br>return RegDeleteKey(m_hKey, lpszSubKey); <br>} <br> <br>inline LONG CRegKey::DeleteValue(LPCTSTR lpszValue) </code></pre>
<p>
</p>
<pre><code>{ <br>_ASSERTE(m_hKey != NULL); <br>return RegDeleteValue(m_hKey, (LPTSTR)lpszValue); <br>} <br> <br>#pragma pack(pop) <br> <br>#ifndef ATL_NO_NAMESPACE <br>}; //namespace ATL <br>using namespace ATL; <br>#endif <br> <br>#endif // __ATLBASE_H__ <br> <br>///////////////////////////////////////////////////////////////////////////// </code></pre>
<p>&nbsp;</p></body>
</HTML>
