<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>STATREG.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3884"></a>STATREG.CPP</h2>
<pre><code>// This is a part of the Active Template Library. <br>// Copyright (C) 1996-1997 Microsoft Corporation <br>// All rights reserved. <br>// <br>// This source code is only intended as a supplement to the <br>// Active Template Library Reference and related <br>// electronic documentation provided with the library. <br>// See these sources for detailed information regarding the <br>// Active Template Library product. <br> <br>/////////////////////////////////////// <br>#define RET_ON_ERROR(x) \ <br>if (FAILED(hr = x))\ <br>return hr; <br>/////////////////////////////////////// <br>#define BREAK_ON_ERROR(x) \ <br>if (FAILED(hr = x))\ <br>break; <br>/////////////////////////////////////// <br>#ifdef _DEBUG <br>#define REPORT_ERROR(name, func) \ <br>if (func != ERROR_SUCCESS)\ <br>ATLTRACE(_T("NON CRITICAL ERROR : %s failed\n"), name); <br>#define REG_TRACE_RECOVER() \ <br>if (!bRecover) \ <br>ATLTRACE(_T("Opened Key %s\n"), szToken); \ <br>else \ <br>ATLTRACE(_T("Ignoring Open key on %s : In Recovery mode\n"), szToken); <br>#else //!_DEBUG <br>#define REG_TRACE_RECOVER() <br>#define REPORT_ERROR(name, func) \ <br>func; <br>#endif //_DEBUG <br> <br>/////////////////////////////////////// <br>#define MAX_TYPE            MAX_VALUE <br>#define MAX_VALUE           4096 <br> <br>#ifndef ATL_NO_NAMESPACE <br>namespace ATL <br>{ <br>#endif <br> <br>class CParseBuffer <br>{ <br>public: <br>int nPos; <br>int nSize; <br>LPTSTR p; <br>CParseBuffer(int nInitial); <br>~CParseBuffer() {CoTaskMemFree(p);} <br>BOOL AddChar(TCHAR ch); <br>BOOL AddString(LPCOLESTR lpsz); <br>LPTSTR Detach(); <br> <br>}; <br> <br>LPCTSTR   rgszNeverDelete[] = //Component Catagories <br>{ <br>_T("CLSID"), _T("TYPELIB") <br>}; <br> <br>const int   cbNeverDelete = sizeof(rgszNeverDelete) / sizeof(LPCTSTR*); <br> <br>static LPTSTR StrChr(LPTSTR lpsz, TCHAR ch) <br>{ <br>LPTSTR p = NULL; <br>while (*lpsz) <br>{ <br>if (*lpsz == ch) <br>{ <br>p = lpsz; <br>break; <br>} <br>lpsz = CharNext(lpsz); <br>} <br>return p; <br>} <br> <br>static HKEY WINAPI HKeyFromString(LPTSTR szToken) <br>{ <br>struct keymap <br>{ <br>LPCTSTR lpsz; <br>HKEY hkey; <br>}; <br>static const keymap map[] = { <br>{_T("HKCR"), HKEY_CLASSES_ROOT}, <br>{_T("HKCU"), HKEY_CURRENT_USER}, <br>{_T("HKLM"), HKEY_LOCAL_MACHINE}, <br>{_T("HKU"),  HKEY_USERS}, <br>{_T("HKPD"), HKEY_PERFORMANCE_DATA}, <br>{_T("HKDD"), HKEY_DYN_DATA}, <br>{_T("HKCC"), HKEY_CURRENT_CONFIG}, <br>{_T("HKEY_CLASSES_ROOT"), HKEY_CLASSES_ROOT}, <br>{_T("HKEY_CURRENT_USER"), HKEY_CURRENT_USER}, <br>{_T("HKEY_LOCAL_MACHINE"), HKEY_LOCAL_MACHINE}, <br>{_T("HKEY_USERS"), HKEY_USERS}, <br>{_T("HKEY_PERFORMANCE_DATA"), HKEY_PERFORMANCE_DATA}, <br>{_T("HKEY_DYN_DATA"), HKEY_DYN_DATA}, <br>{_T("HKEY_CURRENT_CONFIG"), HKEY_CURRENT_CONFIG} <br>}; <br> <br>for (int i=0;i&lt;sizeof(map)/sizeof(keymap);i++) <br>{ <br>if (!lstrcmpi(szToken, map[i].lpsz)) <br>return map[i].hkey; <br>} <br>return NULL; <br>} <br> <br>static HKEY HKeyFromCompoundString(LPTSTR szToken, LPTSTR&amp; szTail) <br>{ <br>if (NULL == szToken) <br>return NULL; <br> <br>LPTSTR lpsz = StrChr(szToken, chDirSep); <br> <br>if (NULL == lpsz) <br>return NULL; <br> <br>szTail = CharNext(lpsz); <br>*lpsz = chEOS; <br>HKEY hKey = HKeyFromString(szToken); <br>*lpsz = chDirSep; <br>return hKey; <br>} <br> <br>static LPVOID QueryValue(HKEY hKey, LPCTSTR szValName, DWORD&amp; dwType) <br>{ <br>DWORD dwCount = 0; <br> <br>if (RegQueryValueEx(hKey, szValName, NULL, &amp;dwType, NULL, &amp;dwCount) != ERROR_SUCCESS) <br>{ <br>ATLTRACE(_T("RegQueryValueEx failed for Value %s\n"), szValName); <br>return NULL; <br>} <br> <br>if (!dwCount) <br>{ <br>ATLTRACE(_T("RegQueryValueEx returned 0 bytes\n")); <br>return NULL; <br>} <br> <br>// Not going to Check for fail on CoTaskMemAlloc &amp; RegQueryValueEx as NULL <br>// will be returned regardless if anything failed <br> <br>LPVOID pData = CoTaskMemAlloc(dwCount); <br>RegQueryValueEx(hKey, szValName, NULL, &amp;dwType, (LPBYTE) pData, &amp;dwCount); <br>return pData; <br>} <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// <br> <br>HRESULT CRegParser::GenerateError(UINT nID) <br>{ <br>//  m_re.m_nID   = nID; <br>//  m_re.m_cLines = m_cLines; <br>return DISP_E_EXCEPTION; <br>} <br> <br> <br>CRegParser::CRegParser(CRegObject* pRegObj) <br>{ <br>m_pRegObj           = pRegObj; <br>m_pchCur            = NULL; <br>m_cLines            = 1; <br>} <br> <br>BOOL CRegParser::IsSpace(TCHAR ch) <br>{ <br>switch (ch) <br>{ <br>case chSpace: <br>case chTab: <br>case chCR: <br>case chLF: <br>return TRUE; <br>} <br> <br>return FALSE; <br>} <br> <br>void CRegParser::IncrementLinePos() <br>{ <br>m_pchCur = CharNext(m_pchCur); <br>if (chLF == *m_pchCur) <br>IncrementLineCount(); <br>} <br> <br>void CRegParser::SkipWhiteSpace() <br>{ <br>while(IsSpace(*m_pchCur)) <br>IncrementLinePos(); <br>} <br> <br>HRESULT CRegParser::NextToken(LPTSTR szToken) <br>{ <br>USES_CONVERSION; <br> <br>UINT ichToken = 0; <br> <br>SkipWhiteSpace(); <br> <br>// NextToken cannot be called at EOS <br>if (chEOS == *m_pchCur) <br>return GenerateError(E_ATL_UNEXPECTED_EOS); <br> <br>// handle quoted value / key <br>if (chQuote == *m_pchCur) <br>{ <br>LPCTSTR szOrig = szToken; <br> <br>IncrementLinePos(); // Skip Quote <br> <br>while (chEOS != *m_pchCur &amp;&amp; !EndOfVar()) <br>{ <br>if (chQuote == *m_pchCur) // If it is a quote that means we must skip it <br>IncrementLinePos();   // as it has been escaped <br> <br>LPTSTR pchPrev = m_pchCur; <br>IncrementLinePos(); <br> <br>if (szToken + sizeof(WORD) &gt;= MAX_VALUE + szOrig) <br>return GenerateError(E_ATL_VALUE_TOO_LARGE); <br>for (int i = 0; pchPrev+i &lt; m_pchCur; i++, szToken++) <br>*szToken = *(pchPrev+i); <br>} <br> <br>if (chEOS == *m_pchCur) <br>{ <br>ATLTRACE(_T("NextToken : Unexpected End of File\n")); <br>return GenerateError(E_ATL_UNEXPECTED_EOS); <br>} <br> <br>*szToken = chEOS; <br>IncrementLinePos(); // Skip end quote <br>} <br> <br>else <br>{   // Handle non-quoted ie parse up till first "White Space" <br>while (chEOS != *m_pchCur &amp;&amp; !IsSpace(*m_pchCur)) <br>{ <br>LPTSTR pchPrev = m_pchCur; <br>IncrementLinePos(); <br>for (int i = 0; pchPrev+i &lt; m_pchCur; i++, szToken++) <br>*szToken = *(pchPrev+i); <br>} <br> <br>*szToken = chEOS; <br>} <br>return S_OK; <br>} <br> <br>static BOOL VTFromRegType(LPCTSTR szValueType, VARTYPE&amp; vt) <br>{ <br>struct typemap <br>{ <br>LPCTSTR lpsz; <br>VARTYPE vt; <br>}; <br>static const typemap map[] = { <br>{szStringVal, VT_BSTR}, <br>{szDwordVal,  VT_I4} <br>}; <br> <br>for (int i=0;i&lt;sizeof(map)/sizeof(typemap);i++) <br>{ <br>if (!lstrcmpi(szValueType, map[i].lpsz)) <br>{ <br>vt = map[i].vt; <br>return TRUE; <br>} <br>} <br> <br>return FALSE; <br> <br>} <br> <br>HRESULT CRegParser::AddValue(CRegKey&amp; rkParent,LPCTSTR szValueName, LPTSTR szToken) <br>{ <br>USES_CONVERSION; <br>HRESULT hr; <br> <br>TCHAR       szTypeToken[MAX_TYPE]; <br>VARTYPE     vt; <br>LONG        lRes = ERROR_SUCCESS; <br>UINT        nIDRes = 0; <br> <br>RET_ON_ERROR(NextToken(szTypeToken)) <br>if (!VTFromRegType(szTypeToken, vt)) <br>{ <br>ATLTRACE(_T("%s Type not supported\n"), szTypeToken); <br>return GenerateError(E_ATL_TYPE_NOT_SUPPORTED); <br>} <br> <br>TCHAR szValue[MAX_VALUE]; <br>SkipWhiteSpace(); <br>RET_ON_ERROR(NextToken(szValue)); <br>long lVal; <br> <br>switch (vt) <br>{ <br>case VT_BSTR: <br>lRes = rkParent.SetValue(szValue, szValueName); <br>ATLTRACE(_T("Setting Value %s at %s\n"), szValue, !szValueName ? _T("default") : szValueName); <br>break; <br>case VT_I4: <br>VarI4FromStr(T2OLE(szValue), 0, 0, &amp;lVal); <br>lRes = rkParent.SetValue(lVal, szValueName); <br>ATLTRACE(_T("Setting Value %d at %s\n"), lVal, !szValueName ? _T("default") : szValueName); <br>break; <br>} <br> <br>if (ERROR_SUCCESS != lRes) <br>{ <br>nIDRes = E_ATL_VALUE_SET_FAILED; <br>hr = HRESULT_FROM_WIN32(lRes); <br>} <br> <br>RET_ON_ERROR(NextToken(szToken)) <br> <br>return S_OK; <br>} <br> <br>BOOL CRegParser::CanForceRemoveKey(LPCTSTR szKey) <br>{ <br>for (int iNoDel = 0; iNoDel &lt; cbNeverDelete; iNoDel++) <br>if (!lstrcmpi(szKey, rgszNeverDelete[iNoDel])) <br> return FALSE;                       // We cannot delete it <br> <br>return TRUE; <br>} <br> <br>BOOL CRegParser::HasSubKeys(HKEY hkey) <br>{ <br>DWORD       cbSubKeys = 0; <br> <br>if (FAILED(RegQueryInfoKey(hkey, NULL, NULL, NULL, <br>   &amp;cbSubKeys, NULL, NULL, <br>   NULL, NULL, NULL, NULL, NULL))) <br>{ <br>ATLTRACE(_T("Should not be here!!\n")); <br>_ASSERTE(FALSE); <br>return FALSE; <br>} <br> <br>return cbSubKeys &gt; 0; <br>} <br> <br>BOOL CRegParser::HasValues(HKEY hkey) <br>{ <br>DWORD       cbValues = 0; <br> <br>LONG lResult = RegQueryInfoKey(hkey, NULL, NULL, NULL, <br>  NULL, NULL, NULL, <br>  &amp;cbValues, NULL, NULL, NULL, NULL); <br>if (ERROR_SUCCESS != lResult) <br>{ <br>ATLTRACE(_T("RegQueryInfoKey Failed ")); <br>_ASSERTE(FALSE); <br>return FALSE; <br>} <br> <br>if (1 == cbValues) <br>{ <br>DWORD cbData = 0; <br>lResult = RegQueryValueEx(hkey, NULL, NULL, NULL, NULL, &amp;cbData); <br> <br>if (ERROR_SUCCESS == lResult) <br>return !cbData; <br>else <br>return TRUE; <br>} <br> <br>return cbValues &gt; 0; <br>} <br> <br>HRESULT CRegParser::SkipAssignment(LPTSTR szToken) <br>{ <br>HRESULT hr; <br>TCHAR szValue[MAX_VALUE]; <br> <br>if (*szToken == chEquals) <br>{ <br>RET_ON_ERROR(NextToken(szToken)) <br>// Skip assignment <br>SkipWhiteSpace(); <br>RET_ON_ERROR(NextToken(szValue)); <br>RET_ON_ERROR(NextToken(szToken)) <br>} <br> <br>return S_OK; <br>} <br> <br> <br>HRESULT CRegParser::RegisterSubkeys(HKEY hkParent, BOOL bRegister, BOOL bRecover) <br>{ <br>CRegKey keyCur; <br>TCHAR   szToken[MAX_VALUE]; <br>LONG    lRes; <br>TCHAR   szKey[MAX_VALUE]; <br>BOOL    bDelete = TRUE; <br>BOOL    bInRecovery = bRecover; <br>HRESULT hr = S_OK; <br> <br>ATLTRACE(_T("Num Els = %d\n"), cbNeverDelete); <br>RET_ON_ERROR(NextToken(szToken))  // Should be key name <br> <br> <br>while (*szToken != chRightBracket) // Continue till we see a } <br>{ <br>BOOL bTokenDelete = !lstrcmpi(szToken, szDelete); <br> <br>if (!lstrcmpi(szToken, szForceRemove) || bTokenDelete) <br>{ <br>BREAK_ON_ERROR(NextToken(szToken)) <br> <br>if (bRegister) <br>{ <br>CRegKey rkForceRemove; <br> <br>if (StrChr(szToken, chDirSep) != NULL) <br>return GenerateError(E_ATL_COMPOUND_KEY); <br> <br>if (CanForceRemoveKey(szToken)) <br>{ <br>rkForceRemove.Attach(hkParent); <br>rkForceRemove.RecurseDeleteKey(szToken); <br>rkForceRemove.Detach(); <br>} <br>if (bTokenDelete) <br>{ <br>BREAK_ON_ERROR(NextToken(szToken)) <br>BREAK_ON_ERROR(SkipAssignment(szToken)) <br>goto EndCheck; <br>} <br>} <br> <br>} <br> <br>if (!lstrcmpi(szToken, szNoRemove)) <br>{ <br>bDelete = FALSE;    // set even for register <br>BREAK_ON_ERROR(NextToken(szToken)) <br>} <br> <br>if (!lstrcmpi(szToken, szValToken)) // need to add a value to hkParent <br>{ <br>TCHAR  szValueName[_MAX_PATH]; <br> <br>BREAK_ON_ERROR(NextToken(szValueName)) <br>BREAK_ON_ERROR(NextToken(szToken)) <br> <br>if (*szToken != chEquals) <br>return GenerateError(E_ATL_EXPECTING_EQUAL); <br> <br>if (bRegister) <br>{ <br>CRegKey rk; <br> <br>rk.Attach(hkParent); <br>hr = AddValue(rk, szValueName, szToken); <br>rk.Detach(); <br> <br>if (FAILED(hr)) <br>return hr; <br> <br>goto EndCheck; <br>} <br>else <br>{ <br>if (!bRecover) <br>{ <br>ATLTRACE(_T("Deleting %s\n"), szValueName); <br>REPORT_ERROR(_T("RegDeleteValue"), RegDeleteValue(hkParent, szValueName)) <br>} <br> <br>BREAK_ON_ERROR(SkipAssignment(szToken)) // Strip off type <br>continue;  // can never have a subkey <br>} <br>} <br> <br>if (StrChr(szToken, chDirSep) != NULL) <br>return GenerateError(E_ATL_COMPOUND_KEY); <br> <br>if (bRegister) <br>{ <br>lRes = keyCur.Open(hkParent, szToken, KEY_ALL_ACCESS); <br>if (ERROR_SUCCESS != lRes) <br>{ <br>// Failed all access try read only <br>lRes = keyCur.Open(hkParent, szToken, KEY_READ); <br>if (ERROR_SUCCESS != lRes) <br>{ <br>// Finally try creating it <br>ATLTRACE(_T("Creating key %s\n"), szToken); <br>lRes = keyCur.Create(hkParent, szToken); <br>if (ERROR_SUCCESS != lRes) <br>return GenerateError(E_ATL_CREATE_KEY_FAILED); <br>} <br>} <br> <br>BREAK_ON_ERROR(NextToken(szToken)) <br> <br>if (*szToken == chEquals) <br>BREAK_ON_ERROR(AddValue(keyCur, NULL, szToken)) // NULL == default <br>} <br>else <br>{ <br>if (!bRecover &amp;&amp; keyCur.Open(hkParent, szToken) != ERROR_SUCCESS) <br>bRecover = TRUE; <br> <br>// TRACE out Key open status and if in recovery mode <br>REG_TRACE_RECOVER() <br> <br>// Remember Subkey <br>lstrcpyn(szKey, szToken, _MAX_PATH); <br> <br>// If in recovery mode <br> <br>if (bRecover || HasSubKeys(keyCur) || HasValues(keyCur)) <br>{ <br>BREAK_ON_ERROR(NextToken(szToken)) <br>BREAK_ON_ERROR(SkipAssignment(szToken)) <br> <br>if (*szToken == chLeftBracket) <br>{ <br>BREAK_ON_ERROR(RegisterSubkeys(keyCur.m_hKey, bRegister, bRecover)) <br>if (bRecover) // Turn off recovery if we are done <br>{ <br>bRecover = bInRecovery; <br>ATLTRACE(_T("Ending Recovery Mode\n")); <br>BREAK_ON_ERROR(NextToken(szToken)) <br>BREAK_ON_ERROR(SkipAssignment(szToken)) <br>continue; <br>} <br>} <br> <br>if (!bRecover &amp;&amp; HasSubKeys(keyCur)) <br>{ <br>// See if the KEY is in the NeverDelete list and if so, don't <br>if (CanForceRemoveKey(szKey)) <br>{ <br>ATLTRACE(_T("Deleting non-empty subkey %s by force\n"), szKey); <br>REPORT_ERROR(_T("RecurseDeleteKey"), keyCur.RecurseDeleteKey(szKey)) <br>} <br>BREAK_ON_ERROR(NextToken(szToken)) <br>continue; <br>} <br> <br>if (bRecover) <br>continue; <br>} <br> <br>if (!bRecover &amp;&amp; keyCur.Close() != ERROR_SUCCESS) <br>   return GenerateError(E_ATL_CLOSE_KEY_FAILED); <br> <br>if (!bRecover &amp;&amp; bDelete) <br>{ <br>ATLTRACE(_T("Deleting Key %s\n"), szKey); <br>REPORT_ERROR(_T("RegDeleteKey"), RegDeleteKey(hkParent, szKey)) <br>} <br> <br>BREAK_ON_ERROR(NextToken(szToken)) <br>BREAK_ON_ERROR(SkipAssignment(szToken)) <br>} <br> <br>EndCheck: <br> <br>if (bRegister) <br>{ <br>if (*szToken == chLeftBracket) <br>{ <br>BREAK_ON_ERROR(RegisterSubkeys(keyCur.m_hKey, bRegister, FALSE)) <br>BREAK_ON_ERROR(NextToken(szToken)) <br>} <br>} <br>} <br> <br>return hr; <br>} <br> <br>LPTSTR CParseBuffer::Detach() <br>{ <br>LPTSTR lp = p; <br>p = NULL; <br>return lp; <br>} <br> <br>CParseBuffer::CParseBuffer(int nInitial) <br>{ <br>nPos = 0; <br>nSize = nInitial; <br>p = (LPTSTR) CoTaskMemAlloc(nSize*sizeof(TCHAR)); <br>} <br> <br>BOOL CParseBuffer::AddString(LPCOLESTR lpsz) <br>{ <br>USES_CONVERSION; <br>LPCTSTR lpszT = OLE2CT(lpsz); <br>while (*lpszT) <br>{ <br>AddChar(*lpszT); <br>lpszT++; <br>} <br>return TRUE; <br>} <br> <br>BOOL CParseBuffer::AddChar(TCHAR ch) <br>{ <br>if (nPos == nSize) // realloc <br>{ <br>nSize *= 2; <br>p = (LPTSTR) CoTaskMemRealloc(p, nSize*sizeof(TCHAR)); <br>} <br>p[nPos++] = ch; <br>return TRUE; <br>} <br> <br>HRESULT CRegParser::PreProcessBuffer(LPTSTR lpszReg, LPTSTR* ppszReg) <br>{ <br>USES_CONVERSION; <br>_ASSERTE(lpszReg != NULL); <br>_ASSERTE(ppszReg != NULL); <br>*ppszReg = NULL; <br>int nSize = lstrlen(lpszReg)*2; <br>CParseBuffer pb(nSize); <br>if (pb.p == NULL) <br>return E_OUTOFMEMORY; <br>m_pchCur = lpszReg; <br>HRESULT hr = S_OK; <br> <br>while (*m_pchCur != NULL) // look for end <br>{ <br>if (*m_pchCur == _T('%')) <br>{ <br>IncrementLinePos(); <br>if (*m_pchCur == _T('%')) <br>pb.AddChar(*m_pchCur); <br>else <br>{ <br>LPTSTR lpszNext = StrChr(m_pchCur, _T('%')); <br>if (lpszNext == NULL) <br>{ <br>ATLTRACE(_T("Error no closing % found\n")); <br>hr = GenerateError(E_ATL_UNEXPECTED_EOS); <br>break; <br>} <br>int nLength = lpszNext - m_pchCur; <br>if (nLength &gt; 31) <br>{ <br>hr = E_FAIL; <br>break; <br>} <br>TCHAR buf[32]; <br>lstrcpyn(buf, m_pchCur, nLength+1); <br>LPCOLESTR lpszVar = m_pRegObj-&gt;StrFromMap(buf); <br>if (lpszVar == NULL) <br>{ <br>hr = GenerateError(E_ATL_NOT_IN_MAP); <br>break; <br>} <br>pb.AddString(lpszVar); <br>while (m_pchCur != lpszNext) <br>IncrementLinePos(); <br>} <br>} <br>else <br>pb.AddChar(*m_pchCur); <br>IncrementLinePos(); <br>} <br>pb.AddChar(NULL); <br>if (SUCCEEDED(hr)) <br>*ppszReg = pb.Detach(); <br>return hr; <br>} <br> <br>HRESULT CRegParser::RegisterBuffer(LPTSTR szBuffer, BOOL bRegister) <br>{ <br>TCHAR   szToken[_MAX_PATH]; <br>HRESULT hr = S_OK; <br> <br>LPTSTR szReg; <br>hr = PreProcessBuffer(szBuffer, &amp;szReg); <br>if (FAILED(hr)) <br>return hr; <br> <br>m_pchCur = szReg; <br> <br>// Preprocess szReg <br> <br>while (chEOS != *m_pchCur) <br>{ <br>BREAK_ON_ERROR(NextToken(szToken)) <br>HKEY hkBase; <br>if ((hkBase = HKeyFromString(szToken)) == NULL) <br>{ <br>ATLTRACE(_T("HKeyFromString failed on %s\n"), szToken); <br>hr = GenerateError(E_ATL_BAD_HKEY); <br>break; <br>} <br> <br>BREAK_ON_ERROR(NextToken(szToken)) <br> <br>if (chLeftBracket != *szToken) <br>{ <br>ATLTRACE(_T("Syntax error, expecting a {, found a %s\n"), szToken); <br>hr = GenerateError(E_ATL_MISSING_OPENKEY_TOKEN); <br>break; <br>} <br>if (bRegister) <br>{ <br>LPTSTR szRegAtRegister = m_pchCur; <br>hr = RegisterSubkeys(hkBase, bRegister); <br>if (FAILED(hr)) <br>{ <br>ATLTRACE(_T("Failed to register, cleaning up!\n")); <br>m_pchCur = szRegAtRegister; <br>RegisterSubkeys(hkBase, FALSE); <br>break; <br>} <br>} <br>else <br>{ <br>BREAK_ON_ERROR(RegisterSubkeys(hkBase, bRegister)) <br>} <br> <br>SkipWhiteSpace(); <br>} <br>CoTaskMemFree(szReg); <br>return hr; <br>} <br> <br>HRESULT CExpansionVector::Add(LPCOLESTR lpszKey, LPCOLESTR lpszValue) <br>{ <br>USES_CONVERSION; <br>HRESULT hr = S_OK; <br> <br>EXPANDER* pExpand = NULL; <br>ATLTRY(pExpand = new EXPANDER); <br>if (pExpand == NULL) <br>return E_OUTOFMEMORY; <br> <br>DWORD cbKey = (ocslen(lpszKey)+1)*sizeof(OLECHAR); <br>DWORD cbValue = (ocslen(lpszValue)+1)*sizeof(OLECHAR); <br>pExpand-&gt;szKey = (LPOLESTR)CoTaskMemAlloc(cbKey); <br>pExpand-&gt;szValue = (LPOLESTR)CoTaskMemAlloc(cbValue); <br>if (pExpand-&gt;szKey == NULL || pExpand-&gt;szValue == NULL) <br>{ <br>CoTaskMemFree(pExpand-&gt;szKey); <br>CoTaskMemFree(pExpand-&gt;szValue); <br>delete pExpand; <br>return E_OUTOFMEMORY; <br>} <br>memcpy(pExpand-&gt;szKey, lpszKey, cbKey); <br>memcpy(pExpand-&gt;szValue, lpszValue, cbValue); <br> <br>if (m_cEls == m_nSize) <br>{ <br>m_nSize*=2; <br>m_p = (EXPANDER**)realloc(m_p, m_nSize*sizeof(EXPANDER*)); <br>} <br> <br>if (NULL != m_p) <br>{ <br>m_p[m_cEls] = pExpand; <br>m_cEls++; <br>} <br>else <br>hr = E_OUTOFMEMORY; <br> <br>return hr; <br> <br>} <br> <br>LPCOLESTR CExpansionVector::Find(LPTSTR lpszKey) <br>{ <br>USES_CONVERSION; <br>for (int iExpand = 0; iExpand &lt; m_cEls; iExpand++) <br>{ <br>if (!lstrcmpi(OLE2T(m_p[iExpand]-&gt;szKey), lpszKey)) //are equal <br>return m_p[iExpand]-&gt;szValue; <br>} <br>return NULL; <br>} <br> <br>HRESULT CExpansionVector::ClearReplacements() <br>{ <br>for (int iExpand = 0; iExpand &lt; m_cEls; iExpand++) <br>{ <br>EXPANDER* pExp = m_p[iExpand]; <br>CoTaskMemFree(pExp-&gt;szValue); <br>CoTaskMemFree(pExp-&gt;szKey); <br>delete pExp; <br>} <br>m_cEls = 0; <br>return S_OK; <br>} <br> <br>HRESULT CRegObject::GenerateError(UINT nID) <br>{ <br>//  re.m_nID    = nID; <br>//  re.m_cLines = -1; <br> <br>return DISP_E_EXCEPTION; <br>} <br> <br>HRESULT STDMETHODCALLTYPE CRegObject::AddReplacement(LPCOLESTR lpszKey, LPCOLESTR lpszItem) <br>{ <br>m_csMap.Lock(); <br>HRESULT hr = m_RepMap.Add(lpszKey, lpszItem); <br>m_csMap.Unlock(); <br>return hr; <br>} <br> <br>HRESULT CRegObject::RegisterFromResource(LPCOLESTR bstrFileName, LPCTSTR szID, <br> LPCTSTR szType, BOOL bRegister) <br>{ <br>USES_CONVERSION; <br> <br>HRESULT     hr; <br>CRegParser  parser(this); <br>HINSTANCE   hInstResDll; <br>HRSRC       hrscReg; <br>HGLOBAL     hReg; <br>DWORD       dwSize; <br>LPSTR       szRegA; <br>LPTSTR      szReg; <br> <br>hInstResDll = LoadLibraryEx(OLE2CT(bstrFileName), NULL, LOAD_LIBRARY_AS_DATAFILE); <br> <br>if (NULL == hInstResDll) <br>{ <br>ATLTRACE(_T("Failed to LoadLibrary on %s\n"), OLE2CT(bstrFileName)); <br>hr = HRESULT_FROM_WIN32(GetLastError()); <br>goto ReturnHR; <br>} <br> <br>hrscReg = FindResource((HMODULE)hInstResDll, szID, szType); <br> <br>if (NULL == hrscReg) <br>{ <br>ATLTRACE(_T("Failed to FindResource on ID:%s TYPE:%s\n"), szID, szType); <br>hr = HRESULT_FROM_WIN32(GetLastError()); <br>goto ReturnHR; <br>} <br> <br>hReg = LoadResource((HMODULE)hInstResDll, hrscReg); <br> <br>if (NULL == hReg) <br>{ <br>ATLTRACE(_T("Failed to LoadResource \n")); <br>hr = HRESULT_FROM_WIN32(GetLastError()); <br>goto ReturnHR; <br>} <br> <br>dwSize = SizeofResource((HMODULE)hInstResDll, hrscReg); <br>szRegA = (LPSTR)hReg; <br>if (szRegA[dwSize] != NULL) <br>{ <br>szRegA = (LPSTR)_alloca(dwSize+1); <br>memcpy(szRegA, (void*)hReg, dwSize+1); <br>szRegA[dwSize] = NULL; <br>} <br> <br>szReg = A2T(szRegA); <br> <br>#ifdef _DEBUG <br>OutputDebugString(szReg); //would call ATLTRACE but szReg is &gt; 512 bytes <br>OutputDebugString(_T("\n")); <br>#endif //_DEBUG <br> <br>hr = parser.RegisterBuffer(szReg, bRegister); <br> <br>ReturnHR: <br> <br>if (NULL != hInstResDll) <br>FreeLibrary((HMODULE)hInstResDll); <br>return hr; <br>} <br> <br>HRESULT STDMETHODCALLTYPE CRegObject::ResourceRegister(LPCOLESTR szFileName, UINT nID, LPCOLESTR szType) <br>{ <br>USES_CONVERSION; <br>return RegisterFromResource(szFileName, MAKEINTRESOURCE(nID), OLE2CT(szType), TRUE); <br>} <br> <br>HRESULT STDMETHODCALLTYPE CRegObject::ResourceRegisterSz(LPCOLESTR szFileName, LPCOLESTR szID, LPCOLESTR szType) <br>{ <br>USES_CONVERSION; <br> <br>if (szID == NULL || szType == NULL) <br>return E_INVALIDARG; <br> <br>return RegisterFromResource(szFileName, OLE2CT(szID), OLE2CT(szType), TRUE); <br>} <br> <br>HRESULT STDMETHODCALLTYPE CRegObject::ResourceUnregister(LPCOLESTR szFileName, UINT nID, LPCOLESTR szType) <br>{ <br>USES_CONVERSION; <br>return RegisterFromResource(szFileName, MAKEINTRESOURCE(nID), OLE2CT(szType), FALSE); <br>} <br> <br>HRESULT STDMETHODCALLTYPE CRegObject::ResourceUnregisterSz(LPCOLESTR szFileName, LPCOLESTR szID, LPCOLESTR szType) <br>{ <br>USES_CONVERSION; <br>if (szID == NULL || szType == NULL) <br>return E_INVALIDARG; <br> <br>return RegisterFromResource(szFileName, OLE2CT(szID), OLE2CT(szType), FALSE); <br>} <br> <br>HRESULT CRegObject::RegisterWithString(LPCOLESTR bstrData, BOOL bRegister) <br>{ <br>USES_CONVERSION; <br>CRegParser  parser(this); <br> <br> <br>LPCTSTR szReg = OLE2CT(bstrData); <br> <br>#ifdef _DEBUG <br>OutputDebugString(szReg); //would call ATLTRACE but szReg is &gt; 512 bytes <br>OutputDebugString(_T("\n")); <br>#endif //_DEBUG <br> <br>HRESULT hr = parser.RegisterBuffer((LPTSTR)szReg, bRegister); <br> <br>return hr; <br>} <br> <br>HRESULT CRegObject::ClearReplacements() <br>{ <br>m_csMap.Lock(); <br>HRESULT hr = m_RepMap.ClearReplacements(); <br>m_csMap.Unlock(); <br>return hr; <br>} <br> <br> <br>LPCOLESTR CRegObject::StrFromMap(LPTSTR lpszKey) <br>{ <br>m_csMap.Lock(); <br>LPCOLESTR lpsz = m_RepMap.Find(lpszKey); <br>if (lpsz == NULL) // not found!! <br>ATLTRACE(_T("Map Entry not found\n")); <br>m_csMap.Unlock(); <br>return lpsz; <br>} <br> <br>HRESULT CRegObject::MemMapAndRegister(LPCOLESTR bstrFileName, BOOL bRegister) <br>{ <br>USES_CONVERSION; <br> <br>CRegParser  parser(this); <br> <br>HANDLE hFile = CreateFile(OLE2CT(bstrFileName), GENERIC_READ, 0, NULL, <br>  OPEN_EXISTING, <br>  FILE_ATTRIBUTE_READONLY, <br>  NULL); <br> <br>if (NULL == hFile) <br>{ <br>ATLTRACE(_T("Failed to CreateFile on %s\n"), OLE2CT(bstrFileName)); <br>return HRESULT_FROM_WIN32(GetLastError()); <br>} <br> <br>DWORD cbFile = GetFileSize(hFile, NULL); // No HiOrder DWORD required <br> <br>HANDLE hMapping = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0, NULL); <br> <br>if (NULL == hMapping) <br>{ <br>ATLTRACE(_T("Failed to CreateFileMapping\n")); <br>return HRESULT_FROM_WIN32(GetLastError()); <br>} <br> <br>LPVOID pMap = MapViewOfFile(hMapping, FILE_MAP_READ, 0, 0, 0); <br> <br>if (NULL == pMap) <br>{ <br>ATLTRACE(_T("Failed to MapViewOfFile\n")); <br>return HRESULT_FROM_WIN32(GetLastError()); <br>} <br> <br>LPTSTR szReg = A2T((char*)pMap); <br> <br>if (chEOS != szReg[cbFile]) //ensure buffer is NULL terminated <br>{ <br>ATLTRACE(_T("ERROR : Bad or missing End of File\n")); <br>return E_FAIL; // make a real error <br>} <br> <br>#ifdef _DEBUG <br>OutputDebugString(szReg); //would call ATLTRACE but szReg is &gt; 512 bytes <br>OutputDebugString(_T("\n")); <br>#endif //_DEBUG <br> <br>HRESULT hRes = parser.RegisterBuffer(szReg, bRegister); <br> <br>//  if (FAILED(hRes)) <br>//      re = parser.GetRegException(); <br> <br>UnmapViewOfFile(pMap); <br>CloseHandle(hMapping); <br>CloseHandle(hFile); <br> <br>return hRes; <br>} <br> <br>HRESULT STDMETHODCALLTYPE CRegObject::FileRegister(LPCOLESTR bstrFileName) <br>{ <br>return MemMapAndRegister(bstrFileName, TRUE); <br>} <br> <br>HRESULT STDMETHODCALLTYPE CRegObject::FileUnregister(LPCOLESTR bstrFileName) <br>{ <br>return MemMapAndRegister(bstrFileName, FALSE); <br>} <br> <br>HRESULT STDMETHODCALLTYPE CRegObject::StringRegister(LPCOLESTR bstrData) <br>{ <br>return RegisterWithString(bstrData, TRUE); <br>} <br> <br>HRESULT STDMETHODCALLTYPE CRegObject::StringUnregister(LPCOLESTR bstrData) <br>{ <br>return RegisterWithString(bstrData, FALSE); <br>} <br> <br>#ifndef ATL_NO_NAMESPACE <br>}; //namespace ATL <br>#endif </code></pre>
<p>&nbsp;</p></body>
</HTML>
