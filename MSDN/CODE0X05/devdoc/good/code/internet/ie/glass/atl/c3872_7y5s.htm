<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>ATLIMPL.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3880"></a>ATLIMPL.CPP</h2>
<pre><code>// This is a part of the Active Template Library. <br>// Copyright (C) 1996-1997 Microsoft Corporation <br>// All rights reserved. <br>// <br>// This source code is only intended as a supplement to the <br>// Active Template Library Reference and related <br>// electronic documentation provided with the library. <br>// See these sources for detailed information regarding the <br>// Active Template Library product. <br> <br>#ifndef __ATLBASE_H__ <br>#error atlimpl.cpp requires atlbase.h to be included first <br>#endif <br> <br>extern "C" const IID IID_IRegistrar = {0x44EC053B,0x400F,0x11D0,{0x9D,0xCD,0x00,0xA0,0xC9,0x03,0x91,0xD3}}; <br>#ifndef _ATL_DLL_IMPL <br>extern "C" const CLSID CLSID_Registrar = {0x44EC053A,0x400F,0x11D0,{0x9D,0xCD,0x00,0xA0,0xC9,0x03,0x91,0xD3}}; <br>#endif <br> <br>#include &lt;atlconv.cpp&gt; <br>#ifdef _DEBUG <br>#include &lt;stdio.h&gt; <br>#include &lt;stdarg.h&gt; <br>#endif <br> <br>#ifndef ATL_NO_NAMESPACE <br>namespace ATL <br>{ <br>#endif <br> <br>// used in thread pooling <br>UINT CComApartment::ATL_CREATE_OBJECT = 0; <br> <br>#ifdef __ATLCOM_H__ <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// AtlReportError <br> <br>HRESULT WINAPI AtlReportError(const CLSID&amp; clsid, UINT nID, const IID&amp; iid, <br>HRESULT hRes, HINSTANCE hInst) <br>{ <br>return AtlSetErrorInfo(clsid, (LPCOLESTR)MAKEINTRESOURCE(nID), 0, NULL, iid, hRes, hInst); <br>} <br> <br>HRESULT WINAPI AtlReportError(const CLSID&amp; clsid, UINT nID, DWORD dwHelpID, <br>LPCOLESTR lpszHelpFile, const IID&amp; iid, HRESULT hRes, HINSTANCE hInst) <br>{ <br>return AtlSetErrorInfo(clsid, (LPCOLESTR)MAKEINTRESOURCE(nID), dwHelpID, <br>lpszHelpFile, iid, hRes, hInst); <br>} <br> <br>#ifndef OLE2ANSI <br>HRESULT WINAPI AtlReportError(const CLSID&amp; clsid, LPCSTR lpszDesc, <br>DWORD dwHelpID, LPCSTR lpszHelpFile, const IID&amp; iid, HRESULT hRes) <br>{ <br>_ASSERTE(lpszDesc != NULL); <br>USES_CONVERSION; <br>return AtlSetErrorInfo(clsid, A2COLE(lpszDesc), dwHelpID, A2CW(lpszHelpFile), <br>iid, hRes, NULL); <br>} <br> <br>HRESULT WINAPI AtlReportError(const CLSID&amp; clsid, LPCSTR lpszDesc, <br>const IID&amp; iid, HRESULT hRes) <br>{ <br>_ASSERTE(lpszDesc != NULL); <br>USES_CONVERSION; <br>return AtlSetErrorInfo(clsid, A2COLE(lpszDesc), 0, NULL, iid, hRes, NULL); <br>} <br>#endif <br> <br>HRESULT WINAPI AtlReportError(const CLSID&amp; clsid, LPCOLESTR lpszDesc, <br>const IID&amp; iid, HRESULT hRes) <br>{ <br>return AtlSetErrorInfo(clsid, lpszDesc, 0, NULL, iid, hRes, NULL); <br>} <br> <br>HRESULT WINAPI AtlReportError(const CLSID&amp; clsid, LPCOLESTR lpszDesc, DWORD dwHelpID, <br>LPCOLESTR lpszHelpFile, const IID&amp; iid, HRESULT hRes) <br>{ <br>return AtlSetErrorInfo(clsid, lpszDesc, dwHelpID, lpszHelpFile, iid, hRes, NULL); <br>} <br> <br>#endif //__ATLCOM_H__ <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// CComBSTR <br> <br>CComBSTR&amp; CComBSTR::operator=(const CComBSTR&amp; src) <br>{ <br>if (m_str != src.m_str) <br>{ <br>if (m_str) <br>::SysFreeString(m_str); <br>m_str = src.Copy(); <br>} <br>return *this; <br>} <br> <br>CComBSTR&amp; CComBSTR::operator=(LPCOLESTR pSrc) <br>{ <br>::SysFreeString(m_str); <br>m_str = ::SysAllocString(pSrc); <br>return *this; <br>} <br> <br>void CComBSTR::Append(LPCOLESTR lpsz, int nLen) <br>{ <br>int n1 = Length(); <br>BSTR b = SysAllocStringLen(NULL, n1+nLen); <br>memcpy(b, m_str, n1*sizeof(OLECHAR)); <br>memcpy(b+n1, lpsz, nLen*sizeof(OLECHAR)); <br>b[n1+nLen] = NULL; <br>SysFreeString(m_str); <br>m_str = b; <br>} <br> <br>#ifndef OLE2ANSI <br>void CComBSTR::Append(LPCSTR lpsz) <br>{ <br>USES_CONVERSION; <br>LPCOLESTR lpo = A2COLE(lpsz); <br>Append(lpo, ocslen(lpo)); <br>} <br> <br>CComBSTR::CComBSTR(LPCSTR pSrc) <br>{ <br>USES_CONVERSION; <br>m_str = ::SysAllocString(A2COLE(pSrc)); <br>} <br> <br>CComBSTR::CComBSTR(int nSize, LPCSTR sz) <br>{ <br>USES_CONVERSION; <br>m_str = ::SysAllocStringLen(A2COLE(sz), nSize); <br>} <br> <br>CComBSTR&amp; CComBSTR::operator=(LPCSTR pSrc) <br>{ <br>USES_CONVERSION; <br>::SysFreeString(m_str); <br>m_str = ::SysAllocString(A2COLE(pSrc)); <br>return *this; <br>} <br>#endif <br> <br>HRESULT CComBSTR::ReadFromStream(IStream* pStream) <br>{ <br>_ASSERTE(pStream != NULL); <br>_ASSERTE(m_str == NULL); // should be empty <br>ULONG cb; <br>ULONG cbStrLen; <br>HRESULT hr = pStream-&gt;Read((void*) &amp;cbStrLen, sizeof(cbStrLen), &amp;cb); <br>if (FAILED(hr)) <br>return hr; <br>if (cbStrLen != 0) <br>{ <br>//subtract size for terminating NULL which we wrote out <br>//since SysAllocStringByteLen overallocates for the NULL <br>m_str = SysAllocStringByteLen(NULL, cbStrLen-sizeof(OLECHAR)); <br>if (m_str == NULL) <br>hr = E_OUTOFMEMORY; <br>else <br>hr = pStream-&gt;Read((void*) m_str, cbStrLen, &amp;cb); <br>} <br>return hr; <br>} <br> <br>HRESULT CComBSTR::WriteToStream(IStream* pStream) <br>{ <br>_ASSERTE(pStream != NULL); <br>ULONG cb; <br>ULONG cbStrLen = m_str ? SysStringByteLen(m_str)+sizeof(OLECHAR) : 0; <br>HRESULT hr = pStream-&gt;Write((void*) &amp;cbStrLen, sizeof(cbStrLen), &amp;cb); <br>if (FAILED(hr)) <br>return hr; <br>return cbStrLen ? pStream-&gt;Write((void*) m_str, cbStrLen, &amp;cb) : S_OK; <br>} <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// CComVariant <br> <br>CComVariant&amp; CComVariant::operator=(BSTR bstrSrc) <br>{ <br>InternalClear(); <br>vt = VT_BSTR; <br>bstrVal = ::SysAllocString(bstrSrc); <br>if (bstrVal == NULL &amp;&amp; bstrSrc != NULL) <br>{ <br>vt = VT_ERROR; <br>scode = E_OUTOFMEMORY; <br>} <br>return *this; <br>} <br> <br>CComVariant&amp; CComVariant::operator=(LPCOLESTR lpszSrc) <br>{ <br>InternalClear(); <br>vt = VT_BSTR; <br>bstrVal = ::SysAllocString(lpszSrc); <br> <br>if (bstrVal == NULL &amp;&amp; lpszSrc != NULL) <br>{ <br>vt = VT_ERROR; <br>scode = E_OUTOFMEMORY; <br>} <br>return *this; <br>} <br> <br>#ifndef OLE2ANSI <br>CComVariant&amp; CComVariant::operator=(LPCSTR lpszSrc) <br>{ <br>USES_CONVERSION; <br>InternalClear(); <br>vt = VT_BSTR; <br>bstrVal = ::SysAllocString(A2COLE(lpszSrc)); <br> <br>if (bstrVal == NULL &amp;&amp; lpszSrc != NULL) <br>{ <br>vt = VT_ERROR; <br>scode = E_OUTOFMEMORY; <br>} <br>return *this; <br>} <br>#endif <br> <br>#if _MSC_VER&gt;1020 <br>CComVariant&amp; CComVariant::operator=(bool bSrc) <br>{ <br>if (vt != VT_BOOL) <br>{ <br>InternalClear(); <br>vt = VT_BOOL; <br>} <br>#pragma warning(disable: 4310) // cast truncates constant value <br>boolVal = bSrc ? VARIANT_TRUE : VARIANT_FALSE; <br>#pragma warning(default: 4310) // cast truncates constant value <br>return *this; <br>} <br>#endif <br> <br>CComVariant&amp; CComVariant::operator=(int nSrc) <br>{ <br>if (vt != VT_I4) <br>{ <br>InternalClear(); <br>vt = VT_I4; <br>} <br>lVal = nSrc; <br> <br>return *this; <br>} <br> <br>CComVariant&amp; CComVariant::operator=(BYTE nSrc) <br>{ <br>if (vt != VT_UI1) <br>{ <br>InternalClear(); <br>vt = VT_UI1; <br>} <br>bVal = nSrc; <br>return *this; <br>} <br> <br>CComVariant&amp; CComVariant::operator=(short nSrc) <br>{ <br>if (vt != VT_I2) <br>{ <br>InternalClear(); <br>vt = VT_I2; <br>} <br>iVal = nSrc; <br>return *this; <br>} <br> <br>CComVariant&amp; CComVariant::operator=(long nSrc) <br>{ <br>if (vt != VT_I4) <br>{ <br>InternalClear(); <br>vt = VT_I4; <br>} <br>lVal = nSrc; <br>return *this; <br>} <br> <br>CComVariant&amp; CComVariant::operator=(float fltSrc) <br>{ <br>if (vt != VT_R4) <br>{ <br>InternalClear(); <br>vt = VT_R4; <br>} <br>fltVal = fltSrc; <br>return *this; <br>} <br> <br>CComVariant&amp; CComVariant::operator=(double dblSrc) <br>{ <br>if (vt != VT_R8) <br>{ <br>InternalClear(); <br>vt = VT_R8; <br>} <br>dblVal = dblSrc; <br>return *this; <br>} <br> <br>CComVariant&amp; CComVariant::operator=(CY cySrc) <br>{ <br>if (vt != VT_CY) <br>{ <br>InternalClear(); <br>vt = VT_CY; <br>} <br>cyVal.Hi = cySrc.Hi; <br>cyVal.Lo = cySrc.Lo; <br>return *this; <br>} <br> <br>CComVariant&amp; CComVariant::operator=(IDispatch* pSrc) <br>{ <br>InternalClear(); <br>vt = VT_DISPATCH; <br>pdispVal = pSrc; <br>// Need to AddRef as VariantClear will Release <br>if (pdispVal != NULL) <br>pdispVal-&gt;AddRef(); <br>return *this; <br>} <br> <br>CComVariant&amp; CComVariant::operator=(IUnknown* pSrc) <br>{ <br>InternalClear(); <br>vt = VT_UNKNOWN; <br>punkVal = pSrc; <br> <br>// Need to AddRef as VariantClear will Release <br>if (punkVal != NULL) <br>punkVal-&gt;AddRef(); <br>return *this; <br>} <br> <br>#if _MSC_VER&gt;1020 <br>bool CComVariant::operator==(const VARIANT&amp; varSrc) <br>{ <br>if (this == &amp;varSrc) <br>return true; <br> <br>// Variants not equal if types don't match <br>if (vt != varSrc.vt) <br>return false; <br> <br>// Check type specific values <br>switch (vt) <br>{ <br>case VT_EMPTY: <br>case VT_NULL: <br>return true; <br> <br>case VT_BOOL: <br>return boolVal == varSrc.boolVal; <br> <br>case VT_UI1: <br>return bVal == varSrc.bVal; <br> <br>case VT_I2: <br>return iVal == varSrc.iVal; <br> <br>case VT_I4: <br>return lVal == varSrc.lVal; <br> <br>case VT_R4: <br>return fltVal == varSrc.fltVal; <br> <br>case VT_R8: <br>return dblVal == varSrc.dblVal; <br> <br>case VT_BSTR: <br>return (::SysStringByteLen(bstrVal) == ::SysStringByteLen(varSrc.bstrVal)) &amp;&amp; <br>(::memcmp(bstrVal, varSrc.bstrVal, ::SysStringByteLen(bstrVal)) == 0); <br> <br>case VT_ERROR: <br>return scode == varSrc.scode; <br> <br>case VT_DISPATCH: <br>return pdispVal == varSrc.pdispVal; <br> <br>case VT_UNKNOWN: <br>return punkVal == varSrc.punkVal; <br> <br>default: <br>_ASSERTE(false); <br>// fall through <br>} <br> <br>return false; <br>} <br>#else <br>BOOL CComVariant::operator==(const VARIANT&amp; varSrc) <br>{ <br>if (this == &amp;varSrc) <br>return TRUE; <br> <br>// Variants not equal if types don't match <br>if (vt != varSrc.vt) <br>return FALSE; <br> <br>// Check type specific values <br>switch (vt) <br>{ <br>case VT_EMPTY: <br>case VT_NULL: <br>return TRUE; <br> <br>case VT_BOOL: <br>return boolVal == varSrc.boolVal; <br> <br>case VT_UI1: <br>return bVal == varSrc.bVal; <br> <br>case VT_I2: <br>return iVal == varSrc.iVal; <br> <br>case VT_I4: <br>return lVal == varSrc.lVal; <br> <br>case VT_R4: <br>return fltVal == varSrc.fltVal; <br> <br>case VT_R8: <br>return dblVal == varSrc.dblVal; <br> <br>case VT_BSTR: <br>return (::SysStringByteLen(bstrVal) == ::SysStringByteLen(varSrc.bstrVal)) &amp;&amp; <br>(::memcmp(bstrVal, varSrc.bstrVal, ::SysStringByteLen(bstrVal)) == 0); <br> <br>case VT_ERROR: <br>return scode == varSrc.scode; <br> <br>case VT_DISPATCH: <br>return pdispVal == varSrc.pdispVal; <br> <br>case VT_UNKNOWN: <br>return punkVal == varSrc.punkVal; <br> <br>default: <br>_ASSERTE(FALSE); <br>// fall through <br>} <br> <br>return FALSE; <br>} <br>#endif <br> <br>HRESULT CComVariant::Attach(VARIANT* pSrc) <br>{ <br>// Clear out the variant <br>HRESULT hr = Clear(); <br>if (!FAILED(hr)) <br>{ <br>// Copy the contents and give control to CComVariant <br>memcpy(this, pSrc, sizeof(VARIANT)); <br>VariantInit(pSrc); <br>hr = S_OK; <br>} <br>return hr; <br>} <br> <br>HRESULT CComVariant::Detach(VARIANT* pDest) <br>{ <br>// Clear out the variant <br>HRESULT hr = ::VariantClear(pDest); <br>if (!FAILED(hr)) <br>{ <br>// Copy the contents and remove control from CComVariant <br>memcpy(pDest, this, sizeof(VARIANT)); <br>vt = VT_EMPTY; <br>hr = S_OK; <br>} <br>return hr; <br>} <br> <br>HRESULT CComVariant::ChangeType(VARTYPE vtNew, const VARIANT* pSrc) <br>{ <br>VARIANT* pVar = const_cast&lt;VARIANT*&gt;(pSrc); <br>// Convert in place if pSrc is NULL <br>if (pVar == NULL) <br>pVar = this; <br>// Do nothing if doing in place convert and vts not different <br>return ::VariantChangeType(this, pVar, 0, vtNew); <br>} <br> <br>HRESULT CComVariant::InternalClear() <br>{ <br>HRESULT hr = Clear(); <br>_ASSERTE(SUCCEEDED(hr)); <br>if (FAILED(hr)) <br>{ <br>vt = VT_ERROR; <br>scode = hr; <br>} <br>return hr; <br>} <br> <br>void CComVariant::InternalCopy(const VARIANT* pSrc) <br>{ <br>HRESULT hr = Copy(pSrc); <br>if (FAILED(hr)) <br>{ <br>vt = VT_ERROR; <br>scode = hr; <br>} <br>} <br> <br> <br>HRESULT CComVariant::WriteToStream(IStream* pStream) <br>{ <br>HRESULT hr = pStream-&gt;Write(&amp;vt, sizeof(VARTYPE), NULL); <br>if (FAILED(hr)) <br>return hr; <br> <br>int cbWrite = 0; <br>switch (vt) <br>{ <br>case VT_UNKNOWN: <br>case VT_DISPATCH: <br>{ <br>CComPtr&lt;IPersistStream&gt; spStream; <br>if (punkVal != NULL) <br>{ <br>hr = punkVal-&gt;QueryInterface(IID_IPersistStream, (void**)&amp;spStream); <br>if (FAILED(hr)) <br>return hr; <br>} <br>if (spStream != NULL) <br>return OleSaveToStream(spStream, pStream); <br>else <br>return WriteClassStm(pStream, CLSID_NULL); <br>} <br>case VT_UI1: <br>case VT_I1: <br>cbWrite = sizeof(BYTE); <br>break; <br>case VT_I2: <br>case VT_UI2: <br>case VT_BOOL: <br>cbWrite = sizeof(short); <br>break; <br>case VT_I4: <br>case VT_UI4: <br>case VT_R4: <br>case VT_INT: <br>case VT_UINT: <br>case VT_ERROR: <br>cbWrite = sizeof(long); <br>break; <br>case VT_R8: <br>case VT_CY: <br>case VT_DATE: <br>cbWrite = sizeof(double); <br>break; <br>default: <br>break; <br>} <br>if (cbWrite != 0) <br>return pStream-&gt;Write((void*) &amp;bVal, cbWrite, NULL); <br> <br>CComBSTR bstrWrite; <br>CComVariant varBSTR; <br>if (vt != VT_BSTR) <br>{ <br>hr = VariantChangeType(&amp;varBSTR, this, VARIANT_NOVALUEPROP, VT_BSTR); <br>if (FAILED(hr)) <br>return hr; <br>bstrWrite = varBSTR.bstrVal; <br>} <br>else <br>bstrWrite = bstrVal; <br> <br>return bstrWrite.WriteToStream(pStream); <br>} <br> <br>HRESULT CComVariant::ReadFromStream(IStream* pStream) <br>{ <br>_ASSERTE(pStream != NULL); <br>HRESULT hr; <br>hr = VariantClear(this); <br>if (FAILED(hr)) <br>return hr; <br>VARTYPE vtRead; <br>hr = pStream-&gt;Read(&amp;vtRead, sizeof(VARTYPE), NULL); <br>if (FAILED(hr)) <br>return hr; <br> <br>vt = vtRead; <br>int cbRead = 0; <br>switch (vtRead) <br>{ <br>case VT_UNKNOWN: <br>case VT_DISPATCH: <br>{ <br>punkVal = NULL; <br>hr = OleLoadFromStream(pStream,  <br>(vtRead == VT_UNKNOWN) ? IID_IUnknown : IID_IDispatch,  <br>(void**)&amp;punkVal); <br>if (hr == REGDB_E_CLASSNOTREG) <br>hr = S_OK; <br>return S_OK; <br>} <br>case VT_UI1: <br>case VT_I1: <br>cbRead = sizeof(BYTE); <br>break; <br>case VT_I2: <br>case VT_UI2: <br>case VT_BOOL: <br>cbRead = sizeof(short); <br>break; <br>case VT_I4: <br>case VT_UI4: <br>case VT_R4: <br>case VT_INT: <br>case VT_UINT: <br>case VT_ERROR: <br>cbRead = sizeof(long); <br>break; <br>case VT_R8: <br>case VT_CY: <br>case VT_DATE: <br>cbRead = sizeof(double); <br>break; <br>default: <br>break; <br>} <br>if (cbRead != 0) <br>return pStream-&gt;Read((void*) &amp;bVal, cbRead, NULL); <br>CComBSTR bstrRead; <br> <br>hr = bstrRead.ReadFromStream(pStream); <br>if (FAILED(hr)) <br>return hr; <br>vt = VT_BSTR; <br>bstrVal = bstrRead.Detach(); <br>if (vtRead != VT_BSTR) <br>hr = ChangeType(vtRead); <br>return hr; <br>} <br> <br>#ifdef __ATLCOM_H__ <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// CComTypeInfoHolder <br> <br>void CComTypeInfoHolder::AddRef() <br>{ <br>EnterCriticalSection(&amp;_Module.m_csTypeInfoHolder); <br>m_dwRef++; <br>LeaveCriticalSection(&amp;_Module.m_csTypeInfoHolder); <br>} <br> <br>void CComTypeInfoHolder::Release() <br>{ <br>EnterCriticalSection(&amp;_Module.m_csTypeInfoHolder); <br>if (--m_dwRef == 0) <br>{ <br>if (m_pInfo != NULL) <br>m_pInfo-&gt;Release(); <br>m_pInfo = NULL; <br>} <br>LeaveCriticalSection(&amp;_Module.m_csTypeInfoHolder); <br>} <br> <br>HRESULT CComTypeInfoHolder::GetTI(LCID lcid, ITypeInfo** ppInfo) <br>{ <br>//If this assert occurs then most likely didn't initialize properly <br>_ASSERTE(m_plibid != NULL &amp;&amp; m_pguid != NULL); <br>_ASSERTE(ppInfo != NULL); <br>*ppInfo = NULL; <br> <br>HRESULT hRes = E_FAIL; <br>EnterCriticalSection(&amp;_Module.m_csTypeInfoHolder); <br>if (m_pInfo == NULL) <br>{ <br>ITypeLib* pTypeLib; <br>hRes = LoadRegTypeLib(*m_plibid, m_wMajor, m_wMinor, lcid, &amp;pTypeLib); <br>if (SUCCEEDED(hRes)) <br>{ <br>ITypeInfo* pTypeInfo; <br>hRes = pTypeLib-&gt;GetTypeInfoOfGuid(*m_pguid, &amp;pTypeInfo); <br>if (SUCCEEDED(hRes)) <br>m_pInfo = pTypeInfo; <br>pTypeLib-&gt;Release(); <br>} <br>} <br>*ppInfo = m_pInfo; <br>if (m_pInfo != NULL) <br>{ <br>m_pInfo-&gt;AddRef(); <br>hRes = S_OK; <br>} <br>LeaveCriticalSection(&amp;_Module.m_csTypeInfoHolder); <br>return hRes; <br>} <br> <br>HRESULT CComTypeInfoHolder::GetTypeInfo(UINT /*itinfo*/, LCID lcid, <br>ITypeInfo** pptinfo) <br>{ <br>HRESULT hRes = E_POINTER; <br>if (pptinfo != NULL) <br>hRes = GetTI(lcid, pptinfo); <br>return hRes; <br>} <br> <br>HRESULT CComTypeInfoHolder::GetIDsOfNames(REFIID /*riid*/, LPOLESTR* rgszNames, <br>UINT cNames, LCID lcid, DISPID* rgdispid) <br>{ <br>ITypeInfo* pInfo; <br>HRESULT hRes = GetTI(lcid, &amp;pInfo); <br>if (pInfo != NULL) <br>{ <br>hRes = pInfo-&gt;GetIDsOfNames(rgszNames, cNames, rgdispid); <br>pInfo-&gt;Release(); <br>} <br>return hRes; <br>} <br> <br>HRESULT CComTypeInfoHolder::Invoke(IDispatch* p, DISPID dispidMember, REFIID /*riid*/, <br>LCID lcid, WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult, <br>EXCEPINFO* pexcepinfo, UINT* puArgErr) <br>{ <br>SetErrorInfo(0, NULL); <br>ITypeInfo* pInfo; <br>HRESULT hRes = GetTI(lcid, &amp;pInfo); <br>if (pInfo != NULL) <br>{ <br>hRes = pInfo-&gt;Invoke(p, dispidMember, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr); <br>pInfo-&gt;Release(); <br>} <br>return hRes; <br>} <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// QI implementation <br> <br>#ifdef _ATL_DEBUG_QI <br>HRESULT WINAPI AtlDumpIID(REFIID iid, LPCTSTR pszClassName, HRESULT hr) <br>{ <br>USES_CONVERSION; <br>CRegKey key; <br>TCHAR szName[100]; <br>DWORD dwType,dw = sizeof(szName); <br> <br>LPOLESTR pszGUID = NULL; <br>StringFromCLSID(iid, &amp;pszGUID); <br>OutputDebugString(pszClassName); <br>OutputDebugString(_T(" - ")); <br> <br>// Attempt to find it in the interfaces section <br>key.Open(HKEY_CLASSES_ROOT, _T("Interface")); <br>if (key.Open(key, OLE2T(pszGUID)) == S_OK) <br>{ <br>*szName = 0; <br>RegQueryValueEx(key.m_hKey, (LPTSTR)NULL, NULL, &amp;dwType, (LPBYTE)szName, &amp;dw); <br>OutputDebugString(szName); <br>goto cleanup; <br>} <br>// Attempt to find it in the clsid section <br>key.Open(HKEY_CLASSES_ROOT, _T("CLSID")); <br>if (key.Open(key, OLE2T(pszGUID)) == S_OK) <br>{ <br>*szName = 0; <br>RegQueryValueEx(key.m_hKey, (LPTSTR)NULL, NULL, &amp;dwType, (LPBYTE)szName, &amp;dw); <br>OutputDebugString(_T("(CLSID\?\?\?) ")); <br>OutputDebugString(szName); <br>goto cleanup; <br>} <br>OutputDebugString(OLE2T(pszGUID)); <br>cleanup: <br>if (hr != S_OK) <br>OutputDebugString(_T(" - failed")); <br>OutputDebugString(_T("\n")); <br>CoTaskMemFree(pszGUID); <br>return hr; <br>} <br>#endif <br> <br>HRESULT WINAPI CComObjectRootBase::_Break(void* /* pv */, REFIID iid, void** /* ppvObject */, DWORD /* dw */) <br>{ <br>iid; <br>_ATLDUMPIID(iid, _T("Break due to QI for interface "), S_OK); <br>DebugBreak(); <br>return S_FALSE; <br>} <br> <br>HRESULT WINAPI CComObjectRootBase::_NoInterface(void* /* pv */, REFIID /* iid */, void** /* ppvObject */, DWORD /* dw */) <br>{ <br>return E_NOINTERFACE; <br>} <br> <br>HRESULT WINAPI CComObjectRootBase::_Creator(void* pv, REFIID iid, void** ppvObject, DWORD dw) <br>{ <br>_ATL_CREATORDATA* pcd = (_ATL_CREATORDATA*)dw; <br>return pcd-&gt;pFunc(pv, iid, ppvObject); <br>} <br> <br>HRESULT WINAPI CComObjectRootBase::_Delegate(void* pv, REFIID iid, void** ppvObject, DWORD dw) <br>{ <br>HRESULT hRes = E_NOINTERFACE; <br>IUnknown* p = *(IUnknown**)((DWORD)pv + dw); <br>if (p != NULL) <br>hRes = p-&gt;QueryInterface(iid, ppvObject); <br>return hRes; <br>} <br> <br>HRESULT WINAPI CComObjectRootBase::_Chain(void* pv, REFIID iid, void** ppvObject, DWORD dw) <br>{ <br>_ATL_CHAINDATA* pcd = (_ATL_CHAINDATA*)dw; <br>void* p = (void*)((DWORD)pv + pcd-&gt;dwOffset); <br>return InternalQueryInterface(p, pcd-&gt;pFunc(), iid, ppvObject); <br>} <br> <br>HRESULT WINAPI CComObjectRootBase::_Cache(void* pv, REFIID iid, void** ppvObject, DWORD dw) <br>{ <br>HRESULT hRes = E_NOINTERFACE; <br>_ATL_CACHEDATA* pcd = (_ATL_CACHEDATA*)dw; <br>IUnknown** pp = (IUnknown**)((DWORD)pv + pcd-&gt;dwOffsetVar); <br>if (*pp == NULL) <br>hRes = pcd-&gt;pFunc(pv, IID_IUnknown, (void**)pp); <br>if (*pp != NULL) <br>hRes = (*pp)-&gt;QueryInterface(iid, ppvObject); <br>return hRes; <br>} <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// CComClassFactory <br> <br>STDMETHODIMP CComClassFactory::CreateInstance(LPUNKNOWN pUnkOuter, <br>REFIID riid, void** ppvObj) <br>{ <br>_ASSERTE(m_pfnCreateInstance != NULL); <br>HRESULT hRes = E_POINTER; <br>if (ppvObj != NULL) <br>{ <br>*ppvObj = NULL; <br>// can't ask for anything other than IUnknown when aggregating <br>_ASSERTE((pUnkOuter == NULL) || InlineIsEqualUnknown(riid)); <br>if ((pUnkOuter != NULL) &amp;&amp; !InlineIsEqualUnknown(riid)) <br>hRes = CLASS_E_NOAGGREGATION; <br>else <br>hRes = m_pfnCreateInstance(pUnkOuter, riid, ppvObj); <br>} <br>return hRes; <br>} <br> <br>STDMETHODIMP CComClassFactory::LockServer(BOOL fLock) <br>{ <br>if (fLock) <br>_Module.Lock(); <br>else <br>_Module.Unlock(); <br>return S_OK; <br>} <br> <br>STDMETHODIMP CComClassFactory2Base::LockServer(BOOL fLock) <br>{ <br>if (fLock) <br>_Module.Lock(); <br>else <br>_Module.Unlock(); <br>return S_OK; <br>} <br> <br>#ifndef _ATL_NO_CONNECTION_POINTS <br>///////////////////////////////////////////////////////////////////////////// <br>// Connection Points <br> <br>DWORD CComDynamicUnkArray::Add(IUnknown* pUnk) <br>{ <br>IUnknown** pp = NULL; <br>if (m_nSize == 0) // no connections <br>{ <br>m_pUnk = pUnk; <br>m_nSize = 1; <br>return (DWORD)m_pUnk; <br>} <br>else if (m_nSize == 1) <br>{ <br>//create array <br>pp = (IUnknown**)malloc(sizeof(IUnknown*)*_DEFAULT_VECTORLENGTH); <br>if (pp == NULL) <br>return 0; <br>memset(pp, 0, sizeof(IUnknown*)*_DEFAULT_VECTORLENGTH); <br>*pp = m_pUnk; <br>m_ppUnk = pp; <br>m_nSize = _DEFAULT_VECTORLENGTH; <br>} <br>for (pp = begin();pp&lt;end();pp++) <br>{ <br>if (*pp == NULL) <br>{ <br>*pp = pUnk; <br>return (DWORD)pUnk; <br>} <br>} <br>int nAlloc = m_nSize*2; <br>pp = (IUnknown**)realloc(m_ppUnk, sizeof(IUnknown*)*nAlloc); <br>if (pp == NULL) <br>return 0; <br>m_ppUnk = pp; <br>memset(&amp;m_ppUnk[m_nSize], 0, sizeof(IUnknown*)*m_nSize); <br>m_ppUnk[m_nSize] = pUnk; <br>m_nSize = nAlloc; <br>return (DWORD)pUnk; <br>} <br> <br>BOOL CComDynamicUnkArray::Remove(DWORD dwCookie) <br>{ <br>IUnknown** pp; <br>if (dwCookie == NULL) <br>return FALSE; <br>if (m_nSize == 0) <br>return FALSE; <br>if (m_nSize == 1) <br>{ <br>if ((DWORD)m_pUnk == dwCookie) <br>{ <br>m_nSize = 0; <br>return TRUE; <br>} <br>return FALSE; <br>} <br>for (pp=begin();pp&lt;end();pp++) <br>{ <br>if ((DWORD)*pp == dwCookie) <br>{ <br>*pp = NULL; <br>return TRUE; <br>} <br>} <br>return FALSE; <br>} <br> <br>#endif //!_ATL_NO_CONNECTION_POINTS <br> <br>#endif //__ATLCOM_H__ <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// Object Registry Support <br> <br>static HRESULT WINAPI AtlRegisterProgID(LPCTSTR lpszCLSID, LPCTSTR lpszProgID, LPCTSTR lpszUserDesc) <br>{ <br>CRegKey keyProgID; <br>LONG lRes = keyProgID.Create(HKEY_CLASSES_ROOT, lpszProgID); <br>if (lRes == ERROR_SUCCESS) <br>{ <br>keyProgID.SetValue(lpszUserDesc); <br>keyProgID.SetKeyValue(_T("CLSID"), lpszCLSID); <br>return S_OK; <br>} <br>return HRESULT_FROM_WIN32(lRes); <br>} <br> <br>void CComModule::AddCreateWndData(_AtlCreateWndData* pData, void* pObject) <br>{ <br>pData-&gt;m_pThis = pObject; <br>pData-&gt;m_dwThreadID = ::GetCurrentThreadId(); <br>::EnterCriticalSection(&amp;m_csWindowCreate); <br>pData-&gt;m_pNext = m_pCreateWndList; <br>m_pCreateWndList = pData; <br>::LeaveCriticalSection(&amp;m_csWindowCreate); <br>} <br> <br>void* CComModule::ExtractCreateWndData() <br>{ <br>::EnterCriticalSection(&amp;m_csWindowCreate); <br>_AtlCreateWndData* pEntry = m_pCreateWndList; <br>if(pEntry == NULL) <br>{ <br>::LeaveCriticalSection(&amp;m_csWindowCreate); <br>return NULL; <br>} <br> <br>DWORD dwThreadID = ::GetCurrentThreadId(); <br>_AtlCreateWndData* pPrev = NULL; <br>while(pEntry != NULL) <br>{ <br>if(pEntry-&gt;m_dwThreadID == dwThreadID) <br>{ <br>if(pPrev == NULL) <br>m_pCreateWndList = pEntry-&gt;m_pNext; <br>else <br>pPrev-&gt;m_pNext = pEntry-&gt;m_pNext; <br>::LeaveCriticalSection(&amp;m_csWindowCreate); <br>return pEntry-&gt;m_pThis; <br>} <br>pPrev = pEntry; <br>pEntry = pEntry-&gt;m_pNext; <br>} <br> <br>::LeaveCriticalSection(&amp;m_csWindowCreate); <br>return NULL; <br>} <br> <br>#ifdef _ATL_STATIC_REGISTRY <br>// Statically linking to Registry Ponent <br>HRESULT WINAPI CComModule::UpdateRegistryFromResourceS(UINT nResID, BOOL bRegister, <br>struct _ATL_REGMAP_ENTRY* pMapEntries) <br>{ <br>USES_CONVERSION; <br>CRegObject ro; <br>TCHAR szModule[_MAX_PATH]; <br>GetModuleFileName(_Module.GetModuleInstance(), szModule, _MAX_PATH); <br>LPOLESTR pszModule = T2OLE(szModule); <br>ro.AddReplacement(OLESTR("Module"), pszModule); <br>if (NULL != pMapEntries) <br>{ <br>while (NULL != pMapEntries-&gt;szKey) <br>{ <br>_ASSERTE(NULL != pMapEntries-&gt;szData); <br>ro.AddReplacement(pMapEntries-&gt;szKey, pMapEntries-&gt;szData); <br>pMapEntries++; <br>} <br>} <br> <br>LPCOLESTR szType = OLESTR("REGISTRY"); <br>return (bRegister) ? ro.ResourceRegister(pszModule, nResID, szType) : <br>ro.ResourceUnregister(pszModule, nResID, szType); <br>} <br> <br>HRESULT WINAPI CComModule::UpdateRegistryFromResourceS(LPCTSTR lpszRes, BOOL bRegister, <br>struct _ATL_REGMAP_ENTRY* pMapEntries) <br>{ <br>USES_CONVERSION; <br>CRegObject ro; <br>TCHAR szModule[_MAX_PATH]; <br>GetModuleFileName(_Module.GetModuleInstance(), szModule, _MAX_PATH); <br>LPOLESTR pszModule = T2OLE(szModule); <br>ro.AddReplacement(OLESTR("Module"), pszModule); <br>if (NULL != pMapEntries) <br>{ <br>while (NULL != pMapEntries-&gt;szKey) <br>{ <br>_ASSERTE(NULL != pMapEntries-&gt;szData); <br>ro.AddReplacement(pMapEntries-&gt;szKey, pMapEntries-&gt;szData); <br>pMapEntries++; <br>} <br>} <br> <br>LPCOLESTR szType = OLESTR("REGISTRY"); <br>LPCOLESTR pszRes = T2COLE(lpszRes); <br>return (bRegister) ? ro.ResourceRegisterSz(pszModule, pszRes, szType) : <br>ro.ResourceUnregisterSz(pszModule, pszRes, szType); <br>} <br>#endif // _ATL_STATIC_REGISTRY <br> <br>HRESULT WINAPI CComModule::UpdateRegistryClass(const CLSID&amp; clsid, LPCTSTR lpszProgID, <br>LPCTSTR lpszVerIndProgID, UINT nDescID, DWORD dwFlags, BOOL bRegister) <br>{ <br>if (bRegister) <br>{ <br>return RegisterClassHelper(clsid, lpszProgID, lpszVerIndProgID, nDescID, <br>dwFlags); <br>} <br>else <br>return UnregisterClassHelper(clsid, lpszProgID, lpszVerIndProgID); <br>} <br> <br>HRESULT WINAPI CComModule::RegisterClassHelper(const CLSID&amp; clsid, LPCTSTR lpszProgID, <br>LPCTSTR lpszVerIndProgID, UINT nDescID, DWORD dwFlags) <br>{ <br>static const TCHAR szProgID[] = _T("ProgID"); <br>static const TCHAR szVIProgID[] = _T("VersionIndependentProgID"); <br>static const TCHAR szLS32[] = _T("LocalServer32"); <br>static const TCHAR szIPS32[] = _T("InprocServer32"); <br>static const TCHAR szThreadingModel[] = _T("ThreadingModel"); <br>static const TCHAR szAUTPRX32[] = _T("AUTPRX32.DLL"); <br>static const TCHAR szApartment[] = _T("Apartment"); <br>static const TCHAR szBoth[] = _T("both"); <br>USES_CONVERSION; <br>HRESULT hRes = S_OK; <br>TCHAR szDesc[256]; <br>LoadString(m_hInst, nDescID, szDesc, 256); <br>TCHAR szModule[_MAX_PATH]; <br>GetModuleFileName(m_hInst, szModule, _MAX_PATH); <br> <br>LPOLESTR lpOleStr; <br>StringFromCLSID(clsid, &amp;lpOleStr); <br>LPTSTR lpsz = OLE2T(lpOleStr); <br> <br>hRes = AtlRegisterProgID(lpsz, lpszProgID, szDesc); <br>if (hRes == S_OK) <br>hRes = AtlRegisterProgID(lpsz, lpszVerIndProgID, szDesc); <br>LONG lRes = ERROR_SUCCESS; <br>if (hRes == S_OK) <br>{ <br>CRegKey key; <br>LONG lRes = key.Open(HKEY_CLASSES_ROOT, _T("CLSID")); <br>if (lRes == ERROR_SUCCESS) <br>{ <br>lRes = key.Create(key, lpsz); <br>if (lRes == ERROR_SUCCESS) <br>{ <br>key.SetValue(szDesc); <br>key.SetKeyValue(szProgID, lpszProgID); <br>key.SetKeyValue(szVIProgID, lpszVerIndProgID); <br> <br>if ((m_hInst == NULL) || (m_hInst == GetModuleHandle(NULL))) // register as EXE <br>key.SetKeyValue(szLS32, szModule); <br>else <br>{ <br>key.SetKeyValue(szIPS32, (dwFlags &amp; AUTPRXFLAG) ? szAUTPRX32 : szModule); <br>LPCTSTR lpszModel = (dwFlags &amp; THREADFLAGS_BOTH) ? szBoth : <br>(dwFlags &amp; THREADFLAGS_APARTMENT) ? szApartment : NULL; <br>if (lpszModel != NULL) <br>key.SetKeyValue(szIPS32, lpszModel, szThreadingModel); <br>} <br>} <br>} <br>} <br>CoTaskMemFree(lpOleStr); <br>if (lRes != ERROR_SUCCESS) <br>hRes = HRESULT_FROM_WIN32(lRes); <br>return hRes; <br>} <br> <br>HRESULT WINAPI CComModule::UnregisterClassHelper(const CLSID&amp; clsid, LPCTSTR lpszProgID, <br>LPCTSTR lpszVerIndProgID) <br>{ <br>USES_CONVERSION; <br>CRegKey key; <br> <br>key.Attach(HKEY_CLASSES_ROOT); <br>if (lpszProgID != NULL &amp;&amp; lstrcmpi(lpszProgID, _T(""))) <br>key.RecurseDeleteKey(lpszProgID); <br>if (lpszVerIndProgID != NULL &amp;&amp; lstrcmpi(lpszVerIndProgID, _T(""))) <br>key.RecurseDeleteKey(lpszVerIndProgID); <br>LPOLESTR lpOleStr; <br>StringFromCLSID(clsid, &amp;lpOleStr); <br>LPTSTR lpsz = OLE2T(lpOleStr); <br>if (key.Open(key, _T("CLSID")) == ERROR_SUCCESS) <br>key.RecurseDeleteKey(lpsz); <br>CoTaskMemFree(lpOleStr); <br>return S_OK; <br>} <br> <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// CRegKey <br> <br>LONG CRegKey::Close() <br>{ <br>LONG lRes = ERROR_SUCCESS; <br>if (m_hKey != NULL) <br>{ <br>lRes = RegCloseKey(m_hKey); <br>m_hKey = NULL; <br>} <br>return lRes; <br>} <br> <br>LONG CRegKey::Create(HKEY hKeyParent, LPCTSTR lpszKeyName, <br>LPTSTR lpszClass, DWORD dwOptions, REGSAM samDesired, <br>LPSECURITY_ATTRIBUTES lpSecAttr, LPDWORD lpdwDisposition) <br>{ <br>_ASSERTE(hKeyParent != NULL); <br>DWORD dw; <br>HKEY hKey = NULL; <br>LONG lRes = RegCreateKeyEx(hKeyParent, lpszKeyName, 0, <br>lpszClass, dwOptions, samDesired, lpSecAttr, &amp;hKey, &amp;dw); <br>if (lpdwDisposition != NULL) <br>*lpdwDisposition = dw; <br>if (lRes == ERROR_SUCCESS) <br>{ <br>lRes = Close(); <br>m_hKey = hKey; <br>} <br>return lRes; <br>} <br> <br>LONG CRegKey::Open(HKEY hKeyParent, LPCTSTR lpszKeyName, REGSAM samDesired) <br>{ <br>_ASSERTE(hKeyParent != NULL); <br>HKEY hKey = NULL; <br>LONG lRes = RegOpenKeyEx(hKeyParent, lpszKeyName, 0, samDesired, &amp;hKey); <br>if (lRes == ERROR_SUCCESS) <br>{ <br>lRes = Close(); <br>_ASSERTE(lRes == ERROR_SUCCESS); <br>m_hKey = hKey; <br>} <br>return lRes; <br>} <br> <br>LONG CRegKey::QueryValue(DWORD&amp; dwValue, LPCTSTR lpszValueName) <br>{ <br>DWORD dwType = NULL; <br>DWORD dwCount = sizeof(DWORD); <br>LONG lRes = RegQueryValueEx(m_hKey, (LPTSTR)lpszValueName, NULL, &amp;dwType, <br>(LPBYTE)&amp;dwValue, &amp;dwCount); <br>_ASSERTE((lRes!=ERROR_SUCCESS) || (dwType == REG_DWORD)); </code></pre>
<p>
</p>
<pre><code>_ASSERTE((lRes!=ERROR_SUCCESS) || (dwCount == sizeof(DWORD))); <br>return lRes; <br>} <br> <br>LONG CRegKey::QueryValue(LPTSTR szValue, LPCTSTR lpszValueName, DWORD* pdwCount) <br>{ <br>_ASSERTE(pdwCount != NULL); <br>DWORD dwType = NULL; <br>LONG lRes = RegQueryValueEx(m_hKey, (LPTSTR)lpszValueName, NULL, &amp;dwType, <br>(LPBYTE)szValue, pdwCount); <br>_ASSERTE((lRes!=ERROR_SUCCESS) || (dwType == REG_SZ) || <br> (dwType == REG_MULTI_SZ) || (dwType == REG_EXPAND_SZ)); <br>return lRes; <br>} <br> <br>LONG WINAPI CRegKey::SetValue(HKEY hKeyParent, LPCTSTR lpszKeyName, LPCTSTR lpszValue, LPCTSTR lpszValueName) <br>{ <br>_ASSERTE(lpszValue != NULL); <br>CRegKey key; <br>LONG lRes = key.Create(hKeyParent, lpszKeyName); <br>if (lRes == ERROR_SUCCESS) <br>lRes = key.SetValue(lpszValue, lpszValueName); <br>return lRes; <br>} <br> <br>LONG CRegKey::SetKeyValue(LPCTSTR lpszKeyName, LPCTSTR lpszValue, LPCTSTR lpszValueName) <br>{ <br>_ASSERTE(lpszValue != NULL); <br>CRegKey key; <br>LONG lRes = key.Create(m_hKey, lpszKeyName); <br>if (lRes == ERROR_SUCCESS) <br>lRes = key.SetValue(lpszValue, lpszValueName); <br>return lRes; <br>} <br> <br>LONG CRegKey::SetValue(DWORD dwValue, LPCTSTR lpszValueName) <br>{ <br>_ASSERTE(m_hKey != NULL); <br>return RegSetValueEx(m_hKey, lpszValueName, NULL, REG_DWORD, <br>(BYTE * const)&amp;dwValue, sizeof(DWORD)); <br>} <br> <br>HRESULT CRegKey::SetValue(LPCTSTR lpszValue, LPCTSTR lpszValueName) <br>{ <br>_ASSERTE(lpszValue != NULL); <br>_ASSERTE(m_hKey != NULL); <br>return RegSetValueEx(m_hKey, lpszValueName, NULL, REG_SZ, <br>(BYTE * const)lpszValue, (lstrlen(lpszValue)+1)*sizeof(TCHAR)); <br>} <br> <br>//RecurseDeleteKey is necessary because on NT RegDeleteKey doesn't work if the <br>//specified key has subkeys <br>LONG CRegKey::RecurseDeleteKey(LPCTSTR lpszKey) <br>{ <br>CRegKey key; <br>LONG lRes = key.Open(m_hKey, lpszKey); <br>if (lRes != ERROR_SUCCESS) <br>return lRes; <br>FILETIME time; <br>TCHAR szBuffer[256]; <br>DWORD dwSize = 256; <br>while (RegEnumKeyEx(key.m_hKey, 0, szBuffer, &amp;dwSize, NULL, NULL, NULL, <br>&amp;time)==ERROR_SUCCESS) <br>{ <br>lRes = key.RecurseDeleteKey(szBuffer); <br>if (lRes != ERROR_SUCCESS) <br>return lRes; <br>dwSize = 256; <br>} <br>key.Close(); <br>return DeleteSubKey(lpszKey); <br>} <br> <br>#ifdef __ATLCOM_H__ <br>#ifndef _ATL_NO_SECURITY <br> <br>CSecurityDescriptor::CSecurityDescriptor() <br>{ <br>m_pSD = NULL; <br>m_pOwner = NULL; <br>m_pGroup = NULL; <br>m_pDACL = NULL; <br>m_pSACL= NULL; <br>} <br> <br>CSecurityDescriptor::~CSecurityDescriptor() <br>{ <br>if (m_pSD) <br>delete m_pSD; <br>if (m_pOwner) <br>free(m_pOwner); <br>if (m_pGroup) <br>free(m_pGroup); <br>if (m_pDACL) <br>free(m_pDACL); <br>if (m_pSACL) <br>free(m_pSACL); <br>} <br> <br>HRESULT CSecurityDescriptor::Initialize() <br>{ <br>if (m_pSD) <br>{ <br>delete m_pSD; <br>m_pSD = NULL; <br>} <br>if (m_pOwner) <br>{ <br>free(m_pOwner); <br>m_pOwner = NULL; <br>} <br>if (m_pGroup) <br>{ <br>free(m_pGroup); <br>m_pGroup = NULL; <br>} <br>if (m_pDACL) <br>{ <br>free(m_pDACL); <br>m_pDACL = NULL; <br>} <br>if (m_pSACL) <br>{ <br>free(m_pSACL); <br>m_pSACL = NULL; <br>} <br> <br>ATLTRY(m_pSD = new SECURITY_DESCRIPTOR); <br>if (!m_pSD) <br>return E_OUTOFMEMORY; <br>if (!InitializeSecurityDescriptor(m_pSD, SECURITY_DESCRIPTOR_REVISION)) <br>{ <br>HRESULT hr = HRESULT_FROM_WIN32(GetLastError()); <br>delete m_pSD; <br>m_pSD = NULL; <br>_ASSERTE(FALSE); <br>return hr; <br>} <br>// Set the DACL to allow EVERYONE <br>SetSecurityDescriptorDacl(m_pSD, TRUE, NULL, FALSE); <br>return S_OK; <br>} <br> <br>HRESULT CSecurityDescriptor::InitializeFromProcessToken(BOOL bDefaulted) <br>{ <br>PSID pUserSid; <br>PSID pGroupSid; <br>HRESULT hr; <br> <br>Initialize(); <br>hr = GetProcessSids(&amp;pUserSid, &amp;pGroupSid); <br>if (FAILED(hr)) <br>return hr; <br>hr = SetOwner(pUserSid, bDefaulted); <br>if (FAILED(hr)) <br>return hr; <br>hr = SetGroup(pGroupSid, bDefaulted); <br>if (FAILED(hr)) <br>return hr; <br>return S_OK; <br>} <br> <br>HRESULT CSecurityDescriptor::InitializeFromThreadToken(BOOL bDefaulted, BOOL bRevertToProcessToken) <br>{ <br>PSID pUserSid; <br>PSID pGroupSid; <br>HRESULT hr; <br> <br>Initialize(); <br>hr = GetThreadSids(&amp;pUserSid, &amp;pGroupSid); <br>if (HRESULT_CODE(hr) == ERROR_NO_TOKEN &amp;&amp; bRevertToProcessToken) <br>hr = GetProcessSids(&amp;pUserSid, &amp;pGroupSid); <br>if (FAILED(hr)) <br>return hr; <br>hr = SetOwner(pUserSid, bDefaulted); <br>if (FAILED(hr)) <br>return hr; <br>hr = SetGroup(pGroupSid, bDefaulted); <br>if (FAILED(hr)) <br>return hr; <br>return S_OK; <br>} <br> <br>HRESULT CSecurityDescriptor::SetOwner(PSID pOwnerSid, BOOL bDefaulted) <br>{ <br>_ASSERTE(m_pSD); <br> <br>// Mark the SD as having no owner <br>if (!SetSecurityDescriptorOwner(m_pSD, NULL, bDefaulted)) <br>{ <br>HRESULT hr = HRESULT_FROM_WIN32(GetLastError()); <br>_ASSERTE(FALSE); <br>return hr; <br>} <br> <br>if (m_pOwner) <br>{ <br>free(m_pOwner); <br>m_pOwner = NULL; <br>} <br> <br>// If they asked for no owner don't do the copy <br>if (pOwnerSid == NULL) <br>return S_OK; <br> <br>// Make a copy of the Sid for the return value <br>DWORD dwSize = GetLengthSid(pOwnerSid); <br> <br>m_pOwner = (PSID) malloc(dwSize); <br>if (!m_pOwner) <br>{ <br>// Insufficient memory to allocate Sid <br>_ASSERTE(FALSE); <br>return E_OUTOFMEMORY; <br>} <br>if (!CopySid(dwSize, m_pOwner, pOwnerSid)) <br>{ <br>HRESULT hr = HRESULT_FROM_WIN32(GetLastError()); <br>_ASSERTE(FALSE); <br>free(m_pOwner); <br>m_pOwner = NULL; <br>return hr; <br>} <br> <br>_ASSERTE(IsValidSid(m_pOwner)); <br> <br>if (!SetSecurityDescriptorOwner(m_pSD, m_pOwner, bDefaulted)) <br>{ <br>HRESULT hr = HRESULT_FROM_WIN32(GetLastError()); <br>_ASSERTE(FALSE); <br>free(m_pOwner); <br>m_pOwner = NULL; <br>return hr; <br>} <br> <br>return S_OK; <br>} <br> <br>HRESULT CSecurityDescriptor::SetGroup(PSID pGroupSid, BOOL bDefaulted) <br>{ <br>_ASSERTE(m_pSD); <br> <br>// Mark the SD as having no Group <br>if (!SetSecurityDescriptorGroup(m_pSD, NULL, bDefaulted)) <br>{ <br>HRESULT hr = HRESULT_FROM_WIN32(GetLastError()); <br>_ASSERTE(FALSE); <br>return hr; <br>} <br> <br>if (m_pGroup) <br>{ <br>free(m_pGroup); <br>m_pGroup = NULL; <br>} <br> <br>// If they asked for no Group don't do the copy <br>if (pGroupSid == NULL) <br>return S_OK; <br> <br>// Make a copy of the Sid for the return value <br>DWORD dwSize = GetLengthSid(pGroupSid); <br> <br>m_pGroup = (PSID) malloc(dwSize); <br>if (!m_pGroup) <br>{ <br>// Insufficient memory to allocate Sid <br>_ASSERTE(FALSE); <br>return E_OUTOFMEMORY; <br>} <br>if (!CopySid(dwSize, m_pGroup, pGroupSid)) <br>{ <br>HRESULT hr = HRESULT_FROM_WIN32(GetLastError()); <br>_ASSERTE(FALSE); <br>free(m_pGroup); <br>m_pGroup = NULL; <br>return hr; <br>} <br> <br>_ASSERTE(IsValidSid(m_pGroup)); <br> <br>if (!SetSecurityDescriptorGroup(m_pSD, m_pGroup, bDefaulted)) <br>{ <br>HRESULT hr = HRESULT_FROM_WIN32(GetLastError()); <br>_ASSERTE(FALSE); <br>free(m_pGroup); <br>m_pGroup = NULL; <br>return hr; <br>} <br> <br>return S_OK; <br>} <br> <br>HRESULT CSecurityDescriptor::Allow(LPCTSTR pszPrincipal, DWORD dwAccessMask) <br>{ <br>HRESULT hr = AddAccessAllowedACEToACL(&amp;m_pDACL, pszPrincipal, dwAccessMask); <br>if (SUCCEEDED(hr)) <br>SetSecurityDescriptorDacl(m_pSD, TRUE, m_pDACL, FALSE); <br>return hr; <br>} <br> <br>HRESULT CSecurityDescriptor::Deny(LPCTSTR pszPrincipal, DWORD dwAccessMask) <br>{ <br>HRESULT hr = AddAccessDeniedACEToACL(&amp;m_pDACL, pszPrincipal, dwAccessMask); <br>if (SUCCEEDED(hr)) <br>SetSecurityDescriptorDacl(m_pSD, TRUE, m_pDACL, FALSE); <br>return hr; <br>} <br> <br>HRESULT CSecurityDescriptor::Revoke(LPCTSTR pszPrincipal) <br>{ <br>HRESULT hr = RemovePrincipalFromACL(m_pDACL, pszPrincipal); <br>if (SUCCEEDED(hr)) <br>SetSecurityDescriptorDacl(m_pSD, TRUE, m_pDACL, FALSE); <br>return hr; <br>} <br> <br>HRESULT CSecurityDescriptor::GetProcessSids(PSID* ppUserSid, PSID* ppGroupSid) <br>{ <br>BOOL bRes; <br>HRESULT hr; <br>HANDLE hToken = NULL; <br>if (ppUserSid) <br>*ppUserSid = NULL; <br>if (ppGroupSid) <br>*ppGroupSid = NULL; <br>bRes = OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &amp;hToken); <br>if (!bRes) <br>{ <br>// Couldn't open process token <br>hr = HRESULT_FROM_WIN32(GetLastError()); <br>_ASSERTE(FALSE); <br>return hr; <br>} <br>hr = GetTokenSids(hToken, ppUserSid, ppGroupSid); <br>return hr; <br>} <br> <br>HRESULT CSecurityDescriptor::GetThreadSids(PSID* ppUserSid, PSID* ppGroupSid, BOOL bOpenAsSelf) <br>{ <br>BOOL bRes; <br>HRESULT hr; <br>HANDLE hToken = NULL; <br>if (ppUserSid) <br>*ppUserSid = NULL; <br>if (ppGroupSid) <br>*ppGroupSid = NULL; <br>bRes = OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, bOpenAsSelf, &amp;hToken); <br>if (!bRes) <br>{ <br>// Couldn't open thread token <br>hr = HRESULT_FROM_WIN32(GetLastError()); <br>return hr; <br>} <br>hr = GetTokenSids(hToken, ppUserSid, ppGroupSid); <br>return hr; <br>} <br> <br> <br>HRESULT CSecurityDescriptor::GetTokenSids(HANDLE hToken, PSID* ppUserSid, PSID* ppGroupSid) <br>{ <br>DWORD dwSize; <br>HRESULT hr; <br>PTOKEN_USER ptkUser = NULL; <br>PTOKEN_PRIMARY_GROUP ptkGroup = NULL; <br> <br>if (ppUserSid) <br>*ppUserSid = NULL; <br>if (ppGroupSid) <br>*ppGroupSid = NULL; <br> <br>if (ppUserSid) <br>{ <br>// Get length required for TokenUser by specifying buffer length of 0 <br>GetTokenInformation(hToken, TokenUser, NULL, 0, &amp;dwSize); <br>hr = GetLastError(); <br>if (hr != ERROR_INSUFFICIENT_BUFFER) <br>{ <br>// Expected ERROR_INSUFFICIENT_BUFFER <br>_ASSERTE(FALSE); <br>hr = HRESULT_FROM_WIN32(hr); <br>goto failed; <br>} <br> <br>ptkUser = (TOKEN_USER*) malloc(dwSize); <br>if (!ptkUser) <br>{ <br>// Insufficient memory to allocate TOKEN_USER <br>_ASSERTE(FALSE); <br>hr = E_OUTOFMEMORY; <br>goto failed; <br>} <br>// Get Sid of process token. <br>if (!GetTokenInformation(hToken, TokenUser, ptkUser, dwSize, &amp;dwSize)) <br>{ <br>// Couldn't get user info <br>hr = HRESULT_FROM_WIN32(GetLastError()); <br>_ASSERTE(FALSE); <br>goto failed; <br>} <br> <br>// Make a copy of the Sid for the return value <br>dwSize = GetLengthSid(ptkUser-&gt;User.Sid); <br> <br>PSID pSid = (PSID) malloc(dwSize); <br>if (!pSid) <br>{ <br>// Insufficient memory to allocate Sid <br>_ASSERTE(FALSE); <br>hr = E_OUTOFMEMORY; <br>goto failed; <br>} <br>if (!CopySid(dwSize, pSid, ptkUser-&gt;User.Sid)) <br>{ <br>hr = HRESULT_FROM_WIN32(GetLastError()); <br>_ASSERTE(FALSE); <br>goto failed; <br>} <br> <br>_ASSERTE(IsValidSid(pSid)); <br>*ppUserSid = pSid; <br>free(ptkUser); <br>} <br>if (ppGroupSid) <br>{ <br>// Get length required for TokenPrimaryGroup by specifying buffer length of 0 <br>GetTokenInformation(hToken, TokenPrimaryGroup, NULL, 0, &amp;dwSize); <br>hr = GetLastError(); <br>if (hr != ERROR_INSUFFICIENT_BUFFER) <br>{ <br>// Expected ERROR_INSUFFICIENT_BUFFER <br>_ASSERTE(FALSE); <br>hr = HRESULT_FROM_WIN32(hr); <br>goto failed; <br>} <br> <br>ptkGroup = (TOKEN_PRIMARY_GROUP*) malloc(dwSize); <br>if (!ptkGroup) <br>{ <br>// Insufficient memory to allocate TOKEN_USER <br>_ASSERTE(FALSE); <br>hr = E_OUTOFMEMORY; <br>goto failed; <br>} <br>// Get Sid of process token. <br>if (!GetTokenInformation(hToken, TokenPrimaryGroup, ptkGroup, dwSize, &amp;dwSize)) <br>{ <br>// Couldn't get user info <br>hr = HRESULT_FROM_WIN32(GetLastError()); <br>_ASSERTE(FALSE); <br>goto failed; <br>} <br> <br>// Make a copy of the Sid for the return value <br>dwSize = GetLengthSid(ptkGroup-&gt;PrimaryGroup); <br> <br>PSID pSid = (PSID) malloc(dwSize); <br>if (!pSid) <br>{ <br>// Insufficient memory to allocate Sid <br>_ASSERTE(FALSE); <br>hr = E_OUTOFMEMORY; <br>goto failed; <br>} <br>if (!CopySid(dwSize, pSid, ptkGroup-&gt;PrimaryGroup)) <br>{ <br>hr = HRESULT_FROM_WIN32(GetLastError()); <br>_ASSERTE(FALSE); <br>goto failed; <br>} <br> <br>_ASSERTE(IsValidSid(pSid)); <br> <br>*ppGroupSid = pSid; <br>free(ptkGroup); <br>} <br> <br>return S_OK; <br> <br>failed: <br>if (ptkUser) <br>free(ptkUser); <br>if (ptkGroup) <br>free (ptkGroup); <br>return hr; <br>} <br> <br> <br>HRESULT CSecurityDescriptor::GetCurrentUserSID(PSID *ppSid) <br>{ <br>HANDLE tkHandle; <br> <br>if (OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &amp;tkHandle)) <br>{ <br>TOKEN_USER *tkUser; <br>DWORD tkSize; <br>DWORD sidLength; <br> <br>// Call to get size information for alloc <br>GetTokenInformation(tkHandle, TokenUser, NULL, 0, &amp;tkSize); <br>tkUser = (TOKEN_USER *) malloc(tkSize); <br> <br>// Now make the real call <br>if (GetTokenInformation(tkHandle, TokenUser, tkUser, tkSize, &amp;tkSize)) <br>{ <br>sidLength = GetLengthSid(tkUser-&gt;User.Sid); <br>*ppSid = (PSID) malloc(sidLength); <br> <br>memcpy(*ppSid, tkUser-&gt;User.Sid, sidLength); <br>CloseHandle(tkHandle); <br> <br>free(tkUser); <br>return S_OK; <br>} <br>else <br>{ <br>free(tkUser); <br>return HRESULT_FROM_WIN32(GetLastError()); <br>} <br>} <br>return HRESULT_FROM_WIN32(GetLastError()); <br>} <br> <br> <br>HRESULT CSecurityDescriptor::GetPrincipalSID(LPCTSTR pszPrincipal, PSID *ppSid) <br>{ <br>HRESULT hr; <br>LPTSTR pszRefDomain = NULL; <br>DWORD dwDomainSize = 0; <br>DWORD dwSidSize = 0; <br>SID_NAME_USE snu; <br> <br>// Call to get size info for alloc <br>LookupAccountName(NULL, pszPrincipal, *ppSid, &amp;dwSidSize, pszRefDomain, &amp;dwDomainSize, &amp;snu); <br> <br>hr = GetLastError(); <br>if (hr != ERROR_INSUFFICIENT_BUFFER) <br>return HRESULT_FROM_WIN32(hr); <br> <br>ATLTRY(pszRefDomain = new TCHAR[dwDomainSize]); <br>if (pszRefDomain == NULL) <br>return E_OUTOFMEMORY; <br> <br>*ppSid = (PSID) malloc(dwSidSize); <br>if (*ppSid != NULL) <br>{ <br>if (!LookupAccountName(NULL, pszPrincipal, *ppSid, &amp;dwSidSize, pszRefDomain, &amp;dwDomainSize, &amp;snu)) <br>{ <br>free(*ppSid); <br>*ppSid = NULL; <br>delete[] pszRefDomain; <br>return HRESULT_FROM_WIN32(GetLastError()); <br>} <br>delete[] pszRefDomain; <br>return S_OK; <br>} <br>delete[] pszRefDomain; <br>return E_OUTOFMEMORY; <br>} <br> <br> <br>HRESULT CSecurityDescriptor::Attach(PSECURITY_DESCRIPTOR pSelfRelativeSD) <br>{ <br>PACL    pDACL = NULL; <br>PACL    pSACL = NULL; <br>BOOL    bDACLPresent, bSACLPresent; <br>BOOL    bDefaulted; <br>PACL    m_pDACL = NULL; <br>ACCESS_ALLOWED_ACE* pACE; <br>HRESULT hr; <br>PSID    pUserSid; <br>PSID    pGroupSid; <br> <br>hr = Initialize(); <br>if(FAILED(hr)) <br>return hr; <br> <br>// get the existing DACL. <br>if (!GetSecurityDescriptorDacl(pSelfRelativeSD, &amp;bDACLPresent, &amp;pDACL, &amp;bDefaulted)) <br>goto failed; <br> <br>if (bDACLPresent) <br>{ <br>if (pDACL) <br>{ <br>// allocate new DACL. <br>m_pDACL = (PACL) malloc(pDACL-&gt;AclSize); <br>if (!m_pDACL) <br>goto failed; <br> <br>// initialize the DACL <br>if (!InitializeAcl(m_pDACL, pDACL-&gt;AclSize, ACL_REVISION)) <br>goto failed; <br> <br>// copy the ACES <br>for (int i = 0; i &lt; pDACL-&gt;AceCount; i++) <br>{ <br>if (!GetAce(pDACL, i, (void **)&amp;pACE)) <br>goto failed; <br> <br>if (!AddAccessAllowedAce(m_pDACL, ACL_REVISION, pACE-&gt;Mask, (PSID)&amp;(pACE-&gt;SidStart))) <br>goto failed; <br>} <br> <br>if (!IsValidAcl(m_pDACL)) <br>goto failed; <br>} <br> <br>// set the DACL <br>if (!SetSecurityDescriptorDacl(m_pSD, m_pDACL ? TRUE : FALSE, m_pDACL, bDefaulted)) <br>goto failed; <br>} <br> <br>// get the existing SACL. <br>if (!GetSecurityDescriptorSacl(pSelfRelativeSD, &amp;bSACLPresent, &amp;pSACL, &amp;bDefaulted)) <br>goto failed; <br> <br>if (bSACLPresent) <br>{ <br>if (pSACL) <br>{ <br>// allocate new SACL. <br>m_pSACL = (PACL) malloc(pSACL-&gt;AclSize); <br>if (!m_pSACL) <br>goto failed; <br> <br>// initialize the SACL <br>if (!InitializeAcl(m_pSACL, pSACL-&gt;AclSize, ACL_REVISION)) <br>goto failed; <br> <br>// copy the ACES <br>for (int i = 0; i &lt; pSACL-&gt;AceCount; i++) <br>{ <br>if (!GetAce(pSACL, i, (void **)&amp;pACE)) <br>goto failed; <br> <br>if (!AddAccessAllowedAce(m_pSACL, ACL_REVISION, pACE-&gt;Mask, (PSID)&amp;(pACE-&gt;SidStart))) <br>goto failed; <br>} <br> <br>if (!IsValidAcl(m_pSACL)) <br>goto failed; <br>} <br> <br>// set the SACL <br>if (!SetSecurityDescriptorSacl(m_pSD, m_pSACL ? TRUE : FALSE, m_pSACL, bDefaulted)) <br>goto failed; <br>} <br> <br>if (!GetSecurityDescriptorOwner(m_pSD, &amp;pUserSid, &amp;bDefaulted)) <br>goto failed; <br> <br>if (FAILED(SetOwner(pUserSid, bDefaulted))) <br>goto failed; <br> <br>if (!GetSecurityDescriptorGroup(m_pSD, &amp;pGroupSid, &amp;bDefaulted)) <br>goto failed; <br> <br>if (FAILED(SetGroup(pGroupSid, bDefaulted))) <br>goto failed; <br> <br>if (!IsValidSecurityDescriptor(m_pSD)) <br>goto failed; <br> <br>return hr; <br> <br>failed: <br>if (m_pDACL) <br>free(m_pDACL); <br>if (m_pSD) <br>free(m_pSD); <br>return E_UNEXPECTED; <br>} <br> <br>HRESULT CSecurityDescriptor::AttachObject(HANDLE hObject) <br>{ <br>HRESULT hr; <br>DWORD dwSize = 0; <br>PSECURITY_DESCRIPTOR pSD = NULL; <br> <br>GetKernelObjectSecurity(hObject, OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION | <br>DACL_SECURITY_INFORMATION, pSD, 0, &amp;dwSize); <br> <br>hr = GetLastError(); <br>if (hr != ERROR_INSUFFICIENT_BUFFER) <br>return HRESULT_FROM_WIN32(hr); <br> <br>pSD = (PSECURITY_DESCRIPTOR) malloc(dwSize); <br> <br>if (!GetKernelObjectSecurity(hObject, OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION | <br>DACL_SECURITY_INFORMATION, pSD, dwSize, &amp;dwSize)) <br>{ <br>hr = HRESULT_FROM_WIN32(GetLastError()); <br>free(pSD); <br>return hr; <br>} <br> <br>hr = Attach(pSD); <br>free(pSD); <br>return hr; <br>} <br> <br> <br>HRESULT CSecurityDescriptor::CopyACL(PACL pDest, PACL pSrc) <br>{ <br>ACL_SIZE_INFORMATION aclSizeInfo; <br>LPVOID pAce; <br>ACE_HEADER *aceHeader; <br> <br>if (pSrc == NULL) <br>return S_OK; <br> <br>if (!GetAclInformation(pSrc, (LPVOID) &amp;aclSizeInfo, sizeof(ACL_SIZE_INFORMATION), AclSizeInformation)) <br>return HRESULT_FROM_WIN32(GetLastError()); <br> <br>// Copy all of the ACEs to the new ACL <br>for (UINT i = 0; i &lt; aclSizeInfo.AceCount; i++) <br>{ <br>if (!GetAce(pSrc, i, &amp;pAce)) <br>return HRESULT_FROM_WIN32(GetLastError()); <br> <br>aceHeader = (ACE_HEADER *) pAce; <br> <br>if (!AddAce(pDest, ACL_REVISION, 0xffffffff, pAce, aceHeader-&gt;AceSize)) <br>return HRESULT_FROM_WIN32(GetLastError()); <br>} <br> <br>return S_OK; <br>} <br> <br>HRESULT CSecurityDescriptor::AddAccessDeniedACEToACL(PACL *ppAcl, LPCTSTR pszPrincipal, DWORD dwAccessMask) <br>{ <br>ACL_SIZE_INFORMATION aclSizeInfo; <br>int aclSize; <br>DWORD returnValue; <br>PSID principalSID; <br>PACL oldACL, newACL; <br> <br>oldACL = *ppAcl; <br> <br>returnValue = GetPrincipalSID(pszPrincipal, &amp;principalSID); <br>if (FAILED(returnValue)) <br>return returnValue; <br> <br>aclSizeInfo.AclBytesInUse = 0; <br>if (*ppAcl != NULL) <br>GetAclInformation(oldACL, (LPVOID) &amp;aclSizeInfo, sizeof(ACL_SIZE_INFORMATION), AclSizeInformation); <br> <br>aclSize = aclSizeInfo.AclBytesInUse + sizeof(ACL) + sizeof(ACCESS_DENIED_ACE) + GetLengthSid(principalSID) - sizeof(DWORD); <br> <br>ATLTRY(newACL = (PACL) new BYTE[aclSize]); <br> <br>if (!InitializeAcl(newACL, aclSize, ACL_REVISION)) <br>{ <br>free(principalSID); <br>return HRESULT_FROM_WIN32(GetLastError()); <br>} <br> <br>if (!AddAccessDeniedAce(newACL, ACL_REVISION2, dwAccessMask, principalSID)) <br>{ <br>free(principalSID); <br>return HRESULT_FROM_WIN32(GetLastError()); <br>} <br> <br>returnValue = CopyACL(newACL, oldACL); <br>if (FAILED(returnValue)) <br>{ <br>free(principalSID); <br>return returnValue; <br>} <br> <br>*ppAcl = newACL; <br> <br>if (oldACL != NULL) <br>free(oldACL); <br>free(principalSID); <br>return S_OK; <br>} <br> <br> <br>HRESULT CSecurityDescriptor::AddAccessAllowedACEToACL(PACL *ppAcl, LPCTSTR pszPrincipal, DWORD dwAccessMask) <br>{ <br>ACL_SIZE_INFORMATION aclSizeInfo; <br>int aclSize; <br>DWORD returnValue; <br>PSID principalSID; <br>PACL oldACL, newACL; <br> <br>oldACL = *ppAcl; <br> <br>returnValue = GetPrincipalSID(pszPrincipal, &amp;principalSID); <br>if (FAILED(returnValue)) <br>return returnValue; <br> <br>aclSizeInfo.AclBytesInUse = 0; <br>if (*ppAcl != NULL) <br>GetAclInformation(oldACL, (LPVOID) &amp;aclSizeInfo, (DWORD) sizeof(ACL_SIZE_INFORMATION), AclSizeInformation); <br> <br>aclSize = aclSizeInfo.AclBytesInUse + sizeof(ACL) + sizeof(ACCESS_ALLOWED_ACE) + GetLengthSid(principalSID) - sizeof(DWORD); <br> <br>ATLTRY(newACL = (PACL) new BYTE[aclSize]); <br> <br>if (!InitializeAcl(newACL, aclSize, ACL_REVISION)) <br>{ <br>free(principalSID); <br>return HRESULT_FROM_WIN32(GetLastError()); <br>} <br> <br>returnValue = CopyACL(newACL, oldACL); <br>if (FAILED(returnValue)) <br>{ <br>free(principalSID); <br>return returnValue; <br>} <br> <br>if (!AddAccessAllowedAce(newACL, ACL_REVISION2, dwAccessMask, principalSID)) <br>{ <br>free(principalSID); <br>return HRESULT_FROM_WIN32(GetLastError()); <br>} <br> <br>*ppAcl = newACL; <br> <br>if (oldACL != NULL) <br>free(oldACL); <br>free(principalSID); <br>return S_OK; <br>} <br> <br> <br>HRESULT CSecurityDescriptor::RemovePrincipalFromACL(PACL pAcl, LPCTSTR pszPrincipal) <br>{ <br>ACL_SIZE_INFORMATION aclSizeInfo; <br>ULONG i; <br>LPVOID ace; <br>ACCESS_ALLOWED_ACE *accessAllowedAce; <br>ACCESS_DENIED_ACE *accessDeniedAce; <br>SYSTEM_AUDIT_ACE *systemAuditAce; <br>PSID principalSID; <br>DWORD returnValue; <br>ACE_HEADER *aceHeader; <br> <br>returnValue = GetPrincipalSID(pszPrincipal, &amp;principalSID); <br>if (FAILED(returnValue)) <br>return returnValue; <br> <br>GetAclInformation(pAcl, (LPVOID) &amp;aclSizeInfo, (DWORD) sizeof(ACL_SIZE_INFORMATION), AclSizeInformation); <br> <br>for (i = 0; i &lt; aclSizeInfo.AceCount; i++) <br>{ <br>if (!GetAce(pAcl, i, &amp;ace)) <br>{ <br>free(principalSID); <br>return HRESULT_FROM_WIN32(GetLastError()); <br>} <br> <br>aceHeader = (ACE_HEADER *) ace; <br> <br>if (aceHeader-&gt;AceType == ACCESS_ALLOWED_ACE_TYPE) <br>{ <br>accessAllowedAce = (ACCESS_ALLOWED_ACE *) ace; <br> <br>if (EqualSid(principalSID, (PSID) &amp;accessAllowedAce-&gt;SidStart)) <br>{ <br>DeleteAce(pAcl, i); <br>free(principalSID); <br>return S_OK; <br>} <br>} else <br> <br>if (aceHeader-&gt;AceType == ACCESS_DENIED_ACE_TYPE) <br>{ <br>accessDeniedAce = (ACCESS_DENIED_ACE *) ace; <br> <br>if (EqualSid(principalSID, (PSID) &amp;accessDeniedAce-&gt;SidStart)) <br>{ <br>DeleteAce(pAcl, i); <br>free(principalSID); <br>return S_OK; <br>} <br>} else <br> <br>if (aceHeader-&gt;AceType == SYSTEM_AUDIT_ACE_TYPE) <br>{ <br>systemAuditAce = (SYSTEM_AUDIT_ACE *) ace; <br> <br>if (EqualSid(principalSID, (PSID) &amp;systemAuditAce-&gt;SidStart)) <br>{ <br>DeleteAce(pAcl, i); <br>free(principalSID); <br>return S_OK; <br>} <br>} <br>} <br>free(principalSID); <br>return S_OK; <br>} <br> <br> <br>HRESULT CSecurityDescriptor::SetPrivilege(LPCTSTR privilege, BOOL bEnable, HANDLE hToken) <br>{ <br>HRESULT hr; <br>TOKEN_PRIVILEGES tpPrevious; <br>TOKEN_PRIVILEGES tp; <br>DWORD cbPrevious = sizeof(TOKEN_PRIVILEGES); <br>LUID luid; <br> <br>// if no token specified open process token <br>if (hToken == 0) <br>{ <br>if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &amp;hToken)) <br>{ <br>hr = HRESULT_FROM_WIN32(GetLastError()); <br>_ASSERTE(FALSE); <br>return hr; <br>} <br>} <br> <br>if (!LookupPrivilegeValue(NULL, privilege, &amp;luid )) <br>{ <br>hr = HRESULT_FROM_WIN32(GetLastError()); <br>_ASSERTE(FALSE); <br>return hr; <br>} <br> <br>tp.PrivilegeCount = 1; <br>tp.Privileges[0].Luid = luid; <br>tp.Privileges[0].Attributes = 0; <br> <br>if (!AdjustTokenPrivileges(hToken, FALSE, &amp;tp, sizeof(TOKEN_PRIVILEGES), &amp;tpPrevious, &amp;cbPrevious)) <br>{ <br>hr = HRESULT_FROM_WIN32(GetLastError()); <br>_ASSERTE(FALSE); <br>return hr; <br>} <br> <br>tpPrevious.PrivilegeCount = 1; <br>tpPrevious.Privileges[0].Luid = luid; <br> <br>if (bEnable) <br>tpPrevious.Privileges[0].Attributes |= (SE_PRIVILEGE_ENABLED); <br>else <br>tpPrevious.Privileges[0].Attributes ^= (SE_PRIVILEGE_ENABLED &amp; tpPrevious.Privileges[0].Attributes); <br> <br>if (!AdjustTokenPrivileges(hToken, FALSE, &amp;tpPrevious, cbPrevious, NULL, NULL)) <br>{ <br>hr = HRESULT_FROM_WIN32(GetLastError()); <br>_ASSERTE(FALSE); <br>return hr; <br>} <br>return S_OK; <br>} <br> <br>#endif //_ATL_NO_SECURITY <br>#endif //__ATLCOM_H__ <br> <br>#ifdef _DEBUG <br> <br>void _cdecl AtlTrace(LPCTSTR lpszFormat, ...) <br>{ <br>va_list args; <br>va_start(args, lpszFormat); <br> <br>int nBuf; <br>TCHAR szBuffer[512]; <br> <br>nBuf = _vstprintf(szBuffer, lpszFormat, args); <br>_ASSERTE(nBuf &lt; sizeof(szBuffer)); <br> <br>OutputDebugString(szBuffer); <br>va_end(args); <br>} <br>#endif <br> <br>#ifndef ATL_NO_NAMESPACE <br>}; //namespace ATL <br>#endif <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//All Global stuff goes below this line <br>/////////////////////////////////////////////////////////////////////////////// <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// Minimize CRT <br>// Specify DllMain as EntryPoint <br>// Turn off exception handling <br>// Define _ATL_MIN_CRT <br> <br>#ifdef _ATL_MIN_CRT <br>///////////////////////////////////////////////////////////////////////////// <br>// Startup Code <br> <br>#if defined(_WINDLL) || defined(_USRDLL) <br> <br>// Declare DllMain <br>extern "C" BOOL WINAPI DllMain(HANDLE hDllHandle, DWORD dwReason, LPVOID lpReserved); <br> <br>extern "C" BOOL WINAPI _DllMainCRTStartup(HANDLE hDllHandle, DWORD dwReason, LPVOID lpReserved) <br>{ <br>return DllMain(hDllHandle, dwReason, lpReserved); <br>} <br> <br>#else <br> <br>// wWinMain is not defined in winbase.h. <br>extern "C" int WINAPI wWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPWSTR lpCmdLine, int nShowCmd); <br> <br>#define SPACECHAR   _T(' ') <br>#define DQUOTECHAR  _T('\"') <br> <br> <br>#ifdef _UNICODE <br>extern "C" void wWinMainCRTStartup() <br>#else // _UNICODE <br>extern "C" void WinMainCRTStartup() <br>#endif // _UNICODE <br>{ <br>LPTSTR lpszCommandLine = ::GetCommandLine(); <br>if(lpszCommandLine == NULL) <br>::ExitProcess((UINT)-1); <br> <br>// Skip past program name (first token in command line). <br>// Check for and handle quoted program name. <br>if(*lpszCommandLine == DQUOTECHAR) <br>{ <br>// Scan, and skip over, subsequent characters until <br>// another double-quote or a null is encountered. <br>do <br>{ <br>lpszCommandLine = ::CharNext(lpszCommandLine); <br>} <br>while((*lpszCommandLine != DQUOTECHAR) &amp;&amp; (*lpszCommandLine != _T('\0'))); <br> <br>// If we stopped on a double-quote (usual case), skip over it. <br>if(*lpszCommandLine == DQUOTECHAR) <br>lpszCommandLine = ::CharNext(lpszCommandLine); <br>} <br>else <br>{ <br>while(*lpszCommandLine &gt; SPACECHAR) <br>lpszCommandLine = ::CharNext(lpszCommandLine); <br>} <br> <br>// Skip past any white space preceeding the second token. <br>while(*lpszCommandLine &amp;&amp; (*lpszCommandLine &lt;= SPACECHAR)) <br>lpszCommandLine = ::CharNext(lpszCommandLine); <br> <br>STARTUPINFO StartupInfo; <br>StartupInfo.dwFlags = 0; <br>::GetStartupInfo(&amp;StartupInfo); <br> <br>int nRet = _tWinMain(::GetModuleHandle(NULL), NULL, lpszCommandLine, <br>(StartupInfo.dwFlags &amp; STARTF_USESHOWWINDOW) ? <br>StartupInfo.wShowWindow : SW_SHOWDEFAULT); <br> <br>::ExitProcess((UINT)nRet); <br>} <br> <br>#endif // defined(_WINDLL) | defined(_USRDLL) <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// Heap Allocation <br> <br>#ifndef _DEBUG <br> <br>#ifndef _MERGE_PROXYSTUB <br>//rpcproxy.h does the same thing as this <br>int __cdecl _purecall() <br>{ <br>DebugBreak(); <br>return 0; <br>} <br>#endif <br> <br>extern "C" const int _fltused = 0; <br> <br>void* __cdecl malloc(size_t n) <br>{ <br>if (_Module.m_hHeap == NULL) <br>{ <br>_Module.m_hHeap = HeapCreate(0, 0, 0); <br>if (_Module.m_hHeap == NULL) <br>return NULL; <br>} <br>_ASSERTE(_Module.m_hHeap != NULL); <br> <br>#ifdef _MALLOC_ZEROINIT <br>return HeapAlloc(_Module.m_hHeap, HEAP_ZERO_MEMORY, n); <br>#else <br>return HeapAlloc(_Module.m_hHeap, 0, n); <br>#endif <br>} <br> <br>void* __cdecl calloc(size_t n, size_t s) <br>{ <br>return malloc(n * s); <br>} <br> <br>void* __cdecl realloc(void* p, size_t n) <br>{ <br>_ASSERTE(_Module.m_hHeap != NULL); <br>#ifdef _MALLOC_ZEROINIT <br>return (p == NULL) ? malloc(n) : HeapReAlloc(_Module.m_hHeap, HEAP_ZERO_MEMORY, p, n); <br>#else <br>return (p == NULL) ? malloc(n) : HeapReAlloc(_Module.m_hHeap, 0, p, n); <br>#endif <br>} <br> <br>void __cdecl free(void* p) <br>{ <br>_ASSERTE(_Module.m_hHeap != NULL); <br>HeapFree(_Module.m_hHeap, 0, p); <br>} <br> <br>void* __cdecl operator new(size_t n) <br>{ <br>return malloc(n); <br>} <br> <br>void __cdecl operator delete(void* p) <br>{ <br>free(p); <br>} <br> <br>#endif  //_DEBUG <br> <br>#endif //_ATL_MIN_CRT <br> <br>#ifndef _ATL_DLL <br> <br>#ifndef ATL_NO_NAMESPACE <br>#ifndef _ATL_DLL_IMPL <br>namespace ATL <br>{ <br>#endif <br>#endif <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// statics <br> <br>static UINT WINAPI AtlGetDirLen(LPCOLESTR lpszPathName) <br>{ <br>_ASSERTE(lpszPathName != NULL); <br> <br>// always capture the complete file name including extension (if present) <br>LPCOLESTR lpszTemp = lpszPathName; <br>for (LPCOLESTR lpsz = lpszPathName; *lpsz != NULL; ) <br>{ <br>LPCOLESTR lp = CharNextO(lpsz); <br>// remember last directory/drive separator <br>if (*lpsz == OLESTR('\\') || *lpsz == OLESTR('/') || *lpsz == OLESTR(':')) <br>lpszTemp = lp; <br>lpsz = lp; <br>} <br> <br>return lpszTemp-lpszPathName; <br>} <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// QI support <br> <br>ATLAPI AtlInternalQueryInterface(void* pThis, <br>const _ATL_INTMAP_ENTRY* pEntries, REFIID iid, void** ppvObject) <br>{ <br>_ASSERTE(pThis != NULL); <br>// First entry in the com map should be a simple map entry <br>_ASSERTE(pEntries-&gt;pFunc == _ATL_SIMPLEMAPENTRY); <br>if (ppvObject == NULL) <br>return E_POINTER; <br>*ppvObject = NULL; <br>if (InlineIsEqualUnknown(iid)) // use first interface <br>{ <br>IUnknown* pUnk = (IUnknown*)((int)pThis+pEntries-&gt;dw); <br>pUnk-&gt;AddRef(); <br>*ppvObject = pUnk; <br>return S_OK; <br>} <br>while (pEntries-&gt;pFunc != NULL) <br>{ <br>BOOL bBlind = (pEntries-&gt;piid == NULL); <br>if (bBlind || InlineIsEqualGUID(*(pEntries-&gt;piid), iid)) <br>{ <br>if (pEntries-&gt;pFunc == _ATL_SIMPLEMAPENTRY) //offset <br>{ <br>_ASSERTE(!bBlind); <br>IUnknown* pUnk = (IUnknown*)((int)pThis+pEntries-&gt;dw); <br>pUnk-&gt;AddRef(); <br>*ppvObject = pUnk; <br>return S_OK; <br>} <br>else //actual function call <br>{ <br>HRESULT hRes = pEntries-&gt;pFunc(pThis, <br>iid, ppvObject, pEntries-&gt;dw); <br>if (hRes == S_OK || (!bBlind &amp;&amp; FAILED(hRes))) <br>return hRes; <br>} <br>} <br>pEntries++; </code></pre>
<p>
</p>
<pre><code>} <br>return E_NOINTERFACE; <br>} <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// Smart Pointer helpers <br> <br>ATLAPI_(IUnknown*) AtlComPtrAssign(IUnknown** pp, IUnknown* lp) <br>{ <br>if (lp != NULL) <br>lp-&gt;AddRef(); <br>if (*pp) <br>(*pp)-&gt;Release(); <br>*pp = lp; <br>return lp; <br>} <br> <br>ATLAPI_(IUnknown*) AtlComQIPtrAssign(IUnknown** pp, IUnknown* lp, REFIID riid) <br>{ <br>IUnknown* pTemp = *pp; <br>lp-&gt;QueryInterface(riid, (void**)pp); <br>if (pTemp) <br>pTemp-&gt;Release(); <br>return *pp; <br>} <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// Inproc Marshaling helpers <br> <br>ATLAPI AtlFreeMarshalStream(IStream* pStream) <br>{ <br>if (pStream != NULL) <br>{ <br>CoReleaseMarshalData(pStream); <br>pStream-&gt;Release(); <br>} <br>return S_OK; <br>} <br> <br>ATLAPI AtlMarshalPtrInProc(IUnknown* pUnk, const IID&amp; iid, IStream** ppStream) <br>{ <br>HRESULT hRes = CreateStreamOnHGlobal(NULL, TRUE, ppStream); <br>if (SUCCEEDED(hRes)) <br>{ <br>hRes = CoMarshalInterface(*ppStream, iid, <br>pUnk, MSHCTX_INPROC, NULL, MSHLFLAGS_TABLESTRONG); <br>if (FAILED(hRes)) <br>{ <br>(*ppStream)-&gt;Release(); <br>*ppStream = NULL; <br>} <br>} <br>return hRes; <br>} <br> <br>ATLAPI AtlUnmarshalPtr(IStream* pStream, const IID&amp; iid, IUnknown** ppUnk) <br>{ <br>*ppUnk = NULL; <br>HRESULT hRes = E_INVALIDARG; <br>if (pStream != NULL) <br>{ <br>LARGE_INTEGER l; <br>l.QuadPart = 0; <br>pStream-&gt;Seek(l, STREAM_SEEK_SET, NULL); <br>hRes = CoUnmarshalInterface(pStream, iid, (void**)ppUnk); <br>} <br>return hRes; <br>} <br> <br>ATLAPI_(BOOL) AtlWaitWithMessageLoop(HANDLE hEvent) <br>{ <br>DWORD dwRet; <br>MSG msg; <br> <br>while(1) <br>{ <br>dwRet = MsgWaitForMultipleObjects(1, &amp;hEvent, FALSE, INFINITE, QS_ALLINPUT); <br> <br>if (dwRet == WAIT_OBJECT_0) <br>return TRUE;    // The event was signaled <br> <br>if (dwRet != WAIT_OBJECT_0 + 1) <br>break;          // Something else happened <br> <br>// There is one or more window message available. Dispatch them <br>while(PeekMessage(&amp;msg,NULL,NULL,NULL,PM_REMOVE)) <br>{ <br>TranslateMessage(&amp;msg); <br>DispatchMessage(&amp;msg); <br>if (WaitForSingleObject(hEvent, 0) == WAIT_OBJECT_0) <br>return TRUE; // Event is now signaled. <br>} <br>} <br>return FALSE; <br>} <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// Connection Point Helpers <br> <br>ATLAPI AtlAdvise(IUnknown* pUnkCP, IUnknown* pUnk, const IID&amp; iid, LPDWORD pdw) <br>{ <br>CComPtr&lt;IConnectionPointContainer&gt; pCPC; <br>CComPtr&lt;IConnectionPoint&gt; pCP; <br>HRESULT hRes = pUnkCP-&gt;QueryInterface(IID_IConnectionPointContainer, (void**)&amp;pCPC); <br>if (SUCCEEDED(hRes)) <br>hRes = pCPC-&gt;FindConnectionPoint(iid, &amp;pCP); <br>if (SUCCEEDED(hRes)) <br>hRes = pCP-&gt;Advise(pUnk, pdw); <br>return hRes; <br>} <br> <br>ATLAPI AtlUnadvise(IUnknown* pUnkCP, const IID&amp; iid, DWORD dw) <br>{ <br>CComPtr&lt;IConnectionPointContainer&gt; pCPC; <br>CComPtr&lt;IConnectionPoint&gt; pCP; <br>HRESULT hRes = pUnkCP-&gt;QueryInterface(IID_IConnectionPointContainer, (void**)&amp;pCPC); <br>if (SUCCEEDED(hRes)) <br>hRes = pCPC-&gt;FindConnectionPoint(iid, &amp;pCP); <br>if (SUCCEEDED(hRes)) <br>hRes = pCP-&gt;Unadvise(dw); <br>return hRes; <br>} <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// IDispatch Error handling <br> <br>ATLAPI AtlSetErrorInfo(const CLSID&amp; clsid, LPCOLESTR lpszDesc, DWORD dwHelpID, <br>LPCOLESTR lpszHelpFile, const IID&amp; iid, HRESULT hRes, HINSTANCE hInst) <br>{ <br>USES_CONVERSION; <br>TCHAR szDesc[1024]; <br>szDesc[0] = NULL; <br>// For a valid HRESULT the id should be in the range [0x0200, 0xffff] <br>if (HIWORD(lpszDesc) == 0) //id <br>{ <br>UINT nID = LOWORD((DWORD)lpszDesc); <br>_ASSERTE((nID &gt;= 0x0200 &amp;&amp; nID &lt;= 0xffff) || hRes != 0); <br>if (LoadString(hInst, nID, szDesc, 1024) == 0) <br>{ <br>_ASSERTE(FALSE); <br>lstrcpy(szDesc, _T("Unknown Error")); <br>} <br>lpszDesc = T2OLE(szDesc); <br>if (hRes == 0) <br>hRes = MAKE_HRESULT(3, FACILITY_ITF, nID); <br>} <br> <br>CComPtr&lt;ICreateErrorInfo&gt; pICEI; <br>if (SUCCEEDED(CreateErrorInfo(&amp;pICEI))) <br>{ <br>CComPtr&lt;IErrorInfo&gt; pErrorInfo; <br>pICEI-&gt;SetGUID(iid); <br>LPOLESTR lpsz; <br>ProgIDFromCLSID(clsid, &amp;lpsz); <br>if (lpsz != NULL) <br>pICEI-&gt;SetSource(lpsz); <br>if (dwHelpID != 0 &amp;&amp; lpszHelpFile != NULL) <br>{ <br>pICEI-&gt;SetHelpContext(dwHelpID); <br>pICEI-&gt;SetHelpFile(const_cast&lt;LPOLESTR&gt;(lpszHelpFile)); <br>} <br>CoTaskMemFree(lpsz); <br>pICEI-&gt;SetDescription((LPOLESTR)lpszDesc); <br>if (SUCCEEDED(pICEI-&gt;QueryInterface(IID_IErrorInfo, (void**)&amp;pErrorInfo))) <br>SetErrorInfo(0, pErrorInfo); <br>} <br>//#ifdef _DEBUG <br>//  USES_CONVERSION; <br>//  ATLTRACE(_T("AtlReportError: Description=\"%s\" returning %x\n"), OLE2CT(lpszDesc), hRes); <br>//#endif <br>return (hRes == 0) ? DISP_E_EXCEPTION : hRes; <br>} <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// Module <br> <br>//Although these functions are big, they are only used once in a module <br>//so we should make them inline. <br> <br>ATLAPI AtlModuleInit(_ATL_MODULE* pM, _ATL_OBJMAP_ENTRY* p, HINSTANCE h) <br>{ <br>_ASSERTE(pM != NULL); <br>if (pM == NULL) <br>return E_INVALIDARG; <br>if (pM-&gt;cbSize &lt; sizeof(_ATL_MODULE)) <br>return E_INVALIDARG; <br>pM-&gt;m_pObjMap = p; <br>pM-&gt;m_hInst = pM-&gt;m_hInstTypeLib = pM-&gt;m_hInstResource = h; <br>pM-&gt;m_nLockCnt=0L; <br>pM-&gt;m_hHeap = NULL; <br>InitializeCriticalSection(&amp;pM-&gt;m_csTypeInfoHolder); <br>InitializeCriticalSection(&amp;pM-&gt;m_csWindowCreate); <br>InitializeCriticalSection(&amp;pM-&gt;m_csObjMap); <br>return S_OK; <br>} <br> <br>ATLAPI AtlModuleRegisterClassObjects(_ATL_MODULE* pM, DWORD dwClsContext, DWORD dwFlags) <br>{ <br>_ASSERTE(pM != NULL); <br>if (pM == NULL) <br>return E_INVALIDARG; <br>_ASSERTE(pM-&gt;m_pObjMap != NULL); <br>_ATL_OBJMAP_ENTRY* pEntry = pM-&gt;m_pObjMap; <br>HRESULT hRes = S_OK; <br>while (pEntry-&gt;pclsid != NULL &amp;&amp; hRes == S_OK) <br>{ <br>hRes = pEntry-&gt;RegisterClassObject(dwClsContext, dwFlags); <br>pEntry++; <br>} <br>return hRes; <br>} <br> <br>ATLAPI AtlModuleRevokeClassObjects(_ATL_MODULE* pM) <br>{ <br>_ASSERTE(pM != NULL); <br>if (pM == NULL) <br>return E_INVALIDARG; <br>_ASSERTE(pM-&gt;m_pObjMap != NULL); <br>_ATL_OBJMAP_ENTRY* pEntry = pM-&gt;m_pObjMap; <br>HRESULT hRes = S_OK; <br>while (pEntry-&gt;pclsid != NULL &amp;&amp; hRes == S_OK) <br>{ <br>hRes = pEntry-&gt;RevokeClassObject(); <br>pEntry++; <br>} <br>return hRes; <br>} <br> <br>ATLAPI AtlModuleGetClassObject(_ATL_MODULE* pM, REFCLSID rclsid, REFIID riid, LPVOID* ppv) <br>{ <br>_ASSERTE(pM != NULL); <br>if (pM == NULL) <br>return E_INVALIDARG; <br>_ASSERTE(pM-&gt;m_pObjMap != NULL); <br>_ATL_OBJMAP_ENTRY* pEntry = pM-&gt;m_pObjMap; <br>HRESULT hRes = S_OK; <br>if (ppv == NULL) <br>return E_POINTER; <br>while (pEntry-&gt;pclsid != NULL) <br>{ <br>if (InlineIsEqualGUID(rclsid, *pEntry-&gt;pclsid)) <br>{ <br>if (pEntry-&gt;pCF == NULL) <br>{ <br>EnterCriticalSection(&amp;pM-&gt;m_csObjMap); <br>if (pEntry-&gt;pCF == NULL) <br>hRes = pEntry-&gt;pfnGetClassObject(pEntry-&gt;pfnCreateInstance, IID_IUnknown, (LPVOID*)&amp;pEntry-&gt;pCF); <br>LeaveCriticalSection(&amp;pM-&gt;m_csObjMap); <br>} <br>if (pEntry-&gt;pCF != NULL) <br>hRes = pEntry-&gt;pCF-&gt;QueryInterface(riid, ppv); <br>break; <br>} <br>pEntry++; <br>} <br>if (*ppv == NULL &amp;&amp; hRes == S_OK) <br>hRes = CLASS_E_CLASSNOTAVAILABLE; <br>return hRes; <br>} <br> <br>ATLAPI AtlModuleTerm(_ATL_MODULE* pM) <br>{ <br>_ASSERTE(pM != NULL); <br>if (pM == NULL) <br>return E_INVALIDARG; <br>_ASSERTE(pM-&gt;m_hInst != NULL); <br>if (pM-&gt;m_pObjMap != NULL) <br>{ <br>_ATL_OBJMAP_ENTRY* pEntry = pM-&gt;m_pObjMap; <br>while (pEntry-&gt;pclsid != NULL) <br>{ <br>if (pEntry-&gt;pCF != NULL) <br>pEntry-&gt;pCF-&gt;Release(); <br>pEntry-&gt;pCF = NULL; <br>pEntry++; <br>} <br>} <br>DeleteCriticalSection(&amp;pM-&gt;m_csTypeInfoHolder); <br>DeleteCriticalSection(&amp;pM-&gt;m_csWindowCreate); <br>DeleteCriticalSection(&amp;pM-&gt;m_csObjMap); <br>if (pM-&gt;m_hHeap != NULL) <br>HeapDestroy(pM-&gt;m_hHeap); <br>return S_OK; <br>} <br> <br>ATLAPI AtlModuleRegisterServer(_ATL_MODULE* pM, BOOL bRegTypeLib, const CLSID* pCLSID) <br>{ <br>_ASSERTE(pM != NULL); <br>if (pM == NULL) <br>return E_INVALIDARG; <br>_ASSERTE(pM-&gt;m_hInst != NULL); <br>_ASSERTE(pM-&gt;m_pObjMap != NULL); <br>_ATL_OBJMAP_ENTRY* pEntry = pM-&gt;m_pObjMap; <br>HRESULT hRes = S_OK; <br>for (;pEntry-&gt;pclsid != NULL; pEntry++) <br>{ <br>if (pCLSID == NULL) <br>{ <br>if (pEntry-&gt;pfnGetObjectDescription() != NULL) <br>continue; <br>} <br>else <br>{ <br>if (!IsEqualGUID(*pCLSID, *pEntry-&gt;pclsid)) <br>continue; <br>} <br>hRes = pEntry-&gt;pfnUpdateRegistry(TRUE); <br>if (FAILED(hRes)) <br>break; <br>} <br>if (SUCCEEDED(hRes) &amp;&amp; bRegTypeLib) <br>hRes = AtlModuleRegisterTypeLib(pM, 0); <br>return hRes; <br>} <br> <br>ATLAPI AtlModuleUnregisterServer(_ATL_MODULE* pM, const CLSID* pCLSID) <br>{ <br>_ASSERTE(pM != NULL); <br>if (pM == NULL) <br>return E_INVALIDARG; <br>_ASSERTE(pM-&gt;m_hInst != NULL); <br>_ASSERTE(pM-&gt;m_pObjMap != NULL); <br>_ATL_OBJMAP_ENTRY* pEntry = pM-&gt;m_pObjMap; <br>for (;pEntry-&gt;pclsid != NULL; pEntry++) <br>{ <br>if (pCLSID == NULL) <br>{ <br>if (pEntry-&gt;pfnGetObjectDescription() != NULL) <br>continue; <br>} <br>else <br>{ <br>if (!IsEqualGUID(*pCLSID, *pEntry-&gt;pclsid)) <br>continue; <br>} <br>pEntry-&gt;pfnUpdateRegistry(FALSE); //unregister <br>} <br>return S_OK; <br>} <br> <br>ATLAPI AtlModuleUpdateRegistryFromResourceD(_ATL_MODULE* pM, LPCOLESTR lpszRes, <br>BOOL bRegister, struct _ATL_REGMAP_ENTRY* pMapEntries, IRegistrar* pReg) <br>{ <br>USES_CONVERSION; <br>_ASSERTE(pM != NULL); <br>HRESULT hRes = S_OK; <br>CComPtr&lt;IRegistrar&gt; p; <br>if (pReg != NULL) <br>p = pReg; <br>else <br>{ <br>hRes = CoCreateInstance(CLSID_Registrar, NULL, <br>CLSCTX_INPROC_SERVER, IID_IRegistrar, (void**)&amp;p); <br>} <br>if (SUCCEEDED(hRes)) <br>{ <br>TCHAR szModule[_MAX_PATH]; <br>GetModuleFileName(pM-&gt;m_hInst, szModule, _MAX_PATH); <br>p-&gt;AddReplacement(OLESTR("Module"), T2OLE(szModule)); <br> <br>if (NULL != pMapEntries) <br>{ <br>while (NULL != pMapEntries-&gt;szKey) <br>{ <br>_ASSERTE(NULL != pMapEntries-&gt;szData); <br>p-&gt;AddReplacement((LPOLESTR)pMapEntries-&gt;szKey, (LPOLESTR)pMapEntries-&gt;szData); <br>pMapEntries++; <br>} <br>} <br>LPCOLESTR szType = OLESTR("REGISTRY"); <br>GetModuleFileName(pM-&gt;m_hInstResource, szModule, _MAX_PATH); <br>LPOLESTR pszModule = T2OLE(szModule); <br>if (HIWORD(lpszRes)==0) <br>{ <br>if (bRegister) <br>hRes = p-&gt;ResourceRegister(pszModule, ((UINT)LOWORD((DWORD)lpszRes)), szType); <br>else <br>hRes = p-&gt;ResourceUnregister(pszModule, ((UINT)LOWORD((DWORD)lpszRes)), szType); <br>} <br>else <br>{ <br>if (bRegister) <br>hRes = p-&gt;ResourceRegisterSz(pszModule, lpszRes, szType); <br>else <br>hRes = p-&gt;ResourceUnregisterSz(pszModule, lpszRes, szType); <br>} <br> <br>} <br>return hRes; <br>} <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// TypeLib Support <br> <br>ATLAPI AtlModuleRegisterTypeLib(_ATL_MODULE* pM, LPCOLESTR lpszIndex) <br>{ <br>_ASSERTE(pM != NULL); <br>USES_CONVERSION; <br>_ASSERTE(pM-&gt;m_hInstTypeLib != NULL); <br>TCHAR szModule[_MAX_PATH+10]; <br>OLECHAR szDir[_MAX_PATH]; <br>GetModuleFileName(pM-&gt;m_hInstTypeLib, szModule, _MAX_PATH); <br>if (lpszIndex != NULL) <br>lstrcat(szModule, OLE2CT(lpszIndex)); <br>ITypeLib* pTypeLib; <br>LPOLESTR lpszModule = T2OLE(szModule); <br>HRESULT hr = LoadTypeLib(lpszModule, &amp;pTypeLib); <br>if (!SUCCEEDED(hr)) <br>{ <br>// typelib not in module, try &lt;module&gt;.tlb instead <br>LPTSTR lpszExt = NULL; <br>LPTSTR lpsz; <br>for (lpsz = szModule; *lpsz != NULL; lpsz = CharNext(lpsz)) <br>{ <br>if (*lpsz == _T('.')) <br>lpszExt = lpsz; <br>} <br>if (lpszExt == NULL) <br>lpszExt = lpsz; <br>lstrcpy(lpszExt, _T(".tlb")); <br>lpszModule = T2OLE(szModule); <br>hr = LoadTypeLib(lpszModule, &amp;pTypeLib); <br>} <br>if (SUCCEEDED(hr)) <br>{ <br>ocscpy(szDir, lpszModule); <br>szDir[AtlGetDirLen(szDir)] = 0; <br>hr = ::RegisterTypeLib(pTypeLib, lpszModule, szDir); <br>} <br>if (pTypeLib != NULL) <br>pTypeLib-&gt;Release(); <br>return hr; <br>} <br> <br>#ifndef ATL_NO_NAMESPACE <br>#ifndef _ATL_DLL_IMPL <br>}; //namespace ATL <br>#endif <br>#endif <br> <br>#endif //!_ATL_DLL <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
