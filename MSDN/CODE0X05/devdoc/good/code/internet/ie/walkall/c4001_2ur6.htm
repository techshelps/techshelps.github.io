<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>WALKALL.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context4002"></a>WALKALL.CPP</h2>
<pre><code>// =========================================================================== <br>// File: W A L K A L L . C P P <br>// <br>// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF <br>// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO <br>// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A <br>// PARTICULAR PURPOSE. <br>// <br>// Description: <br>// <br>// This sample demonstrates the use of MSHTML as a UI-less HTML parser. <br>// To successfully walk the HTML Scripting Object Model that the parser <br>// exposes after loading the specified document, the host application must <br>// wait until MSHTML has finished loading the document. To track MSHTML's  <br>// READYSTATE, the host implements a simple COM object that exposes  <br>// IPropertyNotifySink. The host application connects to MSHTML using the  <br>// standard connection point interfaces. As MSHTML loads the document  <br>// it's readiness state changes. To notify the host of these changes,  <br>// it executes IPropertyNotifySink::OnChanged passing along the DISPID  <br>// of the property that has changed (DISPID_READYSTATE). The host uses MSHTML's  <br>// automation interface obtained at creation time to retrieve the current value  <br>// of this property. When the value equals READYSTATE_COMPLETE,  <br>// MSHTML has finished loading the document. <br> <br>// If the loaded document is an HTML page which contains scripts, Java Applets and/or  <br>// ActiveX controls, and those scripts are coded for immediate execution, MSHTML will <br>// execute them by default. To disable this feature, the host must implement two  <br>// additional interfaces: IOleClientSite and IDispatch. At initialization time, after <br>// MSHTML is instantiated, the host should query MSHTML for its IOleObject interface, <br>// pass MSHTML a reference to its IOleClientSite interface, query MSHTML for its IOleControl <br>// interface, and call OnAmbientPropertyChange(DISPID_AMBIENT_DLCONTROL). MSHTML will in  <br>// turn query the host's IOleClientSite interface for IDispatch and then request the value <br>// of this property from the host. This is the hosts opportunity to control MSHTML, disabling <br>// the execution of scripts, etc. A full list of control flags are available in &lt;mshtmdid.h&gt;. <br> <br>// Requirements: <br>//   * Internet Explorer version 4.0 <br>//   * Microsoft Visual C++ 5.0. The code uses types (_bstr_t) introduced with VC5. <br>//   * Be sure that the INETSDK include and lib directories are in your INCLUDE and LIB <br>//     environment variables respectively. <br> <br>// Instructions: <br>// <br>//  To use this sample: <br>//   * build it using the NMAKE command. NMAKE will create WALKALL.EXE. <br>//   * run WALKALL.EXE specifying the resource to download by passing an <br>//     URL on the command-line. use no command-line argument to default to <br>//     "http://example.microsoft.com". <br>//   * The program prints all HTML tags to the console. If an IMG tag is encountered <br>//     the SRC attribute is displayed. <br>// <br>// Modification History <br>// 30 May 1997 - Matt Oshry - created <br>// 12 Jun 1997 - Matt Oshry - added minimal support for IOleClientSite and IDispatch <br>// Copyright 1995-1997 Microsoft Corporation.  All Rights Reserved. <br>// =========================================================================== <br> <br>#include &lt;windows.h&gt; <br>#include &lt;tchar.h&gt; <br>#include &lt;wininet.h&gt; <br>#include &lt;urlmon.h&gt; <br>#include &lt;mshtml.h&gt; <br>#include &lt;iostream.h&gt; <br>#include &lt;comdef.h&gt; <br>#include &lt;assert.h&gt; <br> <br>#include &lt;servprov.h&gt; <br> <br>#include &lt;mshtmdid.h&gt; <br> <br>#define C_USAGE _T("Usage: walkall &lt;URL&gt;") <br> <br>#define ODS(x) OutputDebugString(x) <br> <br>#define WM_USER_STARTWALKING((WM_USER) + 1) <br> <br>const TCHAR c_szDefaultUrl[] = _T("http://example.microsoft.com/"); <br> <br>INTERNET_SCHEME GetScheme(LPCTSTR szURL); <br> <br>void PrintDISPID(DISPID dispidMember); <br> <br>class CApp : public IPropertyNotifySink, IOleClientSite, IDispatch <br>{ <br>public: <br>CApp() : m_pMSHTML(NULL), m_dwRef(1),  <br>m_hrConnected(CONNECT_E_CANNOTCONNECT), <br>m_dwCookie(0), m_pCP(NULL), m_szURL(NULL), m_nScheme(INTERNET_SCHEME_UNKNOWN), <br>m_lReadyState(READYSTATE_UNINITIALIZED) <br>{} <br>~CApp() <br>{ <br>if (m_pMSHTML) <br>{ <br>m_pMSHTML-&gt;Release(); <br>} <br>} <br> <br>// IUnknown methods <br>    STDMETHOD(QueryInterface)(REFIID riid, LPVOID* ppv); <br>    STDMETHOD_(ULONG, AddRef)(); <br>    STDMETHOD_(ULONG, Release)();  <br> <br>// IPropertyNotifySink methods <br>    STDMETHOD(OnChanged)(DISPID dispID); <br>    STDMETHOD(OnRequestEdit)(DISPID dispID); <br> <br>// IOleClientSite methods <br>STDMETHOD(SaveObject)(void) { ODS("SaveObject\n"); return E_NOTIMPL; } <br> <br>STDMETHOD(GetMoniker)(DWORD dwAssign, <br>            DWORD dwWhichMoniker, <br>            IMoniker** ppmk) <br>{ ODS("GetMoniker\n"); return E_NOTIMPL; } <br> <br>STDMETHOD(GetContainer)(IOleContainer** ppContainer) <br>{ ODS("GetContainer\n"); return E_NOTIMPL; } <br> <br>STDMETHOD(ShowObject)(void) <br>{ ODS("ShowObject\n"); return E_NOTIMPL; } <br> <br>    STDMETHOD(OnShowWindow)(BOOL fShow) <br>{ ODS("OnShowWindow\n"); return E_NOTIMPL; } <br> <br>    STDMETHOD(RequestNewObjectLayout)(void) <br>{ ODS("RequestNewObjectLayout\n"); return E_NOTIMPL; } <br> <br>// IDispatch method <br>STDMETHOD(GetTypeInfoCount)(UINT* pctinfo) <br>{ ODS("GetTypeInfoCount\n"); return E_NOTIMPL; } <br> <br>STDMETHOD(GetTypeInfo)(UINT iTInfo, <br>            LCID lcid, <br>            ITypeInfo** ppTInfo) <br>{ ODS("GetTypeInfo\n"); return E_NOTIMPL; } <br> <br>STDMETHOD(GetIDsOfNames)(REFIID riid, <br>            LPOLESTR* rgszNames, <br>            UINT cNames, <br>            LCID lcid, <br>            DISPID* rgDispId) <br>{ ODS("GetIDsOfNames\n"); return E_NOTIMPL; } <br>         <br>STDMETHOD(Invoke)(DISPID dispIdMember, <br>            REFIID riid, <br>            LCID lcid, <br>            WORD wFlags, <br>            DISPPARAMS __RPC_FAR *pDispParams, <br>            VARIANT __RPC_FAR *pVarResult, <br>            EXCEPINFO __RPC_FAR *pExcepInfo, <br>            UINT __RPC_FAR *puArgErr); <br> <br>// Additional class methods <br>HRESULT Init(int argc, char* argv[]); <br>HRESULT Run(); <br>HRESULT Term(); <br>HRESULT Walk(); <br> <br>protected: <br>// Persistence helpers <br>HRESULT LoadURLFromFile(); <br>HRESULT LoadURLFromMoniker(); <br> <br>IHTMLDocument2* m_pMSHTML; <br>DWORD m_dwRef; <br>DWORD m_dwCookie; <br>LPCONNECTIONPOINT m_pCP; <br>HRESULT m_hrConnected; <br>LPTSTR m_szURL; <br>INTERNET_SCHEME m_nScheme; <br>READYSTATE m_lReadyState; <br> <br>IBinding* m_pBinding; <br>}; <br> <br>STDMETHODIMP CApp::QueryInterface(REFIID riid, LPVOID* ppv) <br>{ <br>*ppv = NULL; <br> <br>if (IID_IUnknown == riid || IID_IPropertyNotifySink == riid) <br>{ <br>*ppv = (LPUNKNOWN)(IPropertyNotifySink*)this; <br>AddRef(); <br>return NOERROR; <br>} <br>else if (IID_IOleClientSite == riid) <br>{ <br>*ppv = (IOleClientSite*)this; <br>AddRef(); <br>return NOERROR; <br>} <br>else if (IID_IDispatch == riid) <br>{ <br>*ppv = (IDispatch*)this; <br>AddRef(); <br>return NOERROR; <br>} <br>else <br>{ <br>OLECHAR wszBuff[39]; <br>int i = StringFromGUID2(riid, wszBuff, 39); <br>TCHAR szBuff[39]; <br>i = WideCharToMultiByte(CP_ACP, 0, wszBuff, -1, szBuff, 39, NULL, NULL); <br>ODS("QI: "); ODS(szBuff); ODS("\n"); <br>return E_NOTIMPL; <br>} <br>} <br> <br>STDMETHODIMP_(ULONG) CApp::AddRef() <br>{ <br>TCHAR szBuff[255]; <br>wsprintf(szBuff, "CApp refcount increased to %d\n", m_dwRef+1); <br>ODS(szBuff); <br>return ++m_dwRef; <br>} <br> <br>STDMETHODIMP_(ULONG) CApp::Release() <br>{ <br>TCHAR szBuff[255]; <br> <br>if (--m_dwRef == 0)  <br>{  <br>ODS("Deleting object\n"); <br>delete this;  <br>return 0;  <br>} <br> <br>wsprintf(szBuff, "CApp refcount reduced to %d\n", m_dwRef); <br>ODS(szBuff); <br>return m_dwRef; <br>} <br> <br>// Fired on change of the value of a 'bindable' property <br>STDMETHODIMP CApp::OnChanged(DISPID dispID) <br>{ <br>HRESULT hr; <br>TCHAR szBuff[255]; <br> <br>if (DISPID_READYSTATE == dispID) <br>{ <br>// check the value of the readystate property <br>assert(m_pMSHTML); <br> <br>VARIANT vResult = {0}; <br>EXCEPINFO excepInfo; <br>UINT uArgErr; <br> <br>DISPPARAMS dp = {NULL, NULL, 0, 0}; <br>if (SUCCEEDED(hr = m_pMSHTML-&gt;Invoke(DISPID_READYSTATE, IID_NULL, LOCALE_SYSTEM_DEFAULT,  <br>DISPATCH_PROPERTYGET, &amp;dp, &amp;vResult, &amp;excepInfo, &amp;uArgErr))) <br>{ <br>TCHAR szReadyState[20]; <br>assert(VT_I4 == V_VT(&amp;vResult)); <br>m_lReadyState = (READYSTATE)V_I4(&amp;vResult); <br>switch (m_lReadyState) <br>{ <br>case READYSTATE_UNINITIALIZED://= 0, <br>lstrcpy(szReadyState, _T("Uninitialized")); <br>break; <br>case READYSTATE_LOADING: //= 1, <br>lstrcpy(szReadyState, _T("Loading")); <br>break; <br>case READYSTATE_LOADED:// = 2, <br>lstrcpy(szReadyState, _T("Loaded")); <br>break; <br>case READYSTATE_INTERACTIVE: //= 3, <br>lstrcpy(szReadyState, _T("Interactive")); <br>break; <br>case READYSTATE_COMPLETE: // = 4 <br>lstrcpy(szReadyState, _T("Complete")); <br>BOOL fRet = PostThreadMessage(GetCurrentThreadId(), <br>WM_USER_STARTWALKING, <br>(WPARAM)0, <br>(LPARAM)0); <br>break; <br>} <br>wsprintf(szBuff, _T("OnChanged: readyState = %s\n"), szReadyState); <br>VariantClear(&amp;vResult); <br>} <br>else <br>{ <br>lstrcpy(szBuff, _T("Unable to obtain readyState value\n")); <br>} <br>} <br>else <br>{ <br>wsprintf(szBuff, _T("OnChanged: %d\n"), dispID); <br>} <br> <br>ODS(szBuff); <br>cout &lt;&lt; szBuff; <br> <br>return NOERROR; <br>} <br> <br>STDMETHODIMP CApp::OnRequestEdit(DISPID dispID) <br>{ <br>// Property changes are OK any time as far as this app is concerned <br>TCHAR szBuff[255]; <br>wsprintf(szBuff, _T("OnRequestEdit: %d\n"), dispID); <br>ODS(szBuff); <br> <br>return NOERROR; <br>} <br> <br>typedef CApp* LPAPP; <br> <br>LPAPP g_pApp; <br> <br>int main(int argc, char* argv[]) <br>{ <br>HRESULT hr = NOERROR; <br> <br>g_pApp = new CApp; <br>if (!g_pApp) <br>{ <br>return -1; <br>} <br> <br>if (FAILED(hr = CoInitialize(NULL))) <br>{ <br>return -1; <br>} <br> <br>if (FAILED(g_pApp-&gt;Init(argc, argv))) <br>{ <br>goto Error; <br>} <br> <br>g_pApp-&gt;Run(); <br> <br>g_pApp-&gt;Term(); <br> <br>Error: <br>if (g_pApp) g_pApp-&gt;Release(); <br> <br>CoUninitialize(); <br> <br>if (FAILED(hr)) <br>{ <br>return -1; <br>} <br>else <br>{ <br>return 0; <br>} <br>} <br> <br>// Return the protocol associated with the specified URL <br>INTERNET_SCHEME GetScheme(LPCTSTR szURL) <br>{ <br>URL_COMPONENTS urlComponents; <br>DWORD dwFlags = 0; <br>INTERNET_SCHEME nScheme = INTERNET_SCHEME_UNKNOWN; <br> <br>ZeroMemory((PVOID)&amp;urlComponents, sizeof(URL_COMPONENTS)); <br>urlComponents.dwStructSize = sizeof(URL_COMPONENTS); <br> <br>if (szURL) <br>{ <br>if (InternetCrackUrl(szURL, 0, dwFlags, &amp;urlComponents)) <br>{ <br>nScheme = urlComponents.nScheme; <br>} <br>} <br> <br>return nScheme; <br>} <br> <br>// Initialize the app. Load MSHTML, hook up property notification sink, etc <br>HRESULT CApp::Init(int argc, char* argv[]) <br>{ <br>HRESULT hr; <br>LPCONNECTIONPOINTCONTAINER pCPC = NULL; <br>LPOLEOBJECT pOleObject = NULL; <br>LPOLECONTROL pOleControl = NULL; <br> <br>if (argc &lt; 2) <br>{ <br>// If no arguments were passed, load a default URL <br>m_szURL = (LPTSTR)c_szDefaultUrl; <br>m_nScheme = INTERNET_SCHEME_HTTP; <br>} <br>else <br>{ <br>// otherwise, check the scheme (protocol) <br>// to determine which persistence interface to use <br>// see the Run method for where the scheme is used <br>m_szURL = argv[1]; <br>m_nScheme = GetScheme(m_szURL); <br>} <br> <br>// Create an instance of an dynamic HTML document <br>if (FAILED(hr = CoCreateInstance( CLSID_HTMLDocument, NULL,  <br>CLSCTX_INPROC_SERVER, IID_IHTMLDocument2,  <br>(LPVOID*)&amp;g_pApp-&gt;m_pMSHTML ))) <br>{ <br>goto Error; <br>} <br> <br>if (FAILED(hr = m_pMSHTML-&gt;QueryInterface(IID_IOleObject, (LPVOID*)&amp;pOleObject))) <br>{ <br>goto Error; <br>} <br>hr = pOleObject-&gt;SetClientSite((IOleClientSite*)this); <br>pOleObject-&gt;Release(); <br> <br>if (FAILED(hr = m_pMSHTML-&gt;QueryInterface(IID_IOleControl, (LPVOID*)&amp;pOleControl))) <br>{ <br>goto Error; <br>} <br>hr = pOleControl-&gt;OnAmbientPropertyChange(DISPID_AMBIENT_DLCONTROL); <br>pOleControl-&gt;Release(); <br> <br>// Hook up sink to catch ready state property change <br>if (FAILED(hr = m_pMSHTML-&gt;QueryInterface(IID_IConnectionPointContainer, (LPVOID*)&amp;pCPC))) <br>{ <br>goto Error; <br>} <br> <br>if (FAILED(hr = pCPC-&gt;FindConnectionPoint(IID_IPropertyNotifySink, &amp;m_pCP))) <br>{ <br>goto Error; <br>} <br> <br>m_hrConnected = m_pCP-&gt;Advise((LPUNKNOWN)(IPropertyNotifySink*)this, &amp;m_dwCookie); <br> <br>Error: <br>if (pCPC) pCPC-&gt;Release(); <br> <br>return hr; <br>} <br> <br>// Clean up connection point <br>HRESULT CApp::Term() <br>{ <br>HRESULT hr = NOERROR; <br> <br>// Disconnect from property change notifications <br>if (SUCCEEDED(m_hrConnected)) <br>{ <br>// ASSERT(m_pCP); <br>hr = m_pCP-&gt;Unadvise(m_dwCookie); <br>} <br> <br>// Release the connection point <br>if (m_pCP)  <br>{ <br>m_pCP-&gt;Release(); <br>} <br> <br>return hr; <br>} <br> <br>// Load the specified document and start pumping messages <br>HRESULT CApp::Run() <br>{ <br>HRESULT hr; <br>MSG msg; <br> <br>switch(m_nScheme) <br>{ <br>case INTERNET_SCHEME_HTTP: <br>    case INTERNET_SCHEME_FTP: <br>    case INTERNET_SCHEME_GOPHER: <br>    case INTERNET_SCHEME_HTTPS: <br>    case INTERNET_SCHEME_FILE: <br>// load URL using IPersistMoniker <br>hr = LoadURLFromMoniker(); <br>break; <br>    case INTERNET_SCHEME_NEWS: <br>    case INTERNET_SCHEME_MAILTO: <br>    case INTERNET_SCHEME_SOCKS: <br>// we don't handle these <br>return E_FAIL; <br>break; <br>    //case INTERNET_SCHEME_DEFAULT: <br>    //case INTERNET_SCHEME_PARTIAL = -2, <br>    //case INTERNET_SCHEME_UNKNOWN = -1, <br>default: <br>// try loading URL using IPersistFile <br>hr = LoadURLFromFile(); <br>break; <br>} <br> <br>if (SUCCEEDED(hr) || E_PENDING == hr) <br>{ <br> <br>while (GetMessage(&amp;msg, NULL, 0, 0)) <br>{ <br>if (WM_USER_STARTWALKING == msg.message &amp;&amp; NULL == msg.hwnd) <br>{ <br>g_pApp-&gt;Walk(); <br>} <br>else <br>{ <br>DispatchMessage(&amp;msg); <br>} <br>} <br>} <br> <br>return hr; <br>} <br> <br>// Use an asynchronous Moniker to load the specified resource <br>HRESULT CApp::LoadURLFromMoniker() <br>{ <br>HRESULT hr; <br>OLECHAR  wszURL[MAX_PATH*sizeof(OLECHAR)]; <br>if (0 == MultiByteToWideChar(CP_ACP, 0, m_szURL, -1, wszURL, MAX_PATH*sizeof(OLECHAR))) <br>{ <br>return E_FAIL; <br>} <br> <br>// Ask the system for a URL Moniker <br>LPMONIKER pMk = NULL; <br>LPBINDCTX pBCtx = NULL; <br>LPPERSISTMONIKER pPMk = NULL; <br> <br>if (FAILED(hr = CreateURLMoniker(NULL, wszURL, &amp;pMk))) <br>{ <br>return hr; <br>} <br> <br>if (FAILED(hr = CreateBindCtx(0, &amp;pBCtx))) <br>{ <br>goto Error; <br>} <br> <br>// Use MSHTML moniker services to load the specified document <br>if (SUCCEEDED(hr = m_pMSHTML-&gt;QueryInterface(IID_IPersistMoniker, <br>(LPVOID*)&amp;pPMk))) <br>{ <br>// Call Load on the IPersistMoniker <br>// This may return immediately, but the document isn't loaded until <br>// MSHTML reports READYSTATE_COMPLETE. See the implementation of  <br>// IPropertyNotifySink::OnChanged above and see how the app waits <br>// for this state change before walking the document's object model. <br>TCHAR szBuff[MAX_PATH]; <br>wsprintf(szBuff, "Loading %s...\n", m_szURL); <br>ODS(szBuff); <br>cout &lt;&lt; szBuff; <br>hr = pPMk-&gt;Load(FALSE, pMk, pBCtx, STGM_READ); <br>} <br> <br>Error: <br>if (pMk) pMk-&gt;Release(); <br>if (pBCtx) pBCtx-&gt;Release(); <br>return hr; <br>} <br> <br>// A more traditional form of persistence.  <br>// MSHTML performs this asynchronously as well. <br>HRESULT CApp::LoadURLFromFile() <br>{ <br>HRESULT hr; <br>OLECHAR  wszURL[MAX_PATH*sizeof(OLECHAR)]; <br>if (0 == MultiByteToWideChar(CP_ACP, 0, m_szURL, -1, wszURL, MAX_PATH*sizeof(OLECHAR))) <br>{ <br>return E_FAIL; <br>} <br> <br>LPPERSISTFILE  pPF; <br>// MSHTML supports file persistence for ordinary files. <br>    if ( SUCCEEDED(hr = m_pMSHTML-&gt;QueryInterface(IID_IPersistFile, (LPVOID*) &amp;pPF))) <br>{ <br>TCHAR szBuff[MAX_PATH]; <br>wsprintf(szBuff, "Loading %s...\n", m_szURL); <br>ODS(szBuff); <br>cout &lt;&lt; szBuff; <br>hr = pPF-&gt;Load(wszURL, 0); <br>pPF-&gt;Release(); <br>} <br> <br>return hr; <br>} <br> <br>// Walk the object model. <br>HRESULT CApp::Walk() <br>{ <br>HRESULT hr; <br>IHTMLElementCollection* pColl = NULL; <br> <br>assert(m_pMSHTML); <br>if (!m_pMSHTML) <br>{ <br>return E_UNEXPECTED; <br>} <br> <br>if (READYSTATE_COMPLETE != m_lReadyState) <br>{ <br>ODS("Shouldn't get here 'til MSHTML changes readyState to READYSTATE_COMPLETE\n"); <br>DebugBreak(); <br>return E_UNEXPECTED; <br>} <br> <br>// retrieve a reference to the ALL collection <br>if (SUCCEEDED(hr = m_pMSHTML-&gt;get_all( &amp;pColl ))) <br>{ <br>long cElems; <br> <br>assert(pColl); <br> <br>// retrieve the count of elements in the collection <br>if (SUCCEEDED(hr = pColl-&gt;get_length( &amp;cElems ))) <br>{ <br>// for each element retrieve properties such as TAGNAME and HREF <br>for ( int i=0; i&lt;cElems; i++ ) <br>{ <br>VARIANT vIndex; <br>vIndex.vt = VT_UINT; <br>vIndex.lVal = i; <br>VARIANT var2 = { 0 }; <br>LPDISPATCH pDisp;  <br> <br>if (SUCCEEDED(hr = pColl-&gt;item( vIndex, var2, &amp;pDisp ))) <br>{ <br>IHTMLElement* pElem = NULL; <br>if (SUCCEEDED(hr = pDisp-&gt;QueryInterface( IID_IHTMLElement, (LPVOID*)&amp;pElem ))) <br>{ <br>_bstr_t bstrTag; <br>BSTR bstr; <br> <br>assert(pElem); <br> <br>hr = pElem-&gt;get_tagName(&amp;bstr); <br>if (bstr) <br>{ <br>bstrTag = bstr; <br>SysFreeString(bstr); <br>} <br> <br>// if the element is an &lt;IMG&gt; get its SRC attribute <br>IHTMLImgElement* pImage = NULL; <br>if (SUCCEEDED(hr = pDisp-&gt;QueryInterface( IID_IHTMLImgElement, (LPVOID*)&amp;pImage ))) <br>{ <br>assert(pImage); <br> <br>pImage-&gt;get_src(&amp;bstr); <br>if (bstr) <br>{ <br>bstrTag += " - "; <br>bstrTag += bstr; <br>SysFreeString(bstr); <br>} <br>pImage-&gt;Release(); <br>} <br> <br>TCHAR szTag[2048]; <br>LPOLESTR wszTag = bstrTag; UINT uLen = bstrTag.length(); <br>int iBytes = WideCharToMultiByte(CP_ACP, 0, <br>wszTag, bstrTag.length(), <br>szTag, 2048, NULL, NULL); <br> <br>if (iBytes &lt; 2047) <br>{ <br>szTag[uLen] = '\0'; <br>} <br>else <br>{ <br>szTag[2047] = '\0'; <br>} <br>cout &lt;&lt; szTag &lt;&lt; endl; <br>ODS(szTag); <br>ODS("\n"); <br> <br>pElem-&gt;Release(); <br>} // QI(IHTMLElement) <br>pDisp-&gt;Release(); <br>} // item <br>} // for <br>} // get_length <br> <br>pColl-&gt;Release(); <br>} // get_all <br> <br>// We're done so post ourselves a quit to terminate the message pump. <br>PostQuitMessage(0); <br> <br>return hr; <br>} <br> <br>// MSHTML Queries for the IDispatch interface of the host through the IOleClientSite <br>// interface that MSHTML is passed through its implementation of IOleObject::SetClientSite() <br>STDMETHODIMP CApp::Invoke(DISPID dispIdMember, <br>            REFIID riid, <br>            LCID lcid, <br>            WORD wFlags, <br>            DISPPARAMS __RPC_FAR *pDispParams, <br>            VARIANT __RPC_FAR *pVarResult, <br>            EXCEPINFO __RPC_FAR *pExcepInfo, <br>            UINT __RPC_FAR *puArgErr) <br>{ <br>if (!pVarResult) <br>{ <br>return E_POINTER; <br>} <br> <br>PrintDISPID(dispIdMember); <br> <br>switch(dispIdMember) <br>{ <br>case DISPID_AMBIENT_DLCONTROL:  <br>// respond to this ambient to indicate that we only want to <br>// download the page, but we don't want to run scripts, <br>// Java applets, or ActiveX controls <br>V_VT(pVarResult) = VT_I4; <br>V_I4(pVarResult) =  DLCTL_DOWNLOADONLY |  <br>DLCTL_NO_SCRIPTS |  <br>DLCTL_NO_JAVA | <br>DLCTL_NO_DLACTIVEXCTLS | <br>DLCTL_NO_RUNACTIVEXCTLS; <br>break; <br>default: <br>return DISP_E_MEMBERNOTFOUND; <br>} <br> <br>return NOERROR; <br>} <br> <br>// Diagnostic helper to discover what ambient properties MSHTML <br>// asks of the host <br>void PrintDISPID(DISPID dispidMember) <br>{ <br>#define ALEN(x) (sizeof(x)/(sizeof(x[0]))) <br> <br>typedef struct { <br>DISPID dispid; <br>LPCTSTR szDesc; <br>} DISPIDDESC; <br> <br>static DISPIDDESC aDISPIDS[] = { <br>{DISPID_AMBIENT_DLCONTROL, _T("DISPID_AMBIENT_DLCONTROL")}, // (-5512) <br>{DISPID_AMBIENT_USERAGENT, _T("DISPID_AMBIENT_USERAGENT")}, // (-5513) <br>{DISPID_AMBIENT_BACKCOLOR, _T("DISPID_AMBIENT_BACKCOLOR")},  //        (-701) <br>{DISPID_AMBIENT_DISPLAYNAME, _T("DISPID_AMBIENT_DISPLAYNAME")},  //      (-702) <br>{DISPID_AMBIENT_FONT, _T("DISPID_AMBIENT_FONT")},  //             (-703) <br>{DISPID_AMBIENT_FORECOLOR, _T("DISPID_AMBIENT_FORECOLOR")},  //        (-704) <br>{DISPID_AMBIENT_LOCALEID, _T("DISPID_AMBIENT_LOCALEID")},  //         (-705) <br>{DISPID_AMBIENT_MESSAGEREFLECT, _T("DISPID_AMBIENT_MESSAGEREFLECT")},  //   (-706) <br>{DISPID_AMBIENT_SCALEUNITS, _T("DISPID_AMBIENT_SCALEUNITS")},  //       (-707) <br>{DISPID_AMBIENT_TEXTALIGN, _T("DISPID_AMBIENT_TEXTALIGN")},  //        (-708) <br>{DISPID_AMBIENT_USERMODE, _T("DISPID_AMBIENT_USERMODE")},  //         (-709) <br>{DISPID_AMBIENT_UIDEAD, _T("DISPID_AMBIENT_UIDEAD")},  //           (-710) <br>{DISPID_AMBIENT_SHOWGRABHANDLES, _T("DISPID_AMBIENT_SHOWGRABHANDLES")},  //  (-711) <br>{DISPID_AMBIENT_SHOWHATCHING, _T("DISPID_AMBIENT_SHOWHATCHING")},  //     (-712) <br>{DISPID_AMBIENT_DISPLAYASDEFAULT, _T("DISPID_AMBIENT_DISPLAYASDEFAULT")},  // (-713) <br>{DISPID_AMBIENT_SUPPORTSMNEMONICS, _T("DISPID_AMBIENT_SUPPORTSMNEMONICS")},  // (-714) <br>{DISPID_AMBIENT_AUTOCLIP, _T("DISPID_AMBIENT_AUTOCLIP")},  //         (-715) <br>{DISPID_AMBIENT_APPEARANCE, _T("DISPID_AMBIENT_APPEARANCE")},  //       (-716) <br>{DISPID_AMBIENT_PALETTE, _T("DISPID_AMBIENT_PALETTE")},  //          (-726) <br>{DISPID_AMBIENT_TRANSFERPRIORITY, _T("DISPID_AMBIENT_TRANSFERPRIORITY")},  // (-728) <br>{DISPID_AMBIENT_RIGHTTOLEFT, _T("DISPID_AMBIENT_RIGHTTOLEFT")},  //      (-732) <br>{DISPID_AMBIENT_TOPTOBOTTOM, _T("DISPID_AMBIENT_TOPTOBOTTOM")}  //      (-733) <br>}; <br> <br>TCHAR szBuff[255]; <br> <br>for (int i = 0; i &lt; ALEN(aDISPIDS); i++) <br>{ <br>if (dispidMember == aDISPIDS[i].dispid) <br>{ <br>wsprintf(szBuff, "MSHTML requesting '%s'\n", aDISPIDS[i].szDesc); <br>ODS(szBuff); <br>return; <br>} <br>} <br> <br>wsprintf(szBuff, "MSHTML requesting DISPID '%d'\n", dispidMember); <br>ODS(szBuff); <br>} <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
