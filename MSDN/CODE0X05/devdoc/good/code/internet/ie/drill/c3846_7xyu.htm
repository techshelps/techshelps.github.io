<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>README.TXT</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3846"></a>README.TXT</h2>
<pre><code>====================================================== <br>Notes for "Drill" Samples <br>====================================================== <br> <br>There are two Drill samples, both do the same thing, however one is written using MFC and the other is written using Visual Basic. <br> <br>OVERVIEW <br>======== <br>The drill samples demonstrate hosting the WebBrowser control as part of another application. The buttons and address input are supplied by the hosting application and commands are sent to the WebBrowser control on the form. Entering a URL in the address field on the form will result in the WebBrowser control navigating to that page. <br> <br>Additionally the Drill samples show how a hosting application can "drill" into the WebBrowser control and investigate the loaded HTML document. In this case the host walks the ALL collection of the document object of the loaded html page using Dynamic HTML and populate a list box with each element encountered. <br> <br>NOTES on Driller <br>================ <br>The sample is an MFC based ActiveX control container and is a dialog based application with control container support enabled. <br> <br>The sample is a VC4.2b sample. It has not been tested with VC5 although it will most probably work. <br> <br>The two functions of interest are OnBtnGo() and <br>OnBtnDrill(). Both are in the file drillerDlg.cpp. <br> <br>OnBtnGo: <br>The function uses the Navigate2 method of the IWebBrowser2 <br>interface to navigate to the URL. <br> <br>OnBtnDrill() <br>This function shows how to walk the object model for <br>an HTML page. It does the equivalent of the following <br>in script: <br> <br> <br>cnt = document.all.length; <br>for (i=0;i&lt;cnt;i++) <br>{ <br> elem = document.all.item(i); <br> output(elem.tagName); <br> if (elem.tagName == "IMG") <br>    output(elem.href); <br>} <br> <br>The code in C++ wil be as follows: <br> <br>   IDispatch* pDisp = pBrowser-&gt;GetDocument(); <br> <br>The document property gives access to the object model <br>for the HTML document. From here on one can walk <br>down the dynamic HTML object model. <br> <br>For example, getting the IHTMLDocument2 interface <br>is equivalent to getting to the document object <br>in the object model. The document object exposes <br>the HTML docuement through a number of collections <br>and properties. <br> <br>All the interfaces for the object model are defined <br>in MSHTML.h which is included the INetSDK\include <br>directory. <br> <br>Some of the methods of the IHTMLDocument2 interface are: <br> <br>         get_all( IHTMLElementCollection   *p)  <br>         get_images( IHTMLElementCollection   *p)  <br>         get_applets( IHTMLElementCollection   *p)  <br>         get_links( IHTMLElementCollection   *p)  <br>         get_forms( IHTMLElementCollection   *p)  <br>         get_anchors( IHTMLElementCollection   *p)  <br>         get_scripts( IHTMLElementCollection   *p)  <br>         get_frames( IHTMLFramesCollection2   *p)  <br>         get_embeds( IHTMLElementCollection   *p)  <br>         get_plugins( IHTMLElementCollection   *p)  <br>        <br>Most of these methods returns a collection which corresponds to the <br>collection <br>in the object model. For example get_all returns the all collection, <br>which is <br>a collection of all the elements in the document. Similarly get_images <br>returns <br>the images collection, get_links the links collection, get_forms the <br>forms <br>collection and so on. <br> <br>IDispatch* pDisp = pBrowser-&gt;GetDocument(); <br> <br>if (pDisp != NULL ) <br>{ <br>IHTMLDocument2* pHTMLDocument2; <br>HRESULT hr; <br>hr = pDisp-&gt;QueryInterface( IID_IHTMLDocument2, <br>(void**)&amp;pHTMLDocument2 ); <br>if (hr == S_OK) <br>{ <br> <br>IHTMLElementCollection* pColl; <br>hr = pHTMLDocument2-&gt;get_all( &amp;pColl ); <br> <br>Using get_all we get the all collection of the object model. <br>This is the same as doing allColl = document.all from within <br>script. <br> <br>Below is how to walk the all collection. The same <br>technique can be used to walk any collection. The idea <br>is to get the length using get_length and then <br>interate through each element. <br> <br>if (hr == S_OK) <br>{ <br>LONG celem; <br>hr = pColl-&gt;get_length( &amp;celem ); <br> <br>if ( hr == S_OK ) <br>{ <br>for ( int i=0; i&lt; celem; i++ ) <br>{ <br>VARIANT varIndex; <br>varIndex.vt = VT_UINT; <br>varIndex.lVal = i; <br>VARIANT var2; <br>VariantInit( &amp;var2 ); <br>IDispatch* pDisp; <br> <br>hr = pColl-&gt;item( varIndex, <br>var2, &amp;pDisp ); <br> <br>The item method of the collection gives the element's dispatch <br>interface. Each element implements the IHTMLElement interface which <br>can be used to access the elements methods and properties. <br> <br>Again look at the IHTMLElement interface in MSHTML.h for the <br>different methods that is has. There is a corresponding method <br>for every element property in the object model. So for example <br>if you want to get the tagName of the element use the get_tagName <br>method. The tagName is a the HTML tag of the element. For example <br>the tagName of the following line of HTML code: <br>&lt;H1&gt; This is Heading 1 &lt;/H1&gt; <br>will be H1. <br> <br>if ( hr == S_OK ) <br>{ <br> <br>IHTMLElement* pElem; <br> <br>hr = <br>pDisp-&gt;QueryInterface( IID_IHTMLElement, (void **)&amp;pElem ); <br> <br>if ( hr == S_OK ) <br>{ <br> <br>BSTR bstr; <br>hr = <br>pElem-&gt;get_tagName(&amp;bstr); <br>CString strTag = <br>bstr; <br> <br> <br>An element could implement other interfaces depending on the <br>type of the element. For example if the element is an <br>image it will implement the IHTMLImgElement interface. The <br>IHTMLImgElement interface gives more information about <br>the IMG element. In this sample we use the IHTMLImgElement <br>to get the URL for the image. <br> <br>IHTMLImgElement* <br>pImgElem; <br>hr = <br>pDisp-&gt;QueryInterface( IID_IHTMLImgElement, (void **)&amp;pImgElem ); <br>if ( hr == S_OK <br>) <br>{ <br> <br>pImgElem-&gt;get_href(&amp;bstr); <br>strTag <br>+= " - "; <br>strTag <br>+= bstr; <br> <br>pImgElem-&gt;Release(); <br>} <br> <br> <br>m_listTags.AddString( strTag ); <br> <br> <br>pElem-&gt;Release(); <br>} <br>pDisp-&gt;Release(); <br>} <br>} <br>} <br> <br>pColl-&gt;Release(); <br>} <br>pHTMLDocument2-&gt;Release(); <br>} <br>pDisp-&gt;Release(); <br>} <br> <br> <br> <br> <br>Notes on DrillVB <br>================ <br>The DrillVB sample is written using Visual Basic 4.0, and will also run in VB5.0. It populates a listbox with the elements that it finds on the all collection which is obtained using <br>   Set allCol = WebBrowser1.Document.All <br>  <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
