<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>HEADDUMP.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context4008"></a>HEADDUMP.CPP</h2>
<pre><code><br>//=--------------------------------------------------------------------------= <br>//  (C) Copyright 1996-1997 Microsoft Corporation. All Rights Reserved. <br>//=--------------------------------------------------------------------------= <br>/**************************************************************************** <br>* <br>* HeadDump: requests the default HTML document from the server and prints  <br>*along with HTTP headers. <br>*Microsoft Corporation (C). Leon Braginski. <br>* <br>* PURPOSE:  <br>* This sample demonstrates how to create and submit HTTP  <br>* request. Sample requests the default HTML document from the <br>* server and then display it along with the HTTP transaction headers. <br>* This sample also allows to access password protected pages. It  <br>* checks for HTTP server response code and it is "401 Access Denied" <br>* it asks password and user name and then resubmit request. <br> <br>* <br>* This sample features:  <br>*  - SSL/PCT support <br>*  - NTLM Authentication (when IE 3.0 or above is installed) <br>*  - Basic Authentication <br>*  - Generating stadart user name/password UI to get user credentials. <br>*  - Getting user name and passwors without UI <br>*  - getting any document of any MIME type <br>*  - translation of Internet error codes to the extended error messeges <br>*  - ability to save remote object to a local file (when no local file <br>* specify output goes to STDOUT). <br>* <br>* Usage: <br>*   headdump.exe -h host [-o object] [-p proxy] [-u] [-s] [-?] [-f file] <br>*-h host is a HTTP server such as www.server.com  <br>*-p proxy is optional proxy, in form: http://proxy:80 <br>*-o object is optional document to GET, in form: /foobar.htm <br>*-u use this flag to bring user name and password UI (optional) <br>*-f save remote object as local file  (optional) <br>*-? get help <br>*-s use SSL (optional) <br>* <br>* Samples: <br>* To get help on command line parameters: <br>*C:&gt; headdump.exe -? <br>* <br>* Note that HeadDump can also invoke ISAPI dll or CGI like this: <br>* C:&gt; headdump.exe -s www.server.name -o /scripts/myisapi.dll  <br>* <br>* Since sample generates large output, you may want to pipe to more: <br>* C:&gt; headdump.exe -s www.server.name -o /scripts/myisapi.dll  | more <br>* <br>* To save remote HTML object as file: <br>*C:&gt; headdump.exe -s www.server.name -o /exe_files/foo.exe -f foo.exe <br>* <br>* <br>*  <br>****************************************************************************/ <br> <br> <br> <br>#include &lt;windows.h&gt; <br>#include &lt;wininet.h&gt; <br>#include &lt;iostream.h&gt; <br> <br>BOOL ErrorOut  ( DWORD dError, TCHAR * szCallingFunc); <br>BOOL ParseParams (int argc , CHAR ** argv, CHAR* szServer, CHAR* szObject,  <br>                  CHAR* szProxy, CHAR * szFile, BOOL&amp; bUi, BOOL&amp; bSSL); <br>void Usage (CHAR *szName);                   <br> <br> <br>int main (int argc, char *argv[]) <br>{ <br> HINTERNET hOpen, hConnect, hReq; <br> DWORD  dwSize, dwCode; <br> DWORD  dwFlags = INTERNET_FLAG_RELOAD |  <br>                  INTERNET_FLAG_NO_CACHE_WRITE | <br>                  INTERNET_FLAG_KEEP_CONNECTION; <br>                   <br> CHAR *lpBuffer, szData[51]; <br> CHAR szServer[256], szObject [256], szProxy [256], szFile [256]; <br> BOOL bSSL, bUi; <br> HANDLE hFile = NULL; <br> INTERNET_PORT dwPort; <br> TCHAR szAccept[] = "*/*"; <br> LPSTR AcceptTypes[2]={0};  <br> <br>  <br> AcceptTypes[0]=szAccept; <br> <br> <br> <br>if (!ParseParams ( argc , argv, szServer, szObject,  <br>                  szProxy,  szFile, bUi, bSSL)) <br>    return (FALSE); <br> <br>if (szFile [0]) <br>{ <br>// Open local file <br>SECURITY_ATTRIBUTES sa = {sizeof(SECURITY_ATTRIBUTES), NULL, FALSE}; <br>if  ( !(hFile = CreateFile (szFile,  <br>                        GENERIC_WRITE,  <br>FILE_SHARE_READ,  <br>&amp;sa,  <br>CREATE_ALWAYS,  <br>FILE_ATTRIBUTE_NORMAL, NULL) )) <br>{ <br>cerr &lt;&lt; "Can't open file: " &lt;&lt; szFile &lt;&lt; " Error: " &lt;&lt; GetLastError() &lt;&lt; endl; <br>return 0; <br>} <br>} <br> <br> <br> <br>if (szProxy [0] == NULL) <br>{   <br>    // No proxy was specified <br>    if ( !(hOpen = InternetOpen ( "HeadDump",  LOCAL_INTERNET_ACCESS , NULL, 0, 0) ) ) <br>    { <br>        ErrorOut ( GetLastError(), "InternetOpen"); <br>        return 0; <br>    } <br> } <br> else <br> { <br>    // Use proxy server <br>   if ( !(hOpen = InternetOpen ( "HeadDump",  CERN_PROXY_INTERNET_ACCESS, szProxy, NULL, 0) ) ) <br>   { <br>        ErrorOut ( GetLastError(), "InternetOpen"); <br>       return 0; <br>   } <br>  } <br>         <br> <br>if  (bSSL) <br>{ <br>    dwPort = INTERNET_DEFAULT_HTTPS_PORT; <br>    dwFlags |= INTERNET_FLAG_SECURE |  <br>               INTERNET_FLAG_IGNORE_CERT_CN_INVALID | <br>               INTERNET_FLAG_IGNORE_CERT_DATE_INVALID  ; <br>} <br>else <br>    dwPort = INTERNET_INVALID_PORT_NUMBER; <br>     <br>         <br>if ( !(hConnect = InternetConnect ( hOpen, szServer , dwPort, "",  "", INTERNET_SERVICE_HTTP, 0  , 0) ) ) <br>{ <br>    ErrorOut (GetLastError(), "InternetConnect"); <br>    return 0; <br>} <br> <br>if ( !(hReq = HttpOpenRequest (hConnect, "GET", szObject, HTTP_VERSION, "",  <br>                                (LPCTSTR*) AcceptTypes, dwFlags ,0 ))) <br>{ <br>    ErrorOut (GetLastError(), "HttpOpenRequest"); <br>    return 0; <br>} <br> <br> <br>again: <br>if (!HttpSendRequest (hReq, NULL, 0, NULL, 0) ) <br>{ <br>    ErrorOut (GetLastError(), "HttpSend"); <br>    return 0; <br>} <br> <br>dwSize = sizeof (DWORD) ;   <br>if ( !HttpQueryInfo (hReq, HTTP_QUERY_STATUS_CODE | HTTP_QUERY_FLAG_NUMBER, &amp;dwCode, &amp;dwSize, NULL)) <br>{ <br>ErrorOut (GetLastError(), "HttpQueryInfo"); <br>return FALSE; <br>} <br> <br>if ( dwCode == HTTP_STATUS_DENIED || dwCode == HTTP_STATUS_PROXY_AUTH_REQ) <br>{   <br> <br>    // We have to read all outstanding data on the Internet handle <br>    // before we can resubmit request. Just discard the data. <br>    do <br>{ <br>InternetReadFile (hReq, (LPVOID)szData, 50, &amp;dwSize); <br>} <br>while (dwSize != 0); <br> <br>    if (!bUi) <br>    { <br>        // This is a secure page. <br>        cerr &lt;&lt; "This page is password protected. " &lt;&lt; endl; <br>    CHAR szUser[50]=""; <br>    CHAR szPass[50]=""; <br> <br>    cerr &lt;&lt; "User: "; <br>    cin  &gt;&gt; szUser; <br>    cerr &lt;&lt; "Pass: "; <br>    cin  &gt;&gt; szPass; <br>        if ( !InternetSetOption (hConnect, INTERNET_OPTION_USERNAME, (LPVOID) szUser, lstrlen (szUser) )) <br>        { <br>            cerr &lt;&lt; "InternetSetOptionFailed: " &lt;&lt; GetLastError() &lt;&lt; endl; <br>            return FALSE; <br>        } <br>     <br>        if ( !InternetSetOption (hConnect, INTERNET_OPTION_PASSWORD, (LPVOID) szPass, lstrlen (szPass) )) <br>        { <br>            cerr &lt;&lt; "InternetSetOptionFailed: " &lt;&lt; GetLastError() &lt;&lt; endl; <br>            return FALSE; <br>        } <br>        goto again;     <br>    } <br>    else <br>    { <br>        if ( InternetErrorDlg (GetDesktopWindow(), <br>                               hReq,  <br>                               ERROR_INTERNET_INCORRECT_PASSWORD, <br>                               FLAGS_ERROR_UI_FILTER_FOR_ERRORS | <br>                               FLAGS_ERROR_UI_FLAGS_GENERATE_DATA | <br>                               FLAGS_ERROR_UI_FLAGS_CHANGE_OPTIONS, <br>                               NULL) == ERROR_INTERNET_FORCE_RETRY) <br>            goto again; <br>    } <br> <br>} <br> <br>                                                                           <br>// First time we will find out the size of the headers. <br>HttpQueryInfo (hReq,HTTP_QUERY_RAW_HEADERS_CRLF,  NULL, &amp;dwSize, NULL); <br>lpBuffer =  new char [dwSize + 1 ]; <br> <br>// Now we call HttpQueryInfo again to get the headers. <br>if (!HttpQueryInfo (hReq,HTTP_QUERY_RAW_HEADERS_CRLF, (LPVOID) lpBuffer, <br>    &amp;dwSize, NULL)) <br>{ <br>ErrorOut (GetLastError(), "HttpQueryInfo"); <br>return FALSE; <br>} <br>*(lpBuffer + dwSize) = '\0'; <br>cout &lt;&lt; lpBuffer &lt;&lt; endl; <br> <br> <br>do <br>{ <br>if (!InternetReadFile (hReq, (LPVOID)szData, 50, &amp;dwSize) ) <br>{ <br> ErrorOut (GetLastError (), "InternetReadFile"); <br>return FALSE; <br>} <br>if (dwSize != 0)  <br>{ <br>if (!hFile) <br>{ <br>// dump text to the screen <br>szData[dwSize] = '\0'; <br>cout &lt;&lt; szData; <br>} <br>else <br>{ <br>DWORD dwWritten; <br>if (!WriteFile(hFile,  szData, dwSize,  &amp;dwWritten,  NULL)) <br>            { <br>              CloseHandle (hFile); <br>              cerr &lt;&lt; "WriteFile to " &lt;&lt; szFile &lt;&lt; " failed: " &lt;&lt; <br>    GetLastError () &lt;&lt; endl; <br>              return FALSE; <br>            }  <br>} <br>} <br>} <br>while (dwSize); <br> <br> <br>cout &lt;&lt; endl; <br> <br>if (!InternetCloseHandle (hReq) ) <br>{ <br>    ErrorOut (GetLastError (), "CloseHandle on hReq"); <br>    return FALSE; <br>} <br>if (!InternetCloseHandle (hConnect) ) <br>{ <br>    ErrorOut (GetLastError (), "CloseHandle on hConnect"); <br>    return FALSE; <br>} <br>if (!InternetCloseHandle (hOpen) ) <br>{ <br>    ErrorOut (GetLastError (), "CloseHandle on hOpen"); <br>    return FALSE; <br>} <br> <br> <br>delete [] lpBuffer; <br> <br>if (hFile) <br>{ <br>FlushFileBuffers (hFile); <br>CloseHandle (hFile); <br>} <br>return TRUE; <br>} <br> <br>/**************************************************************************** <br>* <br>*    FUNCTION: ErrorOut <br>* <br>*    PURPOSE: This function is used to get extended Internet error. <br>* <br>*    COMMENTS:  Function returns TRUE on success and FALSE on failure. <br>* <br>****************************************************************************/ <br> <br>BOOL ErrorOut ( DWORD dError, TCHAR * szCallFunc) <br>{ <br>    TCHAR szTemp[100] = "", *szBuffer=NULL, *szBufferFinal = NULL; <br>    char strName[256]=""; <br>    DWORD  dwIntError , dwLength = 0;  <br>     <br> <br>    FormatMessage(FORMAT_MESSAGE_FROM_HMODULE, <br>               GetModuleHandle("wininet.dll"),dError,0, <br>                  (LPSTR)strName,256,NULL); <br>    wsprintf (szTemp,  "%s error code: %d\nMessage: %s\n",  <br>    szCallFunc, dError, strName); <br>     <br>if (dError == ERROR_INTERNET_EXTENDED_ERROR) <br>{ <br>InternetGetLastResponseInfo (&amp;dwIntError, NULL, &amp;dwLength); <br>if (dwLength) <br>{ <br>if ( !(szBuffer = (TCHAR *) LocalAlloc ( LPTR,  dwLength) ) ) <br>{ <br>lstrcat (szTemp, TEXT ( "Unable to allocate memory to display Internet error code. Error code: ") ); <br>lstrcat (szTemp, TEXT (_itoa (GetLastError(), szBuffer, 10)  ) ); <br>lstrcat (szTemp, TEXT ("\n") ); <br>cerr &lt;&lt; szTemp &lt;&lt; endl; <br>return FALSE; <br>} <br>if (!InternetGetLastResponseInfo (&amp;dwIntError, (LPTSTR) szBuffer, &amp;dwLength)) <br>{ <br>lstrcat (szTemp, TEXT ( "Unable to get Internet error. Error code: ") ); <br>lstrcat (szTemp, TEXT (_itoa (GetLastError(), szBuffer, 10)  ) ); <br>lstrcat (szTemp, TEXT ("\n") ); <br>cerr &lt;&lt; szTemp &lt;&lt; endl; <br>return FALSE; <br>} <br>if ( !(szBufferFinal = (TCHAR *) LocalAlloc ( LPTR,  (strlen (szBuffer) +strlen (szTemp) + 1)  ) )  ) <br>{ <br>lstrcat (szTemp, TEXT ( "Unable to allocate memory. Error code: ") ); <br>lstrcat (szTemp, TEXT (_itoa (GetLastError(), szBuffer, 10)  ) ); <br>lstrcat (szTemp, TEXT ("\n") ); <br>cerr &lt;&lt; szTemp &lt;&lt; endl; <br>return FALSE; <br>} <br>lstrcpy (szBufferFinal, szTemp); <br>lstrcat (szBufferFinal, szBuffer); <br>LocalFree (szBuffer); <br>cerr &lt;&lt;  szBufferFinal  &lt;&lt; endl; <br>LocalFree (szBufferFinal); <br>} <br>} <br>else <br>        cerr &lt;&lt; szTemp &lt;&lt; endl; <br>    return TRUE; <br>} <br>BOOL ParseParams (int argc , CHAR ** argv, CHAR* szServer, CHAR* szObject,  <br>                  CHAR* szProxy, CHAR * szFile, BOOL&amp; bUi, BOOL&amp; bSSL) <br>{ <br>    int i = 1; <br>    BOOL bServer = FALSE; <br>     <br>    szProxy[0]  = NULL, bUi = FALSE, bSSL = FALSE, szFile[0]  = NULL; <br>    lstrcpy (szObject, ""); <br>     <br>    while (i &lt; argc) <br>    { <br>       if ( *argv[i] != '-') <br>       { <br>           Usage (argv[0]); <br>           return FALSE; <br>       } <br>       switch (argv[i][1]) <br>       { <br>           case 'H': <br>           case 'h': <br>              lstrcpy (szServer,argv[i+1]); <br>              i += 2; <br>              bServer = TRUE; <br>           break; <br>           case 'o': <br>           case 'O': <br>              lstrcpy (szObject, argv[i+1]); <br>              i += 2; <br>           break; <br>            <br>           case 'p': <br>           case 'P': <br>              lstrcpy (szProxy, argv[i+1]); <br>              i += 2;   <br>           break;     <br>            <br>           case 'u': <br>           case 'U': <br>              bUi = TRUE; <br>              i++;   <br>           break;  <br>            <br>           case 's': <br>           case 'S': <br>              bSSL = TRUE; <br>              i++;   <br>           break;  <br> <br>           case 'f': <br>           case 'F': <br>  lstrcpy (szFile, argv[i+1]); <br>              i += 2;  <br>           break;  <br>    <br>   case '?': <br>   Usage (argv[0]); <br>   return FALSE; <br>   break; <br>           default: <br>               cerr &lt;&lt; "Invalid command line argument: "&lt;&lt; argv[i] &lt;&lt; endl; <br>               Usage (argv[0]); <br>               return FALSE; <br>        } <br>    } <br>    if ( bServer ) <br>        return TRUE; <br>    else <br>    { <br>        Usage(argv[0]); <br>        return FALSE; <br>    } <br>} <br> <br>                 <br> <br>void Usage (CHAR *szName) <br>{ <br>    cerr &lt;&lt; "Usage: " &lt;&lt; szName &lt;&lt;" -h host [-o object] [-p proxy] [-u] [-s] [-?] [-f file]" &lt;&lt; endl; <br>    cerr &lt;&lt; "\t-h host is a HTTP server such as www.server.com" &lt;&lt; endl; <br>    cerr &lt;&lt; "\t-p proxy is optional proxy in form: http://proxy:80" &lt;&lt; endl; <br>    cerr &lt;&lt; "\t-o object is optional document to GET in form: /foobar.htm" &lt;&lt; endl; <br>    cerr &lt;&lt; "\t-u use this flag to bring user name and password UI " &lt;&lt; endl; <br>cerr &lt;&lt; "\t-f save remote object as local file " &lt;&lt; endl; <br>cerr &lt;&lt; "\t-? get help " &lt;&lt; endl; <br>    cerr &lt;&lt; "\t-s use SSL " &lt;&lt; endl; <br>}     <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
