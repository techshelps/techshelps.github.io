<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>INETALL.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context4010"></a>INETALL.CPP</h2>
<pre><code>/////////////////////////////////////////////////////// <br>/* <br> *  inetcpp.cpp <br> * <br> *  Written by Wei Hua <br> *  of Microsoft Developer Support <br> * <br> *  Functions implemented in inetall.cpp <br> * <br> *  MyAllocMem()         - memory allocation helper function <br> *  MyFreeMem()          - free memory allocated by MyAllocMem <br> *  CMyItemArray::CMyItemArray() <br> *                       - CMyItemArray constructor <br> *  CMyItemArray::~CMyItemArray() <br> *                       - CMyItemArray destructor <br> *  CMyItemArray::Add()  - Add an item to the array <br> *  CMyItemArray::RemoveAll() <br> *                       - Remove all items in the array <br> *  CMyItemArray::GetAt()- Get an item given an index <br> *  CMyItemArray::GetSize() <br> *                       - Get the size of the array <br> *  WinMain()           - WinMain, display our main dialog box <br> *  Dlg_Proc()           - Message Proc for the main dialog box <br> *  Dlg_OnInitDialog()   - WM_INITDIALOG handler for the main dialog box <br> *  Dlg_OnCommand()      - WM_COMMAND handler for the main dialog box <br> *  Dlg_OnDestroy()      - WM_DESTROY handler for the main dialog box <br> *  BOOL UpdateUI()      - Exchange data between UI and member variables <br> *  FillFtpOrFileObjArray() <br> *                       - Enumerate a FTP or FILE URL, and populate a CMyItemArray <br> *  FillTreeControl()    - Draw tree structure of a FTP or FILE URL in Treeview Ctrl <br> *  Copyright (C) 1997 Microsoft Corporation. All rights reserved <br> * <br> */ <br>////////////////////////////////////////////////////// <br>#include &lt;windows.h&gt; <br> <br>#include &lt;windowsx.h&gt;  <br>//we use message crackers to make code easier to read <br> <br>#include &lt;commctrl.h&gt; <br>#include &lt;tchar.h&gt; <br>#include &lt;string.h&gt; <br>#include &lt;wininet.h&gt; <br>#include "inetall.h"  <br> <br>LPVOID <br>MyAllocMem( <br>    DWORD cb) <br>{ <br>    return HeapAlloc(GetProcessHeap(),  <br>    HEAP_GENERATE_EXCEPTIONS | HEAP_ZERO_MEMORY, cb); <br>}  <br> <br>BOOL <br>MyFreeMem( <br>    LPVOID pMem) <br>{ <br>    return HeapFree(GetProcessHeap(), 0, pMem); <br>} <br> <br>////////////////////////////////////////////////////// <br>//CMyItemArray Implementation functions <br>CMyItemArray::CMyItemArray() <br>{ <br>m_nCount = 0; <br>m_pItemlist = NULL; <br>} <br> <br>CMyItemArray::~CMyItemArray() <br>{ <br>if (m_pItemlist) MyFreeMem(m_pItemlist); <br>} <br> <br>int CMyItemArray::Add(ItemAttrib&amp; item) <br>{ <br>if (m_nCount%10 == 0) <br>{ <br>//Allocating 10 ItemAttrib at a time <br>LPVOID pTemp = MyAllocMem((m_nCount+10) * sizeof (ItemAttrib)); <br>if (!pTemp) return -1;  <br>//The called function should check return value <br>CopyMemory (pTemp, m_pItemlist, m_nCount*sizeof(ItemAttrib)); <br>MyFreeMem(m_pItemlist); <br>m_pItemlist = (PItemAttrib)pTemp; <br>} <br>lstrcpy(m_pItemlist[m_nCount].szObjectPath, item.szObjectPath); <br>m_pItemlist[m_nCount].nObjectType = item.nObjectType; <br>return m_nCount++; //return index of the newly added item. Increment count. <br>} <br> <br>void CMyItemArray::RemoveAll() <br>{ <br>if (m_pItemlist) MyFreeMem(m_pItemlist); <br>m_pItemlist = NULL; <br>m_nCount = 0; <br>} <br> <br>ItemAttrib CMyItemArray::GetAt(int nIndex) <br>{ <br>if (nIndex&gt;=0 &amp;&amp; nIndex &lt; m_nCount) <br>return m_pItemlist[nIndex]; <br>else <br>{ <br>ItemAttrib nullItem; <br>(nullItem.szObjectPath)[0]='\0'; <br>nullItem.nObjectType = -1; <br>return nullItem; <br>} <br>} <br> <br>int CMyItemArray::GetSize() <br>{ <br>return m_nCount; <br>} <br>//End of CMyItemArray Implementation <br>////////////////////////////////////////////////////// <br> <br>////////////////////////////////////////////////////// <br>//Declare Dialog callback function. <br>BOOL CALLBACK Dlg_Proc (HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam); <br> <br>//WinMain just displays a dialogbox <br>int APIENTRY WinMain (HINSTANCE hInstance,  <br>   HINSTANCE hPrevInstance, LPSTR lpszCmdLine, int nCmdShow) { <br> <br>g_hInst = hInstance; <br>InitCommonControls(); <br>if (DialogBox(hInstance, MAKEINTRESOURCE(IDD_INETALL_DIALOG),  <br>NULL, (DLGPROC)Dlg_Proc) == -1)  <br>MessageBox(NULL, "Failure in creating main dialog window", "Error", MB_OK); <br>return(0); <br>} <br> <br>BOOL Dlg_OnInitDialog (HWND hwnd, HWND hwndFocus,  <br>   LPARAM lParam)  <br>{ <br>BOOL bRet =  FALSE; <br> <br>g_Inet.m_dwSizeHtml = 1024; <br>g_Inet.m_phtml = (LPTSTR)MyAllocMem(g_Inet.m_dwSizeHtml); <br>if (!g_Inet.m_phtml) <br>{ <br>MessageBox(hwnd, "Memory Allocation Failure", "Error", MB_OK); <br>return bRet; <br>} <br> <br>bRet = (g_hDlg = hwnd) <br>&amp;&amp; (g_Inet.hCheckBoxCern = GetDlgItem(g_hDlg, IDC_CERN)) <br>&amp;&amp; (g_Inet.hwndUrl = GetDlgItem(g_hDlg, IDC_URL)) <br>&amp;&amp; (g_Inet.hwndPassword = GetDlgItem(g_hDlg, IDC_PASSWORD)) <br>&amp;&amp; (g_Inet.hwndUsername = GetDlgItem(g_hDlg, IDC_USERNAME)) <br>&amp;&amp; (g_Inet.hTreeViewCtrl = GetDlgItem(g_hDlg, IDC_TREE1)) <br>&amp;&amp; (g_Inet.hwndHTML = GetDlgItem(hwnd, IDC_HTML)); <br> <br>if (!bRet) return bRet; <br> <br>//Set inital service to HTTP, and select the option button. <br>g_Inet.m_dwServiceType = SERVICE_TYPE_HTTP; <br>ShowWindow(g_Inet.hCheckBoxCern, SW_HIDE); //CERN check box only shown when doing ftp <br>g_Inet.m_phtml[0]=g_Inet.m_url[0] = g_Inet.m_password[0] = g_Inet.m_username[0] = '\0'; <br> <br>g_Inet.m_cern = TRUE; <br> <br>//Send g_Inet to update UI <br>UpdateUI(FALSE); <br> <br>g_Inet.m_curItem = NULL; //No current selected item in tree control <br> <br>//Set up image list and tree control <br>g_Inet.hImgList = ImageList_Create(16, 15, 0, 3, 2); <br>HBITMAP hBmTemp; <br>for (int iCnt=IDB_BMERR; iCnt&lt;=IDB_BMFILE; iCnt++) <br>{ <br>hBmTemp = LoadBitmap(g_hInst, MAKEINTRESOURCE(iCnt)); <br>ImageList_Add(g_Inet.hImgList, hBmTemp, NULL); <br>} <br>TreeView_SetImageList(g_Inet.hTreeViewCtrl, g_Inet.hImgList, TVSIL_NORMAL); <br>TV_INSERTSTRUCT tvstruct; <br>tvstruct.hParent = NULL; <br>tvstruct.hInsertAfter = TVI_FIRST; <br>tvstruct.item.iImage = 0; <br>tvstruct.item.iSelectedImage = 0; <br>tvstruct.item.pszText = _T("Root"); <br>tvstruct.item.mask = TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_TEXT; <br>g_Inet.m_curItem= (HTREEITEM)SendMessage(g_Inet.hTreeViewCtrl, TVM_INSERTITEM,0, (LPARAM)(LPTV_INSERTSTRUCT)&amp;tvstruct); <br>g_Inet.m_bRedrawTree = TRUE; <br>return(TRUE); <br>} <br> <br> <br>void Dlg_OnDestroy (HWND hwnd) { <br>if (g_Inet.hImgList) ImageList_Destroy(g_Inet.hImgList); <br>if (g_Inet.m_phtml) MyFreeMem(g_Inet.m_phtml); <br>} <br> <br>void Dlg_OnCommand (HWND hwnd, int id,  <br>   HWND hwndCtl, UINT codeNotify)  <br>{ <br>   switch (id) { <br>      case IDCANCEL: <br>         EndDialog(hwnd, id); <br>         break; <br> <br>  case IDC_HTTP: //http option button is clicked. <br>  case IDC_FTP:  //ftp option button is clicked. <br>  case IDC_FILE:  //file option button is clicked. <br>g_Inet.m_url[0] = g_Inet.m_password[0] = g_Inet.m_username[0]  <br>= g_Inet.m_phtml[0]= '\0'; <br>g_Inet.m_dwServiceType = (id == IDC_HTTP)? SERVICE_TYPE_HTTP: <br>(id ==  IDC_FTP)?SERVICE_TYPE_FTP : SERVICE_TYPE_FILE; <br>//Show CERN check box for FTP URL only <br>if (id == IDC_FTP) ShowWindow(g_Inet.hCheckBoxCern, SW_SHOW); <br>else ShowWindow(g_Inet.hCheckBoxCern, SW_HIDE); <br>UpdateUI(FALSE); //Send g_Inet to update UI <br>g_Inet.m_itemArray.RemoveAll();  <br>FillTreeControl(); <br>break; <br>  <br>  case IDC_CERN:  //CERN checked box is clicked. <br>g_Inet.m_cern = IsDlgButtonChecked(g_hDlg, IDC_CERN)==BST_CHECKED; <br>break; <br> <br>  case IDC_GETDATA: //GetData button is clicked <br>HCURSORhCursor; <br>hCursor = SetCursor(LoadCursor (NULL, IDC_WAIT)); <br>ShowCursor(TRUE); <br> <br>//Get the UI setting to g_Inet <br>UpdateUI(TRUE); <br>g_Inet.m_phtml[0]= '\0'; <br>UpdateUI(FALSE); //cleaning up the html window <br> <br>//strip out white space in url <br>int i=0, j=0; <br>while (g_Inet.m_url[i]) <br>{ <br>while (g_Inet.m_url[i] == ' ') i++; <br>g_Inet.m_url[j++] = g_Inet.m_url[i++]; <br>} <br>g_Inet.m_url[j]='\0'; <br>if (!lstrlen(g_Inet.m_url)) <br>{ <br>MessageBox(g_hDlg, "You haven't enter a URL yet.", "Error", MB_OK); <br>break; <br>} <br> <br>CharLower(g_Inet.m_url); //change to all lower case <br>if (_tcsstr(g_Inet.m_url, _T("http://")) || <br>_tcsstr(g_Inet.m_url, _T("ftp://")) || <br>_tcsstr(g_Inet.m_url, _T("file://"))) <br>{ <br>MessageBox(hwnd, "Don't type method name in the url text box!", g_Inet.m_url, MB_OK); <br>goto CursorBackandBailOut; <br>} <br> <br>if (g_Inet.m_dwServiceType == SERVICE_TYPE_FILE) <br>{ //For file url, change all / to \ in the url <br>i=0; <br>while (g_Inet.m_url[i])  <br>{ <br>if (g_Inet.m_url[i] == '/') g_Inet.m_url[i] = '\\'; <br>i++; <br>} <br>lstrcpy(szFullUrl, "file://"); <br>lstrcat(szFullUrl, g_Inet.m_url); <br>} <br>else <br>{ //For ftp or http, change all \ to / in the url <br>i=0; <br>while (g_Inet.m_url[i])  <br>{ <br>if (g_Inet.m_url[i] == '\\') g_Inet.m_url[i] = '/'; <br>i++; <br>} <br>//If the server requires username and password, we will construct a url like this: <br>//http://username:password@server:port/path. <br>//Since we only use InternetOpenUrl, there is no other way to pass in username and <br>//password.Doesn't apply to FILE url. <br>lstrcpy(szFullUrl, g_Inet.m_dwServiceType == SERVICE_TYPE_FTP? <br>"ftp://":"http://"); <br>if (lstrlen(g_Inet.m_username) &amp;&amp; lstrlen(g_Inet.m_password)) <br>{ <br>lstrcat(szFullUrl,g_Inet.m_username);  <br>lstrcat(szFullUrl, ":"); <br>lstrcat(szFullUrl,(LPCTSTR)g_Inet.m_password);  <br>lstrcat(szFullUrl, "@"); <br>} <br>lstrcat(szFullUrl,(LPCTSTR)g_Inet.m_url);  <br>} <br> <br> <br>//if m_bRedrawTree is FALSE, which means user has clicked a treecontrol item, <br>//we won't redraw the whole tree. We will simply add sub-item to the currnet  <br>//selected item. Also if the service HTTP, we don't change tree control at all. <br>if ((g_Inet.m_bRedrawTree &amp;&amp; g_Inet.m_dwServiceType != SERVICE_TYPE_HTTP) <br>|| g_Inet.m_dwServiceType == SERVICE_TYPE_HTTP) <br>{ <br>TreeView_DeleteAllItems( g_Inet.hTreeViewCtrl); <br>TV_INSERTSTRUCT tvstruct; <br>tvstruct.hParent = NULL; <br>tvstruct.hInsertAfter = TVI_FIRST; <br>tvstruct.item.iImage = 0; <br>tvstruct.item.iSelectedImage = 0; <br>tvstruct.item.pszText = g_Inet.m_url; <br>tvstruct.item.mask = TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_TEXT; <br>g_Inet.m_curItem = (HTREEITEM)SendMessage(g_Inet.hTreeViewCtrl, TVM_INSERTITEM,0, (LPARAM)(LPTV_INSERTSTRUCT)&amp;tvstruct); <br>} <br>g_Inet.m_bRedrawTree = TRUE; <br> <br> <br>HINTERNET hInternetSession; <br>hInternetSession = InternetOpen(_T("InetAll"), INTERNET_OPEN_TYPE_PRECONFIG, <br>NULL, NULL, 0); <br>if (!hInternetSession) <br>{ <br>MessageBox(hwnd, "InternetOpen Fails", "Error", MB_OK); <br>goto CursorBackandBailOut; <br>} <br>switch (g_Inet.m_dwServiceType) <br>{ <br>case SERVICE_TYPE_HTTP: <br>HINTERNET hInternetFile; <br>//We just download html and text. Modify if needs to download binary file. <br>hInternetFile = InternetOpenUrl(hInternetSession, szFullUrl, <br>NULL, 0, INTERNET_FLAG_TRANSFER_ASCII | INTERNET_FLAG_RELOAD | INTERNET_FLAG_DONT_CACHE, 0); <br>if (!hInternetFile) <br>{ <br>MessageBox(hwnd, "InternetOpenUrl failed! Check URL or connection", szFullUrl, MB_OK); <br>goto CursorBackandBailOut; <br>} <br>DWORD dwRead; <br>TCHAR szTemp[1024]; <br>int nTimes; <br>nTimes=1; <br>while (InternetReadFile(hInternetFile, (LPVOID)szTemp, 1023, &amp;dwRead)) <br>{ <br>if (!dwRead) break; <br>szTemp[dwRead]='\0'; <br>//Enlarge buffer only on a need base <br>if (++nTimes * 1024&gt;(int)g_Inet.m_dwSizeHtml) <br>{ <br>LPVOID pTemp = MyAllocMem(g_Inet.m_dwSizeHtml + 1024); <br>if (!pTemp) { <br>MessageBox(hwnd, "Mem alloc fails", "Error", MB_OK); <br>InternetCloseHandle(hInternetFile); <br>g_Inet.m_phtml[0] = '\0'; <br>goto CursorBackandBailOut; <br>} <br>CopyMemory (pTemp, g_Inet.m_phtml, g_Inet.m_dwSizeHtml); <br>g_Inet.m_dwSizeHtml += 1024; <br> <br>MyFreeMem(g_Inet.m_phtml); <br>g_Inet.m_phtml = (LPTSTR)pTemp; <br>} <br>lstrcat(g_Inet.m_phtml, szTemp); <br>} <br>SetWindowText(g_Inet.hwndHTML, g_Inet.m_phtml); <br>InternetCloseHandle(hInternetFile); <br>break; <br> <br>case SERVICE_TYPE_FILE: <br>case SERVICE_TYPE_FTP: <br>//FillFtpOrFileObjArray enumerates and FTP or FILE url, and populates <br>//g_Inet.m_itemArray. <br>if (!FillFtpOrFileObjArray(hInternetSession, szFullUrl)) break; <br>//FillTreeControl draws the treeview control using g_Inet.m_itemArray  <br>FillTreeControl(); <br>break; <br>} <br> <br>CursorBackandBailOut: <br>InternetCloseHandle(hInternetSession); <br>UpdateUI(FALSE); <br>ShowCursor(FALSE); <br>SetCursor(hCursor); <br>break; //break for switch id <br>}   <br>} <br> <br> <br>BOOL CALLBACK Dlg_Proc (HWND hDlg, UINT uMsg,  <br>   WPARAM wParam, LPARAM lParam) { <br>    <br>   BOOL fProcessed = TRUE; <br>   switch (uMsg) { <br>      HANDLE_MSG(hDlg, WM_INITDIALOG, Dlg_OnInitDialog); <br>      HANDLE_MSG(hDlg, WM_DESTROY, Dlg_OnDestroy); <br>      HANDLE_MSG(hDlg, WM_COMMAND, Dlg_OnCommand); <br> <br>  //No message crackers defined in windowsx.h for WM_NOTIFY, so we just handled <br>  //it directly. <br>  //We only process WM_NOTIFY when TreeView items are double clicked. <br>  case WM_NOTIFY: <br>int idCtrl; <br>idCtrl  = (int) wParam; <br>LPNMHDR pnmh; <br>pnmh =  (LPNMHDR) lParam;  <br>  <br>if (idCtrl == IDC_TREE1 &amp;&amp; pnmh-&gt;code == NM_DBLCLK) <br>{ <br>g_Inet.m_curItem = TreeView_GetSelection(g_Inet.hTreeViewCtrl); <br> <br>//if it's already root, we don't need to enumerate again. <br>if (! TreeView_GetParent(g_Inet.hTreeViewCtrl, g_Inet.m_curItem)) return fProcessed; <br>TV_ITEM tvItem; <br>tvItem.mask =TVIF_TEXT;  <br>tvItem.hItem = g_Inet.m_curItem; <br>tvItem.pszText = g_Inet.m_url; <br>TreeView_GetItem(g_Inet.hTreeViewCtrl, &amp;tvItem); <br> <br>//change UI to have new m_url <br>UpdateUI(FALSE); <br> <br>//if the URL ends with a / or \, it's a directory, we call Dlg_OnCommand directly to <br>//construct new m_itemArray. FillFtpOrFileObjArray <br>//and FillTreeControl will be called by Dlg_OnCommand. <br>TCHAR cRight; <br>cRight = g_Inet.m_url[lstrlen(g_Inet.m_url)-1]; <br>if (cRight =='/' ||cRight =='\\') <br>{ <br>g_Inet.m_bRedrawTree = FALSE; <br>Dlg_OnCommand (g_hDlg, IDC_GETDATA, GetDlgItem(g_hDlg, IDC_GETDATA),0); <br>} <br>else <br>{ <br>//if it's a file, we are downloading it. <br>if (g_Inet.m_dwServiceType == SERVICE_TYPE_FTP) <br>{ <br>HINTERNET hInternetFile, hInternetSession; <br>hInternetSession = InternetOpen(_T("InetAll"), INTERNET_OPEN_TYPE_PRECONFIG, <br>NULL, NULL, 0); <br>if (!hInternetSession) <br>{ <br>MessageBox(g_hDlg, "InternetOpen Fails", "Error", MB_OK); <br>return fProcessed; <br>} <br> <br>UpdateUI(TRUE); <br>lstrcpy(szFullUrl, g_Inet.m_dwServiceType == SERVICE_TYPE_FTP? <br>"ftp://":"http://"); <br>if (lstrlen(g_Inet.m_username) &amp;&amp; lstrlen(g_Inet.m_password)) <br>{ <br>lstrcat(szFullUrl,g_Inet.m_username);  <br>lstrcat(szFullUrl, ":"); <br>lstrcat(szFullUrl,(LPCTSTR)g_Inet.m_password);  <br>lstrcat(szFullUrl, "@"); <br>} <br>lstrcat(szFullUrl,(LPCTSTR)g_Inet.m_url);  <br>DeleteFile("c:\\deleteme"); <br>HANDLE f; <br>DWORD dwRead; <br>//download the file to c:\deleteme <br>f= CreateFile("c:\\deleteme", GENERIC_WRITE,  0, NULL,  <br>CREATE_ALWAYS,FILE_ATTRIBUTE_NORMAL, NULL);  <br> <br>if (f==  INVALID_HANDLE_VALUE)  <br>{ <br>MessageBox (hDlg, "Can't open c:\\deleteme to write! Enough free space on C:???", <br>szFullUrl, MB_OK); <br>return fProcessed; <br>} <br> hInternetFile = InternetOpenUrl(hInternetSession,(LPCTSTR)szFullUrl, NULL, 0,  <br>INTERNET_FLAG_RELOAD | INTERNET_FLAG_DONT_CACHE, 0); <br>if (!hInternetFile) <br>{ <br>CloseHandle(f); <br>return fProcessed; <br>} <br>TCHAR szTemp[1024]; <br>while (InternetReadFile(hInternetFile, (LPVOID)szTemp, 1024, &amp;dwRead)) <br>{ <br>if (!dwRead) break; <br>DWORD dwWritten; <br>WriteFile(f, (LPVOID)szTemp, dwRead, &amp;dwWritten, NULL); <br>} <br>CloseHandle(f); <br>InternetCloseHandle(hInternetFile); <br>InternetCloseHandle(hInternetSession); <br>MessageBox(g_hDlg, "The url is downloaded in c:\\deleteme!", szFullUrl, MB_OK); <br> <br>}//////////// <br>else <br>{ ///file type url <br>DeleteFile("c:\\deleteme"); <br>if (CopyFile( <br>g_Inet.m_url,// pointer to name of an existing file  <br>"c:\\deleteme",// pointer to filename to copy to  <br>FALSE // flag for operation if file exists  <br>))  <br>MessageBox(g_hDlg, "The url is downloaded in c:\\deleteme!", g_Inet.m_url, MB_OK); <br>else  <br>{ <br>MessageBox(g_hDlg, "CopyFile failed!", g_Inet.m_url, MB_OK); <br>} <br>} <br>} <br>//Double click will actually collapse a tree. To expand it in double click event <br>//we will simply post a TVM_EXPAND message to the treeview control. <br>PostMessage(g_Inet.hTreeViewCtrl, TVM_EXPAND, (WPARAM) (UINT) TVE_EXPAND, (LPARAM) g_Inet.m_curItem);  <br>} <br>break; <br> <br>      default: <br>         fProcessed = FALSE; <br>         break; <br>   } <br> <br>   return(fProcessed); <br>} <br> <br> <br>//Update UI or Collect input from UI <br>//bDirection FALSE g_Inet to UI <br>//bDirection TRUE UI to g_Inet <br> <br>BOOL UpdateUI(BOOL bDirection) <br>{ <br>BOOL bRet = FALSE; <br>if (bDirection) //Get UI Input to g_Inet <br>{ <br>if (BST_CHECKED ==IsDlgButtonChecked(g_hDlg, IDC_CERN)) g_Inet.m_cern = TRUE; <br>else g_Inet.m_cern =  FALSE; <br> <br>if (BST_CHECKED ==IsDlgButtonChecked(g_hDlg, IDC_HTTP))  <br>g_Inet.m_dwServiceType == SERVICE_TYPE_HTTP; <br>if (BST_CHECKED ==IsDlgButtonChecked(g_hDlg, IDC_FTP))  <br>g_Inet.m_dwServiceType == SERVICE_TYPE_FTP; <br>if (BST_CHECKED ==IsDlgButtonChecked(g_hDlg, IDC_FILE))  <br>g_Inet.m_dwServiceType == SERVICE_TYPE_FILE; <br> <br>bRet = GetDlgItemText(g_hDlg, IDC_URL, g_Inet.m_url, MAX_STRING_SIZE) <br>  &amp;&amp; GetDlgItemText(g_hDlg, IDC_USERNAME, g_Inet.m_username, MAX_STRING_SIZE) <br>  &amp;&amp; GetDlgItemText(g_hDlg, IDC_PASSWORD, g_Inet.m_password, MAX_STRING_SIZE); <br>} <br>else //Update UI from g_Inet <br>{  <br>int nService; <br> <br>if (g_Inet.m_dwServiceType == SERVICE_TYPE_HTTP) nService = IDC_HTTP; <br>else if (g_Inet.m_dwServiceType == SERVICE_TYPE_FTP) nService = IDC_FTP; <br>else nService = IDC_FILE; <br>bRet = CheckRadioButton(g_hDlg, IDC_HTTP, IDC_FILE, nService) <br>&amp;&amp; SetWindowText(g_Inet.hwndUrl, g_Inet.m_url) <br>    &amp;&amp; SetWindowText(g_Inet.hwndPassword, g_Inet.m_password) <br>&amp;&amp; SetWindowText(g_Inet.hwndUsername, g_Inet.m_username);; <br>bRet  = bRet &amp;&amp; SetWindowText(g_Inet.hwndHTML, g_Inet.m_phtml); <br> <br>SendMessage(g_Inet.hCheckBoxCern, BM_SETCHECK, g_Inet.m_cern, 0); <br>} <br>return bRet; <br>} <br> <br>//Enumerate strURL, and populate g_Inet.m_itemArray <br>BOOL FillFtpOrFileObjArray(HINTERNET hInternetSession, LPTSTR strURL) <br>{ <br>BOOL bRet = FALSE; <br>if (!hInternetSession) return bRet; <br> <br>if (g_Inet.m_dwServiceType == SERVICE_TYPE_HTTP) <br>{ <br>MessageBox(g_hDlg, "only ftp and file url needs enumeration!", "Error", MB_OK); <br>return bRet; <br>} <br> <br>ItemAttrib tempObj; <br>g_Inet.m_itemArray.RemoveAll(); <br> <br>if (g_Inet.m_dwServiceType == SERVICE_TYPE_FTP) //////// start_if_ftp <br>{ <br>//CERN or NO CERN we will download HTML anyway. <br>HINTERNET hInternetFile; <br>hInternetFile = InternetOpenUrl(hInternetSession, szFullUrl, <br>NULL, 0, INTERNET_FLAG_TRANSFER_ASCII | INTERNET_FLAG_RELOAD | INTERNET_FLAG_DONT_CACHE, 0); <br>DWORD dwRead; <br>TCHAR szTemp[1024]; <br>int nTimes; <br>nTimes=1; <br>while (InternetReadFile(hInternetFile, (LPVOID)szTemp, 1023, &amp;dwRead)) <br>{ <br>if (!dwRead) break; <br>szTemp[dwRead]='\0'; <br>if (++nTimes * 1024&gt;(int)g_Inet.m_dwSizeHtml) <br>{ <br>LPVOID pTemp = MyAllocMem(g_Inet.m_dwSizeHtml + 1024); <br>if (!pTemp) { <br>MessageBox(g_hDlg, "Mem alloc fails", "Error", MB_OK); <br>InternetCloseHandle(hInternetFile); <br>g_Inet.m_phtml[0] = '\0'; <br>break; <br>} <br>CopyMemory (pTemp, g_Inet.m_phtml, g_Inet.m_dwSizeHtml); <br>g_Inet.m_dwSizeHtml += 1024; <br> <br>MyFreeMem(g_Inet.m_phtml); <br>g_Inet.m_phtml = (LPTSTR)pTemp; <br>} <br>lstrcat(g_Inet.m_phtml, szTemp); <br>} <br>SetWindowText(g_Inet.hwndHTML, g_Inet.m_phtml); <br>InternetCloseHandle(hInternetFile); <br> <br>//If direct access to FTP server, we will use  <br>//InternetOpenUrl(INTERNET_FLAG_RAW_DATA) and InternetFindNextFile <br>//to enumerate the sub directories and files <br>if (!g_Inet.m_cern)  //start_if_no_cern <br>{ <br>WIN32_FIND_DATA wfd; <br> <br>HINTERNET hInternetFind = InternetOpenUrl(hInternetSession,(LPCTSTR)strURL, NULL, 0,  <br>INTERNET_FLAG_RAW_DATA| INTERNET_FLAG_RELOAD | INTERNET_FLAG_DONT_CACHE, 0); <br>if (!InternetFindNextFile (hInternetFind, &amp;wfd))  <br>{ <br>bRet = FALSE; //Actually this may or may not be a failure. <br>MessageBox(g_hDlg, "No files or sub-directories under this url directory", strURL, MB_OK); <br>return bRet; <br>} <br>do { <br>LPCTSTR strFileName; <br>if(wfd.dwFileAttributes &amp; FILE_ATTRIBUTE_DIRECTORY) { <br>strFileName = (LPCTSTR) &amp;wfd.cFileName; <br>if (strFileName[0] == '.') continue; <br>lstrcpy(tempObj.szObjectPath, g_Inet.m_url); <br>if (strURL[lstrlen(strURL)-1] != '/') lstrcat(tempObj.szObjectPath, "/"); <br>lstrcat (tempObj.szObjectPath, strFileName); <br>if (tempObj.szObjectPath[lstrlen(tempObj.szObjectPath)-1] != '/' ) <br>lstrcat(tempObj.szObjectPath, "/"); <br>tempObj.nObjectType = 1; <br>g_Inet.m_itemArray.Add(tempObj); <br>} <br>else <br>{ <br>strFileName = (LPCTSTR) &amp;wfd.cFileName; <br>lstrcpy(tempObj.szObjectPath , g_Inet.m_url); <br>if (strURL[lstrlen(strURL)-1] != '/') lstrcat(tempObj.szObjectPath, "/"); <br>lstrcat(tempObj.szObjectPath, strFileName); <br>tempObj.nObjectType = 0; <br>g_Inet.m_itemArray.Add(tempObj); <br>} <br>} while (InternetFindNextFile (hInternetFind, &amp;wfd)); <br>InternetCloseHandle (hInternetFind); <br>}  //end_if_no_cern <br>else <br>{ //start_if_cern  <br>LPTSTR strTemp; <br>TCHAR strTempUrl[MAX_STRING_SIZE]; <br>strTemp = g_Inet.m_phtml; <br>//we have the html file listings in the strTemp, we just need to parse it  <br>//a sample html is provided at the bottom of this file. Note that the parsing <br>//code may not work with proxies other than MS Proxy server. <br>while (TRUE) <br>{ <br>int nPos; <br>TCHAR strLeft[] = "&lt;A HREF="; <br>TCHAR strRight[] = "&gt;"; <br> <br>nPos = _tcsstr(strTemp, strLeft) - strTemp; <br>if (nPos &lt; 0) break; <br>strTemp = strTemp + nPos +lstrlen(strLeft)+1; <br>nPos = _tcsstr(strTemp, strRight) - strTemp; <br>for (int i=0; i&lt;nPos-1; i++) <br>strTempUrl[i]=strTemp[i]; <br>strTempUrl[nPos-1] = '\0'; <br>strTemp =  strTemp +i +lstrlen(strRight); <br>if (strTempUrl[0] == '.') continue; <br> <br>if (g_Inet.m_url[lstrlen(g_Inet.m_url)-1] != '/') <br>{ <br>g_Inet.m_url[lstrlen(g_Inet.m_url)] ='/'; <br>g_Inet.m_url[lstrlen(g_Inet.m_url)+1] ='\0'; <br>} <br> <br>TCHAR strServerName[256]; <br>i=0; <br>while (TRUE) <br>{ <br>strServerName[i]= g_Inet.m_url[i]; <br>if (g_Inet.m_url[i] == '/') <br>{ <br>strServerName[i] = '\0'; <br>break; <br>} <br>i++; <br>} <br>lstrcpy(tempObj.szObjectPath, strServerName); <br>lstrcat(tempObj.szObjectPath, strTempUrl); <br>if (strTempUrl[lstrlen(strTempUrl)-1] == '/' ) tempObj.nObjectType = 1; <br>else tempObj.nObjectType = 0; <br>g_Inet.m_itemArray.Add(tempObj); <br>} <br>if (!g_Inet.m_itemArray.GetSize()){ <br>MessageBox(g_hDlg, "No files or sub-directories under the url", g_Inet.m_url, MB_OK); <br>return bRet; <br>} <br>}//end_if_cern <br>}////end_if_ftp <br>else  <br>{  //start_if_file <br>TCHAR strFileSpec[MAX_STRING_SIZE]; <br> <br> <br>lstrcpy(strFileSpec, g_Inet.m_url); <br> <br>//trying to determine if it's a single machine name to enumerate, or <br>//it's already a unc name. <br>LPTSTR szTempRight; <br> <br>//in case user type in \\machine name in url text box, <br>szTempRight = strFileSpec+2; <br>int i=0; <br>BOOL bServerNameOnly; <br>bServerNameOnly= TRUE; <br>for (i=0; i&lt;lstrlen(szTempRight)-1; i++) <br>{ <br>if (szTempRight[i] == '\\') <br>{ <br>bServerNameOnly = FALSE; <br>break; <br>} <br>} <br> <br>if (bServerNameOnly) <br>{  <br>//user enters a single machine name, we will enumerate the shares. <br>lstrcpy(g_Inet.m_url, "\\\\"); <br>int i=0; <br>while (strFileSpec[i] == '\\') i++; <br>lstrcat(g_Inet.m_url, (LPTSTR)(strFileSpec + i)); <br>if (g_Inet.m_url[lstrlen(g_Inet.m_url)-1] == '\\') <br>g_Inet.m_url[lstrlen(g_Inet.m_url)-1] = '\0'; <br>//now the g_Inet.m_url is "\\server name <br>NETRESOURCE nr; <br>nr.dwScope = RESOURCE_GLOBALNET; <br>nr.dwType = RESOURCETYPE_ANY; <br>nr.dwDisplayType = RESOURCEDISPLAYTYPE_SERVER; <br>nr.dwUsage = RESOURCEUSAGE_CONTAINER; <br>nr.lpLocalName = NULL; <br>nr.lpRemoteName = g_Inet.m_url; <br>nr.lpComment = NULL; <br>nr.lpProvider = NULL; <br>LPVOID pMem =  HeapAlloc(GetProcessHeap(),  <br>    HEAP_GENERATE_EXCEPTIONS | HEAP_ZERO_MEMORY, 16384); <br>if (!pMem) <br>{ <br>MessageBox(g_hDlg, "Not enough memory to allocate for WNetEnumResource",g_Inet.m_url, MB_OK ); <br>return bRet; <br>} <br>HANDLE hWNetEnum=NULL; <br>DWORD dwStatus = WNetOpenEnum(RESOURCE_GLOBALNET, RESOURCETYPE_ANY,  <br>RESOURCEUSAGE_CONNECTABLE, &amp;nr, &amp;hWNetEnum); <br>if (dwStatus != NO_ERROR) <br>{ <br>DWORD dwErr = GetLastError(); <br>MessageBox(g_hDlg, "WNetOpenEnum failed", g_Inet.m_url, MB_OK ); <br>HeapFree(GetProcessHeap(), 0, pMem); <br>return bRet; <br>} <br>do <br>{ <br>DWORD dwEntries; <br>DWORD dwBuffSize; <br>dwEntries =1; <br>dwBuffSize= 16384; <br>dwStatus = WNetEnumResource(hWNetEnum, &amp;dwEntries, pMem, &amp;dwBuffSize); <br>if (dwStatus == NO_ERROR) <br>{ <br>lstrcpy(tempObj.szObjectPath, ((LPNETRESOURCE)pMem)-&gt;lpRemoteName); <br>lstrcat(tempObj.szObjectPath, "\\"); <br>tempObj.nObjectType = 1; <br>g_Inet.m_itemArray.Add(tempObj); <br>} <br>} while (dwStatus == NO_ERROR); <br>if (dwStatus != ERROR_NO_MORE_ITEMS) <br>{ <br>MessageBox(g_hDlg, "WNetEnumResource failed",g_Inet.m_url, MB_OK); <br>MyFreeMem(pMem); <br>WNetCloseEnum(hWNetEnum); <br>return bRet; <br>} <br>MyFreeMem(pMem); <br>WNetCloseEnum(hWNetEnum); <br>//we are done with enumerating shares on a file server. <br>return bRet = TRUE; <br>} <br> <br>lstrcpy(strFileSpec, "\\\\"); <br>i=0; <br>while (g_Inet.m_url[i]=='\\') //skip starting \ in m_url <br>{ <br>i++; <br>} <br>lstrcat(strFileSpec, g_Inet.m_url+i); <br>//Now strFileSpec is a UNC such as \\server\share\filedirectory\... <br> <br>WIN32_FIND_DATA fd;  <br>HANDLE hFind = NULL; <br>if ((hFind = FindFirstFile ((LPCTSTR) strFileSpec, &amp;fd)) == <br>INVALID_HANDLE_VALUE) { <br>if (strFileSpec[lstrlen(strFileSpec)-1] != '\\') lstrcat(strFileSpec, "\\"); <br>lstrcpy(g_Inet.m_url, strFileSpec); <br>lstrcat(strFileSpec, "*.*"); <br>if ((hFind = FindFirstFile ((LPCTSTR) strFileSpec, &amp;fd)) == <br>INVALID_HANDLE_VALUE)  <br>{ <br>MessageBox(g_hDlg, "No files or sub-directories under the url", g_Inet.m_url, MB_OK); <br>return bRet; <br>} <br>} <br>do { <br>if(fd.dwFileAttributes &amp; FILE_ATTRIBUTE_DIRECTORY) { <br> (LPCTSTR) &amp;fd.cFileName; <br>if ( ((LPCTSTR) &amp;fd.cFileName)[0] == '.') continue; <br>lstrcpy(tempObj.szObjectPath, g_Inet.m_url); <br>lstrcat(tempObj.szObjectPath, (LPCTSTR) &amp;fd.cFileName); <br>lstrcat(tempObj.szObjectPath, "\\"); <br>tempObj.nObjectType = 1; <br>g_Inet.m_itemArray.Add(tempObj); <br>} <br>else <br>{ <br>lstrcpy(tempObj.szObjectPath, g_Inet.m_url); <br>lstrcat(tempObj.szObjectPath, (LPCTSTR) &amp;fd.cFileName); <br>tempObj.nObjectType = 0; <br>g_Inet.m_itemArray.Add(tempObj); <br> <br>} <br>} while (FindNextFile (hFind, &amp;fd)); <br>FindClose (hFind); <br>} //end_if_file <br>bRet = TRUE; //happy here. <br> <br>return bRet; <br>} <br> <br>//Draw tree structure of a FTP or FILE URL in  <br>//treeview Ctrl using g_Inet.m_itemArray <br>void FillTreeControl() <br>{ <br>TV_INSERTSTRUCT tvstruct; <br>int nItem; <br>nItem = g_Inet.m_itemArray.GetSize(); <br>HTREEITEM hChildItem=NULL, hNextChildItem=NULL; <br>if (!nItem){ <br>TreeView_DeleteAllItems( g_Inet.hTreeViewCtrl); <br>tvstruct.hParent = NULL; <br>tvstruct.hInsertAfter = TVI_FIRST; <br>tvstruct.item.iImage = 0; <br>tvstruct.item.iSelectedImage = 0; <br>tvstruct.item.pszText = _T("Root"); <br>tvstruct.item.mask = TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_TEXT; <br>SendMessage(g_Inet.hTreeViewCtrl, TVM_INSERTITEM,0, (LPARAM)(LPTV_INSERTSTRUCT)&amp;tvstruct); <br>return; <br>} <br> <br>int nBMID; <br> <br>//Remove all old items under the selected item <br>hChildItem = TreeView_GetChild(g_Inet.hTreeViewCtrl, g_Inet.m_curItem);  <br> <br>while (hChildItem) <br>{ <br>hNextChildItem = TreeView_GetNextSibling(g_Inet.hTreeViewCtrl, hChildItem); <br> TreeView_DeleteItem(g_Inet.hTreeViewCtrl, hChildItem); <br>hChildItem = hNextChildItem; <br>} <br>//add new items <br>for (int i=0; i&lt;nItem; i++) <br>{ <br>nBMID = ((g_Inet.m_itemArray.GetAt(i)).nObjectType==0)?2:1; <br>tvstruct.hParent = g_Inet.m_curItem; <br>tvstruct.hInsertAfter = TVI_LAST; <br>tvstruct.item.iImage = nBMID; <br>tvstruct.item.iSelectedImage = nBMID; <br>tvstruct.item.pszText = (g_Inet.m_itemArray.GetAt(i)).szObjectPath; <br>tvstruct.item.mask = TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_TEXT; <br>SendMessage(g_Inet.hTreeViewCtrl, TVM_INSERTITEM,0, (LPARAM)(LPTV_INSERTSTRUCT)&amp;tvstruct); <br>} <br>//Make sure the tree under the selected item is expanded. <br>if (g_Inet.m_curItem)  <br>{ <br>TreeView_EnsureVisible(g_Inet.hTreeViewCtrl, g_Inet.m_curItem); <br>TreeView_Expand(g_Inet.hTreeViewCtrl, g_Inet.m_curItem, TVE_EXPAND); <br>} <br>} <br> <br>//A typical HTML wrapper for file listing a in ftp url from MS Proxy Server <br>//which is CERN-compatible proxy. <br>/* <br>&lt;HTML&gt; <br>&lt;HEAD&gt; <br>&lt;TITLE&gt;FTP root at ftp.microsoft.com&lt;/TITLE&gt; <br>&lt;/HEAD&gt; <br>&lt;BODY&gt; <br>&lt;H1&gt;FTP root at ftp.microsoft.com&lt;/H1&gt; <br>&lt;HR&gt; <br>&lt;H4&gt;&lt;PRE&gt; <br>This is FTP.MICROSOFT.COM.  Please see the <br> dirmap.txt file for more information. </code></pre>
<p>
</p>
<pre><code>&lt;/PRE&gt;&lt;/H4&gt; <br>&lt;HR&gt; <br>&lt;PRE&gt; <br>08/24/94 12:00AM          &amp;lt;DIR&amp;gt; &lt;A HREF="/deskapps/access/"&gt;access&lt;/A&gt; <br>08/24/94 12:00AM          &amp;lt;DIR&amp;gt; &lt;A HREF="/deskapps/dosword/"&gt;dosword&lt;/A&gt; <br>08/24/94 12:00AM          &amp;lt;DIR&amp;gt; &lt;A HREF="/deskapps/excel/"&gt;excel&lt;/A&gt; <br>08/24/94 12:00AM          &amp;lt;DIR&amp;gt; &lt;A HREF="/deskapps/games/"&gt;games&lt;/A&gt; <br>10/08/94 12:00AM          &amp;lt;DIR&amp;gt; &lt;A HREF="/deskapps/GEN_INFO/"&gt;GEN_INFO&lt;/A&gt; <br>08/24/94 12:00AM          &amp;lt;DIR&amp;gt; &lt;A HREF="/deskapps/homeapps/"&gt;homeapps&lt;/A&gt; <br>03/12/97 10:23PM          &amp;lt;DIR&amp;gt; &lt;A HREF="/deskapps/kids/"&gt;kids&lt;/A&gt; <br>08/24/94 12:00AM          &amp;lt;DIR&amp;gt; &lt;A HREF="/deskapps/miscapps/"&gt;miscapps&lt;/A&gt; <br>08/24/94 12:00AM          &amp;lt;DIR&amp;gt; &lt;A HREF="/deskapps/mmapps/"&gt;mmapps&lt;/A&gt; <br>08/28/96 12:00AM          &amp;lt;DIR&amp;gt; &lt;A HREF="/deskapps/MONEY/"&gt;MONEY&lt;/A&gt; <br>08/24/94 12:00AM          &amp;lt;DIR&amp;gt; &lt;A HREF="/deskapps/office/"&gt;office&lt;/A&gt; <br>08/24/94 12:00AM          &amp;lt;DIR&amp;gt; &lt;A HREF="/deskapps/powerpt/"&gt;powerpt&lt;/A&gt; <br>08/24/94 12:00AM          &amp;lt;DIR&amp;gt; &lt;A HREF="/deskapps/project/"&gt;project&lt;/A&gt; <br>08/24/94 12:00AM          &amp;lt;DIR&amp;gt; &lt;A HREF="/deskapps/publishr/"&gt;publishr&lt;/A&gt; <br>08/30/94 12:00AM          1,791 &lt;A HREF="/deskapps/readme.txt"&gt;readme.txt&lt;/A&gt; <br>08/24/94 12:00AM          &amp;lt;DIR&amp;gt; &lt;A HREF="/deskapps/word/"&gt;word&lt;/A&gt; <br>08/28/96 12:00AM          &amp;lt;DIR&amp;gt; &lt;A HREF="/deskapps/WORKS/"&gt;WORKS&lt;/A&gt; <br>&lt;/PRE&gt; <br>&lt;HR&gt; <br>&lt;/BODY&gt; <br>&lt;/HTML&gt; <br>*/ <br> <br>/////////////////////// End Of File //////////////////////// </code></pre>
<p>&nbsp;</p></body>
</HTML>
