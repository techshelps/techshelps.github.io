<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>FTPJR.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context4004"></a>FTPJR.CPP</h2>
<pre><code>////////////////////////////////////////////////////////// <br>// <br>//         FTP Jr  -- A Poor Man's FTP Client <br>//         Sample WinInet Application to demonstrate <br>//         The FTP APIs <br>//         Microsoft Corporation (C) <br>// <br>////////////////////////////////////////////////////////// <br> <br>#include &lt;iostream.h&gt; <br>#include &lt;windows.h&gt; <br>#include &lt;direct.h&gt; <br>#include &lt;wininet.h&gt; <br> <br>#define PROMPT  "FTP Jr&gt;" <br> <br>BOOL ParseCommand(char *, char *, char *); <br>BOOL Open (CHAR *); <br>BOOL Close (); <br>BOOL ErrorOut ( DWORD, CHAR *); <br>void FtpEnumDirectory (); <br>void lcd (char *); <br>void rcd (char *); <br>void type (char *); <br>void DisplayHelp(); <br>void ShowUsage(); <br> <br>char arg1[256], arg2[256], arg3[256]; <br>char szProxy[256] = ""; <br>char szServer[256] = ""; <br>char szCmdLine[256] = ""; <br>HINTERNET hOpen, hConnect; <br>BOOL bActiveSession = FALSE; <br>DWORD dwType = FTP_TRANSFER_TYPE_BINARY; <br> <br>void main(int argc, char *argv[]) <br>{ <br> <br>// Display our banner <br>cout &lt;&lt; "FTP Jr. WinInet FTP Sample Application" &lt;&lt; endl; <br>cout &lt;&lt; "Microsoft Corporation" &lt;&lt; endl &lt;&lt; endl; <br> <br>// Do they want the display syntax? <br>if ((lstrcmp(argv[1], "/?") == 0) || <br>        (lstrcmp(argv[1], "?") == 0) || <br>(lstrcmp(argv[1], "-?") == 0) || <br>(lstrcmp(argv[1], "help") == 0) || <br>        (lstrcmp(argv[1], "/help") == 0) || <br>(lstrcmp(argv[1], "/HELP") == 0) || <br>(lstrcmp(argv[1], "HELP") == 0)) <br>{ <br>ShowUsage(); <br>return; <br>} <br> <br>switch (argc) <br>{ <br>case 2: <br>// Specified proxy, Open WININET.DLL w/ Proxy <br>lstrcpy(szProxy, argv[1]); <br>        if ( !(hOpen = InternetOpen ( "FTP Jr (C)",  CERN_PROXY_INTERNET_ACCESS, szProxy, NULL, 0) ) ) <br>        { <br>            ErrorOut ( GetLastError(), "InternetOpen"); <br>           return ; <br>        } <br>        break; <br>    case 1: <br>// No proxy specified.  Open WININET.DLL w/ local access <br>        if ( !(hOpen = InternetOpen ( "FTP Jr (C)",  LOCAL_INTERNET_ACCESS , NULL, 0, 0) ) ) <br>        { <br>            ErrorOut ( GetLastError(), "InternetOpen"); <br>            return ; <br>        } <br>        break;     <br>    default: <br>ShowUsage(); <br>return; <br>} <br> <br>cout &lt;&lt; PROMPT; <br> <br>// Parse commands 1 line at a time <br>while(TRUE) <br>{ <br>char *pszArg1, *pszArg2, *pszArg3, *pszTemp; <br> <br>// Read line <br>cin.getline(szCmdLine, 256); <br>pszArg1 = szCmdLine; <br> <br>//Remove white space before 1st arg <br>while((*pszArg1 != 0) &amp;&amp; <br>  (*pszArg1 == ' ')) pszArg1++; <br> <br>pszArg2 = pszArg1; <br> <br>//Find end of 1st arg and zero terminate <br>while ((*pszArg2 != 0) &amp;&amp; <br>   (*pszArg2 != ' ')) pszArg2++; <br> <br>if (*pszArg2 != 0) *pszArg2++ = 0; <br> <br>//Remove white space before 2nd arg <br>while ((*pszArg2 !=0) &amp;&amp; <br>   (*pszArg2 == ' ')) pszArg2++; <br> <br>pszArg3 = pszArg2; <br> <br>//Find end of 2nd arg and zero terminate <br>while ((*pszArg3 != 0) &amp;&amp; <br>   (*pszArg3 != ' ')) pszArg3++; <br> <br>if (*pszArg3 != 0) *pszArg3++ = 0; <br> <br>//Remove white space before 3rd Arg <br>while ((*pszArg3 !=0) &amp;&amp; <br>   (*pszArg3 == ' ')) pszArg3++; <br> <br>pszTemp = pszArg3; <br> <br>//Find end of 3rd arg and zero terminate <br>while((*pszTemp != 0) &amp;&amp; <br>  (*pszTemp != ' ')) pszTemp++; <br> <br>if (*pszTemp != 0) *pszTemp = 0; <br> <br>//Loop indefintely until ParseCommand returns false <br>if (ParseCommand(pszArg1, pszArg2, pszArg3) == FALSE) <br>return; <br> <br>} <br>} <br> <br>/////////////////////////////////////////////////////////// <br>// <br>//      ParseCommand Function <br>// <br>//      Input:   FTP command arguments <br>//      Returns: TRUE if any command called but quit <br>//               FALSE if command is quit <br>// <br>////////////////////////////////////////////////////////// <br>BOOL ParseCommand(char *pszArg1, char *pszArg2, char *pszArg3) <br>{ <br>_strupr(pszArg1); <br>    CHAR szFile1[256] ="", szFile2[256] ="", szTemp[256]; <br> <br>// Quit Command <br>if (lstrcmp(pszArg1, "QUIT") == 0) <br>return FALSE; <br> <br>// Get Command <br>else if (lstrcmp(pszArg1, "GET") == 0) <br>{ <br>    if (bActiveSession) <br>        { <br>            cout &lt;&lt; "Enter RemoteFile LocalFile: "; <br>            cin &gt;&gt; szFile1 &gt;&gt; szFile2; <br>            cin.getline(szTemp, 256); <br>            if (!FtpGetFile (hConnect,szFile1, szFile2, FALSE,INTERNET_FLAG_RELOAD, dwType, 0 ) ) <br>                ErrorOut (GetLastError(), "FtpGetFile"); <br>        } <br>        else <br>            cout &lt;&lt; "No active session" ; <br>        cout &lt;&lt; endl &lt;&lt; PROMPT; <br>} <br> <br>// Put Command <br>else if (lstrcmp(pszArg1, "PUT") == 0) <br>{ <br>    if (bActiveSession) <br>        { <br>            cout &lt;&lt; "Enter LocalFile RemoteFile : "; <br>            cin &gt;&gt; szFile1 &gt;&gt; szFile2; <br>            cin.getline(szTemp, 256); <br>            if (!FtpPutFile (hConnect,szFile1, szFile2, dwType, 0 ) ) <br>                ErrorOut (GetLastError(), "FtpPutFile"); <br>        } <br>        else <br>            cout &lt;&lt; "No active session" ; <br>        cout &lt;&lt; endl &lt;&lt; PROMPT; <br>} <br> <br>// Del Command <br>else if (lstrcmp(pszArg1, "DEL") == 0) <br>{ <br>    if (bActiveSession) <br>        { <br>            cout &lt;&lt; "Enter RemoteFile : "; <br>            cin &gt;&gt; szFile1; <br>            cin.getline(szTemp, 256); <br>            if (!FtpDeleteFile (hConnect,szFile1 ) ) <br>                ErrorOut (GetLastError(), "FtpDelFile"); <br>        } <br>        else <br>            cout &lt;&lt; "No active session" ; <br>        cout &lt;&lt; endl &lt;&lt; PROMPT; <br>} <br> <br>// Ren Command <br>else if (lstrcmp(pszArg1, "REN") == 0) <br>{ <br>    if (bActiveSession) <br>        { <br>            cout &lt;&lt; "Enter ExistingFile NewFile : "; <br>            cin &gt;&gt; szFile1 &gt;&gt; szFile2; <br>            cin.getline(szTemp, 256); <br>            if (!FtpRenameFile (hConnect,szFile1, szFile2 ) ) <br>                ErrorOut (GetLastError(), "FtpRenameFile"); <br>        } <br>        else <br>            cout &lt;&lt; "No active session" ; <br>        cout &lt;&lt; endl &lt;&lt; PROMPT; <br> <br>} <br> <br>// ls command <br>else if (lstrcmp(pszArg1, "LS") == 0) <br>{ <br>    if (bActiveSession) <br>            FtpEnumDirectory(); <br>        else <br>            cout &lt;&lt; "No active session" ; <br>        cout &lt;&lt; endl &lt;&lt; PROMPT; <br>} <br> <br>// md command <br>else if (lstrcmp(pszArg1, "MD") == 0) <br>{ <br>    if (bActiveSession) <br>        { <br>            cout &lt;&lt; "Enter Directory : "; <br>            cin &gt;&gt; szFile1; <br>            cin.getline(szTemp, 256); <br>            if (!FtpCreateDirectory (hConnect,szFile1 ) ) <br>                ErrorOut (GetLastError(), "FtpCreateDirectory"); <br>        } <br>        else <br>            cout &lt;&lt; "No active session" ; <br>        cout &lt;&lt; endl &lt;&lt; PROMPT; <br>} <br> <br>// rd command <br>else if (lstrcmp(pszArg1, "RD") == 0) <br>{ <br>    if (bActiveSession) <br>        { <br>            cout &lt;&lt; "Enter Directory : "; <br>            cin &gt;&gt; szFile1; <br>            cin.getline(szTemp, 256); <br>            if (!FtpRemoveDirectory (hConnect,szFile1 ) ) <br>                ErrorOut (GetLastError(), "FtpRemoveDirectory"); <br>        } <br>        else <br>            cout &lt;&lt; "No active session" ; <br>        cout &lt;&lt; endl &lt;&lt; PROMPT; <br>} <br> <br>// type command <br>else if (lstrcmp(pszArg1, "TYPE") == 0) <br>{ <br>        if (bActiveSession) <br>            type (pszArg2); <br>        else <br>            cout &lt;&lt; "No active session" &lt;&lt; endl &lt;&lt; PROMPT; <br>}    <br>     <br>// cd command <br>else if (lstrcmp(pszArg1, "CD") == 0) <br>{ <br>        if (bActiveSession) <br>            rcd (pszArg2); <br>        else <br>            cout &lt;&lt; "No active session" &lt;&lt; endl &lt;&lt; PROMPT; <br>} <br> <br>// lcd command <br>else if (lstrcmp(pszArg1, "LCD") == 0) <br>{ <br>lcd(pszArg2); <br>} <br> <br>// open command <br>else if (lstrcmp(pszArg1, "OPEN") == 0) <br>{ <br>        if (!bActiveSession) <br>        { <br>        if (Open (pszArg2)) <br>                cout &lt;&lt; "Connected to " &lt;&lt; pszArg2 &lt;&lt; endl &lt;&lt; PROMPT; <br>            else <br>                cout &lt;&lt; "Session closed" &lt;&lt; endl &lt;&lt; PROMPT;     <br>        }  <br>        else <br>            cout &lt;&lt; "Already connected to " &lt;&lt; szServer &lt;&lt; endl &lt;&lt; PROMPT; <br>            <br>} <br> <br>// close command <br>else if (lstrcmp(pszArg1, "CLOSE") == 0) <br>{ <br>        if (bActiveSession) <br>        { <br>        Close(); <br>            cout &lt;&lt; "Session closed" &lt;&lt; endl &lt;&lt; PROMPT; <br>        } <br>        else <br>            cout &lt;&lt; "No active session" &lt;&lt; endl &lt;&lt; PROMPT; <br>} <br> <br>// help command <br>else if (lstrcmp(pszArg1, "HELP") == 0) <br>{ <br>DisplayHelp(); <br>} <br> <br>// error Unknown command <br>else <br>{ <br>cout &lt;&lt; "?Unknown Command" &lt;&lt; endl &lt;&lt; PROMPT; <br>} <br>return TRUE; <br>} <br> <br>void DisplayHelp() <br>{ <br>cout &lt;&lt; "Commands are:" &lt;&lt; endl; <br>cout &lt;&lt; "   cd" &lt;&lt; endl; <br>cout &lt;&lt; "   close" &lt;&lt; endl; <br>cout &lt;&lt; "   del" &lt;&lt; endl; <br>cout &lt;&lt; "   get" &lt;&lt; endl; <br>cout &lt;&lt; "   help" &lt;&lt; endl; <br>cout &lt;&lt; "   lcd" &lt;&lt; endl; <br>cout &lt;&lt; "   ls" &lt;&lt; endl; <br>cout &lt;&lt; "   md" &lt;&lt; endl; <br>cout &lt;&lt; "   open" &lt;&lt; endl; <br>cout &lt;&lt; "   put" &lt;&lt; endl; <br>cout &lt;&lt; "   quit" &lt;&lt; endl; <br>cout &lt;&lt; "   rd" &lt;&lt; endl; <br>cout &lt;&lt; "   ren" &lt;&lt; endl; <br>cout &lt;&lt; "   type" &lt;&lt; endl; <br>    ShowUsage (); <br>cout &lt;&lt; endl &lt;&lt; PROMPT; <br>} <br> <br>void lcd(char *pszDir) <br>{ <br>if ((*pszDir != 0) &amp;&amp; (_chdir(pszDir) == -1)) <br>cout &lt;&lt; "?Invalid Local Directory" &lt;&lt; endl &lt;&lt; PROMPT; <br>else <br>{ <br>char dir[256]; <br>GetCurrentDirectory(256, dir); <br>cout &lt;&lt; "Local Directory is " &lt;&lt; dir &lt;&lt; endl &lt;&lt; PROMPT; <br>} <br>} <br> <br>void rcd(char *pszDir) <br>{ <br>    char dir[256]; <br>if (*pszDir != 0) <br>    { <br>if (!FtpSetCurrentDirectory (hConnect, pszDir)) <br>        { <br>            ErrorOut (GetLastError(), "FtpSetCurrentDirectory"); <br>            cout &lt;&lt;  PROMPT; <br>        } <br>        else     <br>    cout &lt;&lt; "Remote Directory is " &lt;&lt; pszDir &lt;&lt; endl &lt;&lt; PROMPT; <br>    }     <br>else <br>{ <br>        DWORD dwSize = sizeof(dir); <br>if (!FtpGetCurrentDirectory (hConnect, dir, &amp;dwSize)) <br>            cout &lt;&lt; "Can not determine current remote directory " &lt;&lt; endl &lt;&lt; PROMPT; <br>        else     <br>    cout &lt;&lt; "Remote Directory is " &lt;&lt; dir &lt;&lt; endl &lt;&lt; PROMPT; <br>} <br>} <br> <br>void type (char *szType) <br>{ <br>     <br>_strupr(szType);     <br>if (*szType != 0) <br>    { <br>    if (lstrcmp(szType, "BIN") == 0) <br>        { <br>    dwType = FTP_TRANSFER_TYPE_BINARY; <br>            cout &lt;&lt; "BIN mode selected"; <br>        } <br>    else if (lstrcmp(szType, "ASCII") == 0) <br>        { <br>    dwType = FTP_TRANSFER_TYPE_ASCII; <br>            cout &lt;&lt; "ASCII mode selected"; <br>        } <br>        else <br>            cout &lt;&lt; "Invalid mode"; <br>        cout &lt;&lt; endl &lt;&lt; PROMPT;     <br>    }     <br>else <br>{ <br>if ( dwType == FTP_TRANSFER_TYPE_BINARY) <br>            cout &lt;&lt; "BIN "; <br>        else     <br>    cout &lt;&lt; "ASCII "; <br>        cout &lt;&lt; "mode selected " &lt;&lt; endl &lt;&lt; PROMPT;     <br>} <br>} <br> <br> <br>void ShowUsage() <br>{ <br>cout &lt;&lt; "Syntax:" &lt;&lt; endl &lt;&lt; "  FTPJR &lt;proxy&gt;" &lt;&lt; endl ; <br>    cout &lt;&lt; "Note: a CERN style proxy will not work. You will need to "&lt;&lt; endl; <br>    cout &lt;&lt; "specify a TIS style FTP proxy in the form:" &lt;&lt; endl &lt;&lt; endl; <br>cout &lt;&lt; "     FTPJR ftp-gw" &lt;&lt; endl &lt;&lt; endl; <br>cout &lt;&lt; "where ftp-gw is the name of the host that is running the gateway" &lt;&lt; endl; <br>} <br> <br>BOOL Open (CHAR * szHost) <br>{ <br>    CHAR szUser[256], szPass[256]; <br>    if ( *szHost == 0) <br>    { <br>        cout &lt;&lt; "Enter host, user, pass: "; <br>        cin &gt;&gt; szHost &gt;&gt; szUser &gt;&gt; szPass; <br>    } <br>    else <br>    { <br>        cout &lt;&lt; "Enter user, pass: "; <br>        cin &gt;&gt; szUser &gt;&gt; szPass; <br>    } <br>    CHAR szTemp[256]; <br>    cin.getline(szTemp, 256); <br>    if ( !(hConnect = InternetConnect ( hOpen, szHost , INTERNET_INVALID_PORT_NUMBER, szUser,  szPass, INTERNET_SERVICE_FTP, INTERNET_FLAG_PASSIVE , 0) ) ) <br>    { <br>    ErrorOut (GetLastError(), "InternetConnect"); <br>        return FALSE; <br>    } <br>    bActiveSession = TRUE; <br>    lstrcpy (szServer, szHost); <br>    return TRUE; <br>} <br> <br>BOOL Close () <br>{ <br>    if (!InternetCloseHandle (hConnect) ) <br>    { <br>        ErrorOut (GetLastError(), "InternetCloseHandle"); <br>        return FALSE; <br>    } <br>    bActiveSession = FALSE; <br>    return TRUE; <br>} <br>     <br>void FtpEnumDirectory () <br>{ <br>WIN32_FIND_DATA pData; <br>HINTERNET hFind; <br>DWORD dError; <br> <br>// Start enumeration and get file handle <br>if ( !(hFind = FtpFindFirstFile (hConnect, TEXT ("*.*"), &amp;pData, 0, 0) )) <br>if (GetLastError()  == ERROR_NO_MORE_FILES)  <br>{ <br>cout &lt;&lt; "This directory is empty" &lt;&lt; endl; <br>return ; <br>} <br>else <br>{ <br>ErrorOut (GetLastError (), "FindFirst error: "); <br>return ; <br>} <br> <br>cout &lt;&lt; pData.cFileName; <br>if (pData.dwFileAttributes == FILE_ATTRIBUTE_DIRECTORY) <br>// Entry is a directory, mark it as such <br>cout &lt;&lt; " &lt;DIR&gt; " &lt;&lt; endl; <br>else <br>cout &lt;&lt; endl; <br> <br>dError = NO_ERROR; <br>do <br>{ <br> if (!InternetFindNextFile (hFind, &amp;pData)) <br> { <br> dError = GetLastError(); <br> if ( dError == ERROR_NO_MORE_FILES )  <br>break; <br> else <br> { <br> ErrorOut (dError, "InternetFindNextFile"); <br> return ; <br> } <br> } <br> else <br> { <br>cout &lt;&lt; pData.cFileName; <br>if (pData.dwFileAttributes == FILE_ATTRIBUTE_DIRECTORY) <br>cout &lt;&lt; " &lt;DIR&gt; " &lt;&lt; endl; <br>else <br>cout &lt;&lt; endl; <br> } <br>} <br>while ( TRUE); <br>if (!InternetCloseHandle (hFind) ) <br>{ <br>ErrorOut (GetLastError(), "InternetCloseHandle error"); <br>return ; <br>} <br>return ; <br>} <br> <br> <br>/**************************************************************************** <br>* <br>*    FUNCTION: ErrorOut <br>* <br>*    PURPOSE: This function is used to get extended Internet error. <br>* <br>*    COMMENTS:  Function returns TRUE on success and FALSE on failure. <br>* <br>****************************************************************************/ <br> <br>BOOL ErrorOut ( DWORD dError, TCHAR * szCallFunc) <br>{ <br>    TCHAR szTemp[100] = "", *szBuffer=NULL, *szBufferFinal = NULL; <br>    DWORD  dwIntError , dwLength = 0;  <br>    wsprintf (szTemp,  "%s error %d\n ", szCallFunc, dError ); <br>if (dError == ERROR_INTERNET_EXTENDED_ERROR) <br>{ <br>InternetGetLastResponseInfo (&amp;dwIntError, NULL, &amp;dwLength); <br>if (dwLength) <br>{ <br>if ( !(szBuffer = (TCHAR *) LocalAlloc ( LPTR,  dwLength) ) ) <br>{ <br>lstrcat (szTemp, TEXT ( "Unable to allocate memory to display Internet error code. Error code: ") ); <br>lstrcat (szTemp, TEXT (_itoa (GetLastError(), szBuffer, 10)  ) ); <br>lstrcat (szTemp, TEXT ("\n") ); <br>cerr &lt;&lt; szTemp &lt;&lt; endl; <br>return FALSE; <br>} <br>if (!InternetGetLastResponseInfo (&amp;dwIntError, (LPTSTR) szBuffer, &amp;dwLength)) <br>{ <br>lstrcat (szTemp, TEXT ( "Unable to get Intrnet error. Error code: ") ); <br>lstrcat (szTemp, TEXT (_itoa (GetLastError(), szBuffer, 10)  ) ); <br>lstrcat (szTemp, TEXT ("\n") ); <br>cerr &lt;&lt; szTemp &lt;&lt; endl; <br>return FALSE; <br>} <br>if ( !(szBufferFinal = (TCHAR *) LocalAlloc ( LPTR,  (strlen (szBuffer) +strlen (szTemp) + 1)  ) )  ) <br>{ <br>lstrcat (szTemp, TEXT ( "Unable to allocate memory. Error code: ") ); <br>lstrcat (szTemp, TEXT (_itoa (GetLastError(), szBuffer, 10)  ) ); <br>lstrcat (szTemp, TEXT ("\n") ); <br>cerr &lt;&lt; szTemp &lt;&lt; endl; <br>return FALSE; <br>} <br>lstrcpy (szBufferFinal, szTemp); <br>lstrcat (szBufferFinal, szBuffer); <br>LocalFree (szBuffer); <br>cerr &lt;&lt;  szBufferFinal  &lt;&lt; endl; <br>LocalFree (szBufferFinal); <br>} <br>} <br>else <br>        cerr &lt;&lt; szTemp &lt;&lt; endl; <br>    return TRUE; <br>} <br>  <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
