<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>IEMIMECTL.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3901"></a>IEMIMECTL.CPP</h2>
<pre><code>// IEMimeCtl.cpp : Implementation of CIEMimeCtl <br>#include "stdafx.h" <br> <br>#include "IEMime.h" <br>#include "IEMimeCtl.h" <br> <br>#include "dispids.h" <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// CIEMimeCtl <br> <br> <br>HRESULT CIEMimeCtl::OnDraw(ATL_DRAWINFO&amp; di) <br>{ <br>RECT&amp; rc = *(RECT*)di.prcBounds; <br> <br>HDC hdc  = di.hdcDraw; <br>HBRUSH    hOldBrush, hBrush; <br>    HPEN      hOldPen, hPen; <br>hPen = (HPEN)GetStockObject(BLACK_PEN); <br>    hOldPen = (HPEN)SelectObject(hdc, hPen); <br>    hBrush = (HBRUSH)GetStockObject(WHITE_BRUSH); <br>    hOldBrush = (HBRUSH)SelectObject(hdc, hBrush); <br>Rectangle(hdc, rc.left, rc.top, rc.right, rc.bottom); <br> <br>SetBkMode(di.hdcDraw,TRANSPARENT); <br>SetTextColor(di.hdcDraw,RGB(0,0,255)); <br>if (!m_bstrCFFormat) // Empty - don't draw text <br>return S_OK; <br> <br>ATLTRACE(_T("    m_bstrCFFormat=%s\n"),(LPTSTR)m_bstrCFFormat); <br>rc.left += 5; // small left margin <br>DrawText(di.hdcDraw, m_bstrCFFormat, m_bstrCFFormat.length(), &amp;rc,   <br>DT_LEFT | DT_WORD_ELLIPSIS | DT_SINGLELINE); <br> <br>SelectObject(hdc, hOldPen); <br>    SelectObject(hdc, hOldBrush); <br> <br>return S_OK; <br>} <br> <br>STDMETHODIMP CIEMimeCtl::get_URL(BSTR * pVal) <br>{ <br>//*pVal = m_bstrURL.copy(); <br>// NOTE: _bstr_t::copy() has a BUG in VC5.0 that is fixed in VS5 SP1. See KB Q151491. <br>*pVal = ::SysAllocString(static_cast&lt;const wchar_t*&gt;(m_bstrURL)); <br> <br>return S_OK; <br>} <br> <br>STDMETHODIMP CIEMimeCtl::put_URL(BSTR newVal) <br>{ <br>m_bstrURL = newVal; <br> <br>FireOnChanged(DISPID_URL); <br> <br>if (!m_bstrURL) // NULL string <br>return S_OK; <br> <br>if (READYSTATE_LOADING != m_nReadyState)  // Wait until control is done loading before <br>Reload();  // firing off download <br> <br>    return S_OK; <br>} <br> <br>STDMETHODIMP CIEMimeCtl::get_Media(BSTR * pVal) <br>{ <br>//*pVal = m_bstrMedia.copy(); <br>// NOTE: _bstr_t::copy() has a BUG in VC5.0 that is fixed in VS5 SP1. See KB Q151491. <br>*pVal = ::SysAllocString(static_cast&lt;const wchar_t*&gt;(m_bstrMedia)); <br> <br>return S_OK; <br>} <br> <br>STDMETHODIMP CIEMimeCtl::put_Media(BSTR newVal) <br>{ <br>m_bstrMedia = newVal; <br> <br>FireOnChanged(DISPID_MEDIA); <br> <br>    return S_OK; <br>} <br> <br>STDMETHODIMP CIEMimeCtl::get_Cfformat(BSTR * pVal) <br>{ <br>*pVal = m_bstrCFFormat.copy(); <br> <br>return S_OK; <br>} <br> <br>STDMETHODIMP CIEMimeCtl::AboutBox() <br>{ <br>// The following is necessary to prepare the frame for showing a modal dialog box <br>HRESULT hr; <br>OLEINPLACEFRAMEINFO frameInfo; <br>RECT rcPos, rcClip; <br>CComPtr&lt;IOleInPlaceFrame&gt; spInPlaceFrame; <br>CComPtr&lt;IOleInPlaceUIWindow&gt; spInPlaceUIWindow; <br>frameInfo.cb = sizeof(OLEINPLACEFRAMEINFO); <br>HWND hwndFrame = NULL; <br> <br>if (m_spInPlaceSite) <br>{ <br>m_spInPlaceSite-&gt;GetWindowContext(&amp;spInPlaceFrame, <br>&amp;spInPlaceUIWindow, &amp;rcPos, &amp;rcClip, &amp;frameInfo); <br>if (spInPlaceFrame) <br>{ <br>spInPlaceFrame-&gt;GetWindow(&amp;hwndFrame); <br>hr = spInPlaceFrame-&gt;EnableModeless(FALSE); <br>if (FAILED(hr)) <br>return S_OK;  // Failed, but we don't want to send errors back to script <br>} <br>} <br>// ------------------------------------------------------------------------------- <br> <br>    ::MessageBox(hwndFrame, _T("This is My Control"), _T("About iemim"), MB_OK | MB_TASKMODAL); <br> <br>// Tell frame our modal dialog box has gone away <br>if (spInPlaceFrame) <br>{ <br>spInPlaceFrame-&gt;EnableModeless(TRUE); <br>} <br>// -------------------------------------------- <br> <br>return S_OK; <br>} <br> <br>STDMETHODIMP CIEMimeCtl::Reload() <br>{ <br>if (!m_bstrURL) // NO OP <br>return S_OK; <br>else <br>{ <br>m_nReadyState = READYSTATE_INTERACTIVE; <br>FireOnChanged(DISPID_READYSTATE); <br>CBindStatusCallback2&lt;CIEMimeCtl&gt;::Download(this, OnData, m_bstrURL, m_spClientSite, FALSE); <br>} <br> <br>return S_OK; <br>} <br> <br>HRESULT CIEMimeCtl::PreBindMoniker(CComPtr&lt;IBindCtx&gt; pBindCtx, CComPtr&lt;IMoniker&gt; pMoniker) <br>{ <br>HRESULT hr = S_OK; <br> <br>if (!(m_bstrMedia)) // No MIME registration of our own, default <br>return S_OK;    // will give us an accept-type of "*/*" <br> <br>LPSTR rgszTypes[1]; <br>CLIPFORMAT cfFormats[1]; <br>cfFormats[0] = CF_NULL; <br> <br>// Register m_bstrMedia as a media-type. This will either give us <br>// the CLIPFORMAT of an existing media-type or create a new one for us. <br>rgszTypes[0] = (LPSTR)(m_bstrMedia); <br>if (SUCCEEDED(hr)) <br>hr = RegisterMediaTypes(1, (LPSTR*)&amp;rgszTypes, cfFormats); <br> <br>FORMATETC rgfmtetc[1] =  <br>{ {CF_NULL, NULL, DVASPECT_CONTENT, -1, TYMED_NULL} }; <br>IEnumFORMATETC *pMyEtc = NULL; <br> <br>// Create and register a FORMATETC enumerator for our (potentially custom) <br>// media type. Basically this has the equivalent effect of telling URLMON <br>// to use this media type for the HTTP Accept-types header. <br>// (this won't come into play for file://) <br>rgfmtetc[0].cfFormat = cfFormats[0]; <br>hr = CreateFormatEnumerator (1, rgfmtetc, &amp;pMyEtc); <br>if (SUCCEEDED(hr) &amp;&amp; pMyEtc) <br>{ <br>hr = RegisterFormatEnumerator(pBindCtx, pMyEtc, 0); <br>_ASSERTE(SUCCEEDED(hr)); <br>} <br> <br>return hr; <br>} <br> <br>void CIEMimeCtl::OnBindingFailure(HRESULT hr, LPCWSTR szError) <br>{ <br>if (NULL != szError &amp;&amp; NULL != *szError) <br>m_bstrCFFormat = szError; <br>else <br>{ <br>// Convert HR to human-readable string <br>if (INET_E_NO_VALID_MEDIA == hr) <br>m_bstrCFFormat = _T("&lt;Resource at URL does not match Media type&gt;"); <br>else <br>m_bstrCFFormat = _T("&lt;Failed to download&gt;"); <br>} <br> <br>m_nReadyState = READYSTATE_COMPLETE; <br>FireOnChanged(DISPID_READYSTATE); <br>FireViewChange(); <br> <br>} <br> <br>//OnData will be used as a callback functin by the CBindStatusCallback object. <br>//OnData will be called periodically with data from the asynchronous transfer <br>void CIEMimeCtl::OnData(CBindStatusCallback2&lt;CIEMimeCtl&gt;* pbsc, BYTE* pBytes, DWORD dwSize, <br>DWORD grfBSCF, FORMATETC *pformatetc, STGMEDIUM *pstgmed) <br>{ <br>static TCHAR formatname[MAX_PATH]; <br> <br>GetClipboardFormatName(pformatetc-&gt;cfFormat, formatname, MAX_PATH); <br>m_bstrCFFormat = formatname; <br> <br>FireOnChanged(DISPID_CFFORMAT); <br> <br>if (grfBSCF &amp; BSCF_LASTDATANOTIFICATION) <br>{ <br>Fire_Complete(); // Fire the "Complete" event <br>m_nReadyState = READYSTATE_COMPLETE; <br>FireOnChanged(DISPID_READYSTATE); <br>FireViewChange(); <br>} <br> <br>} <br> <br>// From ATLCTL.H, line 842 <br>STDMETHODIMP CIEMimeCtl::FreezeEvents(BOOL bFreeze) <br>{ <br>ATLTRACE(_T("IOleControlImpl::FreezeEvents\n")); <br>if (bFreeze) <br>m_nFreezeEvents++; <br>else <br>{ <br>m_nFreezeEvents--; <br>// Modified this so that we wait until container is <br>// set before downloading <br>if (!m_nFreezeEvents) <br>{ <br>// Let's go! <br>Reload(); <br>} <br>} <br> <br>return S_OK; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
