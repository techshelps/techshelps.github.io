<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>IEMIMECTL.H</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3902"></a>IEMIMECTL.H</h2>
<pre><code>// IEMimeCtl.h : Declaration of the CIEMimeCtl <br> <br>#ifndef __IEMIMECTL_H_ <br>#define __IEMIMECTL_H_ <br> <br>#include "resource.h"       // main symbols <br> <br>#include "CPIEMime.h" // Event interface Connection Point <br>#include "BSCbck.h"   // Bind-status-callback download implementation <br>// We're using VC5 COM support (_bstr_t and smart pointers) <br>#include &lt;comdef.h&gt; <br> <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// CIEMimeCtl <br>class ATL_NO_VTABLE CIEMimeCtl : <br>public CComObjectRootEx&lt;CComSingleThreadModel&gt;, <br>public CComCoClass&lt;CIEMimeCtl,&amp;CLSID_IEMimeCtl&gt;, <br>public CComControl&lt;CIEMimeCtl&gt;, <br>public IDispatchImpl&lt;IIEMimeCtl, &amp;IID_IIEMimeCtl, &amp;LIBID_IEMIMELib&gt;, <br>public IPersistStreamInitImpl&lt;CIEMimeCtl&gt;, <br>public IOleControlImpl&lt;CIEMimeCtl&gt;, <br>public IOleObjectImpl&lt;CIEMimeCtl&gt;, <br>public IOleInPlaceActiveObjectImpl&lt;CIEMimeCtl&gt;, <br>public IViewObjectExImpl&lt;CIEMimeCtl&gt;, <br>public IConnectionPointContainerImpl&lt;CIEMimeCtl&gt;, <br>public IOleInPlaceObjectWindowlessImpl&lt;CIEMimeCtl&gt;, <br>public IPersistPropertyBagImpl&lt;CIEMimeCtl&gt;, <br>public IPerPropertyBrowsingImpl&lt;CIEMimeCtl&gt;, <br>public IObjectSafetyImpl&lt;CIEMimeCtl&gt;, <br>public CProxyDIEMimeEvents&lt;CIEMimeCtl&gt;, <br>public IPropertyNotifySinkCP&lt;CIEMimeCtl, CComDynamicUnkArray&gt;, <br>public IProvideClassInfo2Impl&lt;&amp;CLSID_IEMimeCtl, &amp;DIID__IEMimeEvents, &amp;LIBID_IEMIMELib&gt; <br>{ <br>public: <br>CIEMimeCtl() <br>{ <br>m_nReadyState = READYSTATE_UNINITIALIZED; <br>} <br> <br>DECLARE_REGISTRY_RESOURCEID(IDR_IEMIMECTL) <br> <br>BEGIN_COM_MAP(CIEMimeCtl)  <br>COM_INTERFACE_ENTRY(IDispatch) <br>COM_INTERFACE_ENTRY(IIEMimeCtl) <br>COM_INTERFACE_ENTRY_IMPL_IID(IID_IViewObject, IViewObjectEx) <br>COM_INTERFACE_ENTRY_IMPL_IID(IID_IViewObject2, IViewObjectEx) <br>COM_INTERFACE_ENTRY_IMPL(IViewObjectEx) <br>COM_INTERFACE_ENTRY_IMPL_IID(IID_IOleWindow, IOleInPlaceObjectWindowless) <br>COM_INTERFACE_ENTRY_IMPL_IID(IID_IOleInPlaceObject, IOleInPlaceObjectWindowless) <br>COM_INTERFACE_ENTRY_IMPL(IOleInPlaceObjectWindowless) <br>COM_INTERFACE_ENTRY_IMPL(IOleInPlaceActiveObject) <br>COM_INTERFACE_ENTRY_IMPL(IOleControl) <br>COM_INTERFACE_ENTRY_IMPL(IOleObject) <br>COM_INTERFACE_ENTRY_IMPL(IPersistStreamInit) <br>COM_INTERFACE_ENTRY_IMPL_IID(IID_IPersist, IPersistPropertyBag) <br>COM_INTERFACE_ENTRY_IMPL(IPersistPropertyBag) <br>COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer) <br>COM_INTERFACE_ENTRY_IMPL(IObjectSafety) <br>COM_INTERFACE_ENTRY(IProvideClassInfo2) <br>COM_INTERFACE_ENTRY_IID(IID_IProvideClassInfo, IProvideClassInfo2) <br>END_COM_MAP() <br> <br>BEGIN_PROPERTY_MAP(CIEMimeCtl) <br>PROP_ENTRY("URL", 1, CLSID_NULL) <br>PROP_ENTRY("Media", 2, CLSID_NULL) <br>END_PROPERTY_MAP() <br> <br>BEGIN_CONNECTION_POINT_MAP(CIEMimeCtl) <br>CONNECTION_POINT_ENTRY(DIID__IEMimeEvents) <br>CONNECTION_POINT_ENTRY(IID_IPropertyNotifySink) <br>END_CONNECTION_POINT_MAP() <br> <br>BEGIN_MSG_MAP(CIEMimeCtl) <br>MESSAGE_HANDLER(WM_PAINT, OnPaint) <br>MESSAGE_HANDLER(WM_SETFOCUS, OnSetFocus) <br>MESSAGE_HANDLER(WM_KILLFOCUS, OnKillFocus) <br>END_MSG_MAP() <br> <br>// IViewObjectEx <br>STDMETHOD(GetViewStatus)(DWORD* pdwStatus) <br>{ <br>ATLTRACE(_T("IViewObjectExImpl::GetViewStatus\n")); <br>*pdwStatus = VIEWSTATUS_SOLIDBKGND | VIEWSTATUS_OPAQUE; <br>return S_OK; <br>} <br> <br>// IIEMimeCtl <br>public: <br>STDMETHOD(Reload)(); <br>STDMETHOD(AboutBox)(); <br>STDMETHOD(get_Cfformat)(/*[out, retval]*/ BSTR *pVal); <br>//STDMETHOD(put_Cfformat)(/*[in]*/ BSTR newVal); // PUT not supported <br>STDMETHOD(get_Media)(/*[out, retval]*/ BSTR *pVal); <br>STDMETHOD(put_Media)(/*[in]*/ BSTR newVal); <br>STDMETHOD(get_URL)(/*[out, retval]*/ BSTR *pVal); <br>STDMETHOD(put_URL)(/*[in]*/ BSTR newVal);  <br>HRESULT OnDraw(ATL_DRAWINFO&amp; di); <br> <br>// IOleControl override <br>STDMETHOD(FreezeEvents)(BOOL bFreeze); <br> <br>// IPersistPropertybag override <br>STDMETHOD(Load)(LPPROPERTYBAG pPropBag, LPERRORLOG pErrorLog) <br>{ <br>ATLTRACE(_T("IPersistPropertyBagImpl::Load\n")); <br>ATL_PROPMAP_ENTRY* pMap = GetPropertyMap(); <br>_ASSERTE(pMap != NULL); <br>m_nReadyState = READYSTATE_LOADING; // ADDED <br>FireOnChanged(DISPID_READYSTATE); <br>HRESULT hr = IPersistPropertyBag_Load(pPropBag, pErrorLog, pMap); <br>m_nReadyState = READYSTATE_COMPLETE;// ADDED <br>// Saying we're complete lets MSHTML proceed. See README.TXT for details. <br>FireOnChanged(DISPID_READYSTATE); <br>return hr; <br>} <br> <br>void OnData(CBindStatusCallback2&lt;CIEMimeCtl&gt;* pbsc, BYTE* pBytes, DWORD dwSize, <br>DWORD grfBSCF, FORMATETC *pformatetc, STGMEDIUM *pstgmed); <br> <br>HRESULT PreBindMoniker(CComPtr&lt;IBindCtx&gt; pBindCtx, CComPtr&lt;IMoniker&gt; pMoniker); <br> <br>void OnBindingFailure(HRESULT hr, LPCWSTR szError); <br> <br>// IObjectSafetyImpl doesn't support safe-for-persistence naturally. <br>// See Microsoft Knowledge Base article Q168371 for more details on the following <br>STDMETHOD(GetInterfaceSafetyOptions)(REFIID riid, <br>DWORD *pdwSupportedOptions, <br>DWORD *pdwEnabledOptions) <br>{ <br>   ATLTRACE(_T("CObjectSafetyImpl::GetInterfaceSafetyOptions\n")); <br>   if (!pdwSupportedOptions || !pdwEnabledOptions) <br>  return E_FAIL; <br>   LPUNKNOWN pUnk; <br>   if (_InternalQueryInterface (riid, (void**)&amp;pUnk) == E_NOINTERFACE) <br>  // Our object doesn't even support this interface. <br>  return E_NOINTERFACE; <br>   else <br>   { <br>  // Cleanup after ourselves. <br>  pUnk-&gt;Release(); <br>  pUnk = NULL; <br>   } <br>   if (riid == IID_IDispatch)  <br>   { <br>  *pdwSupportedOptions = INTERFACESAFE_FOR_UNTRUSTED_CALLER; <br>  *pdwEnabledOptions = m_dwSafety &amp; <br>   INTERFACESAFE_FOR_UNTRUSTED_CALLER; <br>  return S_OK; <br>// IEMime only supports persistence via IPersistPropertyBag <br>   } <br>   else if (riid == IID_IPersistPropertyBag)  <br>   { <br>  *pdwSupportedOptions = INTERFACESAFE_FOR_UNTRUSTED_DATA; <br>  *pdwEnabledOptions = m_dwSafety &amp; <br>   INTERFACESAFE_FOR_UNTRUSTED_DATA; <br>  return S_OK; <br>   } <br>   else <br>   { <br>  // No other interfaces in this control are <br>  // safe for initializing or scripting. <br>  *pdwSupportedOptions = 0; <br>  *pdwEnabledOptions = 0; <br>  return E_FAIL; <br>   } <br>} <br> <br>   STDMETHOD(SetInterfaceSafetyOptions)(REFIID riid, <br>                                     DWORD dwOptionSetMask, <br>                                     DWORD dwEnabledOptions) <br>   { <br>   ATLTRACE(_T("CObjectSafetyImpl::SetInterfaceSafetyOptions\n")); <br>   if (!dwOptionSetMask &amp;&amp; !dwEnabledOptions) return E_FAIL; <br>   LPUNKNOWN pUnk; <br>   if (_InternalQueryInterface (riid, (void**)&amp;pUnk) == E_NOINTERFACE) <br>  // Our object doesn't even support this interface. <br>  return E_NOINTERFACE; <br>   else <br>   { <br>  // Cleanup after ourselves. <br>  pUnk-&gt;Release(); <br>  pUnk = NULL; <br>   } <br>   // Store our current safety level to return in <br>   // GetInterfaceSafetyOptions <br>   m_dwSafety |= dwEnabledOptions &amp; dwOptionSetMask; <br>   if ((riid == IID_IDispatch) &amp;&amp; <br>   (m_dwSafety &amp; INTERFACESAFE_FOR_UNTRUSTED_CALLER)) <br>  return S_OK; <br>   else if ((riid == IID_IPersistPropertyBag) &amp;&amp; <br> (m_dwSafety &amp; INTERFACESAFE_FOR_UNTRUSTED_DATA)) <br>  return S_OK; <br>   else <br>  return E_FAIL; <br>   } <br> <br>// ReadyState property - not using CStockPropImpl because we only want this one stock-prop <br>//                       and we only want it to be read-only <br>long m_nReadyState; <br> <br>HRESULT STDMETHODCALLTYPE get_ReadyState(long* pnReadyState) <br>{ <br>ATLTRACE(_T("CIEMimeCTL - get_ReadyState - %d\n"),m_nReadyState); <br> <br>*pnReadyState = m_nReadyState; <br>return S_OK; <br>} <br> <br>public: <br>_bstr_t m_bstrURL; <br>_bstr_t m_bstrMedia; <br>_bstr_t m_bstrCFFormat; <br> <br>}; <br> <br>#endif //__IEMIMECTL_H_ </code></pre>
<p>&nbsp;</p></body>
</HTML>
