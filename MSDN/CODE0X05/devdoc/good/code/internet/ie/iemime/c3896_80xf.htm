<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>BSCBCK.H</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3903"></a>BSCBCK.H</h2>
<pre><code>// CBindStatusCallback2 -- we want a little more info than it is giving us, such as  <br>//      C&amp;P'ed from ATL -- see ADDED below for additons, CHANGED for changes... <br> <br>// PreBindMoniker() &amp; OnBindingFailure() must be implemented in using class T <br> <br>template &lt;class T&gt; <br>class ATL_NO_VTABLE CBindStatusCallback2 : <br>public CComObjectRootEx&lt;T::_ThreadModel::ThreadModelNoCS&gt;, <br>public IBindStatusCallbackImpl&lt;T&gt; <br>{ <br>// CHANGED from CBindStatusCallback <br>typedef void (T::*ATL_PDATAAVAILABLE)(CBindStatusCallback2&lt;T&gt;* pbsc, BYTE* pBytes, DWORD dwSize, <br>DWORD grfBSCF, FORMATETC *pformatetc, STGMEDIUM *pstgmed); <br>// ------- <br> <br>public: <br> <br>BEGIN_COM_MAP(CBindStatusCallback2&lt;T&gt;) <br>COM_INTERFACE_ENTRY_IID(IID_IBindStatusCallback, IBindStatusCallbackImpl&lt;T&gt;) <br>END_COM_MAP() <br> <br> <br>CBindStatusCallback2() <br>{ <br>m_pT = NULL; <br>m_pFunc = NULL; <br>} <br>~CBindStatusCallback2() <br>{ <br>ATLTRACE(_T("~CBindStatusCallback2\n")); <br>} <br> <br>STDMETHOD(OnStartBinding)(DWORD dwReserved, IBinding *pBinding) <br>{ <br>ATLTRACE(_T("CBindStatusCallback2::OnStartBinding\n")); <br>m_spBinding = pBinding; <br>return S_OK; <br>} <br> <br>STDMETHOD(GetPriority)(LONG *pnPriority) <br>{ <br>ATLTRACENOTIMPL(_T("CBindStatusCallback2::GetPriority")); <br>} <br> <br>STDMETHOD(OnLowResource)(DWORD reserved) <br>{ <br>ATLTRACENOTIMPL(_T("CBindStatusCallback2::OnLowResource")); <br>} <br> <br>STDMETHOD(OnProgress)(ULONG ulProgress, ULONG ulProgressMax, ULONG ulStatusCode, LPCWSTR szStatusText) <br>{ <br>//ATLTRACENOTIMPL(_T("CBindStatusCallback2::OnProgress")); <br>ATLTRACE(_T("CBindStatusCallback2::OnProgress : progress=%d / %d - status=%x\n"), ulProgress, ulProgressMax, ulStatusCode); <br>_bstr_t strStatusText = szStatusText; <br>ATLTRACE(_T("     status-text=%s\n"),(LPCTSTR)strStatusText); <br>return E_NOTIMPL; <br>} <br> <br>STDMETHOD(OnStopBinding)(HRESULT hresult, LPCWSTR szError) <br>{ <br>ATLTRACE(_T("CBindStatusCallback2::OnStopBinding\n")); <br> <br>if (FAILED(hresult)) <br>m_pT-&gt;OnBindingFailure(hresult, szError); <br> <br>m_spBinding.Release();// ADDED <br>m_spBindCtx.Release(); <br>m_spMoniker.Release(); <br> <br>return S_OK; <br>} <br> <br>STDMETHOD(GetBindInfo)(DWORD *pgrfBINDF, BINDINFO *pbindInfo) <br>{ <br>ATLTRACE(_T("CBindStatusCallback2::GetBindInfo\n")); <br>if (!pbindInfo || !pbindInfo-&gt;cbSize || !pgrfBINDF) <br>return E_INVALIDARG; <br>*pgrfBINDF = BINDF_ASYNCHRONOUS | BINDF_ASYNCSTORAGE | <br>BINDF_GETNEWESTVERSION | BINDF_NOWRITECACHE; <br> <br>// NOTE: BINDINFO has changed sizes between IE3 and IE4 <br>// Relying on a compiled sizeof(BINDINFO) can cause trouble. <br>// The following changes will propagate to later versions of <br>// ATL. <br> <br>// Remember incoming cbSize <br>ULONG cbSize = pbindInfo-&gt;cbSize; <br> <br>memset(pbindInfo, 0, cbSize); <br> <br>// Restore cbSize <br>pbindInfo-&gt;cbSize = cbSize; <br>pbindInfo-&gt;dwBindVerb = BINDVERB_GET; <br> <br>return S_OK; <br>} <br> <br>STDMETHOD(OnDataAvailable)(DWORD grfBSCF, DWORD dwSize, FORMATETC *pformatetc, STGMEDIUM *pstgmed) <br>{ <br>ATLTRACE(_T("CBindStatusCallback2::OnDataAvailable\n")); <br>HRESULT hr = S_OK; <br> <br>// Get the Stream passed <br>if (BSCF_FIRSTDATANOTIFICATION &amp; grfBSCF) <br>{ <br>if (!m_spStream &amp;&amp; pstgmed-&gt;tymed == TYMED_ISTREAM) <br>{ <br>m_spStream = pstgmed-&gt;pstm; <br>/*if (m_spStream) <br>m_spStream-&gt;AddRef();*/ // CHANGED <br>} <br>} <br> <br>DWORD dwRead = dwSize - m_dwTotalRead; // Minimum amount available that hasn't been read <br>DWORD dwActuallyRead = 0;              // Placeholder for amount read during this pull <br> <br>// If there is some data to be read then go ahead and read them <br>if (m_spStream) <br>{ <br>if (dwRead &gt; 0) <br>{ <br>BYTE* pBytes = NULL; <br>ATLTRY(pBytes = new BYTE[dwRead + 1]); <br>if (pBytes == NULL) <br>return S_FALSE; <br>hr = m_spStream-&gt;Read(pBytes, dwRead, &amp;dwActuallyRead); <br>if (SUCCEEDED(hr)) <br>{ <br>pBytes[dwActuallyRead] = 0; <br>if (dwActuallyRead&gt;0) <br>{ <br>// CHANGED <br>(m_pT-&gt;*m_pFunc)(this, pBytes, dwActuallyRead, grfBSCF, pformatetc, pstgmed); <br>// ------- <br>m_dwTotalRead += dwActuallyRead; <br>} <br>} <br>delete[] pBytes; <br>} <br>} <br> <br>if (BSCF_LASTDATANOTIFICATION &amp; grfBSCF) <br>m_spStream.Release(); <br>return hr; <br>} <br> <br>STDMETHOD(OnObjectAvailable)(REFIID riid, IUnknown *punk) <br>{ <br>ATLTRACENOTIMPL(_T("CBindStatusCallback2::OnObjectAvailable")); <br>} <br> <br>HRESULT _StartAsyncDownload(BSTR bstrURL, IUnknown* pUnkContainer, BOOL bRelative) <br>{ <br>m_dwTotalRead = 0; <br>m_dwAvailableToRead = 0; <br>HRESULT hr = S_OK; <br>CComQIPtr&lt;IServiceProvider, &amp;IID_IServiceProvider&gt; spServiceProvider(pUnkContainer); <br>CComPtr&lt;IBindHost&gt; spBindHost; <br>if (spServiceProvider) <br>spServiceProvider-&gt;QueryService(SID_IBindHost, IID_IBindHost, (void**)&amp;spBindHost); <br> <br>if (spBindHost == NULL) <br>{ <br>if (bRelative) <br>return E_NOINTERFACE;  // relative asked for, but no IBindHost <br>hr = CreateURLMoniker(NULL, bstrURL, &amp;m_spMoniker); <br> <br>if (SUCCEEDED(hr)) <br>hr = CreateBindCtx(0, &amp;m_spBindCtx); <br> <br>if (SUCCEEDED(hr)) <br>hr = RegisterBindStatusCallback(m_spBindCtx, reinterpret_cast&lt;IBindStatusCallback*&gt;(static_cast&lt;IBindStatusCallbackImpl&lt;T&gt;*&gt;(this)), 0, 0L); <br>else <br>m_spMoniker.Release(); <br> <br>// ADDED to CBindStatusCallback <br>if (SUCCEEDED(hr)) <br>hr = m_pT-&gt;PreBindMoniker(m_spBindCtx, m_spMoniker); <br>// ----- <br> <br>if (SUCCEEDED(hr)) <br>{ <br>IStream* pStream; <br>hr = m_spMoniker-&gt;BindToStorage(m_spBindCtx, 0, IID_IStream, (void**)&amp;pStream); <br>if (pStream != NULL) // ADDED <br>pStream-&gt;Release(); <br>} <br>} <br>else <br>{ <br>hr = CreateBindCtx(0, &amp;m_spBindCtx); <br> <br>/*if (SUCCEEDED(hr)) <br>hr = RegisterBindStatusCallback(m_spBindCtx, reinterpret_cast&lt;IBindStatusCallback*&gt;(static_cast&lt;IBindStatusCallbackImpl&lt;T&gt;*&gt;(this)), 0, 0L);*/ <br>// If we're working through the IBindHost interface, we should specify the <br>// IBSC on MonikerBindToStorage, not registered on the IBindCtx <br> <br>if (SUCCEEDED(hr)) <br>{ <br>if (bRelative) <br>hr = spBindHost-&gt;CreateMoniker(bstrURL, m_spBindCtx, &amp;m_spMoniker, 0); <br>else <br>hr = CreateURLMoniker(NULL, bstrURL, &amp;m_spMoniker); <br>} <br> <br>// ADDED <br>if (SUCCEEDED(hr)) <br>hr = m_pT-&gt;PreBindMoniker(m_spBindCtx, m_spMoniker); <br>// ----- <br> <br>if (SUCCEEDED(hr)) <br>{ <br>IStream* pStream; <br>hr = spBindHost-&gt;MonikerBindToStorage(m_spMoniker, m_spBindCtx, reinterpret_cast&lt;IBindStatusCallback*&gt;(static_cast&lt;IBindStatusCallbackImpl&lt;T&gt;*&gt;(this)), IID_IStream, (void**)&amp;pStream); <br>if (pStream != NULL) // ADDED <br>pStream-&gt;Release(); <br>ATLTRACE(_T("Bound")); <br>} <br>} <br>return hr; <br>} <br> <br>HRESULT StartAsyncDownload(T* pT, ATL_PDATAAVAILABLE pFunc, BSTR bstrURL, IUnknown* pUnkContainer = NULL, BOOL bRelative = FALSE) <br>{ <br>m_pT = pT; <br>m_pFunc = pFunc; <br>return  _StartAsyncDownload(bstrURL, pUnkContainer, bRelative); <br>} <br> <br>static HRESULT Download(T* pT, ATL_PDATAAVAILABLE pFunc, BSTR bstrURL, IUnknown* pUnkContainer = NULL, BOOL bRelative = FALSE) <br>{ <br>CComObject&lt;CBindStatusCallback2&lt;T&gt; &gt; *pbsc; <br>HRESULT hRes = CComObject&lt;CBindStatusCallback2&lt;T&gt; &gt;::CreateInstance(&amp;pbsc); <br>if (FAILED(hRes)) <br>return hRes; <br>return pbsc-&gt;StartAsyncDownload(pT, pFunc, bstrURL, pUnkContainer, bRelative); <br>} <br> <br>CComPtr&lt;IMoniker&gt; m_spMoniker; <br>CComPtr&lt;IBindCtx&gt; m_spBindCtx; <br>CComPtr&lt;IBinding&gt; m_spBinding; <br>CComPtr&lt;IStream&gt; m_spStream; <br>T* m_pT; <br>ATL_PDATAAVAILABLE m_pFunc; <br>DWORD m_dwTotalRead; <br>DWORD m_dwAvailableToRead; <br>}; <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
