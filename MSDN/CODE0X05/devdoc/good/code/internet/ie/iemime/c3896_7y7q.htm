<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>README.TXT</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3896"></a>README.TXT</h2>
<pre><code>IEMime Sample <br>============= <br> <br>IEMime demonstrates MIME type registration and MIME type recognition of downloads. <br> <br>The control starts an asynchronous download, usually by asking its <br>bind-host to MonikerBindToStorage on its behalf. During the download proces, IEMime <br>is notified of the MIME type on its bind-status-callback. IEMime displays this MIME type. <br> <br>Main points of interest: <br> <br>* For purposes of demonstration, IEMime uses a somewhat atypical scheme for <br>  downloading during initialization. Typically, a control which downloads asynchronous <br>  data based on a data-path property (URL) would proceed with the download as soon <br>  as it possibly can. The ReadyState property would then be used to signal to MSHTML as <br>  the control container that the control was done downloading whatever data it needed <br>  asynchronously. MSHTML would continue to show progress and UI such as the spinning <br>  icon until the control signalled READYSTATE_COMPLETE. In most cases, any events <br>  signalling the download would happen before the page was ready to receive them. In <br>  the case of IEMime, this would cause the Complete() event to not fire on page-startup. <br> <br>  Instead, IEMime waits until the container is totally ready to receive events before <br>  starting its download. That way, script can catch Complete() even for downloads kicked off <br>  by &lt;PARAM URL=&gt; persistent properties. However, this gets us into a deadlocked <br>  situation of sorts -- the container is waiting for our control to signal complete <br>  while we're waiting for the container to go complete. We avoid this problem by <br>  signalling "COMPLETE" as soon as our properties are loaded and then transitioning back to <br>  "INTERACTIVE" once we start our asynchronous download. This solution is acceptable -- <br>  it is okay for a control to change ReadyState back to LOADED or INTERACTIVE while it <br>  is re-downloading a data file or re-evaluating a query, for example. We always go back <br>  to INTERACTIVE when doing an asynchronous download. <br> <br>  The traditional means for a control to know when its container is up and running and <br>  can receive events is to watch IOleControl::FreezeEvents until the freeze count <br>  transitions from 1 to 0. This is where IEMime kicks off the download by calling Reload(). <br> <br>* IEMime adds to the basic ATL class CBindStatusCallback by adding some extra overrides. <br>  IEMime's CBindStatusCallback2 passes the FORMATETC and STGMEDIUM on to the using class <br>  (CIEMimeCtl) during OnData, because these structures are what we are really interested in. <br>  The original CBindStatusCallback did not provide these to the using class. <br> <br>  IEMime also calls up to two funcs in the using class, PreBindMoniker &amp; OnBindingFailure. <br>  The class design here could be improved, as this requires the using class to implement <br>  these funcs instead of pass in func-pointers such as with OnData. In our case, <br>  we want to handle both so it isn't a big deal. <br> <br>* PreBindMoniker is intended to allow the using class to talk to the IBindCtx and IMoniker <br>  interfaces before the upcoming bind process. In our case, we use it to demonstrate <br>  the use of the RegisterMediaType, CreateFormatEnumerator, and RegisterFormatEnumerator APIs. <br>  If the "Media" property has been set on the control, then IEMime uses this custom <br>  string to Register a new Media Type. This nets a Clipboard format for that media type. Then, <br>  IEMime creates a format enumerator that enumerates ONLY this custom clipformat and registers <br>  that format enumerator on the bindctx. The net effect of this is that IE will use this <br>  custom type in the HTTP "Accept" header supplied to remote servers to indicate the <br>  accepted types that we're looking for. Feel free to experiment with different servers <br>  and different requested types. <br> <br>* IEMime marks itself as safe-for-persistence on the IPersistPropertyBag interface. This <br>  is necessary to allow controls to receive Property persistence through &lt;PARAM&gt; tags.  <br>  The standard ATL IObjectSafetyImpl doesn't support this automatically, so we override <br>  Set/GetInterfaceSafetyOptions and do the right magic. <br> <br>* Miscellaneous Note #1: When asking a BindHost to do a binding via MonikerBindToStorage, <br>  the IBindStatusCallback registered on the IBindCtx will not be used in most cases and <br>  will get dumped. It's pretty important to supply the IBindStatusCallback interface as the <br>  third parameter to MonikerBindToStorage.  <br> <br>* Miscellaneous Note #2: IProvideClassInfo(2) must be implemented by a control if it wants <br>  IE/MSHTML to connect the control's event sink for scripting. </code></pre>
<p>&nbsp;</p></body>
</HTML>
