<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>TDCCTL.H</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3949"></a><sup></sup>TDCCTL.H</h2>
<pre><code>//+----------------------------------------------------------------------- <br>// <br>//  Tabular Data Control <br>//  Copyright (C) Microsoft Corporation, 1996, 1997 <br>// <br>//  File:       TDCCtl.h <br>// <br>//  Contents:   Declaration of the CTDCCtl ActiveX Control. <br>// <br>//------------------------------------------------------------------------ <br> <br> <br>#include "resource.h"       // main symbols <br>#include "std.h" <br>#include "wch.h" <br>#include &lt;wininet.h&gt;        // for INTERNET_MAX_URL_LENGTH <br> <br>#pragma comment(lib, "wininet.lib") <br> <br>#ifndef DISPID_AMBIENT_CODEPAGE <br>#define DISPID_AMBIENT_CODEPAGE (-725) <br>#endif <br> <br>// Declare helper needed in IHttpNegotiateImpl <br>HRESULT <br>GetHostURL(IOleClientSite *pSite, LPOLESTR *ppszHostName); <br> <br>//------------------------------------------------------------------------ <br>// <br>//  Template:  CMyBindStatusCallback <br>// <br>//  Synopsis:  This is a temporary kludge to get around an ATL feature <br>//             while we're waiting for it to become official code. <br>// <br>//------------------------------------------------------------------------ <br> <br>template &lt;class T&gt; <br>class ATL_NO_VTABLE IServiceProviderImpl <br>{ <br>    public: <br>        // IUnknown <br>        // <br>        STDMETHOD(QueryInterface)(REFIID riid, void ** ppvObject) = 0; <br>        _ATL_DEBUG_ADDREF_RELEASE_IMPL(IServiceProviderImpl) <br> <br>        STDMETHOD(QueryService) (REFGUID guidService, <br>                                 REFIID riid, <br>                                 void **ppvObject) <br>        { <br>            return S_OK; <br>        } <br> <br>}; <br> <br>template &lt;class T&gt; <br>class ATL_NO_VTABLE IHttpNegotiateImpl <br>{ <br>    public: <br>        // IUnknown <br>        // <br>        STDMETHOD(QueryInterface)(REFIID riid, void ** ppvObject) = 0; <br>        _ATL_DEBUG_ADDREF_RELEASE_IMPL(IHttpNegotiateImpl) <br> <br>        STDMETHOD(BeginningTransaction) (LPCWSTR szURL, <br>                                         LPCWSTR szHeaders, <br>                                         DWORD dwReserved, <br>                                         LPWSTR *pszAdditionalHeaders) <br>        { <br>            return S_OK; <br>        } <br> <br>        STDMETHOD(OnResponse) (DWORD dwResponseCode, <br>                               LPCWSTR szResponseHeaders, <br>                               LPCWSTR szRequestHeaders, <br>                               LPWSTR *pszAdditionalRequestHeaders) <br>        { <br>            return S_OK; <br>        } <br> <br>}; <br> <br> <br>template &lt;class T&gt; <br>class ATL_NO_VTABLE CMyBindStatusCallback : <br>    public CComObjectRootEx&lt;T::_ThreadModel::ThreadModelNoCS&gt;, <br>    public IBindStatusCallbackImpl&lt;T&gt;, public IHttpNegotiateImpl&lt;T&gt;, public IServiceProviderImpl&lt;T&gt; <br>{ <br>    typedef void (T::*ATL_PDATAAVAILABLE)(CMyBindStatusCallback&lt;T&gt;* pbsc, BYTE* pBytes, DWORD dwSize); <br> <br>    public: <br> <br>        BEGIN_COM_MAP(CMyBindStatusCallback&lt;T&gt;) <br>                COM_INTERFACE_ENTRY_IID(IID_IBindStatusCallback, IBindStatusCallbackImpl&lt;T&gt;) <br>                COM_INTERFACE_ENTRY_IID(IID_IHttpNegotiate, IHttpNegotiateImpl&lt;T&gt;) <br>                COM_INTERFACE_ENTRY_IID(IID_IServiceProvider, IServiceProviderImpl&lt;T&gt;) <br>        END_COM_MAP() <br> <br>        CMyBindStatusCallback() <br>        { <br>            m_pT = NULL; <br>            m_pFunc = NULL; <br>            m_fReload = FALSE; <br>        } <br>        ~CMyBindStatusCallback() <br>        { <br>            ATLTRACE(_T("~CMyBindStatusCallback\n")); <br>        } <br> <br>        // IServiceProvider methods <br> <br>        STDMETHOD(QueryService) (REFGUID guidService, <br>                                 REFIID riid, <br>                                 void **ppvObject) <br>        { <br>            // As it turns out, the service ID for IHttpNegotiate is the same <br>            // as it's IID (confusing).  This is the only service we support. <br>            if (IsEqualGUID(IID_IHttpNegotiate, guidService)) <br>            { <br>                return ((IHttpNegotiate *)this)-&gt;QueryInterface(riid, ppvObject); <br>            } <br>            else return E_NOTIMPL; <br>        } <br> <br>        // <br>        // IHttpNegotiate methods <br>        // <br> <br>        STDMETHOD(BeginningTransaction) (LPCWSTR szURL, <br>                                         LPCWSTR szHeaders, <br>                                         DWORD dwReserved, <br>                                         LPWSTR *pszAdditionalHeaders) <br>        { <br>            HRESULT hr = S_OK; <br>            WCHAR swzHostScheme[INTERNET_MAX_URL_LENGTH]; <br>            DWORD cchHostScheme = INTERNET_MAX_URL_LENGTH; <br>            WCHAR swzFileScheme[INTERNET_MAX_URL_LENGTH]; <br>            DWORD cchFileScheme = INTERNET_MAX_URL_LENGTH;             <br> <br>            LPOLESTR pszHostName; <br> <br>            *pszAdditionalHeaders = NULL; <br> <br>            hr = GetHostURL(m_spClientSite, &amp;pszHostName); <br>            if (FAILED(hr)) <br>                goto Cleanup; <br> <br>            // PARSE_SCHEMA didn't work, so we'll just CANONICALIZE and then use the first N <br>            // characters of the URL <br>            hr = CoInternetParseUrl(pszHostName, PARSE_CANONICALIZE, 0, swzHostScheme, cchHostScheme, <br>                                    &amp;cchHostScheme, 0); <br>            if (FAILED(hr)) <br>                goto Cleanup; <br> <br>            // Don't send a referer which isn't http: or https:, it's none <br>            // of the servers' business.  Further, don't send an https: <br>            // referer when requesting an http: file. <br>            if (0 != wch_incmp(swzHostScheme, L"https:", 6) &amp;&amp; <br>                0 != wch_incmp(swzHostScheme, L"http:", 5)) <br>                goto Cleanup; <br> <br>            if (0 == wch_incmp(swzHostScheme, L"https:", 6)) <br>            { <br>                hr = CoInternetParseUrl(szURL, PARSE_CANONICALIZE, 0, swzFileScheme, cchFileScheme, <br>                                        &amp;cchFileScheme, 0); <br>                if (0 == wch_incmp(swzFileScheme, L"http:", 65)) // don't send https: referer <br>                    goto Cleanup;                                // to an http: file. <br>            } <br> <br>            // 3*sizeof(WCHAR) is for CR, LF, &amp; '\0' <br>            *pszAdditionalHeaders = (WCHAR *)CoTaskMemAlloc(sizeof(L"Referer: ") + <br>                                                            ocslen(pszHostName)*sizeof(WCHAR) + <br>                                                            3*sizeof(WCHAR)); <br>            if (NULL != *pszAdditionalHeaders) <br>            { <br>                ocscpy(*pszAdditionalHeaders, L"Referer: "); <br>                ocscpy(&amp;((*pszAdditionalHeaders)[9]), pszHostName); <br>                ocscpy(&amp;((*pszAdditionalHeaders)[9+ocslen(pszHostName)]), L"\r\n"); <br>            } <br> <br>Cleanup: <br>            CoTaskMemFree(pszHostName); <br>            return hr; <br>        } <br> <br>        STDMETHOD(OnResponse) (DWORD dwResponseCode, <br>                               LPCWSTR szResponseHeaders, <br>                               LPCWSTR szRequestHeaders, <br>                               LPWSTR *pszAdditionalRequestHeaders) <br>        { <br>            return S_OK; <br>        } <br> <br> <br> <br>        // <br>        // IBindStatusCallback methods <br>        // <br> <br>        STDMETHOD(OnStartBinding)(DWORD dwReserved, IBinding *pBinding) <br>        { <br>            ATLTRACE(_T("CMyBindStatusCallback::OnStartBinding\n")); <br>            m_spBinding = pBinding; <br>            return S_OK; <br>        } <br> <br>        STDMETHOD(GetPriority)(LONG *pnPriority) <br>        { <br>            ATLTRACENOTIMPL(_T("CMyBindStatusCallback::GetPriority")); <br>        } <br> <br>        STDMETHOD(OnLowResource)(DWORD reserved) <br>        { <br>            ATLTRACENOTIMPL(_T("CMyBindStatusCallback::OnLowResource")); <br>        } <br> <br>        STDMETHOD(OnProgress)(ULONG ulProgress, ULONG ulProgressMax, ULONG ulStatusCode, LPCWSTR szStatusText) <br>        { <br>            if (BINDSTATUS_REDIRECTING == ulStatusCode &amp;&amp; szStatusText != NULL) <br>            { <br>                ocscpy(m_pszURL, szStatusText); <br>            } <br>            return S_OK; <br>        } <br> <br>        STDMETHOD(OnStopBinding)(HRESULT hresult, LPCWSTR szError) <br>        { <br>            //      ATLTRACE(_T("CMyBindStatusCallback::OnStopBinding\n")); <br>            (m_pT-&gt;*m_pFunc)(this, NULL, 0); <br>            m_spBinding.Release(); <br>            m_spBindCtx.Release(); <br>            m_spMoniker.Release(); <br>            return S_OK; <br>        } <br> <br>        STDMETHOD(GetBindInfo)(DWORD *pgrfBINDF, BINDINFO *pbindInfo) <br>        { <br>            ATLTRACE(_T("CMyBindStatusCallback::GetBindInfo\n")); <br> <br>            if (!pbindInfo || !pbindInfo-&gt;cbSize || !pgrfBINDF) <br>                return E_INVALIDARG; <br> <br>            *pgrfBINDF = BINDF_ASYNCHRONOUS <br>                         | BINDF_ASYNCSTORAGE <br>                         ; <br>// ;begin_internal <br>#ifdef NEVER <br>            // I want DEBUG mode to NOT cache things!! -cfranks <br>            *pgrfBINDF |= BINDF_GETNEWESTVERSION <br>                          | BINDF_NOWRITECACHE <br>                          | BINDF_RESYNCHRONIZE <br>                          ; <br>#endif <br>// ;end_internal <br> <br>#ifndef DISPID_AMBIENT_OFFLINE <br>#define DISPID_AMBIENT_OFFLINE          (-5501) <br>#endif <br>            // Get our offline property from container <br>            VARIANT var; <br>            VariantInit(&amp;var); <br>            DWORD dwConnectedStateFlags; <br>            m_pT-&gt;GetAmbientProperty(DISPID_AMBIENT_OFFLINE, var); <br>            if (var.vt==VT_BOOL &amp;&amp; var.boolVal) <br>            { <br>                if (!(InternetGetConnectedState(&amp;dwConnectedStateFlags, 0)) &amp;&amp; <br>                    (0 == (dwConnectedStateFlags &amp; INTERNET_CONNECTION_MODEM_BUSY))) <br>                { <br>                    ATLTRACE(_T("CMyBindStatusCallback::GetBindInfo OFFLINE\n")); <br>                   // We're not even dialed out to another connectoid <br>                    *pgrfBINDF |= BINDF_OFFLINEOPERATION; <br>                } <br>                else <br>                { <br>                    ATLTRACE(_T("CMyBindStatusCallback::GetBindInfo OFFLINE\n")); <br>                    *pgrfBINDF &amp;= ~BINDF_OFFLINEOPERATION;                    <br>                } <br>            } <br> <br>            // See if we should force a reload, iff we're not offline. <br>            if (!(*pgrfBINDF &amp; BINDF_OFFLINEOPERATION) &amp;&amp; m_fReload) <br>            { <br>                *pgrfBINDF |= BINDF_RESYNCHRONIZE|BINDF_PRAGMA_NO_CACHE; <br>            } <br> <br>            ULONG cbSize = pbindInfo-&gt;cbSize; <br>            memset(pbindInfo, 0, cbSize); <br> <br>            pbindInfo-&gt;cbSize = cbSize; <br>            pbindInfo-&gt;dwBindVerb = BINDVERB_GET; <br> <br>            return S_OK; <br>        } <br> <br>        STDMETHOD(OnDataAvailable)(DWORD grfBSCF, DWORD dwSize, FORMATETC *pformatetc, STGMEDIUM *pstgmed) <br>        { <br>            ATLTRACE(_T("CMyBindStatusCallback::OnDataAvailable\n")); <br>            HRESULT hr = S_OK; <br> <br>            // Get the Stream passed <br>            if (BSCF_FIRSTDATANOTIFICATION &amp; grfBSCF) <br>            { <br>                if (!m_spStream &amp;&amp; pstgmed-&gt;tymed == TYMED_ISTREAM) <br>                { <br>                    m_spStream = pstgmed-&gt;pstm; <br>                } <br>            } <br> <br>            DWORD dwRead = dwSize - m_dwTotalRead; // Minimum amount available that hasn't been read <br>            DWORD dwActuallyRead = 0;            // Placeholder for amount read during this pull <br> <br>            // If there is some data to be read then go ahead and read them <br>            if (m_spStream) <br>            { <br>                if (dwRead &gt; 0) <br>                { <br>                    BYTE* pBytes = NULL; <br>                    ATLTRY(pBytes = new BYTE[dwRead + 1]); <br>                    if (pBytes == NULL) <br>                        return S_FALSE; <br>                    hr = m_spStream-&gt;Read(pBytes, dwRead, &amp;dwActuallyRead); <br>                    if (SUCCEEDED(hr)) <br>                    { <br>                        pBytes[dwActuallyRead] = 0; <br>                        if (dwActuallyRead&gt;0) <br>                        { <br>                            (m_pT-&gt;*m_pFunc)(this, pBytes, dwActuallyRead); <br>                            m_dwTotalRead += dwActuallyRead; <br>                        } <br>                    } <br>                    delete[] pBytes; <br>                } <br>            } <br> <br>            if (BSCF_LASTDATANOTIFICATION &amp; grfBSCF) <br>                m_spStream.Release(); <br>            return hr; <br>        } <br> <br>        STDMETHOD(OnObjectAvailable)(REFIID riid, IUnknown *punk) <br>        { <br>            ATLTRACENOTIMPL(_T("CMyBindStatusCallback::OnObjectAvailable")); <br>        } <br> <br>        HRESULT _StartAsyncDownload(BSTR bstrURL, IUnknown* pUnkContainer, BOOL bRelative) <br>        { <br>            m_dwTotalRead = 0; <br>            m_dwAvailableToRead = 0; <br>            HRESULT hr = S_OK; <br>            CComQIPtr&lt;IServiceProvider, &amp;IID_IServiceProvider&gt; spServiceProvider(pUnkContainer); <br>            CComPtr&lt;IBindHost&gt; spBindHost; <br>            CComPtr&lt;IStream&gt; spStream; <br>            if (spServiceProvider) <br>                spServiceProvider-&gt;QueryService(SID_IBindHost, IID_IBindHost, (void**)&amp;spBindHost); <br> <br>            // We don't bother checking this QI, because the only failure mode is that our <br>            // BeginningNegotitation method won't be able able to properly add the referer string. <br>            (void)pUnkContainer-&gt;QueryInterface(IID_IOleClientSite, (void **)&amp;m_spClientSite); <br> <br>            if (spBindHost == NULL) <br>            { <br>                if (bRelative) <br>                    return E_NOINTERFACE;  // relative asked for, but no IBindHost <br>                hr = CreateURLMoniker(NULL, bstrURL, &amp;m_spMoniker); <br>                if (SUCCEEDED(hr)) <br>                    hr = CreateBindCtx(0, &amp;m_spBindCtx); <br> <br>                if (SUCCEEDED(hr)) <br>                    hr = RegisterBindStatusCallback(m_spBindCtx, reinterpret_cast&lt;IBindStatusCallback*&gt;(static_cast&lt;IBindStatusCallbackImpl&lt;T&gt;*&gt;(this)), 0, 0L); <br>                else <br>                    m_spMoniker.Release(); <br> <br>                if (SUCCEEDED(hr)) <br>                { <br>                    LPOLESTR pszTemp = NULL; <br>                    hr = m_spMoniker-&gt;GetDisplayName(m_spBindCtx, NULL, &amp;pszTemp); <br>                    if (!hr &amp;&amp; pszTemp != NULL) <br>                        ocscpy(m_pszURL, pszTemp); <br>                    CoTaskMemFree(pszTemp); <br> <br>                    hr = m_spMoniker-&gt;BindToStorage(m_spBindCtx, 0, IID_IStream, (void**)&amp;spStream); <br>                } <br>            } <br>            else <br>            { <br>                hr = CreateBindCtx(0, &amp;m_spBindCtx); <br>                if (SUCCEEDED(hr)) <br>                    hr = RegisterBindStatusCallback(m_spBindCtx, reinterpret_cast&lt;IBindStatusCallback*&gt;(static_cast&lt;IBindStatusCallbackImpl&lt;T&gt;*&gt;(this)), 0, 0L); <br> <br>                if (SUCCEEDED(hr)) <br>                { <br>                    if (bRelative) <br>                        hr = spBindHost-&gt;CreateMoniker(bstrURL, m_spBindCtx, &amp;m_spMoniker, 0); <br>                    else <br>                        hr = CreateURLMoniker(NULL, bstrURL, &amp;m_spMoniker); <br>                } <br> <br>                if (SUCCEEDED(hr)) <br>                { <br>                    LPOLESTR pszTemp = NULL; <br>                    hr = m_spMoniker-&gt;GetDisplayName(m_spBindCtx, NULL, &amp;pszTemp); <br>                    if (!hr &amp;&amp; pszTemp != NULL) <br>                        ocscpy(m_pszURL, pszTemp); <br>                    CoTaskMemFree(pszTemp); <br>                    hr = spBindHost-&gt;MonikerBindToStorage(m_spMoniker, NULL, reinterpret_cast&lt;IBindStatusCallback*&gt;(static_cast&lt;IBindStatusCallbackImpl&lt;T&gt;*&gt;(this)), IID_IStream, (void**)&amp;spStream); <br>                    ATLTRACE(_T("Bound")); <br>                } <br>            } <br>            return hr; <br>        } <br> <br>        HRESULT StartAsyncDownload(T* pT, ATL_PDATAAVAILABLE pFunc, BSTR bstrURL, IUnknown* pUnkContainer, BOOL bRelative, <br>                                   BOOL fReload) <br>        { <br>            m_pT = pT; <br>            m_pFunc = pFunc; <br>            m_fReload = fReload;        // force reload if TRUE <br>            return  _StartAsyncDownload(bstrURL, pUnkContainer, bRelative); <br>        } <br> <br>        static HRESULT Download(T* pT, ATL_PDATAAVAILABLE pFunc, BSTR bstrURL, IUnknown* pUnkContainer = NULL, BOOL bRelative = FALSE) <br>        { <br>            CComObject&lt;CMyBindStatusCallback&lt;T&gt; &gt; *pbsc; <br>            HRESULT hRes = CComObject&lt;CMyBindStatusCallback&lt;T&gt; &gt;::CreateInstance(&amp;pbsc); <br>            if (FAILED(hRes)) <br>                return hRes; <br>            return pbsc-&gt;StartAsyncDownload(pT, pFunc, bstrURL, pUnkContainer, bRelative, FALSE); <br>        } <br>        CComPtr&lt;IMoniker&gt; m_spMoniker; <br>        CComPtr&lt;IBindCtx&gt; m_spBindCtx; <br>        CComPtr&lt;IBinding&gt; m_spBinding; <br>        CComPtr&lt;IStream&gt; m_spStream; <br>        CComPtr&lt;IOleClientSite&gt; m_spClientSite; <br>        BOOL m_fReload; <br>        OLECHAR m_pszURL[INTERNET_MAX_URL_LENGTH]; <br>        T* m_pT; <br>        ATL_PDATAAVAILABLE m_pFunc; <br>        DWORD m_dwTotalRead; <br>        DWORD m_dwAvailableToRead; <br>}; <br> <br>////////////////////////////////////////////////////////////////////////////////////////////////// <br>// CTimer <br>template &lt;class Derived, class T, const IID* piid&gt; <br>class CTimer <br>{ <br>public: <br> <br>    CTimer() <br>    { <br>        m_bTimerOn = FALSE; <br>    } <br> <br>    HRESULT TimerOn(DWORD dwTimerInterval) <br>    { <br>        Derived* pDerived = ((Derived*)this); <br> <br>        m_dwTimerInterval = dwTimerInterval; <br>        if (m_bTimerOn) // already on, just change interval <br>            return S_OK; <br> <br>        m_bTimerOn = TRUE; <br>        m_dwTimerInterval = dwTimerInterval; <br>        m_pStream = NULL;  <br> <br>        HRESULT hRes; <br> <br>        hRes = CoMarshalInterThreadInterfaceInStream(*piid, (T*)pDerived, &amp;m_pStream); <br> <br>        // Create thread and pass the thread proc the this ptr <br>        m_hThread = CreateThread(NULL, 0, &amp;_Apartment, (void*)this, 0, &amp;m_dwThreadID); <br> <br>        return S_OK; <br>    } <br> <br>    void TimerOff() <br>    { <br>        if (m_bTimerOn) <br>        { <br>            m_bTimerOn = FALSE; <br>            AtlWaitWithMessageLoop(m_hThread); <br>        } <br>    } <br> <br> <br>// Implementation <br>private: <br>    static DWORD WINAPI _Apartment(void* pv) <br>    { <br>        CTimer&lt;Derived, T, piid&gt;* pThis = (CTimer&lt;Derived, T, piid&gt;*) pv; <br>        pThis-&gt;Apartment(); <br>        return 0; <br>    } <br> <br>    DWORD Apartment() <br>    { <br>        CoInitialize(NULL); <br>        HRESULT hRes; <br> <br>        m_spT.Release(); <br> <br>        if (m_pStream) <br>        { <br>            hRes = CoGetInterfaceAndReleaseStream(m_pStream, *piid, (void**)&amp;m_spT); <br>        } <br> <br>        while(m_bTimerOn) <br>        { <br>            Sleep(m_dwTimerInterval); <br>            if (!m_bTimerOn) <br>                break; <br> <br>            m_spT-&gt;_OnTimer(); <br>        } <br>        m_spT.Release(); <br> <br>        CoUninitialize(); <br>        return 0; <br>    } <br> <br>// Attributes <br>public: <br>    DWORD m_dwTimerInterval; <br> <br>// Implementation <br>private: <br>    HANDLE m_hThread; <br>    DWORD m_dwThreadID; <br>    LPSTREAM m_pStream; <br>    CComPtr&lt;T&gt; m_spT; <br>    BOOL m_bTimerOn; <br>}; <br> <br>class CEventBroker; <br> <br>////////////////////////////////////////////////////////////////////////////// <br>// CProxyITDCCtlEvents <br>template &lt;class T&gt; <br>class CProxyITDCCtlEvents : public IConnectionPointImpl&lt;T, &amp;IID_ITDCCtlEvents, CComDynamicUnkArray&gt; <br>{ <br>//ITDCCtlEvents : IDispatch <br>public: <br>    void FireOnReadyStateChanged() <br>    { <br>        T* pT = (T*)this; <br>        pT-&gt;Lock(); <br>        IUnknown** pp = m_vec.begin(); <br>        while (pp &lt; m_vec.end()) <br>        { <br>            if (*pp != NULL) <br>            { <br>                DISPPARAMS dispParams; <br>                dispParams.cArgs = 0; <br>                dispParams.cNamedArgs = 0; <br>                dispParams.rgvarg = NULL; <br>                dispParams.rgdispidNamedArgs = NULL; <br>                ITDCCtlEvents* pITDCCtlEvents = reinterpret_cast&lt;ITDCCtlEvents*&gt;(*pp); <br>                pITDCCtlEvents-&gt;Invoke(DISPID_READYSTATECHANGE, IID_NULL, CP_ACP, DISPATCH_METHOD, &amp;dispParams, <br>                                       NULL, NULL, NULL); <br>            } <br>            pp++; <br>        } <br>        pT-&gt;Unlock(); <br>        return; <br>    } <br> <br>}; <br> <br> <br>//------------------------------------------------------------------------ <br>// <br>//  Class:     CTDCCtl <br>// <br>//  Synopsis:  This is the TabularDataControl COM object. <br>//             It creates a CTDCArr object to manage the control's data. <br>// <br>//------------------------------------------------------------------------ <br> <br>class CTDCCtl : <br>    public CComObjectRoot, <br>    public CComCoClass&lt;CTDCCtl, &amp;CLSID_CTDCCtl&gt;, <br>    public CComControl&lt;CTDCCtl&gt;, <br>    public CStockPropImpl&lt;CTDCCtl, ITDCCtl, &amp;IID_ITDCCtl, &amp;LIBID_TDCLib&gt;, <br>    public IProvideClassInfo2Impl&lt;&amp;CLSID_CTDCCtl, &amp;IID_ITDCCtlEvents, &amp;LIBID_TDCLib&gt;, <br>    public IPersistStreamInitImpl&lt;CTDCCtl&gt;, <br>    public IOleControlImpl&lt;CTDCCtl&gt;, <br>    public IOleObjectImpl&lt;CTDCCtl&gt;, <br>    public IOleInPlaceActiveObjectImpl&lt;CTDCCtl&gt;, <br>    public IViewObjectExImpl&lt;CTDCCtl&gt;, <br>    public IOleInPlaceObjectWindowlessImpl&lt;CTDCCtl&gt;, <br>    public IPersistPropertyBagImpl&lt;CTDCCtl&gt;, <br>    public CTimer&lt;CTDCCtl, ITDCCtl, &amp;IID_ITDCCtl&gt;, <br>    public IRunnableObjectImpl&lt;CTDCCtl&gt;, <br>    public IConnectionPointContainerImpl&lt;CTDCCtl&gt;, <br>    public IPropertyNotifySinkCP&lt;CTDCCtl&gt;, <br>    public CProxyITDCCtlEvents&lt;CTDCCtl&gt; <br>{ <br>public: <br>    CTDCCtl(); <br>    ~CTDCCtl(); <br> <br>DECLARE_REGISTRY_RESOURCEID(IDR_TDCCtl) <br> <br>DECLARE_NOT_AGGREGATABLE(CTDCCtl) <br> <br>BEGIN_COM_MAP(CTDCCtl)  <br>    COM_INTERFACE_ENTRY(IDispatch) <br>    COM_INTERFACE_ENTRY(ITDCCtl) <br>    COM_INTERFACE_ENTRY_IMPL_IID(IID_IViewObject, IViewObjectEx) <br>    COM_INTERFACE_ENTRY_IMPL_IID(IID_IViewObject2, IViewObjectEx) <br>    COM_INTERFACE_ENTRY_IMPL(IViewObjectEx) <br>    COM_INTERFACE_ENTRY_IMPL_IID(IID_IOleWindow, IOleInPlaceObjectWindowless) <br>    COM_INTERFACE_ENTRY_IMPL_IID(IID_IOleInPlaceObject, IOleInPlaceObjectWindowless) <br>    COM_INTERFACE_ENTRY_IMPL(IOleInPlaceObjectWindowless) <br>    COM_INTERFACE_ENTRY_IMPL(IOleInPlaceActiveObject) <br>    COM_INTERFACE_ENTRY_IMPL(IOleControl) <br>    COM_INTERFACE_ENTRY_IMPL(IOleObject) <br>    COM_INTERFACE_ENTRY_IMPL(IPersistStreamInit) <br>    COM_INTERFACE_ENTRY(IProvideClassInfo) <br>    COM_INTERFACE_ENTRY(IProvideClassInfo2) <br>    COM_INTERFACE_ENTRY_IMPL(IPersistPropertyBag) <br>    COM_INTERFACE_ENTRY_IMPL(IRunnableObject) <br>    COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer) <br>END_COM_MAP() <br> <br>BEGIN_PROPERTY_MAP(CTDCCtl) <br>    PROP_ENTRY("RowDelim",      DISPID_ROWDELIM,    CLSID_CTDCCtl) <br>    PROP_ENTRY("FieldDelim",    DISPID_FIELDDELIM,  CLSID_CTDCCtl) <br>    PROP_ENTRY("TextQualifier", DISPID_TEXTQUALIFIER,   CLSID_CTDCCtl) <br>    PROP_ENTRY("EscapeChar",    DISPID_ESCAPECHAR,  CLSID_CTDCCtl) <br>    PROP_ENTRY("UseHeader",     DISPID_USEHEADER,   CLSID_CTDCCtl) <br>    PROP_ENTRY("SortAscending", DISPID_SORTASCENDING,   CLSID_CTDCCtl) <br>    PROP_ENTRY("SortColumn",    DISPID_SORTCOLUMN,  CLSID_CTDCCtl) <br>    PROP_ENTRY("FilterValue",   DISPID_FILTERVALUE, CLSID_CTDCCtl) <br>    PROP_ENTRY("FilterCriterion",   DISPID_FILTERCRITERION, CLSID_CTDCCtl) <br>    PROP_ENTRY("FilterColumn",  DISPID_FILTERCOLUMN,CLSID_CTDCCtl) <br>    PROP_ENTRY("CharSet",       DISPID_CHARSET,     CLSID_CTDCCtl) <br>    PROP_ENTRY("Language",      DISPID_LANGUAGE,    CLSID_CTDCCtl) <br>    PROP_ENTRY("CaseSensitive", DISPID_CASESENSITIVE, CLSID_CTDCCtl) <br>    PROP_ENTRY("Sort",          DISPID_SORT,        CLSID_CTDCCtl) <br>// ;begin_internal <br>//  Doesn't work right yet. <br>//    PROP_ENTRY("RefreshInterval",   DISPID_TIMER,      CLSID_CTDCCtl) <br>// ;end_internal <br>    PROP_ENTRY("Filter",        DISPID_FILTER,      CLSID_CTDCCtl) <br>    PROP_ENTRY("AppendData",    DISPID_APPENDDATA,  CLSID_CTDCCtl) <br>// ;begin_internal <br>//  Trying to save this property causes OLEAUT to GP Fault trying <br>//  to conver the IDispatch * to a BSTR! <br>//    PROP_ENTRY("OSP",           DISPID_OSP,         CLSID_CTDCCtl) <br>// ;end_internal <br>    //  This will be removed when we learn more about the HTML <br>    //  sub-tag "OBJECT" <br>    PROP_ENTRY("DataURL",       DISPID_DATAURL,     CLSID_CTDCCtl) <br>    PROP_ENTRY("ReadyState",    DISPID_READYSTATE,  CLSID_CTDCCtl) <br>END_PROPERTY_MAP() <br> <br>BEGIN_CONNECTION_POINT_MAP(CTDCCtl) <br>CONNECTION_POINT_ENTRY(IID_IPropertyNotifySink) <br>CONNECTION_POINT_ENTRY(IID_ITDCCtlEvents) <br>END_CONNECTION_POINT_MAP() <br> <br>BEGIN_MSG_MAP(CTDCCtl) <br>    MESSAGE_HANDLER(WM_PAINT, OnPaint) <br>    MESSAGE_HANDLER(WM_GETDLGCODE, OnGetDlgCode) <br>    MESSAGE_HANDLER(WM_SETFOCUS, OnSetFocus) <br>    MESSAGE_HANDLER(WM_KILLFOCUS, OnKillFocus) <br>END_MSG_MAP() <br> <br>private: <br>    CComBSTR     m_cbstrFieldDelim; <br>    CComBSTR     m_cbstrRowDelim; <br>    CComBSTR     m_cbstrQuoteChar; <br>    CComBSTR     m_cbstrEscapeChar; <br>    VARIANT_BOOL m_fUseHeader; <br>    CComBSTR     m_cbstrSortColumn; <br>    VARIANT_BOOL m_fSortAscending; <br>    CComBSTR     m_cbstrFilterValue; <br>    OSPCOMP      m_enumFilterCriterion; <br>    CComBSTR     m_cbstrFilterColumn; <br>    UINT         m_nCodePage; <br>    CComBSTR     m_cbstrLanguage; <br>    CComBSTR     m_cbstrDataURL; <br>    LCID         m_lcidRead; <br>    boolean      m_fDataURLChanged; <br>    HRESULT      m_hrDownloadStatus; <br>    LONG         m_lTimer; <br>    CComBSTR     m_cbstrFilterExpr; <br>    CComBSTR     m_cbstrSortExpr; <br>    VARIANT_BOOL m_fAppendData; <br>    VARIANT_BOOL m_fCaseSensitive; <br>    boolean      m_fInReset; <br> <br>    OLEDBSimpleProvider *m_pSTD; <br>    CTDCArr      *m_pArr; <br>    IMultiLanguage  *m_pML; <br>    BOOL         m_fSecurityChecked; <br> <br>// ;begin_internal <br>    DATASRCListener *m_pDATASRCListener; <br>// ;end_internal <br>    DataSourceListener *m_pDataSourceListener; <br>    CEventBroker *m_pEventBroker; <br> <br> <br>    //  These member objects are used while parsing the input stream <br>    // <br>    CTDCUnify       *m_pUnify; <br>    CComObject&lt;CMyBindStatusCallback&lt;CTDCCtl&gt; &gt; *m_pBSC; <br> <br>// These members and methods expose the ITDCCtl interface <br>// <br>public: <br> <br>    //  Control Properties <br>    // <br>    STDMETHOD(get_FieldDelim)(BSTR* pbstrFieldDelim); <br>    STDMETHOD(put_FieldDelim)(BSTR bstrFieldDelim); <br>    STDMETHOD(get_RowDelim)(BSTR* pbstrRowDelim); <br>    STDMETHOD(put_RowDelim)(BSTR bstrRowDelim); <br>    STDMETHOD(get_TextQualifier)(BSTR* pbstrTextQualifier); <br>    STDMETHOD(put_TextQualifier)(BSTR bstrTextQualifier); <br>    STDMETHOD(get_EscapeChar)(BSTR* pbstrEscapeChar); <br>    STDMETHOD(put_EscapeChar)(BSTR bstrEscapeChar); <br>    STDMETHOD(get_UseHeader)(VARIANT_BOOL* pfUseHeader); <br>    STDMETHOD(put_UseHeader)(VARIANT_BOOL fUseHeader); <br>    STDMETHOD(get_SortColumn)(BSTR* pbstrSortColumn); <br>    STDMETHOD(put_SortColumn)(BSTR bstrSortColumn); <br>    STDMETHOD(get_SortAscending)(VARIANT_BOOL* pfSortAscending); <br>    STDMETHOD(put_SortAscending)(VARIANT_BOOL fSortAscending); <br>    STDMETHOD(get_FilterValue)(BSTR* pbstrFilterValue); <br>    STDMETHOD(put_FilterValue)(BSTR bstrFilterValue); <br>    STDMETHOD(get_FilterCriterion)(BSTR* pbstrFilterCriterion); <br>    STDMETHOD(put_FilterCriterion)(BSTR bstrFilterCriterion); <br>    STDMETHOD(get_FilterColumn)(BSTR* pbstrFilterColumn); <br>    STDMETHOD(put_FilterColumn)(BSTR bstrFilterColumn); <br>    STDMETHOD(get_CharSet)(BSTR *pbstrCharSet); <br>    STDMETHOD(put_CharSet)(BSTR bstrCharSet); <br>    STDMETHOD(get_Language)(BSTR* pbstrLanguage); <br>    STDMETHOD(put_Language_)(LPWCH pwchLanguage); <br>    STDMETHOD(put_Language)(BSTR bstrLanguage); <br>    STDMETHOD(get_CaseSensitive)(VARIANT_BOOL *pfCaseSensitive); <br>    STDMETHOD(put_CaseSensitive)(VARIANT_BOOL fCaseSensitive); <br>    STDMETHOD(get_DataURL)(BSTR* pbstrDataURL); //  <br>    STDMETHOD(put_DataURL)(BSTR bstrDataURL); <br>// ;begin_internal <br>//    STDMETHOD(get_RefreshInterval)(LONG* plTimer); <br>//    STDMETHOD(put_RefreshInterval)(LONG lTimer); <br>// ;end_internal <br>    STDMETHOD(get_Filter)(BSTR* pbstrFilterExpr); <br>    STDMETHOD(put_Filter)(BSTR bstrFilterExpr); <br>    STDMETHOD(get_Sort)(BSTR* pbstrSortExpr); <br>    STDMETHOD(put_Sort)(BSTR bstrSortExpr); <br>    STDMETHOD(get_AppendData)(VARIANT_BOOL* pfAppendData); <br>    STDMETHOD(put_AppendData)(VARIANT_BOOL fAppendData); <br>    STDMETHOD(get_OSP)(OLEDBSimpleProviderX ** ppISTD); <br> <br>    STDMETHOD(get_ReadyState)(LONG *lReadyState); <br>    STDMETHOD(put_ReadyState)(LONG lReadyState); <br> <br>    // Override IPersistPropertyBagImpl::Load <br>    STDMETHOD(Load)(LPPROPERTYBAG pPropBag, LPERRORLOG pErrorLog); <br> <br>    void UpdateReadyState(LONG lReadyState); <br>    //  Data source notification methods <br>    STDMETHOD(msDataSourceObject)(BSTR qualifier, IUnknown **ppUnk); <br>    STDMETHOD(addDataSourceListener)(IUnknown *pEvent); <br> <br>    //  Control Methods <br>    // <br>    STDMETHOD(Reset)(); <br>    STDMETHOD(_OnTimer)(void); <br> <br>private: <br>    STDMETHOD(CreateTDCArr)(boolean fAppend); <br>    STDMETHOD(ReleaseTDCArr)(boolean fReplacing); <br>    void LockBSC(); <br>    void UnlockBSC(); <br>    STDMETHOD(InitiateDataLoad)(boolean fAppend); <br>    STDMETHOD(SecurityCheckDataURL)(LPOLESTR pszURL); <br>    STDMETHOD(SecurityMatchAllowDomainList)(); <br>    STDMETHOD(SecurityMatchProtocols)(LPOLESTR pszURL); <br>    STDMETHOD(TerminateDataLoad)(); <br>    BSTR bstrConstructSortExpr(); <br>    BSTR bstrConstructFilterExpr(); <br> <br>protected: <br>    void OnData(CMyBindStatusCallback&lt;CTDCCtl&gt; *pbsc, BYTE *pBytes, DWORD dwSize); <br>}; </code></pre>
<p>&nbsp;</p></body>
</HTML>
