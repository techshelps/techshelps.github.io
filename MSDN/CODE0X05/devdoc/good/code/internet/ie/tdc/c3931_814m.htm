<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>TDCARR.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3946"></a><sup></sup>TDCARR.CPP</h2>
<pre><code>//+----------------------------------------------------------------------- <br>// <br>//  Tabular Data Control Array <br>//  Copyright (C) Microsoft Corporation, 1996, 1997 <br>// <br>//  File:       TDCArr.cpp <br>// <br>//  Contents:   Implementation of the CTDCArr object. <br>//              This class forms the heart of the Tabular Data Control. <br>//              It provides the core 2D array of variant values, plus <br>//              a (possibly filtered/sorted) view of this data for <br>//              presentation through an ISimpleTabularData interface. <br>// <br>//------------------------------------------------------------------------ <br> <br>#include "stdafx.h" <br>#include "wch.h" <br>#include "STD.h" <br>#include "TDC.h" <br>#include &lt;MLang.h&gt; <br>#include "Notify.h" <br>#include "TDCParse.h" <br>#include "TDCArr.h" <br>#include "SimpData.h" <br>#include "TDCIds.h" <br> <br>//------------------------------------------------------------------------ <br>// <br>//  Function:  fWCHIsSpace() <br>// <br>//  Synopsis:  Indicates whether a WCHAR is considered a space character <br>// <br>//  Arguments: wch      Character to test <br>// <br>//  Returns:   TRUE/FALSE indicating whether the given character is <br>//             considered a space. <br>// <br>//------------------------------------------------------------------------ <br> <br>inline boolean fWCHIsSpace(WCHAR wch) <br>{ <br>    return (wch == L' ' || wch == L'\t'); <br>} <br> <br> <br>//------------------------------------------------------------------------ <br>// <br>//  Function:  fWCHEatTest() <br>// <br>//  Synopsis:  Advances a string pointer over a given test character. <br>// <br>//  Arguments: ppwch      Pointer to string to test <br>//             wch        Match character <br>// <br>//  Returns:   TRUE indicating the character matched and the pointer has <br>//               been advanceed <br>//             FALSE indicating no match (character pointer left unchanged) <br>// <br>//------------------------------------------------------------------------ <br> <br>inline boolean fWCHEatTest(LPWCH *ppwch, WCHAR wch) <br>{ <br>    if (**ppwch != wch) <br>        return FALSE; <br>    (*ppwch)++; <br>    return TRUE; <br>} <br> <br> <br>//------------------------------------------------------------------------ <br>// <br>//  Function:  fWCHEatSpace() <br>// <br>//  Synopsis:  Advances a string pointer over white space. <br>// <br>//  Arguments: ppwch      String pointer. <br>// <br>//  Returns:   Nothing. <br>// <br>//------------------------------------------------------------------------ <br> <br>inline void fWCHEatSpace(LPWCH *ppwch) <br>{ <br>    while (fWCHIsSpace(**ppwch)) <br>        (*ppwch)++; <br>} <br> <br> <br>//------------------------------------------------------------------------ <br>// <br>//  Method:    CTDCArr() <br>// <br>//  Synopsis:  Class constructor.  Due to the COM model, the <br>//             member function "Create" should be called to actually <br>//             initialise the STD data structures. <br>// <br>//  Arguments: None. <br>// <br>//------------------------------------------------------------------------ <br> <br>CTDCArr::CTDCArr() : m_cRef(1) <br>{ <br>    m_pEventBroker = NULL; <br>    m_pSortList = NULL; <br>    m_bstrSortExpr = NULL; <br>    m_pFilterTree = NULL; <br>    m_bstrFilterExpr = NULL; <br>} <br> <br>//------------------------------------------------------------------------ <br>// <br>//  Member:    Init() <br>// <br>//  Synopsis:  Initialises the internal data. <br>// <br>//  Arguments: pEventBroker       Object to delegate notifications to. <br>// <br>//  Returns:   S_OK upon success. <br>//             Error code upon failure. <br>// <br>//------------------------------------------------------------------------ <br> <br>STDMETHODIMP <br>CTDCArr::Init(CEventBroker *pEventBroker, IMultiLanguage *pML) <br>{ <br>    HRESULT hr = S_OK; <br> <br>    hr = m_arrparrCells.Init(0); <br>    if (SUCCEEDED(hr)) <br>        hr = m_arrparrFilter.Init(0); <br>    if (SUCCEEDED(hr)) <br>        hr = m_arrColInfo.Init(0); <br>    m_iFilterRows = CalcFilterRows(); <br>    m_iDataRows = CalcDataRows(); <br>    m_iCols = CalcCols(); <br>    m_fLastFilter = FALSE; <br>    m_fSortFilterDisrupted = FALSE; <br>    m_state = LS_UNINITIALISED; <br>    m_lcid = GetUserDefaultLCID(); <br>    m_lcidRead = m_lcid; <br>    _ASSERT(pEventBroker != NULL); <br> <br>    m_pEventBroker = pEventBroker; <br>    m_pEventBroker-&gt;AddRef();           // better not be called with NULL <br> <br>    m_pML = pML; <br>    m_pML-&gt;AddRef(); <br> <br>    m_fAsync = FALSE;                   // assume non-asynch for error cases <br>    return hr; <br>} <br> <br> <br>//------------------------------------------------------------------------ <br>// <br>//  Member:    ~CTDCArr() <br>// <br>//  Synopsis:  Destructor for CTDCArr <br>// <br>//------------------------------------------------------------------------ <br> <br>CTDCArr::~CTDCArr() <br>{ <br>    for (LONG iRow = CalcDataRows(); iRow &gt;= 0; iRow--) <br>    { <br>        m_arrparrCells[iRow]-&gt;Passivate(); <br>        delete m_arrparrCells[iRow]; <br>    } <br>    m_arrparrCells.Passivate(); <br>    m_arrparrFilter.Passivate(); <br>    m_arrColInfo.Passivate(); <br>    if (m_pSortList != NULL) <br>        delete m_pSortList; <br>    SysFreeString(m_bstrSortExpr); <br>    if (m_pFilterTree != NULL) <br>        delete m_pFilterTree; <br>    SysFreeString(m_bstrFilterExpr); <br> <br>    if (m_pEventBroker) <br>    { <br>        m_pEventBroker-&gt;Release(); <br>        m_pEventBroker = NULL; <br>    } <br> <br>    ClearInterface(&amp;m_pML); <br>} <br> <br>LONG CTDCArr::CalcDataRows() <br>{ <br>    return m_arrparrCells.GetSize() - 1; <br>} <br> <br>LONG CTDCArr::CalcFilterRows() <br>{ <br>    return m_arrparrFilter.GetSize() - 1; <br>} <br> <br>LONG CTDCArr::CalcCols() <br>{ <br>    return m_arrparrCells.GetSize() &gt; 0 <br>                ? m_arrparrCells[0]-&gt;GetSize() : 0; <br>} <br> <br>//------------------------------------------------------------------------ <br>// <br>//  Member:    GetRowCount() <br>// <br>//  Synopsis:  Retrieves the number of rows in the table. <br>// <br>//  Arguments: pcRows          pointer to number of rows    (OUT) <br>// <br>//  Returns:   S_OK to indicate success. <br>// <br>//------------------------------------------------------------------------ <br> <br>STDMETHODIMP <br>CTDCArr::getRowCount(LONG *pcRows) <br>{ <br>    *pcRows = m_iFilterRows; <br>    return S_OK; <br>} <br> <br>//------------------------------------------------------------------------ <br>// <br>//  Member:    GetColumnCount() <br>// <br>//  Synopsis:  Retrieves the number of column in the table. <br>// <br>//  Arguments: pcCols       pointer to number of columns (OUT) <br>// <br>//  Returns:   S_OK to indicate success. <br>//             E_UNEXPECTED if the table has not been loaded yet. <br>// <br>//------------------------------------------------------------------------ <br> <br>STDMETHODIMP <br>CTDCArr::getColumnCount(LONG *pcCols) <br>{ <br>    *pcCols = m_iCols; <br>    return S_OK; <br>} <br> <br>//------------------------------------------------------------------------ <br>// <br>//  Member:    GetRWStatus() <br>// <br>//  Synopsis:  Gets the read/write status of a cell, row, column or the <br>//             entire array.  Since this implementation of STD can never <br>//             set the read/write status of a cell anywhere, all data <br>//             cells are presumed to have the default access and all <br>//             column heading cells are presumed to be read-only.  Therefore, <br>//             it is not necessary to keep track of this information in <br>//             individual cells, and this function need only return <br>//             the value OSPRW_DEFAULT. <br>// <br>//  Arguments: iRow            row index (-1 means all rows) <br>//             iCols           column index (-1 means all columns) <br>//             prwStatus       pointer to read/write status (OUT) <br>// <br>//  Returns:   S_OK if indices are correct (prwStatus set). <br>//             E_INVALIDARG if indices are out of bounds. <br>//             E_UNEXPECTED if the table has not been loaded yet. <br>// <br>//------------------------------------------------------------------------ <br> <br>STDMETHODIMP <br>CTDCArr::getRWStatus(LONG iRow, LONG iCol, OSPRW *prwStatus) <br>{ <br>    HRESULT hr  = S_OK; <br> <br>    if ((fValidFilterRow(iRow) || iRow == -1) &amp;&amp; <br>        (fValidCol(iCol) || iCol == -1)) <br>    { <br>        if (iRow == -1) <br>        { <br>            //  Should return READONLY if there is only a label row, <br>            //  but frameworks tend to get confused if they want to <br>            //  later insert data. <br>            // <br>//          *prwStatus = m_iDataRows &gt; 0 ? OSPRW_MIXED : OSPRW_READONLY; <br>            *prwStatus = OSPRW_MIXED; <br>        } <br>        else if (iRow == 0) <br>            *prwStatus = OSPRW_READONLY; <br>        else <br>            *prwStatus = OSPRW_DEFAULT; <br>    } <br>    else <br>        hr = E_INVALIDARG; <br>    return hr; <br>} <br> <br>//------------------------------------------------------------------------ <br>// <br>//  Member:    GetVariant() <br>// <br>//  Synopsis:  Retrieves a variant value for a cell. <br>// <br>//  Arguments: iRow            row index <br>//             iCols           column index <br>//             format          output format <br>//             pVar            pointer to storage for resulting value <br>// <br>//  Returns:   S_OK upon success (contents of pVar set). <br>//             E_INVALIDARG if indices are out of bounds. <br>//             E_UNEXPECTED if the table has not been loaded yet. <br>// <br>//------------------------------------------------------------------------ <br> <br>STDMETHODIMP <br>CTDCArr::getVariant(LONG iRow, LONG iCol, OSPFORMAT format, VARIANT *pVar) <br>{ <br>    HRESULT hr  = S_OK; <br> <br>    if (fValidFilterCell(iRow, iCol)) <br>    { <br>        CTDCCell    *pCell  = GetFilterCell(iRow, iCol); <br> <br>        if (format == OSPFORMAT_RAW) <br>        { <br>            //  Copy the raw variant value <br>            // <br>            hr = VariantCopy(pVar, pCell); <br>        } <br>        else if (format == OSPFORMAT_FORMATTED || format == OSPFORMAT_HTML) <br>        { <br>            //  Construct a BSTR value representing the cell <br>            // <br>            if (pCell-&gt;vt == VT_BOOL) <br>            { <br>                //  For OLE DB spec compliance: <br>                //    VariantChangeTypeEx converts booleans in BSTR "0", "-1". <br>                //    This code yields BSTR "False", "True" instead. <br>                // <br>                VariantClear(pVar); <br>                pVar-&gt;vt = VT_BSTR; <br>                hr = VarBstrFromBool(pCell-&gt;boolVal, m_lcid, 0, &amp;pVar-&gt;bstrVal); <br>            } <br>            else <br>            { <br>                hr = VariantChangeTypeEx(pVar, pCell, m_lcid, 0, VT_BSTR); <br>            } <br>            if (!SUCCEEDED(hr)) <br>            { <br>                VariantClear(pVar); <br>                pVar-&gt;vt = VT_BSTR; <br>                pVar-&gt;bstrVal = SysAllocString(L"#Error"); <br>            } <br>        } <br>        else <br>            hr = E_INVALIDARG; <br>    } <br>    else <br>        hr = E_INVALIDARG; <br> <br>    return hr; <br>} <br> <br>//------------------------------------------------------------------------ <br>// <br>//  Member:    SetVariant() <br>// <br>//  Synopsis:  Sets a cell's variant value from a given variant value. <br>//             The given variant type is coerced into the column's <br>//             underlying type. <br>// <br>//  Arguments: iRow            row index <br>//             iCols           column index <br>//             format          output format <br>//             Var             value to be stored in the cell. <br>// <br>//  Returns:   S_OK upon success (contents of pVar set). <br>//             E_INVALIDARG if indices are out of bounds. <br>//             E_UNEXPECTED if the table has not been loaded yet. <br>// <br>//------------------------------------------------------------------------ <br> <br>STDMETHODIMP <br>CTDCArr::setVariant(LONG iRow, LONG iCol, OSPFORMAT format, VARIANT Var) <br>{ <br>    HRESULT hr; <br> <br>    if (fValidFilterCell(iRow, iCol)) <br>    { <br>        CTDCCell    *pCell  = GetFilterCell(iRow, iCol); <br>        CTDCColInfo *pColInfo   = GetColInfo(iCol); <br> <br>        if (format == OSPFORMAT_RAW || <br>            format == OSPFORMAT_FORMATTED || format == OSPFORMAT_HTML) <br>        { <br>            if (m_pEventBroker != NULL) <br>            { <br>                hr = m_pEventBroker-&gt;aboutToChangeCell(iRow, iCol); <br>                if (!SUCCEEDED(hr)) <br>                    goto Cleanup; <br>            } <br> <br>            if (Var.vt == pColInfo-&gt;vtType) <br>                hr = VariantCopy(pCell, &amp;Var); <br>            else <br>            { <br>                //  For OLE DB spec compliance: <br>                //    VariantChangeTypeEx converts booleans in BSTR "0", "-1". <br>                //    This code yields BSTR "False", "True" instead. <br>                // <br>                if (Var.vt == VT_BOOL &amp;&amp; pColInfo-&gt;vtType==VT_BSTR) <br>                { <br>                    VariantClear(pCell); <br>                    pCell-&gt;vt = VT_BSTR; <br>                    hr = VarBstrFromBool(Var.boolVal, m_lcid, 0, &amp;pCell-&gt;bstrVal); <br>                } <br>                else <br>                    hr = VariantChangeTypeEx(pCell, &amp;Var, m_lcid, <br>                                             0, pColInfo-&gt;vtType); <br>            } <br>            if (SUCCEEDED(hr) &amp;&amp; m_pEventBroker != NULL) <br>                hr = m_pEventBroker-&gt;cellChanged(iRow, iCol); <br>            m_fSortFilterDisrupted = TRUE; <br>        } <br>        else <br>            hr = E_INVALIDARG; <br>    } <br>    else <br>        hr = E_INVALIDARG; <br> <br>Cleanup: <br>    return hr; <br>} <br> <br>//------------------------------------------------------------------------ <br>// <br>//  Member:    GetLocale() <br>// <br>//  Synopsis:  Returns the locale of our data. <br>//              <br>//  Arguments: Returns a BSTR, representing an RFC1766 form string for our <br>//             locale.  Note this may not necessarily match our LANGUAGE <br>//             param, if we had one, because teh string is canoncialized <br>//             by using MLang to convert it to an LCID and back to a string <br>//             again. <br>// <br>//  Returns:   S_OK to indicate success. <br>// <br>//------------------------------------------------------------------------ <br> <br>STDMETHODIMP <br>CTDCArr::getLocale(BSTR *pbstrLocale) <br>{ <br>    return m_pML-&gt;GetRfc1766FromLcid(m_lcid, pbstrLocale); <br>} <br> <br> <br>//+----------------------------------------------------------------------- <br>// <br>//  Member:    DeleteRows <br>// <br>//  Synopsis:  Used to delete rows from the table.  Bounds are checked <br>//             to make sure that the rows can all be deleted.  Label row <br>//             cannot be deleted. <br>// <br>//  Arguments: iRow            first row to delete <br>//             cRows           number of rows to delete <br>//             pcRowsDeleted   actual number of rows deleted (OUT) <br>// <br>//  Returns:   S_OK upon success, i.e. all rows could be deleted <br>//             E_INVALIDARG if cRows &lt; 0 or any rows to be deleted <br>//               are out of bounds <br>// <br>//------------------------------------------------------------------------ <br> <br>STDMETHODIMP <br>CTDCArr::deleteRows(LONG iRow, LONG cRows, LONG *pcRowsDeleted) <br>{ <br>    HRESULT hr; <br>    *pcRowsDeleted = 0; <br> <br>    if (fValidFilterRow(iRow) &amp;&amp; iRow &gt; 0 &amp;&amp; cRows &gt;= 0 &amp;&amp; <br>        fValidFilterRow(iRow + cRows - 1)) <br>    { <br>        if (m_pEventBroker != NULL) <br>        { <br>            hr = m_pEventBroker-&gt;aboutToDeleteRows(iRow, cRows); <br>            if (!SUCCEEDED(hr)) <br>                goto Cleanup; <br>        } <br> <br>        *pcRowsDeleted = cRows; <br>        hr = S_OK; <br>        if (cRows &gt; 0) <br>        { <br>            //  Delete the rows from the array <br>            // <br>            m_arrparrFilter.DeleteElems(iRow, cRows); <br>            m_iFilterRows = CalcFilterRows(); <br> <br>            m_fSortFilterDisrupted = TRUE; <br>            //  Notify the event-handler of the deletion <br>            // <br>            if (m_pEventBroker != NULL) <br>                hr = m_pEventBroker-&gt;deletedRows(iRow, cRows); <br>        } <br>    } <br>    else <br>    { <br>        hr = E_INVALIDARG; <br>    } <br>Cleanup: <br>    return hr; <br>} <br> <br>//+----------------------------------------------------------------------- <br>// <br>//  Member:    InsertRows() <br>// <br>//  Synopsis:  Allows for the insertion of new rows.  This can either be <br>//             used to insert new rows between existing rows, or to <br>//             append new rows to the end of the table.  Thus, to <br>//             insert new rows at the end of the table, a user would <br>//             specify the initial row as 1 greater than the current <br>//             row dimension. <br>//             Note that iRow is checked to ensure that it is within the <br>//             proper bounds (1..&lt;current # of rows&gt;+1). <br>//             User cannot delete column heading row. <br>// <br>//  Arguments: iRow            rows will be inserted *before* row 'iRow' <br>//             cRows           how many rows to insert <br>//             pcRowsInserted  actual number of rows inserted (OUT) <br>// <br>//  Returns:   S_OK upon success, i.e. all rows could be inserted. <br>//             E_INVALIDARG if row is out of allowed bounds. <br>//             It is possible that fewer than the requested rows were <br>//             inserted.  In this case, E_OUTOFMEMORY would be returned, <br>//             and the actual number of rows inserted would be set. <br>// <br>//------------------------------------------------------------------------ <br> <br>STDMETHODIMP <br>CTDCArr::insertRows(LONG iRow, LONG cRows, LONG *pcRowsInserted) <br>{ <br>    HRESULT hr  = S_OK; <br>    TSTDArray&lt;CTDCCell&gt; **pRows = NULL; <br>    LONG    iTmpRow; <br> <br>    //  Verify that the insertion row is within range <br>    // <br>    if (iRow &lt; 1 || iRow &gt; m_iFilterRows + 1) <br>    { <br>        hr = E_INVALIDARG; <br>        goto Cleanup; <br>    } <br> <br>    if (cRows &lt;= 0) <br>    { <br>        if (cRows &lt; 0) <br>            hr = E_INVALIDARG; <br>        goto Cleanup; <br>    } <br> <br>    //  Unless success is complete, assume 0 rows inserted. <br>    // <br>    *pcRowsInserted = 0; <br> <br>    //  Allocate a temporary array of rows <br>    // <br>    pRows = new TSTDArray&lt;CTDCCell&gt;* [cRows]; <br>    if (pRows == NULL) <br>    { <br>        hr = E_OUTOFMEMORY; <br>        goto Cleanup; <br>    } <br> <br>    memset(pRows, '\0', sizeof(pRows[0]) * cRows); <br> <br>    for (iTmpRow = 0; iTmpRow &lt; cRows; iTmpRow++) <br>    { <br>        if ((pRows[iTmpRow] = new TSTDArray&lt;CTDCCell&gt;) == NULL) <br>        { <br>            hr = E_OUTOFMEMORY; <br>            goto CleanupTmpRows; <br>        } <br>        hr = pRows[iTmpRow]-&gt;InsertElems(0, m_iCols); <br>        if (!SUCCEEDED(hr)) <br>            goto CleanupTmpRows; <br>    } <br> <br> <br>    //  Expand the Cell-Rows and Filter-Rows arrays to cope with the new rows. <br>    // <br>    _ASSERT(m_iFilterRows &lt;= m_iDataRows); <br>    hr = m_arrparrCells.InsertElems(iRow, cRows); <br>    if (!SUCCEEDED(hr)) <br>        goto CleanupTmpRows; <br>    hr = m_arrparrFilter.InsertElems(iRow, cRows); <br>    if (!SUCCEEDED(hr)) <br>    { <br>        //  Undo the previous allocation <br>        // <br>        m_arrparrCells.DeleteElems(iRow, cRows); <br>        goto CleanupTmpRows; <br>    } <br> <br>    if (m_pEventBroker != NULL) <br>    { <br>        hr = m_pEventBroker-&gt;aboutToInsertRows(iRow, cRows); <br>        if (FAILED(hr)) <br>            goto CleanupTmpRows; <br>    } <br>     <br>    //  Copy across the row pointers <br>    // <br>    for (iTmpRow = 0; iTmpRow &lt; cRows; iTmpRow++) <br>    { <br>        m_arrparrCells[iRow + iTmpRow] = pRows[iTmpRow]; <br>        m_arrparrFilter[iRow + iTmpRow] = pRows[iTmpRow]; <br>    } <br> <br>    //  Return indicating success <br>    // <br>    *pcRowsInserted = cRows; <br>    m_iFilterRows = CalcFilterRows();; <br>    m_iDataRows = CalcDataRows(); <br> <br>    // Fire events: <br>    if (*pcRowsInserted != 0) <br>    { <br>        m_fSortFilterDisrupted = TRUE; <br>        if (m_pEventBroker != NULL) <br>            hr = m_pEventBroker-&gt;insertedRows(iRow, cRows); <br>    } <br>    goto Cleanup; <br> <br>CleanupTmpRows: <br>    //  Free the memory associated with the tmp rows. <br>    // <br>    for (iTmpRow = 0; iTmpRow &lt; cRows; iTmpRow++) <br>        if (pRows[iTmpRow] != NULL) <br>            delete pRows[iTmpRow]; <br> <br>Cleanup: <br>    if (pRows != NULL) <br>        delete pRows; <br>    return hr; <br>} <br> <br>// ;begin_internal <br>//+----------------------------------------------------------------------- <br>// <br>//  Member:    DeleteColumns() <br>// <br>//  Synopsis:  Used to delete columns from the table.  Bounds are checked <br>//             to make sure that the columns can all be deleted.  Label <br>//             column cannot be deleted. <br>// <br>//  Arguments: iCol               first column to delete <br>//             cCols              number of columns to delete <br>//             pcColsDeleted      actual number of rows deleted (OUT) <br>// <br>//  Returns:   S_OK upon succes, i.e. all columns could be deleted <br>//             E_INVALIDARG if column is out of allowed bounds. <br>// <br>//------------------------------------------------------------------------ <br> <br>STDMETHODIMP <br>CTDCArr::DeleteColumns(LONG iCol, LONG cCols, LONG *pcColsDeleted) <br>{ <br>    HRESULT hr; <br> <br>    if (fValidCol(iCol) &amp;&amp; iCol &gt; 0 &amp;&amp; cCols &gt;= 0 &amp;&amp; <br>        fValidCol(iCol + cCols - 1)) <br>    { <br>        *pcColsDeleted = cCols; <br>        hr = S_OK; <br>        if (cCols &gt; 0) <br>        { <br>            for (LONG iRow = 0; iRow &lt; m_iFilterRows; iRow++) <br>            { <br>                TSTDArray&lt;CTDCCell&gt; *pRow; <br> <br>                pRow = m_arrparrCells[iRow]; <br>                pRow-&gt;DeleteElems(iCol - 1, cCols); <br>            } <br>            m_arrColInfo.DeleteElems(iCol - 1, cCols); <br>            m_iCols = CalcCols(); <br> <br>            if (!m_fUseHeader) <br>                RenumberColumnHeadings(); <br> <br>            m_fSortFilterDisrupted = TRUE; <br> <br>            //  Notify the event-handler of the deletion <br>            // <br>#ifdef NEVER <br>            if (m_pEventBroker != NULL) <br>                hr = m_pEventBroker-&gt;DeletedCols(iCol, cCols); <br>#endif <br>        } <br>        _ASSERT(m_arrColInfo.GetSize() == (ULONG) m_iCols); <br>    } <br>    else <br>    { <br>        hr = E_INVALIDARG; <br>        *pcColsDeleted = 0; <br>    } <br>    return hr; <br>} <br> <br>//+----------------------------------------------------------------------- <br>// <br>//  Member:    InsertColumns() <br>// <br>//  Synopsis:  Allows for the insertion of new columns.  This can either be <br>//             used to insert new columns between existing columns, or to <br>//             append new columns to the end of the table.  Thus, to <br>//             insert new columns at the end of the table, a user would <br>//             specify the initial columns as 1 greater than the current <br>//             columns dimension. <br>//             Note that iColumn is checked to ensure that it is within the <br>//             proper bounds (1..&lt;current # of cols&gt;+1). <br>// <br>//  Arguments: iCol            columns will be inserted *before* row 'iCol' <br>//             cCols           how many columns to insert <br>//             pcColsInserted  actual number of columns inserted (OUT) <br>// <br>//  Returns:   S_OK upon success, i.e. all columns could be inserted. <br>//             E_INVALIDARG if column is out of allowed bounds. <br>//             It is possible that fewer than the requested columns were <br>//             inserted.  In this case, E_OUTOFMEMORY would be returned, <br>//             and the actual number of columns inserted would be set. <br>// <br>//------------------------------------------------------------------------ <br> <br>STDMETHODIMP <br>CTDCArr::InsertColumns(LONG iCol, LONG cCols, LONG *pcColsInserted) <br>{ <br>    HRESULT hr  = S_OK; <br>    LONG iTmpRow; <br> <br>    //  Verify that the insertion column is within range <br>    // <br>    if (iCol &lt; 1 || iCol &gt; m_iCols + 1) <br>    { <br>        hr = E_INVALIDARG; <br>        goto Cleanup; <br>    } <br> <br>    if (cCols &lt;= 0) <br>    { <br>        if (cCols &lt; 0) <br>            hr = E_INVALIDARG; <br>        goto Cleanup; <br>    } <br> <br>    //  Unless success is complete, assume 0 columns inserted. <br>    // <br>    *pcColsInserted = 0; <br> <br>    for (iTmpRow = 0; iTmpRow &lt;= m_iDataRows; iTmpRow++) <br>    { <br>        hr = m_arrparrCells[iTmpRow]-&gt;InsertElems(iCol, cCols); <br>        if (!SUCCEEDED(hr)) <br>        { <br>            //  Undo the changes we've done <br>            // <br>            while (--iTmpRow &gt;= 0) <br>                m_arrparrCells[iTmpRow]-&gt;DeleteElems(iCol, cCols); <br>            goto Cleanup; <br>        } <br>    } <br> <br>    //  Return indicating success <br>    // <br>    *pcColsInserted = cCols; <br>    m_iCols = CalcCols(); <br>     <br>    // Fire events: <br>    if (*pcColsInserted != 0) <br>    { <br>        m_fSortFilterDisrupted = TRUE; <br>#ifdef NEVER <br>        if (m_pEventBroker != NULL) <br>            hr = m_pEventBroker-&gt;InsertedCols(iCol, cCols); <br>#endif <br>    } <br> <br>Cleanup: <br>    //  If we're using automatically numbered column headings and some <br>    //  columns were inserted, then renumber the columns. <br>    // <br>    if (*pcColsInserted &gt; 0 &amp;&amp; !m_fUseHeader) <br>        RenumberColumnHeadings(); <br> <br>    return hr; <br>} <br>// ;end_internal <br> <br>//+----------------------------------------------------------------------- <br>// <br>//  Member:    Find() <br>// <br>//  Synopsis:  Searches for a row matching the specified criteria <br>// <br>//  Arguments: iRowStart       The starting row for the search <br>//             iCol            The column being tested <br>//             vTest           The value against which cells in the <br>//                               test column are tested <br>//             findFlags       Flags indicating whether to search up/down <br>//                               and whether comparisons are case sensitive. <br>//             compType        The comparison operator for matching (find a <br>//                             cell =, &gt;=, &lt;=, &gt;, &lt;, &lt;&gt; the test value) <br>//             piRowFound      The row with a matching cell [OUT] <br>// <br>//  Returns:   S_OK upon success, i.e. a row was found (piRowFound set). <br>//             E_FAIL upon failure, i.e. a row was not found. <br>//             E_INVALIDARG if starting row 'iRowStart' or test column 'iCol' <br>//               are out of bounds. <br>//             DISP_E_TYPEMISMATCH if the test value's type does not match <br>//               the test column's type. <br>// <br>//------------------------------------------------------------------------ <br> <br>STDMETHODIMP <br>CTDCArr::find(LONG iRowStart, LONG iCol, VARIANT vTest, <br>        OSPFIND findFlags, OSPCOMP compType, LONG *piRowFound) <br>{ <br>    HRESULT hr = S_OK; <br>    boolean fUp = FALSE; <br>    boolean fCaseSensitive  = FALSE; <br>    LONG    iRow; <br> <br>    *piRowFound = -1; <br> <br>    //  Validate arguments <br>    // <br>    if (iRowStart &lt; 1 || !fValidFilterRow(iRowStart) || !fValidCol(iCol)) <br>    { <br>        hr = E_INVALIDARG; <br>        goto Cleanup; <br>    } <br> <br>    if (GetColInfo(iCol)-&gt;vtType != vTest.vt) <br>    { <br>        //  Search-value type does not match the underlying column type <br>        //  Fail as per spec. <br>        // <br>        hr = DISP_E_TYPEMISMATCH; <br>        goto Cleanup; <br>    } <br> <br>    if ((findFlags &amp; OSPFIND_UP) != 0) <br>        fUp = TRUE; <br>    if ((findFlags &amp; OSPFIND_CASESENSITIVE) != 0) <br>        fCaseSensitive = TRUE; <br> <br>    for (iRow = iRowStart; <br>         fUp ? iRow &gt; 0 : iRow &lt;= m_iFilterRows; <br>         fUp ? iRow-- : iRow++) <br>    { <br>        int         iCmp = VariantComp(GetFilterCell(iRow, iCol), &amp;vTest, vTest.vt, fCaseSensitive); <br>        boolean     fFound  = FALSE; <br> <br>        switch (compType) <br>        { <br>        case OSPCOMP_LT:    fFound = iCmp &lt;  0; break; <br>        case OSPCOMP_LE:    fFound = iCmp &lt;= 0; break; <br>        case OSPCOMP_GT:    fFound = iCmp &gt;  0; break; <br>        case OSPCOMP_GE:    fFound = iCmp &gt;= 0; break; <br>        case OSPCOMP_EQ:    fFound = iCmp == 0; break; <br>        case OSPCOMP_NE:    fFound = iCmp != 0; break; <br>        default: <br>            hr = E_INVALIDARG; <br>            goto Cleanup; <br>        } <br>        if (fFound) <br>        { <br>            *piRowFound = iRow; <br>            hr = S_OK; <br>            goto Cleanup; <br>        } <br>    } <br> <br>    hr = E_FAIL; <br>         <br>Cleanup: <br>    return hr; <br>} <br> <br>//+----------------------------------------------------------------------- <br>// <br>//  Member:    addOLEDBSimpleProviderListener() <br>// <br>//  Synopsis:  Sets or clears a reference to the COM object which receives <br>//             notifications of cell changes, row/column insert/deletes etc. <br>// <br>//  Arguments: pEvent          Pointer to the COM object to receive <br>//                             notifications, or NULL if no notifications <br>//                             are to be sent. <br>// <br>//  Returns:   S_OK upon success. <br>//             Error code upon success. <br>// <br>//------------------------------------------------------------------------ <br> <br>STDMETHODIMP <br>CTDCArr::addOLEDBSimpleProviderListener(OLEDBSimpleProviderListener *pSTDEvents) <br>{ <br>    HRESULT hr = S_OK; <br> <br>    if (m_pEventBroker == NULL) <br>        hr = E_FAIL; <br>    else <br>    { <br>        hr = m_pEventBroker-&gt;SetSTDEvents(pSTDEvents); <br>        // If the event sink has been added, and we're already loaded, <br>        // then fire transferComplete, because we probably couldn't before. <br>        if (LS_LOADED==m_state) <br>            m_pEventBroker-&gt;STDLoadCompleted(); <br>    } <br>    return hr; <br>} <br> <br>STDMETHODIMP <br>CTDCArr::removeOLEDBSimpleProviderListener(OLEDBSimpleProviderListener *pSTDEvents) <br>{ <br>    HRESULT hr = S_OK; <br> <br>    if (m_pEventBroker &amp;&amp; pSTDEvents==m_pEventBroker-&gt;GetSTDEvents()) <br>        hr = m_pEventBroker-&gt;SetSTDEvents(NULL); <br>    return hr; <br>} <br> <br>//+----------------------------------------------------------------------- <br>// <br>//  Member:    FindCol() <br>// <br>//  Synopsis:  Locate a column by name <br>// <br>//  Arguments: pwchColName        Name of column to locate <br>// <br>//  Returns:   +ve Column number upon success (column name matched) <br>//             0 upon failure (no column name matched) <br>// <br>//------------------------------------------------------------------------ <br> <br>LONG <br>CTDCArr::FindCol(LPWCH pwchColName) <br>{ <br>    LONG iCol = 0; <br> <br>    if (pwchColName != NULL) <br>    { <br>        for (iCol = m_iCols; iCol &gt; 0; iCol--) </code></pre>
<p>
</p>
<pre><code>{ <br>            CTDCCell    *pCell  = GetDataCell(0, iCol); <br> <br>            _ASSERT(pCell-&gt;vt == VT_BSTR); <br>            if (wch_icmp(pwchColName, pCell-&gt;bstrVal) == 0) <br>                break; <br>        } <br>    } <br>    return iCol; <br>} <br> <br>class SortElt <br>{ <br>public: <br>    CTDCArr *pInstance; <br>    int     iRow; <br>    TSTDArray&lt;CTDCCell&gt; *   parrRow; <br>}; <br> <br>//+----------------------------------------------------------------------- <br>// <br>//  Function:  CompareSort() <br>// <br>//  Synopsis:  Called by qsort() to order the rows of a table. <br>// <br>//  Arguments: pElt1, pElt1       pointers to elements to be compared <br>// <br>//  Returns:   -1 if the first element is less than the second element <br>//              0 if the first element equals the second element <br>//             +1 if the first element is greater than the second element <br>// <br>//------------------------------------------------------------------------ <br> <br>static int <br>CompareSort(const void *pElt1, const void *pElt2) <br>{ <br>    SortElt *pse1   = (SortElt *) pElt1; <br>    SortElt *pse2   = (SortElt *) pElt2; <br> <br>    return pse1-&gt;pInstance-&gt;SortComp(pse1-&gt;iRow, pse2-&gt;iRow); <br>} <br> <br>//+----------------------------------------------------------------------- <br>// <br>//  Function:  extract_num() <br>// <br>//  Synopsis:  Extracts the first non-negative number from the character <br>//             stream referenced by 'ppwch'.  Updates 'ppwch' to point <br>//             to the character following the digits found. <br>// <br>//  Arguments: ppwch      Pointer to null-terminated WCHAR string <br>// <br>//  Returns:   Non-negative number extracted upon success (pointer updated) <br>//             -1 upon failure (no digits found; pointer moved to end-of-string <br>// <br>//+----------------------------------------------------------------------- <br> <br>static int <br>extract_num(WCHAR **ppwch) <br>{ <br>    int retval  = 0; <br>    boolean fFoundDigits    = FALSE; <br> <br>    if (*ppwch != NULL) <br>    { <br>        //  Skip over leading non-digits <br>        // <br>        while ((**ppwch) != 0 &amp;&amp; ((**ppwch) &lt; L'0' || (**ppwch) &gt; L'9')) <br>            (*ppwch)++; <br> <br>        //  Accumulate digits <br>        // <br>        fFoundDigits = *ppwch != 0; <br>        while ((**ppwch) &gt;= L'0' &amp;&amp; (**ppwch) &lt;= L'9') <br>            retval = 10 * retval + *(*ppwch)++ - L'0'; <br>    } <br> <br>    return fFoundDigits ? retval : -1; <br>} <br> <br> <br>//+----------------------------------------------------------------------- <br>// <br>//  Member:    CreateNumberedColumnHeadings() <br>// <br>//  Synopsis:  Allocates cells for numbered column headings. <br>// <br>//  Arguments: None. <br>// <br>//  Returns:   S_OK upon success. <br>//             E_OUTOFMEMORY if there was insufficient memory to complete <br>//             the operation. <br>// <br>//------------------------------------------------------------------------ <br> <br>HRESULT CTDCArr::CreateNumberedColumnHeadings() <br>{ <br>    HRESULT hr  = S_OK; <br>    LONG    iCol; <br> <br>    iCol = m_iCols; <br> <br>    //  Allocate a new row entry <br>    // <br>    hr = m_arrparrCells.InsertElems(0, 1); <br>    if (!SUCCEEDED(hr)) <br>        goto Cleanup; <br> <br>    //  Allocate a new row of cells <br>    // <br>    m_arrparrCells[0] = new TSTDArray&lt;CTDCCell&gt;; <br>    if (m_arrparrCells[0] == NULL) <br>    { <br>        hr = E_OUTOFMEMORY; <br>        goto Cleanup; <br>    } <br>    hr = m_arrparrCells[0]-&gt;InsertElems(0, iCol); <br> <br>Cleanup: <br>    return hr; <br>} <br> <br>//+----------------------------------------------------------------------- <br>// <br>//  Member:    RenumberColumnHeadings() <br>// <br>//  Synopsis:  Set the automatic name "Column&lt;column-number&gt;" for each column <br>// <br>//  Arguments: None. <br>// <br>//  Returns:   Nothing. <br>// <br>//------------------------------------------------------------------------ <br> <br>void CTDCArr::RenumberColumnHeadings() <br>{ <br>    for (LONG iCol = m_iCols; iCol &gt; 0; iCol--) <br>    { <br>        CTDCCell    *pCell  = GetDataCell(0, iCol); <br>        WCHAR       awchLabel[20]; <br> <br>        wch_cpy(awchLabel, L"Column"); <br>        _ltow(iCol, &amp;awchLabel[6], 10); <br> <br>        pCell-&gt;clear(); <br>        pCell-&gt;vt = VT_BSTR; <br>        pCell-&gt;bstrVal = SysAllocString(awchLabel); <br>    } <br>} <br> <br>//+----------------------------------------------------------------------- <br>// <br>//  Member:    ParseColumnHeadings() <br>// <br>//  Synopsis:  Extracts type information (if present) from column <br>//             headings, removes leadning <br>// <br>//  Arguments: None. <br>// <br>//  Returns:   S_OK upon success. <br>//             E_OUTOFMEMORY if there was insufficient memory to complete <br>//             the operation. <br>// <br>//------------------------------------------------------------------------ <br> <br>HRESULT CTDCArr::ParseColumnHeadings() <br>{ <br>    LPWCH   pwchIntType     = L"int"; <br>    LPWCH   pwchFloatType   = L"float"; <br>    LPWCH   pwchStringType  = L"string"; <br>    LPWCH   pwchBooleanType = L"boolean"; <br>    LPWCH   pwchDateType    = L"date"; <br> <br>    HRESULT hr  = S_OK; <br>    LONG    iCol; <br> <br>    iCol = m_iCols; <br> <br>    //  Allocate space for column type info <br>    // <br>    hr = m_arrColInfo.InsertElems(0, iCol); <br>    if (!SUCCEEDED(hr)) <br>        goto Cleanup; <br> <br>    for (; iCol &gt; 0; iCol--) <br>    { <br>        //  Column headings have the format: <br>        //      &lt;column-name&gt;[:&lt;typename&gt;[,&lt;format&gt;]] <br>        // <br>        CTDCColInfo *pColInfo   = GetColInfo(iCol); <br>        CTDCCell    *pCell      = GetDataCell(0, iCol); <br> <br>        _ASSERT(pCell-&gt;vt == VT_BSTR); <br> <br>        BSTR        bstr; <br>        LPWCH       pColon; <br> <br>        bstr = pCell-&gt;bstrVal; <br>        pColInfo-&gt;vtType = VT_BSTR;     //  Default type for a column is BSTR <br>        pColon = wch_chr(bstr, L':'); <br>        if (pColon != NULL) <br>        { <br>            WCHAR   *pwchFormat = NULL; <br>            LPWCH   pSpace; <br> <br>            *pColon++ = 0; <br>            pSpace = wch_chr(pColon, L' '); <br> <br>            if (pSpace != NULL) <br>            { <br>                *pSpace++ = '\0'; <br>                pwchFormat = pSpace; <br>            } <br>            if (wch_icmp(pColon, pwchIntType) == 0) <br>                pColInfo-&gt;vtType = VT_I4; <br>            else if (wch_icmp(pColon, pwchFloatType) == 0) <br>                pColInfo-&gt;vtType = VT_R8; <br>            else if (wch_icmp(pColon, pwchStringType) == 0) <br>                pColInfo-&gt;vtType = VT_BSTR; <br>            else if (wch_icmp(pColon, pwchBooleanType) == 0) <br>                pColInfo-&gt;vtType = VT_BOOL; <br>            else if (wch_icmp(pColon, pwchDateType) == 0) <br>            { <br>                pColInfo-&gt;vtType = VT_DATE; <br> <br>                TDCDateFmt  fmt = TDCDF_NULL; <br> <br>                if (pwchFormat != NULL) <br>                { <br>                    int nPos    = 0; <br>                    int nDayPos = 0; <br>                    int nMonPos = 0; <br>                    int nYearPos= 0; <br> <br>                    //  Convert the format string into an internal enum type <br>                    //  Find the relative positions of the letters 'D' 'M' 'Y' <br>                    // <br>                    for (; *pwchFormat != 0; nPos++, pwchFormat++) <br>                    { <br>                        switch (*pwchFormat) <br>                        { <br>                        case L'D': <br>                        case L'd': <br>                            nDayPos = nPos; <br>                            break; <br>                        case L'M': <br>                        case L'm': <br>                            nMonPos = nPos; <br>                            break; <br>                        case L'Y': <br>                        case L'y': <br>                            nYearPos = nPos; <br>                            break; <br>                        } <br>                    } <br>                    //  Compare the relative positions to work out the format <br>                    // <br>                    if (nDayPos &lt; nMonPos &amp;&amp; nMonPos &lt; nYearPos) <br>                        fmt = TDCDF_DMY; <br>                    else if (nMonPos &lt; nDayPos &amp;&amp; nDayPos &lt; nYearPos) <br>                        fmt = TDCDF_MDY; <br>                    else if (nDayPos &lt; nYearPos &amp;&amp; nYearPos &lt; nMonPos) <br>                        fmt = TDCDF_DYM; <br>                    else if (nMonPos &lt; nYearPos &amp;&amp; nYearPos &lt; nDayPos) <br>                        fmt = TDCDF_MYD; <br>                    else if (nYearPos &lt; nMonPos &amp;&amp; nMonPos &lt; nDayPos) <br>                        fmt = TDCDF_YMD; <br>                    else if (nYearPos &lt; nDayPos &amp;&amp; nDayPos &lt; nMonPos) <br>                        fmt = TDCDF_YDM; <br>                } <br>                pColInfo-&gt;datefmt = fmt; <br>            } <br>        } <br> <br>        if (bstr != NULL) <br>        { <br>            //  Remove leading/trailing spaces from column name <br>            // <br>            LPWCH       pwch; <br>            LPWCH       pwchDest = NULL; <br>            LPWCH       pLastNonSpace = NULL; <br> <br>            for (pwch = bstr; *pwch != 0; pwch++) <br>            { <br>                if (!fWCHIsSpace(*pwch)) <br>                { <br>                    if (pwchDest == NULL) <br>                        pwchDest = bstr; <br>                    pLastNonSpace = pwchDest; <br>                } <br>                if (pwchDest != NULL) <br>                    *pwchDest++ = *pwch; <br>            } <br>            if (pLastNonSpace == NULL) <br>                bstr[0] = 0;        // all spaces!  Make it null string. <br>            else <br>                pLastNonSpace[1] = 0; <br>        } <br> <br>        //  Copy the modified column header and free the original <br>        // <br>        pCell-&gt;bstrVal = SysAllocString(bstr); <br>        SysFreeString(bstr); <br> <br>        if (pCell-&gt;bstrVal == NULL) <br>        { <br>            hr = E_OUTOFMEMORY; <br>            goto Cleanup; <br>        } <br>    } <br>Cleanup: <br>    return hr; <br>} <br> <br>//+----------------------------------------------------------------------- <br>// <br>//  Member:    VariantFromBSTR() <br>// <br>//  Synopsis:  Convert a BSTR value into a variant compatible with a <br>//             given column type. <br>// <br>//  Arguments: pVar       Pointer to resultant variant value <br>//             bstr       Source BSTR <br>//             pColInfo   Column information (type, format options etc). <br>//             lcid       Locale # for locale-specific conversion. <br>// <br>//  Returns:   S_OK upon success (pVar set) <br>//             OLE_E_CANTCONVERT if the given BSTR is badly formatted <br>//               (e.g. contains an invalid date value for a date conversion). <br>//             E_OUTOFMEMORY if insufficient memory is available for <br>//               a conversion. <br>// <br>//------------------------------------------------------------------------ <br> <br>HRESULT CTDCArr::VariantFromBSTR(VARIANT *pVar, BSTR bstr, CTDCColInfo *pColInfo, LCID lcid) <br>{ <br>    HRESULT hr  = E_FAIL; <br> <br>    VariantInit(pVar); <br>    switch (pColInfo-&gt;vtType) <br>    { <br>    case VT_DATE: <br>        if (pColInfo-&gt;datefmt != TDCDF_NULL) <br>        { <br>            //  Parse the date string according to specified format. <br>            //  First, find the three numeric components in the date. <br>            // <br>            int  n1; <br>            int  n2; <br>            int  n3; <br>            WCHAR   *pwch   = bstr; <br>            SYSTEMTIME  st; <br> <br>            n1 = extract_num(&amp;pwch); <br>            n2 = extract_num(&amp;pwch); <br>            n3 = extract_num(&amp;pwch); <br> <br>            memset(&amp;st, '\0', sizeof(st)); <br>            switch (pColInfo-&gt;datefmt) <br>            { <br>            case TDCDF_DMY: <br>                st.wDay = n1; <br>                st.wMonth = n2; <br>                st.wYear = n3; <br>                break; <br>            case TDCDF_MDY: <br>                st.wDay = n2; <br>                st.wMonth = n1; <br>                st.wYear = n3; <br>                break; <br>            case TDCDF_DYM: <br>                st.wDay = n1; <br>                st.wMonth = n3; <br>                st.wYear = n2; <br>                break; <br>            case TDCDF_MYD: <br>                st.wDay = n3; <br>                st.wMonth = n1; <br>                st.wYear = n2; <br>                break; <br>            case TDCDF_YMD: <br>                st.wDay = n3; <br>                st.wMonth = n2; <br>                st.wYear = n1; <br>                break; <br>            case TDCDF_YDM: <br>                st.wDay = n2; <br>                st.wMonth = n3; <br>                st.wYear = n1; <br>                break; <br>            } <br> <br>            VariantClear(pVar); <br>            if (n1 &gt;= 0 &amp;&amp; n2 &gt;= 0 &amp;&amp; n3 &gt;= 0 &amp;&amp; <br>                SystemTimeToVariantTime(&amp;st, &amp;pVar-&gt;date)) <br>            { <br>                pVar-&gt;vt = VT_DATE; <br>                hr = S_OK; <br>            } <br>            else <br>                hr = OLE_E_CANTCONVERT; <br>        } <br>        else <br>        { <br>            //  No date format specified - just use the default conversion <br>            // <br>            VARIANT vSrc; <br> <br>            VariantInit(&amp;vSrc); <br>            vSrc.vt = VT_BSTR; <br>            vSrc.bstrVal = bstr; <br>            hr = VariantChangeTypeEx(pVar, &amp;vSrc, lcid, 0, pColInfo-&gt;vtType); <br>        } <br>        break; <br>    case VT_BOOL: <br>    case VT_I4: <br>    case VT_R8: <br>    default: <br>        // <br>        //  Perform a standard conversion. <br>        // <br>        { <br>            VARIANT vSrc; <br> <br>            VariantInit(&amp;vSrc); <br>            vSrc.vt = VT_BSTR; <br>            vSrc.bstrVal = bstr; <br>            hr = VariantChangeTypeEx(pVar, &amp;vSrc, lcid, 0, pColInfo-&gt;vtType); <br>        } <br>        break; <br>    case VT_BSTR: <br>        // <br>        //  Duplicate the BSTR <br>        // <br>        pVar-&gt;bstrVal = SysAllocString(bstr); <br>        if (bstr != NULL &amp;&amp; pVar-&gt;bstrVal == NULL) <br>            hr = E_OUTOFMEMORY; <br>        else <br>        { <br>            pVar-&gt;vt = VT_BSTR; <br>            hr = S_OK; <br>        } <br>        break; <br>    } <br>    return hr; <br>} <br> <br>//+----------------------------------------------------------------------- <br>// <br>//  Member:    VariantComp() <br>// <br>//  Synopsis:  Compares two variant values. <br>// <br>//  Arguments: pVar1            First variant value <br>//             pVar2            Second variant value <br>//             fCaseSensitive   TRUE if string comparisons should be <br>//                              case-sensitive, false if string comparisons <br>//                              should be case-insensitive.  Ignored if <br>//                              non-string data types are being compared. <br>// <br>//  Returns:   -1 if  <br>//             OLE_E_CANTCONVERT if the given BSTR is badly formatted <br>//               (e.g. contains an invalid date value for a date conversion). <br>//             E_OUTOFMEMORY if insufficient memory is available for <br>//               a conversion. <br>// <br>//------------------------------------------------------------------------ <br> <br>int CTDCArr::VariantComp(VARIANT *pVar1, VARIANT *pVar2, VARTYPE type, <br>    boolean fCaseSensitive) <br>{ <br>    int retval = 0; <br> <br>    //  NULLs are lexically less than anything else <br>    // <br>    if (pVar1-&gt;vt == VT_NULL) <br>        retval = pVar2-&gt;vt == VT_NULL ? 0 : -1; <br>    else if (pVar2-&gt;vt == VT_NULL) <br>        retval = 1; <br>    else if (pVar1-&gt;vt != type) <br>    { <br>        //  Type-mismatches are lexically greater than anything else <br>        // <br>        retval = pVar2-&gt;vt == type ? 1 : 0; <br>    } <br>    else if (pVar2-&gt;vt != type) <br>    { <br>        //  Type-mismatches are lexically greater than anything else <br>        // <br>        retval = -1; <br>    } <br>    else <br>    { <br>        switch (type) <br>        { <br>        case VT_I4: <br>            retval = pVar1-&gt;lVal &lt; pVar2-&gt;lVal <br>                ? -1 <br>                : pVar1-&gt;lVal &gt; pVar2-&gt;lVal <br>                    ? 1 <br>                    : 0; <br>            break; <br>        case VT_R8: <br>            retval = pVar1-&gt;dblVal &lt; pVar2-&gt;dblVal <br>                ? -1 <br>                : pVar1-&gt;dblVal &gt; pVar2-&gt;dblVal <br>                    ? 1 <br>                    : 0; <br>            break; <br>        case VT_BSTR: <br>            retval = fCaseSensitive <br>                ? wch_cmp(pVar1-&gt;bstrVal, pVar2-&gt;bstrVal) <br>                : wch_icmp(pVar1-&gt;bstrVal, pVar2-&gt;bstrVal); <br>            break; <br>        case VT_BOOL: <br>            retval = pVar1-&gt;boolVal <br>                ? (pVar2-&gt;boolVal ? 0 : 1) <br>                : (pVar2-&gt;boolVal ? -1 : 0); <br>            break; <br>        case VT_DATE: <br>            retval = pVar1-&gt;date &lt; pVar2-&gt;date <br>                ? -1 <br>                : pVar1-&gt;date &gt; pVar2-&gt;date <br>                    ? 1 <br>                    : 0; <br>            break; <br>        default: <br>            retval = 0;     //  Unrecognised types are all lexically equal <br>            break; <br>        } <br>    } <br> <br>    return retval; <br>} <br> <br>//+----------------------------------------------------------------------- <br>// <br>//  Method:    CreateSortList() <br>// <br>//  Synopsis:  Creates a list of sort criteria from a text description. <br>// <br>//  Arguments: bstrSortCols          ';'-separted list of column names, <br>//                                   optionally prefixed with '+' (default) <br>//                                   or '-' indicating ascending or descending <br>//                                   sort order respectively for that column. <br>// <br>//  Returns:   S_OK upon success. <br>//             E_OUTOFMEMORY if insufficient memory is available for <br>//               the construction of sort criteria. <br>// <br>//  Side Effect:   Saves created list in m_pSortList <br>// <br>//+----------------------------------------------------------------------- <br> <br>HRESULT CTDCArr::CreateSortList(BSTR bstrSortCols) <br>{ <br>    HRESULT     hr = S_OK; <br> <br>    if (m_pSortList != NULL) <br>    { <br>        delete m_pSortList; <br>        m_pSortList = NULL; <br>    } <br>    if (bstrSortCols != NULL) <br>    { <br>        WCHAR   *pwchEnd  = bstrSortCols; <br>        CTDCSortCriterion   **pLast = &amp;m_pSortList; <br> <br>        while (*pwchEnd != 0) <br>        { <br>            WCHAR   *pwchStart  = pwchEnd; <br>            boolean fSortAscending = TRUE; <br> <br>            //  Discard leading white space and field-separators <br>            // <br>            while (*pwchStart == L';' || fWCHIsSpace(*pwchStart)) <br>                pwchStart++; <br>             <br>            //  Strip off optional direction indicator + white space <br>            // <br>            if (*pwchStart == L'+' || *pwchStart == '-') <br>            { <br>                fSortAscending = *pwchStart++ == L'+'; <br>                while (fWCHIsSpace(*pwchStart)) <br>                    pwchStart++; <br>            } <br> <br>            //  Find the field terminator. <br>            //  Strip out trailing white spaces. <br>            // <br>            for (pwchEnd = pwchStart; *pwchEnd != 0 &amp;&amp; *pwchEnd != L';';) <br>                pwchEnd++; <br> <br>            while (pwchStart &lt; pwchEnd &amp;&amp; fWCHIsSpace(pwchEnd[-1])) <br>                pwchEnd--; <br> <br>            //  Ignore blank column names - this could be the result of <br>            //  a leading or trailing ';'. <br>            // <br>            if (pwchStart &gt;= pwchEnd) <br>                continue; <br> <br>            //  Find the column number from the column name <br>            // <br>            BSTR bstrColName = SysAllocStringLen(pwchStart, pwchEnd - pwchStart); <br> <br>            if (bstrColName == NULL) <br>            { <br>                hr = E_OUTOFMEMORY; <br>                goto Cleanup; <br>            } <br>            LONG iCol = FindCol(bstrColName); <br>            SysFreeString(bstrColName); <br> <br>            if (iCol &gt; 0) <br>            { <br>                //  Allocate a node for this criterion <br>                // <br>                _ASSERT(*pLast == NULL); <br>                *pLast = new CTDCSortCriterion; <br>                if (*pLast == NULL) <br>                { <br>                    hr = E_OUTOFMEMORY; <br>                    goto Cleanup; <br>                } <br>                (*pLast)-&gt;m_fSortAscending = fSortAscending; <br>                (*pLast)-&gt;m_iSortCol = iCol; <br>                pLast = &amp;(*pLast)-&gt;m_pNext; <br>            } <br>        } <br>    } <br> <br>Cleanup: <br>    return hr; <br>} <br> <br>//+----------------------------------------------------------------------- <br>// <br>//  Method:    SortComp() <br>// <br>//  Synopsis:  Compares two rows using the elememts in the columns specified <br>//             by the current sort criteria. <br>// <br>//  Arguments: iRow1      Index of first row being compared <br>//             iRow2      Index of second row being compared <br>// <br>//  Returns:   -1 if first row should be sorted before the second row <br>//             0 if rows are equal <br>//             1 if first row should be sorted after the second row <br>// <br>//+----------------------------------------------------------------------- <br> <br>int CTDCArr::SortComp(LONG iRow1, LONG iRow2) <br>{ <br>    CTDCSortCriterion   *pCriterion; <br>    int     cmp = 0; <br> <br>    for (pCriterion = m_pSortList; <br>         pCriterion != NULL &amp;&amp; cmp == 0; <br>         pCriterion = pCriterion-&gt;m_pNext) <br>    { <br>        CTDCCell    *pCell1 = GetFilterCell(iRow1, pCriterion-&gt;m_iSortCol); <br>        CTDCCell    *pCell2 = GetFilterCell(iRow2, pCriterion-&gt;m_iSortCol); <br> <br>        cmp = VariantComp(pCell1, pCell2, GetColInfo(pCriterion-&gt;m_iSortCol)-&gt;vtType, <br>                         m_fCaseSensitive); <br>        if (!pCriterion-&gt;m_fSortAscending) <br>            cmp = -cmp; <br>    } <br>    return cmp; <br>} <br> <br>//+----------------------------------------------------------------------- <br>// <br>//  Method:    FilterParseComplex() <br>// <br>//  Synopsis:  Takes the text of a filter query, parses it and creates <br>//             a tree of CTDCFilterNode representing the query. <br>// <br>//  Arguments: phr: pointer to HRESULT value, set to indicate success/failure. <br>// <br>//             ppwchQuery:  This is a textual representation of a query.  The <br>//                          query language syntax is: <br>// <br>//               Query ::== Complex <br>// <br>//               Complex ::== Simple <br>//                       ::== Simple '&amp;' Simple ( '&amp;' Simple ... ) <br>//                       ::== Simple '|' Simple ( '|' Simple ... ) <br>// <br>//               Simple ::== '(' Complex ')' <br>//                      ::== Atom Relop Atom <br>// <br>//               Relop ::== '=' | '&gt;' | '&gt;=' | '&lt;' | '&lt;=' | '&lt;&gt;' <br>// <br>//               Atom ::== Bunch of characters up to a (, ), &gt;, &lt;, =, &amp; or | <br>//                         If it's recognisable as field name, then it's <br>//                         treated as a field name.  Otherwise it's treated <br>//                         as a value.  Quotes (") are processed, and force <br>//                         the atom to be treated as a value.  Escape <br>//                         characters (\) are processed and allow the <br>//                         use of special characters within a field name. <br>// <br>//               Notes: <br>//               ----- <br>//                  * The definition of 'Complex' expressly forbids mixing <br>//                    logical ANDs and ORs ('&amp;' and '|') unless parentheses <br>//                    are used to clarify the query.  Something like: <br>//                          field1 &gt; 2 &amp; field3 = "lime" | field4 &lt; 5 <br>//                    is illegal, but: <br>//                          (field1 &gt; 2 &amp; field3 = "lime") | field4 &lt; 5 <br>//                    is fine. <br>// <br>//                  * It is illegal to attempt a comparison of two columns <br>//                    with different types. <br>// <br>// <br>//  Returns:   Pointer to parsed Filter Node upon success (*phr set to S_OK) <br>//             NULL upon failure (*phr set to an appropriate error code) <br>// <br>//+----------------------------------------------------------------------- <br> <br>CTDCFilterNode *CTDCArr::FilterParseComplex(LPWCH *ppwchQuery, HRESULT *phr) <br>{ <br>    *phr = S_OK; <br>    CTDCFilterNode  *retval; <br>    WCHAR   wchBoolOp   = 0; <br> <br>    retval = FilterParseSimple(ppwchQuery, phr); <br> <br>    //  Stop if there's an error, or we encounter a terminating ')' or '\0' <br>    // <br>    while (retval != NULL &amp;&amp; **ppwchQuery != L')' &amp;&amp; **ppwchQuery != 0) <br>    { <br>        //  Next character should be a matching logical connector ... <br>        // <br>        if (**ppwchQuery != L'&amp;' &amp;&amp; **ppwchQuery != L'|') <br>        { <br>            *phr = E_FAIL; <br>            break; <br>        } <br>        if (wchBoolOp == 0) <br>            wchBoolOp = **ppwchQuery; <br>        else if (wchBoolOp != **ppwchQuery) <br>        { <br>            *phr = E_FAIL; <br>            break; <br>        } <br>        (*ppwchQuery)++; <br>        CTDCFilterNode *pTmp = new CTDCFilterNode; <br>        if (pTmp == NULL) <br>        { <br>            *phr = E_OUTOFMEMORY; <br>            break; <br>        } <br>        pTmp-&gt;m_type = (wchBoolOp == L'&amp;') <br>            ? CTDCFilterNode::NT_AND <br>            : CTDCFilterNode::NT_OR; <br>        pTmp-&gt;m_pLeft = retval; <br>        retval = pTmp; <br>        retval-&gt;m_pRight = FilterParseSimple(ppwchQuery, phr); <br>        if (retval-&gt;m_pRight == NULL) <br>            break; <br>    } <br>    if (!SUCCEEDED(*phr) &amp;&amp; retval != NULL) <br>    { <br>        delete retval; <br>        retval = NULL; <br>    } <br>    return retval; <br>} <br> <br>CTDCFilterNode *CTDCArr::FilterParseSimple(LPWCH *ppwch, HRESULT *phr) <br>{ <br>    *phr = S_OK; <br>    CTDCFilterNode  *retval = NULL; <br> <br>    fWCHEatSpace(ppwch);    //  Eat up white space <br> <br>    if (fWCHEatTest(ppwch, L'(')) <br>    { <br>        retval = FilterParseComplex(ppwch, phr); <br>        if (retval != NULL) <br>        { <br>            if (fWCHEatTest(ppwch, L')')) <br>                fWCHEatSpace(ppwch);    //  Eat up white space <br>            else <br>                *phr = E_FAIL; <br>        } <br>        goto Cleanup; <br>    } <br> <br>    retval = FilterParseAtom(ppwch, phr); <br>    if (retval == NULL) <br>        goto Cleanup; <br> <br>    { <br>        CTDCFilterNode *pTmp = new CTDCFilterNode; <br>        if (pTmp == NULL) <br>        { <br>            *phr = E_OUTOFMEMORY; <br>            goto Cleanup; <br>        } <br>        pTmp-&gt;m_pLeft = retval; <br>        retval = pTmp; <br>    } <br> <br>    retval-&gt;m_vt = retval-&gt;m_pLeft-&gt;m_vt; <br> <br>    //  Get the relational operator <br>    // <br>    if (fWCHEatTest(ppwch, L'=')) <br>        retval-&gt;m_type = CTDCFilterNode::NT_EQ; <br>    else if (fWCHEatTest(ppwch, L'&gt;')) <br>        retval-&gt;m_type = fWCHEatTest(ppwch, L'=') <br>            ? CTDCFilterNode::NT_GE <br>            : CTDCFilterNode::NT_GT; <br>    else if (fWCHEatTest(ppwch, L'&lt;')) <br>        retval-&gt;m_type = fWCHEatTest(ppwch, L'=') <br>                ? CTDCFilterNode::NT_LE <br>                : fWCHEatTest(ppwch, L'&gt;') <br>                    ? CTDCFilterNode::NT_NE <br>                    : CTDCFilterNode::NT_LT; <br>    else <br>    { <br>        *phr = E_FAIL; <br>        goto Cleanup; <br>    } <br> <br>    retval-&gt;m_pRight = FilterParseAtom(ppwch, phr); <br>    if (retval-&gt;m_pRight == NULL) <br>        goto Cleanup; <br> <br>    if (retval-&gt;m_pLeft-&gt;m_iCol &lt;= 0 &amp;&amp; retval-&gt;m_pRight-&gt;m_iCol &lt;= 0) <br>    { <br>        //  At least one of the atoms being compared must be a column <br>        // <br>        //  This condition means we don't have to test for comparison <br>        //  of two wildcard values. <br>        // <br>        *phr = E_FAIL; <br>        goto Cleanup; <br>    } <br> <br>    //  Check type compatibility of atoms <br>    // <br>    if (retval-&gt;m_pRight-&gt;m_vt != retval-&gt;m_vt) <br>    { <br>        CTDCFilterNode  *pSrc = retval-&gt;m_pRight; <br>        CTDCFilterNode  *pTarg= retval-&gt;m_pLeft; <br> <br>        if (retval-&gt;m_pLeft-&gt;m_iCol &gt; 0) <br>        { <br>            if (retval-&gt;m_pRight-&gt;m_iCol &gt; 0) <br>            { <br>                //  Two columns of incompatible type - can't resolve <br>                // <br>                *phr = E_FAIL; <br>                goto Cleanup; <br>            } <br>            pSrc = retval-&gt;m_pLeft; <br>            pTarg = retval-&gt;m_pRight; <br>        } <br>        _ASSERT(pTarg-&gt;m_vt == VT_BSTR); <br>        _ASSERT(pTarg-&gt;m_iCol == 0); <br>        _ASSERT(pSrc-&gt;m_iCol &gt; 0); <br>        CTDCColInfo *pColInfo = GetColInfo(pSrc-&gt;m_iCol); <br>        _ASSERT(pColInfo-&gt;vtType == pSrc-&gt;m_vt); <br>        VARIANT vtmp; <br>        VariantInit(&amp;vtmp); <br>        *phr = VariantFromBSTR(&amp;vtmp, pTarg-&gt;m_value.bstrVal, pColInfo, m_lcid); <br>        if (!SUCCEEDED(*phr)) <br>            goto Cleanup; <br>        VariantClear(&amp;pTarg-&gt;m_value); <br>        pTarg-&gt;m_value = vtmp; <br>        pTarg-&gt;m_vt = pSrc-&gt;m_vt; <br>        retval-&gt;m_vt = pSrc-&gt;m_vt; <br>    } <br> <br>Cleanup: <br>    if (!SUCCEEDED(*phr) &amp;&amp; retval != NULL) <br>    { <br>        delete retval; <br>        retval = NULL; <br>    } <br>    return retval; <br>} <br> <br>CTDCFilterNode *CTDCArr::FilterParseAtom(LPWCH *ppwch, HRESULT *phr) <br>{ <br>    *phr = S_OK; <br>    CTDCFilterNode  *retval = NULL; <br>    int nQuote  = 0; <br>    boolean fDone = FALSE; <br>    LPWCH   pwchDest; <br>    LPWCH   pwchLastStrip; <br> <br>    fWCHEatSpace(ppwch);    //  Eat up white space <br> <br>    WCHAR   *pwchTmpBuf = new WCHAR[wch_len(*ppwch) + 1]; <br>    if (pwchTmpBuf == NULL) <br>    { <br>        *phr = E_OUTOFMEMORY; <br>        goto Cleanup; <br>    } <br> <br>    pwchDest = pwchTmpBuf; <br>    pwchLastStrip = pwchTmpBuf; <br> <br>    while (**ppwch != 0 &amp;&amp; !fDone) <br>        switch (**ppwch) <br>        { <br>        case L'\\': <br>            //  Handle escape characters <br>            // <br>            if ((*pwchDest++ = *++(*ppwch)) != 0) <br>                pwchLastStrip = (*ppwch)++; <br>            break; <br>        case L'"': <br>            //  Quotes <br>            // <br>            pwchLastStrip = (*ppwch)++; <br>            nQuote++; <br>            break; <br>        case L'&gt;': <br>        case L'&lt;': <br>        case L'=': <br>        case L'(': <br>        case L')': <br>        case L'&amp;': <br>        case L'|': <br>            if (fDone = ((nQuote &amp; 1) == 0)) <br>                break; <br>        default: <br>            *pwchDest++ = *(*ppwch)++; <br>        } <br> <br>    //  Strip off trailing white space <br>    // <br>    while (pwchDest &gt; pwchLastStrip &amp;&amp; fWCHIsSpace(pwchDest[-1])) <br>        pwchDest--; <br>    *pwchDest = 0; <br> <br>    if ((pwchDest == pwchTmpBuf &amp;&amp; nQuote == 0) || (nQuote &amp; 1 != 0)) <br>    { <br>        //  Empty string or mismatched quote </code></pre>
<p>
</p>
<pre><code>// <br>        *phr = E_FAIL; <br>        goto Cleanup; <br>    } <br> <br>    retval = new CTDCFilterNode; <br>    if (retval == NULL) <br>    { <br>        *phr = E_OUTOFMEMORY; <br>        goto Cleanup; <br>    } <br> <br>    retval-&gt;m_type = CTDCFilterNode::NT_ATOM; <br>    retval-&gt;m_iCol = nQuote &gt; 0 ? 0 : FindCol(pwchTmpBuf); <br>    if (retval-&gt;m_iCol == 0) <br>    { <br>        retval-&gt;m_vt = VT_BSTR; <br>        retval-&gt;m_value.vt = VT_BSTR; <br>        retval-&gt;m_value.bstrVal = SysAllocString(pwchTmpBuf); <br>        if (retval-&gt;m_value.bstrVal == NULL) <br>        { <br>            *phr = E_OUTOFMEMORY; <br>            goto Cleanup; <br>        } <br>        retval-&gt;m_fWildcard = wch_chr(retval-&gt;m_value.bstrVal, L'*') != NULL; <br>    } <br>    else <br>    { <br>        retval-&gt;m_vt = GetColInfo(retval-&gt;m_iCol)-&gt;vtType; <br>        retval-&gt;m_fWildcard = FALSE; <br>    } <br> <br>Cleanup: <br>    if (pwchTmpBuf != NULL) <br>        delete pwchTmpBuf; <br>    if (!SUCCEEDED(*phr) &amp;&amp; retval != NULL) <br>    { <br>        delete retval; <br>        retval = NULL; <br>    } <br>    return retval; <br>} <br> <br>//+----------------------------------------------------------------------- <br>// <br>//  Method:    EvalDataRow() <br>// <br>//  Synopsis:  Evaluates the given data row # against the filter query <br>//             represented by 'pNode'. <br>// <br>//  Arguments: iRow      The number of the row to evaluate. <br>//             pNode     A filter query to the row against. <br>// <br>//  Returns:   TRUE if the given row satisfies the filter query. <br>//             FALSE otherwise. <br>// <br>//+----------------------------------------------------------------------- <br> <br>boolean CTDCArr::EvalDataRow(LONG iRow, CTDCFilterNode *pNode) <br>{ <br>    boolean retval  = TRUE; <br>    VARIANT *pVar1; <br>    VARIANT *pVar2; <br> <br>    _ASSERT(pNode != NULL); <br>    switch (pNode-&gt;m_type) <br>    { <br>    case CTDCFilterNode::NT_AND: <br>        retval = EvalDataRow(iRow, pNode-&gt;m_pLeft) &amp;&amp; <br>                 EvalDataRow(iRow, pNode-&gt;m_pRight); <br>        break; <br>    case CTDCFilterNode::NT_OR: <br>        retval = EvalDataRow(iRow, pNode-&gt;m_pLeft) || <br>                 EvalDataRow(iRow, pNode-&gt;m_pRight); <br>        break; <br>    case CTDCFilterNode::NT_EQ: <br>    case CTDCFilterNode::NT_NE: <br>    case CTDCFilterNode::NT_LT: <br>    case CTDCFilterNode::NT_GT: <br>    case CTDCFilterNode::NT_LE: <br>    case CTDCFilterNode::NT_GE: <br>        pVar1 = &amp;pNode-&gt;m_pLeft-&gt;m_value; <br>        pVar2 = &amp;pNode-&gt;m_pRight-&gt;m_value; <br> <br>        if (pNode-&gt;m_pLeft-&gt;m_iCol &gt; 0) <br>            pVar1 = GetDataCell(iRow, pNode-&gt;m_pLeft-&gt;m_iCol); <br>        if (pNode-&gt;m_pRight-&gt;m_iCol &gt; 0) <br>            pVar2 = GetDataCell(iRow, pNode-&gt;m_pRight-&gt;m_iCol); <br> <br>        if ((pNode-&gt;m_pLeft-&gt;m_fWildcard || pNode-&gt;m_pRight-&gt;m_fWildcard) &amp;&amp; <br>            (pNode-&gt;m_type == CTDCFilterNode::NT_EQ || <br>             pNode-&gt;m_type == CTDCFilterNode::NT_NE) &amp;&amp; <br>             pVar1-&gt;vt == VT_BSTR &amp;&amp; pVar2-&gt;vt == VT_BSTR) <br>        { <br>            //  Wildcards are only meaningful in comparing strings <br>            //  for equlaity / inequality <br>            // <br>            VARIANT *pText; <br>            VARIANT *pPattern; <br> <br>            if (pNode-&gt;m_pLeft-&gt;m_fWildcard) <br>            { <br>                pPattern = pVar1; <br>                pText = pVar2; <br>            } <br>            else <br>            { <br>                pText = pVar1; <br>                pPattern = pVar2; <br>            } <br> <br>            retval = wch_wildcardMatch(pText-&gt;bstrVal, pPattern-&gt;bstrVal, <br>                                       m_fCaseSensitive) <br>                ? (pNode-&gt;m_type == CTDCFilterNode::NT_EQ) <br>                : (pNode-&gt;m_type == CTDCFilterNode::NT_NE); <br>        } <br>        else <br>        { <br>            int     cmp; <br> <br>            cmp = VariantComp(pVar1, pVar2, pNode-&gt;m_vt, m_fCaseSensitive); <br> <br>            switch (pNode-&gt;m_type) <br>            { <br>            case CTDCFilterNode::NT_LT:    retval = cmp &lt;  0;  break; <br>            case CTDCFilterNode::NT_LE:    retval = cmp &lt;= 0;  break; <br>            case CTDCFilterNode::NT_GT:    retval = cmp &gt;  0;  break; <br>            case CTDCFilterNode::NT_GE:    retval = cmp &gt;= 0;  break; <br>            case CTDCFilterNode::NT_EQ:    retval = cmp == 0;  break; <br>            case CTDCFilterNode::NT_NE:    retval = cmp != 0;  break; <br>            } <br>        } <br>        break; <br> <br>    default: <br>        _ASSERT(FALSE); <br>    } <br>    return retval; <br>} <br> <br>//+----------------------------------------------------------------------- <br>// <br>//  Method:    ApplySortFilterCriteria() <br>// <br>//  Synopsis:  Resets any filter and sorting criterion for the control to <br>//             the values specified.  Initiates sort/filter operations <br>//             if appropriate. <br>// <br>//  Arguments: None. <br>// <br>//  Returns:   S_OK upon success. <br>//             E_OUTOFMEMORY if there was insufficient memory to complete <br>//               the operation. <br>// <br>//+----------------------------------------------------------------------- <br> <br>STDMETHODIMP <br>CTDCArr::ApplySortFilterCriteria() <br>{ <br>    HRESULT hr  = S_OK; <br>    LONG iRow; <br> <br>    if (!m_fSortFilterDisrupted || <br>        m_state == LS_UNINITIALISED || <br>        m_state == LS_LOADING_HEADER_UNAVAILABLE) <br>    { <br>        //  No change, or can't do anything yet. <br>        // <br>        goto Cleanup; <br>    } <br> <br>    //  Discard the old parse trees <br>    // <br>    if (m_pSortList != NULL) <br>        delete m_pSortList; <br>    if (m_pFilterTree != NULL) <br>        delete m_pFilterTree; <br> <br>    m_pSortList = NULL; <br>    m_pFilterTree = NULL; <br> <br>    //  Discard old filtered rows <br>    // <br>    if (m_arrparrFilter.GetSize() &gt; 0) <br>        m_arrparrFilter.DeleteElems(0, m_arrparrFilter.GetSize()); <br> <br>    //  Create an array of filter rows from the data rows <br>    // <br>    hr = m_arrparrFilter.InsertElems(0, m_iDataRows + 1); <br>    if (!SUCCEEDED(hr)) <br>        goto Cleanup; <br>    for (iRow = 0; iRow &lt;= m_iDataRows; iRow++) <br>        m_arrparrFilter[iRow] = m_arrparrCells[iRow]; <br>    m_iFilterRows = CalcFilterRows(); <br> <br>    //  Create the filter parse tree <br>    // <br>    if (m_bstrFilterExpr != NULL) <br>    { <br>        LPWCH pwchQuery = m_bstrFilterExpr; <br> <br>        m_pFilterTree = FilterParseComplex(&amp;pwchQuery, &amp;hr); <br>        if (hr == E_FAIL || (m_pFilterTree != NULL &amp;&amp; *pwchQuery != 0)) <br>        { <br>            //  Parse failed or there were unparsed characters left over. <br>            //  This gets treated as an 'include everything' filter. <br>            // <br>            if (m_pFilterTree != NULL) <br>            { <br>                delete m_pFilterTree; <br>                m_pFilterTree = NULL; <br>            } <br>            hr = S_OK; <br>        } <br>    } <br> <br>    //  Filter the rows <br>    // <br>    if (m_pFilterTree != NULL) <br>    { <br>        LONG    iRowDest    = 1; <br> <br>        for (iRow = 1; iRow &lt;= m_iFilterRows; iRow++) <br>            if (EvalDataRow(iRow, m_pFilterTree)) <br>                m_arrparrFilter[iRowDest++] = m_arrparrFilter[iRow]; <br>        if (iRowDest &lt; iRow) <br>            m_arrparrFilter.DeleteElems(iRowDest, iRow - iRowDest); <br>        m_iFilterRows = CalcFilterRows(); <br>    } <br> <br>    //  Create the sort list <br>    // <br>    hr = CreateSortList(m_bstrSortExpr); <br>    if (!SUCCEEDED(hr)) <br>        goto Cleanup; <br> <br>    //  Sort the filtered rows <br>    // <br>    if (m_pSortList != NULL &amp;&amp; m_iFilterRows &gt; 0) <br>    { <br>        SortElt *pSortArr   = new SortElt[m_iFilterRows + 1]; <br>        if (pSortArr == NULL) <br>        { <br>            hr = E_OUTOFMEMORY; <br>            goto Cleanup; <br>        } <br>        for (iRow = 0; iRow &lt;= m_iFilterRows; iRow++) <br>        { <br>            pSortArr[iRow].pInstance = this; <br>            pSortArr[iRow].iRow = iRow; <br>            pSortArr[iRow].parrRow = m_arrparrFilter[iRow]; <br>        } <br> <br>        qsort((void *)&amp;pSortArr[1], m_iFilterRows, sizeof(pSortArr[0]), CompareSort); <br> <br>        for (iRow = 0; iRow &lt;= m_iFilterRows; iRow++) <br>            m_arrparrFilter[iRow] = pSortArr[iRow].parrRow; <br> <br>        delete pSortArr; <br> <br>    } <br> <br>    m_fSortFilterDisrupted = FALSE; <br> <br>    if (m_state == LS_LOADING_HEADER_AVAILABLE &amp;&amp; m_iDataRows &gt; 0) <br>    { <br>        //  We've just parsed the sort/filter expressions - there <br>        //  was no data to sort/filter, so dont register a change. <br>    } <br>    else <br>    { <br>        //  Notify the event-broker of the changes <br>        // <br>        if (m_pEventBroker != NULL) <br>            hr = m_pEventBroker-&gt;STDDataSetChanged(); <br>    } <br> <br>Cleanup: <br>    return hr; <br>} <br> <br> <br>//+----------------------------------------------------------------------- <br>// <br>//  Method:    SetSortFilterCriteria() <br>// <br>//  Synopsis:  Resets any filter and sorting criterion for the control to <br>//             the values specified.  Initiates sort/filter operations <br>//             if any the changes invalidate existing criteria. <br>// <br>//  Arguments: bstrSortExpr    List of columns for sorting ("" = no sorting) <br>//             bstrFilterExpr  Expression for filtering ("" = no filtering) <br>// <br>//  Returns:   S_OK upon success. <br>//             E_OUTOFMEMORY if there was insufficient memory to complete <br>//               the operation. <br>// <br>//+----------------------------------------------------------------------- <br> <br>STDMETHODIMP <br>CTDCArr::SetSortFilterCriteria(BSTR bstrSortExpr, BSTR bstrFilterExpr, <br>                              boolean fCaseSensitive) <br>{ <br>    HRESULT hr  = S_OK; <br> <br> <br>    //  Check if we need to reparse the sort/filter criteria <br>    // <br> <br>    if (wch_cmp(bstrSortExpr, m_bstrSortExpr) != 0 || <br>        wch_cmp(bstrFilterExpr, m_bstrFilterExpr) != 0 || <br>        fCaseSensitive != m_fCaseSensitive) <br>    { <br>        m_fSortFilterDisrupted = TRUE; <br>    } <br>    m_bstrSortExpr = bstrSortExpr; <br>    m_bstrFilterExpr = bstrFilterExpr; <br>    m_fCaseSensitive = fCaseSensitive; <br> <br>    //  If not loaded, leave it to the load process to apply any changes <br>    // <br>    if (m_state == LS_LOADED) <br>        hr = ApplySortFilterCriteria(); <br>    return hr; <br>} <br> <br>//+----------------------------------------------------------------------- <br>// <br>//  Method:    CTDCCStartDataLoad() <br>// <br>//  Synopsis:  Preparation for a load operation via FieldSink routines below <br>// <br>//  Arguments: fUseHeader      TRUE if the first line of fields should <br>//                               be interpreted as column name/type info. <br>//             bstrSortExpr    Sort expression for ordering rows <br>//             bstrFilterExpr  Filter expression for including/excluding rows <br>//             lcidRead        Locale ID to use for interpreting locale- <br>//                               dependent data formats (date, number etc). <br>//             pBSC            COM object performing the data transfer <br>//             fAppend         Flag indicating whether the data should be <br>//                             appended to any existing data. <br>// <br>//  Returns:   S_OK indicating success. <br>// <br>//+----------------------------------------------------------------------- <br> <br>STDMETHODIMP <br>CTDCArr::StartDataLoad(boolean fUseHeader, BSTR bstrSortExpr, <br>    BSTR bstrFilterExpr, LCID lcidRead, <br>    CComObject&lt;CMyBindStatusCallback&lt;CTDCCtl&gt; &gt; *pBSC, <br>    boolean fAppend, boolean fCaseSensitive) <br>{ <br>    HRESULT hr  = S_OK; <br> <br>    //  If we're asked to append to existing data AND <br>    //     - there isn't any OR <br>    //     - the previous load didn't load a header row <br>    //  then treat it as an initial load. <br>    // <br>    if (fAppend &amp;&amp; m_state == LS_UNINITIALISED) <br>        fAppend = FALSE; <br> <br>    if (fAppend) <br>    { <br>        if (m_state != LS_LOADED || m_iDataRows &lt; 0) <br>        { <br>            hr = E_FAIL; <br>            goto Cleanup; <br>        } <br>        m_state = LS_LOADING_HEADER_AVAILABLE; <br>    } <br>    else <br>    { <br>        if (m_state != LS_UNINITIALISED || <br>            m_iDataRows != -1 || <br>            m_iFilterRows != -1 || <br>            m_iCols != 0) <br>        { <br>            hr = E_FAIL; <br>            goto Cleanup; <br>        } <br>        m_state = LS_LOADING_HEADER_UNAVAILABLE; <br>        m_fSortFilterDisrupted = TRUE; <br>    } <br> <br>    SetSortFilterCriteria(bstrSortExpr, bstrFilterExpr, <br>                         fCaseSensitive); <br> <br>    m_fUseHeader = fUseHeader; <br>    m_fSkipRow = fAppend &amp;&amp; fUseHeader; <br>    _ASSERT(m_iFilterRows == CalcFilterRows()); <br>    _ASSERT(m_iDataRows == CalcDataRows()); <br>    _ASSERT(m_iCols == CalcCols()); <br>    m_iCurrRow = m_iDataRows + 1; <br>    m_iCurrCol = 1; <br>    m_lcidRead = lcidRead; <br>    if (m_pEventBroker != NULL) <br>    hr = m_pEventBroker-&gt;STDLoadStarted(pBSC, fAppend); <br> <br>Cleanup: <br>    return hr; <br>} <br> <br> <br> <br>////////////////////////////////////////////////////////////////////////// <br>// <br>//        CTDCFieldSink Methods - see comments in file TDCParse.h <br>//        --------------------- <br>// <br>////////////////////////////////////////////////////////////////////////// <br> <br>//+----------------------------------------------------------------------- <br>// <br>//  Method:    AddField() <br>// <br>//  Synopsis:  Adds a data cell to the growing cell grid. <br>// <br>//  Arguments: pwch         Wide-char string holding data for the cell <br>//             dwSize       # of significant bytes in 'pwch' <br>// <br>//  Returns:   S_OK indicating success. <br>//             E_OUTOFMEMORY if there was not enough memory to add the cell. <br>// <br>//+----------------------------------------------------------------------- <br> <br>STDMETHODIMP <br>CTDCArr::AddField(LPWCH pwch, DWORD dwSize) <br>{ <br>    _ASSERT(m_state == LS_LOADING_HEADER_UNAVAILABLE || <br>            m_state == LS_LOADING_HEADER_AVAILABLE); <br> <br>    HRESULT hr          = S_OK; <br>    LONG    nCols       = 0; <br>    BSTR    bstr        = NULL; <br> <br>    if (m_fSkipRow) <br>        goto Cleanup; <br>#ifdef TDC_ATL_DEBUG_ADDFIELD <br>    ATLTRACE( _T("CTDCArr::AddField called: %d, %d\n"), m_iCurrRow, m_iCurrCol); <br>#endif <br> <br>    if (m_iCurrRow &gt; m_iDataRows &amp;&amp; m_iCurrCol == 1) <br>    { <br>        TSTDArray&lt;CTDCCell&gt; *pRow; <br> <br>        //  Need to insert a new row <br>        // <br>        _ASSERT(m_iCurrRow == m_iDataRows + 1); <br>        hr = m_arrparrCells.InsertElems(m_iCurrRow, 1); <br>        if (!SUCCEEDED(hr)) <br>            goto Cleanup; <br>        pRow = new TSTDArray&lt;CTDCCell&gt;; <br>        if (pRow == NULL) <br>        { <br>            hr = E_OUTOFMEMORY; <br>            goto Cleanup; <br>        } <br>        m_arrparrCells[m_iCurrRow] = pRow; <br>        if (m_iCurrRow &gt; 0) <br>        { <br>            //  We've already read at least one row, so we know how <br>            //  many columns to insert for this row <br>            // <br>            hr = m_arrparrCells[m_iCurrRow]-&gt;InsertElems(0, m_iCols); <br>            if (!SUCCEEDED(hr)) <br>                goto Cleanup; <br>        } <br>    } <br>    if (m_iCurrRow == 0) <br>    { <br>        //  This is the first row - we don't know how many columns there <br>        //  will be, so just insert a single cell for this new element. <br>        // <br>        _ASSERT(m_iCurrCol == m_iCols + 1); <br>        hr = m_arrparrCells[m_iCurrRow]-&gt;InsertElems(m_iCurrCol - 1, 1); <br>        if (!SUCCEEDED(hr)) <br>            goto Cleanup; <br>        m_iCols++; <br>    } <br> <br>    if (m_iCurrCol &lt;= m_iCols) <br>    { <br>        CTDCCell    *pCell  = GetDataCell(m_iCurrRow, m_iCurrCol); <br> <br>        pCell-&gt;clear(); <br>        pCell-&gt;vt = VT_BSTR; <br> <br>        if (dwSize &lt;= 0) <br>            pCell-&gt;bstrVal = NULL; <br>        else <br>        { <br>            pCell-&gt;bstrVal = SysAllocStringLen(pwch, dwSize); <br>            if (pCell-&gt;bstrVal == NULL) <br>            { <br>                hr = E_OUTOFMEMORY; <br>                goto Cleanup; <br>            } <br>        } <br> <br>        if (m_iCurrRow &gt; 0) <br>        { <br>            CTDCColInfo *pColInfo = GetColInfo(m_iCurrCol); <br> <br>            if (pColInfo-&gt;vtType != VT_BSTR) <br>            { <br>                VARIANT     v; <br>                HRESULT     hr; <br>                 <br>                hr = VariantFromBSTR(&amp;v, pCell-&gt;bstrVal, pColInfo, m_lcidRead); <br>                if (SUCCEEDED(hr)) <br>                { <br>                    hr = VariantCopy(pCell, &amp;v); <br>                    VariantClear(&amp;v); <br>                } <br>                else <br>                { <br>                    //  Leave it as a BSTR <br>                    // <br>                    hr = S_OK; <br>                } <br>            } <br>        } <br>    } <br> <br>    m_iCurrCol++; <br> <br>Cleanup: <br>    return hr; <br>} <br> <br>// InsertionSortHelper - <br>//  returns -1 if the candidate row &lt; current filter array row <br>//           0 if the candidate row = current filter array row <br>//           1 if the candidate row &gt; current filter array row <br> <br>int <br>CTDCArr::InsertionSortHelper(int iRow) <br>{ <br>    CTDCSortCriterion *pCriterion; <br>    int cmp = 0; <br> <br>    for (pCriterion = m_pSortList; pCriterion != NULL; <br>         pCriterion = pCriterion-&gt;m_pNext) <br>    { <br>        CTDCCell    *pCell1 = GetDataCell(m_iDataRows, pCriterion-&gt;m_iSortCol); <br>        CTDCCell    *pCell2 = GetFilterCell(iRow, pCriterion-&gt;m_iSortCol); <br> <br>        cmp = VariantComp(pCell1, pCell2, <br>                          GetColInfo(pCriterion-&gt;m_iSortCol)-&gt;vtType, m_fCaseSensitive); <br> <br>        if (!pCriterion-&gt;m_fSortAscending) <br>            cmp = -cmp; <br> <br>        // if &lt; or &gt;, we don't have to look at any further criterion <br>        if (cmp) <br>            break; <br>    } <br>    return cmp; <br>} <br> <br>//+----------------------------------------------------------------------- <br>// <br>//  Method:    EOLN() <br>// <br>//  Synopsis:  Closes of the current row in the growing cell grid, <br>//               handling column headings if it's the first row. <br>// <br>//  Arguments: None. <br>// <br>//  Returns:   S_OK indicating success. <br>//             E_OUTOFMEMORY if insufficient memory is available for <br>//               a conversion. <br>// <br>//+----------------------------------------------------------------------- <br> <br>STDMETHODIMP <br>CTDCArr::EOLN() <br>{ <br>    ATLTRACE(_T("CTDCArr::EOLN called, row: %d\n"), m_iCurrRow); <br> <br>    HRESULT hr  = S_OK; <br> <br>    _ASSERT(m_state == LS_LOADING_HEADER_UNAVAILABLE || <br>            m_state == LS_LOADING_HEADER_AVAILABLE); <br> <br>    if (m_fSkipRow) <br>    { <br>        //  Appending to existing data; skip over the first (header) line <br>        m_fSkipRow = FALSE; <br>        goto Cleanup; <br>    } <br> <br>    if (m_iCurrRow == 0) <br>    { <br>        //  The first row has been inserted - if m_fUseHeader indicates <br>        //  that the first row contains header information then parse <br>        //  it; otherwise, create some numbered column headings. <br>        // <br>        if (!m_fUseHeader) <br>        { <br>            hr = CreateNumberedColumnHeadings(); <br>            if (!SUCCEEDED(hr)) <br>                goto Cleanup; <br> <br>            //  An extra row has been inserted - update the insertion <br>            //  row index for later insertion of new elements <br>            // <br>            m_iCurrRow++; <br> <br>            //  Initialise each column heading as "Column&lt;column#&gt;" <br>            // <br>            RenumberColumnHeadings(); <br>        } <br> <br>        m_iDataRows++; <br>        m_iFilterRows++; <br>        _ASSERT(m_iDataRows == 0); <br>        _ASSERT(m_iFilterRows == 0); <br> <br>        ParseColumnHeadings(); <br> <br>        m_state = LS_LOADING_HEADER_AVAILABLE; <br> <br>        //  Insert the hedaer row into the list of filtered rows <br>        // <br>        hr = m_arrparrFilter.InsertElems(0, 1); <br>        if (!SUCCEEDED(hr)) <br>            goto Cleanup; <br>        m_arrparrFilter[0] = m_arrparrCells[0]; <br> <br>        //  Notify the event handler that the headers have been loaded <br>        // <br>        if (m_pEventBroker != NULL) <br>        { <br>            hr = m_pEventBroker-&gt;STDLoadedHeader(); <br>            OutputDebugStringX(_T("TDCCtl: header loaded\n")); <br>            if (!SUCCEEDED(hr)) <br>                goto Cleanup; <br>        } <br>    } <br> <br>    if (m_iCurrRow &gt; 0) <br>    { <br>        //  Convert uninitialised cells into their column's type. <br>        // <br>        LONG    iCol; <br> <br>        for (iCol = m_iCurrCol; iCol &lt; m_iCols; iCol++) <br>        { <br>            CTDCCell    *pCell    = GetDataCell(m_iCurrRow, iCol); <br> <br>            //  This uninitialised VARIANT is assumed to be the result <br>            //  of specifying too few cells in a row. <br>            // <br>            _ASSERT(pCell-&gt;vt == VT_EMPTY); <br>            pCell-&gt;vt = VT_BSTR; <br>            pCell-&gt;bstrVal = NULL; <br> <br>            CTDCColInfo *pColInfo = GetColInfo(iCol); <br> <br>            if (pColInfo-&gt;vtType != VT_BSTR) <br>            { <br>                VARIANT     v; <br>                HRESULT     tmp_hr; <br>                 <br>                tmp_hr = VariantFromBSTR(&amp;v, pCell-&gt;bstrVal, pColInfo, m_lcidRead); <br>                if (SUCCEEDED(tmp_hr)) <br>                { <br>                    hr = VariantCopy(pCell, &amp;v); <br>                    VariantClear(&amp;v); <br>                    if (!SUCCEEDED(hr)) <br>                        goto Cleanup; <br>                } <br>                else <br>                { <br>                    //  Leave the cell as a BSTR <br>                    // <br>                } <br>            } <br>        } <br>        m_iDataRows++; <br>    } <br> <br>    m_iCurrCol = 1; <br>    m_iCurrRow++; <br> <br>    if (m_fSortFilterDisrupted) <br>    { <br>        //  This will have the side-effect of incorporating any new data rows <br>        // <br>        hr = ApplySortFilterCriteria(); <br>        if (!SUCCEEDED(hr)) <br>            goto Cleanup; <br>    } <br>    else if (m_iDataRows &gt; 0 &amp;&amp; <br>        (m_pFilterTree == NULL || EvalDataRow(m_iDataRows, m_pFilterTree))) <br>    { <br>        //  The new row passed the filter criteria. <br>        //  Insert the new row into the filtered list <br>        // <br>        LONG iRowInsertedAt = m_iFilterRows + 1; <br> <br>        //  at the correct insertion point according to the current <br>        //  sort criteria, if there is one.  We only need to do the search <br>        //  if this is not the first row, and if the candidate row is less <br>        //  than the last row. <br>        if (m_pSortList != NULL &amp;&amp; m_iFilterRows != 0 <br>            &amp;&amp; InsertionSortHelper(m_iFilterRows) &lt; 0) <br>        { <br>            // not at end, do traditional binary search. <br>            LONG lLow = 1;          // we don't use element zero! <br>            LONG lHigh = m_iFilterRows + 1; <br>            LONG lMid; <br> <br>            while (lLow &lt; lHigh) <br>            { <br>                lMid = (lLow + lHigh) / 2; <br>                // Note that InsertionSortHelper automatically flips the comparison <br>                // if m_fAscending flag is off. <br>                if (InsertionSortHelper(lMid) &lt;= 0) <br>                { <br>                    lHigh = lMid; <br>                } <br>                else <br>                { <br>                    lLow = lMid + 1; <br>                } <br>            } <br>            iRowInsertedAt = lLow; <br>        } <br> <br>        hr = m_arrparrFilter.InsertElems(iRowInsertedAt, 1); <br>        if (!SUCCEEDED(hr)) <br>            goto Cleanup; <br>        m_arrparrFilter[iRowInsertedAt] = m_arrparrCells[m_iDataRows]; <br>        ++m_iFilterRows; <br> <br>        //  Notify event handler of row insertion <br>        // <br>        if (m_pEventBroker != NULL) <br>            hr = m_pEventBroker-&gt;rowsAvailable(iRowInsertedAt, 1); <br> <br>    } <br> <br>Cleanup: <br>    return hr; <br>} <br> <br>//+----------------------------------------------------------------------- <br>// <br>//  Method:    EOF() <br>// <br>//  Synopsis:  Indicates no more cells will be added to the cell grid. <br>//             The column-heading cells are added unless it was indicated <br>//             that cell headings should be taken from the data read. <br>//             The cells in each column are converted to that column's <br>//             specified data type. <br>// <br>//  Arguments: None. <br>// <br>//  Returns:   S_OK indicating success. <br>// <br>//+----------------------------------------------------------------------- <br> <br>STDMETHODIMP <br>CTDCArr::EOF() <br>{ <br>    OutputDebugStringX(_T("CTDArr::EOF() called\n")); <br>    _ASSERT(m_state == LS_LOADING_HEADER_UNAVAILABLE || <br>            m_state == LS_LOADING_HEADER_AVAILABLE); <br>    HRESULT hr = S_OK; <br> <br>    if (m_iCurrCol &gt; 1) <br>        EOLN(); <br>    m_state = LS_LOADED; <br>    m_iFilterRows = CalcFilterRows(); <br>    _ASSERT(m_iDataRows == CalcDataRows()); <br>    _ASSERT(m_iCols == CalcCols()); <br> <br>    if (m_fSortFilterDisrupted) <br>    { <br>        hr = ApplySortFilterCriteria(); <br>        if (!SUCCEEDED(hr)) <br>            goto Cleanup; <br>    } <br>    if (m_pEventBroker != NULL) <br>        hr = m_pEventBroker-&gt;STDLoadCompleted(); <br> <br>Cleanup: <br>    return hr; <br>} <br> <br>// GetEstimatedRows..  <br>// We should really see if URLMon has a means of giving a byte count on the file <br>// we're downloading.  For now though.. <br>STDMETHODIMP <br>CTDCArr::getEstimatedRows(LONG *pcRows) <br>{ <br>    *pcRows = m_iFilterRows; <br>    if (m_state&lt;LS_LOADED) <br>    { <br>        // Return twice number of rows, but be careful not to return 2 * 0. <br>        *pcRows = m_iFilterRows ? m_iFilterRows * 2 : -1; <br>    } <br>    return S_OK; <br>} <br> <br>STDMETHODIMP <br>CTDCArr::isAsync(BOOL *pbAsync) <br>{ <br>//    *pbAsync = m_fAsync; <br>    // The TDC always behaves as if it's Async.  Specifically, we always fire <br>    // TransferComplete, even if we have to buffer the notification until our <br>    // addOLEDBSimplerProviderListener is actually called. <br>    *pbAsync = TRUE; <br>    return S_OK; <br>} <br> <br>STDMETHODIMP <br>CTDCArr::stopTransfer() <br>{ <br>    HRESULT hr = S_OK; <br> <br>    //  Force the load state into UNINITIALISED or LOADED ... <br>    // <br>    switch (m_state) <br>    { <br>    case LS_UNINITIALISED: <br>    case LS_LOADED: <br>        break; <br> <br>    case LS_LOADING_HEADER_UNAVAILABLE: <br>        //  Free any allocated cell memory <br>        // <br>        if (m_arrparrFilter.GetSize() &gt; 0) <br>            m_arrparrFilter.DeleteElems(0, m_arrparrFilter.GetSize()); <br>        if (m_arrparrCells.GetSize() &gt; 0) <br>            m_arrparrCells.DeleteElems(0, m_arrparrCells.GetSize()); <br>        m_state = LS_UNINITIALISED; <br>        m_iFilterRows = CalcFilterRows(); <br>        m_iDataRows = CalcDataRows(); <br>        m_iCols = CalcCols(); <br> <br>        // If we stop the load before the header was parsed, we won't <br>        // have a dataset, but we still need to fire datasetchanged, <br>        // to let our customer know the query failed. <br>        if (m_pEventBroker != NULL) <br>            hr = m_pEventBroker-&gt;STDDataSetChanged(); <br> <br>        // <br>        // fall through to LOADING_HEADER_AVAILABLE! <br>        // <br> <br>    case LS_LOADING_HEADER_AVAILABLE: <br>        m_state = LS_LOADED;            // mark us as finished now <br> <br>        // LoadStopped will abort any transfer in progress, and fire <br>        // transferComplete with the OSPXFER_ABORT flag. <br>        if (m_pEventBroker != NULL) <br>            hr = m_pEventBroker-&gt;STDLoadStopped(); <br>        break; <br>    } <br> <br>    return hr; <br>} <br> <br> <br>////////////////////////////////////////////////////////////////////////// <br>// <br>//        Implementation of IUnknown COM interface. <br>//        ----------------------------------------- <br>// <br>////////////////////////////////////////////////////////////////////////// <br> <br>//+----------------------------------------------------------------------- <br>// <br>//  Method:    QueryInterface() <br>// <br>//  Synopsis:  Implements part of the standard IUnknown COM interface. <br>//               (Returns a pointer to this COM object) <br>// <br>//  Arguments: riid          GUID to recognise <br>//             ppv           Pointer to this COM object [OUT] <br>// <br>//  Returns:   S_OK upon success. <br>//             E_NOINTERFACE if queried for an unrecognised interface. <br>// <br>//+----------------------------------------------------------------------- <br> <br>STDMETHODIMP <br>CTDCArr::QueryInterface (REFIID riid, LPVOID * ppv) <br>{ <br>    HRESULT hr; <br> <br>    _ASSERTE(ppv != NULL); <br> <br>    // This is the non-delegating IUnknown implementation <br>    if (riid == IID_IUnknown || riid == IID_OLEDBSimpleProvider) <br>    { <br>        *ppv = this; <br>        ((LPUNKNOWN)*ppv)-&gt;AddRef(); <br>        hr = S_OK; <br>    } <br>    else <br>    { <br>        *ppv = NULL; <br>        hr = E_NOINTERFACE; <br>    } <br> <br>#ifdef _ATL_DEBUG_QI <br>    AtlDumpIID(riid, _T("CTDCArr"), hr); <br>#endif <br>    return hr; <br>} <br> <br> <br>//+----------------------------------------------------------------------- <br>// <br>//  Method:    AddRef() <br>// <br>//  Synopsis:  Implements part of the standard IUnknown COM interface. <br>//               (Adds a reference to this COM object) <br>// <br>//  Arguments: None <br>// <br>//  Returns:   Number of references to this COM object. <br>// <br>//+----------------------------------------------------------------------- <br> <br>STDMETHODIMP_(ULONG) <br>CTDCArr::AddRef () <br>{ <br>    return ++m_cRef; <br>} <br> <br> <br>//+----------------------------------------------------------------------- <br>// <br>//  Method:    Release() <br>// <br>//  Synopsis:  Implements part of the standard IUnknown COM interface. <br>//               (Removes a reference to this COM object) <br>// <br>//  Arguments: None <br>// <br>//  Returns:   Number of remaining references to this COM object. <br>//             0 if the COM object is no longer referenced. <br>// <br>//+----------------------------------------------------------------------- <br> <br>STDMETHODIMP_(ULONG) <br>CTDCArr::Release () <br>{ <br>    ULONG retval; <br> <br>    m_cRef -= 1; <br>    retval = m_cRef; <br>    if (!m_cRef) <br>    { <br>        m_cRef = 0xffff;    //MM: Use this 'flag' for debug? <br>        delete this; <br>    } <br> <br>    return retval; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
