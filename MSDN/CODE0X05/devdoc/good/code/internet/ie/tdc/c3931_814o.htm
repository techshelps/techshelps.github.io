<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>TDCCTL.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3948"></a><sup></sup>TDCCTL.CPP</h2>
<pre><code>//------------------------------------------------------------------------ <br>// <br>//  Tabular Data Control <br>//  Copyright (C) Microsoft Corporation, 1996, 1997 <br>// <br>//  File:       TDCCtl.cpp <br>// <br>//  Contents:   Implementation of the CTDCCtl ActiveX control. <br>// <br>//------------------------------------------------------------------------ <br> <br>#include "stdafx.h" <br>#include "STD.h" <br>#include "TDCIds.h" <br>#include "TDC.h" <br>#include &lt;MLang.h&gt; <br>#include "Notify.h" <br>#include "TDCParse.h" <br>#include "TDCArr.h" <br>#include "SimpData.h" <br>#include "TDCCtl.h" <br>#include "locale.h" <br>#include "langcode.h" <br> <br>//------------------------------------------------------------------------ <br>// <br>//  Function:   EmptyBSTR() <br>// <br>//  Synopsis:   Indicates whether the given BSTR object represents an <br>//              empty string. <br>// <br>//  Arguments:  bstr     String to test <br>// <br>//  Returns:    TRUE if 'bstr' represents an empty string <br>//              FALSE otherwise. <br>// <br>//------------------------------------------------------------------------ <br> <br>inline boolean EmptyBSTR(BSTR bstr) <br>{ <br>    return bstr == NULL || bstr[0] == 0; <br>} <br> <br>void <br>ClearInterfaceFn(IUnknown ** ppUnk) <br>{ <br>    IUnknown * pUnk; <br> <br>    pUnk = *ppUnk; <br>    *ppUnk = NULL; <br>    if (pUnk) <br>        pUnk-&gt;Release(); <br>} <br> <br>//------------------------------------------------------------------------ <br>// <br>//  Method:     CTDCCtl() <br>// <br>//  Synopsis:   Class constructor <br>// <br>//  Arguments:  None <br>// <br>//------------------------------------------------------------------------ <br> <br>CTDCCtl::CTDCCtl() <br>{ <br>    m_cbstrFieldDelim = DEFAULT_FIELD_DELIM; <br>    m_cbstrRowDelim = DEFAULT_ROW_DELIM; <br>    m_cbstrQuoteChar = DEFAULT_QUOTE_CHAR; <br>    m_fUseHeader = VARIANT_FALSE; <br>    m_fSortAscending = VARIANT_TRUE; <br>    m_fAppendData = VARIANT_FALSE; <br>    m_pSTD = NULL; <br>    m_pArr = NULL; <br>    m_pUnify = NULL; <br>    m_pEventBroker = new CEventBroker(this); <br>    m_pDataSourceListener = NULL; <br>// ;begin_internal <br>    m_pDATASRCListener = NULL; <br>// ;end_internal <br>    m_pBSC = NULL; <br>    m_enumFilterCriterion = (OSPCOMP) 0; <br>    m_fDataURLChanged = FALSE; <br>    m_lTimer = 0; <br>    m_fCaseSensitive = VARIANT_TRUE; <br>    m_hrDownloadStatus = S_OK; <br>    m_fInReset = FALSE; <br> <br>    //  Create an MLANG object <br>    // <br>    m_nCodePage = 0;                    // use default from host <br>    { <br>        HRESULT hr; <br> <br>        m_pML = NULL; <br>        hr = CoCreateInstance(CLSID_CMultiLanguage, NULL, <br>                              CLSCTX_INPROC_SERVER, IID_IMultiLanguage, <br>                              (void**) &amp;m_pML); <br>        // Don't set the default Charset here.  Leave m_nCodepage set <br>        // to 0 to indicate default charset.  Later we'll try to query <br>        // our host's default charset, and failing that we'll use CP_ACP. <br>        _ASSERTE(SUCCEEDED(hr) &amp;&amp; m_pML != NULL);         <br>    } <br> <br>    m_lcidRead = 0x0000;                // use default from host <br>} <br> <br> <br>//------------------------------------------------------------------------ <br>// <br>//  Method:     ~CTDCCtl() <br>// <br>//  Synopsis:   Class destructor <br>// <br>//------------------------------------------------------------------------ <br> <br>CTDCCtl::~CTDCCtl() <br>{ <br>    ULONG cRef = _ThreadModel::Decrement(&amp;m_dwRef); <br> <br>    ClearInterface(&amp;m_pSTD); <br> <br>    if (cRef ==0) <br>    { <br>        TimerOff(); <br>        ReleaseTDCArr(FALSE); <br> <br>        if (m_pEventBroker) <br>        { <br>            m_pEventBroker-&gt;Release(); <br>            m_pEventBroker = NULL; <br>        } <br>        ClearInterface(&amp;m_pDataSourceListener); <br>// ;begin_internal <br>        ClearInterface(&amp;m_pDATASRCListener); <br>// ;end_internal <br>        ClearInterface(&amp;m_pML); <br>    } <br>} <br> <br>//------------------------------------------------------------------------ <br>// <br>//  These set/get methods implement the control's properties, <br>//  copying values to and from class members.  They perform no <br>//  other processing apart from argument validation. <br>// <br>//------------------------------------------------------------------------ <br> <br>STDMETHODIMP CTDCCtl::get_ReadyState(LONG *plReadyState) <br>{ <br>    HRESULT hr; <br> <br>    if (m_pEventBroker == NULL) <br>    { <br>        // We must provide a ReadyState whether we want to or not, or our <br>        // host can never go COMPLETE. <br>        *plReadyState = READYSTATE_COMPLETE; <br>        hr = S_OK; <br>    } <br>    else <br>        hr = m_pEventBroker-&gt;GetReadyState(plReadyState); <br>    return hr; <br>} <br> <br>STDMETHODIMP CTDCCtl::put_ReadyState(LONG lReadyState) <br>{ <br>    // We don't allow setting of Ready State, but take advantage of a little <br>    // kludge here to update our container's impression of our readystate <br>    FireOnChanged(DISPID_READYSTATE);     <br>    return S_OK; <br>} <br> <br>STDMETHODIMP CTDCCtl::get_FieldDelim(BSTR* pbstrFieldDelim) <br>{ <br>    *pbstrFieldDelim = m_cbstrFieldDelim.Copy(); <br>    return S_OK; <br>} <br> <br>STDMETHODIMP CTDCCtl::put_FieldDelim(BSTR bstrFieldDelim) <br>{ <br>    HRESULT hr = S_OK; <br> <br>    if (bstrFieldDelim == NULL || bstrFieldDelim[0] == 0) <br>    { <br>        m_cbstrFieldDelim = DEFAULT_FIELD_DELIM; <br>        if (m_cbstrFieldDelim == NULL) <br>            hr = E_OUTOFMEMORY; <br>    } <br>    else <br>        m_cbstrFieldDelim = bstrFieldDelim; <br>    return S_OK; <br>} <br> <br>STDMETHODIMP CTDCCtl::get_RowDelim(BSTR* pbstrRowDelim) <br>{ <br>    *pbstrRowDelim = m_cbstrRowDelim.Copy(); <br>    return S_OK; <br>} <br> <br>STDMETHODIMP CTDCCtl::put_RowDelim(BSTR bstrRowDelim) <br>{ <br>    HRESULT hr = S_OK; <br> <br>    if (bstrRowDelim == NULL || bstrRowDelim[0] == 0) <br>    { <br>        m_cbstrRowDelim = DEFAULT_ROW_DELIM; <br>        if (m_cbstrRowDelim == NULL) <br>            hr = E_OUTOFMEMORY; <br>    } <br>    else <br>        m_cbstrRowDelim = bstrRowDelim; <br>    return hr; <br>} <br> <br>STDMETHODIMP CTDCCtl::get_TextQualifier(BSTR* pbstrTextQualifier) <br>{ <br>    *pbstrTextQualifier = m_cbstrQuoteChar.Copy(); <br>    return S_OK; <br>} <br> <br>STDMETHODIMP CTDCCtl::put_TextQualifier(BSTR bstrTextQualifier) <br>{ <br>    m_cbstrQuoteChar = bstrTextQualifier; <br>    return S_OK; <br>} <br> <br>STDMETHODIMP CTDCCtl::get_EscapeChar(BSTR* pbstrEscapeChar) <br>{ <br>    *pbstrEscapeChar = m_cbstrEscapeChar.Copy(); <br>    return S_OK; <br>} <br> <br>STDMETHODIMP CTDCCtl::put_EscapeChar(BSTR bstrEscapeChar) <br>{ <br>    m_cbstrEscapeChar = bstrEscapeChar; <br>    return S_OK; <br>} <br> <br>STDMETHODIMP CTDCCtl::get_UseHeader(VARIANT_BOOL* pfUseHeader) <br>{ <br>    *pfUseHeader = m_fUseHeader; <br>    return S_OK; <br>} <br> <br>STDMETHODIMP CTDCCtl::put_UseHeader(VARIANT_BOOL fUseHeader) <br>{ <br>    m_fUseHeader = fUseHeader; <br>    return S_OK; <br>} <br> <br>STDMETHODIMP CTDCCtl::get_SortColumn(BSTR* pbstrSortColumn) <br>{ <br>    *pbstrSortColumn = m_cbstrSortColumn.Copy(); <br>    return S_OK; <br>} <br> <br>STDMETHODIMP CTDCCtl::put_SortColumn(BSTR bstrSortColumn) <br>{ <br>    m_cbstrSortColumn = bstrSortColumn; <br>    return S_OK; <br>} <br> <br>STDMETHODIMP CTDCCtl::get_SortAscending(VARIANT_BOOL* pfSortAscending) <br>{ <br>    *pfSortAscending = m_fSortAscending; <br>    return S_OK; <br>} <br> <br>STDMETHODIMP CTDCCtl::put_SortAscending(VARIANT_BOOL fSortAscending) <br>{ <br>    m_fSortAscending = fSortAscending; <br>    return S_OK; <br>} <br> <br>STDMETHODIMP CTDCCtl::get_FilterValue(BSTR* pbstrFilterValue) <br>{ <br>    *pbstrFilterValue = m_cbstrFilterValue.Copy(); <br>    return S_OK; <br>} <br> <br>STDMETHODIMP CTDCCtl::put_FilterValue(BSTR bstrFilterValue) <br>{ <br>    m_cbstrFilterValue = bstrFilterValue; <br>    return S_OK; <br>} <br> <br>STDMETHODIMP CTDCCtl::get_FilterCriterion(BSTR* pbstrFilterCriterion) <br>{ <br>    HRESULT hr; <br>    WCHAR   *pwchCriterion; <br> <br>    switch (m_enumFilterCriterion) <br>    { <br>    case OSPCOMP_EQ:    pwchCriterion = L"=";   break; <br>    case OSPCOMP_LT:    pwchCriterion = L"&lt;";   break; <br>    case OSPCOMP_LE:    pwchCriterion = L"&lt;=";  break; <br>    case OSPCOMP_GE:    pwchCriterion = L"&gt;=";  break; <br>    case OSPCOMP_GT:    pwchCriterion = L"&gt;";   break; <br>    case OSPCOMP_NE:    pwchCriterion = L"&lt;&gt;";  break; <br>    default:            pwchCriterion = L"??";  break; <br>    } <br>    *pbstrFilterCriterion = SysAllocString(pwchCriterion); <br>    hr = (*pbstrFilterCriterion == NULL) ? E_OUTOFMEMORY : S_OK; <br> <br>    return hr; <br>} <br> <br>STDMETHODIMP CTDCCtl::put_FilterCriterion(BSTR bstrFilterCriterion) <br>{ <br>    m_enumFilterCriterion = (OSPCOMP) 0; <br>    if (bstrFilterCriterion != NULL) <br>    { <br>        switch (bstrFilterCriterion[0]) <br>        { <br>        case L'&lt;': <br>            if (bstrFilterCriterion[1] == 0) <br>                m_enumFilterCriterion = OSPCOMP_LT; <br>            else if (bstrFilterCriterion[2] == 0) <br>            { <br>                if (bstrFilterCriterion[1] == L'&gt;') <br>                    m_enumFilterCriterion = OSPCOMP_NE; <br>                else if (bstrFilterCriterion[1] == L'=') <br>                    m_enumFilterCriterion = OSPCOMP_LE; <br>            } <br>            break; <br>        case L'&gt;': <br>            if (bstrFilterCriterion[1] == 0) <br>                m_enumFilterCriterion = OSPCOMP_GT; <br>            else if (bstrFilterCriterion[1] == L'=' &amp;&amp; bstrFilterCriterion[2] == 0) <br>                m_enumFilterCriterion = OSPCOMP_GE; <br>            break; <br>        case L'=': <br>            if (bstrFilterCriterion[1] == 0) <br>                m_enumFilterCriterion = OSPCOMP_EQ; <br>            break; <br>        } <br>    } <br> <br>    //  Return SUCCESS, even on an invalid value; otherwise the <br>    //  frameworks using the control will panic and abandon all hope. <br>    // <br>    return S_OK; <br>} <br> <br>STDMETHODIMP CTDCCtl::get_FilterColumn(BSTR* pbstrFilterColumn) <br>{ <br>    *pbstrFilterColumn = m_cbstrFilterColumn.Copy(); <br>    return S_OK; <br>} <br> <br>STDMETHODIMP CTDCCtl::put_FilterColumn(BSTR bstrFilterColumn) <br>{ <br>    m_cbstrFilterColumn = bstrFilterColumn; <br>    return S_OK; <br>} <br> <br>STDMETHODIMP CTDCCtl::get_CharSet(BSTR* pbstrCharSet) <br>{ <br>    HRESULT hr = E_FAIL; <br> <br>    if (m_pML != NULL) <br>    { <br>        MIMECPINFO  info; <br> <br>        hr = m_pML-&gt;GetCodePageInfo(m_nCodePage, &amp;info); <br>        if (SUCCEEDED(hr)) <br>        { <br>            *pbstrCharSet = SysAllocString(info.wszWebCharset); <br>            if (*pbstrCharSet == NULL) <br>                hr = E_OUTOFMEMORY; <br>        } <br>    } <br>    return S_OK; <br>} <br> <br>STDMETHODIMP CTDCCtl::put_CharSet(BSTR bstrCharSet) <br>{ <br>    HRESULT hr = E_FAIL; <br> <br>    if (m_pML != NULL) <br>    { <br>        MIMECSETINFO    info; <br> <br>        hr = m_pML-&gt;GetCharsetInfo(bstrCharSet, &amp;info); <br>        if (SUCCEEDED(hr)) <br>        { <br>            m_nCodePage = info.uiCodePage; <br>            if (m_nCodePage == 0) <br>                m_nCodePage = info.uiInternetEncoding; <br>        } <br>    } <br>    return hr; <br>} <br> <br>STDMETHODIMP CTDCCtl::get_Language(BSTR* pbstrLanguage) <br>{ <br>    if (m_pArr) <br>    { <br>        return m_pArr-&gt;getLocale(pbstrLanguage); <br>    } <br>     <br>    *pbstrLanguage = m_cbstrLanguage.Copy(); <br>    return S_OK; <br>} <br> <br>STDMETHODIMP CTDCCtl::put_Language_(LPWCH pwchLanguage) <br>{ <br>    HRESULT hr  = S_OK; <br>    LCID    lcid; <br> <br>    hr = m_pML-&gt;GetLcidFromRfc1766(&amp;lcid, pwchLanguage); <br>    if (SUCCEEDED(hr)) <br>    { <br>        m_cbstrLanguage = pwchLanguage; <br>        m_lcidRead = lcid; <br>    } <br>    return hr; <br>} <br> <br>STDMETHODIMP CTDCCtl::put_Language(BSTR bstrLanguage) <br>{ <br>    return put_Language_(bstrLanguage); <br>} <br> <br>STDMETHODIMP CTDCCtl::get_DataURL(BSTR* pbstrDataURL) <br>{ <br>    *pbstrDataURL = m_cbstrDataURL.Copy(); <br>    return S_OK; <br>} <br> <br>STDMETHODIMP CTDCCtl::put_DataURL(BSTR bstrDataURL) <br>{ <br>    HRESULT hr = S_OK; <br> <br>    m_cbstrDataURL = bstrDataURL; <br>    m_fDataURLChanged = TRUE; <br>    return hr; <br>} <br> <br>// ;begin_internal <br>#ifdef NEVER <br>STDMETHODIMP CTDCCtl::get_RefreshInterval(LONG* plTimer) <br>{ <br>    *plTimer = m_lTimer; <br>    return S_OK; <br>} <br> <br>STDMETHODIMP CTDCCtl::put_RefreshInterval(LONG lTimer) <br>{ <br>    m_lTimer = lTimer; <br>    if (m_lTimer &gt; 0) <br>        TimerOn(m_lTimer * 1000); <br>    else <br>        TimerOff(); <br>    return S_OK; <br>} <br>#endif <br>// ;end_internal <br> <br>STDMETHODIMP CTDCCtl::get_Filter(BSTR* pbstrFilterExpr) <br>{ <br>    *pbstrFilterExpr = m_cbstrFilterExpr.Copy(); <br>    return S_OK; <br>} <br> <br>STDMETHODIMP CTDCCtl::put_Filter(BSTR bstrFilterExpr) <br>{ <br>    m_cbstrFilterExpr = bstrFilterExpr; <br>    return S_OK; <br>} <br> <br>STDMETHODIMP CTDCCtl::get_Sort(BSTR* pbstrSortExpr) <br>{ <br>    *pbstrSortExpr = m_cbstrSortExpr.Copy(); <br>    return S_OK; <br>} <br> <br>STDMETHODIMP CTDCCtl::put_Sort(BSTR bstrSortExpr) <br>{ <br>    m_cbstrSortExpr = bstrSortExpr; <br>    return S_OK; <br>} <br> <br>STDMETHODIMP CTDCCtl::get_AppendData(VARIANT_BOOL* pfAppendData) <br>{ <br>    *pfAppendData = m_fAppendData; <br>    return S_OK; <br>} <br> <br>STDMETHODIMP CTDCCtl::put_AppendData(VARIANT_BOOL fAppendData) <br>{ <br>    m_fAppendData = fAppendData; <br>    return S_OK; <br>} <br> <br>STDMETHODIMP CTDCCtl::get_CaseSensitive(VARIANT_BOOL* pfCaseSensitive) <br>{ <br>    *pfCaseSensitive = m_fCaseSensitive; <br>    return S_OK; <br>} <br> <br>STDMETHODIMP CTDCCtl::put_CaseSensitive(VARIANT_BOOL fCaseSensitive) <br>{ <br>    m_fCaseSensitive = fCaseSensitive; <br>    return S_OK; <br>} <br> <br>STDMETHODIMP CTDCCtl::get_OSP(OLEDBSimpleProviderX ** ppISTD) <br>{ <br>    // Return an OSP if we have one, but don't create one on demand! <br>    // (Otherwise property bag load stuff will cause us to create an <br>    // OSP prematurely). <br>    *ppISTD = NULL; <br>    if (m_pSTD) <br>    { <br>        *ppISTD = (OLEDBSimpleProviderX *)m_pSTD; <br>    } <br>    return S_OK; <br>} <br> <br> <br>//------------------------------------------------------------------------ <br>// <br>//  Method:    UpdateReadyState <br>// <br>//  Synopsis:  Vectors to the event brokers ReadyState, if there is one. <br>// ;begin_internal <br>//             Note, we have to be able to set our readystate and fire change <br>//             events on it, whether or not creation of the broker succeeded, <br>//             or we prevent our host container from reaching <br>//             READYSTATE_COMPLETE, which is not acceptable.  We therefore <br>//             have to duplicate some of the broker's work here.  This makes <br>//             me wonder whether the broker architecture was a good idea. <br>// ;end_internal <br>// <br>//  Arguments: None. <br>// <br>//  Returns:   S_OK upon success. <br>//             Error codes as per Reset() upon error. <br>// <br>//------------------------------------------------------------------------ <br>void <br>CTDCCtl::UpdateReadyState(LONG lReadyState) <br>{ <br>    if (m_pEventBroker) <br>        m_pEventBroker-&gt;UpdateReadyState(lReadyState); <br>    else <br>    { <br>        // We have no broker, but our host is still waiting for us to <br>        // go READYSTATE_COMPLETE.  We fire the OnChange here noting that <br>        // get_ReadyState with no broker will return COMPLETE. <br>        FireOnChanged(DISPID_READYSTATE); <br>        FireOnReadyStateChanged(); <br>    } <br>} <br> <br>//------------------------------------------------------------------------ <br>// <br>//  Method:    _OnTimer() <br>// <br>//  Synopsis:  Handles an internal timer event by refreshing the control. <br>// <br>//  Arguments: None. <br>// <br>//  Returns:   S_OK upon success. <br>//             Error codes as per Reset() upon error. <br>// <br>//------------------------------------------------------------------------ <br> <br>STDMETHODIMP CTDCCtl::_OnTimer() <br>{ <br>    HRESULT hr = S_OK; <br> <br>    if (m_pArr != NULL &amp;&amp; m_pArr-&gt;GetLoadState() == CTDCArr::LS_LOADED) <br>    { <br>        m_fDataURLChanged = TRUE; <br>        hr = Reset(); <br>    } <br> <br>    return hr; <br>} <br> <br> <br>//------------------------------------------------------------------------ <br>// <br>//  Method:    msDataSourceObject() <br>// <br>//  Synopsis:  Yields an ISimpleTabularData interface for this control. <br>//             If this is the first call, a load operation is initiated <br>//             reading data from the control's specified DataURL property. <br>//             An STD object is created to point to the control's embedded <br>//             TDCArr object. <br>// <br>//  Arguments: qualifier     Ignored - must be an empty BSTR. <br>//             ppUnk         Pointer to returned interface  [OUT] <br>// <br>//  Returns:   S_OK upon success. <br>//             E_INVALIDARG if 'qualifier' isn't an empty BSTR. <br>//             E_OUTOFMEMORY if non enough memory could be allocated to <br>//               complete the construction of the interface. <br>// <br>//------------------------------------------------------------------------ <br> <br>STDMETHODIMP <br>CTDCCtl::msDataSourceObject(BSTR qualifier, IUnknown **ppUnk) <br>{ <br>    HRESULT hr  = S_OK; <br> <br>    *ppUnk = NULL;                      // NULL in case of failure <br> <br>    if (!EmptyBSTR(qualifier)) <br>    { <br>        hr = E_INVALIDARG; <br>        goto error; <br>    } <br> <br>    // Was there a previous attempt to load this page that failed? <br>    // (Probably due to security or file not found or something). <br>    if (m_hrDownloadStatus) <br>    { <br>        hr = m_hrDownloadStatus; <br>        goto error; <br>    } <br> <br>    if (m_pArr == NULL) <br>    { <br>        // We don't have a valid TDC to give back, probably have to try <br>        // downloading one. <br>        UpdateReadyState(READYSTATE_LOADED); <br>        hr = CreateTDCArr(FALSE); <br>        if (hr) <br>            goto error; <br>    } <br> <br>    _ASSERTE(m_pArr != NULL); <br> <br>    if (m_pSTD == NULL) <br>    { <br>        OutputDebugStringX(_T("Creating an STD COM object\n")); <br> <br>        // fetch ISimpleTabularData interface pointer <br>        m_pArr-&gt;QueryInterface(IID_OLEDBSimpleProvider, (void**)&amp;m_pSTD); <br>        _ASSERTE(m_pSTD != NULL); <br>    } <br> <br>    // Return the STD if we have one, otherwise it stays NULL <br>    if (m_pSTD &amp;&amp; m_pArr-&gt;GetLoadState() &gt;= CTDCArr::LS_LOADING_HEADER_AVAILABLE) <br>    { <br>        *ppUnk = (OLEDBSimpleProviderX *) m_pSTD; <br>        m_pSTD-&gt;AddRef();           // We must AddRef the STD we return! <br>    } <br> <br>cleanup: <br>    return hr; <br> <br>error: <br>    UpdateReadyState(READYSTATE_COMPLETE); <br>    goto cleanup; <br>} <br> <br> <br>// Override IPersistPropertyBagImpl::Load <br>STDMETHODIMP <br>CTDCCtl::Load(LPPROPERTYBAG pPropBag, LPERRORLOG pErrorLog) <br>{ <br>    HRESULT hr; <br>    IUnknown *pSTD; <br>     <br>    // Do normal load <br>    // IPersistPropertyBagImpl&lt;CTDCCtl&gt; <br>    hr = IPersistPropertyBagImpl&lt;CTDCCtl&gt;::Load(pPropBag, pErrorLog); <br>     <br>    // and then start download, if we can <br>    (void)msDataSourceObject(NULL, &amp;pSTD); <br> <br>    // If we actually got an STD, we should release it.  This won't really <br>    // make it go away, since we still have the ref from the QI.  This is <br>    // a bit of a kludge that we should clean up later. <br>    ClearInterface(&amp;pSTD); <br> <br>    return hr; <br>} <br> <br> <br>//------------------------------------------------------------------------ <br>// <br>//  Method:    CreateTDCArr() <br>// <br>//  Synopsis:  Creates the control's embedded TDCArr object. <br>//             Initiates a data download from the DataURL property. <br>// <br>//  Arguments: fAppend         Flag indicating whether data should be <br>//                             appended to an existing TDC object. <br>// <br>//  Returns:   S_OK upon success. <br>//             E_OUTOFMEMORY if non enough memory could be allocated to <br>//               complete the construction of the TDCArr object. <br>// <br>//------------------------------------------------------------------------ <br> <br>STDMETHODIMP <br>CTDCCtl::CreateTDCArr(boolean fAppend) <br>{ <br>    HRESULT hr  = S_OK; <br> <br>    if (m_pEventBroker == NULL) <br>    { <br>        hr = E_FAIL; <br>        goto Error; <br>    } <br> <br>    // Iff we're appending is m_pArr allowed to be non-null here. <br>    _ASSERT ((m_pArr != NULL) == fAppend); <br> <br>    if (m_pArr == NULL) <br>    { <br>        m_pArr = new CTDCArr(); <br>        if (m_pArr == NULL) <br>        { <br>            hr = E_OUTOFMEMORY; <br>            goto Error; <br>        } <br> <br>        hr = m_pArr-&gt;Init(m_pEventBroker, m_pML); <br>        if (FAILED(hr)) <br>            goto Error; <br>    } <br> <br>    hr = InitiateDataLoad(fAppend); <br>    if (hr) <br>        goto Error; <br> <br>    // We decide something is not async if it finished loading during <br>    // the InitiateDataLoad call. <br>    m_pArr-&gt;SetIsAsync(!(m_pArr-&gt;GetLoadState()==CTDCArr::LS_LOADED)); <br> <br>Cleanup: <br>    return hr; <br> <br>Error: <br>    if (!fAppend) <br>    { <br>        ClearInterface(&amp;m_pArr); <br>    } <br>    goto Cleanup; <br>} <br> <br>//------------------------------------------------------------------------ <br>// <br>//  Method:    ReleaseTDCArr() <br>// <br>//  Synopsis:  Releases the control's embedded TDCArr object. <br>//             Releases the control's CTDCUnify and CTDCTokenise objects. <br>//             Releases the old event broker and re-creates it if replacing. <br>// <br>//  Arguments: fReplacingTDCArr   Flag indicating whether a new TDCArr object <br>//                                will be created. <br>// <br>//  Returns:   S_OK upon success. <br>//             Error code upon failure. <br>//             E_OUTOFMEMORY if non enough memory could be allocated to <br>//               complete the construction of the new CEventBroker object. <br>// <br>//------------------------------------------------------------------------ <br> <br>STDMETHODIMP <br>CTDCCtl::ReleaseTDCArr(boolean fReplacingTDCArr) <br>{ <br>    HRESULT hr = S_OK; <br> <br>    TerminateDataLoad(); <br> <br>    //  Release the reference to the current TDCArr object <br>    // <br>    if (m_pArr != NULL) <br>    { <br>        m_pArr-&gt;Release(); <br>        m_pArr = NULL; <br> <br>        // Since we've shut down the CTDCArr object, we should release <br>        // it's OLEDBSimplerProviderListener sink. <br>        if (m_pEventBroker) <br>        { <br>            m_pEventBroker-&gt;SetSTDEvents(NULL); <br>        } <br> <br>        if (fReplacingTDCArr) <br>        { <br>            // Release our previous Event Broker. <br>            if (m_pEventBroker) <br>            { <br>                m_pEventBroker-&gt;Release(); <br>                m_pEventBroker = NULL; <br>            } <br> <br>            //  Create a new event broker. <br>            m_pEventBroker = new CEventBroker(this); <br>            if (m_pEventBroker == NULL) <br>            { <br>                hr = E_OUTOFMEMORY; <br>                goto Cleanup; <br>            } <br>             <br>            // Set the DataSourceListener for the new event broker. <br>            m_pEventBroker-&gt;SetDataSourceListener(m_pDataSourceListener); <br> <br>// ;begin_internal <br>            m_pEventBroker-&gt;SetDATASRCListener(m_pDATASRCListener); <br>// ;end_internal <br>        } <br>    } <br> <br>Cleanup: <br>    return hr; <br>} <br> <br>const IID IID_IDATASRCListener = {0x3050f380,0x98b5,0x11cf,{0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b}}; <br>const IID IID_DataSourceListener = {0x7c0ffab2,0xcd84,0x11d0,{0x94,0x9a,0x00,0xa0,0xc9,0x11,0x10,0xed}}; <br> <br>//------------------------------------------------------------------------ <br>// <br>//  Method:    addDataSourceListener() <br>// <br>//  Synopsis:  Sets the COM object which should receive notification <br>//             events. <br>// <br>//  Arguments: pEvent        Pointer to COM object to receive notification <br>//                           events, or NULL if no notifications to be sent. <br>// <br>//  Returns:   S_OK upon success. <br>//             Error code upon failure. <br>// <br>//------------------------------------------------------------------------ <br> <br>STDMETHODIMP <br>CTDCCtl::addDataSourceListener(IUnknown *pListener) <br>{ <br> <br>    if (m_pEventBroker != NULL) <br>    { <br>        HRESULT hr = S_OK;         <br>        IUnknown * pDatasrcListener; <br> <br>        // Make sure this is the interface we expect <br>        hr = pListener-&gt;QueryInterface(IID_DataSourceListener, <br>                                       (void **)&amp;pDatasrcListener); <br>        if (SUCCEEDED(hr)) <br>        { <br>            m_pEventBroker-&gt; <br>                    SetDataSourceListener((DataSourceListener *)pDatasrcListener); <br> <br>            // Clear any previous <br>            ClearInterface (&amp;m_pDataSourceListener); <br>            // and remember the new. <br>            m_pDataSourceListener = (DataSourceListener *)pDatasrcListener; <br>        } <br>// ;begin_internal <br>        else <br>        { <br>            // The definition of this interface was changed from IDATASRCListener to <br>            // DataSourceListener.  To make sure we don't cause crashes, we QI to <br>            // determine which one we were handed. <br>            hr = pListener-&gt;QueryInterface(IID_IDATASRCListener, <br>                                           (void **)&amp;pDatasrcListener); <br>            if (SUCCEEDED(hr)) <br>            { <br>                m_pEventBroker-&gt; <br>                        SetDATASRCListener((DATASRCListener *) pDatasrcListener); <br> <br>                // Clear any previous <br>                ClearInterface (&amp;m_pDATASRCListener); <br>                // and remember the new. <br>                m_pDATASRCListener = (DATASRCListener *)pDatasrcListener; <br>            } <br>        } <br>// ;end_internal <br>        return hr; <br>    } <br>    else <br>        return E_FAIL; <br>} <br> <br>//------------------------------------------------------------------------ <br>// <br>//  Method:    Reset() <br>// <br>//  Synopsis:  Reset the control's filter/sort criteria. <br>// <br>//  Arguments: None. <br>// <br>//  Returns:   S_OK upon success. <br>//             Error code upon failure. <br>// <br>//------------------------------------------------------------------------ <br> <br>STDMETHODIMP CTDCCtl::Reset() <br>{ <br>    HRESULT hr  = S_OK; <br> <br>    // The next query to msDataSourceObject should get a new STD <br>    ClearInterface(&amp;m_pSTD); <br> <br>    // Infinite recursive calls to Reset can occur if script code calls reset <br>    // from within the datasetchanged event.  This isn't a good idea. <br>    if (m_fInReset) <br>    { <br>        hr = E_FAIL; <br>        goto Cleanup; <br>    } <br> <br>    m_fInReset = TRUE; <br> <br>    // Clear any previous error <br>    m_hrDownloadStatus = S_OK; <br> <br>    if (m_fDataURLChanged) <br>    { <br>        if (!m_fAppendData) <br>        { <br>            // Release previous TDC array with "replacing" flag. <br>            hr = ReleaseTDCArr(TRUE); <br>            if (!SUCCEEDED(hr))         // possible memory failure <br>                goto Cleanup; <br>        } <br> <br>        // Read the new data into a TDC arry, appending if specified. <br>        hr = CreateTDCArr((BOOL)m_fAppendData); <br>    } <br>    else if (m_pArr != NULL) <br>    { <br>        // Re-apply the sort and filter criteria <br>        hr = m_pArr-&gt;SetSortFilterCriteria(bstrConstructSortExpr(), <br>                                           bstrConstructFilterExpr(), <br>                                           m_fCaseSensitive ? 1 : 0); <br>    } <br> <br>    m_fInReset = FALSE; <br> <br>Cleanup: <br>    return hr; <br>} <br> <br> <br>//------------------------------------------------------------------------ <br>// <br>//  Method:    bstrConstructSortExpr() <br>// <br>//  Synopsis:  Constructs a sort expression from the Sort property or <br>//             (for backward compatibility) from the SortColumn/SortAscending <br>//             properties. <br>// <br>//             This method only exists to isolate backward-compatibility <br>//             with the old-fashioned sort properties. <br>// <br>//  Arguments: None. <br>// <br>//  Returns:   The constructed sort expression. <br>// <br>//  NB!  It is the caller's responsibility to free the string returned. <br>// <br>//------------------------------------------------------------------------ <br> <br>BSTR <br>CTDCCtl::bstrConstructSortExpr() <br>{ <br>    BSTR    bstr = NULL; <br> <br>    if (!EmptyBSTR(m_cbstrSortExpr)) <br>        bstr = SysAllocString(m_cbstrSortExpr); <br>    else if (!EmptyBSTR(m_cbstrSortColumn)) <br>    { <br>        //  Use the old-fashioned sort properties <br>        //  Construct a sort expression of the form: <br>        //     &lt;SortColumn&gt;  or <br>        //    -&lt;SortColumn&gt; <br>        // <br>        if (m_fSortAscending) <br>            bstr = SysAllocString(m_cbstrSortColumn); <br>        else <br>        { <br>            bstr = SysAllocStringLen(NULL, SysStringLen(m_cbstrSortColumn) + 1); <br>            if (bstr != NULL) <br>            { <br>                bstr[0] = L'-'; <br>                wch_cpy(&amp;bstr[1], m_cbstrSortColumn); <br>            } <br>        } <br>    } <br> <br>    return bstr; <br>} <br> <br>//------------------------------------------------------------------------ <br>// <br>//  Method:    bstrConstructFilterExpr() <br>// <br>//  Synopsis:  Constructs a filter expression from the Filter property or <br>//             (for backward compatibility) from the FilterColumn/FilterValue/ <br>//             FilterCriterion properties. <br>// <br>//             This method only exists to isolate backward-compatibility <br>//             with the old-fashioned filter properties. <br>// <br>//  Arguments: None. <br>// <br>//  Returns:   The constructed filter expression <br>// <br>//  NB!  It is the caller's responsibility to free the string returned. <br>// <br>//------------------------------------------------------------------------ <br> <br>BSTR <br>CTDCCtl::bstrConstructFilterExpr() <br>{ <br>    BSTR    bstr = NULL; <br> <br>    if (!EmptyBSTR(m_cbstrFilterExpr)) <br>        bstr = SysAllocString(m_cbstrFilterExpr); <br>    else if (!EmptyBSTR(m_cbstrFilterColumn)) <br>    { <br>        //  Use the old-fashioned filter properties <br>        //  Construct a sort expression of the form: <br>        //     &lt;FilterColumn&gt; &lt;FilterCriterion&gt; "&lt;FilterValue&gt;" <br>        // <br>        BSTR bstrFilterOp; <br>        HRESULT hr; <br> <br>        hr = get_FilterCriterion(&amp;bstrFilterOp); <br>        if (!SUCCEEDED(hr)) <br>            goto Cleanup; <br>        bstr = SysAllocStringLen(NULL, <br>                    SysStringLen(m_cbstrFilterColumn) + <br>                    SysStringLen(bstrFilterOp) + <br>                    1 + <br>                    SysStringLen(m_cbstrFilterValue) + <br>                    1); <br>        if (bstr != NULL) <br>        { <br>            DWORD pos = 0; </code></pre>
<p>
</p>
<pre><code><br>            wch_cpy(&amp;bstr[pos], m_cbstrFilterColumn); <br>            pos = wch_len(bstr); <br>            wch_cpy(&amp;bstr[pos], bstrFilterOp); <br>            pos = wch_len(bstr); <br>            bstr[pos++] = L'"'; <br>            wch_cpy(&amp;bstr[pos], m_cbstrFilterValue); <br>            pos = wch_len(bstr); <br>            bstr[pos++] = L'"'; <br>            bstr[pos] = 0; <br>        } <br>        SysFreeString(bstrFilterOp); <br>    } <br>Cleanup: <br>    return bstr; <br>} <br> <br>//------------------------------------------------------------------------ <br>// <br>//  Method:    TerminateDataLoad() <br>// <br>//  Synopsis:  Stop the current data load operation. <br>// <br>//  Returns:   S_OK upon success. <br>// <br>//------------------------------------------------------------------------ <br> <br>STDMETHODIMP CTDCCtl::TerminateDataLoad() <br>{ <br>    HRESULT hr  = S_OK; <br> <br>    // Make sure if we call Reset() right away now, we don't re-download <br>    // the data. <br>    m_fDataURLChanged = FALSE; <br> <br>    m_pBSC = NULL;      //  Block any outstanding OnData calls <br> <br>    if (m_pEventBroker) <br>        m_pEventBroker-&gt;m_pBSC = NULL;  // kill all <br> <br>    if (m_pUnify != NULL) <br>        delete m_pUnify; <br> <br>    m_pUnify = NULL; <br> <br>    return hr; <br>} <br> <br>//------------------------------------------------------------------------ <br>// <br>//  Method:    InitiateDataLoad() <br>// <br>//  Synopsis:  Start loading data from the control's DataURL property. <br>// <br>//  Arguments: fAppend        Flag to indicate whether data should be <br>//                            appended to an existing TDCArr object. <br>// <br>//  Returns:   S_OK upon success. <br>//             E_OUTOFMEMORY if not enough memory could be allocated to <br>//               complete the download. <br>// <br>//------------------------------------------------------------------------ <br> <br>STDMETHODIMP CTDCCtl::InitiateDataLoad(boolean fAppend) <br>{ <br>    HRESULT hr  = S_OK; <br> <br>    WCHAR   wchFieldDelim = (!m_cbstrFieldDelim) ? 0 : m_cbstrFieldDelim[0]; <br>    WCHAR   wchRowDelim   = (!m_cbstrRowDelim)   ? 0 : m_cbstrRowDelim[0]; <br>    // Default quote char to double-quote, not NULL <br>    WCHAR   wchQuoteChar  = (!m_cbstrQuoteChar)  ? 0 : m_cbstrQuoteChar[0]; <br>    WCHAR   wchEscapeChar = (!m_cbstrEscapeChar) ? 0 : m_cbstrEscapeChar[0]; <br> <br>    // <br>    // Figure out what code page to use. <br>    // <br>    if (0==m_nCodePage)                  <br>    { <br>        // 0 means user didn't set one, so ask our container. <br>        VARIANT varCodepage; <br>        VariantInit(&amp;varCodepage); <br>        GetAmbientProperty(DISPID_AMBIENT_CODEPAGE, varCodepage); <br> <br>        // If container didn't provide one, use the default code page <br>        // of the client system. <br>        m_nCodePage = (varCodepage.vt == VT_UI4) <br>                        ? (ULONG)varCodepage.lVal <br>                        : 1252;         // ultimate default is Latin-1 <br>    } <br> <br>    // <br>    // Default LCID the same way as Codepage <br>    // <br>    if (0==m_lcidRead) <br>    { <br>        hr = GetAmbientLocaleID(m_lcidRead); <br>        if (FAILED(hr)) <br>        { <br>            // Ultimate default is US locale -- sort of Web global <br>            // language default. <br>            put_Language_(L"en-us"); <br>        } <br>    } <br> <br>    if (EmptyBSTR(m_cbstrDataURL)) <br>    { <br>        hr = S_FALSE;                   // quiet failure <br>        goto Error; <br>    } <br> <br>    OutputDebugStringX(_T("Initiating Data Download\n")); <br> <br>    //  No data load should currently be in progress - <br>    //  This data load has been initiated on the construction of a new <br>    //  TDCArr object, or appending to an existing loaded TDCArr object. <br>    //  Any currently running data load would have been <br>    //  terminated by the call to ReleaseTDCArr(). <br>    // <br> <br>    _ASSERT(m_pUnify == NULL); <br>    _ASSERT(m_pBSC == NULL); <br> <br> <br>    m_hrDownloadStatus = S_OK; <br> <br>    //  Create a pipeline of objects to process the URL data <br>    // <br>    //    CMyBindStatusCallback -&gt; CTDCUnify -&gt; CTDCTokenise -&gt; CTDCArr <br>    // <br> <br>    CComObject&lt;CMyBindStatusCallback&lt;CTDCCtl&gt; &gt;::CreateInstance(&amp;m_pBSC); <br> <br>    if (m_pBSC == NULL) <br>    { <br>        hr = E_FAIL; <br>        goto Error; <br>    } <br>    hr = m_pArr-&gt;StartDataLoad(m_fUseHeader ? TRUE : FALSE, <br>                               bstrConstructSortExpr(), <br>                               bstrConstructFilterExpr(), <br>                               m_lcidRead, <br>                               m_pBSC, <br>                               fAppend, <br>                               m_fCaseSensitive ? 1 : 0); <br>    if (!SUCCEEDED(hr)) <br>        goto Error; <br> <br>    m_pUnify = new CTDCUnify(); <br>    if (m_pUnify == NULL) <br>    { <br>        hr = E_OUTOFMEMORY; <br>        goto Error; <br>    } <br>    m_pUnify-&gt;Create(m_nCodePage, m_pML); <br> <br>    // Init tokenizer <br>    m_pUnify-&gt;InitTokenizer(m_pArr, wchFieldDelim, wchRowDelim, <br>                            wchQuoteChar, wchEscapeChar); <br> <br> <br> <br>    m_fSecurityChecked = FALSE; <br> <br>    // Start (and maybe perform) actual download. <br>    // If we're within a Reset() call, always force a "reload" of the data <br>    // from the server -- i.e. turn on BINDF_GETNEWESTVERSION to make sure <br>    // sure the cache data isn't stale. <br>    hr = m_pBSC-&gt;StartAsyncDownload(this, OnData, m_cbstrDataURL, m_spClientSite, TRUE, <br>                                    m_fInReset == TRUE); <br>    if (FAILED(hr)) <br>        goto Error; <br> <br>    // m_hrDownloadStatus remembers the first (if any) error that occured during <br>    // the OnData callbacks.  Unlike an error returning from StartAsyncDownload, <br>    // this doesn't necessarily cause us to throw away the TDC array. <br>    hr = m_hrDownloadStatus; <br>    if (!SUCCEEDED(hr)) <br>        m_pBSC = NULL; <br> <br>Cleanup: <br>    return hr; <br> <br>Error: <br>    TerminateDataLoad(); <br>    if (m_pEventBroker) <br>    { <br>        // Fire data set changed to indicate query failed, <br>        m_pEventBroker-&gt;STDDataSetChanged(); <br>        // and go complete. <br>        UpdateReadyState(READYSTATE_COMPLETE); <br>    } <br>    goto Cleanup; <br>} <br> <br>// ;begin_internal <br> <br>#define ZERO '0' <br>#define NINE '9' <br>#define DOT '.' <br> <br>// Scans a string and returns TRUE if it looks like a numeric <br>// part of an IP address <br>static BOOL ScanNumber (LPOLESTR&amp; psz) <br>{ <br>    // first char <br>    if (*psz &lt; ZERO || *psz &gt; NINE) <br>        return FALSE; <br>    psz++; <br> <br>    // second char <br>    if (*psz &lt; ZERO || *psz &gt; NINE) <br>        return FALSE; <br>    psz++; <br> <br>    // third char <br>    if (*psz &lt; ZERO || *psz &gt; NINE) <br>        return FALSE; <br> <br>    return TRUE; <br>} <br> <br>// ;end_internal <br> <br>//------------------------------------------------------------------------ <br>// <br>//  Method:    SecurityCheckDataURL(pszURL) <br>// <br>//  Synopsis:  Check that the data URL is within the same security zone <br>//             as the document that loaded the control. <br>// <br>//  Arguments: URL to check <br>// <br>//  Returns:   S_OK upon success. <br>//             E_INVALID if the security check failed or we failed to get <br>//               an interface that we needed <br>// <br>//------------------------------------------------------------------------ <br> <br> <br>// ;begin_internal <br>// Wendy Richards(v-wendri) 6/6/97 <br>// Copied this here because I couldn't link without it. The version <br>// of URLMON.LIB I have does not have this symbol exported <br>// ;end_internal <br> <br>const IID IID_IInternetHostSecurityManager = {0x3af280b6,0xcb3f,0x11d0,{0x89,0x1e,0x00,0xc0,0x4f,0xb6,0xbf,0xc4}}; <br> <br>#define MAX_SEC_ID 256 <br> <br>STDMETHODIMP CTDCCtl::SecurityCheckDataURL(LPOLESTR pszURL) <br>{ <br>    CComQIPtr&lt;IServiceProvider, &amp;IID_IServiceProvider&gt; pSP(m_spClientSite); <br>    CComPtr&lt;IInternetSecurityManager&gt; pSM; <br>    CComPtr&lt;IInternetHostSecurityManager&gt; pHSM; <br>    CComPtr&lt;IMoniker&gt; pMoniker; <br> <br>    BYTE     bSecIDHost[MAX_SEC_ID], bSecIDURL[MAX_SEC_ID]; <br>    DWORD    cbSecIDHost = MAX_SEC_ID, cbSecIDURL = MAX_SEC_ID;  <br>    HRESULT  hr = E_FAIL; <br> <br>    USES_CONVERSION; <br> <br>    // If we're running under the timer, it's quite possible our ClientSite will <br>    // disappear out from under us.  We'll obviously fail the security check, <br>    // but things are shutting down anyway.. <br>    if (pSP==NULL) <br>        goto Cleanup; <br> <br>    hr = CoInternetCreateSecurityManager(pSP, &amp;pSM, 0L); <br>    if (!SUCCEEDED(hr)) <br>        goto Cleanup; <br> <br>    hr = pSP-&gt;QueryService(IID_IInternetHostSecurityManager, <br>                           IID_IInternetHostSecurityManager, <br>                           (LPVOID *)&amp;pHSM); <br>    if (!SUCCEEDED(hr)) <br>        goto Cleanup; <br> <br>    hr = pHSM-&gt;GetSecurityId(bSecIDHost, &amp;cbSecIDHost, 0L); <br>    if (!SUCCEEDED(hr)) <br>        goto Cleanup; <br> <br>    hr = pSM-&gt;GetSecurityId(OLE2W(pszURL), bSecIDURL, &amp;cbSecIDURL, 0L); <br>    if (!SUCCEEDED(hr)) <br>        goto Cleanup; <br> <br>    if (cbSecIDHost != cbSecIDURL) <br>    { <br>        hr = E_FAIL; <br>        goto Cleanup; <br>    }    <br> <br>    if (memcmp(bSecIDHost, bSecIDURL, cbSecIDHost) != 0) <br>    { <br>        hr = E_FAIL; <br>        goto Cleanup; <br>    } <br> <br>Cleanup: <br>#ifdef ATLTRACE <br>    LPOLESTR pszHostName = NULL; <br>    TCHAR *pszFailPass = hr ? _T("Failed") : _T("Passed"); <br>    GetHostURL(m_spClientSite, &amp;pszHostName); <br>    ATLTRACE(_T("CTDCCtl: %s security check on %S referencing %S\n"), pszFailPass, <br>             pszHostName, pszURL); <br>    bSecIDHost[cbSecIDHost] = 0; <br>    bSecIDURL[cbSecIDURL] = 0; <br>    ATLTRACE(_T("CTDCCtl: Security ID Host %d bytes: %s\n"), cbSecIDHost, bSecIDHost); <br>    ATLTRACE(_T("CTDCCtl: Security ID URL %d bytes: %s\n"), cbSecIDURL, bSecIDURL); <br>    CoTaskMemFree(pszHostName); <br>#endif <br>    return hr; <br>} <br> <br>//------------------------------------------------------------------------ <br>// <br>//  Method:    OnData() <br>// <br>//  Synopsis:  Accepts a chunk of data loaded from a URL and parses it. <br>// <br>//  Arguments: pBSC       The invoking data transfer object. <br>//             pBytes     Character buffer containing data. <br>//             dwSize     Count of the number of bytes in 'pBytes'. <br>// <br>//  Returns:   Nothing. <br>// <br>//------------------------------------------------------------------------ <br> <br>void CTDCCtl::OnData(CMyBindStatusCallback&lt;CTDCCtl&gt; *pBSC, BYTE *pBytes, DWORD dwSize) <br>{ <br>    HRESULT hr; <br>    CTDCUnify::ALLOWDOMAINLIST nAllowDomainList; <br> <br>    if (pBSC != m_pBSC) <br>    { <br>        OutputDebugStringX(_T("OnData called from invalid callback object\n")); <br>        hr = S_OK; <br>        goto Cleanup; <br>    } <br> <br> <br>    if (pBytes != NULL &amp;&amp; dwSize != 0) <br>    { <br>        OutputDebugStringX(_T("OnData called with data buffer\n")); <br>        //  Process this chunk of data  <br>        // <br>        hr = m_pUnify-&gt;ConvertByteBuffer(pBytes, dwSize); <br> <br>        if (!m_fSecurityChecked) <br>        { <br>            // Note that we MUST check for the allow domain list at the <br>            // front of every file, even if it's on the same host.  This <br>            // is to make sure if we always strip off the @!allow_domain line. <br>            nAllowDomainList = m_pUnify-&gt;CheckForAllowDomainList(); <br> <br>            switch (nAllowDomainList) <br>            { <br>                // Don't have enough chars to tell yet. <br>                case CTDCUnify::ALLOW_DOMAINLIST_DONTKNOW: <br>                    // Return without errors or arborting. <br>                    // Presumably the next data packet will bring more info. <br>                    return; <br> <br>                case CTDCUnify::ALLOW_DOMAINLIST_NO: <br>                    hr = E_FAIL; <br>                    // It's not on the exception list, still try to see if <br>                    // it's in the same domain. <br>                    break; <br> <br>                case CTDCUnify::ALLOW_DOMAINLIST_YES: <br>                    // The file is decorated.  Now check the domain list <br>                    // against our host domain name. <br>                    hr = SecurityMatchAllowDomainList(); <br>#ifdef ATLTRACE <br>                    if (!hr) ATLTRACE(_T("CTDCCtl: @!allow_domain list matched.")); <br>                    else ATLTRACE(_T("CTDCCtl: @!allow_domain list did not match")); <br>#endif <br>                    break; <br>            } <br> <br>            // Unless we passed the previous security check, we still have to <br>            // do the next one. <br>            if (FAILED(hr)) <br>            { <br>                if (FAILED(hr = SecurityCheckDataURL(m_pBSC-&gt;m_pszURL))) <br>                    goto Error; <br>            } <br>            else <br>            { <br>                hr = SecurityMatchProtocols(m_pBSC-&gt;m_pszURL); <br>                if (FAILED(hr)) <br>                    goto Error; <br>            } <br> <br> <br>            // Set m_fSecurityChecked only if it passes security.  This is in case for some <br>            // reason we get more callbacks before the StopTransfer takes affect. <br>            m_fSecurityChecked = TRUE;             <br>        } <br> <br>        // Normal case, we can process data! <br>        hr = m_pUnify-&gt;AddWcharBuffer(FALSE); <br> <br>    } <br>    else if (pBytes == NULL || dwSize == 0) <br>    { <br>        OutputDebugStringX(_T("OnData called with empty (terminating) buffer\n")); <br> <br>        // We might not have gotten enough to check security yet. <br>        if (!m_fSecurityChecked) <br>        { <br>            if (FAILED(hr = SecurityCheckDataURL(m_pBSC-&gt;m_pszURL))) <br>                goto Error; <br>        } <br> <br>        //  No more data - trigger an EOF <br>        // <br>        hr = m_pUnify-&gt;AddWcharBuffer(TRUE); // last chance to parse any stragglers <br> <br>        if (m_pArr!=NULL) <br>            hr = m_pArr-&gt;EOF(); <br> <br>        TerminateDataLoad(); <br>    } <br> <br>Cleanup: <br>    //  Void fn - can't return an error code ... <br>    // <br>    if (SUCCEEDED(m_hrDownloadStatus)) <br>        m_hrDownloadStatus = hr; <br>    return; <br> <br>Error: <br>    // Security failure. <br>    // Abort the current download <br>    if (m_pBSC &amp;&amp; m_pBSC-&gt;m_spBinding) <br>    { <br>        (void) m_pBSC-&gt;m_spBinding-&gt;Abort(); <br>    } <br> <br>    m_hrDownloadStatus = hr; <br> <br>    // Notify data set changed for the abort <br>    if (m_pEventBroker != NULL) <br>        hr = m_pEventBroker-&gt;STDDataSetChanged(); <br>    goto Cleanup; <br>} <br> <br>// <br>// Utility routine to get our  <br>// <br>HRESULT <br>GetHostURL(IOleClientSite *pSite, LPOLESTR *ppszHostName) <br>{ <br>    HRESULT hr; <br>    CComPtr&lt;IMoniker&gt; spMoniker; <br>    CComPtr&lt;IBindCtx&gt; spBindCtx; <br> <br>    if (!pSite) <br>    { <br>        hr = E_FAIL; <br>        goto Cleanup; <br>    } <br> <br>    hr = pSite-&gt;GetMoniker(OLEGETMONIKER_ONLYIFTHERE, OLEWHICHMK_CONTAINER, <br>                           &amp;spMoniker); <br>    if (FAILED(hr)) <br>        goto Cleanup; <br> <br>    hr = CreateBindCtx(0, &amp;spBindCtx); <br>    if (FAILED(hr)) <br>        goto Cleanup; <br> <br>    hr = spMoniker-&gt;GetDisplayName(spBindCtx, NULL, ppszHostName); <br>    if (FAILED(hr)) <br>        goto Cleanup; <br> <br>Cleanup: <br>    return hr; <br>} <br> <br>HRESULT <br>CTDCCtl::SecurityMatchProtocols(LPOLESTR pszURL) <br>{ <br>    HRESULT hr = E_FAIL; <br> <br>    LPOLESTR pszHostURL = NULL; <br>    LPWCH pszPostHostProtocol; <br>    LPWCH pszPostProtocol; <br> <br>    if (FAILED(GetHostURL(m_spClientSite, &amp;pszHostURL))) <br>        goto Cleanup; <br> <br>    pszPostHostProtocol = wch_chr(pszHostURL, _T(':')); <br>    pszPostProtocol     = wch_chr(pszURL, _T(':')); <br>    if (!pszPostHostProtocol || !pszPostProtocol) <br>        goto Cleanup; <br>    else <br>    { <br>        int ccChars1 = pszPostHostProtocol - pszHostURL; <br>        int ccChars2 = pszPostProtocol - pszURL; <br>        if (ccChars1 != ccChars2) <br>            goto Cleanup; <br>        else if (wch_ncmp(pszHostURL, pszURL, ccChars1) != 0) <br>            goto Cleanup; <br>    } <br>    hr = S_OK; <br> <br>Cleanup: <br>    if (pszHostURL) <br>        CoTaskMemFree(pszHostURL); <br>     <br>    return hr; <br>} <br> <br>HRESULT <br>CTDCCtl::SecurityMatchAllowDomainList() <br>{ <br>    HRESULT hr; <br>    WCHAR swzHostDomain[INTERNET_MAX_HOST_NAME_LENGTH]; <br>    DWORD cchHostDomain = INTERNET_MAX_HOST_NAME_LENGTH; <br>    LPOLESTR pszHostName = NULL; <br> <br>    hr = GetHostURL(m_spClientSite, &amp;pszHostName); <br>    if (FAILED(hr)) <br>        goto Cleanup; <br> <br>    hr = CoInternetParseUrl(pszHostName, PARSE_DOMAIN, 0, swzHostDomain, cchHostDomain, <br>                            &amp;cchHostDomain, 0); <br>    if (FAILED(hr)) <br>        goto Cleanup; <br> <br>    hr = m_pUnify-&gt;MatchAllowDomainList(swzHostDomain); <br> <br>Cleanup: <br>    CoTaskMemFree(pszHostName); <br>    return hr; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
