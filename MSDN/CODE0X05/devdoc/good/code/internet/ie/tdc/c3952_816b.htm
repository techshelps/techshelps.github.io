<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>WCH.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3953"></a>WCH.CPP</h2>
<pre><code>//+----------------------------------------------------------------------- <br>// <br>//  Wide Character Routines <br>//  Copyright (C) Microsoft Corporation, 1996, 1997 <br>// <br>//  File:       wch.cpp <br>// <br>//  Contents:   Implementation of wide characters routines. <br>//              These routines are being used to avoid dragging in <br>//              the initialization chunk of the C run-time library <br>//              that would be required by library routines such as <br>//              wcsicmp() etc. <br>// <br>//------------------------------------------------------------------------ <br> <br>#include "stdafx.h" <br>#include "shlwapi.h"            // Wrapper routines for non-Win95 calls <br> <br>#pragma comment(lib, "shlwapi.lib") <br> <br>//------------------------------------------------------------------------ <br>// <br>//  Function:  wch_icmp() <br>// <br>//  Synopsis:  Perform a case-insensitive comparison of two strings. <br>// <br>//  Arguments: pwch1     First string to compare <br>//             pwch2     Second string to compare <br>//             Treats NULLs as empty strings. <br>// <br>//  Returns:   0 if the strings are lexically equal (allowing for <br>//               case insensitivity) <br>//             -1 if pwch1 lexically less than pwch2 <br>//             +1 if pwch1 lexically greater than pwch2 <br>// <br>//------------------------------------------------------------------------ <br> <br>int wch_icmp(LPWCH pwch1, LPWCH pwch2) <br>{ <br>    USES_CONVERSION; <br> <br>    if (pwch1 == NULL) <br>        pwch1 = L""; <br>    if (pwch2 == NULL) <br>        pwch2 = L""; <br> <br>    return StrCmpIW(pwch1, pwch2); <br>} <br> <br>//------------------------------------------------------------------------ <br>// <br>//  Function:  wch_incmp() <br>// <br>//  Synopsis:  Perform a case-insensitive comparison of two strings, <br>//             up to a specified maximum number of characters. <br>// <br>//  Arguments: pwch1     First string to compare <br>//             pwch2     Second string to compare <br>//             dwMaxLen  Maximum number of characters to compare. <br>// <br>//             Treats NULLs as empty strings. <br>// <br>//  Returns:   0 if the strings are lexically equal (allowing for <br>//               case insensitivity) <br>//             -1 if pwch1 lexically less than pwch2 <br>//             +1 if pwch1 lexically greater than pwch2 <br>// <br>//------------------------------------------------------------------------ <br> <br>int wch_incmp(LPWCH pwch1, LPWCH pwch2, DWORD dwMaxLen) <br>{ <br> <br>    if (pwch1 == NULL) <br>        pwch1 = L""; <br>    if (pwch2 == NULL) <br>        pwch2 = L""; <br> <br>    return StrCmpNIW(pwch1, pwch2, dwMaxLen); <br>} <br> <br>//------------------------------------------------------------------------ <br>// <br>//  Function:  wch_len() <br>// <br>//  Synopsis:  Calculate the length of a string. <br>//             Treats NULL as an empty string. <br>// <br>//  Arguments: pwch      String to measure <br>// <br>//  Returns:   Length of given string. <br>// <br>//------------------------------------------------------------------------ <br> <br>int wch_len(LPWCH pwch) <br>{ <br>    LPWCH   pwchOrig = pwch; <br> <br>    if (pwch == NULL) <br>        return 0; <br>    while (*pwch++ != 0) <br>        ; <br>    return pwch - pwchOrig - 1; <br>} <br> <br>//------------------------------------------------------------------------ <br>// <br>//  Function:  wch_cmp() <br>// <br>//  Synopsis:  Perform a case-sensitive comparison of two strings. <br>//             Treats NULLs as empty strings. <br>// <br>//  Arguments: pwch1     First string to compare <br>//             pwch2     Second string to compare <br>// <br>//  Returns:   0 if the strings are lexically equal <br>//             -1 if pwch1 lexically less than pwch2 <br>//             +1 if pwch1 lexically greater than pwch2 <br>// <br>//------------------------------------------------------------------------ <br> <br>int wch_cmp(LPWCH pwch1, LPWCH pwch2) <br>{ <br>    if (pwch1 == NULL) <br>        pwch1 = L""; <br>    if (pwch2 == NULL) <br>        pwch2 = L""; <br>    for (; *pwch1 != 0 &amp;&amp; *pwch1 == *pwch2; pwch1++, pwch2++) <br>        ; <br>    return *pwch1 - *pwch2; <br>} <br> <br>//------------------------------------------------------------------------ <br>// <br>//  Function:  wch_ncmp() <br>// <br>//  Synopsis:  Perform a case-sensitive comparison of two strings, <br>//             up to a specified maximum number of characters. <br>// <br>//  Arguments: pwch1     First string to compare <br>//             pwch2     Second string to compare <br>//             dwMaxLen  Maximum number of characters to compare. <br>// <br>//             Treats NULLs as empty strings. <br>// <br>//  Returns:   0 if the strings are lexically equal (allowing for <br>//               case insensitivity) <br>//             -1 if pwch1 lexically less than pwch2 <br>//             +1 if pwch1 lexically greater than pwch2 <br>// <br>//------------------------------------------------------------------------ <br> <br>int wch_ncmp(LPWCH pwch1, LPWCH pwch2, DWORD dwMaxLen) <br>{ <br>    int cmp; <br> <br>    if (pwch1 == NULL) <br>        pwch1 = L""; <br>    if (pwch2 == NULL) <br>        pwch2 = L""; <br> <br>    for (cmp = 0; cmp == 0 &amp;&amp; dwMaxLen-- &gt; 0; pwch1++, pwch2++) <br>        if (*pwch1 == 0) <br>        { <br>            cmp = (*pwch2 == 0) ? 0 : -1; <br>            break; <br>        } <br>        else <br>            cmp = (*pwch2 == 0) ? 1 : (*pwch2 - *pwch1); <br> <br>    return cmp; <br>} <br> <br>//------------------------------------------------------------------------ <br>// <br>//  Function:  wch_cpy() <br>// <br>//  Synopsis:  Copy a wide-character null-terminated string. <br>//             Treats NULL source as an empty string. <br>// <br>//  Arguments: pwchDesc  Destination buffer. <br>//             pwchSrc   Source string. <br>// <br>//  Returns:   Nothing. <br>// <br>//------------------------------------------------------------------------ <br> <br>void wch_cpy(LPWCH pwchDest, LPWCH pwchSrc) <br>{ <br>    if (pwchSrc == NULL) <br>        *pwchDest = 0; <br>    else <br>        while ((*pwchDest++ = *pwchSrc++) != 0) <br>            ; <br>} <br> <br>//------------------------------------------------------------------------ <br>// <br>//  Function:  wch_chr() <br>// <br>//  Synopsis:  Searches for a character in a null-terminated wide-character <br>//             string. <br>//             Treats NULL pwch as an empty string. <br>// <br>//  Arguments: pwch      Search string. <br>//             wch       Character to search for.copy. <br>// <br>//  Returns:   Pointer to first occurrence of 'wch' in 'pwch' if found. <br>//             NULL if 'wch' does not occur in 'pwch'. <br>// <br>//------------------------------------------------------------------------ <br> <br>LPWCH wch_chr(LPWCH pwch, WCHAR wch) <br>{ <br>    if (pwch != NULL) <br>        for (; *pwch != 0; pwch++) <br>            if (*pwch == wch) <br>                return pwch; <br>    return NULL; <br>} <br> <br>//------------------------------------------------------------------------ <br>// <br>//  Function:  wch_wildcardMatch() <br>// <br>//  Synopsis:  Determines whether the given text matches the given <br>//             pattern, which interprets the character '*' as a match <br>//             for 0-or-more characters. <br>//             Treats NULL pwchText as an empty string. <br>//             Treats NULL pwchPattern as an empty string. <br>// <br>//  Arguments: pwchText         Text to match. <br>//             pwchPattern      Pattern to match against. <br>//             fCaseSensitive   Flag to indicate whether match should be <br>//                                case sensitive. <br>// <br>//  Returns:   TRUE if the text matches the given pattern. <br>//             FALSE otherwise. <br>// <br>//------------------------------------------------------------------------ <br> <br>// ;begin_internal <br>// compiler bug (VC5 with optimise?) <br>// ;end_internal <br>boolean wch_wildcardMatch(LPWCH pwchText, LPWCH pwchPattern, <br>                          boolean fCaseSensitive) <br>{ <br>    boolean fMatched; <br>    LPWCH pwchStar; <br>    DWORD   dwPatternLen; <br> <br>    if (pwchText == NULL || pwchText[0] == 0) <br>    { <br>        //  Empty/NULL text.  This matches: <br>        //     - Empty/NULL patterns <br>        //     - Patterns consisting of a string of '*'s <br>        // <br>        //  Equivalently, the text FAILS to match if there <br>        //  is at least one non-* character in the pattern. <br>        // <br>        fMatched = TRUE; <br>        if (pwchPattern != NULL) <br>            while (fMatched &amp;&amp; *pwchPattern != 0) <br>                fMatched = *pwchPattern++ == L'*'; <br>        goto Done; <br>    } <br>    if (pwchPattern == NULL || pwchPattern[0] == 0) <br>    { <br>        //  NULL pattern can only match empty text. <br>        //  Since we've already dealt with the case of empty text above, <br>        //  the match must fail <br>        // <br>        fMatched = FALSE; <br>        goto Done; <br>    } <br> <br>    //  Find the occurrence of the first '*' in the pattern ... <br>    // <br>    pwchStar = wch_chr(pwchPattern, L'*'); <br> <br>    if (pwchStar == NULL) <br>    { <br>        //  No '*'s in the pattern - compute an exact match <br>        // <br>        fMatched = fCaseSensitive <br>            ? wch_cmp(pwchText, pwchPattern) == 0 <br>            : wch_icmp(pwchText, pwchPattern) == 0; <br>        goto Done; <br>    } <br> <br>    int (*pfnBufCmp)(LPWCH pwch1, LPWCH pwch2, DWORD dwMaxCmp); <br> <br>    pfnBufCmp = fCaseSensitive ? wch_ncmp : wch_incmp; <br> <br>    //  Ensure an exact match for characters preceding the first '*', if any <br>    // <br>    dwPatternLen = pwchStar - pwchPattern; <br>    fMatched = (*pfnBufCmp)(pwchText, pwchPattern, dwPatternLen) == 0; <br>    if (!fMatched) <br>        goto Done; <br>    pwchText += dwPatternLen; <br> <br>    for (;;) <br>    { <br>        DWORD dwTextLen = wch_len(pwchText); <br> <br>        //  Skip over leading '*'s in the pattern <br>        // <br>        _ASSERT(*pwchStar == L'*'); <br>        while (*pwchStar == L'*') <br>            pwchStar++; <br> <br>        pwchPattern = pwchStar; <br> <br>        //  Find the next occurrence of a '*' in the pattern <br>        // <br>        if (*pwchPattern == 0) <br>        { <br>            //  This must be have been a trailing '*' in the pattern. <br>            //  It automatically matches what remains of the text. <br>            // <br>            fMatched = TRUE; <br>            goto Done; <br>        } <br>        pwchStar = wch_chr(pwchPattern, L'*'); <br>        if (pwchStar == NULL) <br>        { <br>            //  No more '*'s - require an exact match of remaining <br>            //  pattern text with the end of the text. <br>            // <br>            dwPatternLen = wch_len(pwchPattern); <br>            fMatched = (dwTextLen &gt;= dwPatternLen) &amp;&amp; <br>                        (*pfnBufCmp)(pwchText + dwTextLen - dwPatternLen, <br>                                     pwchPattern, dwPatternLen) == 0; <br>            goto Done; <br>        } <br> <br>        //  Locate an exact match for the pattern-up-to-next-* <br>        //  within the text buffer <br>        // <br>        dwPatternLen = pwchStar - pwchPattern; <br>        fMatched = FALSE; <br>        while (dwTextLen &gt;= dwPatternLen) <br>        { <br>            fMatched = (*pfnBufCmp)(pwchText, pwchPattern, dwPatternLen) == 0; <br>            if (fMatched) <br>                break; <br>             dwTextLen--; <br>             pwchText++; <br>        } <br>        if (!fMatched) <br>            goto Done; <br>        pwchText += dwPatternLen; <br>    } <br> <br>Done: <br>    return fMatched; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
