<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>TARRAY.H</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3943"></a><sup></sup>TARRAY.H</h2>
<pre><code>//+----------------------------------------------------------------------- <br>// <br>//  Template Array Implementation <br>//  Copyright (C) Microsoft Corporation, 1996, 1997 <br>// <br>//  File:      tarray.h <br>// <br>//  Contents:  Template for resizeable arrays.  Allows for the creation <br>//             and manipulation of arrays of any type.  Arrays can <br>//             be dynamically reallocated, and thus can "grow and shrink". <br>//             Constructors and destructors of array elements is <br>//             automatically handles, even when the size of the array is <br>//             changed. <br>//  Templates: TSTDArray <br>// <br>//------------------------------------------------------------------------ <br> <br>#ifndef _TARRAY_H_ <br>#define _TARRAY_H_ <br> <br> <br> <br>//+----------------------------------------------------------------------- <br>// <br>//  Class:     TSTDArray <br>// <br>//  Synopsis:  Contains an array of "type".  Allows array to grow <br>//             dynamically.  During debug, can check bounds on indices. <br>//             Array is indexed 0 to _cArraySize-1.  _cArraySize holds <br>//               number of elements. <br>// <br>//  Methods:   Init          allocate memory for array <br>//             Passivate <br>//             []            allows indexing of array <br>//             GetSize       returns size of array <br>//             InsertElems   insert elements anywhere in array <br>//             DeleteElems   delete elements anywhere in array <br>// <br>//------------------------------------------------------------------------ <br> <br>template &lt;class TYPE&gt; <br>class TSTDArray <br>{ <br>public: <br>    TSTDArray(); <br>#if DBG == 1 <br>    ~TSTDArray(); <br>#endif <br>    HRESULT Init(const size_t cSize); // initialize data structures <br>    void Passivate(); <br> <br>    TYPE&amp; operator[](const size_t iElement); <br>    const TYPE&amp; operator[](const size_t iElement) const; // constant reference <br>    size_t GetSize() const { return _cArraySize; } <br> <br>    HRESULT InsertElems(const size_t iElem, const size_t cElems); <br>    void DeleteElems(const size_t iElem, const size_t cElems); <br> <br>private: <br>#if DBG == 1 <br>    void IsValidObject() const; <br>#else <br>    void IsValidObject() const <br>        {   } <br>#endif <br> <br>// All elements are packaged inside a class CElem.  This allows us to <br>//   overload the new operator so that we can manually invoke the <br>//   constructors. <br> <br>    class CElem <br>    { <br>        friend TSTDArray; <br>    private: <br>        // Now we overload the new operator to allow placement argument <br>        void *operator new(size_t uSize, void *pv) { return pv; } <br> <br>        // Internal data: <br>        TYPE _Element;       // actual element <br>    }; <br> <br>// Internal data: <br>    CElem *_paArray;        // pointer to actual data <br>    size_t _cArraySize; <br>    size_t _cAllocSize;     // the size of allocated object <br> <br>#if DBG == 1 <br>    // Ensure we call constructors and destructors right number of times. <br>    //   Used only as a check. <br>    size_t _cNumElems; <br>#endif <br>}; <br> <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     IsValidObject <br>// <br>//  Synopsis:   Validation method.  Checks that array structure is valid. <br>//              It is usefull to call this member function at the beginning <br>//              of each member function that uses the internal array to <br>//              ensure that the array is not corrupt before attempting to <br>//              modify it. <br>// <br> <br>#if DBG == 1 <br>template &lt;class TYPE&gt; <br>void <br>TSTDArray&lt;TYPE&gt;::IsValidObject() const <br>{ <br>    _ASSERT("Must have valid this pointer" &amp;&amp; <br>           this ); <br> <br>    _ASSERT("Array has no memory" &amp;&amp; <br>           _paArray ); <br> <br>    _ASSERT("destructors called wrong number of times" &amp;&amp; <br>           (_cNumElems == _cArraySize) ); <br>} <br>#endif <br> <br> <br>//+----------------------------------------------------------------------- <br>// <br>//  Constructor for TSTDArray <br>// <br>//  Synopsis:  Doesn't do anything.  Must call member function init to <br>//             actually initialize.  Only call init once. <br>// <br>//  Arguments: None. <br>// <br>//  Returns:   Nothing. <br>// <br> <br>template &lt;class TYPE&gt; <br>TSTDArray&lt;TYPE&gt;::TSTDArray() <br>{ <br>// We null the internal data, so that they are not actually used <br>// until the init member function is called. <br> <br>    _paArray = 0; <br>    _cArraySize = 0; <br>    _cAllocSize = 0; <br> <br>#if DBG == 1 <br>    _cNumElems = 0; <br>#endif <br>} <br> <br> <br>//+----------------------------------------------------------------------- <br>// <br>//  Destructor for TSTDArray <br>// <br>//  Synopsis:  Must call member function passivate <br>//             to actually de-initialize. <br>// <br>//  Arguments: None. <br>// <br>//  Returns:   Nothing. <br>// <br> <br>#if DBG == 1 <br>template &lt;class TYPE&gt; <br>TSTDArray&lt;TYPE&gt;::~TSTDArray() <br>{ <br>    _ASSERT("Passivate must be called first" &amp;&amp; <br>           !_paArray ); <br> <br>    _ASSERT("Destructors called wrong number of times" &amp;&amp; <br>           (_cNumElems == 0) ); <br>} <br>#endif <br> <br> <br>//+----------------------------------------------------------------------- <br>// <br>//  Member:    Init <br>// <br>//  Synopsis:  Initializes the array abstract data type.  Allocates <br>//             memory for the array.  Also sets the cArraySize to <br>//             the number of elements. <br>// <br>//  Arguments: cSize    initial size of array (# of elements) <br>// <br>//  Returns:   Success if memory can be allocated for table. <br>//             Returns E_OUTOFMEMORY if can't get memory. <br>// <br> <br>template &lt;class TYPE&gt; <br>HRESULT <br>TSTDArray&lt;TYPE&gt;::Init(const size_t cSize) <br>{ <br>    HRESULT hr; <br> <br>    _ASSERT(this); <br> <br>    _ASSERT("Only call init once" &amp;&amp; <br>           !_paArray ); <br> <br>// Get memory: <br> <br>    // 0 element array is made into 1 element array so that it functions <br>    //   normally. <br>    { <br>        //;begin_internal <br>        // BUGBUG: <br>        // MSVC 2.0 has a bug in it.  Evaluating the expression sizeof(CElem) <br>        //   seems to confuse it.  CElem is a class containing a variable <br>        //   whose size can only be calculated when the template containing it <br>        //   is instantiated.  In addition to this, CElem is a member of that <br>        //   template.  Placing the sizeof(CElem) expression within a more <br>        //   complicated expression is not possible. <br>        //;end_internal <br>        size_t uCElemSize; <br> <br>        uCElemSize = sizeof(CElem); <br>        uCElemSize *= (cSize == 0 ? 1 : cSize); <br>        _paArray = (CElem *) CoTaskMemAlloc(uCElemSize); <br>    } <br>    if (!_paArray) <br>    { <br>        hr = E_OUTOFMEMORY; <br>    } <br>    else <br>    { <br>        CElem *pTemp;                   // index used to call constructors <br> <br>        // We need to call the constructors manually for each element: <br>        for (pTemp = _paArray; pTemp &lt; _paArray + cSize; pTemp++) <br>        { <br>            new (pTemp) CElem; <br>#if DBG == 1 <br>            _cNumElems++; <br>#endif <br>        } <br> <br>        _cArraySize = cSize; <br>        _cAllocSize = (cSize == 0 ? 1 : cSize); <br>        hr = S_OK; <br>    } <br> <br>    return hr; <br>} <br> <br> <br>//+----------------------------------------------------------------------- <br>// <br>//  Member:    Passivate <br>// <br>//  Synopsis:  Releases memory held in array.  Should be called before <br>//             the object is destroyed.  Should only be called once on an <br>//             object. <br>// <br>//  Arguments: None. <br>// <br>//  Returns:   Nothing. <br>// <br>//------------------------------------------------------------------------ <br> <br>template &lt;class TYPE&gt; <br>void <br>TSTDArray&lt;TYPE&gt;::Passivate() <br>{ <br>    IsValidObject(); <br> <br>    _ASSERT("Only call Passivate once" &amp;&amp; <br>           _paArray ); <br> <br>    // We need to call the destructors manually for each element: <br> <br>    { <br>        CElem *pTemp;                   // index used to call destructors <br> <br>        for (pTemp = _paArray; pTemp &lt; _paArray + _cArraySize; pTemp++) <br>        { <br>            pTemp-&gt;CElem::~CElem(); <br>#if DBG == 1 <br>            _cNumElems--; <br>#endif <br>        } <br>    } <br> <br>    CoTaskMemFree(_paArray); <br> <br>    _paArray = 0;         // make sure we don't call Passivate again <br>    _cArraySize = 0; <br>    _cAllocSize = 0; <br>} <br> <br> <br>//+----------------------------------------------------------------------- <br>// <br>//  Member:    operator[] <br>// <br>//  Synopsis:  Allows indexing of array's elements.  Use this to either <br>//             store an element in the array or read an element from <br>//             the array.  It is the user's responsibility to ensure <br>//             that the index is within the proper range, 0.._cArraySize-1. <br>//             During debugging, the index range is checked. <br>// <br>//  Arguments: iElement       Element index <br>// <br>//  Returns:   Reference to element. <br>// <br> <br>template &lt;class TYPE&gt; <br>inline <br>TYPE&amp; <br>TSTDArray&lt;TYPE&gt;::operator[](const size_t iElement) <br>{ <br>    IsValidObject(); <br> <br>    _ASSERT("Index is out of range" &amp;&amp; <br>           (iElement &lt; _cArraySize) ); <br> <br>    return _paArray[iElement]._Element; <br>} <br> <br> <br>//+----------------------------------------------------------------------- <br>// <br>//  Member:    operator[] const <br>// <br>//  Synopsis:  Same as previous [] operator, but returns a constant <br>//             reference so that it can't be used as an l-value. <br>// <br>//  Arguments: iElement       Element index <br>// <br>//  Returns:   Constant reference to element. <br>// <br> <br>template &lt;class TYPE&gt; <br>inline <br>const TYPE&amp; <br>TSTDArray&lt;TYPE&gt;::operator[](const size_t iElement) const <br>{ <br>    IsValidObject(this); <br> <br>    _ASSERT("Index is out of range" &amp;&amp; <br>           (iElement &lt; _cArraySize) ); <br> <br>    return _paArray[iElement]._Element; <br>} <br> <br> <br>//+----------------------------------------------------------------------- <br>// <br>//  Member:    InsertElems <br>// <br>//  Synopsis:  Changes the size of the array by using MemRealloc(). <br>//             Inserts a number of elements cElems into the array at <br>//             iElem.  This can be used to add new elements to the end of <br>//             the array by specifying iElem equal to _cArraySize.  It is <br>//             the responsibility of the user to make sure that iElem is <br>//             within the proper bounds of the array, although this will <br>//             be checked during debug mode. <br>// <br>//  Arguments: iElem       place to insert first element <br>//             cElems      number of new elements <br>// <br>//  Returns:   Returns success if elements can be added. <br>//             Returns E_OUTOFMEMORY if request cannot be met. <br>//             Array retains its old size if the request cannot be met. <br>// <br> <br>template&lt;class TYPE&gt; <br>HRESULT <br>TSTDArray&lt;TYPE&gt;::InsertElems(const size_t iElem, const size_t cElems) <br>{ <br>    HRESULT hr = S_OK; <br> <br>    IsValidObject(); <br> <br>    // Note that you can insert past the END of an array (appending to it): <br>    _ASSERT("iElem is too large" &amp;&amp; <br>           (iElem &lt;= _cArraySize) ); <br> <br>    if (_cArraySize + cElems &gt; _cAllocSize) <br>    { <br>        // Resize the current array we have: <br>        ULONG cAllocSize = _cAllocSize ? _cAllocSize : 8; <br>        CElem * paArray;                // new array <br> <br>        // Double alloc size until it's big enough.  This will, I suppose, loop <br>        // forever if someone asks to allocate more than 2^31 elements. <br>        _ASSERT(_cArraySize + cElems &lt; MAXLONG); <br>        while (_cArraySize + cElems &gt; cAllocSize) cAllocSize &lt;&lt;= 1; <br> <br>        paArray = (CElem *)CoTaskMemRealloc(_paArray, sizeof(CElem) * cAllocSize); <br> <br>        if (!paArray) <br>        { <br>            hr = E_OUTOFMEMORY; <br>            goto Error; <br>        } <br> <br>        _paArray = paArray; <br>        _cAllocSize = cAllocSize; <br>    } <br> <br> <br>    // Now we have to shift elements to allow space for the new elements: <br>    memmove(_paArray + iElem + cElems,      // dest <br>            _paArray + iElem, <br>            (_cArraySize - iElem) * sizeof(CElem)); <br> <br>    // Call constructors on all new elements: <br>    { <br>        CElem *pTemp;   // index used to call constructors <br> <br>        for (pTemp = _paArray + iElem; <br>             pTemp &lt; _paArray + iElem + cElems; <br>             pTemp++) <br>        { <br>            new (pTemp) CElem; <br>#if DBG == 1 <br>            _cNumElems++; <br>#endif <br>        } <br>    } <br>     <br>    _cArraySize += cElems; <br> <br>Error: <br>    return hr; <br>} <br> <br> <br>//+----------------------------------------------------------------------- <br>// <br>//  Member:    DeleteElems <br>// <br>//  Synopsis:  Deletes a number of elements cElems from the array at <br>//             iElem.  It is the responsibility of the user to make sure <br>//             that the region to be deleted is within the proper bounds <br>//             of the array, although this will be checked during <br>//             debug mode. <br>// <br>//  Arguments: iElem       place to delete first element <br>//             cElems      number of elements to delete <br>// <br>//  Returns:   Returns success. <br>// <br> <br>template&lt;class TYPE&gt; <br>void <br>TSTDArray&lt;TYPE&gt;::DeleteElems(const size_t iElem, const size_t cElems) <br>{ <br>    IsValidObject(); <br> <br>    _ASSERT("Region to delete is too large" &amp;&amp; <br>           (iElem+cElems-1 &lt; _cArraySize) ); <br> <br> <br>    // First we need to call destructors on elements: <br>    { <br>        CElem *pTemp;   // index used to call destructors <br> <br>        for (pTemp = _paArray + iElem; <br>             pTemp &lt; _paArray + iElem + cElems; <br>             pTemp++) <br>        { <br>            pTemp-&gt;CElem::~CElem(); <br>#if DBG == 1 <br>            _cNumElems--; <br>#endif <br>        } <br>    } <br> <br>    // Now we need to shift the remaining elements in: <br>    memmove(_paArray + iElem,                // dest <br>            _paArray + iElem + cElems, <br>            (_cArraySize - (iElem + cElems)) * sizeof(CElem)); <br> <br>    _cArraySize -= cElems; <br>} <br> <br> <br>#endif  // _TARRAY_H_ </code></pre>
<p>&nbsp;</p></body>
</HTML>
