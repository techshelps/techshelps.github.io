<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>TDCARR.H</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3947"></a><sup></sup>TDCARR.H</h2>
<pre><code>//+----------------------------------------------------------------------- <br>// <br>//  TDC Array <br>//  Copyright (C) Microsoft Corporation, 1996, 1997 <br>// <br>//  File:       TDCArr.h <br>// <br>//  Contents:   Declaration of the CTDCArr class. <br>//              This class forms the heart of the Tabular Data Control. <br>//              It provides the core 2D array of variant values, plus <br>//              a (possibly filtered/sorted) view of this data for <br>//              presentation through an ISimpleTabularData interface. <br>// <br>//------------------------------------------------------------------------ <br> <br>// ;begin_internal <br>#ifndef TDC_SKEL <br>// ;end_internal <br>#include "tarray.h" <br> <br>//------------------------------------------------------------------------ <br>// <br>//  CTDCCell <br>// <br>//  This class represents a cell value within the 2D TDC control <br>// <br>//------------------------------------------------------------------------ <br> <br>class CTDCCell : public VARIANT <br>{ <br>public: <br>    CTDCCell() <br>    { <br>        VariantInit(this); <br>    } <br>    ~CTDCCell() <br>    { <br>        clear(); <br>    } <br>    void clear() <br>    { <br>        VariantClear(this); <br>    } <br>}; <br> <br>//------------------------------------------------------------------------ <br>// <br>//  TDCDateFmt <br>// <br>//  This enum represents the 6 meaningful ways to format dates <br>// <br>//------------------------------------------------------------------------ <br>typedef enum <br>{ <br>    TDCDF_NULL, <br>    TDCDF_DMY, <br>    TDCDF_DYM, <br>    TDCDF_MDY, <br>    TDCDF_MYD, <br>    TDCDF_YMD, <br>    TDCDF_YDM, <br>} <br>    TDCDateFmt; <br> <br>//------------------------------------------------------------------------ <br>// <br>//  CTDCColInfo <br>// <br>//  This class represents type/formatting information for a column <br>// <br>//------------------------------------------------------------------------ <br> <br>class CTDCColInfo <br>{ <br>public: <br>    VARTYPE vtType; <br>    TDCDateFmt  datefmt;        //  Format string for dates <br> <br>    CTDCColInfo() <br>    { <br>        vtType = VT_EMPTY; <br>    } <br>}; <br>// ;begin_internal <br>#endif  // TDC_SKEL <br>// ;end_internal <br> <br>//------------------------------------------------------------------------ <br>// <br>//  CTDCSortCriterion <br>// <br>//  This class represents a sorting criterion (sort column and direction) <br>// <br>//------------------------------------------------------------------------ <br> <br>class CTDCSortCriterion <br>{ <br>public: <br>    LONG    m_iSortCol; <br>    boolean m_fSortAscending; <br>    CTDCSortCriterion *m_pNext; <br> <br>    CTDCSortCriterion() <br>    { <br>        m_pNext = NULL; <br>    } <br>    ~CTDCSortCriterion() <br>    { <br>        if (m_pNext != NULL) <br>            delete m_pNext; <br>    } <br>}; <br> <br>//------------------------------------------------------------------------ <br>// <br>//  CTDCFilterNode <br>// <br>//  This class represents a tree node in a filter query. <br>// <br>//------------------------------------------------------------------------ <br> <br>class CTDCFilterNode <br>{ <br>public: <br>    enum NODE_OP <br>    { <br>        NT_AND, <br>        NT_OR, <br>        NT_EQ, <br>        NT_NE, <br>        NT_LT, <br>        NT_GT, <br>        NT_LE, <br>        NT_GE, <br>        NT_ATOM, <br>        NT_NULL, <br>    }; <br>    NODE_OP        m_type; <br>    CTDCFilterNode *m_pLeft;    // NT_AND ... NT_GE <br>    CTDCFilterNode *m_pRight;   // NT_AND ... NT_GE <br>    LONG           m_iCol;      // NT_ATOM, +ve column #, 0 means fixed value <br>    VARIANT        m_value;     // NT_ATOM, m_iCol == 0: optional fixed value <br>    VARTYPE        m_vt;        // NT_EQ ... NT_ATOM - type of comparison/atom <br>    boolean        m_fWildcard; // True for string literals with '*' wildcard <br> <br>    CTDCFilterNode() <br>    { <br>        m_type = NT_NULL; <br>        m_pLeft = NULL; <br>        m_pRight = NULL; <br>        m_iCol = 0; <br>        m_vt = VT_EMPTY; <br>        VariantInit(&amp;m_value); <br>    } <br>    ~CTDCFilterNode() <br>    { <br>        if (m_pLeft != NULL) <br>            delete m_pLeft; <br>        if (m_pRight != NULL) <br>            delete m_pRight; <br>        VariantClear(&amp;m_value); <br>    } <br>}; <br> <br>class CEventBroker; <br> <br>//------------------------------------------------------------------------ <br>// <br>//  CTDCArr <br>// <br>//------------------------------------------------------------------------ <br> <br>class CTDCArr : public OLEDBSimpleProvider, <br>                public CTDCFieldSink <br>{ <br>public: <br>    STDMETHOD(QueryInterface)   (REFIID, LPVOID FAR*); <br>    STDMETHOD_(ULONG,AddRef)    (THIS); <br>    STDMETHOD_(ULONG,Release)   (THIS); <br> <br>    CTDCArr(); <br>    STDMETHOD(Init)(CEventBroker *pEventBroker, IMultiLanguage *pML); <br> <br>    //  CTDCFieldSink methods <br>    // <br>    STDMETHOD(AddField)(LPWCH pwch, DWORD dwSize); <br>    STDMETHOD(EOLN)(); <br>    STDMETHOD(EOF)(); <br> <br>    //  TDC control methods <br>    // <br>    STDMETHOD(StartDataLoad)(boolean fUseHeader, <br>                             BSTR bstrSortExpr, BSTR bstrFilterExpr, LCID lcid, <br>                             CComObject&lt;CMyBindStatusCallback&lt;CTDCCtl&gt; &gt; *pBSC, <br>                             boolean fAppend, boolean fCaseSensitive); <br>    STDMETHOD(SetSortFilterCriteria)(BSTR bstrSortExpr, BSTR bstrFilterExpr, <br>                                    boolean fCaseSensitive); <br> <br>    //  OLEDBSimpleProvider methods <br>    // <br>    STDMETHOD(getRowCount)(LONG *pcRows); <br>    STDMETHOD(getColumnCount)(LONG *pcCols); <br>    STDMETHOD(getRWStatus)(LONG iRow, LONG iCol, OSPRW *prwStatus); <br>    STDMETHOD(getVariant)(LONG iRow, LONG iCol, OSPFORMAT format, VARIANT *pVar); <br>    STDMETHOD(setVariant)(LONG iRow, LONG iCol, OSPFORMAT format, VARIANT Var); <br>    STDMETHOD(getLocale)(BSTR *pbstrLocale); <br>    STDMETHOD(deleteRows)(LONG iRow, LONG cRows, LONG *pcRowsDeleted); <br>    STDMETHOD(insertRows)(LONG iRow, LONG cRows, LONG *pcRowsInserted); <br>    STDMETHOD(find) (LONG iRowStart, LONG iCol, VARIANT val, <br>            OSPFIND findFlags, OSPCOMP compType, LONG *piRowFound); <br>    STDMETHOD(addOLEDBSimpleProviderListener)(OLEDBSimpleProviderListener *pospIListener); <br>    STDMETHOD(removeOLEDBSimpleProviderListener)(OLEDBSimpleProviderListener *pospIListener); <br>    STDMETHOD(getEstimatedRows)(LONG *pcRows);     <br>    STDMETHOD(isAsync)(BOOL *pbAsync); <br>    STDMETHOD(stopTransfer)(); <br>// ;begin_internal <br>    STDMETHOD(DeleteColumns)(LONG iCol, LONG cCols, LONG *pcColsDeleted); <br>    STDMETHOD(InsertColumns)(LONG iCol, LONG cCols, LONG *pcColsInserted); <br>// ;end_internal <br> <br>    //  This member is used during a sort operation <br>    // <br>    int SortComp(LONG iRow1, LONG iRow2); <br> <br>    enum LOAD_STATE <br>    { <br>        LS_UNINITIALISED, <br>        LS_LOADING_HEADER_UNAVAILABLE, <br>        LS_LOADING_HEADER_AVAILABLE, <br>        LS_LOADED, <br>    }; <br>    LOAD_STATE  GetLoadState()  { return m_state; } <br>    void SetIsAsync(BOOL fAsync) { m_fAsync = fAsync; } <br>    CEventBroker    *m_pEventBroker; <br>    IMultiLanguage  *m_pML; <br> <br>private: <br> <br> <br>    ULONG       m_cRef;         // interface reference count <br>    LOAD_STATE  m_state; <br>    LCID        m_lcid;         // Default user LCID <br>    LCID        m_lcidRead;     // User LCID corresponding to LANGUAGE property <br> <br>    ~CTDCArr(); <br> <br>// ;begin_internal <br>#ifndef TDC_SKEL <br>// ;end_internal <br>    boolean     m_fSortFilterDisrupted; <br>    STDMETHOD(ApplySortFilterCriteria)(); <br> <br>    //  These members are used during a sort operation <br>    // <br>    CTDCSortCriterion   *m_pSortList; <br>    BSTR                m_bstrSortExpr; <br>    HRESULT CreateSortList(BSTR bstrSortCols); <br> <br>    //  These members are used during a filter operation <br>    // <br>    CTDCFilterNode  *m_pFilterTree; <br>    BSTR            m_bstrFilterExpr; <br>    boolean EvalDataRow(LONG iRow, CTDCFilterNode *pNode); <br>    CTDCFilterNode *FilterParseComplex(LPWCH *ppwch, HRESULT *phr); <br>    CTDCFilterNode *FilterParseSimple(LPWCH *ppwch, HRESULT *phr); <br>    CTDCFilterNode *FilterParseAtom(LPWCH *ppwch, HRESULT *phr); <br>    LONG    m_fLastFilter; <br>// ;begin_internal <br>#endif // TDC_SKEL <br>// ;end_internal <br> <br>    //  These members are used during a load <br>    // <br>    boolean m_fUseHeader; <br>    boolean m_fSkipRow; <br>    LONG    m_iCurrRow; <br>    LONG    m_iCurrCol; <br> <br>    LONG    m_iDataRows; <br>    LONG    m_iFilterRows; <br>    LONG    m_iCols; <br>    boolean m_fCaseSensitive; <br> <br>    BOOL    m_fAsync;                   // TRUE iff Async <br> <br>    //  These methods and members form the internal array implementation <br>    // <br>    inline boolean fValidDataRow(LONG iRow); <br>    inline boolean fValidFilterRow(LONG iRow); <br>    inline boolean fValidCol(LONG iCol); <br>    inline boolean fValidDataCell(LONG iRow, LONG iCol); <br>    inline boolean fValidFilterCell(LONG iRow, LONG iCol); <br>    inline CTDCCell *GetDataCell(LONG iRow, LONG iCol); <br>    inline CTDCCell *GetFilterCell(LONG iRow, LONG iCol); <br>    inline CTDCColInfo *GetColInfo(LONG iCol); <br>    LONG CalcDataRows(); <br>    LONG CalcFilterRows(); <br>    LONG CalcCols(); <br> <br>    TSTDArray&lt;TSTDArray&lt;CTDCCell&gt; *&gt;   m_arrparrCells; <br>    TSTDArray&lt;TSTDArray&lt;CTDCCell&gt; *&gt;   m_arrparrFilter; <br>    TSTDArray&lt;CTDCColInfo&gt;             m_arrColInfo; <br> <br>    //  Misc internal methods <br>    // <br>    LONG    FindCol(BSTR bstrColName); <br>    HRESULT GetVariantBSTR(VARIANT *pv, BSTR *pbstr, boolean *pfAllocated); <br>    void    RenumberColumnHeadings(); <br>    HRESULT CreateNumberedColumnHeadings(); <br>    HRESULT ParseColumnHeadings(); <br>    HRESULT VariantFromBSTR(VARIANT *pv, BSTR bstr, CTDCColInfo *pColInfo, LCID); <br>    int VariantComp(VARIANT *pVar1, VARIANT *pVar2, VARTYPE type, <br>                    boolean fCaseSensitive); <br>    int InsertionSortHelper(int iRow); <br>}; <br> <br>inline boolean CTDCArr::fValidDataRow(LONG iRow) <br>{ <br>    return iRow &gt;= 0 &amp;&amp; iRow &lt;= m_iDataRows; <br>} <br> <br>inline boolean CTDCArr::fValidFilterRow(LONG iRow) <br>{ <br>    return iRow &gt;= 0 &amp;&amp; iRow &lt;= m_iFilterRows; <br>} <br> <br>inline boolean CTDCArr::fValidCol(LONG iCol) <br>{ <br>    return iCol &gt;= 1 &amp;&amp; iCol &lt;= m_iCols; <br>} <br> <br>inline boolean CTDCArr::fValidDataCell(LONG iRow, LONG iCol) <br>{ <br>    return fValidDataRow(iRow) &amp;&amp; fValidCol(iCol); <br>} <br> <br>inline boolean CTDCArr::fValidFilterCell(LONG iRow, LONG iCol) <br>{ <br>    return fValidFilterRow(iRow) &amp;&amp; fValidCol(iCol); <br>} <br> <br>// ;begin_internal <br>#ifndef TDC_SKEL <br>// ;end_internal <br>inline CTDCCell *CTDCArr::GetDataCell(LONG iRow, LONG iCol) <br>{ <br>    return &amp;((*m_arrparrCells[iRow])[iCol - 1]); <br>} <br> <br>inline CTDCColInfo *CTDCArr::GetColInfo(LONG iCol) <br>{ <br>    return &amp;m_arrColInfo[iCol - 1]; <br>} <br> <br>inline CTDCCell *CTDCArr::GetFilterCell(LONG iRow, LONG iCol) <br>{ <br>    return &amp;((*m_arrparrFilter[iRow])[iCol - 1]); <br>} <br>// ;begin_internal <br>#endif  // TDC_SKEL <br>// ;end_internal </code></pre>
<p>&nbsp;</p></body>
</HTML>
