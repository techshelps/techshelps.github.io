<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>TDCPARSE.H</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3952"></a>TDCPARSE.H</h2>
<pre><code>//------------------------------------------------------------------------ <br>// <br>//  Tabular Data Control Parse Module <br>//  Copyright (C) Microsoft Corporation, 1996, 1997 <br>// <br>//  File:       TDCParse.h <br>// <br>//  Contents:   Declaration of the TDC parser classes. <br>// <br>//  The intent of these classes once was to create a pipeline. <br>// <br>// <br>//          | <br>//          |       Wide-character stream <br>//          |       ~~~~~~~~~~~~~~~~~~~~~ <br>//         \|/ <br>//  ------------------------ <br>//  | CTDCTokenise object  | Created with field &amp; row delimiters, quote &amp; <br>//  |   AddWcharBuffer()   |     escape characters <br>//  ------------------------ <br>//          | <br>//          |       Stream of &lt;field&gt;, &lt;eoln&gt; and &lt;eof&gt; tokens <br>//          |       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ <br>//         \|/ <br>//  ------------------------ <br>//  | CTDCFieldSink object | Abstract class, e.g. STD object created with <br>//  |   AddField()         |     sort/filter criteria &amp; fUseHeader flag <br>//  |   EOLN()             |     to interpret the sequence of fields. <br>//  |   EOF()              | <br>//  ------------------------ <br>// <br>//------------------------------------------------------------------------ <br> <br>#define DEFAULT_FIELD_DELIM L"," <br>#define DEFAULT_ROW_DELIM   L"\n" <br>#define DEFAULT_QUOTE_CHAR  L"\"" <br> <br>#define UNICODE_CP          1200        // Win32's Unicode codepage <br>#define UNICODE_REVERSE_CP  1201        // Byte-swapped Unicode codepage <br> <br>#define ALLOW_DOMAIN_STRING L"@!allow_domains" <br> <br>//------------------------------------------------------------------------ <br>// <br>//  Class:  CTDCFieldSink <br>// <br>//  This class accumulates a sequence of &lt;fields&gt; and &lt;eoln&gt; tokens <br>//  into a 2-D array. <br>// <br>//  An admissible calling sequence on this object is: <br>//   * 0 or more calls to AddField() or EOLN() <br>//   * 1 call to EOF() <br>// <br>//------------------------------------------------------------------------ <br> <br>class CTDCFieldSink <br>{ <br>public: <br>    STDMETHOD(AddField)(LPWCH pwch, DWORD dwSize) PURE; <br>    STDMETHOD(EOLN)() PURE; <br>    STDMETHOD(EOF)() PURE; <br>}; <br> <br>//------------------------------------------------------------------------ <br>// <br>//  Class: CTDCUnify <br>// <br>//  This class takes a series of byte buffers and breaks them up into <br>//  UNICODE buffers. <br>//  The resulting buffers are passed to a CTDCTokenise object. <br>// <br>//  An admissible calling sequence on this object is: <br>//   * Exactly 1 call to Create() <br>//   * 0 or more calls to AddByteBuffer() with a non-zero-sized buffer <br>//   * Exactly 1 call to AddByteBuffer() with a zero-sized buffer <br>// <br>//  Calls to query the characteristics of the parsed data are allowed <br>//  after the call to Create(), but are only meaningful after a <br>//  reasonable amount of data has been collected. <br>//   <br>// <br>//  Caveats: <br>//  ~~~~~~~ <br>//  The class characterises the input stream as ASCII/UNICODE/COMPOSITE <br>//  based on the buffer passed in the initial call to AddByteBuffer(). <br>//  If this buffer is too small, the class may make an incorrect <br>//  characterisation. <br>// <br>//------------------------------------------------------------------------ <br> <br>class CTDCUnify <br>{ <br>public: <br>    CTDCUnify(); <br>    ~CTDCUnify(); <br>    HRESULT Create(UINT nCodePage, IMultiLanguage *pML); <br>    HRESULT ConvertByteBuffer(BYTE *pBytes, DWORD dwSize); <br>    HRESULT InitTokenizer(CTDCFieldSink *pFieldSink, <br>                          WCHAR wchDelimField, <br>                          WCHAR wchDelimRow, <br>                          WCHAR wchQuote, <br>                          WCHAR wchEscape);     <br>    HRESULT AddWcharBuffer(BOOL fAtEnd); <br>    int IsUnicode(BYTE * pBytes, DWORD dwSize); <br>    enum ALLOWDOMAINLIST <br>    { <br>        ALLOW_DOMAINLIST_YES, <br>        ALLOW_DOMAINLIST_NO, <br>        ALLOW_DOMAINLIST_DONTKNOW <br>    }; <br> <br>    ALLOWDOMAINLIST CheckForAllowDomainList(); <br>    HRESULT MatchAllowDomainList(LPCWSTR pwzURL); <br> <br>private: <br>    CTDCFieldSink *m_pFieldSink; <br>    WCHAR m_wchDelimField; <br>    WCHAR m_wchDelimRow; <br>    WCHAR m_wchQuote; <br>    WCHAR m_wchEscape; <br>    WCHAR m_ucParsed; <br> <br>    boolean m_fEscapeActive; <br>    boolean m_fQuoteActive; <br>    boolean m_fIgnoreNextLF; <br>    boolean m_fIgnoreNextCR; <br>    boolean m_fIgnoreNextWhiteSpace; <br>    boolean m_fFoldCRLF; <br>    boolean m_fFoldWhiteSpace; <br> <br>    UINT            m_nCodePage; <br>    UINT            m_nUnicode; <br>    boolean         m_fDataMarkedUnicode; <br>    boolean         m_fDataIsUnicode; <br>    boolean         m_fCanConvertToUnicode; <br>    DWORD           m_dwBytesProcessed; <br>    DWORD           m_dwConvertMode; <br> <br>    BYTE            *m_psByteBuf; <br>    ULONG           m_ucByteBufSize; <br>    ULONG           m_ucByteBufCount; <br> <br>    WCHAR           *m_psWcharBuf; <br>    ULONG           m_ucWcharBufSize; <br>    ULONG           m_ucWcharBufCount; <br> <br>    IMultiLanguage *m_pML; <br>}; </code></pre>
<p>&nbsp;</p></body>
</HTML>
