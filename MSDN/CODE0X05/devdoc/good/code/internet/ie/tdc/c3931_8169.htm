<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>TDCPARSE.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3951"></a><sup></sup>TDCPARSE.CPP</h2>
<pre><code>//------------------------------------------------------------------------ <br>// <br>//  Tabular Data Control Parsing Module <br>//  Copyright (C) Microsoft Corporation, 1996, 1997 <br>// <br>//  File:       TDCParse.cpp <br>// <br>//  Contents:   Implementation of CTDCParse classes. <br>// <br>//------------------------------------------------------------------------ <br> <br> <br>#include "stdafx.h" <br>#include "STD.h" <br>#include "TDC.h" <br>#include &lt;MLang.h&gt; <br>#include "Notify.h" <br>#include "TDCParse.h" <br>#include "TDCArr.h" <br>#include "locale.h" <br>#include "wch.h" <br> <br>#define BYTE_ORDER_MARK 0xFEFF <br>#define REVERSE_BYTE_ORDER_MARK 0xFFFE <br> <br>//------------------------------------------------------------------------ <br>// <br>//  Function:   IsSpace() <br>// <br>//  Synopsis:   Returns TRUE if the given character is a space or tab character. <br>// <br>//  Arguments:  ch            Character to test. <br>// <br>//  Returns:    TRUE if 'ch' is a space or tab character. <br>//              FALSE otherwise. <br>// <br>//------------------------------------------------------------------------ <br> <br>inline boolean IsSpace(WCHAR ch) <br>{ <br>    return (ch == L' ' || ch == L'\t'); <br>} <br> <br>////////////////////////////////////////////////////////////////////////// <br>// <br>//        CTDCTokenise Class - see comments in file TDCParse.h <br>//        ------------------ <br>////////////////////////////////////////////////////////////////////////// <br> <br> <br>//------------------------------------------------------------------------ <br>// <br>//  Method:     CTDCTokenise::Create() <br>// <br>//  Synopsis:   Initialise the CTDCTokenise object <br>// <br>//  Arguments:  pFieldSink         Object to send parsed fields to. <br>//              wchDelimField      \ <br>//              wchDelimRow         |  Set of characters that control <br>//              wchQuote            |  the parsing of fields <br>//              wchEscape          / <br>// <br>//  Returns:    S_OK indicating success. <br>// <br>//------------------------------------------------------------------------ <br> <br>HRESULT CTDCUnify::InitTokenizer(CTDCFieldSink *pFieldSink, WCHAR wchDelimField, <br>                                 WCHAR wchDelimRow, WCHAR wchQuote, WCHAR wchEscape) <br>{ <br>    _ASSERT(pFieldSink != NULL); <br>    m_pFieldSink = pFieldSink; <br>    m_wchDelimField = wchDelimField; <br>    m_wchDelimRow = wchDelimRow; <br>    m_wchQuote = wchQuote; <br>    m_wchEscape = wchEscape; <br>    m_ucParsed = 0; <br> <br>    m_fIgnoreNextLF = FALSE; <br>    m_fIgnoreNextCR = FALSE; <br>    m_fIgnoreNextWhiteSpace = FALSE; <br>    m_fEscapeActive = FALSE; <br>    m_fQuoteActive = FALSE; <br>    m_fFoldWhiteSpace = FALSE; <br> <br>    //  Ensure that the field and row delimiters are set. <br>    // <br>    if (m_wchDelimRow == 0) <br>        m_wchDelimRow = DEFAULT_ROW_DELIM[0]; <br> <br>    //  Remove conflicting delimiter values <br>    // <br>    if (m_wchDelimRow == m_wchDelimField) <br>        m_wchDelimRow = 0; <br>    if (m_wchQuote != 0) <br>    { <br>        if (m_wchQuote == m_wchDelimField || m_wchQuote == m_wchDelimRow) <br>            m_wchQuote = 0; <br>    } <br>    if (m_wchEscape != 0) <br>    { <br>        if (m_wchEscape == m_wchDelimField || <br>            m_wchEscape == m_wchDelimRow || <br>            m_wchEscape == m_wchQuote) <br>            m_wchEscape = 0; <br>    } <br> <br>    m_fFoldCRLF = (m_wchDelimRow == L'\r' || m_wchDelimRow == L'\n'); <br> <br>    return S_OK; <br>} <br> <br>//------------------------------------------------------------------------ <br>// <br>//  Method:     CTDCTokenise::AddWcharBuffer() <br>// <br>//  Synopsis:   Takes a buffer of characters, breaks it up into fields <br>//              and passes them to the embedded CTDCFieldSink object <br>//              as fields. <br>// <br>//  Arguments:  pwch               Buffer containing characters to be parsed. <br>//              dwSize             Number of significant characters in 'pwch' <br>//                                  dwSize == 0 means "End-of-stream" <br>// <br>//  Returns:    S_OK upon success. <br>//              E_OUTOFMEMORY indicating insufficient memory to carry <br>//                out the parse operation. <br>//              Other misc error code upon failure. <br>// <br>//------------------------------------------------------------------------ <br> <br>HRESULT CTDCUnify::AddWcharBuffer(BOOL fLastData) <br>{ <br> <br>    OutputDebugStringX(_T("CTDCTokenise::AddWcharBuffer called\n")); <br> <br>    _ASSERT(m_pFieldSink != NULL); <br> <br>    HRESULT hr = S_OK; <br> <br>    LPWCH   pwchCurr;   //  Next character to process <br>    LPWCH   pwchEnd;    //  End-of-buffer marker <br>    LPWCH   pwchDest;   //  Where to write next char processed <br>    LPWCH   pwchStart;  //  Beginning of current token <br> <br>    pwchStart = &amp;m_psWcharBuf[0]; <br>    pwchCurr = pwchStart + m_ucParsed; <br>    pwchDest = pwchCurr; <br>    pwchEnd = &amp;m_psWcharBuf[m_ucWcharBufCount]; <br> <br>    //  Read up to the next field boundary (field or row delimiter) <br>    // <br>    while (pwchCurr &lt; pwchEnd) <br>    { <br>        if (m_fIgnoreNextLF) <br>        { <br>            //  We're expecting a LF to terminate a CR-LF sequence. <br>            // <br>            m_fIgnoreNextLF = FALSE; <br>            if (*pwchCurr == L'\n') <br>            { <br>                //  Found a LF - ignore it <br>                // <br>                pwchCurr++; <br>                continue; <br>            } <br> <br>            //  Found something else - carry on ... <br>            // <br>        } <br> <br>        if (m_fIgnoreNextCR) <br>        { <br>            //  We're expecting a CR to terminate a LF-CR sequence. <br>            // <br>            m_fIgnoreNextCR = FALSE; <br>            if (*pwchCurr == L'\r') <br>            { <br>                //  Found a CR - ignore it <br>                // <br>                pwchCurr++; <br>                continue; <br>            } <br> <br>            //  Found something else - carry on ... <br>            // <br>        } <br> <br>        if (m_fIgnoreNextWhiteSpace) <br>        { <br>            //  We're expecting the rest of a white-space sequence <br>            // <br>            if (IsSpace(*pwchCurr)) <br>            { <br>                //  Found white-space - ignore it <br>                // <br>                pwchCurr++; <br>                continue; <br>            } <br>            m_fIgnoreNextWhiteSpace = FALSE; <br>        } <br> <br>        //  Escape characters work, even in quoted strings <br>        // <br>        if (m_fEscapeActive) <br>        { <br>            *pwchDest++ = *pwchCurr++; <br>            m_fEscapeActive = FALSE; <br>            continue; <br>        } <br>        if (*pwchCurr == m_wchEscape) <br>        { <br>            pwchCurr++; <br>            m_fEscapeActive = TRUE; <br>            continue; <br>        } <br> <br>        //  Quotes activate/deactivate Field/Row delimiters <br>        // <br>        if (*pwchCurr == m_wchQuote) <br>        { <br>            pwchCurr++; <br>            m_fQuoteActive = !m_fQuoteActive; <br>            continue; <br>        } <br> <br>        if (m_fQuoteActive) <br>        { <br>            *pwchDest++ = *pwchCurr++; <br>            continue; <br>        } <br> <br> <br>        if (*pwchCurr == m_wchDelimField || <br>            (m_fFoldWhiteSpace &amp;&amp; IsSpace(*pwchCurr))) <br>        { <br>            hr = m_pFieldSink-&gt;AddField(pwchStart, pwchDest - pwchStart); <br>            if (!SUCCEEDED(hr)) <br>                goto Cleanup; <br>            pwchCurr++; <br>            if (m_fFoldWhiteSpace &amp;&amp; IsSpace(*pwchCurr)) <br>                m_fIgnoreNextWhiteSpace = TRUE; <br>            pwchStart = &amp;m_psWcharBuf[0]; <br>            pwchDest = pwchStart; <br>            continue; <br>        } <br> <br>        if (*pwchCurr == m_wchDelimRow || <br>            (m_fFoldCRLF &amp;&amp; (*pwchCurr == L'\r' || *pwchCurr == L'\n'))) <br>        { <br>            hr = m_pFieldSink-&gt;AddField(pwchStart, pwchDest - pwchStart); <br>            if (!SUCCEEDED(hr)) <br>                goto Cleanup; <br>            hr = m_pFieldSink-&gt;EOLN(); <br>            if (!SUCCEEDED(hr)) <br>                goto Cleanup; <br>            if (m_fFoldCRLF) <br>            { <br>                m_fIgnoreNextLF = (*pwchCurr == L'\r'); <br>                m_fIgnoreNextCR = (*pwchCurr == L'\n'); <br>            } <br>            pwchCurr++; <br>            pwchStart = &amp;m_psWcharBuf[0]; <br>            pwchDest = pwchStart; <br>            continue; <br>        } <br> <br>        *pwchDest++ = *pwchCurr++; <br>    } <br>     <br>    m_ucWcharBufCount = pwchDest - pwchStart; <br>    m_ucParsed = pwchDest - pwchStart;  // amount we've already parsed <br> <br>    // If this is the last data packet, and there's a fragment left, <br>    // parse it. <br>    if (m_ucWcharBufCount &amp;&amp; fLastData) <br>    { <br>        hr = m_pFieldSink-&gt;AddField(pwchStart, m_ucParsed); <br>        if (!SUCCEEDED(hr)) <br>            goto Cleanup; <br>        m_ucParsed = 0; <br>        hr = m_pFieldSink-&gt;EOLN(); <br>        return hr; <br>    } <br> <br> <br>Cleanup: <br>    return hr; <br>} <br> <br> <br> <br> <br>////////////////////////////////////////////////////////////////////////// <br>// <br>//        CTDCUnify Class - see comments in file TDCParse.h <br>//        --------------- <br>////////////////////////////////////////////////////////////////////////// <br> <br>//------------------------------------------------------------------------ <br>// <br>//  Method:     CTDCUnify::CTDCUnify() <br>// <br>//  Synopsis:   Constuctor <br>// <br>//------------------------------------------------------------------------ <br> <br>CTDCUnify::CTDCUnify() <br>{ <br>    m_pML = NULL; <br>} <br> <br>//------------------------------------------------------------------------ <br>// <br>//  Method:     CTDCUnify::~CTDCUnify() <br>// <br>//  Synopsis:   Destructor <br>// <br>//------------------------------------------------------------------------ <br> <br>CTDCUnify::~CTDCUnify() <br>{ <br>    delete [] m_psByteBuf; <br>    delete [] m_psWcharBuf; <br> <br>    if (m_pML != NULL) <br>        m_pML-&gt;Release(); <br>} <br> <br>//------------------------------------------------------------------------ <br>// <br>//  Method:     CTDCUnify::Create() <br>// <br>//  Synopsis:   Initialise the CTDCUnify object <br>// <br>//  Arguments:  pTokenise         Object to send converted buffers to. <br>//              nCodePage         Code page for ASCII-&gt;Unicode conversions <br>//              pML               MLANG COM object (used for conversions) <br>// <br>//  Returns:    S_OK to indicate success. <br>// <br>//------------------------------------------------------------------------ <br> <br>HRESULT CTDCUnify::Create(UINT nCodePage, IMultiLanguage *pML) <br>{ <br>    m_pML = pML; <br>    m_pML-&gt;AddRef(); <br>    m_nCodePage = nCodePage; <br>    m_fDataMarkedUnicode = FALSE; <br>    m_fDataIsUnicode = FALSE; <br>    m_dwBytesProcessed = 0; <br>    m_fCanConvertToUnicode = 0; <br>    m_nUnicode = 0; <br> <br>    m_dwConvertMode = 0; <br>    m_ucByteBufSize = 0; <br>    m_ucByteBufCount = 0; <br>    m_psByteBuf = NULL; <br> <br>    m_ucWcharBufSize = 0; <br>    m_ucWcharBufCount = 0; <br>    m_psWcharBuf = NULL; <br> <br>    if (m_pML != NULL) <br>    { <br>        HRESULT hr; <br> <br>        hr = m_pML-&gt;IsConvertible(m_nCodePage, UNICODE_CP); <br>        m_fCanConvertToUnicode = SUCCEEDED(hr); <br>    } <br>    return S_OK; <br>} <br> <br>//------------------------------------------------------------------------ <br>// <br>//  Method:     CTDCUnify::IsUnicode <br>// <br>//  Synopsis:   Determines if our text buffer is Unicode or not.  Should <br>//              only be called once on the FIRST text buffer. <br>// <br>//              Assume if the data is marked as Unicode, that it's correct. <br>// <br>//              The determination this routine makes will override any <br>//              single byte codepage the user may have specified. <br>// <br>//               <br>//  Arguments:  pBytes            Buffer containing characters to be converted. <br>//              dwSize            Number of significant characters in 'pBytes' <br>// <br>//  Returns:    Code page of text, or zero if not Unicode (UNICODE_CP, <br>//              UNICODE_REVERSE_CP, or 0) <br>//               <br>// <br>//------------------------------------------------------------------------ <br>int <br>CTDCUnify::IsUnicode(BYTE * pBytes, DWORD dwSize) <br>{ <br>// Document.Write can cause our hosting page to be Unicode, when the TDC <br>// data page might not be.  This can cause some real problems.. <br>    if (UNICODE_CP == m_nCodePage || <br>        UNICODE_REVERSE_CP == m_nCodePage) <br>    { <br>        return m_nCodePage; <br>    } <br> <br>    if (BYTE_ORDER_MARK == *(WCHAR *)pBytes) <br>        return UNICODE_CP; <br> <br>    if (UNICODE_REVERSE_CP == *(WCHAR *)pBytes) <br>        return UNICODE_REVERSE_CP; <br> <br>    else return 0; <br>} <br> <br>//------------------------------------------------------------------------ <br>// <br>//  Method:     CTDCUnify::ConvertByteBuffer() <br>// <br>//  Synopsis:   Converts a byte-buffer into a wide-character stream <br>//              (applying unicode conversions if necessary) and passes <br>//              it to the embedded TDCTokenise object to be broken into <br>//              fields. <br>// <br>//  Arguments:  pBytes            Buffer containing characters to be converted. <br>//              dwSize            Number of significant characters in 'pBytes' <br>//                                  dwSize == 0 means "End-of-stream" <br>// <br>//  Returns:    S_OK upon success. <br>//              OLE_E_CANTCONVERT if a non-unicode buffer can't be <br>//                converted into unicode. <br>//              E_OUTOFMEMORY if there isn't enough memory to perform <br>//                a data conversion. <br>// <br>//------------------------------------------------------------------------ <br> <br>HRESULT CTDCUnify::ConvertByteBuffer(BYTE *pBytes, DWORD dwSize) <br>{ <br>    OutputDebugStringX(_T("CTDCUnify::AddByteBuffer called\n")); <br> <br>    _ASSERT(pBytes != NULL || dwSize == 0); <br> <br>    //  Examine the data to determine if it's in UNICODE format or not. <br>    //  Convert to UNICODE if neccessary. <br>    // <br>    HRESULT     hr = S_OK; <br>    UINT        ucBytes; <br>    UINT        ucWchars; <br> <br>    _ASSERT(pBytes != NULL); <br>    _ASSERT(dwSize &gt; 0); <br> <br>    if (!m_fCanConvertToUnicode) <br>        hr = OLE_E_CANTCONVERT; <br> <br>    // Is there enough space in Byte buffer for this packet? <br>    if (dwSize &gt; (m_ucByteBufSize - m_ucByteBufCount)) <br>    { <br>        // No, the current buffer is too small, make a new one. <br>        BYTE * psTemp = new BYTE[m_ucByteBufCount + dwSize]; <br>        if (psTemp==NULL) <br>        { <br>            hr = E_OUTOFMEMORY; <br>             <br>            goto Done; <br>        } <br> <br>        if (m_psByteBuf != NULL)        // if not first time <br>        { <br>            memmove(psTemp, m_psByteBuf, m_ucByteBufCount); <br>            delete [] m_psByteBuf; <br>        } <br>        m_ucByteBufSize = m_ucByteBufCount + dwSize; <br>        m_psByteBuf = psTemp; <br>    } <br> <br>    // Append the new data to the old data. <br>    memmove(m_psByteBuf + m_ucByteBufCount, pBytes, dwSize); <br>    m_ucByteBufCount += dwSize; <br> <br>    // Is there enough space in the Wchar buffer for the converted data? <br>    // We make a very conservative assumption here that N source buffer bytes <br>    // convert to N Wchar buffer chars (or 2*N bytes).  This will ensure that <br>    // our call to ConvertToUnicode will never not finish because there wasn't <br>    // enough room in the output buffer. <br>    if (dwSize &gt; (m_ucWcharBufSize - m_ucWcharBufCount)) <br>    { <br>        // The current buffer is too small, make a new one. <br>        WCHAR * psTemp = new WCHAR[m_ucWcharBufCount + dwSize]; <br>        if (psTemp==NULL) <br>        { <br>            hr = E_OUTOFMEMORY; <br>            goto Done; <br>        } <br> <br>        if (m_psWcharBuf != NULL)       // if not first time <br>        { <br>            memmove(psTemp, m_psWcharBuf, <br>                    m_ucWcharBufCount*sizeof(WCHAR)); <br>            delete [] m_psWcharBuf; <br>        } <br>        m_psWcharBuf = psTemp; <br>        m_ucWcharBufSize = m_ucWcharBufCount + dwSize; <br>    } <br> <br>    if (0 == m_dwBytesProcessed) <br>    { <br>        // Need at least 2 chars for Unicode signature (0xFFFE or 0xFEFF) <br>        if (m_ucByteBufCount &gt; 1) <br>        { <br>            // If we detect Unicode, it overrides any user specified code page. <br>            m_nUnicode = IsUnicode(m_psByteBuf, m_ucByteBufCount); <br>            m_nCodePage = m_nUnicode ? m_nUnicode : m_nCodePage; <br>        } <br>        else <br>            goto Done;                  // too little to detect anything yet <br>    } <br> <br>    // Convert as many source bytes as we can to Unicode chars <br>    ucBytes = m_ucByteBufCount; <br>    ucWchars = m_ucWcharBufSize - m_ucWcharBufCount; <br> <br>    // ConvertStringToUnicode won't convert Unicode to Unicode for us. <br>    // So we'll do it ourselves. <br>    if (m_nUnicode) <br>    { <br>        _ASSERT( ucWchars * sizeof(WCHAR) &gt;= ucBytes); <br> <br>        // This might copy an odd extra byte <br>        memmove((BYTE *)(m_psWcharBuf + m_ucWcharBufCount), m_psByteBuf, <br>                ucBytes); <br> <br>        // But we only count the number of complete WCHAR's we copied. <br>        ucWchars = ucBytes / sizeof(WCHAR);  <br>        ucBytes = ucWchars * sizeof(WCHAR); <br> <br>        if (UNICODE_REVERSE_CP == m_nUnicode) <br>        { <br>            // need to byte swap <br>            BYTE *pByteSwap = (BYTE *)(m_psWcharBuf + m_ucWcharBufCount); <br>            BYTE bTemp; <br>            for (ULONG i = ucWchars; i != 0; i--) <br>            { <br>                // Well, OK, we've kind of hardwired WCHAR == 2 here, but .. <br>                bTemp = pByteSwap[0]; <br>                pByteSwap[0] = pByteSwap[1]; <br>                pByteSwap[1] = bTemp; <br>                pByteSwap += 2; <br>            } <br>        } <br> <br>        // On first packet, need to remove Unicode signature. <br>        // Only need to look for 0xFFFE -- we already swapped bytes. <br>        if (0 == m_dwBytesProcessed &amp;&amp; m_psWcharBuf[0] == BYTE_ORDER_MARK) <br>        { <br>            ucWchars--; <br>            memmove((BYTE *)m_psWcharBuf, (BYTE *)m_psWcharBuf+2, <br>                   ucWchars*sizeof(ucWchars)); <br>        } <br>    } <br>    else <br>    { <br>        hr = m_pML-&gt;ConvertStringToUnicode(&amp;m_dwConvertMode, m_nCodePage, <br>                                           (char *)m_psByteBuf, &amp;ucBytes, <br>                                           m_psWcharBuf +m_ucWcharBufCount, <br>                                           &amp;ucWchars); <br>    } <br>    // Move any leftover source characters to the start of the buffer. <br>    // These are probably split Unicode chars, lead bytes without trail <br>    // bytes, etc. <br>    m_ucByteBufCount -= ucBytes; <br>    memmove(m_psByteBuf, m_psByteBuf + ucBytes, <br>            m_ucByteBufCount); <br> <br>    // The number of useful chars in the output buf is increased by the <br>    // number we managed to convert. <br>    m_ucWcharBufCount += ucWchars; <br>    m_dwBytesProcessed += ucWchars; <br> <br>Done: <br>    return hr; <br>} <br> <br>LPWCH SkipSpace(LPWCH pwchCurr) <br>{ <br>    while (IsSpace(*pwchCurr)) pwchCurr++; <br>    return pwchCurr; <br>} <br> <br>static <br>boolean IsEnd(WCHAR ch) <br>{ <br>    return (ch == 0 || ch == L'\r' || ch == L'\n'); <br>} <br> <br>static <br>boolean IsBreak(WCHAR ch) <br>{ <br>    return (ch == L';' || IsEnd(ch)); <br>} <br> <br>// Returns FALSE if names didn't match. <br>// Returns TRUE if they did. <br>// Sets *ppwchAdvance to terminator of the match name <br>BOOL <br>MatchName(LPWCH pwchMatchName, LPCWCH pwzHostName, LPWCH *ppwchAdvance) <br>{ <br>    // match from right to left <br>    LPWCH pwchMatchRight = &amp;pwchMatchName[0]; <br>    LPCWCH pwchHostRight = &amp;pwzHostName[0] + ocslen(pwzHostName) -1; <br>                      <br>    // handle empty match name <br>    if (IsBreak(*pwchMatchRight)) <br>    { <br>        if (!IsEnd(*pwchMatchRight))    // be sure to advance (unless at end) <br>            ++ pwchMatchRight; <br>        *ppwchAdvance = pwchMatchRight; <br>        return FALSE; <br>    } <br>     <br>    // Find end of Match name. <br>    while (!IsBreak(*pwchMatchRight)) pwchMatchRight++; <br> <br>    *ppwchAdvance = pwchMatchRight;     // return pointer to terminator <br> <br>    pwchMatchRight--; <br> <br>    while (IsSpace(*pwchMatchRight) &amp;&amp; pwchMatchRight &gt;= pwchMatchName) <br>        -- pwchMatchRight;              // ignore trailing whitespace <br> <br>    // match full wildcard the easy way <br>    if (pwchMatchRight == pwchMatchName &amp;&amp; pwchMatchRight[0] == '*') <br>        return TRUE; <br>     <br>    // match right-to-left, stop at mismatch or beginning of either string <br>    for (; pwchMatchRight&gt;=pwchMatchName &amp;&amp; pwchHostRight&gt;=pwzHostName; <br>            --pwchMatchRight, --pwchHostRight) <br>    { <br>        if (*pwchMatchRight != *pwchHostRight || *pwchMatchRight == '*') <br>            break; <br>    } <br> <br>    // it's a match if strings matched completely <br>    if (pwchMatchRight+1 == pwchMatchName  &amp;&amp;  pwchHostRight+1 == pwzHostName) <br>        return TRUE; <br> <br>    // or if match name started with "*." and the rest matched a suffix of host name <br>    if (pwchMatchRight == pwchMatchName  &amp;&amp;  pwchMatchRight[0] == '*'  &amp;&amp; <br>        pwchMatchRight[1] == '.') <br>        return TRUE; <br> <br>    // otherwise it's not a match <br>    return FALSE; <br>} <br> <br>HRESULT <br>CTDCUnify::MatchAllowDomainList(LPCWSTR pwzURL) <br>{ <br>    HRESULT hr = E_FAIL;                // assume failure <br>    LPWCH pwchCurr = &amp;m_psWcharBuf[0]; <br>    LPWCH pwchCurr2; <br>    int cchHostDoman = ocslen(pwzURL); <br> <br>    // skip over white space <br>    pwchCurr = SkipSpace(pwchCurr); <br>    if (IsEnd(*pwchCurr)) <br>        goto Cleanup; <br> <br>    // must have the equal sign <br>    if (*pwchCurr++ != '=' || *pwchCurr == '\0') <br>        goto Cleanup; <br> <br>    while (TRUE) <br>    { <br>        // skip over white space <br>        pwchCurr = SkipSpace(pwchCurr); <br> <br>        if (IsEnd(*pwchCurr))           // terminate on \r, \n, \0 <br>            break; <br> <br>        if (IsBreak(*pwchCurr))         // Must be ';', <br>            pwchCurr++;                 // skip it. <br> <br>        // skip over white space <br>        pwchCurr = SkipSpace(pwchCurr); <br> <br>        if (MatchName(pwchCurr, pwzURL, &amp;pwchCurr2)) <br>        { <br>            hr = S_OK; <br>            break; <br>        } <br>        pwchCurr = pwchCurr2; <br>    } <br> <br>Cleanup: <br>    while (!IsEnd(*pwchCurr)) <br>        pwchCurr++; <br> <br>    // Skip CRLF combos <br>    if (*pwchCurr == '\r' &amp;&amp; pwchCurr[1] == '\n') pwchCurr++; <br> <br>    // Eat the AllowDomain line so it doesn't screw up the data. <br>    m_ucWcharBufCount -= (pwchCurr+1 - m_psWcharBuf); <br>    memmove(m_psWcharBuf, pwchCurr+1, m_ucWcharBufCount*sizeof(WCHAR)); <br> <br>    return hr; <br>} <br> <br>//------------------------------------------------------------------------ <br>// <br>//  Method:     CTDCUnify::CheckForAllowDomainList <br>// <br>//  Synopsis:   Checks the beggining of the Wide Char buffer to see if it <br>//              contains the string "@!allow.domains".  This is used to <br>//              determine if this file has a list of domain names which are <br>//              allowed to access this file, even though the access may be <br>//              coming from another internet host. <br>// <br>//  Arguments:  uses CTDCUnify state variables for the Wide Char buffer: <br>//              m_psWcharBUf            the Wide char buffer <br>//              m_ucWcharBufCount       the # of chars in the wide char buf <br>// <br>//  Returns:    ALLOW_DOMAINLIST_NO             signature not found <br>//              ALLOW_DOMAINLIST_YES            signature was found <br>//              ALLOW_DOMAINLIST_DONTKNOW       don't have enough characters <br>//                                              to know for sure yet. <br>// <br>//------------------------------------------------------------------------ <br> <br>CTDCUnify::ALLOWDOMAINLIST <br>CTDCUnify::CheckForAllowDomainList() <br>{ <br>    ULONG cAllowDomainLen = ocslen(ALLOW_DOMAIN_STRING); <br> <br>    // Make sure we have a while line. <br>    LPWCH pwchCurr = m_psWcharBuf; <br>    while (!IsEnd(*pwchCurr)) pwchCurr++; <br>    if (*pwchCurr == '\0')              // if buffer ended before line did <br>        return ALLOW_DOMAINLIST_DONTKNOW; <br> <br>    if (0 == wch_incmp(m_psWcharBuf, ALLOW_DOMAIN_STRING, cAllowDomainLen)) <br>    { <br>        // We matched equal and have the whole string. <br>        // Take the "@!allow.domains" out of the buffer.. <br>        m_ucWcharBufCount -= cAllowDomainLen; <br>        memmove(m_psWcharBuf, &amp;m_psWcharBuf[cAllowDomainLen], <br>                m_ucWcharBufCount*sizeof(WCHAR)); <br>        return ALLOW_DOMAINLIST_YES; <br>    } <br> <br>    // We didn't match equal, no point in looking any more. <br>    return ALLOW_DOMAINLIST_NO; <br>} <br> <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
