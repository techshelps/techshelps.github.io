<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>WABOBJECT.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3995"></a>WABOBJECT.CPP</h2>
<pre><code>#include "wabobject.h" <br> <br> <br> <br>enum { <br>    ieidPR_DISPLAY_NAME = 0, <br>    ieidPR_ENTRYID, <br>ieidPR_OBJECT_TYPE, <br>    ieidMax <br>}; <br>static const SizedSPropTagArray(ieidMax, ptaEid)= <br>{ <br>    ieidMax, <br>    { <br>        PR_DISPLAY_NAME, <br>        PR_ENTRYID, <br>PR_OBJECT_TYPE, <br>    } <br>}; <br> <br> <br>enum { <br>    iemailPR_DISPLAY_NAME = 0, <br>    iemailPR_ENTRYID, <br>    iemailPR_EMAIL_ADDRESS, <br>    iemailPR_OBJECT_TYPE, <br>    iemailMax <br>}; <br>static const SizedSPropTagArray(iemailMax, ptaEmail)= <br>{ <br>    iemailMax, <br>    { <br>        PR_DISPLAY_NAME, <br>        PR_ENTRYID, <br>        PR_EMAIL_ADDRESS, <br>        PR_OBJECT_TYPE <br>    } <br>}; <br> <br> <br>/*********************************************************************************/ <br> <br> <br>// contructor for CWAB object <br>// <br>// pszFileName - FileName of WAB file to open <br>//          if no file name is specified, opens the default <br>// <br>CWAB::CWAB(CString * pszFileName) <br>{ <br>    // Here we load the WAB Object and initialize it <br>    m_bInitialized = FALSE; <br>m_lpPropArray = NULL; <br>    m_ulcValues = 0; <br>    m_SB.cb = 0; <br>    m_SB.lpb = NULL; <br> <br>    { <br>        TCHAR  szWABDllPath[MAX_PATH]; <br>        DWORD  dwType = 0; <br>        ULONG  cbData = sizeof(szWABDllPath); <br>        HKEY hKey = NULL; <br> <br>        *szWABDllPath = '\0'; <br>         <br>        // First we look under the default WAB DLL path location in the <br>        // Registry.  <br>        // WAB_DLL_PATH_KEY is defined in wabapi.h <br>        // <br>        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, WAB_DLL_PATH_KEY, 0, KEY_READ, &amp;hKey)) <br>            RegQueryValueEx( hKey, "", NULL, &amp;dwType, (LPBYTE) szWABDllPath, &amp;cbData); <br> <br>        if(hKey) RegCloseKey(hKey); <br> <br>        // if the Registry came up blank, we do a loadlibrary on the wab32.dll <br>        // WAB_DLL_NAME is defined in wabapi.h <br>        // <br>        m_hinstWAB = LoadLibrary( (lstrlen(szWABDllPath)) ? szWABDllPath : WAB_DLL_NAME ); <br>    } <br> <br>    if(m_hinstWAB) <br>    { <br>        // if we loaded the dll, get the entry point  <br>        // <br>        m_lpfnWABOpen = (LPWABOPEN) GetProcAddress(m_hinstWAB, "WABOpen"); <br> <br>        if(m_lpfnWABOpen) <br>        { <br>            HRESULT hr = E_FAIL; <br>            WAB_PARAM wp = {0}; <br>            wp.cbSize = sizeof(WAB_PARAM); <br>            wp.szFileName = (LPTSTR) (LPCTSTR) *pszFileName; <br>         <br>            // if we choose not to pass in a WAB_PARAM object,  <br>            // the default WAB file will be opened up <br>            // <br>            hr = m_lpfnWABOpen(&amp;m_lpAdrBook,&amp;m_lpWABObject,&amp;wp,0); <br> <br>            if(!hr) <br>                m_bInitialized = TRUE; <br>        } <br>    } <br> <br>} <br> <br> <br>// Destructor <br>// <br>CWAB::~CWAB() <br>{ <br>    if(m_SB.lpb) <br>        LocalFree(m_SB.lpb); <br> <br>    if(m_bInitialized) <br>    { <br>        if(m_lpPropArray) <br>            m_lpWABObject-&gt;FreeBuffer(m_lpPropArray); <br> <br>        if(m_lpAdrBook) <br>            m_lpAdrBook-&gt;Release(); <br> <br>        if(m_lpWABObject) <br>            m_lpWABObject-&gt;Release(); <br> <br>        if(m_hinstWAB) <br>            FreeLibrary(m_hinstWAB); <br>    } <br>} <br> <br> <br>// Opens a wab file and puts its contents into the specified list view <br>// <br>HRESULT CWAB::LoadWABContents(CListCtrl * pListView) <br>{ <br>    ULONG ulObjType =   0; <br>LPMAPITABLE lpAB =  NULL; <br>    LPTSTR * lppszArray=NULL; <br>    ULONG cRows =       0; <br>    LPSRowSet lpRow =   NULL; <br>LPSRowSet lpRowAB = NULL; <br>    LPABCONT  lpContainer = NULL; <br>int cNumRows = 0; <br>    int nRows=0; <br> <br>    HRESULT hr = E_FAIL; <br> <br>    ULONG lpcbEID; <br>LPENTRYID lpEID = NULL; <br> <br>    // Get the entryid of the root PAB container <br>    // <br>    hr = m_lpAdrBook-&gt;GetPAB( &amp;lpcbEID, &amp;lpEID); <br> <br>ulObjType = 0; <br> <br>    // Open the root PAB container <br>    // This is where all the WAB contents reside <br>    // <br>    hr = m_lpAdrBook-&gt;OpenEntry(lpcbEID, <br>    (LPENTRYID)lpEID, <br>    NULL, <br>    0, <br>    &amp;ulObjType, <br>    (LPUNKNOWN *)&amp;lpContainer); <br> <br>m_lpWABObject-&gt;FreeBuffer(lpEID); <br> <br>lpEID = NULL; <br> <br>    if(HR_FAILED(hr)) <br>        goto exit; <br> <br>    // Get a contents table of all the contents in the <br>    // WABs root container <br>    // <br>    hr = lpContainer-&gt;GetContentsTable( 0, <br>            &amp;lpAB); <br> <br>    if(HR_FAILED(hr)) <br>        goto exit; <br> <br>    // Order the columns in the ContentsTable to conform to the <br>    // ones we want - which are mainly DisplayName, EntryID and <br>    // ObjectType <br>    // The table is gauranteed to set the columns in the order  <br>    // requested <br>    // <br>hr =lpAB-&gt;SetColumns( (LPSPropTagArray)&amp;ptaEid, 0 ); <br> <br>    if(HR_FAILED(hr)) <br>        goto exit; <br> <br> <br>    // Reset to the beginning of the table <br>    // <br>hr = lpAB-&gt;SeekRow( BOOKMARK_BEGINNING, 0, NULL ); <br> <br>    if(HR_FAILED(hr)) <br>        goto exit; <br> <br>    // Read all the rows of the table one by one <br>    // <br>do { <br> <br>hr = lpAB-&gt;QueryRows(1,0, &amp;lpRowAB); <br> <br>        if(HR_FAILED(hr)) <br>            break; <br> <br>        if(lpRowAB) <br>        { <br>            cNumRows = lpRowAB-&gt;cRows; <br> <br>    if (cNumRows) <br>    { <br>                LPTSTR lpsz = lpRowAB-&gt;aRow[0].lpProps[ieidPR_DISPLAY_NAME].Value.lpszA; <br>                LPENTRYID lpEID = (LPENTRYID) lpRowAB-&gt;aRow[0].lpProps[ieidPR_ENTRYID].Value.bin.lpb; <br>                ULONG cbEID = lpRowAB-&gt;aRow[0].lpProps[ieidPR_ENTRYID].Value.bin.cb; <br> <br>                // There are 2 kinds of objects - the MAPI_MAILUSER contact object <br>                // and the MAPI_DISTLIST contact object <br>                // For the purposes of this sample, we will only consider MAILUSER <br>                // objects <br>                // <br>                if(lpRowAB-&gt;aRow[0].lpProps[ieidPR_OBJECT_TYPE].Value.l == MAPI_MAILUSER) <br>                { <br>                    // We will now take the entry-id of each object and cache it <br>                    // on the listview item representing that object. This enables <br>                    // us to uniquely identify the object later if we need to <br>                    // <br>                    LPSBinary lpSB = NULL; <br> <br>                    m_lpWABObject-&gt;AllocateBuffer(sizeof(SBinary), (LPVOID *) &amp;lpSB); <br>                 <br>                    if(lpSB) <br>                    { <br>                        m_lpWABObject-&gt;AllocateMore(cbEID, lpSB, (LPVOID *) &amp;(lpSB-&gt;lpb)); <br> <br>                        if(!lpSB-&gt;lpb) <br>                        { <br>                            m_lpWABObject-&gt;FreeBuffer(lpSB); <br>                            continue; <br>                        } <br>                     <br>                        CopyMemory(lpSB-&gt;lpb, lpEID, cbEID); <br>                        lpSB-&gt;cb = cbEID; <br> <br>                        LV_ITEM lvi = {0}; <br>                        lvi.mask = LVIF_TEXT | LVIF_PARAM; <br>                        lvi.iItem = pListView-&gt;GetItemCount(); <br>                        lvi.iSubItem = 0; <br>                        lvi.pszText = lpsz; <br>                        lvi.lParam = (LPARAM) lpSB; <br> <br>                        // Now add this item to the list view <br>                        pListView-&gt;InsertItem(&amp;lvi); <br>                    } <br>                } <br>    } <br>    FreeProws(lpRowAB ); <br>        } <br> <br>}while ( SUCCEEDED(hr) &amp;&amp; cNumRows &amp;&amp; lpRowAB)  ; <br> <br>exit: <br> <br>if ( lpContainer ) <br>lpContainer-&gt;Release(); <br> <br>if ( lpAB ) <br>lpAB-&gt;Release(); <br> <br>    return hr; <br>} <br> <br> <br>// Clears the contents of the specified ListView <br>// <br>void CWAB::ClearWABLVContents(CListCtrl * pListView) <br>{ <br>    int i; <br>    int nCount = pListView-&gt;GetItemCount(); <br>     <br>    if(nCount&lt;=0) <br>        return; <br> <br>    for(i=0;i&lt;nCount;i++) <br>    { <br>        LV_ITEM lvi ={0}; <br>        lvi.mask = LVIF_PARAM; <br>        lvi.iItem = i; <br>        lvi.iSubItem = 0; <br>        pListView-&gt;GetItem(&amp;lvi); <br>        if(lvi.lParam) <br>        { <br>            LPSBinary lpSB = (LPSBinary) lvi.lParam; <br>            m_lpWABObject-&gt;FreeBuffer(lpSB); <br>        } <br>    } <br>    pListView-&gt;DeleteAllItems(); <br>} <br> <br> <br> <br>void CWAB::FreeProws(LPSRowSet prows) <br>{ <br>ULONGirow; <br>if (!prows) <br>return; <br>for (irow = 0; irow &lt; prows-&gt;cRows; ++irow) <br>m_lpWABObject-&gt;FreeBuffer(prows-&gt;aRow[irow].lpProps); <br>m_lpWABObject-&gt;FreeBuffer(prows); <br>} <br> <br>// When an item is selected in the listview, we <br>// cache its entry id as a special selected item <br>// <br>void CWAB::SetSelection(CListCtrl * pListView) <br>{ <br> <br>    LV_ITEM lvi = {0}; <br>    // Get the Selected Item from the listview <br>    lvi.mask = LVIF_PARAM; <br>    lvi.iSubItem = 0; <br>    lvi.iItem = pListView-&gt;GetNextItem(-1, LVNI_SELECTED); <br> <br>    if(lvi.iItem == -1) <br>        return; <br> <br>    pListView-&gt;GetItem(&amp;lvi); <br> <br>    if(lvi.lParam) <br>    { <br>        LPSBinary lpSB = (LPSBinary) lvi.lParam; <br>        if(m_SB.lpb) <br>            LocalFree(m_SB.lpb); <br>        m_SB.cb = lpSB-&gt;cb; <br>        m_SB.lpb = (LPBYTE) LocalAlloc(LMEM_ZEROINIT, m_SB.cb); <br>        if(m_SB.lpb) <br>            CopyMemory(m_SB.lpb, lpSB-&gt;lpb, m_SB.cb); <br>        else <br>            m_SB.cb = 0; <br>    }     <br>} <br> <br> <br> <br>// Show details on the selected item <br>// <br>void CWAB::ShowSelectedItemDetails(HWND hWndParent) <br>{ <br>    HRESULT hr = S_OK; <br> <br>    // if we have a specially cached entryid .. <br>    // <br>    if(m_SB.cb &amp;&amp; m_SB.lpb) <br>    { <br>        HWND hWnd = NULL; <br>        LPSBinary lpSB = (LPSBinary) &amp;m_SB; <br>        hr = m_lpAdrBook-&gt;Details(  (LPULONG) &amp;hWnd, <br>        NULL, NULL, <br>    lpSB-&gt;cb, <br>    (LPENTRYID) lpSB-&gt;lpb, <br>    NULL, NULL, <br>    NULL, 0); <br>    } <br>    return; <br>} <br> <br>// Gets a SPropValue array for the selected item <br>// This array contains all the properties for that item <br>// though we could actually get a subset too if we <br>// wanted to <br>// <br>void CWAB::GetSelectedItemPropArray() <br>{ <br>    if(m_SB.lpb &amp;&amp; m_SB.cb) <br>    { <br>        LPMAILUSER lpMailUser = NULL; <br>        LPSBinary lpSB = (LPSBinary) &amp;m_SB; <br>        ULONG ulObjType = 0; <br> <br>        // Open the selected entry  <br>        // <br>        m_lpAdrBook-&gt;OpenEntry(lpSB-&gt;cb, <br>                               (LPENTRYID) lpSB-&gt;lpb, <br>                              NULL,         // interface <br>                              0,            // flags <br>                              &amp;ulObjType, <br>                              (LPUNKNOWN *)&amp;lpMailUser); <br> <br>        if(lpMailUser) <br>        { <br>            // Flush away any old array we might have cached <br>            // <br>            if(m_lpPropArray) <br>                m_lpWABObject-&gt;FreeBuffer(m_lpPropArray); <br>            m_ulcValues = 0; <br> <br>            lpMailUser-&gt;GetProps(NULL, 0, &amp;m_ulcValues, &amp;m_lpPropArray); <br> <br>            lpMailUser-&gt;Release(); <br>        } <br>    } <br>    return; <br>} <br> <br> <br>// Loads the proptags for the selected entry into the <br>// PropTags list box <br>// <br>void CWAB::LoadPropTags(CListBox * pList) <br>{ <br>    if(!m_ulcValues || !m_lpPropArray) <br>        return; <br> <br>    pList-&gt;ResetContent(); <br> <br>    ULONG i; <br>    TCHAR sz[32]; <br>    for(i=0;i&lt;m_ulcValues;i++) <br>    { <br>        wsprintf(sz, "0x%.8x", m_lpPropArray[i].ulPropTag); <br>        pList-&gt;SetItemData(pList-&gt;AddString(sz), m_lpPropArray[i].ulPropTag); <br>    } <br> <br>    pList-&gt;SetCurSel(-1); <br>    pList-&gt;SetCurSel(0); <br>} <br> <br> <br>// Sets the property value, if understandable, into the <br>// given edit box <br>// <br>void CWAB::SetPropString(CEdit * pEdit, ULONG ulPropTag) <br>{ <br>    pEdit-&gt;SetWindowText(""); <br> <br>    if(!m_ulcValues || !m_lpPropArray) <br>        return; <br> <br>    ULONG i; <br> <br>    for(i=0;i&lt;m_ulcValues;i++) <br>    { <br>        if(m_lpPropArray[i].ulPropTag == ulPropTag) <br>        { <br>            switch(PROP_TYPE(ulPropTag)) <br>            { <br>            case PT_TSTRING: <br>                pEdit-&gt;SetWindowText(m_lpPropArray[i].Value.LPSZ); <br>                break; <br>            case PT_MV_TSTRING: <br>                { <br>                    ULONG j; <br>                    LPSPropValue lpProp = &amp;(m_lpPropArray[i]); <br>                    for(j=0;j&lt;lpProp-&gt;Value.MVSZ.cValues;j++) <br>                    { <br>                        pEdit-&gt;ReplaceSel(lpProp-&gt;Value.MVSZ.LPPSZ[j]); <br>                        pEdit-&gt;ReplaceSel("\r\n"); <br>                    } <br>                } <br>                break; <br>            case PT_BINARY: <br>                pEdit-&gt;SetWindowText("Binary data"); <br>                break; <br>            case PT_I2: <br>            case PT_LONG: <br>            case PT_R4: <br>            case PT_DOUBLE: <br>            case PT_BOOLEAN: <br>                { <br>                    TCHAR sz[256]; <br>                    wsprintf(sz,"%d",m_lpPropArray[i].Value.l); <br>                    pEdit-&gt;SetWindowText(sz); <br>                } <br>                break; <br>            default: <br>                pEdit-&gt;SetWindowText("Unrecognized or undisplayable data"); <br>                break; <br>            } <br>            break; <br>        } <br>    } <br> <br>} <br> <br> <br>enum { <br>    icrPR_DEF_CREATE_MAILUSER = 0, <br>    icrPR_DEF_CREATE_DL, <br>    icrMax <br>}; <br> <br>const SizedSPropTagArray(icrMax, ptaCreate)= <br>{ <br>    icrMax, <br>    { <br>        PR_DEF_CREATE_MAILUSER, <br>        PR_DEF_CREATE_DL, <br>    } <br>}; <br> <br> <br>// Gets the WABs default Template ID for MailUsers <br>// or DistLists. These Template IDs are needed for creating <br>// new mailusers and distlists <br>// <br>HRESULT CWAB::HrGetWABTemplateID(ULONG   ulObjectType, <br>                                ULONG * lpcbEID, <br>                                LPENTRYID * lppEID) <br>{ <br>    LPABCONT lpContainer = NULL; <br>    HRESULT hr  = hrSuccess; <br>    SCODE sc = ERROR_SUCCESS; <br>    ULONG ulObjType = 0; <br>    ULONG cbWABEID = 0; <br>    LPENTRYID lpWABEID = NULL; <br>    LPSPropValue lpCreateEIDs = NULL; <br>    LPSPropValue lpNewProps = NULL; <br>    ULONG cNewProps; <br>    ULONG nIndex; <br> <br>    if (    (!m_lpAdrBook) || <br>           ((ulObjectType != MAPI_MAILUSER) &amp;&amp; (ulObjectType != MAPI_DISTLIST)) ) <br>    { <br>        hr = MAPI_E_INVALID_PARAMETER; <br>        goto out; <br>    } <br> <br>    *lpcbEID = 0; <br>    *lppEID = NULL; <br> <br>    if (HR_FAILED(hr = m_lpAdrBook-&gt;GetPAB( &amp;cbWABEID, <br>                                      &amp;lpWABEID))) <br>    { <br>        goto out; <br>    } <br> <br>    if (HR_FAILED(hr = m_lpAdrBook-&gt;OpenEntry(cbWABEID,     // size of EntryID to open <br>                                        lpWABEID,     // EntryID to open <br>                                        NULL,         // interface <br>                                        0,            // flags <br>                                        &amp;ulObjType, <br>                                        (LPUNKNOWN *)&amp;lpContainer))) <br>    { <br>        goto out; <br>    } <br> <br>    // Opened PAB container OK <br> <br>    // Get us the default creation entryids <br>    if (HR_FAILED(hr = lpContainer-&gt;GetProps(   (LPSPropTagArray)&amp;ptaCreate, <br>                                                0, <br>                                                &amp;cNewProps, <br>                                                &amp;lpCreateEIDs)  )   ) <br>    { <br>        goto out; <br>    } <br> <br>    // Validate the properites <br>    if (    lpCreateEIDs[icrPR_DEF_CREATE_MAILUSER].ulPropTag != PR_DEF_CREATE_MAILUSER || <br>            lpCreateEIDs[icrPR_DEF_CREATE_DL].ulPropTag != PR_DEF_CREATE_DL) <br>    { <br>        goto out; <br>    } <br> <br>    if(ulObjectType == MAPI_DISTLIST) <br>        nIndex = icrPR_DEF_CREATE_DL; <br>    else <br>        nIndex = icrPR_DEF_CREATE_MAILUSER; <br> <br>    *lpcbEID = lpCreateEIDs[nIndex].Value.bin.cb; <br> <br>    m_lpWABObject-&gt;AllocateBuffer(*lpcbEID, (LPVOID *) lppEID); <br>     <br>    if (sc != S_OK) <br>    { <br>        hr = MAPI_E_NOT_ENOUGH_MEMORY; <br>        goto out; <br>    } <br>    CopyMemory(*lppEID,lpCreateEIDs[nIndex].Value.bin.lpb,*lpcbEID); <br> <br>out: <br>    if (lpCreateEIDs) <br>        m_lpWABObject-&gt;FreeBuffer(lpCreateEIDs); <br> <br>    if (lpContainer) <br>        lpContainer-&gt;Release(); <br> <br>    if (lpWABEID) <br>        m_lpWABObject-&gt;FreeBuffer(lpWABEID); <br> <br>    return hr; <br>} <br> <br> <br>// Shows the NewEntry dialog to enable creating a new contact in the WAB <br>// <br>HRESULT CWAB::ShowNewEntryDialog(HWND hWndParent) <br>{ <br>ULONG cbEID=0; <br>LPENTRYID lpEID=NULL; <br> <br>    HRESULT hr = hrSuccess; <br>    ULONG cbTplEID = 0; <br>    LPENTRYID lpTplEID = NULL; <br> <br>    // Get the template id which is needed to create the <br>    // new object <br>    // <br>    if(HR_FAILED(hr = HrGetWABTemplateID(   MAPI_MAILUSER, <br>                                            &amp;cbTplEID, <br>                                            &amp;lpTplEID))) <br>    { <br>        goto out; <br>    } <br> <br>    // Display the New Entry dialog to create the new entry <br>    // <br>if (HR_FAILED(hr = m_lpAdrBook-&gt;NewEntry((ULONG) hWndParent, <br>            0, <br>            0,NULL, <br>            cbTplEID,lpTplEID, <br>            &amp;cbEID,&amp;lpEID))) <br>    { <br>        goto out; <br>    } <br> <br>out: <br>    return hr; <br>} <br> <br> <br>// Delete an entry from the WAB <br>// <br>HRESULT CWAB::DeleteEntry() <br>{ <br>HRESULT hr = hrSuccess; <br>    ULONG cbWABEID = 0; <br>    LPENTRYID lpWABEID = NULL; <br>    LPABCONT lpWABCont = NULL; <br>    ULONG ulObjType; <br>    SBinaryArray SBA; <br> <br>    hr = m_lpAdrBook-&gt;GetPAB( &amp;cbWABEID, <br>                              &amp;lpWABEID); <br>    if(HR_FAILED(hr)) <br>        goto out; <br> <br>    hr = m_lpAdrBook-&gt;OpenEntry(  cbWABEID,     // size of EntryID to open <br>                                  lpWABEID,     // EntryID to open <br>                                  NULL,         // interface <br>                                  0,            // flags <br>                                  &amp;ulObjType, <br>                                  (LPUNKNOWN *)&amp;lpWABCont); <br> <br>    if(HR_FAILED(hr)) <br>        goto out; <br> <br>    SBA.cValues = 1; <br>    SBA.lpbin = &amp;m_SB; <br> <br>    hr = lpWABCont-&gt;DeleteEntries((LPENTRYLIST) &amp;SBA, 0); <br> <br>    if(m_lpPropArray) <br>        m_lpWABObject-&gt;FreeBuffer(m_lpPropArray); <br> <br>    m_lpPropArray = NULL; <br>    m_ulcValues = 0; <br> <br>out: <br>    if(lpWABCont) <br>        lpWABCont-&gt;Release(); <br> <br>    if(lpWABEID) <br>        m_lpWABObject-&gt;FreeBuffer(lpWABEID); <br> <br>    return hr; <br>} <br> <br> <br>// Gets the property value for specified String property <br>// <br>BOOL CWAB::GetStringPropVal(HWND hWnd, ULONG ulPropTag, LPTSTR sz, ULONG cbsz) <br>{ <br> <br>    BOOL bRet = FALSE; <br> <br>    if(PROP_TYPE(ulPropTag) != PT_TSTRING) <br>    { <br>        MessageBox(hWnd, "This tool only supports modifying string type props right now", <br>            "Error", MB_OK | MB_ICONINFORMATION); <br>        goto out; <br>    } <br> <br>    ULONG i; <br> <br>    // Since we already cached the proparray for the selected <br>    // item, all we need to do is look in the cached proparray <br>    // for the requested proptag <br>    // <br>    for(i=0;i&lt;m_ulcValues;i++) <br>    { <br>        if(m_lpPropArray[i].ulPropTag == ulPropTag) <br>        { <br>            LPTSTR lp = m_lpPropArray[i].Value.LPSZ; <br>            ULONG nLen = (ULONG) lstrlen(lp); <br>            if(nLen &gt;= cbsz) <br>            { <br>                CopyMemory(sz, lp, cbsz-1); <br>                sz[cbsz-1]='\0'; <br>            } <br>            else  <br>                lstrcpy(sz,lp); <br>            break; <br>        } <br>    } <br> <br>    bRet = TRUE; <br>out: <br>    return bRet; <br>} <br> <br> <br>// Sets a single string property onto a mailuser object <br>// <br>BOOL CWAB::SetSingleStringProp(HWND hWnd, ULONG ulPropTag, LPTSTR sz) <br>{ <br>    SPropValue Prop; <br>    BOOL bRet = FALSE; <br> <br>    if(PROP_TYPE(ulPropTag) != PT_TSTRING) <br>    { <br>        MessageBox(hWnd, "This version of the tool can only set string properties.", <br>            "Error", MB_OK | MB_ICONINFORMATION); <br>        goto out; <br>    } <br> <br>    Prop.ulPropTag = ulPropTag; <br>    Prop.Value.LPSZ = sz; <br> <br>    // Open the cached entry and get a mailuser object <br>    // representing that entry <br>    // <br>    if(m_SB.lpb &amp;&amp; m_SB.cb) <br>    { <br>        LPMAILUSER lpMailUser = NULL; <br>        LPSBinary lpSB = (LPSBinary) &amp;m_SB; <br>        ULONG ulObjType = 0; <br> <br>        // To modify an object, make sure to specify the  <br>        // MAPI_MODIFY flag otherwise the object is always <br>        // opened read-only be default <br>        // <br>        m_lpAdrBook-&gt;OpenEntry(lpSB-&gt;cb, <br>                               (LPENTRYID) lpSB-&gt;lpb, <br>                              NULL,         // interface <br>                              MAPI_MODIFY,            // flags <br>                              &amp;ulObjType, <br>                              (LPUNKNOWN *)&amp;lpMailUser); <br> <br>        if(lpMailUser) <br>        { <br> <br>            // Knock out this prop if it exists so we can overwrite it <br>            // <br>            { <br>                SPropTagArray SPTA; <br>                SPTA.cValues = 1; <br>                SPTA.aulPropTag[0] = ulPropTag; <br> <br>                lpMailUser-&gt;DeleteProps(&amp;SPTA, NULL); <br>            } <br> <br>            // Set the new property on the mailuser <br>            // <br>            if (!HR_FAILED(lpMailUser-&gt;SetProps(1, &amp;Prop, NULL))) <br>            { <br>                // **NOTE** if you dont call SaveChanges, the <br>                // changes are not saved (duh). Also if you didnt <br>                // open the object with the MAPI_MODIFY flag, you <br>                // are likely to get an ACCESS_DENIED error <br>                // <br>                lpMailUser-&gt;SaveChanges(0); <br>                bRet = TRUE; <br>            } <br>            lpMailUser-&gt;Release(); <br>        } <br>    } <br> <br>out: <br> <br>    GetSelectedItemPropArray(); <br>    return bRet; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
