<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SUPERPAD.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3984"></a>SUPERPAD.CPP</h2>
<pre><code>//=------------------------------------------------------------------------= <br>// SuperPad.Cpp <br>//=------------------------------------------------------------------------= <br>// Copyright 1992-1997 Microsoft Corporation.  All Rights Reserved. <br>// <br>// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF <br>// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO <br>// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A <br>// PARTICULAR PURPOSE. <br>//=--------------------------------------------------------------------------= <br>// <br>// Defines the class behaviors for the application. <br>// <br> <br>#include "stdafx.h" <br>#include "superpad.h" <br>#include "mainfrm.h" <br>#include "padview.h" <br>#include "paddoc.h" <br>#include "padframe.h" <br>#include "ipframe.h" <br> <br>#include &lt;locale.h&gt; <br> <br>#include "download.h" <br>#include "urlmon.h" <br>#include "Fileopen.h" <br> <br>BEGIN_MESSAGE_MAP(CTheApp, CWinApp) <br>//{{AFX_MSG_MAP(CTheApp) <br>ON_COMMAND(ID_APP_ABOUT, OnAppAbout) <br>ON_COMMAND(ID_PAGE_SETUP, OnPageSetup) <br>ON_COMMAND(ID_FILE_OPEN, OnFileOpen) <br>//}}AFX_MSG_MAP <br>// Standard file based document commands <br>ON_COMMAND(ID_FILE_NEW, CWinApp::OnFileNew) <br>ON_COMMAND(ID_FILE_OPEN, CWinApp::OnFileOpen) <br>ON_COMMAND(ID_FILE_PRINT_SETUP, CWinApp::OnFilePrintSetup) <br>END_MESSAGE_MAP() <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// Superpad global data <br> <br>CTheApp NEAR theApp; <br> <br>// this is the GUID for OCLIENT documents <br>static const GUID BASED_CODE clsid = <br>{ 0x00021844, 0, 0, { 0xC0, 0, 0, 0, 0, 0, 0, 0x46 } }; <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// CTheApp initialization <br> <br>CTheApp::CTheApp() <br>{ <br>// initialize locale to system default <br>_tsetlocale(LC_ALL, _T("")); <br>} <br> <br>BOOL CTheApp::InitInstance() <br>{ <br>// initialized OLE 2.0 libraries <br>if (!AfxOleInit()) <br>{ <br>AfxMessageBox(IDP_OLE_INIT_FAILED); <br>return FALSE; <br>} <br> <br>// initialization that must be done before splash dialog is shown <br>Enable3dControls(); <br>CPadFrame::Initialize(); <br> <br>// add doc template <br>CDocTemplate* pDocTemplate; <br>pDocTemplate = new CMultiDocTemplate(IDR_TEXTTYPE, <br>RUNTIME_CLASS(CPadDoc), <br>RUNTIME_CLASS(CPadFrame), <br>RUNTIME_CLASS(CPadView)); <br>pDocTemplate-&gt;SetServerInfo( <br>IDR_TEXTTYPE_EMBEDDED, IDR_TEXTTYPE_INPLACE, <br>RUNTIME_CLASS(CInPlaceFrame)); <br>AddDocTemplate(pDocTemplate); <br> <br>// connect the server to the document template <br>m_server.ConnectTemplate(clsid, pDocTemplate, FALSE); <br> <br>// create main window <br>CMainFrame* pMainFrame = new CMainFrame; <br>if (!pMainFrame-&gt;LoadFrame(IDR_MAINFRAME)) <br>return FALSE; <br>m_pMainWnd = pMainFrame; <br>int nCmdShow = m_nCmdShow; <br> <br>// Parse command line for standard shell commands, DDE, file open <br>CCommandLineInfo cmdInfo; <br>ParseCommandLine(cmdInfo); <br> <br>// setup main window <br>nCmdShow = !cmdInfo.m_bRunEmbedded ? m_nCmdShow : SW_HIDE; <br>m_nCmdShow = SW_HIDE; <br>((CMainFrame*)m_pMainWnd)-&gt;InitialShowWindow(nCmdShow); <br> <br>if (!cmdInfo.m_bRunEmbedded) <br>{ <br>m_pMainWnd-&gt;UpdateWindow(); <br> <br>if (!m_pMainWnd-&gt;IsIconic() &amp;&amp; cmdInfo.m_bShowSplash &amp;&amp; <br>m_splash.Create(m_pMainWnd)) <br>{ <br>m_splash.ShowWindow(SW_SHOW); <br>m_splash.UpdateWindow(); <br>m_splash.SetTimer(1, 500, NULL); <br>} <br>m_dwSplashTime = ::GetCurrentTime(); <br> <br>// update the registry now that the splash dialog is visible <br>m_server.UpdateRegistry(); <br>RegisterShellFileTypes(TRUE); <br>} <br> <br>// do other initialization after (possibly) creating the splash window <br>EnableShellOpen(); <br>m_pMainWnd-&gt;DragAcceptFiles(); <br> <br>LoadStdProfileSettings(); <br>CPadView::Initialize(); <br>dlgPageSetup.Initialize(); <br> <br>// register any class objects we may have (for automation &amp; OLE) <br>COleTemplateServer::RegisterAll(); <br> <br>// open default file if command line doesn't have /Embedding <br>if (!cmdInfo.m_bRunEmbedded) <br>{ <br>// Dispatch commands specified on the command line <br>if (!ProcessShellCommand(cmdInfo)) <br>return FALSE; <br> <br>m_nCmdShow = nCmdShow; <br>m_pMainWnd-&gt;UpdateWindow(); <br>} <br> <br>return TRUE; <br>} <br> <br>BOOL CTheApp::OnIdle(LONG lCount) <br>{ <br>// call base class idle first <br>BOOL bResult = CWinApp::OnIdle(lCount); <br> <br>// then do our work <br>if (m_splash.m_hWnd != NULL) <br>{ <br>if (::GetCurrentTime() - m_dwSplashTime &gt; 2500) <br>{ <br>// timeout expired, destroy the splash window <br>m_splash.DestroyWindow(); <br>m_pMainWnd-&gt;UpdateWindow(); <br> <br>// NOTE: don't set bResult to FALSE, <br>//  CWinApp::OnIdle may have returned TRUE <br>} <br>else <br>{ <br>// check again later... <br>bResult = TRUE; <br>} <br>} <br> <br>return bResult; <br>} <br> <br>BOOL CTheApp::PreTranslateMessage(MSG* pMsg) <br>{ <br>BOOL bResult = CWinApp::PreTranslateMessage(pMsg); <br> <br>if (m_splash.m_hWnd != NULL &amp;&amp; <br>(pMsg-&gt;message == WM_KEYDOWN || <br> pMsg-&gt;message == WM_SYSKEYDOWN || <br> pMsg-&gt;message == WM_LBUTTONDOWN || <br> pMsg-&gt;message == WM_RBUTTONDOWN || <br> pMsg-&gt;message == WM_MBUTTONDOWN || <br> pMsg-&gt;message == WM_NCLBUTTONDOWN || <br> pMsg-&gt;message == WM_NCRBUTTONDOWN || <br> pMsg-&gt;message == WM_NCMBUTTONDOWN)) <br>{ <br>m_splash.DestroyWindow(); <br>m_pMainWnd-&gt;UpdateWindow(); <br>} <br> <br>return bResult; <br>} <br> <br>int CTheApp::ExitInstance() <br>{ <br>dlgPageSetup.Terminate(); <br>CPadView::Terminate(); <br>CPadFrame::Terminate(); <br> <br>return CWinApp::ExitInstance(); <br>} <br> <br>CTheApp::~CTheApp() <br>{ <br>} <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// CTheApp message handlers <br> <br>void CTheApp::OnAppAbout() <br>{ <br>CAboutBox about; <br>about.DoModal(); <br>} <br> <br>CPageSetupDlg NEAR dlgPageSetup; <br>void CTheApp::OnPageSetup() <br>{ <br>dlgPageSetup.DoModal(); <br>} <br> <br>void CTheApp::OnFileOpen()  <br>{ <br>// Prompt the user (with all document templates) <br>CString newName; <br>UINT retval; <br> <br>retval=PromptForFileName(newName, AFX_IDS_OPENFILE,  <br>                   OFN_HIDEREADONLY|OFN_ENABLETEMPLATE|OFN_NOVALIDATE, <br>   TRUE); <br> <br>if (retval==0) <br>return; // open cancelled <br>else <br>if (retval==1)  // If this an ordinary file then just open <br>{ <br>OpenDocumentFile(newName); <br>return; <br>} <br> <br>CWinApp* pApp = AfxGetApp() ; <br>CMainFrame* pFrame = (CMainFrame*)pApp-&gt;m_pMainWnd; <br>CBindStatusCallback *dtfcb= new CBindStatusCallback(pFrame);  <br>if( !dtfcb ) <br>{ <br>// Error to be handled <br>return; <br>} <br> <br>// File to be downloaded to temporary directory <br>static TCHAR count = '1'; <br>CString localfile; <br> <br>LPTSTR tempPath= new CHAR[MAX_PATH]; <br>if (tempPath) <br>{ <br>::GetTempPath(MAX_PATH,tempPath); <br>localfile+=tempPath; <br>delete [] tempPath; <br>} <br> <br>// If we couldn't allocate memory for tempPath then lets create the file locally. <br>// Lets go ahead with downloading of file. <br>// The file is downloaded to [temporary directory]urltmpX.htm [where X is the no of view] <br>localfile+="urltmp"; <br>localfile+=count; <br>localfile+=".htm"; <br>count++; <br> <br>// Do file downlaod <br> HRESULT hr = URLDownloadToFile(0,newName,localfile,0,dtfcb); <br> <br>    // Open the local file. <br>CPadDoc *PPadDoc = (CPadDoc *)OpenDocumentFile(localfile); <br>if (PPadDoc) <br>{ <br>PPadDoc-&gt;m_urlflag=TRUE; <br> <br>CHAR seps[]   = "/\t\n"; <br>CHAR *tokens = strtok((LPTSTR)newName.GetBuffer(_MAX_PATH), seps); <br>CHAR oldtoken[_MAX_PATH];  <br>while (( tokens != NULL )) <br>{ <br>lstrcpy(oldtoken,tokens); <br>tokens = strtok(NULL, seps); <br>} <br>PPadDoc-&gt;m_urlfile=oldtoken; <br>PPadDoc-&gt;SetTitle(oldtoken); // Sort of fooling but better than some cryptic temporary file name. <br>} <br>if (dtfcb) <br>delete dtfcb; <br>} <br> <br>////////////////////////////////////////////////////////////////////////////// <br>// %%Function: CTheApp::PromptForFileName <br>// Puts custom Template and calls the FileOpen Dialog <br>// Return Type specifies whether <br>// 0 : IDCANCEL pressed <br>// 1 : Local File <br>// 2 : URL file <br>// --------------------------------------------------------------------------- <br> <br>UINT <br>CTheApp::PromptForFileName <br>( <br>CString&amp; fileName,//Buffer to return the filename <br>UINT nIDSTitle,//Title String <br>DWORD dwFlags,//Flags for FileOpen Dialog <br>BOOL bOpenFileDialog// Flag specifying whether File Open or File Save <br>) <br>{ <br> <br>CModFileDialog dlgFile(bOpenFileDialog); <br>CString title; <br>VERIFY(title.LoadString(nIDSTitle)); <br>dlgFile.m_ofn.Flags |= dwFlags; <br>dlgFile.m_ofn.lpstrTitle = title; <br>dlgFile.m_ofn.lpstrFile = fileName.GetBuffer(_MAX_PATH); <br>dlgFile.m_ofn.lpTemplateName = MAKEINTRESOURCE(MYFILEOPEN); <br>    dlgFile.m_ofn.Flags &amp;= ~OFN_EXPLORER; <br>dlgFile.m_ofn.hInstance=AfxGetInstanceHandle(); <br>dlgFile.m_ofn.lpstrFilter = "*.*"; <br>dlgFile.m_ofn.lpstrDefExt = "*.*"; <br> <br> <br>UINT bRet =(dlgFile.DoModal() == IDOK) ? 1 : 0; <br>if ((dlgFile.m_urlflag==TRUE)&amp;&amp;(bRet!=0)) <br>bRet=2; <br>fileName.ReleaseBuffer(); <br>return bRet; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
