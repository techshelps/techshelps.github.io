<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>PROGRESS.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3956"></a>PROGRESS.CPP</h2>
<pre><code>// =========================================================================== <br>// File: P R O G R E S S . C P P <br>// <br>// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF <br>// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO <br>// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A <br>// PARTICULAR PURPOSE. <br>// <br>// Description: <br>// <br>//  This sample demonstrates using a URL moniker to download information. <br>// The key routines include the implementation of IBindStatusCallback <br>// and the CDownload::DoDownload routine, which creates and binds to the <br>// URL moniker. <br>// <br>// Instructions: <br>// <br>//  To use this sample: <br>//   * build it using the NMAKE command. NMAKE will create PROGRESS.EXE. <br>//   * run PROGRESS.EXE. specify the resource to download by passing an <br>//     URL on the command-line. use no command-line argument to default to <br>//     downloading "http://www.msn.com". <br>//  * The program displays a dialog box containing information about the <br>//    download: <br>//     - a status message, describing the current status of the download <br>//     - a progress message, describing the amount of information that <br>//       has been downloaded. <br>//     - a text box, which displays chunks of the download information as <br>//       it arrives. <br>//  * Press the "GO" button to begin the download. <br>// <br>// Sample update:- <br>//   * New feature include Progress Bar to indicated progress of the download <br>// * Edit box replaces the old text box. Also the whole file can be viewed.  <br>//     If the file exceeds 32KB then only the first 32 KB from the last data <br>//   pull will be displayed.  If the pull exceeds 32 KB, then only the first <br>//     32 KB of the last Read will be displayed. <br>//  <br>/// <br>// File updated by Jason Strayer 27-Aug-1997 <br>// File updated by Jobi George 19-June-1996 <br>// File updated by Ramesha Gopalakrishna 28-June-1996 <br>// File updated by Oliver Wallace 9-July-1996 <br>// Copyright 1995 - 1998 Microsoft Corporation.  All Rights Reserved. <br>// =========================================================================== <br>#include "urlmon.h" <br>#include "wininet.h" <br>#include "resource.h" <br>#include "commctrl.h" <br> <br>#define EDIT_BOX_LIMIT 0x7FFF    //  The Edit box limit <br> <br>// %%Classes: ---------------------------------------------------------------- <br>class CDownload { <br>  public: <br>    CDownload(LPCWSTR szURL); <br>    ~CDownload(); <br>    HRESULT DoDownload(HWND,HWND,HWND,HWND); <br>    LPCWSTR              m_url; <br> <br>  private: <br>    IMoniker*            m_pmk; <br>    IBindCtx*            m_pbc; <br>    IBindStatusCallback* m_pbsc; <br>}; <br> <br>class CBindStatusCallback : public IBindStatusCallback { <br>  public: <br>    // IUnknown methods <br>    STDMETHODIMP    QueryInterface(REFIID riid,void ** ppv); <br>    STDMETHODIMP_(ULONG)    AddRef()    { return m_cRef++; } <br>    STDMETHODIMP_(ULONG)    Release()   { if (--m_cRef == 0) { delete this; return 0; } return m_cRef; } <br> <br>    // IBindStatusCallback methods <br>    STDMETHODIMP    OnStartBinding(DWORD dwReserved, IBinding* pbinding); <br>    STDMETHODIMP    GetPriority(LONG* pnPriority); <br>    STDMETHODIMP    OnLowResource(DWORD dwReserved); <br>    STDMETHODIMP    OnProgress(ULONG ulProgress, ULONG ulProgressMax, ULONG ulStatusCode, <br>                        LPCWSTR pwzStatusText); <br>    STDMETHODIMP    OnStopBinding(HRESULT hrResult, LPCWSTR szError); <br>    STDMETHODIMP    GetBindInfo(DWORD* pgrfBINDF, BINDINFO* pbindinfo); <br>    STDMETHODIMP    OnDataAvailable(DWORD grfBSCF, DWORD dwSize, FORMATETC *pfmtetc, <br>                        STGMEDIUM* pstgmed); <br>    STDMETHODIMP    OnObjectAvailable(REFIID riid, IUnknown* punk); <br> <br>    // constructors/destructors <br>    CBindStatusCallback(HWND hwndStatus, HWND hwndProgress, HWND hwndText, HWND hwndProgressBar); <br>    ~CBindStatusCallback(); <br> <br>    inline void SetStatus(LPCWSTR szStatus)     { SetWndText(m_hwndStatus, szStatus); } <br>    void SetProgress(LPCWSTR szProgress)        { SetWndText(m_hwndProgress, szProgress); } <br>void SetProgressBar(ULONG cProgress, ULONG maxProgress)  <br>{ <br>// Set the range and increment of the progress bar.  <br>SendMessage(m_hwndProgressBar, PBM_SETRANGE, 0, 100);  <br>        SendMessage(m_hwndProgressBar, PBM_SETPOS, (WPARAM) (maxProgress ? cProgress * 100 / maxProgress : 0), 0); <br>} <br>    void SetWndText(HWND hwnd, LPCWSTR szText); <br> <br>    // data members <br>    DWORD           m_cRef; <br>    IBinding*       m_pbinding; <br>    IStream*        m_pstm; <br>    HWND            m_hwndStatus; <br>    HWND            m_hwndProgress; <br>    HWND            m_hwndText; <br>HWNDm_hwndProgressBar; <br>    DWORD           m_cbOld; <br>}; <br> <br> <br>// =========================================================================== <br>//                     CBindStatusCallback Implementation <br>// =========================================================================== <br> <br>// --------------------------------------------------------------------------- <br>// %%Function: CBindStatusCallback::CBindStatusCallback <br>// --------------------------------------------------------------------------- <br>CBindStatusCallback::CBindStatusCallback(HWND hwndStatus, HWND hwndProgress, HWND hwndText, HWND hwndProgressBar) <br>{ <br>    m_hwndStatus = hwndStatus; <br>    m_hwndProgress = hwndProgress; <br>    m_hwndText = hwndText; <br>m_hwndProgressBar = hwndProgressBar; <br>    m_pbinding = NULL; <br>    m_pstm = NULL; <br>    m_cRef = 1; <br>    m_cbOld = 0; <br>}  // CBindStatusCallback <br> <br>// --------------------------------------------------------------------------- <br>// %%Function: CBindStatusCallback::~CBindStatusCallback <br>// --------------------------------------------------------------------------- <br>CBindStatusCallback::~CBindStatusCallback() <br>{ <br>}  // ~CBindStatusCallback <br> <br>// --------------------------------------------------------------------------- <br>// %%Function: CBindStatusCallback::SetWndText <br>// --------------------------------------------------------------------------- <br> inline void <br>CBindStatusCallback::SetWndText(HWND hwnd,LPCWSTR szText) <br>{ <br>    if (IsWindow(hwnd)) <br>        { <br>        char    rgchBuf[INTERNET_MAX_PATH_LENGTH]; <br>        WideCharToMultiByte(CP_ACP, 0, szText, -1, rgchBuf, INTERNET_MAX_PATH_LENGTH, 0, 0); <br>SetWindowText(hwnd, rgchBuf); <br>} <br>}  // CBindStatusCallback::SetWndText <br> <br>// --------------------------------------------------------------------------- <br>// %%Function: CBindStatusCallback::QueryInterface <br>// --------------------------------------------------------------------------- <br> STDMETHODIMP <br>CBindStatusCallback::QueryInterface(REFIID riid, void** ppv) <br>{ <br>    *ppv = NULL; <br> <br>    if (riid==IID_IUnknown || riid==IID_IBindStatusCallback) <br>        { <br>        *ppv = this; <br>        AddRef(); <br>        return S_OK; <br>        } <br>    return E_NOINTERFACE; <br>}  // CBindStatusCallback::QueryInterface <br> <br>// --------------------------------------------------------------------------- <br>// %%Function: CBindStatusCallback::OnStartBinding <br>// --------------------------------------------------------------------------- <br> STDMETHODIMP <br>CBindStatusCallback::OnStartBinding(DWORD dwReserved, IBinding* pbinding) <br>{ <br>    if (m_pbinding != NULL) <br>        m_pbinding-&gt;Release(); <br>    m_pbinding = pbinding; <br>    if (m_pbinding != NULL) <br>        { <br>        m_pbinding-&gt;AddRef(); <br>        SetStatus(L"Status: Starting to bind..."); <br>        } <br>    return S_OK; <br>}  // CBindStatusCallback::OnStartBinding <br> <br>// --------------------------------------------------------------------------- <br>// %%Function: CBindStatusCallback::GetPriority <br>// --------------------------------------------------------------------------- <br> STDMETHODIMP <br>CBindStatusCallback::GetPriority(LONG* pnPriority) <br>{ <br>return E_NOTIMPL; <br>}  // CBindStatusCallback::GetPriority <br> <br>// --------------------------------------------------------------------------- <br>// %%Function: CBindStatusCallback::OnLowResource <br>// --------------------------------------------------------------------------- <br> STDMETHODIMP <br>CBindStatusCallback::OnLowResource(DWORD dwReserved) <br>{ <br>    return E_NOTIMPL; <br>}  // CBindStatusCallback::OnLowResource <br> <br>// --------------------------------------------------------------------------- <br>// %%Function: CBindStatusCallback::OnProgress <br>// --------------------------------------------------------------------------- <br> STDMETHODIMP <br>CBindStatusCallback::OnProgress(ULONG ulProgress, ULONG ulProgressMax, ULONG ulStatusCode, LPCWSTR szStatusText) <br>{ <br>    char    sz[255]; <br> <br>if(szStatusText!=NULL) <br>    WideCharToMultiByte(CP_ACP, 0, szStatusText,-1, sz, 255, 0,0); <br> <br>    char    msg[100]; <br>    WCHAR   out[200]; <br> <br>    wsprintf(msg,"Progress: %s %d of %d ", sz, ulProgress, (ulProgress&gt;ulProgressMax)?ulProgress:ulProgressMax); <br>    MultiByteToWideChar(CP_ACP, 0, msg, -1, out, sizeof(out)); <br> <br>    SetProgress(out); <br>SetProgressBar(ulProgress, ulProgressMax); <br>    return(NOERROR); <br>}  // CBindStatusCallback::OnProgress <br> <br>// --------------------------------------------------------------------------- <br>// %%Function: CBindStatusCallback::OnStopBinding <br>// --------------------------------------------------------------------------- <br> STDMETHODIMP <br>CBindStatusCallback::OnStopBinding(HRESULT hrStatus, LPCWSTR pszError) <br>{ <br>    if (hrStatus) <br>        SetStatus(L"Status: File download Failed."); <br> <br>if (m_pbinding) <br>{ <br>m_pbinding-&gt;Release(); <br>m_pbinding = NULL; <br>} <br> <br>    return S_OK; <br>}  // CBindStatusCallback::OnStopBinding <br> <br>// --------------------------------------------------------------------------- <br>// %%Function: CBindStatusCallback::GetBindInfo <br>// --------------------------------------------------------------------------- <br> STDMETHODIMP <br>CBindStatusCallback::GetBindInfo(DWORD* pgrfBINDF, BINDINFO* pbindInfo) <br>{ <br>if (!pbindInfo || !pbindInfo-&gt;cbSize || !pgrfBINDF) <br>return E_INVALIDARG; <br> <br>*pgrfBINDF = BINDF_ASYNCHRONOUS | BINDF_ASYNCSTORAGE | BINDF_PULLDATA | <br>BINDF_GETNEWESTVERSION | BINDF_NOWRITECACHE; <br> <br>// remember incoming cbSize <br>ULONG cbSize = pbindInfo-&gt;cbSize; <br>// zero out structure <br>memset(pbindInfo, 0, cbSize); <br> <br>// restore cbSize <br>pbindInfo-&gt;cbSize = cbSize; <br>pbindInfo-&gt;dwBindVerb = BINDVERB_GET; <br> <br>return S_OK; <br>}  // CBindStatusCallback::GetBindInfo <br> <br>// --------------------------------------------------------------------------- <br>// %%Function: CBindStatusCallback::OnDataAvailable <br>// --------------------------------------------------------------------------- <br> STDMETHODIMP <br>CBindStatusCallback::OnDataAvailable(DWORD grfBSCF, DWORD dwSize, FORMATETC* pfmtetc, STGMEDIUM* pstgmed) <br>{ <br> HRESULT hr=S_OK; <br> DWORD dStrlength=0; <br> <br>// Get the Stream passed <br>    if (BSCF_FIRSTDATANOTIFICATION &amp; grfBSCF) <br>    { <br>        if (!m_pstm &amp;&amp; pstgmed-&gt;tymed == TYMED_ISTREAM) <br>    { <br>    m_pstm = pstgmed-&gt;pstm; <br>            if (m_pstm) <br>                m_pstm-&gt;AddRef(); <br>    } <br>    } <br> <br>    // If there is some data to be read then go ahead and read them <br>    if (m_pstm &amp;&amp; dwSize &gt; m_cbOld) <br>{ <br>        DWORD dwRead = dwSize - m_cbOld; // Minimum amount available that hasn't been read <br>        DWORD dwActuallyRead = 0;            // Placeholder for amount read during this pull <br> <br>if (dwRead &gt; 0) <br>do <br>{ <br>        char * pNewstr = new char[dwRead + 1]; <br>if (pNewstr==NULL) <br>return S_FALSE; <br>hr=m_pstm-&gt;Read(pNewstr,dwRead,&amp;dwActuallyRead); <br>    pNewstr[dwActuallyRead] = 0; <br>// If we really read something then lets add it to the Edit box <br>if (dwActuallyRead&gt;0) <br>{ <br>dStrlength=GetWindowTextLength(m_hwndText); <br> <br>char *pOldstr=NULL; <br>if (dwActuallyRead&gt;=EDIT_BOX_LIMIT)  // Read exceeded Edit box size <br>{ <br>pOldstr= new char[EDIT_BOX_LIMIT]; <br>if (pOldstr==NULL) <br>{ <br>delete[] pNewstr; <br>return S_FALSE; <br>} <br>lstrcpyn(pOldstr,pNewstr,EDIT_BOX_LIMIT-1); <br>} <br>                else if (dStrlength + dwActuallyRead &gt;= EDIT_BOX_LIMIT) <br>                { <br>                    // This pull exceeded the edit box size.  Only copy the last read. <br>                    pOldstr = new char[dwActuallyRead+1]; <br>                    if (pOldstr==NULL) <br>                    { <br>                        delete[] pNewstr; <br>                        return S_FALSE; <br>                    } <br>                    lstrcpyn(pOldstr,pNewstr,dwActuallyRead); <br>                } <br>  else <br>{ <br>pOldstr= new char[dStrlength+dwActuallyRead+1]; <br>if (pOldstr==NULL) <br>{ <br>delete[] pNewstr; <br>return S_FALSE; <br> } <br>GetWindowText(m_hwndText,pOldstr,(dStrlength+dwActuallyRead+1)); <br>lstrcat(pOldstr,pNewstr); <br>} <br>        SetWindowText(m_hwndText,pOldstr); <br>m_cbOld += dwActuallyRead; <br>delete[] pOldstr; <br>} <br>delete[] pNewstr; <br> <br>                } while (!(hr == E_PENDING || hr == S_FALSE) &amp;&amp; SUCCEEDED(hr)); <br>}//     if (m_pstm &amp;&amp; dwSize &gt; m_cbOld) <br> <br>if (BSCF_LASTDATANOTIFICATION &amp; grfBSCF) <br>{ <br>        if (m_pstm) <br>            m_pstm-&gt;Release(); <br>hr=S_OK;  // If it was the last data then we should return S_OK as we just finished reading everything <br>        SetStatus(L"Status: File downloaded."); <br>} <br> <br>    return hr; <br>}  // CBindStatusCallback::OnDataAvailable <br> <br>// --------------------------------------------------------------------------- <br>// %%Function: CBindStatusCallback::OnObjectAvailable <br>// --------------------------------------------------------------------------- <br> STDMETHODIMP <br>CBindStatusCallback::OnObjectAvailable(REFIID riid, IUnknown* punk) <br>{ <br>    return E_NOTIMPL; <br>}  // CBindStatusCallback::OnObjectAvailable <br> <br> <br>// =========================================================================== <br>//                           CDownload Implementation <br>// =========================================================================== <br> <br>// --------------------------------------------------------------------------- <br>// %%Function: CDownload::CDownload <br>// --------------------------------------------------------------------------- <br>CDownload::CDownload(LPCWSTR szURL) <br>{ <br>    m_url = szURL; <br>    m_pmk = 0; <br>    m_pbc = 0; <br>    m_pbsc = 0; <br>}  // CDownload <br> <br>// --------------------------------------------------------------------------- <br>// %%Function: CDownload::~CDownload <br>// --------------------------------------------------------------------------- <br>CDownload::~CDownload() <br>{ <br>    if (m_pmk) <br>        m_pmk-&gt;Release(); <br>    if (m_pbc) <br>        m_pbc-&gt;Release(); <br>    if (m_pbsc) <br>        m_pbsc-&gt;Release(); <br>}  // ~CDownload <br> <br>// --------------------------------------------------------------------------- <br>// %%Function: CDownload::DoDownload <br>// --------------------------------------------------------------------------- <br> HRESULT <br>CDownload::DoDownload(HWND hwndStatus, HWND hwndProgress, HWND hwndText, HWND hwndProgressBar) <br>{ <br>    IStream* pstm = NULL; <br>    HRESULT hr; <br> <br>    hr = CreateURLMoniker(NULL, m_url, &amp;m_pmk); <br>    if (FAILED(hr)) <br>        goto LErrExit; <br> <br>    m_pbsc = new CBindStatusCallback(hwndStatus, hwndProgress, hwndText, hwndProgressBar); <br>    if (m_pbsc == NULL) <br>        { <br>        hr = E_OUTOFMEMORY; <br>        goto LErrExit; <br>        } <br> <br>    hr = CreateBindCtx(0, &amp;m_pbc); <br>    if (FAILED(hr)) <br>        goto LErrExit; <br> <br>    hr = RegisterBindStatusCallback(m_pbc, <br>            m_pbsc, <br>            0, <br>            0L); <br>    if (FAILED(hr)) <br>        goto LErrExit; <br> <br>    hr = m_pmk-&gt;BindToStorage(m_pbc, 0, IID_IStream, (void**)&amp;pstm); <br>    if (FAILED(hr)) <br>        goto LErrExit; <br> <br>    return hr; <br> <br>LErrExit: <br>    if (m_pbc != NULL) <br>        { <br>        m_pbc-&gt;Release(); <br>        m_pbc = NULL; <br>        } <br>    if (m_pbsc != NULL) <br>        { <br>        m_pbsc-&gt;Release(); <br>        m_pbsc = NULL; <br>        } <br>    if (m_pmk != NULL) <br>        { <br>        m_pmk-&gt;Release(); <br>        m_pmk = NULL; <br>        } <br>if (pstm) <br>{ <br>pstm-&gt;Release(); <br>pstm = NULL; <br>} <br>    return hr; <br>}  // CDownload::DoDownload <br> <br> <br>// =========================================================================== <br>//                  User Interface and Initialization Routines <br>// =========================================================================== <br> <br>// --------------------------------------------------------------------------- <br>// %%Function: DialogProc <br>// --------------------------------------------------------------------------- <br> BOOL CALLBACK <br>DialogProc(HWND hwndDlg, UINT message, WPARAM wParam, LPARAM lParam) <br>{ <br>    static CDownload* pcdl = NULL; <br> <br>    switch(message) <br>        { <br>        case WM_INITDIALOG: <br>            EnableWindow(GetDlgItem(hwndDlg, IDOK), TRUE); <br>            EnableWindow(GetDlgItem(hwndDlg, IDCANCEL), TRUE); <br>            pcdl = (CDownload*)(LPVOID)(lParam); <br>            break; <br> <br>        case WM_COMMAND: <br>            { <br>            switch (LOWORD(wParam)) <br>                { <br>                case IDOK: <br>                    { <br>                    char rgchBuf[INTERNET_MAX_PATH_LENGTH]; <br>                    HWND hwndStatus = GetDlgItem(hwndDlg, IDC_DISPLAY); <br>                    HWND hwndProgress = GetDlgItem(hwndDlg, IDC_PROGRESS); <br>                    HWND hwndText = GetDlgItem(hwndDlg, IDC_EDIT); <br>HWND hwndProgressBar = GetDlgItem(hwndDlg, IDC_PROGRESSBAR); <br> <br>                    EnableWindow(GetDlgItem(hwndDlg, IDOK), FALSE); <br>                    EnableWindow(GetDlgItem(hwndDlg, IDCANCEL), FALSE); <br> <br>                    WideCharToMultiByte(CP_ACP, 0, pcdl-&gt;m_url, -1, rgchBuf, MAX_PATH, 0, 0); <br>            SetWindowText(hwndDlg, rgchBuf); <br> <br>                    SetWindowText(hwndStatus, TEXT("Status: Initiating Bind...")); <br>                    pcdl-&gt;DoDownload(hwndStatus, hwndProgress, hwndText, hwndProgressBar); <br>                    EnableWindow(GetDlgItem(hwndDlg, IDCANCEL), TRUE); <br>                    break; <br>                    } <br> <br>                case IDCANCEL: <br>                    EndDialog(hwndDlg,0); <br>                    return 1; <br>                } <br>            break; <br>            } <br>        } <br> <br>    return 0; <br>}  // DialogProc <br> <br>// --------------------------------------------------------------------------- <br>// %%Function: WinMain <br>// --------------------------------------------------------------------------- <br> int WINAPI <br>WinMain(HINSTANCE hinst, HINSTANCE hinstPrev, LPSTR szCmdLine, int nCmdShow) <br>{ <br>    static WCHAR    szDefaultURL[] = L"http://www.msn.com"; <br>    WCHAR           rgwchCmdLine[MAX_PATH]; <br>    HRESULT         hr; <br> <br>InitCommonControls(); <br> <br>    hr = CoInitialize(NULL); <br>    if (FAILED(hr)) <br>        return hr; <br> <br>    MultiByteToWideChar(CP_ACP, 0, szCmdLine, -1, rgwchCmdLine, MAX_PATH); <br> <br>    CDownload download(rgwchCmdLine[0] ? rgwchCmdLine : szDefaultURL); <br> <br>    int x = DialogBoxParam(hinst, MAKEINTRESOURCE(IDD_DIALOG1), HWND_DESKTOP, <br>        DialogProc, (LPARAM)(LPVOID)&amp;download); <br> <br>    CoUninitialize(); <br> <br>    return 0; <br>}  // WinMain <br> <br>// EOF ======================================================================= <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
