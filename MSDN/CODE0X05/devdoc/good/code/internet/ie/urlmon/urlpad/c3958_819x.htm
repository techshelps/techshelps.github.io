<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>PADITEM.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3975"></a>PADITEM.CPP</h2>
<pre><code>//=------------------------------------------------------------------------= <br>// PadItem.Cpp <br>//=------------------------------------------------------------------------= <br>// Copyright 1992-1997 Microsoft Corporation.  All Rights Reserved. <br>// <br>// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF <br>// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO <br>// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A <br>// PARTICULAR PURPOSE. <br>//=--------------------------------------------------------------------------= <br>// <br>// implementation of the CEmbeddedItem class <br>// <br> <br>#include "stdafx.h" <br>#include "padview.h" <br>#include "paddoc.h" <br>#include "paditem.h" <br>#include &lt;limits.h&gt; <br>#include &lt;winnls.h&gt; <br> <br>IMPLEMENT_DYNAMIC(CEmbeddedItem, COleServerItem) <br> <br>CEmbeddedItem::CEmbeddedItem(CPadDoc* pContainerDoc) <br>: COleServerItem(pContainerDoc, TRUE) <br>{ <br>m_nBeg = 0; <br>m_nEnd = UINT_MAX; <br> <br>// support CF_TEXT format <br>GetDataSource()-&gt;DelayRenderFileData(CF_TEXT); <br>} <br> <br>BOOL CEmbeddedItem::OnRenderFileData(LPFORMATETC lpFormatEtc, CFile* pFile) <br>{ <br>ASSERT(lpFormatEtc != NULL); <br>if (lpFormatEtc-&gt;cfFormat != CF_TEXT) <br>return COleServerItem::OnRenderFileData(lpFormatEtc, pFile); <br> <br>BOOL bResult = FALSE; <br>TRY <br>{ <br>// save contents of this item to the file <br>SaveToFile(pFile); <br> <br>// CF_TEXT has NUL termination <br>char chZero = '\0'; <br>pFile-&gt;Write(&amp;chZero, sizeof(char)); <br> <br>bResult = TRUE; // success <br>} <br>END_TRY <br> <br>return bResult; <br>} <br> <br>CPadView* CEmbeddedItem::GetView() const <br>{ <br>CDocument* pDoc = GetDocument(); <br>ASSERT_VALID(pDoc); <br>POSITION pos = pDoc-&gt;GetFirstViewPosition(); <br>if (pos == NULL) <br>return NULL; <br> <br>CPadView* pView = (CPadView*)pDoc-&gt;GetNextView(pos); <br>ASSERT_VALID(pView); <br>ASSERT_KINDOF(CPadView, pView); <br>return pView; <br>} <br> <br>void CEmbeddedItem::SaveToFile(CFile* pFile) <br>{ <br>CPadView* pView = GetView(); <br>LPCTSTR lpszText = NULL; <br> <br>TRY <br>{ <br>// get access to the edit buffer <br>lpszText = pView-&gt;LockBuffer(); <br> <br>// get range (make sure inside of text length) <br>UINT nEnd = pView-&gt;GetWindowTextLength(); <br>UINT nBeg = min(m_nBeg, nEnd); <br>nEnd = min(m_nEnd, nEnd); <br>#ifdef _UNICODE <br>// copy to temp buffer, convert, then write to file <br>int nLen = WideCharToMultiByte(CP_ACP, 0, lpszText+nBeg, nEnd-nBeg, <br>NULL, 0, NULL, NULL); <br>char* pszTemp = new char[nLen]; <br>WideCharToMultiByte(CP_ACP, 0, lpszText+nBeg, nEnd-nBeg, <br>pszTemp, nLen, NULL, NULL); <br>pFile-&gt;Write(pszTemp, nLen); <br>delete[] pszTemp; <br>#else <br>// write it out to the file <br>pFile-&gt;Write(lpszText+nBeg, (nEnd-nBeg) * sizeof(char)); <br>#endif <br>} <br>END_TRY <br> <br>// release access to edit buffer <br>if (lpszText != NULL) <br>pView-&gt;UnlockBuffer(); <br>} <br> <br>void CEmbeddedItem::Serialize(CArchive&amp; ar) <br>{ <br>if (ar.IsStoring()) <br>{ <br>// save just the portion this item refers to <br>ar.Flush(); <br>CFile* pFile = ar.GetFile(); <br>SaveToFile(pFile); <br>} <br>else <br>{ <br>// otherwise, read in the entire file <br>GetDocument()-&gt;Serialize(ar); <br>} <br>} <br> <br>BOOL CEmbeddedItem::OnGetExtent(DVASPECT dwDrawAspect, CSize&amp; rSize) <br>{ <br>if (dwDrawAspect != DVASPECT_CONTENT) <br>return COleServerItem::OnGetExtent(dwDrawAspect, rSize); <br> <br>// no drawing will happen if cliprect is NULL <br>CClientDC dc(NULL); <br>dc.IntersectClipRect(0, 0, 0, 0); <br>return OnDraw(&amp;dc, rSize); <br>} <br> <br>BOOL CEmbeddedItem::OnDraw(CDC* pDC, CSize&amp; rSize) <br>{ <br>// get view attached to the item <br>CPadView* pView = GetView(); <br> <br>// In some situations, OLE1 servers will ask for the presentation data <br>//  during shutdown, even though it is not necessary (since the picture <br>//  has not changed).  This will happen when closing a frame window <br>//  for example.  By this time all the views are gone and there is no <br>//  way to produce the metafile data, since the actual text is <br>//  stored by the edit control (the view).  In this case, we simply <br>//  fail the call. <br>if (pView == NULL) <br>return FALSE; <br> <br>// edit controls have a border around them <br>CRect rectClient; <br>CRect margin; <br> <br>{ // Calculate correct ClientRect <br>pView-&gt;GetClientRect(&amp;rectClient); <br>rectClient.InflateRect(-1,-1); <br> <br>if (pView-&gt;GetStyle() &amp; WS_HSCROLL) <br>rectClient.bottom++; <br>if (pView-&gt;GetStyle() &amp; WS_VSCROLL) <br>rectClient.right++; <br>} <br> <br>{ // Calculate margins <br>CRect rectEdit; <br>pView-&gt;GetEditCtrl().GetRect(&amp;rectEdit); <br> <br>if (rectEdit.IsRectEmpty()) <br>rectEdit.SetRect(4,4,4,4); <br> <br>int HorzMargin = rectEdit.left - rectClient.left; <br>int VertMargin = rectEdit.top - rectClient.top; <br> <br>margin.SetRect(HorzMargin,VertMargin,HorzMargin,VertMargin); <br> <br>if (pView-&gt;GetStyle() &amp; WS_HSCROLL) <br>margin.bottom++; <br>if (pView-&gt;GetStyle() &amp; WS_VSCROLL) <br>margin.right++; <br>} <br> <br>// get the font from the CEditView <br>CFont* pFont = pView-&gt;GetFont(); <br>CFont* pOldFont = NULL; <br>if (pFont != NULL) <br>pOldFont = pDC-&gt;SelectObject(pFont); <br> <br>// get formatting rectangle <br>CRect rect(rectClient); <br>rect.left += margin.left; <br>rect.top += margin.top; <br>rect.right -= margin.right; <br>rect.bottom = INT_MAX; <br> <br>pDC-&gt;SetBkMode(TRANSPARENT); <br> <br>// first just determine the correct extents of the text <br>pDC-&gt;SaveDC(); <br>pDC-&gt;IntersectClipRect(0, 0, 0, 0); // no drawing with NULL clipping <br>if (pView-&gt;PrintInsideRect(pDC, rect, m_nBeg, m_nEnd) == 0) <br>{ <br>TEXTMETRIC tm; <br>pDC-&gt;GetTextMetrics(&amp;tm); <br>rect.bottom = rect.top + tm.tmHeight + tm.tmExternalLeading; <br>} <br>pDC-&gt;RestoreDC(-1); <br> <br>// then, really output the text <br>pDC-&gt;SetWindowOrg(rect.left-margin.left,rect.top-margin.top); <br>pDC-&gt;SetWindowExt(margin.left + rect.Width() + margin.right, <br>margin.top + rect.Height() + margin.bottom); <br>pView-&gt;PrintInsideRect(pDC, rect, m_nBeg, m_nEnd); <br> <br>// adjust for border (rect.left is already adjusted) <br>rect.left -= margin.left; <br>rect.top -= margin.top; <br>rect.right += margin.right; <br>rect.bottom += margin.bottom; <br> <br>// select previous font <br>if (pOldFont != NULL) <br>pDC-&gt;SelectObject(pOldFont); <br> <br>// return HIMETRIC size <br>rSize = rect.Size(); <br>pDC-&gt;LPtoHIMETRIC(&amp;rSize); <br>return TRUE; <br>} <br> <br>///////////////////////////////////////////////////////////////////////////// </code></pre>
<p>&nbsp;</p></body>
</HTML>
