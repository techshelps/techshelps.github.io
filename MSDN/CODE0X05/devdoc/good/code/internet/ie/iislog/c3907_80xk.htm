<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>LOGPARSE.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3908"></a>LOGPARSE.CPP</h2>
<pre><code>// LOGPARSE.CPP - Implementation file for your Internet Server <br>//    LogParse Extension <br> <br>#include "stdafx.h" <br>#include "LogParse.h" <br>#include "urlmon.h" <br> <br>/////////////////////////////////////////////////////////////////////// <br>// The one and only CWinApp object <br>// NOTE: You may remove this object if you alter your project to no <br>// longer use MFC in a DLL. <br> <br>CWinApp theApp; <br> <br>#define USE_DECODER 1 <br> <br>#define MAX_SIZE        2048 <br>#define LOG_BUF_SIZE    512 <br>#define NUMLOG          23 <br> <br>TCHAR   LogEntries[NUMLOG][LOG_BUF_SIZE] = { <br>        "",                 //0 remote addr <br>        "-",                //1 user name, "-" means anonymous <br>        "",                 //2 request date <br>        "",                 //3 request time <br>        "W3SVC",            //4 service type (default = W3SVC) <br>        "",                 //5 server name <br>        "",                 //6 server ip <br>        "0",                //7 elapsed time (default = 0) <br>        "0",                //8 bytes received (default = 0) <br>        "0",                //9 bytes sent (default = 0) <br>        "200",              //a service response code (default = 200) <br>        "0",                //b system (NT) response code (default = 0) <br>        "GET",              //c method type  (HEAD,POST, default = GET) <br>        "",                 //d uri <br>        "",                 //e user agent <br>        "-",                //f referer (default = "-" means unknown) <br>        "",                 //10 cookie <br>        "-",                //11 query string ("-" means no query string) <br>        "",                 //12 duration <br>        "",                 //13 context <br>        "",                 //14 client cache <br>        "-",                //15 metatag <br>        "-"                 //16 additional parameters (ignored) <br>    }; <br> <br> <br>/////////////////////////////////////////////////////////////////////// <br>// command-parsing map <br> <br>BEGIN_PARSE_MAP(CLogParseExtension, CHttpServer) <br>// TODO: insert your ON_PARSE_COMMAND() and  <br>// ON_PARSE_COMMAND_PARAMS() here to hook up your commands. <br>// For example: <br>DEFAULT_PARSE_COMMAND(LogParse, CLogParseExtension) <br>ON_PARSE_COMMAND(LogParse, CLogParseExtension, ITS_PSTR) <br>ON_PARSE_COMMAND_PARAMS("input_text=default") <br>END_PARSE_MAP(CLogParseExtension) <br> <br> <br>/////////////////////////////////////////////////////////////////////// <br>// The one and only CLogParseExtension object <br> <br>CLogParseExtension theExtension; <br> <br> <br>/////////////////////////////////////////////////////////////////////// <br>// CLogParseExtension implementation <br> <br>CLogParseExtension::CLogParseExtension() <br>{ <br>m_hFile = NULL; <br>m_ContentLen = 0; <br>m_szEncoding = NULL; <br>    m_cbURILen = 0; <br>    m_fInLog = FALSE; <br>} <br> <br>CLogParseExtension::~CLogParseExtension() <br>{ <br>if (m_szEncoding) <br>GlobalFree(m_szEncoding); <br> <br>} <br> <br>BOOL CLogParseExtension::GetExtensionVersion(HSE_VERSION_INFO* pVer) <br>{ <br>// Call default implementation for initialization <br>CHttpServer::GetExtensionVersion(pVer); <br> <br>// Load description string <br>TCHAR sz[HSE_MAX_EXT_DLL_NAME_LEN+1]; <br>ISAPIVERIFY(::LoadString(AfxGetResourceHandle(), <br>IDS_SERVER, sz, HSE_MAX_EXT_DLL_NAME_LEN)); <br>_tcscpy(pVer-&gt;lpszExtensionDesc, sz); <br>return TRUE; <br>} <br> <br>/////////////////////////////////////////////////////////////////////// <br>// CLogParseExtension command handlers <br> <br>// pszString : post string (using FORM) <br>void CLogParseExtension::LogParse(CHttpServerContext* pCtxt, LPTSTR pszString) <br>{ <br> <br>StartContent(pCtxt); <br>WriteTitle(pCtxt); <br> <br>*pCtxt &lt;&lt; _T("Server DLL, just shown that we were here. \r\n"); <br> <br>    // real work starts <br>    DWORD   err; <br>    DWORD   dwLen = sizeof(DWORD); <br>    char    buf[LOG_BUF_SIZE]; <br>    DWORD   cbsize = LOG_BUF_SIZE; <br>    BOOL    bret; <br>BOOL    fEncoded = FALSE; <br> <br>    // get server variables <br>    if (!pCtxt-&gt;GetServerVariable("CONTENT_LENGTH", buf, &amp;dwLen) || <br>        !pCtxt-&gt;GetServerVariable("REQUEST_METHOD", (void *)LogEntries[12], &amp;cbsize) ) <br>    { <br>        err = GetLastError(); <br>        *pCtxt &lt;&lt; _T("LogParse failed: couldn't get server variables.\r\n"); <br>        goto _exithere; <br>    } <br> <br>    if (lstrcmp(LogEntries[12], _T("POST"))) <br>    { <br>        *pCtxt &lt;&lt; _T("LogParse failed: wrong request method.\r\n"); <br>        goto _exithere; <br>    } <br>    else     <br>    {     <br>cbsize = LOG_BUF_SIZE; <br>m_szEncoding = (LPTSTR)GlobalAlloc(LPTR, LOG_BUF_SIZE); <br>if (!m_szEncoding) <br>{ <br>*pCtxt &lt;&lt; _T("LogParse failed: couldn't allocate g_szEncoding \r\n"); <br>goto _exithere; <br>} <br> <br>        if (pCtxt-&gt;GetServerVariable("HTTP_CONTENT_TRANSFER_ENCODING", (void *)m_szEncoding, &amp;cbsize)) <br>fEncoded = TRUE; <br> <br>if (*pszString == NULL) <br>{ <br>*pCtxt &lt;&lt; _T("LogParse: no posting string \r\n"); <br>goto _exithere; <br>} <br> <br>bret = OpenLogFile(pCtxt); <br>if (!bret) <br>{ <br>*pCtxt &lt;&lt; _T("LogParse: create/open file failed \r\n"); <br>goto _exithere; <br>} <br> <br>dwLen = AppendContentToLogfile(pCtxt, pszString, atoi(buf), fEncoded); <br> <br>ISAPITRACE1("LogParse: server logged   %d bytes\n", dwLen); <br>ISAPITRACE1("LogParse: encoding by %s\n", m_szEncoding); <br> <br>    } <br>     <br> <br>_exithere: <br>EndContent(pCtxt); <br> <br>} <br> <br>BOOL CLogParseExtension::OpenLogFile(CHttpServerContext* pCtxt) <br>{ <br>SYSTEMTIMEst; <br>    TCHAR   szLogPath[MAX_PATH]; <br>    DWORD   cbpath = MAX_PATH; <br>TCHARpszfile[MAX_PATH]; <br>    HKEY    hkey; <br> <br>// generate filename based on date <br>GetLocalTime(&amp;st); <br>    wsprintf(pszfile, "ie%.2d%.2d%.2d.log", st.wYear, st.wMonth, st.wDay); <br> <br>    if (ERROR_SUCCESS != RegOpenKeyEx(HKEY_LOCAL_MACHINE, g_szRegW3SVC, 0, KEY_READ, &amp;hkey)) <br>    { <br>        *pCtxt &lt;&lt; _T("LogParse failed: RegOpenKeyEx\r\n"); <br>    return FALSE; <br>    } <br> <br>if (ERROR_SUCCESS != RegQueryValueEx(hkey, g_szRegLogFileDirectory,  <br>                                             NULL, NULL, (LPBYTE)szLogPath, &amp;cbpath)) <br>{ <br>    *pCtxt &lt;&lt; _T("LogParse failed: GetLogFileDirectory.\r\n"); <br>        RegCloseKey(hkey); <br>    return FALSE;  <br>    } <br> <br>    RegCloseKey(hkey); <br> <br>    lstrcpy(m_szLogFile, szLogPath); <br>    lstrcat(m_szLogFile, g_szLogFilePath); <br>lstrcat(m_szLogFile, pszfile); <br> <br>    m_hFile = CreateFile(m_szLogFile, GENERIC_READ|GENERIC_WRITE, 0, NULL,  <br>        OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL); <br> <br>    if (m_hFile == INVALID_HANDLE_VALUE) <br>        return FALSE; <br> <br>SetFilePointer(m_hFile, 0, NULL, FILE_END); <br> <br>return TRUE; <br>} <br> <br>DWORD CLogParseExtension::AppendContentToLogfile(CHttpServerContext* pCtxt, LPCTSTR pszContent, DWORD ContentLen, BOOL fEncoded) <br>{ <br>LPTSTR  pszDecContent = NULL; <br>LPTSTR  pszLog = NULL; <br>    DWORD   dwWritten = 0; <br> <br>if (fEncoded) <br>{ <br>DWORD   dwlen; <br>//decoding <br>dwlen = ContentLen * 4; <br>pszDecContent = (LPTSTR)GlobalAlloc(LPTR, dwlen); <br>if (DecodeContent(pCtxt, pszContent, ContentLen, pszDecContent, dwlen)) <br>pszLog = pszDecContent; <br>        else <br>            return 0;       // failed to decompress the data somehow <br>} <br>else <br>{ <br>pszLog = (LPTSTR)pszContent; <br>m_ContentLen = lstrlenA(pszLog); <br>} <br> <br>//transform to W3C flexible log format <br>dwWritten = ConvertToW3CFlexible(pCtxt, pszLog); <br> <br>if (pszDecContent) <br>GlobalFree(pszDecContent); <br> <br>    return dwWritten; <br>} <br> <br>// we need to extract out the decoder's name from "x-filtername" string <br>BOOL CLogParseExtension::DecodeContent(CHttpServerContext* pCtxt, LPCTSTR pszEncodedString,  <br>   DWORD cbEnc, LPTSTR pszDecString, DWORD cbDec) <br>{ <br>#ifdef USE_DECODER <br>LPWSTRpwszEncoding = NULL; <br>LPTSTR  pszEncoding = m_szEncoding; <br>DWORD   dwlen; <br>BOOL    bInDash = FALSE; <br>BOOLbret = FALSE; <br>IEncodingFilterFactory* pEflt = NULL; <br>    IDataFilter*    pDF = NULL; <br> <br>//parse encoding header string <br>while (*pszEncoding != 0) <br>{ <br>if (bInDash) <br>break; <br> <br>if (*pszEncoding == '-') <br>bInDash = TRUE; <br> <br>pszEncoding ++; <br>}; <br> <br>dwlen = (lstrlenA(pszEncoding) + 1) * sizeof(WCHAR); <br>pwszEncoding = (LPWSTR)GlobalAlloc(LPTR, dwlen); <br> <br>//find/load decoder <br>    if (!pwszEncoding) <br>    { <br>*pCtxt &lt;&lt; _T("LogParse: DecodeContent mem error \r\n"); <br>goto _exitDecode; <br>} <br> <br>dwlen = MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, pszEncoding, lstrlenA(pszEncoding), <br>pwszEncoding, dwlen); <br> <br>if (dwlen == 0) <br>{ <br>*pCtxt &lt;&lt; _T("LogParse : DecodeContent wide char convert failed\r\n"); <br>goto _exitDecode; <br>} <br> <br>    CoCreateInstance(CLSID_StdEncodingFilterFac, NULL, CLSCTX_INPROC_SERVER, <br>                                    IID_IEncodingFilterFactory, (void**)&amp;pEflt); <br> <br>if (pEflt) <br>    {                 <br>pEflt-&gt;GetDefaultFilter(pwszEncoding, L"text", &amp;pDF); <br>        if (pDF) <br>        { <br>            LONG lInUsed = 0; <br>            LONG lOutUsed = 0; <br>            HRESULT hrCode = NOERROR; <br> <br>            hrCode = pDF-&gt;DoEncode( <br>                                   0, <br>                                   cbEnc, <br>                                   (BYTE *)pszEncodedString,  <br>                                   cbDec, <br>                                   (BYTE *)pszDecString,  <br>                                   cbEnc, <br>                                   &amp;lInUsed, <br>                                   &amp;lOutUsed, <br>                                   0); <br> <br>            if (SUCCEEDED(hrCode)) <br>            { <br>                m_ContentLen = (DWORD)lOutUsed; <br>bret = TRUE; <br>            } <br>            pDF-&gt;Release(); <br>         <br>} <br>         <br>        pEflt-&gt;Release(); <br>         <br>}    <br> <br>_exitDecode: <br>if (pwszEncoding) <br>GlobalFree(pwszEncoding); <br> <br>return bret; <br>#else <br>return TRUE; <br>#endif <br>} <br> <br> <br>DWORD CLogParseExtension::ConvertToW3CFlexible(CHttpServerContext* pCtxt, LPTSTR pszClientLog) <br>{ <br> <br>#ifdef _DEBUG <br>#define NUMVARS 20 <br> <br>  char varnames[NUMVARS][30] = { <br>    "AUTH_TYPE", <br>    "CONTENT_LENGTH", <br>    "CONTENT_TYPE", <br>    "PATH_INFO", <br>    "PATH_TRANSLATED", <br>    "QUERY_STRING", <br>    "REMOTE_ADDR", <br>    "REMOTE_HOST", <br>    "REMOTE_USER", <br>    "UNMAPPED_REMOTE_USER", <br>    "REQUEST_METHOD", <br>    "SCRIPT_NAME", <br>    "SERVER_NAME", <br>    "SERVER_PORT", <br>    "SERVER_PORT_SECURE", <br>    "SERVER_PROTOCOL", <br>    "SERVER_SOFTWARE", <br>    "ALL_HTTP", <br>    "HTTP_ACCEPT", <br>    "URL" <br>  }; <br> <br>  char buf[1024]; <br>  unsigned long bufsize; <br> <br>  for (int index = 0; index &lt; NUMVARS; index++) { <br> <br>    bufsize = 1024; <br>    if (pCtxt-&gt;GetServerVariable (&amp;varnames[index][0], buf, &amp;bufsize)) { <br> <br>      ISAPITRACE2("[%s] = [%s]\n", &amp;varnames[index], buf); <br>    } <br>    else { <br> <br>      ISAPITRACE1("[%s] = (Oops!)\n", varnames[index]); <br>    } <br>  } <br>#endif <br> <br>    DWORD  dwFixedBytes = 0; <br>    DWORD  dwTotalBytes = 0; <br>    TCHAR  szSpace[] = " "; <br>    LPTSTR pszServerLog; <br>    DWORD  dwCount = m_ContentLen + 1;  // over 1 from end <br>    DWORD  dwmove; <br>     <br>    dwFixedBytes = ProcessFixedLogFields(pCtxt); <br>    dwFixedBytes = dwFixedBytes + NUMLOG*lstrlen(szSpace) + lstrlen(LogEntries[4])  <br>                + 6*lstrlen(LogEntries[7]) + lstrlen(LogEntries[10]); <br> <br>    // parse client log <br>    m_cbURILen = 0; <br>    do  <br>    { <br>        DWORD   dwthisclientlog = 0; <br>        DWORD   dwthislog = 0; <br>        DWORD   dwwritten; <br> <br>        dwthisclientlog = ProcessClientLog(pCtxt, pszClientLog, &amp;dwmove); <br>        if (dwthisclientlog == 0) <br>            break; <br> <br>        dwthislog = dwFixedBytes + dwthisclientlog; <br> <br>        // fill in temp buffer <br>        pszServerLog = (LPTSTR)GlobalAlloc(LPTR, dwthislog); <br>        if (!pszServerLog) <br>        { <br>            ISAPITRACE0("LogParse: mem alloc failed, pszServerLog\n"); <br>            continue; <br>        } <br> <br>        int ilog, i; <br>        int index = 0; <br>        for (ilog=0; ilog&lt;NUMLOG; ilog++) <br>        { <br>            for (i=0; LogEntries[ilog][i]; i++, index++) <br>                pszServerLog[index] = LogEntries[ilog][i]; <br> <br>            // Add space <br>            pszServerLog[index++] = ' '; <br>        } <br> <br>        // null terminated <br>        pszServerLog[index] = 0; <br> <br>        // write to server log file <br>        WriteFile(m_hFile, pszServerLog, index, &amp;dwwritten, NULL); <br>        dwTotalBytes += dwwritten; <br>        GlobalFree(pszServerLog); <br> <br>        // keep track of end of string <br>        dwCount -= dwmove; <br>        if (dwCount == 0) <br>            break; <br> <br>        pszClientLog += dwmove; <br> <br>    } while (TRUE); <br> <br>CloseHandle(m_hFile); <br> <br>    return dwTotalBytes; <br>} <br> <br>#define NUMSERVER   7 <br>#define NUMCLIENT   5 <br> <br>char Varnames[NUMSERVER][20] = { <br>    "REMOTE_ADDR", <br>    "REMOTE_USER", <br>    "SERVER_NAME", <br>    "SERVER_PORT", <br>    "HTTP_USER_AGENT", <br>    "HTTP_REFERER", <br>    "QUERY_STRING" <br>    }; <br> <br>int SvrIdx[NUMSERVER+NUMCLIENT] = {0, 1, 5, 6, 14, 15, 17, 19, 20, 2, 3, 18}; <br> <br> <br>DWORD CLogParseExtension::ProcessFixedLogFields(CHttpServerContext* pCtxt) <br>{ <br>    DWORD   dwBytes; <br>    DWORD   cbsize; <br>    char    buf[1024]; <br> <br>    // remote addr <br>    dwBytes = 0; <br>    for (int i=0; i&lt;NUMSERVER; i++) <br>    { <br>        cbsize = LOG_BUF_SIZE; <br>        if (!pCtxt-&gt;GetServerVariable(Varnames[i], buf, &amp;cbsize)) <br>        { <br>            ISAPITRACE1("LogParse: can't get %s\n", Varnames[i]); <br>        } <br>        else <br>        { <br>            if (*buf) <br>                lstrcpy(LogEntries[SvrIdx[i]], buf); <br>        } <br>        dwBytes += lstrlen(LogEntries[SvrIdx[i]]); <br>    } <br> <br>    // method type <br>    dwBytes += lstrlen(LogEntries[12]); <br> <br>    // cookie <br>    cbsize = LOG_BUF_SIZE; <br>    if (!GetUserCookie(pCtxt, LogEntries[16], &amp;cbsize)) <br>    { <br>        ISAPITRACE0("LogParse: can't get request method\n"); <br>        cbsize = 0; <br>    } <br>    dwBytes += cbsize; <br> <br>    return dwBytes; <br>} <br> <br> <br>BOOL CLogParseExtension::GetUserCookie(CHttpServerContext* pCtxt, LPTSTR pszCookie, LPDWORD pcb) <br>{ <br>    BOOL    bret = FALSE; <br>    DWORD   sizeof_cookies = sizeof_header; <br>    char *  cookie; <br> <br>    cookie = (char *)GlobalAlloc(LPTR, sizeof_cookies); <br>    if (!cookie) <br>        return bret; <br> <br>    char * interse_cookie = &amp;cookie[0];   // interse' cookie <br> <br>    // Obtain the list of cookies. <br>    if (pCtxt-&gt;GetServerVariable("ALL_HTTP", interse_cookie, &amp;sizeof_cookies)) <br>    { <br>        if (interse_cookie = strstr (interse_cookie, "HTTP_COOKIE:")) <br>        { <br>            // Does the client already have a Interse' cookie? Also, remove cookies <br>            // to the left of the Interse' cookie. <br>            // <br>            if (interse_cookie = strstr (interse_cookie, interselog_cookiename)) <br>            { <br>                // Remove cookies to the right of Interse' cookie. <br>                // <br>                char * next_cookie = strstr (interse_cookie, ";"); <br>                if (next_cookie) *next_cookie = 0; <br>                *pcb = lstrlen(interse_cookie); <br>                if (*pcb &gt;= LOG_BUF_SIZE) <br>                { <br>                    ISAPITRACE0("LogParse: cookie memory overflow!!\n"); <br>                } <br>                lstrcpy(pszCookie, interse_cookie); <br>                bret = TRUE; <br>            } <br>            else <br>            { <br>                *pszCookie = 0; <br>                *pcb = 0; <br>            } <br>        } <br>        else <br>        { <br>            *pszCookie = 0; <br>            *pcb = 0; <br>        } <br>    } <br> <br>    return bret; <br>} <br> <br>/* <br> * client log is in "extended server log format" <br> * #Fields: s-URI <br> * http://www.msnbc.com/news/66784.asp <br> * #Fields: x-context x-cache x-date x-time x-duration x-meta <br> * N 1 06-10-1997 14:03:54 00:12:32 customestring <br> * N 1 06-11-1997 10:13:04 00:05:13 <br> * N 1 06-17-1997 04:07:15 00:11:33 <br> */ <br> <br>DWORD CLogParseExtension::ProcessClientLog(CHttpServerContext* pCtxt, LPTSTR pszClientLog, LPDWORD pMove) <br>{ <br>    char*   pszNext; <br>    DWORD   cbBytes = 0; <br>    LPTSTR  pszInbuf = pszClientLog; <br> <br>    if (m_cbURILen == 0) <br>    { <br>        // look for URI <br>        if (*pszClientLog == ' ') <br>            pszClientLog ++; <br> <br>        if (memicmp(pszClientLog, g_szURIFields, lstrlen(g_szURIFields))) <br>            return 0; <br> <br>        pszClientLog += lstrlen(g_szURIFields); <br>        pszNext = strstr(pszClientLog, " "); <br>        if (pszNext) <br>            *pszNext = 0; <br> <br>        lstrcpy(LogEntries[13], pszClientLog); <br>        m_cbURILen = pszNext - pszClientLog; <br>        pszClientLog += m_cbURILen; <br>        pszClientLog ++;    // the space  (pNext) <br>    } <br> <br>    cbBytes = m_cbURILen; <br>  <br>    // next line should be either log or #Fields: x-context.... or end_of_string <br>    if (!memicmp(pszClientLog, g_szFields, lstrlen(g_szFields))) <br>    { <br>        pszClientLog = strstr(pszClientLog, g_szMeta); <br>        pszClientLog += lstrlen(g_szMeta); <br>        if (*pszClientLog == ' ') <br>            pszClientLog ++;        // the 1st space in log cache!!  <br>    } <br>    else if (*pszClientLog == 0) <br>    { <br>        // end of log string <br>        return 0; <br>    } <br> <br>    for (int i = NUMSERVER; i &lt; NUMSERVER+NUMCLIENT; i ++) <br>    { <br>        pszNext = strstr(pszClientLog, " "); <br>        if (pszNext) <br>            *pszNext = 0; <br>        lstrcpy(LogEntries[SvrIdx[i]], pszClientLog); <br>        cbBytes += lstrlen(LogEntries[SvrIdx[i]]); <br>        pszClientLog += lstrlen(LogEntries[SvrIdx[i]]); <br>        pszClientLog ++ ;   // the space <br>    } <br> <br>    // look for URI <br>    if (!memicmp(pszClientLog, g_szURIFields, lstrlen(g_szURIFields))) <br>    { <br>        m_cbURILen = 0; <br>    } <br>    // <br>    *pMove = pszClientLog - pszInbuf;     <br>    return cbBytes;         <br> <br>} <br> <br>// Do not edit the following lines, which are needed by ClassWizard. <br>#ifdef PROCESS_MESSAGE <br>BEGIN_MESSAGE_MAP(CLogParseExtension, CHttpServer) <br>//{{AFX_MSG_MAP(CLogParseExtension) <br>//}}AFX_MSG_MAP <br>END_MESSAGE_MAP() <br>#endif <br> <br> <br> <br>/////////////////////////////////////////////////////////////////////// <br>// If your extension will not use MFC, you'll need this code to make <br>// sure the extension objects can find the resource handle for the <br>// module.  If you convert your extension to not be dependent on MFC, <br>// remove the comments arounn the following AfxGetResourceHandle() <br>// and DllMain() functions, as well as the g_hInstance global. <br> <br>/**** <br> <br>static HINSTANCE g_hInstance; <br> <br>HINSTANCE AFXISAPI AfxGetResourceHandle() <br>{ <br>return g_hInstance; <br>} <br> <br>BOOL WINAPI DllMain(HINSTANCE hInst, ULONG ulReason, <br>LPVOID lpReserved) <br>{ <br>if (ulReason == DLL_PROCESS_ATTACH) <br>{ <br>g_hInstance = hInst; <br>} <br> <br>return TRUE; <br>} <br> <br>****/ <br> <br>/* W3C flexible log file format */ <br>/* <br>157.56.230.204//remote addr <br>-//user name, "-" means anonymous <br>06/17/97//request date <br>19:51:44//request time <br>W3SVC//service type (default = W3SVC) <br>A282527//server name <br>157.56.230.168//server ip <br>340//elapsed time (default = 0) <br>450//bytes received (default = 0) <br>123//bytes sent (default = 0) <br>200//service response code (default = 200) <br>0//system (NT) response code (default = 0) <br>GET//method type  (HEAD,POST, default = GET) <br>/impsrvr/index.html//uri <br>Mozilla/2.0 (compatible; MSIE 3.02; WIndows NT)//user agent <br>-//referer (default = "-" means unknown) <br>INTERSE=157222862038521//cookie <br>-//query string ("-" means no query string) <br>00:00:18//duration <br>N//context <br>1//client cache <br>-//additional parameters (ignored) <br>*/ </code></pre>
<p>&nbsp;</p></body>
</HTML>
