<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>IELNKCTL.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3891"></a>IELNKCTL.CPP</h2>
<pre><code>// IELnkCtl.cpp : Implementation of CIELnkCtl <br>#include "stdafx.h" <br>#include "IELnk.h" <br>#include "IELnkCtl.h" <br>#include &lt;hlink.h&gt; <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// CIELnkCtl <br>STDMETHODIMP CIELnkCtl::InterfaceSupportsErrorInfo(REFIID riid) <br>{ <br>static const IID* arr[] =  <br>{ <br>&amp;IID_IIELnkCtl, <br>}; <br>for (int i=0;i&lt;sizeof(arr)/sizeof(arr[0]);i++) <br>{ <br>if (InlineIsEqualGUID(*arr[i],riid)) <br>return S_OK; <br>} <br>return S_FALSE; <br>} <br> <br> <br>HRESULT CIELnkCtl::OnDraw(ATL_DRAWINFO&amp; di) <br>{ <br>RECT&amp; rc = *(RECT*)di.prcBounds; <br>HDC hdc  = di.hdcDraw; <br>HBRUSH    hOldBrush, hBrush; <br>    HPEN      hOldPen, hPen; <br> <br>    hPen = (HPEN)GetStockObject(BLACK_PEN); <br>    hOldPen = (HPEN)SelectObject(hdc, hPen); <br>    hBrush = (HBRUSH)GetStockObject(WHITE_BRUSH); <br>    hOldBrush = (HBRUSH)SelectObject(hdc, hBrush); <br> <br>Rectangle(hdc, rc.left, rc.top, rc.right, rc.bottom); <br> <br>#ifndef _UNICODE <br>if(m_pANSIHLink) <br>DrawText(hdc, m_pANSIHLink, -1, &amp;rc, DT_CENTER | DT_VCENTER | DT_SINGLELINE); <br>else <br>DrawText(hdc, "Unable to Display URL", -1, &amp;rc, DT_CENTER | DT_VCENTER | DT_SINGLELINE); <br>#else <br>DrawText(hdc, m_strHLink, -1, &amp;rc, DT_CENTER | DT_VCENTER | DT_SINGLELINE); <br>#endif <br> <br>    SelectObject(hdc, hOldPen); <br>    SelectObject(hdc, hOldBrush); <br>     <br>return S_OK; <br>} <br> <br>STDMETHODIMP CIELnkCtl::get_Flags(long * pVal) <br>{ <br>*pVal = m_lFlags; <br> <br>return S_OK; <br>} <br> <br>STDMETHODIMP CIELnkCtl::put_Flags(long newVal) <br>{ <br>if (newVal == 0 || newVal == 1) <br>{ <br>m_lMode = newVal; <br> <br>return S_OK; <br>} <br>else <br>return Error(_T("The navigation flag must be either 0 or 1.")); <br>} <br> <br>STDMETHODIMP CIELnkCtl::get_HLink(BSTR * pVal) <br>{ <br>*pVal = m_strHLink; <br> <br>return S_OK; <br>} <br> <br>STDMETHODIMP CIELnkCtl::put_HLink(BSTR newVal) <br>{ <br>m_strHLink = newVal; <br> <br>#ifndef _UNICODE <br>unsigned int nURLLength = m_strHLink.Length(); <br> <br>if(m_pANSIHLink) <br>free(m_pANSIHLink); <br> <br>// Adjust for the terminating NULL character when allocating space <br>m_pANSIHLink = (char *)calloc(nURLLength + 1, 1); <br> <br>wcstombs(m_pANSIHLink, m_strHLink, nURLLength); <br>#endif <br> <br>return S_OK; <br>} <br> <br>STDMETHODIMP CIELnkCtl::get_Location(BSTR * pVal) <br>{ <br>*pVal = m_strLocation; <br> <br>return S_OK; <br>} <br> <br>STDMETHODIMP CIELnkCtl::put_Location(BSTR newVal) <br>{ <br>m_strLocation = newVal; <br> <br>return S_OK; <br>} <br> <br>STDMETHODIMP CIELnkCtl::get_Mode(long * pVal) <br>{ <br>*pVal = m_lMode; <br> <br>return S_OK; <br>} <br> <br>STDMETHODIMP CIELnkCtl::put_Mode(long newVal) <br>{ <br>if (newVal &gt;= 0 &amp;&amp; newVal &lt;= 7) <br>{ <br>m_lMode = newVal; <br> <br>return S_OK; <br>} <br>else <br>return Error(_T("The Mode value must be in the range of 0 through 7.")); <br>} <br> <br>STDMETHODIMP CIELnkCtl::get_TargetFrame(BSTR * pVal) <br>{ <br>*pVal = m_strTargetFrame;  <br> <br>return S_OK; <br>} <br> <br>STDMETHODIMP CIELnkCtl::put_TargetFrame(BSTR newVal) <br>{ <br>m_strTargetFrame = newVal; <br> <br>return S_OK; <br>} <br> <br>STDMETHODIMP CIELnkCtl::GetInterfaceSafetyOptions(REFIID riid, DWORD *pdwSupportedOptions, DWORD *pdwEnabledOptions) <br>{ <br>ATLTRACE(_T("IObjectSafetyImpl::GetInterfaceSafetyOptions\n")); <br>if (pdwSupportedOptions == NULL || pdwEnabledOptions == NULL) <br>return E_POINTER; <br>HRESULT hr = S_OK; <br> <br>if (riid == IID_IDispatch) <br>{ <br>*pdwSupportedOptions = INTERFACESAFE_FOR_UNTRUSTED_CALLER; <br>*pdwEnabledOptions = m_dwSafety &amp; INTERFACESAFE_FOR_UNTRUSTED_CALLER; <br>} <br>else if (riid == IID_IPersistPropertyBag) <br>{ <br>*pdwSupportedOptions = INTERFACESAFE_FOR_UNTRUSTED_DATA; <br>*pdwEnabledOptions = m_dwSafety &amp; INTERFACESAFE_FOR_UNTRUSTED_DATA; <br>} <br>else <br>{ <br>*pdwSupportedOptions = 0; <br>*pdwEnabledOptions = 0; <br>hr = E_NOINTERFACE; <br>} <br>return hr; <br>} <br> <br>STDMETHODIMP CIELnkCtl::SetInterfaceSafetyOptions(REFIID riid, DWORD dwOptionSetMask, DWORD dwEnabledOptions) <br>{ <br>ATLTRACE(_T("IObjectSafetyImpl::SetInterfaceSafetyOptions\n")); <br> <br>// If we're being asked to set our safe for scripting or <br>// safe for initialization options then oblige <br>if (riid == IID_IDispatch || riid == IID_IPersistPropertyBag) <br>{ <br>// Store our current safety level to return in GetInterfaceSafetyOptions <br>m_dwSafety = dwEnabledOptions &amp; dwOptionSetMask; <br>return S_OK; <br>} <br> <br>return E_NOINTERFACE; <br>} <br> <br>STDMETHODIMP CIELnkCtl::Go() <br>{ <br>int nNavFlag; <br>HRESULT hr; <br> <br>// m_lFlags values: <br>// <br>// 0 - Navigate in a new window <br>// 1 - Navigate in the current window <br> <br>if( m_lFlags == 0 ) <br>nNavFlag = HLNF_OPENINNEWWINDOW; <br>else if( m_lFlags == 1)  <br>nNavFlag = HLNF_INTERNALJUMP; <br>else <br>return Error(_T("The navigation flag must be 0 or 1.")); <br> <br>switch (m_lMode) <br>{ <br>case 0 : <br>hr = HlinkSimpleNavigateToString( <br>!m_strHLink ? NULL : (BSTR)m_strHLink, <br>!m_strLocation ? NULL : (BSTR)m_strLocation, <br>!m_strTargetFrame ? NULL : (BSTR)m_strTargetFrame, <br>GetUnknown(), <br>NULL, <br>NULL, <br>nNavFlag, <br>0); <br>break; <br> <br>case 1 : <br>HlinkSimpleNavigateToString( <br>!m_strHLink ? NULL : (BSTR)m_strHLink, <br>!m_strLocation ? NULL : (BSTR)m_strLocation, <br>!m_strTargetFrame ? NULL : (BSTR)m_strTargetFrame, <br>NULL, <br>NULL, <br>NULL, <br>nNavFlag, <br>0); <br>break; <br> <br>case 2 : <br>HlinkNavigateString( <br>GetUnknown(), <br>!m_strHLink ? NULL : (BSTR)m_strHLink); <br>break; <br> <br>case 3 : <br>HlinkNavigateString( <br>NULL, <br>!m_strHLink ? NULL : (BSTR)m_strHLink); <br>break; <br> <br>case 4 : <br>{ <br>IMoniker *pmTarget; <br> <br>::CreateURLMoniker( <br>0, <br>!m_strHLink ? NULL : (BSTR)m_strHLink, <br>&amp;pmTarget); <br> <br>HlinkSimpleNavigateToMoniker( <br>pmTarget, <br>!m_strLocation ? NULL : (BSTR)m_strLocation, <br>!m_strTargetFrame ? NULL : (BSTR)m_strTargetFrame, <br>GetUnknown(), <br>NULL, <br>NULL, <br>nNavFlag, <br>0); <br>} <br>break; <br> <br>case 5 : <br>{ <br>IMoniker *pmTarget; <br> <br>::CreateURLMoniker( <br>0, <br>!m_strHLink ? NULL : (BSTR)m_strHLink, <br>&amp;pmTarget); <br> <br>HlinkSimpleNavigateToMoniker( <br>pmTarget, <br>!m_strLocation ? NULL : (BSTR)m_strLocation, <br>!m_strTargetFrame ? NULL : (BSTR)m_strTargetFrame, <br>NULL,  <br>NULL, <br>NULL, <br>nNavFlag, <br>0); <br>} <br>break; <br> <br>case 6 : <br>{ <br>IMoniker *pmTarget; <br> <br>::CreateURLMoniker( <br>0, <br>!m_strHLink ? NULL : (BSTR)m_strHLink, <br>&amp;pmTarget); <br> <br>HlinkNavigateMoniker( <br>GetUnknown(), <br>pmTarget); <br>} <br>break; <br> <br>case 7 : <br>{ <br>IMoniker *pmTarget; <br> <br>::CreateURLMoniker( <br>0, <br>!m_strHLink ? NULL : (BSTR)m_strHLink, <br>&amp;pmTarget); <br> <br>HlinkNavigateMoniker( <br>NULL, <br>pmTarget); <br>} <br>break; <br> <br>default: <br>return Error(_T("The Mode value must be in the range of 0 through 7.")); <br>} <br> <br>return S_OK; <br>} <br> <br>STDMETHODIMP CIELnkCtl::Forward() <br>{ <br>HlinkGoForward(GetUnknown()); <br> <br>return S_OK; <br>} <br> <br>STDMETHODIMP CIELnkCtl::Back() <br>{ <br>HlinkGoBack(GetUnknown()); <br> <br>return S_OK; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
