<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>ADVQUERY.CXX</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context4225"></a>ADVQUERY.CXX</h2>
<pre><code>//+------------------------------------------------------------------------- <br>// <br>// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF <br>// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO <br>// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A <br>// PARTICULAR PURPOSE. <br>// <br>// Copyright 1997 Microsoft Corporation.  All Rights Reserved. <br>// <br>// PROGRAM:  advquery.cxx <br>// <br>// PURPOSE:  Illustrates a minimal query using Microsoft Index Server. <br>//           Uses native OLE DB, not Index Server helper functions. <br>// <br>// PLATFORM: Windows NT <br>// <br>//-------------------------------------------------------------------------- <br> <br>#define UNICODE <br> <br>#include &lt;stdio.h&gt; <br>#include &lt;windows.h&gt; <br> <br>#define OLEDBVER 0x0200 // need the command tree definitions <br>#define DBINITCONSTANTS <br> <br>#include &lt;oledberr.h&gt; <br>#include &lt;oledb.h&gt; <br> <br>#include &lt;ntquery.h&gt; <br> <br>// This is found in disptree.cxx <br> <br>extern void DisplayCommandTree( DBCOMMANDTREE * pNode, ULONG iLevel = 0 ); <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Template:   XInterface <br>// <br>//  Synopsis:   Template for managing ownership of interfaces <br>// <br>//-------------------------------------------------------------------------- <br> <br>template&lt;class T&gt; class XInterface <br>{ <br>public: <br>    XInterface( T * p = 0 ) : _p( p ) {} <br>    ~XInterface() { if ( 0 != _p ) _p-&gt;Release(); } <br>    T * operator-&gt;() { return _p; } <br>    T * GetPointer() const { return _p; } <br>    IUnknown ** GetIUPointer() { return (IUnknown **) &amp;_p; } <br>    T ** GetPPointer() { return &amp;_p; } <br>    void ** GetQIPointer() { return (void **) &amp;_p; } <br>    T * Acquire() { T * p = _p; _p = 0; return p; } <br> <br>private: <br>    T * _p; <br>}; <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Function:   CreateICommand <br>// <br>//  Synopsis:   Creates an ICommand. <br>// <br>//  Arguments:  [ppICommand] - Where the ICommand is returned on success <br>// <br>//  Returns:    HRESULT result <br>// <br>//-------------------------------------------------------------------------- <br> <br>HRESULT CreateICommand( ICommand ** ppICommand ) <br>{ <br>    // Instantiate the data source object <br> <br>    const GUID CLSID_IndexServerDSO = CLSID_INDEX_SERVER_DSO; <br>    XInterface&lt;IDBInitialize&gt; xIDBInit; <br>    HRESULT hr = CoCreateInstance( CLSID_IndexServerDSO, <br>                                 0, <br>                                 CLSCTX_INPROC_SERVER, <br>                                 IID_IDBInitialize, <br>                                 xIDBInit.GetQIPointer() ); <br> <br>    if ( FAILED(hr) ) <br>        return hr; <br> <br>    // Initialize, verifying that we supplied the right variables <br> <br>    hr = xIDBInit-&gt;Initialize(); <br>    if ( FAILED(hr) ) <br>        return hr; <br> <br>    // Get a session object <br> <br>    XInterface&lt;IDBCreateSession&gt; xIDBSess; <br>    hr = xIDBInit-&gt;QueryInterface( IID_IDBCreateSession, <br>                                   xIDBSess.GetQIPointer() ); <br>    if ( FAILED(hr) ) <br>        return hr; <br> <br>    // Get a Create Command object <br> <br>    XInterface&lt;IDBCreateCommand&gt; xICreateCommand; <br>    hr = xIDBSess-&gt;CreateSession( 0, <br>                                  IID_IDBCreateCommand, <br>                                  xICreateCommand.GetIUPointer() ); <br>    if ( FAILED(hr) ) <br>        return hr; <br> <br>    // Create the ICommand <br> <br>    XInterface&lt;ICommand&gt; xICommand; <br>    hr = xICreateCommand-&gt;CreateCommand( 0, <br>                                         IID_ICommand, <br>                                         xICommand.GetIUPointer() ); <br>    if ( FAILED(hr) ) <br>        return hr; <br> <br>    *ppICommand = xICommand.Acquire(); <br> <br>    return hr; <br>} //CreateICommand <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Function:   SetCommandProperties <br>// <br>//  Synopsis:   Sets the DBPROP_USEEXTENDEDDBTYPES property to TRUE, so <br>//              data is returned in PROPVARIANTs, as opposed to the <br>//              default, which is OLE automation VARIANTs.  PROPVARIANTS <br>//              allow a superset of VARIANT data types.  Use of these <br>//              types avoids costly coercions. <br>// <br>//              Also sets the DBPROP_USECONTENTINDEX property to TRUE, so <br>//              the index will always be used to resolve the query (as <br>//              opposed to enumerating all the files on the disk), even <br>//              if the index is out of date. <br>// <br>//              Both of these properties are unique to Index Server's OLE DB <br>//              implementation. <br>// <br>//  Arguments:  [pICommand] - The ICommand used to set the property <br>// <br>//  Returns:    HRESULT result of setting the properties <br>// <br>//-------------------------------------------------------------------------- <br> <br>HRESULT SetCommandProperties( ICommand * pICommand ) <br>{ <br>    static const DBID dbcolNull = { { 0,0,0, { 0,0,0,0,0,0,0,0 } }, <br>                                    DBKIND_GUID_PROPID, 0 }; <br>    static const GUID guidQueryExt = DBPROPSET_QUERYEXT; <br> <br>    DBPROP aProp[2]; <br> <br>    aProp[0].dwPropertyID = DBPROP_USEEXTENDEDDBTYPES; <br>    aProp[0].dwOptions = DBPROPOPTIONS_SETIFCHEAP; <br>    aProp[0].dwStatus = 0; <br>    aProp[0].colid = dbcolNull; <br>    aProp[0].vValue.vt = VT_BOOL; <br>    aProp[0].vValue.boolVal = VARIANT_TRUE; <br> <br>    aProp[1] = aProp[0]; <br>    aProp[1].dwPropertyID = DBPROP_USECONTENTINDEX; <br> <br>    DBPROPSET aPropSet[1]; <br> <br>    aPropSet[0].rgProperties = &amp;aProp[0]; <br>    aPropSet[0].cProperties = 2; <br>    aPropSet[0].guidPropertySet = guidQueryExt; <br> <br>    XInterface&lt;ICommandProperties&gt; xICommandProperties; <br>    HRESULT hr = pICommand-&gt;QueryInterface( IID_ICommandProperties, <br>                                            xICommandProperties.GetQIPointer() ); <br>    if ( FAILED( hr ) ) <br>        return hr; <br> <br>    return xICommandProperties-&gt;SetProperties( 1,          // 1 property set <br>                                               aPropSet ); // the properties <br>} //SetCommandProperties <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Function:   SetScopeCatalogAndMachine <br>// <br>//  Synopsis:   Sets the catalog and machine properties in the ICommand. <br>//              Also sets a default scope. <br>// <br>//  Arguments:  [pICommand]       - ICommand to set props on <br>//              [pwcQueryScope]   - Scope for the query <br>//              [pwcQueryCatalog] - Catalog name over which query is run <br>//              [pwcQueryMachine] - Machine name on which query is run <br>// <br>//  Returns:    HRESULT result of the operation <br>// <br>//-------------------------------------------------------------------------- <br> <br>HRESULT SetScopeCatalogAndMachine( <br>    ICommand *    pICommand, <br>    WCHAR const * pwcQueryScope, <br>    WCHAR const * pwcQueryCatalog, <br>    WCHAR const * pwcQueryMachine ) <br>{ <br>    // Get an ICommandProperties so we can set the properties <br> <br>    XInterface&lt;ICommandProperties&gt; xICommandProperties; <br>    HRESULT hr = pICommand-&gt;QueryInterface( IID_ICommandProperties, <br>                                            xICommandProperties.GetQIPointer() ); <br>    if ( FAILED( hr ) ) <br>        return hr; <br> <br>    // note: SysAllocString, SafeArrayCreate, and SafeArrayPutElement can <br>    // fail, but this isn't checked here for brevity. <br> <br>    SAFEARRAYBOUND rgBound[1]; <br>    rgBound[0].lLbound = 0; <br>    rgBound[0].cElements = 1; <br>    SAFEARRAY * pMachines = SafeArrayCreate( VT_BSTR, 1, rgBound ); <br>    long i = 0; <br>    SafeArrayPutElement( pMachines, &amp;i, SysAllocString( pwcQueryMachine ) ); <br> <br>    SAFEARRAY * pCatalogs = SafeArrayCreate( VT_BSTR, 1, rgBound ); <br>    SafeArrayPutElement( pCatalogs, &amp;i, SysAllocString( pwcQueryCatalog ) ); <br> <br>    SAFEARRAY * pScopes = SafeArrayCreate( VT_BSTR, 1, rgBound ); <br>    SafeArrayPutElement( pScopes, &amp;i, SysAllocString( pwcQueryScope ) ); <br> <br>    LONG lFlags = QUERY_DEEP; <br>    SAFEARRAY * pFlags = SafeArrayCreate( VT_I4, 1, rgBound ); <br>    SafeArrayPutElement( pFlags, &amp;i, &amp;lFlags ); <br> <br>    DBPROP aScopeProperties[2]; <br>    memset( aScopeProperties, 0, sizeof aScopeProperties ); <br>    aScopeProperties[0].dwPropertyID = DBPROP_CI_INCLUDE_SCOPES; <br>    aScopeProperties[0].vValue.vt = VT_BSTR | VT_ARRAY; <br>    aScopeProperties[0].vValue.parray = pScopes; <br> <br>    aScopeProperties[1].dwPropertyID = DBPROP_CI_SCOPE_FLAGS; <br>    aScopeProperties[1].vValue.vt = VT_I4 | VT_ARRAY; <br>    aScopeProperties[1].vValue.parray = pFlags; <br> <br>    DBPROP aCatalogProperties[1]; <br>    memset( aCatalogProperties, 0, sizeof aCatalogProperties ); <br>    aCatalogProperties[0].dwPropertyID = DBPROP_CI_CATALOG_NAME; <br>    aCatalogProperties[0].vValue.vt = VT_BSTR | VT_ARRAY; <br>    aCatalogProperties[0].vValue.parray = pCatalogs; <br>     <br>    DBPROP aMachineProperties[1]; <br>    memset( aMachineProperties, 0, sizeof aMachineProperties ); <br>    aMachineProperties[0].dwPropertyID = DBPROP_MACHINE; <br>    aMachineProperties[0].vValue.vt = VT_BSTR | VT_ARRAY; <br>    aMachineProperties[0].vValue.parray = pMachines; <br> <br>    const GUID guidFSCI = DBPROPSET_FSCIFRMWRK_EXT; <br>    DBPROPSET aAllPropsets[3]; <br>    aAllPropsets[0].rgProperties = aScopeProperties; <br>    aAllPropsets[0].cProperties = 2; <br>    aAllPropsets[0].guidPropertySet = guidFSCI; <br> <br>    aAllPropsets[1].rgProperties = aCatalogProperties; <br>    aAllPropsets[1].cProperties = 1; <br>    aAllPropsets[1].guidPropertySet = guidFSCI; <br> <br>    const GUID guidCI = DBPROPSET_CIFRMWRKCORE_EXT; <br>    aAllPropsets[2].rgProperties = aMachineProperties; <br>    aAllPropsets[2].cProperties = 1; <br>    aAllPropsets[2].guidPropertySet = guidCI; <br> <br>    const ULONG cPropertySets = sizeof aAllPropsets / sizeof aAllPropsets[0]; <br> <br>    hr = xICommandProperties-&gt;SetProperties( cPropertySets,  // # of propsets <br>                                             aAllPropsets ); // the propsets <br> <br>    SafeArrayDestroy( pScopes ); <br>    SafeArrayDestroy( pFlags ); <br>    SafeArrayDestroy( pCatalogs ); <br>    SafeArrayDestroy( pMachines ); <br> <br>    return hr; <br>} //SetScopeCatalogAndMachine <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Function:   AllocAndCopy <br>// <br>//  Synopsis:   Allocates and duplicates a string. <br>// <br>//  Arguments:  [pwcIn]  - The string to copy <br>// <br>//  Returns:    A string <br>// <br>//-------------------------------------------------------------------------- <br> <br>WCHAR * AllocAndCopy( WCHAR const * pwcIn ) <br>{ <br>    ULONG cwc = wcslen( pwcIn ) + 1; <br> <br>    // note: CoTaskMemAlloc can return 0 if out of memory, not checked <br> <br>    WCHAR * pwc = (WCHAR *) CoTaskMemAlloc( cwc * sizeof WCHAR ); <br>    wcscpy( pwc, pwcIn ); <br>    return pwc; <br>} //AllocAndCopy <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Function:   NewTreeNode <br>// <br>//  Synopsis:   Allocates and initializes a DBCOMMANDTREE object <br>// <br>//  Arguments:  [op]     - The node's operator <br>//              [wKind]  - The kind of node <br>// <br>//  Returns:    an initialized DBCOMMANDTREE object <br>// <br>//-------------------------------------------------------------------------- <br> <br>DBCOMMANDTREE * NewTreeNode( <br>    DBCOMMANDOP op, <br>    WORD        wKind ) <br>{ <br>    DBCOMMANDTREE * pTree = (DBCOMMANDTREE *) <br>                             CoTaskMemAlloc( sizeof DBCOMMANDTREE ); <br>    memset( pTree, 0, sizeof DBCOMMANDTREE ); <br>    pTree-&gt;op = op; <br>    pTree-&gt;wKind = wKind; <br>    return pTree; <br>} //NewTreeNode <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Function:   CreateQueryTree <br>// <br>//  Synopsis:   Creates a DBCOMMANDTREE for the query <br>// <br>//  Arguments:  [pwcQueryRestrition] - The actual query string <br>//              [ppTree]             - Resulting query tree <br>// <br>//  Returns:    HRESULT result of the operation <br>// <br>//  Notes:      The query tree has a string restriction, a list of <br>//              columns to return (rank, size, and path), and a sort <br>//              order (rank). <br>//              Here are two views of the query tree <br>// <br>//                child: project <br>//                  sibling: sort_list_anchor <br>//                    child: sort_list_element <br>//                      value: SORTINFO (descending, lcid) <br>//                      child: column_name <br>//                        value: DBID rank <br>//                  child: select <br>//                    sibling: project_list_anchor <br>//                      child: project_list_element <br>//                        child: column_name <br>//                          value: DBID rank <br>//                        sibling: project_list_element <br>//                          child: column_name <br>//                            value: DBID size <br>//                          sibling: project_list_element <br>//                            child: column_name <br>//                              value: DBID path <br>//                    child: table_name <br>//                      value: WSTR: "Table" <br>//                      sibling: content <br>//                        value: DBCONTENT (restriction, weight, lcid) <br>//                        child: column_name <br>//                          value: DBID contents <br>// <br>// +---------------------------+ <br>// | DBOP_sort                 | <br>// | DBVALUEKIND_EMPTY         | <br>// +---------------------------+ <br>// | <br>// |child <br>// |                            sibling                               <br>// +---------------------------+-------+---------------------------+  <br>// | DBOP_project              |       | DBOP_sort_list_anchor     |  <br>// | DBVALUEKIND_EMPTY         |       | DBVALUEKIND_EMPTY         |  <br>// +---------------------------+       +---------------------------+ <br>// |                                   |                             <br>// |child                              |child                        <br>// |                                   |                             <br>// |                                   +---------------------------+ <br>// |                                   | DBOP_sort_list_element    | <br>// |                                   | DBVALUEKIND_SORTINFO      | <br>// |                                   +---------------------------+ <br>// |                                   |            |            <br>// |                                   |child       | pdbsrtinfValue <br>// |                                   |            |            <br>// |                                   |     +-------------+        <br>// |                                   |     | DBSORTIFO   |        <br>// |                                   |     | fDesc TRUE  | <br>// |                                   |     | lcid system | <br>// |                                   |     +-------------+        <br>// |                                   |                             <br>// |                                   | <br>// |                                   |                             <br>// |                                   +---------------------------+ <br>// |                                   | DBOP_column_name          | <br>// |                                   | DBVALUEKIND_ID            | <br>// |                                   +---------------------------+ <br>// |                                                |                <br>// |                                                | pdbidValue     <br>// |                                                |                <br>// |                                             +------+            <br>// |                                             | DBID |            <br>// |                                             | rank |            <br>// |                                             +------+            <br>// | <br>// |                            sibling <br>// +---------------------------+-------+---------------------------+-------+   <br>// | DBOP_select               |       | DBOP_project_list_anchor  |       | s <br>// | DBVALUEKIND_EMPTY         |       | DBVALUEKIND_EMPTY         |       | i <br>// +---------------------------+       +---------------------------+       | b <br>// |                                   |                                   | l <br>// |child                              |child                              | i <br>// |                                   |                                   | n <br>// |                                   +---------------------------+       | g <br>// |                                   | DBOP_project_list_element |       |  <br>// |                                   | DBVALUEKIND_EMPTY         |       |  <br>// |                                   +---------------------------+       |  <br>// |                                   |                                   | <br>// |                                   |child                              | <br>// |                                   |                                   | <br>// |                                   +---------------------------+       | <br>// |                                   | DBOP_column_name          |       | <br>// |                                   | DBVALUEKIND_ID            |       | <br>// |                                   +---------------------------+       | <br>// |                                                |                      | <br>// |                                                | pdbidValue           | <br>// |                                                |                      | <br>// |                                             +------+                  | <br>// |                                             | DBID |                  | <br>// |                                             | rank |                  | <br>// |                                             +------+                  | <br>// |                                                                       | <br>// |                                   +-----------------------------------+ <br>// |                                   | <br>// |                                   +---------------------------+-------+    <br>// |                                   | DBOP_project_list_element |       | s  <br>// |                                   | DBVALUEKIND_EMPTY         |       | i  <br>// |                                   +---------------------------+       | b  <br>// |                                   |                                   | l  <br>// |                                   |child                              | i  <br>// |                                   |                                   | n  <br>// |                                   +---------------------------+       | g  <br>// |                                   | DBOP_column_name          |       |    <br>// |                                   | DBVALUEKIND_ID            |       |    <br>// |                                   +---------------------------+       |    <br>// |                                                |                      |    <br>// |                                                | pdbidValue           |    <br>// |                                                |                      |    <br>// |                                             +------+                  |    <br>// |                                             | DBID |                  |    <br>// |                                             | size |                  |    <br>// |                                             +------+                  |    <br>// |                                                                       |    <br>// |                                   +-----------------------------------+ <br>// |                                   | <br>// |                                   +---------------------------+ <br>// |                                   | DBOP_project_list_element | <br>// |                                   | DBVALUEKIND_EMPTY         | <br>// |                                   +---------------------------+ <br>// |                                   |                             <br>// |                                   |child                        <br>// |                                   |                             <br>// |                                   +---------------------------+ <br>// |                                   | DBOP_column_name          | <br>// |                                   | DBVALUEKIND_ID            | <br>// |                                   +---------------------------+ <br>// |                                                |                <br>// |                                                | pdbidValue     <br>// |                                                |                <br>// |                                             +------+            <br>// |                                             | DBID |            <br>// |                                             | path |            <br>// |                                             +------+            <br>// |                         <br>// |                            sibling                                <br>// +---------------------------+-------+---------------------------+   <br>// | DBOP_table_name           |       | DBOP_content              |   <br>// | DBVALUEKIND_WSTR: 'Table' |       | DBVALUEKIND_CONTENT       |   <br>// +---------------------------+       +---------------------------+ <br>//                                     |            |               <br>//                                     |child       | pdbcntntValue <br>//                                     |            |               <br>//                                     |  +---------------------------+         <br>//                                     |  | DBCONTENT                 |         <br>//                                     |  | dwGenerateMethod: GENERATE_METHOD_EXACT | <br>//                                     |  | lWeight: 1000             | <br>//                                     |  | lcid: system              | <br>//                                     |  | pwszPhrase: the query     | <br>//                                     |  +---------------------------+    <br>//                                     | <br>//                                     | <br>//                                     |                             <br>//                                     +---------------------------+ <br>//                                     | DBOP_column_name          | <br>//                                     | DBVALUEKIND_ID            | <br>//                                     +---------------------------+ <br>//                                                  |            <br>//                                                  | pdbidValue <br>//                                                  |            <br>//                                             +----------+        <br>//                                             | DBID     |        <br>//                                             | contents |        <br>//                                             +----------+        <br>// <br>//-------------------------------------------------------------------------- <br> <br>HRESULT CreateQueryTree( <br>    WCHAR const *    pwcQueryRestriction, <br>    DBCOMMANDTREE ** ppTree ) <br>{ <br>    // These are the properties that'll be referenced below <br> <br>    const DBID dbidContents = { PSGUID_STORAGE, DBKIND_GUID_PROPID, <br>                                (LPOLESTR) PID_STG_CONTENTS }; <br>    const DBID dbidPath =     { PSGUID_STORAGE, DBKIND_GUID_PROPID, <br>                                (LPOLESTR) PID_STG_PATH }; <br>    const DBID dbidSize =     { PSGUID_STORAGE, DBKIND_GUID_PROPID, <br>                                (LPOLESTR) PID_STG_SIZE }; <br>    DBID dbidRank; <br>    dbidRank.uGuid.guid = PSGUID_QUERY; <br>    dbidRank.eKind = DBKIND_GUID_PROPID; <br>    dbidRank.uName.ulPropid = PROPID_QUERY_RANK ; <br> <br>    // The restriction is a content node with either a word or a phrase. <br>    // This is the most simple possible query.  Other types of nodes include <br>    // AND, OR, NOT, etc. <br>    // The CITextToFullTree function is available for building more complex <br>    // queries given a text string. <br> <br>    DBCOMMANDTREE *pRestriction = NewTreeNode( DBOP_content, <br>                                               DBVALUEKIND_CONTENT ); <br>    DBCONTENT * pDBContent = (DBCONTENT *) CoTaskMemAlloc( sizeof DBCONTENT ); <br>    memset( pDBContent, 0, sizeof DBCONTENT ); <br>    pRestriction-&gt;value.pdbcntntValue = pDBContent; <br>    pDBContent-&gt;dwGenerateMethod = GENERATE_METHOD_EXACT; <br>    pDBContent-&gt;lWeight = 1000; // maximum possible weight <br>    pDBContent-&gt;lcid = GetSystemDefaultLCID(); <br>    pDBContent-&gt;pwszPhrase = AllocAndCopy( pwcQueryRestriction ); <br> <br>    // This identifies "file contents" as the property for the restrition <br> <br>    DBCOMMANDTREE *pPropID = NewTreeNode( DBOP_column_name, DBVALUEKIND_ID ); <br>    pRestriction-&gt;pctFirstChild = pPropID; <br>    DBID *pDBID = (DBID *) CoTaskMemAlloc( sizeof DBID ); <br>    *pDBID = dbidContents; <br>    pPropID-&gt;value.pdbidValue = pDBID; <br> <br>    DBCOMMANDTREE *pSelect = NewTreeNode( DBOP_select, DBVALUEKIND_EMPTY ); <br>    DBCOMMANDTREE *pTableId = NewTreeNode( DBOP_table_name, DBVALUEKIND_WSTR ); <br>    pSelect-&gt;pctFirstChild = pTableId; <br>    pTableId-&gt;value.pwszValue = AllocAndCopy( L"Table" ); <br>    pTableId-&gt;pctNextSibling = pRestriction; <br> <br>    DBCOMMANDTREE *pProject = NewTreeNode( DBOP_project, DBVALUEKIND_EMPTY ); <br>    pProject-&gt;pctFirstChild = pSelect; <br> <br>    // The project anchor holds the list of columns that are retrieved <br> <br>    DBCOMMANDTREE * pProjectAnchor = NewTreeNode( DBOP_project_list_anchor, <br>                                                  DBVALUEKIND_EMPTY ); <br>    pSelect-&gt;pctNextSibling = pProjectAnchor; <br> <br>    // Retrieve rank as column 1 <br> <br>    DBCOMMANDTREE * pProjectRank = NewTreeNode( DBOP_project_list_element, <br>                                                  DBVALUEKIND_EMPTY ); <br>    pProjectAnchor-&gt;pctFirstChild = pProjectRank; <br> <br>    DBCOMMANDTREE * pColumnRank = NewTreeNode( DBOP_column_name, <br>                                               DBVALUEKIND_ID ); <br>    pProjectRank-&gt;pctFirstChild = pColumnRank; <br>    DBID *pDBIDRank = (DBID *) CoTaskMemAlloc( sizeof DBID ); <br>    pColumnRank-&gt;value.pdbidValue = pDBIDRank; <br>    *pDBIDRank = dbidRank; <br> <br>    // Retrieve file size as column 2 <br> <br>    DBCOMMANDTREE * pProjectSize = NewTreeNode( DBOP_project_list_element, <br>                                                DBVALUEKIND_EMPTY ); <br>    pProjectRank-&gt;pctNextSibling = pProjectSize; <br> <br>    DBCOMMANDTREE * pColumnSize = NewTreeNode( DBOP_column_name, <br>                                               DBVALUEKIND_ID ); <br>    pProjectSize-&gt;pctFirstChild = pColumnSize; <br>    DBID *pDBIDSize = (DBID *) CoTaskMemAlloc( sizeof DBID ); <br>    pColumnSize-&gt;value.pdbidValue = pDBIDSize; <br>    *pDBIDSize = dbidSize; <br> <br>    // Retrieve file path as column 3 <br> <br>    DBCOMMANDTREE * pProjectPath = NewTreeNode( DBOP_project_list_element, <br>                                                DBVALUEKIND_EMPTY ); <br>    pProjectSize-&gt;pctNextSibling = pProjectPath; <br> <br>    DBCOMMANDTREE * pColumnPath = NewTreeNode( DBOP_column_name, <br>                                               DBVALUEKIND_ID ); <br>    pProjectPath-&gt;pctFirstChild = pColumnPath; <br>    DBID *pDBIDPath = (DBID *) CoTaskMemAlloc( sizeof DBID ); <br>    pColumnPath-&gt;value.pdbidValue = pDBIDPath; <br>    *pDBIDPath = dbidPath; <br> <br>    // The sort node specifies the sort order for the results <br> <br>    DBCOMMANDTREE * pSort = NewTreeNode( DBOP_sort, DBVALUEKIND_EMPTY ); <br>    pSort-&gt;pctFirstChild = pProject; <br> <br>    // The sort anchor is the start of the list of sort properties <br> <br>    DBCOMMANDTREE * pSortAnchor = NewTreeNode( DBOP_sort_list_anchor, <br>                                               DBVALUEKIND_EMPTY ); <br>    pProject-&gt;pctNextSibling = pSortAnchor; <br> <br>    // The sort order is rank <br> <br>    DBCOMMANDTREE * pSortRank = NewTreeNode( DBOP_sort_list_element, <br>                                             DBVALUEKIND_SORTINFO ); <br>    pSortAnchor-&gt;pctFirstChild = pSortRank; <br> <br>    DBSORTINFO * pSortInfo = (DBSORTINFO *) CoTaskMemAlloc( sizeof DBSORTINFO ); <br>    memset( pSortInfo, 0, sizeof DBSORTINFO ); <br>    pSortRank-&gt;value.pdbsrtinfValue = pSortInfo; <br>    pSortInfo-&gt;fDesc = TRUE; // descending, not ascending <br>    pSortInfo-&gt;lcid = GetSystemDefaultLCID(); <br> <br>    DBCOMMANDTREE * pSortColumnRank = NewTreeNode( DBOP_column_name, <br>                                                   DBVALUEKIND_ID ); <br>    pSortRank-&gt;pctFirstChild = pSortColumnRank; <br>    DBID *pDBIDSortRank = (DBID *) CoTaskMemAlloc( sizeof DBID ); <br>    pSortColumnRank-&gt;value.pdbidValue = pDBIDSortRank; <br>    *pDBIDSortRank = dbidRank; <br> <br>    // The sort node is the head of the tree <br> <br>    *ppTree = pSort; <br> <br>    return S_OK; <br>} //CreateQueryTree <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Function:   DoQuery <br>// <br>//  Synopsis:   Creates and executes a query, then displays the results. <br>// <br>//  Arguments:  [pwcQueryScope]      - Root path for all results <br>//              [pwcQueryCatalog]    - Catalog name over which query is run <br>//              [pwcQueryMachine]    - Machine name on which query is run <br>//              [pwcQueryRestrition] - The actual query string <br>//              [fDisplayTree]       - TRUE to display the command tree <br>// <br>//  Returns:    HRESULT result of the query <br>// <br>//-------------------------------------------------------------------------- <br> <br>HRESULT DoQuery( <br>    WCHAR const * pwcQueryScope, <br>    WCHAR const * pwcQueryCatalog, <br>    WCHAR const * pwcQueryMachine, <br>    WCHAR const * pwcQueryRestriction, <br>    BOOL          fDisplayTree ) <br>{ <br>    // Create an ICommand object.  The default scope for the query is the <br>    // entire catalog. <br> <br>    XInterface&lt;ICommand&gt; xICommand; <br>    HRESULT hr = CreateICommand( xICommand.GetPPointer() ); <br>    if ( FAILED( hr ) ) <br>        return hr; <br> <br>    // Set the scope, catalog, and machine in the ICommand <br> <br>    hr = SetScopeCatalogAndMachine( xICommand.GetPointer(), <br>                                    pwcQueryScope, <br>                                    pwcQueryCatalog, <br>                                    pwcQueryMachine ); <br>    if ( FAILED( hr ) ) <br>        return hr; <br> <br>    // Set required properties on the ICommand <br> <br>    hr = SetCommandProperties( xICommand.GetPointer() ); </code></pre>
<p>
</p>
<pre><code>if ( FAILED( hr ) ) <br>        return hr; <br> <br>    // Create an OLE DB query tree from a text restriction <br> <br>    DBCOMMANDTREE * pTree; <br>    hr = CreateQueryTree( pwcQueryRestriction, // the input query <br>                          &amp;pTree );            // the output tree <br>    if ( FAILED( hr ) ) <br>        return hr; <br> <br>    // If directed, display the command tree <br> <br>    if ( fDisplayTree ) <br>        DisplayCommandTree( pTree ); <br> <br>    // Set the tree in the ICommandTree <br> <br>    XInterface&lt;ICommandTree&gt; xICommandTree; <br>    hr = xICommand-&gt;QueryInterface( IID_ICommandTree, <br>                                    xICommandTree.GetQIPointer() ); <br>    if ( FAILED( hr ) ) <br>        return hr; <br>     <br>    hr = xICommandTree-&gt;SetCommandTree( &amp;pTree, <br>                                        DBCOMMANDREUSE_NONE, <br>                                        FALSE ); <br>    if ( FAILED( hr ) ) <br>        return hr; <br> <br>    // Execute the query.  The query is complete when Execute() returns <br> <br>    XInterface&lt;IRowset&gt; xIRowset; <br>    hr = xICommand-&gt;Execute( 0,            // no aggregating IUnknown <br>                             IID_IRowset,  // IID for interface to return <br>                             0,            // no DBPARAMs <br>                             0,            // no rows affected <br>                             xIRowset.GetIUPointer() ); // result <br>    if ( FAILED( hr ) ) <br>        return hr; <br>     <br>    // Create an accessor, so data can be retrieved from the rowset <br>     <br>    XInterface&lt;IAccessor&gt; xIAccessor; <br>    hr = xIRowset-&gt;QueryInterface( IID_IAccessor, <br>                                   xIAccessor.GetQIPointer() ); <br>    if ( FAILED( hr ) ) <br>        return hr; <br> <br>    // Column iOrdinals are parallel with those passed to CiTextToFullTree, <br>    // so MapColumnIDs isn't necessary.  These binding values for dwPart, <br>    // dwMemOwner, and wType are the most optimal bindings for Index Server. <br> <br>    const ULONG cColumns = 3; // 3 for Rank, Size, and Path <br>    DBBINDING aColumns[ cColumns ]; <br>    memset( aColumns, 0, sizeof aColumns ); <br> <br>    aColumns[0].iOrdinal   = 1; // first column specified above (rank) <br>    aColumns[0].obValue    = 0; // offset where value is written in GetData <br>    aColumns[0].dwPart     = DBPART_VALUE;  // retrieve value, not status <br>    aColumns[0].dwMemOwner = DBMEMOWNER_PROVIDEROWNED; // Index Server owned <br>    aColumns[0].wType      = DBTYPE_VARIANT | DBTYPE_BYREF; // VARIANT * <br> <br>    aColumns[1] = aColumns[0]; <br>    aColumns[1].iOrdinal   = 2; // second column specified above (size) <br>    aColumns[1].obValue    = sizeof (PROPVARIANT *); // offset for value <br> <br>    aColumns[2] = aColumns[0]; <br>    aColumns[2].iOrdinal   = 3; // third column specified above (path) <br>    aColumns[2].obValue    = 2 * sizeof (PROPVARIANT *); // offset for value <br> <br>    HACCESSOR hAccessor; <br>    hr = xIAccessor-&gt;CreateAccessor( DBACCESSOR_ROWDATA, // rowdata accessor <br>                                     cColumns,           // # of columns <br>                                     aColumns,           // columns <br>                                     0,                  // ignored <br>                                     &amp;hAccessor,         // result <br>                                     0 );                // no status <br>    if ( FAILED( hr ) ) <br>        return hr; <br> <br>    // Display the results of the query.  Print file size and file path. <br> <br>    printf( " Rank       Size  Path\n" ); <br>     <br>    ULONG cRowsSoFar = 0; <br> <br>    do <br>    { <br>        ULONG cRowsReturned = 0; <br>        const ULONG cRowsAtATime = 10; <br>        HROW aHRow[cRowsAtATime]; <br>        HROW * pgrHRows = aHRow; <br>        hr = xIRowset-&gt;GetNextRows( 0,              // no chapter <br>                                    0,              // no rows to skip <br>                                    cRowsAtATime,   // # rows to get <br>                                    &amp;cRowsReturned, // # rows returned <br>                                    &amp;pgrHRows);     // resulting hrows <br>     <br>        if ( FAILED( hr ) ) <br>            break; <br>     <br>        for ( ULONG iRow = 0; iRow &lt; cRowsReturned; iRow++ ) <br>        { <br>            PROPVARIANT * aData[cColumns]; <br>            hr = xIRowset-&gt;GetData( aHRow[iRow],  // hrow being accessed <br>                                    hAccessor,    // accessor to use <br>                                    &amp;aData );     // resulting data <br>            if ( FAILED( hr ) ) <br>                break; <br> <br>            if ( VT_I4 ==     aData[0]-&gt;vt &amp;&amp; <br>                 VT_I8 ==     aData[1]-&gt;vt &amp;&amp; <br>                 VT_LPWSTR == aData[2]-&gt;vt ) <br>                printf( "%5d %10I64d  %ws\n", <br>                        aData[0]-&gt;lVal, <br>                        aData[1]-&gt;hVal, <br>                        aData[2]-&gt;pwszVal ); <br>            else <br>                printf( "could not retrieve a file's values\n" ); <br>        } <br>     <br>        if ( 0 != cRowsReturned ) <br>            xIRowset-&gt;ReleaseRows( cRowsReturned, // # of rows to release <br>                                   aHRow,         // rows to release <br>                                   0,             // no options <br>                                   0,             // no refcounts <br>                                   0 );           // no status <br>     <br>        if ( DB_S_ENDOFROWSET == hr ) <br>        { <br>            hr = S_OK; // succeeded, return S_OK from DoQuery <br>            break; <br>        } <br> <br>        if ( FAILED( hr ) ) <br>            break; <br> <br>        cRowsSoFar += cRowsReturned; <br>    } while ( TRUE ); <br> <br>    printf( "%d files matched the query '%ws'\n", <br>            cRowsSoFar, <br>            pwcQueryRestriction ); <br> <br>    xIAccessor-&gt;ReleaseAccessor( hAccessor, 0 ); <br> <br>    return hr; <br>} //DoQuery <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Function:   Usage <br>// <br>//  Synopsis:   Displays information about how to use the app and exits <br>// <br>//-------------------------------------------------------------------------- <br> <br>void Usage() <br>{ <br>    printf( "usage: ADVQUERY query [/c:catalog] [/m:machine] [/s:scope] [/d]\n\n" ); <br>    printf( "    query        word or phrase used for the search\n" ); <br>    printf( "    /c:catalog   name of the catalog, default is SYSTEM\n" ); <br>    printf( "    /m:machine   name of the machine, default is local machine\n" ); <br>    printf( "    /s:scope     root path, default is entire catalog (\\) \n" ); <br>    printf( "    /d           display the DBCOMMANDTREE, default is off\n" ); <br>    exit( -1 ); <br>} //Usage <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Function:   wmain <br>// <br>//  Synopsis:   Entry point for the app.  Parses command line arguments <br>//              and issues a query. <br>// <br>//  Arguments:  [argc]     - Argument count <br>//              [argv]     - Arguments <br>// <br>//-------------------------------------------------------------------------- <br> <br>extern "C" int __cdecl wmain( int argc, WCHAR * argv[] ) <br>{ <br>    WCHAR const * pwcScope       = L"\\";     // default scope: entire catalog <br>    WCHAR const * pwcCatalog     = L"system"; // default: system catalog <br>    WCHAR const * pwcMachine     = L".";      // default: local machine <br>    WCHAR const * pwcRestriction = 0;         // no default restriction <br>    BOOL fDisplayTree            = FALSE;     // don't display the tree <br> <br>    // Parse command line parameters <br> <br>    for ( int i = 1; i &lt; argc; i++ ) <br>    { <br>        if ( L'-' == argv[i][0] || L'/' == argv[i][0] ) <br>        { <br>            WCHAR wc = toupper( argv[i][1] ); <br> <br>            if ( ':' != argv[i][2] &amp;&amp; 'D' != wc ) <br>                Usage(); <br> <br>            if ( 'C' == wc ) <br>                pwcCatalog = argv[i] + 3; <br>            else if ( 'M' == wc ) <br>                pwcMachine = argv[i] + 3; <br>            else if ( 'S' == wc ) <br>                pwcScope = argv[i] + 3; <br>            else if ( 'D' == wc ) <br>                fDisplayTree = TRUE; <br>            else <br>                Usage(); <br>        } <br>        else if ( 0 != pwcRestriction ) <br>            Usage(); <br>        else <br>            pwcRestriction = argv[i]; <br>    } <br> <br>    // A query restriction is necessary.  Fail if none is given. <br> <br>    if ( 0 == pwcRestriction ) <br>        Usage(); <br> <br>    // Initialize COM <br> <br>    HRESULT hr = CoInitialize( 0 ); <br> <br>    if ( SUCCEEDED( hr ) ) <br>    { <br>        // Run the query <br> <br>        hr = DoQuery( pwcScope, <br>                      pwcCatalog, <br>                      pwcMachine, <br>                      pwcRestriction, <br>                      fDisplayTree ); <br> <br>        CoUninitialize(); <br>    } <br> <br>    if ( FAILED( hr ) ) <br>    { <br>        printf( "the query '%ws' failed with error %#x\n", <br>                pwcRestriction, hr ); <br>        return -1; <br>    } <br> <br>    return 0; <br>} //wmain <br> <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
