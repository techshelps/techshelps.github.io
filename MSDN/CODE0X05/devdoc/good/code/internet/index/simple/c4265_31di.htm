<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>QSAMPLE.CXX</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context4266"></a>QSAMPLE.CXX</h2>
<pre><code>//+------------------------------------------------------------------------- <br>// <br>// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF <br>// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO <br>// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A <br>// PARTICULAR PURPOSE. <br>// <br>// Copyright 1997 Microsoft Corporation.  All Rights Reserved. <br>// <br>// PROGRAM:  qsample.cxx <br>// <br>// PURPOSE:  Illustrates a minimal query using Microsoft Index Server. <br>//           Uses CICreateCommand and CITextToFullTree helper functions. <br>// <br>// PLATFORM: Windows NT <br>// <br>//-------------------------------------------------------------------------- <br> <br>#define UNICODE <br> <br>#include &lt;stdio.h&gt; <br>#include &lt;windows.h&gt; <br> <br>#define OLEDBVER 0x0200 // need the command tree definitions <br>#define DBINITCONSTANTS <br> <br>#include &lt;oledberr.h&gt; <br>#include &lt;oledb.h&gt; <br> <br>#include &lt;ntquery.h&gt; <br> <br>// This is found in disptree.cxx <br> <br>extern void DisplayCommandTree( DBCOMMANDTREE * pNode, ULONG iLevel = 0 ); <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Template:   XInterface <br>// <br>//  Synopsis:   Template for managing ownership of interfaces <br>// <br>//-------------------------------------------------------------------------- <br> <br>template&lt;class T&gt; class XInterface <br>{ <br>public: <br>    XInterface( T * p = 0 ) : _p( p ) {} <br>    ~XInterface() { if ( 0 != _p ) _p-&gt;Release(); } <br>    T * operator-&gt;() { return _p; } <br>    T * GetPointer() const { return _p; } <br>    IUnknown ** GetIUPointer() { return (IUnknown **) &amp;_p; } <br>    T ** GetPPointer() { return &amp;_p; } <br>    void ** GetQIPointer() { return (void **) &amp;_p; } <br>    T * Acquire() { T * p = _p; _p = 0; return p; } <br> <br>private: <br>    T * _p; <br>}; <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Function:   SetCommandProperties <br>// <br>//  Synopsis:   Sets the DBPROP_USEEXTENDEDDBTYPES property to TRUE, so <br>//              data is returned in PROPVARIANTs, as opposed to the <br>//              default, which is OLE automation VARIANTs.  PROPVARIANTS <br>//              allow a superset of VARIANT data types.  Use of these <br>//              types avoids costly coercions. <br>// <br>//              Also sets the DBPROP_USECONTENTINDEX property to TRUE, so <br>//              the index will always be used to resolve the query (as <br>//              opposed to enumerating all the files on the disk), even <br>//              if the index is out of date. <br>// <br>//              Both of these properties are unique to Index Server's OLE DB <br>//              implementation. <br>// <br>//  Arguments:  [pICommand] - The ICommand used to set the property <br>// <br>//  Returns:    HRESULT result of setting the properties <br>// <br>//-------------------------------------------------------------------------- <br> <br>HRESULT SetCommandProperties( ICommand * pICommand ) <br>{ <br>    static const DBID dbcolNull = { { 0,0,0, { 0,0,0,0,0,0,0,0 } }, <br>                                    DBKIND_GUID_PROPID, 0 }; <br>    static const GUID guidQueryExt = DBPROPSET_QUERYEXT; <br> <br>    DBPROP aProp[2]; <br> <br>    aProp[0].dwPropertyID = DBPROP_USEEXTENDEDDBTYPES; <br>    aProp[0].dwOptions = DBPROPOPTIONS_SETIFCHEAP; <br>    aProp[0].dwStatus = 0; <br>    aProp[0].colid = dbcolNull; <br>    aProp[0].vValue.vt = VT_BOOL; <br>    aProp[0].vValue.boolVal = VARIANT_TRUE; <br> <br>    aProp[1] = aProp[0]; <br>    aProp[1].dwPropertyID = DBPROP_USECONTENTINDEX; <br> <br>    DBPROPSET aPropSet[1]; <br> <br>    aPropSet[0].rgProperties = &amp;aProp[0]; <br>    aPropSet[0].cProperties = 2; <br>    aPropSet[0].guidPropertySet = guidQueryExt; <br> <br>    XInterface&lt;ICommandProperties&gt; xICommandProperties; <br>    HRESULT hr = pICommand-&gt;QueryInterface( IID_ICommandProperties, <br>                                            xICommandProperties.GetQIPointer() ); <br>    if ( FAILED( hr ) ) <br>        return hr; <br> <br>    return xICommandProperties-&gt;SetProperties( 1,          // 1 property set <br>                                               aPropSet ); // the properties <br>} //SetCommandProperties <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Function:   DoQuery <br>// <br>//  Synopsis:   Creates and executes a query, then displays the results. <br>// <br>//  Arguments:  [pwcQueryCatalog]    - Catalog name over which query is run <br>//              [pwcQueryMachine]    - Machine name on which query is run <br>//              [pwcQueryRestrition] - The actual query string <br>//              [fDisplayTree]       - TRUE to display the command tree <br>// <br>//  Returns:    HRESULT result of the query <br>// <br>//-------------------------------------------------------------------------- <br> <br>HRESULT DoQuery( <br>    WCHAR const * pwcQueryCatalog, <br>    WCHAR const * pwcQueryMachine, <br>    WCHAR const * pwcQueryRestriction, <br>    BOOL          fDisplayTree ) <br>{ <br>    // Create an ICommand object.  The default scope for the query is the <br>    // entire catalog.  CICreateCommand is a shortcut for making an <br>    // ICommand.  The ADVQUERY sample shows the OLE DB equivalent. <br> <br>    XInterface&lt;ICommand&gt; xICommand; <br>    HRESULT hr = CICreateCommand( xICommand.GetIUPointer(), // result <br>                                  0,                  // controlling unknown <br>                                  IID_ICommand,       // IID requested <br>                                  pwcQueryCatalog,    // catalog name <br>                                  pwcQueryMachine );  // machine name <br> <br>    if ( FAILED( hr ) ) <br>        return hr; <br> <br>    // Set required properties on the ICommand <br> <br>    hr = SetCommandProperties( xICommand.GetPointer() ); <br>    if ( FAILED( hr ) ) <br>        return hr; <br> <br> <br>    // Create an OLE DB query tree from a text restriction, column <br>    // set, and sort order. <br> <br>    DBCOMMANDTREE * pTree; <br>    hr = CITextToFullTree( pwcQueryRestriction,      // the query itself <br>                           L"Size,Path",             // columns to return <br>                           0, // no sort. eg L"Rank[d]" for rank descending <br>                           0,                        // reserved <br>                           &amp;pTree,                   // resulting tree <br>                           0,                        // no custom properties <br>                           0,                        // no custom properties <br>                           GetSystemDefaultLCID() ); // default locale <br>    if ( FAILED( hr ) ) <br>        return hr; <br> <br>    // If directed, display the command tree <br> <br>    if ( fDisplayTree ) <br>        DisplayCommandTree( pTree ); <br> <br>    // Set the tree in the ICommandTree <br> <br>    XInterface&lt;ICommandTree&gt; xICommandTree; <br>    hr = xICommand-&gt;QueryInterface( IID_ICommandTree, <br>                                    xICommandTree.GetQIPointer() ); <br>    if ( FAILED( hr ) ) <br>        return hr; <br>     <br>    hr = xICommandTree-&gt;SetCommandTree( &amp;pTree, <br>                                        DBCOMMANDREUSE_NONE, <br>                                        FALSE ); <br>    if ( FAILED( hr ) ) <br>        return hr; <br> <br>    // Execute the query.  The query is complete when Execute() returns <br> <br>    XInterface&lt;IRowset&gt; xIRowset; <br>    hr = xICommand-&gt;Execute( 0,            // no aggregating IUnknown <br>                             IID_IRowset,  // IID for interface to return <br>                             0,            // no DBPARAMs <br>                             0,            // no rows affected <br>                             xIRowset.GetIUPointer() ); // result <br>    if ( FAILED( hr ) ) <br>        return hr; <br>     <br>    // Create an accessor, so data can be retrieved from the rowset <br>     <br>    XInterface&lt;IAccessor&gt; xIAccessor; <br>    hr = xIRowset-&gt;QueryInterface( IID_IAccessor, <br>                                   xIAccessor.GetQIPointer() ); <br>    if ( FAILED( hr ) ) <br>        return hr; <br> <br>    // Column iOrdinals are parallel with those passed to CiTextToFullTree, <br>    // so MapColumnIDs isn't necessary.  These binding values for dwPart, <br>    // dwMemOwner, and wType are the most optimal bindings for Index Server. <br> <br>    const ULONG cColumns = 2; // 2 for Size and Path <br>    DBBINDING aColumns[ cColumns ]; <br>    memset( aColumns, 0, sizeof aColumns ); <br> <br>    aColumns[0].iOrdinal   = 1; // first column specified above (size) <br>    aColumns[0].obValue    = 0; // offset where value is written in GetData <br>    aColumns[0].dwPart     = DBPART_VALUE;  // retrieve value, not status <br>    aColumns[0].dwMemOwner = DBMEMOWNER_PROVIDEROWNED; // Index Server owned <br>    aColumns[0].wType      = DBTYPE_VARIANT | DBTYPE_BYREF; // VARIANT * <br> <br>    aColumns[1] = aColumns[0]; <br>    aColumns[1].iOrdinal   = 2; // second column specified above (path) <br>    aColumns[1].obValue    = sizeof (PROPVARIANT *); // offset for value <br> <br>    HACCESSOR hAccessor; <br>    hr = xIAccessor-&gt;CreateAccessor( DBACCESSOR_ROWDATA, // rowdata accessor <br>                                     cColumns,           // # of columns <br>                                     aColumns,           // columns <br>                                     0,                  // ignored <br>                                     &amp;hAccessor,         // result <br>                                     0 );                // no status <br>    if ( FAILED( hr ) ) <br>        return hr; <br> <br>    // Display the results of the query.  Print file size and file path. <br> <br>    printf( "      Size  Path\n" ); <br>     <br>    ULONG cRowsSoFar = 0; <br> <br>    do <br>    { <br>        ULONG cRowsReturned = 0; <br>        const ULONG cRowsAtATime = 10; <br>        HROW aHRow[cRowsAtATime]; <br>        HROW * pgrHRows = aHRow; <br>        hr = xIRowset-&gt;GetNextRows( 0,              // no chapter <br>                                    0,              // no rows to skip <br>                                    cRowsAtATime,   // # rows to get <br>                                    &amp;cRowsReturned, // # rows returned <br>                                    &amp;pgrHRows);     // resulting hrows <br>     <br>        if ( FAILED( hr ) ) <br>            break; <br>     <br>        for ( ULONG iRow = 0; iRow &lt; cRowsReturned; iRow++ ) <br>        { <br>            PROPVARIANT * aData[cColumns]; <br>            hr = xIRowset-&gt;GetData( aHRow[iRow],  // hrow being accessed <br>                                    hAccessor,    // accessor to use <br>                                    &amp;aData );     // resulting data <br>            if ( FAILED( hr ) ) <br>                break; <br> <br>            if ( VT_I8 ==     aData[0]-&gt;vt &amp;&amp; <br>                 VT_LPWSTR == aData[1]-&gt;vt ) <br>                printf( "%10I64d  %ws\n", <br>                        aData[0]-&gt;hVal, <br>                        aData[1]-&gt;pwszVal ); <br>            else <br>                printf( "could not retrieve a file's values\n" ); <br>        } <br>     <br>        if ( 0 != cRowsReturned ) <br>            xIRowset-&gt;ReleaseRows( cRowsReturned, // # of rows to release <br>                                   aHRow,         // rows to release <br>                                   0,             // no options <br>                                   0,             // no refcounts <br>                                   0 );           // no status <br> <br>        if ( DB_S_ENDOFROWSET == hr ) <br>        { <br>            hr = S_OK; // succeeded, return S_OK from DoQuery <br>            break; <br>        } <br> <br>        if ( FAILED( hr ) ) <br>            break; <br> <br>        cRowsSoFar += cRowsReturned; <br>    } while ( TRUE ); <br> <br>    printf( "%d files matched the query '%ws'\n", <br>            cRowsSoFar, <br>            pwcQueryRestriction ); <br> <br>    xIAccessor-&gt;ReleaseAccessor( hAccessor, 0 ); <br> <br>    return hr; <br>} //DoQuery <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Function:   Usage <br>// <br>//  Synopsis:   Displays information about how to use the app and exits <br>// <br>//-------------------------------------------------------------------------- <br> <br>void Usage() <br>{ <br>    printf( "usage: QSAMPLE query [/c:catalog] [/m:machine] [/d]\n\n" ); <br>    printf( "    query        a Microsoft Index Server query\n" ); <br>    printf( "    /c:catalog   name of the catalog, default is SYSTEM\n" ); <br>    printf( "    /m:machine   name of the machine, default is local machine\n" ); <br>    printf( "    /d           display the DBCOMMANDTREE, default is off\n" ); <br>    exit( -1 ); <br>} //Usage <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Function:   wmain <br>// <br>//  Synopsis:   Entry point for the app.  Parses command line arguments <br>//              and issues a query. <br>// <br>//  Arguments:  [argc]     - Argument count <br>//              [argv]     - Arguments <br>// <br>//-------------------------------------------------------------------------- <br> <br>extern "C" int __cdecl wmain( int argc, WCHAR * argv[] ) <br>{ <br>    WCHAR const * pwcCatalog     = L"system"; // default: system catalog <br>    WCHAR const * pwcMachine     = L".";      // default: local machine <br>    WCHAR const * pwcRestriction = 0;         // no default restriction <br>    BOOL fDisplayTree            = FALSE;     // don't display the tree <br> <br>    // Parse command line parameters <br> <br>    for ( int i = 1; i &lt; argc; i++ ) <br>    { <br>        if ( L'-' == argv[i][0] || L'/' == argv[i][0] ) <br>        { <br>            WCHAR wc = toupper( argv[i][1] ); <br> <br>            if ( ':' != argv[i][2] &amp;&amp; 'D' != wc ) <br>                Usage(); <br> <br>            if ( 'C' == wc ) <br>                pwcCatalog = argv[i] + 3; <br>            else if ( 'M' == wc ) <br>                pwcMachine = argv[i] + 3; <br>            else if ( 'D' == wc ) <br>                fDisplayTree = TRUE; <br>            else <br>                Usage(); <br>        } <br>        else if ( 0 != pwcRestriction ) <br>            Usage(); <br>        else <br>            pwcRestriction = argv[i]; <br>    } <br> <br>    // A query restriction is necessary.  Fail if none is given. <br> <br>    if ( 0 == pwcRestriction ) <br>        Usage(); <br> <br>    // Run the query <br> <br>    HRESULT hr = DoQuery( pwcCatalog, <br>                          pwcMachine, <br>                          pwcRestriction, <br>                          fDisplayTree ); <br> <br>    if ( FAILED( hr ) ) <br>    { <br>        printf( "the query '%ws' failed with error %#x\n", <br>                pwcRestriction, hr ); <br>        return -1; <br>    } <br> <br>    return 0; <br>} //wmain <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
