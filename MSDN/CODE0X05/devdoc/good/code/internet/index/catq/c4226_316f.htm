<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CIQUERY.CXX</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context4227"></a>CIQUERY.CXX</h2>
<pre><code>/*++ <br> <br>Copyright 1992 - 1998 Microsoft Corporation, All rights reserved. <br> <br>    THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF <br>    ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO <br>    THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A <br>    PARTICULAR PURPOSE. <br> <br>Module Name: <br> <br>    ciquery.cxx <br> <br>Abstract: <br> <br>    Perform queries against the content index catalog generated by <br>     the Microsoft Index Server. <br> <br>Platform: <br> <br>    Windows NT <br> <br>Revision History: <br> <br>    David Lee                      Wrote it. <br>    Steve Firebaugh                Modified slightly to work in GUI context. <br> <br>--*/ <br> <br>#include &lt;stdio.h&gt; <br>#include &lt;windows.h&gt; <br> <br>#define OLEDBVER 0x0200 // need the command tree definitions <br>#define DBINITCONSTANTS <br> <br>#include &lt;oledberr.h&gt; <br>#include &lt;oledb.h&gt; <br> <br>#include &lt;ntquery.h&gt; <br> <br>#include "catq.h" <br> <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Template:   XInterface <br>// <br>//  Synopsis:   Template for managing ownership of interfaces <br>// <br>//-------------------------------------------------------------------------- <br> <br>template&lt;class T&gt; class XInterface <br>{ <br>public: <br>    XInterface( T * p = 0 ) : _p( p ) {} <br>    ~XInterface() { if ( 0 != _p ) _p-&gt;Release(); } <br>    T * operator-&gt;() { return _p; } <br>    T * GetPointer() const { return _p; } <br>    IUnknown ** GetIUPointer() { return (IUnknown **) &amp;_p; } <br>    T ** GetPPointer() { return &amp;_p; } <br>    void ** GetQIPointer() { return (void **) &amp;_p; } <br>    T * Acquire() { T * p = _p; _p = 0; return p; } <br> <br>private: <br>    T * _p; <br>}; <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Function:   SetCommandProperties <br>// <br>//  Synopsis:   Sets the DBPROP_USEEXTENDEDDBTYPES property to TRUE, so <br>//              data is returned in PROPVARIANTs, as opposed to the <br>//              default, which is OLE automation VARIANTs.  PROPVARIANTS <br>//              allow a superset of VARIANT data types.  Use of these <br>//              types avoids costly coercions. <br>// <br>//              Also sets the DBPROP_USECONTENTINDEX property to TRUE, so <br>//              the index will always be used to resolve the query (as <br>//              opposed to enumerating all the files on the disk), even <br>//              if the index is out of date. <br>// <br>//              Both of these properties are unique to Index Server's OLE DB <br>//              implementation. <br>// <br>//  Arguments:  [pICommand] - The ICommand used to set the property <br>// <br>//  Returns:    HRESULT result of setting the properties <br>// <br>//-------------------------------------------------------------------------- <br> <br>HRESULT SetCommandProperties( ICommand * pICommand, WCHAR const * pwcQueryScope ) <br>{ <br>    static const DBID dbcolNull = { { 0,0,0, { 0,0,0,0,0,0,0,0 } }, <br>                                    DBKIND_GUID_PROPID, 0 }; <br>    static const GUID guidQueryExt = DBPROPSET_QUERYEXT; <br>    static const GUID guidFSCIFRMWRK = DBPROPSET_FSCIFRMWRK_EXT; <br> <br>    DBPROP aProp[2]; <br> <br>    aProp[0].dwPropertyID = DBPROP_USEEXTENDEDDBTYPES; <br>    aProp[0].dwOptions = DBPROPOPTIONS_SETIFCHEAP; <br>    aProp[0].dwStatus = 0; <br>    aProp[0].colid = dbcolNull; <br>    aProp[0].vValue.vt = VT_BOOL; <br>    aProp[0].vValue.boolVal = VARIANT_TRUE; <br> <br>    aProp[1] = aProp[0]; <br>    aProp[1].dwPropertyID = DBPROP_USECONTENTINDEX; <br> <br> <br>    SAFEARRAYBOUND rgBound[1]; <br>    rgBound[0].lLbound = 0; <br>    rgBound[0].cElements = 1; <br>    DBPROP aScopeProperties[2]; <br>    LONG lFlags = QUERY_DEEP; <br>    long i = 0; <br> <br>    SAFEARRAY * pScopes = SafeArrayCreate( VT_BSTR, 1, rgBound ); <br>    if (!pScopes) return GetLastError(); <br>    SafeArrayPutElement( pScopes, &amp;i, SysAllocString( pwcQueryScope ) ); <br> <br>    SAFEARRAY * pFlags = SafeArrayCreate( VT_I4, 1, rgBound ); <br>    if (!pFlags) return GetLastError(); <br>    SafeArrayPutElement( pFlags, &amp;i, &amp;lFlags ); <br> <br>    memset( aScopeProperties, 0, sizeof aScopeProperties ); <br>    aScopeProperties[0].dwPropertyID = DBPROP_CI_INCLUDE_SCOPES; <br>    aScopeProperties[0].vValue.vt = VT_BSTR | VT_ARRAY; <br>    aScopeProperties[0].vValue.parray = pScopes; <br> <br>    aScopeProperties[1].dwPropertyID = DBPROP_CI_SCOPE_FLAGS; <br>    aScopeProperties[1].vValue.vt = VT_I4 | VT_ARRAY; <br>    aScopeProperties[1].vValue.parray = pFlags; <br> <br> <br> <br>    DBPROPSET aPropSet[2]; <br> <br>    aPropSet[1].rgProperties = &amp;aProp[0]; <br>    aPropSet[1].cProperties = 2; <br>    aPropSet[1].guidPropertySet = guidQueryExt; <br> <br>    aPropSet[0].rgProperties = &amp;aScopeProperties[0]; <br>    aPropSet[0].cProperties = 2; <br>    aPropSet[0].guidPropertySet = guidFSCIFRMWRK; <br> <br>    XInterface&lt;ICommandProperties&gt; xICommandProperties; <br>    HRESULT hr = pICommand-&gt;QueryInterface( IID_ICommandProperties, <br>                                            xICommandProperties.GetQIPointer() ); <br>    if ( FAILED( hr ) ) <br>        return hr; <br> <br>    hr = xICommandProperties-&gt;SetProperties( 2,          // 2 properties set <br>                                             aPropSet ); // the properties <br> <br> <br>    SafeArrayDestroy( pScopes ); <br>    SafeArrayDestroy( pFlags ); <br> <br>    return hr; <br> <br>} //SetCommandProperties <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Function:   DoQuery <br>// <br>//  Synopsis:   Creates and executes a query, then displays the results. <br>// <br>//  Arguments:  [pwcQueryCatalog]    - Catalog name over which query is run <br>//              [pwcQueryMachine]    - Machine name on which query is run <br>//              [pwcQueryScope]      - Directory scope to constrain the search <br>//              [pwcQueryRestrition] - The actual query string <br>// <br>//  Returns:    HRESULT result of the query <br>// <br>//-------------------------------------------------------------------------- <br> <br>HRESULT DoQuery( <br>    WCHAR const * pwcQueryCatalog, <br>    WCHAR const * pwcQueryMachine, <br>    WCHAR const * pwcQueryScope, <br>    WCHAR const * pwcQueryRestriction) <br>{ <br>    // Create an ICommand object.  The default scope for the query is the <br>    // entire catalog.  CICreateCommand is a shortcut for making an <br>    // ICommand.  The ADVQUERY sample shows the OLE DB equivalent. <br> <br>    XInterface&lt;ICommand&gt; xICommand; <br>    HRESULT hr = CICreateCommand( xICommand.GetIUPointer(), // result <br>                                  0,                  // controlling unknown <br>                                  IID_ICommand,       // IID requested <br>                                  pwcQueryCatalog,    // catalog name <br>                                  pwcQueryMachine );  // machine name <br> <br>    if ( FAILED( hr ) ) <br>        return hr; <br> <br>    // Set required properties on the ICommand <br> <br>    hr = SetCommandProperties( xICommand.GetPointer(), pwcQueryScope ); <br>    if ( FAILED( hr ) ) <br>        return hr; <br> <br> <br>    // Create an OLE DB query tree from a text restriction, column <br>    // set, and sort order. <br> <br>    DBCOMMANDTREE * pTree; <br>    hr = CITextToFullTree( pwcQueryRestriction,      // the query itself <br>                           L"Size,Path",             // columns to return <br>                           L"Rank[d]",               // sort rank-descending <br>                           0,                        // reserved <br>                           &amp;pTree,                   // resulting tree <br>                           0,                        // no custom properties <br>                           0,                        // no custom properties <br>                           GetSystemDefaultLCID() ); // default locale <br>    if ( FAILED( hr ) ) <br>        return hr; <br> <br>    // Set the tree in the ICommandTree <br> <br>    XInterface&lt;ICommandTree&gt; xICommandTree; <br>    hr = xICommand-&gt;QueryInterface( IID_ICommandTree, <br>                                    xICommandTree.GetQIPointer() ); <br>    if ( FAILED( hr ) ) <br>        return hr; <br>     <br>    hr = xICommandTree-&gt;SetCommandTree( &amp;pTree, <br>                                        DBCOMMANDREUSE_NONE, <br>                                        FALSE ); <br>    if ( FAILED( hr ) ) <br>        return hr; <br> <br>    // Execute the query.  The query is complete when Execute() returns <br> <br>    XInterface&lt;IRowset&gt; xIRowset; <br>    hr = xICommand-&gt;Execute( 0,            // no aggregating IUnknown <br>                             IID_IRowset,  // IID for interface to return <br>                             0,            // no DBPARAMs <br>                             0,            // no rows affected <br>                             xIRowset.GetIUPointer() ); // result <br>    if ( FAILED( hr ) ) <br>        return hr; <br>     <br>    // Create an accessor, so data can be retrieved from the rowset <br>     <br>    XInterface&lt;IAccessor&gt; xIAccessor; <br>    hr = xIRowset-&gt;QueryInterface( IID_IAccessor, <br>                                   xIAccessor.GetQIPointer() ); <br>    if ( FAILED( hr ) ) <br>        return hr; <br> <br>    // Column iOrdinals are parallel with those passed to CiTextToFullTree, <br>    // so MapColumnIDs isn't necessary.  These binding values for dwPart, <br>    // dwMemOwner, and wType are the most optimal bindings for Index Server. <br> <br>    const ULONG cColumns = 2; // 2 for Size and Path <br>    DBBINDING aColumns[ cColumns ]; <br>    memset( aColumns, 0, sizeof aColumns ); <br> <br>    aColumns[0].iOrdinal   = 1; // first column specified above (size) <br>    aColumns[0].obValue    = 0; // offset where value is written in GetData <br>    aColumns[0].dwPart     = DBPART_VALUE;  // retrieve value, not status <br>    aColumns[0].dwMemOwner = DBMEMOWNER_PROVIDEROWNED; // Index Server owned <br>    aColumns[0].wType      = DBTYPE_VARIANT | DBTYPE_BYREF; // VARIANT * <br> <br>    aColumns[1] = aColumns[0]; <br>    aColumns[1].iOrdinal   = 2; // second column specified above (path) <br>    aColumns[1].obValue    = sizeof (PROPVARIANT *); // offset for value <br> <br>    HACCESSOR hAccessor; <br>    hr = xIAccessor-&gt;CreateAccessor( DBACCESSOR_ROWDATA, // rowdata accessor <br>                                     cColumns,           // # of columns <br>                                     aColumns,           // columns <br>                                     0,                  // ignored <br>                                     &amp;hAccessor,         // result <br>                                     0 );                // no status <br>    if ( FAILED( hr ) ) <br>        return hr; <br> <br>    // Display the results of the query.  Print file size and file path. <br> <br>     <br>    ULONG cRowsSoFar = 0; <br> <br>    do <br>    { <br>        ULONG cRowsReturned = 0; <br>        const ULONG cRowsAtATime = 10; <br>        HROW aHRow[cRowsAtATime]; <br>        HROW * pgrHRows = aHRow; <br>        hr = xIRowset-&gt;GetNextRows( 0,              // no chapter <br>                                    0,              // no rows to skip <br>                                    cRowsAtATime,   // # rows to get <br>                                    &amp;cRowsReturned, // # rows returned <br>                                    &amp;pgrHRows);     // resulting hrows <br>     <br>        if ( FAILED( hr ) ) <br>            break; <br> <br> <br>        for ( ULONG iRow = 0; iRow &lt; cRowsReturned; iRow++ ) <br>        { <br>            PROPVARIANT * aData[cColumns]; <br>            hr = xIRowset-&gt;GetData( aHRow[iRow],  // hrow being accessed <br>                                    hAccessor,    // accessor to use <br>                                    &amp;aData );     // resulting data <br>            if ( FAILED( hr ) ) <br>                break; <br> <br> <br>            if ( VT_I8 ==     aData[0]-&gt;vt &amp;&amp; <br>                 VT_LPWSTR == aData[1]-&gt;vt ) <br>                catqReportResultsVariable( <br>                        TEXT("%s"), <br>                        aData[1]-&gt;pwszVal ); <br>            else <br>                catqLogComment( TEXT("could not retrieve a file's values" )); <br>        } <br>     <br>        if ( 0 != cRowsReturned ) <br>            xIRowset-&gt;ReleaseRows( cRowsReturned, // # of rows to release <br>                                   aHRow,         // rows to release <br>                                   0,             // no options <br>                                   0,             // no refcounts <br>                                   0 );           // no status <br> <br>        if ( DB_S_ENDOFROWSET == hr ) <br>        { <br>            hr = S_OK; // succeeded, return S_OK from DoQuery <br>            break; <br>        } <br> <br>        if ( FAILED( hr ) ) <br>            break; <br> <br>        cRowsSoFar += cRowsReturned; <br>    } while ( TRUE ); <br> <br>    catqLogCommentVariable( <br>            TEXT("%d files matched the query '%s'"), <br>            cRowsSoFar, <br>            pwcQueryRestriction ); <br> <br>    xIAccessor-&gt;ReleaseAccessor( hAccessor, 0 ); <br> <br>    return hr; <br>} //DoQuery </code></pre>
<p>&nbsp;</p></body>
</HTML>
