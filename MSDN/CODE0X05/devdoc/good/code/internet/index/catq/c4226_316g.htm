<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>MAIN.CXX</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context4228"></a>MAIN.CXX</h2>
<pre><code>/*++ <br> <br>Copyright 1992 - 1998 Microsoft Corporation, All rights reserved. <br> <br>    THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF <br>    ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO <br>    THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A <br>    PARTICULAR PURPOSE. <br> <br>Module Name: <br> <br>    main.cxx <br> <br>Abstract: <br> <br>    WinMain() and other functions required to interact with Windows. <br> <br>Revision History: <br> <br>    Steve Firebaugh     9-97          Created from previous samples <br> <br>--*/ <br> <br> <br>#include &lt;windows.h&gt; <br>#include &lt;commctrl.h&gt; <br>#include &lt;ntquery.h&gt; <br>#include "catq.h" <br> <br> <br>// <br>// Declare a global HWND for this module.  It will contain the window <br>//  handle for the main dialog.  Make it global so that the comment <br>//  and result reporting functions in this module do not require HWND <br>//  parameters (since they are called from other modules that don't <br>//  need to know anything about HWND). <br>// <br> <br>HWND hwndGlobalDlg = NULL; <br> <br> <br> <br> <br>int APIENTRY WinMain(HINSTANCE hInstance, <br>                     HINSTANCE hPrevInstance, <br>                     LPSTR lpCmdLine, <br>                     int nCmdShow) <br>/*++ <br> <br>  required for all WIN32 applications <br>  input parameters:  c.f. generic sample <br> <br>--*/ <br>{ <br>    int iRet; <br> <br>    UNREFERENCED_PARAMETER( hPrevInstance ); <br>    UNREFERENCED_PARAMETER( lpCmdLine ); <br>    UNREFERENCED_PARAMETER( nCmdShow); <br> <br> <br>    // <br>    // Detect platform and exit gracefully if app will not work correctly. <br>    //  notice that this may need to be updated over time if/when Index Server <br>    //  is expanded to run on additional platforms. <br>    // <br>    // Here we check first for Windows NT, and then for version 5 or greater. <br>    // <br> <br>    { <br>      OSVERSIONINFO osvi; <br>      osvi.dwOSVersionInfoSize = sizeof (OSVERSIONINFO); <br>      GetVersionEx (&amp;osvi); <br> <br>      if (osvi.dwPlatformId != VER_PLATFORM_WIN32_NT) { <br>        MessageBox (NULL, <br>                    TEXT ("Application requires Windows NT"), <br>                    SZ_APP_TITLE, <br>                    MB_OK | MB_ICONSTOP); <br>        return 0; <br>      } <br> <br>      if (osvi.dwMajorVersion &lt; 5) { <br>        MessageBox (NULL, <br>                    TEXT ("Application requires at least Windows NT version 5"), <br>                    SZ_APP_TITLE, <br>                    MB_OK | MB_ICONSTOP); <br>        return 0; <br>      } <br>    }  // end version checking <br> <br> <br> <br>    // <br>    // Just put up a dialog box that does all of the work.  Interesting code <br>    //  is in the MainDlgProc() below. <br>    // <br>    // Here we use DialogBoxParam() rather than just DialogBox(), because we <br>    //  want to pass the hInstance to the WM_INITDIALOG message. <br>    // <br> <br>    iRet = DialogBoxParam (hInstance, <br>                           TEXT("mainDlg"), <br>                           NULL, <br>                           (DLGPROC)MainDlgProc, <br>                           (LONG) hInstance); <br>    return iRet; <br>} <br> <br> <br> <br> <br>LRESULT CALLBACK MainDlgProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam) <br>/*++ <br> <br>  standard WIN32 dialog procedure for the main window <br> <br>  input parameters:  c.f. generic sample <br> <br>--*/ <br>{ <br> <br>  switch (message) { <br> <br>    case WM_INITDIALOG: { <br> <br>      // <br>      // Store the hwnd in the global variable for use later. <br>      // <br> <br>      hwndGlobalDlg = hwnd; <br> <br> <br>      // <br>      // The dialog template in the .rc file specifies the location and size <br>      //  of most of the "child controls."  However, we also want a status bar <br>      //  on the bottom of the main window.  Create the status bar here, but <br>      //  before doing that, call the Windows function to initialize the <br>      //  common controls.  StatusBars and ProgressBars are "common controls" <br>      //  and will not work until InitCommonControls is called. <br>      // <br> <br>      InitCommonControls (); <br>      catqCreateStatusBar (hwnd); <br> <br> <br>      // <br>      // Set the font for the text display windows to be a fixed width font <br>      // <br> <br>      SendDlgItemMessage (hwnd, <br>                          DID_OUTRESULTS, <br>                          WM_SETFONT, <br>                          (WPARAM) GetStockObject (ANSI_FIXED_FONT), <br>                          (LPARAM) 0 ); <br> <br>      // <br>      // Set initial values into the input controls.  For the machine this <br>      //  is just "."  For the catalog, we call the appropriate query API. <br>      //  For the directory scope, we try to locate the SDK.  For the search <br>      //  text we start with some friendly initial string. <br>      // <br> <br>      { WCHAR szbuffer[MAX_PATH]; <br> <br>      SetWindowText (GetDlgItem (hwnd, DID_MACHINE), TEXT(".")); <br> <br>      catqInitializeSDKPath (GetDlgItem (hwnd, DID_SCOPE), szbuffer); <br> <br>      catqInitializeCatalogs (GetDlgItem (hwnd, DID_CATALOG), szbuffer); <br> <br>      SetWindowText (GetDlgItem (hwnd, DID_CONTAIN), TEXT("&lt;search text here&gt;")); <br>      } <br> <br>      // <br>      // Select all of the text in the search-string edit control so that <br>      //  anything the user types will replace what is there. <br>      // <br> <br>      SendMessage (GetDlgItem (hwnd, DID_CONTAIN), EM_SETSEL, 0, MAX_PATH); <br>      SetFocus ( GetDlgItem (hwnd, DID_CONTAIN)); <br> <br> <br>      // <br>      // Since main window is a dialog it does not get an app defined icon <br>      //  by default... so, load one out of the built in resources, and <br>      //  associate it with this window.  Notice hInstance passed in as <br>      //  lParam ala DialogBoxParam(). <br>      // <br> <br>      SendMessage (hwnd, WM_SETICON, ICON_BIG, (LPARAM) LoadIcon ((HINSTANCE)lParam, TEXT("catqIcon"))); <br> <br> <br>      // <br>      // Start a window timer to post us a messsage every one second. <br>      //  Use this later to keep fields in the status bar up-to-date. <br>      // <br> <br>      SetTimer (hwnd, TID_PROGRESS, 1000, NULL); <br> <br> <br>      // <br>      // Content indexing is only available if the correct service is running. <br>      //  Ensure that it is running, or start it if it is not. <br>      // <br> <br>      catqStartCIService ( hwnd ); <br> <br>      return FALSE; <br>    } break;  // WM_INITDIALOG <br> <br> <br>    case WM_TIMER: <br> <br>      // <br>      // Timer messages with ID of TID_PROGRESS indicate that we should <br>      //  query the progress of the indexing effort. <br>      // <br> <br>      if ((int) wParam == TID_PROGRESS) { <br>        LONG lTotal, lFinished; <br>        int iProgress; <br> <br>        iProgress = catqPDHQueryProgress (&amp;lFinished, &amp;lTotal); <br> <br>        catqUpdateProgress (GetDlgItem (hwnd, DID_STATUSBAR), <br>                            iProgress, <br>                            lFinished, lTotal); <br> <br> <br>      } <br>    break; <br> <br> <br>    case WM_COMMAND: <br> <br>    // <br>    // Handle the events caused by the buttons on the main page <br>    // <br> <br>      switch (LOWORD(wParam)) { <br> <br>        // <br>        // When one of the files in the listbox is double clicked, launch <br>        //  the file that has been selected.  If ShellExecute() fails, try <br>        //  to load the file into notepad.  This will work for all "text files" <br>        //  but will look ugly for "binary files" that are indexed. <br>        // <br> <br>        case DID_OUTRESULTS      : <br>          if (HIWORD (wParam) == LBN_DBLCLK) { <br>            HWND hwndLB; <br>            LRESULT lRet; <br>            TCHAR pszBuffer [ MAX_PATH ] ; <br> <br>            hwndLB = GetDlgItem (hwnd, DID_OUTRESULTS); <br>            lRet = SendMessage (hwndLB, LB_GETCURSEL, 0,0); <br>            lRet = SendMessage (hwndLB, LB_GETTEXT, (WPARAM)lRet, (LPARAM) pszBuffer); <br> <br>            lRet = (LRESULT) ShellExecute (NULL, <br>                                           TEXT("open"), <br>                                           pszBuffer, <br>                                           NULL, <br>                                           NULL, <br>                                           SW_SHOW); <br> <br>            if (lRet &lt;= 32 ) { // magic number, see docs <br>              catqLogCommentVariable (TEXT ("ShellExecute (%s) failed (%d).  Loading into notepad." ), <br>                                      pszBuffer, lRet); <br>              lRet = (LRESULT) ShellExecute (NULL, <br>                                             TEXT("open"), <br>                                             TEXT("notepad"), <br>                                             pszBuffer, <br>                                             NULL, <br>                                             SW_SHOW); <br>            } <br>          } <br>        break; <br> <br> <br>        // <br>        // When the "find now" button is hit, take appropriate action. <br>        // <br> <br>        case DID_FINDNOW      : { <br>           TCHAR szCatalog[MAX_PATH]     = TEXT(""); <br>           TCHAR szMachine[MAX_PATH]     = TEXT(""); <br>           TCHAR szScope[MAX_PATH]     = TEXT(""); <br>           TCHAR szRestriction[MAX_PATH] = TEXT(""); <br> <br>           HRESULT hr; <br> <br>           // <br>           // Clear out the old results list from the listbox, <br>           // <br> <br>           SendMessage( GetDlgItem (hwnd, DID_OUTRESULTS), <br>                        LB_RESETCONTENT, 0, 0); <br> <br> <br>           // <br>           // Query the edit controls for the user specified parameters <br>           // <br> <br>           GetWindowText (GetDlgItem (hwnd, DID_CATALOG), <br>                         szCatalog, <br>                         MAX_PATH); <br> <br>           GetWindowText (GetDlgItem (hwnd, DID_MACHINE), <br>                         szMachine, <br>                         MAX_PATH); <br> <br>           GetWindowText (GetDlgItem (hwnd, DID_SCOPE), <br>                         szScope, <br>                         MAX_PATH); <br> <br>           GetWindowText (GetDlgItem (hwnd, DID_CONTAIN), <br>                         szRestriction, <br>                         MAX_PATH); <br> <br> <br>           // <br>           // And finally, with these parameters, call our own function <br>           //  to perform the query (and display the results). <br>           // <br> <br>           hr = DoQuery( szCatalog, <br>                         szMachine, <br>                         szScope, <br>                         szRestriction); <br> <br>           if ( FAILED( hr ) ) <br>           { <br>               catqReportError ( hr ); <br>               return 0; <br>           } <br> <br>        } break; <br> <br>      } // end switch (LOWORD()) <br> <br>    break; // WM_COMMAND <br> <br> <br> <br>    case WM_SIZE: { <br> <br>      // <br>      // Pass the WM_SIZE along to the status bar window procedure (provided <br>      //  by windows, not part of this application code)...  it will resize <br>      //  itself to fit in the bottom of the window... once this is done, <br>      //  re-space the different sections of  the status bar with our function. <br>      // <br> <br>      SendMessage (GetDlgItem (hwnd, DID_STATUSBAR), <br>                   WM_SIZE, wParam, lParam); <br> <br>      catqPartitionStatusBar (GetDlgItem (hwnd, DID_STATUSBAR)); <br> <br> <br> <br>      // <br>      // Adjust the large list box to fill the remainder of the window. <br>      // <br> <br>#define NICEBORDER 5 <br>#define BELOWINPUTCONTROLS 100 <br> <br>      int x, y, cx, cy; <br>      int nWidth, nHeight; <br>      RECT rect; <br> <br>      nWidth = LOWORD (lParam); <br>      nHeight = HIWORD (lParam); <br> <br>      SendMessage (GetDlgItem (hwnd, DID_STATUSBAR), SB_GETRECT, 0, (LPARAM) &amp;rect); <br> <br>      x = NICEBORDER; <br>      cx = nWidth - (2* NICEBORDER); <br> <br>      nHeight -= BELOWINPUTCONTROLS; <br>      nHeight -= rect.bottom; <br>      nHeight -= 2* NICEBORDER; <br> <br>      cy = (nHeight &gt; 0) ? nHeight : 0; <br> <br>      y = BELOWINPUTCONTROLS + NICEBORDER; <br>      SetWindowPos ( GetDlgItem (hwnd, DID_OUTRESULTS), <br>                    NULL, <br>                    x, <br>                    y, <br>                    cx, <br>                    cy, <br>                    SWP_NOZORDER); <br>      return 0; <br> <br>    } break; // WM_SIZE <br> <br> <br>    case WMAPP_ADDRESULT: <br> <br>      // <br>      // Application defined message. <br>      // <br>      // Append a new file name to the bottom of the results listbox. <br>      // <br>      // wParam is ignored <br>      // lParam is pointer to the string to add to the listbox. <br>      // <br> <br>      SendMessage (GetDlgItem (hwnd, DID_OUTRESULTS), <br>                     LB_ADDSTRING, 0, lParam); <br> <br>    break; <br> <br> <br>    case WM_SYSCOMMAND: <br> <br>    // <br>    //  ignore all syscommand messages, except for SC_CLOSE.  On this one, <br>    //   log one final comment for the debugger output and call EndDialog(). <br>    // <br> <br>      if (wParam == SC_CLOSE) { <br> <br>        catqLogComment (TEXT("bye.")); <br> <br>        EndDialog (hwnd, TRUE); <br>        return TRUE; <br>      } else <br>        return FALSE; <br>    break; <br> <br> <br>    default: return FALSE; <br>  } // end switch(message) <br>  return TRUE; <br>} <br> <br> <br> <br>int catqInitializeCatalogs ( HWND hwndComboBox, LPTSTR pszScope ) <br>/*++ <br> <br>    Fill the combobox indicated by the first parameter with catalogs <br>     as returned by the WIN32 API LocateCatalogs.  The second parameter <br>     is the "scope" that we are checking catalogs for.  We expect this <br>     to be the directory location of the SDK. <br> <br>--*/ <br>{ <br>#define PSZ_SYSTEMCATALOG TEXT("System") <br> <br>    HRESULT hr = S_OK; <br>    ULONG iBmk; <br>    ULONG iCountSuccess = 0; <br> <br>    // <br>    // Loop through calls to LocateCatalogs until the return value is not <br>    //  S_OK.  For any catalog that we get, verify that the strings were <br>    //  big enough, and add the catalog name to the combobox. <br>    // <br>    // This code is taken from the LocateCatalogs documentation. <br>    // <br> <br>    for ( iBmk = 0; S_OK == hr; iBmk++ ) { <br> <br>      TCHAR atcMachine[ MAX_COMPUTERNAME_LENGTH + 1 ]; <br>      const ULONG ctcMachineBuffer = sizeof atcMachine / sizeof TCHAR; <br>      ULONG ctcMachine = ctcMachineBuffer; <br>      TCHAR atcCatalog[ MAX_PATH + 1 ]; <br>      const ULONG ctcCatalogBuffer = sizeof atcCatalog / sizeof TCHAR; <br>      ULONG ctcCatalog = ctcCatalogBuffer; <br> <br> <br>      hr = LocateCatalogs( pszScope, <br>                           iBmk, <br>                           atcMachine, <br>                           &amp;ctcMachine, <br>                           atcCatalog, <br>                           &amp;ctcCatalog ); <br> <br>      if ( ( hr == S_OK ) &amp;&amp; <br>           ( ctcMachine &lt;= ctcMachineBuffer ) &amp;&amp; <br>           ( ctcCatalog &lt;= ctcCatalogBuffer ) )    { <br>          iCountSuccess++; <br>          SendMessage ( hwndComboBox, <br>                        CB_ADDSTRING, <br>                        0, <br>                        (LPARAM) atcCatalog); <br> <br>      } <br>    } <br> <br> <br>    // <br>    // In some cases (the scope parameter is "\" for example) LocateCatalogs <br>    //  will not return any useful catalogs.  We detect this case by comparing <br>    //  iCountSuccess with 0.  In this case, add the system catalog anyway. <br>    // <br>    // The failure of LocateCatalogs("\" ... ) may change in a later release. <br>    // <br> <br>    if (iCountSuccess == 0) <br>        SendMessage ( hwndComboBox, <br>                      CB_ADDSTRING, <br>                      0, <br>                      (LPARAM) PSZ_SYSTEMCATALOG); <br> <br> <br>    // <br>    // Select the initial value to be the system catalog. <br>    // <br> <br>    SendMessage ( hwndComboBox, <br>                  CB_SELECTSTRING, <br>                  0, <br>                  (LPARAM) PSZ_SYSTEMCATALOG); <br>    return TRUE; <br>} <br> <br> <br> <br>int catqInitializeSDKPath (HWND hwndEdit, LPTSTR pszPath ) <br>/*++ <br> <br>    This routine is called one time at window creation time.  It initializes <br>     the value in the passed in edit control to be equal to the directory <br>     location of the SDK.  Separate this out as a function only because <br>     the logic is rather involved and would clutter up the main window proc. <br> <br>    hwndEdit -- the edit control that this function fills. <br>    pszPath -- buffer to return the path in to the calling routine. <br> <br>--*/ <br>{ <br>    DWORD dwRet; <br>    TCHAR pszSDKEnvVar[MAX_PATH]; <br> <br>    // <br>    // Query the environment for the location where the SDK is installed. <br>    // <br> <br>    dwRet = GetEnvironmentVariable (TEXT("MSSDK"), pszSDKEnvVar, MAX_PATH); <br> <br>    if (dwRet == 0) { <br>      catqLogComment (TEXT("Can't locate SDK.  Defaulting to \\.")); <br>      lstrcpy (pszSDKEnvVar, TEXT("\\")); <br>    } <br> <br>    SetWindowText (hwndEdit, pszSDKEnvVar); <br>    lstrcpy (pszPath, pszSDKEnvVar); <br> <br>  return TRUE; <br>} <br> <br> <br> <br>int catqReportError ( int iError ) <br>/*++ <br> <br>    Call WIN32 API GetLastError, format it for human consumption, and pass <br>     it along to our application output routine. <br> <br>--*/ <br>{ <br>    DWORD  dwRet; <br>    TCHAR  szBuffer[MAX_PATH], szCommentStr[MAX_PATH]; <br> <br>    dwRet = FormatMessage( FORMAT_MESSAGE_FROM_SYSTEM, <br>                           NULL, <br>                           iError, <br>                           LANG_NEUTRAL, <br>                           szBuffer, <br>                           MAX_PATH, <br>                           NULL); <br> <br> <br>    // <br>    // If formatmessage succeeds, glue the numeric value on the end just <br>    //  for fun.  If it fails, report that along with the numeric value. <br>    // <br> <br>    if (dwRet) <br>        wsprintf (szCommentStr, <br>                  TEXT("%s (0x%x)"), <br>                  szBuffer, <br>                  iError); <br> <br>    else <br>        wsprintf (szCommentStr, <br>                  TEXT("FormatMessage failed on 0x%x"), <br>                  iError); <br> <br> <br>    catqLogComment ( szCommentStr ); <br> <br>    return TRUE; <br>} <br> <br> <br>void <br>_cdecl <br>catqReportResultsVariable( <br>    PTCH Format, <br>    ... <br>    ) <br>/*++ <br> <br>    Format the variable number of arguments passed in based on the first <br>     argument (the format string), and display the message to the user. <br> <br>    Uses GLOBAL hwndGlobalDlg <br> <br>--*/ <br>{ <br>    static TCHAR buffer[MAX_PATH]; <br> <br>    va_list marker; <br>    va_start (marker,Format); <br>    wvsprintf (buffer,Format, marker); <br> <br> <br>    if (IsWindow(hwndGlobalDlg)) <br>        SendMessage (hwndGlobalDlg, <br>                     WMAPP_ADDRESULT, <br>                     0, <br>                     (LPARAM) buffer); <br>    else <br>        MessageBox (NULL, <br>                    buffer, <br>                    SZ_APP_TITLE, <br>                    MB_OK ); <br>    return; <br>} <br> <br> <br>void <br>_cdecl <br>catqLogCommentVariable( <br>    PTCH Format, <br>    ... <br>    ) <br>/*++ <br> <br>    Format the variable number of arguments passed in based on the first <br>     argument (the format string), and call the routine to log the comment. <br> <br>--*/ <br>{ <br>    static TCHAR buffer[MAX_PATH]; <br> <br>    va_list marker; <br>    va_start (marker,Format); <br>    wvsprintf (buffer,Format, marker); <br> <br>    catqLogComment ( buffer ); <br>    return; <br>} <br> <br> <br> <br>int catqLogComment ( PTCHAR ptString ) <br>/*++ <br> <br>    If the main window has been created already (i.e. hwnd is valid), then <br>     display the message (second input parameter) in the statusbar. <br>     If the main window does not exist, put up a message box. <br> <br>    Uses GLOBAL hwndGlobalDlg <br> <br>--*/ <br>{ <br>    if (IsWindow(hwndGlobalDlg)) <br>        catqUpdateStatusComment(GetDlgItem(hwndGlobalDlg, DID_STATUSBAR), <br>                                ptString); <br>    else <br>        MessageBox (NULL, <br>                    ptString, <br>                    SZ_APP_TITLE, <br>                    MB_OK | MB_ICONSTOP); <br> <br>    // <br>    // Also write to the debug output stream for the sake of anyone running <br>    //  under a debugger.  Or, notice that DBMON.EXE from the SDK will allow <br>    //  one to monitor output sent to OutputDebugString (). <br>    // <br> <br>    OutputDebugString ( TEXT("catq: ")); <br>    OutputDebugString ( ptString ); <br>    OutputDebugString ( TEXT("\n")); <br> <br>    return TRUE; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
