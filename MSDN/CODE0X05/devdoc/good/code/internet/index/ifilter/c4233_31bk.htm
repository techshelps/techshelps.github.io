<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>METATAG.CXX</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context4250"></a>METATAG.CXX</h2>
<pre><code>//+--------------------------------------------------------------------------- <br>// <br>//  Copyright 1992 - 1998 Microsoft Corporation. <br>// <br>//  File:       metatag.cxx <br>// <br>//  Contents:   Parsing algorithm for meta tag in Html <br>// <br>//  Classes:    CMetaTag <br>// <br>//---------------------------------------------------------------------------- <br> <br>#include &lt;pch.cxx&gt; <br>#pragma hdrstop <br> <br>#include &lt;metatag.hxx&gt; <br>#include &lt;htmlguid.hxx&gt; <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Method:     CMetaTag::CMetaTag <br>// <br>//  Synopsis:   Constructor <br>// <br>//  Arguments:  [htmlIFilter]    -- Html IFilter <br>//              [serialStream]   -- Input stream <br>//              [clsidMetaInfo]  -- Clsid for meta chunk <br>// <br>//-------------------------------------------------------------------------- <br> <br>CMetaTag::CMetaTag( CHtmlIFilter&amp; htmlIFilter, <br>                    CSerialStream&amp; serialStream, <br>                    GUID clsidMetaInfo ) <br>    : CHtmlElement(htmlIFilter, serialStream), <br>      _clsidMetaInfo(clsidMetaInfo), <br>      _pwcValueBuf(0), <br>      _cValueChars(0), <br>      _eState(FilteringValue) <br>{ <br>} <br> <br> <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Method:     CMetaTag::GetChunk <br>// <br>//  Synopsis:   Gets the next chunk and returns chunk information in pStat <br>// <br>//  Arguments:  [pStat] -- chunk information returned here <br>// <br>//-------------------------------------------------------------------------- <br> <br>SCODE CMetaTag::GetChunk( STAT_CHUNK * pStat ) <br>{ <br>    SCODE sc = SwitchToNextHtmlElement( pStat ); <br> <br>    return sc; <br>} <br> <br> <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Method:     CMetaTag::GetText <br>// <br>//  Synopsis:   Retrieves text from current chunk <br>// <br>//  Arguments:  [pcwcOutput] -- count of UniCode characters in buffer <br>//              [awcBuffer]  -- buffer for text <br>// <br>//-------------------------------------------------------------------------- <br> <br>SCODE CMetaTag::GetText( ULONG *pcwcOutput, WCHAR *awcBuffer ) <br>{ <br>    return FILTER_E_NO_TEXT; <br>} <br> <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Method:     CMetaTag::GetValue <br>// <br>//  Synopsis:   Retrieves value from current chunk <br>// <br>//  Arguments:  [ppPropValue] -- Value returned here <br>// <br>//-------------------------------------------------------------------------- <br> <br>SCODE CMetaTag::GetValue( VARIANT **ppPropValue ) <br>{ <br>    switch ( _eState ) <br>    { <br>    case FilteringValue: <br>    { <br>        PROPVARIANT *pPropVar = (PROPVARIANT *) CoTaskMemAlloc( sizeof PROPVARIANT ); <br>        if ( pPropVar == 0 ) <br>            return E_OUTOFMEMORY; <br> <br>        pPropVar-&gt;vt = VT_LPWSTR; <br>        pPropVar-&gt;pwszVal = (WCHAR *) CoTaskMemAlloc( ( _cValueChars + 1 ) * sizeof( WCHAR ) ); <br>        if ( pPropVar-&gt;pwszVal == 0 ) <br>        { <br>            CoTaskMemFree( (void *) pPropVar ); <br>            return E_OUTOFMEMORY; <br>        } <br> <br>        RtlCopyMemory( pPropVar-&gt;pwszVal, _pwcValueBuf, _cValueChars * sizeof(WCHAR) );  <br>        pPropVar-&gt;pwszVal[_cValueChars] = 0; <br> <br>        *ppPropValue = pPropVar; <br> <br>        _eState = NoMoreValue; <br>        return S_OK; <br>    } <br> <br>    case NoMoreValue: <br> <br>        return FILTER_E_NO_MORE_VALUES; <br> <br>    default: <br>        Win4Assert( !"CMetaTag::GetValue, unknown state" ); <br>        return E_FAIL; <br>    } <br>} <br> <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Method:     CMetaTag::InitStatChunk <br>// <br>//  Synopsis:   Initializes the STAT_CHUNK <br>// <br>//  Arguments:  [pStat] -- STAT_CHUNK to initialize <br>// <br>//-------------------------------------------------------------------------- <br> <br>void CMetaTag::InitStatChunk( STAT_CHUNK *pStat ) <br>{ <br>    WCHAR *pwcName; <br>    unsigned cwcName; <br> <br>    // <br>    // Read the names field <br>    // <br>    _scanner.ReadTagIntoBuffer(); <br>    _scanner.ScanTagBuffer( L"name=\"", pwcName, cwcName ); <br> <br>    if ( cwcName == 0 ) <br>    { <br>        // <br>        // Try to read http-equiv instead <br>        // <br>        _scanner.ScanTagBuffer( L"http-equiv=\"", pwcName, cwcName ); <br>    } <br> <br>    if ( cwcName == 0 ) <br>    { <br>        // <br>        // Chunk of unknown type <br>        // <br>        _cValueChars = 0; <br>        pStat-&gt;attribute.psProperty.ulKind = PRSPEC_PROPID; <br>        pStat-&gt;attribute.psProperty.propid = 3; <br>    } <br>    else <br>    { <br>        _scanner.ScanTagBuffer( L"content=\"", _pwcValueBuf, _cValueChars ); <br> <br>        pStat-&gt;attribute.psProperty.ulKind = PRSPEC_LPWSTR; <br> <br>        if ( cwcName &gt; MAX_PROPSPEC_STRING_LENGTH ) <br>            cwcName = MAX_PROPSPEC_STRING_LENGTH;     // Truncate to max length permitted <br> <br>        RtlCopyMemory( _awszPropSpec, pwcName, cwcName * sizeof(WCHAR) ); <br>        _awszPropSpec[cwcName] = 0; <br> <br>        pStat-&gt;attribute.psProperty.lpwstr = _awszPropSpec; <br>    } <br> <br>    _eState = FilteringValue; <br> <br>    pStat-&gt;idChunk = _htmlIFilter.GetNextChunkId(); <br>    pStat-&gt;flags = CHUNK_VALUE; <br>    pStat-&gt;locale = _htmlIFilter.GetLocale(); <br>    pStat-&gt;attribute.guidPropSet = _clsidMetaInfo; <br>    pStat-&gt;breakType = CHUNK_EOS; <br>    pStat-&gt;idChunkSource = pStat-&gt;idChunk; <br>    pStat-&gt;cwcStartSource = 0; <br>    pStat-&gt;cwcLenSource = 0; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
