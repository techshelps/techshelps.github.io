<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SERSTRM.CXX</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context4260"></a>SERSTRM.CXX</h2>
<pre><code>//+--------------------------------------------------------------------------- <br>// <br>//  Copyright 1992 - 1998 Microsoft Corporation. <br>// <br>//  File:       serstrm.cxx <br>// <br>//  Contents:   Serial stream <br>// <br>//  Classes:    CSerialStream <br>// <br>//---------------------------------------------------------------------------- <br> <br>#include &lt;pch.cxx&gt; <br>#pragma hdrstop <br> <br>#include &lt;htmlfilt.hxx&gt; <br> <br>// <br>// Special char hash table is static so that there is only one hash table <br>// per htmlfilt dll <br>// <br>CSpecialCharHashTable CSerialStream::_specialCharHash; <br> <br>// <br>// aControlCodeMap is the mapping for chars in the control code region (0x80 to 0x9f) <br>// as mapped by the web browser <br>// <br>static WCHAR aControlCodeMap[] = { 0x20,     // space <br>                                   0x20,     // space <br>                                   0x2c,     // comma <br>                                   0x192,    // script f <br>                                   0x201e,   // low double comma <br>                                   0x2026,   // horizontal ellipsis <br>                                   0x2020,   // dagger <br>                                   0x2021,   // double dagger <br>                                   0x5e,     // circumflex <br>                                   0x2030,   // per mille <br>                                   0x160,    // S haeck <br>                                   0x2039,   // left guillemet <br>                                   0x152,    // OE <br>                                   0x20,     // space <br>                                   0x20,     // space <br>                                   0x20,     // space <br>                                   0x20,     // space <br>                                   0x2018,   // single turned comma <br>                                   0x2019,   // single turned comma <br>                                   0x201c,   // double turned comma <br>                                   0x201d,   // double turned comma <br>                                   0x2022,   // bullet <br>                                   0x2014,   // em dash <br>                                   0x2015,   // quotation dash <br>                                   0x2dc,    // tilde <br>                                   0x2122,   // trademark <br>                                   0x161,    // s haeck <br>                                   0x203a,   // right guillemet <br>                                   0x153,    // oe <br>                                   0x20,     // space <br>                                   0x20,     // space <br>                                   0x178     // y diaresis <br>                                 }; <br> <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Method:     CSerialStream::CSerialStream <br>// <br>//  Synopsis:   Constructor <br>// <br>//-------------------------------------------------------------------------- <br> <br>CSerialStream::CSerialStream() <br>    : _wch(0), <br>      _fUnGotChar(FALSE), <br>      _cCharsReadAhead(0), <br>      _pCurChar(_awcReadAheadBuf) <br>{ <br>} <br> <br> <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Method:     CSerialStream::Init <br>// <br>//  Synopsis:   Initialize the memory mapped stream <br>// <br>//  Arguments:  [pwszFileName] -- File to be mapped <br>// <br>//-------------------------------------------------------------------------- <br> <br>void CSerialStream::Init( WCHAR *pwszFileName ) <br>{ <br>    _mmInputStream.Init( pwszFileName ); <br>} <br> <br> <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Method:     CSerialStream::GetChar <br>// <br>//  Synopsis:   Read the next Unicode character from the input file, accounting <br>//              for special chars, chars push backs and read ahead <br>// <br>//  Returns:    Next Unicode char <br>// <br>//-------------------------------------------------------------------------- <br> <br>WCHAR CSerialStream::GetChar() <br>{ <br>    // <br>    // Was a char pushed back into input ? <br>    // <br>    if ( _fUnGotChar ) <br>    { <br>        _fUnGotChar = FALSE; <br>        return _wch; <br>    } <br> <br>    // <br>    // Are there any chars in our read-ahead buffer ? <br>    // <br>    WCHAR wch; <br>    if ( _pCurChar &lt; _awcReadAheadBuf + _cCharsReadAhead ) <br>    { <br>        wch = *_pCurChar; <br>        _pCurChar++; <br> <br>        return wch; <br>    } <br> <br>    if ( _mmInputStream.Eof() ) <br>        return WEOF; <br> <br>    // <br>    // Read from input stream <br>    // <br>    wch = _mmInputStream.GetChar(); <br>    if ( wch == 0xa || wch == 0xd )         // Replace newlines with spaces <br>        wch = L' '; <br> <br>    if ( wch == L'&amp;' ) <br>    { <br>        // <br>        // Read in the special char until ';' or '&amp;', or EOF, or until _awcReadAhead buffer is full <br>        // <br>        _awcReadAheadBuf[0] = wch; <br>        for ( unsigned i=1; i&lt;MAX_SPECIAL_CHAR_LENGTH; i++) <br>        { <br>            if ( _mmInputStream.Eof() ) <br>                break; <br> <br>            wch = _mmInputStream.GetChar(); <br>            if ( wch == 0xa || wch == 0xd )         // Replace newlines with spaces <br>                wch = L' '; <br> <br>            _awcReadAheadBuf[i] = wch; <br>            if ( wch == L';' || wch == L'&amp;' ) <br>                break; <br>        } <br> <br>        if ( wch == L';' ) <br>        { <br>            if ( _awcReadAheadBuf[1] == L'#' &amp;&amp; IsUnicodeNumber( &amp;_awcReadAheadBuf[2], i-2, wch ) ) <br>            { <br>                // <br>                // Return converted Unicode number, e.g. for &amp;#160, return 160 <br>                // <br>                return wch; <br>            } <br>            else if ( _specialCharHash.Lookup( &amp;_awcReadAheadBuf[1], i-1, wch ) ) <br>            { <br>                // <br>                // Corresponding Unicode char found <br>                // <br>                return wch; <br>            } <br>            else <br>            { <br>                _cCharsReadAhead = i+1; <br>                _pCurChar = &amp;_awcReadAheadBuf[1]; <br> <br>                return L'&amp;'; <br>            } <br>        } <br>        else if ( wch == L'&amp;' ) <br>        { <br>            // <br>            // For example, &amp;acu&amp;aacute; . So keep &amp;acu in the read ahead buffer, <br>            // but push the second '&amp;' back into the input stream, so that &amp;aacute; <br>            // can be recognized as a special char during a subsequent call to GetChar() <br>            // <br>            _mmInputStream.UnGetChar( L'&amp;' ); <br>            _cCharsReadAhead = i; <br>            _pCurChar = &amp;_awcReadAheadBuf[1]; <br> <br>            return L'&amp;'; <br>        } <br>        else <br>        { <br>            _cCharsReadAhead = i; <br>            _pCurChar = &amp;_awcReadAheadBuf[1]; <br> <br>            return L'&amp;'; <br>        } <br>    } <br>    else <br>        return wch; <br>} <br> <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Method:     CSerialStream::UnGetChar <br>// <br>//  Synopsis:   Pushes(logically) a character back into the input stream <br>// <br>//  Arguments:  [wch]  -- Char to be pushed back <br>// <br>//-------------------------------------------------------------------------- <br> <br>void CSerialStream::UnGetChar( WCHAR wch ) <br>{ <br>    // <br>    // We can unget only one char at a time <br>    // <br>    Win4Assert( ! _fUnGotChar ); <br> <br>    _fUnGotChar = TRUE; <br>    _wch = wch; <br>} <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Method:     CSerialStream::Eof <br>// <br>//  Synopsis:   Is this the end of input file ? <br>// <br>//-------------------------------------------------------------------------- <br> <br>BOOL CSerialStream::Eof() <br>{ <br>    if ( _fUnGotChar ) <br>        return FALSE; <br> <br>    if ( _pCurChar &lt; _awcReadAheadBuf + _cCharsReadAhead ) <br>        return FALSE; <br> <br>    return _mmInputStream.Eof(); <br>} <br> <br> <br> <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Method:     CSerialStream::IsUnicodeNumber <br>// <br>//  Synopsis:   Is the special char a Unicode number ? <br>// <br>//  Arguments:  [pwcInputBuf] -- input buffer <br>//              [uLen]        -- Length of input (not \0 terminated) <br>//              [wch]         -- Unicode char returned here <br>// <br>//  Returns:    True if we've managed to convert to a Unicode number <br>// <br>//-------------------------------------------------------------------------- <br> <br>BOOL CSerialStream::IsUnicodeNumber( WCHAR *pwcInputBuf, <br>                                     unsigned uLen, <br>                                     WCHAR&amp; wch ) <br>{ <br>    wch = 0; <br>    for ( unsigned i=0; i&lt;uLen; i++ ) <br>    { <br>        // <br>        // Check that the result will be less than max Unicode value, namely 0xffff <br>        // <br>        if ( iswdigit( pwcInputBuf[i] ) <br>             &amp;&amp; wch &lt; (0xffff - (pwcInputBuf[i]-L'0'))/10 ) <br>        { <br>            wch = 10 * wch + pwcInputBuf[i] - L'0'; <br>        } <br>        else <br>            return FALSE; <br>    } <br> <br>    if ( wch &gt;= 0x80 &amp;&amp; wch &lt;= 0x9f ) <br>    { <br>        // <br>        // Chars in the control code region are mapped by the browser to valid chars <br>        // <br> <br>        wch = aControlCodeMap[wch-0x80]; <br>    } <br> <br>    return ( wch &gt; 0 ); <br>} <br> <br> <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
