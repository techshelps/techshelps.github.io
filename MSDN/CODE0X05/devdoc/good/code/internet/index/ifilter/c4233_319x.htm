<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>HTMLSCAN.CXX</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context4245"></a>HTMLSCAN.CXX</h2>
<pre><code>//+--------------------------------------------------------------------------- <br>// <br>//  Copyright 1992 - 1998 Microsoft Corporation. <br>// <br>//  File:       htmlscan.cxx <br>// <br>//  Contents:   Scanner for html files <br>// <br>//  Classes:    CHtmlScanner <br>// <br>//---------------------------------------------------------------------------- <br> <br>#include &lt;pch.cxx&gt; <br>#pragma hdrstop <br> <br>#include &lt;htmlguid.hxx&gt; <br>#include &lt;charhash.hxx&gt; <br>#include &lt;htmlfilt.hxx&gt; <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Method:     CToken::IsMatchProperty <br>// <br>//  Synopsis:   Does the token's property match the given property ? <br>// <br>//  Arguments:  [propSpec]   -- Property to match <br>// <br>//-------------------------------------------------------------------------- <br> <br>BOOL CToken::IsMatchProperty( CFullPropSpec&amp; propSpec ) <br>{ <br>    if ( propSpec.IsPropertyPropid() <br>         &amp;&amp; propSpec.GetPropSet() == _guidPropset <br>         &amp;&amp; propSpec.GetPropertyPropid() == _propid ) <br>    { <br>        return TRUE; <br>    } <br>    else <br>        return FALSE; <br>} <br> <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Method:     CHtmlScanner::CHtmlScanner <br>// <br>//  Synopsis:   Constructor <br>// <br>//  Arguments:  [htmlIFilter]    -- Reference to Html filter <br>//              [serialStream]   -- Reference to input stream to scan <br>// <br>//-------------------------------------------------------------------------- <br> <br>CHtmlScanner::CHtmlScanner( CHtmlIFilter&amp; htmlIFilter, <br>                            CSerialStream&amp; serialStream ) <br>    : _htmlIFilter(htmlIFilter), <br>      _serialStream(serialStream), <br>      _uLenTagBuf(TAG_BUFFER_SIZE), <br>      _cTagCharsRead(0) <br>{ <br>    _pwcTagBuf = newk(mtNewX, NULL) WCHAR[ TAG_BUFFER_SIZE ]; <br>} <br> <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Method:     CHtmlScanner::~CHtmlScanner <br>// <br>//  Synopsis:   Destructor <br>// <br>//-------------------------------------------------------------------------- <br> <br>CHtmlScanner::~CHtmlScanner() <br>{ <br>    delete[] _pwcTagBuf; <br>} <br> <br> <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Method:     CHtmlScanner::GetBlockOfChars <br>// <br>//  Synopsis:   Returns a block of chars upto the size requested by user. If <br>//              any Html tag is encountered, it stops scanning, and returns the <br>//              token found. <br>// <br>//  Arguments:  [cCharsNeeded]   -- Maximum # chars to scan <br>//              [awcBuffer]      -- Buffer to fill with scanned chars <br>//              [cCharsScanned]  -- # chars actually scanned <br>//              [token]          -- Token found (if any) <br>// <br>//-------------------------------------------------------------------------- <br> <br>void CHtmlScanner::GetBlockOfChars( ULONG cCharsNeeded, <br>                                    WCHAR *awcBuffer, <br>                                    ULONG&amp; cCharsScanned, <br>                                    CToken&amp; token ) <br>{ <br>    cCharsScanned = 0; <br> <br>    while ( cCharsNeeded &gt; 0 ) <br>    { <br>        if ( _serialStream.Eof() ) <br>        { <br>            token.SetTokenType( EofToken ); <br>            return; <br>        } <br> <br>        WCHAR wch = _serialStream.GetChar(); <br>        if ( wch == L'&lt;' ) <br>        { <br>            // <br>            // Html tag encountered <br>            // <br>            ScanTag( token ); <br>            return; <br>        } <br>        else <br>        { <br>            // <br>            // &amp;lt; and &amp;gt; were mapped to Unicode chars from private use area <br>            // to avoid collision with '&lt;' and '&gt;' chars in Html tags. Map them <br>            // back to '&lt;' and '&gt;'. <br>            // <br>            if ( wch == PRIVATE_USE_MAPPING_FOR_LT ) <br>                wch = L'&lt;'; <br>            else if ( wch == PRIVATE_USE_MAPPING_FOR_GT ) <br>                wch = L'&gt;'; <br> <br>            awcBuffer[cCharsScanned++] = wch; <br>            cCharsNeeded--; <br>        } <br>    } <br>} <br> <br> <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Method:     CHtmlScanner::SkipCharsUntilNextRelevantToken <br>// <br>//  Synopsis:   Skips characters in input until EOF or an interesting token <br>//              is found. The list of properties that were asked to be filtered <br>//              as part of the IFilter::Init call determines whether a token is <br>//              interesting or not. <br>// <br>//  Arguments:  [fFilterContents]     -- Are contents filtered ? <br>//              [fFilterProperties]   -- Are properties filtered ? <br>//              [cAttributes]          -- Count of properties <br>//              [pAttributes]         -- List of properties to be filtered <br>// <br>//-------------------------------------------------------------------------- <br> <br>void CHtmlScanner::SkipCharsUntilNextRelevantToken( CToken&amp; token ) <br>{ <br>    // <br>    // Loop until we find a stop token or end of file <br>    // <br>    for (;;) <br>    { <br>        if ( _serialStream.Eof() ) <br>        { <br>            token.SetTokenType( EofToken ); <br>            return; <br>        } <br> <br>        WCHAR wch = _serialStream.GetChar(); <br>        if ( wch == L'&lt;' ) <br>        { <br>            ScanTag( token ); <br> <br>            if ( token.GetTokenType() == EofToken <br>                 || _htmlIFilter.IsStopToken( token ) ) <br>            { <br>                return; <br>            } <br>            else <br>            { <br>                // <br>                // Uninteresting tag, hence skip tag <br>                // <br>                EatTag(); <br>            } <br>        } <br>        else <br>        { <br>            // <br>            // Vanilla text <br>            // <br>            if ( _htmlIFilter.FFilterContent() ) <br>            { <br>                _serialStream.UnGetChar( wch ); <br>                token.SetTokenType( TextToken ); <br>                return; <br>            } <br>            else <br>                EatText(); <br>        } <br>    } <br>} <br> <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Method:     CHtmlScanner::ScanTag <br>// <br>//  Synopsis:   Scans a Html tag from input <br>// <br>//  Arguments:  [token]  -- Token info returned here <br>// <br>//-------------------------------------------------------------------------- <br> <br>void CHtmlScanner::ScanTag( CToken&amp; token ) <br>{ <br> <br>    EatBlanks(); <br> <br>    if ( _serialStream.Eof() ) <br>    { <br>        token.SetTokenType( EofToken ); <br>        return; <br>    } <br>    WCHAR wch = _serialStream.GetChar(); <br> <br>    token.SetStartTokenFlag( TRUE ); <br>    if ( wch == L'/' ) <br>    { <br>        // <br>        // This is an end tag <br>        // <br>        token.SetStartTokenFlag( FALSE ); <br>        EatBlanks(); <br> <br>        if ( _serialStream.Eof() ) <br>        { <br>            token.SetTokenType( EofToken ); <br>            return; <br>        } <br>        wch = _serialStream.GetChar(); <br>    } <br> <br>    WCHAR awcTagName[MAX_TAG_LENGTH+1]; <br>    unsigned uLenTag = 0; <br> <br>    // <br>    // Scan the tag name into szTagName. We scan MAX_TAG_LENGTH <br>    // characters only, because anything longer is most probably <br>    // a bogus tag. <br>    // <br>    while ( !iswspace(wch) <br>            &amp;&amp; wch != L'&gt;' <br>            &amp;&amp; uLenTag &lt; MAX_TAG_LENGTH ) <br>    { <br>        awcTagName[uLenTag++] = wch; <br> <br>        if ( _serialStream.Eof() ) <br>            break; <br>        wch = _serialStream.GetChar(); <br>    } <br>    awcTagName[uLenTag] = 0; <br> <br>    if ( _serialStream.Eof() ) <br>    { <br>        token.SetTokenType( EofToken ); <br>        return; <br>    } <br>    else if ( wch == L'&gt;' || uLenTag == MAX_TAG_LENGTH ) <br>    { <br>        // <br>        // Push char back into input stream because a subsequent GetChar() <br>        // will be expecting to see the char in the input <br>        // <br>        _serialStream.UnGetChar( wch ); <br>    } <br> <br>    TagNameToToken( awcTagName, token ); <br>} <br> <br> <br> <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Method:     CHtmlScanner::ReadTagIntoBuffer <br>// <br>//  Synopsis:   Reads the rest of Html tag into the internal buffer <br>// <br>//-------------------------------------------------------------------------- <br> <br>void CHtmlScanner::ReadTagIntoBuffer() <br>{ <br>    _cTagCharsRead = 0; <br> <br>    if ( _serialStream.Eof() ) <br>        return; <br> <br>    WCHAR wch = _serialStream.GetChar(); <br>    while ( wch != L'&gt;' ) <br>    { <br>        if ( _cTagCharsRead &gt;= _uLenTagBuf ) <br>            GrowTagBuffer(); <br>        Win4Assert( _cTagCharsRead &lt; _uLenTagBuf ); <br> <br>        _pwcTagBuf[_cTagCharsRead++] = wch; <br> <br>        if ( _serialStream.Eof() ) <br>            return; <br>        wch = _serialStream.GetChar(); <br>    } <br>} <br> <br> <br> <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Method:     CHtmlScanner::ScanTagBuffer <br>// <br>//  Synopsis:   Scans the internal tag buffer for a given name, and returns the <br>//              corresponding value <br>// <br>//  Arguments:  [awcName]   -- Pattern to match <br>//              [pwcValue]  -- Start position of value returned here <br>//              [uLenValue  -- Length of value field <br>// <br>//-------------------------------------------------------------------------- <br> <br>void CHtmlScanner::ScanTagBuffer( WCHAR *awcName, <br>                                  WCHAR * &amp; pwcValue, <br>                                  unsigned&amp; uLenValue ) <br>{ <br>    unsigned uLenName = wcslen( awcName ); <br> <br>    if ( _cTagCharsRead &lt;= uLenName ) <br>    { <br>        // <br>        // Pattern to match is longer than scanned tag <br>        // <br>        pwcValue = 0; <br>        uLenValue = 0; <br> <br>        return; <br>    } <br> <br>    for ( unsigned i=0; i&lt;_cTagCharsRead-uLenName; i++ ) <br>    { <br>        BOOL fMatch = TRUE; <br>        for ( unsigned j=0; j&lt;uLenName; j++ ) <br>        { <br>            // <br>            // Case insensitive match <br>            // <br>            if ( towlower(awcName[j]) != towlower(_pwcTagBuf[i+j]) ) <br>            { <br>                fMatch = FALSE; <br>                break; <br>            } <br>        } <br> <br>        if ( fMatch ) <br>        { <br>            unsigned k = i + uLenName; <br>            while ( _pwcTagBuf[k] != L'"' &amp;&amp; k &lt; _cTagCharsRead ) <br>                k++; <br> <br>            uLenValue = k - (i + uLenName); <br>            pwcValue = &amp;_pwcTagBuf[i+uLenName]; <br> <br>            return; <br>        } <br>    } <br> <br>    uLenValue = 0; <br>    pwcValue = 0; <br>} <br> <br> <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Method:     CHtmlScanner::EatTag <br>// <br>//  Synopsis:   Skips characters in input until the '&gt;' char, which demarcates <br>//              the end of the tag <br>// <br>//-------------------------------------------------------------------------- <br> <br>void CHtmlScanner::EatTag() <br>{ <br>    if ( _serialStream.Eof() ) <br>        return; <br> <br>    WCHAR wch = _serialStream.GetChar(); <br>    while ( wch != L'&gt;' &amp;&amp;  !_serialStream.Eof() ) <br>        wch = _serialStream.GetChar(); <br>} <br> <br> <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Method:     CHtmlScanner::EatText <br>// <br>//  Synopsis:   Skips characters in input until a '&lt;', ie a tag is encountered <br>// <br>//-------------------------------------------------------------------------- <br> <br>void CHtmlScanner::EatText() <br>{ <br>    if ( _serialStream.Eof() ) <br>        return; <br> <br>    WCHAR wch = _serialStream.GetChar(); <br>    while ( wch != L'&lt;' &amp;&amp; !_serialStream.Eof() ) <br>        wch = _serialStream.GetChar(); <br> <br>    if ( wch == L'&lt;' ) <br>        _serialStream.UnGetChar( wch ); <br>} <br> <br> <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Method:     CHtmlScanner::EatBlanks <br>// <br>//  Synopsis:   Skips generic white space characters in input <br>// <br>//-------------------------------------------------------------------------- <br> <br>void CHtmlScanner::EatBlanks() <br>{ <br>    if ( _serialStream.Eof() ) <br>        return; <br> <br>    WCHAR wch = _serialStream.GetChar(); <br>    while ( iswspace(wch) &amp;&amp; !_serialStream.Eof() ) <br>        wch = _serialStream.GetChar(); <br> <br>    if ( !iswspace(wch) ) <br>        _serialStream.UnGetChar( wch ); <br>} <br> <br> <br> <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Method:     CHtmlScanner::TagNameToToken <br>// <br>//  Synopsis:   Maps a tag name to token information <br>// <br>//  Arguments:  [awcTagName]  -- Tag name to map <br>//              [token]       -- Token information returned here <br>// <br>//-------------------------------------------------------------------------- <br> <br>void CHtmlScanner::TagNameToToken( WCHAR *awcTagName, CToken&amp; token ) <br>{ <br>    // <br>    // The number of interesting Html tags will be small, hence no need for <br>    // a table lookup <br>    // <br>    switch( awcTagName[0] ) <br>    { <br>    case L'a': <br>    case L'A': <br>        if ( _wcsicmp( awcTagName, L"a" ) == 0 ) <br>        { <br>            token.SetTokenType( AnchorToken ); <br>            token.SetPropset( CLSID_HtmlInformation ); <br>            token.SetPropid( PID_HREF ); <br>        } <br>        else if ( _wcsicmp( awcTagName, L"address" ) == 0 ) <br>            token.SetTokenType( BreakToken ); <br>        else <br>            token.SetTokenType( GenericToken ); <br> <br>        break; <br> <br>    case L'b': <br>    case L'B': <br>        if ( _wcsicmp( awcTagName, L"br" ) == 0 <br>             || _wcsicmp( awcTagName, L"blockquote" ) == 0 ) <br>        { <br>            token.SetTokenType( BreakToken ); <br>        } <br>        else <br>            token.SetTokenType( GenericToken ); <br> <br>        break; <br> <br>    case L'd': <br>    case L'D': <br>        if ( _wcsicmp( awcTagName, L"dd" ) == 0 <br>             || _wcsicmp( awcTagName, L"dl" ) == 0 <br>             || _wcsicmp( awcTagName, L"dt" ) == 0 ) <br>        { <br>            token.SetTokenType( BreakToken ); <br>        } <br>        else <br>            token.SetTokenType( GenericToken ); <br> <br>        break; <br> <br>    case L'f': <br>    case L'F': <br>        if ( _wcsicmp( awcTagName, L"form" ) == 0 ) <br>            token.SetTokenType( BreakToken ); <br>        else <br>            token.SetTokenType( GenericToken ); <br> <br>        break; <br> <br>    case L'h': <br>    case L'H': <br>        if ( _wcsicmp( awcTagName, L"h1" ) == 0 ) <br>        { <br>            token.SetTokenType( Heading1Token ); <br>            token.SetPropset( CLSID_HtmlInformation ); <br>            token.SetPropid( PID_HEADING_1 ); <br>        } <br>        else if ( _wcsicmp( awcTagName, L"h2" ) == 0 ) <br>        { <br>            token.SetTokenType( Heading2Token ); <br>            token.SetPropset( CLSID_HtmlInformation ); <br>            token.SetPropid( PID_HEADING_2 ); <br>        } <br>        else if ( _wcsicmp( awcTagName, L"h3" ) == 0 ) <br>        { <br>            token.SetTokenType( Heading3Token ); <br>            token.SetPropset( CLSID_HtmlInformation ); <br>            token.SetPropid( PID_HEADING_3 ); <br>        } <br>        else if ( _wcsicmp( awcTagName, L"h4" ) == 0 ) <br>        { <br>            token.SetTokenType( Heading4Token ); <br>            token.SetPropset( CLSID_HtmlInformation ); <br>            token.SetPropid( PID_HEADING_4 ); <br>        } <br>        else if ( _wcsicmp( awcTagName, L"h5" ) == 0 ) <br>        { <br>            token.SetTokenType( Heading5Token ); <br>            token.SetPropset( CLSID_HtmlInformation ); <br>            token.SetPropid( PID_HEADING_5 ); <br>        } <br>        else if ( _wcsicmp( awcTagName, L"h6" ) == 0 ) <br>        { <br>            token.SetTokenType( Heading6Token ); <br>            token.SetPropset( CLSID_HtmlInformation ); <br>            token.SetPropid( PID_HEADING_6 ); <br>        } <br>        else <br>            token.SetTokenType( GenericToken ); <br> <br>        break; <br> <br>    case L'i': <br>    case L'I': <br>        if ( _wcsicmp( awcTagName, L"input" ) == 0 ) <br>            token.SetTokenType( InputToken ); <br>        else if ( _wcsicmp( awcTagName, L"img" ) == 0 ) <br>            token.SetTokenType( ImageToken ); <br>        else <br>            token.SetTokenType( GenericToken ); <br> <br>        break; <br> <br>    case L'l': <br>    case L'L': <br>        if ( _wcsicmp( awcTagName, L"li" ) == 0 ) <br>            token.SetTokenType( BreakToken ); <br>        else <br>            token.SetTokenType( GenericToken ); <br> <br>        break; <br> <br>    case L'm': <br>    case L'M': <br>        if ( _wcsicmp( awcTagName, L"math" ) == 0 ) <br>            token.SetTokenType( BreakToken ); <br>        else if (  _wcsicmp( awcTagName, L"meta" ) == 0 ) <br>            token.SetTokenType( MetaToken ); <br>        else <br>            token.SetTokenType( GenericToken ); <br> <br>        break; <br> <br>    case L'o': <br>    case L'O': <br>        if ( _wcsicmp( awcTagName, L"ol" ) == 0 ) <br>            token.SetTokenType( BreakToken ); <br>        else <br>            token.SetTokenType( GenericToken ); <br> <br>        break; <br> <br>    case L'p': <br>    case L'P': <br>        if ( _wcsicmp( awcTagName, L"p" ) == 0 ) <br>            token.SetTokenType( BreakToken ); <br>        else <br>            token.SetTokenType( GenericToken ); <br> <br>        break; <br> <br>    case L's': <br>    case L'S': <br>        if ( _wcsicmp( awcTagName, L"script" ) == 0 ) <br>            token.SetTokenType( ScriptToken ); <br>        else <br>            token.SetTokenType( GenericToken ); <br> <br>        break; <br> <br>    case L't': <br>    case L'T': <br>        if ( _wcsicmp( awcTagName, L"title" ) == 0 ) <br>        { <br>            token.SetTokenType( TitleToken ); <br>            token.SetPropset( CLSID_SummaryInformation ); <br>            token.SetPropid( PID_TITLE ); <br>        } <br>        else if ( _wcsicmp( awcTagName, L"table" ) == 0 <br>                  || _wcsicmp( awcTagName, L"th" ) == 0 <br>                  || _wcsicmp( awcTagName, L"tr" ) == 0 <br>                  || _wcsicmp( awcTagName, L"td" ) == 0 ) <br>            token.SetTokenType( BreakToken ); <br>        else <br>            token.SetTokenType( GenericToken ); <br> <br>        break; <br> <br>    case L'u': <br>    case L'U': <br>        if ( _wcsicmp( awcTagName, L"ul" ) == 0 ) <br>            token.SetTokenType( BreakToken ); <br>        else <br>            token.SetTokenType( GenericToken ); <br> <br>        break; <br> <br>    case L'!': <br>        if  ( _wcsicmp( awcTagName, L"!--" ) == 0 ) <br>            token.SetTokenType( CommentToken ); <br>        else <br>            token.SetTokenType( GenericToken ); <br> <br>        break; <br> <br>    default: <br>        // <br>        // It's an uninteresting tag <br>        // <br>        token.SetTokenType( GenericToken ); <br>    } <br>} <br> <br> <br> <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Method:     CHtmlScanner::GrowTagBuffer <br>// <br>//  Synopsis:   Grow internal tag buffer to twice its current size <br>// <br>//-------------------------------------------------------------------------- <br> <br>void CHtmlScanner::GrowTagBuffer() <br>{ <br>    WCHAR *pwcNewTagBuf = newk(mtNewX, NULL) WCHAR[2 * _uLenTagBuf]; <br>    RtlCopyMemory( pwcNewTagBuf, <br>                   _pwcTagBuf, <br>                   _uLenTagBuf * sizeof(WCHAR) ); <br> <br>    delete[] _pwcTagBuf; <br>    _uLenTagBuf *= 2; <br>    _pwcTagBuf = pwcNewTagBuf; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
