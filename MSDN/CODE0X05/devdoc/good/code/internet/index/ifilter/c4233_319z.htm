<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>INPSTRM.CXX</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context4247"></a>INPSTRM.CXX</h2>
<pre><code>//+--------------------------------------------------------------------------- <br>// <br>//  Copyright 1992 - 1998 Microsoft Corporation. <br>// <br>//  File:       inpstrm.cxx <br>// <br>//  Contents:   Memory mapped input stream <br>// <br>//  Classes:    CMemoryMappedSerialStream <br>// <br>//---------------------------------------------------------------------------- <br> <br>#include &lt;pch.cxx&gt; <br>#pragma hdrstop <br> <br>#include &lt;htmlfilt.hxx&gt; <br>#include &lt;codepage.hxx&gt; <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Method:     CMemoryMappedInputStream::CMemoryMappedInputStream <br>// <br>//  Synopsis:   Constructor <br>// <br>//-------------------------------------------------------------------------- <br> <br>CMemoryMappedInputStream::CMemoryMappedInputStream() <br>    : _bytesReadFromMMBuffer(0), <br>      _charsReadFromTranslatedBuffer(0), <br>      _cwcTranslatedBuffer(0), <br>      _ulCodePage(LocaleToCodepage(GetSystemDefaultLCID())), <br>      _fUnGotChar(FALSE), <br>      _wch(0) <br>{ <br>} <br> <br> <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Method:     CMemoryMappedInputStream::~CMemoryMappedInputStream <br>// <br>//  Synopsis:   Destructor <br>// <br>//-------------------------------------------------------------------------- <br> <br>CMemoryMappedInputStream::~CMemoryMappedInputStream() <br>{ <br>    if ( _mmStream.Ok() &amp;&amp; _mmStreamBuf.Get() != 0 ) <br>        _mmStream.Unmap( _mmStreamBuf ); <br>} <br> <br> <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Method:     CMemoryMappedInputStream::Init <br>// <br>//  Synopsis:   Initialize the memory mapped stream <br>// <br>//  Arguments:  [pwszFileName] -- File to be mapped <br>// <br>//-------------------------------------------------------------------------- <br> <br>void CMemoryMappedInputStream::Init( WCHAR *pwszFileName ) <br>{ <br>    Win4Assert( pwszFileName ); <br> <br>    _bytesReadFromMMBuffer = 0; <br> <br>    if ( _mmStream.Ok() ) <br>    { <br>        _mmStreamBuf.Rewind(); <br>        _mmStream.Close(); <br>    } <br> <br>    _mmStream.Open( pwszFileName, <br>                    GENERIC_READ, <br>                    FILE_SHARE_READ, <br>                    OPEN_EXISTING ); <br> <br>    if ( _mmStream.Ok() ) <br>    { <br>        _mmStreamBuf.Init( &amp;_mmStream ); <br>        if ( !_mmStream.isEmpty() ) <br>            _mmStreamBuf.Map( HTML_FILTER_CHUNK_SIZE ); <br>    } <br>    else <br>    { <br>        htmlDebugOut(( DEB_ERROR, "Throwing FILTER_E_ACCESS in CMemoryMappedInputStream::Init\n" )); <br>        throw( CException( FILTER_E_ACCESS ) ); <br>    } <br>} <br> <br> <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Method:     CMemoryMappedInputStream::GetChar <br>// <br>//  Synopsis:   Read the next consecutive character from the input file <br>// <br>//-------------------------------------------------------------------------- <br> <br>WCHAR CMemoryMappedInputStream::GetChar() <br>{ <br>    if ( !_mmStream.Ok() || !_mmStreamBuf.Get() ) <br>        throw( CException( FILTER_E_ACCESS ) ); <br> <br>    if ( _fUnGotChar ) <br>    { <br>        _fUnGotChar = FALSE; <br>        return _wch; <br>    } <br> <br>    if ( _charsReadFromTranslatedBuffer == _cwcTranslatedBuffer ) <br>    { <br>        if ( _bytesReadFromMMBuffer == _mmStreamBuf.Size() ) <br>        { <br>            if ( _mmStreamBuf.Eof() ) <br>                return WEOF; <br>     <br>            // <br>            // Try to map in next chunk of file <br>            // <br>            _mmStreamBuf.Map( HTML_FILTER_CHUNK_SIZE ); <br>            _bytesReadFromMMBuffer = 0; <br>     <br>            Win4Assert( _mmStreamBuf.Size() &gt; _bytesReadFromMMBuffer ); <br>        } <br> <br>        ULONG cChUnread = _mmStreamBuf.Size() - _bytesReadFromMMBuffer; <br> <br>        // <br>        // Since, the wide chars are precomposed, assume 1:1 translation mapping <br>        // <br>        ULONG cChIn = TRANSLATED_CHAR_BUFFER_LENGTH; <br>        if ( cChIn &gt; cChUnread ) <br>        { <br>            // <br>            // Not enough chars in input <br>            // <br>            cChIn = cChUnread; <br>        } <br> <br>        ULONG cwcActual = 0; <br>        do <br>        { <br>            cwcActual = MultiByteToWideChar( _ulCodePage, <br>                                             MB_PRECOMPOSED, <br>                                             (char *) _mmStreamBuf.Get() + _bytesReadFromMMBuffer, <br>                                             cChIn, <br>                                             _awcTranslatedBuffer, <br>                                             TRANSLATED_CHAR_BUFFER_LENGTH ); <br>            if ( cwcActual == 0 ) <br>            { <br>                if ( GetLastError() == ERROR_INSUFFICIENT_BUFFER &amp;&amp; cChIn &gt;= 2 ) <br>                    cChIn /= 2; <br>                else <br>                { <br>                    Win4Assert( !"CMemoryMappedInputStream::GetChar, cannot translate single char" ); <br> <br>                    throw( CException( GetLastError() ) ); <br>                } <br>            } <br>        } while( cwcActual == 0 ); <br> <br>        Win4Assert( _bytesReadFromMMBuffer + cChIn &lt;= _mmStreamBuf.Size() ); <br>        Win4Assert( cwcActual &lt;= TRANSLATED_CHAR_BUFFER_LENGTH ); <br> <br>        _bytesReadFromMMBuffer += cChIn; <br>        _charsReadFromTranslatedBuffer = 0; <br>        _cwcTranslatedBuffer = cwcActual; <br>    } <br> <br>    return _awcTranslatedBuffer[_charsReadFromTranslatedBuffer++]; <br>} <br> <br> <br> <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Method:     CMemoryMappedInputStream::UnGetChar <br>// <br>//  Synopsis:   Pushes(logically) a character back into the input stream <br>// <br>//  Arguments:  [wch] -- Char to be pushed back <br>// <br>//-------------------------------------------------------------------------- <br> <br>void CMemoryMappedInputStream::UnGetChar( WCHAR wch ) <br>{ <br>    // <br>    // We can unget only one char at a time <br>    // <br>    Win4Assert( !_fUnGotChar ); <br> <br>    _fUnGotChar = TRUE; <br>    _wch = wch; <br>} <br> <br> <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Method:     CMemoryMappedInputStream::Eof <br>// <br>//  Synopsis:   Is this the end of input file ? <br>// <br>//-------------------------------------------------------------------------- <br> <br>BOOL CMemoryMappedInputStream::Eof() <br>{ <br>    if ( !_mmStream.Ok() ) <br>        throw( CException( FILTER_E_ACCESS ) ); <br> <br>    if ( _fUnGotChar ) <br>        return FALSE; <br> <br>    if ( _charsReadFromTranslatedBuffer &lt; _cwcTranslatedBuffer ) <br>        return FALSE; <br> <br>    if ( _bytesReadFromMMBuffer == _mmStreamBuf.Size() ) <br>        return _mmStreamBuf.Eof(); <br>    else <br>        return FALSE; <br>} <br> <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
