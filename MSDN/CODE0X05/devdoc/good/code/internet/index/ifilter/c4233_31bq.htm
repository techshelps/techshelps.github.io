<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>PROPTAG.CXX</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context4256"></a>PROPTAG.CXX</h2>
<pre><code>//+--------------------------------------------------------------------------- <br>// <br>//  Copyright 1992 - 1998 Microsoft Corporation. <br>// <br>//  File:       proptag.cxx <br>// <br>//  Contents:   Generic parsing algorithm for property tags, such as title and headings <br>// <br>//  Classes:    CPropertyTag <br>// <br>//---------------------------------------------------------------------------- <br> <br>#include &lt;pch.cxx&gt; <br>#pragma hdrstop <br> <br>#include &lt;proptag.hxx&gt; <br>#include &lt;htmlguid.hxx&gt; <br>#include &lt;stgprop.h&gt; <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Method:     CPropertyTag::CPropertyTag <br>// <br>//  Synopsis:   Constructor <br>// <br>//  Arguments:  [htmlIFilter]  -- Reference to Html filter <br>//              [serialStream] -- Reference to input stream <br>//              [propSpec]     -- Property spec <br>//              [eTokType]     -- Token corresponding to this property <br>// <br>//-------------------------------------------------------------------------- <br> <br>CPropertyTag::CPropertyTag( CHtmlIFilter&amp; htmlIFilter, <br>                            CSerialStream&amp; serialStream, <br>                            CFullPropSpec&amp; propSpec, <br>                            HtmlTokenType eTokType ) <br>    : CHtmlElement(htmlIFilter, serialStream), <br>      _eState(NoMoreProperty), <br>      _ulIdContentChunk(0), <br>      _pwcPropBuf(0), <br>      _uLenPropBuf(0), <br>      _cPropChars(0), <br>      _cPropCharsFiltered(0), <br>      _propSpec(propSpec), <br>      _eTokType(eTokType) <br>{ <br>} <br> <br> <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Method:     CPropertyTag::~CPropertyTag <br>// <br>//  Synopsis:   Destructor <br>// <br>//-------------------------------------------------------------------------- <br> <br>CPropertyTag::~CPropertyTag() <br>{ <br>    delete[] _pwcPropBuf; <br>} <br> <br> <br> <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Method:     CPropertyTag::GetChunk <br>// <br>//  Synopsis:   Gets the next chunk and returns chunk information in pStat <br>// <br>//  Arguments:  [pStat] -- chunk information returned here <br>// <br>//-------------------------------------------------------------------------- <br> <br>SCODE CPropertyTag::GetChunk( STAT_CHUNK * pStat ) <br>{ <br>    switch ( _eState ) <br>    { <br>    case FilteringContent: <br>    case FilteringProperty: <br>    case FilteringPropertyButContentNotFiltered: <br>    { <br>        SCODE sc = SkipRemainingTextAndGotoNextChunk( pStat ); <br> <br>        return sc; <br>    } <br> <br>    case NoMoreContent: <br>        _eState = FilteringProperty; <br> <br>        pStat-&gt;idChunk = _htmlIFilter.GetNextChunkId(); <br>        pStat-&gt;locale = _htmlIFilter.GetLocale(); <br>        pStat-&gt;cwcStartSource = 0; <br>        pStat-&gt;cwcLenSource = 0; <br>        pStat-&gt;flags = CHUNK_TEXT; <br>        pStat-&gt;attribute.guidPropSet = _propSpec.GetPropSet(); <br> <br>        Win4Assert( _propSpec.IsPropertyPropid() ); <br> <br>        pStat-&gt;attribute.psProperty.ulKind = PRSPEC_PROPID; <br>        pStat-&gt;attribute.psProperty.propid = _propSpec.GetPropertyPropid(); <br>        pStat-&gt;idChunkSource = _ulIdContentChunk; <br>        pStat-&gt;breakType = CHUNK_EOS; <br> <br>        break; <br> <br>    case NoMoreProperty: <br>    { <br>        // <br>        // Skip over the end property tag <br>        // <br>        _scanner.EatTag(); <br> <br>        SCODE sc = SwitchToNextHtmlElement( pStat ); <br> <br>        return sc; <br>    } <br> <br>    default: <br>        Win4Assert( !"Unknown _eState in CPropertyTag::GetChunk" ); <br>        htmlDebugOut(( DEB_ERROR, "CPropertyTag::GetChunk, unkown property tag state: %d\n", _eState )); <br>    } <br> <br>    return S_OK; <br>} <br> <br> <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Method:     CPropertyTag::GetText <br>// <br>//  Synopsis:   Retrieves text from current chunk <br>// <br>//  Arguments:  [pcwcBuffer] -- count of UniCode characters in buffer <br>//              [awcBuffer]  -- buffer for text <br>// <br>//-------------------------------------------------------------------------- <br> <br>SCODE CPropertyTag::GetText( ULONG *pcwcOutput, WCHAR *awcBuffer ) <br>{ <br>    switch ( _eState ) <br>    { <br>    case NoMoreContent: <br>    case NoMoreProperty: <br>         return FILTER_E_NO_MORE_TEXT; <br> <br>    case FilteringContent: <br>    case FilteringPropertyButContentNotFiltered: <br>    { <br>        ULONG cCharsRead = 0; <br>        while ( cCharsRead &lt; *pcwcOutput ) <br>        { <br>            ULONG cCharsScanned; <br>            ULONG cCharsNeeded = *pcwcOutput - cCharsRead; <br>            CToken token; <br>            _scanner.GetBlockOfChars( cCharsNeeded, <br>                                      awcBuffer + cCharsRead, <br>                                      cCharsScanned, <br>                                      token ); <br> <br>            cCharsRead += cCharsScanned; <br>            if ( cCharsScanned == cCharsNeeded ) <br>            { <br>                // <br>                // We've read the #chars requested by user <br>                // <br>                break; <br>            } <br> <br>            HtmlTokenType eTokType = token.GetTokenType(); <br>            if ( eTokType == EofToken || eTokType == _eTokType ) <br>            { <br>                // <br>                // End of file or end property tag <br>                // <br>                if ( _eState == FilteringContent ) <br>                    _eState = NoMoreContent; <br>                else <br>                    _eState = NoMoreProperty; <br> <br>                break; <br>            } <br>            else if ( eTokType == BreakToken ) <br>            { <br>                // <br>                // Insert a newline char <br>                // <br>                Win4Assert( cCharsRead &lt; *pcwcOutput ); <br>                awcBuffer[cCharsRead++] = L'\n'; <br>                _scanner.EatTag(); <br>            } <br>            else <br>            { <br>                // <br>                // Uninteresting tag, so skip over tag and continue processing <br>                // <br>                _scanner.EatTag(); <br>            } <br>        } <br> <br>        // <br>        // Keep a copy of property in our internal buffer <br>        // <br>        if ( cCharsRead &gt; 0 ) <br>            ConcatenateProperty( awcBuffer, cCharsRead ); <br> <br>        *pcwcOutput = cCharsRead; <br> <br>        if ( _eState == NoMoreContent || _eState == NoMoreProperty ) <br>            return FILTER_S_LAST_TEXT; <br>        else <br>            return S_OK; <br> <br>        break; <br>    } <br> <br> <br>    case FilteringProperty: <br>    { <br>        ULONG cCharsRemaining = _cPropChars - _cPropCharsFiltered; <br> <br>        if ( cCharsRemaining == 0 ) <br>        { <br>            _eState = NoMoreProperty; <br>            return FILTER_E_NO_MORE_TEXT; <br>        } <br> <br>        if ( *pcwcOutput &lt; cCharsRemaining ) <br>        { <br>            RtlCopyMemory( awcBuffer, <br>                           _pwcPropBuf + _cPropCharsFiltered, <br>                           *pcwcOutput * sizeof(WCHAR) ); <br>            _cPropCharsFiltered += *pcwcOutput; <br> <br>            return S_OK; <br>        } <br>        else <br>        { <br>            RtlCopyMemory( awcBuffer, <br>                           _pwcPropBuf + _cPropCharsFiltered, <br>                           cCharsRemaining * sizeof(WCHAR) ); <br>            _cPropCharsFiltered += cCharsRemaining; <br>            *pcwcOutput = cCharsRemaining; <br>            _eState = NoMoreProperty; <br> <br>            return FILTER_S_LAST_TEXT; <br>        } <br> <br>        break; <br>    } <br> <br>    default: <br>        Win4Assert( !"Unknown value of _eState" ); <br>        htmlDebugOut(( DEB_ERROR, <br>                       "CPropertyTag::GetText, unknown value of _eState: %d\n", <br>                       _eState )); <br>        return S_OK; <br>    } <br>} <br> <br> <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Method:     CPropertyTag::InitStatChunk <br>// <br>//  Synopsis:   Initializes the STAT_CHUNK as part of a GetChunk call <br>// <br>//  Arguments:  [pStat] -- STAT_CHUNK to initialize <br>// <br>//-------------------------------------------------------------------------- <br> <br>void CPropertyTag::InitStatChunk( STAT_CHUNK *pStat ) <br>{ <br>    // <br>    // Skip over the rest of property tag <br>    // <br>    _scanner.EatTag(); <br> <br>    _cPropChars = 0; <br>    _cPropCharsFiltered = 0; <br> <br>    pStat-&gt;idChunk = _htmlIFilter.GetNextChunkId(); <br>    pStat-&gt;flags = CHUNK_TEXT; <br>    pStat-&gt;breakType = CHUNK_EOS; <br>    pStat-&gt;locale = _htmlIFilter.GetLocale(); <br>    pStat-&gt;cwcStartSource = 0; <br>    pStat-&gt;cwcLenSource = 0; <br> <br>    if ( _htmlIFilter.FFilterContent() ) <br>    { <br>        // <br>        // Store the idChunk so that it can be retrieved later to set the value of <br>        // idChunkSource when initializing the pseudo-property <br>        // <br>        _ulIdContentChunk = pStat-&gt;idChunk; <br>        pStat-&gt;attribute.guidPropSet = CLSID_Storage; <br>        pStat-&gt;attribute.psProperty.ulKind = PRSPEC_PROPID; <br>        pStat-&gt;attribute.psProperty.propid = PID_STG_CONTENTS; <br>        pStat-&gt;idChunkSource = pStat-&gt;idChunk; <br> <br>        _eState = FilteringContent; <br>    } <br>    else <br>    { <br>        // <br>        // We've been asked to filter only the pseudo-property, so skip content filtering <br>        // <br>        _ulIdContentChunk = 0; <br>        pStat-&gt;attribute.guidPropSet = _propSpec.GetPropSet(); <br> <br>        Win4Assert( _propSpec.IsPropertyPropid() ); <br> <br>        pStat-&gt;attribute.psProperty.ulKind = PRSPEC_PROPID; <br>        pStat-&gt;attribute.psProperty.propid = _propSpec.GetPropertyPropid(); <br>        pStat-&gt;idChunkSource = 0; <br> <br>        _eState = FilteringPropertyButContentNotFiltered; <br>    } <br> } <br> <br> <br> <br> //+------------------------------------------------------------------------- <br>// <br>//  Method:     CPropertyTag::ConcatenateProperty <br>// <br>//  Synopsis:   Append the Property suffix to Property stored in internal buffer <br>// <br>//  Arguments:  [awcPropertySuffix] -- Suffix of Property <br>//              [uLen]           -- Length of Property <br>// <br>//-------------------------------------------------------------------------- <br> <br>void CPropertyTag::ConcatenateProperty( WCHAR *awcPropSuffix, unsigned uLen ) <br>{ <br>    // <br>    // Need to grow Property buffer ? <br>    // <br>    if ( _cPropChars + uLen &gt; _uLenPropBuf ) <br>    { <br>        WCHAR *pwcNewPropBuf = newk(mtNewX, NULL) WCHAR[_cPropChars + uLen + PROP_BUFFER_SLOP]; <br>        RtlCopyMemory( pwcNewPropBuf, _pwcPropBuf, _cPropChars * sizeof(WCHAR) ); <br> <br>        delete[] _pwcPropBuf; <br>        _uLenPropBuf = _cPropChars + uLen + PROP_BUFFER_SLOP; <br> <br>        _pwcPropBuf = pwcNewPropBuf; <br>    } <br> <br>    RtlCopyMemory( _pwcPropBuf + _cPropChars, awcPropSuffix, uLen * sizeof(WCHAR) ); <br>    _cPropChars += uLen; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
