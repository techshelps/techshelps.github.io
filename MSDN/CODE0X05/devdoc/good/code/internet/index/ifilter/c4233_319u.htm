<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>HTMLFILT.CXX</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context4242"></a>HTMLFILT.CXX</h2>
<pre><code>//+--------------------------------------------------------------------------- <br>// <br>//  Copyright 1992 - 1998 Microsoft Corporation. <br>// <br>//  File:       htmlfilt.cxx <br>// <br>//  Contents:   Html filter <br>// <br>//  Classes:    CHtmlIFilter <br>// <br>//---------------------------------------------------------------------------- <br> <br>#include &lt;pch.cxx&gt; <br>#pragma hdrstop <br> <br>#include &lt;eh.h&gt; <br>#include &lt;htmlfilt.hxx&gt; <br>#include &lt;textelem.hxx&gt; <br>#include &lt;proptag.hxx&gt; <br>#include &lt;anchor.hxx&gt; <br>#include &lt;inputtag.hxx&gt; <br>#include &lt;start.hxx&gt; <br>#include &lt;titletag.hxx&gt; <br>#include &lt;imagetag.hxx&gt; <br>#include &lt;metatag.hxx&gt; <br>#include &lt;scriptag.hxx&gt; <br>#include &lt;htmlguid.hxx&gt; <br>#include &lt;stgprop.h&gt; <br>#include &lt;limits.h&gt; <br>#include &lt;regacc32.hxx&gt; <br> <br>DECLARE_INFOLEVEL(html) <br> <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Method:     CHtmlIFilter::CHtmlIFilter <br>// <br>//  Synopsis:   Constructor <br>// <br>//-------------------------------------------------------------------------- <br> <br>CHtmlIFilter::CHtmlIFilter() <br>    : _pHtmlElement(0), <br>      _fNonHtmlFile(FALSE), <br>      _fFilterContent(FALSE), <br>      _fFilterMetaTag(FALSE), <br>      _fFilterScriptTag(FALSE), <br>      _cAttributes(0), <br>      _pAttributes(0), <br>      _pwszFileName(0), <br>      _ulChunkID(0), <br>      _locale(GetSystemDefaultLCID()), <br>      _htmlElementBag( COUNT_OF_HTML_ELEMENTS ) <br>{ <br>    // <br>    // Setup various Html elements <br>    // <br>    _htmlElementBag.AddElement( TextToken, newk(mtNewX, NULL) CTextElement( *this, _serialStream ) ); <br> <br>    _htmlElementBag.AddElement( StartOfFileToken, newk(mtNewX, NULL) CStartOfFileElement( *this, _serialStream ) ); <br> <br>    CFullPropSpec psTitle( CLSID_SummaryInformation, PID_TITLE ); <br>    _htmlElementBag.AddElement( TitleToken, newk(mtNewX, NULL) CTitleTag( *this, <br>                                                                          _serialStream, <br>                                                                          psTitle, <br>                                                                          TitleToken ) ); <br> <br>    CFullPropSpec psHeading1( CLSID_HtmlInformation, PID_HEADING_1 ); <br>    _htmlElementBag.AddElement( Heading1Token, newk(mtNewX, NULL) CPropertyTag( *this, <br>                                                                                _serialStream, <br>                                                                                psHeading1, <br>                                                                                Heading1Token ) ); <br> <br>    CFullPropSpec psHeading2( CLSID_HtmlInformation, PID_HEADING_2 ); <br>    _htmlElementBag.AddElement( Heading2Token, newk(mtNewX, NULL) CPropertyTag( *this, <br>                                                                                _serialStream, <br>                                                                                psHeading2, <br>                                                                                Heading2Token ) ); <br> <br>    CFullPropSpec psHeading3( CLSID_HtmlInformation, PID_HEADING_3 ); <br>    _htmlElementBag.AddElement( Heading3Token, newk(mtNewX, NULL) CPropertyTag( *this, <br>                                                                                _serialStream, <br>                                                                                psHeading3, <br>                                                                                Heading3Token ) ); <br> <br>    CFullPropSpec psHeading4( CLSID_HtmlInformation, PID_HEADING_4 ); <br>    _htmlElementBag.AddElement( Heading4Token, newk(mtNewX, NULL) CPropertyTag( *this, <br>                                                                                _serialStream, <br>                                                                                psHeading4, <br>                                                                                Heading4Token ) ); <br> <br>    CFullPropSpec psHeading5( CLSID_HtmlInformation, PID_HEADING_5 ); <br>    _htmlElementBag.AddElement( Heading5Token, newk(mtNewX, NULL) CPropertyTag( *this, <br>                                                                                _serialStream, <br>                                                                                psHeading5, <br>                                                                                Heading5Token ) ); <br> <br>    CFullPropSpec psHeading6( CLSID_HtmlInformation, PID_HEADING_6 ); <br>    _htmlElementBag.AddElement( Heading6Token, newk(mtNewX, NULL) CPropertyTag( *this, <br>                                                                                _serialStream, <br>                                                                                psHeading6, <br>                                                                                Heading6Token ) ); <br> <br>    _htmlElementBag.AddElement( AnchorToken, newk(mtNewX, NULL) CAnchorTag( *this, _serialStream ) ); <br> <br>    _htmlElementBag.AddElement( InputToken, newk(mtNewX, NULL) CInputTag( *this, _serialStream ) ); <br> <br>    _htmlElementBag.AddElement( ImageToken, newk(mtNewX, NULL) CImageTag( *this, _serialStream ) ); <br> <br>    // <br>    // Read classid of meta information from registry <br>    // <br>    const WCHAR *pszKey = L"system\\currentcontrolset\\control\\HtmlFilter"; <br>    CRegAccess regMetaInfo( HKEY_LOCAL_MACHINE, pszKey ); <br> <br>    const MAX_VALUE_LENGTH = 100; <br>    WCHAR wszValue[MAX_VALUE_LENGTH]; <br>    _fFilterMetaTag = regMetaInfo.Get( L"MetaTagClsid", wszValue, MAX_VALUE_LENGTH ); <br> <br>    if ( _fFilterMetaTag ) <br>    { <br>        GUID ClsidMetaInformation; <br> <br>        StringToClsid( wszValue, ClsidMetaInformation ); <br>        _htmlElementBag.AddElement( MetaToken, newk(mtNewX, NULL) CMetaTag( *this, <br>                                                                            _serialStream, <br>                                                                            ClsidMetaInformation ) ); <br>    } <br> <br>    // <br>    // Read classid of scripts from registry <br>    // <br>    CRegAccess regScriptInfo( HKEY_LOCAL_MACHINE, pszKey ); <br> <br>    _fFilterScriptTag = regScriptInfo.Get( L"ScriptTagClsid", wszValue, MAX_VALUE_LENGTH ); <br> <br>    if ( _fFilterScriptTag ) <br>    { <br>        GUID ClsidScriptInformation; <br> <br>        StringToClsid( wszValue, ClsidScriptInformation ); <br>        _htmlElementBag.AddElement( ScriptToken, newk(mtNewX, NULL) CScriptTag( *this, <br>                                                                                _serialStream, <br>                                                                                ClsidScriptInformation ) ); <br>    } <br> <br>    // <br>    // Set the start state to StartOfFile mode <br>    // <br>    _pHtmlElement = _htmlElementBag.QueryElement( StartOfFileToken ); <br>} <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Method:     CHtmlIFilter::~CHtmlIFilter <br>// <br>//  Synopsis:   Destructor <br>// <br>//-------------------------------------------------------------------------- <br> <br>CHtmlIFilter::~CHtmlIFilter() <br>{ <br>    delete[] _pAttributes; <br>    delete[] _pwszFileName; <br>} <br> <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CHtmlIFilter::BindRegion <br>// <br>//  Synopsis:   Creates moniker or other interface for text indicated <br>// <br>//  Arguments:  [origPos] -- the region of text to be mapped to a moniker <br>//              [riid]    -- Interface id <br>//              [ppunk]   -- the interface <br>// <br>//---------------------------------------------------------------------------- <br> <br>SCODE STDMETHODCALLTYPE CHtmlIFilter::BindRegion( FILTERREGION origPos, <br>                                                  REFIID riid, <br>                                                  void ** ppunk ) <br>{ <br>    return E_NOTIMPL; <br>} <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CHtmlIFilter::GetClassID, public <br>// <br>//  Synopsis:   Returns the class id of this class. <br>// <br>//  Arguments:  [pClassID] -- the class id <br>// <br>//---------------------------------------------------------------------------- <br> <br>SCODE STDMETHODCALLTYPE CHtmlIFilter::GetClassID( CLSID * pClassID ) <br>{ <br>    *pClassID = CLSID_HtmlIFilter; <br>    return S_OK; <br>} <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CHtmlIFilter::IsDirty, public <br>// <br>//  Synopsis:   Always returns S_FALSE since the filter is read-only <br>// <br>//---------------------------------------------------------------------------- <br> <br>SCODE STDMETHODCALLTYPE CHtmlIFilter::IsDirty() <br>{ <br>    return S_FALSE; <br>} <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CHtmlIFilter::Load, public <br>// <br>//  Synopsis:   Loads the indicated file <br>// <br>//  Arguments:  [pszFileName] -- the file name <br>//              [dwMode] -- the mode to load the file in <br>// <br>//---------------------------------------------------------------------------- <br> <br>SCODE STDMETHODCALLTYPE CHtmlIFilter::Load( LPCWSTR psszFileName, DWORD dwMode ) <br>{ <br>    if ( _pwszFileName != 0 ) <br>    { <br>        delete _pwszFileName; <br>        _pwszFileName = 0; <br>    } <br> <br>    _se_translator_function tf = _set_se_translator( SystemExceptionTranslator ); <br> <br>    SCODE sc = S_OK; <br>    try <br>    { <br>        unsigned cLen = wcslen( psszFileName ) + 1; <br>        _pwszFileName = newk(mtNewX, NULL) WCHAR[cLen]; <br>        wcscpy( _pwszFileName, psszFileName ); <br> <br>        _fNonHtmlFile = IsNonHtmlFile(); <br>    } <br>    catch( CException&amp; e ) <br>    { <br>        htmlDebugOut(( DEB_ERROR, "Exception 0x%x caught in CHtmlIFilter::Load", e.GetErrorCode() )); <br> <br>        sc = GetOleError( e ); <br>    } <br> <br>    _set_se_translator( tf ); <br> <br>    return sc; <br>} <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CHtmlIFilter::Save, public <br>// <br>//  Synopsis:   Always returns E_FAIL, since the file is opened read-only <br>// <br>//---------------------------------------------------------------------------- <br> <br>SCODE STDMETHODCALLTYPE CHtmlIFilter::Save( LPCWSTR pszFileName, BOOL fRemember ) <br>{ <br>    return E_FAIL; <br>} <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CHtmlIFilter::SaveCompleted, public <br>// <br>//  Synopsis:   Always returns S_OK since the file is opened read-only <br>// <br>//---------------------------------------------------------------------------- <br> <br>SCODE STDMETHODCALLTYPE CHtmlIFilter::SaveCompleted( LPCWSTR pszFileName ) <br>{ <br>    return E_FAIL; <br>} <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CHtmlIFilter::GetCurFile, public <br>// <br>//  Synopsis:   Returns a copy of the current file name <br>// <br>//  Arguments:  [ppszFileName] -- where the copied string is returned <br>// <br>//---------------------------------------------------------------------------- <br> <br>SCODE STDMETHODCALLTYPE CHtmlIFilter::GetCurFile( LPWSTR * ppwszFileName ) <br>{ <br>    if ( _pwszFileName == 0 ) <br>        return E_FAIL; <br> <br>    unsigned cLen = wcslen( _pwszFileName ) + 1; <br>    *ppwszFileName = (WCHAR *)CoTaskMemAlloc( cLen*sizeof(WCHAR) ); <br> <br>    SCODE sc = S_OK; <br>    if ( *ppwszFileName ) <br>        wcscpy( *ppwszFileName, _pwszFileName ); <br>    else <br>        sc = E_OUTOFMEMORY; <br> <br>    return sc; <br>} <br> <br> <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Method:     CHtmlIFilter::Init <br>// <br>//  Synopsis:   Initializes instance of Html filter <br>// <br>//  Arguments:  [grfFlags] -- flags for filter behavior <br>//              [cAttributes] -- number of attributes in array pAttributes <br>//              [pAttributes] -- array of attributes <br>//              [pFlags]      -- Set to 0 version 1 <br>// <br>//-------------------------------------------------------------------------- <br> <br>SCODE STDMETHODCALLTYPE CHtmlIFilter::Init( ULONG grfFlags, <br>                                            ULONG cAttributes, <br>                                            FULLPROPSPEC const * pAttributes, <br>                                            ULONG * pFlags ) <br>{ <br>    SCODE sc = S_OK; <br> <br>    *pFlags = 0;  // There are no OLE docfile properties for .htm files. <br> <br>    // <br>    // IE workaround, don't filter non-Html files such as .gif <br>    // <br>    if ( _fNonHtmlFile ) <br>        return S_OK; <br> <br>    _se_translator_function tf = _set_se_translator( SystemExceptionTranslator ); <br> <br>    try <br>    { <br> <br> <br>        _fFilterContent = FALSE; <br> <br>        if ( _cAttributes &gt; 0 ) <br>        { <br>            delete[] _pAttributes; <br>            _pAttributes = 0; <br>            _cAttributes = 0; <br>        } <br> <br>        if ( cAttributes &gt; 0 ) <br>        { <br>            // <br>            // Filter properties specified in pAttributes <br>            // <br>            _pAttributes = newk(mtNewX, NULL) CFullPropSpec[cAttributes]; <br>            _cAttributes = cAttributes; <br> <br>            CFullPropSpec *pAttrib = (CFullPropSpec *) pAttributes; <br> <br>            for (unsigned i=0; i&lt;cAttributes; i++) <br>            { <br>                if ( pAttrib[i].IsPropertyPropid() <br>                     &amp;&amp; pAttrib[i].GetPropertyPropid() == PID_STG_CONTENTS <br>                     &amp;&amp; pAttrib[i].GetPropSet() == CLSID_Storage ) <br>                { <br>                    _fFilterContent = TRUE; <br>                } <br> <br>                _pAttributes[i] = pAttrib[i]; <br>            } <br>        } <br>        else if ( grfFlags &amp; IFILTER_INIT_APPLY_INDEX_ATTRIBUTES ) <br>        { <br>            // <br>            // Filter contents and all pseudo-properties <br>            // <br>            _fFilterContent = TRUE; <br> <br>            const COUNT_ATTRIBUTES = 8; <br>            _pAttributes = newk(mtNewX, NULL) CFullPropSpec[COUNT_ATTRIBUTES]; <br>            _cAttributes = COUNT_ATTRIBUTES; <br> <br>            _pAttributes[0].SetPropSet( CLSID_SummaryInformation ); <br>            _pAttributes[0].SetProperty( PID_TITLE ); <br> <br>            _pAttributes[1].SetPropSet( CLSID_HtmlInformation ); <br>            _pAttributes[1].SetProperty( PID_HREF ); <br> <br>            _pAttributes[2].SetPropSet( CLSID_HtmlInformation ); <br>            _pAttributes[2].SetProperty( PID_HEADING_1 ); <br> <br>            _pAttributes[3].SetPropSet( CLSID_HtmlInformation ); <br>            _pAttributes[3].SetProperty( PID_HEADING_2 ); <br> <br>            _pAttributes[4].SetPropSet( CLSID_HtmlInformation ); <br>            _pAttributes[4].SetProperty( PID_HEADING_3 ); <br> <br>            _pAttributes[5].SetPropSet( CLSID_HtmlInformation ); <br>            _pAttributes[5].SetProperty( PID_HEADING_4 ); <br> <br>            _pAttributes[6].SetPropSet( CLSID_HtmlInformation ); <br>            _pAttributes[6].SetProperty( PID_HEADING_5 ); <br> <br>            _pAttributes[7].SetPropSet( CLSID_HtmlInformation ); <br>            _pAttributes[7].SetProperty( PID_HEADING_6 ); <br>        } <br>        else if ( grfFlags == 0 ) <br>        { <br>            // <br>            // Filter only contents <br>            // <br>            _fFilterContent = TRUE; <br>        } <br> <br>        _pHtmlElement = _htmlElementBag.QueryElement( StartOfFileToken ); <br>        _ulChunkID = 0; <br>        _serialStream.Init( _pwszFileName ); <br>    } <br>    catch( CException&amp; e) <br>    { <br>        htmlDebugOut(( DEB_ERROR, <br>                       "Exception 0x%x caught in CHtmlIFilter::Init\n", <br>                       e.GetErrorCode() )); <br>        sc = GetOleError( e ); <br>    } <br> <br>    _set_se_translator( tf ); <br> <br>    return sc; <br>} <br> <br> <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Method:     CHtmlIFilter::ChangeState <br>// <br>//  Synopsis:   Change the current Html element and hence the parsing algorithm <br>// <br>//  Arguments:  [pHtmlElemNewState]  -- New Html element to change to <br>// <br>//-------------------------------------------------------------------------- <br> <br>void CHtmlIFilter::ChangeState( CHtmlElement *pHtmlElemNewState ) <br>{ <br>    _pHtmlElement = pHtmlElemNewState; <br>} <br> <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Method:     CHtmlIFilter::QueryElement <br>// <br>//  Synopsis:   Return HtmlElement corresponding to given token type <br>// <br>//  Arguments:  [eTokenType]  -- token type <br>// <br>//-------------------------------------------------------------------------- <br> <br>CHtmlElement *CHtmlIFilter::QueryHtmlElement( HtmlTokenType eTokType ) <br>{ <br>    return _htmlElementBag.QueryElement( eTokType ); <br>} <br> <br> <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Method:     CHtmlIFilter::GetNextChunkId <br>// <br>//  Synopsis:   Return a brand new chunk id <br>// <br>//-------------------------------------------------------------------------- <br> <br>ULONG CHtmlIFilter::GetNextChunkId() <br>{ <br>    Win4Assert( _ulChunkID != ULONG_MAX ); <br> <br>    return ++_ulChunkID; <br>} <br> <br> <br> <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Method:     CHtmlIFilter::GetChunk <br>// <br>//  Synopsis:   Gets the next chunk and returns chunk information in ppStat <br>// <br>//  Arguments:  [pStat] -- chunk information returned here <br>// <br>//-------------------------------------------------------------------------- <br> <br>SCODE STDMETHODCALLTYPE CHtmlIFilter::GetChunk( STAT_CHUNK * pStat ) <br>{ <br>    // <br>    // IE workaround, don't filter non-Html files such as .gif <br>    // <br>    if ( _fNonHtmlFile ) <br>        return FILTER_E_END_OF_CHUNKS; <br> <br>    SCODE sc = S_OK; <br> <br>    _se_translator_function tf = _set_se_translator( SystemExceptionTranslator ); <br> <br>    try <br>    { <br>        sc = _pHtmlElement-&gt;GetChunk( pStat ); <br>    } <br>    catch( CException&amp; e ) <br>    { <br>        htmlDebugOut(( DEB_ERROR, <br>                       "Caught exception 0x%x in CHtmlIFilter::GetChunk\n", <br>                       e.GetErrorCode() )); <br> <br>        sc = GetOleError( e ); <br>    } <br> <br>    _set_se_translator( tf ); <br> <br>    return sc; <br>} <br> <br> <br> <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Method:     CHtmlIFilter::GetText <br>// <br>//  Synopsis:   Retrieves text from current chunk <br>// <br>//  Arguments:  [pcwcOutput] -- count of UniCode characters in buffer <br>//              [awcBuffer]  -- buffer for text <br>// <br>//-------------------------------------------------------------------------- <br> <br>SCODE STDMETHODCALLTYPE CHtmlIFilter::GetText( ULONG * pcwcOutput, WCHAR * awcOutput ) <br>{ <br>    // <br>    // IE workaround, don't filter non-Html files such as .gif <br>    // <br>    if ( _fNonHtmlFile ) <br>        return FILTER_E_NO_TEXT; <br> <br>    SCODE sc = S_OK; <br> <br>    _se_translator_function tf = _set_se_translator( SystemExceptionTranslator ); <br> <br>    try <br>    { <br>        sc = _pHtmlElement-&gt;GetText( pcwcOutput, awcOutput ); <br>    } <br>    catch( CException&amp; e ) <br>    { <br>        htmlDebugOut(( DEB_ERROR, <br>                       "Caught exception 0x%x in CHtmlIFilter::GetText\n", <br>                       e.GetErrorCode() )); <br> <br>        sc = GetOleError( e ); <br>    } <br> <br>    _set_se_translator( tf ); <br> <br>    return sc; <br>} <br> <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CHtmlIFilter::GetValue <br>// <br>//  Synopsis:   Retrieves value from current chunk <br>// <br>//---------------------------------------------------------------------------- <br> <br>SCODE STDMETHODCALLTYPE CHtmlIFilter::GetValue( VARIANT ** ppPropValue ) <br>{ <br>    // <br>    // IE workaround, don't filter non-Html files such as .gif <br>    // <br>    if ( _fNonHtmlFile ) <br>        return FILTER_E_NO_VALUES; <br> <br>    SCODE sc = S_OK; <br> <br>    _se_translator_function tf = _set_se_translator( SystemExceptionTranslator ); <br> <br>    try <br>    { <br>        sc = _pHtmlElement-&gt;GetValue( ppPropValue ); <br>    } <br>    catch( CException&amp; e ) <br>    { <br>        htmlDebugOut(( DEB_ERROR, <br>                       "Caught exception 0x%x in CHtmlIFilter::GetValue\n", <br>                       e.GetErrorCode() )); <br> <br>        sc = GetOleError( e ); <br>    } <br> <br>    _set_se_translator( tf ); <br> <br>    return sc; <br>} <br> <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Method:     CHtmlIFilter::IsStopToken <br>// <br>//  Synopsis:   Check if given token is a token that should stop further <br>//              scanning <br>// <br>//  Arguments:  [token]  -- Given token <br>// <br>//-------------------------------------------------------------------------- <br> <br>BOOL CHtmlIFilter::IsStopToken( CToken&amp; token ) <br>{ <br>    HtmlTokenType tokType = token.GetTokenType(); <br>    if ( ( tokType == InputToken || tokType == ImageToken )  &amp;&amp; _fFilterContent <br>         || tokType == MetaToken &amp;&amp; _fFilterMetaTag <br>         || tokType == ScriptToken &amp;&amp; _fFilterScriptTag ) <br>    { <br>        return TRUE; <br>    } <br> <br>    if ( token.GetTokenType() == GenericToken <br>         || token.GetTokenType() == BreakToken ) <br>        return FALSE; <br> <br>    for ( unsigned i=0; i&lt;_cAttributes; i++ ) <br>    { <br>        if ( token.IsMatchProperty( _pAttributes[i] ) ) <br>            return TRUE; <br>    } <br> <br>    return FALSE; <br>} <br> <br> <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Method:     CHtmlIFilter::IsNonHtmlFile <br>// <br>//  Synopsis:   Check if file being filtered has an extension such as .gif, <br>//              which means that the file is not an Html file <br>// <br>//-------------------------------------------------------------------------- <br> <br>BOOL CHtmlIFilter::IsNonHtmlFile() <br>{ <br>    WCHAR *pwszExtension; <br> <br>    for ( int i=wcslen(_pwszFileName)-1; i&gt;=0; i-- ) <br>    { <br>        if ( _pwszFileName[i] == L'.' ) <br>        { <br>            pwszExtension = &amp;_pwszFileName[i+1]; <br>            break; <br>        } <br>    } <br> <br>    // <br>    // No extension, then assume it's an html file <br>    // <br>    if ( i &lt; 0 ) <br>        return FALSE; <br> <br>    switch( pwszExtension[0] ) <br>    { <br>    case L'a': <br>    case L'A': <br>        if ( _wcsicmp( pwszExtension, L"aif" ) == 0 <br>             || _wcsicmp( pwszExtension, L"aifc" ) == 0 <br>             || _wcsicmp( pwszExtension, L"aiff" ) == 0 <br>             || _wcsicmp( pwszExtension, L"au" ) == 0 ) <br>        { <br>            return TRUE; <br>        } <br> <br>        break; <br> <br>    case L'g': <br>    case L'G': <br>        if ( _wcsicmp( pwszExtension, L"gif" ) == 0 ) <br>            return TRUE; <br> <br>        break; <br> <br>    case L'j': <br>    case L'J': <br>        if ( _wcsicmp( pwszExtension, L"jfif" ) == 0 <br>             || _wcsicmp( pwszExtension, L"jpe" ) == 0 <br>             || _wcsicmp( pwszExtension, L"jpeg" ) == 0 <br>             || _wcsicmp( pwszExtension, L"jpg" ) == 0 ) <br>        { <br>            return TRUE; <br>        } <br> <br>        break; <br> <br>    case L's': <br>    case L'S': <br>        if ( _wcsicmp( pwszExtension, L"snd" ) == 0 ) <br>            return TRUE; <br> <br>        break; <br> <br>    case L'x': <br>    case L'X': <br>        if ( _wcsicmp( pwszExtension, L"xbm" ) == 0 ) <br>            return TRUE; <br> <br>        break; <br> <br>    default: <br>        return FALSE; <br>    } <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
