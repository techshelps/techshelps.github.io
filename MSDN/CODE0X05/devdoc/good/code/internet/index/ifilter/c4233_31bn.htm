<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>MMSTRM.CXX</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context4253"></a>MMSTRM.CXX</h2>
<pre><code>//+--------------------------------------------------------------------------- <br>// <br>//  Copyright 1992 - 1998 Microsoft Corp. <br>// <br>//  File:       mmstrm.cxx <br>// <br>//  Contents:   Memory Mapped Stream using win32 API <br>// <br>//  Classes:    CMmStream, CMmStreamBuf <br>// <br>//---------------------------------------------------------------------------- <br> <br>#include &lt;pch.cxx&gt; <br>#pragma hdrstop <br> <br>#include &lt;mmstrm.hxx&gt; <br>#include &lt;osv.hxx&gt; <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Member:     CMmStream::CMmStream <br>// <br>//  Synopsis:   constructor <br>// <br>//  Arguments:  [wcsPath] - file path <br>// <br>//-------------------------------------------------------------------------- <br> <br>CMmStream::CMmStream ( WCHAR* wcsPath ) <br>    : _hMap(0) <br>{ <br>    OpenRorW ( wcsPath ); <br>} <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Member:     CMmStream::CMmStream <br>// <br>//  Synopsis:   constructor <br>// <br>//-------------------------------------------------------------------------- <br>CMmStream::CMmStream() <br>        : _hFile(INVALID_HANDLE_VALUE), <br>          _hMap(0), <br>          _fWrite(FALSE) <br>{ <br>} <br> <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Member:     CMmStream::~CMmStream <br>// <br>//  Synopsis:   destructor <br>// <br>// <br>//-------------------------------------------------------------------------- <br>CMmStream::~CMmStream() <br>{ <br>    if (Ok()) <br>    { <br>        if(_hMap ) <br>        { <br>            CloseHandle(_hMap); <br>            _hMap = 0; <br>        } <br> <br>        CloseHandle ( _hFile ); <br>        _hFile = INVALID_HANDLE_VALUE; <br>    } <br>} <br> <br> <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Member:     CMmStream::OpenRorW, public <br>// <br>//  Synopsis:   Open stream <br>// <br>//  Arguments:  [path] - file path <br>// <br>//  Notes:      Tries to open read/write, create if necessary. <br>//              If it fails, try opening read only. If read/write, <br>//              regions are mapped in COMMON_PAGE_SIZE increments. <br>// <br>//-------------------------------------------------------------------------- <br> <br>void CMmStream::OpenRorW ( WCHAR* wcsPath ) <br>{ <br>    // Try read write access (create if possible) <br> <br>    if ( GetOSVersion() == VER_PLATFORM_WIN32_NT ) <br>    { <br>        _hFile = CreateFile( wcsPath, <br>                             GENERIC_READ | GENERIC_WRITE, <br>                             FILE_SHARE_READ, <br>                             0, // security <br>                             OPEN_ALWAYS, <br>                             FILE_ATTRIBUTE_NORMAL, <br>                             0 ); // template <br>    } <br>    else // win95 <br>    { <br>        // Worst case - size of multibyte == size of Unicode <br>        int nLen = wcslen( wcsPath ) * 2; <br>        char *pszPath = new char[nLen]; <br> <br>        if ( pszPath == NULL ) <br>        { <br>            _hFile = INVALID_HANDLE_VALUE; <br>        } <br>        else <br>        { <br>            if ( wcstombs( pszPath, wcsPath, nLen ) == -1 ) <br>            { <br>                _hFile = INVALID_HANDLE_VALUE; <br>            } <br>            else <br>            { <br>                _hFile = CreateFileA( pszPath, <br>                                      GENERIC_READ | GENERIC_WRITE, <br>                                      FILE_SHARE_READ, <br>                                      0, // security <br>                                      OPEN_ALWAYS, <br>                                      FILE_ATTRIBUTE_NORMAL, <br>                                      0 ); // template <br>            } <br>            delete [] pszPath; <br>            pszPath = NULL; <br>        } <br>    } <br> <br>    if ( Ok() ) <br>    { <br>        _fWrite = TRUE; <br>    } <br>    else <br>    { <br>        _fWrite = FALSE; <br>        // Try read only access <br> <br>        if ( GetOSVersion() == VER_PLATFORM_WIN32_NT ) <br>        { <br>            _hFile = CreateFile( wcsPath, <br>                                 GENERIC_READ, <br>                                 FILE_SHARE_READ | FILE_SHARE_WRITE, <br>                                 0, // security <br>                                 OPEN_EXISTING, <br>                                 FILE_ATTRIBUTE_NORMAL, <br>                                 0 ); // template <br>        } <br>        else // win95 <br>        { <br>            // Worst case - size of multibyte == size of Unicode <br>            int nLen = wcslen( wcsPath ) * 2; <br>            char *pszPath = new char[nLen]; <br> <br>            if ( pszPath == NULL ) <br>            { <br>                _hFile = INVALID_HANDLE_VALUE; <br>            } <br>            else <br>            { <br>                if ( wcstombs( pszPath, wcsPath, nLen ) == -1 ) <br>                { <br>                    _hFile = INVALID_HANDLE_VALUE; <br>                } <br>                else <br>                { <br>                    _hFile = CreateFileA( pszPath, <br>                                          GENERIC_READ, <br>                                          FILE_SHARE_READ | FILE_SHARE_WRITE, <br>                                          0, // security <br>                                          OPEN_EXISTING, <br>                                          FILE_ATTRIBUTE_NORMAL, <br>                                          0 ); // template <br>                } <br>                delete [] pszPath; <br>                pszPath = NULL; <br>            } <br>        } <br>    } <br> <br>    if (Ok()) <br>    { <br>        _sizeLow = GetFileSize ( _hFile, &amp;_sizeHigh ); <br> <br>        if (_sizeLow == 0xffffffff &amp;&amp; GetLastError() != NO_ERROR) <br>        { <br>            Close(); <br>            throw ( CException(HRESULT_FROM_WIN32(GetLastError()))); <br>        } <br> <br> <br>        if (_fWrite ) <br>        { <br>            CommonPageRound(_sizeLow, _sizeHigh); <br>        } <br> <br>        if ( _sizeLow != 0 || _sizeHigh != 0 ) <br>        { <br>            if ( GetOSVersion() == VER_PLATFORM_WIN32_NT ) <br>            { <br>                _hMap = CreateFileMapping( _hFile, <br>                                           0, // security <br>                                           _fWrite ? PAGE_READWRITE : PAGE_READONLY, <br>                                           _sizeHigh, <br>                                           _sizeLow, <br>                                           0 ); // name <br>            } <br>            else // windows 95 <br>            { <br>                _hMap = CreateFileMappingA( _hFile, <br>                                            0, // security <br>                                            _fWrite ? PAGE_READWRITE : PAGE_READONLY, <br>                                            _sizeHigh, <br>                                            _sizeLow, <br>                                            0 ); // name <br>            } <br> <br>            if (_hMap == NULL) <br>            { <br>                Close(); <br>                throw ( CException(HRESULT_FROM_WIN32(GetLastError()))); <br>            } <br>        } <br>    } <br>} <br> <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Function:   IsCreateExisting <br>// <br>//  Synopsis:   Tests if the error was a result of trying to create a <br>//              file that already exists. <br>// <br>//  Arguments:  [Error]      --  Error returned by the system. <br>//              [modeAccess] --  access mode specified to CreateFile. <br>//              [modeCreate] --  create mode specified to CreateFile. <br>// <br>//  Returns:    TRUE if the failure is because of trying to create a "New" <br>//              file with the same name as the one already existing. <br>//              FALSE otherwise. <br>// <br>//---------------------------------------------------------------------------- <br> <br>BOOL IsCreateExisting( ULONG Error, ULONG modeAccess, ULONG modeCreate ) <br>{ <br>    if ( (Error == ERROR_ALREADY_EXISTS || Error == ERROR_FILE_EXISTS) &amp;&amp; <br>         (modeAccess &amp; GENERIC_WRITE) &amp;&amp; <br>         (modeCreate &amp; CREATE_NEW) ) <br>    { <br>       return TRUE; <br>    } <br>    else <br>    { <br>        return FALSE; <br>    } <br>} <br> <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Member:     CMmStream::Open, public <br>// <br>//  Synopsis:   Open stream <br>// <br>//  Arguments:  [path] - file path <br>//              [modeAccess] -- access mode <br>//              [modeShare] -- sharing mode <br>//              [modeCreate] -- create mode <br>// <br>//-------------------------------------------------------------------------- <br> <br>void CMmStream::Open( <br>    const WCHAR* wcsPath, <br>    ULONG modeAccess, <br>    ULONG modeShare, <br>    ULONG modeCreate, <br>    ULONG modeAttribute) <br>{ <br>    _fWrite = FALSE; <br> <br>    if ( GetOSVersion() == VER_PLATFORM_WIN32_NT ) <br>    { <br>        _hFile = CreateFile( wcsPath, <br>                             modeAccess, <br>                             modeShare, <br>                             0, // security <br>                             modeCreate, <br>                             modeAttribute, <br>                             0 ); // template <br>    } <br>    else // win95 <br>    { <br>        // Worst case - size of multibyte == size of Unicode <br>        int nLen = wcslen( wcsPath ) * 2; <br>        char *pszPath = new char[nLen]; <br> <br>        if ( pszPath == NULL ) <br>        { <br>            _hFile = INVALID_HANDLE_VALUE; <br>        } <br>        else <br>        { <br>            if ( wcstombs( pszPath, wcsPath, nLen ) == -1 ) <br>            { <br>                _hFile = INVALID_HANDLE_VALUE; <br>            } <br>            else <br>            { <br>                _hFile = CreateFileA( pszPath, <br>                                      modeAccess, <br>                                      modeShare, <br>                                      0, // security <br>                                      modeCreate, <br>                                      modeAttribute, <br>                                      0 ); // template <br>            } <br> <br>            delete [] pszPath; <br>            pszPath = NULL; <br>        } <br>    } <br> <br>    if ( !Ok() ) <br>    { <br>        // <br>        // If applicable, delete a zomby and re-create it. <br>        // <br>        if ( IsCreateExisting( GetLastError(), modeAccess, modeCreate ) ) <br>        { <br>            htmlDebugOut(( DEB_ERROR, "CreateNew on %ws - already exists\n", <br>                         wcsPath )); <br>            modeCreate &amp;= ~CREATE_NEW;   // Turn off the Create new flag <br>            modeCreate |= CREATE_ALWAYS; // Enable the CREATE_ALWAYS flag. <br> <br>            if ( GetOSVersion() == VER_PLATFORM_WIN32_NT ) <br>            { <br>                _hFile = CreateFile( wcsPath, <br>                                     modeAccess, <br>                                     modeShare, <br>                                     0,          // security <br>                                     modeCreate, <br>                                     FILE_ATTRIBUTE_NORMAL, <br>                                     0 );        // template <br>            } <br>            else // win95 <br>            { <br>                // Worst case - size of multibyte == size of Unicode <br>                int nLen = wcslen( wcsPath ); <br>                char *pszPath = new char[nLen]; <br> <br>                if ( pszPath == NULL ) <br>                { <br>                    _hFile = INVALID_HANDLE_VALUE; <br>                } <br>                else <br>                { <br>                    if ( wcstombs( pszPath, wcsPath, nLen ) == -1 ) <br>                    { <br>                        _hFile = INVALID_HANDLE_VALUE; <br>                    } <br>                    else <br>                    { <br>                        _hFile = CreateFileA( pszPath, <br>                                              modeAccess, <br>                                              modeShare, <br>                                              0,          // security <br>                                              modeCreate, <br>                                              FILE_ATTRIBUTE_NORMAL, <br>                                              0 );        // template <br>                    } <br>                    delete [] pszPath; <br>                    pszPath = NULL; <br>                } <br>            } <br>        } <br>    } <br> <br>    if ( Ok() ) <br>    { <br>        _sizeLow = GetFileSize ( _hFile, &amp;_sizeHigh ); <br> <br>        if (_sizeLow == 0xffffffff &amp;&amp; GetLastError() != NO_ERROR) <br>        { <br>            Close(); <br>            htmlDebugOut (( DEB_ERROR, "Open stream %ws failed\n", wcsPath )); <br>            throw ( CException(HRESULT_FROM_WIN32(GetLastError()))); <br>        } <br> <br>        if ( modeAccess &amp; GENERIC_WRITE ) <br>        { <br>            _fWrite = TRUE; <br>            CommonPageRound(_sizeLow, _sizeHigh); <br>            // BUGBUG OFS zero size files <br>            if (_sizeLow == 0 &amp;&amp; _sizeHigh == 0) <br>            { <br>                if ( SetFilePointer ( _hFile, <br>                                      COMMON_PAGE_SIZE, <br>                                      0, <br>                                      FILE_BEGIN ) == 0xFFFFFFFF  &amp;&amp; <br>                     GetLastError() != NO_ERROR ) <br>                { <br>                    Close(); <br>                    htmlDebugOut(( DEB_ERROR, <br>                                 "CMmStream::Open -- SetFilePointer returned %d\n", <br>                                 GetLastError() )); <br>                    throw ( CException(HRESULT_FROM_WIN32(GetLastError()))); <br>                } <br> <br>                if ( !SetEndOfFile( _hFile ) ) <br>                { <br>                    Close(); <br>                    htmlDebugOut(( DEB_ERROR, <br>                                 "CMmStream::Open -- SetEndOfFile returned %d\n", <br>                                 GetLastError() )); <br>                    throw ( CException(HRESULT_FROM_WIN32(GetLastError()))); <br>                } <br>                _sizeLow = COMMON_PAGE_SIZE; <br>            } <br>        } <br> <br>        if ( _sizeLow != 0 || _sizeHigh != 0 ) <br>        { <br>            if ( GetOSVersion() == VER_PLATFORM_WIN32_NT ) <br>            { <br>                _hMap = CreateFileMapping( _hFile, <br>                                           0, // security <br>                                           _fWrite ? PAGE_READWRITE : PAGE_READONLY, <br>                                           _sizeHigh, <br>                                           _sizeLow, <br>                                           0 ); // name <br>            } <br>            else // win95 <br>            { <br>                _hMap = CreateFileMappingA( _hFile, <br>                                            0, // security <br>                                            _fWrite ? PAGE_READWRITE : PAGE_READONLY, <br>                                            _sizeHigh, <br>                                            _sizeLow, <br>                                            0 ); // name <br>            } <br> <br>            if (_hMap == NULL) <br>            { <br>                Close(); <br>                htmlDebugOut (( DEB_ERROR, "File mapping failed\n" )); <br>                throw ( CException(HRESULT_FROM_WIN32(GetLastError()))); <br>            } <br>        } <br>    } <br>    else <br>    { <br>        htmlDebugOut (( DEB_ITRACE, "Open failed on MM Stream; GetLastError()=0x%x\n", <br>                      GetLastError() )); <br>    } <br>} <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Member:     CMmStream::Close, public <br>// <br>//  Synopsis:   Create all handles <br>// <br>//-------------------------------------------------------------------------- <br> <br>void CMmStream::Close() <br>{ <br>    if (Ok()) <br>    { <br>        if(_hMap ) <br>        { <br>            if ( !CloseHandle(_hMap)) <br>            { <br>                htmlDebugOut (( DEB_ERROR, "Closing file mapping failed\n" )); <br>                throw ( CException(HRESULT_FROM_WIN32(GetLastError()))); <br>            } <br>            _hMap = 0; <br>        } <br>        if ( !CloseHandle ( _hFile )) <br>        { <br> <br>            htmlDebugOut (( DEB_ERROR, "Closing file handle failed\n" )); <br>            throw ( CException(HRESULT_FROM_WIN32(GetLastError()))); <br>        } <br>        _hFile = INVALID_HANDLE_VALUE; <br>    } <br>} <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Member:     CMmStream::SetSize, public <br>// <br>//  Synopsis:   Increase the size of the (writable) file <br>// <br>//  Arguments:  [storage] -- storage (not used) <br>//              [newSizeLow]  -- Low 32 bits of filesize <br>//              [newSizeHigh] -- High 32 bits of filesize <br>// <br>//-------------------------------------------------------------------------- <br> <br>void CMmStream::SetSize ( PStorage&amp; storage, <br>    ULONG newSizeLow, ULONG newSizeHigh ) <br>{ <br>    if (_hMap != 0) <br>        CloseHandle(_hMap); <br> <br>    LARGE_INTEGER sizeOld = { _sizeLow, _sizeHigh }; <br>    LARGE_INTEGER sizeNew = { newSizeLow, newSizeHigh }; <br> <br>    if (sizeNew.QuadPart &lt; sizeOld.QuadPart) <br>    { <br>        if ( SetFilePointer ( _hFile, <br>                              newSizeLow, <br>                              (long *)&amp;newSizeHigh,   // BUGBUG: Win32 <br>                              FILE_BEGIN ) == 0xFFFFFFFF  &amp;&amp; <br>             GetLastError() != NO_ERROR ) <br>        { <br>            htmlDebugOut(( DEB_ERROR, <br>                         "CMmStream::Close -- SetFilePointer returned %d\n", <br>                         GetLastError() )); <br>            throw ( CException(HRESULT_FROM_WIN32(GetLastError()))); <br>        } <br> <br>        if ( !SetEndOfFile( _hFile ) ) <br>        { <br>            htmlDebugOut(( DEB_ERROR, <br>                         "CMmStream::Close -- SetEndOfFile returned %d\n", <br>                         GetLastError() )); <br>            throw ( CException(HRESULT_FROM_WIN32(GetLastError()))); <br>        } <br> <br>    } <br> <br>    if ( GetOSVersion() == VER_PLATFORM_WIN32_NT ) <br>    { <br>        _hMap = CreateFileMapping( _hFile, <br>                                   0, // security <br>                                   PAGE_READWRITE, <br>                                   newSizeHigh, <br>                                   newSizeLow, <br>                                   0 ); // name <br>    } <br>    else // win95 <br>    { <br>        _hMap = CreateFileMappingA( _hFile, <br>                                    0, // security <br>                                    PAGE_READWRITE, <br>                                    newSizeHigh, <br>                                    newSizeLow, <br>                                    0 ); // name <br>    } <br> <br>    if (_hMap == 0) <br>        throw ( CException(HRESULT_FROM_WIN32(GetLastError()))); <br> <br>    _sizeLow = newSizeLow; <br>    _sizeHigh = newSizeHigh; <br>} <br> <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Member:     CMmStream::MapAll, public <br>// <br>//  Synopsis:   Create file mapping <br>// <br>//-------------------------------------------------------------------------- <br>void CMmStream::MapAll ( CMmStreamBuf&amp; sbuf ) <br>{ <br>    Win4Assert ( SizeHigh() == 0 ); <br>    Map ( sbuf, SizeLow(), 0, 0 ); <br>} <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Member:     CMmStream::Map, private <br>// <br>//  Synopsis:   Create file mapping <br>// <br>//  Arguments:  [cb] -- size of the mapped area <br>//              [offLow] -- low part of file offset <br>//              [offHigh] -- high part of file offset <br>// <br>//-------------------------------------------------------------------------- <br> <br>void CMmStream::Map ( CMmStreamBuf&amp; sbuf, <br>                      ULONG cb, ULONG offLow, ULONG offHigh, <br>                      BOOL <br>                    ) <br>{ <br>    Win4Assert ( _hMap != 0 ); <br> <br>    if ( !_fWrite ) <br>    { <br>        // <br>        // Adjust size to be min( cb, sizeoffile - off ) <br>        // <br> <br>        LARGE_INTEGER size = { _sizeLow, _sizeHigh }; <br>        LARGE_INTEGER off  = { offLow, offHigh }; <br>        LARGE_INTEGER licb = { cb, 0 }; <br>        LARGE_INTEGER diff; <br> <br>        diff.QuadPart = size.QuadPart - off.QuadPart; <br> <br>        if ( diff.QuadPart &lt; licb.QuadPart ) <br>        { <br>            cb = diff.LowPart; <br>            htmlDebugOut(( DEB_ITRACE, <br>                         "CMmStream::Map -- reducing map to 0x%x bytes\n", <br>                         cb )); <br>        } <br>    } <br> <br>    void* buf = MapViewOfFile ( <br>            _hMap, <br>            _fWrite? FILE_MAP_WRITE: FILE_MAP_READ, <br>            offHigh, <br>            offLow, <br>            cb ); <br> <br>    if ( 0 == buf ) <br>    { <br>        htmlDebugOut(( DEB_ERROR, <br>                     "CMmStream::Map -- MapViewOfFile returned %d\n", <br>                     GetLastError() )); <br>        throw( CException( HRESULT_FROM_WIN32( GetLastError() ) ) ); <br>    } <br> <br>    sbuf.SetBuf( buf ); <br>    sbuf.SetSize ( cb ); <br>    sbuf.SetStream ( this ); <br>} <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Member:     CMmStream::Unmap, public <br>// <br>//  Synopsis:   Unmap the view of file <br>// <br>//  History:    10-Mar-93 BartoszM  Created <br>// <br>//-------------------------------------------------------------------------- <br>void CMmStream::Unmap( CMmStreamBuf&amp; sbuf ) <br>{ <br>     if ( !UnmapViewOfFile(sbuf.Get()) ) <br>     { <br>         htmlDebugOut(( DEB_ERROR, "UnmapViewOfFile returned %d\n", <br>                      GetLastError() )); <br>         throw( CException( HRESULT_FROM_WIN32( GetLastError() ) ) ); <br>     } <br> <br>     sbuf.SetBuf ( 0 ); <br>} <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Member:     CMmStream::Flush, public <br>// <br>//  Synopsis:   Flush the view back to disk <br>// <br>//  History:    10-Mar-93 BartoszM  Created <br>// <br>//-------------------------------------------------------------------------- <br> <br>void CMmStream::Flush( CMmStreamBuf&amp; sbuf, ULONG cb ) <br>{ <br>    FlushViewOfFile ( sbuf.Get(), cb ); <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
