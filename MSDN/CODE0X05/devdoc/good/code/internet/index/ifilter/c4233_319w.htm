<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>HTMLIFLT.CXX</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context4244"></a>HTMLIFLT.CXX</h2>
<pre><code>//+------------------------------------------------------------------------- <br>// <br>//  Copyright 1992 - 1998 Microsoft Corporation <br>// <br>//  File:       htmliflt.cxx <br>// <br>//  Contents:   Html IFilter <br>// <br>//-------------------------------------------------------------------------- <br> <br>#include &lt;pch.cxx&gt; <br>#pragma hdrstop <br> <br>class CHtmlElement; <br> <br>#include &lt;eh.h&gt; <br> <br>#include &lt;htmliflt.hxx&gt; <br>#include &lt;serstrm.hxx&gt; <br> <br>#include &lt;bag.hxx&gt; <br>#include &lt;charhash.hxx&gt; <br>#include &lt;htmlfilt.hxx&gt; <br> <br>long gulcInstances = 0; <br> <br>extern "C" GUID CLSID_HtmlIFilter = { <br>    0xE0CA5340, <br>    0x4534, <br>    0x11CF, <br>    { 0xB9, 0x52, 0x00, 0xAA, 0x00, 0x51, 0xFE, 0x20 } <br>}; <br> <br>// <br>// BUGBUG:  CLSID_HtmlClass is only necessary because real OLE doesn't <br>//          yet support persistent handlers as KyleOLE does. <br>//          When DllGetClassObject is called, real OLE asks for CLSID_HtmlClass, <br>//          whereas under the persistent handler model, CLSID_HtmlIFilter <br>//          should be used. <br>// <br> <br>extern "C" GUID CLSID_HtmlClass = { <br>    0x6A7A7550, <br>    0x4535, <br>    0x11CF, <br>    { 0xB9, 0x52, 0x00, 0xAA, 0x00, 0x51, 0xFE, 0x20 } <br>}; <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Method:     CHtmlIFilterBase::CHtmlIFilterBase <br>// <br>//  Synopsis:   Base constructor <br>// <br>//  Effects:    Manages global refcount <br>// <br>//-------------------------------------------------------------------------- <br> <br>CHtmlIFilterBase::CHtmlIFilterBase() <br>{ <br>    _uRefs = 1; <br>    InterlockedIncrement( &amp;gulcInstances ); <br>} <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Method:     CHtmlIFilterBase::~CHtmlIFilterBase <br>// <br>//  Synopsis:   Base destructor <br>// <br>//  Effects:    Manages global refcount <br>// <br>//-------------------------------------------------------------------------- <br> <br>CHtmlIFilterBase::~CHtmlIFilterBase() <br>{ <br>    InterlockedDecrement( &amp;gulcInstances ); <br>} <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Method:     CHtmlIFilterBase::QueryInterface <br>// <br>//  Synopsis:   Rebind to other interface <br>// <br>//  Arguments:  [riid]      -- IID of new interface <br>//              [ppvObject] -- New interface * returned here <br>// <br>//  Returns:    S_OK if bind succeeded, E_NOINTERFACE if bind failed <br>// <br>//-------------------------------------------------------------------------- <br> <br>SCODE STDMETHODCALLTYPE CHtmlIFilterBase::QueryInterface( REFIID riid, <br>                                                          void  ** ppvObject) <br>{ <br>    // <br>    // Optimize QueryInterface by only checking minimal number of bytes. <br>    // <br>    // IID_IUnknown     = 00000000-0000-0000-C000-000000000046 <br>    // IID_IFilter      = 89BCB740-6119-101A-BCB7-00DD010655AF <br>    // IID_IPersist     = 0000010c-0000-0000-C000-000000000046 <br>    // IID_IPersistFile = 0000010b-0000-0000-C000-000000000046 <br>    //                          -- <br>    //                           | <br>    //                           +--- Unique! <br>    // <br> <br>    Win4Assert( (IID_IUnknown.Data1     &amp; 0x000000FF) == 0x00 ); <br>    Win4Assert( (IID_IFilter.Data1      &amp; 0x000000FF) == 0x40 ); <br>    Win4Assert( (IID_IPersist.Data1     &amp; 0x000000FF) == 0x0c ); <br>    Win4Assert( (IID_IPersistFile.Data1 &amp; 0x000000FF) == 0x0b ); <br> <br>    IUnknown *pUnkTemp; <br>    SCODE sc = S_OK; <br> <br>    switch( riid.Data1 &amp; 0x000000FF ) <br>    { <br>    case 0x00: <br>        if ( IID_IUnknown == riid ) <br>            pUnkTemp = (IUnknown *)(IPersist *)(IPersistFile *)this; <br>        else <br>            sc = E_NOINTERFACE; <br>        break; <br> <br>    case 0x40: <br>        if ( IID_IFilter == riid ) <br>            pUnkTemp = (IUnknown *)(IFilter *)this; <br>        else <br>            sc = E_NOINTERFACE; <br>        break; <br> <br>    case 0x0c: <br>        if ( IID_IPersist == riid ) <br>            pUnkTemp = (IUnknown *)(IPersist *)(IPersistFile *)this; <br>        else <br>            sc = E_NOINTERFACE; <br>        break; <br> <br>    case 0x0b: <br>        if ( IID_IPersistFile == riid ) <br>            pUnkTemp = (IUnknown *)(IPersistFile *)this; <br>        else <br>            sc = E_NOINTERFACE; <br>        break; <br> <br>    default: <br>        pUnkTemp = 0; <br>        sc = E_NOINTERFACE; <br>        break; <br>    } <br> <br>    if( 0 != pUnkTemp ) <br>    { <br>        *ppvObject = (void  * )pUnkTemp; <br>        pUnkTemp-&gt;AddRef(); <br>    } <br>    return(sc); <br>} <br> <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Method:     CHtmlIFilterBase::AddRef <br>// <br>//  Synopsis:   Increments refcount <br>// <br>//-------------------------------------------------------------------------- <br> <br>ULONG STDMETHODCALLTYPE CHtmlIFilterBase::AddRef() <br>{ <br>    return InterlockedIncrement( &amp;_uRefs ); <br>} <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Method:     CHtmlIFilterBase::Release <br>// <br>//  Synopsis:   Decrement refcount.  Delete if necessary. <br>// <br>//-------------------------------------------------------------------------- <br> <br>ULONG STDMETHODCALLTYPE CHtmlIFilterBase::Release() <br>{ <br>    unsigned long uTmp = InterlockedDecrement( &amp;_uRefs ); <br> <br>    if ( 0 == uTmp ) <br>        delete this; <br> <br>    return(uTmp); <br>} <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Method:     CHtmlIFilterCF::CHtmlIFilterCF <br>// <br>//  Synopsis:   Html IFilter class factory constructor <br>// <br>//+------------------------------------------------------------------------- <br> <br>CHtmlIFilterCF::CHtmlIFilterCF() <br>{ <br>    _uRefs = 1; <br>    InterlockedIncrement( &amp;gulcInstances ); <br>} <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Method:     CHtmlIFilterCF::~CHtmlIFilterCF <br>// <br>//  Synopsis:   Html IFilter class factory destructor <br>// <br>//  History:    1-Jan-1996    SitaramR    Created <br>// <br>//-------------------------------------------------------------------------- <br> <br>CHtmlIFilterCF::~CHtmlIFilterCF() <br>{ <br>    InterlockedDecrement( &amp;gulcInstances ); <br>} <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Method:     CHtmlIFilterCF::QueryInterface <br>// <br>//  Synopsis:   Rebind to other interface <br>// <br>//  Arguments:  [riid]      -- IID of new interface <br>//              [ppvObject] -- New interface * returned here <br>// <br>//  Returns:    S_OK if bind succeeded, E_NOINTERFACE if bind failed <br>// <br>//-------------------------------------------------------------------------- <br> <br>SCODE STDMETHODCALLTYPE CHtmlIFilterCF::QueryInterface( REFIID riid, <br>                                                        void  ** ppvObject ) <br>{ <br>    // <br>    // Optimize QueryInterface by only checking minimal number of bytes. <br>    // <br>    // IID_IUnknown      = 00000000-0000-0000-C000-000000000046 <br>    // IID_IClassFactory = 00000001-0000-0000-C000-000000000046 <br>    //                           -- <br>    //                           | <br>    //                           +--- Unique! <br>    // <br> <br>    Win4Assert( (IID_IUnknown.Data1      &amp; 0x000000FF) == 0x00 ); <br>    Win4Assert( (IID_IClassFactory.Data1 &amp; 0x000000FF) == 0x01 ); <br> <br>    IUnknown *pUnkTemp; <br>    SCODE sc = S_OK; <br> <br>    switch( riid.Data1 &amp; 0x000000FF ) <br>    { <br>    case 0x00: <br>        if ( IID_IUnknown == riid ) <br>            pUnkTemp = (IUnknown *)(IPersist *)(IPersistFile *)this; <br>        else <br>            sc = E_NOINTERFACE; <br>        break; <br> <br>    case 0x01: <br>        if ( IID_IClassFactory == riid ) <br>            pUnkTemp = (IUnknown *)(IClassFactory *)this; <br>        else <br>            sc = E_NOINTERFACE; <br>        break; <br> <br>    default: <br>        pUnkTemp = 0; <br>        sc = E_NOINTERFACE; <br>        break; <br>    } <br> <br>    if( 0 != pUnkTemp ) <br>    { <br>        *ppvObject = (void  * )pUnkTemp; <br>        pUnkTemp-&gt;AddRef(); <br>    } <br> <br>    return(sc); <br>} <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Method:     CHtmlIFilterCF::AddRef <br>// <br>//  Synopsis:   Increments refcount <br>// <br>//-------------------------------------------------------------------------- <br> <br>ULONG STDMETHODCALLTYPE CHtmlIFilterCF::AddRef() <br>{ <br>    return InterlockedIncrement( &amp;_uRefs ); <br>} <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Method:     CHtmlIFilterCF::Release <br>// <br>//  Synopsis:   Decrement refcount.  Delete if necessary. <br>// <br>//-------------------------------------------------------------------------- <br> <br>ULONG STDMETHODCALLTYPE CHtmlIFilterCF::Release() <br>{ <br>    unsigned long uTmp = InterlockedDecrement( &amp;_uRefs ); <br> <br>    if ( 0 == uTmp ) <br>        delete this; <br> <br>    return(uTmp); <br>} <br> <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Method:     CHtmlIFilterCF::CreateInstance <br>// <br>//  Synopsis:   Creates new HtmlIFilter object <br>// <br>//  Arguments:  [pUnkOuter] -- 'Outer' IUnknown <br>//              [riid]      -- Interface to bind <br>//              [ppvObject] -- Interface returned here <br>// <br>//-------------------------------------------------------------------------- <br> <br>SCODE STDMETHODCALLTYPE CHtmlIFilterCF::CreateInstance( IUnknown * pUnkOuter, <br>                                                        REFIID riid, <br>                                                        void  * * ppvObject ) <br>{ <br>    CHtmlIFilter *  pIUnk = 0; <br>    SCODE sc = S_OK; <br> <br>    _se_translator_function tf = _set_se_translator( SystemExceptionTranslator ); <br> <br>    try <br>    { <br>        pIUnk = newk(mtNewX, NULL) CHtmlIFilter(); <br>        sc = pIUnk-&gt;QueryInterface(  riid , ppvObject ); <br> <br>        if( SUCCEEDED(sc) ) <br>            pIUnk-&gt;Release();  // Release extra refcount from QueryInterface <br>    } <br>    catch(CException&amp; e) <br>    { <br>        Win4Assert( 0 == pIUnk ); <br> <br>        htmlDebugOut(( DEB_ERROR, <br>                       "Exception 0x%x caught in CHtmlIFilterCF::CreateInstance", <br>                       e.GetErrorCode() )); <br>        sc = GetOleError( e ); <br>    } <br> <br>    _set_se_translator( tf ); <br> <br>    return (sc); <br>} <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Method:     CHtmlIFilterCF::LockServer <br>// <br>//  Synopsis:   Force class factory to remain loaded <br>// <br>//  Arguments:  [fLock] -- TRUE if locking, FALSE if unlocking <br>// <br>//  Returns:    S_OK <br>// <br>//-------------------------------------------------------------------------- <br> <br>SCODE STDMETHODCALLTYPE CHtmlIFilterCF::LockServer(BOOL fLock) <br>{ <br>    if(fLock) <br>        InterlockedIncrement( &amp;gulcInstances ); <br>    else <br>        InterlockedDecrement( &amp;gulcInstances ); <br> <br>    return(S_OK); <br>} <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Function:   DllGetClassObject <br>// <br>//  Synopsis:   Ole DLL load class routine <br>// <br>//  Arguments:  [cid]    -- Class to load <br>//              [iid]    -- Interface to bind to on class object <br>//              [ppvObj] -- Interface pointer returned here <br>// <br>//  Returns:    Html filter class factory <br>// <br>//-------------------------------------------------------------------------- <br> <br>extern "C" SCODE STDMETHODCALLTYPE DllGetClassObject( REFCLSID   cid, <br>                                                      REFIID     iid, <br>                                                      void **    ppvObj ) <br>{ <br>    IUnknown *  pResult = 0; <br>    SCODE       sc      = S_OK; <br> <br>    _se_translator_function tf = _set_se_translator( SystemExceptionTranslator ); <br> <br>    try <br>    { <br>        if ( cid == CLSID_HtmlIFilter || cid == CLSID_HtmlClass ) <br>            pResult = (IUnknown *) newk(mtNewX, NULL) CHtmlIFilterCF; <br>        else <br>            sc = E_NOINTERFACE; <br> <br>        if ( pResult ) <br>        { <br>            sc = pResult-&gt;QueryInterface( iid, ppvObj ); <br>            pResult-&gt;Release();     // Release extra refcount from QueryInterface <br>        } <br>    } <br>    catch(CException&amp; e) <br>    { <br>        if ( pResult ) <br>            pResult-&gt;Release(); <br> <br>        htmlDebugOut(( DEB_ERROR, <br>                       "Exception 0x%x caught in CHtmlIFilterCF::CreateInstance", <br>                       e.GetErrorCode() )); <br>        sc = GetOleError( e ); <br>    } <br> <br>    _set_se_translator( tf ); <br> <br>    return (sc); <br>} <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Method:     DllCanUnloadNow <br>// <br>//  Synopsis:   Notifies DLL to unload (cleanup global resources) <br>// <br>//  Returns:    S_OK if it is acceptable for caller to unload DLL. <br>// <br>//-------------------------------------------------------------------------- <br> <br>extern "C" SCODE STDMETHODCALLTYPE DllCanUnloadNow( void ) <br>{ <br>    if ( 0 == gulcInstances ) <br>        return( S_OK ); <br>    else <br>        return( S_FALSE ); <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
