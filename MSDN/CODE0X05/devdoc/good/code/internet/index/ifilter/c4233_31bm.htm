<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>MMSCBUF.CXX</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context4252"></a>MMSCBUF.CXX</h2>
<pre><code>//+--------------------------------------------------------------------------- <br>// <br>//  Copyright 1992 - 1998 Microsoft Corporation. <br>// <br>//  File:       mmscbuf.cxx <br>// <br>//  Contents:   Memory Mapped Stream buffer for consecutive buffer mapping <br>// <br>//  Classes:    CMmStreamConsecBuf <br>// <br>//---------------------------------------------------------------------------- <br> <br>#include &lt;pch.cxx&gt; <br>#pragma hdrstop <br> <br>#include "mmscbuf.hxx" <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Member:     CMmStreamConsecBuf::CMmStreamConsecBuf, public <br>// <br>//  Synopsis:   Constructor <br>// <br>//-------------------------------------------------------------------------- <br> <br>CMmStreamConsecBuf::CMmStreamConsecBuf() <br>: _pMmStream(0) <br>{ <br>    LARGE_INTEGER liOffset = { 0, 0 }; <br>    _liOffset = liOffset; <br>} <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Member:     CMmStreamConsecBuf::Map, public <br>// <br>//  Synopsis:   Map next consecutive part of file <br>// <br>//  Arguments:  [cb] -- size of the mapped area <br>// <br>//-------------------------------------------------------------------------- <br> <br>void CMmStreamConsecBuf::Map( ULONG cb ) <br>{ <br>    Win4Assert( 0 != _pMmStream ); <br> <br>    if ( Get() != 0 ) <br>        _pMmStream-&gt;Unmap( *this ); <br> <br>    LARGE_INTEGER liNewOffset; <br>    LARGE_INTEGER liStreamSize={_pMmStream-&gt;SizeLow(), _pMmStream-&gt;SizeHigh()}; <br> <br>     liNewOffset.QuadPart = cb + _liOffset.QuadPart; <br> <br>    if ( liNewOffset.QuadPart &gt; liStreamSize.QuadPart ) <br>    { <br>        cb = (ULONG)(liStreamSize.QuadPart - _liOffset.QuadPart); <br>        liNewOffset = liStreamSize; <br>    } <br> <br>    _pMmStream-&gt;Map( *this, <br>                     cb, <br>                     _liOffset.LowPart, <br>                     _liOffset.HighPart ); <br> <br>    _liOffset = liNewOffset; <br>} <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Member:     CMmStreamConsecBuf::Init, public <br>// <br>//  Synopsis:   Initizializes CMmStreamConsecBuf <br>// <br>//  Arguments:  [pMmStream] -- pointer to the CMmStream from which to fill <br>//                             the buffer <br>// <br>//-------------------------------------------------------------------------- <br> <br>void CMmStreamConsecBuf::Init( PMmStream * pMmStream ) <br>{ <br>    _pMmStream = pMmStream; <br>    LARGE_INTEGER liOffset = { 0, 0 }; <br>    _liOffset = liOffset; <br>} <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Member:     CMmStreamConsecBuf::Rewind, public <br>// <br>//  Synopsis:   Rewind file to beginning. <br>// <br>//-------------------------------------------------------------------------- <br> <br>void CMmStreamConsecBuf::Rewind() <br>{ <br> <br>    Win4Assert( 0 != _pMmStream ); <br> <br>    if ( Get() != 0 ) <br>        _pMmStream-&gt;Unmap( *this ); <br> <br>    _liOffset.LowPart = 0; <br>    _liOffset.HighPart = 0; <br>} <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Member:     CMmStreamConsecBuf::Eof, public <br>// <br>//  Synopsis:   Returns whether end of file has been hit <br>// <br>//  Returns:    FALSE if there is still more file to be mapped.  TRUE <br>//              otherwise. <br>// <br>//-------------------------------------------------------------------------- <br> <br>BOOL CMmStreamConsecBuf::Eof() <br>{ <br>    Win4Assert( 0 != _pMmStream ); <br>    return( ( (ULONG) _liOffset.HighPart == _pMmStream-&gt;SizeHigh() ) &amp;&amp; <br>            ( _liOffset.LowPart == _pMmStream-&gt;SizeLow() ) ); <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
