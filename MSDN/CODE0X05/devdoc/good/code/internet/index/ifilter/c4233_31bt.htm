<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SCRIPTAG.CXX</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context4259"></a>SCRIPTAG.CXX</h2>
<pre><code>//+--------------------------------------------------------------------------- <br>// <br>//  Copyright 1992 - 1998 Microsoft Corporation. <br>// <br>//  File:       scripttag.cxx <br>// <br>//  Contents:   Parsing algorithm for script tag in Html <br>// <br>//  Classes:    CScriptTag <br>// <br>//---------------------------------------------------------------------------- <br> <br>#include &lt;pch.cxx&gt; <br>#pragma hdrstop <br> <br>#include &lt;scriptag.hxx&gt; <br>#include &lt;htmlguid.hxx&gt; <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Method:     CScriptTag::CScriptTag <br>// <br>//  Synopsis:   Constructor <br>// <br>//  Arguments:  [htmlIFilter]    -- Html IFilter <br>//              [serialStream]   -- Input stream <br>//              [clsidScriptInfo]  -- Clsid for script chunk <br>// <br>//-------------------------------------------------------------------------- <br> <br>CScriptTag::CScriptTag( CHtmlIFilter&amp; htmlIFilter, <br>                    CSerialStream&amp; serialStream, <br>                    GUID clsidScriptInfo ) <br>    : CHtmlElement(htmlIFilter, serialStream), <br>      _clsidScriptInfo(clsidScriptInfo), <br>      _eState(NoMoreContent) <br>{ <br>    _awszPropSpec[0] = 0; <br>} <br> <br> <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Method:     CScriptTag::GetChunk <br>// <br>//  Synopsis:   Gets the next chunk and returns chunk information in pStat <br>// <br>//  Arguments:  [pStat] -- chunk information returned here <br>// <br>//-------------------------------------------------------------------------- <br> <br>SCODE CScriptTag::GetChunk( STAT_CHUNK * pStat ) <br>{ <br>    switch ( _eState ) <br>    { <br> <br>    case  FilteringContent: <br>    { <br>        SCODE sc = SkipRemainingTextAndGotoNextChunk( pStat ); <br> <br>        return sc; <br>    } <br> <br>    case NoMoreContent: <br>    { <br>            SCODE sc = SwitchToNextHtmlElement( pStat ); <br> <br>            return sc; <br>    } <br> <br>    default: <br>        Win4Assert( !"Unknown _eState in CScriptTag::GetChunk" ); <br>        htmlDebugOut(( DEB_ERROR, "CScriptTag::GetChunk, unkown tag state: %d\n", _eState )); <br> <br>        return S_OK; <br>    } <br>} <br> <br> <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Method:     CScriptTag::GetText <br>// <br>//  Synopsis:   Retrieves text from current chunk <br>// <br>//  Arguments:  [pcwcOutput] -- count of UniCode characters in buffer <br>//              [awcBuffer]  -- buffer for text <br>// <br>//-------------------------------------------------------------------------- <br> <br>SCODE CScriptTag::GetText( ULONG *pcwcOutput, WCHAR *awcBuffer ) <br>{ <br>    switch( _eState ) <br>    { <br>    case NoMoreContent: <br>        return FILTER_E_NO_MORE_TEXT; <br> <br>    case FilteringContent: <br>    { <br>        ULONG cCharsRead = 0; <br>        while ( cCharsRead &lt; *pcwcOutput ) <br>        { <br>            ULONG cCharsScanned; <br>            ULONG cCharsNeeded = *pcwcOutput - cCharsRead; <br>            CToken token; <br>            _scanner.GetBlockOfChars( cCharsNeeded, <br>                                      awcBuffer + cCharsRead, <br>                                      cCharsScanned, <br>                                      token ); <br> <br>            cCharsRead += cCharsScanned; <br>            if ( cCharsScanned == cCharsNeeded ) <br>            { <br>                // <br>                // We've read the #chars requested by user <br>                // <br>                break; <br>            } <br> <br>            HtmlTokenType eTokType = token.GetTokenType(); <br>            if ( eTokType == EofToken || eTokType == ScriptToken ) <br>            { <br>                // <br>                // End of file or end script tag <br>                // <br>                _eState = NoMoreContent; <br> <br>                break; <br>            } <br>            else if ( eTokType == BreakToken ) <br>            { <br>                // <br>                // Insert a newline char <br>                // <br>                Win4Assert( cCharsRead &lt; *pcwcOutput ); <br>                awcBuffer[cCharsRead++] = L'\n'; <br>                _scanner.EatTag(); <br>            } <br>            else if ( eTokType == CommentToken ) <br>            { <br>                // <br>                // Scripts are often enclosed in comments for backward <br>                // compatibilty, so do nothing <br>                // <br>            } <br>            else <br>            { <br>                // <br>                // Uninteresting tag, so skip over tag and continue processing <br>                // <br>                _scanner.EatTag(); <br>            } <br>        } <br> <br>        *pcwcOutput = cCharsRead; <br> <br>        if ( _eState == NoMoreContent ) <br>            return FILTER_S_LAST_TEXT; <br>        else <br>            return S_OK; <br> <br>        break; <br>    } <br> <br>    default: <br>        Win4Assert( !"Unknown value of _eState" ); <br>        htmlDebugOut(( DEB_ERROR, <br>                       "CScriptTag::GetText, unknown value of _eState: %d\n", <br>                       _eState )); <br>        return S_OK; <br>    } <br>} <br> <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Method:     CScriptTag::GetValue <br>// <br>//  Synopsis:   Retrieves value from current chunk <br>// <br>//  Arguments:  [ppPropValue] -- Value returned here <br>// <br>//-------------------------------------------------------------------------- <br> <br>SCODE CScriptTag::GetValue( VARIANT **ppPropValue ) <br>{ <br>    return FILTER_E_NO_VALUES;   <br>} <br> <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Method:     CScriptTag::InitStatChunk <br>// <br>//  Synopsis:   Initializes the STAT_CHUNK <br>// <br>//  Arguments:  [pStat] -- STAT_CHUNK to initialize <br>// <br>//-------------------------------------------------------------------------- <br> <br>void CScriptTag::InitStatChunk( STAT_CHUNK *pStat ) <br>{ <br>    WCHAR *pwcLang; <br>    unsigned cwcLang; <br> <br>    // <br>    // Read the Language field <br>    // <br>    _scanner.ReadTagIntoBuffer(); <br>    _scanner.ScanTagBuffer( L"language=\"", pwcLang, cwcLang ); <br> <br>    if ( cwcLang == 0 ) <br>    { <br>        // <br>        // Use whatever was specified in an earlier script tag, if none, the default is <br>        // Javascript <br>        // <br>        if ( _awszPropSpec[0] == 0 ) <br>            RtlCopyMemory( _awszPropSpec, L"javascript", (wcslen(L"javascript") + 1) * sizeof( WCHAR) ); <br>    } <br>    else <br>    { <br>        if ( cwcLang &gt; MAX_PROPSPEC_STRING_LENGTH ) <br>            cwcLang = MAX_PROPSPEC_STRING_LENGTH;     // Truncate to max length permitted <br> <br>        RtlCopyMemory( _awszPropSpec, pwcLang, cwcLang * sizeof(WCHAR) ); <br>        _awszPropSpec[cwcLang] = 0; <br>    } <br> <br>    _eState = FilteringContent; <br> <br>    pStat-&gt;attribute.guidPropSet = _clsidScriptInfo; <br>    pStat-&gt;attribute.psProperty.ulKind = PRSPEC_LPWSTR; <br>    pStat-&gt;attribute.psProperty.lpwstr = _awszPropSpec; <br> <br>    pStat-&gt;idChunk = _htmlIFilter.GetNextChunkId(); <br>    pStat-&gt;flags = CHUNK_TEXT; <br>    pStat-&gt;locale = _htmlIFilter.GetLocale(); <br>    pStat-&gt;breakType = CHUNK_EOS; <br>    pStat-&gt;idChunkSource = pStat-&gt;idChunk; <br>    pStat-&gt;cwcStartSource = 0; <br>    pStat-&gt;cwcLenSource = 0; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
