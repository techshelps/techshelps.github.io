<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>JDEBUG.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context4297"></a>JDEBUG.CPP</h2>
<pre><code>/*++ <br> <br>Copyright (c) 1996  Microsoft Corporation <br> <br>Module Name: <br> <br>   jdebug.cpp <br> <br>Abstract: <br> <br>   Java debugger class implementation. <br> <br>   The C++ debugger sample preforms the following steps: <br> <br>    1) Connects to the debug manager. <br>    2) Runs the Java debuggee applet. <br>    3) Watches for the debuggee's Java VM to be created, and puts up a message box. <br>    4) Connects to the debuggee's Java VM. <br>    5) Watches for the debuggee class to be loaded. <br>    6) Sets a breakpoint in a method in the debuggee class. <br>    7) Watches for the breakpoint to be hit, and puts up a message box. <br>    8) Clears the breakpoint. <br>    9) Watches for the debuggee's Java VM to be destroyed, and puts up a message box. <br>   10) Disconnects from the debuggee's Java VM. <br>   11) Disconnects from the debug manager. <br>   12) Exits. <br> <br>--*/ <br> <br> <br>/* Headers <br> **********/ <br> <br>#include "project.hpp" <br> <br>#include &lt;javadbg.h&gt; <br>#include &lt;jdbgguid.h&gt; <br> <br>#include "refcount.hpp" <br> <br> <br>/* Classes <br> **********/ <br> <br>// sample Java debugger class <br> <br>class JavaDebugger : public RefCount, <br>                     public IRemoteDebugManagerCallback, <br>                     public IRemoteProcessCallback <br>{ <br>private: <br>   /* Fields <br>    *********/ <br> <br>   // debug manager <br>   IRemoteDebugManager *m_pirdm; <br> <br>   // remote process <br>   IRemoteProcess *m_pirp; <br> <br>   // debuggee class name <br>   LPWSTR m_pwszDebugClass; <br> <br>   /* Methods <br>    **********/ <br> <br>   UINT RunMessageLoop(void); <br>   void QuitMessageLoop(UINT uResult); <br> <br>public: <br>   /* Methods <br>    **********/ <br> <br>   JavaDebugger(void); <br>   ~JavaDebugger(void); <br>   HRESULT Initialize(IRemoteDebugManager *pirdm); <br>   void Terminate(void); <br>   HRESULT Debug(LPCSTR pcszDebugClass); <br> <br>   // IRemoteDebugManagerCallback methods <br> <br>   HRESULT STDMETHODCALLTYPE ProcessCreateEvent(IRemoteProcess *pirpNew, IRemoteProcess *pirpParent); <br> <br>   // IRemoteProcessCallback methods <br> <br>   HRESULT STDMETHODCALLTYPE DebugStringEvent(IRemoteThread *pirth, LPCWSTR pcwszDebugMsg); <br>   HRESULT STDMETHODCALLTYPE CodeBreakpointEvent(IRemoteThread *pirth); <br>   HRESULT STDMETHODCALLTYPE DataBreakpointEvent(IRemoteThread *pirth, IRemoteObject *piro); <br>   HRESULT STDMETHODCALLTYPE ExceptionEvent(IRemoteThread *pirth, IRemoteClassField *pircfException, EXCEPTIONKIND exk); <br>   HRESULT STDMETHODCALLTYPE StepEvent(IRemoteThread *pirth); <br>   HRESULT STDMETHODCALLTYPE CanStopEvent(IRemoteThread *pirth); <br>   HRESULT STDMETHODCALLTYPE BreakEvent(IRemoteThread *pirth); <br>   HRESULT STDMETHODCALLTYPE ThreadCreateEvent(IRemoteThread *pirth); <br>   HRESULT STDMETHODCALLTYPE ThreadDestroyEvent(IRemoteThread *pirth); <br>   HRESULT STDMETHODCALLTYPE ThreadGroupCreateEvent(IRemoteThread *pirth, IRemoteThreadGroup *pirthg); <br>   HRESULT STDMETHODCALLTYPE ThreadGroupDestroyEvent(IRemoteThread *pirth, IRemoteThreadGroup *pirthg); <br>   HRESULT STDMETHODCALLTYPE ClassLoadEvent(IRemoteThread *pirth, IRemoteClassField *pircfClass); <br>   HRESULT STDMETHODCALLTYPE ClassUnloadEvent(IRemoteThread *pirth, IRemoteClassField *pircfClass); <br>   HRESULT STDMETHODCALLTYPE ProcessDestroyEvent(IRemoteThread *pirth); <br>   HRESULT STDMETHODCALLTYPE TraceEvent(IRemoteThread *pirth); <br>   HRESULT STDMETHODCALLTYPE LoadCompleteEvent(IRemoteThread *pirth); <br> <br>   // IUnknown methods <br> <br>   DEFINE_DELEGATED_REFCOUNT_ADDREF(JavaDebugger); <br>   DEFINE_DELEGATED_REFCOUNT_RELEASE(JavaDebugger); <br>   HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, PVOID *ppvObject); <br>}; <br> <br> <br>/* Module Constants <br> *******************/ <br> <br>#pragma data_seg(DATA_SEG_READ_ONLY) <br> <br>const char SPACE                 = ' '; <br>const char TAB                   = '\t'; <br>const char QUOTE                 = '\''; <br>const char QUOTES                = '"'; <br> <br>const char s_cszMsgBoxTitle[]    = "Sample Java Debugger"; <br> <br>const char s_cszDebugKey[]       = "Software\\Microsoft\\Java VM\\Debug"; <br> <br>const char s_cszDebugClass[]     = "Hello"; <br>const WCHAR s_cwszDebugMethod[]  = L"main"; <br>const ULONG s_ulcBreakpointPC    = 0; <br> <br>#pragma data_seg() <br> <br> <br>/* Macros <br> *********/ <br> <br>// <br>// Compile-time type check cast macro. <br>// <br>#define SAFE_CAST(type, obj) \ <br>   (((type)(obj) == (obj) ? 0 : 0), (type)(obj)) <br> <br>// <br>// Safely delete an object. <br>// <br>#define SAFE_DELETE(ptr) \ <br>   { \ <br>      if (! (ptr)) \ <br>          ; \ <br>      else \ <br>      { \ <br>          delete(ptr); \ <br>          (ptr) = NULL;  \ <br>      } \ <br>   } \ <br> <br> <br>/***************************** Private Functions *****************************/ <br> <br> <br>// <br>// Create a dynamically allocated Unicode copy of an ANSI string. <br>// <br>static HRESULT ANSIToUnicode(LPCSTR pcszANSI, LPWSTR *ppwszUnicode) <br>{ <br>   HRESULT hr = E_UNEXPECTED; <br>   int ncchANSI; <br>   int ncchUnicode; <br> <br>   // (+ 1) for null terminator. <br>   ncchANSI = lstrlen(pcszANSI) + 1; <br> <br>   ncchUnicode = MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, pcszANSI, ncchANSI, NULL, 0); <br> <br>   if (ncchUnicode &gt; 0) <br>   { <br>      *ppwszUnicode = new(WCHAR[ncchUnicode]); <br> <br>      if (*ppwszUnicode) <br>      { <br>         if (MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, pcszANSI, ncchANSI, *ppwszUnicode, ncchUnicode) == ncchUnicode) <br>            hr = S_OK; <br>         else <br>         { <br>            delete(*ppwszUnicode); <br>            *ppwszUnicode = NULL; <br>         } <br>      } <br>      else <br>         hr = E_OUTOFMEMORY; <br>   } <br>   else <br>      *ppwszUnicode = NULL; <br> <br>   return(hr); <br>} <br> <br> <br>// <br>// Skip over the white space at the beginning of a string. <br>// <br>LPCSTR SkipWhiteSpace(LPCSTR pcsz) <br>{ <br>   while (*pcsz == SPACE || <br>          *pcsz == TAB) <br>      pcsz = CharNext(pcsz); <br> <br>   return(pcsz); <br>} <br> <br> <br>// <br>// Skip over the meat at the beginning of a string. <br>// <br>static LPCSTR SkipNonWhiteSpace(LPCSTR pcsz) <br>{ <br>   while (*pcsz &amp;&amp; <br>          *pcsz != SPACE &amp;&amp; <br>          *pcsz != TAB) <br>      pcsz = CharNext(pcsz); <br> <br>   return(pcsz); <br>} <br> <br> <br>// <br>// Skip over a quoted substring at the beginning of a string. <br>// <br>static LPCSTR SkipQuotedArg(LPCSTR pcsz) <br>{ <br>   char chQ; <br> <br>   // Skip over quoted argument past matching quote. <br> <br>   chQ = *pcsz; <br>   pcsz = CharNext(pcsz); <br> <br>   while (*pcsz &amp;&amp; <br>          *pcsz != chQ) <br>      pcsz = CharNext(pcsz); <br> <br>   if (*pcsz == chQ) <br>      pcsz = CharNext(pcsz); <br> <br>   return(pcsz); <br>} <br> <br> <br>// <br>// Skip over a possibly quoted substring at the beginning of a string. <br>// <br>static LPCSTR SkipPossiblyQuotedArg(LPCSTR pcsz) <br>{ <br>   pcsz = SkipWhiteSpace(pcsz); <br> <br>   switch (*pcsz) <br>   { <br>      case QUOTE: <br>      case QUOTES: <br>         pcsz = SkipQuotedArg(pcsz); <br>         break; <br> <br>      default: <br>         pcsz = SkipNonWhiteSpace(pcsz); <br>         break; <br>   } <br> <br>   return(pcsz); <br>} <br> <br> <br>// <br>// Display a printf()-style message box. <br>// <br>static BOOL MyMessageBox(HWND hwndParent, UINT uStyle, LPCSTR pcszFormat, ...) <br>{ <br>   char szMsg[1024]; <br>   va_list valArgs; <br> <br>   // Lamely assume that wvsprintf() won't overflow szMsg[]. <br> <br>   va_start(valArgs, pcszFormat); <br>   wvsprintf(szMsg, pcszFormat, valArgs); <br>   va_end(valArgs); <br> <br>   return(MessageBox(hwndParent, szMsg, s_cszMsgBoxTitle, uStyle)); <br>} <br> <br> <br>// <br>// Create the Java VM Debug key. <br>// <br>static BOOL CreateDebugKey(void) <br>{ <br>    BOOL bResult; <br>    DWORD dwDisposition; <br>    HKEY hkeyDebug; <br> <br>    bResult = (RegCreateKeyEx(HKEY_LOCAL_MACHINE, s_cszDebugKey, 0, NULL, 0, KEY_WRITE, NULL, &amp;hkeyDebug, &amp;dwDisposition) <br>              == ERROR_SUCCESS); <br> <br>    if (bResult) <br>      RegCloseKey(hkeyDebug); <br> <br>   return(bResult); <br>} <br> <br> <br>// <br>// Delete the Java VM Debug key. <br>// <br>static BOOL DeleteDebugKey(void) <br>{ <br>    return(RegDeleteKey(HKEY_LOCAL_MACHINE, s_cszDebugKey) == ERROR_SUCCESS); <br>} <br> <br> <br>/****************************** Public Functions *****************************/ <br> <br> <br>#pragma warning(disable:4100)    // "unreferenced formal parameter" warning <br> <br>int __cdecl main(int argc, char *argv[]) <br>{ <br>   HRESULT hr; <br> <br>   // Initialize OLE on this thread. <br> <br>   hr = CoInitialize(NULL); <br> <br>   if (SUCCEEDED(hr)) <br>   { <br>       IRemoteDebugManager *pirdm; <br> <br>       // Create a RemoteJavaDebugManager from JDbgMgr.exe to initiate debugging. <br> <br>       hr = CoCreateInstance(CLSID_RemoteJavaDebugManager, NULL, <br>                             CLSCTX_LOCAL_SERVER, IID_IRemoteDebugManager, <br>                             (PVOID *)&amp;pirdm); <br> <br>       if (hr == S_OK) <br>       { <br>           JavaDebugger *pjd; <br> <br>           // Create a JavaDebugger object to run a simple debugging session. <br> <br>           pjd = new(JavaDebugger); <br> <br>           if (pjd) <br>           { <br>               hr = pjd-&gt;Initialize(pirdm); <br> <br>               if (hr == S_OK) <br>               { <br>                   hr = pjd-&gt;Debug(s_cszDebugClass); <br> <br>                   pjd-&gt;Terminate(); <br>               } <br> <br>               pjd-&gt;Release(); <br>               pjd = NULL; <br>           } <br>           else <br>               hr = E_OUTOFMEMORY; <br> <br>           pirdm-&gt;Release(); <br>           pirdm = NULL; <br>       } <br> <br>       // Uninitialize OLE on this thread. <br> <br>       CoUninitialize(); <br>   } <br> <br>   return(hr); <br>} <br> <br>#pragma warning(default:4100)    // "unreferenced formal parameter" warning <br> <br> <br>/********************************** Methods **********************************/ <br> <br> <br>JavaDebugger::JavaDebugger(void) <br>{ <br>   m_pirdm = NULL; <br>   m_pirp = NULL; <br>   m_pwszDebugClass = NULL; <br> <br>   return; <br>} <br> <br> <br>JavaDebugger::~JavaDebugger(void) <br>{ <br>   Terminate(); <br> <br>   return; <br>} <br> <br> <br>HRESULT JavaDebugger::Initialize(IRemoteDebugManager *pirdm) <br>{ <br>   HRESULT hr; <br> <br>   // Register this JavaDebugger's callback with the debug manager so it is notified when its debuggee target class is run. <br> <br>   hr = pirdm-&gt;RegisterCallback(this); <br> <br>   if (hr == S_OK) <br>   { <br>      m_pirdm = pirdm; <br>      m_pirdm-&gt;AddRef(); <br>   } <br> <br>   return(hr); <br>} <br> <br> <br>void JavaDebugger::Terminate(void) <br>{ <br>   if (m_pirdm) <br>   { <br>      // Detach this JavaDebugger from the debug manager. <br> <br>      m_pirdm-&gt;Detach(); <br> <br>      m_pirdm-&gt;Release(); <br>      m_pirdm = NULL; <br>   } <br> <br>   SAFE_DELETE(m_pwszDebugClass); <br> <br>   return; <br>} <br> <br> <br>// <br>// Run a message loop on this thread until a WM_QUIT message is encountered. <br>// <br>UINT JavaDebugger::RunMessageLoop(void) <br>{ <br>   MSG msg; <br> <br>   // No accelerators to load. <br> <br>   // Get and dispatch messages until a WM_QUIT message is received. <br> <br>   ZeroMemory(&amp;msg, sizeof(msg)); <br> <br>   while (GetMessage(&amp;msg, NULL, 0, 0)) <br>   { <br>      // Translate virtual key codes. <br> <br>      TranslateMessage(&amp;msg); <br> <br>      // Dispatch message to target window. <br> <br>      DispatchMessage(&amp;msg); <br>   } <br> <br>   return(msg.wParam); <br>} <br> <br> <br>// <br>// Terminate any message loop running on this thread. <br>// <br>void JavaDebugger::QuitMessageLoop(UINT uResult) <br>{ <br>   PostQuitMessage(uResult); <br> <br>   return; <br>} <br> <br> <br>// <br>// Initiate a simple debugging session. <br>// <br>HRESULT JavaDebugger::Debug(LPCSTR pcszDebugClass) <br>{ <br>   HRESULT hr; <br> <br>   // Create the Java VM Debug key to enable Java debugging. <br> <br>   if (CreateDebugKey()) <br>   { <br>      // Remember the debuggee class name. <br> <br>      SAFE_DELETE(m_pwszDebugClass); <br> <br>      hr = ANSIToUnicode(pcszDebugClass, &amp;m_pwszDebugClass); <br> <br>      if (hr == S_OK) <br>      { <br>         LPCSTR pcszCmdLine; <br>         STARTUPINFO si; <br>         PROCESS_INFORMATION pi; <br> <br>         // Treat our command line arguments as the command line to run the debuggee class. <br> <br>         pcszCmdLine = SkipWhiteSpace(SkipPossiblyQuotedArg(GetCommandLine())); <br> <br>         ZeroMemory(&amp;si, sizeof(si)); <br>         si.cb = sizeof(si); <br> <br>         // Start the debuggee class process suspended so we can get its process ID before it executes. <br> <br>         hr = CreateProcess(NULL, (LPSTR)pcszCmdLine, NULL, NULL, FALSE, CREATE_SUSPENDED, NULL, NULL, &amp;si, &amp;pi) ? S_OK : E_FAIL; <br> <br>         if (hr == S_OK) <br>         { <br>            HRESULT hrResume; <br> <br>            // Ask the debug manager to notify us when the debuggee class is run. <br> <br>            hr = m_pirdm-&gt;RequestCreateEvent(m_pwszDebugClass, pi.dwProcessId); <br> <br>            // Resume the debuggee class process to begin debugging. <br> <br>            hrResume = (ResumeThread(pi.hThread) != 0xffffffff) ? S_OK : E_FAIL; <br> <br>            if (hr == S_OK) <br>               hr = hrResume; <br> <br>            CloseHandle(pi.hProcess); <br>            CloseHandle(pi.hThread); <br> <br>            // Run a message loop to dispatch OLE RPC messages. <br> <br>            RunMessageLoop(); <br>         } <br>      } <br> <br>      // Delete the Java VM Debug key, if it hasn't already been deleted, to disable Java debugging. <br> <br>      DeleteDebugKey(); <br>   } <br> <br>   return(hr); <br>} <br> <br> <br>HRESULT STDMETHODCALLTYPE JavaDebugger::QueryInterface(REFIID riid, <br>                                                       PVOID *ppvObject) <br>{ <br>    HRESULT hr = S_OK; <br> <br>    if (riid == IID_IRemoteDebugManagerCallback) <br>       *ppvObject = SAFE_CAST(IRemoteDebugManagerCallback *, this); <br>    else if (riid == IID_IRemoteProcessCallback) <br>       *ppvObject = SAFE_CAST(IRemoteProcessCallback *, this); <br>    else if (riid == IID_IUnknown) <br>       *ppvObject = SAFE_CAST(IUnknown *, (IRemoteDebugManagerCallback *)this); <br>    else <br>    { <br>       *ppvObject = NULL; <br>       hr = E_NOINTERFACE; <br>    } <br> <br>    if (hr == S_OK) <br>        AddRef(); <br> <br>    return(hr); <br>} <br> <br> <br>// <br>// Debugger event notification methods return an HRESULT as follows: <br>// <br>//      S_FALSE     Continue execution. <br>// <br>//      S_OK        Suspend execution of all threads in this VM until an <br>//                  IRemoteThread method is called on this thread to resume <br>//                  execution. <br>// <br>//      E_...       Error. <br>// <br> <br>#pragma warning(disable:4100)    // "unreferenced formal parameter" warning <br> <br>HRESULT STDMETHODCALLTYPE JavaDebugger::ProcessCreateEvent( <br>                                                    IRemoteProcess *pirpNew, <br>                                                    IRemoteProcess *pirpParent) <br>{ <br>   HRESULT hr; <br> <br>   // Register this JavaDebugger's callback with the Java VM so it is notified when interesting events occur in the debuggee. <br> <br>   hr = pirpNew-&gt;RegisterCallback(this); <br> <br>   if (hr == S_OK) <br>   { <br>      m_pirp = pirpNew; <br>      m_pirp-&gt;AddRef(); <br>   } <br> <br>   MyMessageBox(NULL, (MB_OK | MB_ICONINFORMATION | MB_SETFOREGROUND), "Process created."); <br> <br>   // Delete the Java VM Debug key to disable Java debugging. <br> <br>   DeleteDebugKey(); <br> <br>   return(S_FALSE); <br>} <br> <br> <br>HRESULT STDMETHODCALLTYPE JavaDebugger::DebugStringEvent(IRemoteThread *pirth, LPCWSTR pcwszDebugMsg) <br>{ <br>   return(S_FALSE); <br>} <br> <br> <br>HRESULT STDMETHODCALLTYPE JavaDebugger::CodeBreakpointEvent(IRemoteThread *pirth) <br>{ <br>   HRESULT hr; <br>   IRemoteStackFrame *pirsf; <br> <br>   // Get the method object from the current thread's current stack frame. <br> <br>   hr = pirth-&gt;GetCurrentFrame(&amp;pirsf); <br> <br>   if (hr == S_OK) <br>   { <br>      IRemoteContainerObject *pirco; <br> <br>      hr = pirsf-&gt;GetMethodObject(&amp;pirco); <br> <br>      if (hr == S_OK) <br>      { <br>         IRemoteField *pirf; <br> <br>         // Get the method field from the method object. <br> <br>         hr = pirco-&gt;GetType(&amp;pirf); <br> <br>         if (hr == S_OK) <br>         { <br>            IRemoteMethodField *pirmf; <br> <br>            hr = pirf-&gt;QueryInterface(IID_IRemoteMethodField, (PVOID *)&amp;pirmf); <br> <br>            if (hr == S_OK) <br>            { <br>               // Clear the breakpoint, and continue execution. <br> <br>               hr = pirmf-&gt;ClearBreakpoint(s_ulcBreakpointPC); <br> <br>               if (hr == S_OK) <br>                  MyMessageBox(NULL, (MB_OK | MB_ICONINFORMATION | MB_SETFOREGROUND), "Hit breakpoint %ls.%ls().%lu.", <br>                               m_pwszDebugClass, <br>                               s_cwszDebugMethod, <br>                               s_ulcBreakpointPC); <br> <br>               pirmf-&gt;Release(); <br>               pirmf = NULL; <br>            } <br> <br>            pirf-&gt;Release(); <br>            pirf = NULL; <br>         } <br> <br>         pirco-&gt;Release(); <br>         pirco = NULL; <br>      } <br> <br>      pirsf-&gt;Release(); <br>      pirsf = NULL; <br>   } <br> <br>   return(S_FALSE); <br>} <br> <br> <br>HRESULT STDMETHODCALLTYPE JavaDebugger::DataBreakpointEvent(IRemoteThread *pirth, IRemoteObject *piro) <br>{ <br>   return(S_FALSE); <br>} <br> <br> <br>HRESULT STDMETHODCALLTYPE JavaDebugger::ExceptionEvent(IRemoteThread *pirth, IRemoteClassField *pircfException, EXCEPTIONKIND exk) <br>{ <br>   return(S_FALSE); <br>} <br> <br> <br>HRESULT STDMETHODCALLTYPE JavaDebugger::StepEvent(IRemoteThread *pirth) <br>{ <br>   return(S_FALSE); <br>} <br> <br> <br>HRESULT STDMETHODCALLTYPE JavaDebugger::CanStopEvent(IRemoteThread *pirth) <br>{ <br>   return(S_FALSE); <br>} <br> <br> <br>HRESULT STDMETHODCALLTYPE JavaDebugger::BreakEvent(IRemoteThread *pirth) <br>{ <br>   return(S_FALSE); <br>} <br> <br> <br>HRESULT STDMETHODCALLTYPE JavaDebugger::ThreadCreateEvent(IRemoteThread *pirth) <br>{ <br>   return(S_FALSE); <br>} <br> <br> <br>HRESULT STDMETHODCALLTYPE JavaDebugger::ThreadDestroyEvent(IRemoteThread *pirth) <br>{ <br>   return(S_FALSE); <br>} <br> <br> <br>HRESULT STDMETHODCALLTYPE JavaDebugger::ThreadGroupCreateEvent(IRemoteThread *pirth, IRemoteThreadGroup *pirthg) <br>{ <br>   return(S_FALSE); <br>} <br> <br> <br>HRESULT STDMETHODCALLTYPE JavaDebugger::ThreadGroupDestroyEvent(IRemoteThread *pirth, IRemoteThreadGroup *pirthg) <br>{ <br>   return(S_FALSE); <br>} <br> <br> <br>HRESULT STDMETHODCALLTYPE JavaDebugger::ClassLoadEvent(IRemoteThread *pirth, IRemoteClassField *pircfClass) <br>{ <br>   LPWSTR pwszClassName; <br> <br>   // Get the name of the loaded class. <br> <br>   if (pircfClass-&gt;GetName(&amp;pwszClassName) == S_OK) <br>   { <br>      // Is this the class that a breakpoint is to be set in? <br> <br>      if (! wcscmp(pwszClassName, m_pwszDebugClass)) <br>      { <br>         IJavaEnumRemoteField *pijerf; <br> <br>         // Yes.  Get the method field for the method to set a breakpoint in. <br> <br>         if (pircfClass-&gt;GetFields(&amp;pijerf, FIELD_KIND_METHOD, 0, s_cwszDebugMethod) == S_OK) <br>         { <br>            IRemoteField *pirf; <br>            ULONG ulcFetched; <br> <br>            if (pijerf-&gt;Next(1, &amp;pirf, &amp;ulcFetched) == S_OK) <br>            { <br>               IRemoteMethodField *pirmf; <br> <br>               if (pirf-&gt;QueryInterface(IID_IRemoteMethodField, (PVOID *)&amp;pirmf) == S_OK) <br>               { <br>                  // Set the breakpoint, and continue execution. <br> <br>                  pirmf-&gt;SetBreakpoint(s_ulcBreakpointPC); <br> <br>                  pirmf-&gt;Release(); <br>                  pirmf = NULL; <br>               } <br> <br>               pirf-&gt;Release(); <br>               pirf = NULL; <br>            } <br> <br>            pijerf-&gt;Release(); <br>            pijerf = NULL; <br>         } <br>      } <br> <br>      CoTaskMemFree(pwszClassName); <br>      pwszClassName = NULL; <br>   } <br> <br>   return(S_FALSE); <br>} <br> <br> <br>HRESULT STDMETHODCALLTYPE JavaDebugger::ClassUnloadEvent(IRemoteThread *pirth, IRemoteClassField *pircfClass) <br>{ <br>   return(S_FALSE); <br>} <br> <br> <br>HRESULT STDMETHODCALLTYPE JavaDebugger::ProcessDestroyEvent(IRemoteThread *pirth) <br>{ <br>   // Detach this JavaDebugger from the Java VM. <br> <br>   m_pirp-&gt;Detach(); <br> <br>   m_pirp-&gt;Release(); <br>   m_pirp = NULL; <br> <br>   MyMessageBox(NULL, (MB_OK | MB_ICONINFORMATION | MB_SETFOREGROUND), "Process destroyed."); <br> <br>   // Quit the message loop, and end the debugging session. <br> <br>   QuitMessageLoop(0); <br> <br>   return(S_FALSE); <br>} <br> <br> <br>HRESULT STDMETHODCALLTYPE JavaDebugger::TraceEvent(IRemoteThread *pirth) <br>{ <br>   return(S_FALSE); <br>} <br> <br> <br>HRESULT STDMETHODCALLTYPE JavaDebugger::LoadCompleteEvent(IRemoteThread *pirth) <br>{ <br>   return(S_FALSE); <br>} <br> <br>#pragma warning(default:4100)    // "unreferenced formal parameter" warning <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
