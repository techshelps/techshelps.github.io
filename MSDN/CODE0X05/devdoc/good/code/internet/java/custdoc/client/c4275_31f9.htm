<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CUSTSAMPLE.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context4275"></a>CUSTSAMPLE.CPP</h2>
<pre><code>/*++ <br> <br>    Copyright (c) 1996-1997  Microsoft Corporation.  All rights reserved. <br> <br> <br> <br> <br>--*/ <br> <br> <br> <br> <br>#pragma hdrstop <br> <br> <br>#define INITGUID 1 <br> <br>#include &lt;windows.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;olectl.h&gt;          // to get the SELFREF_E_CLASS definition <br> <br> <br>#define MYCHAR CHAR <br>#include "debug\\CustSample.h"  // ICustSample defn (generated from CustSample.odl). <br> <br> <br> <br>//======================================================================= <br>// CCustSample <br>// <br>//   This class implements our COM object which exposes only one interface <br>//   (ICustSample). <br>// <br>//   Strictly speaking, it should also expose IMarshal by aggregating the <br>//   Ole free-threaded marshaler, since this dll marks itself "Both." <br>//   For such a simple sample, however, this will not matter. <br>//======================================================================= <br>class CCustSample : public ICustSample { <br>    private: <br>        ULONG       m_ref;          // Reference count. <br> <br>    public: <br>        CCustSample() { <br>            m_ref = 0; <br>        } <br> <br>        //------------------------------------------------------- <br>        // IUnknown methods. <br>        //------------------------------------------------------- <br>        STDMETHOD(QueryInterface) (REFIID riid, LPVOID *ppv) { <br>            __try { <br>                *ppv = NULL; <br>            } __except (EXCEPTION_EXECUTE_HANDLER) { <br>                return E_POINTER; <br>            } <br> <br>            if (riid == IID_IUnknown || riid == IID_ICustSample) { <br>                AddRef(); <br>                *ppv = (ICustSample*)this; <br>                return S_OK; <br>            } <br>            return E_NOINTERFACE; <br>        } <br> <br>        STDMETHOD_(ULONG, AddRef) () { <br>            InterlockedIncrement( (LONG*)&amp;m_ref ); <br>            return 1; <br>        } <br> <br>        STDMETHOD_(ULONG, Release) () { <br>            LONG ulc; <br> <br>            ulc = InterlockedDecrement( (LONG*)&amp;m_ref ); <br>            if (ulc &lt; 0) { <br>                OutputDebugString("Too many releases on CCustSample object!\n"); <br>                DebugBreak(); <br>            } <br>            if (0 == ulc) { <br>                OutputDebugString("CCustSample: Destroy\n"); <br>                delete this; <br>                return 0; <br>            } <br>            return 1; <br>        } <br> <br> <br>        //------------------------------------------------------- <br>        // ICustSample methods. <br>        //------------------------------------------------------- <br>        STDMETHOD(PassFixedPtIn)(FIXED fp) <br>        { <br>            printf("C PassFixedPtIn called: (%ld, %lu)\n", <br>                   (LONG)(fp.value), <br>                   (ULONG)(fp.fract)); <br>            return S_OK; <br>        } <br> <br>        STDMETHOD(PassPFixedPtOutRetVal)(FIXED *pfp) <br>        { <br>            printf("C PassPFixedPtOutRetVal called. Returning 7.25\n"); <br>            pfp-&gt;value = 7; <br>            pfp-&gt;fract = 16384; <br>            return S_OK; <br>        } <br> <br>        STDMETHOD(PassPFixedPtIn)(FIXED *pfp) <br>        { <br>            printf("C PassPFixedPtIn called: (%ld, %lu)\n", <br>                   (LONG)(pfp-&gt;value), <br>                   (ULONG)(pfp-&gt;fract)); <br>            return S_OK; <br>        } <br> <br>        STDMETHOD(PassPFixedPtOut)(FIXED *pfp) <br>        { <br>            printf("C PassPFixedPtOut called. Returning 3.25\n"); <br>            pfp-&gt;value = 3; <br>            pfp-&gt;fract = 16384; <br>            return S_OK; <br>        } <br> <br>        STDMETHOD(PassPFixedPtInOut)(FIXED *pfp) <br>        { <br>            printf("C PassPFixedPtInOut called. Incrementing value by 2.\n"); <br>            pfp-&gt;value += 2; <br>            return S_OK; <br>        } <br> <br>        STDMETHOD(PassFixedPtsFromComToJava)(ICustSample *obj) <br>        { <br> <br>            // This method demonstrates invoking Java methods from COM. <br>            // It accepts an ICustSample interface pointer (whose implementation <br>            // will be in Java, though this method is naturally oblivious <br>            // to that), and invokes every single method on it. <br> <br>            HRESULT hr; <br> <br>            { <br>                FIXED f = {32768, 4}; <br>                hr = obj-&gt;PassFixedPtIn(f); <br>                if (S_OK != hr) { <br>                    return hr; <br>                } <br>            } <br> <br>            { <br>                FIXED f = {0, 0}; <br>                hr = obj-&gt;PassPFixedPtOutRetVal(&amp;f); <br>                if (S_OK != hr) { <br>                    return hr; <br>                } <br>                printf("(%ld, %lu)\n", (LONG)(f.value), (ULONG)(f.fract)); <br>            } <br>            { <br>                FIXED f = {32768, 8}; <br>                hr = obj-&gt;PassPFixedPtIn(&amp;f); <br>                if (S_OK != hr) { <br>                    return hr; <br>                } <br>            } <br>            { <br>                FIXED f = {0, 0}; <br>                hr = obj-&gt;PassPFixedPtOut(&amp;f); <br>                if (S_OK != hr) { <br>                    return hr; <br>                } <br>                printf("(%ld, %lu)\n", (LONG)(f.value), (ULONG)(f.fract)); <br>            } <br> <br>            { <br>                FIXED f = {16384, 8}; <br>                hr = obj-&gt;PassPFixedPtInOut(&amp;f); <br>                if (S_OK != hr) { <br>                    return hr; <br>                } <br>                printf("(%ld, %lu)\n", (LONG)(f.value), (ULONG)(f.fract)); <br>            } <br> <br> <br>            return S_OK; <br> <br> <br>        } <br> <br> <br> <br> <br>        STDMETHOD(PassMyVariantIn)(MYVARIANT v) <br>        { <br>            printf("C PassMyVariantIn called: "); <br>            PrintBSTR(v.bstrVal); <br>            printf("\n"); <br>            return S_OK; <br>        } <br> <br>        STDMETHOD(PassPMyVariantOutRetVal)(MYVARIANT* pv) <br>        { <br>            printf("C PassPMyVariantOutRetVal called.\n"); <br>            pv-&gt;vt = VT_BSTR; <br>            pv-&gt;bstrVal = NewBSTR(L"If you can read this, PassPMyVariantOutRetVal works."); <br>            return S_OK; <br>        } <br> <br>        STDMETHOD(PassPMyVariantIn)(MYVARIANT *pv) <br>        { <br>            printf("C PassPMyVariantIn called: "); <br>            PrintBSTR(pv-&gt;bstrVal); <br>            printf("\n"); <br>            return S_OK; <br>        } <br> <br>        STDMETHOD(PassPMyVariantOut)(MYVARIANT* pv) <br>        { <br>            printf("C PassPMyVariantOut called.\n"); <br>            pv-&gt;vt = VT_BSTR; <br>            pv-&gt;bstrVal = NewBSTR(L"If you can read this, PassPMyVariantOut works."); <br>            return S_OK; <br>        } <br> <br>        STDMETHOD(PassPMyVariantInOut)(MYVARIANT* pv) <br>        { <br>            printf("C PassPMyVariantInOut called: "); <br>            PrintBSTR(pv-&gt;bstrVal); <br>            printf("\n"); <br> <br>            FreeBSTR(pv-&gt;bstrVal); <br>         <br>            pv-&gt;vt = VT_BSTR; <br>            pv-&gt;bstrVal = NewBSTR(L"If you can read this, the 'out' part of PassPMyVariantInOut works."); <br>            return S_OK; <br>        } <br> <br>        STDMETHOD(PassMyVariantFromComToJava)(ICustSample *obj) <br>        { <br> <br>            // This method demonstrates invoking Java methods from COM. <br>            // It accepts an ICustSample interface pointer (whose implementation <br>            // will be in Java, though this method is naturally oblivious <br>            // to that), and invokes every single method on it. <br> <br>            HRESULT hr; <br>            { <br>                MYVARIANT mv; <br>                mv.vt = VT_BSTR; <br>                mv.bstrVal = NewBSTR(L"If you can read this, PassMyVariantIn worked."); <br>                hr = obj-&gt;PassMyVariantIn(mv); <br>                if (S_OK != hr) { <br>                    return hr; <br>                } <br>                FreeBSTR(mv.bstrVal); <br>            } <br> <br>            { <br>                MYVARIANT mv; <br>                FillMemory(&amp;mv, sizeof(mv), 0xcc); <br> <br>                hr = obj-&gt;PassPMyVariantOutRetVal(&amp;mv); <br>                if (S_OK != hr) { <br>                    return hr; <br>                } <br>                PrintBSTR(mv.bstrVal); <br>                printf("\n"); <br>                FreeBSTR(mv.bstrVal); <br>            } <br> <br>            { <br>                MYVARIANT mv; <br>                mv.vt = VT_BSTR; <br>                mv.bstrVal = NewBSTR(L"If you can read this, PPassMyVariantIn worked."); <br>                hr = obj-&gt;PassPMyVariantIn(&amp;mv); <br>                if (S_OK != hr) { <br>                    return hr; <br>                } <br>                FreeBSTR(mv.bstrVal); <br>            } <br> <br>            { <br>                MYVARIANT mv; <br>                FillMemory(&amp;mv, sizeof(mv), 0xcc); <br> <br>                hr = obj-&gt;PassPMyVariantOut(&amp;mv); <br>                if (S_OK != hr) { <br>                    return hr; <br>                } <br>                PrintBSTR(mv.bstrVal); <br>                printf("\n"); <br>                FreeBSTR(mv.bstrVal); <br>            } <br>            { <br>                MYVARIANT mv; <br>                mv.vt = VT_BSTR; <br>                mv.bstrVal = NewBSTR(L"If you can read this, the 'in' part of PPassMyVariantInOut worked."); <br> <br>                hr = obj-&gt;PassPMyVariantInOut(&amp;mv); <br>                if (S_OK != hr) { <br>                    return hr; <br>                } <br>                PrintBSTR(mv.bstrVal); <br>                printf("\n"); <br>                FreeBSTR(mv.bstrVal); <br>            } <br> <br>            return S_OK; <br>        } <br> <br> <br>        STDMETHOD(PassPPointOut)(POINT* ppt) <br>        { <br>            printf("C PassPPointOut called. Returning [5,6]\n"); <br>            ppt-&gt;x = 5; <br>            ppt-&gt;y = 6; <br>            return S_OK; <br>        } <br> <br>        STDMETHOD(PassPPointInOut)(POINT* ppt) <br>        { <br>            printf("C PassPPointInOut called. Received [%ld,%ld]. Translating x &amp; y by 3.\n", ppt-&gt;x, ppt-&gt;y); <br>            ppt-&gt;x += 3; <br>            ppt-&gt;y += 3; <br>            return S_OK; <br>        } <br> <br>        STDMETHOD(PassPointFromComToJava)(ICustSample *obj) <br>        { <br> <br>            // This method demonstrates invoking Java methods from COM. <br>            // It accepts an ICustSample interface pointer (whose implementation <br>            // will be in Java, though this method is naturally oblivious <br>            // to that), and invokes every single method on it. <br> <br>            HRESULT hr; <br>            { <br>                POINT p = {-1,-1}; <br>                hr = obj-&gt;PassPPointOut(&amp;p); <br>                if (hr != S_OK) { <br>                    return hr; <br>                } <br>                printf("[%ld,%ld]\n", p.x, p.y); <br>            } <br> <br>            { <br>                POINT p = {10,11}; <br>                hr = obj-&gt;PassPPointInOut(&amp;p); <br>                if (hr != S_OK) { <br>                    return hr; <br>                } <br>                printf("[%ld,%ld]\n", p.x, p.y); <br>            } <br>            return S_OK; <br>        } <br> <br>        STDMETHOD(PassRectIn)(RECT r) <br>        { <br>            printf("C PassRectIn called: "); <br>            PrintRect(r); <br>            printf("\n"); <br>            return S_OK; <br>        } <br> <br>        STDMETHOD(PassPRectOutRetVal)(RECT *pr) <br>        { <br>            RECT r = {4,5,10,11}; <br>            printf("C PassPRectOutRetVal called. Returning "); <br>            PrintRect(r); <br>            printf("\n"); <br>            *pr = r; <br>            return S_OK; <br>        } <br> <br>        STDMETHOD(PassPRectIn)(RECT *pr) <br>        { <br>            printf("C PassPRectIn called: "); <br>            PrintRect(*pr); <br>            printf("\n"); <br>            return S_OK; <br>        } <br> <br>        STDMETHOD(PassPRectOut)(RECT *pr) <br>        { <br>            RECT r = {7,8,20,31}; <br>            printf("C PassPRectOutRetVal called. Returning "); <br>            PrintRect(r); <br>            printf("\n"); <br>            *pr = r; <br>            return S_OK; <br>        } <br> <br>        STDMETHOD(PassPRectInOut)(RECT *pr) <br>        { <br>            printf("C PassPRectInOut called. Moving rectangle by (2,2)\n"); <br>            pr-&gt;left   += 2; <br>            pr-&gt;top    += 2; <br>            pr-&gt;right  += 2; <br>            pr-&gt;bottom += 2; <br> <br>            return S_OK; <br>        } <br> <br> <br>        STDMETHOD(PassPPRectOutRetVal)(RECT **ppr) <br>        { <br> <br>            *ppr = NewRect(6,7,8,9); <br>            printf("C PassPPRectOutRetVal called. Returning "); <br>            PrintRect(**ppr); <br>            printf("\n"); <br>            return S_OK; <br>        } <br> <br>        STDMETHOD(PassPPRectIn)(RECT **ppr) <br>        { <br>            printf("C PassPPRectIn called: "); <br>            PrintRect(**ppr); <br>            printf("\n"); <br>            return S_OK; <br>        } <br> <br>        STDMETHOD(PassPPRectOut)(RECT **ppr) <br>        { <br> <br>            *ppr = NewRect(13,14,15,16); <br>            printf("C PassPPRectOutcalled. Returning "); <br>            PrintRect(**ppr); <br>            printf("\n"); <br>            return S_OK; <br>        } <br> <br>        STDMETHOD(PassPPRectInOut)(RECT **ppr) <br>        { <br> <br>            printf("C PassPPRectInOut called: "); <br>            PrintRect(**ppr); <br>            printf("\n"); <br> <br>            FreeRect(*ppr); <br> <br>            *ppr = NewRect(1,2,3,4); <br>            printf("C PassPPRectInOut called. Returning "); <br>            PrintRect(**ppr); <br>            printf("\n"); <br>            return S_OK; <br>        } <br> <br>        STDMETHOD(PassRectFromComToJava)(ICustSample *obj) <br>        { <br> <br>            // This method demonstrates invoking Java methods from COM. <br>            // It accepts an ICustSample interface pointer (whose implementation <br>            // will be in Java, though this method is naturally oblivious <br>            // to that), and invokes every single method on it. <br> <br>            HRESULT hr; <br>            { <br>                RECT r = {4,5,6,7}; <br>                PrintRect(r);printf("\n"); <br>                hr = obj-&gt;PassRectIn(r); <br>                if (S_OK != hr) { <br>                    return hr; <br>                } <br>            } <br>            { <br>                RECT r = {-1,-1,-1,-1}; <br>                hr = obj-&gt;PassPRectOutRetVal(&amp;r); <br>                if (S_OK != hr) { <br>                    return hr; <br>                } <br>                PrintRect(r);printf("\n"); <br>            } <br>            { <br>                RECT r = {14,15,16,17}; <br>                PrintRect(r);printf("\n"); <br>                hr = obj-&gt;PassPRectIn(&amp;r); <br>                if (S_OK != hr) { <br>                    return hr; <br>                } <br>            } <br>            { <br>                RECT r = {-1,-1,-1,-1}; <br>                hr = obj-&gt;PassPRectOut(&amp;r); <br>                if (S_OK != hr) { <br>                    return hr; <br>                } <br>                PrintRect(r);printf("\n"); <br>            } <br>            { <br>                RECT r = {24,25,26,27}; <br>                hr = obj-&gt;PassPRectInOut(&amp;r); <br>                if (S_OK != hr) { <br>                    return hr; <br>                } <br>                PrintRect(r);printf("\n"); <br>            } <br>            { <br>                RECT *pr = NULL; <br>                hr = obj-&gt;PassPPRectOutRetVal(&amp;pr); <br>                if (S_OK != hr) { <br>                    return hr; <br>                } <br>                PrintRect(*pr);printf("\n"); <br>                FreeRect(pr); <br>            } <br>            { <br>                RECT r = {44,45,46,47}; <br>                PRECT pr = &amp;r; <br>                hr = obj-&gt;PassPPRectIn(&amp;pr); <br>                if (S_OK != hr) { <br>                    return hr; <br>                } <br>            } <br> <br>            { <br>                RECT *pr = NULL; <br>                hr = obj-&gt;PassPPRectOut(&amp;pr); <br>                if (S_OK != hr) { <br>                    return hr; <br>                } <br>                PrintRect(*pr);printf("\n"); <br>                FreeRect(pr); <br>            } <br>            { <br>                RECT *pr = NewRect(55,56,57,58); <br>                hr = obj-&gt;PassPPRectInOut(&amp;pr); <br>                if (S_OK != hr) { <br>                    return hr; <br>                } <br>                PrintRect(*pr);printf("\n"); <br>                FreeRect(pr); <br>            } <br>            return S_OK; <br>        } <br> <br> <br>        STDMETHOD(PassPStrIn)(LPSTR pstr) <br>        { <br>            printf("C PassPStrIn called: '%s'\n", pstr); <br>            return S_OK; <br>        } <br> <br> <br> <br>        STDMETHOD(PassPPStrOutRetVal)(LPSTR *ppstr) <br>        { <br>            *ppstr = NewStr("If you can read this, C PassPPStrOutRetVal works."); <br>            return S_OK; <br>        } <br> <br>        STDMETHOD(PassPPStrIn)(LPSTR *ppstr) <br>        { <br>            printf("C PassPPStrIn called: '%s'\n", *ppstr); <br>            return S_OK; <br>        } <br> <br>        STDMETHOD(PassPPStrOut)(LPSTR *ppstr) <br>        { <br>            *ppstr = NewStr("If you can read this, C PassPPStrOut works."); <br>            return S_OK; <br>        } <br> <br>        STDMETHOD(PassPPStrInOut)(LPSTR *ppstr) <br>        { <br>            printf("C PassPPStrInOut called: '%s'\n", *ppstr); <br>            FreeStr(*ppstr); <br>            *ppstr = NewStr("If you can read this, 'out' part of C PassPPStrInOut works."); <br>            return S_OK; <br>        } <br> <br> <br>        STDMETHOD(PassAnsiFromComToJava)(ICustSample *obj) <br>        { <br> <br>            // This method demonstrates invoking Java methods from COM. <br>            // It accepts an ICustSample interface pointer (whose implementation <br>            // will be in Java, though this method is naturally oblivious <br>            // to that), and invokes every single method on it. <br> <br>            HRESULT hr; <br>            { <br>                hr = obj-&gt;PassPStrIn("If you can read this, Java PassPStrIn works."); <br>                if (S_OK != hr) { <br>                    return hr; <br>                } <br>            } <br>            { <br>                LPSTR pstr = (LPSTR)0xcccccccc; <br>                hr = obj-&gt;PassPPStrOutRetVal(&amp;pstr); <br>                if (S_OK != hr) { <br>                    return hr; <br>                } <br>                printf("%s\n", pstr); <br>                FreeStr(pstr); <br>            } <br>            { <br>                LPSTR pstr = "If you can read this, Java PassPPStrIn works."; <br>                hr = obj-&gt;PassPPStrIn(&amp;pstr); <br>                if (S_OK != hr) { <br>                    return hr; <br>                } <br>            } <br>            { <br>                LPSTR pstr = (LPSTR)0xcccccccc; <br>                hr = obj-&gt;PassPPStrOut(&amp;pstr); <br>                if (S_OK != hr) { <br>                    return hr; <br>                } <br>                printf("%s\n", pstr); <br>                FreeStr(pstr); <br>            } <br>            { <br>                LPSTR pstr = NewStr("If you can read this, 'in' part of Java PassPPStrInOut works."); <br>                hr = obj-&gt;PassPPStrInOut(&amp;pstr); <br>                if (S_OK != hr) { <br>                    return hr; <br>                } <br>                printf("%s\n", pstr); <br>                FreeStr(pstr); <br>            } <br> <br>            return S_OK; <br>        } <br> <br>    private: <br> <br>        //------------------------------------------------------------ <br>        // Some simple utilities. <br>        //------------------------------------------------------------ <br>        BSTR NewBSTR(LPCWSTR sz) <br>        { <br>            BSTR bstr = SysAllocString(sz); <br>            if (!bstr) { <br>                printf("Out of BSTR heap space.\n"); <br>                exit(1); <br>            } <br> <br>            CHAR msg[100]; <br>            wsprintf(msg, "Server allocated BSTR at %lxh\n", bstr); <br>            OutputDebugString(msg); <br>            return bstr; <br>        } <br> <br>        VOID FreeBSTR(BSTR bstr) <br>        { <br>            CHAR msg[100]; <br>            wsprintf(msg, "Server freeing BSTR at %lxh\n", bstr); <br>            OutputDebugString(msg); <br> <br>            SysFreeString(bstr); <br>        } <br> <br>        VOID PrintBSTR(BSTR bstr) <br>        { <br>            DWORD len = SysStringLen(bstr); <br>            DWORD i; <br>            putchar('"'); <br>            for (i = 0; i &lt; len; i++) { <br>                putchar((CHAR)(bstr[i])); <br>            } <br>            putchar('"'); <br>        } <br> <br> <br>        VOID PrintRect(RECT r) <br>        { <br>            printf("[x=%ld,y=%ld,width=%ld,height=%ld]", <br>                   r.left, <br>                   r.top, <br>                   r.right - r.left, <br>                   r.bottom - r.top); <br>        } <br> <br>        RECT *NewRect(long x, long y, long width, long height) <br>        { <br>            RECT* pr = (RECT*)CoTaskMemAlloc(sizeof(RECT)); <br>            if (!pr) { <br>                printf("Out of task heap space.\n"); <br>                exit(1); <br>            } <br> <br>            pr-&gt;left    = x; <br>            pr-&gt;top     = y; <br>            pr-&gt;right   = x + width; <br>            pr-&gt;bottom  = y + height; <br> <br>            CHAR msg[100]; <br>            wsprintf(msg, "Server allocated RECT at %lxh\n", pr); <br>            OutputDebugString(msg); <br> <br> <br>            return pr; <br>        } <br> <br>        VOID FreeRect(RECT *pr) <br>        { <br>            CHAR msg[100]; <br>            wsprintf(msg, "Server freeing RECT at %lxh\n", pr); <br>            OutputDebugString(msg); <br> <br>            CoTaskMemFree(pr); <br>        } <br> <br>        LPSTR NewStr(LPCSTR sz) <br>        { <br>            LPSTR pstr = (LPSTR)CoTaskMemAlloc(lstrlen(sz)); <br>            if (!pstr) { <br>                printf("Out of heap space.\n"); <br>                exit(1); <br>            } <br> <br>            lstrcpy(pstr, sz); <br> <br>            CHAR msg[100]; <br>            wsprintf(msg, "Server allocated Str at %lxh\n", pstr); <br>            OutputDebugString(msg); <br>            return pstr; <br>        } <br> <br>        VOID FreeStr(LPSTR pstr) <br>        { <br>            CHAR msg[100]; <br>            wsprintf(msg, "Server freeing Str at %lxh\n", pstr); <br>            OutputDebugString(msg); <br> <br>            CoTaskMemFree(pstr); <br>        } <br> <br>}; <br> <br> <br>//======================================================================= <br>// J2CClassFactory <br>// <br>//   This class implements the classfactory for our COM server. Since our <br>//   classfactory has no intrinsic state, we use a static class factory <br>//   to simplify our implementation. <br>//    <br>//======================================================================= <br>class J2CClassFactory : public IClassFactory <br>{ <br>    public: <br> <br>        //----------------------------------------------------------- <br>        // IUnknown methods. <br>        //----------------------------------------------------------- <br>        STDMETHOD(QueryInterface) (REFIID riid, LPVOID *ppv) <br>        { <br>            __try { <br>                *ppv = NULL; <br>            } __except (EXCEPTION_EXECUTE_HANDLER) { <br>                return E_POINTER; <br>            } <br> <br>            if (riid == IID_IUnknown || riid == IID_IClassFactory) { <br>                AddRef(); <br>                *ppv = (IClassFactory*)this; <br>                return S_OK; <br>            } <br>            return E_NOINTERFACE; <br>        } <br> <br>        STDMETHOD_(ULONG, AddRef) () { <br>            return 1; <br>        } <br> <br>        STDMETHOD_(ULONG, Release) () { <br>            return 1; <br>        } <br> <br>        //----------------------------------------------------------- <br>        // IClassFactory methods. <br>        //----------------------------------------------------------- <br>        STDMETHOD(CreateInstance)(IUnknown *punkOuter, REFIID riid, LPVOID *ppv) <br>        { <br>            *ppv = NULL; <br> <br>            if (punkOuter != NULL) { <br>                return CLASS_E_NOAGGREGATION; <br>            } <br> <br>            CCustSample *pJ2CThing; <br>            HRESULT hr; <br> <br>            pJ2CThing = new CCustSample(); <br>            if (!pJ2CThing) { <br>                return E_OUTOFMEMORY; <br>            } <br>         <br>            pJ2CThing-&gt;AddRef(); <br>            hr = pJ2CThing-&gt;QueryInterface(riid, ppv); <br>            pJ2CThing-&gt;Release(); <br>            return hr; <br>        } <br> <br>        STDMETHOD(LockServer)(BOOL fLock) { <br>            return S_OK; <br>            } <br> <br>}; <br> <br> <br>//=================================================================== <br>// Create our first (and only) classfactory. <br>//=================================================================== <br>J2CClassFactory g_CF; <br> <br> <br>// Rememeber our dll's module handle. <br>HINSTANCE ghInstance; <br> <br> <br> <br> <br>//=================================================================== <br>// Standard DLL entry point (called by Win32 loader.) <br>//=================================================================== <br>BOOL WINAPI DllMain(HINSTANCE hmod, DWORD dwReason, <br>                                PVOID pvReserved) <br>{ <br>   ghInstance = hmod; <br> <br>   if (dwReason == DLL_PROCESS_ATTACH) { <br>        OutputDebugString("CustSample.dll has successfully loaded.\n"); <br>   } <br> <br>   return TRUE; <br>} <br> <br> <br> <br> <br> <br> <br>//=================================================================== <br>// Standard Ole export ("creates" a classfactory.) <br>//=================================================================== <br>STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID *ppv) <br>{ <br> <br>    HRESULT hr; <br> <br>    __try { <br>        *ppv = NULL; <br>    } __except (EXCEPTION_EXECUTE_HANDLER) { <br>        return E_POINTER; <br>    } <br> <br>    if (rclsid != CLSID_CCustSample) { <br>        return CLASS_E_CLASSNOTAVAILABLE; <br>    } <br> <br>    return g_CF.QueryInterface(riid, ppv); <br> <br> <br>} <br> <br> <br> <br> <br>//=================================================================== <br>// Simple GUID unparsing utility (for self-registering code). <br>//=================================================================== <br> <br> <br>#define GUIDSTR_MAX (1+ 8 + 1 + 4 + 1 + 4 + 1 + 4 + 1 + 12 + 1 + 1) <br> <br>static const CHAR szDigits[] = "0123456789ABCDEF"; <br>static const BYTE GuidMap[] = { 3, 2, 1, 0, '-', 5, 4, '-', 7, 6, '-', <br>                                8, 9, '-', 10, 11, 12, 13, 14, 15 }; <br> <br> <br>//-------------------------------------------------------------------------- <br>// <br>//  Function:   GUID2StringA <br>// <br>//  Synopsis:   Convert GUID to string form <br>// <br>//  Arguments:  [rguid] - the guid to convert <br>//              [lpszy] - buffer to hold the results <br>// <br>//  Returns:    nothing <br>// <br>//  This code is massively plagiarized from the Ole sources. <br>//-------------------------------------------------------------------------- <br> <br>VOID <br>GUID2StringA(REFGUID rguid, LPSTR lpsz) <br>{ <br>    int i; <br>    LPSTR p = lpsz; <br> <br>    const BYTE * pBytes = (const BYTE *) &amp;rguid; <br> <br>    *p++ = '{'; <br> <br>    for (i = 0; i &lt; sizeof(GuidMap); i++) <br>    { <br>        if (GuidMap[i] == '-') <br>        { <br>            *p++ = '-'; <br>        } <br>        else <br>        { <br>            *p++ = szDigits[ (pBytes[GuidMap[i]] &amp; 0xF0) &gt;&gt; 4 ]; <br>            *p++ = szDigits[ (pBytes[GuidMap[i]] &amp; 0x0F) ]; <br>        } <br>    } <br>    *p++ = '}'; <br>    *p   = '\0'; <br>} <br> <br> <br> <br>const char achTM[] = "Both"; <br>const char achDESC[] = "Sample Custom Marshaling Server."; <br>const char achPROGID[] = "CCustSample"; <br> <br> <br>//=================================================================== <br>// Standard Ole export (for self-registration a la regsvr32.) <br>//=================================================================== <br>__declspec(dllexport) <br>STDAPI <br>DllRegisterServer(VOID) <br>{ <br>   HKEY    hKey  = NULL; <br>   HKEY    hKey2 = NULL; <br>   HKEY    hKey3 = NULL; <br>   DWORD   result; <br>   HRESULT hr = SELFREG_E_CLASS; <br>   CHAR    achCLSID[GUIDSTR_MAX]; <br>   TCHAR   achModulePathName[MAX_PATH]; <br> <br>   // If we fail in the middle, the state of the registry entries <br>   // is indeterminate (as per Ole specs.) <br> <br> <br>   // Create HKEY_CLASSES_ROOT\progid\CLSID <br>   result = RegCreateKey(HKEY_CLASSES_ROOT, achPROGID, &amp;hKey); <br>   if (result != ERROR_SUCCESS) { <br>      goto lExit; <br>   } <br>   result = RegSetValue(hKey, NULL, REG_SZ, achDESC, lstrlen(achDESC)); <br>   if (result != ERROR_SUCCESS) { <br>      goto lExit; <br>   } <br>   result = RegCreateKey(hKey, TEXT("CLSID"), &amp;hKey2); <br>   if (result != ERROR_SUCCESS) { <br>      goto lExit; <br>   } <br>   GUID2StringA(CLSID_CCustSample, achCLSID); <br>   result = RegSetValue(hKey2, NULL, REG_SZ, achCLSID, GUIDSTR_MAX-1); <br>   if (result != ERROR_SUCCESS) { <br>      goto lExit; <br>   } <br> <br>   RegCloseKey(hKey); <br>   RegCloseKey(hKey2); <br>   hKey = NULL; <br>   hKey2 = NULL; <br> <br> <br>   // Create HKEY_CLASSES_ROOT\CLSID\... <br>   result = RegCreateKey(HKEY_CLASSES_ROOT, TEXT("CLSID"), &amp;hKey); <br>   if (result != ERROR_SUCCESS) { <br>      goto lExit; <br>   } <br> <br>   result = RegCreateKey(hKey, achCLSID, &amp;hKey2); <br>   if (result != ERROR_SUCCESS) { <br>      goto lExit; <br>   } <br> <br>   result = RegSetValue(hKey2, NULL, REG_SZ, achDESC, lstrlen(achDESC)); <br>   if (result != ERROR_SUCCESS) { <br>      goto lExit; <br>   } <br> <br>   result = RegCreateKey(hKey2, "InprocServer32", &amp;hKey3); <br>   if (result != ERROR_SUCCESS) { <br>      goto lExit; <br>   } <br> <br>   result = GetModuleFileName(ghInstance, achModulePathName, sizeof(achModulePathName)/sizeof(TCHAR)); <br>   if (result == 0) {  //No way to detect truncation from GetModuleFileName.  <br>      goto lExit; <br>   } <br> <br>   result = RegSetValue(hKey3, NULL, REG_SZ, achModulePathName, lstrlen(achModulePathName)); <br>   if (result != ERROR_SUCCESS) { <br>      goto lExit; <br>   } <br> <br>   result = RegSetValueEx(hKey3, "ThreadingModel", 0, REG_SZ, (BYTE*)achTM, sizeof(achTM)); <br>   if (result != ERROR_SUCCESS) { <br>      goto lExit; <br>   } <br> <br>   RegCloseKey(hKey3); <br>   hKey3 = NULL; <br> <br> <br>   result = RegCreateKey(hKey2, "ProgID", &amp;hKey3); <br>   if (result != ERROR_SUCCESS) { <br>      goto lExit; <br>   } <br>   result = RegSetValue(hKey3, NULL, REG_SZ, achPROGID, lstrlen(achPROGID)); </code></pre>
<p>
</p>
<pre><code>if (result != ERROR_SUCCESS) { <br>      goto lExit; <br>   } <br>   RegCloseKey(hKey3); <br>   hKey3 = NULL; <br> <br> <br> <br>   hr = S_OK; <br> <br> lExit: <br>   if (hKey) { <br>      RegCloseKey(hKey); <br>   } <br>   if (hKey2) { <br>      RegCloseKey(hKey2); <br>   } <br>   if (hKey3) { <br>      RegCloseKey(hKey3); <br>   } <br>   return hr; <br> <br>} <br> <br> <br> <br>//=================================================================== <br>// Standard Ole export (for self-unregistration a la regsvr32.) <br>//=================================================================== <br>__declspec(dllexport) <br>STDAPI <br>DllUnregisterServer(VOID) <br>{ <br>    return S_OK; <br>} <br> <br> <br> <br> <br> <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
