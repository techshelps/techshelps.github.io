<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>PLOTTER.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context4281"></a>PLOTTER.CPP</h2>
<pre><code>/*++ <br> <br>Copyright (c) 1996-1997  Microsoft Corporation.  All rights reserved. <br> <br> <br>--*/ <br> <br> <br>#pragma hdrstop <br> <br> <br>#define INITGUID 1 <br> <br>#include &lt;windows.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;olectl.h&gt;          // to get the SELFREF_E_CLASS definition <br> <br> <br>#include "debug\\Plotter.h"  // IPlotter defn (generated from Plotter.odl). <br> <br> <br> <br>//======================================================================= <br>// CPlotter <br>// <br>//   This class implements our COM object which exposes only one interface <br>//   (IPlotter). <br>// <br>//   Strictly speaking, it should also expose IMarshal by aggregating the <br>//   Ole free-threaded marshaler, since this dll marks itself "Both." <br>//   For such a simple sample, however, this will not matter. <br>//======================================================================= <br> <br>class CPlotter : public IPlotter { <br>    private: <br>        ULONG       m_ref;          // Reference count. <br> <br>    public: <br>        CPlotter() { <br>            m_ref = 0; <br>        } <br> <br>        //------------------------------------------------------- <br>        // IUnknown methods. <br>        //------------------------------------------------------- <br>        STDMETHOD(QueryInterface) (REFIID riid, LPVOID *ppv) { <br>            __try { <br>                *ppv = NULL; <br>            } __except (EXCEPTION_EXECUTE_HANDLER) { <br>                return E_POINTER; <br>            } <br> <br>            if (riid == IID_IUnknown || riid == IID_IPlotter) { <br>                AddRef(); <br>                *ppv = (IPlotter*)this; <br>                return S_OK; <br>            } <br>            return E_NOINTERFACE; <br>        } <br> <br>        STDMETHOD_(ULONG, AddRef) () { <br>            InterlockedIncrement( (LONG*)&amp;m_ref ); <br>            return 1; <br>        } <br> <br>        STDMETHOD_(ULONG, Release) () { <br>            LONG ulc; <br> <br>            ulc = InterlockedDecrement( (LONG*)&amp;m_ref ); <br>            if (ulc &lt; 0) { <br>                OutputDebugString("Too many releases on CPlotter object!\n"); <br>                DebugBreak(); <br>            } <br>            if (0 == ulc) { <br>                OutputDebugString("CPlotter: Destroy\n"); <br>                delete this; <br>                return 0; <br>            } <br>            return 1; <br>        } <br> <br> <br>        //------------------------------------------------------- <br>        // IPlotter methods. <br>        //------------------------------------------------------- <br>        STDMETHOD(DrawLine)(POINT *start, POINT *end) <br>        { <br>            printf("DrawLine called: start = (%ld,%ld), end = (%ld,%ld)\n", <br>                   start-&gt;x, <br>                   start-&gt;y, <br>                   end-&gt;x, <br>                   end-&gt;y); <br>            return S_OK; <br>        } <br> <br>}; <br> <br> <br>//======================================================================= <br>// J2CClassFactory <br>// <br>//   This class implements the classfactory for our COM server. Since our <br>//   classfactory has no intrinsic state, we use a static class factory <br>//   to simplify our implementation. <br>//    <br>//======================================================================= <br>class J2CClassFactory : public IClassFactory <br>{ <br>    public: <br> <br>        //----------------------------------------------------------- <br>        // IUnknown methods. <br>        //----------------------------------------------------------- <br>        STDMETHOD(QueryInterface) (REFIID riid, LPVOID *ppv) <br>        { <br>            __try { <br>                *ppv = NULL; <br>            } __except (EXCEPTION_EXECUTE_HANDLER) { <br>                return E_POINTER; <br>            } <br> <br>            if (riid == IID_IUnknown || riid == IID_IClassFactory) { <br>                AddRef(); <br>                *ppv = (IClassFactory*)this; <br>                return S_OK; <br>            } <br>            return E_NOINTERFACE; <br>        } <br> <br>        STDMETHOD_(ULONG, AddRef) () { <br>            return 1; <br>        } <br> <br>        STDMETHOD_(ULONG, Release) () { <br>            return 1; <br>        } <br> <br>        //----------------------------------------------------------- <br>        // IClassFactory methods. <br>        //----------------------------------------------------------- <br>        STDMETHOD(CreateInstance)(IUnknown *punkOuter, REFIID riid, LPVOID *ppv) <br>        { <br>            *ppv = NULL; <br> <br>            if (punkOuter != NULL) { <br>                return CLASS_E_NOAGGREGATION; <br>            } <br> <br>            CPlotter *pJ2CThing; <br>            HRESULT hr; <br> <br>            pJ2CThing = new CPlotter(); <br>            if (!pJ2CThing) { <br>                return E_OUTOFMEMORY; <br>            } <br>         <br>            pJ2CThing-&gt;AddRef(); <br>            hr = pJ2CThing-&gt;QueryInterface(riid, ppv); <br>            pJ2CThing-&gt;Release(); <br>            return hr; <br>        } <br> <br>        STDMETHOD(LockServer)(BOOL fLock) { <br>            return S_OK; <br>            } <br> <br>}; <br> <br> <br>//=================================================================== <br>// Create our first (and only) classfactory. <br>//=================================================================== <br>J2CClassFactory g_CF; <br> <br> <br>// Rememeber our dll's module handle. <br>HINSTANCE ghInstance; <br> <br> <br> <br> <br>//=================================================================== <br>// Standard DLL entry point (called by Win32 loader.) <br>//=================================================================== <br>BOOL WINAPI DllMain(HINSTANCE hmod, DWORD dwReason, <br>                                PVOID pvReserved) <br>{ <br>   ghInstance = hmod; <br> <br>   if (dwReason == DLL_PROCESS_ATTACH) { <br>        OutputDebugString("Plotter.dll has successfully loaded.\n"); <br>   } <br> <br>   return TRUE; <br>} <br> <br> <br> <br> <br> <br> <br>//=================================================================== <br>// Standard Ole export ("creates" a classfactory.) <br>//=================================================================== <br>STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID *ppv) <br>{ <br> <br>    HRESULT hr; <br> <br>    __try { <br>        *ppv = NULL; <br>    } __except (EXCEPTION_EXECUTE_HANDLER) { <br>        return E_POINTER; <br>    } <br> <br>    if (rclsid != CLSID_CPlotter) { <br>        return CLASS_E_CLASSNOTAVAILABLE; <br>    } <br> <br>    return g_CF.QueryInterface(riid, ppv); <br> <br> <br>} <br> <br> <br> <br> <br>//=================================================================== <br>// Simple GUID unparsing utility (for self-registering code). <br>//=================================================================== <br> <br> <br>#define GUIDSTR_MAX (1+ 8 + 1 + 4 + 1 + 4 + 1 + 4 + 1 + 12 + 1 + 1) <br> <br>static const CHAR szDigits[] = "0123456789ABCDEF"; <br>static const BYTE GuidMap[] = { 3, 2, 1, 0, '-', 5, 4, '-', 7, 6, '-', <br>                                8, 9, '-', 10, 11, 12, 13, 14, 15 }; <br> <br> <br>//-------------------------------------------------------------------------- <br>// <br>//  Function:   GUID2StringA <br>// <br>//  Synopsis:   Convert GUID to string form <br>// <br>//  Arguments:  [rguid] - the guid to convert <br>//              [lpszy] - buffer to hold the results <br>// <br>//  Returns:    nothing <br>// <br>//  This code is massively plagiarized from the Ole sources. <br>//-------------------------------------------------------------------------- <br> <br>VOID <br>GUID2StringA(REFGUID rguid, LPSTR lpsz) <br>{ <br>    int i; <br>    LPSTR p = lpsz; <br> <br>    const BYTE * pBytes = (const BYTE *) &amp;rguid; <br> <br>    *p++ = '{'; <br> <br>    for (i = 0; i &lt; sizeof(GuidMap); i++) <br>    { <br>        if (GuidMap[i] == '-') <br>        { <br>            *p++ = '-'; <br>        } <br>        else <br>        { <br>            *p++ = szDigits[ (pBytes[GuidMap[i]] &amp; 0xF0) &gt;&gt; 4 ]; <br>            *p++ = szDigits[ (pBytes[GuidMap[i]] &amp; 0x0F) ]; <br>        } <br>    } <br>    *p++ = '}'; <br>    *p   = '\0'; <br>} <br> <br> <br> <br>const char achTM[] = "Both"; <br>const char achDESC[] = "Sample Custom Marshaling Server."; <br>const char achPROGID[] = "CPlotter"; <br> <br> <br>//=================================================================== <br>// Standard Ole export (for self-registration a la regsvr32.) <br>//=================================================================== <br>__declspec(dllexport) <br>STDAPI <br>DllRegisterServer(VOID) <br>{ <br>   HKEY    hKey  = NULL; <br>   HKEY    hKey2 = NULL; <br>   HKEY    hKey3 = NULL; <br>   DWORD   result; <br>   HRESULT hr = SELFREG_E_CLASS; <br>   CHAR    achCLSID[GUIDSTR_MAX]; <br>   TCHAR   achModulePathName[MAX_PATH]; <br> <br>   // If we fail in the middle, the state of the registry entries <br>   // is indeterminate (as per Ole specs.) <br> <br> <br>   // Create HKEY_CLASSES_ROOT\progid\CLSID <br>   result = RegCreateKey(HKEY_CLASSES_ROOT, achPROGID, &amp;hKey); <br>   if (result != ERROR_SUCCESS) { <br>      goto lExit; <br>   } <br>   result = RegSetValue(hKey, NULL, REG_SZ, achDESC, lstrlen(achDESC)); <br>   if (result != ERROR_SUCCESS) { <br>      goto lExit; <br>   } <br>   result = RegCreateKey(hKey, TEXT("CLSID"), &amp;hKey2); <br>   if (result != ERROR_SUCCESS) { <br>      goto lExit; <br>   } <br>   GUID2StringA(CLSID_CPlotter, achCLSID); <br>   result = RegSetValue(hKey2, NULL, REG_SZ, achCLSID, GUIDSTR_MAX-1); <br>   if (result != ERROR_SUCCESS) { <br>      goto lExit; <br>   } <br> <br>   RegCloseKey(hKey); <br>   RegCloseKey(hKey2); <br>   hKey = NULL; <br>   hKey2 = NULL; <br> <br> <br>   // Create HKEY_CLASSES_ROOT\CLSID\... <br>   result = RegCreateKey(HKEY_CLASSES_ROOT, TEXT("CLSID"), &amp;hKey); <br>   if (result != ERROR_SUCCESS) { <br>      goto lExit; <br>   } <br> <br>   result = RegCreateKey(hKey, achCLSID, &amp;hKey2); <br>   if (result != ERROR_SUCCESS) { <br>      goto lExit; <br>   } <br> <br>   result = RegSetValue(hKey2, NULL, REG_SZ, achDESC, lstrlen(achDESC)); <br>   if (result != ERROR_SUCCESS) { <br>      goto lExit; <br>   } <br> <br>   result = RegCreateKey(hKey2, "InprocServer32", &amp;hKey3); <br>   if (result != ERROR_SUCCESS) { <br>      goto lExit; <br>   } <br> <br>   result = GetModuleFileName(ghInstance, achModulePathName, sizeof(achModulePathName)/sizeof(TCHAR)); <br>   if (result == 0) {  //No way to detect truncation from GetModuleFileName.  <br>      goto lExit; <br>   } <br> <br>   result = RegSetValue(hKey3, NULL, REG_SZ, achModulePathName, lstrlen(achModulePathName)); <br>   if (result != ERROR_SUCCESS) { <br>      goto lExit; <br>   } <br> <br>   result = RegSetValueEx(hKey3, "ThreadingModel", 0, REG_SZ, (BYTE*)achTM, sizeof(achTM)); <br>   if (result != ERROR_SUCCESS) { <br>      goto lExit; <br>   } <br> <br>   RegCloseKey(hKey3); <br>   hKey3 = NULL; <br> <br> <br>   result = RegCreateKey(hKey2, "ProgID", &amp;hKey3); <br>   if (result != ERROR_SUCCESS) { <br>      goto lExit; <br>   } <br>   result = RegSetValue(hKey3, NULL, REG_SZ, achPROGID, lstrlen(achPROGID)); <br>   if (result != ERROR_SUCCESS) { <br>      goto lExit; <br>   } <br>   RegCloseKey(hKey3); <br>   hKey3 = NULL; <br> <br> <br> <br>   hr = S_OK; <br> <br> lExit: <br>   if (hKey) { <br>      RegCloseKey(hKey); <br>   } <br>   if (hKey2) { <br>      RegCloseKey(hKey2); <br>   } <br>   if (hKey3) { <br>      RegCloseKey(hKey3); <br>   } <br>   return hr; <br> <br>} <br> <br> <br> <br>//=================================================================== <br>// Standard Ole export (for self-unregistration a la regsvr32.) <br>//=================================================================== <br>__declspec(dllexport) <br>STDAPI <br>DllUnregisterServer(VOID) <br>{ <br>    return S_OK; <br>} <br> <br> <br> <br> <br> <br> <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
