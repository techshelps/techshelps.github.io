<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>COMSAMP.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context4327"></a>COMSAMP.CPP</h2>
<pre><code>#define INITGUID 1 <br> <br>#include &lt;windows.h&gt; <br>#include &lt;olectl.h&gt; <br> <br>#include "comsamp.h" <br> <br>TCHAR achSampleProgID[]        = "comntv"; <br>TCHAR achInprocServer32[]      = "InprocServer32"; <br>TCHAR achProgID[]              = "ProgID"; <br>TCHAR achThreadingModel[]      = "ThreadingModel"; <br>TCHAR achBoth[]                = "Both"; <br> <br> <br>DWORD g_ObjectCount = 0; <br>HINSTANCE ghInstance = 0; <br> <br> <br> <br>VOID ObjectCreated(VOID) <br>{ <br>    InterlockedIncrement( (LONG*)&amp;g_ObjectCount ); <br>} <br> <br> <br> <br>VOID ObjectDestroyed(VOID) <br>{ <br>    InterlockedDecrement( (LONG*)&amp;g_ObjectCount ); <br>} <br> <br> <br>HRESULT CheckJavaWriteAccess (BSTR pwszFilename) <br>{ <br>    // If there is no vm in the process, then we could not have <br>    // been called directly from java code, and remote calls are <br>    // implicitly trusted. <br>    if (GetModuleHandle("MSJAVA") == NULL) <br>        return S_OK; <br> <br>    HRESULT hr; <br> <br>    IMyCOMObjectSecurity *psecurity; <br> <br>    hr = CoCreateInstance( <br>            CLSID_CMyCOMObjectSecurity, <br>            NULL, <br>            CLSCTX_ALL, <br>            IID_IMyCOMObjectSecurity, <br>            (PVOID*)&amp;psecurity <br>            ); <br>    if (SUCCEEDED(hr)) <br>    { <br>        hr = psecurity-&gt;CheckRead(pwszFilename); <br>        psecurity-&gt;Release(); <br> <br>        // The VM does not convert SecurityException to a useful HRESULT, so do it here. <br>        if (hr == E_FAIL) <br>            hr = HRESULT_FROM_WIN32(ERROR_PRIVILEGE_NOT_HELD); <br>    } <br> <br>    return hr; <br>} <br> <br> <br>class CMyCOMObject : public IMyInterface <br>{ <br>    ULONG refcount; <br> <br>public: <br> <br>    CMyCOMObject () <br>    { <br>        refcount = 1; <br>    } <br>     <br> <br>    // IUnknown methods <br>     <br>    HRESULT STDMETHODCALLTYPE QueryInterface (REFIID riid, LPVOID* ppv) <br>    { <br>        *ppv = NULL; <br>         <br>        if (riid == IID_IUnknown) <br>        { <br>            *ppv = (IUnknown*)this; <br>        } <br>        else if (riid == IID_IMyInterface) <br>        { <br>            *ppv = (IMyInterface*)this; <br>        } <br>         <br>        if (*ppv) <br>        { <br>            ((IUnknown*)(*ppv))-&gt;AddRef(); <br>            return S_OK; <br>        } <br>         <br>        return E_NOINTERFACE; <br>    } <br> <br>    ULONG STDMETHODCALLTYPE AddRef () <br>    { <br>        InterlockedIncrement((LONG*)&amp;refcount); <br>        return 0xcccccccc; <br>    } <br> <br>    ULONG STDMETHODCALLTYPE Release () <br>    { <br>        if (!InterlockedDecrement((LONG*)&amp;refcount)) <br>        { <br>            delete this; <br>            return 0; <br>        } <br>         <br>        return 0xcccccccc; <br>    } <br> <br> <br>    // IMyInterface methods <br> <br>    HRESULT STDMETHODCALLTYPE COMCheckedLoad (BSTR pwszFilename, BYTE buffer[], int *bufsize) <br>    { <br>        HRESULT hr = CheckJavaWriteAccess(pwszFilename); <br>        if (SUCCEEDED(hr)) <br>        { <br>            hr = JavaCheckedLoad(pwszFilename, buffer, bufsize); <br>        } <br>         <br>        return hr; <br>    } <br>     <br>    HRESULT STDMETHODCALLTYPE JavaCheckedLoad (BSTR pwszFilename, BYTE buffer[], int *bufsize) <br>    { <br>        if (pwszFilename == NULL || buffer == NULL || bufsize == NULL) <br>            return E_POINTER; <br> <br>        if (*bufsize &lt; 0) <br>            return E_INVALIDARG; <br> <br>        HRESULT hr = E_FAIL; <br> <br>        CHAR filename[MAX_PATH]; <br>        int filenamelen = WideCharToMultiByte( <br>                CP_ACP, <br>                0, <br>                pwszFilename, <br>                -1, <br>                filename, <br>                sizeof(filename)-1, <br>                NULL, <br>                NULL); <br>        if (filenamelen != 0) <br>        { <br>            filename[filenamelen] = '\0'; <br> <br>            HANDLE file = CreateFile( <br>                    filename, <br>                    GENERIC_READ, <br>                    FILE_SHARE_READ, <br>                    NULL, <br>                    OPEN_EXISTING, <br>                    FILE_FLAG_SEQUENTIAL_SCAN, <br>                    NULL <br>                    ); <br>            if (file != INVALID_HANDLE_VALUE) <br>            { <br>                DWORD size = GetFileSize(file, NULL); <br>                if (size != 0xffffffff) <br>                { <br>                    DWORD toread = size; <br>                    if (toread &gt; *bufsize) <br>                        toread = *bufsize; <br> <br>                    DWORD read; <br>                    if (ReadFile( <br>                            file, <br>                            buffer, <br>                            toread, <br>                            &amp;read, <br>                            NULL <br>                            ) <br>                          &amp;&amp; read == size <br>                          ) <br>                    { <br>                        *bufsize = read; <br>                        hr = S_OK; <br>                    } <br>                } <br> <br>                CloseHandle(file); <br>            } <br>        } <br> <br>        if (hr == E_FAIL) <br>            hr = HRESULT_FROM_WIN32(GetLastError()); <br> <br>        return hr; <br>    } <br>}; <br> <br> <br> <br>class CMyComObjectClassFactory : public IClassFactory <br>{ <br>public: <br> <br>    CMyComObjectClassFactory () <br>    { <br>        ObjectCreated(); <br>    } <br> <br>    ~CMyComObjectClassFactory () <br>    { <br>        ObjectDestroyed(); <br>    } <br>     <br> <br>    // IUnknown methods <br>     <br>    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, LPVOID* ppv) <br>    { <br>        *ppv = NULL; <br>        if (riid == IID_IUnknown) <br>        { <br>            *ppv = (IUnknown*)this; <br>        } <br>        else if (riid == IID_IClassFactory) <br>        { <br>            *ppv = (IClassFactory*)this; <br>        } <br>        if (*ppv) <br>        { <br>            ((IUnknown*)(*ppv))-&gt;AddRef(); <br>            return S_OK; <br>        } <br>        return E_NOINTERFACE; <br> <br>    } <br> <br>    ULONG STDMETHODCALLTYPE AddRef () <br>    { <br>        return 0xcccccccc; <br>    } <br> <br>    ULONG STDMETHODCALLTYPE Release () <br>    { <br>        return 0xcccccccc; <br>    } <br> <br> <br>    // IClassFactory methods <br>     <br>    HRESULT STDMETHODCALLTYPE CreateInstance (IUnknown *punkOuter, REFIID riid, VOID **ppv) <br>    { <br>        HRESULT hr; <br>        *ppv = NULL; <br>         <br>        if (punkOuter) <br>        { <br>            return CLASS_E_NOAGGREGATION; <br>        } <br>         <br>        CMyCOMObject *obj = new CMyCOMObject(); <br>        if (obj == NULL) <br>        { <br>            return E_OUTOFMEMORY; <br>        } <br>         <br>        hr = obj-&gt;QueryInterface(riid, ppv); <br>        obj-&gt;Release(); <br>        return hr; <br>    } <br> <br>    HRESULT STDMETHODCALLTYPE LockServer (BOOL fLock) <br>    { <br>        if (fLock) <br>            ObjectCreated(); <br>        else <br>            ObjectDestroyed(); <br>        return S_OK; <br>    } <br>}; <br> <br> <br>CMyComObjectClassFactory g_CMyCOMObjectFactory; <br> <br> <br>extern "C" <br>BOOL WINAPI DllMain (HINSTANCE hmod, DWORD dwReason, PVOID pvReserved) <br>{ <br>    ghInstance = hmod; <br>    return TRUE; <br>} <br> <br> <br>STDAPI DllGetClassObject (REFCLSID rclsid, REFIID riid, LPVOID *ppv) <br>{ <br>    *ppv = NULL; <br>    if (rclsid == CLSID_CMyCOMObject) <br>    { <br>        return g_CMyCOMObjectFactory.QueryInterface(riid, ppv); <br>    } <br>    else <br>    { <br>        return CLASS_E_CLASSNOTAVAILABLE; <br>    } <br>} <br> <br> <br>STDAPI DllCanUnloadNow () <br>{ <br>    return g_ObjectCount; <br>} <br> <br> <br> <br> <br>// Plagiarized from comsamp. <br> <br> <br> <br> <br>#define GUIDSTR_MAX (1+ 8 + 1 + 4 + 1 + 4 + 1 + 4 + 1 + 12 + 1 + 1) <br> <br>static const CHAR szDigits[] = "0123456789ABCDEF"; <br>static const BYTE GuidMap[] = { 3, 2, 1, 0, '-', 5, 4, '-', 7, 6, '-', <br>                                8, 9, '-', 10, 11, 12, 13, 14, 15 }; <br> <br> <br>//-------------------------------------------------------------------------- <br>// <br>//  Function:   GUID2StringA <br>// <br>//  Synopsis:   Convert GUID to string form <br>// <br>//  Arguments:  [rguid] - the guid to convert <br>//              [lpszy] - buffer to hold the results <br>// <br>//  Returns:    nothing <br>// <br>//  This code is massively plagiarized from the Ole sources. <br>//-------------------------------------------------------------------------- <br> <br>VOID <br>GUID2StringA(REFGUID rguid, LPSTR lpsz) <br>{ <br>    int i; <br>    LPSTR p = lpsz; <br> <br>    const BYTE * pBytes = (const BYTE *) &amp;rguid; <br> <br>    *p++ = '{'; <br> <br>    for (i = 0; i &lt; sizeof(GuidMap); i++) <br>    { <br>        if (GuidMap[i] == '-') <br>        { <br>            *p++ = '-'; <br>        } <br>        else <br>        { <br>            *p++ = szDigits[ (pBytes[GuidMap[i]] &amp; 0xF0) &gt;&gt; 4 ]; <br>            *p++ = szDigits[ (pBytes[GuidMap[i]] &amp; 0x0F) ]; <br>        } <br>    } <br>    *p++ = '}'; <br>    *p   = '\0'; <br>} <br> <br> <br> <br> <br>//-------------------------------------------------------------------------- <br>// <br>//  NTCompatibleRegDeleteKey <br>// <br>//-------------------------------------------------------------------------- <br>LONG <br>NTCompatibleRegDeleteKey(HKEY hKey, LPCTSTR szSubKey) <br>{ <br>   TCHAR achName[MAX_PATH+1]; <br>   HKEY  hSubkey; <br> <br>   if (ERROR_SUCCESS != RegOpenKey(hKey, szSubKey, &amp;hSubkey)) { <br>      return REGDB_E_INVALIDVALUE; <br>   } <br> <br>   if (ERROR_SUCCESS == RegEnumKey(hSubkey, 0, achName, sizeof(achName)/sizeof(TCHAR))) { <br>      RegCloseKey(hSubkey); <br>      // There's still one subkey: fail the call. <br>      return REGDB_E_INVALIDVALUE; <br>   } <br>   RegCloseKey(hSubkey); <br>   return RegDeleteKey(hKey, szSubKey); <br>} <br> <br> <br> <br>STDAPI DllRegisterServer () <br>{ <br>   HKEY    hKey  = NULL; <br>   HKEY    hKey2 = NULL; <br>   HKEY    hKey3 = NULL; <br>   DWORD   result; <br>   HRESULT hr = SELFREG_E_CLASS; <br>   CHAR    achCLSID[GUIDSTR_MAX]; <br>   TCHAR   achModulePathName[MAX_PATH]; <br> <br>   // If we fail in the middle, the state of the registry entries <br>   // is indeterminate (as per Ole specs.) <br> <br> <br>   // Create HKEY_CLASSES_ROOT\progid\CLSID <br>   result = RegCreateKey(HKEY_CLASSES_ROOT, achSampleProgID, &amp;hKey); <br>   if (result != ERROR_SUCCESS) { <br>      goto lExit; <br>   } <br>   result = RegCreateKey(hKey, TEXT("CLSID"), &amp;hKey2); <br>   if (result != ERROR_SUCCESS) { <br>      goto lExit; <br>   } <br>   GUID2StringA(CLSID_CMyCOMObject, achCLSID); <br>   result = RegSetValue(hKey2, NULL, REG_SZ, achCLSID, GUIDSTR_MAX-1); <br>   if (result != ERROR_SUCCESS) { <br>      goto lExit; <br>   } <br> <br>   RegCloseKey(hKey); <br>   RegCloseKey(hKey2); <br>   hKey = NULL; <br>   hKey2 = NULL; <br> <br> <br>   // Create HKEY_CLASSES_ROOT\CLSID\... <br>   result = RegCreateKey(HKEY_CLASSES_ROOT, TEXT("CLSID"), &amp;hKey); <br>   if (result != ERROR_SUCCESS) { <br>      goto lExit; <br>   } <br> <br>   result = RegCreateKey(hKey, achCLSID, &amp;hKey2); <br>   if (result != ERROR_SUCCESS) { <br>      goto lExit; <br>   } <br> <br>   result = RegCreateKey(hKey2, achInprocServer32, &amp;hKey3); <br>   if (result != ERROR_SUCCESS) { <br>      goto lExit; <br>   } <br> <br>   result = GetModuleFileName(ghInstance, achModulePathName, sizeof(achModulePathName)/sizeof(TCHAR)); <br>   if (result == 0) {  //No way to detect truncation from GetModuleFileName.  <br>      goto lExit; <br>   } <br> <br>   result = RegSetValue(hKey3, NULL, REG_SZ, achModulePathName, lstrlen(achModulePathName)); <br>   if (result != ERROR_SUCCESS) { <br>      goto lExit; <br>   } <br> <br>   result = RegSetValueEx(hKey3, achThreadingModel, 0, REG_SZ, (BYTE*)achBoth, sizeof(achBoth)); <br>   if (result != ERROR_SUCCESS) { <br>      goto lExit; <br>   } <br> <br>   RegCloseKey(hKey3); <br>   hKey3 = NULL; <br> <br> <br>   result = RegCreateKey(hKey2, achProgID, &amp;hKey3); <br>   if (result != ERROR_SUCCESS) { <br>      goto lExit; <br>   } <br>   result = RegSetValue(hKey3, NULL, REG_SZ, achSampleProgID, lstrlen(achSampleProgID)); <br>   if (result != ERROR_SUCCESS) { <br>      goto lExit; <br>   } <br>   RegCloseKey(hKey3); <br>   hKey3 = NULL; <br> <br> <br> <br>   hr = S_OK; <br> <br> lExit: <br>   if (hKey) { <br>      RegCloseKey(hKey); <br>   } <br>   if (hKey2) { <br>      RegCloseKey(hKey2); <br>   } <br>   if (hKey3) { <br>      RegCloseKey(hKey3); <br>   } <br>   return hr; <br> <br>} <br> <br> <br> <br>//---------------------------------------------------------------------- <br>// DllUnregisterServer(): Called by OLE. <br>//---------------------------------------------------------------------- <br>STDAPI DllUnregisterServer(VOID) <br>{ <br>   HKEY    hKey  = NULL; <br>   HKEY    hKey2 = NULL; <br>   DWORD   result; <br>   HRESULT hr = SELFREG_E_CLASS; <br>   CHAR    achCLSID[GUIDSTR_MAX]; <br> <br>   // If we fail in the middle, the state of the registry entries <br>   // is indeterminate (as per Ole specs.) <br>   GUID2StringA(CLSID_CMyCOMObject, achCLSID); <br> <br> <br>   result = RegOpenKey(HKEY_CLASSES_ROOT, achSampleProgID, &amp;hKey); <br>   if (result == ERROR_SUCCESS) { <br>      NTCompatibleRegDeleteKey(hKey, TEXT("CLSID")); <br>      RegCloseKey(hKey); <br>      hKey = NULL; <br>      NTCompatibleRegDeleteKey(HKEY_CLASSES_ROOT, achSampleProgID); <br>   } <br>   // If this fails, it means somebody else added a subkey to this tree. <br>   // We're not allowed to touch it so ignore the failure. <br> <br> <br>   result = RegOpenKey(HKEY_CLASSES_ROOT, TEXT("CLSID"), &amp;hKey); <br>   if (result == ERROR_SUCCESS) { <br> <br>      result = RegOpenKey(hKey, achCLSID, &amp;hKey2); <br>      if (result == ERROR_SUCCESS) { <br>         NTCompatibleRegDeleteKey(hKey2, achInprocServer32); <br>         NTCompatibleRegDeleteKey(hKey2, achProgID); <br>         RegCloseKey(hKey2); <br>         hKey2 = NULL; <br>         NTCompatibleRegDeleteKey(hKey, achCLSID); <br>      } <br> <br>      // If this fails, it means somebody else added a subkey to this tree. <br>      // We're not allowed to touch it so ignore the failure. <br> <br>      RegCloseKey(hKey); <br>      hKey = NULL; <br>   } <br> <br> <br>   hr = S_OK; <br> <br>   return hr; <br> <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
