<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>NATCOM.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context4324"></a>NATCOM.CPP</h2>
<pre><code>/* <br>Copyright (c) 1996-1997  Microsoft Corporation.  All rights reserved. <br>*/ <br> <br>#include &lt;windows.h&gt; <br>#include "natcom.h" <br>#include &lt;iostream.h&gt; <br>#include &lt;olectl.h&gt; <br>#include &lt;stdio.h&gt; <br> <br>// globals <br> <br>ULONGg_cObject = 0 ; <br>HANDLEg_hDllMain ; <br> <br>//////////////////////////////////////////////////////////////////////////////// <br>// <br>//ObjectCreated() <br>// <br>//increments ref count of objects which reference this .DLL <br>// <br>//// <br>VOID ObjectCreated(VOID) <br>{ <br>    InterlockedIncrement( (LONG*)&amp;g_cObject ) ; <br>} <br> <br>//////////////////////////////////////////////////////////////////////////////// <br>// <br>//ObjectDestroyed() <br>// <br>//decrements ref count of objects which reference this .dll <br>// <br>//// <br>VOID ObjectDestroyed(VOID) <br>{ <br>    InterlockedDecrement( (LONG*)&amp;g_cObject ) ; <br>} <br> <br>//////////////////////////////////////////////////////////////////////////////// <br>// <br>//CNatCom <br>// <br>//contains our COM object <br>// <br>//// <br>class CNatCom : public IUnknown <br>{ <br>//////////////////////////////////////////////////////////////////////// <br>// <br>//CImpINatCom <br>// <br>//implements the INatCom interface.  IUnknown delegates to <br>//controlling unknown (CNatCom if not aggregated). <br>// <br>//// <br>class CImpINatCom : public INatCom <br>{ <br>friend class CNatCom ; <br> <br>// PUBLIC ------------------------------------------------------ <br> <br>public : <br> <br>//////////////////////////////////////////////////////////////// <br>// <br>// <br>//CImpINatCom() <br>// <br>//constructor;  Initialize member variables. <br>// <br>//// <br>CImpINatCom() <br>{ <br>m_cRef = 0 ; <br>m_pNatCom = NULL ; <br>m_punkCCW = NULL ; <br>} <br> <br>//////////////////////////////////////////////////////////////// <br>// <br>//~CImpINatCom() <br>// <br>//destructor; release CCW if we have one. <br>// <br>//// <br>~CImpINatCom() <br>{ <br>if (m_punkCCW) <br>{ <br>m_punkCCW-&gt;Release() ; <br>} <br>} <br> <br>//////////////////////////////////////////////////////////////// <br>// <br>//QueryInterface() <br>// <br>//delegating QI. <br>// <br>//// <br>HRESULT __stdcall QueryInterface(REFIID riid, void **ppv) <br>{ <br>return m_pUnkOuter-&gt;QueryInterface(riid,ppv) ; <br>} <br> <br>//////////////////////////////////////////////////////////////// <br>// <br>//AddRef() <br>// <br>//// <br>ULONG __stdcall AddRef(void) <br>{ <br>return m_pUnkOuter-&gt;AddRef() ; <br>} <br> <br>//////////////////////////////////////////////////////////////// <br>// <br>//Release() <br>// <br>//delegating Release <br>// <br>//// <br>ULONG __stdcall Release(void) <br>{ <br>return m_pUnkOuter-&gt;Release() ; <br>} <br> <br>//////////////////////////////////////////////////////////////// <br>// <br>//MultParam() <br>// <br>//multiplies the two passed arguments and returns the <br>//value back in lVal. <br>// <br>//parameters: <br>//lMultmultiplier <br>//lValreturns value we are multiplied by <br>// <br>//// <br>HRESULT __stdcall MultParam(long lMult, long *lVal) <br>{ <br>*lVal = *lVal * lMult ; <br> <br>return S_OK ; <br>} <br> <br>//////////////////////////////////////////////////////////////// <br>// <br>//Square() <br>// <br>//squares lVal, returning the result back in lResult. <br>// <br>//parameters: <br>//lValvalue to be squared <br>//lResult return value = lVal squared <br>// <br>//// <br>HRESULT __stdcall Square(long lVal, long *lResult) <br>{ <br>*lResult = lVal * lVal ; <br> <br>return S_OK ; <br>} <br> <br>//////////////////////////////////////////////////////////////// <br>// <br>//GetClass() <br>// <br>//CoCreates a java-implemented object (CCW); returns the <br>//pointer into the v-table to the callee; exercises one <br>//method in the ccw. <br>// <br>//parameters: <br>//pjNatCompointer to our CCW. <br>// <br>//// <br>HRESULT __stdcall GetClass(jINatCom **pjNatCom) <br>{ <br>HRESULT hr ; <br> <br>if (FAILED(hr = CoCreateInstance(CLSID_jCNatCom, NULL, CLSCTX_SERVER, IID_IUnknown, (void **)&amp;m_punkCCW))) <br>{ <br>return hr ; <br>} <br> <br>if (FAILED(hr = m_punkCCW-&gt;QueryInterface(IID_jINatCom, (void **)&amp;m_pNatCom))) <br>{ <br>m_punkCCW-&gt;Release() ;// IID_IUnknown <br>m_punkCCW = NULL ; <br> <br>return hr ; <br>} <br> <br>// per the rules of COM we leave the refcount at 2, since <br>//  we're passing the pointer back to the caller.  Caller <br>//  must Release() the object. <br> <br>// set member variable <br>*pjNatCom = m_pNatCom ; <br> <br>// invoke java-implemented method <br>m_pNatCom-&gt;ccwHelloWorld() ; <br> <br>return S_OK ; <br>} <br> <br>//////////////////////////////////////////////////////////////// <br> <br>private : <br> <br>ULONGm_cRef ;// ref count <br>IUnknown*m_pUnkOuter ;// controlling unknown <br>jINatCom*m_pNatCom ;// ccw interface pointer <br>IUnknown*m_punkCCW ;// IUnknown of our CCW <br>} ; <br> <br>CImpINatCom m_CImpINatCom ; <br> <br>// PUBLIC -------------------------------------------------------------- <br> <br>public : <br> <br>//////////////////////////////////////////////////////////////////////// <br>// <br>//CNatCom() <br>// <br>//constructor;  initializes variables, including those of <br>//CImpINatCom to point to controlling unknown. <br>// <br>//// <br>CNatCom(IUnknown *punkOuter) <br>{ <br>ObjectCreated() ; <br> <br>m_cRef = 0 ; <br> <br>// if this is non-null, we're being aggregated <br>if (punkOuter) <br>{ <br>m_pUnkOuter = punkOuter ; <br>m_CImpINatCom.m_pUnkOuter = punkOuter ; <br>} <br>else <br>{ <br>m_pUnkOuter = this ; <br>m_CImpINatCom.m_pUnkOuter = this ; <br>} <br>} <br> <br>//////////////////////////////////////////////////////////////////////// <br>// <br>//~CNatCom() <br>// <br>//destructor. <br>// <br>//// <br>~CNatCom() <br>{ <br>ObjectDestroyed() ; <br>} <br> <br>//////////////////////////////////////////////////////////////////////// <br>// <br>//QueryInterface() <br>// <br>//non-delegating QI <br>// <br>//// <br>HRESULT __stdcall QueryInterface(REFIID riid, void **ppv) <br>{ <br>*ppv = NULL ; <br>         <br>if (riid == IID_IUnknown) <br>{ <br>*ppv = this ; <br>} <br> <br>if (riid == IID_INatCom) <br>{ <br>*ppv = &amp;m_CImpINatCom ; <br>} <br> <br>if (*ppv == NULL) <br>{ <br>return E_NOINTERFACE ; <br>} <br> <br>((IUnknown *) *ppv)-&gt;AddRef() ; <br>         <br>return NOERROR ; <br>} <br>         <br>//////////////////////////////////////////////////////////////////////// <br>// <br>//AddRef() <br>// <br>//non-delegating AddRef() <br>// <br>//// <br>ULONG __stdcall AddRef(void) <br>{ <br>InterlockedIncrement( (LONG*)&amp;m_cRef ) ; <br> <br>return m_cRef ; <br>} <br> <br>//////////////////////////////////////////////////////////////////////// <br>// <br>//Release() <br>// <br>//non-delegating Release <br>// <br>//// <br>ULONG __stdcall Release(void) <br>{ <br>if (!InterlockedDecrement( (LONG*)&amp;m_cRef )) <br>{ <br>delete this ; <br>return 0 ; <br>} <br>         <br>return m_cRef ; <br>} <br> <br>// PRIVATE ------------------------------------------------------------- <br> <br>private : <br> <br>ULONGm_cRef ;// ref count <br>IUnknown*m_pUnkOuter ;// controlling unknown <br>} ; <br> <br>// CLASS FACTORY -------------------------------------------------------------- <br> <br>//////////////////////////////////////////////////////////////////////////////// <br>// <br>//CNatComCF <br>// <br>//class factory for CNatCom <br>// <br>//// <br>class CNatComCF : public IClassFactory <br>{ <br>public : <br> <br>//////////////////////////////////////////////////////////////////////// <br>// <br>//CNatComCF() <br>// <br>//constructor <br>// <br>//// <br>CNatComCF() <br>{ <br>m_cRef = 0 ; <br>} <br> <br>/////////////////////////////////////////////////////////////////////// <br>// <br>//CreateInstance() <br>// <br>//IClassFactory CreateInstance() method implementation <br>// <br>//// <br>HRESULT __stdcall CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv) <br>{ <br>CNatCom *cmg ; <br>HRESULT hr ; <br> <br>*ppv = NULL ; <br> <br>if ((punkOuter) &amp;&amp; (riid != IID_IUnknown)) <br>{ <br>return CLASS_E_NOAGGREGATION ; <br>} <br> <br>cmg = new CNatCom(punkOuter) ; <br> <br>hr = cmg-&gt;QueryInterface(riid, ppv) ; <br> <br>if (FAILED(hr)) <br>{ <br>delete cmg ; <br>return hr ; <br>} <br> <br>return S_OK ; <br>} <br> <br>//////////////////////////////////////////////////////////////////////// <br>// <br>//QueryInterface() <br>// <br>//IUnknown QueryInterface() method implementation <br>// <br>//// <br>HRESULT __stdcall QueryInterface(REFIID iid, void **ppv) <br>{ <br>*ppv = NULL ; <br> <br>if (iid == IID_IUnknown || iid == IID_IClassFactory) <br>*ppv = this ; <br>else <br>return E_NOINTERFACE ; <br> <br>AddRef() ; <br> <br>return S_OK ; <br>} <br> <br>//////////////////////////////////////////////////////////////////////// <br>// <br>//AddRef() <br>// <br>//IUnknown AddRef() method implementation <br>// <br>//// <br>ULONG __stdcall AddRef(void) <br>{ <br>return ++m_cRef ; <br>} <br> <br>//////////////////////////////////////////////////////////////////////// <br>// <br>//Release() <br>// <br>//IUnknown Release() method implementation <br>// <br>//// <br>ULONG __stdcall Release(void) <br>{ <br>if (--m_cRef == 0) <br>{ <br>delete this ; <br>return 0 ; <br>} <br>         <br>return m_cRef ; <br>} <br> <br>//////////////////////////////////////////////////////////////////////// <br>// <br>//LockServer() <br>// <br>//IClassFactory LockServer() method implementation <br>// <br>//// <br>HRESULT __stdcall LockServer(BOOL bLock) <br>{ <br>bLock ? ObjectCreated() : ObjectDestroyed() ; <br> <br>return S_OK ; <br>} <br> <br> <br>// PRIVATE ------------------------------------------------------------- <br> <br>private : <br> <br>ULONGm_cRef ;// refcount <br>} ; <br> <br>//////////////////////////////////////////////////////////////////////////////// <br>// <br>//DllMain() <br>// <br>//entry point <br>// <br>//// <br>BOOL WINAPI DllMain(HINSTANCE hDLLInst, DWORD fdwReason, LPVOID lpvReserved) <br>{ <br>switch (fdwReason) <br>{ <br>  case DLL_PROCESS_ATTACH : <br>g_hDllMain = hDLLInst ; <br>} <br> <br>return TRUE ; <br>} <br> <br>// ----------------------------------------------------------------------------- <br> <br>TCHAR achSampleDesc[]= "CNatCom"; <br>TCHAR achInprocServer32[]= "InprocServer32"; <br>TCHAR achSampleProgID[] = "CNatCom"; <br>TCHAR achProgID[]= "CNatCom"; <br>TCHAR achThreadingModel[]= "ThreadingModel"; <br>TCHAR achFree[] = "Both"; <br> <br>#define GUIDSTR_MAX(1+ 8 + 1 + 4 + 1 + 4 + 1 + 4 + 1 + 12 + 1 + 1) <br>static const CHAR szDigits[]= "0123456789ABCDEF"; <br>static const BYTE GuidMap[]= { 3, 2, 1, 0, '-', 5, 4, '-', 7, 6, '-', <br>    8, 9, '-', 10, 11, 12, 13, 14, 15 }; <br> <br>//////////////////////////////////////////////////////////////////////////////// <br>// <br>//GUID2StringA() <br>// <br>//converts GUID to string form <br>// <br>//// <br>VOID GUID2StringA(REFGUID rguid, LPSTR lpsz) <br>{ <br>inti; <br>LPSTRp = lpsz; <br> <br>const BYTE * pBytes = (const BYTE *) &amp;rguid; <br> <br>*p++ = '{'; <br> <br>for (i = 0; i &lt; sizeof(GuidMap); i++) <br>{ <br>if (GuidMap[i] == '-') <br>{ <br>*p++ = '-'; <br>} <br>else <br>{ <br>*p++ = szDigits[ (pBytes[GuidMap[i]] &amp; 0xF0) &gt;&gt; 4 ]; <br>*p++ = szDigits[ (pBytes[GuidMap[i]] &amp; 0x0F) ]; <br>} <br>} <br> <br>*p++ = '}'; <br>*p   = '\0'; <br>} <br> <br>//////////////////////////////////////////////////////////////////////////////// <br>// <br>//NTCompatibleRegDeleteKey() <br>// <br>//checks that registry key does not have any subkeys prior to deletion <br>// <br>//// <br>LONG NTCompatibleRegDeleteKey(HKEY hKey, LPCTSTR szSubKey) <br>{ <br>TCHAR achName[MAX_PATH+1]; <br>HKEY  hSubkey; <br> <br>if (ERROR_SUCCESS != RegOpenKey(hKey, szSubKey, &amp;hSubkey)) <br>return REGDB_E_INVALIDVALUE; <br> <br>if (ERROR_SUCCESS == RegEnumKey(hSubkey, 0, achName, sizeof(achName)/sizeof(TCHAR))) <br>{ <br>RegCloseKey(hSubkey); <br>// There's still one subkey: fail the call. <br>return REGDB_E_INVALIDVALUE; <br>} <br> <br>RegCloseKey(hSubkey); <br>return RegDeleteKey(hKey, szSubKey); <br>} <br> <br>//////////////////////////////////////////////////////////////////////////////// <br>// <br>//DllRegisterServer() <br>// <br>//registers this COM server via the registry. <br>// <br>//// <br>STDAPI DllRegisterServer(VOID) <br>{ <br>HKEYhKey  = NULL; <br>HKEYhKey2  = NULL; <br>HKEYhKey3  = NULL; <br>DWORDresult; <br>HRESULT hr = SELFREG_E_CLASS; <br>CHARachCLSID[GUIDSTR_MAX]; <br>CHARachLIBID[GUIDSTR_MAX] ; <br>TCHARachModulePathName[MAX_PATH]; <br>TCHARachCurrentDirectory[MAX_PATH] ; <br> <br>// CLSID <br> <br>GUID2StringA(CLSID_CNatCom, achCLSID) ; <br> <br>// If we fail in the middle, the state of the registry entries <br>// is indeterminate (as per Ole specs.) <br> <br>// Create HKEY_CLASSES_ROOT\progid\CLSID <br>result = RegCreateKey(HKEY_CLASSES_ROOT, achSampleProgID, &amp;hKey); <br>if (result != ERROR_SUCCESS) goto lExit; <br> <br>result = RegSetValue(hKey, NULL, REG_SZ, achSampleDesc, lstrlen(achSampleDesc)); <br>if (result != ERROR_SUCCESS) goto lExit; <br> <br>result = RegCreateKey(hKey, TEXT("CLSID"), &amp;hKey2); <br>if (result != ERROR_SUCCESS) goto lExit; <br> <br>result = RegSetValue(hKey2, NULL, REG_SZ, achCLSID, GUIDSTR_MAX-1); <br>if (result != ERROR_SUCCESS) goto lExit; <br> <br>RegCloseKey(hKey); <br>RegCloseKey(hKey2); <br>hKey = NULL; <br>hKey2 = NULL; <br> <br>// Create HKEY_CLASSES_ROOT\CLSID\... <br> <br>// create CLSID key <br>result = RegCreateKey(HKEY_CLASSES_ROOT, TEXT("CLSID"), &amp;hKey); <br>if (result != ERROR_SUCCESS) goto lExit ; <br> <br>// create CLSID/GUID key <br>result = RegCreateKey(hKey, achCLSID, &amp;hKey2); <br>if (result != ERROR_SUCCESS) goto lExit ; <br> <br>// put in sample description value into CLSID\GUID key <br>result = RegSetValue(hKey2, NULL, REG_SZ, achSampleDesc, lstrlen(achSampleDesc)); <br>if (result != ERROR_SUCCESS) goto lExit ; <br> <br>// get our path .. <br>result = GetModuleFileName(g_hDllMain, achModulePathName, sizeof(achModulePathName)/sizeof(TCHAR)); <br>if (result == 0) goto lExit ; <br> <br>// create subkey under CLSID\GUID <br>result = RegCreateKey(hKey2, achInprocServer32, &amp;hKey3); <br>if (result != ERROR_SUCCESS) goto lExit ; <br> <br>// set key value to the path obtained above <br>result = RegSetValue(hKey3, NULL, REG_SZ, achModulePathName, lstrlen(achModulePathName)); <br>if (result != ERROR_SUCCESS) goto lExit ; <br> <br>// both <br>result = RegSetValueEx(hKey3, achThreadingModel, 0, REG_SZ, (BYTE*)achFree, sizeof(achFree)); <br>if (result != ERROR_SUCCESS) goto lExit; <br> <br>RegCloseKey(hKey3); <br>hKey3 = NULL; <br> <br>// PROGID <br> <br>result = RegCreateKey(hKey2, achProgID, &amp;hKey3); <br>if (result != ERROR_SUCCESS) goto lExit; <br> <br>result = RegSetValue(hKey3, NULL, REG_SZ, achSampleProgID, lstrlen(achSampleProgID)); <br>if (result != ERROR_SUCCESS) goto lExit; <br> <br>RegCloseKey(hKey3); <br>hKey3 = NULL; <br> <br> <br>hr = S_OK ; <br> <br> lExit : <br> <br>// close up <br>if (hKey) RegCloseKey(hKey); <br>if (hKey2) RegCloseKey(hKey2); <br>if (hKey3) RegCloseKey(hKey3); <br> <br>return hr ; <br>} <br> <br>//////////////////////////////////////////////////////////////////////////////// <br>// <br>//DllUnregisterServer() <br>// <br>//removes our registry entries (entered via DllRegisterServer()) <br>// <br>//// <br>STDAPI DllUnregisterServer(VOID) <br>{ <br>HKEYhKey  = NULL; <br>HKEYhKey2 = NULL; <br>DWORDresult; <br>HRESULT hr = SELFREG_E_CLASS; <br>CHARachCLSID[GUIDSTR_MAX]; <br>CHARachLIBID[GUIDSTR_MAX]; <br> <br>// If we fail in the middle, the state of the registry entries <br>// is indeterminate (as per Ole specs.) <br>GUID2StringA(CLSID_CNatCom, achCLSID); <br> <br>result = RegOpenKey(HKEY_CLASSES_ROOT, achSampleProgID, &amp;hKey); <br>if (result == ERROR_SUCCESS) <br>{ <br>NTCompatibleRegDeleteKey(hKey, TEXT("CLSID")); <br>RegCloseKey(hKey); <br>hKey = NULL; <br>NTCompatibleRegDeleteKey(HKEY_CLASSES_ROOT, achSampleProgID); <br>} <br> <br>result = RegOpenKey(HKEY_CLASSES_ROOT, TEXT("CLSID"), &amp;hKey); <br>result = RegOpenKey(hKey, achCLSID, &amp;hKey2); <br> <br>if (result == ERROR_SUCCESS) <br>{ <br>NTCompatibleRegDeleteKey(hKey2, achInprocServer32); <br>NTCompatibleRegDeleteKey(hKey2, achProgID); <br>RegCloseKey(hKey2); <br>hKey2 = NULL; <br>NTCompatibleRegDeleteKey(hKey, achCLSID); <br>} <br> <br>// If this fails, it means somebody else added a subkey to this tree. <br>// We're not allowed to touch it so ignore the failure. <br> <br>RegCloseKey(hKey); <br>hKey = NULL; <br> <br>hr = S_OK; <br> <br>return hr; <br>} <br> <br> <br>//////////////////////////////////////////////////////////////////////////////// <br>// <br>//DllGetClassObject() <br>// <br>//COM entry point <br>// <br>//// <br>STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, VOID **ppv) <br>{ <br>HRESULT hr ; <br>class CNatComCF *pcf; <br> <br>*ppv = NULL ; <br> <br>if (rclsid != CLSID_CNatCom) <br>{ <br>return CLASS_E_CLASSNOTAVAILABLE; <br>} <br> <br>pcf = new CNatComCF() ; <br> <br>if (!pcf) <br>{ <br>return CLASS_E_CLASSNOTAVAILABLE; <br>} <br> <br>hr = pcf-&gt;QueryInterface(riid, ppv) ; <br> <br>if (FAILED(hr)) <br>{ <br>delete pcf ; <br>return hr ; <br>} <br> <br>return S_OK ; <br>} <br> <br>//////////////////////////////////////////////////////////////////////////////// <br>// <br>//DllCanUnloadNow() <br>// <br>//returns refcount of objects which are using this .dll <br>// <br>//// <br>STDAPI DllCanUnloadNow() <br>{ <br>return g_cObject ; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
