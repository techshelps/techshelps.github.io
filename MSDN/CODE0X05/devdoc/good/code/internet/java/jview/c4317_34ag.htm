<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>JVIEW.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context4318"></a>JVIEW.CPP</h2>
<pre><code>/* <br> * jview.cpp - JView front end, including command-line parsing logic. <br> * <br> * (C) Copyright 1996, Microsoft Corporation and it suppliers. <br> */ <br> <br>#pragma hdrstop <br> <br>#include "jview.h" <br>#include "javaprop.hpp" <br> <br>// Macros <br> <br>#define WIN32_ERROR_TO_HRESULT(err)    MAKE_SCODE(SEVERITY_ERROR, FACILITY_WIN32, (err)) <br> <br>#define WIN32_RESULT_TO_HRESULT(err)   ((err) == ERROR_SUCCESS ? S_OK : WIN32_ERROR_TO_HRESULT(err)) <br> <br>#define LAST_WIN32_ERROR_TO_HRESULT()  WIN32_RESULT_TO_HRESULT(GetLastError()) <br> <br>#define APPLETVIEWER "sun.applet.AppletViewer" <br> <br>//------------------------------------------------------------------------------ <br>// LoadOemString <br>// <br>// Wrapper for the Win32 LoadString API that translates the string to the OEM <br>// character set before returning it to the caller. <br>//------------------------------------------------------------------------------ <br> <br>BOOL LoadOemString(HINSTANCE hInstance, UINT uID, LPSTR lpBuffer, int <br>    nBufferMax) <br>{ <br>    BOOL fResult; <br> <br>    fResult = LoadString(hInstance, uID, lpBuffer, nBufferMax); <br> <br>    if (fResult) <br>        CharToOem(lpBuffer, lpBuffer); <br> <br>    return fResult; <br>} <br> <br>//------------------------------------------------------------------------------ <br>// CJView::CJView: <br>//    Constructor <br>//------------------------------------------------------------------------------ <br>CJView::CJView (int ac, char **av) : m_ac (ac), m_av (av) <br>{ <br>    m_fApplet      = FALSE; <br>    m_fPause       = FALSE; <br>    m_fVerify      = FALSE; <br>    m_pszClassPath = NULL; <br>    m_pszAppend    = NULL; <br>    m_pszPrepend   = NULL; <br>    m_pszClassName = NULL; <br>    m_ppszArgs     = NULL; <br>    m_iArgs        = 0; <br>    m_pJE          = NULL; <br>    m_pProperties  = NULL; <br>} <br> <br>//------------------------------------------------------------------------------ <br>// CJView::~CJView: <br>//    Destructor <br>//------------------------------------------------------------------------------ <br>CJView::~CJView () <br>{ <br>    deleteSZ(m_pszClassPath); <br>    deleteSZ(m_pszClassName); <br>    deleteSZ(m_pszAppend); <br>    deleteSZ(m_pszPrepend); <br> <br>    if (m_ppszArgs) <br>    { <br>        INT n = 0; <br> <br>        while (m_ppszArgs[n] != NULL) <br>            delete [] m_ppszArgs[n++]; <br>        delete [] m_ppszArgs; <br>    } <br> <br>    if (m_pProperties) <br>    { <br>        m_pProperties-&gt;Release(); <br>        delete(m_pProperties); <br>    } <br> <br>    if (m_pJE) <br>    { <br>        m_pJE-&gt;Release(); <br>        CoUninitialize(); <br>    } <br>} <br> <br>//------------------------------------------------------------------------------ <br>// CJView::m_Pause: <br>// <br>// -p was given on the command line, and we have an error, thus we display <br>// amessage to the user to press a key to terminate JView, thus allowing enough <br>// time to read the message before JView termnates and the console it was <br>// running in goes away if being executed from the IDE <br>// <br>// Returns: Nothing <br>//------------------------------------------------------------------------------ <br>void CJView::m_Pause() <br>{ <br>    CHAR szText[BUFSIZE]; <br> <br>    LoadOemString(NULL, IDS_PRESSANYKEY, szText, sizeof(szText)); <br>    fprintf(stderr, "%s", szText); <br>    _getch(); <br>} <br> <br>//------------------------------------------------------------------------------ <br>// CJView::m_FatalError: <br>// <br>// Print a formatted error message to stderr <br>// <br>// Returns: Nothing <br>//------------------------------------------------------------------------------ <br>void CJView::m_FatalError <br>( <br>    INT idString, <br>    ... <br>) <br>{ <br>    CHAR szFmt[BUFSIZE]; <br>    va_list va; <br>    va_start(va, idString); <br> <br> <br>    LoadOemString(NULL, IDS_ERROR, szFmt, sizeof(szFmt)); <br>    fprintf(stderr, szFmt); <br> <br>    if (idString) <br>        LoadOemString(NULL, idString, szFmt, sizeof(szFmt)); <br>    else <br>        lstrcpy(szFmt, "%s"); <br> <br>    vfprintf(stderr, szFmt, va); <br>    va_end(va); <br>    fprintf(stderr, "\n"); <br> <br>    if (m_fPause) <br>        m_Pause(); <br>} <br> <br>//------------------------------------------------------------------------------ <br>// CJView::m_FatalErrorHR: <br>// <br>//      Print a formatted error followup by an hresult tp stderr <br>//------------------------------------------------------------------------------ <br>void CJView::m_FatalErrorHR <br>( <br>    HRESULT hr, <br>    INT     idString, <br>    ... <br>) <br>{ <br>    CHAR  szFmt[BUFSIZE]; <br>    CHAR  buf[BUFSIZE]; <br>    DWORD res; <br>    va_list va; <br>    va_start(va, idString); <br> <br>    LoadOemString(NULL, IDS_ERROR, szFmt, sizeof(szFmt)); <br>    fprintf(stderr, szFmt); <br>    LoadOemString(NULL, idString, szFmt, sizeof(szFmt)); <br>    vfprintf(stderr, szFmt, va); <br>    va_end(va); <br> <br>    res = FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, <br>                        NULL, <br>                        (DWORD)hr, <br>                        LOCALE_SYSTEM_DEFAULT, <br>                        buf, <br>                        sizeof(buf), <br>                        NULL); <br> <br>    CHAR szNoMain[BUFSIZE] = ""; <br> <br>    if (!res) <br>    { <br>        CHAR szSCODE[BUFSIZE]; <br> <br>        LoadOemString(NULL, IDS_SCODE, szSCODE, sizeof(szSCODE)); <br>        sprintf(buf, szSCODE, (DWORD)hr); <br>    } <br>    else <br>    { <br>        // Convert ANSI string returned by FormatMessage to OEM. <br>        CharToOem(buf, buf); <br> <br>        // Now we check if the error is "Member not found", and if it is, we <br>        // will append some additional info to the error message letting <br>        // the user know it was main() that could not be found, since that <br>        // is the only time this message should be generated. <br>        if (hr == DISP_E_MEMBERNOTFOUND) <br>        { <br>            CHAR sz[BUFSIZE] = ""; <br> <br>            LoadOemString(NULL, IDS_NOMAIN, sz, sizeof(sz)); <br>            sprintf(szNoMain, sz, m_pszClassName, m_pszClassName); <br>        } <br>        else <br>            *szNoMain = '\0'; <br>    } <br> <br>    fprintf(stderr, ": %s\n", buf); <br>    if (*szNoMain) <br>        fprintf(stderr, "%s", szNoMain); <br> <br>    if (m_fPause) <br>        m_Pause(); <br>} <br> <br>//------------------------------------------------------------------------------ <br>// CJView::m_InitComAndJava: <br>// <br>// Initializes COM and obtains the neccessary interfaces from the Java VM <br>// <br>// Returns: TRUE if successful, FALSE if not <br>//------------------------------------------------------------------------------ <br>BOOL CJView::m_InitComAndJava () <br>{ <br>    HRESULT           hr   = E_UNEXPECTED; <br>    IClassFactory    *pcf  = NULL; <br> <br>    hr = CoInitialize(NULL); <br> <br>    if (FAILED(hr)) <br>    { <br>        m_FatalErrorHR(hr, IDS_COULDNOTINITOLE); <br>    } <br>    else <br>    { <br>        hr = CoGetClassObject(CLSID_JavaExecute, <br>                              CLSCTX_INPROC_SERVER | <br>                              CLSCTX_INPROC_HANDLER | <br>                              CLSCTX_LOCAL_SERVER, <br>                              NULL, <br>                              IID_IClassFactory, <br>                              (LPVOID*)(&amp;pcf)); <br>        if (FAILED(hr)) <br>        { <br>            m_FatalErrorHR(hr, IDS_JAVAVM); <br>        } <br>        else <br>        { <br>            hr = pcf-&gt;CreateInstance(NULL, IID_IJavaExecute, (LPVOID *)(&amp;m_pJE)); <br>            if (FAILED(hr)) <br>            { <br>                m_pJE = NULL; <br>                m_FatalErrorHR(hr, IDS_CLASSLOADER); <br>            } <br> <br>            pcf-&gt;Release(); <br>        } <br> <br>        if (NULL == m_pJE) <br>            CoUninitialize(); <br>    } <br> <br>    return (m_pJE != NULL); <br>} <br> <br>//------------------------------------------------------------------------------ <br>// CJView::MB2WC: <br>// <br>//   Converts the multibyte string to a UNICODE string, allocating space <br>// for the destination string. <br>// <br>// Returns: Pointer to newly allocated and converted string, NULL if it fails <br>//------------------------------------------------------------------------------ <br>LPWSTR CJView::m_MB2WC <br>( <br>    LPCSTR szAnsi, <br>    int    cchAnsi <br>) <br>{ <br>   // First, determine size of converted string <br>   //-------------------------------------------------------------------------- <br>   LPWSTR pwsz    = NULL; <br>   int    cchWide = MultiByteToWideChar(0, 0, szAnsi, cchAnsi, NULL, 0) + 1; <br> <br>   if (cchWide &gt; 0) <br>   { <br>       // Got size so allocate the space and convert the string <br>       //---------------------------------------------------------------------- <br>       if (pwsz = new WCHAR[cchWide]) <br>          MultiByteToWideChar(0, 0, szAnsi, cchAnsi, pwsz, cchWide); <br>    } <br> <br>   return pwsz; <br>} <br> <br>//------------------------------------------------------------------------------ <br>// CJView::m_WC2MB: <br>// <br>//   Converts the given UNICODE string to a multibyte string, allocating space <br>// for the destination string. <br>// <br>// Returns: Pointer to newly allocated and converted string, NULL if it fails <br>//------------------------------------------------------------------------------ <br>LPSTR CJView::m_WC2MB <br>( <br>   LPCWSTR pwsz, <br>   int     cchWide <br>) <br>{ <br>   // First, determine size of converted string <br>   //-------------------------------------------------------------------------- <br>   LPSTR psz     = NULL; <br>   int   cchAnsi = WideCharToMultiByte(0, 0, pwsz, cchWide, NULL, 0, NULL, NULL); <br> <br>   if (cchAnsi &gt; 0) <br>   { <br>       // Got size so allocate the space and convert the string <br>       //---------------------------------------------------------------------- <br>      if (psz = new CHAR[cchAnsi]) <br>          WideCharToMultiByte(0, 0, pwsz, cchWide, psz, cchAnsi, NULL, NULL); <br>    } <br> <br>    return psz; <br>} <br> <br> <br>//------------------------------------------------------------------------------ <br>// CJView::m_newSZ: <br>// <br>// Allocates the given string, generating OUT OF MEMORY if it fails <br>// <br>// Returns: LPSTR to allocated buffer if successful, NULL if not <br>//------------------------------------------------------------------------------ <br>LPSTR CJView::m_newSZ <br>( <br>    int cBytes <br>) <br>{ <br>    LPSTR psz = new CHAR[cBytes + 1]; // +1 for \0 <br> <br>    if (!psz) <br>        m_FatalError(IDS_OUTOFMEMORY); <br> <br>    return psz; <br>} <br> <br>//------------------------------------------------------------------------------ <br>// CJView::m_AppendPathString <br>// <br>// Appends the given path the the other given path, allocating and freeing <br>// as neccessary <br>// <br>// Returns: TRUE if successful, FALSE if not <br>//------------------------------------------------------------------------------ <br>BOOL CJView::m_AppendPathString <br>( <br>    LPSTR *ppszPath, <br>    LPSTR  pszAppend <br>) <br>{ <br>    LPSTR psz    = NULL; <br>    BOOL  fSemi2 = *CharPrev(pszAppend, pszAppend + lstrlen(pszAppend)) != ';'; <br> <br>    if (*ppszPath) <br>    { <br>        // Been here before, so we append the given string to the given path <br>        //---------------------------------------------------------------------- <br>        if (!(psz = m_newSZ(lstrlen(*ppszPath)))) <br>            return FALSE; <br> <br>        lstrcpy(psz, *ppszPath); <br>        deleteSZ(*ppszPath); <br> <br>        BOOL fSemi1 = *CharPrev(psz, psz + lstrlen(psz)) != ';'; <br> <br>        if (!(*ppszPath = m_newSZ(lstrlen(psz) + lstrlen(pszAppend) + fSemi1 + fSemi2))) <br>        { <br>            deleteSZ(psz); <br>            return FALSE; <br>        } <br> <br>        lstrcpy(*ppszPath, psz); <br> <br>        // Add semi-colon between paths if original path did not have one <br>        //---------------------------------------------------------------------- <br>        if (fSemi1) <br>            lstrcat(*ppszPath, ";"); <br> <br>        lstrcat(*ppszPath, pszAppend); <br>        deleteSZ(psz); <br>    } <br>    else <br>    { <br>        // First time here, so copy Append string into Path <br>        //---------------------------------------------------------------------- <br>        if (!(*ppszPath = m_newSZ(lstrlen(pszAppend) + fSemi2))) <br>            return FALSE; <br> <br>        lstrcpy(*ppszPath , pszAppend); <br>    } <br> <br>    // Append final semi-colon if string being append does not have one <br>    //-------------------------------------------------------------------------- <br>    if (fSemi2) <br>        lstrcat(*ppszPath, ";"); <br> <br>    return TRUE; <br>} <br> <br>//------------------------------------------------------------------------------ <br>// CJView::m_DisplayUsage: <br>// <br>//  Displays the usage text for JView.exe <br>// <br>// Returns: Nothing <br>//------------------------------------------------------------------------------ <br>VOID CJView::m_DisplayUsage () <br>{ <br>    // NOTE: All usage lines must be sequential String <br>    //       IDS starting with IDS_USAGE1 <br>    CHAR sz[BUFSIZE]; <br>    INT  i = 0; <br> <br>    m_DisplayBanner(); <br> <br>    while (TRUE) <br>    { <br>        LoadOemString(NULL, IDS_USAGE1 + (i++), sz, sizeof(sz)); <br>        if (*sz == '~') <br>            break; <br>        printf(sz); <br>    } <br>} <br> <br>//------------------------------------------------------------------------------ <br>// CJView::m_ParseSwitches: <br>// <br>//  Parses off the switches portion of the command line <br>// <br>// Returns: TRUE if successful, FALSE if not <br>//------------------------------------------------------------------------------ <br>BOOL CJView::m_ParseSwitches <br>( <br>    int *piArg <br>) <br>{ <br>    BOOL   fSuccess = TRUE; <br>    BOOL   fReplace = m_pszClassPath != NULL; <br>    LPSTR *ppsz; <br>    LPSTR  psz; <br> <br>    *piArg = 1; <br> <br>    // We support both '-' and '/' switch designators <br>    //-------------------------------------------------------------------------- <br>    while ((*piArg &lt; m_ac) &amp;&amp; ((m_av[*piArg][0] == '-') || (m_av[*piArg][0] == '/'))) <br>    { <br>        psz = CharNext(m_av[*piArg]); <br>         <br>// Check for the -D switch prior to CharLowering the switch string. <br> <br>if ( (*psz == 'D' || *psz == 'd') &amp;&amp; (*(psz+1)==':') ) <br>        { <br>            char *pszPropStr = psz+2; <br> <br>            if ( *pszPropStr == '\0' ) <br>            { <br>                m_FatalError(IDS_INVALIDSWITCH, psz); <br>                fSuccess = FALSE; <br>                break; <br>            } <br> <br>            // If we don't already have a properties object, create one. <br>            if ( !m_pProperties ) <br>            { <br>                m_pProperties = new(CEnumJAVAPROPERTY); <br> <br>                if (!m_pProperties) <br>                { <br>                    m_FatalError(IDS_OUTOFMEMORY); <br>                    fSuccess = FALSE; <br>                    break; <br>                } <br>            } <br> <br>            // Add the property to the property enumerator. <br>            m_pProperties-&gt;Add(psz+2); <br>        } <br>else <br>{ <br>// All other switches are case insensitive, so just knock 'em down to  <br>// lowercase here. <br> <br>            CharLower(psz); <br>     <br>            // Check for usage switch first.  This is only valid as first switch <br>            //---------------------------------------------------------------------- <br>            if (*piArg == 1 &amp;&amp; lstrcmp(psz, "?") == 0) <br>            { <br>             m_DisplayUsage(); <br>                fSuccess = FALSE; <br>                break; <br>            } <br>     <br>            // Check for "run in sun.applet.AppletViewer switch" , -a <br>            if (lstrcmp(psz, "a") == 0) <br>                m_fApplet = TRUE; <br>            // Check for "pause after error switch" , -p <br>            else if (lstrcmp(psz, "p") == 0) <br>                m_fPause = TRUE; <br>            // Check for "verify all" switch, -v <br>            else if (lstrcmp(psz, "v") == 0) <br>                m_fVerify = TRUE; <br>            // Silently ignore the old "quiet" switch for compatibility with <br>            // existing scripts. <br>            else if (lstrcmp(psz, "q") == 0) <br>                ; <br>            else <br>            { <br>                // Check for classpath switches -cp, -cp:p, or -cp:a <br>                //------------------------------------------------------------------ <br>                BOOL fAppend  = FALSE; <br>                BOOL fPrepend = FALSE; <br>     <br>                if (           !lstrcmp(psz, "cp")    || <br>                   (fPrepend = !lstrcmp(psz, "cp:p")) || <br>                   (fAppend  = !lstrcmp(psz, "cp:a"))) <br>                { <br>                    // We have classpath switch, so check for path.  If not given, <br>                    // i.e, we're out of arguments, it's a bogus command line <br>                    //-------------------------------------------------------------- <br>                    if (++(*piArg) == m_ac || <br>                       (m_av[*piArg][0] == '-' || m_av[*piArg][0] == '/')) <br>                    { <br>                        // We're about to exit, so we don't have to worry about <br>                        // losing information in the ANSI to OEM conversion. <br>                        CharToOem(m_av[*piArg - 1], m_av[*piArg - 1]); <br>     <br>                        m_FatalError(IDS_NOPATHGIVEN, m_av[*piArg - 1]); <br>                        fSuccess = FALSE; <br>                        break; <br>                    } <br>     <br>                    // If we are given a class path on the command line and we also <br>                    // have a classpath from the environment variable CLASSPATH, <br>                    // the one given on the command line instructs us to ignore the <br>                    // environment variable, and we instead append/prepend other <br>                    // paths to this one instead <br>                    //-------------------------------------------------------------- <br>                    if (fReplace &amp;&amp; !(fPrepend || fAppend)) <br>                    { <br>                        deleteSZ(m_pszClassPath); <br>                        fReplace = FALSE; <br>                    } <br>     <br>                    ppsz = fPrepend ? &amp;m_pszPrepend : (fAppend ? &amp;m_pszAppend : <br>                                                                 &amp;m_pszClassPath); <br>                    m_AppendPathString(ppsz, m_av[*piArg]); <br>                } <br>                else <br>                { <br>                    // We're about to exit, so we don't have to worry about <br>                    // losing information in the ANSI to OEM conversion. <br>                    CharToOem(m_av[*piArg], m_av[*piArg]); <br>     <br>                    // Bogus switch! <br>                    m_FatalError(IDS_INVALIDSWITCH, m_av[*piArg]); <br>                    fSuccess = FALSE; <br>                    break; <br>                } <br>            } <br>        } <br> <br>        (*piArg)++; <br>    } <br> <br>    return fSuccess; <br>} <br> <br>//------------------------------------------------------------------------------ <br>// CJView::m_ParseParameters <br>// <br>// Parses off the remaining command line arguments following the class simply <br>// copying them into a list of OLESTRS <br>// <br>// Returns: TRUE if successful, FALSE if not <br>//------------------------------------------------------------------------------ <br>BOOL CJView::m_ParseParameters <br>( <br>    int iNext <br>) <br>{ <br>    // If applet or stand-alone, we need a values array <br>    //-------------------------------------------------------------------------- <br>    m_iArgs = m_ac - iNext; <br> <br>    m_ppszArgs = new LPOLESTR[m_iArgs + 1]; <br>    if (!m_ppszArgs) <br>    { <br>        m_FatalError(IDS_OUTOFMEMORY); <br>        return FALSE; <br>    } <br> <br>    (m_ppszArgs)[0] = NULL; // Initially empty! <br> <br>    // Now, run through the list of arguments and process <br>    //-------------------------------------------------------------------------- <br>    int i; <br> <br>    for (i = 0; i &lt; m_iArgs; i++) <br>    { <br>        if (!((m_ppszArgs)[i] = m_MB2WC(m_av[iNext++]))) <br>            break; <br>    } <br> <br>    // If succesful, mark end of array <br>    //-------------------------------------------------------------------------- <br>    if (i == m_iArgs) <br>    { <br>        (m_ppszArgs)[i] = NULL; <br>    } <br>    else <br>    { <br>        // Clean up if we fail <br>        //---------------------------------------------------------------------- <br>        int n; <br> <br>        for (n = 0; n &lt; i; n++) <br>            deleteSZ(m_ppszArgs[n]); <br>        deleteSZ(m_ppszArgs); <br>    } <br> <br>    return (i == m_iArgs); <br>} <br> <br>//------------------------------------------------------------------------------ <br>// CJView::ParseCommandLine: <br>// <br>//  Parses the command line, which must be in the format: <br>// <br>//  JView [switches] ClassName [Parameters] <br>// <br>//  switches:   None          :  Invoke main() <br>//              -a            :  Run as Applet <br>//              -cp   &lt;path&gt;  :  Set CLASSPATH to &lt;path. <br>//              -cp:p &lt;path&gt;  :  Prepend &lt;path&gt; to CLASSPATH <br>//              -cp:a &lt;path&gt;  :  Append  &lt;path&gt; to CLASSPATH <br>// <br>//  Classname:  Class file to run.  Valid previously compiled .JAVA file(s) <br>// <br>//  Parameters: Name=Value <br>// <br>//              if value contains spaces, value must be contained in double <br>//              quotes <br>// <br>//              Name="Value contains spaces" <br>// <br>// Returns: TRUE if successful, FALSE if not <br>//------------------------------------------------------------------------------ <br>BOOL CJView::ParseCommandLine () <br>{ <br>    // Must have at least one command line arguement of class name <br>    // Argument 0 is JVIEW itself <br>    //-------------------------------------------------------------------------- <br>    if (m_ac == 1) <br>    { <br>        m_DisplayUsage(); <br>        return FALSE; <br>    } <br> <br>    // Get current CLASSPATH from VM.  We start with this, and append, prepend, <br>    // or replace it with what we find on the command line <br>    //-------------------------------------------------------------------------- <br>    LPOLESTR psz = NULL; <br> <br>    if (m_pszClassPath = new CHAR[1]) <br>        *m_pszClassPath = 0; <br> <br>    // First thing we check for are switches, processing all arguments that <br>    // begin with "-". <br>    // NOTE: All switches must come before class name and parameters <br>    //-------------------------------------------------------------------------- <br>    INT i; <br> <br>    if (!m_ParseSwitches(&amp;i)) <br>        return FALSE; <br> <br>    // Next on the command line should be the class file to execute.  If no more <br>    // arguments, it's a bogus command line <br>    //-------------------------------------------------------------------------- <br>    BOOL fSuccess = TRUE; <br> <br>    if (i == m_ac) <br>    { <br>        m_FatalError(IDS_NOCLASSGIVEN); <br>        fSuccess = FALSE; <br>    } <br>    else <br>    { <br>        // OK, we have another argument, so whatever it is we simply treat it as <br>        // the class file name and let the VM deal with verifying it. <br>        //---------------------------------------------------------------------- <br>        if (m_pszClassName = m_newSZ(lstrlen(m_fApplet ? APPLETVIEWER : m_av[i]))) <br>        { <br>            lstrcpy(m_pszClassName, m_fApplet ? APPLETVIEWER : m_av[i++]); <br> <br>            // Finally, if we have any more arguments, they are all treated as <br>            // parameters to be used by the class <br>            //------------------------------------------------------------------ <br>            if (i &lt; m_ac) <br>                fSuccess = m_ParseParameters(i); <br>        } <br>    } <br> <br>    if (fSuccess) <br>    { <br>        // Build final path string <br>        //---------------------------------------------------------------------- <br>        if (m_pszPrepend) <br>        { <br>            if (m_pszClassPath) <br>                m_AppendPathString(&amp;m_pszPrepend, m_pszClassPath); <br>            deleteSZ(m_pszClassPath); <br>            m_pszClassPath = m_pszPrepend; <br>            m_pszPrepend   = NULL; <br>        } <br> <br>        if (m_pszAppend) <br>        { <br>            if (m_pszClassPath) <br>            { <br>                m_AppendPathString(&amp;m_pszClassPath, m_pszAppend); <br>                deleteSZ(m_pszAppend); <br>            } <br>            else <br>            { <br>                m_pszClassPath = m_pszAppend; <br>                m_pszAppend    = NULL; <br>            } <br>        } <br>    } <br> <br>    return fSuccess; <br>} <br> <br>//------------------------------------------------------------------------------ <br>// CJView::m_DisplayBanner: <br>// <br>//  Displays the banner for JView.exe <br>// <br>// Returns: Nothing <br>//------------------------------------------------------------------------------ <br>VOID CJView::m_DisplayBanner () <br>{ <br>    // Get FileVersion info <br>    //-------------------------------------------------------------------------- <br>    DWORD dwVer = 0; <br> <br>    CHAR szFile[MAX_PATH]; <br> <br>    GetModuleFileName(NULL, szFile, sizeof(szFile)); <br> <br>    VS_FIXEDFILEINFO *lpInfo; <br>    DWORD  dw; <br>    DWORD  dwSize = GetFileVersionInfoSize(szFile, &amp;dw); <br>    LPVOID lpData = (LPVOID)new CHAR[dwSize]; <br> <br>    GetFileVersionInfo(szFile, 0, dwSize, lpData); <br> <br>    // Get File Version and File Description <br>    //-------------------------------------------------------------------------- <br>    UINT ui; <br>    VerQueryValue (lpData, "\\", (LPVOID*)&amp;lpInfo, &amp;ui); <br> <br>    CHAR sz[BUFSIZE]; <br> <br>    LoadOemString(NULL, IDS_BANNER1, sz, sizeof(sz)); <br>    printf(sz, HIWORD(lpInfo-&gt;dwFileVersionMS), <br>               LOWORD(lpInfo-&gt;dwFileVersionMS), <br>               LOWORD(lpInfo-&gt;dwFileVersionLS)); <br>    LoadOemString(NULL, IDS_BANNER2, sz, sizeof(sz)); <br>    printf(sz); <br> <br>    delete lpData; <br>} <br> <br>//------------------------------------------------------------------------------ <br>// CJView::Initialize: <br>// <br>//  Performs initialization for CJView <br>// <br>// Returns: TRUE if successful, FALSE if not <br>//------------------------------------------------------------------------------ <br>BOOL CJView::Initialize () <br>{ <br>   return m_InitComAndJava(); <br>} <br> <br>//------------------------------------------------------------------------------ <br>// RunMessageLoop: <br>//      Message pump for OLE <br>// <br>//------------------------------------------------------------------------------ <br>UINT RunMessageLoop(void) <br>{ <br>    MSG msg; <br> <br>    // No accelerators to load.  Get and dispatch messages until a WM_QUIT <br>    // message is received. <br>    ZeroMemory(&amp;msg, sizeof(msg)); <br> <br>    msg.wParam = S_OK; <br> <br>    while (GetMessage(&amp;msg, NULL, 0, 0)) <br>      // <br>      // Dispatch message to target window. <br>      // <br>      // We don't have any windows, so there are no window procedures that <br>      // require TranslateMessage(&amp;msg). <br>      // <br>      DispatchMessage(&amp;msg); <br> <br>    return(msg.wParam); <br>} <br> <br>//------------------------------------------------------------------------------ <br>// CJView::SetSystemProperties: <br>// <br>// Will inform the VM of any additional system properties that we want to <br>// set. <br> <br>HRESULT CJView::SetSystemProperties() <br>{ <br>    HRESULT        hr; <br>    IJavaExecute2 *pije2; <br> <br>    // If no properties defined, bail. <br>    if ( !m_pProperties ) <br>        return S_OK; <br> <br>    // Query for the IJavaExecute2 interface off of the existing <br>    // IJavaExecute interface. <br>    if (m_pJE-&gt;QueryInterface(IID_IJavaExecute2, (LPVOID*)&amp;pije2) == S_OK) <br>    { <br>        // We found IJavaExecute2, set the system properties. <br>        hr = pije2-&gt;SetSystemProperties( (IEnumJAVAPROPERTY *)m_pProperties); <br>        pije2-&gt;Release(); <br>    } <br>    else <br>    { <br>        // If the QI failed, this current VM does not support IJavaExecute2 <br>        hr = E_FAIL; <br>        m_FatalError(IDS_PROPSNOTSUPPORTED); <br>    } <br> <br>    return hr; <br>} <br> <br>//------------------------------------------------------------------------------ <br>// CJView::ExecuteClass: <br>// <br>//  Executes the given class file <br>// <br>// Returns: result of IJavaExecute::Execute <br>//------------------------------------------------------------------------------ <br> <br>HRESULT CJView::ExecuteClass (LPERRORINFO *ppIErrorInfo) <br>{ <br>    LPOLESTR        pszClassName; <br>    LPOLESTR        pszClassPath; <br>    JAVAEXECUTEINFO jei; <br> <br>    pszClassName = m_MB2WC(m_pszClassName); <br>    pszClassPath = m_MB2WC(m_pszClassPath); <br> <br>    jei.cbSize       = sizeof(jei); <br>    jei.dwFlags      = m_fVerify ? JEIF_VERIFYCLASSES : 0; <br>    jei.pszClassName = pszClassName; <br>    jei.rgszArgs     = (LPCOLESTR *)(m_ppszArgs); <br>    jei.cArgs        = m_iArgs; <br>    jei.pszClassPath = pszClassPath; <br> <br>    HRESULT hr = m_pJE-&gt;Execute(&amp;jei, ppIErrorInfo); <br> <br>    deleteSZ(pszClassPath); <br>    deleteSZ(pszClassName); <br>    return hr; <br>} <br> <br> <br>//------------------------------------------------------------------------------ <br>// RunClassThread <br>// <br>//  Executes the given class file.  If not found, executes without .class <br>//  extension, if it has it. <br>// <br>// Returns: 0 if successful, 1 if not <br>//------------------------------------------------------------------------------ <br> <br>DWORD _stdcall RunClassThread <br>( <br>    PVOID pv <br>) <br>{ <br>    CJView* pJV     = (CJView*)pv; <br>    int     iResult = 1;            // Assume failure. <br> <br>    if (pJV-&gt;ParseCommandLine()) <br>    { <br>        HRESULT hr; <br>        LPERRORINFO     pIErrorInfo = NULL; <br> <br>        // Check for prepended path <br> <br>        int len = strlen(pJV-&gt;m_pszClassName); <br> <br>        if (len &gt; 2 &amp;&amp; (pJV-&gt;m_pszClassName[1] == ':' || strchr(pJV-&gt;m_pszClassName,'\\') != NULL)) <br>        { <br>            char *fullname = pJV-&gt;m_newSZ(MAX_PATH); <br>            char *endofpath; <br> <br>            if (GetFullPathName(pJV-&gt;m_pszClassName, MAX_PATH+1, fullname, &amp;endofpath)) <br>            { <br>                // Convert to long filename, if needed <br> <br>                WIN32_FIND_DATA findinfo; <br>                HANDLE hfind; <br> <br>                hfind = FindFirstFile(fullname, &amp;findinfo); <br> <br>                if (hfind == INVALID_HANDLE_VALUE) <br>                { <br>                    // Try appending a .class extension <br> <br>                    strcat(endofpath, ".class"); <br> <br>                    hfind = FindFirstFile(fullname, &amp;findinfo); <br>                } <br> <br>                if (hfind != INVALID_HANDLE_VALUE) <br>                { <br>                    // Split path from name <br> <br>                    *(endofpath-1) = '\0'; <br> <br>                    // Create the real class name and update length </code></pre>
<p>
</p>
<pre><code><br>                    deleteSZ(pJV-&gt;m_pszClassName); <br>                    len = lstrlen(findinfo.cFileName); <br>                    pJV-&gt;m_pszClassName = pJV-&gt;m_newSZ(len); <br>                    lstrcpy(pJV-&gt;m_pszClassName, findinfo.cFileName); <br> <br>                    // Prepend to specified path <br> <br>                    if (*pJV-&gt;m_pszClassPath == '\0') <br>                    { <br>                        deleteSZ(pJV-&gt;m_pszClassPath); <br>                        pJV-&gt;m_pszClassPath = fullname; <br>                    } <br>                    else <br>                    { <br>                        pJV-&gt;m_AppendPathString(&amp;fullname, pJV-&gt;m_pszClassPath); <br>                        deleteSZ(pJV-&gt;m_pszClassPath); <br>                        pJV-&gt;m_pszClassPath = fullname; <br>                    } <br> <br>                    FindClose(hfind); <br>                } <br>            } <br> <br>            // else let the vm deal with whatever was specified. <br>        } <br> <br>        // Check for .class extension. <br> <br>        const char classext1[] = ".cla"; <br>        const int classext1len = sizeof(classext1)-1; <br>        const char classext2[] = ".class"; <br>        const int classext2len = sizeof(classext2)-1; <br> <br>        char *classnameext = NULL; <br> <br>        if (len &gt; classext1len) <br>        { <br>            char *ext = pJV-&gt;m_pszClassName+len-classext1len; <br> <br>            if (_stricmp(ext, classext1) == 0) <br>            { <br>                // Truncate at extension. <br> <br>                *ext = '\0'; <br>                classnameext = ext; <br>            } <br>            else <br>            { <br>                // Try the full extension. <br> <br>                ext -= classext2len-classext1len; <br> <br>                if (_stricmp(ext, classext2) == 0) <br>                { <br>                    *ext = '\0'; <br>                    classnameext = ext; <br>                } <br>            } <br>        } <br> <br>        // Set any user defined system properties. <br>        hr = pJV-&gt;SetSystemProperties(); <br> <br>        if ( hr == S_OK ) <br>        { <br>            hr = pJV-&gt;ExecuteClass(&amp;pIErrorInfo); <br> <br>            if (hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) &amp;&amp; classnameext != NULL) <br>            { <br>                // Try the 1 in a billion possibility that someone is trying <br>                // to execute some class named 'class' in a package.  Of course, <br>                // if someone has a class with the same name as the package, we <br>                // hit it first above. <br> <br>                *classnameext = '.'; <br> <br>                hr = pJV-&gt;ExecuteClass(&amp;pIErrorInfo); <br>            } <br> <br>            if (!SUCCEEDED(hr)) <br>            { <br>                // We're about to exit, so we don't have to worry about <br>                // losing information in the ANSI to OEM conversion. <br>                CharToOem(pJV-&gt;m_pszClassName, pJV-&gt;m_pszClassName); <br> <br>                // Most likely .class file did not exist <br>                pJV-&gt;m_FatalErrorHR (hr, IDS_EXECUTINGCLASS, pJV-&gt;m_pszClassName); <br>                iResult = 1; <br>            } <br>            else if (pIErrorInfo) <br>            { <br>                // VM threw an exception while running the .class file.  We <br>                // get the info via the returned IErrorInfo interface <br>                BSTR bstrError = NULL; <br> <br>                if (SUCCEEDED(pIErrorInfo-&gt;GetDescription(&amp;bstrError))) <br>                { <br>                    LPSTR pszError = pJV-&gt;m_WC2MB(bstrError); <br> <br>                    if (pszError) <br>                    { <br>                        CharToOem(pszError, pszError); <br>                        pJV-&gt;m_FatalError (0, pszError); <br>                        deleteSZ(pszError); <br>                    } <br>                    else <br>                        pJV-&gt;m_FatalError (IDS_UNKNOWNERROR); <br> <br>                    SysFreeString(bstrError); <br>                } <br>                else <br>                    pJV-&gt;m_FatalError(IDS_UNKNOWNERROR); <br> <br>                iResult = 1; <br> <br>                pIErrorInfo-&gt;Release(); <br>            } <br>            else <br>              // Success. <br>              iResult = 0; <br>        } <br>    } <br> <br>    // Terminate message pump <br>    PostThreadMessage(pJV-&gt;m_dwMsgLoopThreadID, WM_QUIT, 0, 0); <br> <br>    return (DWORD)iResult; <br>} <br> <br>//------------------------------------------------------------------------------ <br>// main() - Entry point for JView <br>// <br>// Returns: 0 if successful, 1 if not <br>//------------------------------------------------------------------------------ <br> <br>#ifdef NO_CONSOLE <br>#define ENTRYPOINT int WINAPI WinMain( HINSTANCE, HINSTANCE, LPSTR, int ) <br>#else <br>#define ENTRYPOINT int __cdecl main( int, char ** ) <br>#endif <br> <br>ENTRYPOINT <br>{ <br>    int     iRet = 1; <br>    CJView* pJV  = new CJView(__argc,__argv); <br> <br>    if (!pJV) <br>    { <br>        CHAR szFmt[64]; <br> <br>        LoadOemString(NULL, IDS_ERROR, szFmt, sizeof(szFmt)); <br>        fprintf(stderr, szFmt); <br>        LoadOemString(NULL, IDS_OUTOFMEMORY, szFmt, sizeof(szFmt)); <br>        fprintf(stderr, szFmt); <br>        fprintf(stderr, "\n"); <br>        return iRet; <br>    } <br> <br>    if (pJV-&gt;Initialize()) <br>    { <br>        // OK, we're ready, everything is done on the applet thread <br>        HANDLE hth; <br>        DWORD  dwThreadID; <br> <br>        pJV-&gt;m_dwMsgLoopThreadID = GetCurrentThreadId(); <br>        hth = CreateThread(NULL, 0, &amp;RunClassThread, pJV, 0, &amp;dwThreadID); <br> <br>        if (hth) <br>        { <br>            RunMessageLoop(); <br> <br>               // If we returned from RunMessageLoop() as a result of <br>               // RunClassThread() posting the WM_QUIT message, then the thread <br>               // will be exiting shortly (if not already).  We wait for it to <br>               // terminate and grab its exit code.  1/2 second is plenty -- <br>               // if the thread doesn't die by then, something is wrong (we <br>               // got a quit message from someone else, perhaps?) in which case <br>               // we return 1 for failure. <br> <br>               if (WaitForSingleObject (hth, 500) == WAIT_OBJECT_0) <br>               { <br>                     DWORD   dwRetCode = 1; <br> <br>                     // Thread's dead, baby... thread's dead... <br>                     GetExitCodeThread (hth, &amp;dwRetCode); <br>                     iRet = dwRetCode; <br>               } <br>               CloseHandle(hth); <br>               hth = NULL; <br>        } <br>        else <br>        { <br>            pJV-&gt;m_FatalErrorHR(LAST_WIN32_ERROR_TO_HRESULT(), <br>                                IDS_NOJAVATHREAD); <br>        } <br>    } <br> <br>    delete pJV; <br>    return iRet; <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
