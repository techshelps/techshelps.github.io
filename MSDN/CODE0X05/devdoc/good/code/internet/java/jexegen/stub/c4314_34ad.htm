<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>STUB.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context4315"></a>STUB.CPP</h2>
<pre><code>/* <br> * stub.cpp <br> * <br> * Sample code. <br> *   <br> * (C) Copyright 1996, Microsoft Corporation and it suppliers. <br> */ <br> <br>#pragma hdrstop <br> <br>#include "stub.h" <br> <br>// Macros <br> <br>#define WIN32_ERROR_TO_HRESULT(err)    MAKE_SCODE(SEVERITY_ERROR, FACILITY_WIN32, (err)) <br>#define WIN32_RESULT_TO_HRESULT(err)   ((err) == ERROR_SUCCESS ? S_OK : WIN32_ERROR_TO_HRESULT(err)) <br>#define LAST_WIN32_ERROR_TO_HRESULT()  WIN32_RESULT_TO_HRESULT(GetLastError()) <br> <br>// Resource IDs for the class resource data and the main class name data. <br>// These are the IDs of the resources that jexegen will create when used <br>// with the /bindto option. <br> <br>#define CLASSRESOURCEID         1000 <br>#define MAINCLASSNAMERESOURCEID 1001 <br> <br>//------------------------------------------------------------------------------ <br>// CJView::CJView: <br>//    Constructor <br>//------------------------------------------------------------------------------ <br> <br>CJView::CJView (int ac, char **av) : m_ac (ac), m_av (av) <br>{ <br>    m_pszClassName = NULL; <br>    m_ppszArgs     = NULL; <br>    m_iArgs        = 0; <br>    m_pJE          = NULL; <br>} <br> <br>//------------------------------------------------------------------------------ <br>// CJView::~CJView: <br>//    Destructor <br>//------------------------------------------------------------------------------ <br> <br>CJView::~CJView () <br>{ <br>    if (m_ppszArgs) <br>    { <br>        INT n = 0; <br> <br>        while (m_ppszArgs[n] != NULL) <br>            delete [] m_ppszArgs[n++]; <br>        delete [] m_ppszArgs; <br>    } <br> <br>    if (m_pJE) <br>    { <br>        m_pJE-&gt;Release(); <br>        CoUninitialize(); <br>    } <br>} <br> <br>//------------------------------------------------------------------------------ <br>// CJView::m_FatalError: <br>// <br>// Print a formatted error message to stderr <br>// <br>// Returns: Nothing <br>//------------------------------------------------------------------------------ <br> <br>void CJView::m_FatalError <br>( <br>    INT idString, <br>    ... <br>) <br>{ <br>    CHAR szFmt[BUFSIZE]; <br>    va_list va; <br>    va_start(va, idString); <br> <br>    LoadString(NULL, IDS_ERROR, szFmt, sizeof(szFmt)); <br>    fprintf(stderr, szFmt); <br> <br>    if (idString) <br>        LoadString(NULL, idString, szFmt, sizeof(szFmt)); <br>    else <br>        lstrcpy(szFmt, "%s"); <br> <br>    vfprintf(stderr, szFmt, va); <br>    va_end(va); <br>    fprintf(stderr, "\n"); <br>} <br> <br>//------------------------------------------------------------------------------ <br>// CJView::m_FatalErrorHR: <br>// <br>//      Print a formatted error followup by an hresult tp stderr <br>//------------------------------------------------------------------------------ <br> <br>void CJView::m_FatalErrorHR <br>( <br>    HRESULT hr, <br>    INT     idString, <br>    ... <br>) <br>{ <br>    CHAR  szFmt[BUFSIZE]; <br>    CHAR  buf[BUFSIZE]; <br>    DWORD res; <br>    va_list va; <br>    va_start(va, idString); <br> <br>    LoadString(NULL, IDS_ERROR, szFmt, sizeof(szFmt)); <br>    fprintf(stderr, szFmt); <br>    LoadString(NULL, idString, szFmt, sizeof(szFmt)); <br>    vfprintf(stderr, szFmt, va); <br>    va_end(va); <br> <br>    res = FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, <br>                        NULL, <br>                        (DWORD)hr, <br>                        LOCALE_SYSTEM_DEFAULT, <br>                        buf, <br>                        sizeof(buf), <br>                        NULL); <br> <br>    CHAR szNoMain[BUFSIZE] = ""; <br> <br>    if (!res) <br>    { <br>        CHAR szSCODE[BUFSIZE]; <br> <br>        LoadString(NULL, IDS_SCODE, szSCODE, sizeof(szSCODE)); <br>        sprintf(buf, szSCODE, (DWORD)hr); <br>    } <br>    else <br>    { <br>        // Now we check if the error is "Member not found", and if it is, we <br>        // will append some additional info to the error message letting <br>        // the user know it was main() that could not be found, since that <br>        // is the only time this message should be generated. <br>         <br>        if (hr == DISP_E_MEMBERNOTFOUND) <br>        { <br>            CHAR sz[BUFSIZE] = ""; <br> <br>            LoadString(NULL, IDS_NOMAIN, sz, sizeof(sz)); <br>            sprintf(szNoMain, sz, m_pszClassName, m_pszClassName); <br>        } <br>        else <br>            *szNoMain = '\0'; <br>    } <br> <br> <br>    fprintf(stderr, ": %s\n", buf); <br>    if (*szNoMain) <br>        fprintf(stderr, "%s", szNoMain); <br>} <br> <br>//------------------------------------------------------------------------------ <br>// CJView::m_InitComAndJava: <br>// <br>// Initializes COM and obtains the neccessary interfaces from the Java VM <br>// <br>// Returns: TRUE if successful, FALSE if not <br>//------------------------------------------------------------------------------ <br> <br>BOOL CJView::m_InitComAndJava () <br>{ <br>    HRESULT           hr   = E_UNEXPECTED; <br>    IClassFactory    *pcf  = NULL; <br> <br>    hr = CoInitialize(NULL); <br> <br>    if (FAILED(hr)) <br>    { <br>        m_FatalErrorHR(hr, IDS_COULDNOTINITOLE); <br>    } <br>    else <br>    { <br>        hr = CoGetClassObject(CLSID_JavaExecute, <br>                              CLSCTX_INPROC_SERVER | <br>                              CLSCTX_INPROC_HANDLER | <br>                              CLSCTX_LOCAL_SERVER, <br>                              NULL, <br>                              IID_IClassFactory, <br>                              (LPVOID*)(&amp;pcf)); <br>        if (FAILED(hr)) <br>        { <br>            m_FatalErrorHR(hr, IDS_JAVAVM); <br>        } <br>        else <br>        { <br>            hr = pcf-&gt;CreateInstance(NULL, IID_IJavaExecute2, (LPVOID *)(&amp;m_pJE)); <br>            if (FAILED(hr)) <br>            { <br>                m_pJE = NULL; <br>                m_FatalErrorHR(hr, IDS_CLASSLOADER); <br>            } <br> <br>            pcf-&gt;Release(); <br>        } <br> <br>        if (NULL == m_pJE) <br>            CoUninitialize(); <br>    } <br> <br>    return (m_pJE != NULL); <br>} <br> <br>//------------------------------------------------------------------------------ <br>// CJView::MB2WC: <br>// <br>//   Converts the multibyte string to a UNICODE string, allocating space <br>// for the destination string. <br>// <br>// Returns: Pointer to newly allocated and converted string, NULL if it fails <br>//------------------------------------------------------------------------------ <br> <br>LPWSTR CJView::m_MB2WC <br>( <br>    LPCSTR szAnsi, <br>    int    cchAnsi <br>) <br>{ <br>   // First, determine size of converted string <br>   LPWSTR pwsz    = NULL; <br>   int    cchWide = MultiByteToWideChar(0, 0, szAnsi, cchAnsi, NULL, 0) + 1; <br> <br>   if (cchWide &gt; 0) <br>   { <br>       // Got size so allocate the space and convert the string <br>       if (pwsz = new WCHAR[cchWide]) <br>          MultiByteToWideChar(0, 0, szAnsi, cchAnsi, pwsz, cchWide); <br>    } <br> <br>   return pwsz; <br>} <br> <br>//------------------------------------------------------------------------------ <br>// CJView::m_WC2MB: <br>// <br>//   Converts the given UNICODE string to a multibyte string, allocating space <br>// for the destination string. <br>// <br>// Returns: Pointer to newly allocated and converted string, NULL if it fails <br>//------------------------------------------------------------------------------ <br> <br>LPSTR CJView::m_WC2MB <br>( <br>   LPCWSTR pwsz, <br>   int     cchWide <br>) <br>{ <br>   // First, determine size of converted string <br>   LPSTR psz     = NULL; <br>   int   cchAnsi = WideCharToMultiByte(0, 0, pwsz, cchWide, NULL, 0, NULL, NULL); <br> <br>   if (cchAnsi &gt; 0) <br>   { <br>       // Got size so allocate the space and convert the string <br>      if (psz = new CHAR[cchAnsi]) <br>          WideCharToMultiByte(0, 0, pwsz, cchWide, psz, cchAnsi, NULL, NULL); <br>    } <br> <br>    return psz; <br>} <br> <br>//------------------------------------------------------------------------------ <br>// CJView::m_ParseParameters <br>// <br>// Parses off the command line arguments following the class simply <br>// copying them into a list of OLESTRS <br>// <br>// Returns: TRUE if successful, FALSE if not <br>//------------------------------------------------------------------------------ <br> <br>BOOL CJView::m_ParseParameters() <br>{ <br>    m_iArgs = m_ac - 1; <br> <br>    m_ppszArgs = new LPOLESTR[m_iArgs + 1]; <br>    if (!m_ppszArgs) <br>    { <br>        m_FatalError(IDS_OUTOFMEMORY); <br>        return FALSE; <br>    } <br> <br>    (m_ppszArgs)[0] = NULL; // Initially empty! <br> <br>    // Now, run through the list of arguments and process <br>    int iNext = 1; <br>    int i; <br> <br>    for (i = 0; i &lt; m_iArgs; i++) <br>    { <br>        if (!((m_ppszArgs)[i] = m_MB2WC(m_av[iNext++]))) <br>            break; <br>    } <br> <br>    // If succesful, mark end of array <br>    if (i == m_iArgs) <br>    { <br>        (m_ppszArgs)[i] = NULL; <br>    } <br>    else <br>    { <br>        // Clean up if we fail <br>        int n; <br> <br>        for (n = 0; n &lt; i; n++) <br>            deleteSZ(m_ppszArgs[n]); <br>        deleteSZ(m_ppszArgs); <br>    } <br> <br>    return (i == m_iArgs); <br>} <br> <br>//------------------------------------------------------------------------------ <br> <br>BOOL CJView::LoadDataResource( DWORD dwResID, BYTE *pBuffer, DWORD *pdwSize ) <br>{ <br>   HMODULE hMod = GetModuleHandle(NULL); <br>   DWORD   dwBufferSize; <br>   HRSRC   hRes; <br>   HANDLE  hLoadedRes; <br>   PVOID   pData; <br>    <br>   if ( !pdwSize || !pBuffer ) <br>      return FALSE; <br> <br>   dwBufferSize = *pdwSize; <br>   *pdwSize = 0; <br>    <br>   hRes = FindResource( hMod, MAKEINTRESOURCE(dwResID), RT_RCDATA ); <br> <br>   if ( hRes == NULL ) <br>      return FALSE; <br> <br>   *pdwSize = SizeofResource( hMod, hRes ); <br> <br>   if ( dwBufferSize &lt; *pdwSize ) <br>      return FALSE; <br> <br>   hLoadedRes = LoadResource( hMod, hRes ); <br> <br>   if ( !hLoadedRes ) <br>      return FALSE; <br> <br>   pData = LockResource( hLoadedRes ); <br> <br>   CopyMemory( pBuffer, pData, *pdwSize ); <br> <br>   FreeResource( hLoadedRes ); <br>    <br>   return TRUE; <br>} <br> <br>//------------------------------------------------------------------------------ <br>// CJView::Initialize: <br>// <br>//  Performs initialization for CJView <br>// <br>// Returns: TRUE if successful, FALSE if not <br>//------------------------------------------------------------------------------ <br> <br>BOOL CJView::Initialize () <br>{ <br>   // Load the name of the main class file to <br>   // execute. <br>    <br>   char  szBuffer[1024]; <br>   DWORD dwSize = sizeof(szBuffer); <br> <br>   if ( !LoadDataResource( MAINCLASSNAMERESOURCEID, (BYTE *)szBuffer, &amp;dwSize ) ) <br>   {   <br>      m_FatalError( IDS_NOCLASSGIVEN ); <br>      return FALSE; <br>   } <br>    <br>   m_pszClassName = new char[ lstrlen(szBuffer) + 1]; <br> <br>   if ( !m_pszClassName ) <br>   { <br>      m_FatalError( IDS_OUTOFMEMORY ); <br>      return FALSE; <br>   } <br> <br>   lstrcpy( m_pszClassName, szBuffer ); <br> <br>   return m_InitComAndJava(); <br>} <br> <br>//------------------------------------------------------------------------------ <br>// RunMessageLoop: <br>//      Message pump for OLE <br>//------------------------------------------------------------------------------ <br> <br>UINT RunMessageLoop(void) <br>{ <br>    MSG msg; <br> <br>    // No accelerators to load.  Get and dispatch messages until a WM_QUIT <br>    // message is received. <br>    ZeroMemory(&amp;msg, sizeof(msg)); <br> <br>    msg.wParam = S_OK; <br> <br>    while (GetMessage(&amp;msg, NULL, 0, 0)) <br>      // <br>      // Dispatch message to target window. <br>      // <br>      // We don't have any windows, so there are no window procedures that <br>      // require TranslateMessage(&amp;msg). <br>      // <br>      DispatchMessage(&amp;msg); <br> <br>    return(msg.wParam); <br>} <br> <br>//------------------------------------------------------------------------------ <br>// CJView::ExecuteClass: <br>// <br>//  Executes the given class file <br>// <br>// Returns: 0 if successful, 1 if not <br>//------------------------------------------------------------------------------ <br> <br>DWORD _stdcall RunClassThread <br>( <br>    PVOID pv <br>) <br>{ <br>    CJView* pJV     = (CJView*)pv; <br>    HRESULT hr; <br>    int     iResult; <br> <br>    if ( pJV-&gt;m_ParseParameters() ) <br>    { <br>        // Tell the VM that it should look in the current module for  <br>        // class files.  The /bindto option of the jexegen tool will  <br>        // place the resource data in the exe with a resource ID of  <br>        // 1001 so we tell the VM that is where the data is. <br>     <br>        JAVACLASSRESOURCEINFO jcri; <br>        jcri.hModule      = GetModuleHandle(NULL); <br>        jcri.dwResourceID = CLASSRESOURCEID;     // Compatible with jexegen. <br>       <br>        hr = pJV-&gt;m_pJE-&gt;SetClassSource( CLASS_SOURCE_TYPE_MODULERESOURCES,  <br>                                         &amp;jcri,  <br>                                         sizeof(JAVACLASSRESOURCEINFO) ); <br> <br>        if ( !SUCCEEDED(hr) ) <br>        { <br>           pJV-&gt;m_FatalError( IDS_VMCANTFINDRESOURCE ); <br>           return 0; <br>        } <br>         <br>        // Execute. <br>        LPOLESTR        pszClassName = pJV-&gt;m_MB2WC(pJV-&gt;m_pszClassName); <br>        LPERRORINFO     pIErrorInfo = NULL; <br>        JAVAEXECUTEINFO jei; <br> <br>        jei.cbSize       = sizeof(jei); <br>        jei.dwFlags      = 0; <br>        jei.pszClassName = pszClassName; <br>        jei.rgszArgs     = (LPCOLESTR *)(pJV-&gt;m_ppszArgs); <br>        jei.cArgs        = pJV-&gt;m_iArgs; <br>        jei.pszClassPath = NULL; <br> <br>        hr = pJV-&gt;m_pJE-&gt;Execute(&amp;jei, &amp;pIErrorInfo); <br> <br>        if (!SUCCEEDED(hr)) <br>        { <br>            // Most likely .class file did not exist <br>            pJV-&gt;m_FatalErrorHR (hr, IDS_EXECUTINGCLASS, pJV-&gt;m_pszClassName); <br>            iResult = 1; <br>        } <br>        else if (pIErrorInfo) <br>        { <br>            // VM threw an exception while running the .class file.  We <br>            // get the info via the returned IErrorInfo interface <br>            BSTR bstrError = NULL; <br> <br>            if (SUCCEEDED(pIErrorInfo-&gt;GetDescription(&amp;bstrError))) <br>            { <br>                LPSTR pszError = pJV-&gt;m_WC2MB(bstrError); <br> <br>                if (pszError) <br>                { <br>                    pJV-&gt;m_FatalError (0, pszError); <br>                    deleteSZ(pszError); <br>                } <br>                else <br>                    pJV-&gt;m_FatalError (IDS_UNKNOWNERROR); <br> <br>                SysFreeString(bstrError); <br>            } <br>            else <br>                pJV-&gt;m_FatalError(IDS_UNKNOWNERROR); <br> <br>            iResult = 1; <br> <br>            pIErrorInfo-&gt;Release(); <br>        } <br>        else <br>            // Success. <br>            iResult = 0; <br> <br>        deleteSZ(pszClassName); <br>    } <br>    else <br>        iResult = 1; <br> <br>    // Terminate message pump <br>    PostThreadMessage(pJV-&gt;m_dwMsgLoopThreadID, WM_QUIT, 0, 0); <br> <br>    return (DWORD)iResult; <br>} <br> <br>//------------------------------------------------------------------------------ <br> <br>int __cdecl main <br>( <br>    int    ac, <br>    char **av <br>) <br>{ <br>    int     iRet = 1; <br>    CJView* pJV  = new CJView(ac, av); <br> <br>    if ( !pJV ) <br>    { <br>        CHAR szFmt[20]; <br> <br>        LoadString(NULL, IDS_ERROR, szFmt, sizeof(szFmt)); <br>        fprintf(stderr, szFmt); <br>        LoadString(NULL, IDS_OUTOFMEMORY, szFmt, sizeof(szFmt)); <br>        fprintf(stderr, szFmt); <br>        fprintf(stderr, "\n"); <br>        return iRet; <br>    } <br> <br>    if (pJV-&gt;Initialize()) <br>    { <br>        // OK, we're ready, everything is done on the applet thread <br>        HANDLE hth; <br>        DWORD  dwThreadID; <br> <br>        pJV-&gt;m_dwMsgLoopThreadID = GetCurrentThreadId(); <br>        hth = CreateThread(NULL, 0, &amp;RunClassThread, pJV, 0, &amp;dwThreadID); <br> <br>        if (hth) <br>        { <br>            RunMessageLoop(); <br> <br>            // If we returned from RunMessageLoop() as a result of <br>            // RunClassThread() posting the WM_QUIT message, then the thread <br>            // will be exiting shortly (if not already).  We wait for it to <br>            // terminate and grab its exit code.  1/2 second is plenty -- <br>            // if the thread doesn't die by then, something is wrong (we <br>            // got a quit message from someone else, perhaps?) in which case <br>            // we return 1 for failure. <br> <br>            if (WaitForSingleObject (hth, 500) == WAIT_OBJECT_0) <br>            { <br>                DWORD   dwRetCode = 1; <br> <br>                // Thread's dead, baby... thread's dead... <br>                GetExitCodeThread (hth, &amp;dwRetCode); <br>                iRet = dwRetCode; <br>            } <br>            CloseHandle(hth); <br>            hth = NULL; <br>        } <br>        else <br>        { <br>            pJV-&gt;m_FatalErrorHR(LAST_WIN32_ERROR_TO_HRESULT(), <br>                                IDS_NOJAVATHREAD); <br>        } <br>    } <br> <br>    delete pJV; <br>    return iRet; <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
