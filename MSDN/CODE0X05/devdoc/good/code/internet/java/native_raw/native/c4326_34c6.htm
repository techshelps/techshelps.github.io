<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>NATLIB.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context4326"></a>NATLIB.C</h2>
<pre><code><br>/* <br> <br>Copyright (c) 1996-1997  Microsoft Corporation <br> <br>*/ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;native.h&gt; <br>#include "JMain.h" <br>#include "JFoo.h" <br>#include "JThread1.h" <br>#include "JThread2.h" <br> <br>//////////////////////////////////////////////////////////////////////////////// <br>// <br>//RNIGetCompatibleVersion <br>// <br>//Called by the virtual machine to determine what level of RNI compatibility <br>//this DLL offers. <br>// <br>//// <br>DWORD __cdecl RNIGetCompatibleVersion() <br>{ <br>return RNIVER; <br>} <br> <br>//////////////////////////////////////////////////////////////////////////////// <br>// <br>//JMain_Square() <br>// <br>//returns the square of its parameter;  simple callout from java to <br>//native code to perform this operation. <br>// <br>//// <br>__declspec(dllexport) long __cdecl JMain_Square(struct HJMain *pThis, long lVal) <br>{ <br>return lVal * lVal ; <br>} <br> <br>//////////////////////////////////////////////////////////////////////////////// <br>// <br>//JMain_DoubleInstanceVar() <br>// <br>//executes a java-implemented method to retrieve the value of an <br>//instance variable;  returns twice the retrieved value. <br>// <br>//// <br>__declspec(dllexport) void __cdecl JMain_DoubleInstanceVar(struct HJMain *pThis) <br>{ <br>long lVal ; <br> <br>lVal = execute_java_dynamic_method(0, (HObject*) pThis, "GetiVar1", "()I") ; <br> <br>pThis-&gt;iVar1 = lVal &lt;&lt; 1 ; <br>} <br> <br>//////////////////////////////////////////////////////////////////////////////// <br>// <br>//Jmain_showMemberArray() <br>// <br>//executes a class method which returns a private member array of <br>//ints (java); loops through and displays the array members. <br>// <br>//// <br>__declspec(dllexport) void __cdecl JMain_showMemberArray(struct HJMain *pThis) <br>{ <br>ClassArrayOfInt *paiVar1 ; <br>long*plVar2 ; <br>intcIndex ; <br> <br>// get a pointer to an instance array of int, and display it. <br>paiVar1 = (ClassArrayOfInt *) execute_java_dynamic_method(0, (HObject *) pThis, "GetiCVar2", "()[I") ; <br>plVar2 = paiVar1-&gt;body ; <br> <br>for (cIndex = 0; cIndex &lt; paiVar1-&gt;length; cIndex++) <br>{ <br>printf("%5d", *plVar2++) ; <br>} <br>printf("\n") ; <br>} <br> <br>//////////////////////////////////////////////////////////////////////////////// <br>// <br>//JMain_Various() <br>// <br>//finds JFoo class; executes a static method in that class <br>// <br>//// <br>__declspec(dllexport) void __cdecl JMain_Various(struct HJMain *pThis) <br>{ <br>_int64 i64Val = 10 ; <br>ClassClass *pcls = FindClass(NULL, "JFoo", TRUE) ; <br> <br>if (pcls) <br>{ <br>// and exec the static method <br>execute_java_static_method(NULL, pcls, "StaticMethod", "(J)V", i64Val) ; <br>} <br>} <br> <br>//////////////////////////////////////////////////////////////////////////////// <br>// <br>//w32CreateEvent() <br>// <br>//wrapper for win32 API CreateEvent() <br>// <br>//// <br>__declspec(dllexport) long __cdecl JMain_w32CreateEvent(struct HJMain *pThis, long bInit) <br>{ <br>BOOLbInitialState ; <br>HANDLEhEvent ; <br> <br>// determine if initial state is signaled or non-signaled. <br>if (bInit) <br>{ <br>bInitialState = TRUE ; <br>} <br>else <br>{ <br>bInitialState = FALSE ; <br>} <br> <br>// create Event object and return handle <br>return (long) CreateEvent(NULL, FALSE, bInitialState, NULL) ; <br>} <br> <br>//////////////////////////////////////////////////////////////////////////////// <br>// <br>//w32PulseEvent() <br>// <br>//wrapper for win32 API PulseEvent() <br>// <br>//// <br>__declspec(dllexport) void __cdecl JThread1_w32PulseEvent(struct HJThread1 *pThis,long hEvent) <br>{ <br>PulseEvent((HANDLE) hEvent) ; <br>} <br> <br>//////////////////////////////////////////////////////////////////////////////// <br>// <br>//w32CloseHandle() <br>// <br>//wrapper for win32 API CloseHandle() <br>// <br>//// <br>__declspec(dllexport) long __cdecl JThread2_w32CloseHandle(struct HJThread2 *pThis, long hObject) <br>{ <br>return (long) CloseHandle((HANDLE) hObject) ; <br>} <br> <br>//////////////////////////////////////////////////////////////////////////////// <br>// <br>//GCSafeNative() <br>// <br>//method demonstrates GC safe way of performing GC-sensitive operations <br>//in native code. <br>// <br>//// <br>__declspec(dllexport) void __cdecl JThread2_GCSafeNative(struct HJThread2 *pThis, long hEvent) <br>{ <br>struct <br>{ <br>HJFoo *pJFoo1, *pJFoo2 ; <br>} gcSafe ;// struct holds out pointers to JObjects <br>GCFrame gcf ; <br> <br>// GCFramePush() creates storage for GC-sensitive data (JObjects in this case) <br>GCFramePush(&amp;gcf, &amp;gcSafe, sizeof(gcSafe)) ; <br> <br>// set our member variables to point to two JObjects <br>gcSafe.pJFoo1 = (HJFoo *) execute_java_constructor(0, "JFoo", 0, "(I)", 10) ; <br>gcSafe.pJFoo2 = (HJFoo *) execute_java_constructor(0, "JFoo", 0, "()") ; <br> <br>// call GCEnable() - we don't know how long we might be blocked <br>GCEnable() ; <br> <br>// block <br>WaitForSingleObject((HANDLE) hEvent, INFINITE) ; <br> <br>// display instance variable values for above-created JObjects. <br>printf("gcSafe.pJFoo1-&gt;m_iVal = %d\tgcSafe.pJFoo2-&gt;m_iVal = %d\n", gcSafe.pJFoo1-&gt;m_iVal, gcSafe.pJFoo2-&gt;m_iVal) ; <br> <br>// disable GC and pop our storage <br>GCDisable() ; <br>GCFramePop(&amp;gcf) ; <br>} <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
