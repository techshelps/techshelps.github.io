<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>NOTIFY.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context4335"></a>NOTIFY.CPP</h2>
<pre><code>#include "Notify.h" <br> <br> <br>//========================================================================== <br>// <br>//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY <br>//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE <br>//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR <br>//  PURPOSE. <br>// <br>//  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved. <br>// <br>//-------------------------------------------------------------------------- <br>// <br>// AgentNotifySink <br>// <br>//Boilerplate IDispatch implementation with stubs for all  <br>//IAgentNotifySink methods except for RequestComplete. <br>// <br>//========================================================================== <br> <br> <br>extern long g_lDone; <br> <br> <br>// IUnknown methods <br> <br>STDMETHODIMP AgentNotifySink::QueryInterface (REFIID riid, LPVOID *ppv) { <br> <br>    *ppv = NULL; <br> <br>    if ((riid == IID_IUnknown) || (riid == IID_IAgentNotifySink)) <br>        *ppv = this; <br> <br>    if (*ppv == NULL) <br>        return E_NOINTERFACE; <br> <br>    ((LPUNKNOWN)*ppv)-&gt;AddRef(); <br> <br>    return NOERROR; <br>} <br> <br> <br>STDMETHODIMP_ (ULONG) AgentNotifySink::AddRef() { <br> <br>return ++m_cRefs; <br>} <br> <br> <br>STDMETHODIMP_(ULONG) AgentNotifySink::Release() { <br> <br>if (--m_cRefs != 0) <br>return m_cRefs; <br> <br>delete this; <br>return 0; <br>} <br> <br> <br>// IDispatch methods <br> <br>STDMETHODIMP AgentNotifySink::GetTypeInfoCount(UINT *pctInfo) { <br> <br>    *pctInfo = 1; <br>    return NOERROR; <br>} <br> <br> <br>STDMETHODIMP AgentNotifySink::GetTypeInfo(UINT itInfo, LCID lcid, ITypeInfo **ppTypeInfo) { <br> <br>    HRESULT hRes; <br>    ITypeLib *pLib; <br> <br>    *ppTypeInfo = NULL; <br> <br>if (itInfo != 0) <br>        return TYPE_E_ELEMENTNOTFOUND; <br> <br>    if (ppTypeInfo == NULL) <br>        return E_POINTER; <br> <br>if ((PRIMARYLANGID(lcid) != LANG_NEUTRAL) &amp;&amp;  <br>(PRIMARYLANGID(lcid) != LANG_ENGLISH)) <br>return DISP_E_UNKNOWNLCID; <br> <br>    hRes = LoadRegTypeLib(LIBID_AgentServerObjects,  <br>  1,  <br>  0, <br>  PRIMARYLANGID(lcid),  <br>  &amp;pLib); <br>    if (FAILED(hRes)) <br>        return hRes; <br> <br>hRes = pLib-&gt;GetTypeInfoOfGuid(IID_IAgentNotifySink, ppTypeInfo); <br>         <br>pLib-&gt;Release(); <br> <br>    if (FAILED(hRes)) <br>        return hRes; <br> <br>    (*ppTypeInfo)-&gt;AddRef(); <br> <br>    return NOERROR; <br>} <br> <br> <br>STDMETHODIMP AgentNotifySink::GetIDsOfNames(REFIID riid, OLECHAR **rgszNames, UINT cNames, LCID lcid, DISPID *rgDispID) { <br> <br>    HRESULT hRes; <br>    ITypeInfo *pInfo; <br> <br>// REFIID must be NULL <br> <br>if (riid != IID_NULL) <br>        return ResultFromScode(DISP_E_UNKNOWNINTERFACE); <br> <br>// Get the TypeInfo for the specified lcid <br> <br>    hRes = GetTypeInfo(0, lcid, &amp;pInfo); <br> <br>if (FAILED(hRes)) <br>return hRes; <br> <br>// Use the TypeInfo to get the DISPIDs of the specified names. <br>// That's the whole point here.  Let TypeInfo do the work so <br>// we don't have to. <br> <br>hRes = pInfo-&gt;GetIDsOfNames(rgszNames, cNames, rgDispID); <br> <br>pInfo-&gt;Release(); <br> <br>    return hRes; <br>} <br> <br> <br>STDMETHODIMP AgentNotifySink::Invoke(DISPID dispID, REFIID riid, LCID lcid,  <br> unsigned short wFlags, DISPPARAMS *pDispParams,  <br> VARIANT *pVarResult, EXCEPINFO *pExcepInfo,  <br> UINT *puArgErr) { <br> <br>HRESULT hRes; <br>ITypeInfo *pInfo; <br> <br>    // The riid parameter is always supposed to be IID_NULL <br> <br>if (riid != IID_NULL) <br>        return DISP_E_UNKNOWNINTERFACE; <br> <br>// Get the type info for the specified lcid <br> <br>    hRes = GetTypeInfo(0, lcid, &amp;pInfo); <br> <br>    if (FAILED(hRes)) <br>        return hRes; <br> <br>    // Clear exceptions <br> <br>    SetErrorInfo(0L, NULL); <br> <br>hRes = pInfo-&gt;Invoke(this,  <br> dispID,  <br> wFlags,  <br> pDispParams,  <br> pVarResult,  <br> pExcepInfo,  <br> puArgErr); <br> <br> <br>    pInfo-&gt;Release(); <br> <br>    return hRes; <br>} <br> <br> <br>// IAgentNotifySink methods <br> <br>STDMETHODIMP AgentNotifySink::Command(long dwCommandID, IUnknown * punkUserInput) { <br> <br>return NOERROR; <br>} <br> <br> <br>STDMETHODIMP AgentNotifySink::ActivateInputState(long dwCharID, long bActivated) { <br> <br>return NOERROR; <br>} <br> <br> <br>STDMETHODIMP AgentNotifySink::Restart() { <br> <br>return NOERROR; <br>} <br> <br> <br>STDMETHODIMP AgentNotifySink::Shutdown() { <br> <br>return NOERROR; <br>} <br> <br> <br>STDMETHODIMP AgentNotifySink::VisibleState(long dwCharID, long bVisible, long lCause) { <br> <br>return NOERROR; <br>} <br> <br> <br>STDMETHODIMP AgentNotifySink::Click(long dwCharID, short fwKeys, long X, long Y) { <br> <br>return NOERROR; <br>} <br> <br> <br>STDMETHODIMP AgentNotifySink::DblClick(long dwCharID, short fwKeys, long X, long Y) { <br> <br>return NOERROR; <br>} <br> <br> <br>STDMETHODIMP AgentNotifySink::DragStart(long dwCharID, short fwKeys, long X, long Y) { <br> <br>return NOERROR; <br>} <br> <br> <br>STDMETHODIMP AgentNotifySink::DragComplete(long dwCharID, short fwKeys, long X, long Y) { <br> <br>return NOERROR; <br>} <br> <br> <br>STDMETHODIMP AgentNotifySink::RequestStart(long dwRequestID) { <br> <br>return NOERROR; <br>} <br> <br> <br>STDMETHODIMP AgentNotifySink::RequestComplete(long dwRequestID, long hrStatus) { <br> <br>// When we get g_lDone exit the sample app <br> <br>if (dwRequestID == g_lDone) <br>PostQuitMessage(0); <br> <br>return NOERROR; <br>} <br> <br> <br>STDMETHODIMP AgentNotifySink::BookMark(long dwBookMarkID) { <br> <br>return NOERROR; <br>} <br> <br> <br>STDMETHODIMP AgentNotifySink::Idle(long dwCharID, long bStart) { <br> <br>return NOERROR; <br>} <br> <br> <br>STDMETHODIMP AgentNotifySink::Move(long dwCharID, long X, long Y, long lCause) { <br> <br>return NOERROR; <br>} <br> <br> <br>STDMETHODIMP AgentNotifySink::Size(long dwCharID, long lWidth, long lHeight) { <br> <br>return NOERROR; <br>} <br> <br> <br>STDMETHODIMP AgentNotifySink::BalloonVisibleState(long dwCharID, long bVisible) { <br> <br>return NOERROR; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
