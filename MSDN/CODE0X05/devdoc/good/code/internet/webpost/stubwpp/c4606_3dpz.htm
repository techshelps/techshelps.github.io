<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>ATLCOM.H</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context4607"></a>ATLCOM.H</h2>
<pre><code>// This is a part of the Active Template Library. <br>// Copyright (C) 1996-1997 Microsoft Corporation <br>// All rights reserved. <br>// <br>// This source code is only intended as a supplement to the <br>// Active Template Library Reference and related <br>// electronic documentation provided with the library. <br>// See these sources for detailed information regarding the <br>// Active Template Library product. <br> <br>#ifndef __ATLCOM_H__ <br>#define __ATLCOM_H__ <br> <br>#ifndef __cplusplus <br>#error ATL requires C++ compilation (use a .cpp suffix) <br>#endif <br> <br>#ifndef __ATLBASE_H__ <br>#error atlcom.h requires atlbase.h to be included first <br>#endif <br> <br>#pragma pack(push, _ATL_PACKING) <br> <br>#ifndef ATL_NO_NAMESPACE <br>namespace ATL <br>{ <br>#endif <br> <br>#define CComConnectionPointContainerImpl IConnectionPointContainerImpl <br>#define CComISupportErrorInfoImpl ISupportErrorInfoImpl <br>#define CComProvideClassInfo2Impl IProvideClassInfoImpl <br>#define CComDualImpl IDispatchImpl <br> <br>#ifdef _ATL_DEBUG_QI <br>HRESULT WINAPI AtlDumpIID(REFIID iid, LPCTSTR pszClassName, HRESULT hr); <br>#define _ATLDUMPIID(iid, name, hr) AtlDumpIID(iid, name, hr) <br>#else <br>#define _ATLDUMPIID(iid, name, hr) hr <br>#endif <br> <br>#ifdef _ATL_DEBUG_REFCOUNT <br>////////////////////////////////////////////////////////////////////////////// <br>// CComDebugRefCount for interface level ref counting <br>class CComDebugRefCount <br>{ <br>public: <br>CComDebugRefCount() <br>{ <br>m_nRef = 0; <br>} <br>~CComDebugRefCount() <br>{ <br>_ASSERTE(m_nRef == 0); <br>} <br>long m_nRef; <br>}; <br>#define _ATL_DEBUG_ADDREF_RELEASE_IMPL(className) \ <br>public:\ <br>CComDebugRefCount _ref;\ <br>virtual ULONG STDMETHODCALLTYPE _DebugAddRef(void) \ <br>{return ((T*)this)-&gt;DebugAddRef(_ref.m_nRef, _T(#className));} \ <br>virtual ULONG STDMETHODCALLTYPE _DebugRelease(void) \ <br>{return ((T*)this)-&gt;DebugRelease(_ref.m_nRef, _T(#className));} <br>#else <br>#define _ATL_DEBUG_ADDREF_RELEASE_IMPL(className)\ <br>virtual ULONG STDMETHODCALLTYPE AddRef(void) = 0;\ <br>virtual ULONG STDMETHODCALLTYPE Release(void) = 0; <br>#endif // _ATL_DEBUG_REFCOUNT <br> <br> <br>HRESULT WINAPI AtlReportError(const CLSID&amp; clsid, LPCOLESTR lpszDesc, <br>const IID&amp; iid = GUID_NULL, HRESULT hRes = 0); <br> <br>HRESULT WINAPI AtlReportError(const CLSID&amp; clsid, LPCOLESTR lpszDesc, <br>DWORD dwHelpID, LPCOLESTR lpszHelpFile, const IID&amp; iid = GUID_NULL, <br>HRESULT hRes = 0); <br> <br>HRESULT WINAPI AtlReportError(const CLSID&amp; clsid, UINT nID, <br>const IID&amp; iid = GUID_NULL, HRESULT hRes = 0, <br>HINSTANCE hInst = _Module.GetResourceInstance()); <br> <br>HRESULT WINAPI AtlReportError(const CLSID&amp; clsid, UINT nID, <br>DWORD dwHelpID, LPCOLESTR lpszHelpFile, const IID&amp; iid = GUID_NULL, <br>HRESULT hRes = 0, HINSTANCE hInst = _Module.GetResourceInstance()); <br> <br>#ifndef OLE2ANSI <br>HRESULT WINAPI AtlReportError(const CLSID&amp; clsid, LPCSTR lpszDesc, <br>const IID&amp; iid = GUID_NULL, HRESULT hRes = 0); <br> <br>HRESULT WINAPI AtlReportError(const CLSID&amp; clsid, LPCSTR lpszDesc, <br>DWORD dwHelpID, LPCSTR lpszHelpFile, const IID&amp; iid = GUID_NULL, <br>HRESULT hRes = 0); <br>#endif <br> <br>#ifndef _ATL_NO_SECURITY <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// CSecurityDescriptor <br> <br>class CSecurityDescriptor <br>{ <br>public: <br>CSecurityDescriptor(); <br>~CSecurityDescriptor(); <br> <br>public: <br>HRESULT Attach(PSECURITY_DESCRIPTOR pSelfRelativeSD); <br>HRESULT AttachObject(HANDLE hObject); <br>HRESULT Initialize(); <br>HRESULT InitializeFromProcessToken(BOOL bDefaulted = FALSE); <br>HRESULT InitializeFromThreadToken(BOOL bDefaulted = FALSE, BOOL bRevertToProcessToken = TRUE); <br>HRESULT SetOwner(PSID pOwnerSid, BOOL bDefaulted = FALSE); <br>HRESULT SetGroup(PSID pGroupSid, BOOL bDefaulted = FALSE); <br>HRESULT Allow(LPCTSTR pszPrincipal, DWORD dwAccessMask); <br>HRESULT Deny(LPCTSTR pszPrincipal, DWORD dwAccessMask); <br>HRESULT Revoke(LPCTSTR pszPrincipal); <br> <br>// utility functions <br>// Any PSID you get from these functions should be free()ed <br>static HRESULT SetPrivilege(LPCTSTR Privilege, BOOL bEnable = TRUE, HANDLE hToken = NULL); <br>static HRESULT GetTokenSids(HANDLE hToken, PSID* ppUserSid, PSID* ppGroupSid); <br>static HRESULT GetProcessSids(PSID* ppUserSid, PSID* ppGroupSid = NULL); <br>static HRESULT GetThreadSids(PSID* ppUserSid, PSID* ppGroupSid = NULL, BOOL bOpenAsSelf = FALSE); <br>static HRESULT CopyACL(PACL pDest, PACL pSrc); <br>static HRESULT GetCurrentUserSID(PSID *ppSid); <br>static HRESULT GetPrincipalSID(LPCTSTR pszPrincipal, PSID *ppSid); <br>static HRESULT AddAccessAllowedACEToACL(PACL *Acl, LPCTSTR pszPrincipal, DWORD dwAccessMask); <br>static HRESULT AddAccessDeniedACEToACL(PACL *Acl, LPCTSTR pszPrincipal, DWORD dwAccessMask); <br>static HRESULT RemovePrincipalFromACL(PACL Acl, LPCTSTR pszPrincipal); <br> <br>operator PSECURITY_DESCRIPTOR() <br>{ <br>return m_pSD; <br>} <br> <br>public: <br>PSECURITY_DESCRIPTOR m_pSD; <br>PSID m_pOwner; <br>PSID m_pGroup; <br>PACL m_pDACL; <br>PACL m_pSACL; <br>}; <br> <br>#endif // _ATL_NO_SECURITY <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// COM Objects <br> <br>#define DECLARE_PROTECT_FINAL_CONSTRUCT()\ <br>void InternalFinalConstructAddRef() {InternalAddRef();}\ <br>void InternalFinalConstructRelease() {InternalRelease();} <br> <br>template &lt;class T1&gt; <br>class CComCreator <br>{ <br>public: <br>static HRESULT WINAPI CreateInstance(void* pv, REFIID riid, LPVOID* ppv) <br>{ <br>_ASSERTE(*ppv == NULL); <br>HRESULT hRes = E_OUTOFMEMORY; <br>T1* p = NULL; <br>ATLTRY(p = new T1(pv)) <br>if (p != NULL) <br>{ <br>p-&gt;SetVoid(pv); <br>p-&gt;InternalFinalConstructAddRef(); <br>hRes = p-&gt;FinalConstruct(); <br>p-&gt;InternalFinalConstructRelease(); <br>if (hRes == S_OK) <br>hRes = p-&gt;QueryInterface(riid, ppv); <br>if (hRes != S_OK) <br>delete p; <br>} <br>return hRes; <br>} <br>}; <br> <br>template &lt;class T1&gt; <br>class CComInternalCreator <br>{ <br>public: <br>static HRESULT WINAPI CreateInstance(void* pv, REFIID riid, LPVOID* ppv) <br>{ <br>_ASSERTE(*ppv == NULL); <br>HRESULT hRes = E_OUTOFMEMORY; <br>T1* p = NULL; <br>ATLTRY(p = new T1(pv)) <br>if (p != NULL) <br>{ <br>p-&gt;SetVoid(pv); <br>p-&gt;InternalFinalConstructAddRef(); <br>hRes = p-&gt;FinalConstruct(); <br>p-&gt;InternalFinalConstructRelease(); <br>if (hRes == S_OK) <br>hRes = p-&gt;_InternalQueryInterface(riid, ppv); <br>if (hRes != S_OK) <br>delete p; <br>} <br>return hRes; <br>} <br>}; <br> <br>template &lt;HRESULT hr&gt; <br>class CComFailCreator <br>{ <br>public: <br>static HRESULT WINAPI CreateInstance(void*, REFIID, LPVOID*) <br>{ <br>return hr; <br>} <br>}; <br> <br>template &lt;class T1, class T2&gt; <br>class CComCreator2 <br>{ <br>public: <br>static HRESULT WINAPI CreateInstance(void* pv, REFIID riid, LPVOID* ppv) <br>{ <br>_ASSERTE(*ppv == NULL); <br>HRESULT hRes = E_OUTOFMEMORY; <br>if (pv == NULL) <br>hRes = T1::CreateInstance(NULL, riid, ppv); <br>else <br>hRes = T2::CreateInstance(pv, riid, ppv); <br>return hRes; <br>} <br>}; <br> <br>#define DECLARE_NOT_AGGREGATABLE(x) public:\ <br>typedef CComCreator2&lt; CComCreator&lt; CComObject&lt; x &gt; &gt;, CComFailCreator&lt;CLASS_E_NOAGGREGATION&gt; &gt; _CreatorClass; <br>#define DECLARE_AGGREGATABLE(x) public:\ <br>typedef CComCreator2&lt; CComCreator&lt; CComObject&lt; x &gt; &gt;, CComCreator&lt; CComAggObject&lt; x &gt; &gt; &gt; _CreatorClass; <br>#define DECLARE_ONLY_AGGREGATABLE(x) public:\ <br>typedef CComCreator2&lt; CComFailCreator&lt;E_FAIL&gt;, CComCreator&lt; CComAggObject&lt; x &gt; &gt; &gt; _CreatorClass; <br>#define DECLARE_POLY_AGGREGATABLE(x) public:\ <br>typedef CComCreator&lt; CComPolyObject&lt; x &gt; &gt; _CreatorClass; <br> <br>struct _ATL_CREATORDATA <br>{ <br>_ATL_CREATORFUNC* pFunc; <br>}; <br> <br>template &lt;class Creator&gt; <br>class _CComCreatorData <br>{ <br>public: <br>static _ATL_CREATORDATA data; <br>}; <br> <br>template &lt;class Creator&gt; <br>_ATL_CREATORDATA _CComCreatorData&lt;Creator&gt;::data = {Creator::CreateInstance}; <br> <br>struct _ATL_CACHEDATA <br>{ <br>DWORD dwOffsetVar; <br>_ATL_CREATORFUNC* pFunc; <br>}; <br> <br>template &lt;class Creator, DWORD dwVar&gt; <br>class _CComCacheData <br>{ <br>public: <br>static _ATL_CACHEDATA data; <br>}; <br> <br>template &lt;class Creator, DWORD dwVar&gt; <br>_ATL_CACHEDATA _CComCacheData&lt;Creator, dwVar&gt;::data = {dwVar, Creator::CreateInstance}; <br> <br>struct _ATL_CHAINDATA <br>{ <br>DWORD dwOffset; <br>const _ATL_INTMAP_ENTRY* (WINAPI *pFunc)(); <br>}; <br> <br>template &lt;class base, class derived&gt; <br>class _CComChainData <br>{ <br>public: <br>static _ATL_CHAINDATA data; <br>}; <br> <br>template &lt;class base, class derived&gt; <br>_ATL_CHAINDATA _CComChainData&lt;base, derived&gt;::data = <br>{offsetofclass(base, derived), base::_GetEntries}; <br> <br>template &lt;class T, const CLSID* pclsid&gt; <br>class CComAggregateCreator <br>{ <br>public: <br>static HRESULT WINAPI CreateInstance(void* pv, REFIID/*riid*/, LPVOID* ppv) <br>{ <br>_ASSERTE(*ppv == NULL); <br>_ASSERTE(pv != NULL); <br>T* p = (T*) pv; <br>// Add the following line to your object if you get a message about <br>// GetControllingUnknown() being undefined <br>// DECLARE_GET_CONTROLLING_UNKNOWN() <br>return CoCreateInstance(*pclsid, p-&gt;GetControllingUnknown(), CLSCTX_INPROC, IID_IUnknown, ppv); <br>} <br>}; <br> <br>#ifdef _ATL_DEBUG_QI <br>#define DEBUG_QI_ENTRY(x) \ <br>{NULL, \ <br>(DWORD)_T(#x), \ <br>(_ATL_CREATORARGFUNC*)0}, <br>#else <br>#define DEBUG_QI_ENTRY(x) <br>#endif //_ATL_DEBUG_QI <br> <br>//If you get a message that FinalConstruct is ambiguous then you need to <br>// override it in your class and call each base class' version of this <br>#define BEGIN_COM_MAP(x) public: \ <br>typedef x _ComMapClass; \ <br>static HRESULT WINAPI _Cache(void* pv, REFIID iid, void** ppvObject, DWORD dw)\ <br>{\ <br>_ComMapClass* p = (_ComMapClass*)pv;\ <br>p-&gt;Lock();\ <br>HRESULT hRes = CComObjectRootBase::_Cache(pv, iid, ppvObject, dw);\ <br>p-&gt;Unlock();\ <br>return hRes;\ <br>}\ <br>IUnknown* GetUnknown() \ <br>{ _ASSERTE(_GetEntries()[0].pFunc == _ATL_SIMPLEMAPENTRY); return (IUnknown*)((int)this+_GetEntries()-&gt;dw); } \ <br>HRESULT _InternalQueryInterface(REFIID iid, void** ppvObject) \ <br>{ return InternalQueryInterface(this, _GetEntries(), iid, ppvObject); } \ <br>const static _ATL_INTMAP_ENTRY* WINAPI _GetEntries() { \ <br>static const _ATL_INTMAP_ENTRY _entries[] = { DEBUG_QI_ENTRY(x) <br> <br>#define DECLARE_GET_CONTROLLING_UNKNOWN() public:\ <br>virtual IUnknown* GetControllingUnknown() {return GetUnknown();} <br> <br>#define COM_INTERFACE_ENTRY_BREAK(x)\ <br>{&amp;IID_##x, \ <br>NULL, \ <br>_Break}, <br> <br>#define COM_INTERFACE_ENTRY_NOINTERFACE(x)\ <br>{&amp;IID_##x, \ <br>NULL, \ <br>_NoInterface}, <br> <br>#define COM_INTERFACE_ENTRY(x)\ <br>{&amp;IID_##x, \ <br>offsetofclass(x, _ComMapClass), \ <br>_ATL_SIMPLEMAPENTRY}, <br> <br>#define COM_INTERFACE_ENTRY_IID(iid, x)\ <br>{&amp;iid,\ <br>offsetofclass(x, _ComMapClass),\ <br>_ATL_SIMPLEMAPENTRY}, <br> <br>#define COM_INTERFACE_ENTRY_IMPL(x)\ <br>COM_INTERFACE_ENTRY_IID(IID_##x, x##Impl&lt;_ComMapClass&gt;) <br> <br>#define COM_INTERFACE_ENTRY_IMPL_IID(iid, x)\ <br>COM_INTERFACE_ENTRY_IID(iid, x##Impl&lt;_ComMapClass&gt;) <br> <br>#define COM_INTERFACE_ENTRY2(x, x2)\ <br>{&amp;IID_##x,\ <br>(DWORD)((x*)(x2*)((_ComMapClass*)8))-8,\ <br>_ATL_SIMPLEMAPENTRY}, <br> <br>#define COM_INTERFACE_ENTRY2_IID(iid, x, x2)\ <br>{&amp;iid,\ <br>(DWORD)((x*)(x2*)((_ComMapClass*)8))-8,\ <br>_ATL_SIMPLEMAPENTRY}, <br> <br>#define COM_INTERFACE_ENTRY_FUNC(iid, dw, func)\ <br>{&amp;iid, \ <br>dw, \ <br>func}, <br> <br>#define COM_INTERFACE_ENTRY_FUNC_BLIND(dw, func)\ <br>{NULL, \ <br>dw, \ <br>func}, <br> <br>#define COM_INTERFACE_ENTRY_TEAR_OFF(iid, x)\ <br>{&amp;iid,\ <br>(DWORD)&amp;_CComCreatorData&lt;\ <br>CComInternalCreator&lt; CComTearOffObject&lt; x &gt; &gt;\ <br>&gt;::data,\ <br>_Creator}, <br> <br>#define COM_INTERFACE_ENTRY_CACHED_TEAR_OFF(iid, x, punk)\ <br>{&amp;iid,\ <br>(DWORD)&amp;_CComCacheData&lt;\ <br>CComCreator&lt; CComCachedTearOffObject&lt; x &gt; &gt;,\ <br>(DWORD)offsetof(_ComMapClass, punk)\ <br>&gt;::data,\ <br>_Cache}, <br> <br>#define COM_INTERFACE_ENTRY_AGGREGATE(iid, punk)\ <br>{&amp;iid,\ <br>(DWORD)offsetof(_ComMapClass, punk),\ <br>_Delegate}, <br> <br>#define COM_INTERFACE_ENTRY_AGGREGATE_BLIND(punk)\ <br>{NULL,\ <br>(DWORD)offsetof(_ComMapClass, punk),\ <br>_Delegate}, <br> <br>#define COM_INTERFACE_ENTRY_AUTOAGGREGATE(iid, punk, clsid)\ <br>{&amp;iid,\ <br>(DWORD)&amp;_CComCacheData&lt;\ <br>CComAggregateCreator&lt;_ComMapClass, &amp;clsid&gt;,\ <br>(DWORD)offsetof(_ComMapClass, punk)\ <br>&gt;::data,\ <br>_Cache}, <br> <br>#define COM_INTERFACE_ENTRY_AUTOAGGREGATE_BLIND(punk, clsid)\ <br>{NULL,\ <br>(DWORD)&amp;_CComCacheData&lt;\ <br>CComAggregateCreator&lt;_ComMapClass, &amp;clsid&gt;,\ <br>(DWORD)offsetof(_ComMapClass, punk)\ <br>&gt;::data,\ <br>_Cache}, <br> <br>#define COM_INTERFACE_ENTRY_CHAIN(classname)\ <br>{NULL,\ <br>(DWORD)&amp;_CComChainData&lt;classname, _ComMapClass&gt;::data,\ <br>_Chain}, <br> <br>#ifdef _ATL_DEBUG_QI <br>#define END_COM_MAP()   {NULL, 0, 0}};\ <br>return &amp;_entries[1];} <br>#else <br>#define END_COM_MAP()   {NULL, 0, 0}};\ <br>return _entries;} <br>#endif // _ATL_DEBUG_QI <br> <br>#define BEGIN_OBJECT_MAP(x) static _ATL_OBJMAP_ENTRY x[] = { <br>#define END_OBJECT_MAP()   {NULL, NULL, NULL, NULL}}; <br>#define OBJECT_ENTRY(clsid, class) {&amp;clsid, &amp;class::UpdateRegistry, &amp;class::_ClassFactoryCreatorClass::CreateInstance, &amp;class::_CreatorClass::CreateInstance, NULL, 0, &amp;class::GetObjectDescription }, <br> <br>#ifdef _ATL_DEBUG_QI <br>extern HRESULT WINAPI AtlDumpIID(REFIID iid, LPCTSTR pszClassName, HRESULT hr); <br>#endif // _ATL_DEBUG_QI <br> <br> <br>// the functions in this class don't need to be virtual because <br>// they are called from CComObject <br>class CComObjectRootBase <br>{ <br>public: <br>CComObjectRootBase() <br>{ <br>m_dwRef = 0L; <br>} <br>HRESULT FinalConstruct() <br>{ <br>return S_OK; <br>} <br>void FinalRelease() {} <br> <br>static HRESULT WINAPI InternalQueryInterface(void* pThis, <br>const _ATL_INTMAP_ENTRY* pEntries, REFIID iid, void** ppvObject) <br>{ <br>_ASSERTE(pThis != NULL); <br>// First entry in the com map should be a simple map entry <br>_ASSERTE(pEntries-&gt;pFunc == _ATL_SIMPLEMAPENTRY); <br>#ifdef _ATL_DEBUG_QI <br>LPCTSTR pszClassName = (LPCTSTR) pEntries[-1].dw; <br>#endif // _ATL_DEBUG_QI <br>HRESULT hRes = AtlInternalQueryInterface(pThis, pEntries, iid, ppvObject); <br>return _ATLDUMPIID(iid, pszClassName, hRes); <br>} <br> <br>//Outer funcs <br>ULONG OuterAddRef() <br>{ <br>return m_pOuterUnknown-&gt;AddRef(); <br>} <br>ULONG OuterRelease() <br>{ <br>return m_pOuterUnknown-&gt;Release(); <br>} <br>HRESULT OuterQueryInterface(REFIID iid, void ** ppvObject) <br>{ <br>return m_pOuterUnknown-&gt;QueryInterface(iid, ppvObject); <br>} <br> <br>void SetVoid(void*) {} <br>void InternalFinalConstructAddRef() {} <br>void InternalFinalConstructRelease() <br>{ <br>_ASSERTE(m_dwRef == 0); <br>} <br>// If this assert occurs, your object has probably been deleted <br>// Try using DECLARE_PROTECT_FINAL_CONSTRUCT() <br> <br> <br>static HRESULT WINAPI _Break(void* pv, REFIID iid, void** ppvObject, DWORD dw); <br>static HRESULT WINAPI _NoInterface(void* pv, REFIID iid, void** ppvObject, DWORD dw); <br>static HRESULT WINAPI _Creator(void* pv, REFIID iid, void** ppvObject, DWORD dw); <br>static HRESULT WINAPI _Delegate(void* pv, REFIID iid, void** ppvObject, DWORD dw); <br>static HRESULT WINAPI _Chain(void* pv, REFIID iid, void** ppvObject, DWORD dw); <br>static HRESULT WINAPI _Cache(void* pv, REFIID iid, void** ppvObject, DWORD dw); <br> <br>union <br>{ <br>long m_dwRef; <br>IUnknown* m_pOuterUnknown; <br>}; <br>}; <br> <br>template &lt;class ThreadModel&gt; <br>class CComObjectRootEx : public CComObjectRootBase <br>{ <br>public: <br>typedef ThreadModel _ThreadModel; <br>typedef _ThreadModel::AutoCriticalSection _CritSec; <br> <br>ULONG InternalAddRef() <br>{ <br>_ASSERTE(m_dwRef != -1L); <br>return _ThreadModel::Increment(&amp;m_dwRef); <br>} <br>ULONG InternalRelease() <br>{ <br>return _ThreadModel::Decrement(&amp;m_dwRef); <br>} <br> <br>#ifdef _ATL_DEBUG_REFCOUNT <br>ULONG DebugAddRef(long&amp; dw, LPCTSTR lpszClassName) <br>{ <br>_ThreadModel::Increment(&amp;dw); <br>ATLTRACE(_T("%s %d&gt;\n"), lpszClassName, dw); <br>return AddRef(); <br>} <br>ULONG DebugRelease(long&amp; dw, LPCTSTR lpszClassName) <br>{ <br>_ThreadModel::Decrement(&amp;dw); <br>ATLTRACE(_T("%s %d&lt;\n"), lpszClassName, dw); <br>return Release(); <br>} <br>virtual ULONG STDMETHODCALLTYPE AddRef( void) = 0; <br>virtual ULONG STDMETHODCALLTYPE Release( void) = 0; <br>#endif // _ATL_DEBUG_REFCOUNT <br> <br>void Lock() {m_critsec.Lock();} <br>void Unlock() {m_critsec.Unlock();} <br>private: <br>_CritSec m_critsec; <br>}; <br> <br>#if _MSC_VER&gt;1020 <br>template &lt;&gt; <br>#endif <br>class CComObjectRootEx&lt;CComSingleThreadModel&gt; : public CComObjectRootBase <br>{ <br>public: <br>typedef CComSingleThreadModel _ThreadModel; <br>typedef _ThreadModel::AutoCriticalSection _CritSec; <br> <br>ULONG InternalAddRef() <br>{ <br>_ASSERTE(m_dwRef != -1L); <br>return _ThreadModel::Increment(&amp;m_dwRef); <br>} <br>ULONG InternalRelease() <br>{ <br>return _ThreadModel::Decrement(&amp;m_dwRef); <br>} <br> <br>#ifdef _ATL_DEBUG_REFCOUNT <br>ULONG DebugAddRef(long&amp; dw, LPCTSTR lpszClassName) <br>{ <br>_ThreadModel::Increment(&amp;dw); <br>ATLTRACE(_T("%s %d&gt;\n"), lpszClassName, dw); <br>return AddRef(); <br>} <br>ULONG DebugRelease(long&amp; dw, LPCTSTR lpszClassName) <br>{ <br>_ThreadModel::Decrement(&amp;dw); <br>ATLTRACE(_T("%s %d&lt;\n"), lpszClassName, dw); <br>return Release(); <br>} <br>virtual ULONG STDMETHODCALLTYPE AddRef( void) = 0; <br>virtual ULONG STDMETHODCALLTYPE Release( void) = 0; <br>#endif // _ATL_DEBUG_REFCOUNT <br> <br>void Lock() {} <br>void Unlock() {} <br>}; <br> <br>typedef CComObjectRootEx&lt;CComObjectThreadModel&gt; CComObjectRoot; <br> <br>#if defined(_WINDLL) | defined(_USRDLL) <br>#define DECLARE_CLASSFACTORY_EX(cf) typedef CComCreator&lt; CComObjectCached&lt; cf &gt; &gt; _ClassFactoryCreatorClass; <br>#else <br>// don't let class factory refcount influence lock count <br>#define DECLARE_CLASSFACTORY_EX(cf) typedef CComCreator&lt; CComObjectNoLock&lt; cf &gt; &gt; _ClassFactoryCreatorClass; <br>#endif <br>#define DECLARE_CLASSFACTORY() DECLARE_CLASSFACTORY_EX(CComClassFactory) <br>#define DECLARE_CLASSFACTORY2(lic) DECLARE_CLASSFACTORY_EX(CComClassFactory2&lt;lic&gt;) <br>#define DECLARE_CLASSFACTORY_AUTO_THREAD() DECLARE_CLASSFACTORY_EX(CComClassFactoryAutoThread) <br>#define DECLARE_CLASSFACTORY_SINGLETON(obj) DECLARE_CLASSFACTORY_EX(CComClassFactorySingleton&lt;obj&gt;) <br> <br>#define DECLARE_OBJECT_DESCRIPTION(x)\ <br>static LPCTSTR WINAPI GetObjectDescription()\ <br>{\ <br>return _T(x);\ <br>} <br> <br>#define DECLARE_NO_REGISTRY()\ <br>static HRESULT WINAPI UpdateRegistry(BOOL /*bRegister*/)\ <br>{return S_OK;} <br> <br>#define DECLARE_REGISTRY(class, pid, vpid, nid, flags)\ <br>static HRESULT WINAPI UpdateRegistry(BOOL bRegister)\ <br>{\ <br>return _Module.UpdateRegistryClass(GetObjectCLSID(), pid, vpid, nid,\ <br>flags, bRegister);\ <br>} <br> <br>#define DECLARE_REGISTRY_RESOURCE(x)\ <br>static HRESULT WINAPI UpdateRegistry(BOOL bRegister)\ <br>{\ <br>return _Module.UpdateRegistryFromResource(_T(#x), bRegister);\ <br>} <br> <br>#define DECLARE_REGISTRY_RESOURCEID(x)\ <br>static HRESULT WINAPI UpdateRegistry(BOOL bRegister)\ <br>{\ <br>return _Module.UpdateRegistryFromResource(x, bRegister);\ <br>} <br> <br>//DECLARE_STATIC_* provided for backward compatibility <br>#ifdef _ATL_STATIC_REGISTRY <br>#define DECLARE_STATIC_REGISTRY_RESOURCE(x) DECLARE_REGISTRY_RESOURCE(x) <br>#define DECLARE_STATIC_REGISTRY_RESOURCEID(x) DECLARE_REGISTRY_RESOURCEID(x) <br>#endif //_ATL_STATIC_REGISTRY <br> <br>template&lt;class Base&gt; class CComObject; // fwd decl <br> <br>template &lt;class Owner, class ThreadModel = CComObjectThreadModel&gt; <br>class CComTearOffObjectBase : public CComObjectRootEx&lt;ThreadModel&gt; <br>{ <br>public: <br>typedef Owner _OwnerClass; <br>CComObject&lt;Owner&gt;* m_pOwner; <br>CComTearOffObjectBase() {m_pOwner = NULL;} <br>}; <br> <br>//Base is the user's class that derives from CComObjectRoot and whatever <br>//interfaces the user wants to support on the object <br>template &lt;class Base&gt; <br>class CComObject : public Base <br>{ <br>public: <br>typedef Base _BaseClass; <br>CComObject(void* = NULL) <br>{ <br>_Module.Lock(); <br>} <br>// Set refcount to 1 to protect destruction <br>~CComObject() <br>{ <br>m_dwRef = 1L; <br>FinalRelease(); <br>_Module.Unlock(); <br>} <br>//If InternalAddRef or InteralRelease is undefined then your class <br>//doesn't derive from CComObjectRoot <br>STDMETHOD_(ULONG, AddRef)() {return InternalAddRef();} <br>STDMETHOD_(ULONG, Release)() <br>{ <br>ULONG l = InternalRelease(); <br>if (l == 0) <br>delete this; <br>return l; <br>} <br>//if _InternalQueryInterface is undefined then you forgot BEGIN_COM_MAP <br>STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject) <br>{return _InternalQueryInterface(iid, ppvObject);} <br>static HRESULT WINAPI CreateInstance(CComObject&lt;Base&gt;** pp); <br>}; <br> <br>template &lt;class Base&gt; <br>HRESULT WINAPI CComObject&lt;Base&gt;::CreateInstance(CComObject&lt;Base&gt;** pp) <br>{ <br>_ASSERTE(pp != NULL); <br>HRESULT hRes = E_OUTOFMEMORY; <br>CComObject&lt;Base&gt;* p = NULL; <br>ATLTRY(p = new CComObject&lt;Base&gt;()) <br>if (p != NULL) <br>{ <br>p-&gt;SetVoid(NULL); <br>p-&gt;InternalFinalConstructAddRef(); <br>hRes = p-&gt;FinalConstruct(); <br>p-&gt;InternalFinalConstructRelease(); <br>if (hRes != S_OK) <br>{ <br>delete p; <br>p = NULL; <br>} <br>} <br>*pp = p; <br>return hRes; <br>} <br> <br>//Base is the user's class that derives from CComObjectRoot and whatever <br>//interfaces the user wants to support on the object <br>// CComObjectCached is used primarily for class factories in DLL's <br>// but it is useful anytime you want to cache an object <br>template &lt;class Base&gt; <br>class CComObjectCached : public Base <br>{ <br>public: <br>typedef Base _BaseClass; <br>CComObjectCached(void* = NULL){} <br>// Set refcount to 1 to protect destruction <br>~CComObjectCached(){m_dwRef = 1L; FinalRelease();} <br>//If InternalAddRef or InteralRelease is undefined then your class <br>//doesn't derive from CComObjectRoot <br>STDMETHOD_(ULONG, AddRef)() <br>{ <br>m_csCached.Lock(); <br>ULONG l = InternalAddRef(); <br>if (m_dwRef == 2) <br>_Module.Lock(); <br>m_csCached.Unlock(); <br>return l; <br>} <br>STDMETHOD_(ULONG, Release)() <br>{ <br>m_csCached.Lock(); <br>InternalRelease(); <br>ULONG l = m_dwRef; <br>m_csCached.Unlock(); <br>if (l == 0) <br>delete this; <br>else if (l == 1) <br>_Module.Unlock(); <br>return l; <br>} <br>//if _InternalQueryInterface is undefined then you forgot BEGIN_COM_MAP <br>STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject) <br>{return _InternalQueryInterface(iid, ppvObject);} <br>CComGlobalsThreadModel::AutoCriticalSection m_csCached; <br>}; <br> <br>//Base is the user's class that derives from CComObjectRoot and whatever <br>//interfaces the user wants to support on the object <br>template &lt;class Base&gt; <br>class CComObjectNoLock : public Base <br>{ <br>public: <br>typedef Base _BaseClass; <br>CComObjectNoLock(void* = NULL){} <br>// Set refcount to 1 to protect destruction <br>~CComObjectNoLock() {m_dwRef = 1L; FinalRelease();} <br> <br>//If InternalAddRef or InteralRelease is undefined then your class <br>//doesn't derive from CComObjectRoot <br>STDMETHOD_(ULONG, AddRef)() {return InternalAddRef();} <br>STDMETHOD_(ULONG, Release)() <br>{ <br>ULONG l = InternalRelease(); <br>if (l == 0) <br>delete this; <br>return l; <br>} <br>//if _InternalQueryInterface is undefined then you forgot BEGIN_COM_MAP <br>STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject) <br>{return _InternalQueryInterface(iid, ppvObject);} <br>}; <br> <br>// It is possible for Base not to derive from CComObjectRoot <br>// However, you will need to provide FinalConstruct and InternalQueryInterface <br>template &lt;class Base&gt; <br>class CComObjectGlobal : public Base <br>{ <br>public: <br>typedef Base _BaseClass; <br>CComObjectGlobal(void* = NULL){m_hResFinalConstruct = FinalConstruct();} <br>~CComObjectGlobal() {FinalRelease();} <br> <br>STDMETHOD_(ULONG, AddRef)() {return _Module.Lock();} <br>STDMETHOD_(ULONG, Release)(){return _Module.Unlock();} <br>STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject) <br>{return _InternalQueryInterface(iid, ppvObject);} <br>HRESULT m_hResFinalConstruct; <br>}; <br> <br>// It is possible for Base not to derive from CComObjectRoot <br>// However, you will need to provide FinalConstruct and InternalQueryInterface <br>template &lt;class Base&gt; <br>class CComObjectStack : public Base <br>{ <br>public: <br>typedef Base _BaseClass; <br>CComObjectStack(void* = NULL){m_hResFinalConstruct = FinalConstruct();} <br>~CComObjectStack() {FinalRelease();} <br> <br>STDMETHOD_(ULONG, AddRef)() {_ASSERTE(FALSE);return 0;} <br>STDMETHOD_(ULONG, Release)(){_ASSERTE(FALSE);return 0;} <br>STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject) <br>{_ASSERTE(FALSE);return E_NOINTERFACE;} <br>HRESULT m_hResFinalConstruct; <br>}; <br> <br>template &lt;class Base&gt; //Base must be derived from CComObjectRoot <br>class CComContainedObject : public Base <br>{ <br>public: <br>typedef Base _BaseClass; <br>CComContainedObject(void* pv) {m_pOuterUnknown = (IUnknown*)pv;} <br> <br>STDMETHOD_(ULONG, AddRef)() {return OuterAddRef();} <br>STDMETHOD_(ULONG, Release)() {return OuterRelease();} <br>STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject) <br>{return OuterQueryInterface(iid, ppvObject);} <br>//GetControllingUnknown may be virtual if the Base class has declared <br>//DECLARE_GET_CONTROLLING_UNKNOWN() <br>IUnknown* GetControllingUnknown() {return m_pOuterUnknown;} <br>}; <br> <br>//contained is the user's class that derives from CComObjectRoot and whatever <br>//interfaces the user wants to support on the object <br>template &lt;class contained&gt; <br>class CComAggObject : <br>public IUnknown, <br>public CComObjectRootEx&lt; contained::_ThreadModel::ThreadModelNoCS &gt; <br>{ <br>public: <br>typedef contained _BaseClass; <br>CComAggObject(void* pv) : m_contained(pv) <br>{ <br>_Module.Lock(); <br>} <br>//If you get a message that this call is ambiguous then you need to <br>// override it in your class and call each base class' version of this <br>HRESULT FinalConstruct() <br>{ <br>CComObjectRootEx&lt;contained::_ThreadModel::ThreadModelNoCS&gt;::FinalConstruct(); <br>return m_contained.FinalConstruct(); <br>} <br>void FinalRelease() <br>{ <br>CComObjectRootEx&lt;contained::_ThreadModel::ThreadModelNoCS&gt;::FinalRelease(); <br>m_contained.FinalRelease(); <br>} <br>// Set refcount to 1 to protect destruction <br>~CComAggObject() <br>{ <br>m_dwRef = 1L; <br>FinalRelease(); <br>_Module.Unlock(); <br>} <br> <br>STDMETHOD_(ULONG, AddRef)() {return InternalAddRef();} <br>STDMETHOD_(ULONG, Release)() <br>{ <br>ULONG l = InternalRelease(); <br>if (l == 0) <br>delete this; <br>return l; <br>} <br>STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject) <br>{ <br>HRESULT hRes = S_OK; <br>if (InlineIsEqualUnknown(iid)) <br>{ <br>*ppvObject = (void*)(IUnknown*)this; <br>AddRef(); <br>} <br>else <br>hRes = m_contained._InternalQueryInterface(iid, ppvObject); <br>return hRes; <br>} <br>CComContainedObject&lt;contained&gt; m_contained; <br>}; <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// CComPolyObject can be either aggregated or not aggregated <br> <br>template &lt;class contained&gt; <br>class CComPolyObject : <br>public IUnknown, <br>public CComObjectRootEx&lt; contained::_ThreadModel::ThreadModelNoCS &gt; <br>{ <br>public: <br>typedef contained _BaseClass; <br>CComPolyObject(void* pv) : m_contained(pv ? pv : this) <br>{ <br>_Module.Lock(); <br>} <br>//If you get a message that this call is ambiguous then you need to <br>// override it in your class and call each base class' version of this <br>HRESULT FinalConstruct() <br>{ <br>CComObjectRootEx&lt;contained::_ThreadModel::ThreadModelNoCS&gt;::FinalConstruct(); <br>return m_contained.FinalConstruct(); <br>} <br>void FinalRelease() <br>{ <br>CComObjectRootEx&lt;contained::_ThreadModel::ThreadModelNoCS&gt;::FinalRelease(); <br>m_contained.FinalRelease(); <br>} <br>// Set refcount to 1 to protect destruction <br>~CComPolyObject() <br>{ <br>m_dwRef = 1L; <br>FinalRelease(); <br>_Module.Unlock(); <br>} <br> <br>STDMETHOD_(ULONG, AddRef)() {return InternalAddRef();} <br>STDMETHOD_(ULONG, Release)() <br>{ <br>ULONG l = InternalRelease(); <br>if (l == 0) <br>delete this; <br>return l; <br>} <br>STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject) <br>{ <br>HRESULT hRes = S_OK; <br>if (InlineIsEqualUnknown(iid)) <br>{ <br>*ppvObject = (void*)(IUnknown*)this; <br>AddRef(); <br>} <br>else <br>hRes = m_contained._InternalQueryInterface(iid, ppvObject); <br>return hRes; <br>} <br>CComContainedObject&lt;contained&gt; m_contained; <br>}; <br> <br>template &lt;class Base&gt; <br>class CComTearOffObject : public Base <br>{ <br>public: <br>CComTearOffObject(void* pv) <br>{ <br>_ASSERTE(m_pOwner == NULL); <br>m_pOwner = reinterpret_cast&lt;CComObject&lt;Base::_OwnerClass&gt;*&gt;(pv); <br>m_pOwner-&gt;AddRef(); <br>} <br>// Set refcount to 1 to protect destruction <br>~CComTearOffObject() <br>{ <br>m_dwRef = 1L; <br>FinalRelease(); <br>m_pOwner-&gt;Release(); <br>} <br> <br>STDMETHOD_(ULONG, AddRef)() {return InternalAddRef();} <br>STDMETHOD_(ULONG, Release)() <br>{ <br>ULONG l = InternalRelease(); <br>if (l == 0) <br>delete this; <br>return l; <br>} <br>STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject) <br>{ <br>return m_pOwner-&gt;QueryInterface(iid, ppvObject); <br>} <br>}; <br> <br>template &lt;class contained&gt; <br>class CComCachedTearOffObject : <br>public IUnknown, <br>public CComObjectRootEx&lt;contained::_ThreadModel::ThreadModelNoCS&gt; <br>{ <br>public: <br>typedef contained _BaseClass; <br>CComCachedTearOffObject(void* pv) : <br>m_contained(((contained::_OwnerClass*)pv)-&gt;GetControllingUnknown()) <br>{ <br>_ASSERTE(m_contained.m_pOwner == NULL); <br>m_contained.m_pOwner = reinterpret_cast&lt;CComObject&lt;contained::_OwnerClass&gt;*&gt;(pv); <br>} <br>//If you get a message that this call is ambiguous then you need to <br>// override it in your class and call each base class' version of this <br>HRESULT FinalConstruct() <br>{ <br>CComObjectRootEx&lt;contained::_ThreadModel::ThreadModelNoCS&gt;::FinalConstruct(); <br>return m_contained.FinalConstruct(); <br>} <br>void FinalRelease() <br>{ <br>CComObjectRootEx&lt;contained::_ThreadModel::ThreadModelNoCS&gt;::FinalRelease(); <br>m_contained.FinalRelease(); <br>} <br>// Set refcount to 1 to protect destruction <br>~CComCachedTearOffObject(){m_dwRef = 1L; FinalRelease();} <br> <br>STDMETHOD_(ULONG, AddRef)() {return InternalAddRef();} <br>STDMETHOD_(ULONG, Release)() <br>{ <br>ULONG l = InternalRelease(); </code></pre>
<p>
</p>
<pre><code>if (l == 0) <br>delete this; <br>return l; <br>} <br>STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject) <br>{ <br>HRESULT hRes = S_OK; <br>if (InlineIsEqualUnknown(iid)) <br>{ <br>*ppvObject = (void*)(IUnknown*)this; <br>AddRef(); <br>} <br>else <br>hRes = m_contained._InternalQueryInterface(iid, ppvObject); <br>return hRes; <br>} <br>CComContainedObject&lt;contained&gt; m_contained; <br>}; <br> <br>class CComClassFactory : <br>public IClassFactory, <br>public CComObjectRootEx&lt;CComGlobalsThreadModel&gt; <br>{ <br>public: <br>BEGIN_COM_MAP(CComClassFactory) <br>COM_INTERFACE_ENTRY(IClassFactory) <br>END_COM_MAP() <br> <br>// IClassFactory <br>STDMETHOD(CreateInstance)(LPUNKNOWN pUnkOuter, REFIID riid, void** ppvObj); <br>STDMETHOD(LockServer)(BOOL fLock); <br>// helper <br>void SetVoid(void* pv) <br>{ <br>m_pfnCreateInstance = (_ATL_CREATORFUNC*)pv; <br>} <br>_ATL_CREATORFUNC* m_pfnCreateInstance; <br>}; <br> <br>class CComClassFactory2Base : <br>public IClassFactory2, <br>public CComObjectRootEx&lt;CComGlobalsThreadModel&gt; <br>{ <br>public: <br>BEGIN_COM_MAP(CComClassFactory2Base) <br>COM_INTERFACE_ENTRY(IClassFactory) <br>COM_INTERFACE_ENTRY(IClassFactory2) <br>END_COM_MAP() <br>// IClassFactory <br>STDMETHOD(LockServer)(BOOL fLock); <br>// helper <br>void SetVoid(void* pv) <br>{ <br>m_pfnCreateInstance = (_ATL_CREATORFUNC*)pv; <br>} <br>_ATL_CREATORFUNC* m_pfnCreateInstance; <br>}; <br> <br>template &lt;class license&gt; <br>class CComClassFactory2 : public CComClassFactory2Base, license <br>{ <br>public: <br>typedef license _LicenseClass; <br>typedef CComClassFactory2&lt;license&gt; _ComMapClass; <br>// IClassFactory <br>STDMETHOD(CreateInstance)(LPUNKNOWN pUnkOuter, <br>REFIID riid, void** ppvObj) <br>{ <br>_ASSERTE(m_pfnCreateInstance != NULL); <br>if (ppvObj == NULL) <br>return E_POINTER; <br>*ppvObj = NULL; <br>if (!IsLicenseValid()) <br>return CLASS_E_NOTLICENSED; <br> <br>if ((pUnkOuter != NULL) &amp;&amp; !InlineIsEqualUnknown(riid)) <br>return CLASS_E_NOAGGREGATION; <br>else <br>return m_pfnCreateInstance(pUnkOuter, riid, ppvObj); <br>} <br>// IClassFactory2 <br>STDMETHOD(CreateInstanceLic)(IUnknown* pUnkOuter, IUnknown* pUnkReserved, <br>REFIID riid, BSTR bstrKey, void** ppvObject) <br>{ <br>_ASSERTE(m_pfnCreateInstance != NULL); <br>if (ppvObject == NULL) <br>return E_POINTER; <br>*ppvObject = NULL; <br>if ( ((bstrKey != NULL) &amp;&amp; !VerifyLicenseKey(bstrKey)) || <br> ((bstrKey == NULL) &amp;&amp; !IsLicenseValid()) ) <br>return CLASS_E_NOTLICENSED; <br>return m_pfnCreateInstance(pUnkOuter, riid, ppvObject); <br>} <br>STDMETHOD(RequestLicKey)(DWORD dwReserved, BSTR* pbstrKey) <br>{ <br>if (pbstrKey == NULL) <br>return E_POINTER; <br>*pbstrKey = NULL; <br> <br>if (!IsLicenseValid()) <br>return CLASS_E_NOTLICENSED; <br>return GetLicenseKey(dwReserved,pbstrKey) ? S_OK : E_FAIL; <br>} <br>STDMETHOD(GetLicInfo)(LICINFO* pLicInfo) <br>{ <br>if (pLicInfo == NULL) <br>return E_POINTER; <br>pLicInfo-&gt;cbLicInfo = sizeof(LICINFO); <br>pLicInfo-&gt;fLicVerified = IsLicenseValid(); <br>BSTR bstr = NULL; <br>pLicInfo-&gt;fRuntimeKeyAvail = GetLicenseKey(0,&amp;bstr); <br>::SysFreeString(bstr); <br>return S_OK; <br>} <br>}; <br> <br>///////////////////////////////////////////////////////////////////////////////////////////// <br>// Thread Pooling class factory <br> <br>class CComClassFactoryAutoThread : <br>public IClassFactory, <br>public CComObjectRootEx&lt;CComGlobalsThreadModel&gt; <br>{ <br>public: <br>BEGIN_COM_MAP(CComClassFactoryAutoThread) <br>COM_INTERFACE_ENTRY(IClassFactory) <br>END_COM_MAP() <br> <br>// helper <br>void SetVoid(void* pv) <br>{ <br>m_pfnCreateInstance = (_ATL_CREATORFUNC*)pv; <br>} <br>STDMETHODIMP CComClassFactoryAutoThread::CreateInstance(LPUNKNOWN pUnkOuter, <br>REFIID riid, void** ppvObj) <br>{ <br>_ASSERTE(m_pfnCreateInstance != NULL); <br>HRESULT hRes = E_POINTER; <br>if (ppvObj != NULL) <br>{ <br>*ppvObj = NULL; <br>// cannot aggregate across apartments <br>_ASSERTE(pUnkOuter == NULL); <br>if (pUnkOuter != NULL) <br>hRes = CLASS_E_NOAGGREGATION; <br>else <br>hRes = _Module.CreateInstance(m_pfnCreateInstance, riid, ppvObj); <br>} <br>return hRes; <br>} <br>STDMETHODIMP CComClassFactoryAutoThread::LockServer(BOOL fLock) <br>{ <br>if (fLock) <br>_Module.Lock(); <br>else <br>_Module.Unlock(); <br>return S_OK; <br>} <br>_ATL_CREATORFUNC* m_pfnCreateInstance; <br>}; <br> <br>///////////////////////////////////////////////////////////////////////////////////////////// <br>// Singleton Class Factory <br>template &lt;class T&gt; <br>class CComClassFactorySingleton : public CComClassFactory <br>{ <br>public: <br>// IClassFactory <br>STDMETHOD(CreateInstance)(LPUNKNOWN pUnkOuter, REFIID riid, void** ppvObj) <br>{ <br>HRESULT hRes = E_POINTER; <br>if (ppvObj != NULL) <br>{ <br>// can't ask for anything other than IUnknown when aggregating <br>_ASSERTE((pUnkOuter == NULL) || InlineIsEqualUnknown(riid)); <br>if ((pUnkOuter != NULL) &amp;&amp; !InlineIsEqualUnknown(riid)) <br>hRes = CLASS_E_NOAGGREGATION; <br>else <br>hRes = m_Obj.QueryInterface(riid, ppvObj); <br>} <br>return hRes; <br>} <br>CComObjectGlobal&lt;T&gt; m_Obj; <br>}; <br> <br> <br>template &lt;class T, const CLSID* pclsid&gt; <br>class CComCoClass <br>{ <br>public: <br>DECLARE_CLASSFACTORY() <br>DECLARE_AGGREGATABLE(T) <br>typedef T _CoClass; <br>static const CLSID&amp; WINAPI GetObjectCLSID() {return *pclsid;} <br>static LPCTSTR WINAPI GetObjectDescription() {return NULL;} <br>static HRESULT WINAPI Error(LPCOLESTR lpszDesc, <br>const IID&amp; iid = GUID_NULL, HRESULT hRes = 0) <br>{ <br>return AtlReportError(GetObjectCLSID(), lpszDesc, iid, hRes); <br>} <br>static HRESULT WINAPI Error(LPCOLESTR lpszDesc, DWORD dwHelpID, <br>LPCOLESTR lpszHelpFile, const IID&amp; iid = GUID_NULL, HRESULT hRes = 0) <br>{ <br>return AtlReportError(GetObjectCLSID(), lpszDesc, dwHelpID, lpszHelpFile, <br>iid, hRes); <br>} <br>static HRESULT WINAPI Error(UINT nID, const IID&amp; iid = GUID_NULL, <br>HRESULT hRes = 0, HINSTANCE hInst = _Module.GetResourceInstance()) <br>{ <br>return AtlReportError(GetObjectCLSID(), nID, iid, hRes, hInst); <br>} <br>static HRESULT WINAPI Error(UINT nID, DWORD dwHelpID, <br>LPCOLESTR lpszHelpFile, const IID&amp; iid = GUID_NULL, <br>HRESULT hRes = 0, HINSTANCE hInst = _Module.GetResourceInstance()) <br>{ <br>return AtlReportError(GetObjectCLSID(), nID, dwHelpID, lpszHelpFile, <br>iid, hRes, hInst); <br>} <br>#ifndef OLE2ANSI <br>static HRESULT WINAPI Error(LPCSTR lpszDesc, <br>const IID&amp; iid = GUID_NULL, HRESULT hRes = 0) <br>{ <br>return AtlReportError(GetObjectCLSID(), lpszDesc, iid, hRes); <br>} <br>static HRESULT WINAPI Error(LPCSTR lpszDesc, DWORD dwHelpID, <br>LPCSTR lpszHelpFile, const IID&amp; iid = GUID_NULL, HRESULT hRes = 0) <br>{ <br>return AtlReportError(GetObjectCLSID(), lpszDesc, dwHelpID, <br>lpszHelpFile, iid, hRes); <br>} <br>#endif <br>}; <br> <br>// ATL doesn't support multiple LCID's at the same time <br>// Whatever LCID is queried for first is the one that is used. <br>class CComTypeInfoHolder <br>{ <br>// Should be 'protected' but can cause compiler to generate fat code. <br>public: <br>const GUID* m_pguid; <br>const GUID* m_plibid; <br>WORD m_wMajor; <br>WORD m_wMinor; <br> <br>ITypeInfo* m_pInfo; <br>long m_dwRef; <br> <br>public: <br>HRESULT GetTI(LCID lcid, ITypeInfo** ppInfo); <br> <br>void AddRef(); <br>void Release(); <br>HRESULT GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo); <br>HRESULT GetIDsOfNames(REFIID riid, LPOLESTR* rgszNames, UINT cNames, <br>LCID lcid, DISPID* rgdispid); <br>HRESULT Invoke(IDispatch* p, DISPID dispidMember, REFIID riid, <br>LCID lcid, WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult, <br>EXCEPINFO* pexcepinfo, UINT* puArgErr); <br>}; <br> <br>////////////////////////////////////////////////////////////////////////////// <br>// IObjectWithSite <br>// <br>template &lt;class T&gt; <br>class ATL_NO_VTABLE IObjectWithSiteImpl <br>{ <br>public: <br>// IUnknown <br>// <br>STDMETHOD(QueryInterface)(REFIID riid, void ** ppvObject) = 0; <br>_ATL_DEBUG_ADDREF_RELEASE_IMPL(IObjectWithSiteImpl) <br> <br>// IObjectWithSite <br>// <br>STDMETHOD(SetSite)(IUnknown *pUnkSite) <br>{ <br>ATLTRACE(_T("IObjectWithSiteImpl::SetSite\n")); <br>T* pT = static_cast&lt;T*&gt;(this); <br>pT-&gt;m_spUnkSite = pUnkSite; <br>return S_OK; <br>} <br>STDMETHOD(GetSite)(REFIID riid, void **ppvSite) <br>{ <br>ATLTRACE(_T("IObjectWithSiteImpl::GetSite\n")); <br>T* pT = static_cast&lt;T*&gt;(this); <br>_ASSERTE(ppvSite); <br>HRESULT hRes = E_POINTER; <br>if (ppvSite != NULL) <br>{ <br>if (pT-&gt;m_spUnkSite) <br>hRes = pT-&gt;m_spUnkSite-&gt;QueryInterface(riid, ppvSite); <br>else <br>{ <br>*ppvSite = NULL; <br>hRes = E_FAIL; <br>} <br>} <br>return hRes; <br>} <br> <br>CComPtr&lt;IUnknown&gt; m_spUnkSite; <br>}; <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// IDispatchImpl <br> <br>template &lt;class T, const IID* piid, const GUID* plibid, WORD wMajor = 1, <br>WORD wMinor = 0, class tihclass = CComTypeInfoHolder&gt; <br>class ATL_NO_VTABLE IDispatchImpl : public T <br>{ <br>public: <br>typedef tihclass _tihclass; <br>IDispatchImpl() {_tih.AddRef();} <br>~IDispatchImpl() {_tih.Release();} <br> <br>STDMETHOD(GetTypeInfoCount)(UINT* pctinfo) <br>{*pctinfo = 1; return S_OK;} <br> <br>STDMETHOD(GetTypeInfo)(UINT itinfo, LCID lcid, ITypeInfo** pptinfo) <br>{return _tih.GetTypeInfo(itinfo, lcid, pptinfo);} <br> <br>STDMETHOD(GetIDsOfNames)(REFIID riid, LPOLESTR* rgszNames, UINT cNames, <br>LCID lcid, DISPID* rgdispid) <br>{return _tih.GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid);} <br> <br>STDMETHOD(Invoke)(DISPID dispidMember, REFIID riid, <br>LCID lcid, WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult, <br>EXCEPINFO* pexcepinfo, UINT* puArgErr) <br>{return _tih.Invoke((IDispatch*)this, dispidMember, riid, lcid, <br>wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr);} <br>protected: <br>static _tihclass _tih; <br>static HRESULT GetTI(LCID lcid, ITypeInfo** ppInfo) <br>{return _tih.GetTI(lcid, ppInfo);} <br>}; <br> <br>template &lt;class T, const IID* piid, const GUID* plibid, WORD wMajor = 1, <br>WORD wMinor = 0, class tihclass = CComTypeInfoHolder&gt; <br>IDispatchImpl&lt;T, piid, plibid, wMajor, wMinor, tihclass&gt;::_tihclass <br>IDispatchImpl&lt;T, piid, plibid, wMajor, wMinor, tihclass&gt;::_tih = <br>{piid, plibid, wMajor, wMinor, NULL, 0}; <br> <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// IProvideClassInfoImpl <br> <br>template &lt;const CLSID* pcoclsid, const IID* psrcid, const GUID* plibid, <br>WORD wMajor = 1, WORD wMinor = 0, class tihclass = CComTypeInfoHolder&gt; <br>class ATL_NO_VTABLE IProvideClassInfo2Impl : public IProvideClassInfo2 <br>{ <br>public: <br>typedef tihclass _tihclass; <br>IProvideClassInfo2Impl() {_tih.AddRef();} <br>~IProvideClassInfo2Impl() {_tih.Release();} <br> <br>STDMETHOD(GetClassInfo)(ITypeInfo** pptinfo) <br>{ <br>return _tih.GetTypeInfo(0, LANG_NEUTRAL, pptinfo); <br>} <br>STDMETHOD(GetGUID)(DWORD dwGuidKind, GUID* pGUID) <br>{ <br>if (pGUID == NULL) <br>return E_POINTER; <br> <br>if (dwGuidKind == GUIDKIND_DEFAULT_SOURCE_DISP_IID &amp;&amp; psrcid) <br>{ <br>*pGUID = *psrcid; <br>return S_OK; <br>} <br>*pGUID = GUID_NULL; <br>return E_FAIL; <br>} <br> <br>protected: <br>static _tihclass _tih; <br>}; <br> <br> <br>template &lt;const CLSID* pcoclsid, const IID* psrcid, const GUID* plibid, <br>WORD wMajor = 1, WORD wMinor = 0, class tihclass = CComTypeInfoHolder&gt; <br>IProvideClassInfo2Impl&lt;pcoclsid, psrcid, plibid, wMajor, wMinor, tihclass&gt;::_tihclass <br>IProvideClassInfo2Impl&lt;pcoclsid, psrcid, plibid, wMajor, wMinor, tihclass&gt;::_tih = <br>{pcoclsid,plibid, wMajor, wMinor, NULL, 0}; <br> <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// ISupportErrorInfoImpl <br> <br>template &lt;const IID* piid&gt; <br>class ATL_NO_VTABLE ISupportErrorInfoImpl : public ISupportErrorInfo <br>{ <br>public: <br>STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid)\ <br>{return (InlineIsEqualGUID(riid,*piid)) ? S_OK : S_FALSE;} <br>}; <br> <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// CComEnumImpl <br> <br>// These _CopyXXX classes are used with enumerators in order to control <br>// how enumerated items are initialized, copied, and deleted <br> <br>// Default is shallow copy with no special init or cleanup <br>template &lt;class T&gt; <br>class _Copy <br>{ <br>public: <br>static void copy(T* p1, T* p2) {memcpy(p1, p2, sizeof(T));} <br>static void init(T*) {} <br>static void destroy(T*) {} <br>}; <br> <br>#if _MSC_VER&gt;1020 <br>template&lt;&gt; <br>#endif <br>class _Copy&lt;VARIANT&gt; <br>{ <br>public: <br>static void copy(VARIANT* p1, VARIANT* p2) {VariantCopy(p1, p2);} <br>static void init(VARIANT* p) {VariantInit(p);} <br>static void destroy(VARIANT* p) {VariantClear(p);} <br>}; <br> <br>#if _MSC_VER&gt;1020 <br>template&lt;&gt; <br>#endif <br>class _Copy&lt;LPOLESTR&gt; <br>{ <br>public: <br>static void copy(LPOLESTR* p1, LPOLESTR* p2) <br>{ <br>(*p1) = (LPOLESTR)CoTaskMemAlloc(sizeof(OLECHAR)*(ocslen(*p2)+1)); <br>ocscpy(*p1,*p2); <br>} <br>static void init(LPOLESTR* p) {*p = NULL;} <br>static void destroy(LPOLESTR* p) { CoTaskMemFree(*p);} <br>}; <br> <br>#if _MSC_VER&gt;1020 <br>template&lt;&gt; <br>#endif <br>class _Copy&lt;OLEVERB&gt; <br>{ <br>public: <br>static void copy(OLEVERB* p1, OLEVERB* p2) <br>{ <br>*p1 = *p2; <br>if (p1-&gt;lpszVerbName == NULL) <br>return; <br>p1-&gt;lpszVerbName = (LPOLESTR)CoTaskMemAlloc(sizeof(OLECHAR)*(ocslen(p2-&gt;lpszVerbName)+1)); <br>ocscpy(p1-&gt;lpszVerbName,p2-&gt;lpszVerbName); <br>} <br>static void init(OLEVERB* p) { p-&gt;lpszVerbName = NULL;} <br>static void destroy(OLEVERB* p) { if (p-&gt;lpszVerbName) CoTaskMemFree(p-&gt;lpszVerbName);} <br>}; <br> <br>#if _MSC_VER&gt;1020 <br>template&lt;&gt; <br>#endif <br>class _Copy&lt;CONNECTDATA&gt; <br>{ <br>public: <br>static void copy(CONNECTDATA* p1, CONNECTDATA* p2) <br>{ <br>*p1 = *p2; <br>if (p1-&gt;pUnk) <br>p1-&gt;pUnk-&gt;AddRef(); <br>} <br>static void init(CONNECTDATA* ) {} <br>static void destroy(CONNECTDATA* p) {if (p-&gt;pUnk) p-&gt;pUnk-&gt;Release();} <br>}; <br> <br>template &lt;class T&gt; <br>class _CopyInterface <br>{ <br>public: <br>static void copy(T** p1, T** p2) <br>{*p1 = *p2;if (*p1) (*p1)-&gt;AddRef();} <br>static void init(T** ) {} <br>static void destroy(T** p) {if (*p) (*p)-&gt;Release();} <br>}; <br> <br>template&lt;class T&gt; <br>class ATL_NO_VTABLE CComIEnum : public IUnknown <br>{ <br>public: <br>STDMETHOD(Next)(ULONG celt, T* rgelt, ULONG* pceltFetched) = 0; <br>STDMETHOD(Skip)(ULONG celt) = 0; <br>STDMETHOD(Reset)(void) = 0; <br>STDMETHOD(Clone)(CComIEnum&lt;T&gt;** ppEnum) = 0; <br>}; <br> <br> <br>enum CComEnumFlags <br>{ <br>//see FlagBits in CComEnumImpl <br>AtlFlagNoCopy = 0, <br>AtlFlagTakeOwnership = 2, <br>AtlFlagCopy = 3 // copy implies ownership <br>}; <br> <br>template &lt;class Base, const IID* piid, class T, class Copy&gt; <br>class ATL_NO_VTABLE CComEnumImpl : public Base <br>{ <br>public: <br>CComEnumImpl() {m_begin = m_end = m_iter = NULL; m_dwFlags = 0; m_pUnk = NULL;} <br>~CComEnumImpl(); <br>STDMETHOD(Next)(ULONG celt, T* rgelt, ULONG* pceltFetched); <br>STDMETHOD(Skip)(ULONG celt); <br>STDMETHOD(Reset)(void){m_iter = m_begin;return S_OK;} <br>STDMETHOD(Clone)(Base** ppEnum); <br>HRESULT Init(T* begin, T* end, IUnknown* pUnk, <br>CComEnumFlags flags = AtlFlagNoCopy); <br>IUnknown* m_pUnk; <br>T* m_begin; <br>T* m_end; <br>T* m_iter; <br>DWORD m_dwFlags; <br>protected: <br>enum FlagBits <br>{ <br>BitCopy=1, <br>BitOwn=2 <br>}; <br>}; <br> <br>template &lt;class Base, const IID* piid, class T, class Copy&gt; <br>CComEnumImpl&lt;Base, piid, T, Copy&gt;::~CComEnumImpl() <br>{ <br>if (m_dwFlags &amp; BitOwn) <br>{ <br>for (T* p = m_begin; p != m_end; p++) <br>Copy::destroy(p); <br>delete [] m_begin; <br>} <br>if (m_pUnk) <br>m_pUnk-&gt;Release(); <br>} <br> <br>template &lt;class Base, const IID* piid, class T, class Copy&gt; <br>STDMETHODIMP CComEnumImpl&lt;Base, piid, T, Copy&gt;::Next(ULONG celt, T* rgelt, <br>ULONG* pceltFetched) <br>{ <br>if (rgelt == NULL || (celt != 1 &amp;&amp; pceltFetched == NULL)) <br>return E_POINTER; <br>if (m_begin == NULL || m_end == NULL || m_iter == NULL) <br>return E_FAIL; <br>ULONG nRem = (ULONG)(m_end - m_iter); <br>HRESULT hRes = S_OK; <br>if (nRem &lt; celt) <br>hRes = S_FALSE; <br>ULONG nMin = min(celt, nRem); <br>if (pceltFetched != NULL) <br>*pceltFetched = nMin; <br>while(nMin--) <br>Copy::copy(rgelt++, m_iter++); <br>return hRes; <br>} <br> <br>template &lt;class Base, const IID* piid, class T, class Copy&gt; <br>STDMETHODIMP CComEnumImpl&lt;Base, piid, T, Copy&gt;::Skip(ULONG celt) <br>{ <br>m_iter += celt; <br>if (m_iter &lt; m_end) <br>return S_OK; <br>m_iter = m_end; <br>return S_FALSE; <br>} <br> <br>template &lt;class Base, const IID* piid, class T, class Copy&gt; <br>STDMETHODIMP CComEnumImpl&lt;Base, piid, T, Copy&gt;::Clone(Base** ppEnum) <br>{ <br>typedef CComObject&lt;CComEnum&lt;Base, piid, T, Copy&gt; &gt; _class; <br>HRESULT hRes = E_POINTER; <br>if (ppEnum != NULL) <br>{ <br>_class* p = NULL; <br>ATLTRY(p = new _class) <br>if (p == NULL) <br>{ <br>*ppEnum = NULL; <br>hRes = E_OUTOFMEMORY; <br>} <br>else <br>{ <br>// If the data is a copy then we need to keep "this" object around <br>hRes = p-&gt;Init(m_begin, m_end, (m_dwFlags &amp; BitCopy) ? this : m_pUnk); <br>if (FAILED(hRes)) <br>delete p; <br>else <br>{ <br>p-&gt;m_iter = m_iter; <br>hRes = p-&gt;_InternalQueryInterface(*piid, (void**)ppEnum); <br>if (FAILED(hRes)) <br>delete p; <br>} <br>} <br>} <br>return hRes; <br>} <br> <br>template &lt;class Base, const IID* piid, class T, class Copy&gt; <br>HRESULT CComEnumImpl&lt;Base, piid, T, Copy&gt;::Init(T* begin, T* end, IUnknown* pUnk, <br>CComEnumFlags flags) <br>{ <br>if (flags == AtlFlagCopy) <br>{ <br>_ASSERTE(m_begin == NULL); //Init called twice? <br>ATLTRY(m_begin = new T[end-begin]) <br>m_iter = m_begin; <br>if (m_begin == NULL) <br>return E_OUTOFMEMORY; <br>for (T* i=begin; i != end; i++) <br>{ <br>Copy::init(m_iter); <br>Copy::copy(m_iter++, i); <br>} <br>m_end = m_begin + (end-begin); <br>} <br>else <br>{ <br>m_begin = begin; <br>m_end = end; <br>} <br>m_pUnk = pUnk; <br>if (m_pUnk) <br>m_pUnk-&gt;AddRef(); <br>m_iter = m_begin; <br>m_dwFlags = flags; <br>return S_OK; <br>} <br> <br>template &lt;class Base, const IID* piid, class T, class Copy, class ThreadModel = CComObjectThreadModel&gt; <br>class ATL_NO_VTABLE CComEnum : <br>public CComEnumImpl&lt;Base, piid, T, Copy&gt;, <br>public CComObjectRootEx&lt; ThreadModel &gt; <br>{ <br>public: <br>typedef CComEnum&lt;Base, piid, T, Copy &gt; _CComEnum; <br>typedef CComEnumImpl&lt;Base, piid, T, Copy &gt; _CComEnumBase; <br>BEGIN_COM_MAP(_CComEnum) <br>COM_INTERFACE_ENTRY_IID(*piid, _CComEnumBase) <br>END_COM_MAP() <br>}; <br> <br>#ifndef _ATL_NO_CONNECTION_POINTS <br>///////////////////////////////////////////////////////////////////////////// <br>// Connection Points <br> <br>struct _ATL_CONNMAP_ENTRY <br>{ <br>DWORD dwOffset; <br>}; <br> <br> <br>// We want the offset of the connection point relative to the connection <br>// point container base class <br>#define BEGIN_CONNECTION_POINT_MAP(x)\ <br>typedef x _atl_conn_classtype;\ <br>static const _ATL_CONNMAP_ENTRY* GetConnMap(int* pnEntries) {\ <br>static const _ATL_CONNMAP_ENTRY _entries[] = { <br>// CONNECTION_POINT_ENTRY computes the offset of the connection point to the <br>// IConnectionPointContainer interface <br>#define CONNECTION_POINT_ENTRY(iid){offsetofclass(_ICPLocator&lt;&amp;iid&gt;, _atl_conn_classtype)-\ <br>offsetofclass(IConnectionPointContainerImpl&lt;_atl_conn_classtype&gt;, _atl_conn_classtype)}, <br>#define END_CONNECTION_POINT_MAP() {(DWORD)-1} }; \ <br>if (pnEntries) *pnEntries = sizeof(_entries)/sizeof(_ATL_CONNMAP_ENTRY) - 1; \ <br>return _entries;} <br> <br> <br>#ifndef _DEFAULT_VECTORLENGTH <br>#define _DEFAULT_VECTORLENGTH 4 <br>#endif <br> <br>template &lt;unsigned int nMaxSize&gt; <br>class CComUnkArray <br>{ <br>public: <br>CComUnkArray() <br>{ <br>memset(m_arr, 0, sizeof(IUnknown*)*nMaxSize); <br>} <br>DWORD Add(IUnknown* pUnk); <br>BOOL Remove(DWORD dwCookie); <br>static DWORD WINAPI GetCookie(IUnknown** pp) <br>{ <br>return (DWORD)pp; <br>} <br>static IUnknown* WINAPI GetUnknown(DWORD dwCookie) <br>{ <br>return dwCookie ? *(IUnknown**)dwCookie : 0; <br>} <br>IUnknown** begin() <br>{ <br>return &amp;m_arr[0]; <br>} <br>IUnknown** end() <br>{ <br>return &amp;m_arr[nMaxSize]; <br>} <br>protected: <br>IUnknown* m_arr[nMaxSize]; <br>}; <br> <br>template &lt;unsigned int nMaxSize&gt; <br>inline DWORD CComUnkArray&lt;nMaxSize&gt;::Add(IUnknown* pUnk) <br>{ <br>for (IUnknown** pp = begin();pp&lt;end();pp++) <br>{ <br>if (*pp == NULL) <br>{ <br>*pp = pUnk; <br>return (DWORD)pp; // return cookie <br>} <br>} <br>// If this fires then you need a larger array <br>_ASSERTE(0); <br>return 0; <br>} <br> <br>template &lt;unsigned int nMaxSize&gt; <br>inline BOOL CComUnkArray&lt;nMaxSize&gt;::Remove(DWORD dwCookie) <br>{ <br>IUnknown** pp = (IUnknown**)dwCookie; <br>BOOL b = ((pp &gt;= begin()) &amp;&amp; (pp &lt; end())); <br>if (b) <br>*pp = NULL; <br>return b; <br>} <br> <br>#if _MSC_VER&gt;1020 <br>template&lt;&gt; <br>#endif <br>class CComUnkArray&lt;1&gt; <br>{ <br>public: <br>CComUnkArray() <br>{ <br>m_arr[0] = NULL; <br>} <br>DWORD Add(IUnknown* pUnk) <br>{ <br>if (m_arr[0] != NULL) <br>{ <br>// If this fires then you need a larger array <br>_ASSERTE(0); <br>return 0; <br>} <br>m_arr[0] = pUnk; <br>return (DWORD)&amp;m_arr[0]; <br>} <br>BOOL Remove(DWORD dwCookie) <br>{ <br>if (dwCookie != (DWORD)&amp;m_arr[0]) <br>return FALSE; <br>m_arr[0] = NULL; <br>return TRUE; <br>} <br>static DWORD WINAPI GetCookie(IUnknown** pp) <br>{ <br>return (DWORD)pp; <br>} <br>static IUnknown* WINAPI GetUnknown(DWORD dwCookie) <br>{ <br>return dwCookie ? *(IUnknown**)dwCookie : 0; <br>} <br>IUnknown** begin() <br>{ <br>return &amp;m_arr[0]; <br>} <br>IUnknown** end() <br>{ <br>return (&amp;m_arr[0])+1; <br>} <br>protected: <br>IUnknown* m_arr[1]; <br>}; <br> <br>class CComDynamicUnkArray <br>{ <br>public: <br>CComDynamicUnkArray() <br>{ <br>m_nSize = 0; <br>m_ppUnk = NULL; <br>} <br> <br>~CComDynamicUnkArray() <br>{ <br>if (m_nSize &gt; 1) <br>free(m_ppUnk); <br>} <br>DWORD Add(IUnknown* pUnk); <br>BOOL Remove(DWORD dwCookie); <br>static DWORD WINAPI GetCookie(IUnknown** pp) <br>{ <br>return (DWORD)*pp; <br>} <br>static IUnknown* WINAPI GetUnknown(DWORD dwCookie) <br>{ <br>return (IUnknown*)dwCookie; <br>} <br>IUnknown** begin() <br>{ <br>return (m_nSize &lt; 2) ? &amp;m_pUnk : m_ppUnk; <br>} <br>IUnknown** end() <br>{ <br>return (m_nSize &lt; 2) ? (&amp;m_pUnk)+m_nSize : &amp;m_ppUnk[m_nSize]; <br>} <br>protected: <br>union <br>{ <br>IUnknown** m_ppUnk; <br>IUnknown* m_pUnk; <br>}; <br>int m_nSize; <br>}; <br> <br>template &lt;const IID* piid&gt; <br>class ATL_NO_VTABLE _ICPLocator <br>{ <br>//this method needs a different name than QueryInterface <br>STDMETHOD(_LocCPQueryInterface)(REFIID riid, void ** ppvObject) = 0; <br>}; <br> <br>template &lt;class T, const IID* piid, class CDV = CComDynamicUnkArray &gt; <br>class ATL_NO_VTABLE IConnectionPointImpl : public _ICPLocator&lt;piid&gt; <br>{ <br>typedef CComEnum&lt;IEnumConnections, &amp;IID_IEnumConnections, CONNECTDATA, <br>_Copy&lt;CONNECTDATA&gt; &gt; CComEnumConnections; <br>typedef CDV _CDV; <br>public: <br>STDMETHOD(_LocCPQueryInterface)(REFIID riid, void ** ppvObject) <br>{ <br>if (InlineIsEqualGUID(riid, IID_IConnectionPoint) || InlineIsEqualGUID(riid, IID_IUnknown)) <br>{ <br>*ppvObject = this; <br>#ifdef _ATL_DEBUG_REFCOUNT <br>_DebugAddRef(); <br>#else <br>AddRef(); <br>#endif <br>return S_OK; <br>} <br>else <br>return E_NOINTERFACE; <br>} <br>_ATL_DEBUG_ADDREF_RELEASE_IMPL(IConnectionPointImpl) <br> <br>STDMETHOD(GetConnectionInterface)(IID* piid2) <br>{ <br>if (piid2 == NULL) <br>return E_POINTER; <br>*piid2 = *piid; <br>return S_OK; <br>} <br>STDMETHOD(GetConnectionPointContainer)(IConnectionPointContainer** ppCPC) <br>{ <br>if (ppCPC == NULL) <br>return E_POINTER; <br>*ppCPC = reinterpret_cast&lt;IConnectionPointContainer*&gt;( <br>(IConnectionPointContainerImpl&lt;T&gt;*)(T*)this); <br>return S_OK; <br>} <br>STDMETHOD(Advise)(IUnknown* pUnkSink, DWORD* pdwCookie); <br>STDMETHOD(Unadvise)(DWORD dwCookie); <br>STDMETHOD(EnumConnections)(IEnumConnections** ppEnum); <br>CDV m_vec; <br>}; <br> <br>template &lt;class T, const IID* piid, class CDV&gt; <br>STDMETHODIMP IConnectionPointImpl&lt;T, piid, CDV&gt;::Advise(IUnknown* pUnkSink, <br>DWORD* pdwCookie) <br>{ <br>T* pT = (T*)this; <br>IUnknown* p; <br>HRESULT hRes = S_OK; <br>if (pUnkSink == NULL || pdwCookie == NULL) <br>return E_POINTER; <br>IID iid; <br>GetConnectionInterface(&amp;iid); <br>hRes = pUnkSink-&gt;QueryInterface(iid, (void**)&amp;p); <br>if (SUCCEEDED(hRes)) <br>{ <br>pT-&gt;Lock(); <br>*pdwCookie = m_vec.Add(p); <br>hRes = (*pdwCookie != NULL) ? S_OK : CONNECT_E_ADVISELIMIT; <br>pT-&gt;Unlock(); <br>if (hRes != S_OK) <br>{ <br>*pdwCookie = 0; <br>p-&gt;Release(); <br>} <br>} <br>else if (hRes == E_NOINTERFACE) <br>hRes = CONNECT_E_CANNOTCONNECT; <br>return hRes; <br>} <br> <br>template &lt;class T, const IID* piid, class CDV&gt; <br>STDMETHODIMP IConnectionPointImpl&lt;T, piid, CDV&gt;::Unadvise(DWORD dwCookie) <br>{ <br>T* pT = (T*)this; <br>pT-&gt;Lock(); <br>IUnknown* p = _CDV::GetUnknown(dwCookie); <br>HRESULT hRes = m_vec.Remove(dwCookie) ? S_OK : CONNECT_E_NOCONNECTION; <br>pT-&gt;Unlock(); <br>if (hRes == S_OK &amp;&amp; p != NULL) <br>p-&gt;Release(); <br>return hRes; <br>} <br> <br>template &lt;class T, const IID* piid, class CDV&gt; <br>STDMETHODIMP IConnectionPointImpl&lt;T, piid, CDV&gt;::EnumConnections( <br>IEnumConnections** ppEnum) <br>{ <br>if (ppEnum == NULL) <br>return E_POINTER; <br>*ppEnum = NULL; <br>CComObject&lt;CComEnumConnections&gt;* pEnum = NULL; <br>ATLTRY(pEnum = new CComObject&lt;CComEnumConnections&gt;) <br>if (pEnum == NULL) <br>return E_OUTOFMEMORY; <br>T* pT = (T*)this; <br>pT-&gt;Lock(); <br>CONNECTDATA* pcd = NULL; <br>ATLTRY(pcd = new CONNECTDATA[m_vec.end()-m_vec.begin()]) <br>if (pcd == NULL) <br>{ <br>delete pEnum; <br>pT-&gt;Unlock(); <br>return E_OUTOFMEMORY; <br>} <br>CONNECTDATA* pend = pcd; <br>// Copy the valid CONNECTDATA's <br>for (IUnknown** pp = m_vec.begin();pp&lt;m_vec.end();pp++) <br>{ <br>if (*pp != NULL) <br>{ <br>(*pp)-&gt;AddRef(); <br>pend-&gt;pUnk = *pp; <br>pend-&gt;dwCookie = _CDV::GetCookie(pp); <br>pend++; <br>} <br>} <br>// don't copy the data, but transfer ownership to it <br>pEnum-&gt;Init(pcd, pend, NULL, AtlFlagTakeOwnership); <br>pT-&gt;Unlock(); <br>HRESULT hRes = pEnum-&gt;_InternalQueryInterface(IID_IEnumConnections, (void**)ppEnum); <br>if (FAILED(hRes)) <br>delete pEnum; <br>return hRes; <br>} <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// IConnectionPointContainerImpl <br> <br>template &lt;class T&gt; <br>class ATL_NO_VTABLE IConnectionPointContainerImpl <br>{ <br>typedef CComEnum&lt;IEnumConnectionPoints, <br>&amp;IID_IEnumConnectionPoints, IConnectionPoint*, <br>_CopyInterface&lt;IConnectionPoint&gt; &gt; <br>CComEnumConnectionPoints; <br>public: <br>// IUnknown <br>// <br>STDMETHOD(QueryInterface)(REFIID riid, void ** ppvObject) = 0; <br>_ATL_DEBUG_ADDREF_RELEASE_IMPL(IConnectionPointContainerImpl) <br> <br>STDMETHOD(EnumConnectionPoints)(IEnumConnectionPoints** ppEnum) <br>{ <br>if (ppEnum == NULL) <br>return E_POINTER; <br>*ppEnum = NULL; <br>CComEnumConnectionPoints* pEnum = NULL; <br>ATLTRY(pEnum = new CComObject&lt;CComEnumConnectionPoints&gt;) <br>if (pEnum == NULL) <br>return E_OUTOFMEMORY; <br> <br>int nCPCount; <br>const _ATL_CONNMAP_ENTRY* pEntry = T::GetConnMap(&amp;nCPCount); <br>_ASSERTE(nCPCount &gt; 0); <br> <br>// allocate an initialize a vector of connection point object pointers <br>IConnectionPoint** ppCP = (IConnectionPoint**)alloca(sizeof(IConnectionPoint*)*nCPCount); <br> <br>int i = 0; <br>while (pEntry-&gt;dwOffset != (DWORD)-1) <br>{ <br>ppCP[i++] = (IConnectionPoint*)((int)this+pEntry-&gt;dwOffset); <br>pEntry++; <br>} <br> <br>// copy the pointers: they will AddRef this object <br>HRESULT hRes = pEnum-&gt;Init((IConnectionPoint**)&amp;ppCP[0], <br>(IConnectionPoint**)&amp;ppCP[nCPCount], <br>reinterpret_cast&lt;IConnectionPointContainer*&gt;(this), AtlFlagCopy); <br>if (FAILED(hRes)) <br>{ <br>delete pEnum; <br>return hRes; <br>} <br>hRes = pEnum-&gt;QueryInterface(IID_IEnumConnectionPoints, (void**)ppEnum); <br>if (FAILED(hRes)) <br>delete pEnum; <br>return hRes; <br>} <br>STDMETHOD(FindConnectionPoint)(REFIID riid, IConnectionPoint** ppCP) <br>{ <br>if (ppCP == NULL) <br>return E_POINTER; <br>*ppCP = NULL; <br>HRESULT hRes = CONNECT_E_NOCONNECTION; <br>const _ATL_CONNMAP_ENTRY* pEntry = T::GetConnMap(NULL); <br>IID iid; <br>while (pEntry-&gt;dwOffset != (DWORD)-1) <br>{ <br>IConnectionPoint* pCP = <br>(IConnectionPoint*)((int)this+pEntry-&gt;dwOffset); <br>if (SUCCEEDED(pCP-&gt;GetConnectionInterface(&amp;iid)) &amp;&amp; <br>InlineIsEqualGUID(riid, iid)) <br>{ <br>*ppCP = pCP; <br>pCP-&gt;AddRef(); <br>hRes = S_OK; <br>break; <br>} <br>pEntry++; <br>} <br>return hRes; <br>} <br>}; <br> <br> <br>#endif //!_ATL_NO_CONNECTION_POINTS <br> <br>#pragma pack(pop) <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// CComAutoThreadModule <br> <br>template &lt;class ThreadAllocator&gt; <br>inline void CComAutoThreadModule&lt;ThreadAllocator&gt;::Init(_ATL_OBJMAP_ENTRY* p, HINSTANCE h, int nThreads) <br>{ <br>m_nThreads = nThreads; <br>m_pApartments = new CComApartment[m_nThreads]; <br>for (int i = 0; i &lt; nThreads; i++) <br>m_pApartments[i].m_hThread = CreateThread(NULL, 0, CComApartment::_Apartment, (void*)&amp;m_pApartments[i], 0, &amp;m_pApartments[i].m_dwThreadID); <br>CComApartment::ATL_CREATE_OBJECT = RegisterWindowMessage(_T("ATL_CREATE_OBJECT")); <br>CComModule::Init(p, h); <br>} <br> <br>template &lt;class ThreadAllocator&gt; <br>inline LONG CComAutoThreadModule&lt;ThreadAllocator&gt;::Lock() <br>{ <br>LONG l = CComModule::Lock(); <br>DWORD dwThreadID = GetCurrentThreadId(); <br>for (int i=0; i &lt; m_nThreads; i++) <br>{ <br>if (m_pApartments[i].m_dwThreadID == dwThreadID) <br>{ <br>m_pApartments[i].Lock(); <br>break; <br>} <br>} <br>return l; <br>} <br> <br>template &lt;class ThreadAllocator&gt; <br>inline LONG CComAutoThreadModule&lt;ThreadAllocator&gt;::Unlock() <br>{ <br>LONG l = CComModule::Unlock(); <br>DWORD dwThreadID = GetCurrentThreadId(); <br>for (int i=0; i &lt; m_nThreads; i++) <br>{ <br>if (m_pApartments[i].m_dwThreadID == dwThreadID) <br>{ <br>m_pApartments[i].Unlock(); <br>break; <br>} <br>} <br>return l; <br>} <br> <br>template &lt;class ThreadAllocator&gt; <br>HRESULT CComAutoThreadModule&lt;ThreadAllocator&gt;::CreateInstance(void* pfnCreateInstance, REFIID riid, void** ppvObj) <br>{ <br>_ATL_CREATORFUNC* pFunc = (_ATL_CREATORFUNC*) pfnCreateInstance; <br>_AtlAptCreateObjData data; <br>data.pfnCreateInstance = pFunc; <br>data.piid = &amp;riid; <br>data.hEvent = CreateEvent(NULL, FALSE, FALSE, NULL); <br>data.hRes = S_OK; <br>int nThread = m_Allocator.GetThread(m_pApartments, m_nThreads); </code></pre>
<p>
</p>
<pre><code>::PostThreadMessage(m_pApartments[nThread].m_dwThreadID, CComApartment::ATL_CREATE_OBJECT, 0, (LPARAM)&amp;data); <br>AtlWaitWithMessageLoop(data.hEvent); <br>CloseHandle(data.hEvent); <br>if (SUCCEEDED(data.hRes)) <br>data.hRes = CoGetInterfaceAndReleaseStream(data.pStream, riid, ppvObj); <br>return data.hRes; <br>} <br> <br>template &lt;class ThreadAllocator&gt; <br>CComAutoThreadModule&lt;ThreadAllocator&gt;::~CComAutoThreadModule() <br>{ <br>for (int i=0; i &lt; m_nThreads; i++) <br>{ <br>::PostThreadMessage(m_pApartments[i].m_dwThreadID, WM_QUIT, 0, 0); <br>::WaitForSingleObject(m_pApartments[i].m_hThread, INFINITE); <br>} <br>delete[] m_pApartments; <br>} <br> <br> <br>#ifndef ATL_NO_NAMESPACE <br>}; //namespace ATL <br>#endif <br> <br>#endif // __ATLCOM_H__ <br> <br>///////////////////////////////////////////////////////////////////////////// </code></pre>
<p>&nbsp;</p></body>
</HTML>
