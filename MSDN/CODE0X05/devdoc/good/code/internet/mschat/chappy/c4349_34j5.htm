<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>FLATTB.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context4361"></a>FLATTB.CPP</h2>
<pre><code>//**************************************************************************** <br>//  Module:     Chappy.EXE <br>//  File:       FlatTB.cpp <br>//               <br>// <br>//  Copyright (c) Microsoft Corporation 1996-1997 <br>// <br>// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF  <br>// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO  <br>// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A  <br>// PARTICULAR PURPOSE. <br>//**************************************************************************** <br> <br>#include "stdafx.h" <br>#define _AFX_NO_OLE_SUPPORT <br>#include &lt;afxpriv.h&gt; <br>#include "flatTB.h" <br> <br>#ifdef _DEBUG <br>#undef THIS_FILE <br>static char THIS_FILE[] = __FILE__; <br>#endif <br> <br>#define new DEBUG_NEW <br> <br>// globals for fast drawing (shared globals) <br>#ifndef _MAC <br>static HDC hDCGlyphs = NULL; <br>static HDC hDCMono = NULL; <br>#else <br>#define hDCGlyphs   m_hDCGlyphs <br>#define hDCMono     m_hDCMono <br>#endif <br>static HBRUSH hbrDither = NULL; <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// Init / Term <br> <br>#ifndef _MAC <br>static HBITMAP AFXAPI CreateDitherBitmap(); <br>#else <br>static HBITMAP AFXAPI CreateDitherBitmap(BOOL bMonochrome); <br>#endif <br> <br>#ifdef AFX_INIT_SEG <br>#pragma code_seg(AFX_INIT_SEG) <br>#endif <br> <br> <br> <br>// a special struct that will cleanup automatically <br>struct _AFX_TOOLBAR_TERM <br>{ <br>~_AFX_TOOLBAR_TERM() <br>{ <br>#ifndef _MAC <br>AfxDeleteObject((HGDIOBJ*)&amp;hDCMono); <br>AfxDeleteObject((HGDIOBJ*)&amp;hDCGlyphs); <br>#endif <br>AfxDeleteObject((HGDIOBJ*)&amp;hbrDither); <br>} <br>}; <br> <br>static const _AFX_TOOLBAR_TERM toolbarTerm; <br> <br>///////////////////////////////////////////////////////////////////////////// <br> <br>#ifdef AFX_CORE3_SEG <br>#pragma code_seg(AFX_CORE3_SEG) <br>#endif <br> <br>// TONYCL: START: OFFICE97 LOOK AND FEEL <br> <br>struct CToolBarData <br>{ <br>WORD wVersion; <br>WORD wWidth; <br>WORD wHeight; <br>WORD wItemCount; <br>//WORD aItems[wItemCount] <br> <br>WORD* items() <br>{ return (WORD*)(this+1); } <br>}; <br> <br>// Support loading a toolbar from a resource <br>BOOL CFlatToolbar::LoadToolBar(LPCTSTR lpszResourceName) <br>{ <br>ASSERT_VALID(this); <br>ASSERT(lpszResourceName != NULL); <br> <br>// determine location of the bitmap in resource fork <br>HINSTANCE hInst = AfxFindResourceHandle(lpszResourceName, RT_TOOLBAR); <br>HRSRC hRsrc = ::FindResource(hInst, lpszResourceName, RT_TOOLBAR); <br>if (hRsrc == NULL) <br>return FALSE; <br> <br>HGLOBAL hGlobal = LoadResource(hInst, hRsrc); <br>if (hGlobal == NULL) <br>return FALSE; <br> <br>CToolBarData* pData = (CToolBarData*)LockResource(hGlobal); <br>if (pData == NULL) <br>return FALSE; <br>ASSERT(pData-&gt;wVersion == 1); <br> <br>UINT* pItems = new UINT[pData-&gt;wItemCount]; <br>for (int i = 0; i &lt; pData-&gt;wItemCount; i++) <br>pItems[i] = pData-&gt;items()[i]; <br>BOOL bResult = SetButtons(pItems, pData-&gt;wItemCount); <br>delete[] pItems; <br> <br>if (bResult) <br>{ <br>// set new sizes of the buttons <br>CSize sizeImage(pData-&gt;wWidth, pData-&gt;wHeight); <br>CSize sizeButton(pData-&gt;wWidth + 7, pData-&gt;wHeight + 7); <br>SetSizes(sizeButton, sizeImage); <br> <br>// load bitmap now that sizes are known by the toolbar control <br>bResult = LoadBitmap(lpszResourceName); <br>} <br> <br>UnlockResource(hGlobal); <br>FreeResource(hGlobal); <br> <br>return bResult; <br>} <br>// TONYCL: END: OFFICE97 LOOK AND FEEL <br> <br>#ifndef _MAC <br>static HBITMAP AFXAPI CreateDitherBitmap() <br>#else <br>static HBITMAP AFXAPI CreateDitherBitmap(BOOL bMonochrome) <br>#endif <br>{ <br>struct  // BITMAPINFO with 16 colors <br>{ <br>BITMAPINFOHEADER bmiHeader; <br>RGBQUAD      bmiColors[16]; <br>} bmi; <br>memset(&amp;bmi, 0, sizeof(bmi)); <br> <br>bmi.bmiHeader.biSize = sizeof(BITMAPINFOHEADER); <br>bmi.bmiHeader.biWidth = 8; <br>bmi.bmiHeader.biHeight = 8; <br>bmi.bmiHeader.biPlanes = 1; <br>bmi.bmiHeader.biBitCount = 1; <br>bmi.bmiHeader.biCompression = BI_RGB; <br> <br>COLORREF clr = ::GetSysColor(COLOR_BTNFACE); <br>#ifdef _MAC <br>// if monochrome or the face color is already white, use black instead to make <br>// sure that we draw a dither - otherwise we'll have a white on white bitmap <br>if (bMonochrome || clr == RGB(255, 255, 255)) <br>clr = 0; <br>#endif <br>bmi.bmiColors[0].rgbBlue = GetBValue(clr); <br>bmi.bmiColors[0].rgbGreen = GetGValue(clr); <br>bmi.bmiColors[0].rgbRed = GetRValue(clr); <br> <br>clr = ::GetSysColor(COLOR_BTNHIGHLIGHT); <br>bmi.bmiColors[1].rgbBlue = GetBValue(clr); <br>bmi.bmiColors[1].rgbGreen = GetGValue(clr); <br>bmi.bmiColors[1].rgbRed = GetRValue(clr); <br> <br>// initialize the brushes <br>long patGray[8]; <br>for (int i = 0; i &lt; 8; i++) <br>   patGray[i] = (i &amp; 1) ? 0xAAAA5555L : 0x5555AAAAL; <br> <br>HDC hDC = GetDC(NULL); <br>HBITMAP hbm = CreateDIBitmap(hDC, &amp;bmi.bmiHeader, CBM_INIT, <br>(LPBYTE)patGray, (LPBITMAPINFO)&amp;bmi, DIB_RGB_COLORS); <br>ReleaseDC(NULL, hDC); <br> <br>return hbm; <br>} <br> <br>// create a mono bitmap mask: <br>void CFlatToolbar::CreateMask(int iImage, CPoint ptOffset, <br> BOOL bHilite, BOOL bHiliteShadow) <br>{ <br>// initalize whole area with 0's <br>PatBlt(hDCMono, 0, 0, m_sizeButton.cx-2, m_sizeButton.cy-2, WHITENESS); <br> <br>// create mask based on color bitmap <br>// convert this to 1's <br>SetBkColor(hDCGlyphs, globalData.clrBtnFace); <br>BitBlt(hDCMono, ptOffset.x, ptOffset.y, m_sizeImage.cx, m_sizeImage.cy, <br>hDCGlyphs, iImage * m_sizeImage.cx, 0, SRCCOPY); <br> <br>if (bHilite) <br>{ <br>// convert this to 1's <br>SetBkColor(hDCGlyphs, globalData.clrBtnHilite); <br> <br>// OR in the new 1's <br>BitBlt(hDCMono, ptOffset.x, ptOffset.y, m_sizeImage.cx, m_sizeImage.cy, <br>hDCGlyphs, iImage * m_sizeImage.cx, 0, SRCPAINT); <br> <br>if (bHiliteShadow) <br>BitBlt(hDCMono, 1, 1, m_sizeButton.cx-3, m_sizeButton.cy-3, <br>hDCMono, 0, 0, SRCAND); <br>} <br>} <br> <br>// Raster Ops <br>#define ROP_DSPDxax  0x00E20746L <br>#define ROP_PSDPxax  0x00B8074AL <br> <br>BOOL CFlatToolbar::DrawButton(CDC* pDC, int x, int y, int iImage, UINT nStyle) <br>{ <br>ASSERT_VALID(pDC); <br> <br>int dx = m_sizeButton.cx; <br>int dy = m_sizeButton.cy; <br>if (!globalData.bWin4) <br>{ <br>// make the coordinates the interior of the button <br>x += 1; <br>y += 1; <br>dx -= 2; <br>dy -= 2; <br> <br>// border around button <br>pDC-&gt;FillSolidRect(x,    y-1,    dx, 1,  globalData.clrWindowFrame); <br>pDC-&gt;FillSolidRect(x,    y+dy,   dx, 1,  globalData.clrWindowFrame); <br>pDC-&gt;FillSolidRect(x-1,  y,  1,  dy, globalData.clrWindowFrame); <br>pDC-&gt;FillSolidRect(x+dx, y,  1,  dy, globalData.clrWindowFrame); <br>} <br> <br>#ifdef _MAC <br>if (m_bMonochrome) <br>return DrawMonoButton(pDC, x, y, dx, dy, iImage, nStyle); <br>#endif <br> <br>// interior grey <br>pDC-&gt;FillSolidRect(x, y, dx, dy, globalData.clrBtnFace); <br> <br>// determine offset of bitmap (centered within button) <br>CPoint ptOffset; <br>ptOffset.x = (dx - m_sizeImage.cx - 1) / 2; <br>ptOffset.y = (dy - m_sizeImage.cy) / 2; <br> <br>if (nStyle &amp; (TBBS_PRESSED | TBBS_CHECKED)) <br>{ <br>// pressed in or checked <br>pDC-&gt;Draw3dRect(x, y, dx, dy, <br>globalData.bWin4 ? globalData.clrWindowFrame : globalData.clrBtnShadow, <br>globalData.bWin4 ? globalData.clrBtnHilite : globalData.clrBtnFace); <br> <br>/* TONYCL: OFFICE97 LOOK AND FEEL <br>if (globalData.bWin4) <br>{ <br>pDC-&gt;Draw3dRect(x + 1, y + 1, dx - 2, dy - 2, <br>globalData.clrBtnShadow, globalData.clrBtnFace); <br>} <br>*/ <br> <br>// for any depressed button, add one to the offsets. <br>ptOffset.x += 1; <br>ptOffset.y += 1; <br>} <br>// TONYCL: START: OFFICE97 LOOK AND FEEL <br>if (nStyle &amp; TBBS_UPSTATE) <br>{ <br>pDC-&gt;Draw3dRect(x, y, dx, dy, globalData.clrBtnHilite, <br>globalData.bWin4 ? globalData.clrWindowFrame : globalData.clrBtnShadow); <br>} <br>// TONYCL: END: OFFICE97 LOOK AND FEEL <br> <br>if ((nStyle &amp; TBBS_PRESSED) || !(nStyle &amp; TBBS_DISABLED)) <br>{ <br>// normal image version <br>BitBlt(pDC-&gt;m_hDC, x + ptOffset.x, y + ptOffset.y, <br>m_sizeImage.cx, m_sizeImage.cy, <br>hDCGlyphs, iImage * m_sizeImage.cx, 0, SRCCOPY); <br> <br>if (nStyle &amp; TBBS_PRESSED) <br>return TRUE;        // nothing more to do (rest of style is ignored) <br>} <br> <br>if (nStyle &amp; (TBBS_DISABLED | TBBS_INDETERMINATE)) <br>{ <br>// disabled or indeterminate version <br>CreateMask(iImage, ptOffset, TRUE, FALSE); <br> <br>pDC-&gt;SetTextColor(0L);                  // 0's in mono -&gt; 0 (for ROP) <br>pDC-&gt;SetBkColor((COLORREF)0x00FFFFFFL); // 1's in mono -&gt; 1 <br> <br>if (nStyle &amp; TBBS_DISABLED) <br>{ <br>// disabled - draw the hilighted shadow <br>HGDIOBJ hbrOld = pDC-&gt;SelectObject(globalData.hbrBtnHilite); <br>if (hbrOld != NULL) <br>{ <br>// draw hilight color where we have 0's in the mask <br>BitBlt(pDC-&gt;m_hDC, x + 1, y + 1, <br>m_sizeButton.cx - 2, m_sizeButton.cy - 2, <br>hDCMono, 0, 0, ROP_PSDPxax); <br>pDC-&gt;SelectObject(hbrOld); <br>} <br>} <br> <br>//BLOCK: always draw the shadow <br>{ <br>HGDIOBJ hbrOld = pDC-&gt;SelectObject(globalData.hbrBtnShadow); <br>if (hbrOld != NULL) <br>{ <br>// draw the shadow color where we have 0's in the mask <br>BitBlt(pDC-&gt;m_hDC, x, y, <br>m_sizeButton.cx - 2, m_sizeButton.cy - 2, <br>hDCMono, 0, 0, ROP_PSDPxax); <br>pDC-&gt;SelectObject(hbrOld); <br>} <br>} <br>} <br> <br>// if it is checked do the dither brush avoiding the glyph <br>if (nStyle &amp; (TBBS_CHECKED | TBBS_INDETERMINATE)) <br>{ <br>HGDIOBJ hbrOld = pDC-&gt;SelectObject(hbrDither); <br>if (hbrOld != NULL) <br>{ <br>ptOffset.x -= globalData.cxBorder2; <br>ptOffset.y -= globalData.cyBorder2; <br>CreateMask(iImage, ptOffset, ~(nStyle &amp; TBBS_INDETERMINATE), <br>nStyle &amp; TBBS_DISABLED); <br> <br>pDC-&gt;SetTextColor(0L);              // 0 -&gt; 0 <br>pDC-&gt;SetBkColor((COLORREF)0x00FFFFFFL); // 1 -&gt; 1 <br> <br>ASSERT(globalData.cxBorder2 == globalData.cyBorder2); <br>int delta = (nStyle &amp; TBBS_INDETERMINATE) ? <br>globalData.bWin4 ? globalData.cxBorder2*2 : 3 : globalData.cxBorder2*2; <br> <br>// only draw the dither brush where the mask is 1's <br>BitBlt(pDC-&gt;m_hDC, <br>x + globalData.cxBorder2, y + globalData.cyBorder2, dx-delta, dy-delta, <br>hDCMono, 0, 0, ROP_DSPDxax); <br>pDC-&gt;SelectObject(hbrOld); <br>} <br>} <br> <br>return TRUE; <br>} <br> <br>#ifdef _MAC <br>BOOL CFlatToolbar::DrawMonoButton(CDC* pDC, int x, int y, int dx, int dy, <br>int iImage, UINT nStyle) <br>{ <br>// interior is black if pressed, white if not <br>if (nStyle &amp; (TBBS_PRESSED | TBBS_CHECKED)) <br>{ <br>pDC-&gt;FillSolidRect(x, y, dx, dy, RGB(0, 0, 0)); <br>pDC-&gt;SetBkColor(RGB(255, 255, 255));    // bkcolor was set by PatB <br>} <br>else <br>{ <br>pDC-&gt;FillSolidRect(x, y, dx, dy, RGB(0xFF, 0xFF, 0xFF)); <br>} <br> <br>CPoint ptOffset; <br>ptOffset.x = (dx - m_sizeImage.cx - 1) / 2; <br>ptOffset.y = (dy - m_sizeImage.cy) / 2; <br> <br>if ((nStyle &amp; TBBS_PRESSED) || !(nStyle &amp; TBBS_DISABLED)) <br>{ <br>// normal image version <br>BitBlt(pDC-&gt;m_hDC, x + ptOffset.x, y + ptOffset.y, m_sizeImage.cx, <br>m_sizeImage.cy, hDCGlyphs, iImage * m_sizeImage.cx, 0, <br>(nStyle &amp; (TBBS_PRESSED | TBBS_CHECKED)) ? NOTSRCCOPY : SRCCOPY); <br> <br>if (nStyle &amp; (TBBS_PRESSED | TBBS_CHECKED)) <br>return TRUE;        // nothing more to do (rest of style is ignored) <br>} <br> <br>if (nStyle &amp; TBBS_DISABLED) <br>{ <br>BitBlt(pDC-&gt;m_hDC, x + ptOffset.x, y + ptOffset.y, m_sizeImage.cx, <br>m_sizeImage.cy, hDCGlyphs, iImage * m_sizeImage.cx, 0, SRCCOPY); <br> <br>int ropOld = pDC-&gt;SetROP2(R2_MASKNOTPEN); <br>RECT rect; <br>SetRect(&amp;rect, 0, 0, m_sizeImage.cx, m_sizeImage.cy); <br>OffsetRect(&amp;rect, x + ptOffset.x, y + ptOffset.y); <br>AfxFillRect(pDC-&gt;m_hDC, &amp;rect, hbrDither); <br>pDC-&gt;SetROP2(ropOld); <br> <br>return TRUE; <br>} <br> <br>// if it is checked do the dither brush avoiding the glyph <br>if (nStyle &amp; (TBBS_CHECKED | TBBS_INDETERMINATE)) <br>{ <br>HGDIOBJ hbrOld = pDC-&gt;SelectObject(hbrDither); <br>if (hbrOld != NULL) <br>{ <br>CreateMask(iImage, ptOffset, ~(nStyle &amp; TBBS_INDETERMINATE), <br>nStyle &amp; TBBS_DISABLED); <br> <br>pDC-&gt;SetTextColor(0L);              // 0 -&gt; 0 <br>pDC-&gt;SetBkColor((COLORREF)0x00FFFFFFL); // 1 -&gt; 1 <br> <br>int delta = (nStyle &amp; TBBS_INDETERMINATE) ? 3 : 1; <br> <br>// only draw the dither brush where the mask is 1's <br>CRect rect(0, 0, dx, dy); <br>::InvertRect(hDCMono, &amp;rect); <br> <br>BitBlt(pDC-&gt;m_hDC, x, y, dx, dy, hDCMono, 0, 0, ROP_PSDPxax); <br>pDC-&gt;SelectObject(hbrOld); <br>} <br>} <br> <br>return TRUE; <br>} <br>#endif <br> <br>BOOL CFlatToolbar::PrepareDrawButton(DrawState&amp; ds) <br>{ <br>ASSERT(m_hbmImageWell != NULL); <br>ASSERT(m_sizeButton.cx &gt; 2 &amp;&amp; m_sizeButton.cy &gt; 2); <br> <br>// We need to kick-start the bitmap selection process. <br>ds.hbmOldGlyphs = (HBITMAP)SelectObject(hDCGlyphs, m_hbmImageWell); <br>ds.hbmMono = CreateBitmap(m_sizeButton.cx-2, m_sizeButton.cy-2, <br>1, 1, NULL); <br>ds.hbmMonoOld = (HBITMAP)SelectObject(hDCMono, ds.hbmMono); <br>if (ds.hbmOldGlyphs == NULL || ds.hbmMono == NULL || ds.hbmMonoOld == NULL) <br>{ <br>TRACE0("Error: can't draw toolbar.\n"); <br>AfxDeleteObject((HGDIOBJ*)&amp;ds.hbmMono); <br>return FALSE; <br>} <br>return TRUE; <br>} <br> <br>void CFlatToolbar::EndDrawButton(DrawState&amp; ds) <br>{ <br>SelectObject(hDCMono, ds.hbmMonoOld); <br>AfxDeleteObject((HGDIOBJ*)&amp;ds.hbmMono); <br>SelectObject(hDCGlyphs, ds.hbmOldGlyphs); <br>} <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// CFlatToolbar creation etc <br> <br>struct AFX_TBBUTTON <br>{ <br>UINT nID;        // Command ID that this button sends <br>UINT nStyle;    // TBBS_ styles <br>int iImage;     // index into mondo bitmap of this button's picture <br>// or size of this spacer <br>}; <br> <br>inline AFX_TBBUTTON* CFlatToolbar::_GetButtonPtr(int nIndex) const <br>{ <br>ASSERT(nIndex &gt;= 0 &amp;&amp; nIndex &lt; m_nCount); <br>ASSERT(m_pData != NULL); <br>return ((AFX_TBBUTTON*)m_pData) + nIndex; <br>} <br> <br>/* <br>DIBs use RGBQUAD format: <br>0xbb 0xgg 0xrr 0x00 <br> <br>Reasonably efficient code to convert a COLORREF into an <br>RGBQUAD is byte-order-dependent, so we need different <br>code depending on the byte order we're targeting. <br>*/ <br>#ifndef _MAC <br>#define RGB_TO_RGBQUAD(r,g,b)   (RGB(b,g,r)) <br>#define CLR_TO_RGBQUAD(clr)     (RGB(GetBValue(clr), GetGValue(clr), GetRValue(clr))) <br>#else <br>#define RGB_TO_RGBQUAD(r,g,b)   (RGB(r,g,b) &lt;&lt; 8) <br>#define CLR_TO_RGBQUAD(clr)     (clr &lt;&lt; 8) <br>#endif <br> <br>#ifndef _MAC <br>HBITMAP AFXAPI LoadSysColorBitmap(HINSTANCE hInst, HRSRC hRsrc) <br>#else <br>HBITMAP AFXAPI LoadSysColorBitmap(HINSTANCE hInst, HRSRC hRsrc, <br>HDC hDCGlyphs, BOOL bMonochrome) <br>#endif <br>{ <br>struct COLORMAP <br>{ <br>// use DWORD instead of RGBQUAD so we can compare two RGBQUADs easily <br>DWORD rgbqFrom; <br>int iSysColorTo; <br>}; <br>static const COLORMAP sysColorMap[] = <br>{ <br>// mapping from color in DIB to system color <br>{ RGB_TO_RGBQUAD(0x00, 0x00, 0x00),  COLOR_BTNTEXT },       // black <br>{ RGB_TO_RGBQUAD(0x80, 0x80, 0x80),  COLOR_BTNSHADOW },     // dark grey <br>{ RGB_TO_RGBQUAD(0xC0, 0xC0, 0xC0),  COLOR_BTNFACE },       // bright grey <br>{ RGB_TO_RGBQUAD(0xFF, 0xFF, 0xFF),  COLOR_BTNHIGHLIGHT }   // white <br>}; <br>const int nMaps = 4; <br> <br>HGLOBAL hglb; <br>if ((hglb = ::LoadResource(hInst, hRsrc)) == NULL) <br>return NULL; <br> <br>LPBITMAPINFOHEADER lpBitmap = (LPBITMAPINFOHEADER)LockResource(hglb); <br>if (lpBitmap == NULL) <br>return NULL; <br> <br>// make copy of BITMAPINFOHEADER so we can modify the color table <br>const int nColorTableSize = 16; <br>UINT nSize = lpBitmap-&gt;biSize + nColorTableSize * sizeof(RGBQUAD); <br>LPBITMAPINFOHEADER lpBitmapInfo = (LPBITMAPINFOHEADER)::malloc(nSize); <br>if (lpBitmapInfo == NULL) <br>return NULL; <br>memcpy(lpBitmapInfo, lpBitmap, nSize); <br> <br>// color table is in RGBQUAD DIB format <br>DWORD* pColorTable = <br>(DWORD*)(((LPBYTE)lpBitmapInfo) + (UINT)lpBitmapInfo-&gt;biSize); <br> <br>for (int iColor = 0; iColor &lt; nColorTableSize; iColor++) <br>{ <br>// look for matching RGBQUAD color in original <br>for (int i = 0; i &lt; nMaps; i++) <br>{ <br>if (pColorTable[iColor] == sysColorMap[i].rgbqFrom) <br>{ <br>#ifdef _MAC <br>if (bMonochrome) <br>{ <br>// all colors except text become white <br>if (sysColorMap[i].iSysColorTo != COLOR_BTNTEXT) <br>pColorTable[iColor] = RGB_TO_RGBQUAD(255, 255, 255); <br>} <br>else <br>#endif <br>pColorTable[iColor] = <br>CLR_TO_RGBQUAD(::GetSysColor(sysColorMap[i].iSysColorTo)); <br>break; <br>} <br>} <br>} <br> <br>int nWidth = (int)lpBitmapInfo-&gt;biWidth; <br>int nHeight = (int)lpBitmapInfo-&gt;biHeight; <br>HDC hDCScreen = ::GetDC(NULL); <br>HBITMAP hbm = ::CreateCompatibleBitmap(hDCScreen, nWidth, nHeight); <br>::ReleaseDC(NULL, hDCScreen); <br> <br>if (hbm != NULL) <br>{ <br>HBITMAP hbmOld = (HBITMAP)::SelectObject(hDCGlyphs, hbm); <br> <br>LPBYTE lpBits; <br>lpBits = (LPBYTE)(lpBitmap + 1); <br>lpBits += (1 &lt;&lt; (lpBitmapInfo-&gt;biBitCount)) * sizeof(RGBQUAD); <br> <br>StretchDIBits(hDCGlyphs, 0, 0, nWidth, nHeight, 0, 0, nWidth, nHeight, <br>lpBits, (LPBITMAPINFO)lpBitmapInfo, DIB_RGB_COLORS, SRCCOPY); <br>SelectObject(hDCGlyphs, hbmOld); <br> <br>#ifdef _MAC <br>// We don't change this bitmap any more, so get rid of the big, <br>// wasteful Macintosh port <br>::SetBitmapReadOnly(hbm, BRO_READONLY); <br>#endif <br>} <br> <br>// free copy of bitmap info struct and resource itself <br>::free(lpBitmapInfo); <br>::FreeResource(hglb); <br> <br>return hbm; <br>} <br> <br>#ifdef AFX_INIT_SEG <br>#pragma code_seg(AFX_INIT_SEG) <br>#endif <br> <br>CFlatToolbar::CFlatToolbar() <br>{ <br>m_hbmImageWell = NULL; <br>m_hInstImageWell = NULL; <br>m_hRsrcImageWell = NULL; <br>m_iButtonCapture = -1;      // nothing captured <br> <br>// TONYCL: START: OFFICE97 LOOK AND FEEL <br>m_nUpButtonIndex = -1;// No previous upstate button <br>// TONYCL: END: OFFICE97 LOOK AND FEEL <br> <br>// UISG standard sizes <br>m_sizeButton.cx = 24; <br>m_sizeButton.cy = 22; <br>m_sizeImage.cx = 16; <br>m_sizeImage.cy = 15; <br>m_cyTopBorder = m_cyBottomBorder = 3;   // 3 pixel for top/bottom gaps <br> <br>// adjust sizes when running on Win4 <br>if (globalData.bWin4) <br>{ <br>m_sizeButton.cx = 23; <br>m_cySharedBorder = m_cxSharedBorder = 0; <br>m_cxDefaultGap = 8; <br>} <br>else <br>{ <br>m_cxDefaultGap = 6; <br>m_cySharedBorder = m_cxSharedBorder = 1; <br>} <br> <br>#ifdef _MAC <br>m_hDCGlyphs = CreateCompatibleDC(NULL); <br>m_hDCMono = ::CreateCompatibleDC(NULL); <br>if (m_hDCGlyphs == NULL || m_hDCMono == NULL) <br>AfxThrowResourceException(); <br>#endif <br> <br>// initialize the toolbar drawing engine <br>static BOOL bInitialized; <br>if (!bInitialized) <br>{ <br>#ifndef _MAC <br>hDCGlyphs = CreateCompatibleDC(NULL); <br> <br>// Mono DC and Bitmap for disabled image <br>hDCMono = ::CreateCompatibleDC(NULL); <br>#endif <br> <br>#ifndef _MAC <br>HBITMAP hbmGray = ::CreateDitherBitmap(); <br>#else <br>HBITMAP hbmGray = ::CreateDitherBitmap(m_bMonochrome); <br>#endif <br>if (hbmGray != NULL) <br>{ <br>ASSERT(hbrDither == NULL); <br>hbrDither = ::CreatePatternBrush(hbmGray); <br>AfxDeleteObject((HGDIOBJ*)&amp;hbmGray); <br>} <br> <br>#ifndef _MAC <br>if (hDCGlyphs == NULL || hDCMono == NULL || hbrDither == NULL) <br>AfxThrowResourceException(); <br>#else <br>if (hbrDither == NULL) <br>AfxThrowResourceException(); <br>#endif <br>bInitialized = TRUE; <br>} <br>} <br> <br>CFlatToolbar::~CFlatToolbar() <br>{ <br>#ifdef _MAC <br>ASSERT(m_hDCGlyphs != NULL); <br>VERIFY(::DeleteDC(m_hDCGlyphs)); <br> <br>ASSERT(m_hDCMono != NULL); <br>VERIFY(::DeleteDC(m_hDCMono)); <br>#endif <br> <br>AfxDeleteObject((HGDIOBJ*)&amp;m_hbmImageWell); <br>} <br> <br>BOOL CFlatToolbar::Create(CWnd* pParentWnd, DWORD dwStyle, UINT nID) <br>{ <br>if (pParentWnd != NULL) <br>ASSERT_VALID(pParentWnd);   // must have a parent <br> <br>// save the style <br>m_dwStyle = dwStyle; <br>if (nID == AFX_IDW_TOOLBAR) <br>m_dwStyle |= CBRS_HIDE_INPLACE; <br> <br>// create the HWND <br>CRect rect; <br>rect.SetRectEmpty(); <br>LPCTSTR lpszClass = AfxRegisterWndClass(0, ::LoadCursor(NULL, IDC_ARROW), <br>(HBRUSH)(COLOR_BTNFACE+1), NULL); <br>if (!CWnd::Create(lpszClass, NULL, dwStyle, rect, pParentWnd, nID)) <br>return FALSE; <br> <br>// Note: Parent must resize itself for control bar to be resized <br> <br>return TRUE; <br>} <br> <br>void CFlatToolbar::SetSizes(SIZE sizeButton, SIZE sizeImage) <br>{ <br>ASSERT_VALID(this); <br>ASSERT(sizeButton.cx &gt; 0 &amp;&amp; sizeButton.cy &gt; 0); <br>ASSERT(sizeImage.cx &gt; 0 &amp;&amp; sizeImage.cy &gt; 0); <br> <br>// button must be big enough to hold image + 3 pixels on each side <br>ASSERT(sizeButton.cx &gt;= sizeImage.cx + 6); <br>ASSERT(sizeButton.cy &gt;= sizeImage.cy + 6); <br> <br>m_sizeButton = sizeButton; <br>m_sizeImage = sizeImage; <br> <br>// set height <br>Invalidate();   // just to be nice if called when toolbar is visible <br>} <br> <br>void CFlatToolbar::SetHeight(int cyHeight) <br>{ <br>ASSERT_VALID(this); <br> <br>int nHeight = cyHeight; <br>if (m_dwStyle &amp; CBRS_BORDER_TOP) <br>cyHeight -= globalData.cyBorder2; <br>if (m_dwStyle &amp; CBRS_BORDER_BOTTOM) <br>cyHeight -= globalData.cyBorder2; <br>m_cyBottomBorder = (cyHeight - m_sizeButton.cy) / 2; <br>// if there is an extra pixel, m_cyTopBorder will get it <br>m_cyTopBorder = cyHeight - m_sizeButton.cy - m_cyBottomBorder; <br>if (m_cyTopBorder &lt; 0) <br>{ <br>TRACE1("Warning: CFlatToolbar::SetHeight(%d) is smaller than button.\n", <br>nHeight); <br>m_cyBottomBorder += m_cyTopBorder; <br>m_cyTopBorder = 0;  // will clip at bottom <br>} <br>// bottom border will be ignored (truncate as needed) <br>Invalidate();   // just to be nice if called when toolbar is visible <br>} <br> <br>BOOL CFlatToolbar::LoadBitmap(UINT nIDBitmap) <br>{ <br>return LoadBitmap(MAKEINTRESOURCE(nIDBitmap)); <br>} <br> <br>BOOL CFlatToolbar::LoadBitmap(LPCTSTR lpszResourceName) <br>{ <br>ASSERT_VALID(this); <br>ASSERT(lpszResourceName != NULL); <br> <br>AfxDeleteObject((HGDIOBJ*)&amp;m_hbmImageWell);     // get rid of old one <br> <br>m_hInstImageWell = AfxFindResourceHandle(lpszResourceName, RT_BITMAP); <br>if ((m_hRsrcImageWell = ::FindResource(m_hInstImageWell, <br>lpszResourceName, RT_BITMAP)) == NULL) <br>return FALSE; <br> <br>#ifndef _MAC <br>m_hbmImageWell = LoadSysColorBitmap(m_hInstImageWell, m_hRsrcImageWell); <br>#else <br>m_hbmImageWell = LoadSysColorBitmap(m_hInstImageWell, m_hRsrcImageWell, <br>m_hDCGlyphs, m_bMonochrome); <br>#endif <br>return (m_hbmImageWell != NULL); <br>} <br> <br>BOOL CFlatToolbar::SetButtons(const UINT* lpIDArray, int nIDCount) <br>{ <br>ASSERT_VALID(this); <br>ASSERT(nIDCount &gt;= 1);  // must be at least one of them <br>ASSERT(lpIDArray == NULL || <br>AfxIsValidAddress(lpIDArray, sizeof(UINT) * nIDCount, FALSE)); <br> <br>// first allocate array for panes and copy initial data <br>if (!AllocElements(nIDCount, sizeof(AFX_TBBUTTON))) <br>return FALSE; <br>ASSERT(nIDCount == m_nCount); <br> <br>if (lpIDArray != NULL) <br>{ <br>int iImage = 0; <br>// go through them adding buttons <br>AFX_TBBUTTON* pTBB = (AFX_TBBUTTON*)m_pData; <br>for (int i = 0; i &lt; nIDCount; i++, pTBB++) <br>{ <br>ASSERT(pTBB != NULL); <br>if ((pTBB-&gt;nID = *lpIDArray++) == 0) <br>{ <br>// separator <br>pTBB-&gt;nStyle = TBBS_SEPARATOR; <br>// width of separator includes 2 pixel overlap <br>pTBB-&gt;iImage = m_cxDefaultGap + m_cxSharedBorder * 2; <br>} <br>else <br>{ <br>// a command button with image <br>pTBB-&gt;nStyle = TBBS_BUTTON; <br>pTBB-&gt;iImage = iImage++; <br>} <br>} <br>} <br>return TRUE; <br>} <br> <br>#ifdef AFX_CORE3_SEG <br>#pragma code_seg(AFX_CORE3_SEG) <br>#endif <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// CFlatToolbar attribute access <br> <br>int CFlatToolbar::CommandToIndex(UINT nIDFind) const <br>{ <br>ASSERT_VALID(this); <br> <br>AFX_TBBUTTON* pTBB = _GetButtonPtr(0); <br>for (int i = 0; i &lt; m_nCount; i++, pTBB++) <br>if (pTBB-&gt;nID == nIDFind) <br>return i; <br>return -1; <br>} <br> <br>UINT CFlatToolbar::GetItemID(int nIndex) const <br>{ <br>ASSERT_VALID(this); <br> <br>return _GetButtonPtr(nIndex)-&gt;nID; <br>} <br> <br>void CFlatToolbar::GetItemRect(int nIndex, LPRECT lpRect) const <br>{ <br>ASSERT_VALID(this); <br>ASSERT(nIndex &gt;= 0 &amp;&amp; nIndex &lt; m_nCount); <br>ASSERT(AfxIsValidAddress(lpRect, sizeof(RECT))); <br> <br>BOOL bHorz = (m_dwStyle &amp; CBRS_ORIENT_HORZ) ? TRUE : FALSE; <br>CRect rect; <br>rect.SetRectEmpty();        // only need top and left <br>CalcInsideRect(rect, bHorz); <br>AFX_TBBUTTON* pTBB = (AFX_TBBUTTON*)m_pData; <br>for (int iButton = 0; iButton &lt; nIndex; iButton++, pTBB++) <br>{ <br>ASSERT(pTBB != NULL); <br>// skip this button or separator <br>if (bHorz) <br>{ <br>rect.left += (pTBB-&gt;nStyle &amp; TBBS_SEPARATOR) ? <br>pTBB-&gt;iImage : m_sizeButton.cx; <br>rect.left -= m_cxSharedBorder;    // go back for overlap <br>} <br>else <br>{ <br>rect.top += (pTBB-&gt;nStyle &amp; TBBS_SEPARATOR) ? <br>pTBB-&gt;iImage : m_sizeButton.cy; <br>rect.top -= m_cySharedBorder;    // go back for overlap <br>} <br>} <br>ASSERT(iButton == nIndex); <br>ASSERT(pTBB == _GetButtonPtr(nIndex)); <br> <br>// button or image width <br>if (bHorz) <br>{ <br>// TONYCL: START: OFFICE97 LOOK AND FEEL <br>// If we are not floating then shift the buttons down to allow for a gripper <br>if (!IsFloating()) { <br>rect.left += 3; <br>} <br>// TONYCL: END: OFFICE97 LOOK AND FEEL <br> <br>int cx = (pTBB-&gt;nStyle &amp; TBBS_SEPARATOR) ? pTBB-&gt;iImage : m_sizeButton.cx; <br>lpRect-&gt;right = (lpRect-&gt;left = rect.left) + cx; <br>lpRect-&gt;bottom = (lpRect-&gt;top = rect.top) + m_sizeButton.cy; <br>} <br>else <br>{ <br>// TONYCL: START: OFFICE97 LOOK AND FEEL <br>// If we are not floating then shift the buttons down to allow for a gripper <br>if (!IsFloating()) { <br>rect.top += 3; <br>} <br>// TONYCL: END: OFFICE97 LOOK AND FEEL <br> <br>int cy = (pTBB-&gt;nStyle &amp; TBBS_SEPARATOR) ? pTBB-&gt;iImage : m_sizeButton.cy; <br>lpRect-&gt;bottom = (lpRect-&gt;top = rect.top) + cy; <br>lpRect-&gt;right = (lpRect-&gt;left = rect.left) + m_sizeButton.cx; <br>} <br>} <br> <br>UINT CFlatToolbar::GetButtonStyle(int nIndex) const <br>{ <br>return _GetButtonPtr(nIndex)-&gt;nStyle; <br>} <br> <br>void CFlatToolbar::SetButtonStyle(int nIndex, UINT nStyle) <br>{ <br>AFX_TBBUTTON* pTBB = _GetButtonPtr(nIndex); <br>UINT nOldStyle = pTBB-&gt;nStyle; <br>if (nOldStyle != nStyle) <br>{ <br>// update the style and invalidate <br>pTBB-&gt;nStyle = nStyle; <br> <br>// invalidate the button only if both styles not "pressed" <br>if (!(nOldStyle &amp; nStyle &amp; TBBS_PRESSED)) <br>InvalidateButton(nIndex); <br>} <br>} <br> <br>CSize CFlatToolbar::CalcFixedLayout(BOOL bStretch, BOOL bHorz) <br>{ <br>ASSERT_VALID(this); <br> <br>CSize size = CControlBar::CalcFixedLayout(bStretch, bHorz); <br> <br>CRect rect; <br>rect.SetRectEmpty();        // only need top and left <br>CalcInsideRect(rect, bHorz); <br>AFX_TBBUTTON* pTBB = (AFX_TBBUTTON*)m_pData; <br>int nButtonDist = 0; <br> <br>if (!bStretch) <br>{ <br>for (int iButton = 0; iButton &lt; m_nCount; iButton++, pTBB++) <br>{ <br>ASSERT(pTBB != NULL); <br>// skip this button or separator <br>nButtonDist += (pTBB-&gt;nStyle &amp; TBBS_SEPARATOR) ? <br>pTBB-&gt;iImage : (bHorz ? m_sizeButton.cx : m_sizeButton.cy); <br>// go back one for overlap <br>nButtonDist -= bHorz ? m_cxSharedBorder : m_cySharedBorder; <br>} <br>if (bHorz) <br>size.cx = nButtonDist - rect.Width() + m_cxSharedBorder; <br>else <br>size.cy = nButtonDist - rect.Height() + m_cySharedBorder; <br>} <br> <br>if (bHorz) <br>size.cy = m_sizeButton.cy - rect.Height(); // rect.Height() &lt; 0 <br>else <br>size.cx = m_sizeButton.cx - rect.Width(); // rect.Width() &lt; 0 <br> <br>return size; <br>} <br> <br>void CFlatToolbar::GetButtonInfo(int nIndex, UINT&amp; nID, UINT&amp; nStyle, int&amp; iImage) const <br>{ <br>ASSERT_VALID(this); <br> <br>AFX_TBBUTTON* pTBB = _GetButtonPtr(nIndex); <br>nID = pTBB-&gt;nID; <br>nStyle = pTBB-&gt;nStyle; <br>iImage = pTBB-&gt;iImage; <br>} <br> <br>void CFlatToolbar::SetButtonInfo(int nIndex, UINT nID, UINT nStyle, int iImage) <br>{ <br>ASSERT_VALID(this); <br> <br>AFX_TBBUTTON* pTBB = _GetButtonPtr(nIndex); <br>pTBB-&gt;nID = nID; <br>pTBB-&gt;iImage = iImage; <br>pTBB-&gt;nStyle = nStyle; <br>InvalidateButton(nIndex); <br>} <br> <br>void CFlatToolbar::DoPaint(CDC* pDC) <br>{ <br>ASSERT_VALID(this); <br>ASSERT_VALID(pDC); <br> <br>#ifdef _MAC <br>#ifdef _DEBUG <br>// turn off validation to speed up button drawing <br>int wdSav = WlmDebug(WD_NOVALIDATE | WD_ASSERT); <br>#endif <br>#endif <br> <br>CControlBar::DoPaint(pDC);// draw border <br> <br>// if no toolbar loaded, don't draw any buttons <br>if (m_hbmImageWell == NULL) <br>return; <br> <br>BOOL bHorz = m_dwStyle &amp; CBRS_ORIENT_HORZ ? TRUE : FALSE; <br>CRect rect; <br>GetClientRect(rect); <br>CalcInsideRect(rect, bHorz); <br> <br>// force the full size of the button <br>if (bHorz) <br>rect.bottom = rect.top + m_sizeButton.cy; <br>else <br>rect.right = rect.left + m_sizeButton.cx; <br> <br>DrawState ds; <br>if (!PrepareDrawButton(ds)) <br>return;     // something went wrong <br> <br>// TONYCL: START: OFFICE97 LOOK AND FEEL <br>// Only draw the gripper stripes when we are docked <br>if (!IsFloating()) { <br>{ <br>CRect rect; <br>GetClientRect(rect); <br> <br>// Draw the two gripper stripes <br>if (bHorz) { <br>// Adjust the sizes to fit into the client area properly <br>rect.left += 3; <br>rect.top += 3; <br>rect.bottom -= 3; <br>pDC-&gt;Draw3dRect(rect.left, rect.top, 3, rect.Height(), globalData.clrBtnHilite, globalData.clrBtnShadow); <br> <br>rect.left += 4; <br>pDC-&gt;Draw3dRect(rect.left, rect.top, 3, rect.Height(), globalData.clrBtnHilite, globalData.clrBtnShadow); <br>} <br>else { <br>// Adjust the sizes to fit into the client area properly <br>rect.top += 3; <br>rect.left += 3; <br>rect.right -= 3; <br>pDC-&gt;Draw3dRect(rect.left, rect.top, rect.Width(), 3, globalData.clrBtnHilite, globalData.clrBtnShadow); <br> <br>rect.top += 4; <br>pDC-&gt;Draw3dRect(rect.left, rect.top, rect.Width(), 3, globalData.clrBtnHilite, globalData.clrBtnShadow); <br>} <br>} <br> <br>// Shift the buttons down by 2 pixels to allow for the grippers <br>if (bHorz) <br>rect.left += 3; <br>else <br>rect.top += 3; <br>} <br> <br>// TONYCL: END: OFFICE97 LOOK AND FEEL <br> <br>AFX_TBBUTTON* pTBB = (AFX_TBBUTTON*)m_pData; <br>for (int iButton = 0; iButton &lt; m_nCount; iButton++, pTBB++) <br>{ <br>ASSERT(pTBB != NULL); <br>if (pTBB-&gt;nStyle &amp; TBBS_SEPARATOR) <br>{ <br>// separator <br>if (bHorz) <br>rect.right = rect.left + pTBB-&gt;iImage; <br>else <br>rect.bottom = rect.top + pTBB-&gt;iImage; <br> <br>// TONYCL: START: OFFICE97 LOOK AND FEEL <br>{ <br>// Draw a 3D seperator <br>if (bHorz) { </code></pre>
<p>
</p>
<pre><code>int nOffset; <br>nOffset = rect.left + 1 + ((rect.Width() - 2) / 2); <br>pDC-&gt;Draw3dRect(nOffset, rect.top, 2, rect.Height(), globalData.clrBtnShadow, globalData.clrBtnHilite); <br>} <br>else { <br>int nOffset; <br>nOffset = rect.top + 1 + ((rect.Height() - 2) / 2); <br>pDC-&gt;Draw3dRect(rect.left, nOffset, rect.Width(), 2, globalData.clrBtnShadow, globalData.clrBtnHilite); <br>} <br>} <br>// TONYCL: END: OFFICE97 LOOK AND FEEL <br>} <br>else <br>{ <br>if (bHorz) <br>rect.right = rect.left + m_sizeButton.cx; <br>else <br>rect.bottom = rect.top + m_sizeButton.cy; <br>if (!globalData.bWin32s || pDC-&gt;RectVisible(&amp;rect)) <br>{ <br>DrawButton(pDC, rect.left, rect.top, <br>pTBB-&gt;iImage, pTBB-&gt;nStyle); <br>} <br>} <br>// adjust for overlap <br>if (bHorz) <br>rect.left = rect.right - m_cxSharedBorder; <br>else <br>rect.top = rect.bottom - m_cySharedBorder; <br>} <br>EndDrawButton(ds); <br> <br>#ifdef _MAC <br>#ifdef _DEBUG <br>WlmDebug(wdSav); <br>#endif <br>#endif <br>} <br> <br>void CFlatToolbar::InvalidateButton(int nIndex) <br>{ <br>ASSERT_VALID(this); <br> <br>CRect rect; <br>GetItemRect(nIndex, &amp;rect); <br>InvalidateRect(rect, FALSE);    // don't erase background <br>} <br> <br>int CFlatToolbar::OnToolHitTest(CPoint point, TOOLINFO* pTI) const <br>{ <br>ASSERT_VALID(this); <br> <br>// check child windows first by calling CControlBar <br>int nHit = CControlBar::OnToolHitTest(point, pTI); <br>if (nHit != -1) <br>return nHit; <br> <br>// now hit test against CFlatToolbar buttons <br>nHit = ((CFlatToolbar*)this)-&gt;HitTest(point); <br>if (nHit != -1) <br>{ <br>AFX_TBBUTTON* pTBB = _GetButtonPtr(nHit); <br>if (pTI != NULL) <br>{ <br>GetItemRect(nHit, &amp;pTI-&gt;rect); <br>pTI-&gt;uId = pTBB-&gt;nID; <br>pTI-&gt;hwnd = m_hWnd; <br>pTI-&gt;lpszText = LPSTR_TEXTCALLBACK; <br>} <br>nHit = pTBB-&gt;nID; <br>} <br>return nHit; <br>} <br> <br>int CFlatToolbar::HitTest(CPoint point) // in window relative coords <br>{ <br>if (m_pData == NULL) <br>return -1;// no buttons <br> <br>BOOL bHorz = (m_dwStyle &amp; CBRS_ORIENT_HORZ) ? TRUE : FALSE; <br>CRect rect; <br>rect.SetRectEmpty();        // only need top and left <br>CalcInsideRect(rect, bHorz); <br>AFX_TBBUTTON* pTBB = (AFX_TBBUTTON*)m_pData; <br>ASSERT(pTBB != NULL); <br>if (bHorz) <br>{ <br>if (point.y &lt; rect.top || point.y &gt;= rect.top + m_sizeButton.cy) <br>return -1;      // no Y hit <br>for (int iButton = 0; iButton &lt; m_nCount; iButton++, pTBB++) <br>{ <br>if (point.x &lt; rect.left) <br>break;      // missed it <br>rect.left += (pTBB-&gt;nStyle &amp; TBBS_SEPARATOR) ? <br>pTBB-&gt;iImage : m_sizeButton.cx; <br>if (point.x &lt; rect.left &amp;&amp; !(pTBB-&gt;nStyle &amp; TBBS_SEPARATOR)) <br>return iButton;     // hit ! <br>rect.left -= m_cxSharedBorder;    // go back for overlap <br>} <br>} <br>else <br>{ <br>if (point.x &lt; rect.left || point.x &gt;= rect.left + m_sizeButton.cx) <br>return -1;      // no X hit <br>for (int iButton = 0; iButton &lt; m_nCount; iButton++, pTBB++) <br>{ <br>if (point.y &lt; rect.top) <br>break;      // missed it <br>rect.top += (pTBB-&gt;nStyle &amp; TBBS_SEPARATOR) ? <br>pTBB-&gt;iImage : m_sizeButton.cy; <br>if (point.y &lt; rect.top &amp;&amp; !(pTBB-&gt;nStyle &amp; TBBS_SEPARATOR)) <br>return iButton;     // hit ! <br>rect.top -= m_cySharedBorder;    // go back for overlap <br>} <br>} <br> <br>return -1;      // nothing hit <br>} <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// CFlatToolbar message handlers <br> <br>BEGIN_MESSAGE_MAP(CFlatToolbar, CControlBar) <br>//{{AFX_MSG_MAP(CFlatToolbar) <br>ON_WM_LBUTTONDOWN() <br>ON_WM_MOUSEMOVE() <br>ON_WM_LBUTTONUP() <br>ON_WM_CANCELMODE() <br>ON_WM_SYSCOLORCHANGE() <br>ON_WM_WINDOWPOSCHANGED() <br>//}}AFX_MSG_MAP <br>END_MESSAGE_MAP() <br> <br>void CFlatToolbar::OnLButtonDown(UINT nFlags, CPoint point) <br>{ <br>if ((m_iButtonCapture = HitTest(point)) &lt; 0) // nothing hit <br>{ <br>CControlBar::OnLButtonDown(nFlags, point); <br>return; <br>} <br> <br>AFX_TBBUTTON* pTBB = _GetButtonPtr(m_iButtonCapture); <br>ASSERT(!(pTBB-&gt;nStyle &amp; TBBS_SEPARATOR)); <br> <br>// update the button before checking for disabled status <br>UpdateButton(m_iButtonCapture); <br>if (pTBB-&gt;nStyle &amp; TBBS_DISABLED) <br>{ <br>m_iButtonCapture = -1; <br>return;     // don't press it <br>} <br> <br>// TONYCL: START: <br>// Kill the UPSTATE style so that the button is drawn in the downstate <br>pTBB-&gt;nStyle &amp;= ~TBBS_UPSTATE; <br>// TONYCL: END: <br> <br>pTBB-&gt;nStyle |= TBBS_PRESSED; <br>InvalidateButton(m_iButtonCapture); <br>UpdateWindow(); // immediate feedback <br> <br>SetCapture(); <br>GetOwner()-&gt;SendMessage(WM_SETMESSAGESTRING, (WPARAM)pTBB-&gt;nID); <br>} <br> <br>void CFlatToolbar::OnMouseMove(UINT /*nFlags*/, CPoint point) <br>{ <br>if (m_iButtonCapture &gt;= 0) <br>{ <br>AFX_TBBUTTON* pTBB = _GetButtonPtr(m_iButtonCapture); <br>ASSERT(!(pTBB-&gt;nStyle &amp; TBBS_SEPARATOR)); <br> <br>UINT nNewStyle = (pTBB-&gt;nStyle &amp; ~TBBS_PRESSED); <br>int iButtonCapture = m_iButtonCapture; <br>if (GetCapture() != this) <br>{ <br>m_iButtonCapture = -1; // lost capture <br>GetOwner()-&gt;SendMessage(WM_SETMESSAGESTRING, AFX_IDS_IDLEMESSAGE); <br>} <br>else <br>{ <br>// should be pressed if still hitting the captured button <br>if (HitTest(point) == m_iButtonCapture) <br>nNewStyle |= TBBS_PRESSED; <br>} <br>SetButtonStyle(iButtonCapture, nNewStyle); <br>UpdateWindow(); // immediate feedback <br>} <br>// TONYCL: START: OFFICE97 LOOK AND FEEL <br>else { <br>// We have to be the active application <br>if (GetForegroundWindow()-&gt;GetSafeHwnd() == AfxGetMainWnd()-&gt;GetSafeHwnd()) { <br>// Hit test the button, and then draw the button in the up state <br>int nButtonID = HitTest(point);// Which button are we over? <br> <br>if (nButtonID == -1) { <br>ReleaseCapture(); <br>} <br>else { <br>SetCapture(); <br>} <br> <br>// Are we over the same button as we were last time? <br>if (m_nUpButtonIndex == nButtonID) { <br>return; <br>} <br> // Is the new button -1, and were we over a button? <br>else if ((nButtonID == -1) &amp;&amp; (m_nUpButtonIndex != -1)) { <br>// Reset the button state so it's flat <br>UINT nStyle = GetButtonStyle(m_nUpButtonIndex); <br>nStyle &amp;= ~TBBS_UPSTATE; <br>SetButtonStyle(m_nUpButtonIndex, nStyle); <br>InvalidateButton(m_nUpButtonIndex); <br>m_nUpButtonIndex = -1; <br>UpdateWindow(); // immediate feedback <br>} <br>// We are over a button <br>else if (nButtonID != -1 &amp;&amp; (!(GetButtonStyle(nButtonID) &amp; TBBS_DISABLED))) { <br>// Put the button into the upstate <br>UINT nStyle = GetButtonStyle(nButtonID); <br>nStyle |= TBBS_UPSTATE; <br>SetButtonStyle(nButtonID, nStyle); <br>InvalidateButton(nButtonID); <br> <br>// If we were over a different button to the one before, flatten it <br>if (m_nUpButtonIndex != -1) { <br>UINT nStyle = GetButtonStyle(m_nUpButtonIndex); <br>nStyle &amp;= ~TBBS_UPSTATE; <br>SetButtonStyle(m_nUpButtonIndex, nStyle); <br>InvalidateButton(m_nUpButtonIndex); <br>} <br> <br>m_nUpButtonIndex = nButtonID; <br>UpdateWindow(); // immediate feedback <br>} <br>} <br>} <br>// TONYCL: END: OFFICE97 LOOK AND FEEL <br>} <br> <br>void CFlatToolbar::OnLButtonUp(UINT nFlags, CPoint point) <br>{ <br>if (m_iButtonCapture &lt; 0) <br>{ <br>CControlBar::OnLButtonUp(nFlags, point); <br>return;     // not captured <br>} <br> <br>AFX_TBBUTTON* pTBB = _GetButtonPtr(m_iButtonCapture); <br>ASSERT(!(pTBB-&gt;nStyle &amp; TBBS_SEPARATOR)); <br>UINT nIDCmd = 0; <br> <br>UINT nNewStyle = (pTBB-&gt;nStyle &amp; ~TBBS_PRESSED); <br>if (GetCapture() == this) <br>{ <br>// we did not lose the capture <br>ReleaseCapture(); <br>if (HitTest(point) == m_iButtonCapture) <br>{ <br>// give button a chance to update <br>UpdateButton(m_iButtonCapture); <br> <br>// then check for disabled state <br>if (!(pTBB-&gt;nStyle &amp; TBBS_DISABLED)) <br>{ <br>// pressed, will send command notification <br>nIDCmd = pTBB-&gt;nID; <br> <br>if (pTBB-&gt;nStyle &amp; TBBS_CHECKBOX) <br>{ <br>// auto check: three state =&gt; down <br>if (nNewStyle &amp; TBBS_INDETERMINATE) <br>nNewStyle &amp;= ~TBBS_INDETERMINATE; <br> <br>nNewStyle ^= TBBS_CHECKED; <br>} <br>} <br>} <br>} <br> <br>GetOwner()-&gt;SendMessage(WM_SETMESSAGESTRING, AFX_IDS_IDLEMESSAGE); <br> <br>int iButtonCapture = m_iButtonCapture; <br>m_iButtonCapture = -1; <br>if (nIDCmd != 0) <br>GetOwner()-&gt;SendMessage(WM_COMMAND, nIDCmd);    // send command <br> <br>SetButtonStyle(iButtonCapture, nNewStyle); <br>UpdateButton(iButtonCapture); <br> <br>UpdateWindow(); // immediate feedback <br>} <br> <br>// TONYCL: START: OFFICE97 LOOK AND FEEL <br>void CFlatToolbar::OnWindowPosChanged( WINDOWPOS* lpwndpos ) <br>{ <br>// Force a repaint of the window to fix a repaint bug <br>InvalidateRect(NULL); <br>UpdateWindow(); <br>} <br>// TONYCL: END: OFFICE97 LOOK AND FEEL <br> <br>void CFlatToolbar::OnCancelMode() <br>{ <br>CControlBar::OnCancelMode(); <br> <br>if (m_iButtonCapture &gt;= 0) <br>{ <br>AFX_TBBUTTON* pTBB = _GetButtonPtr(m_iButtonCapture); <br>ASSERT(!(pTBB-&gt;nStyle &amp; TBBS_SEPARATOR)); <br>UINT nNewStyle = (pTBB-&gt;nStyle &amp; ~TBBS_PRESSED); <br>if (GetCapture() == this) <br>ReleaseCapture(); <br>SetButtonStyle(m_iButtonCapture, nNewStyle); <br>m_iButtonCapture = -1; <br>UpdateWindow(); <br>} <br>} <br> <br>void CFlatToolbar::OnSysColorChange() <br>{ <br>#ifdef _MAC <br>CControlBar::OnSysColorChange(); <br> <br>ASSERT(hDCGlyphs != NULL); <br>VERIFY(::DeleteDC(hDCGlyphs)); <br>hDCGlyphs = ::CreateCompatibleDC(NULL); <br> <br>ASSERT(hDCMono != NULL); <br>VERIFY(::DeleteDC(hDCMono)); <br>hDCMono = ::CreateCompatibleDC(NULL); <br>#endif <br> <br>// re-initialize global dither brush <br>#ifndef _MAC <br>HBITMAP hbmGray = ::CreateDitherBitmap(); <br>#else <br>HBITMAP hbmGray = ::CreateDitherBitmap(m_bMonochrome); <br>#endif <br>if (hbmGray != NULL) <br>{ <br>HBRUSH hbrNew = ::CreatePatternBrush(hbmGray); <br>if (hbrNew != NULL) <br>{ <br>AfxDeleteObject((HGDIOBJ*)&amp;hbrDither);      // free old one <br>hbrDither = hbrNew; <br>} <br>::DeleteObject(hbmGray); <br>} <br> <br>// re-color bitmap for toolbar <br>if (m_hbmImageWell != NULL) <br>{ <br>HBITMAP hbmNew; <br>#ifndef _MAC <br>hbmNew = LoadSysColorBitmap(m_hInstImageWell, m_hRsrcImageWell); <br>#else <br>hbmNew = LoadSysColorBitmap(m_hInstImageWell, m_hRsrcImageWell, <br>m_hDCGlyphs, m_bMonochrome); <br>#endif <br>if (hbmNew != NULL) <br>{ <br>::DeleteObject(m_hbmImageWell);     // free old one <br>m_hbmImageWell = hbmNew; <br>} <br>} <br>} <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// CFlatToolbar idle update through CToolCmdUI class <br> <br>#define CToolCmdUI COldToolCmdUI <br> <br>class CToolCmdUI : public CCmdUI        // class private to this file ! <br>{ <br>public: // re-implementations only <br>virtual void Enable(BOOL bOn); <br>virtual void SetCheck(int nCheck); <br>virtual void SetText(LPCTSTR lpszText); <br>}; <br> <br>void CToolCmdUI::Enable(BOOL bOn) <br>{ <br>m_bEnableChanged = TRUE; <br>CFlatToolbar* pToolBar = (CFlatToolbar*)m_pOther; <br>ASSERT(pToolBar != NULL); <br>ASSERT_KINDOF(CFlatToolbar, pToolBar); <br>ASSERT(m_nIndex &lt; m_nIndexMax); <br> <br>UINT nNewStyle = pToolBar-&gt;GetButtonStyle(m_nIndex) &amp; ~TBBS_DISABLED; <br>if (!bOn) <br>nNewStyle |= TBBS_DISABLED; <br>ASSERT(!(nNewStyle &amp; TBBS_SEPARATOR)); <br>pToolBar-&gt;SetButtonStyle(m_nIndex, nNewStyle); <br>} <br> <br>void CToolCmdUI::SetCheck(int nCheck) <br>{ <br>ASSERT(nCheck &gt;= 0 &amp;&amp; nCheck &lt;= 2); // 0=&gt;off, 1=&gt;on, 2=&gt;indeterminate <br>CFlatToolbar* pToolBar = (CFlatToolbar*)m_pOther; <br>ASSERT(pToolBar != NULL); <br>ASSERT_KINDOF(CFlatToolbar, pToolBar); <br>ASSERT(m_nIndex &lt; m_nIndexMax); <br> <br>UINT nNewStyle = pToolBar-&gt;GetButtonStyle(m_nIndex) &amp; <br>~(TBBS_CHECKED | TBBS_INDETERMINATE); <br>if (nCheck == 1) <br>nNewStyle |= TBBS_CHECKED; <br>else if (nCheck == 2) <br>nNewStyle |= TBBS_INDETERMINATE; <br>ASSERT(!(nNewStyle &amp; TBBS_SEPARATOR)); <br>pToolBar-&gt;SetButtonStyle(m_nIndex, nNewStyle | TBBS_CHECKBOX); <br>} <br> <br>void CToolCmdUI::SetText(LPCTSTR) <br>{ <br>// ignore it <br>} <br> <br>void CFlatToolbar::OnUpdateCmdUI(CFrameWnd* pTarget, BOOL bDisableIfNoHndler) <br>{ <br>CToolCmdUI state; <br>state.m_pOther = this; <br> <br>state.m_nIndexMax = (UINT)m_nCount; <br>for (state.m_nIndex = 0; state.m_nIndex &lt; state.m_nIndexMax; <br>  state.m_nIndex++) <br>{ <br>AFX_TBBUTTON* pTBB = _GetButtonPtr(state.m_nIndex); <br>state.m_nID = pTBB-&gt;nID; <br> <br>// ignore separators <br>if (!(pTBB-&gt;nStyle &amp; TBBS_SEPARATOR)) <br>state.DoUpdate(pTarget, bDisableIfNoHndler); <br>} <br> <br>// update the dialog controls added to the toolbar <br>UpdateDialogControls(pTarget, bDisableIfNoHndler); <br>} <br> <br>void CFlatToolbar::UpdateButton(int nIndex) <br>{ <br>// determine target of command update <br>CFrameWnd* pTarget = (CFrameWnd*)GetOwner(); <br>if (pTarget == NULL || !pTarget-&gt;IsFrameWnd()) <br>pTarget = GetParentFrame(); <br> <br>// send the update notification <br>if (pTarget != NULL) <br>{ <br>CToolCmdUI state; <br>state.m_pOther = this; <br>state.m_nIndex = nIndex; <br>state.m_nIndexMax = (UINT)m_nCount; <br>AFX_TBBUTTON* pTBB = _GetButtonPtr(nIndex); <br>state.m_nID = pTBB-&gt;nID; <br>state.DoUpdate(pTarget, pTarget-&gt;m_bAutoMenuEnable); <br>} <br>} <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// CFlatToolbar diagnostics <br> <br>#ifdef _DEBUG <br>void CFlatToolbar::AssertValid() const <br>{ <br>CControlBar::AssertValid(); <br>ASSERT(m_hbmImageWell == NULL || <br>(globalData.bWin32s || ::GetObjectType(m_hbmImageWell) == OBJ_BITMAP)); <br> <br>if (m_hbmImageWell != NULL) <br>{ <br>ASSERT(m_hRsrcImageWell != NULL); <br>ASSERT(m_hInstImageWell != NULL); <br>} <br>} <br> <br>void CFlatToolbar::Dump(CDumpContext&amp; dc) const <br>{ <br>CControlBar::Dump(dc); <br> <br>dc &lt;&lt; "m_hbmImageWell = " &lt;&lt; (UINT)m_hbmImageWell; <br>dc &lt;&lt; "\nm_hInstImageWell = " &lt;&lt; (UINT)m_hInstImageWell; <br>dc &lt;&lt; "\nm_hRsrcImageWell = " &lt;&lt; (UINT)m_hRsrcImageWell; <br>dc &lt;&lt; "\nm_iButtonCapture = " &lt;&lt; m_iButtonCapture; <br>dc &lt;&lt; "\nm_sizeButton = " &lt;&lt; m_sizeButton; <br>dc &lt;&lt; "\nm_sizeImage = " &lt;&lt; m_sizeImage; <br> <br>if (dc.GetDepth() &gt; 0) <br>{ <br>for (int i = 0; i &lt; m_nCount; i++) <br>{ <br>AFX_TBBUTTON* pTBB = _GetButtonPtr(i); <br>dc &lt;&lt; "\ntoolbar button[" &lt;&lt; i &lt;&lt; "] = {"; <br>dc &lt;&lt; "\n\tnID = " &lt;&lt; pTBB-&gt;nID; <br>dc &lt;&lt; "\n\tnStyle = " &lt;&lt; pTBB-&gt;nStyle; <br>if (pTBB-&gt;nStyle &amp; TBBS_SEPARATOR) <br>dc &lt;&lt; "\n\tiImage (separator width) = " &lt;&lt; pTBB-&gt;iImage; <br>else <br>dc &lt;&lt;"\n\tiImage (bitmap image index) = " &lt;&lt; pTBB-&gt;iImage; <br>dc &lt;&lt; "\n}"; <br>} <br>} <br> <br>dc &lt;&lt; "\n"; <br>} <br>#endif <br> <br>#undef new <br>#ifdef AFX_INIT_SEG <br>#pragma code_seg(AFX_INIT_SEG) <br>#endif <br> <br>IMPLEMENT_DYNAMIC(CFlatToolbar, CControlBar) <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// Cached system metrics, etc <br> <br>GLOBAL_DATA globalData; <br> <br>// Initialization code <br>GLOBAL_DATA::GLOBAL_DATA() <br>{ <br>// Cache various target platform version information <br>DWORD dwVersion = ::GetVersion(); <br>nWinVer = (LOBYTE(dwVersion) &lt;&lt; 8) + HIBYTE(dwVersion); <br>bWin32s = (dwVersion &amp; 0x80000000) != 0; <br>bWin4 = (BYTE)dwVersion &gt;= 4; <br>bNotWin4 = 1 - bWin4;   // for convenience <br>#ifndef _MAC <br>bSmCaption = bWin4; <br>#else <br>bSmCaption = TRUE; <br>#endif <br>bWin31 = bWin32s &amp;&amp; !bWin4; // Windows 95 reports Win32s <br> <br>// Cached system metrics (updated in CWnd::OnWinIniChange) <br>UpdateSysMetrics(); <br> <br>// Border attributes <br>hbrLtGray = ::CreateSolidBrush(RGB(192, 192, 192)); <br>hbrDkGray = ::CreateSolidBrush(RGB(128, 128, 128)); <br>ASSERT(hbrLtGray != NULL); <br>ASSERT(hbrDkGray != NULL); <br> <br>// Cached system values (updated in CWnd::OnSysColorChange) <br>hbrBtnFace = NULL; <br>hbrBtnShadow = NULL; <br>hbrBtnHilite = NULL; <br>hbrWindowFrame = NULL; <br>hpenBtnShadow = NULL; <br>hpenBtnHilite = NULL; <br>hpenBtnText = NULL; <br>UpdateSysColors(); <br> <br>// cxBorder2 and cyBorder are 2x borders for Win4 <br>cxBorder2 = bWin4 ? CX_BORDER*2 : CX_BORDER; <br>cyBorder2 = bWin4 ? CY_BORDER*2 : CY_BORDER; <br> <br>// allocated on demand <br>hStatusFont = NULL; <br>hToolTipsFont = NULL; <br>} <br> <br>// Termination code <br>GLOBAL_DATA::~GLOBAL_DATA() <br>{ <br>// cleanup standard brushes <br>AfxDeleteObject((HGDIOBJ*)&amp;hbrLtGray); <br>AfxDeleteObject((HGDIOBJ*)&amp;hbrDkGray); <br>AfxDeleteObject((HGDIOBJ*)&amp;hbrBtnFace); <br>AfxDeleteObject((HGDIOBJ*)&amp;hbrBtnShadow); <br>AfxDeleteObject((HGDIOBJ*)&amp;hbrBtnHilite); <br>AfxDeleteObject((HGDIOBJ*)&amp;hbrWindowFrame); <br> <br>// cleanup standard pens <br>AfxDeleteObject((HGDIOBJ*)&amp;hpenBtnShadow); <br>AfxDeleteObject((HGDIOBJ*)&amp;hpenBtnHilite); <br>AfxDeleteObject((HGDIOBJ*)&amp;hpenBtnText); <br> <br>// clean up objects we don't actually create <br>AfxDeleteObject((HGDIOBJ*)&amp;hStatusFont); <br>AfxDeleteObject((HGDIOBJ*)&amp;hToolTipsFont); <br>} <br> <br>void GLOBAL_DATA::UpdateSysColors() <br>{ <br>clrBtnFace = ::GetSysColor(COLOR_BTNFACE); <br>clrBtnShadow = ::GetSysColor(COLOR_BTNSHADOW); <br>clrBtnHilite = ::GetSysColor(COLOR_BTNHIGHLIGHT); <br>clrBtnText = ::GetSysColor(COLOR_BTNTEXT); <br>clrWindowFrame = ::GetSysColor(COLOR_WINDOWFRAME); <br> <br>AfxDeleteObject((HGDIOBJ*)&amp;hbrBtnFace); <br>AfxDeleteObject((HGDIOBJ*)&amp;hbrBtnShadow); <br>AfxDeleteObject((HGDIOBJ*)&amp;hbrBtnHilite); <br>AfxDeleteObject((HGDIOBJ*)&amp;hbrWindowFrame); <br> <br>hbrBtnFace = ::CreateSolidBrush(clrBtnFace); <br>ASSERT(hbrBtnFace != NULL); <br>hbrBtnShadow = ::CreateSolidBrush(clrBtnShadow); <br>ASSERT(hbrBtnShadow != NULL); <br>hbrBtnHilite = ::CreateSolidBrush(clrBtnHilite); <br>ASSERT(hbrBtnHilite != NULL); <br>hbrWindowFrame = ::CreateSolidBrush(clrWindowFrame); <br>ASSERT(hbrWindowFrame != NULL); <br> <br>AfxDeleteObject((HGDIOBJ*)&amp;hpenBtnShadow); <br>AfxDeleteObject((HGDIOBJ*)&amp;hpenBtnHilite); <br>AfxDeleteObject((HGDIOBJ*)&amp;hpenBtnText); <br> <br>hpenBtnShadow = ::CreatePen(PS_SOLID, 0, clrBtnShadow); <br>ASSERT(hpenBtnShadow != NULL); <br>hpenBtnHilite = ::CreatePen(PS_SOLID, 0, clrBtnHilite); <br>ASSERT(hpenBtnHilite != NULL); <br>hpenBtnText = ::CreatePen(PS_SOLID, 0, clrBtnText); <br>ASSERT(hpenBtnText != NULL); <br>} <br> <br>void GLOBAL_DATA::UpdateSysMetrics() <br>{ <br>// Device metrics for screen <br>HDC hDCScreen = GetDC(NULL); <br>ASSERT(hDCScreen != NULL); <br>cxPixelsPerInch = GetDeviceCaps(hDCScreen, LOGPIXELSX); <br>cyPixelsPerInch = GetDeviceCaps(hDCScreen, LOGPIXELSY); <br>ReleaseDC(NULL, hDCScreen); <br>} <br> <br>///////////////////////////////////////////////////////////////////////////// </code></pre>
<p>&nbsp;</p></body>
</HTML>
