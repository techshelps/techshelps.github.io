<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CHPPYVW.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context4355"></a>CHPPYVW.CPP</h2>
<pre><code>//**************************************************************************** <br>//  Module:     Chappy.EXE <br>//  File:       ChappyView.cpp : implementation of the CChappyView class <br>//               <br>// <br>//  Copyright (c) Microsoft Corporation 1996-1997 <br>// <br>// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF  <br>// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO  <br>// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A  <br>// PARTICULAR PURPOSE. <br>//**************************************************************************** <br> <br>#include "stdafx.h" <br>#include "Chappy.h" <br> <br>#include "ChppyDoc.h" <br>#include "ChppyVw.h" <br>#include "Globals.h" <br>#include "EnterDlg.h" <br>#include "chtitems.h" <br>#include "mainfrm.h" <br>#include "LogInDlg.h" <br>#include "PWordDlg.h" <br>#include "KickDlg.h" <br>#include "BanDlg.h" <br> <br>#ifdef _DEBUG <br>#define new DEBUG_NEW <br>#undef THIS_FILE <br>static char THIS_FILE[] = __FILE__; <br>#endif <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// CChappyView <br> <br>IMPLEMENT_DYNCREATE(CChappyView, CView) <br> <br>BEGIN_MESSAGE_MAP(CChappyView, CView) <br>//{{AFX_MSG_MAP(CChappyView) <br>ON_WM_CREATE() <br>ON_NOTIFY(TCN_SELCHANGE, IDC_MESSAGE_TAB, OnSelchangeTab1) <br>ON_WM_SIZE() <br>ON_COMMAND(ID_FILE_NEW, OnFileNew) <br>ON_WM_DESTROY() <br>ON_COMMAND(ID_BTN_SEND, OnBtnSend) <br>ON_COMMAND(ID_BTN_WHISPER, OnBtnWhisper) <br>ON_COMMAND(ID_ROOM_CONNECT, OnRoomConnect) <br>ON_COMMAND(ID_BTN_DO, OnBtnDo) <br>ON_COMMAND(ID_BTN_THINK, OnBtnThink) <br>ON_COMMAND(ID_ROOM_DISCONNECT, OnRoomDisconnect) <br>ON_UPDATE_COMMAND_UI(ID_ROOM_CONNECT, OnUpdateRoomConnect) <br>ON_UPDATE_COMMAND_UI(ID_ROOM_DISCONNECT, OnUpdateRoomDisconnect) <br>ON_COMMAND(ID_SERVER_LOGIN, OnRoomLogin) <br>ON_UPDATE_COMMAND_UI(ID_SERVER_LOGIN, OnUpdateRoomLogin) <br>ON_UPDATE_COMMAND_UI(ID_SERVER_LOGOUT, OnUpdateRoomLogout) <br>ON_COMMAND(ID_SERVER_LOGOUT, OnRoomLogout) <br>ON_COMMAND(ID_ROOM_LISTROOMS, OnRoomListrooms) <br>ON_COMMAND(ID_ROOMLIST_ENTERROOM, OnRoomListEnterRoom) <br>ON_UPDATE_COMMAND_UI(ID_ROOMLIST_ENTERROOM, OnUpdateRoomListEnterRoom) <br>ON_UPDATE_COMMAND_UI(ID_ROOM_LISTROOMS, OnUpdateRoomListRooms) <br>ON_COMMAND(ID_PARTLIST_KICK, OnPartlistKick) <br>ON_COMMAND(ID_FILE_SAVE, OnFileSave) <br>ON_UPDATE_COMMAND_UI(ID_PARTLIST_BAN, OnUpdatePartlistBan) <br>ON_COMMAND(ID_PARTLIST_BAN, OnPartlistBan) <br>ON_COMMAND(ID_SERVER_BANUSER, OnServerBanuser) <br>ON_UPDATE_COMMAND_UI(ID_SERVER_BANUSER, OnUpdateServerBanuser) <br>ON_UPDATE_COMMAND_UI(ID_PARTLIST_KICK, OnUpdatePartlistKick) <br>ON_COMMAND(ID_PARTLIST_MAKEHOST, OnPartlistMakehost) <br>ON_UPDATE_COMMAND_UI(ID_PARTLIST_MAKEHOST, OnUpdatePartlistMakehost) <br>ON_COMMAND(ID_PARTLIST_MAKEPARTICIPANT, OnPartlistMakeparticipant) <br>ON_UPDATE_COMMAND_UI(ID_PARTLIST_MAKEPARTICIPANT, OnUpdatePartlistMakeparticipant) <br>ON_UPDATE_COMMAND_UI(ID_FILE_SAVE, OnUpdateFileSave) <br>ON_COMMAND(ID_HISTORY_CLEAR, OnHistoryClear) <br>ON_UPDATE_COMMAND_UI(ID_HISTORY_CLEAR, OnUpdateHistoryClear) <br> <br>//}}AFX_MSG_MAP <br>END_MESSAGE_MAP() <br> <br>//ON_NOTIFY_EX_RANGE(TTN_NEEDTEXTW, 0, 0xFFFF, OnToolTipNotify) <br>//nON_NOTIFY_EX_RANGE(TTN_NEEDTEXTA, 0, 0xFFFF, OnToolTipNotify) <br> <br> <br>//EnableToolTips(TRUE); <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// CChappyView construction/destruction <br> <br>CChappyView::CChappyView() <br>{ <br>// TODO: add construction code here <br>m_cx = m_cy = 0; <br>m_iLastTab = -1; //first chat room <br>m_iVisibleTab = 0; <br>m_iServerConnectionState = csDisconnected; <br>m_iServerConnectionType = -1; <br>for (long i=0; i &lt; MAX_ROOMS; ++i) <br>{ <br>m_ChatRoom[i] = NULL; <br>} <br>} <br> <br>CChappyView::~CChappyView() <br>{ <br>//disconnect from the server <br>//m_ocxChat.Disconnect(); <br>for (long i=0; i &lt; MAX_ROOMS; ++i) <br>{ <br>if (m_ChatRoom[i]) <br>{ <br>delete(m_ChatRoom[i]); <br>m_ChatRoom[i] = NULL; <br>} <br>} <br>} <br> <br>BOOL CChappyView::PreCreateWindow(CREATESTRUCT&amp; cs) <br>{ <br>// TODO: Modify the Window class or styles here by modifying <br>//  the CREATESTRUCT cs <br> <br>return CView::PreCreateWindow(cs); <br>} <br> <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// CChappyView diagnostics <br> <br>#ifdef _DEBUG <br>void CChappyView::AssertValid() const <br>{ <br>CView::AssertValid(); <br>} <br> <br>void CChappyView::Dump(CDumpContext&amp; dc) const <br>{ <br>CView::Dump(dc); <br>} <br> <br>CChappyDoc* CChappyView::GetDocument() // non-debug version is inline <br>{ <br>ASSERT(m_pDocument-&gt;IsKindOf(RUNTIME_CLASS(CChappyDoc))); <br>return (CChappyDoc*)m_pDocument; <br>} <br>#endif //_DEBUG <br> <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// CChappyView drawing <br> <br>void CChappyView::OnDraw(CDC* pDC) <br>{ <br>//TRACE0("DRAW \n"); <br>//CChappyDoc* pDoc = GetDocument(); <br>//ASSERT_VALID(pDoc); <br> <br> <br>int iParticListSize = 0; <br>if ( (LIST_TAB != m_iVisibleTab) &amp;&amp; (MESSAGE_TAB != m_iVisibleTab) ) <br>{ <br>//the tab contains a room <br>iParticListSize = m_ChatRoom[m_iVisibleTab]-&gt;m_ctrlPartListWnd.GetCx(); <br> <br>//TRACE1("size = %u", iParticListSize); <br>m_ChatRoom[m_iVisibleTab]-&gt;m_ctrlPartListWnd.MoveWindow(m_cx - iParticListSize,  <br>0,  <br>iParticListSize,  <br>m_cy,  <br>TRUE); <br>} <br> <br>m_ctrlTabWnd.MoveWindow(0,  <br>0,  <br>m_cx - iParticListSize,  <br>m_cy - INPUT_RICHEDIT_SIZE,  <br>TRUE); <br> <br> <br>//the history/room list window <br>HWND hWnd = NULL; <br>switch (m_iVisibleTab)  <br>{ <br>case LIST_TAB: <br>hWnd = m_ctrlRoomList; <br>break; <br>case MESSAGE_TAB: <br>//server and private messages <br>hWnd = m_ctrlPrivateMsg; <br>break; <br>default: <br>//all the other tabs are rooms  <br>hWnd = m_ChatRoom[m_iVisibleTab]-&gt;m_ctrlHistoryWnd; <br>} <br> <br>::MoveWindow(hWnd, <br>6,  <br>6,  <br>m_cx - iParticListSize - 20,  <br>m_cy - INPUT_RICHEDIT_SIZE - 42,  <br>TRUE); <br> <br>m_ctrlSendToolBar.MoveWindow(0,  <br>m_cy - INPUT_RICHEDIT_SIZE,  <br>SEND_TB_SIZE ,  <br>INPUT_RICHEDIT_SIZE,  <br>FALSE); <br> <br> <br>m_ctrlInputWnd.MoveWindow(SEND_TB_SIZE ,  <br>m_cy - INPUT_RICHEDIT_SIZE,  <br>m_cx - iParticListSize - SEND_TB_SIZE,  <br>INPUT_RICHEDIT_SIZE,  <br>TRUE); <br> <br> <br>} <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// CChappyView message handlers <br> <br>void CChappyView::OnDestroy()  <br>{ <br>//disconnect from the server <br>if (csConnected &lt;= m_iServerConnectionState) <br>{ <br>OnRoomLogout(); <br>} <br> <br>//commctrl faults if do not destroy the windows in the proper order <br>m_ctrlRoomList.DestroyWindow(); <br>m_ctrlPrivateMsg.DestroyWindow(); <br>m_ctrlTabWnd.DestroyWindow(); <br>m_ctrlSendToolBar.DestroyWindow(); <br>m_ctrlInputWnd.DestroyWindow(); <br> <br>CView::OnDestroy(); <br> <br>} <br> <br> <br>int CChappyView::OnCreate(LPCREATESTRUCT lpCreateStruct)  <br>{ <br>if (CView::OnCreate(lpCreateStruct) == -1) <br>return -1; <br> <br>//some random initial size <br>RECT rec; <br>rec.left= 0; <br>rec.top= 0; <br>rec.right= 100; <br>rec.bottom= 100; <br> <br>BOOL ret = FALSE; <br> <br>//create the tab control <br>ret = m_ctrlTabWnd.Create(WS_CHILD | WS_BORDER | WS_VISIBLE | WS_TABSTOP | WS_THICKFRAME | <br>TCS_BOTTOM | TCS_TABS ,  <br>rec, this, IDC_MESSAGE_TAB); <br>ASSERT (ret); <br> <br>//create the input rich edit control <br>ret = m_ctrlInputWnd.Create(WS_CHILD | WS_BORDER |  WS_VISIBLE | WS_VSCROLL | <br>ES_MULTILINE | ES_AUTOVSCROLL,  <br>rec,  <br>this, <br>IDC_INPUT_RICHEDIT); <br>ASSERT (ret); <br> <br>////set the font for the input richedit <br>//CHARFORMAT cf; <br>//m_ctrlInputWnd.GetDefaultCharFormat(cf); <br>// <br>// <br>//cf.cbSize = sizeof (CHARFORMAT);  <br>//cf.dwMask = CFM_FACE ; <br>////cf.dwEffects; <br>////cf.yHeight; <br>////cf.yOffset; <br>////cf.crTextColor=RGB(250,0,0); <br>////cf.bCharSet; <br>////cf.bPitchAndFamily; <br>//sprintf(cf.szFaceName, "Script"); <br>// <br>//m_ctrlInputWnd.SetDefaultCharFormat(cf); <br>// <br> <br>//create the toolbar with the send/wisper buttons <br>ret = m_ctrlSendToolBar.Create(this,//GetParent(), <br>WS_CHILD |  WS_VISIBLE | <br>TBSTYLE_TOOLTIPS | CBRS_RIGHT | CCS_NORESIZE ,  <br>IDR_SEND_TOOLBAR); <br>ASSERT (ret); <br> <br>//load the toolbar <br>ret = m_ctrlSendToolBar.LoadToolBar(IDR_SEND_TOOLBAR); <br>ASSERT (ret); <br> <br>//enable the tooltips  <br>ret = m_ctrlSendToolBar.EnableToolTips(TRUE); <br>ASSERT (ret); <br>ret = EnableToolTips(TRUE); <br>ASSERT (ret); <br> <br>//** The OCX ** <br>RECT rect; <br> <br>rect.left= 1; <br>rect.top= 1; <br>rect.right= 5000; <br>rect.bottom= 5000; <br> <br>if (!m_ocxChat.Create(NULL, WS_CHILD, rect, this, IDC_OCX_CHAT)) <br>{ <br>AfxMessageBox (IDS_FAIL_TO_LOAD_OCX); <br>return -1; <br>} <br> <br>//create the list of Chat rooms <br>CString szTabName; <br>szTabName.LoadString (IDS_ROOM_LIST_TAB); <br>long iTab = AddTab(szTabName); <br>m_ctrlTabWnd.ChangeImage(iTab, IMG_ROOM_LIST); <br>m_ctrlRoomList.Create(LVS_REPORT | LVS_SINGLESEL | LVS_SORTASCENDING, <br>rect, <br>&amp;m_ctrlTabWnd, <br>IDC_ROOM_LIST); <br>ASSERT(m_ctrlRoomList); <br> <br>//create a history windows for private and server messages <br>szTabName.LoadString (IDS_MESSAGES_TAB); <br>iTab = AddTab(szTabName); <br>m_ctrlTabWnd.ChangeImage(iTab, IMG_OFF); <br>m_ctrlPrivateMsg.Create(WS_CHILD | WS_BORDER | WS_VSCROLL | <br>ES_MULTILINE | ES_AUTOVSCROLL| WS_EX_NOPARENTNOTIFY,  <br>rec,  <br>&amp;m_ctrlTabWnd, <br>IDC_HISTORY_RICHEDIT);  <br>ASSERT(m_ctrlPrivateMsg); <br> <br>//Log in a chat server <br>OnRoomLogin(); <br> <br>m_ctrlRoomList.ShowWindow(SW_SHOW); <br>//insert the first chat room <br>//OnFileNew(); <br> <br>return 0; <br>} <br> <br> <br>void CChappyView::OnFileNew()  <br>{ <br>// new room <br>CStringszTmp; <br>szTmp.LoadString(IDS_CHAT_TAB); <br>long iTab = AddTab(szTmp); <br>m_ctrlTabWnd.ChangeImage(iTab, IMG_OFF); <br> <br>//create a new chat room <br>m_ChatRoom[m_iLastTab] = (CRoom *) new CRoom; <br>m_ChatRoom[m_iLastTab]-&gt;Create(m_ctrlTabWnd, m_ocxChat.GetChannels()); <br> <br>if (!m_iLastTab) m_ChatRoom[m_iLastTab]-&gt;OnFocus(TRUE); // the first tab needs to get focus  <br> <br>//give focus to the new tab <br>m_ctrlTabWnd.SetCurrentTab(m_iLastTab); <br> <br>//redraw and update status <br>Invalidate(); <br> <br>} <br> <br>void CChappyView::OnSelchangeTab1(NMHDR* pNMHDR, LRESULT* pResult)  <br>{ <br>TRACE0("CChappyView::OnSelchangeTab1\n"); <br> <br>int iOldTab; <br> <br>iOldTab = m_iVisibleTab; <br>m_iVisibleTab = m_ctrlTabWnd.GetCurFocus(); <br> <br>//hide them all <br>m_ctrlRoomList.ShowWindow(SW_HIDE); <br>m_ctrlPrivateMsg.ShowWindow(SW_HIDE); <br> <br>if ( (LIST_TAB != iOldTab) &amp;&amp; (MESSAGE_TAB != iOldTab) ) <br>{ <br>if (m_ChatRoom[iOldTab])  <br>{ <br>m_ChatRoom[iOldTab]-&gt;OnFocus(FALSE); <br>} <br>} <br> <br> <br>switch (m_iVisibleTab)  <br>{ <br>case LIST_TAB: <br>m_ctrlRoomList.ShowWindow(SW_SHOW); <br>break; <br>case MESSAGE_TAB: <br>//server and private messages <br>m_ctrlPrivateMsg.ShowWindow(SW_SHOW); <br>m_ctrlTabWnd.ChangeImage(m_iVisibleTab, IMG_OFF); <br>break; <br>default: <br>//all the other tabs are rooms <br>if (m_ChatRoom[m_iVisibleTab]) <br>{ <br>m_ChatRoom[m_iVisibleTab]-&gt;OnFocus(TRUE); <br>m_ctrlTabWnd.ChangeImage(m_iVisibleTab, IMG_OFF); <br>} <br>} <br> <br> <br> <br>Invalidate(); <br> <br>*pResult = 0; <br>} <br> <br>void CChappyView::OnSize(UINT nType, int cx, int cy)  <br>{ <br>CView::OnSize(nType, cx, cy); <br> <br>m_cx = cx; <br>m_cy = cy; <br>} <br> <br>BOOL CChappyView::OnToolTipNotify( UINT id, NMHDR * pNMHDR, LRESULT * pResult ) <br>{ <br>TRACE0 ("OnToolTipNotify\n"); <br> <br>// need to handle both ANSI and UNICODE versions of the message <br>TOOLTIPTEXTA* pTTTA = (TOOLTIPTEXTA*)pNMHDR; <br>TOOLTIPTEXTW* pTTTW = (TOOLTIPTEXTW*)pNMHDR; <br>UINT nID = pNMHDR-&gt;idFrom; <br>TRACE ("  HWnd: %u\n",nID); <br> <br>if (((pNMHDR-&gt;code == TTN_NEEDTEXTA) || (pNMHDR-&gt;code == TTN_NEEDTEXTW)) &amp;&amp;  <br>(pTTTA-&gt;uFlags &amp; TTF_IDISHWND) ) <br>{ <br>        // idFrom is actually the HWND of the tool <br>        nID = ::GetDlgCtrlID((HWND)nID); <br>       TRACE ("  ID: %u\n",nID); <br>} <br> <br>if( (nID == ID_BTN_SEND) || <br>  (nID == ID_BTN_WHISPER) ) <br>{ <br>CString szTipText; <br>szTipText.LoadString(nID); <br> <br>        //pTTT-&gt;lpszText =(LPTSTR) (LPCTSTR) szTipText;// MAKEINTRESOURCE(nID); <br>        pTTTA-&gt;hinst = AfxGetResourceHandle(); <br>pTTTW-&gt;hinst = AfxGetResourceHandle(); <br>    <br>#ifndef _UNICODE <br>if (pNMHDR-&gt;code == TTN_NEEDTEXTA) <br>lstrcpyn(pTTTA-&gt;szText, (LPTSTR) (LPCTSTR) szTipText, _countof(pTTTA-&gt;szText)); <br>else <br>_mbstowcsz(pTTTW-&gt;szText, (LPTSTR) (LPCTSTR) szTipText, _countof(pTTTA-&gt;szText)); <br>#else <br>if (pNMHDR-&gt;code == TTN_NEEDTEXTA) <br>_wcstombsz(pTTTA-&gt;szText, (LPTSTR) (LPCTSTR) szTipText, _countof(pTTTA-&gt;szText)); <br>else <br>lstrcpyn(pTTTW-&gt;szText, (LPTSTR) (LPCTSTR) szTipText, _countof(pTTTA-&gt;szText)); <br>#endif <br> <br>// bring the tooltip window above other popup windows <br>::SetWindowPos(pNMHDR-&gt;hwndFrom, HWND_TOP, 0, 0, 0, 0, <br>SWP_NOACTIVATE|SWP_NOSIZE|SWP_NOMOVE|SWP_NOOWNERZORDER); <br> <br>return TRUE; <br>} <br> <br>    return FALSE; <br>} <br> <br> <br>void CChappyView::OnInitialUpdate()  <br>{ <br>CView::OnInitialUpdate(); <br> <br>BOOL ret = EnableToolTips(TRUE); <br>ASSERT(ret); <br> <br>} <br> <br>////////////////////////////////////////////////////////////////////////////// <br>//  OCX Event handlers <br>////////////////////////////////////////////////////////////////////////////// <br> <br>BEGIN_EVENTSINK_MAP(CChappyView, CView) <br>    //{{AFX_EVENTSINK_MAP(CChappyView) <br> <br>ON_EVENT(CChappyView, IDC_OCX_CHAT, 116 /* OnAddMember */, OnOnAddMemberMschatpr, VTS_DISPATCH VTS_BSTR VTS_DISPATCH) <br>ON_EVENT(CChappyView, IDC_OCX_CHAT, 114 /* OnBeginEnumeration */, OnOnBeginEnumerationMschatpr, VTS_DISPATCH VTS_I4) <br>ON_EVENT(CChappyView, IDC_OCX_CHAT, 113 /* OnChannelError */, OnOnChannelErrorMschatpr, VTS_DISPATCH VTS_I4 VTS_BSTR) <br>ON_EVENT(CChappyView, IDC_OCX_CHAT, 123 /* OnChannelProperty */, OnOnChannelPropertyMschatpr, VTS_DISPATCH VTS_DISPATCH) <br>ON_EVENT(CChappyView, IDC_OCX_CHAT, 124 /* OnChannelPropertyChanged */, OnOnChannelPropertyChangedMschatpr, VTS_DISPATCH VTS_BSTR VTS_BSTR VTS_VARIANT VTS_VARIANT) <br>ON_EVENT(CChappyView, IDC_OCX_CHAT, 112 /* OnChannelState */, OnOnChannelStateMschatpr, VTS_DISPATCH VTS_I4) <br>ON_EVENT(CChappyView, IDC_OCX_CHAT, 111 /* OnConnectionError */, OnOnConnectionErrorMschatpr, VTS_I4 VTS_BSTR VTS_VARIANT) <br>ON_EVENT(CChappyView, IDC_OCX_CHAT, 110 /* OnConnectionState */, OnOnConnectionStateMschatpr, VTS_I4) <br>ON_EVENT(CChappyView, IDC_OCX_CHAT, 117 /* OnDelMember */, OnOnDelMemberMschatpr, VTS_DISPATCH VTS_BSTR) <br>ON_EVENT(CChappyView, IDC_OCX_CHAT, 115 /* OnEndEnumeration */, OnOnEndEnumerationMschatpr, VTS_DISPATCH VTS_I4) <br>ON_EVENT(CChappyView, IDC_OCX_CHAT, 126 /* OnInvitation */, OnOnInvitationMschatpr, VTS_BSTR VTS_DISPATCH) <br>ON_EVENT(CChappyView, IDC_OCX_CHAT, 127 /* OnKnock */, OnOnKnockMschatpr, VTS_DISPATCH VTS_DISPATCH VTS_I4) <br>ON_EVENT(CChappyView, IDC_OCX_CHAT, 122 /* OnMemberKicked */, OnOnMemberKickedMschatpr, VTS_DISPATCH VTS_BSTR VTS_BSTR VTS_BSTR) <br>ON_EVENT(CChappyView, IDC_OCX_CHAT, 120 /* OnMemberProperty */, OnOnMemberPropertyMschatpr, VTS_DISPATCH VTS_DISPATCH) <br>ON_EVENT(CChappyView, IDC_OCX_CHAT, 121 /* OnMemberPropertyChanged */, OnOnMemberPropertyChangedMschatpr, VTS_DISPATCH VTS_BSTR VTS_BSTR VTS_BSTR VTS_VARIANT VTS_VARIANT) <br>ON_EVENT(CChappyView, IDC_OCX_CHAT, 130 /* OnMessage */, OnOnMessageMschatpr, VTS_DISPATCH VTS_BSTR VTS_I4 VTS_VARIANT VTS_VARIANT VTS_VARIANT) <br>ON_EVENT(CChappyView, IDC_OCX_CHAT, 128 /* OnPrivateMessage */, OnOnPrivateMessageMschatpr, VTS_BSTR VTS_I4 VTS_VARIANT VTS_VARIANT) <br>ON_EVENT(CChappyView, IDC_OCX_CHAT, 131 /* OnProtocolMessage */, OnOnProtocolMessageMschatpr, VTS_BSTR VTS_BSTR VTS_VARIANT VTS_PBOOL) <br>ON_EVENT(CChappyView, IDC_OCX_CHAT, 125 /* OnServerProperty */, OnOnServerPropertyMschatpr, VTS_DISPATCH) <br>ON_EVENT(CChappyView, IDC_OCX_CHAT, 129 /* OnServerTextMessage */, OnOnServerTextMessageMschatpr, VTS_I4 VTS_BSTR) <br>ON_EVENT(CChappyView, IDC_OCX_CHAT, 118 /* OnUserProperty */, OnOnUserPropertyMschatpr, VTS_DISPATCH) <br>ON_EVENT(CChappyView, IDC_OCX_CHAT, 119 /* OnUserPropertyChanged */, OnOnUserPropertyChangedMschatpr, VTS_BSTR VTS_BSTR VTS_BSTR VTS_VARIANT VTS_VARIANT) <br> <br> <br>//}}AFX_EVENTSINK_MAP <br>END_EVENTSINK_MAP() <br> <br> <br>void CChappyView::OnOnMessageMschatpr(LPDISPATCH Channel, LPCTSTR SenderNickname, long MessageType, const VARIANT FAR&amp; Message, const VARIANT FAR&amp; RecipientNicknames, const VARIANT FAR&amp; DataMessageTag) <br>{ <br>TRACE ("--- CChappyView::OnOnMessageMschatpr - %u %s %u %u \n", Channel, SenderNickname, MessageType, Message.vt ); <br> <br>if (((VT_BSTR == Message.vt) || ((VT_BYREF | VT_VARIANT) == Message.vt))&amp;&amp;  <br>((msgtNormal == MessageType) || (msgtWhisper == MessageType)) || (msgtAction == MessageType)) //comic chat sends info messages <br>{ <br>CString szTmp; <br>if (VT_BSTR == Message.vt) <br>{ <br>szTmp = Message.bstrVal;  <br>} <br>else if ((VT_BYREF | VT_VARIANT) == Message.vt) <br>{ <br>szTmp = Message.pvarVal-&gt;bstrVal; <br>} <br> <br>long iTab = GetTabFromIndex(Channel); <br>if (m_ChatRoom[iTab]) <br>{ <br>long iMT = IMG_OFF; <br>if (iTab != m_iVisibleTab) <br>{ <br>if (msgtNormal == MessageType)  <br>{ <br>iMT = IMG_SAY; <br>} <br>else if (msgtWhisper == MessageType) <br>{ <br>iMT = IMG_WHISPER; <br>}  <br>else if (msgtAction == MessageType) <br>{ <br>iMT = IMG_DO; <br>} <br>m_ctrlTabWnd.ChangeImage(iTab, iMT); <br>} <br> <br>m_ChatRoom[iTab]-&gt;m_ctrlHistoryWnd.UpdateMessageUI(SenderNickname, MessageType, szTmp); <br>} <br>} <br> <br>} <br> <br>void CChappyView::OnOnPrivateMessageMschatpr(LPCTSTR SenderNickname, long PrivateMessageType, const VARIANT FAR&amp; Message, const VARIANT FAR&amp; DataMessageTag) <br>{ <br>TRACE0 ("--- CChappyView::OnOnPrivateMessageMschatpr\n"); <br> <br>if ((VT_BSTR == Message.vt) &amp;&amp; (0x20 &gt; PrivateMessageType)) //comic chat sends info messages <br>{ <br>CString szTmp(Message.bstrVal);  <br> <br>m_ctrlPrivateMsg.AddText("- Private message from ", TRUE); <br>m_ctrlPrivateMsg.UpdateMessageUI(SenderNickname, PrivateMessageType, szTmp); <br>m_ctrlTabWnd.ChangeImage(1, IMG_IMPORTANT); <br>//m_ChatRoom[m_iVisibleTab].AddText("--- End Private message ---", TRUE); <br>} <br>} <br> <br>void CChappyView::OnOnServerTextMessageMschatpr(long ServerMessageType, LPCTSTR Text)  <br>{ <br>TRACE0 ("--- CChappyView::OnOnServerTextMessageMschatpr\n"); <br> <br>static long iCurrentType_s = -1; <br>m_ctrlPrivateMsg.SetTextColor(RGB(0, 64, 128)); //nice blue <br>//Post a message in the history control <br>//CString szInMsg; <br>if (ServerMessageType != iCurrentType_s)   <br>{ <br>//print the message type only once <br>iCurrentType_s = ServerMessageType; <br>CString szTmp; <br>szTmp.LoadString(IDS_SMT_NORMAL + ServerMessageType); <br>m_ctrlPrivateMsg.AddText(szTmp, TRUE); <br>} <br>m_ctrlPrivateMsg.AddText("\t"); <br>m_ctrlPrivateMsg.AddText(Text); <br>m_ctrlPrivateMsg.AddText("\n"); <br>m_ctrlPrivateMsg.SetTextColor(GetSysColor (COLOR_WINDOWTEXT)); //default text color <br>} <br> <br>void CChappyView::OnOnAddMemberMschatpr(LPDISPATCH Channel, LPCTSTR Nickname, LPDISPATCH MemberItems)  <br>{ <br>TRACE2 ("--- CChappyView::OnOnAddMemberMschatpr: Channel: %u Nickname: %s \n",Channel,Nickname); <br> <br>//add the user to the listview control <br>HTREEITEM iTreeItem; <br>long iTab = GetTabFromIndex(Channel); <br> <br> <br>ASSERT (m_ChatRoom[iTab]); <br>iTreeItem = m_ChatRoom[iTab]-&gt;m_ctrlPartListWnd.InsertItem(Nickname); <br> <br> <br>ASSERT (Channel); <br>IChannelObjectIChannel(Channel); <br>IChannel.m_bAutoRelease = FALSE;  //do not release the object when done <br> <br>//let's go get some of thouse hard to find properties <br>IChatItemsITmpChatItems = IChannel.GetMemberProperty("IPAddress", COleVariant(Nickname)); <br>ASSERT (ITmpChatItems); <br> <br>//let's see what the server returned <br>COleSafeArray vValidItemsArray(ITmpChatItems.GetValidItems()); <br> <br>TRACE1 ("Array Dimensions: %i \n",vValidItemsArray.GetDim()); <br> <br>long iSize = (long) vValidItemsArray.GetOneDimSize(); <br>TRACE1 (" Number of elements: %i \n",iSize); <br> <br>HLOCAL element = LocalAlloc (GMEM_ZEROINIT | LMEM_FIXED ,vValidItemsArray.GetElemSize()+2);//+2 just to be safe <br>for (long i = 0; i &lt;iSize ; ++i) <br>{ <br>COleVariant data((LPCSTR)element); <br>vValidItemsArray.GetElement(&amp;i, (void *) data); <br>CString szItemName (data.bstrVal); <br>TRACE2 ("%u. Item Name: %s\n",i, szItemName); <br>COleVariant vItem(ITmpChatItems.GetItem(szItemName)); <br> <br>CString szTextOut; <br>if (VT_BSTR == vItem.vt) <br>{ <br>CString szItem(vItem.bstrVal); <br>szTextOut.Format("%s: %s", szItemName, szItem); <br>} <br>else if ((VT_I2 == vItem.vt) || (VT_I4 == vItem.vt)) <br>{ <br>long iItem = (VT_I2 == vItem.vt) ? vItem.iVal : vItem.lVal; <br>szTextOut.Format("%s: %u", szItemName, iItem); <br>} <br> <br>if (!szTextOut.IsEmpty()) <br>{ <br>TRACE0 (szTextOut);  <br>TRACE0 ("\n"); <br> <br>//insert the item <br> <br>m_ChatRoom[iTab]-&gt;m_ctrlPartListWnd.InsertItem(szTextOut, iTreeItem); <br> <br>} <br>} <br>LocalFree(element); <br> <br>//Post a message in the history control <br>CString szInMsg; <br>CString szTmp; <br>szTmp.LoadString(IDS_ADD_MEMBER); <br>szInMsg.Format("%s %s\n\n",Nickname, szTmp); //blabla entered the room <br>m_ChatRoom[iTab]-&gt;m_ctrlHistoryWnd.AddText(szInMsg, TRUE); <br> <br>//m_ctrlPartListWnd.InsertItem("Name", item); <br>//m_ctrlPartListWnd.InsertItem("e-mail", item); <br> <br> <br>} <br> <br>void CChappyView::OnOnDelMemberMschatpr(LPDISPATCH Channel, LPCTSTR Nickname)  <br>{ <br>TRACE0 ("--- CChappyView::OnOnDelMemberMschatpr\n"); <br>long iTab = GetTabFromIndex(Channel); <br> <br>ASSERT(m_ChatRoom[iTab]); <br>m_ChatRoom[iTab]-&gt;m_ctrlPartListWnd.DeleteItemFromText (Nickname); <br> <br>//Post a message in the history control <br>CString szInMsg; <br>CString szTmp; <br>szTmp.LoadString(IDS_DEL_MEMBER); <br>szInMsg.Format("%s %s\n\n",Nickname, szTmp); //blabla exit the room <br>m_ChatRoom[iTab]-&gt;m_ctrlHistoryWnd.AddText(szInMsg, TRUE); <br> <br>} <br> <br>void CChappyView::OnOnChannelStateMschatpr(LPDISPATCH Channel, long NewChannelState)  <br>{ <br>TRACE1 ("--- CChappyView::OnOnChannelStateMschatpr %u\n", NewChannelState); <br>long iTab = GetTabFromIndex(Channel); <br> <br>ASSERT(m_ChatRoom[iTab]); <br> <br>if (chsClosed == NewChannelState) <br>{ <br>m_ChatRoom[iTab]-&gt;DestroyRoom(); <br>//delete (m_ChatRoom[iTab]); <br>//m_ctrlTabWnd.DeleteItem(iTab); <br> <br>//rename the tab <br>CString szEmptyRoomTab; <br>szEmptyRoomTab.LoadString(IDS_CHAT_TAB); <br>m_ctrlTabWnd.RenameTab(iTab, szEmptyRoomTab); <br> <br>} <br> <br>} <br> <br>void CChappyView::OnOnConnectionStateMschatpr(long NewConnectionState)  <br>{ <br>TRACE1 ("--- CChappyView::OnOnConnectionStateMschatpr, State: %u\n", NewConnectionState); <br> <br>m_iServerConnectionState = NewConnectionState; <br>m_iServerConnectionType = (csConnected &lt;= m_iServerConnectionState) ? m_ocxChat.GetConnectionType() : -1; <br> <br>//as soon as we are logged in we display the list of rooms (if requested) <br>if (m_bShowRoomList &amp;&amp; (csLogged == m_iServerConnectionState))  <br>{ <br>OnRoomListrooms(); <br>} <br>else if (csLogged == m_iServerConnectionState) //just once <br>{ <br>//no room list <br>CString szNoRoomList; <br>szNoRoomList.LoadString(IDS_NO_ROOM_LIST_MSG); <br>m_ctrlRoomList.AddColumn(szNoRoomList); <br>} <br>else if (csDisconnected == m_iServerConnectionState) //just once <br>{ <br>//clean up !! <br>//CleanUp(); <br>} <br>} <br> <br>void CChappyView::OnOnChannelPropertyMschatpr(LPDISPATCH Channel, LPDISPATCH ChannelItems)  <br>{ <br>TRACE1 ("--- CChappyView::OnOnChannelPropertyMschatpr: Channel: %u\n",Channel); <br> <br>static int iItemIndex = -1; <br> <br>if (NULL == Channel)  <br>{ <br>//populate the room list <br>CChatItemsITmpChatItems (ChannelItems); <br>ITmpChatItems.m_bAutoRelease = FALSE; <br>ASSERT (ITmpChatItems); <br>CString szType = ITmpChatItems.GetAssociatedType(); <br> <br>//let's see what the server returned <br>COleSafeArray vValidItemsArray(ITmpChatItems.GetValidItems()); <br> <br>TRACE1 ("Array Dimensions: %i \n",vValidItemsArray.GetDim()); <br> <br>long iSize = (long) vValidItemsArray.GetOneDimSize(); <br>TRACE1 (" Number of elements: %i \n",iSize); <br> <br>HLOCAL element = LocalAlloc (GMEM_ZEROINIT | LMEM_FIXED ,vValidItemsArray.GetElemSize()+2);//+2 just to be safe <br>for (long i = 0; i &lt;iSize ; ++i) <br>{ <br>COleVariant data((LPCSTR)element); <br>vValidItemsArray.GetElement(&amp;i, (void *) data); <br>CString szItemName (data.bstrVal); <br>TRACE2 ("%u. Item Name: %s\n",i, szItemName); <br> <br>//insert the a new column if we do not have one already <br>if ( i &gt;= m_ctrlRoomList.GetNumOfColumns()) <br>{ <br>m_ctrlRoomList.AddColumn(szItemName); <br>} <br> <br>//get the item <br>COleVariant vItem(ITmpChatItems.GetItem(szItemName)); <br> <br>CString szTextOut; <br>if (VT_BSTR == vItem.vt) <br>{ <br>CString szItem(vItem.bstrVal); <br>szTextOut.Format("%s", szItem); <br>} <br>else if ((VT_I2 == vItem.vt) || (VT_I4 == vItem.vt)) <br>{ <br>long iItem = (VT_I2 == vItem.vt) ? vItem.iVal : vItem.lVal; <br>szTextOut.Format("%u", iItem); <br>} <br> <br>if (!szTextOut.IsEmpty()) <br>{ <br>TRACE0 (szTextOut);  <br>TRACE0 ("\n"); <br> <br>if (0 == i) // means that this is the room name <br>{ <br>//insert the item <br>m_ctrlRoomList.InsertNextItem(szTextOut); <br>} <br>else <br>{ <br>//add the sub items to the current item <br>m_ctrlRoomList.AddSubItem(i, szTextOut); <br>} <br>} <br>} <br>LocalFree(element); <br>} <br>} <br> <br>void CChappyView::OnOnMemberKickedMschatpr(LPDISPATCH Channel, LPCTSTR KickedNickname, LPCTSTR KickerNickname, LPCTSTR Reason)  <br>{ <br>TRACE0 ("--- CChappyView::OnOnMemberKickedMschatpr\n"); <br> <br>ASSERT (Channel); <br>IChannelObjectIChannel(Channel); <br>IChannel.m_bAutoRelease = FALSE;  //do not release the object when done <br> <br>CString szFormat; <br>szFormat.LoadString(IDS_KICKED_MSG); <br>CString szMessage; <br>szMessage.Format ((LPCTSTR) szFormat, KickedNickname, IChannel.GetChannelName(), Reason); <br> <br>TRACE0 (szMessage); <br>TRACE0 ("\n"); <br> <br>AfxMessageBox(szMessage); <br>} <br> <br>void CChappyView::OnOnChannelErrorMschatpr(LPDISPATCH Channel, long ErrorCode, LPCTSTR Description)  <br>{ <br>TRACE0 ("--- CChappyView::OnOnChannelErrorMschatpr\n"); <br>ASSERT (Channel); <br>IChannelObjectIChannel(Channel); <br>IChannel.m_bAutoRelease = FALSE;  //do not release the object when done <br> <br>CString szFormat; <br>szFormat.LoadString(IDS_CHANNEL_ERROR_MSG); <br>CString szMessage; <br>szMessage.Format ((LPCTSTR) szFormat, IChannel.GetChannelName(), ErrorCode, Description); <br> <br>TRACE0 (szMessage); <br>TRACE0 ("\n"); <br> <br>AfxMessageBox(szMessage); <br>} <br> <br>void CChappyView::OnOnConnectionErrorMschatpr(long ErrorCode, LPCTSTR Description, const VARIANT FAR&amp; ChannelName)  <br>{ <br>TRACE0 ("--- CChappyView::OnOnConnectionErrorMschatpr\n"); <br> <br>CString szFormat; <br>szFormat.LoadString(IDS_CONNECTION_ERROR_MSG); <br>CString szMessage; <br>szMessage.Format ((LPCTSTR) szFormat, ErrorCode, Description); <br> <br>TRACE0 (szMessage); <br>TRACE0 ("\n"); <br> <br>AfxMessageBox(szMessage); <br>} <br> <br> <br>void CChappyView::OnOnChannelPropertyChangedMschatpr(LPDISPATCH Channel, LPCTSTR ModifierNickname, LPCTSTR ChannelPropertyName, const VARIANT FAR&amp; OldChannelProperty, const VARIANT FAR&amp; NewChannelProperty)  <br>{ <br>TRACE0 ("--- CChappyView::OnOnChannelPropertyChangedMschatpr\n"); <br>} <br> <br>void CChappyView::OnOnServerPropertyMschatpr(LPDISPATCH ServerItems)  <br>{ <br>TRACE0 ("--- CChappyView::OnOnServerPropertyMschatpr\n"); <br>} <br> <br>void CChappyView::OnOnProtocolMessageMschatpr(LPCTSTR MessagePrefix, LPCTSTR MessageCommand, const VARIANT FAR&amp; MessageParameters, BOOL FAR* EnableDefault)  <br>{ <br>TRACE0 ("--- CChappyView::OnOnProtocolMessageMschatpr\n"); <br>} <br> <br>void CChappyView::OnOnUserPropertyMschatpr(LPDISPATCH UserItems)  <br>{ <br>TRACE0 ("--- CChappyView::OnOnUserPropertyMschatpr\n"); <br>} <br> <br>void CChappyView::OnOnUserPropertyChangedMschatpr(LPCTSTR ModifiedNickname, LPCTSTR ModifierNickname, LPCTSTR UserPropertyName, const VARIANT FAR&amp; OldUserProperty, const VARIANT FAR&amp; NewUserProperty)  <br>{ <br>TRACE0 ("--- CChappyView::OnOnUserPropertyChangedMschatpr\n"); <br>} <br> <br>void CChappyView::OnOnMemberPropertyMschatpr(LPDISPATCH Channel, LPDISPATCH MemberItems)  <br>{ <br>TRACE0 ("--- CChappyView::OnOnMemberPropertyMschatpr\n"); <br>} <br> <br>void CChappyView::OnOnMemberPropertyChangedMschatpr(LPDISPATCH Channel, LPCTSTR ModifiedNickname, LPCTSTR ModifierNickname, LPCTSTR MemberPropertyName, const VARIANT FAR&amp; OldMemberProperty, const VARIANT FAR&amp; NewMemberProperty)  <br>{ <br>TRACE0 ("--- CChappyView::OnOnMemberPropertyChangedMschatpr\n"); <br>} <br> <br>void CChappyView::OnOnInvitationMschatpr(LPCTSTR ChannelName, LPDISPATCH InviterItems)  <br>{ <br>TRACE0 ("--- CChappyView::OnOnInvitationMschatpr\n"); <br>} <br>void CChappyView::OnOnKnockMschatpr(LPDISPATCH Channel, LPDISPATCH KnockerItems, long ErrorCode)  <br>{ <br>TRACE0 ("--- CChappyView::OnOnKnockMschatpr\n"); <br>} <br> <br>void CChappyView::OnOnBeginEnumerationMschatpr(LPDISPATCH Channel, long EnumType)  <br>{ <br>TRACE0 ("--- CChappyView::OnOnBeginEnumerationMschatpr\n"); <br>} <br> <br>void CChappyView::OnOnEndEnumerationMschatpr(LPDISPATCH Channel, long EnumType)  <br>{ <br>TRACE2 ("--- CChappyView::OnOnEndEnumerationMschatpr - %u %u\n", Channel, EnumType); <br> <br>} <br> <br> <br>////////////////////////////////////////////////////////////////////////////// <br>//  Command message handler <br>////////////////////////////////////////////////////////////////////////////// <br> <br>////////////////////////////////////////////////////////////////////////////// <br>//  Sending chat messages <br>////////////////////////////////////////////////////////////////////////////// <br> <br>void CChappyView::OnBtnSend()  <br>{ <br>PostChatMessage(msgtNormal); <br>} <br> <br>void CChappyView::OnBtnWhisper()  <br>{ <br>PostChatMessage(msgtWhisper); <br>} <br> <br>void CChappyView::OnBtnDo()  <br>{ <br>PostChatMessage(msgtAction); </code></pre>
<p>
</p>
<pre><code>} <br> <br>void CChappyView::OnBtnThink()  <br>{ <br>PostChatMessage(msgtThought); <br>} <br> <br>void CChappyView::PostChatMessage(long iMsgType_p) <br>{ <br> <br>if (!IsRoomTab(m_iVisibleTab))  <br>{ <br>//not in a room tab <br>return; <br>} <br> <br>ASSERT(m_ChatRoom[m_iVisibleTab]); <br> <br>//select all <br>m_ctrlInputWnd.SetSel(0,-1); <br>if (SEL_EMPTY == m_ctrlInputWnd.GetSelectionType()) <br>{ <br>//notting to send <br>return ; <br>} <br> <br>//get the selection text <br>CString szSendText = m_ctrlInputWnd.GetSelText(); <br>//The control clean itself on VK_RETURN but we need to clean it  <br>//if we hit the toobar button <br>m_ctrlInputWnd.Clear(); <br> <br>//Send the text if we got any <br>if ("" == szSendText)  <br>{ <br>//notting to send <br>return ; <br>} <br> <br>m_ChatRoom[m_iVisibleTab]-&gt;SendMessage(m_szMyAlias, iMsgType_p, szSendText); <br> <br>//clean up the control <br>m_ctrlInputWnd.SetSel(0,-1); <br>m_ctrlInputWnd.Clear();  <br>} <br> <br>void CChappyView::OnHistoryClear()  <br>{ <br>TRACE("CChappyView::OnFileSave\n"); <br> <br>ASSERT (m_iVisibleTab &gt; LIST_TAB); <br> <br>CHistory*ctrlVisibleHistory; <br> <br>if (m_iVisibleTab == MESSAGE_TAB) <br>{ <br>ctrlVisibleHistory = &amp;m_ctrlPrivateMsg; <br>} <br>else <br>{ <br>ctrlVisibleHistory = m_ChatRoom[m_iVisibleTab]-&gt;GetRoomHistoryCtrlPtr(); <br>} <br> <br>ctrlVisibleHistory-&gt;ClearAll(); <br> <br>} <br> <br> <br>////////////////////////////////////////////////////////////////////////////// <br>//  Log in and out of servers <br>////////////////////////////////////////////////////////////////////////////// <br> <br>void CChappyView::OnRoomLogin()  <br>{ <br>ASSERT (m_ocxChat); <br> <br>long iState = GetServerConnectionState(); <br> <br>//we enable the menu only if we are disconnected or logged <br>ASSERT ( (csLogged == iState) || (csDisconnected == iState)); <br> <br>CLogInDlg LogInDlg; <br> <br> <br>LogInDlg.m_szNickname.LoadString(IDS_DEFAULT_NICKNAME); <br>LogInDlg.m_szServerName.LoadString(IDS_DEFAULT_SERVER);  <br> <br>int iRet = LogInDlg.DoModal(); <br>if (IDOK == iRet) <br>{ <br>//this will tell us if we display the room list at startup <br>m_bShowRoomList = LogInDlg.m_bShowRoomList; <br> <br>COleVariant vRealName;//(_T("myrealname")); <br>COleVariant vUserName; //the ocx will get windows user name <br>COleVariant vSecurity;(_T("NTLM;ALL")); <br>COleVariant vPassword(LogInDlg.m_szPassword); <br>//COleVariant vUserModes(1L,VT_I4); <br>m_szMyAlias= LogInDlg.m_szNickname; <br>m_ocxChat.Login(LogInDlg.m_szServerName, LogInDlg.m_szNickname, vUserName , vRealName, vPassword, vSecurity); <br>//clean the list view <br>m_ctrlRoomList.ClearList(); <br>} <br>} <br> <br> <br>void CChappyView::OnRoomLogout()  <br>{ <br>long iState = GetServerConnectionState(); <br> <br>ASSERT (csDisconnected != iState); <br>ASSERT (csDisconnecting != iState); <br> <br>m_ctrlPrivateMsg.AddText("\n"); <br> <br>if ( (csConnecting == iState) || <br> (csLogging == iState) ) <br>{ <br>m_ocxChat.CancelConnectLogin(); <br>} <br>else <br>{ <br>m_ocxChat.Disconnect(); <br>} <br> <br>//clean the list view <br>m_ctrlRoomList.ClearList(); <br>} <br> <br> <br>////////////////////////////////////////////////////////////////////////////// <br>//  Enter and exit rooms <br>////////////////////////////////////////////////////////////////////////////// <br> <br>void CChappyView::OnRoomListEnterRoom()  <br>{ <br> <br>CString szRoomName = m_ctrlRoomList.GetItemText(m_ctrlRoomList.GetSelectedItem(), 0); <br> <br>CPWordDlgdlgPW; <br>if (IDOK == dlgPW.DoModal()) <br>{ <br>//add the tab <br>OnFileNew(); <br>//enter room <br>EnterRoom(m_iLastTab, szRoomName, dlgPW.m_szPassword); <br>} <br> <br>} <br> <br>void CChappyView::EnterRoom(long iTab, CString &amp; szRoom, CString &amp; szPassword) <br>{ <br>//we never use the fist 2 items in the array of rooms <br>ASSERT(m_ChatRoom[iTab]); <br> <br>m_ChatRoom[iTab]-&gt;EnterRoom(iTab, szRoom, szPassword); <br> <br>//if I succed change the name of the tab <br>m_ctrlTabWnd.RenameTab(iTab, szRoom); <br>m_ctrlTabWnd.SetCurrentTab(m_iLastTab); <br> <br>//The tab grabs focus and covers the history, a repaint fixes it <br>Invalidate(); <br>} <br> <br>void CChappyView::OnRoomConnect()  <br>{ <br>ASSERT(m_ocxChat); <br> <br>CEnterDlgdlgEnter; <br> <br>int iDlgRet = dlgEnter.DoModal(); <br> <br>if (iDlgRet == IDOK) <br>{ <br> <br>TRACE1("Room URL: %s\n",(LPCTSTR) dlgEnter.m_szRoom); <br> <br>//enter room <br>EnterRoom(m_iVisibleTab, dlgEnter.m_szRoom, dlgEnter.m_szPassword); <br> <br>} <br>else <br>{ <br>if (iDlgRet != IDCANCEL) <br>{ <br>AfxMessageBox ("Error Displaying the dialog: %i", iDlgRet); <br>} <br>} <br> <br>} <br> <br>void CChappyView::OnRoomDisconnect()  <br>{ <br>if (csLogged == m_iServerConnectionState) <br>{ <br>//exit the room <br>ASSERT (m_ChatRoom[m_iVisibleTab]); <br>m_ChatRoom[m_iVisibleTab]-&gt;LeaveChannel(); <br>} <br>} <br> <br> <br>////////////////////////////////////////////////////////////////////////////// <br>//  UI Update handlers <br>////////////////////////////////////////////////////////////////////////////// <br> <br>void CChappyView::OnUpdateRoomConnect(CCmdUI* pCmdUI)  <br>{ <br>pCmdUI-&gt;Enable ((csLogged == m_iServerConnectionState)&amp;&amp; <br>(IsRoomTab(m_iVisibleTab))&amp;&amp; <br>(chsClosed == GetCurrentChannelState())) ; <br> <br>} <br> <br>void CChappyView::OnUpdateRoomDisconnect(CCmdUI* pCmdUI)  <br>{ <br>pCmdUI-&gt;Enable ((csLogged == m_iServerConnectionState)&amp;&amp;  <br>(IsRoomTab(m_iVisibleTab))&amp;&amp; <br>(chsClosed != GetCurrentChannelState())); <br>} <br> <br> <br>void CChappyView::OnUpdateRoomLogin(CCmdUI* pCmdUI)  <br>{ <br>pCmdUI-&gt;Enable (csDisconnected == m_iServerConnectionState); <br> <br>} <br> <br>void CChappyView::OnUpdateRoomLogout(CCmdUI* pCmdUI)  <br>{ <br>pCmdUI-&gt;Enable ((csDisconnected != m_iServerConnectionState) &amp;&amp; <br>(csDisconnecting != m_iServerConnectionState)); <br> <br>CString szNewMenuText; <br>if ((csConnecting == m_iServerConnectionState) || <br>(csLogging == m_iServerConnectionState)) <br>{ <br>szNewMenuText.LoadString(IDS_MNU_CANCEL_LOGGING); <br>} <br>else <br>{ <br>szNewMenuText.LoadString(IDS_MNU_LOGOUT); <br>} <br> <br>pCmdUI-&gt;SetText(szNewMenuText); <br> <br>} <br> <br>void CChappyView::OnUpdateRoomListEnterRoom(CCmdUI* pCmdUI)  <br>{ <br>pCmdUI-&gt;Enable( (-1 != m_ctrlRoomList.GetSelectedItem()) ); <br>} <br> <br>void CChappyView::OnUpdateRoomListRooms(CCmdUI* pCmdUI)  <br>{ <br>pCmdUI-&gt;Enable ((csDisconnected != m_iServerConnectionState) &amp;&amp; <br>(csDisconnecting != m_iServerConnectionState)); <br> <br>} <br> <br>void CChappyView::OnUpdatePartlistKick(CCmdUI* pCmdUI)  <br>{ <br>pCmdUI-&gt;Enable((IsRoomTab(m_iVisibleTab))&amp;&amp; <br>(!m_ChatRoom[m_iVisibleTab]-&gt;GetSelectedMember().IsEmpty())); <br>} <br> <br>void CChappyView::OnUpdatePartlistBan(CCmdUI* pCmdUI)  <br>{ <br>pCmdUI-&gt;Enable((IsRoomTab(m_iVisibleTab))&amp;&amp; <br>(!m_ChatRoom[m_iVisibleTab]-&gt;GetSelectedMember().IsEmpty())); <br> <br>} <br> <br>void CChappyView::OnUpdateServerBanuser(CCmdUI* pCmdUI)  <br>{ <br>pCmdUI-&gt;Enable ((csDisconnected != m_iServerConnectionState) &amp;&amp; <br>(csDisconnecting != m_iServerConnectionState)); <br>} <br> <br>void CChappyView::OnUpdatePartlistMakehost(CCmdUI* pCmdUI)  <br>{ <br>pCmdUI-&gt;Enable((IsRoomTab(m_iVisibleTab))&amp;&amp; <br>(!m_ChatRoom[m_iVisibleTab]-&gt;GetSelectedMember().IsEmpty())); <br> <br>} <br> <br>void CChappyView::OnUpdatePartlistMakeparticipant(CCmdUI* pCmdUI)  <br>{ <br>pCmdUI-&gt;Enable((IsRoomTab(m_iVisibleTab))&amp;&amp; <br>(!m_ChatRoom[m_iVisibleTab]-&gt;GetSelectedMember().IsEmpty())); <br>} <br> <br>void CChappyView::OnUpdateFileSave(CCmdUI* pCmdUI)  <br>{ <br>pCmdUI-&gt;Enable(m_iVisibleTab &gt; LIST_TAB); <br> <br>} <br> <br>void CChappyView::OnUpdateHistoryClear(CCmdUI* pCmdUI)  <br>{ <br>pCmdUI-&gt;Enable(m_iVisibleTab &gt; LIST_TAB); <br>} <br> <br> <br>////////////////////////////////////////////////////////////////////////////// <br>//  Room list <br>////////////////////////////////////////////////////////////////////////////// <br> <br>void CChappyView::OnRoomListrooms()  <br>{ <br>TRACE0 ("--- CChappyView::OnRoomListrooms\n"); <br> <br>//clean the list view <br>m_ctrlRoomList.ClearList(); <br> <br>CChatItemsITmpChatItems = m_ocxChat.GetNewChatItems();  <br>ASSERT (ITmpChatItems); <br>ITmpChatItems.SetAssociatedType("Query"); <br>m_ocxChat.ListChannels(ITmpChatItems); <br>//the list is populated asyncronusly in OnOnChannelPropertyMschatpr <br>} <br> <br>////////////////////////////////////////////////////////////////////////////// <br>//  Kick and Ban <br>////////////////////////////////////////////////////////////////////////////// <br> <br>void CChappyView::OnPartlistKick()  <br>{ <br>CKickDlgdlgKick; <br> <br>if (IDOK == dlgKick.DoModal())  <br>{ <br>m_ChatRoom[m_iVisibleTab]-&gt;KickMember(dlgKick.m_szReason); <br>} <br>} <br> <br>void CChappyView::OnPartlistBan()  <br>{ <br>m_ChatRoom[m_iVisibleTab]-&gt;BanMember(m_ocxChat.GetNewChatItems()); <br>} <br> <br>void CChappyView::OnServerBanuser()  <br>{ <br>//pop the dialog <br>CBanDlg dlgBan; <br> <br>dlgBan.m_iBan= 1; <br>dlgBan.m_iOperation = 0; <br>dlgBan.m_iProperty= 0; <br>dlgBan.m_iDuration= 1; <br> <br>if ( IDOK == dlgBan.DoModal()) <br>{ <br> <br>CChatItemsITmpChatItems = m_ocxChat.GetNewChatItems();  <br>ASSERT (ITmpChatItems); <br>ITmpChatItems.SetAssociatedType("Query"); <br> <br>CString szProperty; <br>szProperty.LoadString(IDS_IP_ADDRESS_ITEM+dlgBan.m_iProperty); <br>ITmpChatItems.SetItem (szProperty, COleVariant(dlgBan.m_szValue)); <br> <br>if (0 &lt; dlgBan.m_iOperation) <br>{ <br>CString szOperationName; <br>szOperationName.LoadString(IDS_IP_ADDRESS_OP_NAME+dlgBan.m_iProperty); <br>CString szOperation; <br>szOperation.LoadString(IDS_CONTAINS_OP+dlgBan.m_iOperation-1); <br>ITmpChatItems.SetItem (szOperationName, COleVariant(szOperation)); <br>} <br> <br>m_ocxChat.BanUsers(ITmpChatItems, dlgBan.m_iBan, COleVariant(dlgBan.m_szReason), COleVariant(dlgBan.m_iDuration)); <br> <br> <br>} <br>} <br> <br>////////////////////////////////////////////////////////////////////////////// <br>//  change members property <br>////////////////////////////////////////////////////////////////////////////// <br> <br>void CChappyView::OnPartlistMakehost()  <br>{ <br>m_ChatRoom[m_iVisibleTab]-&gt;MakeHost(TRUE); <br>} <br> <br>void CChappyView::OnPartlistMakeparticipant()  <br>{ <br>m_ChatRoom[m_iVisibleTab]-&gt;MakeHost(FALSE); <br>} <br> <br> <br> <br>////////////////////////////////////////////////////////////////////////////// <br>//Utilities <br>////////////////////////////////////////////////////////////////////////////// <br> <br>long CChappyView::GetIndexFromChannel(LPDISPATCH Channel_p) <br>{ <br>for (int i = 0; i &lt;= m_iLastTab; ++i) <br>{ <br> <br>if(m_ChatRoom[i] &amp;&amp;   <br>(Channel_p == m_ChatRoom[i]-&gt;GetChannel()))  <br>{ <br>return m_ChatRoom[i]-&gt;GetIndex(); <br>} <br>} <br> <br>return -1; <br> <br>// <br>//ASSERT (Channel_p); <br>//IChannelObjectIChannel(Channel_p); <br>//IChannel.m_bAutoRelease = FALSE;  //do not release the object when done <br>////The tabs are in sync with the indexes <br>//return (IChannel.GetIndex()); <br> <br>} <br> <br>long CChappyView::AddTab(CString &amp; szTitle_p) <br>{ <br>m_iLastTab++; <br> <br>//insert a new tab <br>TC_ITEM tcItem; <br>tcItem.mask = TCIF_TEXT; <br> <br>char szTabTitle[256]; <br>sprintf(szTabTitle, " %s ",(LPCTSTR) szTitle_p); //e.g." Rooms " <br>tcItem.pszText = szTabTitle; <br> <br>int ret =  m_ctrlTabWnd.InsertItem(m_iLastTab ,&amp;tcItem); <br>ASSERT (m_iLastTab==ret); <br>return m_iLastTab; <br>} <br> <br>//|void CChappyView::CleanUp() <br>//|{ <br>//|for (long i=0; i &lt; MAX_ROOMS; ++i) <br>//|{ <br>//|if (m_ChatRoom[i]) <br>//|{ <br>//|m_ChatRoom[i]-&gt;DestroyRoom(); <br>//| <br>//|CString szEmptyRoomTab; <br>//|szEmptyRoomTab.LoadString(IDS_CHAT_TAB); <br>//|m_ctrlTabWnd.RenameTab(i, szEmptyRoomTab); <br>//|} <br>//|} <br>//|} <br> <br>////////////////////////////////////////////////////////////////////////////// <br>//  SAVE <br>////////////////////////////////////////////////////////////////////////////// <br> <br>void CChappyView::OnFileSave()  <br>{ <br>TRACE("CChappyView::OnFileSave\n"); <br> <br>ASSERT (m_iVisibleTab &gt; LIST_TAB); <br> <br>CHistory*ctrlVisibleHistory; <br> <br>if (m_iVisibleTab == MESSAGE_TAB) <br>{ <br>ctrlVisibleHistory = &amp;m_ctrlPrivateMsg; <br>} <br>else <br>{ <br>ctrlVisibleHistory = m_ChatRoom[m_iVisibleTab]-&gt;GetRoomHistoryCtrlPtr(); <br>} <br> <br>ctrlVisibleHistory-&gt;OnFileSave(); <br> <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
