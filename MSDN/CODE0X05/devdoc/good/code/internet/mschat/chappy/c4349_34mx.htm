<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>ROOM.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context4389"></a>ROOM.CPP</h2>
<pre><code>//**************************************************************************** <br>//  Module:     Chappy.EXE <br>//  File:       Room.cpp : implementation file <br>//               <br>// <br>//  Copyright (c) Microsoft Corporation 1996-1997 <br>// <br>// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF  <br>// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO  <br>// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A  <br>// PARTICULAR PURPOSE. <br>//**************************************************************************** <br> <br> <br> <br>#include "stdafx.h" <br>#include "Chappy.h" <br>#include "Room.h" <br>#include "Globals.h" <br>#include "kickDlg.h" <br> <br>#ifdef _DEBUG <br>#define new DEBUG_NEW <br>#undef THIS_FILE <br>static char THIS_FILE[] = __FILE__; <br>#endif <br> <br>CRoom::CRoom() <br>{ <br>} <br> <br>CRoom::~CRoom() <br>{ <br>if (m_IChannels.m_lpDispatch) <br>{ <br>m_IChannels.ReleaseDispatch(); <br>m_IChannels = NULL; <br>} <br>} <br> <br>//|bool CRoom::operator== ( const CRoom &amp;src ) const <br>//|{ <br>//|if ((m_IChannel== src.m_IChannel)) <br>//|{ <br>//|return TRUE; <br>//|} <br>//|else <br>//|{ <br>//|return FALSE; <br>//|} <br>//|} <br>//| <br>//|void CRoom::operator= ( const CRoom&amp; src ) <br>//|{ <br>//|m_IChannel= src.m_IChannel; <br>//|} <br> <br> <br>BOOL CRoom::Create(CWnd &amp;wndParent_p, LPDISPATCH lpIChannels_p)  <br>{ <br>//ASSERT (!m_ctrlHistoryWnd);  //if we already have a control something is wrong <br>ASSERT (&amp;wndParent_p); <br>ASSERT (lpIChannels_p); <br> <br>m_IChannels.AttachDispatch(lpIChannels_p, TRUE); <br> <br>//create the input rich edit control <br>RECT rec; <br>rec.left= 100; <br>rec.top= 100; <br>rec.right= 200; <br>rec.bottom= 200; <br> <br>int bRet = m_ctrlHistoryWnd.Create(WS_CHILD | WS_BORDER | WS_VSCROLL | <br>ES_MULTILINE | ES_AUTOVSCROLL| WS_EX_NOPARENTNOTIFY,  <br>rec,  <br>&amp;wndParent_p, <br>IDC_HISTORY_RICHEDIT);  <br>ASSERT (bRet); <br> <br>//create the list of participant control <br>bRet = m_ctrlPartListWnd.Create(WS_CHILD | WS_BORDER | WS_VSCROLL | WS_TABSTOP | WS_THICKFRAME | <br>TVS_HASLINES | TVS_HASBUTTONS | TVS_SHOWSELALWAYS | TVS_LINESATROOT,  <br>rec,  <br>wndParent_p.GetParent(), <br>IDC_PART_LIST_TREE); <br>ASSERT (bRet); <br> <br> <br>//we do not have a channel yet <br>m_IChannel= NULL; <br>m_iIndex= 0; <br> <br>//|//create the Channel item <br>//|//to instaciate the OCX you can get the CLSID directly usign MIDL or use CLSIDFromProgID <br>//|const CLSID CLSID_MsChatPr = {0x039397c0,0x46df,0x11d0,{0x99,0xcb,0x00,0xc0,0x4f,0xd6,0x44,0x97}}; <br>//|//const CLSID CLSID_Channels = {0x011eee42,0x46df,0x11d0,{0x99,0xcb,0x00,0xc0,0x4f,0xd6,0x44,0x97}}; <br>//|//const CLSID CLSID_Channel = {0x011eee44,0x46df,0x11d0,{0x99,0xcb,0x00,0xc0,0x4f,0xd6,0x44,0x97}}; <br>//| <br>//|// create the chat object that we'll drive through OLE automation <br>//|COleException e; <br>//|CLSID clsid = CLSID_MsChatPr;  <br>//| <br>//|if (CLSIDFromProgID(OLESTR("MsChatX.Microsoft Chat Protocol Control.2"), &amp;clsid) != NOERROR) <br>//|{ <br>//|AfxMessageBox("Failed to create"); <br>//|//EndDialog(IDABORT); <br>//|return FALSE; <br>//|} <br>//| <br>//|// try to get the active calculator before creating a new one <br>//|LPUNKNOWN lpUnk; <br>//|LPDISPATCH lpDispatch; <br>//|if (GetActiveObject(clsid, NULL, &amp;lpUnk) == NOERROR) <br>//|{ <br>//|HRESULT hr = lpUnk-&gt;QueryInterface(IID_IDispatch,  <br>//|(LPVOID*)&amp;lpDispatch); <br>//|lpUnk-&gt;Release(); <br>//|if (hr == NOERROR) <br>//|m_IChannel.AttachDispatch(lpDispatch, TRUE); <br>//|} <br>//| <br>//|// if not dispatch ptr attached yet, need to create one <br>//|if (m_IChannel.m_lpDispatch == NULL &amp;&amp;  <br>//|!m_IChannel.CreateDispatch(clsid, &amp;e)) <br>//|{ <br>//|AfxMessageBox("CreateDispatch() failed\n"); <br>//|return FALSE; <br>//|} <br>//| <br>//|COleVariant vChannel(_T("#TestAR")); <br>//|COleVariant vKey(_T("")); <br>//| <br>//|m_IChannel.JoinChannel(vChannel,vKey); <br> <br>return TRUE; <br>} <br> <br>void CRoom::OnFocus(BOOL bFocus_p) <br>{ <br>m_ctrlHistoryWnd.ShowWindow(bFocus_p ? SW_SHOW : SW_HIDE); <br>m_ctrlPartListWnd.ShowWindow(bFocus_p ? SW_SHOW : SW_HIDE); <br>} <br> <br>void CRoom::SendMessage(LPCTSTR SenderNickname_p, long iMsgType_p, CString &amp; szMsgTxt_p) <br>{ <br>TRACE1("Send Messge : '%s'\n", szMsgTxt_p); <br> <br>if (!m_IChannel) return; <br> <br>COleVariant vMsgTxt(szMsgTxt_p); <br>COleVariant vRecipients(""); <br>COleVariant vDataMessageTag; <br>vDataMessageTag.Clear(); <br> <br>vRecipients.Clear(); <br>if (msgtWhisper == iMsgType_p ) <br>{ <br>vRecipients = GetSelectedMember(); <br>if (vRecipients == COleVariant("")) <br>{ <br>AfxMessageBox(IDS_NO_MEMBER_SELECTED); <br>return; <br>} <br>} <br> <br>m_IChannel.SendMessage(iMsgType_p, vMsgTxt, vRecipients, vDataMessageTag); <br>m_ctrlHistoryWnd.UpdateMessageUI(SenderNickname_p, iMsgType_p, szMsgTxt_p); <br>} <br> <br>void CRoom::LeaveChannel() <br>{ <br>//exit if we do not have a channel object (not in a room) <br>if (!m_IChannel) return; <br> <br>//leave the channel <br>if (chsClosed != m_IChannel.GetChannelState()) <br>{ <br>m_IChannel.LeaveChannel(); <br>} <br>//m_ctrlPartListWnd.DeleteAllItems(); <br>} <br> <br>//call this function async <br>void CRoom::DestroyRoom() <br>{ <br>if (m_ctrlPartListWnd) <br>{ <br>m_ctrlPartListWnd.DeleteAllItems(); <br>} <br> <br>//release the IChannel object <br>m_IChannel.ReleaseDispatch(); <br>m_IChannel = NULL; <br> <br>//remove the channel from the collection <br>m_IChannels.Remove(COleVariant(m_szKey)); <br> <br>} <br> <br> <br>BOOL CRoom::EnterRoom(long iIndex_p, CString &amp;szRoomName_p, CString &amp;szRoomKey_p) <br>{ <br> <br>ASSERT (!m_IChannel); //if we already have a channel something is wrong <br>ASSERT (!szRoomName_p.IsEmpty()); <br> <br>m_iIndex = iIndex_p; <br>m_szKey.Format("%s%i",szRoomName_p,iIndex_p); <br> <br>//Add a channel to the collection  <br>//the ocx takes care of pushing in the new channel if you pass an index that <br>//already exists. If you pass in an invalid index, on the other hand, the OCX complains <br>COleVariant vIndex(1L); <br>COleVariant vKey(m_szKey); <br> <br>LPDISPATCH lpIChannel = NULL; <br>lpIChannel = m_IChannels.Add (vIndex, vKey); <br>m_IChannel.AttachDispatch(lpIChannel, TRUE); <br>ASSERT (m_IChannel); <br> <br>//enter the room <br>COleVariant vChannel (szRoomName_p) ; <br>COleVariant vChannelKey(szRoomKey_p); <br>m_IChannel.JoinChannel(vChannel,vChannelKey); <br> <br>return TRUE; <br>} <br> <br>CString CRoom::GetSelectedMember() <br>{ <br>HTREEITEM iSel = m_ctrlPartListWnd.GetSelItem(); <br>return ((iSel) ?  m_ctrlPartListWnd.GetItemText(iSel) : ""); <br>} <br> <br>void CRoom::KickMember(CString &amp; szReason_p) <br>{ <br>{ <br>CString szMember = GetSelectedMember(); <br>TRACE2("-- Kick: %s Reason: %s",szMember, szReason_p);  <br>m_IChannel.KickMember((LPCSTR)szMember, COleVariant(szReason_p)); <br>} <br>} <br> <br>void CRoom::BanMember(CChatItems &amp;IChatItem_p) <br>{  <br>ASSERT (IChatItem_p); <br>IChatItem_p.SetAssociatedType("Query"); <br>IChatItem_p.SetItem ("Nickname", COleVariant(GetSelectedMember())); <br>m_IChannel.BanMembers(IChatItem_p, TRUE); <br>} <br> <br>void CRoom::MakeHost(BOOL bFlag) <br>{ <br>m_IChannel.ChangeMemberProperty ("Modes", COleVariant((long)(bFlag ? mmHost : mmNotHost)),COleVariant(GetSelectedMember())); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
