<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CKYMUNGE.CPP</title>
<link disabled rel=stylesheet href=../../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context4213"></a>CKYMUNGE.CPP</h2>
<pre><code>// CkyMunge: ISAPI filter for ASP session state for cookieless browsers. <br>// An inglorious hack that munges URLs embedded in outgoing ASP pages, <br>// embedding the ASPSESSIONID cookie in them.  Also useful as an example of <br>// an ISAPI filter that does something non-trivial with rawdata. <br> <br> <br>#include "CkyPch.h" <br> <br>#include "debug.h" <br>#include "isapiflt.h" <br>#include "utils.h" <br>#include "notify.h" <br>#include "filter.h" <br>#include "globals.h" <br>#include "keyword.h" <br> <br> <br>#define MAJOR_VERSION 1 <br>#define MINOR_VERSION 1 <br> <br>// the munging mode.  This will be read from the registry upon initialization <br>intg_mungeMode = MungeMode_Off; <br> <br>// the session ID size is either 16 or 24 chars (depends on the server version) <br>long g_SessionIDSize=-1; <br> <br>// the "cookie extra" is the string appended after "ASPSESSIONID" and before <br>// "=".  It is actually the process ID (with some extra mangling) <br>static volatile long        g_fCookieExtraSet = 0; <br>static CRITICAL_SECTION     g_csCookieExtra; <br>CHAR                        g_szCookieExtra[ COOKIE_NAME_EXTRA_SIZE + 1 ]; <br> <br> <br>static LPCTSTR szRegKey = "Software\\Microsoft\\CkyMunge"; <br>static LPCTSTR szRegValue = "MungeMode"; <br> <br>void SetSessionIDSize( HTTP_FILTER_CONTEXT* ); <br>void SetCookieExtra( LPCSTR ); <br>bool IsValidCookieExtra( LPCSTR ); <br> <br>// <br>// Optional entry/exit point for all DLLs <br>// <br> <br>extern "C" <br>BOOL <br>WINAPI <br>DllMain( <br>    HINSTANCE /*hInstance*/, <br>    DWORD     dwReason, <br>    LPVOID    /*lpReserved*/) <br>{ <br>    if (dwReason == DLL_PROCESS_ATTACH) <br>    { <br>        DEBUG_INIT(); <br>        TRACE("%s starting up\n", EVENT_MODULE); <br> <br>// get the munge mode from the registry <br>HKEY hKey; <br>DWORD dwDisposition; <br>if ( ::RegCreateKeyEx( <br>HKEY_LOCAL_MACHINE, <br>szRegKey, <br>0, <br>REG_NONE, <br>0, <br>KEY_ALL_ACCESS, <br>NULL, <br>&amp;hKey, <br>&amp;dwDisposition ) != ERROR_SUCCESS ) <br>{ <br>TRACE( "Couldn't create/open key in registry\n" ); <br>return FALSE; <br>} <br> <br>DWORD dwType; <br>DWORD dwValue; <br>DWORD dwBufferSize = sizeof( dwValue ); <br> <br>if ( ::RegQueryValueEx( <br>hKey, <br>szRegValue, <br>NULL, <br>&amp;dwType, <br>reinterpret_cast&lt;BYTE*&gt;(&amp;dwValue), <br>&amp;dwBufferSize ) != ERROR_SUCCESS ) <br>{ <br>TRACE( "No munge mode set, defaulting to smart mode\n" ); <br>dwValue = MungeMode_Smart; <br> <br>::RegSetValueEx( <br>hKey, <br>szRegValue, <br>0, <br>REG_DWORD, <br>reinterpret_cast&lt;BYTE*&gt;(&amp;dwValue), <br>sizeof( DWORD ) ); <br>} <br> <br>g_mungeMode = static_cast&lt;int&gt;( dwValue ); <br>        TRACE("MungeMode = %d\n", g_mungeMode); <br> <br>        if (! InitUtils()  ||  ! InitKeywords()) <br>            return FALSE; <br> <br>        g_szCookieExtra[0]='\0'; <br>        ::InitializeCriticalSection( &amp;g_csCookieExtra ); <br> <br>    } <br>    else if (dwReason == DLL_PROCESS_DETACH) <br>    { <br>        ::DeleteCriticalSection( &amp;g_csCookieExtra ); <br> <br>        if (! TerminateUtils()  ||  ! TerminateKeywords()) <br>            return FALSE; <br>        TRACE("%s shutting down\n", EVENT_MODULE); <br>        DEBUG_TERM(); <br>    } <br> <br>    return TRUE;    // ok <br>} <br> <br> <br> <br>// <br>// Required initialization entrypoint for all ISAPI filters <br>// <br> <br>BOOL <br>WINAPI <br>GetFilterVersion( <br>    HTTP_FILTER_VERSION* pVer) <br>{ <br>    EventReport("", "", EVENTLOG_INFORMATION_TYPE, CMFI_LOADED);  <br> <br>    pVer-&gt;dwFilterVersion = HTTP_FILTER_REVISION; <br> <br>    //  Specify the types and order of notification <br>    pVer-&gt;dwFlags = ((SF_NOTIFY_SECURE_PORT  | SF_NOTIFY_NONSECURE_PORT) <br>                     | SF_NOTIFY_ORDER_MEDIUM <br>                     | SF_NOTIFY_PREPROC_HEADERS <br>                     | SF_NOTIFY_URL_MAP <br>                     | SF_NOTIFY_SEND_RAW_DATA <br>                     | SF_NOTIFY_END_OF_REQUEST <br>                     ); <br> <br>    // Set the filter description <br>    wsprintf(pVer-&gt;lpszFilterDesc, <br>             "Active Server Pages ISAPI filter for munging ASPSESSIONID " <br>             "cookies, v%d.%02d", <br>             MAJOR_VERSION, MINOR_VERSION); <br>    TRACE("%s\n", pVer-&gt;lpszFilterDesc); <br> <br>    return TRUE; <br>} <br> <br> <br> <br>// <br>// Required dispatch entrypoint for all ISAPI filters <br>// <br> <br>DWORD <br>WINAPI <br>HttpFilterProc( <br>    HTTP_FILTER_CONTEXT* pfc, <br>    DWORD                dwNotificationType, <br>    VOID*                pvData) <br>{ <br>    // first verify the session ID size <br>    if ( g_SessionIDSize == -1 ) <br>    { <br>        SetSessionIDSize( pfc ); <br>    } <br> <br> if ( g_mungeMode == MungeMode_Off ) <br>{ <br>// just get out as quick as possible <br>return SF_STATUS_REQ_NEXT_NOTIFICATION; <br>} <br> <br>CNotification* pNotify = CNotification::Get(pfc); <br>if ( pNotify != NULL ) <br>{ <br>if ( pNotify-&gt;MungingOff() ) <br>{ <br>// we must've figured out that the browser is <br>// accepting cookies. <br>return SF_STATUS_REQ_NEXT_NOTIFICATION; <br>} <br>} <br> <br>    switch (dwNotificationType) <br>    { <br>    case SF_NOTIFY_READ_RAW_DATA: <br>        return OnReadRawData(pfc,    (PHTTP_FILTER_RAW_DATA) pvData); <br> <br>    case SF_NOTIFY_PREPROC_HEADERS: <br>        return OnPreprocHeaders(pfc, (PHTTP_FILTER_PREPROC_HEADERS) pvData); <br> <br>    case SF_NOTIFY_URL_MAP: <br>        return OnUrlMap(pfc,         (PHTTP_FILTER_URL_MAP) pvData); <br> <br>    case SF_NOTIFY_AUTHENTICATION: <br>        return OnAuthentication(pfc, (PHTTP_FILTER_AUTHENT) pvData); <br> <br>    case SF_NOTIFY_ACCESS_DENIED: <br>        return OnAccessDenied(pfc,   (PHTTP_FILTER_ACCESS_DENIED) pvData); <br> <br>    case SF_NOTIFY_SEND_RAW_DATA: <br>        return OnSendRawData(pfc,    (PHTTP_FILTER_RAW_DATA) pvData); <br> <br>    case SF_NOTIFY_END_OF_REQUEST: <br>        return OnEndOfRequest(pfc); <br> <br>    case SF_NOTIFY_LOG: <br>        return OnLog(pfc,            (PHTTP_FILTER_LOG) pvData); <br> <br>    case SF_NOTIFY_END_OF_NET_SESSION: <br>        return OnEndOfNetSession(pfc); <br>         <br>    default: <br>        TRACE("Unknown notification: %x, context: %p, data: %p\n", <br>              dwNotificationType, pfc, pvData); <br>        return SF_STATUS_REQ_NEXT_NOTIFICATION; <br>    } <br>} <br> <br> <br> <br>// <br>// Read raw data from the client (browser) <br>// <br> <br>DWORD <br>OnReadRawData( <br>    PHTTP_FILTER_CONTEXT  pfc, <br>    PHTTP_FILTER_RAW_DATA pRawData) <br>{ <br>    TRACE("OnReadRawData(%p, %p)\n", pfc, pRawData); <br> <br>    return SF_STATUS_REQ_NEXT_NOTIFICATION; <br>} <br> <br> <br> <br>// <br>// Preprocess the headers of the client's request before the server handles <br>// the request <br>// <br> <br>DWORD <br>OnPreprocHeaders( <br>    PHTTP_FILTER_CONTEXT         pfc, <br>    PHTTP_FILTER_PREPROC_HEADERS pHeaders) <br>{ <br>    TRACE("OnPreprocHeaders(%p)\n", pfc, pHeaders); <br> <br>    CHAR  szUrl[1024*5]; <br>    DWORD cbUrl = sizeof szUrl; <br> <br>    // Get the URL for this request <br>    if (! pHeaders-&gt;GetHeader(pfc, "url", szUrl, &amp;cbUrl)) <br>    { <br>        TRACE("GetHeader(\"url\") failed\n"); <br>        EventReport("OnPreprocHeaders", "url", <br>                    EVENTLOG_ERROR_TYPE, CMFE_GETHEADER); <br>        return SF_STATUS_REQ_ERROR; <br>    } <br> <br>    CNotification* pNotify = NULL; <br>    CHAR szSessionID[ MAX_SESSION_ID_SIZE + 1 ]; <br>    *szSessionID = '\0'; <br> <br>    // Does the URL contain an embedded Session ID, such as <br>    // /foo/bar.asp-ASP=PVZQGHUMEAYAHMFV ? <br> <br>    if (DecodeURL(szUrl, szSessionID)) <br>    { <br>        pNotify = CNotification::SetSessionID(pfc, szSessionID); <br> <br>        // Set the URL to one without the Session ID <br>        if (!pHeaders-&gt;SetHeader(pfc, "url", szUrl)) <br>        { <br>            TRACE("Failed to set Url header!\n", szUrl); <br>            EventReport("OnPreprocHeaders", szUrl, <br>                        EVENTLOG_ERROR_TYPE, CMFE_SETHEADER); <br>            return SF_STATUS_REQ_ERROR; <br>        } <br>    } <br> <br> <br>    // Look for a "Cookie:" header <br> <br>    CHAR  szCookie[1024*4]; <br>    DWORD cbCookie = sizeof szCookie; <br>    BOOL  fCookie = pHeaders-&gt;GetHeader(pfc, "Cookie:", szCookie, &amp;cbCookie); <br> <br>    if (fCookie  &amp;&amp;  cbCookie &gt; 0) <br>    { <br>        TRACE("Cookie: %s\n", szCookie); <br>        // if the Cookie header includes ASPSESSIONID=&lt;whatever&gt;, use that <br>        pNotify = CNotification::SetSessionID(pfc, szCookie); <br> <br>// got a header with a cookie, so don't munge anymore <br>if ( pNotify ) <br>{ <br>TRACE( "Cookies accepted: stop munging\n" ); <br>pNotify-&gt;m_fTestCookies = false; <br>} <br>    } <br>    else if (pNotify != NULL  &amp;&amp;  *szSessionID != '\0') <br>    { <br>        // No cookie header, so we synthesize an ASPSESSIONID cookie header <br>        // from the Session ID embedded in the URL <br>        CHAR sz[ SZ_SESSION_ID_COOKIE_NAME_SIZE + MAX_SESSION_ID_SIZE <br>                + 1 + COOKIE_NAME_EXTRA_SIZE + 1]; <br>        wsprintf(sz, "%s%s=%s", SZ_SESSION_ID_COOKIE_NAME, <br>                 g_szCookieExtra, szSessionID); <br>        TRACE("About to AddHeader(\"%s\")\n", sz); <br> <br>        if (!pHeaders-&gt;AddHeader(pfc, "Cookie:", sz)) <br>        { <br>            TRACE("Failed to AddHeader(\"Cookie:\", %s)\n", sz); <br>            EventReport("OnPreprocHeaders", szUrl, <br>                        EVENTLOG_ERROR_TYPE, CMFE_ADDHEADER); <br>            return SF_STATUS_REQ_ERROR; <br>        } <br> <br>// if we were testing cookies, we now know that the browser isn't <br>// sending any to us, so start munging <br>if ( pNotify-&gt;m_fTestCookies ) <br>{ <br>TRACE( "Cookies not accepted: continue munging\n" ); <br>pNotify-&gt;m_fTestCookies = false; <br>pNotify-&gt;m_fEatCookies = true; <br>} <br>    } <br> <br>    // Kill the "Connection: Keep-alive" header, so that browser will <br>    // terminate session properly.  If it's present, the server <br>    // will send back a "Connection: Keep-Alive" header in response to <br>    // requests for .htm pages (though not for .asp pages).  The <br>    // browser will think that there's more data to come, when <br>    // there's not, and it will show an hourglass cursor and eventually <br>    // put up an error messagebox. <br> <br>    BOOL fKeepAlive = pHeaders-&gt;SetHeader(pfc, "Connection:", ""); <br> <br>    return SF_STATUS_REQ_NEXT_NOTIFICATION; <br>} <br> <br> <br> <br>// <br>// We have mapped the URL to the corresponding physical file <br>// <br> <br>DWORD <br>OnUrlMap( <br>    PHTTP_FILTER_CONTEXT pfc, <br>    PHTTP_FILTER_URL_MAP pMapInfo) <br>{ <br>    TRACE("OnUrlMap(%p, %p, %s)\n", pfc, pMapInfo, pMapInfo-&gt;pszURL); <br> <br>    // Can we safely ignore this URL based on its MIME type (e.g., image/gif)? <br>    if (IsIgnorableUrl(pMapInfo-&gt;pszURL)) <br>    { <br>        CNotification::Destroy(pfc); <br>        TRACE("Ignoring &lt;%s&gt;\n", pMapInfo-&gt;pszURL); <br>    } <br>    else <br>    { <br>        CNotification* pNotify = CNotification::Get(pfc); <br> <br>        if (pNotify == NULL) <br>            pNotify = CNotification::Create(pfc, NULL); <br> <br>        pNotify-&gt;m_nState = HN_SEEN_URL; <br>    } <br> <br>    return SF_STATUS_REQ_NEXT_NOTIFICATION; <br>} <br> <br> <br> <br>// <br>// Authenticating the user <br>// <br> <br>DWORD <br>OnAuthentication( <br>    PHTTP_FILTER_CONTEXT pfc, <br>    PHTTP_FILTER_AUTHENT pAuthent) <br>{ <br>    TRACE("OnAuthentication(%p, %p)\n", pfc, pAuthent); <br> <br>    return SF_STATUS_REQ_NEXT_NOTIFICATION; <br>} <br> <br> <br> <br>// <br>// Authentication failed <br>// <br> <br>DWORD <br>OnAccessDenied( <br>    PHTTP_FILTER_CONTEXT       pfc, <br>    PHTTP_FILTER_ACCESS_DENIED pAccess) <br>{ <br>    TRACE("OnAccessDenied(%p, %p)\n", pfc, pAccess); <br> <br>    return SF_STATUS_REQ_NEXT_NOTIFICATION; <br>} <br> <br> <br> <br>// <br>// Do the hard work of munging the data.  Note that we may be in one of <br>// three interesting states: HN_SEEN_URL (initially), HN_IN_HEADER (looking <br>// at the outgoing HTTP headers), and HN_IN_BODY (in the body of the <br>// response).  If the browser has cached this URL already (not the case <br>// with .ASP pages, but typically the case with ordinary HTML pages or <br>// images), no body is sent and we never move into the HN_IN_BODY state. <br>// <br>// The data will be sent in one or more packets, and we may need to buffer <br>// portions of those packets, as tokens may be split across two or more <br>// packets.  The code assumes that an individual header will not be split <br>// across packets. <br>// <br> <br>DWORD <br>OnSendRawData( <br>    PHTTP_FILTER_CONTEXT  pfc, <br>    PHTTP_FILTER_RAW_DATA pRawData) <br>{ <br>    TRACE("OnSendRawData(%p, %p)\n", pfc, pRawData); <br> <br>   CNotification* pNotify = CNotification::Get(pfc); <br> <br>    if (pNotify == NULL  ||  pNotify-&gt;m_nState == HN_UNDEFINED) <br>        return SF_STATUS_REQ_NEXT_NOTIFICATION; <br> <br>if ( pNotify-&gt;MungingOff() ) <br>{ <br>// either munging has been turned off, or we detected that <br>// munging isn't necessary <br>return SF_STATUS_REQ_NEXT_NOTIFICATION; <br>} <br> <br>    LPSTR   pszData = (LPSTR) pRawData-&gt;pvInData; <br>    int     iStart = 0; // offset of the beginning of the body data <br>     <br>    // first time in OnSendRawData? <br>    if (pNotify-&gt;m_nState == HN_SEEN_URL) <br>    { <br>        // Assume Content-Type header is in first packet <br>        LPCSTR pszContentType = FindHeaderValue("Content-Type:", "text/html", <br>                                                pRawData, 0); <br> <br>        if (pszContentType == NULL) <br>        { <br>            pNotify-&gt;m_nState = HN_UNDEFINED;   // not HTML; ignore <br>            return SF_STATUS_REQ_NEXT_NOTIFICATION; <br>        } <br>        else <br>        { <br>            pNotify-&gt;m_nState = HN_IN_HEADER; <br>            pNotify-&gt;m_ct = CT_TEXT_HTML; <br>        } <br>    } <br> <br>    if (pNotify-&gt;m_nState == HN_IN_HEADER) <br>    { <br>        static const char szSetCookie[] = "Set-Cookie:"; <br>        LPSTR pszCookie = FindString(szSetCookie, pRawData, 0); <br>         <br>        // multiple Set-Cookie headers may be present in the header <br>        while (pszCookie != NULL) <br>        { <br>            pNotify-&gt;m_nState = HN_IN_HEADER; <br>             <br>            // Header lines are supposed to be terminated by "\r\n" <br>            LPSTR pszEoln = strchr(pszCookie, '\r'); <br>             <br>            if (pszEoln != NULL) <br>            { <br>                *pszEoln = '\0'; <br>                TRACE("%s\n", pszCookie); <br>                 <br>                // ASP only sends the ASPSESSIONID cookie if a session ID <br>                // hasn't already been picked, which happens either when <br>                // Session_OnStart is executed (if it and global.asa are <br>                // present) or when the Session object is first modified <br>                // by user code. <br>                LPCSTR szCookieName; <br>                if ( ( szCookieName = <br>                       strstr(pszCookie, SZ_SESSION_ID_COOKIE_NAME) ) != NULL) <br>                { <br>                    // need to figure out what's tacked onto the cookie name. <br>                    if ( !g_fCookieExtraSet ) <br>                    { <br>                        SetCookieExtra( szCookieName ); <br>                    } <br>                     <br>                    // we know this cookie contains ASPSESSIONID, but is it <br>                    // ours? (the cookie extra parts must match) <br>                    if ( strstr( szCookieName, g_szCookieExtra ) != NULL ) <br>                    { <br>                        VERIFY(CNotification::SetSessionID(pfc, pszCookie) <br>                               == pNotify); <br>                        TRACE("Update: %s\n", pNotify-&gt;SessionID()); <br>                         <br>                        *pszEoln = '\r';    // restore <br>                         <br>                        // Eat outgoing "Set-Cookie: ASPSESSIONIDXXXXXXXX=..." <br>                        // header?  Benign for cookie-less browsers; will keep <br>                        // cookie-warning browsers quiet. <br>                        if (pNotify-&gt;m_fEatCookies) <br>                        { <br>                            TRACE("Deleting cookie\n"); <br>                            DeleteLine(szSetCookie, pRawData, pszCookie); <br>                        } <br>                    } <br>                } <br>                else <br>                { <br>                    *pszEoln = '\r';    // restore <br>                } <br>                 <br>                pszCookie = <br>                    FindString(szSetCookie, pRawData, <br>                            pszEoln - static_cast&lt;LPCSTR&gt;(pRawData-&gt;pvInData)); <br>            } <br>            else <br>            { <br>                pszCookie = NULL; // terminate loop <br>            } <br>        } <br> <br>        // If a Content-Length header is present, we need to destroy it <br>        // because there is no way we can guess a priori how much longer <br>        // the data will become.  If we don't destroy it, the browser will <br>        // believe the header and become very confused. <br>         <br>        static const char szContentLength[] = "Content-Length:"; <br>        LPSTR pszCL = FindString(szContentLength, pRawData, 0); <br> <br>        if (pszCL != NULL) <br>        { <br>            char szFmt[ARRAYSIZE(szContentLength) + 10]; <br>            sprintf(szFmt, "%s %%u", szContentLength); <br>            sscanf(pszCL, szFmt, &amp;pNotify-&gt;m_cchContentLength); <br>            TRACE("%s is %u\n", szContentLength, pNotify-&gt;m_cchContentLength); <br>            DeleteLine(szContentLength, pRawData, pszCL); <br>        } <br> <br>        // Is the end-of-headers marker present? <br>        LPCSTR pszEndHeaderBlock = FindString("\n\r\n", pRawData, 0); <br> <br>        if (pszEndHeaderBlock != NULL) <br>        { <br>            pNotify-&gt;m_nState = HN_IN_BODY; <br>            iStart = pszEndHeaderBlock + 3 - pszData; <br>        } <br>    } <br> <br>    // We're in the body.  Let's do some real work. <br> <br>    if (pNotify-&gt;m_nState == HN_IN_BODY) <br>    { <br>        LPSTR pszBuf = pszData; <br>        int iEnd; <br> <br>        // Have we got a partial line from the last packet?  If so, it <br>        // means that the last character in the buffer on that packet was <br>        // not a token boundary character, such as '\n' or '&gt;'.  Prepend <br>        // that data to the current batch. <br>         <br>        if (pNotify-&gt;m_pbPartialToken != NULL) <br>        { <br>            ASSERT(iStart == 0); <br>            ASSERT(pNotify-&gt;m_cbPartialToken &gt; 0); <br> <br>            pNotify-&gt;AppendToken(pfc, pszBuf, pRawData-&gt;cbInData); <br> <br>            pRawData-&gt;pvInData = pszBuf = (LPSTR) pNotify-&gt;m_pbPartialToken; <br>            pRawData-&gt;cbInData = pRawData-&gt;cbInBuffer <br>                = pNotify-&gt;m_cbPartialToken; <br>                 <br>            iEnd = g_trie.EndOfBuffer(pRawData, iStart); <br> <br>            if (iEnd &lt; 0) <br>            { <br>                // Don't let IIS send any data on this pass <br>                pRawData-&gt;pvInData = NULL; <br>                pRawData-&gt;cbInData = pRawData-&gt;cbInBuffer = 0; <br> <br>                return SF_STATUS_REQ_NEXT_NOTIFICATION; <br>            } <br>            else <br>            { <br>                // Have a complete token <br>                pNotify-&gt;m_pbPartialToken = NULL; <br>                pNotify-&gt;m_cbPartialToken = 0; <br>            } <br>        } <br> <br>        ASSERT(pNotify-&gt;m_pbPartialToken == NULL <br>               &amp;&amp;  pNotify-&gt;m_cbPartialToken == 0); <br> <br>        // Is the last token in the block incomplete? <br>        iEnd = g_trie.EndOfBuffer(pRawData, iStart); <br> <br>        if (iEnd != pRawData-&gt;cbInData) <br>        { <br>            LPSTR pszBoln = (iEnd &lt; 0)  ?  pszBuf + iStart  :  pszBuf + iEnd ; <br> <br>            TRACE("Partial Token: "); <br>            pNotify-&gt;AppendToken(pfc, pszBoln, <br>                                 (pszBuf + pRawData-&gt;cbInData) - pszBoln); <br>            pRawData-&gt;cbInData -= pNotify-&gt;m_cbPartialToken; <br>        } <br> <br>        pNotify-&gt;m_cchContentLength -= pRawData-&gt;cbInData; <br> <br>        // Filter whatever is left <br>        const int nExtra = Filter(pfc, pRawData, pszBuf, <br>                                  pRawData-&gt;cbInData, iStart, <br>                                  pNotify-&gt;m_szSessionID); <br>    } <br> <br>    return SF_STATUS_REQ_NEXT_NOTIFICATION; <br>} <br> <br> <br> <br>// <br>// The transaction is over.  Pump out any remaining data before the <br>// connection closes. <br>// <br> <br>DWORD <br>OnEndOfRequest( <br>    PHTTP_FILTER_CONTEXT pfc) <br>{ <br>    TRACE("OnEndOfRequest(%p)\n", pfc); <br> <br>    CNotification* pNotify = CNotification::Get(pfc); <br> <br>    if (pNotify != NULL  &amp;&amp;  pNotify-&gt;m_pbPartialToken != NULL) <br>    { <br>        // append a '\n', which is guaranteed to be a token boundary char <br>        pNotify-&gt;m_pbPartialToken[pNotify-&gt;m_cbPartialToken] = '\n'; <br>#ifdef _DEBUG <br>        pNotify-&gt;m_pbPartialToken[pNotify-&gt;m_cbPartialToken + 1] = '\0'; <br>#endif <br>        LPBYTE pbTemp = pNotify-&gt;m_pbPartialToken; <br>        DWORD  cb = pNotify-&gt;m_cbPartialToken + 1; <br> <br>        // Note: WriteClient ends up calling OnSendRawData.  Destroy the <br>        // partial token before it's called. <br>        pNotify-&gt;m_pbPartialToken = NULL; <br>        pNotify-&gt;m_cbPartialToken = 0; <br> <br>        if (!pfc-&gt;WriteClient(pfc, pbTemp, &amp;cb, 0)) <br>            TRACE("WriteClient failed, err %x.\n", GetLastError()); <br>    } <br> <br>    return SF_STATUS_REQ_NEXT_NOTIFICATION; <br>} <br> <br> <br> <br>// <br>// Log the details of the transaction <br>// <br> <br>DWORD <br>OnLog( <br>    PHTTP_FILTER_CONTEXT pfc, <br>    PHTTP_FILTER_LOG     pLog) <br>{ <br>    TRACE("OnLog(%p, %p)\n", pfc, pLog); <br> <br>    return SF_STATUS_REQ_NEXT_NOTIFICATION; <br>} <br> <br> <br> <br>// <br>// The HTTP session (transaction) is over and the connection has been closed. <br>// <br> <br>DWORD <br>OnEndOfNetSession( <br>    PHTTP_FILTER_CONTEXT pfc) <br>{ <br>    TRACE("OnEndOfNetSession(%p)\n", pfc); <br> <br>    CNotification::Destroy(pfc); <br> <br>    return SF_STATUS_REQ_NEXT_NOTIFICATION; <br>} <br> <br> <br> <br>void <br>SetSessionIDSize( <br>    PHTTP_FILTER_CONTEXT pfc ) <br>{ <br>    static const char szVersion4B2[] = "Microsoft-IIS/4.0 Beta 2"; <br>    static const char szVersion4[]   = "Microsoft-IIS/4.0"; <br>    const long version3Size = 16; <br>    const long version4Size = MAX_SESSION_ID_SIZE; <br>    const long version4B2Size = 16; <br> <br>    long size = version3Size; <br> <br>    DWORD dwBufferSize = 0; <br>    pfc-&gt;GetServerVariable( pfc, "SERVER_SOFTWARE", NULL, &amp;dwBufferSize ); <br>    if ( ::GetLastError() == ERROR_INSUFFICIENT_BUFFER ) <br>    { <br>        LPSTR str = (LPSTR)_alloca( ++dwBufferSize ); <br>        if (pfc-&gt;GetServerVariable(pfc, "SERVER_SOFTWARE", str, &amp;dwBufferSize)) <br>        { <br>            TRACE( "Server Software: %s\n", str ); <br>            if ( strcmp( szVersion4B2, str ) == 0 ) <br>            { <br>                TRACE( "Using version 4 beta 2 session ID size (%d bytes)\n", <br>                       version4B2Size ); <br>                size = version4B2Size; <br>            } <br>            else if ( strncmp( szVersion4, str, strlen( szVersion4 ) ) == 0 ) <br>            { <br>                TRACE( "Using version 4 session ID size (%d bytes)\n", <br>                       version4Size ); <br>                size = version4Size; <br>            } <br>            else <br>            { <br>                TRACE( "Using version 3 session ID size (%d bytes)\n", <br>                       version3Size ); <br>            } <br>        } <br>        else <br>        { <br>            TRACE( "Failed to get server variable, error: %d\n", <br>                   ::GetLastError() ); <br>        } <br>    } <br>    else <br>    { <br>        TRACE( "Failed to get server variable(SERVER_SOFTWARE), error: %d\n", <br>               ::GetLastError() ); <br>    } <br>    ::InterlockedExchange( &amp;g_SessionIDSize, size ); <br>} <br> <br> <br> <br>void <br>SetCookieExtra( <br>    LPCSTR  szCookieName ) <br>{ <br>    ::EnterCriticalSection( &amp;g_csCookieExtra ); <br>    // need to check again in case the cookie extra was set <br>    // while we were waiting on the critical section <br>    if ( !g_fCookieExtraSet ) <br>    { <br>        szCookieName += SZ_SESSION_ID_COOKIE_NAME_SIZE; <br>        if ( *szCookieName != '=' ) <br>        { <br>            CHAR szExtra[ COOKIE_NAME_EXTRA_SIZE + 1 ]; <br>            strncpy( szExtra, szCookieName, COOKIE_NAME_EXTRA_SIZE ); <br>            szExtra[ COOKIE_NAME_EXTRA_SIZE ] = 0; <br> <br>            if ( IsValidCookieExtra( szExtra ) ) <br>            { <br>                // copy the cookie name extra <br>                strcpy( g_szCookieExtra, szExtra ); <br>                TRACE("SetCookieExtra(%s)\n", g_szCookieExtra); <br>                ::InterlockedExchange( (long*)&amp;g_fCookieExtraSet, 1 ); <br>            } <br>            else <br>            { <br>                TRACE( "Cookie extra validation failed\n" ); <br>            } <br>        } <br>    } <br>    ::LeaveCriticalSection( &amp;g_csCookieExtra ); <br>} <br> <br> <br> <br>// Check to see if this `extra part' is a valid value for this server. <br>// The extra part is derived from the process ID and then randomized <br>// slightly.  So we can tell if the extra is reasonable based on the <br>// process ID. <br>bool <br>IsValidCookieExtra( <br>    LPCSTR  szExtra ) <br>{ <br>    bool rc = true; <br>     <br>    CHAR szProcessID[ COOKIE_NAME_EXTRA_SIZE ]; <br> <br>    // Process ID <br>    wsprintf(szProcessID, "%08X", GetCurrentProcessId()); <br> <br>    // check based on how we know the process ID is munged to the cookie extra <br>    static const char *pszDigitsToLetters[2] = {"GHIJKLMNOP","QRSTUVWXYZ"}; <br> <br>    for (int i = 0; i &lt; COOKIE_NAME_EXTRA_SIZE; i++) <br>    { <br>        char cp = szProcessID[i]; <br>        char ce = szExtra[i]; <br>        if ( ( cp &gt;= '0' ) &amp;&amp; ( cp &lt;= '9' ) ) <br>        { <br>            int ndx = cp - '0'; <br>            if ( ( pszDigitsToLetters[0][ndx] == ce ) <br>                 || ( pszDigitsToLetters[1][ndx] == ce ) ) <br>            { <br>                // okay, keep checking <br>            } <br>            else <br>            { <br>                // no good <br>                rc = false; <br>                i = COOKIE_NAME_EXTRA_SIZE; <br>            } <br>        } <br>        else <br>        { <br>            if ( cp == ce ) <br>            { <br>                // okay, keep checking <br>            } <br>            else <br>            { <br>                // no good <br>                rc = false; <br>                i = COOKIE_NAME_EXTRA_SIZE; <br>            } <br>        } <br>    } <br>#ifdef _DEBUG <br>    if (!rc) <br>        TRACE("`%s' is not a valid extra\n", szExtra); <br>#endif <br>    return rc; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
