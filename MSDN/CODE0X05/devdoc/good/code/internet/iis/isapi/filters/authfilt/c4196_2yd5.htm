<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CACHE.C</title>
<link disabled rel=stylesheet href=../../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context4199"></a>CACHE.C</h2>
<pre><code>/*++ <br> <br>Copyright (c) 1996  Microsoft Corporation <br> <br>This program is released into the public domain for any purpose. <br> <br> <br>Module Name: <br> <br>    cache.c <br> <br>Abstract: <br> <br>    This module implements a simple user cache.  The cached users are kept <br>    in an LRU sorted list.  If there will be a large number of simultaneous <br>    users, then a sorted array would be more appropriate. <br> <br>--*/ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;httpfilt.h&gt; <br>#include "authfilt.h" <br> <br>// <br>// Constants <br>// <br> <br>// <br>//  The maximum number of users we will cache.  If there will be a large number <br>//  of simultaneous users, bump this value <br>// <br> <br>#define MAX_CACHED_USERS        100 <br> <br>// <br>//  The position after which we'll move a cache entry to the front of the list <br>// <br> <br>#define LIST_REORDER_THRESHOLD  6 <br> <br>// <br>//  Cached user structure <br>// <br> <br>typedef struct _USER_INFO <br>{ <br>    LIST_ENTRY  ListEntry;  // Double linked list entry <br> <br>    CHAR  achUserName[SF_MAX_USERNAME];   // External username and password <br>    CHAR  achPassword[SF_MAX_PASSWORD]; <br> <br>    CHAR  achNTUserName[SF_MAX_USERNAME]; // NT account and password to map user to <br>    CHAR  achNTUserPassword[SF_MAX_PASSWORD]; <br> <br>} USER_INFO, *PUSER_INFO; <br> <br> <br>// <br>//  Globals <br>// <br> <br>// <br>//  Circular double linked list of cached users <br>// <br> <br>LIST_ENTRY CacheListHead; <br> <br>// <br>//  Critical section protects cache list <br>// <br> <br>CRITICAL_SECTION csCacheLock; <br> <br>// <br>//  Indicates whether we are initialized <br>// <br> <br>BOOL fCacheInitialized = FALSE; <br> <br>// <br>//  Number of items in the cache <br>// <br> <br>DWORD cCacheItems = 0; <br> <br> <br>BOOL <br>InitializeCache( <br>    VOID <br>    ) <br>/*++ <br> <br>Routine Description: <br> <br>    Initializes the cache module <br> <br>Return Value: <br> <br>    TRUE if initialized successfully, FALSE on error <br> <br>--*/ <br>{ <br>    if ( fCacheInitialized ) <br>        return TRUE; <br> <br>    InitializeCriticalSection( &amp;csCacheLock ); <br>    CacheListHead.Blink = CacheListHead.Flink = &amp;CacheListHead; <br> <br>    fCacheInitialized = TRUE; <br> <br>    return TRUE; <br>} <br> <br> <br>BOOL <br>LookupUserInCache( <br>    CHAR * pszUserName, <br>    BOOL * pfFound, <br>    CHAR * pszPassword, <br>    CHAR * pszNTUser, <br>    CHAR * pszNTUserPassword <br>    ) <br>/*++ <br> <br>Routine Description: <br> <br>    Checks to see if a user is in the cache and returns the user properties <br>    if found <br> <br>Arguments: <br> <br>    pszUserName - Case insensitive username to find <br>    pfFound     - Set to TRUE if the specified user was found <br>    pszPassword - Receives password for specified user if found <br>    pszNTUser   - Receives the NT Username to map this user to <br>    pszNTUserPassword - Receives the NT Password for pszNTUser <br> <br>    Note: pszPassword and pszNTUserPassword must be at least SF_MAX_PASSWORD <br>    characters.  pszNTUser must be at least SF_MAX_USERNAME characters. <br> <br>Return Value: <br> <br>    TRUE if no errors occurred. <br> <br>--*/ <br>{ <br>    LIST_ENTRY * pEntry; <br>    USER_INFO *  pUser; <br>    DWORD        cPosition = 0; <br> <br>    // <br>    //  Search the cache for the specified user <br>    // <br> <br>    EnterCriticalSection( &amp;csCacheLock ); <br> <br>    for ( pEntry  = CacheListHead.Flink; <br>          pEntry != &amp;CacheListHead; <br>          pEntry = pEntry-&gt;Flink ) <br>    { <br>        pUser = CONTAINING_RECORD( pEntry, USER_INFO, ListEntry ); <br> <br>        if ( !stricmp( pszUserName, pUser-&gt;achUserName )) <br>        { <br>            goto Found; <br>        } <br> <br>        cPosition++; <br>    } <br> <br>    LeaveCriticalSection( &amp;csCacheLock ); <br> <br>    // <br>    //  Not Found <br>    // <br> <br>    *pfFound = FALSE; <br>    return TRUE; <br> <br>Found: <br> <br>    // <br>    //  Copy out the user properties <br>    // <br> <br>    strcpy( pszPassword,       pUser-&gt;achPassword ); <br>    strcpy( pszNTUser,         pUser-&gt;achNTUserName ); <br>    strcpy( pszNTUserPassword, pUser-&gt;achNTUserPassword ); <br> <br>    // <br>    //  Move this user entry to the front of the list as we're probably going <br>    //  to get subsequent requests for this user.  Note we only move it <br>    //  if it's not already near the front <br>    // <br> <br>    if ( cPosition &gt; LIST_REORDER_THRESHOLD ) <br>    { <br>        // <br>        //  Remove from the old position... <br>        // <br> <br>        pEntry-&gt;Blink-&gt;Flink = pEntry-&gt;Flink; <br>        pEntry-&gt;Flink-&gt;Blink = pEntry-&gt;Blink; <br> <br>        // <br>        // ...and insert it at the beginning of the list <br>        // <br> <br>        pEntry-&gt;Blink = &amp;CacheListHead; <br>        pEntry-&gt;Flink = CacheListHead.Flink; <br> <br>        CacheListHead.Flink-&gt;Blink = pEntry; <br>        CacheListHead.Flink        = pEntry; <br>    } <br> <br>    LeaveCriticalSection( &amp;csCacheLock ); <br> <br>    *pfFound = TRUE; <br> <br>    return TRUE; <br>} <br> <br>BOOL <br>AddUserToCache( <br>    CHAR * pszUserName, <br>    CHAR * pszPassword, <br>    CHAR * pszNTUser, <br>    CHAR * pszNTUserPassword <br>    ) <br>/*++ <br> <br>Routine Description: <br> <br>    Adds the specified user to the cache <br> <br>Arguments: <br> <br>    pszUserName - Username to add <br>    pszPassword - Contains the external password for this user <br>    pszNTUser   - Contains the NT user name to use for this user <br>    pszNTUserPassword - Contains the password for NTUser <br> <br>Return Value: <br> <br>    TRUE if no errors occurred. <br> <br>--*/ <br>{ <br>    LIST_ENTRY * pEntry; <br>    USER_INFO *  pUser; <br> <br>    // <br>    //  Check our parameters before adding them to the cache <br>    // <br> <br>    if ( strlen( pszUserName ) &gt; SF_MAX_USERNAME || <br>         strlen( pszPassword ) &gt; SF_MAX_PASSWORD || <br>         strlen( pszNTUser   ) &gt; SF_MAX_USERNAME || <br>         strlen( pszNTUserPassword ) &gt; SF_MAX_PASSWORD ) <br>    { <br>        SetLastError( ERROR_INVALID_PARAMETER ); <br>        return FALSE; <br>    } <br> <br>    // <br>    //  Search the cache for the specified user to make sure there are no <br>    //  duplicates <br>    // <br> <br>    EnterCriticalSection( &amp;csCacheLock ); <br> <br>    for ( pEntry  = CacheListHead.Flink; <br>          pEntry != &amp;CacheListHead; <br>          pEntry = pEntry-&gt;Flink ) <br>    { <br>        pUser = CONTAINING_RECORD( pEntry, USER_INFO, ListEntry ); <br> <br>        if ( !stricmp( pszUserName, pUser-&gt;achUserName )) <br>        { <br>            goto Found; <br>        } <br>    } <br> <br>    // <br>    //  Allocate a new cache item and put it at the head of the list <br>    // <br> <br>    pUser = (USER_INFO *) LocalAlloc( LPTR, sizeof( USER_INFO )); <br> <br>    if ( !pUser ) <br>    { <br>        LeaveCriticalSection( &amp;csCacheLock ); <br> <br>        SetLastError( ERROR_NOT_ENOUGH_MEMORY ); <br>        return FALSE; <br>    } <br> <br>    pUser-&gt;ListEntry.Flink = CacheListHead.Flink; <br>    pUser-&gt;ListEntry.Blink = &amp;CacheListHead; <br> <br>    CacheListHead.Flink-&gt;Blink = &amp;pUser-&gt;ListEntry; <br>    CacheListHead.Flink = &amp;pUser-&gt;ListEntry; <br> <br>Found: <br> <br>    // <br>    //  Set the various fields <br>    // <br> <br>    strcpy( pUser-&gt;achUserName,       pszUserName ); <br>    strcpy( pUser-&gt;achPassword,       pszPassword ); <br>    strcpy( pUser-&gt;achNTUserName,     pszNTUser ); <br>    strcpy( pUser-&gt;achNTUserPassword, pszNTUserPassword ); <br> <br>    cCacheItems++; <br> <br>    // <br>    //  If there are too many cached users, remove the least recently <br>    //  used one now <br>    // <br> <br>    if ( cCacheItems &gt; MAX_CACHED_USERS ) <br>    { <br>        pEntry = CacheListHead.Blink; <br> <br>        pEntry-&gt;Blink-&gt;Flink = &amp;CacheListHead; <br>        CacheListHead.Blink  = pEntry-&gt;Blink; <br> <br>        LocalFree( CONTAINING_RECORD( pEntry, USER_INFO, ListEntry )); <br> <br>        cCacheItems--; <br>    } <br> <br>    LeaveCriticalSection( &amp;csCacheLock ); <br> <br>    return TRUE; <br>} <br> <br>VOID <br>TerminateCache( <br>    VOID <br>    ) <br>/*++ <br> <br>Routine Description: <br> <br>    Terminates the cache module and frees any allocated memory <br> <br>--*/ <br>{ <br>    LIST_ENTRY * pEntry; <br>    LIST_ENTRY * pEntryNext; <br>    USER_INFO *  pUser; <br> <br>    if ( !fCacheInitialized ) <br>        return; <br> <br>    EnterCriticalSection( &amp;csCacheLock ); <br> <br>    // <br>    //  Free all of the cache entries <br>    // <br> <br>    for ( pEntry  = CacheListHead.Flink; <br>          pEntry != &amp;CacheListHead; <br>          pEntry  = pEntryNext ) <br> <br>    { <br>        pUser = CONTAINING_RECORD( pEntry, USER_INFO, ListEntry ); <br> <br>        pEntryNext = pEntry-&gt;Flink; <br> <br>        // <br>        //  Remove this entry from the list and free it <br>        // <br> <br>        pEntry-&gt;Blink-&gt;Flink = pEntry-&gt;Flink; <br>        pEntry-&gt;Flink-&gt;Blink = pEntry-&gt;Blink; <br> <br>        LocalFree( pUser ); <br>    } <br> <br>    cCacheItems = 0; <br>    LeaveCriticalSection( &amp;csCacheLock ); <br> <br>    DeleteCriticalSection( &amp;csCacheLock ); <br> <br>    fCacheInitialized = FALSE; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
