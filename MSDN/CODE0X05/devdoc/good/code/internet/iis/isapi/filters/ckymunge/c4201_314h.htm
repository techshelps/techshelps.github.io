<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>NOTIFY.CPP</title>
<link disabled rel=stylesheet href=../../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context4211"></a>NOTIFY.CPP</h2>
<pre><code>#include "CkyPch.h" <br>#include "debug.h" <br>#include "utils.h" <br>#include "notify.h" <br> <br> <br>// <br>// ctor <br>// <br> <br>CNotification::CNotification( <br>    LPCSTR pszCookie) <br>    : m_nState(HN_UNDEFINED), <br>      m_ct(CT_UNDEFINED), <br>      m_pszUrl(NULL), <br>      m_pbPartialToken(NULL), <br>      m_cbPartialToken(0), <br>      m_pbTokenBuffer(NULL), <br>      m_cbTokenBuffer(0), <br>      m_cchContentLength(UINT_MAX), // not specified for .ASPs <br>  m_fTestCookies(false) <br>{ <br>// set the eat cookies and test cookies based on the munge mode. <br>// Here's how the flags will affect output of this session <br> <br>// if EatCookies is true, cookies will be stripped and URLs will <br>// be munged with the cookie <br>// if TestCookies is true URLs will be munged <br>switch ( g_mungeMode ) <br>{ <br>case MungeMode_Off: <br>{ <br>m_fEatCookies = false; <br>} break; <br> <br>case MungeMode_On: <br>{ <br>m_fEatCookies = true; <br>} break; <br> <br>// always default to smart <br>default: <br>{ <br>m_fEatCookies = false; <br>m_fTestCookies = true; <br>} break; <br>} <br> <br>    *m_szSessionID = '\0'; <br> <br>    if (pszCookie != NULL) <br>    { <br>        if (!Cookie2SessionID(pszCookie, m_szSessionID)) <br>        { <br>            TRACE("CNotification(%s): ", pszCookie); <br>            CopySessionID(pszCookie, m_szSessionID); <br>        } <br>    } <br> <br>    TRACE("CNotification(%s)\n", (*m_szSessionID ? m_szSessionID : "&lt;none&gt;")); <br>} <br> <br> <br> <br>// <br>// dtor <br>// <br> <br>CNotification::~CNotification() <br>{ <br>    TRACE("~CNotification(%s)\n", m_szSessionID); <br>} <br> <br> <br> <br>// <br>// Create a CNotification for a Filter Context <br>// <br> <br>CNotification* <br>CNotification::Create( <br>    PHTTP_FILTER_CONTEXT pfc, <br>    LPCSTR               pszCookie) <br>{ <br>    ASSERT(pfc-&gt;pFilterContext == NULL); <br>     <br>    TRACE("Notify: "); <br> <br>    // placement new, using ISAPI's fast allocator <br>    LPBYTE pbNotify = <br>        static_cast&lt;LPBYTE&gt;(AllocMem(pfc, sizeof(CNotification))); <br>    CNotification* pNotify = new (pbNotify) CNotification(pszCookie); <br> <br>    pfc-&gt;pFilterContext = static_cast&lt;PVOID&gt;(pNotify); <br> <br>    return pNotify; <br>} <br> <br> <br> <br>// <br>// Cleanup <br>// <br> <br>void <br>CNotification::Destroy( <br>    PHTTP_FILTER_CONTEXT pfc) <br>{ <br>    CNotification* pNotify = Get(pfc); <br> <br>    if (pNotify != NULL) <br>        pNotify-&gt;~CNotification(); // placement destruction <br> <br>    pfc-&gt;pFilterContext = NULL; <br>} <br> <br> <br> <br>// <br>// Set the filter context's session ID, creating a CNotification if necessary <br>// <br> <br>CNotification* <br>CNotification::SetSessionID( <br>    PHTTP_FILTER_CONTEXT pfc, <br>    LPCSTR               pszCookie) <br>{ <br>    CNotification* pNotify = Get(pfc); <br> <br>    if (pNotify != NULL) <br>    { <br>        if (!Cookie2SessionID(pszCookie, pNotify-&gt;m_szSessionID)) <br>        { <br>            TRACE("SetSessionID(%s): ", pszCookie); <br>            CopySessionID(pszCookie, pNotify-&gt;m_szSessionID); <br>        } <br>    } <br>    else <br>        pNotify = Create(pfc, pszCookie); <br> <br>    return pNotify; <br>} <br> <br> <br> <br>// <br>// Sometimes the data in OnSendRawData ends in a partial token.  We need <br>// to buffer that partial token for the next call to OnSendRawData.  In <br>// some cases, it may take several successive calls to OnSendRawData to <br>// accumulate a complete token.  This routine builds the partial token, <br>// taking care of memory (re)allocation.  There's always SPARE_BYTES bytes <br>// unused at the end that callers (esp. OnEndOfRequest) can write into. <br>// <br> <br>void <br>CNotification::AppendToken( <br>    PHTTP_FILTER_CONTEXT pfc, <br>    LPCSTR               pszNewData, <br>    int                  cchNewData) <br>{ <br>    ASSERT(pszNewData != NULL  &amp;&amp;  cchNewData &gt; 0); <br> <br>    // if there's room, append new data to the currently allocated buffer <br>    if (m_cbPartialToken + cchNewData &lt;= m_cbTokenBuffer - SPARE_BYTES) <br>    { <br>        m_pbPartialToken = m_pbTokenBuffer; <br>        memcpy(m_pbPartialToken + m_cbPartialToken, pszNewData, cchNewData); <br>        m_cbPartialToken += cchNewData; <br>#ifdef _DEBUG <br>        m_pbPartialToken[m_cbPartialToken] = '\0'; <br>#endif <br>        return; <br>    } <br>     <br>    // We want to allocate some extra space so that we have room to <br>    // grow for a while before needing to allocate more space.  If we <br>    // allocated only exactly enough, we'd see O(n^2) memory usage in <br>    // degenerate cases because AllocMem doesn't return memory to its <br>    // pool until the transaction is over. <br>    DWORD cb2 = max(1024, 2 * (cchNewData + m_cbTokenBuffer) + SPARE_BYTES); <br> <br>    if (cb2 &gt; 10000) <br>        cb2 = 3 * (cchNewData + m_cbTokenBuffer) / 2 + SPARE_BYTES; <br> <br>    m_cbTokenBuffer = cb2; <br>    LPBYTE pb  = (LPBYTE) AllocMem(pfc, m_cbTokenBuffer); <br>    LPBYTE pb2 = pb; <br> <br>    // Already have a partial token buffer?  Copy contents, if so. <br>    if (m_cbPartialToken &gt; 0) <br>    { <br>        ASSERT(m_pbPartialToken != NULL <br>               &amp;&amp;  m_pbPartialToken == m_pbTokenBuffer); <br>        memcpy(pb, m_pbPartialToken, m_cbPartialToken); <br>        pb2 += m_cbPartialToken; <br>    } <br>    else <br>        ASSERT(m_pbPartialToken == NULL); <br> <br>    memcpy(pb2, pszNewData, cchNewData); <br>    m_pbPartialToken = m_pbTokenBuffer = pb; <br>    m_cbPartialToken += cchNewData; <br> <br>#ifdef _DEBUG <br>    m_pbPartialToken[m_cbPartialToken] = '\0'; <br>#endif <br> <br>    ASSERT(m_cbPartialToken &lt;= m_cbTokenBuffer - SPARE_BYTES); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
