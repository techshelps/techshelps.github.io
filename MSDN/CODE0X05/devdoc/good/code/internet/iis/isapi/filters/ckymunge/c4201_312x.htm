<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>KEYWORD.CPP</title>
<link disabled rel=stylesheet href=../../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context4209"></a>KEYWORD.CPP</h2>
<pre><code>#include "CkyPch.h" <br> <br>#include "keyword.h" <br>#include "filter.h" <br>#include "utils.h" <br> <br>#undef EXTERN <br>#define EXTERN <br>#include "globals.h" <br> <br> <br>// Build table of keywords <br> <br>typedef struct { <br>    LPCTSTR          ptszKwd; <br>    CToken::BOUNDARY bndPrefix; <br>    CToken::BOUNDARY bndSuffix; <br>} SKeywordData; <br> <br> <br>#define KEYWORD(KWD, tszKwd, bndStart, bndEnd, DoFilterDecl)        \ <br>                                                      \ <br>    class CKwd##KWD : public CToken                   \ <br>    {                                                 \ <br>    public:                                           \ <br>        CKwd##KWD(                                    \ <br>            LPCTSTR ptsz,                             \ <br>            BOUNDARY bndPrefix,                       \ <br>            BOUNDARY bndSuffix)                       \ <br>            : CToken(ptsz, bndPrefix, bndSuffix)      \ <br>        {}                                            \ <br>                                                      \ <br>        virtual UINT                                  \ <br>        CountBytes(                                   \ <br>            CStateStack&amp; rss,                         \ <br>            LPCTSTR      ptszData,                    \ <br>            UINT         cchData) const;              \ <br>                                                      \ <br>        DoFilterDecl                                  \ <br>    };                                                \ <br>                                                      \ <br>    static const SKeywordData kd##KWD =               \ <br>        {tszKwd, CToken::bndStart, CToken::bndEnd}; <br> <br> <br>#define DO_FILTER_DECL                                \ <br>        virtual UINT                                  \ <br>        DoFilter(                                     \ <br>            CStateStack&amp; rss,                         \ <br>            LPCTSTR&amp;     rptszData,                   \ <br>            UINT         cchData,                     \ <br>            LPTSTR&amp;      rptszOutBuf) const;          \ <br> <br>#define NO_DO_FILTER_DECL /*none*/ <br> <br> <br>KEYWORD(StartTag, _T("&lt;"),          IRRELEVANT, IRRELEVANT, NO_DO_FILTER_DECL); <br>KEYWORD(Anchor,   _T("&lt;a"),         IRRELEVANT, WHITESPACE, NO_DO_FILTER_DECL); <br>KEYWORD(Area,     _T("&lt;area"),      IRRELEVANT, WHITESPACE, NO_DO_FILTER_DECL); <br>KEYWORD(EndTag,   _T("&gt;"),          IRRELEVANT, IRRELEVANT, NO_DO_FILTER_DECL); <br>KEYWORD(HRef,     _T("href="),      WHITESPACE, IRRELEVANT, DO_FILTER_DECL); <br>KEYWORD(BegCmnt,  _T("&lt;--!"),       IRRELEVANT, WHITESPACE, NO_DO_FILTER_DECL); <br>KEYWORD(EndCmnt,  _T("--&gt;"),        WHITESPACE, IRRELEVANT, NO_DO_FILTER_DECL); <br>KEYWORD(BegCmnt2, _T("&lt;comment&gt;"),  IRRELEVANT, WHITESPACE, NO_DO_FILTER_DECL); <br>KEYWORD(EndCmnt2, _T("&lt;/comment&gt;"), WHITESPACE, IRRELEVANT, NO_DO_FILTER_DECL); <br> <br> <br> <br>#define KEYWORD_INIT(KWD)                             \ <br>    g_trie.AddToken(new CKwd##KWD(kd##KWD.ptszKwd,    \ <br>                                  kd##KWD.bndPrefix,  \ <br>                                  kd##KWD.bndSuffix)) <br> <br> <br>BOOL <br>InitKeywords() <br>{ <br>    KEYWORD_INIT(StartTag); <br>    KEYWORD_INIT(Anchor); <br>    KEYWORD_INIT(Area); <br>    KEYWORD_INIT(EndTag); <br>    KEYWORD_INIT(HRef); <br>    KEYWORD_INIT(BegCmnt); <br>    KEYWORD_INIT(EndCmnt); <br>    KEYWORD_INIT(BegCmnt2); <br>    KEYWORD_INIT(EndCmnt2); <br> <br>    DUMP(&amp;g_trie); <br> <br>    return TRUE; <br>} <br> <br> <br> <br>BOOL <br>TerminateKeywords() <br>{ <br>    g_trie.Flush(); <br>    return TRUE; <br>} <br> <br> <br> <br>//---------------------------------------------------------------- <br>// "&lt;" starting a tag <br> <br>UINT <br>CKwdStartTag::CountBytes( <br>    CStateStack&amp; rss, <br>    LPCTSTR      ptszData, <br>    UINT         cchData) const <br>{ <br>    rss.m_fInTag = TRUE; <br>    return 0; <br>} <br> <br> <br> <br>//---------------------------------------------------------------- <br>// "&lt;a" <br> <br>UINT <br>CKwdAnchor::CountBytes( <br>    CStateStack&amp; rss, <br>    LPCTSTR      ptszData, <br>    UINT         cchData) const <br>{ <br>    if (!rss.m_fInComment) <br>        rss.push(ANCHOR); <br> <br>    return 0; <br>} <br> <br> <br> <br>//---------------------------------------------------------------- <br>// "&lt;area" (occurs inside &lt;map&gt; ... &lt;/map&gt;) <br> <br>UINT <br>CKwdArea::CountBytes( <br>    CStateStack&amp; rss, <br>    LPCTSTR      ptszData, <br>    UINT         cchData) const <br>{ <br>    if (!rss.m_fInComment) <br>        rss.push(AREA); <br> <br>    return 0; <br>} <br> <br> <br> <br>//---------------------------------------------------------------- <br>// "&gt;" closing "&lt;a [href=...] ...&gt;" or "&lt;area [href=...] ...&gt;" <br> <br>UINT <br>CKwdEndTag::CountBytes( <br>    CStateStack&amp; rss, <br>    LPCTSTR      ptszData, <br>    UINT         cchData) const <br>{ <br>    if (!rss.m_fInComment  &amp;&amp; !rss.m_fInComment2) <br>    { <br>        PARSESTATE ps = rss.top(); <br>         <br>        if (ps == HREF) <br>        { <br>            ps = rss.top(); <br>            rss.pop(); <br>        } <br>         <br>        if (ps == ANCHOR  ||  ps == AREA) <br>        { <br>            ps = rss.top(); <br>            rss.pop(); <br>        } <br>    } <br> <br>    rss.m_fInTag = FALSE; <br>    return 0; <br>} <br> <br> <br> <br>//---------------------------------------------------------------- <br>// "href=" <br> <br>UINT <br>CKwdHRef::CountBytes( <br>    CStateStack&amp; rss, <br>    LPCTSTR      ptszData, <br>    UINT         cchData) const <br>{ <br>    PARSESTATE ps = rss.top(); <br> <br>    if (!rss.m_fInComment  &amp;&amp; !rss.m_fInComment2) <br>        if (ps == ANCHOR  ||  ps == AREA) <br>            rss.push(HREF); <br> <br>    const TCHAR* const ptszEnd = ptszData + cchData; <br>     <br>    ptszData += m_str.length(); <br> <br>    const TCHAR tchDelim = *ptszData; <br> <br>    if (tchDelim == _T('"')) <br>        ++ptszData; <br>     <br>    int cLen; <br>    const URLTYPE ut = UrlType(ptszData, ptszEnd, cLen); <br>     <br>    if (ut != UT_HTTP  &amp;&amp;  ut != UT_HTTPS  &amp;&amp;  ut != UT_NONE) <br>        return 0; <br>    else <br>        ptszData += cLen; <br> <br>    // Is it an absolute URL?  E.g., http://server/foo/... <br>    // Don't want to mangle URLs that belong to some other <br>    // server, as it won't know what to do with them <br>    if (ptszData[0] == '/'  &amp;&amp;  ptszData[1] == '/') <br>        return 0; <br> <br>    // Is it a server-relative absolute URL?  E.g., http:/foo/... <br>    // Session IDs are scoped by application (virtual root) in ASP 1.0 <br>    if (ptszData[0] == '/') <br>        return 0; <br> <br>    TRACE("href = %x\n",  <br>          (SESSION_ID_PREFIX_SIZE <br>           + g_SessionIDSize <br>           + SESSION_ID_SUFFIX_SIZE)); <br> <br>    return (SESSION_ID_PREFIX_SIZE <br>            + g_SessionIDSize <br>            + SESSION_ID_SUFFIX_SIZE); <br>} <br> <br> <br> <br>UINT <br>CKwdHRef::DoFilter( <br>    CStateStack&amp; rss, <br>    LPCTSTR&amp;     rptszData, <br>    UINT         cchData, <br>    LPTSTR&amp;      rptszOutBuf) const <br>{ <br>    UINT cb = CountBytes(rss, rptszData, cchData); <br> <br>    if (cb != 0) <br>    { <br>        const TCHAR* const ptszEnd = rptszData + cchData; <br>         <br>        LPCTSTR ptsz = rptszData + m_str.length(); <br>         <br>        const TCHAR tchDelim = *ptsz; <br>         <br>        if (tchDelim == _T('"')) <br>            ++ptsz; <br>         <br>        int cLen; <br>        const URLTYPE ut = UrlType(ptsz, ptszEnd, cLen); <br>         <br>        if (ut != UT_HTTP  &amp;&amp;  ut != UT_HTTPS  &amp;&amp;  ut != UT_NONE) <br>        { <br>            ASSERT(FALSE); <br>            return 0; <br>        } <br>        else <br>            ptsz += cLen; <br>         <br>        // Is it an absolute URL?  E.g., http://server/foo/... <br>        if (ptsz[0] == '/'  &amp;&amp;  ptsz[1] == '/') <br>        { <br>            ASSERT(FALSE); <br>            return 0; <br>        } <br>         <br>        while (*ptsz != _T('?') <br>               &amp;&amp; *ptsz != _T(' ') <br>               &amp;&amp; *ptsz != _T('&gt;') <br>               &amp;&amp; *ptsz != _T('"')) <br>        { <br>            // TRACE("%c", *ptsz); <br>            ++ptsz; <br>        } <br> <br>        memcpy(rptszOutBuf, rptszData, ptsz - rptszData); <br>        rptszOutBuf += ptsz - rptszData; <br> <br>        strcpy(rptszOutBuf, SESSION_ID_PREFIX); <br>        rptszOutBuf += SESSION_ID_PREFIX_SIZE; <br> <br>        strcpy(rptszOutBuf, rss.m_szSessionID); <br>        rptszOutBuf += g_SessionIDSize; <br> <br>        strcpy(rptszOutBuf, SESSION_ID_SUFFIX); <br>        rptszOutBuf += SESSION_ID_SUFFIX_SIZE; <br> <br>        // TRACE("%s%s%s", <br>        //       SESSION_ID_PREFIX, rss.m_szSessionID, SESSION_ID_SUFFIX); <br> <br>        rptszData = ptsz; <br>    } <br>    else <br>    { <br>        // we must skip over the keyword <br>       rptszData += m_str.length(); <br>       memcpy( rptszOutBuf, m_str.c_str(), m_str.length() ); <br>       rptszOutBuf += m_str.length(); <br>    } <br> <br>    return 0;   // we have taken care of updating rptszOutBuf <br>} <br> <br> <br> <br>//---------------------------------------------------------------- <br>// "&lt;--! " <br> <br>UINT <br>CKwdBegCmnt::CountBytes( <br>    CStateStack&amp; rss, <br>    LPCTSTR      ptszData, <br>    UINT         cchData) const <br>{ <br>    rss.push(COMMENT); <br>    rss.m_fInComment = TRUE; <br> <br>    return 0; <br>} <br> <br> <br> <br>//---------------------------------------------------------------- <br>// " --&gt;" <br> <br>UINT <br>CKwdEndCmnt::CountBytes( <br>    CStateStack&amp; rss, <br>    LPCTSTR      ptszData, <br>    UINT         cchData) const <br>{ <br>    PARSESTATE ps = rss.top(); <br> <br>    if (ps == COMMENT) <br>    { <br>        ASSERT(rss.m_fInComment); <br>        ps = rss.top(); <br>        rss.pop(); <br>    } <br>    else if (rss.m_fInComment) <br>    { <br>        do <br>        { <br>            ps = rss.top(); <br>            rss.pop(); <br>        } while (ps != COMMENT  &amp;&amp;  ps != INVALID); <br>    } <br> <br>    rss.m_fInComment = FALSE; <br> <br>    return 0; <br>} <br> <br> <br> <br> <br>//---------------------------------------------------------------- <br>// "&lt;comment": an IE- and Mosaic-specific tag <br> <br>UINT <br>CKwdBegCmnt2::CountBytes( <br>    CStateStack&amp; rss, <br>    LPCTSTR      ptszData, <br>    UINT         cchData) const <br>{ <br>    rss.push(COMMENT2); <br>    rss.m_fInComment2 = TRUE; <br> <br>    return 0; <br>} <br> <br> <br> <br>//---------------------------------------------------------------- <br>// " &lt;/comment" <br> <br>UINT <br>CKwdEndCmnt2::CountBytes( <br>    CStateStack&amp; rss, <br>    LPCTSTR      ptszData, <br>    UINT         cchData) const <br>{ <br>    PARSESTATE ps = rss.top(); <br> <br>    if (ps == COMMENT2) <br>    { <br>        ASSERT(rss.m_fInComment2); <br>        ps = rss.top(); <br>        rss.pop(); <br>    } <br>    else if (rss.m_fInComment2) <br>    { <br>        do <br>        { <br>            ps = rss.top(); <br>            rss.pop(); <br>        } while (ps != COMMENT2  &amp;&amp;  ps != INVALID); <br>    } <br> <br>    rss.m_fInComment2 = FALSE; <br> <br>    return 0; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
