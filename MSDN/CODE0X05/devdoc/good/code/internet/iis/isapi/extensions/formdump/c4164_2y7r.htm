<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>KEYS.CPP</title>
<link disabled rel=stylesheet href=../../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context4167"></a>KEYS.CPP</h2>
<pre><code>/*++ <br> <br>Copyright (c) 1997  Microsoft Corporation <br> <br>Module Name:    keys.cpp <br> <br>Abstract: <br> <br>   This module contains functions which deal with keys and values  <br>   on inbound form data. Please, see keys.h for details. <br> <br>--*/ <br>#define WIN32_LEAN_AND_MEAN     // the bare essential Win32 API <br>#include &lt;windows.h&gt;                                                                     <br>#include &lt;httpext.h&gt; <br> <br>// <br>// If your application plans to receive huge amounts of data <br>// and you don't want megabytes of memory allocated, define <br>// the USE_TEMPORARY_FILES.  It is recommended to leave the <br>// define line below commented out unless absolutely necessary. <br>//  <br> <br>//#define USE_TEMPORARY_FILES <br> <br>#include "keys.h" <br> <br>#ifndef USE_MEMORY <br> <br>#ifndef USE_TEMPORARY_FILES <br>#define USE_MEMORY <br>#endif <br> <br>#endif <br> <br> <br>// <br>// If you want to record errors, modify this macro definition to <br>// call your own logging function.  This sample does not save <br>// error strings. <br>//  <br>#define LOG(errorstring)        // OutputDebugString( errorstring ); \ <br>                                // OutputDebugString ( "\r\n" ) <br> <br>// <br>//  <br>// Intended external interface: <br>//  <br>// GetKeyList       Determines if data was sent, and if it was, the <br>// data is extracted by GetPostKeys or GetUrlKeys, <br>// two private functions within this file.  A  <br>// pointer to a linked list is returned ( as a  <br>// handle ). <br>//  <br>// GetKeyInfo       Returns a pointer to the key name, <br>// the length of the data, a flag indicating if <br>// the data has control characters in it, and an <br>// instance number for duplicate key names. <br>//  <br>// GetKeyBuffer Returns a pointer to the buffer holding the key's <br>// data. <br>//  <br>// FindKey          Sequentially searches linked list for key name. <br>//  <br>// FreeKeyList      Deallocates memory used by the linked list of <br>// keys.  Also deletes content resources. <br>//  <br>// GetKeyOffset Returns the offset to either the content memory <br>// buffer or the content temporary file. <br>//  <br>// GetContentFile   Returns a pointer to the temporary file, only <br>// when USE_TEMPORARY_FILES is defined. <br>//  <br>// CloseContentFile Closes the content file, normally left open <br>// until FreeKeyList is called, available only <br>// when USE_TEMPORARY_FILES is defined. <br>//  <br>// OpenContentFile Reopens the content file for additional use <br>// by GetKeyBuffer, available only when  <br>// USE_TEMPORARY_FILES is defined. <br>//  <br>// GetDataBuffer    Returns a pointer to the content, only if the <br>// USE_TEMPORARY_FILES constant is NOT defined. <br>//  <br>// Helper functions called only in this source file: <br>//  <br>// GetQueryByte Similar to GetPostedByte, this function <br>// extracts data from the query string. <br>//  <br>// HexDigitToInt    Returns the decimal value of a hex character. <br>//  <br>// GetFirstByte Sets up POSDATA struct and calls GetNextByte. <br>// Caller specifies function used to retrieve <br>// data, either GetPostedByte or GetQueryByte. <br>//  <br>// GetNextByte      Uses GetInboundByte ( specified in GetFirstByte ) <br>// to retrieve inbound data, and decodes it using <br>// the URL encoding rules. <br>//  <br>// BKL_Alloc        Allocates memory used in GetPostKeys. <br>//  <br>// BKL_Dealloc      Deallocates memory used in GetPostKeys. <br>//  <br>// BKL_Abort        Cleans up all resources for abnormal exits from <br>// GetPostKeys. <br>//  <br>// IsKeySeparator   Returns TRUE if character is one of "=\r\n&amp;\0". <br>//  <br>// BuildKeyList Given a data extraction function ( i.e. <br>// GetPostedByte or GetQueryByte ), this function <br>// converts all keys into a linked list of POSTKEY <br>// structures. <br>//  <br>// GetPostKeys      Takes inbound data off the wire by calling <br>// BuildKeyList with GetPostedByte as the extraction <br>// function. <br>//  <br>// GetUrlKeys       Extracts data from the query string by calling <br>// BuildKeyList with GetQueryByte as the extraction <br>// function. <br>//  <br>// GetPropAddr      Calculates the address of the list's properties, <br>// appended to the first key in a list. <br>//  <br>// The typedef for the linked list is kept privately in this file, <br>// and our interface isolates other source files from the  <br>// implementation details. <br>//  <br> <br>// <br>// Constants for this source file only <br>//  <br> <br>#define MAX_KEY_NAME_LENGTH 256 // maximum size of an inbound key name <br>#define CONTENT_BUF_LENGTH 8192 // amount of content buffered before <br>                                // WriteFile call <br>                                    // ( used for temporary files only ) <br> <br>#define GNB_NOTHING_LEFT 0      // GetNextByte return values <br>#define GNB_DECODED_CHAR 1 <br>#define GNB_NORMAL_CHAR 2 <br> <br> <br>// <br>// POSDATA struct is used with GetInboundByte to keep <br>// track of the position within incoming data. <br>// GETINBOUNDBYTE is a function pointer type. <br>//  <br> <br>typedef struct _tagPOSDATA { <br>    EXTENSION_CONTROL_BLOCK *pECB; <br>    int nCurrentPos;            // overall position <br> <br>    int nBufferLength;          // length of buffer <br> <br>    int nBufferPos;             // position within buffer <br> <br>    int nAllocLength;           // size of buffer as allocated <br> <br>    LPBYTE pData; <br>    int (*GetInboundByte)(struct _tagPOSDATA * p); <br>} POSDATA, *PPOSDATA; <br> <br>typedef int (*GETINBOUNDBYTE)(PPOSDATA p); <br> <br> <br>#ifdef USE_MEMORY <br> <br>// <br>// LISTPROP struct is used to maintain a set of <br>// list-wide properties.  This implementation <br>// uses the properties list to hold a buffer <br>// pointer. <br>//  <br> <br>typedef struct _tagLISTPROP { <br>    LPBYTE lpbyBuf; <br>} LISTPROP, *PLISTPROP; <br> <br>#elif defined USE_TEMPORARY_FILES <br> <br>// <br>// This LISTPROP struct holds temporary <br>// file information. <br>//  <br> <br>typedef struct _tagLISTPROP { <br>    char szTempFileName[MAX_PATH]; <br>    HANDLE hFile; <br>} LISTPROP, *PLISTPROP; <br> <br>#endif <br> <br> <br>// This private helper needs a prototype <br>PLISTPROP GetPropAddr( HKEYLIST hKey ); <br> <br>  <br>int  <br>GetPostedByte(  <br>    PPOSDATA pPosData  <br>) <br>/*++ <br> <br>Purpose: <br> <br>    GetPostedByte returns a waiting character that is not <br>    decoded yet.  We have this function to smooth out the <br>    inbound data: the server gives us blocks of data, one at <br>    a time, and there can be any number of blocks. <br>      <br>    For the first call, pPosData-&gt;nAllocLength must be zero, <br>    and pECB must be set. <br> <br>Arguments: <br> <br>    pPostData - pointer to POSTDATA struct <br> <br>Returns: <br> <br>    incoming byte value or <br>    -1 to indicate an error <br> <br>--*/ <br>{ <br>    int nBytesToCopy; <br> <br>    // For readability only... <br>    EXTENSION_CONTROL_BLOCK *pECB; <br> <br>    pECB = pPosData-&gt;pECB; <br> <br>    //  <br>    // Initialize position struct on first call. <br>    //  <br> <br>    if ( !pPosData-&gt;nAllocLength ) { <br>        // Initialize the members <br>        pPosData-&gt;nCurrentPos = 0; <br>        pPosData-&gt;nBufferPos = 0; <br>        pPosData-&gt;nBufferLength = 0; <br>        pPosData-&gt;nAllocLength = 0x10000;   // 65536 bytes <br> <br>        // Allocate the memory <br>        pPosData-&gt;pData = (LPBYTE) HeapAlloc(  <br>            GetProcessHeap( ), <br>            HEAP_ZERO_MEMORY, <br>            pPosData-&gt;nAllocLength ); <br>    } <br>    //  <br>    // Was memory allocated?  Is it still allocated? <br>    // If not, return right away. <br>    //  <br> <br>    if ( !pPosData-&gt;pData ) { <br>        LOG( "GetPostedByte: Buffer not allocated." ); <br>        return -1; <br>    } <br>    //  <br>    // Check for end.  Deallocate and return if we're done. <br>    //  <br> <br>    if ( (DWORD) pPosData-&gt;nCurrentPos == pECB-&gt;cbTotalBytes ) { <br> <br>        HeapFree( GetProcessHeap( ), 0, (LPVOID) pPosData-&gt;pData ); <br>        pPosData-&gt;pData = 0; <br> <br>        return -1; <br>    } <br> <br>    //  <br>    // Check for buffer not loaded.  Load if necessary. <br>    //  <br> <br>    if ( pPosData-&gt;nBufferPos == pPosData-&gt;nBufferLength ) { <br> <br>        //  <br>        // Fill the buffer with new inbound data. <br>        // Request it via ReadClient if necessary. <br>        //  <br> <br>        if ( pECB-&gt;cbAvailable &lt; 1 ) { <br> <br>            // Calculate how much we should go and get <br>            nBytesToCopy = pECB-&gt;cbTotalBytes - pPosData-&gt;nCurrentPos; <br>            if ( nBytesToCopy &gt; pPosData-&gt;nAllocLength ) { <br>                nBytesToCopy = pPosData-&gt;nAllocLength; <br>            } <br> <br>            // Let's go get the data <br>            if ( !pECB-&gt;ReadClient(  <br>                    pECB-&gt;ConnID,  <br>                    pPosData-&gt;pData,  <br>                    (LPDWORD) &amp; nBytesToCopy  <br>                    )) { <br>                HeapFree( GetProcessHeap( ), 0, (LPVOID) pPosData-&gt;pData ); <br>                pPosData-&gt;pData = 0; <br> <br>                LOG( "GetPostedByte: Error reading data via ReadClient" ); <br>                return -1; <br>            } <br>        }else{ <br>            // Take at most nAllocLength bytes of data <br>            if ( pECB-&gt;cbAvailable &gt; (DWORD) (pPosData-&gt;nAllocLength) ) { <br>                nBytesToCopy = pPosData-&gt;nAllocLength; <br>            }else{ <br>                nBytesToCopy = pECB-&gt;cbAvailable; <br>            } <br> <br>            // Copy the inbound data to our buffer <br>            memcpy(  <br>                pPosData-&gt;pData, <br>                &amp;pECB-&gt;lpbData[pPosData-&gt;nCurrentPos], <br>                nBytesToCopy  <br>                ); <br> <br>            // Account for removed data <br>            pECB-&gt;cbAvailable -= nBytesToCopy; <br>        } <br> <br>        // Our buffer is now full <br>        pPosData-&gt;nBufferLength = nBytesToCopy; <br>        pPosData-&gt;nBufferPos = 0; <br> <br>        // Make sure we have something <br>        if ( !nBytesToCopy ) { <br>            HeapFree( GetProcessHeap( ), 0, (LPVOID) pPosData-&gt;pData ); <br>            pPosData-&gt;pData = 0; <br>            return -1; <br>        } <br>    } <br>    //  <br>    // Inc current pos, buffer pos, and return a character <br>    //  <br> <br>    pPosData-&gt;nCurrentPos++; <br>    pPosData-&gt;nBufferPos++; <br>    return ( (int)pPosData-&gt;pData[pPosData-&gt;nBufferPos - 1] ); <br>} <br> <br> <br>  <br>int  <br>GetQueryByte(  <br>    IN OUT PPOSDATA pPosData  <br>) <br>/*++ <br> <br>Purpose: <br> <br>    Returns a waiting character that is not <br>    decoded yet.  We have this function to match GetPostedData. <br> <br>    For the first call, pPosData-&gt;nAllocLength must be zero, <br>    and pECB must be set. <br> <br> <br>Arguments: <br> <br>    pPostData - points to POSDATA structura <br> <br>Returns: <br> <br>    byte value or -1 to indicate an error <br> <br>--*/ <br>{ <br>    // For readability only... <br>    EXTENSION_CONTROL_BLOCK *pECB; <br> <br>    pECB = pPosData-&gt;pECB; <br> <br>    //  <br>    // Initialize position struct on first call. <br>    //  <br> <br>    if ( !pPosData-&gt;nAllocLength ) { <br>        // Initialize the useful members <br>        pPosData-&gt;nBufferPos = 0; <br>        pPosData-&gt;nBufferLength = lstrlen( (LPCSTR) pECB-&gt;lpszQueryString ); <br>        pPosData-&gt;nAllocLength = -1; <br> <br>        char szMsg[256]; <br> <br>        wsprintf(  <br>            szMsg,  <br>            "pPosData-&gt;nBufferLength=%i",  <br>            pPosData-&gt;nBufferLength  <br>            ); <br>        LOG( szMsg ); <br>    } <br> <br>    //  <br>    // Check for end.  Deallocate and return if we're done. <br>    //  <br> <br>    if ( pPosData-&gt;nBufferPos == pPosData-&gt;nBufferLength ) { <br>        return -1; <br>    } <br> <br>    //  <br>    // Inc buffer pos and return a character <br>    //  <br> <br>    pPosData-&gt;nBufferPos++; <br>    return ( (int)pECB-&gt;lpszQueryString[pPosData-&gt;nBufferPos - 1] ); <br>} <br> <br> <br>// <br>// Now that we have GetPostedByte, and GetQueryByte, we can  <br>// build a more useful function that decodes URL-style  <br>// encoded characters. <br>//  <br>// Recall that there are two special cases for this encoding: <br>//  <br>// 1. Each plus sign must be converted to a space <br>// 2. A percent sign denotes a hex value-encoded character <br>//  <br>// Percents are used to specify characters that are otherwise <br>// illegal.  This includes percents themselves, ampersands, <br>// control characters, and so on. <br>//  <br>// GetNextByte returns the decoded byte, plus a flag indicating <br>// normal character, decoded character, or failure.  See top of   <br>// file for return value constants. <br>//  <br> <br>  <br>int  <br>HexDigitToInt(  <br>    IN char c  <br>) <br>/*++ <br> <br>Purpose: <br>    HexDigitToInt simply converts a hex-based character to an int. <br> <br>Arguments: <br>    tc - character to convert <br> <br>Returns: <br>    binary value of the character (0-15) <br>    -1 if the character is not hex digit <br> <br>--*/ <br>{ <br>    if ( c &gt;= '0' &amp;&amp; c &lt;= '9' ) { <br>        return ( c - '0' ); <br>    } <br> <br>    if ( tolower( c ) &gt;= 'a' &amp;&amp; tolower( c ) &lt;= 'f' ) { <br>        return ( tolower( c ) - 'a'  + 10 ); <br>    } <br> <br>    return -1; <br>} <br> <br>  <br>int  <br>GetNextByte(  <br>    IN OUT PPOSDATA pPosData,  <br>    OUT char * pc  <br>) <br>/*++ <br> <br>Purpose: <br>    Decode single byte of the input data <br> <br>Arguments: <br>    pPostData - points to POSDATA struct <br>    pc - points to variable to accept decoded byte <br> <br>Returns: <br>    GNB_NORMAL_CHAR, GNB_NOTHING_LEFT or GNB_DECODED_CHAR <br> <br>--*/ <br>{ <br>    int nChar; <br>    int nDigit; <br> <br>    // Initialize character pointer <br>    *pc = 0; <br> <br>    // Fetch the next inbound character <br>    nChar = pPosData-&gt;GetInboundByte( pPosData ); <br>    if ( nChar == -1 ) { <br>        return GNB_NOTHING_LEFT; <br>    } <br> <br>    // Plus signs: convert to spaces <br>    if ( nChar == '+' ) { <br>        *pc = ' '; <br>        return GNB_DECODED_CHAR; <br>    } <br>    // Percent signs: convert hex values <br>    else if ( nChar == '%' ) { <br>        nChar = pPosData-&gt;GetInboundByte( pPosData ); <br>        nDigit = HexDigitToInt( nChar ); <br>        if ( nDigit == -1 ) { <br>            return GNB_NOTHING_LEFT; <br>        } <br> <br>        *pc = ( char ) ( ( UINT ) nDigit &lt;&lt; 4 ); <br> <br>        nChar = pPosData-&gt;GetInboundByte( pPosData ); <br>        nDigit = HexDigitToInt( nChar ); <br>        if ( nDigit == -1 ) {  <br>            *pc = 0;            // incomplete <br> <br>            return GNB_NOTHING_LEFT; <br>        } <br>        *pc |= ( char ) ( UINT ) nDigit; <br> <br>        return GNB_DECODED_CHAR; <br>    } <br>    // Must be normal character then <br>    *pc = (char) nChar; <br> <br>    return GNB_NORMAL_CHAR; <br>} <br> <br>  <br>int  <br>GetFirstByte(  <br>    IN OUT PPOSDATA pPosData, <br>    IN EXTENSION_CONTROL_BLOCK * pECB, <br>    OUT char * pc,  <br>    IN GETINBOUNDBYTE GetInboundByte  <br>) <br>/*++ <br> <br>Purpose: <br> <br>    GetFirstByte eliminates the guesswork from initialization. <br>    We call GetFirstByte with an uninitialized POSDATA structure, <br>    and we call GetNextByte from there on. <br> <br>Arguments: <br>    pPosData - points to POSDATA struct to initialize <br>    pECB - points to the extenstion control block  <br>    pc - points to variable to accept decoded byte <br>    GetInboundByte - points to function to get incoming bytes <br> <br> <br>Returns: <br>    same as GetNextByte() <br> <br>--*/ <br>{ <br>    // Initialize struct <br>    pPosData-&gt;nAllocLength = 0; <br>    pPosData-&gt;pECB = pECB; <br>    pPosData-&gt;GetInboundByte = GetInboundByte; <br> <br>    // Make the call as usual <br>    return GetNextByte( pPosData, pc ); <br>} <br> <br> <br>// <br>// Structure used in data processing - the elements of the <br>// key list. <br>//  <br> <br>typedef struct _tagPOSTKEY { <br>    int nInstance;              // used when key name is the same as another,  <br>                                // normally 0 <br> <br>    DWORD dwOffset;             // offset into content file <br>    DWORD dwLength;             // length of data <br>    BOOL bHasCtrlChars;         // a character value &lt; 32 is in data <br>    struct _tagPOSTKEY *pNext;  // linked list <br>    struct _tagPOSTKEY *pHead;  // first in linked list <br>    LPBYTE lpbyBuf;             // pointer to the key's data in the list <br>                                // buffer <br> <br>    // key string appended to structure <br>    // for the head key, list properties are appended <br>} POSTKEY, *PPOSTKEY; <br> <br> <br> <br>// <br>// These three helper functions isolate the memory allocation,  <br>// deallocation and abnormal exit code.  They are used only to  <br>// keep BuildKeyList readable. <br>//  <br> <br>  <br>BOOL  <br>BKL_Alloc(  <br>    OUT LPSTR * plpszKey,  <br>    OUT LPBYTE * plpbyBuf  <br>) <br>{ <br>    // Allocate a buffer for the key name <br>    *plpszKey = (LPSTR) HeapAlloc( GetProcessHeap( ), <br>        HEAP_ZERO_MEMORY, <br>        MAX_KEY_NAME_LENGTH ); <br> <br>    if ( !*plpszKey ) { <br>        return FALSE; <br>    } <br> <br>#ifdef USE_MEMORY <br>    // Init buffer to NULL <br>    *plpbyBuf = NULL; <br> <br>#elif defined USE_TEMPORARY_FILES <br> <br>    // Allocate a buffer for the content <br>    *plpbyBuf = (LPBYTE) HeapAlloc( GetProcessHeap( ), <br>        HEAP_ZERO_MEMORY, <br>        CONTENT_BUF_LENGTH ); <br> <br>    if ( !*plpbyBuf ) { <br>        HeapFree( GetProcessHeap( ), 0, (LPVOID) * plpszKey ); <br>        return FALSE; <br>    } <br>#endif <br> <br>    return TRUE; <br>} <br> <br>  <br>void  <br>BKL_Dealloc(  <br>    IN LPSTR * plpsz,  <br>    IN LPBYTE * plpby  <br>) <br>{ <br>    if ( plpsz &amp;&amp; *plpsz ) { <br>        HeapFree( GetProcessHeap( ), 0, (LPVOID) * plpsz ); <br>    } <br>    if ( plpby &amp;&amp; *plpby ) { <br>        HeapFree( GetProcessHeap( ), 0, (LPVOID) * plpby ); <br>    } <br>} <br> <br>// <br>// This allows us to clean up... with temporary files we have to close <br>// and delete them.  Otherwise, we have to free a lot of memory. <br>//  <br> <br>#ifdef USE_TEMPORARY_FILES <br>#define MACRO_AbortCleanup BKL_Abort( pHead, hDataFile, \ <br>    lpszKeyNameBuf, lpbyContentBuf );\ <br>    if ( hDataFile != INVALID_HANDLE_VALUE ) DeleteFile( szTempPath ) <br> <br>#elif defined USE_MEMORY <br> <br>#define MACRO_AbortCleanup BKL_Abort( pHead, INVALID_HANDLE_VALUE, \ <br>    lpszKeyNameBuf,lpbyContentBuf )  <br>#endif <br> <br>  <br>void  <br>BKL_Abort(  <br>    IN PPOSTKEY pHead,  <br>    IN HANDLE hFile,  <br>    IN LPSTR lpszKey,  <br>    IN LPBYTE lpbyBuf  <br>) <br>{ <br>    if ( pHead ) { <br>        FreeKeyList( (HKEYLIST) pHead ); <br>    } <br> <br>    if ( hFile != INVALID_HANDLE_VALUE ) { <br>        CloseHandle( hFile ); <br>    } <br> <br>    BKL_Dealloc( &amp;lpszKey, &amp;lpbyBuf ); <br>} <br> <br>  <br>BOOL  <br>IsKeySeparator(  <br>    char c  <br>) <br>/*++ <br> <br>Purpose: <br>    Identify key separators <br> <br>Arguments: <br>    c - character <br> <br>Returns: <br>    TRUE if character is a key separator, <br>    FALSE otherwise <br> <br>--*/ <br>{ <br>    return ( c == '=' || c == '\r' || c == '\n' || c == '&amp;' || !c ); <br>} <br> <br>  <br>PPOSTKEY  <br>BuildKeyList(  <br>    IN EXTENSION_CONTROL_BLOCK * pECB, <br>    IN GETINBOUNDBYTE GetInboundByte  <br>) <br>/*++ <br> <br>Purpose: <br> <br>    Now that we have a way to get a decoded byte from the stream, <br>    we can parse POST data.  POST data comes in as: <br> <br>    key=data&amp;key=data&amp;key=data\r\n <br> <br>    A linked list of keys is established, and the head node <br>    of the list is returned.  A NULL indicates no keys or <br>    an error. <br> <br> <br>Arguments: <br>    pECB - pointer to the extension control block <br>    GetInboundByte - pointer to function to get input data <br> <br>Returns: <br>    Pointer to the head node or NULL <br> <br>--*/ <br>{ <br>    PPOSTKEY pHead = NULL;      // head of linked list ( the return val ) <br>    PPOSTKEY pTail = NULL;      // last member in linked list <br>    PPOSTKEY pNewPostKey;       // pointer for unlinked, newly allocated <br>                                // objects <br> <br>    PPOSTKEY pListWalk;         // linked list walking pointer <br>    PLISTPROP pProp;            // pointer to list properties <br>    LPSTR lpszKeyNameBuf;       // pointer to buffer, used in obtaining key <br>                                // name <br> <br>    int nPos;                   // position within key name buffer <br>    DWORD dwOffset;             // offset from start of content buffer or <br>                                // file <br> <br>    DWORD dwLength;             // length of key data <br>    char c;                     // general-purpose character <br>    int nReturn;                // general-purpose return code <br>    POSDATA pd;                 // POSDATA struct needed in GetInboundByte <br>    int nContentPos;            // position within content buffer <br>    LPBYTE lpbyContentBuf;      // pointer to buffer <br>    BOOL bHasCtrlChars;         // flag to detect ctrl chars <br> <br>    // Call helper to allocate a buffer <br>    if ( !BKL_Alloc( &amp;lpszKeyNameBuf, &amp;lpbyContentBuf ) ) { <br>        LOG( "BuildKeyList: Memory allocation failure" ); <br>        return NULL; <br>    } <br>    nContentPos = dwOffset = 0; <br> <br> <br>#ifdef USE_MEMORY <br>    //  <br>    // Allocate enough memory for all the content. <br>    // For the POST method, the cbTotalBytes gives us the number <br>    // of bytes that are being sent by the browser.  We can  <br>    // allocate that much but we'll really only use about 75% of it. <br>    // For the GET method, we need to allocate the size of the <br>    // query string plus 1. <br>    //  <br> <br>    lpbyContentBuf = (LPBYTE) HeapAlloc( GetProcessHeap( ), <br>        HEAP_ZERO_MEMORY, <br>        pECB-&gt;cbTotalBytes + <br>        lstrlen( pECB-&gt;lpszQueryString ) + 1 ); <br> <br>    if ( !lpbyContentBuf ) { <br> <br>        LOG( "BuildKeyList: Error allocating content memory" ); <br>        BKL_Dealloc( &amp;lpszKeyNameBuf, &amp;lpbyContentBuf ); <br> <br>        return NULL; <br>    } <br>#elif defined USE_TEMPORARY_FILES <br> <br>    //  <br>    // When USE_TEMPORARY_FILES is chosen, we create <br>    // a temporary file to store all the inbound data. <br>    // This is done to support huge amounts of inbound <br>    // data, like file uploads. <br>    //  <br> <br>    char szTempDir[MAX_PATH];   // directory of temporary files <br>    char szTempPath[MAX_PATH];  // path of content file <br>    HANDLE hDataFile;           // handle to content file <br>    DWORD dwBytesWritten;       // used with WriteFile <br> <br>    // Get a temp file name <br>    GetTempPath( MAX_PATH, szTempDir ); <br>    if ( !GetTempFileName( szTempDir, "key", 0, szTempPath ) ) { <br> <br>        LOG( "BuildKeyList: Error creating temporary file" ); <br>        BKL_Dealloc( &amp;lpszKeyNameBuf, &amp;lpbyContentBuf ); <br> <br>        return NULL; <br>    } <br>    // Create the content file <br>    hDataFile = CreateFile( szTempPath, <br>        GENERIC_READ | GENERIC_WRITE, <br>        0,                      // No sharing mode <br>        NULL,                   // Default security attribs <br>        CREATE_ALWAYS, <br>        FILE_ATTRIBUTE_NORMAL, <br>        NULL                    // No template file <br>        ); <br> <br>    // Return if an error occured <br>    if ( hDataFile == INVALID_HANDLE_VALUE ) { <br>        LOG( "BuildKeyList: Error opening temporary file" ); <br>        MACRO_AbortCleanup; <br>        return NULL; <br>    } <br>#endif <br> <br> <br>    //  <br>    // 'for' statement detects the start of a valid key name. <br>    //  <br>    // To do inside 'for' loop: <br>    // Obtain key name <br>    // Write data to buffer or content file <br>    // Create POSTKEY object <br>    // Update links <br>    //  <br> <br>    for ( nReturn = GetFirstByte( &amp;pd, pECB, &amp;c, GetInboundByte ); <br>        nReturn != GNB_NOTHING_LEFT; <br>        nReturn = GetNextByte( &amp;pd, &amp;c ) ) { <br>             <br>        // If \r or \n, ignore and continue <br>        if ( c == '\r' || c == '\n' ) { <br>            continue; <br>        } <br> <br>        // Get a key name <br>        nPos = 0; <br>        while ( !IsKeySeparator( c ) ) { <br>            if ( nPos &lt; MAX_KEY_NAME_LENGTH ) { <br>                lpszKeyNameBuf[nPos] = c; <br>                nPos++; <br>            } <br>            nReturn = GetNextByte( &amp;pd, &amp;c ); <br>            if ( nReturn == GNB_NOTHING_LEFT )  { // abrupt end! <br>                break; <br>            } <br>        } <br> <br>        // If no equals sign or name too long, <br>        // we have a browser formatting error <br>        if ( c != '=' || nPos == MAX_KEY_NAME_LENGTH ) { <br>            LOG( "BuildKeyList: Browser formatting error" ); <br> <br>            MACRO_AbortCleanup; <br>            return NULL; <br>        } <br> <br>        // Truncate the name string, reset data info variables <br>        lpszKeyNameBuf[nPos] = 0; <br>        nPos++; <br>        dwLength = 0; <br>        bHasCtrlChars = FALSE; <br> <br>        //  <br>        // Move the data to the content buffer or file. <br>        //  <br>        for ( nReturn = GetNextByte( &amp;pd, &amp;c ); <br>            !IsKeySeparator( c ) || nReturn == GNB_DECODED_CHAR; <br>            nReturn = GetNextByte( &amp;pd, &amp;c ) ) { <br> <br>            lpbyContentBuf[nContentPos] = c; <br> <br>            nContentPos += sizeof ( char ); <br>            dwLength++; <br> <br>            // Check for ctrl chars <br>            if ( c &lt; 0x20 ) { <br>                bHasCtrlChars = TRUE; <br>            } <br> <br>#ifdef USE_TEMPORARY_FILES <br>            // If we have enough data, write buffer to disk <br>            if ( nContentPos == CONTENT_BUF_LENGTH ) { <br>                if ( !WriteFile( hDataFile, lpbyContentBuf, <br>                    nContentPos, &amp;dwBytesWritten, NULL ) ) { <br> <br>                    LOG( "BuildKeyList: Error writing to content file" ); <br>                    MACRO_AbortCleanup; <br>                    return NULL; <br>                } <br>                nContentPos = 0; <br>            } <br>#endif <br> <br>        } // for( nReturn <br> <br> <br>#ifdef USE_MEMORY <br>        //  <br>        // Put a terminating NULL at the end of the key data. <br>        //  <br> <br>        lpbyContentBuf[nContentPos] = 0; <br>        nContentPos++; <br> <br>#elif defined USE_TEMPORARY_FILES <br> <br>        // Drain buffer <br>        if ( nContentPos ) { <br>            if ( !WriteFile( hDataFile, lpbyContentBuf, <br>                nContentPos, &amp;dwBytesWritten, NULL ) ) { <br> <br>                LOG( "BuildKeyList: Error writing to content file" ); <br>                MACRO_AbortCleanup; <br>                return NULL; <br>            } <br>            nContentPos = 0; <br>        } <br>#endif <br> <br> <br>        // Allocate a POSTKEY object, allocate extra for first key <br>        if ( pHead ) { <br>            pNewPostKey = (PPOSTKEY) HeapAlloc(  <br>                GetProcessHeap( ), <br>                HEAP_ZERO_MEMORY, <br>                sizeof (POSTKEY) + nPos  <br>                ); <br>        }else{ <br>            pNewPostKey = (PPOSTKEY) HeapAlloc(  <br>                GetProcessHeap( ), <br>                HEAP_ZERO_MEMORY, <br>                sizeof (POSTKEY) + nPos + <br>                sizeof (LISTPROP) ); <br> <br>            pProp = (PLISTPROP) ( (LPBYTE)pNewPostKey +  <br>                    sizeof (POSTKEY) + nPos ); <br>        } <br> <br>        // Check for valid pointer <br>        if ( !pNewPostKey ) { <br>            LOG( "BuildKeyList: POSTKEY memory allocation failure" ); <br>            MACRO_AbortCleanup; <br>            return NULL; <br>        } <br> <br>        //  <br>        // Set pNewPostKey members <br>        //  <br> <br>        // Set nInstance <br>        pNewPostKey-&gt;nInstance = 0; <br>        pListWalk = pHead; <br>        while ( pListWalk ) { <br>            // Check for duplicate key names <br>            if ( !lstrcmpi( (LPCSTR) ( &amp;pListWalk[1] ), lpszKeyNameBuf )) { <br>                pNewPostKey-&gt;nInstance++; <br>            } <br>            pListWalk = pListWalk-&gt;pNext; <br>        } <br> <br>        // Set dwOffset, dwLength, bHasCtrlChars, lpbyBuf <br>        pNewPostKey-&gt;dwOffset = dwOffset; <br>        pNewPostKey-&gt;dwLength = dwLength; <br>        pNewPostKey-&gt;bHasCtrlChars = bHasCtrlChars; <br> <br>#ifdef USE_MEMORY <br>        pNewPostKey-&gt;lpbyBuf = &amp;lpbyContentBuf[dwOffset]; <br>        dwOffset += dwLength + 1; <br> <br>#elif defined USE_TEMPORARY_FILES <br> <br>        pNewPostKey-&gt;lpbyBuf = NULL; <br>        dwOffset += dwLength; <br>#endif <br> <br> <br>        // Copy key name <br>        lstrcpy( (LPSTR) ( &amp;pNewPostKey[1] ), lpszKeyNameBuf ); <br> <br>        // Link <br>        if ( pTail ) { <br>            pTail-&gt;pNext = pNewPostKey; <br>        }else{ <br> <br>#ifdef USE_TEMPORARY_FILES <br>            // Copy content file name to list properties <br>            lstrcpy( pProp-&gt;szTempFileName, szTempPath ); <br> <br>            // Set handle <br>            pProp-&gt;hFile = hDataFile; <br> <br>#elif defined USE_MEMORY <br> <br>            // Set content buffer pointer <br>            pProp-&gt;lpbyBuf = lpbyContentBuf; <br>#endif <br> <br>            // Set head <br>            pHead = pNewPostKey; <br>        } <br> <br>        pNewPostKey-&gt;pNext = NULL; <br>        pTail = pNewPostKey; <br> <br>        pNewPostKey-&gt;pHead = pHead;     // may point to itself <br> <br>    } // for ( nReturn <br> <br>#ifdef USE_TEMPORARY_FILES <br>    //  <br>    // If content file is empty, close it and delete it <br>    //  <br> <br>    if ( !pHead ) { <br>        LOG( "Empty content file is being deleted." ); <br>        CloseHandle( hDataFile ); <br>        DeleteFile( szTempPath ); <br>    } <br>    // Free work buffer <br>    BKL_Dealloc( &amp;lpszKeyNameBuf, &amp;lpbyContentBuf ); <br> <br>#elif defined USE_MEMORY <br> <br>    // Free work buffer <br>    BKL_Dealloc( &amp;lpszKeyNameBuf, pHead ? NULL : &amp;lpbyContentBuf ); <br>#endif <br> <br> <br>    return pHead; <br>} <br> <br> <br>// <br>// We are now pretty much done with anything complex. BuildKeyList  <br>// will do all our parse work, so now we need a few wrappers to <br>// make a nice, clean external interface. <br>//  <br>// GetPostKeys calls BuildKeyList with GetPostedByte. <br>//  <br>// GetUrlKeys calls BuildKeyList with GetQueryByte. <br>//  <br> <br>PPOSTKEY  <br>GetPostKeys(  <br>    IN EXTENSION_CONTROL_BLOCK * pECB  <br>) <br>{ <br>    return BuildKeyList( pECB, GetPostedByte ); <br>} <br> <br>PPOSTKEY  <br>GetUrlKeys(  <br>    IN EXTENSION_CONTROL_BLOCK * pECB  <br>) <br>{ <br>    return BuildKeyList( pECB, GetQueryByte ); <br>} <br> <br>  <br>PLISTPROP  <br>GetPropAddr(  <br>    IN HKEYLIST hKey  <br>) <br>/*++ <br> <br>Purpose: <br> <br>    GetPropAddr returns the address of the end of <br>    the first key.  We stuff list properties there. <br>    This implementation of keys.cpp keeps a pointer <br>    to the content buffer.  The second version ( used <br>    in IS2WCGI ) appends a temporary file name <br>    to the first key. <br> <br>Arguments: <br>    hKey - pointer to a key list <br> <br>Returns: <br>    The address of the end of the first key <br> <br>--*/ <br>{ <br>    LPCSTR lpszKeyName; <br>    PPOSTKEY pHead; <br> <br>    // Safety <br>    if ( !hKey ) { </code></pre>
<p>
</p>
<pre><code>return NULL; <br>    } <br> <br>    // ContentPath follows POSTKEY struct and key name <br>    pHead = (PPOSTKEY) hKey; <br>    pHead = pHead-&gt;pHead; <br> <br>    lpszKeyName = (LPCSTR) ( &amp;pHead[1] ); <br> <br>    return (PLISTPROP) ( lpszKeyName + lstrlen( lpszKeyName ) + 1 ); <br>} <br> <br>  <br>HKEYLIST  <br>GetKeyList(  <br>    IN EXTENSION_CONTROL_BLOCK * pECB  <br>) <br>/*++ <br> <br>Purpose: <br> <br>    Examines the method and calls GetPostKeys or GetUrlKeys,  <br>    whichever is relevant. <br>  <br> <br>Arguments: <br>    pECB - points to the extension control block <br> <br>Returns: <br>    GetPropAddr returns the address of the end of <br>    the first key.  We stuff list properties there. <br>    This implementation of keys.cpp keeps a pointer <br>    to the content buffer.  The second version ( used <br>    in IS2WCGI ) appends a temporary file name <br>    to the first key. <br> <br>--*/ <br>{ <br>    if ( !lstrcmpi( pECB-&gt;lpszMethod, "POST" ) ) { <br>        LOG( "Method=POST" ); <br>        return (HKEYLIST) GetPostKeys( pECB ); <br>    }else if ( !lstrcmpi( pECB-&gt;lpszMethod, "GET" ) ) { <br>        LOG( "Method=GET" ); <br>        return (HKEYLIST) GetUrlKeys( pECB ); <br>    } <br>    LOG( "Unknown method" ); <br> <br>    return NULL; <br>} <br> <br>  <br>HKEYLIST  <br>GetKeyInfo(  <br>    IN HKEYLIST hKey,  <br>    OUT LPCSTR * plpszKeyName, <br>    OUT LPDWORD pdwLength,  <br>    OUT BOOL * pbHasCtrlChars, <br>    OUT LPINT pnInstance  <br>) <br>// <br>// GetKeyInfo is a wrapper for the POSTKEY linked list. <br>// It returns the members of the supplied POSTKEY object. <br>//  <br>{ <br>    PPOSTKEY pPostKey; <br> <br>    // Safety <br>    if ( !hKey ) { <br>        return NULL; <br>    } <br> <br>    pPostKey = (PPOSTKEY) hKey; <br> <br>    // Set the data members <br>    if ( plpszKeyName ) <br>        *plpszKeyName = ( LPCSTR ) ( &amp;pPostKey[1] ); <br>    if ( pdwLength ) <br>        *pdwLength = pPostKey-&gt;dwLength; <br>    if ( pbHasCtrlChars ) <br>        *pbHasCtrlChars = pPostKey-&gt;bHasCtrlChars; <br>    if ( pnInstance ) <br>        *pnInstance = pPostKey-&gt;nInstance; <br> <br>    // Return a handle to the next object in the list <br>    return ( ( HKEYLIST ) pPostKey-&gt;pNext ); <br>} <br> <br> <br> <br>#ifdef USE_MEMORY <br>LPBYTE  <br>GetKeyBuffer(  <br>    IN HKEYLIST hKey  <br>) <br>{ <br>    //  <br>    // We have two versions of this function because <br>    // we may want to use file i/o when the extension <br>    // deals with massive amounts of inbound data <br>    // ( like multi-megabyte uploads ). <br>    //  <br> <br>    //  <br>    // This version uses a memory buffer. <br>    //  <br> <br>    PPOSTKEY pKey; <br> <br>    // Safety <br>    if ( !hKey ) { <br>        return NULL; <br>    } <br> <br>    pKey = (PPOSTKEY) hKey; <br> <br>    return (LPBYTE) pKey-&gt;lpbyBuf; <br>} <br> <br>#elif defined USE_TEMPORARY_FILES <br> <br>LPBYTE  <br>GetKeyBuffer(  <br>    IN HKEYLIST hKey  <br>) <br>{ <br>    //  <br>    // This version uses slow temporary files. <br>    //  <br> <br>    PLISTPROP pProp; <br>    PPOSTKEY pKey; <br>    DWORD dwRead; <br> <br>    // Get pointer to list properties <br>    pProp = GetPropAddr( hKey ); <br> <br>    // Safety <br>    if ( !pProp ) { <br>        return NULL; <br>    } <br> <br>    pKey = (PPOSTKEY) hKey; <br> <br>    // Check if memory was already loaded for this key <br>    if ( pKey-&gt;lpbyBuf ) { <br>        return pKey-&gt;lpbyBuf; <br>    } <br> <br>    // If not, let's allocate memory and do a ReadFile <br>    pKey-&gt;lpbyBuf = (LPBYTE) HeapAlloc( GetProcessHeap( ), <br>        HEAP_ZERO_MEMORY, <br>        pKey-&gt;dwLength + 1 ); <br>    if ( !pKey-&gt;lpbyBuf ) { <br>        LOG( "GetKeyBuffer: HeapAlloc failed" ); <br>        return NULL; <br>    } <br>    // Do the ReadFile <br>    SetFilePointer( pProp-&gt;hFile, pKey-&gt;dwOffset, NULL, FILE_BEGIN ); <br>    if ( !ReadFile( pProp-&gt;hFile, pKey-&gt;lpbyBuf, <br>            pKey-&gt;dwLength, &amp;dwRead, NULL ) || <br>        dwRead != pKey-&gt;dwLength ) { <br>        HeapFree( GetProcessHeap( ), 0, (LPVOID) pKey-&gt;lpbyBuf ); <br>        pKey-&gt;lpbyBuf = NULL; <br> <br>        LOG( "GetKeyBuffer: ReadFile failed" ); <br>        return NULL; <br>    } <br>    return pKey-&gt;lpbyBuf; <br>} <br>#endif <br> <br>  <br>HKEYLIST  <br>FindKey(  <br>    IN HKEYLIST hKeyList,  <br>    IN LPCSTR lpszSearchName  <br>) <br>/*++ <br> <br>Purpose: <br> <br>    FindKey sequentially searches the linked list for a given key. <br> <br>Arguments: <br> <br>    hKeyList - points to key list <br>    lpszSearchName - points to a key name to find  <br> <br>Returns: <br> <br>    The return handle points to the element within the linked list. <br>    Use it in GetKeyInfo, but not FreeKeyList. <br> <br>--*/ <br>{ <br>    PPOSTKEY pFindKey; <br> <br>    pFindKey = (PPOSTKEY) hKeyList; <br>    while ( pFindKey ) { <br>        if ( !lstrcmpi( lpszSearchName, ( LPCSTR ) ( &amp;pFindKey[1] ) ) ) { <br>            return ( ( HKEYLIST ) pFindKey ); <br>        } <br> <br>        pFindKey = pFindKey-&gt;pNext; <br>    } <br> <br>    return NULL; <br>} <br> <br>  <br>void  <br>FreeKeyList(  <br>    IN HKEYLIST hHeadKey  <br>) <br>/*++ <br> <br>Purpose: <br> <br>    FreeKeyList deallocates all the objects in the key list. <br>    The content file is also deleted. <br> <br>Arguments: <br>    hHeadKey - points to the list head     <br> <br>--*/ <br>{ <br>    PPOSTKEY pObject; <br>    PPOSTKEY pDel; <br>    PLISTPROP pProp; <br> <br>    // Safety <br>    if ( !hHeadKey ) { <br>        return; <br>    } <br> <br>#ifdef USE_TEMPORARY_FILES <br>    // Close the content file <br>    CloseContentFile( hHeadKey ); <br> <br>    // delete the content file <br>    pProp = GetPropAddr( hHeadKey ); <br>    DeleteFile( pProp-&gt;szTempFileName ); <br> <br>#elif defined USE_MEMORY <br> <br>    // delete content <br>    pProp = GetPropAddr( hHeadKey ); <br>    HeapFree( GetProcessHeap( ), 0, (LPVOID) pProp-&gt;lpbyBuf ); <br>#endif <br> <br>    // delete all objects in the list <br>    pObject = (PPOSTKEY) hHeadKey; <br>    pObject = pObject-&gt;pHead; <br>    while ( pObject ) { <br> <br>#ifdef USE_TEMPORARY_FILES <br>        //  <br>        // Free each buffer when using temporary files <br>        //  <br> <br>        if ( pObject-&gt;lpbyBuf ) <br>            HeapFree( GetProcessHeap( ), 0, (LPVOID) pObject-&gt;lpbyBuf ); <br>#endif <br> <br>        pDel = pObject; <br>        pObject = pObject-&gt;pNext; <br> <br>        HeapFree( GetProcessHeap( ), 0, (LPVOID) pDel ); <br>    } <br>} <br> <br>  <br>DWORD  <br>GetKeyOffset(  <br>    IN HKEYLIST hKey  <br>) <br>/*++ <br> <br>Purpose: <br> <br>    GetKeyOffset returns the offset of a key into the internal <br>    buffer or temporary file.  This is provided for IS2WCGI <br>    so it can return an offset within the content file. <br> <br>Arguments: <br>     <br>    hKey - points to a key <br> <br>Returns: <br>     <br>    Offset of a key or NULL if no key provided <br> <br>--*/ <br>{ <br>    // Safety <br>    if ( !hKey ) <br>        return NULL; <br> <br>    return ( (PPOSTKEY) hKey )-&gt;dwOffset; <br>} <br> <br>  <br>#ifdef USE_TEMPORARY_FILES <br> <br>LPCSTR  <br>GetContentFile(  <br>    IN HKEYLIST hKeyList  <br>) <br>/*++ <br> <br>Purpose: <br> <br>    GetContentFile returns a pointer to the name of the <br>    temporary file.  This is provided for the IS2WCGI <br>    sample. <br> <br>Arguments: <br> <br> <br>Returns: <br> <br>--*/ <br>{ <br>    PLISTPROP pProp; <br> <br>    // safety <br>    if ( !hKeyList ) <br>        return NULL; <br> <br>    pProp = GetPropAddr( hKeyList ); <br> <br>    return ( LPCSTR ) pProp-&gt;szTempFileName; <br>} <br> <br>  <br>void  <br>CloseContentFile(  <br>    IN HKEYLIST hKey  <br>) <br>/*++ <br> <br>Purpose: <br> <br>    CloseContentFile forces the content file to be closed.  This <br>    allows you to pass the file to something else that may open <br>    it.  Call OpenContentFile before calling any other key <br>    function. <br> <br>Arguments: <br> <br>--*/ <br>{ <br>    PLISTPROP pProp; <br> <br>    if ( !hKey ) <br>        return; <br> <br>    pProp = GetPropAddr( hKey ); <br>    if ( pProp-&gt;hFile != INVALID_HANDLE_VALUE ) { <br>        CloseHandle( pProp-&gt;hFile ); <br>        pProp-&gt;hFile = INVALID_HANDLE_VALUE; <br>    } <br>} <br> <br>  <br>void  <br>OpenContentFile(  <br>    IN HKEYLIST hKey  <br>) <br>/*++ <br> <br>Purpose: <br> <br>    OpenContentFile forces the content file to be reopened. <br>    GetKeyBuffer will fail if the content file was closed by <br>    CloseContentFile, but not reopened. <br> <br>Arguments: <br> <br> <br>Returns: <br> <br>--*/ <br>{ <br>    PLISTPROP pProp; <br> <br>    if ( !hKey ) <br>        return; <br> <br>    pProp = GetPropAddr( hKey ); <br> <br>    if ( pProp-&gt;hFile != INVALID_HANDLE_VALUE ) <br>        return; <br> <br>    // Create the content file <br>    pProp-&gt;hFile = CreateFile( pProp-&gt;szTempFileName, <br>        GENERIC_READ | GENERIC_WRITE, <br>        0,                      // No sharing mode <br>         NULL,                  // Default security attribs <br>         OPEN_EXISTING, <br>        FILE_ATTRIBUTE_NORMAL, <br>        NULL ); <br>} <br> <br>#elif defined USE_MEMORY <br> <br>  <br>LPBYTE  <br>GetDataBuffer(  <br>    IN HKEYLIST hKeyList  <br>) <br>/*++ <br> <br>Purpose: <br> <br>    GetBufferPointer returns a pointer to the buffer used <br>    for content storage. <br> <br>Arguments: <br> <br>    hKeyList - points to a key list <br>     <br>Returns: <br> <br>    pointer to the content buffer or NULL <br> <br>--*/ <br>{ <br>    PLISTPROP pProp; <br> <br>    // safety <br>    if ( !hKeyList ) <br>        return NULL; <br> <br>    pProp = GetPropAddr( hKeyList ); <br> <br>    return pProp-&gt;lpbyBuf; <br>} <br>#endif </code></pre>
<p>&nbsp;</p></body>
</HTML>
