<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>TOKEN.CPP</title>
<link disabled rel=stylesheet href=../../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context4216"></a>TOKEN.CPP</h2>
<pre><code>#include "CkyPch.h" <br> <br>#include "debug.h" <br>#include "token.h" <br>#include "utils.h" <br> <br> <br>// Base class for keywords <br> <br>CToken::CToken( <br>    const string&amp; rstr, <br>    const BOUNDARY bndPrefix /* =IRRELEVANT */, <br>    const BOUNDARY bndSuffix /* =IRRELEVANT */) <br>    : m_str(rstr), <br>      m_bndPrefix(bndPrefix), <br>      m_bndSuffix(bndSuffix) <br>{ <br>} <br> <br> <br> <br>CToken::~CToken() <br>{ <br>} <br> <br> <br> <br>BOOL <br>CToken::MatchesBoundaryClass( <br>    const TCHAR tch, <br>    const BOUNDARY bnd) <br>{ <br>    switch (bnd) <br>    { <br>    case IRRELEVANT: <br>        return TRUE; <br>         <br>    case WHITESPACE: <br>        return _istspace(tch); <br>         <br>    case ALPHA: <br>        return _istalpha(tch); <br>         <br>    case NUMERIC: <br>        return _istdigit(tch); <br> <br>    case ALPHANUMERIC: <br>        return _istalnum(tch); <br> <br>    case NEWLINE: <br>        return tch == _T('\n')  ||  tch == _T('\r'); <br> <br>    default: <br>        ASSERT(FALSE); <br>        return FALSE; <br>    } <br>} <br> <br> <br> <br>// DoFilter: default implementation is to update the state stack <br>// and copy the text that matched the token <br> <br>UINT <br>CToken::DoFilter( <br>    CStateStack&amp; rss, <br>    LPCTSTR&amp;     rptszData, <br>    UINT         cchData, <br>    LPTSTR&amp;      rptszOutBuf) const <br>{ <br>    const UINT cb  = CountBytes(rss, rptszData, cchData); <br>    const UINT cch = m_str.length(); <br> <br>    // for (UINT i = 0; i &lt; cch; ++i) <br>    //     TRACE("%c", rptszOutBuf[i]); <br> <br>    memcpy(rptszOutBuf, rptszData, cch); <br>    rptszData += cch; <br>    rptszOutBuf += cch; <br> <br>    return cb; <br>} <br> <br> <br> <br>#ifdef _DEBUG <br> <br>void <br>CToken::AssertValid() const <br>{ <br>} <br> <br> <br> <br>void <br>CToken::Dump() const <br>{ <br>    TRACE("\t%d %d", (int) m_bndPrefix, (int) m_bndSuffix); <br>} <br> <br>#endif // _DEBUG <br> <br> <br> <br>//---------------------------------------------------------------- <br> <br> <br>bool <br>CTokenTrie::AddToken( <br>    const CToken* ptok) <br>{ <br>    return CTrie&lt;CToken, true, true&gt;::AddToken(ptok-&gt;m_str.c_str(), ptok); <br>} <br> <br> <br> <br>inline bool <br>CTokenTrie::_LastCharPresent( <br>    CHAR ch) const <br>{ <br>    ASSERT(CHAR_MIN &lt;= ch  &amp;&amp;  ch &lt;= CHAR_MAX); <br>    const UINT i = ch - CHAR_MIN;   // CHAR_MIN is -128 for `signed char' <br> <br>    return m_afLastChar[i &gt;&gt; 3] &amp; (1 &lt;&lt; (i &amp; 7))  ?  true  :  false; <br>} <br> <br> <br> <br>inline void <br>CTokenTrie::_SetLastCharPresent( <br>    CHAR ch, <br>    bool f) <br>{ <br>    ASSERT(CHAR_MIN &lt;= ch  &amp;&amp;  ch &lt;= CHAR_MAX); <br>    const UINT i = ch - CHAR_MIN; <br> <br>    if (f) <br>        m_afLastChar[i &gt;&gt; 3] |=  (1 &lt;&lt; (i &amp; 7)); <br>    else <br>        m_afLastChar[i &gt;&gt; 3] &amp;= ~(1 &lt;&lt; (i &amp; 7)); <br>} <br> <br> <br>// ctor <br> <br>CTokenTrie::CTokenTrie() <br>{ <br>    memset(m_afCharPresent, 0, sizeof(m_afCharPresent)); <br> <br>    static const CHAR achEndTokens[] = { <br>        ' ', '\t', '\f', '\b', '\r', '\n', '&gt;', <br>    }; <br> <br>    for (int i = ARRAYSIZE(achEndTokens);  --i &gt;= 0; ) <br>        _SetLastCharPresent(achEndTokens[i], true); <br>} <br> <br> <br> <br>// Returns 1 past the last character which is a valid token-ending char, <br>// or &lt; 0 if no such char <br>int <br>CTokenTrie::EndOfBuffer( <br>    PHTTP_FILTER_RAW_DATA pRawData, <br>    int iStart) <br>{ <br>    LPSTR pszData = (LPSTR) pRawData-&gt;pvInData; <br> <br>    // Empty interval? <br>    if (pRawData-&gt;cbInData == iStart) <br>        return iStart; <br> <br>    for (int i = pRawData-&gt;cbInData;  --i &gt;= iStart; ) <br>    { <br>        if (_LastCharPresent(pszData[i])) <br>            return i+1; <br>    } <br> <br>    return -1; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
