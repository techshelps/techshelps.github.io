<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>KEYS.H</title>
<link disabled rel=stylesheet href=../../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context4168"></a>KEYS.H</h2>
<pre><code>/*++ <br> <br>Copyright (c) 1997  Microsoft Corporation <br> <br>Module Name:    keys.h <br> <br>Abstract: <br> <br>    header file for reusable interface <br> <br>--*/ <br> <br>// Abstracted pointer <br>typedef void * HKEYLIST; <br> <br>// <br>// Retrieves and decodes inbound form data.  Builds list of keys, and <br>// pointers to data within a content file.  Returns handle to first <br>// element in the list. <br>// <br> <br>HKEYLIST GetKeyList(IN EXTENSION_CONTROL_BLOCK *pECB); <br> <br>// <br>// GetKeyInfo extracts the key name and content values from the <br>// supplied key, and returns a handle to the next key in the list. <br>// <br>// The length is the exact length of the inbound data, but a NULL <br>// is appended to the data.  For example, a text string of five <br>// characters has a *pdwLength=5, but GetKeyBuffer returns at <br>// least a 6 byte buffer--the five characters and a NULL. <br>// <br> <br>HKEYLIST GetKeyInfo(IN HKEYLIST hKey, OUT LPCSTR *plpszKeyName,  <br>                    OUT LPDWORD pdwLength, OUT BOOL *pbHasCtrlChars, <br>                    OUT LPINT pnInstance); <br> <br>// <br>// GetKeyBuffer returns a pointer to the buffer holding data. <br>// Depending on the implementation in keys.cpp, this may or may not <br>// be a buffer the exact size of the data (it may be bigger). <br>// <br>// The data is zero-terminated. <br>// <br> <br>LPBYTE GetKeyBuffer(IN HKEYLIST hKey); <br> <br> <br>// <br>// FindKey sequentially searches the linked list for a specific key. <br>// The return handle can be used with GetKeyInfo to get more details. <br>// FindKey returns the very first occurance of a duplicate key. <br>// Also, it searches from the given key which need not be the head <br>// key. <br>// <br> <br>HKEYLIST FindKey(IN HKEYLIST hKeyList, IN LPCSTR lpszSearchName); <br> <br> <br>// <br>// FreeKeyList releases all of the memory associated with a key list. <br>// Also, content resources are deleted. <br>// <br> <br>void FreeKeyList(IN HKEYLIST hKeyList); <br> <br> <br>// <br>// GetKeyOffset returns the offset within the internal buffer or <br>// the content file.  Under normal circumstances, use GetKeyInfo <br>// and GetKeyBuffer instead of directly accessing the buffer. <br>// <br> <br>DWORD GetKeyOffset(IN HKEYLIST hKey); <br> <br> <br>#ifdef USE_TEMPORARY_FILES <br>// <br>// GetContentFile returns the name of the temporary file used <br>// to save the content.  The temporary file may be open. <br>// <br> <br>LPCTSTR GetContentFile(IN HKEYLIST hKeyList); <br> <br>// <br>// CloseContentFile forces the content file to be closed.  This <br>// allows you to pass the file to something else that may open <br>// it.  Call OpenContentFile before calling any other key <br>// function. <br>// <br> <br>void CloseContentFile(IN HKEYLIST hKeyList); <br> <br> <br>// <br>// OpenContentFile forces the content file to be reopened. <br>// GetKeyBuffer will fail if the content file was closed by <br>// CloseContentFile, but not reopened. <br>// <br> <br>void OpenContentFile(IN HKEYLIST hKeyList); <br> <br>#else <br> <br>// <br>// GetDataBuffer returns a pointer to the start of the data <br>// buffer which holds all content.  This function is not <br>// particularly useful -- use GetKeyBuffer to get a pointer <br>// to the buffer for a specific key. <br>// <br> <br>LPBYTE GetDataBuffer(IN HKEYLIST hKey); <br> <br>#endif <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
