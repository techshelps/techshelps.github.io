<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>TRIE.H</title>
<link disabled rel=stylesheet href=../../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context4218"></a>TRIE.H</h2>
<pre><code>// A trie is a multiway search tree (aka a radix tree).  See a good <br>// algorithms text, like Knuth or Sedgewick, for a complete description. <br>// <br>// Briefly, given a list of strings such as <br>//      cab, car, carts, cats, dog, doge, dogs <br>// you get a trie that looks like this: <br>// <br>//                /-[b] <br>//               / <br>//        &lt;c&gt;--&lt;a&gt;--[r]--&lt;t&gt;--[s] <br>//       /       \ <br>//      /         \-&lt;t&gt;--[s] <br>//     *              <br>//      \              /-[e] <br>//       \            / <br>//        &lt;d&gt;--&lt;o&gt;--[g] <br>//                    \ <br>//                     \-[s] <br>// <br>// where `[r]' denotes the end of a word and `&lt;a&gt;', the middle. <br>// <br>// A trie has several useful properties: <br>//  * fast <br>//  * easily handles longest substring matches <br>//  * fairly compact, especially when there are many overlapping strings <br>// <br>// The multiway tree is implemented as a binary tree with child and sibling <br>// pointers. <br>// <br>// The CTrie template takes three parameters: <br>//      class _TOKEN:        up to you <br>//      bool  fIgnoreCase:   case-sensitivity for searches <br>//      bool  fDeleteTokens: delete _TOKEN* when Flush() called? <br>// and it exposes three methods: <br>//      bool AddToken(ptszToken, _TOKEN*) <br>//      _TOKEN* Search(ptszSearch, pctchMatched = NULL, nMaxLen = 0) <br>//      void Flush() <br>// <br>// Use them like this: <br>//      CTrie&lt;CToken, true, true&gt; trie; <br>//      CToken* ptokHello = new CToken(...); <br>// <br>//      VERIFY(trie.AddToken(_T("Hello"), ptokHello)); <br>// <br>//      CToken* ptok = trie.Search(_T("Goodbye")); <br>//      if (ptok != NULL) {...} <br>// <br>//      if (fIniFileChanged) <br>//      { <br>//          trie.Flush();   // will delete all tokens <br>//          AddTokensFromIniFile(trie); <br>//      } <br>// <br>// Note: If you use DUMP(&amp;trie) or ASSERT_VALID(&amp;trie), your _TOKEN class must <br>// have Dump() or AssertValid() methods, respectively, in its _DEBUG version. <br>// <br>// <br>// TODO: <br>//  * template really ought to be parameterized on ANSI/Unicode too <br>//  * STLify it: add iterators, turn it into a container, etc <br>//  * remove Win32 dependencies (TCHAR) <br>//  * add operator= and copy ctor <br>// <br>// <br>// George V. Reilly  &lt;gvr@halcyon.com&gt;  Oct 1995  Initial implementation <br>// George V. Reilly  &lt;gvr@halcyon.com&gt;  Sep 1996  Add CharPresent for ANSI <br>// George V. Reilly  &lt;gvr@halcyon.com&gt;  Mar 1997  Templatized; removed MFC <br> <br> <br>#ifndef __TRIE_H__ <br>#define __TRIE_H__ <br> <br>#include &lt;tchar.h&gt; <br>#include &lt;limits.h&gt; <br>#include &lt;malloc.h&gt; <br> <br>#include "debug.h" <br> <br>// Workaround for bool being a "reserved extension" in Visual C++ 4.x <br>#if _MSC_VER&lt;1100 <br># ifndef bool <br>#  define bool  BOOL <br># endif <br># ifndef true <br>#  define true  TRUE <br># endif <br># ifndef false <br>#  define false FALSE <br># endif <br>#endif <br> <br> <br>// forward declaration <br>template &lt;class _TOKEN, bool fIgnoreCase, bool fDeleteTokens&gt; class CTrie; <br> <br> <br>//+--------------------------------------------------------------------- <br>//  Class:      CTrieNode (tn) <br>//      one node for each letter <br> <br>template &lt;class _TOKEN, bool fIgnoreCase, bool fDeleteTokens&gt; <br>class CTrieNode <br>{ <br>    friend class CTrie&lt;_TOKEN, fIgnoreCase, fDeleteTokens&gt;; <br>    typedef CTrieNode&lt;_TOKEN, fIgnoreCase, fDeleteTokens&gt; _Node; <br> <br>public: <br>    CTrieNode(); <br> <br>    CTrieNode( <br>        _Node*        pParent, <br>        const _TOKEN* ptok, <br>        const TCHAR   tch, <br>        LPCTSTR       ptszToken); <br> <br>    bool <br>    SetData( <br>        const _TOKEN* ptok, <br>        LPCTSTR       ptszToken); <br> <br>    ~CTrieNode(); <br> <br>protected: <br>    const _Node*  m_pParent; <br>    _Node*        m_pSibling; <br>    _Node*        m_pChild; <br>    const _TOKEN* m_ptok; <br>#ifdef _DEBUG <br>    LPTSTR        m_ptszToken; <br>#endif <br>    const TCHAR   m_tch; <br>    TCHAR         m_tchMaxChild;    // Maximum m_tch of child nodes (1 level) <br> <br>// Diagnostics <br>public: <br>#ifdef _DEBUG <br>    void <br>    AssertValid() const; <br> <br>    virtual void <br>    Dump() const; <br> <br>protected: <br>    bool <br>    CheckNodeToken() const; <br>#endif <br> <br>private: <br>    // private, unimplemented copy ctor and op= to prevent <br>    // compiler synthesizing them <br>    CTrieNode(const CTrieNode&amp;); <br>    CTrieNode&amp; operator=(const CTrieNode&amp;); <br>}; <br> <br> <br> <br>//+--------------------------------------------------------------------- <br>//  Class:      CTrie (trie) <br> <br>template &lt;class _TOKEN, bool fIgnoreCase, bool fDeleteTokens&gt; <br>class CTrie <br>{ <br>    typedef CTrieNode&lt;_TOKEN, fIgnoreCase, fDeleteTokens&gt; _Node; <br> <br>public: <br>    CTrie(); <br> <br>    virtual <br>    ~CTrie(); <br> <br>    virtual bool <br>    AddToken( <br>        LPCTSTR             ptszToken, <br>        const _TOKEN* const ptok); <br> <br>    virtual const _TOKEN* <br>    Search( <br>        LPCTSTR   ptszSearch, <br>        int*      pctchMatched = NULL, <br>        const int nMaxLen = 0) const; <br> <br>    virtual void <br>    Flush(); <br> <br>protected: <br>    _Node  m_tnRoot; <br>    TCHAR  m_tchMinChild; <br>    TCHAR  m_tchMaxChild; <br> <br>    void <br>    _DeleteTrie( <br>        _Node* ptn); <br> <br>#ifndef _UNICODE <br>    // bit array for first letter of all tokens <br>    BYTE  m_afCharPresent[(CHAR_MAX - CHAR_MIN + 1 + 7) / 8]; <br> <br>    bool <br>    _CharPresent( <br>        CHAR ch) const; <br> <br>    void <br>    _SetCharPresent( <br>        CHAR ch, <br>        bool f); <br>#endif // !UNICODE <br> <br> <br>// Diagnostics <br>public: <br>#ifdef _DEBUG <br>    virtual void <br>    AssertValid() const; <br> <br>    virtual void <br>    Dump() const; <br> <br>protected: <br>    int   m_ctchMaxTokenLen;    // length of longest token string <br> <br>    void <br>    _AssertWalk( <br>        _Node* ptn, <br>        LPTSTR ptszName, <br>        int    iLevel) const; <br> <br>    void <br>    _DumpWalk( <br>        _Node* ptn, <br>        LPTSTR ptszName, <br>        int    iLevel, <br>        int&amp;   rcNodes, <br>        int&amp;   rcTokens) const; <br>#endif <br> <br>private: <br>    // private, unimplemented copy ctor and op= to prevent <br>    // compiler synthesizing them <br>    CTrie(const CTrie&amp;); <br>    CTrie&amp; operator=(const CTrie&amp;); <br>}; <br> <br> <br> <br>#ifdef _UNICODE <br># define TCHAR_MIN L'\0' <br>#else // !UNICODE <br># define TCHAR_MIN CHAR_MIN <br>#endif // !UNICODE <br> <br> <br> <br>//----------------------------------------------------------------------------- <br>// CTrieNode implementation <br> <br>// CTrieNode::CTrieNode <br>//      default ctor (needed for CTrie::m_tnRoot) <br> <br>template &lt;class _TOKEN, bool fIgnoreCase, bool fDeleteTokens&gt; <br>CTrieNode&lt;_TOKEN, fIgnoreCase, fDeleteTokens&gt;::CTrieNode() <br>    : m_pParent(NULL), <br>      m_pSibling(NULL), <br>      m_pChild(NULL), <br>      m_ptok(NULL), <br>#ifdef _DEBUG <br>      m_ptszToken(NULL), <br>#endif <br>      m_tch(TCHAR_MIN), <br>      m_tchMaxChild(TCHAR_MIN) <br>{ <br>} <br> <br> <br> <br>// CTrieNode::CTrieNode <br>//      ctor <br> <br>template &lt;class _TOKEN, bool fIgnoreCase, bool fDeleteTokens&gt; <br>CTrieNode&lt;_TOKEN, fIgnoreCase, fDeleteTokens&gt;::CTrieNode( <br>    _Node*        pParent, <br>    const _TOKEN* ptok, <br>    const TCHAR   tch, <br>    LPCTSTR       ptszToken) <br>    : m_pParent(pParent), <br>      m_pSibling(NULL), <br>      m_pChild(NULL), <br>      m_ptok(ptok), <br>#ifdef _DEBUG <br>      m_ptszToken(NULL), <br>#endif <br>      m_tch(tch), <br>      m_tchMaxChild(TCHAR_MIN) <br>{ <br>    ASSERT(m_pParent != NULL); <br>    ASSERT(m_tch &gt; TCHAR_MIN); <br>     <br>    _Node* ptnPrev = NULL; <br>    _Node* ptn = m_pParent-&gt;m_pChild; <br>         <br>    // find where in the list of pParent's children to insert `this' <br>    while (ptn != NULL  &amp;&amp;  ptn-&gt;m_tch &lt; m_tch) <br>    { <br>        ptnPrev = ptn; <br>        ptn = ptn-&gt;m_pSibling; <br>    } <br>     <br>    ASSERT(ptn == NULL  ||  ptn-&gt;m_tch != m_tch); <br>     <br>    if (ptnPrev == NULL) <br>    { <br>        ASSERT(pParent-&gt;m_pChild == ptn); <br>        pParent-&gt;m_pChild = this; <br>    } <br>    else <br>        ptnPrev-&gt;m_pSibling = this; <br> <br>    this-&gt;m_pSibling = ptn; <br> <br>    if (pParent-&gt;m_tchMaxChild &lt; m_tch) <br>        pParent-&gt;m_tchMaxChild = m_tch; <br> <br>#ifdef _DEBUG <br>    if (ptszToken != NULL) <br>    { <br>        ASSERT(m_ptok != NULL); <br>        m_ptszToken = new TCHAR [_tcslen(ptszToken) + 1]; <br>        _tcscpy(m_ptszToken, ptszToken); <br>    } <br>#endif <br>} <br> <br> <br>     <br>// CTrieNode::SetData <br>//      sets the data if it's NULL.  Needed if you do <br>//      AddToken("foobar", &amp;tokFoobar) and then AddToken("foo", &amp;tokFoo) <br>//      to set the data for tokFoo. <br> <br>template &lt;class _TOKEN, bool fIgnoreCase, bool fDeleteTokens&gt; <br>bool <br>CTrieNode&lt;_TOKEN, fIgnoreCase, fDeleteTokens&gt;::SetData( <br>    const _TOKEN* ptok, <br>    LPCTSTR       ptszToken) <br>{ <br>    // Don't set data if ptok is NULL <br>    if (ptok == NULL) <br>        return false; <br>     <br>    // overwrite m_ptok only if it is NULL <br>    if (m_ptok == NULL) <br>    { <br>        m_ptok = ptok; <br>#ifdef _DEBUG <br>        ASSERT(m_ptszToken == NULL); <br>        ASSERT(ptszToken != NULL); <br>        m_ptszToken = new TCHAR [_tcslen(ptszToken) + 1]; <br>        _tcscpy(m_ptszToken, ptszToken); <br>#endif <br>    } <br> <br>    return true; <br>} <br> <br> <br> <br>// CTrieNode::~CTrieNode <br>//      dtor <br> <br>template &lt;class _TOKEN, bool fIgnoreCase, bool fDeleteTokens&gt; <br>CTrieNode&lt;_TOKEN, fIgnoreCase, fDeleteTokens&gt;::~CTrieNode() <br>{ <br>#ifdef _DEBUG <br>    delete [] m_ptszToken; <br>#endif <br> <br>    // Is this an auto-delete trie, i.e., do we take care of deleting <br>    // the _TOKENs? <br>    if (fDeleteTokens) <br>    { <br>        // cast away constness so that delete will work <br>        delete const_cast&lt;_TOKEN*&gt; (m_ptok); <br>    } <br> <br>    ASSERT(m_pChild == NULL); <br>} <br> <br> <br>     <br>//----------------------------------------------------------------------------- <br>// CTrieNode diagnostics <br> <br>#ifdef _DEBUG <br> <br>// CTrieNode::CheckNodeToken <br>//      Do the real work of validating a CTrieNode object <br> <br>template &lt;class _TOKEN, bool fIgnoreCase, bool fDeleteTokens&gt; <br>bool <br>CTrieNode&lt;_TOKEN, fIgnoreCase, fDeleteTokens&gt;::CheckNodeToken() const <br>{ <br>    // If there's no m_ptok, it's automatically valid <br>    if (m_ptok == NULL) <br>        return true; <br> <br>    ASSERT(m_ptszToken != NULL); <br>    const int cLen = _tcslen(m_ptszToken); <br>    const _Node* ptn = this; <br> <br>    ASSERT((m_pChild == NULL  &amp;&amp;  m_tchMaxChild == TCHAR_MIN) <br>           ||  (m_pChild != NULL  &amp;&amp;  m_tchMaxChild &gt; TCHAR_MIN)); <br> <br>    // Walk back up towards CTrie::m_tnRoot <br>    for (int i = cLen;  --i &gt;= 0;  ) <br>    { <br>        ASSERT(ptn != NULL); <br>        ASSERT(ptn-&gt;m_tch != TCHAR_MIN); <br> <br>        const TCHAR tch = (fIgnoreCase <br>                           ? (TCHAR) _totlower(this-&gt;m_ptszToken[i]) <br>                           : this-&gt;m_ptszToken[i]); <br> <br>        if (ptn-&gt;m_tch != tch) <br>            ASSERT(false); <br> <br>        ASSERT(ptn-&gt;m_pParent != NULL  &amp;&amp;  ptn-&gt;m_pParent-&gt;m_pChild != NULL); <br> <br>        const _Node* ptn2; <br> <br>        // check to see if ptn really is a child of its parent <br>        for (ptn2 = ptn-&gt;m_pParent-&gt;m_pChild; <br>             ptn2 != ptn  &amp;&amp;  ptn2 != NULL; <br>             ptn2 = ptn2-&gt;m_pSibling) <br>        {} <br>        ASSERT(ptn2 == ptn); <br> <br>        // check that ptn-&gt;m_pParent-&gt;m_tchMaxChild is correct <br>        for (ptn2 = ptn-&gt;m_pParent-&gt;m_pChild; <br>             ptn2-&gt;m_pSibling != NULL; <br>             ptn2 = ptn2-&gt;m_pSibling) <br>        { <br>            ASSERT(ptn2-&gt;m_tch &gt; TCHAR_MIN <br>                   &amp;&amp;  ptn2-&gt;m_tch &lt; ptn2-&gt;m_pSibling-&gt;m_tch); <br>        } <br>        ASSERT(ptn-&gt;m_pParent-&gt;m_tchMaxChild == ptn2-&gt;m_tch); <br> <br>        ptn = ptn-&gt;m_pParent; <br>        ASSERT(ptn-&gt;m_ptok != this-&gt;m_ptok); <br>    } <br> <br>    // check to see if ptn == CTrie::m_tnRoot <br>    ASSERT(ptn-&gt;m_pParent == NULL  &amp;&amp;  ptn-&gt;m_pSibling == NULL <br>           &amp;&amp;  ptn-&gt;m_tch == TCHAR_MIN  &amp;&amp;  ptn-&gt;m_ptok == NULL); <br> <br>    return true; <br>} <br> <br> <br> <br>// CTrieNode::AssertValid <br>//      Validate a CTrieNode object <br> <br>template &lt;class _TOKEN, bool fIgnoreCase, bool fDeleteTokens&gt; <br>void <br>CTrieNode&lt;_TOKEN, fIgnoreCase, fDeleteTokens&gt;::AssertValid() const <br>{ <br>    ASSERT(CheckNodeToken()); <br>} <br> <br> <br> <br>// CTrieNode::Dump <br>//      Dump a CTrieNode object <br> <br>template &lt;class _TOKEN, bool fIgnoreCase, bool fDeleteTokens&gt; <br>void <br>CTrieNode&lt;_TOKEN, fIgnoreCase, fDeleteTokens&gt;::Dump() const <br>{ <br>    // TODO: flesh out <br>} <br> <br>#endif // _DEBUG <br> <br> <br> <br>//----------------------------------------------------------------------------- <br>// CTrie implementation <br> <br>// CTrie::CTrie <br>//      ctor <br> <br>template &lt;class _TOKEN, bool fIgnoreCase, bool fDeleteTokens&gt; <br>CTrie&lt;_TOKEN, fIgnoreCase, fDeleteTokens&gt;::CTrie() <br>{ <br>    Flush(); <br>} <br> <br> <br> <br>// CTrie::~CTrie <br>//      dtor <br> <br>template &lt;class _TOKEN, bool fIgnoreCase, bool fDeleteTokens&gt; <br>CTrie&lt;_TOKEN, fIgnoreCase, fDeleteTokens&gt;::~CTrie() <br>{ <br>    Flush(); <br>} <br> <br> <br> <br>#ifndef _UNICODE <br> <br>// CTrie::_CharPresent <br> <br>template &lt;class _TOKEN, bool fIgnoreCase, bool fDeleteTokens&gt; <br>inline bool <br>CTrie&lt;_TOKEN, fIgnoreCase, fDeleteTokens&gt;::_CharPresent( <br>    CHAR ch) const <br>{ <br>    ASSERT(CHAR_MIN &lt;= ch  &amp;&amp;  ch &lt;= CHAR_MAX); <br>    const UINT i = ch - CHAR_MIN;   // CHAR_MIN is -128 for `signed char' <br> <br>    return m_afCharPresent[i &gt;&gt; 3] &amp; (1 &lt;&lt; (i &amp; 7))  ?  true  :  false; <br>} <br> <br> <br> <br>// CTrie::_SetCharPresent <br> <br>template &lt;class _TOKEN, bool fIgnoreCase, bool fDeleteTokens&gt; <br>inline void <br>CTrie&lt;_TOKEN, fIgnoreCase, fDeleteTokens&gt;::_SetCharPresent( <br>    CHAR ch, <br>    bool f) <br>{ <br>    ASSERT(CHAR_MIN &lt;= ch  &amp;&amp;  ch &lt;= CHAR_MAX); <br>    const UINT i = ch - CHAR_MIN; <br> <br>    if (f) <br>        m_afCharPresent[i &gt;&gt; 3] |=  (1 &lt;&lt; (i &amp; 7)); <br>    else <br>        m_afCharPresent[i &gt;&gt; 3] &amp;= ~(1 &lt;&lt; (i &amp; 7)); <br>} <br> <br>#endif // !UNICODE <br> <br> <br> <br>// CTrie::AddToken <br>//      Add search string `ptszToken' to trie, which will return `ptok' <br>//      if searched for in Search(). <br> <br>template &lt;class _TOKEN, bool fIgnoreCase, bool fDeleteTokens&gt; <br>bool <br>CTrie&lt;_TOKEN, fIgnoreCase, fDeleteTokens&gt;::AddToken( <br>    LPCTSTR             ptszToken, <br>    const _TOKEN* const ptok) <br>{ <br>    if (ptok == NULL  ||  ptszToken == NULL  ||  *ptszToken == _T('\0')) <br>    { <br>        ASSERT(false); <br>        return false; <br>    } <br> <br>    const int cLen = _tcslen(ptszToken); <br>    _Node* ptnParent = &amp;m_tnRoot; <br>     <br>    for (int i = 0;  i &lt; cLen;  ++i) <br>    { <br>        ASSERT(ptnParent != NULL); <br>         <br>        _Node* ptn = ptnParent-&gt;m_pChild; <br>        const TCHAR tch = (fIgnoreCase <br>                           ? (TCHAR) _totlower(ptszToken[i]) <br>                           : ptszToken[i]); <br>        const _TOKEN* ptok2 = (i == cLen - 1)  ?  ptok       :  NULL; <br>        LPCTSTR ptsz2 =       (i == cLen - 1)  ?  ptszToken  :  NULL; <br> <br>        while (ptn != NULL  &amp;&amp;  ptn-&gt;m_tch &lt; tch) <br>            ptn = ptn-&gt;m_pSibling; <br>             <br>        if (ptn == NULL  ||  ptn-&gt;m_tch &gt; tch) <br>        { <br>            ptnParent = new _Node(ptnParent, ptok2, tch, ptsz2); <br>        } <br>        else <br>        { <br>            ASSERT(ptn-&gt;m_tch == tch); <br>             <br>            ptn-&gt;SetData(ptok2, ptsz2); <br>            ptnParent = ptn; <br>        } <br> <br>        ASSERT(ptnParent-&gt;CheckNodeToken()); <br>    } <br> <br>    m_tchMinChild = m_tnRoot.m_pChild-&gt;m_tch; <br>    m_tchMaxChild = m_tnRoot.m_tchMaxChild; <br>#ifdef _DEBUG <br>    m_ctchMaxTokenLen = max(m_ctchMaxTokenLen, cLen); <br>#endif <br> <br>    ASSERT(TCHAR_MIN &lt; m_tchMinChild  &amp;&amp;  m_tchMinChild &lt;= m_tchMaxChild); <br> <br>#ifndef _UNICODE <br>    // Keep a map of the initial letter of each token, to speed up searches <br>    if (fIgnoreCase) <br>    { <br>        _SetCharPresent(tolower(ptszToken[0]), true); <br>        _SetCharPresent(toupper(ptszToken[0]), true); <br>    } <br>    else <br>        _SetCharPresent(ptszToken[0], true); <br>#endif // !UNICODE <br> <br>#ifdef _DEBUG <br>    int nTemp; <br>    const _TOKEN* ptok2 = Search(ptszToken, &amp;nTemp); <br> <br>    ASSERT(ptok2 == ptok  &amp;&amp;  nTemp == cLen); <br>#endif // _DEBUG <br> <br>    return true; <br>} <br> <br> <br> <br>// CTrie::Search <br>//      Search trie for `ptszSearch', returning count of characters <br>//      matched in `pctchMatched' (if non-NULL), matching at most `nMaxLen' <br>//      characters, if nMaxLen != 0, or _tcslen(ptszSearch) otherwise. <br> <br>template &lt;class _TOKEN, bool fIgnoreCase, bool fDeleteTokens&gt; <br>const _TOKEN* <br>CTrie&lt;_TOKEN, fIgnoreCase, fDeleteTokens&gt;::Search( <br>    LPCTSTR   ptszSearch, <br>    int*      pctchMatched /* = NULL */, <br>    const int nMaxLen /* = 0 */) const <br>{ <br>    // Set count of matched characters <br>    if (pctchMatched != NULL) <br>        *pctchMatched = 0; <br> <br>#ifndef _UNICODE <br>    if (! _CharPresent(ptszSearch[0])) <br>        return NULL; <br> <br>    TCHAR tch; <br>#else    // UNICODE <br>    TCHAR tch = fIgnoreCase ? (TCHAR) _totlower(ptszSearch[0]) : ptszSearch[0]; <br> <br>    if (tch &lt; m_tchMinChild  ||  m_tchMaxChild &lt; tch) <br>        return NULL; <br>#endif // UNICODE <br> <br>    // For some uses (e.g., ptszSearch is not '\0'-terminated), nMaxLen is <br>    // specified.  If it's not specified, use the length of the string. <br>    const int cLen = (nMaxLen != 0)  ?  nMaxLen  :  _tcslen(ptszSearch); <br>    ASSERT(0 &lt; cLen); <br> <br>    bool fOvershot = true; <br>    const _Node* ptnParent = &amp;m_tnRoot; <br>    const _Node* ptn = NULL; <br>    int i; <br> <br>    // Find the longest approximate match.  For example, if we have "foo" <br>    // and "foobar" in the trie and we're asked to match "fool", we'll work <br>    // our way down to "foob", then backtrack up to "foo". <br> <br>    for (i = 0;  i &lt; cLen;  ++i) <br>    { <br>        ASSERT(ptnParent != NULL); <br> <br>        ptn = ptnParent-&gt;m_pChild; <br>        ASSERT(ptn != NULL  &amp;&amp;  ptn-&gt;m_pParent == ptnParent); <br> <br>        tch = fIgnoreCase ? (TCHAR) _totlower(ptszSearch[i]) : ptszSearch[i]; <br>        ASSERT(tch &gt;= TCHAR_MIN); <br> <br>        if (ptnParent-&gt;m_tchMaxChild &lt; tch) <br>        { <br>            ASSERT(i &gt; 0); <br>            break; <br>        } <br>         <br>        while (ptn != NULL  &amp;&amp;  ptn-&gt;m_tch &lt; tch) <br>            ptn = ptn-&gt;m_pSibling; <br> <br>        // failed to match? <br>        if (ptn == NULL  ||  ptn-&gt;m_tch &gt; tch) <br>        { <br>            ASSERT(ptn == NULL  ||  ptn-&gt;m_tch &lt;= ptnParent-&gt;m_tchMaxChild); <br>             <br>            if (i == 0) <br>                return NULL; <br>            break; <br>        } <br>        else <br>        { <br>            ASSERT(ptn-&gt;m_tch == tch); <br>            ASSERT(ptn-&gt;m_pParent-&gt;m_tchMaxChild &gt;= tch); <br> <br>            if (ptn-&gt;m_pChild == NULL) <br>            { <br>                ASSERT(ptn-&gt;m_ptok != NULL); <br>                fOvershot = false; <br>                break; <br>            } <br> <br>            ptnParent = ptn; <br>        } <br>    } <br> <br>    if (fOvershot) <br>    { <br>        --i;  ptn = ptnParent;  // back up one character <br>    } <br>    else <br>        ASSERT(ptn-&gt;m_pChild == NULL); <br> <br>    ASSERT(0 &lt;= i  &amp;&amp;  i &lt; cLen); <br>    ASSERT(ptn != NULL  &amp;&amp;  ptn != &amp;m_tnRoot); <br>     <br>    // we've found an approximate match; backtrack until we find an exact match <br>    do <br>    { <br>        ASSERT(ptn != NULL); <br>        ASSERT(ptn-&gt;m_tch == (fIgnoreCase <br>                              ? (TCHAR) _totlower(ptszSearch[i]) <br>                              : ptszSearch[i])); <br>        ASSERT(ptn-&gt;CheckNodeToken()); <br>         <br>        const _TOKEN* const ptok = ptn-&gt;m_ptok; <br> <br>        if (ptok != NULL) <br>        { <br>            ASSERT(i == (int) _tcslen(ptn-&gt;m_ptszToken) - 1); <br> <br>            if (pctchMatched != NULL) <br>                *pctchMatched = i+1; <br> <br>            return ptok; <br>        } <br> <br>        ptn = ptn-&gt;m_pParent; <br>    } while (--i &gt;= 0); <br> <br>    return NULL; <br>} <br> <br> <br> <br>// CTrie::Flush <br>//      flush all nodes leaving an empty trie <br> <br>template &lt;class _TOKEN, bool fIgnoreCase, bool fDeleteTokens&gt; <br>void <br>CTrie&lt;_TOKEN, fIgnoreCase, fDeleteTokens&gt;::Flush() <br>{ <br>    if (m_tnRoot.m_pChild != NULL) <br>        _DeleteTrie(m_tnRoot.m_pChild); <br> <br>    m_tnRoot.m_pChild = NULL;  // or ~CTrieNode will ASSERT <br>    m_tnRoot.m_tchMaxChild = TCHAR_MIN; <br> <br>    m_tchMinChild = m_tchMaxChild = TCHAR_MIN; <br>#ifdef _DEBUG <br>    m_ctchMaxTokenLen = 0; <br>#endif <br>#ifndef _UNICODE <br>    memset(m_afCharPresent, 0, sizeof(m_afCharPresent)); <br>#endif <br>} <br> <br> <br> <br>// CTrie::_DeleteTrie <br>//      recursively delete a subtrie <br> <br>template &lt;class _TOKEN, bool fIgnoreCase, bool fDeleteTokens&gt; <br>void <br>CTrie&lt;_TOKEN, fIgnoreCase, fDeleteTokens&gt;::_DeleteTrie( <br>    _Node* ptn) <br>{ <br>    if (ptn == NULL) <br>    { <br>        ASSERT(false); <br>        return; <br>    } <br>     <br>    do <br>    { <br>        if (ptn-&gt;m_pChild != NULL) <br>        { <br>            _DeleteTrie(ptn-&gt;m_pChild); <br>            ptn-&gt;m_pChild = NULL;   // or ~CTrieNode will ASSERT <br>        } <br> <br>        _Node* ptnSibling = ptn-&gt;m_pSibling; <br>        delete ptn; <br>        ptn = ptnSibling;   // tail recursion <br>    } while (ptn != NULL); <br>} <br> <br> <br> <br>//----------------------------------------------------------------------------- <br>// CTrie diagnostics <br> <br>#ifdef _DEBUG <br> <br>// CTrie::AssertValid <br> <br>template &lt;class _TOKEN, bool fIgnoreCase, bool fDeleteTokens&gt; <br>void <br>CTrie&lt;_TOKEN, fIgnoreCase, fDeleteTokens&gt;::AssertValid() const <br>{ <br>    TCHAR* ptszName = static_cast&lt;TCHAR*&gt; <br>                        (_alloca(sizeof(TCHAR) * (m_ctchMaxTokenLen+1))); <br>    *ptszName = _T('\0'); <br> <br>    ASSERT_VALID(&amp;m_tnRoot); <br>    ASSERT(m_tnRoot.m_tchMaxChild == m_tchMaxChild); <br> <br>    if (m_tnRoot.m_pChild != NULL) <br>    { <br>        ASSERT(m_tchMinChild == m_tnRoot.m_pChild-&gt;m_tch); <br>        ASSERT(m_ctchMaxTokenLen &gt; 0); <br>        _AssertWalk(m_tnRoot.m_pChild, ptszName, 0); <br>    } <br>    else <br>    { <br>        ASSERT(m_tchMinChild == TCHAR_MIN &amp;&amp; m_tchMinChild == m_tchMaxChild); <br>        ASSERT(m_ctchMaxTokenLen == 0); <br>    } <br>} <br> <br> <br> <br>// CTrie::_AssertWalk <br>//      recursively validate a subtrie <br> <br>template &lt;class _TOKEN, bool fIgnoreCase, bool fDeleteTokens&gt; <br>void <br>CTrie&lt;_TOKEN, fIgnoreCase, fDeleteTokens&gt;::_AssertWalk( <br>    _Node* ptn, <br>    LPTSTR ptszName, <br>    int    iLevel) const <br>{ <br>    ASSERT(iLevel &lt; m_ctchMaxTokenLen); <br>     <br>    do <br>    { <br>        ASSERT_VALID(ptn); <br>         <br>        ptszName[iLevel] = ptn-&gt;m_tch; <br>        ptszName[iLevel+1] = _T('\0'); <br> <br>        if (ptn-&gt;m_ptok != NULL) <br>        { <br>            ASSERT(ptn-&gt;m_ptszToken != NULL); <br>            if (fIgnoreCase) <br>                ASSERT(_tcsicmp(ptszName, ptn-&gt;m_ptszToken) == 0); <br>            else <br>                ASSERT(_tcscmp(ptszName, ptn-&gt;m_ptszToken) == 0); <br>            ASSERT_VALID(ptn-&gt;m_ptok); <br>        } <br>         <br>        if (ptn-&gt;m_pChild != NULL) <br>            _AssertWalk(ptn-&gt;m_pChild, ptszName, iLevel+1); <br> <br>        ptn = ptn-&gt;m_pSibling;   // tail recursion <br>    } while (ptn != NULL); <br>} <br> <br> <br> <br>// CTrie::Dump <br> <br>template &lt;class _TOKEN, bool fIgnoreCase, bool fDeleteTokens&gt; <br>void <br>CTrie&lt;_TOKEN, fIgnoreCase, fDeleteTokens&gt;::Dump() const <br>{ <br>    int cNodes = 0, cTokens = 0; <br>    TCHAR* ptszName = static_cast&lt;TCHAR*&gt; <br>                        (_alloca(sizeof(TCHAR) * (m_ctchMaxTokenLen+1))); <br>    *ptszName = _T('\0'); <br> <br>    TRACE0("Dumping trie...\n"); <br> <br>    if (m_tnRoot.m_pChild != NULL) <br>        _DumpWalk(m_tnRoot.m_pChild, ptszName, 0, cNodes, cTokens); <br> <br>    TRACE2("%d nodes, %d tokens\n", cNodes, cTokens); <br>} <br> <br> <br> <br>// CTrie::_DumpWalk <br>//      recursively dump a subtrie <br> <br>template &lt;class _TOKEN, bool fIgnoreCase, bool fDeleteTokens&gt; <br>void <br>CTrie&lt;_TOKEN, fIgnoreCase, fDeleteTokens&gt;::_DumpWalk( <br>    _Node* ptn, <br>    LPTSTR ptszName, <br>    int    iLevel, <br>    int&amp;   rcNodes, <br>    int&amp;   rcTokens) const <br>{ <br>    ASSERT(iLevel &lt; m_ctchMaxTokenLen); <br> <br>    do <br>    { <br>        ASSERT_VALID(ptn); <br>         <br>        ++rcNodes; <br>        ptszName[iLevel] = ptn-&gt;m_tch; <br>        ptszName[iLevel+1] = _T('\0'); <br> <br>        if (ptn-&gt;m_ptok != NULL) <br>        { <br>            ++rcTokens; <br>            ASSERT(ptn-&gt;m_ptszToken != NULL); <br>            TRACE2("\t%s (%s): ", ptszName, ptn-&gt;m_ptszToken); <br>            DUMP(ptn-&gt;m_ptok); <br>            TRACE0("\n"); <br>        } <br>         <br>        if (ptn-&gt;m_pChild != NULL) <br>            _DumpWalk(ptn-&gt;m_pChild, ptszName, iLevel+1, rcNodes, rcTokens); <br> <br>        ptn = ptn-&gt;m_pSibling;   // tail recursion <br>    } while (ptn != NULL); <br>} <br> <br>#endif // _DEBUG <br> <br>#endif // __TRIE_H__ </code></pre>
<p>&nbsp;</p></body>
</HTML>
