<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>AUTHFILT.C</title>
<link disabled rel=stylesheet href=../../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context4197"></a>AUTHFILT.C</h2>
<pre><code>/*++ <br> <br>Copyright (c) 1996  Microsoft Corporation <br> <br>This program is released into the public domain for any purpose. <br> <br> <br>Module Name: <br> <br>    authfilt.c <br> <br>Abstract: <br> <br>    This module is an example of an ISAPI Authentication Filter. <br> <br>    It demonstrates how to do an authentication filter based on an external <br>    datasource.  Though this sample uses a flat file, access to a database <br>    could easily be plugged in. <br> <br>--*/ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;httpfilt.h&gt; <br>#include "authfilt.h" <br> <br>// <br>// Functions <br>// <br> <br>BOOL <br>WINAPI <br>DllMain( <br>     IN HINSTANCE hinstDll, <br>     IN DWORD     fdwReason, <br>     IN LPVOID    lpvContext OPTIONAL <br>     ) <br>/*++ <br> <br> Routine Description: <br> <br>   This function DllLibMain() is the main initialization function for <br>    this DLL. It initializes local variables and prepares it to be invoked <br>    subsequently. <br> <br> Arguments: <br> <br>   hinstDll          Instance Handle of the DLL <br>   fdwReason         Reason why NT called this DLL <br>   lpvReserved       Reserved parameter for future use. <br> <br> Return Value: <br> <br>    Returns TRUE is successful; otherwise FALSE is returned. <br>--*/ <br>{ <br>    BOOL        fReturn = TRUE; <br> <br>    switch (fdwReason ) <br>    { <br>    case DLL_PROCESS_ATTACH: <br> <br>        if ( !InitializeUserDatabase() || <br>             !InitializeCache() ) <br>        { <br>            DbgWrite(( DEST, <br>                       "[GetFilterVersion] Database or cache failed, error %d\n", <br>                       GetLastError() )) <br> <br>            return FALSE; <br>        } <br> <br>        // <br>        //  We don't care about thread attach/detach notifications <br>        // <br> <br>        DisableThreadLibraryCalls( hinstDll ); <br> <br>        break; <br> <br>    case DLL_PROCESS_DETACH: <br>        { <br> <br>            if ( lpvContext != NULL) <br>            { <br>                TerminateCache(); <br>                TerminateUserDatabase(); <br>            } <br> <br>            break; <br>        } /* case DLL_PROCESS_DETACH */ <br> <br>    default: <br>        break; <br>    }   /* switch */ <br> <br>    return ( fReturn); <br>}  /* DllLibMain() */ <br> <br> <br> <br>BOOL <br>WINAPI <br>GetFilterVersion( <br>    HTTP_FILTER_VERSION * pVer <br>    ) <br>{ <br>    DbgWrite(( DEST, <br>               "[GetFilterVersion] Server filter version is %d.%d\n", <br>               HIWORD( pVer-&gt;dwServerFilterVersion ), <br>               LOWORD( pVer-&gt;dwServerFilterVersion ) )); <br> <br>    pVer-&gt;dwFilterVersion = HTTP_FILTER_REVISION; <br> <br>    // <br>    //  Specify the types and order of notification <br>    // <br> <br>    pVer-&gt;dwFlags = (SF_NOTIFY_SECURE_PORT        | <br>                     SF_NOTIFY_NONSECURE_PORT     | <br> <br>                     SF_NOTIFY_AUTHENTICATION     | <br>                     SF_NOTIFY_LOG                | <br> <br>                     SF_NOTIFY_ORDER_DEFAULT); <br> <br>    strcpy( pVer-&gt;lpszFilterDesc, "Sample Authentication Filter, version 1.0" ); <br> <br>    return TRUE; <br>} <br> <br>DWORD <br>WINAPI <br>HttpFilterProc( <br>    HTTP_FILTER_CONTEXT *      pfc, <br>    DWORD                      NotificationType, <br>    VOID *                     pvData <br>    ) <br>/*++ <br> <br>Routine Description: <br> <br>    Filter notification entry point <br> <br>Arguments: <br> <br>    pfc -              Filter context <br>    NotificationType - Type of notification <br>    pvData -           Notification specific data <br> <br>Return Value: <br> <br>    One of the SF_STATUS response codes <br> <br>--*/ <br>{ <br>    BOOL                  fAllowed; <br>    CHAR                  achUser[SF_MAX_USERNAME]; <br>    HTTP_FILTER_AUTHENT * pAuth; <br>    HTTP_FILTER_LOG *     pLog; <br>    CHAR *                pch; <br> <br>    // <br>    //  Handle this notification <br>    // <br> <br>    switch ( NotificationType ) <br>    { <br>    case SF_NOTIFY_AUTHENTICATION: <br> <br>        pAuth = (HTTP_FILTER_AUTHENT *) pvData; <br> <br>        // <br>        //  Ignore the anonymous user <br>        // <br> <br>        if ( !*pAuth-&gt;pszUser ) <br>        { <br>            // <br>            //  Tell the server to notify any subsequent notifications in the <br>            //  chain <br>            // <br> <br>            return SF_STATUS_REQ_NEXT_NOTIFICATION; <br>        } <br> <br>        // <br>        //  Save the unmapped username so we can log it later <br>        // <br> <br>        strcpy( achUser, pAuth-&gt;pszUser ); <br> <br>        // <br>        //  Make sure this user is a valid user and map to the appropriate <br>        //  Windows NT user <br>        // <br> <br>        if ( !ValidateUser( pAuth-&gt;pszUser, <br>                            pAuth-&gt;pszPassword, <br>                            &amp;fAllowed )) <br>        { <br>            DbgWrite(( DEST, <br>                       "[OnAuthentication] Error %d validating user %s\n", <br>                       GetLastError(), <br>                       pAuth-&gt;pszUser )); <br> <br>            return SF_STATUS_REQ_ERROR; <br>        } <br> <br>        if ( !fAllowed ) <br>        { <br>            // <br>            //  This user isn't allowed access.  Indicate this to the server <br>            // <br> <br>            SetLastError( ERROR_ACCESS_DENIED ); <br> <br>            return SF_STATUS_REQ_ERROR; <br>        } <br> <br>        // <br>        //  Save the unmapped user name so we can log it later on.  We allocate <br>        //  enough space for two usernames so we can use this memory block <br>        //  for logging.  Note we may have already allocated it from a previous <br>        //  request on this TCP session <br>        // <br> <br>        if ( !pfc-&gt;pFilterContext ) <br>        { <br>            pfc-&gt;pFilterContext = pfc-&gt;AllocMem( pfc, 2 * SF_MAX_USERNAME + 4, 0 ); <br> <br>            if ( !pfc-&gt;pFilterContext ) <br>            { <br>                SetLastError( ERROR_NOT_ENOUGH_MEMORY ); <br>                return SF_STATUS_REQ_ERROR; <br>            } <br>        } <br> <br>        strcpy( (CHAR *) pfc-&gt;pFilterContext, achUser ); <br> <br>        return SF_STATUS_REQ_HANDLED_NOTIFICATION; <br> <br>    case SF_NOTIFY_LOG: <br> <br>        // <br>        //  The unmapped username is in pFilterContext if this filter <br>        //  authenticated this user <br>        // <br> <br>        if ( pfc-&gt;pFilterContext ) <br>        { <br>            pch  = pfc-&gt;pFilterContext; <br>            pLog = (HTTP_FILTER_LOG *) pvData; <br> <br>            // <br>            //  Put both the original username and the NT mapped username <br>            //  into the log in the form "Original User (NT User)" <br>            // <br> <br>            strcat( pch, " (" ); <br>            strcat( pch, pLog-&gt;pszClientUserName ); <br>            strcat( pch, ")" ); <br> <br>            pLog-&gt;pszClientUserName = pch; <br>        } <br> <br>        return SF_STATUS_REQ_NEXT_NOTIFICATION; <br> <br>    default: <br>        DbgWrite(( DEST, <br>                "[HttpFilterProc] Unknown notification type, %d\n", <br>                NotificationType )); <br> <br>        break; <br>    } <br> <br>    return SF_STATUS_REQ_NEXT_NOTIFICATION; <br>} <br> <br> <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
