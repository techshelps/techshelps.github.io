<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CTETEST.C</title>
<link disabled rel=stylesheet href=../../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context4160"></a>CTETEST.C</h2>
<pre><code>/*++ <br> <br>Copyright (c) 1997  Microsoft Corporation <br> <br>Module Name:    ctetest.c <br> <br>Abstract: <br> <br>    ISAPI Extension sample illustrating Chunked Transfer Encoding.  <br> <br>--*/ <br> <br>#include "ctetest.h" <br> <br>// <br>// if chunksize= is not specified, use this value <br>// <br> <br>#define DEFAULT_CHUNK_SIZE 1024 <br> <br> <br>// <br>// auxiliary functions prototypes <br>// <br> <br>static BOOL SendChunkedFile( EXTENSION_CONTROL_BLOCK *, DWORD, LPCSTR ); <br>static BOOL SendHttpHeaders( EXTENSION_CONTROL_BLOCK *, LPCSTR, LPCSTR, BOOL ); <br>static BOOL GetFileMimeType( LPCSTR, LPSTR, DWORD );  <br>static BOOL GetQueryStringField( LPCSTR, LPCSTR, LPSTR, DWORD ); <br>static void DisplayExampleUsage( EXTENSION_CONTROL_BLOCK * ); <br> <br> <br>  <br>DWORD WINAPI <br>HttpExtensionProc( <br>    IN EXTENSION_CONTROL_BLOCK *pECB <br>) <br>/*++ <br> <br>Purpose: <br> <br>    Illustrate chunk transfer encoding in ISAPI HTTP Extension DLL. <br>    Process "GET" requests that specify a filename and transfer  <br>    chunk size. <br> <br>Arguments: <br> <br>    pECB - pointer to the extenstion control block  <br> <br>Returns: <br> <br>    HSE_STATUS_SUCCESS on successful transmission completion <br>    HSE_STATUS_ERROR on failure <br> <br>--*/ <br>{ <br>    DWORD dwChunksize = 0; <br>    char szPath[MAX_PATH]; <br>    char szHeaders[1024]; <br>    DWORD cchPath, cchHeaders; <br>    char szChunkSize[32]; <br> <br>    // <br>    // if request method is not "GET", bail out <br>    // <br>     <br>    if( _stricmp( pECB-&gt;lpszMethod, "GET" ) != 0 ) { <br>    return HSE_STATUS_ERROR; <br>    }     <br>     <br>    // <br>    // process chunksize= query argument, if any <br>    // <br>     <br>    if( GetQueryStringField( pECB-&gt;lpszQueryString, "chunksize",  <br>            szChunkSize, sizeof szChunkSize )) { <br>        dwChunksize = atoi( szChunkSize ); <br>    } <br>     <br>    if( dwChunksize == 0 ) { <br>    dwChunksize = DEFAULT_CHUNK_SIZE; <br>}     <br> <br>    // <br>    // process file= query argument <br>    // <br> <br>    cchPath = sizeof szPath; <br>    if( !GetQueryStringField(  <br>            pECB-&gt;lpszQueryString,  <br>            "file",  <br>            szPath,  <br>            cchPath )) { <br> <br>        //  <br>        // no file specified - display usage and report success <br>        // <br>         <br>        DisplayExampleUsage( pECB ); <br> <br>        return HSE_STATUS_SUCCESS; <br>    } <br> <br>    // <br>    // use ServerSupportFunction to map virtual file name to local <br>    // path (otherwise users get access to any file on the system) <br>    // <br> <br>    if( !pECB-&gt;ServerSupportFunction( <br>             pECB-&gt;ConnID, <br>             HSE_REQ_MAP_URL_TO_PATH, <br>             szPath, <br>             &amp;cchPath, <br>             NULL ) ) { <br> <br>        return HSE_STATUS_ERROR; <br>    } <br> <br>    // <br>    // see if we can get file attributes, report error if not <br>    // <br> <br>    if( GetFileAttributes( szPath ) == 0xFFFFFFFF ) { <br> <br>        return HSE_STATUS_ERROR; <br>    } <br> <br>    // <br>    // begin preparing the headers <br>    // <br>     <br>    strcpy( szHeaders, "Transfer-encoding: chunked\r\nContent-type: " ); <br> <br>    // <br>    // obtain MIME type for this file and append it to the headers <br>    // <br> <br>    cchHeaders = strlen( szHeaders ); <br>    GetFileMimeType(  <br>        szPath,  <br>        szHeaders + cchHeaders,  <br>        sizeof szHeaders - cchHeaders  <br>        ); <br> <br>    // <br>    // terminate headers with empty line <br>    // <br> <br>    strcat( szHeaders, "\r\n\r\n" ); <br> <br>    // <br>    // try sending headers to the client <br>    // <br> <br>    if( !SendHttpHeaders( pECB, "200 OK", szHeaders, TRUE ) ) { <br> <br>        return HSE_STATUS_ERROR; <br>    } <br> <br>    // <br>    // try sending the file using CTE encoding <br>    // <br> <br>    if( !SendChunkedFile( pECB, dwChunksize, szPath ) ) { <br> <br>        return HSE_STATUS_ERROR; <br>    }     <br>     <br>    return HSE_STATUS_SUCCESS; <br>} <br> <br>  <br>BOOL WINAPI <br>GetExtensionVersion( <br>    OUT HSE_VERSION_INFO *pVer <br>) <br>/*++ <br> <br>Purpose: <br> <br>    This is required ISAPI Extension DLL entry point. <br> <br>Arguments: <br> <br>    pVer - poins to extension version info structure  <br> <br>Returns: <br> <br>    always returns TRUE <br> <br>--*/ <br>{ <br> <br>    // <br>    // tell the server our version number and extension description <br>    // <br> <br>    pVer-&gt;dwExtensionVersion = <br>        MAKELONG( HSE_VERSION_MINOR, HSE_VERSION_MAJOR ); <br> <br>    lstrcpyn( <br>        pVer-&gt;lpszExtensionDesc,  <br>        "ISAPI CTE test", <br>        HSE_MAX_EXT_DLL_NAME_LEN); <br> <br>    return TRUE; <br>} <br> <br>  <br>BOOL WINAPI <br>TerminateExtension( <br>    DWORD dwFlags <br>) <br>/*++ <br> <br>Purpose: <br> <br>    This is optional ISAPI extension DLL entry point. <br>    If present, it will be called before unloading the DLL, <br>    giving it a chance to perform any shutdown procedures. <br>     <br>Arguments: <br>     <br>    dwFlags - specifies whether the DLL can refuse to unload or not <br>     <br>Returns: <br>     <br>    TRUE, if the DLL can be unloaded <br>     <br>--*/ <br>{ <br>    return TRUE; <br>} <br> <br> <br>  <br>BOOL WINAPI <br>DllMain ( <br>    IN HINSTANCE hInstance, <br>    IN DWORD fdwReason, <br>    IN LPVOID lpvReserved     <br>) <br>/*++ <br> <br>Purpose: <br> <br>    Perform any required DLL initialization here. <br> <br>Returns: <br> <br>    TRUE if DLL was successfully initialized <br>    FALSE otherwise <br> <br>--*/ <br>{ <br> <br>    // <br>    // Nothing needs to be done. This function exists a template. <br>    // <br> <br>    return TRUE; <br>} <br> <br>  <br>static BOOL  <br>SendChunkedFile(  <br>    EXTENSION_CONTROL_BLOCK *pECB,  <br>    DWORD dwChunkSize, <br>    LPCSTR pszPath <br>) <br>/*++ <br> <br>Purpose: <br> <br>    Transfer the specified file using chunked encoding. <br> <br>    Illustrates the usage of CteBeginWrite(), CteWrite() and <br>    CteEndWrite() functions. <br> <br> <br>Arguments: <br> <br>    pECB - pointer to extenstion control block  <br>    dwChunkSize - chunk size for transfer encoding <br>    pszPath - local file path <br> <br>Returns: <br> <br>    TRUE if the file was successfully transfered, <br>    FALSE otherwise <br>     <br>--*/ <br>{ <br>    HANDLE hFile; <br>    HCTE_ENCODER hCteWrite; <br>    BOOL fSuccess = FALSE; <br> <br>    // <br>    // try accessing file <br>    // <br> <br>    hFile = CreateFile( <br>                pszPath,  <br>                GENERIC_READ,  <br>                FILE_SHARE_READ, <br>                NULL, <br>                OPEN_EXISTING, <br>                FILE_FLAG_SEQUENTIAL_SCAN, <br>                NULL); <br> <br>    if( hFile != INVALID_HANDLE_VALUE ) { <br>        BYTE buf[4096]; <br>        DWORD cbread; <br> <br>        // <br>        // prepare chunk transfer encoder <br>        // <br> <br>        hCteWrite = CteBeginWrite( pECB, dwChunkSize ); <br>        if ( hCteWrite ) { <br>         <br>            for( ;; ) { <br> <br>                if( !ReadFile( hFile, buf, sizeof buf, &amp;cbread, NULL ) ) { <br>                     <br>                    // <br>                    // if ReadFile fails, break out of loop and cause  <br>                    // the function to return FALSE (failure) <br>                    // <br>                     <br>                    break; <br>                } <br>             <br>                if( cbread == 0 ) { <br>                 <br>                    // <br>                    // ReadFile succeded, but read 0 bytes - <br>                    // we've achieved EOF and everything is transmitted. <br>                    // break out and return success! <br>                    // <br>                     <br>                    fSuccess = TRUE; <br>                    break; <br>                } <br> <br>                // <br>                // transmit one buffer full of data, <br>                // <br>                 <br>                if( !CteWrite( hCteWrite, buf, cbread ) ) { <br>                 <br>                    // <br>                    // CteWrite failed - break out and return FALSE <br>                    // <br>                     <br>                    break; <br>                }                 <br>            } <br> <br>            // <br>            // finish transfer and release encoder context <br>            // <br>             <br>            if( !CteEndWrite( hCteWrite ) ) { <br>             <br>                fSuccess = FALSE; <br>            } <br>        } <br> <br>        CloseHandle( hFile ); <br>    } <br> <br>    return fSuccess; <br>} <br> <br> <br>  <br>static BOOL  <br>SendHttpHeaders(  <br>    EXTENSION_CONTROL_BLOCK *pECB,  <br>    LPCSTR pszStatus, <br>    LPCSTR pszHeaders, <br>    BOOL fKeepConn <br>) <br>/*++ <br> <br>Purpose: <br>    Send specified HTTP status string and any additional header strings <br>    using new ServerSupportFunction() request HSE_SEND_HEADER_EX_INFO <br> <br>Arguments: <br> <br>    pECB - pointer to the extension control block <br>    pszStatus - HTTP status string (e.g. "200 OK") <br>    pszHeaders - any additional headers, separated by CRLFs and  <br>                 terminated by empty line <br>    fKeepConn - specifies whether to keep TCP connection open or close it <br>                after request is processed. <br> <br>Returns: <br> <br>    TRUE if headers were successfully sent <br>    FALSE otherwise <br> <br>--*/ <br>{ <br>    HSE_SEND_HEADER_EX_INFO header_ex_info; <br>    BOOL success; <br> <br>    header_ex_info.pszStatus = pszStatus; <br>    header_ex_info.pszHeader = pszHeaders; <br>    header_ex_info.cchStatus = strlen( pszStatus ); <br>    header_ex_info.cchHeader = strlen( pszHeaders ); <br>    header_ex_info.fKeepConn = fKeepConn; <br> <br> <br>    success = pECB-&gt;ServerSupportFunction( <br>                  pECB-&gt;ConnID, <br>                  HSE_REQ_SEND_RESPONSE_HEADER_EX, <br>                  &amp;header_ex_info, <br>                  NULL, <br>                  NULL <br>                  ); <br> <br>    return success; <br>} <br> <br> <br>  <br>static BOOL  <br>GetFileMimeType(  <br>    LPCSTR pszPath,  <br>    LPSTR pszType,  <br>    DWORD cbMax  <br>) <br>/*++ <br> <br>Purpose: <br> <br>    Given the file name, obtain MIME type for "Content-type:" header field. <br>    We try to find MIME type string under HCR\.xyz key, "Content Type" value. <br>    If that fails, we return default "application/ocetet-stream". <br> <br>Arguments: <br>     <br>    pszPath - file path <br>    pszType - points to the buffer that will receive MIME type string <br>    cbMax - specifies the maximum number of characters to copy to the buffer, <br>            including the NUL character. If the text exceed this limit, it <br>            will be truncated. <br> <br>Returns: <br> <br>    TRUE, because we can always use default MIME type. <br>   <br>--*/ <br>{ <br>    LPSTR pszExt; <br>    HKEY hKey; <br>    DWORD value_type; <br>    LONG result; <br> <br> <br>    // <br>    // set MIME type to empty string <br>    // <br> <br>    *pszType = '\0'; <br> <br> <br>    // <br>    // try to locate file extension <br>    // <br> <br>    pszExt = strrchr( pszPath, '.' ); <br>     <br>    if( pszExt != NULL ) { <br>     <br>        //  <br>        // for file extension .xyz, MIME Type can be found <br>        // HKEY_CLASSES_ROOT\.xyz key in the registry <br>        // <br> <br>        result = RegOpenKeyEx(  <br>                     HKEY_CLASSES_ROOT,  <br>                     pszExt,  <br>                     0L,  <br>                     KEY_READ,  <br>                     &amp;hKey  <br>                     ); <br>                      <br>        if( result == ERROR_SUCCESS) { <br>         <br>            // <br>            // we sucessfully opened the key. <br>            // try getting the "Content Type" value <br>            // <br>             <br>            result = RegQueryValueEx(  <br>                         hKey,  <br>                     "Content Type",  <br>                     NULL,  <br>                     &amp;value_type,  <br>                     (BYTE *)pszType,  <br>                     &amp;cbMax ); <br> <br>            // <br>            // if we failed to get the value or it is not string, <br>            // clear content-type field <br>            // <br>             <br>            if( result != ERROR_SUCCESS || value_type != REG_SZ ) { <br>                *pszType = '\0'; <br>            } <br>             <br>            RegCloseKey( hKey ); <br>        } <br>    } <br>     <br>    // <br>    // if at this point we don't have MIME type, use default <br>    // <br>     <br>    if( *pszType == '\0' ) { <br>        strncpy( pszType, "application/octet_stream", cbMax ); <br>    } <br> <br>    return TRUE; <br>} <br> <br> <br>  <br>static void <br>DisplayExampleUsage( <br>    EXTENSION_CONTROL_BLOCK *pECB <br>) <br>/*++ <br> <br>Purpose: <br>     <br>    Send short plaintext description of our usage to the user. <br> <br>Arguments: <br>     <br>    pECB - pointer to the extension control block <br> <br>--*/ <br>{ <br>    DWORD dwLength; <br>    static char szUsage[] =  <br>        "Example usage:\r\n" <br>        "http://localhost/scripts/ctetest.dll" <br>        "?file=/default.htm+chunksize=512\r\n"; <br>         <br>    char szHeaders[1024]; <br>     <br> <br>    // <br>    // send simple headers and sample usage instruction <br>    // <br>    dwLength = sizeof szUsage - 1; <br>     <br>    sprintf(  <br>        szHeaders,  <br>        "Content-Length: %u\r\n" <br>        "Content-Type: text/plain\r\n\r\n", <br>        dwLength  <br>        ); <br>     <br>    if( SendHttpHeaders( pECB, "200 OK", szHeaders, FALSE ) ) { <br>        pECB-&gt;WriteClient( <br>            pECB-&gt;ConnID, <br>            szUsage, <br>            &amp;dwLength, <br>            HSE_IO_SYNC <br>            ); <br>    }         <br>} <br> <br> <br>  <br>BOOL  <br>GetQueryStringField( <br>    LPCSTR pszQueryString, <br>    LPCSTR pszKey,  <br>    LPSTR buf,  <br>    DWORD cbuf <br>) <br>/*++ <br> <br>Purpose: <br>    Assuming "key1=value1+key2=value2" syntax, <br>    extract the value for specified key. <br>     <br> <br>Arguments: <br>    pszQueryString - query string provided by ECB <br>    pszKey - key name <br>    buf - buffer for parameter value <br>    cbuf - buffer size <br> <br>Returns: <br> <br>    TRUE if the value was successfully extracted <br>    FALSE otherwise <br> <br>--*/ <br>{ <br>    int len, keylen; <br>    LPCSTR p = pszQueryString; <br> <br>    // <br>    // compute key and query lengths, bail out if either is missing <br>    // <br>     <br>    keylen = strlen( pszKey ); <br>    len = strlen( p ); <br> <br>    if( keylen == 0 || len == 0 ) return FALSE; <br> <br>    // <br>    // process one "+" delimited section at a time   <br>    // <br> <br>    for( ;; ) { <br>     <br>        // <br>        // skip any leading blanks, bail out if end of line found <br>        // <br>         <br>        while( *p &lt;= ' ' ) { <br> <br>            if( *p == '\0' ) { <br>                return FALSE; <br>            } <br>             <br>            p++; <br>            len--; <br>        } <br> <br>        // <br>        // if the key won't fit into the rest of the command line, bail out <br>        // <br>         <br>        if( keylen + 1 &gt; len ) { <br>            return FALSE; <br>        } <br>             <br>        // <br>        // is this the key we are looking for? <br>        // <br>         <br>        if( _memicmp( p, pszKey, keylen ) == 0 &amp;&amp; p[keylen] == '=' ) { <br>         <br>            // <br>            // found it - skip '=' and break out of the loop <br>            // <br>             <br>            p += keylen + 1; <br>            break; <br>        } <br> <br>        //     <br>        // no match, try advancing to next '+' section <br>        // <br>         <br>        while( *p != '+' ) { <br> <br>            if( *p == '\0' ) { <br>                return FALSE; <br>            } <br>             <br>            p++; <br>            len--; <br>        } <br>         <br>        // <br>        // found '+', skip it <br>        // <br>         <br>        p++; <br>        len--; <br>    }    <br> <br>    // <br>    // copy the value up to: the end of line, cbuf chars, or <br>    // '+' separator, whichever comes first <br>    // <br>     <br>    while( *p &amp;&amp; *p != '+' ) { <br> <br>        if( cbuf &lt;= 1 ) { <br>            break; <br>        } <br>         <br>        *(buf++) = *(p++); <br>        cbuf--; <br>    } <br> <br>    // <br>    // zero-terminate the value, report success <br>    // <br>     <br>    *buf = '\0'; <br>    return TRUE; <br>} <br> <br> <br> <br> <br> <br> <br> <br> <br> <br> <br> <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
