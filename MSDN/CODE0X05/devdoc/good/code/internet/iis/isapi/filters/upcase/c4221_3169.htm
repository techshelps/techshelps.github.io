<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>UPCASE.C</title>
<link disabled rel=stylesheet href=../../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context4221"></a>UPCASE.C</h2>
<pre><code>/*++                                                                                                                              <br> <br>Copyright (c) 1995-1996  Microsoft Corporation <br> <br>Module Name: <br> <br>    upcase.c <br> <br>Abstract: <br> <br>    This filter converts HTML response data to upper case if requested <br>    by the client. The request is made by specifying an extra  <br>    subdirectory in the URL, which doesnt actually exist on the server, <br>    but is used by the filter to indicate that upper case is desired. <br>    The extra subdirectory is removed from the request before the HTTP <br>    server sees the request. <br> <br>    When a request is received, the filter inspects the  <br>    subdirectories specified in the URL. If a subdirectory is 'UC' <br>    or 'uc', the subdirectory is removed from the request, and the <br>    filter saves in its pFilterContext field, a value indicating that <br>    the response data should be converted to upper case. <br> <br>    When the filter entrypoint is later called for the response, it  <br>    checks the pFilterContext field and converts the data if  <br>    the mime-type of the response indicates that its an html file. <br>    This avoids conversions on binary data. <br> <br>    An example URL entered by a user might be: <br> <br>        http://www.myweb.com/sales/uc/projections.htm <br> <br>    While the functionality of this filter is somewhat contrived, this <br>    filter does a good job of demonstrating the following features of <br>    filters: <br>        - parsing/modifying HTTP headers (in the request) <br>        - modifying data following HTTP headers (in the response) <br>        - saving state to be used by the filter later <br>        - adding request/response level functionality to the server <br>            (instead of using a mechanism like this to convert to  <br>             uppercase, you may use it to do on-the-fly customized <br>             translations of HTML pages (English -&gt; French perhaps?) <br> <br>Author: <br> <br>    Kerry Schwartz (kerrys) 05-Nov-1995 <br> <br>--*/       <br> <br>#include &lt;windows.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;httpfilt.h&gt; <br> <br>BOOL <br>WINAPI __stdcall <br>GetFilterVersion( <br>    HTTP_FILTER_VERSION * pVer <br>    ) <br>{ <br>    // <br>    //  Specify the types and order of notification <br>    // <br> <br>    pVer-&gt;dwFlags = (SF_NOTIFY_NONSECURE_PORT     | <br>                     SF_NOTIFY_URL_MAP            | <br>                     SF_NOTIFY_SEND_RAW_DATA      | <br>                     SF_NOTIFY_ORDER_DEFAULT); <br> <br>    pVer-&gt;dwFilterVersion = HTTP_FILTER_REVISION; <br> <br>    strcpy( pVer-&gt;lpszFilterDesc,  <br>            "Upper case conversion filter, Version 1.0"); <br> <br>    return TRUE; <br>} <br> <br>DWORD <br>WINAPI __stdcall <br>HttpFilterProc( <br>    HTTP_FILTER_CONTEXT *      pfc, <br>    DWORD                      NotificationType, <br>    VOID *                     pvData ) <br>{ <br>    CHAR *pchIn, *pPhysPath; <br>    DWORD cbBuffer, cbtemp; <br>    PHTTP_FILTER_URL_MAP pURLMap; <br>    PHTTP_FILTER_RAW_DATA pRawData; <br>     <br>   <br>    switch ( NotificationType ) <br>    { <br>    case SF_NOTIFY_URL_MAP: <br> <br>        pURLMap = (PHTTP_FILTER_URL_MAP) pvData; <br>        pPhysPath = pURLMap-&gt;pszPhysicalPath; <br>        pfc-&gt;pFilterContext = 0; <br> <br>        while (*pPhysPath) <br>        { <br>            if (*pPhysPath == '\\' &amp;&amp; <br>               (*(pPhysPath+1) == 'u' || *(pPhysPath+1) == 'U') &amp;&amp; <br>               (*(pPhysPath+2) == 'c' || *(pPhysPath+2) == 'C') &amp;&amp; <br>                *(pPhysPath+3) == '\\') <br>            { <br>                while (*(pPhysPath+3)) <br>                { <br>                    *pPhysPath = *(pPhysPath+3); <br>                    pPhysPath++; <br>                } <br>                *pPhysPath = '\0'; <br>                pfc-&gt;pFilterContext = (VOID *) 1; <br>                break; <br>            } <br>            pPhysPath++; <br>        } <br> <br>        break; <br> <br>    case SF_NOTIFY_SEND_RAW_DATA: <br> <br>        pRawData = (PHTTP_FILTER_RAW_DATA) pvData; <br> <br>        if (pfc-&gt;pFilterContext) <br>        { <br>            pchIn = (BYTE *) pRawData-&gt;pvInData; <br>            cbBuffer = 0; <br>            cbtemp = 0; <br> <br>            if (pfc-&gt;pFilterContext == (VOID *) 1)      // first block? <br>            { <br>                while (cbBuffer &lt; pRawData-&gt;cbInData) <br>                { <br>                    if (pchIn[cbBuffer] == '\n' &amp;&amp; <br>                        pchIn[cbBuffer+2] == '\n') <br>                    { <br>                        cbBuffer +=3; <br>                        break; <br>                    } <br>                    cbBuffer++; <br>                } <br>             <br>                while (cbtemp &lt; cbBuffer) <br>                { <br>                    if (pchIn[cbtemp] == '/' &amp;&amp; pchIn[cbtemp+1] == 'h' &amp;&amp; <br>                        pchIn[cbtemp+2] == 't' &amp;&amp; pchIn[cbtemp+3] == 'm') <br>                    { <br>                        pfc-&gt;pFilterContext = (VOID *) 2; <br>                        break; <br>                    } <br>                    cbtemp++; <br>                } <br>                if (cbtemp == cbBuffer) <br>                    pfc-&gt;pFilterContext = 0;        // not an html file <br>            } <br>             <br>            if (pfc-&gt;pFilterContext) <br>            { <br>                while (cbBuffer &lt; pRawData-&gt;cbInData) <br>                { <br>                    pchIn[cbBuffer] =  <br>                        (pchIn[cbBuffer]&gt;='a' &amp;&amp; pchIn[cbBuffer]&lt;='z') ?  <br>                (pchIn[cbBuffer]-'a'+'A') : pchIn[cbBuffer]; <br>                    cbBuffer++; <br>                } <br>             <br>            } <br>        } <br>        break; <br>            <br>    default: <br>        break;         <br>    } <br> <br>    return SF_STATUS_REQ_NEXT_NOTIFICATION; <br>} <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
