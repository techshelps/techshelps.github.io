<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>WORKERTHREAD.C</title>
<link disabled rel=stylesheet href=../../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context4195"></a>WORKERTHREAD.C</h2>
<pre><code>/*++ <br> <br>Copyright (c) 1997  Microsoft Corporation <br> <br>Module Name:    WorkerThread.c <br> <br>Abstract: <br> <br>    IIS maintains a pool of threads to handle incoming HTTP requests.  When all of <br>    these threads are in use, new requests will be rejected.  If all the pool threads <br>    are in a wait state (for instance, running ISAPI dlls that are waiting for a query <br>    on a remote database to complete), IIS may reject incoming requests even if there <br>    is plenty of CPU power to handle them. <br>     <br>    One way of avoiding this situation is to offload processing of these types of <br>    requests to a worker thread, releasing the IIS thread back to the pool so that it <br>    can be used for another request.  This basic sample demonstrates how to implement <br>    this in an ISAPI dll. <br> <br>*/ <br> <br>#define WIN32_LEAN_AND_MEAN <br>#include &lt;windows.h&gt; <br>#include &lt;httpext.h&gt; <br>#include &lt;stdio.h&gt; <br> <br>// <br>// global variables <br>// <br> <br>DWORD g_dwThreadCount = 0; <br> <br>// <br>// local functions prototypes <br>// <br> <br>DWORD WINAPI WorkerFunction( LPVOID );  <br>BOOL SendHttpHeaders(EXTENSION_CONTROL_BLOCK *, LPCSTR , LPCSTR, BOOL ); <br> <br> <br>  <br>BOOL WINAPI <br>GetExtensionVersion( <br>    OUT HSE_VERSION_INFO *pVer <br>) <br>/*++ <br> <br>Purpose: <br> <br>    This is required ISAPI Extension DLL entry point. <br> <br>Arguments: <br> <br>    pVer - poins to extension version info structure  <br> <br>Returns: <br> <br>    always returns TRUE <br> <br>--*/ <br>{ <br> <br>    // <br>    // tell the server our version number and extension description <br>    // <br> <br>    pVer-&gt;dwExtensionVersion = <br>        MAKELONG( HSE_VERSION_MINOR, HSE_VERSION_MAJOR ); <br> <br>    lstrcpyn( <br>        pVer-&gt;lpszExtensionDesc,  <br>        "ISAPI Worker Thread Extension Sample",  <br>        HSE_MAX_EXT_DLL_NAME_LEN  <br>        ); <br> <br>return TRUE; <br>} <br> <br>  <br>DWORD WINAPI <br>HttpExtensionProc( <br>    IN EXTENSION_CONTROL_BLOCK *pECB <br>) <br>/*++ <br> <br>Purpose: <br> <br>    Create a thread to handle extended processing. It will be passed  <br>    the address of a function ("WorkerFunction") to run, and the address  <br>    of the ECB associated with this session. <br> <br>Arguments: <br> <br>    pECB - pointer to the extenstion control block  <br> <br>Returns: <br> <br>    HSE_STATUS_PENDING to mark this request as pending <br> <br>--*/ <br>{ <br>    DWORD dwThreadID; <br> <br> <br>    // (NOTE: in production environment you'd probably  <br>    //  wanted to limit the number of threads created) <br> <br>    CreateThread(NULL,              // Pointer to thread security attributes  <br>                 0,                 // Initial thread stack size, in bytes  <br>                 WorkerFunction,    // Pointer to thread function  <br>                 pECB,              // The ECB is the argument for the new thread <br>                 0,                 // Creation flags  <br>                 &amp;dwThreadID        // Pointer to returned thread identifier  <br>                 ); <br> <br>    // <br>    // update global thread count <br>    // <br> <br>    InterlockedIncrement( &amp;g_dwThreadCount ); <br> <br>    // Return HSE_STATUS_PENDING to release IIS pool thread without losing connection <br> <br>    return HSE_STATUS_PENDING; <br>} <br> <br>  <br>DWORD WINAPI  <br>WorkerFunction( <br>    IN LPVOID vECB <br>) <br>/*++ <br> <br>Purpose: <br> <br>    Show how to perform extended processing in ISAPI DLL without <br>    tying IIS threads.  <br> <br>Arguments: <br> <br>    vECB - points to current extension control block <br> <br>Returns: <br>     <br>    returns 0   <br> <br>--*/ <br>{ <br>    char szHeader[] =   "Content-type: text/html\r\n\r\n"; <br>    char szContent[]=   "&lt;html&gt; &lt;form method=get action=WorkerThread.dll&gt;&lt;h1&gt;Worker Thread Sample&lt;/h1&gt;&lt;hr&gt;" <br>                        "&lt;input type=submit value=\"Send Request\"&gt; &lt;/form&gt;&lt;/html&gt;"; <br>    EXTENSION_CONTROL_BLOCK *pECB; <br>    DWORD dwSize; <br> <br>    // <br>    // Initialize local ECB pointer to void pointer passed to thread <br>    // <br> <br>    pECB = vECB; <br> <br> <br>    // <br>    // Send outgoing header <br>    // <br> <br>    SendHttpHeaders( pECB, "200 OK", szHeader, FALSE ); <br> <br>    // <br>    // Simulate extended processing for 5 seconds <br>    // <br>     <br>    Sleep(5000); <br> <br> <br>    // <br>    // Send content <br>    // <br>     <br>    dwSize = strlen( szContent ); <br>    pECB-&gt;WriteClient( pECB-&gt;ConnID, szContent, &amp;dwSize, 0 ); <br> <br> <br>    // <br>    // Inform server that the request has been satisfied,  <br>    // and the connection may now be dropped <br>    // <br> <br>    pECB-&gt;ServerSupportFunction(  <br>        pECB-&gt;ConnID,  <br>        HSE_REQ_DONE_WITH_SESSION,  <br>        NULL,  <br>        NULL,  <br>        NULL  <br>        ); <br> <br>    // <br>    // update global thread count <br>    // <br> <br>    InterlockedDecrement( &amp;g_dwThreadCount ); <br> <br>    return 0; <br>} <br> <br>  <br>BOOL  <br>SendHttpHeaders(  <br>    EXTENSION_CONTROL_BLOCK *pECB,  <br>    LPCSTR pszStatus, <br>    LPCSTR pszHeaders, <br>    BOOL fKeepConnection <br>) <br>/*++ <br> <br>Purpose: <br>    Send specified HTTP status string and any additional header strings <br>    using new ServerSupportFunction() request HSE_SEND_HEADER_EX_INFO <br> <br>Arguments: <br> <br>    pECB - pointer to the extension control block <br>    pszStatus - HTTP status string (e.g. "200 OK") <br>    pszHeaders - any additional headers, separated by CRLFs and  <br>                 terminated by empty line <br> <br>Returns: <br> <br>    TRUE if headers were successfully sent <br>    FALSE otherwise <br> <br>--*/ <br>{ <br>    HSE_SEND_HEADER_EX_INFO header_ex_info; <br>    BOOL success; <br> <br>    header_ex_info.pszStatus = pszStatus; <br>    header_ex_info.pszHeader = pszHeaders; <br>    header_ex_info.cchStatus = strlen( pszStatus ); <br>    header_ex_info.cchHeader = strlen( pszHeaders ); <br>    header_ex_info.fKeepConn = fKeepConnection; <br> <br> <br>    success = pECB-&gt;ServerSupportFunction( <br>                  pECB-&gt;ConnID, <br>                  HSE_REQ_SEND_RESPONSE_HEADER_EX, <br>                  &amp;header_ex_info, <br>                  NULL, <br>                  NULL <br>                  ); <br> <br>    return success; <br>} <br> <br>  <br>BOOL WINAPI <br>TerminateExtension(  <br>    IN DWORD dwFlags  <br>) <br>/*++ <br> <br>Routine Description: <br> <br>    This function is called when the WWW service is shutdown. <br> <br>Arguments: <br> <br>    dwFlags - HSE_TERM_ADVISORY_UNLOAD or HSE_TERM_MUST_UNLOAD <br> <br>Return Value: <br> <br>    TRUE when extension is ready to be unloaded, <br> <br>--*/ <br>{ <br> <br>    // (Our threads are deterministic and will complete  <br>    //  not much later than 5 seconds from now) <br> <br>    // <br>    // wait for all threads to terminate, sleeping for 1 sec <br>    // <br> <br>    while( g_dwThreadCount &gt; 0 ) { <br>        SleepEx( 1000, FALSE ); <br>    } <br> <br>    // <br>    // make sure the last thread indeed exited <br>    // <br> <br>    SleepEx( 1000, FALSE ); <br> <br>    return TRUE; <br>} <br> <br> <br> <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
