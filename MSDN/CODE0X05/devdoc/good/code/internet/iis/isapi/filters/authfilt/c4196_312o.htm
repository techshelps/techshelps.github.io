<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DB.C</title>
<link disabled rel=stylesheet href=../../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context4200"></a>DB.C</h2>
<pre><code>/*++ <br> <br>Copyright (c) 1996  Microsoft Corporation <br> <br>This program is released into the public domain for any purpose. <br> <br> <br>Module Name: <br> <br>    db.c <br> <br>Abstract: <br> <br>    This module implements the database routines for the authentication filter. <br> <br>--*/ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;httpfilt.h&gt; <br>#include "authfilt.h" <br> <br>// <br>//  This is the name of the file that contains the username/password pairs and <br>//  the appropriate NT account the username/password should be mapped to. <br>// <br>//  The format of the file is: <br>// <br>//  User1:Password1, NTUser1:NTPassword1 <br>//  User2:Password2, NTUser2:NTPassword2 <br>//  User3:Password3, NTUser1:NTPassword1 <br>// <br>// <br> <br>#define USER_LIST_FILE     "c:\\inetsrv\\userdb.txt" <br> <br>// <br>//  Globals <br>// <br> <br>CHAR * pszUserFile = NULL; <br> <br> <br>BOOL <br>ValidateUser( <br>    IN OUT CHAR * pszUserName, <br>    IN OUT CHAR * pszPassword, <br>    OUT    BOOL * pfValid <br>    ) <br>/*++ <br> <br>Routine Description: <br> <br>    Looks up the username and confirms the user is allowed access to the <br>    server <br> <br>Arguments: <br> <br>    pszUserName - The username to validate, will contain the mapped username <br>                  on return.  Must be at least SF_MAX_USERNAME <br>    pszPassword - The password for this user.  Will contain the mapped <br>                  password on return.  Must be at least SF_MAX_PASSWORD <br>    pfValid     - Set to TRUE if the user should be logged on. <br> <br>Return Value: <br> <br>    TRUE on success, FALSE on failure <br> <br>--*/ <br>{ <br>    BOOL fFound; <br>    CHAR achPassword[SF_MAX_PASSWORD]; <br>    CHAR achNTUser[SF_MAX_USERNAME]; <br>    CHAR achNTUserPassword[SF_MAX_PASSWORD]; <br> <br>    // <br>    //  Assume we're going to fail validation <br>    // <br> <br>    *pfValid = FALSE; <br> <br>    // <br>    //  Lookup the user in the cache, if that fails, get the user from the <br>    //  database and add the retrieved user to the cache <br>    // <br> <br>    if ( !LookupUserInCache( pszUserName, <br>                             &amp;fFound, <br>                             achPassword, <br>                             achNTUser, <br>                             achNTUserPassword )) <br>    { <br>        return FALSE; <br>    } <br> <br>    if ( !fFound ) <br>    { <br>        if ( !LookupUserInDb( pszUserName, <br>                              &amp;fFound, <br>                              achPassword, <br>                              achNTUser, <br>                              achNTUserPassword )) <br>        { <br>            return FALSE; <br>        } <br> <br>        if ( fFound ) <br>        { <br>            AddUserToCache( pszUserName, <br>                            achPassword, <br>                            achNTUser, <br>                            achNTUserPassword ); <br>        } <br>    } <br> <br>    if ( !fFound ) <br>    { <br>        DbgWrite(( DEST, <br>                   "[ValidateUser] Failed to find user %s\n", <br>                   pszUserName )); <br> <br>        return TRUE; <br>    } <br> <br>    // <br>    //  Do the passwords match? <br>    // <br> <br>    if ( !strcmp( pszPassword, achPassword )) <br>    { <br>        // <br>        //  We have a match, map to the NT user and password <br>        // <br> <br>        strcpy( pszUserName, achNTUser ); <br>        strcpy( pszPassword, achNTUserPassword ); <br>        *pfValid = TRUE; <br>    } <br> <br>    return TRUE; <br>} <br> <br>BOOL <br>InitializeUserDatabase( <br>    VOID <br>    ) <br>/*++ <br> <br>Routine Description: <br> <br>    Retrieves the userlist from the file.  If the users were coming from a <br>    database, this routine would connect to the database. <br> <br>Return Value: <br> <br>    TRUE on success, FALSE on failure <br> <br>--*/ <br>{ <br>    HANDLE hFile; <br>    DWORD  cbFile; <br>    DWORD  cbRead; <br> <br>    // <br>    //  Open and read the file.  The System account must have access to the <br>    //  file. <br>    // <br> <br>    hFile = CreateFile( USER_LIST_FILE, <br>                        GENERIC_READ, <br>                        FILE_SHARE_READ, <br>                        NULL, <br>                        OPEN_EXISTING, <br>                        0, <br>                        NULL ); <br> <br>    if ( hFile == INVALID_HANDLE_VALUE ) <br>    { <br>        DbgWrite(( DEST, <br>                   "[InitializeUserDatabase] Error %d openning %s\n", <br>                   GetLastError(), <br>                   USER_LIST_FILE )); <br> <br>        return FALSE; <br>    } <br> <br>    cbFile = GetFileSize( hFile, NULL ); <br> <br>    if ( cbFile == (DWORD) -1 ) <br>    { <br>        CloseHandle( hFile ); <br>        return FALSE; <br>    } <br> <br>    pszUserFile = LocalAlloc( LPTR, cbFile + 1 ); <br> <br>    if ( !pszUserFile ) <br>    { <br>        SetLastError( ERROR_NOT_ENOUGH_MEMORY ); <br>        CloseHandle( hFile ); <br>        return FALSE; <br>    } <br> <br>    if ( !ReadFile( hFile, <br>                    pszUserFile, <br>                    cbFile, <br>                    &amp;cbRead, <br>                    NULL )) <br>    { <br>        CloseHandle( hFile ); <br>        LocalFree( pszUserFile ); <br> <br>        return FALSE; <br>    } <br> <br>    CloseHandle( hFile ); <br> <br>    // <br>    //  Zero terminate the file data <br>    // <br> <br>    pszUserFile[cbRead] = '\0'; <br> <br>    return TRUE; <br>} <br> <br>BOOL <br>LookupUserInDb( <br>    IN CHAR * pszUser, <br>    OUT BOOL * pfFound, <br>    OUT CHAR * pszPassword, <br>    OUT CHAR * pszNTUser, <br>    OUT CHAR * pszNTUserPassword <br>    ) <br>/*++ <br> <br>Routine Description: <br> <br>    Looks up the username in the database and returns the other attributes <br>    associated with this user <br> <br>    The file data is not sorted to simulate the cost of an external database <br>    lookup. <br> <br>Arguments: <br> <br>    pszUserName - The username to find in the database (case insensitive) <br>    pfFound     - Set to TRUE if the specified user name was found in the <br>                  database <br>    pszPassword - The external password for the found user.  Buffer must be <br>                  at least SF_MAX_PASSWORD bytes. <br>    pszNTUser   - The NT username associated with this user, Buffer must be at <br>                  least SF_MAX_USERNAME bytes <br>    pszNTUserPassword - The password for NTUser. Buffer must be at least <br>                  SF_MAX_PASSWORD <br> <br>Return Value: <br> <br>    TRUE on success, FALSE on failure <br> <br>--*/ <br>{ <br>    CHAR * pch = pszUserFile; <br>    CHAR * pchEnd; <br>    DWORD  cchUser = strlen( pszUser ); <br>    DWORD  cch; <br> <br>    *pfFound = FALSE; <br> <br>    // <br>    //  Find the external username.  We're expecting one user per line in <br>    //  the form: <br>    // <br>    //      username:password, NTUser:NTUserPassword <br>    // <br> <br>    while ( pch &amp;&amp; *pch ) <br>    { <br>        while ( ISWHITE( *pch ) ) <br>            pch++; <br> <br>        if ( toupper( *pch ) == toupper( *pszUser ) &amp;&amp; <br>             !strnicmp( pszUser, pch, cchUser )     &amp;&amp; <br>             pch[cchUser] == ':' ) <br>        { <br>            pch += cchUser + 1; <br>            goto Found; <br>        } <br> <br>        pch = strchr( pch+1, '\n' ); <br>    } <br> <br>    // <br>    //  Not found <br>    // <br> <br>    return TRUE; <br> <br>Found: <br> <br>    // <br>    //  Break out the external username <br>    // <br> <br>    if ( !(pchEnd = strchr( pch, ',' ))) <br>    { <br>        SetLastError( ERROR_INVALID_PASSWORDNAME ); <br>        return FALSE; <br>    } <br> <br>    cch = pchEnd - pch; <br> <br>    if ( cch+1 &gt; SF_MAX_PASSWORD ) <br>    { <br>        SetLastError( ERROR_INVALID_PASSWORDNAME ); <br>        return FALSE; <br>    } <br> <br>    memcpy( pszPassword, pch, cch ); <br>    pszPassword[cch] = '\0'; <br> <br>    pch = pchEnd + 1; <br> <br>    // <br>    //  Get the NT username from the file <br>    // <br> <br>    while ( ISWHITE( *pch ) ) <br>        pch++; <br> <br>    if ( !(pchEnd = strchr( pch, ':' ))) <br>    { <br>        SetLastError( ERROR_BAD_USERNAME ); <br>        return FALSE; <br>    } <br> <br>    cch = pchEnd - pch; <br> <br>    if ( cch+1 &gt; SF_MAX_USERNAME ) <br>    { <br>        SetLastError( ERROR_BAD_USERNAME ); <br>        return FALSE; <br>    } <br> <br>    memcpy( pszNTUser, pch, cch ); <br>    pszNTUser[cch] = '\0'; <br> <br>    pch = pchEnd + 1; <br> <br>    // <br>    //  Get the NT password from the file, look for a '\r' or '\n' <br>    // <br> <br>    pchEnd = pch; <br> <br>    while ( *pchEnd &amp;&amp; *pchEnd != '\r' &amp;&amp; *pchEnd != '\n' ) <br>        pchEnd++; <br> <br>    cch = pchEnd - pch; <br> <br>    if ( cch+1 &gt; SF_MAX_PASSWORD ) <br>    { <br>        SetLastError( ERROR_INVALID_PASSWORDNAME ); <br>        return FALSE; <br>    } <br> <br>    memcpy( pszNTUserPassword, pch, cch ); <br>    pszNTUserPassword[cch] = '\0'; <br> <br>    *pfFound = TRUE; <br> <br>    return TRUE; <br>} <br> <br>VOID <br>TerminateUserDatabase( <br>    VOID <br>    ) <br>/*++ <br> <br>Routine Description: <br> <br>    Shutsdown the user database. <br> <br>--*/ <br>{ <br>    if ( pszUserFile ) <br>    { <br>        LocalFree( pszUserFile ); <br>    } <br>} <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
