<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>FORMDUMP.CPP</title>
<link disabled rel=stylesheet href=../../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context4169"></a>FORMDUMP.CPP</h2>
<pre><code>/*++ <br> <br>Copyright (c) 1997  Microsoft Corporation <br> <br>Module Name:    formdump.cpp <br> <br>Abstract: <br> <br>    ISAPI Extension sample illustrating how to obtain data from a web browser <br>    and how to build a reply to the form.  <br> <br>--*/ <br> <br>#define WIN32_LEAN_AND_MEAN     // the bare essential Win32 API <br>#include &lt;windows.h&gt; <br>#include &lt;ctype.h&gt;              // for isprint() <br>#include &lt;httpext.h&gt; <br> <br>#include "keys.h" <br>#include "html.h" <br> <br>// <br>// local prototypes <br>//  <br>void SendVariables( EXTENSION_CONTROL_BLOCK * pECB ); <br>void HexDumper( EXTENSION_CONTROL_BLOCK * pECB, LPBYTE lpbyBuf, DWORD dwLength ); <br>void WhoAmI( EXTENSION_CONTROL_BLOCK * pECB ); <br>BOOL SendHttpHeaders( EXTENSION_CONTROL_BLOCK *, LPCSTR, LPCSTR ); <br> <br>  <br>BOOL WINAPI <br>GetExtensionVersion( <br>    OUT HSE_VERSION_INFO * pVer <br>    ) <br>/*++ <br> <br>Purpose: <br> <br>    This is required ISAPI Extension DLL entry point. <br> <br>Arguments: <br> <br>    pVer - poins to extension version info structure  <br> <br>Returns: <br> <br>    always returns TRUE <br> <br>--*/ <br>{ <br>    // <br>    // set version to httpext.h version constants <br>    // <br>    pVer-&gt;dwExtensionVersion = MAKELONG(HSE_VERSION_MINOR, HSE_VERSION_MAJOR); <br> <br>    lstrcpyn((LPSTR) pVer-&gt;lpszExtensionDesc, <br>        "FORMDUMP - A Form Decoder and Dumper", <br>        HSE_MAX_EXT_DLL_NAME_LEN); <br> <br>    return TRUE; <br>}        <br> <br>  <br>DWORD WINAPI <br>HttpExtensionProc( <br>    IN EXTENSION_CONTROL_BLOCK * pECB <br>) <br>/*++ <br> <br>Purpose: <br> <br>    Pull in all inbound data.  Build a reply page <br>    so the user can see how forms appear in our key list. <br> <br>Arguments: <br> <br>    pECB - pointer to the extenstion control block  <br> <br>Returns: <br> <br>    HSE_STATUS_SUCCESS on successful completion <br>    HSE_STATUS_ERROR on failure <br> <br>--*/ <br>{ <br>    HKEYLIST hKeyList; <br>    char szMsg[128]; <br> <br>    // <br>    // Get the keys sent by the client <br>    // <br>     <br>    hKeyList = GetKeyList( pECB ); <br> <br>     <br>    // <br>    // Send HTTP headers  <br>    // <br>     <br>    SendHttpHeaders( pECB, "200 OK", "Content-type: text/html\r\n\r\n" ); <br> <br>    // <br>    // Create a basic HTML page <br>    // <br>     <br>    HtmlCreatePage( pECB, "FormDump.dll Reply" ); <br>    HtmlHeading( pECB, 1, "Data Available via ISAPI" ); <br>    HtmlHorizontalRule( pECB ); <br> <br>    //  <br>    // Send each form field <br>    //  <br> <br>    HtmlHeading( pECB, 2, "Form Fields" ); <br> <br>    if ( !hKeyList ) { <br>     <br>        // <br>        // Report no data/error <br>        // <br>         <br>        HtmlBold( pECB, "No form fields sent" ); <br>        HtmlWriteText( pECB, " (or error decoding keys)" ); <br>        HtmlEndParagraph( pECB ); <br>         <br>    } else { <br>        HKEYLIST hKey; <br> <br>        // <br>        // Print a quick overview <br>        // <br>         <br>        HtmlWriteTextLine( pECB, "The form you submitted data to just called" ); <br>        HtmlWriteTextLine( pECB, "the Internet Information Server extension" ); <br>        HtmlWriteTextLine( pECB, "FormDump.dll.  Here is a listing of what was" ); <br>        HtmlWriteTextLine( pECB, "received and what variables inside FormDump" ); <br>        HtmlWriteTextLine( pECB, "have the data." ); <br>        HtmlEndParagraph( pECB ); <br> <br>        // <br>        // Loop through all of the keys <br>        // <br>        hKey = hKeyList; <br>        while ( hKey ) { <br>         <br>            // <br>            // Details about the key <br>            // <br>             <br>            LPCTSTR lpszKeyName; <br>            DWORD dwLength; <br>            BOOL bHasCtrlChars; <br>            int nInstance; <br>            HKEYLIST hLastKey; <br> <br>            // <br>            // We get info, and hKey points to next key in list <br>            // <br>             <br>            hLastKey = hKey;    // keep this for later <br> <br>            hKey = GetKeyInfo( hKey, &amp;lpszKeyName, &amp;dwLength, <br>                &amp;bHasCtrlChars, &amp;nInstance ); <br> <br>            // <br>            // Build web page <br>            // <br>             <br>            HtmlBold( pECB, "Form Field Name (lpszKeyName): " ); <br>            HtmlWriteText( pECB, lpszKeyName ); <br>            HtmlLineBreak( pECB ); <br> <br>            HtmlBold( pECB, "Length of Data (dwLength): " ); <br>            wsprintf( szMsg, "%u", dwLength ); <br>            HtmlWriteText( pECB, szMsg ); <br>            HtmlLineBreak( pECB ); <br> <br>            HtmlBold( pECB, "Data Has Control Characters (bHasCtrlChars): " ); <br>            wsprintf( szMsg, "%u", bHasCtrlChars ); <br>            HtmlWriteText( pECB, szMsg ); <br>            HtmlLineBreak( pECB ); <br> <br>            HtmlBold( pECB, "Instance of Form Field (nInstance): " ); <br>            wsprintf( szMsg, "%u", nInstance ); <br>            HtmlWriteText( pECB, szMsg ); <br> <br>            if ( dwLength ) { <br>                HtmlLineBreak( pECB ); <br>                HtmlBold( pECB, "Data Sent for Field:" ); <br>                HtmlLineBreak( pECB ); <br> <br>                HexDumper( pECB, GetKeyBuffer( hLastKey ), dwLength ); <br>            } <br>            HtmlEndParagraph( pECB ); <br>        } <br>     <br>        // <br>        // Clean up <br>        // <br>         <br>        FreeKeyList( hKeyList ); <br>    } <br> <br>    HtmlHorizontalRule( pECB ); <br> <br> <br>    //  <br>    // Get user name from SID and return it in the page <br>    //  <br> <br>    HtmlHeading( pECB, 2, "Security Context for HttpExtensionProc Thread" ); <br>    WhoAmI( pECB ); <br>    HtmlHorizontalRule( pECB ); <br> <br> <br>    //  <br>    // Display all server variables <br>    //  <br> <br>    HtmlHeading( pECB, 2, "Server Variables" ); <br>    HtmlWriteTextLine( pECB,  <br>        "Below is a list of all variables available via" ); <br>    HtmlWriteTextLine( pECB, "GetServerVariable ISAPI API.  Much of this" ); <br>    HtmlWriteTextLine( pECB,  <br>        "information comes from the browser HTTP header." ); <br>    HtmlEndParagraph( pECB ); <br> <br>    // <br>    // Send server variables obtained from the HTTP header <br>    // <br>     <br>    SendVariables( pECB ); <br> <br> <br>    // <br>    // Finish up... <br>    // <br>     <br>    HtmlEndPage( pECB ); <br> <br>    return HSE_STATUS_SUCCESS; <br>} <br> <br>  <br>BOOL WINAPI <br>TerminateExtension( <br>    DWORD dwFlags <br>) <br>/*++ <br> <br>Purpose: <br> <br>    This is optional ISAPI extension DLL entry point. <br>    If present, it will be called before unloading the DLL, <br>    giving it a chance to perform any shutdown procedures. <br>     <br>Arguments: <br>     <br>    dwFlags - specifies whether the DLL can refuse to unload or not <br>     <br>Returns: <br>     <br>    TRUE, if the DLL can be unloaded <br>     <br>--*/ <br>{ <br>    return TRUE; <br>} <br> <br> <br> <br>  <br>void <br>HexDumper( <br>    IN EXTENSION_CONTROL_BLOCK * pECB, <br>    IN LPBYTE lpbyBuf, <br>    IN DWORD dwLength <br>) <br>/*++ <br> <br>Purpose: <br> <br>    Put the inbound data in a hex dump format <br> <br>Arguments: <br>     <br>    pECB - points to the extension control block <br>    lpbyByf - bytes to dump <br>    dwLength - specifies the number of bytes to dump <br>     <br>--*/ <br>{ <br>    DWORD dwSize; <br>    char szLine[80]; <br>    char szHex[3]; <br>    DWORD i; <br>    DWORD dwPos = 0; <br> <br>    HtmlBeginPreformattedText( pECB ); <br> <br>    while (dwLength) { <br>     <br>        // <br>        // Take min of 16 or dwLength <br>        // <br>         <br>        dwSize = min(16, dwLength ); <br> <br>        // <br>        // Build text line <br>        // <br>         <br>        wsprintf(szLine, "  %04X ", dwPos ); <br> <br>        for (i = 0; i &lt; dwSize; i++) { <br>            wsprintf(szHex, "%02X", lpbyBuf[i] ); <br>            lstrcat(szLine, szHex ); <br>            lstrcat(szLine, " " ); <br>        } <br> <br>        // <br>        // Add spaces for short lines <br>        // <br>         <br>        while (i &lt; 16) { <br>            lstrcat(szLine, "   " ); <br>            i++; <br>        } <br> <br>        // <br>        // Add ASCII chars <br>        // <br>         <br>        for (i = 0; i &lt; dwSize; i++) { <br>            if (isprint(lpbyBuf[i])) { <br>                wsprintf(szHex, "%c", lpbyBuf[i] ); <br>                lstrcat(szLine, szHex ); <br>            } else { <br>                lstrcat(szLine, "." ); <br>            } <br>        } <br> <br>        // <br>        // Write data to web page <br>        // <br>         <br>        HtmlWriteTextLine( pECB, szLine ); <br> <br>        // <br>        // Advance positions <br>        // <br>         <br>        dwLength -= dwSize; <br>        dwPos += dwSize; <br>        lpbyBuf += dwSize; <br>    } <br> <br>    HtmlEndPreformattedText( pECB ); <br>} <br> <br>  <br>void <br>DumpVariable( <br>    IN EXTENSION_CONTROL_BLOCK * pECB, <br>    IN LPCTSTR szName <br>) <br>/*++ <br> <br>Purpose: <br>     <br>    Dump a server variable <br> <br>Arguments: <br> <br>    pECB - points to the extension control block <br>    lpbyByf - points to ASCIIZ name of the server variable to dump <br>     <br>--*/     <br>{ <br>    DWORD dwBufferSize; <br>    char szBuffer[4096]; <br>    BOOL bReturn; <br> <br>    dwBufferSize = sizeof szBuffer; <br>    bReturn = pECB-&gt;GetServerVariable( pECB-&gt;ConnID, <br>        (LPSTR) szName, <br>        szBuffer, <br>        &amp;dwBufferSize ); <br> <br>    if ( !bReturn || !szBuffer[0] ) <br>        return; <br> <br>    HtmlWriteText( pECB, szName ); <br>    HtmlWriteText( pECB, "=" ); <br>    HtmlWriteText( pECB, szBuffer ); <br>    HtmlLineBreak( pECB ); <br>} <br> <br>  <br>BOOL  <br>SendHttpHeaders(  <br>    EXTENSION_CONTROL_BLOCK *pECB,  <br>    LPCSTR pszStatus, <br>    LPCSTR pszHeaders <br>) <br>/*++ <br> <br>Purpose: <br>    Send specified HTTP status string and any additional header strings <br>    using new ServerSupportFunction() request HSE_SEND_HEADER_EX_INFO <br> <br>Arguments: <br> <br>    pECB - pointer to the extension control block <br>    pszStatus - HTTP status string (e.g. "200 OK") <br>    pszHeaders - any additional headers, separated by CRLFs and  <br>                 terminated by empty line <br> <br>Returns: <br> <br>    TRUE if headers were successfully sent <br>    FALSE otherwise <br> <br>--*/ <br>{ <br>    HSE_SEND_HEADER_EX_INFO header_ex_info; <br>    BOOL success; <br> <br>    header_ex_info.pszStatus = pszStatus; <br>    header_ex_info.pszHeader = pszHeaders; <br>    header_ex_info.cchStatus = strlen( pszStatus ); <br>    header_ex_info.cchHeader = strlen( pszHeaders ); <br>    header_ex_info.fKeepConn = FALSE; <br> <br> <br>    success = pECB-&gt;ServerSupportFunction( <br>                  pECB-&gt;ConnID, <br>                  HSE_REQ_SEND_RESPONSE_HEADER_EX, <br>                  &amp;header_ex_info, <br>                  NULL, <br>                  NULL <br>                  ); <br> <br>    return success; <br>} <br> <br>  <br>void <br>SendVariables( <br>    IN EXTENSION_CONTROL_BLOCK * pECB <br>) <br>/*++ <br> <br>Purpose: <br> <br>    Send all server variables (they came in the HTTP header) <br>     <br>Arguments: <br> <br>    pECB - pointer to the extension control block <br>     <br>--*/     <br>{ <br>    char *pChar, *pOpts, *pEnd; <br>    DWORD dwBufferSize; <br>    char szBuffer[4096]; <br>    BOOL bReturn; <br> <br>    //  <br>    // Dump the standard variables <br>    //  <br> <br>    DumpVariable( pECB, "AUTH_TYPE" ); <br>    DumpVariable( pECB, "CONTENT_LENGTH" ); <br>    DumpVariable( pECB, "CONTENT_TYPE" ); <br>    DumpVariable( pECB, "GATEWAY_INTERFACE" ); <br>    DumpVariable( pECB, "PATH_INFO" ); <br>    DumpVariable( pECB, "PATH_TRANSLATED" ); <br>    DumpVariable( pECB, "QUERY_STRING" ); <br>    DumpVariable( pECB, "REMOTE_ADDR" ); <br>    DumpVariable( pECB, "REMOTE_HOST" ); <br>    DumpVariable( pECB, "REMOTE_USER" ); <br>    DumpVariable( pECB, "REQUEST_METHOD" ); <br>    DumpVariable( pECB, "SCRIPT_NAME" ); <br>    DumpVariable( pECB, "SERVER_NAME" ); <br>    DumpVariable( pECB, "SERVER_PORT" ); <br>    DumpVariable( pECB, "SERVER_PROTOCOL" ); <br>    DumpVariable( pECB, "SERVER_SOFTWARE" ); <br>    DumpVariable( pECB, "AUTH_PASS" ); <br> <br> <br>    //  <br>    // Dump any others (in ALL_HTTP) <br>    //  <br> <br>    dwBufferSize = sizeof szBuffer; <br>    bReturn = pECB-&gt;GetServerVariable( pECB-&gt;ConnID, <br>        "ALL_HTTP", <br>        szBuffer, <br>        &amp;dwBufferSize ); <br> <br>    if ( bReturn ) { <br>        //  <br>        // Find lines, split key/data pair and write them as output <br>        //  <br> <br>        pChar = szBuffer; <br>        while ( *pChar ) { <br>            if ( *pChar == '\r' || *pChar == '\n' ) { <br>                pChar++; <br>                continue; <br>            } <br>            pOpts = strchr( pChar, ':' );   // look for separator <br> <br>            if ( !pOpts ) <br>                break; <br>            if ( !*pOpts ) <br>                break; <br> <br>            pEnd = pOpts; <br>            while ( *pEnd &amp;&amp; *pEnd != '\r' &amp;&amp; *pEnd != '\n' ) <br>                pEnd++; <br> <br>            *pOpts = 0;         // split strings <br> <br>            *pEnd = 0; <br> <br>            //  <br>            // pChar points to variable name, pOpts + 1 points to variable <br>            // val <br>            //  <br> <br>            HtmlWriteText( pECB, pChar ); <br>            HtmlWriteText( pECB, "=" ); <br>            HtmlWriteText( pECB, pOpts + 1 ); <br>            HtmlLineBreak( pECB ); <br> <br>            pChar = pEnd + 1; <br>        } <br>    } <br>    HtmlEndParagraph( pECB ); <br>    HtmlHorizontalRule( pECB ); <br>} <br> <br>  <br>void <br>WhoAmI( <br>    IN EXTENSION_CONTROL_BLOCK * pECB <br>) <br>/*++ <br> <br>Purpose: <br>     <br>    Get the user SID, lookup the account name and display it <br> <br>Arguments: <br> <br>    pECB - pointer to the extension control block <br>     <br>--*/     <br>{ <br>    HANDLE hToken; <br>    PTOKEN_USER pTokenUser; <br>    BYTE byBuf[1024]; <br>    DWORD dwLen; <br>    char szName[256], szDomain[256]; <br>    DWORD dwNameLen, dwDomainLen; <br>    SID_NAME_USE eUse; <br> <br>    if ( !OpenThreadToken(  <br>            GetCurrentThread( ), TOKEN_QUERY, TRUE, &amp;hToken ) ) { <br>             <br>        DWORD dwError = GetLastError( ); <br> <br>        HtmlBold( pECB, "OpenThreadToken failed. " ); <br>        HtmlPrintf( pECB, "Error code=%u", dwError ); <br>        HtmlEndParagraph( pECB ); <br>        return; <br>    } <br>     <br>    pTokenUser = (PTOKEN_USER) byBuf; <br>    if ( !GetTokenInformation( <br>            hToken, TokenUser, pTokenUser, sizeof byBuf, &amp;dwLen ) ) { <br>             <br>        DWORD dwError = GetLastError( ); <br> <br>        CloseHandle( hToken ); <br> <br>        HtmlBold( pECB, "GetTokenInformation failed. " ); <br>        HtmlPrintf( pECB, "Error code=%u dwLen=%u", dwError, dwLen ); <br>        HtmlEndParagraph( pECB ); <br>        return; <br>    } <br>     <br>    dwNameLen = sizeof szName; <br>    dwDomainLen = sizeof szDomain; <br>    if ( !LookupAccountSid( NULL, pTokenUser-&gt;User.Sid, <br>            szName, &amp;dwNameLen, <br>            szDomain, &amp;dwDomainLen, &amp;eUse )) { <br>             <br>        DWORD dwError = GetLastError( ); <br> <br>        CloseHandle( hToken ); <br> <br>        HtmlBold( pECB, "LookupAccountSid failed. " ); <br>        HtmlPrintf( pECB, "Error code=%u dwNameLen=%u dwDomainLen=%u", <br>            dwError, dwNameLen, dwDomainLen ); <br>        HtmlEndParagraph( pECB ); <br>        return; <br>    } <br>     <br>    HtmlBold( pECB, "Domain: " ); <br>    HtmlWriteText( pECB, szDomain ); <br>    HtmlLineBreak( pECB ); <br>    HtmlBold( pECB, "User: " ); <br>    HtmlWriteText( pECB, szName ); <br>    HtmlEndParagraph( pECB ); <br> <br>    CloseHandle( hToken ); <br>} <br> <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
