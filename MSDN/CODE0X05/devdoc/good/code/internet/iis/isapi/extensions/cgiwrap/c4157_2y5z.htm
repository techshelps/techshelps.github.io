<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CGIWRAP.C</title>
<link disabled rel=stylesheet href=../../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context4157"></a>CGIWRAP.C</h2>
<pre><code>/*++ <br> <br>File: cgiwrap.c <br> <br>Demonstrates an executable which can be used to load an ISAPI DLL like <br>a CGI script. <br> <br>--*/ <br> <br>#define WIN32_LEAN_AND_MEAN <br>#include &lt;windows.h&gt; <br>#include &lt;httpext.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;stdlib.h&gt; <br> <br>// <br>// These are things that go out in the Response Header <br>//  <br> <br>#define HTTP_VER "HTTP/1.0" <br>#define SERVER_VERSION "Http-Srv-Beta2/1.0" <br> <br>// <br>// Simple wrappers for the heap APIS <br>//  <br> <br>#define xmalloc(s) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, (s)) <br>#define xfree(s)   HeapFree(GetProcessHeap(), 0, (s)) <br> <br>// <br>// The mandatory exports from the ISAPI DLL <br>//  <br> <br>typedef BOOL(WINAPI * VersionProc) (HSE_VERSION_INFO *); <br>typedef DWORD(*HttpExtProc) (EXTENSION_CONTROL_BLOCK *); <br> <br> <br>// <br>// Prototypes of the functions this sample implements <br>//  <br> <br>BOOL WINAPI FillExtensionControlBlock(EXTENSION_CONTROL_BLOCK *); <br>BOOL WINAPI GetServerVariable(HCONN, LPSTR, LPVOID, LPDWORD); <br>BOOL WINAPI ReadClient(HCONN, LPVOID, LPDWORD); <br>BOOL WINAPI WriteClient(HCONN, LPVOID, LPDWORD, DWORD); <br>BOOL WINAPI ServerSupportFunction(HCONN, DWORD, LPVOID, LPDWORD, LPDWORD); <br>char *MakeDateStr(VOID); <br>char *GetEnv(char *); <br> <br> <br>// <br>// In the startup of this program, we look at our executable name and       <br>// replace the ".EXE" with ".DLL" to find the ISAPI DLL we need to load.    <br>// This means that the executable need only be given the same "name" as     <br>// the DLL to load. There is no recompilation required.                     <br>// <br> <br>int __cdecl <br>main(int argc, char **argv) <br>{ <br> <br>    HINSTANCE hDll; <br>    VersionProc GetExtensionVersion; <br>    HttpExtProc HttpExtensionProc; <br>    HSE_VERSION_INFO version_info; <br>    EXTENSION_CONTROL_BLOCK ECB; <br>    DWORD rc; <br>    char szModuleFileName[256], *c; <br> <br> <br>    if (!GetModuleFileName(NULL, szModuleFileName, 256)) { <br>        fprintf(stderr, "cannot get ModuleFileName %d\n", GetLastError()); <br>        return -1; <br>    } <br> <br>    rc = strlen(szModuleFileName); <br>    c = szModuleFileName + rc - 4;  // Go back to the last "." <br> <br>    c[1] = 'D'; <br>    c[2] = 'L'; <br>    c[3] = 'L'; <br> <br>    hDll = LoadLibrary(szModuleFileName);   // Load our DLL <br> <br>    if (!hDll) { <br>        fprintf(stderr, "Error: Failure to load %s.dll (%d)\n", <br>            argv[0], GetLastError()); <br>        return -1; <br>    } <br> <br>    //  <br>    // Find the exported functions <br>    // <br> <br>    GetExtensionVersion = (VersionProc) GetProcAddress(hDll,  <br>                                            "GetExtensionVersion"); <br>    if (!GetExtensionVersion) { <br>        fprintf(stderr, "Can't Get Extension Version %d\n", GetLastError()); <br>        return -1; <br>    } <br>    HttpExtensionProc = (HttpExtProc) GetProcAddress(hDll,  <br>                                          "HttpExtensionProc"); <br>    if (!HttpExtensionProc) { <br>        fprintf(stderr, "Can't Get Extension proc %d\n", GetLastError()); <br>        return -1; <br>    } <br> <br>    // <br>    // This should really check if the version information matches what  <br>    // we expect. <br>    //  <br> <br>    __try { <br>        if (!GetExtensionVersion(&amp;version_info)) { <br>            fprintf(stderr, "Fatal: GetExtensionVersion failed\n"); <br>            return -1; <br>        } <br>    } <br>    __except(1) { <br>        return -1; <br>    } <br> <br>    //  <br>    // Fill the ECB with the necessary information <br>    //  <br> <br>    if (!FillExtensionControlBlock(&amp;ECB)) { <br>        fprintf(stderr, "Fill Ext Block Failed\n"); <br>        return -1; <br>    } <br> <br>    // <br>    // Call the DLL <br>    //  <br> <br>    __try { <br>        rc = HttpExtensionProc(&amp;ECB); <br>    } <br>    __except(1) { <br>        return -1; <br>    } <br> <br> <br>    // <br>    // We should really free memory (e.g., from GetEnv), but we'll be dead <br>    // soon enough <br>    // <br>     <br>    if (rc == HSE_STATUS_PENDING)    <br>         <br>        // <br>        // We will exit in ServerSupportFunction <br>        // <br> <br>        Sleep(INFINITE); <br> <br>    return 0; <br> <br>} <br> <br> <br>// <br>// GetServerVariable() is how the DLL calls the main program to figure out <br>// the environment variables it needs. This is a required function. <br>//  <br> <br>BOOL WINAPI <br>GetServerVariable(HCONN hConn, LPSTR lpszVariableName, <br>    LPVOID lpBuffer, LPDWORD lpdwSize) <br>{ <br> <br>    DWORD rc; <br> <br>    //  <br>    // We don't really have an HCONN, so we assume a value of 0 (which is <br>    // passed <br>    // to the DLL in the ECB by HttpExtensionProc(). <br>    // Hence the check for a non-zero HCONN <br> <br>    if (hConn) { <br>        SetLastError(ERROR_INVALID_PARAMETER); <br>        return FALSE; <br>    } <br>    rc = GetEnvironmentVariable(lpszVariableName, lpBuffer, *lpdwSize); <br> <br>    if (!rc) {                   <br> <br>        // <br>        // return of 0 indicates the variable was not found <br>        // <br>        SetLastError(ERROR_NO_DATA); <br>        return FALSE; <br>    } <br> <br>    if (rc &gt; *lpdwSize) { <br>        SetLastError(ERROR_INSUFFICIENT_BUFFER); <br>        return FALSE; <br>    } <br> <br>    // <br>    // GetEnvironmentVariable does not count the NUL character <br>    // <br>    *lpdwSize = rc + 1;          <br> <br>    return TRUE; <br> <br>} <br> <br> <br>// <br>// Again, we don't have an HCONN, so we simply wrap ReadClient() to <br>// ReadFile on stdin. The semantics of the two functions are the same <br>//  <br> <br>BOOL WINAPI <br>ReadClient(HCONN hConn, LPVOID lpBuffer, LPDWORD lpdwSize) <br>{ <br> <br>    return ReadFile(GetStdHandle(STD_INPUT_HANDLE), lpBuffer, (*lpdwSize), <br>        lpdwSize, NULL); <br> <br>} <br> <br> <br>// <br>// ditto for WriteClient() <br>//  <br> <br>BOOL WINAPI <br>WriteClient(HCONN hConn, LPVOID lpBuffer, LPDWORD lpdwSize, <br>    DWORD dwReserved) <br>{ <br> <br>    return WriteFile(GetStdHandle(STD_OUTPUT_HANDLE), lpBuffer, *lpdwSize, <br>        lpdwSize, NULL); <br> <br>} <br> <br> <br>// <br>// This is a special callback function used by the DLL for certain extra  <br>// functionality. Look at the API help for details. <br>//  <br> <br>BOOL WINAPI <br>ServerSupportFunction(HCONN hConn, DWORD dwHSERequest, <br>    LPVOID lpvBuffer, LPDWORD lpdwSize, LPDWORD lpdwDataType) <br>{ <br> <br>    char *lpszRespBuf; <br>    char *temp; <br>    DWORD dwBytes; <br>    BOOL bRet; <br> <br>    switch (dwHSERequest) { <br> <br>    case (HSE_REQ_SEND_RESPONSE_HEADER): <br>        lpszRespBuf = xmalloc(*lpdwSize + 80);  // accomodate our header <br> <br>        if (!lpszRespBuf) <br>            return FALSE; <br>        wsprintf(lpszRespBuf, "%s %s %s %s\r\n%s",  <br>            HTTP_VER, <br>            lpvBuffer ? lpvBuffer : "200 Ok",   // Default response is 200 Ok <br>            temp = MakeDateStr(),               // Create a time string <br>            SERVER_VERSION, <br> <br>        // <br>        // If this exists, it is a pointer to a data buffer to be sent.  <br>        // <br>            lpdwDataType ? (char *) lpdwDataType : NULL); <br> <br>        xfree(temp); <br> <br>        dwBytes = strlen(lpszRespBuf); <br>        bRet = WriteClient(0, lpszRespBuf, &amp;dwBytes, 0); <br>        xfree(lpszRespBuf); <br> <br>        break; <br> <br> <br>    case (HSE_REQ_DONE_WITH_SESSION): <br> <br>        //  <br>        // A real server would do cleanup here <br>        // <br> <br>        ExitProcess(0); <br>        break; <br> <br>    case (HSE_REQ_SEND_URL_REDIRECT_RESP): <br> <br>        //  <br>        // This sends a redirect (temporary) to the client. <br>        // The header construction is similar to RESPONSE_HEADER above. <br>        //  <br> <br>        lpszRespBuf = xmalloc(*lpdwSize + 80); <br>        if (!lpszRespBuf) <br>            return FALSE; <br>        wsprintf(lpszRespBuf, "%s %s %s\r\n", <br>            HTTP_VER, <br>            "302 Moved Temporarily", <br>            (lpdwSize &gt; 0) ? lpvBuffer : 0); <br>        dwBytes = strlen(lpszRespBuf); <br>        bRet = WriteClient(0, lpszRespBuf, &amp;dwBytes, 0); <br>        xfree(lpszRespBuf); <br>        break; <br> <br>    default: <br>        return FALSE; <br>        break; <br>    } <br>    return bRet; <br> <br>} <br> <br> <br> <br>// <br>// Makes a string of the date and time from GetSystemTime(). <br>// This is in UTC, as required by the HTTP spec.` <br>//  <br> <br>char * <br>MakeDateStr(void) <br>{ <br>    SYSTEMTIME systime; <br>    char *szDate = xmalloc(64); <br> <br>    char *DaysofWeek[] =  <br>        {"Sun", "Mon", "Tue", "Wed", "Thurs", "Fri", "Sat"}; <br>    char *Months[] =  <br>        {"NULL", "Jan", "Feb", "Mar", "Apr", "May", "Jun",  <br>         "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"}; <br> <br>    GetSystemTime(&amp;systime); <br> <br>    wsprintf(szDate, "%s, %d %s %d %d:%d.%d",  <br>        DaysofWeek[systime.wDayOfWeek], <br>        systime.wDay, <br>        Months[systime.wMonth], <br>        systime.wYear, <br>        systime.wHour, systime.wMinute, <br>        systime.wSecond); <br> <br>    return szDate; <br>} <br> <br> <br>// <br>// Fill the ECB up  <br>//  <br> <br>BOOL WINAPI <br>FillExtensionControlBlock(EXTENSION_CONTROL_BLOCK * ECB) <br>{ <br> <br>    char *temp; <br> <br>    ECB-&gt;cbSize = sizeof (EXTENSION_CONTROL_BLOCK); <br>    ECB-&gt;dwVersion = MAKELONG(HSE_VERSION_MINOR, HSE_VERSION_MAJOR); <br>    ECB-&gt;ConnID = 0; <br> <br>    //  <br>    // Pointers to the functions the DLL will call. <br>    //  <br>     <br>    ECB-&gt;GetServerVariable = GetServerVariable; <br>    ECB-&gt;ReadClient = ReadClient; <br>    ECB-&gt;WriteClient = WriteClient; <br>    ECB-&gt;ServerSupportFunction = ServerSupportFunction; <br> <br>    //  <br>    // Fill in the standard CGI environment variables <br>    //  <br>     <br>    ECB-&gt;lpszMethod = GetEnv("REQUEST_METHOD"); <br>    ECB-&gt;lpszQueryString = GetEnv("QUERY_STRING"); <br>    ECB-&gt;lpszPathInfo = GetEnv("PATH_INFO"); <br>    ECB-&gt;lpszPathTranslated = GetEnv("PATH_TRANSLATED"); <br>    ECB-&gt;cbTotalBytes = ((temp = GetEnv("CONTENT_LENGTH")) ?  <br>                            (atoi(temp)) : 0); <br>    ECB-&gt;cbAvailable = 0; <br>    ECB-&gt;lpbData = ""; <br>    ECB-&gt;lpszContentType = GetEnv("CONTENT_TYPE"); <br> <br>    return TRUE; <br> <br>} <br> <br> <br>// <br>// Works like _getenv(), but uses win32 functions instead. <br>//  <br> <br>char * <br>GetEnv(LPSTR lpszEnvVar) <br>{ <br> <br>    char *var, dummy; <br>    DWORD dwLen; <br> <br>    if (!lpszEnvVar) <br>        return ""; <br> <br>    dwLen = GetEnvironmentVariable(lpszEnvVar, &amp;dummy, 1); <br> <br>    if (dwLen == 0) <br>        return ""; <br> <br>    var = xmalloc(dwLen); <br>    if (!var) <br>        return ""; <br> <br>    (void) GetEnvironmentVariable(lpszEnvVar, var, dwLen); <br> <br>    return var; <br>} <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
