<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>READCLI.C</title>
<link disabled rel=stylesheet href=../../../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context4180"></a>READCLI.C</h2>
<pre><code>/*++ <br> <br>Copyright (c) 1997  Microsoft Corporation <br> <br>Module Name: <br> <br>    readcli.c <br> <br>Abstract: <br> <br>    This module absorbs input from the client, and then returns <br>    it to the client. <br> <br>Revision History: <br>--*/ <br>#define WIN32_LEAN_AND_MEAN <br>#include &lt;windows.h&gt; <br>#include &lt;httpext.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;stdlib.h&gt; <br> <br>#define BUFFER_LENGTH 4096 <br>#define STRING_LENGTH 80 <br> <br>// Prototypes <br>BOOL SendErrorToClient( LPEXTENSION_CONTROL_BLOCK pec, CHAR *szErrorText ); <br> <br>BOOL WINAPI  <br>GetExtensionVersion( HSE_VERSION_INFO *Version ) <br>/*++ <br> <br>Routine Description: <br> <br>    Sets the ISAPI extension version information. <br> <br>Arguments: <br> <br>    Version     pointer to HSE_VERSION_INFO structure <br> <br>Return Value: <br> <br>    TRUE <br> <br>--*/ <br>{ <br>    Version-&gt;dwExtensionVersion =  <br>        MAKELONG( HSE_VERSION_MINOR, HSE_VERSION_MAJOR ); <br> <br>    strcpy( Version-&gt;lpszExtensionDesc, "ReadClient Extension" ); <br> <br>    return TRUE; <br>} <br> <br> <br>DWORD WINAPI  <br>HttpExtensionProc( LPEXTENSION_CONTROL_BLOCK pec ) <br>/*++ <br> <br>Routine Description: <br> <br>    This is the main routine for any ISAPI application.  We read in all <br>    the data from the client, using the ReadClient function, and then <br>    spit it all back out to the client using WriteClient. <br> <br>Arguments: <br> <br>    pec           pointer to ECB containing parameters related to the request. <br> <br>Return Value: <br> <br>    Either HSE_STATUS_SUCCESS or HSE_STATUS_ERROR <br> <br>--*/ <br>{ <br>    BOOL bResult; <br>    CHAR *szBuffer; <br>    CHAR szTemp[BUFFER_LENGTH]; <br>    CHAR szTmpBuf[BUFFER_LENGTH]; <br>    DWORD dwBytesRead; <br>    DWORD dwBytesWritten; <br>    DWORD dwTotalRead; <br>    DWORD dwTotalWritten; <br>    DWORD dwContentLength; <br>    DWORD dwBufferSize; <br>    HSE_SEND_HEADER_EX_INFO SendHeaderExInfo; <br> <br>    // Determine the amount of data available from the <br>    // Content-Length header <br>    dwBufferSize = sizeof( szTmpBuf ) - 1; <br>    bResult = pec-&gt;GetServerVariable( <br>        pec-&gt;ConnID, <br>        "CONTENT_LENGTH", <br>        szTmpBuf, <br>        &amp;dwBufferSize <br>        ); <br>    if ( !bResult ) { <br>        bResult = SendErrorToClient( pec, "Content-Length header not found" ); <br>        if ( !bResult ) { <br>            return( HSE_STATUS_ERROR ); <br>        } <br>        return( HSE_STATUS_SUCCESS ); <br>    } <br>    dwContentLength = atol( szTmpBuf ); <br> <br>    // Allocate the buffer based on the Content-Length <br>    szBuffer = HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY, dwContentLength + 5 ); <br>    if ( szBuffer == NULL ) { <br>        sprintf( <br>            szTemp, <br>            "Unable to allocate %ld bytes of memory for buffer", <br>            dwContentLength + 5 <br>            ); <br>        bResult = SendErrorToClient( pec, szTemp ); <br>        if ( !bResult ) { <br>            return( HSE_STATUS_ERROR ); <br>        } <br>        return( HSE_STATUS_SUCCESS ); <br>    } <br> <br>    // If the client didn't post anything, return and create a nice form <br>    // for them <br>    if ( pec-&gt;cbAvailable == 0 ) { <br>        bResult = SendErrorToClient( pec, "Your request did not contain any data" ); <br>        if ( !bResult ) { <br>            return( HSE_STATUS_ERROR ); <br>        } <br>        return( HSE_STATUS_SUCCESS ); <br>    } <br> <br> <br>    // Initialize variables before reading in the data <br>    dwTotalWritten = 0; <br>    dwTotalRead = pec-&gt;cbAvailable; <br> <br>    // Copy the first chunk of the data into the buffer <br>    strncpy( szBuffer, pec-&gt;lpbData, dwTotalRead ); <br>    szBuffer[dwTotalRead] = 0; <br> <br>    // Loop to read in the rest of the data from the client <br>    while ( dwTotalRead &lt; pec-&gt;cbTotalBytes ) { <br>        // Set the size of our temporary buffer <br>        dwBytesRead = sizeof( szTmpBuf ) - 1; <br>        if ( (dwTotalRead + dwBytesRead) &gt; pec-&gt;cbTotalBytes ) { <br>            dwBytesRead = pec-&gt;cbTotalBytes - dwTotalRead; <br>        } <br> <br>        // Read the data into the temporary buffer <br>        bResult = pec-&gt;ReadClient( <br>            pec-&gt;ConnID, <br>            szTmpBuf, <br>            &amp;dwBytesRead <br>            ); <br>        if ( !bResult ) { <br>            HeapFree( GetProcessHeap(), 0, szBuffer ); <br>            return( HSE_STATUS_ERROR ); <br>        } <br>        // NULL-Terminate the temporary buffer <br>        szTmpBuf[dwBytesRead] = 0; <br> <br>        // Append the temporary buffer to the real buffer <br>        if ( dwBytesRead != 0 ) { <br>            strcat( szBuffer + dwTotalRead, szTmpBuf ); <br>        } <br>        dwTotalRead += dwBytesRead; <br>    } // while ( dwTotalRead &lt; pec-&gt;cbTotalBytes ) <br> <br>    // All the data has been read in and stored in our buffer <br>    // Now send the data back to the client <br>    SendHeaderExInfo.pszStatus = "200 OK"; <br>    SendHeaderExInfo.pszHeader = "Content-Type: text/html\r\n\r\n"; <br>    SendHeaderExInfo.cchStatus = lstrlen( SendHeaderExInfo.pszStatus ); <br>    SendHeaderExInfo.cchHeader = lstrlen( SendHeaderExInfo.pszHeader ); <br>    SendHeaderExInfo.fKeepConn = FALSE; <br> <br>    bResult = pec-&gt;ServerSupportFunction( <br>        pec-&gt;ConnID, <br>        HSE_REQ_SEND_RESPONSE_HEADER_EX, <br>        &amp;SendHeaderExInfo, <br>        NULL, <br>        NULL <br>        ); <br>    if ( !bResult ) { <br>        HeapFree( GetProcessHeap(), 0, szBuffer ); <br>        return( HSE_STATUS_ERROR ); <br>    } <br>    dwBytesWritten = dwTotalRead; <br>    bResult = pec-&gt;WriteClient( <br>        pec-&gt;ConnID, <br>        szBuffer, <br>        &amp;dwBytesWritten, <br>        0 <br>        ); <br>    if ( !bResult ) { <br>        HeapFree( GetProcessHeap(), 0, szBuffer ); <br>        return( HSE_STATUS_ERROR ); <br>    } <br>    HeapFree( GetProcessHeap(), 0, szBuffer ); <br>    return( HSE_STATUS_SUCCESS ); <br>} <br> <br> <br> <br> <br>BOOL WINAPI <br>TerminateExtension( DWORD dwFlags ) <br>/*++ <br> <br>Routine Description: <br> <br>    This function is called when the WWW service is shutdown <br> <br>Arguments: <br> <br>    dwFlags - HSE_TERM_ADVISORY_UNLOAD or HSE_TERM_MUST_UNLOAD <br> <br>Return Value: <br> <br>    TRUE if extension is ready to be unloaded, <br>    FALSE otherwise <br> <br>--*/ <br>{ <br>    return TRUE; <br>} <br> <br> <br>BOOL SendErrorToClient( LPEXTENSION_CONTROL_BLOCK pec, CHAR *szErrorText ) <br>/*++ <br> <br>Routine Description: <br> <br>    This function sends any error messages and usage information <br>    to the client.  It also creates a nice little form which can <br>    be used to post data. <br> <br>Arguments: <br> <br>    pec - pointer to ECB containing parameters related to the request <br>    szErrorText - Helpful error text to send to the client <br> <br>Return Value: <br> <br>    TRUE or FALSE, depending on the success of WriteClient <br> <br>--*/ <br>{ <br>    BOOL bResult; <br>    CHAR szTemp[BUFFER_LENGTH]; <br>    DWORD dwBytesWritten; <br>    HSE_SEND_HEADER_EX_INFO SendHeaderExInfo; <br> <br>    SendHeaderExInfo.pszStatus = "200 OK"; <br>    SendHeaderExInfo.pszHeader = "Content-Type: text/html\r\n\r\n"; <br>    SendHeaderExInfo.cchStatus = lstrlen( SendHeaderExInfo.pszStatus ); <br>    SendHeaderExInfo.cchHeader = lstrlen( SendHeaderExInfo.pszHeader ); <br>    SendHeaderExInfo.fKeepConn = FALSE; <br> <br>    bResult = pec-&gt;ServerSupportFunction( <br>        pec-&gt;ConnID, <br>        HSE_REQ_SEND_RESPONSE_HEADER_EX, <br>        &amp;SendHeaderExInfo, <br>        NULL, <br>        NULL <br>        ); <br>    if ( !bResult ) { <br>        return FALSE; <br>    } <br> <br>    dwBytesWritten = sprintf(  <br>        szTemp,  <br>        "&lt;h3&gt;Error: %s&lt;/h3&gt;&lt;p&gt;\r\n\r\n" <br>        "Usage: readcli.dll&lt;p&gt;\r\n\r\n" <br>        "Request must be a POST request, with extra data&lt;p&gt;\r\n" <br>        "&lt;h2&gt;Sample Form&lt;/h2&gt;\r\n" <br>        "Enter data below:&lt;br&gt;\r\n" <br>        "&lt;form method=POST action=\"readcli.dll\"&gt;\r\n" <br>        "&lt;input type=text name=test size=80&gt;&lt;br&gt;\r\n" <br>        "&lt;input type=submit&gt;\r\n", <br>        szErrorText <br>        ); <br>    bResult = pec-&gt;WriteClient( <br>        pec-&gt;ConnID, <br>        szTemp, <br>        &amp;dwBytesWritten, <br>        0 <br>        ); <br>    return( bResult ); <br>} <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
