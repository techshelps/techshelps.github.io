<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>FTRANS.C</title>
<link disabled rel=stylesheet href=../../../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context4175"></a>FTRANS.C</h2>
<pre><code>/*++ <br> <br>Copyright (c) 1995-1997  Microsoft Corporation <br> <br>Module Name: <br> <br>    ftrans.c <br> <br>Abstract: <br> <br>    This module demonstrates a simple file transfer using ISAPI application <br>      using the Async TransmitFile support with callback. <br> <br> <br>Revision History: <br>--*/ <br> <br>#include &lt;windows.h&gt; <br>#include "httpext.h" <br> <br># include "openf.h" <br> <br>/************************************************************ <br> *  Global Data <br> ************************************************************/ <br> <br>LIST_ENTRY g_lWorkItems; <br>CRITICAL_SECTION g_csWorkItems; <br> <br># define USE_WORK_QUEUE   (0) <br> <br> <br>DWORD <br>SendHeaderToClient( IN EXTENSION_CONTROL_BLOCK  * pecb, IN LPCSTR pszErrorMsg); <br> <br> <br>DWORD <br>SendFileToClient( IN EXTENSION_CONTROL_BLOCK  * pecb, IN LPCSTR pszFile); <br> <br>DWORD <br>SendFileOver( IN EXTENSION_CONTROL_BLOCK  * pecb, <br>              IN HANDLE hFile,  <br>              IN LPCSTR pszFile); <br> <br> <br> <br>  <br>/************************************************************ <br> *    Functions <br> ************************************************************/ <br> <br> <br>BOOL WINAPI <br>DllMain( <br>     IN HINSTANCE hinstDll, <br>     IN DWORD     fdwReason, <br>     IN LPVOID    lpvContext OPTIONAL <br>     ) <br>/*++ <br> <br> Routine Description: <br> <br>   This function DllMain() is the main initialization function for <br>    this DLL. It initializes local variables and prepares it to be invoked <br>    subsequently. <br> <br> Arguments: <br> <br>   hinstDll          Instance Handle of the DLL <br>   fdwReason         Reason why NT called this DLL <br>   lpvReserved       Reserved parameter for future use. <br> <br> Return Value: <br> <br>    Returns TRUE is successful; otherwise FALSE is returned. <br> <br>--*/ <br>{ <br>    BOOL    fReturn = TRUE; <br> <br>    switch (fdwReason ) { <br> <br>    case DLL_PROCESS_ATTACH: <br>        { <br>          OutputDebugString( " Initializing the global data in ftrans.dll\n"); <br> <br>          // <br>          // Initialize various data and modules. <br>          // <br>          InitializeCriticalSection(&amp;g_csWorkItems); <br>          InitializeListHead( &amp;g_lWorkItems); <br>          InitFileHandleCache(); <br> <br>          break; <br>        } /* case DLL_PROCESS_ATTACH */ <br> <br>    case DLL_PROCESS_DETACH: <br>        { <br> <br>          // <br>          // Only cleanup when we are called because of a FreeLibrary(). <br>          //  i.e., when lpvContext == NULL <br>          // If we are called because of a process termination, <br>          //  dont free anything. System will free resources and memory for us. <br>          // <br> <br>          CleanupFileHandleCache(); <br>          if ( lpvContext != NULL) { <br> <br>              DeleteCriticalSection(&amp;g_csWorkItems); <br>          } <br> <br>          break; <br>        } /* case DLL_PROCESS_DETACH */ <br> <br>    default: <br>        break; <br>    } /* switch */ <br> <br>    return ( fReturn); <br>}  /* DllMain() */ <br> <br> <br> <br>  <br>DWORD WINAPI <br>HttpExtensionProc( <br>    EXTENSION_CONTROL_BLOCK * pecb <br>    ) <br>/*++ <br> <br> Routine Description: <br> <br>   This function performs the necessary action to send response for the  <br>    request received from the client. It picks up the name of a file from <br>    the pecb-&gt;lpszQueryString and transmits that file to the client. <br> <br> Arguments: <br> <br>   pecb          pointer to ECB containing parameters related to the request. <br> <br> Return Value: <br> <br>    Returns HSE_* status codes <br>--*/ <br>{ <br>    DWORD hseStatus; <br> <br>     <br>    if ( pecb-&gt;lpszQueryString == NULL || <br>        *pecb-&gt;lpszQueryString == '\0'  <br>        ) { <br>         <br>        hseStatus = SendHeaderToClient( pecb, "File Not Specified"); <br>    } else { <br> <br>        hseStatus = SendFileToClient( pecb, pecb-&gt;lpszQueryString); <br>    } <br>     <br>    return ( hseStatus); <br>     <br>} // HttpExtensionProc() <br> <br> <br> <br>  <br>BOOL WINAPI <br>GetExtensionVersion( <br>    HSE_VERSION_INFO * pver <br>    ) <br>{ <br>    pver-&gt;dwExtensionVersion = MAKELONG( 1, 0 ); <br>    strcpy( pver-&gt;lpszExtensionDesc, <br>           "File Transfer using TransmitFile" ); <br>     <br>    return TRUE; <br>} <br> <br>  <br>BOOL WINAPI <br>TerminateExtension( <br>    DWORD dwFlags <br>    ) <br>/*++ <br> <br>Purpose: <br> <br>    This is optional ISAPI extension DLL entry point. <br>    If present, it will be called before unloading the DLL, <br>    giving it a chance to perform any shutdown procedures. <br>     <br>Arguments: <br>     <br>    dwFlags - specifies whether the DLL can refuse to unload or not <br>     <br>Returns: <br>     <br>    TRUE, if the DLL can be unloaded <br>     <br>--*/ <br>{ <br>    return TRUE; <br>} <br> <br> <br> <br> <br>  <br>DWORD <br>SendHeaderToClient(  <br>    IN EXTENSION_CONTROL_BLOCK  * pecb,  <br>    IN LPCSTR pszErrorMsg <br>    ) <br>{ <br>HSE_SEND_HEADER_EX_INFOSendHeaderExInfo; <br>char szStatus[]     = "200 OK"; <br>char szHeader[1024]; <br> <br>    // <br>    //  Note the HTTP header block is terminated by a blank '\r\n' pair, <br>    //  followed by the document body <br>    // <br> <br>    wsprintf( szHeader, <br>              "Content-Type: text/html\r\n" <br>              "\r\n"              // marks the end of header block <br>              "&lt;head&gt;&lt;title&gt;Simple File Transfer (Transmit File)" <br>              "&lt;/title&gt;&lt;/head&gt;\n" <br>              "&lt;body&gt;&lt;h1&gt;%s&lt;/h1&gt;\n" <br>              , <br>              pszErrorMsg ); <br> <br> <br>    // <br>    //  Populate SendHeaderExInfo struct <br>    // <br> <br>    SendHeaderExInfo.pszStatus = szStatus; <br>    SendHeaderExInfo.pszHeader = szHeader; <br>    SendHeaderExInfo.cchStatus = lstrlen( szStatus); <br>    SendHeaderExInfo.cchHeader = lstrlen( szHeader); <br>    SendHeaderExInfo.fKeepConn = FALSE; <br> <br>    // <br>    //  Send header - use the EX Version to send the header blob <br>    // <br> <br>if ( !pecb-&gt;ServerSupportFunction( <br>                pecb-&gt;ConnID, <br>                HSE_REQ_SEND_RESPONSE_HEADER_EX, <br>                &amp;SendHeaderExInfo, <br>                NULL, <br>                NULL <br>            ) ) { <br> <br>    return HSE_STATUS_ERROR; <br>} <br>     <br>    return ( HSE_STATUS_SUCCESS); <br>} // SendHeaderToClient() <br>     <br> <br>  <br>DWORD <br>SendFileToClient(  <br>    IN EXTENSION_CONTROL_BLOCK * pecb,  <br>    IN LPCSTR pszFile <br>    ) <br>{ <br>    CHAR    pchBuffer[1024]; <br>    HANDLE  hFile; <br>    DWORD   hseStatus = HSE_STATUS_SUCCESS; <br> <br>    hFile = FcOpenFile( pecb, pszFile); <br> <br>    if ( hFile == INVALID_HANDLE_VALUE) { <br> <br> <br>        wsprintfA( pchBuffer,  <br>                  "OpenFailed: Error (%d) while opening the file %s.\n", <br>                  GetLastError(), pszFile); <br> <br>        hseStatus = SendHeaderToClient( pecb, pchBuffer); <br> <br>    } else { <br> <br>#if SEPARATE_HEADERS <br>        hseStatus = SendHeaderToClient( pecb, "File Transfer begins"); <br>#else  <br>        hseStatus = HSE_STATUS_SUCCESS; <br>#endif <br> <br>        if ( hseStatus == HSE_STATUS_SUCCESS) { <br> <br>            hseStatus = SendFileOver( pecb, hFile, pszFile); <br>             <br>            if ( hseStatus != HSE_STATUS_PENDING) { <br> <br>                // <br>                // assume that the data is transmitted. <br>                // <br>                 <br>                if ( hseStatus != HSE_STATUS_SUCCESS) { <br>                     <br>                    // <br>                    // Error in transmitting the file. Send error message. <br>                    // <br>                     <br>                    wsprintfA( pchBuffer,  <br>                              "Send Failed: Error (%d) for file %s.\n", <br>                              GetLastError(), pszFile); <br>                     <br>                    SendHeaderToClient( pecb, pchBuffer); <br>                } <br>            } <br>        } <br> <br>        if ( hseStatus != HSE_STATUS_PENDING) { <br>               <br>            // <br>            // file handle is closed for all non-pending cases <br>            // if the status is pending, file handle is cleaned up in callback <br>            // <br>            FcCloseFile( hFile); <br>        } <br>    } <br>     <br>    return (hseStatus); <br> <br>} // SendFileToClient() <br> <br> <br> <br>  <br># define MAX_BUFFER_SIZE  (400) <br> <br>typedef struct _AIO_WORK_ITEM { <br>     <br>    LIST_ENTRY    listEntry; <br>    EXTENSION_CONTROL_BLOCK * pecb; <br>    HSE_TF_INFO   hseTf; <br>    CHAR          pchBuffer[ MAX_BUFFER_SIZE ]; <br> <br>}  AIO_WORK_ITEM, * PAWI; <br> <br> <br> <br>  <br>VOID <br>CleanupAW( IN PAWI paw, IN BOOL fDoneWithSession) <br>{ <br> <br>    DWORD err = GetLastError(); <br> <br>    if ( paw-&gt;hseTf.hFile != INVALID_HANDLE_VALUE) {  <br>      <br>        FcCloseFile( paw-&gt;hseTf.hFile); <br>    } <br>     <br>    if (fDoneWithSession) { <br> <br>        paw-&gt;pecb-&gt;ServerSupportFunction( paw-&gt;pecb-&gt;ConnID, <br>                                         HSE_REQ_DONE_WITH_SESSION, <br>                                         NULL, NULL, NULL); <br>    } <br>    SetLastError( err); <br> <br>    // <br>    // Remove from work items list <br>    //  <br>#if USE_WORK_QUEUE <br>    EnterCriticalSection( &amp;g_csWorkItems); <br>    RemoveEntryList( &amp;paw-&gt;listEntry); <br>    LeaveCriticalSection( &amp;g_csWorkItems); <br># endif  <br> <br>    LocalFree( paw); <br>    return; <br> <br>} // CleanupAW() <br> <br> <br> <br>  <br>VOID WINAPI <br>HseIoCompletion( <br>                IN EXTENSION_CONTROL_BLOCK * pECB,  <br>                IN PVOID    pContext, <br>                IN DWORD    cbIO, <br>                IN DWORD    dwError <br>                ) <br>/*++ <br> <br> Routine Description: <br> <br>   This is the callback function for handling completions of asynchronous IO. <br>   This function performs necessary cleanup and resubmits additional IO <br>    (if required). In this case, this function is called at the end of a  <br>    successful TransmitFile() operation. This function primarily cleans up <br>    the data and worker queue item and exits. <br> <br> Arguments: <br> <br>   pecb          pointer to ECB containing parameters related to the request. <br>   pContext      context information supplied with the asynchronous IO call. <br>   cbIO          count of bytes of IO in the last call. <br>   dwError       Error if any, for the last IO operation. <br> <br> Return Value: <br> <br>   None. <br>--*/ <br>{ <br>    PAWI    paw = (PAWI ) pContext; <br>    EXTENSION_CONTROL_BLOCK   * pecb = paw-&gt;pecb; <br> <br>     <br>    // assert( pecb == paw-&gt;pecb); <br> <br>    // <br>    // 1. if no errors, we are done transmitting the file <br>    // 2. cleanup and exit <br>    // <br> <br>     <br>    // <br>    // Do Cleanup <br>    // <br>     <br>    CleanupAW( paw, TRUE); <br> <br> <br>    return; <br> <br>} // HseIoCompletion() <br> <br> <br> <br>  <br>DWORD <br>SendFileOver( IN EXTENSION_CONTROL_BLOCK  * pecb, <br>              IN HANDLE hFile,  <br>              IN LPCSTR pszFile) <br>{ <br> <br>    PAWI   paw; <br>    DWORD  hseStatus = HSE_STATUS_PENDING; <br> <br>    paw  = (PAWI ) LocalAlloc( LMEM_FIXED, sizeof(AIO_WORK_ITEM)); <br>    if ( paw == NULL) { <br> <br>        SetLastError( ERROR_NOT_ENOUGH_MEMORY); <br>        return (HSE_STATUS_ERROR); <br>    } <br> <br>    // <br>    // Fill in all the data in AIO_WORK_ITEM <br>    // <br>    paw-&gt;pecb = pecb; <br>    InitializeListHead( &amp;paw-&gt;listEntry); <br> <br>    paw-&gt;hseTf.pfnHseIO = HseIoCompletion; <br>    paw-&gt;hseTf.pContext = paw; <br>    paw-&gt;hseTf.dwFlags  = (HSE_IO_ASYNC | HSE_IO_DISCONNECT_AFTER_SEND); <br> <br>    paw-&gt;hseTf.hFile    = hFile; <br>    paw-&gt;hseTf.BytesToWrite = GetFileSize(hFile, NULL); <br>    paw-&gt;hseTf.Offset   = 0; <br>    paw-&gt;hseTf.pTail    = NULL; <br>    paw-&gt;hseTf.TailLength = 0; <br> <br> <br>    // <br>    //  Set up the header to be sentout for the file <br>    // <br>     <br>#if SEPARATE_HEADERS <br>    paw-&gt;hseTf.HeadLength = 0; <br>    paw-&gt;hseTf.pHead    = NULL; <br> <br>#else  <br>    paw-&gt;hseTf.HeadLength =  <br>      wsprintfA ( paw-&gt;pchBuffer, <br>                 "HTTP/1.1 200 OK\r\n" <br>                 "Content-Type: text/html\r\n" <br>                 "\r\n" <br>                 "&lt;head&gt;&lt;title&gt;Simple File Transfer (TransmitFile) " <br>                 "&lt;/title&gt;&lt;/head&gt;\n" <br>                 "&lt;h1&gt; Transferred file contains...&lt;/h1&gt;\n"); <br>    paw-&gt;hseTf.pHead = paw-&gt;pchBuffer; <br># endif  <br>     <br>    // Add to the list <br>#if USE_WORK_QUEUE <br>    EnterCriticalSection( &amp;g_csWorkItems); <br>    InsertTailList( &amp;g_lWorkItems,  &amp;paw-&gt;listEntry); <br>    LeaveCriticalSection( &amp;g_csWorkItems); <br>#endif  <br> <br>    // <br>    // Setup the Async TransmitFile <br>    // <br> <br>    if ( !pecb-&gt;ServerSupportFunction( pecb-&gt;ConnID, <br>                                       HSE_REQ_TRANSMIT_FILE, <br>                                       &amp;paw-&gt;hseTf, <br>                                       NULL, <br>                                       NULL) <br>        ) { <br> <br>        // <br>        // Do cleanup and return error <br>        // <br> <br>        // File handle will be freed by the caller for errors <br>        paw-&gt;hseTf.hFile = INVALID_HANDLE_VALUE; <br> <br>        CleanupAW( paw, FALSE); <br>        hseStatus =  HSE_STATUS_ERROR; <br>    } <br> <br>    return (hseStatus); <br> <br>} // SendFileOver() <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
