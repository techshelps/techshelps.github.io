<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>UTILS.CPP</title>
<link disabled rel=stylesheet href=../../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context4219"></a>UTILS.CPP</h2>
<pre><code>// Miscellaneous utility functions <br> <br>#include "CkyPch.h" <br> <br>#include "utils.h" <br>#include "debug.h" <br>#include "notify.h" <br>#include "trie.h" <br>#include "globals.h" <br> <br> <br>// A list of MIME extensions that we know can safely ignore. <br>// BUGBUG: really ought to get this list dynamically <br> <br>static char* s_aszIgnoredExtensions[] = { <br>    "evy",     "hqx",     "doc",     "dot",     "bin", <br>    "oda",     "pdf",     "ai",      "eps",     "ps", <br>    "rtf",     "hlp",     "bcpio",   "cpio",    "csh", <br>    "dcr",     "dir",     "dxr",     "dvi",     "gtar", <br>    "hdf",     "latex",   "mdb",     "crd",     "clp", <br>    "xla",     "xlc",     "xlm",     "xls",     "xlt", <br>    "xlw",     "m1d",     "m14",     "wmf",     "mny", <br>    "ppt",     "mpp",     "pub",     "trm",     "wks", <br>    "wri",     "cdf",     "nc",      "pma",     "pmc", <br>    "pml",     "pmr",     "pmw",     "sh",      "shar", <br>    "sv4cpio", "sv4crc",  "tar",     "tcl",     "tex", <br>    "texi",    "texinfo", "roff",    "t",       "tr", <br>    "man",     "me",      "ms",      "ustar",   "src", <br>    "zip",     "au",      "snd",     "aif",     "aifc", <br>    "aiff",    "ram",     "wav",     "bmp",     "cod", <br>    "gif",     "ief",     "jpe",     "jpeg",    "jpg", <br>    "tif",     "tiff",    "ras",     "cmx",     "pnm", <br>    "pbm",     "pgm",     "ppm",     "rgb",     "xbm", <br>    "xpm",     "xwd",     "bas",     "c",       "h", <br>    "txt",     "rtx",     "tsv",     "etx",     "mpe", <br>    "mpeg",    "mpg",     "mov",     "qt",      "avi", <br>    "movie",   "flr",     "wrl",     "wrz",     "xaf", <br>    "xof", <br>}; <br> <br> <br>// STL functor for CStrILookup <br> <br>struct stricomp { <br>    bool <br>    operator()( <br>        const char* s1, <br>        const char* s2) const <br>    { <br>        return stricmp(s1, s2) &lt; 0; <br>    } <br>}; <br> <br>typedef set&lt;const char*, stricomp&gt; CStrILookup; <br> <br>static CStrILookup s_setMimeExtensions; <br> <br> <br>// Figure out the type of a URL (http:, mailto:, etc) <br> <br>typedef struct { <br>    const char* m_pszUrlType; <br>    URLTYPE     m_ut; <br> <br>#ifdef _DEBUG <br>    void <br>    AssertValid() const <br>    {} <br> <br>    void <br>    Dump() const <br>    { <br>        TRACE("\t%d", m_ut); <br>    } <br>#endif <br>} SUrlType; <br> <br> <br>static const SUrlType s_aUrlTypes[] = { <br>    {"http:",   UT_HTTP}, <br>    {"https:",  UT_HTTPS}, <br>    {"ftp:",    UT_FTP}, <br>    {"gopher:", UT_GOPHER}, <br>    {"mailto:", UT_MAILTO}, <br>    {"mk:",     UT_MK}, <br>    {"news:",   UT_NEWS}, <br>    {"newsrc:", UT_NEWSRC}, <br>    {"nntp:",   UT_NNTP}, <br>    {"telnet:", UT_TELNET}, <br>    {"wais:",   UT_WAIS}, <br>}; <br> <br> <br>static CTrie&lt;SUrlType, true, false&gt; s_trieUrlType; <br> <br> <br> <br>// <br>// Initialize various utility functions <br>// <br> <br>BOOL <br>InitUtils() <br>{ <br>    TRACE("InitUtils\n"); <br> <br>    // Double-check that we've set up our constants correctly <br>    ASSERT(strlen(SESSION_ID_PREFIX) == SESSION_ID_PREFIX_SIZE); <br>    ASSERT(strlen(SESSION_ID_SUFFIX) == SESSION_ID_SUFFIX_SIZE); <br>    ASSERT(strlen(SZ_SESSION_ID_COOKIE_NAME)== SZ_SESSION_ID_COOKIE_NAME_SIZE); <br> <br>    // Build the set of ignorable MIME extensions <br>    s_setMimeExtensions.insert(s_aszIgnoredExtensions, <br>                               s_aszIgnoredExtensions <br>                                 + ARRAYSIZE(s_aszIgnoredExtensions)); <br>#ifdef _DEBUG <br>    int cExt = 0; <br>    for (CStrILookup::iterator j = s_setMimeExtensions.begin(); <br>         j != s_setMimeExtensions.end(); <br>         ++j) <br>    { <br>        const char* psz = *j; <br>        TRACE("%s%c", psz, (++cExt &amp; 3) ? '\t' : '\n' ); <br>    } <br>    TRACE("\n"); <br>#endif <br> <br>    for (int i = 0;  i &lt; ARRAYSIZE(s_aUrlTypes);  ++i) <br>        s_trieUrlType.AddToken(s_aUrlTypes[i].m_pszUrlType, &amp;s_aUrlTypes[i]); <br> <br>    DUMP(&amp;s_trieUrlType); <br> <br>    return InitEventLog(); <br>} <br> <br> <br> <br>// <br>// Clean up when terminating <br>// <br> <br>BOOL <br>TerminateUtils() <br>{ <br>    TRACE("TerminateUtils\n"); <br> <br>    // Best to clean up global objects as much as possible before terminating <br>    s_setMimeExtensions.clear(); <br> <br>    return TRUE; <br>} <br> <br> <br> <br>// <br>// Can this URL be safely ignored? <br>// <br> <br>BOOL <br>IsIgnorableUrl( <br>    LPCSTR pszUrl) <br>{ <br>    // a URL ending in '/' (i.e., a directory name) is ignorable <br>    if (pszUrl[strlen(pszUrl) - 1] == '/') <br>        return TRUE; <br>     <br>    LPCSTR pszExtn = strrchr(pszUrl, '.'); <br> <br>    if (pszExtn != NULL) <br>    { <br>        return (s_setMimeExtensions.find(pszExtn + 1) <br>                != s_setMimeExtensions.end()); <br>    } <br> <br>    return FALSE; <br>} <br> <br> <br> <br>// <br>// "http:" -&gt; UT_HTTP, "ftp:" -&gt; UT_FTP, etc <br>// <br> <br>URLTYPE <br>UrlType( <br>    LPCTSTR ptszData, <br>    LPCTSTR ptszEnd, <br>    int&amp;    rcLen) <br>{ <br>    const SUrlType* put = s_trieUrlType.Search(ptszData, &amp;rcLen, <br>                                               ptszEnd - ptszData); <br> <br>    if (put != NULL) <br>        return put-&gt;m_ut; <br>    else <br>        return UT_NONE; <br>} <br> <br> <br> <br>// <br>// Initializes the event log <br>// <br> <br>BOOL <br>InitEventLog() <br>{ <br>    HKEY hk = NULL;  <br>     <br>    // Add the source name as a subkey under the Application  <br>    // key in the EventLog service portion of the registry.  <br>     <br>    if (RegCreateKey(HKEY_LOCAL_MACHINE,  <br>                     "SYSTEM\\CurrentControlSet\\Services" <br>                     "\\EventLog\\Application\\" EVENT_SOURCE,  <br>                     &amp;hk))  <br>    { <br>        TRACE("could not create registry key\n");  <br>        return FALSE; <br>    } <br>  <br>    // Get the full path of this DLL <br>  <br>    HMODULE hMod = GetModuleHandle(EVENT_MODULE); <br> <br>    if (hMod == NULL) <br>    { <br>        TRACE("Can't get module handle for %s, error %d\n", <br>              EVENT_MODULE, GetLastError()); <br>        return FALSE; <br>    } <br> <br>    CHAR szModule[MAX_PATH];  <br> <br>    if (GetModuleFileName(hMod, szModule, MAX_PATH) &gt; 0) <br>        TRACE("Module is `%s'\n", szModule); <br>    else <br>    { <br>        TRACE("No module, error %d\n", GetLastError()); <br>        return FALSE; <br>    } <br> <br>    // Add the Event ID message-file name to the subkey. <br>  <br>    if (RegSetValueEx(hk,                       // subkey handle <br>                      "EventMessageFile",       // value name <br>                      0,                        // reserved: must be zero <br>                      REG_EXPAND_SZ,            // value type <br>                      (LPBYTE) szModule,        // address of value data <br>                      strlen(szModule) + 1))    // length of value data <br>    { <br>        TRACE("could not set EventMessageFile\n");  <br>        return FALSE; <br>    } <br>  <br>    // Set the supported types flags. <br>  <br>    DWORD dwData = (EVENTLOG_ERROR_TYPE <br>                    | EVENTLOG_WARNING_TYPE <br>                    | EVENTLOG_INFORMATION_TYPE);  <br>  <br>    if (RegSetValueEx(hk,                // subkey handle <br>                      "TypesSupported",  // value name <br>                      0,                 // reserved: must be zero <br>                      REG_DWORD,         // value type <br>                      (LPBYTE) &amp;dwData,  // address of value data <br>                      sizeof(dwData)))   // length of value data <br>    { <br>        TRACE("could not set TypesSupported\n");  <br>        return FALSE; <br>    } <br>  <br>    RegCloseKey(hk);  <br> <br>    return TRUE; <br>} <br> <br> <br> <br>// <br>// Report things in the Event Log <br>// <br> <br>VOID <br>EventReport( <br>    LPCTSTR string1, <br>    LPCTSTR string2, <br>    WORD eventType, <br>    DWORD eventID) <br>{ <br>    HANDLE hEvent; <br>    LPCTSTR pszaStrings[2]; <br>    WORD cStrings; <br> <br>    cStrings = 0; <br>    if ((pszaStrings[0] = string1) &amp;&amp; (string1[0])) <br>        cStrings++; <br>    if ((pszaStrings[1] = string2) &amp;&amp; (string2[0])) <br>        cStrings++; <br>     <br>    hEvent = RegisterEventSource(NULL, EVENT_SOURCE); <br> <br>    if (hEvent)  <br>    { <br>        ReportEvent(hEvent,         // handle returned by RegisterEventSource  <br>                    eventType,      // event type to log  <br>                    0,              // event category  <br>                    eventID,        // event identifier  <br>                    NULL,           // user security identifier (optional)  <br>                    cStrings,       // number of strings to merge with message  <br>                    0,              // size of binary data, in bytes <br>                    pszaStrings,    // array of strings to merge with message  <br>                    NULL);          // address of binary data  <br>        DeregisterEventSource(hEvent); <br>    } <br>} <br> <br> <br> <br>// <br>// stristr (stolen from fts.c, wickn) <br>// <br>// case-insensitive version of strstr <br>// stristr returns a pointer to the first occurrence of string2 in string1. <br>// The search does not include terminating nul characters. <br>// <br> <br>char* <br>stristr(const char* string1, const char* string2) <br>{ <br>    char *cp1 = (char*) string1, *cp2, *cp1a; <br>    char first; <br> <br>    // get the first char in string to find <br>    first = string2[0]; <br> <br>    // first char often won't be alpha <br>    if (isalpha(first)) <br>    { <br>        first = tolower(first); <br>        for ( ; *cp1  != '\0'; cp1++) <br>        { <br>            if (tolower(*cp1) == first) <br>            { <br>                for (cp1a = &amp;cp1[1], cp2 = (char*) &amp;string2[1]; <br>                     ; <br>                     cp1a++, cp2++) <br>                { <br>                    if (*cp2 == '\0') <br>                        return cp1; <br>                    if (tolower(*cp1a) != tolower(*cp2)) <br>                        break; <br>                } <br>            } <br>        } <br>    } <br>    else <br>    { <br>        for ( ; *cp1 != '\0' ; cp1++) <br>        { <br>            if (*cp1 == first) <br>            { <br>                for (cp1a = &amp;cp1[1], cp2 = (char*) &amp;string2[1]; <br>                     ; <br>                     cp1a++, cp2++) <br>                { <br>                    if (*cp2 == '\0') <br>                        return cp1; <br>                    if (tolower(*cp1a) != tolower(*cp2)) <br>                        break; <br>                } <br>            } <br>        } <br>    } <br> <br>    return NULL; <br>} <br> <br> <br> <br>// <br>// Find a string in a block of rawdata (a sort of stristr). <br>// Can't use stristr because the rawdata is not \0-terminated. <br>// <br> <br>LPSTR <br>FindString( <br>    LPCSTR psz, <br>    PHTTP_FILTER_RAW_DATA pRawData, <br>    int iStart) <br>{ <br>    LPSTR pszData = iStart + (LPSTR) pRawData-&gt;pvInData; <br>    const int cch = strlen(psz); <br>    const CHAR ch = tolower(*psz); <br> <br>    for (int i = pRawData-&gt;cbInData - cch + 1 - iStart;  --i &gt;= 0; ) <br>    { <br>        if (ch == tolower(*pszData)  &amp;&amp;  strnicmp(psz, pszData, cch) == 0) <br>            return pszData; <br>        else <br>            ++pszData; <br>    } <br> <br>    return NULL; <br>} <br> <br> <br> <br>// <br>// Find a header-value pair, such as ("Content-Type:", "text/html").  Works <br>// no matter how many spaces between the pair <br>// <br> <br>LPSTR <br>FindHeaderValue( <br>    LPCSTR pszHeader, <br>    LPCSTR pszValue, <br>    PHTTP_FILTER_RAW_DATA pRawData, <br>    int iStart) <br>{ <br>    LPSTR psz = FindString(pszHeader, pRawData, iStart); <br> <br>    if (psz != NULL) <br>    { <br>        LPSTR pszData = iStart + (LPSTR) pRawData-&gt;pvInData; <br>        int   i       = (psz - pszData) + strlen(pszHeader); <br>         <br>        // Skip spaces <br>        while (i &lt; pRawData-&gt;cbInData  &amp;&amp;  isspace(pszData[i])) <br>            ++i; <br>         <br>        // Check for szValue <br>        const int cchValue = strlen(pszValue); <br>         <br>        if (i + cchValue &lt;= pRawData-&gt;cbInData) <br>            if (strnicmp(pszData+i, pszValue, cchValue) == 0) <br>                return psz; <br>    } <br> <br>    return NULL; <br>} <br> <br> <br> <br>// <br>// Delete a line such as "Content-Length: 924\r\n" <br>// <br> <br>BOOL <br>DeleteLine( <br>    LPCSTR psz, <br>    PHTTP_FILTER_RAW_DATA pRawData, <br>    LPSTR  pszStart /* = NULL */) <br>{ <br>    if (pszStart == NULL) <br>        pszStart = FindString(psz, pRawData, 0); <br> <br>    if (pszStart == NULL) <br>        return FALSE; <br> <br>    LPCSTR pszData = (LPCSTR) pRawData-&gt;pvInData; <br> <br>    for (unsigned i = pszStart - pszData;  i &lt; pRawData-&gt;cbInData; ) <br>    { <br>        if (pszData[i++] == '\n') <br>        { <br>            for (unsigned j = 0;  j &lt;  pRawData-&gt;cbInData - i;  j++) <br>                pszStart[j] = pszData[i + j]; <br>            if (j &lt;  pRawData-&gt;cbInData) <br>                pszStart[j] = '\0'; <br>            pRawData-&gt;cbInData -= i - (pszStart - pszData); <br> <br>            return TRUE; <br>        } <br>    } <br> <br>    return FALSE; <br>} <br> <br> <br> <br>// <br>// Extract a Session ID from a Cookie header.  Cookie will be in the form <br>//     name1=value1; name2=value2; name3=value3; ... <br>// One of those name-value pairs should be something like: <br>//     ASPSESSIONIDXXXXXXXX=PVZQGHUMEAYAHMFV or <br>//     ASPSESSIONID=PVZQGHUMEAYAHMFV <br>// <br>  <br>BOOL <br>Cookie2SessionID( <br>    LPCSTR pszCookie, <br>    LPSTR  pszSessionID) <br>{ <br>    if (pszCookie == NULL) <br>    { <br>        ASSERT(FALSE); <br>        return FALSE; <br>    } <br>     <br>    LPCSTR psz = strstr(pszCookie, SZ_SESSION_ID_COOKIE_NAME); <br> <br>    if (psz == NULL) <br>    { <br>        TRACE("C2SID: failed strstr `%s'\n", pszCookie); <br>        return FALSE; <br>    } <br> <br>    // skip over the "ASPSESSIONIDXXXXXXXX=" or "ASPSESSIONID=" part <br>    psz += SZ_SESSION_ID_COOKIE_NAME_SIZE; <br>    if (*(psz) != '=') <br>    { <br>        if ( strncmp( psz, g_szCookieExtra, COOKIE_NAME_EXTRA_SIZE ) == 0 ) <br>        { <br>            psz += COOKIE_NAME_EXTRA_SIZE; <br>            if ( *(psz) != '=' ) <br>            { <br>                TRACE("C2SID: no = `%s'\n", psz); <br>                return FALSE; <br>            } <br>        } <br>        else <br>        { <br>            TRACE("C2SID: strncmp(%s) `%s'\n", g_szCookieExtra, psz); <br>            return FALSE; <br>        } <br>    } <br>    psz++; <br> <br>    return CopySessionID(psz, pszSessionID); <br>} <br> <br> <br> <br>// <br>// Extract a Session ID from psz, placing it into pszSessionID <br>// <br> <br>BOOL <br>CopySessionID( <br>    LPCSTR psz, <br>    LPSTR  pszSessionID) <br>{ <br>    ASSERT( g_SessionIDSize != -1 ); <br> <br>    strncpy(pszSessionID, psz, g_SessionIDSize); <br>    pszSessionID[g_SessionIDSize] = '\0'; <br> <br>#ifdef _DEBUG <br>    TRACE("SessionID='%s'\n", pszSessionID); <br>    for (psz = pszSessionID;  *psz;  ++psz) <br>        ASSERT('A' &lt;= *psz  &amp;&amp;  *psz &lt;= 'Z'); <br>#endif <br> <br>    return TRUE; <br>} <br> <br> <br> <br>// <br>// Remove an encoded Session ID from a URL, returning the Session ID  <br>// e.g., /foo/bar.asp-ASP=PVZQGHUMEAYAHMFV?quux=5 -&gt; <br>//           /foo/bar.asp?quux=5 + PVZQGHUMEAYAHMFV <br>// <br> <br>BOOL <br>DecodeURL( <br>    LPSTR pszUrl, <br>    LPSTR pszSessionID) <br>{ <br>    ASSERT( g_SessionIDSize != -1 ); <br> <br>    TRACE("Decode(%s)", pszUrl); <br>     <br>    LPSTR pszQuery = strchr(pszUrl, '?'); <br> <br>    if (pszQuery != NULL) <br>        *pszQuery++ = '\0'; <br> <br>    LPSTR pszLastSlash = strrchr(pszUrl, *SESSION_ID_PREFIX); <br> <br>    if (pszLastSlash == NULL) <br>    { <br>        TRACE(" (no `" SESSION_ID_PREFIX "')\n"); <br>        return FALSE; <br>    } <br> <br>    const int cchEncodedID = strlen(pszLastSlash); <br> <br>    if (strncmp(pszLastSlash, SESSION_ID_PREFIX, SESSION_ID_PREFIX_SIZE) != 0 <br>        || cchEncodedID != <br>            (SESSION_ID_PREFIX_SIZE + g_SessionIDSize + SESSION_ID_SUFFIX_SIZE) <br>        || strcmp(pszLastSlash + cchEncodedID - SESSION_ID_SUFFIX_SIZE, <br>                  SESSION_ID_SUFFIX) != 0) <br>    { <br>        if (pszQuery != NULL) <br>            *pszQuery = '?'; <br>        TRACE(": not encoded\n"); <br>        return FALSE; <br>    } <br>    else <br>    { <br>        strncpy(pszSessionID, pszLastSlash + SESSION_ID_PREFIX_SIZE, <br>                g_SessionIDSize); <br>        pszSessionID[g_SessionIDSize] = '\0'; <br> <br>        *pszLastSlash = '\0'; <br> <br>        if (pszQuery != NULL) <br>        { <br>            *pszLastSlash++ = '?'; <br> <br>            while ((*pszLastSlash++ = *pszQuery++) != '\0') <br>                ; <br>        } <br> <br>        TRACE(" -&gt; %s, %s\n", pszUrl, pszSessionID); <br> <br>        return TRUE; <br>    } <br>} <br> <br> <br> <br>// <br>// Wrapper for pfc-&gt;AllocMem. <br>// <br> <br>VOID* <br>AllocMem( <br>    PHTTP_FILTER_CONTEXT  pfc, <br>    DWORD                 cbSize) <br>{ <br>    PVOID pv = pfc-&gt;AllocMem(pfc, cbSize, 0); <br>#ifdef _DEBUG <br>    memset(pv, 0, cbSize); <br>#endif <br>    TRACE("Allocated %d (%x) bytes at %x\n", cbSize, cbSize, pv); <br>    return pv; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
