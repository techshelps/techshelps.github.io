<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>FWASYNC.C</title>
<link disabled rel=stylesheet href=../../../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context4179"></a>FWASYNC.C</h2>
<pre><code>/*++ <br> <br>Copyright (c) 1995-1997  Microsoft Corporation <br> <br>Module Name: <br> <br>    fwasync.c <br> <br>Abstract: <br> <br>    This module demonstrates a simple file transfer using ISAPI application <br>      using the Async WriteClient() with callback. <br> <br>Revision History: <br>--*/ <br> <br># include &lt;windows.h&gt; <br># include &lt;stdio.h&gt; <br># include "httpext.h" <br># include "openf.h" <br> <br>/************************************************************ <br> *  Global Data <br> ************************************************************/ <br> <br>LIST_ENTRY g_lWorkItems; <br>CRITICAL_SECTION g_csWorkItems; <br> <br># define USE_WORK_QUEUE   (0) <br> <br> <br>DWORD <br>SendHeaderToClient( IN EXTENSION_CONTROL_BLOCK  * pecb, IN LPCSTR pszErrorMsg); <br> <br> <br>DWORD <br>SendFileToClient( IN EXTENSION_CONTROL_BLOCK  * pecb, IN LPCSTR pszFile); <br> <br>DWORD <br>SendFileOver( IN EXTENSION_CONTROL_BLOCK  * pecb, IN HANDLE hFile); <br> <br> <br> <br> <br>  <br>/************************************************************ <br> *    Functions <br> ************************************************************/ <br> <br> <br>BOOL WINAPI <br>DllMain( <br>     IN HINSTANCE hinstDll, <br>     IN DWORD     fdwReason, <br>     IN LPVOID    lpvContext OPTIONAL) <br>/*++ <br> <br> Routine Description: <br> <br>   This function DllLibMain() is the main initialization function for <br>    this DLL. It initializes local variables and prepares it to be invoked <br>    subsequently. <br> <br> Arguments: <br> <br>   hinstDll          Instance Handle of the DLL <br>   fdwReason         Reason why NT called this DLL <br>   lpvReserved       Reserved parameter for future use. <br> <br> Return Value: <br> <br>    Returns TRUE is successful; otherwise FALSE is returned. <br> <br>--*/ <br>{ <br>  BOOL    fReturn = TRUE; <br> <br>  switch (fdwReason ) { <br> <br>    case DLL_PROCESS_ATTACH: <br>      { <br>          OutputDebugString( "Initializing the global data for fwasync.dll\n"); <br> <br>          // <br>          // Initialize various data and modules. <br>          // <br>          InitializeCriticalSection(&amp;g_csWorkItems); <br>          InitializeListHead( &amp;g_lWorkItems); <br>          fReturn = (InitFileHandleCache() == NO_ERROR); <br> <br>          break; <br>      } /* case DLL_PROCESS_ATTACH */ <br> <br>    case DLL_PROCESS_DETACH: <br>      { <br> <br>          // <br>          // Only cleanup when we are called because of a FreeLibrary(). <br>          //  i.e., when lpvContext == NULL <br>          // If we are called because of a process termination, <br>          //  dont free anything. System will free resources and memory for us. <br>          // <br> <br>          CleanupFileHandleCache(); <br>          if ( lpvContext != NULL) { <br> <br>              DeleteCriticalSection(&amp;g_csWorkItems); <br>          } <br> <br>          break; <br>      } /* case DLL_PROCESS_DETACH */ <br> <br>    default: <br>      break; <br>  }   /* switch */ <br> <br>  return ( fReturn); <br>}  /* DllLibMain() */ <br> <br> <br> <br>  <br>DWORD WINAPI <br>HttpExtensionProc( <br>    EXTENSION_CONTROL_BLOCK * pecb <br>    ) <br>/*++ <br> <br> Routine Description: <br> <br>   This function performs the necessary action to send response for the <br>    request received from the client. It picks up the name of a file from <br>    the pecb-&gt;lpszQueryString and sends the file using Asynchronous WriteClient <br> <br> Arguments: <br> <br>   pecb          pointer to ECB containing parameters related to the request. <br> <br> Return Value: <br> <br>    Returns HSE_* status codes <br>--*/ <br>{ <br>    DWORD hseStatus; <br> <br> <br>    if ( pecb-&gt;lpszQueryString == NULL) { <br> <br>        hseStatus = SendHeaderToClient( pecb, "File Not Found"); <br>    } else { <br> <br>        hseStatus = SendFileToClient( pecb, pecb-&gt;lpszQueryString); <br>    } <br> <br>    return ( hseStatus); <br> <br>} // HttpExtensionProc() <br> <br> <br> <br> <br>  <br>BOOL WINAPI <br>GetExtensionVersion( <br>    HSE_VERSION_INFO * pver <br>    ) <br>{ <br>    pver-&gt;dwExtensionVersion = MAKELONG( 1, 0 ); <br>    strcpy( pver-&gt;lpszExtensionDesc, <br>           "File Transfer using WriteClient" ); <br> <br>    return TRUE; <br>} <br> <br>  <br>BOOL WINAPI <br>TerminateExtension( <br>                   /*IN */ DWORD dwFlags <br>    ) <br>/*++ <br>  This function is called when IIS decides to stop and unload the  <br>  ISAPI DLL. We can do any custom cleanup for the module inside this function <br>--*/ <br>{ <br>    // <br>    // Nothing specific do here for cleanup <br>    // Cleanup is done in the dll process detach in DllLibMain() <br>    // <br> <br>    return ( TRUE); <br>} <br> <br> <br> <br>  <br>DWORD <br>SendHeaderToClient( IN EXTENSION_CONTROL_BLOCK  * pecb, IN LPCSTR pszErrorMsg) <br>{ <br>HSE_SEND_HEADER_EX_INFOSendHeaderExInfo; <br>char szStatus[]     = "200 OK"; <br>char szHeader[1024]; <br> <br>    // <br>    //  Note the HTTP header block is terminated by a blank '\r\n' pair, <br>    //  followed by the document body <br>    // <br> <br>    wsprintf( szHeader, <br>              "Content-Type: text/html\r\n" <br>              "\r\n"              // marks the end of header block <br>              "&lt;head&gt;&lt;title&gt;Simple File Transfer (Async Write)" <br>              "&lt;/title&gt;&lt;/head&gt;\n" <br>              "&lt;body&gt;&lt;h1&gt;%s&lt;/h1&gt;\n" <br>              , <br>              pszErrorMsg ); <br> <br> <br>    // <br>    //  Populate SendHeaderExInfo struct <br>    // <br> <br>    SendHeaderExInfo.pszStatus = szStatus; <br>    SendHeaderExInfo.pszHeader = szHeader; <br>    SendHeaderExInfo.cchStatus = lstrlen( szStatus); <br>    SendHeaderExInfo.cchHeader = lstrlen( szHeader); <br>    SendHeaderExInfo.fKeepConn = FALSE; <br> <br>    // <br>    //  Send header - use the EX Version to send the header blob <br>    // <br> <br>if ( !pecb-&gt;ServerSupportFunction( <br>    pecb-&gt;ConnID <br>    , HSE_REQ_SEND_RESPONSE_HEADER_EX <br>    , &amp;SendHeaderExInfo <br>    , NULL <br>    , NULL <br>            ) ) { <br> <br>    return HSE_STATUS_ERROR; <br>} <br> <br>    return ( HSE_STATUS_SUCCESS); <br>} // SendHeaderToClient() <br> <br> <br>  <br>DWORD <br>SendFileToClient( IN EXTENSION_CONTROL_BLOCK  * pecb, IN LPCSTR pszFile) <br>{ <br>    CHAR    pchBuffer[1024]; <br>    HANDLE  hFile; <br>    DWORD   hseStatus = HSE_STATUS_SUCCESS; <br> <br>    hFile = FcOpenFile( pecb, pszFile); <br> <br>    if ( hFile == INVALID_HANDLE_VALUE) { <br> <br> <br>        wsprintfA( pchBuffer, <br>                  "OpenFailed: Error (%d) while opening the file %s.\n", <br>                  GetLastError(), pszFile); <br> <br>        hseStatus = SendHeaderToClient( pecb, pchBuffer); <br> <br>    } else { <br> <br>        wsprintfA( pchBuffer, " Transferred file contains..."); <br> <br>        hseStatus = SendHeaderToClient( pecb, pchBuffer); <br> <br>        if ( hseStatus == HSE_STATUS_SUCCESS) { <br> <br>            hseStatus = SendFileOver( pecb, hFile); <br> <br>            if ( hseStatus != HSE_STATUS_PENDING) { <br> <br>                // <br>                // assume that the data is transmitted. <br>                // <br> <br>                // close file handle <br>                FcCloseFile( hFile); <br> <br>                if ( hseStatus != HSE_STATUS_SUCCESS) { <br> <br>                    // <br>                    // Error in transmitting the file. Send error message. <br>                    // <br> <br>                    wsprintfA( pchBuffer, <br>                              "Send Failed: Error (%d) for file %s.\n", <br>                              GetLastError(), pszFile); <br> <br>                    SendHeaderToClient( pecb, pchBuffer); <br>                } <br>            } <br>        } <br>    } <br> <br>    return (hseStatus); <br> <br>} // SendFileToClient() <br> <br> <br> <br>  <br># define MAX_BUFFER_SIZE  (4096) <br> <br>typedef struct _AIO_WORK_ITEM { <br> <br>    LIST_ENTRY    listEntry; <br>    EXTENSION_CONTROL_BLOCK * pecb; <br>    HANDLE        hFile; <br>    OVERLAPPED    ov; <br>    DWORD         nRead; <br>    CHAR          pchBuffer[ MAX_BUFFER_SIZE ]; <br> <br>}  AIO_WORK_ITEM, * PAWI; <br> <br> <br>  <br>DWORD <br>ReadDataForPaw(IN PAWI paw) <br>{ <br>    DWORD hseStatus = HSE_STATUS_SUCCESS; <br> <br>    // read data from the file <br>    if (!FcReadFromFile( paw-&gt;hFile, paw-&gt;pchBuffer, MAX_BUFFER_SIZE, <br>                         &amp;paw-&gt;nRead, <br>                         &amp;paw-&gt;ov) <br>        ) { <br> <br>        hseStatus = HSE_STATUS_ERROR; <br>    } <br> <br>    return (hseStatus); <br> <br>} // ReadDataForPaw() <br> <br> <br> <br>  <br>DWORD <br>SendDataForPaw(IN PAWI paw) <br>{ <br>    DWORD hseStatus = HSE_STATUS_PENDING; <br> <br>    // write data to client <br> <br>    if ( !paw-&gt;pecb-&gt;WriteClient( paw-&gt;pecb-&gt;ConnID, <br>                                 paw-&gt;pchBuffer, <br>                                 &amp;paw-&gt;nRead, <br>                                 HSE_IO_ASYNC) <br>        ) { <br> <br>        hseStatus = HSE_STATUS_ERROR; <br>    } <br> <br>    return (hseStatus); <br>} // SendDataForPaw() <br> <br> <br> <br>  <br>VOID <br>CleanupAW( IN PAWI paw, IN BOOL fDoneWithSession) <br>{ <br> <br>    DWORD err = GetLastError(); <br> <br>    FcCloseFile( paw-&gt;hFile); <br>    CloseHandle( paw-&gt;ov.hEvent); <br> <br>    if (fDoneWithSession) { <br>        paw-&gt;pecb-&gt;ServerSupportFunction( paw-&gt;pecb-&gt;ConnID, <br>                                         HSE_REQ_DONE_WITH_SESSION, <br>                                         NULL, NULL, NULL); <br>    } <br>    SetLastError( err); <br> <br>    // <br>    // Remove from work items list <br>    // <br>#if USE_WORK_QUEUE <br>    EnterCriticalSection( &amp;g_csWorkItems); <br>    RemoveEntryList( &amp;paw-&gt;listEntry); <br>    LeaveCriticalSection( &amp;g_csWorkItems); <br># endif <br> <br>    LocalFree( paw); <br>    return; <br> <br>} // CleanupAW() <br> <br> <br> <br>  <br>VOID WINAPI <br>HseIoCompletion( <br>                IN EXTENSION_CONTROL_BLOCK * pECB, <br>                IN PVOID    pContext, <br>                IN DWORD    cbIO, <br>                IN DWORD    dwError <br>                ) <br>/*++ <br> <br> Routine Description: <br> <br>   This is the callback function for handling completions of asynchronous IO. <br>   This function performs necessary cleanup and resubmits additional IO <br>    (if required). In this case, this function is called at the end of a <br>    successful Async WriteClient(). This function attempts to read the next <br>    chunk of data and sends it to client. If there is no next chunk this <br>    function cleans up the state and informs IIS about its intention to end <br>    the request. <br> <br> Arguments: <br> <br>   pecb          pointer to ECB containing parameters related to the request. <br>   pContext      context information supplied with the asynchronous IO call. <br>   cbIO          count of bytes of IO in the last call. <br>   dwError       Error if any, for the last IO operation. <br> <br> Return Value: <br> <br>   None. <br>--*/ <br>{ <br>    PAWI    paw = (PAWI ) pContext; <br>    EXTENSION_CONTROL_BLOCK   * pecb = paw-&gt;pecb; <br>    DWORD   hseStatus; <br> <br> <br>    // <br>    // 1. if no errors, do another read of the file <br>    // 2. send the read contents to client <br>    // 3. if no data present, cleanup and exit <br>    // <br> <br>    if ( dwError != NO_ERROR) { <br> <br>        // <br>        // Do Cleanup <br>        // <br> <br>        CleanupAW( paw, TRUE); <br>        return; <br>    } <br> <br>    //    assert( paw-&gt;nRead == cbIO); <br> <br> <br>    // <br>    // Read next chunk of data <br>    // <br>     <br>    paw-&gt;nRead = 0; <br>    hseStatus = ReadDataForPaw( paw); <br>     <br>    if ( hseStatus == HSE_STATUS_SUCCESS &amp;&amp; paw-&gt;nRead &gt; 0) { <br>         <br>        hseStatus = SendDataForPaw( paw); <br>    } <br> <br>    if ( hseStatus != HSE_STATUS_PENDING) { <br> <br>        CleanupAW( paw, TRUE); <br>    } <br> <br>    return; <br>} // HseIoCompletion() <br> <br> <br>  <br>DWORD <br>SendFileOver( IN EXTENSION_CONTROL_BLOCK  * pecb, IN HANDLE hFile) <br>{ <br> <br>    PAWI   paw; <br>    DWORD  hseStatus = HSE_STATUS_SUCCESS; <br> <br>    paw  = (PAWI ) LocalAlloc( LMEM_FIXED, sizeof(AIO_WORK_ITEM)); <br>    if ( paw == NULL) { <br> <br>        SetLastError( ERROR_NOT_ENOUGH_MEMORY); <br>        return (HSE_STATUS_ERROR); <br>    } <br> <br>    // <br>    // Fill in all the data in AIO_WORK_ITEM <br>    // <br>    paw-&gt;pecb = pecb; <br>    InitializeListHead( &amp;paw-&gt;listEntry); <br>    paw-&gt;hFile = hFile; <br>    paw-&gt;nRead = 0; <br>    memset( &amp;paw-&gt;ov, 0, sizeof(OVERLAPPED)); <br>    paw-&gt;ov.OffsetHigh = 0; <br>    paw-&gt;ov.Offset = 0; <br>    paw-&gt;ov.hEvent = CreateEvent( NULL, TRUE, FALSE, NULL); <br> <br>    if ( paw-&gt;ov.hEvent == NULL) { <br> <br>        LocalFree( paw); <br>        return (HSE_STATUS_ERROR); <br>    } <br> <br>    // <br>    // Setup the callback context for the Async IO <br>    // <br> <br>    if ( !pecb-&gt;ServerSupportFunction( pecb-&gt;ConnID, <br>                                       HSE_REQ_IO_COMPLETION, <br>                                       HseIoCompletion, <br>                                       0, <br>                                       (LPDWORD ) paw) <br>        ) { <br> <br>        // <br>        // Do cleanup and return error <br>        // <br> <br>        CloseHandle( paw-&gt;ov.hEvent); <br>        LocalFree( paw); <br>        return HSE_STATUS_ERROR; <br>    } <br> <br>    // Add to the list <br>#if USE_WORK_QUEUE <br>    EnterCriticalSection( &amp;g_csWorkItems); <br>    InsertTailList( &amp;g_lWorkItems,  &amp;paw-&gt;listEntry); <br>    LeaveCriticalSection( &amp;g_csWorkItems); <br>#endif <br> <br>    hseStatus = ReadDataForPaw( paw); <br> <br>    if ( hseStatus == HSE_STATUS_SUCCESS &amp;&amp; paw-&gt;nRead &gt; 0 ) { <br> <br> <br>        hseStatus = SendDataForPaw( paw); <br>    } <br> <br>    if ( hseStatus != HSE_STATUS_PENDING) { <br> <br>        CleanupAW(paw, FALSE); <br>    } <br> <br>    return (hseStatus); <br> <br>} // SendFileOver() <br> <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
