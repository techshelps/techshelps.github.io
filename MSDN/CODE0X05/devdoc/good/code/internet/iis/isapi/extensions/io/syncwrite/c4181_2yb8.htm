<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>FWRITE.C</title>
<link disabled rel=stylesheet href=../../../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context4184"></a>FWRITE.C</h2>
<pre><code>/*++ <br> <br>Copyright (c) 1995-1997  Microsoft Corporation <br> <br>Module Name: <br> <br>    fwrite.c <br> <br>Abstract: <br> <br>    This module demonstrates a simple file transfer using ISAPI application <br>      using the WriteClient() callback. <br> <br>Revision History: <br>--*/ <br> <br># define WIN32_LEAN_AND_MEAN <br># include &lt;windows.h&gt; <br># include &lt;stdio.h&gt; <br># include "httpext.h" <br># include "openf.h" <br> <br>DWORD <br>SendHeaderToClient( IN EXTENSION_CONTROL_BLOCK  * pecb, IN LPCSTR pszErrorMsg); <br> <br> <br>DWORD <br>SendFileToClient( IN EXTENSION_CONTROL_BLOCK  * pecb, IN LPCSTR pszFile); <br> <br>DWORD <br>SendFileOver( IN EXTENSION_CONTROL_BLOCK  * pecb, IN HANDLE hFile); <br> <br> <br> <br>  <br>BOOL WINAPI <br>DllMain( <br>     IN HINSTANCE hinstDll, <br>     IN DWORD     fdwReason, <br>     IN LPVOID    lpvContext OPTIONAL) <br>/*++ <br> <br> Routine Description: <br> <br>   This function DllLibMain() is the main initialization function for <br>    this DLL. It initializes local variables and prepares it to be invoked <br>    subsequently. <br> <br> Arguments: <br> <br>   hinstDll          Instance Handle of the DLL <br>   fdwReason         Reason why NT called this DLL <br>   lpvReserved       Reserved parameter for future use. <br> <br> Return Value: <br> <br>    Returns TRUE is successful; otherwise FALSE is returned. <br> <br>--*/ <br>{ <br>  BOOL    fReturn = TRUE; <br> <br>  switch (fdwReason ) { <br> <br>    case DLL_PROCESS_ATTACH: <br>      { <br>          OutputDebugString( " Initializing the global data in fwrite.dll\n"); <br> <br>          // <br>          // Initialize various data and modules. <br>          // <br>          fReturn = (InitFileHandleCache() == NO_ERROR); <br> <br>          break; <br>      } /* case DLL_PROCESS_ATTACH */ <br> <br>    case DLL_PROCESS_DETACH: <br>      { <br> <br>          // <br>          // Only cleanup when we are called because of a FreeLibrary(). <br>          //  i.e., when lpvContext == NULL <br>          // If we are called because of a process termination, <br>          //  dont free anything. System will free resources and memory for us. <br>          // <br> <br>          CleanupFileHandleCache(); <br> <br>          break; <br>      } /* case DLL_PROCESS_DETACH */ <br> <br>    default: <br>      break; <br>  }   /* switch */ <br> <br>  return ( fReturn); <br>}  /* DllLibMain() */ <br> <br> <br> <br>  <br>DWORD WINAPI <br>HttpExtensionProc( <br>    IN EXTENSION_CONTROL_BLOCK * pecb <br>) <br>{ <br>    DWORD hseStatus; <br> <br> <br>    if ( pecb-&gt;lpszQueryString == NULL) { <br> <br>        hseStatus = SendHeaderToClient( pecb, "File Not Found"); <br>    } else { <br> <br>        hseStatus = SendFileToClient( pecb, pecb-&gt;lpszQueryString); <br>    } <br> <br>    return ( hseStatus); <br> <br>} // HttpExtensionProc() <br> <br> <br> <br> <br>  <br>BOOL WINAPI <br>GetExtensionVersion( <br>    HSE_VERSION_INFO * pver <br>    ) <br>{ <br>    pver-&gt;dwExtensionVersion = MAKELONG( 1, 0 ); <br>    strcpy( pver-&gt;lpszExtensionDesc, <br>           "File Transfer using WriteClient" ); <br> <br>    return TRUE; <br>} <br> <br> <br>  <br>BOOL WINAPI <br>TerminateExtension( <br>                   /*IN */ DWORD dwFlags <br>    ) <br>/*++ <br>  This function is called when IIS decides to stop and unload the  <br>  ISAPI DLL. We can do any custom cleanup for the module inside this function <br>--*/ <br>{ <br>    // <br>    // Nothing specific do here for cleanup <br>    // Cleanup is done in the dll process detach in DllLibMain() <br>    // <br> <br>    return ( TRUE); <br>} <br> <br> <br> <br>  <br>DWORD <br>SendHeaderToClient( IN EXTENSION_CONTROL_BLOCK  * pecb, IN LPCSTR pszErrorMsg) <br>{ <br>HSE_SEND_HEADER_EX_INFOSendHeaderExInfo; <br>char szStatus[]     = "200 OK"; <br>char szHeader[1024]; <br> <br>    // <br>    //  Note the HTTP header block is terminated by a blank '\r\n' pair, <br>    //  followed by the document body <br>    // <br> <br>    wsprintf( szHeader, <br>              "Content-Type: text/html\r\n" <br>              "\r\n"              // marks the end of header block <br>              "&lt;head&gt;&lt;title&gt;Simple File Transfer (Synchronous Write)" <br>              "&lt;/title&gt;&lt;/head&gt;\n" <br>              "&lt;body&gt;&lt;h1&gt;%s&lt;/h1&gt;\n" <br>              , <br>              pszErrorMsg ); <br> <br> <br>    // <br>    //  Populate SendHeaderExInfo struct <br>    // <br> <br>    SendHeaderExInfo.pszStatus = szStatus; <br>    SendHeaderExInfo.pszHeader = szHeader; <br>    SendHeaderExInfo.cchStatus = lstrlen( szStatus); <br>    SendHeaderExInfo.cchHeader = lstrlen( szHeader); <br>    SendHeaderExInfo.fKeepConn = FALSE; <br> <br>    // <br>    //  Send header - use the EX Version to send the header blob <br>    // <br> <br>if ( !pecb-&gt;ServerSupportFunction( <br>    pecb-&gt;ConnID <br>    , HSE_REQ_SEND_RESPONSE_HEADER_EX <br>    , &amp;SendHeaderExInfo <br>    , NULL <br>    , NULL <br>            ) ) { <br> <br>    return HSE_STATUS_ERROR; <br>} <br> <br>    return ( HSE_STATUS_SUCCESS); <br>} // SendHeaderToClient() <br> <br> <br> <br>DWORD <br>SendFileToClient( IN EXTENSION_CONTROL_BLOCK  * pecb, IN LPCSTR pszFile) <br>{ <br>    CHAR    pchBuffer[1024]; <br>    HANDLE  hFile; <br>    DWORD   hseStatus = HSE_STATUS_SUCCESS; <br> <br>    hFile = FcOpenFile( pecb, pszFile); <br> <br>    if ( hFile == INVALID_HANDLE_VALUE) { <br> <br> <br>        wsprintfA( pchBuffer, <br>                  "OpenFailed: Error (%d) while opening the file %s.\n", <br>                  GetLastError(), pszFile); <br> <br>        hseStatus = SendHeaderToClient( pecb, pchBuffer); <br> <br>    } else { <br> <br>        wsprintfA( pchBuffer, " Transferred file contains..."); <br> <br>        hseStatus = SendHeaderToClient( pecb, pchBuffer); <br> <br>        if ( hseStatus == HSE_STATUS_SUCCESS) { <br> <br>            hseStatus = SendFileOver( pecb, hFile); <br> <br>            if ( hseStatus != HSE_STATUS_PENDING) { <br> <br>                if ( hseStatus != HSE_STATUS_SUCCESS) { <br> <br>                    // <br>                    // Error in transmitting the file. Send error message. <br>                    // <br> <br>                    wsprintfA( pchBuffer, <br>                              "Send Failed: Error (%d) for file %s.\n", <br>                              GetLastError(), pszFile); <br> <br>                    SendHeaderToClient( pecb, pchBuffer); <br>                } <br>            } <br> <br>            if ( hseStatus != HSE_STATUS_PENDING) { <br> <br>                // <br>                // assume that the data is transmitted. <br>                // <br> <br>                // close file handle <br>                FcCloseFile( hFile); <br>            } <br>        } <br>    } <br> <br>    return (hseStatus); <br> <br>} // SendFileToClient() <br> <br> <br> <br>  <br># define MAX_BUFFER_SIZE  (4096) <br> <br>DWORD <br>SendFileOver( IN EXTENSION_CONTROL_BLOCK  * pecb, IN HANDLE hFile) <br>{ <br>    CHAR  pchBuffer[MAX_BUFFER_SIZE]; <br>    DWORD dwBytesInFile = GetFileSize(hFile, NULL); <br>    DWORD nRead = 0; <br>    DWORD hseStatus = HSE_STATUS_SUCCESS; <br>    OVERLAPPED  ov; <br>    DWORD err; <br> <br>    // <br>    // Send the whole file. <br>    // Loop thru reading the file and transmitting it to client <br>    // <br> <br> <br>    memset(&amp;ov, 0, sizeof(OVERLAPPED)); <br> <br>    ov.OffsetHigh = 0; <br>    ov.Offset = 0; <br>    ov.hEvent = CreateEvent(NULL, TRUE, FALSE, "OVERLAPPED::hEvent"); <br> <br>    if ( ov.hEvent == NULL) { <br> <br>        return (HSE_STATUS_ERROR); <br>    } <br> <br>    do { <br> <br>        nRead = 0; <br> <br>        // read data from the file <br>        if (!FcReadFromFile( hFile, pchBuffer, MAX_BUFFER_SIZE, &amp;nRead, <br>                           &amp;ov) <br>            ) { <br> <br>            hseStatus = HSE_STATUS_ERROR; <br>            break; <br>        } <br> <br>        // write data to client <br> <br>        if ( !pecb-&gt;WriteClient( pecb-&gt;ConnID, <br>                                 pchBuffer, &amp;nRead, <br>                                0) <br>            ) { <br> <br>            hseStatus = HSE_STATUS_ERROR; <br>            break; <br>        } <br> <br>    } while (TRUE); <br> <br> <br>    if ( ov.hEvent != NULL) { <br> <br>        err = GetLastError(); <br>        CloseHandle( ov.hEvent); <br>        ov.hEvent = NULL; <br>        SetLastError( err); <br>    } <br> <br>    return (hseStatus); <br> <br>} // SendFileOver() <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
