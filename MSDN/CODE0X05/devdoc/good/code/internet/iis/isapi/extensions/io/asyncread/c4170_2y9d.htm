<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>AREADCLI.C</title>
<link disabled rel=stylesheet href=../../../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context4171"></a>AREADCLI.C</h2>
<pre><code>/*++ <br> <br>Copyright (c) 1997  Microsoft Corporation <br> <br>Module Name: <br> <br>    AReadCli.c <br> <br>Abstract: <br> <br>    This module demonstrates using asynchronous ReadClient call <br>    to read data sent from client. On return, this sends the  <br>    followings back to client: <br>     <br>    1) the number of bytes intended to send <br>    2) the number of bytes actually read. <br>    3) data content  <br> <br>Author: <br> <br>    Stanley Tam (stanleyt)   4-June 1997 <br>     <br>Revision History: <br>   <br>--*/ <br>#include &lt;windows.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;httpext.h&gt; <br> <br> <br>#define MAX_BUF_SIZE        (49152)                 // Max number of bytes for each read - 48K <br>#define MEM_ALLOC_THRESHOLD (1024 * 1024)           // Default heap size is 1M <br> <br> <br>typedef struct _IO_WORK_ITEM { <br> <br>    PBYTE                       pbDATAFromClient;   // Grand read data holder <br>    DWORD                       cbReadSoFar;        // Number of bytes read so far,  <br>                                                    // and is used as index for pbDATAFromClient <br>    EXTENSION_CONTROL_BLOCK *   pecb; <br> <br>}  IO_WORK_ITEM, * PIOWI; <br> <br> <br>// <br>//  Sample Form for doing a POST method <br>// <br> <br>static CHAR             g_szPostForm[] = <br>                        "&lt;h2&gt;Asychronous ReadClient Sample Post Form&lt;/h2&gt;&lt;p&gt;\r\n\r\n" <br>                        "This demonstrates a post request being sent by this form to the sample ISAPI - AReadCli.dll&lt;p&gt;\r\n\r\n" <br>                        "AReadCli.dll reads data posted by this form and send it back to the browser.&lt;p&gt;\r\n" <br>                        "&lt;h3&gt;Post Form&lt;/h3&gt;\r\n" <br>                        "Please enter data below:&lt;br&gt;\r\n" <br>                        "&lt;form method=POST action=\"areadcli.dll\"&gt;\r\n" <br>                        "&lt;textarea name=\"Data\" cols=48 rows=4&gt;&lt;/textarea&gt;\r\n\r\n" <br>                        "&lt;input type=submit&gt; &lt;input type=reset&gt;\r\n" <br>                        "&lt;/form&gt;"; <br> <br>// <br>//  Report read data <br>// <br> <br>static CHAR             g_szReport[] =  <br>                        "Bytes count including \"Data=\"  \r\n" <br>                        "ECB Total Bytes:    %d.\r\n" <br>                        "Actual Read Bytes:  %d.\r\n"; <br>                 <br>DWORD <br>DoInit(IN OUT PIOWI piowi); <br> <br>VOID <br>DoCleanUp(IN PIOWI piowi); <br> <br>DWORD <br>DoAsyncReadClient(IN PIOWI piowi); <br>              <br>VOID WINAPI <br>AsyncReadClientIoCompletion(IN LPEXTENSION_CONTROL_BLOCK pecb,  <br>                            IN PVOID pContext, <br>                            IN DWORD cbIO, <br>                            IN DWORD dwError); <br> <br>DWORD <br>SendMSGToClient(IN LPEXTENSION_CONTROL_BLOCK pecb,  <br>                IN LPCSTR pszErrorMsg); <br> <br>LPVOID  <br>AR_Allocate(IN LPEXTENSION_CONTROL_BLOCK pecb, IN DWORD dwSize); <br> <br>BOOL  <br>AR_Free(IN LPEXTENSION_CONTROL_BLOCK pecb, IN LPVOID pvData); <br> <br> <br> <br>DllMain( <br>     IN HINSTANCE hinstDll, <br>     IN DWORD     fdwReason, <br>     IN LPVOID    lpvContext OPTIONAL) <br>/*++ <br> <br> Routine Description: <br> <br>   This function DllLibMain() is the main initialization function for <br>    this DLL. It initializes local variables and prepares it to be invoked <br>    subsequently. <br> <br> Arguments: <br> <br>   hinstDll          Instance Handle of the DLL <br>   fdwReason         Reason why NT called this DLL <br>   lpvReserved       Reserved parameter for future use. <br> <br> fReturn Value: <br> <br>    fReturns TRUE if successful; otherwise FALSE is fReturned. <br> <br>--*/ <br>{ <br>  BOOL    fReturn = TRUE; <br> <br> <br>  switch ( fdwReason) { <br> <br>    case DLL_PROCESS_ATTACH: <br>      { <br>          OutputDebugString( "Initializing the global data for areadcli.dll\n"); <br> <br>          // <br>          // Prevent the system from calling DllMain <br>          // when threads are created or destroyed. <br>          // <br> <br>          DisableThreadLibraryCalls( hinstDll); <br> <br>          // <br>          // Initialize various data and modules. <br>          // <br> <br>          break; <br> <br>      } // case DLL_PROCESS_ATTACH <br> <br>    case DLL_PROCESS_DETACH: <br>      { <br> <br>          if ( lpvContext != NULL) { } <br> <br>          break; <br>      } // case DLL_PROCESS_DETACH <br> <br>    default: <br>      break; <br>  }   // switch <br> <br>  return (fReturn); <br>}  // DllLibMain() <br> <br> <br> <br> <br>BOOL WINAPI <br>GetExtensionVersion(HSE_VERSION_INFO * Version) <br>/*++ <br> <br>Routine Description: <br> <br>    Sets the ISAPI extension version information. <br> <br>Arguments: <br> <br>    Version     pointer to HSE_VERSION_INFO structure <br> <br>Return Value: <br> <br>    TRUE <br> <br>--*/ <br>{ <br>    Version-&gt;dwExtensionVersion =  <br>    MAKELONG(HSE_VERSION_MINOR, HSE_VERSION_MAJOR); <br> <br>    strcpy(Version-&gt;lpszExtensionDesc, "Asynchronous Read Client Sample ISAPI DLL"); <br> <br>    return TRUE; <br>} <br> <br> <br> <br> <br>DWORD WINAPI <br>HttpExtensionProc(LPEXTENSION_CONTROL_BLOCK pecb) <br>/*++ <br> <br>Routine Description: <br> <br>    This is the main routine for any ISAPI application. Inside DoASyncReadClient, <br>    proper action will be performed to read data from client asynchronously. Any data  <br>    read from client will be sent back to the client by using synchronous WriteClient. <br> <br>Arguments: <br> <br>    pecb        pointer to ECB containing parameters related to the request. <br> <br>Return Value: <br> <br>    HSE_STATUS_SUCCESS  or <br>    HSE_STATUS_PENDING  or  <br>    HSE_STATUS_ERROR <br> <br>--*/ <br>{ <br>    PIOWI   piowi; <br>    DWORD   hseStatus = HSE_STATUS_SUCCESS; <br>     <br>    // <br>    // The string length of textarea name "Data=" is 5.  <br>    // Available bytes &lt;= 5 indicates that no user- <br>    // entered data has been sent, and the post form  <br>    // is shown. <br>    // <br> <br>    if ( pecb-&gt;cbAvailable &lt;= 5) {   <br> <br>        hseStatus = SendMSGToClient(pecb, g_szPostForm); <br>     <br>    } else { <br> <br>        piowi  = (PIOWI ) LocalAlloc( LMEM_FIXED, sizeof( IO_WORK_ITEM)); <br> <br>        if ( NULL == piowi) { <br> <br>            SetLastError( ERROR_NOT_ENOUGH_MEMORY); <br>            return (HSE_STATUS_ERROR); <br>        } <br> <br>        piowi-&gt;pecb = pecb; <br> <br>        // <br>        // Init Grand data holder, assign the first chunk(read-ahead chunk) <br>        // and update the index (cbRreadSoFar) of the grand data holder. <br>        // <br> <br>        hseStatus = DoInit( piowi); <br>         <br>        if ( HSE_STATUS_ERROR != hseStatus) { <br>             <br>            // <br>            // Now we are ready to do asynchronous readclient here <br>            // <br> <br>            hseStatus = DoAsyncReadClient( piowi); <br>         <br>            if (hseStatus != HSE_STATUS_PENDING) { <br> <br>                // <br>                //  When IO finishes, tell IIS we will end the <br>                //  session. Also clean up other resources here <br>                // <br> <br>                DoCleanUp( piowi); <br> <br>            } <br>         <br>        } <br> <br>    } <br>        <br>    return (hseStatus); <br>} <br> <br> <br> <br> <br>BOOL WINAPI <br>TerminateExtension(DWORD dwFlags) <br>/*++ <br> <br>Routine Description: <br> <br>This function is called when the WWW service is shutdown <br> <br>Arguments: <br> <br>dwFlags - HSE_TERM_ADVISORY_UNLOAD or HSE_TERM_MUST_UNLOAD <br> <br>Return Value: <br> <br>    TRUE <br> <br>--*/ <br>{ <br>    return TRUE; <br>} <br> <br> <br> <br> <br>DWORD <br>SendMSGToClient(IN LPEXTENSION_CONTROL_BLOCK  pecb, IN LPCSTR pszMsg) <br>/*++ <br> <br>Routine Description: <br> <br>    Prepare header, SendHeaderExInfo struct and write whatever <br>    message is intended to send to the client. <br> <br>Arguments: <br> <br>    pecb        - pointer to ECB containing parameters related to the request. <br>    pszMsg      - pointer to the body of the message that is sent to the content. <br> <br>Return Value: <br> <br>    HSE_STATUS_SUCCESS  or HSE_STATUS_ERROR <br> <br>--*/ <br>{ <br>    HSE_SEND_HEADER_EX_INFOSHEI; <br> <br>    BOOL    fReturn; <br>    DWORD   cbText; <br>    DWORD   hseStatus = HSE_STATUS_SUCCESS; <br>    CHAR    *pszText = NULL; <br>     <br>    CHAR    szStatus[] = "200 OK"; <br>    CHAR    szHeaderBase[] = "Content-type: text/html\r\n\r\n"; <br>     <br>    // <br>    //  Populate SendHeaderExInfo struct <br>    // <br>    //  NOTE we must send Content-Length header with correct  <br>    //  byte count in order for keep-alive to work. <br>    // <br>    // <br> <br>    SHEI.pszStatus = szStatus; <br>    SHEI.pszHeader = szHeaderBase; <br>    SHEI.cchStatus = lstrlen(szStatus); <br>    SHEI.cchHeader = lstrlen(szHeaderBase); <br>    SHEI.fKeepConn = FALSE; <br>     <br>    // <br>    //  Build page  <br>    // <br>     <br>    cbText = strlen("&lt;head&gt;&lt;title&gt;Simple Async Read Client Sample&lt;/title&gt;&lt;/head&gt;\n&lt;body&gt;&lt;/body&gt;\n") <br>             + strlen(pszMsg) <br>             + 1; <br> <br>    pszText = (PCHAR) AR_Allocate(pecb, cbText); <br> <br>    if ( NULL == pszText) { <br> <br>        SetLastError( ERROR_NOT_ENOUGH_MEMORY); <br>        return (HSE_STATUS_ERROR); <br>    } <br>     <br>    strcpy(pszText, "&lt;head&gt;&lt;title&gt;Simple Async Read Client Sample&lt;/title&gt;&lt;/head&gt;\n"); <br>    strcat(pszText, "&lt;body&gt;"); <br>    strcat(pszText, pszMsg); <br>    strcat(pszText, "&lt;/body&gt;\n"); <br>    cbText = (DWORD)strlen(pszText);  <br>         <br>    // <br>    // Send header and body text to client <br>    // <br> <br>    fReturn =  <br>    pecb-&gt;ServerSupportFunction( pecb-&gt;ConnID, <br>                                 HSE_REQ_SEND_RESPONSE_HEADER_EX,   <br>                                 &amp;SHEI, <br>                                 NULL, <br>                                 NULL)  <br>                                             <br>                                 &amp;&amp; <br> <br>    pecb-&gt;WriteClient( pecb-&gt;ConnID, <br>                       pszText, <br>                       &amp;cbText, <br>                       0 ); <br> <br>    if ( !fReturn)  { <br>        hseStatus = HSE_STATUS_ERROR; <br>    } <br> <br>     <br>    AR_Free( pecb, pszText); <br>     <br>    return ( hseStatus); <br>}  <br> <br> <br> <br> <br>DWORD <br>DoAsyncReadClient(IN PIOWI piowi) <br>/*++ <br> <br>Routine Description: <br> <br>    The caller of the asynchrnous read client. <br> <br>Arguments: <br> <br>    piowi       pointer to the work item <br>     <br>Return Value: <br> <br>    HSE_STATUS_SUCCESS  or <br>    HSE_STATUS_PENDING  or  <br>    HSE_STATUS_ERROR <br> <br>--*/ <br>{    <br>    BOOL    fReturn; <br>    BYTE    *pbData = NULL; <br>    CHAR    szTmp[MAX_BUF_SIZE]; <br>    DWORD   dwFlags; <br>    DWORD   cbTotalToRead = MAX_BUF_SIZE; <br>    DWORD   hseStatus =  HSE_STATUS_PENDING; <br>     <br>    // <br>    // Check if cbTotalBytes == cbAvailable <br>    // if so lpbData contains all the data sent by  <br>    // the client, and complete the session.  <br>    // <br> <br>    if (piowi-&gt;pecb-&gt;cbTotalBytes == piowi-&gt;pecb-&gt;cbAvailable) { <br>         <br>        // <br>        // Construct the report and write it to client <br>        // <br> <br>        pbData = (PBYTE) AR_Allocate(piowi-&gt;pecb, piowi-&gt;pecb-&gt;cbAvailable + MAX_BUF_SIZE); <br>             <br>        if ( NULL == pbData) { <br> <br>            SetLastError( ERROR_NOT_ENOUGH_MEMORY); <br>            return (HSE_STATUS_ERROR); <br>        } <br> <br>        wsprintf ( pbData, <br>                   g_szReport, <br>                   piowi-&gt;pecb-&gt;cbTotalBytes, <br>                   piowi-&gt;pecb-&gt;cbAvailable ); <br>                     <br>        strcat( pbData, piowi-&gt;pecb-&gt;lpbData);   <br> <br>        hseStatus = SendMSGToClient( piowi-&gt;pecb, pbData); <br> <br> <br>        AR_Free( piowi-&gt;pecb, pbData); <br>        DoCleanUp( piowi); <br>         <br>        return ( hseStatus); // HSE_STATUS_SUCCESS or HSE_STATUS_ERROR; <br>    } <br> <br>    // <br>    //  More to read... <br>    // <br> <br>    // <br>    //  Set a call back function and context that will  <br>    //  be used for handling asynchrnous IO operations. <br>    //  This only needs to set up once. <br>    // <br> <br>    fReturn = <br>    piowi-&gt;pecb-&gt;ServerSupportFunction( <br>                    piowi-&gt;pecb-&gt;ConnID, <br>                    HSE_REQ_IO_COMPLETION, <br>                    AsyncReadClientIoCompletion, <br>                    0, <br>                    (LPDWORD)piowi );   <br>     <br>    if ( !fReturn) { <br> <br>        wsprintf ( szTmp, "Problem occurred at ServerSupportFunction() sending HSE_REQ_IO_COMPLETION request."); <br>        SendMSGToClient( piowi-&gt;pecb, szTmp); <br>         <br>        return ( HSE_STATUS_ERROR); <br>    } <br>     <br> <br>    // <br>    //  Fire off the call to perform an asynchronus read from the client.  <br>    // <br>     <br>    //  <br>    // We need to first check if the size of the remaining chunk  <br>    // is less than MAX_BUF_SIZE, if so just read what is available,  <br>    // otherwise read MAX_BUF_SIZE bytes of data. <br>    //  <br> <br>    cbTotalToRead = piowi-&gt;pecb-&gt;cbTotalBytes - piowi-&gt;cbReadSoFar; <br>    if ( cbTotalToRead &gt; MAX_BUF_SIZE )  { <br> <br>        cbTotalToRead = MAX_BUF_SIZE; <br>    } <br> <br>    dwFlags = HSE_IO_ASYNC; <br>    fReturn =  <br>    piowi-&gt;pecb-&gt;ServerSupportFunction( <br>                        piowi-&gt;pecb-&gt;ConnID <br>                      , HSE_REQ_ASYNC_READ_CLIENT <br>                      , piowi-&gt;pbDATAFromClient + // append the new chunk to buffer, cbReadSoFar indexes <br>                        piowi-&gt;cbReadSoFar        // the byte right after the last written byte in the buffer <br>                      , &amp;cbTotalToRead <br>                      , &amp;dwFlags); <br> <br>    if (!fReturn) { <br>         <br>        wsprintf ( szTmp, "Problem occurred at ServerSupportFunction() sending HSE_REQ_ASYNC_READ_CLIENT request."); <br>        SendMSGToClient( piowi-&gt;pecb, szTmp); <br>         <br>        hseStatus = HSE_STATUS_ERROR; <br>    } <br> <br>    return ( hseStatus); // HSE_STATUS_PENDING or HSE_STATUS_ERROR; <br>     <br>} <br> <br>  <br> <br> <br>VOID WINAPI <br>AsyncReadClientIoCompletion( <br>            IN LPEXTENSION_CONTROL_BLOCK pECB, <br>            IN PVOID pContext, <br>            IN DWORD cbIO, <br>            IN DWORD dwError) <br>/*++ <br> <br>Routine Description: <br> <br>    This is the callback function for handling completions of asynchronous ReadClient. <br>    This function resubmits additional IO to read the next chunk of data from the  <br>    client. If there is no more data to read or problem during operation, this function  <br>    will inform IIS that it is about to end the request session. <br>     <br> <br>Arguments: <br> <br>    pecb        - extension control block <br>    pContext    - this is a IO_WORK_ITEM <br>    cbIO        - bytes just read <br>    dwError     - Win32 error status code <br> <br>fReturn Value: <br> <br>    None <br> <br>--*/ <br>{ <br>    BOOL    fReturn; <br>    BYTE    *pbData = NULL; <br>    CHAR    szTmp[MAX_BUF_SIZE]; <br>    DWORD   dwFlags; <br>    DWORD   cbTotalToRead; <br>     <br>    PIOWI   piowi = ( PIOWI) pContext; <br>    EXTENSION_CONTROL_BLOCK   * pecb = piowi-&gt;pecb; <br>     <br> <br>    if (ERROR_SUCCESS == dwError) { <br> <br>        // <br>        // Read successfully, so update current  <br>        // total bytes read (aka index of grand data holder) <br>        // <br> <br>        piowi-&gt;cbReadSoFar += cbIO;      <br>                                <br>        // <br>        // If they are equal, we finish reading all bytes from client <br>        // <br>         <br>        if ( piowi-&gt;cbReadSoFar == pecb-&gt;cbTotalBytes ) {  <br> <br>            // <br>            // Construct the report and write it to client <br>            // <br> <br>            pbData = (PBYTE) AR_Allocate( pecb, piowi-&gt;cbReadSoFar + MAX_BUF_SIZE); <br>                 <br>            if ( NULL == pbData) { <br> <br>                SetLastError( ERROR_NOT_ENOUGH_MEMORY); <br>                wsprintf ( szTmp, "Failed to allocate memory inside AsyncReadClientIoCompletion()."); <br>                SendMSGToClient( pecb, szTmp); <br>                 <br>                DoCleanUp( piowi); <br>  <br>                return; <br>            } <br>             <br>            wsprintf ( pbData, g_szReport, pecb-&gt;cbTotalBytes, piowi-&gt;cbReadSoFar ); <br>            piowi-&gt;pbDATAFromClient[piowi-&gt;cbReadSoFar] = 0;  <br>            strcat( pbData, piowi-&gt;pbDATAFromClient); <br>            SendMSGToClient( pecb, pbData); <br>             <br> <br>            AR_Free( piowi-&gt;pecb, pbData); <br>            DoCleanUp( piowi); <br>             <br>            return; <br>             <br>        } else { <br> <br>            //  <br>            // Still have more data to read...  <br>            //  <br>            // We need to first check if the size of the remaining chunk  <br>            // is less than MAX_BUF_SIZE, if so just read what is available,  <br>            // otherwise read MAX_BUF_SIZE bytes of data. <br>            //  <br> <br>            cbTotalToRead = pecb-&gt;cbTotalBytes - piowi-&gt;cbReadSoFar; <br>            if ( cbTotalToRead &gt; MAX_BUF_SIZE )  { <br> <br>                cbTotalToRead = MAX_BUF_SIZE; <br>            } <br>             <br>            //  <br>            // Fire off another call to perform an asynchronus read from the client.  <br>            // <br> <br>            dwFlags = HSE_IO_ASYNC; <br>            fReturn =  <br>            pecb-&gt;ServerSupportFunction( <br>                          pecb-&gt;ConnID <br>                        , HSE_REQ_ASYNC_READ_CLIENT <br>                        , piowi-&gt;pbDATAFromClient + // append the new chunk to buffer, cbReadSoFar indexes <br>                          piowi-&gt;cbReadSoFar        // the byte right after the last written byte in the buffer <br>                        , &amp;cbTotalToRead <br>                        , &amp;dwFlags); <br> <br>            if ( !fReturn) { <br>                wsprintf ( szTmp, "Problem occurred at ServerSupportFunction() sending HSE_REQ_ASYNC_READ_CLIENT request."); <br>                SendMSGToClient( pecb, szTmp); <br> <br>                DoCleanUp( piowi); <br>                 <br>                return; <br>            } <br> <br>        } <br>     <br>    } else { <br> <br>        // <br>        // Error on read <br>        // <br> <br>        SetLastError(dwError); <br>         <br>        DoCleanUp( piowi); <br>    } <br>         <br>    return; <br>         <br>} // AsyncReadClientIoCompletion <br> <br> <br> <br> <br>DWORD <br>DoInit(IN OUT PIOWI piowi) <br>/*++ <br> <br>Routine Description: <br> <br>    Initialize the  Grand data holder, assign the first chunk(read-ahead chunk) <br>    and update the index (cbRreadSoFar) of the grand data holder. <br>     <br>Arguments: <br> <br>    piowi       pointer to the work item <br> <br>fReturn Value: <br> <br>    HSE_STATUS_SUCCESS or HSE_STATUS_ERROR <br> <br>--*/ <br>{ <br> <br>    piowi-&gt;pbDATAFromClient =  <br>    (PBYTE) AR_Allocate( piowi-&gt;pecb, piowi-&gt;pecb-&gt;cbTotalBytes + MAX_BUF_SIZE); <br>     <br>    if ( NULL == piowi-&gt;pbDATAFromClient) { <br> <br>        SetLastError( ERROR_NOT_ENOUGH_MEMORY); <br>        return (HSE_STATUS_ERROR); <br>    } <br> <br>    // <br>    // The first chunk (read-ahead chunk) has arrived.   <br>    // <br>     <br>    strcpy ( piowi-&gt;pbDATAFromClient, piowi-&gt;pecb-&gt;lpbData); <br>    piowi-&gt;cbReadSoFar = piowi-&gt;pecb-&gt;cbAvailable; <br> <br>    return (HSE_STATUS_SUCCESS); <br>} <br> <br> <br> <br> <br>VOID <br>DoCleanUp(IN PIOWI piowi) <br>/*++ <br> <br>Routine Description: <br> <br>    End the session with IIS and clean up other previous allocated resources. <br>     <br>Arguments: <br> <br>    piowi       pointer to the work item <br> <br>fReturn Value: <br> <br>    None <br> <br>--*/ <br>{ <br>     <br>     <br>    if ( piowi-&gt;pbDATAFromClient != NULL) { <br> <br>        AR_Free( piowi-&gt;pecb, piowi-&gt;pbDATAFromClient); <br> <br>    } <br> <br>    piowi-&gt;pecb-&gt;ServerSupportFunction( piowi-&gt;pecb-&gt;ConnID, <br>                                        HSE_REQ_DONE_WITH_SESSION, <br>                                        NULL, <br>                                        NULL, <br>                                        NULL); <br> <br>    LocalFree( piowi); <br> <br>    return; <br> <br>} <br> <br> <br> <br> <br>LPVOID  <br>AR_Allocate(IN LPEXTENSION_CONTROL_BLOCK pecb, IN DWORD dwSize) <br>/*++ <br> <br>Routine Description: <br> <br>    Memory allocation routine. Two different Win32 API's to allocate <br>    bytes in memory, which is based on the number of bytes coming from  <br>    the client. If the size is greater than 1 M bytes VirtualAllocate is  <br>    used, otherwise HeapAllocate is used. <br>     <br>Arguments: <br> <br>    pecb        - pointer to ECB containing parameters related to the request. <br>    dwSize      - number of bytes to allocate <br> <br>fReturn Value: <br> <br>    Pointer to void <br> <br>--*/ <br>{ <br>    LPVOID pvData = NULL; <br>     <br> <br>    if ( pecb-&gt;cbTotalBytes &gt; MEM_ALLOC_THRESHOLD) { <br> <br>        pvData =  <br>        VirtualAlloc( NULL,  <br>                      dwSize, <br>                      MEM_RESERVE | MEM_COMMIT,  <br>                      PAGE_READWRITE); <br> <br>    } else { <br> <br>        pvData =  <br>        HeapAlloc( GetProcessHeap(),  <br>                   HEAP_ZERO_MEMORY, <br>                   dwSize); <br>                            <br>    } <br> <br>    return ( pvData); <br> <br>} <br> <br> <br> <br> <br>BOOL <br>AR_Free( IN LPEXTENSION_CONTROL_BLOCK pecb, IN LPVOID pvData) <br>/*++ <br> <br>Routine Description: <br> <br>    Freeing memory routine, a complementary routine to AR_Allocate.  <br>    Two different Win32 API's will be used to free up bytes in memory, <br>    which is based on the number of bytes coming from the client. If  <br>    the size is greater than 1 M bytes VirtualFree is used. Otherwise,  <br>    HeapFree is used. <br>     <br>Arguments: <br> <br>    pecb        - pointer to ECB containing parameters related to the request. <br>    pvData      - pointer to the data to be freed. <br> <br>fReturn Value: <br> <br>    TRUE or FALSE <br> <br>--*/ <br>{ <br>    BOOL fReturn = FALSE; <br> <br> <br>    if ( pecb-&gt;cbTotalBytes &gt; MEM_ALLOC_THRESHOLD) { <br>         <br>        fReturn = VirtualFree( pvData, 0, MEM_RELEASE); <br> <br>    } else { <br> <br>        fReturn = HeapFree( GetProcessHeap(), 0, pvData); <br>    } <br> <br>    return (fReturn); <br>} <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
