<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CTE_ENC.C</title>
<link disabled rel=stylesheet href=../../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context4159"></a>CTE_ENC.C</h2>
<pre><code>/*++ <br> <br>Copyright (c) 1997 Microsoft Corporation <br> <br>Module Name: <br> <br>    cte_enc.c <br> <br>Abstract: <br> <br>    This module contains routines implementing Chunked Transfer  <br>    Encoding (CTE) for ISAPI Extension DLLs. See Section 3.6  <br>    "Transfer Codings" of RFC 2068 for details. <br> <br>Functions: <br>    CteBeginWrite <br>    CteWrite <br>    CteEndWrite <br> <br>--*/ <br> <br> <br>#include "ctetest.h" <br> <br> <br>// <br>// Encoder context structure  <br>// <br> <br>typedef struct CTE_ENCODER_STRUCT { <br>    EXTENSION_CONTROL_BLOCK * pECB;         // a copy of current ECB pointer <br>    DWORD                     dwChunkSize;  // user-specified chunk size <br>    DWORD                     cbData;       // number of bytes in the buffer <br>    BYTE *                    pData;        // pointer to chunk data bytes <br>} CTE_ENCODER; <br> <br>// <br>// Chunk header consists of HEX string for the chunk size in bytes <br>// (DWORD needs up to 8 bytes in HEX), followed by CRLF, <br>// therefore the maximum chunk header size is 10 bytes. <br>// <br> <br>#define CTE_MAX_CHUNK_HEADER_SIZE 10 <br> <br>// <br>// Chunk data is always followed by CRLF <br>// <br> <br>#define CTE_MAX_ENCODING_OVERHEAD (CTE_MAX_CHUNK_HEADER_SIZE + 2) <br> <br>// <br>// Total encoder size includes: <br>//   the size of the encoder context structure itself, <br>//   the chunk data size, <br>//   the maximum encoding overhead (header and terminating CRLF) <br>// <br> <br>#define CTE_ENCODER_SIZE(dwChunkSize) \ <br>    (sizeof(CTE_ENCODER) + dwChunkSize + CTE_MAX_ENCODING_OVERHEAD) <br> <br> <br>  <br>HCTE_ENCODER <br>CteBeginWrite( <br>    IN EXTENSION_CONTROL_BLOCK * pECB, <br>    IN DWORD dwChunkSize <br>    )    <br>/*++ <br> <br>Purpose: <br> <br>    Allocate and initialize chunked transfer encoder context <br>     <br>Arguments:     <br> <br>    pECB - pointer to extension control as passed to HttpExtensionProc() <br>    dwChunkSize - the maximum size of the chunk to transmit <br> <br>Returns: <br>    encoder context handle, or  <br>    NULL if memory allocation failed or chunk size was zero <br>     <br>--*/ <br>{ <br>    HCTE_ENCODER h; <br> <br> <br>    // <br>    // reject zero-length chunk size <br>    // <br> <br>    if( dwChunkSize == 0 ) { <br>        SetLastError( ERROR_INVALID_PARAMETER ); <br>        return NULL; <br>    } <br> <br>    // <br>    // allocate context structure <br>    //  <br>     <br>    h = LocalAlloc( LMEM_FIXED, CTE_ENCODER_SIZE(dwChunkSize) ); <br> <br>    if( h != NULL ) { <br> <br>        // <br>        // initialize context structure <br>        // <br> <br>        h-&gt;pECB         = pECB; <br>        h-&gt;dwChunkSize  = dwChunkSize; <br>        h-&gt;cbData       = 0; <br> <br>        // <br>        // chunk data bytes follow the context structure itself  <br>        // and chunk header  <br>        // <br> <br>        h-&gt;pData = (BYTE *) h + sizeof( *h ) + CTE_MAX_CHUNK_HEADER_SIZE; <br> <br>        // <br>        // this is the CRLF which follows chunk size  <br>        // (and immediately precedes data) <br>        // <br> <br>        h-&gt;pData[-2] = '\r'; <br>        h-&gt;pData[-1] = '\n'; <br> <br>    } else { <br> <br>        SetLastError( ERROR_NOT_ENOUGH_MEMORY ); <br>    } <br> <br>    return h; <br>} <br> <br>  <br>static BOOL <br>CteSendChunk( <br>    IN HCTE_ENCODER h <br>) <br>/*++ <br> <br>Purpose:  <br> <br>    Send one chunk of data using ClientWrite()  <br>    &lt;hex encoded chunk size&gt;, CRLF, data bytes, if any, CRLF <br> <br>Arguments: <br> <br>    h - CTE Encoder handle     <br>       <br>Returns: <br> <br>    TRUE if WriteClient succeeded <br>    FALSE if WriteClient failed <br>     <br>--*/ <br>{ <br>    char szChunkLength[9]; <br>    DWORD cbChunkLength; <br>    BYTE *buf; <br>    DWORD cbToSend; <br>    BOOL success; <br> <br>    // <br>    // produce hex string of the number of bytes <br>    // and compute the length of this string <br>    // <br>    _itoa( h-&gt;cbData, szChunkLength, 16 );  <br>    cbChunkLength = strlen( szChunkLength ); <br> <br>    // <br>    // step back to make place for hex number and CRLF, <br>    // copy hex string to its location <br>    // <br> <br>    buf = h-&gt;pData - 2 - cbChunkLength; <br>    memmove( buf, szChunkLength, cbChunkLength ); <br> <br>    // <br>    // compute the number of bytes to send <br>    // (this includes chunk data size, hex string and CRLF) <br>    //  <br> <br>    cbToSend = h-&gt;cbData + cbChunkLength + 2; <br> <br>    // <br>    // append trailing CRLF right after the data bytes <br>    // <br>     <br>    buf[cbToSend++] = '\r'; <br>    buf[cbToSend++] = '\n'; <br> <br>    // <br>    // issue synchronous WriteClient and return result to the caller  <br>    // <br>     <br>    success = h-&gt;pECB-&gt;WriteClient( <br>                    h-&gt;pECB-&gt;ConnID,  <br>                    buf,  <br>                    &amp;cbToSend,  <br>                    HSE_IO_SYNC  <br>                    ); <br> <br>    // <br>    // reset buffer pointer <br>    // <br>     <br>    h-&gt;cbData = 0; <br> <br>    return success; <br>} <br> <br>  <br>BOOL <br>CteWrite( <br>    IN HCTE_ENCODER h, <br>    IN PVOID pData, <br>    IN DWORD cbData <br>) <br>/*++ <br> <br>Purpose: <br> <br>    Write specified number of data bytes to the chunk buffer. <br>    When the chunk buffer becomes full, call CteSendChunk()  <br>    to send it out. <br> <br>Arguments: <br> <br>    h - CTE Encoder handle  <br>    pData - pointer to data bytes  <br>    cbData - number of data bytes to send <br>     <br>Returns:     <br> <br>    TRUE if bytes were successfully written <br>    FALSE if WriteClient() failed <br>     <br>--*/ <br>{ <br>    DWORD cbToConsume; <br>    PBYTE pBytesToSend = (PBYTE) pData; <br> <br>    for( ;; ) { <br> <br>        // <br>        // compute the number of bytes to consume, <br>        // break out of the loop, if nothing is left <br>        // <br> <br>        cbToConsume = min( cbData, h-&gt;dwChunkSize - h-&gt;cbData ); <br> <br>        if( cbToConsume == 0 ) { <br>            break; <br>        } <br> <br>        // <br>        // move bytes to the buffer, advance pointers and counters <br>        // <br>         <br>        memmove( h-&gt;pData + h-&gt;cbData, pBytesToSend, cbToConsume ); <br> <br>        h-&gt;cbData += cbToConsume; <br>        pBytesToSend += cbToConsume; <br>        cbData -= cbToConsume; <br> <br>        // <br>        // if the chunk buffer is full, send it <br>        // <br>         <br>        if( h-&gt;cbData == h-&gt;dwChunkSize ) { <br>            if( !CteSendChunk( h ) ) { <br>                return FALSE; <br>            } <br>        } <br> <br>    } <br> <br>    return TRUE; <br>} <br> <br>  <br>BOOL  <br>CteEndWrite( <br>    IN HCTE_ENCODER h <br>) <br>/*++ <br> <br>Purpose: <br> <br>    Complete the transfer and release the encoder context <br> <br>Arguments: <br> <br>    h - CTE Encoder handle <br>     <br>Returns: <br> <br>    TRUE if transfer was successfully completed <br>    FALSE if WriteClient() failed <br>     <br>--*/  <br>{ <br>    BOOL success; <br> <br>    // <br>    // if there are some bytes in the chunk, send them <br>    // <br>     <br>    if( h-&gt;cbData ) { <br>        if( !CteSendChunk( h ) ) { <br>            return FALSE; <br>        } <br>    } <br>     <br>    // <br>    // send empty chunk (which means EOF) <br>    // <br>     <br>    success = CteSendChunk( h ); <br>     <br>    // <br>    // release chunk transfer context <br>    // <br> <br>    LocalFree( h ); <br>     <br>    return success; <br>} <br> <br> <br> <br> <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
