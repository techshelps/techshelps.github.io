<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>OPENF.C</title>
<link disabled rel=stylesheet href=../../../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context4173"></a>OPENF.C</h2>
<pre><code>/*++ <br> <br>   Copyright    (c)    1995-1997    Microsoft Corporation <br> <br>   Module  Name : <br> <br>      openf.c <br> <br>   Abstract: <br> <br>      This module implements a simple open file handle cache <br> <br>   Project: <br> <br>       ISAPI Extensions Sample DLL <br> <br>   Functions Exported: <br> <br> <br>   Note: <br>      THIS IS NOT ROBUST for REAL WORLD. <br>      I wrote this for testing the ISAPI Async IO processing. <br> <br>--*/ <br> <br> <br>/************************************************************ <br> *     Include Headers <br> ************************************************************/ <br> <br># include "openf.h" <br> <br> <br>/************************************************************ <br> *     Type definitions and Globals <br> ************************************************************/ <br> <br>// <br>// internal data structure for maintaining the list of open file handles. <br>// <br> <br>typedef struct _OPEN_FILE { <br>     <br>    HANDLE  hFile; <br>    struct _OPEN_FILE * pNext; <br>    LONG    nHits; <br>    LONG    nRefs; <br>    CHAR    rgchFile[MAX_PATH+1]; <br> <br>} OPEN_FILE, * LPOPEN_FILE; <br> <br> <br>LPOPEN_FILE g_pOpenFiles = NULL; <br>CRITICAL_SECTION g_csOpenFiles; <br>BOOL g_fIsNt = TRUE; <br> <br>// <br>// Set up global variables containing the flags for CreateFile <br>//  The flags can be masked for Windows 95 system <br>// <br> <br>DWORD  g_dwCreateFileShareMode =  <br>         (FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE); <br> <br>DWORD  g_dwCreateFileFlags =  <br>         (FILE_FLAG_SEQUENTIAL_SCAN | FILE_FLAG_OVERLAPPED); <br> <br>/************************************************************ <br> *    Functions  <br> ************************************************************/ <br> <br>  <br>DWORD <br>InitFileHandleCache(VOID) <br>/*++ <br> <br>  This function initializes the file handle cache. <br>  It should be called at the initialization time. <br> <br>  Arguments: <br>    None <br>   <br>  Returns: <br>    Win32 error code. NO_ERROR indicates that the call succeeded. <br>--*/ <br>{ <br>    OSVERSIONINFO  osInfo; <br>     <br>    InitializeCriticalSection( &amp;g_csOpenFiles); <br> <br>    // <br>    // obtain the platform type to find out how to open the file <br>    // <br> <br>    osInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO); <br> <br>    if ( GetVersionEx( &amp;osInfo ) ) { <br>        g_fIsNt = (osInfo.dwPlatformId == VER_PLATFORM_WIN32_NT); <br>    } <br> <br>    if ( !g_fIsNt) { <br> <br>        // <br>        // Reset the flags appropriately so that Windows 95 will be happy <br>        // <br> <br>        g_dwCreateFileShareMode = (FILE_SHARE_READ | FILE_SHARE_WRITE); <br>        g_dwCreateFileFlags     = (FILE_FLAG_SEQUENTIAL_SCAN); <br>    } <br> <br>    return (NO_ERROR); <br> <br>} // InitFileHandleCache() <br> <br> <br> <br>  <br>DWORD <br>CleanupFileHandleCache(VOID) <br>{ <br>    LPOPEN_FILE  pFileScan; <br> <br>    while ( g_pOpenFiles != NULL) { <br> <br>        pFileScan = g_pOpenFiles; <br>        g_pOpenFiles = g_pOpenFiles-&gt;pNext; <br> <br>        if ( pFileScan-&gt;hFile != INVALID_HANDLE_VALUE) { <br> <br>            CloseHandle( pFileScan-&gt;hFile); <br>        } <br> <br>        LocalFree( pFileScan); <br>    } <br> <br>    DeleteCriticalSection( &amp;g_csOpenFiles); <br> <br>    return (NO_ERROR); <br>} // CleanupFileHandleCache() <br> <br> <br> <br>  <br>HANDLE <br>FcOpenFile(IN EXTENSION_CONTROL_BLOCK * pecb, IN LPCSTR pszFile) <br>/*++ <br> <br> FcOpenFile() <br>  <br> Description: <br>   This function opens the file specified in the 'pszFile'.  <br>   If the file name starts with a '/' we use the ECB to map  <br>   the given path into a physical file path. <br> <br> Arguments: <br>  pecb - pointer to the ECB block <br>  pszFile - pointer to file name <br> <br> Returns: <br>   valid File handle on success <br>--*/ <br>{ <br>    LPOPEN_FILE  pFileScan; <br>    HANDLE hFile = INVALID_HANDLE_VALUE; <br> <br>    EnterCriticalSection( &amp;g_csOpenFiles); <br> <br>    for ( pFileScan =  g_pOpenFiles;  <br>         NULL != pFileScan;  <br>         pFileScan = pFileScan-&gt;pNext) { <br> <br>        if ( 0 == lstrcmpi( pFileScan-&gt;rgchFile, pszFile)) { <br> <br>            // <br>            //  there is a file match.  <br>            // <br> <br>            break; <br>        } <br> <br>    } // for <br> <br> <br>    if ( NULL == pFileScan) { <br> <br>        // <br>        // File was not found. Create a new file handle <br>        // <br> <br>        CHAR   rgchFileName[ MAX_PATH]; // local copy <br>        LPCSTR pszInputPath = pszFile; <br>         <br>        lstrcpyn( rgchFileName, pszFile, MAX_PATH); <br>        if ( *pszFile == '/') {  <br> <br>            DWORD cbSize = sizeof(rgchFileName); <br>            BOOL  fRet; <br> <br>            // reset the file pointer, so subsequent use will fail <br>            pszFile = NULL; <br> <br>            // <br>            // Using the ECB map the Virtual path to the Physical path <br>            // <br> <br>            fRet = pecb-&gt;ServerSupportFunction( pecb-&gt;ConnID, <br>                                                HSE_REQ_MAP_URL_TO_PATH, <br>                                                rgchFileName, <br>                                                &amp;cbSize, NULL); <br>             <br>            if (fRet) { <br>                // we got the mapping. Use it. <br>                pszFile = rgchFileName; <br>            } <br>        }    <br> <br>        if ( NULL != pszFile) { <br>            pFileScan = LocalAlloc( LPTR, sizeof( *pFileScan)); <br> <br>            if ( NULL != pFileScan) { <br>                 <br>                SECURITY_ATTRIBUTES sa; <br>                 <br>                sa.nLength              = sizeof(sa); <br>                sa.lpSecurityDescriptor = NULL; <br>                sa.bInheritHandle       = FALSE; <br>                 <br>                pFileScan-&gt;hFile =  <br>                    CreateFile( pszFile, <br>                                GENERIC_READ, <br>                                g_dwCreateFileShareMode, <br>                                &amp;sa, <br>                                OPEN_EXISTING, <br>                                g_dwCreateFileFlags, <br>                                NULL ); <br>                 <br>                if ( INVALID_HANDLE_VALUE == pFileScan-&gt;hFile) { <br>                     <br>                    LocalFree( pFileScan); <br>                    pFileScan = NULL; <br>                } else { <br>                     <br>                    // insert this into the list at the top <br>                    lstrcpyn( pFileScan-&gt;rgchFile, pszInputPath, MAX_PATH); <br>                    pFileScan-&gt;pNext = g_pOpenFiles; <br>                    g_pOpenFiles = pFileScan; <br>                    pFileScan-&gt;nRefs = 1; <br>                    pFileScan-&gt;nHits = 0; <br>                } <br>            } <br>        } <br>    } <br> <br>    if ( NULL != pFileScan) { <br> <br>        hFile = pFileScan-&gt;hFile; <br>        pFileScan-&gt;nHits++; <br>        pFileScan-&gt;nRefs++; <br>    } <br> <br>    LeaveCriticalSection( &amp;g_csOpenFiles); <br> <br>    return (hFile); <br> <br>} // FcOpenFile() <br> <br> <br>  <br>DWORD <br>FcCloseFile(IN HANDLE hFile) <br>{ <br>    LPOPEN_FILE  pFileScan; <br>    DWORD dwError = NO_ERROR; <br> <br>    EnterCriticalSection( &amp;g_csOpenFiles); <br> <br>    // <br>    // Look for the handle and decrement the ref count. <br>    //  <br>    for ( pFileScan =  g_pOpenFiles;  <br>         NULL != pFileScan;  <br>         pFileScan = pFileScan-&gt;pNext) { <br> <br>        if ( hFile == pFileScan-&gt;hFile) { <br> <br>            // <br>            //  there is a file match.  <br>            // <br> <br>            pFileScan-&gt;nRefs--; <br> <br>            // <br>            // BUGBUG: There is no freeing of the file when Ref hits '0' :( <br>            // <br> <br>            break; <br>        } <br> <br>    } // for <br> <br> <br>    if ( NULL == pFileScan) { <br>        // <br>        // file handle not found <br>        // <br>        dwError = ( ERROR_INVALID_HANDLE); <br>    } <br> <br>    LeaveCriticalSection( &amp;g_csOpenFiles); <br> <br> <br>    return ( dwError); <br> <br>} // FcCloseFile() <br> <br> <br> <br>  <br>BOOL <br>FcReadFromFile( <br>               IN  HANDLE hFile, <br>               OUT CHAR * pchBuffer, <br>               IN  DWORD  dwBufferSize, <br>               OUT LPDWORD  pcbRead, <br>               IN OUT LPOVERLAPPED  pov <br>               ) <br>/*++ <br>  Description: <br>    Reads contents of file [hFile] from the specified offset in the overlapped  <br>    structure. The contents are read into the buffer supplied. <br> <br>  Arguments: <br>    hFile        - handle for the File from which to read data <br>    pchBuffer    - pointer to the buffer into which the data is to be read <br>    dwBufferSize - DWORD containing the max size of the buffer supplied <br>    pcbRead      - number of bytes read from the file <br>    pov          - pointer to an overlapped structure that contains the  <br>                     offset from where to read the contents. The <br>                     overlapped structure also is used for Overlapped <br>                     IO in NT. <br> <br>  Notes: <br>   This function automatically handles both Windows 95 and NT <br>    <br> <br>  Returns: <br>    TRUE on success and FALSE if there is a failure. <br>    Use GetLastError() to get the last error code on failure. <br>--*/ <br>{ <br>    BOOL fRet = TRUE; <br> <br>    *pcbRead = 0; <br>     <br>    if ( !g_fIsNt ) { <br>        // <br>        // Windows95 does not support Overlapped IO. <br>        //  So we shall thunk it out and use Synchronous IO <br>        // <br>         <br>        fRet = (  <br>                SetFilePointer( hFile,  <br>                                pov-&gt;Offset, <br>                                NULL, <br>                                FILE_BEGIN) &amp;&amp; <br>                ReadFile( hFile, <br>                          pchBuffer, <br>                          dwBufferSize, <br>                          pcbRead, <br>                          NULL <br>                          ) <br>                ); <br>    } else { <br>             <br>            ResetEvent( pov-&gt;hEvent); <br> <br>            fRet = TRUE; <br> <br>            // read data from file <br>            if (!ReadFile(hFile, <br>                          pchBuffer, <br>                          dwBufferSize, <br>                          pcbRead, <br>                          pov <br>                          )) { <br>                 <br>                DWORD err = GetLastError(); <br>                 <br>                if ( (err != ERROR_IO_PENDING) || <br>                     !GetOverlappedResult( hFile, pov, <br>                                           pcbRead, TRUE)) { <br>                     <br>                    fRet = FALSE; <br>                } <br>            } <br>    } <br> <br>    if ( fRet) { <br>        pov-&gt;Offset += *pcbRead; <br>    } <br> <br>    return ( fRet); <br>} // FcReadFromFile() <br> <br>/************************ End of File ***********************/ </code></pre>
<p>&nbsp;</p></body>
</HTML>
