<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>HELPERS.H</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context4586"></a>HELPERS.H</h2>
<pre><code>//--------------------------------------------------------------------------- <br>// Helpers.h <br>//--------------------------------------------------------------------------- <br>// General OLE Automation helper functions. <br>//--------------------------------------------------------------------------- <br>// (C) Copyright 1995-1997 by Microsoft Corporation.  All rights reserved. <br>// <br>// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF  <br>// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO  <br>// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A  <br>// PARTICULAR PURPOSE. <br>//--------------------------------------------------------------------------- <br> <br> <br>//--------------------------------------------------------------------------- <br>// To make the OLE-related code easier to read <br>//--------------------------------------------------------------------------- <br>#define CHECK(x)       { hr = (x);  if (hr) { FAIL("Bad hr"); goto CleanUp; } } <br>#define CHECKSZ(x,sz)  { hr = (x);  if (hr) { FAIL(sz);       goto CleanUp; } } <br>#define CHECKCL(x)     { hr = (x);  if (hr) { FAIL("Bad hr"); goto CheckLoop; } } <br>#define ARGSZ(f,sz)    {            if (f)  { FAIL(sz);       return E_INVALIDARG; } } <br>#define CHECKOS(x) { if (ERROR_SUCCESS!=(x)) { FAIL("Bad"); hr=E_FAIL; goto CleanUp; } } <br> <br>#define RELEASEPTRTYPE(p,typ) \ <br>  {                           \ <br>    if (p)                    \ <br>      {                       \ <br>      typ *__punk = (p);      \ <br>      (p) = NULL;             \ <br>      __punk-&gt;Release();      \ <br>      }                       \ <br>  } <br> <br>#define RELEASEPTR(p)     RELEASEPTRTYPE(p,IUnknown) <br> <br> <br>//--------------------------------------------------------------------------- <br>// Allocates a temporary buffer that will disappear when it goes out of scope <br>// NOTE: Be careful of that-- make sure you use the string in the same or <br>// nested scope in which you created this buffer.  People should not use this <br>// class directly; use the macro(s) below. <br>//--------------------------------------------------------------------------- <br>class TempBuffer <br>  { <br>  public: <br>    TempBuffer(ULONG cb) <br>      { <br>      m_fAlloc = (cb &gt; 120); <br>      if (m_fAlloc) <br>        m_pbBuf = new char[cb]; <br>      else <br>        m_pbBuf = &amp;m_szBufT; <br>      } <br>    ~TempBuffer() <br>      { if (m_pbBuf &amp;&amp; m_fAlloc) delete m_pbBuf; } <br>    void *GetBuffer(void) <br>      { return m_pbBuf; } <br> <br>  private: <br>    void *m_pbBuf; <br>    char  m_szBufT[120];  // We'll use this temp buffer for small cases. <br>    int   m_fAlloc; <br>  }; <br> <br> <br>//--------------------------------------------------------------------------- <br>// String helpers. <br>//--------------------------------------------------------------------------- <br>// Given and ANSI String, copy it into a wide buffer. <br>// NOTE: Be careful about scoping when using this macro! <br>// <br>// How to use the below two macros: <br>// <br>//  ... <br>//  LPSTR pszA; <br>//  pszA = MyGetpszAnsiingRoutine(); <br>//  MAKE_WIDEPTR_FROMANSI(pwsz, pszA); <br>//  MyUseWideStringRoutine(pwsz); <br>//  ... <br>// <br>// Similarily for MAKE_ANSIPTR_FROMWIDE().  Note that the first param does <br>// not have to be declared, and no clean up must be done. <br>//--------------------------------------------------------------------------- <br>#define UNICODE_FROM_ANSI(pwszUnicode, pszAnsi, cb) \ <br>    MultiByteToWideChar(CP_ACP, 0, pszAnsi, -1, pwszUnicode, cb); <br> <br>#define MAKE_WIDEPTR_FROMANSI(ptrname, pszAnsi) \ <br>    char *__psz##ptrname = pszAnsi?pszAnsi:""; \ <br>    long __l##ptrname = (lstrlen(__psz##ptrname) + 1) * sizeof(WCHAR); \ <br>    TempBuffer __TempBuffer##ptrname(__l##ptrname); \ <br>    MultiByteToWideChar(CP_ACP, 0, __psz##ptrname, -1, (LPWSTR)__TempBuffer##ptrname.GetBuffer(), __l##ptrname); \ <br>    LPWSTR ptrname = (LPWSTR)__TempBuffer##ptrname.GetBuffer() <br> <br>#define MAKE_ANSIPTR_FROMWIDE(ptrname, pwszUnicode) \ <br>    WCHAR *__pwsz##ptrname = pwszUnicode?pwszUnicode:L""; \ <br>    long __l##ptrname = (lstrlenW(__pwsz##ptrname) + 1) * sizeof(char); \ <br>    TempBuffer __TempBuffer##ptrname(__l##ptrname); \ <br>    WideCharToMultiByte(CP_ACP, 0, __pwsz##ptrname, -1, (LPSTR)__TempBuffer##ptrname.GetBuffer(), __l##ptrname, NULL, NULL); \ <br>    LPSTR ptrname = (LPSTR)__TempBuffer##ptrname.GetBuffer() <br> <br>//--- EOF ------------------------------------------------------------------- </code></pre>
<p>&nbsp;</p></body>
</HTML>
