<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SPR.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context4596"></a>SPR.CPP</h2>
<pre><code>//--------------------------------------------------------------------------- <br>// Spr.cpp <br>//--------------------------------------------------------------------------- <br>// Sprite handler <br>//--------------------------------------------------------------------------- <br>// (C) Copyright 1992-1997 by Microsoft Corporation.  All rights reserved. <br>// <br>// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF  <br>// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO  <br>// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A  <br>// PARTICULAR PURPOSE. <br>//--------------------------------------------------------------------------- <br> <br>#include "Main.h" <br>#pragma hdrstop <br>#include "Spr.h" <br>#include &lt;math.h&gt; <br> <br> <br>//--------------------------------------------------------------------------- <br>// DEBUG info <br>//--------------------------------------------------------------------------- <br>SZTHISFILE <br> <br> <br>//--------------------------------------------------------------------------- <br>// Global Variables <br>//--------------------------------------------------------------------------- <br>ITypeInfo *g_ptinfoClsSpriteClass = NULL; <br>ITypeInfo *g_ptinfoIntSpriteClass = NULL; <br>ITypeInfo *g_ptinfoClsSprite      = NULL; <br>ITypeInfo *g_ptinfoIntSprite      = NULL; <br>HBITMAP    g_hbmpStock            = NULL; <br>HBRUSH     g_hbrushStock          = NULL; <br>HDC        g_hdcMem               = NULL; <br> <br> <br>//*************************************************************************** <br>//*************************************************************************** <br>//** <br>//**  Display Class <br>//** <br>//*************************************************************************** <br>//*************************************************************************** <br> <br>//--------------------------------------------------------------------------- <br>// Initialize display surface for sprites <br>//--------------------------------------------------------------------------- <br>CDisplay::CDisplay <br>( <br>  HINSTANCE  hinst, <br>  HWND       hwnd, <br>  HDC        hdc, <br>  IUnknown  *punkParent, <br>  PFNCOLLIDE pfnCollide, <br>  int        cimg, <br>  PIMG       prgimg, <br>  UINT       idbmp <br>) <br>{ <br>  RECT rect; <br> <br>  INIT_SIGNATURE(SIG_Display); <br> <br>  // Create an HDC and get the stock bitmap <br>  if (!g_hdcMem) <br>    { <br>    HBITMAP hbmp; <br> <br>    g_hdcMem = CreateCompatibleDC(NULL); <br>    hbmp = CreateCompatibleBitmap(g_hdcMem, 1, 1); <br>    g_hbmpStock = (HBITMAP)SelectObject(g_hdcMem, hbmp); <br>    SelectObject(g_hdcMem, g_hbmpStock); <br>    DeleteObject(hbmp); <br>    g_hbrushStock = (HBRUSH)GetStockObject(LTGRAY_BRUSH); <br>    } <br> <br>  // Stash away values &amp; init member variables <br>  m_hinst      = hinst; <br>  m_hdc        = hdc; <br>  GetClientRect(hwnd, &amp;rect); <br>  m_cx         = rect.right; <br>  m_cy         = rect.bottom; <br>  m_pfnCollide = pfnCollide; <br>  m_csc        = 0; <br>  m_cimg       = cimg; <br>  m_prgimg     = prgimg; <br>  m_idbmp      = idbmp; <br>  m_psprFirst  = NULL; <br>  m_psprLast   = NULL; <br>  m_punkParent = punkParent; <br>  m_hbmp       = NULL; <br>  m_hbrushBack = NULL; <br>  this-&gt;SetBackColor(0x00c0c0c0); <br>  m_hwnd       = hwnd; <br> <br>  // Compute animated images <br>  for (int i=0; i&lt;cimg; i++) <br>    if (prgimg[i].iimgNext != iimgNONE &amp;&amp; <br>        prgimg[i].iimgNext != iimgREMOVE) <br>      prgimg[i].pimgNext = &amp;prgimg[prgimg[i].iimgNext]; <br> <br>  // Load in all hbmp <br>  m_hbmp = LoadBitmap(m_hinst, MAKEINTRESOURCE(m_idbmp)); <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>// Terminate Sprite Sytem <br>//--------------------------------------------------------------------------- <br>CDisplay::~CDisplay <br>( <br>  void <br>) <br>{ <br>  CHECK_SIGNATURE(SIG_Display); <br> <br>  if (m_hbrushBack) <br>    { <br>    SelectObject(g_hdcMem, g_hbrushStock); <br>    DeleteObject(m_hbrushBack); <br>    m_hbrushBack = NULL; <br>    } <br> <br>  if (g_hdcMem) <br>    { <br>    SelectObject(g_hdcMem, g_hbmpStock); <br>    DeleteDC(g_hdcMem); <br>    g_hdcMem = NULL; <br>    } <br> <br>  if (m_hbmp) <br>    { <br>    // Delete all loaded bitmaps: <br>    DeleteObject((HGDIOBJ)m_hbmp); <br>    m_hbmp = (HBITMAP)NULL; <br>    } <br> <br>  DESTROY_SIGNATURE(SIG_Display); <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>// Free all sprites on Display. <br>//--------------------------------------------------------------------------- <br>void CDisplay::DestroyAll <br>( <br>  void <br>) <br>{ <br>  CSprite *pspr; <br> <br>  while (m_psprFirst) <br>    { <br>    pspr = m_psprFirst; <br>    pspr-&gt;_Unlink(FALSE); <br>    pspr-&gt;Release(); <br>    } <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>// Move all sprites on Display. <br>//--------------------------------------------------------------------------- <br>void CDisplay::Timer <br>( <br>  void <br>) <br>{ <br>  CSprite *pspr; <br>  CSprite *psprPrev; <br> <br>  for (pspr=m_psprLast; pspr; pspr=psprPrev) <br>    { <br>    psprPrev = pspr-&gt;m_psprPrev; <br> <br>    // Fire Tick event, if sprite exists <br>    if (!pspr-&gt;m_fFree) <br>      { <br>      if (--pspr-&gt;m_tickEvt &lt;= 0) <br>        { <br>        pspr-&gt;m_psc-&gt;FireTick(pspr); <br>        pspr-&gt;m_tickEvt = pspr-&gt;m_tickEvtMax; <br>        } <br>      } <br> <br>    // Move sprite, if it still exits (FireTick might have killed it.) <br>    if (!pspr-&gt;m_fFree) <br>      { <br>      if (--pspr-&gt;m_tickMove &lt;= 0) <br>        { <br>        long xOldFull; <br>        long yOldFull; <br> <br>        pspr-&gt;m_tickMove = pspr-&gt;m_tickMoveMax; <br> <br>        // Does this sprite have a "MoveAt" sprite attached? <br>        if (pspr-&gt;m_psprAt) <br>          pspr-&gt;DoMoveAt(pspr-&gt;m_psprAt, pspr-&gt;m_dMaxAt, pspr-&gt;m_scaleAt, pspr-&gt;m_flagsAt, TRUE); <br> <br>        xOldFull = pspr-&gt;m_xFull; <br>        yOldFull = pspr-&gt;m_yFull; <br>        if (HIWORD(xOldFull + pspr-&gt;m_vxFull) == HIWORD(xOldFull) &amp;&amp; <br>            HIWORD(yOldFull + pspr-&gt;m_vyFull) == HIWORD(yOldFull)) <br>          { <br>          // Movement was only fractional, so don't need to redraw sprite. <br>          pspr-&gt;m_xFull += pspr-&gt;m_vxFull; <br>          pspr-&gt;m_yFull += pspr-&gt;m_vyFull; <br>          } <br>        else <br>          { <br>          pspr-&gt;_Erase(); <br>          pspr-&gt;m_xFull += pspr-&gt;m_vxFull; <br>          pspr-&gt;m_yFull += pspr-&gt;m_vyFull; <br>          if (pspr-&gt;m_pimg-&gt;iimgNext == iimgREMOVE) <br>            pspr-&gt;Remove(); <br>          else if (pspr-&gt;m_pimg-&gt;iimgNext != iimgNONE) <br>            { <br>            pspr-&gt;m_iimg = pspr-&gt;m_pimg-&gt;iimgNext; <br>            pspr-&gt;m_pimg = pspr-&gt;m_pimg-&gt;pimgNext; <br>            } <br>          if (!pspr-&gt;_FDraw(TRUE)) <br>            { <br>            pspr-&gt;m_xFull = xOldFull; <br>            pspr-&gt;m_yFull = yOldFull; <br>            pspr-&gt;_FDraw(FALSE); <br>            } <br>          } <br> <br>        // Calculate Friction <br>        if (pspr-&gt;m_fFriction) <br>          { <br>          pspr-&gt;m_vxFull = (long)((FLOAT)pspr-&gt;m_vxFull * pspr-&gt;m_fx); <br>          pspr-&gt;m_vyFull = (long)((FLOAT)pspr-&gt;m_vyFull * pspr-&gt;m_fy); <br>          } <br> <br>        // Calculate AccelerationFriction <br>        if (pspr-&gt;m_psc-&gt;m_fFrictionAccel) <br>          { <br>          pspr-&gt;m_axFull = (long)((FLOAT)pspr-&gt;m_axFull * pspr-&gt;m_psc-&gt;m_frictionAccel); <br>          pspr-&gt;m_ayFull = (long)((FLOAT)pspr-&gt;m_ayFull * pspr-&gt;m_psc-&gt;m_frictionAccel); <br>          } <br> <br>        // Calculate Acceleration <br>        pspr-&gt;m_vxFull += pspr-&gt;m_axFull; <br>        pspr-&gt;m_vyFull += pspr-&gt;m_ayFull; <br> <br>        // Ensure Vel is not over max allowed for SpriteClass <br>        if (pspr-&gt;m_vxFull &gt; pspr-&gt;m_psc-&gt;m_vFullMax) <br>          pspr-&gt;m_vxFull = pspr-&gt;m_psc-&gt;m_vFullMax; <br>        else if (pspr-&gt;m_vxFull &lt; -pspr-&gt;m_psc-&gt;m_vFullMax) <br>          pspr-&gt;m_vxFull = -pspr-&gt;m_psc-&gt;m_vFullMax; <br>        if (pspr-&gt;m_vyFull &gt; pspr-&gt;m_psc-&gt;m_vFullMax) <br>          pspr-&gt;m_vyFull = pspr-&gt;m_psc-&gt;m_vFullMax; <br>        else if (pspr-&gt;m_vyFull &lt; -pspr-&gt;m_psc-&gt;m_vFullMax) <br>          pspr-&gt;m_vyFull = -pspr-&gt;m_psc-&gt;m_vFullMax; <br>        } <br>      } <br> <br>    if (pspr-&gt;m_fFree) <br>      { <br>      pspr-&gt;_Unlink(TRUE); <br>      pspr-&gt;Release(); <br>      } <br>    } <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>// Paint all sprites. <br>//--------------------------------------------------------------------------- <br>void CDisplay::Paint <br>( <br>  HDC hdc <br>) <br>{ <br>  CSprite *pspr; <br> <br>  if (hdc == NULL) <br>    hdc = m_hdc; <br> <br>  for (pspr=m_psprLast; pspr; pspr=pspr-&gt;m_psprPrev) <br>    { <br>    if (!pspr-&gt;m_fFree &amp;&amp; !pspr-&gt;m_fHidden) <br>      { <br>      SelectObject(g_hdcMem, m_hbmp); <br>      BitBlt(hdc, pspr-&gt;m_x, pspr-&gt;m_y, pspr-&gt;m_pimg-&gt;cx, pspr-&gt;m_pimg-&gt;cy, g_hdcMem, pspr-&gt;m_pimg-&gt;x, pspr-&gt;m_pimg-&gt;y, SRCCOPY); <br>      } <br>    } <br>  SelectObject(g_hdcMem, g_hbmpStock); <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>// Paint any sprites with fNeedRefresh set. <br>//--------------------------------------------------------------------------- <br>void CDisplay::Refresh <br>( <br>  void <br>) <br>{ <br>  CSprite *pspr; <br>  HDC   hdc = m_hdc; <br> <br>  for (pspr=m_psprLast; pspr; pspr=pspr-&gt;m_psprPrev) <br>    { <br>    if (pspr-&gt;m_fNeedRefresh &amp;&amp; !pspr-&gt;m_fHidden) <br>      { <br>      pspr-&gt;m_fNeedRefresh = FALSE; <br>      SelectObject(g_hdcMem, m_hbmp); <br>      BitBlt(hdc, pspr-&gt;m_x, pspr-&gt;m_y, pspr-&gt;m_pimg-&gt;cx, pspr-&gt;m_pimg-&gt;cy, g_hdcMem, pspr-&gt;m_pimg-&gt;x, pspr-&gt;m_pimg-&gt;y, SRCCOPY); <br>      } <br>    } <br>  SelectObject(g_hdcMem, g_hbmpStock); <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>// <br>//--------------------------------------------------------------------------- <br>void CDisplay::SetBackColor <br>( <br>  COLORREF c <br>) <br>{ <br>  static LOGBRUSH lb = {BS_SOLID, 0x00c0c0c0, 0}; <br> <br>  if (m_colorBack == c) <br>    return; <br>  m_colorBack = c; <br>  lb.lbColor = c; <br>  if (m_hbrushBack) <br>    DeleteObject(m_hbrushBack); <br>  m_hbrushBack = CreateBrushIndirect(&amp;lb); <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>// Send Collide event back to the fn passed into the constructor. <br>//--------------------------------------------------------------------------- <br>void CDisplay::FireCollide <br>( <br>  CSprite *psprLowId, <br>  CSprite *psprHighId, <br>  int      maskCollide <br>) <br>{ <br>  (*m_pfnCollide)(psprLowId, psprHighId, maskCollide); <br>} <br> <br> <br>//*************************************************************************** <br>//*************************************************************************** <br>//** <br>//**  SpriteClass Class <br>//** <br>//*************************************************************************** <br>//*************************************************************************** <br> <br>HRESULT s_hr = S_OK; <br> <br> <br>//--------------------------------------------------------------------------- <br>// Create function for SpriteClass.  Use instead of "new CSpriteClass". <br>//--------------------------------------------------------------------------- <br>HRESULT CSpriteClass::Create <br>( <br>  CDisplay      *pdisp, <br>  CSpriteClass **ppscOut <br>) <br>{ <br>  if (!ppscOut) <br>    return E_INVALIDARG; <br> <br>  *ppscOut = new CSpriteClass(pdisp); <br>  if (!*ppscOut) <br>    return E_OUTOFMEMORY; <br> <br>  return S_OK; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>// Constructor for SpriteClass <br>//--------------------------------------------------------------------------- <br>CSpriteClass::CSpriteClass <br>( <br>  CDisplay *pdisp <br>) <br>{ <br>  INIT_SIGNATURE(SIG_SpriteClass); <br> <br>  m_id              = ++(pdisp-&gt;m_csc); <br>  m_pdisp           = pdisp; <br>  m_brd             = SPR_brdALL; <br>  m_maskCollide     = 0; <br>  m_iimg            = 0; <br>  m_cspr            = 0; <br>  m_cref            = 1; <br>  m_pdispBaseObject = NULL; <br>  VariantInit(&amp;m_varTag); <br>  m_friction        = (FLOAT)1.0; <br>  m_frictionAccel   = (FLOAT)1.0; <br>  m_fFrictionAccel  = FALSE; <br>  m_vFullMax    = 0x000a0000; <br>  m_aFullMax    = 0x00010000; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>// Destructor for Sprite <br>//--------------------------------------------------------------------------- <br>void CSpriteClass::Close <br>( <br>  void <br>) <br>{ <br>  CHECK_SIGNATURE(SIG_SpriteClass); <br> <br>  CSprite *pspr; <br>  CSprite *psprPrev; <br> <br>  // Destroy all sprites of this SpriteClass <br>  for (pspr=m_pdisp-&gt;m_psprLast; pspr; pspr=psprPrev) <br>    { <br>    psprPrev = pspr-&gt;m_psprPrev; <br> <br>    if (pspr-&gt;m_psc == this) <br>      { <br>      pspr-&gt;_Unlink(FALSE); <br>      pspr-&gt;m_psc = NULL; <br>      pspr-&gt;Release(); <br>      } <br>    } <br> <br>  // Unadvise all event sinks <br>  m_cp.Close(); <br> <br>  // Clear incase this is an object <br>  VariantClear(&amp;m_varTag); <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>// Destructor for Sprite <br>//--------------------------------------------------------------------------- <br>CSpriteClass::~CSpriteClass <br>( <br>  void <br>) <br>{ <br>  CHECK_SIGNATURE(SIG_SpriteClass); <br>  this-&gt;Close(); <br>  DESTROY_SIGNATURE(SIG_SpriteClass); <br>} <br> <br> <br>//*************************************************************************** <br>// IUnknown Interface <br>//*************************************************************************** <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CSpriteClass::QueryInterface <br>( <br>  REFIID  iid, <br>  LPVOID* ppvObjOut <br>) <br>{ <br>  if (!ppvObjOut) <br>    return E_INVALIDARG; <br> <br>  *ppvObjOut = NULL; <br> <br>  if (iid == IID_IUnknown) <br>    *ppvObjOut = this-&gt;GetUnknown(); <br>  else if (iid == IID_IDispatch) <br>    *ppvObjOut = this-&gt;GetDispatch(); <br>  else if (iid == IID_ISpriteClass) <br>    *ppvObjOut = (ISpriteClass *)this; <br>  else if (iid == IID_IConnectionPointContainer) <br>    *ppvObjOut = (IConnectionPointContainer *)this; <br>  else if (iid == IID_IProvideClassInfo) <br>    *ppvObjOut = (IProvideClassInfo *)this; <br> <br>  if (*ppvObjOut) <br>    { <br>    this-&gt;AddRef(); <br>    return S_OK; <br>    } <br> <br>  return E_NOINTERFACE; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP_(ULONG) CSpriteClass::AddRef <br>( <br>  void  <br>) <br>{ <br>  return ++m_cref; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP_(ULONG) CSpriteClass::Release <br>( <br>  void  <br>) <br>{ <br>  ASSERT(m_cref, "bad m_cref"); <br>  m_cref--; <br>  if (!m_cref) <br>    { <br>    this-&gt;Close(); <br>    if (!m_cref &amp;&amp; !m_cp.m_cref) <br>      { <br>      delete this; <br>      return 0; <br>      } <br>    } <br>  return m_cref; <br>} <br> <br> <br>//*************************************************************************** <br>// IDispatch Interface <br>//*************************************************************************** <br> <br>//--------------------------------------------------------------------------- <br>// Method needed by COleAuto, so it can implement IDispatch for us. <br>//--------------------------------------------------------------------------- <br>HRESULT CSpriteClass::GetTypeLibInfo <br>( <br>  HINSTANCE    *phinstOut, <br>  const GUID  **pplibidOut,  <br>  SHORT        *pwMajLib,  <br>  SHORT        *pwMinLib, <br>  const CLSID **ppclsidOut,  <br>  const IID   **ppiidOut,  <br>  ITypeLib   ***ppptlOut <br>) <br>{ <br>  *phinstOut  = g_hinst; <br>  *pplibidOut = &amp;LIBID_SPRUUIDS; <br>  *pwMajLib   = 1; <br>  *pwMinLib   = 0; <br>  *ppclsidOut = &amp;CLSID_SpriteClass; <br>  *ppiidOut   = &amp;IID_ISpriteClass; <br>  *ppptlOut   = &amp;g_ptlMain; <br>  return S_OK; <br>} <br> <br> <br>//*************************************************************************** <br>// IProvideClassInfo Interface <br>//*************************************************************************** <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CSpriteClass::GetClassInfo <br>( <br>  ITypeInfo** pptinfoOut <br>) <br>{ <br>  HRESULT hr = ((COleAuto *)this)-&gt;CheckTypeInfo(0, 0x0409); <br>  if (hr) <br>    return hr; <br>  *pptinfoOut = g_ptinfoClsSpriteClass; <br>  (*pptinfoOut)-&gt;AddRef(); <br>  return S_OK; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CSpriteClass::GetGUID <br>( <br>  DWORD dwGuidKind, <br>  GUID* pGUID <br>) <br>{ <br>  if (pGUID) <br>    return E_INVALIDARG; <br> <br>  if (dwGuidKind != GUIDKIND_DEFAULT_SOURCE_DISP_IID) <br>    return E_INVALIDARG; <br> <br>  *pGUID = DIID_ISpriteClassEvents; <br>  return S_OK; <br>} <br> <br> <br>//*************************************************************************** <br>// IConnectionPointContainer Interface <br>//*************************************************************************** <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CSpriteClass::EnumConnectionPoints <br>( <br>  LPENUMCONNECTIONPOINTS* ppEnum <br>) <br>{ <br>  return E_NOTIMPL;   // UNDONE: Implement this method <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CSpriteClass::FindConnectionPoint <br>( <br>  REFIID             iid, <br>  LPCONNECTIONPOINT* ppCpOut <br>) <br>{ <br>  if (!ppCpOut) <br>    return E_INVALIDARG; <br> <br>  if (iid == DIID_ISpriteClassEvents || iid == IID_IDispatch) <br>    { <br>    *ppCpOut = &amp;m_cp; <br>    (*ppCpOut)-&gt;AddRef(); <br>    return S_OK; <br>    } <br>     <br>  return E_NOINTERFACE; <br>} <br> <br> <br>//*************************************************************************** <br>// Embedded IConnectionPoint Class <br>//*************************************************************************** <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>CSpriteClass::XCP::XCP <br>( <br>  void <br>) <br>{ <br>  m_cref = 1; <br>  for (int i=0; i&lt;SC_cADVISE; i++) <br>    m_rgpdisp[i] = NULL; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>void CSpriteClass::XCP::Close <br>( <br>  void <br>) <br>{ <br>  for (int i=0; i&lt;SC_cADVISE; i++) <br>    if (m_rgpdisp[i]) <br>      { <br>      m_rgpdisp[i]-&gt;Release(); <br>      m_rgpdisp[i] = NULL; <br>      } <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CSpriteClass::XCP::QueryInterface <br>( <br>  REFIID  iid, <br>  LPVOID* ppvObjOut <br>) <br>{ <br>  if (!ppvObjOut) <br>    return E_INVALIDARG; <br> <br>  *ppvObjOut = NULL; <br> <br>  if (iid == IID_IUnknown) <br>    *ppvObjOut = this-&gt;GetUnknown(); <br>  else if (iid == IID_IConnectionPoint) <br>    *ppvObjOut = (IConnectionPoint *)this; <br> <br>  if (*ppvObjOut) <br>    { <br>    this-&gt;AddRef(); <br>    return S_OK; <br>    } <br> <br>  return E_NOINTERFACE; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP_(ULONG) CSpriteClass::XCP::AddRef <br>( <br>  void  <br>) <br>{ <br>  return ++m_cref; <br>} <br> <br> <br>#define SCOFCP(pcp)  ((CSpriteClass *)((char *)pcp - (char *)&amp;(((CSpriteClass *)0)-&gt;m_cp))) <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP_(ULONG) CSpriteClass::XCP::Release <br>( <br>  void  <br>) <br>{ <br>  CSpriteClass *psc = SCOFCP(this); <br> <br>  ASSERT(m_cref, "bad m_cref"); <br>  m_cref--; <br>  if (!m_cref &amp;&amp; !psc-&gt;m_cref) <br>    { <br>    delete psc; <br>    return 0; <br>    } <br>  return m_cref; <br>} <br> <br> <br>//*************************************************************************** <br>// IConnectionPoint Interface <br>//*************************************************************************** <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CSpriteClass::XCP::GetConnectionInterface <br>( <br>  IID* piid <br>) <br>{ <br>  if (!piid) <br>    return E_INVALIDARG; <br> <br>  memcpy(piid, &amp;DIID_ISpriteClassEvents, sizeof(IID)); <br>  return S_OK; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CSpriteClass::XCP::GetConnectionPointContainer <br>( <br>  IConnectionPointContainer** ppCpcOut <br>) <br>{ <br>  if (!ppCpcOut) <br>    return E_INVALIDARG; <br> <br>  *ppCpcOut = SCOFCP(this); <br>  (*ppCpcOut)-&gt;AddRef(); <br>  return S_OK; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CSpriteClass::XCP::Advise <br>( <br>  IUnknown* punkSink, <br>  DWORD*    pdwCookie <br>) <br>{ <br>  IDispatch  *psce = NULL; <br>  IDispatch **ppdisp; <br>  HRESULT     hr; <br> <br>  if (!punkSink || !pdwCookie) <br>    return E_INVALIDARG; <br>  *pdwCookie = 0; <br> <br>  // Look for empty slot <br>  for (ppdisp=m_rgpdisp; *ppdisp &amp;&amp; ppdisp&lt;&amp;m_rgpdisp[SC_cADVISE]; ppdisp++) <br>    ; <br>  // Did we find one? <br>  if (ppdisp &gt;= &amp;m_rgpdisp[SC_cADVISE]) <br>    return E_FAIL;          // UNDONE: Error? <br> <br>  // Now see if sink supports correct interface <br>  hr = punkSink-&gt;QueryInterface(DIID_ISpriteClassEvents, (void **)&amp;psce); <br>  if (hr == E_NOINTERFACE) <br>    { <br>    hr = punkSink-&gt;QueryInterface(IID_IDispatch, (void **)&amp;psce); <br>    if (hr) <br>      return hr; <br>    } <br>  ASSERT(psce, "QI but no ptr"); <br> <br>  // Finish advise by stashing punkSink QI'd to our interface <br>  *ppdisp = psce;       // AddRef'd from QI <br>  *pdwCookie = (ppdisp - m_rgpdisp) + 1; <br> <br>  return S_OK; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CSpriteClass::XCP::Unadvise <br>( <br>  DWORD dwCookie <br>) <br>{ <br>  if (!dwCookie || dwCookie &gt; SC_cADVISE) <br>    return E_INVALIDARG; <br> <br>  m_rgpdisp[dwCookie-1]-&gt;Release(); <br>  m_rgpdisp[dwCookie-1] = NULL; <br>  return S_OK; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CSpriteClass::XCP::EnumConnections <br>( <br>  LPENUMCONNECTIONS* ppEnum <br>) <br>{ <br>  return E_NOTIMPL;   // UNDONE: Implement this method <br>} <br> <br> <br> <br>//*************************************************************************** <br>//*************************************************************************** <br>//** <br>//**  Sprite Class <br>//** <br>//*************************************************************************** <br>//*************************************************************************** <br> <br>//--------------------------------------------------------------------------- <br>// Constructor for Sprite <br>//--------------------------------------------------------------------------- <br>CSprite::CSprite <br>( <br>  CSpriteClass *psc, <br>  int           x, <br>  int           y, <br>  CSprite      *psprPrev,  // NULL==1st, -1==Last <br>  VARIANT      *pvarUser <br>) <br>{ <br>  INIT_SIGNATURE(SIG_Sprite); <br> <br>  m_pdisp        = psc-&gt;m_pdisp; <br>  m_psprNext     = NULL; <br>  m_psprPrev     = psprPrev; <br>  m_xFull        = 0; <br>  m_x            = x; <br>  m_yFull        = 0; <br>  m_y            = y; <br>  m_vxFull       = 0; <br>  m_vyFull       = 0; <br>  m_axFull       = 0; <br>  m_ayFull       = 0; <br>  m_fx           = psc-&gt;m_friction; <br>  m_fy           = psc-&gt;m_friction; <br>  m_fFriction    = (psc-&gt;m_friction != 1.0); <br>  m_tickEvt      = 0x7fffffff; <br>  m_tickEvtMax   = 0x7fffffff; <br>  m_tickMove     = 1; <br>  m_tickMoveMax  = 1; <br>  m_iimg         = psc-&gt;m_iimg; <br>  m_pimg         = &amp;m_pdisp-&gt;m_prgimg[m_iimg]; <br>  m_psc          = psc; <br>  m_fNeedRefresh = TRUE; <br>  m_fFree        = FALSE; <br>  m_fIgnoreMove  = FALSE; <br>  m_fLinked      = FALSE; <br>  m_fHidden      = 2;     // Set to 2 instead of TRUE to detect if user explicitly hides it during _Init event <br>  m_cref         = 1; <br>  m_psprAt       = NULL; <br>  m_pdispBaseObject = NULL; <br>  VariantInit(&amp;m_varTag); <br>  this-&gt;_Link(); <br> <br>  m_psc-&gt;FireInit(this, pvarUser); <br>  if (m_fHidden == 2)  <br>    m_fHidden = FALSE;    // If not explicitly hidden in event, show it <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>// Destructor for Sprite <br>//--------------------------------------------------------------------------- <br>CSprite::~CSprite <br>( <br>  void <br>) <br>{ <br>  CHECK_SIGNATURE(SIG_Sprite); <br>  VariantClear(&amp;m_varTag); <br>  if (m_psprAt) <br>    { <br>    m_psprAt-&gt;Release(); <br>    m_psprAt = NULL; <br>    } <br>  this-&gt;_Unlink(TRUE); <br>  DESTROY_SIGNATURE(SIG_Sprite); <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>// Change the class of an existing pspr <br>//--------------------------------------------------------------------------- <br>CSprite *CSprite::PsprMutate <br>( <br>  CSpriteClass *psc, <br>  VARIANT      *pvarUser <br>) <br>{ <br>  m_x          += m_pimg-&gt;cx &gt;&gt; 1; <br>  m_y          += m_pimg-&gt;cy &gt;&gt; 1; <br>  m_iimg        = psc-&gt;m_iimg; <br>  m_pimg        = &amp;m_pdisp-&gt;m_prgimg[m_iimg]; <br>  m_x          -= m_pimg-&gt;cx &gt;&gt; 1; <br>  m_y          -= m_pimg-&gt;cy &gt;&gt; 1; <br>  m_psc-&gt;m_cspr--; <br>  m_psc         = psc; <br>  m_psc-&gt;m_cspr++; <br>  m_tickEvt     = 0x7fffffff; <br>  m_tickEvtMax  = 0x7fffffff; <br>  m_tickMove    = 0; <br>  m_tickMoveMax = 1; <br>  m_fHidden     = 2;     // Set to 2 instead of TRUE to detect if user explicitly hides it during _Init event <br>   <br>  m_psc-&gt;FireInit(this, pvarUser); <br>  if (m_fHidden == 2)  <br>    m_fHidden = FALSE;    // If not explicitly hidden in event, show it <br>  return this; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>// Free a SPR structure <br>//--------------------------------------------------------------------------- <br>void CSprite::MarkFree <br>( <br>  void <br>) <br>{ <br>  if (m_psprAt) <br>    { <br>    m_psprAt-&gt;Release(); <br>    m_psprAt = NULL; <br>    } <br>  m_psc-&gt;FireTerm(this); <br>  m_fFree = TRUE; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>// Link a sprite into the display list <br>//--------------------------------------------------------------------------- <br>void CSprite::_Link <br>( <br>  void <br>) <br>{ <br>  if (!m_psprPrev) <br>    { <br>    m_psprNext = m_pdisp-&gt;m_psprFirst; <br>    m_pdisp-&gt;m_psprFirst = this; <br>    if (m_psprNext) <br>      m_psprNext-&gt;m_psprPrev = this; <br>    if (!m_pdisp-&gt;m_psprLast) <br>      m_pdisp-&gt;m_psprLast = this; <br>    } <br>  else if (m_psprPrev == (CSprite *)-1) <br>    { <br>    m_psprNext = NULL; <br>    m_psprPrev = m_pdisp-&gt;m_psprLast; <br>    if (m_pdisp-&gt;m_psprLast) <br>      m_pdisp-&gt;m_psprLast-&gt;m_psprNext = this; <br>    else <br>      m_pdisp-&gt;m_psprFirst = this; <br>    m_pdisp-&gt;m_psprLast = this; <br>    } <br>  else <br>    { <br>    // UNDONE: Fix this up. <br>    m_psprNext = m_pdisp-&gt;m_psprLast-&gt;m_psprNext; <br>    m_pdisp-&gt;m_psprLast-&gt;m_psprNext = this; <br>    m_psprNext-&gt;m_psprPrev = this; <br>    if (m_pdisp-&gt;m_psprLast == m_pdisp-&gt;m_psprLast) <br>      m_pdisp-&gt;m_psprLast = this; <br>    } <br> <br>  m_fLinked = TRUE; <br>  m_psc-&gt;m_cspr++; <br>  //this-&gt;_FDraw(FALSE);      // Require "s.Refresh" to avoid spurious paint before img set <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>// Unlink a sprite into the display list <br>//--------------------------------------------------------------------------- <br>void CSprite::_Unlink <br>( <br>  BOOL fFireEvt <br>) <br>{ <br>  if (!m_fLinked) <br>    return; <br> <br>  this-&gt;_Erase(); <br> <br>  if (m_pdisp-&gt;m_psprFirst == this) <br>    m_pdisp-&gt;m_psprFirst = m_psprNext; <br>  if (m_pdisp-&gt;m_psprLast  == this) <br>    m_pdisp-&gt;m_psprLast  = m_psprPrev; <br> <br>  if (m_psprPrev) <br>    m_psprPrev-&gt;m_psprNext = m_psprNext; <br>  if (m_psprNext) <br>    m_psprNext-&gt;m_psprPrev = m_psprPrev; <br> <br>  m_fLinked = FALSE; <br>  m_fHidden = TRUE; <br> <br>  // Track # of sprites of this kind.  If there are no more, then <br>  // fire the _LastTerm event. <br>  m_psc-&gt;m_cspr--; <br>  if (fFireEvt &amp;&amp; !m_psc-&gt;m_cspr) <br>    m_psc-&gt;FireLastTerm(); <br> <br>  if (m_psprAt) <br>    { <br>    m_psprAt-&gt;Release(); <br>    m_psprAt = NULL; <br>    } <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>// Draw the given sprite <br>//--------------------------------------------------------------------------- <br>BOOL CSprite::_FDraw <br>( <br>  BOOLfCollide <br>) <br>{ <br>  CSprite *psprT; <br>  CSprite *psprNext; <br>  int x   = m_x; <br>  int y   = m_y; <br>  int cx  = m_pimg-&gt;cx; <br>  int cy  = m_pimg-&gt;cy; <br>  HDC hdc = m_pdisp-&gt;m_hdc; <br> <br>  if (fCollide &amp;&amp; !m_fFree) <br>    { <br>    int maskCollide = m_psc-&gt;m_maskCollide; <br> <br>    if (m_fHidden) <br>      goto DoneWithColl; <br> <br>    for (psprT=m_pdisp-&gt;m_psprFirst; psprT; psprT=psprNext) <br>      { <br>      psprNext = psprT-&gt;m_psprNext; <br>      if (psprT != this &amp;&amp;                                    // Never collide w/self <br>          ((psprT-&gt;m_psc != m_psc) || (maskCollide &amp; 1)) &amp;&amp;   // Coll w/like kind only if bit 1 set </code></pre>
<p>
</p>
<pre><code>(maskCollide &amp; psprT-&gt;m_psc-&gt;m_maskCollide &amp; ~1) &amp;&amp; // Coll w/other kinds only if masks overlap <br>          x &lt;= psprT-&gt;m_x+psprT-&gt;m_pimg-&gt;cx &amp;&amp; x+cx &gt;= psprT-&gt;m_x &amp;&amp; // Coll only if actually touch <br>          y &lt;= psprT-&gt;m_y+psprT-&gt;m_pimg-&gt;cy &amp;&amp; y+cy &gt;= psprT-&gt;m_y) <br>        { <br>        m_fIgnoreMove = FALSE; <br>        if (m_psc-&gt;m_id &lt;= psprT-&gt;m_psc-&gt;m_id) <br>          m_pdisp-&gt;FireCollide(this, psprT, maskCollide &amp; psprT-&gt;m_psc-&gt;m_maskCollide); <br>        else <br>          m_pdisp-&gt;FireCollide(psprT, this, maskCollide &amp; psprT-&gt;m_psc-&gt;m_maskCollide); <br>        if (m_fFree) <br>          return TRUE; <br>        if (m_fIgnoreMove) <br>          return FALSE; <br>        if (psprT-&gt;m_fFree) <br>          goto DoneWithColl; <br>        } <br>      } <br>DoneWithColl:; <br>    if ((m_psc-&gt;m_brd &amp; SPR_brdALL)) <br>      { <br>      BRD brd = 0; <br>      if (m_psc-&gt;m_brd &amp; SPR_brdIN) <br>        { <br>        if (x &lt; 0) brd= SPR_brdINLEFT; <br>        if (y &lt; 0) brd |= SPR_brdINTOP; <br>        if (x+cx &gt; m_pdisp-&gt;m_cx) brd |= SPR_brdINRIGHT; <br>        if (y+cy &gt; m_pdisp-&gt;m_cy) brd |= SPR_brdINBOTTOM; <br>        } <br>      if (m_psc-&gt;m_brd &amp; SPR_brdOUT) <br>        { <br>        if (x+cx &lt; 0) brd  = SPR_brdOUTLEFT; <br>        if (y+cy &lt; 0) brd |= SPR_brdOUTTOP; <br>        if (x &gt; m_pdisp-&gt;m_cx) brd |= SPR_brdOUTRIGHT; <br>        if (y &gt; m_pdisp-&gt;m_cy) brd |= SPR_brdOUTBOTTOM; <br>        } <br>      if (brd) <br>        { <br>        m_fIgnoreMove = FALSE; <br>        m_psc-&gt;FireBorder(this, brd); <br> <br>        if (m_fFree) <br>          return TRUE; <br>        if (m_fIgnoreMove) <br>          return FALSE; <br>        } <br>      } <br>    } <br> <br>  // Don't draw if not visible <br>  if (m_fHidden) <br>    return TRUE; <br> <br>  SelectObject(g_hdcMem, m_pdisp-&gt;m_hbmp); <br>  BitBlt(hdc, m_x, m_y, cx, cy, g_hdcMem, m_pimg-&gt;x, m_pimg-&gt;y, SRCCOPY); <br>  m_fNeedRefresh = FALSE; <br>  for (psprT=m_psprPrev; psprT; psprT=psprT-&gt;m_psprPrev) <br>    { <br>    if (!psprT-&gt;m_fNeedRefresh &amp;&amp; <br>        x &lt;= psprT-&gt;m_x+psprT-&gt;m_pimg-&gt;cx &amp;&amp; x+cx &gt;= psprT-&gt;m_x &amp;&amp; <br>        y &lt;= psprT-&gt;m_y+psprT-&gt;m_pimg-&gt;cy &amp;&amp; y+cy &gt;= psprT-&gt;m_y) <br>      { <br>      psprT-&gt;m_fNeedRefresh = TRUE; <br>      } <br>    } <br>  SelectObject(g_hdcMem, g_hbmpStock); <br>  return TRUE; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>// Erase the given sprite <br>//--------------------------------------------------------------------------- <br>void CSprite::_Erase <br>( <br>  void <br>) <br>{ <br>  int      x   = m_x; <br>  int      y   = m_y; <br>  int      cx  = m_pimg-&gt;cx; <br>  int      cy  = m_pimg-&gt;cy; <br>  HDC      hdc = m_pdisp-&gt;m_hdc; <br>  CSprite *psprT; <br> <br>  SelectObject(hdc, (HGDIOBJ)(m_pdisp-&gt;m_hbrushBack ? m_pdisp-&gt;m_hbrushBack : g_hbrushStock)); <br>  PatBlt(hdc, m_x, m_y, cx, cy, PATCOPY); <br>  for (psprT=m_pdisp-&gt;m_psprLast; psprT; psprT=psprT-&gt;m_psprPrev) <br>    { <br>    if (psprT != this &amp;&amp; !psprT-&gt;m_fNeedRefresh &amp;&amp; <br>        x &lt;= psprT-&gt;m_x+psprT-&gt;m_pimg-&gt;cx &amp;&amp; x+cx &gt;= psprT-&gt;m_x &amp;&amp; <br>        y &lt;= psprT-&gt;m_y+psprT-&gt;m_pimg-&gt;cy &amp;&amp; y+cy &gt;= psprT-&gt;m_y) <br>      psprT-&gt;m_fNeedRefresh = TRUE; <br>    } <br>  SelectObject(g_hdcMem, g_hbrushStock); <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>// Move the given sprite to new location <br>//--------------------------------------------------------------------------- <br>BOOL CSprite::MoveToFull <br>( <br>  longxFull, <br>  longyFull, <br>  BOOLfCollide <br>) <br>{ <br>  long xOldFull = m_xFull; <br>  long yOldFull = m_yFull; <br> <br>  this-&gt;_Erase(); <br>  m_xFull = xFull; <br>  m_yFull = yFull; <br>  if (m_pimg-&gt;iimgNext == iimgREMOVE) <br>    this-&gt;Remove(); <br>  else if (m_pimg-&gt;iimgNext != iimgNONE) <br>    { <br>    m_iimg = m_pimg-&gt;iimgNext; <br>    m_pimg = m_pimg-&gt;pimgNext; <br>    } <br>  if (!this-&gt;_FDraw(fCollide)) <br>    { <br>    m_xFull = xOldFull; <br>    m_yFull = yOldFull; <br>    this-&gt;_FDraw(FALSE); <br>    return FALSE; <br>    } <br>  return TRUE; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>// Move the given sprite to new location <br>//--------------------------------------------------------------------------- <br>BOOL CSprite::MoveByFull <br>( <br>  longdxFull, <br>  longdyFull, <br>  BOOLfCollide <br>) <br>{ <br>  long xOldFull = m_xFull; <br>  long yOldFull = m_yFull; <br> <br>  if (HIWORD(xOldFull + dxFull) == HIWORD(xOldFull) &amp;&amp; <br>      HIWORD(yOldFull + dyFull) == HIWORD(yOldFull)) <br>    { <br>    m_xFull += dxFull; <br>    m_yFull += dyFull; <br>    return TRUE; <br>    } <br> <br>  this-&gt;_Erase(); <br>  m_xFull += dxFull; <br>  m_yFull += dyFull; <br>  if (m_pimg-&gt;iimgNext == iimgREMOVE) <br>    this-&gt;Remove(); <br>  else if (m_pimg-&gt;iimgNext != iimgNONE) <br>    { <br>    m_iimg = m_pimg-&gt;iimgNext; <br>    m_pimg = m_pimg-&gt;pimgNext; <br>    } <br> <br>  if (!this-&gt;_FDraw(fCollide)) <br>    { <br>    m_xFull = xOldFull; <br>    m_yFull = yOldFull; <br>    this-&gt;_FDraw(FALSE); <br>    return FALSE; <br>    } <br>  return TRUE; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>// flags: 1=X, 2=Y; <br>//        4=Pos, 8=Vel, 16=Accel; <br>//        32=Less With Distance (default=More); <br>//        128=Remember <br>//--------------------------------------------------------------------------- <br>BOOL CSprite::DoMoveAt <br>( <br>  CSprite *psprAt, <br>  float    scale, <br>  float    dMax, <br>  long     flags, <br>  BOOL     fCollide <br>) <br>  { <br>  long dx = psprAt-&gt;m_xFull - m_xFull; <br>  long dy = psprAt-&gt;m_yFull - m_yFull; <br> <br>  if (flags &amp; MAS_RECIPDIST) <br>    { <br>    dx = FULLOFFLOAT((FLOAT)1.0 / FLOATOFFULL(dx | 0xffff)); <br>    dy = FULLOFFLOAT((FLOAT)1.0 / FLOATOFFULL(dy | 0xffff)); <br>    } <br> <br>  float d = FLOATOFFULL(dx) * scale; <br>  if (d &gt; dMax) <br>    d = dMax; <br>  else if (d &lt; -dMax) <br>    d = -dMax; <br>  dx = FULLOFFLOAT(d); <br>  d = FLOATOFFULL(dy) * scale; <br>  if (d &gt; dMax) <br>    d = dMax; <br>  else if (d &lt; -dMax) <br>    d = -dMax; <br>  dy = FULLOFFLOAT(d); <br> <br>  if (flags &amp; MAS_X) <br>    { <br>    if (flags &amp; MAS_VEL) <br>      { <br>      m_vxFull += dx; <br>      if (m_vxFull &gt; m_psc-&gt;m_vFullMax) <br>        m_vxFull = m_psc-&gt;m_vFullMax; <br>      else if (m_vxFull &lt; -m_psc-&gt;m_vFullMax) <br>        m_vxFull = -m_psc-&gt;m_vFullMax; <br>      } <br>    if (flags &amp; MAS_ACCEL) <br>      { <br>      m_axFull += dx; <br>      if (m_axFull &gt; m_psc-&gt;m_aFullMax) <br>        m_axFull = m_psc-&gt;m_aFullMax; <br>      else if (m_axFull &lt; -m_psc-&gt;m_aFullMax) <br>        m_axFull = -m_psc-&gt;m_aFullMax; <br>      } <br>    if (!(flags &amp; MAS_POS)) <br>      dx = 0; <br>    } <br>  else  <br>    dx = 0; <br> <br>  if (flags &amp; MAS_Y) <br>    { <br>    if (flags &amp; MAS_VEL) <br>      { <br>      m_vyFull += dy; <br>      if (m_vyFull &gt; m_psc-&gt;m_vFullMax) <br>        m_vyFull = m_psc-&gt;m_vFullMax; <br>      else if (m_vyFull &lt; -m_psc-&gt;m_vFullMax) <br>        m_vyFull = -m_psc-&gt;m_vFullMax; <br>      } <br>    if (flags &amp; MAS_ACCEL) <br>      { <br>      m_ayFull += dy; <br>      if (m_ayFull &gt; m_psc-&gt;m_aFullMax) <br>        m_ayFull = m_psc-&gt;m_aFullMax; <br>      else if (m_ayFull &lt; -m_psc-&gt;m_aFullMax) <br>        m_ayFull = -m_psc-&gt;m_aFullMax; <br>      } <br>    if (!(flags &amp; MAS_POS)) <br>      dy = 0; <br>    } <br>  else  <br>    dy = 0; <br> <br>  if (dx || dy) <br>    return this-&gt;MoveByFull(dx, dy, fCollide); <br> <br>  return TRUE; <br>  } <br> <br> <br>//*************************************************************************** <br>// IUnknown Interface <br>//*************************************************************************** <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CSprite::QueryInterface <br>( <br>  REFIID  iid, <br>  LPVOID* ppvObjOut <br>) <br>{ <br>  if (!ppvObjOut) <br>    return E_INVALIDARG; <br> <br>  *ppvObjOut = NULL; <br> <br>  if (iid == IID_IUnknown) <br>    *ppvObjOut = this-&gt;GetUnknown(); <br>  else if (iid == IID_IDispatch) <br>    *ppvObjOut = this-&gt;GetDispatch(); <br>  else if (iid == IID_ISprite) <br>    *ppvObjOut = (ISprite *)this; <br> <br>  if (*ppvObjOut) <br>    { <br>    this-&gt;AddRef(); <br>    return S_OK; <br>    } <br> <br>  return E_NOINTERFACE; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP_(ULONG) CSprite::AddRef <br>( <br>  void  <br>) <br>{ <br>  return ++m_cref; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP_(ULONG) CSprite::Release <br>( <br>  void  <br>) <br>{ <br>  ASSERT(m_cref, "bad m_cref"); <br>  m_cref--; <br>  if (!m_cref) <br>    { <br>    delete this; <br>    return 0; <br>    } <br>  return m_cref; <br>} <br> <br> <br>//*************************************************************************** <br>// IDispatch Interface <br>//*************************************************************************** <br> <br>//--------------------------------------------------------------------------- <br>// Method needed by COleAuto, so it can implement IDispatch for us. <br>//--------------------------------------------------------------------------- <br>HRESULT CSprite::GetTypeLibInfo <br>( <br>  HINSTANCE    *phinstOut, <br>  const GUID  **pplibidOut,  <br>  SHORT        *pwMajLib,  <br>  SHORT        *pwMinLib, <br>  const CLSID **ppclsidOut,  <br>  const IID   **ppiidOut,  <br>  ITypeLib   ***ppptlOut <br>) <br>{ <br>  *phinstOut  = g_hinst; <br>  *pplibidOut = &amp;LIBID_SPRUUIDS; <br>  *pwMajLib   = 1; <br>  *pwMinLib   = 0; <br>  *ppclsidOut = &amp;CLSID_Sprite; <br>  *ppiidOut   = &amp;IID_ISprite; <br>  *ppptlOut   = &amp;g_ptlMain; <br>  return S_OK; <br>} <br> <br>//--- EOF ------------------------------------------------------------------- <br> <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
