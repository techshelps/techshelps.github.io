<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>GAME.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context4581"></a>GAME.CPP</h2>
<pre><code>//--------------------------------------------------------------------------- <br>// Game.cpp <br>//--------------------------------------------------------------------------- <br>// Sample spr program <br>//--------------------------------------------------------------------------- <br>// (C) Copyright 1992-1997 by Microsoft Corporation.  All rights reserved. <br>// <br>// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF  <br>// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO  <br>// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A  <br>// PARTICULAR PURPOSE. <br>//--------------------------------------------------------------------------- <br> <br>#include "Main.h" <br>#pragma hdrstop <br>#include "Game.h" <br>#include "App.h" <br>#include "Spr.h" <br>#include "Score.h" <br>#include "SpruuidP.h" <br>#include &lt;math.h&gt; <br>#include &lt;sys/types.h&gt; <br>#include &lt;sys/stat.h&gt; <br>#include &lt;stdio.h&gt; <br> <br> <br>//--------------------------------------------------------------------------- <br>// DEBUG info <br>//--------------------------------------------------------------------------- <br>SZTHISFILE <br> <br> <br>//--------------------------------------------------------------------------- <br>// Forward Declares <br>//--------------------------------------------------------------------------- <br>int DisplayScriptError(HINSTANCE hinst, HWND hwndParent, LPCSTR pszError, int ichError); <br> <br> <br>//--------------------------------------------------------------------------- <br>// Image data <br>//--------------------------------------------------------------------------- <br>#define ADDPIX(    id,idNext,x,y,cx,cy) {iimg##idNext, x, y, cx, cy}, <br>#define ADDPIXLAST(id,idNext,x,y,cx,cy) {iimg##idNext, x, y, cx, cy} <br>#define ADDPIXIMG <br>IMG Game_img[] = { <br>#include "SpruuidP.pix" <br>}; <br>#undef ADDPIX <br>#undef ADDPIXLAST <br>#undef ADDPIXIMG <br> <br> <br>//--------------------------------------------------------------------------- <br>// Various Globals <br>//--------------------------------------------------------------------------- <br>CGame     *g_pgame            = NULL; <br>ITypeLib  *g_ptlGameSubObj    = NULL; <br>ITypeInfo *g_ptinfoClsGame    = NULL; <br>ITypeInfo *g_ptinfoIntGame    = NULL; <br>char      *CGame::s_pszError  = NULL; <br>ULONG      g_clineOffset; <br> <br> <br>//--------------------------------------------------------------------------- <br>// Cover for contstructor.  Use instead of new CGame! <br>//--------------------------------------------------------------------------- <br>HRESULT CGame::s_hr = E_FAIL; <br> <br>HRESULT CGame::CreateGame <br>( <br>  HINSTANCE hinst, <br>  HWND      hwndDlg, <br>  HWND      hwndPS, <br>  HWND      hwndStat, <br>  IOleComponentManager *pcm, <br>  CGame   **ppgameOut <br>) <br>{ <br>  CGame  *pgame; <br>  HRESULT hr; <br> <br>  *ppgameOut = NULL; <br>  pgame = new CGame(hinst, hwndDlg, hwndPS, hwndStat, pcm); <br>  if (!pgame) <br>    return E_OUTOFMEMORY; <br>  else if (pgame-&gt;s_hr) <br>    { <br>    delete pgame; <br>    return s_hr; <br>    } <br> <br>// ##### BEGIN ACTIVEX SCRIPTING SUPPORT ##### <br>// Add the Game as a Named Item &amp; load its code <br>  g_clineOffset = 0; <br>  hr = pgame-&gt;ParseFile(g_pszCodeFile, L"Game"); <br>  if (hr) <br>    { <br>    MessageBox(g_papp-&gt;m_hwndDlg, s_pszError ? s_pszError : "Unspecified Error", "Spruuids", MB_OK | MB_ICONEXCLAMATION); <br>    return hr; <br>    } <br>// #####  END  ACTIVEX SCRIPTING SUPPORT ##### <br> <br>  // Create sprite classes based upon $OBJECT lines in file <br>  for (int i=0; i&lt;pgame-&gt;m_csubobj; i++) <br>    { <br>    CHECK(CSpriteClass::Create(pgame-&gt;m_pdisp, &amp;pgame-&gt;m_rgpsc[i])); <br>    pgame-&gt;m_rgpdispSubObjs[i] = pgame-&gt;m_rgpsc[i]-&gt;GetDispatch(); <br>    pgame-&gt;m_rgpdispSubObjs[i]-&gt;AddRef(); <br>    } <br> <br>  if (hr) <br>    { <br>CleanUp: <br>    delete pgame; <br>    return hr; <br>    } <br> <br>// ##### BEGIN ACTIVEX SCRIPTING SUPPORT ##### <br>  // Start the script running... <br>  hr = pgame-&gt;m_ps-&gt;SetScriptState(SCRIPTSTATE_CONNECTED); <br>  if (hr) <br>    { <br>    delete pgame; <br>    return hr; <br>    } <br>// #####  END  ACTIVEX SCRIPTING SUPPORT ##### <br> <br>  // Success <br>  *ppgameOut = pgame; <br>  return S_OK; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>// Constructor <br>//--------------------------------------------------------------------------- <br>CGame::CGame <br>( <br>  HINSTANCE hinst, <br>  HWND      hwndDlg, <br>  HWND      hwndPS, <br>  HWND      hwndStat, <br>  IOleComponentManager *pcm <br>) <br>{ <br>  INIT_SIGNATURE(SIG_Game); <br> <br>  // Setup globals <br>  g_pgame       = this; <br>  s_hr          = S_OK; <br> <br>  // Init members <br>  m_hinst        = hinst; <br>  m_hwndDlg      = hwndDlg; <br>  m_hwndPS       = hwndPS; <br>  m_hwndStat     = hwndStat; <br>  m_cref         = 1; <br>  m_fPaused      = FALSE; <br>  m_fShipDead    = FALSE; <br>  m_fShipRestart = FALSE; <br>  m_fGameOver    = TRUE; <br>  m_pcm          = pcm; <br>  m_ps           = NULL; <br>  m_psp          = NULL; <br>  VariantInit(&amp;m_varTag); <br>  m_pscore       = NULL; <br>  m_pdisp        = NULL; <br>  m_pdispBaseObject = NULL; <br>  m_pgameoa      = NULL; <br>  m_csubobj      = 0; <br> <br>  CoCreateGuid(&amp;m_libidSubObj); <br>  CoCreateGuid(&amp;m_clsidSubObj); <br>  CoCreateGuid(&amp;m_iidSubObj); <br> <br>  m_pgameoa = new CGameOA(this); <br>  if (!m_pgameoa) <br>    { <br>    s_hr = E_OUTOFMEMORY; <br>    return; <br>    } <br>  this-&gt;SetBaseObject(m_pgameoa-&gt;GetDispatch()); <br> <br>  m_pdisp = new CDisplay(hinst, hwndPS, GetDC(hwndPS), <br>                         this-&gt;GetUnknown(), CGameOA::FireCollide, <br>                         sizeof(Game_img)/sizeof(IMG), Game_img, ID_BMP_SPRITES); <br>  if (!m_pdisp) <br>    { <br>    s_hr = E_OUTOFMEMORY; <br>    return; <br>    } <br> <br>  s_hr = CScore::CreateScore( <br>                      m_hinst,       // hinst to load resources from <br>                      m_hwndDlg,     // hwnd on which to draw score <br>                      m_hwndPS,      // hwnd of PlaySurface <br>                      m_hwndStat,    // hwnd of Status bar <br>                      2500,          // scoreFirst1Up <br>                      5000,          // scoreSecond1Up <br>                      2500,          // dscoreNext1Up <br>                      3,             // cshipStart; <br>                      ID_BMP_SHIP,   // idbmpShip; <br>                      ID_BMP_PLUS,   // idbmpPlus; <br>                      &amp;m_pscore); <br>  if (s_hr) <br>    return; <br>  ASSERT(m_pscore, "Good hr, but m_pscore==NULL"); <br> <br>  // Default to VBScript <br>  extern const CLSID CLSID_VBScript; <br>  m_clsidEngine = CLSID_VBScript; <br> <br>  // Success <br>  s_hr = S_OK; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>// Clean up allocated resources <br>//--------------------------------------------------------------------------- <br>CGame::~CGame <br>( <br>  void <br>) <br>{ <br>  CHECK_SIGNATURE(SIG_Game); <br>  this-&gt;Close(); <br>  if (m_pgameoa) <br>    delete m_pgameoa; <br>  DESTROY_SIGNATURE(SIG_Game); <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>// Clean up allocated resources <br>//--------------------------------------------------------------------------- <br>void CGame::Close <br>( <br>  void <br>) <br>{ <br>  CHECK_SIGNATURE(SIG_Game); <br> <br>  if (g_mode != MODE_PLAYBACK) <br>    KillTimer(m_hwndPS, 0); <br> <br>  g_pgame = NULL; <br> <br>  // Clear this, since it may be an object <br>  VariantClear(&amp;m_varTag); <br> <br>// ##### BEGIN ACTIVEX SCRIPTING SUPPORT ##### <br>  // Release the language engine, since it may hold on to us <br>  if (m_psp) <br>    m_psp-&gt;Release(); <br>  if (m_ps) <br>    { <br>    m_ps-&gt;Close(); <br>    m_ps-&gt;Release(); <br>    } <br>// #####  END  ACTIVEX SCRIPTING SUPPORT ##### <br> <br>  // Drop all sink's that have Advise()'d us, since they might keep us alive <br>  m_pgameoa-&gt;m_cp.Close(); <br> <br>  // Release all existing sprites <br>  if (m_pdisp) <br>    m_pdisp-&gt;DestroyAll(); <br> <br>  // Close &amp; Release the SpriteClass Sub Objects <br>  for (int i=0; i&lt;m_csubobj; i++) <br>    { <br>    delete [] m_rgpwszSubObjs[i]; <br>    if (m_rgpdispSubObjs[i]) <br>      { <br>      m_rgpdispSubObjs[i]-&gt;Release(); <br>      m_rgpdispSubObjs[i] = NULL; <br>      } <br>    if (m_rgpsc[i]) <br>      { <br>      m_rgpsc[i]-&gt;Close(); <br>      m_rgpsc[i]-&gt;Release(); <br>      m_rgpsc[i] = NULL; <br>      } <br>    } <br> <br>  // Now destroy the Score &amp; Display objects <br>  if (m_pscore) <br>    { <br>    delete m_pscore; <br>    m_pscore = NULL; <br>    } <br>  if (m_pdisp) <br>    { <br>    delete m_pdisp; <br>    m_pdisp = NULL; <br>    } <br>} <br> <br> <br>//*************************************************************************** <br>// IUnknown Interface <br>//*************************************************************************** <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CGame::QueryInterface <br>( <br>  REFIID  iid, <br>  LPVOID* ppvObjOut <br>) <br>{ <br>  if (!ppvObjOut) <br>    return E_INVALIDARG; <br> <br>  *ppvObjOut = NULL; <br> <br>  if (iid == IID_IUnknown) <br>    *ppvObjOut = this-&gt;GetUnknown(); <br>  else if (iid == IID_IDispatch) <br>    *ppvObjOut = this-&gt;GetDispatch(); <br>  else if (iid == IID_IGameSubObjects) <br>    *ppvObjOut = this-&gt;GetDispatch(); <br>  else if (iid == IID_IActiveScriptSite) <br>    *ppvObjOut = (IActiveScriptSite *)this; <br>  else if (iid == IID_IActiveScriptSiteWindow) <br>    *ppvObjOut = (IActiveScriptSiteWindow *)this; <br>  else if (iid == IID_IProvideClassInfo) <br>    *ppvObjOut = (IProvideClassInfo *)this; <br>  else if (iid == IID_IProvideMultipleClassInfo) <br>    *ppvObjOut = (IProvideMultipleClassInfo *)this; <br>  else if (iid == IID_IGame) <br>    *ppvObjOut = (IGame *)(this-&gt;m_pgameoa); <br>  else if (iid == IID_IConnectionPointContainer) <br>    *ppvObjOut = (IConnectionPointContainer *)(this-&gt;m_pgameoa); <br> <br>  if (*ppvObjOut) <br>    { <br>    this-&gt;AddRef(); <br>    return S_OK; <br>    } <br> <br>  return E_NOINTERFACE; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP_(ULONG) CGame::AddRef <br>( <br>  void  <br>) <br>{ <br>  return ++m_cref; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP_(ULONG) CGame::Release <br>( <br>  void  <br>) <br>{ <br>  ASSERT(m_cref, "bad m_cref"); <br>  m_cref--; <br>  if (!m_cref) <br>    { <br>    m_pgameoa-&gt;m_cp.Close();     // Make sure nobody's holding on to us because we're holding their sink <br>    if (!m_cref &amp;&amp; !m_pgameoa-&gt;m_cp.m_cref) <br>      { <br>      delete this; <br>      return 0; <br>      } <br>    } <br>  return m_cref; <br>} <br> <br> <br>//*************************************************************************** <br>// IDispatch Interface <br>//*************************************************************************** <br> <br>//--------------------------------------------------------------------------- <br>// Re-implement COleAuto's GetIDsOfNames(), so we can implement the dynamic <br>// properties we added for the $OBJECT=SpriteClassName lines. <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CGame::GetIDsOfNames <br>( <br>  REFIID    iid, <br>  OLECHAR** rgszNames, <br>  UINT      cNames, <br>  LCID      lcid, <br>  DISPID*   prgdispid <br>) <br>{ <br>  // Validate Args <br>  if (iid != IID_NULL) <br>      return E_INVALIDARG; <br> <br>  // See if a sub-object matches the name passed in. <br>  for (int i=0; i&lt;m_csubobj; i++) <br>    if (!wcscmp(*rgszNames, m_rgpwszSubObjs[i])) <br>      { <br>      if (cNames != 1) <br>        return DISP_E_NONAMEDARGS; <br>      *prgdispid = 0x80010000 | i; <br>      return S_OK; <br>      } <br> <br>  return COleAuto::GetIDsOfNames(iid, rgszNames, cNames, lcid, prgdispid); <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>// Re-implement COleAuto's Invoke(), so we can implement the dynamic <br>// properties we added for the $OBJECT=SpriteClassName lines. <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CGame::Invoke <br>( <br>  DISPID      dispid, <br>  REFIID      riid, <br>  LCID        lcid, <br>  WORD        wFlags, <br>  DISPPARAMS* pdispparams, <br>  VARIANT*    pvarResult, <br>  EXCEPINFO*  pexcepinfo,  <br>  UINT*       puArgErr) <br>{ <br>  IDispatch *pdisp = NULL; <br> <br>  // Validate Args <br>  if (pvarResult) <br>    VariantInit(pvarResult); <br>  if (puArgErr) <br>    *puArgErr = 0; <br>  SetErrorInfo(0L, NULL); <br> <br>  // If dispid isn't a dynamic property, call COleAuto's dispatch, <br>  // and it will forward the request on to m_pdispBaseObject. <br>  if ((dispid &amp; 0x80010000) != 0x80010000) <br>    return COleAuto::Invoke(dispid, riid, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr); <br>  // It's for one of our property objects... <br> <br>  // Make sure we have either a PropGet or a Method <br>  if (!(wFlags &amp; (DISPATCH_METHOD | DISPATCH_PROPERTYGET))) <br>    return DISP_E_MEMBERNOTFOUND; <br> <br>  dispid &amp;= 0xffff; <br>  if (dispid &gt;= m_csubobj) <br>    return DISP_E_MEMBERNOTFOUND; <br> <br>  if (pdispparams-&gt;cArgs) <br>    return DISP_E_BADPARAMCOUNT; <br> <br>  if (pdispparams-&gt;cNamedArgs) <br>    return DISP_E_NONAMEDARGS; <br> <br>  // Get an addref'd IDispatch to the property object <br>  pdisp = m_rgpdispSubObjs[dispid]; <br>  ASSERT(pdisp, "NULL m_rgpdispSubObjs[]"); <br> <br>  if (pvarResult) <br>    { <br>    pvarResult-&gt;vt = VT_DISPATCH; <br>    pvarResult-&gt;pdispVal = pdisp; <br>    pdisp-&gt;AddRef();// We're returning this disp ptr <br>    } <br> <br>  return S_OK; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>// Method needed by COleAuto, so it can implement IDispatch for us. <br>//--------------------------------------------------------------------------- <br>HRESULT CGame::GetTypeLibInfo <br>( <br>  HINSTANCE    *phinstOut, <br>  const GUID  **pplibidOut,  <br>  SHORT        *pwMajLib,  <br>  SHORT        *pwMinLib, <br>  const CLSID **ppclsidOut,  <br>  const IID   **ppiidOut,  <br>  ITypeLib   ***ppptlOut <br>) <br>{ <br>  HRESULT hr = this-&gt;BuildTypeInfo(); <br>  if (hr) <br>    return hr; <br>  *phinstOut  = NULL; <br>  *pplibidOut = &amp;m_libidSubObj; <br>  *pwMajLib   = 1; <br>  *pwMinLib   = 0; <br>  *ppclsidOut = &amp;m_clsidSubObj; <br>  *ppiidOut   = &amp;m_iidSubObj; <br>  *ppptlOut   = &amp;g_ptlGameSubObj; <br>  return S_OK; <br>} <br> <br> <br>//*************************************************************************** <br>// IProvideClassInfo Interfaces <br>//*************************************************************************** <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CGame::GetClassInfo <br>( <br>  ITypeInfo** pptinfoOut <br>) <br>{ <br>  HRESULT hr = ((COleAuto *)this)-&gt;CheckTypeInfo(0, 0x0409); <br>  if (hr) <br>    return hr; <br>  *pptinfoOut = g_ptinfoClsGame; <br>  (*pptinfoOut)-&gt;AddRef(); <br>  return S_OK; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CGame::GetGUID <br>( <br>  DWORD dwGuidKind, <br>  GUID* pGUID <br>) <br>{ <br>  if (pGUID) <br>    return E_INVALIDARG; <br> <br>  if (dwGuidKind != GUIDKIND_DEFAULT_SOURCE_DISP_IID) <br>    return E_INVALIDARG; <br> <br>  *pGUID = DIID_IGameEvents; <br>  return S_OK; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CGame::GetMultiTypeInfoCount <br>( <br>  ULONG *pcti <br>) <br>{ <br>  if (!pcti) <br>    return E_INVALIDARG; <br> <br>  *pcti = 2; <br>  return S_OK; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CGame::GetInfoOfIndex <br>( <br>  ULONG       iti, <br>  DWORD       dwFlags, <br>  ITypeInfo** pptiCoClass, <br>  DWORD*      pdwTIFlags, <br>  ULONG*      pcdispidReserved, <br>  IID*        piidPrimary, <br>  IID*        piidSource <br>) <br>{ <br>  HRESULT    hr        = S_OK; <br>  ITypeInfo *ptinfoOut = NULL; <br> <br>  if (iti &gt; 1) <br>    hr = E_FAIL; <br> <br>//  if (dwFlags &amp; ~MULTICLASSINFO_ALL) <br>//    hr = E_INVALIDARG; <br> <br>  if (dwFlags &amp; MULTICLASSINFO_GETTYPEINFO) <br>    { <br>    if (!pptiCoClass || !pdwTIFlags) <br>      hr = E_INVALIDARG; <br>    else <br>      { <br>      *pdwTIFlags  = 0L; <br>      *pptiCoClass = NULL; <br>      if (iti == 0) <br>        { <br>        hr = ((COleAuto *)this)-&gt;CheckTypeInfo(0, 0x0409); <br>        if (hr) <br>          return hr; <br>        ptinfoOut = g_ptinfoClsGame; <br>        } <br>      else <br>        { <br>        hr = ((COleAuto *)m_pgameoa)-&gt;CheckTypeInfo(0, 0x0409); <br>        if (hr) <br>          return hr; <br>        ptinfoOut = g_ptinfoClsGameOA; <br>        } <br>      } <br>    } <br> <br>  if (dwFlags &amp; MULTICLASSINFO_GETNUMRESERVEDDISPIDS) <br>    { <br>    if (!pcdispidReserved) <br>      hr = E_INVALIDARG; <br>    else <br>      *pcdispidReserved = 256; <br>    } <br> <br>  if (dwFlags &amp; MULTICLASSINFO_GETIIDPRIMARY) <br>    { <br>    if (!piidPrimary) <br>      hr = E_INVALIDARG; <br>    else if (iti == 0) <br>      *piidPrimary = IID_IGameSubObjects; <br>    else <br>      *piidPrimary = IID_IGame; <br>    } <br> <br>  if (dwFlags &amp; MULTICLASSINFO_GETIIDSOURCE) <br>    { <br>    if (!piidSource) <br>      hr = E_INVALIDARG; <br>    else if (iti == 0) <br>      *piidSource = IID_NULL; <br>    else <br>      *piidSource = DIID_IGameEvents; <br>    } <br> <br>  // Fill in ptinfo out param <br>  if (hr) <br>    { <br>    if (pptiCoClass) <br>      *pptiCoClass = NULL; <br>    } <br>  else if (pptiCoClass) <br>    { <br>    *pptiCoClass = ptinfoOut; <br>    (*pptiCoClass)-&gt;AddRef(); <br>    } <br> <br>  return hr; <br>} <br> <br> <br> <br>// ##### BEGIN ACTIVEX SCRIPTING SUPPORT ##### <br>//*************************************************************************** <br>// IActiveScriptSite Interface <br>//*************************************************************************** <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CGame::GetLCID <br>( <br>  LCID *plcid <br>) <br>{ <br>  return E_NOTIMPL;     // Use system settings <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CGame::GetItemInfo <br>( <br>  LPCOLESTR   pstrName, <br>  DWORD       dwReturnMask, <br>  IUnknown**  ppunkItemOut, <br>  ITypeInfo** pptinfoOut <br>) <br>{ <br>  HRESULT hr; <br> <br>  if (dwReturnMask &amp; SCRIPTINFO_ITYPEINFO) <br>    { <br>    if (!pptinfoOut) <br>      return E_INVALIDARG; <br>    *pptinfoOut = NULL; <br>    } <br> <br>  if (dwReturnMask &amp; SCRIPTINFO_IUNKNOWN) <br>    { <br>    if (!ppunkItemOut) <br>      return E_INVALIDARG; <br>    *ppunkItemOut = NULL; <br>    } <br> <br>  if (!_wcsicmp(L"game", pstrName)) <br>    { <br>    if (dwReturnMask &amp; SCRIPTINFO_ITYPEINFO) <br>      { <br>      hr = ((COleAuto *)this)-&gt;CheckTypeInfo(0, 0x0409); <br>      if (hr) <br>        return hr; <br>      *pptinfoOut = g_ptinfoClsGame; <br>      (*pptinfoOut)-&gt;AddRef();      // because returning <br>      } <br>    if (dwReturnMask &amp; SCRIPTINFO_IUNKNOWN) <br>      { <br>      *ppunkItemOut = this-&gt;GetUnknown(); <br>      (*ppunkItemOut)-&gt;AddRef();    // because returning <br>      } <br>    return S_OK; <br>    } <br> <br>  return TYPE_E_ELEMENTNOTFOUND; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CGame::GetDocVersionString <br>( <br>  BSTR *pbstrVersion <br>) <br>{ <br>  return E_NOTIMPL;   // UNDONE: Implement this method <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CGame::RequestItems <br>( <br>  void  <br>) <br>{ <br>  return m_ps-&gt;AddNamedItem(L"Game", SCRIPTITEM_ISVISIBLE | SCRIPTITEM_ISSOURCE); <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CGame::RequestTypeLibs <br>( <br>  void  <br>) <br>{ <br>  return m_ps-&gt;AddTypeLib(LIBID_SPRUUIDS, 1, 0, 0); <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CGame::OnScriptTerminate <br>( <br>  const VARIANT   *pvarResult, <br>  const EXCEPINFO *pexcepinfo <br>) <br>{ <br>  // UNDONE: Put up error dlg here <br>  return S_OK; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CGame::OnStateChange <br>( <br>  SCRIPTSTATE ssScriptState <br>) <br>{ <br>  // Don't care about notification <br>  return S_OK; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>// Display the error <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CGame::OnScriptError <br>( <br>  IActiveScriptError *pse <br>) <br>{ <br>  char      szError[1024]; <br>  char     *pszArrow = NULL; <br>  BOOL      fAlloc = FALSE; <br>  EXCEPINFO ei; <br>  DWORD     dwSrcContext; <br>  ULONG     ulLine; <br>  LONG      ichError; <br>  BSTR      bstrLine = NULL; <br>  HRESULT   hr; <br> <br>  CHECK(pse-&gt;GetExceptionInfo(&amp;ei)); <br>  CHECK(pse-&gt;GetSourcePosition(&amp;dwSrcContext, &amp;ulLine, &amp;ichError)); <br>  ulLine += g_clineOffset;    // Adjust for $ENGINE/$OBJECT/etc. lines <br>  hr = pse-&gt;GetSourceLineText(&amp;bstrLine); <br>  if (hr) <br>    hr = S_OK;  // Ignore this error, there may not be source available <br>   <br>  if (!hr) <br>    { <br>    MAKE_ANSIPTR_FROMWIDE(pszSrc,  ei.bstrSource); <br>    MAKE_ANSIPTR_FROMWIDE(pszDesc, ei.bstrDescription); <br>    MAKE_ANSIPTR_FROMWIDE(pszLine, bstrLine); <br>    if (ichError &gt; 0 &amp;&amp; ichError &lt; 255) <br>      { <br>      pszArrow = new char[ichError+1]; <br>      memset(pszArrow, '-', ichError); <br>      pszArrow[ichError-1] = 'v'; <br>      pszArrow[ichError]   = 0; <br>      fAlloc = TRUE; <br>      } <br>    else <br>      pszArrow = ""; <br> <br>    wsprintf(szError, "Source:'%s'\nFile:'%s'  Line:%d  Char:%d\nError:%d  '%s'\n%s\n%s", <br>                      pszSrc, g_pszCodeFile, ulLine, ichError, <br>                      (int)ei.wCode, pszDesc, pszArrow, pszLine); <br>    DisplayScriptError(g_hinst, m_hwndDlg, szError, ichError); <br>    } <br> <br>CleanUp: <br>  if (fAlloc) <br>    delete [] pszArrow; <br>  if (bstrLine) <br>    SysFreeString(bstrLine); <br> <br>  return hr; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CGame::OnEnterScript <br>( <br>  void  <br>) <br>{ <br>  // No need to do anything <br>  return S_OK; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CGame::OnLeaveScript <br>( <br>  void  <br>) <br>{ <br>  // No need to do anything <br>  return S_OK; <br>} <br> <br> <br> <br>//*************************************************************************** <br>// IActiveScriptSiteWindow Interface <br>//*************************************************************************** <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CGame::GetWindow <br>( <br>  HWND *phwndOut <br>) <br>{ <br>  if (!phwndOut) <br>    return E_INVALIDARG; <br>  *phwndOut = m_hwndDlg; <br>  return S_OK; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CGame::EnableModeless <br>( <br>  BOOL fEnable <br>) <br>{ <br>  if (fEnable) <br>    m_pcm-&gt;FOnComponentExitState(g_papp-&gt;m_idcomp, cmgrstateModal, cmgrcontextAll, 0, NULL); <br>  else <br>    m_pcm-&gt;OnComponentEnterState(g_papp-&gt;m_idcomp, cmgrstateModal, cmgrcontextAll, 0, NULL, NULL); <br>  return S_OK; <br>} <br>// #####  END  ACTIVEX SCRIPTING SUPPORT ##### <br> <br> <br>//*************************************************************************** <br>// Misc WndProc-related Methods <br>//*************************************************************************** <br> <br>//--------------------------------------------------------------------------- <br>// <br>//--------------------------------------------------------------------------- <br>BOOL AppEvt_DlgProc <br>( <br>  HWND   hwnd, <br>  UINT   msg, <br>  WPARAM wp, <br>  LPARAM lp <br>) <br>{ <br>  if (!g_pgame) <br>    return FALSE; <br> <br>  return g_pgame-&gt;DlgProc(hwnd, msg, wp, lp); <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>// <br>//--------------------------------------------------------------------------- <br>BOOL CGame::DlgProc <br>( <br>  HWND   hwnd, <br>  UINT   msg, <br>  WPARAM wp, <br>  LPARAM lp <br>) <br>{ <br>  switch (msg) <br>    { <br>    case WM_ERASEBKGND: <br>      if (m_pscore) <br>        { <br>        m_pscore-&gt;Paint((HDC)wp); <br>        return TRUE; <br>        } <br>      break; <br>    } <br>  return FALSE; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>// <br>//--------------------------------------------------------------------------- <br>LRESULT AppEvt_PSWndProc <br>( <br>  HWND   hwnd, <br>  UINT   msg, <br>  WPARAM wp, <br>  LPARAM lp <br>) <br>{ <br>  if (!g_pgame) <br>    return DefWindowProc(hwnd, msg, wp, lp); <br> <br>  return g_pgame-&gt;PSWndProc(hwnd, msg, wp, lp); <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>// <br>//--------------------------------------------------------------------------- <br>LRESULT CGame::PSWndProc <br>( <br>  HWND   hwnd, <br>  UINT   msg, <br>  WPARAM wp, <br>  LPARAM lp <br>) <br>{ <br>  switch (msg) <br>    { <br>    case WM_PAINT: <br>      if (m_pdisp) <br>        { <br>        if (wp) <br>          m_pdisp-&gt;Paint((HDC)wp); <br>        else <br>          { <br>          PAINTSTRUCT ps; <br> <br>          BeginPaint(hwnd, &amp;ps); <br>          m_pdisp-&gt;Paint(ps.hdc); <br>          EndPaint(hwnd, &amp;ps); <br>          } <br>        return 1L; <br>        } <br>      break; <br> <br>    case WM_ERASEBKGND: <br>      SelectObject((HDC)wp, (HGDIOBJ)(m_pdisp-&gt;m_hbrushBack ? (HBRUSH)(m_pdisp-&gt;m_hbrushBack) : (HBRUSH)g_hbrushStock)); <br>      PatBlt((HDC)wp, 0, 0, 32000, 32000, PATCOPY); <br>      SelectObject((HDC)wp, g_hbrushStock); <br>      return TRUE; <br> <br>    case WM_SIZE: <br>      { <br>      RECT rect; <br> <br>      GetClientRect(hwnd, &amp;rect); <br>      m_pdisp-&gt;m_cx = rect.right; <br>      m_pdisp-&gt;m_cy = rect.bottom; <br>      break; <br>      } <br> <br>    case WM_TIMER: <br>      { <br>      if (m_fGameOver) <br>        break; <br> <br>      m_pdisp-&gt;Timer(); <br> <br>      if (m_fPaused) <br>        break; <br> <br>      if (m_fShipRestart) <br>        { <br>        m_pdisp-&gt;Refresh(); <br>        break; <br>        } <br> <br>      if (!m_fShipDead) <br>        { <br>        static cRefresh = 0; <br> <br>        m_pgameoa-&gt;FireTick(); <br>        if (++cRefresh &gt; 5)      // What's a reasonable number? <br>          { <br>          m_pdisp-&gt;Refresh(); <br>          cRefresh = 0; <br>          } <br>        } <br>      else <br>        { <br>        m_pscore-&gt;ShipKilled(); <br>        InvalidateRect(m_hwndDlg, NULL, TRUE); <br>        if (m_pscore-&gt;GetCShip() &lt;= 0) <br>          { <br>          this-&gt;GameOver(); <br>          break; <br>          } <br> <br>        m_fShipDead = FALSE; <br>        m_fShipRestart = TRUE; <br>        InvalidateRect(hwnd, NULL, TRUE); <br>        } <br>      break; <br>      } <br> <br>    case WM_KEYDOWN: <br>      m_pgameoa-&gt;FireKeyDown(wp); <br>      break; <br> <br>    case WM_CHAR: <br>      m_pgameoa-&gt;FireKeyPress(wp); <br>      break; <br> <br>    case WM_KEYUP: <br>      m_pgameoa-&gt;FireKeyUp(wp); <br>      break; <br> <br>    case WM_MOUSEMOVE: <br>      m_pgameoa-&gt;FireMouseMove(LOWORD(lp), HIWORD(lp), wp); <br>      break; <br> <br>    case WM_LBUTTONDOWN: <br>      m_pgameoa-&gt;FireMouseDown(LOWORD(lp), HIWORD(lp), wp, MK_LBUTTON); <br>      break; <br> <br>    case WM_RBUTTONDOWN: <br>      m_pgameoa-&gt;FireMouseDown(LOWORD(lp), HIWORD(lp), wp, MK_RBUTTON); <br>      break; <br> <br>    case WM_MBUTTONDOWN: <br>      m_pgameoa-&gt;FireMouseDown(LOWORD(lp), HIWORD(lp), wp, MK_MBUTTON); <br>      break; <br> <br>    case WM_LBUTTONUP: <br>      m_pgameoa-&gt;FireMouseUp(LOWORD(lp), HIWORD(lp), wp, MK_LBUTTON); <br>      break; <br> <br>    case WM_RBUTTONUP: <br>      m_pgameoa-&gt;FireMouseUp(LOWORD(lp), HIWORD(lp), wp, MK_RBUTTON); <br>      break; <br> <br>    case WM_MBUTTONUP: <br>      m_pgameoa-&gt;FireMouseUp(LOWORD(lp), HIWORD(lp), wp, MK_MBUTTON); <br>      break; <br>    } <br> <br>  return DefWindowProc(hwnd, msg, wp, lp); <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>// <br>//--------------------------------------------------------------------------- <br>LRESULT CALLBACK ScriptErrorDialog <br>( <br>  HWND   hwnd, <br>  UINT   msg, <br>  WPARAM wp, <br>  LPARAM lp <br>) <br>{ <br>  LPCSTR pszError; <br> <br>  switch (msg)  <br>    { <br>    case WM_INITDIALOG: <br>      pszError = (LPCSTR)lp; <br>      ShowWindow(hwnd, SW_HIDE); <br>      SendDlgItemMessage(hwnd, ID_CTL_ERROR, WM_SETFONT, <br>                         (WPARAM)GetStockObject(ANSI_FIXED_FONT), MAKELPARAM(FALSE,0)); <br>      SendDlgItemMessage(hwnd, ID_CTL_ERROR, WM_SETTEXT, 0, (LPARAM)pszError); <br>      ShowWindow(hwnd, SW_SHOW); <br>      return (TRUE); <br> <br>     case WM_COMMAND: <br>       switch(LOWORD(wp)) <br>         { <br>         case IDOK: <br>         case IDCANCEL: </code></pre>
<p>
</p>
<pre><code>goto Destroy; <br>         } <br>       break; <br>    } <br>  return FALSE; <br> <br>Destroy: <br>  EndDialog(hwnd, 0); <br>  return TRUE; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>// <br>//--------------------------------------------------------------------------- <br>int DisplayScriptError <br>( <br>  HINSTANCE hinst, <br>  HWND      hwndParent, <br>  LPCSTR    pszError, <br>  int       ichError <br>) <br>{ <br>  int   result; <br>  UINT  len = lstrlen(pszError); <br>  UINT  newlen; <br>  UINT  newindex; <br>  UINT  i; <br>  LPSTR pszNewError; <br> <br>  // Figure out how long the real string will be <br>  newlen = 0; <br>  for (i=0; i&lt;len; i++) <br>    { <br>    CHAR c = pszError[i]; <br> <br>    if (c == '\n') <br>      newlen +=1;               // Convert \n to \r\n <br>    else if (c == '\r') <br>      { <br>      if (pszError[i+1] == '\n') <br>        { <br>        newlen++;               // Leave \r\n alone <br>        i++; <br>        } <br>      else <br>        newlen++;               // Convert \r to \r\n <br>      } <br>    newlen++; <br>    } <br> <br>  // Create the real string: <br>  pszNewError = new char[newlen+1]; <br>  if (!pszNewError) <br>    return -1; <br> <br>  newindex = 0; <br>  for (i=0; i&lt;len; i++) <br>    { <br>    CHAR c = pszError[i]; <br> <br>    if (c == '\n') <br>      pszNewError[newindex++] = '\r';             // Convert \n to \r\n <br>    else if (c == '\r') <br>      { <br>      if (pszError[i+1] == '\n') <br>        { <br>        pszNewError[newindex++] = pszError[i++];  // Leave \r\n alone <br>        i++; <br>        } <br>      else <br>        { <br>        pszNewError[newindex++] = c;              // Convert \r to \r\n <br>        c = '\n'; <br>        } <br>      } <br>    pszNewError[newindex++] = c; <br>    } <br>  pszNewError[newindex] = '\0'; <br> <br>  // Create the dialog box <br>  g_pgame-&gt;m_pcm-&gt;OnComponentEnterState(g_papp-&gt;m_idcomp, cmgrstateModal, cmgrcontextAll, 0, NULL, NULL); <br>  g_pgame-&gt;Pause(1); <br>  result = DialogBoxParam( <br>  hinst,                         // Handle to application instance <br>  MAKEINTRESOURCE(ID_DLG_ERROR), // Identifies dialog box template name   <br>  hwndParent,                    // Handle to owner window <br>  (DLGPROC)ScriptErrorDialog,    // Pointer to dialog box procedure <br>  (DWORD)pszNewError);           // Context <br>  g_pgame-&gt;m_pcm-&gt;FOnComponentExitState(g_papp-&gt;m_idcomp, cmgrstateModal, cmgrcontextAll, 0, NULL); <br>  SetFocus(g_pgame-&gt;m_hwndPS); <br> <br>  delete[] pszNewError; <br> <br>  return result; <br>} <br> <br> <br>//*************************************************************************** <br>// Misc General Methods <br>//*************************************************************************** <br> <br>//--------------------------------------------------------------------------- <br>// New level <br>//--------------------------------------------------------------------------- <br>void CGame::NewLevel <br>( <br>  void <br>) <br>{ <br>  g_pgame-&gt;m_pdisp-&gt;DestroyAll(); <br>  m_pscore-&gt;NextLevel(); <br>  m_fShipRestart = TRUE; <br>  InvalidateRect(m_hwndPS,  NULL, TRUE); <br>  InvalidateRect(m_hwndDlg, NULL, TRUE); <br>  m_pgameoa-&gt;FireNewLevel(); <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>// <br>//--------------------------------------------------------------------------- <br>void AppEvt_NewGame <br>( <br>  void <br>) <br>{ <br>  g_pgame-&gt;NewGame(); <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>// <br>//--------------------------------------------------------------------------- <br>void CGame::NewGame <br>( <br>  void <br>) <br>{ <br>  m_pdisp-&gt;DestroyAll(); <br>  m_pscore-&gt;NewGame(); <br>  m_fGameOver    = FALSE; <br>  m_fShipRestart = TRUE; <br>  m_pgameoa-&gt;FireNewGame(); <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>// <br>//--------------------------------------------------------------------------- <br>BOOL AppEvt_Pause <br>( <br>  int pause <br>) <br>{ <br>  return g_pgame-&gt;Pause(pause); <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>// <br>//--------------------------------------------------------------------------- <br>BOOL CGame::Pause <br>( <br>  int pause <br>) <br>{ <br>  if (pause == -1)            // Toggle <br>    pause = !m_fPaused; <br> <br>  switch (pause) <br>    { <br>    case 1:                   // Pause <br>      if (m_fGameOver) <br>        goto UnPause; <br>      if (g_mode != MODE_PLAYBACK) <br>        KillTimer(m_hwndPS, 0); <br>      m_fPaused = TRUE; <br>      break; <br> <br>    case 0:                   // UnPause <br>UnPause: <br>      if (g_mode != MODE_PLAYBACK) <br>        SetTimer(m_hwndPS, 0, 40, NULL); <br>      m_fPaused = FALSE; <br>      break; <br>    } <br> <br>  if (m_fPaused) <br>    m_pscore-&gt;SetStatusText("Game Paused.  Press F3 to Continue."); <br>  else <br>    m_pscore-&gt;SetStatusText(""); <br> <br>  return m_fPaused; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>// <br>//--------------------------------------------------------------------------- <br>BOOL AppEvt_FQueryTerminate <br>( <br>  BOOL fPromptUser <br>) <br>{ <br>  return g_pgame-&gt;FQueryTerminate(fPromptUser); <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>// <br>//--------------------------------------------------------------------------- <br>BOOL CGame::FQueryTerminate <br>( <br>  BOOL fPromptUser <br>) <br>{ <br>  // UNDONE <br>  return TRUE; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>// <br>//--------------------------------------------------------------------------- <br>void CGame::GameOver <br>( <br>  void <br>) <br>{ <br>  m_fGameOver = TRUE; <br>  InvalidateRect(m_hwndPS, NULL, TRUE); <br>  m_pscore-&gt;SetStatusText("Game Over.  Press F2 to Play a New Game."); <br>} <br> <br> <br>// ##### BEGIN ACTIVEX SCRIPTING SUPPORT ##### <br>//--------------------------------------------------------------------------- <br>// <br>//--------------------------------------------------------------------------- <br>HRESULT CGame::CreateScriptEngine <br>( <br>  LPCOLESTR pstrItemName <br>) <br>{ <br>  HRESULT hr; <br> <br>  if (m_ps) <br>    return S_FALSE;   // Already created it <br> <br>  // Create the ActiveX Scripting Engine <br>  hr = CoCreateInstance(m_clsidEngine, NULL, CLSCTX_INPROC_SERVER, IID_IActiveScript, (void **)&amp;m_ps); <br>  if (hr) <br>    { <br>    s_pszError = "Creating the ActiveX Scripting engine failed.  Scripting engine is probably not correctly registered or CLSID incorrect."; <br>    return E_FAIL; <br>    } <br>  // Script Engine must support IActiveScriptParse for us to use it <br>  hr = m_ps-&gt;QueryInterface(IID_IActiveScriptParse, (void **)&amp;m_psp); <br>  if (hr) <br>    { <br>    s_pszError = "ActiveX Scripting engine does not support IActiveScriptParse"; <br>    return hr; <br>    } <br>  hr = m_ps-&gt;SetScriptSite(this); <br>  if (hr) <br>    return hr; <br>  // InitNew the object: <br>  hr = m_psp-&gt;InitNew(); <br>  if (hr) <br>    return hr; <br>  hr = m_ps-&gt;AddNamedItem(L"Game", SCRIPTITEM_ISVISIBLE | SCRIPTITEM_ISSOURCE); <br>  return hr; <br>} <br>// #####  END  ACTIVEX SCRIPTING SUPPORT ##### <br> <br> <br> <br>//*************************************************************************** <br>// Parsing support <br>//*************************************************************************** <br> <br>//--------------------------------------------------------------------------- <br>// Skip white space, counting lines.  Treat \r &amp; \n as white space only if <br>// fSkipNewLines is TRUE. <br>//--------------------------------------------------------------------------- <br>void SkipWhite <br>( <br>  char **ppsz, <br>  BOOL   fSkipNewLines <br>) <br>{ <br>  // Skip white space <br>  while (**ppsz &amp;&amp; **ppsz&lt;=' ') <br>    { <br>    if (**ppsz == '\r' || **ppsz == '\n') <br>      { <br>      if (!fSkipNewLines) <br>        return; <br>      if (**ppsz == '\r' &amp;&amp; (*ppsz)[1] == '\n') <br>        ++*ppsz; <br>      g_clineOffset++; <br>      } <br>    ++*ppsz; <br>    } <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>// Finds $OBJECT, $ENGINE, $INCLUDE, etc, parses past '=' to argument.  NULL <br>// terminates the argument, then returns a ptr to begining of arg &amp; to beg <br>// of next line. <br>//--------------------------------------------------------------------------- <br>struct <br>  { <br>  int   cch; <br>  char *psz; <br>  } g_rgtoken[] =  <br>    { <br>      {7, "$ENGINE"}, <br>      {7, "$OBJECT"}, <br>      {8, "$INCLUDE"}, <br>      {0, ""}, <br>    }; <br> <br>int FindToken <br>( <br>  char    *pszCur, <br>  char   **ppszBeginArg, <br>  char   **ppszNextLine, <br>  HRESULT *phr, <br>  char   **ppszError <br>) <br>{ <br>  char chQuote = 0; <br>  char ch; <br> <br>  *phr = S_OK; <br>  SkipWhite(&amp;pszCur, TRUE); <br>  if (*pszCur != '$') <br>    { <br>    *ppszNextLine = pszCur; <br>    return 0;   // No token found <br>    } <br> <br>  for (int i=0; g_rgtoken[i].cch; i++) <br>    { <br>    if (!strncmp(pszCur, g_rgtoken[i].psz, g_rgtoken[i].cch)) <br>      { <br>      pszCur += g_rgtoken[i].cch; <br>      SkipWhite(&amp;pszCur, FALSE); <br>      if (*pszCur != '=') <br>        { <br>        *ppszError = "Missing '=' on $ENGINE, $OBJECT, or $INCLUDE line"; <br>        *phr = E_FAIL; <br>        return 0; <br>        } <br>      pszCur++; <br>      SkipWhite(&amp;pszCur, FALSE); <br>      if (*pszCur &lt;= ' ') <br>        { <br>        *ppszError = "Missing argument on $ENGINE, $OBJECT, or $INCLUDE line"; <br>        *phr = E_FAIL; <br>        return 0; <br>        } <br>      if (*pszCur=='"' || *pszCur=='\'' || *pszCur=='&lt;') <br>        { <br>        chQuote = *pszCur; <br>        if (chQuote == '&lt;') <br>          chQuote = '&gt;'; <br>        pszCur++; <br>        } <br>      *ppszBeginArg = pszCur; <br>      if (chQuote) <br>        { <br>        // Look for End of String, EOL, or End of Quote <br>        while (*pszCur &amp;&amp; *pszCur!='\n' &amp;&amp; *pszCur!='\r' &amp;&amp; *pszCur!=chQuote) <br>          pszCur++; <br>        } <br>      else <br>        { <br>        // Skip non-white space <br>        while (*pszCur &gt; ' ') <br>          pszCur++; <br>        } <br>      ch = *pszCur; <br>      *pszCur = 0; <br>NextChar: <br>      switch (ch) <br>        { <br>        default: <br>          // Look for EOL <br>          pszCur++; <br>          ch = *pszCur; <br>          goto NextChar; <br> <br>        case '\r': <br>          // Skip the cr we're at <br>          g_clineOffset++; <br>          pszCur++; <br>          if (*pszCur == '\n') <br>            pszCur++; <br>          break; <br> <br>        case '\n': <br>          // Skip the newline we're at <br>          g_clineOffset++; <br>          pszCur++; <br>          break; <br> <br>        case 0: <br>           break; <br>        } <br> <br>      *ppszNextLine = pszCur; <br>      return i+1; <br>      } <br>    } <br> <br>  *ppszError = "unrecognized token; must be $ENGINE, $OBJECT, or $INCLUDE"; <br>  *phr = E_FAIL; <br>  return 0; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>// <br>//--------------------------------------------------------------------------- <br>HRESULT CGame::ParseFile <br>( <br>  char     *pszFileName, <br>  LPCOLESTR pstrItemName <br>) <br>{ <br>  struct _stat stat; <br>  size_t       cch; <br>  EXCEPINFO    ei; <br>  char        *pszT; <br>  char        *pszAlloc; <br>  FILE        *pfile; <br>  HRESULT      hr = S_OK; <br>  int          tk = 0; <br>  char        *pszArg; <br> <br>  // Find the length of the file <br>  if (_stat(pszFileName, &amp;stat)) <br>    return E_FAIL; <br>  cch = stat.st_size; <br> <br>  // Allocate a buffer to read the file <br>  pszAlloc = new char[cch+1]; <br>  if (!pszAlloc) <br>    return E_OUTOFMEMORY; <br>  memset(pszAlloc, 0, cch);   // HACK: Since cch may be too large, zero-fill string <br> <br>  // Open &amp; read the file <br>  pfile = fopen(pszFileName, "rb"); <br>  if (!pfile) <br>    { <br>    s_pszError = "Bad file name"; <br>    hr = E_FAIL; <br>    goto Error; <br>    } <br>  fread(pszAlloc, cch, 1, pfile); <br>  fclose(pfile); <br> <br>  // Parse lines begining w/$ <br>  pszAlloc[cch] = 0; <br>  pszT = pszAlloc; <br>  while (tk=FindToken(pszT, &amp;pszArg, &amp;pszT, &amp;hr, &amp;s_pszError)) <br>    { <br>    switch (tk) <br>      { <br>      case 1:   // $ENGINE <br>        { <br>        MAKE_WIDEPTR_FROMANSI(pwszCLSID, pszArg); <br>        hr = CLSIDFromString(pwszCLSID, &amp;m_clsidEngine); <br>        if (hr) <br>          { <br>          s_pszError = "Bad $ENGINE={xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx} syntax"; <br>          goto Error; <br>          } <br>        hr = this-&gt;CreateScriptEngine(pstrItemName); <br>        if (hr == S_FALSE) <br>          { <br>          s_pszError = "$ENGINE must be first line; Script Engine already created."; <br>          goto Error; <br>          } <br>        else if (hr) <br>          goto Error; <br>        break; <br>        } <br> <br>      case 2:  // $OBJECT <br>        if (m_csubobj &gt;= csubobjMAX) <br>          { <br>          s_pszError = "Too many $OBJECT lines"; <br>          goto Error; <br>          } <br> <br>        m_rgpwszSubObjs[m_csubobj] = new WCHAR [strlen(pszArg)+1]; <br>        if (!m_rgpwszSubObjs[m_csubobj]) <br>          { <br>          s_pszError = "Out Of Memory"; <br>          goto Error; <br>          } <br>        UNICODE_FROM_ANSI(m_rgpwszSubObjs[m_csubobj], pszArg, 2*strlen(pszArg)); <br>        m_rgpdispSubObjs[m_csubobj] = NULL; <br>        m_rgpsc[m_csubobj] = NULL; <br>        m_csubobj++; <br>        break; <br> <br>      case 3:   // $INCLUDE <br>        hr = this-&gt;ParseFile(pszArg, pstrItemName); <br>        if (hr) <br>          goto Error; <br>        break; <br>      } <br>    } <br> <br>  // If there's anything left, assume it's code <br>  if (*pszT) <br>    { <br>// ##### BEGIN ACTIVEX SCRIPTING SUPPORT ##### <br>    // Make sure we've created the scripting engine <br>    if (!m_ps) <br>      { <br>      hr = this-&gt;CreateScriptEngine(pstrItemName); <br>      if (hr) <br>        goto Error; <br>      } <br> <br>    // Hand it the code <br>    MAKE_WIDEPTR_FROMANSI(pwszCode, pszT); <br>    hr = m_psp-&gt;ParseScriptText(pwszCode, pstrItemName, NULL, NULL, 0, 0, 0L, NULL, &amp;ei); <br>    hr = S_OK;    // Ignore parse errors, so user can press F9 to view source... <br>// #####  END  ACTIVEX SCRIPTING SUPPORT ##### <br>    } <br> <br>Error: <br>  delete [] pszAlloc; <br>  return hr; <br>} <br> <br> <br> <br>//*************************************************************************** <br>// Dynamic object model support <br>//*************************************************************************** <br> <br>//--------------------------------------------------------------------------- <br>// Builds the typeinfo for the container object from the list of property  <br>// objects. <br>//--------------------------------------------------------------------------- <br>HRESULT CGame::BuildTypeInfo <br>( <br>  void <br>) <br>{ <br>  static GUID guidStdOle = {0x00020430,0x00,0x00,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}; <br>  ITypeLib*        ptlStdOle   = NULL; <br>  ITypeInfo*       ptinfoIDisp = NULL; <br>  ICreateTypeLib * pcreatetl   = NULL; <br>  ICreateTypeInfo* pctiCoClass = NULL;// For creating the CoClass <br>  ICreateTypeInfo* pctiProps   = NULL;// For creating the Primary (Property) Dispinterface <br>  FUNCDESC         funcdesc    = {0}; <br>  TYPEDESC         tdescUser   = {0}; <br>  ELEMDESC         edArg       = {0}; <br>  HREFTYPE         hreftype; <br>  int              index; <br>  int              i; <br>  HRESULT          hr; <br> <br>  if (g_ptinfoIntGame &amp;&amp; g_ptinfoClsGame) <br>    return S_OK; <br> <br>  // Create TypeLib <br>  CHECKSZ(CreateTypeLib(SYS_WIN32, L"c:\\SprdSubO.tlb" /* szFile */, &amp;pcreatetl), "CreateTypeLib FAILED"); <br> <br>  // Misc. global props of the TypeLib <br>  CHECKSZ(pcreatetl-&gt;SetGuid(m_libidSubObj), "TL SetGuid FAILED"); <br>  CHECKSZ(pcreatetl-&gt;SetVersion(1, 0), "TL SetVersion FAILED"); <br>  CHECKSZ(pcreatetl-&gt;SetName(L"Sprds"), "TL SetName FAILED"); <br>  CHECKSZ(pcreatetl-&gt;SetLcid(LOCALE_SYSTEM_DEFAULT), "TL SetLcid FAILED"); <br> <br>  // Get Information on IDispatch <br>  CHECKSZ(LoadRegTypeLib(guidStdOle, STDOLE_MAJORVERNUM, STDOLE_MINORVERNUM, STDOLE_LCID, &amp;ptlStdOle), "LoadRegTypeLib FAILED"); <br>  CHECKSZ(ptlStdOle-&gt;GetTypeInfoOfGuid(IID_IDispatch, &amp;ptinfoIDisp), "GetTypeInfoOfGuid (IID_IDispatch) FAILED"); <br> <br>  // Create TypeInfo <br>  CHECKSZ(pcreatetl-&gt;CreateTypeInfo(L"GameSubObjs", TKIND_DISPATCH, &amp;pctiProps), "Create TI FAILED"); <br>  CHECKSZ(pctiProps-&gt;SetGuid(m_iidSubObj), "cti SetGuid FAILED"); <br>  CHECKSZ(pctiProps-&gt;SetVersion(1, 0), "cti SetVersion FAILED"); <br>  CHECKSZ(pctiProps-&gt;AddRefTypeInfo(ptinfoIDisp, &amp;hreftype), "cti AddRefTypeInfoo FAILED"); // Reference StdOLE <br>  CHECKSZ(pctiProps-&gt;AddImplType(0, hreftype), "cti AddImplType FAILED"); <br> <br>  funcdesc.funckind = FUNC_DISPATCH; <br>  funcdesc.invkind  = INVOKE_PROPERTYGET; <br>  funcdesc.callconv = CC_STDCALL; <br>  funcdesc.cScodes  = -1; <br>  funcdesc.elemdescFunc.tdesc.vt = VT_PTR; <br>  funcdesc.elemdescFunc.tdesc.lptdesc = &amp;tdescUser; <br>  tdescUser.vt = VT_USERDEFINED; <br> <br>  // Loop through all of the SpriteClasses ($OBJECTs) in this game, adding a <br>  // property to pctiProps which corresponds to the control. <br>  index = 0; <br>  for (i=0; i&lt;m_csubobj; i++) <br>    { <br>    // Need to make sure this starts out cleared <br>    if (!g_ptinfoClsSpriteClass) <br>      { <br>      CHECKCL(LoadTypeInfo(g_hinst, 0, 1, 0, 0x0409, <br>                           LIBID_SPRUUIDS, CLSID_SpriteClass, IID_ISpriteClass, FALSE, <br>                           &amp;g_ptlMain, &amp;g_ptinfoClsSpriteClass, &amp;g_ptinfoIntSpriteClass)); <br>      } <br>    CHECKCL(pctiProps-&gt;AddRefTypeInfo(g_ptinfoClsSpriteClass, &amp;tdescUser.hreftype)); <br>    funcdesc.memid = 0x80010000 | i; <br>    funcdesc.wFuncFlags = FUNCFLAG_FSOURCE; <br> <br>    CHECKCL(pctiProps-&gt;AddFuncDesc(index, &amp;funcdesc)); <br>    CHECKCL(pctiProps-&gt;SetFuncAndParamNames(index, &amp;m_rgpwszSubObjs[i], 1)); <br> <br>    index++; <br>    continue; <br> <br>CheckLoop: <br>    // Do any clean up here <br> <br>    CHECKSZ(hr,"BuildTypeInfo FAILED"); <br>    break; <br>    } <br> <br>  // Finish off the TI for the Props <br>  CHECKSZ(pctiProps-&gt;LayOut(), "BuildTypeInfo FAILED"); <br>  CHECKSZ(pctiProps-&gt;QueryInterface(IID_ITypeInfo, (void **)&amp;g_ptinfoIntGame), "BuildTypeInfo FAILED"); <br> <br>  // Now we have to create a coclass for the interface <br>  CHECKSZ(pcreatetl-&gt;CreateTypeInfo(L"Game", TKIND_COCLASS, &amp;pctiCoClass), "BuildTypeInfo FAILED"); <br>  CHECKSZ(pctiCoClass-&gt;SetGuid(m_clsidSubObj), "BuildTypeInfo FAILED"); <br>  CHECKSZ(pctiCoClass-&gt;SetVersion(1, 0), "BuildTypeInfo FAILED"); <br> <br>  // Add the Page Property dispinterface to coclass <br>  CHECKSZ(pctiCoClass-&gt;AddRefTypeInfo(g_ptinfoIntGame, &amp;hreftype), "BuildTypeInfo FAILED"); <br>  CHECKSZ(pctiCoClass-&gt;AddImplType(0, hreftype), "BuildTypeInfo FAILED"); <br>  CHECKSZ(pctiCoClass-&gt;SetImplTypeFlags(0, IMPLTYPEFLAG_FDEFAULT), "BuildTypeInfo FAILED"); <br> <br>  // Finish off the CoClass <br>  CHECKSZ(pctiCoClass-&gt;LayOut(), "BuildTypeInfo FAILED"); <br>  CHECKSZ(pctiCoClass-&gt;QueryInterface(IID_ITypeInfo, (void **)&amp;g_ptinfoClsGame), "BuildTypeInfo FAILED"); <br> <br>  // Finish off the Library <br>  CHECKSZ(pcreatetl-&gt;QueryInterface(IID_ITypeLib, (void **)&amp;g_ptlGameSubObj), "BuildTypeLib FAILED"); <br> <br>CleanUp: <br>  // Code to release refs aquired during page build. <br>  if (pctiCoClass) <br>    pctiCoClass-&gt;Release(); <br>  if (pctiProps) <br>    pctiProps-&gt;Release(); <br>  if (ptinfoIDisp) <br>    ptinfoIDisp-&gt;Release(); <br>  if (ptlStdOle) <br>    ptlStdOle-&gt;Release(); <br>  if (pcreatetl) <br>    pcreatetl-&gt;Release(); <br> <br>  return hr; <br>}; <br> <br>//--- EOF ------------------------------------------------------------------- </code></pre>
<p>&nbsp;</p></body>
</HTML>
