<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>COMPMGR.H</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context4602"></a>COMPMGR.H</h2>
<pre><code>//--------------------------------------------------------------------------- <br>// CompMgr.h <br>//--------------------------------------------------------------------------- <br>// This file contains the exported interfaces and declarations for  <br>// Component Manager Interfaces. <br>//--------------------------------------------------------------------------- <br>// Copyright (c) 1995-1997 Microsoft Corporation <br>//--------------------------------------------------------------------------- <br> <br> <br>#ifdef INITGUID <br>    #define DEFINE_GUID2(name, bCategory, bIndex) \ <br>        EXTERN_C const GUID name = {0x000C0000 | MAKEWORD(bIndex, bCategory),} <br>#else <br>    #define DEFINE_GUID2(name, bCategory, bIndex) \ <br>        EXTERN_C const GUID name <br>#endif <br> <br>DEFINE_GUID2(IID_IOleComponent,        0x06, 0x00); <br>DEFINE_GUID2(IID_IOleComponentManager, 0x06, 0x01); <br> <br> <br> <br>//*************************************************************************** <br>// Component integration structures and constants <br>//*************************************************************************** <br> <br>//--------------------------------------------------------------------------- <br>// Component registration flags <br>//--------------------------------------------------------------------------- <br>enum <br>    { <br>    cmgrrfNeedIdleTime         = 1,  // needs idle time <br>    cmgrrfNeedPeriodicIdleTime = 2,  // needs idle time every N milliseconds <br>    cmgrrfPreTranslateKeys     = 4,  // must process keyboard msgs  <br>                             // before translation <br>    cmgrrfPreTranslateAll      = 8,  // must process all msgs  <br>                             // before translation <br>    }; <br> <br> <br>//--------------------------------------------------------------------------- <br>// Component registration advise flags (see cmgrstate enumeration) <br>//--------------------------------------------------------------------------- <br>enum <br>    { <br>    cmgradvfModal              = 1,  // needs modal state change notification <br>                             // (must be registered by components <br>                             // managing a toplevel window) <br>    cmgradvfRedrawOff          = 2,  // needs redrawOff state change notif <br>    cmgradvfWarningsOff        = 4,  // needs warningsOff state change notif <br>    cmgradvfRecording          = 8,  // needs Recording state change notif <br>    cmgradvfExclusiveActive    = 16, // needs ExclusiveActive change notif <br>                             // (must be registered by components <br>                             //  managing a window with UI). <br>    }; <br> <br> <br>//--------------------------------------------------------------------------- <br>// Component registration information <br>//--------------------------------------------------------------------------- <br>typedef struct _CMGRRINFO <br>    { <br>    ULONG cbSize;             // size of CMGRRINFO structure in bytes. <br>    ULONG uIdleTimeInterval;  // If cmgrrfNeedPeriodicIdleTime is registered <br>                      // in grfcrf, component needs to perform <br>                      // periodic idle time tasks during an idle phase <br>                      // every uIdleTimeInterval milliseconds. <br>    DWORD grfcrf;             // bit flags taken from cmgrrf values (above) <br>    DWORD grfcadvf;           // bit flags taken from cmgradvf values (above) <br>    } CMGRRINFO; <br> <br> <br>//--------------------------------------------------------------------------- <br>// Idle flags, passed to IOleComponent::FDoIdle and  <br>// IOleStdComponentMgr::FDoIdle. <br>//--------------------------------------------------------------------------- <br>enum <br>    { <br>    cmgridlefPeriodic    = 1,  // periodic idle tasks <br>    cmgridlefNonPeriodic = 2,  // any nonperiodic idle task <br>    cmgridlefPriority    = 4,  // high priority, nonperiodic idle tasks <br>    cmgridlefAll         = -1  // all idle tasks <br>    }; <br> <br> <br>//--------------------------------------------------------------------------- <br>// Reasons for pushing a message loop, passed to  <br>// IOleComponentHost::FPushMessageLoop.  The host should remain in message <br>// loop until IOleComponent::FContinueMessageLoop returns FALSE. <br>//--------------------------------------------------------------------------- <br>enum <br>    { <br>    cmgrloopFocusWait = 1,  // component is activating host  <br>    cmgrloopDoEvents  = 2,  // component is asking host to process messages <br>    cmgrloopDebug     = 3,  // component has entered debug mode <br>    cmgrloopModalForm = 4   // component is displaying a modal form   <br>    }; <br> <br> <br>//--------------------------------------------------------------------------- <br>// cmgrstate values: state IDs passed to  <br>//  IOleComponent::OnEnterState,  <br>//  IOleComponentManager::OnComponentEnterState/FOnComponentExitState/FInState, <br>// <br>//  When the host or a component is notified through one of these methods that  <br>//  another entity (component or host) is entering or exiting a state  <br>//  identified by one of these state IDs, the host/component should take <br>//  appropriate action: <br>//      cmgrstateModal (modal state): <br>//    If app is entering modal state, host/component should disable <br>//    its toplevel windows, and reenable them when app exits this <br>//    state.  Also, when this state is entered or exited, host/component <br>//    should notify approprate inplace objects via  <br>//    IOleInPlaceActiveObject::EnableModeless. <br>//cmgrstateRedrawOff (redrawOff state): <br>//    If app is entering redrawOff state, host/component should disable <br>//    repainting of its windows, and reenable repainting when app exits <br>//    this state. <br>//cmgrstateWarningsOff (warningsOff state): <br>//    If app is entering warningsOff state, host/component should disable <br>//    the presentation of any user warnings, and reenable this when <br>//    app exits this state. <br>//cmgrstateRecording (Recording state): <br>//    Used to notify host/component when Recording is turned on or off. <br>//cmgrstateExclusiveActive (Exclusive Active state) <br>//    TODO: add comments on what host/component should do. <br>//--------------------------------------------------------------------------- <br>enum <br>    { <br>    cmgrstateModal       = 1,     // Modal state; disable toplevel windows <br>    cmgrstateRedrawOff   = 2,     // RedrawOff state; disable window repainting <br>    cmgrstateWarningsOff = 3,     // WarningsOff state; disable user warnings <br>    cmgrstateRecording   = 4,     // Recording state <br>    cmgrstateExclusiveActive = 5, // ExclusiveActive state; TODO: add brief <br>                          // comment on what should be done here <br>    }; <br> <br> <br>//--------------------------------------------------------------------------- <br>// ** Comments on State Contexts ** <br>//--------------------------------------------------------------------------- <br>// IOleComponentManager::FCreateSubComponentManager allows one to create a  <br>// hierarchical tree of component managers.  This tree is used to maintain  <br>// multiple contexts with regard to cmgrstateXXX states.  These contexts are  <br>// referred to as 'state contexts'. <br>// Each component manager in the tree defines a state context.  The <br>// components registered with a particular component manager or any of its <br>// descendents live within that component manager's state context.  Calls <br>// to IOleComponentManager::OnComponentEnterState/FOnComponentExitState <br>// can be used to affect all components, only components within the component <br>// manager's state context, or only those components that are outside of the <br>// component manager's state context.  IOleComponentManager::FInState is used <br>// to query the state of the component manager's state context at its root. <br>// <br>// cmgrcontext values: context indicators passed to  <br>// IOleComponentManager::OnComponentEnterState/FOnComponentExitState. <br>// These values indicate the state context that is to be affected by the <br>// state change.  <br>// In IOleComponentManager::OnComponentEnterState/FOnComponentExitState, <br>// the comp mgr informs only those components/host that are within the <br>// specified state context. <br>//--------------------------------------------------------------------------- <br>enum <br>    { <br>    cmgrcontextAll    = 0, // all state contexts in state context tree <br>    cmgrcontextMine   = 1, // component manager's state context <br>    cmgrcontextOthers = 2, // all other state contexts outside of comp mgr's <br>    }; <br> <br> <br>//--------------------------------------------------------------------------- <br>// Defines the IOleComponent interface <br>//--------------------------------------------------------------------------- <br>// Any component that needs idle time, the ability to process messages before <br>// they are translated (for example, to call TranslateAccelerator() or <br>// IsDialogMessage), notification about modal states, or the ability push <br>// message loops must implement this interface and register with the <br>// Component Manager. <br>//--------------------------------------------------------------------------- <br>#undef  INTERFACE <br>#define INTERFACE  IOleComponent <br> <br>DECLARE_INTERFACE_(IOleComponent, IUnknown) <br>{ <br>// *** IUnknown methods *** <br>STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE; <br>STDMETHOD_(ULONG, AddRef) (THIS) PURE; <br>STDMETHOD_(ULONG, Release) (THIS) PURE; <br> <br>// Give component a chance to process the message pMsg before it is <br>// translated and dispatched. Component can do TranslateAccelerator, <br>// do IsDialogMessage, modify pMsg, or take some other action. <br>// Return TRUE if the message is consumed, FALSE otherwise. <br>STDMETHOD_(BOOL, FPreTranslateMessage) (THIS_ MSG *pMsg) PURE; <br> <br>#if MAC <br>// Give Macintosh component a chance to process the event pEvt <br>// before it is processed by the host.  <br>// Return TRUE if the event is consumed, FALSE otherwise. <br>// (WLM components can simply return FALSE.) <br>STDMETHOD_(BOOL, FPreProcessMacEvent) (THIS_ EventRecord *pEvt) PURE; <br>#endif // MAC <br> <br>// Notify component when app enters or exits (as indicated by fEnter) <br>// the state identified by uStateID (a value from cmgrstate enumeration). <br>// Component should take action depending on value of uStateID <br>// (see cmgrstate comments, above). <br>//  <br>// Note: If n calls are made with TRUE fEnter, component should consider  <br>// the state to be in effect until n calls are made with FALSE fEnter. <br>//  <br>// Note: Components should be aware that it is possible for this method to <br>// be called with FALSE fEnter more times than it was called with TRUE  <br>// fEnter (so, for example, if component is maintaining a state counter <br>// (incremented when this method is called with TRUE fEnter, decremented <br>// when called with FALSE fEnter), the counter should not be decremented <br>// for FALSE fEnter if it is already at zero.) <br>STDMETHOD_(void, OnEnterState) (THIS_ ULONG uStateID, BOOL fEnter) PURE; <br> <br>// Notify component when the host application gains or loses activation. <br>// If fActive is TRUE, the host app is being activated and dwOtherThreadID <br>// is the ID of the thread owning the window being deactivated. <br>// If fActive is FALSE, the host app is being deactivated and  <br>// dwOtherThreadID is the ID of the thread owning the window being  <br>// activated. <br>// Note: this method is not called when both the window being activated <br>// and the one being deactivated belong to the host app. <br>STDMETHOD_(void, OnAppActivate) (THIS_  <br>BOOL fActive, DWORD dwOtherThreadID) PURE; <br> <br>// Notify the active component that it has lost its active status because <br>// the host or another component has become active. <br>STDMETHOD_(void, OnLoseActivation) (THIS) PURE; <br> <br>// Give component a chance to do idle time tasks.  grfidlef is a group of <br>// bit flags taken from the enumeration of cmgridlef values (above), <br>// indicating the type of idle tasks to perform.   <br>// Component may periodically call IOleComponentManager::FContinueIdle;  <br>// if this method returns FALSE, component should terminate its idle  <br>// time processing and return.   <br>// Return TRUE if more time is needed to perform the idle time tasks,  <br>// FALSE otherwise. <br>// Note: If a component reaches a point where it has no idle tasks <br>// and does not need FDoIdle calls, it should remove its idle task <br>// registration via IOleComponentManager::FUpdateComponentRegistration. <br>// Note: If this method is called on while component is performing a  <br>// tracking operation, component should only perform idle time tasks that <br>// it deems are appropriate to perform during tracking. <br>STDMETHOD_(BOOL, FDoIdle) (THIS_ DWORD grfidlef) PURE; <br> <br>// Called once per iteration of a message loop that the component pushed. <br>// uReason and pvLoopData are the reason and the component private data <br>// that were passed to IOleComponentManager::FPushMessageLoop. <br>// Return TRUE if the message loop should continue, FALSE otherwise. <br>STDMETHOD_(BOOL, FContinueMessageLoop) (THIS_  <br>ULONG uReason, void *pvLoopData) PURE; <br> <br>// Called when component manager wishes to know if the component is in a <br>// state in which it can terminate.  If fPromptUser is FALSE, component <br>// should simply return TRUE if it can terminate, FALSE otherwise. <br>// If fPromptUser is TRUE, component should return TRUE if it can <br>// terminate without prompting the user; otherwise it should prompt the <br>// user, either 1.) asking user if it can terminate and returning TRUE <br>// or FALSE appropriately, or 2.) giving an indication as to why it <br>// cannot terminate and returning FALSE. <br>STDMETHOD_(BOOL, FQueryTerminate) (THIS_ BOOL fPromptUser) PURE; <br> <br>// Called when component manager wishes to terminate the component's <br>// registration.  Component should revoke its registration with component <br>// manager, release references to component manager and perform any <br>// necessary cleanup. <br>STDMETHOD_(void, Terminate) (THIS) PURE; <br>}; <br> <br> <br> <br>//--------------------------------------------------------------------------- <br>// Defines the IOleComponentManager interface <br>//--------------------------------------------------------------------------- <br>// A component manager is an object implementing the IOleComponentManager <br>// interface.  The component manager coordinates components with its message <br>// loop for proper distribution of idle time and pre-translation message <br>// processing. <br>// It also coordinates modalities and the pushing of message loops. <br>//--------------------------------------------------------------------------- <br>#undef  INTERFACE <br>#define INTERFACE  IOleComponentManager <br> <br>DECLARE_INTERFACE_(IOleComponentManager, IUnknown) <br>{ <br>// *** IUnknown methods *** <br>STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE; <br>STDMETHOD_(ULONG, AddRef) (THIS) PURE; <br>STDMETHOD_(ULONG, Release) (THIS) PURE; <br> <br>// Return in *ppvObj an implementation of interface iid for service <br>// guidService (same as IServiceProvider::QueryService). <br>// Return NOERROR if the requested service is supported, otherwise return <br>// NULL in *ppvObj and an appropriate error (eg E_FAIL, E_NOINTERFACE). <br>STDMETHOD(QueryService) (THIS_ <br>REFGUID guidService, REFIID iid, void **ppvObj) PURE; <br> <br>// Register component piComponent and its registration info pcrinfo with <br>// this component manager.  Return in *pdwComponentID a cookie which will <br>// identify the component when it calls other IOleComponentManager <br>// methods. <br>// Return TRUE if successful, FALSE otherwise. <br>STDMETHOD_(BOOL, FRegisterComponent) (THIS_ <br>IOleComponent *piComponent, const CMGRRINFO *pcrinfo,  <br>DWORD *pdwComponentID) PURE; <br> <br>// Undo the registration of the component identified by dwComponentID <br>// (the cookie returned from the FRegisterComponent method). <br>// Return TRUE if successful, FALSE otherwise. <br>STDMETHOD_(BOOL, FRevokeComponent) (THIS_ DWORD dwComponentID) PURE; <br> <br>// Update the registration info of the component identified by <br>// dwComponentID (the cookie returned from FRegisterComponent) with the <br>// new registration information pcrinfo. <br>// Typically this is used to update the idle time registration data, but <br>// can be used to update other registration data as well. <br>// Return TRUE if successful, FALSE otherwise. <br>STDMETHOD_(BOOL, FUpdateComponentRegistration) (THIS_  <br>DWORD dwComponentID, const CMGRRINFO *pcrinfo) PURE; <br> <br>// Notify component manager that component identified by dwComponentID <br>// (cookie returned from FRegisterComponent) has been activated. <br>// The active component gets the chance to process messages before they <br>// are dispatched (via IOleComponent::FPreTranslateMessage) and typically <br>// gets first crack at idle time after the host. <br>STDMETHOD_(void, OnComponentActivate) (THIS_ DWORD dwComponentID) PURE; <br> <br>// Called to inform component manager that  component identified by  <br>// dwComponentID (cookie returned from FRegisterComponent) wishes <br>// to perform a tracking operation (such as mouse tracking). <br>// The component calls this method with fTrack == TRUE to begin the <br>// tracking operation and with fTrack == FALSE to end the operation. <br>// During the tracking operation the component manager routes messages <br>// to the tracking component (via IOleComponent::FPreTranslateMessage) <br>// rather than to the active component.  When the tracking operation ends, <br>// the component manager should resume routing messages to the active <br>// component.   <br>// Note: component manager should perform no idle time processing during a <br>// tracking operation other than give the tracking component idle <br>// time via IOleComponent::FDoIdle. <br>// Note: there can only be one tracking component at a time. <br>// Return TRUE if successful, FALSE otherwise. <br>STDMETHOD_(BOOL, FSetTrackingComponent) (THIS_  <br>DWORD dwComponentID, BOOL fTrack) PURE; <br> <br>// Notify component manager that component identified by dwComponentID <br>// (cookie returned from FRegisterComponent) is entering the state <br>// identified by uStateID (cmgrstateXXX value).  (For convenience when <br>// dealing with sub CompMgrs, the host can call this method passing 0 for <br>// dwComponentID.)   <br>// Component manager should notify all other interested components within <br>// the state context indicated by uContext (a cmgrcontextXXX value), <br>// excluding those within the state context of a CompMgr in rgpicmExclude, <br>// via IOleComponent::OnEnterState (see "Comments on State Contexts",  <br>// above). <br>// Component Manager should also take appropriate action depending on the  <br>// value of uStateID (see cmgrstate comments, above). <br>// dwReserved is reserved for future use and should be zero. <br>        //  <br>// rgpicmExclude (can be NULL) is an array of cpicmExclude CompMgrs (can <br>// include root CompMgr and/or sub CompMgrs); components within the state <br>// context of a CompMgr appearing in thisarray should NOT be notified of  <br>// the state change (note: if uContextis cmgrcontextMine, the only  <br>// CompMgrs in rgpicmExclude that are checked for exclusion are those that  <br>// are sub CompMgrs of this Component Manager, since all other CompMgrs  <br>// are outside of this Component Manager's state context anyway.) <br>        //  <br>// Note: Calls to this method are symmetric with calls to  <br>// FOnComponentExitState.  <br>// That is, if n OnComponentEnterState calls are made, the component is <br>// considered to be in the state until n FOnComponentExitState calls are <br>// made.  Before revoking its registration a component must make a  <br>// sufficient number of FOnComponentExitState calls to offset any <br>// outstanding OnComponentEnterState calls it has made. <br>        //  <br>// Note: inplace objects should not call this method with <br>// uStateID == cmgrstateModal when entering modal state. Such objects <br>// should call IOleInPlaceFrame::EnableModeless instead. <br>STDMETHOD_(void, OnComponentEnterState) (THIS_  <br>DWORD dwComponentID,  <br>ULONG uStateID,  <br>ULONG uContext, <br>ULONG cpicmExclude, <br>IOleComponentManager **rgpicmExclude,  <br>DWORD dwReserved) PURE; <br> <br>// Notify component manager that component identified by dwComponentID <br>// (cookie returned from FRegisterComponent) is exiting the state <br>// identified by uStateID (a cmgrstateXXX value).  (For convenience when <br>// dealing with sub CompMgrs, the host can call this method passing 0 for <br>// dwComponentID.) <br>// uContext, cpicmExclude, and rgpicmExclude are as they are in  <br>// OnComponentEnterState. <br>// Component managershould notify all appropriate interested components <br>// (taking into account uContext, cpicmExclude, rgpicmExclude) via <br>// IOleComponent::OnEnterState (see "Comments on State Contexts", above).  <br>// Component Manager should also take appropriate action depending on <br>// the value of uStateID (see cmgrstate comments, above). <br>// Return TRUE if, at the end of this call, the state is still in effect <br>// at the root of this component manager's state context <br>// (because the host or some other component is still in the state), <br>// otherwise return FALSE (ie. return what FInState would return). <br>// Caller can normally ignore the return value. <br>//  <br>// Note: n calls to this method are symmetric with n calls to  <br>// OnComponentEnterState (see OnComponentEnterState comments, above). <br>STDMETHOD_(BOOL, FOnComponentExitState) (THIS_  <br>DWORD dwComponentID,  <br>ULONG uStateID,  <br>ULONG uContext, <br>ULONG cpicmExclude, <br>IOleComponentManager **rgpicmExclude) PURE; <br> <br>// Return TRUE if the state identified by uStateID (a cmgrstateXXX value) <br>// is in effect at the root of this component manager's state context,  <br>// FALSE otherwise (see "Comments on State Contexts", above). <br>// pvoid is reserved for future use and should be NULL. <br>STDMETHOD_(BOOL, FInState) (THIS_ ULONG uStateID, void *pvoid) PURE; <br> <br>// Called periodically by a component during IOleComponent::FDoIdle. <br>// Return TRUE if component can continue its idle time processing,  <br>// FALSE if not (in which case component returns from FDoIdle.) <br>STDMETHOD_(BOOL, FContinueIdle) (THIS) PURE; <br> <br>// Component identified by dwComponentID (cookie returned from  <br>// FRegisterComponent) wishes to push a message loop for reason uReason. <br>// uReason is one the values from the cmgrloop enumeration (above). <br>// pvLoopData is data private to the component. <br>// The host should push its message loop,  <br>// calling IOleComponent::FContinueMessageLoop(uReason, pvLoopData) <br>// once per loop iteration.  When IOleComponent::FContinueMessageLoop <br>// returns FALSE, the host should terminate the loop. <br>STDMETHOD_(BOOL, FPushMessageLoop) (THIS_  <br>DWORD dwComponentID, ULONG uReason, void *pvLoopData) PURE; <br> <br>// Cause the component manager to create a "sub" component manager, which <br>// will be one of its children in the hierarchical tree of component <br>// managers used to maintiain state contexts (see "Comments on State <br>// Contexts", above). <br>// piunkOuter is the controlling unknown (can be NULL), riid is the <br>// desired IID, and *ppvObj returns the created sub component manager. <br>// piunkServProv (can be NULL) is a ptr to an object supporting <br>// IServiceProvider interface to which the created sub component manager <br>// will delegate its IOleComponentManager::QueryService calls.  <br>// (see objext.h or docobj.h for definition of IServiceProvider). <br>// Returns TRUE if successful. <br>STDMETHOD_(BOOL, FCreateSubComponentManager) (THIS_  <br>IUnknown *piunkOuter,  <br>IUnknown *piunkServProv, <br>REFIID riid,  <br>void **ppvObj) PURE; <br> <br>// Return in *ppicm an AddRef'ed ptr to this component manager's parent <br>// in the hierarchical tree of component managers used to maintain state <br>// contexts (see "Comments on State Contexts", above). <br>// Returns TRUE if the parent is returned, FALSE if no parent exists or <br>// some error occurred. <br>STDMETHOD_(BOOL, FGetParentComponentManager) (THIS_  <br>IOleComponentManager **ppicm) PURE; <br> <br>// Return in *ppic an AddRef'ed ptr to the current active component. <br>// Returns TRUE if the active component is returned, FALSE if no component <br>// is active or some error occurred. <br>// dwReserved is reserved for future use and should be zero. <br>STDMETHOD_(BOOL, FGetActiveComponent) (THIS_  <br>DWORD dwReserved, IOleComponent **ppic) PURE; <br>}; <br> <br>//--- EOF ------------------------------------------------------------------- </code></pre>
<p>&nbsp;</p></body>
</HTML>
