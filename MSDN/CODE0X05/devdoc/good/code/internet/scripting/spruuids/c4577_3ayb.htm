<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>GAMEOA.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context4583"></a>GAMEOA.CPP</h2>
<pre><code>//--------------------------------------------------------------------------- <br>// GameOA.cpp <br>//--------------------------------------------------------------------------- <br>// Sample spr program, OLE Automation implementation <br>//--------------------------------------------------------------------------- <br>// (C) Copyright 1992-1997 by Microsoft Corporation.  All rights reserved. <br>// <br>// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF  <br>// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO  <br>// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A  <br>// PARTICULAR PURPOSE. <br>//--------------------------------------------------------------------------- <br> <br>#include "Main.h" <br>#pragma hdrstop <br>#include "Game.h" <br>#include "App.h" <br>#include "Spr.h" <br>#include "Score.h" <br>#include "DispIDs.h" <br>#include &lt;math.h&gt; <br> <br> <br>//--------------------------------------------------------------------------- <br>// DEBUG info <br>//--------------------------------------------------------------------------- <br>SZTHISFILE <br> <br> <br>//--------------------------------------------------------------------------- <br>// Various Globals <br>//--------------------------------------------------------------------------- <br>extern CGame *g_pgame; <br>ITypeInfo *g_ptinfoClsGameOA = NULL; <br>ITypeInfo *g_ptinfoIntGameOA = NULL; <br> <br> <br> <br>//*************************************************************************** <br>// Constructor / Destructor <br>//*************************************************************************** <br> <br>//--------------------------------------------------------------------------- <br>// <br>//--------------------------------------------------------------------------- <br>CGameOA::CGameOA <br>( <br>  CGame *pgame <br>) <br>{ <br>  m_pgame           = pgame; <br>  m_pdispBaseObject = NULL; <br>} <br> <br> <br> <br>//*************************************************************************** <br>// Fire IGameEvents Events <br>//*************************************************************************** <br> <br>//--------------------------------------------------------------------------- <br>// <br>//--------------------------------------------------------------------------- <br>void CGameOA::FireNewGame <br>( <br>  void <br>) <br>{ <br>  IDispatch **ppdisp = m_cp.m_rgpdisp; <br> <br>  for (; ppdisp &lt; &amp;m_cp.m_rgpdisp[GAME_cADVISE]; ppdisp++) <br>    if (*ppdisp) <br>      InvokeEvent(*ppdisp, DISPID_GameEvents_NewGame, NULL, 0); <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>// <br>//--------------------------------------------------------------------------- <br>void CGameOA::FireNewLevel <br>( <br>  void <br>) <br>{ <br>  IDispatch **ppdisp = m_cp.m_rgpdisp; <br> <br>  for (; ppdisp &lt; &amp;m_cp.m_rgpdisp[GAME_cADVISE]; ppdisp++) <br>    if (*ppdisp) <br>      InvokeEvent(*ppdisp, DISPID_GameEvents_NewLevel, NULL, 0); <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>// <br>//--------------------------------------------------------------------------- <br>void CGameOA::FireNewShip <br>( <br>  void <br>) <br>{ <br>  IDispatch **ppdisp = m_cp.m_rgpdisp; <br> <br>  for (; ppdisp &lt; &amp;m_cp.m_rgpdisp[GAME_cADVISE]; ppdisp++) <br>    if (*ppdisp) <br>      InvokeEvent(*ppdisp, DISPID_GameEvents_NewShip, NULL, 0); <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>// <br>//--------------------------------------------------------------------------- <br>void CGameOA::FireCollide <br>( <br>  CSprite *psprLowId, <br>  CSprite *psprHighId, <br>  int      maskCollide <br>) <br>{ <br>  IDispatch **ppdisp = g_pgame-&gt;m_pgameoa-&gt;m_cp.m_rgpdisp; <br>  VARIANTARG  var[3]; <br> <br>  VariantInit(&amp;var[2]); <br>  var[2].vt = VT_DISPATCH; <br>  var[2].pdispVal = psprLowId-&gt;GetDispatch(); <br>  psprLowId-&gt;AddRef(); <br>  VariantInit(&amp;var[1]); <br>  var[1].vt = VT_DISPATCH; <br>  var[1].pdispVal = psprHighId-&gt;GetDispatch(); <br>  psprHighId-&gt;AddRef(); <br>  VariantInit(&amp;var[0]); <br>  var[0].vt = VT_I4; <br>  var[0].lVal = maskCollide; <br> <br>  for (; ppdisp &lt; &amp;g_pgame-&gt;m_pgameoa-&gt;m_cp.m_rgpdisp[GAME_cADVISE]; ppdisp++) <br>    if (*ppdisp) <br>      InvokeEvent(*ppdisp, DISPID_GameEvents_Collide, var, 3); <br> <br>  psprLowId-&gt;Release();     // For var[2].pdispVal <br>  psprHighId-&gt;Release();    // For var[1].pdispVal <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>// <br>//--------------------------------------------------------------------------- <br>void CGameOA::FireTick <br>( <br>  void <br>) <br>{ <br>  IDispatch **ppdisp = m_cp.m_rgpdisp; <br> <br>  for (; ppdisp &lt; &amp;m_cp.m_rgpdisp[GAME_cADVISE]; ppdisp++) <br>    if (*ppdisp) <br>      InvokeEvent(*ppdisp, DISPID_GameEvents_Tick, NULL, 0); <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>// <br>//--------------------------------------------------------------------------- <br>void CGameOA::FireKeyDown <br>( <br>  int vk <br>) <br>{ <br>  IDispatch **ppdisp = m_cp.m_rgpdisp; <br>  VARIANTARG  var[2]; <br> <br>  VariantInit(&amp;var[0]); <br>  var[0].vt   = VT_I4; <br>  var[0].lVal = vk; <br> <br>  for (; ppdisp &lt; &amp;m_cp.m_rgpdisp[GAME_cADVISE]; ppdisp++) <br>    if (*ppdisp) <br>      InvokeEvent(*ppdisp, DISPID_GameEvents_KeyDown, var, 1); <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>// <br>//--------------------------------------------------------------------------- <br>void CGameOA::FireKeyPress <br>( <br>  int ascii <br>) <br>{ <br>  IDispatch **ppdisp = m_cp.m_rgpdisp; <br>  VARIANTARG  var[1]; <br> <br>  VariantInit(&amp;var[0]); <br>  var[0].vt   = VT_I4; <br>  var[0].lVal = ascii; <br> <br>  for (; ppdisp &lt; &amp;m_cp.m_rgpdisp[GAME_cADVISE]; ppdisp++) <br>    if (*ppdisp) <br>      InvokeEvent(*ppdisp, DISPID_GameEvents_KeyPress, var, 1); <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>// <br>//--------------------------------------------------------------------------- <br>void CGameOA::FireKeyUp <br>( <br>  int vk <br>) <br>{ <br>  IDispatch **ppdisp = m_cp.m_rgpdisp; <br>  VARIANTARG  var[2]; <br> <br>  VariantInit(&amp;var[0]); <br>  var[0].vt   = VT_I4; <br>  var[0].lVal = vk; <br> <br>  for (; ppdisp &lt; &amp;m_cp.m_rgpdisp[GAME_cADVISE]; ppdisp++) <br>    if (*ppdisp) <br>      InvokeEvent(*ppdisp, DISPID_GameEvents_KeyUp, var, 1); <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>// <br>//--------------------------------------------------------------------------- <br>void CGameOA::FireMouseMove <br>( <br>  int  x, <br>  int  y, <br>  long mk <br>) <br>{ <br>  IDispatch **ppdisp = m_cp.m_rgpdisp; <br>  VARIANTARG  var[4]; <br> <br>  VariantInit(&amp;var[3]); <br>  var[3].vt = VT_I4; <br>  var[3].lVal = (mk &amp; MK_SHIFT   ? 1 : 0) | <br>                (mk &amp; MK_CONTROL ? 2 : 0); <br>  VariantInit(&amp;var[2]); <br>  var[2].vt = VT_I4; <br>  var[2].lVal = (mk &amp; MK_LBUTTON ? 1 : 0) | <br>                (mk &amp; MK_RBUTTON ? 2 : 0) | <br>                (mk &amp; MK_MBUTTON ? 4 : 0); <br>  VariantInit(&amp;var[1]); <br>  var[1].vt = VT_I4; <br>  var[1].lVal = x; <br>  VariantInit(&amp;var[0]); <br>  var[0].vt = VT_I4; <br>  var[0].lVal = y; <br> <br>  for (; ppdisp &lt; &amp;m_cp.m_rgpdisp[GAME_cADVISE]; ppdisp++) <br>    if (*ppdisp) <br>      InvokeEvent(*ppdisp, DISPID_GameEvents_MouseMove, var, 4); <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>// <br>//--------------------------------------------------------------------------- <br>void CGameOA::FireMouseDown <br>( <br>  int  x, <br>  int  y, <br>  long mk, <br>  long button <br>) <br>{ <br>  IDispatch **ppdisp = m_cp.m_rgpdisp; <br>  VARIANTARG  var[4]; <br> <br>  VariantInit(&amp;var[3]); <br>  var[3].vt = VT_I4; <br>  var[3].lVal = (mk &amp; MK_SHIFT   ? 1 : 0) | <br>                (mk &amp; MK_CONTROL ? 2 : 0); <br>  VariantInit(&amp;var[2]); <br>  var[2].vt = VT_I4; <br>  var[2].lVal = (button &amp; MK_LBUTTON ? 1 : 0) | <br>                (button &amp; MK_RBUTTON ? 2 : 0) | <br>                (button &amp; MK_MBUTTON ? 4 : 0); <br>  VariantInit(&amp;var[1]); <br>  var[1].vt = VT_I4; <br>  var[1].lVal = x; <br>  VariantInit(&amp;var[0]); <br>  var[0].vt = VT_I4; <br>  var[0].lVal = y; <br> <br>  for (; ppdisp &lt; &amp;m_cp.m_rgpdisp[GAME_cADVISE]; ppdisp++) <br>    if (*ppdisp) <br>      InvokeEvent(*ppdisp, DISPID_GameEvents_MouseDown, var, 4); <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>// <br>//--------------------------------------------------------------------------- <br>void CGameOA::FireMouseUp <br>( <br>  int  x, <br>  int  y, <br>  long mk, <br>  long button <br>) <br>{ <br>  IDispatch **ppdisp = m_cp.m_rgpdisp; <br>  VARIANTARG  var[4]; <br> <br>  VariantInit(&amp;var[3]); <br>  var[3].vt = VT_I4; <br>  var[3].lVal = (mk &amp; MK_SHIFT   ? 1 : 0) | <br>                (mk &amp; MK_CONTROL ? 2 : 0); <br>  VariantInit(&amp;var[2]); <br>  var[2].vt = VT_I4; <br>  var[2].lVal = (button &amp; MK_LBUTTON ? 1 : 0) | <br>                (button &amp; MK_RBUTTON ? 2 : 0) | <br>                (button &amp; MK_MBUTTON ? 4 : 0); <br>  VariantInit(&amp;var[1]); <br>  var[1].vt = VT_I4; <br>  var[1].lVal = x; <br>  VariantInit(&amp;var[0]); <br>  var[0].vt = VT_I4; <br>  var[0].lVal = y; <br> <br>  for (; ppdisp &lt; &amp;m_cp.m_rgpdisp[GAME_cADVISE]; ppdisp++) <br>    if (*ppdisp) <br>      InvokeEvent(*ppdisp, DISPID_GameEvents_MouseUp, var, 4); <br>} <br> <br> <br>//*************************************************************************** <br>// IGame Interface <br>//*************************************************************************** <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CGameOA::get_Caption <br>( <br>  BSTR* pRet <br>) <br>{ <br>  if (!pRet) <br>    return E_INVALIDARG; <br>  UINT cch = GetWindowTextLength(m_pgame-&gt;m_hwndDlg); <br>  char *pszT = new char[cch+1]; <br>  if (!pszT) <br>    return E_OUTOFMEMORY; <br>  *pRet = SysAllocStringLen(NULL, cch); <br>  if (!*pRet) <br>    { <br>    delete [] pszT; <br>    return E_OUTOFMEMORY; <br>    } <br>  GetWindowText(m_pgame-&gt;m_hwndDlg, pszT, cch+1); <br>  MultiByteToWideChar(CP_ACP, 0, pszT, -1, *pRet, cch+1); <br>  delete [] pszT; <br>  return S_OK; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CGameOA::put_Caption <br>( <br>  BSTR bstr <br>) <br>{ <br>  WCHAR *pwsz = bstr ? bstr : L""; <br>  MAKE_ANSIPTR_FROMWIDE(pszT, pwsz); <br>  SetWindowText(m_pgame-&gt;m_hwndDlg, pszT); <br>  return S_OK; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CGameOA::get_StatusText <br>( <br>  BSTR* pRet <br>) <br>{ <br>  if (!pRet) <br>    return E_INVALIDARG; <br>  UINT cch = GetWindowTextLength(m_pgame-&gt;m_hwndStat); <br>  char *pszT = new char[cch+1]; <br>  if (!pszT) <br>    return E_OUTOFMEMORY; <br>  *pRet = SysAllocStringLen(NULL, cch); <br>  if (!*pRet) <br>    { <br>    delete [] pszT; <br>    return E_OUTOFMEMORY; <br>    } <br>  GetWindowText(m_pgame-&gt;m_hwndStat, pszT, cch+1); <br>  MultiByteToWideChar(CP_ACP, 0, pszT, -1, *pRet, cch+1); <br>  delete [] pszT; <br>  return S_OK; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CGameOA::put_StatusText <br>( <br>  BSTR bstr <br>) <br>{ <br>  WCHAR *pwsz = bstr ? bstr : L""; <br>  MAKE_ANSIPTR_FROMWIDE(pszT, pwsz); <br>  m_pgame-&gt;m_pscore-&gt;SetStatusText(pszT); <br>  return S_OK; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CGameOA::get_Application <br>( <br>  ISpruuidsApp** lppaReturn <br>) <br>{ <br>  return g_papp-&gt;QueryInterface(IID_ISpruuidsApp, (void **)lppaReturn); <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CGameOA::get_Parent <br>( <br>  ISpruuidsApp** lppaReturn <br>) <br>{ <br>  return g_papp-&gt;QueryInterface(IID_ISpruuidsApp, (void **)lppaReturn); <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CGameOA::StartGame <br>( <br>  void  <br>) <br>{ <br>  m_pgame-&gt;NewGame(); <br>  return S_OK; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CGameOA::EndGame <br>( <br>  void  <br>) <br>{ <br>  m_pgame-&gt;GameOver(); <br>  return S_OK; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CGameOA::RemoveAllSprites <br>( <br>  void  <br>) <br>{ <br>  m_pgame-&gt;m_pdisp-&gt;DestroyAll(); <br>  return S_OK; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CGameOA::NextLevel <br>( <br>  void  <br>) <br>{ <br>  m_pgame-&gt;NewLevel(); <br>  return S_OK; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CGameOA::Refresh <br>( <br>  void  <br>) <br>{ <br>  m_pgame-&gt;m_pdisp-&gt;Refresh(); <br>  return S_OK; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CGameOA::AddScore <br>( <br>  int val <br>) <br>{ <br>  m_pgame-&gt;m_pscore-&gt;Add(val); <br>  return S_OK; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>// <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CGameOA::StdBorderBounce <br>( <br>  ISprite *psprite, <br>  int      brd <br>) <br>{ <br>  CSprite *pspr = SPRITEOFI(psprite); <br> <br>  if ((brd &amp; SPR_brdTOP) &amp;&amp; pspr-&gt;m_vyFull &lt; 0) <br>    { <br>    pspr-&gt;m_vyFull = -pspr-&gt;m_vyFull; <br>    pspr-&gt;IgnoreMove(); <br>    } <br>  if ((brd &amp; SPR_brdLEFT) &amp;&amp; pspr-&gt;m_vxFull &lt; 0) <br>    { <br>    pspr-&gt;m_vxFull = -pspr-&gt;m_vxFull; <br>    pspr-&gt;IgnoreMove(); <br>    } <br>  if ((brd &amp; SPR_brdBOTTOM) &amp;&amp; pspr-&gt;m_vyFull &gt; 0) <br>    { <br>    pspr-&gt;m_vyFull = -pspr-&gt;m_vyFull; <br>    pspr-&gt;IgnoreMove(); <br>    } <br>  if ((brd &amp; SPR_brdRIGHT) &amp;&amp; pspr-&gt;m_vxFull &gt; 0) <br>    { <br>    pspr-&gt;m_vxFull = -pspr-&gt;m_vxFull; <br>    pspr-&gt;IgnoreMove(); <br>    } <br>  return S_OK; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>// <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CGameOA::StdBorderWrap <br>( <br>  ISprite *psprite, <br>  int      brd <br>) <br>{ <br>  CSprite *pspr = SPRITEOFI(psprite); <br> <br>  if ((brd &amp; SPR_brdTOP) &amp;&amp; pspr-&gt;m_vyFull &lt; 0) <br>    pspr-&gt;m_y = pspr-&gt;m_pdisp-&gt;m_cy; <br>  if ((brd &amp; SPR_brdLEFT) &amp;&amp; pspr-&gt;m_vxFull &lt; 0) <br>    pspr-&gt;m_x = pspr-&gt;m_pdisp-&gt;m_cx; <br>  if ((brd &amp; SPR_brdBOTTOM) &amp;&amp; pspr-&gt;m_vyFull &gt; 0) <br>    pspr-&gt;m_y = -pspr-&gt;m_pimg-&gt;cy; <br>  if ((brd &amp; SPR_brdRIGHT) &amp;&amp; pspr-&gt;m_vxFull &gt; 0) <br>    pspr-&gt;m_x = -pspr-&gt;m_pimg-&gt;cx; <br>  return S_OK; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>// Generate a random number between 0 and n. <br>//--------------------------------------------------------------------------- <br>int MyRand <br>( <br>  int n <br>) <br>{ <br>  int t, u; <br>  static nLast=0, tLast=0; <br> <br>  if (n &lt;= 1) <br>    return 0; <br> <br>  n &amp;= RAND_MAX; <br>  if (n == nLast) <br>    t = tLast; <br>  else <br>    { <br>    nLast = n; <br>    for (t=2; t&lt;n; t&lt;&lt;=1) <br>      ; <br>    t--; <br>    tLast = t; <br>    } <br> <br>  do <br>    { <br>    u = t &amp; rand(); <br>    } while (u &gt;= n); <br>  return u; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>// Init to random position which doesn't cause a collision event. <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CGameOA::StdInitRand <br>( <br>  ISprite *psprite, <br>  VARIANT  varUser <br>) <br>{ <br>  CSprite *pspr = SPRITEOFI(psprite); <br>  CSprite *psprT; <br>  LONG     x, y, dx, dy; <br>  int      cx, cy; <br>  int      lUser = (varUser.vt == VT_I4) ? varUser.lVal : 0; <br>  LONG     dist = 8128; <br> <br>  cx = pspr-&gt;m_pimg-&gt;cx; <br>  cy = pspr-&gt;m_pimg-&gt;cy; <br>  do <br>    { <br>Loop: <br>    x = MyRand(pspr-&gt;m_pdisp-&gt;m_cx - cx); <br>    y = MyRand(pspr-&gt;m_pdisp-&gt;m_cy - cy); <br>    for (psprT=pspr-&gt;m_pdisp-&gt;m_psprFirst; psprT; psprT=psprT-&gt;m_psprNext) <br>      { <br>      if (!(psprT-&gt;m_psc-&gt;m_maskCollide &amp; pspr-&gt;m_psc-&gt;m_maskCollide) &amp;&amp; // if potential collision doesn't matter <br>          x &lt;= psprT-&gt;m_x+psprT-&gt;m_pimg-&gt;cx &amp;&amp; x+cx &gt;= psprT-&gt;m_x &amp;&amp;  // and we collide <br>          y &lt;= psprT-&gt;m_y+psprT-&gt;m_pimg-&gt;cy &amp;&amp; y+cy &gt;= psprT-&gt;m_y) <br>goto Loop;                              // then try another location <br>      } <br>    dx = (x - (pspr-&gt;m_pdisp-&gt;m_cx&gt;&gt;1)); <br>    dy = (y - (pspr-&gt;m_pdisp-&gt;m_cy&gt;&gt;1)); <br>    } while (dx*dx + dy*dy &lt; dist); <br>  pspr-&gt;m_x = (int)x; <br>  pspr-&gt;m_y = (int)y; <br>  return S_OK; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>// Init to random position along edge of disp. <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CGameOA::StdInitEdge <br>( <br>  ISprite *psprite, <br>  VARIANT  varUser <br>) <br>{ <br>  CSprite *pspr = SPRITEOFI(psprite); <br> <br>  if (rand() &amp; 1) <br>    { <br>    pspr-&gt;m_x = MyRand(pspr-&gt;m_pdisp-&gt;m_cx - pspr-&gt;m_pimg-&gt;cx); <br>    if (rand() &amp; 1) <br>      pspr-&gt;m_y = pspr-&gt;m_pdisp-&gt;m_cy - pspr-&gt;m_pimg-&gt;cy; <br>    } <br>  else <br>    { <br>    pspr-&gt;m_y = MyRand(pspr-&gt;m_pdisp-&gt;m_cy - pspr-&gt;m_pimg-&gt;cy); <br>    if (rand() &amp; 1) <br>      pspr-&gt;m_x = pspr-&gt;m_pdisp-&gt;m_cx - pspr-&gt;m_pimg-&gt;cx; <br>    } <br>  return S_OK; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CGameOA::get_Paused <br>( <br>  VARIANT_BOOL* pRet <br>) <br>{ <br>  *pRet = m_pgame-&gt;m_fPaused; <br>  return S_OK; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CGameOA::put_Paused <br>( <br>  VARIANT_BOOL val <br>) <br>{ <br>  m_pgame-&gt;Pause(!!val); <br>  return S_OK; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CGameOA::get_Width <br>( <br>  int* pRet <br>) <br>{ <br>  *pRet = m_pgame-&gt;m_pdisp-&gt;m_cx; <br>  return S_OK; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CGameOA::put_Width <br>( <br>  int val <br>) <br>{ <br>  if (val &lt; 20 || val &gt; 1024) <br>    return E_FAIL; <br>  m_pgame-&gt;m_pscore-&gt;Size(val, m_pgame-&gt;m_pdisp-&gt;m_cy); <br>  return S_OK; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CGameOA::get_Height <br>( <br>  int* pRet <br>) <br>{ <br>  *pRet = m_pgame-&gt;m_pdisp-&gt;m_cy; <br>  return S_OK; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CGameOA::put_Height <br>( <br>  int val <br>) <br>{ <br>  if (val &lt; 20 || val &gt; 1024) <br>    return E_FAIL; <br>  m_pgame-&gt;m_pscore-&gt;Size(m_pgame-&gt;m_pdisp-&gt;m_cx, val); <br>  return S_OK; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CGameOA::get_BackColor <br>( <br>  long* pRet <br>) <br>{ <br>  *pRet = m_pgame-&gt;m_pdisp-&gt;m_colorBack; <br>  return S_OK; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CGameOA::put_BackColor <br>( <br>  long val <br>) <br>{ <br>  if (val &amp; 0xff000000) <br>    return E_FAIL; <br>  m_pgame-&gt;m_pdisp-&gt;SetBackColor(val); <br>  return S_OK; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CGameOA::get_Score <br>( <br>  int* pRet <br>) <br>{ <br>  *pRet = m_pgame-&gt;m_pscore-&gt;GetScore(); <br>  return S_OK; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CGameOA::put_Score <br>( <br>  int val <br>) <br>{ <br>  m_pgame-&gt;m_pscore-&gt;SetScore(val); <br>  return S_OK; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CGameOA::get_Level <br>( <br>  int* pRet <br>) <br>{ <br>  *pRet = m_pgame-&gt;m_pscore-&gt;GetLevel(); <br>  return S_OK; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CGameOA::put_Level <br>( <br>  int val <br>) <br>{ <br>  m_pgame-&gt;m_pscore-&gt;SetLevel(val); <br>  return S_OK; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CGameOA::get_ShipCount <br>( <br>  int* pRet <br>) <br>{ <br>  *pRet = m_pgame-&gt;m_pscore-&gt;GetCShip(); <br>  return S_OK; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CGameOA::put_ShipCount <br>( <br>  int val <br>) <br>{ <br>  m_pgame-&gt;m_pscore-&gt;SetCShip(val); <br>  return S_OK; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CGameOA::get_ScoreFirst1Up <br>( <br>  int* pRet <br>) <br>{ <br>  *pRet = m_pgame-&gt;m_pscore-&gt;m_scoreFirst1Up; <br>  return S_OK; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CGameOA::put_ScoreFirst1Up <br>( <br>  int val <br>) <br>{ <br>  if (val &lt; 0) <br>    return E_FAIL; <br>  m_pgame-&gt;m_pscore-&gt;m_scoreFirst1Up = val; <br>  if (m_pgame-&gt;m_pscore-&gt;m_scoreSecond1Up &lt; val) <br>    m_pgame-&gt;m_pscore-&gt;m_scoreSecond1Up = val; <br>  if (m_pgame-&gt;m_pscore-&gt;GetScore() &lt; m_pgame-&gt;m_pscore-&gt;m_scoreFirst1Up) <br>    m_pgame-&gt;m_pscore-&gt;m_scoreNext1Up = val; <br>  return S_OK; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CGameOA::get_ScoreSecond1Up <br>( <br>  int* pRet <br>) <br>{ <br>  *pRet = m_pgame-&gt;m_pscore-&gt;m_scoreSecond1Up; <br>  return S_OK; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CGameOA::put_ScoreSecond1Up <br>( <br>  int val <br>) <br>{ <br>  if (val &lt; 0) <br>    return E_FAIL; <br>  m_pgame-&gt;m_pscore-&gt;m_scoreSecond1Up = val; <br>  if (val &lt; m_pgame-&gt;m_pscore-&gt;m_scoreFirst1Up) <br>    m_pgame-&gt;m_pscore-&gt;m_scoreFirst1Up = val; <br>  if (m_pgame-&gt;m_pscore-&gt;GetScore() &gt; m_pgame-&gt;m_pscore-&gt;m_scoreFirst1Up  &amp;&amp; <br>      m_pgame-&gt;m_pscore-&gt;GetScore() &lt; m_pgame-&gt;m_pscore-&gt;m_scoreSecond1Up) <br>    m_pgame-&gt;m_pscore-&gt;m_scoreNext1Up = val; <br>  return S_OK; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CGameOA::get_DScoreNext1Up <br>( <br>  int* pRet <br>) <br>{ <br>  *pRet = m_pgame-&gt;m_pscore-&gt;m_dscoreNext1Up; <br>  return S_OK; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CGameOA::put_DScoreNext1Up <br>( <br>  int val <br>) <br>{ <br>  if (val &lt; 0) <br>    return E_FAIL; <br>  m_pgame-&gt;m_pscore-&gt;m_dscoreNext1Up = val; <br>  if (m_pgame-&gt;m_pscore-&gt;GetScore() &gt; m_pgame-&gt;m_pscore-&gt;m_scoreFirst1Up &amp;&amp; m_pgame-&gt;m_pscore-&gt;GetScore() &gt; 0) <br>    { <br>    m_pgame-&gt;m_pscore-&gt;m_scoreNext1Up = m_pgame-&gt;m_pscore-&gt;m_scoreFirst1Up; <br>    while (m_pgame-&gt;m_pscore-&gt;m_scoreNext1Up &lt; m_pgame-&gt;m_pscore-&gt;GetScore()) <br>      m_pgame-&gt;m_pscore-&gt;m_scoreNext1Up += m_pgame-&gt;m_pscore-&gt;m_dscoreNext1Up; <br>    } <br>  return S_OK; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CGameOA::get_ShipsStart <br>( <br>  int* pRet <br>) <br>{ <br>  *pRet = m_pgame-&gt;m_pscore-&gt;m_cshipStart; <br>  return S_OK; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CGameOA::put_ShipsStart <br>( <br>  int val <br>) <br>{ <br>  if (val &lt; 0) <br>    return E_FAIL; <br>  m_pgame-&gt;m_pscore-&gt;m_cshipStart = val; <br>  return S_OK; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CGameOA::get_Tag <br>( <br>  VARIANT* pRet <br>) <br>{ <br>  if (!pRet) <br>    return E_INVALIDARG; <br>  VariantInit(pRet); <br>  return VariantCopy(pRet, &amp;m_pgame-&gt;m_varTag); <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CGameOA::put_Tag <br>( <br>  VARIANT val <br>) <br>{ <br>  return VariantCopy(&amp;m_pgame-&gt;m_varTag, &amp;val); <br>} <br> <br> <br> <br>//*************************************************************************** <br>// IDispatch Interface <br>//*************************************************************************** <br> <br>//--------------------------------------------------------------------------- <br>// Method needed by COleAuto, so it can implement IDispatch for us. <br>//--------------------------------------------------------------------------- <br>HRESULT CGameOA::GetTypeLibInfo <br>( <br>  HINSTANCE    *phinstOut, <br>  const GUID  **pplibidOut,  <br>  SHORT        *pwMajLib,  <br>  SHORT        *pwMinLib, <br>  const CLSID **ppclsidOut,  <br>  const IID   **ppiidOut,  <br>  ITypeLib   ***ppptlOut <br>) <br>{ <br>  *phinstOut  = g_hinst; <br>  *pplibidOut = &amp;LIBID_SPRUUIDS; <br>  *pwMajLib   = 1; <br>  *pwMinLib   = 0; <br>  *ppclsidOut = &amp;CLSID_Game; <br>  *ppiidOut   = &amp;IID_IGame; <br>  *ppptlOut   = &amp;g_ptlMain; <br>  return S_OK; <br>} <br> <br> <br> <br>//*************************************************************************** <br>// IProvideClassInfo Interfaces <br>//*************************************************************************** <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CGameOA::GetClassInfo <br>( <br>  ITypeInfo** pptinfoOut <br>) <br>{ <br>  HRESULT hr = ((COleAuto *)this)-&gt;CheckTypeInfo(0, 0x0409); <br>  if (hr) <br>    return hr; <br>  *pptinfoOut = g_ptinfoClsGameOA; <br>  (*pptinfoOut)-&gt;AddRef(); <br>  return S_OK; <br>} <br> <br> <br> <br> <br>//*************************************************************************** <br>// IConnectionPointContainer Interface <br>//*************************************************************************** <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CGameOA::EnumConnectionPoints <br>( <br>  LPENUMCONNECTIONPOINTS* ppEnum <br>) <br>{ <br>  return E_NOTIMPL;   // UNDONE: Implement this method <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CGameOA::FindConnectionPoint <br>( <br>  REFIID             iid, <br>  LPCONNECTIONPOINT* ppCpOut <br>) <br>{ <br>  if (!ppCpOut) <br>    return E_INVALIDARG; <br> <br>  if (iid == DIID_IGameEvents || iid == IID_IDispatch) <br>    { <br>    *ppCpOut = &amp;m_cp; <br>    (*ppCpOut)-&gt;AddRef(); <br>    return S_OK; <br>    } <br>     <br>  return E_NOINTERFACE; <br>} <br> <br> <br>//*************************************************************************** <br>// Embedded IConnectionPoint Class <br>//*************************************************************************** <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>CGameOA::XCP::XCP <br>( <br>  void <br>) <br>{ <br>  m_cref = 1; <br>  for (int i=0; i&lt;GAME_cADVISE; i++) <br>    m_rgpdisp[i] = NULL; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>void CGameOA::XCP::Close </code></pre>
<p>
</p>
<pre><code>( <br>  void <br>) <br>{ <br>  for (int i=0; i&lt;SC_cADVISE; i++) <br>    if (m_rgpdisp[i]) <br>      { <br>      m_rgpdisp[i]-&gt;Release(); <br>      m_rgpdisp[i] = NULL; <br>      } <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CGameOA::XCP::QueryInterface <br>( <br>  REFIID  iid, <br>  LPVOID* ppvObjOut <br>) <br>{ <br>  if (!ppvObjOut) <br>    return E_INVALIDARG; <br> <br>  *ppvObjOut = NULL; <br> <br>  if (iid == IID_IUnknown) <br>    *ppvObjOut = this-&gt;GetUnknown(); <br>  else if (iid == IID_IConnectionPoint) <br>    *ppvObjOut = (IConnectionPoint *)this; <br> <br>  if (*ppvObjOut) <br>    { <br>    this-&gt;AddRef(); <br>    return S_OK; <br>    } <br> <br>  return E_NOINTERFACE; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP_(ULONG) CGameOA::XCP::AddRef <br>( <br>  void  <br>) <br>{ <br>  return ++m_cref; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP_(ULONG) CGameOA::XCP::Release <br>( <br>  void  <br>) <br>{ <br>  CGame *pgame = this-&gt;PGAMEOA()-&gt;m_pgame; <br>  ASSERT(m_cref, "bad m_cref"); <br>  m_cref--; <br>  if (!m_cref &amp;&amp; !pgame-&gt;m_cref) <br>    { <br>    delete pgame; <br>    return 0; <br>    } <br>  return m_cref; <br>} <br> <br> <br>//*************************************************************************** <br>// IConnectionPoint Interface <br>//*************************************************************************** <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CGameOA::XCP::GetConnectionInterface <br>( <br>  IID* piid <br>) <br>{ <br>  if (!piid) <br>    return E_INVALIDARG; <br> <br>  memcpy(piid, &amp;DIID_ISpriteClassEvents, sizeof(IID)); <br>  return S_OK; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CGameOA::XCP::GetConnectionPointContainer <br>( <br>  IConnectionPointContainer** ppCPC <br>) <br>{ <br>  if (!ppCPC) <br>    return E_INVALIDARG; <br> <br>  *ppCPC = this-&gt;PGAMEOA(); <br>  (*ppCPC)-&gt;AddRef(); <br>  return S_OK; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CGameOA::XCP::Advise <br>( <br>  IUnknown* punkSink, <br>  DWORD*    pdwCookie <br>) <br>{ <br>  IDispatch  *psce = NULL; <br>  IDispatch **ppdisp; <br>  HRESULT     hr; <br> <br>  if (!punkSink || !pdwCookie) <br>    return E_INVALIDARG; <br>  *pdwCookie = 0; <br> <br>  // Look for empty slot <br>  for (ppdisp=m_rgpdisp; *ppdisp &amp;&amp; ppdisp&lt;&amp;m_rgpdisp[GAME_cADVISE]; ppdisp++) <br>    ; <br>  // Did we find one? <br>  if (ppdisp &gt;= &amp;m_rgpdisp[GAME_cADVISE]) <br>    return E_FAIL;          // UNDONE: Error? <br> <br>  // Now see if sink supports correct interface <br>  hr = punkSink-&gt;QueryInterface(DIID_ISpriteClassEvents, (void **)&amp;psce); <br>  if (hr == E_NOINTERFACE) <br>    { <br>    hr = punkSink-&gt;QueryInterface(IID_IDispatch, (void **)&amp;psce); <br>    if (hr) <br>      return hr; <br>    } <br>  ASSERT(psce, "QI but no ptr"); <br> <br>  // Finish advise by stashing punkSink QI'd to our interface <br>  *ppdisp = psce;       // AddRef'd from QI <br>  *pdwCookie = (ppdisp - m_rgpdisp) + 1; <br> <br>  return S_OK; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CGameOA::XCP::Unadvise <br>( <br>  DWORD dwCookie <br>) <br>{ <br>  if (!dwCookie || dwCookie &gt; GAME_cADVISE) <br>    return E_INVALIDARG; <br> <br>  m_rgpdisp[dwCookie-1]-&gt;Release(); <br>  m_rgpdisp[dwCookie-1] = NULL; <br>  return S_OK; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CGameOA::XCP::EnumConnections <br>( <br>  LPENUMCONNECTIONS* ppEnum <br>) <br>{ <br>  return E_NOTIMPL;   // UNDONE: Implement this method <br>} <br> <br> <br>//--- EOF ------------------------------------------------------------------- </code></pre>
<p>&nbsp;</p></body>
</HTML>
