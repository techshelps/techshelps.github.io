<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>OLEAUTO.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context4590"></a>OLEAUTO.CPP</h2>
<pre><code>//--------------------------------------------------------------------------- <br>// OleAuto.cpp <br>//--------------------------------------------------------------------------- <br>// Simple class for doing dual OLE Automation interfaces <br>//--------------------------------------------------------------------------- <br>// (C) Copyright 1992-1997 by Microsoft Corporation.  All rights reserved. <br>// <br>// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF  <br>// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO  <br>// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A  <br>// PARTICULAR PURPOSE. <br>//--------------------------------------------------------------------------- <br> <br>#include "Main.h" <br>#pragma hdrstop <br> <br>#define NUM_RESERVED_EXTENDER_DISPIDS 500 <br>#define EXTENDER_DISPID_BASE ((ULONG)(0x80010000)) <br>#define IS_EXTENDER_DISPID(x) ( ( (ULONG)(x) &amp; 0xFFFF0000 ) == EXTENDER_DISPID_BASE ) <br> <br>SZTHISFILE <br> <br>//--------------------------------------------------------------------------- <br>// A little utility which simplifies firing dispatch events. <br>//--------------------------------------------------------------------------- <br>HRESULT InvokeEvent <br>( <br>  IDispatch  *pdisp,    // IDispatch of Sink <br>  DISPID      dispid,   // DISPID of event <br>  VARIANTARG *pvararg,  // Args to event <br>  UINT        carg      // # args <br>) <br>{ <br>  DISPPARAMS dp; <br>  EXCEPINFO  ei; <br>  UINT       uArgErr = 0; <br> <br>  dp.rgvarg            = pvararg; <br>  dp.rgdispidNamedArgs = NULL; <br>  dp.cArgs             = carg; <br>  dp.cNamedArgs        = 0; <br>  return pdisp-&gt;Invoke(dispid, IID_NULL, 0, DISPATCH_METHOD, &amp;dp, NULL, &amp;ei, &amp;uArgErr); <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>// This routine will load a TypeLib and (optionally) find the TypeInfo inside <br>// which matches the given clsid.  The TypeLib and TypeInfo pointers are <br>// in/out so you can simply: <br>//      hr = LoadTypeInfo(..., &amp;g_pMyTypeLib, &amp;m_pMyObjectsTypeInfo); <br>// and it will fill in g_pMyTypeLib and m_pMyObjectsTypeInfo, if necessary. <br>//--------------------------------------------------------------------------- <br>HRESULT LoadTypeInfo <br>( <br>  HINSTANCE   hinst,             // hinst of where to load TypeLib from, if not found <br>  UINT        itinfo,            // index of TypeInfo requested, only 0 supported <br>  USHORT      dwMaj,             // Maj version # of TypeLib <br>  USHORT      dwMin,             // Min version # of TypeLib <br>  LCID        lcid,              // Locale of TypeLib to load <br>  REFGUID     libid,             // LIBID of TypeLib  to find <br>  REFCLSID    clsid,             // CLSID of TypeInfo to find <br>  REFIID      iid,               // IID   of TypeInfo to find <br>  BOOL        fDispOnly,         // TRUE=ensure *ptinfoIntInOut is a TKIND_DISPATCH, not vtbl <br>  ITypeLib  **pptlibInOut,       // Ptr to cache of pTypeLib, typically &amp;g_ptlib <br>  ITypeInfo **pptinfoClassInOut, // Ptr to cache of pTypeInfo, typically &amp;s_ptinfoCls <br>  ITypeInfo **pptinfoIntInOut    // Ptr to cache of pTypeInfo, typically &amp;s_ptinfoInt <br>) <br>{ <br>  HRESULT    hr        = S_OK; <br>  ITypeInfo *ptinfoT   = NULL; <br>  TYPEATTR  *ptypeattr = NULL; <br> <br>  // Arg checking <br>  if (itinfo != 0) <br>    return DISP_E_BADINDEX; <br> <br>  if (!pptlibInOut) <br>    return E_POINTER; <br> <br>  // Check to see if we have a TypeLib, load it if not. <br>  if (!*pptlibInOut) <br>    { <br>    hr = LoadRegTypeLib(libid, dwMaj, dwMin, lcid, pptlibInOut); <br>    if (hr) <br>      { <br>      ASSERT(hinst, "hinst==NULL means in-memory TL; shouldn't have to load from resource"); <br> <br>      // If, for some reason, we failed to load the type library this way, <br>      // we're going to try and load the type library directly out of our <br>      // resources.  This has the advantage of going and re-setting all the <br>      // registry information again for us. <br>      DWORD dwPathLen; <br>      char  szDllPath[MAX_PATH]; <br> <br>      dwPathLen = GetModuleFileName(hinst, szDllPath, MAX_PATH); <br>      if (!dwPathLen) <br>        return E_FAIL; <br> <br>      MAKE_WIDEPTR_FROMANSI(pwsz, szDllPath); <br>      CHECK(LoadTypeLib(pwsz, pptlibInOut)); <br>      } <br>    } <br>  ASSERT(*pptlibInOut, "Don't have a pTypeLib"); <br> <br>  // If the user wants a coclass TypeInfo... <br>  if (pptinfoClassInOut) <br>    { <br>    // ...Check to see if we already have it, and find it in the TypeLib, if not. <br>    if (!*pptinfoClassInOut) <br>      { <br>      // Get coclass TypeInfo <br>      CHECK((*pptlibInOut)-&gt;GetTypeInfoOfGuid(clsid, pptinfoClassInOut)); <br>      } <br>    } <br> <br>  // If the user wants an interface TypeInfo... <br>  if (pptinfoIntInOut) <br>    { <br>    // ...Check to see if we already have it, and find it in the TypeLib, if not. <br>    if (!*pptinfoIntInOut) <br>      { <br>      // Get interface TypeInfo <br>      CHECK((*pptlibInOut)-&gt;GetTypeInfoOfGuid(iid, &amp;ptinfoT)); <br>      CHECK(ptinfoT-&gt;GetTypeAttr(&amp;ptypeattr)); <br> <br>      // If we want a TKIND_DISPATCH, but we have a TKIND_INTERFACE, then switch if it's dual <br>      if (fDispOnly &amp;&amp; ptypeattr-&gt;typekind == TKIND_INTERFACE) <br>        { <br>        // We're on a TKIND_INTERFACE but want a dispatch.  If this is not a dual interface, <br>        // we're out of luck, so stuff a NULL, and return S_FALSE. <br>        if (!(ptypeattr-&gt;wTypeFlags &amp; TYPEFLAG_FDUAL)) <br>          { <br>          *pptinfoIntInOut = NULL; <br>          hr = S_FALSE; <br>          } <br> <br>        // This is a dual interface, so get the corresponding Disp interface; <br>        // 0xffffffff is a magic number which does this for us. <br>        HREFTYPE hrefType; <br>        CHECK(ptinfoT-&gt;GetRefTypeOfImplType(0xffffffff, &amp;hrefType)); <br>        CHECK(ptinfoT-&gt;GetRefTypeInfo(hrefType, pptinfoIntInOut)); <br>        } <br>      else <br>        { <br>        *pptinfoIntInOut = ptinfoT; <br>        (*pptinfoIntInOut)-&gt;AddRef(); <br>        } <br>      } <br>    } <br> <br>CleanUp: <br>  // Release all frame variables <br>  if (ptypeattr) <br>    ptinfoT-&gt;ReleaseTypeAttr(ptypeattr); <br>  if (ptinfoT) <br>    ptinfoT-&gt;Release(); <br> <br>  return hr; <br>} <br> <br> <br> <br>//*************************************************************************** <br>// IDispatch Interface <br>//*************************************************************************** <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP COleAuto::GetTypeInfoCount <br>( <br>  UINT* pctinfo <br>) <br>{ <br>  // Validate args <br>  if (!pctinfo) <br>    return E_INVALIDARG; <br> <br>  // Return requested info <br>  *pctinfo = 1; <br>  return S_OK; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP COleAuto::GetTypeInfo <br>( <br>  UINT        itinfo, <br>  LCID        lcid, <br>  ITypeInfo** pptinfoOut <br>) <br>{ <br>  HRESULT hr = S_OK; <br> <br>  // Validate args <br>  if (!pptinfoOut) <br>    return E_INVALIDARG; <br>  *pptinfoOut = NULL; <br> <br>  // Make sure we have the TypeInfo <br>  CHECK(this-&gt;CheckTypeInfo(itinfo, lcid)); <br> <br>  // Return requested info <br>  *pptinfoOut = *this-&gt;GetTinfoIntAddr(); <br>  (*pptinfoOut)-&gt;AddRef();    // For *pptiOut <br> <br>CleanUp: <br>  return hr; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>HRESULT COleAuto::CheckTypeInfo <br>( <br>  UINT itinfo, <br>  LCID lcid <br>) <br>{ <br>  HRESULT      hr; <br>  HINSTANCE    hinst; <br>  SHORT        wMaj, wMin; <br>  const GUID  *plibid; <br>  const CLSID *pclsid; <br>  const IID   *piid; <br>  ITypeLib   **pptl; <br>  ITypeInfo  **pptinfoCls; <br>  ITypeInfo  **pptinfoInt; <br> <br>  pptinfoCls = this-&gt;GetTinfoClsAddr(); <br>  pptinfoInt = this-&gt;GetTinfoIntAddr(); <br>  if (*pptinfoCls &amp;&amp; *pptinfoInt) <br>    return S_OK; <br> <br>  hr = GetTypeLibInfo(&amp;hinst, &amp;plibid, &amp;wMaj, &amp;wMin, &amp;pclsid, &amp;piid, &amp;pptl); <br>  if (hr) <br>    return hr; <br> <br>  return LoadTypeInfo(hinst, itinfo, wMaj, wMin, lcid, *plibid, *pclsid, *piid, FALSE, <br>                      pptl, pptinfoCls, pptinfoInt); <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP COleAuto::GetIDsOfNames <br>( <br>  REFIID    iid, <br>  OLECHAR** rgszNames, <br>  UINT      cNames, <br>  LCID      lcid, <br>  DISPID*   prgdispid <br>) <br>{ <br>  HRESULT hr; <br> <br>  // Validate Args <br>  if (iid != IID_NULL) <br>      return E_INVALIDARG; <br> <br>  // Make sure we have the TypeInfo <br>  CHECK(this-&gt;CheckTypeInfo(0, lcid)); <br> <br>  // Use the standard provided routines to do all the work for us. <br>  hr = (*this-&gt;GetTinfoIntAddr())-&gt;GetIDsOfNames(rgszNames, cNames, prgdispid); <br> <br>  // Try the base object iff there is a base object and the previous call failed <br>  if (FAILED(hr) &amp;&amp; m_pdispBaseObject) <br>    { <br>    hr = m_pdispBaseObject-&gt;GetIDsOfNames(iid, rgszNames, cNames, lcid, prgdispid); <br>    if (SUCCEEDED(hr)) <br>      { <br>      // Adjust extender dispid. <br>      if (IS_EXTENDER_DISPID(prgdispid[0])) <br>        prgdispid[0] += NUM_RESERVED_EXTENDER_DISPIDS; <br>      } <br>    } <br> <br>CleanUp: <br>  return hr; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP COleAuto::Invoke <br>( <br>  DISPID      dispidMember, <br>  REFIID      iid, <br>  LCID        lcid, <br>  WORD        wFlags, <br>  DISPPARAMS* pdispparams, <br>  VARIANT*    pvarResult, <br>  EXCEPINFO*  pexcepinfo, <br>  UINT*       puArgErr <br>) <br>{ <br>  HRESULT hr; <br> <br>  // Validate args, clear out params <br>  if (!pdispparams) <br>    return E_INVALIDARG; <br>  if (pvarResult) <br>    VariantInit(pvarResult); <br>  SetErrorInfo(0L, NULL); <br>  if (puArgErr) <br>    *puArgErr = 0; <br>  if (iid != IID_NULL) <br>    return E_INVALIDARG; <br> <br>  // Make sure we have the TypeInfo <br>  CHECK(this-&gt;CheckTypeInfo(0, lcid)); <br> <br>  // Use the standard provided routines to do all the work for us. <br>  hr = (*this-&gt;GetTinfoIntAddr())-&gt;Invoke(this-&gt;GetPrimary(), dispidMember, wFlags, <br>                                          pdispparams, pvarResult, pexcepinfo, puArgErr); <br>  // Try the base object iff there is a base object and the previous invoke failed <br>  if (FAILED(hr) &amp;&amp; m_pdispBaseObject) <br>    { <br>    if (IS_EXTENDER_DISPID(dispidMember)) <br>      dispidMember -= NUM_RESERVED_EXTENDER_DISPIDS; <br> <br>    hr = m_pdispBaseObject-&gt;Invoke(dispidMember, iid, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr); <br>    } <br> <br>CleanUp: <br>  return hr; <br>} <br> <br> <br>//*************************************************************************** <br>// IProvideMultipleClassInfo Interface <br>//*************************************************************************** <br> <br>//--------------------------------------------------------------------------- <br>// <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP COleAuto::GetMultiTypeInfoCount <br>( <br>  ULONG *pc <br>) <br>  { <br>  HRESULT hr; <br>  ULONG count; <br>  IProvideClassInfo         *pclsinfo   = NULL; <br>  IProvideMultipleClassInfo *pclsinfoex = NULL; <br> <br>  // This should not be possible! <br>  ASSERT(m_pdispBaseObject != NULL, ""); <br> <br>  hr = m_pdispBaseObject-&gt;QueryInterface(IID_IProvideMultipleClassInfo, (void**)&amp;pclsinfoex); <br>  if (SUCCEEDED(hr)) <br>    { <br>    hr = pclsinfoex-&gt;GetMultiTypeInfoCount(&amp;count); <br>    if (SUCCEEDED(hr)) <br>      *pc = count + 1; <br>    } <br>  else <br>    { <br>    hr = m_pdispBaseObject-&gt;QueryInterface(IID_IProvideClassInfo, (void**)&amp;pclsinfo); <br>    if (FAILED(hr)) <br>      goto Exit; <br>    *pc = 2; <br>    } <br> <br>Exit: <br>  // Release the temp refs <br>  if (pclsinfoex) <br>    pclsinfoex-&gt;Release(); <br>  if (pclsinfo) <br>    pclsinfo-&gt;Release(); <br>  return hr; <br>  } <br> <br> <br>//--------------------------------------------------------------------------- <br>// <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP COleAuto::GetInfoOfIndex <br>( <br>  ULONG       itinfo, <br>  DWORD       dwFlags, <br>  ITypeInfo** pptinfoCoClass, <br>  DWORD*      pdwTIFlags, <br>  ULONG*      pcdispidReserved, <br>  IID*        piidPrimary, <br>  IID*        piidSource <br>) <br>  { <br>  HRESULT                    hr         = S_OK; <br>  IProvideClassInfo         *pclsinfo   = NULL; <br>  IProvideMultipleClassInfo *pclsinfoex = NULL; <br> <br>  // This should not be possible! <br>  ASSERT(m_pdispBaseObject != NULL, ""); <br> <br>  if (itinfo == 0) <br>    { <br>    // Return info on ourselves <br>    if (dwFlags &amp; MULTICLASSINFO_GETTYPEINFO) <br>      { <br>      // Make sure we have the TypeInfo <br>      hr = this-&gt;CheckTypeInfo(0, 0x0409); <br>      if (hr) <br>        goto Exit; <br> <br>      // Return requested info <br>      *pptinfoCoClass = *this-&gt;GetTinfoClsAddr(); <br>      (*pptinfoCoClass)-&gt;AddRef();    // For *pptiOut <br>      if (pdwTIFlags) <br>        *pdwTIFlags = 0; <br>      } <br>    if (dwFlags &amp; MULTICLASSINFO_GETNUMRESERVEDDISPIDS) <br>      *pcdispidReserved = NUM_RESERVED_EXTENDER_DISPIDS; <br>    if (dwFlags &amp; MULTICLASSINFO_GETIIDPRIMARY) <br>      // REVIEW: Not implemented <br>      *piidPrimary = IID_NULL; <br>    if (dwFlags &amp; MULTICLASSINFO_GETIIDSOURCE) <br>      // REVIEW: Not implemented <br>      *piidSource = IID_NULL; <br>    else <br>      { <br>      // Look for an extender <br>      hr = m_pdispBaseObject-&gt;QueryInterface(IID_IProvideMultipleClassInfo, (void**)&amp;pclsinfoex); <br>      if (SUCCEEDED(hr)) <br>        { <br>        hr = pclsinfoex-&gt;GetInfoOfIndex(itinfo-1, dwFlags, pptinfoCoClass, pdwTIFlags, <br>                                       pcdispidReserved, piidPrimary, piidSource); <br>        if (SUCCEEDED(hr) &amp;&amp; (dwFlags &amp; MULTICLASSINFO_GETTYPEINFO))  <br>          *pdwTIFlags = TIFLAGS_EXTENDDISPATCHONLY; <br>} <br>      else <br>        { <br>        if (itinfo != 1) <br>          hr = TYPE_E_ELEMENTNOTFOUND; <br> <br>        hr = m_pdispBaseObject-&gt;QueryInterface(IID_IProvideClassInfo, (void**)&amp;pclsinfo); <br>        if (FAILED(hr)) <br>          goto Exit; <br>         <br>        // Return info on unextended base object <br>        if (dwFlags &amp; MULTICLASSINFO_GETTYPEINFO) <br>          { <br>          hr = pclsinfo-&gt;GetClassInfo(pptinfoCoClass); <br>          if (FAILED(hr)) <br>            goto Exit; <br>          if (pdwTIFlags) <br>            *pdwTIFlags = TIFLAGS_EXTENDDISPATCHONLY; <br>          } <br>        if (dwFlags &amp; MULTICLASSINFO_GETNUMRESERVEDDISPIDS) <br>          *pcdispidReserved = 0; <br>        if (dwFlags &amp; MULTICLASSINFO_GETIIDPRIMARY) <br>          // REVIEW: Not implemented <br>          *piidPrimary = IID_NULL; <br>        if (dwFlags &amp; MULTICLASSINFO_GETIIDSOURCE) <br>          // REVIEW: Not implemented <br>          *piidSource = IID_NULL; <br>        } <br>      } <br>    } <br> <br>Exit: <br>  // Release the temp refs <br>  if (pclsinfoex) <br>    pclsinfoex-&gt;Release(); <br>  if (pclsinfo) <br>    pclsinfo-&gt;Release(); <br>  return hr; <br>  } <br> <br> <br> <br>//*************************************************************************** <br>// Misc  <br>//*************************************************************************** <br> <br>//--------------------------------------------------------------------------- <br>// <br>//--------------------------------------------------------------------------- <br>HRESULT COleAuto::SetBaseObject <br>( <br>  IDispatch *pdisp <br>) <br>  { <br>  if (!pdisp) <br>    { <br>    if (m_pdispBaseObject) <br>      { <br>      IDispatch* pdispTemp = m_pdispBaseObject; <br> <br>      m_pdispBaseObject = NULL; <br>      pdispTemp-&gt;Release(); <br>      } <br>    } <br>  else <br>    { <br>    // Only allow the base object to be set once <br>    if (m_pdispBaseObject) <br>      return E_UNEXPECTED; <br>    m_pdispBaseObject = pdisp; <br>    m_pdispBaseObject-&gt;AddRef(); <br>    } <br> <br>  return S_OK; <br>  } <br> <br>//--- EOF ------------------------------------------------------------------- </code></pre>
<p>&nbsp;</p></body>
</HTML>
