<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SPROA.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context4598"></a>SPROA.CPP</h2>
<pre><code>//--------------------------------------------------------------------------- <br>// SprOA.cpp <br>//--------------------------------------------------------------------------- <br>// Sprite handler, OLE Automation support <br>//--------------------------------------------------------------------------- <br>// (C) Copyright 1992-1997 by Microsoft Corporation.  All rights reserved. <br>// <br>// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF  <br>// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO  <br>// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A  <br>// PARTICULAR PURPOSE. <br>//--------------------------------------------------------------------------- <br> <br>#include "Main.h" <br>#pragma hdrstop <br>#include "Spr.h" <br>#include "DispIDs.h" <br>#include &lt;math.h&gt; <br> <br> <br>//--------------------------------------------------------------------------- <br>// DEBUG info <br>//--------------------------------------------------------------------------- <br>SZTHISFILE <br> <br> <br>//*************************************************************************** <br>//*************************************************************************** <br>//** <br>//**  SpriteClass Class <br>//** <br>//*************************************************************************** <br>//*************************************************************************** <br> <br> <br>//*************************************************************************** <br>// Fire ISpriteClassEvents Events <br>//*************************************************************************** <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>void CSpriteClass::FireInit <br>( <br>  CSprite *pspr, <br>  VARIANT *pvarUser <br>) <br>{ <br>  IDispatch **ppdisp = m_cp.m_rgpdisp; <br>  VARIANTARG  var[2]; <br> <br>  VariantInit(&amp;var[1]); <br>  var[1].vt = VT_DISPATCH; <br>  var[1].pdispVal = pspr-&gt;GetDispatch(); <br>  pspr-&gt;AddRef(); <br>  VariantInit(&amp;var[0]); <br>  VariantCopy(&amp;var[0], pvarUser); <br> <br>  for (; ppdisp &lt; &amp;m_cp.m_rgpdisp[SC_cADVISE]; ppdisp++) <br>    if (*ppdisp) <br>      InvokeEvent(*ppdisp, DISPID_SpriteClassEvents_Init, var, 2); <br> <br>  pspr-&gt;Release();    // For var[1].pdispVal <br>  VariantClear(&amp;var[0]); <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>void CSpriteClass::FireTick <br>( <br>  CSprite *pspr <br>) <br>{ <br>  IDispatch **ppdisp = m_cp.m_rgpdisp; <br>  VARIANTARG  var[1]; <br> <br>  VariantInit(&amp;var[0]); <br>  var[0].vt = VT_DISPATCH; <br>  var[0].pdispVal = pspr-&gt;GetDispatch(); <br>  pspr-&gt;AddRef(); <br> <br>  for (; ppdisp &lt; &amp;m_cp.m_rgpdisp[SC_cADVISE]; ppdisp++) <br>    if (*ppdisp) <br>      InvokeEvent(*ppdisp, DISPID_SpriteClassEvents_Tick, var, 1); <br> <br>  pspr-&gt;Release();    // For var[0].pdispVal <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>void CSpriteClass::FireBorder <br>( <br>  CSprite *pspr, <br>  BRD      brd <br>) <br>{ <br>  IDispatch **ppdisp = m_cp.m_rgpdisp; <br>  VARIANTARG  var[2]; <br> <br>  VariantInit(&amp;var[1]); <br>  var[1].vt = VT_DISPATCH; <br>  var[1].pdispVal = pspr-&gt;GetDispatch(); <br>  pspr-&gt;AddRef(); <br>  VariantInit(&amp;var[0]); <br>  var[0].vt = VT_I4; <br>  var[0].lVal = brd; <br> <br>  for (; ppdisp &lt; &amp;m_cp.m_rgpdisp[SC_cADVISE]; ppdisp++) <br>    if (*ppdisp) <br>      { <br>      BOOL f; <br>      HRESULT hr = InvokeEvent(*ppdisp, DISPID_SpriteClassEvents_Border, var, 2); <br>      if (hr) <br>        f = TRUE; <br>      } <br> <br>  pspr-&gt;Release();    // For var[1].pdispVal <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>void CSpriteClass::FireTerm <br>( <br>  CSprite *pspr <br>) <br>{ <br>  IDispatch **ppdisp = m_cp.m_rgpdisp; <br>  VARIANTARG  var[1]; <br> <br>  VariantInit(&amp;var[0]); <br>  var[0].vt = VT_DISPATCH; <br>  var[0].pdispVal = pspr-&gt;GetDispatch(); <br>  pspr-&gt;AddRef(); <br> <br>  for (; ppdisp &lt; &amp;m_cp.m_rgpdisp[SC_cADVISE]; ppdisp++) <br>    if (*ppdisp) <br>      InvokeEvent(*ppdisp, DISPID_SpriteClassEvents_Term, var, 1); <br> <br>  pspr-&gt;Release();    // For var[0].pdispVal <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>void CSpriteClass::FireLastTerm <br>( <br>  void <br>) <br>{ <br>  IDispatch **ppdisp = m_cp.m_rgpdisp; <br> <br>  for (; ppdisp &lt; &amp;m_cp.m_rgpdisp[SC_cADVISE]; ppdisp++) <br>    if (*ppdisp) <br>      InvokeEvent(*ppdisp, DISPID_SpriteClassEvents_LastTerm, NULL, 0); <br>} <br> <br> <br>//*************************************************************************** <br>// ISpriteClass Interface <br>//*************************************************************************** <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CSpriteClass::get_Application <br>( <br>  ISpruuidsApp** ppRet <br>) <br>{ <br>  if (!ppRet) <br>    return E_INVALIDARG; <br>  return g_punkApplicationNA-&gt;QueryInterface(IID_ISpruuidsApp, (void **)ppRet); <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CSpriteClass::get_Parent <br>( <br>  IGame** ppRet <br>) <br>{ <br>  if (!ppRet) <br>    return E_INVALIDARG; <br>  return m_pdisp-&gt;m_punkParent-&gt;QueryInterface(IID_IGame, (void **)ppRet); <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CSpriteClass::CreateSprite <br>( <br>  int       x, <br>  int       y, <br>  VARIANT   arg, <br>  ISprite **ppRet <br>) <br>{ <br>  CSprite *pspr = new CSprite(this, x, y, NULL, &amp;arg); <br>  if (!pspr) <br>    return E_OUTOFMEMORY; <br>  *ppRet = pspr; <br>  (*ppRet)-&gt;AddRef(); <br>  return S_OK; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CSpriteClass::get_Tag <br>( <br>  VARIANT* pRet <br>) <br>{ <br>  if (!pRet) <br>    return E_INVALIDARG; <br>  VariantInit(pRet); <br>  return VariantCopy(pRet, &amp;m_varTag); <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CSpriteClass::put_Tag <br>( <br>  VARIANT val <br>) <br>{ <br>  return VariantCopy(&amp;m_varTag, &amp;val); <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CSpriteClass::get_Image <br>( <br>  int* pRet <br>) <br>{ <br>  if (!pRet) <br>    return E_INVALIDARG; <br>  *pRet = m_iimg; <br>  return S_OK; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CSpriteClass::put_Image <br>( <br>  int val <br>) <br>{ <br>  if (val &gt; 0 &amp;&amp; val &lt; m_pdisp-&gt;m_cimg) <br>    m_iimg = val; <br>  return S_OK; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CSpriteClass::get_Border <br>( <br>  int* pRet <br>) <br>{ <br>  if (!pRet) <br>    return E_INVALIDARG; <br>  *pRet = m_brd; <br>  return S_OK; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CSpriteClass::put_Border <br>( <br>  int val <br>) <br>{ <br>  m_brd = val; <br>  return S_OK; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CSpriteClass::get_Collide <br>( <br>  int* pRet <br>) <br>{ <br>  if (!pRet) <br>    return E_INVALIDARG; <br>  *pRet = m_maskCollide; <br>  return S_OK; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CSpriteClass::put_Collide <br>( <br>  int val <br>) <br>{ <br>  m_maskCollide = val; <br>  return S_OK; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CSpriteClass::get_MaximumVelocity <br>( <br>  FLOAT* pRet <br>) <br>{ <br>  if (!pRet) <br>    return E_INVALIDARG; <br> <br>  *pRet = FLOATOFFULL(m_vFullMax); <br>  return S_OK; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CSpriteClass::put_MaximumVelocity <br>( <br>  FLOAT val <br>) <br>{ <br>  m_vFullMax = FULLOFFLOAT(val); <br>  return S_OK; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CSpriteClass::get_Friction <br>( <br>  FLOAT* pRet <br>) <br>{ <br>  if (!pRet) <br>    return E_INVALIDARG; <br>  *pRet = m_friction; <br>  return S_OK; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CSpriteClass::put_Friction <br>( <br>  FLOAT val <br>) <br>{ <br>  m_friction = val; <br>  return S_OK; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CSpriteClass::get_MaximumAcceleration <br>( <br>  FLOAT* pRet <br>) <br>{ <br>  if (!pRet) <br>    return E_INVALIDARG; <br> <br>  *pRet = FLOATOFFULL(m_aFullMax); <br>  return S_OK; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CSpriteClass::put_MaximumAcceleration <br>( <br>  FLOAT val <br>) <br>{ <br>  m_aFullMax = FULLOFFLOAT(val); <br>  return S_OK; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CSpriteClass::get_AccelerationFriction <br>( <br>  FLOAT* pRet <br>) <br>{ <br>  if (!pRet) <br>    return E_INVALIDARG; <br>  *pRet = m_frictionAccel; <br>  return S_OK; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CSpriteClass::put_AccelerationFriction <br>( <br>  FLOAT val <br>) <br>{ <br>  m_frictionAccel = val; <br>  m_fFrictionAccel = (val != (FLOAT)1.0); <br>  return S_OK; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CSpriteClass::get_SpriteCount <br>( <br>  int* pRet <br>) <br>{ <br>  if (!pRet) <br>    return E_INVALIDARG; <br>  *pRet = m_cspr; <br>  return S_OK; <br>} <br> <br> <br> <br>//*************************************************************************** <br>//*************************************************************************** <br>//** <br>//**  Sprite Class <br>//** <br>//*************************************************************************** <br>//*************************************************************************** <br> <br> <br>//*************************************************************************** <br>// ISprite Interface <br>//*************************************************************************** <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CSprite::get_Application <br>( <br>  ISpruuidsApp** ppRet <br>) <br>{ <br>  if (!ppRet) <br>    return E_INVALIDARG; <br>  return g_punkApplicationNA-&gt;QueryInterface(IID_ISpruuidsApp, (void **)ppRet); <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CSprite::get_Parent <br>( <br>  ISpriteClass** ppRet <br>) <br>{ <br>  if (!ppRet) <br>    return E_INVALIDARG; <br>  return m_psc-&gt;QueryInterface(IID_ISpriteClass, (void **)ppRet); <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CSprite::MoveTo <br>( <br>  FLOAT x, <br>  FLOAT y <br>) <br>{ <br>  this-&gt;MoveToFull(FULLOFFLOAT(x), FULLOFFLOAT(y), TRUE); <br>  return S_OK; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CSprite::MoveBy <br>( <br>  FLOAT dx, <br>  FLOAT dy <br>) <br>{ <br>  this-&gt;MoveByFull(FULLOFFLOAT(dx), FULLOFFLOAT(dy), TRUE); <br>  return S_OK; <br>} <br> <br> <br> <br>//--------------------------------------------------------------------------- <br>// <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CSprite::MoveAtSprite <br>( <br>  ISprite* sprite, <br>  float    dMax, <br>  float    scale, <br>  long     flags <br>) <br>{ <br>  if (!sprite) <br>    return E_INVALIDARG; <br> <br>  // Store parameters &amp; do every tickMove ticks if MAS_REMEMBER set. <br>  if (flags &amp; MAS_REMEMBER) <br>    { <br>    if (m_psprAt) <br>      { <br>      m_psprAt-&gt;Release(); <br>      m_psprAt = NULL; <br>      } <br>    m_psprAt = (CSprite *)(void *)sprite; <br>    if (!m_psprAt) <br>      return S_OK; <br>    m_psprAt-&gt;AddRef(); <br>    m_dMaxAt = dMax; <br>    m_scaleAt = scale; <br>    m_flagsAt = flags; <br>    return S_OK; <br>    } <br> <br>  // Otherwise, do this right now. <br>  this-&gt;DoMoveAt((CSprite *)(void *)sprite, dMax, scale, flags, FALSE); <br>  return S_OK; <br>} <br> <br> <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CSprite::Remove <br>( <br>  void  <br>) <br>{ <br>  this-&gt;MarkFree(); <br>  return S_OK; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CSprite::Refresh <br>( <br>  void  <br>) <br>{ <br>  this-&gt;_FDraw(FALSE); <br>  return S_OK; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CSprite::IgnoreMove <br>( <br>  void  <br>) <br>{ <br>  m_fIgnoreMove = TRUE; <br>  return S_OK; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CSprite::get_Left <br>( <br>  FLOAT* pRet <br>) <br>{ <br>  if (!pRet) <br>    return E_INVALIDARG; <br> <br>  *pRet = FLOATOFFULL(m_xFull); <br>  return S_OK; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CSprite::put_Left <br>( <br>  FLOAT val <br>) <br>{ <br>  m_xFull = FULLOFFLOAT(val); <br>  return S_OK; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CSprite::get_Top <br>( <br>  FLOAT* pRet <br>) <br>{ <br>  if (!pRet) <br>    return E_INVALIDARG; <br> <br>  *pRet = FLOATOFFULL(m_yFull); <br>  return S_OK; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CSprite::put_Top <br>( <br>  FLOAT val <br>) <br>{ <br>  m_yFull = FULLOFFLOAT(val); <br>  return S_OK; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CSprite::get_Vx <br>( <br>  FLOAT* pRet <br>) <br>{ <br>  if (!pRet) <br>    return E_INVALIDARG; <br> <br>  *pRet = FLOATOFFULL(m_vxFull); <br>  return S_OK; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CSprite::put_Vx <br>( <br>  FLOAT val <br>) <br>{ <br>  m_vxFull = FULLOFFLOAT(val); <br>  return S_OK; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CSprite::get_Vy <br>( <br>  FLOAT* pRet <br>) <br>{ <br>  if (!pRet) <br>    return E_INVALIDARG; <br> <br>  *pRet = FLOATOFFULL(m_vyFull); <br>  return S_OK; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CSprite::put_Vy <br>( <br>  FLOAT val <br>) <br>{ <br>  m_vyFull = FULLOFFLOAT(val); <br>  return S_OK; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CSprite::get_Ax <br>( <br>  FLOAT* pRet <br>) <br>{ <br>  if (!pRet) <br>    return E_INVALIDARG; <br> <br>  *pRet = FLOATOFFULL(m_axFull); <br>  return S_OK; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CSprite::put_Ax <br>( <br>  FLOAT val <br>) <br>{ <br>  m_axFull = FULLOFFLOAT(val); <br>  return S_OK; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CSprite::get_Ay <br>( <br>  FLOAT* pRet <br>) <br>{ <br>  if (!pRet) <br>    return E_INVALIDARG; <br> <br>  *pRet = FLOATOFFULL(m_ayFull); <br>  return S_OK; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CSprite::put_Ay <br>( <br>  FLOAT val <br>) <br>{ <br>  m_ayFull = FULLOFFLOAT(val); <br>  return S_OK; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CSprite::get_FrictionX <br>( <br>  FLOAT* pRet <br>) <br>{ <br>  if (!pRet) <br>    return E_INVALIDARG; <br> <br>  *pRet = m_fx; <br>  return S_OK; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CSprite::put_FrictionX <br>( <br>  FLOAT val <br>) <br>{ <br>  m_fx = val; <br>  m_fFriction = (m_fx != 1.0) || (m_fy != 1.0); <br>  return S_OK; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CSprite::get_FrictionY <br>( <br>  FLOAT* pRet <br>) <br>{ <br>  if (!pRet) <br>    return E_INVALIDARG; <br> <br>  *pRet = m_fy; <br>  return S_OK; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CSprite::put_FrictionY <br>( <br>  FLOAT val <br>) <br>{ <br>  m_fy = val; <br>  m_fFriction = (m_fx != 1.0) || (m_fy != 1.0); <br>  return S_OK; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CSprite::get_Width <br>( <br>  int* pRet <br>) <br>{ <br>  if (!pRet) <br>    return E_INVALIDARG; <br>  *pRet = m_pimg-&gt;cx; <br>  return S_OK; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CSprite::get_Height <br>( <br>  int* pRet <br>) <br>{ <br>  if (!pRet) <br>    return E_INVALIDARG; <br>  *pRet = m_pimg-&gt;cy; <br>  return S_OK; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CSprite::get_Image <br>( <br>  int* pRet <br>) <br>{ <br>  if (!pRet) <br>    return E_INVALIDARG; <br>  *pRet = m_iimg; <br>  return S_OK; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CSprite::put_Image <br>( <br>  int val <br>) <br>{ <br>  if (val &gt;= 0 &amp;&amp; val &lt; m_pdisp-&gt;m_cimg) <br>    { <br>    PIMG pimgCur = m_pimg; <br> <br>    if (!m_fHidden) <br>      this-&gt;_Erase(); <br>    m_iimg = val; <br>    m_pimg = &amp;(m_pdisp-&gt;m_prgimg[m_iimg]); <br>    // Keep image centered, if Visible <br>    if (!m_fHidden) <br>      { <br>      m_x += (pimgCur-&gt;cx - m_pimg-&gt;cx) &gt;&gt; 1; <br>      m_y += (pimgCur-&gt;cy - m_pimg-&gt;cy) &gt;&gt; 1; <br>      this-&gt;_FDraw(FALSE); <br>      } <br>    } <br>  return S_OK; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CSprite::get_TickMove <br>( <br>  int* pRet <br>) <br>{ <br>  if (!pRet) <br>    return E_INVALIDARG; <br>  *pRet = m_tickMoveMax; <br>  return S_OK; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CSprite::put_TickMove <br>( <br>  int val <br>) <br>{ <br>  m_tickMoveMax = val; <br>  if (m_tickMove &gt; m_tickMoveMax) <br>    m_tickMove = m_tickMoveMax; <br>  return S_OK; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CSprite::get_TickEvent <br>( <br>  int* pRet <br>) <br>{ <br>  if (!pRet) <br>    return E_INVALIDARG; <br>  *pRet = m_tickEvtMax; <br>  return S_OK; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CSprite::put_TickEvent <br>( <br>  int val <br>) <br>{ <br>  m_tickEvtMax = val; <br>  if (m_tickEvt &gt; m_tickEvtMax) <br>    m_tickEvt = m_tickEvtMax; <br>  return S_OK; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CSprite::get_Visible <br>( <br>  VARIANT_BOOL* pRet <br>) <br>{ <br>  if (!pRet) <br>    return E_INVALIDARG; <br>  *pRet = m_fHidden ? 0 : -1; <br>  return S_OK; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CSprite::put_Visible <br>( <br>  VARIANT_BOOL val <br>) <br>{ <br>  if (m_fLinked) <br>    { <br>    m_fHidden = !val; <br>    if (!m_fHidden) <br>      this-&gt;_Erase(); <br>    else <br>      this-&gt;_FDraw(FALSE); <br>    } <br>  return S_OK; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CSprite::get_Tag <br>( <br>  VARIANT* pRet <br>) <br>{ <br>  if (!pRet) <br>    return E_INVALIDARG; <br>  VariantInit(pRet); <br>  return VariantCopy(pRet, &amp;m_varTag); <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CSprite::put_Tag <br>( <br>  VARIANT val <br>) <br>{ <br>  return VariantCopy(&amp;m_varTag, &amp;val); <br>} <br> <br>//--- EOF ------------------------------------------------------------------- <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
