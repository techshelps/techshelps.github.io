<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>APP.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context4592"></a>APP.CPP</h2>
<pre><code>//--------------------------------------------------------------------------- <br>// App.cpp <br>//--------------------------------------------------------------------------- <br>// Shell for sample spr program <br>//--------------------------------------------------------------------------- <br>// (C) Copyright 1992-1997 by Microsoft Corporation.  All rights reserved. <br>// <br>// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF  <br>// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO  <br>// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A  <br>// PARTICULAR PURPOSE. <br>//--------------------------------------------------------------------------- <br> <br>#include "Main.h" <br>#pragma hdrstop <br>#include "App.h" <br>#include "MsgLoop.h" <br>#include "Game.h" <br>#include &lt;stdio.h&gt; <br> <br> <br>//--------------------------------------------------------------------------- <br>// DEBUG info <br>//--------------------------------------------------------------------------- <br>SZTHISFILE <br> <br> <br>//--------------------------------------------------------------------------- <br>// Prototypes <br>//--------------------------------------------------------------------------- <br>BOOL CALLBACK AppDlgProc(  HWND hwnd, UINT msg, WPARAM wp, LPARAM lp); <br>BOOL CALLBACK AboutDlgProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp); <br>LONG CALLBACK PSWndProc(   HWND hwnd, UINT msg, WPARAM wp, LPARAM lp); <br> <br> <br>//--------------------------------------------------------------------------- <br>// Global Variables <br>//--------------------------------------------------------------------------- <br>HINSTANCE g_hinst             = NULL; <br>ITypeLib *g_ptlMain           = NULL;   // Cache of TypeLib <br>CApp     *g_papp              = NULL; <br>IUnknown *g_punkApplicationNA = NULL;   // Not AddRef()'d <br>char     *g_pszCodeFile       = NULL; <br>char     *g_pszRecFile        = NULL; <br>FILE     *g_pfileRec          = NULL; <br>int       g_mode              = MODE_NORMAL; <br>CMGRRINFO App_crinfo = <br>  { <br>  sizeof(CMGRRINFO),      // size of CMGRRINFO structure in bytes. <br>  0,                      // Don't need idle time <br>  cmgrrfPreTranslateAll,  // Need pretranslate <br>  cmgradvfModal           // Need modal notifications <br>  }; <br>HRESULT CApp::s_hr = E_FAIL; <br> <br> <br>//--------------------------------------------------------------------------- <br>// Helpers for little vs. bit endian <br>//--------------------------------------------------------------------------- <br> <br>#undef BIGENDIAN // change for big-endian systems <br> <br>typedef union <br>  { <br>  DWORD i4; <br>  struct <br>    { <br>    char b1; <br>    char b2; <br>    char b3; <br>    char b4; <br>    }; <br>  } I4_SW; <br> <br>#ifndef BIGENDIAN <br>  #define NORMALIZE_I4(i4)  (i4) <br>#else <br>  #define NORMALIZE_I4(i4) \ <br>    {                      \ <br>    I4_SW l=i4;            \ <br>    (i4).b1 = l.b4;        \ <br>    (i4).b2 = l.b3;        \ <br>    (i4).b3 = l.b2;        \ <br>    (i4).b4 = l.b1;        \ <br>    } <br>#endif <br> <br>typedef struct <br>  { <br>  char   win; <br>  char   msg; <br>  I4_SW  wp; <br>  I4_SW  lp; <br>  } REC; <br> <br> <br>//--------------------------------------------------------------------------- <br>// Write out one message. <br>//--------------------------------------------------------------------------- <br>#define RECORD(win, msg, wp, lp)    {if (g_mode == MODE_RECORD) Record(win,msg,wp,lp);} <br>#define WIN_DLG   ((char)0xdd)  // Dlg <br>#define WIN_PS    ((char)0xee)  // playsurfacE <br>#define WIN_ABOUT ((char)0xaa)  // About <br>   <br>void Record <br>( <br>  char   win, <br>  UINT   msg, <br>  WPARAM wp, <br>  LPARAM lp <br>) <br>{ <br>  REC rec; <br> <br>  if (!g_pfileRec) <br>    { <br>    g_pfileRec = fopen(g_pszRecFile, "wb"); <br>    if (!g_pfileRec) <br>      { <br>      MessageBox(NULL, "Could not open record file", "Spruuids", MB_OK | MB_ICONEXCLAMATION); <br>      exit(1); <br>      } <br>    } <br> <br>  switch (msg) <br>    { <br>    default: <br>      return; <br> <br>    case WM_COMMAND: <br>      msg = 1; <br>      break; <br>    case WM_SYSCOMMAND: <br>      msg = 2; <br>      break; <br>    case WM_TIMER: <br>      msg = 3; <br>      break; <br>    case WM_CHAR: <br>      msg = 4; <br>      break; <br>    case WM_KEYDOWN: <br>      msg = 5; <br>      break; <br>    case WM_KEYUP: <br>      msg = 6; <br>      break; <br>    case WM_MOUSEMOVE: <br>      msg = 7; <br>      break; <br>    case WM_LBUTTONUP: <br>      msg = 8; <br>      break; <br>    case WM_RBUTTONUP: <br>      msg = 9; <br>      break; <br>    case WM_MBUTTONUP: <br>      msg = 10; <br>      break; <br>    case WM_LBUTTONDOWN: <br>      msg = 11; <br>      break; <br>    case WM_RBUTTONDOWN: <br>      msg = 12; <br>      break; <br>    case WM_MBUTTONDOWN: <br>      msg = 13; <br>      break; <br>    } <br> <br>  rec.win = win; <br>  rec.msg = (char)msg; <br>  rec.wp.i4 = wp; <br>  NORMALIZE_I4(rec.wp);    // Handle byte-swapping for little vs. big endian. <br>  rec.lp.i4 = lp; <br>  NORMALIZE_I4(rec.lp);    // Handle byte-swapping for little vs. big endian. <br>  fwrite(&amp;rec, sizeof(rec), 1, g_pfileRec); <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>// <br>//--------------------------------------------------------------------------- <br>HRESULT CApp::Playback <br>( <br>  void <br>) <br>{ <br>  REC    rec; <br>  HWND   hwnd; <br>  UINT   msg; <br> <br>  if (!g_pfileRec) <br>    { <br>    g_pfileRec = fopen(g_pszRecFile, "rb"); <br>    if (!g_pfileRec) <br>      { <br>      MessageBox(NULL, "Could not open playback file", "Spruuids", MB_OK | MB_ICONEXCLAMATION); <br>      return E_FAIL; <br>      } <br>    } <br> <br>  while (TRUE) <br>    { <br>    size_t cch = fread(&amp;rec, sizeof(rec), 1, g_pfileRec); <br>    if (cch != 1) <br>      { <br>      if (feof(g_pfileRec)) <br>        { <br>        fclose(g_pfileRec); <br>        g_pfileRec = NULL; <br>        g_mode = MODE_NORMAL; <br>        m_fQuit = TRUE; <br>        return S_OK; <br>        } <br>      MessageBox(NULL, "Unexpected read error in playback file", "Spruuids", MB_OK | MB_ICONEXCLAMATION); <br>      return E_FAIL; <br>      } <br> <br>    switch (rec.win) <br>      { <br>      case WIN_DLG: <br>        hwnd = m_hwndDlg; <br>        break; <br> <br>      case WIN_PS: <br>        hwnd = m_hwndPS; <br>        break; <br> <br>      case WIN_ABOUT: <br>        hwnd = m_hwndAbout; <br>        break; <br>      } <br> <br>    UINT mpimsg[] = {0, WM_COMMAND, WM_SYSCOMMAND, WM_TIMER, WM_CHAR, WM_KEYDOWN, WM_KEYUP, <br>                        WM_MOUSEMOVE, WM_LBUTTONUP, WM_RBUTTONUP, WM_MBUTTONUP, WM_LBUTTONDOWN, <br>                        WM_RBUTTONDOWN, WM_MBUTTONDOWN}; <br>    if (rec.msg &lt;= 0 || rec.msg &gt;= sizeof(mpimsg)/sizeof(mpimsg[0])) <br>      { <br>      MessageBox(NULL, "Bad msg # in playback file", "Spruuids", MB_OK | MB_ICONEXCLAMATION); <br>      return E_FAIL; <br>      } <br>    msg = mpimsg[rec.msg]; <br>    NORMALIZE_I4(rec.wp);    // Handle byte-swapping for little vs. big endian. <br>    NORMALIZE_I4(rec.lp);    // Handle byte-swapping for little vs. big endian. <br> <br>    SendMessage(hwnd, msg, (WPARAM)rec.wp.i4, (LPARAM)rec.lp.i4); <br>    if (!m_pmsgloop-&gt;FPushMessageLoop(g_papp-&gt;m_idcomp, cmgrloopDoEvents, NULL)) <br>      return E_FAIL; <br>    } <br> <br>  return S_OK; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>// Helper to parse command-line parameters <br>//--------------------------------------------------------------------------- <br>HRESULT ParseCmdLine <br>( <br>  char *pszCmdLine <br>) <br>{ <br>  if (!pszCmdLine) <br>    goto DoError; <br> <br>  if (pszCmdLine[0] == '/') <br>    { <br>    if (pszCmdLine[1] == 'P') <br>      { <br>      g_mode = MODE_PLAYBACK; <br>      goto GetFile; <br>      } <br>    else if (pszCmdLine[1] == 'R') <br>      { <br>      g_mode = MODE_RECORD; <br>GetFile: <br>      if (pszCmdLine[2] &lt;= ' ') <br>        goto DoError; <br>      pszCmdLine += 2; <br>      g_pszRecFile = pszCmdLine; <br>      while (*pszCmdLine &gt; ' ')   // Skip non-white space <br>        pszCmdLine++; <br>      if (!*pszCmdLine)   // End Of String <br>        goto DoError;     // Needed &lt;fileCode&gt; <br>      *pszCmdLine = 0; <br>      pszCmdLine++; <br>      srand(1);           // Seed random # generator <br>      } <br>    else <br>      goto DoError; <br>    } <br> <br>  // Skip white space <br>  while (*pszCmdLine &amp;&amp; *pszCmdLine &lt;= ' ') <br>    pszCmdLine++; <br>  if (!*pszCmdLine) <br>    { <br>DoError: <br>    MessageBox(NULL, "Usage: Spruuids [/P&lt;filePlay&gt; | /R&lt;fileRec&gt;] &lt;fileCode&gt;, where &lt;fileCode&gt; is a VB Script", "Spruuids", MB_OK | MB_ICONEXCLAMATION); <br>    return E_FAIL; <br>    } <br> <br>  // Rest of Cmd Line should be source file <br>  g_pszCodeFile = pszCmdLine; <br>  return S_OK; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>// Main program <br>//--------------------------------------------------------------------------- <br>int WINAPI WinMain <br>( <br>  HINSTANCE hinst,        // Instance handle of current instance <br>  HINSTANCE hinstPrev,    // Instance handle of previous instance <br>  LPSTR     lpszCmdLine,  // Null-terminated command line <br>  int    iCmdShow      // How window should be initially displayed <br>) <br>{ <br>  int     ret   = 1;      // Assume non-normal exit <br>  BOOL    fInit = FALSE; <br>  HRESULT hr; <br> <br>  // Stuff hinst in global for all to see <br>  g_hinst      = hinst; <br>  hr = ParseCmdLine(lpszCmdLine); <br>  if (hr) <br>    goto CleanUp; <br> <br>  // Initialize OLE <br>  hr = CoInitialize(NULL); <br>  if (hr) <br>    goto CleanUp; <br>  fInit = TRUE; <br> <br>  // Create the CApp object, since it runs the show, note it inits g_papp <br>  hr = CApp::CreateApp(hinst); <br>  if (hr) <br>    goto CleanUp; <br>  ASSERT(g_papp, "!hr but g_papp==NULL"); <br> <br>  // Start a new game <br>  g_papp-&gt;CausePause(0); <br>  AppEvt_NewGame(); <br> <br>  // Either Playback or push the main msg loop <br>  if (g_mode == MODE_PLAYBACK) <br>    hr = g_papp-&gt;Playback(); <br>  else <br>    hr = g_papp-&gt;MainMsgLoop(); <br>  if (hr) <br>    goto CleanUp; <br> <br>  // Normal exit <br>  ret = 0; <br> <br>  // Cleanup, if we haven't already done so <br>CleanUp: <br>  if (g_pfileRec) <br>    { <br>    fclose(g_pfileRec); <br>    g_pfileRec = NULL; <br>    } <br>  if (g_papp) <br>    delete g_papp; <br>  if (fInit) <br>    CoUninitialize(); <br>  return ret; <br>} <br> <br> <br>//*************************************************************************** <br>// Constructor and Destructor support for CApp <br>//*************************************************************************** <br> <br>//--------------------------------------------------------------------------- <br>// Creates an instance of CApp.  Use this instead of "new", as this returns <br>// errors, etc. <br>//--------------------------------------------------------------------------- <br>HRESULT CApp::CreateApp <br>( <br>  HINSTANCE hinst <br>) <br>{ <br>  if (g_papp) <br>    return E_UNEXPECTED; <br> <br>  CApp *papp = new CApp(hinst); <br>  if (!papp) <br>    return E_OUTOFMEMORY; <br>  if (papp-&gt;s_hr) <br>    return papp-&gt;s_hr; <br> <br>  return S_OK; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>// Constructor <br>//--------------------------------------------------------------------------- <br>CApp::CApp <br>( <br>  HINSTANCE hinst <br>) <br>{ <br>  WNDCLASS cls; <br>  RECT     rect; <br>  int      cx, cy; <br> <br>  INIT_SIGNATURE(SIG_App); <br> <br>  // Init globals <br>  g_papp              = this; <br>  g_punkApplicationNA = this-&gt;GetUnknown(); // GetUnknown() doesn't AddRef, but we don't want to anyway. <br>  s_hr                = E_FAIL;             // Assume failure <br> <br>  // Init members <br>  m_pmsgloop        = NULL; <br>  m_pgame           = NULL; <br>  m_hwndDlg         = NULL; <br>  m_hwndPS          = NULL; <br>  m_hwndStat        = NULL; <br>  m_hwndAbout       = NULL; <br>  m_hinst           = hinst; <br>  m_idcomp          = 0xffffffff; <br>  m_fRegisteredComp = FALSE; <br>  m_cmodal          = 0; <br>  m_fQuit           = FALSE; <br>  m_cref            = 1; <br>  m_ptinfoCls       = NULL; <br>  m_ptinfoInt       = NULL; <br>  m_pdispBaseObject = NULL; <br> <br>  // Add new class for dialog which is our application: <br>  cls.style         = 0; <br>  cls.lpfnWndProc   = DefDlgProc; <br>  cls.cbClsExtra    = 0; <br>  cls.cbWndExtra    = 0; <br>  cls.hInstance     = hinst; <br>  cls.hIcon         = LoadIcon(hinst, MAKEINTRESOURCE(ID_ICO_APP)); <br>  cls.hCursor       = NULL; <br>  cls.hbrBackground = (HBRUSH)GetStockObject(LTGRAY_BRUSH); <br>  cls.lpszMenuName  = NULL; <br>  cls.lpszClassName = "DlgClass"; <br>  if (!RegisterClass(&amp;cls)) <br>    return; <br> <br>  // Add new class for play surface: <br>  cls.style         = CS_OWNDC; <br>  cls.lpfnWndProc   = PSWndProc; <br>  cls.cbClsExtra    = 0; <br>  cls.cbWndExtra    = 0; <br>  cls.hInstance     = hinst; <br>  cls.hIcon         = NULL; <br>  cls.hCursor       = LoadCursor(hinst, MAKEINTRESOURCE(ID_CUR_PLAYSURF)); <br>  cls.hbrBackground = NULL; <br>  cls.lpszMenuName  = NULL; <br>  cls.lpszClassName = "PlaySurface"; <br>  if (!RegisterClass(&amp;cls)) <br>    return; <br> <br>  // Now that we've registerd the window classes, create the main window <br>  m_hwndDlg = CreateDialog(hinst, MAKEINTRESOURCE(ID_DLG_APP), NULL, AppDlgProc); <br>  if (!m_hwndDlg) <br>    { <br>    s_hr = E_OUTOFMEMORY; <br>    return; <br>    } <br> <br>  // Center Dialog: <br>  GetWindowRect(m_hwndDlg, &amp;rect); <br>  rect.right  -= rect.left; <br>  rect.bottom -= rect.top; <br>  cx = GetSystemMetrics(SM_CXSCREEN); <br>  cy = GetSystemMetrics(SM_CYSCREEN); <br>  MoveWindow(m_hwndDlg, (cx - rect.right) &gt;&gt; 1, (cy - rect.bottom) &gt;&gt; 1, rect.right, rect.bottom, TRUE); <br> <br>  // Create the Component Manager <br>  m_pmsgloop = new CMsgLoop(m_hwndDlg); <br>  if (!m_pmsgloop) <br>    { <br>    s_hr = E_OUTOFMEMORY; <br>    return; <br>    } <br> <br>  m_fRegisteredComp = m_pmsgloop-&gt;FRegisterComponent(this, &amp;App_crinfo, &amp;m_idcomp); <br>  if (!m_fRegisteredComp) <br>    return; <br> <br>  HRESULT hr = this-&gt;LoadGame(); <br>  if (hr) <br>    { <br>    s_hr = hr; <br>    return; <br>    } <br> <br>  // Success <br>  s_hr = S_OK; <br>  ShowWindow(m_hwndDlg, SW_NORMAL); <br>  return; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>// Destructor <br>//--------------------------------------------------------------------------- <br>CApp::~CApp <br>( <br>  void <br>) <br>{ <br>  CHECK_SIGNATURE(SIG_App); <br> <br>  g_papp = NULL; <br>  g_punkApplicationNA = NULL;   // Wasn't AddRef()'d, so don't Release(). <br> <br>  if (m_hwndDlg) <br>    { <br>    ShowWindow(m_hwndDlg, SW_HIDE); <br>    ReleaseCapture(); <br>    DestroyWindow(m_hwndDlg); <br>    m_hwndDlg = NULL; <br>    } <br> <br>  if (m_pgame) <br>    { <br>    delete m_pgame; <br>    m_pgame = NULL; <br>    } <br> <br>  if (m_fRegisteredComp) <br>    { <br>    ASSERT(m_pmsgloop, "m_idcomp, but !m_pmsgloop"); <br>    BOOL f = m_pmsgloop-&gt;FRevokeComponent(m_idcomp); <br>    ASSERT(!f, "!f"); <br>    m_fRegisteredComp = FALSE; <br>    } <br> <br>  if (m_pmsgloop) <br>    { <br>    m_pmsgloop-&gt;Release(); <br>    m_pmsgloop = NULL; <br>    } <br> <br>  // Free dynamically created TypeInfo / TypeLib stuff <br>  if (g_ptinfoClsGame) <br>    g_ptinfoClsGame-&gt;Release(); <br>  if (g_ptinfoIntGame) <br>    g_ptinfoIntGame-&gt;Release(); <br> <br>  if (g_ptlGameSubObj) <br>    g_ptlGameSubObj-&gt;Release(); <br> <br>  // Free TypeInfo / TypeLib loaded from our resources <br>  if (g_ptinfoClsGameOA) <br>    g_ptinfoClsGameOA-&gt;Release(); <br>  if (g_ptinfoIntGameOA) <br>    g_ptinfoIntGameOA-&gt;Release(); <br> <br>  if (g_ptinfoClsSpriteClass) <br>    g_ptinfoClsSpriteClass-&gt;Release(); <br>  if (g_ptinfoIntSpriteClass) <br>    g_ptinfoIntSpriteClass-&gt;Release(); <br> <br>  if (g_ptinfoClsSprite) <br>    g_ptinfoClsSprite-&gt;Release(); <br>  if (g_ptinfoIntSprite) <br>    g_ptinfoIntSprite-&gt;Release(); <br> <br>  if (m_ptinfoCls) <br>    m_ptinfoCls-&gt;Release(); <br>  if (m_ptinfoInt) <br>    m_ptinfoInt-&gt;Release(); <br> <br>  if (g_ptlMain) <br>    g_ptlMain-&gt;Release(); <br> <br>  DESTROY_SIGNATURE(SIG_App); <br>} <br> <br> <br>//*************************************************************************** <br>// General methods <br>//*************************************************************************** <br> <br>//--------------------------------------------------------------------------- <br>// Enter main message loop for application <br>//--------------------------------------------------------------------------- <br>HRESULT CApp::MainMsgLoop <br>( <br>  void <br>) <br>{ <br>  if (!m_pmsgloop-&gt;FPushMessageLoop(g_papp-&gt;m_idcomp, cmgrloopDoEvents, NULL)) <br>    return E_FAIL; <br> <br>  return S_OK; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>// Load a game from the given file. <br>//--------------------------------------------------------------------------- <br>HRESULT CApp::LoadGame <br>( <br>  void <br>) <br>{ <br>  if (m_pgame) <br>    return E_UNEXPECTED; <br> <br>  return CGame::CreateGame(g_hinst, m_hwndDlg, m_hwndPS, m_hwndStat, m_pmsgloop, &amp;m_pgame); <br>} <br> <br>   <br>//--------------------------------------------------------------------------- <br>// Get rid of an existing game, if present. <br>//--------------------------------------------------------------------------- <br>void CApp::CloseGame <br>( <br>  void <br>) <br>{ <br>  if (m_pgame) <br>    { <br>    m_pgame-&gt;Close(); <br>    m_pgame-&gt;Release(); <br>    m_pgame = NULL; <br>    } <br>} <br> <br>   <br>//--------------------------------------------------------------------------- <br>// Called when pausing or unpausing <br>//--------------------------------------------------------------------------- <br>void CApp::CausePause <br>( <br>  int p   // -1=Toggle, 0=UnPause, 1=Pause <br>) <br>{ <br>  // Invoke game.cpp's Pause event.  Returns whether or not app is paused <br>  p = AppEvt_Pause(p); <br>} <br> <br> <br>//*************************************************************************** <br>// DlgProcs, WndProcs <br>//*************************************************************************** <br> <br>//--------------------------------------------------------------------------- <br>// <br>//--------------------------------------------------------------------------- <br>BOOL CALLBACK AppDlgProc <br>( <br>  HWND   hwnd, <br>  UINT   msg, <br>  WPARAM wp, <br>  LPARAM lp <br>) <br>{ <br>  switch (msg) <br>    { <br>    case WM_INITDIALOG: <br>      { <br>      g_papp-&gt;m_hwndDlg  = hwnd; <br>      g_papp-&gt;m_hwndPS   = GetDlgItem(hwnd, ID_CTL_PLAYSURF); <br>      g_papp-&gt;m_hwndStat = GetDlgItem(hwnd, ID_CTL_STATUS); <br>      break; <br>      } <br> <br>    case WM_ACTIVATE: <br>      if (LOWORD(wp) != WA_INACTIVE) <br>        { <br>        g_papp-&gt;m_pmsgloop-&gt;OnComponentActivate(g_papp-&gt;m_idcomp); <br>        SetFocus(g_papp-&gt;m_hwndPS); <br>        return TRUE; <br>        } <br>      break; <br> <br>    case WM_SETFOCUS: <br>      SetFocus(g_papp-&gt;m_hwndPS); <br>      return TRUE; <br> <br>    case WM_QUERYDRAGICON: <br>      return (BOOL)LoadIcon(g_papp-&gt;m_hinst, MAKEINTRESOURCE(ID_ICO_APP)); <br> <br>    case WM_PAINT: <br>      { <br>      HDC hdc; <br>      PAINTSTRUCT ps; <br> <br>      if (!IsIconic(hwnd)) <br>        return FALSE; <br>      hdc = wp ? (HDC)wp : BeginPaint(hwnd, &amp;ps); <br>      DrawIcon(hdc, 0, 0, LoadIcon(g_papp-&gt;m_hinst, MAKEINTRESOURCE(ID_ICO_APP))); <br>      if (!wp) <br>        EndPaint(hwnd, &amp;ps); <br>      return TRUE; <br>      } <br> <br>    case WM_ERASEBKGND: <br>      { <br>      if (IsIconic(hwnd)) <br>        { <br>        DefWindowProc(hwnd, msg, wp, lp); <br>        return TRUE; <br>        } <br> <br>      // Draw fancy boarders <br>      RECT rect; <br> <br>      GetClientRect(hwnd, &amp;rect); <br>      DrawEdge((HDC)wp, &amp;rect, 0, BF_RECT | BF_MIDDLE); <br> <br>      GetWindowRect(g_papp-&gt;m_hwndPS, &amp;rect); <br>      ScreenToClient(hwnd, (LPPOINT)&amp;rect); <br>      ScreenToClient(hwnd, (LPPOINT)&amp;rect.right); <br>      InflateRect(&amp;rect, 2, 2); <br>      DrawEdge((HDC)wp, &amp;rect, EDGE_SUNKEN, BF_RECT); <br> <br>      GetWindowRect(g_papp-&gt;m_hwndStat, &amp;rect); <br>      InflateRect(&amp;rect, 2, 2); <br>      ScreenToClient(hwnd, (LPPOINT)&amp;rect); <br>      ScreenToClient(hwnd, (LPPOINT)&amp;rect.right); <br>      DrawEdge((HDC)wp, &amp;rect, BDR_SUNKENOUTER, BF_RECT); <br>      break; <br>      } <br> <br>    case WM_SYSCOMMAND: <br>      RECORD(WIN_DLG, msg, wp, lp); <br>      switch (wp &amp; 0xfff0) <br>        { <br>        case SC_CLOSE: <br>          if (g_papp-&gt;FQueryTerminate(TRUE)) <br>            g_papp-&gt;m_fQuit = TRUE; <br>          break; <br>        } <br>      return FALSE; <br> <br>    case WM_SIZE: <br>      if (IsIconic(hwnd)) <br>        g_papp-&gt;CausePause(TRUE); <br>      break; <br> <br>    case WM_COMMAND: <br>      RECORD(WIN_DLG, msg, wp, lp); <br>      if (!LOWORD(lp) || HIWORD(lp) == 1) <br>        switch (wp) <br>          { <br>          case ID_MENU_NEWGAME: <br>            g_papp-&gt;CausePause(1); <br>            if (!g_papp-&gt;m_pgame-&gt;m_fGameOver &amp;&amp; g_mode != MODE_PLAYBACK) <br>              { <br>              int ret; <br>              g_papp-&gt;m_pmsgloop-&gt;OnComponentEnterState(g_papp-&gt;m_idcomp, cmgrstateModal, cmgrcontextAll, 0, NULL, NULL); <br>              ret = MessageBox(g_papp-&gt;m_hwndDlg, "Do you really want to start a new game?", "Spruuids", MB_YESNO | MB_ICONQUESTION); <br>              g_papp-&gt;m_pmsgloop-&gt;FOnComponentExitState(g_papp-&gt;m_idcomp, cmgrstateModal, cmgrcontextAll, 0, NULL); <br>              SetFocus(g_papp-&gt;m_hwndPS); <br>              if (ret == IDYES) <br>                goto NewGame; <br>              } <br>            else <br>              { <br>NewGame:      g_papp-&gt;CausePause(0); <br>              AppEvt_NewGame(); <br>              } <br>            return TRUE; <br> <br>          case ID_MENU_EDIT: <br>            { <br>            char sz[255]; <br>            // Shell notepad to edit file we loaded. <br>            g_papp-&gt;CausePause(1); <br>            wsprintf(sz, "Notepad.exe %s", g_pszCodeFile); <br>            WinExec(sz, SW_SHOWNORMAL); <br>            return TRUE; <br>            } <br> <br>          case ID_MENU_RELOAD: <br>            g_papp-&gt;CausePause(1); <br>            if (g_papp-&gt;m_pgame &amp;&amp; !g_papp-&gt;m_pgame-&gt;m_fGameOver) <br>              { <br>              int ret; <br>              g_papp-&gt;m_pmsgloop-&gt;OnComponentEnterState(g_papp-&gt;m_idcomp, cmgrstateModal, cmgrcontextAll, 0, NULL, NULL); <br>              ret = MessageBox(g_papp-&gt;m_hwndDlg, "Do you really want to start a new game?", "Spruuids", MB_YESNO | MB_ICONQUESTION); <br>              g_papp-&gt;m_pmsgloop-&gt;FOnComponentExitState(g_papp-&gt;m_idcomp, cmgrstateModal, cmgrcontextAll, 0, NULL); <br>              SetFocus(g_papp-&gt;m_hwndPS); <br>              if (ret == IDYES) <br>                goto OpenGame; <br>              } <br>            else <br>              { <br>OpenGame:     g_papp-&gt;CloseGame(); <br>              g_papp-&gt;LoadGame(); <br>              g_papp-&gt;CausePause(0); <br>              AppEvt_NewGame();    // Start a new game <br>              } <br>            return TRUE; <br> <br>          case ID_MENU_EXIT: <br>            if (g_papp-&gt;FQueryTerminate(TRUE)) <br>              g_papp-&gt;m_fQuit = TRUE; <br>            return TRUE; <br> <br>          case ID_MENU_PAUSE: <br>            g_papp-&gt;CausePause(-1); <br>            break; <br> <br>          case ID_MENU_ABOUT: <br>            g_papp-&gt;CausePause(1); <br>            g_papp-&gt;m_pmsgloop-&gt;OnComponentEnterState(g_papp-&gt;m_idcomp, cmgrstateModal, cmgrcontextAll, 0, NULL, NULL); <br>            DialogBox(g_papp-&gt;m_hinst, MAKEINTRESOURCE(ID_DLG_ABOUT), g_papp-&gt;m_hwndDlg, AboutDlgProc); <br>            g_papp-&gt;m_pmsgloop-&gt;FOnComponentExitState(g_papp-&gt;m_idcomp, cmgrstateModal, cmgrcontextAll, 0, NULL); <br>            SetFocus(g_papp-&gt;m_hwndPS); <br>            return TRUE; <br> <br>          case ID_MENU_HIGHSCORES: <br>          case ID_MENU_HELPINDEX: <br>          case ID_MENU_HELPPLAY: <br>          case ID_MENU_HELPCOMMANDS: <br>          case ID_MENU_HELPHELP: <br>            return TRUE; <br>          } <br>      break; <br>    } <br> <br>  return AppEvt_DlgProc(hwnd, msg, wp, lp); <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>// <br>//--------------------------------------------------------------------------- <br>BOOL CALLBACK AboutDlgProc <br>( <br>  HWND   hwnd, <br>  UINT   msg, <br>  WPARAM wp, <br>  LPARAM lp <br>) <br>{ <br>  switch (msg) <br>    { <br>    case WM_INITDIALOG: <br>      { <br>      RECT rect; <br>      RECT rect2; <br> <br>      g_papp-&gt;m_hwndAbout = hwnd; <br>      GetWindowRect(g_papp-&gt;m_hwndDlg, &amp;rect); <br>      GetWindowRect(hwnd, &amp;rect2); <br>      MoveWindow(hwnd, (rect.right+rect.left)/2-(rect2.right-rect2.left)/2, <br>                       (rect.bottom+rect.top)/2-(rect2.bottom-rect2.top)/2, <br>                       rect2.right-rect2.left, <br>                       rect2.bottom-rect2.top, <br>                       TRUE); <br>      return TRUE; <br>      } <br> <br>    case WM_COMMAND: <br>      RECORD(WIN_ABOUT, msg, wp, lp); <br>      g_papp-&gt;m_hwndAbout = NULL; <br>      EndDialog(hwnd, TRUE); <br>      return TRUE; <br>    } <br>  return FALSE; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>// <br>//--------------------------------------------------------------------------- <br>LRESULT CALLBACK PSWndProc <br>( <br>  HWND   hwnd, <br>  UINT   msg, <br>  WPARAM wp, <br>  LPARAM lp <br>) <br>{ <br>  switch (msg) <br>    { <br>    case WM_TIMER: <br>    case WM_CHAR: <br>    case WM_KEYUP: <br>    case WM_MOUSEMOVE: <br>    case WM_LBUTTONUP: <br>    case WM_RBUTTONUP: <br>    case WM_MBUTTONUP: <br>      RECORD(WIN_PS, msg, wp, lp); <br>      break; <br> <br> <br>    case WM_LBUTTONDOWN: <br>    case WM_RBUTTONDOWN: <br>    case WM_MBUTTONDOWN: <br>      RECORD(WIN_PS, msg, wp, lp); <br>      SetFocus(hwnd); <br>      break; <br> <br>    case WM_GETDLGCODE: <br>      return DLGC_WANTALLKEYS | DLGC_WANTARROWS | DLGC_WANTCHARS | DLGC_WANTMESSAGE | DLGC_WANTTAB; <br> <br>    case WM_KEYDOWN: <br>      RECORD(WIN_PS, msg, wp, lp); <br>      switch (wp) <br>        { <br>        case VK_ESCAPE: <br>          ShowWindow(g_papp-&gt;m_hwndDlg, SW_MINIMIZE); <br>          break; <br> <br>        case VK_F1: <br>          SendMessage(g_papp-&gt;m_hwndDlg, WM_COMMAND, ID_MENU_HELPINDEX, 0L); <br>          break; <br> <br>        case VK_F2: <br>          SendMessage(g_papp-&gt;m_hwndDlg, WM_COMMAND, ID_MENU_NEWGAME, 0L); <br>          break; <br> <br>        case VK_PAUSE: <br>        case VK_F3: <br>          SendMessage(g_papp-&gt;m_hwndDlg, WM_COMMAND, ID_MENU_PAUSE, 0L); <br>          break; <br> <br>        case VK_F5: <br>          SendMessage(g_papp-&gt;m_hwndDlg, WM_COMMAND, ID_MENU_RELOAD, 0L); <br>          break; <br> <br>        case VK_F9: <br>          SendMessage(g_papp-&gt;m_hwndDlg, WM_COMMAND, ID_MENU_EDIT, 0L); <br>          break; <br>        } <br>      break; <br>    } <br> <br>  return AppEvt_PSWndProc(hwnd, msg, wp, lp); <br>} <br> <br> <br>//*************************************************************************** <br>// IUnknown Interface <br>//*************************************************************************** <br> <br>//--------------------------------------------------------------------------- <br>// <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CApp::QueryInterface <br>( <br>  REFIID iid, <br>  void **ppvObjOut <br>) <br>{ <br>  if (!ppvObjOut) <br>    return E_INVALIDARG; <br> <br>  *ppvObjOut = NULL; <br> <br>  if (iid == IID_IUnknown) <br>    *ppvObjOut = this-&gt;GetUnknown(); <br>  else if (iid == IID_IDispatch) <br>    *ppvObjOut = this-&gt;GetDispatch(); <br>  else if (iid == IID_ISpruuidsApp) <br>    *ppvObjOut = (ISpruuidsApp *)this; <br>  else if (iid == IID_IOleComponent) <br>    *ppvObjOut = (IOleComponent *)this; <br> <br>  if (*ppvObjOut) <br>    { <br>    this-&gt;AddRef(); <br>    return S_OK; <br>    } <br> <br>  return E_NOINTERFACE; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>// <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP_(ULONG) CApp::AddRef <br>( <br>  void <br>) <br>{ <br>  ASSERT(m_cref, "bad m_cref"); <br>  return ++m_cref; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>// <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP_(ULONG) CApp::Release <br>( <br>  void <br>) <br>{ <br>  ASSERT(m_cref, "bad m_cref"); <br>  m_cref--; <br>  if (!m_cref) <br>    { <br>    delete this; <br>    return 0; <br>    } <br>  return m_cref; <br>} <br> <br> <br>//*************************************************************************** <br>// IOleComponent Interface <br>//*************************************************************************** <br> <br>//--------------------------------------------------------------------------- <br>// <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP_(BOOL) CApp::FPreTranslateMessage <br>( <br>  MSG *pmsg <br>) <br>{ <br>  return IsDialogMessage(m_hwndDlg, pmsg); <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>// <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP_(void) CApp::OnEnterState <br>( <br>  ULONG state, <br>  BOOL  fEnter <br>) <br>{ <br>  // TODO: We only care about Modal notifications.  You application will likely <br>  // TODO: need to support some of the others. <br> <br>  if (state == cmgrstateModal) <br>    { <br>    if (fEnter) <br>      { <br>      if (!m_cmodal) <br>        { <br>        this-&gt;CausePause(1);              // Pause for the user, since we're modal <br>        EnableWindow(m_hwndDlg, FALSE);   // Entering modal state, so disable window <br>        } <br>      m_cmodal++; <br>      } <br>    else if (m_cmodal)    // Don't decrement if zero! <br>      { <br>      m_cmodal--; <br>      if (!m_cmodal) <br>        EnableWindow(m_hwndDlg, TRUE);   // Leaving modal state, so re-enable window <br>      } <br>    } <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>// <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP_(void) CApp::OnAppActivate <br>( <br>  BOOL  fActive, <br>  DWORD dwOtherThreadID <br>) <br>{ <br>  // TODO: If you have floating palettes, etc., show them here. <br>  SetFocus(m_hwndPS); <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>// <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP_(void) CApp::OnLoseActivation <br>( <br>  void <br>) <br>{ <br>  // TODO: If you have floating palettes, etc., hide them here. <br>  this-&gt;CausePause(1); <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>// <br>//--------------------------------------------------------------------------- </code></pre>
<p>
</p>
<pre><code>STDMETHODIMP_(BOOL) CApp::FDoIdle <br>( <br>  DWORD grfidlef <br>) <br>{ <br>  // TODO: If you have need idle-time processing, do so here <br>  return FALSE; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>// <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP_(BOOL) CApp::FContinueMessageLoop <br>( <br>  ULONG uReason, <br>  void *pvLoopData <br>) <br>{ <br>  MSG msg; <br> <br>  // If we're playing back a recording, return from msg loop once there are <br>  // no more msgs. <br>  if (g_mode == MODE_PLAYBACK &amp;&amp; !PeekMessage(&amp;msg, NULL, NULL, NULL, PM_NOREMOVE)) <br>    return FALSE; <br> <br>  // Since the only time we push a message loop is for the Main message loop, <br>  // we don't want that one popped until we decide to exit the application. <br>  return !m_fQuit; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>// <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP_(BOOL) CApp::FQueryTerminate <br>( <br>  BOOL fPromptUser <br>) <br>{ <br>  // Disallow termination if modal dlg is up <br>  if (m_cmodal) <br>    { <br>    if (fPromptUser) <br>      MessageBox(NULL, "Please terminate Dlg before exiting", "Spruuids", <br>                 MB_TASKMODAL | MB_ICONEXCLAMATION | MB_OK); <br>    return FALSE; <br>    } <br> <br>  return AppEvt_FQueryTerminate(fPromptUser); <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>// <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP_(void) CApp::Terminate <br>( <br>  void <br>) <br>{ <br>  // Unregister component &amp; release all refs on Component Manager <br>  if (m_fRegisteredComp) <br>    { <br>    ASSERT(m_pmsgloop, "m_idcomp, but !m_pmsgloop"); <br>    BOOL f = m_pmsgloop-&gt;FRevokeComponent(m_idcomp); <br>    ASSERT(!f, "!f"); <br>    m_fRegisteredComp = FALSE; <br>    } <br> <br>  if (m_pmsgloop) <br>    { <br>    m_pmsgloop-&gt;Release(); <br>    m_pmsgloop = NULL; <br>    } <br> <br>  m_fQuit = TRUE; <br>} <br> <br> <br>//*************************************************************************** <br>// IDispatch Interface <br>//*************************************************************************** <br> <br>//--------------------------------------------------------------------------- <br>// Method needed by COleAuto, so it can implement IDispatch for us. <br>//--------------------------------------------------------------------------- <br>HRESULT CApp::GetTypeLibInfo <br>( <br>  HINSTANCE    *phinstOut, <br>  const GUID  **pplibidOut,  <br>  SHORT        *pwMajLib,  <br>  SHORT        *pwMinLib, <br>  const CLSID **ppclsidOut,  <br>  const IID   **ppiidOut,  <br>  ITypeLib   ***ppptlOut <br>) <br>{ <br>  *phinstOut  = g_hinst; <br>  *pplibidOut = &amp;LIBID_SPRUUIDS; <br>  *pwMajLib   = 1; <br>  *pwMinLib   = 0; <br>  *ppclsidOut = &amp;CLSID_SpruuidsApp; <br>  *ppiidOut   = &amp;IID_ISpruuidsApp; <br>  *ppptlOut   = &amp;g_ptlMain; <br>  return S_OK; <br>} <br> <br> <br>//*************************************************************************** <br>// SpruuidsApp Interface <br>//*************************************************************************** <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CApp::get_Application <br>( <br>  ISpruuidsApp** lppaReturn <br>) <br>{ <br>  return this-&gt;QueryInterface(IID_ISpruuidsApp, (void **)lppaReturn); <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CApp::get_Parent <br>( <br>  ISpruuidsApp** lppaReturn <br>) <br>{ <br>  return this-&gt;QueryInterface(IID_ISpruuidsApp, (void **)lppaReturn); <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CApp::Quit <br>( <br>  void  <br>) <br>{ <br>  m_fQuit = TRUE; <br> <br>  return S_OK; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>//  <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CApp::get_Game <br>( <br>  IGame** lppaReturn <br>) <br>{ <br>  return m_pgame-&gt;QueryInterface(IID_IGame, (void **)lppaReturn); <br>} <br> <br>   <br>//--- EOF ------------------------------------------------------------------- </code></pre>
<p>&nbsp;</p></body>
</HTML>
