<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SCORE.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context4594"></a>SCORE.CPP</h2>
<pre><code>//--------------------------------------------------------------------------- <br>// Score.cpp <br>//--------------------------------------------------------------------------- <br>// Score object to track score, # lives, level. <br>//--------------------------------------------------------------------------- <br>// (C) Copyright 1995-1997 by Microsoft Corporation.  All rights reserved. <br>// <br>// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF  <br>// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO  <br>// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A  <br>// PARTICULAR PURPOSE. <br>//--------------------------------------------------------------------------- <br> <br>#include "Main.h" <br>#pragma hdrstop <br>#include "Score.h" <br>#include "Spr.h" <br>#include "Game.h" <br>extern CGame *g_pgame; <br> <br> <br>//--------------------------------------------------------------------------- <br>// DEBUG info <br>//--------------------------------------------------------------------------- <br>SZTHISFILE <br> <br> <br>//--------------------------------------------------------------------------- <br>// Initialize score stuff <br>//--------------------------------------------------------------------------- <br>HRESULT CScore::s_hr = E_FAIL; <br> <br>HRESULT CScore::CreateScore <br>( <br>  HINSTANCE hinst,          // Needed to load bitmaps <br>  HWND      hwnd,           // hwnd on which to draw the Score, Level, # Lives <br>  HWND      hwndPS,         // hwnd of PlaySurface <br>  HWND      hwndStat,       // hwnd of Status Bar <br>  long      scoreFirst1Up,  // Score to first new life <br>  long      scoreSecond1Up, // Score to 2nd new life <br>  long      dscoreNext1Up,  // Score to next new life <br>  int       cship,          // Number lives to start <br>  IDBMP     idbmpShip,      // Bitmap for display of # lives <br>  IDBMP     idbmpPlus,      // Bitmap for "+" when out of room for # lives <br>  CScore  **ppscoreOut      // Return value: new score object <br>) <br>{ <br>  // Initialize output parameters <br>  *ppscoreOut = NULL; <br> <br>  // Validate required args, etc. <br>  if (!idbmpShip || !hwnd) <br>    return E_INVALIDARG; <br> <br>  *ppscoreOut = new CScore(hinst, hwnd, hwndPS, hwndStat, scoreFirst1Up, scoreSecond1Up, dscoreNext1Up, cship, idbmpShip, idbmpPlus); <br>  if (!ppscoreOut) <br>    return E_OUTOFMEMORY; <br>  if (s_hr) <br>    { <br>    delete *ppscoreOut; <br>    return s_hr; <br>    } <br> <br>  return S_OK; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>// Initialize score stuff <br>//--------------------------------------------------------------------------- <br>CScore::CScore <br>( <br>  HINSTANCE hinst,          // Needed to load bitmaps <br>  HWND      hwnd,           // hwnd on which to draw the Score, Level, # Lives <br>  HWND      hwndPS,         // hwnd of PlaySurface <br>  HWND      hwndStat,       // hwnd of Status Bar <br>  long      scoreFirst1Up,  // Score to first new life <br>  long      scoreSecond1Up, // Score to 2nd new life <br>  long      dscoreNext1Up,  // Score to next new life <br>  int       cshipStart,     // Number lives to start <br>  IDBMP     idbmpShip,      // Bitmap for display of # lives <br>  IDBMP     idbmpPlus       // Bitmap for "+" when out of room for # lives <br>) <br>{ <br>  BITMAP bmp; <br>  RECT   rectStat; <br> <br>  INIT_SIGNATURE(SIG_Score); <br> <br>  // Assume success <br>  s_hr = S_OK; <br> <br>  // Assume reasonable default values, if not supplied <br>  m_hinst          = hinst; <br>  m_hwnd           = hwnd; <br>  m_hwndStat       = hwndStat; <br>  m_hwndPS         = hwndPS; <br>  m_scoreFirst1Up  = scoreFirst1Up  ? scoreFirst1Up : 0x7fffffff; <br>  m_scoreSecond1Up = scoreSecond1Up ? scoreFirst1Up : 0x7fffffff; <br>  m_dscoreNext1Up  = dscoreNext1Up  ? dscoreNext1Up : 0x7fffffff; <br>  m_cshipStart     = cshipStart; <br> <br>  // Init rest of class <br>  m_hbmpShip  = NULL; <br>  m_hbmpPlus  = NULL; <br>  m_cyMax     = 0; <br>  m_cxShip    = 0; <br>  m_cyShip    = 0; <br>  m_cxPlus    = 0; <br>  m_cyPlus    = 0; <br>  // m_scoreNext1Up = m_scoreFirst1Up;    // Handled by NewGame() <br>  // m_score        = 0;                  // Handled by NewGame() <br>  // m_cship        = m_cshipStart;       // Handled by NewGame() <br>  // m_lvl          = 0;                  // Handled by NewGame() <br>  // m_rectScore    = 0;                  // Handled below <br>  // m_rectShip     = 0;                  // Handled below <br>  // m_rectLvl      = 0;                  // Handled below <br> <br>  // Finish initing the score object <br>  this-&gt;NewGame(); <br>  ASSERT(m_scoreNext1Up == m_scoreFirst1Up, "NewGame() not initing all"); <br>  ASSERT(!m_score, "NewGame() not initing all"); <br>  ASSERT(m_cship == cshipStart, "NewGame() not initing all"); <br>  ASSERT(!m_lvl, "NewGame() not initing all"); <br> <br>  // Load the bmp for the display of lives <br>  m_hbmpShip = LoadBitmap(hinst, MAKEINTRESOURCE(idbmpShip)); <br>  if (!m_hbmpShip) <br>    { <br>    s_hr = E_FAIL; <br>    return; <br>    } <br>  GetObject(m_hbmpShip, sizeof(bmp), (HGDIOBJ)&amp;bmp); <br>  m_cxPlus = m_cxShip = bmp.bmWidth; <br>  m_cyPlus = m_cyShip = m_cyMax = bmp.bmHeight; <br> <br>  // Load the bmp of the "+" for the display of lives <br>  if (idbmpPlus) <br>    { <br>    m_hbmpPlus = LoadBitmap(hinst, MAKEINTRESOURCE(idbmpPlus)); <br>    if (!m_hbmpPlus) <br>      { <br>      s_hr = E_FAIL; <br>      return; <br>      } <br>    GetObject(m_hbmpPlus, sizeof(bmp), (HGDIOBJ)&amp;bmp); <br>    m_cxPlus = bmp.bmWidth; <br>    m_cyPlus = bmp.bmHeight; <br>    if (m_cyPlus &gt; m_cyMax) <br>      m_cyMax = m_cyPlus; <br>    } <br> <br>  // Calc height of Text. <br>  // HACK: Cheat and use DrawText() with a "|" instead of getting TextMetrics... <br>  rectStat.top = 0; <br>  DrawText(GetDC(hwnd), "|", 1, &amp;rectStat, DT_NOCLIP|DT_NOPREFIX|DT_SINGLELINE|DT_CALCRECT); <br>  m_cyStat = rectStat.bottom; <br>  if (rectStat.bottom &gt; m_cyMax) <br>    m_cyMax = rectStat.bottom; <br> <br>  // Place PlaySurface correctly <br>  this-&gt;Size(372, 282); <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>// Given the size of the PlaySurface, calculate the size of the Dlg &amp; other <br>// components. <br>//--------------------------------------------------------------------------- <br>void CScore::Size <br>( <br>  int cx, <br>  int cy <br>) <br>{ <br>  RECT rect, rectCli; <br> <br>#define cBRD  (6) <br>  GetWindowRect(m_hwnd, &amp;rect); <br>  GetClientRect(m_hwnd, &amp;rectCli); <br>  ClientToScreen(m_hwnd, (LPPOINT)&amp;rectCli); <br>  ClientToScreen(m_hwnd, (LPPOINT)&amp;rectCli.right); <br>  MoveWindow(m_hwnd,     rect.left, <br>                         rect.top, <br>                         cx + (2 * cBRD) + (rect.right - rect.left) - (rectCli.right - rectCli.left), <br>                         cy + (3 * cBRD + m_cyMax + m_cyStat) + (rect.bottom - rect.top) - (rectCli.bottom - rectCli.top), <br>                         TRUE); <br>  GetClientRect(m_hwnd, &amp;rect); <br>  MoveWindow(m_hwndStat, cBRD, <br>                         rect.bottom - (m_cyStat + cBRD), <br>                         rect.right  - (2 * cBRD), <br>                         m_cyStat, TRUE); <br>  MoveWindow(m_hwndPS,   cBRD, <br>                         cBRD + m_cyMax, <br>                         rect.right  - (2 * cBRD), <br>                         rect.bottom - (3 * cBRD + m_cyMax + m_cyStat), TRUE); <br>  GetWindowRect(m_hwndPS, &amp;rect); <br>  ScreenToClient(m_hwnd, (LPPOINT)&amp;rect); <br>  ScreenToClient(m_hwnd, (LPPOINT)&amp;rect.right); <br>  rect.top    = 1; <br>  rect.bottom = m_cyMax + 4; <br>  m_rectScore = rect; <br>  m_rectShip  = rect; <br>  m_rectLvl   = rect; <br>  m_rectShip.right = m_rectLvl.left   = rect.left +  (rect.right - rect.left) / 3; <br>  m_rectLvl.right  = m_rectScore.left = rect.left + ((rect.right - rect.left) / 3 * 2); <br>  GetClientRect(m_hwndPS, &amp;rect); <br>  g_pgame-&gt;m_pdisp-&gt;m_cx = rect.right  - rect.left; <br>  g_pgame-&gt;m_pdisp-&gt;m_cy = rect.bottom - rect.top; <br>  InvalidateRect(m_hwnd,   NULL, TRUE); <br>  InvalidateRect(m_hwndPS, NULL, TRUE); <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>// Terminate score stuff <br>//--------------------------------------------------------------------------- <br>CScore::~CScore <br>( <br>  void <br>) <br>{ <br>  CHECK_SIGNATURE(SIG_Score); <br> <br>  if (m_hbmpShip) <br>    DeleteObject((HGDIOBJ)m_hbmpShip); <br>  if (m_hbmpPlus) <br>    DeleteObject((HGDIOBJ)m_hbmpPlus); <br> <br>  DESTROY_SIGNATURE(SIG_Score); <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>// Re-initialize score stuff for new game <br>//--------------------------------------------------------------------------- <br>void CScore::NewGame <br>( <br>  void <br>) <br>{ <br>  m_scoreNext1Up = m_scoreFirst1Up; <br>  m_score        = 0; <br>  m_cship        = m_cshipStart; <br>  m_lvl          = 0; <br> <br>  InvalidateRect(m_hwnd, NULL, TRUE); <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>// Paint score stuff: # 1Ups, current level, score <br>//--------------------------------------------------------------------------- <br>void CScore::Paint <br>( <br>  HDC hdc <br>) <br>{ <br>  char rgch[100]; <br>  int x, y; <br>  int i; <br>  extern HDC     g_hdcMem; <br>  extern HBITMAP g_hbmpStock; <br> <br>  SelectObject(g_hdcMem, m_hbmpShip); <br>  x = m_rectShip.left; <br>  y = m_rectShip.top + ((m_rectShip.bottom - m_rectShip.top - m_cyShip) &gt;&gt; 1); <br> <br>  // Draw the 1Ups w/a "+", if necessary <br>  for (i=1; i&lt;m_cship; i++) <br>    { <br>    BitBlt(hdc, x, y, m_cxShip, m_cyShip, g_hdcMem, 0, 0, SRCCOPY); <br>    x += m_cxShip + (m_cxShip &gt;&gt; 2); <br> <br>    // If we only have more 1Ups, but only room for the "+", draw the "+" <br>    if (x + m_cxShip + m_cxPlus &gt; m_rectShip.right &amp;&amp; m_hbmpPlus &amp;&amp; i+1&lt;m_cship) <br>      { <br>      y = m_rectShip.top + ((m_rectShip.bottom - m_rectShip.top - m_cyPlus) &gt;&gt; 1); <br>      SelectObject(g_hdcMem, m_hbmpPlus); <br>      BitBlt(hdc, x, y, m_cxPlus, m_cyPlus, g_hdcMem, 0, 0, SRCCOPY); <br>      break; <br>      } <br>    } <br>  SelectObject(g_hdcMem, g_hbmpStock); <br> <br>  SetBkMode(hdc, TRANSPARENT); <br>  wsprintf(rgch, "%ld", m_score); <br>  DrawText(hdc, rgch, -1, &amp;m_rectScore, DT_RIGHT|DT_NOCLIP|DT_NOPREFIX|DT_SINGLELINE|DT_VCENTER); <br> <br>  wsprintf(rgch, "%d", m_lvl); <br>  DrawText(hdc, rgch, -1, &amp;m_rectLvl,   DT_CENTER|DT_NOCLIP|DT_NOPREFIX|DT_SINGLELINE|DT_VCENTER); <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>// Change the score by the delta d. <br>//--------------------------------------------------------------------------- <br>void CScore::Add <br>( <br>  long d      // Change the score by this amount (signed) <br>) <br>{ <br>  m_score += d; <br>  if (m_score &lt; 0) <br>    m_score = 0; <br>  if (m_score &gt;= m_scoreNext1Up) <br>    { <br>    if (m_score &gt; m_scoreSecond1Up) <br>      m_scoreNext1Up += m_dscoreNext1Up; <br>    else <br>      m_scoreNext1Up = m_scoreSecond1Up; <br>    m_cship++; <br>    InvalidateRect(m_hwnd, &amp;m_rectShip, TRUE); <br>    g_pgame-&gt;m_pgameoa-&gt;FireNewShip(); <br>    } <br> <br>  InvalidateRect(m_hwnd, &amp;m_rectScore, TRUE); <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>// Called when pausing or unpausing <br>//--------------------------------------------------------------------------- <br>void CScore::SetStatusText <br>( <br>  const char *pszText <br>) <br>{ <br>  SetWindowText(m_hwndStat, pszText); <br>} <br> <br>//--- EOF ------------------------------------------------------------------- </code></pre>
<p>&nbsp;</p></body>
</HTML>
