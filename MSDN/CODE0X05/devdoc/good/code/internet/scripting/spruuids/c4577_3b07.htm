<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SPR.H</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context4597"></a>SPR.H</h2>
<pre><code>//--------------------------------------------------------------------------- <br>// Spr.h <br>//--------------------------------------------------------------------------- <br>// Sprite handler <br>//--------------------------------------------------------------------------- <br>// (C) Copyright 1992-1997 by Microsoft Corporation.  All rights reserved. <br>// <br>// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF  <br>// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO  <br>// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A  <br>// PARTICULAR PURPOSE. <br>//--------------------------------------------------------------------------- <br> <br> <br>//--------------------------------------------------------------------------- <br>// Constants <br>//--------------------------------------------------------------------------- <br>#define SPR_brdINLEFT       0x0001 <br>#define SPR_brdINTOP        0x0002 <br>#define SPR_brdINRIGHT      0x0004 <br>#define SPR_brdINBOTTOM     0x0008 <br>#define SPR_brdIN           0x000F <br>#define SPR_brdOUTLEFT      0x0010 <br>#define SPR_brdOUTTOP       0x0020 <br>#define SPR_brdOUTRIGHT     0x0040 <br>#define SPR_brdOUTBOTTOM    0x0080 <br>#define SPR_brdOUT          0x00F0 <br>#define SPR_brdALL          0x00FF <br>#define SPR_brdLEFT         0x0011 <br>#define SPR_brdTOP          0x0022 <br>#define SPR_brdRIGHT        0x0044 <br>#define SPR_brdBOTTOM       0x0088 <br> <br>#define MAS_X               0x0001 <br>#define MAS_Y               0x0002 <br>#define MAS_POS             0x0004 <br>#define MAS_VEL             0x0008 <br>#define MAS_ACCEL           0x0010 <br>#define MAS_RECIPDIST       0x0020 <br>#define MAS_REMEMBER        0x0080 <br> <br> <br>//--------------------------------------------------------------------------- <br>// Macros <br>//--------------------------------------------------------------------------- <br>#define tickOFSEC(sec)              ((int)(20*(sec))) <br>#define PuserDEREF(type, pspr)      ((type)((pspr)-&gt;m_bUser)) <br>#define SPRITEOFI(psprite)          ((CSprite *)(void *)(psprite)) <br> <br> <br>//--------------------------------------------------------------------------- <br>// Typedefs <br>//--------------------------------------------------------------------------- <br>class CDisplay; <br>class CSpriteClass; <br>class CSprite; <br>typedef UINT BRD; <br>typedef WORD IDBMP; <br>typedef struct tagIMG *PIMG; <br>typedef void (*PFNCOLLIDE)(CSprite *, CSprite *, int); <br>#define FLOAT float <br>#define FULLOFFLOAT(r8)   ((long)((r8) * (FLOAT)0x10000)) <br>#define FLOATOFFULL(i4)   ((FLOAT)(i4) / (FLOAT)0x10000) <br>#define FIXED(full, sub, super) \ <br>  union                         \ <br>    {                           \ <br>    long full;                  \ <br>    struct                      \ <br>      {                         \ <br>      USHORT sub;               \ <br>      SHORT super;              \ <br>      };                        \ <br>    } <br> <br> <br>//--------------------------------------------------------------------------- <br>// Image description <br>//--------------------------------------------------------------------------- <br>typedef struct tagIMG <br>  { <br>  int   iimgNext; <br>  int   x,  y; <br>  int   cx, cy; <br>  PIMG  pimgNext; <br>  } IMG; <br>#define iimgNONE      (-1) <br>#define iimgREMOVE    (-2) <br> <br> <br>//--------------------------------------------------------------------------- <br>// Display surface for sprites <br>//--------------------------------------------------------------------------- <br>class CDisplay <br>  { <br>  friend class CSprite; <br>  friend class CSpriteClass; <br> <br>public: <br>  CDisplay(HINSTANCE hinst, HWND hwnd, HDC hdc, IUnknown *pparent, PFNCOLLIDE pfncollide, int cimg, PIMG prgimg, UINT idbmp); <br>  ~CDisplay(void); <br> <br>  void DestroyAll(void); <br>  void Timer(void); <br>  void Paint(HDC hdc); <br>  void Refresh(void); <br>  void SetBackColor(COLORREF c); <br>  void FireCollide(CSprite *psprLowId, CSprite *psprHighId, int); <br> <br>  HINSTANCE  m_hinst; <br>  HWND       m_hwnd; <br>  HDC        m_hdc; <br>  int        m_cx, m_cy; <br>  PFNCOLLIDE m_pfnCollide;    // Routine to handle spr collisions <br>  CSprite   *m_psprFirst; <br>  CSprite   *m_psprLast; <br>  IUnknown  *m_punkParent;    // For get_Parent() on SpriteClass <br>  COLORREF   m_colorBack; <br>  HBRUSH    m_hbrushBack; <br> <br>protected: <br>  int       m_cimg; <br>  int       m_csc; <br>  PIMG      m_prgimg; <br>  IDBMP     m_idbmp; <br>  HBITMAP   m_hbmp; <br> <br>  // DEBUG info <br>  #define SIG_Display 'Disp' <br>  DECLARE_SIGNATURE(SIG_Display); <br>  }; <br> <br> <br>//--------------------------------------------------------------------------- <br>// Class description of different types of sprites <br>//--------------------------------------------------------------------------- <br>class CSpriteClass : public ISpriteClass, public COleAuto, <br>                     public IProvideClassInfo, public IConnectionPointContainer <br>  { <br>  friend class CDisplay; <br>  friend class CSprite; <br> <br>public: <br>  // *** Constructor/Destructor methods *** <br>  static HRESULT Create(CDisplay *pdisp, CSpriteClass **ppscOut); <br>  CSpriteClass(CDisplay *pdisp); <br>  ~CSpriteClass(void); <br>  void Close(void); <br> <br>  // *** Event methods *** <br>  void FireInit(  CSprite *pspr, VARIANT *pvarUser); <br>  void FireTick(  CSprite *pspr); <br>  void FireBorder(CSprite *pspr, BRD brd); <br>  void FireTerm(  CSprite *pspr); <br>  void FireLastTerm(void); <br> <br>  // *** IUnknown methods *** <br>  STDMETHOD(QueryInterface)(REFIID iid, void** ppvObjOut); <br>  STDMETHOD_(ULONG, AddRef)(void); <br>  STDMETHOD_(ULONG, Release)(void); <br>  inline IUnknown  *GetUnknown(void)  {return (ISpriteClass *)this;}; <br>  inline IDispatch *GetDispatch(void) {return (ISpriteClass *)this;}; <br> <br>  // *** IDispatch methods *** <br>  DECLARE_STANDARD_DISPATCH(); <br>  // Override required by COleAuto: <br>  virtual ITypeInfo **GetTinfoClsAddr(void) { return &amp;g_ptinfoClsSpriteClass; }; <br>  virtual ITypeInfo **GetTinfoIntAddr(void) { return &amp;g_ptinfoIntSpriteClass; }; <br>  virtual HRESULT GetTypeLibInfo(HINSTANCE *phinstOut, const GUID **pplibidOut,  <br>                                 SHORT *pwMajLibOut, SHORT *pwMinLibOut, <br>                                 const CLSID **ppclsidOut, const IID **ppiidOut, <br>                                 ITypeLib ***ppptlOut); <br>  virtual IDispatch *GetPrimary() {return this-&gt;GetDispatch(); }; <br> <br>  // *** ISpriteClass methods *** <br>  STDMETHOD(get_Application)(ISpruuidsApp** ppRet); <br>  STDMETHOD(get_Parent)(IGame** ppRet); <br>  STDMETHOD(CreateSprite)(int x, int y, VARIANT arg, ISprite** ppRet); <br>  STDMETHOD(get_Tag)(VARIANT* pRet); <br>  STDMETHOD(put_Tag)(VARIANT val); <br>  STDMETHOD(get_Image)(int* pRet); <br>  STDMETHOD(put_Image)(int val); <br>  STDMETHOD(get_Border)(int* pRet); <br>  STDMETHOD(put_Border)(int val); <br>  STDMETHOD(get_Collide)(int* pRet); <br>  STDMETHOD(put_Collide)(int val); <br>  STDMETHOD(get_MaximumVelocity)(float* pRet); <br>  STDMETHOD(put_MaximumVelocity)(float val); <br>  STDMETHOD(get_Friction)(float* pRet); <br>  STDMETHOD(put_Friction)(float val); <br>  STDMETHOD(get_MaximumAcceleration)(float* pRet); <br>  STDMETHOD(put_MaximumAcceleration)(float val); <br>  STDMETHOD(get_AccelerationFriction)(float* pRet); <br>  STDMETHOD(put_AccelerationFriction)(float val); <br>  STDMETHOD(get_SpriteCount)(int* pRet); <br> <br>  // *** IProvideClassInfo methods *** <br>  STDMETHOD(GetClassInfo)(ITypeInfo** pptinfoOut); <br>  // *** IProvideClassInfo2 methods *** <br>  STDMETHOD(GetGUID)(DWORD dwGuidKind, GUID* pGUID); <br> <br>  // *** IConnectionPointContainer methods *** <br>  STDMETHOD(EnumConnectionPoints)(LPENUMCONNECTIONPOINTS* ppEnum); <br>  STDMETHOD(FindConnectionPoint)(REFIID iid, LPCONNECTIONPOINT* ppCP); <br> <br>  class XCP : public IConnectionPoint <br>    { <br>    public: <br>    XCP(); <br>    void Close(void); <br> <br>    // *** IUnknown methods *** <br>    STDMETHOD(QueryInterface)(REFIID iid, void** ppvObjOut); <br>    STDMETHOD_(ULONG, AddRef)(void); <br>    STDMETHOD_(ULONG, Release)(void); <br>    inline IUnknown *GetUnknown(void) {return (IConnectionPoint *)this;}; <br> <br>    // *** IConnectionPoint methods *** <br>    STDMETHOD(GetConnectionInterface)(IID* piid); <br>    STDMETHOD(GetConnectionPointContainer)(IConnectionPointContainer** ppCPC); <br>    STDMETHOD(Advise)(IUnknown* punkSink, DWORD* pdwCookie); <br>    STDMETHOD(Unadvise)(DWORD dwCookie); <br>    STDMETHOD(EnumConnections)(LPENUMCONNECTIONS* ppEnum); <br> <br>    // *** Member Variables *** <br>    ULONG     m_cref; <br>#define SC_cADVISE 5 <br>    IDispatch *m_rgpdisp[SC_cADVISE];     // Array of pdisps to call. <br>    } m_cp; <br> <br>  // *** Member Variables *** <br>  CDisplay *m_pdisp; <br>  int       m_id; <br>  int       m_brd;         // Mask indicates which borders to check collision with <br>  int       m_maskCollide; // Mask indicates which other sprites can collide with <br>  int       m_iimg; <br>  int       m_cspr; <br>  VARIANT   m_varTag; <br>  FLOAT     m_friction; <br>  FLOAT     m_frictionAccel; <br>  BOOL      m_fFrictionAccel; <br>  ULONG     m_cref; <br>  FIXED(    m_vFullMax, m_vSubMax, m_vMax); <br>  FIXED(    m_aFullMax, m_aSubMax, m_aMax); <br> <br>private: <br>  // DEBUG info <br>  static HRESULT s_hr; <br>  #define SIG_SpriteClass 'SCls' <br>  DECLARE_SIGNATURE(SIG_SpriteClass); <br>  }; <br> <br> <br>//--------------------------------------------------------------------------- <br>// Definition of sprite <br>//--------------------------------------------------------------------------- <br>class CSprite : ISprite, COleAuto <br>  { <br>  friend class CDisplay; <br>  friend class CSpriteClass; <br> <br>public: <br>  // *** Constructor/Destructor methods *** <br>  CSprite(CSpriteClass *psc, int x, int y, CSprite *psprPrev, VARIANT *pvarUser); <br>  ~CSprite(); <br> <br>  // *** General Routines *** <br>  CSprite *PsprMutate(CSpriteClass *psc, VARIANT *pvarUser); <br>  void MarkFree(); <br>  BOOL MoveToFull(long xFull,  long yFull,  BOOL fCollide); <br>  BOOL MoveByFull(long dxFull, long dyFull, BOOL fCollide); <br>  BOOL DoMoveAt(CSprite *psprAt, float dMax, float scale, long flags, BOOL fCollide); <br> <br>  // *** IUnknown methods *** <br>  STDMETHOD(QueryInterface)(REFIID riid, void** ppvObj); <br>  STDMETHOD_(ULONG, AddRef)(void); <br>  STDMETHOD_(ULONG, Release)(void); <br>  inline IUnknown  *GetUnknown(void)  {return (ISprite *)this;}; <br>  inline IDispatch *GetDispatch(void) {return (ISprite *)this;}; <br> <br>  // *** IDispatch methods *** <br>  DECLARE_STANDARD_DISPATCH(); <br>  // Override required by COleAuto: <br>  virtual ITypeInfo **GetTinfoClsAddr(void) { return &amp;g_ptinfoClsSprite; }; <br>  virtual ITypeInfo **GetTinfoIntAddr(void) { return &amp;g_ptinfoIntSprite; }; <br>  virtual HRESULT GetTypeLibInfo(HINSTANCE *phinstOut, const GUID **pplibidOut,  <br>                                 SHORT *pwMajLibOut, SHORT *pwMinLibOut, <br>                                 const CLSID **ppclsidOut, const IID **ppiidOut, <br>                                 ITypeLib ***ppptlOut); <br>  virtual IDispatch *GetPrimary() {return this-&gt;GetDispatch(); }; <br> <br>  // *** ISprite methods *** <br>  STDMETHOD(get_Application)(ISpruuidsApp** ppRet); <br>  STDMETHOD(get_Parent)(ISpriteClass** ppRet); <br>  STDMETHOD(MoveTo)(FLOAT x, FLOAT y); <br>  STDMETHOD(MoveBy)(FLOAT dx, FLOAT dy); <br>  STDMETHOD(MoveAtSprite)(ISprite *sprite, FLOAT dMax, FLOAT scale, long flags); <br>  STDMETHOD(Remove)(void); <br>  STDMETHOD(Refresh)(void); <br>  STDMETHOD(IgnoreMove)(void); <br>  STDMETHOD(get_Left)(FLOAT* pRet); <br>  STDMETHOD(put_Left)(FLOAT val); <br>  STDMETHOD(get_Top)(FLOAT* pRet); <br>  STDMETHOD(put_Top)(FLOAT val); <br>  STDMETHOD(get_Vx)(FLOAT* pRet); <br>  STDMETHOD(put_Vx)(FLOAT val); <br>  STDMETHOD(get_Vy)(FLOAT* pRet); <br>  STDMETHOD(put_Vy)(FLOAT val); <br>  STDMETHOD(get_Ax)(FLOAT* pRet); <br>  STDMETHOD(put_Ax)(FLOAT val); <br>  STDMETHOD(get_Ay)(FLOAT* pRet); <br>  STDMETHOD(put_Ay)(FLOAT val); <br>  STDMETHOD(get_FrictionX)(FLOAT* pRet); <br>  STDMETHOD(put_FrictionX)(FLOAT val); <br>  STDMETHOD(get_FrictionY)(FLOAT* pRet); <br>  STDMETHOD(put_FrictionY)(FLOAT val); <br>  STDMETHOD(get_Image)(int* pRet); <br>  STDMETHOD(put_Image)(int val); <br>  STDMETHOD(get_TickMove)(int* pRet); <br>  STDMETHOD(put_TickMove)(int val); <br>  STDMETHOD(get_TickEvent)(int* pRet); <br>  STDMETHOD(put_TickEvent)(int val); <br>  STDMETHOD(get_Visible)(VARIANT_BOOL* pRet); <br>  STDMETHOD(put_Visible)(VARIANT_BOOL val); <br>  STDMETHOD(get_Tag)(VARIANT* pRet); <br>  STDMETHOD(put_Tag)(VARIANT val); <br>  STDMETHOD(get_Width)(int* pRet); <br>  STDMETHOD(get_Height)(int* pRet); <br> <br>  // *** Member Variables *** <br>  CDisplay     *m_pdisp; <br>  CSpriteClass *m_psc; <br>  CSprite      *m_psprNext; <br>  CSprite      *m_psprPrev; <br>  FIXED(       m_xFull,  m_xSub,  m_x); <br>  FIXED(       m_yFull,  m_ySub,  m_y); <br>  FIXED(       m_vxFull, m_vxSub, m_vx); <br>  FIXED(       m_vyFull, m_vySub, m_vy); <br>  FIXED(       m_axFull, m_axSub, m_ax); <br>  FIXED(       m_ayFull, m_aySub, m_ay); <br>  BOOL         m_fFriction; <br>  FLOAT        m_fx;    // Friction <br>  FLOAT        m_fy; <br>  long         m_tickEvt, m_tickEvtMax, m_tickMove, m_tickMoveMax; <br>  int          m_iimg; <br>  PIMG         m_pimg; <br>  VARIANT      m_varTag; <br> <br>  // Support for MoveAtSprite() <br>  CSprite     *m_psprAt; <br>  float        m_dMaxAt; <br>  float        m_scaleAt; <br>  long         m_flagsAt; <br> <br> <br>protected: <br>  // *** Internal Routines *** <br>  BOOL _FDraw(BOOL fCollide); <br>  void _Erase(); <br>  void _Link(); <br>  void _Unlink(BOOL fFireEvt); <br> <br>  // *** Member Variables *** <br>  BOOL    m_fNeedRefresh:1; <br>  BOOL    m_fFree:1; <br>  BOOL    m_fIgnoreMove:1; <br>  BOOL    m_fLinked:1; <br>  BOOL    m_fHidden;            // 2 = Implicitly hidden for _Init event <br>  ULONG   m_cref; <br> <br>  // DEBUG info <br>  #define SIG_Sprite 'Spr ' <br>  DECLARE_SIGNATURE(SIG_Sprite); <br>  }; <br> <br>//--- EOF ------------------------------------------------------------------- </code></pre>
<p>&nbsp;</p></body>
</HTML>
