<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>MSGLOOP.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context4588"></a>MSGLOOP.CPP</h2>
<pre><code>//--------------------------------------------------------------------------- <br>// MsgLoop.cpp <br>//--------------------------------------------------------------------------- <br>// Implementation of message loop for application.  Includes implementation <br>// of IOleComponentManager. <br>//--------------------------------------------------------------------------- <br>// (C) Copyright 1995-1997 by Microsoft Corporation.  All rights reserved. <br>// <br>// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF  <br>// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO  <br>// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A  <br>// PARTICULAR PURPOSE. <br>//--------------------------------------------------------------------------- <br> <br>#include "Main.h" <br>#pragma hdrstop <br>#include "MsgLoop.h" <br> <br> <br>//--------------------------------------------------------------------------- <br>// DEBUG info <br>//--------------------------------------------------------------------------- <br>SZTHISFILE <br> <br> <br>//--------------------------------------------------------------------------- <br>// <br>//--------------------------------------------------------------------------- <br>CMsgLoop::CMsgLoop <br>( <br>  HWND hwnd <br>) <br>  { <br>  INIT_SIGNATURE(SIG_MsgLoop); <br> <br>  for (int i=0; i&lt;cCOMP; i++) <br>    m_rgcomp[i].pcomp = NULL; <br> <br>  m_icompActive  = icompNIL; <br>  m_fInState     = FALSE; <br>  m_icompState   = icompNIL; <br>  m_uStateID     = 0; <br>  m_fScrptReset  = FALSE; <br>  m_fQuitting    = FALSE; <br>  m_hwnd         = hwnd; <br>  m_haccel       = NULL;     // Load accel table here <br>  m_icompMsgLoop =icompNIL; <br> <br>  m_cref        = 1; <br>  m_cMsgLoop    = 0; <br>  } <br> <br> <br>//--------------------------------------------------------------------------- <br>// <br>//--------------------------------------------------------------------------- <br>CMsgLoop::~CMsgLoop <br>( <br>  void <br>) <br>  { <br>  CHECK_SIGNATURE(SIG_MsgLoop); <br> <br>  for (int i=0; i&lt;cCOMP; i++) <br>    if (m_rgcomp[i].pcomp) <br>      { <br>      m_rgcomp[i].pcomp-&gt;Terminate(); <br>      RELEASEPTR(m_rgcomp[i].pcomp); <br>      } <br> <br>  DESTROY_SIGNATURE(SIG_MsgLoop); <br>  } <br> <br> <br>//*************************************************************************** <br>// IUnknown methods <br>//*************************************************************************** <br> <br>//--------------------------------------------------------------------------- <br>// <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CMsgLoop::QueryInterface <br>( <br>  REFIID   riid,  <br>  void   **ppvObj <br>) <br>  { <br>  *ppvObj = NULL; <br> <br>  if (riid == IID_IUnknown) <br>    *ppvObj = (LPVOID)(IUnknown *)(IOleComponentManager *)this; <br>  else if (riid == IID_IOleComponentManager) <br>    *ppvObj = (LPVOID)(IOleComponentManager *)this;  <br> <br>  if (*ppvObj)  <br>    { <br>    this-&gt;AddRef(); <br>    return S_OK; <br>    } <br>   <br>  return E_NOINTERFACE; <br>  } <br> <br> <br>//--------------------------------------------------------------------------- <br>// <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP_(ULONG) CMsgLoop::AddRef <br>( <br>  void <br>) <br>  { <br>  CHECK_SIGNATURE(SIG_MsgLoop); <br>  return ++m_cref; <br>  } <br> <br> <br>//--------------------------------------------------------------------------- <br>// <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP_(ULONG) CMsgLoop::Release <br>( <br>  void <br>) <br>  { <br>  CHECK_SIGNATURE(SIG_MsgLoop); <br>  if (--m_cref) <br>    return m_cref; <br> <br>  delete this; <br>  return 0; <br>  } <br> <br> <br> <br>//*************************************************************************** <br>// IOleComponentManager Methods <br>//*************************************************************************** <br> <br>//--------------------------------------------------------------------------- <br>// <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP CMsgLoop::QueryService <br>( <br>  REFGUID guidService,  <br>  REFIID  iid,  <br>  void  **ppvObjOut <br>)  <br>  { <br>  *ppvObjOut = NULL; <br>  return E_NOINTERFACE; <br>  } <br> <br> <br>//--------------------------------------------------------------------------- <br>// <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP_(BOOL) CMsgLoop::FRegisterComponent <br>( <br>  IOleComponent   *piComponent,  <br>  const CMGRRINFO *pcrinfo,  <br>  DWORD           *pdwCompIDOut <br>) <br>  { <br>  for (int i=0; i&lt;cCOMP; i++) <br>    if (!m_rgcomp[i].pcomp) <br>      { <br>      piComponent-&gt;AddRef(); <br>      m_rgcomp[i].pcomp = piComponent; <br>      *pdwCompIDOut = i; <br>      return TRUE; <br>      } <br> <br>  FAIL("Out of room!"); <br>  return FALSE; <br>  } <br> <br> <br>//--------------------------------------------------------------------------- <br>// <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP_(BOOL) CMsgLoop::FRevokeComponent <br>( <br>  DWORD icomp <br>) <br>  { <br>  ASSERT(m_rgcomp[icomp].pcomp, "Bogus icomp"); <br>  RELEASEPTR(m_rgcomp[icomp].pcomp); <br>  if (m_icompActive == icomp) <br>    m_icompActive = icompNIL; <br>  if (m_icompMsgLoop == icomp) <br>    m_icompMsgLoop = icompNIL; <br>  return TRUE; <br>  } <br> <br> <br>//--------------------------------------------------------------------------- <br>// <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP_(BOOL) CMsgLoop::FUpdateComponentRegistration <br>(  <br>  DWORD            dwComponentID,  <br>  const CMGRRINFO *pcrinfo <br>) <br>  { <br>  // Don't track info anyway, so pretend it worked: <br>  return TRUE; <br>  } <br> <br> <br>//--------------------------------------------------------------------------- <br>// <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP_(void) CMsgLoop::OnComponentActivate <br>( <br>  DWORD icomp <br>) <br>  { <br>  ASSERT(m_rgcomp[icomp].pcomp, "Bad icomp"); <br>  m_icompActive = icomp; <br>  return; <br>  } <br> <br> <br>//--------------------------------------------------------------------------- <br>// <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP_(BOOL) CMsgLoop::FSetTrackingComponent <br>( <br>  DWORD dwComponentID,  <br>  BOOL  fTrack <br>) <br>  { <br>  // UNDONE: Need to support <br>  return FALSE; <br>  } <br> <br> <br>//--------------------------------------------------------------------------- <br>// <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP_(void) CMsgLoop::OnComponentEnterState <br>( <br>  DWORD icomp, <br>  ULONG uStateID,  <br>  ULONG uContext,  <br>  ULONG cpicmExclude, <br>  IOleComponentManager **rgpicmExclude, <br>  DWORD dwReserved <br>) <br>  { <br>  ASSERT(m_rgcomp[icomp].pcomp, "Bad icomp"); <br>  ASSERT(uStateID==cmgrstateModal,  "Not modal state"); <br>  ASSERT(!m_fInState, "Nested modal states"); <br> <br>  m_icompState = icomp; <br>  m_fInState   = TRUE; <br>  m_uStateID   = uStateID; <br>  if (uStateID == cmgrstateModal) <br>    EnableWindow(m_hwnd, FALSE); <br>  } <br> <br> <br>//--------------------------------------------------------------------------- <br>// <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP_(BOOL) CMsgLoop::FOnComponentExitState <br>( <br>  DWORD icomp, <br>  ULONG uStateID, <br>  ULONG uContext, <br>  ULONG cpicmExclude, <br>  IOleComponentManager **rgpicmExclude <br>) <br>  { <br>  ASSERT(m_rgcomp[icomp].pcomp, "Bad icomp"); <br>  ASSERT(icomp==(DWORD)m_icompState, "icomp didn't own state"); <br>  ASSERT(uStateID==cmgrstateModal,  "Not modal state"); <br>  ASSERT(uStateID==m_uStateID, "non-matching modal states on pop"); <br>  ASSERT(m_fInState, "underflow of modal state"); <br> <br>  m_fInState   = FALSE; <br>  m_icompState = icompNIL; <br>  if (uStateID == cmgrstateModal) <br>    EnableWindow(m_hwnd, TRUE); <br>  return TRUE; <br>  } <br> <br> <br>//--------------------------------------------------------------------------- <br>// <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP_(BOOL) CMsgLoop::FInState <br>( <br>  ULONG uStateID, <br>  void *pvoid <br>) <br>  { <br>  return m_fInState &amp;&amp; uStateID==m_uStateID; <br>  } <br> <br> <br>//--------------------------------------------------------------------------- <br>// <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP_(BOOL) CMsgLoop::FContinueIdle <br>( <br>  void <br>) <br>  { <br>  return FALSE; <br>  } <br> <br> <br>//--------------------------------------------------------------------------- <br>// <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP_(BOOL) CMsgLoop::FPushMessageLoop <br>( <br>  DWORD icomp,  <br>  ULONG uReason,  <br>  void *pvLoopData <br>) <br>  { <br>  MessageLoop(icomp, uReason, pvLoopData); <br>  return TRUE; <br>  } <br> <br> <br>//--------------------------------------------------------------------------- <br>// <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP_(BOOL) CMsgLoop::FCreateSubComponentManager <br>( <br>  IUnknown *piunkOuter,  <br>  IUnknown *piunkServProv, <br>  REFIID    riid,  <br>  void    **ppvObj <br>) <br>  { <br>  ASSERT(!piunkOuter, "Don't support aggre. SubCompMgr"); <br>  HRESULT hr = this-&gt;QueryInterface(riid, ppvObj); <br>  return !FAILED(hr); <br>  } <br> <br> <br>//--------------------------------------------------------------------------- <br>// <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP_(BOOL) CMsgLoop::FGetParentComponentManager <br>( <br>  IOleComponentManager **ppicm <br>) <br>  { <br>  // UNDONE: Need to implement <br>  return FALSE; <br>  } <br> <br> <br>//--------------------------------------------------------------------------- <br>// <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP_(BOOL) CMsgLoop::FGetActiveComponent <br>( <br>  DWORD           dwReserved, <br>  IOleComponent **ppcompOut <br>) <br>  { <br>  // Do we have an active component? <br>  if (m_icompActive == icompNIL) <br>    { <br>    *ppcompOut = NULL; <br>    return FALSE; <br>    } <br> <br>  // Yes, return it <br>  *ppcompOut = m_rgcomp[m_icompActive].pcomp; <br>  (*ppcompOut)-&gt;AddRef();       // for *ppcompOut <br>  return TRUE; <br>  } <br> <br> <br> <br>//*************************************************************************** <br>// Message Loop Implementation <br>//*************************************************************************** <br> <br>//--------------------------------------------------------------------------- <br>// This pushes a new message loop. <br>//--------------------------------------------------------------------------- <br>void CMsgLoop::MessageLoop <br>( <br>  DWORD icomp, <br>  ULONG uReason,  <br>  void *pvLoopData <br>) <br>  { <br>  BOOL  fExitLoop = FALSE; <br> <br>  m_cMsgLoop++; <br> <br>  while (!fExitLoop)  <br>    fExitLoop = PumpMessage(icomp, uReason, pvLoopData); <br> <br>  m_cMsgLoop--; <br> <br>  if (!m_cMsgLoop) <br>    m_fScrptReset = FALSE; <br>  } <br> <br> <br>//--------------------------------------------------------------------------- <br>// This processes one message. <br>// Returns TRUE if it is time to exit the current message loop. <br>//--------------------------------------------------------------------------- <br>BOOL CMsgLoop::PumpMessage <br>( <br>  DWORD icomp, <br>  ULONG uReason,  <br>  void *pvLoopData <br>) <br>  { <br>  BOOL fExitLoop = FALSE; <br>  BOOL fMsg; <br>  MSG  msg; <br> <br>  fMsg = PeekMessage(&amp;msg, NULL, NULL, NULL, PM_REMOVE); <br>  if (fMsg)  <br>    { <br>    if (msg.message == WM_QUIT) <br>      { <br>      // Since we're not really an app, re-post the WM_QUIT message, until <br>      // we can pop any msgloops we've pushed. <br>      if (m_cMsgLoop) <br>       PostQuitMessage(msg.wParam); <br>      return TRUE; <br>      } <br>    else <br>      ProcessMessage(&amp;msg); <br>    } <br> <br>  if (m_fScrptReset) <br>    return TRUE; <br> <br>  // A Component told us to push this message loop, and so we <br>  // ask them whether it's time yet to exit the loop <br>  fExitLoop = !m_rgcomp[icomp].pcomp-&gt;FContinueMessageLoop(uReason, pvLoopData); <br> <br>  if (!fMsg &amp;&amp; !fExitLoop)  <br>    { <br>    // There weren't any messages and we don't need to exit this message <br>    // loop yet.  Therefore, now is the right time to do idle processing <br>    DoIdleProcessing(); <br>    WaitMessage(); <br>    } <br> <br>  return fExitLoop; <br>  } <br> <br> <br>//--------------------------------------------------------------------------- <br>// This processes one message. <br>//--------------------------------------------------------------------------- <br>void CMsgLoop::ProcessMessage <br>( <br>  MSG  *pmsg <br>) <br>  {     <br>  // When a component is active give it a chance to translate <br>  // its accelerators. <br>  if (m_icompActive != icompNIL) <br>    { <br>    if (!m_rgcomp[m_icompActive].pcomp-&gt;FPreTranslateMessage(pmsg)) <br>      { <br>      TranslateMessage(pmsg);    // Translates virtual key codes   <br>      DispatchMessage(pmsg);    // Dispatches message to window  <br>      } <br>    }  <br>  else  <br>    { <br>    if (!TranslateAccelerator(m_hwnd, m_haccel, pmsg)) <br>      { <br>      TranslateMessage(pmsg); // Translates virtual key codes   <br>      DispatchMessage(pmsg);  // Dispatches message to window  <br>      } <br>    } <br>  } <br> <br> <br>//--------------------------------------------------------------------------- <br>// This is called at idle time. <br>//--------------------------------------------------------------------------- <br>void CMsgLoop::DoIdleProcessing <br>( <br>  void <br>) <br>  { <br>  MSG  msg; <br>  BOOL fContinue = TRUE; <br> <br>  while (fContinue &amp;&amp; !PeekMessage(&amp;msg, NULL, NULL, NULL, PM_NOREMOVE)) <br>    { <br>    fContinue = DoIdle(); <br>    } <br>  } <br> <br> <br>//--------------------------------------------------------------------------- <br>// <br>//--------------------------------------------------------------------------- <br>BOOL CMsgLoop::DoIdle <br>( <br>  void <br>) <br>  { <br>  int  i; <br>  BOOL fDidWork = FALSE; <br> <br>  // if we have periodic idle tasks that to be done,  <br>  // do them and return TRUE. <br>  for (i=0; i&lt;cCOMP; i++) <br>    { <br>    if (m_rgcomp[i].pcomp) <br>      if (m_rgcomp[i].pcomp-&gt;FDoIdle(cmgridlefPeriodic)) <br>        fDidWork = TRUE; <br>    if (fDidWork) <br>      return TRUE; <br>    } <br> <br>  // if any high priority idle tasks need to be done, <br>  // do it, and return TRUE. <br>  for (i=0; i&lt;cCOMP; i++) <br>    { <br>    if (m_rgcomp[i].pcomp) <br>      if (m_rgcomp[i].pcomp-&gt;FDoIdle(cmgridlefPriority)) <br>        fDidWork = TRUE; <br>    if (fDidWork) <br>      return TRUE; <br>    } <br> <br>  // if any lower priority idle tasks need to be done, <br>  // do it, and return TRUE. <br>  for (i=0; i&lt;cCOMP; i++) <br>    { <br>    if (m_rgcomp[i].pcomp) <br>      if (m_rgcomp[i].pcomp-&gt;FDoIdle(cmgridlefNonPeriodic)) <br>        fDidWork = TRUE; <br>    if (fDidWork) <br>      return TRUE; <br>    } <br> <br>  return FALSE; <br>  } <br> <br>//--- EOF ------------------------------------------------------------------- </code></pre>
<p>&nbsp;</p></body>
</HTML>
