<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Example Code Using CryptDecryptMessage</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h3><a name="_crypto2_example_code_using_cryptdecryptmessage"></a>Example Code Using CryptDecryptMessage</h3>
<p>
The following example code implements the procedure just presented. Comments show which code fragments pertain to each step in the procedure. The details of the functions and structures can be found in <a href="sca_4t83.htm">Simplified Message Functions</a> and <a href="structs_2ylv.htm">Data Structures</a>. </p>
<pre><code>//-------------------------------------------------------------
//-------------------------------------------------------------
// EXAMPLE CODE FOR DECRYPTING AN ENCRYPTED MESSAGE USING
// CryptDecryptMessage().
//-------------------------------------------------------------
//-------------------------------------------------------------

//-------------------------------------------------------------
// Get a pointer to the encrypted message. Use the pointers,
// pbEncryptedBlob and cbEncryptedBlob, retrieved in the 
// previous code segment (Step 1).
//-------------------------------------------------------------

// View the encrypted blob.

char*    EncryptedString = new char[(cbEncryptedBlob *2) +1];

// Call a routine to convert the byte blob to ASCII HEX. See the
// function code at the end of this code fragment.
BytesToStr(cbEncryptedBlob, pbEncryptedBlob, EncryptedString);

// Show the string.
AfxMessageBox(EncryptedString);


//-------------------------------------------------------------
// Open the system certificate store (Step 2).
//-------------------------------------------------------------
//HCERTSTORE        hStoreHandle = NULL;

// Call CertOpenSystemStore to open the store.
hStoreHandle = CertOpenSystemStore(hCryptProv, "MY");
if (!hStoreHandle)
{
    AfxMessageBox( "Error Getting Store Handle");
    return;
}

// If the call was successful, the certificate store handle now
// resides at the location pointed to by hStoreHandle.

// Create a "CertStoreArray" (Step 3)
HCERTSTORE        CertStoreArray[] = {hStoreHandle};

//-------------------------------------------------------------
// Initialize the CRYPT_DECRYPT_MESSAGE_PARA structure. (Step 4).
//-------------------------------------------------------------
CRYPT_DECRYPT_MESSAGE_PARA        DecryptParams;
DWORD    DecryptParamsSize = sizeof(DecryptParams);
memset(&amp;DecryptParams, 0, DecryptParamsSize);

DecryptParams.cbSize = DecryptParamsSize;
DecryptParams.dwMsgAndCertEncodingType = MY_ENCODING_TYPE;
DecryptParams.cCertStore = 1;
DecryptParams.rghCertStore = CertStoreArray;

//-------------------------------------------------------------
// Decrypt the message data (Step 5).
//-------------------------------------------------------------
DWORD        cbDecryptedMessage;

// Call CryptDecryptMessage to get the returned data size.
fReturn = CryptDecryptMessage(
          &amp;DecryptParams,
          pbEncryptedBlob,
          cbEncryptedBlob,
          NULL,
          &amp;cbDecryptedMessage,
          NULL);
if(FALSE == fReturn)
    AfxMessageBox( "Error Getting Decrypted Message Size");

// Allocate memory for the returned decrypted data.
BYTE*    pbDecryptedMessage;

pbDecryptedMessage = (BYTE*)malloc(cbDecryptedMessage);
if(!pbDecryptedMessage)
    AfxMessageBox("Memory Allocation Error While Decrypting");

// Call CryptDecryptMessage to decrypt the data.
fReturn = CryptDecryptMessage(
          &amp;DecryptParams,
          pbEncryptedBlob,
          cbEncryptedBlob,
          pbDecryptedMessage,
          &amp;cbDecryptedMessage,
          NULL);
LPSTR    DecryptedString = (LPSTR) pbDecryptedMessage;

if(FALSE == fReturn)
    AfxMessageBox("Error Decrypting The Data");
else
{
    AfxMessageBox("Data Decrypted Successfully");
    AfxMessageBox(DecryptedString);    // Display the string.
}

// If the function call succeeded, the decrypted message now
// resides at the location pointed to by pbDecryptedMessage.

//-------------------------------------------------------------
// Clean up memory.
//-------------------------------------------------------------

fReturn = CertCloseStore(
          hStoreHandle, 
          CERT_CLOSE_STORE_CHECK_FLAG);
if(FALSE == fReturn)
    AfxMessageBox("Store Closed After Decryption - \n"
                  "Not All Certs or CRLs Were Freed");

free(pbEncryptedBlob);
free(pbDecryptedMessage);
delete [] EncryptedString;


//************************************************************
// BytesToStr() - Converts the bytes into CHAR hex. Needs
// (cb * 2 + 1) * sizeof(CHAR) bytes of space in sz.
//************************************************************
static void BytesToStr(DWORD cb, void* pv, LPSTR sz)
{
    
    BYTE* pb = (BYTE*) pv;
    for (DWORD i = 0; i&lt;cb; i++)
    {
        int b;

        b = (*pb &amp; 0xF0) &gt;&gt; 4;
        *sz++ = (b &lt;= 9) ? b + '0' : (b - 10) + 'A';
        b = *pb &amp; 0x0F;
        *sz++ = (b &lt;= 9) ? b + '0' : (b - 10) + 'A';
        
        pb++;
    }
    *sz++ = 0;
}
 </code></pre>
<p>
</p>
<p>&nbsp;</p></body>
</HTML>
