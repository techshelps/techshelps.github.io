<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Certificate Request Example Code</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h2><a name="_crypto2_certificate_request_example_code"></a>Certificate Request Example Code</h2>
<p>
The following example code demonstrates the procedure outlined in the previous section. This example code creates a simple certificate request with one signer, a single RDN attribute, and no general attributes.</p>
<pre><code>// This example code demonstrates how to create and encode a 
// certificate request. 

#include &lt;stdio.h&gt;
#include &lt;windows.h&gt;
#include "wincrypt.h"
#define CERT_SUBJECT_NAME "Elizabeth Jackson"
#define MY_ENCODING_TYPE  (PKCS_7_ASN_ENCODING | X509_ASN_ENCODING)
void BytesToStr(DWORD cb, void* pv, LPSTR sz);
void main(void)
{
// Declare and initialize  

// A CERT_RDN_ATTR array.
// In this code, only one array element is used.

  CERT_RDN_ATTR rgNameAttr[] = {"2.5.4.3",  // pszObjId 
  CERT_RDN_PRINTABLE_STRING,                // dwValueType
    strlen(CERT_SUBJECT_NAME),              // value.cbData
    (BYTE*)CERT_SUBJECT_NAME};              // value.pbData

// A CERT_RDN array.
// In this code, only one array element is used.

CERT_RDN rgRDN[] = {
    1,                 // rgRDN[0].cRDNAttr
    &amp;rgNameAttr[0]};   // rgRDN[0].rgRDNAttr

// A CERT_NAME_INFO structure.

CERT_NAME_INFO Name = {
       1,                  // Name.cRDN
       rgRDN};             // Name.rgRDN

// Other variables and structures.

CERT_REQUEST_INFO    CertReqInfo;
CERT_NAME_BLOB       SubjNameBlob;
DWORD cbNameEncoded = 0;
BYTE* pbNameEncoded;
HCRYPTPROV hCryptProv = NULL; // Handle returned here
DWORD    cbPublicKeyInfo;
CERT_PUBLIC_KEY_INFO* pbPublicKeyInfo;
DWORD    cbEncodedCertReqSize;
CRYPT_OBJID_BLOB Parameters;
CRYPT_ALGORITHM_IDENTIFIER SigAlg;
BYTE* pbSignedEncodedCertReq;
char*    pSignedEncodedCertReqBlob;
BOOL fReturn = FALSE;

CryptEncodeObject(
    MY_ENCODING_TYPE,     // Encoding type
    X509_NAME,            // Struct type
    &amp;Name,                // Address of CERT_NAME_INFO struct.
    NULL,                 // pbEncoded
    &amp;cbNameEncoded);      // pbEncoded size

if(cbNameEncoded&lt;1)
{
    printf("First call to CryptEncodeObject Failed\n");
    goto handle_error;
}

if(!(pbNameEncoded = (BYTE*)malloc(cbNameEncoded)))
{
    printf("pbNamencoded Malloc Failed\n");
    goto handle_error;
}

if(!CryptEncodeObject(
        MY_ENCODING_TYPE,    // Encoding type
        X509_NAME,           // Struct type
        &amp;Name,               // Address of CERT_NAME_INFO struct.
        pbNameEncoded,       // pbEncoded
        &amp;cbNameEncoded))     // pbEncoded size
{
    printf("Second call to CryptEncodeObject Failed\n");
    free(pbNameEncoded);
    goto handle_error;
}

// Set the Subject member of CertReqInfo to point to 
// a CERT_NAME_INFO structure that 
// has been initialized with the data from step 5.

SubjNameBlob.cbData = cbNameEncoded;
SubjNameBlob.pbData = pbNameEncoded;
CertReqInfo.Subject = SubjNameBlob;

// Generate custom information.  This step is not
// implemented in this code.

CertReqInfo.cAttribute = 0;
CertReqInfo.rgAttribute = NULL;
CertReqInfo.dwVersion = CERT_REQUEST_V1;

// Call CryptExportPublicKeyInfo to return an initialized
// CERT_PUBLIC_KEY_INFO structure.
// #1  Get a cryptographic provider.

if(!(CryptAcquireContext(
    &amp;hCryptProv,        // Address for handle to be returned.
    NULL,               // Use the current user's logon name.
    NULL,               // Use the default provider.
    PROV_RSA_FULL,      // Need to do both encrypt &amp; sign.
    NULL)))             // No flags needed.
{
    printf("Call to CryptAcquireContextFailed\n");
    free(pbNameEncoded);
    goto handle_error;
}

// Call CryptExportPublicKeyInfo to get the size of the returned
// information.

if(!(CryptExportPublicKeyInfo(
          hCryptProv,            // Provider handle
          AT_SIGNATURE,          // Key spec
          MY_ENCODING_TYPE,      // Encoding type
          NULL,                  // pbPublicKeyInfo
          &amp;cbPublicKeyInfo)))     // Size of PublicKeyInfo
{
    printf("First call to CryptExportPublicKeyInfo failed\n");
    free(pbNameEncoded);
    goto handle_error;
}

// Allocate the necessary memory.
if(!(pbPublicKeyInfo = 
   (CERT_PUBLIC_KEY_INFO*)malloc(cbPublicKeyInfo)))
{
    printf("pbPublicKeyInfo Malloc Failed.\n");
    free(pbNameEncoded);
    goto handle_error;
}

// Call CryptExportPublicKeyInfo to get pbPublicKeyInfo.
if(!(CryptExportPublicKeyInfo(
          hCryptProv,            // Provider handle
          AT_SIGNATURE,          // Key spec
          MY_ENCODING_TYPE,      // Encoding type
          pbPublicKeyInfo,       // pbPublicKeyInfo
          &amp;cbPublicKeyInfo)))    // Size of PublicKeyInfo
{
    printf("Second call to CryptExportPublicKeyInfo failed.\n");
    free(pbNameEncoded);
    free(pbPublicKeyInfo);
    goto handle_error;
}
// Set the SubjectPublicKeyInfo member of the 
// CERT_REQUEST_INFO structure to point to the CERT_PUBLIC_KEY_INFO 
// structure created.

CertReqInfo.SubjectPublicKeyInfo = *pbPublicKeyInfo;

// Call CryptSignAndEncodeCertificate to encode, sign,
// and re-encode the CERT_REQUEST_INFO structure and the data 
// pointed to by it.
//---------------------------------------------------------------

memset(&amp;Parameters, 0, sizeof(Parameters));
SigAlg.pszObjId = szOID_OIWSEC_sha1RSASign;
SigAlg.Parameters = Parameters;

// Call CryptSignAndEncodeCertificate to get the size of the
// returned blob.
if(!(CryptSignAndEncodeCertificate(
          hCryptProv,                      // Crypto provider
          AT_SIGNATURE,                    // Key spec.
          MY_ENCODING_TYPE,                // Encoding type
          X509_CERT_REQUEST_TO_BE_SIGNED,  // Struct type
          &amp;CertReqInfo,                    // Struct info
          &amp;SigAlg,                         // Signature algorithm
          NULL,                            // Not used
          NULL,                            // pbSignedEncodedCertReq
          &amp;cbEncodedCertReqSize)))         // Size of cert req
{
    printf("First call to CryptSignAndEncodeCertificate\n ");
    printf("failed.\n");
    free(pbNameEncoded);
    free(pbPublicKeyInfo);
    goto handle_error;
}

// Malloc the necessary memory.
pbSignedEncodedCertReq = (BYTE*)malloc(cbEncodedCertReqSize);
if(!pbSignedEncodedCertReq)
{
    printf("pbSignedEncodedCertReq Malloc Failed\n");
    free(pbNameEncoded);
    free(pbPublicKeyInfo);
    goto handle_error;
}
// Call CryptSignAndEncodeCertificate to get the 
// returned blob.
if(!(CryptSignAndEncodeCertificate(
          hCryptProv,                     // Crypto provider
          AT_SIGNATURE,                   // Key spec.
          MY_ENCODING_TYPE,               // Encoding type
          X509_CERT_REQUEST_TO_BE_SIGNED, // Struct type
          &amp;CertReqInfo,                   // Struct info        
          &amp;SigAlg,                        // Signature algorithm
          NULL,                           // Not used
          pbSignedEncodedCertReq,         // Pointer
          &amp;cbEncodedCertReqSize)))        // Sizeif(!fReturn)
{
    printf("Second call to CryptSignAndEncodeCertificate\n ");
    printf("failed.\n");
    free(pbNameEncoded);
    free(pbPublicKeyInfo);
    free(pbSignedEncodedCertReq);
    goto handle_error;
}
// View the signed and encoded certificate request blob.

pSignedEncodedCertReqBlob = 
                        new char[(cbEncodedCertReqSize *2) +1];
// Call routine to convert the byte blob to ASCII HEX. See the 
// subroutine that follows this code segment.
BytesToStr(cbEncodedCertReqSize,
            pbSignedEncodedCertReq,
            pSignedEncodedCertReqBlob);
// Show the unicode string.
printf("%S\n",pSignedEncodedCertReqBlob);

//---------------------------------------------------------------
// Free memory.
//---------------------------------------------------------------
free(pbNameEncoded);
free(pbPublicKeyInfo);
free(pbSignedEncodedCertReq);
handle_error:
printf("have reached the end.\n");
}


//************************************************************
// BytesToStr() - Converts the bytes into CHAR hex. Needs
// (cb * 2 + 1) * sizeof(CHAR) bytes of space in sz.
//************************************************************
void BytesToStr(DWORD cb, void* pv, LPSTR sz)
{
    
    BYTE* pb = (BYTE*) pv;
int b;
DWORD i;
    for (i = 0; i&lt;cb; i++)
    {
     b = (*pb &amp; 0xF0) &gt;&gt; 4;
        *sz++ = (b &lt;= 9) ? b + '0' : (b - 10) + 'A';
        b = *pb &amp; 0x0F;
        *sz++ = (b &lt;= 9) ? b + '0' : (b - 10) + 'A';
        
        pb++;
    }
    *sz++ = 0;
}
 </code></pre>
<p>&nbsp;</p></body>
</HTML>
