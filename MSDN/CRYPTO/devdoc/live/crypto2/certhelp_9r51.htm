<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CertStrToName</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_crypto2_certstrtoname"></a>CertStrToName</h1>
<p>
The <b>CertStrToName</b> function converts a NULL-terminated X500 string to an encoded certificate name. The input string is expected to be formatted the same as the output from <a href="certhelp_73ea.htm"><b>CertNameToStr</b></a>.</p>
<pre><code><b>#include &lt;wincrypt.h&gt;
BOOL WINAPI CertStrToName(
  DWORD</b><i> dwCertEncodingType</i><b>,   </b>// in
<b>  LPCTSTR</b><i> pszX500</i><b>,            </b>// in
<b>  DWORD</b><i> dwStrType</i><b>,            </b>// in
<b>  void*</b><i> pvReserved</i><b>,           </b>// in, optional
<b>  BYTE*</b><i> pbEncoded</i><b>,            </b>// out
<b>  DWORD*</b><i> pcbEncoded</i><b>,          </b>// in/out
<b>  LPCTSTR*</b><i> ppszError          </i>// out, optional
<b>);</b>
 </code></pre>
<h4>Parameters</h4>
<dl>
<dt>
<i>dwCertEncodingType</i></dt>
<dd>
The type of encoding used on the certificate. Currently defined certificate encoding types are shown in the following table:
<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=49%>Encoding type</th>
<th align=left width=51%>Value</th>
</tr>
<tr valign=top>
<td width=49%>X509_ASN_ENCODING</td>
<td width=51%>0x00000001</td>
</tr>
</table><br>

</dd>
<dt>
<i>pszX500</i></dt>
<dd>
A pointer to the zero-terminated X500 string to be converted.</dd>
<dt>
<i>dwStrType</i></dt>
<dd>
The type of the input string. The possible types are as follows.
<p>
When <i>dwStrType</i> is set to 0, CERT_OID_NAME_STR or CERT_X500_NAME_STR, the input is allowed to contain either a case insensitive X500 key (CN=), case insensitive "OID." prefixed object identifier (OID.1.2.3.4.5.6=) or an object identifier (1.2.3.4=).

<p>
If no flags are combined with a bitwise OR operation into <i>dwStrType</i>, then, the input is allowed to contain "," or ";" as RDN separators and "+" as the multiple RDN value separator. Quoting is supported. A quote may be included in a quoted value by double quoting, for example (CN="Joe ""Cool"""). A value starting with a "#" is treated as ascii hex and converted to a CERT_RDN_OCTET_STRING. Embedded whitespace is skipped (1.2.3 = # AB CD 01 is the same as 1.2.3=#ABCD01).

<p>
Whitespace surrounding the keys, object identifiers and values are removed.

<dl>
<dt>
CERT_NAME_STR_COMMA_FLAG</dt>
<dd>
This flag can be combined with a bitwise OR operation into <i>dwStrType</i> to only allow the "," as the RDN separator.</dd>
<dt>
CERT_NAME_STR_SEMICOLON_FLAG</dt>
<dd>
This flag can be combined with a bitwise OR operation into <i>dwStrType</i> to only allow the ";" as the RDN separator.</dd>
<dt>
CERT_NAME_STR_CRLF_FLAG</dt>
<dd>
This flag can be combined with a bitwise OR operation into <i>dwStrType</i> to only allow "\r" or "\n" as the RDN separator.</dd>
<dt>
CERT_NAME_STR_NO_PLUS_FLAG</dt>
<dd>
This flag can be combined with a bitwise OR operation into <i>dwStrType</i> to ignore "+" as a separator and not allow multiple values per RDN.</dd>
<dt>
CERT_NAME_STR_NO_QUOTING_FLAG</dt>
<dd>
This flag can be combined with a bitwise OR operation into <i>dwStrType</i> to inhibit quoting.</dd>
<dt>
CERT_NAME_STR_DISABLE_IE4_UTF8_FLAG</dt>
<dd>
By default, CERT_RDN_T61_STRING encoded values are initially decoded as UTF8. If the UTF8 decoding fails, then the value is decoded as 8 bit characters. This flag can be combined with a bitwise OR operation into <i>dwStrType</i> to skip the initial attempt to decode as UTF8.</dd>
<dt>
CERT_SIMPLE_NAME_STR</dt>
<dd>
This type isn't supported since it doesn't contain any (CN=) type of information.</dd>
<dt>
CERT_NAME_STR_REVERSE-FLAG</dt>
<dd>
This flag can be combined with a bitwise OR operation into <i>dwStrType</i> to specify that the order of the RDNs is to be reversed after converting from the string and before encoding. See <b>CertNameToStr</b> for a demonstration of this flags usage.</dd>
</dl>

<p>
The following X500 Keys are supported:

<table cellspacing=4 cols=3>
<tr valign=top>
<th align=left width=18%>Key</th>
<th align=left width=58%>Object Identifier</th>
<th align=left width=24%>RDN Value Type(s)</th>
</tr>
<tr valign=top>
<td width=18%>CN </td>
<td width=58%>szOID_COMMON_NAME</td>
<td width=24%>Printable, T61</td>
</tr>
<tr valign=top>
<td width=18%>L</td>
<td width=58%>szOID_LOCALITY_NAME</td>
<td width=24%>Printable, T61</td>
</tr>
<tr valign=top>
<td width=18%>O</td>
<td width=58%>szOID_ORGANIZATION_NAME</td>
<td width=24%>Printable, T61</td>
</tr>
<tr valign=top>
<td width=18%>OU</td>
<td width=58%>szOID_ORGANIZATIONAL_UNIT_NAME</td>
<td width=24%>Printable, T61</td>
</tr>
<tr valign=top>
<td width=18%>Email</td>
<td width=58%>szOID_RSA_emailAddr</td>
<td width=24%>Only IA5</td>
</tr>
<tr valign=top>
<td width=18%>C</td>
<td width=58%>szOID_COUNTRY_NAME</td>
<td width=24%>Only Printable</td>
</tr>
<tr valign=top>
<td width=18%>S</td>
<td width=58%>szOID_STATE_OR_PROVINCE_NAME</td>
<td width=24%>Printable, T61</td>
</tr>
<tr valign=top>
<td width=18%>ST</td>
<td width=58%>szOID_STATE_OR_PROVINCE_NAME</td>
<td width=24%>Printable, T61</td>
</tr>
<tr valign=top>
<td width=18%>STREET</td>
<td width=58%>szOID_STREET_ADDRESS</td>
<td width=24%>Printable, T61</td>
</tr>
<tr valign=top>
<td width=18%>T</td>
<td width=58%>szOID_TITLE</td>
<td width=24%>Printable, T61</td>
</tr>
<tr valign=top>
<td width=18%>Title</td>
<td width=58%>szOID_TITLE</td>
<td width=24%>Printable, T61</td>
</tr>
<tr valign=top>
<td width=18%>G</td>
<td width=58%>szOID_GIVEN_NAME</td>
<td width=24%>Printable, T61</td>
</tr>
<tr valign=top>
<td width=18%>GivenName</td>
<td width=58%>szOID_GIVEN_NAME</td>
<td width=24%>Printable, T61</td>
</tr>
<tr valign=top>
<td width=18%>I</td>
<td width=58%>szOID_INITIALS</td>
<td width=24%>Printable, T61</td>
</tr>
<tr valign=top>
<td width=18%>Initials</td>
<td width=58%>szOID_INITIALS</td>
<td width=24%>Printable, T61</td>
</tr>
<tr valign=top>
<td width=18%>SN</td>
<td width=58%>szOID_SUR_NAME</td>
<td width=24%>Printable, T61</td>
</tr>
<tr valign=top>
<td width=18%>DC</td>
<td width=58%>szOID_DOMAIN_COMPONENT</td>
<td width=24%>Only IA5</td>
</tr>
</table><br>


<p>
If either Printable or T61 is allowed as the RDN Value Type for the key (CN=), then Printable is selected if the name string components are restricted to the following character set: 

<p class=indent1>
A, B, …, Z<br>
a, b,  …, z<br>
0, 1,  …, 9<br>
(space) ' ( ) +, - . / : = ?</p>
</dd>
<dt>
<i>pvReserved</i></dt>
<dd>
This parameter is reserved for future use and must be NULL.</dd>
<dt>
<i>pbEncoded</i></dt>
<dd>
Pointer to a buffer that receives the encoded structure.
<p>
This parameter can be NULL to set the size of the key usage for memory allocation purposes. For more information, see the "<a href="refoview_46pf.htm">Common In/Out Parameter Conventions</a>" section at the beginning of this Reference.
</dd>
<dt>
<i>pcbEncoded</i></dt>
<dd>
Pointer to a variable that specifies the size, in bytes, of the buffer pointed to by the <i>pbEncoded </i>parameter. When the function returns, the variable pointed to by the <i>pcbEncoded </i>parameter contains the number of bytes stored in the buffer. This parameter can be NULL, only if <i>pbEncoded </i>is NULL.</dd>
<dt>
<i>ppszError </i></dt>
<dd>
An application may specify a pointer for <i>ppszError</i> if designed to handle errors caused by invalid input strings.
<p>
If the input string is detected to be invalid, *<i>ppszError</i> is updated by this function to point to the beginning of the invalid character sequence. If no errors are detected in the input string, *<i>ppszError</i> is set to NULL.

<p>
<i>ppszError</i> can be set to NULL by the application if it is not interested in getting a pointer to the invalid character sequence, should one be found.

<p>
*<i>ppszError</i> is updated with a non-NULL pointer for the following errors:

<p class=indent1>
CRYPT_E_INVALID_X500_STRING <br>
CRYPT_E_INVALID_NUMERIC_STRING<br>
CRYPT_E_INVALID_PRINTABLE_STRING<br>
CRYPT_E_INVALID_IA5_STRING</p>

</dd>
</dl>
<h4>Return Values</h4>
<p>
Returns TRUE if the input string was successfully parsed and the name was encoded without error. Otherwise, FALSE is returned.</p>
<p>
Call <b>GetLastError</b> to see the reason for any failures.</p>
<h4>Remarks</h4>
<p>
The T61 types are UTF-8 encoded.</p>
<h4>Example</h4>
<pre><code>// EXAMPLE CODE FOR USING CertStrToName().
// Converts a X500 string to an encoded certificate name.
// Assume a pointer to the X500 string is already known.

// Set up the variables.
DWORD dwCertEncodingType = X509_ASN_ENCODING; 
                           // Type of encoding
LPCTSTR pszX500;           // Initialized elsewhere
DWORD dwStrType = 0;       // Type of input string
void * pvReserved = NULL;  // Reserved - set to NULL
BYTE * pbEncoded;          // Pointer to the BYTE blob
DWORD cbEncoded;           // # of bytes of the BYTE blob
LPCTSTR* ppszError;        // Error handling-out, optional
BOOL fResult;              // Returned TRUE if name is encoded
                           //   FALSE if error occurred

// Function called the first time to get
// the size of the structure
fResult = CertStrToName(
            dwCertEncodingType,
            pszX500,
            dwStrType,
            pvReserved,
            pbEncoded,
            &amp;cbEncoded,
            ppszError);

if (!fResult){
 cout&lt;&lt; "First call to CertStrToName failed"&lt;&lt; endl;
}
else {
  cout&lt;&lt; "First call to CertStrToName successful"&lt;&lt; endl;
  pbEncoded = (BYTE*)malloc (cbEncoded);
  cout&lt;&lt; "memory allocated" &lt;&lt; endl;
}

// Function call to convert string to name
fResult = CertStrToName(
            dwCertEncodingType,// in - Type of encoding
            pszX500,           // in - Pointer to the X500 string
            dwStrType,         // in - 0 allows case insensitive key
            pvReserved,        // in, optional - must be NULL 
            pbEncoded,         // out - Pointer to the structure
            &amp;cbEncoded,        // in/out - # of bytes in the structure
            ppszError);        // out, optional - Set to NULL- not
                               //   interested in getting a pointer to
                               //   the invalid character sequence

if (!fResult){                 // FALSE
  cout&lt;&lt; "String was not parsed "&lt;&lt; endl
      &lt;&lt; "error code = "&lt;&lt; GetLastError ()&lt;&lt; endl;
}
else {                         // TRUE
  cout&lt;&lt; "String was parsed"&lt;&lt; endl
      &lt;&lt; "encoded structure = "&lt;&lt; &amp;pbEncoded&lt;&lt; endl
      &lt;&lt; "of "&lt;&lt; cbEncoded&lt;&lt; " bytes"&lt;&lt; endl;
}
free (&amp;pbEncoded);
 </code></pre>
<h4>QuickInfo</h4>
<p>
<b>&nbsp;&nbsp;Windows NT: </b>Requires version 4.0 SP3 or later. Available also in IE 3.02 and later.<br>
<b>&nbsp;&nbsp;Windows: </b>Requires Windows 98 (or Windows 95 with IE 3.02 or later).<br>
<b>&nbsp;&nbsp;Windows CE: </b>Unsupported.<br>
<b>&nbsp;&nbsp;Header: </b>Declared in wincrypt.h.<br>
<b>&nbsp;&nbsp;Import Library: </b>Use crypt32.lib.<br>
<b>&nbsp;&nbsp;Unicode: </b>Defined as Unicode and ANSI prototypes.</p>
<h4>See Also</h4>
<p>
<a href="certhelp_73ea.htm"><b>CertNameToStr</b></a><b><u> </u></b></p>
<p>&nbsp;</p></body>
</HTML>
