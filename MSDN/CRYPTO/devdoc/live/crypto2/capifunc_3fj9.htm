<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CryptVerifySignature</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_crypto2_cryptverifysignature"></a>CryptVerifySignature</h1>
<p>
The <b>CryptVerifySignature</b> function is used to verify a signature against a hash object.</p>
<p>
Before calling this function, the <a href="capifunc_5kfc.htm"><b>CryptCreateHash</b></a> function must be called to get a handle to a hash object. The <a href="capifunc_8c81.htm"><b>CryptHashData</b></a> and/or <a href="capifunc_8fuh.htm"><b>CryptHashSessionKey</b></a> functions are then used to add the data and/or session keys to the hash object.</p>
<p>
After this function has been completed, the only hash function that can be called by using the <i>hHash</i> handle is the <a href="capifunc_5960.htm"><b>CryptDestroyHash</b></a> function.</p>
<pre><code><b>#include &lt;wincrypt.h&gt;
BOOL WINAPI CryptVerifySignature(
  HCRYPTHASH</b><i> hHash</i><b>,      </b>// in
<b>  BYTE </b><i>*pbSignature</i><b>,     </b>// in
<b>  DWORD</b><i> dwSigLen</i><b>,        </b>// in
<b>  HCRYPTKEY</b><i> hPubKey</i><b>,     </b>// in
<b>  LPCTSTR</b><i> sDescription</i><b>,  </b>// in
<b>  DWORD</b><i> dwFlags          </i>// in
<b>);</b>
 </code></pre>
<h4>Parameters</h4>
<dl>
<dt>
<i>hHash</i></dt>
<dd>
A handle to the hash object to verify against.</dd>
<dt>
<i>pbSignature</i></dt>
<dd>
The address of the signature data to be verified.</dd>
<dt>
<i>dwSigLen</i></dt>
<dd>
The number of bytes in the <i>pbSignature</i> signature data.</dd>
<dt>
<i>hPubKey</i></dt>
<dd>
A handle to the public key to use to authenticate the signature. This public key must belong to the key pair that was originally used to create the digital signature.</dd>
<dt>
<i>sDescription</i></dt>
<dd>
This parameter should no longer be used, and should be set to NULL to prevent security vulnerabilities. However, it is still supported for backward compatibility in the Microsoft Base Cryptographic Provider.</dd>
<dt>
<i>dwFlags</i></dt>
<dd>
The flag values. This parameter is reserved for future use and should always be zero.
</dd>
</dl>
<h4>Return Values</h4>
<p>
If the function succeeds, the return value is TRUE. If it fails, the return value is FALSE. To retrieve extended error information, use the <b>GetLastError</b> function.</p>
<p>
The following table lists the error codes most commonly returned by the <b>GetLastError</b> function. The error codes prefaced by "NTE" are generated by the particular CSP you are using.</p>
<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=43%>Error code</th>
<th align=left width=57%>Description</th>
</tr>
<tr valign=top>
<td width=43%>ERROR_INVALID_HANDLE</td>
<td width=57%>One of the parameters specifies an invalid handle.</td>
</tr>
<tr valign=top>
<td width=43%>ERROR_INVALID_PARAMETER</td>
<td width=57%>One of the parameters contains an invalid value. This is most often an illegal pointer.</td>
</tr>
<tr valign=top>
<td width=43%>NTE_BAD_FLAGS</td>
<td width=57%>The <i>dwFlags</i> parameter is nonzero.</td>
</tr>
<tr valign=top>
<td width=43%>NTE_BAD_HASH</td>
<td width=57%>The hash object specified by the <i>hHash</i> parameter is invalid.</td>
</tr>
<tr valign=top>
<td width=43%>NTE_BAD_KEY</td>
<td width=57%>The <i>hPubKey</i> parameter does not contain a handle to a valid public key.</td>
</tr>
<tr valign=top>
<td width=43%>NTE_BAD_SIGNATURE</td>
<td width=57%>The signature was not verified. This could be because the data itself has changed, the description string did not match, or the wrong public key was specified by <i>hPubKey</i>.<p>
This error can also be returned if the hashing or signature algorithms do not match the ones used to create the signature.</p>
</td>
</tr>
<tr valign=top>
<td width=43%>NTE_BAD_UID</td>
<td width=57%>The CSP context that was specified when the hash object was created cannot be found.</td>
</tr>
<tr valign=top>
<td width=43%>NTE_NO_MEMORY</td>
<td width=57%>The CSP ran out of memory during the operation.</td>
</tr>
</table><br>
<h4>Example</h4>
<pre><code>#include &lt;wincrypt.h&gt;

HCRYPTPROV hProv = 0;
#define BUFFER_SIZE 256
BYTE pbBuffer[BUFFER_SIZE];
HCRYPTHASH hHash = 0;
HCRYPTKEY hPubKey = 0;
BYTE *pbSignature = NULL;
DWORD dwSigLen;
LPTSTR szDescription = NULL;

// Get a handle to the default provider.
if(!CryptAcquireContext(&amp;hProv, NULL, NULL, PROV_RSA_FULL, 0)) {
    printf("Error %x during CryptAcquireContext!\n", GetLastError());
    goto done;
}

// Load 'pbBuffer' with 'BUFFER_SIZE' bytes of test data. This must
// be the same data that was originally signed.
...
// Point 'pbSignature' at the signature created by a previous call
// to CryptSignHash. Set 'dwSigLen' to the number of bytes in the
// signature.
...

// Point 'szDescription' at the text describing the data being 
// signed. This must be the same description text that was originally
// passed to CryptSignHash.
...

// Get the public key of the user who created the digital signature 
// and import it into the CSP by using CryptImportKey. This will return
// a handle to the public key in 'hPubKey'.
...

// Create a hash object.
if(!CryptCreateHash(hProv, CALG_MD5, 0, 0, &amp;hHash)) {
    printf("Error %x during CryptCreateHash!\n", GetLastError());
    goto done;
}

// Compute the cryptographic hash of the buffer.
if(!CryptHashData(hHash, pbBuffer, BUFFER_SIZE, 0)) {
    printf("Error %x during CryptHashData!\n", GetLastError());
    goto done;
}

// Validate the digital signature.
if(!CryptVerifySignature(hHash, pbSignature, dwSigLen, hPubKey, 
                            szDescription, 0)) {
    if(GetLastError() == NTE_BAD_SIGNATURE) {
        printf("Signature not validated!\n");
    } else {
        printf("Error %x during CryptVerifySignature!\n", 
                GetLastError());
    }
} else {
    printf("Signature validated\n");
}

done:
...

// Release the public key.
if(hPubKey != 0) CryptDestroyKey(hPubKey);

// Destroy the hash object.
if(hHash != 0) CryptDestroyHash(hHash);

// Release the provider handle.
if(hProv != 0) CryptReleaseContext(hProv, 0);
 </code></pre>
<h4>QuickInfo</h4>
<p>
<b>&nbsp;&nbsp;Windows NT: </b>Requires version 4.0 or later.<br>
<b>&nbsp;&nbsp;Windows: </b>Requires Windows 95 OSR2 or later (or Windows 95 with IE 3.02 or later).<br>
<b>&nbsp;&nbsp;Windows CE: </b>Unsupported.<br>
<b>&nbsp;&nbsp;Header: </b>Declared in wincrypt.h.<br>
<b>&nbsp;&nbsp;Import Library: </b>Use crypt32.lib.<br>
<b>&nbsp;&nbsp;Unicode: </b>Defined as Unicode and ANSI prototypes.</p>
<h4>See Also</h4>
<p>
<a href="capifunc_5kfc.htm"><b>CryptCreateHash</b></a>, <a href="capifunc_5960.htm"><b>CryptDestroyHash</b></a>, <a href="capifunc_8c81.htm"><b>CryptHashData</b></a>, <a href="capifunc_8fuh.htm"><b>CryptHashSessionKey</b></a>, <a href="capifunc_7aco.htm"><b>CryptSignHash</b></a> </p>
<p>
</p>
<p>&nbsp;</p></body>
</HTML>
