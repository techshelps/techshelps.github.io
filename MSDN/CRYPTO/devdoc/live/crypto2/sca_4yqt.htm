<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CryptVerifyDetachedMessageSignature</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_crypto2_cryptverifydetachedmessagesignature"></a>CryptVerifyDetachedMessageSignature</h1>
<p>
The <b>CryptVerifyDetachedMessageSignature</b> function verifies a signed message containing a detached signature or signatures.</p>
<pre><code><b>#include &lt;wincrypt.h&gt;
BOOL WINAPI CryptVerifyDetachedMessageSignature(
  CRYPT_VERIFY_MESSAGE_PARA</b><i> pVerifyPara</i><b>,  </b>// in
<b>  DWORD</b><i> dwSignerIndex</i><b>,                    </b>// in
<b>  const BYTE *</b><i> pbDetachedSignBlob</i><b>,        </b>// in
<b>  DWORD</b><i> cbDetachedSignBlob</i><b>,               </b>// in
<b>  DWORD</b><i> cToBeSigned</i><b>,                      </b>// in
<b>  const BYTE *</b><i>rgpbToBeSigned[ ]</i><b>,          </b>// in
<b>  DWORD *</b><i>rgcbToBeSigned[ ]</i><b>,               </b>// in
<b>  PCCERT_CONTEXT *</b><i>ppSignerCert            </i>// out, optional
<b>);</b>
 </code></pre>
<h4>Parameters</h4>
<dl>
<dt>
<i>pVerifyPara</i></dt>
<dd>
A pointer to the verify parameters. For details, see <a href="structs_3noz.htm">Simplified Message Data Structures</a>. </dd>
<dt>
<i>dwSignerIndex</i></dt>
<dd>
There can be more than one signature. This is an index to the desired signature. The function can be called repeatedly, incrementing <i>dwSignerIndex</i> each time. If the function returns FALSE, and <b>GetLastError</b> returns CRYPT_E_NO_SIGNER, the previous call got the last signer of the message.</dd>
<dt>
<i>pbDetachedSignBlob</i></dt>
<dd>
A pointer to the encoded message containing only signatures (without content).</dd>
<dt>
<i>cbDetachedSignBlob</i></dt>
<dd>
The size, in bytes, of the detached signature.</dd>
<dt>
<i>cToBeSigned</i></dt>
<dd>
The number of array elements in <i>rgpbToBeSigned</i>[] and <i>rgcbToBeSigned</i>[]<i>.</i></dd>
<dt>
<i>rgpbToBeSigned</i>[]</dt>
<dd>
An array of pointers to the contents to be hashed.</dd>
<dt>
<i>rgcbToBeSigned</i>[]</dt>
<dd>
An array of sizes, in bytes, for the contents pointed to in <i>rgpbToBeSigned</i>[].</dd>
<dt>
<i>ppSignerCert</i></dt>
<dd>
An optional parameter, it is a pointer to the certificate context pointer of the signer. A pointer will not be returned if this parameter is NULL.
</dd>
</dl>
<h4>Return Values</h4>
<p>
TRUE if the function succeeded and the detached signature was verified. FALSE if the function failed to verify the signature.</p>
<p>
Call <b>GetLastError</b> to see the reason for any failures. Note that errors from the called functions <a href="capifunc_5kfc.htm"><b>CryptCreateHash</b></a>,<b> <a href="capifunc_8c81.htm">CryptHashData</a></b>,<b> <a href="capifunc_3fj9.htm">CryptVerifySignature</a></b>, and <a href="capifunc_5np5.htm"><b>CryptImportKey</b></a><b> </b>may be propagated to this function. This function has the following error codes:</p>
<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=57%>Error code</th>
<th align=left width=43%>Description</th>
</tr>
<tr valign=top>
<td width=57%>E_INVALIDARG </td>
<td width=43%>Invalid message and certificate encoding types. Currently only PKCS_7_ASN_ENCODING and X509_ASN_ENCODING_TYPE are supported. Invalid <b>cbSize</b> in *<i>pVerifyPara</i>.</td>
</tr>
<tr valign=top>
<td width=57%>CRYPT_E_OSS_ERROR </td>
<td width=43%>Message ASN.1 decoding error. Note, to get the OSS error subtract CRYPT_E_OSS_ERROR from the returned error and see asn1code.h for details on the error.</td>
</tr>
<tr valign=top>
<td width=57%>CRYPT_E_UNEXPECTED_MSG_TYPE</td>
<td width=43%>Not a signed cryptographic message.</td>
</tr>
<tr valign=top>
<td width=57%>CRYPT_E_NO_SIGNER </td>
<td width=43%>The message doesn't have any signers or a signer for the specified <i>dwSignerIndex</i>.</td>
</tr>
<tr valign=top>
<td width=57%>NTE_BAD_ALGID </td>
<td width=43%>The message was hashed and signed using an algorithm we don't know about or support.</td>
</tr>
<tr valign=top>
<td width=57%>NTE_BAD_SIGNATURE </td>
<td width=43%>The message's signature was not verified. </td>
</tr>
</table><br>
<h4>Example</h4>
<pre><code>// EXAMPLE CODE FOR USING CryptVerifyDetachedMessageSignature() to 
// verify a message's signatures. The signer's certificates are not 
// required and won't be returned.

// Assume that the application already knows the address of the
// target detached signature blob (pbDetachedSignBlob) and its size
// (cbDetachedsignBlob), the address of the array of signatures to be 
// verified (rgpbToBeSigned[]), the number of elements in the array
// (cToBeSigned), and the size of each of the elements
// (rgcbToBeSigned[]).

// Set up the variables.
CRYPT_VERIFY_MESSAGE_PARA    VerifyPara;      // Struct initialized elsewhere
DWORD                dwSignerIndex = 0;
const BYTE*          pbDetachedSignBlob;      // Initialized elsewhere
DWORD                cbDetachedSignBlob;      // Initialized elsewhere
DWORD                cToBeSigned = 3;         // Initialized elsewhere
const BYTE*          rgpbToBeSigned[3];       // Initialized elsewhere
DWORD                rgcbToBeSigned[3];       // Initialized elsewhere
BOOL                 fReturn =    FALSE;
DWORD                dwErrorCode;

// Call CryptVerifyDetachedMessageSignature to verify the detached 
// signatures.
while(TRUE)
{
    fReturn = CryptVerifyDetachedMessageSignature(&amp;VerifyPara, 
              dwSignerIndex, pbDetachedSignBlob, 
              cbDetachedSignBlob, cToBeSigned, 
              rgpbToBeSigned,rgcbToBeSigned, NULL);
    if(fReturn != TRUE)
    { 
        dwErrorCode = GetLastError();
        if(dwErrorCode == CRYPT_E_NO_SIGNER)
        {
            cout &lt;&lt; "Done verifying signatures";
            break;
        }
        else
        {
            // A signer was not verified or an error occurred.
            // Handle the condition.
        }
    }
    dwSignerIndex ++;
}

// If dwErrorCode = CRYPT_E_NO_SIGNER at this point, the function succeeded,
// and all the signatures were verified.
 </code></pre>
<h4>QuickInfo</h4>
<p>
<b>&nbsp;&nbsp;Windows NT: </b>Requires version 4.0 SP3 or later. Available also in IE 3.02 and later.<br>
<b>&nbsp;&nbsp;Windows: </b>Requires Windows 98 (or Windows 95 with IE 3.02 or later).<br>
<b>&nbsp;&nbsp;Windows CE: </b>Unsupported.<br>
<b>&nbsp;&nbsp;Header: </b>Declared in wincrypt.h.<br>
<b>&nbsp;&nbsp;Import Library: </b>Use crypt32.lib.</p>
<h4>See Also</h4>
<p>
<a href="sca_5ecl.htm"><b>CryptVerifyMessageSignature</b></a> </p>
<p>&nbsp;</p></body>
</HTML>
