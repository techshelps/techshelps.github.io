<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CryptDecodeMessage</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_crypto2_cryptdecodemessage"></a>CryptDecodeMessage</h1>
<p>
The <b>CryptDecodeMessage</b> function decodes, decrypts, and verifies a cryptographic message.</p>
<p>
This function may be used when the type of cryptographic message is unknown. The constants for <i>dwMsgTypeFlags</i> may be combined with a bitwise OR operation so that the function will try to find one of the types. When one of the types is found, the function will report the type found, and return the data appropriate for the type found (see the <i>pbDecoded</i> parameter).</p>
<p>
In a single pass, the function cracks only the first level of encryption or encoding. For additional cracking, the function needs to be called again, or one of the other <a href="sca_4t83.htm">Simplified Message Functions</a> used for the additional cracking must be called.</p>
<pre><code><b>#include &lt;wincrypt.h&gt;
BOOL WINAPI CryptDecodeMessage(
  DWORD</b><i> dwMsgTypeFlags</i><b>,                       </b>// in
<b>  PCRYPT_DECRYPT_MESSAGE_PARA</b><i> pDecryptPara</i><b>,   </b>// in
<b>  PCRYPT_VERIFY_MESSAGE_PARA</b><i> pVerifyPara</i><b>,     </b>// in
<b>  DWORD</b><i> dwSignerIndex</i><b>,                        </b>// in
<b>  const BYTE </b><i>*pbEncodedBlob</i><b>,                  </b>// in
<b>  DWORD</b><i> cbEncodedBlob</i><b>,                        </b>// in
<b>  DWORD</b><i> dwPrevInnerContentType</i><b>,               </b>// in
<b>  DWORD </b><i>*pdwMsgType</i><b>,                          </b>// out/optional
<b>  DWORD </b><i>*pdwInnerContentType</i><b>,                 </b>// out/optional
<b>  BYTE </b><i>*pbDecoded</i><b>,                            </b>// out/optional
<b>  DWORD </b><i>*pcbDecoded</i><b>,                          </b>// in/out/optional
<b>  PCCERT_CONTEXT </b><i>*ppXchgCert</i><b>,                 </b>// out/optional
<b>  PCCERT_CONTEXT </b><i>*ppSignerCert                </i>// out/optional
<b>);</b>
 </code></pre>
<h4>Parameters</h4>
<dl>
<dt>
<i>dwMsgTypeFlags</i></dt>
<dd>
Flags that control what message types get decoded. The following types are defined, and may be combined with the bitwise OR operator:
<ul>
<li>
CMSG_DATA_FLAG</li>
<li>
CMSG_SIGNED_FLAG</li>
<li>
CMSG_ENVELOPED_FLAG</li>
<li>
CMSG_SIGNED_AND_ENVELOPED_FLAG</li>
<li>
CMSG_HASHED_FLAG</li>
</ul>
</dd>
<dt>
<i>pDecryptPara</i></dt>
<dd>
Pointer to the decryption parameters. For details, see <a href="structs_3noz.htm">Simplified Message Data Structures</a>. Applicable to the message types: CMSG_ENVELOPED or CMSG_SIGNED_AND_ENVELOPED.</dd>
<dt>
<i>pVerifyPara</i></dt>
<dd>
Pointer to the verification parameters. For details, see Simplified Message Data Structures. Applicable to the message types: CMSG_SIGNED, CMSG_SIGNED_AND_ENVELOPED and CMSG_HASHED.</dd>
<dt>
<i>dwSignerIndex</i></dt>
<dd>
Message might have more than one signer, so <i>dwSignerIndex</i> is an index to a particular signer, and can be iterated with multiple calls to the function. It should be set to zero for the first signer, or, as is the usual case, for a single signer. If the function returns FALSE, and <b>GetLastError</b> returns CRYPT_E_NO_SIGNER, the previous call got the last signer of the message. Only applicable to the message types: CMSG_SIGNED_AND_ENVELOPED or CMSG_SIGNED. </dd>
<dt>
<i>pbEncodedBlob</i></dt>
<dd>
Pointer to the encoded blob that is to be decoded.</dd>
<dt>
<i>cbEncodedBlob</i></dt>
<dd>
The size, in bytes, of the encoded blob.</dd>
<dt>
<i>dwPrevInnerContentType</i></dt>
<dd>
Only applicable when processing nested cryptographic messages. When processing an outer cryptographic message, it must be set to zero. When decoding a nested cryptographic message, it should be set to the value returned at <i>pdwInnerContentType</i> by a previous calling of <b>CryptDecodeMessage</b> for the outer message. It can be any of the CMSG types listed in <i>pdwMsgType.</i> Set to zero for backward compatibility.</dd>
<dt>
<i>pdwMsgType</i></dt>
<dd>
An optional parameter. Specifies the address where the message type is returned. Possible message types are:
<p>
CMSG_DATA<br>
CMSG_SIGNED<br>
CMSG_ENVELOPED<br>
CMSG_SIGNED_AND_ENVELOPED<br>
CMSG_HASHED
</dd>
<dt>
<i>pdwInnerContentType</i></dt>
<dd>
An optional parameter that is updated with the type of the inner message. Unless there is cryptographic message nesting, CMSG_DATA is returned. Set to NULL for backward compatibility.</dd>
<dt>
<i>pbDecoded</i></dt>
<dd>
Optional parameter. Pointer to a buffer that receives the decoded message. 
<p>
This parameter can be NULL if the decoded message is not required, or to set the size of the decoded message for memory allocation purposes. For more information, see <a href="refoview_46pf.htm">Common In/Out Parameter Conventions</a>. 
</dd>
<dt>
<i>pcbDecoded</i></dt>
<dd>
An optional parameter. Pointer to a variable that specifies the size, in bytes, of the buffer pointed to by the <i>pbDecoded </i>parameter. When the function returns, this variable contains the size of the decoded message copied to *<i>pbDecoded</i>. A decoded message will not be returned if this parameter is NULL.
<p>
Note that when processing the data returned in the buffer, applications need to use the actual size of the data returned. The actual size may be slightly smaller than the size of the buffer specified on input. (On input, buffer sizes are usually specified large enough to insure that the largest possible output data will fit in the buffer.) On output, the variable pointed to by this parameter is updated to reflect the actual size of the data copied to the buffer.
</dd>
<dt>
<i>ppXchgCert</i></dt>
<dd>
An optional parameter. It's a pointer to the certificate context pointer corresponding to the exchange (private) key used to decode the message. Only updated for CMSG_ENVELOPED or CMSG_SIGNED_AND_ENVELOPED.</dd>
<dt>
<i>ppSignerCert</i></dt>
<dd>
An optional parameter. It is a pointer to the certificate context pointer of the signer. Only updated for CMSG_SIGNED or CMSG_SIGNED_AND_ENVELOPED.
</dd>
</dl>
<h4>Return Values</h4>
<p>
TRUE if the function succeeded. FALSE if the function failed.</p>
<p>
Call <b>GetLastError</b> to see the reason for any failures. Note that errors from the called functions <a href="sca_73j9.htm"><b>CryptDecryptMessage</b></a>, <a href="sca_5ecl.htm"><b>CryptVerifyMessageSignature</b></a>,<b> </b>or<b> <a href="sca_2fjc.htm">CryptVerifyMessageHash</a></b> may be propagated to this function.</p>
<p>
This function has the following error codes.</p>
<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=40%>Error code</th>
<th align=left width=60%>Description</th>
</tr>
<tr valign=top>
<td width=40%>ERROR_MORE_DATA</td>
<td width=60%>If the buffer specified by the <i>pbDecoded </i>parameter is not large enough to hold the returned data, the function sets the ERROR_MORE_DATA code, and stores the required buffer size, in bytes, into the variable pointed to by <i>pcbDecoded</i>.</td>
</tr>
</table><br>
<h4>Remarks</h4>
<p>
The<i> dwMsgTypeFlags</i> parameter specifies the set of allowable messages. For example, to decode either SIGNED or ENVELOPED messages, set <i>dwMsgTypeFlags</i> to CMSG_SIGNED_FLAG | CMSG_ENVELOPED_FLAG. Either or both of the <i>pDecryptPara </i>or <i>pVerifyPara </i>parameters must be specified.</p>
<p>
Note that *<i>pdwMsgType</i> is updated with the type of the message.</p>
<p>
For a successfully decoded or verified message, the certificate context pointers pointed to by <i>ppXchgCert</i> and <i>ppSignerCert</i> are updated. They must be freed by calling <a href="certstor_1tv8.htm"><b>CertFreeCertificateContext</b></a>. If the function fails, they are set to NULL.</p>
<p>
<i>ppXchgCert</i> or <i>ppSignerCert</i> can be NULL, indicating the caller isn't interested in getting the exchange certificate or the signer certificate context.</p>
<h4>Example</h4>
<pre><code>// EXAMPLE CODE FOR USING CryptDecodeMessage().
// Decodes, decrypts, and verifies a cryptographic message.
// Assume that pointers to the decription paramaters
// (pDecryptPara), the verification paramaters (pVerifyPara),
// and the encoded blob (pbEncodedBlob) have already been defined.

// Set up the variables.
DWORD dwMsgTypeFlags = CMSG_DATA_FLAG | CMSG_SIGNED_FLAG;
                                  // Type of message flag
PCRYPT_DECRYPT_MESSAGE_PARA pDecryptPara;
                                  // Struct initialized elsewhere -
                                  //   Pointer to decryption
                                  //   paramaters
PCRYPT_VERIFY_MESSAGE_PARA pVerifyPara;
                                  // Struct initialized elsewhere -
                                  //   Pointer to verification
                                  //   paramaters
DWORD dwSignerIndex = 0;          // Signer index -  0 for the first
                                  //   signer
const BYTE *pbEncodedBlob;        // Initialized elsewhere -
                                  //   Pointer to the encoded blob
DWORD cbEncodedBlob = 128;        // Size of encoded blob
DWORD dwPrevInnerContentType = 0; // Previous content type (eg.
                                  //   CMSG_DATA) - set to 0 for outer
                                  //   nested messages
DWORD *pdwMsgType;                // Pointer to the message type
DWORD *pdwInnerContentType;       // Pointer to type of inner message
                                  //   for outer message set to NULL
BYTE *pbDecoded;                  // Pointer to decoded message buffer
DWORD cbDecoded;                  // Size of decoded message
PCCERT_CONTEXT *ppXchgCert;       // Pointer to certificate context
                                  //   pointer of the exchange key
PCCERT_CONTEXT *ppSignerCert;     // Pointer to certificate context
                                  //   pointer of the signer
BOOL fResult;                     // Return TRUE if function succeeds
                                  //   FALSE if function fails

// Function called the first time to get the
// size of the decoded message (cbDecoded)
fResult= CryptDecodeMessage(
           dwMsgTypeFlags,
           pDecryptPara,
           pVerifyPara,
           dwSignerIndex,
           pbEncodedBlob,
           cbEncodedBlob,
           dwPrevInnerContentType,
           pdwMsgType,
           pdwInnerContentType,
           NULL,                        // NULL on first call
           &amp;cbDecoded,
           ppXchgCert,
           ppSignerCert);

if (!fResult){
  cout&lt;&lt; "first call to CryptDecodeMessage failed"&lt;&lt; endl;
}
else {
  cout&lt;&lt; "first call to CryptDecodeMessage successful"&lt;&lt; endl;
  pbDecoded = (BYTE*) malloc (cbDecoded);
  cout&lt;&lt; "memory allocated"&lt;&lt; endl;
}

// Function call decode the first level of encryption
fResult= CryptDecodeMessage(
           dwMsgTypeFlags,              // in
           pDecryptPara,                // in
           pVerifyPara,                 // in
           dwSignerIndex,               // in
           pbEncodedBlob,               // in
           cbEncodedBlob,               // in
           dwPrevInnerContentType,      // in
           pdwMsgType,                  // out/optional
           pdwInnerContentType,         // out/optional
           pbDecoded,                   // out/optional
           &amp;cbDecoded,                  // in/out/optional
           ppXchgCert,                  // out/optional
           ppSignerCert);               // out/optional

if (!fResult) {                         // FALSE
 cout&lt;&lt; "Function failed"&lt;&lt; endl
     &lt;&lt; "error code = "&lt;&lt; GetLastError()&lt;&lt; endl;
}
else {                                  // TRUE
  cout&lt;&lt; "Function succeeded"&lt;&lt; endl
      &lt;&lt; "message type = "&lt;&lt; &amp;pdwMsgType&lt;&lt; endl
      &lt;&lt; "inner message type (NULL) = "&lt;&lt; &amp;pdwInnerContentType&lt;&lt; endl
      &lt;&lt; "size = "&lt;&lt; cbDecoded&lt;&lt; endl
      &lt;&lt; "located at = "&lt;&lt; pbDecoded&lt;&lt; endl;
}
free (pbDecoded);
 </code></pre>
<h4>QuickInfo</h4>
<p>
<b>&nbsp;&nbsp;Windows NT: </b>Requires version 4.0 SP3 or later. Available also in IE 3.02 and later.<br>
<b>&nbsp;&nbsp;Windows: </b>Requires Windows 98 (or Windows 95 with IE 3.02 or later).<br>
<b>&nbsp;&nbsp;Windows CE: </b>Unsupported.<br>
<b>&nbsp;&nbsp;Header: </b>Declared in wincrypt.h.<br>
<b>&nbsp;&nbsp;Import Library: </b>Use crypt32.lib.</p>
<h4>See Also</h4>
<p>
<a href="sca_73j9.htm"><b>CryptDecryptMessage</b></a>,<b> <a href="sca_2fjc.htm">CryptVerifyMessageHash</a></b>,<b> <a href="sca_5ecl.htm">CryptVerifyMessageSignature</a> </b></p>
<p>&nbsp;</p></body>
</HTML>
