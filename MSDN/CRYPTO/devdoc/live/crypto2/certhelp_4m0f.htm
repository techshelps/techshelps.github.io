<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CryptHashPublicKeyInfo</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_crypto2_crypthashpublickeyinfo"></a>CryptHashPublicKeyInfo</h1>
<p>
The <b>CryptHashPublicKeyInfo</b> function encodes the public key information and computes its hash.</p>
<pre><code><b>#include &lt;wincrypt.h&gt;
BOOL WINAPI CryptHashPublicKeyInfo(
  HCRYPTPROV</b><i> hCryptProv</i><b>,        </b>// in
<b>  ALG_ID</b><i> Algid</i><b>,                 </b>// in
<b>  DWORD</b><i> dwFlags</i><b>,                </b>// in
<b>  DWORD</b><i> dwCertEncodingType</i><b>,     </b>// in
<b>  PCERT_PUBLIC_KEY_INFO</b><i> pInfo</i><b>,  </b>// in
<b>  BYTE </b><i>*pbComputedHash</i><b>,         </b>// out
<b>  DWORD </b><i>*pcbComputedHash        </i>// in, out
<b>);</b>
 </code></pre>
<h4>Parameters</h4>
<dl>
<dt>
<i>hCryptProv</i></dt>
<dd>
Specifies the Cryptographic Service Provider to use to compute the hash.
<p>
Unless there is a strong reason for passing in a specific cryptographic provider in <b>hCryptProv</b>, zero should be passed in. Passing in zero causes the default RSA or DSS provider to be acquired before doing hash, signature verification or recipient encryption operations.
</dd>
<dt>
<i>Algid</i></dt>
<dd>
Specifies the CryptoAPI hash algorithm to use. If <i>Algid</i> is zero, the default hash algorithm, SHA1, is used.</dd>
<dt>
<i>dwFlags</i></dt>
<dd>
Normally zero. Gets passed on to <a href="capifunc_5kfc.htm"><b>CryptCreateHash</b></a>.</dd>
<dt>
<i>dwCertEncodingType</i></dt>
<dd>
The type of encoding used on the certificate. Currently defined certificate encoding types are shown in the following table:
<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=49%>Encoding type</th>
<th align=left width=51%>Value</th>
</tr>
<tr valign=top>
<td width=49%>X509_ASN_ENCODING</td>
<td width=51%>0x00000001</td>
</tr>
</table><br>

</dd>
<dt>
<i>pInfo</i></dt>
<dd>
A pointer to the public key information to be encoded and hashed.</dd>
<dt>
<i>pbComputedHash</i></dt>
<dd>
Pointer to a buffer that receives the computed hash.
<p>
This parameter can be NULL to set the size of this information for memory allocation purposes. For more information, see <a href="refoview_46pf.htm">Common In/Out Parameter Conventions</a>. 
</dd>
<dt>
<i>pcbComputedHash</i></dt>
<dd>
Pointer to a <b>DWORD </b>that contains the size, in bytes, of the buffer pointed to by the <i>pbComputedHash </i>parameter. When the function returns, the variable pointed to by the <i>pcbComputedHash </i>parameter contains the number of bytes stored in the buffer. This parameter can be NULL only if <i>pbComputedHash </i>is NULL.

<p>
<b>Note</b>&nbsp;&nbsp;When processing the data returned in the buffer, applications need to use the actual size of the data returned. The actual size may be slightly smaller than the size of the buffer specified on input. (On input, buffer sizes are usually specified large enough to insure that the largest possible output data will fit in the buffer.) On output, the variable pointed to by this parameter is updated to reflect the actual size of the data copied to the buffer.

</dd>
</dl>
<h4>Return Values</h4>
<p>
TRUE if the function succeeded, FALSE if the function failed.</p>
<p>
Call <b>GetLastError</b> to see the reason for any failures. Note that errors from the called functions <a href="capifunc_5kfc.htm"><b>CryptCreateHash</b></a>,<b> <a href="capifunc_7inh.htm">CryptGetHashParam</a></b> and <a href="capifunc_8c81.htm"><b>CryptHashData</b></a> may be propagated to this function. This function has the following error codes.</p>
<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=43%>Error code</th>
<th align=left width=57%>Description</th>
</tr>
<tr valign=top>
<td width=43%>CRYPT_E_OSS_ERROR </td>
<td width=57%>Public key ASN.1 encoding error. Note, to get the OSS error subtract CRYPT_E_OSS_ERROR from the returned error and see asn1code.h for details on the error.</td>
</tr>
<tr valign=top>
<td width=43%>ERROR_MORE_DATA</td>
<td width=57%>If the buffer specified by the <i>pbComputedHash </i>parameter is not large enough to hold the returned data, the function sets the ERROR_MORE_DATA code, and stores the required buffer size, in bytes, into the variable pointed to by <i>pcbComputedHash</i>.</td>
</tr>
<tr valign=top>
<td width=43%>ERROR_FILE_NOT_FOUND</td>
<td width=57%>Invalid certificate encoding type. Currently only X509_ASN_ENCODING is supported. </td>
</tr>
</table><br>
<h4>Example</h4>
<pre><code>// EXAMPLE CODE FOR USING CryptHashPublicKeyInfo().
// Encodes the public key information and computes its hash.
// Assume that a pointer to the Public Key blob (pInfo) has 
// already been defined.

// Set up the variables.
HCRYPTPROV hCryptProv = 0;    // Service Provider handle- normally 0
ALG_ID Algid = 0;             // Algorithm
DWORD dwFlags = 0;            // Flags value- normally 0
DWORD dwCertEncodingType = X509_ASN_ENCODING;
                              // Type of encoding
PCERT_PUBLIC_KEY_INFO pInfo;  // Pointer to public key info 
BYTE * pbComputedHash;        // Pointer to computed hash
DWORD cbComputedHash;         // Size of computer hash
BOOL fResult;                 // Return TRUE if function succeeded
                              //   FALSE if function failed

// Function called the first time to get
// the size of the returned hash.
fResult= CryptHashPublicKeyInfo(
           hCryptProv,
           Algid,
           dwFlags,
           dwCertEncodingType,
           pInfo,
           NULL,              // NULL on first call
                              //   NULL is used to determine the
                              //   size needed to insure that the
                              //   returned data fits in the
                              //   specified buffer
           &amp;cbComputedHash);

if (!fResult){
  cout&lt;&lt; "first call to CryptHashPublicKeyInfo failed"&lt;&lt; endl;
}
else {
  cout&lt;&lt; "first call to CryptHashPublicKeyInfo successful"&lt;&lt; endl;
  pbComputedHash = (BYTE *)malloc (cbComputedHash);
  cout&lt;&lt; "memory allocated"&lt;&lt; endl;
}

// Function call to get the computed hash
fResult= CryptHashPublicKeyInfo(
           hCryptProv,        // in - 0 is default RSA or DSS provider 
           Algid,             // in - 0 is default 
           dwFlags,           // in - set to 0
           dwCertEncodingType,// in - X509_ASN_ENCODING
           pInfo,             // in - Public key info
           pbComputedHash,    // out- Pointer to the returned hash 
           &amp;cbComputedHash);  // in/out - Size of hash

if (!fResult) {               // FALSE
 cout&lt;&lt; "Function failed"&lt;&lt; endl
     &lt;&lt; "error = "&lt;&lt; GetLastError()&lt;&lt; endl;
}
else {                        // TRUE
 cout&lt;&lt; "Function succeeded"&lt;&lt; endl;
}
free (pInfo);
 </code></pre>
<h4>QuickInfo</h4>
<p>
<b>&nbsp;&nbsp;Windows NT: </b>Requires version 4.0 SP3 or later. Available also in IE 3.02 and later.<br>
<b>&nbsp;&nbsp;Windows: </b>Requires Windows 98 (or Windows 95 with IE 3.02 or later).<br>
<b>&nbsp;&nbsp;Windows CE: </b>Unsupported.<br>
<b>&nbsp;&nbsp;Header: </b>Declared in wincrypt.h.<br>
<b>&nbsp;&nbsp;Import Library: </b>Use crypt32.lib.</p>
<h4>See Also</h4>
<p>
<a href="certhelp_2jxh.htm"><b>CryptHashCertificate</b></a>,<b> <a href="certhelp_60mc.htm">CryptHashToBeSigned</a> </b></p>
<p>&nbsp;</p></body>
</HTML>
