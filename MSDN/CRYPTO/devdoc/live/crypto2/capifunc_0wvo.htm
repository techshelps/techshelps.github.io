<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CryptAcquireContext</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_crypto2_cryptacquirecontext"></a>CryptAcquireContext</h1>
<p>
The <b>CryptAcquireContext</b> function is used to acquire a handle to a particular key container within a particular CSP. This returned handle can then be used to make calls to the selected CSP.</p>
<p>
This function performs two operations. It first attempts to find a CSP with the characteristics described in the <i>dwProvType</i> and <i>pszProvider</i> parameters. If the CSP is found, then the function attempts to find a key container within the CSP matching the name specified by the <i>pszContainer</i> parameter.</p>
<p>
This function can also be used to create and destroy key containers, depending on the value of the <i>dwFlags</i> parameter.</p>
<pre><code><b>#include &lt;wincrypt.h&gt;
BOOL WINAPI CryptAcquireContext(
  HCRYPTPROV </b><i>*phProv</i><b>,   </b>// out
<b>  LPCTSTR</b><i> pszContainer</i><b>, </b>// in
<b>  LPCTSTR</b><i> pszProvider</i><b>,  </b>// in
  <b>DWORD</b> <i>dwProvType</i><b>,</b>     // in
<b>  DWORD</b><i> dwFlags         </i>// in
<b>);</b>
 </code></pre>
<h4>Parameters</h4>
<dl>
<dt>
<i>phProv</i></dt>
<dd>
Address to which the function copies a handle to the CSP.</dd>
<dt>
<i>pszContainer</i></dt>
<dd>
Key container name. This is a zero-terminated string that identifies the key container to the CSP. This name is independent of the method used to store the keys. Some <a href="cryptcsp/signcsp_6rn7.htm">CSPs</a> will store their key containers internally (in hardware), some will use the system registry, and others will use the file system. <i>pszContainer</i> is to be set to NULL when <i>dwFlags </i>is set to CRYPT_VERIFYCONTEXT.
<p>
If this parameter is NULL, then a default key container name will be used. For example, if the Microsoft Base Cryptographic Provider is being used, then the current user's logon name will be used as the name of the key container. Other CSPs may also have default key containers that can be acquired in this way.

<p>
An application can obtain the name of the acquired key container at a later time by reading the PP_CONTAINER CSP parameter with the <a href="capifunc_4vxp.htm"><b>CryptGetProvParam</b></a> function.
</dd>
<dt>
<i>pszProvider</i></dt>
<dd>
Provider name. This is a zero-terminated string that specifies the CSP to be used.
<p>
If this parameter is NULL then the user default provider is used. For more details, see <a href="csp_00j6.htm">Connecting to a Cryptographic Service Provider</a>. 

<p>
An application can obtain the name of the acquired CSP at a later time by reading the PP_NAME CSP parameter with the <b>CryptGetProvParam</b> function.
</dd>
<dt>
<i>dwProvType</i></dt>
<dd>
Type of provider to acquire. The following provider types are predefined, and are discussed in detail in <a href="csp_1gpr.htm">Interfacing with a Cryptographic Service Provider (CSP)</a>. 
<ul>
<li>
PROV_RSA_FULL</li>
<li>
PROV_RSA_SIG</li>
<li>
PROV_DSS</li>
<li>
PROV_DSS_DH</li>
<li>
PROV_DH_SCHANNEL</li>
<li>
PROV_FORTEZZA</li>
<li>
PROV_MS_EXCHANGE</li>
<li>
PROV_RSA_SCHANNEL</li>
<li>
PROV_SSL</li>
</ul>
</dd>
<dt>
<i>dwFlags</i></dt>
<dd>
Flag values. This parameter is normally set to zero, but some applications will set one or more of the following flags:
<ul>
<li>
CRYPT_VERIFYCONTEXT. If this flag is set, then the application will have no access to the private keys and the <i>pszContainer </i>parameter must be set to NULL.<p>
This option is intended to be used with applications that will not be using private keys.
<p>
When <b>CryptAcquireContext</b> is called, many <a href="cryptcsp/signcsp_6rn7.htm">CSPs</a> will require input from the owning user before granting access to the private keys in the key container. For example, the private keys may be encrypted, requiring a password from the user before they can be used. However, if the CRYPT_VERIFYCONTEXT flag is specified, access to the private keys is not required and the user interface can be bypassed.
</li>
<li>
CRYPT_NEWKEYSET. If this flag is set, then a new key container will be created with the name specified by <i>pszContainer</i>. If <i>pszContainer</i> is NULL, then a key container with the default name will be created. See CRYPT_MACHINE_KEYSET for information on combining flags.</li>
<li>
CRYPT_MACHINE_KEYSET. By default, keys are stored in the HKEY_CURRENT_USER portion of the registry. The CRYPT_MACHINE_KEYSET flag can be combined with all of the other flags, indicating that the location for the key of interest is HKEY_LOCAL_MACHINE. When combined with the CRYPT_NEWKEYSET flag, the CRYPT_MACHINE_KEYSET flag is useful when access is being performed from a service or user account that did not log on interactively. This combination enables access to user specific keys under HKEY_LOCAL_MACHINE.</li>
</ul>

<p>
<b>Note</b>&nbsp;&nbsp;When key containers are created, most <a href="cryptcsp/signcsp_6rn7.htm">CSPs</a> will not automatically create any public/private key pairs. These keys must be created as a separate step with the <a href="capifunc_4ptl.htm"><b>CryptGenKey</b></a> function.


<ul>
<li>
CRYPT_DELETEKEYSET. If this flag is set, then the key container specified by <i>pszContainer</i> is deleted. If <i>pszContainer</i> is NULL, then the key container with the default name is deleted. All key pairs in the key container are also destroyed.<p>
When the CRYPT_DELETEKEYSET flag is set, the value returned in <i>phProv</i> is undefined and, thus, the <a href="capifunc_62no.htm"><b>CryptReleaseContext</b></a> function need not be called afterwards.
</li>
</ul>
</dd>
</dl>
<h4>Return Values</h4>
<p>
If the function succeeds, the return value is TRUE. If it does not succeed, the return value is FALSE. To retrieve extended error information, use the <b>GetLastError</b> function.</p>
<p>
The following table lists the error codes most commonly returned by the <b>GetLastError</b> function.</p>
<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=53%>Error code</th>
<th align=left width=47%>Description</th>
</tr>
<tr valign=top>
<td width=53%>ERROR_INVALID_PARAMETER</td>
<td width=47%>One of the parameters contains an invalid value. This is most often an illegal pointer.</td>
</tr>
<tr valign=top>
<td width=53%>ERROR_NOT_ENOUGH_MEMORY</td>
<td width=47%>The operating system ran out of memory during the operation.</td>
</tr>
<tr valign=top>
<td width=53%>NTE_BAD_FLAGS</td>
<td width=47%>The <i>dwFlags</i> parameter has an illegal value.</td>
</tr>
<tr valign=top>
<td width=53%>NTE_BAD_KEYSET</td>
<td width=47%>The registry entry for the key container could not be opened and may not exist.</td>
</tr>
<tr valign=top>
<td width=53%>NTE_BAD_KEYSET_PARAM</td>
<td width=47%>The <i>pszContainer</i> or <i>pszProvider</i> parameter is set to an illegal value.</td>
</tr>
<tr valign=top>
<td width=53%>NTE_BAD_PROV_TYPE</td>
<td width=47%>The value of the <i>dwProvType</i> parameter is out of range. All provider types must be from 1 to 999, inclusive.</td>
</tr>
<tr valign=top>
<td width=53%>NTE_BAD_SIGNATURE</td>
<td width=47%>The provider DLL signature could not be verified. Either the DLL or the digital signature has been tampered with.</td>
</tr>
<tr valign=top>
<td width=53%>NTE_EXISTS</td>
<td width=47%>The <i>dwFlags</i> parameter is CRYPT_NEWKEYSET, but the key container already exists.</td>
</tr>
<tr valign=top>
<td width=53%>NTE_KEYSET_ENTRY_BAD</td>
<td width=47%>The registry entry for the <i>pszContainer</i> key container was found (in the HKEY_CURRENT_USER window), but is corrupt. See <a href="sysadmin_3qni.htm">System Administration</a> for details about the CryptoAPI registry usage.</td>
</tr>
<tr valign=top>
<td width=53%>NTE_KEYSET_NOT_DEF</td>
<td width=47%>No registry entry exists in the HKEY_CURRENT_USER window for the key container specified by <i>pszContainer</i>.</td>
</tr>
<tr valign=top>
<td width=53%>NTE_NO_MEMORY</td>
<td width=47%>The CSP ran out of memory during the operation.</td>
</tr>
<tr valign=top>
<td width=53%>NTE_PROV_DLL_NOT_FOUND</td>
<td width=47%>The provider DLL file does not exist or is not on the current path.</td>
</tr>
<tr valign=top>
<td width=53%>NTE_PROV_TYPE_ENTRY_BAD</td>
<td width=47%>The registry entry for the provider type specified by <i>dwProvType</i> is corrupt. This error may relate to either the user default CSP list or the machine default CSP list. See <a href="sysadmin_3qni.htm">System Administration</a> for details about the CryptoAPI registry usage.</td>
</tr>
<tr valign=top>
<td width=53%>NTE_PROV_TYPE_NO_MATCH</td>
<td width=47%>The provider type specified by <i>dwProvType</i> does not match the provider type found in the registry. Note that this error can only occur when <i>pszProvider</i> specifies an actual CSP name.</td>
</tr>
<tr valign=top>
<td width=53%>NTE_PROV_TYPE_NOT_DEF</td>
<td width=47%>No registry entry exists for the provider type specified by <i>dwProvType</i>.</td>
</tr>
<tr valign=top>
<td width=53%>NTE_PROVIDER_DLL_FAIL</td>
<td width=47%>The provider DLL file could not be loaded, and may not exist. If it exists, then the file is not a valid DLL.</td>
</tr>
<tr valign=top>
<td width=53%>NTE_SIGNATURE_FILE_BAD</td>
<td width=47%>An error occurred while loading the DLL file image, prior to verifying its signature.</td>
</tr>
</table><br>
<h4>Example</h4>
<pre><code>#include &lt;wincrypt.h&gt;

HCRYPTPROV hProv = 0;
BYTE pbData[1000];
DWORD cbData;

// Get a handle to the default PROV_RSA_FULL provider.
if(!CryptAcquireContext(&amp;hProv, NULL, NULL, PROV_RSA_FULL, 0)) {
    printf("Error %x during CryptAcquireContext!\n", GetLastError());
    return;
}

// Read the name of the default CSP.
cbData = 1000;
if(!CryptGetProvParam(hProv, PP_NAME, pbData, &amp;cbData, 0)) {
    printf("Error %x reading CSP name!\n", GetLastError());
    return;
}
printf("Provider name: %s\n", pbData);

// Read the name of the default key container.
cbData = 1000;
if(!CryptGetProvParam(hProv, PP_CONTAINER, pbData, &amp;cbData, 0)) {
    printf("Error %x reading key container name!\n", GetLastError());
    return;
}
printf("Key Container name: %s\n", pbData);

// Perform cryptographic operations.
...

// Release the provider handle.
if(!CryptReleaseContext(hProv, 0)) {
    printf("Error %x during CryptReleaseContext!\n", GetLastError());
    return;
}

// ****************************************************************

// Get a handle to the Microsoft Base Cryptographic Provider and the 
// "KC1" key container.
if(!CryptAcquireContext(&amp;hProv, TEXT("KC1"), MS_DEF_PROV, 
                        PROV_RSA_FULL, 0)) {
    printf("Error %x during CryptAcquireContext!\n", GetLastError());
    return;
}

// Perform cryptographic operations.
...

// Release the provider handle.
if(!CryptReleaseContext(hProv, 0)) {
    printf("Error %x during CryptReleaseContext!\n", GetLastError());
    return;
}

// ****************************************************************

// Get a handle to the default provider. Create a new key container 
// named "KC2". Note that this key container will be empty until keys
// are explicitly created with the CryptGenKey function.
lstrcpy(szProv, );
lstrcpy(szContainer, );
if(!CryptAcquireContext(&amp;hProv, TEXT("KC2"), NULL, PROV_RSA_FULL,
                        CRYPT_NEWKEYSET)) {
    printf("Error %x during CryptAcquireContext!\n", GetLastError());
    return;
}

// Perform cryptographic operations.
...

// Release the provider handle.
if(!CryptReleaseContext(hProv, 0)) {
    printf("Error %x during CryptReleaseContext!\n", GetLastError());
    return;
}
 </code></pre>
<p class=indent1>
For more examples, see <a href="llmf_7dut.htm">Hashed Message Example Code</a>, <a href="llmf_0igh.htm">Enveloped Message Example 1</a>, <a href="llmf_0igi.htm">Enveloped Message Example 2</a>, <a href="xchgkeys_3ko5.htm">Sender Code Example</a>, and <a href="smf_1jtx.htm">Example Code Using CryptEncryptMessage</a>. </p>
<h4>QuickInfo</h4>
<p>
<b>&nbsp;&nbsp;Windows NT: </b>Requires version 4.0 or later.<br>
<b>&nbsp;&nbsp;Windows: </b>Requires Windows 95 OSR2 or later (or Windows 95 with IE 3.02 or later).<br>
<b>&nbsp;&nbsp;Windows CE: </b>Unsupported.<br>
<b>&nbsp;&nbsp;Header: </b>Declared in wincrypt.h.<br>
<b>&nbsp;&nbsp;Import Library: </b>Use advapi32.lib.<br>
<b>&nbsp;&nbsp;Unicode: </b>Defined as Unicode and ANSI prototypes.</p>
<h4>See Also</h4>
<p>
<a href="capifunc_4ptl.htm"><b>CryptGenKey</b></a>, <a href="capifunc_4vxp.htm"><b>CryptGetProvParam</b></a>, <a href="capifunc_62no.htm"><b>CryptReleaseContext</b></a> </p>
<p>&nbsp;</p></body>
</HTML>
