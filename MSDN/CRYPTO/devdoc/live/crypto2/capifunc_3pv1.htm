<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CryptSetKeyParam</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_crypto2_cryptsetkeyparam"></a>CryptSetKeyParam</h1>
<p>
The <b>CryptSetKeyParam</b> function customizes various aspects of a key's operations.</p>
<p>
Generally, this function is used to set session-specific parameters on symmetric keys. </p>
<p>
<a href="msprov_554g.htm">The Microsoft Base Cryptographic Provider</a> has no parameters that can be set on key exchange or signature keys. However, custom providers may define parameters that can be set on these keys.</p>
<pre><code><b>#include &lt;wincrypt.h&gt;
BOOL WINAPI CryptSetKeyParam(
  HCRYPTKEY</b><i> hKey</i><b>, </b>// in
<b>  DWORD</b><i> dwParam</i><b>,  </b>// in
<b>  BYTE </b><i>*pbData</i><b>,   </b>// in
<b>  DWORD</b><i> dwFlags   </i>// in
<b>);</b>
 </code></pre>
<h4>Parameters</h4>
<dl>
<dt>
<i>hKey</i></dt>
<dd>
Handle to the key on which to set parameters.</dd>
<dt>
<i>dwParam</i></dt>
<dd>
The parameter number. See the "Remarks" section for a list of valid parameters.</dd>
<dt>
<i>pbData</i></dt>
<dd>
The parameter data buffer. Place the parameter data in this buffer before calling <b>CryptSetKeyParam</b>. The form of this data will vary, depending on the parameter number.</dd>
<dt>
<i>dwFlags</i></dt>
<dd>
The flag values. This parameter is reserved for future use and should always be zero.
</dd>
</dl>
<h4>Return Values</h4>
<p>
If the function succeeds, the return value is TRUE. If it fails, the return value is FALSE. To retrieve extended error information, use the <b>GetLastError</b> function.</p>
<p>
The following table lists the error codes most commonly returned by the <b>GetLastError</b> function. The error codes prefaced by "NTE" are generated by the particular CSP you are using.</p>
<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=48%>Error code</th>
<th align=left width=52%>Description</th>
</tr>
<tr valign=top>
<td width=48%>ERROR_INVALID_HANDLE</td>
<td width=52%>One of the parameters specifies an invalid handle. </td>
</tr>
<tr valign=top>
<td width=48%>ERROR_BUSY</td>
<td width=52%>The CSP context is currently being used by another process.</td>
</tr>
<tr valign=top>
<td width=48%>ERROR_INVALID_PARAMETER</td>
<td width=52%>One of the parameters contains an invalid value. This is most often an illegal pointer.</td>
</tr>
<tr valign=top>
<td width=48%>NTE_BAD_FLAGS</td>
<td width=52%>The <i>dwFlags</i> parameter is nonzero or the <i>pbData</i> buffer contains an invalid value.</td>
</tr>
<tr valign=top>
<td width=48%>NTE_BAD_TYPE</td>
<td width=52%>The <i>dwParam</i> parameter specifies an unknown parameter.</td>
</tr>
<tr valign=top>
<td width=48%>NTE_BAD_UID</td>
<td width=52%>The CSP context that was specified when the <i>hKey</i> key was created cannot be found.</td>
</tr>
<tr valign=top>
<td width=48%>NTE_FAIL</td>
<td width=52%>The function failed in some unexpected way.</td>
</tr>
<tr valign=top>
<td width=48%>NTE_FIXEDPARAMETERS</td>
<td width=52%>Some <a href="cryptcsp/signcsp_6rn7.htm">CSPs</a> will have hard coded P, Q, and G values. If this is the case, then using the KP_P, KP_Q, and KP_G for the value of <i>dwParam</i> will cause this error.</td>
</tr>
</table><br>
<h4>Remarks</h4>
<p>
For all session key types, the <i>dwParam</i> value can be set to one of the following key parameter types.</p>
<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=31%>Parameter type</th>
<th align=left width=69%>Description</th>
</tr>
<tr valign=top>
<td width=31%>KP_SALT</td>
<td width=69%>The salt value. The <i>pbData</i> buffer should contain a <b>BYTE</b> array specifying a new salt value. This value is made part of the session key. The size of the salt value will vary depending on the CSP being used, so before setting this parameter, it should be read by using <a href="capifunc_6d9p.htm"><b>CryptGetKeyParam</b></a> in order to determine its size.<p>
When you suspect that the base data used for derived keys is less than ideal, salt values are often used to make the session keys more unique. This makes dictionary attacks more difficult.</p>
<p>
When using the Microsoft Base Cryptographic Provider, this parameter defaults to zero.</p>
</td>
</tr>
<tr valign=top>
<td width=31%>KP_SALT_EX</td>
<td width=69%>To set a salt value, a user can call the <b>CryptSetKeyParam</b> function with the KP_SALT_EX parameter value specified and with the <i>pbData</i> parameter pointing to a <b>CRYPTOAPI_BLOB</b> structure containing the salt. For more information, see <a href="apndx_c_5jtx.htm">Specifying a Salt Value</a>. </td>
</tr>
<tr valign=top>
<td width=31%>KP_PERMISSIONS</td>
<td width=69%>The key permissions flags. The <i>pbData</i> buffer should contain a <b>DWORD</b> value specifying zero or more permission flags. Refer to the <a href="capifunc_6d9p.htm"><b>CryptGetKeyParam</b></a> function for a description of these flags.<p>
When using the Microsoft Base Cryptographic Provider, this parameter defaults to 0xFFFFFFFF.</p>
</td>
</tr>
</table><br>
<p>
If a DSS key is specified by <i>hKey</i>, the <i>dwParam</i> value can also be set to one of the following parameter types.</p>
<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=31%>Parameter type</th>
<th align=left width=69%>Description</th>
</tr>
<tr valign=top>
<td width=31%>KP_P</td>
<td width=69%>The <i>pbData</i> buffer should contain a pointer to the prime modulus P from the DSS key blob that is to be set. The data is in the form of a <a href="structs_0zmt.htm"><b>BLOB Structure</b></a> where the <i>pbData</i> member is the value and the <i>cbData</i> member is the length of the value. The value is expected with no header information and in little endian form.</td>
</tr>
<tr valign=top>
<td width=31%>KP_Q</td>
<td width=69%>The <i>pbData</i> buffer should contain a pointer to the prime Q from the DSS key blob that is to be set. The data is in the form of a <a href="structs_0zmt.htm"><b>BLOB Structure</b></a> where the <i>pbData</i> member is the value and the <i>cbData</i> member is the length of the value. The value is expected with no header information and in little endian form.</td>
</tr>
<tr valign=top>
<td width=31%>KP_G</td>
<td width=69%>The <i>pbData</i> buffer should contain a pointer to the generator G from the DSS key blob that is to be set The data is in the form of a <a href="structs_0zmt.htm"><b>BLOB Structure</b></a>, where the <i>pbData</i> member is the value and the <i>cbData</i> member is the length of the value. The value is expected with no header information and in little endian form.</td>
</tr>
<tr valign=top>
<td width=31%>KP_X</td>
<td width=69%>Once the P, Q, and G values have been set, a call can be made to <b>CryptSetKeyParam</b> specifying the KP_X value for <i>dwParam</i> and NULL for the <i>pbData</i> parameter. This will cause the X and Y values to be generated.</td>
</tr>
</table><br>
<p>
If a block cipher session key is specified by <i>hKey</i>, the <i>dwParam</i> value can also be set to one of the following parameter types.</p>
<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=28%>Parameter type</th>
<th align=left width=72%>Description</th>
</tr>
<tr valign=top>
<td width=28%>KP_EFFECTIVE_<br>
KEYLEN</td>
<td width=72%>This parameter may be used only with RC2 keys and has been added due to the previous implementation of <b>CryptSetKeyParam</b> in the Microsoft® Windows NT® version 4.0 Service Pack 2 MS Enhanced Provider. In that implementation the RC2 keys in the Enhanced Provider were 128 bits in strength, but the effective key length used to expand keys into the key table was only 40 bits. This reduced the strength of the algorithm to 40 bits.<p>
To maintain backward compatibility, the previous implementation will remain as is. However, the effective key length may be set to be greater than 40 bits by using this parameter value in the <b>CryptSetKeyParam</b> call. The effective key length is passed in the <i>pbData</i> parameter as a pointer to a DWORD with the effective key length value. The minimum effective key length on the Microsoft Base Cryptographic Provider is 1 and the maximum is 40. In the MS Enhanced Provider the minimum is 1 and the maximum is 1024. The key length must be set prior to encrypting or decrypting with the key.</p>
</td>
</tr>
<tr valign=top>
<td width=28%>KP_IV</td>
<td width=72%>The initialization vector. The <i>pbData</i> buffer should contain a <b>BYTE</b> array specifying the initialization vector. This array should contain <i>block_length</i>/8 elements. For example, if the block length is 64 bits, the initialization vector will consist of eight bytes.<p>
When using the Microsoft Base Cryptographic Provider, this parameter defaults to zero.</p>
</td>
</tr>
<tr valign=top>
<td width=28%>KP_PADDING</td>
<td width=72%>The padding mode. The <i>pbData</i> buffer should contain a <b>DWORD</b> value specifying the padding method to be used by the cipher. Following are the padding modes currently defined:<p>
PKCS5_PADDING. PKCS 5 (sec 6.2) padding method.</p>
<p>
When using the Microsoft Base Cryptographic Provider, this parameter defaults to PKCS5_PADDING.</p>
</td>
</tr>
<tr valign=top>
<td width=28%>KP_MODE</td>
<td width=72%>The cipher mode. The <i>pbData</i> buffer should contain a <b>DWORD</b> value specifying the cipher mode to be used. Refer to the <a href="capifunc_6d9p.htm"><b>CryptGetKeyParam</b></a> function for a list of the defined cipher modes.<p>
When using the Microsoft Base Cryptographic Provider, this parameter defaults to CRYPT_MODE_CBC.</p>
</td>
</tr>
<tr valign=top>
<td width=28%>KP_MODE_BITS</td>
<td width=72%>The number of bits to feed back. The <i>pbData</i> buffer contains a <b>DWORD</b> value indicating the number of bits that are processed per cycle when the OFB or CFB cipher mode is used.<p>
When using the Microsoft Base Cryptographic Provider, this parameter defaults to eight.</p>
</td>
</tr>
</table><br>
<h4>Example</h4>
<pre><code>#include &lt;wincrypt.h&gt;

HCRYPTPROV hProv = 0;
HCRYPTKEY hKey = 0;
DWORD dwMode;
BYTE pbData[16];
DWORD dwCount;
DWORD i;

// Get a handle to the user default provider.
if(!CryptAcquireContext(&amp;hProv, NULL, NULL, PROV_RSA_FULL, 0)) {
    printf("Error %x during CryptAcquireContext!\n", GetLastError());
    goto done;
}

// Create a random block cipher session key.
if(!CryptGenKey(hProv, CALG_RC2, CRYPT_EXPORTABLE, &amp;hKey)) {
    printf("Error %x during CryptGenKey!\n", GetLastError());
    goto done;
}

// Set the cipher mode.
dwMode = CRYPT_MODE_ECB;
if(!CryptSetKeyParam(hKey, KP_MODE, &amp;dwMode, 0)) {
    printf("Error %x during CryptSetKeyParam!\n", GetLastError());
    goto done;
}

// Generate a random initialization vector.
if(!CryptGenRandom(hProv, 8, pbData)) {
    printf("Error %x during CryptGenRandom!\n", GetLastError());
    goto done;
}

// Set the initialization vector.
if(!CryptSetKeyParam(hKey, KP_IV, pbData, 0)) {
    printf("Error %x during CryptSetKeyParam!\n", GetLastError());
    goto done;
}

// Use 'hKey' to encrypt a message.
...

done:

// Destroy the session key.
if(hKey != 0) CryptDestroyKey(hKey);

// Release the provider handle.
if(hProv != 0) CryptReleaseContext(hProv, 0);
 </code></pre>
<h4>QuickInfo</h4>
<p>
<b>&nbsp;&nbsp;Windows NT: </b>Requires version 4.0 or later.<br>
<b>&nbsp;&nbsp;Windows: </b>Requires Windows 95 OSR2 or later (or Windows 95 with IE 3.02 or later).<br>
<b>&nbsp;&nbsp;Windows CE: </b>Unsupported.<br>
<b>&nbsp;&nbsp;Header: </b>Declared in wincrypt.h.<br>
<b>&nbsp;&nbsp;Import Library: </b>Use advapi32.lib.</p>
<h4>See Also</h4>
<p>
<a href="capifunc_4ptl.htm"><b>CryptGenKey</b></a>, <a href="capifunc_6d9p.htm"><b>CryptGetKeyParam</b></a> </p>
<p>&nbsp;</p></body>
</HTML>
