<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CryptSignAndEncryptMessage</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_crypto2_cryptsignandencryptmessage"></a>CryptSignAndEncryptMessage</h1>
<p>
The <b>CryptSignAndEncryptMessage</b> function creates a hash of the specified content, signs the hash, encrypts the content and the signed hash, and then encodes the encrypted content and signed hash (encrypted message). The result is the same as if you first signed and then encrypted separately.</p>
<pre><code><b>#include &lt;wincrypt.h&gt;
BOOL WINAPI CryptSignAndEncryptMessage(
  PCRYPT_SIGN_MESSAGE_PARA</b><i> pSignPara</i><b>,       </b>// in
<b>  PCRYPT_ENCRYPT_MESSAGE_PARA</b><i> pEncryptPara</i><b>, </b>// in
<b>  DWORD</b><i> cRecipientCert</i><b>,                     </b>// in
<b>  PCCERT_CONTEXT </b><i>rgpRecipientCert[ ]</i><b>,       </b>// in
<b>  const BYTE *</b><i>pbToBeSignedAndEncrypted</i><b>,     </b>// in
<b>  DWORD</b><i> cbToBeSignedAndEncrypted</i><b>,           </b>// in
<b>  BYTE *</b><i>pbSignedAndEncryptedBlob</i><b>,           </b>// out
<b>  DWORD *</b><i>pcbSignedAndEncryptedBlob          </i>// in/out
<b>);</b>
 </code></pre>
<h4>Parameters</h4>
<dl>
<dt>
<i>pSignPara</i></dt>
<dd>
Pointer to the signature parameters. For details, see <a href="structs_3noz.htm">Simplified Message Data Structures</a>. </dd>
<dt>
<i>pEncryptPara</i></dt>
<dd>
Pointer to the encryption parameters. For details, see Simplified Message Data Structures.</dd>
<dt>
<i>cRecipientCert</i></dt>
<dd>
Number of array elements in <i>rgpRecipientCert</i>[]<i>.</i></dd>
<dt>
<i>rgpRecipientCert</i>[]</dt>
<dd>
Array of pointers to the certificate contexts of the intended recipients of the message.</dd>
<dt>
<i>pbToBeSignedAndEncrypted</i></dt>
<dd>
Pointer to the content that is to be signed and encrypted.</dd>
<dt>
<i>cbToBeSignedAndEncrypted</i></dt>
<dd>
Size, in bytes, of the content located at *<i>pbToBeSignedAndEncrypted</i>.</dd>
<dt>
<i>pbSignedAndEncryptedBlob</i></dt>
<dd>
Pointer to a buffer that receives the encrypted and encoded message. 
<p>
This parameter can be NULL to set the size of this information for memory allocation purposes. For more information, see <a href="refoview_46pf.htm">Common In/Out Parameter Conventions</a>. 
</dd>
<dt>
<i>pcbSignedAndEncryptedBlob</i></dt>
<dd>
Pointer to a variable that specifies the size, in bytes, of the buffer pointed to by the <i>pbSignedAndEncryptedBlob</i> parameter. When the function returns, this variable contains the size, in bytes, of the signed and encrypted message copied to *<i>pbSignedAndEncryptedBlob</i>.
<p>
Note that when processing the data returned in the buffer, applications need to use the actual size of the data returned. The actual size may be slightly smaller than the size of the buffer specified on input. (On input, buffer sizes are usually specified large enough to insure that the largest possible output data will fit in the buffer.) On output, the variable pointed to by this parameter is updated to reflect the actual size of the data copied to the buffer.

</dd>
</dl>
<h4>Return Values</h4>
<p>
TRUE if the function succeeded. FALSE if the function failed. </p>
<p>
Call <b>GetLastError</b> to see the reason for any failures. Note that errors from the called functions <a href="sca_8skl.htm"><b>CryptSignMessage</b></a> and <a href="sca_11d1.htm"><b>CryptEncryptMessage</b></a> may be propagated to this function.</p>
<p>
This function has the following error codes.</p>
<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=40%>Error code</th>
<th align=left width=60%>Description</th>
</tr>
<tr valign=top>
<td width=40%>ERROR_MORE_DATA</td>
<td width=60%>If the buffer specified by the <i>pbSignedAndEncryptedBlob </i>parameter is not large enough to hold the returned data, the function sets the ERROR_MORE_DATA code, and stores the required buffer size, in bytes, into the variable pointed to by <i>pcbSignedAndEncryptedBlob</i>.</td>
</tr>
</table><br>
<h4>Example</h4>
<pre><code>// EXAMPLE CODE FOR USING CryptSignAndEncryptMessage() to sign and 
// encrypt a single message.

// Assume that the application already knows the addresses of the
// recipient certification array (rgpRecipientCert[]), the number of elements
// in rgcRecipientCert[] (cRecipientCert), the message to be signed and
// encrypted (pbToBeSignedAndEncrypted), and the size of the message 
// (cbToBeSignedAndEnctypted).

// Set up the variables.
CRYPT_SIGN_MESSAGE_PARA     SignPara;       //Struct initialized
                                            //   elsewhere
CRYPT_ENCRYPT_MESSAGE_PARA  EncryptPara;    //Struct initialized
                                            //   elsewhere
DWORD            cRecipientCert = 1;        // Initialized elsewhere
PCCERT_CONTEXT   rgpRecipientCert[1];       // Initialized elsewhere
const BYTE*      pbToBeSignedAndEncrypted;  // Initialized 
                                            //   elsewhere
DWORD            cbToBeSignedAndEncrypted;  // Initialized 
                                            //   elsewhere
DWORD            cbSignedAndEncryptedBlob;

// Call CryptSignAndEncryptMessage to get the size of the signed and 
// encrypted message. 
BOOL             fReturn =  FALSE;

fReturn = CryptSignAndEncryptMessage(&amp;SignPara, &amp;EncryptPara, 
          cRecipientCert, rgpRecipientCert, 
          pbToBeSignedAndEncrypted, cbToBeSignedAndEncrypted, 
          NULL, &amp;cbSignedAndEncryptedBlob);
if(fReturn != TRUE)
    ;// Function call failed.  Handle the error.

// If the call succeeded, the size of the signed and encrypted message,
// in bytes, now resides in cbSignedAndEncryptedBlob.

// Malloc memory for the size of the signed and encrypted message.
BYTE* pbSignedAndEncryptedBlob;

pbSignedAndEncryptedBlob = (BYTE*)malloc(cbSignedAndEncryptedBlob);
if(pbSignedAndEncryptedBlob == NULL)
    ;// Handle the memory allocation error.

// Call CryptSignAndEncryptMessage to return the signed and encrypted 
// message.
fReturn = CryptSignAndEncryptMessage(&amp;SignPara, &amp;EncryptPara, 
          cRecipientCert, rgpRecipientCert, 
          pbToBeSignedAndEncrypted, cbToBeSignedAndEncrypted, 
          pbSignedAndEncryptedBlob, &amp;cbSignedAndEncryptedBlob);
if(fReturn != TRUE)
    ;// Function call failed.  Handle the error.

// If the function succeeded, the signed and encrypted message is now
// at the location pointed to by pbSignedAndEncryptedBlob.

// Process the message.
...

// Free memory.
free (pbSignedAndEncryptedBlob);
 </code></pre>
<h4>QuickInfo</h4>
<p>
<b>&nbsp;&nbsp;Windows NT: </b>Requires version 4.0 SP3 or later. Available also in IE 3.02 and later.<br>
<b>&nbsp;&nbsp;Windows: </b>Requires Windows 98 (or Windows 95 with IE 3.02 or later).<br>
<b>&nbsp;&nbsp;Windows CE: </b>Unsupported.<br>
<b>&nbsp;&nbsp;Header: </b>Declared in wincrypt.h.<br>
<b>&nbsp;&nbsp;Import Library: </b>Use crypt32.lib.</p>
<h4>See Also</h4>
<p>
<a href="sca_8skl.htm"><b>CryptSignMessage</b></a><b> </b></p>
<p>&nbsp;</p></body>
</HTML>
