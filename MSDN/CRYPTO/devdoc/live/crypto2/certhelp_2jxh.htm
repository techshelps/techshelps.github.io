<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CryptHashCertificate</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_crypto2_crypthashcertificate"></a>CryptHashCertificate</h1>
<p>
The <b>CryptHashCertificate</b> function hashes the entire encoded content, including the signature.</p>
<pre><code><b>#include &lt;wincrypt.h&gt;
BOOL WINAPI CryptHashCertificate(
  HCRYPTPROV</b><i> hCryptProv</i><b>,     </b>// in
<b>  ALG_ID</b><i> Algid</i><b>,              </b>// in
<b>  DWORD</b><i> dwFlags</i><b>,             </b>// in
<b>  const BYTE </b>*<i>pbEncoded</i><b>,     </b>// in
<b>  DWORD</b><i> cbEncoded</i><b>,           </b>// in
<b>  BYTE </b><i>*pbComputedHash</i><b>,      </b>// out
<b>  DWORD </b><i>*pcbComputedHash     </i>// in, out
<b>);</b>
 </code></pre>
<h4>Parameters</h4>
<dl>
<dt>
<i>hCryptProv</i></dt>
<dd>
Specifies the Cryptographic Service Provider to use to compute the hash.
<p>
Unless there is a strong reason for passing in a specific cryptographic provider in <b>hCryptProv</b>, zero should be passed in. Passing in zero causes the default RSA or DSS provider to be acquired before doing hash, signature verification or recipient encryption operations.
</dd>
<dt>
<i>Algid</i></dt>
<dd>
Specifies the CryptoAPI hash algorithm to use. If <i>Algid</i> is zero, the default hash algorithm, SHA1, is used.</dd>
<dt>
<i>dwFlags</i></dt>
<dd>
These flags are passed through to <a href="capifunc_5kfc.htm"><b>CryptCreateHash</b></a>. See it for details.</dd>
<dt>
<i>pbEncoded</i></dt>
<dd>
The address of the encoded content that is to be hashed.</dd>
<dt>
<i>cbEncoded</i></dt>
<dd>
The size, in bytes, of the encoded content.</dd>
<dt>
<i>pbComputedHash</i></dt>
<dd>
Pointer to a buffer that receives the computed hash.
<p>
This parameter can be NULL to set the size of this information for memory allocation purposes. For more information, see <a href="refoview_46pf.htm">Common In/Out Parameter Conventions</a>. 
</dd>
<dt>
<i>pcbComputedHash</i></dt>
<dd>
Pointer to a <b>DWORD </b>that contains the size, in bytes, of the buffer pointed to by the <i>pbComputedHash </i>parameter. When the function returns, the variable pointed to by the <i>pcbComputedHash </i>parameter contains the number of bytes stored in the buffer. This parameter can be NULL only if <i>pbComputedHash </i>is NULL.

<p>
<b>Note</b>&nbsp;&nbsp;When processing the data returned in the buffer, applications need to use the actual size of the data returned. The actual size may be slightly smaller than the size of the buffer specified on input. (On input, buffer sizes are usually specified large enough to insure that the largest possible output data will fit in the buffer.) On output, the variable pointed to by this parameter is updated to reflect the actual size of the data copied to the buffer.

</dd>
</dl>
<h4>Return Values</h4>
<p>
TRUE if the function succeeded, FALSE if the function failed.</p>
<p>
Call <b>GetLastError</b> to see the reason for any failures. Note that errors from the called functions <a href="capifunc_5kfc.htm"><b>CryptCreateHash</b></a>,<b> <a href="capifunc_7inh.htm">CryptGetHashParam</a></b> and <a href="capifunc_8c81.htm"><b>CryptHashData</b></a> may be propagated to this function.</p>
<h4>Example</h4>
<pre><code>// EXAMPLE CODE FOR USING CryptHashCertificate() to 
// hash a certificate for which a certificate context has already
// been obtained (pCertContext).
PCCERT_CONTEXT pCertContext; // Initialized elsewhere

// First, get a cryptographic provider.
HCRYPTPROV hCryptProv = NULL; // Handle returned here
BOOL fReturn = FALSE;

fReturn = CryptAcquireContext(
          &amp;hCryptProv,         // Address for handle to be returned.
          NULL,                // Use the current user's logon name.
          NULL,                // Use the default provider.
          PROV_RSA_FULL,       // Need to do both encrypt &amp; sign.
          NULL);               // No flags needed.
if(TRUE != fReturn)
    printf("Couldn't Get a Cryptographic Provider");

// If the function succeeded, the handle to the cryptographic
// provider resides at hCryptProv.

DWORD  maxSHAhashlen = 20; // The max size hash for SHA is 20 bytes.
BYTE * pbComputedHash;     // Buffer pointer.

// Allocate the memory for the computed hash.
pbComputedHash = (BYTE *)malloc(maxSHAhashlen );

// Hash the certificate using SHA for the hashing algorithm.
fReturn = CryptHashCertificate(hCryptProv, CALG_SHA, 0, 
                               pCertContext-&gt;pbCertEncoded,
                               pCertContext-&gt;cbCertEncoded,
                               pbComputedHash , &amp;maxSHAhashlen );

// Use the hash as desired…

// Free memory allocated when through.
free(pbComputedHash);

// Note : An alternate way of obtaining the CALG_SHA hash is to 
// make a call to CertGetCertificateContextProperty specifying 
// CERT_SHA1_HASH_PROP_ID which calculates the hash if it has not 
// already been calculated. If it already has been calculated,
// a throughput benefit is realized.
 </code></pre>
<h4>QuickInfo</h4>
<p>
<b>&nbsp;&nbsp;Windows NT: </b>Requires version 4.0 SP3 or later. Available also in IE 3.02 and later.<br>
<b>&nbsp;&nbsp;Windows: </b>Requires Windows 98 (or Windows 95 with IE 3.02 or later).<br>
<b>&nbsp;&nbsp;Windows CE: </b>Unsupported.<br>
<b>&nbsp;&nbsp;Header: </b>Declared in wincrypt.h.<br>
<b>&nbsp;&nbsp;Import Library: </b>Use crypt32.lib.</p>
<h4>See Also</h4>
<p>
<a href="certhelp_4m0f.htm"><b>CryptHashPublicKeyInfo</b></a>,<b> <a href="certhelp_60mc.htm">CryptHashToBeSigned</a> </b></p>
<p>&nbsp;</p></body>
</HTML>
