<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CryptSignCertificate</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_crypto2_cryptsigncertificate"></a>CryptSignCertificate</h1>
<p>
The <b>CryptSignCertificate</b> function signs the "to be signed" information in the encoded signed content.</p>
<pre><code><b>#include &lt;wincrypt.h&gt;
BOOL WINAPI CryptSignCertificate(
  HCRYPTPROV</b><i> hCryptProv</i><b>,                            </b>// in
<b>  DWORD</b><i> dwKeySpec</i><b>,                                  </b>// in
<b>  DWORD</b><i> dwCertEncodingType</i><b>,                         </b>// in
<b>  BYTE </b><i>*pbEncodedToBeSigned</i><b>,                        </b>// in, constant
<b>  DWORD</b><i> cbEncodedToBeSigned</i><b>,                        </b>// in
<b>  PCRYPT_ALGORITHM_IDENTIFIER</b><i> pSignatureAlgorithm</i><b>,  </b>// in
<b>  void </b><i>*pvHashAuxInfo</i><b>,                              </b>// in/optional
<b>  BYTE </b><i>*pbSignature</i><b>,                                </b>// out
<b>  DWORD </b>*<i>pcbSignature                               </i>// in, out
<b>);</b>
 </code></pre>
<h4>Parameters</h4>
<dl>
<dt>
<i>hCryptProv</i></dt>
<dd>
Specifies the Cryptographic Service Provider to use to do the signature.</dd>
<dt>
<i>dwKeySpec</i></dt>
<dd>
Identifies the private key to use from the provider's container. For example, AT_KEYEXCHANGE or AT_SIGNATURE.</dd>
<dt>
<i>dwCertEncodingType</i></dt>
<dd>
The type of encoding used on the certificate. Currently defined certificate encoding types are shown in the following table:
<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=49%>Encoding type</th>
<th align=left width=51%>Value</th>
</tr>
<tr valign=top>
<td width=49%>X509_ASN_ENCODING</td>
<td width=51%>0x00000001</td>
</tr>
</table><br>

</dd>
<dt>
<i>pbEncodedToBeSigned</i></dt>
<dd>
The address of the encoded content to be signed.</dd>
<dt>
<i>cbEncodedToBeSigned</i></dt>
<dd>
The size, in bytes, of the encoded content.</dd>
<dt>
<i>pSignatureAlgorithm</i></dt>
<dd>
CRYPT_ALGORITHM_IDENTIFIER with a member pszObjId that should be set to one of the following:
<p>
szOID_OIWSEC_sha1RSASign<br>
szOID_RSA_MD5RSA  
</dd>
<dt>
<i>pvHashAuxInfo</i></dt>
<dd>
Not currently used. Must be NULL.</dd>
<dt>
<i>pbSignature</i></dt>
<dd>
Pointer to a buffer that receives the signed hash of the content.
<p>
This parameter can be NULL to set the size of this information for memory allocation purposes. For more information, see <a href="refoview_46pf.htm">Common In/Out Parameter Conventions</a>.
</dd>
<dt>
<i>pcbSignature</i></dt>
<dd>
Pointer to a <b>DWORD </b>that contains the size, in bytes, of the buffer pointed to by the <i>pbSignature </i>parameter. When the function returns, the variable pointed to by the <i>pcbSignature </i>parameter contains the number of bytes stored in the buffer. This parameter can be NULL only if <i>pbSignature </i>is NULL.

<p>
<b>Note</b>&nbsp;&nbsp;When processing the data returned in the buffer, applications need to use the actual size of the data returned. The actual size may be slightly smaller than the size of the buffer specified on input. (On input, buffer sizes are usually specified large enough to insure that the largest possible output data will fit in the buffer.) On output, the variable pointed to by this parameter is updated to reflect the actual size of the data copied to the buffer.

</dd>
</dl>
<h4>Return Values</h4>
<p>
TRUE if the function succeeded, FALSE if the function failed.</p>
<p>
Call <b>GetLastError</b> to see the reason for any failures. Note that errors from the called functions <a href="capifunc_5kfc.htm"><b>CryptCreateHash</b></a>,<b> <a href="capifunc_7aco.htm">CryptSignHash</a></b> and <a href="capifunc_8c81.htm"><b>CryptHashData</b></a> may be propagated to this function. This function has the following error codes.</p>
<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=40%>Error code</th>
<th align=left width=60%>Description</th>
</tr>
<tr valign=top>
<td width=40%>ERROR_MORE_DATA</td>
<td width=60%>If the buffer specified by the <i>pbSignature </i>parameter is not large enough to hold the returned data, the function sets the ERROR_MORE_DATA code, and stores the required buffer size, in bytes, into the variable pointed to by <i>pcbSignature</i>.</td>
</tr>
<tr valign=top>
<td width=40%>NTE_BAD_ALGID </td>
<td width=60%>The signature algorithm's Object Identifier doesn't map to a known or supported hash algorithm.</td>
</tr>
</table><br>
<h4>Example</h4>
<pre><code>// EXAMPLE CODE FOR USING CryptSignCertificate().
// Signs the encoded signed content.
// Assume that pointers to the encoded content
// (pbEncodedToBeSigned) and the signature algorithm
// (pSignatureAlgorithm) have already been defined.

// Set up the variables.
HCRYPTPROV hCryptProv = 0;        // Service Provider handle
DWORD dwKeySpec = AT_KEYEXCHANGE; // Private key
DWORD dwCertEncodingType = X509_ASN_ENCODING;
                                  // Type of encoding
BYTE *pbEncodedToBeSigned;        // Initialized elsewhere
DWORD cbEncodedToBeSigned;        // Size of content (bytes)
PCRYPT_ALGORITHM_IDENTIFIER pSignatureAlgorithm;
                                  // Initialized elsewhere
                                  //   Algorithm object identifiers
void *pvHashAuxInfo = NULL;       // Not used- set to NULL
BYTE *pbSignature = NULL;         // Pointer to the signed hash - set
                                  //   to NULL - memory allocation
                                  //   purposes
DWORD cbSignature;                // Signature size (bytes)
BOOL fResult;                     // Return TRUE if function succeeded
                                  //   FALSE if function failed

// Function called the first time to get the pointer
// to the handle to the public key (pcbSignature).
fResult= CryptSignCertificate(
           hCryptProv,
           dwKeySpec,
           dwCertEncodingType,
           pbEncodedToBeSigned,
           cbEncodedToBeSigned,
           pSignatureAlgorithm,
           NULL,             // NULL - set to NULL
           NULL,             // NULL - to determine the size of
                             //   this informaiton - memory allocation
           &amp;cbSignature);
if (!fResult) {              // FALSE
 cout&lt;&lt; "first call to CryptSignCertificate failed"&lt;&lt; endl;
}
else {
 cout&lt;&lt; "first call to CryptSignCertificate successful"&lt;&lt; endl;
 pbSignature = (BYTE *) malloc (cbSignature);
 cout&lt;&lt; "memory allocated"&lt;&lt; endl;
}

// Function call with the address of the signed hash 
fResult= CryptSignCertificate(
           hCryptProv,         // in - 0 is default RSA or DSS
                               //   provider 
           dwKeySpec,          // in - Key from provider's container
           dwCertEncodingType, // in - X509_ASN_ENCODING
           pbEncodedToBeSigned,// in/constant - Pointer to encoded
                               //   content
           cbEncodedToBeSigned,// in
           pSignatureAlgorithm,// in
           pvHashAuxInfo,      // in/optional
           NULL,
           &amp;cbSignature);      // in/out- Pointer handle to public key

if (!fResult) {                // FALSE
 cout&lt;&lt; "Function failed"&lt;&lt; endl
     &lt;&lt; "error code = "&lt;&lt; GetLastError()&lt;&lt; endl;
}
else {                         // TRUE
 cout&lt;&lt; "Function succeeded"&lt;&lt; endl;
}
 </code></pre>
<h4>QuickInfo</h4>
<p>
<b>&nbsp;&nbsp;Windows NT: </b>Requires version 4.0 SP3 or later. Available also in IE 3.02 and later.<br>
<b>&nbsp;&nbsp;Windows: </b>Requires Windows 98 (or Windows 95 with IE 3.02 or later).<br>
<b>&nbsp;&nbsp;Windows CE: </b>Unsupported.<br>
<b>&nbsp;&nbsp;Header: </b>Declared in wincrypt.h.<br>
<b>&nbsp;&nbsp;Import Library: </b>Use crypt32.lib.</p>
<h4>See Also</h4>
<p>
<a href="certhelp_8ag5.htm"><b>CryptSignAndEncodeCertificate</b></a> </p>
<p>&nbsp;</p></body>
</HTML>
