<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Encoding Signed Data</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h3><a name="_crypto2_encoding_signed_data"></a>Encoding Signed Data</h3>
<p>
The general tasks required to encode a signed message are depicted in the following illustration and are described in the list that follows it. There can be multiple signers, hashing algorithms, and certificates. Also, while the illustration shows only certificates, certificate revocation lists (CRL) can be used as well. They would fit into the illustration wherever certificates are shown.</p>
<p>
<img src="images/signmsg2.gif" border=0></p>
<p>
The sequence of events for encoding signed data, as depicted in the previous illustration, is as follows:
<ol>
<li>
The data is created (if necessary) and a pointer to it is retrieved.</li>
<li>
A certificate store is opened that contains the signer's certificate.</li>
<li>
The private key from the certificate is retrieved. There are two properties that must be set on the certificate before using it. One is used to tie a certificate to a particular CSP and, within that CSP, to a particular private key. The other is used to indicate which hashing algorithm is to be used when a digest operation is called for. These need only be set once.</li>
<li>
From the certificate property, the hash algorithm is determined.</li>
<li>
A hash (digest) of the data is created by sending the data through the hashing function.</li>
<li>
The signature is created by using the private key, obtained through the property on the certificate, to encrypt the hash.</li>
<li>
The following data is included in the finished, signed message:<ul>
<li>
The original data to be signed</li>
<li>
The hash algorithms</li>
<li>
The signatures</li>
<li>
The signer info structures, which includes the signerID (certificate issuer and serial number)</li>
<li>
The signer's certificates (optional)</li>
</ul>
</li>
</ol>
<p>
The tasks just illustrated and listed describe the simplest case. A more complex case is when authenticated attributes are included in the message. When the content type is anything but the Data type (a BYTE string), or there is at least one authenticated attribute along with any data type, there are two standard authenticated attributes required: the content (data) type, and the hash of the content. Under these circumstances, the CryptoAPI automatically provides these two required attributes. The low-level message functions hash the authenticated attributes, encrypt the hash with the private key, and provide this as the signature.</p>
<p>
Use the low-level message functions to accomplish the tasks just listed, by using the following procedure.</p>
<h5><img src="../../images/wedge.gif" border=0>&nbsp;&nbsp;&nbsp;&nbsp;To encode a signed message using the CryptoAPI </h5>
<ol>
<li>
Create or retrieve the content.</li>
<li>
Get a cryptographic provider.</li>
<li>
Get the signer certificates.</li>
<li>
Initialize the <a href="structs_89rj.htm"><b>CMSG_SIGNER_ENCODE_INFO</b></a> structure.</li>
<li>
Initialize the <a href="structs_2pyn.htm"><b>CMSG_SIGNED_ENCODE_INFO</b></a> structure.</li>
<li>
Call <a href="llmsg_6gh4.htm"><b>CryptMsgCalculateEncodedLength</b></a> to get the size of the encoded message blob. Allocate memory for it.</li>
<li>
Call <a href="llmsg_5azp.htm"><b>CryptMsgOpenToEncode</b></a>, passing in CMSG_SIGNED for <i>dwMsgType</i>, and a pointer to <b>CMSG_SIGNED_ENCODE_INFO</b> for <i>pvMsgEncodeInfo</i>. As a result of this call, you get a handle to the opened message.</li>
<li>
Call <a href="llmsg_6rtx.htm"><b>CryptMsgUpdate</b></a>, passing in the handle retrieved in step 7, and a pointer to the data that is to be signed and encoded. This function can be called as many times as necessary to complete the encoding process.</li>
<li>
Call <a href="llmsg_6xm5.htm"><b>CryptMsgGetParam</b></a>, passing in the handle retrieved in step 7 and the appropriate parameter types to access the desired, encoded data. For example, pass in CMSG_CONTENT_PARAM to get a pointer to the entire PKCS #7 message.<p>
If the result of this encoding is to be used as the inner data for another encoded message, such as an enveloped message, the CMSG_BARE_CONTENT_PARAM parameter must be passed. For example code showing this, see <a href="llmf_0igi.htm">Enveloped Message Example 2</a>. 
</li>
<li>
Close the message by calling <a href="llmsg_3485.htm"><b>CryptMsgClose</b></a>.</li>
</ol>
<p>
The result of this procedure is an encoded message that contains the original data, the encrypted hash of that data (signature), and the signer information. Also, you now have a pointer pointing to the desired, encoded blob. </p>
<p>&nbsp;</p></body>
</HTML>
