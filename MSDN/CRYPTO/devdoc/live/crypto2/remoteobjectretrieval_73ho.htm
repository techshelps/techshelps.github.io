<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CryptRetrieveObjectByUrl</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_crypto2_cryptretrieveobjectbyurl"></a>CryptRetrieveObjectByUrl</h1>
<p>
<span style=color:#FF0000>[This is preliminary documentation and subject to change.]</span> </p>
<p>
The <b>CryptRetrieveObjectByUrl</b> function retrieves the PKI object where the location is given by an URL.</p>
<p>
These remote objects are in encoded format and are retrieved in a "context" form.</p>
<pre><code><b>#include &lt;wincrypt.h&gt;
BOOL WINAPI CryptRetrieveObjectByUrl(
  LPCTSTR</b><i> pszUrl</i><b>,</b><i>                  </i>// in
<b>  LPCSTR</b><i> pszObjectOid</i><b>,</b><i>            </i> // in
<b>  DWORD</b><i> dwRetrievalFlags</i><b>,</b>          // in
<b>  DWORD</b><i> dwTimeout</i><b>,</b>                 // in
<b>  LPVOID </b><i>*ppvObject</i><b>,</b><i>               </i>// out
<b>  HCRYPTASYNC</b><i> hAsyncRetrieve</i><b>,</b>      // in
<b>  PCRYPT_CREDENTIALS</b><i> pCredentials</i><b>,</b> // in/optional
<b>  LPVOID</b><i> pvVerify</i><b>,</b><i>                 </i>// in/optional
<b>  LPVOID</b><i> pvReserved                </i>// in/optional
<b>);</b>
 </code></pre>
<h4>Parameters</h4>
<dl>
<dt>
<i>pszUrl</i></dt>
<dd>
A LPCTSTR address of a valid URL from which to retrieve the PKI object(s). The following schemes are supported:
<ul>
<li>
ldap</li>
<li>
http</li>
<li>
ftp</li>
<li>
file</li>
</ul>
</dd>
<dt>
<i>pszObjectOid</i></dt>
<dd>
Pointer to the object identifier (OID) of the object(s) to be retrieved. The valid OIDs are as follows:
<table cellspacing=4 cols=3>
<tr valign=top>
<th align=left width=25%>OID Value</th>
<th align=left width=20%>Description</th>
<th align=left width=55%>Returned <i>ppvObject</i> type</th>
</tr>
<tr valign=top>
<td width=25%>NULL</td>
<td width=20%>blob</td>
<td width=55%>Encoded bits are returned in a single buffer with a count, array of pointers, and data which must be freed with <b>CryptMemFree</b>.</td>
</tr>
<tr valign=top>
<td width=25%>CONTEXT_OID_<br>
CERTIFICATE</td>
<td width=20%>certificate</td>
<td width=55%>PCERT_CONTEXT for single object retrieval. HCERTSTORE, which contains the certificates, for multiple object retrieval.</td>
</tr>
<tr valign=top>
<td width=25%>CONTEXT_OID_<br>
CRL</td>
<td width=20%>CRL</td>
<td width=55%>PCRL_CONTEXT for single object retrieval. HCERTSTORE, which contains the CRLs, for multiple object retrieval.</td>
</tr>
<tr valign=top>
<td width=25%>CONTEXT_OID_<br>
CTL</td>
<td width=20%>CTL</td>
<td width=55%>PCTL_CONTEXT for single object retrieval. HCERTSTORE, which contains the CTLs, for multiple object retrieval.</td>
</tr>
<tr valign=top>
<td width=25%>CONTEXT_OID_<br>
PKCS7</td>
<td width=20%>PKCS7</td>
<td width=55%>HCERTSTORE containing the object from the message.</td>
</tr>
<tr valign=top>
<td width=25%>CONTEXT_OID_<br>
CAPI2_ANY</td>
<td width=20%>Function will determine appropriate item</td>
<td width=55%>HCERTSTORE containing the object.</td>
</tr>
</table><br>

</dd>
<dt>
<i>dwRetrievalFlags</i></dt>
<dd>
Retrieval flag values. The flag determines whether the cached URL or a URL retrieved from the wire URL should be utilized. The form in which objects are returned is determined by the <i>pszObjectOid</i>.
<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=32%>Flag value</th>
<th align=left width=68%>Description</th>
</tr>
<tr valign=top>
<td width=32%>CRYPT_RETRIEVE_<br>
MULTIPLE_OBJECTS</td>
<td width=68%>Retrieves multiple objects if available. All objects must be of a homogeneous object type as determined by the <i>pszObjectOid,</i> unless the OID Value is CONTEXT_OID_CAPI2_ANY.</td>
</tr>
<tr valign=top>
<td width=32%>CRYPT_CACHE_<br>
ONLY_RETRIEVAL</td>
<td width=68%>Retrieves the encoded bits from the URL cache only. Do not use the wire to retrieve the URL.</td>
</tr>
<tr valign=top>
<td width=32%>CRYPT_WIRE_ONLY_<br>
RETRIEVAL</td>
<td width=68%>Retrieves the encoded bits from the wire only. Does not use the URL cache.</td>
</tr>
<tr valign=top>
<td width=32%>CRYPT_DONT_<br>
CACHE_RESULT</td>
<td width=68%>Does not store the retrieved encoded bits to the URL cache. If this flag is not set, the retrieved URL is cached.</td>
</tr>
<tr valign=top>
<td width=32%>CRYPT_ASYNC_<br>
RETRIEVAL</td>
<td width=68%>Retrieves the object(s) asynchronously. If this flag is not set, <i>hAsyncRetrieve </i>must be NULL. (This flag is not supported in Windows NT® 5.0 Beta).</td>
</tr>
<tr valign=top>
<td width=32%>CRYPT_VERIFY_<br>
CONTEXT_<br>
SIGNATURE</td>
<td width=68%>Gets signature verification on the context created. In this case <i>pszObjectOid</i> must be non-NULL and <i>pvVerify</i> points to the signer certificate context.</td>
</tr>
<tr valign=top>
<td width=32%>CRYPT_VERIFY_<br>
DATA_HASH</td>
<td width=68%>Gets verification of the blob data retrieved by the protocol. The <i>pvVerify</i> points to an <b>URL_DATA_HASH</b> structure (This flag is not supported in Windows NT 5.0 Beta).</td>
</tr>
</table><br>

</dd>
<dt>
<i>dwTimeout</i></dt>
<dd>
Specifies the maximum number of milliseconds to wait for retrieval. If a value of zero is specified, this function does not time-out. If the URL scheme is file, <i>dwTimeout </i>is not used.</dd>
<dt>
<i>ppvObject</i></dt>
<dd>
Address of pointer variable of the returned object. The return type can be one of the supported type, shown in <i>pszObjectOid</i>.</dd>
<dt>
<i>hAsyncRetrieve</i></dt>
<dd>
Async handle by a scheme provider that supports asynchronous retrieval. If <i>dwRetrievalFlags</i> is not set to CRYPT_ASYNC_RETRIEVAL, this parameter must be NULL. Asynchronous retrieval is not supported in Microsoft® Windows NT® 5.0 Beta 2. Set <i>hAsyncRetrieve</i> to NULL.</dd>
<dt>
<i>pCredentials</i></dt>
<dd>
Pointer to the Credentials structure when accessing the URL. The only type of credentials currently supported are username and password credentials. <i>pCredentials </i>is used only when the object is retrieved from the wire. Do not use <i>pCredentials </i>when using cache-only retrieval (set <i>pCredentials </i>to NULL). If the URL scheme is file, <i>pCredentials </i>is not used.</dd>
<dt>
<i>pvVerify</i></dt>
<dd>
Pointer to a verification object. This object is a function of the <i>dwRetrievalFlags</i>. <i>pvVerify </i>can be NULL, indicating the caller isn't interested in getting the certificate context or index of the signer if <i>dwRetrievalFlags</i> is CRYPT_VERIFY_CONTEXT_SIGNATURE or CRYPT_VERIFY_DATA_HASH.</dd>
<dt>
<i>pvReserved</i></dt>
<dd>
This parameter is reserved for future use and should always be set to NULL.
</dd>
</dl>
<h4>Return Values</h4>
<p>
If the function succeeds, the return value is TRUE. If it does not succeed, the return value is FALSE. To retrieve extended error information, use the <b>GetLastError</b> function.</p>
<h4>Remarks</h4>
<p>
The remote object retrieval manager exposes two provider models. One is the "Scheme Provider" model which allows for installable protocol providers as defined by the URL scheme e.g. ldap, http, ftp, file. The scheme provider entry point is the same as the <b>CryptRetrieveObjectByUrl</b>; however, the *<i>ppvObject</i> returned is ALWAYS a counted array of encoded bits (one per object retrieved).</p>
<p>
The second provider model is the "Context Provider" model that allows for installable creators of the context handles (objects) based on the retrieved encoded bits. These are dispatched based on the object OID given in the call to <b>CryptRetrieveObjectByUrl</b>.</p>
<p>
This functions supports multiple URL schemes such as "http:", "ftp:", "ldap:", "file:" as well as newly defined schemes.</p>
<p>
Retrieval of individual PKI objects, such as certificates, trusts lists, revocation lists, PKCS #7 messages, and multiple homogenous objects is possible.</p>
<h4>Example</h4>
<pre><code>// EXAMPLE CODE FOR USING CryptRetrieveObjectByUrl().
// Assume that a pointer to the URL (pszUrl) and the credentials
// structure (pCredentials) is already known.

// Set up the variables.
LPCTSTR pszUrl;                 // Pointer to a valid URL
LPCSTR pszObjectOid;            // Pointer to an OID
DWORD dwRetrievalFlags;         // Retrieval flag
DWORD dwTimeout;                // Timeout value (milliseconds)
LPVOID* ppvObject;              // Return address
HCRYPTASYNC hAsyncRetrieve;     // Set to NULL- not utilized in
                                //   Windows NT 5.0 Beta
PCRYPT_CREDENTIALS pCredentials;// Pointer to Credentials structure
PCRL_CONTEXT pvVerify;          // Pointer to Verification object
LPVOID pvReserved;              // NULL- reserved for future use
BOOL fResult;                   // Return value- True if function
                                //   successful
                                //   False if function fails       

// call to CryptRetrieveObjectByUrl to get the URL object
fResult= CryptRetrieveObjectByUrl(
           pszUrl,              // in- pszUrl- initialized elsewhere
           CONTEXT_OID_CRL,     // in- OID
           CRYPT_CACHE_ONLY_RETRIEVAL,
                                // in- Use the cache only. Do not go
                                //   onto the wire to retrieve the
                                //   URL.
           0,                   // in- timeout set 0
           ppvObject,           // out- Address of returned object
           NULL,                // in- hAsyncRetrieve- set to NULL
           NULL,                // in/optional- pCredentials set to
                                //   NULL, using cache only
           NULL,                // in/optional- pvVerify- not
                                //   interested in getting signer's
                                //   verification
           NULL);               // in/optional- pvReserved

if (fResult){                   // returned value is TRUE
                                //   CryptGetObjectUrl is successful
  cout&lt;&lt; "Call to CryptRetrieveObjectByUrl successful"&lt;&lt; endl
      &lt;&lt; "The object, "&lt;&lt; ppvObject&lt;&lt; endl
      &lt;&lt; "is at "&lt;&lt; &amp;ppvObject&lt;&lt; endl;
 }
else {                          // returned value is FALSE
  cout&lt;&lt; "Call to CryptRetrieveObjectByUrl failed"&lt;&lt; endl
      &lt;&lt; "error code = "&lt;&lt; GetLastError&lt;&lt; endl;
}
 </code></pre>
<h4>QuickInfo</h4>
<p>
<b>&nbsp;&nbsp;Windows NT: </b>Requires version 5.0 or later.<br>
<b>&nbsp;&nbsp;Windows: </b>Unsupported.<br>
<b>&nbsp;&nbsp;Windows CE: </b>Unsupported.<br>
<b>&nbsp;&nbsp;Header: </b>Declared in wincrypt.h.<br>
<b>&nbsp;&nbsp;Import Library: </b>Use cryptnet.lib.</p>
<p>
</p>
<p>&nbsp;</p></body>
</HTML>
