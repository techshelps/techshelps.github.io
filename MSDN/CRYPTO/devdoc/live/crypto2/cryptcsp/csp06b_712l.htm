<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CPGenRandom</title>
<link disabled rel=stylesheet href=../../../backsdk3.css>
<style type="text/css">
@import url(../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_cryptcsp_cpgenrandom"></a>CPGenRandom</h1>
<p>
The <b>CPGenRandom</b> function fills a buffer with random bytes.</p>
<pre><code><b>BOOL CPGenRandom(
  HCRYPTPROV</b><i> hProv</i><b>,  </b>// in
<b>  DWORD</b><i> dwLen</i><b>,       </b>// in
<b>  BYTE</b><i> *pbBuffer     </i>// in, out
<b>);</b>
 </code></pre>
<h4>Parameters</h4>
<dl>
<dt>
<i>hProv</i></dt>
<dd>
Handle to a particular key container (or "context") within the CSP. This handle is obtained via a call to <a href="csp05b_4mt0.htm"><b>CPAcquireContext</b></a>.</dd>
<dt>
<i>dwLen</i></dt>
<dd>
Number of bytes of random data to be generated.</dd>
<dt>
<i>pbBuffer</i></dt>
<dd>
Buffer to which the function is to copy the random data. This buffer is <i>dwLen</i> bytes in length.
<p>
Upon input to the function, this buffer may contain up to <i>dwLen</i> bytes of random data that the CSP can use in generating a random seed. This is discussed further in the "Remarks" section.

</dd>
</dl>
<h4>Return Values</h4>
<p>
If the function succeeds, TRUE should be returned; otherwise, return FALSE. When FALSE is returned, the appropriate error code (see the following table) must be set via <b>SetLastError</b>.</p>
<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=28%>Error</th>
<th align=left width=72%>Description</th>
</tr>
<tr valign=top>
<td width=28%>NTE_BAD_UID</td>
<td width=72%>The <i>hProv</i> parameter does not contain a valid context handle.</td>
</tr>
<tr valign=top>
<td width=28%>NTE_FAIL</td>
<td width=72%>The function failed in some unexpected manner.</td>
</tr>
</table><br>
<h4>Remarks</h4>
<p>
Although <b>CPGenRandom</b> is one of the more difficult functions to implement correctly, it must be done correctly to maintain the security of your CSP. The <b>CPGenRandom</b> function is (typically) used internally by the <a href="csp06b_5h2x.htm"><b>CPGenKey</b></a> function, as well by applications when generating data items used in cryptographic protocols, such as challenge strings. If the value of the cryptographic keys or challenge strings produced by your CSP is in any way predictable, then your CSP is not doing its job.</p>
<p>
There are two components to a good random number generator: a method of getting a truly random seed and an algorithm that will generate a good pseudo-random stream of data based on the seed.</p>
<p>
Generating a <i>truly</i> random seed can be difficult, depending on the hardware that your CSP is running on. If your CSP has access to a hardware random number source (such as some slightly radioactive material and a Geiger counter), then this doesn't present much of a problem. If your CSP is completely software-based, some of the following sources may be used:
<ul>
<li>
The system time.</li>
<li>
Any high-precision clocks that exist on the system board and peripherals.</li>
<li>
The cursor or mouse pointer location.</li>
<li>
Any accumulated physical state information in keyboard input buffers, I/O service queues, video drivers, and so on.</li>
<li>
The number of tasks in the OS scheduling queue, their task identifiers, or their code base addresses and sizes.</li>
<li>
Data from the application, passed into the <a href="../capifunc_15t9.htm"><b>CryptGenRandom</b></a> function.</li>
</ul>
<p>
All of this data can be hashed together, along with the random seed from the previous session, to make a fairly good random seed. A new seed should be generated periodically throughout the session, to avoid placing too much reliance on the pseudo-random stream generator.</p>
<p>
Once the random seed has been obtained, any number of algorithms can be used to generate a pseudo-random stream of data based on it. Sometimes a stream cipher such as RC4 is used for this purpose (with the seed forming the keying material). The following sources describe other algorithms and techniques:
<ul>
<li>
Bellare, M., and P. Rogaway. <i>Optimal Asymmetric Encryption</i>. Advances in Cryptology—EUROCRYPT '94, ed. by A. deSantis, Springer-Verlag, 1995, pp. 92-111, <i>Lecture Notes in Computer Science</i>, vol. 950.</li>
<li>
Blum, L. , M. Blum, and M. Shub. <i>A Simple Unpredictable Pseudo-Random Number Generator</i>. <i>SIAM Journal on Computing</i> 15(2)(May 1986); 364-383.</li>
<li>
M. Blum and S. Micali, "How to generate cryptographically strong sequences of pseudo-random bits," <i>SIAM Journal on Computing</i> 13(4)(November 1984); 850-864.</li>
</ul>
<h4>See Also</h4>
<p>
<a href="../capifunc_15t9.htm"><b>CryptGenRandom</b></a></p>
<p>&nbsp;</p></body>
</HTML>
