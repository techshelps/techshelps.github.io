<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CPAcquireContext</title>
<link disabled rel=stylesheet href=../../../backsdk3.css>
<style type="text/css">
@import url(../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_cryptcsp_cpacquirecontext"></a>CPAcquireContext</h1>
<p>
The <b>CPAcquireContext</b> function is used to acquire a handle to the key container specified by the <i>pszContainer</i> parameter.</p>
<pre><code><b>BOOL CPAcquireContext(
  HCRYPTPROV</b><i> *phProv</i><b>,       </b>// out
  <b>CHAR</b> <i>*pszContainer</i><b>,</b>       // in, out
<b>  DWORD</b><i> dwFlags</i><b>,            </b>// in
<b>  PVTableProvStruc</b><i> pVTable  </i>// in
<b>);</b>
 </code></pre>
<h4>Parameters</h4>
<dl>
<dt>
<i>phProv</i></dt>
<dd>
Address to which the function copies a handle to the CSP.</dd>
<dt>
<i>pszContainer</i></dt>
<dd>
Key container name. This is a zero-terminated string, of typically no more than MAX_PATH characters, including the terminator. <i>pszContainer</i> is to be set to NULL when <i>dwFlags </i>is set to CRYPT_VERIFYCONTEXT.
<p>
If this parameter is NULL, then a default key container name will be used. For example, the Microsoft® RSA Base Provider uses the logon name of the user currently logged on as the key container name in this situation.

<p>
<i>dwFlags</i>

<p>
Flag values. This parameter is normally zero, but the following flags are allowed:

<dl>
<dt>
CRYPT_VERIFYCONTEXT</dt>
<dd>
If this flag is set, then the application will have no access to the private keys and the <i>pszContainer </i>parameter must be set to NULL.
<p>
This option is intended to be used with applications that will not be using private keys.

<p>
When <a href="../capifunc_0wvo.htm"><b>CryptAcquireContext</b></a> (in the <i>CryptoAPI) </i>is called, many <a href="signcsp_6rn7.htm">CSPs</a> will require input from the owning user before granting access to the private keys in the key container. For example, the private keys may be encrypted, requiring a password from the user before they can be used. However, if the CRYPT_VERIFYCONTEXT flag is specified, access to the private keys is not required and the user interface can be bypassed.
</dd>
<dt>
CRYPT_NEWKEYSET</dt>
<dd>
If this flag is set, then a new key container will be created with the name specified by <i>pszContainer</i>. If <i>pszContainer</i> is NULL, then a key container with the default name will be created.
<p>
The CSP is not required to create any key pairs at this point. Instead, the key pairs are typically generated later via the <a href="csp06b_5h2x.htm"><b>CPGenKey</b></a> function. However, the CSP may generate key pairs during the <b>CPAcquireContext</b> function call at the CSP author's discretion.
</dd>
<dt>
CRYPT_MACHINE_KEYSET</dt>
<dd>
By default keys are stored in the HKEY_CURRENT_USER portion of the registry. The CRYPT_MACHINE_KEYSET flag may be used when calling <a href="../capifunc_0wvo.htm"><b>CryptAcquireContext</b></a> (in the <i>CryptoAPI) </i>with the CRYPT_NEW_KEYSET or CRYPT_DELETE_KEYSET flag and, in this case, the keys will be stored in the HKEY_LOCAL_MACHINE portion of the registry.
<p>
Note that CRYPT MACHINE KEYSET applies specifically to the Microsoft <a href="../csp_62er.htm">Provider Types</a>. Other provider types may store keys differently and should ignore this flag. 

<p>
For <a href="signcsp_6rn7.htm">CSPs</a> to be compatible with the Microsoft Cryptograpic Providers, they should implement the CRYPT MACHINE KEYSET flag. In the case of many CSPs, this may mean just ignoring this flag. This flag is used for keys that are machine keys, which means these keys need to be accessible to applications that are not associated with a user account. It is generally not good practice to have a UI associated with these keys because these keys could easily be used by an unattended server application. Microsoft Providers store keys in the registry and the machine keys are stored in the HKEY_LOCAL_MACHINE portion of the registry. In addition, with the Microsoft Providers, ACLs may be set on these keys by using <a href="csp05b_7v71.htm"><b>CPGetProvParam</b></a> and <a href="csp05b_894d.htm"><b>CPSetProvParam</b></a> with the PP_KEYSET_SEC_DESCR value. CSP writers may want to consider allowing the setting of Microsoft Windows NT® ACLs on keys as well.

</dd>
</dl>

<p>
<b>Note</b>&nbsp;&nbsp;When key containers are created, most CSPs will not automatically create any public/private key pairs. These keys must be created as a separate step by using the <a href="../capifunc_4ptl.htm"><b>CryptGenKey</b></a> function (in the <i>CryptoAPI)</i>.


<dl>
<dt>
CRYPT_DELETEKEYSET.</dt>
<dd>
If this flag is set, then the key container specified by pszContainer is deleted. If <i>pszContainer</i> is NULL, then the key container with the default name is deleted. All key pairs in the key container are also destroyed.
<p>
When the CRYPT_DELETEKEYSET flag is set, the value returned in phProv is undefined and, thus, the <a href="../capifunc_62no.htm"><b>CryptReleaseContext</b></a> function (in the <i>CryptoAPI) </i>need not be called afterwards.
</dd>
</dl>
</dd>
<dt>
pVTable</dt>
<dd>
Pointer to a <b>VTableProvStruct</b> structure that contains a list of functions provided by the operating system for use by the CSP.
<p class=indent1>
This is discussed further in the <b>Remarks</b> section.</p>

</dd>
</dl>
<h4>Return Values</h4>
<p>
If the function succeeds, TRUE should be returned; otherwise, return FALSE. When FALSE is returned, the appropriate error code (see the following table) must be set via <b>SetLastError</b>.</p>
<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=41%>Error</th>
<th align=left width=59%>Description</th>
</tr>
<tr valign=top>
<td width=41%>NTE_BAD_FLAGS</td>
<td width=59%>The <i>dwFlags</i> parameter has an illegal value.</td>
</tr>
<tr valign=top>
<td width=41%>NTE_BAD_KEYSET</td>
<td width=59%>The key container could not be opened, and may not exist.</td>
</tr>
<tr valign=top>
<td width=41%>NTE_BAD_KEYSET_PARAM</td>
<td width=59%>The <i>pszContainer</i> parameter is set to an illegal value.</td>
</tr>
<tr valign=top>
<td width=41%>NTE_BAD_SIGNATURE</td>
<td width=59%>The digital signature of an auxiliary DLL did not verify correctly. Either the DLL or the digital signature has been tampered with.</td>
</tr>
<tr valign=top>
<td width=41%> NTE_EXISTS</td>
<td width=59%>The <i>dwFlags</i> parameter is CRYPT_NEWKEYSET, but the key container already exists.</td>
</tr>
<tr valign=top>
<td width=41%> NTE_KEYSET_ENTRY_BAD</td>
<td width=59%>The registry entry for the pszContainer key container was found but is corrupt </td>
</tr>
<tr valign=top>
<td width=41%> NTE_KEYSET_NOT_DEF</td>
<td width=59%>The key container specified by <i>pszContainer</i> does not exist.</td>
</tr>
<tr valign=top>
<td width=41%> NTE_NO_MEMORY</td>
<td width=59%>The CSP ran out of memory during the operation.</td>
</tr>
<tr valign=top>
<td width=41%> NTE_PROVIDER_DLL_FAIL</td>
<td width=59%>An auxiliary DLL file could not be loaded, and may not exist. If it exists, the file is not a valid DLL.</td>
</tr>
</table><br>
<h4>Remarks</h4>
<p>
The <b>VTableProvStruc</b> structure and the function pointers that it contains are defined as:</p>
<pre><code>typedef struct _VTableProvStruc {
    DWORD   Version;
    FARPROC FuncVerifyImage;
    FARPROC FuncReturnhWnd;
    DWORD   dwProvType;
    BYTE *pbContextInfo;
    DWORD cbContextInfo;
} VTableProvStruc, *PVTableProvStruc;
BOOL FuncVerifyImage(LPCSTR lpszImage, BYTE *pSigData);
BOOL FuncReturnhWnd(DWORD *phWnd);
 </code></pre>
<p>
The <b>Version</b> field is currently always set to 2. The value of this field will be incremented as additional function pointers are added to the structure, or as other changes are made. </p>
<p>
All auxiliary DLLs that your CSP makes function calls into must be signed, in the same manner (and with the same key) as is the primary CSP DLL. To make this work properly, the auxiliary DLLs must be loaded dynamically, via the <b>LoadLib</b> function. But before the <b>LoadLib</b> function is called, the signature of the DLL must be verified. The CSP does this verification by calling the <b>FuncVerifyImage</b> function, as illustrated in the following code fragment.</p>
<pre><code>BOOL (FARPROC *ProvVerifyImage)(LPCSTR lpszImage, BYTE *pSigData);
BYTE bSignature[72];

// "ProvVerifyImage" has been set to "pVTable-&gt;FuncVerifyImage"
// within the CPAcquireContext function.

// Load the c:\winnt40\system32\winfoo.sig file into the 
// bSignature buffer. During development, this file is created 
// with the sign.exe utility.
...

// Verify the signature on the c:\winnt40\system32\winfoo.dll file.
if(RCRYPT_FAILED(ProvVerifyImage("c:\\winnt40\\system32\\winfoo.dll",
                                 bSignature)) {
    SetLastError(NTE_BAD_SIGNATURE);
    return CRYPT_FAILED;
}

// Load the DLL with the LoadLib function, then acquire pointers to 
// the member functions with the GetProcAddress function.
...
 </code></pre>
<p>
The <b>FuncReturnWnd</b> entry in the <b>VTableProvStruc</b> structure can be called by <a href="signcsp_6rn7.htm">CSPs</a> to retrieve a window handle that it is to use when interacting directly with the user via Microsoft Win32®. CSPs that do not communicate directly with the user (and ones that use dedicated hardware for this purpose) can ignore this entry. This window handle is zero by default, but some applications will set it to a different value by using the <a href="../capifunc_59v1.htm"><b>CryptSetProvParam</b></a> function (in the <i>CryptoAPI)</i>.</p>
<p>
The <b>dwProvType</b> field specifies the type of provider to acquire. The following provider types are predefined, and are discussed in detail in <a href="../apndx_a_3zw3.htm">Interoperability with RSA CSPs</a>. 
<ul>
<li>
PROV_RSA_FULL</li>
<li>
PROV_RSA_SIG</li>
<li>
PROV_DSS</li>
<li>
PROV_FORTEZZA</li>
<li>
PROV_MS_EXCHANGE</li>
</ul>
<p>
The <b>pbContextInfo</b> and <b>cbContextInfo</b> fields specifiy the information set when performing a <a href="csp05b_894d.htm"><b>CPSetProvParam</b></a> with the PP_CONTEXT_INFO parameter number specified.</p>
<h4>See Also</h4>
<p>
<a href="csp05b_9sl0.htm"><b>CPReleaseContext</b></a>, <a href="../capifunc_0wvo.htm"><b>CryptAcquireContext</b></a>,<b> <a href="../capifunc_59v1.htm">CryptSetProvParam</a></b></p>
<p>&nbsp;</p></body>
</HTML>
