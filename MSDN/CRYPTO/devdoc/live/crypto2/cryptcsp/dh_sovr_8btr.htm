<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Deriving the Bulk Encryption and MAC Keys (Diffie-Hellman)</title>
<link disabled rel=stylesheet href=../../../backsdk3.css>
<style type="text/css">
@import url(../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_cryptcsp_deriving_the_bulk_encryption_and_mac_keys_diffie_hellman_"></a>Deriving the Bulk Encryption and MAC Keys (Diffie-Hellman)</h1>
<p>
The bulk encryption and MAC keys are mostly derived from the master key but often include a number of other items, depending on the protocol and cipher suite used.</p>
<p>
The process is the same for both client and server:
<ol>
<li>
The protocol engine calls <a href="../capifunc_3pv1.htm"><b>CryptSetKeyParam</b></a> on the master key one or more times, such that the CSP has all of the information necessary to build the keys.</li>
<li>
A hash object is created from the master key via <a href="../capifunc_5kfc.htm"><b>CryptCreateHash</b></a>. This step is necessary because it is not possible to derive CryptoAPI keys directly from other keys.</li>
<li>
The two bulk encryption keys and the two MAC keys are created from the "master hash" object, via four calls to <a href="../capifunc_88jd.htm"><b>CryptDeriveKey</b></a>.</li>
</ol>
<p>
<b>Note</b>&nbsp;&nbsp;When performing SSL "reconnects," the protocol engine may perform the above procedure several times, using the same master key. This enables the client and server to have multiple (often simultaneous) connections, each using different bulk encryption and MAC keys, but without doing any Diffie-Hellman operations.</p>
<p>
As with all CSPs, it is important that good thread-safe practices are used. Thread counts of several dozen are not unusual.</p>
<p>
The protocol engine's source code is typically;</p>
<pre><code>BOOL fClient = &lt;<i>are we a client?</i>&gt;;
CRYPT_DATA_BLOB Data;
HCRYPTHASH hMasterHash;

// Finish creating the master_secret.
switch(<i>&lt;protocol being used&gt;</i>)
{
    case <i>&lt;SSL 3.0&gt;</i>:
    case <i>&lt;TLS 1.0&gt;</i>:

        // Specify client_random.
        Data.pbData = pClientRandom;
        Data.cbData = cbClientRandom;
        CryptSetKeyParam(hMasterKey, KP_CLIENT_RANDOM, 
                         (PBYTE)&amp;Data, 0);

        // Specify server_random.
        Data.pbData = pServerRandom;
        Data.cbData = cbServerRandom;
        CryptSetKeyParam(hMasterKey, KP_SERVER_RANDOM, 
                         (PBYTE)&amp;Data, 0);
}

// Create the master hash object from the master key.
CryptCreateHash(hProv, CALG_SCHANNEL_MASTER_HASH,
                hMasterKey, 0, &amp;hMasterHash);

// Derive read key from the master hash object.
CryptDeriveKey(hProv, 
               CALG_SCHANNEL_ENC_KEY, 
               hMasterHash,
               fClient ? CRYPT_SERVER : 0,
               &amp;hReadKey);

// Derive write key from the master hash object.
CryptDeriveKey(hProv,
               CALG_SCHANNEL_ENC_KEY,
               hMasterHash,
               fClient ? 0 : CRYPT_SERVER,
               &amp;hWriteKey);

// Derive read MAC from the master hash object.
CryptDeriveKey(hProv,
               CALG_SCHANNEL_MAC_KEY,
               hMasterHash,
               fClient ? CRYPT_SERVER : 0,
               &amp;hReadMAC);

// Derive write MAC from the master hash object.
CryptDeriveKey(hProv,
               CALG_SCHANNEL_MAC_KEY,
               hMasterHash,
               fClient ? 0 : CRYPT_SERVER,
               &amp;hWriteMAC);

CryptDestroyHash(hMasterHash);
 </code></pre>
<p>&nbsp;</p></body>
</HTML>
