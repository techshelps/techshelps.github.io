<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Specifying the Algorithms</title>
<link disabled rel=stylesheet href=../../../backsdk3.css>
<style type="text/css">
@import url(../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h2><a name="_cryptcsp_specifying_the_algorithms"></a>Specifying the Algorithms</h2>
<p>
After the master key has been created (or imported), the protocol engine must inform the CSP of the type of bulk encryption and MAC keys that will be derived from the master key. The following code specifies the algorithms. The same code is used for both client and server.</p>
<pre><code>typedef struct _SCHANNEL_ALG 
{
    DWORD  dwUse;
    ALG_ID Algid;
    DWORD  cBits; 
} SCHANNEL_ALG, *PSCHANNEL_ALG;

SCHANNEL_ALG Algorithm;

// Specify encryption algorithm.
Algorithm.dwUse = SCHANNEL_ENC_KEY;
Algorithm.Algid = CALG_RC4;    // or CALG_RC2, CALG_DES, etc.
Algorithm.cBits = 40;          // or 64, 128, 192, etc.
CryptSetKeyParam(hMasterKey, KP_SCHANNEL_ALG, (PBYTE)&amp;Algorithm, 0);

// Specify hash algorithm.
Algorithm.dwUse = SCHANNEL_MAC_KEY;
Algorithm.Algid = CALG_MD5;    // or CALG_SHA, etc.
Algorithm.cBits = 128;         // or 160...
CryptSetKeyParam(hMasterKey, KP_SCHANNEL_ALG, (PBYTE)&amp;Algorithm, 0);
 </code></pre>
<p>
<b>Note</b>&nbsp;&nbsp;The protocol engine should never specify algorithms and key sizes unless they are supported by the CSP. See the<b> <a href="rsa_sovr_0y2b.htm">Enumerating the Supported Protocols</a></b> section. Where unsupported algorithms or key sizes are specified, the CSP should fail and return the NTE_BAD_DATA error code.</p>
<p>&nbsp;</p></body>
</HTML>
