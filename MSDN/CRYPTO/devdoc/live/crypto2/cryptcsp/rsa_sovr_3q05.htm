<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>The Opaque Blob Type</title>
<link disabled rel=stylesheet href=../../../backsdk3.css>
<style type="text/css">
@import url(../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h2><a name="_cryptcsp_the_opaque_blob_type"></a>The Opaque Blob Type</h2>
<p>
Opaque blobs (also known as OPAQUEBLOBs) are used to store session keys. They don't merely contain the base key material though, they also contain all of the current state information. This includes information such as the salt, the initialization vector, the key table, etc. Opaque blobs are called "opaque" because their format is unpublished. Each CSP vendor determines their own format, which should include encrypting the opaque blobs with some sort of symmetric key.</p>
<p>
Once a key has been exported into an opaque blob, it can only be imported back into the same CSP from which it was originally exported.</p>
<p>
When two processes are involved, each independently calls <a href="../capifunc_0wvo.htm"><b>CryptAcquireContext</b></a>, such that they both end up with a handle to a key container, possibly the same container. One process creates the keys and exports them into opaque blobs, then passes them to a second process, which imports them again.</p>
<p>
If the CSP uses a hardware token that doesn't support exporting keys, then the blob may only contain the index of a key register, or something similar. In this case, the hardware can remain unaware of the whole procedure.</p>
<p>
When the CRYPT_DESTROYKEY flag is passed into the <b>CryptExportKey</b> function, the original key is automatically destroyed by the CSP. For a hardware CSP, the handle to the original key is destroyed. This avoids the necessity of calling <b>CryptDestroyKey</b> on the original key, which may confuse some hardware CSPs by causing them to delete a key that you are still planning to use.</p>
<pre><code><i>&lt;secure process&gt;
</i>cbBlob = sizeof(rgbBlob);
CryptExportKey(hKey, 0, OPAQUEBLOB, CRYPT_DESTROYKEY, 
               rgbBlob, &amp;cbBlob);
hKey = 0;

<i>&lt;blob is transferred to other process&gt;</i>

<i>&lt;user process&gt;</i>
CryptImportKey(hProv, pbBlob, cbBlob, 0, 0, &amp;hKey);
 </code></pre>
<p>
</p>
<p>&nbsp;</p></body>
</HTML>
