<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CryptGetKeyParam</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_crypto2_cryptgetkeyparam"></a>CryptGetKeyParam</h1>
<p>
The <b>CryptGetKeyParam</b> function retrieves data that govern the operations of a key. Note that in the <a href="msprov_4dmb.htm">Microsoft Cryptographic Service Providers</a>, the base symmetric keying material is not obtainable by this function or any other function.</p>
<pre><code><b>#include &lt;wincrypt.h&gt;
BOOL WINAPI CryptGetKeyParam(
  HCRYPTKEY</b><i> hKey</i><b>,  </b>// in
<b>  DWORD</b><i> dwParam</i><b>,   </b>// in
<b>  BYTE </b><i>*pbData</i><b>,    </b>// out
<b>  DWORD </b><i>*pcbData</i><b>,  </b>// in/out
<b>  DWORD</b><i> dwFlags    </i>// in
<b>);</b>
 </code></pre>
<h4>Parameters</h4>
<dl>
<dt>
<i>hKey</i></dt>
<dd>
Handle to the key on which to query parameters.</dd>
<dt>
<i>dwParam</i></dt>
<dd>
Parameter number. See the "Remarks" section for a list of valid parameters.</dd>
<dt>
<i>pbData</i></dt>
<dd>
Pointer to a buffer that receives the parameter data. The function will copy the specified parameter data to this buffer. The form of this data will vary, depending on the parameter number.
<p>
This parameter can be NULL to set the size of this information for memory allocation purposes. For more information, see <a href="refoview_46pf.htm">Common In/Out Parameter Conventions</a>. 
</dd>
<dt>
<i>pcbData</i></dt>
<dd>
Pointer to a variable that specifies the size, in bytes, of the buffer pointed to by the <i>pbData </i>parameter. When the function returns, the variable pointed to by the <i>pcbData </i>parameter contains the number of bytes stored in the buffer. This parameter can be NULL, only if <i>pbData </i>is NULL.
<p>
Note that when processing the data returned in the buffer, applications need to use the actual size of the data returned. The actual size may be slightly smaller than the size of the buffer specified on input. (On input, buffer sizes are usually specified large enough to insure that the largest possible output data will fit in the buffer.) On output, the variable pointed to by this parameter is updated to reflect the actual size of the data copied to the buffer.
</dd>
<dt>
<i>dwFlags</i></dt>
<dd>
Flag values. This parameter is reserved for future use and should always be zero.
</dd>
</dl>
<h4>Return Values</h4>
<p>
If the function succeeds, the return value is TRUE. If it fails, the return value is FALSE. To retrieve extended error information, use the <b>GetLastError</b> function.</p>
<p>
The following table lists the error codes most commonly returned by the <b>GetLastError</b> function. The error codes prefaced by "NTE" are generated by the particular CSP you are using.</p>
<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=51%>Error code</th>
<th align=left width=49%>Description</th>
</tr>
<tr valign=top>
<td width=51%>ERROR_INVALID_HANDLE</td>
<td width=49%>One of the parameters specifies an invalid handle. </td>
</tr>
<tr valign=top>
<td width=51%>ERROR_INVALID_PARAMETER</td>
<td width=49%>One of the parameters contains an invalid value. This is most often an illegal pointer.</td>
</tr>
<tr valign=top>
<td width=51%>ERROR_MORE_DATA</td>
<td width=49%>If the buffer specified by the <i>pbData </i>parameter is not large enough to hold the returned data, the function sets the ERROR_MORE_DATA code, and stores the required buffer size, in bytes, into the variable pointed to by <i>pcbData</i>.</td>
</tr>
<tr valign=top>
<td width=51%>NTE_BAD_FLAGS</td>
<td width=49%>The <i>dwFlags</i> parameter is nonzero.</td>
</tr>
<tr valign=top>
<td width=51%>NTE_BAD_KEY or NTE_NO_KEY</td>
<td width=49%>The key specified by the <i>hKey</i> parameter is invalid.</td>
</tr>
<tr valign=top>
<td width=51%>NTE_BAD_TYPE</td>
<td width=49%>The <i>dwParam</i> parameter specifies an unknown parameter number.</td>
</tr>
<tr valign=top>
<td width=51%>NTE_BAD_UID</td>
<td width=49%>The CSP context that was specified when the key was created cannot be found.</td>
</tr>
</table><br>
<h4>Remarks</h4>
<p>
For all key types, the <i>dwParam</i> value can be set to one of the following key parameter types.</p>
<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=33%>Parameter type</th>
<th align=left width=67%>Description</th>
</tr>
<tr valign=top>
<td width=33%>KP_ALGID</td>
<td width=67%>Key algorithm. The <i>pbData</i> buffer will contain an <a href="datatype_2td0.htm"><b>ALG_ID</b></a> value indicating the algorithm that was specified when the key was created. Note that when key specifications AT_KEYEXCHANGE and AT_SIGNATURE are specified for the <i>Algid</i> parameter, the algorithm identifiers that are used to generate the key depend on the provider used. As a result, for these key specifications the values returned from <a href="#_crypto2_cryptgetkeyparam"><b>CryptGetKeyParam</b></a> (when the KP_ALGID parameter is specified) depend on the provider used. See <a href="datatype_2td0.htm">ALG_ID</a> to determine which algorithm identifier is used by the different providers for the key specifications AT_KEYEXCHANGE and AT_SIGNATURE.</td>
</tr>
<tr valign=top>
<td width=33%>KP_BLOCKLEN</td>
<td width=67%>If a session key is specified by <i>hKey</i>, this parameter returns the block length, in bits, of the cipher. The <i>pbData</i> buffer will contain a <b>DWORD</b> value indicating the block length. For stream ciphers, this value will always be zero.<p>
If a public/private key pair is specified by <i>hKey</i>, this parameter returns the key pair's encryption granularity in bits. For example, the Microsoft Base Cryptographic Provider generates 512-bit RSA key pairs, so a value of 512 is returned for these keys. If the public-key algorithm does not support encryption, the value returned by this parameter is undefined.</p>
</td>
</tr>
<tr valign=top>
<td width=33%>KP_KEYLEN</td>
<td width=67%>Used to get the actual length of a key in bits, The length of the key is located in the <b>DWORD</b> pointed to by <i>pbData</i>. This parameter can be used to get the length of any key type.</td>
</tr>
<tr valign=top>
<td width=33%>KP_SALT</td>
<td width=67%>The salt value. The <i>pbData</i> buffer will contain a <b>BYTE</b> array indicating the current salt value. The size of the salt value will vary depending on the CSP and algorithm being used.<p>
Salt values do not apply to public/private key pairs.</p>
</td>
</tr>
<tr valign=top>
<td width=33%>KP_PERMISSIONS</td>
<td width=67%>Key permissions. The <i>pbData</i> buffer will contain a <b>DWORD</b> value with zero or more permission flags set. Refer to the table at the end of this section for a description of each of these flags.</td>
</tr>
</table><br>
<p>
If a DSS key is specified by <i>hKey</i>, the <i>dwParam</i> value can also be set to one of the following parameter types.</p>
<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=33%>Parameter type</th>
<th align=left width=67%>Description</th>
</tr>
<tr valign=top>
<td width=33%>KP_P</td>
<td width=67%>The <i>pbData</i> buffer will contain the prime modulus P from the DSS key blob. The length of the data is returned in the <i>pcbData </i>parameter.</td>
</tr>
<tr valign=top>
<td width=33%>KP_Q</td>
<td width=67%>The <i>pbData</i> buffer will contain the prime Q from the DSS key blob. The length of the data is returned in the <i>pcbData </i>parameter.</td>
</tr>
<tr valign=top>
<td width=33%>KP_G</td>
<td width=67%>The <i>pbData</i> buffer will contain the generator G from the DSS key blob. The length of the data is returned in the <i>pcbData </i>parameter.</td>
</tr>
</table><br>
<p>
If a block cipher session key is specified by <i>hKey</i>, the <i>dwParam</i> value can also be set to one of the following parameter types.</p>
<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=38%>Parameter type</th>
<th align=left width=62%>Description</th>
</tr>
<tr valign=top>
<td width=38%>KP_EFFECTIVE_KEYLEN</td>
<td width=62%>Used to query the effective key length of an RC2 key. The value of the effective key length is returned as a DWORD pointed to by the <i>pbData</i> parameter.</td>
</tr>
<tr valign=top>
<td width=38%>KP_IV</td>
<td width=62%>The initialization vector. The <i>pbData</i> buffer will contain a <b>BYTE</b> array indicating the current initialization vector. This array contains <i>block_length</i>/8 elements. For example, if the block length is 64 bits, the initialization vector will consist of eight bytes.</td>
</tr>
<tr valign=top>
<td width=38%>KP_PADDING</td>
<td width=62%>The padding mode. The <i>pbData</i> buffer will contain a <b>DWORD</b> value indicating the padding method used by the cipher. Following are the padding modes currently defined:<p>
PKCS5_PADDING—PKCS 5 (sec 6.2) padding method.</p>
</td>
</tr>
<tr valign=top>
<td width=38%>KP_MODE</td>
<td width=62%>The cipher mode. The <i>pbData</i> buffer will contain a <b>DWORD</b> value indicating the mode of the cipher. Refer to the following table for a list of valid cipher modes.</td>
</tr>
<tr valign=top>
<td width=38%>KP_MODE_BITS</td>
<td width=62%>The number of bits to feed back. The <i>pbData</i> buffer will contain a <b>DWORD</b> value indicating the number of bits that are processed per cycle when the OFB or CFB cipher modes are used.</td>
</tr>
</table><br>
<p>
The following table lists the possible values for the KP_MODE parameter. These cipher modes are discussed in <a href="enc_dec_5qw1.htm">Encrypting and Decrypting Data</a>. </p>
<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=35%>Cipher mode</th>
<th align=left width=65%>Description</th>
</tr>
<tr valign=top>
<td width=35%>CRYPT_MODE_ECB</td>
<td width=65%>Electronic codebook</td>
</tr>
<tr valign=top>
<td width=35%>CRYPT_MODE_CBC</td>
<td width=65%>Cipher block chaining</td>
</tr>
<tr valign=top>
<td width=35%>CRYPT_MODE_OFB</td>
<td width=65%>Output feedback mode</td>
</tr>
<tr valign=top>
<td width=35%>CRYPT_MODE_CFB</td>
<td width=65%>Cipher feedback mode</td>
</tr>
</table><br>
<p>
The following table lists the flags in the bit field that are obtained when the KP_PERMISSIONS parameter is read. These permission flags are ignored by the Microsoft Base Cryptographic Provider. However, custom <a href="cryptcsp/signcsp_6rn7.htm">CSPs</a> can use these flags to restrict operations on keys.</p>
<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=35%>Permission flag</th>
<th align=left width=65%>Description</th>
</tr>
<tr valign=top>
<td width=35%>CRYPT_ENCRYPT</td>
<td width=65%>Allow encryption.</td>
</tr>
<tr valign=top>
<td width=35%>CRYPT_DECRYPT</td>
<td width=65%>Allow decryption.</td>
</tr>
<tr valign=top>
<td width=35%>CRYPT_EXPORT</td>
<td width=65%>Allow key to be exported.</td>
</tr>
<tr valign=top>
<td width=35%>CRYPT_READ</td>
<td width=65%>Allow parameters to be read.</td>
</tr>
<tr valign=top>
<td width=35%>CRYPT_WRITE</td>
<td width=65%>Allow parameters to be set.</td>
</tr>
<tr valign=top>
<td width=35%>CRYPT_MAC</td>
<td width=65%>Allow MACs to be used with key.</td>
</tr>
</table><br>
<h4>Example</h4>
<pre><code>#include &lt;wincrypt.h&gt;

HCRYPTPROV hProv = 0;
HCRYPTKEY hKey = 0;
DWORD dwMode;
BYTE pbData[16];
DWORD dwCount;
DWORD i;

// Get a handle to user default provider.
if(!CryptAcquireContext(&amp;hProv, NULL, NULL, PROV_RSA_FULL, 0)) {
    printf("Error %x during CryptAcquireContext!\n", GetLastError());
    goto done;
}

// Create a random block cipher session key.
if(!CryptGenKey(hProv, CALG_RC2, CRYPT_EXPORTABLE, &amp;hKey)) {
    printf("Error %x during CryptGenKey!\n", GetLastError());
    goto done;
}

// Read the cipher mode.
dwCount = sizeof(DWORD);
if(!CryptGetKeyParam(hKey, KP_MODE, &amp;dwMode, &amp;dwCount, 0)) {
    printf("Error %x during CryptGetKeyParam!\n", GetLastError());
    goto done;
}
assert(dwCount==sizeof(BYTE));

// Print out the cipher mode.
printf("Default cipher mode: %d\n", dwMode);

// Read the initialization vector.
dwCount = 16;
if(!CryptGetKeyParam(hKey, KP_IV, pbData, &amp;dwCount, 0)) {
    printf("Error %x during CryptGetKeyParam!\n", GetLastError());
    goto done;
}
// Print out the initialization vector.
printf("Default IV:");
for(i=0;i&lt;dwCount;i++) printf("%2.2x ",pbData[i]);
printf("\n");

done:

// Destroy the session key.
if(hKey != 0) CryptDestroyKey(hKey);

// Release the provider handle.
if(hProv != 0) CryptReleaseContext(hProv, 0);
 </code></pre>
<h4>QuickInfo</h4>
<p>
<b>&nbsp;&nbsp;Windows NT: </b>Requires version 4.0 or later.<br>
<b>&nbsp;&nbsp;Windows: </b>Requires Windows 95 OSR2 or later (or Windows 95 with IE 3.02 or later).<br>
<b>&nbsp;&nbsp;Windows CE: </b>Unsupported.<br>
<b>&nbsp;&nbsp;Header: </b>Declared in wincrypt.h.<br>
<b>&nbsp;&nbsp;Import Library: </b>Use advapi32.lib.</p>
<h4>See Also</h4>
<p>
<a href="capifunc_3pv1.htm"><b>CryptSetKeyParam</b></a> </p>
<p>&nbsp;</p></body>
</HTML>
