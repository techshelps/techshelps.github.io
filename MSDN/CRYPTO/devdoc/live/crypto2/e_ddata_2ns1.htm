<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Encoding and Decoding Data</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_crypto2_encoding_and_decoding_data"></a>Encoding and Decoding Data</h1>
<p>
In order for data to be sent over a serial line, such as a phone line, the data must be <i>serialized</i>. That is, the data must be converted to a string of ones and zeros that are transmitted serially over the line. This must be done in a manner such that the computer receiving the data can deserialize the data back into its original format. The exact manner in which this is accomplished is called a communication protocol, and is controlled by both software and data-transmission hardware. There are several levels at which the data is converted. The following illustration shows a greatly simplified view of communication protocol layers.</p>
<p>
<img src="images/layer.gif" border=0></p>
<p>
As shown in the accompanying illustration, an application, the Application Layer on Computer #1, sends the data to be transmitted (usually consisting of some combination of textual characters and numbers) to the Encoding/Decoding Layer, where the data is encoded into a stream of computer bytes. At the lowest level, the Hardware Layer, the hardware converts the bytes of data into a serial stream of ones and zeros that is transmitted over the line to Computer #2. The Hardware Layer of Computer #2 converts the ones and zeros back into computer bytes, and passes them up to the Encode/Decode Layer for decoding. The Encode/Decode Layer decodes the bytes back into their original format and passes the data up to the Application Layer. In reality, there are generally more layers involved in a given protocol, but this simplified view is adequate for the purposes of this discussion.</p>
<p>
An accepted software design principle involves the use of <i>abstraction</i>, the process of describing a problem or object in terms of its general parameters rather than describing all the details necessary to solve the problem, or describing all the details of an object. Using abstraction, a designer can specify a software object that has specific qualities without concern for how the object is actually implemented in the software code. Such a practice leaves the implementation open; it simplifies the specification; and it makes it possible to state axioms about the object that can be proved when the object is implemented, and that can be assumed when the object is employed in another, higher-level object. Abstraction is the hallmark of most modern software specifications.</p>
<p>
Most communication protocols involve a good deal of abstraction. Objects at higher layers are defined abstractly and are intended to be implemented by using objects at lower layers. For instance, a service at one layer may require the transfer of certain abstract objects between computers; a lower layer may provide transfer services for strings of ones and zeroes, using encoding rules to transform the abstract objects into such strings.</p>
<p>
One common method of specifying abstract objects that are intended to be serially transmitted is called Abstract Syntax Notation One (ASN.1), and is defined in CCITT Recommendation X.208. One set of rules for representing such objects as strings of ones and zeros is called the Distinguished Encoding Rules (DER), and is defined in CCITT Recommendation X.509, Section 8.7. These are the encoding methods currently used by the CryptoAPI.</p>
<p>&nbsp;</p></body>
</HTML>
