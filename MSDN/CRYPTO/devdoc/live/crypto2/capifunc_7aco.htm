<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CryptSignHash</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_crypto2_cryptsignhash"></a>CryptSignHash</h1>
<p>
The <b>CryptSignHash</b> function is used to sign a piece of data. Because all signature algorithms are asymmetric and thus incredibly slow, the CryptoAPI will not let data be signed directly. Instead, you must first hash the data and then use <b>CryptSignHash</b> to sign the hash value.</p>
<pre><code><b>#include &lt;wincrypt.h&gt;
BOOL WINAPI CryptSignHash(
  HCRYPTHASH</b><i> hHash</i><b>,     </b>// in
<b>  DWORD</b><i> dwKeySpec</i><b>,      </b>// in
<b>  LPCTSTR</b><i> sDescription</i><b>, </b>// in
<b>  DWORD</b><i> dwFlags</i><b>,        </b>// in
<b>  BYTE </b><i>*pbSignature</i><b>,    </b>// out
<b>  DWORD </b><i>*pdwSigLen      </i>// in/out
<b>);</b>
 </code></pre>
<h4>Parameters</h4>
<dl>
<dt>
<i>hHash</i></dt>
<dd>
Handle to the hash object to be signed.</dd>
<dt>
<i>dwKeySpec</i></dt>
<dd>
Key pair to use to sign the hash. The following keys can be specified.
<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=39%>Value</th>
<th align=left width=61%>Description</th>
</tr>
<tr valign=top>
<td width=39%>AT_KEYEXCHANGE</td>
<td width=61%>Exchange private key</td>
</tr>
<tr valign=top>
<td width=39%>AT_SIGNATURE</td>
<td width=61%>Signature private key</td>
</tr>
</table><br>


<p>
The signature algorithm used is specified when the key pair was originally created.

<p>
The only signature algorithm that the Microsoft Base Cryptographic Provider supports is the RSA Public-Key algorithm.
</dd>
<dt>
<i>sDescription</i></dt>
<dd>
This parameter should no longer be used, and should be set to NULL to prevent security vulnerabilities. However, it is still supported for backward compatibility in the Microsoft Base Cryptographic Provider.</dd>
<dt>
<i>dwFlags</i></dt>
<dd>
Flag values. This parameter is reserved for future use and should always be zero.</dd>
<dt>
<i>pbSignature</i></dt>
<dd>
Pointer to a buffer that receives the signature data.
<p>
This parameter can be NULL to set the size of this information for memory allocation purposes. For more information, see <a href="refoview_46pf.htm">Common In/Out Parameter Conventions</a>.
</dd>
<dt>
<i>pdwSigLen</i></dt>
<dd>
Pointer to a variable that specifies the size, in bytes, of the buffer pointed to by the <i>pdwSigLen </i>parameter. When the function returns, the variable pointed to by the <i>pdwSigLen </i>parameter contains the number of bytes stored in the buffer. This parameter can be NULL, only if <i>pbSignature </i>is NULL.
<p>
Note that when processing the data returned in the buffer, applications need to use the actual size of the data returned. The actual size may be slightly smaller than the size of the buffer specified on input. (On input, buffer sizes are usually specified large enough to insure that the largest possible output data will fit in the buffer.) On output, the variable pointed to by this parameter is updated to reflect the actual size of the data copied to the buffer.

</dd>
</dl>
<h4>Return Values</h4>
<p>
If the function succeeds, the return value is TRUE. If it fails, the return value is FALSE. To retrieve extended error information, use the <b>GetLastError</b> function.</p>
<p>
The following table lists the error codes most commonly returned by the <b>GetLastError</b> function. The error codes prefaced by "NTE" are generated by the particular CSP you are using.</p>
<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=48%>Error code</th>
<th align=left width=52%>Description</th>
</tr>
<tr valign=top>
<td width=48%>ERROR_INVALID_HANDLE</td>
<td width=52%>One of the parameters specifies an invalid handle.</td>
</tr>
<tr valign=top>
<td width=48%>ERROR_INVALID_PARAMETER</td>
<td width=52%>One of the parameters contains an invalid value. This is most often an illegal pointer.</td>
</tr>
<tr valign=top>
<td width=48%>ERROR_MORE_DATA</td>
<td width=52%>If the buffer specified by the <i>pbSignature </i>parameter is not large enough to hold the returned data, the function sets the ERROR_MORE_DATA code and stores the required buffer size, in bytes, into the variable pointed to by <i>pdwSigLen</i>.</td>
</tr>
<tr valign=top>
<td width=48%>NTE_BAD_ALGID</td>
<td width=52%>The <i>hHash</i> handle specifies an algorithm that this CSP does not support.</td>
</tr>
<tr valign=top>
<td width=48%>NTE_BAD_FLAGS</td>
<td width=52%>The <i>dwFlags</i> parameter is nonzero.</td>
</tr>
<tr valign=top>
<td width=48%>NTE_BAD_HASH</td>
<td width=52%>The hash object specified by the <i>hHash</i> parameter is invalid.</td>
</tr>
<tr valign=top>
<td width=48%>NTE_BAD_UID</td>
<td width=52%>The CSP context that was specified when the hash object was created cannot be found.</td>
</tr>
<tr valign=top>
<td width=48%>NTE_NO_KEY</td>
<td width=52%>The private key specified by <i>dwKeySpec</i> does not exist.</td>
</tr>
<tr valign=top>
<td width=48%>NTE_NO_MEMORY</td>
<td width=52%>The CSP ran out of memory during the operation.</td>
</tr>
</table><br>
<h4>Remarks</h4>
<p>
Before calling this function, the <a href="capifunc_5kfc.htm"><b>CryptCreateHash</b></a> function must be called to get a handle to a hash object. The <a href="capifunc_8c81.htm"><b>CryptHashData</b></a> or <a href="capifunc_8fuh.htm"><b>CryptHashSessionKey</b></a> function is then used to add the data or session keys to the hash object.</p>
<p>
After this function has been completed, the only hash function that can be called using the <i>hHash</i> handle is the <a href="capifunc_5960.htm"><b>CryptDestroyHash</b></a> function.</p>
<h4>Example</h4>
<pre><code>#include &lt;wincrypt.h&gt;

HCRYPTPROV hProv = 0;
#define BUFFER_SIZE 256
BYTE pbBuffer[BUFFER_SIZE];
HCRYPTHASH hHash = 0;
BYTE *pbSignature = NULL;
DWORD dwSigLen;
LPTSTR szDescription = TEXT("Test Data");
DWORD i;

// Get a handle to the default provider.
if(!CryptAcquireContext(&amp;hProv, NULL, NULL, PROV_RSA_FULL, 0)) {
    printf("Error %x during CryptAcquireContext!\n", GetLastError());
    goto done;
}

// Fill the buffer with test data.
for(i = 0 ; i &lt; BUFFER_SIZE ; i++) {
    pbBuffer[i] = (BYTE)i;
}

// Create a hash object.
if(!CryptCreateHash(hProv, CALG_MD5, 0, 0, &amp;hHash)) {
    printf("Error %x during CryptCreateHash!\n", GetLastError());
    goto done;
}

// Compute the cryptographic hash of the buffer.
if(!CryptHashData(hHash, pbBuffer, BUFFER_SIZE, 0)) {
    printf("Error %x during CryptHashData!\n", GetLastError());
    goto done;
}

// Determine the size of the signature and allocate memory.
dwSigLen= 0;
if(!CryptSignHash(hHash, AT_SIGNATURE, TEXT(""), 0, NULL, 
                        &amp;dwSigLen)) {
    printf("Error %x during CryptSignHash!\n", GetLastError());
    if(GetLastError()!=NTE_BAD_LEN) goto done;
}
if((pbSignature = malloc(dwSigLen)) == NULL) {
    printf("Out of memory!\n");
    goto done;
}

// Sign the hash object.
if(!CryptSignHash(hHash, AT_SIGNATURE, szDescription, 0, pbSignature, 
                        &amp;dwSigLen)) {
    printf("Error %x during CryptSignHash!\n", GetLastError());
    goto done;
}

// Store or transmit the signature, test buffer, and description string.
...

done:

// Free memory to be used to store signature.
if(pbSignature != NULL) free(pbSignature);

// Destroy the hash object.
if(hHash != 0) CryptDestroyHash(hHash);

// Release the provider handle.
if(hProv != 0) CryptReleaseContext(hProv, 0);
 </code></pre>
<h4>QuickInfo</h4>
<p>
<b>&nbsp;&nbsp;Windows NT: </b>Requires version 4.0 or later.<br>
<b>&nbsp;&nbsp;Windows: </b>Requires Windows 95 OSR2 or later (or Windows 95 with IE 3.02 or later).<br>
<b>&nbsp;&nbsp;Windows CE: </b>Unsupported.<br>
<b>&nbsp;&nbsp;Header: </b>Declared in wincrypt.h.<br>
<b>&nbsp;&nbsp;Import Library: </b>Use advapi32.lib.<br>
<b>&nbsp;&nbsp;Unicode: </b>Defined as Unicode and ANSI prototypes.</p>
<h4>See Also</h4>
<p>
<a href="capifunc_5kfc.htm"><b>CryptCreateHash</b></a>, <a href="capifunc_5960.htm"><b>CryptDestroyHash</b></a>, <a href="capifunc_8c81.htm"><b>CryptHashData</b></a>, <a href="capifunc_8fuh.htm"><b>CryptHashSessionKey</b></a>, <a href="capifunc_3fj9.htm"><b>CryptVerifySignature</b></a> </p>
<p>&nbsp;</p></body>
</HTML>
