<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CryptExportKey</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_crypto2_cryptexportkey"></a>CryptExportKey</h1>
<p>
The <b>CryptExportKey</b> function is used to export cryptographic keys out of a cryptographic service provider in a secure manner.</p>
<p>
A handle to the key to be exported is passed into the function and the function returns a key blob to the caller. This key blob can be sent over a nonsecure transport or stored in a nonsecure storage location. The key blob is useless until the intended recipient uses the <a href="capifunc_5np5.htm"><b>CryptImportKey</b></a> function on it, which will then import the key into the recipient's CSP.</p>
<pre><code><b>#include &lt;wincrypt.h&gt;
BOOL WINAPI CryptExportKey(
  HCRYPTKEY</b><i> hKey</i><b>,     </b>// in
<b>  HCRYPTKEY</b><i> hExpKey</i><b>,  </b>// in
<b>  DWORD</b><i> dwBlobType</i><b>,   </b>// in
<b>  DWORD</b><i> dwFlags</i><b>,      </b>// in
  <b>BYTE</b> <i>*pbData</i><b>,</b>       // out
<b>  DWORD </b><i>*pcbDataLen   </i>// in/out
<b>);</b>
 </code></pre>
<h4>Parameters</h4>
<dl>
<dt>
<i>hKey</i></dt>
<dd>
Handle to the key to be exported.</dd>
<dt>
<i>hExpKey</i></dt>
<dd>
Handle to a cryptographic key belonging to the destination user. The key data within the key blob created is encrypted by using this key. This ensures that only the destination user will be able to make use of the key blob.
<p>
Most often, this will be the key exchange public key of the destination user. However, certain protocols in some <a href="cryptcsp/signcsp_6rn7.htm">CSPs</a> require that a session key belonging to the destination user be used for this purpose. (Neither the Microsoft Base Cryptographic Provider or the Microsoft Enhanced Cryptographic Provider currently support this.)

<p>
If the key blob type specified by <i>dwBlobType</i> is PUBLICKEYBLOB, then this parameter is unused and should be set to zero.

<p>
If the key blob type specified by <i>dwBlobType </i>is PRIVATEKEYBLOB, then this is typically a handle to a session key that is to be used to encrypt the key blob. Some CSPs allow this parameter to be zero, in which case the application should encrypt the private key blob manually so as to protect it.

<p>
To determine how Microsoft Cryptographic Providers respond to this parameter, see The Private-Key Blob sections of <a href="msprov_4dmb.htm">Microsoft Cryptographic Service Providers</a><u>.</u>
</dd>
<dt>
<i>dwBlobType</i></dt>
<dd>
Type of key blob to be exported. This must be one of the following constants, which are discussed in <a href="xchgkeys_3hkj.htm">Exchanging Cryptographic Keys</a>:
<ul>
<li>
SIMPLEBLOB - used to transport session keys</li>
<li>
PUBLICKEYBLOB - used to transport public keys</li>
<li>
PRIVATEKEYBLOB - used to transport public/private key pairs</li>
<li>
OPAQUEBLOB - used to store session keys in a Schannel CSP. OPAQUEBLOBs are non-transferrable and must be used within the CSP that generated the blob.</li>
</ul>
</dd>
<dt>
<i>dwFlags</i></dt>
<dd>
Flag values. This parameter is reserved for future use and should always be zero.  </dd>
<dt>
<i>pbData</i></dt>
<dd>
Pointer to a buffer that receives the key blob.
<p>
This parameter can be NULL to set the size of this information for memory allocation purposes. For more information, see <a href="refoview_46pf.htm">Common In/Out Parameter Conventions</a>. 
</dd>
<dt>
<i>pcbDataLen</i></dt>
<dd>
Pointer to a variable that specifies the size, in bytes, of the buffer pointed to by the <i>pbDataLen </i>parameter. When the function returns, the variable pointed to by the <i>pcbData </i>parameter contains the number of bytes stored in the buffer. This parameter can be NULL, only if <i>pbDataLen </i>is NULL.

<p>
<b>Note</b>&nbsp;&nbsp;When processing the data returned in the buffer, applications need to use the actual size of the data returned. The actual size may be slightly smaller than the size of the buffer specified on input. (On input, buffer sizes are usually specified large enough to insure that the largest possible output data will fit in the buffer.) On output, the variable pointed to by this parameter is updated to reflect the actual size of the data copied to the buffer.

</dd>
</dl>
<h4>Return Values</h4>
<p>
If the function succeeds, the return value is TRUE. If it fails, the return value is FALSE. To retrieve extended error information, use the <b>GetLastError</b> function.</p>
<p>
The following table lists the error codes most commonly returned by the <b>GetLastError</b> function. The error codes prefaced by "NTE" are generated by the particular CSP you are using.</p>
<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=50%>Error code</th>
<th align=left width=50%>Description</th>
</tr>
<tr valign=top>
<td width=50%>ERROR_INVALID_HANDLE</td>
<td width=50%>One of the parameters specifies an invalid handle. </td>
</tr>
<tr valign=top>
<td width=50%>ERROR_INVALID_PARAMETER</td>
<td width=50%>One of the parameters contains an invalid value. This is most often an illegal pointer.</td>
</tr>
<tr valign=top>
<td width=50%>ERROR_MORE_DATA</td>
<td width=50%>If the buffer specified by the <i>pbData </i>parameter is not large enough to hold the returned data, the function sets the ERROR_MORE_DATA code, and stores the required buffer size, in bytes, into the variable pointed to by <i>pcbDataLen</i>.</td>
</tr>
<tr valign=top>
<td width=50%>NTE_BAD_FLAGS</td>
<td width=50%>The <i>dwFlags</i> parameter is nonzero.</td>
</tr>
<tr valign=top>
<td width=50%>NTE_BAD_KEY</td>
<td width=50%>One or both of the keys specified by <i>hKey</i> and <i>hExpKey</i> are invalid.</td>
</tr>
<tr valign=top>
<td width=50%>NTE_BAD_KEY_STATE</td>
<td width=50%>You do not have permission to export the key. That is, when the <i>hKey</i> key was created, the CRYPT_EXPORTABLE flag was not specified.</td>
</tr>
<tr valign=top>
<td width=50%>NTE_BAD_PUBLIC_KEY</td>
<td width=50%>The key blob type specified by <i>dwBlobType</i> is PUBLICKEYBLOB, but <i>hExpKey</i> does not contain a public key handle.</td>
</tr>
<tr valign=top>
<td width=50%>NTE_BAD_TYPE</td>
<td width=50%>The <i>dwBlobType</i> parameter specifies an unknown blob type.</td>
</tr>
<tr valign=top>
<td width=50%>NTE_BAD_UID</td>
<td width=50%>The CSP context that was specified when the <i>hKey</i> key was created cannot be found.</td>
</tr>
<tr valign=top>
<td width=50%>NTE_NO_KEY</td>
<td width=50%>A session key is being exported and the <i>hExpKey</i> parameter does not specify a public key.</td>
</tr>
</table><br>
<h4>Example</h4>
<pre><code>#include &lt;wincrypt.h&gt;

HCRYPTPROV hProv;      // Handle to CSP
HCRYPTKEY hKey;        // Handle to session key
HCRYPTKEY hXchgKey;    // Handle to receiver's exchange public key
BYTE *pbKeyBlob = NULL;
DWORD dwBlobLen;
...
// Determine the size of the key blob and allocate memory.
if(!CryptExportKey(hKey, hXchgKey, SIMPLEBLOB, 0, NULL, &amp;dwBlobLen)) {
    printf("Error %x computing blob length!\n", GetLastError());
    ...
}
if((pbKeyBlob = malloc(dwBlobLen)) == NULL) {
    printf("Out of memory!\n");
    ...
}

// Export the key into a simple key blob.
if(!CryptExportKey(hKey, hXchgKey, SIMPLEBLOB, 0, pbKeyBlob, &amp;dwBlobLen)) {
    printf("Error %x during CryptExportKey!\n", GetLastError());
    ...
}
 </code></pre>
<p>
Another example is located in <a href="xchgkeys_3ko5.htm">Sender Code Example</a>. </p>
<h4>QuickInfo</h4>
<p>
<b>&nbsp;&nbsp;Windows NT: </b>Requires version 4.0 or later.<br>
<b>&nbsp;&nbsp;Windows: </b>Requires Windows 95 OSR2 or later (or Windows 95 with IE 3.02 or later).<br>
<b>&nbsp;&nbsp;Windows CE: </b>Unsupported.<br>
<b>&nbsp;&nbsp;Header: </b>Declared in wincrypt.h.<br>
<b>&nbsp;&nbsp;Import Library: </b>Use advapi32.lib.</p>
<h4>See Also</h4>
<p>
<a href="capifunc_5np5.htm"><b>CryptImportKey</b></a> </p>
<p>&nbsp;</p></body>
</HTML>
