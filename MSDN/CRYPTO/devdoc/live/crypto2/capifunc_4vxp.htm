<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CryptGetProvParam</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_crypto2_cryptgetprovparam"></a>CryptGetProvParam</h1>
<p>
The <b>CryptGetProvParam</b> function retrieves parameters that govern the operations of a CSP.</p>
<pre><code><b>#include &lt;wincrypt.h&gt;
BOOL WINAPI CryptGetProvParam(
  HCRYPTPROV</b><i> hProv</i><b>, </b>// in
<b>  DWORD</b><i> dwParam</i><b>,    </b>// in
<b>  BYTE </b><i>*pbData</i><b>,     </b>// out
<b>  DWORD </b><i>*pcbData</i><b>,   </b>// in/out
<b>  DWORD</b><i> dwFlags     </i>// in
<b>);</b>
 </code></pre>
<h4>Parameters</h4>
<dl>
<dt>
<i>hProv</i></dt>
<dd>
Handle to the CSP on which to query parameters.</dd>
<dt>
<i>dwParam</i></dt>
<dd>
Parameter number. See the "Remarks" section for a list of valid parameters.</dd>
<dt>
<i>pbData</i></dt>
<dd>
Pointer to a buffer that receives the specified parameter data. The form of this data will vary, depending on the parameter number.
<p>
This parameter can be NULL to set the size of this information for memory allocation purposes. For more information, see <a href="refoview_46pf.htm">Common In/Out Parameter Conventions</a>. 
</dd>
<dt>
<i>pcbData</i></dt>
<dd>
Pointer to a variable that specifies the size, in bytes, of the buffer pointed to by the <i>pbData </i>parameter. When the function returns, the variable pointed to by the <i>pcbData </i>parameter contains the number of bytes stored in the buffer. This parameter can be NULL, only if <i>pbData </i>is NULL.
<p>
Note that when processing the data returned in the buffer, applications need to use the actual size of the data returned. The actual size may be slightly smaller than the size of the buffer specified on input. (On input, buffer sizes are usually specified large enough to insure that the largest possible output data will fit in the buffer.) On output, the variable pointed to by this parameter is updated to reflect the actual size of the data copied to the buffer.


<p>
<b>Note</b>&nbsp;&nbsp;When one of the enumeration parameters (PP_ENUMALGS or PP_ENUMCONTAINERS) is being read, the <i>pcbData </i>parameter works somewhat differently. If <i>pbData</i> is NULL or the value pointed to by <i>pcbData </i>is too small, the value returned in this parameter is the size of the largest item in the enumeration list instead of the size of the item currently being read.

<p>
When one of the enumeration parameters is read and the <i>pbData</i> parameter is NULL, the CRYPT_FIRST flag must be specified in order for the size information to be correctly retrieved.

</dd>
<dt>
<i>dwFlags</i></dt>
<dd>
Flag values.
<p>
When one of the enumeration parameters (PP_ENUMALGS or PP_ENUMCONTAINERS) is being read, then the CRYPT_FIRST flag can be specified. When this flag is set, the first item in the enumeration list is returned. If this flag is not set, then the next item in the list is returned.

<p>
When the enumeration parameter PP_ENUMCONTAINERS is being read, then the CRYPT_MACHINE_KEYSET flag can be specified. This flag can be set if you want the enumeration to come from the HKEY_LOCAL_MACHINE portion of the registry rather than from the HKEY_CURRENT_USER portion of the registry (the default).

<p>
When the <i>dwParam</i> is PP_KEYSET_SEC_DESCR, the security descriptor on the registry key where the keys are stored is being retrieved. For this case, <i>dwFlags</i> is used to pass in the SECURITY_INFORMATION bit flags (can be combined with a bitwise OR operation), as defined in the <i>Win32 Programmer's Reference</i>, that indicates the requested security information. The following is specified there: 

<pre><code>typedef DWORD SECURITY_INFORMATION;</code></pre>
</dd>
</dl>
<pre><code></code></pre>
<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=58%>Value</th>
<th align=left width=42%>Meaning</th>
</tr>
<tr valign=top>
<td width=58%>OWNER_SECURITY_INFORMATION</td>
<td width=42%>Indicates the owner identifier of the object is being referenced.</td>
</tr>
<tr valign=top>
<td width=58%>GROUP_SECURITY_INFORMATION</td>
<td width=42%>Indicates the primary group identifier of the object is being referenced.</td>
</tr>
<tr valign=top>
<td width=58%>DACL_SECURITY_INFORMATION</td>
<td width=42%>Indicates the discretionary ACL of the object is being referenced.</td>
</tr>
<tr valign=top>
<td width=58%>SACL_SECURITY_INFORMATION</td>
<td width=42%>Indicates the system ACL of the object is being referenced.</td>
</tr>
</table><br>
<h4>Return Values</h4>
<p>
If the function succeeds, the return value is TRUE. If it fails, the return value is FALSE. To retrieve extended error information, use the <b>GetLastError</b> function.</p>
<p>
The following table lists the error codes most commonly returned by the <b>GetLastError</b> function. The error codes prefaced by "NTE" are generated by the particular CSP you are using.</p>
<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=47%>Error code</th>
<th align=left width=53%>Description</th>
</tr>
<tr valign=top>
<td width=47%>ERROR_INVALID_HANDLE</td>
<td width=53%>One of the parameters specifies an invalid handle. </td>
</tr>
<tr valign=top>
<td width=47%>ERROR_INVALID_PARAMETER</td>
<td width=53%>One of the parameters contains an invalid value. This is most often an illegal pointer.</td>
</tr>
<tr valign=top>
<td width=47%>ERROR_MORE_DATA</td>
<td width=53%>If the buffer specified by the <i>pbData </i>parameter is not large enough to hold the returned data, the function sets the ERROR_MORE_DATA code, and stores the required buffer size, in bytes, into the variable pointed to by <i>pcbData</i>.</td>
</tr>
<tr valign=top>
<td width=47%>ERROR_NO_MORE_ITEMS</td>
<td width=53%>The end of the enumeration list has been reached. No valid data has been placed in the <i>pbData</i> buffer. This error is returned only when <i>dwParam</i> equals PP_ENUMALGS or PP_ENUMCONTAINERS.</td>
</tr>
<tr valign=top>
<td width=47%>NTE_BAD_FLAGS</td>
<td width=53%>The <i>dwFlags</i> parameter is nonzero.</td>
</tr>
<tr valign=top>
<td width=47%>NTE_BAD_TYPE</td>
<td width=53%>The <i>dwParam</i> parameter specifies an unknown parameter number.</td>
</tr>
<tr valign=top>
<td width=47%>NTE_BAD_UID</td>
<td width=53%>The CSP context specified by <i>hProv</i> is invalid.</td>
</tr>
</table><br>
<h4>Remarks</h4>
<p>
The parameter number contained in the <i>dwParam</i> parameter can be set to one of the following values:
<ul>
<li>
PP_CONTAINER. The key container name. When this parameter is specified, the function fills the <i>pbData</i> buffer with the name of the current key container. This name is in the form of a zero-terminated CHAR string.<p>
This string is exactly the same as the one passed in the <i>pszContainer</i> parameter of the <a href="capifunc_0wvo.htm"><b>CryptAcquireContext</b></a> function in order to specify that the current key container be used. This parameter is often read in order to determine the name of the default key container.
</li>
<li>
PP_ENUMALGS. The algorithm information. When this parameter is specified, the function fills the <i>pbData</i> buffer with information about one of the algorithms supported by the CSP. The PP_ENUMALGS parameter must be read repeatedly to enumerate all the supported algorithms. The algorithms are not enumerated in any particular order.<p>
The first time that the PP_ENUMALGS parameter is read, the CRYPT_FIRST flag should be specified. This will ensure that information about the first algorithm in the enumeration list is returned. The PP_ENUMALGS parameter can then be repeatedly read in order to retrieve the information about the rest of the algorithms. When the <b>CryptGetProvParam</b> function fails with ERROR_NO_MORE_ITEMS, then the end of the enumeration list has been reached. A code sample illustrating this is located in the "Example" section.
<p>
When calling <b>CryptGetProvParam</b> with the PP_ENUMALGS flag in the <i>dwParam </i>parameter the <i>dwBits</i> field should be changed to the length of the default key sizes.
<p>
The following code fragment indicates the format of the data that the function returns in the <i>pbData</i> buffer:
<pre><code>ALG_ID aiAlgid;
DWORD dwBits;
DWORD dwNameLen;
CHAR szName[dwNameLen];
 </code></pre>
<p>
The following table defines each of these fields.
</li>
</ul>
<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=27%>Field</th>
<th align=left width=73%>Description</th>
</tr>
<tr valign=top>
<td width=27%><i>aiAlgid</i></td>
<td width=73%>The algorithm identifier. This is the value that is passed to the <a href="capifunc_4ptl.htm"><b>CryptGenKey</b></a>, <a href="capifunc_88jd.htm"><b>CryptDeriveKey</b></a>, or <a href="capifunc_5kfc.htm"><b>CryptCreateHash</b></a><b> </b>functions in order to specify that a particular algorithm be used.</td>
</tr>
<tr valign=top>
<td width=27%><i>dwBits</i></td>
<td width=73%>The number of bits in the keys used by the algorithm. <p>
If this is a hash algorithm, this value indicates the number of bits in the hash values generated by this algorithm.</p>
</td>
</tr>
<tr valign=top>
<td width=27%><i>dwNameLen</i></td>
<td width=73%>The number of characters in the algorithm name, including the terminating zero.</td>
</tr>
<tr valign=top>
<td width=27%><i>szName</i></td>
<td width=73%>The zero-terminated name of the algorithm.</td>
</tr>
</table><br>
<ul>
<li>
PP_ENUMCONTAINERS. The key container names. When this parameter is specified, the function fills the <i>pbData</i> buffer with the name of one of the key containers maintained by the CSP. This name is in the form of a zero-terminated <b>CHAR</b> string. The PP_ENUMCONTAINERS parameter must be read repeatedly to enumerate all the container names.<p>
These container names are enumerated in the same way as are the CSP's supported algorithms. Refer to the PP_ENUMALGS entry for more information.
</li>
<li>
PP_IMPTYPE. The CSP implementation type. The <i>pbData</i> buffer will contain a DWORD value that indicates how the CSP is implemented. Possible values are:<ul>
<li>
CRYPT_IMPL_HARDWARE</li>
<li>
CRYPT_IMPL_SOFTWARE</li>
<li>
CRYPT_IMPL_MIXED</li>
<li>
CRYPT_IMPL_UNKNOWN </li>
</ul>
</li>
<li>
PP_NAME. The CSP name. When this parameter is specified, the function fills the <i>pbData</i> buffer with the name of the CSP. This name is in the form of a zero-terminated CHAR string.<p>
This string is identical to the one passed in the <i>pszProvider</i> parameter of the <a href="capifunc_0wvo.htm"><b>CryptAcquireContext</b></a> function in order to specify that the current CSP be used. For example, the Microsoft Base Cryptographic Provider will return "Microsoft Base Cryptographic Provider v1.0" when this parameter is read.
</li>
<li>
PP_VERSION. The CSP version number. The <i>pbData</i> buffer will contain a DWORD value that indicates the version number of the CSP. The least significant byte contains the minor version number and the next most significant byte the major version number. For example, version 1.0 would be represented here as 0x00000100. </li>
</ul>
<p>
<b>Version Information for <br>
<a href="msprov_554g.htm">The Microsoft Base Cryptographic Provider</a> and <br>
<a href="msprov_4434.htm">The Microsoft Enhanced Cryptographic Provider</a></b>: </p>
<p>
To maintain backward compatibility with earlier versions of these providers, the name retains the "v1.0" designation in later versions. This can be seen in the wincrypt.h header file. Version 2.0 of this provider is currently shipping. To see which version of the provider you have, make a call to <b>CryptGetProvParam</b> with the <i>dwParam</i> argument set to PP_VERSION. For example, if 0x00000200 is returned in <i>pbData</i>, then you have version 2.0.
<ul>
<li>
PP_KEYSET_SEC_DESCR. Indicates that the security descriptor is to be retrieved for the registry entry where the key set is stored.<p>
<b>Note</b>&nbsp;&nbsp;The PP_KEYSET_SEC_DESCR flag is not supported under Microsoft® Windows® 95.
</li>
</ul>
<p>
The <i>dwFlags</i> parameter is used to pass in the SECURITY_INFORMATION bit flags that indicate the requested security information. The pointer to the security descriptor is returned in the <i>pbData</i> parameter and the length of the security descriptor is returned in the <i>pcbData </i>parameter. It may be helpful to look at the documentation on <b>RegGetKeySecurity</b> and <b>RegSetKeySecurity </b>(WIN32 calls).</p>
<h5>Algorithm Identifiers</h5>
<p>
When enumerating algorithms (<i>dwParam</i> == PP_ENUMALGS), your application may need to determine the class of a particular algorithm. For example, you may want to display a list of encryption algorithms to the user and disregard the rest. This can be done with the <b>GET_ALG_CLASS(</b><i>x</i><b>)</b> macro. This macro takes an algorithm identifier as an argument and returns a code indicating the general class of algorithm that the identifier belongs to. Possible return values include:
<ul>
<li>
ALG_CLASS_DATA_ENCRYPT</li>
<li>
ALG_CLASS_HASH</li>
<li>
ALG_CLASS_KEY_EXCHANGE</li>
<li>
ALG_CLASS_SIGNATURE</li>
</ul>
<p>
The following table lists the algorithms supported by the Microsoft Base Cryptographic Provider along with the class of each algorithm.</p>
<table cellspacing=4 cols=3>
<tr valign=top>
<th align=left width=24%>Name</th>
<th align=left width=30%>Identifier</th>
<th align=left width=46%>Class</th>
</tr>
<tr valign=top>
<td width=24%>"MD2"</td>
<td width=30%>CALG_MD2</td>
<td width=46%>ALG_CLASS_HASH</td>
</tr>
<tr valign=top>
<td width=24%>"MD5"</td>
<td width=30%>CALG_MD5</td>
<td width=46%>ALG_CLASS_HASH</td>
</tr>
<tr valign=top>
<td width=24%>"SHA"</td>
<td width=30%>CALG_SHA</td>
<td width=46%>ALG_CLASS_HASH</td>
</tr>
<tr valign=top>
<td width=24%>"MAC"</td>
<td width=30%>CALG_MAC</td>
<td width=46%>ALG_CLASS_HASH</td>
</tr>
<tr valign=top>
<td width=24%>"RSA_SIGN"</td>
<td width=30%>CALG_RSA_SIGN</td>
<td width=46%>ALG_CLASS_SIGNATURE</td>
</tr>
<tr valign=top>
<td width=24%>"RSA_KEYX"</td>
<td width=30%>CALG_RSA_KEYX</td>
<td width=46%>ALG_CLASS_KEY_EXCHANGE</td>
</tr>
<tr valign=top>
<td width=24%>"RC2"</td>
<td width=30%>CALG_RC2</td>
<td width=46%>ALG_CLASS_DATA_ENCRYPT</td>
</tr>
<tr valign=top>
<td width=24%>"RC4"</td>
<td width=30%>CALG_RC4</td>
<td width=46%>ALG_CLASS_DATA_ENCRYPT</td>
</tr>
</table><br>
<p>
If your application does not recognize an algorithm identifier, it is not recommended that you use the algorithm. Making use of an unknown cryptographic algorithm can sometimes produce unpredictable results.</p>
<h4>Example</h4>
<p>
This example shows how the list of algorithms supported by a particular CSP is accessed by an application:</p>
<pre><code>HCRYPTPROV hProv;         // Handle to CSP
DWORD dwAlgCount;
BYTE *ptr = NULL;
DWORD i;
ALG_ID aiAlgid;
DWORD dwBits;
DWORD dwNameLen;
CHAR szName[100];         // Often allocated dynamically
BYTE pbData[1000];        // Often allocated dynamically
DWORD cbData;
DWORD dwFlags;
CHAR *pszAlgType = NULL;

// Enumerate the supported algorithms.
for(i=0 ; ; i++) {
    // Set the CRYPT_FIRST flag the first time through the loop.
    if(i == 0) {
        dwFlags = CRYPT_FIRST;
    } else {
        dwFlags = 0;
    }

// Retrieve information about an algorithm.
    cbData = 1000;
    if(!CryptGetProvParam(hProv, PP_ENUMALGS, pbData, &amp;cbData, dwFlags)) {
        if(GetLastError() == ERROR_NO_MORE_ITEMS) {
            // Exit the loop.
            break;
        } else {
            printf("Error %x reading algorithm!\n", GetLastError());
            return;
        }
    }

    // Extract algorithm information from the 'pbData' buffer.
    ptr = pbData;
    aiAlgid = *(ALG_ID *)ptr;
    ptr += sizeof(ALG_ID);
    dwBits = *(DWORD *)ptr;
    ptr += sizeof(DWORD);
    dwNameLen = *(DWORD *)ptr;
    ptr += sizeof(DWORD);
    strncpy(szName, ptr, dwNameLen);

    // Determine the algorithm type.
    switch(GET_ALG_CLASS(aiAlgid)) {
        case ALG_CLASS_DATA_ENCRYPT: pszAlgType = "Encrypt  ";
                                     break;
        case ALG_CLASS_HASH:         pszAlgType = "Hash     ";
                                     break;
        case ALG_CLASS_KEY_EXCHANGE: pszAlgType = "Exchange ";
                                     break;
        case ALG_CLASS_SIGNATURE:    pszAlgType = "Signature";
                                     break;
        default:                     pszAlgType = "Unknown  ";
    }

    // Print information about the algorithm.
    printf("Algid:%8.8xh, Bits:%-4d, Type:%s, NameLen:%-2d, Name:%s\n",
        aiAlgid, dwBits, pszAlgType, dwNameLen, szName
    );
}
 </code></pre>
<h4>QuickInfo</h4>
<p>
<b>&nbsp;&nbsp;Windows NT: </b>Requires version 4.0 or later.<br>
<b>&nbsp;&nbsp;Windows: </b>Requires Windows 95 OSR2 or later (or Windows 95 with IE 3.02 or later).<br>
<b>&nbsp;&nbsp;Windows CE: </b>Unsupported.<br>
<b>&nbsp;&nbsp;Header: </b>Declared in wincrypt.h.<br>
<b>&nbsp;&nbsp;Import Library: </b>Use advapi32.lib.</p>
<h4>See Also</h4>
<p>
<a href="capifunc_0wvo.htm"><b>CryptAcquireContext</b></a>, <a href="capifunc_5kfc.htm"><b>CryptCreateHash</b></a>,<b> <a href="capifunc_88jd.htm">CryptDeriveKey</a></b>, <a href="capifunc_4ptl.htm"><b>CryptGenKey</b></a>, <a href="capifunc_6d9p.htm"><b>CryptGetKeyParam</b></a>, <a href="capifunc_59v1.htm"><b>CryptSetProvParam</b></a> </p>
<p>&nbsp;</p></body>
</HTML>
