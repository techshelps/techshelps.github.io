<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Encoding Enveloped Data</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h3><a name="_crypto2_encoding_enveloped_data"></a>Encoding Enveloped Data</h3>
<p>
The tasks required to encode an enveloped message are depicted in the following illustration and described in the list that follows it.</p>
<p>
<img src="images/envelmsg.gif" border=0></p>
<p>
The sequence of events for encoding enveloped data, as depicted in the previous illustration, is as follows:
<ol>
<li>
A pointer to the plaintext message is retrieved.</li>
<li>
A symmetric (session) key is generated.</li>
<li>
The symmetric key and specified encryption algorithm are used to encrypt the message data.</li>
<li>
A certificate store is opened.</li>
<li>
The recipient's certificate is retrieved from the store.</li>
<li>
The public key is retrieved from the recipient's certificate.</li>
<li>
Using the recipient's public key, the symmetric key is encrypted.</li>
<li>
From the recipients certificate, the recipient's ID is retrieved.</li>
<li>
The following information is included in the digitally enveloped message: the data encryption algorithm, the encrypted data, the encrypted symmetric key, and the recipient information structure. </li>
</ol>
<p>
To use low-level message functions to accomplish the tasks just listed, use the following procedure.</p>
<h5><img src="../../images/wedge.gif" border=0>&nbsp;&nbsp;&nbsp;&nbsp;To encode an enveloped message using CryptoAPI</h5>
<ol>
<li>
Create or retrieve the content.</li>
<li>
Get a cryptographic provider.</li>
<li>
Get a recipient certificate.</li>
<li>
Initialize the <a href="structs_91pr.htm"><b>CMSG_ENVELOPED_ENCODE_INFO</b></a> structure.</li>
<li>
Call <a href="llmsg_6gh4.htm"><b>CryptMsgCalculateEncodedLength</b></a> to get the size of the encoded message blob. Allocate memory for it.</li>
<li>
Call <a href="llmsg_5azp.htm"><b>CryptMsgOpenToEncode</b></a> passing in CMSG_ENVELOPED for <i>dwMsgType</i>, and a pointer to <b>CMSG_ENVELOPED_ENCODE_INFO</b> for <i>pvMsgEncodeInfo</i>. As a result of this call, you will get a handle to the opened message.</li>
<li>
Call <a href="llmsg_6rtx.htm"><b>CryptMsgUpdate</b></a> passing in the handle retrieved in step 6, and a pointer to the data that is to be encrypted, enveloped, and encoded. This function can be called as many times as necessary to complete the encoding process.</li>
<li>
Call <a href="llmsg_6xm5.htm"><b>CryptMsgGetParam</b></a>, passing in the handle retrieved in step 6, and the appropriate parameter types to access the desired, encoded data. For example, pass in CMSG_CONTENT_PARAM to get a pointer to the entire PKCS #7 message.<p>
If the result of this encoding is to be used as the inner data for another encoded message, such as an enveloped message, the CMSG_BARE_CONTENT_PARAM parameter must be passed. For example code showing this, see <a href="llmf_0igi.htm">Enveloped Message Example 2</a>.
</li>
<li>
Close the message by calling <a href="llmsg_3485.htm"><b>CryptMsgClose</b></a>.</li>
</ol>
<p>
The result of this procedure is an encoded message that contains the encrypted data, the symmetric key that is encrypted with the recipient's public keys, and the recipient info data structures. The combination of encrypted content and an encrypted symmetric key for a recipient is a <i>digital envelope</i> for that recipient. Any type of content can be enveloped for multiple recipients.</p>
<p>&nbsp;</p></body>
</HTML>
