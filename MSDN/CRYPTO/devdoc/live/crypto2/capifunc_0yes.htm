<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CryptFormatObject</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_crypto2_cryptformatobject"></a>CryptFormatObject</h1>
<p>
<span style=color:#FF0000>[This is preliminary documentation and subject to change.]</span> </p>
<p>
The <b>CryptFormatObject</b> function formats the encoded data and returns a Unicode string in the allocated buffer according to the certificate encoding type.</p>
<pre><code><b>#include &lt;wincrypt.h&gt;
BOOL WINAPI CryptFormatObject(
  DWORD</b><i> dwCertEncodingType,     </i>// in
<b>  DWORD</b><i> dwFormatType,           </i>// in
<b>  DWORD</b><i> dwFormatStrType,        </i>// in
<b>  void</b><i> *pFormatStruct,          </i>// in
<b>  LPCSTR</b><i> lpszStructType,        </i>// in
<b>  const BYTE</b><i> *pbEncoded,       </i> // in
<b>  DWORD</b><i> cbEncoded,</i>              // in
<b>  void</b> <i>*pbFormat,               </i>// out
<b>  DWORD</b><i> *pcbFormat              </i>// in/out
<b>);</b>
 </code></pre>
<h4>Parameters</h4>
<dl>
<dt>
<i>dwCertEncodingType</i></dt>
<dd>
Type of encoding used on the certificate. Currently defined certificate encoding types are shown in the following table:
<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=51%>Encoding type</th>
<th align=left width=49%>Value</th>
</tr>
<tr valign=top>
<td colspan=2 width=100%></td>
</tr>
<tr valign=top>
<td width=51%>X509_ASN_ENCODING</td>
<td width=49%>0x00000001</td>
</tr>
</table><br>

</dd>
<dt>
<i>dwFormatType</i></dt>
<dd>
Format type values. Not used. Set to 0.</dd>
<dt>
<i>dwFormatStrType</i></dt>
<dd>
Structure format type values. This parameter can be zero, or you can specify one or more of the following flags by using the bitwise OR operator to combine them:
<p>
Currently defined values are shown in the following table:

<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=34%>Format value</th>
<th align=left width=66%>Description</th>
</tr>
<tr valign=top>
<td width=34%>0</td>
<td width=66%>Display the data in single line. Each subfield is concatenated with a ", " (see Remarks).</td>
</tr>
<tr valign=top>
<td width=34%>CRYPT_FORMAT_<br>
STR_MULTI_LINE</td>
<td width=66%>Display the data in multiple lines rather than the default of a single line display (see Remarks).</td>
</tr>
<tr valign=top>
<td width=34%>CRYPT_FORMAT_<br>
STR_NO_HEX</td>
<td width=66%>Disables the hex dump (see Remarks).</td>
</tr>
</table><br>

</dd>
<dt>
<i>pFormatStruct</i></dt>
<dd>
Pointer to the format of the structure. Not used. Set to NULL.</dd>
<dt>
<i>lpszStructType</i></dt>
<dd>
Pointer to an OID defining the encoded data. If the high-order word of the <i>lpszStructType</i> parameter is zero, the low-order word specifies the integer identifier for the type of the given structure. Otherwise, this parameter is a long pointer to a null-terminated string.
<p>
The following table is a listing of supported OIDs with the associated OID extension:

<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=66%>OID Name</th>
<th align=left width=34%>OID</th>
</tr>
<tr valign=top>
<td width=66%>SPC_FINANCIAL_CRITERIA_OBJID</td>
<td width=34%>1.3.6.1.4.1.311.2.1.27</td>
</tr>
<tr valign=top>
<td width=66%>SPC_SP_AGENCY_INFO_OBJID</td>
<td width=34%>1.3.6.1.4.1.311.2.1.10</td>
</tr>
<tr valign=top>
<td width=66%>szOID_AUTHORITY_INFO_ACCESS</td>
<td width=34%>1.3.6.1.5.5.7.1.1</td>
</tr>
<tr valign=top>
<td width=66%>szOID_AUTHORITY_KEY_IDENTIFIER2</td>
<td width=34%>2.5.29.35</td>
</tr>
<tr valign=top>
<td width=66%>szOID_BASIC_CONSTRAINTS2</td>
<td width=34%>2.5.29.19</td>
</tr>
<tr valign=top>
<td width=66%>szOID_CERT_POLICIES</td>
<td width=34%>2.5.29.32</td>
</tr>
<tr valign=top>
<td width=66%>szOID_CRL_DIST_POINTS</td>
<td width=34%>2.5.29.31</td>
</tr>
<tr valign=top>
<td width=66%>szOID_CRL_REASON_CODE</td>
<td width=34%>2.5.29.21</td>
</tr>
<tr valign=top>
<td width=66%>szOID_ENHANCED_KEY_USAGE</td>
<td width=34%>2.5.29.37</td>
</tr>
<tr valign=top>
<td width=66%>szOID_ISSUER_ALT_NAME2</td>
<td width=34%>2.5.29.18</td>
</tr>
<tr valign=top>
<td width=66%>szOID_KEY_ATTRIBUTES</td>
<td width=34%>2.5.29.2</td>
</tr>
<tr valign=top>
<td width=66%>szOID_KEY_USAGE</td>
<td width=34%>2.5.29.15</td>
</tr>
<tr valign=top>
<td width=66%>szOID_KEY_USAGE_RESTRICTION</td>
<td width=34%>2.5.29.4</td>
</tr>
<tr valign=top>
<td width=66%>szOID_NEXT_UPDATE_LOCATION</td>
<td width=34%>1.3.6.1.4.1.311.10.2</td>
</tr>
<tr valign=top>
<td width=66%>szOID_RSA_SMIMECapabilities</td>
<td width=34%>1.2.840.113549.1.9.15</td>
</tr>
<tr valign=top>
<td width=66%>szOID_SUBJECT_ALT_NAME2</td>
<td width=34%>2.5.29.17</td>
</tr>
<tr valign=top>
<td width=66%>szOID_SUBJECT_KEY_IDENTIFIER</td>
<td width=34%>2.5.29.14</td>
</tr>
</table><br>

</dd>
<dt>
<i>pbEncoded</i></dt>
<dd>
Pointer to the encoded data to be formatted. If <i>lpszStructType</i>  is one of the OIDs listed above, the <i>pbEncoded</i> is the encoded extension.</dd>
<dt>
<i>cbEncoded</i></dt>
<dd>
Size, in bytes, of the <i>pbEncoded </i>structure.</dd>
<dt>
<i>pbFormat</i></dt>
<dd>
Pointer to a buffer that receives the formatted string. When the buffer that is specified is not large enough to receive the decoded structure, the function sets ERROR_MORE_DATA and stores the required buffer size, in bytes, into the variable pointed to by <i>pcbFormat.</i>
<p>
This parameter can be NULL to set the size of this information for memory allocation purposes. For more information, see <a href="refoview_46pf.htm">Common In/Out Parameter Conventions</a>. 
</dd>
<dt>
<i>pcbFormat</i></dt>
<dd>
Pointer to a variable that specifies the size, in bytes, of the buffer pointed to by the <i>pbFormat </i>parameter. When the function returns, the variable pointed to by the <i>pcbFormat</i> parameter contains the number of bytes stored in the buffer. This parameter can be NULL, only if <i>pbFormat is NULL</i>.

<p>
<b>Note</b>&nbsp;&nbsp;When processing the data returned in the buffer, applications need to use the actual size of the data returned. The actual size may be slightly smaller than the size of the buffer specified on input. (On input, buffer sizes are usually specified large enough to insure that the largest possible output data will fit in the buffer.) On output, the variable pointed to by this parameter is updated to reflect the actual size of the data copied to the buffer.

</dd>
</dl>
<h4>Return Values</h4>
<p>
If the function succeeds, the return value is TRUE. If it does not succeed, the return value is FALSE. To retrieve extended error information, use the <b>GetLastError</b> function.</p>
<h4>Remarks</h4>
<p>
The default behavior of <b>CryptFormatObject</b> is to return single line display of the encoded data, that is, each subfield will be concatenated with a ", " on one line. If a user prefers to display the data in multiple line, set the flag <b>CRYPT_FORMAT_STR_MULTI_LINE</b>, that is, each subfield will be displayed on a separate line.</p>
<p>
If there is no formatting routine installed or registered for the <i>lpszStructType</i>, the hex dump of the encoded <a href="structs_0zmt.htm"><b>BLOB Structure</b></a> will be returned. A user can set the flag <b>CRYPT_FORMAT_STR_NO_HEX</b> to disable the hex dump.</p>
<h4>Example</h4>
<pre><code>// EXAMPLE CODE FOR USING CryptFormatObject().
// Assume that a pointer to an encoded data structure
// (pbEncoded) is already known.

// Set up the variables.
DWORD dwCertEncodingType; // Type of encoding
DWORD dwFormatType;       // Format type
DWORD dwFormatStrType;    // Structure format flags
LPCSTR pFormatStruct;     // Pointer to structure format- set to NULL
LPCSTR  lpszStructType;   // Pointer to type of encoding
const BYTE *pbEncoded;    // Pointer to the encoded object to be read
                          //   and formatted
DWORD  cbEncoded;         // size of structure
BYTE *pbFormat;           // Pointer to the formatted string
DWORD  pcbFormat;
DWORD  cbFormat;          // size of the formated object
BOOL fResult;             // Return value- True if function successful
                          //   False if function fails       

// initalize the pointers/ structure
cout&lt;&lt; "Begin initalization."&lt;&lt; endl;

fResult= CryptFormatObject(
           X509_ASN_ENCODING,          // in- dwCertEncodingType
           0,                          // in- dwFormatType set to 0
           CRYPT_FORMAT_STR_MULTI_LINE,// in- dwFormatStrType- print
                                       //   in multiple line format
           NULL,                       // in- FormatStruct set to NULL
           szOID_CERT_POLICIES,        // in- Structure name
           pbEncoded,                  // in- Pointer to data
                                       //   structure to be formatted
                                       //   initialized elsewhere
           1024,                       // in- size in bytes
           NULL,                       // out- set to NULL to allocate
                                       //   memory
           &amp;cbFormat);                 // in/out- pbFormat size

if (!fResult){
 cout&lt;&lt; "First call to CryptFormatObject failed"&lt;&lt; endl;
}
else {
  cout&lt;&lt; "First call to CryptFormatObject successful"&lt;&lt; endl;
  pbFormat = (BYTE*)malloc (cbFormat);
  cout&lt;&lt; "memory allocated" &lt;&lt; endl;

// Function call to format the object
fResult= CryptFormatObject(
           X509_ASN_ENCODING,          // in- dwCertEncodingType
           0,                          // in- dwFormatType set to 0
           CRYPT_FORMAT_STR_MULTI_LINE,// in- dwFormatStrType- print
                                       //   in multiple line format
           NULL,                       // in- FormatStruct set to NULL
           szOID_CERT_POLICIES,        // in- Structure name
           pbEncoded,                  // in- initialized elsewhere
           1024,                       // in- size in bytes
           pbFormat,                   // out- pbFormat
           &amp;cbFormat);                 // in/out- pbFormat size

if (!fResult){
 cout&lt;&lt; "Second call to CryptFormatObject failed"&lt;&lt; endl;
    }
else {
  cout&lt;&lt; "Second call to CryptFormatObject successful"&lt;&lt; endl
      &lt;&lt; "The string is "&lt;&lt; pbFormat&lt;&lt; endl
      &lt;&lt; "size of pbFormat (cbFormat)= "&lt;&lt; cbFormat&lt;&lt; endl;
    }
free(pbFormat);

}
}
 </code></pre>
<h4>QuickInfo</h4>
<p>
<b>&nbsp;&nbsp;Windows NT: </b>Requires version 5.0 or later.<br>
<b>&nbsp;&nbsp;Windows: </b>Unsupported.<br>
<b>&nbsp;&nbsp;Windows CE: </b>Unsupported.<br>
<b>&nbsp;&nbsp;Header: </b>Declared in wincrypt.h.<br>
<b>&nbsp;&nbsp;Import Library: </b>Use crypt32.lib.</p>
<p>&nbsp;</p></body>
</HTML>
