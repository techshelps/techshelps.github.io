<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CryptMsgOpenToDecode</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_crypto2_cryptmsgopentodecode"></a>CryptMsgOpenToDecode</h1>
<p>
The <b>CryptMsgOpenToDecode</b> function opens a cryptographic message for decoding. The message remains open until <a href="llmsg_3485.htm"><b>CryptMsgClose</b></a> is called.</p>
<p>
Important changes have been made to the CryptoAPI in order to support S/MIME e-mail interoperability, which affect the handling of enveloped messages. See the Remarks for <a href="llmsg_5azp.htm"><b>CryptMsgOpenToEncode</b></a> for details.</p>
<pre><code><b>#include &lt;wincrypt.h&gt;
HCRYPTMSG WINAPI CryptMsgOpenToDecode(
  DWORD</b><i> dwMsgEncodingType</i><b>,         </b>// in
<b>  DWORD</b><i> dwFlags</i><b>,                   </b>// in
<b>  DWORD</b><i> dwMsgType</i><b>,                 </b>// in
<b>  HCRYPTPROV</b><i> hCryptProv</i><b>,           </b>// in
<b>  PCERT_INFO</b><i> pRecipientInfo</i><b>,       </b>// in/optional
<b>  PCMSG_STREAM_INFO</b><i> pStreamInfo    </i>// in/optional
<b>);</b>
 </code></pre>
<h4>Parameters</h4>
<dl>
<dt>
<i>dwMsgEncodingType</i></dt>
<dd>
Type of message encoding used. Note that it is always acceptable to specify both the certificate and message encoding types, by combining them with a bitwise OR operation, as shown in the following example:
<pre><code>CRYPT_ASN_ENCODING | PKCS_7_ASN_ENCODING
 </code></pre>

<p>
However, it is required only to specify the message encoding here. Currently defined encoding types are shown in the following table.

<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=45%>Encoding type</th>
<th align=left width=55%>Value</th>
</tr>
<tr valign=top>
<td width=45%>CRYPT_ASN_ENCODING</td>
<td width=55%>0x00000001</td>
</tr>
<tr valign=top>
<td width=45%>PKCS_7_ASN_ENCODING</td>
<td width=55%>0x00010000</td>
</tr>
</table><br>

</dd>
<dt>
<i>dwFlags</i></dt>
<dd>
Flag values. The CMSG_DETACHED_FLAG indicates that there is detached data being supplied for the subsequent calls to <a href="llmsg_6rtx.htm"><b>CryptMsgUpdate</b></a>.</dd>
<dt>
<i>dwMsgType</i></dt>
<dd>
Message type. Currently defined types are shown in the following table.
<table cellspacing=4 cols=3>
<tr valign=top>
<th align=left width=43%>Message type</th>
<th align=left width=46%>Associated structures</th>
<th align=left width=11%>Value</th>
</tr>
<tr valign=top>
<td width=43%>CMSG_DATA</td>
<td width=46%>Raw data (no associated structure)</td>
<td width=11%>1</td>
</tr>
<tr valign=top>
<td width=43%>CMSG_ENCRYPTED</td>
<td width=46%>Not implemented.</td>
<td width=11%>6</td>
</tr>
<tr valign=top>
<td width=43%>CMSG_ENVELOPED</td>
<td width=46%><a href="structs_91pr.htm"><b>CMSG_ENVELOPED_ENCODE_INFO</b></a></td>
<td width=11%>3</td>
</tr>
<tr valign=top>
<td width=43%>CMSG_HASHED</td>
<td width=46%><a href="structs_78fj.htm"><b>CMSG_HASHED_ENCODE_INFO</b></a></td>
<td width=11%>5</td>
</tr>
<tr valign=top>
<td width=43%>CMSG_SIGNED</td>
<td width=46%><a href="structs_89rj.htm"><b>CMSG_SIGNER_ENCODE_INFO</b></a>, <a href="structs_2pyn.htm"><b>CMSG_SIGNED_ENCODE_INFO</b></a></td>
<td width=11%>2</td>
</tr>
<tr valign=top>
<td width=43%>CMSG_SIGNED_AND_ENVELOPED</td>
<td width=46%>Not implemented.</td>
<td width=11%>4</td>
</tr>
</table><br>


<p>
For the Message type descriptions, see <a href="llmsg_5azp.htm"><b>CryptMsgOpenToEncode</b></a>.

<p>
Signed messages created with Microsoft® Internet Explorer version 3.0 do not contain header information. To maintain compatibility with Internet Explorer version 3.0, the <i>dwMsgType</i> parameter is provided. Therefore, if a signed message from Internet Explorer version 3.0 is received, the message type must be passed in to the function.

<p>
When zero is passed in for the <i>dwMsgType</i> parameter, this function will attempt to read the message type from the header on the message. If the header is missing, as in the case of some Internet Explorer version 3.0 messages, the function call will fail.
</dd>
<dt>
<i>hCryptProv</i></dt>
<dd>
Specifies a handle to the cryptographic provider to use for hashing the message. For signed messages, <i>hCryptProv </i>is used for signature verification.
<p>
Unless there is a strong reason for passing in a specific cryptographic provider in <b>hCryptProv</b>, zero should be passed in. Passing in zero causes the default RSA or DSS provider to be acquired before doing hash, signature verification or recipient encryption operations.
</dd>
<dt>
<i>pRecipientInfo</i></dt>
<dd>
This parameter is reserved for future use and should be set to NULL in the interim.</dd>
<dt>
<i>pStreamInfo</i></dt>
<dd>
When streaming is not being used, this parameter must be set to NULL.
<p>
When streaming is being used, this parameter should point to a <a href="structs_3obz.htm">CMSG_STREAM_INFO</a> structure. The callback specified by <i>pfnStreamOutput</i> in the CMSG_STREAM_INFO structure is called when <a href="llmsg_6rtx.htm"><b>CryptMsgUpdate</b></a> is executed (and also when <a href="llmsg_871o.htm"><b>CryptMsgControl</b></a> is executed when decoding a streamed enveloped message). For more information on how to use the callback, see <a href="structs_3obz.htm">CMSG_STREAM_INFO</a>.

<p>
For a signed message, the callback is passed a block of the decoded bytes from the inner content of the message.

<p>
For an enveloped message, periodic checks should be made to see if the CMSG_ENVELOPE_ALGORITHM_PARAM is available yet by calling <a href="llmsg_6xm5.htm"><b>CryptMsgGetParam</b></a> (CMSG_ENVELOPE_ALGORITHM_PARAM after each call to <b>CryptMsgUpdate</b>. <b>CryptMsgGetParam</b> will fail with LastError == CRYPT_E_STREAM_MSG_NOT_READY until enough of the message has been processed by <b>CryptMsgUpdate</b> to make the CMSG_ENVELOPE_ALGORITHM_PARAM available. Once it is available, the application can then iterate through the recipients, retrieving the <a href="structs_3k33.htm">CERT_INFO</a> for each using <b>CryptMsgGetParam</b> (CMSG_RECIPIENT_INFO_PARAM). 

<p>
The CERT_INFO for a recipient is used to call <a href="certstor_5339.htm"><b>CertGetSubjectCertificateFromStore</b></a> to see if a matching certificate is in the "my" certificate store (<a href="certstor_27s5.htm"><b>CertOpenSystemStore</b></a> or <a href="certstor_12sl.htm"><b>CertOpenStore</b></a><b> </b>must have been previously called to open the "my" store). When a match is found, <a href="certstor_9ce1.htm"><b>CertGetCertificateContextProperty</b></a>(CERT_KEY_PROV_INFO_PROP_ID) is called which returns a <a href="structs_4xdb.htm">CRYPT_KEY_PROV_INFO</a> structure that contains the information necessary to acquire the private key for that recipient. <a href="capifunc_0wvo.htm"><b>CryptAcquireContext</b></a> is called using the <i>pwszContainerName</i>, <i>pwszProvName</i>, <i>dwProvType</i>, and <i>dwFlags</i> members of CRYPT_KEY_PROV_INFO as parameters to get the desired <i>hCryptProv.</i> This <i>hCryptProv </i>and the <i>dwKeySpec</i> from the CRYPT_KEY_PROV_INFO are passed to <a href="llmsg_871o.htm"><b>CryptMsgControl</b></a> (as a member of the <a href="structs_4nhd.htm">CMSG_CTRL_DECRYPT_PARA</a> structure) to permit the start of the decryption of the inner content. The streaming code will then perform the decryption as the data is input, and the resulting blocks of plaintext gets passed to the callback specified by <i>pfnStreamOutput</i> where an application may save it to a file.


<p>
<b>Note</b>&nbsp;&nbsp;The streaming decode for an enveloped message queues up the ciphertext in memory until <b>CryptMsgControl</b> is called to start the decryption. It is up to the application to initiate decrypting in a timely manner so that the data can be saved to disk (or routed elsewhere) before the accumulated ciphertext becomes too large and the system runs out of memory.


<p>
Consider the case of a signed message enclosed in an enveloped message. The plaintext output from the streaming decode of the enveloped message can be fed into another streaming decode which can process the signed message.

</dd>
</dl>
<h4>Return Values</h4>
<p>
Returns a handle to the opened message if successful. Returns NULL if the operation failed.</p>
<p>
To retrieve extended error information, use the <b>GetLastError</b> function.</p>
<p>
The following table lists the error codes most commonly returned by the <b>GetLastError</b> function. </p>
<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=43%>Error code</th>
<th align=left width=57%>Description</th>
</tr>
<tr valign=top>
<td width=43%>E_INVALIDARG</td>
<td width=57%>One or more arguments are invalid.</td>
</tr>
<tr valign=top>
<td width=43%>E_OUTOFMEMORY</td>
<td width=57%>Ran out of memory.</td>
</tr>
</table><br>
<h4>Example</h4>
<p>
See <a href="llmf_3zdx.htm">Signed Message Example Code</a>. </p>
<p>
See <a href="llmf_0igh.htm">Enveloped Message Example 1</a>. </p>
<p>
See <a href="llmf_7dut.htm">Hashed Message Example Code</a>. </p>
<h4>QuickInfo</h4>
<p>
<b>&nbsp;&nbsp;Windows NT: </b>Requires version 4.0 SP3 or later. Available also in IE 3.02 and later.<br>
<b>&nbsp;&nbsp;Windows: </b>Requires Windows 98 (or Windows 95 with IE 3.02 or later).<br>
<b>&nbsp;&nbsp;Windows CE: </b>Unsupported.<br>
<b>&nbsp;&nbsp;Header: </b>Declared in wincrypt.h.<br>
<b>&nbsp;&nbsp;Import Library: </b>Use crypt32.lib.</p>
<h4>See Also</h4>
<p>
<a href="llmsg_3485.htm"><b>CryptMsgClose</b></a>,<b> <a href="llmsg_6rtx.htm">CryptMsgUpdate</a></b>,<b> <a href="llmsg_6xm5.htm">CryptMsgGetParam</a></b>,<b> <a href="llmsg_5azp.htm">CryptMsgOpenToEncode</a> </b></p>
<p>&nbsp;</p></body>
</HTML>
