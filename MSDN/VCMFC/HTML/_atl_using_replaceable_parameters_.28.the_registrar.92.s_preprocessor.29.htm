<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Using Replaceable Parameters (The Registrar's Preprocessor)</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY>
<font face="verdana,arial,helvetica" size="2">
<h1><a name="_atl_using_replaceable_parameters_.28.the_registrar.92.s_preprocessor.29"></a>Using Replaceable Parameters (The Registrar's Preprocessor)</h1>
<p>
Replaceable parameters allow a Registrar's client to specify run-time data. To do this, the Registrar maintains a replacement map into which it enters the values associated with the replaceable parameters in your script. The Registrar makes these entries at run time. The following section demonstrates these steps.</p>

<h2><a name="_atl_using_.25.module.25"></a>Using %MODULE%</h2>
<p>
The ATL Object Wizard automatically generates a script that uses <code>%MODULE%</code>. ATL uses this replaceable parameter for the actual location of your server's DLL or EXE.</p>
<p>
Besides adding <code>%MODULE%</code> to the script, the ATL Object Wizard also adds the following line to the object's class declaration:</p>
<pre><code>DECLARE_REGISTRY_RESOURCEID(IDR_MYCOMAPP)
</code></pre>
<p>
This macro expands to:</p>
<pre><code>static HRESULT WINAPI UpdateRegistry(BOOL bRegister)
{
 &nbsp; return _Module.UpdateRegistryFromResource(IDR_MYCOMAPP, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bRegister);
}
</code></pre>
<p>
where <code>_Module</code> refers to the global <a href="_atl_ccommodule.htm">CComModule</a>, which has the following method and <b>#define</b> statement:</p>
<pre><code>UpdateRegistryFromResource(UINT nResID, BOOL bRegister,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct _ATL_REGMAP_ENTRY* pMapEntries = NULL);

#define UpdateRegistryFromResource 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UpdateRegistryFromResource
</code></pre>
<p>
This method calls <code>AtlModuleUpdateRegistryFromResource</code>, which contains the following code:</p>
<pre><code>ATLAPI AtlModuleUpdateRegistryFromResource(_ATL_MODULE*pM, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LPCOLESTR lpszRes, BOOL bRegister, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct _ATL_REGMAP_ENTRY* pMapEntries, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IRegistrar* pReg)
{
 &nbsp; USES_CONVERSION;
 &nbsp; ...
 &nbsp; CComPtr&lt;IRegistrar&gt; p;
 &nbsp; ...

 &nbsp; TCHAR szModule[_MAX_PATH];
 &nbsp; GetModuleFileName(pM-&gt;m_hInst, szModule, _MAX_PATH);
 &nbsp; p-&gt;AddReplacement(OLESTR("Module"), T2OLE(szModule));

 &nbsp; ...
}
</code></pre>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;You can find this code in atl\include\atlimpl.cpp.</p>
<p>
<b>CoCreateInstance</b> acquires the pointer <code>p</code>, which points to the Registrar. Then, <b>AddReplacement</b> receives an <b>LPCOLESTR</b> containing the string "<code>Module</code>", as well as an <b>LPCOLESTR</b> containing the string acquired from the Win32 API function, <object id=alink_1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="DefaultTopic" value="_topic_not_found.htm">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="_win32_GetModuleFileName">
</object><a href=JavaScript:alink_1.Click()>GetModuleFileName</a>. This code adds a replacement map entry for the <code>Module</code> variable that has a value associated with the result of <b>GetModuleFileName</b>. Now, when the preprocessor sees the <code>%MODULE%</code> in the script, it will replace it with the value from <b>GetModuleFileName</b>.</p>
<h2>Concatenating run-time data with script data</h2>
<p>
Another use of the preprocessor is to concatenate run-time data with script data. For example, suppose we need an entry that contains a full path to a module with the string "<code>, 1</code>" appended at the end. First, define the following expansion:</p>
<pre><code>'MyGoofyKey' = s '%MODULE%, 1'
</code></pre>
<p>
Then, before calling one of the script processing methods, add a replacement to the map:</p>
<pre><code>TCHAR szModule[_MAX_PATH]
GetModuleFileName(pM-&gt;m_hInst, szModule, _MAX_PATH);
p-&gt;AddReplacement(OLESTR("Module"), T2OLE(szModule));
</code></pre>
<p>
During the parsing of the script, the Registrar expands <code>'%MODULE%, 1'</code> to <code>c:\mycode\mydll.dll, 1</code>.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;In a Registrar script, 4K is the maximum token size. (A token is any recognizable element in the syntax.) This includes tokens that were created or expanded by the preprocessor.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;To substitute replacement values at run time, remove the call to <a href="_atl_declare_registry_resource.htm">DECLARE_REGISTRY_RESOURCE</a> or <a href="_atl_declare_registry_resourceid.htm">DECLARE_REGISTRY_RESOURCEID</a> macro. Instead, replace it with your own <b>UpdateRegistry</b> member function that calls <a href="_atl_ccommodule.3a3a.updateregistryfromresourced.htm">CComModule::UpdateRegistryFromResource</a>, and pass your array of <b>_ATL_REGMAP_ENTRY</b> structures. Your array of <b>_ATL_REGMAP_ENTRY</b> must have at least one entry that is set to {<b>NULL</b>,<b>NULL</b>}, and this entry should always be the last entry. Otherwise, an access violation error will be generated when <b>UpdateRegistryFromResrouce</b> is called.</p>
</font></BODY>
</HTML>
