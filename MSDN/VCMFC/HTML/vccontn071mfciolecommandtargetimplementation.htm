<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>TN071: MFC IOleCommandTarget Implementation</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY>
<font face="verdana,arial,helvetica" size="2">
<h1><a name="vccontn071mfciolecommandtargetimplementation"></a>TN071: MFC IOleCommandTarget Implementation</h1>
<p>
The <b>IOleCommandTarget</b> interface enables objects and their containers to dispatch commands to each other. For example, an object's toolbars may contain buttons for commands such as <b>Print</b>, <b>Print Preview</b>, <b>Save</b>, <b>New</b>, and <b>Zoom</b>. If such an object were embedded in a container that supports <b>IOleCommandTarget</b>, the object could enable its buttons and forward the commands to the container for processing when the user clicked them. If a container wanted the embedded object to print itself, it could make this request by sending a command through the <b>IOleCommandTarget</b> interface of the embedded object.</p>
<p>
<b>IOleCommandTarget</b> is an Automation-like interface in that it is used by a client to invoke methods on a server. However, using <b>IOleCommandTarget</b> saves the overhead of making calls via Automation interfaces because programmers don't have to use the typically expensive <b>Invoke</b> method of <b>IDispatch</b>.</p>
<p>
In MFC, the <b>IOleCommandTarget</b> interface is used by Active document servers to allow Active document containers to dispatch commands to the server. The Active document server class, <b>CDocObjectServerItem</b>, uses MFC interface maps (see <a href="_mfcnotes_tn038.htm">TN038: MFC/OLE IUnknown Implementation</a>) to implement the <b>IOleCommandTarget</b> interface.</p>
<p>
<b>IOleCommandTarget</b> is also implemented in the <b>COleFrameHook</b> class. <b>COleFrameHook</b> is an undocumented MFC class that implements the frame window functionality of in-place editing containers. <b>COleFrameHook</b> also uses MFC interface maps to implement the <b>IOleCommandTarget</b> interface. <b>COleFrameHook</b>'s implementation of <b>IOleCommandTarget</b> forwards OLE commands to <b>COleDocObjectItem</b>-derived Active document containers. This allows any MFC Active document container to receive messages from contained Active document servers.</p>
<p class=label>
<b>MFC OLE Command Maps</b></p>
<p>
MFC developers can take advantage of <b>IOleCommandTarget</b> by using MFC OLE command maps. OLE command maps are like message maps because they can be used to map OLE commands to member functions of the class that contains the command map. To make this work, place macros in the command map to specify the OLE command group of the command you want to handle, the OLE command, and the command ID of the <object id=alink_1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="DefaultTopic" value="_topic_not_found.htm">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="_win32_wm_command">
</object><a href=JavaScript:alink_1.Click()>WM_COMMAND</a> message that will be sent when the OLE command is received. MFC also provides a number of predefined macros for standard OLE commands. For a list of the standard OLE commands that were originally designed for use with Microsoft Office applications, see the OLECMDID enumeration, which is defined in docobj.h. </p>
<p>
When an OLE command is received by an MFC application that contains an OLE command map, MFC tries to find the command ID and command group for the requested command in the OLE command map of the application. If a match is found, a <b>WM_COMMAND</b> message is dispatched to the application containing the command map with the ID of the requested command. (See the description of <b>ON_OLECMD</b> below.) In this way, OLE commands dispatched to an application are turned into <b>WM_COMMAND</b> messages by MFC. The <b>WM_COMMAND</b> messages are then routed through the application's message maps using the MFC standard <object id=alink_2 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="DefaultTopic" value="_topic_not_found.htm">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="_core_Command_Routing">
</object><a href=JavaScript:alink_2.Click()>command routing</a> architecture.</p>
<p>
Unlike message maps, MFC OLE command maps are not supported by ClassWizard. MFC developers must add OLE command map support and OLE command map entries by hand. OLE command maps can be added to MFC Active document servers in any class that is in the <b>WM_COMMAND</b> message-routing chain at the time the Active document is in-place active in a container. These classes include the application's classes derived from <a href="_mfc_cwinapp.htm">CWinApp</a>, <a href="_mfc_cview.htm">CView</a>, <a href="_mfc_cdocument.htm">CDocument</a>, and <a href="_mfc_coleipframewnd.htm">COleIPFrameWnd</a>. In Active document containers, OLE command maps can only be added to the <a href="_mfc_coledocobjectitem.htm">COleDocObjectItem</a>-derived class. Also, in Active document containers, the <b>WM_COMMAND</b> messages will only be dispatched to the message map in the <b>COleDocObjectItem</b>-derived class. </p>
<p class=label>
<b>OLE Command Map Macros</b></p>
<p>
Use the following macros to add command map functionality to your class:</p>
<pre><code>DECLARE_OLECMD_MAP ()
</code></pre>
<p>
This macro goes in the class declaration (typically in the header file) of the class that contains the command map.</p>
<pre><code>BEGIN_OLECMD_MAP(theClass, baseClass)
</code></pre>
<p class=dt>
<code>theClass</code></p>
<p class=indent>
Name of the class that contains the command map.</p>
<p class=dt>
<code>baseClass</code></p>
<p class=indent>
Name of the base class of the class that contains the command map.</p>
<p>
This macro marks the beginning of the command map. Use this macro in the implementation file for the class that contains the command map.</p>
<pre><code>END_OLECMD_MAP()
</code></pre>
<p>
This macro marks the end of the command map. Use this macro in the implementation file for the class that contains the command map. This macro must always follow the <code>BEGIN_OLECMD_MAP</code> macro.</p>
<pre><code>ON_OLECMD(pguid, olecmdid, id)
</code></pre>
<p class=dt>
<code>pguid</code></p>
<p class=indent>
Pointer to the GUID of the OLE command's command group. This parameter is <b>NULL</b> for the standard OLE command group.</p>
<p class=dt>
<code>olecmdid</code></p>
<p class=indent>
OLE command ID of the command to be invoked.</p>
<p class=dt>
<code>id</code></p>
<p class=indent>
ID of the <b>WM_COMMAND</b> message to be sent to the application containing the command map when this OLE command is invoked.</p>
<p>
Use the <code>ON_OLECMD</code> macro in the command map to add entries for the OLE commands you want to handle. When the OLE commands are received, they will be converted to the specified <b>WM_COMMAND</b> message and routed through the application's message map using the standard MFC command-routing architecture.</p>
<p class=label>
<b>Example</b></p>
<p>
The following example shows how to add OLE command-handling capability to an MFC Active document server to handle the <object id=alink_3 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="DefaultTopic" value="_topic_not_found.htm">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="_com_olecmdid">
</object><a href=JavaScript:alink_3.Click()>OLECMDID_PRINT</a> OLE command. This example assumes that you used AppWizard to generate an MFC application that is an Active document server.
<ol>
<li>
In your <b>CView</b>-derived class's header file, add the <code>DECLARE_OLECMD_MAP</code> macro to the class declaration. <p class=atl>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;Use the <b>CView</b>-derived class because it is one of the classes in the Active document server that is in the <b>WM_COMMAND</b> message-routing chain.</p><pre><code>class CMyServerView : public CView
{
protected: // create from serialization only
CMyServerView();
DECLARE_DYNCREATE(CMyServerView)
DECLARE_OLECMD_MAP()
. . .
};
</code></pre>
</li>
<li>
In the implementation file for the <b>CView</b>-derived class, add the <code>BEGIN_OLECMD_MAP</code> and <code>END_OLECMD_MAP</code> macros:<pre><code>BEGIN_OLECMD_MAP(CMyServerView, CView)

END_OLECMD_MAP()
</code></pre>
</li>
<li>
To handle the standard OLE print command, add an <a href="_mfc_on_olecmd.htm">ON_OLECMD</a> macro to the command map specifying the OLE command ID for the standard print command and <b>ID_FILE_PRINT</b> for the <b>WM_COMMAND</b> ID. <b>ID_FILE_PRINT</b> is the standard print command ID used by AppWizard-generated MFC applications:<pre><code>BEGIN_OLECMD_MAP(CMyServerView, CView)
ON_OLECMD(NULL,OLECMDID_PRINT,ID_FILE_PRINT)
END_OLECMD_MAP()
</code></pre>
</li>
</ol>
<p>
Note that one of the standard OLE command macros, defined in afxdocob.h, could be used in place of the <b>ON_OLECMD</b> macro because <b>OLECMDID_PRINT</b> is a standard OLE command ID. The <b>ON_OLECMD_PRINT</b> macro will accomplish the same task as the <b>ON_OLECMD</b> macro shown above.</p>
<p>
When a container application sends this server an <b>OLECMDID_PRINT</b> command through the server's <b>IOleCommandTarget</b> interface, the MFC printing command handler will be invoked in the server, causing the server to print the application. The Active document container's code to invoke the print command added in the steps above would look something like this:</p>
<pre><code>void CContainerCntrItem::DoOleCmd()
{
   IOleCommandTarget *pCmd = NULL;
   HRESULT hr = E_FAIL;
   OLECMD ocm={OLECMDID_PRINT, 0};

   hr = m_lpObject-&gt;QueryInterface(IID_IOleCommandTarget,reinterpret_cast&lt;void**&gt;(&amp;pCmd));
   if(FAILED(hr))
      return;

   hr = pCmd-&gt;QueryStatus(NULL, 1, &amp;ocm, NULL);
   if(SUCCEEDED(hr) &amp;&amp; (ocm.cmdf &amp; OLECMDF_ENABLED))
   {
      //Command is available and enabled so call it
      COleVariant vIn;
      COleVariant vOut;
      hr = pCmd-&gt;Exec(NULL, OLECMDID_PRINT,
 OLECMDEXECOPT_DODEFAULT, &amp;vIn, &amp;vOut);
      ASSERT(SUCCEEDED(hr));
   }
   pCmd-&gt;Release();
}
</code></pre>
<p>
<a href="_mfcnotes_technical_notes_by_number.htm">Technical Notes by Number</a>  |&nbsp; <a href="_mfcnotes_technical_notes_by_category.htm">Technical Notes by Category</a></p>
</font></BODY>
</HTML>
