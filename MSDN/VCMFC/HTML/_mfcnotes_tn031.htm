<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>TN031: Control Bars</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY>
<font face="verdana,arial,helvetica" size="2">
<h1><a name="_mfcnotes_tn031"></a>TN031: Control Bars</h1>
<p>
This note describes the control bar classes in MFC: the general <a href="#_mfcnotes_ccontrolbar">CControlBar</a>, <a href="#_mfcnotes_cstatusbar">CStatusBar</a>, <a href="#_mfcnotes_ctoolbar">CToolBar</a>, <a href="#_mfcnotes_cdialogbar">CDialogBar</a>, and <b>CDockBar</b>.</p>

<p class=label>
<b><a name="_mfcnotes_ccontrolbar"></a>CControlBar</b></p>
<p>
A <b>ControlBar</b> is a <b>CWnd</b>-derived class that:
<ul type=disc>
<li>
Is aligned to the top or bottom of a frame window.<br><br></li>
<li>
May contain child items that are either HWND-based controls (for example, <b>CDialogBar</b>) or non-<b>HWND</b> based items (for example, <b>CToolBar</b>, <b>CStatusBar</b>).</li>
</ul>
<p>
Control bars support the additional styles:
<ul type=disc>
<li>
<b>CBRS_TOP</b>&nbsp;&nbsp;&nbsp;(the default) pin the control bar to the top<br><br></li>
<li>
<b>CBRS_BOTTOM</b>&nbsp;&nbsp;&nbsp;pin the control bar to the bottom<br><br></li>
<li>
<b>CBRS_NOALIGN</b>&nbsp;&nbsp;&nbsp;don't reposition the control bar when the parent resizes</li>
</ul>
<p>
Classes derived from <b>CControlBar</b> provide more interesting implementations:
<ul type=disc>
<li>
<b>CStatusBar</b>&nbsp;&nbsp;&nbsp;a status bar, items are status bar panes containing text<br><br></li>
<li>
<b>CToolBar</b>&nbsp;&nbsp;&nbsp;a toolbar, items are bitmap buttons aligned in a row<br><br></li>
<li>
<b>CDialogBar</b>&nbsp;&nbsp;&nbsp;a toolbar-like frame containing standard windows controls (created from a dialog template resource)<br><br></li>
<li>
<b>CDockBar</b>&nbsp;&nbsp;&nbsp;a generalized docking area for other <b>CControlBar</b> derived objects.&nbsp; The specific member functions and variables available in this class are likely to change in future releases.</li>
</ul>
<p>
All control bar objects/windows will be child windows of some parent frame window. They are usually added as a sibling to the client area of the frame (for example, an MDI Client or view). The child window ID of a control bar is important. The default layout of control bar only works for control bars with IDs in the range of <b>AFX_IDW_CONTROLBAR_FIRST</b> to <b>AFX_IDW_CONTROLBAR_LAST</b>. Note that even though there is a range of 256 control bar IDs, the first 32 of these control bar IDs are special since they are directly supported by the print preview architecture.</p>
<p>
The <b>CControlBar</b> class gives standard implementation for
<ul type=disc>
<li>
Aligning the control bar to the top, bottom, or either side of the frame.<br><br></li>
<li>
Allocating control item arrays.<br><br></li>
<li>
Supporting the implementation of derived classes.</li>
</ul>
<p>
C++ control bar objects will usually be embedded as members of a <b>CFrameWnd</b> derived class, and will be cleaned up when the parent <b>HWND</b> and object are destroyed. If you need to allocate a control bar object on the heap, you can simply set the <b>m_bAutoDestruct</b> member to <b>TRUE</b> to make the control bar “<b>delete this</b>” when the <b>HWND</b> is destroyed.</p>
<p class=indent>
<B><b>Important</b></B>&nbsp;&nbsp;&nbsp;If you create your own <b>CControlBar</b>-derived class, rather than using one of MFC's derived classes, such as <b>CStatusBar</b>, <b>CToolBar</b>, or <b>CDialogBar</b>, you will need to set the <b>m_dwStyle</b> data member. This can be done in the override of <b>Create</b>:</p>
<pre><code>// CMyControlBar is derived from CControlBar
BOOL CMyControlBar::Create( CWnd* pParentWnd, DWORD dwStyle, UINT nID )
{
 &nbsp; m_dwStyle = dwStyle;

 &nbsp; .
 &nbsp; .
 &nbsp; .
}
</code></pre>
<p class=label>
<b>Control Bar Layout Algorithm</b></p>
<p>
The control bar layout algorithm is very simple. The frame window sends a message <b>WM_SIZEPARENT</b> to all children in the control bar range. Along with this message, a pointer to the parent's client rectangle is passed. This message is sent to children in Z-order. The control-bar children use this information to position themselves and to decrease the size of the parent's client area. The final rectangle that is left for the normal client area (less control bars) is used to position the main client window (usually an MDI client, view or splitter window).</p>
<p>
See <b>CWnd::RepositionBars</b> and <b>CFrameWnd::RecalcLayout</b> for more details.</p>
<p>
MFC private Windows messages, including <b>WM_SIZEPARENT</b>, are documented in <a href="_mfcnotes_tn024.htm">Technical Note 24</a>.</p>

<p class=label>
<b><a name="_mfcnotes_cstatusbar"></a>CStatusBar</b></p>
<p>
A status bar is a control bar which has a row of text output panes. There are two common ways to use text output panes:
<ul type=disc>
<li>
As a message line<p class=tl>
(for example, the standard menu help message line). These are usually accessed by a 0-based indexed</P></li>
<li>
As status indicators<p class=tl>
(for example, the CAP, NUM and SCRL indicators). These are usually accessed by string/command ID.</P></li>
</ul>
<p>
The font for the status bar is 10 point “MS Sans Serif” (dictated by the Windows Interface Application Design Guide or the font mappers best match of a 10-point Swiss proportional font). On certain versions of Windows, such as the Japanese edition and Windows 4.0, the fonts selected are different.</p>
<p>
The colors used in the status bar are also consistent with the recomendation of the Windows Interface Application Design Guide. These colors are not hard coded and are changed dynamically in response to user customization via the Control Panel.</p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows>
<tr valign=top>
<td class=label width=31%><b>Item</b></td>
<td class=label width=35%><b>Windows COLOR value</b></td>
<td class=label width=34%><b>Default RGB</b></td>
</tr>
<tr valign=top>
<td width=31%>Status bar background</td>
<td width=35%><b>COLOR_BTNFACE</b></td>
<td width=34%>RGB(192, 192, 192)</td>
</tr>
<tr valign=top>
<td width=31%>Status bar text</td>
<td width=35%><b>COLOR_BTNTEXT</b></td>
<td width=34%>RGB(000, 000, 000)</td>
</tr>
<tr valign=top>
<td width=31%>Status bar top/left edges</td>
<td width=35%><b>COLOR_BTNHIGHLIGHT</b></td>
<td width=34%>RGB(255, 255, 255)</td>
</tr>
<tr valign=top>
<td width=31%>Status bar bot/right edges</td>
<td width=35%><b>COLOR_BTNSHADOW</b></td>
<td width=34%>RGB(128, 128, 128)</td>
</tr>
</table><br>
<p class=label>
<b>CCmdUI Support for CStatusBar</b></p>
<p>
The way indicators are usually updated is through the <b>ON_UPDATE_COMMAND_UI</b> mechanism. On idle time, the status bar will call the <b>ON_UPDATE_COMMAND_UI</b> handler with the string ID of the indicator pane.</p>
<p>
The <b>ON_UPDATE_COMMAND_UI</b> handler can call:
<ul type=disc>
<li>
<b>Enable</b>:&nbsp; to enable or disable the pane. A disabled pane looks exactly like an enabled pane but the text is invisible (that is, turns off the text indicator).<br><br></li>
<li>
<b>SetText</b>:&nbsp; to change the text. Be careful if you use this since the pane will not automatically resize.</li>
</ul>
<p>
Please refer to class <a href="_mfc_cstatusbar.htm">CStatusBar</a> in the <i>Class Library Reference</i> for details about <b>CStatusBar</b> creation and customization APIs. Most customization of status bars should be done before the status bar is initially made visible.</p>
<p>
The status bar supports only one stretchy pane, usually the first pane. The size of that pane is really a minimum size. If the status bar is bigger than the minimum size of all the panes, any extra width will be given to the stretchy pane. The default application with a status bar has right-aligned indicators for CAP, NUM and SCRL since the first pane is stretchy.</p>

<p class=label>
<b><a name="_mfcnotes_ctoolbar"></a>CToolBar</b></p>
<p>
A toolbar is a control bar with a row of bitmap buttons that may include separators. Two styles of buttons are supported: pushbuttons and check box buttons. Radio group functionality can be built with check box buttons and <b>ON_UPDATE_COMMAND_UI</b>.</p>
<p>
All the bitmap buttons in the toolbar are taken from one bitmap. This bitmap must contain one image or glyph for each button. Typically the order of the images/glyphs in the bitmap is the same order they will be drawn on the screen. (This can be changed using the customization APIs.)</p>
<p>
Each button must be the same size. The default is the standard 24x22 pixels. Each image/glyph must be the same size and must be side-by-side in the bitmap. The default image/glyph size is 16x15 pixels. Therefore, for a toolbar with 10 buttons (using standard sizes), you need a bitmap that is 160 pixels wide and 15 pixels high.</p>
<p>
Each button has one and only one image/glyph. The different button states and styles (for example, pressed, up, down, disabled, disabled down, indeterminate) are algorithmically generated from that one image/glyph. Any color bitmap or DIB can be used in theory. The algorithm for generating the different button states works best if the original image is shades of gray. Look at the standard toolbar buttons and the toolbar button clipart provided in MFC General sample <object id=alink_1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="DefaultTopic" value="_topic_not_found.htm">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="_sample_mfc_CLIPART">
</object><a href=JavaScript:alink_1.Click()>CLIPART</a> for examples.</p>
<p>
The colors used in the toolbar are also consistent with the recommendation of the Windows Interface Application Design Guide. These colors are not hard coded and are changed dynamically in response to user customization via the Control Panel. </p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows>
<tr valign=top>
<td class=label width=30%><b>Item</b></td>
<td class=label width=36%><b>Windows COLOR value</b></td>
<td class=label width=34%><b>Default RGB</b></td>
</tr>
<tr valign=top>
<td width=30%>ToolBar background </td>
<td width=36%><b>COLOR_BTNFACE</b></td>
<td width=34%>RGB(192,192,192)</td>
</tr>
<tr valign=top>
<td width=30%>ToolBar buttons top/left edges</td>
<td width=36%><b>COLOR_BTNHIGHLIGHT</b></td>
<td width=34%>RGB(255,255,255)</td>
</tr>
<tr valign=top>
<td width=30%>ToolBar buttons bot/right edges</td>
<td width=36%> <b>COLOR_BTNSHADOW</b></td>
<td width=34%>RGB(128,128,128)</td>
</tr>
</table><br>
<p>
In addition, the toolbar bitmap buttons are recolored as though they were standard Windows button controls. This recoloring occurs when the bitmap is loaded from the resource and in response to a change in system colors in response to user customization via the Control Panel. The following colors in a toolbar bitmap will be recolored automatically so they should be used with caution. If you do not wish to have a portion of your bitmap recolored, then use a color that closely approximates one of the mapped RGB values. The mapping is done based on exact RGB values.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=37%><b>RGB Value</b></td>
<td class=label width=63%><b>Dynamically mapped COLOR value</b></td>
</tr>
<tr valign=top>
<td width=37%>RGB(000, 000, 000)</td>
<td width=63%>COLOR_BTNTEXT</td>
</tr>
<tr valign=top>
<td width=37%>RGB(128, 128, 128)</td>
<td width=63%>COLOR_BTNSHADOW</td>
</tr>
<tr valign=top>
<td width=37%>RGB(192, 192, 192)</td>
<td width=63%>COLOR_BTNFACE</td>
</tr>
<tr valign=top>
<td width=37%>RGB(255, 255, 255)</td>
<td width=63%>COLOR_BTNHIGHLIGHT</td>
</tr>
</table><br>
<p>
Please refer to class <a href="_mfc_ctoolbar.htm">CToolBar</a> the <i>Class Library Reference</i> for details about the <b>CToolBar</b> creation and customization APIs. Most customization of toolbars should be done before the toolbar is initially made visible.</p>
<p>
The customization APIs can be used to adjust the button IDs, styles, spacer width and which image/glyph is used for what button. By default you do not need to use these APIs.</p>
<p class=label>
<b>CCmdUI Support for CToolBar</b></p>
<p>
The way toolbar buttons are always updated is through the <b>ON_UPDATE_COMMAND_UI</b> mechanism. On idle time, the toolbar will call the <b>ON_UPDATE_COMMAND_UI</b> handler with the command ID of that button. <b>ON_UPDATE_COMMAND_UI</b> is not called for separators, but it is called for pushbuttons and check box buttons.</p>
<p>
The <b>ON_UPDATE_COMMAND_UI</b> handler can call:
<ul type=disc>
<li>
<b>Enable</b>:&nbsp; to enable or disable the button. This works equally for pushbuttons and check box buttons.<br><br></li>
<li>
<b>SetCheck</b>:&nbsp; to set the check state of a button. Calling this for a toolbar button will turn it into a check box button. <b>SetCheck</b> takes a parameter which can be 0 (not checked), 1 (checked) or 2 (indeterminate)<br><br></li>
<li>
<b>SetRadio</b>:&nbsp; shorthand for <b>SetCheck</b>.</li>
</ul>
<p>
Check box buttons are “AUTO” check box buttons; that is, when the user presses them they will immediately change state. Checked is the down or depressed state. There is no built-in user interface way to change a button into the “indeterminate” state; that must be done through code.</p>
<p>
The customization APIs will permit you to change the state of a given toolbar button, preferably you should change these states in the <b>ON_UPDATE_COMMAND_UI</b> handler for the command the toolbar button represents. Remember, the idle processing will change the state of toolbar buttons with the <b>ON_UPDATE_COMMAND_UI</b> handler, so any changes to these states made through SetButtonStyle may get lost after the next idle.</p>
<p>
Toolbar buttons will send <b>WM_COMMAND</b> messages like normal buttons or menu items and are normally handled by an <b>ON_COMMAND</b> handler in the same class that provides the <b>ON_UPDATE_COMMAND_UI</b> handler.</p>
<p>
There are four Toolbar button styles (TBBS_ values) used for display states:
<ul type=disc>
<li>
TBBS_CHECKED:&nbsp;&nbsp;&nbsp;check box is currently checked (down)<br><br></li>
<li>
TBBS_INDETERMINATE:&nbsp;&nbsp;&nbsp;check box is currently indeterminate<br><br></li>
<li>
TBBS_DISABLED:&nbsp;&nbsp;&nbsp;button is currently disabled<br><br></li>
<li>
TBBS_PRESSED:&nbsp;&nbsp;&nbsp;button is currently pressed</li>
</ul>
<p>
The six official Windows Interface Application Design Guide button styles are represented by the following TBBS values:
<ul type=disc>
<li>
Up = 0<br><br></li>
<li>
Mouse Down = TBBS_PRESSED (| any other style)<br><br></li>
<li>
Disabled = TBBS_DISABLED<br><br></li>
<li>
Down = TBBS_CHECKED<br><br></li>
<li>
Down Disabled = TBBS_CHECKED | TBBS_DISABLED<br><br></li>
<li>
Indeterminate = TBBS_INDETERMINATE</li>
</ul>

<p class=label>
<b><a name="_mfcnotes_cdialogbar"></a>CDialogBar</b></p>
<p>
A dialog bar is a control bar that contains standard Windows controls. It acts like a dialog in that it contains the controls and supports tabbing between them. It also acts like a dialog in that it uses a dialog template to represent the bar.</p>
<p>
A <b>CDialogBar</b> is used for the print-preview toolbar, which contains standard pushbutton controls.</p>
<p>
Using a <b>CDialogBar</b> is like using a <b>CFormView</b>. You must define a dialog template for the dialog bar and remove all the styles except <b>WS_CHILD</b>. Note that the dialog must not be visible.</p>
<p>
The control notifications for a <b>CDialogBar</b> will be sent to the parent of the control bar (just like toolbar buttons).</p>
<p class=label>
<b>CCmdUI Support for CDialogBar</b></p>
<p>
Dialog bar buttons should be updated through the <b>ON_UPDATE_COMMAND_UI</b> handler mechanism. At idle time, the dialog bar will call the <b>ON_UPDATE_COMMAND_UI</b> handler with the command ID of all the buttons that have a ID &gt;= 0x8000 (that is, in the range of command IDs).</p>
<p>
The <b>ON_UPDATE_COMMAND_UI</b> handler can call:
<ul type=disc>
<li>
Enable:&nbsp; to enable or disable the button.<br><br></li>
<li>
SetText:&nbsp; to change the text of the button.</li>
</ul>
<p>
Customization can be done through standard window manager APIs.</p>
<p>
<a href="_mfcnotes_technical_notes_by_number.htm">Technical Notes by Number</a>  |&nbsp; <a href="_mfcnotes_technical_notes_by_category.htm">Technical Notes by Category</a></p>
</font></BODY>
</HTML>
