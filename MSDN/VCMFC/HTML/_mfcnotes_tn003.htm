<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>TN003: Mapping of Windows Handles to Objects</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY>
<font face="verdana,arial,helvetica" size="2">
<h1><a name="_mfcnotes_tn003"></a><sup></sup>TN003: Mapping of Windows Handles to Objects</h1>
<p>
This note describes the MFC routines that support mapping Windows object handles to C++ objects.</p>
<p class=label>
<b>The Problem</b></p>
<p>
Windows objects are normally represented by <b>HANDLE</b>s. The MFC classes wrap Windows object handles with C++ objects. The handle wrapping functions of the MFC class library provide a way to find the C++ object that is wrapping the Windows object with a particular handle. There are times when a Windows object does not have a C++ wrapper object, however, and at these times a temporary object is created to act as the C++ wrapper.</p>
<p>
The Windows objects that use handle maps are:
<ul type=disc>
<li>
<b>HWND</b> (<b>CWnd</b> and <b>CWnd</b>-derived classes)<br><br></li>
<li>
<b>HDC</b> (<b>CDC</b> and <b>CDC</b>-derived classes)<br><br></li>
<li>
<b>HMENU</b> (<b>CMenu</b>)<br><br></li>
<li>
<b>HPEN</b> (<b>CGdiObject</b>)<br><br></li>
<li>
<b>HBRUSH</b> (<b>CGdiObject</b>)<br><br></li>
<li>
<b>HFONT</b> (<b>CGdiObject</b>)<br><br></li>
<li>
<b>HBITMAP</b> (<b>CGdiObject</b>)<br><br></li>
<li>
<b>HPALETTE</b> (<b>CGdiObject</b>)<br><br></li>
<li>
<b>HRGN</b> (<b>CGdiObject</b>)<br><br></li>
<li>
<b>HIMAGELIST</b> (<b>CImageList</b>)<br><br></li>
<li>
<b>SOCKET</b> (<b>CSocket</b>)</li>
</ul>
<p>
Given a handle to any of these objects, you can find the MFC object that wraps the handle by calling the static member function <b>FromHandle</b>. For example, given an <b>HWND</b> called <i>hWnd</i>:</p>
<pre><code>CWnd::FromHandle(hWnd)
</code></pre>
<p>
will return a pointer to the <b>CWnd</b> that wraps the <i>hWnd</i>. If that <i>hWnd</i> does not have a specific wrapper object, then a temporary <b>CWnd</b> is created to wrap the <b>hWnd</b>. This makes it possible to get a valid C++ object from any handle.</p>
<p>
Once you have a wrapper object, you can get to its handle through a public member variable. In the case of an <b>CWnd</b>, <i>m_hWnd</i> contains the <b>HWND</b> for that object.</p>
<p class=label>
<b>Attaching Handles to MFC Objects</b></p>
<p>
Given a newly created handle-wrapper object and a handle to a Windows object, you can associate the two by calling <b>Attach</b>. For example:</p>
<pre><code>CWnd myWnd;
myWnd.Attach(hWnd);
</code></pre>
<p>
This makes an entry in the permanent map associating <i>myWnd</i> and <i>hWnd</i>. Calling <b>CWnd::FromHandle</b>(<i>hWnd</i>) will now return a pointer to <i>myWnd</i>. When <i>myWnd</i> is deleted, the destructor will automatically destroy the hWnd by calling the Windows <b>DestroyWindow</b> function. If this is not desired, the <i>hWnd</i> must be detached from <i>myWnd</i> before the <i>myWnd</i> object is destroyed (normally when leaving the scope at which <i>myWnd</i> was defined). The <b>Detach</b> member function does this.</p>
<pre><code>myWnd.Detach();
</code></pre>
<p class=label>
<b>More About Temporary Objects</b></p>
<p>
Temporary objects are created whenever <b>FromHandle</b> is given a handle that does not already have a wrapper object. These temporary objects are detached from their handle and deleted by the <b>DeleteTempMap</b> functions. The default <b>OnIdle</b> processing in <b>CWinThread</b> automatically calls <b>DeleteTempMap</b> for each class that supports temporary handle maps. This means that you cannot assume a pointer to a temporary object will be valid past the point of exit from the function where the pointer was obtained, as the temporary object will be deleted during the Windows message-loop idle time.</p>
<p class=label>
<b>Wrapper Objects and Multiple Threads</b></p>
<p>
Both temporary and permanent objects are maintained on a per-thread basis. That is, one thread cannot access another threads C++ wrapper objects, regardless of whether it is temporary or permanent. As stated above, temporary objects are deleted when the thread which that temporary object belongs enters <b>OnIdle</b>.</p>
<p>
To pass these objects from one thread to another, always send them as their native <b>HANDLE</b> type. Passing a C++ wrapper object from one thread to another will often result in unexpected results.</p>
<p>
<a href="_mfcnotes_technical_notes_by_number.htm">Technical Notes by Number</a>  |&nbsp; <a href="_mfcnotes_technical_notes_by_category.htm">Technical Notes by Category</a></p>
</font></BODY>
</HTML>
