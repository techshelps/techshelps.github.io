<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>TN011: Using MFC as Part of a DLL</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY>
<font face="verdana,arial,helvetica" size="2">
<h1><a name="_mfcnotes_tn011"></a>TN011: Using MFC as Part of a DLL</h1>
<p>
This note describes regular DLLs, which allow you to use the MFC library as part of a Windows dynamic-link library (DLL). It assumes you are familiar with Windows DLLs and how to build them. For information about MFC extension DLLs, which allow you to create extensions to the MFC library, see <a href="_mfcnotes_tn033.htm">DLL Version of MFC</a>.</p>
<p class=label>
<b>DLL Interfaces</b></p>
<p>
Regular DLLs assume interfaces between the application and the DLL are specified in normal C-like functions or explicitly exported classes. MFC class interfaces cannot be exported.</p>
<p>
If both a DLL and an application want to use MFC, then both have a choice to either use the shared version of the MFC libraries or have a copy of the MFC library statically linked into them. In versions prior to Visual C++ 4.0, the MFC static link libraries were different for applications and DLLs. With the current version of MFC, the application and DLL may both use one of the standard versions of the MFC library. There is not a separate library for DLLs in this version (MFC makes the choice at runtime).</p>
<p>
Regular DLLs have several advantages:
<ul type=disc>
<li>
The application using the DLL does not have to use MFC or, for that matter, it does not have to be a Visual C++ application.<br><br></li>
<li>
With regular DLLs that statically link to MFC, the size of the DLL depends only on those MFC and C runtime routines that are used and linked by the linker. <br><br></li>
<li>
The file size of regular DLLs that dynamically link to MFC may be much smaller than regular DLLs that statically link to MFC, and the savings in memory from using the shared version of MFC can be significant. However, you must distribute the shared DLLs MFCx0.DLL and MSVCRTx0.DLL (or similar files) with your DLL. <br><br></li>
<li>
There are no problems with classes changing underneath you. Your DLL design exports only those APIs you wish it to.<br><br></li>
<li>
With regular DLLs that statically link to MFC, if both DLL and application use MFC, there are no problems with the application wanting a different version of MFC than the DLL (or vice versa). Since the MFC library is statically linked into each DLL or EXE, there is no question about which version you have.</li>
</ul>
<p class=label>
<b>API Limitations</b></p>
<p>
Some MFC capabilities are not applicable to the DLL version, either because of technical limitations or because those services are usually provided by the application. These limitations are listed below:
<ul type=disc>
<li>
<b>CWinApp::Enable3dControls</b><br><br></li>
<li>
<b>CWinApp::SetDialogBkColor</b> (color is ignored for message boxes)</li>
</ul>
<p class=label>
<b>Building Your DLL</b></p>
<p>
When compiling regular DLLs that statically link to MFC, the symbols "<b>_USRDLL</b>" and "<b>_WINDLL</b>" must be defined. Your DLL code must also be compiled with the following compiler switches:
<ul type=disc>
<li>
/D_WINDLL signifies the compilation is for a DLL<br><br></li>
<li>
/D_USRDLL specifies you are building a regular DLL </li>
</ul>
<p>
When compiling regular DLLs that dynamically link to MFC, you must define the above symbols and use the above compiler switches. Additonally, the symbol "<b>_AFXDLL</b>” must be defined and your DLL code must be compiled with:
<ul type=disc>
<li>
/D_AFXDLL specifies that you are building a regular DLL that dynamically links to MFC</li>
</ul>
<p>
The interfaces (APIs) between the application and the DLL must be explicitly exported. It is recommended that you define your interfaces to be low bandwidth, sticking to C interfaces where possible. More direct C interfaces are easier to maintain than more complex C++ classes.</p>
<p>
Place your APIs in a separate header that can be included by both C and C++ files (that way you won't limit your DLL customers to C++ programmers). See the header TRACEAPI.H in the MFC Advanced Concepts sample <object id=alink_1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="DefaultTopic" value="_topic_not_found.htm">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="_sample_mfc_DLLTRACE">
</object><a href=JavaScript:alink_1.Click()>DLLTRACE</a> for an example. To export your functions, enter them in the <b>EXPORTS</b> section of your module definition file (.DEF) or include <b>__declspec(dllexport)</b> on your function definitions. Use <b>__declspec(dllimport)</b> to import these functions into the client executable.</p>
<p>
You must add the <b>AFX_MANAGE_STATE</b> macro at the begining of all the exported functions in regular DLLs that dynamically link to MFC to set the current module state to the one for the DLL. This is done by adding the following line of code to the beginning of functions exported from the DLL:</p>
<p>
<code>&nbsp;&nbsp;</code></p>
<p>
<code>AFX_MANAGE_STATE(AfxGetStaticModuleState( ))</code></p>
<p>
<code>&nbsp;&nbsp;</code></p>
<p class=label>
<b>WinMain -&gt; DllMain</b></p>
<p>
The MFC library defines the standard Win32 <b>DllMain</b> entry point that initializes your <b>CWinApp</b> derived object as in a normal MFC application. Place all DLL-specific initialization in the <b>InitInstance</b> member function as in a normal MFC application.</p>
<p>
Note that the <b>CWinApp::Run</b> mechanism doesn't apply to a DLL, since the application owns the main message pump. If your DLL brings up modeless dialogs or has a main frame window of its own, your application's main message pump must call a DLL-exported routine that calls <b>CWinApp::PreTranslateMessage</b>.</p>
<p>
See the DLLTRACE sample for use of this function.</p>
<p>
The <b>ExitInstance</b> member function of your CWinApp derived class will be called from the MFC provided <b>DllMain</b> function before the DLL is unloaded.</p>
<p class=label>
<b>What to Do to Link It All Together</b></p>
<p>
With regular DLLs that statically link to MFC, you must link your DLL with this library (NAFXCWD.LIB or NAFXCW.LIB) along with the version of the C runtimes called 'LIBCMT.LIB'. These libraries are pre-built and may be installed by specifying them when you run Visual C++ setup.</p>
<p class=label>
<b>Sample Code</b></p>
<p>
Please see the MFC Advanced Concepts sample program <object id=alink_2 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="DefaultTopic" value="_topic_not_found.htm">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="_sample_mfc_DLLTRACE">
</object><a href=JavaScript:alink_2.Click()>DLLTRACE</a> for a complete sample. This includes a simple DLL called 'TRACER.DLL' that implements the AFX Trace flags dialog (see <a href="_mfcnotes_tn007.htm">Technical Note 7</a>). It also has a simple HELLO application that calls the DLL to use the dialog.</p>
<p>
Several interesting thing to note:
<ul type=disc>
<li>
The compiler flags of the DLL and the application are very different.<br><br></li>
<li>
The link lines and .DEF files for the DLL and the application are also very different.<br><br></li>
<li>
The application using the DLL doesn't even have to be in C++.<br><br></li>
<li>
The interface between the application and the DLL is a "C"-like API and are exported with TRACER.DEF.</li>
</ul>
<p>
The following extract from TRACEAPI.H illustrates what is needed for one API that is defined in a regular DLL that statically links to MFC:</p>
<pre><code>#ifdef __cplusplus
extern "C" {
#endif&nbsp; /* __cplusplus */

struct TracerData
{
 &nbsp;&nbsp; BOOL&nbsp;&nbsp;&nbsp; bEnabled;
 &nbsp;&nbsp; UINT&nbsp;&nbsp;&nbsp; flags;
};

BOOL FAR PASCAL EXPORT PromptTraceFlags(TracerData FAR* lpData);

#ifdef __cplusplus
}
#endif
</code></pre>
<p>
In this example, the declaration is enclosed in an 'extern "C" { }' block for C++ users. This has several advantages. First, it makes your DLL APIs usable by non-C++ client applications. Second, it reduces DLL overhead since C++ name mangling will not be applied to the exported name. Lastly, it makes it easier to explicitly add to a .DEF file (for exporting by ordinal) without having to worry about name mangling.</p>
<p>
All API functions are "<b>FAR PASCAL EXPORT</b>". Although not stricly necessary for Win32 DLLs, these definitions have been kept for easy back-porting to 16-bit Windows. The <b>FAR</b>, <b>PASCAL</b>, and <b>EXPORT</b> macros all expand to nothing under Win32.</p>
<p>
The structures used by the API are not derived from MFC classes and are defined completely in the API header. This reduces the complexity of the interface between the DLL and the application and, once again, makes the DLL usable by C programs as well.</p>
<p>
Any data pointers used in the API are explicit <b>FAR</b> pointers. Again, <b>FAR</b>, is not really necessary for Win32, but is useful if you plan to compile the code for 16-bit Windows sometime in the future.</p>
<p>
<a href="_mfcnotes_technical_notes_by_number.htm">Technical Notes by Number</a>  |&nbsp; <a href="_mfcnotes_technical_notes_by_category.htm">Technical Notes by Category</a></p>
</font></BODY>
</HTML>
