<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>TN019: Updating existing MFC Applications to MFC 3.0</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY>
<font face="verdana,arial,helvetica" size="2">
<h1><a name="_mfcnotes_tn019"></a><sup></sup>TN019: Updating existing MFC Applications to MFC 3.0</h1>
<p>
This technical note primarily provides guidelines for migrating MFC 1.0 applications to the MFC 2.0 tools. Additional differences between MFC 2.0, 2.5, and 3.0 are presented in the first section, below.</p>
<p class=label>
<b>MFC 4.0/3.0 API Changes</b></p>
<p>
There are no known changes to the documented MFC APIs that would cause existing code to require changes. There are, of course, many additional features you may want to take advantage of. For more information on these features, see <i>Visual C++ Programmer's Guide</i>.</p>
<p class=label>
<b>MFC 2.5 API Changes</b></p>
<p>
MFC 2.5 added two major features to the class library: OLE 2.0 support, which replaced the OLE 1.0 support and ODBC support which provides database access. It is the intention of this technote to cover the API changes that may affect your existing code. For information about these new features, not covered in this technote, see <i>Visual C++ Programmer's Guide</i>.</p>
<p>
<b>CFrameWnd::RecalcLayout</b> has an additional parameter, BOOL bNotify. This specifies whether or not to notify any OLE servers that they layout has changed. It is normally TRUE and therefore that is the default. This function is virtual, so if your program provides an override of this function you will need to add the extra parameter to your function as well.</p>
<p>
There were other changes made to undocumented functions in the MFC 2.5 libraries to support OLE 2.0 as well as ODBC. If your program uses undocumented MFC APIs, you should review all such uses to make sure they are still valid.</p>
<p class=label>
<b>Migrating MFC 1.0 Applications to MFC 2.0</b></p>
<p>
IMPORTANT: To understand and evaluate the two approaches presented below, you must be familiar with MFC 2.0 concepts, such as the Document and View architecture, and the tools. We suggest you at least work through the MFC Tutorial sample <object id=alink_1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="DefaultTopic" value="_topic_not_found.htm">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="_sample_mfc_SCRIBBLE">
</object><a href=JavaScript:alink_1.Click()>SCRIBBLE</a> in <i>Tutorials</i> before beginning any migration of existing code.</p>
<p>
There are two basic approaches to migrating existing applications from MFC version 1, released with Microsoft C7, to MFC version 2.</p>
<p class=label>
<b>Minimal Migration</b></p>
<p>
Using the "Minimal Migration" method, you make only the minimum changes required, so that:
<ul type=disc>
<li>
Your existing MFC 1.0 application compiles and links successfully with the MFC 2.0 libraries.<br><br></li>
<li>
Your resources can be successfully edited using Visual C++.<br><br></li>
<li>
Your message handler functions and dialog data are recognized by ClassWizard.</li>
</ul>
<p>
This is the easiest approach, but it does not take full advantage of the rich features in the MFC 2.0 library. Even if you chose the "Full Migration" method, you will need to understand and exercise techniques for minimal migration.</p>
<p class=label>
<b>Full Migration</b></p>
<p>
If you perform a "Full Migration", you can take full advantage of the MFC 2.0 library. Using the minimal migration method, you will be able to edit your application using Visual C++ and ClassWizard. By using the full migration method, you gain the following MFC 2.0 support:
<ul type=disc>
<li>
Standard File menu and dialog user interfaces. You get features such as standard file open and save dialogs, file manager, drag-and-drop, most-recently-used File menu interface, and so on.<br><br></li>
<li>
Printing. You supply the view code; the library takes care of getting the printer DC, putting up the abort dialog, running the print loop, and so on.<br><br></li>
<li>
Print Preview. Usually, you will have to do no extra coding to have Print Preview functionality in your application.<br><br></li>
<li>
Toolbars and status bars. They are now easy to add to your application using Visual C++ and MFC 2.0.<br><br></li>
<li>
Splitter windows. If you structure your display code into view classes, then you'll be able to display them in splitter windows at very little additional cost.<br><br></li>
<li>
OLE2 support. By utilizing the "Document/View" architecture your application can probably be OLE enabled without a significant amount of work.</li>
</ul>
<p>
The overall full migration method is basically to emulate developing an MFC 2.0 application from scratch, starting with AppWizard. The difference from developing an MFC 2.0 application from scratch, of course, is that you will borrow as much of the MFC 1.0 code you wrote as makes sense.</p>
<p class=label>
<b>Minimal Migration</b></p>
<p>
The following subsections present detailed guidelines for performing a minimal migration. </p>
<p class=label>
<b>Conforming to Windows 3.1 STRICT typedefs</b></p>
<p>
The default builds of the MFC 2.0 library adhere to the Windows 3.1 <b>STRICT</b> typedefs which are explained in the Windows 3.1 SDK. MFC 1.0 had <b>STRICT</b> turned off, but now MFC 2.0 has <b>STRICT</b> turned on by default. This follows MFC's commitment to track the industry standard Windows API and to foster development practices that make developing robust applications easier. Just as the <b>STRICT</b> typedefs were helpful to the developers of the MFC 2.0 classes to produce robust software, so will that be true for you in developing your application code.</p>
<p>
When using <b>STRICT</b> type checking for the first time, many compilation errors will typically result. Modifying your MFC 1.0 application to conform to Windows 3.1 <b>STRICT</b> typedefs may very well represent the bulk of your minimal migration effort.</p>
<p>
Once your application complies with <b>STRICT</b>, you may be able to compile an executable with no further changes. For example, the ABOUT2 and FILEVIEW MFC 1.0 samples compile with no additional changes. They were already <b>STRICT</b> compliant and did not used any changed MFC APIs.</p>
<p class=label>
<b>MFC 2.0 API Changes</b></p>
<p>
Beyond conforming to <b>STRICT</b>, most of the effort of doing a minimal migration is to identify and change your application code to conform to the relatively few MFC 2.0 API changes.</p>
<p>
Out of over 1800 MFC 1.0 APIs, only 20 of the APIs that were changed result in compile-time errors. These changes require only trivial modifications to existing MFC 1.0 applications. The most extensive changes are the architectural restructuring of the OLE classes. These changes are covered in <a href="_mfcnotes_tn018.htm">Technical Note 18</a>.</p>
<p>
To anticipate which changes you'll need to make, see the section "Alphabetical API Changes" at the end of this technote. It provides a useful, brief summary of which MFC 1.0 APIs were modified in MFC 2.0.</p>
<p>
If you do not make all the changes necessary to deal with MFC 2.0 code, you will get various compilation and linking errors. These errors are almost always easy to diagnose. To aid your diagnosis, we provide some guidelines in the section "Compiler Errors" at the end of this technote.</p>
<p>
The following MFC APIs have been removed in MFC 2.0. We recommend alternative APIs where appropriate. This list does not include changes to undocumented implementation APIs.</p>
<p class=dt>
<b>CDC::GetDCOrg</b></p>
<p class=indent>
<b>GetDCOrg</b> is not available in Win32. For Windows 3.x only applications, just call the Windows API <b>::GetDCOrg</b> directly.</p>
<p class=dt>
<b>CRuntimeClass::m_pszClassName</b></p>
<p class=indent>
This member variable is now an <b>LPSTR</b> rather than the memory model-dependent (char*). It is named <b>m_lpszClassName</b> in MFC 2.0.</p>
<p class=dt>
<b>CMDIChildWnd::m_pMDIFrameWnd</b></p>
<p class=indent>
In MFC 1.0, this member variable pointed to the class's MDIFrame parent. This member variable has been replaced with a member function <b>CMDIChildWnd::GetMDIFrame</b>. If you are using multiple document interface (MDI) in MFC 2.0, most uses <b>CMDIChildWnd::m_pMDIFrameWnd</b> (or <b>GetMDIFrame</b>) are no longer necessary since the default MDI support handles all of the standard MDI Windows menu commands.</p>
<p class=dt>
<b>CFrameWnd::GetChildFrame</b></p>
<p class=indent>
Use <b>CMDIFrameWnd::MDIGetActive</b> for MDI frames instead.</p>
<p>
The following API has been left in MFC 2.0 to support 1 compatibility but is obsolete. It will be removed from future versions of MFC.</p>
<p class=dt>
<b>CMDIFrameWnd::CreateClient</b></p>
<p class=indent>
This functionality has been replaced by the more general <b>OnCreateClient</b> mechanism that supports view creation and the improved MFC 2.0 MDI support. The original <b>CreateClient</b> can still be used for MDI applications that manage their own MDI frame window's menu bar (by using <b>CMDIFrame::MDISetMenu</b>). The MFC 2.0 MDI support will automatically switch the MDI frame window's menu bar to the menu for the currently active MDI child window.</p>
<p class=label>
<b>Other API-related Changes</b></p>
<p>
Two MFC classes have been moved from the afxwin.h to the afxext.h header file:
<ul type=disc>
<li>
CBitmapButton<br><br></li>
<li>
CMetaFileDC</li>
</ul>
<p>
In your .cpp files that reference these classes add the following:</p>
<pre><code>#include &lt;afxext.h&gt;
</code></pre>
<p>
Many APIs have been changed so that they are stricter about the use of the 'const' modifier. These changes result in a more consistent use of the LPCSTR type name and the new LPCRECT type name. Note, there is no compile time issue with these changes, since any type can be promoted to a const version of that type when used as an argument. Like the <b>STRICT</b> change, this leads to more robust code when your code uses const data pointers.</p>
<p>
The window <b>Create</b> functions listed below now have an additional parameter, but since the last parameter has a default value of NULL, existing code will work without modification. These functions are
<ul type=disc>
<li>
<b>CWnd::Create</b><br><br></li>
<li>
<b>CFrameWnd::Create</b><br><br></li>
<li>
<b>CMDIFrameWnd::Create</b><br><br></li>
<li>
<b>CMDIChildWnd::Create</b></li>
</ul>
<p>
The following functions were virtual in MFC 1.0 but are now nonvirtual in MFC 2.0:
<ul type=disc>
<li>
<b>CFile::GetStatus</b><br><br></li>
<li>
<b>CFrameWnd::GetParentFrame</b></li>
</ul>
<p>
If a derived class of your MFC 1.0 application overrides either of these functions, it is unlikely that the function in your derived class will be called in MFC 2.0. In addition, <b>GetParentFrame</b> was moved from <b>CFrameWnd</b> to <b>CWnd</b> to be a more generally useful API.</p>
<p>
All static members of classes, as well as global operator/friend functions, now adhere to <b>PASCAL</b> calling conventions. All global functions are <b>AFXAPI</b> (<b>PASCAL</b>). Again, this is not a compile time issue but leads to faster and smaller generated code.</p>
<p>
Many of the implementation-only classes and structures have been renamed to not use the 'C' prefix. For example, <b>CExceptionContext</b> has been renamed to <b>AFX_EXCEPTION_CONTEXT</b>. These classes are not documented and remain implementation details of the class library. It is unlikely that you have relied on these, and it is generally recommended that you do not rely on undocumented APIs of the class library since they are subject to change in future versions.</p>
<p class=label>
<b>MFC 2.0 Default Behavior Changes</b></p>
<p>
Dealing with MFC API changes is easy with the aid of errors reported by the compiler and linker. Not all library changes are revealed in the library header files, however. Some changes are revealed in run-time behavior of your application. These changes are generally not difficult to deal with, as long as you anticipate them. The following information is provided to help you anticipate such behavioral changes.</p>
<p>
<b>CDialog</b> and <b>CModalDialog</b> have been merged into a single class. <b>CModalDialog</b> is now considered to be an obsolete class. However, for MFC 1.0 compatibility, all references to <b>CModalDialog</b> are still valid through a migration macro in afxwin.h:</p>
<pre><code>#define CModalDialog CDialog
</code></pre>
<p>
For many MFC 1.0 applications, this simple #define is sufficient. However, there are cases where this #define is not sufficient.</p>
<p>
If you implemented a modeless dialog and relied on the default "do nothing" behavior for <b>OnOK</b> and <b>OnCancel</b>, then you must override these and the default behavior, since they now call <b>EndDialog</b> (for modal dialog processing).</p>
<p>
<b>CDialog::CreateIndirect</b> still creates a modeless dialog. To create a modal dialog use <b>CDialog::InitModalIndirect</b> instead of the removed <b>CModalDialog::CreateIndirect</b> API.</p>
<p>
Dialog box and message box background colors can now be globally set using the <b>CWinApp::SetDialogBkColor</b> API. The default parameter sets the color to light gray (not <b>COLOR_BTNFACE</b>) to produce gray backgrounds. You may specify other colors.</p>
<p>
If <b>SetDialogBkColor</b> is not called in your <b>CWinApp</b>-derived <b>InitInstance</b> function, the default Window Background color (set in the Control Panel Color applet) is used.</p>
<p>
In MFC 1.0, if a DLL contained a <b>CWinApp</b> object, it was necessary to provide a <b>DllMain</b> that included a call to <b>AfxWinTerm</b>. MFC 2.0 provides this <b>DllMain</b>, so any additional code included in the your <b>DllMain</b> should be migrated to the DLL's C<b>WinApp::ExitInstance</b> member function. </p>
<p>
<b>CMDIChildWnd::Create</b> now correctly uses the <b>dwStyle</b> parameter. You must now specify a complete window style for the MDI child window. If you specify <b>dwStyle</b> = 0, you will now get an <b>ASSERT</b> failure in <b>CMDIChildWnd::PreCreateWindow</b>. To avoid this, you should specify the style WS_CHILD | WS_VISIBLE | WS_OVERLAPPEDWINDOW to be backward compatible with MFC 1.0.</p>
<p>
MFC 2.0 supports setting different styles for MDI child windows, so you can remove some of the frame window controls, if desired.</p>
<p>
Class <b>CFrameWnd</b> has a new data member, BOOL <b>CFrameWnd::m_bAutoMenuEnable</b>. It is set to TRUE by default. This causes menu items that don't have <b>ON_UPDATE_COMMAND_UI</b> or <b>ON_COMMAND</b> handlers to be automatically disabled. Menu items that have <b>ON_COMMAND</b> handlers, but no <b>ON_UPDATE_COMMAND_UI</b> handlers, will be automatically enabled.</p>
<p>
This makes it easy to implement optional commands based on the current selection. Also, this greatly reduces the need for applications to write <b>ON_UPDATE_COMMAND_UI</b> handlers for enable/disable of menu items. For instance, an AppWizard-generated application will have Edit Cut/Copy/Paste disabled until the programmer implements handlers for them.</p>
<p>
However, if your MFC 1.0 application is not updated to use <b>ON_COMMAND</b> and <b>ON_UPDATE_COMMAND_UI</b> handlers, then it must clear <b>m_bAutoMenuEnable</b> explicitly. Otherwise, menus that you disable will be re-enabled automatically.</p>
<p class=label>
<b>Project (Build) Changes</b></p>
<p>
You can continue to build your MFC 1.0 application using a standard makefile. By far the easiest way to migrate your project is to use the Visual C++ project facility to maintain your depedencies and other project options within the Visual C++ environment.</p>
<p>
A common link error is unresolved externals to COMDLG32.DLL and SHELL32.DLL APIs. Be sure to link with COMDLG32.LIB and SHELL32.LIB.</p>
<p>
You may be able to improve build times by placing #include &lt;afxwin.h&gt; in a precompiled header. By convention, MFC 2.0 applications specify "stdafx.h" as the precompiled header. Then module stdafx.cpp includes stdafx.h. This technique is illustrated by the code created by AppWizard, and by many of the MFC 2.0 samples.</p>
<p class=indent>
<b>Note</b>&nbsp;&nbsp;&nbsp;It is important that you neither define nor undefine any of the _AFX_NO_XXX macros in stdafx.h. See the Knowledge Base article "PRB: Problems Occur When Defining _AFX_NO_XXX." You can find Knowledge Base articles on the MSDN Library CD, or at http://www.microsoft.com/kb/.</p>
<p class=label>
<b>Visual C++ and ClassWizard Compatibility</b></p>
<p>
Even for minimal migration, we recommend that you follow the steps below so that you can use Visual C++ and ClassWizard to edit your application resources and code.
<ul type=disc>
<li>
For any module whose message map you want to edit with ClassWizard, add the following two comment lines in your .cpp file outside of any function implementations:<pre><code>//{{AFX_MSG_MAP(&lt;class name&gt;)
//}}AFX_MSG_MAP
</code></pre>
<p class=tl>
&lt;class name&gt; is the name of your class containing the message map.</P><p class=tl>
Similarly, add the following two comment lines inside of the corresponding class declaration in your .h file:</P><pre><code>//{{AFX_MSG(&lt;class name&gt;)
//}}AFX_MSG
</code></pre>
<p class=tl>
For an example of these declarations, look at the same comment lines in any application created by AppWizard. For an explanation of what these comment lines mean, see <object id=alink_2 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="DefaultTopic" value="_topic_not_found.htm">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="_core_MFC.3a_.Using_the_MFC_Source_Files">
</object><a href=JavaScript:alink_2.Click()>MFC: Using the MFC Source Files</a> in <i>Visual C++ Programmer's Guide</i>.</P></li>
<li>
Your project must have a makefile named &lt;project&gt;.mak and a resource file named &lt;project&gt;.rc, where &lt;project&gt; is the name of your project. Both of these files must be located in the project's root directory. The .MAK file may be an external makefile.<br><br></li>
<li>
Run ClassWizard from within Visual C++. When ClassWizard discovers that a .CLW file does not exist, it asks you if you want to create one. Respond 'yes'. The .CLW file is essentially an index file that ClassWizard uses to identify modules that have such //{{AFX_MSG comment lines.<br><br></li>
<li>
For any module whose virtual functions you want to edit with ClassWizard, add the following two comment lines inside your class declaration in your .h file:<pre><code>//{{AFX_VIRTUAL(&lt;class name&gt;)
//}}AFX_VIRTUAL
</code></pre>
</li>
</ul>
<p class=label>
<b>Full Migration</b></p>
<p>
A full migration of your existing C or MFC 1.0 application to MFC 2.0 will offer you all the advantages of MFC 2.0. For most applications, a full migration is not difficult and is well worth the effort.</p>
<p>
A successful full migration of an application to MFC 2.0 requires essentially the same understanding of MFC 2.0 as developing a new application from scratch. You should become familiar with the MFC 2.0 Class Library, Visual C++, AppWizard, and ClassWizard before you begin the full migration. You should understand what portions of your application code can be removed by deriving equivalent or improved functionality from the MFC 2.0 classes. Not only will using more of the library implementation make your source code smaller, but it will make these parts of your application better integrated with the rest of the MFC framework.</p>
<p>
By fully migrating your application to MFC 2.0, you will be able to derive additional functionality from MFC at relatively little extra cost. For example, if your application did not have a splitter window user interface, but one would be useful to your users, then you will be able to quickly add this feature, having already ported your code to MFC 2.0's document/view architecture.</p>
<p>
Although a full migration to MFC 2.0 may require a couple days effort for large applications, the process itself is fairly straightforward. The following general steps describe the process:
<ol>
<li>
Analyze how your existing application architecture factors into document, views, and frame windows.<p class=tl>
Do this before you start editing any code. Many programmers tend to intertwine document code with view code. Although doing so is not necessarily "bad," separation of document and view functionality is a design philosophy that the MFC framework endorses and supports particularly well. Even though MFC 1.0 did not have <b>CDocument</b> and <b>CView</b> classes, it also endorsed document/view separation. So will all future versions of the library.</P><p class=tl>
Study the MFC 2.0 samples that use the <b>CDocument</b> and <b>CView</b> classes, particularly the MFC Tutorial Sample <object id=alink_3 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="DefaultTopic" value="_topic_not_found.htm">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="_sample_mfc_SCRIBBLE">
</object><a href=JavaScript:alink_3.Click()>SCRIBBLE</a>. Then analyze your application to determine what the document is and what the view is. Determine whether your application has multiple document types or views.</P><p class=tl>
Even if your application does not lend itself to clear document/view separation, you will still be able to fully migrate to MFC 2.0 and take essentially complete advantage of the framework. You can "fake" document/view separation by implementing <b>CDocument</b>- and <b>CView</b>-derived classes, but your document or view class may delegate most of its work to the other class. Or, your view class might rely on your <b>CFrameWnd</b>- or <b>CMDIChildWnd</b>-derived class to implement the bulk of your application's user interface. In summary, you have almost complete freedom as to how to separate your document, view, and frame window classes.</P><p class=tl>
Your analysis also should determine whether your application needs multiple view classes and possibly multiple document classes. Even relatively simple applications sometimes need more than one view class. However, multiple views, such as in a splitter window, don't necessarily dictate that you have multiple <b>CView</b>-derived classes. For example, if each pane in the splitter window provides the same user interface as other panes in the splitter window, then they can share the same view class. In that case, each pane is simply a distinct object of the same view class. You'll probably want to design multiple view classes, if your application provides very distinct user interfaces in different windows.</P></li>
<li>
Analyze what AppWizard-supported framework features your application will need.<p class=tl>
AppWizard will create a skeleton MFC 2.0 application that supports various framework features that you select as options in AppWizard dialogs. Before you run AppWizard to create your skeleton application, you should first become familiar with the options AppWizard provides.</P><p class=tl>
Then, take a little time to decide which of AppWizard's options you'll want to select. Don't attempt to do this in a few minutes the first time you run AppWizard. For example, if your application does not already support OLE, this is a major decision that you'll want to consider. If you didn't chose AppWizard's OLE option to begin with, you'll still be able to modify your application code to use MFC's OLE features. But starting with the OLE option in AppWizard to begin with will save you time.</P><p class=tl>
Your analysis should determine whether your application is a single document interface (SDI) or multiple document interface (MDI) application. This particular determination should be obvious if you're familiar with these two distinct user interfaces in other Windows applications. AppWizard will create MDI applications by default since the MDI user interface is usually more functional to end users for it lets them open more than one document/file at a time. Fortunately, with the MFC 2.0 document/view architecture, supporting MDI requires no extra coding on your part.</P></li>
<li>
Generate a new application using AppWizard.<p class=tl>
Having done the above analysis, you're now ready to run AppWizard to create the skeleton code for your application.</P><p class=tl>
Having analyzed how your application separates into document, views, and frame windows, you should have a good idea what names to give to their corresponding classes and modules. You might want to assign somewhat generic names, such as the tutorial sample's CScribDoc and CScribView, and scribdoc.cpp and scribvw.cpp. However, if your application requires multiple view classes, you'll probably want to give the first AppWizard-created view class a more specialized name, such as CDataEntryView and CReportView. See the next step for additional information on creating multiple document and view classes.</P><p class=tl>
Having anticipated what additional AppWizard options you want, such as SDI or MDI, and OLE, you should now be able to select the AppWizard options and create the skeleton application in just a few minutes.</P></li>
<li>
Optionally, clone second view, document, and frame window classes.<p class=tl>
If your above analysis determines that your application should have multiple view, document, or frame window classes, then it's a good time to create the skeleton code for these classes right after you run AppWizard.</P><p class=tl>
You can create the skeleton code for your additional view, document, and frame window classes by cloning the ones created by AppWizard. That is, copy the .cpp and .h files, assigning a new module name for the second document or class. Then edit the skeleton code by changing class names. Another alternative is to use the ClassWizard's Add Class functionality to create a new class automatically in the files you specify using the names you specify. You will already be familiar with the ClassWizard's ability to create new classes if you have followed the SCRIBBLE tutorial.</P><p class=tl>
In either case, in your <b>CWinApp</b>-derived class's <b>InitInstance</b> function, you must register additional document template objects for any associations that you want to make between you multiple document, view, and frame window classes.</P><p class=tl>
This is also a quick step. You can postpone this step if you're not committed to implementing multiple documents, views, or frame window classes in your application.</P></li>
<li>
Migrate the relevant portions of your MFC 1.0 code into the classes created by AppWizard.<p class=tl>
This step represents the bulk of the work in migrating your MFC 1.0 application to MFC 2.0. You should do this incrementally. Migrate relatively small chunks of your application at a time. As you do this, you'll learn more details about what functionality the framework provides that will allow you to discard some of your old MFC 1.0 application code.</P><p class=tl>
As you migrate these chunks of code, keep in mind the guidelines presented under "Minimal Migration". Many of those guidelines apply to full migration. AppWizard will have already added the //{{AFX_MSG and //{{AFX_MSG_MAP comments to your command target classes (application, document, view, and frame window). It is not necessary for you manually add these as under the minimal migration approach. Although it is not required, we recommend that you move message-handling functions between the //{{AFX_MSG comments nested in the message maps. Also, move the declarations of these message-handling (<b>afx_msg</b>) functions between the //{{AFX_MSG comments in your header files. Doing so will allow you to use ClassWizard throughout the rest of your project's life cycle(s).</P><p class=tl>
These recommendations regarding //{{AFX_MSG comments also apply, perhaps to a lesser degree, to dialogs. If you don't anticipate many future changes to a given dialog class, then it might not be worth your effort to make that dialog ClassWizard-aware. That's fine. We recommend, of course, that you create all new dialog classes using ClassWizard's Add Class option.</P><p class=tl>
As you migrate an MFC 1.0 or Windows application, you may want to maintain compatibility with existing file formats. (The default MFC 2.0 document serialization mechanism may not be appropriate for your application.) To do direct <b>CFile</b> write and read calls, or to implement a non-file based document, you will want to override <b>CDocument::OnOpenDocument</b> and <b>OnSaveDocument</b>. The MFC General sample <object id=alink_4 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="DefaultTopic" value="_topic_not_found.htm">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="_sample_mfc_DIBLOOK">
</object><a href=JavaScript:alink_4.Click()>DIBLOOK</a> provides an example of this technique. If your current application already serializes objects, then this will not be an issue.</P></li>
</ol>
<p class=label>
<b>Alphabetical API Changes</b></p>
<p>
To understand the reasons for these changes, please refer to "Reason for Changes" below.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=44%><b>API / Variable</b></td>
<td class=label width=56%><b>MFC 2.0 Change (Reason for Change)</b></td>
</tr>
<tr valign=top>
<td width=44%><b>CMetaFileDC::Close</b></td>
<td width=56%>Return type (2)</td>
</tr>
<tr valign=top>
<td width=44%><b>CWnd::Create</b></td>
<td width=56%>Extra default param added, <b>CWnd* const</b> (1, 3)</td>
</tr>
<tr valign=top>
<td width=44%><b>CFrameWnd::Create</b></td>
<td width=56%>Extra default param added, <b>CWnd* const</b> (1, 3)</td>
</tr>
<tr valign=top>
<td width=44%><b>CMDIChildWnd::Create</b></td>
<td width=56%>Extra default param added, <b>CWnd* const</b> (1, 3)&nbsp; <i>dwStyle</i> default is now: WS_CHILD | WS_VISIBLE | WS_OVERLAPPEDWINDOW</td>
</tr>
<tr valign=top>
<td width=44%><b>CWnd::CreateEx</b></td>
<td width=56%>Extra default param added, <b>CWnd* const</b> (1, 3)</td>
</tr>
<tr valign=top>
<td width=44%><b>CBitmap::CreateBitmap</b></td>
<td width=56%>Parameter types (4)</td>
</tr>
<tr valign=top>
<td width=44%><b>CDC::EnumObjects</b></td>
<td width=56%>Callback prototype (2)</td>
</tr>
<tr valign=top>
<td width=44%><b>CTime::Format</b></td>
<td width=56%>Const function (3)</td>
</tr>
<tr valign=top>
<td width=44%><b>CTimeSpan::Format</b></td>
<td width=56%>Const function (3)</td>
</tr>
<tr valign=top>
<td width=44%><b>CTime::FormatGmt</b></td>
<td width=56%>Const function (3)</td>
</tr>
<tr valign=top>
<td width=44%><b>CFile::GetStatus</b></td>
<td width=56%>Nonvirtual (5)</td>
</tr>
<tr valign=top>
<td width=44%><b>CDC::GrayString</b></td>
<td width=56%>Callback prototype and parameter type (2)</td>
</tr>
<tr valign=top>
<td width=44%><b>CBitmapButton::LoadBitmaps</b></td>
<td width=56%>Extra default parameter (1)</td>
</tr>
<tr valign=top>
<td width=44%><b>CWnd::OnActivateApp</b></td>
<td width=56%>Parameter type (2)</td>
</tr>
<tr valign=top>
<td width=44%><b>CWnd::OnCompareItem</b></td>
<td width=56%>Extra parameter (6)</td>
</tr>
<tr valign=top>
<td width=44%><b>CWnd::OnDeleteItem</b></td>
<td width=56%>Extra parameter (6)</td>
</tr>
<tr valign=top>
<td width=44%><b>CWnd::OnDrawItem</b></td>
<td width=56%>Extra parameter (6)</td>
</tr>
<tr valign=top>
<td width=44%><b>CWnd::OnDropFiles</b></td>
<td width=56%>Parameter type (2)</td>
</tr>
<tr valign=top>
<td width=44%><b>CWnd::OnGetMinMaxInfo</b></td>
<td width=56%>Parameter type (6)</td>
</tr>
<tr valign=top>
<td width=44%><b>CWnd::OnMeasureItem</b></td>
<td width=56%>Extra parameter (6)</td>
</tr>
<tr valign=top>
<td width=44%><b>CWnd::OnMenuChar</b></td>
<td width=56%>Return type (2)</td>
</tr>
<tr valign=top>
<td width=44%><b>CWnd::OnNcCalcSize</b></td>
<td width=56%>Extra parameter (6)</td>
</tr>
<tr valign=top>
<td width=44%><b>CWnd::OnPaintClipboard</b></td>
<td width=56%>Parameter type (2)</td>
</tr>
<tr valign=top>
<td width=44%><b>CWnd::OnParentNotify</b></td>
<td width=56%>Parameter type (2)</td>
</tr>
<tr valign=top>
<td width=44%><b>CWnd::OnSizeClipboard</b></td>
<td width=56%>Parameter type (2)</td>
</tr>
<tr valign=top>
<td width=44%><b>CWnd::OnSysCommand</b></td>
<td width=56%>Parameter type (2)</td>
</tr>
<tr valign=top>
<td width=44%><b>CWnd::OnWinIniChange</b></td>
<td width=56%>Parameter type (2)</td>
</tr>
<tr valign=top>
<td width=44%><b>CDC::PlayMetaFile</b></td>
<td width=56%>Parameter type (2)</td>
</tr>
<tr valign=top>
<td width=44%><b>CEdit::SetSel</b></td>
<td width=56%>Extra default parameter (6)</td>
</tr>
<tr valign=top>
<td width=44%><b>CEdit::SetTabStops</b></td>
<td width=56%>Parameter type (5)</td>
</tr>
<tr valign=top>
<td width=44%><b>CWnd::SetTimer</b></td>
<td width=56%>Callback prototype and parameter type (2)</td>
</tr>
<tr valign=top>
<td width=44%><b>CRuntimeClass::m_pszClassName</b></td>
<td width=56%>Renamed <b>m_lpszClassName</b> (5)</td>
</tr>
</table><br>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=44%><b>Deleted or Obsolete API</b></td>
<td class=label width=56%><b>MFC 2.0 Change (Reason for Change)</b></td>
</tr>
<tr valign=top>
<td width=44%><b>CBitmapButton</b></td>
<td width=56%>Removed ctor with 3 params - use <b>LoadBitmaps</b> (1)</td>
</tr>
<tr valign=top>
<td width=44%><b>CMDIFrameWnd::</b> <b>CreateClient</b></td>
<td width=56%>Use <b>OnCreateClient</b> (1)</td>
</tr>
<tr valign=top>
<td width=44%><b>GetChildFrame</b></td>
<td width=56%>Use <b>MDIGetActive</b> (1)</td>
</tr>
<tr valign=top>
<td width=44%><b>GetDCOrg</b></td>
<td width=56%>Use Windows API directly for 3.x (4)</td>
</tr>
<tr valign=top>
<td width=44%> <b>m_pMDIFrameWnd</b></td>
<td width=56%>Now call <b>GetParentFrame</b> OR <b>GetMDIFrame</b> (1)</td>
</tr>
</table><br>
<p>
Reasons for Changes:
<ul type=disc>
<li>
Improved functionality. The MFC 2.0 version of this API provides more or improved functionality over its MFC 1.0 counterpart.<br><br></li>
<li>
<b>STRICT</b> conformance. The MFC 2.0 API was changed to conform with the <b>STRICT</b> Windows API.<br><br></li>
<li>
Const correctness. The MFC 2.0 API was fixed to correctly apply the 'const' keyword to facilitate more robust programs.<br><br></li>
<li>
Win32 portability. The MFC 2.0 API was changed to correctly reflect the Win32 API which facilitates easy porting of MFC applications to Win32.<br><br></li>
<li>
Reduced memory usage. The MFC 2.0 API was changed to provide more efficient linkage and memory usage techniques which will result in smaller applications and reduced <b>DGROUP</b> usage.<br><br></li>
<li>
Win 3.1 functionality. The MFC 2.0 API was changed to correctly reflect a Windows 3.1 API change. The API still remains compatible with Windows 3.0, but optional Windows 3.1 only parameters are now available.</li>
</ul>
<p class=label>
<b>Compiler Errors</b></p>
<p>
Most changes to the MFC 2.0 APIs will generate one of a few compiler errors, or none at all if standard type conversions satisfy the compiler. The following compiler errors may be generated when compiling existing MFC 1.0 applications under MFC 2.0:</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=34%><b>Number</b></td>
<td class=label width=66%><b>Compiler Error Message</b></td>
</tr>
<tr valign=top>
<td width=34%>Compiler error C2039</td>
<td width=66%>'Identifier' : is not a member of ‘class-key.’</td>
</tr>
<tr valign=top>
<td width=34%></td>
<td width=66%>This error is caused when a member function or data member has been removed from a class, for example <b>CFrameWnd</b>'s <b>m_pMDIFrameWnd</b>.</td>
</tr>
<tr valign=top>
<td width=34%>Compiler error C2501</td>
<td width=66%>'Identifier' : missing decl-specifiers.</td>
</tr>
<tr valign=top>
<td width=34%></td>
<td width=66%>This error is caused when you use an unknown class name. This is usually the case when the class no longer exists or has been moved to a different header file. For example if you get this error for <b>CMetaFile</b> and <b>CBitmapButton</b> then you must add #include "afxext.h" to the source files using those classes.</td>
</tr>
<tr valign=top>
<td width=34%>Compiler error C2248</td>
<td width=66%>'Member' cannot access 'specifier' member declared in class 'class.'</td>
</tr>
<tr valign=top>
<td width=34%></td>
<td width=66%>This error occurs if the access of a member has changed from MFC 1.0 to 2. For example, an undocumented API has been moved from <b>public</b> to <b>protected</b> member access. This should only occur in code that is using undocumented and unsupported APIs, which should be changed to use the appropriate MFC 2.0 functionality.</td>
</tr>
<tr valign=top>
<td width=34%>Compiler error C2642</td>
<td width=66%>Cast to pointer to member must be from related pointer to member.</td>
</tr>
<tr valign=top>
<td width=34%></td>
<td width=66%>This error occurs when the message handler function prototype differs from the one in afxwin.h. For example, a line containing the <b>ON_WM_ACTIVATEAPP</b> macro will emit this error if the parameters and return type of your OnActivateApp message handler match the MFC 1.0 declaration.</td>
</tr>
<tr valign=top>
<td width=34%>Compiler error C2660</td>
<td width=66%>'Function' : function does not take 'number' parameters.</td>
</tr>
<tr valign=top>
<td width=34%></td>
<td width=66%>The number of parameters has changed from MFC 1.0 to MFC 2.0. For example, calling the <b>CBitmapButton</b> constructor with three parameters causes this error since this particular constructor has been removed and replaced by the <b>LoadBitmaps</b> member function.</td>
</tr>
<tr valign=top>
<td width=34%>Compiler error C2664</td>
<td width=66%>'Function' : cannot convert parameter 'number' from 'type1' to 'type2.'</td>
</tr>
<tr valign=top>
<td width=34%></td>
<td width=66%>The type of a parameter has changed, and standard conversions do not satisfy the compiler. <b>CDC::EnumObjects</b> is an example of this. In this case, the prototype of the callback function has changed.</td>
</tr>
</table><br>
<p>
<a href="_mfcnotes_technical_notes_by_number.htm">Technical Notes by Number</a>  |&nbsp; <a href="_mfcnotes_technical_notes_by_category.htm">Technical Notes by Category</a></p>
</font></BODY>
</HTML>
