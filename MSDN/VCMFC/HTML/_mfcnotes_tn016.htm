<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>TN016: Using C++ Multiple Inheritance with MFC</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY>
<font face="verdana,arial,helvetica" size="2">
<h1><a name="_mfcnotes_tn016"></a><sup></sup>TN016: Using C++ Multiple Inheritance with MFC</h1>
<p>
This note describes how to use Multiple Inheritance (MI) with the Microsoft Foundation Classes.</p>
<p class=label>
<b>Why Multiple Inheritance?</b></p>
<p>
There is an ongoing debate in the C++ and object-oriented communities over the value of MI. The Visual C++ compiler and development environment fully supports MI.</p>
<p>
The MFC class library has been designed so that you do not need to understand MI to use MFC. MI is not used in any of the MFC classes. We have found that MI is not required to write a class library, nor is it required for writing serious applications. To use MI or not can be a personal decision, so we leave that decision to you.</p>
<p class=label>
<b>So You Want to Use MI?</b></p>
<p>
If you already understand how to use MI, understand the performance trade-offs, and want to use MFC, this technote will tell you what you must do. Some of the restrictions are general C++ restrictions, others are imposed by the MFC architecture.</p>
<p>
The following describes some of the technical issues of how MI affect the use of common MFC idioms. At the end of this technical note a complete MFC application using MI is included which you can extract and compile.</p>
<p class=label>
<b>CRuntimeClass</b></p>
<p>
The persistence and dynamic object creation mechanisms of MFC use the <b>CRuntimeClass</b> data structure to uniquely identify classes. MFC associates one structure of this type with each dynamic and/or serializable class in the application. These structures are initialized at application startup time using a special static object of type <b>AFX_CLASSINIT</b>. You need not concern yourself with the implementation of this information, as it is likely to change between revisions of MFC.</p>
<p>
The current implementation of <b>CRuntimeClass</b> does not support Multiple Inheritance runtime type information. This does not mean you cannot use MI in your MFC application, but if you do, you will have certain responsibilities when working with objects that have more than one base class.</p>
<p>
The <b>CObject::IsKindOf</b> member function will not correctly determine the type of an object if it has multiple base classes. Therefore, you cannot use <b>CObject</b> as a virtual base class, and all calls to <b>CObject</b> member functions such as <b>Serialize</b> and <b>operator new</b> will need to have scope qualifiers so that C++ can disambiguate the appropriate function call. If you do find the need to use MI within MFC, then you should be sure to make the class containing the <b>CObject</b> base class the left-most class in the list of base classes.</p>
<p>
For advice on the uses and abuses of MI, see <i>Advanced C++ Programming Styles and Idioms</i> by James O. Coplien (Addison Wesley, 1992).</p>
<p class=label>
<b>CObject - The Root of all Classes</b></p>
<p>
As you know, all significant classes derive directly or indirectly from class <b>CObject</b>. <b>CObject</b> does not have any member data, but does have some default functionality. When using MI, it will be common to inherit from two or more <b>CObject</b>-derived classes, for example, a <b>CFrameWnd</b> and a <b>CObList</b>:</p>
<pre><code>class CListWnd : public CFrameWnd, public CObList
{
 ...
};
CListWnd myListWnd;
</code></pre>
<p>
In this case <b>CObject</b> is included twice, which leads to two problems:
<ul type=disc>
<li>
Any reference to <b>CObject</b> member functions must be disambiguated.<pre><code>myListWnd.Dump(afxDump);
 &nbsp;&nbsp; // compile time error, CFrameWnd::Dump or CObList::Dump ?
</code></pre>
</li>
<li>
Static member functions, including '<b>operator new</b>' and '<b>operator delete</b>' must also be disambiguated.</li>
</ul>
<p class=label>
<b>Recommended Steps</b></p>
<p>
When creating a new class with two or more <b>CObject</b> derived base classes, reimplement those <b>CObject</b> member that you expect people to use. Operators <b>new</b> and <b>delete</b> are mandatory, <b>Dump</b> is recommended. For example:</p>
<pre><code>class CListWnd : public CFrameWnd, public CObList
{
public:
 &nbsp;&nbsp; void* operator new(size_t nSize)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { return CFrameWnd::operator new(nSize); }
 &nbsp;&nbsp; void operator delete(void* p)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { CFrameWnd::operator delete(p); }

 &nbsp;&nbsp; void Dump(CDumpContent&amp; dc)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { CFrameWnd::Dump(dc);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CObList::Dump(dc); }
 &nbsp;&nbsp;&nbsp; ...
};
</code></pre>
<p class=label>
<b>Virtual Inheritance of CObject ?</b></p>
<p>
You may ask, "If you inherit CObject virtually, won't all of the ambiguity problems go away?".</p>
<p>
Even in the efficient Microsoft Object Model, virtual inheritance is not as efficient as non-virtual inheritance (just as Multiple Inheritance is not as efficient as single inheritance in certain cases). Since there is no member data in <b>CObject</b>, virtual inheritance is not needed to prevent multiple copies of a base class's member data.</p>
<p>
The real answer is no, virtual inheritance will not solve the ambiguity problems illustrated above. For example: the <b>Dump</b> virtual member function is still ambiguous (since <b>CFrameWnd</b> and <b>CObList</b> implement it differently).</p>
<p>
Therefore we recommend following the steps above to provide disambiguation:</p>
<p class=label>
<b>CObject::IsKindOf and Run-time Typing</b></p>
<p>
The runtime typing mechanism supported by MFC in <b>CObject</b> uses the macros <b>DECLARE_DYNAMIC</b>, <b>IMPLEMENT_DYNAMIC, DECLARE_DYNCREATE</b>, <b>IMPLEMENT_DYNCREATE</b>, <b>DECLARE_SERIAL</b> and <b>IMPLEMENT_SERIAL</b>. These give the ability to do a run-time type check to allow for safe cast-downs.</p>
<p>
These macros only support a single base class and will work in a limited way for multiply inherited classes. The base class you specify in <b>IMPLEMENT_DYNAMIC</b> or <b>IMPLEMENT_SERIAL</b> should be the first (or left-most) base class. For example,</p>
<pre><code>class CListWnd : public CFrameWnd, public CObList
{
 &nbsp;&nbsp; DECLARE_DYNAMIC(CListWnd)
 &nbsp;&nbsp; ...
};
IMPLEMENT_DYNAMIC(CListWnd, CFrameWnd)
</code></pre>
<p>
This will allow you to do type checking for the left-most base class only. The run-time type system will know nothing about additional bases (<b>CObList</b> in this case).</p>
<p class=label>
<b>CWnd and Message Maps</b></p>
<p>
In order for the MFC message map system to work correctly, there are two additional requirements:
<ul type=disc>
<li>
There must be only one <b>CWnd</b>-derived base class.<br><br></li>
<li>
The <b>CWnd</b>-derived base class must be the first (or left-most) base class.</li>
</ul>
<p>
In the example above, <b>CFrameWnd</b> is the first base class.</p>
<p>
Some examples that will not work:</p>
<pre><code>class CTwoWindows : public CFrameWnd, public CEdit
 &nbsp;&nbsp; { ... };
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // error : two copies of CWnd

class CListEdit : public CObList, public CEdit
 &nbsp;&nbsp; { ... };
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // error : CEdit (derived from CWnd) must be first
</code></pre>
<p class=label>
<b>A Sample Program using MI</b></p>
<p>
The following sample is a stand-alone application that consists of one class derived from <b>CFrameWnd</b> and <b>CWinApp</b>. This way of structuring an application is not a recommended, but this is an example of the smallest MFC application with one class.</p>
<p>
You can cut the following program and copy it on top of HELLOAPP.CPP in the single-inheritance MFC General sample <object id=alink_1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="DefaultTopic" value="_topic_not_found.htm">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="_sample_mfc_HELLOAPP">
</object><a href=JavaScript:alink_1.Click()>HELLOAPP</a>. Then build the program as you would normally.</p>
<pre><code>#include &lt;afxwin.h&gt;

class CHelloAppAndFrame : public CFrameWnd, public CWinApp
{ 
public:
 &nbsp;&nbsp; CHelloAppAndFrame()
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { }

 &nbsp;&nbsp; // Necessary evil for MI disambiguity
 &nbsp;&nbsp; void* operator new(size_t nSize)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { return CFrameWnd::operator new(nSize); }
 &nbsp;&nbsp; void operator delete(void* p)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { CFrameWnd::operator delete(p); }

// Implementation
 &nbsp;&nbsp; // CWinApp overrides
 &nbsp;&nbsp; virtual BOOL InitInstance();
 &nbsp;&nbsp; // CFrameWnd overrides
 &nbsp;&nbsp; virtual void PostNcDestroy();
 &nbsp;&nbsp; afx_msg void OnPaint();

 &nbsp;&nbsp; DECLARE_MESSAGE_MAP()

};

BEGIN_MESSAGE_MAP(CHelloAppAndFrame, CFrameWnd)
 &nbsp;&nbsp; ON_WM_PAINT()
END_MESSAGE_MAP()

// since the frame window is not allocated on the heap, we must
// override PostNCDestroy not to delete the frame object
void CHelloAppAndFrame::PostNcDestroy()
{
 &nbsp;&nbsp; // do nothing (do not call base class)
}

void CHelloAppAndFrame::OnPaint()
{
 &nbsp;&nbsp; CPaintDC dc(this);
 &nbsp;&nbsp; CRect rect;
 &nbsp;&nbsp; GetClientRect(rect);

 &nbsp;&nbsp; CString s = "Hello, Windows!";
 &nbsp;&nbsp; dc.SetTextAlign(TA_BASELINE | TA_CENTER);
 &nbsp;&nbsp; dc.SetTextColor(::GetSysColor(COLOR_WINDOWTEXT));
 &nbsp;&nbsp; dc.SetBkMode(TRANSPARENT);
 &nbsp;&nbsp; dc.TextOut(rect.right / 2, rect.bottom / 2, s);
}

// Application initialization
BOOL CHelloAppAndFrame::InitInstance()
{
 &nbsp;&nbsp; // first create the main frame
 &nbsp;&nbsp; if (!CFrameWnd::Create(NULL, "Multiple Inheritance Sample",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WS_OVERLAPPEDWINDOW, rectDefault))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return FALSE;

 &nbsp;&nbsp; // the application object is also a frame window
 &nbsp;&nbsp; m_pMainWnd = this;&nbsp;&nbsp;&nbsp;       
 &nbsp;&nbsp; ShowWindow(m_nCmdShow);
 &nbsp;&nbsp; return TRUE;
}

CHelloAppAndFrame theHelloAppAndFrame;
</code></pre>
<p>
<a href="_mfcnotes_technical_notes_by_number.htm">Technical Notes by Number</a>  |&nbsp; <a href="_mfcnotes_technical_notes_by_category.htm">Technical Notes by Category</a></p>
</font></BODY>
</HTML>
