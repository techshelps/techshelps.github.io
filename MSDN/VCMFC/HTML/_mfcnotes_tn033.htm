<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>TN033: DLL Version of MFC</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY>
<font face="verdana,arial,helvetica" size="2">
<h1><a name="_mfcnotes_tn033"></a><sup></sup>TN033: DLL Version of MFC</h1>
<p>
This note describes how you can use the MFCxx.DLL and MFCxxD.DLL (where x is the MFC version number) shared dynamic link libraries with MFC applications and extension DLLs. For more information about regular DLLs, see <a href="_mfcnotes_tn011.htm">Using MFC as Part of a DLL</a>.</p>
<p>
This technical note covers three aspects of DLLs. The last two are for the more advanced users:
<ul type=disc>
<li>
<a href="#_mfcnotes_how_to_write_an_mfc_extension_dll">How you build an MFC Extension DLL</a><br><br></li>
<li>
<a href="#_mfcnotes_writing_an_application_that_uses_the_dll_version">How you build an MFC application that uses the DLL version of MFC</a><br><br></li>
<li>
<a href="#_mfcnotes_how_the_mfc30.dll_is_implemented">How the MFC shared dynamic-link libraries are implemented</a></li>
</ul>
<p>
If you are interested in building a DLL using MFC that can be used with non-MFC applications (this is called a regular DLL), please refer to <a href="_mfcnotes_tn011.htm">Technical Note 11</a>.</p>
<p class=label>
<b>Overview of MFCxx.DLL Support: Terminology and Files</b></p>
<p>
<b>Regular DLL</b>: You use a regular DLL to build a stand-alone DLL using some of the MFC classes. Interfaces across the App/DLL boundary are “C” interfaces, and the client application does not have to be an MFC application.</p>
<p>
This is the version of DLL support supported in MFC 1.0. It is described in <a href="_mfcnotes_tn011.htm">Technical Note 11</a> and the MFC Advanced Concepts sample <object id=alink_1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="DefaultTopic" value="_topic_not_found.htm">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="_sample_mfc_DLLTRACE">
</object><a href=JavaScript:alink_1.Click()>DLLTRACE</a>.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;As of Visual C++ version 4.0, the term <b>USRDLL</b> is obsolete and has been replaced by a regular DLL that statically links to MFC. You may also build a regular DLL that dynamically links to MFC.</p>
<p>
MFC 3.0 (and above) supports regular DLLs with all the new functionality including the OLE and Database classes.</p>
<p>
<b>AFXDLL</b>: This is also referred to as the shared version of the MFC libraries. This is the new DLL support added in MFC 2.0. The MFC library itself is in a number of DLLs (described below) and a client application or DLL dynamically links the DLLs that it requires. Interfaces across the application/DLL boundary are C++/MFC class interfaces. The client application MUST be an MFC application. This supports all MFC 3.0 functionality (excption: UNICODE is not supported for the database classes).</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;As of Visual C++ version 4.0, this type of DLL is referred to as an “Extension DLL.”</p>
<p>
This note will use MFCxx.DLL to refer to the entire MFC DLL set, which includes: 
<ul type=disc>
<li>
Debug: MFCxxD.DLL (core), MFCOxxD.DLL (OLE), MFCDxxD.DLL (database), MFCNxxD.DLL (network), MFCSxxD.LIB (static)<br><br></li>
<li>
Release: MFCxx.DLL (combined), MFCSxx.LIB (static)<br><br></li>
<li>
Unicode Debug: MFCxxUD.DLL (core), MFCOxxUD.DLL (OLE), MFCDxxUD.DLL (database), MFCNxxUD.DLL (network), MFCSxxD.LIB (static)<br><br></li>
<li>
Unicode Release: MFCxxU.DLL (combined), MFCSxxU.LIB (static)</li>
</ul>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;The MFCSxx[U][D].LIB libraries are used in conjunction with the MFC shared DLLs. These libraries contain code that must be statically linked to the application or DLL.</p>
<p>
An application links to the corresponding import libraries:
<ul type=disc>
<li>
Debug: MFCxxD.LIB, MFCOxxD.LIB, MFCDxxD.LIB, MFCNxxD.LIB<br><br></li>
<li>
Release: MFCxx.LIB<br><br></li>
<li>
Unicode Debug: MFCxxUD.LIB, MFCOxxUD.LIB, MFCDxxUD.LIB, MFCNxxUD.LIB<br><br></li>
<li>
Unicode Release: MFCxxU.LIB</li>
</ul>
<p>
An “MFC Extension DLL” is a DLL built upon MFCxx.DLL (and/or the other MFC shared DLLs). Here the MFC component architecture kicks in. If you derive a useful class from an MFC class, or build another MFC-like toolkit, you can place it in a DLL. That DLL uses MFCxx.DLL, as does the ultimate client application. This permits reusable leaf classes, reusable base classes, and reusable view/document classes.</p>
<p class=indent>
<b>Note</b>&nbsp;&nbsp;&nbsp;It is not necessary to link with the MFCOxx[U]D, MFCDxx[U]D, or MFCNxx[U]D Debug libraries unless your application uses the MFC/OLE, database, or networking classes respectively.</p>
<p class=label>
<b>Pros and Cons</b></p>
<p>
Why should you use the shared version of MFC?
<ul type=disc>
<li>
Using the shared library can result in smaller applications [a minimal application that uses most of the MFC library is less than 10K].<br><br></li>
<li>
The shared version of MFC supports MFC Extension DLLs and regular DLLs.<br><br></li>
<li>
Building an application that uses the shared MFC libraries is faster than building a statically linked MFC application because it is not necessary to link MFC itself. This is especially true in <b>DEBUG</b> builds where the linker must compact the debug information -- by linking with a DLL that already contains the debug information, there is less debug information to compact within your application.</li>
</ul>
<p>
Why should you not use the shared version of MFC:
<ul type=disc>
<li>
Shipping an application that uses the shared library requires that you ship the MFCxx.DLL (and others) library with your program. MFCxx.DLL is freely redistributable like many DLLs, but you still must install the DLL in your SETUP program. In addition, you must ship the MSVCRTxx.DLL, which contains the C-runtime library which is used both by your program and the MFC DLLs themselves.</li>
</ul>

<h2><a name="_mfcnotes_how_to_write_an_mfc_extension_dll"></a>How to Write an MFC Extension DLL</h2>
<p>
An MFC Extension DLL is a DLL containing classes and functions written to embellish the functionality of the MFC classes. The OLE and database debug support DLLs (MFCOxxD.DLL and MFCDxxD.DLL) are examples of MFC extension DLLs in that they use MFCxxD.DLL. An MFC Extension DLL uses the shared MFC DLLs in the same way an application uses it, with a few additional considerations:
<ul type=disc>
<li>
The build process is similar to building an application that uses the shared MFC libraries with a few additional compiler and linker options.<br><br></li>
<li>
An MFC Extension DLL does not have a <b>CWinApp</b> derived class.<br><br></li>
<li>
An MFC Extension DLL must provide a special <b>DllMain</b>. AppWizard supplies a <b>DllMain</b> function that you can modify.<br><br></li>
<li>
An MFC Extension DLL will usually provide an initialization routine to create a <b>CDynLinkLibrary</b> if the extension DLL wishes to export <b>CRuntimeClass</b>es or resources to the application. A derived class of <b>CDynLinkLibrary</b> may be used if per-application data must be maintained by the extension DLL.</li>
</ul>
<p>
These considerations are described in more detail below. You should also refer to the MFC Advanced Concepts sample <object id=alink_2 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="DefaultTopic" value="_topic_not_found.htm">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="_sample_mfc_DLLHUSK">
</object><a href=JavaScript:alink_2.Click()>DLLHUSK</a> since it illustrates:
<ul type=disc>
<li>
Building an application using the shared libraries. (DLLHUSK.EXE is an MFC application that dynamically links to the MFC libraries as well as other DLLs.)<br><br></li>
<li>
Building an MFC Extension DLL. (Note the special flags such as <b>_AFXEXT</b> that are used in building an extension DLL)<br><br></li>
<li>
Two examples of MFC Extension DLLs. One shows the basic structure of an MFC Extension DLL with limited exports (TESTDLL1) and the other shows exporting an entire class interface (TESTDLL2).</li>
</ul>
<p>
Both the client application and any extension DLLs must use the same version of MFCxx.DLL. You should follow the convention of MFC DLL and provide both a debug and retail (/release) version of your extension DLL. This permits client programs to build both debug and retail versions of their applications and link them with the appropriate debug or retail version of all DLLs. </p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;Due to C++ name mangling and export issue, the export list from an extension DLL may be different between the debug and retail versions of the same DLL and DLLs for different platforms. The retail MFCxx.DLL has about 2000 exported entry points; the debug MFCxxD.DLL has about 3000 exported entry points.</p>
<p class=label>
<b>Quick Note on Memory Management</b></p>
<p>
The section titled “Memory Management,” near the end of this technical note, describes the implementation of the MFCxx.DLL with the shared version of MFC. The information you need to know to implement just an extension DLL is described here.</p>
<p>
MFCxx.DLL and all extension DLLs loaded into a client application's address space will use the same memory allocator, resource loading and other MFC “global” states as if they were in the same application. This is significant because the non-MFC DLL libraries and regular DLLs that statically link to MFC do the exact opposite and have each DLL allocating out of its own memory pool.</p>
<p>
If an extension DLL allocates memory, then that memory can freely intermix with any other application-allocated object. Also, if an application that uses the shared MFC libraries crashes, the protection of the operating system will maintain the integrity of any other MFC application sharing the DLL.</p>
<p>
Similarly other “global” MFC states, like the current executable file to load resources from, are also shared between the client application and all MFC extension DLLs as well as MFCxx.DLL itself.</p>
<p class=label>
<b>Building an Extension DLL</b></p>
<p>
You can use AppWizard to create an MFC extension DLL project, and it will automatically generate the appropriate compiler and linker settings. It was also generate a <b>DllMain</b> function that you can modify.</p>
<p>
If you are converting an existing project to an MFC extension DLL, start with the standard rules for building an application using the shared version of MFC, then do the following:
<ul type=disc>
<li>
Add <b>/D_AFXEXT</b> to the compiler flags. On the Project Settings dialog, select the C/C++ tab. Then select the Preprocessor category. Add <b>_AFXEXT</b> to the Preprocessor Definitions field, separating each of the items with commas.<br><br></li>
<li>
Remove the <b>/Gy</b> compiler switch On the Project Setting dialog, select the C/C++ tab. Then select the C Language category. Ensure that the "Enable Function-Level Linking" checkbox is cleared. This will make it easier to export classes because the linker will not remove unreferenced functions. If the original project is used to build a Regular DLL statically linked to MFC, change the <b>/MT[d]</b> compiler option to <b>/MD[d]</b>.<br><br></li>
<li>
Build an export library with the <b>/DLL</b> option to LINK. This will be set when you create a new target, specifying Win32 Dynamic-Link Library as the target type.</li>
</ul>
<p class=label>
<b>Changing your Header Files</b></p>
<p>
The goal of an extension DLL is usually to export some common functionality to one or more applications which can use that functionality. This boils down to exporting classes and global functions which are available for your client applications.</p>
<p>
In order to do this you must insure that each of the member functions is marked as import or export as appropriate. This requires special declarations: <b>__declspec(dllexport)</b> and <b>__declspec(dllimport)</b>. When your classes are used by the client applications, you want them to be declared as <b>__declspec(dllimport)</b>. When the extension DLL itself is being built, they should be declared as <b>__declspec(dllexport)</b>. In addition, the functions must be actually exported, so that the client programs bind to them at load time.</p>
<p>
To export your entire class, use <b>AFX_EXT_CLASS</b> in the class definition. This macro is defined by the framework as <b>__declspec(dllexport)</b> when <b>_AFXDLL</b> and <b>_AFXEXT</b> is defined, but defined as <b>__declspec(dllimport)</b> when <b>_AFXEXT</b> is not defined. <b>_AFXEXT</b> as described above, is only defined when building your extension DLL. For example:</p>
<pre><code>class AFX_EXT_CLASS CExampleExport : public CObject
{ ... class definition ... };
</code></pre>
<p class=label>
<b>Not Exporting the Entire Class</b></p>
<p>
Sometimes you may want to export just the individual necessary members of your class. For example, if you are exporting a <b>CDialog</b>-derived class, you might only need to export the constructor and the <b>DoModal</b> call. You can export these members using the DLL's .DEF file, but you can also use <b>AFX_EXT_CLASS</b> in much the same way on the individual members you need to export.</p>
<p>
For example:</p>
<pre><code>class CExampleDialog : public CDialog
{
public:
 &nbsp; AFX_EXT_CLASS CExampleDialog();
 &nbsp; AFX_EXT_CLASS int DoModal();
 &nbsp; // rest of class definition
 &nbsp; .
 &nbsp; .
 &nbsp; .
};
</code></pre>
<p>
When you do this, you may run into an additional problem due to the fact that you are no longer exporting all members of the class. The problem is in the way that MFC macros work. Several of MFC's helper macros actually declare or define data members. Therefore, these data members will also need to be exported from your DLL.</p>
<p>
For example, the <b>DECLARE_DYNAMIC</b> macro is defined as follows when building an extension DLL:</p>
<pre><code>#define DECLARE_DYNAMIC(class_name) \
protected: \
 &nbsp; static CRuntimeClass* PASCAL _GetBaseClass(); \
 &nbsp; public: \
 &nbsp; static AFX_DATA CRuntimeClass class##class_name; \
 &nbsp; virtual CRuntimeClass* GetRuntimeClass() const; \
</code></pre>
<p>
The line that begins "static <b>AFX_DATA</b>" is declaring a static object inside of your class. To export this class correctly and access the runtime information from a client .EXE, you need to export this static object. Because the static object is declared with the modifier <b>AFX_DATA</b>, you only need to define <b>AFX_DATA</b> to be <b>__declspec(dllexport)</b> when building your DLL and define it as <b>__declspec(dllimport)</b> when building your client executable.</p>
<p>
As discussed above, <b>AFX_EXT_CLASS</b> is already defined in this way. So you just need to re-define <b>AFX_DATA</b> to be the same as <b>AFX_EXT_CLASS</b> around your class definition.</p>
<p>
For example:</p>
<pre><code>&nbsp;&nbsp;&nbsp;#undef&nbsp; AFX_DATA
 &nbsp; #define AFX_DATA AFX_EXT_CLASS
 &nbsp; class CExampleView : public CView
 &nbsp; {
 &nbsp;&nbsp;&nbsp; DECLARE_DYNAMIC()
 &nbsp;&nbsp;&nbsp; // ... class definition ...
 &nbsp; };
 &nbsp; #undef&nbsp; AFX_DATA
 &nbsp; #define AFX_DATA
</code></pre>
<p>
MFC always uses the <b>AFX_DATA</b> symbol on data items it defines within its macros, so this technique will work for all such scenarios. For example it will work for <b>DECLARE_MESSAGE_MAP</b>.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;If you are exporting the entire class rather than selected members of the class, static data members are automatically exported.</p>
<p>
You can use the same technique to automatically export the <b>CArchive</b> extraction operator for classes that use the <b>DECLARE_SERIAL</b> and <b>IMPLEMENT_SERIAL</b> macros. Export the archive operator by bracketing the class declarations (located in the .H file) with the following code:</p>
<pre><code>#undef AFX_API
#define AFX_API AFX_EXT_CLASS

&lt;your class declarations here&gt;

#undef AFX_API
#define AFX_API
</code></pre>
<p class=label>
<b>Limitations of _AFXEXT</b></p>
<p>
You can use the _<b>AFXEXT</b> pre-processor symbol for your extension DLLs as long as you do not have multiple layers of extension DLLs. If you have extension DLLs which call or derive from classes in your own extension DLLs, which then derive from the MFC classes, you must use your own preprocessor symbol to avoid ambiguity.</p>
<p>
The problem is that in Win32, you must explicitly declare any data as <b>__declspec(dllexport)</b> if it is to be exported from a DLL, and <b>__declspec(dllimport)</b> if it is to be imported from a DLL. When you define <b>_AFXEXT</b>, the MFC headers make sure that <b>AFX_EXT_CLASS</b> is defined correctly.</p>
<p>
When you have multiple layers, one symbol such as <b>AFX_EXT_CLASS</b> is not sufficient, since an extension DLL may be exporting new classes as well as importing other classes from another extension DLL. In order to deal with this problem, use a special pre-processor symbol which indicates that you are building the DLL itself versus using the DLL. For example, imagine two extension DLLs, A.DLL, and B.DLL. They each export some classes in A.H and B.H, respectively. B.DLL uses the classes from A.DLL. The header files would look something like this:</p>
<pre><code>// A.H
#ifdef A_IMPL
 &nbsp; #define CLASS_DECL_A   __declspec(dllexport)
#else
 &nbsp; #define CLASS_DECL_A   __declspec(dllimport)
#endif

class CLASS_DECL_A CExampleA : public CObject
{ ... class definition ... };

// B.H
#ifdef B_IMPL
 &nbsp; #define CLASS_DECL_B   __declspec(dllexport)
#else
 &nbsp; #define CLASS_DECL_B   __declspec(dllimport)
#endif

class CLASS_DECL_B CExampleB : public CExampleA
{ ... class definition .. };
</code></pre>
<p>
When A.DLL is built, it is built with <b>/D A_IMPL</b> and when B.DLL is built, it is built with <b>/D B_IMPL</b>. By using separate symbols for each DLL, CExampleB is exported and CExampleA is imported when building B.DLL. CExampleA is exported when building A.DLL and imported when used by B.DLL (or some other client).</p>
<p>
This type of layering cannot be done when using the built-in <b>AFX_EXT_CLASS</b> and <b>_AFXEXT</b> pre-processor symbols. The technique described above solves this problem in a manner not unlike the mechanism MFC itself uses when building its OLE, Database, and Network extension DLLs.</p>
<p class=label>
<b>Not Exporting the Entire Class</b></p>
<p>
Again you will have to take special care when you are not exporting an entire class. You have to ensure that the necessary data items created by the MFC macros are exported correctly. This can be done by re-defining <b>AFX_DATA </b>to your specific class' macro. This should be done any time you are not exporting the entire class.</p>
<p>
For example:</p>
<pre><code>// A.H
#ifdef A_IMPL
 &nbsp; #define CLASS_DECL_A&nbsp; _declspec(dllexport)
#else
 &nbsp; #define CLASS_DECL_A&nbsp; _declspec(dllimport)
 &nbsp; #endif

#undef&nbsp; AFX_DATA
#define AFX_DATA CLASS_DECL_A

class CExampleA : public CObject
{
 &nbsp; DECLARE_DYNAMIC()
 &nbsp; CLASS_DECL_A int SomeFunction();
 &nbsp; //class definition 
 &nbsp; .
 &nbsp; .
 &nbsp; .
};

#undef AFX_DATA
#define AFX_DATA
</code></pre>
<p class=label>
<b>DllMain</b></p>
<p>
The following is the exact code you should place in your main source file for your extension DLL. It should come after the standard includes. Note that when you use AppWizard to create starter files for an extension DLL, it supplies a <b>DllMain</b> for you. </p>
<pre><code>#include "afxdllx.h"

static AFX_EXTENSION_MODULE extensionDLL;

extern "C" int APIENTRY 
DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID)
{
 &nbsp; if (dwReason == DLL_PROCESS_ATTACH)
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; // Extension DLL one-time initialization 
 &nbsp;&nbsp;&nbsp;&nbsp; if (!AfxInitExtensionModule(
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; extensionDLL, hInstance))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;

 &nbsp;&nbsp;&nbsp;&nbsp; // TODO: perform other initialization tasks here
 &nbsp; }
 &nbsp; else if (dwReason == DLL_PROCESS_DETACH)
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; // Extension DLL per-process termination
 &nbsp;&nbsp;&nbsp;&nbsp; AfxTermExtensionModule(extensionDLL);

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // TODO: perform other cleanup tasks here
 &nbsp; }
 &nbsp; return 1;&nbsp;&nbsp; // ok
}
</code></pre>
<p>
The call to <b>AfxInitExtensionModule</b> captures the modules runtime-classes (<b>CRuntimeClass</b> structures) as well as its object factories (<b>COleObjectFactory</b> objects) for use later when the <b>CDynLinkLibrary</b> object is created. The (optional) call to <b>AfxTermExtensionModule</b> allows MFC to cleanup the extension DLL when each process detaches (which happens when the process exits, or when the DLL is unloaded as a result of a <b>FreeLibrary</b> call) from the extension DLL. Since most extension DLLs are not dynamically loaded (usually, they are linked via their import libraries), the call to <b>AfxTermExtensionModule</b> is usually not necessary. </p>
<p>
If your application loads and frees extension DLLs dynamically, be sure to call <b>AfxTermExtensionModule</b> as shown above.&nbsp; Also be sure to use <b>AfxLoadLibrary</b> and <b>AfxFreeLibrary</b> (instead of Win32 functions <b>LoadLibrary</b> and <b>FreeLibrary</b>) if your application uses multiple threads. Using <b>AfxLoadLibrary</b> and <b>AfxFreeLibrary</b> insures that the startup and shutdown code which executes when the extension DLL is loaded and unloaded does not corrupt the global MFC state.</p>
<p>
The header file AFXDLLX.H contains special defintions for structures used in extension DLLs, such as the definition for <b>AFX_EXTENSION_MODULE</b> and <b>CDynLinkLibrary</b>.</p>
<p>
The global <i>extensionDLL</i> must be declared as shown. Unlike the 16-bit version of MFC, you can allocate memory and call MFC functions during this time, since the MFCxx.DLL is fully initialized by the time your <b>DllMain</b> is called.</p>
<p class=label>
<b>Sharing Resources and Classes</b></p>
<p>
Simple MFC extension DLLs need only export a few low-bandwidth functions to the client application and nothing more. More user-interface intensive DLLs may want to export resources and C++ classes to the client application.</p>
<p>
Exporting resources is done through a resource list. In each application is a singly linked list of <b>CDynLinkLibrary</b> objects. When looking for a resource, most of the standard MFC implementations that load resources look first at the current resource module (<b>AfxGetResourceHandle</b>) and if not found walk the list of <b>CDynLinkLibrary</b> objects attempting to load the requested resource.</p>
<p>
Dynamic creation of C++ objects given a C++ class name is similar. The MFC object deserialization mechanism needs to have all of the <b>CRuntimeClass</b> objects registered so that it can reconstruct by dynamically creating C++ object of the required type based on what was stored earlier.</p>
<p>
If you want the client application to use classes in your extension DLL that are <b>DECLARE_SERIAL</b>, then you will need to export your classes to be visible to the client application. This is also done by walking the <b>CDynLinkLibrary</b> list.</p>
<p>
In the case of the MFC Advanced Concepts sample <object id=alink_3 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="DefaultTopic" value="_topic_not_found.htm">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="_sample_mfc_DLLHUSK">
</object><a href=JavaScript:alink_3.Click()>DLLHUSK</a>, the list looks something like:</p>
<pre><code>head -&gt; &nbsp; DLLHUSK.EXE&nbsp;&nbsp; - or -&nbsp;&nbsp; DLLHUSK.EXE
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TESTDLL2.DLL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TESTDLL2.DLL
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TESTDLL1.DLL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TESTDLL1.DLL
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MFCO42D.DLL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MFCD42D.DLL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MFC42D.DLL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MFC42.DLL
</code></pre>
<p>
The MFCxx.DLL is usually last on the resource and class list. MFCxx.DLL includes all of the standard MFC resources, including prompt strings for all the standard command IDs. Placing it at the tail of the list allows DLLs and the client application itself to not have a their own copy of the standard MFC resources, but to rely on the shared resources in the MFCxx.DLL instead.</p>
<p>
Merging the resources and class names of all DLLs into the client application's name space has the disadvantage that you have to be careful what IDs or names you pick. You can of course disable this feature by not exporting either your resources or a <b>CDynLinkLibrary</b> object to the client application. The <object id=alink_4 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="DefaultTopic" value="_topic_not_found.htm">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="_sample_mfc_DLLHUSK">
</object><a href=JavaScript:alink_4.Click()>DLLHUSK</a> sample manages the shared resource name space by using multiple header files. See <a href="_mfcnotes_tn035.htm">Technical Note 35</a> for more tips on using shared resource files.</p>
<p class=label>
<b>Initializing the DLL</b></p>
<p>
As mentioned above, you will usually want to create a <b>CDynLinkLibrary</b> object in order to export your resources and classes to the client application. You will need to provide an exported entry point to initialize the DLL. Minimally this is a void routine that takes no arguments and returns nothing, but it can be anything you like.</p>
<p>
Each client application that wants to use your DLL must call this initialization routine, if you use this approach. You may also allocate this <b>CDynLinkLibrary</b> object in your <b>DllMain</b> just after calling <b>AfxInitExtensionModule</b>.</p>
<p>
The initialization routine must create a <b>CDynLinkLibrary</b> object in the current application's heap, wired up to your extension DLL information. This can be done with the following:</p>
<pre><code>extern "C" extern void WINAPI InitXxxDLL()
{
 &nbsp; new CDynLinkLibrary(extensionDLL);
}
</code></pre>
<p>
The routine name, <i>InitXxxDLL</i> in this example, can be anything you want. It does not need to be <code>extern “C”</code>, but doing so makes the export list easier to maintain.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;If you use your extension DLL from a regular DLL, you must export this initialization function. This function must be called from the regular DLL before using any extension DLL classes or resources.</p>
<p class=label>
<b>Exporting Entries</b></p>
<p>
The simple way to export your classes is to use <b>__declspec(dllimport)</b> and <b>__declspec(dllexport)</b> on each class and global function you wish to export. This makes it a lot easier, but is less efficient than naming each entry point (described below) since you have less control over what functions get exported and you cannot export the functions by ordinal. This is the method that both TESTDLL1 and TESTDLL2 use to export their entries.</p>
<p>
A more efficient method (and the method used by MFCxx.DLL) is to export each entry by hand by naming each entry in the .DEF file. Since we are exporting selective exports from our DLL (that is, not everything), we must decide which particular interfaces we wish to export. This is difficult since you must specify the mangled names to the linker in the form of entries in the .DEF file. Don't export any C++ classes unless you really need to have a symbolic link for it.</p>
<p>
If you have tried exporting C++ classes with a .DEF file before, you may want to develop a tool to generate this list automatically. This can be done using a two stage link process. Link your DLL once with no exports, and allow the linker to generate a .MAP file. The .MAP file can be used to generate a list of functions which should be exported, so with some munging, it can be used to generate your EXPORT entries for your .DEF file. The export list for MFCxx.DLL and the OLE and Database extension DLLs, several thousand in number, was generated with such a process (although it is not completely automatic and requires some hand tuning every once in a while).</p>
<p class=label>
<b>CWinApp vs. CDynLinkLibrary</b></p>
<p>
An MFC Extension DLL does not have a <b>CWinApp</b>-derived object of its own; instead it must work with the <b>CWinApp</b>-derived object of the client application. This means that the client application owns the main message pump, the idle loop and so on.</p>
<p>
If your MFC Extension DLL needs to maintain extra data for each application, you can derive a new class from <b>CDynLinkLibrary</b> and create it in the InitXxxDLL routine describe above. When running, the DLL can check the current application's list of <b>CDynLinkLibrary</b> objects to find the one for that particular extension DLL.</p>
<p class=label>
<b>Using Resources in Your DLL Implementation</b></p>
<p>
As mentioned above, the default resource load will walk the list of <b>CDynLinkLibrary</b> objects looking for the first EXE or DLL which has the requested resource. All MFC APIs as well as all the internal code uses <b>AfxFindResourceHandle</b> to walk the resource list to find any resource, no matter where it may reside.</p>
<p>
If you wish to only load resources from a specific place, use the APIs <b>AfxGetResourceHandle</b> and <b>AfxSetResourceHandle</b> to save the old handle and set the new handle. Be sure to restore the old resource handle before you return to the client application. The sample TESTDLL2 uses this approach for explicitly loading a menu.</p>
<p>
Walking the list has the disadvantages that it is slightly slower and requires managing resource ID ranges. It has the advantage that a client application that links to several extension DLLs can use any DLL-provided resource without having to specify the DLL instance handle. <b>AfxFindResourceHandle</b> is an API used for walking the resource list to look for a given match. It takes the name and type of a resource and returns the resource handle where it was first found (or NULL).</p>

<h2><a name="_mfcnotes_writing_an_application_that_uses_the_dll_version"></a>Writing an Application That Uses the DLL Version</h2>
<p class=label>
<b>Application Requirements</b></p>
<p>
An application that uses the shared version of MFC must follow a few simple rules:
<ul type=disc>
<li>
It must have a <b>CWinApp</b> object and follow the standard rules for a message pump.<br><br></li>
<li>
It must be compiled with a set of required compiler flags (see below). <br><br></li>
<li>
It must link with the MFCxx import libraries. By setting the required compiler flags, the MFC headers determine at link time which library the application should link with.<br><br></li>
<li>
To run the executable, MFCxx.DLL must be on the path or in the Windows system directory.</li>
</ul>
<p class=label>
<b>Building with the Development Environment</b></p>
<p>
If you are using the internal makefile with most of the standard defaults, you can easily change the project to build the DLL version.</p>
<p>
The following step assumes you have a correctly functioning MFC application linked with NAFXCWD.LIB (for debug) and NAFXCW.LIB (for retail) and you want to convert it to use the shared version of the MFC library. You are running the Visual C++ environment and have an internal project file.
<ol start=4>
<li>
Select Settings from the Build menu. In the General page under Project Settings, set Microsoft Foundation Classes to Use MFC in a Shared DLL (MFCxx(d).dll).</li>
</ol>
<p class=label>
<b>Building with NMAKE</b></p>
<p>
If you are using the external makefile feature of the Visual C++, or are using NMAKE directly, you will have to edit your makefile to support compiler and linker options</p>
<p>
Required compiler flags: </p>
<p class=dt>
/D_AFXDLL /MD</p>
<p class=indent>
/D_AFXDLL</p>
<p>
The standard MFC headers need this symbol to be defined:</p>
<p class=dt>
/MD</p>
<p class=indent>
The application must use the DLL version of the C-runtime library</p>
<p>
All other compiler flags follow the MFC defaults (for example, _DEBUG for debug).</p>
<p>
Edit the linker list of libraries. Change NAFXCWD.LIB to MFCxxD.LIB and change NAFXCW.LIB to MFCxx.LIB. Add MFCOxx[U]D.LIB, MFCDxx[U]D.LIB, and MFCNxx[U]D.LIB as appropriate (required for with use of the MFC/OLE, database, or networking classes). Replace LIBC.LIB with MSVCRT.LIB. As with any other MFC library it is important that MFCxxD.LIB is placed <b>before</b> any C-runtime libraries.</p>
<p>
Optionally add /D_AFXDLL to both your retail and debug resource compiler options (the one that actually compiles the resources with /R). This makes your final executable smaller by sharing the resources that are present in the MFC DLLs.</p>
<p>
A full rebuild is required after these changes are made.</p>
<p class=label>
<b>Building the Samples</b></p>
<p>
Most of the MFC sample programs can be built from Visual C++ or from a shared NMAKE-compatible MAKEFILE from the command line. </p>
<p>
To convert any of these samples to use MFCxx.DLL, you can load the .MAK file into the Visual C++ and set the Project options as described above. If you are using the NMAKE build, you can specify “AFXDLL=1” on the NMAKE command line and that will build the sample using the shared MFC libraries.</p>
<p>
The MFC Advanced Concepts sample <object id=alink_5 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="DefaultTopic" value="_topic_not_found.htm">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="_sample_mfc_DLLHUSK">
</object><a href=JavaScript:alink_5.Click()>DLLHUSK</a> is built with the DLL version of MFC. This sample not only illustrates how to build an application linked with MFCxx.DLL, but it also illustrates other features of the MFC DLL packaging option such as MFC Extension DLLs described later in this technical note.</p>
<p class=label>
<b>Packaging Notes</b></p>
<p>
The retail version of the DLLs (MFCxx[U].DLL) are freely redistributable. The debug version of the DLLs are not freely redistributable and should be used only during the development of your application.</p>
<p>
The debug DLLs are provided with debugging information. By using the Visual C++ debugger, you can trace execution of your application as well as the DLL. The Release DLLs (MFCxx[U].DLL) do not contain debugging information.</p>
<p>
If you customize or rebuild the DLLs, then you should call them something other than “MFCxx” The MFC SRC file MFCDLL.MAK describes build options and contains the logic for renaming the DLL. This rule also applies to the MFC/OLE, database, and network DLLs which are built by MFCOLE.MAK, MFCDB.MAK, and MFCNET.MAK, respectively. Renaming the files is necessary, since these DLLs are potentially shared by many MFC applications. Having your custom version of the MFC DLLs replace those installed on the system may break another MFC application using the shared MFC DLLs.</p>
<p>
Rebuilding the MFC DLLs is not recommended.</p>

<h2><a name="_mfcnotes_how_the_mfc30.dll_is_implemented"></a>How the MFCxx.DLL Is Implemented</h2>
<p>
The following section describes how the MFC DLL (MFCxx.DLL and MFCxxD.DLL) is implemented. Understanding the details here are also not important if all you want to do is use the MFC DLL with your application. The details here are not essential for understanding how to write an MFC extension DLL, but understanding this implementation may help you write your own DLL.</p>
<p class=label>
<b>Implementation Overview</b></p>
<p>
The MFC DLL is really a special case of an MFC Extension DLL as described above. It has a very large number of exports for a large number of classes. There are a few additional things we do in the MFC DLL that make it even more special than a regular Extension DLL.</p>
<p class=label>
<b>Win32 Does Most of the Work</b></p>
<p>
The 16-bit version of MFC needed a number of special techniques including per-app data on the stack segment, special segments created by some 80x86 assembly code, per-process exception contexts, and other techniques. Win32 directly supports per-process data in a DLL, which is what you want most of the time. For the most part MFCxx.DLL is just NAFXCW.LIB packaged in a DLL. If you look at the MFC source code, you'll find very few #ifdef _AFXDLL, since there are very few special cases that need to be made. The special cases that are there are specifically to deal with Win32 on Windows 3.1 (otherwise known as Win32s). Win32s does not support per-process DLL data directly so the MFC DLL must use the thread-local storage (TLS) Win32 APIs to obtain process local data.</p>
<p class=label>
<b>Impact on Library Sources, Additional Files</b></p>
<p>
The impact of the <b>_AFXDLL</b> version on the normal MFC class library sources and headers is relatively minor. There is a special version file (AFXV_DLL.H) as well as an additional header file (AFXDLL_.H) included by the main AFXWIN.H header. The AFXDLL_.H header includes the <b>CDynLinkLibrary</b> class and other implementation details of both <b>_AFXDLL</b> applications and MFC Extension DLLs. The AFXDLLX.H header is provided for building MFC Extension DLLs (see above for details).</p>
<p>
The regular sources to the MFC library in MFC SRC have some additional conditional code under the <b>_AFXDLL</b> #ifdef. An additional source file (DLLINIT.CPP) contains the extra DLL initialization code and other glue for the shared version of MFC.</p>
<p>
In order to build the shared version of MFC, additional files are provided. (See below for details on how to build the DLL.)
<ul type=disc>
<li>
A special makefile (MFCDLL.MAK) is used for building the DLLs. This makefile includes the standard MAKEFILE to get all the normal MFC library building rules.<br><br></li>
<li>
Two .DEF files are used for exporting the MFC DLL entry points for debug (MFCxxD.DEF) and release (MFCxx.DEF) versions of the DLL.<br><br></li>
<li>
An .RC file (MFCDLL.RC) contains all the standard MFC resources and a VERSIONINFO resource for the DLL.<br><br></li>
<li>
A .CLW file (MFCDLL.CLW) is provided to allow browsing the MFC classes using ClassWizard. Note: this feature is not particular to the DLL version of MFC.</li>
</ul>
<p class=label>
<b>Building the MFC DLL</b></p>
<p>
Rebuilding the MFC DLL is intentionally difficult, so you think twice (or three times) before doing it. If you understand the potential packaging problems and redistribution restrictions described below, and you still <i>really</i> need to rebuild the MFC DLL, you can.</p>
<p>
The MFCDLL.MAK file will build the Debug DLL with CodeView info:</p>
<pre><code>NMAKE /f mfcdll.mak DEBUG=1 LIBNAME=MYMFC
</code></pre>
<p>
The MFCDLL.MAK file will build the Release DLL without CodeView info:</p>
<pre><code>NMAKE /f mfcdll.mak DEBUG=0 LIBNAME=MYMFC
</code></pre>
<p>
(similarly, you use MFCOLE.MAK, MFCDB.MAK, and MFCNET.MAK to build the MFCOxxD.DLL, MFCDxxD.DLL, and MFCNxxD.DLL -- the DLLs which contain the MFC/OLE, database, and network classes)</p>
<p>
This will build a private version of the MFC DLL in your MFC SRC directory with the standard MFCxx.DLL and MFCxxD.DLL names. You will need to copy them to an appropriate place on your path to use the new DLLs. The MFCDLL.MAK makefile will also rebuild the import libraries (MFCxx.LIB and MFCxxD.LIB) and place them in the standard MFC LIB directory. This will replace the prebuilt MFCxx.LIB and MFCxxD.LIB libraries, so please be careful.</p>
<p>
If you wish to redistribute a modified version of the MFC DLL library, please be sure to change the name of the DLL in the MFCDLL.MAK makefile and the two .DEF files. See the makefile MFCDLL.MAK for more info.</p>
<p>
You may modify the library and redistribute a retail (/release) of your modified library only if you rename it to something other than MFCxx.DLL. You may not redistribute the debug version of either the pre-built or custom built debug DLL.</p>
<p>
These redistribution restrictions are primarily to avoid a proliferation of nonstandard and potentially virus containing DLLs. Ideally you should not need to rebuild the DLLs and if you redistribute your application with the prebuilt MFCxx.DLL provided with the Visual C++ product, you will avoid a lot of problems for yourself and your users.</p>
<p class=label>
<b>Memory Management</b></p>
<p>
An application using MFCxx.DLL uses a common memory allocator provided by MSVCRTxx.DLL, the shared C-runtime DLL. Both the application, any extension DLLs, as well as the MFC DLLs themselves, use this shared memory allocator. By using a shared DLL for memory allocation, the MFC DLLs can allocate memory which is later freed by the application or vice-versa. Because both the application and the DLL must use the same allocator, you should not override the C++ global <b>operator new</b> or <b>operator delete</b>. The same rules apply to the rest of the C-runtime memory allocation routines (such as malloc, realloc, free, etc.).</p>
<p class=label>
<b>Ordinals and class __declspec(dllexport) and DLL naming</b></p>
<p>
We do not use the <code>class</code> <b>__declspec(dllexport)</b> functionality of the C++ compiler. Instead, a list of exports is included with the class library sources (MFCxx.DEF and MFCxxD.DEF). Only these select set of entry points (functions and data) are exported. Other symbols, such as MFC private implementation functions or classes, are not exported All exports are done by ordinal without a string name in the resident or non-resident name table.</p>
<p>
Using <code>class</code> <b>__declspec(dllexport)</b> may be a viable alternative for building smaller DLLs, but in the case of a large DLL like MFC, the default exporting mechanism has efficiency and capacity limits.</p>
<p>
What this all means is that we can package a large amount of functionality in the release MFCxx.DLL that is only around 800 KBytes without compromising much execution or loading speed. MFCxx.DLL would have been 100K larger had this technique not been used.This also makes it possible to add additional entry points at the end of the .DEF file to allow simple versioning without compromising the speed and size efficiency of exporting by ordinal. Major version revisions in the MFC class library will change the library name. That is, MFC30.DLL is the redistributable DLL containing version 3.0 of the MFC class library. An upgrade of this DLL, say, in a hypothetical MFC 3.1, the DLL would be named MFC31.DLL instead. Again, if you modify the MFC source code to produce a custom version of the MFC DLL, please use a different name (and preferably one without “MFC” in the name).</p>
<p>
<a href="_mfcnotes_technical_notes_by_number.htm">Technical Notes by Number</a>  |&nbsp; <a href="_mfcnotes_technical_notes_by_category.htm">Technical Notes by Category</a></p>
</font></BODY>
</HTML>
