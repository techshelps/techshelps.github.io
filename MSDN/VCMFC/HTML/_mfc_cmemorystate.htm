<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CMemoryState</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY>
<font face="verdana,arial,helvetica" size="2">
<h1><a name="_mfc_cmemorystate"></a><sup></sup>CMemoryState</h1>
<p>
<b>CMemoryState</b> does not have a base class.</p>
<p>
<b>CMemoryState</b> provides a convenient way to detect memory leaks in your program. A “memory leak” occurs when memory for an object is allocated on the heap but not deallocated when it is no longer required. Such memory leaks can eventually lead to out-of-memory errors. There are several ways to allocate and deallocate memory in your program:
<ul type=disc>
<li>
Using the <b>malloc</b>/<b>free</b> family of functions from the run-time library.<br><br></li>
<li>
Using the Windows API memory management functions, <b>LocalAlloc</b>/<b>LocalFree</b> and <b>GlobalAlloc</b>/<b>GlobalFree</b>.<br><br></li>
<li>
Using the C++ <b>new</b> and <b>delete</b> operators.</li>
</ul>
<p>
The <b>CMemoryState</b> diagnostics only help detect memory leaks caused when memory allocated using the <b>new</b> operator is not deallocated using <b>delete</b>. The other two groups of memory-management functions are for non-C++ programs, and mixing them with <b>new</b> and <b>delete</b> in the same program is not recommended. An additional macro, <b>DEBUG_NEW</b>, is provided to replace the <b>new</b> operator when you need file and line-number tracking of memory allocations. <b>DEBUG_NEW</b> is used whenever you would normally use the <b>new</b> operator.</p>
<p>
As with other diagnostics, the <b>CMemoryState</b> diagnostics are only available in debug versions of your program. A debug version must have the <b>_DEBUG</b> constant defined.</p>
<p>
If you suspect your program has a memory leak, you can use the <b>Checkpoint</b>, <b>Difference</b>, and <b>DumpStatistics</b> functions to discover the difference between the memory state (objects allocated) at two different points in program execution. This information can be useful in determining whether a function is cleaning up all the objects it allocates.</p>
<p>
If simply knowing where the imbalance in allocation and deallocation occurs does not provide enough information, you can use the <b>DumpAllObjectsSince</b> function to dump all objects allocated since the previous call to <b>Checkpoint</b>. This dump shows the order of allocation, the source file and line where the object was allocated (if you are using <b>DEBUG_NEW</b> for allocation), and the derivation of the object, its address, and its size. <b>DumpAllObjectsSince</b> also calls each object’s <b>Dump</b> function to provide information about its current state.</p>
<p>
For more information about how to use <b>CMemoryState</b> and other diagnostics, see <object id=alink_1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="DefaultTopic" value="_topic_not_found.htm">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="mfcdebug">
</object><a href=JavaScript:alink_1.Click()>MFC Debugging Support</a> in <i>Visual C++ Programmer’s Guide</i>.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;Declarations of objects of type <b>CMemoryState</b> and calls to member functions should be bracketed by <code>#if defined(_DEBUG)/#endif </code>directives. This causes memory diagnostics to be included only in debugging builds of your program.</p>
<p>
<a href="_mfc_cmemorystate_class_members.htm">Class Members</a>  |&nbsp; <a href="_mfc_hierarchy_chart.htm">Hierarchy Chart</a></p>
</font></BODY>
</HTML>
