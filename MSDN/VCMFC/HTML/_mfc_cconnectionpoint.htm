<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CConnectionPoint</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY>
<font face="verdana,arial,helvetica" size="2">
<h1><a name="_mfc_cconnectionpoint"></a>CConnectionPoint</h1>
<p>
<img src="cconxnpt.gif" border=0></p>
<p>
The <b>CConnectionPoint</b> class defines a special type of interface used to communicate with other OLE objects, called a “connection point.” Unlike normal OLE interfaces, which are used to implement and expose the functionality of an OLE control, a connection point implements an outgoing interface that is able to initiate actions on other objects, such as firing events and change notifications.</p>
<p>
A connection consists of two parts: the object calling the interface, called the “source,” and the object implementing the interface, called the “sink.” By exposing a connection point, a source allows sinks to establish connections to itself. Through the connection point mechanism, a source object obtains a pointer to the sink’s implementation of a set of member functions. For example, to fire an event implemented by the sink, the source can call the appropriate method of the sink’s implementation.</p>
<p>
By default, a <b>COleControl</b>-derived class implements two connection points: one for events and one for property change notifications. These connections are used, respectively, for event firing and for notifying a sink (for example, the control’s container) when a property value has changed. Support is also provided for OLE controls to implement additional connection points. For each additional connection point implemented in your control class, you must declare a “connection part” that implements the connection point. If you implement one or more connection points, you also need to declare a single “connection map” in your control class.</p>
<p>
The following example demonstrates a simple connection map and one connection point for the <code>Sample</code> OLE control, consisting of two fragments of code: the first portion declares the connection map and point; the second implements this map and point. The first fragment is inserted into the declaration of the control class, under the <b>protected</b> section:</p>
<pre><code>&nbsp;&nbsp;&nbsp;&nbsp;// Connection point for ISample interface
 &nbsp;&nbsp; BEGIN_CONNECTION_PART(CSampleCtrl, SampleConnPt)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CONNECTION_IID(IID_ISampleSink)
 &nbsp;&nbsp; END_CONNECTION_PART(SampleConnPt)

 &nbsp;&nbsp; DECLARE_CONNECTION_MAP()
</code></pre>
<p>
The <b>BEGIN_CONNECTION_PART</b> and <b>END_CONNECTION_PART</b> macros declare an embedded class, <code>XSampleConnPt</code> (derived from <b>CConnectionPoint</b>) that implements this particular connection point. If you want to override any <b>CConnectionPoint</b> member functions, or add member functions of your own, declare them between these two macros. For example, the <b>CONNECTION_IID</b> macro overrides the <b>CConnectionPoint::GetIID</b> member function when placed between these two macros.</p>
<p>
The second code fragment is inserted into the implementation file (.CPP) of your control class. This code implements the connection map, which includes the additional connection point, <code>SampleConnPt</code>:</p>
<pre><code>BEGIN_CONNECTION_MAP(CSampleCtrl, COleControl)
 &nbsp;&nbsp; CONNECTION_PART(CSampleCtrl, IID_ISampleSink, SampleConnPt)
END_CONNECTION_MAP()
</code></pre>
<p>
Once these code fragments have been inserted, the Sample OLE control exposes a connection point for the <b>ISampleSink</b> interface.</p>
<p>
Typically, connection points support “multicasting”; the ability to broadcast to multiple sinks connected to the same interface. The following code fragment demonstrates how to accomplish multicasting by iterating through each sink on a connection point:</p>
<pre><code>void CSampleCtrl::CallSinkFunc()
{
 &nbsp;&nbsp; const CPtrArray* pConnections = m_xSampleConnPt.GetConnections();
 &nbsp;&nbsp; ASSERT(pConnections != NULL);

 &nbsp;&nbsp; int cConnections = pConnections-&gt;GetSize();
 &nbsp;&nbsp; ISampleSink* pSampleSink;
 &nbsp;&nbsp; for (int i = 0; i &lt; cConnections; i++)
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pSampleSink = (ISampleSink*)(pConnections-&gt;GetAt(i));
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ASSERT(pSampleSink != NULL);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pSampleSink-&gt;SinkFunc();
 &nbsp;&nbsp; }
}
</code></pre>
<p>
This example retrieves the current set of connections on the <code>SampleConnPt</code> connection point with a call to <code>CConnectionPoint::GetConnections</code>. It then iterates through the connections and calls <code>ISampleSink::SinkFunc</code> on every active connection.</p>
<p>
For more information on using <b>CConnectionPoint</b>, see the article <object id=alink_1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="DefaultTopic" value="_topic_not_found.htm">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="_core_Connection_Points">
</object><a href=JavaScript:alink_1.Click()>Connection Points</a> in <i>Visual C++ Programmer's Guide</i>.</p>
<p>
<b>#include &lt;afxctl.h&gt;</b></p>
<p>
<a href="_mfc_cconnectionpoint_class_members.htm">Class Members</a>  |&nbsp; <a href="_mfc_ccmdtarget.htm">Base Class</a>  |&nbsp; <a href="_mfc_hierarchy_chart.htm">Hierarchy Chart</a></p>
</font></BODY>
</HTML>
