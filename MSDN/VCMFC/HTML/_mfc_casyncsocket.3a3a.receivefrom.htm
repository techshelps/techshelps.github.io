<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CAsyncSocket::ReceiveFrom</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY>
<font face="verdana,arial,helvetica" size="2">
<h1><a name="_mfc_casyncsocket.3a3a.receivefrom"></a><sup></sup>CAsyncSocket::ReceiveFrom</h1>
<p>
<b>int</b> <b>ReceiveFrom(</b> <b>void*</b> <i>lpBuf</i><b>,</b> <b>int</b> <i>nBufLen</i><b>,</b> <b>CString&amp;</b> <i>rSocketAddress</i><b>,</b> <b>UINT&amp;</b> <i>rSocketPort</i><b>,</b> <b>int</b> <i>nFlags</i> <b>=</b> <b>0</b> <b>);</b></p>
<p>
<b>int</b> <b>ReceiveFrom(</b> <b>void*</b> <i>lpBuf</i><b>,</b> <b>int</b> <i>nBufLen</i><b>,</b> <b>SOCKADDR*</b> <i>lpSockAddr</i><b>,</b> <b>int*</b> <i>lpSockAddrLen</i><b>,</b> <b>int</b> <i>nFlags</i> <b>=</b> <b>0</b> <b>);</b></p>
<p class=label>
<b>Return Value</b></p>
<p>
If no error occurs, <b>ReceiveFrom</b> returns the number of bytes received. If the connection has been closed, it returns 0. Otherwise, a value of <b>SOCKET_ERROR</b> is returned, and a specific error code can be retrieved by calling <b>GetLastError</b>. The following errors apply to this member function:
<ul type=disc>
<li>
<b>WSANOTINITIALISED</b>&nbsp;&nbsp;&nbsp;A successful <a href="_mfc_afxsocketinit.htm">AfxSocketInit</a> must occur before using this API.<br><br></li>
<li>
<b>WSAENETDOWN</b>&nbsp;&nbsp;&nbsp;The Windows Sockets implementation detected that the network subsystem failed.<br><br></li>
<li>
<b>WSAEFAULT</b>&nbsp;&nbsp;&nbsp;The <i>lpSockAddrLen</i> argument was invalid: the <i>lpSockAddr</i> buffer was too small to accommodate the peer address.<br><br></li>
<li>
<b>WSAEINPROGRESS</b>&nbsp;&nbsp;&nbsp;A blocking Windows Sockets operation is in progress.<br><br></li>
<li>
<b>WSAEINVAL</b>&nbsp;&nbsp;&nbsp;The socket has not been bound with <b>Bind</b>.<br><br></li>
<li>
<b>WSAENOTCONN</b>&nbsp;&nbsp;&nbsp;The socket is not connected (<b>SOCK_STREAM</b> only).<br><br></li>
<li>
<b>WSAENOTSOCK</b>&nbsp;&nbsp;&nbsp;The descriptor is not a socket.<br><br></li>
<li>
<b>WSAEOPNOTSUPP</b>&nbsp;&nbsp;&nbsp;<b>MSG_OOB</b> was specified, but the socket is not of type <b>SOCK_STREAM</b>.<br><br></li>
<li>
<b>WSAESHUTDOWN</b>&nbsp;&nbsp;&nbsp;The socket has been shut down; it is not possible to call <b>ReceiveFrom</b> on a socket after <b>ShutDown</b> has been invoked with <i>nHow</i> set to 0 or 2.<br><br></li>
<li>
<b>WSAEWOULDBLOCK</b>&nbsp;&nbsp;&nbsp;The socket is marked as nonblocking and the <b>ReceiveFrom</b> operation would block.<br><br></li>
<li>
<b>WSAEMSGSIZE</b>&nbsp;&nbsp;&nbsp;The datagram was too large to fit into the specified buffer and was truncated.<br><br></li>
<li>
<b>WSAECONNABORTED</b>&nbsp;&nbsp;&nbsp;The virtual circuit was aborted due to timeout or other failure.<br><br></li>
<li>
<b>WSAECONNRESET</b>&nbsp;&nbsp;&nbsp;The virtual circuit was reset by the remote side.</li>
</ul>
<p class=label>
<b>Parameters</b></p>
<p class=dt>
<i>lpBuf</i></p>
<p class=indent>
A buffer for the incoming data.</p>
<p class=dt>
<i>nBufLen</i></p>
<p class=indent>
The length of <i>lpBuf</i> in bytes.</p>
<p class=dt>
<i>rSocketAddress</i></p>
<p class=indent>
Reference to a <b>CString</b> object that receives a dotted number IP address.</p>
<p class=dt>
<i>rSocketPort</i></p>
<p class=indent>
Reference to a <b>UINT</b> that stores a port.</p>
<p class=dt>
<i>lpSockAddr</i></p>
<p class=indent>
A pointer to a <a href="_mfc_sockaddr_structure.htm">SOCKADDR</a> structure that holds the source address upon return.</p>
<p class=dt>
<i>lpSockAddrLen</i></p>
<p class=indent>
A pointer to the length of the source address in <i>lpSockAddr</i> in bytes.</p>
<p class=dt>
<i>nFlags</i></p>
<p class=indent>
Specifies the way in which the call is made. The semantics of this function are determined by the socket options and the <i>nFlags</i> parameter. The latter is constructed by combining any of the following values with the C++ <b>OR</b> operator:
<ul type=disc>
<li>
<b>MSG_PEEK</b>&nbsp;&nbsp;&nbsp;Peek at the incoming data. The data is copied into the buffer but is not removed from the input queue.<br><br></li>
<li>
<b>MSG_OOB</b>&nbsp;&nbsp;&nbsp;Process out-of-band data (see <object id=alink_1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="DefaultTopic" value="_topic_not_found.htm">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="_win32_Windows_Sockets_Programming_Considerations_2">
</object><a href=JavaScript:alink_1.Click()>Windows Sockets Programming Considerations</a> in the Win32 SDK documentation for a discussion of this topic).</li>
</ul>
<p class=label>
<b>Remarks</b></p>
<p>
Call this member function to receive a datagram and store the source address in the <a href="_mfc_sockaddr_structure.htm">SOCKADDR</a> structure or in <i>rSocketAddress</i>. This function is used to read incoming data on a (possibly connected) socket and capture the address from which the data was sent. </p>
<p>
For sockets of type <b>SOCK_STREAM</b>, as much information as is currently available up to the size of the buffer supplied is returned. If the socket has been configured for in-line reception of out-of-band data (socket option <b>SO_OOBINLINE</b>) and out-of-band data is unread, only out-of-band data will be returned. The application can use the <b>IOCtl</b> <b>SIOCATMARK</b> option or <b>OnOutOfBandData</b> to determine whether any more out-of-band data remains to be read. The <i>lpSockAddr</i> and <i>lpSockAddrLen</i> parameters are ignored for <b>SOCK_STREAM</b> sockets. </p>
<p>
For datagram sockets, data is extracted from the first enqueued datagram, up to the size of the buffer supplied. If the datagram is larger than the buffer supplied, the buffer is filled with the first part of the message, the excess data is lost, and <b>ReceiveFrom</b> returns a value of <b>SOCKET_ERROR</b> with the error code set to <b>WSAEMSGSIZE</b>. </p>
<p>
If <i>lpSockAddr</i> is nonzero, and the socket is of type <b>SOCK_DGRAM</b>, the network address of the socket which sent the data is copied to the corresponding <a href="_mfc_sockaddr_structure.htm">SOCKADDR</a> structure. The value pointed to by <i>lpSockAddrLen</i> is initialized to the size of this structure, and is modified on return to indicate the actual size of the address stored there. If no incoming data is available at the socket, the <b>ReceiveFrom</b> call waits for data to arrive unless the socket is nonblocking. In this case, a value of <b>SOCKET_ERROR</b> is returned with the error code set to <b>WSAEWOULDBLOCK</b>. The <b>OnReceive</b> callback can be used to determine when more data arrives. </p>
<p>
If the socket is of type <b>SOCK_STREAM</b> and the remote side has shut down the connection gracefully, a <b>ReceiveFrom</b> will complete immediately with 0 bytes received.</p>
<p>
<a href="_mfc_casyncsocket.htm">CAsyncSocket Overview</a>  |&nbsp; <a href="_mfc_casyncsocket_class_members.htm">Class Members</a>  |&nbsp; <a href="_mfc_hierarchy_chart.htm">Hierarchy Chart</a></p>
<p>
<b>See Also</b>&nbsp;&nbsp;&nbsp;<a href="_mfc_casyncsocket.3a3a.asyncselect.htm">CAsyncSocket::AsyncSelect</a>, <a href="_mfc_casyncsocket.3a3a.create.htm">CAsyncSocket::Create</a>, <a href="_mfc_casyncsocket.3a3a.receive.htm">CAsyncSocket::Receive</a>, <a href="_mfc_casyncsocket.3a3a.send.htm">CAsyncSocket::Send</a></p>
</font></BODY>
</HTML>
