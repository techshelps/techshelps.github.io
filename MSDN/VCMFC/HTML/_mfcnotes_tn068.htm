<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>TN068: Performing Transactions with the Microsoft Access 7 ODBC Driver</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY>
<font face="verdana,arial,helvetica" size="2">
<h1><a name="_mfcnotes_tn068"></a>TN068: Performing Transactions with the Microsoft Access 7 ODBC Driver</h1>
<p>
This note describes how to perform transactions when using the MFC ODBC database classes and the Microsoft Access 7.0 ODBC driver included in the Microsoft ODBC Desktop Driver Pack version 3.0.</p>
<p class=label>
<b>Overview</b></p>
<p>
If your database application performs transactions, you must be careful to call <b>CDatabase::BeginTrans</b> and <b>CRecordset::Open</b> in the correct sequence in your application. The Microsoft Access 7.0 driver uses the Microsoft Jet database engine, and Jet requires that your application not begin a transaction on any database that has an open cursor. For the MFC ODBC database classes, an open cursor equates to an open <b>CRecordset</b> object.</p>
<p>
If you open a recordset before calling <b>BeginTrans</b>, you may not see any error messages. However, any recordset updates your application makes become permanent after calling <b>CRecordset::Update</b>, and the updates will not be rolled back by calling <b>Rollback</b>. To avoid this problem, you must call <b>BeginTrans</b> first and then open the recordset.</p>
<p>
MFC checks the driver functionality for cursor commit and rollback behavior. Class <b>CDatabase</b> provides two member functions, <b>GetCursorCommitBehavior</b> and <b>GetCursorRollbackBehavior</b>, to determine the effect of any transaction on your open <b>CRecordset</b> object. For the Microsoft Access 7.0 ODBC driver, these member functions return <b>SQL_CB_CLOSE</b> because the Access driver does not support cursor preservation. Therefore, you must call <b>CRecordset::Requery</b> following a <b>CommitTrans</b> or <b>Rollback</b> operation.</p>
<p>
When you need to perform multiple transactions one after another, you cannot call <b>Requery</b> after the first transaction and then start the next one. You must close the recordset before the next call to <b>BeginTrans</b> in order to satisfy Jet’s requirement. This technical note describes two methods of handling this situation:
<ul type=disc>
<li>
Closing the recordset after each <b>CommitTrans</b> or <b>Rollback</b> operation.<br><br></li>
<li>
Using the ODBC API function <b>SQLFreeStmt</b>.</li>
</ul>
<p class=label>
<b>Closing the Recordset after each CommitTrans or Rollback Operation</b></p>
<p>
Before starting a transaction, make sure the recordset object is closed. After calling <b>BeginTrans</b>, call the recordset’s <b>Open</b> member function. Close the recordset immediately after calling <b>CommitTrans</b> or <b>Rollback</b>. Note that repeatedly opening and closing the recordset can slow an application’s performance.</p>
<p class=label>
<b>Using SQLFreeStmt</b></p>
<p>
You can also use the ODBC API function <b>SQLFreeStmt</b> to explicitly close the cursor after ending a transaction. To start another transaction, call <b>BeginTrans</b> followed by <b>CRecordset::Requery</b>. When calling <b>SQLFreeStmt</b>, you must specify the recordset’s HSTMT as the first parameter and <b>SQL_CLOSE</b> as the second parameter. This method is faster than closing and opening the recordset at the start of every transaction. The following code demonstrates how to implement this technique:</p>
<pre><code>CMyDatabase db;
db.Open( "MYDATASOURCE" );
CMyRecordset rs( &amp;db );

// start transaction 1 and 
// open the recordset
db.BeginTrans( );
rs.Open( );

// manipulate data

// end transaction 1
db.CommitTrans( );&nbsp; // or Rollback( )

// close the cursor
::SQLFreeStmt( rs.m_hstmt, SQL_CLOSE );

// start transaction 2
db.BeginTrans( );

// now get the result set
rs.Requery( );

// manipulate data

// end transaction 2
db.CommitTrans( );

rs.Close( );
db.Close( );
</code></pre>
<p>
Another way to implement this technique is to write a new function, <b>RequeryWithBeginTrans</b>, which you can call to start the next transaction after you commit or rollback the first one. To write such a function, do the following steps:
<ol>
<li>
Copy the code for <b>CRecordset::Requery( )</b> to the new function.<br><br></li>
<li>
Add the following line immediately after the call to <b>SQLFreeStmt</b>:<br>
<code>m_pDatabase-&gt;BeginTrans( );</code></li>
</ol>
<p>
Now you can call this function between each pair of transactions:</p>
<pre><code>// start transaction 1 and 
// open the recordset
db.BeginTrans( );
rs.Open( );

// manipulate data

// end transaction 1
db.CommitTrans( );&nbsp; // or Rollback( )

// close the cursor, start new transaction,
// and get the result set
rs.RequeryWithBeginTrans( );

// manipulate data

// end transaction 2
db.CommitTrans( );&nbsp; // or Rollback( )
</code></pre>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;Do not use this technique if you need to change the recordset member variables <b>m_strFilter</b> or <b>m_strSort</b> between transactions. In that case, you should close the recordset after each <b>CommitTrans</b> or <b>Rollback</b> operation.</p>
<p>
<a href="_mfcnotes_technical_notes_by_number.htm">Technical Notes by Number</a>  |&nbsp; <a href="_mfcnotes_technical_notes_by_category.htm">Technical Notes by Category</a></p>
</font></BODY>
</HTML>
