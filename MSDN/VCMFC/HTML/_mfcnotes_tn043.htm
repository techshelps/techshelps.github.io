<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>TN043: RFX Routines</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY>
<font face="verdana,arial,helvetica" size="2">
<h1><a name="_mfcnotes_tn043"></a><sup></sup>TN043: RFX Routines</h1>
<p>
This note describes the record field exchange (RFX) architecture. It also describes how you write an <b>RFX_</b> procedure.</p>
<p class=label>
<b>Overview of Record Field Exchange</b></p>
<p>
All recordset field functions are done with C++ code. There are no special resources or magic macros. The heart of the mechanism is a virtual function that must be overridden in every derived recordset class. It is always found in this form:</p>
<pre><code>void CMySet::DoFieldExchange(CFieldExchange* pFX)
{
  //{{AFX_FIELD_MAP(CMySet)
  &lt;recordset exchange field type call&gt;
  &lt;recordset exchange function call&gt;
  //}}AFX_FIELD_MAP
}
</code></pre>
<p>
The special format AFX comments allow ClassWizard to locate and edit the code within this function. Code that is not compatible with ClassWizard should be placed outside of the special format comments.</p>
<p>
In the above example, &lt;recordset_exchange_field_type_call&gt; is in the form:</p>
<pre><code>pFX-&gt;SetFieldType(CFieldExchange::outputColumn);
</code></pre>
<p>
and &lt;recordset_exchange_function_call&gt; is in the form:</p>
<pre><code>RFX_Custom(pFX, "Col2", m_Col2);
</code></pre>
<p>
Most <b>RFX_</b> functions have three arguments as shown above, but some (e.g. <b>RFX_Text</b> and <b>RFX_Binary</b>) have additional optional arguments.</p>
<p>
More than one <b>RFX_</b> may be included in each <b>DoDataExchange</b> function. </p>
<p>
See 'afxdb.h' for a list of all the recordset field exchange routines provided with MFC.</p>
<p>
Recordset field calls are a way of registering memory locations (usually data members) to store field data for a <b>CMySet</b> class.</p>
<p class=label>
<b>Notes</b></p>
<p>
Recordset field functions are designed to work only with the <b>CRecordset</b> classes. They are not generally usable by any other MFC classes.</p>
<p>
Initial values of data are set in the standard C++ constructor, usually in a block with <code>//{{AFX_FIELD_INIT(CMylSet)</code> and <code>//}}AFX_FIELD_INIT</code> comments.</p>
<p>
Each <b>RFX_</b> function must support various operations, ranging from returning the dirty status of the field to archiving the field in preparation for editing the field.</p>
<p>
Each function which calls <b>DoFieldExchange</b> (for instance <b>SetFieldNull</b>, <b>IsFieldDirty</b>), does its own initialization around the call to <b>DoFieldExchange</b>.</p>
<p class=label>
<b>How Does It Work?</b></p>
<p>
You do not need to understand the following in order to use record field exchange. However, understanding how this works behind the scenes will help you write your own exchange procedure.</p>
<p>
The <b>DoFieldExchange</b> member function is much like the <b>Serialize</b> member function - it is responsible for getting or setting data to/from an external form (in this case columns from the result of an ODBC query) from/to member data in the class. The <i>pFX</i> parameter is the context for doing data exchange and is similar to the <b>CArchive</b> parameter to <b>CObject::Serialize</b>. The <i>pFX</i> (a <b>CFieldExchange</b> object) has an operation indicator, which is similar to, but a generalization of the <b>CArchive</b> direction flag. An RFX function may have to support the following operations:
<ul type=disc>
<li>
<b>BindParam</b> -- Indicate where ODBC should retrieve parameter data<br><br></li>
<li>
<b>BindFieldToColumn</b> -- Indicate where ODBC must retrieve/deposit outputColumn data<br><br></li>
<li>
<b>Fixup</b> -- Set <b>CString/CByteArray</b> lengths, set NULL status bit<br><br></li>
<li>
<b>MarkForAddNew</b> -- Mark dirty if value has changed since AddNew call<br><br></li>
<li>
<b>MarkForUpdate</b> -- Mark dirty if value has changed since Edit call<br><br></li>
<li>
<b>Name</b> -- Append field names for fields marked dirty<br><br></li>
<li>
<b>NameValue</b> -- Append "&lt;column name&gt;=?" for fields marked dirty<br><br></li>
<li>
<b>Value</b> -- Append "?" followed by separator, like ',' or ' '<br><br></li>
<li>
<b>SetFieldDirty</b> -- Set status bit dirty (i.e. changed) field<br><br></li>
<li>
<b>SetFieldNull</b> -- Set status bit indicating null value for field<br><br></li>
<li>
<b>IsFieldDirty</b> -- Return value of dirty status bit<br><br></li>
<li>
<b>IsFieldNull</b> -- Return value of null status bit<br><br></li>
<li>
<b>IsFieldNullable</b> -- Return TRUE if field can hold NULL values<br><br></li>
<li>
<b>StoreField</b> -- Archive field value <br><br></li>
<li>
<b>LoadField</b> -- Reload archived field value<br><br></li>
<li>
<b>GetFieldInfoValue</b> -- Return general information on a field<br><br></li>
<li>
<b>GetFieldInfoOrdinal</b> -- Return general information on a field</li>
</ul>
<p class=label>
<b>User Extensions</b></p>
<p>
There are several ways to extend the default RFX mechanism. You can
<ul type=disc>
<li>
Add new data types. For example:<pre><code>CBookmark
</code></pre>
</li>
<li>
Add new exchange procedures (RFX_???).<pre><code>void AFXAPI RFX_Bigint(CFieldExchange* pFX, const char *szName,
 &nbsp;&nbsp; BIGINT&amp; value);
</code></pre>
</li>
<li>
Have the <b>DoFieldExchange</b> member function conditionally include additional RFX calls or any other valid C++ statements.<pre><code>while (posExtraFields != NULL)
{
 &nbsp;&nbsp; RFX_Text(pFX, m_listName.GetNext(posExtraFields), 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_listValue.GetNext(posExtraValues));
}
</code></pre>
</li>
</ul>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;Such code cannot be edited by ClassWizard and should be used only outside of the special format comments.</p>
<p class=label>
<b>Writing a Custom RFX</b></p>
<p>
To write your own Custom RFX function, it is suggested that you copy an existing RFX function and modify it to your own purposes. Selecting the right RFX to copy can make your job much easier. Some RFX functions have some unique properties that you should take into account when deciding which to copy.</p>
<p class=dt>
<b>RFX_Long and RFX_Int</b>:</p>
<p class=indent>
These are the simplest RFX functions. The data value doesn't need any special interpretation, and the data size is fixed.</p>
<p class=dt>
<b>RFX_Single and RFX_Double</b>:</p>
<p class=indent>
Like RFX_Long and RFX_Int above, these functions are simple and can make use of the default implementation extensively. They are stored in dbflt.cpp instead of dbrfx.cpp, however, to enable loading the runtime floating point library only when they are explicitly reference.</p>
<p class=dt>
<b>RFX_Text and RFX_Binary</b>:</p>
<p class=indent>
These two functions preallocate a static buffer to hold string/binary information, and must register these buffers with ODBC SQLBindCol instead of registering &amp;value. Because of this, these two functions have lots of special-case code.</p>
<p class=dt>
<b>RFX_Date</b>:</p>
<p class=indent>
ODBC returns date and time information in their own TIMESTAMP_STRUCT data structure. This function dynamically allocates a TIMESTAMP_STRUCT as a "proxy" for sending and receiving date time data. Various operations must transfer the date and time information between the C++ <b>CTime</b> object and the TIMESTAMP_STRUCT proxy. Needless to say, this complicates this function considerably, but it is a good example of how to use a proxy for data transfer.</p>
<p class=dt>
<b>RFX_LongBinary</b>:</p>
<p class=indent>
This is the only class library RFX function that does not use column binding to receive and send data. This function ignores the BindFieldToColumn operation and instead, during the Fixup operation, allocates storage to hold the incoming SQL_LONGVARCHAR or SQL_LONGVARBINARY data, then performs an SQLGetData call to retrieve the value into the allocated storage. When preparing to send data values back to the data source (i.e. NameValue and Value operations), this function uses ODBC's DATA_AT_EXEC functionality. See <a href="_mfcnotes_tn045.htm">Technical Note 45</a> for more information on working with SQL_LONGVARBINARY and SQL_LONGVARCHARs.</p>
<p>
When writing your own <b>RFX_</b> function, you will often be able to use <b>CFieldExchange::Default</b> to implement a given operation. Look at the implementation of Default for the operation in question. If it performs the operation you would be writing in your <b>RFX_</b> function you can delegate to the <b>CFieldExchange::Default.</b> You can see examples of calling <b>CFieldExchange::Default</b> in dbrfx.cpp</p>
<p>
It is important to call <b>IsFieldType</b> at the start of your RFX function, and return immediately if it returns FALSE. This mechanism keeps parameter operations from being performed on <b>outputColumns</b>, and vice versa (like calling <b>BindParam</b> on an <b>outputColumn</b>). In addition, <b>IsFieldType</b> automatically keeps track of the count of <b>outputColumns</b> (<b>m_nFields</b>) and params (<b>m_nParams</b>).</p>
<p>
<a href="_mfcnotes_technical_notes_by_number.htm">Technical Notes by Number</a>  |&nbsp; <a href="_mfcnotes_technical_notes_by_category.htm">Technical Notes by Category</a></p>
</font></BODY>
</HTML>
