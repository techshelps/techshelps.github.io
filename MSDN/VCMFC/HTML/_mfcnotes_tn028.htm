<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>TN028: Context-Sensitive Help Support</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY>
<font face="verdana,arial,helvetica" size="2">
<h1><a name="_mfcnotes_tn028"></a><sup></sup>TN028: Context-Sensitive Help Support</h1>
<p>
This note describes the rules for assigning Help contexts IDs (that is, topic numbers) and other help issues in MFC 2.0. Context sensitive help support requires the help compiler which is available in Visual C++ Professional.</p>
<p class=label>
<b>Types of Help Supported</b></p>
<p>
There are two types of context-sensitive help implemented in Windows applications. The first, referred to as “F1 Help” involves launching WinHelp with the appropriate context based on the currently active object. The second is SHIFT+F1 mode. In this mode, the mouse cursor changes to the help cursor (a combination arrow + question mark), and the user proceeds to click on the object they'd like help on. At that point, WinHelp is launched giving help for the object on which the user clicked.</p>
<p>
The Microsoft Foundation classes implement both of these forms of help. In addition, the framework supports two simple help commands, Help Index and Using Help.</p>
<p class=label>
<b>Help Files</b></p>
<p>
The Microsoft Foundation classes assume a single Help file. That Help file must have the same name and path as the application (.EXE -&gt; .HLP).</p>
<p>
This is a public <b>CWinApp</b> member variable named <b>m_pszHelpFilePath</b> that the user can change if desired.</p>
<p class=label>
<b>Help Context Ranges</b></p>
<p>
0x00000000 - 0x0000FFFF : user defined</p>
<p>
0x00010000 - 0x0001FFFF : commands (menus/command buttons)</p>
<p>
&nbsp;&nbsp;&nbsp;0x00010000 + ID_</p>
<p>
&nbsp;&nbsp;&nbsp;(note: 0x18000-&gt; 0x1FFFF is practical range since command IDs are &gt;=0x8000)</p>
<p>
0x00020000 - 0x0002FFFF : windows and dialogs</p>
<p>
&nbsp;&nbsp;&nbsp;0x00020000 + IDR_</p>
<p>
&nbsp;&nbsp;&nbsp;(note: 0x20000-&gt; 0x27FFF is practical range since IDRs are &lt;= 0x7FFF)</p>
<p>
0x00030000 - 0x0003FFFF : error messages (based on error string ID)</p>
<p>
&nbsp;&nbsp;&nbsp;0x00030000 + IDP_</p>
<p>
0x00040000 - 0x0004FFFF : special purpose (non-client areas)</p>
<p>
&nbsp;&nbsp;&nbsp;0x00040000 + HitTest area</p>
<p>
0x00050000 - 0x0005FFFF : controls (those that are not commands)</p>
<p>
&nbsp;&nbsp;&nbsp;0x00040000 + IDW_</p>
<p>
These rules are hard-coded into the default implementation of the Microsoft Foundation classes. They can be overridden by providing different implementations of the various Help-related member functions.</p>
<p class=label>
<b>Simple “Help” Commands</b></p>
<p>
There are two simple Help commands that are implemented by the Microsoft Foundation classes:
<ul type=disc>
<li>
ID_HELP_INDEX which is implemented by <b>CWinApp::OnHelpIndex</b><br><br></li>
<li>
ID_HELP_USING which is implemented by <b>CWinApp::OnHelpUsing</b></li>
</ul>
<p>
These two commands simply show the Help index for the application and show the user help on using the WinHelp program, respectively.</p>
<p class=label>
<b>Context-Sensitive Help (F1 Help)</b></p>
<p>
This is the first form of context-sensitive Help (usually referred to as F1 Help). The user presses F1 to get help on the task at hand (the active window or menu item). No special “help mode” is involved.</p>
<p>
The F1 key is usually translated to a command with an ID of <b>ID_HELP</b> by an accelerator placed into the main window's accelerator table. The <b>ID_HELP</b> command may also be generated by a button with an ID of <b>ID_HELP</b> on the main window or dialog box. Also, when a menu or a dialog box is active and the user presses F1, the keystroke is hard-coded to translate into an <b>ID_HELP</b> command.</p>
<p>
However the <b>ID_HELP</b> command is generated, it is routed as a normal command until it reaches a command handler (for more information on the Microsoft Foundation classes command-routing architecture, refer to <a href="_mfcnotes_tn021.htm">Technical Note 21</a>.) If the application is Help enabled, the <b>ID_HELP</b> command will be handled by the <b>CWinApp::OnHelp</b> function. Since the default command routing is not adequate for determining the most specific context the command is instead always routed to the application object and then undergoes custom routing for Help.</p>
<p>
<b>CWinApp::OnHelp</b> attempts to launch WinHelp in the following order:
<ol>
<li>
Checks for an active <b>AfxMessageBox</b> call with a Help ID. If a message box is currently active, WinHelp is launched with the context appropriate to that message box.<br><br></li>
<li>
If no message box is active, <b>CWinApp::OnHelp</b> sends a <b>WM_COMMANDHELP</b> (a message private to the Microsoft Foundation classes) to the active window. If that window does not respond by launching WinHelp, the same message is then sent to the parent of that window, until the message is processed or the current window is a top-level window (and therefore does not have a parent window).<br><br></li>
<li>
If the message remains unprocessed, then the default Help is invoked. This is done by sending a <b>ID_DEFAULT_HELP</b> command to the main window. This command is generally mapped to <b>CWinApp::OnHelpIndex</b>.</li>
</ol>
<p>
To globally override the ID base values (0x10000 for commands, 0x20000 for resources such as dialogs, and so on), the application should override <b>CWinApp::WinHelp</b>. This is in fact done in the implementation of the ClassWizard and AppWizard applications themselves, for example, since both share a single Help file.</p>
<p>
To override this functionality and the way that a Help context is determined, an application should handle the <b>WM_COMMANDHELP</b> message (see below). You may wish to provide more specific Help routing than the framework provides, as it only goes as deep as the current MDI child window. Or you may wish to provide more specific help for a particular window or dialog -- perhaps based on the current internal state of that object or the active control within the dialog.</p>
<p class=label>
<b>WM_COMMANDHELP</b></p>
<p>
<b>afx_msg</b> <b>LRESULT</b> <b>CWnd::OnCommandHelp(</b><i>WPARAM</i>, <i>LPARAM</i> <i>lParam</i><b>)</b></p>
<p>
WM_COMMANDHELP is an MFC private Windows message that is received by the active window when Help is requested. When the window receives this message, it may call <b>CWinApp::WinHelp</b> with context that matches the window's internal state. </p>
<p class=dt>
<i>lParam</i></p>
<p class=indent>
contains the currently available Help context. lParam is zero if no Help context has been determined yet. An implementation of <b>OnCommandHelp</b> can use the context ID in lParam to determine a “better” context or can just pass it to <b>CWinApp::WinHelp</b>.</p>
<p class=dt>
<i>wParam</i></p>
<p class=indent>
is not used and will be zero.</p>
<p>
If the <b>OnCommandHelp</b> function calls <b>CWinApp::WinHelp</b>, it should return TRUE. Returning TRUE stops the routing of this command to other classes (base classes) and to other windows.</p>
<p class=label>
<b>Help Mode (Shift+F1 Help)</b></p>
<p>
This is the second form of context-sensitive Help. Generally, this mode is entered by pressing SHIFT+F1 or via the menu/toolbar. It is implemented as a command (<b>ID_CONTEXT_HELP</b>). The message filter hook is not used to translate this command while a modal dialog box or menu is active, therefore this command is only available to the user when the application is executing the main message pump (<b>CWinApp::Run</b>).</p>
<p>
After entering this mode, the Help mouse cursor is displayed over all areas of the application, even if the application would normally display it's own cursor for that area (such as the sizing border around the window). The user is able to use the mouse or keyboard to select a command. Instead of executing the command, Help on that command is displayed. Also the user can click a visible object on the screen, such as a button on the toolbar, and Help will be displayed for that object. This mode of Help is provided by <b>CWinApp::OnContextHelp</b>.</p>
<p>
During the execution of this loop, all keyboard input is inactive, except for keys that access the menu. Also, command translation is still performed via <b>PreTranslateMessage</b> to allow the user to press an accelerator key and receive help on that command. </p>
<p>
If there are particular translations or actions taking place in the <b>PreTranslateMessage</b> function that shouldn't take place during SHIFT+F1 Help mode, you should check the <b>m_bHelpMode</b> member of <b>CWinApp</b> before performing those operations. The <b>CDialog</b> implementation of <b>PreTranslateMessage</b> checks this before calling <b>IsDialogMessage</b>, for example. This disables “dialog navigation” keys on modeless dialogs during SHIFT+F1 mode. In addition, <b>CWinApp::OnIdle</b> is still called during this loop.</p>
<p>
If the user chooses a command from the menu, it is handled as help on that command (through <b>WM_COMMANDHELP</b>, see below). If the user clicks a visible area of the applications window, a determination is made as to whether it is a nonclient click or a client click. <b>OnContextHelp</b> handles mapping of nonclient clicks to client clicks automatically. If it is a client click, it then sends a <b>WM_HELPHITTEST</b> to the window that was clicked. If that window returns a nonzero value, that value is used as the context for help. If it returns zero, <b>OnContextHelp</b> tries the parent window (and failing that, its parent, and so on). If a Help context cannot be determined, the default is to send a <b>ID_DEFAULT_HELP</b> command to the main window, which is then (usually) mapped to <b>CWinApp::OnHelpIndex</b>.</p>
<p class=label>
<b>WM_HELPHITTEST</b></p>
<p>
<b>afx_msg LRESULT CWnd::OnHelpHitTest(</b><i>WPARAM</i>, <i>LPARAM lParam</i><b>)</b></p>
<p>
<b>WM_HELPHITTEST</b> is an MFC private windows message, that is received by the active window clicked during SHIFT+F1 Help mode. When the Window receives this message, it returns a DWORD Help ID for use by WinHelp.</p>
<p class=dt>
LOWORD(lParam)</p>
<p class=indent>
contains the X-axis device coordinate where the mouse was clicked relative to the client area of the window. </p>
<p class=dt>
HIWORD(lParam)</p>
<p class=indent>
contains the Y-axis coordinate. </p>
<p class=dt>
<i>wParam</i></p>
<p class=indent>
is not used and will be zero. If the return value is nonzero, WinHelp is called with that context. If the return value is zero, the parent window is queried for help.</p>
<p>
In many cases, you can leverage hit-testing code you may already have. See the implementation of <b>CToolBar::OnHelpHitTest</b> for an example of handling the <b>WM_HELPHITTEST</b> message (the code leverages the hit-test code used on buttons and tooltips in <b>CControlBar</b>).</p>
<p class=label>
<b>MFC AppWizard Support and MAKEHM</b></p>
<p>
AppWizard creates the necessary files to build a Help file (.cnt and .hpj files). It also includes a number of prebuilt .RTF files that are accepted by the Microsoft Help Compiler. Many of the topics are complete, but some may need to be modified for your specific application. </p>
<p>
Automatic creation of a “help mapping” file is supported by a utility called MAKEHM. The MAKEHM utility can translate an application's RESOURCE.H file to a Help mapping file. For example:</p>
<pre><code>#define IDD_MY_DIALOG&nbsp;&nbsp; 2000
#define ID_MY_COMMAND&nbsp;&nbsp; 150
</code></pre>
<p>
will be translated into:</p>
<pre><code>HIDD_MY_DIALOG&nbsp;&nbsp;&nbsp; 0x207d0
HID_MY_COMMAND&nbsp;&nbsp;&nbsp; 0x10096
</code></pre>
<p>
This format is compatible with the Help compiler's facility, which maps context IDs (the numbers on the right side) with topic names (the symbols on the left side).</p>
<p>
The source code for MAKEHM is available in the MFC Programming Utilties sample <object id=alink_1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="DefaultTopic" value="_topic_not_found.htm">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="_sample_mfc_MAKEHM">
</object><a href=JavaScript:alink_1.Click()>MAKEHM</a>.</p>
<p class=label>
<b>Adding Help Support After Running AppWizard</b></p>
<p>
The best way to add Help to your application is to check the “Context Sensitive Help” option in AppWizard's Options dialog before creating your application. That way AppWizard automatically adds the necessary message map entries to your CWinApp-derived class to support Help.</p>
<p>
If you have already created your application without Help support and now wish to add it, see <i>Visual C++ Programmer's Guide</i>.</p>
<p class=label>
<b>Help on Message Boxes</b></p>
<p>
Help on Message Boxes (sometimes called alerts) is supported through the <b>AfxMessageBox</b> function, a wrapper for the <b>MessageBox</b> Windows API.</p>
<p>
There are two versions of <b>AfxMessageBox</b>, one for use with a string ID and another for use with a pointer to string (<b>LPCSTR</b>):</p>
<pre><code>int AFXAPI AfxMessageBox(LPCSTR lpszText, UINT nType, UINT nIDHelp);
int AFXAPI AfxMessageBox(UINT nIDPrompt, UINT nType, UINT nIDHelp);
</code></pre>
<p>
In both cases, there is an optional Help ID.</p>
<p>
In the first case, the default for nIDHelp is 0, which indicates no Help for this message box. If the user presses F1 while such as message box is active, the user will not receive Help (even if the application supports Help). If this is not desirable, a Help ID should be provided for nIDHelp.</p>
<p>
In the second case, the default value for nIDHelp is -1, which indicates the Help ID is the same as nIDPrompt. Help will work only if the application is Help-enabled, of course). You should provide 0 for nIDHelp if you wish that the message box have no help support. Should you want the message to be Help enabled, but desire a different help ID than nIDPrompt, simply provide a positive value for nIDHelp different from that of nIDPrompt.</p>
<p>
<a href="_mfcnotes_technical_notes_by_number.htm">Technical Notes by Number</a>  |&nbsp; <a href="_mfcnotes_technical_notes_by_category.htm">Technical Notes by Category</a></p>
</font></BODY>
</HTML>
