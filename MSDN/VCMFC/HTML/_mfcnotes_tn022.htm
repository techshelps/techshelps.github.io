<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>TN022: Standard Commands Implementation</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY>
<font face="verdana,arial,helvetica" size="2">
<h1><a name="_mfcnotes_tn022"></a><sup></sup>TN022: Standard Commands Implementation</h1>
<p>
This note describes the standard command implementations provided by MFC 2.0. Please be sure to read <a href="_mfcnotes_tn021.htm">Technical Note 21</a> first since that describes the mechanisms used to implement many of the standard commands.</p>
<p>
This description assumes knowledge of the MFC architectures, APIs, and common programming practice. Documented as well as undocumented "implementation only" APIs are described. This is not a place to start to learn about the features of or how to program in MFC. Please refer to the <i>Visual C++ Programmer's Guide</i> for more general information and for details of documented APIs.</p>
<p class=label>
<b>The Problem</b></p>
<p>
MFC defines many standard command IDs in the header file AFXRES.H. Framework support for these commands varies. Understanding where and how the framework classes handle these commands will not only show you how the framework works internally but will provide useful information on how to customize the standard implementations and hopefully teach you a few techniques for implementing your own command handlers.</p>
<p class=label>
<b>Contents of This Technical Note</b></p>
<p>
Each command ID is described in two sections:
<ul type=disc>
<li>
The title: the symbolic name of the command ID (for example, <b>ID_FILE_SAVE</b>) followed by the purpose of the command (for example, "saves the current document") separated by a colon.<br><br></li>
<li>
One or more paragraphs describing which classes implement the command, and what the default implementation does</li>
</ul>
<p>
Most default command implementations are prewired in the framework's base class message map. There are some command implementations which require explicit wiring in your derived class. These are described under "Note". If you chose the right options in AppWizard, these default handlers will be connected for you in the generated skeleton application.</p>
<p class=label>
<b>Naming Convention</b></p>
<p>
Standard commands follow a simple naming convention that we recommend you use if possible. Most standard commands are located in standard places in an application's menu bar. The symbolic name of the command starts with "ID_" followed by the standard popup menu name, followed by the menu item name. The symbolic name is in upper case with underscore word-breaks. For commands that do not have standard menu item names, a logical command name is defined starting with "ID_" (for example, <b>ID_NEXT_PANE</b>).</p>
<p>
We use the prefix "ID_" to indicate commands that are designed to be bound to menu items, toolbar buttons, or other command user-interface objects. Command handlers handling "ID_" commands should use the <b>ON_COMMAND</b> and <b>ON_UPDATE_COMMAND_UI</b> mechanisms of the MFC command architecture.</p>
<p>
We recommend you use the standard "IDM_" prefix for menu items which do not follow the command architecture and need menu-specific code to enable and disable them. Of course the number of menu specific commands should be small since following the MFC command architecture not only makes command handlers more powerful (since they will work with toolbars) but makes the command handler code reusable.</p>
<p class=label>
<b>ID Ranges</b></p>
<p>
Please refer to <a href="_mfcnotes_tn020.htm">Technical Note 20</a> for more details on the use of ID ranges in MFC.</p>
<p>
MFC standard commands fall in the range 0xE000 to 0xEFFF. Please do not rely on the specific values of these IDs since they are subject to change in future versions of the library.</p>
<p>
Your application should define its commands in the range 0x8000 to 0xDFFF.</p>
<p class=label>
<b>Standard Command IDs</b></p>
<p>
For each command ID, there is a standard message line prompt string that can be found in the file PROMPTS.RC. The string ID for that menu prompt must be the same as for the command ID.
<ul type=disc>
<li>
ID_FILE_NEW:&nbsp;&nbsp;&nbsp;Creates a new/empty document.<p class=atl>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;You must connect this to your <b>CWinApp</b>-derived class's message map to enable this functionality.</p><p class=tl>
<b>CWinApp::OnFileNew</b> implements this command differently depending on the number of document templates in the application. If there is only one <b>CDocTemplate</b>, <b>CWinApp::OnFileNew</b> will create a new document of that type, as well as the proper frame and view class.</P><p class=tl>
If there is more than one <b>CDocTemplate</b>, <b>CWinApp::OnFileNew</b> will prompt the user with a dialog (<b>AFX_IDD_NEWTYPEDLG</b>) letting them select which document type to use. The selected <b>CDocTemplate</b> is used to create the document.</P><p class=tl>
One common customization of <b>ID_FILE_NEW</b> is to provide a different and more graphical choice of document types. In this case you can implement your own <b>CMyApp::OnFileNew</b> and place it in your message map instead of <b>CWinApp::OnFileNew</b>. There is no need to call the base class implementation.</P><p class=tl>
Another common customization of <b>ID_FILE_NEW</b> is to provide a separate command for creating a document of each type. In this case you should define new command IDs, for example ID_FILE_NEW_CHART and ID_FILE_NEW_SHEET.</P></li>
<li>
ID_FILE_OPEN:&nbsp;&nbsp;&nbsp;Opens an existing document.<p class=atl>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;You must connect this to your <b>CWinApp</b>-derived class's message map to enable this functionality.</p><p class=tl>
<b>CWinApp::OnFileOpen</b> has a very simple implementation of calling <b>CWinApp::DoPromptFileName</b> followed by <b>CWinApp::OpenDocumentFile</b> with the file or path name of the file to open. The <b>CWinApp</b> implementation routine <b>DoPromptFileName</b> brings up the standard FileOpen dialog and fills it with the file extensions obtained from the current document templates.</P><p class=tl>
One common customization of <b>ID_FILE_OPEN</b> is to customize the FileOpen dialog or add additional file filters. The recommended way to customize this is to replace the default implementation with your own FileOpen dialog, and call <b>CWinApp::OpenDocumentFile</b> with the document's file or path name. There is no need to call the base class.</P></li>
<li>
ID_FILE_CLOSE:&nbsp;&nbsp;&nbsp;Closes the currently open document.<p class=tl>
<b>CDocument::OnFileClose</b> calls <b>CDocument::SaveModified</b> to prompt the user to save the document if it has been modified and then calls <b>OnCloseDocument</b>. All the closing logic, including destroying the document, is done in the <b>OnCloseDocument</b> routine.</P><p class=atl>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;<b>ID_FILE_CLOSE</b> acts differently from a <b>WM_CLOSE</b> message or an <b>SC_CLOSE</b> system command sent to the documents frame window. Closing a window will close the document only if that is the last frame window showing the document. Closing the document with <b>ID_FILE_CLOSE</b> will not only close the document but will close down all frame windows showing the document.</p></li>
<li>
ID_FILE_SAVE:&nbsp;&nbsp;&nbsp;Saves the current document.<p class=tl>
The implementation uses a helper routine <b>CDocument::DoSave</b> which is used for both <b>OnFileSave</b> and <b>OnFileSaveAs</b>. If you save a document that has not been saved before (that is, it does not have a path name, as in the case of FileNew) or that was read from a read-only document, the <b>OnFileSave</b> logic will act like the <b>ID_FILE_SAVE_AS</b> command and ask the user to provide a new file name. The actual process of opening the file and doing the saving is done through the virtual function <b>OnSaveDocument</b>.</P><p class=tl>
There are two common reasons to customize <b>ID_FILE_SAVE</b>. For documents that do not save, simply remove the <b>ID_FILE_SAVE</b> menu items and toolbar buttons from your user interface. Also make sure that you never dirty your document (that is, never call <b>CDocument::SetModifiedFlag</b>) and the framework will never cause the document to be saved. For documents that save to someplace other than a disk file, define a new command for that operation. </P><p class=tl>
In the case of a <b>COleServerDoc</b>, <b>ID_FILE_SAVE</b> is used both for file save (for normal documents) and file update (for embedded documents).</P><p class=tl>
If your document data is stored in individual disk files, but you don't want to use the default <b>CDocument</b> serialize implementation, you should override <b>CDocument::OnSaveDocument</b> instead of <b>OnFileSave</b>.</P></li>
<li>
ID_FILE_SAVE_AS:&nbsp;&nbsp;&nbsp;Saves the current document under a different file name.<p class=tl>
The <b>CDocument::OnFileSaveAs</b> implementation uses the same <b>CDocument::DoSave</b> helper routine as <b>OnFileSave</b>. The <b>OnFileSaveAs</b> command is handled just as <b>ID_FILE_SAVE</b> if the documents had no file name before the save. <b>COleServerDoc::OnFileSaveAs</b> implements the logic to save a normal document data file or to save a server document representing an OLE object embedded in some other application as a separate file.</P><p class=tl>
If you customize the logic of <b>ID_FILE_SAVE</b>, you will probably want to customize <b>ID_FILE_SAVE_AS</b> in a similar fashion or the operation of "Save As" may not apply to your document. You can remove the menu item from your menu bar if it is not needed.</P></li>
<li>
ID_FILE_SAVE_COPY_AS:&nbsp;&nbsp;&nbsp;Saves a copy current document under a new name.<p class=tl>
The <b>COleServerDoc::OnFileSaveCopyAs</b> implementation is very similar to <b>CDocument::OnFileSaveAs</b>, except that the document object is not "attached" to the underlying file after the save. That is, if the in-memory document was "modified" before the save, it is still "modified". In addition, this command has no effect on the path name or title stored in the document.</P></li>
<li>
ID_FILE_UPDATE:&nbsp;&nbsp;&nbsp;Notifies the container to save an embedded document.<p class=tl>
The <b>COleServerDoc::OnUpdateDocument</b> implementation simply notifiies the container that the embedding should be saved. The container then calls the appropriate OLE APIs in order to save the embedded object.</P></li>
<li>
ID_FILE_PAGE_SETUP:&nbsp;&nbsp;&nbsp;Invokes an application-specific page setup/layout dialog.<p class=tl>
Currently there is no standard for this dialog, and the framework has no default implementation of this command.</P><p class=tl>
If you choose to implement this command, we recommend you use this command ID.</P></li>
<li>
ID_FILE_PRINT_SETUP:&nbsp;&nbsp;&nbsp;Invoke the standard Print Setup dialog.<p class=atl>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;You must connect this to your <b>CWinApp</b>-derived class's message map to enable this functionality.</p><p class=tl>
This command invokes the standard print setup dialog that allows the user to customize the printer and print settings for at least this document or at most all the documents in this application. You must use the Control Panel to change the default printer settings for the entire system.</P><p class=tl>
<b>CWinApp::OnFilePrintSetup</b> has a very simple implementation creating a <b>CPrintDialog</b> object and calling the <b>CWinApp::DoPrintDialog</b> implementation function. This sets the application default printer setup.</P><p class=tl>
The common need for customizing this command is to allow for per-document printer settings, which should be stored with the document when saved. To do this you should add a message-map handler in your <b>CDocument</b> class that creates a <b>CPrintDialog</b> object, initializes it with the appropriate printer attributes (usually <b>hDevMode</b> and <b>hDevNames</b>), call the <b>CPrintDialog::DoModal,</b> and save the changed printer settings. For a robust implementation, you should look at the implementation of <b>CWinApp::DoPrintDialog</b> for detecting errors and <b>CWinApp::UpdatePrinterSelection</b> for dealing with sensible defaults and tracking system-wide printer changes.</P></li>
<li>
ID_FILE_PRINT:&nbsp;&nbsp;&nbsp;Standard printing of the current document<p class=atl>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;You must connect this to your <b>CView</b>-derived class's message map to enable this functionality.</p><p class=tl>
This command prints the current document, or more correctly, starts the printing process, which involves invoking the standard print dialog and running the print engine.</P><p class=tl>
<b>CView::OnFilePrint</b> implements this command and the main print loop. It calls the virtual <b>CView::OnPreparePrinting</b> to prompt of the user with the print dialog. It then prepares the output DC to go to the printer, brings up the printing progress dialog (<b>AFX_IDD_PRINTDLG</b>), and sends the <b>StartDoc</b> escape to the printer. <b>CView::OnFilePrint</b> also contains the main page-oriented print loop. For each page, it calls the virtual <b>CView::OnPrepareDC</b> followed by a <b>StartPage</b> escape and calling the virtual <b>CView::OnPrint</b> for that page. When complete, the virtual <b>CView::OnEndPrinting</b> is called, and the printing progress dialog is closed.</P><p class=tl>
The MFC printing architecture is designed to hook in many different ways for printing and print preview. You will normally find the various <b>CView</b> overridable functions adequate for any page-oriented printing tasks. Only in the case of an application that uses the printer for non-page oriented output, should you find the need to replace the <b>ID_FILE_PRINT</b> implementation.</P></li>
<li>
ID_FILE_PRINT_PREVIEW:&nbsp;&nbsp;&nbsp;Enter print-preview mode for the current document.<p class=atl>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;You must connect this to your <b>CView</b>-derived class's message map to enable this functionality.</p><p class=tl>
<b>CView::OnFilePrintPreview</b> starts the print preview mode by calling the documented helper function <b>CView::DoPrintPreview</b>. <b>CView::DoPrintPreview</b> is the main engine for the print preview loop, just as <b>OnFilePrint</b> is the main engine for the printing loop.</P><p class=tl>
The print preview operation can be customized in a variety of ways by passing different parameters to <b>DoPrintPreview</b>. Please refer to <a href="_mfcnotes_tn030.htm">Technical Note 30</a>, which discusses some of the details of print preview and how to customize it.</P></li>
<li>
<b>ID_FILE_MRU_FILE1</b>...<b>FILE16</b> : a range of command IDs for the File MRU <i>list</i>. <p class=tl>
<b>CWinApp::OnUpdateRecentFileMenu</b> is a update command UI handler that is one of the more advanced uses of the <b>ON_UPDATE_COMMAND_UI</b> mechanism. In your menu resource, you need only define a single menu item with ID <b>ID_FILE_MRU_FILE1</b>. That menu item remains initially disabled.</P><p class=tl>
As the MRU list grows, more menu items are added to the list. The standard <b>CWinApp</b> implementation defaults to the standard limit of the four most recently used files. You can change the default by calling <b>CWinApp::LoadStdProfileSettings</b> with a larger or smaller value. The MRU list is stored in the application's .INI file. The list is loaded in your application's <b>InitInstance</b> function if you call <b>LoadStdProfileSettings</b>, and is saved when your application exits. The MRU update command UI handler also will convert absolute paths to relative paths for display on the file menu.</P><p class=tl>
<b>CWinApp::OnOpenRecentFile</b> is the <b>ON_COMMAND</b> handler that performs the actual command. It simply gets the file name from the MRU list and calls <b>CWinApp::OpenDocumentFile</b>, which does all the work of opening the file and updating the MRU list.</P><p class=tl>
Customization of this command handler is not recommended.</P></li>
<li>
ID_EDIT_CLEAR:&nbsp;&nbsp;&nbsp;Clears the current selection<p class=tl>
Currently there is no standard implementation for this command. You must implement this for each <b>CView</b>-derived class.</P><p class=tl>
<b>CEditView</b> provides an implementation of this command using <b>CEdit::Clear</b>. The command is disabled if there is no current selection.</P><p class=tl>
If you choose to implement this command, we recommend you use this command ID.</P></li>
<li>
ID_EDIT_CLEAR_ALL:&nbsp;&nbsp;&nbsp;Clears the entire document.<p class=tl>
Currently there is no standard implementation for this command. You must implement this for each <b>CView</b>-derived class.</P><p class=tl>
If you choose to implement this command, we recommend you use this command ID. See the MFC Tutorial sample <object id=alink_1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="DefaultTopic" value="_topic_not_found.htm">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="_sample_mfc_SCRIBBLE">
</object><a href=JavaScript:alink_1.Click()>SCRIBBLE</a> for an example implementation.</P></li>
<li>
ID_EDIT_COPY:&nbsp;&nbsp;&nbsp;Copies the current selection to the Clipboard.<p class=tl>
Currently there is no standard implementation for this command. You must implement this for each <b>CView</b>-derived class.</P><p class=tl>
<b>CEditView</b> provides an implementation of this command, which copies the currently selected text to the Clipboard as CF_TEXT using <b>CEdit::Copy</b>. The command is disabled if there is no current selection.</P><p class=tl>
If you choose to implement this command, we recommend you use this command ID.</P></li>
<li>
ID_EDIT_CUT:&nbsp;&nbsp;&nbsp;Cuts the current selection to the Clipboard.<p class=tl>
Currently there is no standard implementation for this command. You must implement this for each <b>CView</b>-derived class.</P><p class=tl>
<b>CEditView</b> provides an implementation of this command, which cuts the currently selected text to the Clipboard as CF_TEXT using <b>CEdit::Cut</b>. The command is disabled if there is no current selection.</P><p class=tl>
If you choose to implement this command, we recommend you use this command ID.</P></li>
<li>
ID_EDIT_FIND:&nbsp;&nbsp;&nbsp;Begin the find operation, bring up the modeless find dialog.<p class=tl>
Currently there is no standard implementation for this command. You must implement this for each <b>CView</b>-derived class.</P><p class=tl>
<b>CEditView</b> provides an implementation of this command, which calls the implementation helper function <b>OnEditFindReplace</b> to use and store the previous find/replace settings in private implementation variables. The <b>CFindReplaceDialog</b> class is used to manage the modeless dialog for prompting the user.</P><p class=tl>
If you choose to implement this command, we recommend you use this command ID.</P></li>
<li>
ID_EDIT_PASTE:&nbsp;&nbsp;&nbsp;Insert the current Clipboard contents.<p class=tl>
Currently there is no standard implementation for this command. You must implement this for each <b>CView</b>-derived class.</P><p class=tl>
<b>CEditView</b> provides an implementation of this command, which copies the current Clipboard data replacing the selected text using <b>CEdit::Paste</b>. The command is disabled if there is no <b>CF_TEXT</b> in the Clipboard.</P><p class=tl>
<b>COleClientDoc</b> just provides a update command UI handler for this command. If the Clipboard does not contain an embeddable OLE item/object, the command will be disabled. You are responsible for writing the handler for the actual command to do the actual pasting. If your OLE application can also paste other formats, you should provide your own update command UI handler in your view or document (that is, somewhere before <b>COleClientDoc</b> in the command target routing).</P><p class=tl>
If you choose to implement this command, we recommend you use this command ID.</P><p class=tl>
For replacing the standard OLE implementation, use <b>COleClientItem::CanPaste</b>.</P></li>
<li>
ID_EDIT_PASTE_LINK:&nbsp;&nbsp;&nbsp;Insert a link from the current Clipboard contents.<p class=tl>
Currently there is no standard implementation for this command. You must implement this for each <b>CView</b>-derived class.</P><p class=tl>
<b>COleDocument</b> just provides a update command UI handler for this command. If the Clipboard does not contain linkable OLE item/object, the command will be disabled. You are responsible for writing the handler for the actual command to do the actual pasting. If your OLE application can also paste other formats, you should provide your own update command UI handler in your view or document (that is, somewhere before <b>COleDocument</b> in the command target routing).</P><p class=tl>
If you choose to implement this command, we recommend you use this command ID.</P><p class=tl>
For replacing the standard OLE implementation, use <b>COleClientItem::CanPasteLink</b>.</P></li>
<li>
ID_EDIT_PASTE_SPECIAL:&nbsp;&nbsp;&nbsp;Insert the current Clipboard contents with options.<p class=tl>
Currently there is no standard implementation for this command. You must implement this for each <b>CView</b>-derived class. MFC does not provide this dialog.</P><p class=tl>
If you choose to implement this command, we recommend you use this command ID.</P></li>
<li>
ID_EDIT_REPEAT:&nbsp;&nbsp;&nbsp;Repeat the last operation.<p class=tl>
Currently there is no standard implementation for this command. You must implement this for each <b>CView</b>-derived class.</P><p class=tl>
<b>CEditView</b> provides an implementation of this command to repeat the last find operation. The private implementation variables for the last find are used. The command is disabled if a find can not be attempted.</P><p class=tl>
If you choose to implement this command, we recommend you use this command ID.</P></li>
<li>
ID_EDIT_REPLACE:&nbsp;&nbsp;&nbsp;Begin the replace operation, bring up the modeless replace dialog.<p class=tl>
Currently there is no standard implementation for this command. You must implement this for each <b>CView</b>-derived class.</P><p class=tl>
<b>CEditView</b> provides an implementation of this command, which calls the implementation helper function <b>OnEditFindReplace</b> to use and store the previous find/replace settings in private implementation variables. The <b>CFindReplaceDialog</b> class is used to manage the modeless dialog that prompts the user.</P><p class=tl>
If you choose to implement this command, we recommend you use this command ID.</P></li>
<li>
ID_EDIT_SELECT_ALL:&nbsp;&nbsp;&nbsp;Select the entire document.<p class=tl>
Currently there is no standard implementation for this command. You must implement this for each <b>CView</b>-derived class.</P><p class=tl>
<b>CEditView</b> provides an implementation of this command, which selects all the text in the document. The command is disabled if there is no text to select.</P><p class=tl>
If you choose to implement this command, we recommend you use this command ID.</P></li>
<li>
ID_EDIT_UNDO:&nbsp;&nbsp;&nbsp;Undo the last operation.<p class=tl>
Currently there is no standard implementation for this command. You must implement this for each <b>CView</b>-derived class.</P><p class=tl>
<b>CEditView</b> provides an implementation of this command, using <b>CEdit::Undo</b>. The command is disabled if <b>CEdit::CanUndo</b> returns FALSE.</P><p class=tl>
If you choose to implement this command, we recommend you use this command ID.</P></li>
<li>
ID_EDIT_REDO:&nbsp;&nbsp;&nbsp;Redo the last operation.<p class=tl>
Currently there is no standard implementation for this command. You must implement this for each <b>CView</b>-derived class.</P><p class=tl>
If you choose to implement this command, we recommend you use this command ID.</P></li>
<li>
ID_WINDOW_NEW:&nbsp;&nbsp;&nbsp;Open another window on the active document.<p class=tl>
<b>CMDIFrameWnd::OnWindowNew</b> implements this powerful feature by using the document template of the current document to create another frame containing another view of the current document.</P><p class=tl>
Like most multiple document interface (MDI) Window menu commands, the command is disabled if there is no active MDI child window.</P><p class=tl>
Customization of this command handler is not recommended. If you wish to provide a command that creates additional views or frame windows, you will probably be better off inventing your own command. You can clone the code from <b>CMDIFrameWnd::OnWindowNew</b> and modify it to the specific frame and view classes of your liking.</P></li>
<li>
ID_WINDOW_ARRANGE:&nbsp;&nbsp;&nbsp;Arrange icons at the bottom of an MDI window.<p class=tl>
<b>CMDIFrameWnd</b> implements this standard MDI command in an implementation helper function <b>OnMDIWindowCmd</b>. This helper maps command IDs to MDI Windows messages and can therefore share a lot of code.</P><p class=tl>
Like most MDI Window menu commands, the command is disabled if there is no active MDI child window.</P><p class=tl>
Customization of this command handler is not recommended.</P></li>
<li>
ID_WINDOW_CASCADE:&nbsp;&nbsp;&nbsp;Cascade windows so they overlap.<p class=tl>
<b>CMDIFrameWnd</b> implements this standard MDI command in an implementation helper function <b>OnMDIWindowCmd</b>. This helper maps command IDs to MDI Windows messages and can therefore share a lot of code.</P><p class=tl>
Like most MDI Window menu commands, the command is disabled if there is no active MDI child window.</P><p class=tl>
Customization of this command handler is not recommended.</P></li>
<li>
ID_WINDOW_TILE_HORZ:&nbsp;&nbsp;&nbsp;Tile windows horizontally.<p class=tl>
This command is implemented in <b>CMDIFrameWnd</b> just like <b>ID_WINDOW_CASCADE</b>, except a different MDI Windows message is used for the operation.</P><p class=tl>
You should pick the default tile orientation for your application. You can do this by changing the ID for the Window "Tile" menu item to either <b>ID_WINDOW_TILE_HORZ</b> or <b>ID_WINDOW_TILE_VERT</b>.</P></li>
<li>
ID_WINDOW_TILE_VERT:&nbsp;&nbsp;&nbsp;Tile windows vertically.<p class=tl>
This command is implemented in <b>CMDIFrameWnd</b> just like <b>ID_WINDOW_CASCADE</b>, except a different MDI Windows message is used for the operation.</P><p class=tl>
You should pick the default tile orientation for your application. You can do this by changing the ID for the Window "Tile" menu item to either <b>ID_WINDOW_TILE_HORZ</b> or <b>ID_WINDOW_TILE_VERT</b>.</P></li>
<li>
ID_WINDOW_SPLIT:&nbsp;&nbsp;&nbsp;Keyboard interface to splitter.<p class=tl>
<b>CView</b> handles this command for the <b>CSplitterWnd</b> implementation. If the view is part of a splitter window, this command will delegate to the implementation function <b>CSplitterWnd::DoKeyboardSplit</b>. This will place the splitter in a mode that will allow keyboard users to split or unsplit a splitter window.</P><p class=tl>
This command is disabled if the view is not in a splitter.</P><p class=tl>
Customization of this command handler is not recommended.</P></li>
<li>
ID_APP_ABOUT:&nbsp;&nbsp;&nbsp;Invoke the About dialog box.<p class=tl>
There is no standard implementation for an application's About box. The default AppWizard-created application will create a custom dialog class for your application and use it as your About box. AppWizard will also write the trivial command handler which handles this command and invokes the dialog.</P><p class=tl>
You will almost always implement this command.</P></li>
<li>
ID_APP_EXIT:&nbsp;&nbsp;&nbsp;Exit the application.<p class=tl>
<b>CWinApp::OnAppExit</b> handles this command by sending a <b>WM_CLOSE</b> message to the application's main window. The standard shutting down of the application (prompting for dirty files and so on) is handled by the <b>CFrameWnd</b> implementation.</P><p class=tl>
Customization of this command handler is not recommended. Overriding <b>CWinApp::SaveAllModified</b> or the <b>CFrameWnd</b> closing logic is recommended.</P><p class=tl>
If you choose to implement this command, we recommend you use this command ID.</P></li>
<li>
ID_HELP_INDEX:&nbsp;&nbsp;&nbsp;List Help topics from .HLP file.<p class=atl>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;You must connect this to your <b>CWinApp</b>-derived class's message map to enable this functionality.</p><p class=tl>
<b>CWinApp::OnHelpIndex</b> handles this command by trivially calling <b>CWinApp::WinHelp</b>.</P><p class=tl>
Customization of this command handler is not recommended.</P></li>
<li>
ID_HELP_USING:&nbsp;&nbsp;&nbsp;Display help on how to use Help.<p class=atl>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;You must connect this to your <b>CWinApp</b>-derived class's message map to enable this functionality.</p><p class=tl>
<b>CWinApp::OnHelpUsing</b> handles this command by trivially calling <b>CWinApp::WinHelp</b>.</P><p class=tl>
Customization of this command handler is not recommended.</P></li>
<li>
ID_CONTEXT_HELP:&nbsp;&nbsp;&nbsp;Enter SHIFT-F1 help mode.<p class=atl>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;You must connect this to your <b>CWinApp</b>-derived class's message map to enable this functionality.</p><p class=tl>
<b>CWinApp::OnContextHelp</b> handles this command by setting the help mode cursor, entering a modal loop and waiting for the user to select a window to get help on. Please refer to <a href="_mfcnotes_tn028.htm">Technical Note 28</a> for more details on the MFC Help implementation.</P><p class=tl>
Customization of this command handler is not recommended.</P></li>
<li>
ID_HELP:&nbsp;&nbsp;&nbsp;Give help on the current context<p class=atl>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;You must connect this to your <b>CWinApp</b>-derived class's message map to enable this functionality.</p><p class=tl>
<b>CWinApp::OnHelp</b> handles this command by getting the right help context for the current application context. This handles simple F1 help, help on message boxes and so on. Please refer to <a href="_mfcnotes_tn028.htm">Technical Note 28</a> for more details on the MFC help implementation.</P><p class=tl>
Customization of this command handler is not recommended.</P></li>
<li>
ID_DEFAULT_HELP:&nbsp;&nbsp;&nbsp;Display default help for context<p class=atl>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;You must connect this to your <b>CWinApp</b>-derived class's message map to enable this functionality.</p><p class=tl>
This command is usually mapped to <b>CWinApp::OnHelpIndex</b>.</P><p class=tl>
A different command handler can be provided if a distinction between default Help and the Help index is desired.</P></li>
<li>
ID_NEXT_PANE:&nbsp;&nbsp;&nbsp;Go to next pane<p class=tl>
<b>CView</b> handles this command for the <b>CSplitterWnd</b> implementation. If the view is part of a splitter window, this command will delegate to the implementation function <b>CSplitterWnd::OnNextPaneCmd</b>. This will move the active view to the next pane in the splitter.</P><p class=tl>
This command is disabled if the view is not in a splitter or there is no next pane to go to.</P><p class=tl>
Customization of this command handler is not recommended.</P></li>
<li>
ID_PREV_PANE:&nbsp;&nbsp;&nbsp;Go to previous pane<p class=tl>
<b>CView</b> handles this command for the <b>CSplitterWnd</b> implementation. If the view is part of a splitter window, this command will delegate to the implementation function <b>CSplitterWnd::OnNextPaneCmd</b>. This will move the active view to the previous pane in the splitter.</P><p class=tl>
This command is disabled if the view is not in a splitter or there is no previous pane to go to.</P><p class=tl>
Customization of this command handler is not recommended.</P></li>
<li>
ID_OLE_INSERT_NEW:&nbsp;&nbsp;&nbsp;Insert a new OLE object<p class=tl>
Currently there is no standard implementation for this command. You must implement this for your <b>CView</b>-derived class to insert a new OLE item/object at the current selection.</P><p class=tl>
All OLE client applications should implement this command. AppWizard, with the OLE option, will create a skeleton implementation of <b>OnInsertObject</b> in your view class which you will have to complete.</P><p class=tl>
See the MFC OLE sample <object id=alink_2 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="DefaultTopic" value="_topic_not_found.htm">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="_sample_mfc_OCLIENT">
</object><a href=JavaScript:alink_2.Click()>OCLIENT</a> example for a complete implementation of this command.</P></li>
<li>
ID_OLE_EDIT_LINKS:&nbsp;&nbsp;&nbsp;Edit OLE links<p class=tl>
<b>COleDocument</b> handles this command by using the MFC-provided implementation of the standard OLE links dialog. The implementation of this dialog is accessed through the <b>COleLinksDialog</b> class. If the current document does not contain any links, the command is disabled.</P><p class=tl>
Customization of this command handler is not recommended.</P></li>
<li>
ID_OLE_VERB_FIRST...LAST:&nbsp;&nbsp;&nbsp;An ID range for OLE verbs<p class=tl>
<b>COleDocument</b> uses this command ID range for the verbs supported by the currently selected OLE item/object. This must be a range since a given OLE item/object type can support zero or more custom verbs. In your application's menu, you should have one menu item with the ID of <b>ID_OLE_VERB_FIRST</b>. When the program is run, the menu will be updated with the appropriate menu verb description (or pop-up menu with many verbs). The management of the OLE menu is handled by <b>AfxOleSetEditMenu</b>, done in the update command UI handler for this command.</P><p class=tl>
There are no explicit command handlers for handling each of the command ID in this range. <b>COleDocument::OnCmdMsg</b> is overridden to trap all command IDs in this range, turn them into zero-based verb numbers, and launch the server for that verb (using <b>COleClientItem::DoVerb</b>).</P><p class=tl>
Customization or other use of this command ID range is not recommended.</P></li>
<li>
ID_VIEW_TOOLBAR:&nbsp;&nbsp;&nbsp;Toggle the toolbar on and off<p class=tl>
<b>CFrameWnd</b> handles this command and the update-command UI handler to toggle the visible state of the toolbar. The toolbar must be a child window of the frame with child window ID of <b>AFX_IDW_TOOLBAR</b>. The command handler actually toggles the visibility of the toolbar window. <b>CFrameWnd::RecalcLayout</b> is used to redraw the frame window with the toolbar in its new state. The update-command UI handler checks the menu item when the toolbar is visible.</P><p class=tl>
Customization of this command handler is not recommended. If you wish to add additional toolbars, you will want to clone and modify the command handler and the update-command UI handler for this command.</P></li>
<li>
ID_VIEW_STATUS_BAR:&nbsp;&nbsp;&nbsp;Toggle the status bar on and off<p class=tl>
This command is implemented in <b>CFrameWnd</b> just like <b>ID_VIEW_TOOLBAR</b>, except a different child window ID (<b>AFX_IDW_STATUS_BAR</b>) is used.</P></li>
</ul>
<p class=label>
<b>Update-Only Command Handlers</b></p>
<p>
There are several standard command IDs that are used as indicators in status bars. These use the same update-command UI handling mechanism to display their current visual state during application idle time. Since they can't be selected by the user (that is, you can't push a status bar pane), then it makes no sense to have an <b>ON_COMMAND</b> handler for these command IDs.
<ul type=disc>
<li>
<b>ID_INDICATOR_CAPS</b> : CAP lock indicator<br><br></li>
<li>
<b>ID_INDICATOR_NUM</b> : NUM lock indicator<br><br></li>
<li>
<b>ID_INDICATOR_SCRL</b> : SCRL lock indicator<br><br></li>
<li>
<b>ID_INDICATOR_KANA</b> : KANA lock indicator (applicable only to Japanese systems)</li>
</ul>
<p>
All three of these are implemented in <b>CFrameWnd::OnUpdateKeyIndicator</b>, an implementation helper that uses the command ID to map to the appropriate Virtual Key. A common implementation enables or disables (for status panes disabled = no text) the <b>CCmdUI</b> object depending on whether the appropriate Virtual Key is currently locked.</p>
<p>
Customization of this command handler is not recommended.
<ul type=disc>
<li>
<b>ID_INDICATOR_EXT : EXT</b>ended select indicator<br><br></li>
<li>
<b>ID_INDICATOR_OVR : OV</b>e<b>R</b>strike indicator<br><br></li>
<li>
<b>ID_INDICATOR_REC : REC</b>ording indicator</li>
</ul>
<p>
Currently there is no standard implementation for these indicators.</p>
<p>
If you choose to implement these indicators, we recommend you use these indicator IDs and maintaining the ordering of the indicators in your status bar (that is, in this order: EXT, CAP, NUM, SCRL, OVR, REC).</p>
<p>
<a href="_mfcnotes_technical_notes_by_number.htm">Technical Notes by Number</a>  |&nbsp; <a href="_mfcnotes_technical_notes_by_category.htm">Technical Notes by Category</a></p>
</font></BODY>
</HTML>
