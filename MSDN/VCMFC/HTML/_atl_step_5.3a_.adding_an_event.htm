<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Step 5: Adding an Event</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY>
<font face="verdana,arial,helvetica" size="2">
<h1><a name="_atl_step_5.3a_.adding_an_event"></a>Step 5: Adding an Event</h1>
<p>
Now you will add a <code>ClickIn</code> and a <code>ClickOut</code> event to your ATL control. You will fire the <code>ClickIn</code> event if the user clicks within the polygon and fire <code>ClickOut</code> if the user clicks outside.</p>
<p>
When you created the full control in Step 2, you selected the <b>Support Connection Points</b> check box.&nbsp; This created the <code>IPolyCtlEvents</code> interface in your .idl file.&nbsp; Note that the interface name starts with an underscore. This is a convention to indicate that the interface is an internal interface. Thus, programs that allow you to browse COM objects can choose not to display the interface to the user. Also notice in the .idl file that <b>Support Connection Points</b> added a line to indicate that <code>IPolyCtlEvents</code>  is the default source interface. The source attribute indicates that the control is the source of the notifications, so it will call this interface on the container.</p>
<p>
Now you should add the ClickIn and ClickOut methods to the <code>IPolyCtlEvents</code> interface:
<ol>
<li>
Right click on <code>IPolyCtlEvents</code> in <b>ClassView</b> and selecting <b>Add Method…</b> from the popup menu.<br><br></li>
<li>
Select a <b>Return Type</b> of <code>void</code>.<br><br></li>
<li>
Type <code>ClickIn</code> in the <b>Method Name</b> box.<br><br></li>
<li>
Enter <code>[in] long x, [in] long y</code> in the <b>Parameters</b> box.<br><br></li>
<li>
Click <b>OK</b>.</li>
</ol>
<p>
Check the .idl file to see that the code was added as a method to the <code>IPolyCtlEvents</code> dispinterface.&nbsp; Then use the same procedure to define a <code>ClickOut</code> method with the same parameters and return type.&nbsp; The IPolyCtlEvents dispinterface in your .idl file should now look like this:</p>
<pre><code>dispinterface _IPolyCtlEvents
{
   properties:
   methods:
   [id(1), helpstring("method ClickIn")] void ClickIn([in]long x, [in] long y);
   [id(2), helpstring("method ClickOut")] void ClickOut([in] long x, [in] long y);
};
</code></pre>
<p>
The <code>ClickIn</code> and <code>ClickOut</code> methods that take the x and y coordinates of the clicked point as parameters. </p>
<p>
Now generate your type library. To do this you can either rebuild your project or right-click the .idl file in <b>FileView</b> and click <b>Compile Polygon.idl</b>. This will create the Polygon.tlb file, which is your type library.</p>
<p>
Next, implement a connection point interface and a connection point container interface for your control. (In COM, events are implemented through the mechanism of connection points. To receive events from a COM object, a container establishes an advisory connection to the connection point that the COM object implements. Since a COM object can have multiple connection points, the COM object also implements a connection point container interface. Through this interface, the container can determine which connection points are supported.) The interface that implements a connection point is called <b>IConnectionPoint</b> and the interface that implements a connection point container is called <b>IConnectionPointContainer</b>.</p>
<p>
To help implement <b>IConnectionPoint</b>, use <b>ClassView</b> to access a connection point wizard. This wizard generates the <b>IConnectionPoint</b> interface by reading your type library and implementing a function for each event that can be fired. </p>
<p>
To run the wizard, follow these steps:
<ol>
<li>
Go to <b>ClassView</b> (on the <b>View</b> menu, click <b>Workspace</b> to see <b>ClassView</b>). <br><br></li>
<li>
Right click on your control's implementation class, in this case <b>CPolyCtl</b>.<br><br></li>
<li>
In the shortcut menu, select <b>Implement Connection Point…</b>.<br><br></li>
<li>
Select _PolyEvents from the <b>Interfaces</b> list then click <b>OK</b> and a proxy class for the connection point will be generated, in this case, CProxy_IPolyCtlEvents.</li>
</ol>
<p>
<img src="vc309a1.gif" border=0></p>
<p>
If you look at the generated PolygonCP.h file in <b>FileView</b>, you see it has a class called <code>CProxy_PolyCtlEvents</code> that derives from <b>IConnectionPointImpl</b>. PolygonCP.h also defines the two methods <code>Fire_ClickIn</code> and <code>Fire_ClickOut</code>, which take the two coordinate parameters. These are the methods you call when you want to fire an event from your control.</p>
<p>
The wizard also added the <b>CProxy_PolyEvents</b> and <b>IConnectionPointContainerImpl</b> to your control's multiple inheritance list.&nbsp; The wizard also exposed <b>IConnectionPointContainer</b> for you by adding appropriate entries to the COM map.</p>
<p>
You are finished implementing the code to support events. Now, add some code to fire the events at the appropriate moment. Remember, you are going to fire a <code>ClickIn</code> or <code>ClickOut</code> event when the user clicks the left mouse button in the control. To find out when the user clicks the button, first add a handler for the <b>WM_LBUTTONDOWN</b> message. In <b>ClassView</b>, right click on the CPolyCtl class and select <b>Add Windows Message Handler...</b> from the shortcut menu.&nbsp; Then select <b>WM_LBUTTONDOWN</b> from the list on the left and click the <b>Add Handler</b> button.&nbsp; Click <b>OK</b>.</p>
<p>
Next, add new code to the <b>OnLButtonDown</b> function in PolyCtl.h (deleting any code placed by the wizard) so that <b>OnLButtonDown</b> now looks like this:</p>
<pre><code>LRESULT CPolyCtl::OnLButtonDown(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL&amp; bHandled)
{
   HRGN hRgn;
   WORD xPos = LOWORD(lParam);&nbsp; // horizontal position of cursor
   WORD yPos = HIWORD(lParam);&nbsp; // vertical position of cursor

   CalcPoints(m_rcPos);

   // Create a region from our list of points
   hRgn = CreatePolygonRgn(&amp;m_arrPoint[0], m_nSides, WINDING);

   // If the clicked point is in our polygon then fire the ClickIn
   //&nbsp; event otherwise we fire the ClickOut event
   if (PtInRegion(hRgn, xPos, yPos))
      Fire_ClickIn(xPos, yPos);
   else
      Fire_ClickOut(xPos, yPos);

   // Delete the region that we created
   DeleteObject(hRgn);
   return 0;
}
</code></pre>
<p>
Since you have already calculated the points of the polygon in the <code>OnDraw</code> function, use them in <code>OnLButtonDown</code> to create a region. Then, use the <b>PtInRegion</b> API function to determine whether the clicked point is inside the polygon or not.</p>
<p>
The <code>uMsg</code> parameter is the ID of the Windows message being handled. This allows you to have one function that handles a range of messages. The <code>wParam</code> and the <code>lParam</code> are the standard values for the message being handled. The parameter <code>bHandled</code> allows you to specify whether the function handled the message or not. By default, the value is set to <b>TRUE</b> to indicate that the function handled the message, but you can set it to <b>FALSE.</b> Doing so will cause ATL to continue looking for another message handler function to which to send the message.</p>
<p>
Now try out your events. Build the control and start <b>ActiveX Control Test Container</b> again. This time, view the event log window.&nbsp; To route events to the output window, select <b>Logging</b> from the <b>Options</b> menu and select <b>Log to output window</b>. Now insert the control and try clicking in the window. Notice that <code>ClickIn</code> is fired if you click within the filled polygon and <code>ClickOut</code> is fired when you click outside of it. </p>
<p>
Next you will add a property page.</p>
<p>
<a href="_atl_step_4.3a_.changing_the_drawing_code.htm">Back to Step 4</a>  |&nbsp; <a href="_atl_step_6.3a_.adding_a_property_page.htm">On to Step 6</a> </p>
</font></BODY>
</HTML>
