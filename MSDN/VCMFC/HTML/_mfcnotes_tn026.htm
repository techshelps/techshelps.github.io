<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>TN026: DDX and DDV Routines</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY>
<font face="verdana,arial,helvetica" size="2">
<h1><a name="_mfcnotes_tn026"></a><sup></sup>TN026: DDX and DDV Routines</h1>
<p>
This note describes the dialog data exchange (DDX) and dialog data validation (DDV) architecture. It also describes how you write a DDX_ or DDV_ procedure and how you can extend ClassWizard to use your routines.</p>
<p class=label>
<b>Overview of Dialog Data Exchange</b></p>
<p>
All dialog data functions are done with C++ code. There are no special resources or magic macros. The heart of the mechanism is a virtual function that is overridden in every dialog class that does dialog data exchange and validation. It is always found in this form:</p>
<pre><code>void CMyDialog::DoDataExchange(CDataExchange* pDX)
{
 &nbsp;&nbsp; CDialog::DoDataExchange(pDX);&nbsp;&nbsp;&nbsp; // call base class

 &nbsp;&nbsp; //{{AFX_DATA_MAP(CMyDialog)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;data_exchange_function_call&gt;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp; //}}AFX_DATA_MAP
}
</code></pre>
<p>
The special format AFX comments allow ClassWizard to locate and edit the code within this function. Code that is not compatible with ClassWizard should be placed outside of the special format comments.</p>
<p>
In the above example, &lt;data_exchange_function_call&gt; is in the form:</p>
<pre><code>&nbsp;&nbsp;&nbsp;&nbsp;DDX_Custom(pDX, nIDC, field);
</code></pre>
<p>
and &lt;data_validation_function_call&gt; is optional and is in the form:</p>
<pre><code>&nbsp;&nbsp;&nbsp;&nbsp;DDV_Custom(pDX, field, ...);
</code></pre>
<p>
More than one DDX_/DDV_ pair may be included in each <b>DoDataExchange</b> function. </p>
<p>
See 'afxdd_.h' for a list of all the dialog data exchange routines and dialog data validation routines provided with MFC.</p>
<p>
Dialog data is just that - member data in the <b>CMyDialog</b> class. It is not stored in a struct or anything special like that.</p>
<p class=label>
<b>Notes</b></p>
<p>
Although we call this “dialog data,” all features are available in any class derived from <b>CWnd</b> and are not limited to just dialogs.</p>
<p>
Initial values of data are set in the standard C++ constructor, usually in a block with <code>//{{AFX_DATA_INIT</code> and <code>//}}AFX_DATA_INIT</code> comments.</p>
<p>
<b>CWnd::UpdateData</b> is the operation that does the initialization and error handling around the call to <b>DoDataExchange</b>.</p>
<p>
You can call <b>CWnd::UpdateData</b> at any time to perform data exchange and validation. By default <b>UpdateData</b>(TRUE) is called in the default <b>CDialog::OnOK</b> handler and <b>UpdateData</b>(FALSE) is called in the default <b>CDialog::OnInitDialog</b>.</p>
<p>
The DDV_ routine should immediately follow the DDX_ routine for that <i>field</i>.</p>
<p class=label>
<b>How Does It Work?</b></p>
<p>
You do not need to understand the following in order to use dialog data. However, understanding how this works behind the scenes will help you write your own exchange or validation procedure.</p>
<p>
The <b>DoDataExchange</b> member function is much like the <b>Serialize</b> member function - it is responsible for getting or setting data to/from an external form (in this case controls in a dialog) from/to member data in the class. The <i>pDX</i> parameter is the context for doing data exchange and is similar to the <b>CArchive</b> parameter to <b>CObject::Serialize</b>. The <i>pDX</i> (a <b>CDataExchange</b> object) has a direction flag much like <b>CArchive</b> has a direction flag:
<ul type=disc>
<li>
if <b>!m_bSaveAndValidate</b>, then load the data state into the controls<br><br></li>
<li>
if <b>m_bSaveAndValidate</b>, then set the data state from the controls</li>
</ul>
<p>
Validation only occurs when <b>m_bSaveAndValidate</b> is set. The value of <b>m_bSaveAndValidate</b> is determined by the BOOL parameter to <b>CWnd::UpdateData</b>.</p>
<p>
There are three other interesting <b>CDataExchange</b> members:
<ul type=disc>
<li>
<b>m_pDlgWnd</b>: The window (usually a dialog) that contains the controls. This is to prevent callers of the DDX_ and DDV_ global functions from having to pass 'this' to every DDX/DDV routine.<br><br></li>
<li>
<b>PrepareCtrl</b>, and <b>PrepareEditCtrl</b>: Prepares a dialog control for data exchange. Stores that control's handle for setting the focus if a validation fails. <b>PrepareCtrl</b> is used for nonedit controls and <b>PrepareEditCtrl</b> is used for edit controls.<br><br></li>
<li>
<b>Fail</b>: Called after bringing up a message box alerting the user to the input error. This routine will restore the focus to the last control (the last call to <b>PrepareCtrl</b>/<b>PrepareEditCtrl</b>) and throw an exception. This member function may be called from both DDX_ and DDV_ routines.</li>
</ul>
<p class=label>
<b>User Extensions</b></p>
<p>
There are several ways to extend the default DDX/DDV mechanism. You can:
<ul type=disc>
<li>
Add new data types.<pre><code>CTime
</code></pre>
</li>
<li>
Add new exchange procedures (DDX_???).<pre><code>void PASCAL DDX_Time(CDataExchange* pDX, int nIDC, CTime&amp; tm);
</code></pre>
</li>
<li>
Add new validation procedures (DDV_???).<pre><code>void PASCAL DDV_TimeFuture(CDataExchange* pDX, CTime tm, BOOL bFuture);
// make sure time is in the future or past
</code></pre>
</li>
<li>
Pass arbitrary expressions to the validation procedures.<pre><code>DDV_MinMax(pDX, age, 0, m_maxAge);
</code></pre>
<p class=atl>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;Such arbitrary expressions cannot be edited by ClassWizard and therefore should be moved outside of the special format comments (//{{AFX_DATA_MAP(CMyClass)).</p></li>
</ul>
<p>
Have the <b>DoDialogExchange</b> member function include conditionals or any other valid C++ statements with intermixed exchange and validation function calls.</p>
<pre><code>//{{AFX_DATA_MAP(CMyClass)
DDX_Check(pDX, IDC_SEX, m_bFemale);
DDX_Text(pDX, IDC_EDIT1, m_age);
//}}AFX_DATA_MAP
if (m_bFemale)
 &nbsp;&nbsp; DDV_MinMax(pDX, age, 0, m_maxFemaleAge);
else
 &nbsp;&nbsp; DDV_MinMax(pDX, age, 0, m_maxMaleAge);
</code></pre>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;As shown above, such code can not be edited by ClassWizard and should be used only outside of the special format comments.</p>
<p class=label>
<b>ClassWizard Support</b></p>
<p>
ClassWizard supports a subset of DDX/DDV customizations by allowing you to integrate your own DDX_ and DDV_ routines into the ClassWizard user interface. Doing this is only cost beneficial if you plan to reuse particular DDX and DDV routines time and time again in a project or in many projects.</p>
<p>
To do this, special entries are made in DDX.CLW (previous versions of Visual C++ stored this information in APSTUDIO.INI) or in your project’s .CLW file. The special entries can be entered either in the [General Info] section of your project's .CLW file or in the [ExtraDDX] section of the DDX.CLW file in the \Program Files\Microsoft Visual Studio\Visual C++\bin directory. You may need to create the DDX.CLW file if it doesn’t already exist. If you plan to use the custom DDX_/DDV_ routines only in a certain project, add the entries to the [General Info] section of your project .CLW file instead. If you plan to use the routines on many projects, add the entries to the [ExtraDDX] section of DDX.CLW.</p>
<p>
The general format of these special entries is:</p>
<p class=tl>
ExtraDDXCount=n</P><p class=tl>
; where n is the number of ExtraDDX? lines to follow</P><p class=tl>
ExtraDDX?=&lt;keys&gt;;&lt;vb-keys&gt;; &lt;prompt&gt;; &lt;type&gt;; &lt;initValue&gt;; &lt;DDX_Proc&gt; [;&lt;DDV_Proc&gt;; &lt;prompt1&gt;; &lt;arg1&gt;; [&lt;prompt2&gt;; &lt;fmt2&gt;]]</P><p class=tl>
; Where ? is a number 1-n indicating which DDX type in the list that is being defined.</P><p>
Each field is delimited by a ';' character. The fields and their purpose are described below.</p>
<p class=dt>
&lt;keys&gt;</p>
<p class=indent>
= list of single characters indicating for which dialog controls this variable type is allowed.</p>
<p class=tl>
E = edit</P><p class=tl>
C = two-state check box</P><p class=tl>
c = tri-state check box</P><p class=tl>
R = first radio button in a group</P><p class=tl>
L = non-sorted list box</P><p class=tl>
l = sorted list box</P><p class=tl>
M = combo box (with edit item)</P><p class=tl>
N = non-sorted drop list</P><p class=tl>
n = sorted drop list</P><p class=tl>
1 = if the DDX insert should be added to head of list (default is add to tail)&nbsp; This is generally used for DDX routines that transfer the 'Control' property.</P><p class=dt>
&lt;vb-keys&gt;</p>
<p class=indent>
this field is used only in the 16-bit product for VBX controls (VBX controls are not supported in the 32-bit product)</p>
<p class=dt>
&lt;prompt&gt; =</p>
<p class=indent>
string to place in the Property combo box (no quotes)</p>
<p class=dt>
&lt;type&gt; =</p>
<p class=indent>
single identifier for type to emit in the header file. In our example above with DDX_Time, this would be set to CTime.</p>
<p class=dt>
&lt;vb-keys&gt; =</p>
<p class=indent>
not used in this version and should always be empty</p>
<p class=dt>
&lt;initValue&gt; =</p>
<p class=indent>
initial value - 0 or blank. If it is blank, then no initialization line will be written in the //{{AFX_DATA_INIT section of the implementation file. A blank entry should be used for C++ objects (such as CString, CTime, and so on) that have constructors that guarantee correct initialization.</p>
<p class=dt>
&lt;DDX_Proc&gt; =</p>
<p class=indent>
single identifier for the DDX_ procedure. The C++ function name must start with “DDX_,” but don't include “DDX_” in the &lt;DDX_Proc&gt; identifier. In the example above, the &lt;DDX_Proc&gt; identifier would be Time. When ClassWizard writes the function call to the implementation file in the {{AFX_DATA_MAP section, it appends this name to DDX_, thus arriving at DDX_Time.</p>
<p class=dt>
&lt;comment&gt; =</p>
<p class=indent>
comment to show in dialog for variable with this DDX. Place any text you would like here, usually provide something that describes the operation performed by the DDX/DDV pair.</p>
<p class=dt>
&lt;DDV_Proc&gt;</p>
<p class=indent>
The DDV portion of the entry is optional. Not all DDX routines have corresponding DDV routines. Often, it is more convenient to include the validation phase as an integral part of the transfer. This is often the case when your DDV routine doesn't require any parameters, since ClassWizard doesn't support DDV routines without any parameters.</p>
<p class=dt>
</p>
<p class=indent>
= single identifier for the DDV_ procedure. The C++ function name must start with “DDV_” but don't include “DDX_” in the &lt;DDX_Proc&gt; identifier.</p>
<p>
followed by 1 or 2 DDV args:</p>
<p class=dt>
&lt;promptX&gt; =</p>
<p class=indent>
string to place above the edit item (with &amp; for accelerator)</p>
<p class=dt>
&lt;fmtX&gt; =</p>
<p class=indent>
format character for the arg type, one of</p>
<p class=tl>
d = int</P><p class=tl>
u = unsigned</P><p class=tl>
D = long int (that is, long)</P><p class=tl>
U = long unsigned (that is, DWORD)</P><p class=tl>
f = float</P><p class=tl>
F = double</P><p class=tl>
s = string</P><p class=label>
<b>An Example of Custom DDX</b></p>
<p>
An example of custom DDX with validation can be found in the MFC Advanced Concepts sample <object id=alink_1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="DefaultTopic" value="_topic_not_found.htm">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="_sample_mfc_CHKBOOK">
</object><a href=JavaScript:alink_1.Click()>CHKBOOK</a>. See DDX_DollarsCents in DOLLCENT.CPP for an sample implementation of a custom DDX routine and CHKBOOK.CLW for the corresponding example ExtraDDXCount and ExtraDDX1 entries in the [General Info] section of CHKBOOK’s .CLW file.</p>
<p>
<a href="_mfcnotes_technical_notes_by_number.htm">Technical Notes by Number</a>  |&nbsp; <a href="_mfcnotes_technical_notes_by_category.htm">Technical Notes by Category</a></p>
</font></BODY>
</HTML>
