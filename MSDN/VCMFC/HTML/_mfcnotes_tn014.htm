<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>TN014: Custom Controls</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY>
<font face="verdana,arial,helvetica" size="2">
<h1><a name="_mfcnotes_tn014"></a><sup></sup>TN014: Custom Controls</h1>
<p>
This note describes the MFC Support for custom and self-drawing controls. Dynamic subclassing is also described. General advice on ownership of <b>CWnd</b> objects vs. <b>HWND</b>s is presented.</p>
<p>
The MFC sample application CTRLTEST illustrates many of these features. Please refer to the source code for the MFC General sample <object id=alink_1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="DefaultTopic" value="_topic_not_found.htm">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="_sample_mfc_CTRLTEST">
</object><a href=JavaScript:alink_1.Click()>CTRLTEST</a> and online help. </p>
<p class=label>
<b>Owner-Draw Controls/Menus</b></p>
<p>
Windows provides support for "owner draw" controls and menus. These are Windows messages sent to a parent window of a control or menu that allow you to customize the visual appearance and behavior of the control or menu.</p>
<p>
MFC directly supports owner draw with the message map entries:
<ul type=disc>
<li>
<b>CWnd::OnDrawItem</b><br><br></li>
<li>
<b>CWnd::OnMeasureItem</b><br><br></li>
<li>
<b>CWnd::OnCompareItem</b><br><br></li>
<li>
<b>CWnd::OnDeleteItem</b></li>
</ul>
<p>
You can override these in your <b>CWnd</b>-derived class (usually a dialog or main frame window) to implement the owner-draw behavior.</p>
<p>
This approach does not lead to reusable code. If you have two similar controls in two different dialogs, you must implement the custom control behavior in two places. The MFC-supported self-drawing control architecture solves this problem.</p>
<p class=label>
<b>Self-Drawing Controls and Menus</b></p>
<p>
MFC provides a default implementation (in <b>CWnd</b> and <b>CMenu</b>) for the standard owner-draw messages. This default implementation will decode the owner-draw parameters and delegate the owner-draw messages to the controls or menu. This is called "self-draw" since the drawing (/measuring/comparing) code is in the class of the control or menu, not in the owner window.</p>
<p>
This allows you to build reusable control classes that display the control using "owner draw" semantics. The code for drawing the control, not the owner of the control, is in the control class. This is an object-oriented approach to custom control programming.
<ul type=disc>
<li>
For self-draw buttons:<pre><code>CButton:DrawItem(LPDRAWITEMSTRUCT);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // draw this button
</code></pre>
</li>
<li>
For self-draw menus:<pre><code>CMenu:MeasureItem(LPMEASUREITEMSTRUCT);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // measure the size of an item in this menu
CMenu:DrawItem(LPDRAWITEMSTRUCT);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // draw an item in this menu
</code></pre>
</li>
<li>
For self-draw list boxes:<pre><code>CListBox:MeasureItem(LPMEASUREITEMSTRUCT);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // measure the size of an item in this list box
CListBox:DrawItem(LPDRAWITEMSTRUCT);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // draw an item in this list box

CListBox:CompareItem(LPCOMPAREITEMSTRUCT);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // compare two items in this list box if LBS_SORT
CListBox:DeleteItem(LPDELETEITEMSTRUCT);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // delete an item from this list box
</code></pre>
</li>
<li>
For self-draw combo boxes:<pre><code>CComboBox:MeasureItem(LPMEASUREITEMSTRUCT);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // measure the size of an item in this combo box
CComboBox:DrawItem(LPDRAWITEMSTRUCT);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // draw an item in this combo box

CComboBox:CompareItem(LPCOMPAREITEMSTRUCT);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // compare two items in this combo box if CBS_SORT
CComboBox:DeleteItem(LPDELETEITEMSTRUCT);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // delete an item from this combo box
</code></pre>
</li>
</ul>
<p>
For details on the owner-draw structures (<b>DRAWITEMSTRUCT</b>, <b>MEASUREITEMSTRUCT</b>, <b>COMPAREITEMSTRUCT</b>, and <b>DELETEITEMSTRUCT</b>) refer to the MFC documentation for <b>CWnd::OnDrawItem</b>, <b>CWnd::OnMeasureItem</b>, <b>CWnd::OnCompareItem</b>, and <b>CWnd::OnDeleteItem</b> respectively.</p>
<p class=label>
<b>Using self-drawing controls and menus</b></p>
<p>
For self-drawing menus, you must override both <b>MeasureItem</b> and <b>DrawItem</b> member functions.</p>
<p>
For self-drawing list boxes and combo boxes, you must override <b>MeasureItem</b> and <b>DrawItem</b>. You must specify the OWNERDRAWVARIABLE style in the dialog template (<b>LBS_OWNERDRAWVARIABLE</b> and <b>CBS_OWNERDRAWVARIABLE</b> respectively). The <b>OWNERDRAWFIXED</b> style will not work with self-drawing items since the fixed item height is determined before self-drawing controls are attached to the list box. (The Win 3.1 member functions <b>CListBox::SetItemHeight</b> and <b>CComboBox::SetItemHeight</b> can be used to get around this limitation.)</p>
<p>
In addition, note that switching to an <b>OWNERDRAWVARIABLE</b> style will affect the <b>NOINTEGRALHEIGHT</b> style. Because the control can not calculate an integral height with variable sized items, the default style of <b>INTEGRALHEIGHT</b> is ignored and the control is always <b>NOINTEGRALHEIGHT</b>. If your items are fixed height, you can prevent partial items from being drawn by specifying the control size to be an integral multiplier of the item size.</p>
<p>
For self-drawing list boxes and combo boxes with the SORT style (<b>LBS_SORT</b> and <b>CBS_SORT</b> respectively), you must override the <b>CompareItem</b> member function.</p>
<p>
For self-drawing list boxes and combo boxes, <b>DeleteItem</b> is not normally overridden. <b>DeleteItem</b> can be overridden if additional memory or other resources are stored with each list box or combo box item.</p>
<p class=label>
<b>Examples of Self-Drawing Controls/Menus</b></p>
<p>
The MFC General sample <object id=alink_2 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="DefaultTopic" value="_topic_not_found.htm">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="_sample_mfc_CTRLTEST">
</object><a href=JavaScript:alink_2.Click()>CTRLTEST</a> provides samples of a self-draw menu (showing colors) and a self-draw list box (also showing colors).</p>
<p>
The most typical example of a self-drawing button is a bitmap button (a button that shows one, two, or three bitmap images for the different states). This is provided in the MFC class <b>CBitmapButton</b>.</p>
<p class=label>
<b>Dynamic Subclassing</b></p>
<p>
Subclassing is the Windows term for replacing the <b>WndProc</b> of a window with a different <b>WndProc</b> and calling the old <b>WndProc</b> for default (superclass) functionality.</p>
<p>
This should not be confused with C++ class derivation (C++ terminology uses the words "base" and "derived" while the Windows object model uses "super" and "sub"). C++ derivation with MFC and Windows subclassing are functionally very similar, except C++ does not support a feature similar to dynamic subclassing.</p>
<p>
The <b>CWnd</b> class provides the connection between a C++ object (derived from <b>CWnd</b>) and a Windows window object (also known as an <b>HWND</b>).</p>
<p>
There are three common ways these are related:
<ul type=disc>
<li>
<b>CWnd</b> creates the <b>HWND</b>. The behavior can be modified in a derived class. "Class derivation" is done by creating a class derived from <b>CWnd</b> and created with calls to <b>Create</b>.<br><br></li>
<li>
<b>CWnd</b> gets attached to an existing <b>HWND</b>. The behavior of the existing window is not modified. This is a case of "delegation" and is made possible by calling <b>Attach</b> to alias an existing <b>HWND</b> to a <b>CWnd</b> C++ object.<br><br></li>
<li>
<b>CWnd</b> gets attached to an existing <b>HWND</b> and you can modify the behavior in a derived class. This is called "dynamic subclassing," since we are changing the behavior (and hence the class) of a Windows object at run time.</li>
</ul>
<p>
This last case is done with the member functions:
<ul type=disc>
<li>
<b>CWnd::SubclassWindow</b><br><br></li>
<li>
<b>CWnd::SubclassDlgItem</b>.</li>
</ul>
<p>
Both routines attach a <b>CWnd</b> object to an existing Windows <b>HWND</b>. <b>SubclassWindow</b> takes the <b>HWND</b> directly, and <b>SubclassDlgItem</b> is a helper that takes a control ID and the parent window (usually a dialog). <b>SubclassDlgItem</b> is designed for attaching C++ objects to dialog controls created from a dialog template.</p>
<p>
Please refer to the <object id=alink_3 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="DefaultTopic" value="_topic_not_found.htm">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="_sample_mfc_CTRLTEST">
</object><a href=JavaScript:alink_3.Click()>CTRLTEST</a> example for several examples of when to use <b>SubclassWindow</b> and <b>SubclassDlgItem</b>.</p>
<p>
<a href="_mfcnotes_technical_notes_by_number.htm">Technical Notes by Number</a>  |&nbsp; <a href="_mfcnotes_technical_notes_by_category.htm">Technical Notes by Category</a></p>
</font></BODY>
</HTML>
