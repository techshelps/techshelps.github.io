<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>TN045: MFC/Database Support for Long Varchar/Varbinary</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY>
<font face="verdana,arial,helvetica" size="2">
<h1><a name="_mfcnotes_tn045"></a><sup></sup>TN045: MFC/Database Support for Long Varchar/Varbinary</h1>
<p>
This note describes how to retrieve and send the ODBC <b>SQL_LONGVARCHAR</b> and <b>SQL_LONGVARBINARY</b> data types using the MFC database classes.</p>
<p class=label>
<b>Overview of Long Varchar/Varbinary Support</b></p>
<p>
The ODBC <b>SQL_LONG_VARCHAR</b> and <b>SQL_LONGBINARY</b> data types (referred to here as long data columns) can hold huge amounts of data. There are 3 ways you can handle this data: 
<ul type=disc>
<li>
Bind it to a <b>CString</b>/<b>CByteArray</b>, <br><br></li>
<li>
Bind it to a <b>CLongBinary</b>, or <br><br></li>
<li>
Don't bind it at all and retrieve and send the long data value manually, independent of the database classes. Each of the 3 methods has advantages and disadvantages.</li>
</ul>
<p>
Long data columns are not supported for parameters to a query. They are only supported for outputColumns.</p>
<p class=label>
<b>Binding a Long Data Column to a CString/CByteArray</b></p>
<p>
Advantages: </p>
<p>
This approach is simple to understand, and you work with familiar classes. The framework provides <b>CFormView</b> support for <b>CString</b> with <b>DDX_Text</b>. You have lots of general string or collection functionality with the <b>CString</b> and <b>CByteArray</b> classes, and you can control the amount of memory allocated locally to hold the data value. The framework maintains an old copy of field data during <b>Edit</b> or <b>AddNew</b> function calls, and the framework can automatically detect changes to the data for you.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;Since <b>CString</b> is designed for working on character data, and <b>CByteArray</b> for working on binary data, it is recommended that you put the character data (<b>SQL_LONGVARCHAR</b>) into <b>CString</b>, and the binary data (<b>SQL_LONGVARBINARY</b>) into <b>CByteArray</b>.</p>
<p>
The RFX functions for <b>CString</b> and <b>CByteArray</b> have an additional argument which lets you override the default size of allocated memory to hold the retrieved value for the data column. Note the nMaxLength argument in the following function declarations:</p>
<pre><code>void AFXAPI RFX_Text(CFieldExchange* pFX, const char *szName,
 &nbsp;&nbsp; CString&amp; value, int nMaxLength = 255, int nColumnType =
 &nbsp;&nbsp; SQL_VARCHAR);

void AFXAPI RFX_Binary(CFieldExchange* pFX, const char *szName, 
 &nbsp;&nbsp; CByteArray&amp; value,int nMaxLength = 255);
</code></pre>
<p>
If you retrieve a long data column into a <b>CString</b> or <b>CByteArray</b>, the maximum returned amount of data is, by default, 255 bytes. Anything beyond this is ignored. In this case, the framework will throw the exception <b>AFX_SQL_ERROR_DATA_TRUNCATED</b>. Fortunately, you can explicitly increase nMaxLength to greater values, up to <b>MAXINT</b>.</p>
<p>
ClassWizard will bind a <b>SQL_LONGVARCHAR</b> to a <b>CString</b>, or a <b>SQL_LONGVARBINARY</b> to a <b>CByteArray</b> for you. If you want to allocate more than 255 bytes into which you retrieve your long data column, you can then supply an explicit value for nMaxLength.</p>
<p>
When a long data column is bound to a <b>CString</b> or <b>CByteArray</b>, updating the field works just the same as when it is bound to a SQL_<b>VARCHAR</b> or SQL_<b>VARBINARY</b>. During <b>Edit</b>, the data value is cached away and later compared when <b>Update</b> is called to detect changes to the data value and set the Dirty and Null values for the column appropriately.</p>
<p class=label>
<b>Binding a Long Data Column to a CLongBinary</b></p>
<p>
If your long data column may contain more <b>MAXINT</b> bytes of data, you should probably consider retrieving it into a <b>CLongBinary</b>.</p>
<p>
Advantages: </p>
<p>
This retrieves an entire long data column - up to available memory.</p>
<p>
Disadvantages: </p>
<p>
The data is held in memory. This approach is also prohibitively expensive for very large amounts of data. You must call <b>SetFieldDirty</b> for the bound data member to ensure the field is included in an <b>Update</b> operation.</p>
<p>
If you retrieve long data columns into a <b>CLongBinary</b>, the database classes will check the total size of the long data column, then allocate an <b>HGLOBAL</b> memory segment large enough to hold it the entire data value. The database classes then retrieve the entire data value into the allocated <b>HGLOBAL</b>.</p>
<p>
If the data source cannot return the expected size of the long data column, the framework will throw the exception <b>AFX_SQL_ERROR_SQL_NO_TOTAL</b>. If the attempt to allocate the <b>HGLOBAL</b> fails, a standard memory exception is thrown.</p>
<p>
ClassWizard will bind an <b>SQL_LONGVARCHAR</b> or <b>SQL_LONGVARBINARY</b> to a <b>CLongBinary</b> for you. Select <b>CLongBinary</b> as the Variable Type in the Add Member Variable dialog. ClassWizard will then add an <b>RFX_LongBinary</b> call to your <b>DoFieldExchange</b> call and increment the total number of bound fields.</p>
<p>
To update long data column values, first make sure the allocated <b>HGLOBAL</b> is large enough to hold your new data by calling <b>::GlobalSize</b> on the <b>m_hData</b> member of the <b>CLongBinary</b>. If it's too small, release the <b>HGLOBAL</b> and allocate one the appropriate size. Then set <b>m_dwDataLength</b> to reflect the new size.</p>
<p>
Otherwise, if <b>m_dwDataLength</b> is larger than the size of the data you're replacing, you can either free and reallocate the <b>HGLOBAL</b>, or leave it allocated. Make sure to indicate the number of bytes actually used in <b>m_dwDataLength</b>.</p>
<p class=label>
<b>How Updating a CLongBinary Works</b></p>
<p>
It is not necessary to understand how updating a <b>CLongBinary</b> works, but it may be useful as an example on how to send long data values to a data source, if you choose this third method, described below.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;In order for a <b>CLongBinary</b> field to be included in an update, you must explicitly call <b>SetFieldDirty</b> for the field. If you make any change to a field, including setting it Null, you must call <b>SetFieldDirty</b>.</p>
<p>
When updating a <b>CLongBinary</b> field, the database classes use ODBC's <b>DATA_AT_EXEC</b> mechanism (see ODBC documentation on <b>SQLSetPos</b>'s rgbValue argument). When the framework prepares the insert or update statement, instead of pointing to the <b>HGLOBAL</b> containing the data, the <i>address</i> of the <b>CLongBinary</b> is set as the <i>value</i> of the column instead, and the length indicator set to <b>SQL_DATA_AT_EXEC</b>. Later, when the update statement is sent to the data source, <b>SQLExecDirect</b> will return <b>SQL_NEED_DATA</b>. This alerts the framework that the value of the param for this column is actually the address of a <b>CLongBinary</b>. The framework calls <b>SQLGetData</b> once with a small buffer, expecting the driver to return the actual length of the data. If the driver returns the actual length of the binary large object (the BLOB), MFC reallocates as much space as necessary to fetch the BLOB. If the datasource returns <b>SQL_NO_TOTAL</b>, indicating that it can't determine the size of the BLOB, MFC will create smaller blocks. The default initial size is 64K, and subsequent blocks will be double the size; for example, the second will be 128K, the third is 256K, and so on. The initial size is configurable. </p>
<p class=label>
<b>Not Binding: Retrieving/Sending Data Directly from ODBC with SQLGetData</b></p>
<p>
With this method you completely bypass the database classes, and deal with the long data column yourself.</p>
<p>
Advantages: </p>
<p>
You can cache data to disk if necessary, or decide dynamically how much data to retrieve.</p>
<p>
Disadvantages: </p>
<p>
You don't get the framework's <b>Edit</b> or <b>AddNew</b> support, and you must write code yourself to perform basic functionality (<b>Delete</b> does work though, since it is not a column level operation).</p>
<p>
In this case, the long data column must be in the select list of the recordset, but should not be bound to by the framework. One way to do this is to supply your own SQL statement via <b>GetDefaultSQL</b> or as the lpszSQL argument to <b>CRecordset</b>'s <b>Open</b> function, and not bind the extra column with an RFX_ function call. ODBC requires that unbound fields appear to the right of bound fields, so add your unbound column(s) to the end of the select list.</p>
<p class=indent>
<B><b>Warning</b></B>&nbsp;&nbsp;&nbsp;Since your long data column is not bound by the framework, changes to it will not be handled with <b>CRecordset::Update</b> calls. You must create and send the required SQL <b>INSERT</b> and <b>UPDATE</b> statements yourself.</p>
<p>
<a href="_mfcnotes_technical_notes_by_number.htm">Technical Notes by Number</a>  |&nbsp; <a href="_mfcnotes_technical_notes_by_category.htm">Technical Notes by Category</a></p>
</font></BODY>
</HTML>
