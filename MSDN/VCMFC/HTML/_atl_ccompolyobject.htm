<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CComPolyObject</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY>
<font face="verdana,arial,helvetica" size="2">
<h1><a name="_atl_ccompolyobject"></a>CComPolyObject</h1>
<p>
<b>template&lt; class </b><i>contained</i><b> &gt;</b><br>
<b>class CComPolyObject : public IUnknown, public CComObjectRootEx&lt; </b><i>contained</i><b>::_ThreadModel::ThreadModelNoCS &gt;</b></p>
<p class=label>
<b>Parameters</b></p>
<p class=dt>
<i>contained</i></p>
<p class=indent>
Your class, derived from <a href="_atl_ccomobjectroot.htm">CComObjectRoot</a> or <a href="_atl_ccomobjectrootex.htm">CComObjectRootEx</a>, as well as from any other interfaces you want to support on the object.</p>
<p>
<b>CComPolyObject</b> implements <object id=alink_1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="DefaultTopic" value="_topic_not_found.htm">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="_com_IUnknown">
</object><a href=JavaScript:alink_1.Click()>IUnknown</a> for an aggregated or nonaggregated object. </p>
<p>
When an instance of <b>CComPolyObject</b> is created, the value of the outer unknown is checked. If it is <b>NULL</b>, <b>IUnknown</b> is implemented for a nonaggregated object. If the outer unknown is not <b>NULL</b>, <b>IUnknown</b> is implemented for an aggregated object. </p>
<p>
The advantage of using <b>CComPolyObject</b> is that you avoid having both <a href="_atl_ccomaggobject.htm">CComAggObject</a> and <a href="_atl_ccomobject.htm">CComObject</a> in your module to handle the aggregated and nonaggregated cases. A single <b>CComPolyObject</b> object handles both cases. This means only one copy of the vtable and one copy of the functions exist in your module. If your vtable is large, this can substantially decrease your module size. However, if your vtable is small, using <b>CComPolyObject</b> can result in a slightly larger module size because it is not optimized for an aggregated or nonaggregated object, as are <b>CComAggObject</b> and <b>CComObject</b>.</p>
<p>
If the <b>DECLARE_POLY_AGGREGATABLE</b> macro is specified in your object's class definition, <b>CComPolyObject</b> will be used to create your object. <b>DECLARE_POLY_AGGREGATABLE</b> will automatically be declared if you use the ATL Object Wizard to create a full control or Internet Explorer control. </p>
<p>
If aggregated, the <b>CComPolyObject</b> object has its own <b>IUnknown</b>, separate from the outer object's <b>IUnknown</b>, and maintains its own reference count. <b>CComPolyObject</b> uses <a href="_atl_ccomcontainedobject.htm">CComContainedObject</a> to delegate to the outer unknown.</p>
<p>
For more information about aggregation, see the article <a href="_atl_fundamentals_of_atl_com_objects.htm">Fundamentals of ATL COM Objects</a>.</p>
<p>
<b>#include &lt;atlcom.h&gt;</b></p>
<p>
<a href="_atl_ccompolyobject_class_members.htm">Class Members</a></p>
<p>
<b>See Also</b>&nbsp;&nbsp;&nbsp;<a href="_atl_ccomobjectrootex.htm">CComObjectRootEx</a>, <a href="_atl_declare_poly_aggregatable.htm">DECLARE_POLY_AGGREGATABLE</a></p>
</font></BODY>
</HTML>
