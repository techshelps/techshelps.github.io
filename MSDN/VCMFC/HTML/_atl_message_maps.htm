<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Message Maps</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY>
<font face="verdana,arial,helvetica" size="2"><h1><a name="_atl_message_maps"></a>Message Maps</h1>
<p>
A message map associates a handler function with a particular message, command, or notification. By using ATL's <a href="_atl_atl_macros_and_global_functions.htm#_atl_message_map_macros">message map macros</a>, you can specify a message map for a window. The window procedures in <b>CWindowImpl</b>, <b>CDialogImpl</b>, and <b>CContainedWindow</b> direct a window's messages to its message map.</p>
<p>
The message handler functions accept an additional argument of type <code>BOOL&amp;</code>. This argument indicates whether a message has been processed, and it is set to <code>TRUE</code> by default. A handler function can then set the argument to <code>FALSE</code> to indicate that it has not handled a message. In this case, ATL will continue to look for a handler function further in the message map. By setting this argument to <code>FALSE</code>, you can first perform some action in response to a message and then allow the default processing or another handler function to finish handling the message.</p>
<p>
ATL also allows you to chain message maps, which directs the message handling to a message map defined in another class. For example, you can implement common message handling in a separate class to provide uniform behavior for all windows chaining to that class. You can chain to a base class or to a data member of your class.</p>
<p>
ATL also supports dynamic chaining, which allows you to chain to another object's message map at run time. To implement dynamic chaining, you must derive your class from <a href="_atl_cdynamicchain.htm">CDynamicChain</a>. Then declare the <a href="_atl_chain_msg_map_dynamic.htm">CHAIN_MSG_MAP_DYNAMIC</a> macro in your message map. <b>CHAIN_MSG_MAP_DYNAMIC</b> requires a unique number that identifies the object and the message map to which you are chaining. You must define this unique value through a call to <b>CDynamicChain::SetChainEntry</b>.</p>
<p>
You can chain to any class that declares a message map, provided the class derives from <a href="_atl_cmessagemap.htm">CMessageMap</a>. <b>CMessageMap</b> allows an object to expose its message maps to other objects. Note that <b>CWindowImpl</b> already derives from <b>CMessageMap</b>. </p>
<p>
Finally, ATL supports alternate message maps, declared with the <a href="_atl_alt_msg_map.htm">ALT_MSG_MAP</a> macro. Each alternate message map is identified by a unique number, which you pass to <b>ALT_MSG_MAP</b>. Using alternate message maps, you can handle the messages of multiple windows in one map. Note that by default, <b>CWindowImpl</b> does not use alternate message maps. To add this support, override the <b>WindowProc</b> method in your <b>CWindowImpl</b>-derived class and call <b>ProcessWindowMessage</b> with the message map identifier.</p>
</font></BODY>
</HTML>
