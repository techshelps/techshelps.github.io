<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>TN017: Destroying Window Objects</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY>
<font face="verdana,arial,helvetica" size="2">
<h1><a name="_mfcnotes_tn017"></a><sup></sup>TN017: Destroying Window Objects</h1>
<p>
This note describes the use of the <b>CWnd::PostNcDestroy</b> member function. Use this function if you wish to do customized allocation of <b>CWnd</b>-derived objects.</p>
<p>
This note also explains some of the reasons for the cardinal rule:</p>
<p>
To destroy a C++ Windows object, use DestroyWindow not "delete".</p>
<p>
This is important. If you follow the guidelines below, you will have few cleanup problems (such as forgetting to delete/free C++ memory, forgetting to free system resources like <b>HWND</b>s, or freeing objects too many times).</p>
<p class=label>
<b>The Problem</b></p>
<p>
Windows objects (objects of classes derived from <b>CWnd</b>) represent both a C++ object (allocated in the application's heap) and an HWND (allocated in system resources by the window manager). Since there are several ways to destroy a window object, we must provide a set of rules that prevent system resource or application memory leaks and that prevent objects and Windows handles from being destroyed more than once.</p>
<p>
This is more than a memory management problem. The presence of a Windows window has user-interface impact: a window drawn on the screen; once it is destroyed there is also an impact on system resources. Leaking C++ memory in your application address space is not as bad as leaking system resources.</p>
<p class=label>
<b>Destroying Windows</b></p>
<p>
The two permitted ways to destroy a Windows object are:
<ul type=disc>
<li>
Calling <b>CWnd::DestroyWindow</b> or the Windows API <b>::DestroyWindow</b>.<br><br></li>
<li>
Explicit deletion with the <b>delete</b> operator.</li>
</ul>
<p>
The first case is by far the most common. This case applies even if <b>DestroyWindow</b> is not called directly by your code. The is the case when the user directly closes a frame window (the default <b>WM_CLOSE</b> behavior is to call <b>DestroyWindow</b>), and when a parent window is destroyed, Windows calls <b>DestroyWindow</b> for all the children.</p>
<p>
The second case, the use of the <b>delete</b> operator on Windows objects, should be very rare and only in the cases outlined below.</p>
<p class=label>
<b>Auto Cleanup with CWnd::PostNcDestroy</b></p>
<p>
When destroying a Windows window, the last Windows message sent to the window is <b>WM_NCDESTROY</b>. The default <b>CWnd</b> handler for that message (<b>CWnd::OnNcDestroy</b>) will detach the <b>HWND</b> from the C++ object and call the virtual function <b>PostNcDestroy</b>. Some classes override this function to delete the C++ object.</p>
<p>
The default implementation of <b>CWnd::PostNcDestroy</b> does nothing which is appropriate for window objects allocated on the stack frame or embedded in other objects. This is not appropriate for window objects that are designed to be allocated by themselves on the heap (not embedded in other C++ object).</p>
<p>
Those classes that are designed to be allocated by themselves on the heap override the <b>PostNcDestroy</b> member function to perform a "<b>delete this</b>". This statement will free any C++ memory associated with the C++ object. Even though the default <b>CWnd</b> destructor calls <b>DestroyWindow</b> if <b>m_hWnd</b> is non-NULL, this does not lead to infinite recursion since the handle will be detached and NULL during the cleanup phase.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;<b>CWnd::PostNcDestroy</b> is normally called after the Windows <b>WM_NCDESTROY</b> message is processed, as part of window destruction, and the <b>HWND</b> and the C++ window object are no longer attached. <b>CWnd::PostNcDestroy</b> will also be called in the implementation of most <b>Create</b> calls if failure occurs (see below for auto cleanup rules).</p>
<p class=label>
<b>Auto Cleanup Classes</b></p>
<p>
The following classes are not designed for auto-cleanup. They are normally embedded in other C++ object or on the stack:
<ul type=disc>
<li>
All the standard Windows controls (<b>CStatic</b>, <b>CEdit</b>, <b>CListBox</b>, and so on).<br><br></li>
<li>
Any child windows derived directly from <b>CWnd</b> (for example, custom controls)<br><br></li>
<li>
Splitter windows (<b>CSplitterWnd</b>)<br><br></li>
<li>
Default control bars (classes derived from <b>CControlBar</b>, see <a href="_mfcnotes_tn031.htm">Technical Note 31</a> for enabling auto-delete for control bar objects)<br><br></li>
<li>
Dialogs (<b>CDialog</b>) - designed for modal dialogs on the stack frame<br><br></li>
<li>
All the standard dialogs except <b>CFindReplaceDialog</b><br><br></li>
<li>
The default dialogs created by ClassWizard</li>
</ul>
<p>
The following classes are designed for auto-cleanup. They are normally allocated by themselves on the heap:
<ul type=disc>
<li>
Main frame windows (derived directly or indirectly from <b>CFrameWnd</b>)<br><br></li>
<li>
View windows (derived directly or indirectly from <b>CView</b>)</li>
</ul>
<p>
If you wish to break any of these rules, you must override the <b>PostNcDestroy</b> member function in your derived class. To add auto-cleanup to your class, simply call your base class and then do a <b>delete this</b>. To remove auto-cleanup from your class, call <b>CWnd::PostNcDestroy</b> directly instead of the <b>PostNcDestroy</b> member in your direct base class.</p>
<p>
The most common use of the above is to create a modeless dialog that can be allocated on the heap.</p>
<p class=label>
<b>When to Call 'delete'</b></p>
<p>
The recommended way to destroy a Windows object is to call <b>DestroyWindow</b>, either the C++ member function or the global <b>::DestroyWindow</b> API.</p>
<p>
Do not call the global <b>::DestroyWindow</b> API to destroy an MDI Child window, use the virtual member function <b>CWnd::DestroyWindow</b> instead.</p>
<p>
For C++ Window objects that don't perform auto-cleanup, using <b>DestroyWindow</b> instead of <b>delete</b> avoids problems of having to call <b>DestroyWindow</b> in the <b>CWnd::~CWnd</b> destructor where the VTBL is not pointing to the correctly derived class. This can lead to subtle bugs so the diagnostic (debug) version of MFC will warn you with</p>
<pre><code>Warning: calling DestroyWindow in CWnd::~CWnd
 &nbsp; OnDestroy or PostNcDestroy in derived class will not be called
</code></pre>
<p>
In the case of C++ Windows objects that do perform auto-cleanup, you must call <b>DestroyWindow</b>. If you use operator <b>delete</b> directly, the MFC diagnostic memory allocator will alert you that you are freeing memory twice (the first call to <b>delete</b> as well as the indirect call to "<b>delete this</b>" in the auto-cleanup implementation of <b>PostNcDestroy</b>).</p>
<p>
After calling <b>DestroyWindow</b> on a non-auto-cleanup object, the C++ object will still be around, but <b>m_hWnd</b> will be NULL. After calling <b>DestroyWindow</b> on an auto-cleanup object, the C++ object will be gone, freed by the C++ delete operator in the auto-cleanup implementation of <b>PostNcDestroy</b>..</p>
<p>
<a href="_mfcnotes_technical_notes_by_number.htm">Technical Notes by Number</a>  |&nbsp; <a href="_mfcnotes_technical_notes_by_category.htm">Technical Notes by Category</a></p>
</font></BODY>
</HTML>
