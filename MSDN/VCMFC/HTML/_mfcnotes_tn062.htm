<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>TN062: Message Reflection for Windows Controls</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY>
<font face="verdana,arial,helvetica" size="2">
<h1><a name="_mfcnotes_tn062"></a>TN062: Message Reflection for Windows Controls</h1>
<p>
This technical note describes message reflection, a new feature in MFC 4.0. It also contains directions for creating a simple reusable control that uses message reflection.</p>
<p>
This technical note does not discuss message reflection as it applies to ActiveX controls (formerly called OLE controls). Please see the article <object id=alink_1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="DefaultTopic" value="_topic_not_found.htm">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="_core_ActiveX_Controls.3a_.Subclassing_a_Windows_Control">
</object><a href=JavaScript:alink_1.Click()>ActiveX Controls: Subclassing a Windows Control</a> in <i>Visual C++ Programmer's Guide</i>.</p>
<p class=label>
<b>What Is Message Reflection?</b></p>
<p>
Windows controls frequently send notification messages to their parent windows. For instance, many controls send a control color notification message (<b>WM_CTLCOLOR</b> or one of its variants) to their parent to allow the parent to supply a brush for painting the background of the control.</p>
<p>
In Windows and in MFC prior to version 4.0, the parent window, often a dialog box, is responsible for handling these messages. This means that the code for handling the message needs to be in the parent window’s class and that it has to be duplicated in every class that needs to handle that message. In the case above, every dialog box that wanted controls with custom backgrounds would have to handle the control color notification message. It would be much easier to reuse code if a control class could be written that would handle its own background color.</p>
<p>
In MFC 4.0, the old mechanism still works—parent windows can handle notification messages. In addition, however, MFC 4.0 facilitates reuse by providing a feature called “message reflection” that allows these notification messages to be handled in either the child control window or the parent window, or in both. In the control background color example, you can now write a control class that sets its own background color by handling the reflected <b>WM_CTLCOLOR</b> message—all without relying on the parent. (Note that since message reflection is implemented by MFC, not by Windows, the parent window class must be derived from <b>CWnd</b> for message reflection to work.)</p>
<p>
Older versions of MFC did something similar to message reflection by providing virtual functions for a few messages, such as messages for owner-drawn list boxes (<b>WM_DRAWITEM</b>, and so on). The new message reflection mechanism is generalized and consistent.</p>
<p>
Message reflection is backward compatible with code written for versions of MFC previous to 4.0. </p>
<p>
If you have supplied a handler for a specific message, or for a range of messages, in your parent window's class, it will override reflected message handlers for the same message provided you don't call the base class handler function in your own handler. For example, if you handle <b>WM_CTLCOLOR</b> in your dialog box class, your handling will override any reflected message handlers.</p>
<p>
If, in your parent window class, you supply a handler for a specific <b>WM_NOTIFY</b> message or a range of <b>WM_NOTIFY</b> messages, your handler will be called only if the child control sending those messages does not have a reflected message handler through <b>ON_NOTIFY_REFLECT()</b>. If you use <b>ON_NOTIFY_REFLECT_EX()</b> in your message map, your message handler may or may not allow the parent window to handle the message. If the handler returns <b>TRUE</b>, the message will be handled by the parent as well, while a call that returns <b>FALSE</b> does not allow the parent to handle it. Note that the reflected message is handled before the notification message.</p>
<p>
When a <b>WM_NOTIFY</b> message is sent, the control is offered the first chance to handle it. If any other reflected message is sent, the parent window has the first chance to handle it and the control will receive the reflected message. To do so, it will need a handler function and an appropriate entry in the control's class message map.</p>
<p>
The message-map macro for reflected messages is slightly different than for regular notifications: it has <b>_REFLECT</b> appended to its usual name. For instance, to handle a <b>WM_NOTIFY</b> message in the parent, you use the macro <b>ON_NOTIFY</b> in the parent’s message map. To handle the reflected message in the child control, use the <b>ON_NOTIFY_REFLECT</b> macro in the child control’s message map. In some cases, the parameters are different, as well. Note that ClassWizard can usually add the message-map entries for you and provide skeleton function implementations with correct parameters.</p>
<p>
See <a href="_mfcnotes_tn061.htm">TN061: ON_NOTIFY and WM_NOTIFY Messages</a> for information on the new <b>WM_NOTIFY</b> message.</p>

<p class=label>
<b>Message-Map Entries and Handler Function Prototypes for Reflected Messages</b></p>
<p>
To handle a reflected control notification message, use the message-map macros and function prototypes listed in the table below.</p>
<p>
ClassWizard can usually add these message-map entries for you and provide skeleton function implementations. See <object id=alink_2 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="DefaultTopic" value="_topic_not_found.htm">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="_core_Defining_a_Message_Handler_for_a_Reflected_Message">
</object><a href=JavaScript:alink_2.Click()>Defining a Message Handler for a Reflected Message</a> in the <i>Visual C++ Programmer's Guide</i> for information about how to define handlers for reflected messages.</p>
<p>
To convert from the message name to the reflected macro name, prepend <b>ON_</b> and append <b>_REFLECT</b>. For example, <b>WM_CTLCOLOR</b> becomes <b>ON_WM_CTLCOLOR_REFLECT</b>. (To see which messages can be reflected, do the opposite conversion on the macro entries in the table below.)</p>
<p>
The three exceptions to the rule above are as follows: 
<ul type=disc>
<li>
The macro for <b>WM_COMMAND</b> notifications is <b>ON_CONTROL_REFLECT</b>.<br><br></li>
<li>
The macro for <b>WM_NOTIFY</b> reflections is <b>ON_NOTIFY_REFLECT</b>.<br><br></li>
<li>
The macro for <b>ON_UPDATE_COMMAND_UI</b> reflections is <b>ON_UPDATE_COMMAND_UI_REFLECT</b>.</li>
</ul>
<p>
In each of the above special cases, you must specify the name of the handler member function. In the other cases, you must use the standard name for your handler function.</p>
<p>
The meanings of the parameters and return values of the functions are documented under either the function name or the function name with <b>On</b> prepended. For instance, <b>CtlColor</b> is documented in <b>OnCtlColor</b>. Several reflected message handlers need fewer parameters than the similar handlers in a parent window. Just match the names in the table below with the names of the formal parameters in the documentation.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=38%><b>Map entry</b></td>
<td class=label width=62%><b>Function prototype</b></td>
</tr>
<tr valign=top>
<td width=38%><b>ON_CONTROL_REFLECT( </b><i>wNotifyCode</i><b>, </b><i>memberFxn</i><b> )</b></td>
<td width=62%><b>afx_msg void </b><i>memberFxn</i><b> ( );</b></td>
</tr>
<tr valign=top>
<td width=38%><b>ON_NOTIFY_REFLECT( </b><i>wNotifyCode</i><b>, </b><i>memberFxn</i><b> )</b></td>
<td width=62%><b>afx_msg void </b><i>memberFxn</i><b> ( NMHDR * </b><i>pNotifyStruct</i><b>, LRESULT* </b><i>result</i><b> );</b></td>
</tr>
<tr valign=top>
<td width=38%><b>ON_UPDATE_COMMAND_UI_REFLECT( </b><i>memberFxn</i><b> )</b></td>
<td width=62%><b>afx_msg void </b><i>memberFxn</i><b> ( CCmdUI* </b><i>pCmdUI</i><b> );</b></td>
</tr>
<tr valign=top>
<td width=38%><b>ON_WM_CTLCOLOR_REFLECT( )</b></td>
<td width=62%><b>afx_msg HBRUSH CtlColor ( CDC* </b><i>pDC</i><b>, UINT </b><i>nCtlColor</i><b> );</b></td>
</tr>
<tr valign=top>
<td width=38%><b>ON_WM_DRAWITEM_REFLECT( )</b></td>
<td width=62%><b>afx_msg void DrawItem ( LPDRAWITEMSTRUCT </b><i>lpDrawItemStruct</i><b> );</b></td>
</tr>
<tr valign=top>
<td width=38%><b>ON_WM_MEASUREITEM_REFLECT( )</b></td>
<td width=62%><b>afx_msg void MeasureItem ( LPMEASUREITEMSTRUCT </b><i>lpMeasureItemStruct</i><b> );</b></td>
</tr>
<tr valign=top>
<td width=38%><b>ON_WM_DELETEITEM_REFLECT( )</b></td>
<td width=62%><b>afx_msg void DeleteItem ( LPDELETEITEMSTRUCT </b><i>lpDeleteItemStruct</i><b> );</b></td>
</tr>
<tr valign=top>
<td width=38%><b>ON_WM_COMPAREITEM_REFLECT( )</b></td>
<td width=62%><b>afx_msg int CompareItem ( LPCOMPAREITEMSTRUCT </b><i>lpCompareItemStruct</i><b> );</b></td>
</tr>
<tr valign=top>
<td width=38%><b>ON_WM_CHARTOITEM_REFLECT( )</b></td>
<td width=62%><b>afx_msg int CharToItem ( UINT </b><i>nKey</i><b>, UINT </b><i>nIndex</i><b> );</b></td>
</tr>
<tr valign=top>
<td width=38%><b>ON_WM_VKEYTOITEM_REFLECT( )</b></td>
<td width=62%><b>afx_msg int VKeyToItem ( UINT </b><i>nKey</i><b>, UINT </b><i>nIndex</i><b> );</b></td>
</tr>
<tr valign=top>
<td width=38%><b>ON_WM_HSCROLL_REFLECT( )</b></td>
<td width=62%><b>afx_msg void HScroll ( UINT </b><i>nSBCode</i><b>, UINT </b><i>nPos</i><b> );</b></td>
</tr>
<tr valign=top>
<td width=38%><b>ON_WM_VSCROLL_REFLECT( )</b></td>
<td width=62%><b>afx_msg void VScroll ( UINT </b><i>nSBCode</i><b>, UINT </b><i>nPos</i><b> );</b></td>
</tr>
<tr valign=top>
<td width=38%><b>ON_WM_PARENTNOTIFY_REFLECT( )</b></td>
<td width=62%><b>afx_msg void ParentNotify ( UINT </b><i>message</i><b>, LPARAM </b><i>lParam</i><b> );</b></td>
</tr>
</table><br>
<p>
The <b>ON_NOTIFY_REFLECT</b> and <b>ON_CONTROL_REFLECT</b> macros have variations that allow more than one object (such as the control and its parent) to handle a given message.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=38%><b>Map entry</b></td>
<td class=label width=62%><b>Function prototype</b></td>
</tr>
<tr valign=top>
<td width=38%><b>ON_NOTIFY_REFLECT_EX( </b><i>wNotifyCode</i><b>, </b><i>memberFxn</i><b> )</b></td>
<td width=62%><b>afx_msg BOOL </b><i>memberFxn</i><b> ( NMHDR * </b><i>pNotifyStruct</i><b>, LRESULT* </b><i>result</i><b> );</b></td>
</tr>
<tr valign=top>
<td width=38%><b>ON_CONTROL_REFLECT_EX( </b><i>wNotifyCode</i><b>, </b><i>memberFxn</i><b> )</b></td>
<td width=62%><b>afx_msg BOOL </b><i>memberFxn</i><b> ( );</b></td>
</tr>
</table><br>
<p class=label>
<b>Handling Reflected Messages: An Example of a Reusable control</b></p>
<p>
This simple example creates a reusable control called <code>CYellowEdit</code>. The control works the same as a regular edit control except that it displays black text on a yellow background. It would be easy to add member functions that would allow the <code>CYellowEdit</code> control to display different colors.</p>
<p>
To try this example, do the following steps:
<ol>
<li>
Create a new dialog box in an existing application. For more information see <object id=alink_3 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="DefaultTopic" value="_topic_not_found.htm">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="dialog editor">
</object><a href=JavaScript:alink_3.Click()>dialog editor</a> in the <i>Visual C++ User’s Guide</i>.<p class=tl>
You must have an application in which to develop the reusable control. If you don’t have an existing application to use, create a dialog-based application using AppWizard.</P></li>
<li>
With your project loaded into Visual C++, use ClassWizard to create a new class called <code>CYellowEdit</code> based on <b>CEdit</b>. Leave the “Add to Component Gallery” box checked.<br><br></li>
<li>
Add three member variables to your <code>CYellowEdit</code> class. The first two will be <b>COLORREF</b> variables to hold the text color and the background color. The third will be a <b>CBrush</b> object which will hold the brush for painting the background. The <b>CBrush</b> object allows you to create the brush once, merely referencing it after that, and to destroy the brush automatically when the <code>CYellowEdit</code> control is destroyed.<br><br></li>
<li>
Initialize the member variables by writing the constructor as follows:<pre><code>CYellowEdit::CYellowEdit()
{
m_clrText = RGB( 0, 0, 0 );
m_clrBkgnd = RGB( 255, 255, 0 );
m_brBkgnd.CreateSolidBrush( m_clrBkgnd );
}
</code></pre>
</li>
<li>
Using ClassWizard, add a handler for the reflected <b>WM_CTLCOLOR</b> message to your <code>CYellowEdit</code> class. Note that the equal sign in front of the message name in the list of messages you can handle indicates that the message is reflected. This is described in <object id=alink_4 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="DefaultTopic" value="_topic_not_found.htm">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="_core_Defining_a_Message_Handler_for_a_Reflected_Message">
</object><a href=JavaScript:alink_4.Click()>Defining a Message Handler for a Reflected Message</a> in the <i>Visual C++ Programmer's Guide</i>.<p class=tl>
ClassWizard adds the following message-map macro and skeleton function for you:</P><pre><code>ON_WM_CTLCOLOR_REFLECT()

// Note: other code will be in between....

HBRUSH CYellowEdit::CtlColor(CDC* pDC, UINT nCtlColor) 
{
// TODO: Change any attributes of the DC here

// TODO: Return a non-NULL brush if the
//    parent's handler should not be called
return NULL;
}
</code></pre>
</li>
<li>
Replace the body of the function with the following code. The code specifies the text color, the text background color, and the background color for rest of the control.<pre><code>pDC-&gt;SetTextColor( m_clrText );    // text
pDC-&gt;SetBkColor( m_clrBkgnd );    // text bkgnd
return m_brBkgnd;                // ctl bkgnd
</code></pre>
</li>
<li>
Create an edit control in your dialog box, then attach it to a member variable by double-clicking the edit control while holding a control key down. In the Add Member Variable dialog box, finish the variable name and choose “Control” for the category, then “CYellowEdit” for the variable type. Don’t forget to set the tab order in the dialog box. Also, be sure to include the header file for the <code>CYellowEdit</code> control in your dialog box’s header file.<br><br></li>
<li>
Build and run your application. The edit control will have a yellow background.<br><br></li>
<li>
You can now use Component Gallery to add your <code>CYellowEdit</code> control class to other projects.</li>
</ol>
<p>
<a href="_mfcnotes_technical_notes_by_number.htm">Technical Notes by Number</a>  |&nbsp; <a href="_mfcnotes_technical_notes_by_category.htm">Technical Notes by Category</a></p>
</font></BODY>
</HTML>
