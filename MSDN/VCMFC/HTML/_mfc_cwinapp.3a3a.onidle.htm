<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CWinApp::OnIdle</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY>
<font face="verdana,arial,helvetica" size="2">
<h1><a name="_mfc_cwinapp.3a3a.onidle"></a><sup></sup>CWinApp::OnIdle  </h1>
<p>
<b>virtual</b> <b>BOOL</b> <b>OnIdle(</b> <b>LONG</b> <i>lCount</i> <b>);</b></p>
<p class=label>
<b>Return Value</b></p>
<p>
Nonzero to receive more idle processing time; 0 if no more idle time is needed.</p>
<p class=label>
<b>Parameters</b></p>
<p class=dt>
<i>lCount</i></p>
<p class=indent>
A counter incremented each time <b>OnIdle</b> is called when the application’s message queue is empty. This count is reset to 0 each time a new message is processed. You can use the <i>lCount</i> parameter to determine the relative length of time the application has been idle without processing a message.</p>
<p class=label>
<b>Remarks</b></p>
<p>
Override this member function to perform idle-time processing. <b>OnIdle</b> is called in the default message loop when the application’s message queue is empty. Use your override to call your own background idle-handler tasks.</p>
<p>
<b>OnIdle</b> should return 0 to indicate that no idle processing time is required. The <i>lCount</i> parameter is incremented each time <b>OnIdle</b> is called when the message&nbsp; queue is empty and resets to 0 each time a new message is processed. You can call your different idle routines based on this count.</p>
<p>
The following summarizes idle loop processing:
<ol>
<li>
If the message loop in the Microsoft Foundation Class Library checks the message queue and finds no pending messages, it calls <code>OnIdle</code> for the application object and supplies 0 as the <i>lCount</i> argument.<br><br></li>
<li>
<code>OnIdle</code> performs some processing and returns a nonzero value to indicate it should be called again to do further processing.<br><br></li>
<li>
The message loop checks the message queue again. If no messages are pending, it calls <code>OnIdle</code> again, incrementing the <i>lCount</i> argument.<br><br></li>
<li>
Eventually, <code>OnIdle</code> finishes processing all its idle tasks and returns 0. This tells the message loop to stop calling <code>OnIdle</code> until the next message is received from the message queue, at which point the idle cycle restarts with the argument set to&nbsp;0.</li>
</ol>
<p>
Do not perform lengthy tasks during <b>OnIdle</b> because your application cannot process user input until <b>OnIdle</b> returns.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;The default implementation of <b>OnIdle</b> updates command user-interface objects such as menu items and toolbar buttons, and it performs internal data structure cleanup. Therefore, if you override <b>OnIdle</b>, you must call <b>CWinApp::OnIdle</b> with the <i>lCount</i> in your overridden version. First call all base-class idle processing (that is, until the base class <b>OnIdle</b> returns 0). If you need to perform work before the base-class processing completes, review the base-class implementation to select the proper <i>lCount</i> during which to do your work.</p>
<p class=label>
<b>Example</b></p>
<p>
The following two examples show how to use <b>OnIdle</b>. The first example processes two idle tasks using the <i>lCount</i> argument to prioritize the tasks. The first task is high priority, and you should do it whenever possible. The second task is less important and should be done only when there is a long pause in user input. Note the call to the base-class version of <b>OnIdle</b>. The second example manages a group of idle tasks with different priorities.</p>
<pre><code>BOOL CMyApp::OnIdle(LONG lCount)
{
 &nbsp;&nbsp; BOOL bMore = CWinApp::OnIdle(lCount);

 &nbsp;&nbsp; if (lCount == 0)
 &nbsp;&nbsp; {
 &nbsp;&nbsp; TRACE("App idle for short period of time\n");
 &nbsp;&nbsp; bMore = TRUE;
 &nbsp;&nbsp; }
 &nbsp;&nbsp; else if (lCount == 10)
 &nbsp;&nbsp; {
 &nbsp;&nbsp; TRACE("App idle for longer amount of time\n");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bMore = TRUE;
 &nbsp;&nbsp; }
 &nbsp;&nbsp; else if (lCount == 100)
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TRACE("App idle for even longer amount of time\n");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bMore = TRUE;
 &nbsp;&nbsp; }
 &nbsp;&nbsp; else if (lCount == 1000)
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TRACE("App idle for quite a long period of time\n");
 &nbsp;&nbsp;&nbsp; // bMore is not set to TRUE, no longer need idle
 &nbsp;&nbsp;&nbsp; // IMPORTANT: bMore is not set to FALSE since CWinApp::OnIdle may
 &nbsp;&nbsp;&nbsp; // have more idle tasks to complete.
 &nbsp;&nbsp; }

 &nbsp;&nbsp; return bMore;
 &nbsp;&nbsp;&nbsp; // return TRUE as long as there is any more idle tasks
}
</code></pre>
<p class=label>
<b>Second Example</b></p>
<pre><code>// In this example, four idle loop tasks are given various 
// opportunities to run:
// Task1 is always given a chance to run during idle time, provided
//&nbsp;&nbsp; that no message has queued up while the framework was processing
//&nbsp;&nbsp; its own idle loop tasks (at lCount levels 0 and 1).
// Task2 is given a chance to run only if Task1 has already run,
//&nbsp;&nbsp; provided that no message has queued up while Task1 was running.
// Task3 and Task4 are given a chance to run only if both Task1 and
//&nbsp;&nbsp; Task2 have already run, and no message has queued up in the mean
//&nbsp;&nbsp; time.&nbsp; If Task3 gets its chance to run, then Task4 always gets
//&nbsp;&nbsp; a chance to run immediately after Task3.

BOOL CMyApp::OnIdle(LONG lCount)
{
 &nbsp; // In this example, as in most applications, you should let the
 &nbsp; // base class CWinApp::OnIdle complete its processing before you
 &nbsp; // attempt any additional idle loop processing.
 &nbsp; if (CWinApp::OnIdle(lCount))
 &nbsp;&nbsp;&nbsp;&nbsp; return TRUE;&nbsp;&nbsp; 

 &nbsp; // The base class CWinApp::OnIdle reserves the lCount values 0 
 &nbsp; // and 1 for the framework's own idle processing.&nbsp;&nbsp; If you wish to
 &nbsp; // share idle processing time at a peer level with the framework,
 &nbsp; // then replace the above if-statement with a straight call to
 &nbsp; // CWinApp::OnIdle; and then add a case statement for lCount value
 &nbsp; // 0 and/or 1. Study the base class implementation first to 
 &nbsp; // understand how your idle loop tasks will compete with the 
 &nbsp; // framework's idle loop processing.

 &nbsp; switch (lCount)
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; case 2:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Task1();
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return TRUE; // next time give Task2 a chance
 &nbsp;&nbsp;&nbsp;&nbsp; case 3:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Task2();
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return TRUE; // next time give Task3 and Task4 a chance
 &nbsp;&nbsp;&nbsp;&nbsp; case 4:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Task3();
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Task4();
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return FALSE; // cycle through the idle loop tasks again
 &nbsp; }
 &nbsp; return FALSE;
}


</code></pre>
<p>
<a href="_mfc_cwinapp.htm">CWinApp Overview</a>  |&nbsp; <a href="_mfc_cwinapp_class_members.htm">Class Members</a>  |&nbsp; <a href="_mfc_hierarchy_chart.htm">Hierarchy Chart</a></p>
</font></BODY>
</HTML>
