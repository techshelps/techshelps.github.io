<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>TN002: Persistent Object Data Format</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY>
<font face="verdana,arial,helvetica" size="2">
<h1><a name="_mfcnotes_tn002"></a><sup></sup>TN002: Persistent Object Data Format</h1>
<p>
This note describes the MFC routines that support persistent C++ objects and the format of the object data when it is stored in a file. This only applies to classes with the <b>DECLARE_SERIAL</b> and <b>IMPLEMENT_SERIAL</b> macros.</p>
<p class=label>
<b>The Problem</b></p>
<p>
The MFC implementation for persistent data relies on a compact binary format for saving the data for many objects in a single contiguous part of a file. This binary format provides the structure for how the data is stored, but it is the object's <b>Serialize</b> member function that provides the actual data saved by the object.</p>
<p>
The MFC solves the structuring problem by using the class <b>CArchive</b>. A <b>CArchive</b> object provides a context for persistence that lasts from the time the archive is created until the <b>CArchive::Close</b> member function is called, either explicitly by the programmer or implicitly by the destructor when the scope containing the <b>CArchive</b> is exited.</p>
<p>
This note describes the implementation of the <b>CArchive</b> members <b>ReadObject</b> and <b>WriteObject</b>. <b>ReadObject</b> and <b>WriteObject</b> are not called directly by instead are used by class-specific type-safe insertion and extraction operators generated automatically by the <b>DECLARE_SERIAL</b> and <b>IMPLEMENT_SERIAL</b> macros.</p>
<pre><code>class CMyObject : public CObject
{
 &nbsp;&nbsp; DECLARE_SERIAL(CMyObject)
};

IMPLEMENT_SERIAL(CMyObj, CObject, 1)

// example usage (ar is a CArchive&amp;)
CMyObject* pObj;
CArchive&amp; ar;
ar &lt;&lt; pObj;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // calls ar.WriteObject(pObj)
ar &gt;&gt; pObj;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // calls ar.ReadObject(RUNTIME_CLASS(CObj))
</code></pre>
<p>
This note describes code located in the MFC source file ARCOBJ.CPP. The main <b>CArchive</b> implementation can be found in ARCCORE.CPP.</p>
<p class=label>
<b>Saving Objects to the Store (CArchive::WriteObject)</b></p>
<p>
The member function <b>CArchive::WriteObject</b> writes header data used to reconstruct the object. This data consists of two parts: the type of the object and the state of the object. This member function is also responsible for maintaining the identity of the object being written out, so that only a single copy is saved, regardless of the number of pointers to that object (including circular pointers).</p>
<p>
Saving (inserting) and restoring (extracting) objects relies on several “manifest constants.” These are values that are stored in binary and provide important information to the archive (note the "w" prefix indicates 16-bit quantities):</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=50%><b>Tag</b></td>
<td class=label width=50%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=50%>wNullTag</td>
<td width=50%>Used for NULL object pointers (0).</td>
</tr>
<tr valign=top>
<td width=50%>wNewClassTag</td>
<td width=50%>Indicates class description that follows is new to this archive context—(-1).</td>
</tr>
<tr valign=top>
<td width=50%>wOldClassTag</td>
<td width=50%>Indicates class of the object being read has been seen in this context (0x8000).</td>
</tr>
</table><br>
<p>
When storing objects, the archive maintains a <b>CMapPtrToPtr</b> (the <b>m_pStoreMap</b>) which is a mapping from a stored object to a 32-bit persistent identifier (PID). A PID is assigned to every unique object and every unique class name that is saved in the context of the archive. These PIDs are handed out sequentially starting at 1. It is important to note that these PIDs have no significance outside the scope of the archive and, in particular, are not to be confused with record number or other identity items.</p>
<p>
Starting with MFC version 4.0 the <b>CArchive</b> class has been extended to support very large archives. In previous versions, a PID was a 16-bit quantity, limiting the archive to 0x7FFE (32766) objects. PIDs are now 32-bit, but they are written out as 16-bit unless they are larger than 0x7FFE. Large PIDs are written as 0x7FFF followed by the 32-bit PID. This technique maintains file backward compatibility.</p>
<p>
When a request is made to save an object to an archive (usually through the global insertion operator), a check is made for a NULL <b>CObject</b> pointer; if the pointer is NULL, the wNullTag is inserted into the archive stream.</p>
<p>
If we have a real object pointer that is capable of being serialized (the class is a <b>DECLARE_SERIAL</b> class), we then check the <b>m_pStoreMap</b> to see if the object has been saved already. If it has, we insert the 32-bit PID associated with that object.</p>
<p>
If the object has not been saved before, there are two possibilities we must take into account: either both the object and the exact type (that is, class) of the object are new to this archive context, or the object is of an exact type already seen. To determine if the type has been seen we query the <b>m_pStoreMap</b> for a <b>CRuntimeClass</b> object that matches the <b>CRuntimeClass</b> object associated with the object we are saving. If we have seen this class before, <b>WriteObject</b> inserts a tag that is the bit-wise OR'ing of wOldClassTag and this index. If the <b>CRuntimeClass</b> is new to this archive context, then <b>WriteObject</b> assigns a new PID to that class and insert it into the archive, preceded by the <b>wNewClassTag</b> value.</p>
<p>
The descriptor for this class is then inserted into the archive using the <b>CRuntimeClass</b> member function <b>Store</b>. <b>CRuntimeClass::Store</b> inserts the schema number of the class (see below) and the ASCII text name of the class. Note that the use of the ASCII text name does not guarantee uniqueness of the archive across applications, thus it is advisable to tag your data files to prevent corruption. Following the insertion of the class information, the archive places the object into the <b>m_pStoreMap</b> and then calls the <b>Serialize</b> member function to insert class-specific data into the archive. Placing the object into the <b>m_pStoreMap</b> before calling <b>Serialize</b> prevents multiple copies of the object from being saved to the store.</p>
<p>
When returning to the initial caller (usually the root of the network of objects), it is important to <b>Close</b> the archive. If other <b>CFile</b> operations are going to be done, the <b>CArchive</b> member function <b>Flush</b> MUST be called. Failure to do so will result in a corrupt archive.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;This implementation imposes a hard limit of 0x3FFFFFFE indices per archive context. This number represents the maximum number of unique objects and classes that can be saved in a single archive, but note that a single disk file can have an unlimited number of archive contexts.</p>
<p class=label>
<b>Loading Objects from the Store (CArchive::ReadObject)</b></p>
<p>
Loading (extracting) objects uses the <b>CArchive::ReadObject</b> member function and is the converse of <b>WriteObject</b>. As with <b>WriteObject</b>, <b>ReadObject</b> is not called directly by user code; user code should call the type-safe extraction operator which calls <b>ReadObject</b> with the expected <b>CRuntimeClass</b>. This insures the type integrity of the extract operation.</p>
<p>
Since the <b>WriteObject</b> implementation assigned increasing PIDs, starting with 1 (0 is predefined as the NULL object), the <b>ReadObject</b> implementation can use an array to maintain the state of the archive context. When a PID is read from the store, if the PID is greater than the current upper bound of the <b>m_pLoadArray</b>, then <b>ReadObject</b> knows that a new object (or class description) follows.</p>
<p class=label>
<b>Schema Numbers</b></p>
<p>
The schema number, which is assigned to the class when the class' <b>IMPLEMENT_SERIAL</b> is encountered, is the "version" of the class implementation. The schema refers to the implementation of the class, not to the number of times a given object has been made persistent (usually referred to as the object version).</p>
<p>
If you intend to maintain several different implementations of the same class over time, incrementing the schema as you revise your object's <b>Serialize</b> member function implementation will enable you to write code that can load objects stored using older versions of the implementation.&nbsp; </p>
<p>
The <b>CArchive::ReadObject</b> member function will throw a <b>CArchiveException</b> when it encounters a schema number in the persistent store that differs from the schema number of the class description in memory. It is not easy to recover from this exception.</p>
<p>
You can use <b>VERSIONABLE_SCHEMA</b> OR'd with your schema version to keep this exception from being thrown. By using <b>VERSIONABLE_SCHEMA</b>, your code can take the appropriate action in its <b>Serialize</b> function by checking the return value from <b>CArchive::GetObjectSchema</b>.</p>
<p class=label>
<b>Calling Serialize Directly</b></p>
<p>
There are many cases where the overhead of the general object archive scheme of <b>WriteObject</b> and <b>ReadObject</b> is not necessary or desired. This is the common case of serializing the data into a <b>CDocument</b>. In this case the <b>Serialize</b> member function of the <b>CDocument</b> is called directly, not with the extract or insert operators. The contents of the document may in turn use the more general object archive scheme.</p>
<p>
Calling <b>Serialize</b> directly has the following advantages and disadvantages:
<ul type=disc>
<li>
No extra bytes are added to the archive before or after the object is serialized. This not only makes the saved data smaller, but allows you to implement <b>Serialize</b> routines that can handle any file formats.<br><br></li>
<li>
The MFC is tuned so the <b>WriteObject</b> and <b>ReadObject</b> implementations and related collections will not be linked into your application unless you need the more general object archive scheme for some other purpose.<br><br></li>
<li>
Your code does not need to recover from old schema numbers. This makes your document serialization code responsible for encoding schema numbers, file format version numbers or whatever magic numbers desired at the start of your data files.<br><br></li>
<li>
Any object that is serialized with a direct call to <b>Serialize</b> must not use <b>CArchive::GetObjectSchema</b> or must handle a return value of <b>(UINT)-1</b> indicating that the version was unknown.</li>
</ul>
<p>
Because <b>Serialize</b> is called directly on your document, it is not usually possible for the sub-objects of the document to archive references to their parent document. These objects must be given a pointer to their container document explicitly or you must use <b>CArchive::MapObject</b> function to map the <b>CDocument</b> pointer to a PID before these back pointers are archived.</p>
<p>
As noted above, you should encode the version and class information yourself when calling Serialize directly, allowing you to change the format later while still maintaining backward compatibility with older files. The <b>CArchive::SerializeClassRef</b> function can be called explicitly before directly serializing an object or before calling a base class.</p>
<p>
<a href="_mfcnotes_technical_notes_by_number.htm">Technical Notes by Number</a>  |&nbsp; <a href="_mfcnotes_technical_notes_by_category.htm">Technical Notes by Category</a></p>
</font></BODY>
</HTML>
