<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Dynamically Determining Columns Returned to the Consumer</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY>
<font face="verdana,arial,helvetica" size="2">
<h1><a name="vchowdynamicallydeterminingcolumnsreturnedtoconsumer"></a>Dynamically Determining Columns Returned to the Consumer</h1>
<p>
The <b>PROVIDER_COLUMN_ENTRY</b> macros normally handle the <b>IColumnsInfo::GetColumnsInfo</b> call. Since a consumer may or may not choose to use bookmarks, however, the provider must be able to change the columns returned depending upon whether or not the consumer asks for a bookmark.</p>
<p>
To handle the <b>IColumnsInfo::GetColumnsInfo</b> call, delete the <b>PROVIDER_COLUMN_MAP</b> (which defines a function <code>_GetColumnInfo</code>) from the <code>CAgentMan</code> user record in MyProviderRS.h and replace it with the definition for your own <code>_GetColumnInfo</code> function: </p>
<pre><code>////////////////////////////////////////////////////////////////////////
// MyProviderRS.H
class CAgentMan
{
public:
   DWORD dwBookmark;
   TCHAR szCommand[256];
   TCHAR szText[256];
   TCHAR szCommand2[256];
   TCHAR szText2[256];

   static ATLCOLUMNINFO* _GetColumnInfo(void* pThis, ULONG* pcCols);
   bool operator==(const CAgentMan&amp; am)
   {
      return (lstrcmpi(szCommand, am.szCommand) == 0);
   }

};
</code></pre>
<p>
Next, implement the <code>_GetColumnInfo</code> function in MyProviderRS.cpp, as shown in the following code.</p>
<p>
<code>_GetColumnInfo</code> checks first to see if the OLE DB property <b>DBPROP_IRowsetLocate </b>is set. To get the property, <code>_GetColumnInfo</code> uses a pointer (<code>pRowset</code>) to the rowset object. The <code>pThis</code> pointer represents the class that created the rowset (which is the class where the property map is stored). <b>_</b><code>GetColumnInfo</code> typecasts the <code>pThis</code> pointer to a <code>RMyProviderRowset</code> pointer.</p>
<p>
To check for the <b>DBPROP_IRowsetLocate </b>property, <code>_GetColumnInfo</code> uses the <b>IRowsetInfo</b> interface, which you can obtain by calling <b>QueryInterface</b> on the <code>pRowset</code> interface. (As an alternative, you can use an ATL <a href="_atl_ccomqiptr.htm">CComQIPtr</a> instead.)</p>
<pre><code>////////////////////////////////////////////////////////////////////
// MyProviderRS.cpp
ATLCOLUMNINFO* CAgentMan::_GetColumnInfo(void* pThis, ULONG* pcCols)
{
   static ATLCOLUMNINFO _rgColumns[5];
   ULONG ulCols = 0;
            
   // Check the property flag for bookmarks, if it is set, set the zero ordinal
   // entry in the column map with the bookmark information.
   CAgentRowset* pRowset = (CAgentRowset*) pThis;
   CComQIPtr&lt;IRowsetInfo, &amp;IID_IRowsetInfo&gt; spRowsetProps = pRowset;

   CDBPropIDSet set(DBPROPSET_ROWSET);
   set.AddPropertyID(DBPROP_BOOKMARKS);
   DBPROPSET* pPropSet = NULL;
   ULONG ulPropSet = 0;
   HRESULT hr;

   if (spRowsetProps)
      hr = spRowsetProps-&gt;GetProperties(1, &amp;set, &amp;ulPropSet, &amp;pPropSet);

   if (pPropSet)
   {
      CComVariant var = pPropSet-&gt;rgProperties[0].vValue;
      CoTaskMemFree(pPropSet-&gt;rgProperties);
      CoTaskMemFree(pPropSet);
      
      if (SUCCEEDED(hr) &amp;&amp; (var.boolVal == VARIANT_TRUE))
      {
         ADD_COLUMN_ENTRY_EX(ulCols, OLESTR("Bookmark"), 0, sizeof(DWORD), DBTYPE_BYTES, 
            0, 0, GUID_NULL, CAgentMan, dwBookmark, DBCOLUMNFLAGS_ISBOOKMARK)
         ulCols++;
      }
   }

   // Next set the other columns up.
   ADD_COLUMN_ENTRY(ulCols, OLESTR("Command"), 1, 256, DBTYPE_STR, 0xFF, 0xFF, 
      GUID_NULL, CAgentMan, szCommand)
   ulCols++;
   ADD_COLUMN_ENTRY(ulCols, OLESTR("Text"), 2, 256, DBTYPE_STR, 0xFF, 0xFF, 
      GUID_NULL, CAgentMan, szText)
   ulCols++;

   ADD_COLUMN_ENTRY(ulCols, OLESTR("Command2"), 3, 256, DBTYPE_STR, 0xFF, 0xFF, 
      GUID_NULL, CAgentMan, szCommand2)
   ulCols++;
   ADD_COLUMN_ENTRY(ulCols, OLESTR("Text2"), 4, 256, DBTYPE_STR, 0xFF, 0xFF, 
      GUID_NULL, CAgentMan, szText2)
   ulCols++;

   if (pcCols != NULL)
      *pcCols = ulCols;

   return _rgColumns;
}
</code></pre>
<p>
This example uses a static array to contain the column information. If the consumer does not want the bookmark column, one entry in the array is unused. To handle the information, you create two array macros, <b>ADD_COLUMN_ENTRY</b> and <b>ADD_COLUMN_ENTRY_EX</b>. <b>ADD_COLUMN_ENTRY_EX</b> takes an extra parameter, <code>flags</code>, that is needed if you designate a bookmark column.</p>
<pre><code>////////////////////////////////////////////////////////////////////////
// MyProviderRS.h

#define ADD_COLUMN_ENTRY(ulCols, name, ordinal, colSize, type, precision, scale, guid, dataClass, member) \
   _rgColumns[ulCols].pwszName = (LPOLESTR)name; \
   _rgColumns[ulCols].pTypeInfo = (ITypeInfo*)NULL; \
   _rgColumns[ulCols].iOrdinal = (ULONG)ordinal; \
   _rgColumns[ulCols].dwFlags = 0; \
   _rgColumns[ulCols].ulColumnSize = (ULONG)colSize; \
   _rgColumns[ulCols].wType = (DBTYPE)type; \
   _rgColumns[ulCols].bPrecision = (BYTE)precision; \
   _rgColumns[ulCols].bScale = (BYTE)scale; \
   _rgColumns[ulCols].cbOffset = offsetof(dataClass, member);

#define ADD_COLUMN_ENTRY_EX(ulCols, name, ordinal, colSize, type, precision, scale, guid, dataClass, member, flags) \
   _rgColumns[ulCols].pwszName = (LPOLESTR)name; \
   _rgColumns[ulCols].pTypeInfo = (ITypeInfo*)NULL; \
   _rgColumns[ulCols].iOrdinal = (ULONG)ordinal; \
   _rgColumns[ulCols].dwFlags = flags; \
   _rgColumns[ulCols].ulColumnSize = (ULONG)colSize; \
   _rgColumns[ulCols].wType = (DBTYPE)type; \
   _rgColumns[ulCols].bPrecision = (BYTE)precision; \
   _rgColumns[ulCols].bScale = (BYTE)scale; \
   _rgColumns[ulCols].cbOffset = offsetof(dataClass, member); \
   memset(&amp;(_rgColumns[ulCols].columnid), 0, sizeof(DBID)); \
   _rgColumns[ulCols].columnid.uName.pwszName = (LPOLESTR)name;
</code></pre>
<p>
In the <code>_GetColumnInfo</code> function, the bookmark macro is used like this:</p>
<pre><code>ADD_COLUMN_ENTRY_EX(ulCols, OLESTR("Bookmark"), 0, sizeof(DWORD),
   DBTYPE_BYTES, 0, 0, GUID_NULL, CAgentMan, dwBookmark, 
   DBCOLUMNFLAGS_ISBOOKMARK)
</code></pre>
<p>
You can now compile and run the enhanced provider. To test the provider, modify the test consumer, as described in <a href="vchowmodifyingconsumerforusewithenhancedprovider.htm">Modifying the Consumer for Use with the Enhanced Provider</a>. Run the test consumer with the provider. Verify that the test consumer retrieves the proper strings from the provider when you click the <b>Run</b> button on the test consumer dialog box.</p>
<p>
<a href="vchowimplementingoledbtemplateprovider.htm">Back to Implementing an OLE DB Template Provider</a></p>
</font></BODY>
</HTML>
