<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>TN061: ON_NOTIFY and WM_NOTIFY Messages</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY>
<font face="verdana,arial,helvetica" size="2">
<h1><a name="_mfcnotes_tn061"></a>TN061: ON_NOTIFY and WM_NOTIFY Messages</h1>
<p>
This technical note provides background information on the new <b>WM_NOTIFY</b> message and describes the recommended (and most common) way of handling <b>WM_NOTIFY</b> messages in your MFC application.</p>
<p class=label>
<b><a name="_mfcnotes_notification_messages_in_windows_3..x"></a>Notification Messages in Windows 3.x</b></p>
<p>
In Windows 3.x, controls notify their parents of events such as mouse clicks, changes in content and selection, and control background painting by sending a message to the parent. Simple notifications are sent as special <b>WM_COMMAND</b> messages, with the notification code (such as <b>BN_CLICKED</b>) and control ID packed into <i>wParam</i> and the control’s handle in <i>lParam</i>. Note that since <i>wParam</i> and <i>lParam</i> are full, there is no way to pass any additional data — these messages can be only simple notification. For instance, in the <b>BN_CLICKED</b> notification, there’s no way to send information about the location of the mouse cursor when the button was clicked.</p>
<p>
When controls in Windows 3.x need to send a notification message that includes additional data, they use a variety of special-purpose messages, including <b>WM_CTLCOLOR</b>, <b>WM_VSCROLL</b>, <b>WM_HSCROLL</b>, <b>WM_DRAWITEM</b>, <b>WM_MEASUREITEM</b>, <b>WM_COMPAREITEM</b>, <b>WM_DELETEITEM</b>, <b>WM_CHARTOITEM</b>, <b>WM_VKEYTOITEM</b>, and so on. These messages can be reflected back to the control that sent them. For more information, see <a href="_mfcnotes_tn062.htm">TN062: Message Reflection for Windows Controls</a>.</p>
<p class=label>
<b><a name="_mfcnotes_notification_messages_in_win32"></a>Notification Messages in Win32</b></p>
<p>
For controls that existed in Windows 3.1, the Win32 API uses most of the notification messages that were used in Windows 3.x. However, Win32 also adds a number of sophisticated, complex controls to those supported in Windows 3.x. Frequently, these controls need to send additional data with their notification messages. Rather than adding a new <b>WM_*</b> message for each new notification that needs additional data, the designers of the Win32 API chose to add just one message, <b>WM_NOTIFY</b>, which can pass any amount of additional data in a standardized fashion.</p>
<p>
<b>WM_NOTIFY</b> messages contain the ID of the control sending the message in <i>wParam</i> and a pointer to a structure in <i>lParam</i>. This structure is either an <b>NMHDR</b> structure or some larger structure that has an <b>NMHDR</b> structure as its first member. Note that since the <b>NMHDR</b> member is first, a pointer to this structure can be used as either a pointer to an <b>NMHDR</b> or as a pointer to the larger structure depending on how you cast it.</p>
<p>
In most cases, the pointer will point to a larger structure and you’ll need to cast it when you use it. In only a few notifications, such as the common notifications (whose names start with <b>NM_</b>) and the tool tip control’s <b>TTN_SHOW</b> and <b>TTN_POP</b> notifications, is an <b>NMHDR</b> structure actually used.</p>
<p>
The <b>NMHDR</b> structure or initial member contains the handle and ID of the control sending the message and the notification code (such as <b>TTN_SHOW</b>). The format of the <b>NMHDR</b> structure is shown below:</p>
<pre><code>typedef struct tagNMHDR {
 &nbsp;&nbsp; HWND hwndFrom;
 &nbsp;&nbsp; UINT idFrom;
 &nbsp;&nbsp; UINT code;
} NMHDR;
</code></pre>
<p>
For a <b>TTN_SHOW</b> message, the <b>code</b> member would be set to <b>TTN_SHOW</b>.</p>
<p>
Most notifications pass a pointer to a larger structure that contains an <b>NMHDR</b> structure as its first member. For instance, consider the structure used by the list view control’s <b>LVN_KEYDOWN</b> notification message, which is sent when a key is pressed in a list view control. The pointer points to an <b>LV_KEYDOWN</b> structure, which is defined as shown below:</p>
<pre><code>typedef struct tagLV_KEYDOWN {
 &nbsp;&nbsp; NMHDR hdr;&nbsp;&nbsp; 
 &nbsp;&nbsp; WORD wVKey;&nbsp; 
 &nbsp;&nbsp; UINT flags;&nbsp; 
} LV_KEYDOWN;
</code></pre>
<p>
Note that since the <b>NMHDR</b> member is first in this structure, the pointer you’re passed in the notification message can be cast to either a pointer to an <b>NMHDR</b> or a pointer to an <b>LV_KEYDOWN</b>.</p>
<p class=label>
<b><a name="_mfcnotes_notifications_common_to_all_new_windows_common_controls"></a>Notifications Common to All New Windows Controls</b></p>
<p>
Some notifications are common to all of the new Windows controls. These notifications pass a pointer to an <b>NMHDR</b> structure.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=31%><b>Notification code</b></td>
<td class=label width=69%><b>Sent because</b></td>
</tr>
<tr valign=top>
<td width=31%><b>NM_CLICK</b></td>
<td width=69%>User clicked left mouse button in the control</td>
</tr>
<tr valign=top>
<td width=31%><b>NM_DBLCLK</b></td>
<td width=69%>User double-clicked left mouse button in the control</td>
</tr>
<tr valign=top>
<td width=31%><b>NM_RCLICK</b></td>
<td width=69%>User clicked right mouse button in the control</td>
</tr>
<tr valign=top>
<td width=31%><b>NM_RDBLCLK</b></td>
<td width=69%>User double-clicked right mouse button in the control</td>
</tr>
<tr valign=top>
<td width=31%><b>NM_RETURN</b></td>
<td width=69%>User pressed the ENTER key while control has input focus</td>
</tr>
<tr valign=top>
<td width=31%><b>NM_SETFOCUS</b></td>
<td width=69%>Control has been given input focus</td>
</tr>
<tr valign=top>
<td width=31%><b>NM_KILLFOCUS</b></td>
<td width=69%>Control has lost input focus</td>
</tr>
<tr valign=top>
<td width=31%><b>NM_OUTOFMEMORY</b></td>
<td width=69%>Control could not complete an operation because there was not enough memory available</td>
</tr>
</table><br>
<p class=label>
<b><a name="_mfcnotes_on_notify.3a_.handling_wm_notify_messages_in_mfc_applications"></a>ON_NOTIFY: Handling WM_NOTIFY Messages in MFC Applications</b></p>
<p>
The function <b>CWnd::OnNotify</b> handles notification messages. Its default implementation checks the message map for notification handlers to call. In general, you do not override <b>OnNotify</b>. Instead, you provide a handler function and add a message-map entry for that handler to the message map of your owner window’s class.</p>
<p>
ClassWizard, via either the ClassWizard property sheet or the WizardBar, can create the <b>ON_NOTIFY</b> message-map entry and provide you with a skeleton handler function. For more information on using ClassWizard to make this easier, see <object id=alink_1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="DefaultTopic" value="_topic_not_found.htm">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="_core_Mapping_Messages_to_Functions">
</object><a href=JavaScript:alink_1.Click()>Mapping Messages to Functions</a> in the <i>Visual C++ Programmer's Guide</i>.</p>
<p>
The <b>ON_NOTIFY</b> message-map macro has the following syntax:</p>
<p>
<b>ON_NOTIFY(</b> <i>wNotifyCode</i><b>,</b> <i>id</i><b>,</b> <i>memberFxn</i> <b>)</b></p>
<p>
where the italicized parameters are replaced with:</p>
<p class=dt>
<i>wNotifyCode</i></p>
<p class=indent>
The code for the notification message to be handled, such as <b>LVN_KEYDOWN</b>.</p>
<p class=dt>
<i>id</i></p>
<p class=indent>
The child identifier of the control for which the notification is sent.</p>
<p class=dt>
<i>memberFxn</i></p>
<p class=indent>
The member function to be called when this notification is sent.</p>
<p>
Your member function must be declared with the following prototype:</p>
<p>
<b>afx_msg</b> <b>void</b> <i>memberFxn</i><b>(</b> <b>NMHDR</b> <b>*</b> <i>pNotifyStruct</i><b>,</b> <b>LRESULT</b> <b>*</b> <i>result</i> <b>);</b></p>
<p>
where the italicized parameters are:</p>
<p class=dt>
<i>pNotifyStruct</i></p>
<p class=indent>
A pointer to the notification structure, as described in the section above.</p>
<p class=dt>
<i>result</i></p>
<p class=indent>
A pointer to the result code you’ll set before you return.</p>
<p class=label>
<b>Example</b></p>
<p>
To specify that you want the member function <code>OnKeydownList1</code> to handle <b>LVN_KEYDOWN</b> messages from the <b>CListCtrl</b> whose ID is <code>IDC_LIST1</code>, you would use ClassWizard to add the following to your message map:</p>
<pre><code>ON_NOTIFY( LVN_KEYDOWN, IDC_LIST1, OnKeydownList1 )
</code></pre>
<p>
In the example above, the function provided by ClassWizard is:</p>
<pre><code>void CMessageReflectionDlg::OnKeydownList1(NMHDR* pNMHDR, LRESULT* pResult)
{
   LV_KEYDOWN* pLVKeyDow = (LV_KEYDOWN*)pNMHDR;
   // TODO: Add your control notification handler
   //    &nbsp;&nbsp; code here
   
   *pResult = 0;
}
</code></pre>
<p>
Note that ClassWizard provides a pointer of the proper type automatically. You can access the notification structure through either <code>pNMHDR</code> or <code>pLVKeyDow</code>.</p>
<p class=label>
<b><a name="_mfcnotes_on_notify_range"></a>ON_NOTIFY_RANGE</b></p>
<p>
If you need to process the same <b>WM_NOTIFY</b> message for a set of controls, you can use <b>ON_NOTIFY_RANGE</b> rather than <b>ON_NOTIFY</b>. For instance, you may have a set of buttons for which you want to perform the same action for a certain notification message.</p>
<p>
When you use <b>ON_NOTIFY_RANGE</b>, you specify a contiguous range of child identifiers for which to handle the notification message by specifying the beginning and ending child identifiers of the range.</p>
<p>
ClassWizard does not handle <b>ON_NOTIFY_RANGE</b>; to use it, you need to edit your message map yourself.</p>
<p>
The message-map entry and function prototype for <b>ON_NOTIFY_RANGE</b> are as follows:</p>
<p>
<b>ON_NOTIFY_RANGE( </b><i>wNotifyCode</i><b>, </b><i>id</i><b>, </b><i>idLast</i><b>, </b><i>memberFxn</i><b> )</b></p>
<p>
where the italicized parameters are replaced with:</p>
<p class=dt>
<i>wNotifyCode</i></p>
<p class=indent>
The code for the notification message to be handled, such as <b>LVN_KEYDOWN</b>.</p>
<p class=dt>
<i>id</i></p>
<p class=indent>
The first identifier in the contiguous range of identifiers.</p>
<p class=dt>
<i>idLast</i></p>
<p class=indent>
The last identifier in the contiguous range of identifiers.</p>
<p class=dt>
<i>memberFxn</i></p>
<p class=indent>
The member function to be called when this notification is sent.</p>
<p>
Your member function must be declared with the following prototype:</p>
<p>
<b>afx_msg</b> <b>void</b> <i>memberFxn</i><b>(</b> <b>UINT </b><i>id</i><b>, NMHDR</b> <b>*</b> <i>pNotifyStruct</i><b>,</b> <b>LRESULT</b> <b>*</b> <i>result</i> <b>);</b></p>
<p>
where the italicized parameters are:</p>
<p class=dt>
<i>id</i></p>
<p class=indent>
The child identifier of the control that sent the notification.</p>
<p class=dt>
<i>pNotifyStruct</i></p>
<p class=indent>
A pointer to the notification structure, as described above.</p>
<p class=dt>
<i>result</i></p>
<p class=indent>
A pointer to the result code you’ll set before you return.</p>
<p class=label>
<b><a name="_mfcnotes_tn061_on_notify_ex.2c_.on_notify_ex_range"></a>ON_NOTIFY_EX, ON_NOTIFY_EX_RANGE</b></p>
<p>
If you want more than one object in the notification routing to handle a message, you can use <b>ON_NOTIFY_EX</b> (or <b>ON_NOTIFY_EX_RANGE</b>) rather than <b>ON_NOTIFY</b> (or <b>ON_NOTIFY_RANGE</b>). The only difference between the <b>EX</b> version and the regular version is that the member function called for the <b>EX</b> version returns a <b>BOOL</b> that indicates whether or not message processing should continue. Returning <b>FALSE</b> from this function allows you to process the same message in more than one object.</p>
<p>
ClassWizard does not handle <b>ON_NOTIFY_EX</b> or <b>ON_NOTIFY_EX_RANGE</b>; if you want to use either of them, you need to edit your message map yourself.</p>
<p>
The message-map entry and function prototype for <b>ON_NOTIFY_EX</b> and <b>ON_NOTIFY_EX_RANGE</b> are as follows. The meanings of the parameters are the same as for the non-<b>EX</b> versions.</p>
<p>
<b>ON_NOTIFY_EX(</b> <i>nCode</i><b>,</b> <i>id</i><b>,</b> <i>memberFxn</i> <b>)</b></p>
<p>
<b>ON_NOTIFY_EX_RANGE( </b><i>wNotifyCode</i><b>, </b><i>id</i><b>, </b><i>idLast</i><b>,</b> <i>memberFxn</i><b> )</b></p>
<p>
The prototype for both of the above is the same:</p>
<p>
<b>afx_msg</b> <b>BOOL</b> <i>memberFxn</i><b>(</b> <b>UINT </b><i>id</i><b>, NMHDR</b> <b>*</b> <i>pNotifyStruct</i><b>,</b> <b>LRESULT</b> <b>*</b> <i>result</i> <b>);</b></p>
<p>
In both cases, <i>id</i> holds the child identifier of the control that sent the notification.</p>
<p>
Your function must return <b>TRUE</b> if the notification message has been completely handled or <b>FALSE</b> if other objects in the command routing should have a chance to handle the message.</p>
<p>
<a href="_mfcnotes_technical_notes_by_number.htm">Technical Notes by Number</a>  |&nbsp; <a href="_mfcnotes_technical_notes_by_category.htm">Technical Notes by Category</a></p>
</font></BODY>
</HTML>
