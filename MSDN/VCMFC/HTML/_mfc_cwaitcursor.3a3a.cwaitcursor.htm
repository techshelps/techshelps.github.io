<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CWaitCursor::CWaitCursor</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY>
<font face="verdana,arial,helvetica" size="2">
<h1><a name="_mfc_cwaitcursor.3a3a.cwaitcursor"></a>CWaitCursor::CWaitCursor</h1>
<p>
<b>CWaitCursor( );</b></p>
<p class=label>
<b>Remarks</b></p>
<p>
To display a wait cursor, just declare a <b>CWaitCursor</b> object before the code that performs the lengthy operation.<b> </b>The constructor<b> </b>automatically causes the wait cursor to be displayed.</p>
<p>
When the object goes out of scope (at the end of the block in which the <b>CWaitCursor</b> object is declared), its destructor sets the cursor to the previous cursor. In other words, the object performs the necessary clean-up automatically.</p>
<p>
You can take advantage of the fact that the destructor is called at the end of the block (which might be before the end of the function) to make the wait cursor active in only part of your function. This technique is shown in the second example below.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;Because of how their constructors and destructors work, <b>CWaitCursor</b> objects are always declared as local variables — they’re never declared as global variables, nor are they allocated with <b>new</b>.</p>
<p class=label>
<b>Example</b></p>
<pre><code>// The following example illustrates the most common case
// of displaying the wait cursor during some lengthy
// processing.

void LengthyFunction( )
{
 &nbsp; // perhaps you display a dialog box before displaying a
 &nbsp; // wait cursor

 &nbsp; CWaitCursor wait;   // display wait cursor

 &nbsp; // do some lengthy processing

}&nbsp; // destructor automatically removes the wait cursor

// This example shows using a CWaitCursor object inside a block
// so the wait cursor is displayed only while the program is
// performing a lengthy operation.

void ConditionalFunction( )
{
 &nbsp; if ( SomeCondition )
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; CWaitCursor wait;   // display wait cursor in this block only

 &nbsp;&nbsp;&nbsp;&nbsp; // do some lengthy processing

 &nbsp; }&nbsp; // at this point, the destructor removes the wait cursor
 &nbsp; else
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; // no wait cursor--only quick processing
 &nbsp; }
}
</code></pre>
<p>
<a href="_mfc_cwaitcursor.htm">CWaitCursor Overview</a>  |&nbsp; <a href="_mfc_hierarchy_chart.htm">Hierarchy Chart</a></p>
<p>
<b>See Also</b>&nbsp;&nbsp;&nbsp;<a href="_mfc_cwaitcursor.3a3a.restore.htm">CWaitCursor::Restore</a>, <a href="_mfc_ccmdtarget.3a3a.beginwaitcursor.htm">CCmdTarget::BeginWaitCursor</a>, <a href="_mfc_ccmdtarget.3a3a.endwaitcursor.htm">CCmdTarget::EndWaitCursor</a></p>
</font></BODY>
</HTML>
