<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>TN041: MFC/OLE1 Migration to MFC/OLE 2</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY>
<font face="verdana,arial,helvetica" size="2">
<h1><a name="_mfcnotes_tn041"></a><sup></sup>TN041: MFC/OLE1 Migration to MFC/OLE 2</h1>
<p class=label>
<b>General Issues Relating to Migration</b></p>
<p>
One of the design goals for the OLE 2 classes in MFC 2.5 (and higher) was to retain much of the same architecture put in place in MFC 2.0 for OLE 1.0 support. As a result, many of the same OLE classes in MFC 2.0 still exist in this version of MFC (<b>COleDocument</b>, <b>COleServerDoc</b>, <b>COleClientItem</b>, <b>COleServerItem</b>). In addition, many of the APIs in these classes are exactly the same. However, OLE 2 is drastically different from OLE 1.0 so you can expect that some of the details have changed. If you are familiar with MFC 2.0's OLE1 support, you'll feel at home with MFC's 2.0 support.</p>
<p>
If you are taking an existing MFC/OLE1 application and adding OLE 2 functionality to it, you should read this note first. This note covers some general issues you may encounter while porting your OLE1 functionality to MFC/OLE 2 and then discusses the problems uncovered while porting two applications included in MFC 2.0: the MFC OLE samples <object id=alink_1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="DefaultTopic" value="_topic_not_found.htm">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="_sample_mfc_OCLIENT">
</object><a href=JavaScript:alink_1.Click()>OCLIENT</a> and <object id=alink_2 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="DefaultTopic" value="_topic_not_found.htm">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="_sample_mfc_HIERSVR">
</object><a href=JavaScript:alink_2.Click()>HIERSVR</a>.</p>
<p class=label>
<b>MFC Document/View Architecture Is Important</b></p>
<p>
If your application does not use MFC's Document/View architecture and you want to add OLE 2 support to your application, now is the time to move to Document/View. Many of the benefits of MFC's OLE 2 classes are only realized once your application is using the built-in architecture and components of MFC.</p>
<p>
Implementing a server or container without using the MFC architecture is possible, but not recommended.</p>
<p class=label>
<b>Use MFC Implementation Instead of Your Own</b></p>
<p>
MFC "canned implementation" classes such as <b>CToolBar</b>, <b>CStatusBar</b>, and <b>CScrollView</b> have built-in special case code for OLE 2 support. So, if you can use these classes in your application you'll benefit from the effort put into them to make them OLE aware. Again, it is possible to "roll-your-own" classes here for these purposes, but it is not suggested. If you need to implement similar functionality, the MFC source code is an excellent reference for dealing with some of the finer points of OLE (especially when it comes to in-place activation).</p>
<p class=label>
<b>Examine the MFC Sample Code</b></p>
<p>
There are a number of MFC samples that include OLE functionality. Each of these applications implements OLE from a different angle:</p>
<p>
<object id=alink_3 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="DefaultTopic" value="_topic_not_found.htm">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="_sample_mfc_HIERSVR">
</object><a href=JavaScript:alink_3.Click()>HIERSVR</a> - Meant mostly for use as a server application. It was included in MFC 2.0 as an MFC/OLE1 application and has been ported to MFC/OLE 2 and then extended such that it implements many OLE features available in OLE 2.</p>
<p>
<object id=alink_4 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="DefaultTopic" value="_topic_not_found.htm">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="_sample_mfc_OCLIENT">
</object><a href=JavaScript:alink_4.Click()>OCLIENT</a> - This is a stand-alone container application, meant to demonstrate many of the OLE features from a container standpoint. It too was ported from MFC 2.0, and then extended to support many of the more advanced OLE features, such as custom clipboard formats and links to embedded items.</p>
<p>
<object id=alink_5 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="DefaultTopic" value="_topic_not_found.htm">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="_sample_mfc_DRAWCLI">
</object><a href=JavaScript:alink_5.Click()>DRAWCLI</a> - This application implements OLE container support much like OCLIENT does, except that it does so within the framework of an existing object-oriented drawing program. It shows you how you might implement OLE container support and integrate it into your existing application.</p>
<p>
<object id=alink_6 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="DefaultTopic" value="_topic_not_found.htm">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="_sample_mfc_SUPERPAD">
</object><a href=JavaScript:alink_6.Click()>SUPERPAD</a> - This application, as well as being a fine stand-alone application, is also an OLE server. The server support it implements is quite minimalist. Of particular interest is how it uses OLE clipboard services to copy data to the clipboard, but uses the functionality built into the Windows "edit" control to implement clipboard paste functionality. This shows an interesting mix of traditional Windows API usage as well as integration with the new OLE APIs.</p>
<p>
For more information on the sample applications see the "MFC Sample Help".</p>
<p class=label>
<b>Case Study: OCLIENT from MFC 2.0</b></p>
<p>
As discussed above, <object id=alink_7 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="DefaultTopic" value="_topic_not_found.htm">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="_sample_mfc_OCLIENT">
</object><a href=JavaScript:alink_7.Click()>OCLIENT</a> was included in MFC 2.0 and implemented OLE with MFC/OLE1. The steps by which this application was initially converted to use the MFC/OLE 2 classes are described below. A number of features were added after the initial port was completed to better illustrate the MFC/OLE classes. These features will not be covered here; refer to the sample itself for more information on those advanced features.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;The compiler errors and step-by-step process was created with Visual C++ 2.0. Specific error messages and locations may have changed with Visual C++ 4.0, but the conceptual information remains valid.</p>
<p class=label>
<b>Getting It Up and Running</b></p>
<p>
The approach taken to port the OCLIENT sample to MFC/OLE is to start by building it and fixing the obvious compiler errors that will result. If you take the OCLIENT sample from MFC 2.0 and compile it under this version of MFC, you'll find that there are not that many errors to resolve. The errors in the order in which they occurred are described below.</p>
<p class=label>
<b>Compile and Fix Errors</b></p>
<pre><code>\oclient\mainview.cpp(104) : error C2660: 'Draw' : function does not take 4 parameters
</code></pre>
<p>
The first error concerns <b>COleClientItem::Draw</b>. In MFC/OLE1 it took more parameters than the MFC/OLE version takes. The extra parameters were often not necessary and usually NULL (as in this example). This version of MFC can automatically determine the values for the lpWBounds when the CDC that is being drawn to is a metafile DC. In addition, the pFormatDC parameter is no longer necessary since the framework will build one from the "attribute DC" of the pDC passed in. So to fix this problem, you simply remove the two extra NULL parameters to the Draw call.</p>
<pre><code>\oclient\mainview.cpp(273) : error C2065: 'OLE_MAXNAMESIZE' : undeclared identifier
\oclient\mainview.cpp(273) : error C2057: expected constant expression
\oclient\mainview.cpp(280) : error C2664: 'CreateLinkFromClipboard' : cannot convert parameter 1 from 'char [1]' to 'enum ::tagOLERENDER '
\oclient\mainview.cpp(286) : error C2664: 'CreateFromClipboard' : cannot convert parameter 1 from 'char [1]' to 'enum ::tagOLERENDER '
\oclient\mainview.cpp(288) : error C2664: 'CreateStaticFromClipboard' : cannot convert parameter 1 from 'char [1]' to 'enum ::tagOLERENDER '
</code></pre>
<p>
The errors above result from the fact that all of the <b>COleClientItem::CreateXXXX</b> functions in MFC/OLE1 required that a unique name be passed to represent the item. This was a requirement of the underlying OLE API. This is not necessary in MFC/OLE 2 since OLE 2 does not use DDE as the underlying communications mechanism (the name was used in DDE conversations). To fix this problem, you can remove the <b>CreateNewName</b> function as well as all references to it. It is easy to find out what each MFC/OLE function is expecting in this version simply by placing your cursor on the call and pressing F1.</p>
<p>
Another area that is significantly different is OLE 2 clipboard handling. With OLE1, you used the Windows clipboard APIs interact with the clipboard. With OLE 2 this is done with a different mechanism. The MFC/OLE1 APIs assumed that the clipboard was open before copying a <b>COleClientItem</b> object to the clipboard. This is no longer necessary and will cause all MFC/OLE clipboard operations to fail. While you edit the code to remove dependencies on <b>CreateNewName</b>, you should also remove the code that opens and closes the Windows clipboard.</p>
<pre><code>\oclient\mainview.cpp(332) : error C2065: 'AfxOleInsertDialog' : undeclared identifier
\oclient\mainview.cpp(332) : error C2064: term does not evaluate to a function
\oclient\mainview.cpp(344) : error C2057: expected constant expression
\oclient\mainview.cpp(347) : error C2039: 'CreateNewObject' : is not a member of 'CRectItem'
</code></pre>
<p>
These errors result from the <b>CMainView::OnInsertObject</b> handler. Handling the "Insert New Object" command is another area where things have changed quite a bit. In this case, it is easiest to simply merge the original implementation with that provided by AppWizard for a new OLE Container application. In fact, this is a technique that you can apply to porting other applications. In MFC/OLE1, you displayed the "Insert Object" dialog by calling <b>AfxOleInsertDialog</b> function. In this version you construct a <b>COleInsertObject</b> dialog object and call <b>DoModal</b>. In addition, new OLE items are created with a <b>CLSID</b> instead of a classname string. The end result should look something like this </p>
<pre><code>COleInsertDialog dlg;
if (dlg.DoModal() != IDOK)
 &nbsp;&nbsp; return;

BeginWaitCursor();

CRectItem* pItem = NULL;
TRY
{
 &nbsp;&nbsp; // First create the C++ object
 &nbsp;&nbsp; pItem = GetDocument()-&gt;CreateItem();
 &nbsp;&nbsp; ASSERT_VALID(pItem);

 &nbsp;&nbsp; // Initialize the item from the dialog data.
 &nbsp;&nbsp; if (!dlg.CreateItem(pItem))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AfxThrowMemoryException();
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // any exception will do
 &nbsp;&nbsp; ASSERT_VALID(pItem);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp; // run the object if appropriate
 &nbsp;&nbsp; if (dlg.GetSelectionType() == 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; COleInsertDialog::createNewItem)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pItem-&gt;DoVerb(OLEIVERB_SHOW, this);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp; // update right away
 &nbsp;&nbsp; pItem-&gt;UpdateLink();
 &nbsp;&nbsp; pItem-&gt;UpdateItemRectFromServer();
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp; // set selection to newly inserted item
 &nbsp;&nbsp; SetSelection(pItem);
 &nbsp;&nbsp; pItem-&gt;Invalidate();
}
CATCH (CException, e)
{&nbsp; 
 &nbsp;&nbsp; // clean up item
 &nbsp;&nbsp; if (pItem != NULL)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GetDocument()-&gt;DeleteItem(pItem);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp; AfxMessageBox(IDP_FAILED_TO_CREATE);
}
END_CATCH
 &nbsp;&nbsp; 
EndWaitCursor();
</code></pre>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;Insert New Object may be different for your application):</p>
<p>
It is also necessary to include &lt;afxodlgs.h&gt; which contains the declaration for the <b>COleInsertObject</b> dialog class as well as the other standard dialogs provided by MFC.</p>
<pre><code>\oclient\mainview.cpp(367) : error C2065: 'OLEVERB_PRIMARY' : undeclared identifier
\oclient\mainview.cpp(367) : error C2660: 'DoVerb' : function does not take 1 parameters
</code></pre>
<p>
These errors are caused by the fact that some OLE1 constants have changed in OLE 2, even though in concept they are the same. In this case <b>OLEVERB_PRIMARY</b> has changed to <b>OLEIVERB_PRIMARY</b>. In both OLE1 and OLE 2, the primary verb is usually executed by a container when the user double-clicks on an item.</p>
<p>
In addition, <b>DoVerb</b> now takes an extra parameter — a pointer to a view (<b>CView</b>*). This parameter is only used to implement "Visual Editing" (or in-place activation). For now you set that parameter to NULL, since you are not implementing this feature at this time.</p>
<p>
To make sure that the framework never attempts to in-place activate, you should override <b>COleClientItem::CanActivate</b> as follows:</p>
<pre><code>BOOL CRectItem::CanActivate()
{
 &nbsp;&nbsp; return FALSE;
}

\oclient\rectitem.cpp(53) : error C2065: 'GetBounds' : undeclared identifier
\oclient\rectitem.cpp(53) : error C2064: term does not evaluate to a function
\oclient\rectitem.cpp(84) : error C2065: 'SetBounds' : undeclared identifier
\oclient\rectitem.cpp(84) : error C2064: term does not evaluate to a function
</code></pre>
<p>
In MFC/OLE1, <b>COleClientItem::GetBounds</b> and <b>SetBounds</b> were used to query and manipulate the extent of an item (the <b>left</b> and <b>top</b> members were always zero). In MFC/OLE 2 this is more directly supported by <b>COleClientItem::GetExtent</b> and <b>SetExtent</b>, which deal with a <b>SIZE</b> or <b>CSize</b> instead.</p>
<p>
The code for your new SetItemRectToServer, and UpdateItemRectFromServer calls look like this:</p>
<pre><code>BOOL CRectItem::UpdateItemRectFromServer()
{
 &nbsp; ASSERT(m_bTrackServerSize);
 &nbsp; CSize size;
 &nbsp; if (!GetExtent(&amp;size))
 &nbsp;&nbsp;&nbsp;&nbsp; return FALSE;&nbsp;&nbsp;&nbsp; // blank

 &nbsp; // map from HIMETRIC to screen coordinates
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; CClientDC screenDC(NULL);
 &nbsp;&nbsp;&nbsp;&nbsp; screenDC.SetMapMode(MM_HIMETRIC);
 &nbsp;&nbsp;&nbsp;&nbsp; screenDC.LPtoDP(&amp;size);
 &nbsp; }
 &nbsp; // just set the item size
 &nbsp; if (m_rect.Size() != size)
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; // invalidate the old size/position
 &nbsp;&nbsp;&nbsp;&nbsp; Invalidate();
 &nbsp;&nbsp;&nbsp;&nbsp; m_rect.right = m_rect.left + size.cx;
 &nbsp;&nbsp;&nbsp;&nbsp; m_rect.bottom = m_rect.top + size.cy;
 &nbsp;&nbsp;&nbsp;&nbsp; // as well as the new size/position
 &nbsp;&nbsp;&nbsp;&nbsp; Invalidate();
 &nbsp; }
 &nbsp; return TRUE;
}

BOOL CRectItem::SetItemRectToServer()
{
 &nbsp; // set the official bounds for the embedded item
 &nbsp; CSize size = m_rect.Size();
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; CClientDC screenDC(NULL);
 &nbsp;&nbsp;&nbsp;&nbsp; screenDC.SetMapMode(MM_HIMETRIC);
 &nbsp;&nbsp;&nbsp;&nbsp; screenDC.DPtoLP(&amp;size);
 &nbsp; }
 &nbsp; TRY
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; SetExtent(size);&nbsp; // may do a wait
 &nbsp; }
 &nbsp; CATCH(CException, e)
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; return FALSE;&nbsp; // links will not allow SetBounds
 &nbsp; }
 &nbsp; END_CATCH
 &nbsp; return TRUE;
}

\oclient\frame.cpp(50) : error C2039: 'InWaitForRelease' : is not a member of 'COleClientItem'
\oclient\frame.cpp(50) : error C2065: 'InWaitForRelease' : undeclared identifier
\oclient\frame.cpp(50) : error C2064: term does not evaluate to a function
</code></pre>
<p>
In MFC/OLE1 synchronous API calls from a container to a server were <i>simulated</i>, since OLE1 was inherently asynchronous in many cases. It was necessary to check for an outstanding asynchronous call in progress before processing commands from the user. MFC/OLE1 provided the <b>COleClientItem::InWaitForRelease</b> function for doing so. In MFC/OLE 2 this is not necessary, so you can to remove the override of OnCommand in CMainFrame all together.</p>
<p>
At this point OCLIENT will compile and link.</p>
<p class=label>
<b>Other Necessary Changes</b></p>
<p>
There are few things that aren't done that will keep OCLIENT from running, however. It is better to fix these problems now instead of later.</p>
<p>
First of all it is necessary to initialize the OLE libraries. This is done by calling <b>AfxOleInit</b> from <b>InitInstance</b>:</p>
<pre><code>if (!AfxOleInit())
{
  AfxMessageBox("Failed to initialize OLE libraries");
  return FALSE;
}
</code></pre>
<p>
It is also a good idea to check for virtual functions for parameter list changes. One such function is <b>COleClientItem::OnChange</b>, overridden in every MFC/OLE container application. By looking at online help, you'll see that an extra 'DWORD dwParam' was added. The new CRectItem::OnChange looks as follows:</p>
<pre><code>void 
CRectItem::OnChange(OLE_NOTIFICATION wNotification, DWORD dwParam)
{
  if (m_bTrackServerSize &amp;&amp;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; !UpdateItemRectFromServer())
  {
 &nbsp;&nbsp; // Blank object
 &nbsp;&nbsp; if (wNotification == OLE_CLOSED)
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; // no data received for the object - destroy it
 &nbsp;&nbsp;&nbsp;&nbsp; ASSERT(!IsVisible());
 &nbsp;&nbsp;&nbsp;&nbsp; GetDocument()-&gt;DeleteItem(this);
 &nbsp;&nbsp;&nbsp;&nbsp; return;&nbsp;&nbsp; // no update (item is gone now)
 &nbsp;&nbsp; }
  }
  if (wNotification != OLE_CLOSED)
 &nbsp;&nbsp;&nbsp;&nbsp; Dirty();
  Invalidate();&nbsp; // any change will cause a redraw
}
</code></pre>
<p>
In MFC/OLE1, container applications derived the document class from <b>COleClientDoc</b>. In MFC/OLE 2 this class has been removed and replaced by <b>COleDocument</b> (this new organization makes it easier to build container/server applications). There is a <b>#define</b> that maps <b>COleClientDoc</b> to <b>COleDocument</b> to simplify porting of MFC/OLE1 applications to MFC/OLE 2, such as OCLIENT. One of the features not supplied by <b>COleDocument</b> that was provided by <b>COleClientDoc</b> is the standard command message map entries. This is done so that server applications, which also use <b>COleDocument</b> (indirectly), do not carry with them the overhead of these command handlers unless they are a container/server application. So, you need to add the following entries to the CMainDoc message map:</p>
<pre><code>ON_UPDATE_COMMAND_UI(ID_EDIT_PASTE, OnUpdatePasteMenu)
ON_UPDATE_COMMAND_UI(ID_EDIT_PASTE_LINK, OnUpdatePasteLinkMenu)
ON_UPDATE_COMMAND_UI(ID_OLE_EDIT_LINKS, OnUpdateEditLinksMenu)
ON_COMMAND(ID_OLE_EDIT_LINKS, COleDocument::OnEditLinks)
ON_UPDATE_COMMAND_UI(ID_OLE_VERB_FIRST, OnUpdateObjectVerbMenu)
ON_UPDATE_COMMAND_UI(ID_OLE_EDIT_CONVERT, OnUpdateObjectVerbMenu)
ON_COMMAND(ID_OLE_EDIT_CONVERT, OnEditConvert)
</code></pre>
<p>
The implementation of all of these commands is in <b>COleDocument</b>, which is the base class for your document.</p>
<p>
At this point, OCLIENT is a functional OLE container application. It is possible to insert items of any type (OLE1 or OLE 2). Since the necessary code to enable in-place activation is not implemented, items are edited in a separate window much like with OLE1. The next section discusses the necessary changes to enable in-place editing (sometimes called "Visual Editing").</p>
<p class=label>
<b>Adding "Visual Editing"</b></p>
<p>
One of the most interesting features of OLE is in-place activation (or "Visual Editing"). This feature allows the server application to take over portions of the container's user interface to provided a more seamless editing interface for the user. To implement in-place activation to OCLIENT, some special resources need to be added, as well as some additional code. These resources and the code are normally provided by AppWizard — in fact, much of the code here was borrowed directly from a fresh AppWizard application with "Container" support.</p>
<p>
First of all, it is necessary to add a menu resource to be used when there is an item which is in-place active. You can create this extra menu resource in Visual C++ by copying the IDR_OCLITYPE resource and removing all but the File and Window popups. Two separator bars are inserted between the File and Window popups to indicate the separation of groups (it should look like: File | | Window). For more information on what these separators mean and how the server and container menus are merged see "Menus and Resources: Menu Merging" in <i>OLE 2 Classes</i>.</p>
<p>
Once you have these menus created, you need to let the framework know about them. This is done by calling <b>CDocTemplate::SetContainerInfo</b> for the document template before you add it to the document template list in your InitInstance. The new code to register the document template looks like this:</p>
<pre><code>CDocTemplate* pTemplate = new CMultiDocTemplate(
 &nbsp;&nbsp; IDR_OLECLITYPE,
 &nbsp;&nbsp; RUNTIME_CLASS(CMainDoc),
 &nbsp;&nbsp; RUNTIME_CLASS(CMDIChildWnd),&nbsp;&nbsp;&nbsp; // standard MDI child frame
 &nbsp;&nbsp; RUNTIME_CLASS(CMainView));
pTemplate-&gt;SetContainerInfo(IDR_OLECLITYPE_INPLACE);
AddDocTemplate(pTemplate);
</code></pre>
<p>
The IDR_OLECLITYPE_INPLACE resource is the special in-place resource created in Visual C++.</p>
<p>
In order to enable in-place activation, there are some things that need to change in both the <b>CView</b> (CMainView) derived class as well as the <b>COleClientItem</b> derived class (CRectItem). All of these overrides are provided by AppWizard and most of the implementation will come directly from a default AppWizard application.</p>
<p>
In the first step of this port, in-place activation was disabled entirely by overriding <b>COleClientItem::CanActivate</b>. This override should be removed to allow in-place activation. In addition, NULL was passed to all calls to <b>DoVerb</b> (there are two of them) because providing the view was only necessary for in-place activation. To fully implement in-place activation, it is necessary to pass the correct view in the <b>DoVerb</b> call. One of these calls is in <b>CMainView::OnInsertObject</b>:</p>
<pre><code>pItem-&gt;DoVerb(OLEIVERB_SHOW, this);
</code></pre>
<p>
Another is in <b>CMainView::OnLButtonDblClk</b>:</p>
<pre><code>m_pSelection-&gt;DoVerb(OLEIVERB_PRIMARY, this);
</code></pre>
<p>
It is necessary to override <b>COleClientItem::OnGetItemPosition</b>. This tells the server where to put its window relative to the container's window when the item is in-place activated. For OCLIENT, the implementation is trivial:</p>
<pre><code>void CRectItem::OnGetItemPosition(CRect&amp; rPosition)
{
 &nbsp;&nbsp; rPosition = m_rect;
}
</code></pre>
<p>
Most servers also implement what is called "in-place resizing." This allows the server window to be sized and moved while the user is editing the item. The container must participate in this action, since moving or resizing the window usually affects the position and size within the container document itself. The implementation for OCLIENT synchronizes the internal rectangle maintained by m_rect with the new position and size.</p>
<pre><code>BOOL CRectItem::OnChangeItemPosition(const CRect&amp; rectPos)
{
 &nbsp;&nbsp; ASSERT_VALID(this);

 &nbsp;&nbsp; if (!COleClientItem::OnChangeItemPosition(rectPos))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return FALSE;

 &nbsp;&nbsp; Invalidate();
 &nbsp;&nbsp; m_rect = rectPos;
 &nbsp;&nbsp; Invalidate();
 &nbsp;&nbsp; GetDocument()-&gt;SetModifiedFlag();

 &nbsp;&nbsp; return TRUE;
}
</code></pre>
<p>
At this point, there is enough code to allow an item to be in-place activated and to deal with sizing and moving the item when it is active, but there is no code that will allow the user to exit the editing session. Although some servers will provide this functionality themselves by handling the escape key, it is suggested that containers provide two ways to deactivate an item: (1) by clicking outside the item, and (2) by hitting the escape key.</p>
<p>
For the escape key add an accelerator with Visual C++ that maps the VK_ESCAPE key to a command, ID_CANCEL_EDIT is added to the resources. The handler for this command follows:</p>
<pre><code>// The following command handler provides the standard
// keyboard user interface to cancel an in-place
// editing session.void CMainView::OnCancelEdit()
{
 &nbsp;&nbsp; // Close any in-place active item on this view.
 &nbsp;&nbsp; COleClientItem* pActiveItem = 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GetDocument()-&gt;GetInPlaceActiveItem(this);
 &nbsp;&nbsp; if (pActiveItem != NULL)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pActiveItem-&gt;Close();
 &nbsp;&nbsp; ASSERT(GetDocument()-&gt;GetInPlaceActiveItem(this) == NULL);
}
</code></pre>
<p>
To handle the case where the user clicks outside the item, you add the following code to the start of <b>CMainView::SetSelection</b>:</p>
<pre><code>if (pNewSel != m_pSelection || pNewSel == NULL)
{
 &nbsp;&nbsp; COleClientItem* pActiveItem = 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GetDocument()-&gt;GetInPlaceActiveItem(this);
 &nbsp;&nbsp; if (pActiveItem != NULL &amp;&amp; pActiveItem != pNewSel)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pActiveItem-&gt;Close();
}
 &nbsp;&nbsp; 
</code></pre>
<p>
When an item is in-place active, it should have the focus. To make sure this is the case you handle OnSetFocus so that focus is always transfered to the active item when your view receives the focus:</p>
<pre><code>// Special handling of OnSetFocus and OnSize are required 
// when an object is being edited in-place.
void CMainView::OnSetFocus(CWnd* pOldWnd)
{
 &nbsp;&nbsp; COleClientItem* pActiveItem = 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GetDocument()-&gt;GetInPlaceActiveItem(this);
 &nbsp;&nbsp; if (pActiveItem != NULL &amp;&amp;
 &nbsp;&nbsp; pActiveItem-&gt;GetItemState() == COleClientItem::activeUIState)
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // need to set focus to this item if it is same view
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CWnd* pWnd = pActiveItem-&gt;GetInPlaceWindow();
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pWnd != NULL)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pWnd-&gt;SetFocus();&nbsp; // don't call the base class
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp; }

 &nbsp;&nbsp; CView::OnSetFocus(pOldWnd);
}
</code></pre>
<p>
When the view is resized, you need to notify the active item that the clipping rectangle has changed. To do this you provide a handler for <b>OnSize</b>:</p>
<pre><code>void CMainView::OnSize(UINT nType, int cx, int cy)
{
 &nbsp;&nbsp; CView::OnSize(nType, cx, cy);
 &nbsp;&nbsp; COleClientItem* pActiveItem = 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GetDocument()-&gt;GetInPlaceActiveItem(this);
 &nbsp;&nbsp; if (pActiveItem != NULL)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pActiveItem-&gt;SetItemRects();
}
</code></pre>
<p class=label>
<b>Case Study: HIERSVR from MFC 2.0</b></p>
<p>
<object id=alink_8 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="DefaultTopic" value="_topic_not_found.htm">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="_sample_mfc_HIERSVR">
</object><a href=JavaScript:alink_8.Click()>HIERSVR</a> was also included in MFC 2.0 and implemented OLE with MFC/OLE1. This note briefly describes the steps by which this application was initially converted to use the MFC/OLE 2 classes. A number of features were added after the initial port was completed to better illustrate the MFC/OLE 2 classes. These features will not be covered here; refer to the sample itself for more information on those advanced features.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;The compiler errors and step-by-step process was created with Visual C++ 2.0. Specific error messages and locations may have changed with Visual C++ 4.0, but the conceptual information remains valid.</p>
<p class=label>
<b>Getting It Up and Running</b></p>
<p>
The approach taken to port the HIERSVR sample to MFC/OLE is to start by building it and fixing the obvious compiler errors that will result. If you take the HIERSVR sample from MFC 2.0 and compile it under this version of MFC, you'll find that there are not many errors to resolve (although there are more than with the OCLIENT sample). The errors in the order in which they usually occur are described below.</p>
<p class=label>
<b>Compile and Fix Errors</b></p>
<pre><code>\hiersvr\hiersvr.cpp(83) : error C2039: 'RunEmbedded' : is not a member of 'COleTemplateServer'
</code></pre>
<p>
This first error points out a much larger problem with the <b>InitInstance</b> function for servers. The initialization required for an OLE server is probably one of the biggest changes you'll have to make to your MFC/OLE1 application to get it running. The best thing to do is look at what AppWizard creates for an OLE server and modify your code as appropriate. Here are some points to keep in mind:</p>
<p>
It is necessary to initialize the OLE libraries by calling <b>AfxOleInit</b></p>
<p>
Call SetServerInfo on the document template object to set server resource handles and runtime class information that you can't set with the <b>CDocTemplate</b> constructor.</p>
<p>
Don't show the main window of your application if /Embedding is present on the command line.</p>
<p>
You'll need a <b>GUID</b> for your document. This is a unique identifier for your document's type (128 bits). AppWizard will create one for you — so if you use the technique described here of copying the new code from a new AppWizard generated server application, you can simply "steal" the GUID from that application. If not, you can use the GUIDGEN.EXE utility in the BIN directory.</p>
<p>
It is necessary to "connect" your <b>COleTemplateServer</b> object to the document template by calling <b>COleTemplateServer::ConnectTemplate</b>.</p>
<p>
Update the system registry when your application is run stand-alone. This way, if the user moves the .EXE for your application, running it from its new location will update the Windows system registration database to point to the new location.</p>
<p>
After applying all of these changes based on what AppWizard creates for <b>InitInstance</b>, the <b>InitInstance</b> (and related GUID) for HIERSVR should read as follows:</p>
<pre><code>// this is the GUID for HIERSVR documents
static const GUID BASED_CODE clsid =
 &nbsp;&nbsp; { 0xA0A16360L, 0xC19B, 0x101A, { 0x8C, 0xE5, 0x00, 0xDD, 0x01, 0x11, 0x3F, 0x12 } };
 &nbsp;&nbsp; 
/////////////////////////////////////////////////////////////////////////////
// COLEServerApp initialization

BOOL COLEServerApp::InitInstance()
{
 &nbsp;&nbsp; // OLE 2 initialization
 &nbsp;&nbsp; if (!AfxOleInit())
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AfxMessageBox("Initialization of the OLE failed!");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return FALSE;
 &nbsp;&nbsp; }

 &nbsp;&nbsp; // Standard initialization
 &nbsp;&nbsp; LoadStdProfileSettings(); // Load standard INI file options 

 &nbsp;&nbsp; // Register document templates
 &nbsp;&nbsp; CDocTemplate* pDocTemplate;
 &nbsp;&nbsp; pDocTemplate = new CMultiDocTemplate(IDR_HIERSVRTYPE,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RUNTIME_CLASS(CServerDoc),   
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RUNTIME_CLASS(CMDIChildWnd),
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RUNTIME_CLASS(CServerView));
 &nbsp;&nbsp; pDocTemplate-&gt;SetServerInfo(IDR_HIERSVRTYPE_SRVR_EMB);
 &nbsp;&nbsp; AddDocTemplate(pDocTemplate);

 &nbsp;&nbsp; // create main MDI Frame window
 &nbsp;&nbsp; CMainFrame* pMainFrame = new CMainFrame;
 &nbsp;&nbsp; if (!pMainFrame-&gt;LoadFrame(IDR_MAINFRAME))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return FALSE;
 &nbsp;&nbsp; m_pMainWnd = pMainFrame;

 &nbsp;&nbsp; SetDialogBkColor();&nbsp;&nbsp; // gray look

 &nbsp;&nbsp; // enable file manager drag/drop and DDE Execute open
 &nbsp;&nbsp; m_pMainWnd-&gt;DragAcceptFiles();
 &nbsp;&nbsp; EnableShellOpen();
 &nbsp;&nbsp; 
 &nbsp;&nbsp; m_server.ConnectTemplate(clsid, pDocTemplate, FALSE);
 &nbsp;&nbsp; COleTemplateServer::RegisterAll();

 &nbsp;&nbsp; // try to launch as an OLE server
 &nbsp;&nbsp; if (RunEmbedded())
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // "short-circuit" initialization -- run as server!
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return TRUE;
 &nbsp;&nbsp; }
 &nbsp;&nbsp; m_server.UpdateRegistry();
 &nbsp;&nbsp; RegisterShellFileTypes();

 &nbsp;&nbsp; // not run as OLE server, so show the main window
 &nbsp;&nbsp; if (m_lpCmdLine[0] == '\0')
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // create a new (empty) document
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OnFileNew();
 &nbsp;&nbsp; }
 &nbsp;&nbsp; else
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // open an existing document
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OpenDocumentFile(m_lpCmdLine);
 &nbsp;&nbsp; }

 &nbsp;&nbsp; pMainFrame-&gt;ShowWindow(m_nCmdShow);
 &nbsp;&nbsp; pMainFrame-&gt;UpdateWindow();
 &nbsp;&nbsp; 
 &nbsp;&nbsp; return TRUE;
}
</code></pre>
<p>
You'll notice that the code above refers to a new resource ID, IDR_HIERSVRTYPE_SRVR_EMB. This is the menu resource to be used when a document that is embedded in another container is edited. In MFC/OLE1 the menu items specific to editing an embedded item were modified on the fly. Using an entirely different menu structure when editing an embedded item instead of editing a file-based document makes it much easier to provide different user interfaces for these two separate modes. As you'll see later, an entirely separate menu resource is used when editing an embedded object in-place.</p>
<p>
To create this resource, load the resource script into Visual C++ and copy the existing IDR_HIERSVRTYPE menu resource. Rename the new resource to IDR_HIERSVRTYPE_SRVR_EMB (this is the same naming convention that AppWizard uses). Next change "File Save" to "File Update"; give it command ID <b>ID_FILE_UPDATE</b>. Also change "File Save As" to "File Save Copy As"; give it command ID <b>ID_FILE_SAVE_COPY_AS</b>. The framework provides the implementation of both of these commands.</p>
<pre><code>\hiersvr\svritem.h(60) : error C2433: 'OLESTATUS' : 'virtual' not permitted on data declarations
\hiersvr\svritem.h(60) : error C2501: 'OLESTATUS' : missing decl-specifiers
\hiersvr\svritem.h(60) : error C2146: syntax error : missing ';' before identifier 'OnSetData'
\hiersvr\svritem.h(60) : error C2061: syntax error : identifier 'OLECLIPFORMAT'
\hiersvr\svritem.h(60) : error C2501: 'OnSetData' : missing decl-specifiers
</code></pre>
<p>
There are a number of errors resulting from the override of <b>OnSetData</b>, since it is referring to the <b>OLESTATUS</b> type. <b>OLESTATUS</b> was the way OLE1 returned errors. This has changed to <b>HRESULT</b> in OLE 2, although MFC usually converts an <b>HRESULT</b> into a <b>COleException</b> containing the error. In this particular case, the override of <b>OnSetData</b> is no longer necessary, so the easiest thing to do is to remove it.</p>
<pre><code>\hiersvr\svritem.cpp(30) : error C2660: 'COleServerItem::COleServerItem' : function does not take 1 parameters
</code></pre>
<p>
The <b>COleServerItem</b> constructor takes an extra 'BOOL' parameter. This flag determines how memory management is done on the <b>COleServerItem</b> objects. By setting it to TRUE, the framework handles the memory management of these objects — deleting them when they are no longer necessary. HIERSVR uses <b>CServerItem</b> (derived from <b>COleServerItem</b>) objects as part of its native data, so you'll set this flag to FALSE. This lets HIERSVR determine when each server item is deleted.</p>
<pre><code>\hiersvr\svritem.cpp(44) : error C2259: 'CServerItem' : illegal attempt to instantiate abstract class
\hiersvr\svritem.cpp(44) : error C2259: 'CServerItem' : illegal attempt to instantiate abstract class
</code></pre>
<p>
As these errors imply, there are some 'pure-virtual' functions which have not been overridden in CServerItem. Most likely this is caused by the fact that OnDraw's parameter list has changed. To fix this error, change <b>CServerItem::OnDraw</b> as follows (as well as the declaration in svritem.h):</p>
<pre><code>BOOL CServerItem::OnDraw(CDC* pDC, CSize&amp; rSize)
{
 &nbsp;&nbsp; // request from OLE to draw node
 &nbsp;&nbsp; pDC-&gt;SetMapMode(MM_TEXT); // always in pixels
 &nbsp;&nbsp; return DoDraw(pDC, CPoint(0,0), FALSE);
}
</code></pre>
<p>
The new parameter is 'rSize'. This allows you to fill in the size of the drawing, if convenient. This size must be in <b>HIMETRIC</b>. In this case, it is not convenient to fill this value in, so the framework calls <b>OnGetExtent</b> to retrieve the extent. For that to work, you'll have to implement <b>OnGetExtent</b>:</p>
<pre><code>BOOL CServerItem::OnGetExtent(DVASPECT dwDrawAspect, CSize&amp; rSize)
{
 &nbsp;&nbsp; if (dwDrawAspect != DVASPECT_CONTENT)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return COleServerItem::OnGetExtent(dwDrawAspect, rSize);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp; rSize = CalcNodeSize();
 &nbsp;&nbsp; return TRUE;
}

\hiersvr\svritem.cpp(104) : error C2065: 'm_rectBounds' : undeclared identifier
\hiersvr\svritem.cpp(104) : error C2228: left of '.SetRect' must have class/struct/union type
\hiersvr\svritem.cpp(106) : error C2664: 'void __pascal __far DPtoLP(struct ::tagPOINT __far *,int )__far const ' : cannot convert parameter 1 from 'int __far *' to 'struct ::tagPOINT __far *'
</code></pre>
<p>
In the CServerItem::CalcNodeSize function the item size is converted to <b>HIMETRIC</b> and stored in <b>m_rectBounds</b>. The undocumented '<b>m_rectBounds</b>' member of <b>COleServerItem</b> does not exist (it has been partially replaced by <b>m_sizeExtent</b>, but in OLE 2 this member has a slightly different usage than <b>m_rectBounds</b> did in OLE1). Instead of setting the <b>HIMETRIC</b> size into this member variable, you'll return it. This return value is used in <b>OnGetExtent</b>, implemented previously.</p>
<pre><code>CSize CServerItem::CalcNodeSize()
{
 &nbsp;&nbsp; CClientDC dcScreen(NULL);

 &nbsp;&nbsp; m_sizeNode = dcScreen.GetTextExtent(m_strDescription,
 &nbsp;&nbsp;&nbsp;&nbsp; m_strDescription.GetLength());
 &nbsp;&nbsp; m_sizeNode += CSize(CX_INSET * 2, CY_INSET * 2);

 &nbsp;&nbsp; // set suggested HIMETRIC size
 &nbsp;&nbsp; CSize size(m_sizeNode.cx, m_sizeNode.cy);
 &nbsp;&nbsp; dcScreen.SetMapMode(MM_HIMETRIC);
 &nbsp;&nbsp; dcScreen.DPtoLP(&amp;size);
 &nbsp;&nbsp; return size;
}
</code></pre>
<p>
CServerItem also overrides <b>COleServerItem::OnGetTextData</b>. This function is obsolete in MFC/OLE and is replaced by a different mechanism. The MFC 3.0 version of the MFC OLE sample <object id=alink_9 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="DefaultTopic" value="_topic_not_found.htm">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="_sample_mfc_HIERSVR">
</object><a href=JavaScript:alink_9.Click()>HIERSVR</a> implements this functionality by overriding <b>COleServerItem::OnRenderFileData</b>. This functionality is not important for this basic port, so you can remove the OnGetTextData override.</p>
<p>
There are many more errors in svritem.cpp that haven't been addressed. They are not "real" errors — just errors caused by previous errors.</p>
<pre><code>\hiersvr\svrview.cpp(325) : error C2660: 'CopyToClipboard' : function does not take 2 parameters
</code></pre>
<p>
<b>COleServerItem::CopyToClipboard</b> no longer supports the 'bIncludeNative' flag. The native data (the data written out by the server item's Serialize function) is always copied, so you remove the first parameter. In addition, <b>CopyToClipboard</b> will throw an exception when an error happens instead of returning FALSE. Change the code for CServerView::OnEditCopy as follows:</p>
<pre><code>void CServerView::OnEditCopy()
{
 &nbsp;&nbsp; if (m_pSelectedNode == NULL)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AfxThrowNotSupportedException();
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp; TRY
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_pSelectedNode-&gt;CopyToClipboard(TRUE);
 &nbsp;&nbsp; }
 &nbsp;&nbsp; CATCH_ALL(e)
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AfxMessageBox("Copy to clipboard failed");
 &nbsp;&nbsp; }
 &nbsp;&nbsp; END_CATCH_ALL   
}
</code></pre>
<p>
Although there were more errors resulting from the compilation of the MFC 2.0 version of HIERSVR than there were for the same version of OCLIENT, there were actually fewer changes.</p>
<p>
At this point HIERSVR will compile and link and function as an OLE server, but without the in-place editing feature, which will be implemented next.</p>
<p class=label>
<b>Adding "Visual Editing"</b></p>
<p>
To add "Visual Editing" (or in-place activation) to this server application, there are only a few things you must take care of:
<ul type=disc>
<li>
You need a special menu resource to be used when the item is in-place active.<br><br></li>
<li>
This application has a toolbar, so you'll need a toolbar with only a subset of the normal toolbar to match the menu commands available from the server (matches the menu resource mentioned above).<br><br></li>
<li>
You need a new class derived from <b>COleIPFrameWnd</b> that provides the in-place user interface (much like CMainFrame, derived from <b>CMDIFrameWnd</b>, provides the MDI user interface).<br><br></li>
<li>
You need to tell the framework about these special resources and classes.</li>
</ul>
<p>
The menu resource is easy to create. Run Visual C++, copy the menu resource IDR_HIERSVRTYPE to a menu resource called IDR_HIERSVRTYPE_SRVR_IP. Modify the menu so that only the Edit and Help menu popups are left. Add two separators to the menu in between the Edit and Help menus (it should look like: Edit | | Help). For more information on what these separators mean and how the server and container menus are merged, see "Menus and Resources: Menu Merging" in <i>OLE 2 Classes</i>.</p>
<p>
The bitmap for the subset toolbar can be easily created by copying the one from a fresh AppWizard generated application with a "Server" option checked. This bitmap can then be imported into Visual C++. Be sure to give the bitmap an ID of IDR_HIERSVRTYPE_SRVR_IP.</p>
<p>
The class derived from <b>COleIPFrameWnd</b> can be copied from an AppWizard generated application with server support as well. Copy both files, IPFRAME.CPP and IPFRAME.H and add them to the project. Make sure that the <b>LoadBitmap</b> call refers to IDR_HIERSVRTYPE_SRVR_IP, the bitmap created in the previous step.</p>
<p>
Now that all the new resources and classes are created, add the necessary code so that the framework knows about these (and knows that this application now supports in-place editing). This is done by adding some more parameters to the <b>SetServerInfo</b> call in the <b>InitInstance</b> function:</p>
<pre><code>pDocTemplate-&gt;SetServerInfo(IDR_HIERSVRTYPE_SRVR_EMB,
 &nbsp;&nbsp; IDR_HIERSVRTYPE_SRVR_IP, RUNTIME_CLASS(CInPlaceFrame));
</code></pre>
<p>
It is now ready to run in-place in any container which also supports in-place activation. But, there is one minor bug still lurking in the code. HIERSVR supports a context menu, displayed when the user presses the right mouse button. This menu works when HIERSVR is fully open, but does not work when editing an embedding in-place. The reason can be pinned down to this single line of code in CServerView::OnRButtonDown:</p>
<pre><code>pMenu-&gt;TrackPopupMenu(TPM_CENTERALIGN | TPM_RIGHTBUTTON,
 &nbsp;&nbsp; point.x, point.y, AfxGetApp()-&gt;m_pMainWnd);
</code></pre>
<p>
Notice the reference to <b>AfxGetApp()-&gt;m_pMainWnd</b>. When the server is in-place activated, it has a main window and m_pMainWnd is set, but it is usually invisible. Furthermore, this window refers to the <i>main</i> window of the application, the MDI frame window that appears when the server is fully open or run stand-alone. It does not refer to the active frame window — which when in-place activated is a frame window derived from <b>COleIPFrameWnd</b>. To get the correct active window even when in-place editing, this version of MFC adds a new function, <b>AfxGetMainWnd</b>. Generally, you should use this function instead of <b>AfxGetApp()-&gt;m_pMainWnd</b>. This code needs to change as follows:</p>
<pre><code>pMenu-&gt;TrackPopupMenu(TPM_CENTERALIGN | TPM_RIGHTBUTTON,
 &nbsp;&nbsp; point.x, point.y, AfxGetMainWnd());
</code></pre>
<p>
Now you have an OLE server minimally enabled for functional in-place activation. But there are still many features available with MFC/OLE 2 that were not available in MFC/OLE1. See the HIERSVR sample for more ideas on features you might want to implement. Some of the features that HIERSVR implements are listed below:
<ul type=disc>
<li>
Zooming, for true WYSISYG behavior with respect to the container.<br><br></li>
<li>
Drag / drop and a custom clipboard format<br><br></li>
<li>
Scrolling the container window as the selection is changed</li>
</ul>
<p>
The HIERSVR sample in MFC 3.0 also uses a slightly different design for its server items. This helps conserve memory and makes your links more flexible. With the 2.0 version of HIERSVR each node in the tree <i>is-a</i> <b>COleServerItem</b>. <b>COleServerItem</b> carries a bit more overhead than is strictly necessary for each of these nodes, but a <b>COleServerItem</b> is required for each active link. But for the most part, there are very few active links at any given time. To make this more efficient, the HIERSVR in this version of MFC separates the node from the <b>COleServerItem</b>. It has both a CServerNode and a <b>CServerItem</b> class. The <b>CServerItem</b> (derived from <b>COleServerItem</b>) is only created as necessary. Once the container (or containers) stop using that particular link to that particular node, the CServerItem object associated with the CServerNode is deleted. This design is more efficient and more flexible. Its flexibility comes in when dealing with multiple selection links. Neither of these two versions of HIERSVR support multiple selection, but it would be much easier to add (and to support links to such selections) with the MFC 3.0 version of HIERSVR, since the <b>COleServerItem</b> is separated from the native data.</p>
<p>
<a href="_mfcnotes_technical_notes_by_number.htm">Technical Notes by Number</a>  |&nbsp; <a href="_mfcnotes_technical_notes_by_category.htm">Technical Notes by Category</a></p>
</font></BODY>
</HTML>
