<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>TN024: MFC-Defined Messages and Resources</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY>
<font face="verdana,arial,helvetica" size="2">
<h1><a name="_mfcnotes_tn024"></a><sup></sup>TN024: MFC-Defined Messages and Resources</h1>
<p>
This note describes the internal Windows messages and resource formats used by MFC. This information explains the implementation of the framework, and will assist you in debugging your application. For the adventurous, even though all this information is officially unsupported, you may use some of this information for advanced implementations.</p>
<p>
This note contains MFC private implementation details; all the contents are subject to change in the future. MFC private Windows messages have meaning in the scope of one application only but will change in the future to contain system-wide messages.</p>
<p>
The range of MFC private Windows messages and resource types are in the reserved "system" range set aside by Microsoft Windows. Currently not all numbers in the ranges are used and, in the future, new numbers in the range may be used. The currently used numbers may be changed.</p>
<p>
MFC private Windows messages are in the range 0x360-&gt;0x37F.</p>
<p>
MFC private resource types are in the range 0xF0-&gt;0xFF.</p>
<p class=label>
<b>MFC Private Windows Messages</b></p>
<p>
These Windows messages are used in place of C++ virtual functions where relatively loose coupling is required between window objects and where a C++ virtual function would not be appropriate.</p>
<p>
These private Windows messages and associated parameter structures are declared in the MFC private header 'AFXPRIV.H'. Be warned that any of your code that includes this header may be relying on undocumented behavior and will likely break in future versions of MFC.</p>
<p>
In the rare case of needing to handle one of these messages, you should use the <b>ON_MESSAGE</b> message map macro and handle the message in the generic LRESULT/WPARAM/LPARAM format.</p>
<p class=label>
<b>WM_QUERYAFXWNDPROC</b></p>
<p>
This message is sent to a window that is being created. This is sent very early in the creation process as a method of determining if the WndProc is <b>AfxWndProc.</b> <b>AfxWndProc</b> returns 1.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td width=35%>wParam</td>
<td width=65%>Not used</td>
</tr>
<tr valign=top>
<td width=35%>lParam</td>
<td width=65%>Not used</td>
</tr>
<tr valign=top>
<td width=35%>returns</td>
<td width=65%>1 if processed by <b>AfxWndProc</b></td>
</tr>
</table><br>
<p class=label>
<b>WM_SIZEPARENT</b></p>
<p>
This message is sent by a frame window to its immediate children during resizing (<b>CFrameWnd::OnSize</b> calls <b>CFrameWnd::RecalcLayout</b> which calls <b>CWnd::RepositionBars</b>) to reposition the control bars around the side of the frame. The <b>AFX_SIZEPARENTPARAMS</b> structure contains the current available client rectangle of the parent and a HDWP (which may be NULL) with which to call <b>DeferWindowPos</b> to minimize repainting.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td width=35%>wParam</td>
<td width=65%>Not used</td>
</tr>
<tr valign=top>
<td width=35%>lParam</td>
<td width=65%>Address of an <b>AFX_SIZEPARENTPARAMS</b> structure</td>
</tr>
<tr valign=top>
<td width=35%>returns</td>
<td width=65%>Not used (0)</td>
</tr>
</table><br>
<p>
Ignoring the message indicates that the window doesn't take part in the layout.</p>
<p class=label>
<b>WM_SETMESSAGESTRING</b></p>
<p>
This message is sent to a frame window to ask it to update the message line in the status bar. Either a string ID or a LPCSTR can be specified (but not both).</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td width=35%>wParam</td>
<td width=65%>String ID (or zero)</td>
</tr>
<tr valign=top>
<td width=35%>lParam</td>
<td width=65%>LPCSTR for the string (or NULL)</td>
</tr>
<tr valign=top>
<td width=35%>returns</td>
<td width=65%>Not used (0)</td>
</tr>
</table><br>
<p class=label>
<b>WM_IDLEUPDATECMDUI</b></p>
<p>
This message is sent in idle time to implement the idle-time update of update-command UI handlers. If the window (usually a control bar) handles the message, it creates a <b>CCmdUI</b> object (or an object of a derived class) and call <b>CCmdUI::DoUpdate</b> for each of the "items" in the window. This will in turn check for an <b>ON_UPDATE_COMMAND_UI</b> handler for the objects in the command-handler chain.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td width=35%>wParam</td>
<td width=65%>BOOL bDisableIfNoHandler</td>
</tr>
<tr valign=top>
<td width=35%>lParam</td>
<td width=65%>Not used (0)</td>
</tr>
<tr valign=top>
<td width=35%>returns</td>
<td width=65%>Not used (0)</td>
</tr>
</table><br>
<p>
<i>bDisableIfNoHandler</i> is non-zero to disable the UI object if there is neither an <b>ON_UPDATE_COMMAND_UI</b> nor an <b>ON_COMMAND</b> handler.</p>
<p class=label>
<b>WM_EXITHELPMODE</b></p>
<p>
This message is posted to a <b>CFrameWnd</b> that to exit context sensitive help mode. The receipt of this message terminates the modal loop started by <b>CFrameWnd::OnContextHelp.</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td width=35%>wParam</td>
<td width=65%>Not used (0)</td>
</tr>
<tr valign=top>
<td width=35%>lParam</td>
<td width=65%>Not used (0)</td>
</tr>
<tr valign=top>
<td width=35%>returns</td>
<td width=65%>Not used</td>
</tr>
</table><br>
<p class=label>
<b>WM_INITIALUPDATE</b></p>
<p>
This message is sent by the document template to all descendants of a frame window when it is safe for them to do their initial update. It maps to a call to <b>CView::OnInitialUpdate</b> but can be used in other <b>CWnd</b>-derived classes for other one-shot updating.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td width=35%>wParam</td>
<td width=65%>Not used (0)</td>
</tr>
<tr valign=top>
<td width=35%>lParam</td>
<td width=65%>Not used (0)</td>
</tr>
<tr valign=top>
<td width=35%>returns</td>
<td width=65%>Not used (0)</td>
</tr>
</table><br>
<p class=label>
<b>WM_RECALCPARENT</b></p>
<p>
This message is sent by a view to its parent window (obtained via <b>GetParent</b>) to force a layout recalculation (usually, the parent will call <b>RecalcLayout</b>). This is used in OLE server applications where it is necessary for the frame to grow in size as the view's total size grows.</p>
<p>
If the parent window processes this message it should return TRUE and fill the RECT passed in lParam with the new size of the client area. This is used in <b>CScrollView</b> to properly handle scrollbars (place then on the outside of the window when they are added) when a server object is in-place activated.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td width=35%>wParam</td>
<td width=65%>Not used (0)</td>
</tr>
<tr valign=top>
<td width=35%>lParam</td>
<td width=65%>LPRECT rectClient, may be NULL</td>
</tr>
<tr valign=top>
<td width=35%>returns</td>
<td width=65%>TRUE if new client rectangle returned, FALSE otherwise</td>
</tr>
</table><br>
<p class=label>
<b>WM_SIZECHILD</b></p>
<p>
This message is sent by <b>COleResizeBar</b> to its owner window (via <b>GetOwner</b>) when the user resizes the resize bar with the resize handles. <b>COleIPFrameWnd</b> responds to this message by attempting to reposition the frame window as the user has requested.</p>
<p>
The new rectangle, given in client coordinates relative to the frame window which contains the resize bar, is pointed at by lParam.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td width=35%>wParam</td>
<td width=65%>Not used (0)</td>
</tr>
<tr valign=top>
<td width=35%>lParam</td>
<td width=65%>LPRECT rectNew</td>
</tr>
<tr valign=top>
<td width=35%>returns</td>
<td width=65%>Not used (0)</td>
</tr>
</table><br>
<p class=label>
<b>WM_DISABLEMODAL</b></p>
<p>
This message is sent to all popup windows owned by a frame window that is being deactivated. The frame window uses the result to determine whether or not to disable the popup window.</p>
<p>
You can use this to perform special processing in your popup window when the frame enters a modal state or to keep certain popup windows from getting disabled. Tooltips use this message to destroy themselves when the frame window goes into a modal state, for example.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td width=35%>wParam</td>
<td width=65%>Not used (0)</td>
</tr>
<tr valign=top>
<td width=35%>lParam</td>
<td width=65%>Not used (0)</td>
</tr>
<tr valign=top>
<td width=35%>returns</td>
<td width=65%>Non-zero to <b>NOT</b> disable the window, 0 indicates the window will be disabled</td>
</tr>
</table><br>
<p class=label>
<b>WM_FLOATSTATUS</b></p>
<p>
This message is sent to all popup windows owned by a frame window when the frame is either activated or deactivated by another top-level frame window. This is used by the implementation of <b>MFS_SYNCACTIVE</b> in <b>CMiniFrameWnd</b>, to keep the activation of these popup windows in sync with the activation of the top level frame window.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td width=35%>wParam</td>
<td width=65%>Is one of the following values:<br>
<b>FS_SHOW</b><br>
<b>FS_HIDE</b><br>
<b>FS_ACTIVATE</b><br>
<b>FS_DEACTIVATE</b><br>
<b>FS_ENABLE</b><br>
<b>FS_DISABLE</b><br>
<b>FS_SYNCACTIVE</b></td>
</tr>
<tr valign=top>
<td width=35%>lParam</td>
<td width=65%>Not used (0)</td>
</tr>
</table><br>
<p>
The return value should be non-zero if <b>FS_SYNCACTIVE</b> is set and the window syncronizes its activation with the parent frame. <b>CMiniFrameWnd</b> returns non-zero when the style is set to <b>MFS_SYNCACTIVE.</b></p>
<p>
For more information, see the implementation of <b>CMiniFrameWnd</b>.</p>
<p class=label>
<b>WM_ACTIVATETOPLEVEL</b></p>
<p>
This message is sent to a top-level window when a window in its "top-level group" is either activated or deactivated. A window is part of a top-level group if it is a top-level window (no parent or owner), or it is owned by such a window. This message is similar in use to <b>WM_ACTIVATEAPP,</b> but works in situations where windows belonging to different processes are mixed in a single window hierarchy (common in OLE applications).</p>
<p class=label>
<b>WM_QUERY3DCONTROLS</b></p>
<p>
This message is sent during window creation to determine if the window should be subclassed by CTL3D32.DLL. By default 3D controls are enabled for <b>CControlBar, CDialog, CPropertySheet, and CFormView.</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td width=34%>wParam</td>
<td width=66%>Not used (0)</td>
</tr>
<tr valign=top>
<td width=34%>lParam</td>
<td width=66%>Not used (0)</td>
</tr>
<tr valign=top>
<td width=34%>returns</td>
<td width=66%>Non-zero to subclass with CTL3D.&nbsp; The return value is used for the call to <b>Ctl3dSubclassDlgEx.</b></td>
</tr>
</table><br>
<p class=label>
<b>WM_COMMANDHELP, WM_HELPHITTEST, WM_EXITHELPMODE</b></p>
<p>
These messages are used in the implementation of context-sensitive Help. Please refer to <a href="_mfcnotes_tn028.htm">Technical Note 28</a> for more information.</p>
<p class=label>
<b>MFC Private Resource Formats</b></p>
<p>
There is currently only one MFC private resource format defined, <b>RT_DLGINIT</b>.</p>
<p class=label>
<b>RT_DLGINIT Resource Format</b></p>
<p>
One MFC private resource format is used to store extra dialog initialization information. This includes the initial strings stored in a combo box. The format of this resource is not designed to be manually edited, but is handled by Visual C++.</p>
<p>
Visual C++ and this <b>RT_DLGINIT</b> resource are not required to use the related features of MFC since there are API alternative to using the information in the resource. Using Visual C++ makes it much easier to write, maintain, and translate your application in the long run.</p>
<p>
The basic structure of a <b>RT_DLGINIT</b> resource is as follows:</p>
<pre><code>+---------------+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \
| Control ID&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp; UINT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
+---------------+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
| Message #&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp; UINT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
+---------------+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
|length of data |&nbsp;&nbsp; DWORD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
+---------------+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Repeated
|&nbsp;&nbsp; Data&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp; Variable Length&nbsp; |&nbsp;&nbsp; for each control
|&nbsp;&nbsp;&nbsp;&nbsp; ...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp; and Format&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp; and message
+---------------+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /
|&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp; BYTE
+---------------+
</code></pre>
<p>
A repeated section contains the control ID to send the message to, the Message # to send (a normal Windows message) and a variable length of data. The Windows message is sent in a form:</p>
<pre><code>SendDlgItemMessage(&lt;Control ID&gt;, &lt;Message #&gt;, 0, &amp;&lt;Data&gt;);
</code></pre>
<p>
This is a very general format, allowing any Windows messages and data content. The Visual C++ resource editor and MFC only support a limited subset of Windows messages: CB_ADDSTRING for the initial list-choices for combo boxes (the data is a text string).</p>
<p>
<a href="_mfcnotes_technical_notes_by_number.htm">Technical Notes by Number</a>  |&nbsp; <a href="_mfcnotes_technical_notes_by_category.htm">Technical Notes by Category</a></p>
</font></BODY>
</HTML>
