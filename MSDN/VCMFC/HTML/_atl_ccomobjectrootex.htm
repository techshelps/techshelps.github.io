<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CComObjectRootEx</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY>
<font face="verdana,arial,helvetica" size="2">
<h1><a name="_atl_ccomobjectrootex"></a>CComObjectRootEx</h1>
<p>
<b>template&lt; class </b><i>ThreadModel</i><b> &gt;<br>
class CComObjectRootEx : public CComObjectRootBase</b></p>
<p>
<b>Parameters</b></p>
<p class=dt>
<i>ThreadModel</i></p>
<p class=indent>
The class whose methods implement the desired threading model. You can explicitly choose the threading model by setting <i>ThreadModel</i> to <a href="_atl_ccomsinglethreadmodel.htm">CComSingleThreadModel</a>, <a href="_atl_ccommultithreadmodel.htm">CComMultiThreadModel</a>, or <a href="_atl_ccommultithreadmodelnocs.htm">CComMultiThreadModelNoCS</a>. You can accept the server's default thread model by setting <i>ThreadModel</i> to <a href="_atl_ccomobjectthreadmodel.htm">CComObjectThreadModel</a> or <a href="_atl_ccomglobalsthreadmodel.htm">CComGlobalsThreadModel</a>.</p>
<p>
<b>CComObjectRootEx</b> handles object reference count management for both nonaggregated and aggregated objects. It holds the object reference count if your object is not being aggregated, and holds the pointer to the outer unknown if your object is being aggregated. For aggregated objects, <b>CComObjectRootEx</b> methods can be used to handle the failure of the inner object to construct, and to protect the outer object from deletion when inner interfaces are released or the inner object is deleted. </p>
<p>
A class that implements a COM server must inherit from <b>CComObjectRootEx</b> or <a href="_atl_ccomobjectroot.htm">CComObjectRoot</a>. </p>
<p>
If your class definition specifies the <a href="_atl_declare_poly_aggregatable.htm">DECLARE_POLY_AGGREGATABLE</a> macro, ATL creates an instance of <b>CComPolyObject&lt;CYourClass&gt;</b> when <b>IClassFactory::CreateInstance</b> is called. During creation, the value of the outer unknown is checked. If it is <b>NULL</b>, <b>IUnknown</b> is implemented for a nonaggregated object. If the outer unknown is not <b>NULL</b>, <b>IUnknown</b> is implemented for an aggregated object.</p>
<p>
If your class does not specify the <b>DECLARE_POLY_AGGREGATABLE</b> macro, ATL creates an instance of <b>CComObject&lt;CYourClass&gt;</b> for aggregated objects or an instance of <b>CComAggObject&lt;CYourClass&gt;</b> for nonaggregated objects. </p>
<p>
The advantage of using <b>CComPolyObject</b> is that you avoid having both <b>CComAggObject</b> and <b>CComObject</b> in your module to handle the aggregated and nonaggregated cases. A single <b>CComPolyObject</b> object handles both cases. Therefore, only one copy of the vtable and one copy of the functions exist in your module. If your vtable is large, this can substantially decrease your module size. However, if your vtable is small, using <b>CComPolyObject</b> can result in a slightly larger module size because it is not optimized for an aggregated or nonaggregated object, as are <b>CComAggObject</b> and <b>CComObject</b>.</p>
<p>
The <b>DECLARE_POLY_AGGREGATABLE</b> macro is automatically added to your class definition by the ATL Object Wizard when you create a full control or Internet Explorer control. </p>
<p>
If your object is aggregated, <object id=alink_1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="DefaultTopic" value="_topic_not_found.htm">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="_com_IUnknown">
</object><a href=JavaScript:alink_1.Click()>IUnknown</a> is implemented by <b>CComAggObject</b> or <b>CComPolyObject</b>. These classes delegate <b>QueryInterface</b>, <b>AddRef</b>, and <b>Release</b> calls to <b>CComObjectRootEx</b>'s <b>OuterQueryInterface</b>, <b>OuterAddRef</b>, and <b>OuterRelease</b> to forward to the outer unknown. Typically, you override <b>CComObjectRootEx::FinalConstruct</b> in your class to create any aggregated objects, and override <b>CComObjectRootEx::FinalRelease</b> to free any aggregated objects. </p>
<p>
If your object is not aggregated, <b>IUnknown</b> is implemented by <b>CComObject</b> or <b>CComPolyObject</b>. In this case, calls to <b>QueryInterface</b>, <b>AddRef</b>, and <b>Release</b> are delegated to <b>CComObjectRootEx</b>'s <b>InternalQueryInterface</b>, <b>InternalAddRef</b>, and <b>InternalRelease</b> to perform the actual operations.</p>
<p>
<b>#include &lt;atlcom.h&gt;</b></p>
<p>
<a href="_atl_ccomobjectrootex_class_members.htm">Class Members</a></p>
<p>
<b>See Also</b>&nbsp;&nbsp;&nbsp;<a href="_atl_ccomaggobject.htm">CComAggObject</a>, <a href="_atl_ccomobject.htm">CComObject</a>, <a href="_atl_ccompolyobject.htm">CComPolyObject</a> </p>
</font></BODY>
</HTML>
