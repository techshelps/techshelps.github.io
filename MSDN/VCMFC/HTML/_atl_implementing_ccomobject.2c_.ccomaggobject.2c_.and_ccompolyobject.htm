<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Implementing CComObject, CComAggObject, and CComPolyObject</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY>
<font face="verdana,arial,helvetica" size="2">
<h1><a name="_atl_implementing_ccomobject.2c_.ccomaggobject.2c_.and_ccompolyobject"></a>Implementing CComObject, CComAggObject, and CComPolyObject</h1>
<p>
The template classes, <a href="_atl_ccomobject.htm">CComObject</a>, <a href="_atl_ccomaggobject.htm">CComAggObject</a>, and <a href="_atl_ccompolyobject.htm">CComPolyObject</a> are always the most derived classes in the inheritance chain. It is their responsibility to handle all the methods in <b>IUnknown</b>: <b>QueryInterface</b>, <b>AddRef</b>, and <b>Release</b>. In addition, <b>CComAggObject</b> and <b>CComPolyObject</b> (when used for aggregated objects) provide the special reference counting and <b>QueryInterface</b> semantics required for the inner unknown. </p>
<p>
Whether <b>CComObject</b>, <b>CComAggObject</b>, or <b>CComPolyObject</b> is used depends on whether you declare the <a href="_atl_declare_poly_aggregatable.htm">DECLARE_POLY_AGGREGATABLE</a> macro and on whether your object is being aggregated:
<ul type=disc>
<li>
If your class definition specifies the <b>DECLARE_POLY_AGGREGATABLE</b> macro, ATL creates an instance of <b>CComPolyObject&lt;CYourClass&gt;</b> when <b>IClassFactory::CreateInstance</b> is called. During creation, the value of the outer unknown is checked. If it is <b>NULL</b>, <b>IUnknown</b> is implemented for a non-aggregated object. If the outer unknown is not <b>NULL</b>, <b>IUnknown</b> is implemented for an aggregated object.<br><br></li>
<li>
If you do not specify the <b>DECLARE_POLY_AGGREGATABLE</b> macro in your class definition and the object is not aggregated, ATL creates an instance of <b>CComObject&lt;CYourClass&gt;</b> when <b>IClassFactory::CreateInstance</b> is called.<br><br></li>
<li>
If you do not specify the <b>DECLARE_POLY_AGGREGATABLE</b> macro in your class definition and the object is aggregated, ATL creates a <b>CComAggObject&lt;CYourClass&gt;</b> when <b>IClassFactory::CreateInstance</b> is called.</li>
</ul>
<p>
The advantage of using <b>CComAggObject</b> and <b>CComObject</b> is that the implementation of <b>IUnknown</b> is optimized for the kind of object being created. For instance, a nonaggregated object only needs a reference count, while an aggregated object needs both a reference count for the inner unknown and a pointer to the outer unknown. </p>
<p>
The advantage of using <b>CComPolyObject</b> is that you avoid having both <b>CComAggObject</b> and <b>CComObject</b> in your module to handle the aggregated and nonaggregated cases. A single <b>CComPolyObject</b> object handles both cases. This means only one copy of the vtable and one copy of the functions exist in your module. If your vtable is large, this can substantially decrease your module size. However, if your vtable is small, using <b>CComPolyObject</b> can result in a slightly larger module size because it is not optimized for an aggregated or nonaggregated object, as are <b>CComAggObject</b> and <b>CComObject</b>.</p>
<p>
The <b>DECLARE_POLY_AGGREGATABLE</b> macro is automatically added to your class definition by the ATL Object Wizard when you create a full control or Internet Explorer control. For more information about the wizard, see <a href="_atl_creating_an_atl_project.htm">Creating an ATL Project</a>.</p>
</font></BODY>
</HTML>
