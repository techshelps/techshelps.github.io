<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>TN006: Message Maps</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY>
<font face="verdana,arial,helvetica" size="2">
<h1><a name="_mfcnotes_tn006"></a><sup></sup>TN006: Message Maps</h1>
<p>
This note describes the MFC message map facility.</p>
<p class=label>
<b>The Problem</b></p>
<p>
Microsoft Windows implements what are essentially virtual functions in window classes using its messaging facility. Due to the large number of messages involved, providing a separate virtual function for each Windows message results in a prohibitively large vtable.</p>
<p>
Also, since the number of system-defined Windows messages changes over time, and since a specific application may want to define some Windows messages of its own, the message-map mechanism provides a level of indirection that prevents interface changes from breaking existing code.</p>
<p class=label>
<b>Overview</b></p>
<p>
MFC provides an alternative to the switch statement used in traditional Windows programs to handle messages sent to a window. A mapping from messages to member-functions may be defined so that when a message is to be handled by a window, the appropriate member function is called automatically. This message-map facility is designed to be similar to virtual functions but has additional benefits not possible with C++ virtual functions.</p>
<p class=label>
<b>Defining a Message Map</b></p>
<p>
The <b>DECLARE_MESSAGE_MAP</b> macro declares three members for a class.
<ul type=disc>
<li>
A private array of <b>AFX_MSGMAP_ENTRY</b> entries called <i>_messageEntries</i>,<br><br></li>
<li>
A protected <b>AFX_MSGMAP</b> structure called <b>messageMap</b> that points to the <i>_messageEntries</i> array<br><br></li>
<li>
A protected virtual function called <b>GetMessageMap</b> that returns the address of <b>messageMap</b>.</li>
</ul>
<p>
This macro should be placed in the declaration of any class using message maps. By convention, it is at the end of the class declaration. For example:</p>
<pre><code>class CMyWnd : public CMyParentWndClass
{
 &nbsp;&nbsp; // my stuff...

protected:
 &nbsp;&nbsp; //{{AFX_MSG(CMyWnd)
 &nbsp;&nbsp; afx_msg void OnPaint();
 &nbsp;&nbsp; //}}AFX_MSG

 &nbsp;&nbsp; DECLARE_MESSAGE_MAP()
};
</code></pre>
<p>
This is the format generated by AppWizard and ClassWizard when they create new classes. The //{{ and //}} brackets are needed for ClassWizard.</p>
<p>
The message map's table is defined with a set of macros that expand to message map entries. A table begins with a <b>BEGIN_MESSAGE_MAP</b> macro call, which defines the class that is handled by this message map and the parent class to which unhandled messages are passed. The table ends with the <b>END_MESSAGE_MAP</b> macro call.</p>
<p>
Between these two macro calls is an entry for each message to be handled by this message map. Every standard Windows message has a macro of the form ON_WM_xxx (where xxx is the name of the message) that generates an entry for that message.</p>
<p>
A standard function signature has been defined for unpacking the parameters of each Windows message and providing type safety. These signatures may be found in the file AFXWIN.H in the declaration of CWnd. Each one is marked with the word <b>afx_msg</b> for easy identification.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;ClassWizard requires that you use the <b>afx_msg</b> keyword in your message map handler declarations.</p>
<p>
These function signatures were derived using a simple convention. The name of the function always starts with "On". This is followed by the name of the Windows message with the WM_ removed and only the first letter of each word capitalized. The ordering of the parameters is wParam followed by <b>LOWORD(</b><i>lParam</i><b>)</b> then <b>HIWORD</b>(<i>lParam</i>). Unused parameters are not passed. Any handles that are wrapped by MFC classes are converted to pointers to the appropriate MFC objects. The following example shows how to handle the <b>WM_PAINT</b> message and cause the CMyWnd<b>::OnPaint</b> function to be called:</p>
<pre><code>BEGIN_MESSAGE_MAP(CMyWnd, CMyParentWndClass)
 &nbsp;&nbsp; //{{AFX_MSG_MAP(CMyWnd)
 &nbsp;&nbsp; ON_WM_PAINT()
 &nbsp;&nbsp; //}}AFX_MSG_MAP
END_MESSAGE_MAP()
</code></pre>
<p>
The message map table must be defined outside the scope of any function or class definition. It should not be placed within an extern "C" block.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;ClassWizard will edit the message map entries that are found between the //{{ and //}} comment bracket.</p>
<p class=label>
<b>User Defined Windows Messages</b></p>
<p>
User-defined messages may be included in a message map by using the <b>ON_MESSAGE</b> macro. This macro accepts a message number and a member function of the form:</p>
<pre><code>&nbsp;&nbsp;&nbsp;&nbsp;// inside the class declaration
 &nbsp;&nbsp; afx_msg LRESULT OnMyMessage(WPARAM wParam, LPARAM lParam);

For example:
 &nbsp;&nbsp; #define WM_MYMESSAGE (WM_USER + 100)

BEGIN_MESSAGE_MAP(CMyWnd, CMyParentWndClass)
 &nbsp;&nbsp; ON_MESSAGE(WM_MYMESSAGE, OnMyMessage)
END_MESSAGE_MAP()
</code></pre>
<p>
In this example, we establish a handler for a custom message with a Windows message ID derived from the standard <b>WM_USER</b> base for user-defined messages. You might invoke this handler with code such as:</p>
<pre><code>CWnd* pWnd = ...;
pWnd-&gt;SendMessage(WM_MYMESSAGE);
</code></pre>
<p>
The range of user defined messages using this approach must be in the range WM_USER to 0x7fff.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;ClassWizard does not support entering <b>ON_MESSAGE</b> handler routines from the ClassWizard user interface: you must manually enter them from the Visual C++ editor. Once entered, ClassWizard will parse these entries and allow you to browse them just like any other message-map entries.</p>
<p class=label>
<b>Registered Windows Messages</b></p>
<p>
The <b>::RegisterWindowMessage</b> function is used to define a new window message that is guaranteed to be unique throughout the system. The macro <b>ON_REGISTERED_MESSAGE</b> is used to handle these messages. This macro accepts a the name of a near UINT variable that contains the registered windows message ID. For example</p>
<pre><code>class CMyWnd : public CMyParentWndClass
{
public:
 &nbsp;&nbsp; CMyWnd();

 &nbsp;&nbsp; //{{AFX_MSG(CMyWnd)
 &nbsp;&nbsp; afx_msg LRESULT OnFind(WPARAM wParam, LPARAM lParam);
 &nbsp;&nbsp; //}}AFX_MSG

 &nbsp;&nbsp; DECLARE_MESSAGE_MAP()
};

static UINT NEAR WM_FIND = RegisterWindowMessage("COMMDLG_FIND");

BEGIN_MESSAGE_MAP(CMyWnd, CMyParentWndClass)
 &nbsp;&nbsp; //{{AFX_MSG_MAP(CMyWnd)
 &nbsp;&nbsp; ON_REGISTERED_MESSAGE(WM_FIND, OnFind)
 &nbsp;&nbsp; //}}AFX_MSG_MAP
END_MESSAGE_MAP()
</code></pre>
<p>
The registered Windows message ID variable (WM_FIND in the example above) must be a NEAR variable because of the way <b>ON_REGISTERED_MESSAGE</b> is implemented.</p>
<p>
The range of user defined messages using this approach will be in the range 0xC000 to 0xFFFF.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;ClassWizard does not support entering <b>ON_REGISTERED_MESSAGE</b> handler routines from the ClassWizard user interface, you must manually enter them from the text editor. Once entered, ClassWizard will parse these entries and allow you to browse them just like any other message-map entries.</p>
<p class=label>
<b>Command Messages</b></p>
<p>
Command messages from menus and accelerators are handled in message maps with the <b>ON_COMMAND</b> macro. This macro accepts a command ID as well as a member function. Only the specific <b>WM_COMMAND</b> message with a <i>wParam</i> equal to the specified command ID is handled by the member function specified in the message-map entry. Command handler member functions take no parameters and return void. The macro has the form:</p>
<pre><code>ON_COMMAND(id, memberFxn)
</code></pre>
<p>
Command update messages are routed through the same mechanism as <b>ON_COMMAND</b> handlers. The <b>ON_UPDATE_COMMAND_UI</b> macro is used instead. Command update handler member functions take a single parameter, a pointer to a <b>CCmdUI</b> object, and return void. The macro has the form</p>
<pre><code>ON_UPDATE_COMMAND_UI(id, memberFxn)
</code></pre>
<p>
An extended form of command message handlers is available for advanced uses. The <b>ON_COMMAND_EX</b> macro is used instead and provides a superset of the <b>ON_COMMAND</b> functionality. Extended command-handler member functions take a single parameter, a UINT containing the command ID, and return a BOOL. The BOOL return should be TRUE to indicate that the command has been handled, otherwise routing will continue to other command target objects.</p>
<p>
Examples of the above forms:
<ul type=disc>
<li>
Inside RESOURCE.H (usually generated by Visual C++)<pre><code>#define&nbsp;&nbsp;&nbsp; ID_MYCMD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 100
#define&nbsp;&nbsp;&nbsp; ID_COMPLEX&nbsp;&nbsp;&nbsp; 101
</code></pre>
</li>
<li>
Inside the class declaration<pre><code>afx_msg void OnMyCommand();
afx_msg void OnUpdateMyCommand(CCmdUI* pCmdUI);
afx_msg BOOL OnComplexCommand(UINT nID);
</code></pre>
</li>
<li>
Inside the message map definition<pre><code>ON_COMMAND(ID_MYCMD, OnMyCommand)
ON_UPDATE_COMMAND_UI(ID_MYCMD, OnUpdateMyCommand)
ON_COMMAND_EX(ID_MYCMD, OnComplexCommand)
</code></pre>
</li>
<li>
In the implementation file<pre><code>void CMyClass::OnMyCommand()
{
 &nbsp;&nbsp; // handle the command
}

void CMyClass::OnUpdateMyCommand(CCmdUI* pCmdUI)
{
 &nbsp;&nbsp; // set the UI state with pCmdUI
}

BOOL CMyClass::OnComplexCommand(UINT nID)
{
 &nbsp;&nbsp; // handle the command
 &nbsp;&nbsp; return TRUE;
}
</code></pre>
</li>
</ul>
<p>
Also available for advanced use is <b>ON_COMMAND_RANGE</b> and <b>ON_COMMAND_RANGE_EX</b> which allow you to handle a range of commands with a single command handler. See the product documentation for more information on these macros.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;ClassWizard supports creating <b>ON_COMMAND</b> and <b>ON_UPDATE_COMMAND_UI</b> handlers, but it does not support creating <b>ON_COMMAND_EX</b> or <b>ON_COMMAND_RANGE</b> handlers. However, Class Wizard will parse and allow you to browse all three command handler variants.</p>
<p class=label>
<b>Control Notification Messages</b></p>
<p>
Messages that are sent from child controls to a window have an extra bit of information in their message map entry: the control's ID. The message handler specified in a message map entry is called only if (1) the control notification code (high word of lParam), such as BN_CLICKED, matches the notification code specified in the message-map entry and (2) control ID (wParam) matches the control ID specified in the message-map entry.</p>
<p>
Custom control notification messages may use the <b>ON_CONTROL</b> macro to define a message map entry with a custom notification code. This macro has the form</p>
<pre><code>ON_CONTROL(wNotificationCode, id, memberFxn)
</code></pre>
<p>
For advanced usage <b>ON_CONTROL_RANGE</b> can be used to handle a specific control notification from a range of controls with the same handler.</p>
<p>
ClassWizard does not support creating an <b>ON_CONTROL</b> or <b>ON_CONTROL_RANGE</b> handler in the user interface; you must manually enter them with the text editor. Once entered, ClassWizard will parse these entries and allow you to browse them just like any other message map entries.</p>
<p>
The Windows Common Controls make use of the more powerful <b>WM_NOTIFY</b> for complex control notifications. This version of MFC has direct support for this new message with the <b>ON_NOTIFY</b> and <b>ON_NOTIFY_RANGE</b> macros. See the product documentation for more information on these macros.</p>
<p>
<a href="_mfcnotes_technical_notes_by_number.htm">Technical Notes by Number</a>  |&nbsp; <a href="_mfcnotes_technical_notes_by_category.htm">Technical Notes by Category</a></p>
</font></BODY>
</HTML>
