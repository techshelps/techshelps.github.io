<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>TN030: Customizing Printing and Print Preview</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY>
<font face="verdana,arial,helvetica" size="2">
<h1><a name="_mfcnotes_tn030"></a><sup></sup>TN030: Customizing Printing and Print Preview</h1>
<p>
This note describes the process of customizing printing and print preview and describes the purposes of the callback routines used in <b>CView</b> and the callback routines and member functions of <b>CPreviewView</b>.</p>
<p class=label>
<b>The Problem</b></p>
<p>
MFC provides a complete solution for most printing and print preview needs. In most cases, little additional code is required to have a view able to print and preview. However, there are ways to optimize printing that require significant effort on the part of the developer, and some applications need to add specific user interface elements to the print preview mode.</p>
<p class=label>
<b>Efficient Printing</b></p>
<p>
When an MFC application prints using the standard methods, Windows directs all Graphical Device Interface (GDI) output calls to an in-memory metafile. When <b>EndPage</b> is called, Windows plays the metafile once for each physical band that the printer requires to print one page. During this rendering, GDI frequently queries the Abort Procedure to determine if it should continue. Typically the abort procedure allows messages to be processed so that the user may abort the print job using a printing dialog.</p>
<p>
Unfortunately, this can slow the printing process. If the printing in your application must be faster than can be achieved using the standard technique, you must implement manual banding.</p>
<p class=label>
<b>Print Banding</b></p>
<p>
In order to manually band, you must re implement the print loop such that <b>OnPrint</b> is called multiple times per page (once per band). The print loop is implemented in the <b>OnFilePrint</b> function in viewprnt.cpp. In your <b>CView</b>-derived class, you overload this function so that the message map entry for handling the print command calls your print function. Copy the <b>OnFilePrint</b> routine and change the print loop to implement banding. You will probably also want to pass the banding rectangle to your printing functions so that you can optimize drawing based on the section of the page being printed.</p>
<p>
Second, you must frequently call <b>QueryAbort</b> while drawing the band. Otherwise, the Abort Procedure will not get called and the user will be unable to cancel the print job.</p>
<p class=label>
<b>Print Preview:&nbsp; Electronic Paper with User Interface</b></p>
<p>
Print Preview, in essence, tries to turn the display into an emulation of a printer. By default, the client area of the main window is used to display one or two pages fully within the window. The user is able to zoom in on an area of the page to see it in more detail. With additional support, the user may even be allowed to edit the document in preview mode.</p>
<p class=label>
<b>Customizing Print Preview</b></p>
<p>
This note only deals with one aspect of modifying print preview: Adding UI to preview mode. Other modifications are possible, but such changes are out of the scope of this discussion.</p>
<p>
Briefly, the process of adding UI to the preview mode is to:
<ol>
<li>
Derive a view class from <b>CPreviewView</b>.<br><br></li>
<li>
Add command handlers for the UI aspects you desire.<br><br></li>
<li>
If you are adding visual aspects to the display, override <b>OnDraw</b> and perform your drawing after calling <b>CPreviewView::OnDraw.</b></li>
</ol>
<p class=label>
<b>OnFilePrintPreview</b></p>
<p>
This is the command handler for print preview. Its default implementation is:</p>
<pre><code>void CView::OnFilePrintPreview()
{
 &nbsp;&nbsp; // In derived classes, implement special window handling here
 &nbsp;&nbsp; // Be sure to Unhook Frame Window close if hooked.

 &nbsp;&nbsp; // must not create this on the frame. Must outlive this function
 &nbsp;&nbsp; CPrintPreviewState* pState = new CPrintPreviewState;

 &nbsp;&nbsp; if (!DoPrintPreview(AFX_IDD_PREVIEW_TOOLBAR, this,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RUNTIME_CLASS(CPreviewView), pState))
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // In derived classes, reverse special window handling
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // here for Preview failure case

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TRACE0("Error: DoPrintPreview failed");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AfxMessageBox(AFX_IDP_COMMAND_FAILURE);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delete pState;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // preview failed to initialize, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // delete State now
 &nbsp;&nbsp; }
}
</code></pre>
<p>
<b>DoPrintPreview</b> will hide the main pane of the application. Control Bars, such as the status bar, can be retained by specifying them in the pState-&gt;<b>dwStates</b> member (This is a bit mask and the bits for individual control bars are defined by <b>AFX_CONTROLBAR_MASK</b>( AFX_IDW_MYBAR)). The window pState-&gt;<b>nIDMainPane</b> is the window that will be automatically hidden and reshown. <b>DoPrintPreview</b> will then create a button bar for the standard Preview UI. If special window handling is needed, such as to hide or show other windows, that should be done before <b>DoPrintPreview</b> is called.</p>
<p>
By default, when print preview finishes, it returns the control bars to their original states and the main pane to visible. If special handling is needed, it should be done in an override of <b>EndPrintPreview.</b> If <b>DoPrintPreview</b> fails, also provide special handling.</p>
<p>
DoPrintPreview is called with:
<ul type=disc>
<li>
The Resource ID of the dialog template for the preview toolbar.<br><br></li>
<li>
A pointer to the view to perform the printing for the print preview<br><br></li>
<li>
The run-time class of the Preview View class. This will be dynamically created in DoPrintPreview.<br><br></li>
<li>
The CPrintPreviewState pointer. Note that the CPrintPreviewState structure (or the derived structure if the application needs more state preserved) must <i>not</i> be created on the frame. DoPrintPreview is modeless and this structure must survive until EndPrintPreview is called.<p class=atl>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;If a separate view or view class is needed for printing support, a pointer to that object should be passed as the second parameter.</p></li>
</ul>
<p class=label>
<b>EndPrintPreview</b></p>
<p>
This is called to terminate the print preview mode. It is often desirable to move to the page in the document that was last displayed in print preview. <b>EndPrintPreview</b> is the application's chance to do that. The pInfo-&gt;<b>m_nCurPage</b> member is the page that was last displayed (leftmost if two pages were displayed), and the pointer is a hint as to where on the page the user was interested. Since the structure of the application's view is unknown to the framework, the you must provide the code to move to the chosen point.</p>
<p>
You should perform most actions before calling <b>CView::EndPrintPreview</b>. This call reverses the effects of <b>DoPrintPreview</b> and deletes pView, pDC, and pInfo.</p>
<pre><code>// Any further cleanup should be done here.
CView::EndPrintPreview(pDC, pInfo, point, pView);
</code></pre>
<p class=label>
<b>CWinApp::OnFilePrintSetup</b></p>
<p>
This must be mapped for the Print Setup menu item. In most cases, it is not necessary to override the implementation.</p>
<p class=label>
<b>Page Nomenclature</b></p>
<p>
Another issue is that of page numbering and order. For simple word processor type applications, this is a straightforward issue. Most print preview systems assume that each printed page corresponds to one page in the document.</p>
<p>
In trying to provide a generalized solution, there are several things to consider. Imagine a CAD system. The user has a drawing that covers several E-size sheets. On an E-size (or a smaller, scaled) plotter, page numbering would be as in the simple case. But on a laser printer, printing 16 A-size pages per sheet, what does print preview consider a “page”?</p>
<p>
As the introductory paragraph states, Print Preview is acting like a printer. Therefore, the user will see what would come out of the particular printer that is selected. It is up to the view to determine what image is printed on each page.</p>
<p>
The page description string in the <b>CPrintInfo</b> structure provides a means of displaying the page number to the user if it can be represented as one number per page (as in “Page 1” or “Pages 1-2”). This string is used by the default implementation of <b>CPreviewView::OnDisplayPageNumber</b>. If a different display is needed, one may override this virtual function to provide, for example, “Sheet1, Sections A, B”.</p>
<p>
<a href="_mfcnotes_technical_notes_by_number.htm">Technical Notes by Number</a>  |&nbsp; <a href="_mfcnotes_technical_notes_by_category.htm">Technical Notes by Category</a></p>
</font></BODY>
</HTML>
