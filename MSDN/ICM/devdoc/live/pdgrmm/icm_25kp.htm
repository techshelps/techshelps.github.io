<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CMGetPS2ColorSpaceArray</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_win32_cmgetps2colorspacearray"></a>CMGetPS2ColorSpaceArray</h1>
<p>
<span style=color:#FF0000>[This is preliminary documentation and subject to change.]</span> </p>
<p>
The <b>CMGetPS2ColorSpaceArray</b> function retrieves the PostScript Level 2 color space array from a profile. </p>
<pre><code><b>BOOL WINAPI CMGetPS2ColorSpaceArray(
  HPROFILE </b><i>hProfile</i><b>, </b>
<b>  DWORD </b><i>dwIntent</i><b>, </b>
<b>  DWORD </b><i>dwCSAType</i><b>, </b>
<b>  LPBYTE </b><i>lpBuffer</i><b>, </b>
<b>  LPDWORD </b><i>lpcbSize</i><b>, </b>
<b>  LPBOOL </b><i>lpbBinary</i> 
<b>);</b>
 </code></pre>
<h4>Parameters</h4>
<dl>
<dt>
<i>hProfile</i></dt>
<dd>
Specifies the profile to use.</dd>
<dt>
<i>dwIntent</i></dt>
<dd>
Specifies the desired rendering intent for the color space array. Can be one of the following values:
<pre><code>INTENT_PERCEPTUAL
INTENT_SATURATION
INTENT_RELATIVE_COLORIMETRIC
INTENT_ABSOLUTE_COLORIMETRIC
 </code></pre>

<p>
For more information, see <a href="icm_3ng3.htm">Rendering Intents</a>.
</dd>
<dt>
<i>dwCSAType</i></dt>
<dd>
Specifies the type of color space array. Can take one of the following values:
<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=24%>Constant</th>
<th align=left width=76%>Meaning</th>
</tr>
<tr valign=top>
<td width=24%>CSA_A</td>
<td width=76%>Get a CIEBasedA color space array from the monochrome profile.</td>
</tr>
<tr valign=top>
<td width=24%>CSA_GRAY</td>
<td width=76%>Get a CIEBasedA color space array from the monochrome profile.</td>
</tr>
<tr valign=top>
<td width=24%>CSA_ABC</td>
<td width=76%>Get a CIEBasedABC color space array from the RGB or L<sup>*</sup>a<sup>*</sup>b profile.</td>
</tr>
<tr valign=top>
<td width=24%>CSA_DEF</td>
<td width=76%>Get a CIEBasedDEF color space array from the RGB or L<sup>*</sup>a<sup>*</sup>b profile.</td>
</tr>
<tr valign=top>
<td width=24%>CSA_RGB</td>
<td width=76%>Get a CIEBasedDEF color space array followed by a CIEBasedABC color space array from the RGB profile. On execution, if the printer doesn't support CIEBasedDEF color spaces, the function uses the CIEBasedABC definition.</td>
</tr>
<tr valign=top>
<td width=24%>CSA_Lab</td>
<td width=76%>Gets a CIEBasedABC color space array from the L<sup>*</sup>a<sup>*</sup>b profile.</td>
</tr>
<tr valign=top>
<td width=24%>CSA_DEFG</td>
<td width=76%>Get a CIEBasedDEFG color space array from the CMYK profile.</td>
</tr>
<tr valign=top>
<td width=24%>CSA_CMYK</td>
<td width=76%>Get a CIEBasedCMYK color space array from the CMYK profile.</td>
</tr>
</table><br>

</dd>
<dt>
<i>lpBuffer</i></dt>
<dd>
Pointer to a buffer in which the color space array is to be placed. If the pointer is NULL, the function returns the size required for this buffer in the memory location pointed to by <i>lpcbSize</i>.</dd>
<dt>
<i>lpcbSize</i></dt>
<dd>
Pointer to a variable specifying the size of the buffer. On return, the variable contains has the number of bytes actually copied to the buffer.</dd>
<dt>
<i>lpbBinary</i></dt>
<dd>
Pointer to a Boolean variable. If its value is TRUE, data returned could be binary, or if FALSE, the data should be ASCII85 encoded. On return, the value of in the memory location pointed to by <i>lpbBinary</i> indicates whether the data returned actually is binary or ASCII85.
</dd>
</dl>
<h4>Return Values</h4>
<p>
If this function succeeds, the return value is TRUE. It also returns TRUE if it is called with <i>lpBuffer</i> set to NULL and the size of the required buffer is copied into <i>lpcbSize</i>.</p>
<p>
If this function fails, the return value is FALSE. When this occurs, the CMM should call <b>SetLastError</b> to set the last error to a valid error value defined in Winerror.h.</p>
<h4>Remarks</h4>
<p>
This function is optional for all CMMs.</p>
<p>
If a CMM does not support this function, Windows uses the default CMM to create the color space array.</p>
<p>
If the color space array tag is not present in the profile, the CMM should create the color space array from the profile contents. The resulting color space array can be used as the operand for the PostScript Level 2 <b>setcolorspace</b> operator.</p>
<h4>QuickInfo</h4>
<p>
<b>&nbsp;&nbsp;Windows NT: </b>Requires version 5.0 or later.<br>
<b>&nbsp;&nbsp;Windows: </b>Requires Windows 98.<br>
<b>&nbsp;&nbsp;Windows CE: </b>Unsupported.<br>
<b>&nbsp;&nbsp;Header: </b>Declared in wingdi.h.<br>
<b>&nbsp;&nbsp;Import Library: </b>Use gdi32.lib.</p>
<h4>See Also</h4>
<p>
<a href="icm_156c.htm">Color Management Overview</a>, <a href="icm_4f77.htm">ICM 2.0 Functions</a> </p>
<p>&nbsp;</p></body>
</HTML>
