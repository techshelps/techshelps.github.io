<HTML><HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>The Installable Driver Interface</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">
<FONT FACE="verdana,arial,helvetica" SIZE="2">
<H3>The Installable Driver Interface </H3><P>All audio device drivers are installable drivers and must provide a <B>DriverProc</B> entry point. Installable drivers and the <B>DriverProc</B> entry point are described in the Microsoft Windows Software Development Kit. </P>
<H4><A NAME="sec0"></A>Driver Configuration </H4><P>Installable drivers can supply a configuration dialog box for users to access through an application (such as a Control Panel application). </P>
<P>Interrupt-level and port assignments, and any other hardware-related settings, should be stored in the registry, in the appropriate subkey of the following registry key: </P>
<P><BR></P>
<PRE>HKEY_LOCAL_MACHINE\System\CurrentControlSet\control\MediaResources
</PRE>
<H4><A NAME="sec1"></A>The DriverProc Entry-Point Function </H4><P>Regardless of how many types of audio devices a driver supports, the driver will always have a single <B>DriverProc</B> function. </P>
<P>Generally, when a driver is enabled, you initialize the hardware, hook interrupts, allocate any memory that you need, and set a flag to indicate the driver is enabled. If your driver has not been enabled by MMSYSTEM, or if it failed the enable process, the driver should return MMSYSERR_NOTENABLED from any messages it receives from client applications. When a driver is disabled, you free any memory that you allocated, unhook interrupts, reset the hardware, and set a flag to indicate the driver is not enabled. </P>
<H4><A NAME="sec2"></A>Handling the DRV_DISABLE Message </H4><P>It is possible for a driver to receive a DRV_DISABLE message while it is in the process of sending or receiving audio data. Audio device drivers should follow the behavior specified in the following table when they receive a DRV_DISABLE/DRV_ENABLE message pair: </P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="144pt" VALIGN="TOP"><COL WIDTH="204pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B>Driver Type </B></P></TD><TD VALIGN="TOP"><P><B>Disable/Enable Behavior </B></P></TD></TR><TR><TD VALIGN="TOP"><P>waveform output </P></TD><TD VALIGN="TOP"><P>As if the driver were paused with a WODM_PAUSE message and then restarted with a WODM_RESTART message. </P></TD></TR><TR><TD VALIGN="TOP"><P>waveform input </P></TD><TD VALIGN="TOP"><P>As if the driver were stopped with a WIDM_STOP message and then restarted with a WIDM_START message. </P></TD></TR><TR><TD VALIGN="TOP"><P>MIDI output </P></TD><TD VALIGN="TOP"><P>If the driver is asynchronous, stop output when disabled and continue when reenabled. </P></TD></TR><TR><TD VALIGN="TOP"><P>MIDI input </P></TD><TD VALIGN="TOP"><P>As if the driver were stopped with a MIDM_STOP message and then restarted with a MIDM_START message. </P></TD></TR></TBODY></TABLE>
<P><BR></P><P></P>
<P>Most audio device drivers will be interrupt-driven. For example, a waveform output device interrupts when the device needs another data block. A MIDI input device interrupts when the device receives a MIDI event at its input port. </P>
<H4><A NAME="sec3"></A>Fixing Code and Data Segments </H4><P>Any code segments or data segments a driver accesses at interrupt-time must be fixed segments. For best overall system performance, you should minimize the amount of code and data in fixed segments. To minimize the amount of fixed code, isolate all interrupt-time code in a few source modules and put this code into a single fixed code segment. Unless your driver has a large amount of data not accessed at interrupt time, use a single fixed data segment. </P>
<P>For example, the Sound Blaster sample driver is a medium-model DLL, using a single data segment and multiple code segments. This example fixes the data segment and the code segments named _TEXT and WEP_TEXT. All other code segments are moveable. The code segment _TEXT is used as a safety measure. The compiler places code for which you do not specify a segment in the _TEXT segment. This way, any code that is missed will be placed into a fixed segment, preventing possible problems at interrupt time. However, you should check your segmentation to ensure that only code that is required to be FIXED goes into the FIXED code segment. </P>
<H4><A NAME="sec4"></A>Allocating and Using Memory </H4><P>You can allocate either local memory or global memory for use at interrupt time. </P>
<P>To allocate local memory for use at interrupt time, follow these steps: </P>
<P>    1    Use <B>LocalAlloc</B> with the LMEM_FIXED flag to get a handle to the memory block. </P>
<P>    2    Pass this handle to <B>LocalLock</B> to get a near pointer to the memory block. </P>
<P></P>
<P>Any global memory a driver uses at interrupt-time must be page-locked. To allocate and page-lock global memory, follow these steps: </P>
<P>    1    Use <B>GlobalAlloc</B> with the GMEM_MOVEABLE and GMEM_SHARE flags to get a handle to the memory block. </P>
<P>    2    Pass this handle to <B>GlobalLock</B> to get a far pointer to the memory block. </P>
<P>    3    Pass the high-order word of the far pointer to <B>GlobalPageLock</B> to page-lock the memory block. </P>
<P></P>
<H4><A NAME="sec5"></A>Calling Windows Functions at Interrupt Time </H4><P>The only Windows functions a driver can call at interrupt time are <B>PostMessage</B>, <B>PostAppMessage</B>, <B>DriverCallback</B>, <B>timeGetSystemTime</B>, <B>timeGetTime</B>, <B>timeSetEvent</B>, <B>timeKillEvent</B>, <B>midiOutShortMsg</B>, <B>midiOutLongMsg</B>, and <B>OutputDebugStr</B>. </P></FONT></BODY></HTML>
