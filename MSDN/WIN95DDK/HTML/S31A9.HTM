<HTML><HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Tips and Traps</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">
<FONT FACE="verdana,arial,helvetica" SIZE="2">
<H2>Tips and Traps </H2><P>This section describes common problems that VxD writers encounter and suggests ways to avoid them. </P>
<P><B>Tip:</B> To avoid cancelling a timeout after it has been dispatched, ensure that the timeout callback procedure immediately set the variable that holds the timeout handle to zero. </P>
<P><B>Tip:</B> To avoid cancelling a timeout twice by mistake, use the following method: </P>
<P><BR></P>
<PRE>    xor     esi, esi
    xchg    [hTimeOut], esi
    VMMCall Cancel_Time_Out
</PRE>
<P>If this code is executed twice by mistake, the second time will not cause any harm. Note, however, that there is still an opportunity for a race condition to occur between the <B>xchg</B> instruction and the call to the <B>Cancel_Time_Out</B> service. To be extra sure that you don't cancel the wrong timeout by mistake, put the routine in locked code. If the timeout being cancelled is an asynchronous timeout, you also need to disable interrupts. </P>
<P><B>Tip:</B> To enumerate all of the threads in the System VM, you can't just call <B>Get_Initial_Thread_Handle</B> to retrieve the System VM (or <B>Get_Sys_Thread_Handle</B>), and then call <B>Get_Next_Thread_Handle</B> until you retrieve the handle of a VM whose parent is not the System VM (or until you get back where you started). The reason is that the initial thread handle happens to be the <I>last</I> thread in the list, so the next time you call <B>Get_Next_Thread_Handle</B>, you will be bumped into the next VM and think the game is over. Instead, call <B>Get_Sys_Thread_Handle</B>, and then call <B>Get_Next_Thread_Handle</B> repeatedly until you get back to the system thread handle. For each thread along the way, skip it if the parent VM is not the System VM. </P>
<P><B>Trap:</B> Forgetting to zero-initialize the thread data slot. Remember that thread data slots are not zero-initialized. When one is allocated, you have to go through every thread in the system and initialize each one. </P></FONT></BODY></HTML>
