<HTML><HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Hook_V86_Fault</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">
<FONT FACE="verdana,arial,helvetica" SIZE="2">
<H3>Hook_V86_Fault </H3><P><BR></P>
<PRE>include vmm.inc

mov     eax, FaultNo         ; fault number 
mov     esi, OFFSET32 FaultProc ; points to a fault handler
VMMcall Hook_V86_Fault

jc      not_installed        ; carry flag set if not installed
; The following line is optional. See the following comments section.
mov     [Previous], esi      ; points to previous fault handler (if any)
</PRE>
<P>Installs a fault handler procedure for V86 mode faults. Virtual devices typically install fault handlers while processing the <B>Sys_Critical_Init</B> message to handle faults, such as general protection faults, that the VMM fault handlers cannot handle. The VMM installs its fault handlers after the <B>Sys_Critical_Init</B> control message. Virtual devices install fault handlers after <B>Sys_Critical_Init</B> to handle faults before the fault is passed to the VMM fault handlers. Uses ESI, Flags. </P>
<UL><LI>     Returns with the carry flag clear if successful, set otherwise. If the carry flag is clear, and if FaultProc is a hook procedure, the address of the previous handler is stored in the hook variable. If there was no previous handler, the address of the default handler is stored in the hook variable. Regardless of whether FaultProc is a hook procedure, the ESI register contains the address of the previous fault handler (zero if there was no previous handler). The return value in ESI exists solely for backward compatibility with Windows 3.1. </LI></UL><P></P>
<P><I>FaultNo</I> </P>
<P>Fault number for which to install the fault handler. The fault number cannot be 02h, and must not be greater than 4Fh. </P>
<P><I>FaultProc</I> </P>
<P>Address of the fault handler to install. For more information about the handler, see below. </P>
<P>A virtual device can install a fault handler while processing the <B>Sys_Critical_Init</B> message or at a later time. When a fault occurs, fault handlers installed after the <B>Sys_Critical_Init</B> message receive control first, the VMM fault handlers receive control next, and fault handlers installed during the <B>Sys_Critical_Init</B> message receive control last. (Of course, dynamically-loaded VxDs have no choice but to install the fault handler after <B>Sys_Critical_Init</B>, because they haven't yet been loaded at the time the <B>Sys_Critical_Init</B> message is broadcast.) </P>
<P>The system disables interrupts and calls the fault handler as follows: </P>
<P><BR></P>
<PRE>mov     ebx, VM                 ; current VM handle
mov     ebp, OFFSET32 crs       ; points to a Client_Reg_Struc
call    [FaultProc]
</PRE>
<P>The <I>VM</I> parameter is a handle identifying the current virtual machine, and the <I>crs</I> parameter points to a <B>Client_Reg_Struc</B> structure containing the register values for the current virtual machine. </P>
<P>If the fault procedure does not process the fault, it should pass the fault to the previous fault handler, as stored into the hook variable, making sure that <I>all</I> registers are preserved (not just the registers containing input parameters). </P>
<P>The default fault handler crashes the virtual machine, except for faults 0 (divide), 1 (trace), 3 (breakpoint), 4 (overflow), 5 (bound), and 7 (coprocessor), which are reflected as interrupts. </P>
<P>If the fault handler processes the fault, or if there is no previous fault handler, the handler should return without chaining by executing a near <B>ret</B> instruction (not an <B>iret</B> instruction). </P>
<P>The fault handler can modify the EAX, EBX, ECX, EDX, ESI, and EDI registers. </P>
<P>Do not use this service to install a fault handler for the Non-Maskable Interrupt (NMI). Instead, a virtual device must use the <B>Get_NMI_Handler_Addr</B> and <B>Set_NMI_Handler_Addr</B> services. </P>
<P>Do not use this service to install handlers for hardware interrupts. Instead, a virtual device must use virtual PIC device services. </P>
<P>See also <B>Hook_PM_Fault</B>, <B>Hook_VMM_Fault</B> </P>
<P></P>
<P></P></FONT></BODY></HTML>
