<HTML><HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Hook_V86_Int_Chain</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">
<FONT FACE="verdana,arial,helvetica" SIZE="2">
<H3>Hook_V86_Int_Chain </H3><P><BR></P>
<PRE>include vmm.inc

mov     eax, Interrupt          ; number of interrupt to hook
mov     esi, OFFSET32 HookProc  ; points to hook procedure
VMMcall Hook_V86_Int_Chain

jc      not_installed           ; carry flag set if procedure not installed
</PRE>
<P>Installs a hook procedure that the system calls whenever the specified interrupt occurs. Virtual devices use this service to monitor software interrupts, and simulated hardware interrupts in V86 mode. Unlike Windows 3.1 in which this service was available only during initialization, Windows 95 allows V86 interrupt hooks to be installed after initialization is complete. Uses Flags. </P>
<UL><LI>     Returns with the carry flag clear if successful, set otherwise. </LI></UL><P></P>
<P><I>Interrupt</I> </P>
<P>Number of the interrupt for which to install the hook procedure. </P>
<P><I>HookProc</I> </P>
<P>Address of the hook procedure. For more information about the hook procedure, see below. </P>
<P>The system calls the hook procedure whenever the corresponding interrupt occurs, a virtual device calls the <B>Simulate_Int</B> service, or the system simulates a hardware interrupt. This means a hook procedure must make no assumptions about the origin of the interrupt. </P>
<P>The system calls the procedure as follows: </P>
<P><BR></P>
<PRE>mov     eax, Interrupt      ; number of interrupt hooked
mov     ebx, VM             ; current VM handle
mov     ebp, OFFSET32 crs   ; points to a Client_Reg_Struc
call    [HookProc]

jc      pass_to_next        ; carry set if interrupt not serviced
</PRE>
<P>The <I>Interrupt</I> parameter is the number of the current interrupt, the <I>VM</I> parameter is a handle identifying the current virtual machine, and the <I>crs</I> parameter points to a <B>Client_Reg_Struc</B> structure containing the register values of the current virtual machine. If the hook procedure services the interrupt, it must clear the carry flag to prevent the system from passing the interrupt to the next hook procedure. </P>
<P>Any number of virtual devices can install a hook procedure for a given interrupt. The system always calls the last hook procedure first. A hook procedure either services the interrupt or directs the system to pass the interrupt to the next hook procedure. If no hook procedure services the interrupt, the system reflects the interrupt to the virtual machine. </P>
<P>This service is recommended instead of hooking the V86 interrupt vector directly. </P>
<P>See also <B>Set_V86_Int_Vector</B>, <B>Simulate_Int</B> </P>
<P></P>
<P></P></FONT></BODY></HTML>
