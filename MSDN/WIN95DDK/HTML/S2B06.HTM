<HTML><HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>The Entry Point for MIDI Output Drivers</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">
<FONT FACE="verdana,arial,helvetica" SIZE="2">
<H3>The Entry Point for MIDI Output Drivers </H3><P>A MIDI output driver must have an entry-point function named <B>modMessage</B> to process messages sent by MMSYSTEM. </P>
<H4><A NAME="sec0"></A>Synchronous Versus Asynchronous Message Processing </H4><P>MIDI output device drivers can process the MODM_DATA and MODM_LONGDATA messages either synchronously or asynchronously. If a driver processes these messages synchronously, it waits until all the data has been sent to the hardware before returning from the <B>modMessage</B> function. An asynchronous driver puts the data in a queue and returns immediately. The data is then sent to the hardware in the background. </P>
<P>Whether a driver is written to be synchronous or asynchronous usually depends on the hardware being supported. An asynchronous driver is desirable because it lets foreground applications run while it processes data; however, some hardware may not support asynchronous data transfer. The Sound Blaster sample driver processes the MODM_DATA and MODM_LONGDATA messages synchronously. </P>
<H4><A NAME="sec1"></A>Interrupt-Time and Reentrancy Considerations for modMessage </H4><P>The <B>midiOutShortMsg</B> and <B>midiOutLongMsg</B> functions can be called by applications (and by device drivers) at interrupt time. Thus, the <B>modMessage</B> entry-point function in a MIDI output device driver can be accessed at interrupt time and must be written to be reentrant for the MODM_DATA and MODM_LONGDATA messages. </P>
<P></P>
<P><B>Note </B></P>
<P>For internal MIDI synthesizer drivers, the interrupt-time reception of the MODM_DATA and MODM_LONGDATA messages has an additional consequence: The driver cannot access the disk at interrupt-time to load patch data if it receives a MIDI program-change request. </P>
<P></P>
<P>An example of the reentrancy situation is illustrated by an application that takes incoming MIDI events and sends them to a MIDI output port. The application's low-level callback function for MIDI input receives a MIDM_DATA message, accompanied by the incoming MIDI data. The callback function calls <B>midiOutShortMsg</B> to send the data to a MIDI output port. The <B>modMessage</B> entry-point function in the output port driver is called with a MODM_DATA message. This all happens at interrupt time. While <B>modMessage</B> is processing the MODM_DATA message, another MIDI event arrives at the input port, and the process starts again, with <B>modMessage</B> being reentered with another MODM_DATA message. </P>
<P>To handle being called at interrupt time, the <B>modMessage</B> entry-point function must follow these guidelines: </P>
<UL><LI>     <B>modMessage</B> must reside in a FIXED code segment. Any functions called during processing of the MODM_DATA and MODM_LONGDATA messages must also be in a FIXED code segment. </LI><LI>     <B>modMessage</B> can access only data in FIXED data segments when processing the MODM_DATA and MODM_LONGDATA messages. </LI></UL><P></P>
<P>One way for synchronous drivers to be reentrant is to detect when <B>modMessage</B> is reentered and return a MIDIERR_NOTREADY error. </P>
<P></P>
<P><B>Note </B></P>
<P>A good way for a synchronous driver to handle being reentered is for the driver to maintain a small buffer to hold data received when it's reentered, instead of returning MIDIERR_NOTREADY. Before the driver returns from the original modMessage call (the one that was reentered), it makes sure that all data in this buffer is sent to the hardware. </P>
<P></P></FONT></BODY></HTML>
