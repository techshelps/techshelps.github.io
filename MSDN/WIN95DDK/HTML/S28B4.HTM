<HTML><HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>GET_TOTAL_VRAM_SIZE (Function 36)</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">
<FONT FACE="verdana,arial,helvetica" SIZE="2">
<H3>GET_TOTAL_VRAM_SIZE (Function 36) </H3><P><B>Call With</B></P>
<P>EBX: Contains the VM handle (always the currently executing VM). </P>
<P>EBP: Contains the Windows VM's Client Registers. </P>
<P><B>Return Values</B></P>
<P>Save everything that you use. CY returned means that mini-VDD handled the call. ECX contains the total size of VRAM on the card. </P>
<P><B>Remarks</B></P>
<P>Whenever the VDD saves a hi-res mode, it saves all of the card's video memory to the swap file. This is because VESA applications have full access to the total memory on the card, even if their visible screen size is less than the total VRAM size on the card. Therefore, the Main VDD must know the total VRAM size. If the mini-VDD does not handle this call, the Main VDD will do a time-consuming call to VESA BIOS function 4F00h to obtain this information. For performance reasons, you should implement this function. </P>
<P></P>
<P></P></FONT></BODY></HTML>
