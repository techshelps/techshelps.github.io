<HTML><HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>_Assert_Range</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">
<FONT FACE="verdana,arial,helvetica" SIZE="2">
<H3>_Assert_Range </H3><P><BR></P>
<PRE>#include vmm.h 

_Assert_Range(DWORD pStruc, DWORD ulSize, DWORD sSignature, 
              DWORD lSignatureOffset, DWORD ulFlags);
</PRE>
<P>Verifies that a pointer to any structure is valid. Uses the C calling convention. </P>
<P> Returns nonzero in the EAX register if the structure is valid; otherwise, returns zero. </P>
<P><I>pStruc</I> </P>
<P>Structure pointer to validate. </P>
<P><I>ulSize</I> </P>
<P>Size of the structure in bytes. </P>
<P><I>sSignature</I> </P>
<P>A DWORD value to validate. </P>
<P><I>lSignatureOffset</I> </P>
<P>Offset in bytes to <I>sSignature</I>. </P>
<P><I>ulFlags</I> </P>
<P>Validation flags. May be one or more of these values: </P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="144pt" VALIGN="TOP"><COL WIDTH="190pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>ASSERT_RANGE_NULL_BAD </P></TD><TD VALIGN="TOP"><P>Return failure for NULL pointers. May not be combined with ASSERT_RANGE_NULL_OK. </P></TD></TR><TR><TD VALIGN="TOP"><P>ASSERT_RANGE_NULL_OK </P></TD><TD VALIGN="TOP"><P>Return success for NULL pointers. May not be combined with ASSERT_RANGE_NULL_BAD. </P></TD></TR><TR><TD VALIGN="TOP"><P>ASSERT_RANGE_NO_DEBUG </P></TD><TD VALIGN="TOP"><P>Do not output a debugging message on failure when debugger is present. This flag is ignored if no debugger is installed. </P></TD></TR></TBODY></TABLE>
<P><BR></P><P></P>
<P>The following validation steps are taken. </P>
<P>    1    If pStruc is a null pointer, its validity is determined by which of the ASSERT_RANGE_NULL_BAD or ASSERT_RANGE_NULL_OK flags is passed. </P>
<P>    2    Otherwise, pStruc must be a pointer to valid data of length ulSize bytes. </P>
<P>    3    Furthermore, if sSignature is nonzero, then the DWORD at pStruc + lSignatureOffset must be equal to sSignature. </P>
<P></P>
<P>For example, suppose you have a structure defined as follows: </P>
<P><BR></P>
<PRE>struct ABC {
    DWORD member1;
    BYTE  member2[20];
    DWORD dwSignature;
};

// Every valid ABC has ABCSIGNATURE stored in the dwSignature field.

#define ABCSIGNATURE 0x31415926</PRE>
<P> If you want to check whether some pointer variable p is a valid pointer to a ABC, except that null pointers are okay, then you would write </P>
<P><BR></P>
<PRE>if (!_Assert_Range(p, sizeof(SAMPLE), ABCSIGNATURE, 
    offsetof( SAMPLE, dwSignature), ASSERT_RANGE_NULL_OK)) {
       return ERROR_INVALID_PARAMETER;
    }
</PRE>
<P>This service can be called only at a time when page faults can safely be handled. It cannot be called at hardware interrupt time, nor at any other time when paging is not allowed. Since this service touches the memory at <I>pStruc</I> as part of the validation (even if <I>sSignature</I> is zero), if <I>pStruc</I> points to a phys/linear region owned by memory-mapped hardware, there may be unusual side-effects. </P>
<P></P>
<P></P></FONT></BODY></HTML>
