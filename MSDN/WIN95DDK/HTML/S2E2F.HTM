<HTML><HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Initializing the Pen Driver</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">
<FONT FACE="verdana,arial,helvetica" SIZE="2">
<H3>Initializing the Pen Driver </H3><P>After installing the virtual pen driver, Windows next reads the pen installable driver component from the installable driver line of the SYSTEM.INI file. It loads the specified pen driver by calling the <B>OpenDriver</B> function, using the PENC.DRV filename. When the driver successfully loads, Windows sends it three messages in the following order: DRV_LOAD, DRV_ENABLE, and DRV_OPEN. The PENC.DRV driver handles these messages in its <B>DriverProc</B> function. </P>
<H4><A NAME="sec0"></A>Handling the DRV_LOAD Message </H4><P>The pen driver responds to DRV_LOAD by calling the multiplex interrupt (interrupt 2Fh) to get the protect-mode entry point in the previously-loaded virtual pen driver. The following code illustrates this: </P>
<P><BR></P>
<PRE>_asm {
         xor    di, di                          ; Initialize DI to zero.
         mov    ax, GET_VPEND_API_ENTRY_POINT   ; 1684h
         mov    bx, VPenD_Device_ID             ; Virtual Pen Driver ID
         int    2Fh                             ; Multiplex interrupt
; On return, ES:DI points to protect mode entry point in VxD.
         mov    word ptr vlpfnVpenD_API_Entry_Point+2, es;
         mov    word ptr vlpfnVpenD_API_Entry_Point, di
}
</PRE>
<P>If the virtual pen driver does not respond, the pen driver will return a failure condition to Windows. However, if the virtual pen driver exists in memory and responds correctly to the call, the pen driver next fills in a <B>VPEND_INIT</B> structure with information for the virtual pen driver to use. The pen driver then calls the virtual pen driver entry point that is pointed to by ES:DI. The virtual pen driver records the information for future use and initializes the <B>DRV_PENINFO</B> structure pointed to by the <B>lpPenInfo</B> member of the <B>VPEND_INIT</B> structure. All the members of the <B>VPEND_INIT</B> and <B>DRV_PENINFO</B> structures are defined in the "Reference" section of <I>About the Pen Driver</I>. </P>
<H4><A NAME="sec1"></A>Handling the DRV_ENABLE Message </H4><P>When the pen driver receives the DRV_ENABLE message from Windows, it calls the virtual pen driver to begin reflecting interrupts into the system. The virtual pen driver then sets a callback timer for handling out-of-range packets and returns. For a definition of out-of-range packets and a description of how they are handled see the section "Time-Based Interrupts" in <I>About the Virtual Pen Driver</I>. </P>
<H4><A NAME="sec2"></A>Handling the DRV_OPEN Message </H4><P>When the pen driver receives the DRV_OPEN message, it returns the value DRV_SUCCESS unless </P>
<UL><LI>     The pen driver cannot enable the virtual pen driver to deflect interrupts into the system. </LI><LI>     The DRV_OPEN message is received during setup. </LI></UL><P></P>
<H4><A NAME="sec3"></A>Registering the PENWIN.DLL Callback Function </H4><P>When the PENWIN.DLL library loads, it opens the pen driver. PENWIN.DLL sends the pen driver a DRV_SetEntryPoints message, specifying a <B>ProcessTabletEvents</B> entry point in PENWIN.DLL. For a description of the <B>ProcessTabletEvents</B> function, see the "Reference" section in <I>About the Pen Driver</I>. This is the entry point the driver calls at interrupt time to provide pen packet information to its client, the PENWIN.DLL library. </P></FONT></BODY></HTML>
