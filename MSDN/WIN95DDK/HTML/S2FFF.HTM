<HTML><HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DSHDR</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">
<FONT FACE="verdana,arial,helvetica" SIZE="2">
<H3>DSHDR </H3><P><BR></P>
<PRE>DSHDR STRUC
    dspStamp    dw  ?  ; Identifying stamp ('DM')
    dspCommand  db  ?  ; Command ('R' or 'W')
    dspResult   dw  ?  ; see below
DSHDR ENDS
</PRE>
<P>Defines the portion of the IOCTL header that is common to all DriveSpace Receive Control Data IOCTLs. Notice that WORD alphanumeric constants are shown as they would be defined for MASM. Thus, 'DM' is equivalent to 444Dh, and 'OK' is equivalent to 4B4Fh. When dumped as two consecutive bytes or as a text string, these values would appear as "MD" and "KO" respectively. The <B>dspCommand</B> field is typically an ASCII character. For the raw read IOCTL, <B>dspCommand</B> is set to 'r'; for raw writes, it is set to 'w'. </P>
<P><B>dsp_result</B> </P>
<P>Can be one of these values: </P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="144pt" VALIGN="TOP"><COL WIDTH="190pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B>Value </B></P></TD><TD VALIGN="TOP"><P><B>Meaning </B></P></TD></TR><TR><TD VALIGN="TOP"><P>DSRROK ('OK') </P></TD><TD VALIGN="TOP"><P>Success </P></TD></TR><TR><TD VALIGN="TOP"><P>DSRRWRITE (0001h) </P></TD><TD VALIGN="TOP"><P>Intervening write occurred </P></TD></TR><TR><TD VALIGN="TOP"><P>DSRRLOCK (0002h) </P></TD><TD VALIGN="TOP"><P>Buffer lock failed </P></TD></TR><TR><TD VALIGN="TOP"><P>DSRRIO (0003h) </P></TD><TD VALIGN="TOP"><P>I/O error </P></TD></TR><TR><TD VALIGN="TOP"><P>DSRRBADCLUS (0004h) </P></TD><TD VALIGN="TOP"><P>Invalid MDFAT index </P></TD></TR><TR><TD VALIGN="TOP"><P>DSRRUNALLOC (0005h) </P></TD><TD VALIGN="TOP"><P>Attempt to read unallocated cluster </P></TD></TR><TR><TD VALIGN="TOP"><P>DSRRBADSECTOR (0006h) </P></TD><TD VALIGN="TOP"><P>Bad starting sector </P></TD></TR><TR><TD VALIGN="TOP"><P>DSRRBADSIZE (0007h) </P></TD><TD VALIGN="TOP"><P>Bad cluster size </P></TD></TR><TR><TD VALIGN="TOP"><P>DSRRNOSIZE (0008h) </P></TD><TD VALIGN="TOP"><P>Uncompressed size unknown </P></TD></TR><TR><TD VALIGN="TOP"><P>DSRRNOTFREE (0009h) </P></TD><TD VALIGN="TOP"><P>Some target sectors were not free </P></TD></TR><TR><TD VALIGN="TOP"><P>DSRRXBOUND (000Ah) </P></TD><TD VALIGN="TOP"><P>Allocation crosses BitFAT boundary </P></TD></TR><TR><TD VALIGN="TOP"><P>DSRRNULLPTR (000Bh) </P></TD><TD VALIGN="TOP"><P>NULL pointer passed to write </P></TD></TR><TR><TD VALIGN="TOP"><P>DSRRSECCOUNT (000Ch) </P></TD><TD VALIGN="TOP"><P>Sector count mismatch </P></TD></TR><TR><TD VALIGN="TOP"><P>DSRRPKTSIZE (000Dh) </P></TD><TD VALIGN="TOP"><P>Packet size is too small </P></TD></TR><TR><TD VALIGN="TOP"><P>DSRRDATAWRITE (000Eh) </P></TD><TD VALIGN="TOP"><P>Data was written </P></TD></TR><TR><TD VALIGN="TOP"><P>DSRRBADFRAG (000Fh) </P></TD><TD VALIGN="TOP"><P>Bad fragment table </P></TD></TR></TBODY></TABLE>
<P><BR></P><P></P>
<P></P>
<P></P></FONT></BODY></HTML>
