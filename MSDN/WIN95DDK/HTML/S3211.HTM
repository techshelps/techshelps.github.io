<HTML><HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>_PageAllocate</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">
<FONT FACE="verdana,arial,helvetica" SIZE="2">
<H3>_PageAllocate </H3><P><BR></P>
<PRE>// C syntax
#include &lt;vmm.h&gt;

ULONG EXTERN _PageAllocate(ULONG nPages, ULONG pType, ULONG VM, 
    ULONG AlignMask, ULONG minPhys, ULONG maxPhys, ULONG *PhysAddr,
    ULONG flags);

; assembler syntax
include vmm.inc

VMMcall _PageAllocate, &lt;nPages, pType, VM, AlignMask, minPhys,
    maxPhys, &lt;OFFSET32 PhysAddr&gt;, flags&gt;

test    eax, eax             ; returns 0 on error
jz      error

mov     [Address], eax       ; linear address of allocated memory block
</PRE>
<P>Allocates a block of memory consisting of the specified number of pages. This service reserves linear address space for the memory block, and depending on the value of the <I>flags</I> parameter, may also map the linear addresses to physical memory, locking the pages in memory. The service returns a memory handle that can be used in subsequent memory management functions to lock, unlock, reallocate, and free the memory block. Uses EAX, ECX, EDX, and flags. </P>
<UL><LI>     Returns the ring-0 linear address of the memory block (in the EAX register). For compatibility with Windows 3.1, the same value is returned in EDX. For Windows 3.1, EAX was the memory handle and EDX the memory address. For Windows 95, the handle and the linear address are always the same. Both registers are zero if an error occurs, such as insufficient memory. </LI></UL><P></P>
<P><I>nPages</I> </P>
<P>Number of pages to allocate for the memory block. This parameter must not be zero. </P>
<P><I>pType</I> </P>
<P>Value specifying the type of pages to allocate. Must be PG_HOOKED, PG_SYS, or PG_VM. If PG_SYS is specified, the pages are allocated in the system arena. Otherwise, they are allocated in the ring 3 shared arena. There is no real difference between the PG_HOOKED and PG_VM types. </P>
<P><I>VM</I> </P>
<P>Handle of the virtual machine for which to allocate the pages. This parameter applies to pages allocated using the PG_VM and PG_HOOKED values only. This parameter must be zero if the <I>nType</I> parameter specifies PG_SYS. </P>
<P><I>AlignMask</I> </P>
<P>Alignment mask that defines acceptable starting page numbers for the memory block. This parameter can be one of the following values: </P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="144pt" VALIGN="TOP"><COL WIDTH="190pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B>Value </B></P></TD><TD VALIGN="TOP"><P><B>Meaning </B></P></TD></TR><TR><TD VALIGN="TOP"><P>00000000h </P></TD><TD VALIGN="TOP"><P>Physical address is a multiple of 4K. </P></TD></TR><TR><TD VALIGN="TOP"><P>00000001h </P></TD><TD VALIGN="TOP"><P>Physical address is a multiple of 8K. </P></TD></TR><TR><TD VALIGN="TOP"><P>00000003h </P></TD><TD VALIGN="TOP"><P>Physical address is a multiple of 16K. </P></TD></TR><TR><TD VALIGN="TOP"><P>00000007h </P></TD><TD VALIGN="TOP"><P>Physical address is a multiple of 32K. </P></TD></TR><TR><TD VALIGN="TOP"><P>0000000Fh </P></TD><TD VALIGN="TOP"><P>Physical address is a multiple of 64K. </P></TD></TR><TR><TD VALIGN="TOP"><P>0000001Fh </P></TD><TD VALIGN="TOP"><P>Physical address is a multiple of 128K. </P></TD></TR></TBODY></TABLE>
<P><BR></P><P></P>
<P>This parameter is used only if the <I>flags</I> parameter specifies the PAGEUSEALIGN value. </P>
<P><I>minPhys</I> </P>
<P>Minimum acceptable physical page number in the memory block. All page numbers must be greater than or equal to this value. This parameter is used only if the <I>flags</I> parameter specifies the PAGEUSEALIGN value. </P>
<P><I>maxPhys</I> </P>
<P>Maximum acceptable physical page number in the memory block. All page numbers must be less than this value. This parameter is used only if the <I>flags</I> parameter specifies the PAGEUSEALIGN value. </P>
<P><I>PhysAddr</I> </P>
<P>Address of a four-byte buffer that receives the physical address of the start of the memory block. The service uses this parameter only if the <I>flags</I> parameter specifies the PAGECONTIG and PAGEUSEALIGN values. The service ignores this parameter if it is zero. </P>
<P><I>flags</I> </P>
<P>Operation flags. Can be zero or more of these values: </P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="144pt" VALIGN="TOP"><COL WIDTH="190pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B>Value </B></P></TD><TD VALIGN="TOP"><P><B>Meaning </B></P></TD></TR><TR><TD VALIGN="TOP"><P>PAGECONTIG </P></TD><TD VALIGN="TOP"><P>Allocates contiguous physical pages to create the memory block. This value is ignored if the PAGEUSEALIGN value is not also specified. </P></TD></TR><TR><TD VALIGN="TOP"><P>PAGEFIXED </P></TD><TD VALIGN="TOP"><P>Locks the allocated pages in memory at a fixed linear address, and prevents the pages from subsequently being unlocked or moved. The service locks the memory block regardless of the type of virtual page swap device present. </P>
<P>the page will remain locked throughout its life, use PAGEDFIXED; it's more efficient than PAGELOCKED. </P></TD></TR><TR><TD VALIGN="TOP"><P>PAGELOCKED </P></TD><TD VALIGN="TOP"><P>Locks the allocated pages in the memory. The pages can be subsequently unlocked using the <B>_PageUnLock</B> service. The service locks the memory block regardless of the type of virtual page swap device present. </P></TD></TR><TR><TD VALIGN="TOP"><P>PAGELOCKEDIFDP </P></TD><TD VALIGN="TOP"><P>Locks the allocated pages in the memory only if the virtual page swap device uses MS-DOS or BIOS functions to write to the hardware. If the pages are locked, they can be subsequently unlocked using the <B>_PageUnLock</B> service. </P>
<P>irtual device must not specify the PAGELOCKEDIFDP value until after it has received the <B>Init_Complete</B> message. </P>
<P> PAGELOCKED and PAGELOCKEDIFDP values are mutually exclusive. </P></TD></TR><TR><TD VALIGN="TOP"><P>PAGEUSEALIGN </P></TD><TD VALIGN="TOP"><P>Allocates pages using the alignment and physical addresses specified by the <I>AlignMask</I>, <I>minPhys</I>, and <I>maxPhys</I> parameters. If this value is specified, PAGEFIXED must also be specified. </P></TD></TR><TR><TD VALIGN="TOP"><P>PAGEZEROINIT </P></TD><TD VALIGN="TOP"><P>Fills the memory block with zeros. If this value is not given, the contents of the memory block are undefined. </P></TD></TR></TBODY></TABLE>
<P><BR></P><P></P>
<P>All other values are reserved. </P>
<P>This service reserves linear address space by calling the <B>_PageReserve</B> service, and then commits physical storage by calling the <B>_PageCommit</B> service. The address returned by this service can be used in the same manner as the linear address returned by the <B>_PageReserve</B> service. </P>
<P>Unless the PAGELOCKED, PAGELOCKEDIFDP, or PAGEFIXED value is specified, the allocated pages are not initially present in physical memory. The system maps a page into physical memory (pages it in) when a virtual device attempts to access the page. You can force a page to be present by using the <B>_PageLock</B> service. </P>
<P>Virtual devices use the PAGEUSEALIGN value to allocate buffers for use by the device which have additional alignment restrictions enforced by the hardware. For example, a DMA may require buffers to start at addresses that are a multiple of 64K or 128K. When allocating such buffers, the PAGECONTIG value is often used in combination with PAGEUSEALIGN. </P>
<P>See also <B>_PageFree</B>, <B>_PageLock</B>, <B>_PageReAllocate</B>, <B>_PageUnLock</B> </P>
<P></P>
<P></P></FONT></BODY></HTML>
