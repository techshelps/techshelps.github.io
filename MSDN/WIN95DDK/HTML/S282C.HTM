<HTML><HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>VDD_Takeover_VGA_Port</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">
<FONT FACE="verdana,arial,helvetica" SIZE="2">
<H3>VDD_Takeover_VGA_Port </H3><P><B>Call With</B></P>
<P>EDX contains the VGA port number to takeover (in the range 3C0h through 3DFh). ECX contains the address of the routine in the mini-VDD that will be the handler for this I/O port. </P>
<P><B>Return Values</B></P>
<P>ECX is returned with the address of the old port handling routine. EDX and ECX are destroyed by this call. The carry flag is set on failure. </P>
<P><B>Remarks</B></P>
<P>The Main VDD at <B>Device_Init</B> time takes over accesses to all of the standard VGA ports from port 3C0h up to and including port 3DFh. Some of these ports are not really used by the standard VGA or may be used in different ways by the mini-VDD. Sometimes, the mini-VDD may need to handle all aspects of virtualizing these ports instead of letting the Main VDD do any handling. In this case, the mini-VDD can call this service in order to have all virtualized I/O for the port vectored to the mini-VDD's handler. The Main VDD will not do any virtualization or interact in any way when the port is virtualized. The Main VDD will however, decide when to enable and disable trapping on the VGA port in question. The mini-VDD's handler is passed the usual port virtualization information in the registers (that is, EAX contains the value, EBX contains the VM Handle, ECX contains the I/O type, EDX contains the port number). </P>
<P>If you need some virtualization assistance from the Main VDD, do not use this function. For example, if the mini-VDD needs to virtualize some extensions to the CRTC ports and wants to let the Main VDD handle accesses to the standard VGA indices, it would hook <B>VIRTUALIZE_CRTC_IN</B> and/or <B>VIRTUALIZE_CRTC_OUT</B> which would let it get first crack at virtualizing the CRTC registers. Only use this function if the mini-VDD does not need any virtualization assistance from the Main VDD. </P>
<P>The mini-VDD can also chain back to the Main VDD's handler for a VGA port. Using the S3 sample mini-VDD as an example, suppose you need to collect states for a VGA port that there's no mini-VDD virtualization hook for (in the case of S3, we need to virtualize the Miscellaneous Output Port 3CCH).You can call this service at <B>Dynamic_Init </B>time, but save the value returned in ECX. Then, your virtualization routine (in the S3 example, see <B>MiniVDD_VirtualMiscOutput</B> for details) can collect all of the necessary states that it needs, or modify the default virtualization, and then jump back to the old handler whose address was saved. This provides maximum flexibility in handling VGA ports. </P></FONT></BODY></HTML>
