<HTML><HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Client Virtual Device Services</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">
<FONT FACE="verdana,arial,helvetica" SIZE="2">
<H3>Client Virtual Device Services </H3><P>VCOMM client VxD services enable VxDs to use any communications resource for which a port driver is installed. VCOMM provides services for opening and closing a communications resource, configuring a port, reading from and writing to a communications resource, processing communications events, and calling a port driver's extended functions. The following topics describe the VCOMM client VxD services. </P>
<H4><A NAME="sec0"></A>VCOMM Client VxDs </H4><P>VxDs use the VCOMM client VxD services for a variety of reasons. Following are some examples of VCOMM client VxDs: </P>
<UL><LI>     Application-defined VxDs. An application can install a private VxD that calls the VCOMM services directly, bypassing the Windows communications API. This approach can be useful for implementing time-critical protocols (such as FAX) that require interrupt-time processing. 
<P>Because creating a private VxD ties your application to Windows 95, you should do so only if necessary. Microsoft(r) Win32(r) applications are scheduled regularly enough to meet the timing requirements of most protocols, such as those for file transfer. </P></LI><LI>     Port virtualization VxDs. Port virtualization VxDs simulate communications hardware for applications running in VMs. By using the VCOMM client VxD services, a port virtualization VxD can redirect the virtualized device to any communications resource for which a port driver is installed. </LI><LI>     Many modems are external, attaching to standard serial ports, or are internal but emulate a standard serial UART. Modem drivers for such devices typically do not duplicate the functionality of an existing port driver, but instead call VCOMM client VxD services to perform their input and output. </LI></UL><P></P>
<H4><A NAME="sec1"></A>Open and Close Services </H4><P>Before performing any other operations on a communications resource, a client VxD must call the <B>_VCOMM_OpenComm</B> service to open the resource. This service initializes the communications device and the port driver associated with it, and returns a communications handle that is used in subsequent calls to VCOMM client VxD services. </P>
<P>The <B>_VCOMM_CloseComm</B> service closes a communications resource. If the transmit queue is not empty, the <I>close property</I> of the port determines whether the remaining data is sent before the port is closed: if it is PORTCLOSE_WAIT, the service does not close the port and does not return until the characters in the transmit queue have been sent; if it is PORTCLOSE_FLUSH, the service discards the data in the transmit queue and closes the port immediately. You can query and set the close property using the <B>_VCOMM_EscapeCommFunction</B> service. </P>
<P>Client VxDs must close any communications resources they open. A VxD that opens a communications resource for use in a virtual machine (VM) must process the <B>VM_Not_Executeable</B> event so that it can close the resource if the VM terminates. </P>
<P>See also <B>_VCOMM_CloseComm</B>, <B>_VCOMM_EscapeCommFunction</B>, <B>_VCOMM_OpenComm</B> </P>
<H4><A NAME="sec2"></A>Configuration Services </H4><P>You can use VCOMM services to configure a communications resource and initialize its receive and transmit queues. The <B>_DCB</B> (device control block) structure specifies the configuration settings for a communications resource - for example, the baud rate, the number of data bits per byte, and the number of stop bits per byte. Additional fields specify parity, handshaking options, and special characters used for handshaking or for signaling events. </P>
<P>When you open a communications resource, the port driver initializes it using a default configuration. You can determine the current configuration by calling the <B>_VCOMM_GetCommState</B> service, that fills in a <B>_DCB</B> structure. Before configuring the communications resource, you can determine which settings it supports by calling the <B>_VCOMM_GetCommProperties</B> service; this service fills in a <B>_COMMPROP</B> structure. To configure the communications resource, call the <B>_VCOMM_SetCommState</B> service. </P>
<P>To initialize the receive and transmit queues for a communications resource, call the <B>_VCOMM_SetupComm</B> service. The previous state of the receive queue is returned in the specified <B>_QSB</B> structure. If you do not call this service, the port driver uses default queues. The <B>_COMMPROP</B> structure specifies the default and maximum sizes of the receive and transmit queues. Note that port drivers for some devices, such as LPT ports, do not use queues. </P>
<P>See also <B>_COMMPROP</B>, <B>_DCB</B>, <B>_QSB</B>, <B>_VCOMM_GetCommProperties</B>, <B>_VCOMM_GetCommState</B>, <B>_VCOMM_SetCommState</B>, <B>_VCOMM_SetupComm</B> </P>
<H4><A NAME="sec3"></A>Read and Write Services </H4><P>To write to a communications resource, call the <B>_VCOMM_WriteComm</B> service. This service writes the specified data to the transmit queue and returns immediately. Always check both the return value of this service and the number of bytes written. If there is insufficient space in the transmit queue, the number of bytes written is less than the number requested - yet the return value is TRUE. In this case, call the <B>_VCOMM_ClearCommError</B> service to detect and reset any communications errors that may have occurred. </P>
<P>For communications devices that do not use transmit queues, such as LPT ports, <B>_VCOMM_WriteComm</B> actually writes the data to the device before returning. If a write time-out occurs, the number of bytes written is less than the number requested and the return value is FALSE. </P>
<P>To send high-priority characters, such as event characters, you can use the <B>_VCOMM_TransmitCommChar</B> service. This service sends a single character ahead of any data in the transmit queue. Until the hardware is ready to send the character, most port drivers store it in a special one-character buffer. If a character specified in a previous call to this service is still waiting to be sent, the service returns FALSE. </P>
<P>To read from a communications resource, call the <B>_VCOMM_ReadComm</B> service. This service reads the specified amount of data from the receive queue and returns immediately. Always check both the return value of this service and the number of bytes read. If the receive queue does not contain enough data, the number of bytes read is less than the number requested - yet the return value is TRUE. If the number of bytes read is zero, call <B>_VCOMM_ClearCommError</B> to detect and reset any communications errors that may have occurred. </P>
<P>For output-only devices, such as LPT ports, <B>_VCOMM_ReadComm</B> returns TRUE with zero bytes read. For other communications devices that do not uses receive queues, <B>_VCOMM_ReadComm</B> actually reads the data from the device before returning. If a read time-out occurs, the number of bytes read is less than the number requested and the return value is FALSE. </P>
<P>You can check the status of the transmit and receive queues by calling the <B>_VCOMM_GetCommQueueStatus</B> service; this service fills in a <B>_COMSTAT</B> structure. You can discard the contents of the transmit or receive queue by calling the <B>_VCOMM_PurgeComm</B> service. </P>
<P>See also <B>_COMSTAT</B>, <B>_VCOMM_ClearCommError</B>, <B>_VCOMM_GetCommQueueStatus</B>, <B>_VCOMM_PurgeComm</B>, <B>_VCOMM_ReadComm</B>, <B>_VCOMM_TransmitCommChar</B>, <B>_VCOMM_WriteComm</B> </P>
<H4><A NAME="sec4"></A>Event Services </H4><P>A VCOMM client can receive notifications when communications events occur or when the receive and transmit queues pass specified thresholds. To receive notifications for events, call the <B>_VCOMM_EnableCommNotification</B> service. To receive notifications when queue thresholds are reached, call the <B>_VCOMM_SetReadCallback</B> and <B>_VCOMM_SetWriteCallback</B> services. All three services register client-defined callback functions with the port driver. For information about the callback functions, see the description of the <B>CommNotifyProc</B> function. </P>
<P>You receive notifications for communications events only if the events are enabled. To enable events, call the <B>_VCOMM_SetCommEventMask</B> service; this service specifies the event mask and, optionally, the address of the event variable. The <I>event mask</I> is a 32-bit variable that specifies the combination of enabled events. The <I>event variable</I> is a 32-bit variable that specifies the enabled events that were detected; the port driver updates the event variable at interrupt time when events occur. To determine which enabled events have occurred, call the <B>_VCOMM_GetCommEventMask</B> service; this service retrieves the detected events and clears the corresponding bits in the event variable. </P>
<P>If a hardware handshaking signal causes a notification, the parameters for <B>CommNotifyProc</B> identify the signal that changed but not the current state of the signal. To determine the current state of the clear to send (CTS), data set ready (DSR), receive line signal detect (RLSD), and ring signals, call the <B>_VCOMM_GetModemStatus</B> service. </P>
<P>See also <B>CommNotifyProc</B>, <B>_VCOMM_EnableCommNotification</B>, <B>_VCOMM_GetCommEventMask</B>, <B>_VCOMM_GetModemStatus</B>, <B>_VCOMM_SetCommEventMask</B>, <B>_VCOMM_SetReadCallback</B>, <B>_VCOMM_SetWriteCallback</B> </P>
<H4><A NAME="sec5"></A>Extended Functions </H4><P>You can use the <B>_VCOMM_EscapeCommFunction</B> service to direct the port driver to carry out an extended function. Constants defined in VCOMM.INC identify several extended functions that can be used - for example, to get or set the close property, set or clear hardware handshaking lines, or reset an LPT port. Individual port drivers may support only a subset of the extended functions defined in VCOMM.INC. </P>
<P>To expose unique features of a communications device, port drivers can define driver-specific extended functions not in VCOMM.INC. </P>
<P>See also <B>_VCOMM_EscapeCommFunction</B> </P></FONT></BODY></HTML>
