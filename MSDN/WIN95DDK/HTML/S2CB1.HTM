<HTML><HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Compressing Video Data</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">
<FONT FACE="verdana,arial,helvetica" SIZE="2">
<H3>Compressing Video Data </H3><P>Similar to decompressing video data, your driver will receive a series of messages when it is used to compress data. The client-application will send messages to your driver to coordinate the following activities: </P>
<UL><LI>     Obtaining the driver state </LI><LI>     Specifying the input format and determining the compression format </LI><LI>     Preparing to compress video </LI><LI>     Compressing the video </LI><LI>     Ending compression </LI></UL><P></P>
<P>The following messages are used by video compression drivers: </P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="223pt" VALIGN="TOP"><COL WIDTH="124pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B>Message </B></P></TD><TD VALIGN="TOP"><P><B>Description </B></P></TD></TR><TR><TD VALIGN="TOP"><P>ICM_COMPRESS </P></TD><TD VALIGN="TOP"><P>Compresses a frame of data into the buffer provided by the client-application. </P></TD></TR><TR><TD VALIGN="TOP"><P>ICM_COMPRESS_BEGIN </P></TD><TD VALIGN="TOP"><P>Prepares for compressing data. </P></TD></TR><TR><TD VALIGN="TOP"><P>ICM_COMPRESS_END </P></TD><TD VALIGN="TOP"><P>Cleans up after compressing. </P></TD></TR><TR><TD VALIGN="TOP"><P>ICM_COMPRESS_GET_FORMAT </P></TD><TD VALIGN="TOP"><P>Obtains the driver's suggest the output format of the compressed data. </P></TD></TR><TR><TD VALIGN="TOP"><P>ICM_COMPRESS_GET_SIZE </P></TD><TD VALIGN="TOP"><P>Obtains the maximum size of one frame of data when it is compressed in the output format. </P></TD></TR><TR><TD VALIGN="TOP"><P>ICM_COMPRESS_QUERY </P></TD><TD VALIGN="TOP"><P>Determines if a driver can compress a specific input format. </P></TD></TR></TBODY></TABLE>
<P><BR></P><P></P>
<P>The video compressed with these messages is returned to the client-application. When compressing data, your driver can use either software or hardware to do the compression. </P>
<P></P>
<P><B>Note: </B></P>
<P>When MSVideo recompresses a file, each frame is decompressed to a full frame before it is passed to the compressor. </P>
<P></P>
<H4><A NAME="sec0"></A>Obtaining the Driver State </H4><P>The client-application obtains the driver state by sending ICM_GETSTATE. The client-application determines the size of the buffer needed for the state information by sending this message with <I>dwParam1</I> set to NULL. Your driver should respond to the message by returning the size of the buffer it needs for state information. </P>
<P>After it determines the buffer size, the client-application resends the message with <I>dwParam1</I> pointing to a block of memory it allocated. The <I>dwParam2</I> parameter specifies the size of the memory block. Your driver should respond by filling the memory with its state information. If your driver uses state information, include only optional decompression parameters with the state information. State information typically includes the setup specified by user with the ICM_CONFIGURE dialog box. Any information required for decompressing the image data must be included with the format data. When done, your driver should return the size of the state information. </P>
<P>The client-application does not validate any data in the state information. It simply stores the state information in the 'strd' data chunk of the AVI file. </P>
<H4><A NAME="sec1"></A>Specifying the Input Format and Determining the Compression Format </H4><P>The client-application uses the ICM_COMPRESS_GET_FORMAT or ICM_COMPRESS_QUERY message to specify the input format and determine the compression (output) format. The client-application sends ICM_COMPRESS_GET_FORMAT if it wants your driver to suggest the compressed format. The client-application sends ICM_COMPRESS_QUERY to determine if your driver supports a format it is suggesting. </P>
<P>Both messages have a pointer to a BITMAPINFO data structure in <I>dwParam1</I>. This structure specifies the format of the incoming uncompressed data. The contents of <I>dwParam2</I> depends on the message. </P>
<P>If the client-application wants your driver to suggest the format, it determines the size of the buffer needed for the compressed data format by sending ICM_COMPRESS_GET_FORMAT. When requesting the buffer size, the client-application uses <I>dwParam1</I> to point to a BITMAPINFO structure and sets <I>dwParam2</I> to NULL. Based on the input format, your driver should return the number of bytes needed for the format buffer. Return a buffer size at least large enough to hold a BITMAPINFOHEADER data structure and a color table. </P>
<P>The client-application gets the output format by sending ICM_COMPRESS_GET_FORMAT with valid pointers to BITMAPINFO structures in both <I>dwParam1</I> and <I>dwParam2</I>. Your driver should return the output format in the buffer pointed to by <I>dwParam2</I>. If your driver can produce multiple formats, the format selected by your driver should be the one that preserves the greatest amount of information rather than one that compresses to the most compact size. This will preserve image quality if the video data is later edited and recompressed. </P>
<P>The output format data becomes the 'strf' chunk in the AVI RIFF file. The data must start out like a BITMAPINFOHEADER data structure. You can include any additional information required to decompress the file after the BITMAPINFOHEADER data structure. A color table (if used) follows this information. </P>
<P>If you have format data following the BITMAPINFOHEADER structure, update the <B>biSize</B> member to specify the number of bytes used by the structure and your additional data. If a color table is part of the BITMAPINFO information, it follows immediately after your additional information. </P>
<P>If your driver cannot handle the input format, it returns ICMERR_BADFORMAT to fail the message. </P>
<P>If your driver gets ICM_COMPRESS_QUERY, the <I>dwParam1</I> parameter points to a BITMAPINFO data structure containing the input format data. The <I>dwParam2</I> parameter will either be NULL or contain a pointer to a BITMAPINFO structure describing the compressed format the client-application wants to use. If <I>dwParam2</I> is NULL, your compression driver can use any output format. (The client-application just wants to know if your driver can handle the input.) If <I>dwParam2</I> points to a BITMAPINFO structure, the client-application is suggesting the output format. </P>
<P>If your driver supports the specified input and output format, or it supports the specified input with NULL specified for <I>dwParam2</I>, return ICERR_OK to indicate the driver accepts the formats. Your driver does not have to accept the suggested format. If you fail the message by returning ICERR_BADFORMAT, the client-application suggests alternate formats until your driver accepts one. If your driver exhausts the list of formats normally used, the client-application requests a format with ICM_COMPRESS_GET_FORMAT. </P>
<H4><A NAME="sec2"></A>Initialization for the Compression Sequence </H4><P>When the client-application is ready to start compressing data, it sends the ICM_COMPRESS_BEGIN message. The client-application uses <I>dwParam1</I> to point to the format of the data being compressed, and uses <I>dwParam2</I> to point to the format for the compressed data. If your driver cannot handle the formats, or if they are incorrect, your driver should return ICERR_BADFORMAT to fail the message. </P>
<P>Before the client-application starts compressing data, it sends ICM_COMPRESS_GET_SIZE. For this message the client-application uses <I>dwParam1</I> to point to the input format and uses <I>dwParam2</I> to point to the output format. Your driver should return the worst case size (in bytes) that it expects a compressed frame to occupy. The client-application uses this size value when it allocates buffers for the compressed video frame. </P>
<H4><A NAME="sec3"></A>Compressing the Video </H4><P>The client-application sends ICM_COMPRESS for each frame it wants compressed. It uses <I>dwParam1</I> to point to an ICCOMPRESS structure containing the parameters used for compression. Your driver uses the buffers pointed to by the members of ICCOMPRESS for returning information about the compressed data. </P>
<P>Your driver returns the actual size of the compressed data in the <B>biSizeImage</B> member in the BITMAPINFOHEADER data structure pointed to by the <B>lpbiOutput</B> member of ICCOMPRESS. </P>
<P>The format of the input data is specified in a BITMAPINFOHEADER structure pointed to by the <B>lpbiInput</B> member of ICDECOMPRESS. The input data is in a buffer specified by the <B>lpInput</B> member. The <B>lpbiOutput</B> and <B>lpOutput</B> members contain pointers to the format data and buffer used for the output data. Your driver must indicate the size of the compressed video data in the <B>biSizeImage</B> member in the BITMAPINFO structure specified for <B>lpbiOutput</B>. </P>
<P>The <B>dwFlags</B> member specifies flags used for compression. The client-application sets ICM_COMPRESS_KEYFRAME flag if the input data should be treated as a key frame. (A key frame is one that does not require data from a previous frame for decompression.) When this flag is set, your driver should treat the image as the initial image in a sequence. </P>
<P>The <B>lpckid</B> member specifies a pointer to a buffer used to return the chunk ID for data in the AVI file. Your driver should assign a two-character code for the chunk ID only if it uses a custom chunk ID. </P>
<P>The <B>lpdwFlags</B> member specifies a pointer to a buffer used to return flags for the AVI index. The client-application will add the returned flags to the file index for this chunk. If the compressed frame is a key frame (a frame that does not require a previous frame for decompression), your driver should set the AVIIF_KEYFRAME flag in this member. Your driver can define its own flags but they must be set in the high word only. </P>
<P>The <B>lFrameNum</B> member specifies the frame number of the frame to compress. If your driver is performing fast temporal compression, check this member to see if frames are being sent out of order or if the client-application is having a frame recompressed. </P>
<P>The <B>dwFrameSize</B> member indicates the maximum size (in bytes) desired for the compressed frame. If it specifies zero, your driver determines the size of the compressed image. If it is non-zero, your driver should try to compress the frame to within the specified size. This might require your driver to sacrifice image quality (or make some other trade-off) to obtain the size goal. Your driver should support this if it sets the VIDCF_CRUNCH flag when it responds to the ICM_GETINFO message. </P>
<P>The <B>dwQuality</B> member specifies the compression quality. Your driver should support this if it sets the VIDCF_QUALITY flag when it responds to the ICM_GETINFO message. </P>
<P>The format of the previous data is specified in a BITMAPINFOHEADER structure pointed to by <B>lpbiPrev</B>. The input data is in a buffer specified by <B>lpPrev</B>. Your driver will use this information if it performs temporal compression (that is, it needs the previous frame to compress the current frame). If your driver supports temporal compression, it should set the VIDCF_TEMPORAL flag when it responds to the ICM_GETINFO message. If your driver supports temporal compression and does not need the information in the <B>lpbiPrev</B> and <B>lpPrev</B> members, it should set the VIDCF_FASTTEMPORALC flag when it responds to the ICM_GETINFO message. The VIDCF_FASTEMPORALC flag can decrease the processing time because your driver does not need to access data specified in <B>lpbiPrev</B> and <B>lpPrev</B>. </P>
<P>When your driver has finished compressing the data, it returns ICERR_OK. </P>
<H4><A NAME="sec4"></A>Ending Compression </H4><P>Your driver receives ICM_COMPRESS_END when the client-application no longer needs data compressed, or when the client-application is changing the format or palette. After sending ICM_COMPRESS_END, the client-application must send ICM_COMPRESS_BEGIN to continue compressing data. Your driver should not expect the client-application to send a ICM_COMPRESS_END message for each ICM_COMPRESS_BEGIN message. The client-application can use ICM_COMPRESS_BEGIN to restart compression without sending ICM_COMPRESS_END. </P>
<P>When the driver is no longer needed, the system will close it by sending DRV_CLOSE. </P></FONT></BODY></HTML>
