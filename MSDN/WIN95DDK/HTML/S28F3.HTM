<HTML><HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Step 2. Adapting the OEMDONGL.C Source Code</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">
<FONT FACE="verdana,arial,helvetica" SIZE="2">
<H3>Step 2. Adapting the OEMDONGL.C Source Code </H3><P>The DDK supplied with the DDK has VxD support for the following IR devices: </P>
<UL><LI>     ACTiSYS ACT-200L Infrared Wireless Interface (ACT200L.VXD) </LI><LI>     ACTiSYS ACT-220L Infrared Wireless Interface (ACT220L.VXD) </LI><LI>     Adaptec(tm) AIRport APA-9320 External Infrared Adapter; this adapter is also called the Adaptec AIRport 2000 (ADAPTEC.VXD) </LI><LI>     Adaptec AIRport 1000 (ADAPTEC.VXD) </LI><LI>     AMP PhasIR Serial Adapter (CRYSTAL.VXD) </LI><LI>     Extended Systems JetEye PC Infrared PC Interface, ESI-9680 (ESI.VXD) </LI><LI>     Parallax IR Adapter LiteLink PRA9500A (PARALLAX.VXD) </LI></UL><P></P>
<P>If your IR device is not one listed above or is not compatible with one of those devices, then you must modify the OEMDONGL.C source code to support your device and create a new VxD. In order to produce a VxD that works with the generic serial IrFramer to support your device, adapt the OEMDONGL.C sample source code to your dongle hardware, compile it, and link it to DONGLE.LIB and CVXDCTRL.ASM. </P>
<H4><A NAME="sec0"></A>Establishing the Microsoft Infrared Communications for Windows 95 Build Environment </H4><P>The first step in creating your own IrFramer is to establish a build environment. In order to build binary files that are comparable with the current shipping versions, you will need to use the same tools that were used to build the shipping versions. The build environment includes a C Compiler, Assembler, Linker, include files and libraries - all of the tools necessary to build executable modules from the sample source code provided in this DDK. </P>
<P>If you install both the Win32 SDK and Windows 95 DDK on your development system, then you will have all the header files and libraries you need. You also have to install a set of compilers and an assembler. </P>
<P>Follow this sequence of steps in establishing your build environment: </P>
<P>    1.     Install the compilers and assembler. The following are all necessary: Microsoft Visual C, version 2.x (for 32-bit development), Microsoft Visual C, version 1.5x (for 16-bit development), and Microsoft Assembler, version 6.11c. </P>
<P>    2.     Next, install the Win32 SDK. </P>
<P>    3.     Lastly, install the Windows 95 DDK. </P>
<P></P>
<H4><A NAME="sec1"></A>Introducing the Sample Source Code </H4><P>The sample source code for your VxD is in the DDK subdirectory. The source code modules in the DDK subdirectory that you must modify are described in the following table: </P>

<TABLE COLS="3" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="116pt" VALIGN="TOP"><COL WIDTH="116pt" VALIGN="TOP"><COL WIDTH="116pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B>File </B></P></TD><TD VALIGN="TOP"><P><B>Description </B></P></TD><TD VALIGN="TOP"><P><B>Comment </B></P></TD></TR><TR><TD VALIGN="TOP"><P>OEMDONGL.C </P></TD><TD VALIGN="TOP"><P>Contains the OEMDongleTable which is an array of <B>DONGLE_TYPE</B> structures that list the supported dongles and their support functions. </P>
<P>Contains the OEMDongleTableLen variable that specifies the number of dongles that support is being added for. </P>
<P>Contains the functions to support initializing the dongle, setting the dongle's speed (from 2400 baud to 115,200 baud), and turning off the dongle. </P></TD><TD VALIGN="TOP"><P>The functions currently in OEMDONGL.C are for the ACTiSYS 200L dongle, except the content of the OEMDongleTable array and the names of the <B>type_Init</B>, <B>type_SetSpeed</B>, and <B>type_Deinit</B> functions have been changed to highlight the parts of the code you must change. Note that the name of the OEMDongleTable array and the OEMDongleTableLen variable must not be changed. More details about this are given below. </P></TD></TR><TR><TD VALIGN="TOP"><P>CVXDCTRL.ASM </P></TD><TD VALIGN="TOP"><P>Wrapper that can be linked with OEMDONGL.C to produce a dynamically loadable VxD. </P></TD><TD VALIGN="TOP"><P>The sample CVXDCTRL.ASM source code is for the ACTiSYS 200L dongle. You will have to edit this code to establish the name of your VxD. </P></TD></TR></TBODY></TABLE>
<P><BR></P><P></P>
<H4><A NAME="sec2"></A>Editing the OEMDongleTable Array and Registry </H4><P>To add a dongle type that can be used by the framer, add the dongle type's identifying string and pointers to its <B>type_Init</B>, <B>type_SetSpeed</B>, and <B>type_Deinit</B> functions to the <B>OEMdongleTable</B> array. The sample source code that defines the array in OEMDONGLE.C looks like this: </P>
<P><BR></P>
<PRE>    DONGLE_TYPE OEMDongleTable[] =
    {
        {"OEM", OEM_Init, OEM_SetSpeed, OEM_Deinit }
    };
        
    U32 OEMDongleTableLen = (sizeof(OEMDongleTable)/sizeof(DONGLE_TYPE));
        </PRE>
<P>The <B>DONGLE_TYPE</B> structure is defined in _DONGLE.H: </P>
<P><BR></P>
<PRE>    // Data structure used to hold Dongle information
    typedef struct _DONGLE_TYPE
    {
        char*                  typeName; // Name of dongle in the registry
        IRLAPFRM_DONGLE_INIT   init;     // Pointer to init function
        IRLAPFRM_DONGLE_SET    set;      // Pointer to setSpeed function
        IRLAPFRM_DONGLE_DEINIT deinit;   // Pointer to deinit function
    } DONGLE_TYPE, *PDONGLE_TYPE;
</PRE>
<P>So, for example, if your IR dongle device model is named the REDEYE-88 you could edit the <B>OEMDongleTable</B> array in OEMDONGLE.C to look like this: </P>
<P><BR></P>
<PRE>    DONGLE_TYPE OEMDongleTable[] =
    {
      {"RED88", RED88_Init, RED88_SetSpeed, RED88_Deinit}
    };
</PRE>
<P>You also have to write the name of your dongle type into the registry. The framer gets the names of the dongle types installed on a Windows 95 computer by reading the registry. To add your own dongle type name to the registry during development, you will have to adapt the INFRARED.INF file shipped with the DDK or use the Regedit utility. Continuing with the example, your dongle type name is "RED88." At the registry path HKEY_LOCAL_MACHINE\Enum\Infrared\Framer add the following key and value: </P>
<P><BR></P>
<PRE>DongleType="RED88"
</PRE>
<P>You must also add the name of your VxD to the registry. For example, if the name of your VxD is RED88.VXD, then at the registry path HKEY_LOCAL_MACHINE\Enum\Infrared\Framer you must add the following key and value: </P>
<P><BR></P>
<PRE>SpeedDriver="RED88.VXD"
</PRE>
<P>For information on editing the INFRARED.INF file to accomplish these changes to the registry when your VxD is installed using Setup, see <I>Creating an Installation Diskette and Installing the IR Communications Software</I>. </P>
<H4><A NAME="sec3"></A>Adapting the Interface Exposed to the IrFramer </H4><P>The interface that a specific dongle-type source code module exposes to the generic IrFramer (through the function pointer table in OEMDONGLE.C) can have three functions: </P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="144pt" VALIGN="TOP"><COL WIDTH="204pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B>Function </B></P></TD><TD VALIGN="TOP"><P><B>Description </B></P></TD></TR><TR><TD VALIGN="TOP"><P><B>type_Init</B> </P></TD><TD VALIGN="TOP"><P>Initializes your IR hardware and returns the capabilities mask. </P></TD></TR><TR><TD VALIGN="TOP"><P><B>type_SetSpeed</B> </P></TD><TD VALIGN="TOP"><P>Sets the send and receive speed of your IR hardware and sets VCOMM to handle that speed. </P></TD></TR><TR><TD VALIGN="TOP"><P><B>type_Deinit</B> </P></TD><TD VALIGN="TOP"><P>Powers down or deinitializes your IR hardware. </P></TD></TR></TBODY></TABLE>
<P><BR></P><P></P>
<H5><A NAME="sec4"></A>Using the Available Support Functions </H5><P>A number of functions are available to the OEMDONGL.C module. You have the option of using the VCOMM functions directly and/or indirectly through the functions listed below. It is strongly recommended that you not use the VCOMM functions directly for two-way communication with the dongle. Use the provided functions wherever applicable. The function prototypes are in _DONGLE.H and are shown below: </P>
<P><BR></P>
<PRE>//************************************************************************
//
// Function prototypes of utility functions that should be used by
// dongle functions.

// IrLapFrmSetSpeed will set the speed of the UART to the given speed
// using VCOMM calls.

BOOL IrLapFrmSetSpeed(U32 hCom, LM_BAUD_RATE speed);

// IrLapFrmReadChar is used to read a character from the UART using VCOMM calls
// It assumes that events are turned off so it polls. If no character is read in
// in 12 ms it will return FALSE. If a VCOMM error occurs it will return false.
// If it returns TRUE the character read is placed in the variable pointed to by
// c.

BOOL IrLapFrmReadChar(U32 hCom, PU8 c);

// IrLapFrmWriteChar is used to write a character to the UART using VCOMM calls.
// It returns TRUE if successful otherwise it returns FALSE.

BOOL IrLapFrmWriteChar(U32 hCom, U8 c);

// VMM_GetSystemTime returns the number of milliseconds since Windows started. It is
// accurate to 1ms. This is the standard VMM call.

UINT VMM_GetSystemTime( VOID );
</PRE>
<H5><A NAME="sec5"></A> Adapting the type_Init Function </H5><P>The <B>type_Init</B> function is called by the framer to initialize your IR hardware and to get the dongle capabilities masks. When <B>type_Init</B> is called, the <I>hCom</I> (VCOMM handle) will be set for 9600 baud, 8 data bits, no parity, and 1 stop bit. When <B>type_Init</B> returns, the dongle must be active and ready to receive and send data and the VCOMM handle must be set to 9600 baud, 8 data bits, no parity, and 1 stop bit. </P>
<P>If the dongle cannot be initialized <B>type_Init</B> must return IRDA_STATUS_FAILED. </P>
<P>The syntax of the function call is: </P>
<P><BR></P>
<PRE>BOOL type_Init(
                   U32 hCom, 
                   PDONGLE_CAPABILITIES cap
    )
</PRE>
<P><B>type_Init</B> assumes </P>
<UL><LI>     The <I>hCom</I> parameter identifies a port that has been opened and is set to 9600 baud, 8 data bits, no parity, and 1 stop bit. </LI><LI>     The framer has set no VCOMM event callbacks on the port so <B>type_Init</B> can send and receive characters without interference from the framer. </LI></UL><P></P>
<P>The <I>cap</I> parameter points to the <B>DONGLE_CAPABILITIES</B> structure that <B>type_Init</B> returns to the framer; <B>type_Init</B> can, as an option, set bits in the masks that make up this structure to register Baud Rate, Minimum Turn Around Time, and Number of BOFs capabilities with the framer. </P>
<P>The <B>DONGLE_CAPABILITIES</B> structure is defined in _DONGLE.H and is shown below: </P>
<P><BR></P>
<PRE>// DONGLE_CAPABILITIES - is a structure that contains the IrDA
    // capabilities a dongle can effect. The order of the elements in 
    // this structure must be the same as those in the IRLAPFRM_CAPABILITIES
    // structure.

    typedef struct
    {
      U32 supportedSpeeds;    // Supported speeds of the dongle
      U32 minTurnAroundTime;  // Min turn around time on the dongle
      U32 additionalBOFs;     // Additional BOFs required by the dongle.
    } DONGLE_CAPABILITIES, *PDONGLE_CAPABILITES;
</PRE>
<P>The meaning of the pattern of bit settings in the three capabilities bit masks is defined fully in <I>Infrared Data Association Serial Infrared Link Access Protocol</I> (<I>IrLAP</I>), but summary tables are presented here. </P>
<H5><A NAME="sec6"></A>Baud Rate </H5><P>The bit settings in the baud rate mask indicate the speed(s) at which the IR device can transmit over the data link: </P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="144pt" VALIGN="TOP"><COL WIDTH="204pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P> bit 0 = </P></TD><TD VALIGN="TOP"><P>2400 bps (LSB, transmitted first) </P></TD></TR><TR><TD VALIGN="TOP"><P> bit 1 = </P></TD><TD VALIGN="TOP"><P>9600 bps </P></TD></TR><TR><TD VALIGN="TOP"><P> bit 2 = </P></TD><TD VALIGN="TOP"><P>19200 bps </P></TD></TR><TR><TD VALIGN="TOP"><P> bit 3 = </P></TD><TD VALIGN="TOP"><P>38400 bps </P></TD></TR><TR><TD VALIGN="TOP"><P> bit 4 = </P></TD><TD VALIGN="TOP"><P>57600 bps </P></TD></TR><TR><TD VALIGN="TOP"><P> bit 5 = </P></TD><TD VALIGN="TOP"><P>115200 bps </P></TD></TR><TR><TD VALIGN="TOP"><P> bit 6 = </P></TD><TD VALIGN="TOP"><P>reserved and must be set to 0 </P></TD></TR><TR><TD VALIGN="TOP"><P> bit 7 = </P></TD><TD VALIGN="TOP"><P>reserved and must be set to 0 </P></TD></TR></TBODY></TABLE>
<P><BR></P><P></P>
<H5><A NAME="sec7"></A>Minimum Turn Around Time </H5><P>Minimum turn around time is the time delay required by the IR device from the time it receives the last byte from one device until it is ready to receive the first byte from another device. </P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="144pt" VALIGN="TOP"><COL WIDTH="204pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P> bit 0 = </P></TD><TD VALIGN="TOP"><P>10 ms (LSB, transmitted first) </P></TD></TR><TR><TD VALIGN="TOP"><P> bit 1 = </P></TD><TD VALIGN="TOP"><P>5 ms </P></TD></TR><TR><TD VALIGN="TOP"><P> bit 2 = </P></TD><TD VALIGN="TOP"><P>1 ms </P></TD></TR><TR><TD VALIGN="TOP"><P> bit 3 = </P></TD><TD VALIGN="TOP"><P>0.5 ms </P></TD></TR><TR><TD VALIGN="TOP"><P> bit 4 = </P></TD><TD VALIGN="TOP"><P>0.1 ms </P></TD></TR><TR><TD VALIGN="TOP"><P> bit 5 = </P></TD><TD VALIGN="TOP"><P> 0.05 ms </P></TD></TR><TR><TD VALIGN="TOP"><P> bit 6 = </P></TD><TD VALIGN="TOP"><P>0.01 ms </P></TD></TR><TR><TD VALIGN="TOP"><P> bit 7 = </P></TD><TD VALIGN="TOP"><P>0.005 ms </P></TD></TR></TBODY></TABLE>
<P><BR></P><P></P>
<H5><A NAME="sec8"></A>Number of BOFs </H5><P>These bit settings indicate the number of additional flags needed at the beginning of every frame to provide a delay at the beginning of each frame for devices with long interrupt latency. The bit settings in this mask depend on the baud rate. See <I>Infrared Data Association Serial Infrared Link Access Protocol</I> (<I>IrLAP</I>) for all the different possible values. </P>
<P>The following shows an example of adapting the OEMDONGLE.C sample source code function <B>OEM_Init</B>. The supportedSpeeds mask is set to support all speeds between 9600 baud and 115.2 baud and is set for a 1 ms turnaround, using the following code: </P>
<P><BR></P>
<PRE>#define  CRYSTAL_SPEEDMASK  0x3F     /*supported speeds 115.2Kbps-&gt;9600 Kbps*/
        #define  CRYSTAL_MINTURN    0x00     /*0 turn around*/
         .
         .
         .
    //*********************************************************************
    BOOL OEM_Init(U32 hCom, PDONGLE_CAPABILITIES cap)
    {
          .
          .
               .

        cap-&gt;supportedSpeeds &amp;= CRYSTAL_SPEEDMASK;
          .
               .
               .
    }
</PRE>
<P>Suppose your RED88 dongle only supports 9600, 19200, and 115200 baud. You can change the supportedSpeeds mask to reflect that by changing two lines of the sample code: </P>
<P><BR></P>
<PRE>    #define RED88_SPEEDMASK      0x00000026
        .
          .
               .

        cap-&gt;supportedSpeeds &amp;= RED88_SPEEDMASK;
          .
               .
               .</PRE>
<H5><A NAME="sec9"></A>Adapting the type_SetSpeed Function </H5><P>The <B>type_SetSpeed</B> function is called by the framer <B>IRLAPFRM_SetSpeed</B> function to set the send and receive speed of your IR hardware. <B>type_SetSpeed</B> must also set VCOMM to handle the new speed because <B>IRLAPFRM_SetSpeed</B> does not do that. </P>
<P>The syntax of the <B>type_SetSpeed</B> function call is: </P>
<P><BR></P>
<PRE>BOOL type_SetSpeed(
                      U32 hCom, 
                      LM_BAUD_RATE speed
   )
</PRE>
<P><B>type_SetSpeed</B> can send and receive characters with no interference from the IR framer because <B>IRLAPFRM_SetSpeed</B> disables VCOMM event callbacks before it calls <B>type_SetSpeed</B>. </P>
<P><B>type_SetSpeed</B> can also assume that the framer will not reset the VCOMM speed setting. Therefore, when <B>type_SetSpeed</B> is called, the VCOMM speed setting is either the same as the last time <B>type_SetSpeed</B> set it, or 9600 baud immediately after a call to <B>type_Init</B>. </P>
<P>When <B>type_SetSpeed</B> returns, the framer assumes it can start sending or receiving data at the new speed and restores the VCOMM event callbacks. If it fails to set the IR device speed or the VCOMM speed setting, <B>type_SetSpeed</B> must return IRDA_STATUS_FAILED. </P>
<P>It is not particularly useful to make up an example here for the hypothetical RED88 dongle device. The convention that notifies each particular dongle device of a speed change differs from device to device. Two things to notice about the sample code, however, are: </P>
<UL><LI>     The <B>IrLapFrmSetSpeed</B> function in OEMDONGLE.C can be called from your <B>type_SetSpeed</B> function to set the UART to a new speed. </LI><LI>     <B>VCOMM_EscapeCommFunction</B> is used to set the dongle hardware into and out of command mode (see the <B>ACT200LSetCommandMode</B> and <B>ACT200LClearCommandMode</B> functions in OEMDONGL.C). Using the VCOMM functions is quite acceptable in this case. </LI></UL><P></P>
<H5><A NAME="sec10"></A>Adapting the type_Deinit Function </H5><P>The <B>type_Deinit</B> function is called to power down or otherwise deactivate your hardware. It is called by the framer just before it calls <B>VCOMM_CloseComm</B> to close the port. </P>
<P>The <B>type_Deinit</B> function can send and receive characters with no interference from the IR framer because VCOMM event callbacks are disabled before the call to the dongle function. </P>
<P>The syntax of the <B>type_Deinit</B> function call is: </P>
<P><BR></P>
<PRE>BOOL type_Deinit(
                      U32 hCom
     )
</PRE>
<P>The <B>OEM_Deinit</B> function in OEMDONGL.C (which uses the Crystal chip in the ACTiSYS 200L as an IR device) does the following: </P>
<UL><LI>     Resets the IR device. </LI><LI>     Sets the speed to 9600 baud (the discovery speed). </LI><LI>     Puts the IR chip in low-power mode. </LI><LI>     Make sure the IR device is not in command mode. </LI></UL><P></P></FONT></BODY></HTML>
