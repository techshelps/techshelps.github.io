<HTML><HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Hook_VMM_Fault</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">
<FONT FACE="verdana,arial,helvetica" SIZE="2">
<H3>Hook_VMM_Fault </H3><P><BR></P>
<PRE>include vmm.inc

mov     eax, FaultNo            ; fault number
mov     esi, OFFSET32 FaultProc ; points to a fault handler
VMMcall Hook_VMM_Fault

jc      not_installed           ; carry flag set if not installed
; The following line is optional. See the following comments section.
mov     [Previous], esi         ; points to previous fault handler (if any)
</PRE>
<P>Installs a fault handler procedure for faults encountered by VMM or other virtual devices. Virtual devices typically install fault handlers while processing the <B>Sys_Critical_Init</B> control message to handle faults, such as general protection faults, that the VMM fault handlers cannot handle. The VMM installs its fault handlers after the <B>Sys_Critical_Init</B> control message. Virtual devices install fault handlers after <B>Sys_Critical_Init</B> to handle faults before the fault is passed to the VMM fault handlers. Uses ESI, Flags. </P>
<UL><LI>     Returns with the carry flag clear if successful, set otherwise. If the carry flag is clear, and if FaultProc is a hook procedure, the address of the previous handler is stored into the hook variable. If there was no previous handler, the address of the default handler is stored into the hook variable. Regardless of whether FaultProc is a hook procedure, the ESI register contains the address of the previous fault handler (zero if there was no previous handler). The return value in ESI exists solely for backwards compatibility with Windows 3.1. </LI></UL><P></P>
<P><I>FaultNo</I> </P>
<P>Fault number for which to install the fault handler. The fault number cannot be 02h, and must not be greater than 4Fh. </P>
<P><I>FaultProc</I> </P>
<P>Address of the fault handler to install. For more information about the handler, see below. </P>
<P>A virtual device can install a fault handler while processing the <B>Sys_Critical_Init</B> message, or at a later time. When a fault occurs, fault handlers installed after the <B>Sys_Critical_Init</B> message receive control first, the VMM fault handlers receive control next, and fault handlers installed during the <B>Sys_Critical_Init</B> message receive control last. (Of course, dynamically-loaded VxDs have no choice but to install the fault handler after <B>Sys_Critical_Init</B>, since they haven't yet been loaded at the time the <B>Sys_Critical_Init</B> message is broadcast.) </P>
<P>The system disables interrupts and calls the fault handler as follows: </P>
<P><BR></P>
<PRE>mov     ebx, VM                 ; current VM handle
mov     ebp, OFFSET32 stkfrm    ; points to VMM re-entrant stack frame
call    [FaultProc]
</PRE>
<P>The <I>VM</I> parameter is a handle identifying the current virtual machine, and the <I>stkfrm</I> parameter points to the VMM re-entrant fault stack frame. </P>
<P>The EBP register does <I>not</I> point to a client register structure. </P>
<P>The fault handler may call asynchronous services only. </P>
<P>If the fault handler does not process the fault, it should pass the fault to the previous fault handler (if any), making sure that <I>all</I> registers are preserved (not just the registers containing input parameters). </P>
<P>If the fault handler processes the fault or if there is no previous fault handler, the handler should return without chaining by executing a near <B>ret</B> instruction (not an <B>iret</B> instruction). </P>
<P>The fault handler can modify the EAX, EBX, ECX, EDX, ESI, and EDI registers. </P>
<P>Do not use this service to install a fault handler for the Non-Maskable Interrupt (NMI). Instead, a virtual device must use the <B>Get_NMI_Handler_Addr</B> and <B>Set_NMI_Handler_Addr</B> services. </P>
<P>Do not use this service to install handlers for hardware interrupts. Instead, a virtual device must use virtual PIC device services. </P>
<P>See also <B>Hook_PM_Fault</B>, <B>Hook_V86_Fault</B> </P>
<P></P>
<P></P></FONT></BODY></HTML>
