<HTML><HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DCB</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">
<FONT FACE="verdana,arial,helvetica" SIZE="2">
<H3>DCB </H3><P><BR></P>
<PRE>#include &lt;dcb.h&gt;

typedef struct  _DCB { 
    DCB_COMMON  DCB_cmn;              // common information
    ULONG  DCB_max_xfer_len;          // maximum transfer length 

// Actual geometry data (as seen below the TSD)
    ULONG  DCB_actual_sector_cnt[2];  // number of sectors 
    ULONG  DCB_actual_blk_size;       // actual block size of the device  
    ULONG  DCB_actual_head_cnt;       // number of heads
    ULONG  DCB_actual_cyl_cnt;        // number of cylinders
    ULONG  DCB_actual_spt;            // number of sectors per track

    PVOID  DCB_next_ddb_dcb;          // link to next DCB on DDB chain 
    PVOID  DCB_dev_node;              // address of dev node for device 
    BYTE   DCB_bus_type;              // Bus type; see below
    BYTE   DCB_bus_number;            // channel (cable) within adapter   
    UCHAR  DCB_queue_freeze;          // queue freeze depth counter 
    UCHAR  DCB_max_sg_elements;       // max # s/g elements; see below

// Volume tracking layer use only
    UCHAR  DCB_io_pend_count;         // # of pending requests for DCB
    UCHAR  DCB_lock_count;            // # of LOCK MEDIA commands 

// SCSI
    USHORT DCB_SCSI_VSD_FLAGS;        // Flags for SRB builder
    BYTE   DCB_scsi_target_id;        // SCSI target ID 
    BYTE   DCB_scsi_lun;              // SCSI logical unit number      
    BYTE   DCB_scsi_hba;              // prot-driver-relative adapter #
    BYTE   DCB_max_sense_data_len;    // Maximum sense length
    USHORT DCB_srb_ext_size;          // miniport srb extension length

    BYTE   DCB_inquiry_flags[8];      // Device inquiry flags
    BYTE   DCB_vendor_id[8];          // Vendor ID string
    BYTE   DCB_product_id[16];        // Product ID string
    BYTE   DCB_rev_level[4];          // Product revision level
    BYTE   DCB_port_name[8];          // 
    UCHAR  DCB_current_unit;          // current unit #; see below

// Volume tracking layer use only
    ULONG  DCB_blocked_iop;           // address of requests for an 
                                      //  inactive volume 

    ULONG  DCB_vol_unlock_timer;      // unlock timer handle 
    UCHAR  DCB_access_timer;          // time measure between accesses 

// Volume tracking layer use only
    UCHAR  DCB_Vol_Flags;             // Volume tracking; see below

    BYTE  DCB_q_algo;                 // algorithm index; see below
    BYTE  DCB_unit_on_ctl;            // 0-based device number on ctlr
    ULONG  DCB_Port_Specific;         // bytes for port driver use
    ULONG  DCB_spindown_timer;        // timer for drive spin down

    DCB_BLOCKDEV  DCB_bdd;
} DCB, *PDCB;
</PRE>
<P>Contains device control block information for physical devices. </P>
<P><B>DCB_bus_type</B> </P>
<P>Bus type. Can be one of these values: </P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="144pt" VALIGN="TOP"><COL WIDTH="190pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>DCB_BUS_ESDI </P></TD><TD VALIGN="TOP"><P>ESDI BUS </P></TD></TR><TR><TD VALIGN="TOP"><P>DCB_BUS_SCSI </P></TD><TD VALIGN="TOP"><P>SCSI BUS </P></TD></TR><TR><TD VALIGN="TOP"><P>DCB_BUS_NEC </P></TD><TD VALIGN="TOP"><P>NEC BUS </P></TD></TR><TR><TD VALIGN="TOP"><P>DCB_BUS_SMART </P></TD><TD VALIGN="TOP"><P>SMART BUS </P></TD></TR><TR><TD VALIGN="TOP"><P>DCB_BUS_ABIOS </P></TD><TD VALIGN="TOP"><P>ABIOS BUS </P></TD></TR></TBODY></TABLE>
<P><BR></P><P></P>
<P><B>DCB_max_sg_elements</B> </P>
<P>Maximum number of scatter/gather elements. This value is set initially by the port driver, but may be more restrictively updated by other layer drivers. </P>
<P><B>DCB_current_unit</B> </P>
<P>Used to emulate multiple logical devices with a single physical device. </P>
<P><B>DCB_vol_flags</B> </P>
<P>Volume tracking flags. Can be one of these values: </P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="144pt" VALIGN="TOP"><COL WIDTH="190pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>DCB_VF_INHIBIT_LOCKING </P></TD><TD VALIGN="TOP"><P>Indicates locking is temporarily inhibited </P></TD></TR><TR><TD VALIGN="TOP"><P>DCB_VF_INHIBIT_IO </P></TD><TD VALIGN="TOP"><P>Indicates i/o is temporarily inhibited (event scheduled in volume tracker). </P></TD></TR><TR><TD VALIGN="TOP"><P>DCB_VF_INHIBIT_GEOM_RECOMPUTE </P></TD><TD VALIGN="TOP"><P>Indicates geometry recompute is temporarily inhibited. </P></TD></TR><TR><TD VALIGN="TOP"><P>DCB_VF_UNLOCK_SCHED </P></TD><TD VALIGN="TOP"><P>Indicates unlock event is scheduled. </P></TD></TR><TR><TD VALIGN="TOP"><P>DCB_VF_NEED_PHYS_RECOMP </P></TD><TD VALIGN="TOP"><P>Indicates that a mapper drive needs a compute geometry request sent to the physical drive with same number as the given logical drive. </P></TD></TR><TR><TD VALIGN="TOP"><P>DCB_VF_PROT_NEC_DRIVE </P></TD><TD VALIGN="TOP"><P>Indicates that this DCB has a corresponding protected mode physical NEC driver. </P></TD></TR></TBODY></TABLE>
<P><BR></P><P></P>
<P><B>DCB_q_algo</B> </P>
<P>Queuing algorithm index. Can be one of these values: </P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="144pt" VALIGN="TOP"><COL WIDTH="190pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>DCB_q_fi_fo </P></TD><TD VALIGN="TOP"><P>First in, first out. </P></TD></TR><TR><TD VALIGN="TOP"><P>DCB_q_sort </P></TD><TD VALIGN="TOP"><P>Special algorithm for disk. </P></TD></TR></TBODY></TABLE>
<P><BR></P><P></P>
<P>See also <B>DCB_COMMON</B>, <B>DCB_BLOCKDEV</B> </P>
<P></P>
<P></P></FONT></BODY></HTML>
