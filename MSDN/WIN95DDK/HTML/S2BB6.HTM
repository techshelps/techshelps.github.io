<HTML><HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Adding New MCI Commands</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">
<FONT FACE="verdana,arial,helvetica" SIZE="2">
<H3>Adding New MCI Commands </H3><P>This section applies to your driver only if you need to add new MCI commands or provide extensions to the MCI command set. Do the following to add or extend a command set: </P>
<P>    1    Define the new MCI messages you plan to support with your driver. </P>
<P>    2    Define new structures and flags for this command to use with <B>mciSendCommand</B>. </P>
<P>MCI messages use <I>lParam2</I> as a pointer to a structure, and use <I>lParam1</I> as a bitmember for the flags associated with the message. A flag exists for each member in the structure that accepts data from the calling application. The application sets the flag in the bitmember of <I>lParam1</I> to indicate a value is assigned to a particular member. Flags also specify options without parameters and these flags do not correspond to a member in the structure. </P>
<P>    3    Create a command table that MCI will use to translate string commands sent through <B>mciSendString</B> into the command messages and structures used by your driver. </P>
<P>    4    Support the new messages in your driver's <B>DriverProc</B>. </P>
<P>    5    Register the new command table with MCI in your driver's DRV_LOAD procedure. </P>
<P></P>
<H4><A NAME="sec0"></A>Define the New Messages for Your Driver </H4><P>Suppose you are writing a driver for a videodisc player and this player supports a new command, "reset." This command is invoked by the string "reset program_number." The command sets all player parameters to their default settings or one of several predefined states indicated by the program_number. </P>
<P>You would add the following message to the list of messages you must support in <B>DriverProc</B>: </P>
<P><BR></P>
<PRE>#define    MCI_VDISC_RESET    1000
</PRE>
<P>MCI_USER_MESSAGES is the first integer you can use for custom messages. Since the resource compiler does not accept mathematical expressions in the RCDATA resource type, you must indicate the specific value you want to use. </P>
<P>Now that you have defined the message ID, you must define the structure and the command table, and create the code to handle this message in <B>DriverProc</B>. </P>
<H4><A NAME="sec1"></A>Defining the Structure </H4><P>The members of the structure for an MCI message are always 32 bits long - the size of doubleword values. The number of members in the structure depends on the particular message. The first member must be reserved for a handle to a window function used with the MCI_NOTIFY flag. The next members in the structure depend on the type of data returned for the message: </P>
<UL><LI>     If no data is returned, no return members are reserved in the structure. Any data members for passing information to the device driver immediately follow the <B>dwCallback</B> member. </LI><LI>     If integer data is returned, the second member of the structure is reserved for the return data. Any data members for passing information to the device driver start in the third member. </LI><LI>     If string data is returned, the second and third members of the structure are reserved for the return data. The second <B>DWORD</B> is assigned to a member reserved for a pointer to the zero-terminated return string. The third <B>DWORD</B> is assigned to a member reserved for the size of return buffer. The application is responsible for creating the buffer for return string. Any data members for passing information to the device driver start in the fourth member. </LI><LI>     If <B>RECT</B> data is returned, the second and third members of the structure are reserved for the return data. The first <B>DWORD</B> position is reserved for the top-left values of the <B>RECT</B> data. The second <B>DWORD</B> position is reserved for the bottom-right values of the <B>RECT</B> data. Any data members for passing information to the device driver start in the fourth <B>DWORD</B> position. Rather than specifying two <B>DWORD</B>s for the <B>RECT</B> data, most structure definitions use one <B>RECT</B> data member to obtain an equivalent structure. </LI></UL><P></P>
<H4><A NAME="sec2"></A>Assigning Flag Values </H4><P>In addition to indicating the members used in a structure, flags can indicate an option that does not use any parameters. For example, the wait flag does not use any parameters. </P>
<P>When you add new flags, you must ensure they do not conflict with the flags already used. Bits 0 through 15 of the 32-bit <B>DWORD</B> are reserved for MCI. Bit 16 (0x00010000) is the first bit that a driver can use for its flags. If your command is a new command, you can start with this bit position. If your command extends a command, you must choose bit positions that do not conflict with the flags already defined for that command. Any unused bits in the new flag must be set to zero. For example, if a new command for videodisc players uses flags 16 through 20, a custom extension to the new command could use flags 21 through 31. </P>
<P>To continue the example for adding a "reset" command to a videodisc driver, the following code fragment defines a structure, a corresponding pointer for it, and the flag corresponding to the program member of the structure: </P>
<P><BR></P>
<PRE>typedef struct {
    DWORD    dwCallback;
    DWORD    dwProgram;
} MCI_VDISC_RESET_PARMS;

typedef      MCI_VDISC_RESET_PARMS FAR * LPMCI_VDISC_RESET_PARMS;

#define      MCI_VDISC_RESET_PROGRAM        0x00010000L
</PRE>
<P>When the application sets the MCI_VDISC_RESET_PROGRAM flag in <I>lParam1</I>, it indicates that a value is assigned in the <B>dwProgram</B> member. </P>
<P>Now that you have created the message command, flags and structure, you need to create the command table that tells MCI how to translate the equivalent string command into the message command form. Creating the command table is explained in the following section. </P>
<H4><A NAME="sec3"></A>Creating the MCI Command Tables </H4><P>The MCI parser used by <B>mciSendString</B> uses the command tables to tell it how to translate an MCI command string into parameters used by <B>DriverProc</B>. Most of these tables are stored as resources within the device driver. The resource type is RCDATA. </P>
<P>To allow applications to use <B>mciSendString</B> with any new or extended commands that your driver supports, you must create a command table to indicate how to map the string commands to the message commands. </P>
<H5><A NAME="sec4"></A>Contents of the Command Table </H5><P>A command table consists of three columns: </P>
<UL><LI>     The first column contains the commands and flags used in the string form of the command. Each entry in the first column must be terminated with \0 to form a zero-terminated string. </LI><LI>     The second column is a <B>DWORD</B> and contains the commands and flags used in the message form of the command. </LI><LI>     The third column is a <B>WORD</B> and contains the identifiers that tell the MCI parser how to interpret each entry. </LI></UL><P></P>
<P>The following example shows a partial command table: </P>
<P><BR></P>
<PRE>/*************************************************************/
/*   Sample command table for the MCI core command set       */
/*************************************************************/
core RCDATA
BEGIN
"open\0",              MCI_OPEN, 0,                  MCI_COMMAND_HEAD,
"\0",                MCI_INTEGER, 0,                 MCI_RETURN,
"notify\0",          MCI_NOTIFY,                     MCI_FLAG,
"wait\0",            MCI_WAIT,                       MCI_FLAG,
"test\0",            MCI_TEST,                       MCI_FLAG,
"type\0",            MCI_OPEN_TYPE,                  MCI_STRING,
"element\0",         MCI_OPEN_ELEMENT,               MCI_STRING,
"alias\0",           MCI_OPEN_ALIAS,                 MCI_STRING,
"shareable\0",       MCI_OPEN_SHAREABLE,             MCI_FLAG,
"\0",                0L,                             MCI_END_COMMAND,

"close\0",             MCI_CLOSE, 0,                 MCI_COMMAND_HEAD,
"notify\0",          MCI_NOTIFY,                     MCI_FLAG,
"wait\0",            MCI_WAIT,                       MCI_FLAG ,
"test\0",            MCI_TEST,                       MCI_FLAG,
"\0",                0L,                             MCI_END_COMMAND,


"play\0",              MCI_PLAY, 0,                  MCI_COMMAND_HEAD,
"notify\0",          MCI_NOTIFY,                     MCI_FLAG,
"wait\0",            MCI_WAIT,                       MCI_FLAG ,
"test\0",            MCI_TEST,                       MCI_FLAG,
"from\0",            MCI_FROM,                       MCI_INTEGER,
"to\0",              MCI_TO,                         MCI_INTEGER,
"\0",                0L,                             MCI_END_COMMAND, 
                     .
                     .
                     .
"capability\0",        MCI_GETDEVCAPS, 0,            MCI_COMMAND_HEAD,
"\0",                MCI_INTEGER, 0,                 MCI_RETURN,
"notify\0",          MCI_NOTIFY,                     MCI_FLAG,
"wait\0",            MCI_WAIT,                       MCI_FLAG ,
"test\0",            MCI_TEST,                       MCI_FLAG,
"\0",                MCI_GETDEVCAPS_ITEM,            MCI_CONSTANT
"can record\0",      MCI_GETDEVCAPS_CAN_RECORD,      MCI_INTEGER,
"has audio\0",       MCI_GETDEVCAPS_HAS_AUDIO,       MCI_INTEGER,
"has video\0",       MCI_GETDEVCAPS_HAS_VIDEO,       MCI_INTEGER,
"uses files\0",      MCI_GETDEVCAPS_USES_FILES,      MCI_INTEGER,
"compound device\0", MCI_GETDEVCAPS_COMPOUND_DEVICE, MCI_INTEGER,
"device type\0",     MCI_GETDEVCAPS_DEVICE_TYPE,     MCI_INTEGER,
"can eject\0",       MCI_GETDEVCAPS_CAN_EJECT,       MCI_INTEGER,
"can play\0",        MCI_GETDEVCAPS_CAN_PLAY,        MCI_INTEGER,
"can save\0",        MCI_GETDEVCAPS_CAN_SAVE,        MCI_INTEGER,
"\0",                0L,                             MCI_END_CONSTANT,
"\0",                0L,                             MCI_END_COMMAND,
"resume\0",          MCI_RESUME, 0,                  MCI_COMMAND_HEAD,
"notify\0",          MCI_NOTIFY,                     MCI_FLAG,
"wait\0",            MCI_WAIT,                       MCI_FLAG, 
"\0",                0L,                             MCI_END_COMMAND,
"\0",                0L,                             MCI_END_COMMAND_LIST

END
</PRE>
<P>When you build your command table, ensure that the entries in the second column are <B>DWORD</B>s, and the entries in the third columns are <B>WORD</B>s. If you use any <B>WORD</B>s in the second columns, pad them with a comma and a zero. For example, the MCI_PLAY message in the example is followed by a comma and a zero. The zero is used as a filler to keep the command list properly aligned. Forgetting the zero after a <B>WORD</B> causes the remainder of the command table to be misaligned by one <B>WORD</B>. </P>
<P>A command table consists of command lists. A command list defines how to parse a particular command. For example, the following is a command list for the play command: </P>
<P><BR></P>
<PRE>"play\0",            MCI_PLAY, 0,                    MCI_COMMAND_HEAD,
"notify\0",          MCI_NOTIFY,                     MCI_FLAG,
"wait\0",            MCI_WAIT,                       MCI_FLAG ,
"test\0",            MCI_TEST,                       MCI_FLAG,
"from\0",            MCI_FROM,                       MCI_INTEGER,
"to\0",              MCI_TO,                         MCI_INTEGER,
"\0",                0L,                             MCI_END_COMMAND,
</PRE>
<P>This command list tells the parser which flags are valid and how to create the associated structure for the message command. </P>
<H5><A NAME="sec5"></A>Command List and Command Table Delimiters </H5><P>The first entry in a command list must have the MCI_COMMAND_HEAD delimiter in the third column. The MCI_COMMAND_HEAD delimiter designates the verb portion of the string command. For example, the play command list starts with this entry: </P>
<P><BR></P>
<PRE>"play\0",            MCI_PLAY, 0,                    MCI_COMMAND_HEAD,
</PRE>
<P>The last entry in a command list must have the MCI_END_COMMAND delimiter. For this last entry, the first and second columns contain "\0" and 0L. For example, all command lists end with this entry: </P>
<P><BR></P>
<PRE>"\0",                0L,                             MCI_END_COMMAND,
</PRE>
<P>The last entry of the command table must have the MCI_END_COMMAND_LIST delimiter. The first and second columns for this entry also contain "\0" and 0L. For example, the example command table ends with this entry: </P>
<P><BR></P>
<PRE>"\0",                0L,                            MCI_END_COMMAND_LIST
</PRE>
<H5><A NAME="sec6"></A>Return Values </H5><P>If your want to return data in your structure, you can reserve a member by having an entry in the command list with the MCI_RETURN in the third column. If you use MCI_RETURN, you must use it for the entry immediately following the MCI_COMMAND_HEAD. You can use MCI_RETURN only once in a command list. For example, the MCI_GETDEVCAPS command list starts with the following entries: </P>
<P><BR></P>
<PRE>"capability\0",      MCI_GETDEVCAPS, 0,              MCI_COMMAND_HEAD,
"\0",                MCI_INTEGER, 0,                 MCI_RETURN,
</PRE>
<P>The string in the first column of an entry with MCI_RETURN is "\0". (This column is ignored when you use MCI_RETURN.) </P>
<P>The second column of the MCI_RETURN entry specifies the type of data returned. The parser recognizes the MCI_INTEGER, MCI_STRING, and MCI_RECT keywords for the data type returned. </P>
<P>If you want to return an integer value, use MCI_INTEGER,0 in the second column. For integers, MCI reserves the second <B>DWORD</B> in the structure for the return value. </P>
<P>If you want to return a string value, use MCI_STRING,0 in the second column. For strings, MCI reserves the second and third <B>DWORD</B>s in the structure for the return value. These <B>DWORD</B>s correspond to a pointer to a buffer for the zero-terminated return string and the size of the buffer supplied by the application. </P>
<P>If you want to return a <B>RECT</B> value, use MCI_RECT,0 in the second column. For rectangles, MCI reserves the second and third <B>DWORD</B>s in the structure for the return value. </P>
<P>The following example adds an integer return value to the reset command: </P>
<P><BR></P>
<PRE>"reset\0",           MCI_VDISC_RESET, 0,             MCI_COMMAND_HEAD,
"\0",                MCI_INTEGER, 0,                 MCI_RETURN,   
"notify\0",          MCI_NOTIFY,                     MCI_FLAG,
"wait\0",            MCI_WAIT,                       MCI_FLAG,
"test\0",            MCI_TEST,                       MCI_FLAG,
"program\0",         MCI_VDISC_RESET_PROGRAM,        MCI_INTEGER,
"\0",                0L,                             MCI_END_COMMAND
</PRE>
<P>The corresponding structure for the reset command using a return value is as follows: </P>
<P><BR></P>
<PRE>typedef struct {
   DWORD   dwCallback;
   DWORD   dwReturn
   DWORD   dwProgram;
} MCI_VDISC_RESET_PARMS;
</PRE>
<H5><A NAME="sec7"></A>Command Flag Keywords </H5><P>MCI interprets an entry with MCI_FLAG in the third column as a flag that is not associated with any member of the structure. For example, all commands have the following entry for the MCI_NOTIFY flag: </P>
<P><BR></P>
<PRE>"notify\0",          MCI_NOTIFY,                     MCI_FLAG
</PRE>
<P>The first column of this entry contain the string command used for the flag. The second column contains the value used for the flag. </P>
<H5><A NAME="sec8"></A>Associating Command List Entries to Structures </H5><P>MCI associates a command list entry with a structure member when the command list entry has MCI_INTEGER, MCI_STRING, or MCI_RECT in the third column. The order of the entries in the command list implies the order of the members in a structure. That is, the command list does not explicitly name the members of a structure. </P>
<P>When assigning members, MCI reserves the first member in the structure for the handle to a callback function. Thus, MCI uses the second member of the structure for data associated with the first entry needing space in the structure. MCI then assigns the third data member to the second entry needing it. This continues for the rest of the list. This association assumes that all the data members in the structure are <B>DWORD</B>S. You can intersperse entries that are not modified with values with those that are. For example, a command designated as an MCI_FLAG will not be associated with a member in a structure. Instead, it will designate a bit flag used in <I>lParam1</I>. If the MCI_FLAG entry separates two entries designated MCI_INTEGER, it would not affect the structure member assignment. </P>
<P>For example, the "reset" videodisc player command example would have the following form: </P>
<P><BR></P>
<PRE>"reset\0",           MCI_VDISC_RESET, 0,             MCI_COMMAND_HEAD,
"notify\0",          MCI_NOTIFY,                     MCI_FLAG,
"wait\0",            MCI_WAIT,                       MCI_FLAG,
"test\0",            MCI_TEST,                       MCI_FLAG,
"program\0",         MCI_VDISC_RESET_PROGRAM,        MCI_INTEGER,
"\0",                0L,                             MCI_END_COMMAND
</PRE>
<P>If you specify "\0" in the first column, it designates that entry a default entry. Any flags entered as part of a string command that does not match any entry in the command list will assume the default value. Only one default value can exist in each command list. </P>
<H5><A NAME="sec9"></A>Using Constants </H5><P>MCI uses the MCI_CONSTANT and MCI_END_CONSTANT keywords to associate a range of constants to a flag. The MCI_CONSTANT keyword reserves a <B>DWORD</B> in the associated structure and delimits the start of a list of constants. The following entries contain the constants. Each constant entry has the MCI_INTEGER keyword in the third column. The list of constants is ended with an entry with the MCI_END_CONSTANT keyword. For example, the <B>set</B> command has the following entries for the audio channel constants: </P>
<P><BR></P>
<PRE>"audio\0",           MCI_SET_AUDIO,                  MCI_CONSTANT,
"all\0",             MCI_SET_AUDIO_ALL,              MCI_INTEGER,
"left\0",            MCI_SET_AUDIO_LEFT,             MCI_INTEGER,
"right\0",           MCI_SET_AUDIO_RIGHT,            MCI_INTEGER,
"\0",                0L,                             MCI_END_CONSTANT,
</PRE>
<P>The constant list is actually defining a list of pre-defined integers that can be used in a string command. These pre-defined integers will be passed to your device driver in the member reserved for the flag in the structure. If the parser finds an integer following a flag rather than one of flag's pre-defined constants, the parser will assign the integer to the structure member. This lets your device driver use both constants and integers as data for a flag. </P>
<H5><A NAME="sec10"></A>The Types of Entries </H5><P>The following table summarizes the keywords used to identify the type of entry in the command table: </P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="144pt" VALIGN="TOP"><COL WIDTH="204pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B>Keyword </B></P></TD><TD VALIGN="TOP"><P><B>Description </B></P></TD></TR><TR><TD VALIGN="TOP"><P>MCI_COMMAND_HEAD </P></TD><TD VALIGN="TOP"><P>Indicates the zero-terminated string in the first column corresponds to the verb portion of the string command. The <B>DWORD</B> following the command corresponds to the message command passed to <B>DriverProc</B> as <I>uMsg</I>. This entry must be the first entry in the command list and it must be unique to the table. </P></TD></TR><TR><TD VALIGN="TOP"><P>MCI_CONSTANT </P></TD><TD VALIGN="TOP"><P>Indicates an MCI flag validating constant data. The second column contains the flag name. The structure must reserve a <B>DWORD</B> to hold the integer values representing the constants. A list of constants defined for the integer data immediately follows this entry. </P></TD></TR><TR><TD VALIGN="TOP"><P>MCI_END_COMMAND </P></TD><TD VALIGN="TOP"><P>Indicates the end of a command list. The first and second columns for this entry must contain "\0" and 0L. </P></TD></TR><TR><TD VALIGN="TOP"><P>MCI_END_COMMAND_LIST </P></TD><TD VALIGN="TOP"><P>Indicates the end of the command table. The first and second columns for this entry must contain "\0" and 0L. </P></TD></TR><TR><TD VALIGN="TOP"><P>MCI_END_CONSTANT </P></TD><TD VALIGN="TOP"><P>Indicates the end of a list of constants. The first and second columns for this entry must contain "\0" and 0L. </P></TD></TR><TR><TD VALIGN="TOP"><P>MCI_FLAG </P></TD><TD VALIGN="TOP"><P>Indicates an MCI flag that does not validate data. The second column contains the flag name. </P></TD></TR><TR><TD VALIGN="TOP"><P>MCI_INTEGER </P></TD><TD VALIGN="TOP"><P>Indicates an MCI flag validating integer data. The second column contains the flag name. The structure must reserve a <B>DWORD</B> to hold the integer value. </P></TD></TR><TR><TD VALIGN="TOP"><P>MCI_RECT </P></TD><TD VALIGN="TOP"><P>Indicates an MCI flag validating <B>RECT</B> data. The second column contains the flag name. The structure must reserve two <B>DWORD</B>s to hold the <B>RECT</B> value. </P></TD></TR><TR><TD VALIGN="TOP"><P>MCI_RETURN </P></TD><TD VALIGN="TOP"><P>Indicates a structure associated with a command has data members reserved for return information. If used, the data entry must be the second entry in the command list. The first column of the entry contains "\0". The second column contains the type of return value. If MCI_INTEGER is specified as the return type, the second <B>DWORD</B> in the structure is reserved for an integer return value. If MCI_STRING is specified, the second <B>DWORD</B> is reserved for a pointer to the return string. The third <B>DWORD</B> is reserved for the length of the string. If MCI_RECT is specified, the second and third <B>DWORD</B>s are reserved for the <B>RECT</B> data. </P></TD></TR><TR><TD VALIGN="TOP"><P>MCI_STRING </P></TD><TD VALIGN="TOP"><P>Indicates an MCI flag validating string data. The second column contains the flag name. The structure must reserve a <B>DWORD</B> to hold a pointer to the string data. </P></TD></TR></TBODY></TABLE>
<P><BR></P><P></P>
<H5><A NAME="sec11"></A>How the Parser Uses the Command Tables </H5><P>The following description tells how the MCI parser uses the command table entries to interpret the command string "play videodisc1 notify from 10 to 20." The MCI parser reads the string to obtain the command and its destination device. The parser uses the destination to determine the device ID and assigns it to <I>dwDeviceID</I> of <B>DriverProc</B>. The parser also uses this information to determine which command table to search. </P>
<P>When the parser searches the command tables for "play," it searches the command tables in this order: the device-specific table (your custom command table), then the device-type table (such as the cdaudio command table), and finally the core command table. </P>
<P>When searching the command table, the parser searches the tables for the MCI_COMMAND_HEAD keyword. When found, the parser compares the command listed in the first column with the command from the input string. If the two commands match, the parser uses the <B>DWORD</B> in the second column (in this case MCI_PLAY) as the <I>uMsg</I> parameter for <B>DriverProc</B>. </P>
<P>The parser tries to match each subsequent parameter in the command string with a corresponding entry in the current command list. For the example, the next parameter is "notify." If the parser does not find this, it reports an error. If the parser does find it, it looks in the third column and finds MCI_FLAG. This tells the parser to use the bitwise or operation to add the second column flag MCI_NOTIFY with the bitmember for the <I>lParam1</I> parameter. </P>
<P>If the example command contained "wait" rather than notify, the parser would behave the same as for the "notify" example except that it would combine MCI_WAIT with the bitmember for the <I>lParam1</I> parameter. </P>
<P>When the parser interprets the "from" parameter, the MCI_INTEGER keyword indicates that additional data is available from the command string. The parser obtains the string value, converts it to an integer, and stores it in the <B>DWORD</B> of the structure corresponding to the MCI_FROM flag. The parser also combines the MCI_FROM flag in the bitmember for the <I>lParam1</I> parameter. </P>
<P>The parser processes the "to" parameter exactly as the "from" parameter except that the integer modifier is stored in <B>DWORD</B> of the structure corresponding to the MCI_TO flag. </P>
<P>The parser knows it has finished translating a command when it has reached the end of the input command string. The parser can now call <B>DriverProc</B> with the proper parameters. </P>
<P>Because the parser maps the string commands to message commands and structures passed to the driver, the order of the flags in a command string is irrelevant. The command string "play videodisc1 to 20 from 10 notify" maps exactly to the same command derived from "play videodisc1 notify from 10 to 20". </P>
<P>The parser checks only for syntax errors. It does not check the input string for invalid combinations of flags. Before handling any MCI command, your device driver should determine if there are invalid combinations of flags. </P>
<H4><A NAME="sec12"></A>Providing Support for New Messages in DriverProc </H4><P>When you have finished your command table, you must prepare <B>DriverProc</B> to handle the messages you have created. The procedures for this are the same as preparing it for existing messages. </P>
<H4><A NAME="sec13"></A>Registering the Command Tables with MCI </H4><P>The final checklist item lets the MCI parser know that you have a custom command table. Do this by making the following call in your driver's DRV_LOAD message handler: </P>
<P><BR></P>
<PRE>wTableEntry = mciLoadCommandResource (hInstance, "pioneer", 0);
</PRE>
<P>This example loads the resource named "pioneer," registers it with MCI, and returns a handle to that table. </P>
<P>If you have created a custom command table, your device driver must free the table when your device driver terminates. To free the table, include the following call in your device driver's DRV_FREE message handler: </P>
<P><BR></P>
<PRE>fResult = mciFreeCommandResource (wTableEntry);
</PRE>
<P>Use the table index number returned from <B>mciLoadCommandResource</B> as the argument to this function. This function returns TRUE if the table index number is valid. </P>
<H4><A NAME="sec14"></A>Search Order for MCI Command Tables </H4><P>MCI supports three types of tables: core, device-type, and device-specific. While parsing, the search order is from device-specific to device-type to core. When the command being searched for is found in a table, searching for that command is terminated. This means that if you have a play command in your device-specific command table, then the parser will use that one instead of the one in the device-type or core command tables. </P>
<P>Your command tables can reside in external files or you can bind them to your device driver. The external files are simply DLLs with only the compiled command table. A table for a device-specific command set must use the same table name used by the device driver in its <B>mciLoadCommandResource</B> call. They must use MCI for the extension. Avoid using the names of MCI device types as filenames. Using a device type name will prevent other devices from using the default MCI command tables. </P>
<P>If your device driver is a new device type and the command table it uses is type- specific (that is, it is not a custom or device-specific command table), you do not need to register the command table with <B>mciLoadCommand Resource</B>. When you return MCI_DEVTYPE_OTHER in the <B>wType</B> member of the <B>MCI_OPEN_DRIVER_PARMS</B> structure, MCI will automatically search for the type-specific command table. To obtain the filename, MCI searches the SYSTEM.INI file for the name of your device driver and will use this name to load your type-specific command table. </P>
<P>MCI gives priority to the command tables contained in external files. Thus, you can use the command tables in external files to supersede the bound command tables. For example, the command table bound with your driver could be the most commonly used table. For a foreign language version of the device driver, you could supersede the internal table with a foreign language command table by simply including it in an external file. Command tables must be in directory accessible by the Windows <B>OpenFile</B> function. </P>
<P>If you are using external files for the command tables, you might also place string resources in the file. MCI will also search for string resources in an external command files before searching for it in a bound resource. </P></FONT></BODY></HTML>
