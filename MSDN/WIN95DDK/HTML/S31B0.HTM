<HTML><HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Call_When_VM_Returns</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">
<FONT FACE="verdana,arial,helvetica" SIZE="2">
<H3>Call_When_VM_Returns </H3><P><BR></P>
<PRE>include vmm.inc

mov     eax, TimeOut            ; milliseconds until time out
mov     edx, RefData            ; reference data
mov     esi, OFFSET32 Callback  ; address of callback function
VMMcall Call_When_VM_Returns
</PRE>
<P>Installs a callback function that receives control when a virtual machine executes the <B>iret</B> instruction for the current interrupt. Uses Client_CS, Client_EIP, Flags. </P>
<UL><LI>     No return value. </LI></UL><P></P>
<P><I>TimeOut</I> </P>
<P>Number of milliseconds to wait before calling the callback procedure. The time out occurs only if the <B>iret</B> instruction is not executed before the specified time elapses. If this parameter is positive, the system calls the callback when time elapses. If this parameter is negative, the system calls the callback when time elapses and calls it again when the <B>iret</B> instruction is executed. If this parameter is zero, the system ignores the time out. </P>
<P><I>RefData</I> </P>
<P>Reference data to be passed to the callback procedure. Can be any 32-bit value, but is typically the address of a driver-defined structure. </P>
<P><I>Callback</I> </P>
<P>Address of the callback procedure. For more information about the callback procedure, see below. </P>
<P>A virtual device typically uses this service in a callback procedure that it installed using the <B>Hook_V86_Int_Chain</B> service. This service directs the system to replace the return address for the interrupt with the address of the callback procedure. That is, the system pushes the callback procedure address on the stack when it creates the stack frame for the interrupt. The system then passes the interrupt to the virtual machine. </P>
<P>When the virtual machine executes the <B>iret</B> instruction, the callback procedure receives control and can carry out tasks. After the callback procedure returns, the system restores the original interrupt return address and execution continues as if returning from the interrupt. </P>
<P></P>
<P><B>Note </B></P>
<P>The preceding description implies that the only meaningful place to use Call_When_VM_Returns is when a Simulate_Far_Call or Build_Int_Stack_Frame is going to happen soon. (As noted, this is typically done inside the callback installed by Hook_V86_Int_Chain.) In particular, in order to hook the back end of a simulated interrupt, you must call Call_When_VM_Returns before the interrupt itself is simulated. If the interrupt or far call has already been simulated, Call_When_VM_Returns will not do what you want. (The name of the service is rather unfortunate. It really means "Call when the VM returns to where it is now", and not "Call when the VM executes a return instruction".) </P>
<P></P>
<P>The system calls this callback procedure as follows: </P>
<P><BR></P>
<PRE>mov     ebx, VM             ; current VM handle
mov     edi, hCurThread     ; current thread handle
mov     edx, RefData        ; reference data
mov     ebp, OFFSET32 crs   ; points to a Client_Reg_Struc
call    [Callback]
</PRE>
<P>The <I>VM</I> parameter is a handle identifying the current virtual machine. The <I>RefData</I> parameter is the value supplied when the callback procedure was installed, and the <I>crs</I> parameter points to a <B>Client_Reg_Struc</B> structure containing the register values for the virtual machine. </P>
<P>If the system calls the callback procedure as a result of a time out, it sets the carry flag before calling the procedure. If the system calls the callback a second time (once for a time out and once for the <B>iret</B> instruction), the system sets the zero flag before calling the procedure a second time. The value of the zero flag is indeterminate unless the <I>TimeOut</I> parameter specifies a negative value. </P>
<P>In other words, </P>
<P>(1) If you passed TimeOut = 0, then the callback is called when the VM returns and at no other time. </P>
<P>(2) If you passed TimeOut &gt; 0, then the callback should begin like this: </P>
<P><BR></P>
<PRE>jc      timed_out;  Timeout notification
                 ;  Otherwise, the VM returned
                 ;  before the timeout expired
</PRE>
<P>(3) If you passed TimeOut &lt; 0, then the callback should begin like this: </P>
<P><BR></P>
<PRE>jc      timed_out    ;  Timeout notification
                     ;  Otherwise, the VM returned
jnz         normal_return;  VM returned with no timeout
                     ; Else, VM returned with timeout
</PRE>
<P>See also <B>Hook_V86_Int_Chain</B> </P>
<P></P>
<P></P></FONT></BODY></HTML>
