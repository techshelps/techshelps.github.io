<HTML><HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Time-Based Interrupts</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">
<FONT FACE="verdana,arial,helvetica" SIZE="2">
<H3>Time-Based Interrupts </H3><P>If the pen stops moving or is lifted beyond the tablet's range of sensitivity, many devices will stop generating hardware interrupts. This ends the normal flow of communication between the pen device and Windows. </P>
<P>However, the recognition model of the Pen API version 2.0 requires the pen driver to continuously call into the system even when there is no pen data available. If the pen hardware maintains its own clock mechanism, it can continue to pulse time-based interrupts even when the pen is out of range. When pen motion ceases, the time-based interrupts ensure the system continues to receive pen information. </P>
<P>If the pen device does not contain its own clock, the pen device driver must compensate by using the system timer. In this case, the driver provides a timer hook that activates at regular intervals. This enables the driver to continue its stream of system calls even if the normal hardware interrupts from the device have ceased. </P>
<P>The pen Unidriver sample code uses the system timer. If the OEM device generates its own time-based interrupts, the developer should remove the code that uses the system timer from the Unidriver source code. Such code is in the sample virtual pen driver source code modules HWINT.C, TIMERCB.C, and APIPROCS.C. </P>
<P>When enabled through the DRV_ENABLE message, the virtual pen driver sets up a callback timer function to use the system timer. The callback is named <B>cTimer_Callback_Entry_Point</B> in the TIMERCB.C source file. <B>cTimer_Callback_Entry_Point</B> receives control at each timer tick, which occurs every 55 milliseconds. If it determines that no pen data has arrived from the tablet since the last timer tick, <B>cTimer_Callback_Entry_Point</B> fabricates an <I>out-of-range</I> packet and schedules a callback to the function registered by PENWIN.DLL so the fabricated packet will be sent to the system. An out-of-range packet is a <B>DRV_PENPACKET</B> structure with the <B>wPDK</B> member set to the defined value PDK_OUTOFRANGE. After completing all this, <B>cTimer_Callback_Entry_Point</B> sets up another timer tick callback and waits. </P>
<P>Handling out-of-range pen packets is a virtual pen driver design issue. </P>
<P>All tablets run in what is called in this document <I>shutup mode</I>. In shutup mode, the tablet sends only one out-of-range packet when the pen goes out of range and then sends no more packets until the pen goes back into range. However, serial communications and tablets may be unreliable and the one out-of-range packet is never received by the driver. Sometimes such a lost out-of-range packet can cause Windows 95 to stop processing messages and force the user to restart Windows. For example, suppose the user employs the pen to move a window by dragging the window's title bar. A possible sequence of important pen events during this window dragging operation are: </P>
<P>    1    Pen is down at (x1, y1), which is on the title bar. </P>
<P>    2    Pen is up at (x2, y2), which establishes the new location of the window. </P>
<P>    3    Pen goes out of range because the user is finished moving the window. </P>
<P></P>
<P>If both the second and third events are lost because of unreliable communication between the tablet and the virtual pen driver, the user will eventually have to restart Windows. </P>
<P>To guard against this with tablets that run only in shutup mode, the sample virtual pen driver uses a timer function to constantly monitor the time interval between packet receipt events in the virtual pen driver. If the virtual pen driver does not receive a packet within this time interval, the time function generates an out-of-range packet, which gets sent to the pen driver which notifies Windows of the pen event. </P>
<P>Some OEM tablets (such as the Wacom tablets) enable the virtual pen driver to toggle the tablet between two modes: </P>
<UL><LI>     Shutup mode, as described earlier, sends only one out-of-range packet when the pen goes out of range and then sends no more packets until the pen goes back into range. </LI><LI>     <I>Speakup mode</I> sends pen information constantly, even when the pen is out of range. When the pen is out of range, the tablet sends one out-of-range packet after another. </LI></UL><P></P>
<P>For such tablets, the following strategy can be used to insure that unreliable pen packet communication between the tablet and the virtual pen driver do not force the user to restart Windows: </P>
<P>    1    The tablet is kept in speakup mode until an out-of-range packet is received (that way, the virtual pen driver will always receive an out-of-range packet to mark the transition form in-range to out-of-range even if out-of-range packets are lost). </P>
<P>    2    When the virtual pen driver receives an out-of-range packet, it puts the tablet in shutup mode so it does not receive useless out-of-range packets). </P>
<P>    3    The next time the virtual pen driver receives a packet (it must be an in-range packet), it puts the tablet in speakup mode again. </P>
<P></P>
<P>If you are writing a virtual pen driver that supports both shutup and speakup modes, using the above strategy will put more responsive pens in the hands of the users than if you use the timer method. </P>
<P>The Windows95 DDK sample pen driver supports only the timer method of guarding against lost out-of-range pen packets. For sample code that implements the method that uses both speakup and shutup modes, see the sample pen driver in the Windows 3.1 DDK. </P>
<P>The timer strategy is implemented in the following blocks of code: </P>

<TABLE COLS="3" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="72pt" VALIGN="TOP"><COL WIDTH="144pt" VALIGN="TOP"><COL WIDTH="115pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B>Source Module </B></P></TD><TD VALIGN="TOP"><P><B>Function </B></P></TD><TD VALIGN="TOP"><P><B>Comment </B></P></TD></TR><TR><TD VALIGN="TOP"><P>TIMERCB.C </P></TD><TD VALIGN="TOP"><P><B>cTimer_Callback_Entry_Point</B> </P></TD><TD VALIGN="TOP"><P>This code determines whether it has been too long since receipt of the last packet and, if so, synthesizes an out-of-range packet. </P></TD></TR><TR><TD VALIGN="TOP"><P>APIPROCS.C </P></TD><TD VALIGN="TOP"><P><B>cVpenD_API_Enable</B> </P></TD><TD VALIGN="TOP"><P>Registers the timer callback entry point and, if the HW_TIMERMODEL flag is set, causes monitoring of the interval between interrupts to begin. </P></TD></TR></TBODY></TABLE>
<P><BR></P><P></P>
<P>Note that with tablets that support speakup mode, it can also be used to implement playback of stored pen packets. The virtual pen driver puts the tablet in speakup mode and every time it receives an out-of-range packet, the driver substitutes information from the next stored pen packet and sends it on to the pen driver as a pen packet. The blocks of code that implement this strategy in the sample virtual pen driver are: </P>

<TABLE COLS="3" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="116pt" VALIGN="TOP"><COL WIDTH="116pt" VALIGN="TOP"><COL WIDTH="116pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B>Source Module </B></P></TD><TD VALIGN="TOP"><P><B>Function </B></P></TD><TD VALIGN="TOP"><P><B>Comment </B></P></TD></TR><TR><TD VALIGN="TOP"><P>APIPROC.C </P></TD><TD VALIGN="TOP"><P><B>cVpenD_API_Proc</B> </P></TD><TD VALIGN="TOP"><P>See the VPEND_PENPLAYSTART case block in the dwMsg switch structure. </P></TD></TR><TR><TD VALIGN="TOP"><P>OEMAPI.C </P></TD><TD VALIGN="TOP"><P><B>cOEM_API_Proc</B> </P></TD><TD VALIGN="TOP"><P>Sends the speak up and shut up command strings to the tablet. </P></TD></TR></TBODY></TABLE>
<P><BR></P><P></P></FONT></BODY></HTML>
