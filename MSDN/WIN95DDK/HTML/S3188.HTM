<HTML><HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>BASE</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">
<FONT FACE="verdana,arial,helvetica" SIZE="2">
<H3>BASE </H3><P>This section describes the samples included in the Base\Samples subdirectory. These samples show a wide variety of techniques that you can use in your own virtual device drivers. To find samples specific to your hardware device, see the subdirectory that contains your device class' files. </P>
<H4><A NAME="sec0"></A>ASYNCW32 </H4><P>The ASYNCW32 sample demonstrates how to communicate asynchronously with a VxD from WIN32, using the DeviceIoControl interface. </P>
<P>This sample is comprised of the following files: </P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="144pt" VALIGN="TOP"><COL WIDTH="204pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>CON_AW32.C </P></TD><TD VALIGN="TOP"><P>Application front end that will dynamically load the C VxD sample, call it, and display data returned from the C VxD. </P></TD></TR><TR><TD VALIGN="TOP"><P>ASYNCW32.C </P></TD><TD VALIGN="TOP"><P>Sample VxD written in C. This VxD supports the WIN32 DeviceIoControl interface, which is used by WIN32 to communicate with VxDs. This VxD can be loaded both dynamically and statically. The VxD will communicate asynchronously with CON_AW32.EXE </P></TD></TR><TR><TD VALIGN="TOP"><P>SYSCTRL.ASM </P></TD><TD VALIGN="TOP"><P>Part of sample VxD that contains the real-mode INIT segment (which is 16-bit) and the <B>System_Control</B> message dispatcher. </P></TD></TR><TR><TD VALIGN="TOP"><P>MAKEFILE </P></TD><TD VALIGN="TOP"><P>Makefile for building the C VxD sample. This sample was built using the latest Microsoft Visual C++ tools as well as Microsoft MASM version 6.11c. The MSVC linker will display several LNK4078 warnings during linking; these are expected and can be ignored. </P></TD></TR><TR><TD VALIGN="TOP"><P>WRAPPERS.ASM </P></TD><TD VALIGN="TOP"><P>Wrapper for <B>VWIN32_DIOCCompletionRoutine</B>. </P></TD></TR><TR><TD VALIGN="TOP"><P>MYLOCAL.INC </P></TD><TD VALIGN="TOP"><P>Private version of Local.inc (found in Base\Vxdwraps), which is used to build the created wrapper for linking with C VxD object. </P></TD></TR></TBODY></TABLE>
<P><BR></P><P></P>
<H4><A NAME="sec1"></A>BIOSXLAT </H4><P>The BIOSXLAT sample installs protected-mode handlers for interrupts 10h, 13h, 15h, and 1Ch. </P>
<H4><A NAME="sec2"></A>CVXD32 </H4><P>ThCVXD32 sample demonstrates how to perform the following tasks: </P>
<UL><LI>     How to write a VxD in C. </LI><LI>     How to communicate with VxDs from WIN32 (using the DeviceIoControl interface). </LI><LI>     How to write wrappers for VxD services for which there are currently no wrappers provided. </LI></UL><P></P>
<P>This sample is comprised of the following files: </P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="144pt" VALIGN="TOP"><COL WIDTH="204pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>CON_SAMP.C </P></TD><TD VALIGN="TOP"><P>Application front end that will dynamically load the C VxD sample, call it, and display data returned from the C VxD. </P></TD></TR><TR><TD VALIGN="TOP"><P>CVXDSAMP.C </P></TD><TD VALIGN="TOP"><P>Sample VxD written in C. This VxD supports the WIN32 DeviceIoControl interface which is used by WIN32 to communicate with VxDs. This VxD can be loaded both dynamically and statically. </P></TD></TR><TR><TD VALIGN="TOP"><P>CVXDCTRL.ASM </P></TD><TD VALIGN="TOP"><P>Part of the sample VxD that contains the real-Mode INIT segment (which is 16-bit) and the <B>System_Control</B> message dispatcher. </P></TD></TR><TR><TD VALIGN="TOP"><P>MAKEFILE </P></TD><TD VALIGN="TOP"><P>Makefile for building the C VxD sample using both the Microsoft Visual C++ version 2.0 Linker and Link386. </P></TD></TR><TR><TD VALIGN="TOP"><P>CVXDSAMP.DEF </P></TD><TD VALIGN="TOP"><P>Module-definition file used by both the Microsoft Visual C++ version 2.0 Linker and Link386. The MSVC20 linker will display warnings during linking; these are expected and can be ignored for this sample. </P></TD></TR><TR><TD VALIGN="TOP"><P>CVXDSAMP.LNK </P></TD><TD VALIGN="TOP"><P>Link file used by Link386. </P></TD></TR><TR><TD VALIGN="TOP"><P>VKDGKO.ASM </P></TD><TD VALIGN="TOP"><P>Wrapper for <B>VKD_Get_Kbd_Owner</B>. </P></TD></TR><TR><TD VALIGN="TOP"><P>MYVKD.H </P></TD><TD VALIGN="TOP"><P>Private conversion of the Vkd.inc file to a C include file. </P></TD></TR><TR><TD VALIGN="TOP"><P>MYLOCAL.INC </P></TD><TD VALIGN="TOP"><P>Private version of Local.inc (found in Base\Vxdwraps) which is used to build the created wrapper for linking with the C VxD object. </P></TD></TR><TR><TD VALIGN="TOP"><P>VKDWRAPS.H </P></TD><TD VALIGN="TOP"><P>Include file that defines the VKD wrappers interface. This file is included by the CVXDSAMP.C file. </P></TD></TR></TBODY></TABLE>
<P><BR></P><P></P>
<H4><A NAME="sec3"></A>DYNAPAGE </H4><P>The DYNAPAGE sample is the source code for the pagefile device (DYNAPAGE.VXD). </P>
<H4><A NAME="sec4"></A>EATPAGES </H4><P>The EATPAGES VxD demonstrates the use of the linked list services, as well as the system page allocator functions. The VxD simply allocates half of the free physical pages at boot time and frees them at system exit. This can be useful to simulate low memory conditions. </P>
<P>The sample uses the following services: </P>
<UL><LI>     VMMCall <B>_GetDemandPageInfo</B> </LI><LI>     VMMCall <B>List_Allocate</B> </LI><LI>     VMMCall <B>List_Attach_Tail</B> </LI><LI>     VMMCall <B>List_Create</B> </LI><LI>     VMMCall <B>List_Deallocate</B> </LI><LI>     VMMCall <B>List_Get_First</B> </LI><LI>     VMMCall <B>List_Get_Next</B> </LI><LI>     VMMCall <B>List_Remove</B> </LI><LI>     VMMCall <B>_PageAllocate</B> </LI><LI>     VMMCall <B>_PageFree</B> </LI></UL><P></P>
<H4><A NAME="sec5"></A>EBIOS </H4><P>The EBIOS sample is source code for the EBIOS (Extended BIOS) virtual device driver. This device driver is for use on machines that have EBIOS, such as the PS/2. (Extended BIOS should not be confused with Enhanced BIOS, which provides support for IDE hard disks greater than 504 MB.) </P>
<H4><A NAME="sec6"></A>GENERIC </H4><P>The basic structure of a VxD is illustrated by the GENERIC sample. As written, it can be loaded, although it performs no function. This VxD can be used to create a base set of source files for starting a VxD project. </P>
<H4><A NAME="sec7"></A>GPTRAP </H4><P>The GPTRAP sample uses <B>Hook_PM_Fault</B> to catch GP faults. When this VxD receives control because of a GP fault, it executes an INT 1 call. If execution is continued, control is passed to the next handler in the fault handler chain. </P>
<P>The "VxDStub" code for this VxD is an example in itself. The stub hooks INT 2Fh and then terminates with stay resident. When Windows later loads, this TSR responds to the INT 2Fh, AX=1605h (Windows initialization) broadcast. The TSR returns a structure that causes the VxD to be loaded, so no "device=" line is required in the SYSTEM.INI file. </P>
<P>The sample uses the following service: </P>
<UL><LI>     VMMCall <B>Hook_PM_Fault</B> </LI></UL><P></P>
<H4><A NAME="sec8"></A>VDIALOG </H4><P>The VDIALOG sample is to demonstrate the basic use of the <B>Install_IO_Handler</B> and <B>SHELL_Resolve_Contention</B> function calls. The <B>Install_IO_Handler</B> call enables the VxD to trap IN and OUT instructions to a port from any VM. The <B>SHELL_Resolve_Contention</B> call is then used to display a dialog box when a VM attempts to use a port that is already assigned to another VM. </P>
<P>This VxD also demonstrates the use of <B>Enable_Local_Trapping</B> and <B>Disable_Local_Trapping</B> to allow the owner of the port in question to freely do input and output to the port without overhead. </P>
<P>Uses the following services: </P>
<UL><LI>     VMMCall <B>Disable_Local_Trapping</B> </LI><LI>     VMMCall <B>Enable_Local_Trapping</B> </LI><LI>     VMMCall <B>Install_IO_Handler</B> </LI><LI>     VxDCall <B>SHELL_Resolve_Contention</B> </LI></UL><P></P>
<H4><A NAME="sec9"></A>VDMAD </H4><P>The VDMAD sample is source code for the virtual DMA virtual device driver. </P>
<H4><A NAME="sec10"></A>VFINTD </H4><P>The VFINTD sample has been provided to demonstrate the technique of handling the virtualization of a particular IRQ. </P>
<P>The sample uses the following services: </P>
<UL><LI>     VxDCall <B>VPICD_Clear_Int_Request</B> </LI><LI>     VxDCall <B>VPICD_Phys_EOI</B> </LI><LI>     VxDCall <B>VPICD_Set_Int_Request</B> </LI><LI>     VxDCall <B>VPICD_Virtualize_IRQ</B> </LI></UL><P></P>
<H4><A NAME="sec11"></A>VHOOK86D </H4><P>The VHOOK86D sample is a simple VxD that will hook the V86 INT chain by using the <B>Hook_V86_Int_Chain</B> service. </P>
<P></P>
<P><B>Caution </B></P>
<P>This VxD, by default, will hook INT 2Fh. This VxD may impair system performance. It is intended only to be a demonstration.</P>
<P></P>
<H4><A NAME="sec12"></A>VIDLED </H4><P>The VIDLED VxD demonstrates how to use the <B>Call_When_Idle</B> function. </P>
<P>The sample uses the following service: </P>
<UL><LI>     VMMCall <B>Call_When_Idle</B> </LI></UL><P></P>
<H4><A NAME="sec13"></A>VITD </H4><P>The VITD sample provides a simulation of a hardware interval timer for virtual machines. To install it, build VITD.VXD, place the final VITD.VXD in the Windows System directory, add a "device=VITD.VXD" line in the [386Enh] section of the SYSTEM.INI, and restart Windows. </P>
<P>The sample uses the following services: </P>
<UL><LI>     VMMCall <B>_Allocate_Device_CB_Area</B> </LI><LI>     VMMCall <B>Begin_Nest_Exec</B> </LI><LI>     VMMCall <B>Call_Priority_VM_Event</B> </LI><LI>     VMMCall <B>Cancel_Time_Out</B> </LI><LI>     VMMCall <B>End_Nest_Exec</B> </LI><LI>     VMMCall <B>Exec_Int</B> </LI><LI>     VMMCall <B>Fatal_Memory_Error</B> </LI><LI>     VMMCall <B>Get_VM_Exec_Time</B> </LI><LI>     VMMCall <B>Install_Mult_IO_Handlers</B> </LI><LI>     VxDCall <B>VTD_Begin_Min_Int_Period</B> </LI><LI>     VxDCall <B>VTD_End_Min_Int_Period</B> </LI><LI>     VxDCall <B>VTD_Get_Interrupt_Period</B> </LI><LI>     VxDCall <B>VTD_Get_Version</B> </LI></UL><P></P>
<H4><A NAME="sec14"></A>VMIOD </H4><P>The VMIOD sample can be used to monitor the I/O traffic associated with a particular device. Specifically, INs and OUTs to a single I/O port will trigger debugging output on the secondary monitor of the system. Note that you must have a secondary monitor to use this VxD. </P>
<P>The sample uses the following services: </P>
<UL><LI>     VMMCall <B>Clear_Mono_Screen</B> </LI><LI>     VMMCall <B>Get_Profile_Hex_Int</B> </LI><LI>     VMMCall <B>Install_IO_Handler</B> </LI><LI>     VMMCall <B>Out_Mono_String</B> </LI><LI>     VMMCall <B>Set_Mono_Cur_Pos</B> </LI></UL><P></P>
<H4><A NAME="sec15"></A>VMIRQD </H4><P>The VMIRQD sample can be used to monitor the activity associated with a particular hardware IRQ. Specifically, hardware interrupts, EOIs, IRETs,virtual interrupts, and mask changes associated with a particular IRQ will trigger debugging output on the secondary monitor of the system. Note that you must have a secondary monitor to use this VxD. </P>
<P>The sample uses the following services: </P>
<UL><LI>     VMMCall <B>Clear_Mono_Screen</B> </LI><LI>     VMMCall <B>Get_Profile_Decimal_Int</B> </LI><LI>     VMMCall <B>Out_Mono_String</B> </LI><LI>     VMMCall <B>Set_Mono_Cur_Pos</B> </LI><LI>     VxDCall <B>VPICD_Clear_Int_Request</B> </LI><LI>     VxDCall <B>VPICD_Phys_EOI</B> </LI><LI>     VxDCall <B>VPICD_Set_Int_Request</B> </LI><LI>     VxDCall <B>VPICD_Virtualize_IRQ</B> </LI></UL><P></P>
<H4><A NAME="sec16"></A>VMPAGES </H4><P>The VMPAGES VxD demonstrates how to export a VxD service (in this case <B>GetVMPgCount</B>) to an application. </P>
<P>The sample uses the following service: </P>
<UL><LI>     VMMCall <B>_GetVMPgCount</B> </LI></UL><P></P>
<H4><A NAME="sec17"></A>VNMID </H4><P>The VNMID VxD shows how to hook the NMI (non-maskable interrupt). It currently does not actually do anything with the NMI, except to chain to the previous handler. </P>
<P>The sample uses the following services: </P>
<UL><LI>     VMMCall <B>Get_NMI_Handler_Addr</B> </LI><LI>     VMMCall <B>Hook_NMI_Event</B> </LI><LI>     VMMCall <B>Set_NMI_Handler_Addr</B> </LI></UL><P></P>
<H4><A NAME="sec18"></A>VPOSTD </H4><P>The VPOSTD sample demonstrates one way a VxD can cause a message to be posted to a Windows application. It also shows a fairly useful implementation of real and protected mode functions. </P>
<P>The sample uses the following services: </P>
<UL><LI>     VMMCall <B>_Allocate_Device_CB_Area</B> </LI><LI>     VMMCall <B>Begin_Nest_Exec</B> </LI><LI>     VMMCall <B>Call_Priority_VM_Event</B> </LI><LI>     VMMCall <B>Call_When_VM_Ints_Enabled</B> </LI><LI>     VMMCall <B>End_Nest_Exec</B> </LI><LI>     VMMCall <B>Fatal_Memory_Error</B> </LI><LI>     VMMCall <B>Get_Crit_Section_Status</B> </LI><LI>     VMMCall <B>Get_Sys_VM_Handle</B> </LI><LI>     VMMCall <B>Resume_Exec</B> </LI><LI>     VMMCall <B>Simulate_Far_Call</B> </LI><LI>     VMMCall <B>Simulate_Push</B> </LI><LI>     VMMCall <B>Test_Sys_VM_Handle</B> </LI></UL><P></P>
<H4><A NAME="sec19"></A>VWATCHD </H4><P>The VWATCHD sample is a virtual device that demonstrates the basic structure of a VxD. This VxD issues a <B>Trace_Out</B> (sends messages to the COMx: port) at its entry points. By watching the messages it displays, you can study the situations that cause the various VxD entry points to be called. </P>
<P>This sample shows all major entry points, very simple function calls (separate for V86 mode as well as PM mode), and a "debug_dump" section. </P>
<P>The sample uses the following services: </P>
<UL><LI>     VMMCall <B>_Allocate_Device_CB_Area</B> </LI><LI>     VMMCall <B>Get_System_Time</B> </LI><LI>     VxDCall <B>VwatchD_Get_Version</B> </LI></UL><P></P>
<H4><A NAME="sec20"></A>VWFD </H4><P>The VWFD sample, when installed on a system running Windows in enhanced mode, allows Microsoft&reg; MS-DOS&reg; applications to determine if they are running in a window or full-screen. TSTWF.ASM is a sample MS-DOS program that uses the exposed VWFD API. </P>
<P>The sample uses the following services: </P>
<UL><LI>     VMMCall <B>_Allocate_Device_CB_Area</B> </LI><LI>     VMMCall <B>Fatal_Memory_Error</B> </LI><LI>     VMMCall <B>Get_Next_VM_Handle</B> </LI><LI>     VMMCall <B>Hook_Device_Service</B> </LI><LI>     VMMCall <B>Test_Cur_VM_Handle</B> </LI></UL><P></P>
</FONT></BODY></HTML>
