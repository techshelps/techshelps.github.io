<HTML><HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Input and Output Requests</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">
<FONT FACE="verdana,arial,helvetica" SIZE="2">
<H3>Input and Output Requests </H3><P>File system drivers and other clients use I/O requests to direct a device to carry out a given I/O operation. To submit a request, a client fills the members of an <B>IOR</B> structure (part of an <B>IOP</B> structure) and passes the address of the <B>IOR</B> to the <B>IOS_SendCommand</B> service. The IOS passes the <B>IOR</B> to the various drivers in the calldown chain. The IOS and device drivers update this structure as the request progresses through the chain. There are the following I/O requests: </P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="223pt" VALIGN="TOP"><COL WIDTH="124pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>IOR_ABORT_QUEUE (0x24) </P></TD><TD VALIGN="TOP"><P>Cancels queued requests. </P></TD></TR><TR><TD VALIGN="TOP"><P>IOR_CANCEL (0x03) </P></TD><TD VALIGN="TOP"><P>Cancels a previously issued command. </P></TD></TR><TR><TD VALIGN="TOP"><P>IOR_CLEAR_QUEUE (0x10) </P></TD><TD VALIGN="TOP"><P>Requests to clear NEC queues for device. Returns when queue is clear. </P></TD></TR><TR><TD VALIGN="TOP"><P>IOR_COMPUTE_GEOM (0x0C) </P></TD><TD VALIGN="TOP"><P>Determine device geometry information. </P></TD></TR><TR><TD VALIGN="TOP"><P>IOR_DOS_RESET (0x11) </P></TD><TD VALIGN="TOP"><P>Corresponds to INT 13h reset. </P></TD></TR><TR><TD VALIGN="TOP"><P>IOR_EJECT_MEDIA (0x08) </P></TD><TD VALIGN="TOP"><P>Ejects media. </P></TD></TR><TR><TD VALIGN="TOP"><P>IOR_FLUSH_DRIVE (0x27) </P></TD><TD VALIGN="TOP"><P>Flushes dirty data. </P></TD></TR><TR><TD VALIGN="TOP"><P>IOR_FLUSH_DRIVE_AND_DISCARD (0x28) </P></TD><TD VALIGN="TOP"><P>Flushes dirty data and discards queued data. </P></TD></TR><TR><TD VALIGN="TOP"><P>IOR_FORMAT (0x0E) </P></TD><TD VALIGN="TOP"><P>Formats a track. </P></TD></TR><TR><TD VALIGN="TOP"><P>IOR_FSD_EXT (0x29) </P></TD><TD VALIGN="TOP"><P>Sends prinvate data to FSD layer. </P></TD></TR><TR><TD VALIGN="TOP"><P>IOR_GEN_IOCTL (0x0D) </P></TD><TD VALIGN="TOP"><P>Carries out a generic I/O control function. </P></TD></TR><TR><TD VALIGN="TOP"><P>IOR_LOAD_MEDIA (0x07) </P></TD><TD VALIGN="TOP"><P>Loads media. </P></TD></TR><TR><TD VALIGN="TOP"><P>IOR_LOCK_MEDIA (0x09) </P></TD><TD VALIGN="TOP"><P>Locks media. </P></TD></TR><TR><TD VALIGN="TOP"><P>IOR_MEDIA_CHECK (0x05) </P></TD><TD VALIGN="TOP"><P>Gets disk change status. </P></TD></TR><TR><TD VALIGN="TOP"><P>IOR_MEDIA_CHECK_RESET (0x06) </P></TD><TD VALIGN="TOP"><P>Gets and resets disk change status. </P></TD></TR><TR><TD VALIGN="TOP"><P>IOR_READ (0x00) </P></TD><TD VALIGN="TOP"><P>Reads data from device. </P></TD></TR><TR><TD VALIGN="TOP"><P>IOR_REQUEST_SENSE (0x0B) </P></TD><TD VALIGN="TOP"><P>Returns drive sense data. </P></TD></TR><TR><TD VALIGN="TOP"><P>IOR_RESTART_QUEUE (0x23) </P></TD><TD VALIGN="TOP"><P>Restarts the queue in the same manner as the IOS queuing services. </P></TD></TR><TR><TD VALIGN="TOP"><P>IOR_SCSI_PASS_THROUGH (0x0F) </P></TD><TD VALIGN="TOP"><P>Passes a SCSI command through to device. </P></TD></TR><TR><TD VALIGN="TOP"><P>IOR_SCSI_REQUEST (0x12) </P></TD><TD VALIGN="TOP"><P>Request for SCSI device. </P></TD></TR><TR><TD VALIGN="TOP"><P>IOR_SET_WRITE_STATUS (0x22) </P></TD><TD VALIGN="TOP"><P>Sets write protect status. </P></TD></TR><TR><TD VALIGN="TOP"><P>IOR_SPIN_DOWN (0x25) </P></TD><TD VALIGN="TOP"><P>Directs the drive to stop spinning. </P></TD></TR><TR><TD VALIGN="TOP"><P>IOR_SPIN_UP (0x26) </P></TD><TD VALIGN="TOP"><P>Directs the drive to start spinning. </P></TD></TR><TR><TD VALIGN="TOP"><P>IOR_UNLOCK_MEDIA (0x0A) </P></TD><TD VALIGN="TOP"><P>Unlocks media. </P></TD></TR><TR><TD VALIGN="TOP"><P>IOR_VERIFY (0x02) </P></TD><TD VALIGN="TOP"><P>Verifies data on device. </P></TD></TR><TR><TD VALIGN="TOP"><P>IOR_WRITE (0x01) </P></TD><TD VALIGN="TOP"><P>Writes data to device. </P></TD></TR><TR><TD VALIGN="TOP"><P>IOR_WRITEV (0x04) </P></TD><TD VALIGN="TOP"><P>Writes and verifies data to device. </P></TD></TR></TBODY></TABLE>
<P><BR></P><P></P>
<P>To generate a read request, for example, the client allocates an <B>IOP</B> using the ISP_CREATE_IOP service, fills the <B>IOR</B> with the data for the request, and passes the address of the <B>IOR</B> to the <B>IOS_SendCommand</B> service. The IOS passes the <B>IOR</B> to the volume tracker, which makes sure the correct media is loaded. The volume tracker passes the <B>IOR</B> to the disk TSD, which converts the volume relative address to a media relative address. The disk TSD passes the <B>IOR</B> to the port driver, which initiates a read operation at the device and returns control to the disk TSD. Throughout this process each driver that receives the <B>IOR</B> takes ownership of it. The port driver retains ownership of the <B>IOR</B>. </P>
<P>A client typically allocates the <B>IOP</B> by using the ISP_CREATE_IOP service. This ensures that the IOS can provide request time-out support and other services. The <B>IOR</B> is the only portion of the <B>IOP</B> that the client may access with the exception of the first 32-bit field of the <B>IOP</B>, which contains the 32-bit physical address of the <B>IOP</B>. The correct size for the <B>IOP</B> is contained in the <B>VRP_max_req_size</B> member in the <B>VRP</B> structure. The correct offset into the <B>IOP</B> of the <B>IOR</B> is the sum of the <B>VRP_delta_to_ior</B> member and the <B>IOP</B> address. A client can retrieve the <B>VRP</B> for a given device by using the IRS_GET_VRP function of the <B>IOS_Requestor_Service</B> service. </P>
<P>When the IOS receives an <B>IOP</B>, it sets the following <B>IOP</B> members: </P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="144pt" VALIGN="TOP"><COL WIDTH="204pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B>IOP_physical_dcb</B> </P></TD><TD VALIGN="TOP"><P>Address of the physical <B>DCB</B> </P></TD></TR><TR><TD VALIGN="TOP"><P><B>IOP_original_dcb</B> </P></TD><TD VALIGN="TOP"><P>Address of the logical <B>DCB</B> </P></TD></TR><TR><TD VALIGN="TOP"><P><B>IOP_timer</B> </P></TD><TD VALIGN="TOP"><P>Timeout value to 15 seconds </P></TD></TR><TR><TD VALIGN="TOP"><P><B>IOP_calldown_ptr</B> </P></TD><TD VALIGN="TOP"><P>Address of the first layer in the calldown chain </P></TD></TR><TR><TD VALIGN="TOP"><P><B>IOP_callback_ptr</B> </P></TD><TD VALIGN="TOP"><P>Address of <B>IOS_iop_callback </B>callback routine </P></TD></TR></TBODY></TABLE>
<P><BR></P><P></P>
<P>After setting these members, the IOS calls the first layer in the calldown chain, typically the volume tracking driver. When the request is called back to IOS at <B>IOS_iop_callback</B>, contents of <B>IOR_req_req_handle</B> is placed on the stack, and <B>IOR_callback</B> is called. </P>
<P>See also <B>IOP</B>, <B>IOR</B>, <B>IOS_SendCommand</B>, <B>VRP</B> </P></FONT></BODY></HTML>
