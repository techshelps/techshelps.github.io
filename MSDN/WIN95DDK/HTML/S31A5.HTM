<HTML><HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Pageable VxDs</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">
<FONT FACE="verdana,arial,helvetica" SIZE="2">
<H2>Pageable VxDs </H2><P>This section describes how paging works using the Windows 3.1 model. Then, changes to the model for Windows 95 are described. </P>
<P>Under Windows 3.1, VxD code segments are always locked. This implies that VxD code is normally not preempted, with the following exceptions: </P>
<UL><LI>     If interrupts are enabled, hardware interrupts may be serviced. Therefore, any data structures that may be accessed by hardware interrupts must be protected by disabling interrupts during the access. (And obviously, any data structures accessed by a hardware interrupt must be locked.) </LI><LI>     Accessing swappable memory may result in the code being pre-empted, even if interrupts are disabled. (The VMM might need to wait for the page to arrive from the swap device.) Therefore, any data structures that exist in swappable memory must be protected by some sort of synchronization mechanism; merely disabling interrupts is not good enough. </LI><LI>     Calling a service that adjusts execution priorities may result in the code being pre-empted if the result of the adjustment is that the current virtual machine no longer has the highest execution priority in the system. </LI><LI>     Calling a service that allocates or frees memory from the system heap or pages from the page allocator may result in the code being pre-empted if the swap file needs to be adjusted to account for the memory being allocated or freed. </LI></UL><P></P>
<P>The terms pageable and swappable are synonymous. The VMM uses paging as its form of memory management. It does not swap segments or tasks. Where you see the word swap or a derivative thereof, substitute the corresponding form of the word page. </P>
<P>Windows 95 supports VxD with pageable code segments. While this has the benefits of allowing rarely-used code segments to get paged out, thus freeing up memory, it does come at the cost of adding more rules to follow. </P>
<P>Here are additional rules that apply to Windows 95 pageable VxDs. They are in addition to the existing rules from Windows 3.1. </P>
<UL><LI>     Pageable code and data may not be accessed by a hardware interrupt. </LI><LI>      Code in pageable segments may be preempted at any time by the paging system, even if interrupts are disabled. Thus, care should be taken to protect data structures from corruption by unsynchronized access. Consider the following code fragment: 
<P><BR></P>
<PRE>pushfd        ; Disable interrupts to protect a global
    cli            ; variable, so that the update is atomic
    mov eax, pHead     ; Get the head of the list
    mov ecx, [eax].pNext    ; And delete it from the list
    mov     pHead, ecx
    popfd            ; End of critical section
</PRE>
<P>If this code fragment resides in pageable memory, then it may be possible for code to interrupt this sequence and corrupt the linked list. Using standard synchronization techniques such as semaphores, you can serialize access to the data structure, but since there are hidden possibilities for deadlocks, the safest way to guarantee the correctness of the code is to keep it in locked memory. Furthermore, the data in which the linked list resides should also reside in locked memory. </P>

<P>If Windows 95 is paging through MS-DOS, allowing VxD code segments to be paged out would be catastrophic. In such situations, the VMM automatically locks all VxD code segments (and VxDLdr does the same for dynamically-loaded VxDs). </P></LI></UL><P></P></FONT></BODY></HTML>
