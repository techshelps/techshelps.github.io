<HTML><HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>_BlockOnID</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">
<FONT FACE="verdana,arial,helvetica" SIZE="2">
<H3>_BlockOnID </H3><P><BR></P>
<PRE>include vmm.inc

VMMcall _BlockOnID, &lt;ThreadID, Flags&gt;
</PRE>
<P>Records the identifier (ID) to be used to block the current thread. The actual blockage of a thread is signaled with _<B>SignalID</B>. Uses the C calling convention. Uses flags. </P>
<UL><LI>     No return value. </LI></UL><P></P>
<P><I>ThreadID</I> </P>
<P>The programmer-defined ID used to block the thread. </P>
<P><I>Flags</I> </P>
<P>Actions to take when interrupts occur while the virtual machine is blocked. This parameter can be a combination of the following values: </P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="144pt" VALIGN="TOP"><COL WIDTH="190pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B>Value </B></P></TD><TD VALIGN="TOP"><P><B>Meaning </B></P></TD></TR><TR><TD VALIGN="TOP"><P>Block_Enable_Ints </P></TD><TD VALIGN="TOP"><P>Service interrupts in the virtual machine even if it does not currently have interrupts enabled. This forces interrupts to be enabled. This value is only relevant if either Block_Svc_Ints or Block_Svc_If_Ints is set. </P></TD></TR><TR><TD VALIGN="TOP"><P>Block_Svc_If_Ints_Locked </P></TD><TD VALIGN="TOP"><P>Service interrupts in the virtual machine even if the virtual machine is blocked, and the VMStat_V86IntsLocked flag is set. </P></TD></TR><TR><TD VALIGN="TOP"><P>Block_Svc_Ints </P></TD><TD VALIGN="TOP"><P>Service interrupts in the virtual machine even if the virtual machine is blocked. </P></TD></TR></TBODY></TABLE>
<P><BR></P><P></P>
<P>Typically, the <I>ThreadID</I> consists of 32-bit linear address of something related to the object being blocked on, because that helps ensure uniqueness. When the same ID is passed to <B>SignalID</B>, the blocked thread reawakens. When a thread reawakens, it must check whether the wakeup was valid or spurious. </P>
<P>This service always blocks the current thread on the ID passed. Multiple threads may block on the same ID. When the ID is signaled with _<B>SignalID</B> all of the threads currently blocked on the ID will unblock. </P>
<P>Block IDs are not guaranteed to be unique to the caller; an unrelated piece of code may signal the ID in order to awaken a thread that it has blocked and cause this one to be spuriously awakened. Therefore when this service returns the caller must check for a spurious wake up and call <B>_BlockOnID</B> again if this has occurred. Typically a user maintained flag is used for this. The flag is set before calling _<B>BlockOnID</B> the first time and cleared when <B>_SignalID</B> is called. </P>
<P>The Block ID is traditionally the address of an object somehow related to the reason why the virtual device needs to block. Be aware of race conditions that may occur if <B>_BlockOnID</B> is called after the ID is signalled. For example, if a virtual device initiates an operation, it may be that the operation completes and the Block ID is signalled before the virtual device gets to call <B>_BlockOnID</B> to wait for the signal. The virtual device ends up blocking waiting for a signal that has already arrived. </P>
<P>See also <B>_SignalID</B> </P>
<P></P>
<P></P></FONT></BODY></HTML>
