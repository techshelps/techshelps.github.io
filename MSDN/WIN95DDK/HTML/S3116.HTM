<HTML><HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>IFSMgr_UnlockFile</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">
<FONT FACE="verdana,arial,helvetica" SIZE="2">
<H3>IFSMgr_UnlockFile </H3><P><BR></P>
<PRE>IFSMgr_UnlockFile(
 void ** ppFSDLockListHead,
 unsigned long LockOffset,
 unsigned long LockLength,
 unsigned long LockOwner,
 void * pOpenFileInstance,
 unsigned long fLockSemantics
 )
</PRE>
<P>This service unlocks a previously locked region of an open file. The offset and the length of the region to be unlocked should correspond exactly to a previously locked region. This is true even in the case where there are overlapping locks. The IFS manager just walks the list of locks on the file and sees if it finds a match with one of them. If it does, it frees that lock entry from the list. </P>
<P><I>ppFSDLockListHead</I> </P>
<P>Supplies a pointer to a variable that contains the pointer to the list of locks. </P>
<P><I>LockOffset</I> </P>
<P>Supplies the starting offset in the file of the region to be locked. </P>
<P><I>LockLength</I> </P>
<P>Supplies the length of region in the file to be locked. </P>
<P><I>LockOwner</I> </P>
<P>Supplies the process id of the process requesting the lock. </P>
<P><I>pOpenFileInstance</I> </P>
<P>Supplies a pointer to the structure that describes the current open file instance. </P>
<P><I>fLockSemantics</I> </P>
<P>Supplies flags indicating what kind of locking semantics are operative. </P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="144pt" VALIGN="TOP"><COL WIDTH="190pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B>Lock Semantics Flags:</B> </P></TD><TD VALIGN="TOP"><P></P></TD></TR><TR><TD VALIGN="TOP"><P><B>Value </B></P></TD><TD VALIGN="TOP"><P><B>Meaning </B></P></TD></TR><TR><TD VALIGN="TOP"><P><B>LOCKF_DOS</B> </P></TD><TD VALIGN="TOP"><P>Indicates that DOS semantics are to be applied for the lock request. </P></TD></TR><TR><TD VALIGN="TOP"><P><B>LOCKF_NW</B> </P></TD><TD VALIGN="TOP"><P>Indicate that Netware semantics are to be applied for the lock request. </P></TD></TR><TR><TD VALIGN="TOP"><P><B>LOCKF_RD</B> </P></TD><TD VALIGN="TOP"><P>Indicates that a read lock should be taken. This value is allowed only with LOCKF_NW. DOS semantics do not have the concept of a read lock. </P></TD></TR><TR><TD VALIGN="TOP"><P><B>LOCKF_WR</B> </P></TD><TD VALIGN="TOP"><P>Indicates that a write lock should be taken. </P></TD></TR></TBODY></TABLE>
<P><BR></P><P></P>
<UL><LI>     Returns 0 if success, errorcode if failure. </LI></UL>
<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="144pt" VALIGN="TOP"><COL WIDTH="190pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><I>ppFSDLockListHead</I> </P></TD><TD VALIGN="TOP"><P>The lock list head stored in this variable might have been updated. </P></TD></TR></TBODY></TABLE>
<P><BR></P><P></P>
<P></P>
<P></P>
<P></P></FONT></BODY></HTML>
