<HTML><HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DVT</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">
<FONT FACE="verdana,arial,helvetica" SIZE="2">
<H3>DVT </H3><P><BR></P>
<PRE>#include &lt;dvt.h&gt;

typedef struct DVT {
    USHORT DVT_reserved_1;       // reserved for expansion to 32 bit
    ULONG  DVT_next_dvt;         // 16-bit offset to next DVT
    USHORT DVT_device_cnt;       // count of devices added/accepted
    PVOID  DVT_aer;              // addr of driver's async event routine
    ULONG  DVT_ddb;              // first DDB for this DVT
    ULONG  DVT_ddb_init;         // first DDB for this DVT/ICE
    CHAR   DVT_ascii_name[16];   // driver name
    CHAR   DVT_create_date[8];   // creation date
    CHAR   DVT_create_time[8];   // creation time
    CHAR   DVT_rev_level[4];     // revision level
    ULONG  DVT_feature_code;     // feature code
    USHORT DVT_if_requirements;  // i/f requirements
    BYTE   DVT_bus_type;         // I/O bus type; see below
    ULONG  DVT_reference_data;   // data passed in DRP upon reg
    CHAR   DVT_first_drive;      // unit number of first drive valid
                                 //  only for block devices
    CHAR   DVT_current_lgn;      // current load group number
    ULONG  DVT_LoadHandle;       // contains the VxD's load handle if
                                 //  we loaded the driver else 0
    CHAR   DVT_scsi_max_target;  // max target supported for SCSI
    CHAR   DVT_scsi_max_lun;     // max LUN supported for SCSI
    PVOID  DVT_entry_point;      // entry point into driver 
                                 //  SCSI miniport only
    UCHAR  DVT_init_count;       // # of successful AEP_INITIALIZE calls
                                 //  port drivers only
    PVOID  DVT_reserved[2];      // reserved; must be zero
} _DVT;
</PRE>
<P>Contains driver vector table information. The IOS creates a <B>DVT</B> structure for itself and then one for each driver during registration. The IOS's DVT provides a link to the first driver via the DVT_next_dvt member. The first driver can access the second driver's DVT via its DVT_next_dvt offset, and so on, providing a linked chain between the drivers' DVTs. Many of the members are set using values from the <B>DRP</B> structure provided by the driver. </P>
<P><B>DVT_bus_type</B> </P>
<P>Input and output bus type. Can be one of these values: </P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="144pt" VALIGN="TOP"><COL WIDTH="190pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>DVT_BT_ESDI </P></TD><TD VALIGN="TOP"><P>ESDI or ESDI emulator </P></TD></TR><TR><TD VALIGN="TOP"><P>DVT_BT_SCSI </P></TD><TD VALIGN="TOP"><P>SCSI or SCSI emulator </P></TD></TR><TR><TD VALIGN="TOP"><P>DVT_BT_FLOPPY </P></TD><TD VALIGN="TOP"><P>NEC FLOPPY or FLOPPY emulator </P></TD></TR><TR><TD VALIGN="TOP"><P>DVT_BT_SMART </P></TD><TD VALIGN="TOP"><P>Smart device </P></TD></TR><TR><TD VALIGN="TOP"><P>DVT_BT_ABIOS </P></TD><TD VALIGN="TOP"><P>ABIOS or ABIOS emulator </P></TD></TR></TBODY></TABLE>
<P><BR></P><P></P>
<P><B>DVT_feature_code</B> </P>
<P>Feature code; must match the feature code in the <B>DRP</B>. Can be a combination of these values: </P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="144pt" VALIGN="TOP"><COL WIDTH="190pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>DVT_FC_SCAN_DOWN </P></TD><TD VALIGN="TOP"><P>BIOS scans targets from high to low. </P></TD></TR><TR><TD VALIGN="TOP"><P>DVT_FC_IO_FOR_INQ_AEP </P></TD><TD VALIGN="TOP"><P>Port driver needs to send I/O through IOP in response to an AEP_DEVICE_INQUIRY function. Results in AEP_CONFIG_DCB function for inquiry DCB. </P></TD></TR><TR><TD VALIGN="TOP"><P>DVT_FC_HALF_SEC </P></TD><TD VALIGN="TOP"><P>Notify driver every half second. </P></TD></TR><TR><TD VALIGN="TOP"><P>DVT_FC_1_SEC </P></TD><TD VALIGN="TOP"><P>Notify driver every second. </P></TD></TR><TR><TD VALIGN="TOP"><P>DVT_FC_2_SECS </P></TD><TD VALIGN="TOP"><P>Notify driver every two seconds. </P></TD></TR><TR><TD VALIGN="TOP"><P>DVT_FC_4_SECS </P></TD><TD VALIGN="TOP"><P>Notify driver every four seconds. </P></TD></TR><TR><TD VALIGN="TOP"><P>DVT_FC_DYNALOAD </P></TD><TD VALIGN="TOP"><P>Driver was dynaloaded by the IOS. </P></TD></TR><TR><TD VALIGN="TOP"><P>DVT_FC_NEED_PRELOAD </P></TD><TD VALIGN="TOP"><P>Driver needs to hook I/O even before the port driver. When set, the AEP_CONFIG_DCB function is received before the prot driver. </P></TD></TR><TR><TD VALIGN="TOP"><P>DVT_FC_NEED_PRE_POST_LOAD </P></TD><TD VALIGN="TOP"><P>Same as DVT_FC_NEED_PRELOAD except that the driver receives two AEP_CONFIG_DCB calls for each DCB: one call before the port driver, and another call after layer drivers before its load group have been initialized. Note that care must be taken not to insert twice in the same DCB. </P></TD></TR></TBODY></TABLE>
<P><BR></P><P></P>
<P>See also <B>DRP</B>, <B>AEP</B> </P>
<P></P>
<P></P></FONT></BODY></HTML>
