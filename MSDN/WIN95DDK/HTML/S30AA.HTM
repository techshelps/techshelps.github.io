<HTML><HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>FS_FindFirstFile</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">
<FONT FACE="verdana,arial,helvetica" SIZE="2">
<H3>FS_FindFirstFile </H3><P><BR></P>
<PRE>FS_FindFirstFile(
 PIOREQ pir
 )
</PRE>
<P>A Win32 find first operation is performed through <B>FS_FindFirstFile</B>. A find context handle is created and is passed on <B>FS_FindNextFile</B> to continue the search. This routine handles the Win32 function: FindFirstFile() and the int 21h function 714Eh. </P>
<P><I>ir_ppath</I> </P>
<P>Supplies a pointer to the canonicalized unicode pathname that the search is to begin at. Wildcards are allowed on the pathname. </P>
<P><I>ir_rh</I> </P>
<P>Supplies handle to disk volume or network resource where the search is being done. </P>
<P><I>ir_attr</I> </P>
<P>Supplies must-match and search attributes. Path parsing flags are also provided as advisory information for the FSDs. </P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="144pt" VALIGN="TOP"><COL WIDTH="190pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B>Search Attribute Values:</B> </P>
<P>Any combination of the following attributes may be specified, causing those files to be included with normal files in the search. </P></TD><TD VALIGN="TOP"><P></P></TD></TR><TR><TD VALIGN="TOP"><P><B>Value </B></P></TD><TD VALIGN="TOP"><P><B>Meaning </B></P></TD></TR><TR><TD VALIGN="TOP"><P><B>FILE_ATTRIBUTE_HIDDEN</B> </P></TD><TD VALIGN="TOP"><P>Include hidden file in search. </P></TD></TR><TR><TD VALIGN="TOP"><P><B>FILE_ATTRIBUTE_SYSTEM</B> </P></TD><TD VALIGN="TOP"><P>Include system file in search. </P></TD></TR><TR><TD VALIGN="TOP"><P><B>FILE_ATTRIBUTE_DIRECTORY</B> </P></TD><TD VALIGN="TOP"><P>Include subdirectories in search. </P></TD></TR><TR><TD VALIGN="TOP"><P><B>FILE_ATTRIBUTE_VOLUMELABEL</B> </P></TD><TD VALIGN="TOP"><P>Search for volume label. </P></TD></TR><TR><TD VALIGN="TOP"><P><B>Must-Match Attribute Values:</B> </P>
<P>The must-match attributes can be any of the following attributes. </P></TD><TD VALIGN="TOP"><P></P></TD></TR><TR><TD VALIGN="TOP"><P><B>FILE_ATTRIBUTE_READONLY</B> </P></TD><TD VALIGN="TOP"><P>Match read-only files. </P></TD></TR><TR><TD VALIGN="TOP"><P><B>FILE_ATTRIBUTE_HIDDEN</B> </P></TD><TD VALIGN="TOP"><P>Match hidden files. </P></TD></TR><TR><TD VALIGN="TOP"><P><B>FILE_ATTRIBUTE_SYSTEM</B> </P></TD><TD VALIGN="TOP"><P>Match system files. </P></TD></TR><TR><TD VALIGN="TOP"><P><B>FILE_ATTRIBUTE_DIRECTORY</B> </P></TD><TD VALIGN="TOP"><P>Match subdirectories. </P></TD></TR><TR><TD VALIGN="TOP"><P><B>FILE_ATTRIBUTE_ARCHIVE</B> </P></TD><TD VALIGN="TOP"><P>Match archived files. </P></TD></TR><TR><TD VALIGN="TOP"><P><B>FILE_ATTRIBUTE_VOLUMELABEL</B> </P></TD><TD VALIGN="TOP"><P>Match volume label. </P></TD></TR><TR><TD VALIGN="TOP"><P><B>Path Parsing Flags:</B> </P>
<P>The following path parsing flags are passed in. </P></TD><TD VALIGN="TOP"><P></P></TD></TR><TR><TD VALIGN="TOP"><P><B>Value </B></P></TD><TD VALIGN="TOP"><P><B>Meaning </B></P></TD></TR><TR><TD VALIGN="TOP"><P><B>FILE_FLAG_WILDCARDS</B> </P></TD><TD VALIGN="TOP"><P>Wildcard characters present in pathname. </P></TD></TR><TR><TD VALIGN="TOP"><P><B>FILE_FLAG_HAS_STAR</B> </P></TD><TD VALIGN="TOP"><P>Path has the asterisk as a wildcard character. </P></TD></TR><TR><TD VALIGN="TOP"><P><B>FILE_FLAG_LONG_PATH</B> </P></TD><TD VALIGN="TOP"><P>Path has a longname component. </P></TD></TR><TR><TD VALIGN="TOP"><P><B>FILE_FLAG_KEEP_CASE</B> </P></TD><TD VALIGN="TOP"><P>Preserve the case of the filename passed in when storing on disk. This also implies that this call should use longname semantics for its processing. </P></TD></TR><TR><TD VALIGN="TOP"><P><B>FILE_FLAG_HAS_DOT</B> </P></TD><TD VALIGN="TOP"><P>Filename component has a dot in its name. </P></TD></TR><TR><TD VALIGN="TOP"><P><B>FILE_FLAG_IS_LFN</B> </P></TD><TD VALIGN="TOP"><P>Filename component is a longname. </P></TD></TR></TBODY></TABLE>
<P><BR></P><P></P>
<P><I>ir_uFname</I> </P>
<P>Pointer to the case-preserved filename component in unicode. </P>
<P><I>ir_upath</I> </P>
<P>Pointer to the unparsed user pathname in unicode. </P>
<P><I>ir_hfunc</I> </P>
<P>Supplies a pointer to a function pointer structure, containing a list of the FSD find file entry points. </P>
<P><I>ir_data</I> </P>
<P>Supplies a pointer to buffer where the find data for a file that is found is returned. </P>
<P><I>ir_sfn</I> </P>
<P>Supplies system file number. </P>
<P><I>ir_user</I> </P>
<P>Supplies user id for this request. </P>
<P><I>ir_pid</I> </P>
<P>Supplies process id for this request. </P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="144pt" VALIGN="TOP"><COL WIDTH="190pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>     <I>ir_error</I> </P></TD><TD VALIGN="TOP"><P>Returns status of the operation ( 0 if no error, errorcode otherwise ). </P></TD></TR><TR><TD VALIGN="TOP"><P><I>ir_fh</I> </P></TD><TD VALIGN="TOP"><P>Returns the FSD find context handle which is passed in by the IFS manager on subsequent calls to FS_FindNextFile and FS_FindClose. </P></TD></TR><TR><TD VALIGN="TOP"><P><I>ir_hfunc</I> </P></TD><TD VALIGN="TOP"><P>Returns a filled in function pointer structure, containing a list of the FSD find file entry points. The structure is filled in as follows: </P></TD></TR></TBODY></TABLE>
<P><BR></P><P></P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="144pt" VALIGN="TOP"><COL WIDTH="190pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B>Function Pointer Structure:</B> </P></TD><TD VALIGN="TOP"><P></P></TD></TR><TR><TD VALIGN="TOP"><P><B>Value </B></P></TD><TD VALIGN="TOP"><P><B>Meaning </B></P></TD></TR><TR><TD VALIGN="TOP"><P><I>hf_read</I> </P></TD><TD VALIGN="TOP"><P>Returns pointer to FS_FindNextFile function. </P>
<P></P></TD></TR><TR><TD VALIGN="TOP"><P><I>hf_write</I> </P></TD><TD VALIGN="TOP"><P>Function is not defined, FSD must return pointer to an error function. </P></TD></TR><TR><TD VALIGN="TOP"><P><I>hf_misc</I> </P></TD><TD VALIGN="TOP"><P>Returns a pointer to a function table structure, in the FSD, containing a list of the remaining FSD handle based file I/O entry points. </P></TD></TR></TBODY></TABLE>
<P><BR></P><P></P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="144pt" VALIGN="TOP"><COL WIDTH="190pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B>Function Table Structure:</B> </P></TD><TD VALIGN="TOP"><P></P></TD></TR><TR><TD VALIGN="TOP"><P><I>hm_version</I> </P></TD><TD VALIGN="TOP"><P>IFS version number. </P></TD></TR><TR><TD VALIGN="TOP"><P><I>hm_revision</I> </P></TD><TD VALIGN="TOP"><P>IFS interface revision number. </P></TD></TR><TR><TD VALIGN="TOP"><P><I>hm_size</I> </P></TD><TD VALIGN="TOP"><P>Number of function entry points in table. </P></TD></TR><TR><TD VALIGN="TOP"><P><I>hm_func[NUM_HNDLMISC]</I> </P></TD><TD VALIGN="TOP"><P>Returns an array of pointers to the handle-based functions as described below: </P></TD></TR><TR><TD VALIGN="TOP"><P><I>hm_func[HM_SEEK]</I> </P></TD><TD VALIGN="TOP"><P>Undefined function, must return pointer to an error function. </P></TD></TR><TR><TD VALIGN="TOP"><P><I>hm_func[HM_CLOSE]</I> </P></TD><TD VALIGN="TOP"><P>Returns pointer to FS_FindClose function. </P></TD></TR><TR><TD VALIGN="TOP"><P><I>hm_func[HM_COMMIT]</I> </P></TD><TD VALIGN="TOP"><P>Undefined function, must return pointer to an error function. </P></TD></TR><TR><TD VALIGN="TOP"><P><I>hm_func[HM_FILELOCKS]</I> </P></TD><TD VALIGN="TOP"><P>Undefined function, must return pointer to an error function. </P></TD></TR><TR><TD VALIGN="TOP"><P><I>hm_func[HM_FILETIMES]</I> </P></TD><TD VALIGN="TOP"><P>Undefined function, must return pointer to an error function. </P></TD></TR><TR><TD VALIGN="TOP"><P><I>hm_func[HM_PIPEREQUEST]</I> </P></TD><TD VALIGN="TOP"><P>Undefined function, must return pointer to an error function. </P></TD></TR><TR><TD VALIGN="TOP"><P><I>hm_func[HM_HANDLEINFO]</I> </P></TD><TD VALIGN="TOP"><P>Undefined function, must return pointer to an error function. </P></TD></TR><TR><TD VALIGN="TOP"><P><I>hm_func[HM_ENUMHANDLE]</I> </P></TD><TD VALIGN="TOP"><P>Returns a pointer to the FS_EnumerateHandle function. </P></TD></TR></TBODY></TABLE>
<P><BR></P><P></P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="144pt" VALIGN="TOP"><COL WIDTH="190pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><I>ir_data</I> </P></TD><TD VALIGN="TOP"><P>Returns find data for a file filled in the buffer in the following format if there was no error. </P></TD></TR></TBODY></TABLE>
<P><BR></P><P></P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="144pt" VALIGN="TOP"><COL WIDTH="190pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B>Find Data Structure:</B> </P></TD><TD VALIGN="TOP"><P></P></TD></TR><TR><TD VALIGN="TOP"><P>dwFileAttributes </P></TD><TD VALIGN="TOP"><P>Returns the file attributes of the file found. </P></TD></TR></TBODY></TABLE>
<P><BR></P><P></P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="144pt" VALIGN="TOP"><COL WIDTH="190pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B>Attribute Values:</B> </P>
<P>Any valid combination of the following attributes may be returned. </P></TD><TD VALIGN="TOP"><P></P></TD></TR><TR><TD VALIGN="TOP"><P><B>Value </B></P></TD><TD VALIGN="TOP"><P><B>Meaning </B></P></TD></TR><TR><TD VALIGN="TOP"><P><B>FILE_ATTRIBUTE_READONLY</B> </P></TD><TD VALIGN="TOP"><P>Read-Only file. </P></TD></TR><TR><TD VALIGN="TOP"><P><B>FILE_ATTRIBUTE_HIDDEN</B> </P></TD><TD VALIGN="TOP"><P>Hidden file. </P></TD></TR><TR><TD VALIGN="TOP"><P><B>FILE_ATTRIBUTE_SYSTEM</B> </P></TD><TD VALIGN="TOP"><P>System file. </P></TD></TR><TR><TD VALIGN="TOP"><P><B>FILE_ATTRIBUTE_DIRECTORY</B> </P></TD><TD VALIGN="TOP"><P>Subdirectory. </P></TD></TR><TR><TD VALIGN="TOP"><P><B>FILE_ATTRIBUTE_ARCHIVE</B> </P></TD><TD VALIGN="TOP"><P>Archive file. </P></TD></TR><TR><TD VALIGN="TOP"><P><B>FILE_ATTRIBUTE_VOLUMELABEL</B> </P></TD><TD VALIGN="TOP"><P>Volume label found. </P></TD></TR></TBODY></TABLE>
<P><BR></P><P></P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="144pt" VALIGN="TOP"><COL WIDTH="190pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>ftCreationTime </P></TD><TD VALIGN="TOP"><P>Returns the file creation time in the Win32 FileTime structure format. </P></TD></TR></TBODY></TABLE>
<P><BR></P><P></P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="144pt" VALIGN="TOP"><COL WIDTH="190pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B>Win32 FileTime Structure:</B> </P></TD><TD VALIGN="TOP"><P></P></TD></TR><TR><TD VALIGN="TOP"><P><B>Value </B></P></TD><TD VALIGN="TOP"><P><B>Meaning </B></P></TD></TR><TR><TD VALIGN="TOP"><P><I>dwLowDateTime</I> </P></TD><TD VALIGN="TOP"><P>Returns the low double word of the time in Win32 format. </P></TD></TR><TR><TD VALIGN="TOP"><P><I>dwHighDateTime</I> </P></TD><TD VALIGN="TOP"><P>Returns the high double word of the time in Win32 format. </P></TD></TR></TBODY></TABLE>
<P><BR></P><P></P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="144pt" VALIGN="TOP"><COL WIDTH="190pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><I>ftLastAccessTime</I> </P></TD><TD VALIGN="TOP"><P>Returns the file last access time in Win32 FileTime structure format defined above. </P></TD></TR><TR><TD VALIGN="TOP"><P><I>ftLastWriteTime</I> </P></TD><TD VALIGN="TOP"><P>Returns the file last write time in Win32 FileTime structure format defined above. </P></TD></TR><TR><TD VALIGN="TOP"><P><I>nFileSizeHigh</I> </P></TD><TD VALIGN="TOP"><P>Returns the high 32-bits of the file size. </P></TD></TR><TR><TD VALIGN="TOP"><P><I>nFileSizeLow</I> </P></TD><TD VALIGN="TOP"><P>Returns the low 32-bits of the file size. </P></TD></TR><TR><TD VALIGN="TOP"><P><I>cFileName</I> </P></TD><TD VALIGN="TOP"><P>Returns the unicode long filename that was found. </P></TD></TR><TR><TD VALIGN="TOP"><P><I>CAlternateFileName</I> </P></TD><TD VALIGN="TOP"><P>Returns the unicode alternate alias name (short file name) of the file that was found. </P></TD></TR></TBODY></TABLE>
<P><BR></P><P></P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="144pt" VALIGN="TOP"><COL WIDTH="190pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><I>ir_pos</I> </P></TD><TD VALIGN="TOP"><P>Returns the find resume key for this find next operation. The operation of this key is described below. </P></TD></TR></TBODY></TABLE>
<P><BR></P><P></P>
<P></P>
<P>Local FSDs need to return and also be able to take a find resume key as a parameter. This has been provided to optimize finds across the network by the server. The server typically does a bunch of find first/next operations and stores the information for each of them in a buffer, effectively providing some buffering on find next operations to prevent every find next operation from causing net traffic. However, the network redirector might discard or reuse the buffers if necessary and in that case, the find operation needs to be resumed at that point where a findnext buffer is not valid, which is different from the point at which the find next operation was stopped at the server machine. To facilitate this, the server passes in a find resume key to the IFS which is then passed in to the FSDs, so that they can throw away their current find next state and restart the find next at the point specified by the resume key. This means that the resume key must store enough information so that the find can be restarted at a particular point. For e.g., on a FAT filesystem, the find resume key could be a combination of the cluster number and the index within the cluster of the directory entry last found. This way, when the resume key is passed in, the find next can be restarted at the correct spot. This does not need to be done by network FSDs, it is only local FSDs that handle drives that can be shared that need to implement this functionality. </P>
<P>This api should use LFN matching semantics for its operations only if either or both the FILE_FLAG_KEEP_CASE and FILE_FLAG_IS_LFN are set. The FSD should not assume that this api will always use LFN matching semantics by default. These flags are passed in by the IFS to indicate that LFN matching semantics need to be used. By default, this api will have LFN matching semantics. However, there are certain special cases, such as on the peer server, where a call that comes in via an LFN api still needs shortname matching semantics. If the FSD does not support LFNs on the volume, it should return an error on this function. </P>
<P></P>
<P></P></FONT></BODY></HTML>
