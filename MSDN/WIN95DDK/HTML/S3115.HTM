<HTML><HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>IFSMgr_LockFile</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">
<FONT FACE="verdana,arial,helvetica" SIZE="2">
<H3>IFSMgr_LockFile </H3><P><BR></P>
<PRE>IFSMgr_LockFile(
 void ** ppFSDLockListHead,
 unsigned long LockOffset,
 unsigned long LockLength,
 unsigned long LockOwner,
 void * pOpenFileInstance,
 unsigned long fLockSemantics
 )
</PRE>
<P>This service locks a region of an open file. This service supports two kinds of locking semantics: DOS and Netware. DOS semantics do not allow overlapping locks and a lock prevents any access to that region of the file by another process. On the other hand, Netware's locking semantics provides for overlapping read locks and non-overlapping write locks. It also has the concept of lock promotion of a read lock to a write lock and vice versa. For more details on the Netware locking semantics, please refer to the appropriate Netware documentation. </P>
<P><I>ppFSDLockListHead</I> </P>
<P>Supplies a pointer to a variable that is to contain the pointer to the list of locks. </P>
<P><I>LockOffset</I> </P>
<P>Supplies the starting offset in the file of the region to be locked. </P>
<P><I>LockLength</I> </P>
<P>Supplies the length of region in the file to be locked. </P>
<P><I>LockOwner</I> </P>
<P>Supplies the process id of the process requesting the lock. </P>
<P><I>pOpenFileInstance</I> </P>
<P>Supplies a pointer to the structure that describes the current open file instance. </P>
<P><I>fLockSemantics</I> </P>
<P>Supplies flags indicating what kind of locking semantics are operative. </P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="144pt" VALIGN="TOP"><COL WIDTH="190pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B>Lock Semantics Flags:</B> </P></TD><TD VALIGN="TOP"><P></P></TD></TR><TR><TD VALIGN="TOP"><P><B>Value </B></P></TD><TD VALIGN="TOP"><P><B>Meaning </B></P></TD></TR><TR><TD VALIGN="TOP"><P><B>LOCKF_DOS</B> </P></TD><TD VALIGN="TOP"><P>Indicates that DOS semantics are to be applied for the lock request. </P></TD></TR><TR><TD VALIGN="TOP"><P><B>LOCKF_NW</B> </P></TD><TD VALIGN="TOP"><P>Indicate that Netware semantics are to be applied for the lock request. </P></TD></TR><TR><TD VALIGN="TOP"><P><B>LOCKF_RD</B> </P></TD><TD VALIGN="TOP"><P>Indicates that a read lock should be taken. This value is allowed only with LOCKF_NW. DOS semantics do not have the concept of a read lock. </P></TD></TR><TR><TD VALIGN="TOP"><P><B>LOCKF_WR</B> </P></TD><TD VALIGN="TOP"><P>Indicates that a write lock should be taken. </P></TD></TR></TBODY></TABLE>
<P><BR></P><P></P>
<UL><LI>     Returns 0 if success, errorcode if failure. </LI></UL>
<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="144pt" VALIGN="TOP"><COL WIDTH="190pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><I>ppFSDLockListHead</I> </P></TD><TD VALIGN="TOP"><P>The pointer to the lock list is stored in this variable on a successful return. </P></TD></TR></TBODY></TABLE>
<P><BR></P><P></P>
<P></P>
<P>The IFS manager maintains a list of active locks on the file. The head of this list is stored in the variable pointed to by <I>ppFSDLockListHead</I>. The FSD should not attempt to interpret this list in any fashion, it is only for use by the IFS manager. Typically, the head for the list of locks would be a part of the open file information structure and would be maintained on a per-open-file basis. All locks on this open file are part of this list, irrespective of which process and which open file instance they belong to. </P>
<P></P>
<P></P></FONT></BODY></HTML>
