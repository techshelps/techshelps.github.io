<HTML><HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>About Breakpoints and Callbacks</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">
<FONT FACE="verdana,arial,helvetica" SIZE="2">
<H2>About Breakpoints and Callbacks </H2><P>Breakpoints and callbacks provide a mechanism for transferring control from ring 3 to ring 0 in a controlled manner. </P>
<P>Callbacks are typically given by VxDs to applications so that the application can call back into the VxD as part of a service request. The application performs a far call indirect to the callback address. VMM will perform a Simulate_Far_Return before dispatching the callback to the VxD that installed it. The VxD typically inspects and/or modifies client registers, then returns. Execution then resumes in the application at the instruction following the "call far". </P>
<P>Breakpoints are typically installed by a VxD into existing V86-mode code that needs to be patched. When execution reaches the breakpoint, VMM dispatches the breakpoint directly to the VxD that installed it. The VxD typically inspects and/or modifies client registers, then moves the client (E)IP register past the breakpoint so as to resume execution. Note that, unlike callbacks, it is the VxD's responsibility to adjust the client (E)IP register to point to the location where execution should resume when servicing of the breakpoint is complete. If you forget to do this, the breakpoint will merely be hit again immediately. </P>
<P>Since there are no facilities for freeing breakpoints or callbacks, they should be treated as scarce resources. Dynamically-loaded VxDs which allocate callbacks should save the callback in a static data segment so a new callback is not allocated each time the VxD is loaded. </P>
<P></P>
<P><B>Note </B></P>
<P>Breakpoints are supported only for V86-mode code. Moreover, protected-mode callbacks are not supported from a Win32 application. If a Win32 application needs to communicate with a VxD, it must use the DeviceIoControl mechanism. </P>
<P></P>
<P>There are the following break point and callback services: </P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="144pt" VALIGN="TOP"><COL WIDTH="204pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B>Service </B></P></TD><TD VALIGN="TOP"><P><B>Description </B></P></TD></TR><TR><TD VALIGN="TOP"><P><B>Allocate_V86_Call_Back</B> </P></TD><TD VALIGN="TOP"><P>Allocates a V86-mode callback. </P></TD></TR><TR><TD VALIGN="TOP"><P><B>Allocate_PM_Call_Back</B> </P></TD><TD VALIGN="TOP"><P>Allocates a protected-mode callback. </P></TD></TR><TR><TD VALIGN="TOP"><P><B>Call_When_VM_Returns</B> </P></TD><TD VALIGN="TOP"><P>Installs a return-from-interrupt callback. </P></TD></TR><TR><TD VALIGN="TOP"><P><B>Install_V86_Break_Point</B> </P></TD><TD VALIGN="TOP"><P>Installs a breakpoint callback. </P></TD></TR><TR><TD VALIGN="TOP"><P><B>Remove_V86_Break_Point</B> </P></TD><TD VALIGN="TOP"><P>Removes a V86 breakpoint. </P></TD></TR></TBODY></TABLE>
<P><BR></P><P></P></FONT></BODY></HTML>
