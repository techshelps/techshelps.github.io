<HTML><HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>List_Allocate</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">
<FONT FACE="verdana,arial,helvetica" SIZE="2">
<H3>List_Allocate </H3><P><BR></P>
<PRE>include vmm.inc

mov     esi, List       ; list handle
VMMcall List_Allocate

jc      not_allocated   ; carry flag set if error
mov     [Node], eax     ; address of new node
</PRE>
<P>Allocates a new node for the specified list. A virtual device can attach the new node to the list using the <B>List_Attach, List_Attach_Tail</B> or <B>List_Insert</B> service. The contents of the new node are undefined. Uses EAX, Flags. </P>
<UL><LI>     Returns with the carry flag clear and the address of the new node in the EAX register if successful. For lists created using the LF_Alloc_Error value, the service returns with the carry flag set if a node cannot be allocated. For other lists, the service does not return if a node cannot be allocated. (It crashes the current virtual machine instead.) </LI></UL><P></P>
<P><I>List</I> </P>
<P>Handle of the list. </P>
<P>If the list is created using the LF_Use_Heap value, this service calls the <B>_HeapAllocate</B> service for each node, in which case all the rules regarding heap access apply to <B>List_Allocate</B> as well. </P>
<P>Otherwise, the service allocates nodes from a pool of free nodes. This avoids the overhead of calling the <B>_HeapAllocate</B> service for every node allocation. This non-reliance on <B>_HeapAllocate</B> has both positive and negative consequences. On the positive side, it means that <B>List_Allocate</B> can be called at times when <B>_HeapAllocate</B> cannot be called, such as during hardware interrupts. On the negative side, this means that if the VMM cannot satisfy the allocation request from its pool of free nodes, it cannot obtain more memory from the heap because it might not be safe to call <B>_HeapAllocate</B> at the time the call to <B>List_Allocate</B> made. VMM maintains an emergency pool of memory into which it can dip when faced with this situation. The emergency pool is refreshed from the system heap at a time when <B>_HeapAllocate</B> is safe to call. </P>
<P>The consequence of this tradeoff is that virtual devices should not allocate large numbers of nodes in rapid succession from lists not marked LF_Use_Heap, because that would dry up the free list and emergency pool, causing <B>List_Allocate</B> to fail. </P>
<P>See also <B>List_Attach</B>, <B>List_Attach_Tail</B>, <B>List_Create</B>, <B>List_Deallocate</B>, <B>List_Insert</B> </P>
<P></P>
<P></P></FONT></BODY></HTML>
