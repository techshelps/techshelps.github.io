<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>IMarshal - Default Implementation</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_com_imarshal_default_implementation"></a>IMarshal - Default Implementation</h1>
<p>
COM uses its own internal implementation of the <a href="if_f2n_6sh8.htm"><b>IMarshal</b></a> interface to marshal any object that does not provide its own implementation. COM makes this determination by querying the object for <b>IMarshal</b>. If the interface is missing, COM defaults to its internal implementation.</p>
<p>
COM's default implementation of <b>IMarshal</b> uses a generic proxy for each object, and creates individual stubs and proxies, as they are needed, for each interface implemented on the object. This mechanism is necessary because COM cannot know in advance what particular interfaces a given object may implement. Developers who do not use COM's default marshaling, electing instead to write their own proxy and marshaling routines, know at compile time all the interfaces to be found on their objects and therefore understand exactly what marshaling code is required. COM, in providing marshaling support for all objects, must do so at run time.</p>
<p>
The <i>interface proxy</i> resides in the client process; the <i>interface stub</i>, in the server. Together, each pair handles all marshaling for its interface. The job of each <i>interface proxy</i> is to marshal arguments and unmarshal return values and out parameters that are passed back and forth in subsequent calls to its interface. The job of each <i>interface stub</i> is to unmarshal function arguments and pass them along to the original object, then marshal the return values and out parameters that the object returns.</p>
<p>
Proxy and stub communicate by means of an RPC (remote procedure call) channel, which utilizes the system's RPC infrastructure for interprocess communication. The RPC channel implements a single interface <b>IRpcChannelBuffer,</b> an internal interface to which both interface proxies and stubs hold a pointer. The proxy and stub call the interface to obtain a marshaling packet, send the data to their counterpart, and destroy the packet when they are done. The interface stub also holds a pointer to the original object.</p>
<p>
For any given interface, the proxy and stub are both implemented as instances of the same class, which is listed for each interface in the system registry under the label <i>ProxyStubClsid32 </i>(or <i>ProxyStubClsid</i> on 16-bit systems). This entry maps the interface's IID to the CLSID of its proxy and stub objects. When COM needs to marshal an interface, it looks in the system registry to obtain the appropriate CLSID. The server identified by this CLSID implements both the interface proxy and interface stub.</p>
<p>
Most often, the class to which this CLSID refers is automatically generated by a tool whose input is a description of the function signatures and semantics of a given interface, written in some interface description language. While using such a language is highly recommended and encouraged for accuracy's sake, doing so is by no means required. Proxies and stubs are merely Component Object Model components used by the RPC infrastructure and, as such, can be written in any manner desired so long as the correct external contracts are upheld. The programmer who designs a new interface is responsible for ensuring that all interface proxies and stubs that ever exist agree on the representation of their marshaled data.</p>
<p>
When created, interface proxies are always aggregated into a larger proxy, which represents the object as a whole. This object proxy also aggregates COM's generic proxy object, which is known as the <i>proxy manager</i>. The proxy manager implements two interfaces: <a href="if_r2z_9dwu.htm"><b>IUnknown</b></a> and <b>IMarshal.</b> All of the other interfaces that may be implemented on an object are exposed in its object proxy through the aggregation of individual interface proxies. A client holding a pointer to the object proxy "believes" it holds a pointer to the actual object.</p>
<p>
A proxy representing the object as a whole is required in the client process so that a client can distinguish calls to the same interfaces implemented on entirely different objects. Such a requirement does not exist in the server process, however, where the object itself resides, because all interface stubs communicate only with the objects for which they were created. No other connection is possible.</p>
<p>
Interface stubs, by contrast with interface proxies, are not aggregated, because there is no need that they appear to some external client to be part of a larger whole. When connected, an interface stub is given a pointer to the server object to which it should forward method invocations that it receives. Although it is useful to refer conceptually to a "stub manager," meaning whatever pieces of code and state in the server-side RPC infrastructure that service the remoting of a given object, there is no direct requirement that the code and state take any particular, well-specified form.</p>
<p>
The first time a client requests a pointer to an interface on a particular object, COM loads an <a href="if_a2e_9mk9.htm"><b>IClassFactory</b></a> stub in the server process and uses it to marshal the first pointer back to the client. In the client process, COM loads the generic proxy for the class factory object and calls its implementation of <b>IMarshal</b> to unmarshal that first pointer. COM then creates the first interface proxy and hands it a pointer to the RPC channel. Finally, COM returns the <b>IClassFactory</b> pointer to the client, which uses it to call <a href="if_a2e_5k11.htm"><b>IClassFactory::CreateInstance</b></a>, passing it a reference to the interface.</p>
<p>
Back in the server process, COM now creates a new instance of the object, along with a stub for the requested interface. This stub marshals the interface pointer back to the client process, where another object proxy is created, this time for the object itself. Also created is a proxy for the requested interface, a pointer to which is returned to the client. With subsequent calls to other interfaces on the object, COM will load the appropriate interface stubs and proxies as needed.</p>
<p>
When a new interface proxy is created, COM hands it a pointer to the proxy manager's implementation of <b>IUnknown</b>, to which it delegates all <b>QueryInterface</b> calls. Each interface proxy implements two interfaces of its own: the interface it represents and<b> IRpcProxyBuffer</b>. The interface proxy exposes its own interface directly to clients, which can obtain its pointer by calling <b>QueryInterface</b> on the proxy manager. Only COM, however, can call <b>IRpcProxyBuffer,</b> which it uses to connect and disconnect the proxy to the RPC channel. A client cannot query an interface proxy to obtain a pointer to the <b>IRpcProxyBuffer</b> interface.</p>
<p>
On the server side, each interface stub implements <b>IRpcStubBuffer</b>, an internal interface. The server code acting as a stub manager calls <b>IRpcStubBuffer::Connect</b> and passes the interface stub the <b>IUnknown</b> pointer of its object.</p>
<p>
When an interface proxy receives a method invocation, it obtains a marshaling packet from its RPC channel through a call to <b>IRpcChannelBuffer::GetBuffer</b>. The process of marshaling the arguments will copy data into the buffer. When marshaling is complete, the interface proxy invokes <b>IRpcChannelBuffer::SendReceive</b> to send the marshaled packet to the corresponding interface stub. When <b>IRpcChannelBuffer::SendReceive</b> returns, the buffer into which the arguments were marshaled will have been replaced by a new buffer containing the return values marshaled from the interface stub. The interface proxy unmarshals the return values, invokes <b>IRpcChannelBuffer::FreeBuffer</b> to free the buffer, then returns the return values to the original caller of the method.</p>
<p>
It is the implementation of <b>IRpcChannelBuffer::SendReceive</b> that actually sends the request to the server process and that knows how to identify the server process and, within that process, the object to which the request should be sent. The channel implementation also knows how to forward the request on to the appropriate stub manager in that process. The interface stub unmarshals the arguments from the provided buffer, invokes the indicated method on the server object, and marshals the return values back into a new buffer, allocated by a call to <b>IRpcchannelBuffer::GetBuffer</b>. The channel then transmits the return data packet back to the interface proxy, which is still in the middle of <b>IRpcchannelBuffer::SendReceive</b>, which returns to the interface proxy.</p>
<p>
A particular instance of an interface proxy can be used to service more than one interface, so long as two conditions are met. First, the IIDs of the affected interfaces must be mapped to the the appropriate <i>ProxyStubClsid</i> in the system registry. Second, the interface proxy must support calls to <b>QueryInterface</b> from one supported interface to the other interfaces, as usual, as well as from <b>IUnknown</b> and <b>IRpcProxyBuffer</b>.</p>
<p>
A single instance of an interface stub can also service more than one interface, but only if that set of interfaces has a strict single-inheritance relationship. This restriction exists because the stub can direct method invocations to multiple interfaces only where it knows in advance which methods are implemented on which interfaces.</p>
<p>
Both proxies and stubs will at various times have need to allocate or free memory. Interface proxies, for example, will need to allocate memory in which to return out parameters to their caller. In this respect, interface proxies and interface stubs are just normal COM components, in that they should use the standard task allocator (see <a href="api1_2qlf.htm"><b>CoGetMalloc</b></a><b>)</b>.</p>
<h5>When to Use</h5>
<p>
You should use COM's default implementation of <b>IMarshal</b> except in those very few cases where your application has special requirements that COM's default implementation does not address, or where you can achieve optimizations over the marshaling code COM has provided. For examples of such special cases, see <b>IMarshal</b>, "When to Implement."</p>
<h4>See Also</h4>
<p>
<a href="if_f2n_6sh8.htm"><b>IMarshal</b></a> </p>
<p>
</p>
<p>
</p>
<p>&nbsp;</p></body>
</HTML>
