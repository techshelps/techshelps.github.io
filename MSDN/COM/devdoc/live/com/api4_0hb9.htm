<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>StgOpenStorage</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_com_stgopenstorage"></a>StgOpenStorage</h1>
<p>
Opens an existing root storage object in the file system. You can use this function to open compound files, but you cannot use it to open directories, files, or summary catalogs. Nested storage objects can only be opened using their parent's <a href="if_r2z_182t.htm"><b>IStorage::OpenStorage</b></a><b> </b>method.</p>
<pre><code><b>HRESULT StgOpenStorage(
  const WCHAR *</b><i> pwcsName</i><b>,</b>   //Points to the path of the file 
                            // containing storage object
<b>  IStorage *</b><i> pstgPriority</i><b>,</b>   //Points to a previous opening of a 
                             // root storage object
<b>  DWORD</b><i> grfMode</i><b>,</b>         //Specifies the access mode for the object
<b>  SNB</b><i> snbExclude</i><b>,</b>        //Points to an SNB structure specifying 
                         // elements to be excluded
<b>  DWORD</b><i> reserved</i><b>,</b>        //Reserved; must be zero
<b>  IStorage **</b><i> ppstgOpen  </i>//Address of output variable that receives 
                         // the IStorage interface pointer
<b>);</b>
 </code></pre>
<h4>Parameters</h4>
<dl>
<dt>
<i>pwcsName</i></dt>
<dd>
[in] Points to the path of the file containing the storage object to open. This parameter is ignored if the <i>pStgPriority</i> parameter is not NULL.</dd>
<dt>
<i>pstgPriority</i></dt>
<dd>
[in] Most often NULL. If not NULL, this parameter is used instead of the <i>pwcsName</i> parameter to specify the pointer to the <b>IStorage</b> interface on the storage object to open. It points to a previous opening of a root storage object, most often one that was opened in priority mode.
<p>
After the <b>StgOpenStorage </b>function returns, the storage object specified in the <i>pStgPriority</i> parameter on function entry is invalid, and can no longer be used. Instead, use the one specified in the <i>ppStgOpen</i> parameter instead.
</dd>
<dt>
 </dt>
<dt>
<i>grfMode</i></dt>
<dd>
[in] Specifies the access mode to use to open the storage object.</dd>
<dt>
<i>snbExclude</i></dt>
<dd>
[in] If not NULL, this parameter points to a block of elements in the storage that are to be excluded as the storage object is opened. The exclusion occurs independent of whether a snapshot copy happens on the open. May be NULL.</dd>
<dt>
 </dt>
<dt>
<i>reserved</i></dt>
<dd>
[in] Indicates reserved for future use; must be zero.</dd>
<dt>
<i>ppstgOpen</i></dt>
<dd>
[out] Address of <b>IStorage</b>* pointer variable that receives the interface pointer to the opened storage.</dd>
</dl>
<h4>Return Values</h4>
<dl>
<dt>
S_OK</dt>
<dd>
Indicates the storage object was successfully opened.</dd>
<dt>
STG_E_FILENOTFOUND</dt>
<dd>
Indicates the specified file does not exist.</dd>
<dt>
STG_E_ACCESSDENIED</dt>
<dd>
Access denied because the caller has insufficient permission, or another caller has the file open and locked.</dd>
<dt>
STG_E_LOCKVIOLATION</dt>
<dd>
Access denied because another caller has the file open and locked.</dd>
<dt>
STG_E_SHAREVIOLATION</dt>
<dd>
Access denied because another caller has the file open and locked.</dd>
<dt>
STG_E_FILEALREADYEXISTS</dt>
<dd>
Indicates the file exists but is not a storage object.</dd>
<dt>
STG_E_TOOMANYOPENFILES</dt>
<dd>
Indicates the storage object was not opened because there are too many open files.</dd>
<dt>
STG_E_INSUFFICIENTMEMORY</dt>
<dd>
Indicates the storage object was not opened due to a lack of memory.</dd>
<dt>
STG_E_INVALIDNAME</dt>
<dd>
Indicates bad name in the <i>pwcsName</i> parameter.</dd>
<dt>
STG_E_INVALIDPOINTER</dt>
<dd>
Indicates bad pointer in one of the parameters: <i>snbExclude</i>, <i>pwcsName</i>, <i>pstgPriority</i>, or <i>ppStgOpen</i>.</dd>
<dt>
STG_E_INVALIDFLAG</dt>
<dd>
Indicates bad flag combination in the <i>grfMode</i> parameter.</dd>
<dt>
STG_E_INVALIDFUNCTION</dt>
<dd>
Indicates STGM_DELETEONRELEASE specified in the <i>grfMode</i> parameter.</dd>
<dt>
STG_E_OLDFORMAT</dt>
<dd>
Indicates the storage object being opened was created by the Beta 1 storage provider. This format is no longer supported.</dd>
<dt>
STG_E_NOTSIMPLEFORMAT</dt>
<dd>
Indicates that the STGM_SIMPLE flag was specified in the <i>grfMode </i>parameter and the storage object being opened was not written in simple mode.</dd>
<dt>
STG_E_OLDDLL</dt>
<dd>
Indicates the DLL being used to open this storage object is a version prior to the one used to create it.</dd>
<dt>
STG_E_PATHNOTFOUND</dt>
<dd>
Specified path does not exist.</dd>
</dl>
<p>
This function can also return any file system errors or Win32 errors wrapped in an HRESULT.</p>
<h4>Remarks</h4>
<p>
The <b>StgOpenStorage</b> function opens the specified root storage object according to the access mode in the <i>grfMode</i> parameter, and, if successful, supplies an <b>IStorage</b> pointer to the opened storage object in the <i>ppstgOpen</i> parameter.</p>
<p>
To support the Simple mode for saving a storage object with no substorages, the <b>StgOpenStorage</b> function accepts the following flag combinations as valid modes in the <i>grfMode</i> parameter: STGM_SIMPLE|STGM_READWRITE|STGM_SHARE_EXCLUSIVE and STGM_SIMPLE|STGM_READ|STGM_SHARE_EXCLUSIVE.</p>
<p>
</p>
<p>
To support the single-writer, multi-reader, direct mode, the following flag combinations are valid modes in the <i>grfMode</i> parameter: STGM_READWRITE|STGM_SHARE_DENY_WRITE and STGM_READ|STGM_SHARE_DENY_NONE.</p>
<p>
</p>
<p>
</p>
<p>
</p>
<p>
</p>
<p>
<b>Note</b>&nbsp;&nbsp;Opening a storage object in read and/or write mode without denying writer permission to others (the <i>grfMode</i> parameter specifies STGM_SHARE_DENY_WRITE) can be a time-consuming operation since the <b>StgOpenStorage</b> call must make a snapshot of the entire storage object.</p>
<p>
Applications often try to open storage objects with the following access permissions:</p>
<pre><code>STGM_READ_WRITE | STGM_SHARE_DENY_WRITE 
    // transacted vs. direct mode omitted for exposition 
 </code></pre>
<p>
If the application succeeds, it never needs to do a snapshot copy. If it fails, the application can revert to using the permissions and make a snapshot copy:</p>
<pre><code>STGM_READ_WRITE 
    // transacted vs. direct mode omitted for exposition 
 </code></pre>
<p>
In this case, the application should prompt the user before doing a time-consuming copy. Alternatively, if the document sharing semantics implied by the access modes are appropriate, the application could try to open the storage as follows:</p>
<pre><code>STGM_READ | STGM_SHARE_DENY_WRITE 
    // transacted vs. direct mode omitted for exposition 
 </code></pre>
<p>
In this case, if the application succeeds, a snapshot copy will not have been made (because STGM_SHARE_DENY_WRITE was specified, denying others write access).</p>
<p>
To reduce the expense of making a snapshot copy, applications can open storage objects in priority mode (<i>grfMode</i> specifies STGM_PRIORITY).</p>
<p>
The <i>snbExclude</i> parameter specifies a set of element names in this storage object that are to be emptied as the storage object is opened: streams are set to a length of zero; storage objects have all their elements removed. By excluding certain streams, the expense of making a snapshot copy can be significantly reduced. Almost always, this approach is used after first opening the storage object in priority mode, then completely reading the now-excluded elements into memory. This earlier priority mode opening of the storage object should be passed through the <i>pstgPriority</i> parameter to remove the exclusion implied by priority mode. The calling application is responsible for rewriting the contents of excluded items before committing. Thus, this technique is most likely only useful to applications whose documents do not require constant access to their storage objects while they are active.</p>
<p>
<b>Windows CE:</b> Passing into this function any invalid and, under some circumstances, NULL pointers will result in unexpected termination of the application. For more information about handling exceptions, see Programming Considerations.</p>
<h4>QuickInfo</h4>
<p>
<b>&nbsp;&nbsp;Windows NT: </b>Use version 3.1 or later.<br>
<b>&nbsp;&nbsp;Windows: </b>Use Windows 95 or later.<br>
<b>&nbsp;&nbsp;Windows CE: </b>Use version 2.0 or later.<br>
<b>&nbsp;&nbsp;Header: </b>Declared in objbase.h.<br>
<b>&nbsp;&nbsp;Import Library: </b>Use ole32.lib.</p>
<h4>See Also</h4>
<p>
<a href="if_r2z_9b8l.htm"><b>IStorage</b></a>, <a href="api4_8hd1.htm"><b>StgCreateDocfile</b></a>, <a href="api4_9x2w.htm"><b>StgOpenStorageEx</b></a> </p>
<p>
</p>
<p>
</p>
<p>&nbsp;</p></body>
</HTML>
