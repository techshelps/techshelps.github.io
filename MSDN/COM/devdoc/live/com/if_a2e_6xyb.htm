<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>IDataObject::EnumFormatEtc</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h2><a name="_com_idataobject_enumformatetc"></a>IDataObject::EnumFormatEtc</h2>
<p>
Creates an object for enumerating the <a href="structs_14v7.htm"><b>FORMATETC</b></a> structures for a data object. These structures are used in calls to <a href="if_a2e_1jz5.htm"><b>IDataObject::GetData</b></a> or <a href="if_a2e_438h.htm"><b>IDataObject::SetData</b></a>. </p>
<pre><code><b>HRESULT EnumFormatEtc(
  DWORD</b><i> dwDirection</i><b>,  </b>//Specifies a value from the enumeration 
                      // DATADIR
<b>  IEnumFORMATETC **</b><i> ppenumFormatetc</i>
<i>                      </i>//Address of output variable that receives the 
                      // IEnumFORMATETC interface pointer
<b>);</b>
 </code></pre>
<h4>Parameters</h4>
<dl>
<dt>
<i>dwDirection</i></dt>
<dd>
[in] Direction of the data through a value from the enumeration<b> <a href="enums_2oxe.htm">DATADIR</a></b>. 
<pre><code>typedef enum tagDATADIR 
{ 
    DATADIR_GET = 1, 
    DATADIR_SET = 2, 
} DATADIR; 
 </code></pre>

<p>
The value DATADIR_GET enumerates the formats that can be passed in to a call to <a href="if_a2e_1jz5.htm"><b>IDataObject::GetData</b></a>. The value DATADIR_SET enumerates those formats that can be passed in to a call to <a href="if_a2e_438h.htm"><b>IDataObject::SetData</b></a>.
</dd>
<dt>
<i>ppenumFormatetc</i></dt>
<dd>
[out] Address of <b>IEnumFORMATETC</b>* pointer variable that receives the interface pointer to the new enumerator object.
</dd>
</dl>
<h4>Return Values</h4>
<p>
This method supports the standard return values E_INVALIDARG and E_OUTOFMEMORY, as well as the following: 
<dl>
<dt>
S_OK</dt>
<dd>
Enumerator object was successfully created.</dd>
<dt>
E_NOTIMPL</dt>
<dd>
The direction specified by <i>dwDirection</i> is not supported.</dd>
<dt>
OLE_S_USEREG</dt>
<dd>
Requests that OLE enumerate the formats from the registry.
</dd>
</dl>
<h4>Remarks</h4>
<p>
<b>IDataObject::EnumFormatEtc</b> creates an enumerator object that can be used to determine all of the ways the data object can describe data in a <a href="structs_14v7.htm"><b>FORMATETC</b></a> structure, and supplies a pointer to its <a href="if_a2e_7kyr.htm"><b>IEnumFORMATETC</b></a> interface. This is one of the standard enumerator interfaces. </p>
<h5>Notes to Callers</h5>
<p>
Having obtained the pointer, the caller can enumerate the FORMATETC structures by calling the enumeration methods of <b>IEnumFORMATETC</b>. Because the formats can change over time, there is no guarantee that an enumerated format is currently supported because the formats can change over time. Accordingly, applications should treat the enumeration as a hint of the format types that can be passed. The caller is responsible for calling <b>IEnumFormatEtc::Release</b> when it is finished with the enumeration. </p>
<p>
<b>IDataObject::EnumFormatEtc</b> is called when one of the following actions occurs:
<ul>
<li>
An application calls <a href="api3_55r8.htm"><b>OleSetClipboard</b></a>. OLE must determine what data to place on the Clipboard and whether it is necessary to put OLE 1 compatibility formats on the Clipboard.</li>
<li>
Data is being pasted from the Clipboard or dropped. An application uses the first acceptable format.</li>
<li>
The Paste Special dialog box is displayed. The target application builds the list of formats from the <a href="structs_14v7.htm"><b>FORMATETC</b></a> entries.</li>
</ul>
<h5>Notes to Implementers</h5>
<p>
Formats can be registered statically in the registry or dynamically during object initialization. If an object has an unchanging list of formats and these formats are registered in the registry, OLE provides an implementation of a FORMATETC enumeration object that can enumerate formats registered under a specific CLSID in the registry. A pointer to its <b>IEnumFORMATETC</b> interface is available through a call to the helper function <a href="api3_2kmb.htm"><b>OleRegEnumFormatEtc</b></a>. In this situation, therefore, you can implement the <b>EnumFormatEtc</b> method simply with a call to this function. </p>
<p>
EXE applications can effectively do the same thing by implementing the method to return the value OLE_S_USEREG. This return value instructs the default object handler to call <b>OleRegEnumFormatEtc</b>. Object applications that are implemented as DLL object applications cannot return OLE_S_USEREG, so must call <b>OleRegEnumFormatEtc</b> directly.</p>
<p>
Private formats can be enumerated for OLE 1 objects, if they are registered with the RequestDataFormats or SetDataFormats keys in the registry. Also, private formats can be enumerated for OLE objects (all versions after OLE 1), if they are registered with the GetDataFormats or SetDataFormats keys.</p>
<p>
For OLE 1 objects whose servers do not have RequestDataFormats or SetDataFormats information registered in the registry, a call to <b>IDataObject::EnumFormatEtc</b> passing DATADIR_GET only enumerates the Native and Metafile formats, regardless of whether they support these formats or others. Calling <b>EnumFormatEtc</b> passing DATADIR_SET on such objects only enumerates Native, regardless of whether the object supports being set with other formats.</p>
<p>
The<b> <a href="structs_14v7.htm">FORMATETC</a></b> structure returned by the enumeration usually indicates a NULL target device (<i>ptd</i>). This is appropriate because, unlike the other members of <b>FORMATETC</b>, the target device does not participate in the object's decision as to whether it can accept or provide the data in either a <b>SetData</b> or <b>GetData</b> call.</p>
<p>
The <a href="enums_986c.htm">TYMED</a> member of <b>FORMATETC </b>often indicates that more than one kind of storage medium is acceptable. You should always mask and test for this by using a Boolean OR operator.</p>
<h4>QuickInfo</h4>
<p>
<b>&nbsp;&nbsp;Windows NT: </b>Use version 3.1 or later.<br>
<b>&nbsp;&nbsp;Windows: </b>Use Windows 95 or later.<br>
<b>&nbsp;&nbsp;Windows CE: </b>Unsupported.<br>
<b>&nbsp;&nbsp;Header: </b>Declared in objidl.h.</p>
<h4>See Also</h4>
<p>
<a href="structs_14v7.htm"><b>FORMATETC</b></a>, <a href="api3_2kmb.htm"><b>OleRegEnumFormatEtc</b></a>, <a href="if_a2e_7kyr.htm"><b>IEnumFormatEtc</b></a>, <a href="if_a2e_438h.htm"><b>IDataObject::SetData</b></a>, <a href="if_a2e_1jz5.htm"><b>IDataObject::GetData</b></a> </p>
<p>
</p>
<p>
</p>
<p>&nbsp;</p></body>
</HTML>
