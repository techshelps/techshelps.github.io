<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CoQueryProxyBlanket</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_com_coqueryproxyblanket"></a>CoQueryProxyBlanket</h1>
<p>
<span style=color:#FF0000>[This is preliminary documentation and subject to change.]</span> </p>
<p>
Retrieves the authentication information the client uses to make calls on the specified proxy.</p>
<pre><code><b>HRESULT CoQueryProxyBlanket(
  IUnknown *</b><i> pProxy</i><b>,      </b>//Location for the proxy to query
<b>  DWORD *</b><i> pAuthnSvc</i><b>,      </b>//Location for the current 
                          // authentication service
<b>  DWORD *</b><i> pAuthzSvc</i><b>,      </b>//Location for the current 
                          // authorization service
<b>  OLECHAR **</b><i> pServerPrincName</i><b>,</b>
<b>                          </b>//Location for the current principal name
<b>  DWORD *</b><i> pAuthnLevel</i><b>,    </b>//Location for the current authentication 
                          // level
<b>  DWORD *</b><i> pImpLevel</i><b>,      </b>//Location for the current impersonation 
                          // level
<b>  RPC_AUTH_IDENTITY_HANDLE *</b><i> ppAuthInfo</i><b>,</b>
<b>                          </b>//Location for the value passed to 
                          // IClientSecurity::SetBlanket
<b>  DWORD *</b><i> pCapabilities   </i>//Location for flags indicating further 
                          // capabilities of the proxy
<b>);</b>
 </code></pre>
<h4>Parameters</h4>
<dl>
<dt>
<i>pProxy</i></dt>
<dd>
[in] Pointer indicating the proxy to query. For more information, see the Remarks section.</dd>
<dt>
<i>pAuthnSvc</i></dt>
<dd>
[out] Pointer to a DWORD value defining the current <i>authentication</i> service. This will be a single value taken from the list of <a href="enums_22yg.htm"><b>RPC_C_AUTHN_<i>xxx</i></b></a> constants. May be NULL, in which case the current authentication service is not retrieved.</dd>
<dt>
<i>pAuthzSvc</i></dt>
<dd>
[out] Pointer to a DWORD value defining the current <i>authorization </i>service. This will be a single value taken from the list of <a href="enums_77js.htm"><b>RPC_C_AUTHZ_<i>xxx</i></b></a> constants. May be NULL, in which case the current authorization service is not retrieved.</dd>
<dt>
<i>pServerPrincName</i></dt>
<dd>
[out] Pointer to the current principal name. The string will be allocated by the callee using <a href="api1_9bj7.htm"><b>CoTaskMemAlloc</b></a> and must be freed by the caller using <a href="api1_63l1.htm"><b>CoTaskMemFree</b></a> when they are done with it. Notice that the actual principal name is returned. The EOAC_MAKE_FULLSIC flag is not accepted to convert the prinicpal name. May be NULL, in which case the principal name is not retrieved.</dd>
<dt>
<i>pAuthnLevel</i></dt>
<dd>
[out] Pointer to a DWORD value defining the current authentication level. This will be a single value taken from the list of <a href="enums_3lo8.htm"><b>RPC_C_AUTHN_LEVEL_<i>xxx</i></b></a> constants. May be NULL, in which case the current authentication level is not retrieved.</dd>
<dt>
<i>pImpLevel</i></dt>
<dd>
[out] Pointer to a DWORD value defining the current impersonation level. This will be a single value taken from the list of <a href="enums_2jco.htm"><b>RPC_C_IMP_LEVEL_<i>xxx</i></b></a> constants. May be NULL, in which case the current impersonation level is not retrieved. When using NTLMSSP, this value could be RPC_IMP_LEVEL_IDENTIFY or RPC_IMP_LEVEL_IMPERSONATE. When using NTLMSSP on NT 5.0, cross-apartment or cross-process, this value can be RPC_IMP_LEVEL_DELEGATE. When using Kerberos, it will be RPC_IMP_LEVEL_IDENTIFY, RPC_IMP_LEVEL_IMPERSONATE, or RPC_C_IMP_LEVEL_DELEGATE. </dd>
<dt>
<i>ppAuthInfo</i></dt>
<dd>
[out] Pointer to the pointer value indicating the identity of the client that was passed to the last <b>IClientSecurity::SetBlanket</b> call (or the default value). Default values are only valid until the proxy is released. If no <b>SetBlanket</b> call replaced the default security blanket, and if the client specified a structure for the current authentication service in the <i>pAuthInfo</i> parameter to <b>CoInitializeSecurity</b>, that value is returned. Because this points to the value itself and is not a copy, it should not be manipulated or freed. For SSL, if DCOM could get a private certificate from the certificate manager for the client, that value is returned here. Otherwise, NULL is returned.</dd>
<dt>
<i>pCapabilities</i></dt>
<dd>
[out] Pointer to a DWORD of flags indicating the capabilities of the proxy. May be NULL, in which case the flags are not retrieved. On Windows NT 5.0, this may be EOAC_STATIC_CLOAKING or EOAC_DYNAMIC_CLOAKING.
</dd>
</dl>
<h4>Return Values</h4>
<dl>
<dt>
S_OK</dt>
<dd>
Success.</dd>
<dt>
E_INVALIDARG</dt>
<dd>
One or more arguments are invalid.</dd>
<dt>
E_OUTOFMEMORY</dt>
<dd>
Insufficient memory to create the <i>pServerPrincName</i> out-parameter.
</dd>
</dl>
<h4>Remarks</h4>
<p>
<b>CoQueryProxyBlanket</b> is called by the client to retrieve the authentication information COM will use on calls made from the specified proxy. This function encapsulates the following sequence of common calls (error handling excluded):</p>
<pre><code>pProxy-&gt;QueryInterface(IID_IClientSecurity, (void**)&amp;pcs);
pcs-&gt;QueryBlanket(pProxy, pAuthnSvc, pAuthzSvc, pServerPrincName,
                 pAuthnLevel, pImpLevel, ppAuthInfo, pCapabilities);
pcs-&gt;Release();
 </code></pre>
<p>
This sequence calls <b>QueryInterface</b> on the proxy to get a pointer to <b>IClientSecurity</b>, and with the resulting pointer, calls <b>IClientSecurity::QueryBlanket</b>, and then releases the pointer.</p>
<p>
In <i>pProxy</i>, you can pass any proxy, such as a proxy you get through a call to <b>CoCreateInstance</b>, <b>CoUnmarshalInterface</b>, or you can pass an interface pointer. It can be any interface. You cannot pass a pointer to something that is not a proxy. Therefore, you can't pass a pointer to an interface that has the local keyword in its interface definition since no proxy is created for such an interface. <b>IUnknown</b> is the exception to this rule.</p>
<h4>QuickInfo</h4>
<p>
<b>&nbsp;&nbsp;Windows NT: </b>Use version 4.0 or later.<br>
<b>&nbsp;&nbsp;Windows: </b>Use Windows 95 or later. Available as a redistributable for Windows 95.<br>
<b>&nbsp;&nbsp;Windows CE: </b>Unsupported.<br>
<b>&nbsp;&nbsp;Header: </b>Declared in objbase.h.<br>
<b>&nbsp;&nbsp;Import Library: </b>Included as a resource in ole32.dll.</p>
<h4>See Also</h4>
<p>
<a href="if_a2e_8y0k.htm"><b>IClientSecurity::QueryBlanket</b></a>, <a href="comext_47fx.htm"><b>Security in COM</b></a> </p>
<p>
</p>
<p>
</p>
<p>&nbsp;</p></body>
</HTML>
