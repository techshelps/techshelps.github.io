<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>OleGetClipboard</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_com_olegetclipboard"></a>OleGetClipboard</h1>
<p>
Retrieves a data object that you can use to access the contents of the clipboard.</p>
<pre><code><b>WINOLEAPI OleGetClipboard(
  IDataObject **</b><i> ppDataObj  </i>//Address of output variable that 
                            // receives the IDataObject interface 
                            // pointer
<b>);</b>
 </code></pre>
<h4>Parameter</h4>
<dl>
<dt>
<i>ppDataObj</i></dt>
<dd>
[out] Address of <b>IDataObject</b>* pointer variable that receives the interface pointer to the clipboard data object.
</dd>
</dl>
<h4>Return Values</h4>
<p>
This function supports the standard return values E_INVALIDARG and E_OUTOFMEMORY, as well as the following: 
<dl>
<dt>
S_OK</dt>
<dd>
The data object was successfully retrieved.</dd>
<dt>
CLIPBRD_E_CANT_CLOSE</dt>
<dd>
The Windows <b>CloseClipboard</b> function used within <b>OleGetClipboard</b> failed.</dd>
<dt>
CLIPBRD_E_CANT_OPEN</dt>
<dd>
The Windows <b>OpenClipboard</b> function used with <b>OleGetClipboard</b> failed.
</dd>
</dl>
<h4>Remarks</h4>
<p>
If you are writing an application that can accept data from the clipboard, call the <b>OleGetClipboard</b> function to get a pointer to the <b>IDataObject</b> interface that you can use to retrieve the contents of the clipboard.</p>
<p>
<b>OleGetClipboard</b> handles three cases:
<ol>
<li>
The application that placed data on the clipboard with the <a href="api3_55r8.htm"><b>OleSetClipboard</b></a> function is still running.</li>
<li>
The application that placed data on the clipboard with the <b>OleSetClipboard</b> function has subsequently called the <a href="api3_123o.htm"><b>OleFlushClipboard</b></a> function.</li>
<li>
There is data from a non-OLE application on the clipboard.</li>
</ol>
<p>
In the first case, the clipboard data object returned by <b>OleGetClipboard</b> may forward calls as necessary to the original data object placed on the clipboard and, thus, can potentially make RPC calls.</p>
<p>
In the second case, OLE creates a default data object and returns it to the user. Because the data on the Clipboard originated from an <a href="api3_55r8.htm"><b>OleSetClipboard</b></a> call, the OLE-provided data object contains more accurate information about the type of data on the Clipboard. In particular, the original medium (<a href="enums_986c.htm">TYMED</a>) on which the data was offered is known. Thus, if a data-source application offers a particular clipboard format, for example cfFOO, on a storage object and calls the <a href="api3_123o.htm"><b>OleFlushClipboard</b></a> function, the storage object is copied into memory and the <i>hglobal</i> memory handle is put on the Clipboard. Then, when the <b>OleGetClipboard</b> function creates its default data object, the <i>hglobal</i> from the clipboard again becomes an <b>IStorage</b> object. Furthermore, the <a href="structs_14v7.htm"><b>FORMATETC</b></a> enumerator and the <a href="if_a2e_9wtd.htm"><b>IDataObject::QueryGetData</b></a> method would all correctly indicate that the original clipboard format (cfFOO) is again available on a TYMED_ISTORAGE.</p>
<p>
In the third case, OLE still creates a default data object, but there is no special information about the data in the Clipboard formats (particularly for application-defined Clipboard formats). Thus, if an hGlobal-based storage medium were put on the Clipboard directly by a call to the <b>SetClipboardData </b>function, the <b>FORMATETC</b> enumerator and the <b>IDataObject::QueryGetData</b> method would not indicate that the data was available on a storage medium. A call to the <a href="if_a2e_1jz5.htm"><b>IDataObject::GetData</b></a> method for TYMED_ISTORAGE would succeed, however. Because of these limitations, it is strongly recommended that OLE-aware applications interact with the Clipboard using the OLE Clipboard functions.</p>
<p>
The clipboard data object created by the <b>OleGetClipboard</b> function has a fairly extensive <b>IDataObject</b> implementation. The OLE-provided data object can convert OLE 1 clipboard format data into the representation expected by an OLE 2 caller. Also, any structured data is available on any structured or flat medium, and any flat data is available on any flat medium. However, GDI objects (such as metafiles and bitmaps) are only available on their respective mediums.</p>
<p>
Note that the <i>tymed</i> member of the <b>FORMATETC </b>structure used in the <b>FORMATETC</b> enumerator contains the union of supported mediums. Applications looking for specific information (such as whether CF_TEXT is available on TYMED_HGLOBAL) should do the appropriate bit masking when checking this value.</p>
<p>
If you call the <b>OleGetClipboard</b> function, you should only hold on to the returned <a href="if_a2e_24z8.htm"><b>IDataObject</b></a> for a very short time. It consumes resources in the application that offered it.</p>
<h4>QuickInfo</h4>
<p>
<b>&nbsp;&nbsp;Windows NT: </b>Use version 3.1 or later.<br>
<b>&nbsp;&nbsp;Windows: </b>Use Windows 95 or later.<br>
<b>&nbsp;&nbsp;Windows CE: </b>Unsupported.<br>
<b>&nbsp;&nbsp;Header: </b>Declared in ole2.h.<br>
<b>&nbsp;&nbsp;Import Library: </b>Included as a resource in ole32.dll.</p>
<h4>See Also</h4>
<p>
<a href="api3_55r8.htm"><b>OleSetClipboard</b></a> </p>
<p>
</p>
<p>
</p>
<p>&nbsp;</p></body>
</HTML>
