<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>IMarshal</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_com_imarshal"></a>IMarshal</h1>
<p>
The <b>IMarshal</b> interface enables a COM object to define and manage the marshaling of its interface pointers. The alternative is to use COM's default implementation, the preferred choice in all but a few special cases (see "When to Implement").</p>
<p>
"Marshaling" is the process of packaging data into packets for transmission to a different process or machine. "Unmarshaling" is the process of recovering that data at the receiving end. In any given call, method arguments are marshaled and unmarshaled in one direction, while return values are marshaled and unmarshaled in the other.</p>
<p>
Although marshaling applies to all data types, interface pointers require special handling. The fundamental problem is how client code running in one address space can correctly dereference a pointer to an interface on an object residing in a different address space. COM's solution is for a client application to communicate with the original object through a surrogate object, or <i>proxy</i>, which lives in the client's process. The proxy holds a reference to an interface on the original object and hands the client a pointer to an interface on itself. When the client calls an interface method on the original object, its call is actually going to the proxy. Therefore, from the client's point of view, all calls are in-process.</p>
<p>
On receiving a call, the proxy marshals the method arguments and, through some means of interprocess communication, such as RPC, passes them along to code in the server process, which unmarshals the arguments and passes them to the original object. This same code marshals return values for transmission back to the proxy, which unmarshals the values and passes them to the client application.</p>
<p>
<b>IMarshal</b> provides methods for creating, initializing, and managing a proxy in a client process; it does not dictate how the proxy should communicate with the original object. COM's default implementation of <b>IMarshal</b> uses RPC. When you implement this interface yourself, you are free to choose any method of interprocess communication you deem to be appropriate for your application — shared memory, named pipe, window handle, RPC — in short, whatever works.</p>
<h5>When to Implement </h5>
<p>
Implement <b>IMarshal</b> <i>only</i> when you believe that you can realize significant optimizations to COM's default implementation. In practice, this will rarely be the case. However, there are occasions where implementing <b>IMarshal</b> may be preferred:
<ul>
<li>
The objects you are writing keep their state in shared memory. In this case, both the original process and the client process uses proxies that refer to the shared memory. This type of custom marshaling is possible only if the client process is on the same machine as the original process. COM-provided implementations of <a href="if_r2z_9b8l.htm"><b>IStorage</b></a> and <a href="if_r2z_4x7x.htm"><b>IStream</b></a> are examples of this type of custom marshaling.</li>
<li>
The objects you are writing are immutable, that is, their state does not change after creation. Instead of forwarding method calls to the original objects, you simply create copies of those objects in the client process. This technique avoids the cost of switching from one process to another. Some monikers are examples of immutable objects; if you are implementing your own moniker class, you should evaluate the costs and benefits of implementing <b>IMarshal</b> on your moniker objects.</li>
<li>
Objects that themselves are proxy objects can use custom marshaling to avoid creating proxies to proxies. Instead, the existing proxy can refer new proxies back to the original object. This capability is important for the sake of both efficiency and robustness.</li>
<li>
Your server application wants to manage how calls are made across the network without affecting the interface exposed to clients. For example, if an end user were making changes to a database record, the server might want to cache the changes until the user has committed them all, at which time the entire transaction would be forwarded in a single packet. Using a custom proxy would enable the caching and batching of changes in this way.</li>
</ul>
<p>
When you choose to implement <b>IMarshal</b>, you must do so for both your original object and the proxy you create for it. When implementing the interface on either object or proxy, you simply return E_NOTIMPL for the methods that are not implemented.</p>
<p>
COM uses your implementation of <b>IMarshal</b> in the following manner: When it's necessary to create a remote interface pointer to your object (that is, when a pointer to your object is passed as an argument in a remote function call), COM queries your object for the <b>IMarshal</b> interface. If your object implements it, COM uses your <b>IMarshal</b> implementation to create the proxy object. If your object does not implement <b>IMarshal</b>, COM uses its default implementation.</p>
<p>
How you choose to structure the proxy is entirely up to you. You can write the proxy to use whatever mechanisms you deem appropriate for communicating with the original object. You can also create the proxy as either a stand-alone object or as part of a larger aggregation such as a handler. However you choose to structure the proxy, it must implement <b>IMarshal</b> to work at all. You must also generate a CLSID for the proxy to be returned by your implementation of <b>IMarshal::GetUnmarshalClass</b> on the original object.</p>
<h5>When to Use</h5>
<p>
COM calls this interface as part of system-provided marshaling support. COM's calls are wrapped in calls to <a href="api1_8205.htm"><b>CoMarshalInterface</b></a> and <a href="api1_6gbp.htm"><b>CoUnmarshalInterface</b></a>. Your code typically will not need to call this interface. Special circumstances where you might choose to do so are discussed in the "Notes to Callers" section for each method.</p>
<h4>Methods in VTable Order</h4>
<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=36%><a href="if_r2z_9dwu.htm">IUnknown</a> Methods</th>
<th align=left width=64%>Description</th>
</tr>
<tr valign=top>
<td width=36%><a href="if_r2z_7fvp.htm"><b>QueryInterface</b></a></td>
<td width=64%>Returns pointers to supported interfaces.</td>
</tr>
<tr valign=top>
<td width=36%><a href="if_r2z_3rja.htm"><b>AddRef</b></a></td>
<td width=64%>Increments reference count.</td>
</tr>
<tr valign=top>
<td width=36%><a href="if_r2z_59np.htm"><b>Release</b></a></td>
<td width=64%>Decrements reference count.</td>
</tr>
</table><br>
<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=36%>IMarshal Methods</th>
<th align=left width=64%>Description</th>
</tr>
<tr valign=top>
<td width=36%><a href="if_f2n_1mib.htm"><b>GetUnmarshalClass</b></a></td>
<td width=64%>Returns CLSID of unmarshaling code.</td>
</tr>
<tr valign=top>
<td width=36%><a href="if_f2n_2fjs.htm"><b>GetMarshalSizeMax</b></a></td>
<td width=64%>Returns size of buffer needed during marshaling.</td>
</tr>
<tr valign=top>
<td width=36%><a href="if_f2n_8ox1.htm"><b>MarshalInterface</b></a></td>
<td width=64%>Marshals an interface pointer.</td>
</tr>
<tr valign=top>
<td width=36%><a href="if_f2n_3icl.htm"><b>UnmarshalInterface</b></a></td>
<td width=64%>Unmarshals an interface pointer.</td>
</tr>
<tr valign=top>
<td width=36%><a href="if_f2n_74v5.htm"><b>ReleaseMarshalData</b></a></td>
<td width=64%>Destroys a marshaled data packet.</td>
</tr>
<tr valign=top>
<td width=36%><a href="if_f2n_59h0.htm"><b>DisconnectObject</b></a></td>
<td width=64%>Severs all connections.</td>
</tr>
</table><br>
<h4>QuickInfo</h4>
<p>
<b>&nbsp;&nbsp;Windows NT: </b>Use version 3.1 or later.<br>
<b>&nbsp;&nbsp;Windows: </b>Use Windows 95 or later.<br>
<b>&nbsp;&nbsp;Windows CE: </b>Unsupported.<br>
<b>&nbsp;&nbsp;Header: </b>Declared in objidl.h.</p>
<h4>See Also</h4>
<p>
<a href="if_r2z_99tb.htm"><b>IStdMarshalInfo</b></a> </p>
<p>
</p>
<p>
</p>
<p>&nbsp;</p></body>
</HTML>
