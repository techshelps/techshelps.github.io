<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>IMoniker - URL Moniker Implementation</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_com_imoniker_url_moniker_implementation"></a>IMoniker - URL Moniker Implementation</h1>
<p>
The URL moniker implementation of <b>IMoniker</b> is found on a URL moniker object, which also supports <b>IUnknown</b> and <a href="if_a2e_5nle.htm"><b>IAsyncMoniker</b></a>. The <b>IMoniker</b> interface inherits its definition from <b>IPersistStream</b> as well as <b>IUnknown</b> and <b>IPersistStream</b> inherits from <b>IPersist</b>. Thus, the <b>IMoniker</b> implementation includes support for <b>IPersistStream</b> and <b>IPersist</b>.</p>
<p>
The <b>IAsyncMoniker</b> interface is simply <b>IUnknown</b> (there are no additional methods). It is is used to allow clients to determine if a moniker supports asynchronous binding.</p>
<p>
To get a pointer to the <b>IMoniker</b> interface on this object, call the <a href="api2_38aa.htm"><b>CreateURLMoniker</b></a> function.</p>
<p>
<b>Note</b>&nbsp;&nbsp;The current URL Moniker implementation of <b>IMoniker</b> does not support asynchronous storage. Future implementations will do so.</p>
<h5>When to Use</h5>
<p>
If you're a moniker client (that is, you're using a moniker to get an interface pointer to an object), you typically don't need to know the class of the moniker you're using; you simply call methods using an <b>IMoniker</b> interface pointer.</p>
<p>
If you're a moniker provider (that is, you're handing out monikers that identify your objects to make them accessible to moniker clients), you must use item monikers if the objects you're identifying are contained within another object and can be individually identified using a string. You'll also need to use another type of moniker (for example, file monikers) in order to identify the container object.</p>
<p>
To use item monikers, you must use the <b>CreateItemMoniker</b> function to create the monikers. To allow your objects to be loaded when an item moniker is bound, the container of your objects must implement the <b>IOleItemContainer</b> interface.</p>
<p>
The most common example of moniker providers are COM applications that support linking. If your COM application supports linking to objects smaller than a file-based documents, you need to use item monikers. For a server application that allows linking to a selection within a document, you use the item monikers to identify those objects. For a container application that allows linking to embedded objects, you use the item monikers to identify the embedded objects. </p>
<h4>Remarks</h4>
<dl>
<dt>
<b>IMoniker::BindToObject</b></dt>
<dd>
Since the URL Moniker supports asynchronous binding, the actual return value of its <b>BindToObject</b> may vary depending on the object parameters established in the bind-context, however the semantics of the bind operation are identical regardless of synchronous or asynchronous usage, and are as follows:
<ol>
<li>
The URL Moniker pulls further information for the bind operation from the bind context. For example, the moniker can obtain pointers to the <a href="if_a2e_0vxn.htm"><b>IBindStatusCallback</b></a> and <b>IEnumFORMATETC</b> interfaces that are registered in the bind context. Note that further information can include additional bind options specified on the bind context through <b>IBindCtx::SetBindOptions</b>, such as the <i>dwTickCountDeadline</i> parameter or the <i>grfFlags</i> value of BIND_MAYBOTHERUSER.</li>
<li>
Next, the moniker checks the Running Object Table of the bind-context to determine if the referenced object is already running. The moniker can obtain this information with the following calls:<pre><code>IBindCtx::GetRunningObjectTable(&amp;prot)
prot-&gt;IsRunning(this)
 </code></pre>
<p>
If the object is already running, the moniker retrieves the running object with the following call:
<pre><code>prot-&gt;GetObject(this, &amp;punk)
 </code></pre>
<p>
Then, the moniker calls <b>QueryInterface</b> for the requested interface.
</li>
<li>
Otherwise, the moniker queries the client by calling <a href="if_a2e_5njj.htm"><b>IBindStatusCallback::GetBindInfo</b></a> to obtain additional bind information. The moniker then initiates the bind operation and passes the resulting <b>IBinding</b> interface back to the client by calling <a href="if_a2e_695z.htm"><b>IBindStatusCallback::OnStartBinding</b></a>.</li>
<li>
If in step 1 it was determined that this was an asynchronous bind, <b>BindToObject</b> returns MK_S_ASYNCHRONOUS at this point with NULL in <i>ppv</i>. The caller will receive the actual object pointer during <a href="if_a2e_2vz9.htm"><b>IBindStatusCallback::OnObjectAvailable</b></a> at some later point. The following steps then occur asynchronously to the caller, typically on another thread of execution.</li>
<li>
The class of the resource designated by the URL Moniker is determined in one of the following ways:</li>
</ol>

<ul>
<li>
The URL Moniker examines the media type of the data. If the media type is <b>application/x-oleobject</b>, the first 16-bytes of the actual data (<i>Content-Body</i>) contain the CLSID of the resource and subsequent data is to be interpreted by the class itself. For all other media types, URL Moniker looks in the system registry for the HKEY_CLASSES_ROOT\MIME\Database\Content-Type\&lt;media-type&gt;\CLSID key. Note that <b>application/x-oleobject</b> will be used until <b>application/oleobject</b> is approved.</li>
<li>
The URL Moniker matches portions of arriving data to patterns registered in the system registry under HKEY_CLASSES_ROOT\FileTypes.</li>
<li>
Finally, if all else fails, the URL Moniker correlates the trailing extension of the resource, if any, to a CLSID using the HKEY_CLASSES_ROOT\.??? keys in the system registry, as is done by <b>GetClassFile</b> and the shell.</li>
</ul>

<ol start=6>
<li>
Having determined the class, the URL moniker creates an instance using <b>CoCreateInstance</b> of CLSCTX_SERVER asking for the <b>IUnknown</b> interface.</li>
<li>
The URL Moniker next calls the <b>QueryInterface</b> method of the newly created object for the <a href="if_p2q_7qcy.htm"><b>IPersistMoniker</b></a> interface. If the <b>QueryInterface</b> is successful, the URL Moniker calls <a href="if_p2q_2qhw.htm"><b>IPersistMoniker::Load</b></a> passing itself (<b>this</b>) as the moniker parameter. The object typically calls <b>IMoniker::BindToStorage</b> asking for the storage interface that they're interested in.</li>
<li>
Otherwise, the URL Moniker calls the <b>QueryInterface</b> method for <b>IPersistStream</b> and, if successful, calls <b>IPersistStream::Load</b>, passing the object an <b>IStream</b> pointer for a stream object that is being filled asynchronously by the transport.<p>
If the class being called is not marked with the category CATID_AsyncAware, calls to <b>IStream::Read</b> or <b>IStream::Write</b> which reference data not yet available block until the data becomes available. These calls block in the traditional COM sense. A message loop is entered which allows certain messages to be processed, and the <b>IMessageFilter</b> of the thread is called appropriately.
<p>
If the class is marked with the category CATID_AsyncAware, calls to <b>IStream::Read</b> or <b>IStream::Write</b> which reference data not yet available return E_PENDING.
</li>
<li>
Otherwise, the URL Moniker calls <b>QueryInterface</b> for <b>IPersistFile</b>, and, if successful, completes the download into a temporary file. On completion, the URL Moniker calls <b>IPersistFile::Load</b>. The created file is cached along with other Internet downloaded data. The client must be sure not to delete this file.</li>
<li>
When the object returns from one of the various <b>IPersist<i>Xxx</i>::Load</b> calls described in the previous steps, the URL Moniker calls <a href="if_a2e_2vz9.htm"><b>IBindStatusCallback::OnObjectAvailable</b></a> to return the interface pointer that the client originally requested when the client called <b>IMoniker::BindToObject</b>.</li>
</ol>
</dd>
<dt>
<b>IMoniker::BindToStorage</b></dt>
<dd>
The system implementation of URL Monikers supports the <b>BindToStorage</b> for stream objects on all URLs and for storage objects in the case where the designated resource is in fact a compound file. Future support for <b>ILockBytes</b> may also be added.
<p>
Since the URL Moniker supports asynchronous binding, the actual return value of its <b>BindToStorage</b> may vary depending on the object parameters established in the bind-context. However, the semantics of the bind operation are identical regardless of synchronous or asynchronous usage as described below:

<ol>
<li>
The URL Moniker pulls further information for the bind operation from the bind context. For example, the moniker can obtain pointers to the <b>IBindStatusCallback</b> and <b>IEnumFORMATETC</b> interfaces that are registered in the bind context. Note that further information can include additional bind options specified on the bind context through <b>IBindCtx::SetBindOptions</b>, such as the <i>dwTickCountDeadline</i> parameter or the <i>grfFlags</i> value of BIND_MAYBOTHERUSER. The moniker then queries the client by calling <b>IBindStatusCallback::GetBindInfo</b> and initiates the bind operation with the transport, and passes the resulting <b>IBinding</b> to the client by calling <b>IBindStatusCallback::OnStartBinding</b>.</li>
<li>
If the caller requested an asynchronous <b>IStream</b> or <b>IStorage</b> by specifying the <b>BINDF_ASYNCSTORAGE</b> flag in the <b>BINDINFO</b> structure retrieved from <a href="if_a2e_5njj.htm"><b>IBindStatusCallback::GetBindInfo</b></a>, the URL moniker returns the object as soon as possible. Calls to these <b>IStorage</b> or <b>IStream</b> objects which reference data not yet available return E_PENDING.</li>
<li>
If the caller does not specify asynchronous <b>IStream</b> or <b>IStorage</b> as described above, the URL Moniker will still return an object through <a href="if_a2e_0x2d.htm"><b>IBindStatusCallback::OnDataAvailable</b></a><b> </b>as soon as possible. However calls to these objects which reference data not yet available will block until the data becomes available. For some applications this will require the least modification of their existing I/O code, yet may still result in improved performance depending on their access-patterns.</li>
</ol>
</dd>
<dt>
<b>IMoniker::Reduce</b></dt>
<dd>
Returns MK_S_REDUCED_TO_SELF and itself (<b>this</b>) in *<i>ppmkReduced</i>.</dd>
<dt>
<b>IMoniker::ComposeWith</b></dt>
<dd>
URL Monikers support composition of two URLs: a base URL composed with a relative URL. This composition is done according to the RFC on relative URLs. URL Monikers do not currently support the composition of a base URL moniker with a relative file moniker, although this may be supported in the future.
<p>
However, URL Monikers do support generic composition. If <i>fOnlyIfNotGeneric==TRUE</i>, the <b>ComposeWith</b> method returns MK_E_NEEDGENERIC. Otherwise, this method simply returns <b>CreateGenericComposite</b>(<b>this</b>, <b>pmkRight</b>, <b>ppmkComposite</b>). See the Win32 documentation for more information about <b>IMoniker::ComposeWith</b>.
</dd>
<dt>
<b>IMoniker::Enum</b></dt>
<dd>
Returns S_OK and sets *<i>ppenumMoniker</i> to NULL, indicating that the moniker does not contain sub-monikers.</dd>
<dt>
<b>IMoniker::IsEqual</b></dt>
<dd>
Returns S_FALSE if the other moniker (<i>pmkOtherMoniker</i>) is not an URL moniker, which it checks using <b>IPersist::GetClassID</b> to see if the CLSID is <b>CLSID_URLMoniker</b>. If the other moniker is an URL moniker, it compares the display names of the monikers for equality, returning either S_OK if they are identical or S_FALSE if not.</dd>
<dt>
<b>IMoniker::Hash</b></dt>
<dd>
Creates a hash value based on the URL string of the moniker. This hash value is identical when URL strings are identical, although it may also be identical for different URL strings. This method is used to speed up comparisons by reducing the amount of time that it is necessary to call <b>IMoniker::IsEqual</b>.</dd>
<dt>
<b>IMoniker::IsRunning</b></dt>
<dd>
Returns S_OK if this moniker is currently running. Otherwise, it returns S_FALSE. The URL Moniker determines if it is running by first checking if it is equal to the newly running moniker by making the following call:
<pre><code>pmkNewlyRunning-&gt;IsEqual
 </code></pre>

<p>
Typically, this call an inexpensive operation. If this does not succeed, the moniker next checks to see if it is registered with the Running Object Table of the passed-in bind-context.
</dd>
<dt>
<b>IMoniker::GetTimeOfLastChange</b></dt>
<dd>
Returns the time of last change of an object that is registered in the running object table.</dd>
<dt>
<b>IMoniker::Inverse</b></dt>
<dd>
Returns MK_E_NOINVERSE.</dd>
<dt>
<b>IMoniker::CommonPrefixWith</b></dt>
<dd>
Currently returns E_NOTIMPL. In the future, it may properly compute the proper common prefix of two URL monikers. See the Win32 documentation about <b>IMoniker::CommonPrefixWith</b> for details.</dd>
<dt>
<b>IMoniker::RelativePathTo</b></dt>
<dd>
Currently returns E_NOTIMPL. In the future, it may properly compute the relative path between two URL monikers. See the Win32 documentation about <b>IMoniker::RelativePathTo</b> for details.</dd>
<dt>
<b>IMoniker::GetDisplayName</b></dt>
<dd>
THe URL Moniker attempts to return its full URL string. If the moniker was created with a partial URL string (see <a href="api2_38aa.htm"><b>CreateURLMoniker</b></a>), it will first attempt to find an URL moniker in the bind-context under SZ_URLCONTEXT, and will next look to the moniker to its left for contextual information. If it can not return its full URL string, it will return its partial URL string.</dd>
<dt>
<b>IMoniker::ParseDisplayName</b></dt>
<dd>
Parses a full or partial URL string into a result moniker (<i>ppmkOut</i>). If <i>szDisplayName</i> represents a full URL string (i.e. "http://foo.com/default.html"), the result is a new full URL moniker. If <i>szDisplayName</i> represents a partial URL string (i.e. "..\default.html"), the result is a full URL that takes its context from either the bind-context's SZ_URLCONTEXT object-parameter or from this URL moniker. For example, if the context moniker was "http://foo.com/pub/list.html" and <i>szDisplayName</i> was "..\default.html", the resulting URL moniker would represent "http://foo.com/default.html".</dd>
<dt>
<b>IMoniker::IsSystemMoniker</b></dt>
<dd>
Returns S_TRUE and MKSYS_URLMONIKER in *<i>pdwMksys</i>.
</dd>
</dl>
<h4>See Also</h4>
<p>
<a href="api2_38aa.htm"><b>CreateURLMoniker</b></a>, <a href="if_p2q_4qsu.htm"><b>IPersistStream - URL Moniker Implementation</b></a> </p>
<p>
</p>
<p>
</p>
<p>&nbsp;</p></body>
</HTML>
