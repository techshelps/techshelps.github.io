<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>IMarshal::GetUnmarshalClass</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h2><a name="_com_imarshal_getunmarshalclass"></a>IMarshal::GetUnmarshalClass</h2>
<p>
Returns the CLSID that COM uses to locate the DLL containing the code for the corresponding proxy. COM loads this DLL to create an uninitialized instance of the proxy.</p>
<pre><code><b>HRESULT GetUnmarshalClass(
  REFIID</b><i> riid</i><b>,          </b>//Reference to the identifier of the 
                        //interface to be marshaled
<b>  void *</b><i> pv</i><b>,            </b>//Interface pointer being marshaled
<b>  DWORD</b><i> dwDestContext</i><b>,  </b>//Destination process
<b>  void *</b><i> pvDestContext</i><b>, </b>//Reserved for future use
<b>  DWORD</b><i> mshlflags</i><b>,      </b>//Reason for marshaling
<b>  CLSID *</b><i> pCid          </i>//Pointer to CLSID of proxy
<b>);</b>
 </code></pre>
<h4>Parameters</h4>
<dl>
<dt>
<i>riid</i></dt>
<dd>
[in] Reference to the identifier of the interface to be marshaled.</dd>
<dt>
<i>pv</i></dt>
<dd>
[in] Pointer to the interface to be marshaled; can be NULL if the caller does not have a pointer to the desired interface.</dd>
<dt>
<i>dwDestContext</i></dt>
<dd>
[in] "Destination context" where the specified interface is to be unmarshaled. Values for <i>dwDestContext</i> come from the enumeration <a href="enums_6mpk.htm"><b>MSHCTX</b></a>. Currently, unmarshaling can occur either in another apartment of the current process (MSHCTX_INPROC) or in another process on the same computer as the current process (MSHCTX_LOCAL).</dd>
<dt>
<i>pvDestContext</i></dt>
<dd>
[in] Reserved for future use; must be NULL.</dd>
<dt>
<i>mshlflags</i></dt>
<dd>
[in] Whether the data to be marshaled is to be transmitted back to the client process — the normal case — or written to a global table, where it can be retrieved by multiple clients. Valid values come from the <a href="enums_5bg3.htm"><b>MSHLFLAGS</b></a> enumeration.</dd>
<dt>
<i>pCid</i></dt>
<dd>
[out] Pointer to the CLSID to be used to create a proxy in the client process.
</dd>
</dl>
<h4>Return Value</h4>
<p>
Returns S_OK if successful; otherwise, S_FALSE.</p>
<h4>Remarks</h4>
<p>
This method is called by whatever code in the server process may be responsible for marshaling a pointer to an interface on an object. This marshaling code is usually a stub generated by COM for one of several interfaces that can marshal a pointer to an interface implemented on an entirely different object. Examples include the <a href="if_a2e_9mk9.htm"><b>IClassFactory</b></a> and <a href="if_o_0yb6.htm"><b>IOleItemContainer</b></a> interfaces. For purposes of this discussion, the code responsible for marshaling a pointer is called the "marshaling stub."</p>
<p>
To create a proxy for an object, COM requires two pieces of information from the original object: the amount of data to be written to the marshaling stream and the proxy's CLSID.</p>
<p>
The marshaling stub obtains these two pieces of information with successive calls to <a href="api1_1p2w.htm"><b>CoGetMarshalSizeMax</b></a> and <a href="api1_8205.htm"><b>CoMarshalInterface</b></a>. </p>
<h5>Note to Callers</h5>
<p>
The marshaling stub calls the object's implementation of this method to obtain the CLSID to be used in creating an instance of the proxy. The client, upon receiving the CLSID, loads the DLL listed for it in the system registry.</p>
<p>
You do not explicitly call this method if you are:
<ul>
<li>
Implementing existing COM interfaces, or</li>
<li>
Defining your own interfaces using the Microsoft Interface Definition Language (MIDL).</li>
</ul>
<p>
In both cases, the stub automatically makes the call. See <a href="custintf_1777.htm"><b>Defining COM Interfaces</b></a></p>
<p>
If you are not using MIDL to define your own interface, your stub must call this method, either directly or indirectly, to get the CLSID that the client-side COM Library needs to create a proxy for the object implementing the interface.</p>
<p>
If the caller has a pointer to the interface to be marshaled, it should, as a matter of efficiency, use the <i>pv</i> parameter to pass that pointer. In this way, an implementation that may use such a pointer to determine the appropriate CLSID for the proxy does not have to call <a href="if_r2z_7fvp.htm"><b>IUnknown::QueryInterface</b></a> on itself. If a caller does not have a pointer to the interface to be marshaled, it can pass NULL.</p>
<h5>Notes to Implementers</h5>
<p>
COM calls <b>GetUnmarshalClass</b> to obtain the CLSID to be used for creating a proxy in the client process. The CLSID to be used for a proxy is normally <i>not</i> that of the original object (see "Notes to Implementers" for the exception), but one you will have generated (using the GUIDGEN.EXE tool supplied with the Win32 SDK) specifically for your proxy object.</p>
<p>
Implement this method for each object that provides marshaling for one or more of its interfaces. The code responsible for marshaling the object writes the CLSID, along with the marshaling data, to a stream; COM extracts the CLSID and data from the stream on the receiving side.</p>
<p>
If your proxy implementation consists simply of copying the entire original object into the client process, thereby eliminating the need to forward calls to the original object, the CLSID returned would be the same as that of the original object. This strategy, of course, is advisable only for objects that are not expected to change.</p>
<p>
If the <i>pv</i> parameter is NULL and your implementation needs an interface pointer, it can call <a href="if_r2z_7fvp.htm"><b>IUnknown::QueryInterface</b></a> on the current object to get it. The <i>pv</i> parameter exists merely to improve efficiency. </p>
<p>
To ensure that your implementation of <b>GetUnmarshalClass </b>continues to work properly as new destination contexts are supported in the future, delegate marshaling to COM's default implementation for all <i>dwDestContext</i> values that your implementation does not handle. To delegate marshaling to COM's default implementation, call the <a href="api1_88q4.htm"><b>CoGetStandardMarshal</b></a> function.</p>
<p>
</p>
<p>
</p>
<h4>QuickInfo</h4>
<p>
<b>&nbsp;&nbsp;Windows NT: </b>Use version 3.1 or later.<br>
<b>&nbsp;&nbsp;Windows: </b>Use Windows 95 or later.<br>
<b>&nbsp;&nbsp;Windows CE: </b>Unsupported.<br>
<b>&nbsp;&nbsp;Header: </b>Declared in objidl.h.</p>
<p>&nbsp;</p></body>
</HTML>
