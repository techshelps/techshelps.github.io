<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>IEnumOleUndoUnits</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_com_ienumoleundounits"></a>IEnumOleUndoUnits</h1>
<p>
The <b>IEnumOleUndoUnits</b> interface enumerates the undo units on the undo or redo stack.</p>
<h5>When to Implement</h5>
<p>
The undo manager implements this method to enumerate a list of undo units on the undo or redo stack.</p>
<h5>When to Use</h5>
<p>
Use the <b>IEnumOleUndoUnits</b> interface to enumerate all the top level undo units on the undo or redo stack.</p>
<p>
The prototypes of the methods are as follows:</p>
<pre><code><b>HRESULT Next(
  ULONG</b><i> cUndoUnits</i><b>, </b>//[in]Number of undo units returned in <i>rgpcd</i>
<b>  CONNECTDATA</b><i> **rgpcd</i><b>,</b>
<b>                    </b>//[out]Array to receive enumerated undo units
<b>  ULONG</b><i> *pcFetched  </i>//[out]Pointer to actual number of undo units
<b>);</b>
 
<b>HRESULT Skip(</b>
<b>  ULONG</b><i> cUndoUnits  </i>//[in]Number of undo units to skip
<b>);</b>
 
<b>HRESULT Reset(void);</b>
 
<b>HRESULT Clone(</b>
<b>  IEnumOleUndoUnits**</b><i> ppEnum  </i>//[out]Address of output variable that 
                              // receives the IEnumOleUndoUnits 
                              // interface pointer
<b>);</b>
 </code></pre>
<h4>Remarks</h4>
<dl>
<dt>
<b>IEnumOleUndoUnits::Next</b></dt>
<dd>
Enumerates the next specified number of undo units in the enumerator's list, returning them in <i>rgpcd</i> along with the actual number of enumerated elements in <i>pcFetched</i>.
<p>
The caller is responsible for calling the <b>Release</b> method for each element in the array once this method returns successfully. If <i>cUndoUnits</i> is greater than one, the caller must also pass a non-NULL pointer to <i>pcFetched</i> to get the number of pointers it has to release.

<p>
E_NOTIMPL is not allowed as a return value. If an error value is returned, no entries in the <i>rgpcd</i> array are valid on exit and require no release.
</dd>
<dt>
<b>IEnumOleUndoUnits::Skip</b></dt>
<dd>
Instructs the enumerator to skip the next specified number of elements in the enumerator so that the next call to <b>IEnumOleUndoUnits::Next</b> will not return those elements.</dd>
<dt>
<b>IEnumOleUndoUnits::Reset</b></dt>
<dd>
Instructs the enumerator to position itself at the beginning of the list of elements.
<p>
There is no guarantee that the same set of elements will be enumerated on each pass through the list. It depends on the collection being enumerated. It is too expensive for some collections, such as files in a directory, to maintain a specific state.
</dd>
<dt>
<b>IEnumOleUndoUnits::Clone</b></dt>
<dd>
Creates another undo unit enumerator with the same state as the current enumerator to iterate over the same list. This method makes it possible to record a point in the enumeration sequence in order to return to that point at a later time.
<p>
The caller must release this new enumerator separately from the first enumerator.

</dd>
</dl>
<h4>QuickInfo</h4>
<p>
<b>&nbsp;&nbsp;Windows NT: </b>Use version 4.0 or later. New for OC96.<br>
<b>&nbsp;&nbsp;Windows: </b>Use Windows 95 or later. New for OC96.<br>
<b>&nbsp;&nbsp;Windows CE: </b>Unsupported.<br>
<b>&nbsp;&nbsp;Header: </b>Declared in ocidl.h.</p>
<h4>See Also</h4>
<p>
<a href="if_o_2lv6.htm"><b>IOleUndoManager</b></a>, <a href="if_o_9jck.htm"><b>IOleUndoUnit</b></a> </p>
<p>
</p>
<p>
</p>
<p>&nbsp;</p></body>
</HTML>
