<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Implementing Reference Counting</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h3><a name="_com_implementing_reference_counting"></a>Implementing Reference Counting</h3>
<p>
Reference counting requires work on the part of both the implementor of a class and the clients who use objects of that class. When you implement a class, you must implement the <b>AddRef</b> and <b>Release</b> methods as part of the <a href="if_r2z_9dwu.htm"><b>IUnknown</b></a> interface. These two functions have simple implementations:
<ol>
<li>
<b>AddRef</b> increments the object's internal reference count. </li>
<li>
<b>Release</b> first decrements the object's internal reference count; then it checks whether the reference count has fallen to zero. If it has, that means no one is using the object any longer, so the <b>Release</b> function deallocates the object. </li>
</ol>
<p>
A common implementation approach for most objects is to have only one implementation of these functions (along with <b>QueryInterface</b>), which are shared between all interfaces, and therefore a reference count which applies to the entire object. Architecturally, however, from a client's perspective, reference counting is strictly and clearly a <i>per-interface-pointer</i> notion, and objects may be implemented which take advantage of this capability by dynamically constructing, destroying, loading, or unloading portions of their functionality based on the currently extant interface pointers. These are colloquially called "tear-off" interfaces.</p>
<p>
Whenever a client calls a method (or API function) that returns a new interface pointer, such as <b>QueryInterface</b>, the method being called is responsible for incrementing the reference count through the returned pointer. For example, when a client first creates an object, it receives an interface pointer to an object that, from the client's point of view, has a reference count of one. If the client then calls <b>AddRef</b> on the interface pointer, the reference count becomes two. The client must call <b>Release</b> twice on the interface pointer to drop all of its references to the object. </p>
<p>
An illustration of how reference counts are strictly per-interface-pointer occurs when a client calls <b>QueryInterface</b> on the first pointer for either a new interface or the same interface. <i>In either of these cases</i> the client is required to call <b>Release</b> once for each pointer. COM does not require that an object return the same pointer when asked for the same interface multiple times. (The only exception to this is a query to <a href="if_r2z_9dwu.htm"><b>IUnknown</b></a>, which acts as an object's <i>identity</i> to COM.) This allows the object implementation to manage resources efficiently. Thread-safety is also an important issue in implementing <b>AddRef</b> and <b>Release</b>. For more information, see <a href="com_98mr.htm"><b>Processes and Threads</b></a>.</p>
<p>&nbsp;</p></body>
</HTML>
