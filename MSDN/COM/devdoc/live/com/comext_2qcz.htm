<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Lightweight Client-side Handlers</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h2><a name="_com_lightweight_client_side_handlers"></a>Lightweight Client-side Handlers</h2>
<p>
Lightweight client-side handlers allow you to create general client-side handlers of any size, to help you do any kind of standard task. As handlers, these are usable by more than one client. They differ from OLE handlers in that they cannot be created before the server is launched, and their lifetime is tied to that of the proxy manager, preventing a possible race condition in which the handler could otherwise be prematurely released.</p>
<p>
The proxy manager is the object the system creates that implements the <a href="if_f2n_6sh8.htm"><b>IMarshal</b></a> interface. If you, like most developers, use standard marshaling, the system creates it for you when you call <a href="api1_88q4.htm"><b>CoGetStandardMarshal</b></a>, (or the new function for creating an aggregated marshaler for light-weight handlers, <a href="api1_2h14.htm"><b>CoGetStdMarshalEx</b></a>) and also implements the <a href="if_a2e_2sqh.htm"><b>IClientSecurity</b></a> and <a href="if_f2n_58a1.htm"><b>IMultiQI</b></a> interfaces on the object. On the server side, there is a corresponding system object that also implements <a href="if_f2n_6sh8.htm"><b>IMarshal</b></a>, and these objects handle marshaling for you transparently.</p>
<p>
There are two general types of these handlers that you may want to implement:
<ul>
<li>
A handler that performs a service that requires no extra data from the server</li>
<li>
A handler that uses extra data from the server.</li>
</ul>
<p>
Some potential uses of the extra data in the stream supplied by the server are as follows:
<ul>
<li>
Static data from server - regardless of the particular interface being marshaled, the server writes the same data into the stream.</li>
<li>
Per-interface data from server - depending on which particular interface is being marshaled, the server may write different data into the stream.</li>
<li>
Per-interface helpers - per-interface COM components aggregated into the client handler and delegating to the standard proxy. Such a COM component for <a href="if_r2z_4x7x.htm"><b>IStream</b></a> could, for example, do client-side caching of data, read-ahead, write-behind, op-locking, etc. in order to improve network performance. </li>
<li>
Network version of an interface - the basic idea here is that the network version of the interface is different from the interface exposed by the client and server application code. It is possible, for example, to multiplex exposed interfaces IA and IB, over the same network interface INetAB, the way the embedding server handler does.  For example, one could convert a data transfer interface into a network interface that uses pipes for efficient data transfer.</li>
</ul>
<p>
Down level clients may not have the capability to unmarshal interfaces which have custom handlers, for two reasons. First, they may not understand the CLSID used in the custom marshaled packet when the server handler is aggregated and the object wants a handler. Second, the handler code may not even run on the client side anyway since it requires new functionality from COM to create the aggregated standard marshaler, and to do remote QueryInterface calls.  </p>
<p>&nbsp;</p></body>
</HTML>
