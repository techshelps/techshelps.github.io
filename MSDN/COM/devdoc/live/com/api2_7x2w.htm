<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>MkParseDisplayNameEx</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_com_mkparsedisplaynameex"></a>MkParseDisplayNameEx</h1>
<p>
Given a string, this function returns a moniker of the object that the string denotes.</p>
<pre><code><b>HRESULT MkParseDisplayNameEx(
 </b><i> IBindCtx*pbc</i><b>,           </b>//Pointer to the bind context
<b>  LPWSTR </b><i> szDisplayName</i><b>,  </b>//Display name to be parsed
<b>  ULONG</b><i> *pcchEaten</i><b>,       </b>//Pointer to the number of characters of 
                          // the display name successfully parsed
<b>  IMoniker **</b><i> ppmk        </i>//Address of output variable that receives 
                          // the IMoniker interface pointer
<b>);</b>
 </code></pre>
<h4>Parameters</h4>
<dl>
<dt>
<i>pbc</i></dt>
<dd>
[in] Pointer to the bind context in which to accumulate bound objects.</dd>
<dt>
<i>szDisplayName</i></dt>
<dd>
[in] Display name to be parsed.</dd>
<dt>
<i>pcchEaten</i></dt>
<dd>
[out] Pointer to the number of characters of the display name that were successfully parsed. Most useful on syntax error, when a non-zero value is often returned and therefore a subsequent call to <b>MkParseDisplayNameEx</b> with the same <i>pbc</i> and a shortened <i>szDisplayName</i> should return a valid moniker.</dd>
<dt>
<i>ppmk</i></dt>
<dd>
[out] Address of <b>IMoniker</b>* pointer variable that receives the interface pointer to the resulting moniker.
</dd>
</dl>
<h4>Return Values</h4>
<dl>
<dt>
S_OK </dt>
<dd>
The operation was successful.</dd>
<dt>
MK_E_SYNTAX</dt>
<dd>
Parsing failed because <i>szDisplayName</i> could only be partially resolved into a moniker. In this case, *<i>pcchEaten</i> has the number of characters that were successfully parsed into a moniker prefix.</dd>
<dt>
E_OUTOFMEMORY</dt>
<dd>
The operation ran out of memory.
</dd>
</dl>
<h4>Remarks</h4>
<p>
Given a string, this function returns a moniker for the object that the string denotes. This operation is known as parsing. A display name is parsed into a moniker; it is resolved into its component moniker parts.</p>
<p>
If a syntax error occurs, then an indication of how much of the string was successfully parsed is returned in *<i>pcchEaten</i> and NULL is returned through **<i>ppmk</i>. Otherwise, the value returned through *<i>pcchEaten</i> indicates the entire size of the display name.</p>
<p>
This function differs from the original <b>MkParseDisplayName</b> function in that it supports Universal Resource Indicator (URI) syntax. See the IETC RFC1630 specification for more information on URIs.</p>
<p>
Parsing a display name may in some cases be as expensive as binding to the object that it denotes, since, along the way, the parsing mechanism must connect to various non-trivial name space managers (such as a spreadsheet application that can parse into ranges in its sheets). As might be expected, objects are not released by the parsing operation itself, but are instead handed over to the bind context that was passed in through <b>IBindCtx::RegisterObjectBound</b>. Thus, if the moniker resulting from the parse is immediately bound using this same bind context, redundant loading of objects is maximally avoided.</p>
<p>
In many other cases, however, parsing a display name may be quite inexpensive since a single name-space manager may quickly return a moniker that will perform further expensive analysis on any acceptable name during <b>IMoniker::BindToObject</b> or other methods. An example of such an inexpensive parser is the Win32 implementation of a File Moniker. A theoretical example would be a naive URL moniker which parsed from any valid URL strings (i.e., "http:...", "file:...") and only during binding took time to resolve the string against the Internet, a potentially expensive operation.</p>
<p>
The parsing process is an inductive one, in that there is an initial step that gets the process going, followed by the repeated application of an inductive step. At any point after the beginning of the parse, a certain prefix of <i>szDisplayName</i> has been parsed into a moniker, and a suffix of the display name remains unresolved.</p>
<p>
The inductive step asks the moniker-so-far using <b>IMoniker::ParseDisplayName</b> to consume as much as it would like of the remaining suffix and return the corresponding moniker and the new suffix. The moniker is composed onto the end of the existing moniker, and the process repeats.</p>
<p>
Implementations of <b>IMoniker::ParseDisplayName</b> vary in exactly where the knowledge of how to carry out the parsing is kept. Some monikers by their nature are only used in particular kinds of containers. It is likely that these monikers themselves have the knowledge of the legal display name syntax within the objects that they themselves denote, so they can carry out the processes completely within <b>IMoniker::ParseDisplayName</b>. The common case, however, is that the moniker is generic in the sense that is not specific to one kind of container, and thus cannot know the legal syntax for elements within the container. File monikers are an example of these, as are Item Monikers. These monikers in general employ the following strategy to carry out parsing. First, the moniker connects to the class of object that it currently denotes, asking for <b>IParseDisplayName</b> interface. If that succeeds, then it uses the obtained interface pointer to attempt to carry out the parse. If the class refuses to handle the parse, then the moniker binds to the object it denotes, asking again for <b>IParseDisplayName</b> interface. If this fails, then the parse is aborted.</p>
<p>
The effect is that ultimately an object always gets to be in control of the syntax of elements contained inside of itself. It's just that objects of a certain nature can carry out parsing more efficiently by having a moniker or their class do the parsing on their behalf.</p>
<p>
Notice that since <b>MkParseDisplayNameEx </b>knows nothing of the legal syntax of display names (with the exception of the initial parsing step; see below). It is of course beneficial to the user that display names in different contexts not have gratuitously different syntax. While there some rare situations which call for special purpose syntax, it is recommended that, unless there are compelling reasons to do otherwise, the syntax for display names should be the same as or similar to the native file system syntax. The aim is to build on user familiarity. Most important about this are the characters allowed for the delimiters used to separate the display name of one of the component monikers from the next. Unless through some special circumstances they have very good reason not to, all moniker implementations should use inter-moniker delimiters from the following character set:</p>
<p>
\   /   :   !  [</p>
<p>
Standardization in delimiters promotes usability. But more importantly, notice that the parsing algorithm has the characteristic that a given container consumes as much as it can of the string being parsed before passing the remainder on to the designated object inside themselves. If the delimiter expected of the next-to-be-generated moniker in fact forms (part of) a valid display name in the container, then the container's parse will consume it!</p>
<p>
Monikers and objects which have implementations on more than one platform (such as File Monikers) should always parse according to the syntax of the platform on which they are currently running. When asked for their display name, monikers should also show delimiters appropriate to the platform on which they are currently running, even if they were originally created on a different platform. In total, users will always deal with delimiters appropriate for the host platform.</p>
<p>
The initial step of the parsing process is a bit tricky, in that it needs to somehow determine the initial moniker. <b>MkParseDisplayNameEx</b> is omniscient with respect to the syntax with which the display name of a moniker may legally begin, and it uses this omniscience to choose the initial moniker.</p>
<p>
The initial moniker is determined by trying the following strategies in order, using the first to succeed.
<ol>
<li>
"<b>ProgID:" Case:</b><i> </i>If a prefix of <i>szDisplayName</i> conforms to the legal ProgID syntax, is more than 1 character long, and is followed by a colon (':'), the ProgID is converted to a CLSID with <b>CLSIDFromProgID</b><i>, </i>An instance of this class is asked for the <b>IParseDisplayName</b> interface, and <b>IParseDisplayName:ParseDisplayName</b><i> </i>is called with the entire <i>szDisplayName. </i>This case distinguishes <b>MkParseDisplayNameEx</b> from <b>MkParseDisplayName</b>.</li>
<li>
<b>ROT Case:</b> All prefixes of <i>szDisplayName</i> that consist solely of valid file name characters are consulted as file monikers in the Running Object Table.</li>
<li>
<b>File-System Case:</b> The file system is consulted to check if a prefix of <i>szDisplayName</i> matches an existing file. Said file name may be drive absolute, drive relative, working-directory relative, or begin with an explicit network share name. This is a common case.</li>
<li>
<b>"@ProgID" Case:</b> If the initial character of <i>szDisplayName</i> is '@', then the maximal string immediately following the '@' which conforms to the legal ProgID syntax is determined. This is converted to a CLSID with <b>CLSIDFromProgID</b>. An instance of this class is asked in turn for <b>IParseDisplayName</b> interface; the <b>IParseDisplayName</b> interface so found is then given the whole string (starting with the '@') to continue parsing.</li>
</ol>
<h4>QuickInfo</h4>
<p>
<b>&nbsp;&nbsp;Windows NT: </b>Use version 5.0 or later.<br>
<b>&nbsp;&nbsp;Windows: </b>Unsupported.<br>
<b>&nbsp;&nbsp;Windows CE: </b>Unsupported.<br>
<b>&nbsp;&nbsp;Header: </b>Declared in urlmon.h.</p>
<h4>See Also</h4>
<p>
<a href="if_p2q_4t5x.htm"><b>IParseDisplayName</b></a> </p>
<p>
</p>
<p>
</p>
<p>&nbsp;</p></body>
</HTML>
