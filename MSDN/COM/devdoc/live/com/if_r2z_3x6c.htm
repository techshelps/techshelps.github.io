<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>IRunnableObject::SetContainedObject</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h2><a name="_com_irunnableobject_setcontainedobject"></a>IRunnableObject::SetContainedObject</h2>
<p>
Notifies an object that it is embedded in an OLE container, which ensures that reference counting is done correctly for containers that support links to embedded objects.</p>
<pre><code><b>HRESULT SetContainedObject(
  BOOL</b><i> fContained  </i>//Flag indicating whether object is embedded
<b>);</b>
 </code></pre>
<h4>Parameter</h4>
<dl>
<dt>
<i>fContained</i></dt>
<dd>
[in] TRUE specifies that the object is contained in an OLE container. FALSE indicates that it is not.
</dd>
</dl>
<h4>Return Values</h4>
<p>
This method supports the standard return values E_INVALIDARG, E_OUTOFMEMORY AND E_UNEXPECTED, as well as the following:
<dl>
<dt>
S_OK</dt>
<dd>
Object has been marked as a contained embedding.
</dd>
</dl>
<h4>Remarks</h4>
<p>
The <b>IRunnableObject::SetContainedObject</b> method enables a container to inform an object handler that it is embedded in the container, rather than acting as a link. This call changes the container's reference on the object from strong, the default for external connections, to weak. When the object is running visibly, this method is of little significance because the end user has a lock on the object. During a silent update of an embedded link source, however, the container should not be able to hold an object in the running state after the link has been broken. For this reason, the container's reference to the object must be weak.</p>
<h5>Notes to Callers</h5>
<p>
A container application must call <b>IRunnableObject::SetContainedObject</b> if it supports linking to embedded objects. It normally makes the call immediately<b> </b>after calling <a href="api3_1cmc.htm"><b>OleLoad</b></a> or <a href="api3_6y5h.htm"><b>OleCreate</b></a> and never calls the method again, even before it closes. Moreover, a container almost always calls this method with <i>fContained</i> set to TRUE. The use of this method with <i>fContained</i> set to FALSE is rare.</p>
<p>
Calling <b>IRunnableObject::SetContainedObject</b> is optional only when you know that the embedded object will not be referenced by any client other than the container. If your container application does not support linking to embedded objects; it is preferable, but not necessary, to call <b>IRunnableObject::SetContainedObject</b>.</p>
<p>
<a href="api3_9b1w.htm"><b>OleSetContainedObject</b></a><b> </b>is a helper function that conveniently repackages the functionality offered by <b>IRunnableObject::SetContainedObject</b>. With the release of OLE 2.01, the implementation of <b>OleSetContainedObject</b> was changed to call <b>QueryInterface</b>, ask for <a href="if_r2z_4u2c.htm"><b>IRunnableObject</b></a>, and then call <b>IRunnableObject::SetContainedObject</b>. In other words, you can use the interface and the helper function interchangeably.</p>
<h4>QuickInfo</h4>
<p>
<b>&nbsp;&nbsp;Windows NT: </b>Use version 3.1 or later.<br>
<b>&nbsp;&nbsp;Windows: </b>Use Windows 95 or later.<br>
<b>&nbsp;&nbsp;Windows CE: </b>Unsupported.<br>
<b>&nbsp;&nbsp;Header: </b>Declared in objidl.h.</p>
<h4>See Also</h4>
<p>
<a href="api3_9b1w.htm"><b>OleSetContainedObject</b></a>, <a href="api3_8jmt.htm"><b>OleNoteObjectVisible</b></a>, <a href="api1_5ajw.htm"><b>CoLockObjectExternal</b></a> </p>
<p>
</p>
<p>
</p>
<p>&nbsp;</p></body>
</HTML>
