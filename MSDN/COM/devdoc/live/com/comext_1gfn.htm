<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Marshaling Details</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h3><a name="_com_marshaling_details"></a>Marshaling Details</h3>
<p>
If you use standard marshaling, COM handles all of the details described in this section for you. This section is provided for those few programmers who need these details, and for those interested in the underlying information. Marshaling is the process of packaging and unpackaging parameters so a remote procedure call can take place. Different parameter types are marshaled in different ways. For example, marshaling an integer parameter involves simply copying the value into the message buffer (although even in this simple case, there are issues such as byte ordering to deal with in cross-machine calls). Marshaling an array, however, is a more complex process. Array members are copied in a specific order so that the other side can reconstruct the array exactly. When a pointer is marshaled, the data that the pointer is pointing to is copied following rules and conventions for dealing with nested pointers in structures. Unique functions exist to handle the marshaling of each parameter type.</p>
<p>
With standard marshaling, the proxies and stubs are system-wide resources for the interface, and they interact with the channel through a standard protocol. Standard marshaling can be used by both standard COM-defined interfaces and custom interfaces:
<ul>
<li>
In the case of most COM interfaces, the proxies and stubs for standard marshaling are themselves in-process component objects which are loaded from a system-wide DLL provided by COM in OLE32.DLL.</li>
<li>
In the case of custom interfaces, the proxies and stubs for standard marshaling are generated by the interface designer, typically with MIDL. These proxies and stubs are statically configured in the registry, so any potential client can use the custom interface across process boundaries. These proxies and stubs are loaded from a DLL that is located via the system registry using the interface ID (IID) for the custom interface they marshal.</li>
<li>
An alternative to using MIDL to generate proxies and stubs for custom interfaces, a type library can be generated instead and the system provided type library driven marshaling engine will marshal the interface.</li>
</ul>
<p>
As an alternative to standard marshaling, an interface (standard or custom) can use custom marshaling. With custom marshaling, an object dynamically implements the proxies at run-time for each interface that it supports. For any given interface, the object can select COM-provided standard marshaling or custom marshaling. This choice is made by the object on an interface by interface basis. Once the choice is made for a given interface, it remains in effect during the object's lifetime. However one interface on an object can use custom marshaling while another uses standard marshaling.</p>
<p>
Custom marshaling is inherently unique to the object that implements it. It uses proxies implemented by the object and provided to the system on request at run-time. Objects that custom-marshal must implement the <a href="if_f2n_6sh8.htm"><b>IMarshal</b></a> interface, whereas objects that support standard marshaling do not. </p>
<p>
If you decide to write a custom interface, you must provide marshaling support for it. Typically, you will provide a standard marshaling DLL for the interface you design. You can use the tools contained in the <i>Win32 SDK</i> CD to create the proxy/stub code and the proxy/stub DLL. Alternatively, you can use these tools to create a type library which COM will use to do data driven marshaling (using the data in the type library).</p>
<p>
For a client to make a call to an interface method in an object in another process involves the cooperation of several components. The standard proxy is a piece of interface-specific code that resides in the client's process space and prepares the interface parameters for transmittal. It packages, or marshals, them in such a way that they can be re-created and understood in the receiving process. The standard stub, also a piece of interface-specific code, resides in the server's process space and reverses the work of the proxy. The stub unpackages, or unmarshals, the sent parameters and forwards them to the object application. It also packages reply information to send back to the client. </p>
<p>
<b>Note</b>&nbsp;&nbsp;Readers more familiar with RPC than COM may be used to seeing the terms client stub and server stub. These terms are analogous to proxy and stub.</p>
<p>
The following diagram shows the flow of communication between the components involved. On the client side of the process boundary, the client's method call goes through the proxy and then onto the channel. Note that the channel is part of the COM library. The channel sends the buffer containing the marshaled parameters to the RPC run-time library, which transmits it across the process boundary. The RPC run-time and the COM libraries exist on both sides of the process. Note also that the distinction between the channel and the RPC run-time is a characteristic of this implementation and is not part of the programming model or the conceptual model for COM client/server objects. COM servers see only the proxy or stub and, indirectly, the channel. Future implementations may use different layers below the channel or no layers.</p>
<p>
<img src="images/rpc.gif" border=0></p>
<p>
<b>Components of interprocess communications</b></p>
<p>&nbsp;</p></body>
</HTML>
