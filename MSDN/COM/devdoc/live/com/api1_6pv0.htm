<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CoGetClassObjectFromURL</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_com_cogetclassobjectfromurl"></a>CoGetClassObjectFromURL</h1>
<p>
Returns a factory object for a given <i>rclsid</i>. If no <b>CLSID</b> is specified (<b>CLSID_NULL</b>), this function will choose the appropriate <b>CLSID</b> for interpreting the Internet mail extensions (MIME) type specified in <i>szContentType</i>. If the desired object is installed on the system, it is instantiated. Otherwise, the necessary code is downloaded and installed from the location specified in <i>szCodeURL</i>.</p>
<pre><code><b>STDAPI CoGetClassObjectFromURL(
  REFCLSID</b><i> rclsid</i><b>,        </b>//CLSID of the ActiveX object to be 
                          // installed
<b>  LPCWSTR</b><i> szCodeURL</i><b>,      </b>//URL pointing to the code for the ActiveX 
                          // object
<b>  DWORD</b><i> dwFileVersionMS</i><b>,  </b>//Major version number for object to be 
                          // installed
<b>  DWORD</b><i> dwFileVersionLS</i><b>,  </b>//Minor version number for object to be 
                          // installed
<b>  LPCWSTR</b><i> szContentType</i><b>,  </b>//Mime type to be understood by the 
                          // installed ActiveX object
<b>  LPBINDCTX</b><i> pBindCtx</i><b>,     </b>//Bind context to use for 
                          // downloading/installing component code
<b>  DWORD</b><i> dwClsContext</i><b>,     </b>//Specifies the execution context for the 
                          // class object
<b>  LPVOID</b><i> pvReserved</i><b>,      </b>//Reserved, must be set to NULL
<b>  REFIID</b><i> riid</i><b>,            </b>//Interface to obtain on the factory object
<b>  VOID ppv *</b><i> *            </i>//For synchronous calls, pointer to store 
                          // the interface pointer upon return
<b>);</b>
 </code></pre>
<h4>Parameters</h4>
<dl>
<dt>
<i>rclsid</i></dt>
<dd>
[in] The <b>CLSID</b> of the ActiveX object to be installed. If the value is CLSID_NULL, <i>szContentType</i> is used to determine the <b>CLSID</b>.</dd>
<dt>
<i>szCodeURL</i></dt>
<dd>
[in] The URL pointing to the code for the ActiveX object. This can point to a "portable executable" (.OCX, .DLL, .EXE), to an .CAB (cabinet) file, or to a .INF file. If this value is NULL, the Internet Component Download will still attempt to download the desired code from an Object Store on the Internet Search Path.</dd>
<dt>
<i>dwFileVersionMS</i></dt>
<dd>
[in] The major version number for the object to be installed. If this value and the value for <i>dwFileVersionLS</i> are both 0xFFFFFFFF, then it is assumed that the latest version of the code is always desired. This means that Internet Component Download will always attempt to download new code.</dd>
<dt>
<i>dwFileVersionLS</i></dt>
<dd>
[in] The minor version number for the object to be installed. If this value and the value for dwFileVersionMS are both 0xFFFFFFFF, then it is assumed that the latest version of the code is always desired. This means that Internet Component Download will always attempt to download new code.</dd>
<dt>
<i>szContentType</i></dt>
<dd>
[in] The MIME type to be understood by the installed ActiveX object. If <i>rclsid</i> is CLSID_NULL, this string is used to determine the <b>CLSID</b> of the object to be installed. Note that this parameter is only useful when trying to download a viewer for a particular media type, when the MIME type of media is known but the CLSID is not.</dd>
<dt>
<i>pBindCtx</i></dt>
<dd>
[in] The bind context to use for downloading/installing component code. Register <b>IBindStatusCallback</b> in this bind context to receive callbacks during the download and installation process.</dd>
<dt>
<i>dwClsContext</i></dt>
<dd>
[in] Values taken from the <b>CLSCTX</b> enumeration specifying the execution context for the class object.</dd>
<dt>
<i>pvReserved</i></dt>
<dd>
[in] Reserved, must be set to NULL.</dd>
<dt>
<i>riid</i></dt>
<dd>
[in] The interface to obtain on the factory object. Usually, this interface is <b>IClassFactory</b>.</dd>
<dt>
<i>ppv</i></dt>
<dd>
[out] Upon return for synchronous calls, the pointer in which to store the interface pointer.
</dd>
</dl>
<h4>Return Values</h4>
<dl>
<dt>
S_OK</dt>
<dd>
The function was successful; the <i>ppv</i> contains the requested interface pointer.</dd>
<dt>
MK_S_ASYNCHRONOUS</dt>
<dd>
Component code will be downloaded and installed asynchronously. The client will receive notifications through the <b>IBindStatusCallback</b> interface registered on <i>pBindCtx</i>.</dd>
<dt>
E_NOINTERFACE</dt>
<dd>
The desired interface pointer is not available.
</dd>
</dl>
<h4>Remarks</h4>
<p>
Because this function was designed to enable component download in Web browsers, the parameters passed to <b>CoGetClassObjectFromURL</b> closely match the values expressed in the HTML OBJECT tag. For example, <i>szCodeURL</i>, <i>dwFileVersionMS</i>, and <i>dwFileVersionLS</i> are specified inside an OBJECT tag as:</p>
<pre><code>code=http:-/-/www.foo.com/bar.ocx#Version=a,b,c,d
 </code></pre>
<p>
where:</p>
<p>
<i>szCodeURL</i> is HTTP://WWW.FOO.COM/BAR.OCX</p>
<p>
<i>cdFileVersionMS</i> is MAKELONG(B,A)</p>
<p>
<i>dwFileVersionLS</i> is MAKELONG(D,C)</p>
<p>
If the <i>pBindCtx</i> parameter to the function is an asynchronous bind context created by <b>CreateAsyncBindContext</b>, downloading and installation of code occurs asynchronously, and <b>CoGetClassObjectFromURL</b> will return immediately with a return value of MK_S_ASYNCHRONOUS. Then, the <a href="if_a2e_0vxn.htm"><b>IBindStatusCallback</b></a> registered on the asynchronous bind context is used to communicate the status of the download operation to the client. By implementing the <a href="if_a2e_71ik.htm"><b>ICodeInstall</b></a> callback, the client can participate in further negotiation for the download process. To participate in this communication, implement <b>IBindStatusCallback</b> and register this interface in <i>pBindCtx</i> passed to <b>CoGetClassObjectFromURL</b> using <a href="api3_8bvv.htm"><b>RegisterBindStatusCallback</b></a>. Callback notifications will occur from the following:
<dl>
<dt>
<a href="if_a2e_695z.htm"><b>IBindStatusCallback::OnStartBinding</b></a> </dt>
<dd>
Provides an <b>IBinding</b> for controlling the download process.</dd>
<dt>
<a href="if_a2e_35ir.htm"><b>IBindStatusCallback::OnProgress</b></a> </dt>
<dd>
Reports progress on the download process.</dd>
<dt>
<a href="if_a2e_0gf9.htm"><b>IBindStatusCallback::QueryInterface</b></a> </dt>
<dd>
Requests additional interfaces (for example, <b>ICodeInstall</b>) for further negotiation.</dd>
<dt>
<a href="if_a2e_2vz9.htm"><b>IBindStatusCallback::OnObjectAvailable</b></a> </dt>
<dd>
Returns the desired object interface pointer.</dd>
<dt>
<a href="if_a2e_0wh3.htm"><b>IBindStatusCallback::OnStopBinding</b></a> </dt>
<dd>
Returns any error codes.

<p>
<b>Note</b>&nbsp;&nbsp;The initial implementation of <b>CoGetClassObjectFromURL</b> does not support system-wide simultaneous downloading of the same code. Similarly, it will not support cases by which different but simultaneous downloading refers to the same piece of dependent code.

</dd>
</dl>
<h5>Packaging Component Code for Automatic Download</h5>
<p>
There are three ways to package code for download:
<ul>
<li>
As a single PE (portable executable) format file</li>
<li>
By using a .CAB file</li>
<li>
By using a stand-alone .INF file</li>
</ul>
<p>
A single PE is the simplest way to package a single-file OLE control. This single file is downloaded, installed, and registered in one operation. Note, however, that this method will not use file compression and it will not be platform independent, except with HTTP. No packaging is done with this method, the control is simply placed on a server.</p>
<p>
Another alternative to the PE method is to package the control in a .CAB file. Cabinet files are archives of one or more files compressed using Lempel-Ziv compression. Using a .CAB file offers two advantages over the PE format method. .CAB files are compressed, which reduces the time required to download the control. In addition, multiple files can be downloaded. To package the control in a .CAB file, collect all the required files and write an .INF file to provide further installation instructions. The .INF file refers to files in the .CAB and to files at other URLs.</p>
<p>
The third method of packaging is to specify the .INF file that contains directions for downloading and installing the control, rather than specifying the .OCX file directly or by specifying a .CAB file. The primary advantage of this method is that it provides platform independence. The .INF file is downloaded first. It is possible to specify files to download for different target platforms in the .INF file. When the .INF file is interpreted, the appropriate set of files can be downloaded. Using .INF files also offers the most flexibility in downloading the minimum amount of code required to get the control to work. Note, however, that this method does not provide the compression offered by the .CAB method. The following example is used to create a platform-independent .INF file:</p>
<pre><code>[circ3.ocx]
file_win32_x86=file://products/release/circ3/x86/circ3.cab
file_win32_mips=file://products/release/circ3/mips/circ3.cab
file_mac_ppc=ignore
 </code></pre>
<p>
In the example above, the specified component circ3.ocx (CLSID, Version) needs to be installed on the system. If not already in existence, it can be downloaded from the given location (a .CAB). The <b>ignore</b> keyword indicates that this file is not needed for this platform.</p>
<h5>MIME Types</h5>
<p>
The following MIME types are used to describe portable executables (.EXE., .DLL, .OCX), cabinet files (.CAB), and setup scripts (.INF):</p>
<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=37%>File Description</th>
<th align=left width=63%>MIME Type</th>
</tr>
<tr valign=top>
<td width=37%>Portable executable</td>
<td width=63%>application/x-pe-%opersys%-%cpu%</td>
</tr>
<tr valign=top>
<td width=37%>Cabinet files</td>
<td width=63%>application/x-cabinet-%opersys%-%cpu%</td>
</tr>
<tr valign=top>
<td width=37%>Setup scripts</td>
<td width=63%>application/x-setupscript</td>
</tr>
</table><br>
<h5>Registry Settings and Self-Extracting .EXEs</h5>
<p>
Use self-registering code for Internet Component Download. For security purposes, the .INF format used by Component Download does not provide syntax for changing Registry information. For .OCX, .DLL, and .EXE files marked as OleSelfRegister in the Version resource, Component Download will attempt self-registration. For a .DLL., this means loading the .DLL library and calling the <b>DllRegisterServer</b> entry point, if available. For an .EXE, this implies running the .EXE with the run-time parameter of /RegServer. This ensures that COM objects implemented as local servers (winword.exe, for example) are registered correctly. If an object is not marked as OleSelfRegister and registration is necessary, or if it required ot override the OleSelfRegister flat, add the following to an .INF file:</p>
<pre><code>[foo.ocx]
RegisterServer=no; don't register even if marked OleSelfRegister
    or
RegisterServer=yes; register even if not marked OleSelfRegister
 </code></pre>
<p>
Code that is downloaded via Internet Component Download can be a self-extracting .EXE file. This is because Component Download ignores the OleSelfRegister flag if the main URL for points directly to an .EXE file. In this case, it is assumed that this is a self-registering .EXE, and this enables self-extracting .EXEs to work correctly as long as the /regsvr command-line parameter is ignored. While self-extracting .EXEs enable complex setup mechanisms to be launched automatically, any components that are installed will not be automatically tracked by Internet Component Download. These components are permanently installed and are not marked for future cleanup.</p>
<h5>Internet Search Path</h5>
<p>
When Internet Component Download is called to download code, it traverses the Internet Search Path to look for the desired component. This path is a list of Object Store Servers that will be queried every time components are downloaded using <b>CoGetClassObjectFromURL</b>. In this way, even if an OBJECT tag in an HTML document does not specify a <b>CODEBASE</b> location to download code for an embedded OLE control, the Internet Component Download will still use the Internet Search Path to find the required code. The Internet Search Path provides a great deal of flexibility in determining how files get downloaded. By setting up URLs in the path before the <b>CODEBASE</b> keyword, files can be installed from local intranet caches of common components. By removing the <b>CODEBASE</b> keyword from the path completely, component download from the internet is effectively disabled. By setting up URLs in the path after the <b>CODEBASE</b> keyword, files can be installed from standard distribution points, even if the server specified is not available.</p>
<p>
The version number is also considered when locating files. If a version number is specified, the download service will only try to download and install the file if the version number specified is more recent that any version currently installed on the system. If the version number specified is <b>-1</b>,<b> -1</b>,<b>-1</b>,<b>-1</b>, the download service will always try to locate the latest version of the file for download. When searching the Internet Search Path, each Object Store receives an HTTP POST request containing the CLSID or MIME type and, optionally, a version number in the following format:</p>
<pre><code>CLSID={class id}
Version=a,b,c,d
MIMETYPE=mimetype
 </code></pre>
<p>
All of the values are optional, however, either CLSID or MIMETYPE must be present. The Object Store parses this information, checks the internal database of available files, and redirects the HTTP request to the appropriate downloadable file. </p>
<p>
The search path is specified in a string in the Registry, under the following key:</p>
<pre><code>HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\InternetSettings\CodeBaseSearchPath
 </code></pre>
<p>
The value for this key is a string in the following format:</p>
<pre><code>CodeBaseSearchPath=&lt;URL (1) &gt;;&lt;URL (2) &gt;;...&lt;URL (m) &gt;;CODEBASE;&lt;URL (m+1) &gt;;...&lt;URL (n-1) &gt;;&lt;URL (n) &gt;
 </code></pre>
<p>
In the example above, each URL is an absolute URL pointing to HTTP servers acting as Object Stores. When processing a call to <b>CoGetClassObjectFromURL</b>, the Internet Component Download service will first try downloading the desired code from the locations URL (1)  through URL (m) , it will then try the location specified in the <i>szCodeURL</i> parameter, and will finally try the locations specified in locations URL (m+1)  through URL (n) .</p>
<p>
<b>Note</b>&nbsp;&nbsp;If the <b>CODEBASE</b> keyword is not included in the CodeBaseSearchPath key, calls to <b>CoGetClassObjectFromURL</b> will not check the <i>szCodeURL</i> location for downloading code.</p>
<h5>Internet Search Path Without HTTP</h5>
<p>
The Internet Search Path assumes that all object stores on the search path are active HTTP servers, capable of handling HTTP POST requests and querying an object database. Support for object stores on FILE or FTP servers is planned for future versions of Internet Component Download.</p>
<h4>See Also</h4>
<p>
<a href="if_a2e_0vxn.htm"><b>IBindStatusCallback</b></a>,<b> <a href="if_a2e_695z.htm">IBindStatusCallback::OnStartBinding</a></b>,<b> <a href="if_a2e_35ir.htm">IBindStatusCallback::OnProgress</a></b>,<b> <a href="if_a2e_2vz9.htm">IBindStatusCallback::OnObjectAvailable</a></b>,<b> <a href="if_a2e_0wh3.htm">IBindStatusCallback::OnStopBinding</a>, <a href="if_a2e_71ik.htm">ICodeInstall</a></b>,<b> <a href="api3_8bvv.htm">RegisterBindStatusCallback</a></b> </p>
<p>
</p>
<p>
</p>
<p>&nbsp;</p></body>
</HTML>
