<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>IClassFactory::CreateInstance</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h2><a name="_com_iclassfactory_createinstance"></a>IClassFactory::CreateInstance</h2>
<p>
Creates an uninitialized object. </p>
<pre><code><b>HRESULT CreateInstance(
  IUnknown *</b><i> pUnkOuter</i><b>,</b>
<b>                     </b>//Pointer to whether object is or isn't part of 
                     // an aggregate
<b>  REFIID</b><i> riid</i><b>,       </b>//Reference to the identifier of the interface
<b>  void **</b><i> ppvObject  </i>//Address of output variable that receives the 
                     // interface pointer requested in <i>riid</i>
<b>);</b>
 </code></pre>
<h4>Parameters</h4>
<dl>
<dt>
<i>pUnkOuter</i></dt>
<dd>
[in] If the object is being created as part of an aggregate, pointer to the controlling <b>IUnknown</b> interface of the aggregate. Otherwise, <i>pUnkOuter</i> must be NULL. </dd>
<dt>
<i>riid</i></dt>
<dd>
[in] Reference to the identifier of the interface to be used to communicate with the newly created object. If <i>pUnkOuter</i> is NULL, this parameter is frequently the IID of the initializing interface; if <i>pUnkOuter</i> is non-NULL, <i>riid</i> must be <b>IID_IUnknown</b> (defined in the header as the IID for <b>IUnknown</b>).</dd>
<dt>
<i>ppvObject</i></dt>
<dd>
[out] Address of pointer variable that receives the interface pointer requested in <i>riid</i>. Upon successful return, *<i>ppvObject</i> contains the requested interface pointer. If the object does not support the interface specified in <i>riid</i>, the implementation must set *<i>ppvObject</i> to NULL.
</dd>
</dl>
<h4>Return Values</h4>
<p>
This method supports the standard return values E_UNEXPECTED, E_OUTOFMEMORY, and E_INVALIDARG, as well as the following: 
<dl>
<dt>
S_OK</dt>
<dd>
The specified object was created.</dd>
<dt>
CLASS_E_NOAGGREGATION</dt>
<dd>
The <i>pUnkOuter</i> parameter was non-NULL and the object does not support aggregation.</dd>
<dt>
E_NOINTERFACE</dt>
<dd>
The object that <i>ppvObject</i> points to does not support the interface identified by <i>riid</i>.
</dd>
</dl>
<h4>Remarks</h4>
<p>
The <a href="if_a2e_9mk9.htm"><b>IClassFactory</b></a> interface is always on a class object. The <b>CreateInstance</b> method creates an uninitialized object of the class identified with the specified CLSID. When an object is created in this way, the CLSID must be registered in the system registry with <b>CoRegisterClassObject</b>.</p>
<p>
The <i>pUnkOuter</i> parameter indicates whether the object is being created as part of an aggregate. Object definitions are not required to support aggregation — they must be specifically designed and implemented to support it. </p>
<p>
The <i>riid</i> parameter specifies the IID (interface identifier) of the interface through which you will communicate with the new object. If <i>pUnkOuter</i> is non-NULL (indicating aggregation), the value of the <i>riid</i> parameter must be <b>IID_IUnknown</b>. If the object is not part of an aggregate, <i>riid</i> often specifies the interface though which the object will be initialized. </p>
<p>
For OLE embeddings, the initialization interface is <a href="if_p2q_8crp.htm"><b>IPersistStorage</b></a>, but in other situations, other interfaces are used. To initialize the object, there must be a subsequent call to an appropriate method in the initializing interface. Common initialization functions include <a href="if_p2q_7hyv.htm"><b>IPersistStorage::InitNew</b></a> (for new, blank embeddable components), <a href="if_p2q_34pw.htm"><b>IPersistStorage::Load</b></a> (for reloaded embeddable components), <a href="if_p2q_54f8.htm"><b>IPersistStream::Load</b></a>, (for objects stored in a stream object) or <a href="if_p2q_0p7o.htm"><b>IPersistFile::Load</b></a> (for objects stored in a file).</p>
<p>
In general, if an application supports only one class of objects, and the class object is registered for single use, only one object can be created. The application must not create other objects, and a request to do so should return an error from <b>IClassFactory::CreateInstance</b>. The same is true for applications that support multiple classes, each with a class object registered for single use; a <b>CreateInstance</b> for one class followed by a <b>CreateInstance</b> for any of the classes should return an error.</p>
<p>
To avoid returning an error, applications that support multiple classes with single-use class objects can revoke the registered class object of the first class by calling <a href="api1_9y9g.htm"><b>CoRevokeClassObject</b></a><b> </b>when a request for instantiating a second is received. For example, suppose there are two classes, A and B. When <b>IClassFactory::CreateInstance</b> is called for class A, revoke the class object for B. When B is created, revoke the class object for A. This solution complicates shutdown because one of the class objects might have already been revoked (and cannot be revoked twice).</p>
<h4>QuickInfo</h4>
<p>
<b>&nbsp;&nbsp;Windows NT: </b>Use version 3.1 or later.<br>
<b>&nbsp;&nbsp;Windows: </b>Use Windows 95 or later.<br>
<b>&nbsp;&nbsp;Windows CE: </b>Unsupported.<br>
<b>&nbsp;&nbsp;Header: </b>Declared in unknwn.h.</p>
<h4>See Also</h4>
<p>
<a href="api1_6kz8.htm"><b>CoRegisterClassObject</b></a>, <a href="api1_9y9g.htm"><b>CoRevokeClassObject</b></a>, <a href="api1_1nad.htm"><b>CoCreateInstance</b></a>, <a href="api1_6yb8.htm"><b>CoGetClassObject</b></a> </p>
<p>
</p>
<p>
</p>
<p>&nbsp;</p></body>
</HTML>
