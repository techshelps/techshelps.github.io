<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>IGlobalInterfaceTable</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_com_iglobalinterfacetable"></a>IGlobalInterfaceTable</h1>
<p>
<span style=color:#FF0000>[New for Windows NT 4.0 Service Pack 3.]</span> </p>
<p>
Allows any apartment (either single- or multi-threaded) in a process to get access to an interface implemented on an object in any other apartment in the process. There are three methods, which allow you to register an interface as global (process-wide), to get a pointer to that interface from any other apartment through a "cookie", and to revoke the global registration. </p>
<p>
This interface can be an efficient way for a process to store an interface pointer in a memory that may be accessed from multiple apartments within the process, such as process global variables and free-threaded objects containing interface pointers to non-free-threading objects. This mechanism is not portable across process or machine boundaries, so cannot be use in place of the normal parameter passing mechanism.</p>
<p>
<b>Note</b>&nbsp;&nbsp;This is available only on Windows NT 4.0, Service Pack 3 and later. It is not available on Windows95.</p>
<h4>When to Implement</h4>
<p>
You should not implement this interface. The standard implementation provides complete thread-safe functionality.</p>
<h4>When to Use</h4>
<p>
When an interface implemented on an object in one apartment must be stored in memory accessible for use by other apartments, use this interface. To create the global interface table object, and get a pointer to this interface, call</p>
<pre><code>CoCreateInstance(CLSID_StdGlobalInterfaceTable,
                            NULL,
                            CLSCTX_INPROC_SERVER,
                            IID_IGlobalInterfaceTable,
                            (void **)&amp;gpGIT)
 </code></pre>
<p>
There is a single instance of the Global Interface table per process, so all calls to this function in a process return the same instance. </p>
<p>
After the call to the <a href="api1_1nad.htm"><b>CoCreateInstance</b></a>, register the interface of interest from the apartment in which it resides with a call to the <b>RegisterInterfaceInGlobal</b> method. This supplies a "cookie" that identifies the interface and its location. An apartment that wants a pointer to this interface then calls the <b>GetInterfaceFromGlobal</b> method with this cookie, and the implementation then supplies an interface pointer to the calling apartment in the proper way. To revoke the global registration, any apartment may call the <b>RevokeInterfaceFromGlobal</b> method.</p>
<p>
A simple example of its use would be when you want to pass an interface pointer on an object in a single-threaded apartment (STA) to a worker thread in another apartment. Rather than having to marshal it into a stream and pass the stream to the worker thread as a thread parameter, this interface allows you to simply pass a cookie. When you register the interface in the global interface table, you get a cookie that you can use instead of passing the actual pointer whenever you need to pass the pointer either to a non-method parameter that is going to another apartment (as a parameter to <b>ThreadProc</b> via <b>CreateThread</b>), or to in-process memory accessible outside your apartment.</p>
<p>
Care is, of course, required, because using globals places the extra burden on the programmer of managing problems such as race conditions, mutual exclusion, etc., which are associated with accessing global state from multiple threads simultaneously.</p>
<p>
This interface also makes another previously difficult problem simpler for the programmer to deal with. This occurs when an in-process free-threaded object aggregates the free-threaded marshaler and also holds (as member variables) interface pointers to other objects which themselves are not free-threaded and do not aggregate the free-threaded marshaler.  If the outer object gets marshaled to another apartment and the application calls on it, and the object tries to call on any of its member variable interface pointers that are not free-threaded or are proxies to objects in other apartments, it may get incorrect results or the error RPC_E_WRONG_THREAD, since the inner interface is only designed to be callable from the apartment in which it was first stored in the member variable. </p>
<p>
To solve this problem, the outer object aggregating the free-threaded marshaler should call the <b>RegisterInterfaceInGlobal</b> method on the inner interface and store the resulting cookie in its member variable instead of storing the actual interface pointer. When the outer object wants to call on an inner object's interface pointer, it should call <b>GetInterfaceFromGlobal</b>, use the returned interface pointer, then <b>Release</b> it. When the outer object goes away, it should call <b>RevokeInterfaceFromGlobal</b> to remove the interface from the global interface table.</p>
<h4>Methods in Vtable Order</h4>
<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=48%>IUnknown Methods</th>
<th align=left width=52%>Description</th>
</tr>
<tr valign=top>
<td width=48%><a href="if_r2z_7fvp.htm"><b>QueryInterface</b></a></td>
<td width=52%>Returns pointers to supported interfaces.</td>
</tr>
<tr valign=top>
<td width=48%><a href="if_r2z_3rja.htm"><b>AddRef</b></a></td>
<td width=52%>Increments the reference count.</td>
</tr>
<tr valign=top>
<td width=48%><a href="if_r2z_59np.htm"><b>Release</b></a></td>
<td width=52%>Decrements the reference count.</td>
</tr>
</table><br>
<table cellspacing=4 cols=2>
<tr valign=top>
<td width=48%><b>IGlobalInterfaceTable</b> <b>Methods</b></td>
<td width=52%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=48%><a href="if_f2n_7lt8.htm"><b>RegisterInterfaceInGlobal</b></a></td>
<td width=52%>Permits access to a given interface from any apartment in a process</td>
</tr>
<tr valign=top>
<td width=48%><a href="if_f2n_8bsc.htm"><b>RevokeInterfaceFromGlobal</b></a></td>
<td width=52%>Revokes the registration of a global (process-wide) interface</td>
</tr>
<tr valign=top>
<td width=48%><a href="if_f2n_77e4.htm"><b>GetInterfaceFromGlobal</b></a></td>
<td width=52%>Gives the calling apartment access to an interface registered as global</td>
</tr>
</table><br>
<h4>QuickInfo</h4>
<p>
<b>&nbsp;&nbsp;Windows NT: </b>Use version 5.0 or later.<br>
<b>&nbsp;&nbsp;Windows: </b>Unsupported.<br>
<b>&nbsp;&nbsp;Windows CE: </b>Unsupported.<br>
<b>&nbsp;&nbsp;Header: </b>Declared in objidl.h.</p>
<p>&nbsp;</p></body>
</HTML>
