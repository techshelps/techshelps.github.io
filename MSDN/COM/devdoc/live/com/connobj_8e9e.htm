<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Using IConnectionPointContainer</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h2><a name="_com_using_iconnectionpointcontainer"></a>Using IConnectionPointContainer</h2>
<p>
A connectable object implements <b>IConnectionPointContainer </b>(and exposes it through <b>QueryInterface</b>) to indicate the existence of outgoing interfaces. For each outgoing interface, the connectable object manages a connection point sub-object which itself implements <b>IConnectionPoint.</b> The connectable object therefore contains the connection points, hence the naming of <b>IConnectionPointContainer</b> and <b>IConnectionPoint</b>.</p>
<p>
Through <b>IConnectionPointContainer</b>, a client can perform two operations. First, if the client already has the IID for an outgoing interface that it supports, it can locate the corresponding connection point for the IID using <b>FindConnectionPoint</b>. The client cannot query for the connection point directly because of the container/contained relationship between the connectable object and its contained connection points. In essence, <b>FindConnectionPoint</b> is the <b>QueryInterface</b> for outgoing interfaces when the IID is known to the client.</p>
<p>
Second, the client can enumerate all connection points within the connectable object through <b>IConnectionPointContainer::EnumConnectionPoints</b>. This method returns an <b>IEnumConnectionPoints</b> interface pointer for a separate enumerator object. Through <b>IEnumConnectionPoints::Next</b> the client can obtain <b>IConnectionPoint</b> interface pointers to each connection point.</p>
<p>
Once the client obtains the <b>IConnectionPoint</b> interface, it must call <b>IConnectionPoint::GetConnectionInterface</b> to determine the IID of the outgoing interface supported by each connection point. If the client already supports that outgoing interface, it can establish a connection. Otherwise, it may still be able to support the outgoing interface using information from the connectable object's type library to provide support at run-time. This technique requires that the connectable object support the <b>IProvideClassInfo</b> interface as described below.</p>
<p>
<b>Note</b>&nbsp;&nbsp;Because the enumerator is a separate object, the client must call <b>IEnumConnectionPoints::Release</b> when the enumerator is no longer needed.</p>
<p>
In addition, each connection point is an object with a separate reference count from the containing connectable object. Therefore, the client must also call <b>IConnectionPoint::Release </b>for each connection point accessed through either the enumerator or through <b>FindConnectionPoint</b>.</p>
<p>&nbsp;</p></body>
</HTML>
