<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>URLOpenPullStream</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_com_urlopenpullstream"></a>URLOpenPullStream</h1>
<p>
Creates a pull-type stream object from a URL.</p>
<pre><code><b>HRESULT URLOpenPullStream(
  LPUNKNOWN</b><i> pCaller</i><b>,  </b>// Caller's controlling <a href="if_r2z_9dwu.htm">IUnknown</a> 
<b>  LPCWSTR</b><i> szURL</i><b>,      </b>// URL to be converted to stream
<b>  DWORD</b><i> dwResv</i><b>,       </b>// Reserved for future use
<b>  LPBINDSTATUSCALLBACK</b><i> lpfnCB</i>
<i>                      </i>// Caller's <a href="if_a2e_0vxn.htm">IBindStatusCallback</a> 
<b>);</b>
 </code></pre>
<h4>Parameters</h4>
<dl>
<dt>
<i>pCaller</i></dt>
<dd>
[] Pointer to the caller's controlling <b>IUnknown</b>. If the caller is not an ActiveX component, this value may be set to NULL</dd>
<dt>
<i>szURL</i></dt>
<dd>
[out] The URL to be converted to a stream object. Cannot be NULL.</dd>
<dt>
<i>dwResv</i></dt>
<dd>
[in] Reserved for future use. Must be zero.</dd>
<dt>
<i>lpfnCB</i></dt>
<dd>
[in] Pointer to caller's <b>IBindStatusCallback</b> interface</dd>
</dl>
<h4>Return Values</h4>
<p>
This function returns the same values as <b>IBindHost::MonikerBindToStorage</b>.</p>
<h4>Remarks</h4>
<p>
If <i>pCaller</i> is non-NULL, the caller is a COM object that is contained in another component, such as an ActiveX Control in the context of an HTML page.In this case, the function attempts the download in the context of the ActiveX client framework and allows the caller's container to receive callbacks on the progress of the download.</p>
<p>
<b>URLOpenPullStream</b> calls <a href="if_a2e_0x2d.htm"><b>IBindStatusCallback::OnDataAvailable</b></a> every time data arrives from the Internet. <b>OnDataAvailable</b> can return E_ABORT to abort the download. When the callback is invoked and the <i>pstm</i> member of the STGMEDIUM structure is not NULL, the caller can read from the stream the amount of data specified in the <i>dwSize</i> argument passed with the <b>OnDataAvailable</b> call. If the caller does not read the full amount or does not call <a href="if_r2z_14mc.htm"><b>ISequentialStream::Read</b></a> at all, OnDataAvailable is not called again until this happens and <b>Read</b> returns E_PENDING.The pull model is slightly more cumbersome than the push model, but it the client gives total control over the download operation.</p>
<p>
The logic in the following code fragment is a typical implementation of <b>OnDataAvailable</b> as it is used by the <b>URLOpenPullStream</b> function: </p>
<pre><code>HRESULT CMyBindStatusCallback::OnDataAvailable( ...)
{
    HRESULT hr = NOERROR;
    DWORD dwAmountToRead = dwSize - g_readSoFar;
    BYTE * buffer = new BYTE[ dwAmountToRead ];
    while( TRUE )
    {
        DWORD dwRead;
        hr = pstgmed-&gt;pstrm-&gt;Read( buffer, dwAmountToRead, &amp;dwRead );
        if( hr == E_PENDING )
        {
            // we'll get notified again when more data comes
            return(NOERROR);
        }
        if( SUCCEEDED(hr) )
        {
            // ok, process bits ....
            // keep looping
        }
        else
        {
            // we have an error...
            return(hr);
        }
    }
}
 </code></pre>
<h4>QuickInfo</h4>
<p>
<b>&nbsp;&nbsp;Windows NT: </b>Use version 5.0 or later.<br>
<b>&nbsp;&nbsp;Windows: </b>Unsupported.<br>
<b>&nbsp;&nbsp;Windows CE: </b>Unsupported.<br>
<b>&nbsp;&nbsp;Header: </b>Declared in urlmon.h.</p>
<h4>See Also</h4>
<p>
<a href="if_a2e_0vxn.htm"><b>IBindStatusCallback</b></a>, <a href="if_a2e_0x2d.htm"><b>IBindStatusCallback::OnDataAvailable</b></a>, <a href="if_r2z_4x7x.htm"><b>IStream</b></a>, <a href="if_r2z_1k19.htm"><b>ISequentialStream</b></a>, <a href="if_r2z_14mc.htm"><b>ISequentialStream::Read</b></a> </p>
<p>
</p>
<p>
</p>
<p>&nbsp;</p></body>
</HTML>
