<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>STAT_CHUNK</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_com_stat_chunk_str"></a>STAT_CHUNK</h1>
<p>
The <b>STAT_CHUNK</b> structure describes a chunk. </p>
<pre><code>typedef struct tagSTAT_CHUNK
{
    ULONG              idChunk;
    CHUNK_BREAKTYPE    breakType;
    CHUNKSTATE         flags;
    LCID               locale;
    FULLPROPSPEC       attribute;
    ULONG              idChunkSource;
    ULONG              cwcStartSource;
    ULONG              cwcLenSource;
} STAT_CHUNK;
 </code></pre>
<h4>Members</h4>
<dl>
<dt>
<b>idChunk</b></dt>
<dd>
The chunk identifier. Chunk identifiers must be unique for the current instantiation of <b>IFilter</b>. Chunk Identifiers must be in increasing order. the order in which chunks are numbered should correspond to the order in which they appear in the source document. Some search engines may take advantage of the inter-attribute proximity exposed between chunks of various attributes. If so, the order in which chunks with different attributes are emitted will be important to the search engine.</dd>
<dt>
<b>breakType</b></dt>
<dd>
The type of break that separates the previous chunk from the current chunk. Values are from the CHUNK_BREAKTYPE enumeration. </dd>
<dt>
<b>flags</b></dt>
<dd>
Flags indicate whether this chunk contains text or a non-text attribute value. Values are taken from the <a href="enums_8bzh.htm"><b>CHUNKSTATE</b></a> enumeration. If the CHUNK_TEXT flag is set, <a href="if_f2n_08s4.htm"><b>IFilter::GetText</b></a> should be used to retrieve the contents of the chunk and parse it as a series of words. If the CHUNK_VALUE flag is set,  <a href="if_f2n_19ut.htm"><b>IFilter::GetValue</b></a> should be used to retrieve the value and treat it as a single property value. If the filter wishes the same text to be treated as both text and value it should be emitted twice in two different chunks, each with one flag set. </dd>
<dt>
<b>locale</b></dt>
<dd>
The language and sub-language associated with a chunk of text. Chunk locale<i> </i>will be used by document indexers to perform proper word breaking of text. If the chunk is neither text nor a non-text attribute value of type VT_LPWSTR, VT_LPSTR or VT_BSTR, this field is ignored</dd>
<dt>
<b>attribute</b></dt>
<dd>
The attribute to be applied to the chunk. If a filter wishes the same text to have more than one attribute, it needs to emit the text once for each attribute in separate chunks.
<p>
Following is an example of this that might come from a book:

<p class=indent1>
The small detective exclaimed, "C'est finis!"</p>

<p>
<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Confessions</b>

<p class=indent1>
The room was silent for several minutes. After thinking very hard about it, the young woman asked, "But how did you know?"</p>

<p>
This section might be broken into chunks as follows:


<table cellspacing=4 cols=6>
<tr valign=top>
<th align=left width=7%>ID</th>
<th align=left width=20%>Text</th>
<th align=left width=21%>breakType</th>
<th align=left width=15%>flags</th>
<th align=left width=18%>locale</th>
<th align=left width=19%>attribute</th>
</tr>
<tr valign=top>
<td width=7%>1</td>
<td width=20%>The small dete</td>
<td width=21%>N/A</td>
<td width=15%>CHUNK_TEXT</td>
<td width=18%>ENGLISH_UK</td>
<td width=19%>CONTENT</td>
</tr>
<tr valign=top>
<td width=7%>2</td>
<td width=20%>ctive exclaimed,</td>
<td width=21%>CHUNK_NO_<br>
BREAK</td>
<td width=15%>N/A</td>
<td width=18%>N/A</td>
<td width=19%>N/A</td>
</tr>
<tr valign=top>
<td width=7%>3</td>
<td width=20%>"C'est finis!"</td>
<td width=21%>CHUNK_EOW</td>
<td width=15%>CHUNK_TEXT</td>
<td width=18%>FRENCH_BELGIAN</td>
<td width=19%>CONTENT</td>
</tr>
<tr valign=top>
<td width=7%>4</td>
<td width=20%>Confessions</td>
<td width=21%>CHUNK_EOC</td>
<td width=15%>CHUNK_TEXT</td>
<td width=18%>ENGLISH_UK</td>
<td width=19%>CHAPTER_<br>
NAMES</td>
</tr>
<tr valign=top>
<td width=7%>5</td>
<td width=20%>Confessions</td>
<td width=21%>CHUNK_EOP</td>
<td width=15%>CHUNK_TEXT</td>
<td width=18%>ENGLISH_UK</td>
<td width=19%>CONTENT</td>
</tr>
<tr valign=top>
<td width=7%>6</td>
<td width=20%>The room was silent for several minutes.</td>
<td width=21%>CHUNK_EOP</td>
<td width=15%>CHUNK_TEXT</td>
<td width=18%>ENGLISH_UK</td>
<td width=19%>CONTENT</td>
</tr>
<tr valign=top>
<td width=7%>7</td>
<td width=20%>After thinking very hard about it, the young woman asked, "But how did you know?"</td>
<td width=21%>CHUNK_EOS</td>
<td width=15%>CHUNK_TEXT</td>
<td width=18%>ENGLISH_UK</td>
<td width=19%>CONTENT</td>
</tr>
</table><br>

</dd>
</dl>
<p>
The following three fields are used to describe the source of a derived chunk, that is, one that can be mapped back to a section of contents. For example, the heading of a chapter is both contents and a special type of contents — heading; heading would be a derived chunk. If the text of the current non-contents chunk (psuedo-property or property) is derived from some contents chunk, then:
<dl>
<dt>
<b>idChunkSource</b></dt>
<dd>
the identifier of the source of a derived chunk.</dd>
<dt>
<b>cwcStartSource</b></dt>
<dd>
The offset from which the source text for a derived chunk starts in the source chunk.</dd>
<dt>
<b>cwcLenSource</b></dt>
<dd>
The length in characters of  the source text from which the current chunk was derived. A zero value signifies that there is character-by-character correspondence between the source text and the derived text. A non-zero value means that there is no such direct correspondence. 
</dd>
</dl>
<h4>Remarks</h4>
<p>
Information provided by <b>idChunkSource</b>, <b>cwcStartSource</b>, and <b>cwcLenSource</b><i> </i>is useful for a search engine that highlights hits. If the query is done for a pseudoproperty, the search engine will highlight the original text from which the text of the pseudoproperty has been derived. For instance, for a C++ code filter, when searching for MyFunction in pseudoproperty "function definitions," the browser will highlight the function header in the file. If the chunk is not derived, <b>idChunkSource</b> must be the same as <b>idChunk</b>. If the filter attributes specify a pseudoproperty only, then there is no content chunk from which the current pseudoproperty chunk is derived. In this case, <b>idChunkSource</b> must be set to 0, which is an invalid chunk id.</p>
<h4>QuickInfo</h4>
<p>
<b>&nbsp;&nbsp;Windows NT: </b>Use version 5.0 or later.<br>
<b>&nbsp;&nbsp;Windows: </b>Unsupported.<br>
<b>&nbsp;&nbsp;Windows CE: </b>Unsupported.<br>
<b>&nbsp;&nbsp;Header: </b>Declared in filter.h.</p>
<h4>See Also</h4>
<p>
<a href="if_f2n_93l7.htm"><b>IFilter::GetChunk</b></a>, <a href="if_f2n_08s4.htm"><b>IFilter::GetText</b></a>, <a href="if_f2n_19ut.htm"><b>IFilter::GetValue</b></a>, <a href="enums_27ql.htm"><b>CHUNK_BREAKTYPE</b></a></p>
<p>&nbsp;</p></body>
</HTML>
