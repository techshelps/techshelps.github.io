<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Factors that Determine IUnknown Security</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h3><a name="_com_factors_that_determine_iunknown_security"></a>Factors that Determine IUnknown Security</h3>
<p>
Three factors determine the security settings for <b>IUnknown</b>:
<ul>
<li>
Whether secure reference counting has been set. </li>
<li>
Whether <a href="api1_9sj8.htm"><b>CoSetProxyBlanket</b></a> is called on <b>IUnknown.</b></li>
<li>
Default security settings. </li>
</ul>
<p>
Setting secure reference counting tells COM to authenticate distributed <b>AddRef </b>and <b>Release </b>calls. To set secure reference calls, specify the EOAC_SECURE_REFS capability flag in a call to <b>CoInitializeSecurity</b>. For legacy applications, the <a href="reg_42sz.htm"><b>LegacySecureReferences</b></a> key in the registry can be used to enable secure reference counting. You can also use Dcomcnfg.exe to enable secure reference counting as a machine-wide default setting (see <a href="comext_4kbr.htm"><b>Setting Machine-wide Reference Tracking</b></a>). When secure reference counting is enabled, COM keeps per user reference counts so that a user can only call <b>Release</b> on objects that the user had previously called <b>AddRef </b>on. Although secure reference counting can decrease performance, it ensures that no matter how many times a given user calls Release, the objects and stubs will still exist if someone else has a reference to them. </p>
<p>
If secure reference counting is enabled, <b>IUnknown</b> always uses default security settings. In this case, calls to <b>CoSetProxyBlanket</b> on <b>IUnknown</b> will fail.</p>
<p>
If secure reference counting is turned off, the application can change the security settings for <b>IUnknown</b> by calling <b>CoSetProxyBlanket</b> on <b>IUnknown</b>. In this case, the specified security settings will be used for all future calls to <b>IUnknown</b> on any proxy on that object. To change the security settings for <b>IUnknown</b>, you must first call <b>QueryInterface </b>for <b>IUnknown</b> and then call <b>CoSetProxyBlanket</b> on the returned interface pointer, which is a pointer to the proxy manager. If you call <b>CoSetProxyBlanket</b> on any other interface, security settings for <b>IUnknown</b> will not be affected. Prior to Windows NT 4.0 SP 4, calls to <b>CoSetProxyBlanket</b> on <b>IUnknown</b> only affected <b>QueryInterface</b>, not <b>AddRef </b>or <b>Release</b>.</p>
<p>
If secure reference counting is turned off and <b>CoSetProxyBlanket</b> was not called on <b>IUnknown</b>, <b>IUnknown</b> has the default security settings. For example, suppose the client called <a href="api1_8ayh.htm"><b>CoInitializeSecurity</b></a> with authentication level RPC_C_AUTHN_LEVEL_CONNECT and impersonation level RPC_C_IMP_LEVEL_IDENTIFY. But the server called <b>CoInitializeSecurity</b> using the encrypt authentication level (RPC_C_AUTHN_LEVEL_PKT_PRIVACY) and impersonation level RPC_C_IMP_LEVEL_IMPERSONATE. In this case, calls to <b>IUnknown</b> would be made at encrypt and identify, which are the negotiated default security settings.</p>
<p>&nbsp;</p></body>
</HTML>
