<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>StgOpenStorageEx</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_com_stgopenstorageex"></a>StgOpenStorageEx</h1>
<p>
<span style=color:#FF0000>[This is preliminary documentation and subject to change.]</span> </p>
<p>
Opens an existing root storage object in the file system. You can use this function to open compound files and regular files. Nested storage objects can only be opened using their parent's <a href="if_r2z_182t.htm"><b>IStorage::OpenStorage</b></a><b> </b>method.</p>
<pre><code><b>HRESULT StgOpenStorageEx(
  const WCHAR *</b><i> pwcsName</i><b>,</b>   //Points to the path of the file 
                            // containing storage object
<b>  DWORD</b><i> grfMode</i><b>,</b>         //Specifies the access mode for the object
<b>  STGFMT</b><i> stgfmt</i><b>,</b>        //Specifies the storage file format
<b>  DWORD</b><i> grfAttrs</i><b>,</b>        //Reserved; must be zero
<b>  void *</b><i> reserved1</i><b>,</b>        //Reserved; must be zero
<b>  void *</b><i> reserved2</i><b>,</b>        //Reserved; must be zero
<b>  REFIID</b><i> riid</i><b>,</b>        //Specifies the GUID of the interface pointer
<b>  void **</b><i> ppObjectOpen</i><b>,</b>        //Address of an interface pointer
<b>);</b>
 </code></pre>
<h4>Parameters</h4>
<dl>
<dt>
<i>pwcsName</i></dt>
<dd>
[in] Points to the path of the file containing the storage object.</dd>
<dt>
<i>grfMode</i></dt>
<dd>
[in] Specifies the access mode to use when opening the storage object. For more information, see the <a href="enums_1ktp.htm"><b>STGM</b></a> enumeration. If the caller specifies transacted mode together with STGM_CREATE or STGM_CONVERT, the overwrite or conversion takes place at the time the storage object is opened and therefore is not revertible.</dd>
<dt>
<i>stgfmt</i></dt>
<dd>
[in] Specifies the storage file format. For more information, see the <a href="enums_4xx0.htm"><b>STGFMT</b></a> enumeration. </dd>
<dt>
<i>grfAttrs</i></dt>
<dd>
[in] Reserved for future use; must be zero.</dd>
<dt>
<i>reserved1</i></dt>
<dd>
[in] Reserved for future use; must be zero.</dd>
<dt>
<i>reserved2</i></dt>
<dd>
[in] Reserved for future use; must be zero.</dd>
<dt>
<i>riid</i></dt>
<dd>
[in] Specifies the GUID of the interface pointer to return.</dd>
<dt>
<i>ppObjectOpen</i></dt>
<dd>
[out] Address of an interface pointer variable that receives a pointer for an interface on the storage object being opened; contains NULL if operation failed. </dd>
</dl>
<h4>Return Values</h4>
<dl>
<dt>
S_OK</dt>
<dd>
Indicates the storage object was successfully opened.</dd>
<dt>
STG_E_INVALIDPOINTER </dt>
<dd>
Indicates bad pointer in the <i>ppObjectOpen</i> parameter.</dd>
<dt>
STG_E_INVALIDPARAMETER </dt>
<dd>
Indicates invalid value for the <i>grfAttrs, reserved1, reserved2, grfMode, </i>or<i> stgfmt </i>parameters.</dd>
<dt>
E_NOINTERFACE</dt>
<dd>
Indicates that the specified interface is not supported.</dd>
<dt>
STG_E_INVALIDFLAG</dt>
<dd>
Indicates bad flag combination in the <i>grfMode</i> pointer (includes both STGM_DELETEONRELEASE and STGM_CONVERT flags).</dd>
<dt>
STG_E_INVALIDNAME</dt>
<dd>
Indicates bad name in the <i>pwcsName</i> parameter.</dd>
<dt>
STG_E_INVALIDFUNCTION</dt>
<dd>
Indicates the <i>grfMode</i> is set to STGM_DELETEONRELEASE.</dd>
<dt>
STG_E_LOCKVIOLATION</dt>
<dd>
Access denied because another caller has the file open and locked.</dd>
<dt>
STG_E_SHAREVIOLATION</dt>
<dd>
Access denied because another caller has the file open and locked.</dd>
<dt>
STG_E_UNIMPLEMENTEDFUNCTION</dt>
<dd>
Indicates the <b>StgOpenStorageEx</b> function is not implemented by the operating system. In this case, use the <b>StgOpenStorage</b> function instead.</dd>
</dl>
<p>
This function can also return any file system errors or Win32 errors wrapped in an HRESULT.</p>
<h4>Remarks</h4>
<p>
<b>StgOpenStorageEx</b> is a superset of the <b>StgOpenStorage</b> function, and should be used by new code. Future enhancements to Windows structured storage will be exposed through this function.</p>
<p>
The <b>StgOpenStorageEx</b> function opens the specified root storage object according to the access mode in the <i>grfMode</i> parameter, and, if successful, supplies an interface pointer for the opened storage object in the <i>ppObjectOpen</i> parameter.</p>
<p>
When you open a file, the system selects a structured storage implementation depending on what <b>STGFMT</b> flag you specify and on what type of drive the file is stored. See the <a href="enums_4xx0.htm"><b>STGFMT</b></a> documentation for more information.</p>
<p>
You can use the <b>StgOpenStorageEx</b> function to get access to the root storage of a structured storage document, the contents stream of a flat file, or the property set storage of any file that supports property sets. For information about which interface identifiers (IIDs) are supported for the different <b>STGFMT</b> values, see the <a href="enums_4xx0.htm"><b>STGFMT</b></a> enumeration. </p>
<p>
To support the simple mode for saving a storage object with no substorages, the <b>StgOpenStorageEx</b> function accepts the following flag combinations as valid modes in the <i>grfMode</i> parameter: STGM_SIMPLE|STGM_READWRITE|STGM_SHARE_EXCLUSIVE and STGM_SIMPLE|STGM_READ|STGM_SHARE_EXCLUSIVE.</p>
<p>
</p>
<p>
To support the Single-Writer/Multi-Reader Direct mode, the <b>StgOpenStorageEx</b> function accepts the following flag combinations as valid modes in the <i>grfMode</i> parameter: STGM_READWRITE|STGM_SHARE_DENY_WRITE and STGM_READ|STGM_SHARE_DENY_NONE.</p>
<p>
</p>
<p>
</p>
<p>
<b>Note</b>&nbsp;&nbsp;Opening a storage object in read and/or write mode without denying writer permissions to others (the <i>grfMode</i> parameter specifies STGM_SHARE_DENY_WRITE) can be a time-consuming operation since the <b>StgOpenStorageEx</b> call must make a snapshot copy of the entire storage object.</p>
<p>
Applications often try to open storage objects with the following access permissions:</p>
<pre><code>STGM_READ_WRITE | STGM_SHARE_DENY_WRITE 
    // transacted vs. direct mode omitted for exposition 
 </code></pre>
<p>
If the application succeeds, it never needs to make a snapshot copy. If it fails, the application can revert to using the permissions and make a snapshot copy:</p>
<pre><code>STGM_READ_WRITE 
    // transacted vs. direct mode omitted for exposition 
 </code></pre>
<p>
In this case, the application should prompt the user before doing a time-consuming copy. Alternatively, if the document sharing semantics implied by the access modes are appropriate, the application could try to open the storage as follows:</p>
<pre><code>STGM_READ | STGM_SHARE_DENY_WRITE 
    // transacted vs. direct mode omitted for exposition 
 </code></pre>
<p>
In this case, if the application succeeds, a snapshot copy will not have been made (because STGM_SHARE_DENY_WRITE was specified, denying others write access).</p>
<p>
To reduce the expense of making a snapshot copy, applications can open storage objects in priority mode (<i>grfMode</i> specifies STGM_PRIORITY).</p>
<h4>QuickInfo</h4>
<p>
<b>&nbsp;&nbsp;Windows NT: </b>Use version 5.0 or later.<br>
<b>&nbsp;&nbsp;Windows: </b>Unsupported.<br>
<b>&nbsp;&nbsp;Windows CE: </b>Unsupported.<br>
<b>&nbsp;&nbsp;Header: </b>Declared in objbase.h.</p>
<h4>See Also</h4>
<p>
<a href="if_r2z_9b8l.htm"><b>IStorage</b></a>, <a href="api4_8hd1.htm"><b>StgCreateDocfile</b></a>, <a href="api4_9f3s.htm"><b>StgCreateStorageEx</b></a>, <a href="api4_0hb9.htm"><b>StgOpenStorage</b></a> </p>
<p>
</p>
<p>
</p>
<p>&nbsp;</p></body>
</HTML>
