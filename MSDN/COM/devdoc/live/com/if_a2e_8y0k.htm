<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>IClientSecurity::QueryBlanket</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h2><a name="_com_iclientsecurity_queryblanket"></a>IClientSecurity::QueryBlanket</h2>
<p>
Retrieves authentication information the client uses to make calls on the specified proxy.</p>
<pre><code><b>HRESULT QueryBlanket(
  IUnknown* </b><i> pProxy</i><b>,    </b>//Pointer to the interface whose proxy 
                        // will be queried
<b>  DWORD* </b><i> pAuthnSvc</i><b>,    </b>//Location for the current authentication 
                        // service
<b>  DWORD* </b><i> pAuthzSvc</i><b>,    </b>//Location for the current authorization 
                        // service
<b>  OLECHAR** </b><i> pServerPrincName</i><b>,</b>
<b>                        </b>//Location for the current principal name
<b>  DWORD*</b><i> pAuthnLevel</i><b>,   </b>//Location for the current authentication 
                        // level
<b>  DWORD*</b><i> pImpLevel</i><b>,     </b>//Location for the current impersonation 
                        // level
<b>  RPC_AUTH_IDENTITY_HANDLE* </b><i> pAuthInfo</i><b>, </b>
<b>                        </b>//Location of a handle that indicates the 
                        // client identity 
<b>  DWORD* </b><i> pCapabilities </i>//Location for flags indicating further 
                        // capabilities of the proxy
<b>);</b>
 </code></pre>
<h4>Parameters</h4>
<dl>
<dt>
<i>pProxy</i></dt>
<dd>
[in] Pointer indicating the proxy to query. It may not be NULL. For more information, see the Remarks section.</dd>
<dt>
<i>pAuthnSvc</i></dt>
<dd>
[out] Pointer to a DWORD value defining the current <i>authentication</i> service. This will be a single value taken from the list of <a href="enums_22yg.htm"><b>RPC_C_AUTHN_<i>xxx</i></b></a> constants. If the caller specifies NULL, the current authentication service is not retrieved.</dd>
<dt>
<i>pAuthzSvc</i></dt>
<dd>
[out] Pointer to a DWORD value defining the current <i>authorization </i>service. This will be a single value taken from the list of <a href="enums_77js.htm"><b>RPC_C_AUTHZ_<i>xxx</i></b></a> constants. If the caller specifies NULL, the current authorization service is not retrieved.</dd>
<dt>
<i>pServerPrincName</i></dt>
<dd>
[out] Pointer to the current principal name. The string will be allocated by the callee using <a href="api1_9bj7.htm"><b>CoTaskMemAlloc</b></a> and must be freed by the caller using <a href="api1_63l1.htm"><b>CoTaskMemFree</b></a> when they are done with it. Notice that the actual principal name is returned. The EOAC_MAKE_FULLSIC flag is not accepted to convert the prinicpal name. If the caller specifies NULL, the current principal name is not retrieved.</dd>
<dt>
<i>pAuthnLevel</i></dt>
<dd>
[out] Pointer to a DWORD value defining the current authentication level. This will be a single value taken from the list of <a href="enums_3lo8.htm"><b>RPC_C_AUTHN_LEVEL_<i>xxx</i></b></a> constants. If the caller specifies NULL, the current authentication level is not retrieved.</dd>
<dt>
<i>pImpLevel</i></dt>
<dd>
[out] Pointer to a DWORD value defining the current impersonation level. This will be a single value taken from the list of <a href="enums_2jco.htm"><b>RPC_C_IMP_LEVEL_<i>xxx</i></b></a> constants. If the caller specifies NULL, the current impersonation level is not retrieved. When using NTLMSSP, this value could be RPC_IMP_LEVEL_IDENTIFY or RPC_IMP_LEVEL_IMPERSONATE. When using NTLMSSP on NT 5.0, cross-apartment or cross-process, this value can be RPC_IMP_LEVEL_DELEGATE. When using Kerberos, it can be RPC_IMP_LEVEL_IDENTIFY, RPC_IMP_LEVEL_IMPERSONATE, or RPC_C_IMP_LEVEL_DELEGATE. </dd>
<dt>
<i>pAuthInfo</i></dt>
<dd>
[out] Pointer to a handle indicating the identity of the client that was passed to the last <b>IClientSecurity::SetBlanket</b> call (or the default value). Default values are only valid until the proxy is released. If the caller specifies NULL, the client identity is not retrieved. The format of the structure that the returned handle refers to depends on the authentication service. For NTLMSSP and Kerberos, if the client specified a structure in the <i>pAuthInfo</i> parameter to <b>CoInitializeSecurity</b>, that value is returned. Because this points to the value itself and is not a copy, it should not be manipulated or freed. For SSL, if DCOM could get a private certificate from the certificate manager for the client, that value is returned here. Otherwise, NULL is returned. </dd>
<dt>
<i>pCapabilities</i></dt>
<dd>
[out] Pointer to a DWORD of flags indicating the capabilities of the proxy. May be NULL, in which case the flags are not retrieved. On NT 5, these may be EOAC_STATIC_CLOAKING, or EOAC_DYNAMIC_CLOAKING, or EOAC_ANY_AUTHORITY. If the caller specifies NULL, the current capability flags are not retrieved.
</dd>
</dl>
<h4>Return Values</h4>
<dl>
<dt>
S_OK</dt>
<dd>
Success.</dd>
<dt>
E_INVALIDARG</dt>
<dd>
One or more arguments are invalid.</dd>
<dt>
E_OUTOFMEMORY</dt>
<dd>
Insufficient memory to create the <i>pServerPrincName </i>out-parameter.
</dd>
</dl>
<h4>Remarks</h4>
<p>
<b>IClientSecurity::QueryBlanket</b> is called by the client to retrieve the authentication information COM will use on calls made from the specified interface proxy. With a pointer to an interface on the proxy, the client would first call <b>QueryInterface</b> for a pointer to <b>IClientSecurity</b>; then, with this pointer, the client would call <b>IClientSecurity::QueryBlanket</b>, followed by releasing the pointer. This sequence of calls is encapsulated in the helper function <b>CoQueryProxyBlanket</b>.</p>
<p>
In <i>pProxy</i>, you pass an interface pointer. However, you cannot pass a pointer to an interface that does not use a proxy. Thus you can't pass a pointer to an interface that has the local keyword in its interface definition since no proxy is created for such an interface. <b>IUnknown</b> is the exception to this rule.</p>
<h4>QuickInfo</h4>
<p>
<b>&nbsp;&nbsp;Windows NT: </b>Use version 4.0 or later.<br>
<b>&nbsp;&nbsp;Windows: </b>Use Windows 95 or later. Available as a redistributable for Windows 95.<br>
<b>&nbsp;&nbsp;Windows CE: </b>Unsupported.<br>
<b>&nbsp;&nbsp;Header: </b>Declared in objidl.h.</p>
<h4>See Also</h4>
<p>
<a href="api1_8hf8.htm"><b>CoQueryProxyBlanket</b></a> </p>
<p>
</p>
<p>
</p>
<p>&nbsp;</p></body>
</HTML>
