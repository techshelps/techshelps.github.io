<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>What Support for an Interface Means</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h2><a name="_com_what_support_for_an_interface_means"></a>What Support for an Interface Means</h2>
<p>
Besides the <b>IUnknown</b> interface, an ActiveX Control—or COM Object for that matter—expresses whatever optional functionality it supports through additional interfaces. This is to say that no other interfaces are required above <b>IUnknown</b>. To that end, the following table lists the interfaces that an ActiveX Control might support, and what it means to support that interface<i>. </i>Further details about the methods of these interfaces are given in a later section.</p>
<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=36%>Interface</th>
<th align=left width=64%>Comments/What it Means to Support the Interface</th>
</tr>
<tr valign=top>
<td width=36%><b>IOleObject</b></td>
<td width=64%>If the control requires communication with its client site for anything other than events (see <b>IConnectionPointContainer</b>), then <b>IOleObject</b> is a necessity. When implementing this interface, the control must also support the semantics of the following methods: <b>SetHostNames</b>, <b>Close</b>, <b>EnumVerbs</b>, <b>Update</b>, <b>IsUpToDate</b>, <b>GetUserClassID</b>, <b>GetUserType</b>, <b>GetMiscStatus</b>, and the <b>Advise</b>, <b>Unadvise</b>, and <b>EnumAdvise</b> methods that work in conjunction with a container's <b>IAdviseSink</b> implementation. A control implementing <b>IOleObject</b> must be able to handle <b>IAdviseSink</b> if the container provides one; a container may not, in which case a control ensures, of course, that it does not attempt to call a non-existent sink.</td>
</tr>
<tr valign=top>
<td width=36%><b>IOleInPlaceObject</b></td>
<td width=64%>Expresses the control's ability to be in-place activated and possibly UI activated<i>. </i>This interface means that the control has a user interface of some kind that can be activated, and <b>IOleInPlaceActiveObject</b> is supported as well. Required methods are <b>GetWindow</b>, <b>InPlaceActivate</b>, <b>UIDeactivate</b>, <b>SetObjectRects</b>, and <b>ReactivateAndUndo</b>. Support for this interface requires support for <b>IOleObject</b>.</td>
</tr>
<tr valign=top>
<td width=36%><b>IOleInPlaceActiveObject</b></td>
<td width=64%>An in-place capable object that supports <b>IOleInPlaceObject</b> must also provide this interface as well, though the control itself doesn't necessarily implement the interface directly.</td>
</tr>
<tr valign=top>
<td width=36%><b>IOleControl</b></td>
<td width=64%>Expresses the control's ability and desire to deal with (a) mnemonics (<b>GetControlInfo</b>, <b>OnMnemonic</b> methods), (b)  ambient properties (<b>OnAmbientPropertyChange</b>), and/or (c) events that the control requires the container to handle (<b>FreezeEvents</b>). Note that mnemonics are different than accelerators that are handled through <b>IOleInPlaceActiveObject</b>:  mnemonics have associated UI and are active even when the control is not UI active. A control's support for mnemonics means that the control also knows how to use the container's <b>IOleControlSite::OnControlInfoChanged</b> method. Because this requires the control to know the container's site, support for mnemonics also means support for <b>IOleObject</b>. In addition, knowledge of mnemonics requires in-place support and thus <b>IOleInPlaceObject</b>.<p>
If a control uses any container-ambient properties, then it must also implement this interface to receive change notifications, as following the semantics of changes is required. Because ambient properties are only available through the container site's <b>IDispatch</b>, ambient property support means that the control supports <b>IOleObject</b> (to get the site) as well as being able to generate <b>IDispatch::Invoke</b> calls.</p>
<p>
The <b>FreezeEvents</b> method is necessary for controls that must know when a container is not going to handle an event—this is the only way for control to know this condition. If <b>FreezeEvents</b> is only necessary in isolation, such that other <b>IOleControl</b> methods are not implemented, then <b>IOleControl</b> can stand alone without <b>IOleObject</b> or <b>IOleInPlaceObject</b>.</p>
</td>
</tr>
<tr valign=top>
<td width=36%><b>IDataObject</b></td>
<td width=64%>Indicates that the control can supply at least (a) graphical renderings of the control (CF_METAFILEPICT is the minimum if the control has any visuals at all) and/or (b) property sets, if the control has any properties to provide. The methods <b>GetData</b>, <b>QueryGetData</b>, <b>EnumFormatEtc</b>, <b>DAdvise</b>, <b>DUnadvise</b>, and <b>EnumDAdvise</b> are required. Support for graphical formats other than CF_METAFILEPICT is optional.</td>
</tr>
<tr valign=top>
<td width=36%><b>IViewObject2</b></td>
<td width=64%>Indicates that the control has some interesting visuals when it is not in-place active. If implemented, a control must support the methods <b>Draw</b>, <b>GetAdvise</b>, <b>SetAdvise</b>, and <b>GetExtent</b>.</td>
</tr>
<tr valign=top>
<td width=36%><b>IDispatch</b></td>
<td width=64%>Indicates that the control has either (a) custom methods, or (b) custom properties that are both available via late-binding through <b>IDispatch::Invoke</b>. This also requires that the control provides type information through other <b>IDispatch</b> methods. A control may support multiple <b>IDispatch</b> implementations where only one is associated with IID_IDispatch—the others must have their own unique dispinterface identifiers.<p>
A control is encouraged to supply dual interfaces for custom method and property access, but this is optional if methods and properties exist.</p>
</td>
</tr>
<tr valign=top>
<td width=36%><b>IConnectionPointContainer</b></td>
<td width=64%>Indicates that a control supports at least one outgoing interface, such as events or property change notifications. All methods of this interface must be implemented if this interface is available at all, including <b>EnumConnectionPoints</b> which requires a separate object with <b>IEnumConnectionPoints</b>.<p>
Support for <b>IConnectionPointContainer</b> means that the object also supports one or more related objects with <b>IConnectionPoint</b> that are available through <b>IConnectionPointContainer</b> methods. Each connection point object itself must implement the full <b>IConnectionPoint</b> interface, including <b>EnumConnections</b>, which requires another enumerator object with the <b>IEnumConnections</b> interface.</p>
</td>
</tr>
<tr valign=top>
<td width=36%><b>IProvideClassInfo[2]</b></td>
<td width=64%>Indicates that the object can provide its own coclass type information directly through <b>IProvideClassInfo::GetClassInfo</b>. If the control supports the later variation <b>IProvideClassInfo2</b>, then it also indicates its ability to provide its primary source IID through <b>IProvideClassInfo2::GetGUID</b>. All methods of this interface must be implemented.</td>
</tr>
<tr valign=top>
<td width=36%><b>ISpecifyPropertyPages</b></td>
<td width=64%>Indicates that the control has property pages that it can display such that a container can coordinate this control's property pages with other control's pages when property pages are to be shown for a multi-control selection. All methods of this interface must be implemented when support exists.</td>
</tr>
<tr valign=top>
<td width=36%><b>IPerPropertyBrowsing</b></td>
<td width=64%>Indicates the control's ability to (a) provide a display string for a property, (b) provide pre-defined strings and values for its properties and/or (c) map a property dispID to a specific property page. Support for this interface means that support for properties through IDispatch as above is provided. If (c) is supported, then it also means that the object's property pages mapped through <b>IPerPropertyBrowsing::MapPropertyToPage</b> themselves implement <b>IPropertyPage2</b> as opposed to the basic <b>IPropertyPage</b> interface.</td>
</tr>
<tr valign=top>
<td width=36%><b>IPersistStream</b></td>
<td width=64%>See <a href="ctrlgde_0yer.htm">Persistence Interfaces</a> section.</td>
</tr>
<tr valign=top>
<td width=36%><b>IPersistStreamInit</b></td>
<td width=64%>See Persistence Interfaces section.</td>
</tr>
<tr valign=top>
<td width=36%><b>IPersistMemory</b></td>
<td width=64%>See Persistence Interfaces section.</td>
</tr>
<tr valign=top>
<td width=36%><b>IPersistStorage</b></td>
<td width=64%>See Persistence Interfaces section.</td>
</tr>
<tr valign=top>
<td width=36%><b>IPersistMoniker</b></td>
<td width=64%>See Persistence Interfaces section.</td>
</tr>
<tr valign=top>
<td width=36%><b>IPersistPropertyBag</b></td>
<td width=64%>See Persistence Interfaces section.</td>
</tr>
<tr valign=top>
<td width=36%><b>IOleCache[2]</b></td>
<td width=64%>Indicates support for container caching of control visuals. A control generally obtains caching support itself through the OLE function <b>CreateDataCache</b>. Only controls with meaningful static content should choose to do this (although it is not required). If a control supports caching at all, it should simply aggregate the data cache and expose both <b>IOleCache</b> and <b>IOleCache2</b> interfaces from the data cache. A control implementing <b>IOleObject</b> must be able to handle <b>IAdviseSink</b> if the container provides one; a container may not, in which case a control ensures, of course, that it does not attempt to call a non-existent sink.</td>
</tr>
<tr valign=top>
<td width=36%><b>IExternalConnection</b></td>
<td width=64%>Indicates that the control supports external links to itself; that is, the control is not marked with OLEMISC_CANTLINKINSIDE and supports <b>IOleObject::SetMoniker</b> and <b>IOleObject::GetMoniker</b>. A container will never query for this interface itself nor call it directly as calls are generated from inside OLE's remoting layer.</td>
</tr>
<tr valign=top>
<td width=36%><b>IRunnableObject</b></td>
<td width=64%>Indicates that the control differentiates being loaded from being running, as some in-process objects do.</td>
</tr>
</table><br>
<p>&nbsp;</p></body>
</HTML>
