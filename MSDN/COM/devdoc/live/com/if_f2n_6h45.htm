<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>IFilter Interface</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_com_ifilter_interface"></a>IFilter Interface</h1>
<p>
The <b>IFilter</b> interface scans documents for plain text and properties (attributes). It extracts <i>chunks</i> of text from these documents, filtering out embedded formatting and retaining positional information. <b>IFilter</b> provides the foundation for building higher level applications such as document indexers and application-independent viewers. </p>
<p>
<b>IFilter</b> is designed to meet the specific needs of full text search engines. It is up to the search engine to break the result of a call to <a href="if_f2n_08s4.htm"><b>IFilter::GetText</b></a> or <a href="if_f2n_19ut.htm"><b>IFilter::GetValue</b></a> into words, and store the results in an index. </p>
<h5>Filtering</h5>
<p>
Documents are typically stored in private file formats that are opaque to the system. Most content indexing systems don't understand these private file formats and consequently don't index them. Content filters can be used to filter these private file formats. A particular content filter can read a particular file format. </p>
<p>
When an indexer begins working on a document, it determines the file type, and uses the appropriate content filter. The content filter extracts text chunks from the document that can be sent to a search engine in a recognizable format. </p>
<p>
Besides extracting text chunks, content filters can also recognize language shifts, as in the case of multi-lingual documents. If a particular document format tags such shifts, the content filter can emit the tags with the corresponding text chunk. These tags can then be used by the indexer to load the appropriate word breaker for the language. But, content filters can only do this if some sort of tag is included in the on-disk file format. </p>
<p>
Content filters also handle embedded objects. When such an object is encountered in a document, its type should be identified and the appropriate content filter activated. </p>
<p>
Because knowledge of a particular file format is encapsulated within the content filter, new file formats can be indexed simply by providing a content filter for the format. </p>
<h4>Chunks</h4>
<p>
Each object can be asked to produce the chunks of Unicode text that it contains, converting ASCII to Unicode when necessary. Text within a chunk is intended to be linear and sequential, with the same attribute and locale. Two pieces of text that do not have such a relationship must be in different chunks. Separate text boxes in a graphics file, labels and titles on charts, and possibly even text in separate cells of a spreadsheet are all examples of text in separate chunks.</p>
<p>
Each chunk is given a unique chunk identifier. These ULONG identifiers are guaranteed to remain constant until <b>IFilter</b> is released. </p>
<p>
Repeated instantiations of <b>IFilter</b>, with the same initial parameters, will produce the same set of chunks. Multiple instantiations with different initial parameters may produce a different set of chunks. Changing the set of attributes (see following section) may re-partition the chunks of an object. Chunk id 0 is invalid.</p>
<p>
Chunks may overlap, but a specific attribute should be applied to a given character only once. </p>
<h4>Properties and Pseudoproperties </h4>
<p>
Text extracted by <b>IFilter</b> may be tagged with many attributes, but only one attribute at a time. When these attributes refer to text chunks they are treated as properties by the content indexer (the search engine). but not by the system. They are known as <i>pseudoproperties</i>.</p>
<p>
Pseudoproperties are not accessible through the standard COM <a href="if_p2q_80md.htm"><b>IPropertyStorage</b></a> interface. Pseudoproperties allow the user to search for documents based on the value of some internal field in the document that has not been exposed to the system as a property. For example, a spreadsheet describing monthly sales for an employee might export <i>employee-id</i> and <i>total-sales</i> pseudo-properties. This would enable a query for all spreadsheets (months) in which some employee sold more than <i>x</i> dollars.</p>
<p>
Pseudo-property names must follow COM property naming conventions. Each pseudo-property must be specified as <i>property set\property </i>pair. Failure to follow this naming convention will result in unpredictable query behavior. Specifying a pseudo-property name that matches a true COM-style property name may also result in undefined query behavior.</p>
<p>
An <b>IFilter</b> implementation can also provide COM-style properties. These properties would be retrieved by calling <a href="if_f2n_19ut.htm"><b>IFilter::GetValue</b></a>. Logically, they should be considered external annotations of a document. For example, this mechanism can be used to publish HTML anchors. If a class supports retrieval of COM properties through <a href="if_p2q_80md.htm"><b>IPropertyStorage</b></a>, An <b>IFilter</b> implementation can request that the caller of <b>IFilter</b> use <b>IPropertyStorage</b> to enumerate COM properties, either to replace or to supplement properties emitted by <b>IFilter::GetValue</b>.</p>
<h4>Embedded and Linked Objects</h4>
<p>
An object must enumerate the chunks of text in its embedded objects. These nested chunks appear to the original caller as chunks of the outer object. There is no operating system support provided for this operation. The implementation of <b>IFilter</b> is responsible for binding to the <b>IFilter</b> interface of embedded objects. (<b>IFilter</b> will be implemented on the embedded object by the owner of that format.--standard COM containment.) If the current chunk is within an embedded object, all <a href="if_f2n_08s4.htm"><b>GetText</b></a> and <a href="if_f2n_19ut.htm"><b>GetValue</b></a> calls should be passed directly to the embedded object's <b>IFilter</b>, and the return values from the embedded object should be returned to the client. Other calls require some additional work. <a href="if_f2n_93l7.htm"><b>GetChunk</b></a>, for example, may require renumbering chunk idetifiers to make them unique.</p>
<p>
An object can optionally be asked to enumerate the chunks of text contained in its linked objects. As with embedded objects, your implementation of <b>IFilter</b> is responsible for binding to the <b>IFilter</b> interface of linked objects, then renumbering the chunks of the linked objects so they will appear to the original caller as chunks of the outer object. The same rules that apply to an embedded object's chunks apply to a linked object's chunks. </p>
<p>
The original source of a chunk (embedded, linked, or top-level container) is not exposed by <b>IFilter</b>. </p>
<h5>Proposed Uses of IFilter</h5>
<p>
Although clients of <b>IFilter</b> can use the interface in any way they see fit, it was designed for two tasks: filtering and viewing (browsing/hit-highlighting). </p>
<h5>Full Text Search</h5>
<p>
Full text search engines are the simpler of the two filter clients. They scan objects for plain text, pseudo properties, and COM-style properties. They break the result of <a href="if_f2n_08s4.htm"><b>IFilter::GetText</b></a> calls apart into words, normalize them and then store the result in a search engine. The locale identifier, if specified with a text chunk, is used to perform proper language-specific word breaking. </p>
<h5>Viewing</h5>
<p>
Document viewing displays the results of full text queries. A simplistic model of the viewing process is that documents matching a query will be indexed on-the-fly, and the resulting in-memory index will be searched to locate query hits. A document viewer highlights and navigates between these hits.</p>
<h4>Methods in Vtable Order</h4>
<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=45%>IUnknown Methods</th>
<th align=left width=55%>Description</th>
</tr>
<tr valign=top>
<td width=45%><a href="if_r2z_7fvp.htm"><b>QueryInterface</b></a></td>
<td width=55%>Returns pointers to supported interfaces.</td>
</tr>
<tr valign=top>
<td width=45%><a href="if_r2z_3rja.htm"><b>AddRef</b></a></td>
<td width=55%>Increments reference count.</td>
</tr>
<tr valign=top>
<td width=45%><a href="if_r2z_59np.htm"><b>Release</b></a></td>
<td width=55%>Decrements reference count.</td>
</tr>
</table><br>
<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=45%>IFilterMethods</th>
<th align=left width=55%>Description</th>
</tr>
<tr valign=top>
<td width=45%><b>Init</b></td>
<td width=55%>Initializes filtering session</td>
</tr>
<tr valign=top>
<td width=45%><a href="if_f2n_93l7.htm"><b>GetChunk</b></a></td>
<td width=55%>Positions filter at beginning of next chunk and returns description</td>
</tr>
<tr valign=top>
<td width=45%><a href="if_f2n_08s4.htm"><b>GetText</b></a></td>
<td width=55%>Retrieves text from current chunk</td>
</tr>
<tr valign=top>
<td width=45%><a href="if_f2n_19ut.htm"><b>GetValue</b></a></td>
<td width=55%>Retrieves non-text values from chunk</td>
</tr>
<tr valign=top>
<td width=45%><a href="if_f2n_2fji.htm"><b>BindRegion</b></a></td>
<td width=55%>Retrieves interface representing specified portion of object—currently reserved for future use</td>
</tr>
</table><br>
<h4>See Also</h4>
<p>
<a href="enums_4ab1.htm"><b>IFILTER_INIT</b></a>, <a href="enums_8o19.htm"><b>IFILTER_FLAGS</b></a>, <a href="enums_8bzh.htm"><b>CHUNKSTATE</b></a>, <a href="enums_27ql.htm"><b>CHUNK_BREAKTYPE</b></a>, <a href="structs_9zsi.htm"><b>STAT_CHUNK</b></a>, <a href="structs_9tgy.htm"><b>FILTERREGION</b></a> </p>
<p>
</p>
<p>
</p>
<p>&nbsp;</p></body>
</HTML>
