<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>IMoniker::RelativePathTo</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h2><a name="_com_imoniker_relativepathto"></a>IMoniker::RelativePathTo</h2>
<p>
Supplies a moniker that, when composed onto the end of this moniker (or one with a similar structure), yields the specified moniker.</p>
<pre><code><b>HRESULT RelativePathTo(
  IMoniker</b><i> *pmkOther</i><b>,     </b>//Pointer to moniker to which a relative 
                          //path should be taken
<b>  IMoniker</b><i> **ppmkRelPath  </i>//Address of output variable that receives 
                          //the IMoniker interface pointer
<b>);</b>
 </code></pre>
<h4>Parameters</h4>
<dl>
<dt>
<i>pmkOther</i></dt>
<dd>
[in] Pointer to the <b>IMoniker</b> interface on the moniker to which a relative path should be taken.</dd>
<dt>
<i>ppmkRelPath</i></dt>
<dd>
[out] Address of <b>IMoniker</b>* pointer variable that receives the interface pointer to the relative moniker. When successful, the implementation must call <a href="if_r2z_3rja.htm"><b>IUnknown::AddRef</b></a> on the new moniker; it is the caller's responsibility to call <a href="if_r2z_59np.htm"><b>IUnknown::Release</b></a>. If an error occurs, the implementation sets *<i>ppmkRelPath</i> to NULL. 
</dd>
</dl>
<h4>Return Values</h4>
<dl>
<dt>
The method supports the standard return values E_OUTOFMEMORY and </dt>
</dl>
<p>
E_UNEXPECTED, as well as the following: 
<dl>
<dt>
S_OK</dt>
<dd>
A meaningful relative path has been returned.</dd>
<dt>
MK_S_HIM</dt>
<dd>
No common prefix is shared by the two monikers and the moniker returned in <i>ppmkRelPath</i> is <i>pmkOther</i>.</dd>
<dt>
MK_E_NOTBINDABLE</dt>
<dd>
This moniker is a relative moniker, such as an item moniker. This moniker must be composed with the moniker of its container before a relative path can be determined.
</dd>
</dl>
<h4>Remarks</h4>
<p>
A relative moniker is analogous to a relative path (such as "..\backup"). For example, suppose you have one moniker that represents the path "c:\projects\secret\art\pict1.bmp" and another moniker that represents the path "c:\projects\secret\docs\chap1.txt." Calling <b>IMoniker::RelativePathTo</b> on the first moniker, passing the second one as the <i>pmkOther</i> parameter, would create a relative moniker representing the path "..\docs\chap1.txt." </p>
<h5>Notes to Callers</h5>
<p>
Moniker clients typically do not need to call <b>IMoniker::RelativePathTo</b>. This method is primarily called by the default handler for linked objects. Linked objects contain both an absolute and a relative moniker to identify the link source (this enables link tracking if the user moves a directory tree containing both the container and source files). The default handler calls this method to create a relative moniker from the container document to the link source (that is, it calls <b>IMoniker::RelativePathTo</b> on the moniker identifying the container document, passing the moniker identifying the link source as the <i>pmkOther</i> parameter). </p>
<p>
If you do call <b>IMoniker::RelativePathTo</b>, call it only on absolute monikers; for example, a file moniker or a composite moniker whose leftmost component is a file moniker, where the file moniker represents an absolute path. Do not call this method on relative monikers.</p>
<h5>Notes to Implementers</h5>
<p>
Your implementation of <b>IMoniker::RelativePathTo</b> should first determine whether <i>pmkOther</i> is a moniker of a class that you recognize and for which you can provide special handling (for example, if it is of the same class as this moniker). If so, your implementation should determine the relative path. Otherwise, it should pass both monikers in a call to the <a href="api2_1y7j.htm"><b>MonikerRelativePathTo</b></a> function, which correctly handles the generic case.</p>
<p>
The first step in determining a relative path is determining the common prefix of this moniker and <i>pmkOther</i>. The next step is to break this moniker and <i>pmkOther</i> into two parts each, say (P, myTail) and (P, otherTail) respectively, where P is the common prefix. The correct relative path is then the inverse of myTail composed with otherTail:</p>
<p>
Comp( Inv( myTail ), otherTail )</p>
<p>
Where Comp() represents the composition operation and Inv() represents the inverse operation. </p>
<p>
Note that for certain types of monikers, you cannot use your <a href="if_f2n_2zvp.htm"><b>IMoniker::Inverse</b></a> method to construct the inverse of myTail. For example, a file moniker returns an anti-moniker as an inverse, while its <b>IMoniker::RelativePathTo</b> method must use one or more file monikers that each represent the path ".." to construct the inverse of myTail. </p>
<h4>QuickInfo</h4>
<p>
<b>&nbsp;&nbsp;Windows NT: </b>Use version 3.1 or later.<br>
<b>&nbsp;&nbsp;Windows: </b>Use Windows 95 or later.<br>
<b>&nbsp;&nbsp;Windows CE: </b>Unsupported.<br>
<b>&nbsp;&nbsp;Header: </b>Declared in objidl.h.</p>
<h4>See Also</h4>
<p>
<a href="if_f2n_2zvp.htm"><b>IMoniker::Inverse</b></a>, <a href="if_f2n_9nu0.htm"><b>IMoniker::CommonPrefixWith</b></a>, <a href="api2_1y7j.htm"><b>MonikerRelativePathTo</b></a> </p>
<p>
</p>
<p>
</p>
<p>&nbsp;</p></body>
</HTML>
