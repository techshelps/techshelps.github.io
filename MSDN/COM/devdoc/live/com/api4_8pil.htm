<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>URLOpenBlockingStream</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_com_urlopenblockingstream"></a>URLOpenBlockingStream</h1>
<p>
Creates a blocking stream object from a URL.</p>
<pre><code><b>HRESULT URLOpenBlockingStream(
  LPUNKNOWN</b><i> pCaller</i><b>,  </b>// Caller's controlling <a href="if_r2z_9dwu.htm">IUnknown</a> 
<b>  LPCWSTR</b><i> szURL</i><b>,      </b>// URL to be converted to stream
<b>  LPSTREAM</b><i> *ppStream</i><b>, </b>// Stream object's <a href="if_r2z_4x7x.htm">IStream</a> 
<b>  DWORD</b><i> dwResv</i><b>,       </b>// Reserved for future use
<b>  LPBINDSTATUSCALLBACK</b><i> lpfnCB</i>
<i>                      </i>// Caller's <a href="if_a2e_0vxn.htm">IBindStatusCallback</a> 
<b>);</b>
 </code></pre>
<h4>Parameters</h4>
<dl>
<dt>
<i>pCaller</i></dt>
<dd>
[in] Pointer to the caller's controlling <b>IUnknown</b>. If the caller is not an ActiveX component, this value may be set to NULL.</dd>
<dt>
<i>szURL</i></dt>
<dd>
[out] The URL to be converted to a stream object. Cannot be NULL.</dd>
<dt>
<i>ppStream</i></dt>
<dd>
[out] Pointer to the <b>IStream</b> interface pointer on the stream object created by this function.</dd>
<dt>
<i>dwResv</i></dt>
<dd>
[in] Reserved for future use; must be zero.</dd>
<dt>
<i>lpfnCB</i></dt>
<dd>
[in] Pointer to the IBindStatusCallback interface pointer on the caller. Can be NULL.</dd>
</dl>
<h4>Return Values</h4>
<p>
This function returns the same values as <b>IBindHost::MonikerBindToStorage</b>.</p>
<h4>Remarks</h4>
<p>
Immediately on receiving the interface pointer returned by this function, the caller can download data from the Internet by calling <a href="if_r2z_14mc.htm"><b>ISequentialStream::Read</b></a>. This call blocks until enough data is available. The following code fragment is a typical implementation of such a call:</p>
<pre><code>IStream *pStream
URLOpenStream( 0, L"http://www.msn.com/", &amp;pStream, 0, 0);
char buffer[0x100];
DWORD dwGot;
HRESULT hr = NOERROR;
do {
    hr = pStream-&gt;Read( buffer, sizeof(buffer), &amp;dwGot );
    
    .. do something with contents of buffer ...
} while( SUCCEEDED(hr) );
 </code></pre>
<p>
If <i>pCaller</i> is non-NULL, the caller is a COM object that is contained in another component, such as an ActiveX Control in the context of an HTML page.In this case, the function attempts the download in the context of the ActiveX client framework and allows the caller's container to receive callbacks on the progress of the download.</p>
<p>
<b>URLOpenBlockingStream</b> calls the caller's <a href="if_a2e_35ir.htm"><b>IBindStatusCallback::OnProgress</b></a> method on some connection activity, including the arrival of data (<a href="if_a2e_0x2d.htm"><b>IBindStatusCallback::OnDataAvailable</b></a> is never called for this purpose). Implementing <b>IBindStatusCallback::OnProgress</b> allows a caller to provide a mechanism for monitoring the progress of download operations.It also allows downloads to be canceled by returning E_ABORT from the <b>OnProgress</b> call.</p>
<h4>QuickInfo</h4>
<p>
<b>&nbsp;&nbsp;Windows NT: </b>Use version 5.0 or later.<br>
<b>&nbsp;&nbsp;Windows: </b>Unsupported.<br>
<b>&nbsp;&nbsp;Windows CE: </b>Unsupported.<br>
<b>&nbsp;&nbsp;Header: </b>Declared in urlmon.h.</p>
<h4>See Also</h4>
<p>
<a href="if_a2e_0vxn.htm"><b>IBindStatusCallback</b></a>, <a href="if_a2e_35ir.htm"><b>IBindStatusCallback::OnProgress</b></a>, <a href="if_r2z_4x7x.htm"><b>IStream</b></a>, <a href="if_r2z_1k19.htm"><b>ISequentialStream</b></a>, <a href="if_r2z_14mc.htm"><b>ISequentialStream::Read</b></a> </p>
<p>
</p>
<p>
</p>
<p>&nbsp;</p></body>
</HTML>
