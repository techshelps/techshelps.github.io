<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>IOleInPlaceSiteWindowless</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_com_ioleinplacesitewindowless"></a>IOleInPlaceSiteWindowless</h1>
<p>
The <b>IOleInPlaceSiteWindowless</b> interface is derived from and extends the <a href="if_o_9xdk.htm"><b>IOleInPlaceSiteEx</b></a> interface. <b>IOleInPlaceSiteWindowless</b> works with <a href="if_o_6ib7.htm"><b>IOleInPlaceObjectWindowless</b></a> which is implemented on the windowless object. Together, these two interfaces provide services to a windowless object from its container allowing the windowless object to:
<ul>
<li>
process window messages</li>
<li>
participate in drag and drop operations</li>
<li>
perform drawing operations</li>
</ul>
<p>
Having a window can place unnecessary burdens on small objects, such as controls. It prevents an object from being non-rectangular. It prevents windows from being transparent. It prevents the small instance size needed by many small controls.</p>
<p>
A windowless object can enter the in-place active state without requiring a window or the resources associated with a window. Instead, the object's container provides the object with many of the services associated with having a window.</p>
<h5>Windowless object model</h5>
<p>
Windowless objects are an extension of normal compound document objects. They follow the same in-place activation model and share the same definitions for the various OLE states, with the difference that they do not consume a window when they enter the in-place and UI active states. They are required to comply with the OLE compound document specification, including in-place and UI activation.</p>
<p>
Windowless objects require special support from their container. In other words, the container has to be specifically written to support this new kind of object. However, windowless objects are backward compatible with down level containers. In such containers, they simply create a window when active and behave as a normal compound document object.</p>
<p>
As with other compound document objects, windowless objects need to be in-place active to get mouse and keyboard messages. In fact, since an object needs to have the keyboard focus to receive keyboard messages, and having the keyboard focus implies being UI active for an object, only UI active objects will actually get keyboard messages. Non-active objects can still process keyboard mnemonics.</p>
<p>
Since windowless objects do not have a window, they rely on their container to receive window messages for them. The container dispatches its own window messages to the appropriate embedded, windowless object through calls to <b>IOleInPlaceObjectWindowless</b> methods. Similarly, windowless objects can obtain services from their container such as capturing the mouse, setting the focus, getting a device context in which to paint, and so on. The control calls <b>IOleInPlaceSiteWindowless</b> methods. In addition, the container is responsible for drawing any border hatching as well as the grab handles for the control.</p>
<p>
These two interfaces are derived from existing interfaces. By extending existing interfaces rather than creating new ones, no new VTable pointer is added to the object instance, helping to keep the instance size small.</p>
<h5>Client and server negotiations with windowless objects</h5>
<p>
When a windowless object gets in-place activated, it should query its site for the <b>IOleInPlaceSiteWindowless</b> interface. If this interface is supported, the object calls <b>IOleInPlaceSiteWindowless::CanWindowlessActivate</b> to determine if it can proceed and in-place activate without a window.</p>
<p>
If the container does not support <b>IOleInPlaceSiteWindowless</b> or if the <b>IOleInPlaceSiteWindowless::CanWindowlessActivate</b> method returns S_FALSE, the windowless object should behave like a normal compound document object and create a window.</p>
<p>
The container can get the window handle for an embedded object by calling <a href="if_o_33qv.htm"><b>IOleWindow::GetWindow</b></a>. This method should fail (return E_FAIL) for a windowless object. However, a container cannot be sure that the object is windowless by calling this method. The object may have a window but may not have created it yet. Many existing objects only create their window after calling the <b>OnInPlaceActivate</b> method on their site object.</p>
<p>
Consequently, a windowless object must call the new <b>IOleInPlaceSiteEx::OnInPlaceActivateEx</b> method on its site object, instead of <b>OnInPlaceActivate</b>. The <i>dwFlags</i> parameter for this new method contains additional information in the ACTIVATEFLAGS enumeration. The ACTIVATE_WINDOWLESS enumeration value indicates that the object is activated without a window. Containers can cache this value instead of calling the <b>GetWindow</b> method on the <b>IOleWindow</b> interface repeatedly.</p>
<h5>Message dispatching</h5>
<p>
Windowless objects rely on their containers to dispatch window messages to them, capture the mouse, and get the keyboard focus. The container calls <b>IOleInPlaceObject::OnWindowMessage</b> to dispatch a window message to a windowless object. This method is similar to the <b>SendMessage</b> Windows API function except that it does not require an HWND parameter and it returns both an HRESULT and a LRESULT.</p>
<p>
A windowless object must not call the <b>DefWindowProc</b> Windows API function directly. Instead, it calls <b>IOleInPlaceSiteWindowless::OnDefWindowMessage</b> to invoke the default action, for example with WM_SETCURSOR or WM_HELP that should be propagated back up to the container. Thus, the container has a chance to handle the message before the object processes it.</p>
<p>
For mouse messages, the object calls <b>IOleInPlaceSiteWindowless::Set</b> <b>Capture</b> to obtain the mouse capture and <b>IOleInPlaceSiteWindowless::SetFocus</b> to get the keyboard focus.</p>
<p>
A windowless object handles accelerators and mnemonics as follows:
<dl>
<dt>
<b>Accelerators</b></dt>
<dd>
The UI active object checks for its own accelerators in <a href="if_o_0lo2.htm"><b>IOleInPlaceActiveObject::TranslateAccelerator</b></a>. A windowless object does the same. However, a windowless object cannot send a WM_COMMAND message to itself, as a windowed object would do. Therefore, instead of translating the key to a command, a windowless object should simply process the key right away.
<p>
Except for that one difference, windowless objects should implement the <b>IOleInPlaceActiveObject::TranslateAccelerator</b> method as defined in the OLE specifications. In particular, a windowless object should pass the accelerator message up to its site object if it does not wish to handle it. The windowless object and returns S_OK if the message got translated and S_FALSE if not. In the case of a windowless object, the message is processed instead of translated. Non translated messages will come back to the object through the <b>IOleInPlaceObjectWindowless::OnWindowMessage</b> method.

<p>
Note that because the container's window gets all keyboard input, a UI active object should look for messages sent to that window to find those it needs to process in its <b>IOleInPlaceActiveObject::TranslateAccelerator</b> method. An object can get its container's window by calling <b>IOleWindow::GetWindow</b>.
</dd>
<dt>
<b>Mnemonics</b></dt>
<dd>
Control mnemonics are handled the same way whether the control is windowless or not. The container gets the control mnemonic table by  calling <a href="if_o_5yb3.htm"><b>IOleControl::GetControlInfo</b></a> and then calls <a href="if_o_34mb.htm"><b>IOleControl::OnMnemonic</b></a> when it receives a key combination that matches a control mnemonic.</dd>
</dl>
<h5>Drag &amp; drop onto windowless objects</h5>
<p>
Since a windowless object does not have a window when it is active, it cannot register its own <a href="if_a2e_2y7o.htm"><b>IDropTarget</b></a> interface with the <a href="api3_9eeo.htm"><b>RegisterDragDrop</b></a> function. However, to participate in drag and drop operations, a windowless object still must implement this interface. The object supplies its container with a pointer to its <b>IDropTarget</b> interface through <b>IOleInPlaceObjectWindowless::GetDropTarget</b> instead of having the container call <b>QueryInterface</b> for it. See <a href="if_o_6pmc.htm"><b>IOleInPlaceObjectWindowless::GetDropTarget</b></a> for more information on drag and drop operations involving windowless objects.</p>
<h5>In-place drawing for windowless objects</h5>
<p>
With windowed objects, the container is only responsible for drawing the object when it is inactive. Windowed objects have their own window when they are active and can draw themselves independently of their container.</p>
<p>
A windowless object, however, needs services from its container to redraw itself even when it is active. The container must provide the object with information about its surrounding environment, such as the clipping region, the background, overlapping objects in front of the object being redrawn, and a device context in which to draw.</p>
<p>
The <b>IOleInPlaceSiteWindowless</b> interface on the container's site object provides these services: drawing the object, obtaining and releasing the device context, invalidating the object's on-screen display, scrolling the object, or showing a caret when the object is active.</p>
<p>
<b>Note</b>&nbsp;&nbsp;All methods of <b>IOleInPlaceSiteWindowless</b> take position information in client coordinates of the containing window, that is, the window in which the object is being drawn.</p>
<dl>
<dt>
<b>Drawing windowless objects</b></dt>
<dd>
To maintain compatibility with windowed objects, the container still uses <a href="if_r2z_799z.htm"><b>IViewObject::Draw</b></a> to redraw the in-place active, windowless object. See <b>IViewObject::Draw</b> for information on how the method is used with windowless objects.</dd>
<dt>
<b>Obtaining and releasing a device context</b></dt>
<dd>
To draw on its own when in-place active, a windowless object must call its site's <b>IOleInPlaceSiteWindowless::GetDC</b> method to get a device context in which to draw. Then, it draws into the device context and releases it by calling <b>IOleInPlaceSiteWindowless::ReleaseDC</b>.</dd>
<dt>
<b>Display Invalidation</b></dt>
<dd>
In-place windowless objects may need to invalidate regions of their on-screen image. Even though the notification methods in <a href="if_a2e_5zy0.htm"><b>IAdviseSinkEx</b></a> can be used for that purpose, they are not ideal for in-place active objects because they take HIMETRIC coordinates. In order to simplify and speed up in-place drawing, the <b>InvalidateRect</b> and <b>InvalidateRgn</b> methods in the <b>IOleInPlaceSiteWindowless</b> interface provide the same functionality.
<p>
An object cannot call the Windows API functions <b>InvalidateRect</b> and <b>InvalidateRgn</b> directly on the window handle it gets from calling <b>IOleInPlaceSiteWindowless::GetWindow</b> on its site.
</dd>
<dt>
<b>Scrolling</b></dt>
<dd>
In-place active windowless objects may need to scroll a given rectangle of their on-screen image, for example, with a multi-line text control. Because of transparent and overlapping objects, the Windows API functions <b>ScrollWindow</b> and <b>ScrollDC</b> cannot be used. Instead, the <b>IOleInPlaceSiteWindowless::ScrollRect</b> method enables objects to perform scrolling.</dd>
<dt>
<b>Caret support</b></dt>
<dd>
A windowless object cannot safely show a caret without first checking whether the caret is partially or totally hidden by overlapping objects. In order to make that possible, an object can submit a rectangle to its site object when it calls the site's <b>IOleInPlaceSiteWindowless::AdjustRect</b> method to get a specified rectangle adjusted (usually, reduced) to ensure the rectangle fits in the clipping region.</dd>
</dl>
<h5>When to Implement</h5>
<p>
Implement this interface on the container's site object to support windowless objects.</p>
<h5>When to Use</h5>
<p>
The windowless object calls the methods in this interface to process window messages, to participate in drag and drop operations, and to perform drawing operations.</p>
<h4>Methods in Vtable Order</h4>
<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=48%><a href="if_r2z_9dwu.htm">IUnknown</a> Methods</th>
<th align=left width=52%>Description</th>
</tr>
<tr valign=top>
<td width=48%><a href="if_r2z_7fvp.htm"><b>QueryInterface</b></a></td>
<td width=52%>Returns a pointer to a specified interface.</td>
</tr>
<tr valign=top>
<td width=48%><a href="if_r2z_3rja.htm"><b>AddRef</b></a></td>
<td width=52%>Increments the reference count.</td>
</tr>
<tr valign=top>
<td width=48%><a href="if_r2z_59np.htm"><b>Release</b></a></td>
<td width=52%>Decrements the reference count.</td>
</tr>
</table><br>
<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=48%><a href="if_o_0vcn.htm">IOleWindow</a> Methods</th>
<th align=left width=52%>Description</th>
</tr>
<tr valign=top>
<td width=48%><a href="if_o_33qv.htm"><b>GetWindow</b></a></td>
<td width=52%>Gets a window handle.</td>
</tr>
<tr valign=top>
<td width=48%><a href="if_o_48og.htm"><b>ContextSensitiveHelp</b></a></td>
<td width=52%>Controls enabling of context-sensitive help.</td>
</tr>
</table><br>
<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=48%><a href="if_o_8g9x.htm">IOleInPlaceSite</a> Methods</th>
<th align=left width=52%>Description</th>
</tr>
<tr valign=top>
<td width=48%><a href="if_o_3gth.htm"><b>CanInPlaceActivate</b></a></td>
<td width=52%>Determines if the container can activate the object in place.</td>
</tr>
<tr valign=top>
<td width=48%><a href="if_o_6zqe.htm"><b>OnInPlaceActivate</b></a></td>
<td width=52%>Notifies the container that one of its objects is being activated in place.</td>
</tr>
<tr valign=top>
<td width=48%><a href="if_o_8yjp.htm"><b>OnUIActivate</b></a></td>
<td width=52%>Notifies the container that the object is about to be activated in place, and that the main menu will be replaced by a composite menu.</td>
</tr>
<tr valign=top>
<td width=48%><a href="if_o_9bw4.htm"><b>GetWindowContext</b></a></td>
<td width=52%>Enables an in-place object to retrieve window interfaces that form at the window object hierarchy, and the position in the parent window to locate the object's in-place activation window. </td>
</tr>
<tr valign=top>
<td width=48%><a href="if_o_28z0.htm"><b>Scroll</b></a></td>
<td width=52%>Specifies the number of pixels by which the container is to scroll the object. </td>
</tr>
<tr valign=top>
<td width=48%><a href="if_o_9xt1.htm"><b>OnUIDeactivate</b></a></td>
<td width=52%>Notifies the container to reinstall its user interface and take focus. </td>
</tr>
<tr valign=top>
<td width=48%><a href="if_o_2sbp.htm"><b>OnInPlaceDeactivate</b></a></td>
<td width=52%>Notifies the container that the object is no longer active in place. </td>
</tr>
<tr valign=top>
<td width=48%><a href="if_o_9vc5.htm"><b>DiscardUndoState</b></a></td>
<td width=52%>Instructs the container to discard its undo state.</td>
</tr>
<tr valign=top>
<td width=48%><a href="if_o_9o8f.htm"><b>DeactivateAndUndo</b></a></td>
<td width=52%>Deactivate the object and revert to undo state.</td>
</tr>
<tr valign=top>
<td width=48%><a href="if_o_8mcl.htm"><b>OnPosRectChange</b></a></td>
<td width=52%>Object's extents have changed.</td>
</tr>
</table><br>
<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=48%><a href="if_o_9xdk.htm">IOleInPlaceSiteEx</a> Methods</th>
<th align=left width=52%>Description</th>
</tr>
<tr valign=top>
<td width=48%><a href="if_o_16ew.htm"><b>OnInPlaceActivateEx</b></a></td>
<td width=52%>Called by the embedded object to determine if it needs to redraw itself upon activation.</td>
</tr>
<tr valign=top>
<td width=48%><a href="if_o_9os8.htm"><b>OnInPlaceDeactivateEx</b></a></td>
<td width=52%>Notifies the container of whether the object needs to be redrawn upon deactivation.</td>
</tr>
<tr valign=top>
<td width=48%><a href="if_o_8q91.htm"><b>RequestUIActivate</b></a></td>
<td width=52%>Notifies the container that the object is about to enter the UI-active state.</td>
</tr>
</table><br>
<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=48%>IOleInPlaceSiteWindowless Methods</th>
<th align=left width=52%>Description</th>
</tr>
<tr valign=top>
<td width=48%><a href="if_o_9rdx.htm"><b>CanWindowlessActivate</b></a></td>
<td width=52%>Informs an object if its container can support it as a windowless object that can be in-place activated.</td>
</tr>
<tr valign=top>
<td width=48%><a href="if_o_5xwl.htm"><b>GetCapture</b></a></td>
<td width=52%>Called by an in-place active, windowless object to determine if it still has the mouse capture or not.</td>
</tr>
<tr valign=top>
<td width=48%><a href="if_o_5l5x.htm"><b>SetCapture</b></a></td>
<td width=52%>Enables an in-place active, windowless object to capture all mouse messages.</td>
</tr>
<tr valign=top>
<td width=48%><a href="if_o_2oj7.htm"><b>GetFocus</b></a></td>
<td width=52%>Called by an in-place active, windowless object to determine if it still has the keyboard focus or not.</td>
</tr>
<tr valign=top>
<td width=48%><a href="if_o_4x4j.htm"><b>SetFocus</b></a></td>
<td width=52%>Sets the keyboard focus for a UI-active, windowless object.</td>
</tr>
<tr valign=top>
<td width=48%><a href="if_o_2llv.htm"><b>GetDC</b></a></td>
<td width=52%>Provides an object with a handle to a device context for a screen or compatible device from its container.</td>
</tr>
<tr valign=top>
<td width=48%><a href="if_o_82n7.htm"><b>ReleaseDC</b></a></td>
<td width=52%>Releases the device context previously obtained by a call to <b>IOleInPlaceSiteWindowless::GetDC</b>.</td>
</tr>
<tr valign=top>
<td width=48%><a href="if_o_8th0.htm"><b>InvalidateRect</b></a></td>
<td width=52%>Enables an object to invalidate a specified rectangle of its in-place image on the screen.</td>
</tr>
<tr valign=top>
<td width=48%><a href="if_o_39ke.htm"><b>InvalidateRgn</b></a></td>
<td width=52%>Enables an object to invalidate a specified region of its in-place image on the screen.</td>
</tr>
<tr valign=top>
<td width=48%><a href="if_o_6zec.htm"><b>ScrollRect</b></a></td>
<td width=52%>Enables an object to scroll an area within its in-place active image on the screen.</td>
</tr>
<tr valign=top>
<td width=48%><a href="if_o_92r8.htm"><b>AdjustRect</b></a></td>
<td width=52%>Adjusts a specified rectangle if it is entirely or partially covered by overlapping, opaque objects.</td>
</tr>
<tr valign=top>
<td width=48%><a href="if_o_9wh1.htm"><b>OnDefWindowMessage</b></a></td>
<td width=52%>Invokes the default processing for all messages passed to an object.</td>
</tr>
</table><br>
<h4>QuickInfo</h4>
<p>
<b>&nbsp;&nbsp;Windows NT: </b>Use version 4.0 or later. New for OC96.<br>
<b>&nbsp;&nbsp;Windows: </b>Use Windows 95 or later. New for OC96.<br>
<b>&nbsp;&nbsp;Windows CE: </b>Unsupported.<br>
<b>&nbsp;&nbsp;Header: </b>Declared in ocidl.h.</p>
<h4>See Also</h4>
<p>
<a href="if_a2e_5zy0.htm"><b>IAdviseSinkEx</b></a>, <a href="if_o_2euk.htm"><b>IOleControl</b></a>, <a href="if_o_0lo2.htm"><b>IOleInPlaceActiveObject::TranslateAccelerator</b></a>, <a href="if_o_6ib7.htm"><b>IOleInPlaceObjectWindowless</b></a>, </p>
<p>
</p>
<p>
</p>
<p>&nbsp;</p></body>
</HTML>
