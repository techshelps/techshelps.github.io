<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CoGetMarshalSizeMax</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_com_cogetmarshalsizemax"></a>CoGetMarshalSizeMax</h1>
<p>
Returns an upper bound on the number of bytes needed to marshal the specified interface pointer to the specified object. </p>
<pre><code><b>STDAPI CoGetMarshalSizeMax(
  ULONG</b><i> *pulSize</i><b>,       </b>//Pointer to the upper-bound value
<b>  REFIID</b><i> riid</i><b>,          </b>//Reference to the identifier of the 
                        // interface
<b>  IUnknown *</b><i> pUnk</i><b>,      </b>//Pointer to the interface to be marshaled
<b>  DWORD</b><i> dwDestContext</i><b>,  </b>//Destination process
<b>  LPVOID</b><i> pvDestContext</i><b>, </b>//Reserved for future use
<b>  DWORD</b><i> mshlflags       </i>//Reason for marshaling
<b>);</b>
 </code></pre>
<h4>Parameters</h4>
<dl>
<dt>
<i>pulSize</i></dt>
<dd>
[out] Pointer to the upper-bound value on the size, in bytes, of the data packet to be written to the marshaling stream; a value of zero means that the size of the packet is unknown.</dd>
<dt>
<i>riid</i></dt>
<dd>
[in] Reference to the identifier of the interface whose pointer is to be marshaled. This interface must be derived from the <a href="if_r2z_9dwu.htm"><b>IUnknown</b></a> interface.</dd>
<dt>
<i>pUnk</i></dt>
<dd>
[in] Pointer to the interface to be marshaled. This interface must be derived from the <a href="if_r2z_9dwu.htm"><b>IUnknown</b></a> interface.</dd>
<dt>
<i>dwDestContext</i></dt>
<dd>
[in] Destination context where the specified interface is to be unmarshaled. Values for <i>dwDestContext</i> come from the enumeration <a href="enums_6mpk.htm"><b>MSHCTX</b></a>.</dd>
<dt>
<i>pvDestContext</i></dt>
<dd>
[in] Reserved for future use; must be NULL.</dd>
<dt>
<i>mshlflags</i></dt>
<dd>
[in] Flag indicating whether the data to be marshaled is to be transmitted back to the client process—the normal case—or written to a global table, where it can be retrieved by multiple clients. Values come from the enumeration <a href="enums_5bg3.htm"><b>MSHLFLAGS</b></a>.
</dd>
</dl>
<h4>Return Values</h4>
<p>
This function supports the standard return value E_UNEXPECTED, as well as the following:
<dl>
<dt>
S_OK</dt>
<dd>
The upper bound was returned successfully.</dd>
<dt>
CO_E_NOTINITIALIZED</dt>
<dd>
The <a href="api1_36qt.htm"><b>CoInitialize</b></a> or <a href="api3_6med.htm"><b>OleInitialize</b></a> function was not called on the current thread before this function was called.
</dd>
</dl>
<h4>Remarks</h4>
<p>
This function performs the following tasks:
<ol>
<li>
Queries the object for an <b>IMarshal</b> pointer or, if the object does not implement <b>IMarshal</b>, gets a pointer to COM's standard marshaler.</li>
<li>
Using whichever pointer is obtained in the preceding step, calls <b>IMarshal::GetMarshalSizeMax</b>.</li>
<li>
Adds to the value returned by the call to <b>GetMarshalSizeMax</b> the size of the marshaling data header and, possibly, that of the proxy CLSID to obtain the maximum size in bytes of the amount of data to be written to the marshaling stream.</li>
</ol>
<p>
You do not explicitly call this function unless you are implementing <b>IMarshal</b>, in which case your marshaling stub should call this function to get the correct size of the data packet to be marshaled.</p>
<p>
The value returned by this method is guaranteed to be valid only as long as the internal state of the object being marshaled does not change. Therefore, the actual marshaling should be done immediately after this function returns, or the stub runs the risk that the object, because of some change in state, might require more memory to marshal than it originally indicated.</p>
<h4>QuickInfo</h4>
<p>
<b>&nbsp;&nbsp;Windows NT: </b>Use version 3.1 or later.<br>
<b>&nbsp;&nbsp;Windows: </b>Use Windows 95 or later.<br>
<b>&nbsp;&nbsp;Windows CE: </b>Unsupported.<br>
<b>&nbsp;&nbsp;Header: </b>Declared in objbase.h.<br>
<b>&nbsp;&nbsp;Import Library: </b>Included as a resource in ole32.dll.</p>
<h4>See Also</h4>
<p>
<a href="api1_8205.htm"><b>CoMarshalInterface</b></a>, <a href="if_f2n_2fjs.htm"><b>IMarshal::GetMarshalSizeMax</b></a> </p>
<p>
</p>
<p>
</p>
<p>&nbsp;</p></body>
</HTML>
