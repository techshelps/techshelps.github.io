<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>IMarshal::GetMarshalSizeMax</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h2><a name="_com_imarshal_getmarshalsizemax"></a>IMarshal::GetMarshalSizeMax</h2>
<p>
Returns an upper bound on the number of bytes needed to marshal the specified interface pointer on the specified object. </p>
<pre><code><b>HRESULT GetMarshalSizeMax(
  REFIID</b><i> riid</i><b>,          </b>//Reference to the identifier of the 
                        //interface to be marshaled
<b>  void</b><i> *pv</i><b>,             </b>//Interface pointer to be marshaled
<b>  DWORD</b><i> dwDestContext</i><b>,  </b>//Destination process
<b>  void *</b><i> pvDestContext</i><b>, </b>//Reserved for future use
<b>  DWORD</b><i> mshlflags</i><b>,      </b>//Reason for marshaling
<b>  ULONG *</b><i> pSize         </i>//Pointer to upper-bound value
<b>);</b>
 </code></pre>
<h4>Parameters</h4>
<dl>
<dt>
<i>riid</i></dt>
<dd>
[in] Reference to the identifier of the interface to be marshaled.</dd>
<dt>
<i>pv</i></dt>
<dd>
[in] Interface pointer to be marshaled; can be NULL.</dd>
<dt>
<i>dwDestContext</i></dt>
<dd>
[in] Destination context where the specified interface is to be unmarshaled. Values for <i>dwDestContext</i> come from the enumeration <a href="enums_6mpk.htm"><b>MSHCTX</b></a>. Currently, unmarshaling can occur either in another apartment of the current process (MSHCTX_INPROC) or in another process on the same computer as the current process (MSHCTX_LOCAL).</dd>
<dt>
<i>pvDestContext</i></dt>
<dd>
[in] Reserved for future use; must be NULL.</dd>
<dt>
<i>mshlflags</i></dt>
<dd>
[in] Flag indicating whether the data to be marshaled is to be transmitted back to the client process — the normal case — or written to a global table, where it can be retrieved by multiple clients. Valid values come from the <a href="enums_5bg3.htm"><b>MSHLFLAGS</b></a> enumeration.</dd>
<dt>
<i>pSize</i></dt>
<dd>
[out] Pointer to the upper bound on the amount of data to be written to the marshaling stream.
</dd>
</dl>
<h4>Return Values</h4>
<p>
The method supports the standard return value E_FAIL, as well as the following: 
<dl>
<dt>
S_OK </dt>
<dd>
The maximum size was returned successfully.</dd>
<dt>
E_NOINTERFACE</dt>
<dd>
The specified interface was not supported.
</dd>
</dl>
<h4>Remarks</h4>
<p>
This method is called indirectly, in a call to <a href="api1_1p2w.htm"><b>CoGetMarshalSizeMax</b></a>, by whatever code in the server process is responsible for marshaling a pointer to an interface on an object. This marshaling code is usually a stub generated by COM for one of several interfaces that can marshal a pointer to an interface implemented on an entirely different object. Examples include the <a href="if_a2e_9mk9.htm"><b>IClassFactory</b></a> and <a href="if_o_0yb6.htm"><b>IOleItemContainer</b></a> interfaces. For purposes of discussion, the code responsible for marshaling a pointer is here called the "marshaling stub."</p>
<p>
To create a proxy for an object, COM requires two pieces of information from the original object: the amount of data to be written to the marshaling stream and the proxy's CLSID.</p>
<p>
The marshaling stub obtains these two pieces of information with successive calls to <b>CoGetMarshalSizeMax</b> and <a href="api1_8205.htm"><b>CoMarshalInterface</b></a>. </p>
<h5>Note to Callers</h5>
<p>
The marshaling stub, through a call to <b>CoGetMarshalSizeMax</b>, calls the object's implementation of this method to preallocate the stream buffer that will be passed to <a href="if_f2n_8ox1.htm"><b>IMarshal::MarshalInterface</b></a>. </p>
<p>
You do not explicitly call this method if you are:
<ul>
<li>
Implementing existing COM interfaces, or</li>
<li>
Defining your own custom interfaces, using the Microsoft Interface Definition Language (MIDL).</li>
</ul>
<p>
In both cases, the MIDL-generated stub automatically makes the call.</p>
<p>
If you are <i>not</i> using MIDL to define your own interface (see <a href="custintf_1777.htm"><b>Defining COM Interfaces</b></a>), your marshaling stub does not have to call <b>GetMarshalSizeMax</b>, though doing so is highly recommended. An object knows better than an interface stub what the maximum size of a marshaling data packet is likely to be. Therefore, unless you are providing an automatically growing stream that is so efficient that the overhead of expanding it is insignificant, you should call this method even when implementing your own interfaces.</p>
<p>
The value returned by this method is only guaranteed to be valid as long as the internal state of the object being marshaled does not change. Therefore, the actual marshaling should be done immediately after this function returns, or the stub runs the risk that the object, because of some change in state, might require more memory to marshal than it originally indicated.</p>
<h5>Notes to Implementers</h5>
<p>
Your implementation of <b>MarshalInterface</b> will use this buffer to write marshaling data into the stream. If the buffer is too small, the marshaling operation will fail. Therefore, the value returned by this method <i>must</i> be a conservative estimate of the amount of data that will, in fact, be needed to marshal the interface. Violation of this requirement should be treated as a catastrophic error.</p>
<p>
In a subsequent call to <b>IMarshal::MarshalInterface</b>, your <b>IMarshal</b> implementation cannot rely on the caller actually having called <b>GetMarshalSizeMax</b> beforehand. It must still be wary of STG_E_MEDIUMFULL errors returned by the stream and be prepared to handle them gracefully.</p>
<p>
To ensure that your implementation of <b>GetMarshalSizeMax </b>will continue to work properly as new destination contexts are supported in the future, delegate marshaling to COM's default implementation for all <i>dwDestContext</i> values that your implementation does not understand. To delegate marshaling to COM's default implementation, call the <a href="api1_88q4.htm"><b>CoGetStandardMarshal</b></a> function.</p>
<h4>QuickInfo</h4>
<p>
<b>&nbsp;&nbsp;Windows NT: </b>Use version 3.1 or later.<br>
<b>&nbsp;&nbsp;Windows: </b>Use Windows 95 or later.<br>
<b>&nbsp;&nbsp;Windows CE: </b>Unsupported.<br>
<b>&nbsp;&nbsp;Header: </b>Declared in objidl.h.</p>
<h4>See Also</h4>
<p>
<a href="api1_1p2w.htm"><b>CoGetMarshalSizeMax</b></a>, <a href="if_f2n_8ox1.htm"><b>IMarshal::MarshalInterface</b></a> </p>
<p>
</p>
<p>
</p>
<p>&nbsp;</p></body>
</HTML>
