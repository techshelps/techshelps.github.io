<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CoGetStdMarshalEx</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_com_cogetstdmarshalex"></a>CoGetStdMarshalEx</h1>
<p>
Creates an aggregated standard marshaler for use with lightweight client-side handlers.</p>
<pre><code><b>HRESULT CoGetStdMarshalEx(
  IUnknown *</b><i> pUnkOuter</i><b>,     </b>//Pointer to the controlling IUnknown
<b>  DWORD</b><i> dwSMEXFlags</i><b>,      </b>//Indicates whether marshaler is client- or server-side
<b>  IUnknown **</b><i> ppUnkInner</i><b>,    </b>//Address of IUnknown pointer on aggregated marshaler
<b>);</b>
 </code></pre>
<h4>Parameters</h4>
<dl>
<dt>
<i>pUnkOuter</i></dt>
<dd>
[in] Pointer to the controlling <a href="if_r2z_9dwu.htm"><b>IUnknown</b></a>.</dd>
<dt>
<i>dwSMEXFlags</i></dt>
<dd>
[in] One of two values indicating whether the aggregated standard marshaler is on the client side or the server side. These flags are defined in the STDMSHFLAGS enumeration as follows:
<pre><code>typedef enum tagSTDMSHLFLAGS
{
    SMEXF_SERVER   = 0x01,  //server side aggregated std marshaler
    SMEXF_HANDLER  = 0x02  //client side (handler) agg std marshaler
} STDMSHLFLAGS; 
 </code></pre>
</dd>
<dt>
<i>ppUnkInner</i></dt>
<dd>
[out] On successful return, address of pointer to the <b>IUnknown</b> interface on the newly-created aggregated standard marshaler. If an error occurs, this value is NULL.
</dd>
</dl>
<h4>Return Values</h4>
<dl>
<dt>
S_OK</dt>
<dd>
The standard marshaler was successfully created and aggregated with the proxy, and its <b>IUnknown</b> pointer was returned.
</dd>
</dl>
<h4>Remarks</h4>
<p>
The server calls <b>CoGetStdMarshalEx</b> passing in the flag SMEXF_SERVER. This creates a server side standard marshaler (a.k.a. a stub manager). The handler calls <b>CoGetStdMarshalEx</b> passing in the flag SMEXF_HANDLER. This creates a client side standard marshaler (a.k.a. a proxy manager). Note that when calling this API, the handler must pass the original controlling unknown that was passed to the handler when the handler was created. This will be the system implemented controlling unknown. Failure to pass the correct <b>IUnknown</b> results in an error returned. On success, the <i>ppUnkInner</i> returned is the controlling unknown of the inner object. The server and handler must keep this pointer, and may use it to call <b>IUnknown::QueryInterface</b> for the <b>IMarshal</b> interface.</p>
<h4>QuickInfo</h4>
<p>
<b>&nbsp;&nbsp;Windows NT: </b>Use version 5.0 or later.<br>
<b>&nbsp;&nbsp;Windows: </b>Unsupported.<br>
<b>&nbsp;&nbsp;Windows CE: </b>Unsupported.<br>
<b>&nbsp;&nbsp;Header: </b>Declared in objbase.h.<br>
<b>&nbsp;&nbsp;Import Library: </b>Included as a resource in ole32.dll.</p>
<h4>See Also</h4>
<p>
<a href="if_r2z_99tb.htm"><b>IStdMarshalInfo</b></a><b>, <a href="if_f2n_6sh8.htm">IMarshal</a>, <a href="comext_2qcz.htm">Lightweight Client-side Handlers</a></b></p>
<p>&nbsp;</p></body>
</HTML>
