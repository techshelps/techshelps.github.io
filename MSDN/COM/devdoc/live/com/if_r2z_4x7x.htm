<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>IStream</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_com_istream"></a>IStream</h1>
<p>
The <b>IStream</b> interface supports reading and writing data to stream objects. Stream objects contain the data in a structured storage object, where storages provide the structure. Simple data can be written directly to a stream, but most frequently, streams are elements nested within a storage object. They are similar to standard files.</p>
<p>
The <b>IStream</b> interface defines methods similar to the MS-DOS FAT file functions. For example, each stream object has its own access rights and a seek pointer. The main difference between a stream object and a DOS file is that streams are not opened using a file handle, but through an <b>IStream</b> interface pointer.</p>
<p>
The methods in this interface present your object's data as a contiguous sequence of bytes that you can read or write. There are also methods for committing and reverting changes on streams open in transacted mode and methods for restricting access to a range of bytes in the stream.</p>
<p>
Streams can remain open for long periods of time without consuming file system resources. The <b>IStream::Release</b> method is similar to a close function on a file. Once released, the stream object is no longer valid and cannot be used.</p>
<p>
Clients of asynchronous monikers can choose between a <i>data-pull </i>or <i>data-push </i>model for driving an asynchronous <a href="if_f2n_1kx1.htm"><b>IMoniker::BindToStorage</b></a> operation and for receiving asynchronous notifications.The table below compares the behavior of  asynchronous <a href="if_r2z_14mc.htm"><b>ISequentialStream::Read</b></a><b> </b>and <a href="if_r2z_55m3.htm"><b>IStream::Seek</b></a><b> </b>calls returned in <a href="if_a2e_0x2d.htm"><b>IBindStatusCallback::OnDataAvailable</b></a> in these two download models:</p>
<table cellspacing=4 cols=3>
<tr valign=top>
<th align=left width=24%>IStream method call</th>
<th align=left width=37%>Behavior in <i>data-pull </i>model</th>
<th align=left width=39%>Behavior in <i>data-push</i> model</th>
</tr>
<tr valign=top>
<td width=24%><b>Read</b> is called to read partial data, (i.e. not all the available data)</td>
<td width=37%>Returns S_OK. The client must continue to read all available data before returning from <b>IBindStatusCallback::OnDataAvailable</b> or else the bind operation is blocked. (i.e. read until S_FALSE or E_PENDING is returned)</td>
<td width=39%>Returns S_OK. Even if the client returns from <b>IBindStatusCallback::OnDataAvailable</b> at this point the bind operation  continues and <b>IBindStatusCallback::OnDataAvailable</b> will be called again repeatedly until the binding finishes.</td>
</tr>
<tr valign=top>
<td width=24%><b>Read</b> is called to read all the available data</td>
<td width=37%>Returns E_PENDING if the bind operation has not completed, and <b>IBindStatusCallback::OnDataAvailable</b> will be called again when more data is available. </td>
<td width=39%>Same as data-pull model.</td>
</tr>
<tr valign=top>
<td width=24%><b>Read</b> is called to read all the available data and the bind operation is over (end-of-file)</td>
<td width=37%>Returns S_FALSE. There will be a subsequent call to <b>IBindStatusCallback::OnDataAvailable</b> with the <i>grfBSC</i> flag set to BSCF_LASTDATANOTIFICATION.</td>
<td width=39%>Same as data-pull model.</td>
</tr>
<tr valign=top>
<td width=24%><b>Seek</b> is called</td>
<td width=37%><b>Seek</b> doesn't work in data-pull model</td>
<td width=39%><b>Seek</b> doesn't work in data-push model.</td>
</tr>
</table><br>
<p>
For general information on this topic, see <a href="monikers_3g8j.htm">Asynchronous Monikers</a> and <a href="monikers_0x4c.htm">Data-Pull-Model versus Data Push-Model</a> for more specific information. Also, see <a href="com_8cz2.htm">Managing Memory Allocation</a> for details on COM's rules for managing memory.</p>
<h5>When to Implement</h5>
<p>
Implement <b>IStream</b> on a container or object application when you require functionality not provided by the COM compound file implementation. The specification of <b>IStream</b> defines more functionality that the COM implementation supports. In addition, if you are creating a stream object that is larger than the heap in your machine's memory and you are using a global memory handle, the compound file implementation calls <b>GlobalRealloc</b> internally whenever it needs more memory, which can be extremely inefficient. In this case, the preferred solution is to implement an <b>IStream</b> that uses memory allocated by <b>VirtualAlloc</b> instead of <b>GlobalAlloc</b>. This can reserve a large chunk of virtual address space and then commit memory within that address space as required. No data copying occurs and memory is committed only as it is needed. For more information, refer to <a href="if_r2z_459q.htm"><b>IStream - Compound File Implementation</b></a>. </p>
<p>
The <b>IStream</b> interface inherits <b>Read</b> and <b>Write</b> methods from <a href="if_r2z_1k19.htm"><b>ISequentialStream</b></a>.</p>
<p>
<b>Note</b>&nbsp;&nbsp;Most containers do not implement <b>ISequentialStream</b> as a separate interface, and you are not required to provide it separately even if you provide an <b>IStream</b> implementation. For example, the compound file implementation of structured storage does not succeed on a <b>QueryInterface</b> for <b>ISequentialStream</b> but it includes the <b>Read</b> and <b>Write</b> methods through the <b>IStream</b> interface pointer. The same is true for the NTFS Native Structured Storage implementation.</p>
<h5>When to Use</h5>
<p>
Call the methods of the <b>IStream</b> interface from a container or application to read and write the data for an object. Since stream objects can be marshaled to other processes, applications can share the data in storage objects without having to use global memory.</p>
<h4>Methods in Vtable Order</h4>
<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=48%><a href="if_r2z_9dwu.htm">IUnknown</a> Methods</th>
<th align=left width=52%>Description</th>
</tr>
<tr valign=top>
<td width=48%><a href="if_r2z_7fvp.htm"><b>QueryInterface</b></a></td>
<td width=52%>Returns pointers to supported interfaces.</td>
</tr>
<tr valign=top>
<td width=48%><a href="if_r2z_3rja.htm"><b>AddRef</b></a></td>
<td width=52%>Increments the reference count.</td>
</tr>
<tr valign=top>
<td width=48%><a href="if_r2z_59np.htm"><b>Release</b></a></td>
<td width=52%>Decrements the reference count.</td>
</tr>
</table><br>
<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=48%><a href="if_r2z_1k19.htm">ISequentialStream</a> Methods</th>
<th align=left width=52%>Description</th>
</tr>
<tr valign=top>
<td width=48%><a href="if_r2z_14mc.htm"><b>Read</b></a></td>
<td width=52%>Reads a specified number of bytes from the stream object into memory starting at the current seek pointer.</td>
</tr>
<tr valign=top>
<td width=48%><a href="if_r2z_3yat.htm"><b>Write</b></a></td>
<td width=52%>Writes a specified number of bytes into the stream object starting at the current seek pointer.</td>
</tr>
</table><br>
<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=48%>IStream Methods</th>
<th align=left width=52%>Description</th>
</tr>
<tr valign=top>
<td width=48%><a href="if_r2z_55m3.htm"><b>Seek</b></a></td>
<td width=52%>Changes the seek pointer to a new location relative to the beginning of the stream, the end of the stream, or the current seek pointer.</td>
</tr>
<tr valign=top>
<td width=48%><a href="if_r2z_3ysl.htm"><b>SetSize</b></a></td>
<td width=52%>Changes the size of the stream object.</td>
</tr>
<tr valign=top>
<td width=48%><a href="if_r2z_3lkf.htm"><b>CopyTo</b></a></td>
<td width=52%>Copies a specified number of bytes from the current seek pointer in the stream to the current seek pointer in another stream.</td>
</tr>
<tr valign=top>
<td width=48%><a href="if_r2z_5oac.htm"><b>Commit</b></a></td>
<td width=52%>Ensures that any changes made to a stream object open in transacted mode are reflected in the parent storage object.</td>
</tr>
<tr valign=top>
<td width=48%><a href="if_r2z_9th0.htm"><b>Revert</b></a></td>
<td width=52%>Discards all changes that have been made to a transacted stream since the last <a href="if_r2z_5oac.htm"><b>IStream::Commit</b></a> call.</td>
</tr>
<tr valign=top>
<td width=48%><a href="if_r2z_1jji.htm"><b>LockRegion</b></a></td>
<td width=52%>Restricts access to a specified range of bytes in the stream. Supporting this functionality is optional since some file systems do not provide it.</td>
</tr>
<tr valign=top>
<td width=48%><a href="if_r2z_1f72.htm"><b>UnlockRegion</b></a></td>
<td width=52%>Removes the access restriction on a range of bytes previously restricted with <a href="if_r2z_1jji.htm"><b>IStream::LockRegion</b></a>.</td>
</tr>
<tr valign=top>
<td width=48%><a href="if_r2z_6gtw.htm"><b>Stat</b></a></td>
<td width=52%>Retrieves the <a href="structs_7x7r.htm"><b>STATSTG</b></a> structure for this stream.</td>
</tr>
<tr valign=top>
<td width=48%><a href="if_r2z_6ov9.htm"><b>Clone</b></a></td>
<td width=52%>Creates a new stream object that references the same bytes as the original stream but provides a separate seek pointer to those bytes.</td>
</tr>
</table><br>
<h4>QuickInfo</h4>
<p>
<b>&nbsp;&nbsp;Windows NT: </b>Use version 3.1 or later.<br>
<b>&nbsp;&nbsp;Windows: </b>Use Windows 95 or later.<br>
<b>&nbsp;&nbsp;Windows CE: </b>Unsupported.<br>
<b>&nbsp;&nbsp;Header: </b>Declared in objidl.h.</p>
<h4>See Also<i> </i></h4>
<p>
<a href="if_r2z_459q.htm"><b>IStream - Compound File Implementation</b></a>, <a href="if_r2z_1k19.htm"><b>ISequentialStream</b></a> </p>
<p>
</p>
<p>
</p>
<p>&nbsp;</p></body>
</HTML>
