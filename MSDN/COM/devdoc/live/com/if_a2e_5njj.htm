<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>IBindStatusCallback::GetBindInfo</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h2><a name="_com_ibindstatuscallback_getbindinfo"></a>IBindStatusCallback::GetBindInfo</h2>
<p>
An asynchronous moniker calls this method to obtain the bind information for the bind operation. </p>
<pre><code><b>HRESULT GetBindInfo(
  DWORD</b><i> *pgrfBINDF</i><b>,</b>   //Pointer to BINDF value
<b>  BINDINFO</b><i> *pbindinfo </i>//Pointer to BINDINFO structure
<b>);</b>
 </code></pre>
<h4>Parameters</h4>
<dl>
<dt>
<i>pgrfBINDF</i></dt>
<dd>
[out] Pointer to a value taken from the BINDF enumeration indicating whether the bind should proceed synchronously or asynchronously.</dd>
<dt>
<i>pbindinfo</i></dt>
<dd>
[in, out] Pointer to the BINDINFO structure which describes how the client wants the binding to occur.
</dd>
</dl>
<h4>Return Values</h4>
<dl>
<dt>
S_OK</dt>
<dd>
The operation was successful.</dd>
<dt>
E_INVALIDARG</dt>
<dd>
One or more parameters are invalid.
</dd>
</dl>
<h4>Remarks</h4>
<p>
The moniker calls this method in its implementations of <a href="if_f2n_7o6s.htm"><b>IMoniker::BindToObject</b></a> and <a href="if_f2n_1kx1.htm"><b>IMoniker::BindToStorage</b></a> to obtain information about the specific bind operation. </p>
<p>
Asynchronous moniker clients should be aware that a moniker may call <b>IBindStatusCallback::GetBindInfo</b> more than once during a bind operation. A proper implementation of <b>GetBindInfo</b> should prepare for this possibility. If returning data in the <i>pBindInfo<b> </b></i>parameter, the implementation should allocate the appropriate data(<i>szExtraInfo</i> and/or <i>stgmedData</i>) at the time of each call. In this way, if the callback is never called, data is never allocated, and if the callback is called more than once, it will work correctly. The first time this callback is received by the asynchronous moniker client is <i>before</i> the call to <b>IMoniker::BindToStorage</b> or <b>IMoniker::BindToObject</b>.</p>
<p>
<b>Note</b>&nbsp;&nbsp;Even when the value of <i>pgrfBINDF</i> is BINDF_ASYNCHRONOUS, it is possible that the original call to <a href="if_f2n_1kx1.htm"><b>IMoniker::BindToStorage</b></a> or <a href="if_f2n_7o6s.htm"><b>IMoniker::BindToObject</b></a> may return synchronously rather than returning the MK_S_ASYNCHRONOUS flag. Clients of asynchronous monikers should always prepare for this possibility. Specifically, it is important for avoiding memory leaks to make sure to release the pointer returned a call to either method.</p>
<p>
One way to deal with this case is to call your own implementation of <a href="if_a2e_0x2d.htm"><b>IBindStatusCallback::OnDataAvailable</b></a> or <a href="if_a2e_2vz9.htm"><b>IBindStatusCallback::OnObjectAvailable</b></a> in order to use the same code path regardless of whether you bind synchronously or asynchronously.) </p>
<h4>QuickInfo</h4>
<p>
<b>&nbsp;&nbsp;Windows NT: </b>Use version 5.0 or later.<br>
<b>&nbsp;&nbsp;Windows: </b>Unsupported.<br>
<b>&nbsp;&nbsp;Windows CE: </b>Unsupported.<br>
<b>&nbsp;&nbsp;Header: </b>Declared in urlmon.h.</p>
<h4>See Also</h4>
<p>
<a href="enums_6q1y.htm"><b>BINDF</b></a>, <a href="structs_06lr.htm"><b>BINDINFO</b></a>, <a href="api3_8bvv.htm"><b>RegisterBindStatusCallback</b></a> </p>
<p>
</p>
<p>
</p>
<p>&nbsp;</p></body>
</HTML>
