<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Implementing and Activating a Handler with No Extra Server Data</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h3><a name="_com_implementing_and_activating_a_handler_with_no_extra_server_data"></a>Implementing and Activating a Handler with No Extra Server Data</h3>
<p>
To create an instance of your handler, if it is one that gets no extra server data, the server must implement <a href="if_r2z_99tb.htm"><b>IStdMarshalInfo</b></a>, but not <b>IMarshal</b>. <b>IStdMarshalInfo</b> has one method, <b>GetClassForHandler</b>, which retrieves the CLSID of the object handler to be used in the destination process. COM calls this when it calls <a href="api1_8205.htm"><b>CoMarshalInterface</b></a> for you, and activates the handler on the client side.</p>
<p>
Next, both the server and handler implementations must call a function new in Windows NT5.0, <a href="api1_2h14.htm"><b>CoGetStdMarshalEx</b></a>. This function creates a standard marshaler on each side (called a proxy manager on the client side, and a stub manager on the server side).</p>
<p>
The server calls <b>CoGetStdMarshalEx</b> passing in the flag SMEXF_SERVER. This creates a server side standard marshaler (stub manager). The server side structure looks like this:</p>
<p>
<img src="images/ssstruct.gif" border=0></p>
<p>
<b>Server Side Structure</b></p>
<p>
The handler calls <b>CoGetStdMarshalEx</b> passing in the flag SMEXF_HANDLER. This creates a client side standard marshaler (proxy manager), and aggregates it with the handler on the client side. The lifetime of both are managed by the controlling identity object (implementing IUnknown) that the system implements as well when the handler calls <b>CoGetStdMarshalEx</b> (refer to this function for more information). The client side structure looks like this:</p>
<p>
<img src="images/csstruct.gif" border=0></p>
<p>
<b>Client Side Structure. Solid blue circles are exposed interfaces.</b></p>
<p>
As seen in this figure, the handler is actually sandwiched between the proxy manager and the identity/controlling unknown. This gives the system control over the lifetime of the object, while giving the handler control over the exposed interfaces. The dashed line between the Identity and Proxy Manager indicates that the two share tight integration through internal private interfaces.</p>
<p>
When COM calls CoUnmarshalInterface for the client, it will create the handler instance, aggregating it with the Identity. The handler will create the standard marshaler (through the call to <b>CoGetStdMarshalEx</b>, passing in the controlling unknown it received when it was created. The handler does not implement <b>IMarshal</b>, but will just return the IMarshal from the standard marshaler. Note that even if the handler does implement <b>IMarshal</b>, it will not get called during an unmarshal.</p>
<p>
If two threads simultaneously unmarshal the same object for the first time, it is possible for two handlers to get created temporarily. One will subsequently be Released. </p>
<p>&nbsp;</p></body>
</HTML>
