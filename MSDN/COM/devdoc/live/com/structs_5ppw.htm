<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>PROPVARIANT</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_com_propvariant"></a>PROPVARIANT</h1>
<p>
The PROPVARIANT structure is used in most of the methods of <b>IPropertyStorage</b> to define the type tag and the value of a property in a property set. There are five members. The first, the value type tag, and the last, the value of the property, are significant. The middle three are reserved for future use. The PROPVARIANT structure is defined as follows:</p>
<p>
<b>Note</b>&nbsp;&nbsp;The <b>bool</b> member in previous definitions of this structure has been renamed to <b>boolVal</b>, since some compilers now recognize <i>bool</i> as a keyword.</p>
<pre><code>struct PROPVARIANT{
    VARTYPE        vt;          // value type tag
    WORD           wReserved1;
    WORD           wReserved2;
    WORD           wReserved3;
    union { 
    // none                     // VT_EMPTY, VT_NULL, VT_ILLEGAL
    unsigned char  bVal;        // VT_UI1
    short          iVal;        // VT_I2
    USHORT         uiVal;       // VT_UI2
    long           lVal;        // VT_I4
    ULONG          ulVal;       // VT_UI4
    LARGE_INTEGER  hVal;        // VT_I8
    ULARGE_INTEGER uhVal;       // VT_UI8
    float          fltVal;      // VT_R4
    double         dblVal;      // VT_R8
    CY             cyVal;       // VT_CY
    DATE           date;        // VT_DATE
    BSTR           bstrVal;     // VT_BSTR  
    VARIANT_BOOL   boolVal;        // VT_BOOL
    SCODE          scode;       // VT_ERROR
    FILETIME       filetime;    // VT_FILETIME
    LPSTR          pszVal;      // VT_LPSTR     // string in the current system Ansi code page
    LPWSTR         pwszVal;     // VT_LPWSTR    // string in Unicode
    CLSID*         puuid;       // VT_CLSID
    CLIPDATA*      pclipdata;   // VT_CF
 
    BLOB           blob;        // VT_BLOB, VT_BLOBOBJECT
    IStream*       pStream;     // VT_STREAM, VT_STREAMED_OBJECT
    IStorage*      pStorage;    // VT_STORAGE, VT_STORED_OBJECT
 
    CAUB           caub;         // VT_VECTOR | VT_UI1
    CAI            cai;          // VT_VECTOR | VT_I2
    CAUI           caui;         // VT_VECTOR | VT_UI2
    CAL            cal;          // VT_VECTOR | VT_I4
    CAUL           caul;         // VT_VECTOR | VT_UI4
    CAH            cah;          // VT_VECTOR | VT_I8
    CAUH           cauh;         // VT_VECTOR | VT_UI8
    CAFLT          caflt;        // VT_VECTOR | VT_R4
    CADBL          cadbl;        // VT_VECTOR | VT_R8
    CACY           cacy;         // VT_VECTOR | VT_CY
    CADATE         cadate;       // VT_VECTOR | VT_DATE
    CABSTR         cabstr;       // VT_VECTOR | VT_BSTR
    CABOOL         cabool;       // VT_VECTOR | VT_BOOL
    CASCODE        cascode;      // VT_VECTOR | VT_ERROR
    CALPSTR        calpstr;      // VT_VECTOR | VT_LPSTR
    CALPWSTR       calpwstr;     // VT_VECTOR | VT_LPWSTR
    CAFILETIME     cafiletime;   // VT_VECTOR | VT_FILETIME
    CACLSID        cauuid;       // VT_VECTOR | VT_CLSID
    CACLIPDATA     caclipdata;   // VT_VECTOR | VT_CF
    CAPROPVARIANT  capropvar;    // VT_VECTOR | VT_VARIANT
    }} <b>PROPVARIANT</b>
 </code></pre>
<h4>Remarks</h4>
<p>
PROPVARIANT is the fundamental data type by which property values are read and written through the <a href="if_p2q_80md.htm"><b>IPropertyStorage</b></a> interface.</p>
<p>
The data type PROPVARIANT is related to the data type VARIANT, defined as part of Automation in OLE2 and defined in the Win32 SDK header file oleauto.h. Several definitions are reused from Automation, as follows:</p>
<pre><code>typedef struct  tagCY {
    unsigned long      Lo;
    long               Hi;
    } CY
 
typedef CY             CURRENCY;
typedef short          VARIANT_BOOL;
typedef unsigned short VARTYPE;
typedef double         DATE;
typedef OLECHAR*       BSTR;
 
typedef struct         tagCLIPDATA {
    ULONG              cbSize;  //Includes sizeof(ulClipFmt)
    long               ulClipFmt;
    BYTE*              pClipData;
    } CLIPDATA
 </code></pre>
<p>
In addition, several new data types that define counted arrays of other data types are required. The data types of all counted arrays begin with the letters <b>CA</b> (such as <b>CAUB</b>) and have an ORed <i>vt</i> value. The counted array structure has the following form (where <i>name</i> is the specific name of the counted array):</p>
<pre><code>#define TYPEDEF_CA(type, name) 
 
    typedef struct tag ## <i>name</i> {\
        ULONG cElems;\
        type *pElems;\
        } <i>name</i>
 </code></pre>
<table cellspacing=4 cols=4>
<tr valign=top>
<th align=left width=24%>Propvariant Type</th>
<th align=left width=9%>Code</th>
<th align=left width=17%>Propvariant Member</th>
<th align=left width=50%>Value Representation</th>
</tr>
<tr valign=top>
<td width=24%><b>VT_EMPTY</b></td>
<td width=9%>0</td>
<td width=17%>None</td>
<td width=50%>A property with a type indicator of VT_EMPTY has no data associated with it; that is, the size of the value is zero.</td>
</tr>
<tr valign=top>
<td width=24%><b>VT_NULL</b></td>
<td width=9%>1</td>
<td width=17%>None</td>
<td width=50%>This is like a pointer to NULL.</td>
</tr>
<tr valign=top>
<td width=24%><b>VT_UI1</b></td>
<td width=9%>17</td>
<td width=17%><b>bVal</b></td>
<td width=50%>1-byte unsigned integer</td>
</tr>
<tr valign=top>
<td width=24%><b>VT_I2</b></td>
<td width=9%>2</td>
<td width=17%><b>iVal</b></td>
<td width=50%>Two bytes representing a 2-byte signed integer value.</td>
</tr>
<tr valign=top>
<td width=24%><b>VT_UI2</b></td>
<td width=9%>18</td>
<td width=17%><b>uiVal</b></td>
<td width=50%>2-byte unsigned integer</td>
</tr>
<tr valign=top>
<td width=24%><b>VT_I4</b></td>
<td width=9%>3</td>
<td width=17%><b>lVal</b></td>
<td width=50%>4-byte signed integer value</td>
</tr>
<tr valign=top>
<td width=24%><b>VT_UI4</b></td>
<td width=9%>19</td>
<td width=17%><b>ulVal</b></td>
<td width=50%>4-byte unsigned integer</td>
</tr>
<tr valign=top>
<td width=24%><b>VT_I8</b></td>
<td width=9%>20</td>
<td width=17%><b>hVal</b></td>
<td width=50%>8-byte signed integer</td>
</tr>
<tr valign=top>
<td width=24%><b>VT_UI8</b></td>
<td width=9%>21</td>
<td width=17%><b>uhVal</b></td>
<td width=50%>8-byte unsigned integer</td>
</tr>
<tr valign=top>
<td width=24%><b>VT_R4</b></td>
<td width=9%>4</td>
<td width=17%><b>fltVal</b></td>
<td width=50%>32-bit IEEE floating point value</td>
</tr>
<tr valign=top>
<td width=24%><b>VT_R8</b></td>
<td width=9%>5</td>
<td width=17%><b>dblVal</b></td>
<td width=50%>64-bit IEEE floating point value</td>
</tr>
<tr valign=top>
<td width=24%><b>VT_CY</b></td>
<td width=9%>6</td>
<td width=17%><b>cyVal</b></td>
<td width=50%>8-byte two's complement integer (scaled by 10,000). This type is commonly used for currency amounts.</td>
</tr>
<tr valign=top>
<td width=24%><b>VT_DATE</b></td>
<td width=9%>7</td>
<td width=17%><b>date</b></td>
<td width=50%>A 64-bit floating point number representing the number of days (not seconds) since December 31, 1899. For example, January 1, 1900 is 2.0, January 2, 1900 is 3.0, and so on). This is stored in the same representation as VT_R8.</td>
</tr>
<tr valign=top>
<td width=24%><b>VT_BSTR</b></td>
<td width=9%>8</td>
<td width=17%><b>bstrVal</b></td>
<td width=50%>Pointer to a null terminated Unicode string. The string is immediately preceded by a DWORD representing the byte count, but <b>bstrVal</b> points past this DWORD to the first character of the string. BSTRs must be allocated and freed using the OLE Automation SysAllocString and SysFreeString calls.</td>
</tr>
<tr valign=top>
<td width=24%><b>VT_BOOL</b></td>
<td width=9%>11</td>
<td width=17%><b>boolVal</b> (<b>bool</b> in earlier designs)</td>
<td width=50%>Boolean value, a WORD containing 0 (false) or -1 (true).</td>
</tr>
<tr valign=top>
<td width=24%><b>VT_ERROR</b></td>
<td width=9%>10</td>
<td width=17%><b>scode</b></td>
<td width=50%>A DWORD containing a status code.</td>
</tr>
<tr valign=top>
<td width=24%><b>VT_FILETIME</b></td>
<td width=9%>64</td>
<td width=17%><b>filetime</b></td>
<td width=50%>64-bit <b>FILETIME</b> structure as defined by Win32. It is recommended that all times be stored in Universal Coordinate Time (UTC).</td>
</tr>
<tr valign=top>
<td width=24%><b>VT_LPSTR</b></td>
<td width=9%>30</td>
<td width=17%><b>pszVal</b></td>
<td width=50%>Pointer to a null terminated ANSI string in the system default code page.</td>
</tr>
<tr valign=top>
<td width=24%><b>VT_LPWSTR</b></td>
<td width=9%>31</td>
<td width=17%><b>pwszVal</b></td>
<td width=50%>Pointer to a null terminated Unicode string in the user's default locale.</td>
</tr>
<tr valign=top>
<td width=24%><b>VT_CLSID</b></td>
<td width=9%>72</td>
<td width=17%><b>puuid</b></td>
<td width=50%>Pointer to a CLSID (or other GUID).</td>
</tr>
<tr valign=top>
<td width=24%><b>VT_CF</b></td>
<td width=9%>71</td>
<td width=17%><b>pclipdata</b></td>
<td width=50%>Pointer to a CLIPDATA structure, described above.</td>
</tr>
<tr valign=top>
<td width=24%><b>VT_BLOB</b></td>
<td width=9%>65</td>
<td width=17%><b>blob</b></td>
<td width=50%>DWORD count of bytes, followed by that many bytes of data. The byte count does not include the four bytes for the length of the count itself; an empty BLOB would have a count of zero, followed by zero bytes. This is similar to VT_BSTR but does not guarantee a null byte at the end of the data.</td>
</tr>
<tr valign=top>
<td width=24%><b>VT_BLOBOBJECT</b></td>
<td width=9%>70</td>
<td width=17%><b>blob</b></td>
<td width=50%>A BLOB containing a serialized object in the same representation as would appear in a VT_STREAMED_OBJECT. That is, a DWORD byte count (where the byte count does not include the size of itself) which is in the format of a class identifier followed by initialization data for that class.<p>
The only significant difference between VT_BLOB_OBJECT and VT_STREAMED_OBJECT is that the former does not have the system-level storage overhead that the latter would have, and is therefore more suitable for scenarios involving numbers of small objects.</p>
</td>
</tr>
<tr valign=top>
<td width=24%><b>VT_STREAM</b></td>
<td width=9%>66</td>
<td width=17%><b>pStream</b></td>
<td width=50%>Pointer to an IStream interface, representing a stream which is a sibling to the "Contents" stream.</td>
</tr>
<tr valign=top>
<td width=24%><b>VT_STREAMED_<br>
OBJECT</b></td>
<td width=9%>68</td>
<td width=17%><b>pStream</b></td>
<td width=50%>As in VT_STREAM, but indicates that the stream contains a serialized object, which is a CLSID followed by initialization data for the class. The stream is a sibling to the Contents stream that contains the property set.</td>
</tr>
<tr valign=top>
<td width=24%><b>VT_STORAGE</b></td>
<td width=9%>67</td>
<td width=17%><b>pStorage</b></td>
<td width=50%>Pointer to an IStorage interface, representing a storage object that is a sibling to the "Contents" stream.</td>
</tr>
<tr valign=top>
<td width=24%><b>VT_STORED_<br>
OBJECT</b></td>
<td width=9%>69</td>
<td width=17%><b>pStorage</b></td>
<td width=50%>As in VT_STORAGE, but indicates that the designated IStorage contains a loadable object.</td>
</tr>
<tr valign=top>
<td width=24%><b>VT_VECTOR</b></td>
<td width=9%>0x1000</td>
<td width=17%><b>ca</b>*</td>
<td width=50%>If the type indicator is one of the simple propvariant types ORed with this one, the value is one of the counted array values. This is a DWORD count of elements, followed by that many repetitions of the value.<p>
For example, a type indicator of VT_LPSTR|VT_VECTOR has a DWORD element count, a DWORD byte count, the first string data, padding bytes for 32-bit alignment (see below), a DWORD byte count, the second string data, and so on.</p>
<p>
Nonsimple types cannot be ORed with VT_VECTOR. These types are VT_STREAM, VT_STREAM_OBJECT, VT_STORAGE, VT_STORAGE_OBJECT. VT_BLOB and VT_BLOB_OBJECT types also cannot be ORed with VT_VECTOR.</p>
</td>
</tr>
<tr valign=top>
<td width=24%><b>VT_VARIANT</b></td>
<td width=9%>12</td>
<td width=17%><b>capropvar</b></td>
<td width=50%>A DWORD type indicator followed by the corresponding value. VT_VARIANT can be used only with VT_VECTOR.</td>
</tr>
<tr valign=top>
<td width=24%><b>VT_TYPEMASK</b></td>
<td width=9%>0xFFF</td>
<td width=17%></td>
<td width=50%>Used as a mask for VT_VECTOR and other modifiers to extract the raw VT value.</td>
</tr>
</table><br>
<p>
Clipboard format identifiers, stored with the tag VT_CF, use one of five different representations (identified in the <b>ulClipFmt</b> member of the <b>CLIPDATA</b> structure):</p>
<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=27%>ulClipFmt Value</th>
<th align=left width=73%>pClipData value</th>
</tr>
<tr valign=top>
<td width=27%>-1L</td>
<td width=73%>a DWORD containing a built-in Windows clipboard format value.</td>
</tr>
<tr valign=top>
<td width=27%>-2L</td>
<td width=73%>a DWORD containing a Macintosh clipboard format value.</td>
</tr>
<tr valign=top>
<td width=27%>-3L</td>
<td width=73%>a GUID containing a format identifier (rarely used).</td>
</tr>
<tr valign=top>
<td width=27%>any positive value</td>
<td width=73%>a null-terminated string containing a Windows clipboard format name, one suitable for passing to <b>RegisterClipboardFormat</b>. The code page used for characters in the string is per the code page indicator. The "positive value" here is the length of the string, including the null byte at the end.</td>
</tr>
<tr valign=top>
<td width=27%>0L</td>
<td width=73%>no data (rarely used)</td>
</tr>
</table><br>
<p>
Within a vector of values, each repetition of a value is to be aligned to 32-bit boundaries. The exception to this rule is scalar types which are less than 32 bits:  VT_UI1, VT_12, VT_U12, and VT_BOOL. Vectors of these values are packed.</p>
<p>
Therefore, a value with type tag VT_I2 | VT_VECTOR would be a DWORD element count, followed by a sequence of packed 2-byte integers with <i>no</i> padding between them.</p>
<p>
However, a value with type tag VT_LPSTR | VT_VECTOR would be a DWORD element count, followed by a sequence of (DWORD <i>cch</i>, char <i>rgch</i>[]) strings, each of which may be followed by null padding to round to a 32-bit boundary.</p>
<h4>QuickInfo</h4>
<p>
<b>&nbsp;&nbsp;Windows NT: </b>Use version 4.0 or later.<br>
<b>&nbsp;&nbsp;Windows: </b>Use Windows 95 or later. Available as a redistributable for Windows 95.<br>
<b>&nbsp;&nbsp;Windows CE: </b>Unsupported.<br>
<b>&nbsp;&nbsp;Header: </b>Declared in objidl.h.</p>
<p>&nbsp;</p></body>
</HTML>
