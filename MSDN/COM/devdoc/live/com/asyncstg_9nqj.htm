<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>How Asynchronous Binding and Storage Work</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_com_how_asynchronous_binding_and_storage_work"></a>How Asynchronous Binding and Storage Work</h1>
<p>
When a user clicks a link representing a document embedded in a Web page, the following steps occur:
<ol>
<li>
The browser calls the <a href="api2_8hb9.htm"><b>MkParseDisplayName</b></a> function, passing the link's URL.</li>
<li>
<b>MkParseDisplayName</b> parses the URL, creates a corresponding aynchronous moniker, and returns a pointer to the moniker's <a href="if_f2n_8otu.htm"><b>IMoniker</b></a> interface.</li>
<li>
The browser calls <b>IsAsyncMoniker</b> to determine if the moniker is asynchronous, creates a bind context, registers the <b>IBindStatusCallback</b> interface with the bind context (only if the moniker is asynchronous), and calls <a href="if_f2n_7o6s.htm"><b>IMoniker::BindToObject</b></a>, passing the bind context.</li>
<li>
The moniker binds to the object and queries it for the <b>IPersistMoniker</b> interface, which indicates whether the object supports asynchronous binding and storage. If the object returns a pointer to <b>IPersistMoniker</b>:<ol type=A>
<li>
The URL moniker calls <b>IPersistMoniker::Load</b>, passing its own <b>IMoniker</b> pointer to the object.</li>
<li>
The object modifies the bind context, chooses whether it wants a blocking or non-blocking storage, registers its own <b>IBindStatusCallback</b> and calls <a href="if_f2n_1kx1.htm"><b>IMoniker::BindToStorage</b></a> on the pointer it received through <b>IPersistMoniker::Load</b>.</li>
<li>
The moniker creates an asynchronous storage, keeps a reference to the wrapper object's <a href="if_f2n_5xdf.htm"><b>IFillLockBytes</b></a> interface, registers the <b>IProgressNotify</b> interface on the root storage, and calls <a href="if_p2q_34pw.htm"><b>IPersistStorage::Load</b></a>, passing the asynchronous storage's <b>IStorage</b> pointer. As data arrives (on a background thread) the moniker calls <b>IFillLockBytes</b> to fill the <a href="if_f2n_9q9f.htm"><b>ILockBytes</b></a> on the temp file.</li>
<li>
The object reads data from the storage and returns from <b>IPersistMoniker::Load</b> when it has received sufficient data to consider itself initialized. If the object attempts to read data that has not yet been downloaded, the downloader receives a notification on <b>IProgressNotify</b>. Inside the <a href="if_p2q_2roz.htm"><b>IProgressNotify::OnProgress</b></a> method, the downloading thread either blocks in a modal message loop, or causes the asynchronous storage to return E_PENDING, depending on whether the object has requested a blocking or nonblocking storage.</li>
</ol>
</li>
<li>
If the object does not implement <b>IPersistMoniker</b>, the moniker queries for <a href="if_p2q_8crp.htm"><b>IPersistStorage</b></a>, which indicates that the object's persistent state is stored in a storage object. If the object returns a pointer to <b>IPersistStorage</b>:<ol type=A>
<li>
The Moniker calls <b>IMoniker::BindToStorage</b> on itself, requesting a blocking <a href="if_r2z_9b8l.htm"><b>IStorage</b></a> (because the object is not asynchronous-aware), creates an asynchronous storage, keeps a reference to the wrapper object's <b>IFillLockBytes</b> interface, registers the <b>IProgressNotify</b> interface on the root storage, and calls <b>IPersistStorage::Load</b>, passing the asynchronous storage's <b>IStorage</b> pointer. As data arrives (on a background thread) the moniker calls <b>IFillLockBytes</b> to fill the <b>ILockBytes</b> on the temp file.</li>
<li>
The object reads data from storage and returns from <b>IPersistStorage::Load</b> when it has received sufficient data to consider itself initialized. If the object attempts to read data that has not yet been downloaded, it receives a notification on <b>IProgressNotify</b>. Inside the <b>IProgressNotify::OnProgress</b> method, the downloading thread always blocks in a modal message loop.</li>
</ol>
</li>
<li>
Regardless whether the download is synchronous or asynchronous, the moniker returns from <a href="if_f2n_7o6s.htm"><b>IMoniker::BindToObject</b></a>, and the browser receives the initialized object it asked for.</li>
<li>
The browser queries for <a href="if_o_9778.htm"><b>IOleObject</b></a> and hosts the object as a Document Object. (At this point the object may not be initialized completely, but only enough to display something useful, in which case downloading continues in the background.)</li>
</ol>
<p>&nbsp;</p></body>
</HTML>
