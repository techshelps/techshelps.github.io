<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>C and C++ Design Considerations</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_com_c_and_c_design_considerations"></a>C and C++ Design Considerations</h1>
<p>
Component objects contain data specific to the object and one or more interface implementations. The data is private and inaccessible from outside the object, while the interface implementations are public and you can access them through pointers.</p>
<p>
Because interfaces are a binary standard, interface implementation is language independent. However, C++ is the preferred language because it supports many of the object-oriented concepts inherent in OLE. Using a procedural language such as C involves extra work, as summarized below: 
<ul>
<li>
You must explicitly initialize VTBLs either at compile-time or run-time and you should not change them later. Once initialized with function pointers, those pointers should remain unchanged until the application shuts down. VTBLs in C++ are declared as constants to prevent them from being modified inadvertently. However, in C there is no way to ensure that a VTBL will remain unchanged. <p>
To overcome this difference, OLE provides a mechanism that lets C developers declare VTBLs as constants. To do so, place the following statement before the <i>#include</i> statement for the "ole2.h" header file:
<pre><code>#define CONST_VTABLE 
 </code></pre>
</li>
<li>
Each method requires a pointer to the object that owns the method. In C++, all members are implicitly dereferenced off the <i>this</i> pointer. In C, there must be an additional first parameter passed to each method that is a pointer to the interface in which the method is declared.</li>
<li>
Methods in C++ can have identical names because methods are actually known by a name that is the result of concatenating the method name to the class name. Methods in C must have a unique name to designate the object with which they are associated.</li>
</ul>
<p>
For example, the following C++ code sample defines an implementation of <a href="if_r2z_7fvp.htm"><b>IUnknown::QueryInterface</b></a>. The method name is <b>QueryInterface</b> and there are two parameters: a REFIID and a pointer to where to return the requested interface instance.</p>
<pre><code>CUnknown::QueryInterface (REFIID riid, LPVOID * ppvObj); 
 </code></pre>
<p>
A similar C implementation would require a more complex name and an additional first parameter to indicate the object owning the method:</p>
<pre><code>IUnknown_Doc_QueryInterface (LPUNKNOWN pUnk, REFIID riid, 
    LPVOID * ppvObj); 
 </code></pre>
<p>
The following sections demonstrate how to declare a component object in a few typical ways: using C nested data structures, C++ nested classes, and C++ multiple inheritance. The demonstration object, called <i>CObj</i>, derives from <a href="if_r2z_9dwu.htm"><b>IUnknown</b></a> and supports two interfaces that also derive from <b>IUnknown</b>, <b>InterfaceA</b> and <b>InterfaceB</b>. <i>CObj's</i> private data includes a pointer to another component object in the application (<i>m_pCDoc</i>), a count of all the external references to the object (<i>m_ObjRefCount</i>), and pointers to two interfaces implemented by other component objects and used by <i>CObj (m_pOleObj </i>and<i> m_pStg)</i>. All object members use the <i>m_</i> prefix to make it easy to distinguish between member variables and other variables.</p>
<p>&nbsp;</p></body>
</HTML>
