<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CoGetStandardMarshal</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_com_cogetstandardmarshal"></a>CoGetStandardMarshal</h1>
<p>
Creates a default, or standard, marshaling object in either the client process or the server process, depending on the caller, and returns a pointer to that object's <b>IMarshal</b> implementation.</p>
<pre><code><b>STDAPI CoGetStandardMarshal(
  REFIID</b><i> riid</i><b>,          </b>//Reference to the identifier of the 
                        // interface
<b>  IUnknown *</b><i> pUnk</i><b>,      </b>//Pointer to the interface to be marshaled
<b>  DWORD</b><i> dwDestContext</i><b>,  </b>//Destination process
<b>  LPVOID</b><i> pvDestContext</i><b>, </b>//Reserved for future use
<b>  DWORD</b><i> mshlflags</i><b>,      </b>//Reason for marshaling
<b>  LPMARSHAL *</b><i> ppMarshal </i>//Address of output variable that receives 
                        // the IMarshal interface pointer for the 
                        // standard marshaler
<b>);</b>
 </code></pre>
<h4>Parameters</h4>
<dl>
<dt>
<i>riid</i></dt>
<dd>
[in] Reference to the identifier of the interface whose pointer is to be marshaled. This interface must be derived from the <a href="if_r2z_9dwu.htm"><b>IUnknown</b></a> interface.</dd>
<dt>
<i>pUnk</i></dt>
<dd>
[in] Pointer to the interface to be marshaled.</dd>
<dt>
<i>dwDestContext</i></dt>
<dd>
[in] Destination context where the specified interface is to be unmarshaled. Values for <i>dwDestContext</i> come from the enumeration <a href="enums_6mpk.htm"><b>MSHCTX</b></a>. Currently, unmarshaling can occur either in another apartment of the current process (MSHCTX_INPROC) or in another process on the same computer as the current process (MSHCTX_LOCAL).</dd>
<dt>
<i>pvDestContext</i></dt>
<dd>
[in] Reserved for future use; must be NULL.</dd>
<dt>
<i>mshlflags</i></dt>
<dd>
[in] Flag indicating whether the data to be marshaled is to be transmitted back to the client process—the normal case—or written to a global table, where it can be retrieved by multiple clients. Valid values come from the <a href="enums_5bg3.htm"><b>MSHLFLAGS</b></a> enumeration.</dd>
<dt>
<i>ppMarshal</i></dt>
<dd>
[out] Address of <b>IMarshal*</b> pointer variable that receives the interface pointer to the standard marshaler.
</dd>
</dl>
<h4>Return Values</h4>
<p>
This function supports the standard return values E_FAIL, E_OUTOFMEMORY and E_UNEXPECTED, as well as the following:
<dl>
<dt>
S_OK</dt>
<dd>
The <a href="if_f2n_6sh8.htm"><b>IMarshal</b></a> instance was returned successfully.</dd>
<dt>
CO_E_NOTINITIALIZED</dt>
<dd>
The <a href="api1_36qt.htm"><b>CoInitialize</b></a> or <a href="api3_6med.htm"><b>OleInitialize</b></a> function was not called on the current thread before this function was called.
</dd>
</dl>
<h4>Remarks</h4>
<p>
The <b>CoGetStandardMarshal</b> function creates a default, or standard, marshaling object in either the client process or the server process, as may be necessary, and returns that object's <b>IMarshal</b> pointer to the caller. If you implement <b>IMarshal</b>, you may want your implementation to call <b>CoGetStandardMarshal</b> as a way of delegating to COM's default implementation any destination contexts that you don't fully understand or want to handle. Otherwise, you can ignore this function, which COM calls as part of its internal marshaling procedures.</p>
<p>
When the COM library in the client process receives a marshaled interface pointer, it looks for a CLSID to be used in creating a proxy for the purposes of unmarshaling the packet. If the packet does not contain a CLSID for the proxy, COM calls <b>CoGetStandardMarshal,</b> passing a NULL <i>pUnk </i>value. This function creates a standard proxy in the client process and returns a pointer to that proxy's implementation of <b>IMarshal</b>. COM uses this pointer to call <a href="api1_6gbp.htm"><b>CoUnmarshalInterface</b></a> to retrieve the pointer to the requested interface.</p>
<p>
If your OLE server application's implementation of <a href="if_f2n_6sh8.htm"><b>IMarshal</b></a> calls <b>CoGetStandardMarshal</b>, you should pass both the IID of (<i>riid</i>), and a pointer to (<i>pUnk</i>), the interface being requested.</p>
<p>
This function performs the following tasks:
<ol>
<li>
Determines whether <i>pUnk</i> is NULL.</li>
<li>
If <i>pUnk</i> is NULL, creates a standard interface proxy in the client process for the specified <i>riid</i> and returns the proxy's <b>IMarshal</b> pointer<i>.</i></li>
<li>
If <i>pUnk</i> is not NULL, checks to see if a marshaler for the object already exists, creates a new one if necessary, and returns the marshaler's <b>IMarshal</b> pointer.</li>
</ol>
<h4>QuickInfo</h4>
<p>
<b>&nbsp;&nbsp;Windows NT: </b>Use version 3.1 or later.<br>
<b>&nbsp;&nbsp;Windows: </b>Use Windows 95 or later.<br>
<b>&nbsp;&nbsp;Windows CE: </b>Unsupported.<br>
<b>&nbsp;&nbsp;Header: </b>Declared in objbase.h.<br>
<b>&nbsp;&nbsp;Import Library: </b>Included as a resource in ole32.dll.</p>
<h4>See Also</h4>
<p>
<a href="if_f2n_6sh8.htm"><b>IMarshal</b></a> </p>
<p>
</p>
<p>
</p>
<p>&nbsp;</p></body>
</HTML>
