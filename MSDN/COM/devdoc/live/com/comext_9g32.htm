<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Call Synchronization</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_com_call_synchronization"></a>Call Synchronization</h1>
<p>
COM applications must be able to deal correctly with user input while processing one or more calls from COM or the operating system. COM provides call synchronization for single-threaded apartments only. Multi-threaded apartments (containing free-threaded threads) do not receive calls while making calls (on the same thread). Multi-threaded apartments cannot make input synchronized calls. Asynchronous calls are converted to synchronous calls in multi-threaded apartments. The message filter is not called for any thread in a multi-threaded apartment. For more information on threading issues, see <a href="com_98mr.htm"><b>Processes and Threads</b></a>.</p>
<p>
COM calls between processes fall into three categories:
<ul>
<li>
Synchronous calls</li>
<li>
Asynchronous notifications</li>
<li>
Input-synchronized calls</li>
</ul>
<p>
Most of the communication that takes place within COM is synchronous. When making <i>synchronous</i> <i>calls, </i>the caller waits for the reply before continuing and can receive incoming messages while waiting. COM enters a modal loop to wait for the reply, receiving and dispatching other messages in a controlled manner.</p>
<p>
When sending<i> asynchronous notifications, </i>the caller does not wait for the reply. COM uses <b>PostMessage</b> or high-level events to send asynchronous notifications, depending on the platform. COM defines five asynchronous methods:
<ul>
<li>
<a href="if_a2e_2tgl.htm"><b>IAdviseSink::OnDataChange</b></a> </li>
<li>
<a href="if_a2e_1bj9.htm"><b>IAdviseSink::OnViewChange</b></a> </li>
<li>
<a href="if_a2e_73fp.htm"><b>IAdviseSink::OnRename</b></a> </li>
<li>
<a href="if_a2e_7s6d.htm"><b>IAdviseSink::OnSave</b></a> </li>
<li>
<a href="if_a2e_5sth.htm"><b>IAdviseSink::OnClose</b></a> </li>
</ul>
<p>
While COM is processing an asynchronous call, synchronous calls cannot be made. For example, a container application's implementation of <b>IAdviseSink::OnDataChange</b> cannot contain a call to <a href="if_p2q_19et.htm"><b>IPersistStorage::Save</b></a>. These calls are the only asynchronous calls supported by COM. There is no way to create a custom interface which is asynchronous at this time.</p>
<p>
When making<i> input-synchronized calls, </i>the object called must complete the call before yielding control. This ensures that focus management works correctly and that data entered by the user is processed appropriately. These calls<i> </i>are made by COM through the Windows <b>SendMessage </b>function, without entering a modal loop. While processing an input-synchronized call, the object called must not call any function or method (including synchronous methods) that might yield control.</p>
<p>
The following methods are input synchronized:
<ul>
<li>
<a href="if_o_33qv.htm"><b>IOleWindow::GetWindow</b></a> </li>
<li>
<a href="if_o_99et.htm"><b>IOleInPlaceActiveObject::OnFrameWindowActivate</b></a> </li>
<li>
<a href="if_o_4fs5.htm"><b>IOleInPlaceActiveObject::OnDocWindowActivate</b></a> </li>
<li>
<a href="if_o_7ovm.htm"><b>IOleInPlaceActiveObject::ResizeBorder</b></a> </li>
<li>
<a href="if_o_84he.htm"><b>IOleInPlaceUIWindow::GetBorder</b></a> </li>
<li>
<a href="if_o_9zc5.htm"><b>IOleInPlaceUIWindow::RequestBorderSpace</b></a> </li>
<li>
<a href="if_o_7ep1.htm"><b>IOleInPlaceUIWindow::SetBorderSpace</b></a> </li>
<li>
<a href="if_o_6o6t.htm"><b>IOleInPlaceFrame::SetMenu</b></a> </li>
<li>
<a href="if_o_02us.htm"><b>IOleInPlaceFrame::SetStatusText</b></a> </li>
<li>
<a href="if_o_4sc3.htm"><b>IOleInPlaceObject::SetObjectRects</b></a> </li>
</ul>
<p>
To minimize problems that can arise from asynchronous message processing, the majority of COM method calls are synchronous. With synchronous communication, there is no need for special code to dispatch and handle incoming messages. When an application makes a synchronous method call, COM enters a modal wait loop that handles the required replies and dispatches incoming messages to applications capable of processing them.</p>
<p>
COM manages method calls by assigning an identifier called a <i>logical thread ID</i>. A new one is assigned when a user selects a menu command or when the application initiates a new COM operation. Subsequent calls that relate to the initial COM call are assigned the same logical thread ID as the initial call.</p>
<p>
</p>
<p>
</p>
<p>&nbsp;</p></body>
</HTML>
