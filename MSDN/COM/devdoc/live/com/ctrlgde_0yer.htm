<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Persistence Interfaces</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h2><a name="_com_persistence_interfaces"></a>Persistence Interfaces</h2>
<p>
Objects that have a persistent state of any kind must implement at least one <b>IPersist</b>*<i> </i>interface, and preferably multiple interfaces, in order to provide the container with the most flexible choice of how it wishes to save a control's state.</p>
<p>
If a control has any persistent state whatsoever, it must, as a minimum, implement either <b>IPersistStream</b> or <b>IPersistStreamInit</b> (the two are mutually exclusive and shouldn't be implemented together for the most part). The latter is used when a control wishes to know when it is created new as opposed to reloaded from an existing persistent state (<b>IPersistStream</b> does not have the created new capability). The existence of either interface indicates that the control can save and load its persistent state into a stream, that is, an instance of <b>IStream</b>.</p>
<p>
Beyond these two stream-based interfaces, the <b>IPersist</b>* interfaces listed in the following table can be optionally provided in order to support persistence to locations other than an expandable <b>IStream</b>.</p>
<p>
A set of component categories is identified to cover the support for persistency interfaces see the <a href="ctrlgde_5twz.htm">Component Categories</a> section of this appendix.</p>
<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=31%>Interface</th>
<th align=left width=69%>Usage</th>
</tr>
<tr valign=top>
<td width=31%><b>IPersistMemory</b></td>
<td width=69%>The object can save and load its state into a fixed-length sequential byte array (in memory).</td>
</tr>
<tr valign=top>
<td width=31%><b>IPersistStorage</b></td>
<td width=69%>The object can save and load its state into an <b>IStorage</b> instance. Controls that wish to be marked <b>Insertable</b> as other compound document objects (for insertion into non-control aware containers) must support this interface.</td>
</tr>
<tr valign=top>
<td width=31%><b>IPersistPropertyBag</b></td>
<td width=69%>The object can save and load its state as individual properties written to <b>IPropertyBag</b> which the container implements. This is used for Save As Text functionality in some containers.</td>
</tr>
<tr valign=top>
<td width=31%><b>IPersistMoniker</b></td>
<td width=69%>The object can save and load its state to a location named by a moniker. The control calls <b>IMoniker::BindToStorage</b> to retrieve the storage interface it requires, such as <b>IStorage</b>, <b>IStream</b>, <b>ILockBytes</b>, <b>IDataObject</b>, etc.</td>
</tr>
</table><br>
<p>
While support for <b>IPersistPropertyBag</b> is optional, it is strongly recommended as an optimization for containers with Save As Text features, such as Visual Basic.</p>
<p>
With the exception of <b>IPersistStream[Init]::GetSizeMax</b> and <b>IPersistMemory::GetSizeMax</b>, all methods of each interface must be fully implemented.</p>
<p>&nbsp;</p></body>
</HTML>
