<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>IStream - Compound File Implementation</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_com_istream_compound_file_implementation"></a>IStream - Compound File Implementation</h1>
<p>
The <b>IStream</b> interface supports reading and writing data to stream objects. Stream objects contain the data in a structured storage object, where storages provide the structure. Simple data can be written directly to a stream, but most frequently, streams are elements nested within a storage object. They are similar to standard files.</p>
<p>
The specification of <b>IStream</b> defines more functionality that the COM implementation supports. For example, the <b>IStream</b> interface defines streams up to 2<sup>64</sup> bytes in length requiring a 64-bit seek pointer. However, the COM implementation only supports streams up to 2<sup>32</sup> bytes in length (4 gigabytes) and read and write operations are always limited to 2<sup>32</sup> bytes at a time. The COM implementation also does not support stream transactioning or region locking.</p>
<p>
When you want to create a simple stream based on global memory, you can get an <b>IStream</b> pointer by calling the API function <a href="api2_63sc.htm"><b>CreateStreamOnHGlobal</b></a>. To get an <b>IStream</b> pointer within a compound file object, call either <a href="api4_8hd1.htm"><b>StgCreateDocfile</b></a> or <a href="api4_0hb9.htm"><b>StgOpenStorage</b></a>. These functions retrieve an <b>IStorage</b> pointer, with which you can then call <a href="if_r2z_9wz1.htm"><b>CreateStream</b></a><b>/<a href="if_r2z_7x65.htm">OpenStream</a></b> for an <b>IStream</b> pointer. In either case, the same <b>IStream</b> implementation code is used.</p>
<p>
<b>Note</b>&nbsp;&nbsp;The compound file implementation of structured storage does not succeed on a <b>QueryInterface</b> for <b>ISequentialStream</b> but it includes the <b>Read</b> and <b>Write</b> methods through the <b>IStream</b> interface pointer. The same is true for the NTFS Native Structured Storage implementation.</p>
<h5>When to Use</h5>
<p>
Call the methods of <b>IStream</b> to read and write data to a stream.</p>
<p>
Since stream objects can be marshaled to other processes, applications can share the data in storage objects without having to use global memory. In the COM compound file implementation of stream objects, the custom marshaling facilities in COM create a remote version of the original object in the new process when the two processes have shared memory access. Thus, the remote version does not need to communicate with the original process to carry out its functions.</p>
<p>
The remote version of the stream object shares the same seek pointer as the original stream. If you do not want to share the seek pointer, you should use the <a href="if_r2z_6ov9.htm"><b>IStream::Clone</b></a> method to provide a copy of the stream object for the remote process.</p>
<p>
<b>Note</b>&nbsp;&nbsp;If you are creating a stream object that is larger than the heap in your machine's memory and you are using an HGLOBAL, the stream object calls <b>GlobalRealloc</b> internally whenever it needs more memory. Because <b>GlobalRealloc</b> always copies data from the source to the destination, increasing a stream object from 20M to 25M, for example, consumes immense amounts of time. This is due to the size of the increments copied and is worsened if there is less than 45M of memory on the machine because of disk swapping.</p>
<p>
The preferred solution is to implement an <b>IStream</b> that uses memory allocated by <b>VirtualAlloc</b> instead of <b>GlobalAlloc</b>. This can reserve a large chunk of virtual address space and then commit memory within that address space as required. No data copying occurs and memory is committed only as it is needed.</p>
<p>
Another alternative is to call the <a href="if_r2z_3ysl.htm"><b>IStream::SetSize</b></a> method on the stream object to increase the memory allocation in advance. This is not, however, as efficient as using <b>VirtualAlloc</b> as described above.</p>
<h4>Remarks</h4>
<dl>
<dt>
<a href="if_r2z_14mc.htm"><b>ISequentialStream::Read</b></a> </dt>
<dd>
Reads a specified number of bytes from the stream object into memory starting at the current seek pointer. This implementation returns S_OK if the end of the stream was reached during the read. (This is the same as the "end of file" behavior found in the MS-DOS FAT file system.</dd>
<dt>
<a href="if_r2z_3yat.htm"><b>ISequentialStream::Write</b></a> </dt>
<dd>
Writes a specified number from bytes into the stream object starting at the current seek pointer. In this implementation, stream objects are not sparse. Any fill bytes are eventually allocated on the disk and assigned to the stream.</dd>
<dt>
<a href="if_r2z_55m3.htm"><b>IStream::Seek</b></a> </dt>
<dd>
Changes the seek pointer to a new location relative to the beginning of the stream, to the end of the stream, or to the current seek pointer.</dd>
<dt>
<a href="if_r2z_3ysl.htm"><b>IStream::SetSize</b></a> </dt>
<dd>
Changes the size of the stream object. In this implementation, there is no guarantee that the space allocated will be contiguous</dd>
<dt>
<a href="if_r2z_3lkf.htm"><b>IStream::CopyTo</b></a> </dt>
<dd>
Copies a specified number of bytes from the current seek pointer in the stream to the current seek pointer in another stream.</dd>
<dt>
<a href="if_r2z_5oac.htm"><b>IStream::Commit</b></a> </dt>
<dd>
The compound file implementation of IStream supports opening streams only in direct mode, not transacted mode. Therefore, the method has no effect when called other than to flush all memory buffers to the next storage level.
<p>
In this implementation, it does not matter if you commit changes to streams, you need only commit changes for storage objects.
</dd>
<dt>
<a href="if_r2z_9th0.htm"><b>IStream::Revert</b></a> </dt>
<dd>
This implementation does not support transacted streams, so a call to this method has no effect.</dd>
<dt>
<a href="if_r2z_1jji.htm"><b>IStream::LockRegion</b></a> </dt>
<dd>
Range-locking is not supported by this implementation, so a call to this method has no effect.</dd>
<dt>
<a href="if_r2z_1f72.htm"><b>IStream::UnlockRegion</b></a> </dt>
<dd>
Removes the access restriction on a range of bytes previously restricted with <a href="if_r2z_1jji.htm"><b>IStream::LockRegion</b></a>.</dd>
<dt>
<a href="if_r2z_6gtw.htm"><b>IStream::Stat</b></a> </dt>
<dd>
Retrieves the <a href="structs_7x7r.htm"><b>STATSTG</b></a> structure for this stream</dd>
<dt>
<a href="if_r2z_6ov9.htm"><b>IStream::Clone</b></a> </dt>
<dd>
Creates a new stream object with its own seek pointer that references the same bytes as the original stream.</dd>
</dl>
<h4>See Also</h4>
<p>
<a href="if_r2z_4x7x.htm"><b>IStream</b></a>, <a href="if_r2z_9b8l.htm"><b>IStorage</b></a>, <a href="api2_63sc.htm"><b>CreateStreamOnHGlobal</b></a>, <a href="api4_8hd1.htm"><b>StgCreateDocfile</b></a>, <a href="api4_0hb9.htm"><b>StgOpenStorage</b></a> </p>
<p>
</p>
<p>
</p>
<p>&nbsp;</p></body>
</HTML>
