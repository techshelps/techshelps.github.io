<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>URLOpenStream</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_com_urlopenstream"></a>URLOpenStream</h1>
<p>
Creates a push-type stream object from a URL. The data is downloaded from the Internet as fast as possible. Every time data is available, it is "pushed" at the client through a notification callback.</p>
<pre><code><b>HRESULT URLOpenStream(
  LPUNKNOWN</b><i> pCaller</i><b>,  </b>// Caller's controlling <a href="if_r2z_9dwu.htm">IUnknown</a> 
<b>  PCWSTR</b><i> szURL</i><b>,       </b>// URL to be converted to stream
<b>  DWORD</b><i> dwResv</i><b>,       </b>// Reserved for future use
<b>  LPBINDSTATUSCALLBACK</b><i> lpfnCB</i>
<i>                      </i>// Caller's <a href="if_a2e_0vxn.htm">IBindStatusCallback</a> 
<b>);</b>
 </code></pre>
<h4>Parameters</h4>
<dl>
<dt>
<i>pCaller</i></dt>
<dd>
[in] Pointer to the caller's controlling <b>IUnknown</b>. If the caller is not an ActiveX component, this value may be set to NULL.</dd>
<dt>
<i>szURL</i></dt>
<dd>
[in] Pointer to the URL to be converted to a stream object. Cannot be NULL.</dd>
<dt>
<i>dwResv</i></dt>
<dd>
[in] Reserved for future use; must be zero.</dd>
<dt>
<i>lpfnCB</i></dt>
<dd>
[in] Pointer to caller's <b>IBindStatusCallback</b> interface.</dd>
</dl>
<h4>Return Values</h4>
<p>
This function returns the same values as <b>IBindHost::MonikerBindToStorage</b>.</p>
<h4>Remarks</h4>
<p>
If <i>pCaller</i> is non-NULL, the caller is a COM object that is contained in another component, such as an ActiveX Control in the context of an HTML page.In this case, the function attempts the download in the context of the ActiveX client framework and allows the caller's container to receive callbacks on the progress of the download.</p>
<p>
<b>URLOpenStream</b> calls <a href="if_a2e_0x2d.htm"><b>IBindStatusCallback::OnDataAvailable</b></a> every time data arrives from the Internet. <b>OnDataAvailable</b> can return E_ABORT to abort the download. When the callback is invoked and the <i>pstm</i> member of the STGMEDIUM structure is not NULL, the caller can read from the stream the amount of data specified in the <i>dwSize</i> argument passed with the <b>OnDataAvailable</b> call. If the caller does not read the full amount or does not call <a href="if_r2z_14mc.htm"><b>ISequentialStream::Read</b></a> at all, <b>OnDataAvailable</b> is still called the next time data arrives, as long the grfBSCF flags do not indicate BINDF_LASTDATANOTIFICATION. In that case, no more data is downloaded. Any data that is not read at any given time is still available the next time <b>OnDataAvailable</b> is called.</p>
<p>
The logic in the following code fragment is a typical implementation of <b>OnDataAvailable</b> as it is used by the <b>URLOpenStream</b> function: </p>
<pre><code>HRESULT MyBindStatusCallback::OnDataAvailable(DWORD grfBSCF, DWORD dwSize, ..., STGMEDIUM * pstgmed)
{
    if(dwSize &lt; sizeof(BITMAPINFOHEADER))
        return(NOERROR);  // not enough has been read yet, just return
    if(!g_bGotInfoHeader) // did we get info before?
    {
       // No, go ahead, read now...
        DWORD dwRead;
        HRESULT hr = pstgmed-&gt;pstm-&gt;Read( &amp;bmih, sizeof(bmih), &amp;dwRead);
        if( SUCCEEDED(hr) )
        {
            // now we got it... we can return
            g_bGotInfoHeader = TRUE;
            return(hr);
        }
    }
}
 </code></pre>
<h4>QuickInfo</h4>
<p>
<b>&nbsp;&nbsp;Windows NT: </b>Use version 5.0 or later.<br>
<b>&nbsp;&nbsp;Windows: </b>Unsupported.<br>
<b>&nbsp;&nbsp;Windows CE: </b>Unsupported.<br>
<b>&nbsp;&nbsp;Header: </b>Declared in urlmon.h.</p>
<h4>See Also</h4>
<p>
<a href="if_a2e_0vxn.htm"><b>IBindStatusCallback</b></a>, <a href="if_a2e_0x2d.htm"><b>IBindStatusCallback::OnDataAvailable</b></a>, <a href="if_r2z_4x7x.htm"><b>IStream</b></a>, <a href="if_r2z_1k19.htm"><b>ISequentialStream</b></a>, <a href="if_r2z_14mc.htm"><b>ISequentialStream::Read</b></a> </p>
<p>
</p>
<p>
</p>
<p>&nbsp;</p></body>
</HTML>
