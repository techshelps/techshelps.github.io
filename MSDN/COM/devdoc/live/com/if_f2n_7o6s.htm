<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>IMoniker::BindToObject</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h2><a name="_com_imoniker_bindtoobject"></a>IMoniker::BindToObject</h2>
<p>
Uses the moniker to bind to the object it identifies. The binding process involves finding the object, putting it into the running state if necessary, and supplying the caller with a pointer to a specified interface on the identified object.</p>
<pre><code><b>HRESULT BindToObject(
  IBindCtx</b><i> *pbc</i><b>,        </b>//Pointer to bind context object to be used
<b>  IMoniker</b><i> *pmkToLeft</i><b>,  </b>//Pointer to moniker that precedes this one 
                        //in the composite
<b>  REFIID</b><i> riidResult</i><b>,    </b>//IID of interface pointer requested
<b>  void</b><i> **ppvResult      </i>//Address of output variable that receives 
                        //the interface pointer requested in <i>riidResult</i>
<b>);</b>
 </code></pre>
<h4>Parameters</h4>
<dl>
<dt>
<i>pbc</i></dt>
<dd>
[in] Pointer to the <a href="if_a2e_06bc.htm"><b>IBindCtx</b></a><b> </b>interface on the bind context object, which is used in this binding operation. The bind context caches objects bound during the binding process, contains parameters that apply to all operations using the bind context, and provides the means by which the moniker implementation should retrieve information about its environment.</dd>
<dt>
<i>pmkToLeft</i></dt>
<dd>
[in] If the moniker is part of a composite moniker, pointer to the moniker to the left of this moniker. This parameter is primarily used by moniker implementers to enable cooperation between the various components of a composite moniker. Moniker clients should pass NULL.</dd>
<dt>
<i>riidResult</i></dt>
<dd>
[in] IID of the interface the client wishes to use to communicate with the object that the moniker identifies.</dd>
<dt>
<i>ppvResult</i></dt>
<dd>
[out] Address of pointer variable that receives the interface pointer requested in <i>riid</i>. Upon successful return, *<i>ppvResult</i> contains the requested interface pointer to the object the moniker identifies. When successful, the implementation must call <a href="if_r2z_3rja.htm"><b>IUnknown::AddRef</b></a> on the moniker. It is the caller's responsibility to release the object with a call to <a href="if_r2z_59np.htm"><b>IUnknown::Release</b></a>. If an error occurs, *<i>ppvResult</i> should be NULL.
</dd>
</dl>
<h4>Return Values</h4>
<p>
The method supports the standard return values E_UNEXPECTED and E_OUTOFMEMORY, as well as the following: 
<dl>
<dt>
S_OK</dt>
<dd>
The binding operation was successful.</dd>
<dt>
MK_E_NOOBJECT</dt>
<dd>
The object identified by this moniker, or some object identified by the composite moniker of which this moniker is a part, could not be found.</dd>
<dt>
MK_E_EXCEEDEDDEADLINE</dt>
<dd>
The binding operation could not be completed within the time limit specified by the bind context's <a href="structs_2b1v.htm"><b>BIND_OPTS</b></a> structure. </dd>
<dt>
MK_E_CONNECTMANUALLY</dt>
<dd>
The binding operation requires assistance from the end user. The most common reasons for returning this value are that a password is needed or that a floppy needs to be mounted. When this value is returned, retrieve the moniker that caused the error with a call to <a href="if_a2e_9o6l.htm"><b>IBindCtx::GetObjectParam</b></a> with the key "ConnectManually". You can then call <b>IMoniker::GetDisplayName</b> to get the display name, display a dialog box that communicates the desired information, such as instructions to mount a floppy or a request for a password, and then retry the binding operation.</dd>
<dt>
MK_E_INTERMEDIATEINTERFACENOTSUPPORTED</dt>
<dd>
An intermediate object was found but it did not support an interface required to complete the binding operation. For example, an item moniker returns this value if its container does not support the <b>IOleItemContainer</b> interface.</dd>
<dt>
STG_E_ACCESSDENIED</dt>
<dd>
Unable to access the storage object.</dd>
<dt>
<a href="if_o_9gz8.htm"><b>IOleItemContainer::GetObject</b></a> errors</dt>
<dd>
If the moniker used to bind to an object contains an item moniker, errors associated with this method can be returned.
</dd>
</dl>
<h4>Remarks</h4>
<p>
<b>IMoniker::BindToObject</b> implements the primary function of a moniker, which is to locate the object identified by the moniker and return a pointer to one of its interfaces. </p>
<h5>Notes to Callers</h5>
<p>
If you are using a moniker as a persistent connection between two objects, you activate the connection by calling <b>IMoniker::BindToObject</b>. </p>
<p>
You typically call <b>IMoniker::BindToObject</b> during the following process:
<ol>
<li>
Create a bind context object with a call to the <a href="api2_0ad4.htm"><b>CreateBindCtx</b></a> function.</li>
<li>
Call <b>IMoniker::BindToObject</b> using the moniker, retrieving a pointer to a desired interface on the identified object. </li>
<li>
Release the bind context.</li>
<li>
Through the acquired interface pointer, perform the desired operations on the object. </li>
<li>
When finished with the object, release the object's interface pointer. </li>
</ol>
<p>
The following code fragment illustrates these steps:</p>
<pre><code>// pMnk is an IMoniker * that points to a previously acquired moniker 
// ICellRange is a custom interface designed for an object that is a 
//            range of spreadsheet cells 
ICellRange *pCellRange; 
IBindCtx *pbc; 
 
CreateBindCtx( 0, &amp;pbc ); 
pMnk-&gt;BindToObject( pbc, NULL, IID_ICellRange, &amp;pCellRange ); 
pbc-&gt;Release(); 
// pCellRange now points to the object; safe to use pCellRange 
pCellRange-&gt;Release(); 
 </code></pre>
<p>
You can also use the <a href="api1_469e.htm"><b>BindMoniker</b></a> function when you only intend one binding operation and don't need to retain the bind context object. This helper function encapsulates the creation of the bind context, calling <b>IMoniker::BindToObject</b>, and releasing the bind context.</p>
<p>
COM containers that support links to objects use monikers to locate and get access to the linked object, but typically do not call <b>IMoniker::BindToObject</b> directly. Instead, when a user activates a link in a container, the link container usually calls <b>IOleObject::DoVerb</b>, using the link handler's implementation, which calls <b>IMoniker::BindToObject</b> on the moniker stored in the linked object (if it cannot handle the verb). </p>
<h5>Notes to Implementers</h5>
<p>
What your implementation does depends on whether you expect your moniker to have a prefix, that is, whether you expect the <i>pmkToLeft</i> parameter to be NULL or not. For example, an item moniker, which identifies an object within a container, expects that <i>pmkToLeft</i> identifies the container. An item moniker consequently uses <i>pmkToLeft</i> to request services from that container. If you expect your moniker to have a prefix, you should use the <i>pmkToLeft</i> parameter (for instance, calling <b>IMoniker::BindToObject</b> on it) to request services from the object it identifies. </p>
<p>
If you expect your moniker to have no prefix, your <b>IMoniker::BindToObject</b> implementation should first check the Running Object Table (ROT) to see if the object is already running. To acquire a pointer to the ROT, your implementation should call <a href="if_a2e_70bp.htm"><b>IBindCtx::GetRunningObjectTable</b></a> on the <i>pbc</i> parameter. You can then call the <a href="if_r2z_1c1g.htm"><b>IRunningObjectTable::GetObject</b></a> method to see if the current moniker has been registered in the ROT. If so, you can immediately call <a href="if_r2z_7fvp.htm"><b>IUnknown::QueryInterface</b></a> to get a pointer to the interface requested by the caller. </p>
<p>
When your <b>IMoniker::BindToObject</b> implementation binds to some object, it should use the <i>pbc</i> parameter to call <a href="if_a2e_31es.htm"><b>IBindCtx::RegisterObjectBound</b></a> to store a reference to the bound object in the bind context. This ensures that the bound object remains running until the bind context is released, which can avoid the expense of having a subsequent binding operation load it again later. </p>
<p>
If the bind context's <a href="structs_2b1v.htm"><b>BIND_OPTS</b></a> structure specifies the <b>BINDFLAGS_JUSTTESTEXISTENCE</b> flag, your implementation has the option of returning NULL in <i>ppvResult</i> (although you can also ignore the flag and perform the complete binding operation).</p>
<h4>QuickInfo</h4>
<p>
<b>&nbsp;&nbsp;Windows NT: </b>Use version 3.1 or later.<br>
<b>&nbsp;&nbsp;Windows: </b>Use Windows 95 or later.<br>
<b>&nbsp;&nbsp;Windows CE: </b>Unsupported.<br>
<b>&nbsp;&nbsp;Header: </b>Declared in objidl.h.</p>
<h4>See Also</h4>
<p>
<a href="api1_469e.htm"><b>BindMoniker</b></a>, <a href="if_f2n_1kx1.htm"><b>IMoniker::BindToStorage</b></a> </p>
<p>
</p>
<p>
</p>
<p>&nbsp;</p></body>
</HTML>
