<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Upgrading Applications</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_ole_upgrading_applications"></a>Upgrading Applications</h1>
<p>
When an OLE 1 server is upgraded to an OLE 2 object application, several issues arise. A primary issue is whether the OLE 2 application will replace the OLE 1 application or both versions will coexist. If only the newer version will be available to the user, it is best to convert objects from the older version of the application automatically to the new version format. Objects can be converted on a global basis, where all objects of a specific class are converted, or on a more selective basis, where only some objects are converted. Conversion can be either automatic, under programmatic control, or under the control of a user.</p>
<p>
The ability to detect whether an object is from an OLE 1 server is helpful for implementing conversion functionality. The OLE 2 implementation of the <a href="if_p2q_34pw.htm"><b>IPersistStorage::Load</b></a> method can<b> </b>check for a stream named "\1Ole10Native." The "\1Ole10Native" stream contains a DWORD header whose value is the length of the native data that follows. The existence of this stream indicates that the data is coming from an OLE 1 server. Applications can check whether a storage object contains an object in an OLE 1 format by calling the <a href="api3_1tuv.htm"><b>ReadFmtUserTypeStg</b></a> method and examining the contents of <i>pcfFormat. </i>This is where the OLE 1 class name would appear.</p>
<p>
In the <a href="if_p2q_19et.htm"><b>IPersistStorage::Save</b></a> method, objects that are being permanently converted should be written back to storage in the new format and the "\1Ole10Native" stream should be deleted. The conversion bit in the storage should also be cleared once the conversion to the new format is complete.</p>
<p>
To allow manual conversion of an old OLE 1 object to the new OLE 2 version, the OLE 2 object application must put the OLE 1 server's ProgID (OLE 1 server class name) into the registry under the <b>CLSID\{...}\Conversion\Readable\Main</b> entry. This entry indicates that the OLE 2 application can read its OLE 1 data format; the 'Clipboard format' of the OLE 1 data is the ProgID (that is, the class name) of the OLE 1 object.</p>
<p>
To get a CLSID for an OLE 1 server, the <b>CLSIDFromProgId</b> function or the <a href="api1_3b3b.htm"><b>CLSIDFromString</b></a> function must be called. That is, an OLE 1 application cannot be assigned a CLSID from an OLE 2 application with <b>uuidgen.exe</b>, <a href="api1_05r8.htm"><b>CoCreateGuid</b></a>, or by using a GUID from a range assigned by Microsoft. Because all OLE 1 CLSIDs are expected to fall in a specific range, OLE 1 CLSIDs are assigned with the <b>CLSIDFromProgId</b> function.</p>
<p>
Refer to the appendix called "Registering Object Applications" for detailed information on the required registry entries for upgraded applications.</p>
<p>&nbsp;</p></body>
</HTML>
