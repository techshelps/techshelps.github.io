<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>QueryInterface: Navigating in an Object</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h2><a name="_com_queryinterface_navigating_in_an_object"></a>QueryInterface: Navigating in an Object</h2>
<p>
Once you have an initial pointer to an interface on an object, COM has a very simple mechanism to find out whether the object supports another specific interface, and, if so, to get a pointer to it. (For information on getting an initial pointer to an interface on an object, refer to <a href="comext_1gvo.htm">Getting a Pointer to an Object</a>.) This mechanism is the <b>QueryInterface</b> method of the <a href="if_r2z_9dwu.htm"><b>IUnknown</b></a> interface. If the object supports the requested interface, the method must return a pointer to that interface. This permits an object to navigate freely through the interfaces that an object supports. <b>QueryInterface</b> separates the request "Do you support a given contract?" from the high-performance use of that contract once negotiations have been successful.</p>
<p>
When a client initially gains access to an object, that client will receive, at a minimum, an <b>IUnknown</b><i> </i>interface pointer (the most fundamental interface) through which it can control the lifetime of the object — tell the object when it is done using the object — and invoke <b>QueryInterface</b>. The client is programmed to ask each object it manages to perform some operations, but the <b>IUnknown</b><i> </i>interface has no functions for those operations. Instead, those operations are expressed through other interfaces. The client is thus programmed to negotiate with objects for those interfaces. Specifically, the client will ask an object — by calling <b>QueryInterface</b> — for an interface through which the client may invoke the desired operations.</p>
<p>
Since the object implements <b>QueryInterface</b>, it has the ability to accept or reject the request. If the object accepts the client's request, <b>QueryInterface</b><i> </i>returns a new pointer to the requested interface to the client. Through that interface pointer, the client has access to the methods of that interface. If, on the other hand, the object rejects the client's request, <b>QueryInterface</b><i> </i>returns a null pointer — an error — and the client has no pointer through which to call the desired functions. In this case, the client must deal gracefully with that possibility. For example, suppose a client has a pointer to interface A on an object, and asks for interfaces B and C. While the object supports interface B, it does not support interface C. The object returns a pointer to B, and reports that C is not supported.</p>
<p>
A key point is that when an object rejects a call to <b>QueryInterface</b>, it is impossible for the client to ask the object to perform the operations expressed through the requested interface. A client <i>must</i> have an interface pointer to invoke methods in that interface. There is no alternative. If the object refuses to provide one, a client must be prepared to do without, either not doing whatever it had intended to do with that object, or attempting to fall back on another, perhaps less powerful, interface. Had the object supported that interface, the client might have done something useful with it. This works well in comparison with other object-oriented systems in which you cannot know whether a function will work until you call that function, and even then, handling failure is uncertain. <b>QueryInterface</b> provides a reliable and consistent way to know whether an object supports an interface before attempting to call its methods.</p>
<p>
The <b>QueryInterface</b> method also provides a robust and reliable way for an object to indicate that it does <i>not</i> support a given contract. That is, if in a call to <b>QueryInterface</b> one asks an "old" object whether it supports a "new" interface (one, for example, that was invented after the old object had been shipped), the old object will reliably and, without causing a crash, answer "no." The technology that supports this is the algorithm by which IIDs are allocated. While this may seem like a small point, it is extremely important to the overall architecture of the system, and the ability to inquire of old things about new functionality is, surprisingly, a feature not present in most other object architectures.</p>
<p>&nbsp;</p></body>
</HTML>
