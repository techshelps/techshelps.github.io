<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CoReleaseMarshalData</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_com_coreleasemarshaldata"></a>CoReleaseMarshalData</h1>
<p>
Destroys a previously marshaled data packet. </p>
<pre><code><b>STDAPI CoReleaseMarshalData(
  IStream *</b><i> pStm  </i>//Pointer to stream containing data packet
<b>);</b>
 </code></pre>
<h4>Parameter</h4>
<dl>
<dt>
<i>pStm</i></dt>
<dd>
[in] Pointer to the stream that contains the data packet to be destroyed.
</dd>
</dl>
<h4>Return Values</h4>
<dl>
<dt>
This function supports the standard return values E_FAIL, E_INVALIDARG,</dt>
<dt>
</dt>
</dl>
<p>
E_OUTOFMEMORY, and E_UNEXPECTED, as well as the following:
<dl>
<dt>
S_OK</dt>
<dd>
The data packet was successfully destroyed.</dd>
<dt>
STG_E_INVALIDPOINTER</dt>
<dd>
An <a href="if_r2z_4x7x.htm"><b>IStream</b></a> error dealing with the <i>pStm</i> parameter.</dd>
<dt>
CO_E_NOTINITIALIZED</dt>
<dd>
The <a href="api1_36qt.htm"><b>CoInitialize</b></a> or <a href="api3_6med.htm"><b>OleInitialize</b></a> function was not called on the current thread before this function was called.
</dd>
</dl>
<h4>Remarks</h4>
<p>
The <b>CoReleaseMarshalData</b> function performs the following tasks:
<ol>
<li>
The function reads a CLSID from the stream. </li>
<li>
If COM's default marshaling implementation is being used, the function gets an <a href="if_f2n_6sh8.htm"><b>IMarshal</b></a> pointer to an instance of the standard unmarshaler. If custom marshaling is being used, the function creates a proxy by calling the <a href="api1_1nad.htm"><b>CoCreateInstance</b></a> function, passing the CLSID it read from the stream, and requesings an <b>IMarshal</b> interface pointer to the newly created proxy. </li>
<li>
Using whichever <b>IMarshal</b> interface pointer it has acquired, the function calls <a href="if_f2n_74v5.htm"><b>IMarshal::ReleaseMarshalData</b></a>. </li>
</ol>
<p>
You typically do not call this function. The only situation in which you might need to call this function is if you use custom marshaling (write and use your own implementation of <b>IMarshal</b>). Examples of when <b>CoReleaseMarshalData</b> should be called include the following situations:
<ul>
<li>
An attempt was made to unmarshal the data packet, but it failed.</li>
<li>
A marshaled data packet was removed from a global table.</li>
</ul>
<p>
As an analogy, the data packet can be thought of as a reference to the original object, just as if it were another interface pointer being held on the object. Like a real interface pointer, that data packet must be released at some point. The use of <b>IMarshal::ReleaseMarshalData</b> to release data packets is analogous to the use of <a href="if_r2z_59np.htm"><b>IUnknown::Release</b></a> to release interface pointers. </p>
<p>
Note that you do not need to call <b>CoReleaseMarshalData</b> after a successful call of the <a href="api1_6gbp.htm"><b>CoUnmarshalInterface</b></a> function; that function releases the marshal data as part of the processing that it does. </p>
<h4>QuickInfo</h4>
<p>
<b>&nbsp;&nbsp;Windows NT: </b>Use version 3.1 or later.<br>
<b>&nbsp;&nbsp;Windows: </b>Use Windows 95 or later.<br>
<b>&nbsp;&nbsp;Windows CE: </b>Unsupported.<br>
<b>&nbsp;&nbsp;Header: </b>Declared in objbase.h.<br>
<b>&nbsp;&nbsp;Import Library: </b>Included as a resource in ole32.dll.</p>
<h4>See Also</h4>
<p>
<a href="if_f2n_74v5.htm"><b>IMarshal::ReleaseMarshalData</b></a> </p>
<p>
</p>
<p>
</p>
<p>&nbsp;</p></body>
</HTML>
