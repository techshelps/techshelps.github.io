<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Rules for Implementing QueryInterface</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h2><a name="_com_rules_for_implementing_queryinterface"></a>Rules for Implementing QueryInterface</h2>
<p>
There are three main rules than govern implementing the <a href="if_r2z_7fvp.htm"><b>IUnknown::QueryInterface</b></a> method on a COM object:
<ul>
<li>
Objects must have identity</li>
<li>
The set of interfaces on an object instance must be static</li>
<li>
It must be possible to query successfully for any interface on an object from any other interface</li>
</ul>
<p>
<b><i>Objects must have identity</i></b>. For any given object instance, a call to <b>QueryInterface</b> must always return the same physical pointer value. This allows you to call <b>QueryInterface(IID_IUnknown, ...)</b> on any two interfaces and compare the results to determine whether they point to the same instance of an object.</p>
<p>
<b><i>The set of interfaces on an object instance must be static</i></b>. The set of interfaces accessible on an object via <b>QueryInterface </b>must be static, not dynamic. Specifically, if <b>QueryInterface</b> returns S_OK for a given IID once, it must never return E_NOINTERFACE on subsequent calls on the same object, and if <b>QueryInterface</b> returns E_NOINTERFACE for a given IID, subsequent calls for the same IID on the same object must never return S_OK.</p>
<p>
<b><i>It must be possible to query successfully for any interface on an object from any other interface.</i></b> That is, given the following code:</p>
<pre><code>IA * pA = (some function returning an IA *); 
IB * pB = NULL; 
HRESULT   hr; 
hr = pA-&gt;QueryInterface(IID_IB, &amp;pB); // line 4 
 </code></pre>
<p>
the following rules apply:
<ul>
<li>
If you have a pointer to an interface on an object, a call like the following to <b>QueryInterface</b> for that same interface must succeed:<pre><code>pA-&gt;QueryInterface(IID_IA, ...) 
 </code></pre>
</li>
<li>
If a call to <b>QueryInterface</b> for a second interface pointer succeeds, a call to QueryInterface from that pointer for the first interface must also succeed. If in line 4 of the example, <i>pB</i><b> </b>was successfully obtained, the following must also succeed:<pre><code>pB-&gt;QueryInterface(IID_IA, ...) 
 </code></pre>
</li>
<li>
Any interface must be able to query for any other interface on an object. So in line 4 of the example, <i>pB</i><b> </b>was successfully obtained, and you successfully query for a third interface (IC) using that pointer, you must also be able to query successfully for IC using the first pointer, pA. In this case, the following sequence must succeed:<pre><code>IC * pC = NULL; 
hr = pB-&gt;QueryInterface(IID_IC, &amp;pC);      //Line 7 
pA-&gt;QueryInterface(IID_IC, ...) 
 </code></pre>
</li>
</ul>
<p>
Interface implementations must maintain a counter that is large enough to support 231-1 outstanding pointer references to all the interfaces on a given object. Therefore, you should use a 32-bit unsigned integer for the counter.</p>
<p>
If a client needs to know that resources have been freed, it must use a method in some interface on the object with higher-level semantics before calling <b>Release</b>.</p>
<p>&nbsp;</p></body>
</HTML>
