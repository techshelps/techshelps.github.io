<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>IMoniker - Item Moniker Implementation</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_com_imoniker_item_moniker_implementation"></a>IMoniker - Item Moniker Implementation</h1>
<p>
Item monikers are used to identify objects within containers, such as a portion of a document, an embedded object within a compound document, or a range of cells within a spreadsheet. Item monikers are often used in combination with file monikers; a file moniker is used to identify the container while an item moniker is used to identify the item within the container. </p>
<p>
An item moniker contains a text string; this string is used by the container object to distinguish the contained item from the others. The container object must implement the <b>IOleItemContainer</b> interface; this interface enables the item moniker code to acquire a pointer to an object, given only the string that identifies the object. </p>
<h5>When to Use</h5>
<p>
If you're a moniker client (that is, you're using a moniker to get an interface pointer to an object), you typically don't need to know the class of the moniker you're using; you simply call methods using an <a href="if_f2n_8otu.htm"><b>IMoniker</b></a> interface pointer.</p>
<p>
If you're a moniker provider (that is, you're handing out monikers that identify your objects to make them accessible to moniker clients), you must use item monikers if the objects you're identifying are contained within another object and can be individually identified using a string. You'll also need to use another type of moniker (for example, file monikers) in order to identify the container object.</p>
<p>
To use item monikers, you must use the <a href="api2_1ktu.htm"><b>CreateItemMoniker</b></a> function to create the monikers. In order to allow your objects to be loaded when an item moniker is bound, the container of your objects must implement the <b>IOleItemContainer</b> interface. </p>
<p>
The most common example of moniker providers are COM applications that support linking. If your COM application supports linking to objects smaller than a file-based document, you need to use item monikers. For a server application that allows linking to a selection within a document, you use the item monikers to identify those objects. For a container application that allows linking to embedded objects, you use the item monikers to identify the embedded objects. </p>
<h4>Remarks</h4>
<dl>
<dt>
<a href="if_f2n_7o6s.htm"><b>IMoniker::BindToObject</b></a> </dt>
<dd>
If <i>pmkToLeft</i> is NULL, this method returns E_INVALIDARG. Otherwise, the method calls <a href="if_f2n_7o6s.htm"><b>IMoniker::BindToObject</b></a> on the <i>pmkToLeft</i> parameter, requesting an <b>IOleItemContainer</b> interface pointer. The method then calls <b>IOleItemContainer::GetObject</b>, passing the string contained within the moniker, and returns the requested interface pointer.</dd>
<dt>
<a href="if_f2n_1kx1.htm"><b>IMoniker::BindToStorage</b></a> </dt>
<dd>
If <i>pmkToLeft</i> is NULL, this method returns E_INVALIDARG. Otherwise, the method calls <b>IMoniker::BindToObject</b> on the <i>pmkToLeft</i> parameter, requesting an <b>IOleItemContainer</b> interface pointer. The method then calls <b>IOleItemContainer::GetObjectStorage</b> for the requested interface.</dd>
<dt>
<a href="if_f2n_79d1.htm"><b>IMoniker::Reduce</b></a> </dt>
<dd>
This method returns MK_S_REDUCED_TO_SELF and passes back the same moniker. </dd>
<dt>
<a href="if_f2n_8cx4.htm"><b>IMoniker::ComposeWith</b></a> </dt>
<dd>
If <i>pmkRight</i> is an anti-moniker, the returned moniker is NULL; if <i>pmkRight</i> is a composite whose leftmost component is an anti-moniker, the returned moniker is the composite after the leftmost anti-moniker is removed. If <i>pmkRight</i> is not an anti-moniker, the method combines the two monikers into a generic composite if <i>fOnlyIfNotGeneric</i> is FALSE; if <i>fOnlyIfNotGeneric</i> is TRUE, the method returns a NULL moniker and a return value of MK_E_NEEDGENERIC.</dd>
<dt>
<a href="if_f2n_44od.htm"><b>IMoniker::Enum</b></a> </dt>
<dd>
This method returns S_OK and sets *<i>ppenumMoniker</i> to NULL.</dd>
<dt>
<a href="if_f2n_7mp8.htm"><b>IMoniker::IsEqual</b></a> </dt>
<dd>
This method returns S_OK if both monikers are item monikers and their display names are identical (using a case-insensitive comparison); otherwise, the method returns S_FALSE.</dd>
<dt>
<a href="if_f2n_9uaw.htm"><b>IMoniker::Hash</b></a> </dt>
<dd>
This method calculates a hash value for the moniker.</dd>
<dt>
<a href="if_f2n_62g7.htm"><b>IMoniker::IsRunning</b></a> </dt>
<dd>
If <i>pmkToLeft</i> is NULL, this method returns TRUE if <i>pmkNewlyRunning</i> is non-NULL and is equal to this moniker. Otherwise, the method checks the ROT to see whether this moniker is running. 
<p>
If <i>pmkToLeft</i> is non-NULL, the method calls <a href="if_f2n_7o6s.htm"><b>IMoniker::BindToObject</b></a> on the <i>pmkToLeft</i> parameter, requesting an <b>IOleItemContainer</b> interface pointer. The method then calls <b>IOleItemContainer::IsRunning</b>, passing the string contained within this moniker. 
</dd>
<dt>
<a href="if_f2n_0k9x.htm"><b>IMoniker::GetTimeOfLastChange</b></a> </dt>
<dd>
If <i>pmkToLeft</i> is NULL, this method returns MK_E_NOTBINDABLE. Otherwise, the method creates a composite of <i>pmkToLeft</i> and this moniker and uses the ROT to access the time of last change. If the object is not in the ROT, the method calls <b>IMoniker::GetTimeOfLastChange</b> on the <i>pmkToLeft</i> parameter.</dd>
<dt>
<a href="if_f2n_2zvp.htm"><b>IMoniker::Inverse</b></a> </dt>
<dd>
This method returns an anti-moniker (i.e., the results of calling <a href="api2_6vci.htm"><b>CreateAntiMoniker</b></a>).</dd>
<dt>
<a href="if_f2n_9nu0.htm"><b>IMoniker::CommonPrefixWith</b></a> </dt>
<dd>
If the other moniker is an item moniker that is equal to this moniker, this method sets *<i>ppmkPrefix</i> to this moniker and returns MK_S_US; otherwise, the method calls the <a href="api2_9l2g.htm"><b>MonikerCommonPrefixWith</b></a> function. This function correctly handles the case where the other moniker is a generic composite.</dd>
<dt>
<a href="if_f2n_30j3.htm"><b>IMoniker::RelativePathTo</b></a> </dt>
<dd>
This method returns MK_E_NOTBINDABLE and sets *<i>ppmkRelPath</i> to NULL.</dd>
<dt>
<a href="if_f2n_1tb9.htm"><b>IMoniker::GetDisplayName</b></a> </dt>
<dd>
This method returns the concatenation of the delimiter and the item name that were specified when the item moniker was created.</dd>
<dt>
<a href="if_f2n_6ecl.htm"><b>IMoniker::ParseDisplayName</b></a> </dt>
<dd>
If <i>pmkToLeft</i> is NULL, this method returns MK_E_SYNTAX. Otherwise, the method calls <a href="if_f2n_7o6s.htm"><b>IMoniker::BindToObject</b></a> on the <i>pmkToLeft</i> parameter, requesting an <b>IOleItemContainer</b> interface pointer. The method then calls <b>IOleItemContainer::GetObject</b>, requesting an <a href="if_p2q_4t5x.htm"><b>IParseDisplayName</b></a> interface pointer to the object identified by the moniker, and passes the display name to <a href="if_p2q_4l5x.htm"><b>IParseDisplayName::ParseDisplayName</b></a>. </dd>
<dt>
<a href="if_f2n_4mr6.htm"><b>IMoniker::IsSystemMoniker</b></a></dt>
<dd>
This method returns S_OK and indicates MKSYS_ITEMMONIKER.</dd>
</dl>
<h4>See Also</h4>
<p>
<a href="api2_1ktu.htm"><b>CreateItemMoniker</b></a>, <a href="if_f2n_8otu.htm"><b>IMoniker</b></a>, <a href="if_o_0yb6.htm"><b>IOleItemContainer</b></a> </p>
<p>
</p>
<p>
</p>
<p>&nbsp;</p></body>
</HTML>
