<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Callback Synchronization</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h3><a name="_com_callback_synchronization"></a>Callback Synchronization</h3>
<p>
The asynchronous WinInet API (used for the most common protocols) leaves the synchronization of the callback mechanism and the calling application as an exercise for the client. This is intentional because it allows the greatest degree of flexibility. The default protocols and the URL Moniker implementation perform this synchronization and guarantee that single- and apartment-threaded applications never have to deal with free-thread-style contention. That is, the client's <a href="if_a2e_7kyr.htm"><b>IEnumFORMATETC</b></a> and <b>IBindStatusCallback</b> interfaces are called only on their proper threads. This feature is transparent to the user of the URL Moniker as long each thread that calls <a href="if_f2n_1kx1.htm"><b>IMoniker::BindToStorage</b></a> and <a href="if_f2n_7o6s.htm"><b>IMoniker::BindToObject</b></a> has a message queue.</p>
<p>
The Asynchronous Moniker specification requires more precise control over the prioritization and management of downloads than is allowed for either by WinSock or WinInet. Accordingly, a URL Moniker manages all the downloads for any given caller's thread, using—as part of its synchronization—a priority scheme based on the <b>IBinding</b> specification.</p>
<p>&nbsp;</p></body>
</HTML>
