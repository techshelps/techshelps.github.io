<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>IMarshal::MarshalInterface</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h2><a name="_com_imarshal_marshalinterface"></a>IMarshal::MarshalInterface</h2>
<p>
Writes into a stream the data required to initialize a proxy object in some client process.</p>
<pre><code><b>HRESULT MarshalInterface(
  IStream</b><i> *pStm</i><b>,        </b>//Pointer to stream used for marshaling
<b>  REFIID</b><i> riid</i><b>,          </b>//Reference to the identifier of the 
                        //interface to be marshaled
<b>  void</b><i> *pv</i><b>,             </b>//Interface pointer to be marshaled
<b>  DWORD</b><i> dwDestContext</i><b>,  </b>//Destination context
<b>  void</b><i> *pvDestContext</i><b>,  </b>//Reserved for future use
<b>  DWORD</b><i> mshlflags</i>       //Reason for marshaling
<b>);</b>
 </code></pre>
<h4>Parameters</h4>
<dl>
<dt>
<i>pStm</i></dt>
<dd>
[in] Pointer to the stream to be used during marshaling.</dd>
<dt>
<i>riid</i></dt>
<dd>
[in] Reference to the identifier of the interface to be marshaled. This interface must be derived from the <a href="if_r2z_9dwu.htm"><b>IUnknown</b></a> interface.</dd>
<dt>
<i>pv</i></dt>
<dd>
[in] Pointer to the interface pointer to be marshaled; can be NULL if the caller does not have a pointer to the desired interface.</dd>
<dt>
<i>dwDestContext</i></dt>
<dd>
[in] Destination context where the specified interface is to be unmarshaled. Values for <i>dwDestContext</i> come from the enumeration <a href="enums_6mpk.htm"><b>MSHCTX</b></a>. Currently, unmarshaling can occur either in another apartment of the current process (MSHCTX_INPROC) or in another process on the same computer as the current process (MSHCTX_LOCAL).</dd>
<dt>
<i>pvDestContext</i></dt>
<dd>
[in] Reserved for future use; must be zero.</dd>
<dt>
<i>mshlflags</i></dt>
<dd>
[in] Whether the data to be marshaled is to be transmitted back to the client process — the normal case — or written to a global table, where it can be retrieved by multiple clients. Valid values come from the <a href="enums_5bg3.htm"><b>MSHLFLAGS</b></a> enumeration.
</dd>
</dl>
<h4>Return Values</h4>
<p>
The method supports the standard return value E_FAIL, as well as the following: 
<dl>
<dt>
S_OK </dt>
<dd>
The interface pointer was marshaled successfully.</dd>
<dt>
E_NOINTERFACE</dt>
<dd>
The specified interface is not supported.</dd>
<dt>
STG_E_MEDIUMFULL</dt>
<dd>
The stream is full.
</dd>
</dl>
<h4>Remarks</h4>
<p>
This method is called indirectly, in a call to <a href="api1_8205.htm"><b>CoMarshalInterface</b></a>, by whatever code in the server process may be responsible for marshaling a pointer to an interface on an object. This marshaling code is usually a stub generated by COM for one of several interfaces that can marshal a pointer to an interface implemented on an entirely different object. Examples include the <a href="if_a2e_9mk9.htm"><b>IClassFactory</b></a> and <b>IOleItemContainer</b> interfaces. For purposes of this discussion, the code responsible for marshaling a pointer is called the "marshaling stub."</p>
<h5>Notes to Callers</h5>
<p>
Normally, rather than calling <b>IMarshal::MarshalInterface</b> directly, your marshaling stub instead should call the <b>CoMarshalInterface</b> function, which contains a call to this method. The stub makes this call to command an object to write its marshaling data into a stream. The stub then either passes the marshaling data back to the client process or writes it to a global table, where it can be unmarshaled by multiple clients. The stub's call to <b>CoMarshalInterface</b> is normally preceded by a call to <a href="api1_1p2w.htm"><b>CoGetMarshalSizeMax</b></a>, to get the maximum size of the stream buffer into which the marshaling data will be written.</p>
<p>
You do not explicitly call this method if you are:
<ul>
<li>
Implementing existing COM interfaces, or</li>
<li>
Defining your own interfaces using the Microsoft Interface Definition Language (MIDL).</li>
</ul>
<p>
In both cases, the MIDL-generated stub automatically makes the call.</p>
<p>
If you are not using MIDL to define your own interface, your marshaling stub must call this method, either directly or indirectly.Your stub implementation should call <b>MarshalInterface</b> immediately after its previous call to <a href="if_f2n_2fjs.htm"><b>IMarshal::GetMarshalSizeMax</b></a> returns. Because the value returned by <b>GetMarshalSizeMax</b> is guaranteed to be valid only so long as the internal state of the object being marshaled does not change, a delay in calling <b>MarshalInterface</b> runs the risk that the object will require a larger stream buffer than originally indicated.</p>
<p>
If the caller has a pointer to the interface to be marshaled, it should, as a matter of efficiency, use the <i>pv</i> parameter to pass that pointer. In this way, an implementation that may use such a pointer to determine the appropriate CLSID for the proxy does not have to call <a href="if_r2z_7fvp.htm"><b>IUnknown::QueryInterface</b></a> on itself. If a caller does not have a pointer to the interface to be marshaled, it can pass NULL.</p>
<h5>Notes to Implementers</h5>
<p>
Your implementation of <b>IMarshal::MarshalInterface</b> must write to the stream whatever data is needed to initialize the proxy on the receiving side. Such data would include a reference to the interface to be marshaled, a <b>MSHLFLAGS </b>value specifying whether the data should be returned to the client process or written to a global table, and whatever is needed to connect to the object, such as a named pipe, handle to a window, or pointer to an RPC channel.</p>
<p>
Your implementation should not assume that the stream is large enough to hold all the data. Rather, it should gracefully handle a STG_E_MEDIUMFULL error. Just before exiting, your implementation should position the seek pointer in the stream immediately after the last byte of data written.</p>
<p>
If the <i>pv</i> parameter is NULL and your implementation needs an interface pointer, it can call <a href="if_r2z_7fvp.htm"><b>IUnknown::QueryInterface</b></a> on the current object to get it. The <i>pv</i> parameter exists merely to improve efficiency.</p>
<p>
To ensure that your implementation of <b>MarshalInterface </b>continues to work properly as new destination contexts are supported in the future, delegate marshaling to COM's default implementation for all <i>dwDestContext</i> values that your implementation does not handle. To delegate marshaling to COM's default implementation, call the <a href="api1_88q4.htm"><b>CoGetStandardMarshal</b></a> helper function.</p>
<p>
Using the <b>MSHLFLAGS</b> enumeration, callers can specify whether an interface pointer is to be marshaled back to a single client or written to a global table, where it can be unmarshaled by multiple clients. You must make sure that your object can handle calls from the multiple proxies that might be created from the same initialization data.</p>
<h4>QuickInfo</h4>
<p>
<b>&nbsp;&nbsp;Windows NT: </b>Use version 3.1 or later.<br>
<b>&nbsp;&nbsp;Windows: </b>Use Windows 95 or later.<br>
<b>&nbsp;&nbsp;Windows CE: </b>Unsupported.<br>
<b>&nbsp;&nbsp;Header: </b>Declared in objidl.h.</p>
<h4>See Also</h4>
<p>
<a href="api1_88q4.htm"><b>CoGetStandardMarshal</b></a>, <a href="if_f2n_2fjs.htm"><b>IMarshal::GetMarshalSizeMax</b></a>, <a href="if_f2n_1mib.htm"><b>IMarshal::GetUnmarshalClass</b></a>, <a href="if_f2n_3icl.htm"><b>IMarshal::UnmarshalInterface</b></a>, <a href="custintf_1777.htm"><b>Defining COM Interfaces</b></a> </p>
<p>
</p>
<p>
</p>
<p>&nbsp;</p></body>
</HTML>
