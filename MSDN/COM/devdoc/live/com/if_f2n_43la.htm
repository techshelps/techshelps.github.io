<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>IMoniker - File Moniker Implementation</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_com_imoniker_file_moniker_implementation"></a>IMoniker - File Moniker Implementation</h1>
<p>
File monikers are monikers that represent a path in the file system; a file moniker can identify any object that is saved in its own file. To identify objects contained within a file, you can compose monikers of other classes (for example, item monikers) to the right of a file moniker. However, the moniker to the left of a file moniker within a composite must be another file moniker, an anti-moniker, or a class moniker. It is illegal, for example, for an item moniker to appear to the left of a file moniker in a composite. </p>
<p>
Note that an anti-moniker is the inverse of an entire file moniker, not the inverse of a component of the path that the moniker represents; that is, when you compose an anti-moniker to the right of a file moniker, the entire file moniker is removed. If you want to remove just the rightmost component of the path represented by a file moniker, you must create a separate file moniker based on the ".." path and then compose that to the end of the file moniker. </p>
<h5>When to Use</h5>
<p>
If you're a moniker client (that is, you're using a moniker to get an interface pointer to an object), you typically don't need to know the class of the moniker you're using; you simply call methods using an <a href="if_f2n_8otu.htm"><b>IMoniker</b></a> interface pointer.</p>
<p>
If you're a moniker provider (that is, you're handing out monikers that identify your objects to make them accessible to moniker clients), you must use file monikers if the objects you're identifying are stored in files. If each object resides in its own file, file monikers are the only type you need. If the objects you're identifying are smaller than a file, you need to use another type of moniker (for example, item monikers) in addition to file monikers.</p>
<p>
To use file monikers, you must use the <a href="api2_3tf6.htm"><b>CreateFileMoniker</b></a> function to create the monikers. In order to allow your objects to be loaded when a file moniker is bound, your objects must implement the <a href="if_p2q_99ph.htm"><b>IPersistFile</b></a> interface. </p>
<p>
The most common example of moniker providers are COM server applications that support linking. If your COM server application supports linking only to file-based documents in their entirety, file monikers are the only type of moniker you need. If your COM server application supports linking to objects smaller than a document (such as sections of a document or embedded objects), you must use item monikers as well as file monikers. </p>
<h4>Remarks</h4>
<dl>
<dt>
<a href="if_f2n_7o6s.htm"><b>IMoniker::BindToObject</b></a> </dt>
<dd>
When <i>pmkToLeft</i> is NULL, the method looks for the moniker in the ROT, and if found, queries the retrieved object for the requested interface pointer. If the moniker is not found in the ROT, the method loads the object from the file system and retrieves the requested interface pointer. 
<p>
If <i>pmkLeft</i> is not NULL, then instead of determining the class to instantiate and initialize with the contents of the file referred to by the file moniker using <b>GetClassFile</b> (or other means), call pmkLeft-&gt;BindToObject for <b>IClassFactory </b>and <a href="if_a2e_5wz6.htm"><b>IClassActivator</b></a>, retrieve this pointer in <i>pcf</i>.

<p>
If this fails with E_NOINTERFACE, return MK_E_INTERMEDIATEINTERFACENOTSUPPORTED.

<p>
If the <b>IClassFactory</b> pointer is successfully retrieved, call pcf-&gt;CreateInstance(IID_IPersistFile, (void**)&amp;ppf) to get a fresh instance of the class to be initialized and initialize it using <b>IPersistFile</b> or other appropriate means per the existing initialization paths of File moniker.
</dd>
<dt>
<a href="if_f2n_1kx1.htm"><b>IMoniker::BindToStorage</b></a> </dt>
<dd>
This method opens the file specified by the path represented by the moniker and returns an <a href="if_r2z_9b8l.htm"><b>IStorage</b></a> pointer to that file. The method supports binding to <b>IStorage</b> interface only; if <a href="if_r2z_4x7x.htm"><b>IStream</b></a> or <a href="if_f2n_9q9f.htm"><b>ILockBytes</b></a> is requested in <i>riid</i>, the method returns E_UNSPEC, and if other interfaces are requested, this method returns E_NOINTERFACE. <b>IStream</b> and <b>ILockBytes</b> will be supported in future releases. Unless <i>pmkToLeft</i> is a class moniker, <i>pmkToLeft</i> should be NULL, as in the implementation of <b>IMoniker::BindToObject</b>. For situations where <i>pmkToLeft</i> is non-NULL, see the above description.</dd>
<dt>
<a href="if_f2n_79d1.htm"><b>IMoniker::Reduce</b></a> </dt>
<dd>
This method returns MK_S_REDUCED_TO_SELF and passes back the same moniker.</dd>
<dt>
<a href="if_f2n_8cx4.htm"><b>IMoniker::ComposeWith</b></a> </dt>
<dd>
If <i>pmkRight</i> is an anti-moniker, the returned moniker is NULL. If <i>pmkRight</i> is a composite whose leftmost component is an anti-moniker, the returned moniker is the composite with the leftmost anti-moniker removed. If <i>pmkRight</i> is a file moniker, this method collapses the two monikers into a single file moniker, if possible. If not possible (e.g., if both file monikers represent absolute paths, as in <i>d:\work</i> and <i>e:\reports</i>), then the returned moniker is NULL and the return value is MK_E_SYNTAX. If <i>pmkRight</i> is neither an anti-moniker nor a file moniker, then the method checks the <i>fOnlyIfNotGeneric</i> parameter; if it is FALSE, the method combines the two monikers into a generic composite; if it is TRUE, the method sets *<i>ppmkComposite</i> to NULL and returns MK_E_NEEDGENERIC.</dd>
<dt>
<a href="if_f2n_44od.htm"><b>IMoniker::Enum</b></a> </dt>
<dd>
This method returns S_OK and sets <i>ppenumMoniker</i> to NULL. </dd>
<dt>
<a href="if_f2n_7mp8.htm"><b>IMoniker::IsEqual</b></a> </dt>
<dd>
This method returns S_OK if *<i>pmkOther</i> is a file moniker and the paths for both monikers are identical (using a case-insensitive comparison). Otherwise, the method returns S_FALSE.</dd>
<dt>
<a href="if_f2n_9uaw.htm"><b>IMoniker::Hash</b></a> </dt>
<dd>
This method calculates a hash value for the moniker.</dd>
<dt>
<a href="if_f2n_62g7.htm"><b>IMoniker::IsRunning</b></a> </dt>
<dd>
If <i>pmkNewlyRunning</i> is non-NULL, this method returns TRUE if that moniker is equal to this moniker. Otherwise, the method asks the ROT whether this moniker is running. The method ignores <i>pmkToLeft</i>.</dd>
<dt>
<a href="if_f2n_0k9x.htm"><b>IMoniker::GetTimeOfLastChange</b></a> </dt>
<dd>
If this moniker is in the ROT, this method returns the last change time registered there; otherwise, it returns the last write time for the file. If the file cannot be found, this method returns MK_E_NOOBJECT.</dd>
<dt>
<a href="if_f2n_2zvp.htm"><b>IMoniker::Inverse</b></a> </dt>
<dd>
This method returns an anti-moniker (i.e., the results of calling <a href="api2_6vci.htm"><b>CreateAntiMoniker</b></a>).</dd>
<dt>
<a href="if_f2n_9nu0.htm"><b>IMoniker::CommonPrefixWith</b></a> </dt>
<dd>
If both monikers are file monikers, this method returns a file moniker that is based on the common components at the beginning of two file monikers. Components of a file moniker can be: 
<ul>
<li>
A machine name of the form \\<i>server</i>\<i>share</i>. A machine name is treated as a single component, so two monikers representing the paths "\\myserver\public\work" and "\\myserver\private\games" do not have "\\myserver" as a common prefix.</li>
<li>
A drive designation (for example, "C:").</li>
<li>
A directory or file name.</li>
</ul>

<p>
If the other moniker is not a file moniker, this method passes both monikers in a call to the <a href="api2_9l2g.htm"><b>MonikerCommonPrefixWith</b></a> function. This function correctly handles the case where the other moniker is a generic composite.

<p>
This method returns MK_E_NOPREFIX if there is no common prefix.
</dd>
<dt>
<a href="if_f2n_30j3.htm"><b>IMoniker::RelativePathTo</b></a> </dt>
<dd>
This method computes a moniker which when composed to the right of this moniker yields the other moniker. For example, if the path of this moniker is "C:\work\docs\report.doc" and if the other moniker is "C:\work\art\picture.bmp," then the path of the computed moniker would be "..\..\art\picture.bmp." </dd>
<dt>
<a href="if_f2n_1tb9.htm"><b>IMoniker::GetDisplayName</b></a> </dt>
<dd>
This method returns the path that the moniker represents. If this method is called by a 16-bit application, the method checks to see whether the specified file exists and, if so, returns a short name for that file because 16-bit applications are not equipped to handle long file names. </dd>
<dt>
<a href="if_f2n_6ecl.htm"><b>IMoniker::ParseDisplayName</b></a> </dt>
<dd>
This method tries to acquire an <a href="if_p2q_4t5x.htm"><b>IParseDisplayName</b></a> pointer, first by binding to the class factory for the object identified by the moniker, and then by binding to the object itself. If either of these binding operations is successful, the file moniker passes the unparsed portion of the display name to the <a href="if_p2q_4l5x.htm"><b>IParseDisplayName::ParseDisplayName</b></a> method. 
<p>
This method returns MK_E_SYNTAX if <i>pmkToLeft</i> is non-NULL.
</dd>
<dt>
<a href="if_f2n_4mr6.htm"><b>IMoniker::IsSystemMoniker</b></a></dt>
<dd>
This method returns S_OK, and passes back MKSYS_FILEMONIKER. </dd>
</dl>
<h4>See Also</h4>
<p>
<a href="api2_3tf6.htm"><b>CreateFileMoniker</b></a>, <a href="if_f2n_8otu.htm"><b>IMoniker</b></a>, <a href="if_p2q_99ph.htm"><b>IPersistFile</b></a> </p>
<p>
</p>
<p>
</p>
<p>&nbsp;</p></body>
</HTML>
