<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CoMarshalInterface</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_com_comarshalinterface"></a>CoMarshalInterface</h1>
<p>
Writes into a stream the data required to initialize a proxy object in some client process. The COM library in the client process calls the <a href="api1_6gbp.htm"><b>CoUnmarshalInterface</b></a> function to extract the data and initialize the proxy. <b>CoMarshalInterface</b> can marshal only interfaces derived from <a href="if_r2z_9dwu.htm"><b>IUnknown</b></a>. </p>
<pre><code><b>STDAPI CoMarshalInterface(
  IStream</b><i> *pStm</i><b>,        </b>//Pointer to the stream used for marshaling
<b>  REFIID</b><i> riid</i><b>,          </b>//Reference to the identifier of the 
                        // interface
<b>  IUnknown</b><i> *pUnk</i><b>,</b>       //Pointer to the interface to be marshaled
<b>  DWORD</b><i> dwDestContext</i><b>,  </b>//Destination context
<b>  void</b><i> *pvDestContext</i><b>,</b>  //Reserved for future use
<b>  DWORD</b><i> mshlflags</i>       //Reason for marshaling
<b>);</b>
 </code></pre>
<h4>Parameters</h4>
<dl>
<dt>
<i>pStm</i></dt>
<dd>
[in] Pointer to the stream to be used during marshaling.</dd>
<dt>
<i>riid</i></dt>
<dd>
[in] Reference to the identifier of the interface to be marshaled. This interface must be derived from the <a href="if_r2z_9dwu.htm"><b>IUnknown</b></a> interface.</dd>
<dt>
<i>pUnk</i></dt>
<dd>
[in] Pointer to the interface to be marshaled. This interface must be derived from the <a href="if_r2z_9dwu.htm"><b>IUnknown</b></a> interface.</dd>
<dt>
<i>dwDestContext</i></dt>
<dd>
[in] Destination context where the specified interface is to be unmarshaled. Values for <i>dwDestContext</i> come from the enumeration <a href="enums_6mpk.htm"><b>MSHCTX</b></a>. Currently, unmarshaling can occur either in another apartment of the current process (MSHCTX_INPROC) or in another process on the same computer as the current process (MSHCTX_LOCAL).</dd>
<dt>
<i>pvDestContext</i></dt>
<dd>
[in] Reserved for future use; must be NULL. </dd>
<dt>
<i>mshlflags</i></dt>
<dd>
[in] Flag specifying whether the data to be marshaled is to be transmitted back to the client process—the normal case—or written to a global table, where it can be retrieved by multiple clients. Values come from the <a href="enums_5bg3.htm"><b>MSHLFLAGS</b></a> enumeration.
</dd>
</dl>
<h4>Return Values</h4>
<p>
This function supports the standard return values E_FAIL, E_OUTOFMEMORY, and E_UNEXPECTED, as well as the following:
<dl>
<dt>
S_OK</dt>
<dd>
The interface pointer was marshaled successfully.</dd>
<dt>
CO_E_NOTINITIALIZED</dt>
<dd>
The <a href="api1_36qt.htm"><b>CoInitialize</b></a> or <a href="api3_6med.htm"><b>OleInitialize</b></a> function was not called on the current thread before this function was called.</dd>
<dt>
<b>IStream</b> errors</dt>
<dd>
This function can also return any of the stream-access error values returned by the <a href="if_r2z_4x7x.htm"><b>IStream</b></a> interface.
</dd>
</dl>
<h4>Remarks</h4>
<p>
The <b>CoMarshalInterface</b> function marshals the interface referred to by <i>riid</i> on the object whose <b>IUnknown</b> implementation is pointed to by <i>pUnk.</i> To do so, the <b>CoMarshalInterface</b> function performs the following tasks:
<ol>
<li>
Queries the object for a pointer to the <a href="if_f2n_6sh8.htm"><b>IMarshal</b></a> interface. If the object does not implement <b>IMarshal</b>, meaning that it relies on COM to provide marshaling support, <b>CoMarshalInterface</b> gets a pointer to COM's default implementation of <b>IMarshal</b>.</li>
<li>
Gets the CLSID of the object's proxy by calling <a href="if_f2n_1mib.htm"><b>IMarshal::GetUnmarshalClass</b></a>, using whichever <b>IMarshal</b> interface pointer has been returned.</li>
<li>
Writes the CLSID of the proxy to the stream to be used for marshaling.</li>
<li>
Marshals the interface pointer by calling <a href="if_f2n_8ox1.htm"><b>IMarshal::MarshalInterface</b></a>.</li>
</ol>
<p>
If you are implementing existing COM interfaces or defining your own interfaces using the Microsoft Interface Definition Language (MIDL), the MIDL-generated proxies and stubs call <b>CoMarshalInterface</b> for you. If you are writing your own proxies and stubs, your proxy code and stub code should each call <b>CoMarshalInterface</b> to correctly marshal interface pointers. Calling <b>IMarshal</b> directly from your proxy and stub code is not recommended.</p>
<p>
If you are writing your own implementation of <a href="if_f2n_6sh8.htm"><b>IMarshal</b></a>, and your proxy needs access to a private object, you can include an interface pointer to that object as part of the data you write to the stream. In such situations, if you want to use COM's default marshaling implementation when passing the interface pointer, you can call <b>CoMarshalInterface</b> on the object to do so.</p>
<h4>QuickInfo</h4>
<p>
<b>&nbsp;&nbsp;Windows NT: </b>Use version 3.1 or later.<br>
<b>&nbsp;&nbsp;Windows: </b>Use Windows 95 or later.<br>
<b>&nbsp;&nbsp;Windows CE: </b>Unsupported.<br>
<b>&nbsp;&nbsp;Header: </b>Declared in objbase.h.<br>
<b>&nbsp;&nbsp;Import Library: </b>Included as a resource in ole32.dll.</p>
<h4>See Also</h4>
<p>
<a href="api1_6gbp.htm"><b>CoUnmarshalInterface</b></a>, <a href="if_f2n_8ox1.htm"><b>IMarshal::MarshalInterface</b></a> </p>
<p>
</p>
<p>
</p>
<p>&nbsp;</p></body>
</HTML>
