<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>IMessageFilter</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_com_imessagefilter"></a>IMessageFilter</h1>
<p>
The <b>IMessageFilter</b> interface provides COM servers and applications with the ability to selectively handle incoming and outgoing COM messages while waiting for responses from synchronous calls. Filtering messages helps to ensure that calls are handled in a manner that improves performance and avoids deadlocks. COM messages can be synchronous, asynchronous, or input-synchronized; the majority of interface calls are synchronous. </p>
<p>
Synchronous calls require the caller to wait for a reply before continuing. COM enters a modal loop while waiting for the reply. During this time, the caller is still able to receive and dispatch incoming messages. </p>
<p>
Asynchronous calls allow the caller to proceed without waiting for a response from the called object. Today, in COM, the only asynchronous calls are to an object's <a href="if_a2e_6pnv.htm"><b>IAdviseSink</b></a> interface. While the object is processing an asynchronous call, it is prohibited from making any synchronous calls back to the calling object. </p>
<p>
Input-synchronized calls require the called object to complete the call before relinquishing control, ensuring that behaviors such as focus management and type-ahead function correctly. </p>
<h5>When to Implement</h5>
<p>
You will probably want to implement your own message filter. The default implementation provided by COM offers only minimal message filtering capability. Although message filtering is no longer as significant as it was with 16-bit applications, since the size of the message queue is now virtually unlimited, you still should implement <b>IMessageFilter</b> as a way of resolving deadlocks. </p>
<p>
COM will call your implementation of <b>IMessageFilter</b> to find out if an application is blocking, so that you can task-switch to that application and give the user an opportunity to deal with the situation. For example, if you have Microsoft Word talking to Microsoft Excel, with Excel running in the background in formula mode, in which formulas are being applied to data on the worksheet to compute different or "what if" results, Excel won't check all calls, thereby blocking further action. <b>IMessageFilter</b> would put up a dialog box indicating which task was blocking and provide the user with an opportunity to deal with the deadlock. </p>
<p>
Although it is probably obvious from the method descriptions, it may still be useful to point out that <a href="if_f2n_5zak.htm"><b>HandleIncomingCall</b></a> is an object-based method and <a href="if_f2n_6jxo.htm"><b>RetryRejectedCall</b></a> and <a href="if_f2n_1lgn.htm"><b>MessagePending</b></a> are client-based methods. Clearly, the object must have some way of handling incoming calls from external clients. <b>HandleIncomingCall </b>provides that functionality by allowing the object to handle or defer some incoming calls and reject others. The client also needs to know how an object is going to handle its call. so that it can respond appropriately. The client needs to know if a call has been rejected, or just deferred temporarily, so that it can retry rejected calls after some specified time. The client also needs to be able to respond to Windows messages, while at the same time waiting for replies to pending messages. </p>
<p>
You will use <a href="api1_929e.htm"><b>CoRegisterMessageFilter</b></a> to register your message filter. Once registered, COM then calls your message filter instead of the default implementation. </p>
<h5>When to Use</h5>
<p>
You don't call this interface directly. It's provided by the COM server or application and called by COM.</p>
<h5>Application Shutdown with WM_QUERYENDSESSION and WM_ENDSESSION</h5>
<p>
When a user exits Windows, each open application receives a WM_QUERYENDSESSION message followed by a WM_ENDSESSION message, provided the exit is not canceled. These messages are invoked with <b>SendMessage</b>, which unfortunately restricts the initiation of all outgoing LRPC calls. This is a problem for container applications that have open embedded objects when they receive the shutdown request because LRPC is needed to close those objects.</p>
<p>
Container and container/server applications with open documents typically display a message box on receipt of the WM_QUERYENDSESSION message that asks if the user wants to save changes before exiting. A positive response is usually the default. The recommendation for dealing with the situation described above is for the application to display an alternate message box asking if the user wants to discard changes; a negative response should be the default. If the user chooses to discard the changes, TRUE should be returned for WM_QUERYENDSESSION, which .signals to Windows that it can terminate. If the user does not want to discard the changes, FALSE should be returned. No attempt should be made to close or release running embeddings.</p>
<p>
Server applications should return TRUE for WM_QUERYENDSESSION without prompting the user.On receipt of a WM_ENDSESSION message, all COM applications should execute the normal close sequence for each application's documents and/or objects. At the same time, you should ignore any errors resulting from any cross-process calls or calls to <b>IUnknown::Release</b>. All storage pointers (<b>IStorage</b> and <b>IStream</b> interface pointers) must be released to properly flush any temporary files maintained by the compound file implementation of structured storage.</p>
<h4>Methods in Vtable Order</h4>
<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=39%><a href="if_r2z_9dwu.htm">IUnknown</a> Methods</th>
<th align=left width=61%>Description</th>
</tr>
<tr valign=top>
<td width=39%><a href="if_r2z_7fvp.htm"><b>QueryInterface</b></a></td>
<td width=61%>Returns a pointer to a specified interface.</td>
</tr>
<tr valign=top>
<td width=39%><a href="if_r2z_3rja.htm"><b>AddRef</b></a></td>
<td width=61%>Increments the reference count.</td>
</tr>
<tr valign=top>
<td width=39%><a href="if_r2z_59np.htm"><b>Release</b></a></td>
<td width=61%>Decrements the reference count.</td>
</tr>
</table><br>
<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=39%>IMessageFilter Methods</th>
<th align=left width=61%>Description</th>
</tr>
<tr valign=top>
<td width=39%><a href="if_f2n_5zak.htm"><b>HandleIncomingCall</b></a></td>
<td width=61%>Provides a single entry point for incoming calls.</td>
</tr>
<tr valign=top>
<td width=39%><a href="if_f2n_6jxo.htm"><b>RetryRejectedCall</b></a></td>
<td width=61%>Provides application with opportunity to display a dialog box offering retry or cancel or task switching options.</td>
</tr>
<tr valign=top>
<td width=39%><a href="if_f2n_1lgn.htm"><b>MessagePending</b></a></td>
<td width=61%>Indicates a Windows message has arrived while COM is waiting to respond to a remote call.</td>
</tr>
</table><br>
<h4>QuickInfo</h4>
<p>
<b>&nbsp;&nbsp;Windows NT: </b>Use version 3.1 or later.<br>
<b>&nbsp;&nbsp;Windows: </b>Use Windows 95 or later.<br>
<b>&nbsp;&nbsp;Windows CE: </b>Unsupported.<br>
<b>&nbsp;&nbsp;Header: </b>Declared in objidl.h.</p>
<h4>See Also</h4>
<p>
<a href="api1_929e.htm"><b>CoRegisterMessageFilter</b></a> <a href="api3_7qyh.htm"><b>OleUIBusy</b></a>, <a href="structs_0d0y.htm"><b>OLEUIBUSY</b></a>, In the <i>WIN32 SDK</i>:<i> </i>"Messages and Message Queues"</p>
<p>
</p>
<p>
</p>
<p>&nbsp;</p></body>
</HTML>
