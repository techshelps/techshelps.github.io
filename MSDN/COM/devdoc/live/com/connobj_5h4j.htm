<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Architecture of Connectable Objects</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_com_architecture_of_connectable_objects"></a>Architecture of Connectable Objects</h1>
<p>
The connectable object itself is only one piece of the overall architecture of connectable objects. This technology includes:
<dl>
<dt>
<b><i>Connectable object</i></b></dt>
<dd>
Implements the <a href="if_a2e_5h2q.htm"><b>IConnectionPointContainer</b></a> interface; creates at least one connection point object; defines an outgoing interface for the client.</dd>
<dt>
<b><i>Client</i></b></dt>
<dd>
Queries the object for <b>IConnectionPointContainer</b> to determine if the object is connectable; creates a sink object to implement the outgoing interface defined by the connectable object.</dd>
<dt>
<b><i>Sink object</i></b></dt>
<dd>
Implements the outgoing interface; used to establish a connection to the connectable object.</dd>
<dt>
<b><i>Connection point object</i></b></dt>
<dd>
Implements the <a href="if_a2e_2ar8.htm"><b>IConnectionPoint</b></a> interface and manages connection with the client's sink.
</dd>
</dl>
<p>
The relationships between client, connectable object, a connection point, and a sink are illustrated in the following diagram:</p>
<p>
<img src="images/obpoints.gif" border=0></p>
<p>
Before the connection point object calls methods in the sink interface in step 3, it must <b>QueryInterface</b> for the specific interface required, even if the pointer was already passed in the step 2 call to the <b>Advise</b> method.</p>
<p>
Two enumerator objects are also involved in this architecture though not shown in the illustration. One is created by a method in <b>IConnectionPointContainer</b> to enumerate the connection points within the connectable object. The other is created by a method in <b>IConnectionPoint</b> to enumerate the connections currently established to that connection point. One connection point can support multiple connected sink interfaces, and it should iterate through the list of connections each time it makes a method call on that interface. This process is known as multi-casting.</p>
<p>
When working with connectable objects it is important to understand that the connectable object, each connection point, each sink, and all enumerators are separate objects with separate <b>IUnknown</b> implementations, separate reference counts, and separate lifetimes. A client using these objects is always responsible for releasing all reference counts it owns.</p>
<p>
<b>Note</b>&nbsp;&nbsp;A connectable object can support more than one client and can support multiple sinks within a client. Likewise, a sink can be connected to more than one connectable object.</p>
<p>
The steps for establishing a connection between a client and a connectable object are:
<ol>
<li>
The client queries for <b>IConnectionPointContainer</b> on the object to determine if the object is connectable. If this call is successful, the client holds a pointer to the <b>IConnectionPointContainer</b> interface on the connectable object, and the connectable object reference counter has been incremented. Otherwise, the object is not connectable and does not support outgoing interfaces.</li>
<li>
If the object is connectable, the client next tries to obtain a pointer to the <b>IConnectionPoint</b> interface on a connection point within the connectable object. There are two methods for obtaining this pointer, both in <b>IConnectionPointContainer</b> — <b>FindConnectionPoint</b> and <b>EnumConnectionPoints</b>. There are a few additional steps needed if <b>EnumConnectionPoints</b> is used; see below for more information. If successful, the connectable object and the client both support the same outgoing interface. The connectable object defines it and calls it while the client implements it. The client can then communicate through the connection point within the connectable object.</li>
<li>
The client then calls <b>IConnectionPoint::Advise</b> on the connection point to establish a connection between its sink interface and the object's connection point. After this call, the object's connection point holds a pointer to the outgoing interface on the sink.</li>
<li>
The code inside <b>IConnectionPoint::Advise</b> calls <b>QueryInterface</b> on the interface pointer that is passed in, asking for the specific interface identifier to which it connects.</li>
<li>
The object calls methods on the sink's interface as needed using the pointer held by its connection point.</li>
<li>
The client calls <b>IConnectionPoint::Unadvise</b> to terminate the connection. Then, the client calls <b>IConnectionPoint::Release</b> to free its hold on the connection point and, thus, the main connectable object also. The client must also call <b>IConnectionPointContainer::Release</b> to free its hold on the main connectable object.</li>
</ol>
<p>&nbsp;</p></body>
</HTML>
