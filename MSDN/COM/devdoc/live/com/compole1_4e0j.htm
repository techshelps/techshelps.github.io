<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Working with OLE 1 Servers</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_ole_working_with_ole_1_servers"></a>Working with OLE 1 Servers</h1>
<p>
This section describes some of the known idiosyncrasies of embedding or linking OLE 1 objects.</p>
<p>
As with OLE 2 objects, either the <a href="if_p2q_7hyv.htm"><b>IPersistStorage::InitNew</b></a> method or the <a href="if_p2q_34pw.htm"><b>IPersistStorage::Load</b></a> method must be called to properly initialize a newly instantiated OLE 1 object before any other OLE calls are made. The <b>InitNew</b> method should be called to initialize a newly created object; the <b>Load</b> method should be called for existing objects. If one of the <a href="api3_6y5h.htm"><b>OleCreate</b></a> helper functions or the <a href="api3_1cmc.htm"><b>OleLoad</b></a> function is being used, these functions make the <b>IPersistStorage</b> call, eliminating the need to make the call directly. When an OLE 2 container with an OLE 1 embedded or linked object calls the <a href="if_a2e_1jz5.htm"><b>IDataObject::GetData</b></a> method or the <a href="if_a2e_7iat.htm"><b>IDataObject::GetDataHere</b></a> method, the container can anticipate support for a smaller set of formats and storage mediums than would be supported for an OLE 2 object. The following table lists the combinations that can be supported.</p>
<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=33%>Tymed Formats</th>
<th align=left width=67%>Data Formats</th>
</tr>
<tr valign=top>
<td width=33%>TYMED_MFPICT</td>
<td width=67%>CF_METAFILEPICT</td>
</tr>
<tr valign=top>
<td width=33%>TYMED_GDI</td>
<td width=67%>CF_BITMAP</td>
</tr>
<tr valign=top>
<td width=33%>TYMED_HGLOBAL</td>
<td width=67%>cfNative, CF_DIB, and other OLE 1 server formats</td>
</tr>
</table><br>
<p>
For the aspect value of DVASPECT_ICON, only TYMED_MFPICT with CF_METAFILEPICT is supported. The icon returned from the <a href="if_a2e_1jz5.htm"><b>IDataObject::GetData</b></a> or <a href="if_a2e_7iat.htm"><b>IDataObject::GetDataHere</b></a> call will always be the first icon (index 0) in the executable object application.</p>
<p>
Several methods typically called by containers have unique implementations for OLE 1. The <a href="if_p2q_85x5.htm"><b>IPersistStorage::IsDirty</b></a> method is defined to return S_OK if the object has changed since its last save to persistent storage; S_FALSE if it has not changed. When an OLE 2 container with an OLE 1 embedded object calls the <b>IPersistStorage::IsDirty</b> method, the compatibility code always returns S_OK when the server is running, because there is no way to determine if the object has in fact changed until the File Close or File Update command is selected. S_FALSE is returned when the server is not running.</p>
<p>
An OLE 2 implementation of <a href="if_o_86w5.htm"><b>IOleObject::IsUpToDate</b></a> can return either S_OK if the object is up-to-date, S_FALSE if it is not up-to-date, or OLE_E_UNAVAILABLE if the object cannot determine whether it is up-to-date. The OLE 1 implementation always returns either E_NOT_RUNNING, if the object is in the loaded state, or S_FALSE, if the server is running.</p>
<p>
The OLE 1 implementation of the <b>IOleItemContainer::EnumObjects</b> method always returns OLE_E_NOTSUPPORTED because it is not possible for an OLE 1 server to enumerate its objects.</p>
<p>
The <a href="if_o_6izq.htm"><b>IOleObject::Close</b></a> method takes a save option as a parameter that indicates whether the object should be saved before the close occurs. For OLE 2 objects, there are three possible save options: OLECLOSE_SAVEIFDIRTY, OLECLOSE_NOSAVE, and OLECLOSE_PROMPTSAVE. The OLE 1 implementation of the <b>IOleObject::Close</b> method treats OLECLOSE_PROMPTSAVE as equivalent to OLECLOSE_SAVEIFDIRTY, because it is not possible to require an OLE 1 server to prompt the user.</p>
<p>
OLE 2 containers cannot expect an OLE 1 object to activate in-place; all OLE 1 objects support activation in a separate, open window.</p>
<p>
OLE 1 servers do not support linking to their embedded objects. It is up to OLE 2 containers with OLE 1 embedded objects to prevent a possible link from occurring. Containers can call the <a href="api1_2zlf.htm"><b>CoIsOle1Class</b></a> function to determine at Clipboard copy time if a data selection being copied is an OLE 1 object. If the <b>CoIsOle1Class</b> function returns TRUE, indicating that the selection is an OLE 1 object, the container should not offer the Link Source format. Link Source must be available for a linked object to be created.</p>
<p>
OLE 2 containers can store multiple presentations for an OLE 1 object. However, only the first presentation format is sent to the container when the OLE 1 server closes. After that, the server is in the process of closing down and cannot honor requests for any more formats. Therefore, only the first presentation cache will be updated. The rest will be out of date (perhaps blank) if the object has changed since the last update.</p>
<p>
Because OLE 1 servers do not update the cache for every change to an embedded object until the user selects the File Update command, an OLE 2 container may not be obtaining the latest data from the server. By calling the <a href="if_o_50th.htm"><b>IOleObject::Update</b></a> method, the container can obtain the latest object data.</p>
<p>
An OLE 1 embedded (not linked) object does not notify its container that its data has changed until the user chooses File Update or File Close. Therefore, if an OLE 2 container registers for a data-change notification on an OLE 2 object in a particular format, it should be aware that it will not be notified immediately when the data changes.</p>
<p>
When an OLE 1 object is inserted into a container document and then closed without an update being invoked, the container document is not saved. Neither are the correct streams for the object written into storage. Any subsequent loading of the object by the container will fail. To protect against this, containers can keep data available after the object closes without updating by implementing the following:</p>
<pre><code>OleCreate();             \\ to insert the object 
OleRun();                \\ if OLERENDER_NONE was specified 
IOleObject::Update();    \\ to get snapshot of data 
OleSave(); 
IOleObject::DoVerb(); 
 </code></pre>
<p>&nbsp;</p></body>
</HTML>
