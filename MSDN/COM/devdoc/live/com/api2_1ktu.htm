<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CreateItemMoniker</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_com_createitemmoniker"></a>CreateItemMoniker</h1>
<p>
Creates an item moniker that identifies an object within a containing object (typically a compound document).</p>
<pre><code><b>WINOLEAPI CreateItemMoniker(
  LPCOLESTR</b><i> lpszDelim</i><b>, </b>//Pointer to delimiter string
<b>  LPCOLESTR</b><i> lpszItem</i><b>,  </b>//Pointer to item name
<b>  LPMONIKER FAR</b><i> *ppmk  </i>//Address of output variable that receives 
                       // the IMoniker interface pointer
<b>);</b>
 </code></pre>
<h4>Parameters</h4>
<dl>
<dt>
<i>lpszDelim</i></dt>
<dd>
[in] Pointer to a wide character string (two bytes per character) zero-terminated string containing the delimiter (typically "!") used to separate this item's display name from the display name of its containing object.</dd>
<dt>
<i>lpszItem</i></dt>
<dd>
[in] Pointer to a zero-terminated string indicating the containing object's name for the object being identified. This name can later be used to retrieve a pointer to the object in a call to <a href="if_o_9gz8.htm"><b>IOleItemContainer::GetObject</b></a>.</dd>
<dt>
<i>ppmk</i></dt>
<dd>
[out] Address of <b>IMoniker</b>* pointer variable that receives the interface pointer to the item moniker. When successful, the function has called <a href="if_r2z_3rja.htm"><b>IUnknown::AddRef</b></a> on the item moniker and the caller is responsible for calling <a href="if_r2z_59np.htm"><b>IUnknown::Release</b></a>. If an error occurs, the supplied interface pointer has a NULL value.
</dd>
</dl>
<h4>Return Values</h4>
<p>
This function supports the standard return value E_OUTOFMEMORY, as well as the following:
<dl>
<dt>
S_OK</dt>
<dd>
The moniker was created successfully.
</dd>
</dl>
<h4>Remarks</h4>
<p>
A moniker provider, which hands out monikers to identify its objects so they are accessible to other parties, would call <b>CreateItemMoniker</b> to identify its objects with item monikers. Item monikers are based on a string, and identify objects that are contained within another object and can be individually identified using a string. The containing object must also implement the <a href="if_o_4ysy.htm"><b>IOleContainer</b></a> interface. </p>
<p>
Most moniker providers are OLE applications that support linking. Applications that support linking to objects smaller than file-based documents, such as a server application that allows linking to a selection within a document, should use item monikers to identify the objects. Container applications that allow linking to embedded objects use item monikers to identify the embedded objects. </p>
<p>
The <i>lpszItem</i> parameter is the name used by the document to uniquely identify the object. For example, if the object being identified is a cell range in a spreadsheet, an appropriate name might be something like "A1:E7." An appropriate name when the object being identified is an embedded object might be something like "embedobj1." The containing object must provide an implementation of the <a href="if_o_0yb6.htm"><b>IOleItemContainer</b></a> interface that can interpret this name and locate the corresponding object. This allows the item moniker to be bound to the object it identifies.</p>
<p>
Item monikers are not used in isolation. They must be composed with a moniker that identifies the containing object as well. For example, if the object being identified is a cell range contained in a file-based document, the item moniker identifying that object must be composed with the file moniker identifying that document, resulting in a composite moniker that is the equivalent of "C:\work\sales.xls!A1:E7." </p>
<p>
Nested containers are allowed also, as in the case where an object is contained within an embedded object inside another document. The complete moniker of such an object would be the equivalent of "C:\work\report.doc!embedobj1!A1:E7." In this case, each containing object must call <b>CreateItemMoniker</b> and provide its own implementation of the <b>IOleItemContainer </b>interface. </p>
<h4>QuickInfo</h4>
<p>
<b>&nbsp;&nbsp;Windows NT: </b>Use version 3.1 or later.<br>
<b>&nbsp;&nbsp;Windows: </b>Use Windows 95 or later.<br>
<b>&nbsp;&nbsp;Windows CE: </b>Unsupported.<br>
<b>&nbsp;&nbsp;Header: </b>Declared in objbase.h.<br>
<b>&nbsp;&nbsp;Import Library: </b>Included as a resource in ole32.dll.</p>
<h4>See Also</h4>
<p>
<a href="if_f2n_8cx4.htm"><b>IMoniker::ComposeWith</b></a>,<b> <a href="if_o_0yb6.htm">IOleItemContainer</a></b>,<b> <a href="if_f2n_99ny.htm">IMoniker - Item Moniker Implementation</a></b> </p>
<p>
</p>
<p>
</p>
<p>&nbsp;</p></body>
</HTML>
