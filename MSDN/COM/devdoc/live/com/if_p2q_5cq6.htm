<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>IPropertyStorage-Standalone Implementation</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_com_ipropertystorage_standalone_implementation"></a>IPropertyStorage-Standalone Implementation</h1>
<p>
The system-provided, standalone implementation of <b>IPropertySetStorage</b> includes an implementation of <b>IPropertyStorage</b>, the interface that reads and writes properties in a property set storage. The <b>IPropertySetStorage</b> interface creates and opens property sets in a storage. The <b>IEnumSTATPROPSTG</b> and <b>IEnumSTATPROPSETSTG</b> interfaces are also provided in the standalone implementation.</p>
<p>
To get a pointer to the standalone implementation of <b>IPropertyStorage</b>, call the <b>StgCreatePropStg</b> function if you are creating a new property set or <b>StgOpenPropStg</b> if you want to obtain the interface pointer on an existing property set (or call the <b>Create</b> or <b>Open</b> methods of the <b>IPropertySetStorage</b> standalone implementation).</p>
<p>
The standalone implementation of <b>IPropertyStorage</b> creates property sets on any storage or stream object, not just on compound file storages and streams. The standalone implementation does not depend on compound files and can be used with any implementation of structured storages. See the section <b>IPropertyStorage-Compound File Implementation</b> in the Object Services section of the Platform SDK for more information on the compound file implementation of this interface.</p>
<h5>When to Use</h5>
<p>
Use <b>IPropertyStorage</b> to manage properties within a single property set. Its methods support reading, writing, and deleting both properties and the optional string names that can be associated with property identifiers. Other methods support the standard commit and revert storage operations. There is also a method that sets times associated with the property storage, and another that permits the assignment of a CLSID that can be used to associate other code, such as user interface code, with the property set. The <b>Enum</b> method supplies a pointer to the standalone implementation of <b>IEnumSTATPROPSTG</b>, which enumerates the properties in the set.</p>
<h4>Remarks</h4>
<p>
There are some differences between the standalone implementation of the property set interfaces and the compound file implementation. In the compound file implementation of stream, storage, property set storage, and property storage objects, the various interfaces are able to coordinate with one another because they are part of a common implementation. In the standalone implementation, the interface implementations are distinct from one another.</p>
<p>
As a result, the compound-file implementation handles concurrency issues and synchronizes the property set object with the storage or stream object. With the standalone implementation, the client is responsible for handling concurrency and synchronization issues between the storage or stream object and the property set. A client can meet these requirements by following two simple rules. First, never manipulate a property set using its stream or storage interfaces while a property storage object is opened on it. And, second, always Commit a property storage object before calling Commit, CopyTo, or MoveElementTo on an ancestor storage object. Specifically, the following items require client attention:
<ul>
<li>
In the compound file implementation, a single mechanism provides concurrency protection for the storage object and its associated property set objects. However, in the standalone implementation, the storage object implementation is separate from the property set implementation and each provides its own concurrency mechanisms. Thus, in the standalone implementation, the client is responsible for maintaining concurrency protection between the two implementations through a mutual exclusion mechanism.</li>
<li>
In the compound file implementation, changes to property sets are buffered in a property set cache. Then, when the <b>IStorage::Commit</b> method is called on the storage object, the compound files implementation automatically flushes the property set changes from the property set buffer before the storage object is committed. Thus, the property set changes are made visible as part of the transaction being committed.</li>
<li>
In the standalone implementation, the client must explicitly flush the property set buffer by calling <b>IPropertyStorage::Commit</b> before calling the <b>IStorage:Commit</b> method on the storage. Alternately, the client can use the new PROPSETFLAG_UNBUFFERED value in the standalone implementation to write directly to the property set instead of caching changes to the property set's internal buffer. If PROPSETFLAG_UNBUFFERED is used, the client's responsibilities are automatically met. The compound file implementation does not support the PROPSETFLAG_UNBUFFERED value. See the <a href="enums_4exz.htm"><b>PROPSETFLAG</b></a> enumeration for more information on using this value.</li>
<li>
As with transacted storages, the compound file implementation updates the property set by flushing its internal buffer prior to executing a call to <b>IStorage::CopyTo</b> or <b>IStorage::MoveElementTo</b>. Thus, changes to the property set are reflected in the copied or moved storage element.</li>
<li>
In the standalone implementation, the client must explicitly flush the property set buffer by calling <b>IPropertyStorage::Commit</b> before calling <b>IStorage::CopyTo</b> or <b>IStorage::MoveElementTo</b>. Alternately, the client can use the new PROPSETFLAG_UNBUFFERED to write directly to the property set instead of caching changes to the property set buffer. See the <a href="enums_4exz.htm"><b>PROPSETFLAG</b></a> enumeration for more information on using this value.</li>
</ul>
<p>
The standalone implementation of <b>IPropertyStorage</b> supports the following methods:
<dl>
<dt>
<b>IPropertyStorage::ReadMultiple</b></dt>
<dd>
Reads the properties specified in the <i>rgpspec</i> array and supplies the values of all valid properties in the <i>rgvar</i> array of PROPVARIANTs.
<p>
In the system-provided, standalone implementation, duplicate property identifiers that refer to stream- or storage-types result in multiple calls to <b>IStorage::OpenStream</b> or <b>IStorage::OpenStorage</b> and the success or failure of <b>ReadMultiple</b> depends on the underlying storage implementation's ability to share open storages.

<p>
In addition, to ensure thread-safe operation if the same stream- or storage-valued property is requested multiple times through the same <b>IPropertyStorage</b> pointer, the open will succeed or fail depending on whether or not the property is already open and on whether the underlying file system handles multiple opens of a stream or storage. Thus, the <b>ReadMultiple</b> operation on a stream- or storage-valued property always results in a call to <b>IStorage::OpenStream</b>, or <b>IStorage::OpenStorage</b>, passing the access (STGM_READWRITE, for example) and share values (STGM_SHARE_EXCLUSIVE, for example) specified when the property set was originally opened or created.

<p>
If the method fails, the values written to <i>rgvar</i>[] are undefined. If some stream- or storage-valued properties are opened successfully but an error occurs before execution is complete, these properties should be released before the method returns.
</dd>
<dt>
<b>IPropertyStorage::WriteMultiple</b> </dt>
<dd>
Writes the properties specified in the <i>rgpspec</i>[] array, assigning them the PROPVARIANT tags and values specified in <i>rgvar</i>[]. Properties that already exist are assigned the specified PROPVARIANT values, and properties that do not currently exist are created.</dd>
<dt>
<b>IPropertyStorage::DeleteMultiple</b> </dt>
<dd>
Deletes the properties specified in the <i>rgpspec</i>[].</dd>
<dt>
<b>IPropertyStorage::ReadPropertyNames</b> </dt>
<dd>
Reads existing string names associated with the property identifiers specified in the <i>rgpropid</i>[] array.</dd>
<dt>
<b>IPropertyStorage::WritePropertyNames</b> </dt>
<dd>
Assigns string names specified in the <i>rglpwstrName</i> array to property identifiers specified in the <i>rgpropid</i> array.</dd>
<dt>
<b>IPropertyStorage::DeletePropertyNames</b> </dt>
<dd>
Deletes the string names of the property identifiers specified in the <i>rgpropid</i> array by writing NULL to the property name.</dd>
<dt>
<b>IPropertyStorage::SetClass</b> </dt>
<dd>
Sets the CLSID field of the property set stream. In the standalone implementation, setting the CLSID on a non-simple property set (one that can contain storage- or stream-valued properties, as described in <b>IPropertySetStorage::Create</b>) also sets the CLSID on the underlying sub-storage so it can be obtained through a call to <b>IStorage::Stat</b>.</dd>
<dt>
<b>IPropertyStorage::Commit</b> </dt>
<dd>
For both simple and non-simple property sets, flushes the memory image to the disk subsystem. In addition, for non-simple transacted-mode property sets, this method calls <b>IStorage::Commit</b> on the property set.</dd>
<dt>
<b>IPropertyStorage::Revert</b> </dt>
<dd>
For non-simple property sets only, calls the underlying storage's <b>Revert</b> method and re-opens the 'contents' stream. For simple property sets, only returns E_OK.</dd>
<dt>
<b>IPropertyStorage::Enum</b> </dt>
<dd>
Creates an enumerator object that implements <b>IEnumSTATPROPSTG</b>, the methods of which can be called to enumerate the STATPROPSTG structures that provide information about each of the properties in the set.
<p>
This implementation creates an array into which the entire property set is read and which can be shared when <b>IEnumSTATPROPSTG::Clone</b> is called.
</dd>
<dt>
<b>IPropertyStorage::Stat</b> </dt>
<dd>
Fills in the fields of a STATPROPSETSTG structure, which contains information about the property set as a whole. On return, supplies a pointer to the structure.
<p>
For non-simple storage sets, this implementation calls <b>IStorage::Stat</b> (or <b>IStream::Stat</b>) to get the information from the underlying storage or stream.
</dd>
<dt>
<b>IPropertyStorage::SetTimes</b> </dt>
<dd>
For non-simple property sets only, sets the times supported by the underlying storage. This implementation of <b>SetTimes</b> calls the <b>IStorage::SetElementTimes</b> method of the underlying storage to modify the times. It supports the times supported by the underlying method which can be modification time, access time, or creation time.
</dd>
</dl>
<h4>Programming Information</h4>
<table cellspacing=4 cols=2>
<tr valign=top>
<td width=48%>Windows NT</td>
<td width=52%>4.0/SP2 or with <a href="newgloss_8xvd.htm#_oleglos_redistributable_files">IPROP.DLL</a></td>
</tr>
<tr valign=top>
<td width=48%>Win95</td>
<td width=52%>Yes; requires IPROP.DLL</td>
</tr>
<tr valign=top>
<td width=48%>Win32s</td>
<td width=52%>No</td>
</tr>
<tr valign=top>
<td width=48%>Unicode</td>
<td width=52%>Yes</td>
</tr>
<tr valign=top>
<td width=48%>Import Library</td>
<td width=52%>IPROP.DLL</td>
</tr>
<tr valign=top>
<td width=48%>Header File</td>
<td width=52%>IPROPIDL.H</td>
</tr>
</table><br>
<h4>See Also</h4>
<p>
<a href="if_p2q_8vce.htm"><b>IPropertySetStorage-Standalone Implementation</b></a>, <a href="if_p2q_80md.htm"><b>IPropertyStorage</b></a>, <a href="if_r2z_2ss3.htm"><b>IStorage::SetElementTimes</b></a>, <a href="api4_26hz.htm"><b>StgOpenPropStg</b></a>, <a href="api4_59ev.htm"><b>StgCreatePropStg</b></a>, <a href="api4_1dd3.htm"><b>StgCreatePropSetStg</b></a> </p>
<p>
</p>
<p>
</p>
<p>&nbsp;</p></body>
</HTML>
