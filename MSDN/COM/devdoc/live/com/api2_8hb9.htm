<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>MkParseDisplayName</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_com_mkparsedisplayname"></a>MkParseDisplayName</h1>
<p>
Converts a string into a moniker that identifies the object named by the string. This is the inverse of the <a href="if_f2n_1tb9.htm"><b>IMoniker::GetDisplayName</b></a> operation, which retrieves the display name associated with a moniker.</p>
<pre><code><b>WINOLEAPI MkParseDisplayName(
  LPBC</b><i> pbc</i><b>,             </b>//Pointer to the bind context object
<b>  LPCOLESTR</b><i> szUserName</i><b>, </b>//Pointer to display name
<b>  ULONG FAR</b><i> *pchEaten</i><b>,  </b>//Pointer to the number of characters 
                        // consumed
<b>  LPMONIKER FAR</b><i> *ppmk   </i>//Address of output variable that receives 
                        // the IMoniker interface pointer
<b>);</b>
 </code></pre>
<h4>Parameters</h4>
<dl>
<dt>
<i>pbc</i></dt>
<dd>
[in] Pointer to the <b>IBindCtx</b> interface on the bind context object to be used in this binding operation.</dd>
<dt>
<i>szUserName</i></dt>
<dd>
[in] Pointer to a zero-terminated wide character string (two bytes per character) containing the display name to be parsed.</dd>
<dt>
<i>pchEaten</i></dt>
<dd>
[out] Pointer to the number of characters of <i>szUserName</i> that were consumed. If the function is successful, <i>*pchEaten</i> is the length of <i>szUserName</i>; otherwise, it is the number of characters successfully parsed. </dd>
<dt>
<i>ppmk</i></dt>
<dd>
[out] Address of <b>IMoniker</b>* pointer variable that receives the interface pointer to the moniker that was built from <i>szUserName</i>. When successful, the function has called <a href="if_r2z_3rja.htm"><b>IUnknown::AddRef</b></a> on the moniker and the caller is responsible for calling <a href="if_r2z_59np.htm"><b>IUnknown::Release</b></a>. If an error occurs, the supplied interface pointer value is NULL.
</dd>
</dl>
<h4>Return Values</h4>
<p>
This function supports the standard return value E_OUTOFMEMORY, as well as the following:
<dl>
<dt>
S_OK</dt>
<dd>
The parse operation was successful and the moniker was created.</dd>
<dt>
MK_E_SYNTAX</dt>
<dd>
Error in the syntax of a file name or an error in the syntax of the resulting composite moniker.
</dd>
</dl>
<p>
This function can also return any of the error values returned by <a href="if_f2n_7o6s.htm"><b>IMoniker::BindToObject</b></a>, <a href="if_o_9gz8.htm"><b>IOleItemContainer::GetObject</b></a>, or <a href="if_p2q_4l5x.htm"><b>IParseDisplayName::ParseDisplayName</b></a>.</p>
<h4>Remarks</h4>
<p>
The <b>MkParseDisplayName</b> function parses a human-readable name into a moniker that can be used to identify a link source. The resulting moniker can be a simple moniker (such as a file moniker), or it can be a generic composite made up of the component moniker pieces. For example, the following display name:</p>
<pre><code>"c:\mydir\somefile!item 1" 
 </code></pre>
<p>
could be parsed into the following generic composite moniker:</p>
<pre><code>(FileMoniker based on "c:\mydir\somefile") + (ItemMoniker based on "item 1") 
 </code></pre>
<p>
The most common use of <b>MkParseDisplayName</b> is in the implementation of the standard Links dialog box, which allows an end user to specify the source of a linked object by typing in a string. You may also need to call <b>MkParseDisplayName</b> if your application supports a macro language that permits remote references (reference to elements outside of the document). </p>
<p>
Parsing a display name often requires activating the same objects that would be activated during a binding operation, so it can be just as expensive (in terms of performance) as binding. Objects that are bound during the parsing operation are cached in the bind context passed to the function. If you plan to bind the moniker returned by <b>MkParseDisplayName</b>, it is best to do so immediately after the function returns, using the same bind context, which removes the need to activate objects a second time. </p>
<p>
<b>MkParseDisplayName</b> parses as much of the display name as it understands into a moniker. The function then calls <a href="if_f2n_6ecl.htm"><b>IMoniker::ParseDisplayName</b></a> on the newly created moniker, passing the remainder of the display name. The moniker returned by <b>IMoniker::ParseDisplayName</b> is composed onto the end of the existing moniker and, if any of the display name remains unparsed, <b>IMoniker::ParseDisplayName</b> is called on the result of the composition. This process is repeated until the entire display name has been parsed. </p>
<p>
The<b> MkParseDisplayName</b> function attempts the following strategies to parse the beginning of the display name, using the first one that succeeds: 
<ol>
<li>
The function looks in the Running Object Table for file monikers corresponding to all prefixes of <i>szDisplayName</i> that consist solely of valid file name characters. This strategy can identify documents that are as yet unsaved.</li>
<li>
The function checks the maximal prefix of <i>szDisplayName</i>, which consists solely of valid file name characters, to see if an OLE 1 document is registered by that name (this may require some DDE broadcasts). In this case, the returned moniker is an internal moniker provided by the OLE 1 compatibility layer of OLE 2.</li>
<li>
The function consults the file system to check whether a prefix of <i>szDisplayName</i> matches an existing file. The file name can be drive-absolute, drive-relative, working-directory relative, or begin with an explicit network share name. This is the common case.</li>
<li>
If the initial character of <i>szDisplayName</i> is an '@', the function finds the longest string immediately following it that conforms to the legal ProgID syntax. The function converts this string to a CLSID using the <a href="api1_51gk.htm"><b>CLSIDFromProgID</b></a> function. If the CLSID represents an OLE 2 class, the function loads the corresponding class object and asks for an <a href="if_p2q_4t5x.htm"><b>IParseDisplayName</b></a> interface pointer. The resulting <b>IParseDisplayName</b> interface is then given the whole string to parse, starting with the '@'. If the CLSID represents an OLE 1 class, then the function treats the string following the ProgID as an OLE1/DDE link designator having &lt;<i>filename</i>&gt;!&lt;<i>item</i>&gt; syntax. </li>
</ol>
<h4>QuickInfo</h4>
<p>
<b>&nbsp;&nbsp;Windows NT: </b>Use version 3.1 or later.<br>
<b>&nbsp;&nbsp;Windows: </b>Use Windows 95 or later.<br>
<b>&nbsp;&nbsp;Windows CE: </b>Unsupported.<br>
<b>&nbsp;&nbsp;Header: </b>Declared in objbase.h.<br>
<b>&nbsp;&nbsp;Import Library: </b>Included as a resource in ole32.dll.</p>
<h4>See Also</h4>
<p>
<a href="if_f2n_6ecl.htm"><b>IMoniker::ParseDisplayName</b></a>, <a href="if_f2n_1tb9.htm"><b>IMoniker::GetDisplayName</b></a>, <a href="if_p2q_4t5x.htm"><b>IParseDisplayName</b></a> </p>
<p>
</p>
<p>
</p>
<p>&nbsp;</p></body>
</HTML>
