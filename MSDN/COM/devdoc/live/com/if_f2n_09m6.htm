<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>IMoniker - Generic Composite Moniker Implementation</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_com_imoniker_generic_composite_moniker_implementation"></a>IMoniker - Generic Composite Moniker Implementation</h1>
<p>
A generic composite moniker is a composite moniker whose components have no special knowledge of each other. </p>
<p>
Composition is the process of joining two monikers together. Sometimes two monikers of specific classes can be combined in a special manner; for example, a file moniker representing an incomplete path and another file moniker representing a relative path can be combined to form a single file moniker representing the complete path. This is an example of "non-generic" composition. "Generic" composition, on the other hand, can connect any two monikers, no matter what their classes. Because a non-generic composition depends on the class of the monikers involved, it can be performed only by a particular class's implementation of the <a href="if_f2n_8cx4.htm"><b>IMoniker::ComposeWith</b></a> method. You can define new types of non-generic compositions if you write a new moniker class. By contrast, generic compositions are performed by the <a href="api2_4zc5.htm"><b>CreateGenericComposite</b></a> function. </p>
<h5>When to Use</h5>
<p>
If you're a moniker client (that is, you're using a moniker to get an interface pointer to an object), you typically don't need to know the class of the moniker you're using, or whether it is a generic composite or a non-generic composite; you simply call methods using an <a href="if_f2n_8otu.htm"><b>IMoniker</b></a> interface pointer. </p>
<p>
If you're a moniker provider (that is, you're handing out monikers that identify your objects to make them accessible to moniker clients), you may have to compose two monikers together. (For example, if you are using an item moniker to identify an object, you must compose it with the moniker identifying the object's container before you hand it out.) You use the <a href="if_f2n_8cx4.htm"><b>IMoniker::ComposeWith</b></a> method to do this, calling the method on the first moniker and passing the second moniker as a parameter; this method may produce either a generic or a non-generic composite. </p>
<p>
The only time you should explicitly create a generic composite moniker is if you are writing your own moniker class. In your implementation of <b>IMoniker::ComposeWith</b>, you should attempt to perform a non-generic composition whenever possible; if you cannot perform a non-generic composition and generic composition is acceptable, you can call the <a href="api2_4zc5.htm"><b>CreateGenericComposite</b></a> function to create a generic composite moniker. </p>
<h4>Remarks</h4>
<dl>
<dt>
<a href="if_f2n_7o6s.htm"><b>IMoniker::BindToObject</b></a> </dt>
<dd>
If <i>pmkToLeft</i> is NULL, this method looks for the moniker in the ROT, and if found, queries the retrieved object for the requested interface pointer. If <i>pmkToLeft</i> is not NULL, the method recursively calls <a href="if_f2n_7o6s.htm"><b>IMoniker::BindToObject</b></a> on the rightmost component of the composite, passing the rest of the composite as the <i>pmkToLeft</i> parameter for that call.</dd>
<dt>
<a href="if_f2n_1kx1.htm"><b>IMoniker::BindToStorage</b></a> </dt>
<dd>
This method recursively calls <b>BindToStorage</b> on the rightmost component of the composite, passing the rest of the composite as the <i>pmkToLeft</i> parameter for that call. </dd>
<dt>
<a href="if_f2n_79d1.htm"><b>IMoniker::Reduce</b></a> </dt>
<dd>
This method recursively calls <b>Reduce</b> for each of its component monikers. If any of the components reduces itself, the method returns S_OK and passes back a composite of the reduced components. If no reduction occurred, the method passes back the same moniker and returns MK_S_REDUCED_TO_SELF.</dd>
<dt>
<a href="if_f2n_8cx4.htm"><b>IMoniker::ComposeWith</b></a> </dt>
<dd>
If <i>fOnlyIfNotGeneric</i> is TRUE, this method sets *<i>pmkComposite</i> to NULL and returns MK_E_NEEDGENERIC; otherwise, the method returns the result of combining the two monikers by calling the <a href="api2_4zc5.htm"><b>CreateGenericComposite</b></a> function.</dd>
<dt>
<a href="if_f2n_44od.htm"><b>IMoniker::Enum</b></a> </dt>
<dd>
If successful, this method returns S_OK and passes back an enumerator that enumerates the component monikers that make up the composite; otherwise, the method returns E_OUTOFMEMORY. </dd>
<dt>
<a href="if_f2n_7mp8.htm"><b>IMoniker::IsEqual</b></a> </dt>
<dd>
This method returns S_OK if the components of both monikers are equal when compared in the left-to-right order.</dd>
<dt>
<a href="if_f2n_9uaw.htm"><b>IMoniker::Hash</b></a> </dt>
<dd>
This method calculates a hash value for the moniker.</dd>
<dt>
<a href="if_f2n_62g7.htm"><b>IMoniker::IsRunning</b></a> </dt>
<dd>
If <i>pmkToLeft</i> is non-NULL, this method composes <i>pmkToLeft</i> with this moniker and calls <b>IsRunning</b> on the result.
<p>
If <i>pmkToLeft</i> is NULL, this method returns TRUE if <i>pmkNewlyRunning</i> is non-NULL and is equal to this moniker.

<p>
If <i>pmkToLeft</i> and <i>pmkNewlyRunning</i> are both NULL, this method checks the ROT to see whether the moniker is running. If so, the method returns S_OK; otherwise, it recursively calls <a href="if_f2n_62g7.htm"><b>IMoniker::IsRunning</b></a> on the rightmost component of the composite, passing the remainder of the composite as the <i>pmkToLeft</i> parameter for that call. This handles the case where the moniker identifies a pseudo-object that is not registered as running; see the Item Moniker implementation of <b>IMoniker::IsRunning</b>.
</dd>
<dt>
<a href="if_f2n_0k9x.htm"><b>IMoniker::GetTimeOfLastChange</b></a> </dt>
<dd>
This method creates a composite of <i>pmkToLeft</i> (if non-NULL) and this moniker and uses the ROT to retrieve the time of last change. If the object is not in the ROT, the method recursively calls <a href="if_f2n_0k9x.htm"><b>IMoniker::GetTimeOfLastChange</b></a> on the rightmost component of the composite, passing the remainder of the composite as the <i>pmkToLeft</i> parameter for that call. </dd>
<dt>
<a href="if_f2n_2zvp.htm"><b>IMoniker::Inverse</b></a> </dt>
<dd>
This method returns a composite moniker that consists of the inverses of each of the components of the original composite, stored in reverse order. For example, if the inverse of <i>A</i> is <i>A  (-1) </i>, then the inverse of the composite <i>A</i>  (&deg;)  <i>B</i>  (&deg;)  <i>C</i> is <i>C</i> <i> (-1) </i>  (&deg;)  <i>B&nbsp; (-1) </i>  (&deg;)  <i>A</i> <i> (-1) </i>.</dd>
<dt>
<a href="if_f2n_9nu0.htm"><b>IMoniker::CommonPrefixWith</b></a> </dt>
<dd>
If the other moniker is a composite, this method compares the components of each composite from left to right. The returned common prefix moniker might also be a composite moniker, depending on how many of the leftmost components were common to both monikers. If the other moniker is not a composite, the method simply compares it to the leftmost component of this moniker. 
<p>
If the monikers are equal, the method returns MK_S_US and sets <i>ppmkPrefix</i> to this moniker. If the other moniker is a prefix of this moniker, the method returns MK_S_HIM and sets <i>ppmkPrefix</i> to the other moniker. If this moniker is a prefix of the other, this method returns MK_S_ME and sets <i>ppmkPrefix</i> to this moniker.

<p>
If there is no common prefix, this method returns MK_E_NOPREFIX and sets <i>ppmkPrefix</i> to NULL.
</dd>
<dt>
<a href="if_f2n_30j3.htm"><b>IMoniker::RelativePathTo</b></a> </dt>
<dd>
This method finds the common prefix of the two monikers and creates two monikers that consist of the remainder when the common prefix is removed. Then it creates the inverse for the remainder of this moniker and composes the remainder of the other moniker on the right of it.</dd>
<dt>
<a href="if_f2n_1tb9.htm"><b>IMoniker::GetDisplayName</b></a> </dt>
<dd>
This method returns the concatenation of the display names returned by each component moniker of the composite.</dd>
<dt>
<a href="if_f2n_6ecl.htm"><b>IMoniker::ParseDisplayName</b></a> </dt>
<dd>
This method recursively calls <a href="if_f2n_6ecl.htm"><b>IMoniker::ParseDisplayName</b></a> on the rightmost component of the composite, passing everything else as the <i>pmkToLeft</i> parameter for that call.</dd>
<dt>
<a href="if_f2n_4mr6.htm"><b>IMoniker::IsSystemMoniker</b></a> </dt>
<dd>
This method returns S_OK and indicates MKSYS_GENERICCOMPOSITE.</dd>
</dl>
<h4>See Also</h4>
<p>
<a href="api2_4zc5.htm"><b>CreateGenericComposite</b></a>, <a href="if_f2n_8otu.htm"><b>IMoniker</b></a> </p>
<p>
</p>
<p>
</p>
<p>&nbsp;</p></body>
</HTML>
