<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Working with OLE 1 Clients</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_ole_working_with_ole_1_clients"></a>Working with OLE 1 Clients</h1>
<p>
This section describes some of the idiosyncrasies of working with OLE 1 clients.</p>
<p>
A successful call to the <a href="if_o_44vm.htm"><b>IOleClientSite::GetContainer</b></a> method returns a pointer to the container's <a href="if_o_4ysy.htm"><b>IOleContainer</b></a> interface. If the container does not support the <b>IOleContainer</b> interface, OLE_E_NOT_SUPPORTED is returned. All OLE 1 clients fall in this category, as do OLE 2 containers that do not support linking to their embedded objects.</p>
<p>
The <a href="if_o_1xv8.htm"><b>IOleClientSite::ShowObject</b></a> method, a request to make the embedded or linked object visible, always<b> </b>returns OLE_E_NOT_SUPPORTED when called on an OLE 1 client<b>.</b> The purpose of this method is to help make the user model work smoothly; its failure does not effect OLE functionality.</p>
<p>
When an OLE 1 client contains an OLE 2 object and the object is activated or the <b>OleUpdate</b> function is called, the aspect of the data returned will always be DVASPECT_CONTENT. This is because OLE 1 clients have no concept of a <a href="structs_14v7.htm"><b>FORMATETC</b></a> data structure. This situation may occur when an iconic OLE 2 object is pasted from an OLE 2 container into an OLE 1 container. When the object is first pasted, its presentation remains iconic. With the next update, however, the object's content picture is returned.</p>
<p>
OLE 1 clients can link to OLE 2 objects only if the link source:
<ul>
<li>
is represented by a file moniker or a generic composite moniker consisting of a file moniker and one item moniker.</li>
<li>
is not an embedded OLE 2 object.</li>
</ul>
<p>
An OLE 1 client can contain an incompatible link when a linked object is pasted from an OLE 2 container into the OLE 1 client or when an OLE 2 container saves the data to an OLE 1 file, to allow the OLE 1 version of the application access to its data. When the OLE 1 client loads the incompatible link, the link is converted to an embedded object and assigned the class name "Ole2Link." The OLE 1 client cannot connect to the link source. However, if the newly embedded object is then pasted into an OLE 2 container using the Clipboard, or converted to an OLE 2 object using the <a href="api3_5xk5.htm"><b>OleConvertOLESTREAMToIStorage</b></a> function, it will be converted back to its original state as an OLE 2 linked object.</p>
<p>
When the link source for an OLE 1 linked object changes its name, the link can remain intact only if the file moniker for the link source has changed. That is, if the link source is a range of cells within an OLE 2 spreadsheet application and the name of the file that contains the cell range changes, OLE will track the link. However, if the name of the cell range changes, the link will break.</p>
<p>
Pasting an OLE 2 linked object into an OLE 1 client document and then calling the <b>OleCopyFromLink</b> function to convert it to an embedded object will fail if the data transfer object provided by the link source does not support the <a href="if_p2q_8crp.htm"><b>IPersistStorage</b></a> interface. Creating an embedded object always requires native data, and the <b>IPersistStorage</b> interface provides access to native data.</p>
<p>&nbsp;</p></body>
</HTML>
