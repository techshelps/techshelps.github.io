<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Cooperative and Asynchronous Data Retrieval</TITLE>

<META NAME=MS-HKWD CONTENT="Cooperative and Asynchronous Data Retrieval">
<META NAME="Keywords" CONTENT="Component Development">
<META NAME="Platform" CONTENT="Windows, Win95, WinNT">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=iso8859-1">
<META NAME="MS.LOCALE" CONTENT="EN-US">
<META NAME="ROBOTS" CONTENT="all">


<SCRIPT>
//<!--
var g_isIE = false, g_isNav = false, g_iMaj = 0, g_sPlat = "";
// -->
</SCRIPT>
<SCRIPT SRC="../../code/ver.js"></SCRIPT>


<SCRIPT DEFER SRC="../../code/common.js"></SCRIPT>
<SCRIPT DEFER>
//<!--
function InitPage()
{
	if (g_isIE && g_iMaj >= 4)	
	{
		SetTOC();
	}
}
//-->
</SCRIPT>

<LINK REL="stylesheet" HREF="/msdn/sdk/inetsdk/help/basicsdkIE4.css" TYPE="text/css">
<!-- STYLE_START -->


<SCRIPT>
//<!--
   var sVR = '../../'	// Set root for the style sheet
   var sCSS = '<LINK REL="stylesheet" HREF="' + sVR;

   if(g_isIE)
   {
	   if (g_iMaj >= 4) // For MSIE 4.0 or later
	   {
		   sCSS += 'basicSDKIE4';
		   if (g_sPlat == "Win") // Windows only for now
		   {
			   document.createStyleSheet(sVR + 'advSDKIE4.css');
		   }
	   }
	   else // For MSIE 3.0 or earlier
	   {
		   sCSS += 'basicSDKIE3';
	   }
   }
   else if (g_isNav) // For all Nav versions
   {
	   sCSS += 'basicSDKNAV';
   }
   else
   {
	   sCSS += 'basicSDKIE3'; // default to IE3 sheet
   }

   sCSS += (sCSS == '' ? '' : '.css" TYPE="text/css">');

   document.write(sCSS);
//-->
</SCRIPT>
<!-- STYLE_END -->
</HEAD>
<BODY onload="InitPage()" BGCOLOR="#FFFFFF">

<A NAME="pagetop"></A><A NAME="comobj_data_retrieval"></A>
<!-- NAV_LINKS_START -->
<TABLE class=main BORDER=0 CELLSPACING="0" CELLPADDING="0" WIDTH="10%"><TR><TD ROWSPAN="3" VALIGN="TOP" WIDTH="121"><IMG SRC="../../art/headbar2.gif" WIDTH="121" HEIGHT="82" BORDER=0 ALT="Cooperative and Asynchronous Data Retrieval"></TD><TD ROWSPAN="2" VALIGN="TOP" WIDTH="186"><IMG SRC="../../art/headbarc.gif" WIDTH="186" HEIGHT="44" BORDER=0 ALT="Cooperative and Asynchronous Data Retrieval"></TD><TD VALIGN="TOP" WIDTH="470"><IMG SRC="../../art/replace1.gif" WIDTH="470" HEIGHT="17" BORDER=0 ALT="*"></TD></TR><TR><TD><PRE><IMG SRC="../../art/arrowrht.gif" WIDTH="14" HEIGHT="14" ALIGN="MIDDLE" BORDER=0 ALT="*"><object id="hhal_1" type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Item1" value="">
<PARAM name="Item2" value=_win32_Contents>
</object><A STYLE="color:black" ID=TOC HREF=JavaScript:hhal_1.Click()>Contents</A>  <IMG SRC="../../art/arrowrht.gif" WIDTH="14" HEIGHT="14" ALIGN="MIDDLE" BORDER=0 ALT="*"><object id="hhal_2" type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Item1" value="">
<PARAM name="Item2" value=_win32_Index_1sz1>
</object><A STYLE="color:black" HREF=JavaScript:hhal_2.Click()>Index</A>  <IMG SRC="../../art/arrowrht.gif" WIDTH="14" HEIGHT="14" ALIGN="MIDDLE" BORDER=0 ALT="*"><object id="hhal_3" type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Item1" value="">
<PARAM name="Item2" value=_win32_COM_Objects_for_the_Internet>
</object><A STYLE="color:black" HREF=JavaScript:hhal_3.Click()>Topic Contents</A>
</PRE></TD></TR>
<TR><TD COLSPAN="2"><PRE><IMG SRC="../../art/arrowlft.gif" WIDTH="17" HEIGHT="15" ALIGN="MIDDLE" BORDER=0 ALT="*"><B>Previous Topic:</B> <A STYLE="color:black" HREF="prog_retrieval.htm">Data Path Properties</A>
<IMG SRC="../../art/arrownxt.gif" WIDTH="17" HEIGHT="16" ALIGN="MIDDLE" BORDER=0 ALT="*"><B>Next Topic:</B> <A  STYLE="color:black" HREF="ctl_readiness.htm">Communicating Control &quot;Readiness&quot;</A>
</PRE></TD></TR>
</TABLE>
<!-- NAV_LINKS_END -->
<BLOCKQUOTE class="body">
<!-- CONTENTS_START -->
<h1>Cooperative and Asynchronous Data Retrieval</h1>

<P>Once a control has a moniker for a data path property, it will eventually want to call that moniker's
<object id="hhal_4" type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Item1" value="">
<PARAM name="Item2" value=_win32_Further_Reading>
</object><A HREF=JavaScript:hhal_4.Click()>IMoniker::BindToStorage</A> to retrieve an interface pointer through which the control can retrieve data (or write it as described in the next section).

<P>To deliver optimal quality of service to browser users, a control must read data from an external source in a cooperative manner as much as possible. That is to say, the control should support reading linked data in an asynchronous manner, paying attention to container prioritization and allowing the container to participate in the transfer as it wants. To provide the container with authority over the binding operation, the control should use the <A HREF="reference/IBindHost_MonikerBindToStorage.htm#IBindHost::MonikerBindToStorage">IBindHost::MonikerBindToStorage</A> and <A HREF="reference/IBindHost_MonikerBindToObject.htm#IBindHost::MonikerBindToObject">IBindHost::MonikerBindToObject</A> member functions to bind to any moniker.

<P>A control will first, of course, check whether the moniker it obtained from the container is, in fact, an asynchronous moniker at all by querying it for <B>IMonikerAsync</B> (see <B>Asynchronous Monikers</B>, which specified this interface as an alias for
<object id="hhal_5" type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Item1" value="">
<PARAM name="Item2" value=_win32_Further_Reading>
</object><A HREF=JavaScript:hhal_5.Click()>IUnknown</A>). If this interface is not present, the moniker is synchronous and the control does not need to create an
<object id="hhal_6" type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Item1" value="">
<PARAM name="Item2" value=_win32_IBindStatusCallback>
</object><A HREF=JavaScript:hhal_6.Click()>IBindStatusCallback</A> callback interface to receive asynchronous notifications from the moniker bind operaion.

<P>If the moniker is asynchronous, the control operates as any other client of such a moniker does, by creating an
<object id="hhal_7" type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Item1" value="">
<PARAM name="Item2" value=_win32_IBindStatusCallback>
</object><A HREF=JavaScript:hhal_7.Click()>IBindStatusCallback</A> callback interface for asynchronous download, as described in the document <B>Asynchronous Moniker</B>. The specific requirement for a control is that instead of binding to its moniker directly, it should bind to the moniker through its container, through <A HREF="reference/IBindHost_MonikerBindToStorage.htm#IBindHost::MonikerBindToStorage">IBindHost::MonikerBindToStorage</A> or <A HREF="reference/IBindHost_MonikerBindToObject.htm#IBindHost::MonikerBindToObject">IBindHost::MonikerBindToObject</A>. This call gives the container a chance to register any callbacks or other bits in the bind operation as desired. For example, a container that wishes to watch the progress of the transfer through
<object id="hhal_8" type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Item1" value="">
<PARAM name="Item2" value=_win32_IBindStatusCallback_OnProgress>
</object><A HREF=JavaScript:hhal_8.Click()>IBindStatusCallback::OnProgress</A> will register its own callback for the bind operation, paying attention to <B>OnProgress</B> callbacks and delegating all other callbacks to the control that initiated the bind operation.

<P>If the container does not implement <A HREF="reference/IBindHost.htm#IBindHost">IBindHost</A>, the control can always bind to its moniker(s) directly through
<object id="hhal_9" type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Item1" value="">
<PARAM name="Item2" value=_win32_Further_Reading>
</object><A HREF=JavaScript:hhal_9.Click()>IMoniker::BindToStorage</A> and
<object id="hhal_10" type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Item1" value="">
<PARAM name="Item2" value=_win32_Further_Reading>
</object><A HREF=JavaScript:hhal_10.Click()>IMoniker::BindToObject</A>. These should only be used in degenerate cases when there is no <B>IBindHost</B> present.

<P>A control passes its
<object id="hhal_11" type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Item1" value="">
<PARAM name="Item2" value=_win32_IBindStatusCallback>
</object><A HREF=JavaScript:hhal_11.Click()>IBindStatusCallback</A> to its container directly through <B>IBindHost::BindToXXX</B>. However, if the control wishes to participate in format negotiation (for example, HTTP), it must create a bind context and register its FORMATETC enumerator on this bind context before calling <B>IBindHost::BindToXXX</B>. When a control initiates an asynchronous transfer for a data path, usually within
<object id="hhal_12" type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Item1" value="">
<PARAM name="Item2" value=_win32_Further_Reading>
</object><A HREF=JavaScript:hhal_12.Click()>IPersist*::Load</A>, it should always obtain the data through
<object id="hhal_13" type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Item1" value="">
<PARAM name="Item2" value=_win32_IBindStatusCallback_OnDataAvailable>
</object><A HREF=JavaScript:hhal_13.Click()>IBindStatusCallback::OnDataAvailable</A> exclusively. This is so the control can immediately release the moniker and the bind context and return immediately from <B>IPersist*::Load</B> so that the container can continue processing. Such code inside <B>IPersistStreamInit::Load</B> where another asynchronous stream is obtained, for example, would appear as follows:

<PRE>
HRESULT CImpIPersistStream::Load(IStream *pstm)
   {
    IMoniker *pmkPath;
    IStream  *pstmAsync;
    IBindCtx *pbc;

    /* 
     * Load properties with pstm-&gt;Read, which is either blocking or synchronous.
     * Assume that one property is a path moniker, which we re-create with
     * OleLoadFromStream into pmkPath.
     *
     * Also, assume that m_pbsc is our IBindStatusCallback implementation, and
     * m_pEnumFE is our FORMATETC enumerator.
     */

    //pIBindHost is a pointer to the container's IbindHost.
&#009;CreateAsyncBindCtx(0, NULL, m_pEnumFE, &amp;pbc);
&#009;pIBindHost-&gt;MonikerBindToStorage(pmkPath, pbc, m_pbsc, IID_IStream, &amp;pstmAsync);


    //Do this only for async monikers.
    if (NULL!=pstm)
        pstmAsync-&gt;Release();

    pbc-&gt;Release();
    pmkPath-&gt;Release();

    //Data shows up in IBindStatusCallback::OnDataAvailable.

    return S_OK;
    }
</PRE>

<P>When retrieving data, the path moniker that names the external storage location is either synchronous or asynchronous. If the moniker used in binding is a synchronous moniker, read calls from the control will effectively block the execution thread as is expected&#151;this is how the OLE programming model already works with regards to moniker binding.

<P>Of course, an object that does not want to block and can return E_PENDING as necessary from some of its interface members (see below) may elect to perform the otherwise blocking read operations in another thread, thereby allowing the original thread to continue. This still allows
<object id="hhal_14" type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Item1" value="">
<PARAM name="Item2" value=_win32_Further_Reading>
</object><A HREF=JavaScript:hhal_14.Click()>IPersist*::Load</A> to return right away without waiting for the data to arrive.

<P>The tricky part in handling asynchronous data is communicating the control's "readiness" state (including E_PENDING return codes). These topics are covered in later in this document.


<h2><A NAME="Aborting_a_Data_Tran">Aborting a Data Transfer</A></h2>

<P>Any control that is currently reading or writing data in an asynchronous manner must pay attention to
<object id="hhal_15" type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Item1" value="">
<PARAM name="Item2" value=_win32_IBindStatusCallback_OnStopBinding>
</object><A HREF=JavaScript:hhal_15.Click()>IBindStatusCallback::OnStopBinding</A>. If the control has all its data already, this notification merely says that the transfer is complete. If the control has not received all its data, the transfer was aborted for some other reason&#151;perhaps the container scrolled the object out of view and stopped the transfers itself.

<P>The control itself can call
<object id="hhal_16" type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Item1" value="">
<PARAM name="Item2" value=_win32_IBinding_Abort>
</object><A HREF=JavaScript:hhal_16.Click()>IBinding::Abort</A> if it needs to stop the transfer for some reason. The control receives the
<object id="hhal_17" type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Item1" value="">
<PARAM name="Item2" value=_win32_IBinding>
</object><A HREF=JavaScript:hhal_17.Click()>IBinding</A> pointer through
<object id="hhal_18" type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Item1" value="">
<PARAM name="Item2" value=_win32_IBindStatusCallback_OnStartBinding>
</object><A HREF=JavaScript:hhal_18.Click()>IBindStatusCallback::OnStartBinding</A> and must save it for later use. One such use is for handling the case where a container destroys a control while a transfer is underway&#151;the control has to stop the transfer as part of its destruction procedure.

<P>Also, if a container or authoring tool assigns a new value to a path property while the control is currently retrieving data asynchronously for that path, the control must stop the transfer through
<object id="hhal_19" type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Item1" value="">
<PARAM name="Item2" value=_win32_IBinding_Abort>
</object><A HREF=JavaScript:hhal_19.Click()>IBinding::Abort</A> as soon as is reasonable and save the new path value.

<P>Because a control cannot predict exactly how and when one or more data transfers will be aborted, it must be careful where reentrancy is concerned, especially inside the implementation of
<object id="hhal_20" type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Item1" value="">
<PARAM name="Item2" value=_win32_IBindStatusCallback_OnStopBinding>
</object><A HREF=JavaScript:hhal_20.Click()>IBindStatusCallback::OnStopBinding</A> (but in all other members as well). That is, the control should maintain an internal state machine to protect itself from operations that occur during or after an aborted transfer.


<h3><A NAME="Transfer_Priority">Transfer Priority</A></h3>

<P>As the container owns the "document" as a whole, the container establishes which control will be given the right to transfer data first, second, and so on. When multiple transfers are going on at the same time, a container can control the relative priority of each transfer through its own implementations of
<object id="hhal_21" type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Item1" value="">
<PARAM name="Item2" value=_win32_IBindStatusCallback>
</object><A HREF=JavaScript:hhal_21.Click()>IBindStatusCallback</A>, which are used to control each bind operation (as managed through <B>IBindHost::MonikerBindToXXX</B>). A container can establish its desired relative priority in
<object id="hhal_22" type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Item1" value="">
<PARAM name="Item2" value=_win32_IBindStatusCallback_GetPriority>
</object><A HREF=JavaScript:hhal_22.Click()>IBindStatusCallback::GetPriority</A>. Once the transfer begins and the callbacks receive
<object id="hhal_23" type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Item1" value="">
<PARAM name="Item2" value=_win32_IBindStatusCallback_OnStartBinding>
</object><A HREF=JavaScript:hhal_23.Click()>IBindStatusCallback::OnStartBinding</A>, the container will have the
<object id="hhal_24" type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Item1" value="">
<PARAM name="Item2" value=_win32_IBinding>
</object><A HREF=JavaScript:hhal_24.Click()>IBinding</A> interface through which it can set the priority there as well. Controls should not interfere with this process. 

<h3><A NAME="Controls_that_use_Wi">Controls that use WinINet or Sockets Directly</A></h3>

<P>There are a certain class of controls that may want to bypass the mechanisms of the URL moniker to retrieve bits for some data path directly from the network through a transport layer like WinInet or Sockets. In such cases, the control is not willing to call <A HREF="reference/IBindHost_MonikerBindToStorage.htm#IBindHost::MonikerBindToStorage">IBindHost::MonikerBindToStorage</A>, but instead wants to use the absolute URL directly.

<P>To accomplish this, the control still asks the container for the full moniker in the first place because this step is necessary to resolve any relative path names. Once the control has the moniker, it can retrieve the full URL simply by calling
<object id="hhal_25" type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Item1" value="">
<PARAM name="Item2" value=_win32_Further_Reading>
</object><A HREF=JavaScript:hhal_25.Click()>IMoniker::GetDisplayName</A>.


<h2><A NAME="Object_Persistence_a">Object Persistence and Path Properties</A></h2>

<P>When a control is asked to save its persistent data through some
<object id="hhal_26" type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Item1" value="">
<PARAM name="Item2" value=_win32_Further_Reading>
</object><A HREF=JavaScript:hhal_26.Click()>IPersist*::Save</A> call, it is being asked to save its properties, including its current path properties and the BLOBs in the locations specified with those path properties. That is, once the control has saved its properties into the storage appropriate for the
<object id="hhal_27" type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Item1" value="">
<PARAM name="Item2" value=_win32_Further_Reading>
</object><A HREF=JavaScript:hhal_27.Click()>IPersist*</A> interface in use, it also <B>synchronously</B> saves its BLOBs by obtaining the moniker for the path property from the container as described in a later section, calling
<object id="hhal_28" type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Item1" value="">
<PARAM name="Item2" value=_win32_Further_Reading>
</object><A HREF=JavaScript:hhal_28.Click()>IMoniker::BindToStorage</A> with the container's bind context, and writing data to the storage obtained earlier. When <B>IPersist*::Save</B> returns, the object has completely written any data it needed to save.



<P>A control should save its path property values as strings, not as monikers. In short, a control should simply save whatever values are assigned to its data path properties (as opposed to serializing any monikers that might have been created using these strings).


<h2><A NAME="Container_Flexibilit">Container Flexibility in Moniker Choice</A></h2>

<P>The discussion in the previous section made no stipulations as to what <I>class</I> of moniker must be assigned to any path property. This is intentional: a container can instruct a control to store its persistent data in any location of the container's choosing, as long as the container can create a path name that, when turned into a moniker, references the exact piece of storage that the control needs to load. In the case of creating a complex Web site, most of these monikers will be URL monikers. But there are many other moniker classes that can be used effectively, such as File monikers, generic composite monikers, or even custom monikers.

<P>This design, therefore, allows the container full flexibility in choosing storage locations, depending on the authoring state of the document. At author time, the container (generally at the author's request) may choose to keep the persistent data of all controls embedded in the document. In this case, the container merely passes each control a name identifying some location in the document or on the local file system, such as a single Item moniker or a File moniker. The container then provides the necessary binding support for whatever moniker it supplies through <A HREF="reference/IBindHost_CreateMoniker.htm#IBindHost::CreateMoniker">IBindHost::CreateMoniker</A>. In the case where the authoring tool has the data stored in the document itself, supplying a File Item moniker to the control means that the control's call to <A HREF="reference/IBindHost_MonikerBindToStorage.htm#IBindHost::MonikerBindToStorage">IBindHost::MonikerBindToStorage</A> returns very quickly.

<P>At publish time, the container may then choose to break whatever portions of control data it desires out of the document, saving that data in other locations and reassigning paths. Because the container will have some idea of the <I>size</I> of each control's persistent data, it may choose to leave some of that data embedded in the document anyway, leaving the controls concerned with simple File Item monikers (and such). If the container moves some data to other Web sites, it would create URL monikers for those sites and assign them the path properties of the appropriate controls. As far as the control is concerned, the data has moved, but the data is still named with some moniker. The control continues to use the same <A HREF="reference/IBindHost_MonikerBindToStorage.htm#IBindHost::MonikerBindToStorage">IBindHost::MonikerBindToStorage</A> code that it did before.

<P>What is important to understand here is that the control never has to distinguish between author-time and publish/run-time differences as far as its data path storage is concerned. The control always has some moniker naming its persistent data store(s), and always calls <A HREF="reference/IBindHost_MonikerBindToStorage.htm#IBindHost::MonikerBindToStorage">IBindHost::MonikerBindToStorage</A> in all circumstances. This maintains a single programming model across all document modes, while still giving the container complete flexibility in choose storage locations and how the data in the document is distributed.


<h2><A NAME="Exposing_Path_Proper">Exposing Path Properties from Nested Controls</A></h2>

<P>Some controls, regardless of whether they themselves use any path properties, may contain other nested controls that do use such paths. Nevertheless, an authoring tool will want to construct a list of all paths used by all controls, regardless of the level of nesting involved. This facilitates site management&#151;the authoring tool can examine all external data references from the top-level document and correct the paths involved if the site is being relocated.

<P>Any control that itself uses one or more path properties need only expose those properties as described in earlier sections. Those controls that themselves contain other controls must expose those nested controls so that an authoring tool can check the path properties in those controls as well.

<P>For this reason, a containing control must implement <B>IOleContainer</B> [note that the containing control might also choose to implement IOleItemContainer as well (which is derived from IOleContainer) to allow easier navigation to a particular control given the control's name] with the following behavior:

<TABLE>
<TR><TD><B>Member Function
 </B></TD><TD><B>Behavior
</B></TD></TR><TR><TD><B>Iunknown</B> members
 </TD><TD>Implemented as usual.
</TD></TR><TR><TD><B>ParseDisplayName</B>
 </TD><TD>Returns E_NOTIMPL.
</TD></TR><TR><TD><B>LockContainer</B>
 </TD><TD>Returns E_NOTIMPL.
</TD></TR><TR><TD><B>EnumObjects</B>
 </TD><TD>Returns an <B>IEnumUnknown</B> enumerator through which the caller can retrieve the
<object id="hhal_29" type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Item1" value="">
<PARAM name="Item2" value=_win32_Further_Reading>
</object><A HREF=JavaScript:hhal_29.Click()>IUnknown</A> pointers for each nested control.
</TD></TR></TABLE>

<P>Given this behavior, the top-level container or authoring tool that wishes to examine all path properties in all controls, regardless of the nesting level, uses <B>IProvideClassInfo::GetClassInfo</B> to retrieve the control's type information and then uses the same procedures described earlier to build a list of the control's dispIDs that each correspond to some data path property. The caller can retrieve this property value, examine it, and modify it as necessary. This procedure is summarized in the following pseudo-code:
<PRE>
//In top-level container
construct IEnumUnknown for all top-level controls in pEnum
FindAllPaths(pEnum)
//Done

function FindAllPaths(IEnumUnknown *pEnum)
    }
    IUnknown *pObj;

    while (SUCCEEDED(pEnum-&gt;Next(&amp;pObj)))
        {
        call IProvideClassInfo::GetClassInfo or obtain coclass type information via type lib

        if (SUCCEEDED(ITypeInfo2::GetCustData) and value is greater than zero)
            {
            iterate over properties
                {
                for each path property
                    {
                    examine the path
                    update/modify the path as necessary
                    }
                }

            ITypeInfo2::Release();
            }

        if (SUCCEEDED(pObj-&gt;QueryInterface(IID_IOleContainer, &amp;pCont)))
            {
            pCont-&gt;EnumObjects(&amp;pEnumNested)

            if (NULL!=pEnumNested)
                FindAllPaths(pEnumNested)

            pCont-&gt;Release();
            }

        pObj-&gt;Release();
        }
    }
</PRE>

<P>Through this process, the top-level container can examine all path properties in use in the document. It is unlikely that this will be a seriously expensive operation in all except the most complex documents. Typically, there will only be a handful of controls on a page with any path properties at all, and even fewer containing controls with a significant number of nested controls. Second, third, fourth, and deeper levels of nesting will be exceptionally rare, so implementing this scheme with a recursive code structure will not be expensive in probably ninety percent of all situations.

<P>What is described here for a containing control does not apply to controls that internally use some kind of helper object as a supporting component. In such cases, the helper object is not a "nested control"&#151;it is merely a provider of a useful service. The control that is using the helper should not consider itself a "containing control" because it does not implement the necessary container-side services that would be necessary to nest an actual control.


<!-- CONTENTS_END -->
<!-- START PAGE FOOTER -->
<H6><HR size=1></H6>
<P><A ID=line HREF="#pagetop"><IMG src="../../art/arrowup1.gif" WIDTH="17" HEIGHT="16" ALIGN="MIDDLE" BORDER="0" ALT="Up">&nbsp;Top of Page</A>
<BR><A ID=line HREF="http://www.microsoft.com/misc/cpyright.htm" TARGET="_top">&#169; 1997 Microsoft Corporation. All rights reserved. Terms of Use.</A>
<!-- END PAGE FOOTER -->
</BLOCKQUOTE>
</BODY>
</HTML>
