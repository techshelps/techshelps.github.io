<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Safe Initialization and Scripting for ActiveX Controls</TITLE>

<META NAME=MS-HKWD CONTENT="Safe Initialization and Scripting for ActiveX Controls">
<META NAME="Keywords" CONTENT="Component Development">
<META NAME="Platform" CONTENT="Windows, Win95, WinNT">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=iso8859-1">
<META NAME="MS.LOCALE" CONTENT="EN-US">
<META NAME="ROBOTS" CONTENT="all">


<SCRIPT>
//<!--
var g_isIE = false, g_isNav = false, g_iMaj = 0, g_sPlat = "";
// -->
</SCRIPT>
<SCRIPT SRC="../../code/ver.js"></SCRIPT>


<SCRIPT DEFER SRC="../../code/common.js"></SCRIPT>
<SCRIPT DEFER>
//<!--
function InitPage()
{
	if (g_isIE && g_iMaj >= 4)	
	{
		SetTOC();
	}
}
//-->
</SCRIPT>

<LINK REL="stylesheet" HREF="/msdn/sdk/inetsdk/help/basicsdkIE4.css" TYPE="text/css">
<!-- STYLE_START -->


<SCRIPT>
//<!--
   var sVR = '../../'	// Set root for the style sheet
   var sCSS = '<LINK REL="stylesheet" HREF="' + sVR;

   if(g_isIE)
   {
	   if (g_iMaj >= 4) // For MSIE 4.0 or later
	   {
		   sCSS += 'basicSDKIE4';
		   if (g_sPlat == "Win") // Windows only for now
		   {
			   document.createStyleSheet(sVR + 'advSDKIE4.css');
		   }
	   }
	   else // For MSIE 3.0 or earlier
	   {
		   sCSS += 'basicSDKIE3';
	   }
   }
   else if (g_isNav) // For all Nav versions
   {
	   sCSS += 'basicSDKNAV';
   }
   else
   {
	   sCSS += 'basicSDKIE3'; // default to IE3 sheet
   }

   sCSS += (sCSS == '' ? '' : '.css" TYPE="text/css">');

   document.write(sCSS);
//-->
</SCRIPT>
<!-- STYLE_END -->
</HEAD>
<BODY onload="InitPage()" BGCOLOR="#FFFFFF">

<A NAME="pagetop"></A><A NAME="ch_safety"></A>
<!-- NAV_LINKS_START -->
<TABLE class=main BORDER=0 CELLSPACING="0" CELLPADDING="0" WIDTH="10%"><TR><TD ROWSPAN="3" VALIGN="TOP" WIDTH="121"><IMG SRC="../../art/headbar2.gif" WIDTH="121" HEIGHT="82" BORDER=0 ALT="Safe Initialization and Scripting for ActiveX Controls"></TD><TD ROWSPAN="2" VALIGN="TOP" WIDTH="186"><IMG SRC="../../art/headbarc.gif" WIDTH="186" HEIGHT="44" BORDER=0 ALT="Safe Initialization and Scripting for ActiveX Controls"></TD><TD VALIGN="TOP" WIDTH="470"><IMG SRC="../../art/replace1.gif" WIDTH="470" HEIGHT="17" BORDER=0 ALT="*"></TD></TR><TR><TD><PRE><IMG SRC="../../art/arrowrht.gif" WIDTH="14" HEIGHT="14" ALIGN="MIDDLE" BORDER=0 ALT="*"><object id="hhal_1" type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Item1" value="">
<PARAM name="Item2" value=_win32_Contents>
</object><A STYLE="color:black" ID=TOC HREF=JavaScript:hhal_1.Click()>Contents</A>  <IMG SRC="../../art/arrowrht.gif" WIDTH="14" HEIGHT="14" ALIGN="MIDDLE" BORDER=0 ALT="*"><object id="hhal_2" type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Item1" value="">
<PARAM name="Item2" value=_win32_Index_1sz1>
</object><A STYLE="color:black" HREF=JavaScript:hhal_2.Click()>Index</A>  <IMG SRC="../../art/arrowrht.gif" WIDTH="14" HEIGHT="14" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black" HREF="controls.htm#bk_activex_controls">Topic Contents</A>
</PRE></TD></TR>
<TR><TD COLSPAN="2"><PRE><IMG SRC="../../art/arrowlft.gif" WIDTH="17" HEIGHT="15" ALIGN="MIDDLE" BORDER=0 ALT="*"><B>Previous Topic:</B> <A STYLE="color:black" HREF="tutorial.htm">ActiveX Control Tutorial</A>
<IMG SRC="../../art/arrownxt.gif" WIDTH="17" HEIGHT="16" ALIGN="MIDDLE" BORDER=0 ALT="*"><B>Next Topic:</B> <A  STYLE="color:black" HREF="safety/references.htm">Reference</A>
</PRE></TD></TR>
</TABLE>
<!-- NAV_LINKS_END -->
<BLOCKQUOTE class="body">
<!-- CONTENTS_START -->
<h1>Safe Initialization and Scripting for ActiveX Controls</h1>

<P>This document describes the code that a control developer should implement to ensure safe initialization and safe scripting for a Microsoft&#174; ActiveX&#153; control.


<P><A CLASS=tctop HREF="safety.htm#Introduction"><IMG SRC="../../art/arrowg.gif" WIDTH="6" HEIGHT="11" BORDER=0 ALT="arrowg.gif">Introduction</A><BR>

<P><A CLASS=tctop HREF="safety.htm#Internet_Explorer_3_"><IMG SRC="../../art/arrowg.gif" WIDTH="6" HEIGHT="11" BORDER=0 ALT="arrowg.gif">Internet Explorer 3.0 Security Levels</A><BR>

<P><A CLASS=tctop HREF="safety.htm#ov_init"><IMG SRC="../../art/arrowg.gif" WIDTH="6" HEIGHT="11" BORDER=0 ALT="arrowg.gif">Initialization Security</A><BR>

<P><A CLASS=tctop HREF="safety.htm#ov_script"><IMG SRC="../../art/arrowg.gif" WIDTH="6" HEIGHT="11" BORDER=0 ALT="arrowg.gif">Scripting Security</A><BR>

<P><A CLASS=tctop HREF="safety.htm#safe_cc"><IMG SRC="../../art/arrowg.gif" WIDTH="6" HEIGHT="11" BORDER=0 ALT="arrowg.gif">Using the Component Categories Manager</A><BR>

<P><A CLASS=tctop HREF="safety.htm#iobjsafe"><IMG SRC="../../art/arrowg.gif" WIDTH="6" HEIGHT="11" BORDER=0 ALT="arrowg.gif">Supporting the IObjectSafety Interface</A><BR>

<P><A CLASS=tctop HREF="safety/references.htm#ref_safety"><IMG SRC="../../art/arrowg.gif" WIDTH="6" HEIGHT="11" BORDER=0 ALT="arrowg.gif">Reference</A><BR>
<!--************************************************************--><h2><A NAME="Introduction">Introduction</A></h2>

<P>Many Microsoft&#174; ActiveX&#153; Controls are initialized with persistent data, which is either local or remote, and most ActiveX Controls are scriptable (they support a set of methods, events, and properties). Both initialization (with persistent data) and scripting require certain safeguards to ensure that security is not violated.

<P>An example of a control that poses a security risk at initialization time would be a data compression/decompression control. If the user pointed this control to a remote, compressed file that contained a Trojan-horse copy of a system file (such as Kernel.dll) and requested that the control decompress this file, system security could be breached.

<P>An example of a control that poses a security risk at scripting time would be a control that relies on certain system settings before a script can be safely executed. It would be up to the control developer to provide the necessary code that retrieves the system settings before allowing the script to execute.

<h2><A NAME="Internet_Explorer_3_">Internet Explorer 3.0 Security Levels</A></h2>
<P>Microsoft Internet Explorer 3.0 has three security levels: low, medium, and high. When the user attempts to display a page containing a control that does not guarantee safe initialization or scripting, Internet Explorer 3.0 does one of the following based on the current security level.

<TABLE>
<TR><TD><B>Security level</B></TD><TD><B>Internet Explorer 3.0 notification
</B></TD></TR>
<TR><TD>Low</TD><TD>No warnings. Controls can be initialized or scripted regardless of data source or scripts.
</TD></TR>
<TR><TD>Medium</TD><TD>User is warned of potential safety violation prior to loading the page. User can accept or reject initialization or scripting. If user disables scripting, scripting errors occur when user views the page and attempts to execute the script.
</TD></TR>
<TR><TD>High</TD><TD>User is warned of potential safety violation prior to loading the page. User cannot accept or reject initialization or scripting. Scripting errors occur if user attempts to view page and execute script.
</TD></TR>
</TABLE>

<P><B>Note</B>  Most control developers set their Internet Explorer 3.0 security level to low during the early stages of control development. However, prior to implementing the safe initialization and scripting code, security should be reset to high (the default setting) to ensure adequate testing of the control.
<h2><A NAME="ov_init">Initialization Security</A></h2>

<P>When a control is initialized, it can receive data from an arbitrary <B>IPersist*</B> interface (from either a local or a remote URL) for initializing its state. This is a potential security hazard because the data could come from an untrusted source. Controls that guarantee no security breach regardless of the data source are considered safe for initialization. 

<P>There are two methods for indicating that your control is safe for initialization. The first method uses the Component Categories Manager to create the appropriate entries in the system registry. Internet Explorer 3.0 examines the registry prior to loading your control to determine whether these entries appear. The second method implements an interface named <B>IObjectSafety</B> on your control. If Internet Explorer 3.0 determines that your control supports <B>IObjectSafety</B>, it calls the <A HREF="safety/SetInterfaceSafetyOptions.htm#SetInterfaceSafetyOptions">IObjectSafety::SetInterfaceSafetyOptions</A> method prior to loading your control in order to determine whether your control is safe for initialization.

<h2><A NAME="ov_script">Scripting Security</A></h2>

<P>Code signing can guarantee a user that code is trusted. However, allowing ActiveX Controls to be accessed from scripts raises several new security issues. Even if a control is known to be safe in the hands of a user, it is not necessarily safe when automated by an untrusted script. For example, Microsoft Word is a trusted tool from a reputable source, but a malicious script can use its automation model to delete files on the user's computer, install macro viruses, and worse.

<P>There are two methods for indicating that your control is safe for scripting. The first method uses the Component Categories Manager to create the appropriate entries in the system registry (when your control is loaded). Internet Explorer 3.0 examines the registry prior to loading your control to determine whether these entries appear. The second method implements the <B>IObjectSafety</B> interface on your control. If Internet Explorer 3.0 determines that your control supports <B>IObjectSafety</B>, it calls the <A HREF="safety/SetInterfaceSafetyOptions.htm#SetInterfaceSafetyOptions">IObjectSafety::SetInterfaceSafetyOptions</A> method prior to loading your control in order to determine whether your control is safe for scripting.

<h2><A NAME="safe_cc">Using the Component Categories Manager</A></h2>

<P>As mentioned previously, Internet Explorer 3.0 examines the system registry to determine whether a control is safe for initialization and/or scripting. Internet Explorer 3.0 examines the registry by calling the <B>ICatInformation::IsClassOfCategories</B> method to determine if the control supports the given category (safe for initializing or safe for scripting). 


<P>If a control uses the Component Categories Manager to register itself as being safe, the registry entry for that control contains an Implemented Categories key, which contains one or two subkeys. One subkey is set if the control supports safe initialization, and the other subkey is set if the control supports safe scripting. The safe initialization subkey corresponds to CATID_SafeForInitializing; the safe scripting subkey corresponds to CATID_SafeForScripting. (Unlike the other subkeys for the component categories that are defined in the Comcat.h file, the subkeys for safe initialization and scripting are defined in Objsafe.h.)

<P>The following illustration shows a snapshot of the registry entry for the
<object id="hhal_3" type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Item1" value="">
<PARAM name="Item2" value=_win32_Tabular_Data_Control_TDC_>
</object><A HREF=JavaScript:hhal_3.Click()>Tabular Data Control</A>, an ActiveX&#153; control that ships with Internet Explorer and allows authors to create
<object id="hhal_4" type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Item1" value="">
<PARAM name="Item2" value=_win32_Data_Binding>
</object><A HREF=JavaScript:hhal_4.Click()>data-driven Web pages</A>. Because the control is safe for scripting and initialization, it marks itself in the registry as safe for scripting (7DD95801-9882-11CF-9FA9-00AA006C42C4)and safe for initializing from persistent data (7DD95802-9882-11CF-9FA9-00AA006C42C4).

<P>

<P><IMG SRC="../../art/impl_cat.gif" WIDTH="569" HEIGHT="294" ALT="Registry entry for a control" >

<P>

<h3><A NAME="safety_ex">Registering a Control as Safe</A></h3>

<P>The system registry contains a Component Categories key that lists subkeys for each of the categories of functionality that are implemented or required by components and applications installed on the system. The following illustration shows a snapshot of the Component Categories key. Observe that the CATID_SafeForScripting (7DD95801-9882-11CF-9FA9-00AA006C42C4) and the CATID_SafeForInitializing (7DD95802-9882-11CF-9FA9-00AA006C42C4) are included in the list:

<P>

<P><IMG SRC="../../art/comp_cat.gif" WIDTH="633" HEIGHT="357" ALT="Component Categories key and subkeys" >

<P>

<P>To create the subkey for the appropriate component category, your control must complete the following steps:
<OL>
<LI>Create an instance of the Component Categories Manager and retrieve the address of the <B>ICatRegister</B> interface.
<LI>Set the appropriate members of a <B>CATEGORYINFO</B> structure.
<LI>Call the <B>ICatRegister::RegisterCategories</B> method, passing the address of the initialized <B>CATEGORYINFO</B> structure.
</OL>

<P>The following example shows how these steps were accomplished and combined into a single function named CreateComponentCategory in the sample control.

<PRE>#include "comcat.h"
HRESULT CreateComponentCategory(CATID catid, WCHAR* catDescription)
    {

    ICatRegister* pcr = NULL ;
    HRESULT hr = S_OK ;

    hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr, 
            NULL, CLSCTX_INPROC_SERVER, IID_ICatRegister, (void**)&amp;pcr);
    if (FAILED(hr))
        return hr;

    // Make sure the HKCR\Component Categories\{..catid...}
    // key is registered.
    CATEGORYINFO catinfo;
    catinfo.catid = catid;
    catinfo.lcid = 0x0409 ; // english

    // Make sure the provided description is not too long.
    // Only copy the first 127 characters if it is.
    int len = wcslen(catDescription);
    if (len&gt;127)
        len = 127;
    wcsncpy(catinfo.szDescription, catDescription, len);
        // Make sure the description is null terminated.
        catinfo.szDescription[len] = '\0';

    hr = pcr-&gt;RegisterCategories(1, &amp;catinfo);
        pcr-&gt;Release();

        return hr;
    }
</PRE>

<P>When a subkey has been created for the requisite category, the control should register the category as being implemented by the control. To register the category as being implemented, your control should complete these tasks:
<OL>
<LI>Create an instance of the Component Categories Manager and retrieve the address of the <B>ICatRegister</B> interface.
<LI>Call the
<object id="hhal_5" type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Item1" value="">
<PARAM name="Item2" value=_win32_Further_Reading>
</object><A HREF=JavaScript:hhal_5.Click()>ICatRegister::RegisterClassImplCategories</A> method, passing the control's CLSID and the requisite category ID as arguments.
</OL>

<P>The following example shows how these steps were accomplished and combined into a single function named RegisterCLSIDInCategory in the sample control.

<PRE>#include "comcat.h"
HRESULT RegisterCLSIDInCategory(REFCLSID clsid, CATID catid)
    {
// Register your component categories information.
    ICatRegister* pcr = NULL ;
    HRESULT hr = S_OK ;
    hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr, 
                NULL, CLSCTX_INPROC_SERVER, IID_ICatRegister, (void**)&amp;pcr);
    if (SUCCEEDED(hr))
    {
       // Register this category as being "implemented" by the class.
       CATID rgcatid[1] ;
       rgcatid[0] = catid;
       hr = pcr-&gt;RegisterClassImplCategories(clsid, 1, rgcatid);
    }

    if (pcr != NULL)
        pcr-&gt;Release();

        return hr;
        }
</PRE>

<P>A control should register the safe initialization and scripting categories when its <B>DLLRegisterServer</B> function is called. (<B>DLLRegisterServer</B> is called by the Component Object Model [COM] to create the registry entries for all classes supported by the control.) In the sample control, the <B>DLLRegisterServer</B> function contains calls to the CreateComponentCategory and RegisterCLSIDInCategory functions (which register the control as safe for initialization and scripting). The following implementation of <B>DLLRegisterServer</B> was taken from the sample control.

<PRE>STDAPI DllRegisterServer(void)
{
    HRESULT  hr;    // return for safety functions

    AFX_MANAGE_STATE(_afxModuleAddrThis);

    if (!AfxOleRegisterTypeLib(AfxGetInstanceHandle(), _tlid)) 
        return ResultFromScode(SELFREG_E_TYPELIB);

    if (!COleObjectFactoryEx::UpdateRegistryAll(TRUE))
        return ResultFromScode(SELFREG_E_CLASS);

    // Mark the control as safe for initializing.

    hr = CreateComponentCategory(CATID_SafeForInitializing, L"Controls 
        safely initializable from persistent data!");
    if (FAILED(hr))
        return hr;

    hr = RegisterCLSIDInCategory(CLSID_SafeItem, CATID_SafeForInitializing);
    if (FAILED(hr))
        return hr;

    // Mark the control as safe for scripting.

    hr = CreateComponentCategory(CATID_SafeForScripting, L"Controls 
        safely scriptable!");
    if (FAILED(hr))
        return hr;

    hr = RegisterCLSIDInCategory(CLSID_SafeItem, CATID_SafeForScripting);
    if (FAILED(hr))
        return hr;

    return NOERROR;
}
</PRE>

<P>Just as a control is responsible for creating the registry entries for all safety categories it supports, a control is also responsible for unregistering its categories. The COM calls a control's <B>DLLUnRegisterServer</B> function to remove appropriate registry entries before unloading the control.

<P>To unregister the safe initialization and/or safe scripting categories, the control should do the following:
<OL>
<LI>Create an instance of the Component Categories Manager and retrieve the address of the <B>ICatRegister</B> interface.
<LI>Call the <B>ICatRegister::UnRegisterClassImplCategories</B> method, passing the control's CLSID and the requisite category ID as arguments.
</OL>

<P>The following example shows how these steps were accomplished and combined into a single function named UnRegisterCLSIDInCategory in a sample control.

<PRE>HRESULT UnRegisterCLSIDInCategory(REFCLSID clsid, CATID catid)
    {
    ICatRegister* pcr = NULL ;
    HRESULT hr = S_OK ;

    hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr, 
            NULL, CLSCTX_INPROC_SERVER, IID_ICatRegister, (void**)&amp;pcr);
    if (SUCCEEDED(hr))
    {
       // Unregister this category as being "implemented" by the class.
       CATID rgcatid[1] ;
       rgcatid[0] = catid;
       hr = pcr-&gt;UnRegisterClassImplCategories(clsid, 1, rgcatid);
    }

    if (pcr != NULL)
        pcr-&gt;Release();

        return hr;
        }
</PRE>

<P>As mentioned previously, a control is responsible for removing the safe initialization and scripting category entries when the <B>DLLUnRegisterServer</B> function is called. The following excerpt is taken from a sample control that supports both safe initialization and safe scripting.

<PRE>STDAPI DllUnregisterServer(void)
{
    HRESULT hr;    // HResult used by Safety Functions

    AFX_MANAGE_STATE(_afxModuleAddrThis);

    if (!AfxOleUnregisterTypeLib(_tlid)) 
        return ResultFromScode(SELFREG_E_TYPELIB);

    if (!COleObjectFactoryEx::UpdateRegistryAll(FALSE))
        return ResultFromScode(SELFREG_E_CLASS);

    // Remove entries from the registry.

    hr=UnRegisterCLSIDInCategory(CLSID_SafeItem, CATID_SafeForInitializing);
    if (FAILED(hr))
        return hr;

    hr=UnRegisterCLSIDInCategory(CLSID_SafeItem, CATID_SafeForScripting);
    if (FAILED(hr))
        return hr;

    return NOERROR;
}
</PRE>
<h2><A NAME="iobjsafe">Supporting the IObjectSafety Interface</A></h2>

<P>The <B>IObjectSafety</B> interface allows a container to ask a control to make itself safe, or to retrieve the current initialization or scripting capabilities for the control. This interface is defined in the Objsafe.h file. Currently two capabilities are supported: safe for scripting and safe for initialization. These capabilities correspond to the following bit flags, which are defined in Objsafe.h:

<TABLE>
<TR><TD>INTERFACESAFE_FOR_UNTRUSTED_DATA
 </TD><TD>Specifies that the interface is safe for initialization.
</TD></TR><TR><TD>INTERFACESAFE_FOR_UNTRUSTED_CALLER
 </TD><TD>Specifies that the interface is safe for scripting.
</TD></TR></TABLE>

<P>(Additional capabilities may be defined at a future date.)

<P>The <B>IObjectSafety</B> interface supports two methods: <A HREF="safety/GetInterfaceSafetyOptions.htm#GetInterfaceSafetyOptions">IObjectSafety::GetInterfaceSafetyOptions</A> and <A HREF="safety/SetInterfaceSafetyOptions.htm#SetInterfaceSafetyOptions">IObjectSafety::SetInterfaceSafetyOptions</A>. The first method returns the control's security capabilities (as specified by either of the two bit flags listed above). The second method allows a container to request that a control configure itself for safe initialization or scripting. The following listing from Objsafe.h contains the interface and method definitions.


<PRE>// Option bit definitions for IObjectSafety:
#define    INTERFACESAFE_FOR_UNTRUSTED_CALLER    0x00000001
        // Caller of interface may be untrusted.
#define    INTERFACESAFE_FOR_UNTRUSTED_DATA    0x00000002
        // Data passed into interface may be untrusted.

// {CB5BDC81-93C1-11cf-8F20-00805F2CD064}
DEFINE_GUID(IID_IObjectSafety, 0xcb5bdc81, 0x93c1, 0x11cf, 0x8f, 0x20, 
    0x0, 0x80, 0x5f, 0x2c, 0xd0, 0x64);

interface IObjectSafety : public IUnknown
    {
    public:
        virtual HRESULT __stdcall GetInterfaceSafetyOptions( 
            /* [in]  */ REFIID riid,
            /* [out] */ DWORD __RPC_FAR *pdwSupportedOptions,
            /* [out] */ DWORD __RPC_FAR *pdwEnabledOptions) = 0;

        virtual HRESULT __stdcall SetInterfaceSafetyOptions( 
            /* [in] */ REFIID riid,
            /* [in] */ DWORD dwOptionSetMask,
            /* [in] */ DWORD dwEnabledOptions) = 0;

    };
</PRE>

<P>Although some containers call <A HREF="safety/GetInterfaceSafetyOptions.htm#GetInterfaceSafetyOptions">IObjectSafety::GetInterfaceSafetyOptions</A> to retrieve the default capabilities for a control, Internet Explorer 3.0 does not. Instead, it calls <A HREF="safety/SetInterfaceSafetyOptions.htm#SetInterfaceSafetyOptions">IObjectSafety::SetInterfaceSafetyOptions</A> prior to initializing a control. And, if the control supports scripting, it calls <B>IObjectSafety::SetInterfaceSafetyOptions</B> a second time. This function has three arguments: the first specifies the interface ID for an interface on the control that the container wants to access; the second specifies the capabilities that the container would like to set; the third specifies how the container would like to set these options.

<!-- CONTENTS_END -->
<!-- START PAGE FOOTER -->
<H6><HR size=1></H6>
<P><A ID=line HREF="#pagetop"><IMG src="../../art/arrowup1.gif" WIDTH="17" HEIGHT="16" ALIGN="MIDDLE" BORDER="0" ALT="Up">&nbsp;Top of Page</A>
<BR><A ID=line HREF="http://www.microsoft.com/misc/cpyright.htm" TARGET="_top">&#169; 1997 Microsoft Corporation. All rights reserved. Terms of Use.</A>
<!-- END PAGE FOOTER -->
</BLOCKQUOTE>
</BODY>
</HTML>
