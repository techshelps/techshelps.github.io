<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Palette Management for ActiveX Objects</TITLE>

<META NAME=MS-HKWD CONTENT="Palette Management for ActiveX Objects">
<META NAME="Keywords" CONTENT="Component Development">
<META NAME="Platform" CONTENT="Windows, Win95, WinNT">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=iso8859-1">
<META NAME="MS.LOCALE" CONTENT="EN-US">
<META NAME="ROBOTS" CONTENT="all">


<SCRIPT>
//<!--
var g_isIE = false, g_isNav = false, g_iMaj = 0, g_sPlat = "";
// -->
</SCRIPT>
<SCRIPT SRC="../../code/ver.js"></SCRIPT>


<SCRIPT DEFER SRC="../../code/common.js"></SCRIPT>
<SCRIPT DEFER>
//<!--
function InitPage()
{
	if (g_isIE && g_iMaj >= 4)	
	{
		SetTOC();
	}
}
//-->
</SCRIPT>

<LINK REL="stylesheet" HREF="/msdn/sdk/inetsdk/help/basicsdkIE4.css" TYPE="text/css">
<!-- STYLE_START -->


<SCRIPT>
//<!--
   var sVR = '../../'	// Set root for the style sheet
   var sCSS = '<LINK REL="stylesheet" HREF="' + sVR;

   if(g_isIE)
   {
	   if (g_iMaj >= 4) // For MSIE 4.0 or later
	   {
		   sCSS += 'basicSDKIE4';
		   if (g_sPlat == "Win") // Windows only for now
		   {
			   document.createStyleSheet(sVR + 'advSDKIE4.css');
		   }
	   }
	   else // For MSIE 3.0 or earlier
	   {
		   sCSS += 'basicSDKIE3';
	   }
   }
   else if (g_isNav) // For all Nav versions
   {
	   sCSS += 'basicSDKNAV';
   }
   else
   {
	   sCSS += 'basicSDKIE3'; // default to IE3 sheet
   }

   sCSS += (sCSS == '' ? '' : '.css" TYPE="text/css">');

   document.write(sCSS);
//-->
</SCRIPT>
<!-- STYLE_END -->
</HEAD>
<BODY onload="InitPage()" BGCOLOR="#FFFFFF">

<A NAME="pagetop"></A><A NAME="ch_palettes"></A>
<!-- NAV_LINKS_START -->
<TABLE class=main BORDER=0 CELLSPACING="0" CELLPADDING="0" WIDTH="10%"><TR><TD ROWSPAN="3" VALIGN="TOP" WIDTH="121"><IMG SRC="../../art/headbar2.gif" WIDTH="121" HEIGHT="82" BORDER=0 ALT="Palette Management for ActiveX Objects"></TD><TD ROWSPAN="2" VALIGN="TOP" WIDTH="186"><IMG SRC="../../art/headbarc.gif" WIDTH="186" HEIGHT="44" BORDER=0 ALT="Palette Management for ActiveX Objects"></TD><TD VALIGN="TOP" WIDTH="470"><IMG SRC="../../art/replace1.gif" WIDTH="470" HEIGHT="17" BORDER=0 ALT="*"></TD></TR><TR><TD><PRE><IMG SRC="../../art/arrowrht.gif" WIDTH="14" HEIGHT="14" ALIGN="MIDDLE" BORDER=0 ALT="*"><object id="hhal_1" type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Item1" value="">
<PARAM name="Item2" value=_win32_Contents>
</object><A STYLE="color:black" ID=TOC HREF=JavaScript:hhal_1.Click()>Contents</A>  <IMG SRC="../../art/arrowrht.gif" WIDTH="14" HEIGHT="14" ALIGN="MIDDLE" BORDER=0 ALT="*"><object id="hhal_2" type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Item1" value="">
<PARAM name="Item2" value=_win32_Index_1sz1>
</object><A STYLE="color:black" HREF=JavaScript:hhal_2.Click()>Index</A>  <IMG SRC="../../art/arrowrht.gif" WIDTH="14" HEIGHT="14" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black" HREF="controls.htm#bk_activex_controls">Topic Contents</A>
</PRE></TD></TR>
<TR><TD COLSPAN="2"><PRE><IMG SRC="../../art/arrowlft.gif" WIDTH="17" HEIGHT="15" ALIGN="MIDDLE" BORDER=0 ALT="*"><B>Previous Topic:</B> <A STYLE="color:black" HREF="packaging.htm">Packaging ActiveX Controls</A>
<IMG SRC="../../art/arrownxt.gif" WIDTH="17" HEIGHT="16" ALIGN="MIDDLE" BORDER=0 ALT="*"><B>Next Topic:</B> <A  STYLE="color:black" HREF="registration.htm">Registering an ActiveX Object as the Player for a Media Type</A>
</PRE></TD></TR>
</TABLE>
<!-- NAV_LINKS_END -->
<BLOCKQUOTE class="body">
<!-- CONTENTS_START -->
<h1>Palette Management for ActiveX Objects</h1>

<P>This document describes palette management for ActiveX objects, specifically ActiveX Controls and Active Document Objects. The palette management rules described herein allow multiple controls inside a form or an HTML page to display correctly, while still leaving enough flexibility to allow a control to demand palette control. In general, containers are responsible for palette management, and contained objects (for example, controls) should only realize their palettes in the background.

<P><A CLASS=tctop HREF="palettes.htm#Palette_Management_f"><IMG SRC="../../art/arrowg.gif" WIDTH="6" HEIGHT="11" BORDER=0 ALT="arrowg.gif">Palette Management for ActiveX Controls and Containers</A><BR>

<P><A CLASS=tctop HREF="palettes.htm#Palette_Management_f"><IMG SRC="../../art/arrowg.gif" WIDTH="6" HEIGHT="11" BORDER=0 ALT="arrowg.gif">Palette Management for Active Document Objects</A><BR>
<!--************************************************************--><h2><A NAME="Palette_Management_f">Palette Management for ActiveX Controls and Containers</A></h2>

<P>This section describes how ActiveX controls and containers should manage the palette.

<h3><A NAME="Palette_selection">Palette selection</A></h3>

<P>Because there may be more than one control on a page or form, it is up to the container to choose a common palette, and every control should realize its palette in the background. Anything else would result in chaos as each control realized its palette while painting. The display would flicker madly and most controls would look awful. 

<P>Ultimately it is the container's responsibility to choose the common palette. Some containers may use the UI active object's palette; others may compute the palette at run-time. 

<h3><A NAME="Ambient_palette_prop">Ambient palette property</A></h3>

<P>The container makes its palette available to contained controls through an ambient property: DISPID_AMBIENT_PALETTE. This property is defined as part of the OLE Controls 96 specification and is implemented by Microsoft Internet Explorer. Controls can receive the value of this ambient initially by implementing IOleObject::SetClientSite or IObjectWithSite::SetSite, then querying the container client site for IDispatch, and finally calling IDispatch::Invoke on the property to obtain its value. Afterwards, controls can receive notification of changes to this property by implementing: IOleControl::OnAmbientPropertyChange(). 

<P>Containers should realize the ambient palette before calling this function or IViewObject2::Draw(). Older containers that do not implement this property will typically iterate through their controls, forwarding the WM_QUERYNEWPALETTE message until a control returns TRUE (indicating it has realized a palette). Containers that implement DISPID_AMBIENT_PALETTE should never send WM_QUERYNEWPALETTE to their controls. 

<h3><A NAME="Palette_change_notif">Palette change notification</A></h3>

<P>Palette-aware controls that need to be notified of changes to the ambient palette should implement <B>IOleControl::OnAmbientPropertyChange</B> and handle DISPID_AMBIENT_PALETTE and DISPID_UNKNOWN. DISPID_UNKNOWN is sent when the values of more than one ambient property changes. When this happens, controls should explicitly check for a changed palette. 

<P>Older containers that do not define an ambient palette will send WM_PALETTECHANGED messages. Controls are encouraged to handle this message as well. 

<P>Note that controls can still realize a different palette (in the background). The ambient palette property is useful only if a control needs to optimize its display to the palette of the container. If this is not necessary, the control should ignore the ambient palette property.

<h3><A NAME="IViewObject2__GetCol">IViewObject2::GetColorSet</A></h3>

<P>All palette-aware controls should implement <B>IViewObject2::GetColorSet</B> if they want to specify a palette preference. Containers can use the return value to determine if a control is palette-aware. Containers can also use the color information returned to choose what palette to realize.
<TABLE>
<TR><TD>E_NOTIMPL
 </TD><TD>The control is not palette-aware.
</TD></TR><TR><TD>S_FALSE
 </TD><TD>The control is palette-aware but does not have a palette at this time.
</TD></TR><TR><TD>S_OK
 </TD><TD>The control is palette-aware and has returned its palette to the container.
</TD></TR></TABLE>

<P>It should be noted that the container does not have to call <B>IViewObject2::GetColorSet</B>. The container can determine its palette independently of its controls. 

<h3><A NAME="Realizing_the_palett">Realizing the palette</A></h3>

<P>Older OLE guidelines allowed the UI active object to realize its own palette in the foreground. Revised guidelines disallow this practice.

<P>Controls should realize their palette in the foreground only when receiving a WM_QUERYNEWPALETTE message. In every other situation, the control must realize its palette in the background. Containers that implement DISPID_AMBIENT_PALETTE will never send this message. 

<P><B>Summary:</B> 
<UL>
<LI>Containers determine the palette.
<LI>Containers can choose to implement DISPID_AMBIENT_PALETTE.
<LI>Containers must realize the ambient palette before calling <B>IViewObject2::Draw</B> or <B>IOleControl::OnAmbientPropertyChange</B>.
<LI>Controls must <B>always</B> realize their palette in the background. The only exception is when receiving a WM_QUERYNEWPALETTE message. 
<LI>Controls should implement <A HREF="palettes.htm#IViewObject2__GetCol">IViewObject2::GetColorSet</A> if they want to tell the container about their palette preferences.
<LI>Controls should implement <B>IOleControl::OnAmbientPropertyChange</B> if they want to be notified about changes in the ambient palette property in order to optimize their display to the container's palette.
</UL>
<h2><A NAME="Palette_Management_f">Palette Management for Active Document Objects</A></h2>

<P>The following sections describe issues related to palette management by OLE Document Objects. In general, the palette management scheme for document objects is the same as the scheme used for controls, except that document objects do not receive ambient properties from their container.

<h3><A NAME="Responsibilities_of_">Responsibilities of the document object</A></h3>

<P>Palette management for document objects is similar to palette management for controls. The following are the responsibilities of the document object:
<UL>
<LI>Document objects should implement <A HREF="palettes.htm#IViewObject2__GetCol">IViewObject2::GetColorSet</A> if interested in notifying the container about the palette they want to display. This is exactly the same as the corresponding responsibility for controls (as previously discussed).
<LI>Document objects should realize their palette in the background except when handling WM_QUERYNEWPALETTE messages (forwarded from the container). Again, this is exactly the same as the corresponding responsibility for controls.
</UL>

<P>The only difference between the responsibilities of controls and document objects is that document objects do not handle the DISPID_AMBIENT_PALETTE property.

<h3><A NAME="Single_document_case">Single document case</A></h3>

<P>In the most common cases, a DocObject container will activate only one DocObject at a time. In such a situation, it is acceptable that the activated DocObject should have complete control over the palette, which includes managing palette issues for any controls or content within that document.

<P>The DocObject container in this case has nothing to do with palettes and need not be concerned with palette issues. It should leave palette handling up to the DocObject&#151; in other words, it should forward all Windows&#174; palette management messages on to the DocObject.

<P>The following is example code for the window procedure of the document object host:
<PRE>case WM_PALETTECHANGED:
case WM_QUERYNEWPALETTE:
{
    HWND hwnd;
    IOleWindow *pOleWindow;
    if (pDocObj &amp;&amp; SUCCEEDED(pDocObj-&gt;QueryInterface(IID_IOleWindow, 
            (LPVOID*)&amp;pOleWindow))) {
        LRESULT lres = 0;
        if (SUCCEEDED(pOleWindow-&gt;GetWindow(&amp;hwnd))) {
            lres = SendMessage(hwnd, uMsg, wParam, lParam);
        }
        pOleWindow-&gt;Release();
        return lres;
    }
    break;
}
</PRE>
<h3><A NAME="Multiple_DocObject_c">Multiple DocObject case</A></h3>

<P>In rare cases, a DocObject container may be able to activate more than one DocObject at a time within multiple container frames. While this user interface is discouraged at this time, it can be achieved.

<P>However, no palette-management solution exists for this scenario because there is currently no protocol for communicating palettes between a DocObject and its container. Therefore, the container cannot create a palette suitable to all DocObjects that it has activated.

<P>Because of this, the activated DocObject in the foreground has control over the palette and should use foreground palette rendering. Other activated DocObjects in the background use background palette rendering. The DocObject container itself does not participate in palette management at all. 
<!-- CONTENTS_END -->
<!-- START PAGE FOOTER -->
<H6><HR size=1></H6>
<P><A ID=line HREF="#pagetop"><IMG src="../../art/arrowup1.gif" WIDTH="17" HEIGHT="16" ALIGN="MIDDLE" BORDER="0" ALT="Up">&nbsp;Top of Page</A>
<BR><A ID=line HREF="http://www.microsoft.com/misc/cpyright.htm" TARGET="_top">&#169; 1997 Microsoft Corporation. All rights reserved. Terms of Use.</A>
<!-- END PAGE FOOTER -->
</BLOCKQUOTE>
</BODY>
</HTML>
