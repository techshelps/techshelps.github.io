<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Active Script Debugging API</TITLE>

<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso8859-1">
<META NAME="MS.LOCALE" CONTENT="EN-US">
<META NAME=MS-HKWD CONTENT="Active Script Debugging API">
<META NAME="Keywords" CONTENT="Active Script Debugging API">
<META NAME="Platform" CONTENT="Windows">
<META NAME="ROBOTS" CONTENT="all">

<!--@ SNIFF_START -->
<SCRIPT>
//<!--
var g_isIE = false, g_isNav = false, g_iMaj = 0, g_sPlat = "";
// -->
</SCRIPT>
<SCRIPT SRC="../code/ver.js"></SCRIPT>
<!--@ SNIFF_END -->

<SCRIPT DEFER SRC="../code/common.js"></SCRIPT>
<SCRIPT DEFER>
//<!--
function InitPage()
{
	if (g_isIE && g_iMaj >= 4)	
	{
		SetTOC();
	}
}
//-->
</SCRIPT>

<LINK REL="stylesheet" HREF="/msdn/sdk/inetsdk/help/basicsdkIE4.css" TYPE="text/css">
<!-- STYLE_START -->


<SCRIPT>
//<!--
   var sVR = '../'	// Set root for the style sheet
   var sCSS = '<LINK REL="stylesheet" HREF="' + sVR;

   if(g_isIE)
   {
	   if (g_iMaj >= 4) // For MSIE 4.0 or later
	   {
		   sCSS += 'basicSDKIE4';
		   if (g_sPlat == "Win") // Windows only for now
		   {
			   document.createStyleSheet(sVR + 'advSDKIE4.css');
		   }
	   }
	   else // For MSIE 3.0 or earlier
	   {
		   sCSS += 'basicSDKIE3';
	   }
   }
   else if (g_isNav) // For all Nav versions
   {
	   sCSS += 'basicSDKNAV';
   }
   else
   {
	   sCSS += 'basicSDKIE3'; // default to IE3 sheet
   }

   sCSS += (sCSS == '' ? '' : '.css" TYPE="text/css">');

   document.write(sCSS);
//-->
</SCRIPT>
<!-- STYLE_END -->
</HEAD>
<BODY onload="InitPage()" BGCOLOR="#FFFFFF">

<A NAME="pagetop"></A><A NAME="activdbg"></A>
<!-- NAV_LINKS_START -->
<TABLE class=main BORDER=0 CELLSPACING="0" CELLPADDING="0" WIDTH="10%"><TR><TD ROWSPAN="3" VALIGN="TOP" WIDTH="121"><IMG SRC="../art/headbar2.gif" WIDTH="121" HEIGHT="82" BORDER=0 ALT="Active Script Debugging API"></TD><TD ROWSPAN="2" VALIGN="TOP" WIDTH="186"><IMG SRC="../art/headbarc.gif" WIDTH="186" HEIGHT="44" BORDER=0 ALT="Active Script Debugging API"></TD><TD VALIGN="TOP" WIDTH="470"><IMG SRC="../art/replace1.gif" WIDTH="470" HEIGHT="17" BORDER=0 ALT="*"></TD></TR>
<TR><TD><PRE><IMG SRC="../art/arrowrht.gif" WIDTH="14" HEIGHT="14" ALIGN="MIDDLE" BORDER=0 ALT="*"><object id="hhal_1" type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Item1" value="">
<PARAM name="Item2" value=_win32_Contents>
</object><A STYLE="color:black" ID=TOC HREF=JavaScript:hhal_1.Click()>Contents</A>  <IMG SRC="../art/arrowrht.gif" WIDTH="14" HEIGHT="14" ALIGN="MIDDLE" BORDER=0 ALT="*"><object id="hhal_2" type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Item1" value="">
<PARAM name="Item2" value=_win32_Index_1sz1>
</object><A STYLE="color:black" HREF=JavaScript:hhal_2.Click()>Index</A>  <IMG SRC="../art/arrowrht.gif" WIDTH="14" HEIGHT="14" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black" HREF="../compdev/scripting/scripting.htm">Topic Contents</A></PRE></TD></TR>
<TR><TD COLSPAN="2"><PRE><IMG SRC="../art/arrownxt.gif" WIDTH="17" HEIGHT="16" ALIGN="MIDDLE" BORDER=0 ALT="*"><B>Next Topic:</B>
<object id="hhal_3" type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Item1" value="">
<PARAM name="Item2" value=_win32_Debug_Property_Interfaces>
</object><A  STYLE="color:black" HREF=JavaScript:hhal_3.Click()>Debug Property Interfaces</A></PRE></TD></TR>
</TABLE>
<!-- NAV_LINKS_END -->
<BLOCKQUOTE class="body">
<!-- CONTENTS_START -->
<H1>Active Script Debugging Interfaces</H1>

<P>Active Script Debugging is a set of interfaces that allow language-neutral, host-neutral debugging, with support for a wide variety of development environments.

<P><A NAME="Architecture"><IMG ALT="[ Architecture GIF]" SRC="art/arch.gif" WIDTH=483 HEIGHT=200></A>
<P>By <I>language neutral</I>, we mean that a debugging environment can support essentially any programming language, without having to have specific knowledge of that language built into the environment. (Today, the interfaces focus primarily on support scripting languages such as VBScript and JScript, as well as Java, but in the future we intended evolve them to support native code in languages such as C++.) Furthermore, the debugger automatically has the ability to debug applications written in a mixture of multiple languages, with cross-language stepping and breakpoints.
<P>By <I>host neutral</I>, we mean that the debugger can be automatically be used with any Active Scripting host, such as Internet Explorer, Spruuids, or any any other host written in the future. We also mean that the host has control over the structure of the document tree presented to the user and the contents and syntax coloring of the documents being debugged. This allows the host to present the source code being debugged in the context of the host document (for example, scripts can be show on an HTML page.) In the subsections below, we consider each of the key components in Active Debugging and their associated interfaces.
<P>Before proceeding further, we should define several key Active Debugging concepts:
<I><P>host application: </I>The application that hosts the script engines and provides a scriptable set of objects (or "object model").
<I><P>language engine: </I>A component that provides parsing, execution, and debugging abstractions for a particular languages.
<P><I>debugger IDE:</I> The application that provides debugging UI by communicating with the host application and language engines.
<P><I>machine debug manager:</I> A component that maintains a registry of debuggable application processes.
<P><I>process debug manager: </I>A component that maintains the tree of debuggable documents a particular application, tracks the running threads, etc.
<P><I>document context:</I>: A document context is an abstraction representing a specific range in the source code of a host document.
<P><I>code context: </I>A code context represents a particular location in the running code of a language engine (a "virtual instruction pointer".)
<P><I>expression context: </I>A particular context (for example, a stack frame) in which expressions may be evaluated by a language engine.
<I><P>object browsing:</I> A structured, language-independent representation of an objects name, type, value, and subobjects, suitable for implementating a "watch window" UI.
<P>Below, we provide an overview of each of the key Active Debugging components and their associated interfaces, followed by the details of those interfaces.

<H2>Language Engine</H2>
<P>The language engine provides:
<P>- Language parsing and execution
<P>- Debugging support (breakpoints,etc..).
<P>- Expression evaluation.
<P>- Syntax coloring.
<P>- Object browsing.
<P>- Stack enumeration and parsing.
<P>Below is a list of the key interfaces implemented by a language engine. These interfaces are used by the host application to map between its document context and the engine's code contexts, and also by the debugger UI to do expression evaluation, stack enumeration, and object browsing.
<FONT FACE="Courier New">
<P><A HREF="#IActiveScriptDebug">IActiveScriptDebug</A>; <FONT COLOR="#008000">// provides syntax coloring and code context enumeration</FONT>
<P><A HREF="#IActiveScriptErrorDebug">IActiveScriptErrorDebug</A>; <FONT COLOR="#008000">// returns document contexts and stack frames for errors</FONT>
<P><A HREF="#IActiveScriptSiteDebug">IActiveScriptSiteDebug</A>; <FONT COLOR="#008000">// host provided link from script engine to debugger</FONT>
<P>IActiveScriptTextInfo; <FONT COLOR="#008000">// Language engine debugging abstractions</FONT>
<P><A HREF="#IDebugCodeContext">IDebugCodeContext</A>; <FONT COLOR="#008000">// a virtual "instruction pointer" in a thread</FONT>
<P><A HREF="#IEnumDebugCodeContexts">IEnumDebugCodeContexts</A>;
<P><A HREF="#IDebugStackFrame">IDebugStackFrame</A>; <FONT COLOR="#008000">// logical stack frame on the stack of a thread</FONT>
<P><A HREF="#IDebugExpressionContext">IDebugExpressionContext</A>; <FONT COLOR="#008000">// a context in which expressions can be evaluated</FONT>
<P><A HREF="#IDebugStackFrameSniffer">IDebugStackFrameSniffer</A>; <FONT COLOR="#008000">// enumerator for stack frames known by an engine</FONT>
<P><A HREF="#IDebugExpressionContext">IDebugExpressionContext</A>; <FONT COLOR="#008000">// context for expression evaluation</FONT>
<P><A HREF="#IDebugExpression">IDebugExpression</A>; <FONT COLOR="#008000">// an asynchronously evaluated expression</FONT>
<P><A HREF="#IDebugSyncOperation">IDebugSyncOperation</A>;
<P><A HREF="#IDebugAsyncOperation">IDebugAsyncOperation</A>;
<P><A HREF="#IDebugAsyncOperationCallBack">IDebugAsyncOperationCallBack</A>; <P><A HREF="#IDebugExpressionCallback">IDebugExpressionCallBack</A>; <FONT COLOR="#008000">// status events for IDebugExpression evaluation progress</FONT>
<P><A HREF="#IEnumDebugExpressionContexts">IEnumDebugExpressionContexts</A>; 
<P><A HREF="#IProvideExpressionContexts">IProvideExpressionContexts</A>; <FONT COLOR="#008000">// Object browsing</FONT>
<P><A HREF="#IDebugFormatter">IDebugFormatter</A>; 
</FONT>

<H3>Hosts</H3>
<P>The host:
<P>- Hosts the language engines.
<P>- Provides an object model (set of objects that can be scripted)
<P>- defines a tree of documents that can be debugged and their contents
<P>- Organizes scripts into virtual applications.

<P>There are two kinds of hosts:
<P>1. A dumb host supports just the basic ActiveScripting interfaces. It has no control over document structure or organizations; this is determined entirely by the scripts provided to the language engines.
<P>2. A smart host supports a larger set of interface that allow it to define the document tree, document contents, and syntax coloring. There are a set of helper interfaces, described in the next subsection, which make it much easier for a host to be a smart host.

<P><B>Smart-host Helper Interfaces</B>
<P>The IDebugDocumentHelper are a greatly simplified set of interfaces that a host can use to gain the benefits of smart-hosting without having to handle the full complexity (and power) of the full host interfaces.
<P>A host is not required to use these interfaces, of course, but by using these can avoid having to implement or use a number of more complicated interfaces.
<FONT FACE="Courier New">
<P><A HREF="#IDebugDocumentHelper">IDebugDocumentHelper</A>; <FONT COLOR="#008000">// implemented by PDM</FONT>
<P><A HREF="#IDebugDocumentHost">IDebugDocumentHost</A>; <FONT COLOR="#008000">// implemented (optionally) by the host</FONT>
</FONT>
<P><B>Full Smart-host Interfaces</B>
<P>Below is the full set of interfaces that a smart-host needs to implement or use if it's not using the helper interfaces.
<FONT FACE="Courier New">
<P><FONT COLOR="#008000">// implemented by host</FONT>
<P><A HREF="#IDebugDocumentInfo">IDebugDocumentInfo</A>; <FONT COLOR="#008000">// provides info on (possibily uninstantiated) doc</FONT>
<P><A HREF="#IDebugDocumentProvider">IDebugDocumentProvider</A>; <FONT COLOR="#008000">// allows doc to be instantiated on demand</FONT>
<P><A HREF="#IDebugDocument">IDebugDocument</A>; <FONT COLOR="#008000">// base document interface</FONT>
<P><A HREF="#IDebugDocumentText">IDebugDocumentText</A>; <FONT COLOR="#008000">// provides access to source text of document</FONT>
<P><A HREF="#IDebugDocumentTextEvents">IDebugDocumentTextEvents</A>; <FONT COLOR="#008000">// events fired when source text changes</FONT>
<P><A HREF="#IDebugDocumentTextAuthor">IDebugDocumentTextAuthor</A>;
<P><A HREF="#IDebugDocumentContext">IDebugDocumentContext</A>; <FONT COLOR="#008000">// represents a range within the document
<P>// implemented by PDM on behalf of the host</FONT>
<P><A HREF="#IDebugApplicationNode">IDebugApplicationNode</A>; <FONT COLOR="#008000">// represents the position of a doc in the hierarchy</FONT>
<P><A HREF="#IDebugApplicationNodeEvents">IDebugApplicationNodeEvents</A>; <FONT COLOR="#008000">// events fired by PDM when document hierarchy changes
</FONT>
</FONT>

<H3>Debugger IDE</H3>
<P>The IDE is a fully language independent debugging UI. It provides:
<P>- Document viewers/editors.
<P>- Breakpoint management.
<P>- Expression evaluation and watch windows.
<P>- Stack frame browsing.
<P>- Object/Class browsing.
<P>- Browsing the virtual application structure.
<P><FONT COLOR="#008000">// Debugger implementation</FONT>
<FONT FACE="Courier New">
<P><A HREF="#IDebugSessionProvider">IDebugSessionProvider</A>; <FONT COLOR="#008000">// establishes a debug session for a running application.</FONT>
<P><A HREF="#IApplicationDebugger">IApplicationDebugger</A>; <FONT COLOR="#008000">// primary interface exposed by a debugger IDE session
</FONT>
</FONT>

<H3>Machine Debug Manager</H3>
<P>The machine debug manager provides the hookup point between virtual applications and debuggers by maintaining and enumerating a list of active virtual applications.
<FONT FACE="Courier New">
<P><A HREF="#IMachineDebugManager">IMachineDebugManager</A>;
<P><A HREF="#IMachineDebugManagerCookie">IMachineDebugManagerCookie</A>; <P><A HREF="#IMachineDebugManagerEvents">IMachineDebugManagerEvents</A>;
<P><A HREF="#IEnumRemoteDebugApplications">IEnumRemoteDebugApplications</A>;
</FONT>

<H3>Process Debug Manager</H3>
<P>The PDM does the following:
<P>- Synchronizes the debugging of multiple language engines.
<P>- Maintains a tree of debuggable documents
<P>- Merges stack frames.
<P>- Coordinates breakpoints and stepping across language engines.
<P>- Tracks threads.
<P>- Maintains a debugger thread for asynchronous processing.
<P>- Communicates with the machine debug manager and the debugger IDE.

<P>The following are the interfaces provided by the process debug manager.
<FONT FACE="Courier New">
<P><A HREF="#IProcessDebugManager">IProcessDebugManager</A>; <FONT COLOR="#008000">// creates, adds and removes virtual applications, etc.</FONT>
<P><A HREF="#IRemoteDebugApplication">IRemoteDebugApplication</A>; <FONT COLOR="#008000">// virtual application abstraction</FONT>
<P><A HREF="#IDebugApplication">IDebugApplication</A>;
<P><A HREF="#IRemoteDebugApplicationThread">IRemoteDebugApplicationThread</A>; <FONT COLOR="#008000">// virtual thread abstraction</FONT>
<P><A HREF="#IDebugApplicationThread">IDebugApplicationThread</A>;
<P><A HREF="#IEnumRemoteDebugApplicationThreads">IEnumRemoteDebugApplicationThreads</A>;
<P><A HREF="#IDebugThreadCall">IDebugThreadCall</A>; <FONT COLOR="#008000">// dispatches marshalled calls</FONT>
<P><A HREF="#IDebugApplicationNode">IDebugApplicationNode</A>; <FONT COLOR="#008000">// maintains a position for a document in the hierarchy</FONT>
<P><A HREF="#IEnumDebugApplicationNodes">IEnumDebugApplicationNodes</A>; <P><A HREF="#IEnumDebugStackFrames">IEnumDebugStackFrames</A>; <FONT COLOR="#008000">// merged enumeration of stack frames from engines
</FONT>
</FONT>

<H2><A NAME="Structures">Structures</A> and Enumerations</H2>
<P>These structures and enumerations are used in a number of the interfaces below.

<H3>BREAKPOINT_STATE</H3>
<P>Indicates the state of a breakpoint.
<FONT FACE="Courier New" COLOR="#000080"><P>typedef</FONT><FONT FACE="Courier New"> enum tagBREAKPOINT_STATE {
<P>BREAKPOINT_DELETED = 0,</FONT><FONT COLOR="#008000">// The breakpoint no longer exists but there are still references
</FONT><FONT FACE="Courier New"><P>BREAKPOINT_DISABLED = 1,</FONT><FONT COLOR="#008000">// The breakpoint exists but is disabled
</FONT><FONT FACE="Courier New"><P>BREAKPOINT_ENABLED = 2</FONT><FONT COLOR="#008000">// The breakpoint exists and is enabled
</FONT><FONT FACE="Courier New"><P>} BREAKPOINT_STATE;</FONT>

<H3>APPBREAKFLAGS</H3>
<P>Application break flags. Indicates the current debug state for the application and the current thread.
<P>When certain of these bits are set (some are per-thread and some are for all threads), language engines should break at the next opportunity.
<FONT FACE="Courier New" COLOR="#000080"><P>typedef</FONT><FONT FACE="Courier New"> DWORD APPBREAKFLAGS;
</FONT><FONT COLOR="#008000"><P>// DEBUGGER_BLOCK
<P>// languages should break immediately with BREAKREASON_DEBUGGER_BLOCK
</FONT><FONT FACE="Courier New"><P></FONT><FONT FACE="Courier New" COLOR="#000080">const</FONT><FONT FACE="Courier New"> APPBREAKFLAGSAPPBREAKFLAG_DEBUGGER_BLOCK= 0x00000001; 
</FONT><FONT COLOR="#008000"><P>// DEBUGGER_HALT
<P>// languages should break immediately with BREAKREASON_DEBUGGER_HALT
</FONT><FONT FACE="Courier New"><P></FONT><FONT FACE="Courier New" COLOR="#000080">const</FONT><FONT FACE="Courier New"> APPBREAKFLAGSAPPBREAKFLAG_DEBUGGER_HALT= 0x00000002;
</FONT><FONT COLOR="#008000"><P>// STEP
<P>// languages should break immediately in the stepping thread with BREAKREASON_STEP
</FONT><FONT FACE="Courier New"><P></FONT><FONT FACE="Courier New" COLOR="#000080">const</FONT><FONT FACE="Courier New"> APPBREAKFLAGSAPPBREAKFLAG_STEP= 0x00010000;
</FONT><FONT COLOR="#008000"><P>// NESTED - the application is in nested execution on a breakpoint
</FONT><FONT FACE="Courier New"><P></FONT><FONT FACE="Courier New" COLOR="#000080">const</FONT><FONT FACE="Courier New"> APPBREAKFLAGSAPPBREAKFLAG_NESTED= 0x00020000;
</FONT><FONT COLOR="#008000"><P>// STEP TYPES - defines whether we are stepping at source, bytecode, or machine level.
</FONT><FONT FACE="Courier New"><P></FONT><FONT FACE="Courier New" COLOR="#000080">const</FONT><FONT FACE="Courier New"> APPBREAKFLAGSAPPBREAKFLAG_STEPTYPE_SOURCE= 0x00000000;
<P></FONT><FONT FACE="Courier New" COLOR="#000080">const</FONT><FONT FACE="Courier New"> APPBREAKFLAGSAPPBREAKFLAG_STEPTYPE_BYTECODE= 0x00100000;
<P></FONT><FONT FACE="Courier New" COLOR="#000080">const</FONT><FONT FACE="Courier New"> APPBREAKFLAGSAPPBREAKFLAG_STEPTYPE_MACHINE= 0x00200000;
<P></FONT><FONT FACE="Courier New" COLOR="#000080">const</FONT><FONT FACE="Courier New"> APPBREAKFLAGSAPPBREAKFLAG_STEPTYPE_MASK= 0x00F00000;
</FONT><FONT COLOR="#008000"><P>// BREAKPOINT IN_PROGRESS
</FONT><FONT FACE="Courier New"><P></FONT><FONT FACE="Courier New" COLOR="#000080">const</FONT><FONT FACE="Courier New"> APPBREAKFLAGSAPPBREAKFLAG_IN_BREAKPOINT= 0x80000000;
</FONT>

<H3>BREAKREASON</H3>
<P>Indicates the cause of hitting a breakpoint.
<FONT FACE="Courier New" COLOR="#000080"><P>typedef</FONT><FONT FACE="Courier New"> enum tagBREAKREASON{
<P>BREAKREASON_STEP,</FONT><FONT COLOR="#008000">// Caused by the stepping mode
</FONT><FONT FACE="Courier New"><P>BREAKREASON_BREAKPOINT,</FONT><FONT COLOR="#008000">// Caused by an explicit breakpoint
</FONT><FONT FACE="Courier New"><P>BREAKREASON_DEBUGGER_BLOCK,</FONT><FONT COLOR="#008000">// Caused by another thread breaking
</FONT><FONT FACE="Courier New"><P>BREAKREASON_HOST_INITIATED,</FONT><FONT COLOR="#008000">// Caused by host requested break
</FONT><FONT FACE="Courier New"><P>BREAKREASON_LANGUAGE_INITIATED,</FONT><FONT COLOR="#008000">// Caused by a scripted break
</FONT><FONT FACE="Courier New"><P>BREAKREASON_DEBUGGER_HALT,</FONT><FONT COLOR="#008000">// Caused by debugger IDE requested break
</FONT><FONT FACE="Courier New"><P>BREAKREASON_ERROR</FONT><FONT COLOR="#008000">// Caused by an execution error
</FONT><FONT FACE="Courier New"><P>} BREAKREASON;</FONT>

<H3>BREAKRESUME_ACTION</H3>
<P>Describes how to continue from a breakpoint 
<FONT FACE="Courier New" COLOR="#000080"><P>typedef</FONT><FONT FACE="Courier New"> enum tagBREAKRESUME_ACTION{
<P>BREAKRESUMEACTION_ABORT,</FONT><FONT COLOR="#008000">// Abort the application
</FONT><FONT FACE="Courier New"><P>BREAKRESUMEACTION_CONTINUE,</FONT><FONT COLOR="#008000">// Continue running
</FONT><FONT FACE="Courier New"><P>BREAKRESUMEACTION_STEP_INTO,</FONT><FONT COLOR="#008000">// Step into a procedure
</FONT><FONT FACE="Courier New"><P>BREAKRESUMEACTION_STEP_OVER,</FONT><FONT COLOR="#008000">// Step over a procedure
</FONT><FONT FACE="Courier New"><P>BREAKRESUMEACTION_STEP_OUT</FONT><FONT COLOR="#008000">// Step out of the current procedure
</FONT><FONT FACE="Courier New"><P>} BREAKRESUMEACTION;
</FONT>

<H3>ERRORRESUME_ACTION</H3>
<P>Describes how to continue from a runtime error.
<FONT FACE="Courier New" COLOR="#000080"><P>typedef</FONT><FONT FACE="Courier New"> enum tagERRORRESUMEACTION {
<P>ERRORRESUMEACTION_ReexecuteErrorStatement,</FONT><FONT COLOR="#008000">// try executing the erroneous line again
</FONT><FONT FACE="Courier New"><P>ERRORRESUMEACTION_AbortCallAndReturnErrorToCaller,</FONT><FONT COLOR="#008000">// let the language engine handle the error
</FONT><FONT FACE="Courier New"><P>ERRORRESUMEACTION_SkipErrorStatement,</FONT><FONT COLOR="#008000">// resume execution from beyond the error
</FONT><FONT FACE="Courier New"><P>} ERRORRESUMEACTION;
</FONT>

<H3>DOCUMENTNAMETYPE</H3>
<P>Describes what type of name you'd like to get for a document: 
<FONT FACE="Courier New" COLOR="#000080"><P>typedef</FONT><FONT FACE="Courier New"> enum tagDOCUMENTNAMETYPE {
<P>DOCUMENTNAMETYPE_APPNODE,</FONT><FONT COLOR="#008000">// Gets the name ass it appears in the app tree
</FONT><FONT FACE="Courier New"><P>DOCUMENTNAMETYPE_TITLE,</FONT><FONT COLOR="#008000">// Gets the name as it appears on the doc viewer title bar
</FONT><FONT FACE="Courier New"><P>DOCUMENTNAMETYPE_FILE_TAIL,</FONT><FONT COLOR="#008000">// Gets the filename without a path (for save as...)
</FONT><FONT FACE="Courier New"><P>DOCUMENTNAMETYPE_URL,</FONT><FONT COLOR="#008000">// Gets the URL of the document, if any
</FONT><FONT FACE="Courier New"><P>} DOCUMENTNAMETYPE;
</FONT>

<H3>SOURCE_TEXT_ATTR</H3>
<P>Describes the attributes of a single character of source text. 
<FONT FACE="Courier New" COLOR="#000080"><P>typedef</FONT><FONT FACE="Courier New"> WORD SOURCE_TEXT_ATTR;
</FONT><FONT COLOR="#008000"><P>// The character is a part of a language keyword. Example: while</FONT>
<FONT FACE="Courier New" COLOR="#000080"><P>const</FONT><FONT FACE="Courier New"> SOURCE_TEXT_ATTR SOURCETEXT_ATTR_KEYWORD= 0x0001;
</FONT><FONT COLOR="#008000"><P>// The character is a part of a comment block.</FONT>
<FONT FACE="Courier New" COLOR="#000080"><P>const</FONT><FONT FACE="Courier New"> SOURCE_TEXT_ATTR SOURCETEXT_ATTR_COMMENT= 0x0002;
</FONT><FONT COLOR="#008000"><P>// The character is not part of compiled language source text. Example:
<P>// the HTML surrounding script blocks.</FONT>
<FONT FACE="Courier New" COLOR="#000080"><P>const</FONT><FONT FACE="Courier New"> SOURCE_TEXT_ATTR SOURCETEXT_ATTR_NONSOURCE= 0x0004;
</FONT><FONT COLOR="#008000"><P>// The character is a part of a language operator. Example: *</FONT>
<FONT FACE="Courier New" COLOR="#000080"><P>const</FONT><FONT FACE="Courier New"> SOURCE_TEXT_ATTR SOURCETEXT_ATTR_OPERATOR= 0x0008;
</FONT><FONT COLOR="#008000"><P>// The character is a part of a language numeric constant. Example: 1234</FONT>
<FONT FACE="Courier New" COLOR="#000080"><P>const</FONT><FONT FACE="Courier New"> SOURCE_TEXT_ATTR SOURCETEXT_ATTR_NUMBER= 0x0010;
</FONT><FONT COLOR="#008000"><P>// The character is a part of a language string constant. Example: "Hello World"</FONT>
<FONT FACE="Courier New" COLOR="#000080"><P>const</FONT><FONT FACE="Courier New"> SOURCE_TEXT_ATTR SOURCETEXT_ATTR_STRING= 0x0020;
</FONT><FONT COLOR="#008000"><P>// The character indicates the start of a function block</FONT>
<FONT FACE="Courier New" COLOR="#000080"><P>const</FONT><FONT FACE="Courier New"> SOURCE_TEXT_ATTR SOURCETEXT_ATTR_FUNCTION_START = 0x0040;
</FONT>

<H3>TEXT_DOC_ATTR</H3>
<P>Describes the attributes of the document 
<FONT FACE="Courier New" COLOR="#000080"><P>typedef</FONT><FONT FACE="Courier New"> DWORD TEXT_DOC_ATTR;
</FONT><FONT COLOR="#008000"><P>// Indicates that the document is read-only.</FONT>
<FONT FACE="Courier New" COLOR="#000080"><P>const</FONT><FONT FACE="Courier New"> TEXT_DOC_ATTR TEXT_DOC_ATTR_READONLY = 0x00000001;
</FONT>

<H3>Parse Flags</H3>
<P>Option flags used during IDebugExpressionContext::ParseLanguageText 
<FONT COLOR="#008000"><P>// Indicates that the text is an expression as opposed to a statement. This
<P>// flag may affect the way in which the text is parsed by some languages.</FONT>
<FONT FACE="Courier New" COLOR="#000080"><P>const</FONT><FONT FACE="Courier New"> DWORD DEBUG_TEXT_ISEXPRESSION= 0x00000001;
</FONT><FONT COLOR="#008000"><P>// If a return value is available, it will be used by the caller.</FONT>
<FONT FACE="Courier New" COLOR="#000080"><P>const</FONT><FONT FACE="Courier New"> DWORD DEBUG_TEXT_RETURNVALUE= 0x00000002;
</FONT><FONT COLOR="#008000"><P>// Don't allow side effects. If this flag is set, the evaluation of the
<P>// expression should change no runtime state.</FONT>
<FONT FACE="Courier New" COLOR="#000080"><P>const</FONT><FONT FACE="Courier New"> DWORD DEBUG_TEXT_NOSIDEEFFECTS= 0x00000004;
</FONT><FONT COLOR="#008000"><P>// Allow breakpoints during the evaluation of the text. If this flag is not
<P>// set then breakpoints will be ignored during the evaluation of the text.</FONT>
<FONT FACE="Courier New" COLOR="#000080"><P>const</FONT><FONT FACE="Courier New"> DWORD DEBUG_TEXT_ALLOWBREAKPOINTS= 0x00000008;
</FONT><FONT COLOR="#008000"><P>// Allow error reports during the evaluation of the text. If this flag is not
<P>// set then errors will not be reported to the host during the evaluation.</FONT>
<FONT FACE="Courier New" COLOR="#000080"><P>const</FONT><FONT FACE="Courier New"> DWORD DEBUG_TEXT_ALLOWERRORREPORT= 0x00000010;
</FONT>

<H2>Script Engine Debugging Interfaces</H2>
<P>Below are the interfaces that a script engine needs to support to provide debugging, expression evaluation, and object browsing.
<H3><A NAME="IActiveScriptDebug">IActiveScriptDebug</A></H3>
<P>This interface is implemented by script engines that support debugging, and is QI-able from IActiveScript. It provides the means for:
<P>1.Smart hosts to take over document management.
<P>2.Process debug manager to synchronize debugging of multiple script engines.
<FONT SIZE=2 COLOR="#808080"><P>[
<P>object,
<P>uuid(51973C10-CB0C-11d0-B5C9-00A0244A0E7A),
<P>pointer_default(unique)
<P>]</FONT><FONT FACE="Courier New"></FONT>
<FONT FACE="Courier New" COLOR="#000080"><P>interface</FONT><FONT FACE="Courier New"> IActiveScriptDebug : IUnknown
<P>{
<P></FONT><FONT COLOR="#008000">// Returns the text attributes for an arbitrary block of script text. Smart hosts
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// use this call to delegate GetText calls made on their IDebugDocumentText.
</FONT><FONT FACE="Courier New"><P>HRESULT GetScriptTextAttributes(
<P></FONT><FONT COLOR="#008000">// The script block text. This string need not be null terminated.
</FONT><FONT FACE="Courier New"><P></FONT><FONT SIZE=2 COLOR="#808080">[in, size_is(uNumCodeChars)]</FONT><FONT FACE="Courier New">LPCOLESTRpstrCode,
<P></FONT><FONT COLOR="#008000">// The number of characters in the script block text.
</FONT><FONT FACE="Courier New"><P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New">ULONGuNumCodeChars,
<P></FONT><FONT COLOR="#008000">// See IActiveScriptParse::ParseScriptText for a description of this argument.
</FONT><FONT FACE="Courier New"><P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New">LPCOLESTRpstrDelimiter,
<P></FONT><FONT COLOR="#008000">// See IActiveScriptParse::ParseScriptText for a description of this argument.
</FONT><FONT FACE="Courier New"><P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New">DWORDdwFlags,
<P></FONT><FONT COLOR="#008000">// Buffer to contain the returned attributes.
</FONT><FONT FACE="Courier New"><P></FONT><FONT SIZE=2 COLOR="#808080">[in, out, size_is(uNumCodeChars)]</FONT><FONT FACE="Courier New">SOURCE_TEXT_ATTR *pattr);

<P></FONT><FONT COLOR="#008000">// Returns the text attributes for an arbitrary scriptlet. Smart hosts
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// use this call to delegate GetText calls made on their IDebugDocumentText.
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// Note: this call is provided because scriptlets tend to be expressions and
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// may have a different syntax than a script block. For many languages the implementation
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// will be identical to GetScriptTextAttributes.
</FONT><FONT FACE="Courier New"><P>HRESULT GetScriptletTextAttributes(
<P></FONT><FONT COLOR="#008000">// The script block text. This string need not be null terminated.
</FONT><FONT FACE="Courier New"><P></FONT><FONT SIZE=2 COLOR="#808080">[in, size_is(uNumCodeChars)]</FONT><FONT FACE="Courier New">LPCOLESTRpstrCode,
<P></FONT><FONT COLOR="#008000">// The number of characters in the script block text.
</FONT><FONT FACE="Courier New"><P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New">ULONGuNumCodeChars,
<P></FONT><FONT COLOR="#008000">// See IActiveScriptParse::AddScriptlet for a description of this argument.
</FONT><FONT FACE="Courier New"><P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New">LPCOLESTRpstrDelimiter,
<P></FONT><FONT COLOR="#008000">// See IActiveScriptParse::AddScriptlet for a description of this argument.
</FONT><FONT FACE="Courier New"><P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New">DWORDdwFlags,
<P></FONT><FONT COLOR="#008000">// Buffer to contain the returned attributes.
</FONT><FONT FACE="Courier New"><P></FONT><FONT SIZE=2 COLOR="#808080">[in, out, size_is(uNumCodeChars)]</FONT><FONT FACE="Courier New">SOURCE_TEXT_ATTR *pattr);

<P></FONT><FONT COLOR="#008000">// Used by the smart host to delegate IDebugDocumentContext::EnumDebugCodeContexts.
</FONT><FONT FACE="Courier New"><P>HRESULT EnumCodeContextsOfPosition(
<P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New">DWORD dwSourceContext,</FONT><FONT COLOR="#008000">// As provided to IActiveScriptParse::ParseScriptText
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// or IActiveScriptParse::AddScriptlet
</FONT><FONT FACE="Courier New"><P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New">ULONG uCharacterOffset,</FONT><FONT COLOR="#008000">// character offset relative
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// to start of script text
</FONT><FONT FACE="Courier New"><P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New">ULONG uNumChars,</FONT><FONT COLOR="#008000">// Number of characters in context
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// Returns an enumerator of code contexts.
</FONT><FONT FACE="Courier New"><P></FONT><FONT SIZE=2 COLOR="#808080">[out]</FONT><FONT FACE="Courier New"></FONT><A HREF="#IEnumDebugCodeContexts">IEnumDebugCodeContexts</A><A HREF="#IEnumDebugCodeContexts"><FONT FACE="Courier New">IEnumDebugCodeContexts</FONT></A><FONT FACE="Courier New"> **ppescc);
<P>}
</FONT>

<H3><A NAME="IActiveScriptSiteDebug">IActiveScriptSiteDebug</A></H3>
<P>Implemented by smart hosts and is QI-able from IActiveScriptSite. It provides the means by which a smart host takes over document management and participates in debugging.
<FONT SIZE=2 COLOR="#808080"><P>[
<P>object,
<P>uuid(51973C11-CB0C-11d0-B5C9-00A0244A0E7A),
<P>pointer_default(unique),
<P>local
<P>]</FONT><FONT FACE="Courier New"></FONT>
<FONT FACE="Courier New" COLOR="#000080"><P>interface</FONT><FONT FACE="Courier New"> IActiveScriptSiteDebug : IUnknown
<P>{
<P></FONT><FONT COLOR="#008000">// Used by the language engine to delegate IDebugCodeContext::GetSourceContext.
</FONT><FONT FACE="Courier New"><P>HRESULT GetDocumentContextFromPosition(
<P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New">DWORD dwSourceContext,</FONT><FONT COLOR="#008000">// As provided to ParseScriptText
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// or AddScriptlet
</FONT><FONT FACE="Courier New"><P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New">ULONG uCharacterOffset,</FONT><FONT COLOR="#008000">// character offset relative
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// to start of script block or scriptlet
</FONT><FONT FACE="Courier New"><P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New">ULONG uNumChars,</FONT><FONT COLOR="#008000">// Number of characters in context
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// Returns the document context corresponding to this character-position range.
</FONT><FONT FACE="Courier New"><P></FONT><FONT SIZE=2 COLOR="#808080">[out]</FONT><FONT FACE="Courier New"></FONT><A HREF="#IDebugDocumentContext">IDebugDocumentContext</A><A HREF="#IDebugDocumentContext"><FONT FACE="Courier New">IDebugDocumentContext</FONT></A><FONT FACE="Courier New"> **ppsc);

<P></FONT><FONT COLOR="#008000">// Returns the debug application object associated with this script site. Provides
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// a means for a smart host to define what application object each script belongs to.
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// Script engines should attempt to call this method to get their containing application
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// and resort to IProcessDebugManager::GetDefaultApplication if this fails.
</FONT><FONT FACE="Courier New"><P>HRESULT GetApplication(
<P></FONT><FONT SIZE=2 COLOR="#808080">[out]</FONT><FONT FACE="Courier New"></FONT><A HREF="#IDebugApplication">IDebugApplication</A><A HREF="#IDebugApplication"><FONT FACE="Courier New">IDebugApplication</FONT></A><FONT FACE="Courier New"> **ppda);

<P></FONT><FONT COLOR="#008000">// Gets the application node under which script documents should be added
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// can return NULL if script documents should be top-level.
</FONT><FONT FACE="Courier New"><P>HRESULT GetRootApplicationNode(
<P></FONT><FONT SIZE=2 COLOR="#808080">[out]</FONT><FONT FACE="Courier New"></FONT><A HREF="#IDebugApplicationNode">IDebugApplicationNode</A><A HREF="#IDebugApplicationNode"><FONT FACE="Courier New">IDebugApplicationNode</FONT></A><FONT FACE="Courier New"> **ppdanRoot);

<P></FONT><FONT COLOR="#008000">// Allows a smart host to control the handling of runtime errors
</FONT><FONT FACE="Courier New"><P>HRESULT OnScriptErrorDebug(
<P></FONT><FONT COLOR="#008000">// the runtime error that occurred
</FONT><FONT FACE="Courier New"><P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New"></FONT><A HREF="#IActiveScriptErrorDebug">IActiveScriptErrorDebug</A><A HREF="#IActiveScriptErrorDebug"><FONT FACE="Courier New">IActiveScriptErrorDebug</FONT></A><FONT FACE="Courier New"> *pErrorDebug,
<P></FONT><FONT COLOR="#008000">// whether to pass the error to the debugger to do JIT debugging
</FONT><FONT FACE="Courier New"><P></FONT><FONT SIZE=2 COLOR="#808080">[out]</FONT><FONT FACE="Courier New">BOOL*pfEnterDebugger,
<P></FONT><FONT COLOR="#008000">// whether to call IActiveScriptSite::OnScriptError() when the user
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// decides to continue without debugging
</FONT><FONT FACE="Courier New"><P></FONT><FONT SIZE=2 COLOR="#808080">[out]</FONT><FONT FACE="Courier New">BOOL *pfCallOnScriptErrorWhenContinuing);
<P>}
</FONT>

<H3><A NAME="IActiveScriptErrorDebug">IActiveScriptErrorDebug</A></H3>
<P>Provides document context information for compile and runtime errors. QI-able from IActiveScriptError.
<FONT SIZE=2 COLOR="#808080"><P>[
<P>object,
<P>uuid(51973C12-CB0C-11d0-B5C9-00A0244A0E7A),
<P>pointer_default(unique)
<P>]</FONT><FONT FACE="Courier New"></FONT>
<FONT FACE="Courier New" COLOR="#000080"><P>interface</FONT><FONT FACE="Courier New"> IActiveScriptErrorDebug : IActiveScriptError
<P>{
<P></FONT><FONT COLOR="#008000">// Provides the document context for the associated error. The character-position range
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// should include the entire offending text.
</FONT><FONT FACE="Courier New"><P>HRESULT GetDocumentContext(
<P></FONT><FONT SIZE=2 COLOR="#808080">[out]</FONT> <A HREF="#IDebugDocumentContext">IDebugDocumentContext</A><A HREF="#IDebugDocumentContext"><FONT FACE="Courier New">IDebugDocumentContext</FONT></A><FONT FACE="Courier New"> **ppssc);

<P></FONT><FONT COLOR="#008000">// For runtime errors, provides the stack frame that is in effect.
</FONT><FONT FACE="Courier New"><P>HRESULT GetStackFrame(
<P></FONT><FONT SIZE=2 COLOR="#808080">[out]</FONT> <A HREF="#IDebugStackFrame">IDebugStackFrame</A><A HREF="#IDebugStackFrame"><FONT FACE="Courier New">IDebugStackFrame</FONT></A><FONT FACE="Courier New"> **ppdsf);
<P>}
</FONT>

<H3><A NAME="IDebugCodeContext">IDebugCodeContext</A></H3>
<P>Abstraction reresenting a position in executable code. It can be thought of as a "virtual program counter".
<FONT SIZE=2 COLOR="#808080"><P>[
<P>object,
<P>uuid(51973C13-CB0C-11d0-B5C9-00A0244A0E7A),
<P>pointer_default(unique)
<P>]</FONT><FONT FACE="Courier New"></FONT>
<FONT FACE="Courier New" COLOR="#000080"><P>interface</FONT><FONT FACE="Courier New"> IDebugCodeContext : IUnknown
<P>{
<P></FONT><FONT COLOR="#008000">// Returns the document context associated with this code context.
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">//
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// Note: For text documents, the character-position
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// range should include the text for the entire statement. This allows the debugger IDE
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// to hilight the current source statement.
</FONT><FONT FACE="Courier New"><P>HRESULT GetDocumentContext(
<P></FONT><FONT SIZE=2 COLOR="#808080">[out]</FONT> <A HREF="#IDebugDocumentContext">IDebugDocumentContext</A><A HREF="#IDebugDocumentContext"><FONT FACE="Courier New">IDebugDocumentContext</FONT></A><FONT FACE="Courier New"> **ppsc);

<P></FONT><FONT COLOR="#008000">// Sets or clears a breakpoint at this code context.
</FONT><FONT FACE="Courier New"><P>HRESULT SetBreakPoint(
<P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New"> BREAKPOINT_STATE bps);
<P>}
</FONT>

<H3><A NAME="IDebugExpression">IDebugExpression</A></H3>
<P>Abstract representation of an asynchronously evaluated expression. Normally used by the debugger IDE to implement an immediate execution window or watch window. Normally provided by language engines.
<P>Note: Currently, IDebugExpression is only available from a stack frame.
<FONT SIZE=2 COLOR="#808080"><P>[
<P>object,
<P>uuid(51973C14-CB0C-11d0-B5C9-00A0244A0E7A),
<P>pointer_default(unique)
<P>]</FONT><FONT FACE="Courier New"></FONT>
<FONT FACE="Courier New" COLOR="#000080"><P>interface</FONT><FONT FACE="Courier New"> IDebugExpression : IUnknown
<P>{
<P></FONT><FONT COLOR="#008000">// Begins the evaluation of the expression.
</FONT><FONT FACE="Courier New"><P>HRESULT Start(
<P></FONT><FONT COLOR="#008000">// Provides an event driven means for indicating that the expression evaluation
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// is complete. If NULL, no events will be fired and the client will need to
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// poll the expression state using QueryIsComplete.
</FONT><FONT FACE="Courier New"><P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New"> IDebugExpressionCallBack *pdecb);

<P></FONT><FONT COLOR="#008000">// Aborts the expression. Evaluation of an expression in progress will be stopped
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// at the earliest opportunity. If the expression is actually aborted, GetResultAsString
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// will return E_ABORT as phrResult.
</FONT><FONT FACE="Courier New"><P>HRESULT Abort(void);

<P></FONT><FONT COLOR="#008000">// Returns S_FALSE if the operation is still pending.
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// Returns S_OK if the operation is complete.
</FONT><FONT FACE="Courier New"><P>HRESULT QueryIsComplete(void);

<P></FONT><FONT COLOR="#008000">// Returns the result of the expression evaluation as a string and an HRESULT. Returns
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// E_PENDING if the operation is still pending. Returns S_OK and E_ABORT in phrResult
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// when the operation was aborted with Abort.
</FONT><FONT FACE="Courier New"><P>HRESULT GetResultAsString(
<P></FONT><FONT SIZE=2 COLOR="#808080">[out]</FONT><FONT FACE="Courier New"> HRESULT *phrResult,
<P></FONT><FONT SIZE=2 COLOR="#808080">[out]</FONT><FONT FACE="Courier New"> BSTR *pbstrResult);
<P>
<P></FONT><FONT COLOR="#008000">// Returns the result of the expression evaluation as an
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// IDebugProperty and an HRESULT. Returns
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// E_PENDING if the operation is still pending. Returns S_OK and E_ABORT in phrResult
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// when the operation was aborted with Abort.
</FONT><FONT FACE="Courier New">
<P>HRESULT GetResultAsDebugProperty(
<P></FONT><FONT SIZE=2 COLOR="#808080">[out]</FONT><FONT FACE="Courier New"> HRESULT *phrResult,
<P></FONT><FONT SIZE=2 COLOR="#808080">[out]</FONT><FONT FACE="Courier New"> IDebugProperty **ppdp);
<P></FONT>}

<H3><A NAME="IDebugExpressionContext">IDebugExpressionContext</A></H3>
<P>Abstract representation of a context in which expressions can be evaluated. Currently, this interface is only implemented by the stack frame object. In the future, other objects, such as the document context, may provide this interface.
<FONT SIZE=2 COLOR="#808080"><P>[
<P>object,
<P>uuid(51973C15-CB0C-11d0-B5C9-00A0244A0E7A),
<P>helpstring("IDebugExpressionContext Interface"),
<P>pointer_default(unique)
<P>]</FONT><FONT FACE="Courier New"></FONT>
<FONT FACE="Courier New" COLOR="#000080"><P>interface</FONT><FONT FACE="Courier New"> IDebugExpressionContext : IUnknown
<P>{
<P></FONT><FONT COLOR="#008000">// Creates an IDebugExpression for the specified text.
</FONT><FONT FACE="Courier New"><P>HRESULT ParseLanguageText(
<P></FONT><FONT COLOR="#008000">// Provides the text of the expression or statement(s).
</FONT><FONT FACE="Courier New"><P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New">LPCOLESTRpstrCode,
<P></FONT><FONT COLOR="#008000">// Radix to use
</FONT><FONT FACE="Courier New"><P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New">UINTnRadix,
<P></FONT><FONT COLOR="#008000">// See IActiveScriptParse::ParseScriptText
</FONT><FONT FACE="Courier New"><P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New">LPCOLESTRpstrDelimiter,
<P></FONT><FONT COLOR="#008000">// See above flags.
</FONT><FONT FACE="Courier New"><P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New">DWORDdwFlags,
<P></FONT><FONT COLOR="#008000">// Returns the IDebugExpression for the given text.
</FONT><FONT FACE="Courier New"><P></FONT><FONT SIZE=2 COLOR="#808080">[out]</FONT><FONT FACE="Courier New"></FONT><A HREF="#IDebugExpression">IDebugExpression</A><A HREF="#IDebugExpression"><FONT FACE="Courier New">IDebugExpression</FONT></A><FONT FACE="Courier New">**ppe
<P>);

<P></FONT><FONT COLOR="#008000">// Returns a name and GUID for the langauge owning this context
</FONT><FONT FACE="Courier New"><P>HRESULT GetLanguageInfo (
<P></FONT><FONT SIZE=2 COLOR="#808080">[out]</FONT><FONT FACE="Courier New">BSTR*pbstrLanguageName,</FONT><FONT COLOR="#008000">// the name of the language
</FONT><FONT FACE="Courier New"><P></FONT><FONT SIZE=2 COLOR="#808080">[out]</FONT><FONT FACE="Courier New">GUID*pLanguageID</FONT><FONT COLOR="#008000">// an unique id for this language
</FONT><FONT FACE="Courier New"><P>);
<P>}
</FONT>

<H3><A NAME="IDebugExpressionCallback">IDebugExpressionCallback</A></H3>
<P>Provides status events related to progress of an IDebugExpression evaluation.
<FONT SIZE=2 COLOR="#808080"><P>[
<P>object,
<P>uuid(51973C16-CB0C-11d0-B5C9-00A0244A0E7A),
<P>pointer_default(unique)
<P>]</FONT><FONT FACE="Courier New"></FONT>
<FONT FACE="Courier New" COLOR="#000080"><P>interface</FONT><FONT FACE="Courier New"> IDebugExpressionCallBack : IUnknown
<P>{
<P></FONT><FONT COLOR="#008000">// Indicates that the expression evaluation is complete. Note that
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// IDebugExpression::GetResultAsString can be called from within this event
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// handler.
</FONT><FONT FACE="Courier New"><P>HRESULT onComplete(void);
<P>}
</FONT>

<H3><A NAME="IDebugStackFrame">IDebugStackFrame</A></H3>
<P>Abstraction representing a logical stack frame on the stack of a thread. Note that it derives from IDebugExpressionContext. This allows the debugger to evaluate expressions in the context of a particular stack frame.
<P>Note: In general, you can QI a stack frame for IDebugExpressionContext to allow expression evaluation and watch windows
<FONT SIZE=2 COLOR="#808080"><P>[
<P>object,
<P>uuid(51973C17-CB0C-11d0-B5C9-00A0244A0E7A),
<P>pointer_default(unique)
<P>]</FONT><FONT FACE="Courier New"></FONT>
<FONT FACE="Courier New" COLOR="#000080"><P>interface</FONT><FONT FACE="Courier New"> IDebugStackFrame : IUnknown
<P>{
<P></FONT><FONT COLOR="#008000">// Returns the current code context associated with the stack frame.
</FONT><FONT FACE="Courier New"><P>HRESULT GetCodeContext(
<P></FONT><FONT SIZE=2 COLOR="#808080">[out]</FONT> <A HREF="#IDebugCodeContext">IDebugCodeContext</A><A HREF="#IDebugCodeContext"><FONT FACE="Courier New">IDebugCodeContext</FONT></A><FONT FACE="Courier New"> **ppcc);
<P></FONT><FONT COLOR="#008000">// Returns a short or long textual description of the stack frame.
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// Normally, when fLong if false, this will provide only the name of the
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// function associated with the stack frame. When fLong is true it may
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// also provide the parameter(s) to the function or whatever else is
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// relevant.
</FONT><FONT FACE="Courier New"><P>HRESULT GetDescriptionString(
<P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New"> BOOL fLong,
<P></FONT><FONT SIZE=2 COLOR="#808080">[out]</FONT><FONT FACE="Courier New"> BSTR *pbstrDescription);
<P></FONT><FONT COLOR="#008000">// Returns a short or long textual description of the language. When fLong
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// is false, just the language name should be provided, eg, "Pascal". When
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// fLong is true a full product description may be provided, eg,
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// "Gnat Software's Flaming Pascal v3.72".
</FONT><FONT FACE="Courier New"><P>HRESULT GetLanguageString(
<P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New"> BOOL fLong,
<P></FONT><FONT SIZE=2 COLOR="#808080">[out]</FONT><FONT FACE="Courier New"> BSTR *pbstrLanguage);
<P></FONT><FONT COLOR="#008000">// Returns the thread associated with this stack frame.
</FONT><FONT FACE="Courier New"><P>HRESULT GetThread(
<P></FONT><FONT SIZE=2 COLOR="#808080">[out]</FONT> <A HREF="#IDebugApplicationThread">IDebugApplicationThread</A><A HREF="#IDebugApplicationThread"><FONT FACE="Courier New">IDebugApplicationThread</FONT></A><FONT FACE="Courier New"> **ppat);

<P></FONT><FONT COLOR="#008000">// Returns a property browser for the current frame (locals, etc.)
</FONT><FONT FACE="Courier New"><P>HRESULT GetDebugProperty(
<P></FONT><FONT SIZE=2 COLOR="#808080">[out]</FONT><FONT FACE="Courier New"> IDebugProperty **ppDebugProp);
<P>}
</FONT>

<H3><A NAME="IDebugStackFrameSniffer">IDebugStackFrameSniffer</A></H3>
<P>Provides a means for enumerating logical stack frames known by a certain component. Generally implemented by each script engine. Used by the process debug manager to find all stack frames associated with a given thread. Note: This interface is called from within the thread of interest. It is up to the implementor to identify the current thread and return an appropriate enumerator.
<FONT SIZE=2 COLOR="#808080"><P>[
<P>object,
<P>uuid(51973C18-CB0C-11d0-B5C9-00A0244A0E7A),
<P>pointer_default(unique)
<P>]</FONT><FONT FACE="Courier New"></FONT>
<FONT FACE="Courier New" COLOR="#000080"><P>interface</FONT><FONT FACE="Courier New"> IDebugStackFrameSniffer : IUnknown
<P>{
<P></FONT><FONT COLOR="#008000">// Returns an enumerator of stack frames for the current thread. Top of stack should
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// be returned first (the most recently pushed frame).
</FONT><FONT FACE="Courier New"><P>HRESULT EnumStackFrames(
<P></FONT><FONT SIZE=2 COLOR="#808080">[out]</FONT> <A HREF="#IEnumDebugStackFrames">IEnumDebugStackFrames</A><A HREF="#IEnumDebugStackFrames"><FONT FACE="Courier New">IEnumDebugStackFrames</FONT></A><FONT FACE="Courier New"> **ppedsf);
<P>}

</FONT>

<H3><A NAME="IDebugStackFrameSnifferEx">IDebugStackFrameSnifferEx</A></H3>
<P>Provides a means for enumerating logical stack frames known by a certain component. Generally implemented by each script engine. Used by the process debug manager to find all stack frames associated with a given thread.
<P>Note: This interface is called from within the thread of interest. It is up to the implementor to identify the current thread and return an appropriate enumerator.
<FONT SIZE=2 COLOR="#808080"><P>[
<P>object,
<P>uuid(51973C19-CB0C-11d0-B5C9-00A0244A0E7A),
<P>pointer_default(unique)
<P>]</FONT><FONT FACE="Courier New"></FONT>
<FONT FACE="Courier New" COLOR="#000080"><P>interface</FONT><FONT FACE="Courier New"> IDebugStackFrameSnifferEx : </FONT><A HREF="#IDebugStackFrameSniffer">IDebugStackFrameSniffer</A><A HREF="#IDebugStackFrameSniffer"><FONT FACE="Courier New">IDebugStackFrameSniffer</FONT></A><FONT FACE="Courier New">
<P>{
<P></FONT><FONT COLOR="#008000">// Returns an enumerator of stack frames for the current thread.
</FONT><FONT FACE="Courier New">
<P></FONT><FONT COLOR="#008000">// dwSpMin is the minimum address to begin enumerating stack frames
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// Stack frames before this address will be omitted from the enumeration.
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// Top of stack should be returned first (the most recently pushed frame).
</FONT><FONT FACE="Courier New"><P>HRESULT EnumStackFramesEx( </FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New"> DWORD dwSpMin, </FONT><FONT SIZE=2 COLOR="#808080">[out]</FONT> <A HREF="#IEnumDebugStackFrames">IEnumDebugStackFrames</A><A HREF="#IEnumDebugStackFrames"><FONT FACE="Courier New">IEnumDebugStackFrames</FONT></A><FONT FACE="Courier New"> **ppedsf);
<P>};
</FONT>

<H3><A NAME="IDebugSyncOperation">IDebugSyncOperation</A></H3>
<P>IDebugSyncOperation is generally implemented by a language engine to expose expression evaluation, etc. It allows the implementor to abstract an operation that needs to be performed nested in a particular blocked thread, and it provides a mechanism for cancelling hung operations.
<FONT SIZE=2 COLOR="#808080"><P>[
<P>object,
<P>uuid(51973C1a-CB0C-11d0-B5C9-00A0244A0E7A),
<P>pointer_default(unique),
<P>local
<P>]</FONT><FONT FACE="Courier New"></FONT>
<FONT FACE="Courier New" COLOR="#000080"><P>interface</FONT><FONT FACE="Courier New"> IDebugSyncOperation : IUnknown
<P>{
<P></FONT><FONT COLOR="#008000">// Get TargetThread is called by PDM to determine what thread
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// to call Evaluate() in
</FONT><FONT FACE="Courier New"><P>HRESULT GetTargetThread(
<P></FONT><FONT SIZE=2 COLOR="#808080">[out]</FONT><FONT FACE="Courier New"></FONT><A HREF="#IDebugApplicationThread">IDebugApplicationThread</A><A HREF="#IDebugApplicationThread"><FONT FACE="Courier New">IDebugApplicationThread</FONT></A><FONT FACE="Courier New"> **ppatTarget);

<P></FONT><FONT COLOR="#008000">// Execute is called synchronously by the PDM in the target thread. It
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// synchronously peforms the operation and returns. It returns E_ABORT if
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// the operation was aborted with InProgressAbort();
</FONT><FONT FACE="Courier New"><P>HRESULT Execute(
<P></FONT><FONT SIZE=2 COLOR="#808080">[out]</FONT><FONT FACE="Courier New">IUnknown **ppunkResult);

<P></FONT><FONT COLOR="#008000">// InProgressAbort() is called by the PDM, from within the debugger thread,
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// to cancel an operation which is in progress in another thread. The
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// operation should be completed or error out with E_ABORT as soon as
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// possible. E_NOTIMPL can be returned if the operation cannot be cancelled.
</FONT><FONT FACE="Courier New"><P>HRESULT InProgressAbort(void);
<P>}
</FONT>

<H3><A NAME="IDebugAsyncOperation">IDebugAsyncOperation</A></H3>
<P>IDebugAsyncOperation is generally implemented by the PDM, and is obtained by a language engine through IDebugApplication::CreateAsyncDebugOperation(). The language engine can use it to provide asynchronous access to a SyncDebugOperation.
<FONT SIZE=2 COLOR="#808080"><P>[
<P>object,
<P>uuid(51973C1b-CB0C-11d0-B5C9-00A0244A0E7A),
<P>pointer_default(unique),
<P>local
<P>]</FONT><FONT FACE="Courier New"></FONT>
<FONT FACE="Courier New" COLOR="#000080"><P>interface</FONT><FONT FACE="Courier New"> IDebugAsyncOperation : IUnknown
<P>{
<P>HRESULT GetSyncDebugOperation(
<P></FONT><FONT SIZE=2 COLOR="#808080">[out]</FONT> <A HREF="#IDebugSyncOperation">IDebugSyncOperation</A><A HREF="#IDebugSyncOperation"><FONT FACE="Courier New">IDebugSyncOperation</FONT></A><FONT FACE="Courier New"> **ppsdo);

<P></FONT><FONT COLOR="#008000">// Start() causes the asynchronous operation to begin. It asynchronously
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// causes IDebugSyncOperation::Execute() to be called in the thread obtained
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// from IDebugSyncOperation::GetTargetThread(). It should only
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// be called from within the debugger thread, or it will not return until
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// the operation is complete (it degenerates to synchronous).
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// Returns E_UNEXPECTED if an operation is already pending.
</FONT><FONT FACE="Courier New"><P>HRESULT Start(</FONT><A HREF="#IDebugAsyncOperationCallBack">IDebugAsyncOperationCallBack</A><A HREF="#IDebugAsyncOperationCallBack"><FONT FACE="Courier New">IDebugAsyncOperationCallBack</FONT></A><FONT FACE="Courier New"> *padocb);

<P></FONT><FONT COLOR="#008000">// Abort() causes InProgressAbort() to be called on the IDebugSyncOperation
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// object. It is normally called from within the debugger thread to cancel
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// a hung operation. If the abort happens before the request completes,
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// GetResult() will return E_ABORT. E_NOTIMPL may be returned from this
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// function if the operation is not cancellable.
</FONT><FONT FACE="Courier New"><P>HRESULT Abort(void);

<P></FONT><FONT COLOR="#008000">// QueryIsComplete() returns S_OK if the operation is complete; otherwise it
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// returns S_FALSE;
</FONT><FONT FACE="Courier New"><P>HRESULT QueryIsComplete(void);

<P></FONT><FONT COLOR="#008000">// If the request is complete, returns the HRESULT and object parameter
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// returned from IDebugSyncOperation::Execute(). Otherwise, returns
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// E_PENDING.
</FONT><FONT FACE="Courier New"><P>HRESULT GetResult(
<P></FONT><FONT SIZE=2 COLOR="#808080">[out]</FONT><FONT FACE="Courier New"> HRESULT *phrResult,
<P></FONT><FONT SIZE=2 COLOR="#808080">[out]</FONT><FONT FACE="Courier New"> IUnknown **ppunkResult);
<P>}
</FONT>

<H3><A NAME="IDebugAsyncOperationCallBack">IDebugAsyncOperationCallBack</A></H3>
<P>This interface is used to signal events from an IDebugAsyncOperation.
<FONT SIZE=2 COLOR="#808080"><P>[
<P>object,
<P>uuid(51973C1c-CB0C-11d0-B5C9-00A0244A0E7A),
<P>pointer_default(unique),
<P>local
<P>]</FONT><FONT FACE="Courier New"></FONT>
<FONT FACE="Courier New" COLOR="#000080"><P>interface</FONT><FONT FACE="Courier New"> IDebugAsyncOperationCallBack : IUnknown
<P>{
<P></FONT><FONT COLOR="#008000">// onComplete() is fired by the AsyncDebugOperation when a result is available.
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// The event is fired in the debugger thread.
</FONT><FONT FACE="Courier New"><P>HRESULT onComplete(void);
<P>}
</FONT>

<H3><A NAME="IEnumDebugCodeContexts">IEnumDebugCodeContexts</A></H3>
<P>Enumerates code contexts. Generally used to enumerate the code contexts corresponding to a document context.
<P><FONT SIZE=2 COLOR="#808080">[
<P>object,
<P>uuid(51973C1d-CB0C-11d0-B5C9-00A0244A0E7A),
<P>helpstring("IEnumDebugCodeContexts Interface"),
<P>pointer_default(unique)
<P>]</FONT><FONT FACE="Courier New"></FONT>
<FONT FACE="Courier New" COLOR="#000080"><P>interface</FONT><FONT FACE="Courier New"> IEnumDebugCodeContexts : IUnknown {
<P></FONT><FONT SIZE=2 COLOR="#808080">[local]</FONT><FONT FACE="Courier New">
<P>HRESULT </FONT><FONT SIZE=2 COLOR="#808080">__stdcall</FONT><FONT FACE="Courier New"> Next(
<P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New"> ULONG celt,
<P></FONT><FONT SIZE=2 COLOR="#808080">[out]</FONT> <A HREF="#IDebugCodeContext">IDebugCodeContext</A><A HREF="#IDebugCodeContext"><FONT FACE="Courier New">IDebugCodeContext</FONT></A><FONT FACE="Courier New"> **pscc,
<P></FONT><FONT SIZE=2 COLOR="#808080">[out]</FONT><FONT FACE="Courier New"> ULONG *pceltFetched);
<P>HRESULT Skip(
<P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New"> ULONG celt);
<P>HRESULT Reset(void);
<P>HRESULT Clone(
<P></FONT><FONT SIZE=2 COLOR="#808080">[out]</FONT> <A HREF="#IEnumDebugCodeContexts">IEnumDebugCodeContexts</A><A HREF="#IEnumDebugCodeContexts"><FONT FACE="Courier New">IEnumDebugCodeContexts</FONT></A><FONT FACE="Courier New"> **ppescc);
<P>}
</FONT>

<H3><A NAME="DebugStackFrameDescriptor">DebugStackFrameDescriptor</A></H3>
<P>Used to enumerate stack frames and merge output from several enumerators (on the same thread). dwMin and dwLim provide a machine dependent representation of the range of physical addresses associated with this stack frame. This is used by the process debug manager to sort the stack frames from multiple script engines.
<P>By convention, stacks grow down and, as such, on architectures where stacks grow up the addresses should be twos-complemented.
<P>The punkFinal is used during enumerator merging. If punkFinal is non-null, It indicates that the that the current enumerator merging should stop and a new one should be started. The object indicates how the new enumeration is to be started.
<FONT FACE="Courier New" COLOR="#000080"><P>typedef</FONT><FONT FACE="Courier New"> struct tagDebugStackFrameDescriptor
<P>{
<P></FONT><A HREF="#IDebugStackFrame">IDebugStackFrame</A><A HREF="#IDebugStackFrame"><FONT FACE="Courier New">IDebugStackFrame</FONT></A><FONT FACE="Courier New"> *pdsf;
<P>DWORD dwMin;
<P>DWORD dwLim;
<P>BOOL fFinal;
<P>IUnknown *punkFinal;
<P>} </FONT><A HREF="#DebugStackFrameDescriptor">DebugStackFrameDescriptor</A><A HREF="#DebugStackFrameDescriptor"><FONT FACE="Courier New">DebugStackFrameDescriptor</FONT></A><FONT FACE="Courier New">;
</FONT>

<H3><A NAME="IEnumDebugStackFrames">IEnumDebugStackFrames</A></H3>
<P>Enumerates stack frames. Generally used to enumerate the stack frames corresponding to a thread.
<FONT SIZE=2 COLOR="#808080"><P>[
<P>object,
<P>uuid(51973C1e-CB0C-11d0-B5C9-00A0244A0E7A),
<P>helpstring("IEnumDebugStackFrames Interface"),
<P>pointer_default(unique)
<P>]</FONT><FONT FACE="Courier New"></FONT>
<FONT FACE="Courier New" COLOR="#000080"><P>interface</FONT><FONT FACE="Courier New"> IEnumDebugStackFrames : IUnknown
<P>{
<P></FONT><FONT SIZE=2 COLOR="#808080">[local]</FONT><FONT FACE="Courier New">
<P>HRESULT </FONT><FONT SIZE=2 COLOR="#808080">__stdcall</FONT><FONT FACE="Courier New"> Next(
<P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New"> ULONG celt,
<P></FONT><FONT SIZE=2 COLOR="#808080">[out]</FONT> <A HREF="#DebugStackFrameDescriptor">DebugStackFrameDescriptor</A><A HREF="#DebugStackFrameDescriptor"><FONT FACE="Courier New">DebugStackFrameDescriptor</FONT></A><FONT FACE="Courier New"> *prgdsfd,
<P></FONT><FONT SIZE=2 COLOR="#808080">[out]</FONT><FONT FACE="Courier New"> ULONG *pceltFetched);

<P>HRESULT Skip(
<P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New"> ULONG celt);

<P>HRESULT Reset(void);

<P>HRESULT Clone(
<P></FONT><FONT SIZE=2 COLOR="#808080">[out]</FONT> <A HREF="#IEnumDebugStackFrames">IEnumDebugStackFrames</A><A HREF="#IEnumDebugStackFrames"><FONT FACE="Courier New">IEnumDebugStackFrames</FONT></A><FONT FACE="Courier New"> **ppedsf);
<P>}

<P></FONT>

<H2>Smart Host Interfaces</H2>
<P>Below are the details of the interfaces implemented by a smart host. As mentioned earlier, it is possible to avoid implementing these interfaces by using the smart host helper interfaces.
<H3><A NAME="IDebugDocumentInfo">IDebugDocumentInfo</A></H3>
<P>Provides information on a document, which may or may not be instantiated. 
<FONT SIZE=2 COLOR="#808080"><P>[
<P>object,
<P>uuid(51973C1f-CB0C-11d0-B5C9-00A0244A0E7A),
<P>helpstring("IDebugDocumentInfo Interface"),
<P>pointer_default(unique)
<P>]</FONT><FONT FACE="Courier New"></FONT>
<FONT FACE="Courier New" COLOR="#000080"><P>interface</FONT><FONT FACE="Courier New"> IDebugDocumentInfo : IUnknown {
<P></FONT><FONT COLOR="#008000">// Returns the specified name for the document. If the indicated name is
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// not known, E_FAIL is returned.
</FONT><FONT FACE="Courier New"><P>HRESULT GetName(
<P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New"> DOCUMENTNAMETYPE dnt,
<P></FONT><FONT SIZE=2 COLOR="#808080">[out]</FONT><FONT FACE="Courier New"> BSTR *pbstrName);
<P></FONT><FONT COLOR="#008000">// Returns a CLSID describing the document type. This allows the debugger IDE
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// to host custom viewers for this document. returns CLSID_NULL if this document
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// does not have viewable data.
</FONT><FONT FACE="Courier New"><P>HRESULT GetDocumentClassId(
<P></FONT><FONT SIZE=2 COLOR="#808080">[out]</FONT><FONT FACE="Courier New"> CLSID *pclsidDocument);
<P>}
</FONT>

<H3><A NAME="IDebugDocumentProvider">IDebugDocumentProvider</A></H3>
<P>Provides the means for instantiating a document on demand. This indirect means for instanciating a document:
<P>1.Allows lazy loading of the document.
<P>2.Allows the document object to live at the debugger IDE.
<P>3.Allows more then one way of getting to the identical document object.
<P>This effectively segregates the document from its provider; this allows the provider to carry additional runtime context information.
<FONT SIZE=2 COLOR="#808080"><P>[
<P>object,
<P>uuid(51973C20-CB0C-11d0-B5C9-00A0244A0E7A),
<P>helpstring("IDebugDocumentProvider Interface"),
<P>pointer_default(unique)
<P>]</FONT><FONT FACE="Courier New"></FONT>
<FONT FACE="Courier New" COLOR="#000080"><P>interface</FONT><FONT FACE="Courier New"> IDebugDocumentProvider : IDebugDocumentInfo {
<P></FONT><FONT COLOR="#008000">// Causes the document to be instantiated if it does not already exist.
</FONT><FONT FACE="Courier New"><P>HRESULT GetDocument(
<P></FONT><FONT SIZE=2 COLOR="#808080">[out]</FONT> <A HREF="#IDebugDocument">IDebugDocument</A><A HREF="#IDebugDocument"><FONT FACE="Courier New">IDebugDocument</FONT></A><FONT FACE="Courier New"> **ppssd);
<P>}
</FONT>

<H3><A NAME="IDebugDocument">IDebugDocument</A></H3>
<P>The base interface to all debug documents.
<FONT SIZE=2 COLOR="#808080"><P>[
<P>object,
<P>uuid(51973C21-CB0C-11d0-B5C9-00A0244A0E7A),
<P>pointer_default(unique)
<P>]</FONT><FONT FACE="Courier New"></FONT>
<FONT FACE="Courier New" COLOR="#000080"><P>interface</FONT><FONT FACE="Courier New"> IDebugDocument : IDebugDocumentInfo {
<P>}
</FONT>

<H3><A NAME="IDebugDocumentText">IDebugDocumentText</A></H3>
<P>The interface to a text only debug document.
<P>Conventions:
<P>1.Both character positions and line numbers are zero based.
<P>2.Character-positions represent character offsets; they do not represent byte or word offsets. For Win32, a character-position is an Unicode offset. 
<P>Note: the use of line-number based text management is not recommended; instead it is recommended that character-position based management be used. The line to character-position mapping functions described in this interface may be removed.
<FONT SIZE=2 COLOR="#808080"><P>[
<P>object,
<P>uuid(51973C22-CB0C-11d0-B5C9-00A0244A0E7A),
<P>pointer_default(unique)
<P>]</FONT><FONT FACE="Courier New"></FONT>
<FONT FACE="Courier New" COLOR="#000080"><P>interface</FONT><FONT FACE="Courier New"> IDebugDocumentText : </FONT><A HREF="#IDebugDocument">IDebugDocument</A><A HREF="#IDebugDocument"><FONT FACE="Courier New">IDebugDocument</FONT></A><FONT FACE="Courier New"> {
<P></FONT><FONT COLOR="#008000">// Returns the attributes of the document.
</FONT><FONT FACE="Courier New"><P>HRESULT GetDocumentAttributes(
<P></FONT><FONT SIZE=2 COLOR="#808080">[out]</FONT><FONT FACE="Courier New">TEXT_DOC_ATTR *ptextdocattr);

<P></FONT><FONT COLOR="#008000">// Returns the size of the document.
</FONT><FONT FACE="Courier New"><P>HRESULT GetSize(
<P></FONT><FONT SIZE=2 COLOR="#808080">[out]</FONT><FONT FACE="Courier New"> ULONG *pcNumLines,</FONT><FONT COLOR="#008000">// NULL means do not return the number of lines.
</FONT><FONT FACE="Courier New"><P></FONT><FONT SIZE=2 COLOR="#808080">[out]</FONT><FONT FACE="Courier New"> ULONG *pcNumChars);</FONT><FONT COLOR="#008000">// NULL means do not return the number of characters.
</FONT><FONT FACE="Courier New">
<P></FONT><FONT COLOR="#008000">// Returns character-position corresponding to the first character of a line.
</FONT><FONT FACE="Courier New"><P>HRESULT GetPositionOfLine(
<P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New"> ULONG cLineNumber,
<P></FONT><FONT SIZE=2 COLOR="#808080">[out]</FONT><FONT FACE="Courier New"> ULONG *pcCharacterPosition);

<P></FONT><FONT COLOR="#008000">// Returns the line-number and, optionally, the character offset within the line
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// that corresponds to the given character-position.
</FONT><FONT FACE="Courier New"><P>HRESULT GetLineOfPosition(
<P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New"> ULONG cCharacterPosition,
<P></FONT><FONT SIZE=2 COLOR="#808080">[out]</FONT><FONT FACE="Courier New"> ULONG *pcLineNumber,
<P></FONT><FONT SIZE=2 COLOR="#808080">[out]</FONT><FONT FACE="Courier New"> ULONG *pcCharacterOffsetInLine); </FONT><FONT COLOR="#008000">// NULL means do not return a value.
</FONT><FONT FACE="Courier New">
<P></FONT><FONT COLOR="#008000">// Retrieves the characters and/or the character attributes associated with
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// a character-position range; where a character position range is specified by
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// a character-position and a number of characters.
</FONT><FONT FACE="Courier New"><P>HRESULT GetText(
<P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New"> ULONG cCharacterPosition,
<P></FONT><FONT COLOR="#008000">// Specifies a character text buffer. NULL means do not return characters.
</FONT><FONT FACE="Courier New"><P></FONT><FONT SIZE=2 COLOR="#808080">[in, out, length_is(*pcNumChars), size_is(cMaxChars)]</FONT><FONT FACE="Courier New"> WCHAR *pcharText,
<P></FONT><FONT COLOR="#008000">// Specifies a character attribute buffer. NULL means do not return attributes.
</FONT><FONT FACE="Courier New"><P></FONT><FONT SIZE=2 COLOR="#808080">[in, out, length_is(*pcNumChars), size_is(cMaxChars), ptr]</FONT><FONT FACE="Courier New"> SOURCE_TEXT_ATTR *pstaTextAttr,
<P></FONT><FONT COLOR="#008000">// Indicates the actual number of characters/attributes returned. Must be set to zero
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// before the call.
</FONT><FONT FACE="Courier New"><P></FONT><FONT SIZE=2 COLOR="#808080">[in, out]</FONT><FONT FACE="Courier New"> ULONG *pcNumChars,
<P></FONT><FONT COLOR="#008000">// Specifies the number maximum number of character desired.
</FONT><FONT FACE="Courier New"><P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New"> ULONG cMaxChars);

<P></FONT><FONT COLOR="#008000">// Returns the character-position range corresponding to a document context. The document
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// context provided must be associated with this document.
</FONT><FONT FACE="Courier New"><P>HRESULT GetPositionOfContext(
<P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT> <A HREF="#IDebugDocumentContext">IDebugDocumentContext</A><A HREF="#IDebugDocumentContext"><FONT FACE="Courier New">IDebugDocumentContext</FONT></A><FONT FACE="Courier New"> *psc,
<P></FONT><FONT SIZE=2 COLOR="#808080">[out]</FONT><FONT FACE="Courier New"> ULONG *pcCharacterPosition,
<P></FONT><FONT SIZE=2 COLOR="#808080">[out]</FONT><FONT FACE="Courier New">ULONG *cNumChars);

<P></FONT><FONT COLOR="#008000">// Creates a document context object corresponding to the provided character position range.
</FONT><FONT FACE="Courier New"><P>HRESULT GetContextOfPosition(
<P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New"> ULONG cCharacterPosition,
<P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New"> ULONG cNumChars,
<P></FONT><FONT SIZE=2 COLOR="#808080">[out]</FONT> <A HREF="#IDebugDocumentContext">IDebugDocumentContext</A><A HREF="#IDebugDocumentContext"><FONT FACE="Courier New">IDebugDocumentContext</FONT></A><FONT FACE="Courier New"> **ppsc);
<P>}
</FONT>

<H3><A NAME="IDebugDocumentTextEvents">IDebugDocumentTextEvents</A></H3>
<P>Provides events indicating changes to the associated text document. Note: The text alterations are reflected in the document at the time the events on this interface are fired. Event handlers may retrieve the new text using IDebugDocumentText.
<FONT SIZE=2 COLOR="#808080"><P>[
<P>object,
<P>uuid(51973C23-CB0C-11d0-B5C9-00A0244A0E7A),
<P>pointer_default(unique)
<P>]</FONT><FONT FACE="Courier New"></FONT>
<FONT FACE="Courier New" COLOR="#000080"><P>interface</FONT><FONT FACE="Courier New"> IDebugDocumentTextEvents : IUnknown
<P>{
<P></FONT><FONT COLOR="#008000">// Indicates that the underlying document has been destroyed and is no longer valid.
</FONT><FONT FACE="Courier New"><P>HRESULT onDestroy(void);

<P></FONT><FONT COLOR="#008000">// Indicates that new text has been added to the document. Example: progressive loading
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// of HTML.
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">//
</FONT><FONT FACE="Courier New"><P>HRESULT onInsertText(
<P></FONT><FONT COLOR="#008000">// The position where the new text is inserted.
</FONT><FONT FACE="Courier New"><P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New"> ULONG cCharacterPosition,
<P></FONT><FONT COLOR="#008000">// The number of characters that have been inserted.
</FONT><FONT FACE="Courier New"><P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New"> ULONG cNumToInsert);

<P></FONT><FONT COLOR="#008000">// Indicates that text has been removed from the document.
</FONT><FONT FACE="Courier New"><P>HRESULT onRemoveText(
<P></FONT><FONT COLOR="#008000">// The character-position of the first character removed.
</FONT><FONT FACE="Courier New"><P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New"> ULONG cCharacterPosition,
<P></FONT><FONT COLOR="#008000">// The number of characters removed.
</FONT><FONT FACE="Courier New"><P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New"> ULONG cNumToRemove);

<P></FONT><FONT COLOR="#008000">// Indicates that text has been replaced.
</FONT><FONT FACE="Courier New"><P>HRESULT onReplaceText(
<P></FONT><FONT COLOR="#008000">// The starting character-position of the character-position range
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// that is being replaced.
</FONT><FONT FACE="Courier New"><P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New"> ULONG cCharacterPosition,
<P></FONT><FONT COLOR="#008000">// The number of characters replaced.
</FONT><FONT FACE="Courier New"><P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New"> ULONG cNumToReplace);

<P></FONT><FONT COLOR="#008000">// Indicates that the text attributes associated with the underlying character-position
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// range has changed.
</FONT><FONT FACE="Courier New"><P>HRESULT onUpdateTextAttributes(
<P></FONT><FONT COLOR="#008000">// The character-position of the first character whose attributes have changed.
</FONT><FONT FACE="Courier New"><P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New"> ULONG cCharacterPosition,
<P></FONT><FONT COLOR="#008000">// The number of characters in the range.
</FONT><FONT FACE="Courier New"><P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New"> ULONG cNumToUpdate);

<P></FONT><FONT COLOR="#008000">// Indicates that the document attributes have changed.
</FONT><FONT FACE="Courier New"><P>HRESULT onUpdateDocumentAttributes(
<P></FONT><FONT COLOR="#008000">// The new document attributes.
</FONT><FONT FACE="Courier New"><P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New"> TEXT_DOC_ATTR textdocattr);
<P>}
</FONT>

<H2><A NAME="IDebugDocumentHelper">IDebugDocumentHelper</A></H2>
<P>IDebugDocumentHelper greatly simplifies the task of creating a smart host for ActiveDebugging.
<P>IDebugDocumentHelper automatically provides implementations for IDebugDocumentProvider, IDdebugDocument, IDebugDocumentText, IDebugDocumentContext, IDebugDocumentTextEvents, and many of the other interfaces necessary for smart hosting.
<P>To be a smart host using IDebugDocumentHelper, a host application only to do only three two things:
<P>(1) CoCreate an IProcessDebugManager and use it to add your application to the list of debuggable applications.
<P>(2) create an IDebugDocumentHelper for each host document and make the appropriate calls to define the document name, parent document, text, and script blocks.
<P>(3) Implement IActiveScriptSiteDebug on your IActiveScriptSite object (implemented already for Active Scripting. The only non-trivial method on IActiveScriptSiteDebug simply delegates to the helper.
<P>Additionally, the host can optionally implement IDebugDocumentHost if it needs additional control over syntax color, document context creation, and other extended functionality. 
<P>The main limitation on the smart host helper is that can only handle documents whose contents change or shrink after they have been added (though documents can expand, of course.) For many smart hosts, however, the functionality it provides is exactly what is needed. 
<P>Below we go into each of the steps in more detail.
<P><FONT FACE="Arial,Helvetica"><B><I>Create an Application Object</I></B></FONT>
<P>Before the smart host helper can be used, it is necessary to create an IDebugApplication object to represent your application in the debugger. The steps for creating an application object are as follows:
<P>(1) Create an instance of the process debug manager using CoCreateInstance.
<P>(2) Call IProcessDebugManager::CreateApplication().
<P>(3) Set the name on the application using SetName().
<P>(4) Add the application object to the list of debuggable applications using AddApplication().
<P>Below is code to do this, minus error-check and other niceties.
<P>
<P>CoCreateInstance(CLSID_ProcessDebugManager, NULL,<DIR>
<DIR>

<P>CLSCTX_INPROC_SERVER | CLSCTX_INPROC_HANDLER <DIR>
<DIR>
<DIR>
<DIR>

<P>| CLSCTX_LOCAL_SERVER,</DIR>
</DIR>
</DIR>
</DIR>
</DIR>
</DIR>

<P>IID_IProcessDebugManager, (void **)&amp;g_ppdm);
<P>g_ppdm-&gt;CreateApplication(&amp;g_pda);
<P>g_pda-&gt;SetName(L"My cool application");
<P>g_ppdm-&gt;AddApplication(g_pda, &amp;g_dwAppCookie);

<P>

<H3>Using IDebugDocumentHelper</H3>
<P>The minimal sequence of steps for using the helper is as follows:
<P>(1) For each host document, create a helper using IProcessDebugManager::CreateDebugDocumentHelper.
<P>(2) Call Init on the helper, giving the name, document attributes, etc.
<P>(3) Call Attach with parent helper for the document (or NULL if the document is the root) to define the position of the document in the tree and make it visible to the debugger
<P>(4) Call AddDBCSText() or AddUnicodeText() to define the text of the document. (These can be called multiple times if document is downloaded incrementally, as in the case of a browser.)
<P>(5) Call DefineScriptBlock to define the ranges for each script block and the associated script engines.

<H3>Implementing IActiveScriptSiteDebug</H3>
<P>To implement<I> GetDocumentContextFromPosition</I>, get the helper corresponding to the given site, then get the starting document offset for the given source context, as follows:
<P>pddh-&gt;GetScriptBlockInfo(dwSourceContext, NULL, &amp;ulStartPos, NULL);
<P>Next, use the helper to create a new document context for the given character offset:
<P>pddh-&gt;CreateDebugDocumentContext(ulStartPos + uCharacterOffset, cChars, &amp;pddcNew);
<P>To implement <I>GetRootApplicationNode </I>, simply call IDebugApplication::GetRootNode.  To implement <I>GetDebugApplication </I>, simply return the IDebugApplication you initially created using the process debug manager.

<H3>The optional IDebugDocumentHost interface </H3>
<P>The host can provide an implementation of IDebugDocumentHost using IDebugDocumentHelper::SetHost that gives it additional control over the helper. Here are some of the key things the host interface allows you to do:
<P>(1) Add text using AddDeferredText so that the host doesn't have to provide the actual characters immediately. When the characters are really needed, the helper will call IDebugDocumentHost::GetDeferredCharacters on the host.
<P>(2) Override the default syntax coloring provided by the helper. The helper will call IDebugDocumentHost::GetScriptTextAttributes when it needs to know the coloring for a range of characters, falling back on its default implementation if the host return E_NOTIMPL.
<P>(3) Providing a controlling unknown for document contexts created by the helper my implementing IDebugDocumentHost::OnCreateDocumentContext. This allows the host to override the functionality of the default document context implementation.
<P>(4) Provide a path name in the file system for the document. Some debugging UIs will use this to permit the user to edit and save changes to the document. IDebugDocumentHost::NotifyChanged will be called to notify the host after the document has been saved.
<FONT SIZE=2 COLOR="#808080"><P>[
<P>object,
<P>uuid(51973C26-CB0C-11d0-B5C9-00A0244A0E7A),
<P>helpstring("IDebugDocumentHelper Interface"),
<P>pointer_default(unique)
<P>]</FONT><FONT FACE="Courier New"></FONT>
<FONT FACE="Courier New" COLOR="#000080"><P>interface</FONT><FONT FACE="Courier New"> IDebugDocumentHelper : IUnknown
<P>{
<P></FONT><FONT COLOR="#008000">// Initialize a debug doc helper with the given name and
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// initial attributes.
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">//
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// Note: The document will not actually appear in the tree
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// until Attach is called.
</FONT><FONT FACE="Courier New"><P>HRESULT Init(
<P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New"></FONT><A HREF="#IDebugApplication">IDebugApplication</A><A HREF="#IDebugApplication"><FONT FACE="Courier New">IDebugApplication</FONT></A><FONT FACE="Courier New"> *pda,
<P></FONT><FONT SIZE=2 COLOR="#808080">[in, string]</FONT><FONT FACE="Courier New">LPCOLESTR pszShortName,
<P></FONT><FONT SIZE=2 COLOR="#808080">[in, string]</FONT><FONT FACE="Courier New">LPCOLESTR pszLongName,
<P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New">TEXT_DOC_ATTR docAttr
<P>);

<P></FONT><FONT COLOR="#008000">// Add the document to the doc tree, using pddhParent as the parent.
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// If the ppdhParent is NULL, the document will be top-level.
</FONT><FONT FACE="Courier New"><P>HRESULT Attach(</FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT> <A HREF="#IDebugDocumentHelper">IDebugDocumentHelper</A><A HREF="#IDebugDocumentHelper"><FONT FACE="Courier New">IDebugDocumentHelper</FONT></A><FONT FACE="Courier New"> *pddhParent);

<P></FONT><FONT COLOR="#008000">// Remove the document from the doc tree.
</FONT><FONT FACE="Courier New"><P>HRESULT Detach();

<P></FONT><FONT COLOR="#008000">// Add the given set of unicode characters to end of the document.
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// (This will generate IDebugDocumentTextEvent notifications.)
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">//
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// If this method is called after AddDeferredText has been called,
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// E_FAIL will be returned.
</FONT><FONT FACE="Courier New"><P>HRESULT AddUnicodeText(
<P></FONT><FONT SIZE=2 COLOR="#808080">[in, string]</FONT><FONT FACE="Courier New"> LPCOLESTR pszText
<P>);

<P></FONT><FONT COLOR="#008000">// Add the given set of DBCS characters to end of the document.
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// (This will generate IDebugDocumentTextEvent notifications.)
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">//
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// If this method is called after AddDeferredText has been called,
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// E_FAIL will be returned.
</FONT><FONT FACE="Courier New"><P>HRESULT AddDBCSText(
<P></FONT><FONT SIZE=2 COLOR="#808080">[in, string]</FONT><FONT FACE="Courier New"> LPCSTR pszText
<P>);

<P></FONT><FONT COLOR="#008000">// Set the DebugDocumentHost interface.
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// If provided, this interface will be used for
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// smart-host syntax coloring, fetching deferred text, and returning
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// controlling unknowns for newly created document contexts.
</FONT><FONT FACE="Courier New"><P>HRESULT SetDebugDocumentHost(
<P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT> <A HREF="#IDebugDocumentHost">IDebugDocumentHost</A><A HREF="#IDebugDocumentHost"><FONT FACE="Courier New">IDebugDocumentHost</FONT></A><FONT FACE="Courier New">* pddh
<P>);

<P></FONT><FONT COLOR="#008000">// Notify the helper that the given text is available, but don't actually
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// provide the characters.
</FONT><FONT FACE="Courier New"><P>
<P></FONT><FONT COLOR="#008000">// This allows the host to defer providing the characters unless they
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// are actually needed, while still allowing the helper to generate
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// accurate notifications and size information.
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">//
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// dwTextStartCookie is a cookie, defined by the host, that represents
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// the starting position of the text. (For example, in a host that
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// represents text in DBCS, the cookie could be a byte offset.)
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// This cookie will be provided in subsequent calls to GetText.
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">//
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// NB: It is assumed that a single call to
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// GetText can get characters from multiple calls to AddDeferredText.
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// The helper classes may also ask for the same range of deferred
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// characters more than once.
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">//
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// It is an error to mix calls to AddDeferredText with calls to
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// AddUnicodeText or AddDBCSText-- Doing so will cause E_FAIL to be
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// returned.
</FONT><FONT FACE="Courier New"><P>HRESULT AddDeferredText(
<P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New"> ULONG cChars,</FONT><FONT COLOR="#008000">// number of (Unicode) characters to add
</FONT><FONT FACE="Courier New"><P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New"> DWORD dwTextStartCookie
<P></FONT><FONT COLOR="#008000">// host-defined cookie representing the starting position of the text.
</FONT><FONT FACE="Courier New"><P>);

<P></FONT><FONT COLOR="#008000">// Notify the helper that a particular range of
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// characters is a script block handled by the given script engine.
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// All syntax coloring and code context lookups for that range will be
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// delegated to that script engine.
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">//
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// This method would be used by a smart host whose documents contained
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// embedded script blocks, or by a language engine containing embedded
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// scripts for other languages.
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">//
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// DefineScriptBlock should be called <I>after </I>the text has been
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// added (via AddDBCSText, etc) but before the script script block
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// has been parsed (via IActiveScriptParse).
</FONT><FONT FACE="Courier New"><P>HRESULT DefineScriptBlock(
<P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New"> ULONG ulCharOffset,
<P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New"> ULONG cChars,
<P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New"> IActiveScript* pas,
<P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New"> BOOL fScriptlet,
<P></FONT><FONT SIZE=2 COLOR="#808080">[out]</FONT><FONT FACE="Courier New"> DWORD* pdwSourceContext
<P>);

<P></FONT><FONT COLOR="#008000">// Set the default attribute to use for text that is not in a
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// script block. (If not explicitly set, the default attributes for
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// text outside of a script block is SOURCETEXT_ATTR_NONSOURCE.)
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">//
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// This would allow, for example, for text outside of script blocks
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// to be colored grey and marked read-only.
</FONT><FONT FACE="Courier New"><P>HRESULT SetDefaultTextAttr(SOURCE_TEXT_ATTR staTextAttr);

<P></FONT><FONT COLOR="#008000">// Explicilty set the attributes on a range of text, overriding any
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// other attributes on that text.
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">//
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// It is an error to set the attributes on a text range that has not
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// yet been added using AddText.
</FONT><FONT FACE="Courier New"><P>HRESULT SetTextAttributes(
<P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New"> ULONG ulCharOffset,
<P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New"> ULONG cChars,
<P></FONT><FONT SIZE=2 COLOR="#808080">[in, length_is(cChars), size_is(cChars)]</FONT><FONT FACE="Courier New">
<P>SOURCE_TEXT_ATTR* pstaTextAttr);

<P></FONT><FONT COLOR="#008000">// Set a new long name for the document
</FONT><FONT FACE="Courier New"><P>HRESULT SetLongName(
<P></FONT><FONT SIZE=2 COLOR="#808080">[in, string]</FONT><FONT FACE="Courier New"> LPCOLESTR pszLongName);

<P></FONT><FONT COLOR="#008000">// Set a new short name for the document
</FONT><FONT FACE="Courier New"><P>HRESULT SetShortName(
<P></FONT><FONT SIZE=2 COLOR="#808080">[in, string]</FONT><FONT FACE="Courier New"> LPCOLESTR pszShortName);

<P></FONT><FONT COLOR="#008000">// Define a new set of document attributes
</FONT><FONT FACE="Courier New"><P>HRESULT SetDocumentAttr(
<P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New"> TEXT_DOC_ATTR pszAttributes
<P>);

<P></FONT><FONT COLOR="#008000">// Return the debug application node corresponding to this document
</FONT><FONT FACE="Courier New"><P>HRESULT GetDebugApplicationNode(
<P></FONT><FONT SIZE=2 COLOR="#808080">[out]</FONT> <A HREF="#IDebugApplicationNode">IDebugApplicationNode</A><A HREF="#IDebugApplicationNode"><FONT FACE="Courier New">IDebugApplicationNode</FONT></A><FONT FACE="Courier New"> **ppdan);

<P></FONT><FONT COLOR="#008000">// Once a script block has been defined, this method allows the
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// associate range and script engine to be retrieved.
</FONT><FONT FACE="Courier New"><P>HRESULT GetScriptBlockInfo(
<P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New"> DWORD dwSourceContext,
<P></FONT><FONT SIZE=2 COLOR="#808080">[out]</FONT><FONT FACE="Courier New">IActiveScript** ppasd,
<P></FONT><FONT SIZE=2 COLOR="#808080">[out]</FONT><FONT FACE="Courier New"> ULONG *piCharPos,
<P></FONT><FONT SIZE=2 COLOR="#808080">[out]</FONT><FONT FACE="Courier New">ULONG *pcChars);

<P></FONT><FONT COLOR="#008000">// Allows the host to create a new debug document context
</FONT><FONT FACE="Courier New"><P>HRESULT CreateDebugDocumentContext(
<P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New">ULONG iCharPos,
<P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New">ULONG cChars,
<P></FONT><FONT SIZE=2 COLOR="#808080">[out]</FONT><FONT FACE="Courier New"></FONT><A HREF="#IDebugDocumentContext">IDebugDocumentContext</A><A HREF="#IDebugDocumentContext"><FONT FACE="Courier New">IDebugDocumentContext</FONT></A><FONT FACE="Courier New">** ppddc);


<P></FONT><FONT COLOR="#008000">// Bring this document to the top in the debugger UI.
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// If the debugger isn't started already, start it now.
</FONT><FONT FACE="Courier New"><P>HRESULT BringDocumentToTop();

<P></FONT><FONT COLOR="#008000">// Bring the given context in this document to the top
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// in the debugger UI.
</FONT><FONT FACE="Courier New"><P>HRESULT BringDocumentContextToTop(</FONT><A HREF="#IDebugDocumentContext">IDebugDocumentContext</A><A HREF="#IDebugDocumentContext"><FONT FACE="Courier New">IDebugDocumentContext</FONT></A><FONT FACE="Courier New"> *pddc);
<P>};
</FONT>

<H3><A NAME="IDebugDocumentHost">IDebugDocumentHost</A></H3>
<P>The interface from the IDebugDocumentHelper back to the smart host or language engine. This interface exposes host specific functionality such as syntax coloring,
<FONT SIZE=2 COLOR="#808080"><P>[
<P>object,
<P>uuid(51973C27-CB0C-11d0-B5C9-00A0244A0E7A),
<P>helpstring("IDebugDocumentHost Interface"),
<P>pointer_default(unique)
<P>]</FONT><FONT FACE="Courier New"></FONT>
<FONT FACE="Courier New" COLOR="#000080"><P>interface</FONT><FONT FACE="Courier New"> IDebugDocumentHost : IUnknown
<P>{
<P></FONT><FONT COLOR="#008000">// Return a particular range of characters in the original host document,
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// added using AddDeferredText.
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">//
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// It is acceptable for a host to return E_NOTIMPL for this method,
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// as long as the host doesn't call AddDeferredText.
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">//
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// (Note that this is text from the _original_ document. The host
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// does not need to be responsible for keeping track of edits, etc.)
</FONT><FONT FACE="Courier New"><P>HRESULT GetDeferredText(
<P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New"> DWORD dwTextStartCookie,
<P></FONT><FONT COLOR="#008000">// Specifies a character text buffer. NULL means do not return characters.
</FONT><FONT FACE="Courier New"><P></FONT><FONT SIZE=2 COLOR="#808080">[in, out, length_is(*pcNumChars), size_is(cMaxChars)]</FONT><FONT FACE="Courier New"> WCHAR *pcharText,
<P></FONT><FONT COLOR="#008000">// Specifies a character attribute buffer. NULL means do not return attributes.
</FONT><FONT FACE="Courier New"><P></FONT><FONT SIZE=2 COLOR="#808080">[in, out, length_is(*pcNumChars), size_is(cMaxChars)]</FONT><FONT FACE="Courier New"> SOURCE_TEXT_ATTR *pstaTextAttr,
<P></FONT><FONT COLOR="#008000">// Indicates the actual number of characters/attributes returned. Must be set to zero
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// before the call.
</FONT><FONT FACE="Courier New"><P></FONT><FONT SIZE=2 COLOR="#808080">[in, out]</FONT><FONT FACE="Courier New"> ULONG *pcNumChars,
<P></FONT><FONT COLOR="#008000">// Specifies the number maximum number of character desired.
</FONT><FONT FACE="Courier New"><P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New"> ULONG cMaxChars);

<P></FONT><FONT COLOR="#008000">// Return the text attributes for an arbitrary block of document text.
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// It is acceptable for hosts to return E_NOTIMPL, in which case the
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// default attributes are used.
</FONT><FONT FACE="Courier New"><P>HRESULT GetScriptTextAttributes(
<P></FONT><FONT COLOR="#008000">// The script block text. This string need not be null terminated.
</FONT><FONT FACE="Courier New"><P></FONT><FONT SIZE=2 COLOR="#808080">[in, size_is(uNumCodeChars)]</FONT><FONT FACE="Courier New">LPCOLESTRpstrCode,
<P></FONT><FONT COLOR="#008000">// The number of characters in the script block text.
</FONT><FONT FACE="Courier New"><P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New">ULONGuNumCodeChars,
<P></FONT><FONT COLOR="#008000">// See IActiveScriptParse::ParseScriptText for a description of this argument.
</FONT><FONT FACE="Courier New"><P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New">LPCOLESTRpstrDelimiter,
<P></FONT><FONT COLOR="#008000">// See IActiveScriptParse::ParseScriptText for a description of this argument.
</FONT><FONT FACE="Courier New"><P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New">DWORDdwFlags,
<P></FONT><FONT COLOR="#008000">// Buffer to contain the returned attributes.
</FONT><FONT FACE="Courier New"><P></FONT><FONT SIZE=2 COLOR="#808080">[in, out, size_is(uNumCodeChars)]</FONT><FONT FACE="Courier New">SOURCE_TEXT_ATTR *pattr);

<P></FONT><FONT COLOR="#008000">// Notify the host that a new document context is being created
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// and allow the host to optionally return a controlling unknown
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// for the new context.
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">//
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// This allows the host to add new functionality to the helper-provided
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// document contexts. It is acceptable for the host to return E_NOTIMPL
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// or a null outer unknown for this method, in which case the context is
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// used "as is".
</FONT><FONT FACE="Courier New"><P>HRESULT OnCreateDocumentContext(
<P></FONT><FONT SIZE=2 COLOR="#808080">[out]</FONT><FONT FACE="Courier New"> IUnknown** ppunkOuter);

<P></FONT><FONT COLOR="#008000">// Return the full path (including file name) to the document's source file.
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">//*pfIsOriginalPath is TRUE if the path refers to the original file for the document.
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">//*pfIsOriginalPath is FALSE if the path refers to a newly created temporary file
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">//Returns E_FAIL if no source file can be created/determined.
</FONT><FONT FACE="Courier New"><P>HRESULT GetPathName(
<P></FONT><FONT SIZE=2 COLOR="#808080">[out]</FONT><FONT FACE="Courier New"> BSTR *pbstrLongName,
<P></FONT><FONT SIZE=2 COLOR="#808080">[out]</FONT><FONT FACE="Courier New"> BOOL *pfIsOriginalFile);

<P></FONT><FONT COLOR="#008000">// Return just the name of the document, with no path information.
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// (Used for "Save As...")
</FONT><FONT FACE="Courier New"><P>HRESULT GetFileName(
<P></FONT><FONT SIZE=2 COLOR="#808080">[out]</FONT><FONT FACE="Courier New"> BSTR *pbstrShortName);

<P></FONT><FONT COLOR="#008000">// Notify the host that the document's source file has been saved and
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// that its contents should be refreshed.
</FONT><FONT FACE="Courier New"><P>HRESULT NotifyChanged();
<P>};
</FONT>

<H3><A NAME="IDebugDocumentContext">IDebugDocumentContext</A></H3>
<p>Abstract representation of a portion of the debug document. For text documents this consists of a character-position range.
<FONT SIZE=2 COLOR="#808080"><P>[
<P>object,
<P>uuid(51973C28-CB0C-11d0-B5C9-00A0244A0E7A),
<P>pointer_default(unique)
<P>]</FONT><FONT FACE="Courier New"></FONT>
<FONT FACE="Courier New" COLOR="#000080"><P>interface</FONT><FONT FACE="Courier New"> IDebugDocumentContext : IUnknown
<P>{
<P></FONT><FONT COLOR="#008000">// Returns the document that contains this context.
</FONT><FONT FACE="Courier New"><P>HRESULT GetDocument(
<P></FONT><FONT SIZE=2 COLOR="#808080">[out]</FONT> <A HREF="#IDebugDocument">IDebugDocument</A><A HREF="#IDebugDocument"><FONT FACE="Courier New">IDebugDocument</FONT></A><FONT FACE="Courier New"> **ppsd);

<P></FONT><FONT COLOR="#008000">// Enumerates the code contexts associated with this document context. Generally there will
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// only be one code context but there are important exceptions, such as include file
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// or templates (in C++).
</FONT><FONT FACE="Courier New"><P>HRESULT EnumCodeContexts(
<P></FONT><FONT SIZE=2 COLOR="#808080">[out]</FONT> <A HREF="#IEnumDebugCodeContexts">IEnumDebugCodeContexts</A><A HREF="#IEnumDebugCodeContexts"><FONT FACE="Courier New">IEnumDebugCodeContexts</FONT></A><FONT FACE="Courier New"> **ppescc);
<P>}

</FONT>

<H3>Debugger UI interfaces</H3>
<P>Below are the interfaces that allow other components to launch and interface with the debugger UI.

<H3><A NAME="IDebugSessionProvider">IDebugSessionProvider</A></H3>
<P>The primary interface provided by a debugger IDE to enable host and language initiated debugging. Its sole purpose is to establish a debug session for a running application.
<FONT FACE="Courier New"><P>cpp_quote( "EXTERN_C </FONT><FONT FACE="Courier New" COLOR="#000080">const</FONT><FONT FACE="Courier New"> CLSID CLSID_DefaultDebugSessionProvider;")
</FONT><FONT SIZE=2 COLOR="#808080"><P>[
<P>object,
<P>uuid(51973C29-CB0C-11d0-B5C9-00A0244A0E7A),
<P>helpstring("IDebugSessionProvider Interface"),
<P>pointer_default(unique)
<P>]</FONT><FONT FACE="Courier New"></FONT>
<FONT FACE="Courier New" COLOR="#000080"><P>interface</FONT><FONT FACE="Courier New"> IDebugSessionProvider : IUnknown
<P>{
<P></FONT><FONT COLOR="#008000">// Initiates a debug session with the specified application. The debugger should
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// call IRemoteDebugApplication::ConnectDebugger before returning from this call.
</FONT><FONT FACE="Courier New"><P>HRESULT StartDebugSession(
<P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New"></FONT><A HREF="#IRemoteDebugApplication">IRemoteDebugApplication</A><A HREF="#IRemoteDebugApplication"><FONT FACE="Courier New">IRemoteDebugApplication</FONT></A><FONT FACE="Courier New"> *pda);
<P>};

</FONT>

<H3><A NAME="IApplicationDebugger">IApplicationDebugger</A></H3>
<P>This is the primary interface exposed by a debugger IDE.
<FONT SIZE=2 COLOR="#808080"><P>[
<P>object,
<P>uuid(51973C2a-CB0C-11d0-B5C9-00A0244A0E7A),
<P>helpstring("IApplicationDebugger Interface"),
<P>pointer_default(unique)
<P>]</FONT><FONT FACE="Courier New"></FONT>
<FONT FACE="Courier New" COLOR="#000080"><P>interface</FONT><FONT FACE="Courier New"> IApplicationDebugger : IUnknown
<P>{
<P></FONT><FONT COLOR="#008000">// Indicates if the debugger is alive. Should always return S_OK. If the debugger
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// has rudely shut down COM will return an error from the marshalling proxy.
</FONT><FONT FACE="Courier New"><P>HRESULT QueryAlive(void);
<P></FONT><FONT COLOR="#008000">// Provides a mechanism for hosts and language engines running out-of-process to the
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// debugger to create objects in the debugger process. This can be used for any purpose,
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// including extending the debugger UI. This method simply delegates to CoCreateInstance.
</FONT><FONT FACE="Courier New"><P>HRESULT CreateInstanceAtDebugger(
<P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New">REFCLSID rclsid,</FONT><FONT COLOR="#008000">// Class identifier (CLSID) of the object
</FONT><FONT FACE="Courier New"><P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New">IUnknown *pUnkOuter,</FONT><FONT COLOR="#008000">// Object is or isn't part of an aggregate
</FONT><FONT FACE="Courier New"><P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New">DWORD dwClsContext,</FONT><FONT COLOR="#008000">// Context for running executable code
</FONT><FONT FACE="Courier New"><P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New">REFIID riid,</FONT><FONT COLOR="#008000">// Interface identifier
</FONT><FONT FACE="Courier New"><P></FONT><FONT SIZE=2 COLOR="#808080">[out, iid_is(riid)]</FONT><FONT FACE="Courier New">IUnknown **ppvObject);
<P></FONT><FONT COLOR="#008000">// Points to requested interface pointer
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// This method is called when IDebugApplication::DebugOutput is called. The debugger
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// can use this to display the string in an output window.
</FONT><FONT FACE="Courier New"><P>HRESULT onDebugOutput(
<P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New"> LPCOLESTR pstr);
<P></FONT><FONT COLOR="#008000">// This method is called when a breakpoint is hit. The application will remain
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// suspended until the debugger IDE calls IDebugApplication::ResumeFromBreakPoint.
</FONT><FONT FACE="Courier New"><P>HRESULT onHandleBreakPoint(
<P></FONT><FONT COLOR="#008000">// Indicates the thread in which the breakpoint occured.
</FONT><FONT FACE="Courier New"><P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New"></FONT><A HREF="#IRemoteDebugApplicationThread">IRemoteDebugApplicationThread</A><A HREF="#IRemoteDebugApplicationThread"><FONT FACE="Courier New">IRemoteDebugApplicationThread</FONT></A><FONT FACE="Courier New"> *prpt,
<P></FONT><FONT COLOR="#008000">// Indicates the reason for the breakpoint.
</FONT><FONT FACE="Courier New"><P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New">BREAKREASON br,
<P></FONT><FONT COLOR="#008000">// optional runtime error info (for when br == BREAKREASON_ERROR)
</FONT><FONT FACE="Courier New"><P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New"></FONT><A HREF="#IActiveScriptErrorDebug">IActiveScriptErrorDebug</A><A HREF="#IActiveScriptErrorDebug"><FONT FACE="Courier New">IActiveScriptErrorDebug</FONT></A><FONT FACE="Courier New"> *pError);

<P></FONT><FONT COLOR="#008000">// This method is called when IDebugApplication::Close is called.
</FONT><FONT FACE="Courier New"><P>HRESULT onClose(void);

<P></FONT><FONT COLOR="#008000">// Handle a custom event.
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// The semantics of the GUID and IUnknown are entirely application/debugger defined
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// This method may return E_NOTIMPL.
</FONT><FONT FACE="Courier New"><P>HRESULT onDebuggerEvent(
<P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New">REFIID riid,
<P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New">IUnknown *punk);
<P>};
</FONT>

<H3><A NAME="IApplicationDebuggerUI">IApplicationDebuggerUI</A></H3>
<P>This is a secondary interface exposed by some debugger IDE that allows an external component to have additional control over the debuggers UI.
<FONT SIZE=2 COLOR="#808080"><P>[
<P>object,
<P>uuid(51973C2b-CB0C-11d0-B5C9-00A0244A0E7A),
<P>helpstring("IApplicationDebuggerUI Interface"),
<P>pointer_default(unique)
<P>]</FONT><FONT FACE="Courier New"></FONT>
<FONT FACE="Courier New" COLOR="#000080"><P>interface</FONT><FONT FACE="Courier New"> IApplicationDebuggerUI : IUnknown
<P>{
<P></FONT><FONT COLOR="#008000">// Bring the window corresponding to the given debug document to the front.
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// Returns E_INVALIDARG if the document is not known.
</FONT><FONT FACE="Courier New"><P>HRESULT BringDocumentToTop(</FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT> <A HREF="#IDebugDocumentText">IDebugDocumentText</A><A HREF="#IDebugDocumentText"><FONT FACE="Courier New">IDebugDocumentText</FONT></A><FONT FACE="Courier New">* pddt);

<P></FONT><FONT COLOR="#008000">// Bring the window containing the given doc context to the front,
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// and scroll it to the correct location.
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// Returns E_INVALIDARG if the context is not known.
</FONT><FONT FACE="Courier New"><P>HRESULT BringDocumentContextToTop(</FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT> <A HREF="#IDebugDocumentContext">IDebugDocumentContext</A><A HREF="#IDebugDocumentContext"><FONT FACE="Courier New">IDebugDocumentContext</FONT></A><FONT FACE="Courier New">* pddc);
<P>};
</FONT>

<H3><A NAME="IMachineDebugManager">IMachineDebugManager</A></H3>
<P>The primary interface to the Machine Debug Manager.

<FONT FACE="Courier New"><P>cpp_quote( "EXTERN_C </FONT><FONT FACE="Courier New" COLOR="#000080">const</FONT><FONT FACE="Courier New"> CLSID CLSID_MachineDebugManager;")
</FONT><FONT SIZE=2 COLOR="#808080"><P>[
<P>object,
<P>uuid(51973C2c-CB0C-11d0-B5C9-00A0244A0E7A),
<P>helpstring("IMachineDebugManager Interface"),
<P>pointer_default(unique)
<P>]</FONT><FONT FACE="Courier New"></FONT>
<FONT FACE="Courier New" COLOR="#000080"><P>interface</FONT><FONT FACE="Courier New"> IMachineDebugManager : IUnknown
<P>{
<P></FONT><FONT COLOR="#008000">// Adds an application to the running application list. This method is called by the
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// process debug manager whenever IProcessDebugManager::AddApplication is called.
</FONT><FONT FACE="Courier New"><P>HRESULT AddApplication(
<P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT> <A HREF="#IRemoteDebugApplication">IRemoteDebugApplication</A><A HREF="#IRemoteDebugApplication"><FONT FACE="Courier New">IRemoteDebugApplication</FONT></A><FONT FACE="Courier New"> *pda,
<P></FONT><FONT SIZE=2 COLOR="#808080">[out]</FONT><FONT FACE="Courier New"> DWORD *pdwAppCookie);
<P></FONT><FONT COLOR="#008000">// Removes an application from the running application list. This method is called by the
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// process debug manager whenever IProcessDebugManager::RemoveApplication is called.
</FONT><FONT FACE="Courier New"><P>HRESULT RemoveApplication(
<P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New"> DWORD dwAppCookie);
<P></FONT><FONT COLOR="#008000">// Returns an enumerator of the current list of running applications. Used by the debugger
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// IDE to display and attach applications for debugging purposes.
</FONT><FONT FACE="Courier New"><P>HRESULT EnumApplications(
<P></FONT><FONT SIZE=2 COLOR="#808080">[out]</FONT> <A HREF="#IEnumRemoteDebugApplications">IEnumRemoteDebugApplications</A><A HREF="#IEnumRemoteDebugApplications"><FONT FACE="Courier New">IEnumRemoteDebugApplications</FONT></A><FONT FACE="Courier New"> **ppeda);
<P>};
</FONT>

<H3><A NAME="IMachineDebugManagerCookie">IMachineDebugManagerCookie</A> - As IMachineDebugManager with Debug Cookie support</H3>

<FONT SIZE=2 COLOR="#808080"><P>[
<P>object,
<P>uuid(51973C2d-CB0C-11d0-B5C9-00A0244A0E7A),
<P>helpstring("IMachineDebugManagerCookie Interface"),
<P>pointer_default(unique)
<P>]</FONT><FONT FACE="Courier New"></FONT>
<FONT FACE="Courier New" COLOR="#000080"><P>interface</FONT><FONT FACE="Courier New"> IMachineDebugManagerCookie : IUnknown
<P>{
<P></FONT><FONT COLOR="#008000">// Adds an application to the running application list. This method is called by the
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// process debug manager whenever IProcessDebugManager::AddApplication is called.
</FONT><FONT FACE="Courier New"><P>HRESULT AddApplication(
<P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT> <A HREF="#IRemoteDebugApplication">IRemoteDebugApplication</A><A HREF="#IRemoteDebugApplication"><FONT FACE="Courier New">IRemoteDebugApplication</FONT></A><FONT FACE="Courier New"> *pda,
<P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New"> DWORD dwDebugAppCookie,
<P></FONT><FONT SIZE=2 COLOR="#808080">[out]</FONT><FONT FACE="Courier New"> DWORD *pdwAppCookie);
<P></FONT><FONT COLOR="#008000">// Removes an application from the running application list. This method is called by the
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// process debug manager whenever IProcessDebugManager::RemoveApplication is called.
</FONT><FONT FACE="Courier New"><P>HRESULT RemoveApplication(
<P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New"> DWORD dwDebugAppCookie,
<P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New"> DWORD dwAppCookie);
<P></FONT><FONT COLOR="#008000">// Returns an enumerator of the current list of running applications. Used by the debugger
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// IDE to display and attach applications for debugging purposes.
</FONT><FONT FACE="Courier New"><P>HRESULT EnumApplications(
<P></FONT><FONT SIZE=2 COLOR="#808080">[out]</FONT> <A HREF="#IEnumRemoteDebugApplications">IEnumRemoteDebugApplications</A><A HREF="#IEnumRemoteDebugApplications"><FONT FACE="Courier New">IEnumRemoteDebugApplications</FONT></A><FONT FACE="Courier New"> **ppeda);
<P>};
</FONT>

<H3><A NAME="IMachineDebugManagerEvents">IMachineDebugManagerEvents</A></H3>
<P>This event interface is used to signal changes in the running application list maintained by the machine debug manager. It can be used by the debugger IDE to display a dynamic list of applications.
<FONT SIZE=2 COLOR="#808080"><P>[
<P>object,
<P>uuid(51973C2e-CB0C-11d0-B5C9-00A0244A0E7A),
<P>helpstring("IMachineDebugManagerEvents Interface"),
<P>pointer_default(unique)
<P>]</FONT><FONT FACE="Courier New"></FONT>
<FONT FACE="Courier New" COLOR="#000080"><P>interface</FONT><FONT FACE="Courier New"> IMachineDebugManagerEvents : IUnknown
<P>{
<P></FONT><FONT COLOR="#008000">// Indicates that a new application has appeared on the running application list.
</FONT><FONT FACE="Courier New"><P>HRESULT onAddApplication(
<P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT> <A HREF="#IRemoteDebugApplication">IRemoteDebugApplication</A><A HREF="#IRemoteDebugApplication"><FONT FACE="Courier New">IRemoteDebugApplication</FONT></A><FONT FACE="Courier New"> *pda,
<P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New"> DWORD dwAppCookie);
<P></FONT><FONT COLOR="#008000">// Indicates that an application has been removed from the running application list.
</FONT><FONT FACE="Courier New"><P>HRESULT onRemoveApplication(
<P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT> <A HREF="#IRemoteDebugApplication">IRemoteDebugApplication</A><A HREF="#IRemoteDebugApplication"><FONT FACE="Courier New">IRemoteDebugApplication</FONT></A><FONT FACE="Courier New"> *pda,
<P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New"> DWORD dwAppCookie);
<P>};
</FONT>

<H3>Process Debug Manager Interfaces</H3>
<P>Below are the details of the interfaces for the process debug manager.

<P><A NAME="IProcessDebugManager">IProcessDebugManager</A>
<P>The primary interface to the process debug manager.
<FONT FACE="Courier New">
<P>cpp_quote( "EXTERN_C </FONT><FONT FACE="Courier New" COLOR="#000080">const</FONT><FONT FACE="Courier New"> CLSID CLSID_ProcessDebugManager;")
</FONT><FONT SIZE=2 COLOR="#808080"><P>[
<P>object,
<P>uuid(51973C2f-CB0C-11d0-B5C9-00A0244A0E7A),
<P>helpstring("IProcessDebugManager Interface"),
<P>pointer_default(unique),
<P>local
<P>]</FONT><FONT FACE="Courier New"></FONT>
<FONT FACE="Courier New" COLOR="#000080"><P>interface</FONT><FONT FACE="Courier New"> IProcessDebugManager : IUnknown
<P>{
<P></FONT><FONT COLOR="#008000">// Creates a new debug application object. The new object is not added to the
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// running application list and has no name.
</FONT><FONT FACE="Courier New"><P>HRESULT CreateApplication(
<P></FONT><FONT SIZE=2 COLOR="#808080">[out]</FONT> <A HREF="#IDebugApplication">IDebugApplication</A><A HREF="#IDebugApplication"><FONT FACE="Courier New">IDebugApplication</FONT></A><FONT FACE="Courier New"> **ppda);
<P></FONT><FONT COLOR="#008000">// Returns a default application object for the current process, creating one and adding
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// it to the running application list if necessary. Language engines should use this
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// application if they are running on a host that does not provide an application.
</FONT><FONT FACE="Courier New"><P>HRESULT GetDefaultApplication(
<P></FONT><FONT SIZE=2 COLOR="#808080">[out]</FONT> <A HREF="#IDebugApplication">IDebugApplication</A><A HREF="#IDebugApplication"><FONT FACE="Courier New">IDebugApplication</FONT></A><FONT FACE="Courier New"> **ppda);
<P></FONT><FONT COLOR="#008000">// Adds an application to the running application list in the machine debug manager.
</FONT><FONT FACE="Courier New"><P>HRESULT AddApplication(
<P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT> <A HREF="#IDebugApplication">IDebugApplication</A><A HREF="#IDebugApplication"><FONT FACE="Courier New">IDebugApplication</FONT></A><FONT FACE="Courier New"> *pda,
<P></FONT><FONT COLOR="#008000">// Returns a cookie used to remove the application from the machine debug manager.
</FONT><FONT FACE="Courier New"><P></FONT><FONT SIZE=2 COLOR="#808080">[out]</FONT><FONT FACE="Courier New"> DWORD *pdwAppCookie);
<P></FONT><FONT COLOR="#008000">// Removes an application from the running application list.
</FONT><FONT FACE="Courier New"><P>HRESULT RemoveApplication(
<P></FONT><FONT COLOR="#008000">// The cookie provided by AddApplication.
</FONT><FONT FACE="Courier New"><P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New"> DWORD dwAppCookie);

<P>HRESULT CreateDebugDocumentHelper(
<P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New"> IUnknown *punkOuter,
<P></FONT><FONT SIZE=2 COLOR="#808080">[out]</FONT> <A HREF="#IDebugDocumentHelper">IDebugDocumentHelper</A><A HREF="#IDebugDocumentHelper"><FONT FACE="Courier New">IDebugDocumentHelper</FONT></A><FONT FACE="Courier New">** pddh);
<P>};
</FONT>

<H3><A NAME="IRemoteDebugApplication">IRemoteDebugApplication</A></H3>
<P>An abstraction representing a running application. It need not correspond to an OS process. Applications are the smallest debuggable unit; that is, the debugger IDE normally targets an application for debugging.
<P>The application object is normally implemented by the Process Debug Manager.
<FONT SIZE=2 COLOR="#808080"><P>[
<P>object,
<P>uuid(51973C30-CB0C-11d0-B5C9-00A0244A0E7A),
<P>helpstring("IRemoteDebugApplication Interface"),
<P>pointer_default(unique)
<P>]</FONT><FONT FACE="Courier New"></FONT>
<FONT FACE="Courier New" COLOR="#000080"><P>interface</FONT><FONT FACE="Courier New"> IRemoteDebugApplication : IUnknown
<P>{
<P></FONT><FONT COLOR="#008000">// Continue an application which is currently in a breakpoint.
</FONT><FONT FACE="Courier New"><P>HRESULT ResumeFromBreakPoint(
<P></FONT><FONT COLOR="#008000">// For stepping modes, the thread which is to be affected by the stepping mode.
</FONT><FONT FACE="Courier New"><P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT> <A HREF="#IRemoteDebugApplicationThread">IRemoteDebugApplicationThread</A><A HREF="#IRemoteDebugApplicationThread"><FONT FACE="Courier New">IRemoteDebugApplicationThread</FONT></A><FONT FACE="Courier New"> *prptFocus,
<P></FONT><FONT COLOR="#008000">// The action to take (step mode, etc.) upon resuming the application
</FONT><FONT FACE="Courier New"><P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New"> BREAKRESUMEACTION bra,
<P></FONT><FONT COLOR="#008000">// the action to take in the case that we stopped because of an error
</FONT><FONT FACE="Courier New"><P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New"> ERRORRESUMEACTION era);

<P></FONT><FONT COLOR="#008000">// Causes the application to break into the debugger at the earliest opportunity. Note
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// that a long time may elapse before the application actually breaks, particularly if
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// the application is not currently executing script code.
</FONT><FONT FACE="Courier New"><P>HRESULT CauseBreak(void);
<P></FONT><FONT COLOR="#008000">// Connects a debugger to the application. Only one debugger may be connected at a
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// time; this method fails if there is already a debugger connected
</FONT><FONT FACE="Courier New"><P>HRESULT ConnectDebugger(
<P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New"></FONT><A HREF="#IApplicationDebugger">IApplicationDebugger</A><A HREF="#IApplicationDebugger"><FONT FACE="Courier New">IApplicationDebugger</FONT></A><FONT FACE="Courier New"> *pad);
<P></FONT><FONT COLOR="#008000">// Disconnects the current debugger from the application.
</FONT><FONT FACE="Courier New"><P>HRESULT DisconnectDebugger(void);
<P></FONT><FONT COLOR="#008000">// Returns the current debugger connected to the application.
</FONT><FONT FACE="Courier New"><P>HRESULT GetDebugger(
<P></FONT><FONT SIZE=2 COLOR="#808080">[out]</FONT><FONT FACE="Courier New"></FONT><A HREF="#IApplicationDebugger">IApplicationDebugger</A><A HREF="#IApplicationDebugger"><FONT FACE="Courier New">IApplicationDebugger</FONT></A><FONT FACE="Courier New"> **pad);
<P></FONT><FONT COLOR="#008000">// Provides a mechanism for the debugger IDE, running out-of-process to the
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// application, to create objects in the application process.
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// This method simply delegates to CoCreateInstance.
</FONT><FONT FACE="Courier New"><P>HRESULT CreateInstanceAtApplication(
<P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New">REFCLSID rclsid,</FONT><FONT COLOR="#008000">// Class identifier (CLSID) of the object
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// Note: This parameter may have to be removed.
</FONT><FONT FACE="Courier New"><P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New">IUnknown *pUnkOuter,</FONT><FONT COLOR="#008000">// Object is or isn't part of an aggregate
</FONT><FONT FACE="Courier New"><P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New">DWORD dwClsContext,</FONT><FONT COLOR="#008000">// Context for running executable code
</FONT><FONT FACE="Courier New"><P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New">REFIID riid,</FONT><FONT COLOR="#008000">// Interface identifier
</FONT><FONT FACE="Courier New"><P></FONT><FONT SIZE=2 COLOR="#808080">[out, iid_is(riid)]</FONT><FONT FACE="Courier New">IUnknown **ppvObject);
<P></FONT><FONT COLOR="#008000">// Points to requested interface pointer
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// Indicates if the application is alive. Should always return S_OK. If the application
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// process has rudely shut down COM will return an error from the marshalling proxy.
</FONT><FONT FACE="Courier New"><P>HRESULT QueryAlive(
<P>void);
<P></FONT><FONT COLOR="#008000">// Enumerates all threads known to be associated with the application.
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// New threads may be added at any time.
</FONT><FONT FACE="Courier New"><P>HRESULT EnumThreads(
<P></FONT><FONT SIZE=2 COLOR="#808080">[out]</FONT><FONT FACE="Courier New"></FONT><A HREF="#IEnumRemoteDebugApplicationThreads">IEnumRemoteDebugApplicationThreads</A><A HREF="#IEnumRemoteDebugApplicationThreads"><FONT FACE="Courier New">IEnumRemoteDebugApplicationThreads</FONT></A><FONT FACE="Courier New"> **pperdat);
<P></FONT><FONT COLOR="#008000">// Returns the application node under which all nodes associated with the
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// application are added.
</FONT><FONT FACE="Courier New"><P>HRESULT GetName(
<P></FONT><FONT SIZE=2 COLOR="#808080">[out]</FONT><FONT FACE="Courier New">BSTR *pbstrName);
<P></FONT><FONT COLOR="#008000">// Returns a node for the application
</FONT><FONT FACE="Courier New"><P>HRESULT GetRootNode(
<P></FONT><FONT SIZE=2 COLOR="#808080">[out]</FONT><FONT FACE="Courier New"></FONT><A HREF="#IDebugApplicationNode">IDebugApplicationNode</A><A HREF="#IDebugApplicationNode"><FONT FACE="Courier New">IDebugApplicationNode</FONT></A><FONT FACE="Courier New"> **ppdanRoot);
<P></FONT><FONT COLOR="#008000">// Returns an enumerator that lists the global expression
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// contexts for all languages running in this application
</FONT><FONT FACE="Courier New"><P>HRESULT EnumGlobalExpressionContexts (
<P></FONT><FONT SIZE=2 COLOR="#808080">[out]</FONT><FONT FACE="Courier New"></FONT><A HREF="#IEnumDebugExpressionContexts">IEnumDebugExpressionContexts</A><A HREF="#IEnumDebugExpressionContexts"><FONT FACE="Courier New">IEnumDebugExpressionContexts</FONT></A><FONT FACE="Courier New"> **ppedec);
<P>};
</FONT>

<H3><A NAME="IDebugApplication">IDebugApplication</A></H3>
<P>This interface is an extension of IRemoteDebugApplication, exposing non-remotable methods for use by language engines and hosts.
<P><FONT SIZE=2 COLOR="#808080">[
<P>object,
<P>uuid(51973C32-CB0C-11d0-B5C9-00A0244A0E7A),
<P>helpstring("IDebugApplication Interface"),
<P>pointer_default(unique),
<P>local
<P>]</FONT><FONT FACE="Courier New"></FONT>
<FONT FACE="Courier New" COLOR="#000080"><P>interface</FONT><FONT FACE="Courier New"> IDebugApplication : </FONT><A HREF="#IRemoteDebugApplication">IRemoteDebugApplication</A><A HREF="#IRemoteDebugApplication"><FONT FACE="Courier New">IRemoteDebugApplication</FONT></A><FONT FACE="Courier New">
<P>{
<P></FONT><FONT COLOR="#008000">// Sets the name of the application. The provided name will be returned in subsequent calls
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// to IRemoteDebugApplication::GetName.
</FONT><FONT FACE="Courier New"><P>HRESULT SetName(
<P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New">LPCOLESTR pstrName);
<P></FONT><FONT COLOR="#008000">// This method is called by language engines, in single step mode, just before they
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// return to their caller. The process debug manager uses this opportunity to notify all
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// other script engines that they should break at the first opportunity. This is how
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// cross language step modes are implemented.
</FONT><FONT FACE="Courier New"><P>HRESULT StepOutComplete(void);
<P></FONT><FONT COLOR="#008000">// Causes the given string to be displayed by the debugger IDE, normally in an output
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// window. This mechanism provides the means for a language engine to implement language
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// specific debugging output support. Example: Debug.writeln("Help") in JavaScript.
</FONT><FONT FACE="Courier New"><P>HRESULT DebugOutput(
<P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New">LPCOLESTR pstr);
<P></FONT><FONT COLOR="#008000">// Causes a default debugger IDE to be started and a debug session to be attached to
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// this application if one does not already exist. This is used to implement just-in-time
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// debugging.
</FONT><FONT FACE="Courier New"><P>HRESULT StartDebugSession(void);
<P></FONT><FONT COLOR="#008000">// Called by the language engine in the context of a thread that has hit a breakpoint.
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// This method causes the current thread to block and a notification of the breakpoint
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// to be sent to the debugger IDE. When the debugger IDE resumes the application this
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// method returns with the action to be taken.
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">//
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// Note: While in the breakpoint the language engine may be called in this thread to do
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// various things such as enumerating stack frames or evaluating expressions.
</FONT><FONT FACE="Courier New"><P>HRESULT HandleBreakPoint(
<P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New">BREAKREASON br,
<P></FONT><FONT SIZE=2 COLOR="#808080">[out]</FONT><FONT FACE="Courier New">BREAKRESUMEACTION *pbra);
<P></FONT><FONT COLOR="#008000">// Causes this application to release all references and enter a zombie state. Called
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// by the owner of the application generally on shut down.
</FONT><FONT FACE="Courier New"><P>HRESULT Close(void);
<P></FONT><FONT COLOR="#008000">// Returns the current break flags for the application.
</FONT><FONT FACE="Courier New"><P>HRESULT GetBreakFlags(
<P></FONT><FONT SIZE=2 COLOR="#808080">[out]</FONT><FONT FACE="Courier New">APPBREAKFLAGS *pabf,
<P></FONT><FONT SIZE=2 COLOR="#808080">[out]</FONT><FONT FACE="Courier New"></FONT><A HREF="#IRemoteDebugApplicationThread">IRemoteDebugApplicationThread</A><A HREF="#IRemoteDebugApplicationThread"><FONT FACE="Courier New">IRemoteDebugApplicationThread</FONT></A><FONT FACE="Courier New"> **pprdatSteppingThread);
<P></FONT><FONT COLOR="#008000">// Returns the application thread object associated with the currently running thread.
</FONT><FONT FACE="Courier New"><P>HRESULT GetCurrentThread(
<P></FONT><FONT SIZE=2 COLOR="#808080">[out]</FONT><FONT FACE="Courier New"></FONT><A HREF="#IDebugApplicationThread">IDebugApplicationThread</A><A HREF="#IDebugApplicationThread"><FONT FACE="Courier New">IDebugApplicationThread</FONT></A><FONT FACE="Courier New"> **pat);
<P></FONT><FONT COLOR="#008000">// Creates an IDebugAsyncOperation object to wrap a provided IDebugSyncOperation object.
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// This provides a mechanism for language engines to implement asynchronous expression and
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// evaluation, etc. without having to know the details of synchronization with the
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// debugger thread. See the descriptions for IDebugSyncOperation and IDebugAsyncOperation
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// for more details.
</FONT><FONT FACE="Courier New"><P>HRESULT CreateAsyncDebugOperation(
<P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New"></FONT><A HREF="#IDebugSyncOperation">IDebugSyncOperation</A><A HREF="#IDebugSyncOperation"><FONT FACE="Courier New">IDebugSyncOperation</FONT></A><FONT FACE="Courier New"> *psdo,
<P></FONT><FONT SIZE=2 COLOR="#808080">[out]</FONT><FONT FACE="Courier New"></FONT><A HREF="#IDebugAsyncOperation">IDebugAsyncOperation</A><A HREF="#IDebugAsyncOperation"><FONT FACE="Courier New">IDebugAsyncOperation</FONT></A><FONT FACE="Courier New"> **ppado);
<P></FONT><FONT COLOR="#008000">// Adds a stack frame sniffer to this application. Generally called by a language engine
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// to expose its stack frames to the debugger. It is possible for other entities to
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// expose stack frames.
</FONT><FONT FACE="Courier New"><P>HRESULT AddStackFrameSniffer(
<P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New"></FONT><A HREF="#IDebugStackFrameSniffer">IDebugStackFrameSniffer</A><A HREF="#IDebugStackFrameSniffer"><FONT FACE="Courier New">IDebugStackFrameSniffer</FONT></A><FONT FACE="Courier New"> *pdsfs,
<P></FONT><FONT COLOR="#008000">// Returns a cookie that is used to remove this stack frame sniffer
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// from the application.
</FONT><FONT FACE="Courier New"><P></FONT><FONT SIZE=2 COLOR="#808080">[out]</FONT><FONT FACE="Courier New">DWORD *pdwCookie);
<P></FONT><FONT COLOR="#008000">// Removes a stack frame sniffer from this application.
</FONT><FONT FACE="Courier New"><P>HRESULT RemoveStackFrameSniffer(
<P></FONT><FONT COLOR="#008000">// The cookie returned by AddStackFrameSniffer.
</FONT><FONT FACE="Courier New"><P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New">DWORD dwCookie);
<P></FONT><FONT COLOR="#008000">// Returns S_OK if the current running thread is the debugger thread.
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// Otherwise, returns S_FALSE.
</FONT><FONT FACE="Courier New"><P>HRESULT QueryCurrentThreadIsDebuggerThread(
<P>void);
<P></FONT><FONT COLOR="#008000">// Provides a mechanism for the caller to run code in the debugger thread. This is generally
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// used so that language engines and hosts can implement free threaded objects on top
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// of their single threaded implementations.
</FONT><FONT FACE="Courier New"><P>HRESULT SynchronousCallInDebuggerThread(
<P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New"></FONT><A HREF="#IDebugThreadCall">IDebugThreadCall</A><A HREF="#IDebugThreadCall"><FONT FACE="Courier New">IDebugThreadCall</FONT></A><FONT FACE="Courier New"> *pptc,
<P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New">DWORD dwParam1,
<P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New">DWORD dwParam2,
<P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New">DWORD dwParam3);
<P></FONT><FONT COLOR="#008000">// Creates a new application node which is associated with a specific
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// document provider. Before it is visible, the new node must be
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// attached to a parent node.
</FONT><FONT FACE="Courier New"><P>HRESULT CreateApplicationNode(
<P></FONT><FONT SIZE=2 COLOR="#808080">[out]</FONT><FONT FACE="Courier New"></FONT><A HREF="#IDebugApplicationNode">IDebugApplicationNode</A><A HREF="#IDebugApplicationNode"><FONT FACE="Courier New">IDebugApplicationNode</FONT></A><FONT FACE="Courier New"> **ppdanNew);

<P></FONT><FONT COLOR="#008000">// Fire a generic event to the IApplicationDebugger (if any)
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// The semantics of the GUID and IUnknown are entirely application/debugger defined
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">//
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// This method is currently unimplemented but is here to allow for future extensions.
</FONT><FONT FACE="Courier New"><P>HRESULT FireDebuggerEvent(
<P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New">REFGUID riid,
<P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New">IUnknown *punk);

<P></FONT><FONT COLOR="#008000">// Called by the language engine in the context of a thread that has caused a runtime error.
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// This method causes the current thread to block and a notification of the error
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// to be sent to the debugger IDE. When the debugger IDE resumes the application this
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// method returns with the action to be taken.
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">//
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// Note: While in the runtime error the language engine may be called in this thread to do
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// various things such as enumerating stack frames or evaluating expressions.
</FONT><FONT FACE="Courier New"><P>HRESULT HandleRuntimeError(
<P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New"></FONT><A HREF="#IActiveScriptErrorDebug">IActiveScriptErrorDebug</A><A HREF="#IActiveScriptErrorDebug"><FONT FACE="Courier New">IActiveScriptErrorDebug</FONT></A><FONT FACE="Courier New"> *pErrorDebug,</FONT><FONT COLOR="#008000">// the error that occurred
</FONT><FONT FACE="Courier New"><P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New">IActiveScriptSite *pScriptSite,</FONT><FONT COLOR="#008000">// the script site of the thread
</FONT><FONT FACE="Courier New"><P></FONT><FONT SIZE=2 COLOR="#808080">[out]</FONT><FONT FACE="Courier New">BREAKRESUMEACTION *pbra,</FONT><FONT COLOR="#008000">// how to continue execution (stepping etc...)
</FONT><FONT FACE="Courier New"><P></FONT><FONT SIZE=2 COLOR="#808080">[out]</FONT><FONT FACE="Courier New">ERRORRESUMEACTION *perra,</FONT><FONT COLOR="#008000">// how to handle the error case
</FONT><FONT FACE="Courier New"><P></FONT><FONT SIZE=2 COLOR="#808080">[out]</FONT><FONT FACE="Courier New">BOOL *pfCallOnScriptError);</FONT><FONT COLOR="#008000">// if TRUE then engine should call IActiveScriptSite::OnScriptError()
</FONT><FONT FACE="Courier New">
<P></FONT><FONT COLOR="#008000">// return TRUE if there is a JIT debugger registered
</FONT><FONT FACE="Courier New"><P>BOOL FCanJitDebug ();

<P></FONT><FONT COLOR="#008000">// returns TRUE if a JIT debugger is registered and it is registered to auto-JIT debug dumb hosts
</FONT><FONT FACE="Courier New"><P>BOOL FIsAutoJitDebugEnabled ();

<P></FONT><FONT COLOR="#008000">// Adds a global expression context provider to this application
</FONT><FONT FACE="Courier New"><P>HRESULT AddGlobalExpressionContextProvider(
<P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New"></FONT><A HREF="#IProvideExpressionContexts">IProvideExpressionContexts</A><A HREF="#IProvideExpressionContexts"><FONT FACE="Courier New">IProvideExpressionContexts</FONT></A><FONT FACE="Courier New"> *pdsfs,
<P></FONT><FONT COLOR="#008000">// Returns a cookie that is used to remove this global expression context provider
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// from the application.
</FONT><FONT FACE="Courier New"><P></FONT><FONT SIZE=2 COLOR="#808080">[out]</FONT><FONT FACE="Courier New">DWORD *pdwCookie);

<P></FONT><FONT COLOR="#008000">// Removes a global expression context provider from this application.
</FONT><FONT FACE="Courier New"><P>HRESULT RemoveGlobalExpressionContextProvider(
<P></FONT><FONT COLOR="#008000">// The cookie returned by AddGlobalExpressionContextProvider.
</FONT><FONT FACE="Courier New"><P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New">DWORD dwCookie);
<P>};
</FONT>

<H3>IRemoteDebugApplicationEvents:</H3>
<P>This is the event interface supplied by a debug application: It is always called from within the debugger thread.
<FONT SIZE=2 COLOR="#808080"><P>[
<P>object,
<P>uuid(51973C33-CB0C-11d0-B5C9-00A0244A0E7A),
<P>helpstring("IRemoteDebugApplicationEvents Interface"),
<P>pointer_default(unique)
<P>]</FONT><FONT FACE="Courier New"></FONT>
<FONT FACE="Courier New" COLOR="#000080"><P>interface</FONT><FONT FACE="Courier New"> IRemoteDebugApplicationEvents : IUnknown
<P>{
<P>HRESULT OnConnectDebugger(
<P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New"></FONT><A HREF="#IApplicationDebugger">IApplicationDebugger</A><A HREF="#IApplicationDebugger"><FONT FACE="Courier New">IApplicationDebugger</FONT></A><FONT FACE="Courier New"> *pad);
<P>HRESULT OnDisconnectDebugger(void);
<P>HRESULT OnSetName(
<P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New">LPCOLESTR pstrName);
<P>HRESULT OnDebugOutput(
<P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New">LPCOLESTR pstr);
<P>HRESULT OnClose(void);
<P>HRESULT OnEnterBreakPoint(
<P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New"></FONT><A HREF="#IRemoteDebugApplicationThread">IRemoteDebugApplicationThread</A><A HREF="#IRemoteDebugApplicationThread"><FONT FACE="Courier New">IRemoteDebugApplicationThread</FONT></A><FONT FACE="Courier New"> *prdat);
<P>HRESULT OnLeaveBreakPoint(
<P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New"></FONT><A HREF="#IRemoteDebugApplicationThread">IRemoteDebugApplicationThread</A><A HREF="#IRemoteDebugApplicationThread"><FONT FACE="Courier New">IRemoteDebugApplicationThread</FONT></A><FONT FACE="Courier New"> *prdat);
<P>HRESULT OnCreateThread(
<P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New"></FONT><A HREF="#IRemoteDebugApplicationThread">IRemoteDebugApplicationThread</A><A HREF="#IRemoteDebugApplicationThread"><FONT FACE="Courier New">IRemoteDebugApplicationThread</FONT></A><FONT FACE="Courier New"> *prdat);
<P>HRESULT OnDestroyThread(
<P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New"></FONT><A HREF="#IRemoteDebugApplicationThread">IRemoteDebugApplicationThread</A><A HREF="#IRemoteDebugApplicationThread"><FONT FACE="Courier New">IRemoteDebugApplicationThread</FONT></A><FONT FACE="Courier New"> *prdat);
<P>HRESULT OnBreakFlagChange(
<P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New">APPBREAKFLAGS abf,
<P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New"></FONT><A HREF="#IRemoteDebugApplicationThread">IRemoteDebugApplicationThread</A><A HREF="#IRemoteDebugApplicationThread"><FONT FACE="Courier New">IRemoteDebugApplicationThread</FONT></A><FONT FACE="Courier New"> *prdatSteppingThread);
<P>};
</FONT>

<H3><A NAME="IDebugApplicationNode">IDebugApplicationNode</A></H3>
<P>Provides the functionality of IDebugDocumentProvider, plus a context within a project tree.
<FONT SIZE=2 COLOR="#808080"><P>[
<P>object,
<P>uuid(51973C34-CB0C-11d0-B5C9-00A0244A0E7A),
<P>pointer_default(unique)
<P>]</FONT><FONT FACE="Courier New"></FONT>
<FONT FACE="Courier New" COLOR="#000080"><P>interface</FONT><FONT FACE="Courier New"> IDebugApplicationNode : </FONT><A HREF="#IDebugDocumentProvider">IDebugDocumentProvider</A><A HREF="#IDebugDocumentProvider"><FONT FACE="Courier New">IDebugDocumentProvider</FONT></A><FONT FACE="Courier New"> {
<P>HRESULT EnumChildren(
<P></FONT><FONT SIZE=2 COLOR="#808080">[out]</FONT><FONT FACE="Courier New"></FONT><A HREF="#IEnumDebugApplicationNodes">IEnumDebugApplicationNodes</A><A HREF="#IEnumDebugApplicationNodes"><FONT FACE="Courier New">IEnumDebugApplicationNodes</FONT></A><FONT FACE="Courier New"> **pperddp);
<P>HRESULT GetParent(
<P></FONT><FONT SIZE=2 COLOR="#808080">[out]</FONT><FONT FACE="Courier New"></FONT><A HREF="#IDebugApplicationNode">IDebugApplicationNode</A><A HREF="#IDebugApplicationNode"><FONT FACE="Courier New">IDebugApplicationNode</FONT></A><FONT FACE="Courier New"> **pprddp);
<P>HRESULT SetDocumentProvider(
<P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New"></FONT><A HREF="#IDebugDocumentProvider">IDebugDocumentProvider</A><A HREF="#IDebugDocumentProvider"><FONT FACE="Courier New">IDebugDocumentProvider</FONT></A><FONT FACE="Courier New"> *pddp);
<P>HRESULT Close(void);
<P>HRESULT Attach(
<P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New"></FONT><A HREF="#IDebugApplicationNode">IDebugApplicationNode</A><A HREF="#IDebugApplicationNode"><FONT FACE="Courier New">IDebugApplicationNode</FONT></A><FONT FACE="Courier New"> *pdanParent);
<P>HRESULT Detach(void);
<P>}
</FONT>

<H3><A NAME="IDebugApplicationNodeEvents">IDebugApplicationNodeEvents</A></H3>
<P>Event interface for DebugApplicationNode object.
<FONT SIZE=2 COLOR="#808080"><P>[
<P>object,
<P>uuid(51973C35-CB0C-11d0-B5C9-00A0244A0E7A),
<P>pointer_default(unique)
<P>]</FONT><FONT FACE="Courier New"></FONT>
<FONT FACE="Courier New" COLOR="#000080"><P>interface</FONT><FONT FACE="Courier New"> IDebugApplicationNodeEvents : IUnknown {
<P>HRESULT onAddChild(
<P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New"></FONT><A HREF="#IDebugApplicationNode">IDebugApplicationNode</A><A HREF="#IDebugApplicationNode"><FONT FACE="Courier New">IDebugApplicationNode</FONT></A><FONT FACE="Courier New"> *prddpChild);
<P>HRESULT onRemoveChild(
<P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New"></FONT><A HREF="#IDebugApplicationNode">IDebugApplicationNode</A><A HREF="#IDebugApplicationNode"><FONT FACE="Courier New">IDebugApplicationNode</FONT></A><FONT FACE="Courier New"> *prddpChild);
<P>HRESULT onDetach(void);
<P>HRESULTonAttach(
<P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New"></FONT><A HREF="#IDebugApplicationNode">IDebugApplicationNode</A><A HREF="#IDebugApplicationNode"><FONT FACE="Courier New">IDebugApplicationNode</FONT></A><FONT FACE="Courier New"> *prddpParent);
<P>}
</FONT>

<H3><A NAME="IDebugThreadCall">IDebugThreadCall</A></H3>
<P>IDebugThreadCall is implemented by a component making a cross-thread call using the IDebugThread marshalling implementation in the PDM. It is called by the PDM in the desired thread and should dispatches the call to the desired implementation, casting the parameter information passed in the dwParam's to the appropriate top. It is, of course, a free-threaded object.
<FONT SIZE=2 COLOR="#808080"><P>[
<P>object,
<P>uuid(51973C36-CB0C-11d0-B5C9-00A0244A0E7A),
<P>pointer_default(unique),
<P>local
<P>]</FONT><FONT FACE="Courier New"></FONT>
<FONT FACE="Courier New" COLOR="#000080"><P>interface</FONT><FONT FACE="Courier New"> IDebugThreadCall : IUnknown
<P>{
<P>HRESULT ThreadCallHandler(
<P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New"> DWORD dwParam1,
<P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New"> DWORD dwParam2,
<P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New"> DWORD dwParam3);
<P>}
</FONT>

<H3><A NAME="IRemoteDebugApplicationThread">IRemoteDebugApplicationThread</A></H3>
<P>An abstraction representing a thread of execution within a particular application.
<FONT SIZE=2 COLOR="#808080"><P>[
<P>object,
<P>uuid(51973C37-CB0C-11d0-B5C9-00A0244A0E7A),
<P>pointer_default(unique)
<P>]</FONT><FONT FACE="Courier New"></FONT>
<FONT FACE="Courier New" COLOR="#000080"><P>interface</FONT><FONT FACE="Courier New"> IRemoteDebugApplicationThread : IUnknown
<P>{
<P></FONT><FONT COLOR="#008000">// Returns an operating system dependent identifier associated with the thread.
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">//
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// Note: The returned value does not need to be unique across machines.
</FONT><FONT FACE="Courier New"><P>HRESULT GetSystemThreadId(
<P></FONT><FONT SIZE=2 COLOR="#808080">[out]</FONT><FONT FACE="Courier New">DWORD *dwThreadId);
<P></FONT><FONT COLOR="#008000">// Returns the application object associated with the thread.
</FONT><FONT FACE="Courier New"><P>HRESULT GetApplication(
<P></FONT><FONT SIZE=2 COLOR="#808080">[out]</FONT><FONT FACE="Courier New"></FONT><A HREF="#IRemoteDebugApplication">IRemoteDebugApplication</A><A HREF="#IRemoteDebugApplication"><FONT FACE="Courier New">IRemoteDebugApplication</FONT></A><FONT FACE="Courier New"> **pprda);
<P></FONT><FONT COLOR="#008000">// Returns an enumerator for the stack frames associated with the thread. Can only
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// be called when in a breakpoint. The stack frame enumerator enumerates stack frames
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// in the most recently called order.
</FONT><FONT FACE="Courier New"><P>HRESULT EnumStackFrames(
<P></FONT><FONT SIZE=2 COLOR="#808080">[out]</FONT><FONT FACE="Courier New"></FONT><A HREF="#IEnumDebugStackFrames">IEnumDebugStackFrames</A><A HREF="#IEnumDebugStackFrames"><FONT FACE="Courier New">IEnumDebugStackFrames</FONT></A><FONT FACE="Courier New"> **ppedsf);

<P>HRESULT GetDescription(
<P></FONT><FONT SIZE=2 COLOR="#808080">[out]</FONT><FONT FACE="Courier New">BSTR *pbstrDescription,
<P></FONT><FONT SIZE=2 COLOR="#808080">[out]</FONT><FONT FACE="Courier New">BSTR *pbstrState);

<P></FONT><FONT COLOR="#008000">// Forces execution to continue as close as possible to the
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// given code context, in the context of the given frame.
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// Either of these arguments may be NULL, representing the
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// current frame or context.
</FONT><FONT FACE="Courier New"><P>HRESULT SetNextStatement (
<P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT> <A HREF="#IDebugStackFrame">IDebugStackFrame</A><A HREF="#IDebugStackFrame"><FONT FACE="Courier New">IDebugStackFrame</FONT></A><FONT FACE="Courier New"> *pStackFrame,
<P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT> <A HREF="#IDebugCodeContext">IDebugCodeContext</A><A HREF="#IDebugCodeContext"><FONT FACE="Courier New">IDebugCodeContext</FONT></A><FONT FACE="Courier New"> *pCodeContext);

<P></FONT><FONT COLOR="#008000">// Thread State flags
</FONT><FONT FACE="Courier New"><P></FONT><FONT FACE="Courier New" COLOR="#000080">typedef</FONT><FONT FACE="Courier New"> DWORD THREAD_STATE;
<P></FONT><FONT FACE="Courier New" COLOR="#000080">const</FONT><FONT FACE="Courier New"> THREAD_STATE THREAD_STATE_RUNNING=0x00000001;
<P></FONT><FONT FACE="Courier New" COLOR="#000080">const</FONT><FONT FACE="Courier New"> THREAD_STATE THREAD_STATE_SUSPENDED=0x00000002;
<P></FONT><FONT FACE="Courier New" COLOR="#000080">const</FONT><FONT FACE="Courier New"> THREAD_STATE THREAD_BLOCKED=0x00000004;
<P></FONT><FONT FACE="Courier New" COLOR="#000080">const</FONT><FONT FACE="Courier New"> THREAD_STATE THREAD_OUT_OF_CONTEXT=0x00000008;

<P></FONT><FONT COLOR="#008000">// returns the current state of the thread
</FONT><FONT FACE="Courier New"><P>HRESULT GetState (
<P></FONT><FONT SIZE=2 COLOR="#808080">[out]</FONT><FONT FACE="Courier New"> DWORD *pState);

<P></FONT><FONT COLOR="#008000">// suspends the thread (increments the suspend count)
</FONT><FONT FACE="Courier New"><P>HRESULT Suspend (
<P></FONT><FONT SIZE=2 COLOR="#808080">[out]</FONT><FONT FACE="Courier New"> DWORD *pdwCount);

<P></FONT><FONT COLOR="#008000">// resumes the thread (decrements the suspend count)
</FONT><FONT FACE="Courier New"><P>HRESULT Resume (
<P></FONT><FONT SIZE=2 COLOR="#808080">[out]</FONT><FONT FACE="Courier New"> DWORD *pdwCount);

<P></FONT><FONT COLOR="#008000">// returns the current suspend count of the thread
</FONT><FONT FACE="Courier New"><P>HRESULT GetSuspendCount (
<P></FONT><FONT SIZE=2 COLOR="#808080">[out]</FONT><FONT FACE="Courier New"> DWORD *pdwCount);
<P>}
</FONT>

<H3><A NAME="IDebugApplicationThread">IDebugApplicationThread</A></H3>
<P>An extension of IRemoteDebugApplicationThread that provides non-remotable access to the thread. This interface is used by language engines and hosts to provide thread synchronization and to maintain thread specific debug state information.
<FONT SIZE=2 COLOR="#808080"><P>[
<P>object,
<P>uuid(51973C38-CB0C-11d0-B5C9-00A0244A0E7A),
<P>pointer_default(unique),
<P>local
<P>]</FONT><FONT FACE="Courier New"></FONT>
<FONT FACE="Courier New" COLOR="#000080"><P>interface</FONT><FONT FACE="Courier New"> IDebugApplicationThread : </FONT><A HREF="#IRemoteDebugApplicationThread">IRemoteDebugApplicationThread</A><A HREF="#IRemoteDebugApplicationThread"><FONT FACE="Courier New">IRemoteDebugApplicationThread</FONT></A><FONT FACE="Courier New">
<P>{
<P></FONT><FONT COLOR="#008000">// Provides a mechanism for the caller to run code in another thread. This is generally
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// used so that language engines and hosts can implement free threaded objects on top
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// of their single threaded implementations.
</FONT><FONT FACE="Courier New"><P>HRESULT SynchronousCallIntoThread(
<P></FONT><FONT COLOR="#008000">// The interface to be called back in the target thread.
</FONT><FONT FACE="Courier New"><P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New"></FONT><A HREF="#IDebugThreadCall">IDebugThreadCall</A><A HREF="#IDebugThreadCall"><FONT FACE="Courier New">IDebugThreadCall</FONT></A><FONT FACE="Courier New"> *pstcb,
<P></FONT><FONT COLOR="#008000">// Three arguments passed to the IDebugThreadCall.
</FONT><FONT FACE="Courier New"><P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New">DWORD dwParam1,
<P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New">DWORD dwParam2,
<P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New">DWORD dwParam3);
<P></FONT><FONT COLOR="#008000">// Returns S_OK when this is the currently running thread. Otherwise S_FALSE is returned.
</FONT><FONT FACE="Courier New"><P>HRESULT QueryIsCurrentThread(
<P>void);
<P></FONT><FONT COLOR="#008000">// Returns S_OK when this is the debugger thread. Otherwise, returns S_FALSE.
</FONT><FONT FACE="Courier New"><P>HRESULT QueryIsDebuggerThread(
<P>void);
<P>HRESULT SetDescription(
<P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New">LPCOLESTR pstrDescription);
<P>HRESULT SetStateString(
<P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New">LPCOLESTR pstrState);
<P>}

</FONT><FONT SIZE=2 COLOR="#808080"><P>[
<P>object, local,
<P>uuid(51973C39-CB0C-11d0-B5C9-00A0244A0E7A),
<P>helpstring("IDebugCookie Interface"),
<P>pointer_default(unique)
<P>]</FONT><FONT FACE="Courier New"></FONT>
<FONT FACE="Courier New" COLOR="#000080"><P>interface</FONT><FONT FACE="Courier New"> IDebugCookie : IUnknown
<P>{
<P>HRESULT SetDebugCookie(</FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New">DWORD dwDebugAppCookie);
<P>};
</FONT>

<H3><A NAME="IEnumDebugApplicationNodes">IEnumDebugApplicationNodes</A></H3>
<P>Enumerates Application nodes. Generally used to enumerate child nodes of a node associated with an application. Example: a project window.
<FONT SIZE=2 COLOR="#808080"><P>[
<P>object,
<P>uuid(51973C3a-CB0C-11d0-B5C9-00A0244A0E7A),
<P>helpstring("IEnumDebugApplicationNodes Interface"),
<P>pointer_default(unique)
<P>]</FONT><FONT FACE="Courier New"></FONT>
<FONT FACE="Courier New" COLOR="#000080"><P>interface</FONT><FONT FACE="Courier New"> IEnumDebugApplicationNodes : IUnknown {
<P></FONT><FONT SIZE=2 COLOR="#808080">[local]</FONT><FONT FACE="Courier New">
<P>HRESULT </FONT><FONT SIZE=2 COLOR="#808080">__stdcall</FONT><FONT FACE="Courier New"> Next(
<P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New"> ULONG celt,
<P></FONT><FONT SIZE=2 COLOR="#808080">[out]</FONT> <A HREF="#IDebugApplicationNode">IDebugApplicationNode</A><A HREF="#IDebugApplicationNode"><FONT FACE="Courier New">IDebugApplicationNode</FONT></A><FONT FACE="Courier New"> **pprddp,
<P></FONT><FONT SIZE=2 COLOR="#808080">[out]</FONT><FONT FACE="Courier New"> ULONG *pceltFetched);

<P>HRESULT Skip(
<P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New"> ULONG celt);

<P>HRESULT Reset(void);

<P>HRESULT Clone(
<P></FONT><FONT SIZE=2 COLOR="#808080">[out]</FONT> <A HREF="#IEnumDebugApplicationNodes">IEnumDebugApplicationNodes</A><A HREF="#IEnumDebugApplicationNodes"><FONT FACE="Courier New">IEnumDebugApplicationNodes</FONT></A><FONT FACE="Courier New"> **pperddp);
<P>};
</FONT>

<H3><A NAME="IEnumRemoteDebugApplications">IEnumRemoteDebugApplications</A></H3>
<P>Enumerates application objects. Generally used to enumerate the running applications on a machine. Example: the "attach to application" dialog.
<FONT SIZE=2 COLOR="#808080"><P>[
<P>object,
<P>uuid(51973C3b-CB0C-11d0-B5C9-00A0244A0E7A),
<P>helpstring("IEnumRemoteDebugApplications Interface"),
<P>pointer_default(unique)
<P>]</FONT><FONT FACE="Courier New"></FONT>
<FONT FACE="Courier New" COLOR="#000080"><P>interface</FONT><FONT FACE="Courier New"> IEnumRemoteDebugApplications : IUnknown {
<P></FONT><FONT SIZE=2 COLOR="#808080">[local]</FONT><FONT FACE="Courier New">
<P>HRESULT </FONT><FONT SIZE=2 COLOR="#808080">__stdcall</FONT><FONT FACE="Courier New"> Next(
<P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New"> ULONG celt,
<P></FONT><FONT SIZE=2 COLOR="#808080">[out]</FONT> <A HREF="#IRemoteDebugApplication">IRemoteDebugApplication</A><A HREF="#IRemoteDebugApplication"><FONT FACE="Courier New">IRemoteDebugApplication</FONT></A><FONT FACE="Courier New"> **ppda,
<P></FONT><FONT SIZE=2 COLOR="#808080">[out]</FONT><FONT FACE="Courier New"> ULONG *pceltFetched);
<P>HRESULT Skip(
<P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New"> ULONG celt);

<P>HRESULT Reset(void);

<P>HRESULT Clone(
<P></FONT><FONT SIZE=2 COLOR="#808080">[out]</FONT> <A HREF="#IEnumRemoteDebugApplications">IEnumRemoteDebugApplications</A><A HREF="#IEnumRemoteDebugApplications"><FONT FACE="Courier New">IEnumRemoteDebugApplications</FONT></A><FONT FACE="Courier New"> **ppessd);
<P>}
</FONT>

<H3><A NAME="IEnumRemoteDebugApplicationThreads">IEnumRemoteDebugApplicationThreads</A></H3>
<P>Enumerates thread objects. Generally used to enumerate the running threads in an application.
<FONT SIZE=2 COLOR="#808080"><P>[
<P>object,
<P>uuid(51973C3c-CB0C-11d0-B5C9-00A0244A0E7A),
<P>helpstring("IEnumRemoteDebugApplicationThreads Interface"),
<P>pointer_default(unique)
<P>]</FONT><FONT FACE="Courier New"></FONT>
<FONT FACE="Courier New" COLOR="#000080"><P>interface</FONT><FONT FACE="Courier New"> IEnumRemoteDebugApplicationThreads : IUnknown {
<P></FONT><FONT SIZE=2 COLOR="#808080">[local]</FONT><FONT FACE="Courier New">
<P>HRESULT </FONT><FONT SIZE=2 COLOR="#808080">__stdcall</FONT><FONT FACE="Courier New"> Next(
<P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New"> ULONG celt,
<P></FONT><FONT SIZE=2 COLOR="#808080">[out]</FONT> <A HREF="#IRemoteDebugApplicationThread">IRemoteDebugApplicationThread</A><A HREF="#IRemoteDebugApplicationThread"><FONT FACE="Courier New">IRemoteDebugApplicationThread</FONT></A><FONT FACE="Courier New"> **pprdat,
<P></FONT><FONT SIZE=2 COLOR="#808080">[out]</FONT><FONT FACE="Courier New"> ULONG *pceltFetched);

<P>HRESULT Skip(
<P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New"> ULONG celt);

<P>HRESULT Reset(void);

<P>HRESULT Clone(
<P></FONT><FONT SIZE=2 COLOR="#808080">[out]</FONT> <A HREF="#IEnumRemoteDebugApplicationThreads">IEnumRemoteDebugApplicationThreads</A><A HREF="#IEnumRemoteDebugApplicationThreads"><FONT FACE="Courier New">IEnumRemoteDebugApplicationThreads</FONT></A><FONT FACE="Courier New"> **pperdat);
<P>}
</FONT>

<H3><A NAME="IDebugFormatter">IDebugFormatter</A></H3>
<P>IDebugFormatter allows a language or IDE to customize the conversion between variants or VARTYPES and strings. This interface is used by the ITypeInfo-&gt;IDebugProperty mapping implementation.
<FONT SIZE=2 COLOR="#808080"><P>[
<P>object,
<P>uuid(51973C3d-CB0C-11d0-B5C9-00A0244A0E7A),
<P>helpstring("IDebugFormatter Interface"),
<P>pointer_default(unique),
<P>local
<P>]</FONT><FONT FACE="Courier New"></FONT>
<FONT FACE="Courier New" COLOR="#000080"><P>interface</FONT><FONT FACE="Courier New"> IDebugFormatter : IUnknown
<P>{
<P>HRESULT GetStringForVariant(</FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New"> VARIANT *pvar, </FONT><FONT SIZE=2 COLOR="#808080">[out]</FONT><FONT FACE="Courier New"> BSTR *pbstrValue);
<P>HRESULT GetVariantForString(</FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New"> LPCOLESTR pwstrValue, </FONT><FONT SIZE=2 COLOR="#808080">[out]</FONT><FONT FACE="Courier New"> VARIANT *pvar);
<P>HRESULT GetStringForVarType(</FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New"> VARTYPE vt, </FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New"> TYPEDESC *ptdescArrayType, </FONT><FONT SIZE=2 COLOR="#808080">[out]</FONT><FONT FACE="Courier New"> BSTR *pbstr);
<P>}
</FONT>

<H3><A NAME="ISimpleConnectionPoint">ISimpleConnectionPoint</A></H3>
<P>This interface is the "IDispatchEx" of event interfaces. It provides a simple way for describing and enumerating the events fired on a particular connection pointan also for hooking up an IDispatch to those events. This interface will be available as extended info via the IDebugProperty interface on objects which support events. For simplicity, this interface only works with dispinterfaces.
<FONT SIZE=2 COLOR="#808080"><P>[
<P>object,
<P>uuid(51973C3e-CB0C-11d0-B5C9-00A0244A0E7A),
<P>helpstring("ISimpleConnectionPoint Interface"),
<P>pointer_default(unique),
<P>local
<P>]</FONT><FONT FACE="Courier New"></FONT>
<FONT FACE="Courier New" COLOR="#000080"><P>interface</FONT><FONT FACE="Courier New"> ISimpleConnectionPoint : IUnknown
<P>{
<P></FONT><FONT COLOR="#008000">// Return the number of events exposed on this interface
</FONT><FONT FACE="Courier New"><P>HRESULT GetEventCount(</FONT><FONT SIZE=2 COLOR="#808080">[out]</FONT><FONT FACE="Courier New"> ULONG *pulCount);

<P></FONT><FONT COLOR="#008000">// Return the DISPID and NAME for "cEvents" events, starting at "iEvent".
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// The number of
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">//- Returns S_OK if all of the requested elements were returned.
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">//- Returns S_FALSE if the enumeration finished and the
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">//requested number of elements was not available.
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">//(Unavailable elements will be returned as DISPID_NULL and a null bstr.)
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">//- Returns E_INVALIDARG (or other error status) if no elements could be fetched
</FONT><FONT FACE="Courier New">
<P>HRESULT DescribeEvents(
<P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New"> ULONG iEvent,</FONT><FONT COLOR="#008000">// starting event index
</FONT><FONT FACE="Courier New"><P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New"> ULONG cEvents,</FONT><FONT COLOR="#008000">// number of events to fetch info for
</FONT><FONT FACE="Courier New"><P></FONT><FONT SIZE=2 COLOR="#808080">[out, size_is(cEvents), length_is(*pcEventsFetched)]</FONT><FONT FACE="Courier New">
<P>DISPID *prgid,</FONT><FONT COLOR="#008000">// DISPIDs of the events
</FONT><FONT FACE="Courier New"><P></FONT><FONT SIZE=2 COLOR="#808080">[out, size_is(cEvents), length_is(*pcEventsFetched)]</FONT><FONT FACE="Courier New">
<P>BSTR *prgbstr,
<P></FONT><FONT SIZE=2 COLOR="#808080">[out]</FONT><FONT FACE="Courier New"> ULONG *pcEventsFetched
<P>);</FONT><FONT COLOR="#008000">// names of the events
</FONT><FONT FACE="Courier New">
<P>HRESULT Advise(</FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New"> IDispatch *pdisp, </FONT><FONT SIZE=2 COLOR="#808080">[out]</FONT><FONT FACE="Courier New"> DWORD* pdwCookie);
<P>HRESULT Unadvise(</FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New"> DWORD dwCookie);
<P>};
</FONT>

<H3><A NAME="IDebugHelper">IDebugHelper</A></H3>
<P>IDebugHelper serves as a factory for object browsers and simple connection points.
<FONT FACE="Courier New"><P>cpp_quote( "EXTERN_C </FONT><FONT FACE="Courier New" COLOR="#000080">const</FONT><FONT FACE="Courier New"> CLSID CLSID_DebugHelper;")
</FONT><FONT SIZE=2 COLOR="#808080"><P>[
<P>object,
<P>uuid(51973C3f-CB0C-11d0-B5C9-00A0244A0E7A),
<P>helpstring("IDebugHelper Interface"),
<P>pointer_default(unique),
<P>local
<P>]</FONT><FONT FACE="Courier New"></FONT>
<FONT FACE="Courier New" COLOR="#000080"><P>interface</FONT><FONT FACE="Courier New"> IDebugHelper : IUnknown
<P>{
<P></FONT><FONT COLOR="#008000">// Returns a property browser that wraps a VARIANT
</FONT><FONT FACE="Courier New"><P>HRESULT CreatePropertyBrowser(
<P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New"> VARIANT *pvar,</FONT><FONT COLOR="#008000">// root variant to browse
</FONT><FONT FACE="Courier New"><P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New"> LPCOLESTR bstrName,</FONT><FONT COLOR="#008000">// name to give the root
</FONT><FONT FACE="Courier New"><P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT> <A HREF="#IDebugApplicationThread">IDebugApplicationThread</A><A HREF="#IDebugApplicationThread"><FONT FACE="Courier New">IDebugApplicationThread</FONT></A><FONT FACE="Courier New"> *pdat, </FONT><FONT COLOR="#008000">// thread to request properties on
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// (or NULL for no marshalling)
</FONT><FONT FACE="Courier New"><P></FONT><FONT SIZE=2 COLOR="#808080">[out]</FONT><FONT FACE="Courier New"> IDebugProperty**ppdob);
<P>
<P></FONT><FONT COLOR="#008000">// Returns a property browser that wraps a VARIANT, and allows for custom conversion
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// of variants or VARTYPEs to strings
</FONT><FONT FACE="Courier New"><P>HRESULT CreatePropertyBrowserEx(
<P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New"> VARIANT *pvar,</FONT><FONT COLOR="#008000">// root variant to browse
</FONT><FONT FACE="Courier New"><P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New"> LPCOLESTR bstrName,</FONT><FONT COLOR="#008000">// name to give the root
</FONT><FONT FACE="Courier New"><P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT> <A HREF="#IDebugApplicationThread">IDebugApplicationThread</A><A HREF="#IDebugApplicationThread"><FONT FACE="Courier New">IDebugApplicationThread</FONT></A><FONT FACE="Courier New"> *pdat, </FONT><FONT COLOR="#008000">// thread to request properties on
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// (or NULL for no marshalling)
</FONT><FONT FACE="Courier New"><P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT> <A HREF="#IDebugFormatter">IDebugFormatter</A><A HREF="#IDebugFormatter"><FONT FACE="Courier New">IDebugFormatter</FONT></A><FONT FACE="Courier New">*pdf,</FONT><FONT COLOR="#008000">// provides custom formatting of variants
</FONT><FONT FACE="Courier New"><P></FONT><FONT SIZE=2 COLOR="#808080">[out]</FONT><FONT FACE="Courier New"> IDebugProperty**ppdob);

<P></FONT><FONT COLOR="#008000">// Returns an event interface that wraps the given IDispatch (see ISimpleConnectionPoint)
</FONT><FONT FACE="Courier New"><P>HRESULT CreateSimpleConnectionPoint(
<P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New"> IDispatch *pdisp,
<P></FONT><FONT SIZE=2 COLOR="#808080">[out]</FONT> <A HREF="#ISimpleConnectionPoint">ISimpleConnectionPoint</A><A HREF="#ISimpleConnectionPoint"><FONT FACE="Courier New">ISimpleConnectionPoint</FONT></A><FONT FACE="Courier New"> **ppscp);
<P>};
</FONT>

<H3><A NAME="IEnumDebugExpressionContexts">IEnumDebugExpressionContexts</A></H3>
<FONT SIZE=2 COLOR="#808080"><P>[
<P>object,
<P>uuid(51973C40-CB0C-11d0-B5C9-00A0244A0E7A),
<P>helpstring("IEnumDebugExpressionContexts Interface"),
<P>pointer_default(unique)
<P>]</FONT><FONT FACE="Courier New"></FONT>
<FONT FACE="Courier New" COLOR="#000080"><P>interface</FONT><FONT FACE="Courier New"> IEnumDebugExpressionContexts : IUnknown
<P>{
<P></FONT><FONT SIZE=2 COLOR="#808080">[local]</FONT><FONT FACE="Courier New">
<P>HRESULT </FONT><FONT SIZE=2 COLOR="#808080">__stdcall</FONT><FONT FACE="Courier New"> Next(
<P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New"> ULONG celt,
<P></FONT><FONT SIZE=2 COLOR="#808080">[out]</FONT> <A HREF="#IDebugExpressionContext">IDebugExpressionContext</A><A HREF="#IDebugExpressionContext"><FONT FACE="Courier New">IDebugExpressionContext</FONT></A><FONT FACE="Courier New"> **ppdec,
<P></FONT><FONT SIZE=2 COLOR="#808080">[out]</FONT><FONT FACE="Courier New"> ULONG *pceltFetched);

<P>HRESULT Skip(
<P></FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New"> ULONG celt);

<P>HRESULT Reset(void);

<P>HRESULT Clone(
<P></FONT><FONT SIZE=2 COLOR="#808080">[out]</FONT> <A HREF="#IEnumDebugExpressionContexts">IEnumDebugExpressionContexts</A><A HREF="#IEnumDebugExpressionContexts"><FONT FACE="Courier New">IEnumDebugExpressionContexts</FONT></A><FONT FACE="Courier New"> **ppedec);
<P>}
</FONT>

<H3><A NAME="IProvideExpressionContexts">IProvideExpressionContexts</A></H3>
<P>Provides a means for enumerating expression contexts known by a certain component. Generally implemented by each script engine. Used by the process debug manager to find all global expression contexts associated with a given thread. Note: This interface is called from within the thread of interest. It is up to the implementor to identify the current thread and return an appropriate enumerator.
<FONT SIZE=2 COLOR="#808080"><P>[
<P>object,
<P>uuid(51973C41-CB0C-11d0-B5C9-00A0244A0E7A),
<P>pointer_default(unique)
<P>]</FONT><FONT FACE="Courier New"></FONT>
<FONT FACE="Courier New" COLOR="#000080"><P>interface</FONT><FONT FACE="Courier New"> IProvideExpressionContexts : IUnknown
<P>{
<P></FONT><FONT COLOR="#008000">// Returns an enumerator of expression contexts.
</FONT><FONT FACE="Courier New"><P>HRESULT EnumExpressionContexts(
<P></FONT><FONT SIZE=2 COLOR="#808080">[out]</FONT> <A HREF="#IEnumDebugExpressionContexts">IEnumDebugExpressionContexts</A><A HREF="#IEnumDebugExpressionContexts"><FONT FACE="Courier New">IEnumDebugExpressionContexts</FONT></A><FONT FACE="Courier New"> **ppedec);
<P>}

</FONT><FONT SIZE=2 COLOR="#808080"><P>[
<P>uuid(78a51821-51f4-11d0-8f20-00805f2cd064),
<P>version(1.0),
<P>helpstring("ProcessDebugManagerLib 1.0 Type Library")
<P>]</FONT><FONT FACE="Courier New">
<P>library ProcessDebugManagerLib
<P>{
<P>importlib("stdole2.tlb");

<P></FONT><FONT FACE="Courier New" COLOR="#000080">interface</FONT><FONT FACE="Courier New"> IActiveScriptDebug;
<P></FONT><FONT FACE="Courier New" COLOR="#000080">interface</FONT> <A HREF="#IActiveScriptErrorDebug"><FONT FACE="Courier New">IActiveScriptErrorDebug</FONT></A><FONT FACE="Courier New">;
<P></FONT><FONT FACE="Courier New" COLOR="#000080">interface</FONT> <A HREF="#IActiveScriptSiteDebug"><FONT FACE="Courier New">IActiveScriptSiteDebug</FONT></A><FONT FACE="Courier New">;
<P></FONT><FONT FACE="Courier New" COLOR="#000080">interface</FONT> <A HREF="#IApplicationDebugger"><FONT FACE="Courier New">IApplicationDebugger</FONT></A><FONT FACE="Courier New">;
<P></FONT><FONT FACE="Courier New" COLOR="#000080">interface</FONT> <A HREF="#IApplicationDebuggerUI"><FONT FACE="Courier New">IApplicationDebuggerUI</FONT></A><FONT FACE="Courier New">;
<P></FONT><FONT FACE="Courier New" COLOR="#000080">interface</FONT> <A HREF="#IDebugApplication"><FONT FACE="Courier New">IDebugApplication</FONT></A><FONT FACE="Courier New">;
<P></FONT><FONT FACE="Courier New" COLOR="#000080">interface</FONT> <A HREF="#IDebugApplicationNode"><FONT FACE="Courier New">IDebugApplicationNode</FONT></A><FONT FACE="Courier New">;
<P></FONT><FONT FACE="Courier New" COLOR="#000080">interface</FONT> <A HREF="#IDebugApplicationNodeEvents"><FONT FACE="Courier New">IDebugApplicationNodeEvents</FONT></A><FONT FACE="Courier New">;
<P></FONT><FONT FACE="Courier New" COLOR="#000080">interface</FONT> <A HREF="#IDebugApplicationThread"><FONT FACE="Courier New">IDebugApplicationThread</FONT></A><FONT FACE="Courier New">;
<P></FONT><FONT FACE="Courier New" COLOR="#000080">interface</FONT> <A HREF="#IDebugAsyncOperation"><FONT FACE="Courier New">IDebugAsyncOperation</FONT></A><FONT FACE="Courier New">;
<P></FONT><FONT FACE="Courier New" COLOR="#000080">interface</FONT> <A HREF="#IDebugAsyncOperationCallBack"><FONT FACE="Courier New">IDebugAsyncOperationCallBack</FONT></A><FONT FACE="Courier New">;
<P></FONT><FONT FACE="Courier New" COLOR="#000080">interface</FONT> <A HREF="#IDebugCodeContext"><FONT FACE="Courier New">IDebugCodeContext</FONT></A><FONT FACE="Courier New">;
<P></FONT><FONT FACE="Courier New" COLOR="#000080">interface</FONT><FONT FACE="Courier New"> IDebugCookie;
<P></FONT><FONT FACE="Courier New" COLOR="#000080">interface</FONT> <A HREF="#IDebugDocument"><FONT FACE="Courier New">IDebugDocument</FONT></A><FONT FACE="Courier New">;
<P></FONT><FONT FACE="Courier New" COLOR="#000080">interface</FONT> <A HREF="#IDebugDocumentContext"><FONT FACE="Courier New">IDebugDocumentContext</FONT></A><FONT FACE="Courier New">;
<P></FONT><FONT FACE="Courier New" COLOR="#000080">interface</FONT> <A HREF="#IDebugDocumentHelper"><FONT FACE="Courier New">IDebugDocumentHelper</FONT></A><FONT FACE="Courier New">;
<P></FONT><FONT FACE="Courier New" COLOR="#000080">interface</FONT> <A HREF="#IDebugDocumentHost"><FONT FACE="Courier New">IDebugDocumentHost</FONT></A><FONT FACE="Courier New">;
<P></FONT><FONT FACE="Courier New" COLOR="#000080">interface</FONT><FONT FACE="Courier New"> IDebugDocumentInfo;
<P></FONT><FONT FACE="Courier New" COLOR="#000080">interface</FONT> <A HREF="#IDebugDocumentProvider"><FONT FACE="Courier New">IDebugDocumentProvider</FONT></A><FONT FACE="Courier New">;
<P></FONT><FONT FACE="Courier New" COLOR="#000080">interface</FONT> <A HREF="#IDebugDocumentText"><FONT FACE="Courier New">IDebugDocumentText</FONT></A><FONT FACE="Courier New">;
<P></FONT><FONT FACE="Courier New" COLOR="#000080">interface</FONT> <A HREF="#IDebugDocumentTextAuthor"><FONT FACE="Courier New">IDebugDocumentTextAuthor</FONT></A><FONT FACE="Courier New">;
<P></FONT><FONT FACE="Courier New" COLOR="#000080">interface</FONT> <A HREF="#IDebugDocumentTextEvents"><FONT FACE="Courier New">IDebugDocumentTextEvents</FONT></A><FONT FACE="Courier New">;
<P></FONT><FONT FACE="Courier New" COLOR="#000080">interface</FONT> <A HREF="#IDebugDocumentTextExternalAuthor"><FONT FACE="Courier New">IDebugDocumentTextExternalAuthor</FONT></A><FONT FACE="Courier New">;
<P></FONT><FONT FACE="Courier New" COLOR="#000080">interface</FONT> <A HREF="#IDebugExpression"><FONT FACE="Courier New">IDebugExpression</FONT></A><FONT FACE="Courier New">;
<P></FONT><FONT FACE="Courier New" COLOR="#000080">interface</FONT><FONT FACE="Courier New"> IDebugExpressionCallBack;
<P></FONT><FONT FACE="Courier New" COLOR="#000080">interface</FONT> <A HREF="#IDebugExpressionContext"><FONT FACE="Courier New">IDebugExpressionContext</FONT></A><FONT FACE="Courier New">;
<P></FONT><FONT FACE="Courier New" COLOR="#000080">interface</FONT> <A HREF="#IDebugFormatter"><FONT FACE="Courier New">IDebugFormatter</FONT></A><FONT FACE="Courier New">;
<P></FONT><FONT FACE="Courier New" COLOR="#000080">interface</FONT> <A HREF="#IDebugHelper"><FONT FACE="Courier New">IDebugHelper</FONT></A><FONT FACE="Courier New">;
<P></FONT><FONT FACE="Courier New" COLOR="#000080">interface</FONT><FONT FACE="Courier New"> IDebugSessionProvider;
<P></FONT><FONT FACE="Courier New" COLOR="#000080">interface</FONT> <A HREF="#IDebugStackFrame"><FONT FACE="Courier New">IDebugStackFrame</FONT></A><FONT FACE="Courier New">;
<P></FONT><FONT FACE="Courier New" COLOR="#000080">interface</FONT> <A HREF="#IDebugStackFrameSniffer"><FONT FACE="Courier New">IDebugStackFrameSniffer</FONT></A><FONT FACE="Courier New">;
<P></FONT><FONT FACE="Courier New" COLOR="#000080">interface</FONT> <A HREF="#IDebugStackFrameSnifferEx"><FONT FACE="Courier New">IDebugStackFrameSnifferEx</FONT></A><FONT FACE="Courier New">;
<P></FONT><FONT FACE="Courier New" COLOR="#000080">interface</FONT> <A HREF="#IDebugSyncOperation"><FONT FACE="Courier New">IDebugSyncOperation</FONT></A><FONT FACE="Courier New">;
<P></FONT><FONT FACE="Courier New" COLOR="#000080">interface</FONT> <A HREF="#IDebugThreadCall"><FONT FACE="Courier New">IDebugThreadCall</FONT></A><FONT FACE="Courier New">;
<P></FONT><FONT FACE="Courier New" COLOR="#000080">interface</FONT> <A HREF="#IEnumDebugApplicationNodes"><FONT FACE="Courier New">IEnumDebugApplicationNodes</FONT></A><FONT FACE="Courier New">;
<P></FONT><FONT FACE="Courier New" COLOR="#000080">interface</FONT> <A HREF="#IEnumDebugCodeContexts"><FONT FACE="Courier New">IEnumDebugCodeContexts</FONT></A><FONT FACE="Courier New">;
<P></FONT><FONT FACE="Courier New" COLOR="#000080">interface</FONT> <A HREF="#IEnumDebugExpressionContexts"><FONT FACE="Courier New">IEnumDebugExpressionContexts</FONT></A><FONT FACE="Courier New">;
<P></FONT><FONT FACE="Courier New" COLOR="#000080">interface</FONT> <A HREF="#IEnumDebugStackFrames"><FONT FACE="Courier New">IEnumDebugStackFrames</FONT></A><FONT FACE="Courier New">;
<P></FONT><FONT FACE="Courier New" COLOR="#000080">interface</FONT> <A HREF="#IEnumRemoteDebugApplications"><FONT FACE="Courier New">IEnumRemoteDebugApplications</FONT></A><FONT FACE="Courier New">;
<P></FONT><FONT FACE="Courier New" COLOR="#000080">interface</FONT> <A HREF="#IEnumRemoteDebugApplicationThreads"><FONT FACE="Courier New">IEnumRemoteDebugApplicationThreads</FONT></A><FONT FACE="Courier New">;
<P></FONT><FONT FACE="Courier New" COLOR="#000080">interface</FONT> <A HREF="#IMachineDebugManager"><FONT FACE="Courier New">IMachineDebugManager</FONT></A><FONT FACE="Courier New">;
<P></FONT><FONT FACE="Courier New" COLOR="#000080">interface</FONT> <A HREF="#IMachineDebugManagerCookie"><FONT FACE="Courier New">IMachineDebugManagerCookie</FONT></A><FONT FACE="Courier New">;
<P></FONT><FONT FACE="Courier New" COLOR="#000080">interface</FONT> <A HREF="#IMachineDebugManagerEvents"><FONT FACE="Courier New">IMachineDebugManagerEvents</FONT></A><FONT FACE="Courier New">;
<P></FONT><FONT FACE="Courier New" COLOR="#000080">interface</FONT><FONT FACE="Courier New"> IProcessDebugManager;
<P></FONT><FONT FACE="Courier New" COLOR="#000080">interface</FONT> <A HREF="#IProvideExpressionContexts"><FONT FACE="Courier New">IProvideExpressionContexts</FONT></A><FONT FACE="Courier New">;
<P></FONT><FONT FACE="Courier New" COLOR="#000080">interface</FONT> <A HREF="#IRemoteDebugApplication"><FONT FACE="Courier New">IRemoteDebugApplication</FONT></A><FONT FACE="Courier New">;
<P></FONT><FONT FACE="Courier New" COLOR="#000080">interface</FONT><FONT FACE="Courier New"> IRemoteDebugApplicationEvents;
<P></FONT><FONT FACE="Courier New" COLOR="#000080">interface</FONT> <A HREF="#IRemoteDebugApplicationThread"><FONT FACE="Courier New">IRemoteDebugApplicationThread</FONT></A><FONT FACE="Courier New">;
<P></FONT><FONT FACE="Courier New" COLOR="#000080">interface</FONT> <A HREF="#ISimpleConnectionPoint"><FONT FACE="Courier New">ISimpleConnectionPoint</FONT></A><FONT FACE="Courier New">;

<P></FONT><FONT SIZE=2 COLOR="#808080">[
<P>uuid(78a51822-51f4-11d0-8f20-00805f2cd064),
<P>helpstring("ProcessDebugManager Class")
<P>]</FONT><FONT FACE="Courier New">
<P></FONT><FONT FACE="Courier New" COLOR="#000080">coclass</FONT><FONT FACE="Courier New"> ProcessDebugManager
<P>{
<P></FONT><FONT SIZE=2 COLOR="#808080">[default]</FONT> <FONT FACE="Courier New" COLOR="#000080">interface</FONT><FONT FACE="Courier New"> IProcessDebugManager;
<P>};

<P></FONT><FONT SIZE=2 COLOR="#808080">[
<P>uuid(0BFCC060-8C1D-11d0-ACCD-00AA0060275C),
<P>helpstring("DebugHelper Class")
<P>]</FONT><FONT FACE="Courier New">
<P></FONT><FONT FACE="Courier New" COLOR="#000080">coclass</FONT><FONT FACE="Courier New"> DebugHelper
<P>{
<P></FONT><FONT SIZE=2 COLOR="#808080">[default]</FONT> <FONT FACE="Courier New" COLOR="#000080">interface</FONT> <A HREF="#IDebugHelper"><FONT FACE="Courier New">IDebugHelper</FONT></A><FONT FACE="Courier New">;
<P>};

<P></FONT><FONT COLOR="#008000">// CDebugDocumentHelper
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">//
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// The CDebugDocumentHelper makes it much easier for an ActiveScripting
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// host or scripting engine to implement the IDebugDocument interfaces.
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">//
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// Given the source text and (optionally) script blocks for a host's
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// document, CDebugDocumentHelper provides implementations for
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// the debug document interfaces, including:
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">//
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">//- IDebugDocumentText
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">//- IDebugDocumentTextAuthor (for authoring)
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">//- IDebugDocumentContext
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">//
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// This class supports aggregation, so the host may provide a controlling
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// unknown to CoCreateInstance for extensibility.
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">//
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// This class fires events on IDebugDocumentTextEvents, so the host
</FONT><FONT FACE="Courier New"><P></FONT><FONT COLOR="#008000">// can monitor all changes to the document via that interface.
</FONT><FONT FACE="Courier New"><P>cpp_quote( "EXTERN_C </FONT><FONT FACE="Courier New" COLOR="#000080">const</FONT><FONT FACE="Courier New"> CLSID CLSID_CDebugDocumentHelper;")
<P></FONT><FONT SIZE=2 COLOR="#808080">[
<P>uuid(83B8BCA6-687C-11D0-A405-00AA0060275C),
<P>helpstring("DebugDocumentHelper Class")
<P>]</FONT><FONT FACE="Courier New">
<P></FONT><FONT FACE="Courier New" COLOR="#000080">coclass</FONT><FONT FACE="Courier New"> CDebugDocumentHelper
<P>{
<P></FONT><FONT SIZE=2 COLOR="#808080">[default]</FONT> <FONT FACE="Courier New" COLOR="#000080">interface</FONT> <A HREF="#IDebugDocumentHelper"><FONT FACE="Courier New">IDebugDocumentHelper</FONT></A><FONT FACE="Courier New">;
<P></FONT><FONT FACE="Courier New" COLOR="#000080">interface</FONT> <A HREF="#IDebugDocumentProvider"><FONT FACE="Courier New">IDebugDocumentProvider</FONT></A><FONT FACE="Courier New">;
<P></FONT><FONT FACE="Courier New" COLOR="#000080">interface</FONT> <A HREF="#IDebugDocument"><FONT FACE="Courier New">IDebugDocument</FONT></A><FONT FACE="Courier New">;
<P></FONT><FONT FACE="Courier New" COLOR="#000080">interface</FONT> <A HREF="#IDebugDocumentText"><FONT FACE="Courier New">IDebugDocumentText</FONT></A><FONT FACE="Courier New">;
<P></FONT><FONT FACE="Courier New" COLOR="#000080">interface</FONT> <A HREF="#IDebugDocumentTextAuthor"><FONT FACE="Courier New">IDebugDocumentTextAuthor</FONT></A><FONT FACE="Courier New">;
<P></FONT><FONT FACE="Courier New" COLOR="#000080">interface</FONT><FONT FACE="Courier New"> IConnectionPointContainer;
<P></FONT><FONT SIZE=2 COLOR="#808080">[default, source]</FONT> <FONT FACE="Courier New" COLOR="#000080">interface</FONT> <A HREF="#IDebugDocumentTextEvents"><FONT FACE="Courier New">IDebugDocumentTextEvents</FONT></A><FONT FACE="Courier New">;
<P>};
<P>};
</FONT>
<!-- CONTENTS_END -->
<!-- START PAGE FOOTER -->
<H6><HR size=1></H6>
<P><A ID=line HREF="#pagetop"><IMG src="../art/arrowup1.gif" WIDTH="17" HEIGHT="16" ALIGN="MIDDLE" BORDER="0" ALT="Up">&nbsp;Top of Page</A>
<BR><A ID=line HREF="http://www.microsoft.com/misc/cpyright.htm" TARGET="_top">&#169; 1997 Microsoft Corporation. All rights reserved. Terms of Use.</A>
<!-- END PAGE FOOTER -->
</BLOCKQUOTE>
</BODY>
</HTML>