<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Debug Property Interfaces</TITLE>

<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso8859-1">
<META NAME="MS.LOCALE" CONTENT="EN-US">
<META NAME=MS-HKWD CONTENT="Debug Property Interfaces">
<META NAME="Keywords" CONTENT="Debug Property Interfaces">
<META NAME="Platform" CONTENT="Windows">
<META NAME="ROBOTS" CONTENT="all">

<!--@ SNIFF_START -->
<SCRIPT>
//<!--
var g_isIE = false, g_isNav = false, g_iMaj = 0, g_sPlat = "";
// -->
</SCRIPT>
<SCRIPT SRC="../code/ver.js"></SCRIPT>
<!--@ SNIFF_END -->

<SCRIPT DEFER SRC="../code/common.js"></SCRIPT>
<SCRIPT DEFER>
//<!--
function InitPage()
{
	if (g_isIE && g_iMaj >= 4)	
	{
		SetTOC();
	}
}
//-->
</SCRIPT>

<LINK REL="stylesheet" HREF="/msdn/sdk/inetsdk/help/basicsdkIE4.css" TYPE="text/css">
<!-- STYLE_START -->


<SCRIPT>
//<!--
   var sVR = '../'	// Set root for the style sheet
   var sCSS = '<LINK REL="stylesheet" HREF="' + sVR;

   if(g_isIE)
   {
	   if (g_iMaj >= 4) // For MSIE 4.0 or later
	   {
		   sCSS += 'basicSDKIE4';
		   if (g_sPlat == "Win") // Windows only for now
		   {
			   document.createStyleSheet(sVR + 'advSDKIE4.css');
		   }
	   }
	   else // For MSIE 3.0 or earlier
	   {
		   sCSS += 'basicSDKIE3';
	   }
   }
   else if (g_isNav) // For all Nav versions
   {
	   sCSS += 'basicSDKNAV';
   }
   else
   {
	   sCSS += 'basicSDKIE3'; // default to IE3 sheet
   }

   sCSS += (sCSS == '' ? '' : '.css" TYPE="text/css">');

   document.write(sCSS);
//-->
</SCRIPT>
<!-- STYLE_END -->
</HEAD>
<BODY onload="InitPage()" BGCOLOR="#FFFFFF">

<A NAME="pagetop"></A>
<!-- NAV_LINKS_START -->
<TABLE class=main BORDER=0 CELLSPACING="0" CELLPADDING="0" WIDTH="10%"><TR><TD ROWSPAN="3" VALIGN="TOP" WIDTH="121"><IMG SRC="../art/headbar2.gif" WIDTH="121" HEIGHT="82" BORDER=0 ALT="Debug Property Interfaces"></TD><TD ROWSPAN="2" VALIGN="TOP" WIDTH="186"><IMG SRC="../art/headbarc.gif" WIDTH="186" HEIGHT="44" BORDER=0 ALT="Debug Property Interfaces"></TD><TD VALIGN="TOP" WIDTH="470"><IMG SRC="../art/replace1.gif" WIDTH="470" HEIGHT="17" BORDER=0 ALT="*"></TD></TR><TR><TD><PRE><IMG SRC="../art/arrowrht.gif" WIDTH="14" HEIGHT="14" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black" ID=TOC HREF="../contents.htm">Contents</A>  <IMG SRC="../art/arrowrht.gif" WIDTH="14" HEIGHT="14" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black" HREF="../index.htm">Index</A>  <IMG SRC="../art/arrowrht.gif" WIDTH="14" HEIGHT="14" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black" HREF="../compdev/scripting/scripting.htm">Topic Contents</A></PRE></TD></TR>
<TR><TD COLSPAN="2"><PRE><IMG SRC="../art/arrowlft.gif" WIDTH="17" HEIGHT="15" ALIGN="MIDDLE" BORDER=0 ALT="*"><B>Previous Topic:</B> <A STYLE="color:black" HREF="activdbg.htm">Active Script Debugging Interfaces</A></PRE></TD></TR>
</TABLE>
<!-- NAV_LINKS_END -->
<BLOCKQUOTE class="body">
<!-- CONTENTS_START -->
<H1>Debug Property Interfaces</H1>
<P>This document describes the following interfaces used to examine debugging properties:
<P><FONT FACE="Courier New">IDebugProperty; </FONT>
<P><FONT FACE="Courier New">IDebugExtendedProperty; </FONT>
<P><FONT FACE="Courier New">IEnumDebugPropertyInfo; </FONT>
<P><FONT FACE="Courier New">IEnumDebugExtendedPropertyInfo; </FONT>
<P><FONT FACE="Courier New">IPerPropertyBrowsing2; </FONT>

<P><B>IDebugProperty Intro</B>
<P>The IDebugProperty interface provides a language-neutral way to browse entities such as: 

<UL>
<LI>object properties, methods, and events    
<LI>interfaces   
<LI>local variables 
</UL>

<P> IDebugProperty is not intended to be a general replacement for ITypeInfo.  For example, it does not include enough low-level information to construct vtable  calls or implement IDispatch.  
<P>Instead, IDebugProperty is intended to provide human-readable information to  allow IDE users to browse and modify objects at design or run-time. Because  of this more limited scope, IDebugProperty is much easier to use and to  implement than ITypeInfo.  
<P>One example of how IDebugProperty can be used is to get a root IDebugProperty  from a given stack frame (this IDebugProperty actually represents that stack  frame). The members of this root IDebugProperty are the local variables and method parameters, and can be retrieved by calling IDebugProperty::EnumMembers followed by IEnumDebugPropertyInfo::Next. Next returns an array of DebugPropertyInfo structures that contains all the info generally displayed by IDEs in a variables window: name, type, value, etc, as well as attributes  that specify if a property is expandable, among other things.  
<P>The IDebugProperty interface could also be used to represent registers, memory, or whatever. 
<P>The majority of consumers of this interface will be interested only in the IDebugProperty and IEnumDebugPropertyInfo interfaces and will probably want to ignore IDebugExtendedProperty and IEnumDebugExtendedProperty. 
<B><I><P>INTERFACE NOTES:</I></B>
<P>===============

<DIR>
<P>Run-time type vs. declared type 
<P>The type of a DebugProperty can be determined via two methods. When the type  is obtained via GetPropertyInfo, the type is the <B>run-time</B> type. However, when the type obtained via a GetMemberEnum on the parent, the type is the <B>declared</B> type. In other words, object ‘A’ will give you its run-time type, but A’s parent will give you A’s declared type. </DIR>

<FONT FACE="Courier New" SIZE=2><P>enum 
<P>{ 
<P>&#9;</FONT><FONT SIZE=2 COLOR="#008000">// ----------------------------------------------------------------------- 
</FONT><FONT FACE="Courier New" SIZE=2><P>&#9;</FONT><FONT SIZE=2 COLOR="#008000">// OBJECT ATTRIBUTES 
</FONT><FONT FACE="Courier New" SIZE=2><P>&#9;DBGPROP_ATTRIB_NO_ATTRIB =&#9;&#9;0x00000000, 
<P>&#9;</FONT><FONT SIZE=2 COLOR="#008000">// --------------------- 
</FONT><FONT FACE="Courier New" SIZE=2><P>&#9;</FONT><FONT SIZE=2 COLOR="#008000">// Characteristics  
</FONT><FONT FACE="Courier New" SIZE=2><P>&#9;DBGPROP_ATTRIB_VALUE_IS_INVALID =&#9;0x00000008,&#9;</FONT><FONT SIZE=2 COLOR="#008000">// the value in this slot is invalid 
</FONT><FONT FACE="Courier New" SIZE=2><P>&#9;DBGPROP_ATTRIB_VALUE_IS_EXPANDABLE =0x00000010,&#9;</FONT><FONT SIZE=2 COLOR="#008000">// the object has children 
</FONT><FONT FACE="Courier New" SIZE=2><P>&#9;DBGPROP_ATTRIB_VALUE_READONLY =&#9;0x00000800,&#9;</FONT><FONT SIZE=2 COLOR="#008000">// the value is read-only 
</FONT><FONT FACE="Courier New" SIZE=2><P>&#9;</FONT><FONT SIZE=2 COLOR="#008000">// --------------------- 
</FONT><FONT FACE="Courier New" SIZE=2><P>&#9;</FONT><FONT SIZE=2 COLOR="#008000">// Attributes about a slot's type 
</FONT><FONT FACE="Courier New" SIZE=2><P>&#9;</FONT><FONT SIZE=2 COLOR="#008000">// --------------------- 
</FONT><FONT FACE="Courier New" SIZE=2><P>&#9;</FONT><FONT SIZE=2 COLOR="#008000">// Common attributes 
</FONT><FONT FACE="Courier New" SIZE=2><P>&#9;</FONT><FONT SIZE=2 COLOR="#008000">// field access control 
</FONT><FONT FACE="Courier New" SIZE=2><P>&#9;DBGPROP_ATTRIB_ACCESS_PUBLIC =&#9;0x00001000, 
<P>&#9;DBGPROP_ATTRIB_ACCESS_PRIVATE =&#9;0x00002000, 
<P>&#9;DBGPROP_ATTRIB_ACCESS_PROTECTED =&#9;0x00004000, 
<P>&#9;DBGPROP_ATTRIB_ACCESS_FINAL =&#9;&#9;0x00008000, 
<P>&#9;</FONT><FONT SIZE=2 COLOR="#008000">// storage types 
</FONT><FONT FACE="Courier New" SIZE=2><P>&#9;DBGPROP_ATTRIB_STORAGE_GLOBAL =&#9;0x00010000, 
<P>&#9;DBGPROP_ATTRIB_STORAGE_STATIC =&#9;0x00020000, 
<P>&#9;DBGPROP_ATTRIB_STORAGE_FIELD =&#9;0x00040000, 
<P>&#9;</FONT><FONT SIZE=2 COLOR="#008000">// type modifiers  
</FONT><FONT FACE="Courier New" SIZE=2><P>&#9;DBGPROP_ATTRIB_STORAGE_VIRTUAL =&#9;0x00080000,&#9;&#9;</FONT><FONT SIZE=2 COLOR="#008000">// this slot is virtual 
</FONT><FONT FACE="Courier New" SIZE=2><P>&#9;DBGPROP_ATTRIB_TYPE_IS_CONSTANT =&#9;0x00100000,&#9;&#9;</FONT><FONT SIZE=2 COLOR="#008000">// this slot is a constant value 
</FONT><FONT FACE="Courier New" SIZE=2><P>&#9;DBGPROP_ATTRIB_TYPE_IS_SYNCHRONIZED =0x00200000,&#9;</FONT><FONT SIZE=2 COLOR="#008000">// this slot is thread synchronized 
</FONT><FONT FACE="Courier New" SIZE=2><P>&#9;DBGPROP_ATTRIB_TYPE_IS_VOLATILE =&#9;0x00400000,&#9;&#9;</FONT><FONT SIZE=2 COLOR="#008000">// this slot is volatile storage
</FONT><FONT FACE="Courier New" SIZE=2><P>&#9;DBGPROP_ATTRIB_HAS_EXTENDED_ATTRIBS =0x00800000       </FONT><FONT SIZE=2 COLOR="#008000">// has more attributes
</FONT><FONT FACE="Courier New" SIZE=2><P>}; 
</FONT><FONT FACE="Courier New" SIZE=2 COLOR="#000080"><P>typedef</FONT><FONT FACE="Courier New" SIZE=2> DWORD DBGPROP_ATTRIB_FLAGS; 
<P> 
</FONT><FONT SIZE=2 COLOR="#008000"><P>// -----------------------------------------------------------------------
<P>// DebugPropertyInfo 
<P>// Basic info that all IDebugProperty implementations must support 
</FONT><FONT FACE="Courier New" SIZE=2><P>enum 
<P>{ 
<P>&#9;</FONT><FONT SIZE=2 COLOR="#008000">// Flags used to specify DebugPropertyInfo (and ExtendedDebugPropertyInfo) fields 
</FONT><FONT FACE="Courier New" SIZE=2><P>&#9;DBGPROP_INFO_NAME =&#9;&#9;0x001,&#9;&#9;</FONT><FONT SIZE=2 COLOR="#008000">// init the bstrName field 
</FONT><FONT FACE="Courier New" SIZE=2><P>&#9;DBGPROP_INFO_TYPE =&#9;&#9;0x002,&#9;&#9;</FONT><FONT SIZE=2 COLOR="#008000">// init the bstrType field 
</FONT><FONT FACE="Courier New" SIZE=2><P>&#9;DBGPROP_INFO_VALUE =&#9;&#9;0x004,&#9;&#9;</FONT><FONT SIZE=2 COLOR="#008000">// init the bstrValue field 
</FONT><FONT FACE="Courier New" SIZE=2><P>&#9;DBGPROP_INFO_FULLNAME =&#9;&#9;0x020,&#9;&#9;</FONT><FONT SIZE=2 COLOR="#008000">// init the full name field 
</FONT><FONT FACE="Courier New" SIZE=2><P>&#9;DBGPROP_INFO_ATTRIBUTES =&#9;0x008,&#9;&#9;</FONT><FONT SIZE=2 COLOR="#008000">// init the dwAttrib field
</FONT><FONT FACE="Courier New" SIZE=2><P>&#9;DBGPROP_INFO_DEBUGPROP =&#9;0x010,&#9;&#9;</FONT><FONT SIZE=2 COLOR="#008000">// init the pDebugProp field 
</FONT><FONT FACE="Courier New" SIZE=2><P>&#9;DBGPROP_INFO_AUTOEXPAND =&#9;0x8000000&#9;&#9;</FONT><FONT SIZE=2 COLOR="#008000">// make the Value result auto-expand 
</FONT><FONT FACE="Courier New" SIZE=2><P>}; 
</FONT><FONT FACE="Courier New" SIZE=2 COLOR="#000080"><P>typedef</FONT><FONT FACE="Courier New" SIZE=2> DWORD DBGPROP_INFO_FLAGS; 
</FONT><FONT FACE="Courier New" SIZE=2 COLOR="#000080"><P>const</FONT><FONT FACE="Courier New" SIZE=2> DBGPROP_INFO_FLAGS DBGPROP_INFO_STANDARD = 
<P>&#9;DBGPROP_INFO_NAME | 
<P>&#9;DBGPROP_INFO_TYPE | 
<P>&#9;DBGPROP_INFO_VALUE | 
<P>&#9;DBGPROP_INFO_ATTRIBUTES; 
</FONT><FONT FACE="Courier New" SIZE=2 COLOR="#000080"><P>const</FONT><FONT FACE="Courier New" SIZE=2> DBGPROP_INFO_FLAGS DBGPROP_INFO_ALL =&#9;&#9;
<P>&#9;DBGPROP_INFO_NAME | 
<P>&#9;DBGPROP_INFO_TYPE | 
<P>&#9;DBGPROP_INFO_VALUE | 
<P>&#9;DBGPROP_INFO_FULLNAME | 
<P>&#9;DBGPROP_INFO_ATTRIBUTES | 
<P>&#9;DBGPROP_INFO_DEBUGPROP; 
<P> 
</FONT><FONT FACE="Courier New" SIZE=2 COLOR="#000080"><P>typedef</FONT><FONT FACE="Courier New" SIZE=2> struct tagDebugPropertyInfo 
<P>{ 
<P>&#9;DBGPROP_INFO_FLAGS&#9;m_dwValidFields;&#9;</FONT><FONT SIZE=2 COLOR="#008000">// which DebugPropertyInfo fields were successfully initialized 
</FONT><FONT FACE="Courier New" SIZE=2><P>&#9;BSTR&#9;&#9;&#9;&#9;m_bstrName;&#9;&#9;</FONT><FONT SIZE=2 COLOR="#008000">// property name 
</FONT><FONT FACE="Courier New" SIZE=2><P>&#9;BSTR&#9;&#9;&#9;&#9;m_bstrType;&#9;&#9;</FONT><FONT SIZE=2 COLOR="#008000">// property type, as formatted string 
</FONT><FONT FACE="Courier New" SIZE=2><P>&#9;BSTR&#9;&#9;&#9;&#9;m_bstrValue;&#9;</FONT><FONT SIZE=2 COLOR="#008000">// property value, as formatted string 
</FONT><FONT FACE="Courier New" SIZE=2><P>&#9;BSTR&#9;&#9;&#9;&#9;m_bstrFullName;&#9;</FONT><FONT SIZE=2 COLOR="#008000">// property's full name, like pObject-&gt;m_fFlag 
</FONT><FONT FACE="Courier New" SIZE=2><P>&#9;DBGPROP_ATTRIB_FLAGS&#9;m_dwAttrib;&#9;&#9;</FONT><FONT SIZE=2 COLOR="#008000">// property attributes (ORed DBGPROP_ATTRIB_* above) 
</FONT><FONT FACE="Courier New" SIZE=2><P>&#9;IDebugProperty*&#9;&#9;m_pDebugProp;&#9;</FONT><FONT SIZE=2 COLOR="#008000">// IDebugProperty object corresponding to this DebugPropertyInfo 
</FONT><FONT FACE="Courier New" SIZE=2><P>} DebugPropertyInfo; 
<P> 
</FONT><FONT SIZE=2 COLOR="#008000"><P>// ----------------------------------------------------------------------- 
<P>// Extended info that some IDebugProperty implementations support 
</FONT><FONT FACE="Courier New" SIZE=2><P>enum 
<P>{ 
<P>&#9;</FONT><FONT SIZE=2 COLOR="#008000">// Flags used to specify ExtendedDebugPropertyInfo fields 
</FONT><FONT FACE="Courier New" SIZE=2><P>&#9;EX_DBGPROP_INFO_ID =&#9;&#9;&#9;0x0100,&#9;&#9;</FONT><FONT SIZE=2 COLOR="#008000">// init the nDISPID field 
</FONT><FONT FACE="Courier New" SIZE=2><P>&#9;EX_DBGPROP_INFO_NTYPE =&#9;&#9;&#9;0x0200,&#9;&#9;</FONT><FONT SIZE=2 COLOR="#008000">// init the nType field 
</FONT><FONT FACE="Courier New" SIZE=2><P>&#9;EX_DBGPROP_INFO_NVALUE =&#9;&#9;0x0400,&#9;&#9;</FONT><FONT SIZE=2 COLOR="#008000">// init the varValue field 
</FONT><FONT FACE="Courier New" SIZE=2><P>&#9;EX_DBGPROP_INFO_LOCKBYTES =&#9;&#9;0x0800,&#9;&#9;</FONT><FONT SIZE=2 COLOR="#008000">// init the plb field 
</FONT><FONT FACE="Courier New" SIZE=2><P>&#9;EX_DBGPROP_INFO_DEBUGEXTPROP =&#9;0x1000,&#9;&#9;</FONT><FONT SIZE=2 COLOR="#008000">// init the pDebugExtProp field 
</FONT><FONT FACE="Courier New" SIZE=2><P>}; 
</FONT><FONT FACE="Courier New" SIZE=2 COLOR="#000080"><P>typedef</FONT><FONT FACE="Courier New" SIZE=2> DWORD EX_DBGPROP_INFO_FLAGS; 
<P> 
</FONT><FONT FACE="Courier New" SIZE=2 COLOR="#000080"><P>typedef</FONT><FONT FACE="Courier New" SIZE=2> struct tagExtendedDebugPropertyInfo 
<P>{ 
<P>&#9;</FONT><FONT SIZE=2 COLOR="#008000">// members from DebugPropertyInfo 
</FONT><FONT FACE="Courier New" SIZE=2><P>&#9;DBGPROP_INFO_FLAGS&#9;m_dwValidFields;&#9;</FONT><FONT SIZE=2 COLOR="#008000">// which ExtendedDebugPropertyInfo fields were successfully initialized 
</FONT><FONT FACE="Courier New" SIZE=2><P>&#9;LPOLESTR&#9;&#9;&#9;m_bstrName;&#9;&#9;</FONT><FONT SIZE=2 COLOR="#008000">// property name 
</FONT><FONT FACE="Courier New" SIZE=2><P>&#9;LPOLESTR&#9;&#9;&#9;m_bstrType;&#9;&#9;</FONT><FONT SIZE=2 COLOR="#008000">// property type, as formatted string 
</FONT><FONT FACE="Courier New" SIZE=2><P>&#9;LPOLESTR&#9;&#9;&#9;m_bstrValue;&#9;</FONT><FONT SIZE=2 COLOR="#008000">// property value, as formatted string 
</FONT><FONT FACE="Courier New" SIZE=2><P>&#9;LPOLESTR&#9;&#9;&#9;m_bstrFullName;&#9;</FONT><FONT SIZE=2 COLOR="#008000">// property's full name, like pObject-&gt;m_fFlag 
</FONT><FONT FACE="Courier New" SIZE=2><P>&#9;DBGPROP_ATTRIB_FLAGS&#9;m_dwAttrib;&#9;&#9;</FONT><FONT SIZE=2 COLOR="#008000">// property attributes (ORed DBGPROP_ATTRIB_* above) 
</FONT><FONT FACE="Courier New" SIZE=2><P>&#9;IDebugProperty*&#9;&#9;m_pDebugProp;&#9;</FONT><FONT SIZE=2 COLOR="#008000">// IDebugProperty object corresponding to this DebugPropertyInfo 
</FONT><FONT FACE="Courier New" SIZE=2><P>&#9;</FONT><FONT SIZE=2 COLOR="#008000">// extra members 
</FONT><FONT FACE="Courier New" SIZE=2><P>&#9;DWORD&#9;&#9;&#9;&#9;m_nDISPID;&#9;&#9;</FONT><FONT SIZE=2 COLOR="#008000">// DISPID of this child (DISPID_NIL, if n/a or none) 
</FONT><FONT FACE="Courier New" SIZE=2><P>&#9;DWORD&#9;&#9;&#9;&#9;m_nType;&#9;&#9;</FONT><FONT SIZE=2 COLOR="#008000">// property type 
</FONT><FONT FACE="Courier New" SIZE=2><P>&#9;VARIANT&#9;&#9;&#9;m_varValue;&#9;&#9;</FONT><FONT SIZE=2 COLOR="#008000">// property value (if value can physically fit in VARIANT) 
</FONT><FONT FACE="Courier New" SIZE=2><P>&#9;ILockBytes*&#9;&#9;&#9;m_plbValue;&#9;&#9;</FONT><FONT SIZE=2 COLOR="#008000">// property value (actual data bytes)
</FONT><FONT FACE="Courier New" SIZE=2><P>&#9;IDebugExtendedProperty*&#9;m_pDebugExtProp;&#9;</FONT><FONT SIZE=2 COLOR="#008000">// IDebugExtendedProperty object corresponding to this DebugPropertyInfo 
</FONT><FONT FACE="Courier New" SIZE=2><P>} ExtendedDebugPropertyInfo; 
<P> 
</FONT><FONT SIZE=2 COLOR="#008000"><P>// ----------------------------------------------------------------------- 
<P>// IDebugProperty 
</FONT><FONT SIZE=2 COLOR="#808080"><P>[ 
<P>&#9;object, 
<P>&#9;uuid(51973C50-CB0C-11d0-B5C9-00A0244A0E7A),, 
<P>&#9;pointer_default(unique) 
<P>]</FONT><FONT FACE="Courier New" SIZE=2> 
</FONT><FONT FACE="Courier New" SIZE=2 COLOR="#000080"><P>interface</FONT><FONT FACE="Courier New" SIZE=2> IDebugProperty : IUnknown 
<P>{ 
<P>&#9;</FONT><FONT SIZE=2 COLOR="#008000">// Get Information for this object 
</FONT><FONT FACE="Courier New" SIZE=2><P>&#9;</FONT><FONT SIZE=2 COLOR="#008000">// By setting various PROPERTY_INFO_FLAGS, any subset of the basic info  
</FONT><FONT FACE="Courier New" SIZE=2><P>&#9;</FONT><FONT SIZE=2 COLOR="#008000">// contained in DebugPropertyInfo can be fetched 
</FONT><FONT FACE="Courier New" SIZE=2><P>HRESULT GetPropertyInfo( 
<P>&#9;&#9;</FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New" SIZE=2> DBGPROP_INFO_FLAGS dwFieldSpec, 
<P>&#9;&#9;</FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New" SIZE=2> UINT nRadix, 
<P>&#9;&#9;</FONT><FONT SIZE=2 COLOR="#808080">[out]</FONT><FONT FACE="Courier New" SIZE=2> DebugPropertyInfo* pPropertyInfo); 
<P>&#9;</FONT><FONT SIZE=2 COLOR="#008000">// Get ExtendedInfo for this object. This API only exists for the purpose 
</FONT><FONT FACE="Courier New" SIZE=2><P>&#9;</FONT><FONT SIZE=2 COLOR="#008000">// of retrieving info that does not lend itself to being retrieved via the 
</FONT><FONT FACE="Courier New" SIZE=2><P>&#9;</FONT><FONT SIZE=2 COLOR="#008000">// standard means (i.e. using DebugPropertyInfo) 
</FONT><FONT FACE="Courier New" SIZE=2><P>&#9;</FONT><FONT SIZE=2 COLOR="#008000">//  
</FONT><FONT FACE="Courier New" SIZE=2><P>&#9;</FONT><FONT SIZE=2 COLOR="#008000">// An array of GUIDs and result VARIANTs is passed so that multiple items 
</FONT><FONT FACE="Courier New" SIZE=2><P>&#9;</FONT><FONT SIZE=2 COLOR="#008000">// of extended info can be fetched at the same time. If a variant cannot 
</FONT><FONT FACE="Courier New" SIZE=2><P>&#9;</FONT><FONT SIZE=2 COLOR="#008000">// be initialized for some reason, the vt field should be set to VT_ERROR. 
</FONT><FONT FACE="Courier New" SIZE=2><P> 
<P>&#9;</FONT><FONT SIZE=2 COLOR="#008000">// The currently defined extended info guids are described below. 
</FONT><FONT FACE="Courier New" SIZE=2><P>&#9;</FONT><FONT SIZE=2 COLOR="#008000">// A QI is typically required to obtain interfaces on the right from 
</FONT><FONT FACE="Courier New" SIZE=2><P>&#9;</FONT><FONT SIZE=2 COLOR="#008000">// IUnknowns in the variant. 
</FONT><FONT FACE="Courier New" SIZE=2><P> 
<P>&#9;</FONT><FONT SIZE=2 COLOR="#008000">// GUID VALUE 
</FONT><FONT FACE="Courier New" SIZE=2><P>&#9;</FONT><FONT SIZE=2 COLOR="#008000">// 
</FONT><FONT FACE="Courier New" SIZE=2><P>&#9;</FONT><FONT SIZE=2 COLOR="#008000">// guidDefinitionContext IDebugDocumentContext2 
</FONT><FONT FACE="Courier New" SIZE=2><P>&#9;</FONT><FONT SIZE=2 COLOR="#008000">// ISSUE: Add additional GUIDS, such as: 
</FONT><FONT FACE="Courier New" SIZE=2><P>&#9;</FONT><FONT SIZE=2 COLOR="#008000">// &lt;guidSomeRandomBSTR&gt; BSTR 
</FONT><FONT FACE="Courier New" SIZE=2><P>&#9;</FONT><FONT SIZE=2 COLOR="#008000">// &lt;guidSomeRandomI4&gt; I4 
</FONT><FONT FACE="Courier New" SIZE=2><P>&#9;HRESULT GetExtendedInfo( 
<P>&#9;&#9;</FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New" SIZE=2> ULONG cInfos,  
<P>&#9;&#9;</FONT><FONT SIZE=2 COLOR="#808080">[in, size_is(cInfos)]</FONT><FONT FACE="Courier New" SIZE=2> GUID* rgguidExtendedInfo,
<P>&#9;&#9;</FONT><FONT SIZE=2 COLOR="#808080">[out, size_is(cInfos)]</FONT><FONT FACE="Courier New" SIZE=2> VARIANT* rgvar); 
<P> 
<P>&#9;</FONT><FONT SIZE=2 COLOR="#008000">// Set the value of this object as a string&#9; 
</FONT><FONT FACE="Courier New" SIZE=2><P>&#9;HRESULT SetValueAsString( 
<P>&#9;&#9;</FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New" SIZE=2> LPCOLESTR pszValue, 
<P>&#9;&#9;</FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New" SIZE=2> UINT nRadix); 
<P> 
<P>&#9;</FONT><FONT SIZE=2 COLOR="#008000">// Get enumerator for props of members 
</FONT><FONT FACE="Courier New" SIZE=2><P>&#9;HRESULT EnumMembers( 
<P>&#9;&#9;</FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New" SIZE=2> DBGPROP_INFO_FLAGS dwFieldSpec, 
<P>&#9;&#9;</FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New" SIZE=2> UINT nRadix, 
<P>&#9;&#9;</FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New" SIZE=2> REFIID refiid, 
<P>&#9;&#9;</FONT><FONT SIZE=2 COLOR="#808080">[out]</FONT><FONT FACE="Courier New" SIZE=2> IEnumDebugPropertyInfo **ppepi); 
<P> 
<P>&#9;</FONT><FONT SIZE=2 COLOR="#008000">// Get the parent property 
</FONT><FONT FACE="Courier New" SIZE=2><P>&#9;HRESULT GetParent( 
<P>&#9;&#9;</FONT><FONT SIZE=2 COLOR="#808080">[out]</FONT><FONT FACE="Courier New" SIZE=2> IDebugProperty **ppDebugProp); 
<P>}; 
</FONT><FONT SIZE=2 COLOR="#808080"><P> 
<P>[ 
<P>&#9;object, 
<P>&#9;uuid(51973C51-CB0C-11d0-B5C9-00A0244A0E7A), 
<P>&#9;pointer_default(unique) 
<P>]</FONT><FONT FACE="Courier New" SIZE=2> 
</FONT><FONT FACE="Courier New" SIZE=2 COLOR="#000080"><P>interface</FONT><FONT FACE="Courier New" SIZE=2> IEnumDebugPropertyInfo : IUnknown 
<P>{ 
<P>&#9;</FONT><FONT SIZE=2 COLOR="#008000">// Enumerate information for sub-objects 
</FONT><FONT FACE="Courier New" SIZE=2><P>&#9;</FONT><FONT SIZE=2 COLOR="#008000">// get the next celt elements, if possible 
</FONT><FONT FACE="Courier New" SIZE=2><P>&#9;</FONT><FONT SIZE=2 COLOR="#808080">[local]</FONT><FONT FACE="Courier New" SIZE=2> <DIR>
<DIR>

<P>HRESULT Next( 
</FONT><FONT SIZE=2 COLOR="#808080"><P>[in]</FONT><FONT FACE="Courier New" SIZE=2> ULONG celt, </DIR>
</DIR>

<P>&#9;&#9;</FONT><FONT SIZE=2 COLOR="#808080">[out]</FONT><FONT FACE="Courier New" SIZE=2> DebugPropertyInfo *pi, 
<P>&#9;&#9;</FONT><FONT SIZE=2 COLOR="#808080">[out]</FONT><FONT FACE="Courier New" SIZE=2> ULONG *pcEltsfetched 
<P>&#9;&#9;); 
<P> 
<P>&#9;</FONT><FONT SIZE=2 COLOR="#008000">// Skip the next celt slots 
</FONT><FONT FACE="Courier New" SIZE=2><P>&#9;HRESULT Skip( 
<P>&#9;&#9;</FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New" SIZE=2> ULONG celt); 
<P> 
<P>&#9;</FONT><FONT SIZE=2 COLOR="#008000">// Restart from the beginning 
</FONT><FONT FACE="Courier New" SIZE=2><P>&#9;HRESULT Reset(void); 
<P> 
<P>&#9;</FONT><FONT SIZE=2 COLOR="#008000">// Clone this property browser at the current enumeration state 
</FONT><FONT FACE="Courier New" SIZE=2><P>&#9;HRESULT Clone( 
<P>&#9;&#9;</FONT><FONT SIZE=2 COLOR="#808080">[out]</FONT><FONT FACE="Courier New" SIZE=2> IEnumDebugPropertyInfo **ppepi); 
<P> &#9;</FONT><FONT SIZE=2 COLOR="#008000">// Get the number of elements in the enumerator
</FONT><FONT FACE="Courier New" SIZE=2><P>&#9;HRESULT GetCount( 
<P>&#9;&#9;</FONT><FONT SIZE=2 COLOR="#808080">[out]</FONT><FONT FACE="Courier New" SIZE=2> ULONG* pcelt); 
<P>}; 
</FONT><FONT SIZE=2><P>Note:</FONT><FONT FACE="Courier New" SIZE=2> </FONT>The IDebugExtendedProperty is QI’able from an IDebugProperty, and contains more information than the simpler IDebugProperty. 
<FONT FACE="Courier New" SIZE=2><P> 
</FONT><FONT SIZE=2 COLOR="#808080"><P>[ 
<P>&#9;object, 
<P>&#9;uuid(51973C52-CB0C-11d0-B5C9-00A0244A0E7A), 
<P>&#9;pointer_default(unique) 
<P>]</FONT><FONT FACE="Courier New" SIZE=2> 
</FONT><FONT FACE="Courier New" SIZE=2 COLOR="#000080"><P>interface</FONT><FONT FACE="Courier New" SIZE=2> IDebugExtendedProperty : IDebugProperty 
<P>{ 
<P>&#9;</FONT><FONT SIZE=2 COLOR="#008000">// Get Information for this object 
</FONT><FONT FACE="Courier New" SIZE=2><P>&#9;</FONT><FONT SIZE=2 COLOR="#008000">// By setting various EXPROPERTY_INFO_FLAGS and PROPERTY_INFO_FLAGS,  
</FONT><FONT FACE="Courier New" SIZE=2><P>&#9;</FONT><FONT SIZE=2 COLOR="#008000">// any subset of the basic info contained in ExtendedDebugPropertyInfo  
</FONT><FONT FACE="Courier New" SIZE=2><P>&#9;</FONT><FONT SIZE=2 COLOR="#008000">// can be fetched 
</FONT><FONT FACE="Courier New" SIZE=2><P>&#9;HRESULT GetExtendedPropertyInfo( 
<P>&#9;&#9;</FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New" SIZE=2> EX_DBGPROP_INFO_FLAGS dwFieldSpec, 
<P>&#9;&#9;</FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New" SIZE=2> UINT nRadix, 
<P>&#9;&#9;</FONT><FONT SIZE=2 COLOR="#808080">[out]</FONT><FONT FACE="Courier New" SIZE=2> ExtendedDebugPropertyInfo *pExtendedPropertyInfo);
<P> 
<P>&#9;</FONT><FONT SIZE=2 COLOR="#008000">// Get enumerator for props of members 
</FONT><FONT FACE="Courier New" SIZE=2><P>&#9;HRESULT EnumExtendedMembers( 
<P>&#9;&#9;</FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New" SIZE=2> EX_DBGPROP_INFO_FLAGS dwFieldSpec, 
<P>&#9;&#9;</FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New" SIZE=2> UINT nRadix, 
<P>&#9;&#9;</FONT><FONT SIZE=2 COLOR="#808080">[out]</FONT><FONT FACE="Courier New" SIZE=2> IEnumDebugExtendedPropertyInfo **ppeepi); 
<P>}; 
</FONT><FONT SIZE=2 COLOR="#808080"><P> 
<P>[ 
<P>&#9;object, 
<P>&#9;uuid(51973C53-CB0C-11d0-B5C9-00A0244A0E7A), 
<P>&#9;pointer_default(unique) 
<P>]</FONT><FONT FACE="Courier New" SIZE=2> 
</FONT><FONT FACE="Courier New" SIZE=2 COLOR="#000080"><P>interface</FONT><FONT FACE="Courier New" SIZE=2> IEnumDebugExtendedPropertyInfo : IUnknown 
<P>{ 
<P>&#9;</FONT><FONT SIZE=2 COLOR="#008000">// Enumerate information for sub-objects 
</FONT><FONT FACE="Courier New" SIZE=2><P>&#9;</FONT><FONT SIZE=2 COLOR="#008000">// Get the next celt elements, if possible 
</FONT><FONT FACE="Courier New" SIZE=2><P>&#9;HRESULT Next( 
<P>&#9;&#9;</FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New" SIZE=2> ULONG celt, 
<P>&#9;&#9;</FONT><FONT SIZE=2 COLOR="#808080">[out, size_is(celt), length_is(*pceltFetched)]</FONT><FONT FACE="Courier New" SIZE=2> ExtendedDebugPropertyInfo &#9;&#9;&#9;&#9;&#9;*rgExtendedPropertyInfo, 
<P>&#9;&#9;</FONT><FONT SIZE=2 COLOR="#808080">[out]</FONT><FONT FACE="Courier New" SIZE=2> ULONG *pceltFetched); 
<P>&#9;</FONT><FONT SIZE=2 COLOR="#008000">// Skip the next celt slots 
</FONT><FONT FACE="Courier New" SIZE=2><P>&#9;HRESULT Skip( 
<P>&#9;&#9;</FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New" SIZE=2> ULONG celt); 
<P>&#9;</FONT><FONT SIZE=2 COLOR="#008000">// Restart from the beginning 
</FONT><FONT FACE="Courier New" SIZE=2><P>&#9;HRESULT Reset(void); 
<P>&#9;</FONT><FONT SIZE=2 COLOR="#008000">// Clone this property browser at the current enumeration state 
</FONT><FONT FACE="Courier New" SIZE=2><P>&#9;HRESULT Clone( 
<P>&#9;&#9;</FONT><FONT SIZE=2 COLOR="#808080">[out]</FONT><FONT FACE="Courier New" SIZE=2> IEnumDebugExtendedPropertyInfo **pedpe); 
<P> &#9;</FONT><FONT SIZE=2 COLOR="#008000">// Get the number of elements in the enumerator
</FONT><FONT FACE="Courier New" SIZE=2><P>&#9;HRESULT GetCount( 
<P>&#9;&#9;</FONT><FONT SIZE=2 COLOR="#808080">[out]</FONT><FONT FACE="Courier New" SIZE=2> ULONG* pcelt); 
<P>}; 
<P> 
</FONT><FONT SIZE=2 COLOR="#808080"><P>[ 
<P>&#9;object, 
<P>&#9;uuid(51973C54-CB0C-11d0-B5C9-00A0244A0E7A), 
<P>&#9;pointer_default(unique) 
<P>]</FONT><FONT FACE="Courier New" SIZE=2> 
</FONT><FONT FACE="Courier New" SIZE=2 COLOR="#000080"><P>interface</FONT><FONT FACE="Courier New" SIZE=2> IPerPropertyBrowsing2 : IUnknown 
<P>{ 
<P>&#9;</FONT><FONT SIZE=2 COLOR="#008000">// Get a string to display for those types which are inheritly non-viewable 
</FONT><FONT FACE="Courier New" SIZE=2><P>&#9;</FONT><FONT SIZE=2 COLOR="#008000">// Note: The returned string is *not* a legal value for the property, 
</FONT><FONT FACE="Courier New" SIZE=2><P>&#9;</FONT><FONT SIZE=2 COLOR="#008000">// just an indication to the user of what the property is. 
</FONT><FONT FACE="Courier New" SIZE=2><P>&#9;HRESULT GetDisplayString( 
<P>&#9;&#9;</FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New" SIZE=2> DISPID dispid, 
<P>&#9;&#9;</FONT><FONT SIZE=2 COLOR="#808080">[out]</FONT><FONT FACE="Courier New" SIZE=2> BSTR *pBstr); 
<P> 
<P>&#9;</FONT><FONT SIZE=2 COLOR="#008000">// Return the CLSID of the property page which can be used to edit this 
</FONT><FONT FACE="Courier New" SIZE=2><P>&#9;</FONT><FONT SIZE=2 COLOR="#008000">// property. 
</FONT><FONT FACE="Courier New" SIZE=2><P>&#9;HRESULT MapPropertyToPage( 
<P>&#9;&#9;</FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New" SIZE=2> DISPID dispid, 
<P>&#9;&#9;</FONT><FONT SIZE=2 COLOR="#808080">[out]</FONT><FONT FACE="Courier New" SIZE=2> CLSID *pClsidPropPage); 
<P> 
<P>&#9;</FONT><FONT SIZE=2 COLOR="#008000">// These methods allow the caller to fill a listbox with a set of strings 
</FONT><FONT FACE="Courier New" SIZE=2><P>&#9;</FONT><FONT SIZE=2 COLOR="#008000">// which _represent_ potential values for this property. When an item 
</FONT><FONT FACE="Courier New" SIZE=2><P>&#9;</FONT><FONT SIZE=2 COLOR="#008000">// is chosen, the cookie is passed back to the object, so that the object 
</FONT><FONT FACE="Courier New" SIZE=2><P>&#9;</FONT><FONT SIZE=2 COLOR="#008000">// can set itself to the corresponding value. 
</FONT><FONT FACE="Courier New" SIZE=2><P>&#9;HRESULT GetPredefinedStrings( 
<P>&#9;&#9;</FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New" SIZE=2> DISPID dispid, 
<P>&#9;&#9;</FONT><FONT SIZE=2 COLOR="#808080">[out]</FONT><FONT FACE="Courier New" SIZE=2> CALPOLESTR *pCaStrings, 
<P>&#9;&#9;</FONT><FONT SIZE=2 COLOR="#808080">[out]</FONT><FONT FACE="Courier New" SIZE=2> CADWORD *pCaCookies); 
<P> 
<P>&#9;HRESULT SetPredefinedValue( 
<P>&#9;&#9;</FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New" SIZE=2> DISPID dispid, 
<P>&#9;&#9;</FONT><FONT SIZE=2 COLOR="#808080">[in]</FONT><FONT FACE="Courier New" SIZE=2> DWORD dwCookie); 
<P>}; 
<P> 
</FONT><FONT SIZE=2 COLOR="#008000"><P>// the IDebugPropertyEnumType interfaces are really defined for their IIDs, 
<P>// we have no need currently to *implement* any of them, but we might one day 
<P>// These IIDs are passed to EnumMembers for filtering the enumerator. 
</FONT><FONT SIZE=2 COLOR="#808080"><P>[ 
<P>&#9;object, 
<P>&#9;uuid(51973C55-CB0C-11d0-B5C9-00A0244A0E7A), 
<P>&#9;pointer_default(unique) 
<P>]</FONT><FONT FACE="Courier New" SIZE=2> 
</FONT><FONT FACE="Courier New" SIZE=2 COLOR="#000080"><P>interface</FONT><FONT FACE="Courier New" SIZE=2> IDebugPropertyEnumType_All : IUnknown 
<P>{ 
<P>&#9;HRESULT GetName(</FONT><FONT SIZE=2 COLOR="#808080">[out]</FONT><FONT FACE="Courier New" SIZE=2> BSTR *); 
<P>}; 
<P> 
</FONT><FONT SIZE=2 COLOR="#808080"><P>[ 
<P>&#9;object, 
<P>&#9;uuid(51973C56-CB0C-11d0-B5C9-00A0244A0E7A), 
<P>&#9;pointer_default(unique) 
<P>]</FONT><FONT FACE="Courier New" SIZE=2> 
</FONT><FONT FACE="Courier New" SIZE=2 COLOR="#000080"><P>interface</FONT><FONT FACE="Courier New" SIZE=2> IDebugPropertyEnumType_Locals : IDebugPropertyEnumType_All 
<P>{ 
<P>}; 
<P> 
</FONT><FONT SIZE=2 COLOR="#808080"><P>[ 
<P>&#9;object, 
<P>&#9;uuid(51973C57-CB0C-11d0-B5C9-00A0244A0E7A), 
<P>&#9;pointer_default(unique) 
<P>]</FONT><FONT FACE="Courier New" SIZE=2> 
</FONT><FONT FACE="Courier New" SIZE=2 COLOR="#000080"><P>interface</FONT><FONT FACE="Courier New" SIZE=2> IDebugPropertyEnumType_Arguments : IDebugPropertyEnumType_All 
<P>{ 
<P>}; 
<P> 
</FONT><FONT SIZE=2 COLOR="#808080"><P>[ 
<P>&#9;object, 
<P>&#9;uuid(51973C58-CB0C-11d0-B5C9-00A0244A0E7A), 
<P>&#9;pointer_default(unique) 
<P>]</FONT><FONT FACE="Courier New" SIZE=2> 
</FONT><FONT FACE="Courier New" SIZE=2 COLOR="#000080"><P>interface</FONT><FONT FACE="Courier New" SIZE=2> IDebugPropertyEnumType_LocalsPlusArgs : IDebugPropertyEnumType_All 
<P>{ 
<P>}; 
<P> 
</FONT><FONT SIZE=2 COLOR="#808080"><P>[ 
<P>&#9;object, 
<P>&#9;uuid(51973C59-CB0C-11d0-B5C9-00A0244A0E7A), 
<P>&#9;pointer_default(unique) 
<P>]</FONT>
<FONT FACE="Courier New" SIZE=2 COLOR="#000080"><P>interface</FONT>
<FONT FACE="Courier New" SIZE=2>IDebugPropertyEnumType_Registers : IDebugPropertyEnumType_All
<P>{ 
<P>}; 
</FONT>
<!-- CONTENTS_END -->
<!-- START PAGE FOOTER -->
<H6><HR size=1></H6>
<P><A ID=line HREF="#pagetop"><IMG src="../art/arrowup1.gif" WIDTH="17" HEIGHT="16" ALIGN="MIDDLE" BORDER="0" ALT="Up">&nbsp;Top of Page</A>
<BR><A ID=line HREF="http://www.microsoft.com/misc/cpyright.htm" TARGET="_top">&#169; 1997 Microsoft Corporation. All rights reserved. Terms of Use.</A>
<!-- END PAGE FOOTER -->
</BLOCKQUOTE>
</BODY>
</HTML>