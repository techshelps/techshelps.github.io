<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>List View Updates in Internet Explorer</TITLE>

<META NAME=MS-HKWD CONTENT="List View Updates in Internet Explorer">
<META NAME="Keywords" CONTENT="Internet Tools & Technologies, Common controls">
<META NAME="Platform" CONTENT="Windows, Win95, WinNT, Mac">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=iso8859-1">
<META NAME="MS.LOCALE" CONTENT="EN-US">
<META NAME="ROBOTS" CONTENT="all">


<SCRIPT>
//<!--
var g_isIE = false, g_isNav = false, g_iMaj = 0, g_sPlat = "";
// -->
</SCRIPT>
<SCRIPT SRC="../../../code/ver.js"></SCRIPT>


<SCRIPT DEFER SRC="../../../code/common.js"></SCRIPT>
<SCRIPT DEFER>
//<!--
function InitPage()
{
	if (g_isIE && g_iMaj >= 4)	
	{
		SetTOC();
	}
}
//-->
</SCRIPT>

<LINK REL="stylesheet" HREF="/msdn/sdk/inetsdk/help/basicsdkIE4.css" TYPE="text/css">
<!-- STYLE_START -->


<SCRIPT>
//<!--
   var sVR = '../../../'	// Set root for the style sheet
   var sCSS = '<LINK REL="stylesheet" HREF="' + sVR;

   if(g_isIE)
   {
	   if (g_iMaj >= 4) // For MSIE 4.0 or later
	   {
		   sCSS += 'basicSDKIE4';
		   if (g_sPlat == "Win") // Windows only for now
		   {
			   document.createStyleSheet(sVR + 'advSDKIE4.css');
		   }
	   }
	   else // For MSIE 3.0 or earlier
	   {
		   sCSS += 'basicSDKIE3';
	   }
   }
   else if (g_isNav) // For all Nav versions
   {
	   sCSS += 'basicSDKNAV';
   }
   else
   {
	   sCSS += 'basicSDKIE3'; // default to IE3 sheet
   }

   sCSS += (sCSS == '' ? '' : '.css" TYPE="text/css">');

   document.write(sCSS);
//-->
</SCRIPT>
<!-- STYLE_END -->
</HEAD>
<BODY onload="InitPage()" BGCOLOR="#FFFFFF">

<A NAME="pagetop"></A><A NAME="sec_listview_updates"></A>
<!--NAV_LINKS_START-->
<TABLE class=main BORDER=0 CELLSPACING="0" CELLPADDING="0" WIDTH="10%"><TR><TD ROWSPAN="3" VALIGN="TOP" WIDTH="121"><IMG SRC="../../../art/headbar2.gif" WIDTH="121" HEIGHT="82" BORDER=0 ALT="List View Updates in Internet Explorer"></TD><TD ROWSPAN="2" VALIGN="TOP" WIDTH="186"><IMG SRC="../../../art/headbard.gif" WIDTH="186" HEIGHT="44" BORDER=0 ALT="List View Updates in Internet Explorer"></TD><TD VALIGN="TOP" WIDTH="470"><IMG SRC="../../../art/replace1.gif" WIDTH="470" HEIGHT="17" BORDER=0 ALT="*"></TD></TR><TR><TD><PRE><IMG SRC="../../../art/arrowrht.gif" WIDTH="14" HEIGHT="14" ALIGN="MIDDLE" BORDER=0 ALT="*"><object id="hhal_1" type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Item1" value="">
<PARAM name="Item2" value=_win32_Contents>
</object><A STYLE="color:black" ID=TOC HREF=JavaScript:hhal_1.Click()>Contents</A>  <IMG SRC="../../../art/arrowrht.gif" WIDTH="14" HEIGHT="14" ALIGN="MIDDLE" BORDER=0 ALT="*"><object id="hhal_2" type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Item1" value="">
<PARAM name="Item2" value=_win32_Index_1sz1>
</object><A STYLE="color:black" HREF=JavaScript:hhal_2.Click()>Index</A>  <IMG SRC="../../../art/arrowrht.gif" WIDTH="14" HEIGHT="14" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black" HREF="ListView.htm#ch_listview">Topic Contents</A></PRE></TD></TR>
<TR><TD COLSPAN="2"><PRE><IMG SRC="../../../art/arrowlft.gif" WIDTH="17" HEIGHT="15" ALIGN="MIDDLE" BORDER=0 ALT="*"><B>Previous Topic:</B> <A STYLE="color:black" HREF="Using.htm">Using List View Controls</A>
<IMG SRC="../../../art/arrownxt.gif" WIDTH="17" HEIGHT="16" ALIGN="MIDDLE" BORDER=0 ALT="*"><B>Next Topic:</B> <A  STYLE="color:black" HREF="RefList.htm">List View Control Reference</A></PRE></TD></TR>
</TABLE>
<!-- NAV_LINKS_END -->
<BLOCKQUOTE class="body">
<!-- CONTENTS_START -->
<H1>List View Updates in Internet Explorer</H1>
<BR CLEAR=ALL>
<P>This section details the features that were added to the list view control by Microsoft&#174; Internet Explorer. The following updates are described in this section:
<UL><LI>Columns Update
<LI>Extended List View Styles
<LI>List View Working Areas
<LI>Virtual List View
</UL>
<H2><A NAME="Columns_Update">Columns Update</A></H2>
<P>List view controls now support new features for columns in report view. The new features are implemented by using the new members and mask values in the <A HREF="structures/LVCOLUMN.htm#LV_COLUMN">LVCOLUMN</A> structure with standard column manipulation messages. The new features are <I>column images</I> and <I>column ordering</I>.

<P><B>Column Images:</B> List view controls can display images next to column titles. To implement this feature, specify the LVCF_IMAGE value and assign the proper value to the <B>iImage</B> member in the <B>LVCOLUMN</B> structure.

<P><B>Column Ordering:</B> List view controls can set the order in which columns are displayed. To implement this feature, specify the LVCF_ORDER value and assign the proper value to the <B>iOrder</B> member in the <B>LVCOLUMN</B> structure.
<H2><A NAME="Extended_List_View_S">Extended List View Styles</A></H2>
<P>Extended list view styles are not accessed in the same manner as standard window styles. That is, the
<object id="hhal_3" type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Item1" value="">
<PARAM name="Item2" value=_win32_Further_Reading>
</object><A HREF=JavaScript:hhal_3.Click()>SetWindowLong</A> and
<object id="hhal_4" type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Item1" value="">
<PARAM name="Item2" value=_win32_Further_Reading>
</object><A HREF=JavaScript:hhal_4.Click()>GetWindowLong</A> functions are not used to make extended style changes.
<P>Two messages set and retrieve extended style information: <A HREF="messages/LVM_SETEXTENDEDLISTVIEWSTYLE.htm#LVM_SETEXTENDEDLISTV">LVM_SETEXTENDEDLISTVIEWSTYLE</A> and <A HREF="messages/LVM_GETEXTENDEDLISTVIEWSTYLE.htm#LVM_GETEXTENDEDLISTV">LVM_GETEXTENDEDLISTVIEWSTYLE</A>. Each message has a corresponding macro that can be used instead of sending the message explicitly. The macros are <A HREF="macros/ListView_SetExtendedListViewStyle.htm#ListView_SetExtended">ListView_SetExtendedListViewStyle</A>, <A HREF="macros/ListView_SetExtendedListViewStyleEx.htm#ListView_SetExtended">ListView_SetExtendedListViewStyleEx</A>, and <A HREF="macros/ListView_GetExtendedListViewStyle.htm#ListView_GetExtended">ListView_GetExtendedListViewStyle</A>. 
<H2><A NAME="_win32_lv_working_areas"></A><A NAME="lv_working_areas">List View Working Areas</A></H2>
<P>List view controls now support working areas, which are rectangular virtual areas that the list view control uses to arrange its items. A working area is not a window and cannot have a visible border. By default, the list view has no working areas. When no working areas are present, the list view works exactly the same as before working areas were implemented. 

<P>By creating a working area, you can create an empty border on the left, top and/or right of the items or cause a horizontal scroll bar to be displayed when there normally wouldn't be one. 

<P>The number of current working areas can be obtained with the <A HREF="messages/LVM_GETNUMBEROFWORKAREAS.htm#LVM_GETNUMBEROFWORKA">LVM_GETNUMBEROFWORKAREAS</A> message. The working areas are changed with the <A HREF="messages/LVM_SETWORKAREAS.htm#LVM_SETWORKAREAS">LVM_SETWORKAREAS</A> message and can be retrieved with the <A HREF="messages/LVM_GETWORKAREAS.htm#LVM_GETWORKAREAS">LVM_GETWORKAREAS</A> message. Both of these messages take the address of an array of
<object id="hhal_5" type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Item1" value="">
<PARAM name="Item2" value=_win32_Further_Reading>
</object><A HREF=JavaScript:hhal_5.Click()>RECT</A> structures as the lParam and the number of <B>RECT</B> structures as the wParam. The <B>left</B> and <B>top</B> members of these structures specify the coordinates of the upper-left corner (the origin) of the working area, and the <B>right</B> and <B>bottom</B> members specify the lower-right corner of the working area. All of the coordinates are in client coordinates of the list view. The maximum number of working areas allowed is defined by the LV_MAX_WORKAREAS value. 

<P>Changing the working area has no effect on list view controls that have the <A HREF="Styles.htm#LVS_LIST">LVS_LIST</A> or <A HREF="Styles.htm#LVS_REPORT">LVS_REPORT</A> views, but the working areas will be maintained when the view type is changed. With the <A HREF="Styles.htm#LVS_ICON">LVS_ICON</A> and <A HREF="Styles.htm#LVS_SMALLICON">LVS_SMALLICON</A> views, the working area can be modified to change the way the items are displayed. Making the width of the working area (right - left) greater than the client width of the control will cause the items to be wrapped at that width and the horizontal scroll bar to be displayed. Making the width of the working area narrower than the width of the control's client area will cause the items to be wrapped within the working area and not the client area. Setting the <B>left</B> and/or <B>top</B> members to a positive value will cause the items to be displayed starting at the working area, creating an empty space between the edge of the control and the items. An empty space can also be created between the right edge of the control and the items by making the width of the working area less than the client width of the control. 

<P>The following illustration is an example of a list view control that contains four working areas, each in a different quadrant of the client area and with a 25-pixel empty area around them.

<P><IMG SRC="../../../art/lv_wa_lg.gif" WIDTH="511" HEIGHT="410" ALT="List view control that contains four working areas." >

<P>Here is the same list view when set to <A HREF="Styles.htm#LVS_SMALLICON">LVS_SMALLICON</A> view:

<P><IMG SRC="../../../art/lv_wa_sm.gif" WIDTH="476" HEIGHT="249" ALT="Same list view control set to LVS_SMALLICON view." >

<P>When a working area is created, items that lie within the working area become members of it. Similarly, if an item is moved into a working area, it becomes a member of the working area to which it was moved. If an item does not lie within any working area, it automatically becomes a member of the first (index 0) working area. If you want to create an item and have it placed within a specific working area, you will need to create the item and then move it into the desired working area using the <A HREF="messages/LVM_SETITEMPOSITION.htm#LVM_SETITEMPOSITION">LVM_SETITEMPOSITION</A> or <A HREF="messages/LVM_SETITEMPOSITION32.htm#LVM_SETITEMPOSITION32">LVM_SETITEMPOSITION32</A> message. 

<P>To determine which working area an item is a member of, you retrieve the working areas, retrieve the position of the item, and compare its position to the working areas. The following function will return the index of the working area to which the item belongs. If the function fails, it will return -1. If the function succeeds, but the item isn't inside any of the working areas, the function will return 0, because all items that are not inside a working area automatically become a member of working area zero.

<PRE>int GetItemWorkingArea(HWND hwndList, int iItem)
{
UINT     uRects = 0;
int      nReturn = -1;
LPRECT   pRects;
POINT    pt;

if(!ListView_GetItemPosition(hwndList, iItem, &amp;pt))
   return nReturn;

ListView_GetNumberOfWorkAreas(hwndList, &amp;uRects);

if(uRects)
   {
   pRects = (LPRECT)GlobalAlloc(GPTR, sizeof(RECT) * uRects);

   if(pRects)
      {
      UINT  i;

      nReturn = 0;

      ListView_GetWorkAreas(hwndList, uRects, pRects);

      for(i = 0; i &lt; uRects; i++)
         {
         if(PtInRect((pRects + i), pt))
            {
            nReturn = i;
            break;
            }
         }

      GlobalFree((HGLOBAL)pRects);
      }
   }

return nReturn;
}
</PRE>
<P>Multiple working areas can be used for creating different areas within a view to which items can be moved or dropped. With this method, you could create areas in a single view that have different meanings. The user could then categorize the items by placing them in a different area. An example of this would be a view of a file system that has an area for read/write files and another area for read-only files. If a file item were moved into the read-only area, it would automatically become read-only. Moving a file from the read-only area into the read/write area would make the file read/write.

<P>Multiple working areas can intersect, but any items that lie within the intersection will become members of the area with the lower index. So it is best to avoid this situation. When sorting multiple work areas, the items will be sorted compared to the other items within the same working area.

<P>The following example demonstrates how to create one working area that simulates a 25-pixel empty space around the left, top, and right sides of the items.

<PRE>{
#define  EMPTY_SPACE   25

RECT  rcClient;

GetClientRect(hwndListView, &amp;rcClient);

rcClient.left += EMPTY_SPACE;
rcClient.top += EMPTY_SPACE;
rcClient.right -= (EMPTY_SPACE * 2);

SendMessage(hwndListView, LVM_SETWORKAREAS, 1, (LPARAM)&amp;rcClient);
}
</PRE>
<P>The following example demonstrates how to create two working areas in the control that take up about half of the client area and have a 25-pixel border around each rectangle.

<PRE>{
#define  EMPTY_SPACE   25

RECT  rcClient;
RECT  rcWork[2];

GetClientRect(hwndListView, &amp;rcClient);

rcWork[0].left = rcClient.left + EMPTY_SPACE;
rcWork[0].top = rcClient.top + EMPTY_SPACE;
rcWork[0].right = (rcClient.right/2) - EMPTY_SPACE;
rcWork[0].bottom = rcClient.bottom;

rcWork[1].left = (rcClient.right/2) + EMPTY_SPACE;
rcWork[1].top = rcClient.top + EMPTY_SPACE;
rcWork[1].right = rcClient.right - EMPTY_SPACE;
rcWork[1].bottom = rcClient.bottom;

SendMessage(hwndListView, LVM_SETWORKAREAS, 2, (LPARAM)rcWork);
}
</PRE>
<H2><A NAME="Virtual_List_View">Virtual List View</A></H2>
<P>This section contains information about the new list view control style, "virtual" list view (<A HREF="Styles.htm#LVS_OWNERDATA">LVS_OWNERDATA</A>).
<P>This information has been divided into the following areas:
<UL><LI>Virtual list view description
<LI>Creating a virtual list view control
<LI>Compatibility issues: styles and messages
<LI>Handling virtual list view control notification messages
<LI>Cache management
</UL>
<H3><A NAME="vlv_description">Virtual list view description</A></H3>
<P>A virtual list view is a list view control that has the <A HREF="Styles.htm#LVS_OWNERDATA">LVS_OWNERDATA</A> style. The <B>LVS_OWNERDATA</B> style enables the control to handle an almost infinite number of items. Specifically, the control can support an item count up to a DWORD. This is possible because the overhead of managing item data is placed on the owner. This allows the virtual list view control to lend itself for use with large databases of information, where specific methods of accessing data are already in place.

<P>A virtual list view control maintains very little item information itself. Except for the item selection and focus information, all item information must be managed by the owner of the control. All other item information is requested from the owner using <A HREF="notifications/LVN_GETDISPINFO.htm#LVN_GETDISPINFO">LVN_GETDISPINFO</A> notification messages.

<P>Because this type of list control is intended for large data sets, it is recommended that you cache requested item data to improve retrieval performance. The list view provides a cache-hinting mechanism to assist in optimizing the cache. The hint is implemented in the form of an <A HREF="notifications/LVN_ODCACHEHINT.htm#LVN_ODCACHEHINT">LVN_ODCACHEHINT</A> notification message.

 
<H3><A NAME="Creating_a_virtual_l">Creating a virtual list view control</A></H3>
<P>Virtual list view controls are created using the
<object id="hhal_6" type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Item1" value="">
<PARAM name="Item2" value=_win32_Further_Reading>
</object><A HREF=JavaScript:hhal_6.Click()>CreateWindow</A> or
<object id="hhal_7" type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Item1" value="">
<PARAM name="Item2" value=_win32_Further_Reading>
</object><A HREF=JavaScript:hhal_7.Click()>CreateWindowEx</A> functions, specifying the <A HREF="Styles.htm#LVS_OWNERDATA">LVS_OWNERDATA</A> window style as part of the <I>dwStyle</I> function parameter.
<P>The <A HREF="Styles.htm#LVS_OWNERDATA">LVS_OWNERDATA</A> style can be used with most other window styles, excluding the <A HREF="Styles.htm#LVS_SORTASCENDING">LVS_SORTASCENDING</A> or <A HREF="Styles.htm#LVS_SORTDESCENDING">LVS_SORTDESCENDING</A> styles.
<P>All virtual list view controls default to the <A HREF="Styles.htm#LVS_AUTOARRANGE">LVS_AUTOARRANGE</A> style.
<P><B>Note</B>  Dynamically switching to and from the <A HREF="Styles.htm#LVS_OWNERDATA">LVS_OWNERDATA</A> style is not supported.
<H3><A NAME="_win32_vlv_compatibility"></A><A NAME="vlv_compatibility">Compatibility issues: styles, states, and messages</A></H3>
<P><B>List View Control Styles:</B> All four of the list view styles (icon, small icon, list, and report view) support the <A HREF="Styles.htm#LVS_OWNERDATA">LVS_OWNERDATA</A> style. However, this style will not work with the <A HREF="Styles.htm#LVS_SORTASCENDING">LVS_SORTASCENDING</A> or <A HREF="Styles.htm#LVS_SORTDESCENDING">LVS_SORTDESCENDING</A> style.

<P><B>List View Item States:</B> List view controls that have the <A HREF="Styles.htm#LVS_OWNERDATA">LVS_OWNERDATA</A> style do not store any item-specific information. Therefore, the only valid item state flags that can apply to an item are <A HREF="Item_States.htm#LVIS_SELECTED">LVIS_SELECTED</A> and <A HREF="Item_States.htm#LVIS_FOCUSED">LVIS_FOCUSED</A>. No other state information will be stored for an item. One side effect of this is that state images cannot be used with list view controls that have the <B>LVS_OWNERDATA</B> style because the state image index for the item is stored in the item state field. 

<P><B>List View Messages:</B> Most messages used to handle list view controls are fully supported. However, some messages have limitations or are unsupported when the <A HREF="Styles.htm#LVS_OWNERDATA">LVS_OWNERDATA</A> style is used. The following list summarizes the affected messages. Messages not listed here are fully supported.
<P>
<TABLE>
<TR><TD><B>Message
 </B></TD><TD><B>Limitation
</B></TD></TR><TR><TD><A HREF="messages/LVM_ARRANGE.htm#LVM_ARRANGE">LVM_ARRANGE</A>
 </TD><TD>This message does not support the LVA_SNAPTOGRID style.</TD></TR><TR><TD><A HREF="messages/LVM_DELETEALLITEMS.htm#LVM_DELETEALLITEMS">LVM_DELETEALLITEMS</A>
 </TD><TD>This message sets the item count to zero and clears all internal selection variables, but it does not actually delete any items. A notification callback will be made.</TD></TR><TR><TD><A HREF="messages/LVM_DELETEITEM.htm#LVM_DELETEITEM">LVM_DELETEITEM</A>
 </TD><TD>This message is supported for selection integrity only and does not actually delete an item.</TD></TR><TR><TD><A HREF="messages/LVM_GETITEMSTATE.htm#LVM_GETITEMSTATE">LVM_GETITEMSTATE</A>
 </TD><TD>This message returns only focus and selection states (those states stored by the list view control).</TD></TR><TR><TD><A HREF="messages/LVM_GETNEXTITEM.htm#LVM_GETNEXTITEM">LVM_GETNEXTITEM</A>
 </TD><TD>This message does not support the list view search criteria LVNI_CUT, LVNI_HIDDEN, or LVNI_DROPHILITED. All other criteria are supported.</TD></TR><TR><TD><A HREF="messages/LVM_INSERTITEM.htm#LVM_INSERTITEM">LVM_INSERTITEM</A>
 </TD><TD>This message is supported for selection integrity only.</TD></TR><TR><TD><A HREF="messages/LVM_SETITEM.htm#LVM_SETITEM">LVM_SETITEM</A>
 </TD><TD>This message is not supported. To set the item state, use the <A HREF="messages/LVM_SETITEMSTATE.htm#LVM_SETITEMSTATE">LVM_SETITEMSTATE</A> message.</TD></TR><TR><TD><A HREF="messages/LVM_SETITEMCOUNT.htm#LVM_SETITEMCOUNT">LVM_SETITEMCOUNT</A>
 </TD><TD>This message sets the number of items currently in the list. The owner must be prepared to supply data for any item up to the maximum set using this message, as requested by the list control by notification. The message parameters have been updated to support virtual list view controls.</TD></TR><TR><TD><A HREF="messages/LVM_SETITEMPOSITION.htm#LVM_SETITEMPOSITION">LVM_SETITEMPOSITION</A>
 </TD><TD>This message is not supported.</TD></TR><TR><TD><A HREF="messages/LVM_SETITEMSTATE.htm#LVM_SETITEMSTATE">LVM_SETITEMSTATE</A>
 </TD><TD>This message allows only the selection and focus states to be changed for the item.</TD></TR><TR><TD><A HREF="messages/LVM_SETITEMTEXT.htm#LVM_SETITEMTEXT">LVM_SETITEMTEXT</A>
 </TD><TD> This message is not supported.</TD></TR><TR><TD><A HREF="messages/LVM_SORTITEMS.htm#LVM_SORTITEMS">LVM_SORTITEMS</A>
 </TD><TD> This message is not supported.</TD></TR></TABLE>
<H3><A NAME="Handling_virtual_lis">Handling virtual list view control notification messages</A></H3>
<P>List view controls with the <A HREF="Styles.htm#LVS_OWNERDATA">LVS_OWNERDATA</A> style send the same notification messages as other list view controls plus two new ones: <A HREF="notifications/LVN_ODCACHEHINT.htm#LVN_ODCACHEHINT">LVN_ODCACHEHINT</A> and <A HREF="notifications/LVN_ODFINDITEM.htm#LVN_ODFINDITEM">LVN_ODFINDITEM</A>. The following are the most common notifications sent by a list view control with the <B>LVS_OWNERDATA</B> style:
<P>
<TABLE>
<TR><TD>LVN_GETDISPINFO</TD><TD>A virtual list view control maintains very little item information on its own. As a result, it often sends the <A HREF="notifications/LVN_GETDISPINFO.htm#LVN_GETDISPINFO">LVN_GETDISPINFO</A> notification message to request item information. This message is handled in much the same way as callback items in a standard list control. However, because the number of items supported by the control is probably very large, it is recommended that you cache item data to improve performance.

<P>When handling <A HREF="notifications/LVN_GETDISPINFO.htm#LVN_GETDISPINFO">LVN_GETDISPINFO</A>, the owner of the control should first attempt to supply requested item information from the cache (for more information, see <A HREF="Updates.htm#vlv_cache">Cache management</A>). If the requested item is not cached, the owner must be prepared to supply the information by other means.
</TD></TR><TR><TD>LVN_ODCACHEHINT</TD><TD>A virtual list view sends the <A HREF="notifications/LVN_ODCACHEHINT.htm#LVN_ODCACHEHINT">LVN_ODCACHEHINT</A> notification message to assist in optimizing the cache. The notification message provides inclusive index values for a range of items that it recommends be cached. Upon receiving the notification message, the owner must be prepared to load the cache with item information for the requested range so that the information will be readily available when <A HREF="notifications/LVN_GETDISPINFO.htm#LVN_GETDISPINFO">LVN_GETDISPINFO</A> is sent later.
</TD></TR><TR><TD>LVN_ODFINDITEM</TD><TD>The <A HREF="notifications/LVN_ODFINDITEM.htm#LVN_ODFINDITEM">LVN_ODFINDITEM</A> notification message is sent by a virtual list view control when the control needs the owner to find a particular callback item. The notification message is sent when the list view control receives quick key access or when it receives an <A HREF="messages/LVM_FINDITEM.htm#LVM_FINDITEM">LVM_FINDITEM</A> message. Search information is sent in the form of an <A HREF="structures/LVFINDINFO.htm#LV_FINDINFO">LVFINDINFO</A> structure, which is a member of the <A HREF="structures/NMLVFINDITEM.htm#NMLVFINDITEM">NMLVFINDITEM</A> structure.

<P>The owner should be prepared to search for an item that matches the information given by the list view control. The owner should return the index of the item if successful, or -1 if no matching item is found.</TD></TR></TABLE>
<H3><A NAME="_win32_vlv_cache"></A><A NAME="vlv_cache">Cache management</A></H3>
<P><B>General Cache Information:</B> A list view control with the <A HREF="Styles.htm#LVS_OWNERDATA">LVS_OWNERDATA</A> style will produce a large number of <A HREF="notifications/LVN_GETDISPINFO.htm#LVN_GETDISPINFO">LVN_GETDISPINFO</A> notification messages. To improve performance in looking up item information, it is recommended that the owner of the control keep information for certain items in a globally allocated cache. To create the cache using global memory, use the
<object id="hhal_8" type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Item1" value="">
<PARAM name="Item2" value=_win32_Further_Reading>
</object><A HREF=JavaScript:hhal_8.Click()>GlobalAlloc</A> function.

<P>To assist in optimizing the cache, a virtual list view control sends a notification message, <A HREF="notifications/LVN_ODCACHEHINT.htm#LVN_ODCACHEHINT">LVN_ODCACHEHINT</A>, that provides information about the recommended items to include within the cache. LVN_CACHEHINT is sent as a <A HREF="../common/messages/WM_NOTIFY.htm#WM_NOTIFY">WM_NOTIFY</A> message, with the <I>lParam</I> value acting as the address of an <A HREF="structures/NMLVCACHEHINT.htm#NMLVCACHEHINT">NMLVCACHEHINT</A> structure.

<P>The <B>NMLVCACHEHINT</B> structure includes two integer members, <B>iFrom</B> and <B>iTo</B>, that represent the inclusive endpoints of a range of items that will most likely be needed. The owner must be prepared to load the cache with the item information for each of the items within the recommended range.

<P><B>Frequently Accessed Items:</B> The list control will often need item information for the first item (offset 0). The <A HREF="notifications/LVN_ODCACHEHINT.htm#LVN_ODCACHEHINT">LVN_ODCACHEHINT</A> notification message may not always include item 0, but it should always be included in the cache.

<P>The last items in the list will be accessed often. Therefore, the owner may want to keep a second cache that includes the items at the end of the list. The requested range from <A HREF="notifications/LVN_ODCACHEHINT.htm#LVN_ODCACHEHINT">LVN_ODCACHEHINT</A> can be checked against the end cache to make it available automatically instead of reloading the same end range each time. This documentation provides examples of simple application-defined functions that perform cache management and notification message processing. For more information on these examples, see <A HREF="Updates.htm#vlv_samples_overview">Virtual list view sample code</A>.

 
<H3><A NAME="vlv_samples_overview">Virtual list view sample code</A></H3>
<P>This section includes samples of application-defined functions and structures that implement aspects of a virtual list view control and perform cache management.

<TABLE>
<TR><TD><B>Name </B></TD><TD><B>Description
</B></TD></TR><TR><TD><A HREF="Updates.htm#vlv_sample_OnNotify">OnNotify</A> function 
 </TD><TD>Handles virtual list view notification messages.</TD></TR><TR><TD><A HREF="Updates.htm#vlv_sample_PrepCache">PrepCache</A> function
 </TD><TD>Performs basic cache management.</TD></TR><TR><TD><A HREF="Updates.htm#vlv_sample_RetrieveItem">RetrieveItem</A> function
 </TD><TD>Retrieves item information from the cache.</TD></TR><TR><TD><A HREF="Updates.htm#vlv_sample_RndItem">RndItem</A> structure
 </TD><TD>Holds item information for use with a cache.</TD></TR></TABLE>
<P><B>Note</B>  For demonstration purposes, it is assumed that the cache used in this sample is a dynamically allocated array of the user-defined structure <B>RndItem</B>. The list view control in the example is assumed to have three columns&#151;one column for the item label and two columns for subitems.<A NAME="vlv_sample_OnNotify"></A><P><B>Sample Function: OnNotify
</B>
<P>This sample user-defined function handles notification messages commonly sent from a virtual list view control.
<PRE>LRESULT OnNotify( HWND hwnd, NMHDR* pnmhdr )
{
    LRESULT lrt = FALSE;

    switch (pnmhdr-&gt;code){
        case LVN_GETDISPINFO:
            RndItem rndItem;
            NMLVDISPINFO* pLvdi = (LPNMLVDISPINFO) pnmhdr;
            if (-1 == pLvdi-&gt;item.iItem){
                OutputDebugString("LVOWNER: Request for -1 item?\n");
                DebugBreak();
            }

            //  Get information for item at index iItem.
            RetrieveItem( &amp;rndItem, pLvdi-&gt;item.iItem );

            if(pLvdi-&gt;item.mask &amp; LVIF_STATE){
                //  Fill in the state information.
                pLvdi-&gt;item.state |= rndItem.state;
            }

            if(pLvdi-&gt;item.mask &amp; LVIF_IMAGE){
                //  Fill in the image information.
                pLvdi-&gt;item.iImage = rndItem.iIcon;
            }

            if(pLvdi-&gt;item.mask &amp; LVIF_TEXT){
                //  Fill in the text information.
                switch (pLvdi-&gt;item.iSubItem){
                    case 0:
                        //  Copy the main item text.
                        lstrcpy( pLvdi-&gt;item.pszText, rndItem.Title );
                        break;

                    case 1:
                        //  Copy subitem 1 text.
                        lstrcpy( pLvdi-&gt;item.pszText, rndItem.SubText1 );
                        break;

                    case 2:
                        //  Copy subitem 2 text.
                        lstrcpy( pLvdi-&gt;item.pszText, rndItem.SubText2 );
                        break;

                    default:
                        break;
                }
            }
            lrt = FALSE;
            break;

    case LVN_ODCACHEHINT:
        NMLVCACHEHINT* pcachehint = (NMLVCACHEHINT*) pnmhdr;

        // Load the cache with the recommended range.
        PrepCache( pcachehint-&gt;iFrom, pcachehint-&gt;iTo );
        break;

    case LVN_ODFINDITEM:
        LPNMLVFINDITEM pnmfi = (LPNMLVFINDITEM)pnmhdr;

        // Call a user-defined function to find the index according 
        // to LVFINDINFO. Set return value to -1 if no hits are found.
        break;

    default:
        break;

    return( lrt );
}
</PRE>
<A NAME="vlv_sample_PrepCache"></A><P><B>Sample Function: PrepCache
</B>
<P>This sample function accepts the range values for the cache suggested by a virtual list view control. It performs a verification to determine that the requested range is not already cached, and then it allocates the required global memory and fills the cache if necessary.
<PRE>void PrepCache( int iFrom, int iTo )
{
/*  Global Variables 
 *    g_priCache[] is the main cache.
 *    g_iCache is the index of the first item in the main cache.
 *    c_cCache is the count of items in the main cache.
 *
 *    g_priEndCache[] is the cache of items at the end of the list.
 *    g_iEndCache is the index of the first item in the end cache.
 *    g_cEndCache is the count of items in the end cache.
 */

    //  Local Variables
    int i;
    BOOL fOLFrom = FALSE;
    BOOL fOLTo = FALSE;

    //  Check to see if this is the end cache.
    if ((iTo == g_cItems - 1) &amp;&amp; ((iTo - iFrom) &lt; 30))  // 30 entries wide{
        // Check to see if this is a portion of the current end cache.
        if ((g_cEndCache) &amp;&amp;
            (iFrom &gt;= g_iEndCache) &amp;&amp;
            (iFrom &lt; g_iEndCache+g_cEndCache))
            return;  //  if a part of current end cache, no loading is necessary

        //  This is a new end cache; free the old memory.
        if ( g_priEndCache )
            GlobalFree( g_priEndCache );

        //  Set the index and count values for the new end cache; then get the memory.
        g_iEndCache = iFrom;
        g_cEndCache = (iTo - iFrom + 1);
        g_priEndCache = (PRndItem)GlobalAlloc( GPTR, sizeof( RndItem ) * g_cEndCache );

        if (! g_priEndCache);
            //  Out of memory. Perform error handling operations.

        //  Loop to fill the cache with the recommended items.
        for (i=0; i&lt;g_cEndCache; i++);
            //  Call function that accesses item information and
            //  fills a cache element here.
    }

    else{    //  Not a member of the current end cache. Try primary cache instead.

        //  Check to see if iFrom is within the primary cache.
        if ((g_cCache) &amp;&amp;
            (iFrom &gt;= g_iCache) &amp;&amp;
            (iFrom &lt; g_iCache+g_cCache))
            fOLFrom = TRUE;

        //  Check to see if iTo is within the primary cache.
        if ((g_cCache) &amp;&amp;
            (iTo &gt;= g_iCache) &amp;&amp;
            (iTo &lt;= g_iCache+g_cCache))
            fOLTo = TRUE;

        //  If both iFrom and iTo are within current cache, no work is needed.
        if (fOLFrom &amp;&amp; fOLTo)
            return;

        //  Enlarge the cache size rather than make it specific to this hint.
        if (fOLFrom)
            iFrom = g_iCache;
        else if (fOLTo)
            iTo = g_iCache + g_cCache;

        //  A new primary cache is needed; free the old one.
        if ( g_priCache )
            GlobalFree( g_priCache );

        //  Set the index and count values for the new primary cache, and then get the memory.
        g_iCache = iFrom;
        g_cCache = (iTo - iFrom + 1);
        g_priCache = (PRndItem)GlobalAlloc( GPTR, sizeof( RndItem ) * g_cCache );

        if (!g_priEndCache);
            //  Out of memory. Do error handling.

        //  Loop to fill the cache with the recommended items.
        for (i=0; i&lt;g_cEndCache; i++);
            //  Call function that accesses item information and
            //  fills a cache element here.
    }
}
</PRE>
<A NAME="vlv_sample_RetrieveItem"></A><P><B>Sample Function: RetrieveItem
</B>
<P>This sample function accepts two parameters&#151;the address of the user-defined structure <A HREF="Updates.htm#vlv_sample_RndItem">RndItem</A> and an integer value representing the index of the item in the list. It checks the index value to discover if the desired item is cached. If it is, the pointer that was passed to it is set to a location in the cache. If the item is not in the main or end cache, the item information must be located manually.
<PRE>void RetrieveItem( PRndItem prndItem, int index )
{
/*  Global Variables 
 *    g_priCache[] is the main cache.
 *    g_iCache is the index of the first item in the main cache.
 *    c_cCache is the count of items in the main cache.
 *
 *    g_priEndCache[] is the cache of items at the end of the list.
 *    g_iEndCache is the index of the first item in the end cache.
 *    g_cEndCache is the count of items in the end cache.
 */

    //  Check to see if the item is in the main cache.
    if ((index &gt;= g_iCache) &amp;&amp; (index &lt; g_iCache + g_cCache))
        *prndItem = g_priCache[index-g_iCache];

    //  If it is not, check to see if the item is in the end area cache.
    else if ((index &gt;= g_iEndCache)
              &amp;&amp; (index &lt; g_iEndCache + g_cEndCache))
        *prndItem = g_priEndCache[index-g_iEndCache];
    else{
        //  The item is not in either cache;
        //  you should get the item information manually.
    }
}
</PRE>
<A NAME="vlv_sample_RndItem"></A><P><B>Sample Structure: RndItem
</B>
<P>This sample user-defined structure holds information placed in the cache. The structure has the following form: 

<PRE>typedef struct _RndItem
{
    int   iIcon;
    TCHAR Title[SIZE];                // SIZE is a user-defined macro value.
    UINT  state;
    TCHAR SubText1[SIZE];
    TCHAR SubText2[SIZE];

} RndItem, *PRndItem;
</PRE>
<P>
<DL>
<DT><B>iIcon</B>
</DT><DD>Bitmap to be assigned to this item. The value represents offset within a previously created image list.
</DD><DT><B>Title</B>
</DT><DD>Text for the item label.
</DD><DT><B>state</B>
</DT><DD>Item state value.
</DD><DT><B>SubText1</B>
</DT><DD>Text for the label of the first subitem.
</DD><DT><B>SubText2</B>
</DT><DD>Text for the label of the second subitem.
</DD></DL>

<!-- CONTENTS_END -->
<!-- START PAGE FOOTER -->
<H6><HR size=1></H6>
<P><A ID=line HREF="#pagetop"><IMG src="../../../art/arrowup1.gif" WIDTH="17" HEIGHT="16" ALIGN="MIDDLE" BORDER="0" ALT="Up">&nbsp;Top of Page</A>
<BR><A ID=line HREF="http://www.microsoft.com/misc/cpyright.htm" TARGET="_top">&#169; 1997 Microsoft Corporation. All rights reserved. Terms of Use.</A>
<!-- END PAGE FOOTER -->
</BLOCKQUOTE>
</BODY>
</HTML>