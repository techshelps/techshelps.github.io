<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>File Parsers</TITLE>

<META NAME=MS-HKWD CONTENT="File Parsers">
<META NAME="Keywords" CONTENT="Internet Tools & Technologies, Windows Shell API">
<META NAME="Platform" CONTENT="Windows, Win95, WinNT, Mac">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=iso8859-1">
<META NAME="MS.LOCALE" CONTENT="EN-US">
<META NAME="ROBOTS" CONTENT="all">

<SCRIPT>
//<!--
var g_isIE = false, g_isNav = false, g_iMaj = 0, g_sPlat = "";
// -->
</SCRIPT>
<SCRIPT SRC="../../../code/ver.js"></SCRIPT>


<SCRIPT DEFER SRC="../../../code/common.js"></SCRIPT>
<SCRIPT DEFER>
//<!--
function InitPage()
{
	if (g_isIE && g_iMaj >= 4)	
	{
		SetTOC();
	}
}
//-->
</SCRIPT>

<LINK REL="stylesheet" HREF="/msdn/sdk/inetsdk/help/basicsdkIE4.css" TYPE="text/css">
<!-- STYLE_START -->


<SCRIPT>
//<!--
   var sVR = '../../../'	// Set root for the style sheet
   var sCSS = '<LINK REL="stylesheet" HREF="' + sVR;

   if(g_isIE)
   {
	   if (g_iMaj >= 4) // For MSIE 4.0 or later
	   {
		   sCSS += 'basicSDKIE4';
		   if (g_sPlat == "Win") // Windows only for now
		   {
			   document.createStyleSheet(sVR + 'advSDKIE4.css');
		   }
	   }
	   else // For MSIE 3.0 or earlier
	   {
		   sCSS += 'basicSDKIE3';
	   }
   }
   else if (g_isNav) // For all Nav versions
   {
	   sCSS += 'basicSDKNAV';
   }
   else
   {
	   sCSS += 'basicSDKIE3'; // default to IE3 sheet
   }

   sCSS += (sCSS == '' ? '' : '.css" TYPE="text/css">');

   document.write(sCSS);
//-->
</SCRIPT>
<!-- STYLE_END -->
</HEAD>
<BODY onload="InitPage()" BGCOLOR="#FFFFFF">

<A NAME="pagetop"></A><A NAME="ch_fileparser"></A>
<!-- NAV_LINKS_START -->
<TABLE class=main BORDER=0 CELLSPACING="0" CELLPADDING="0" WIDTH="10%"><TR><TD ROWSPAN="3" VALIGN="TOP" WIDTH="121"><IMG SRC="../../../art/headbar2.gif" WIDTH="121" HEIGHT="82" BORDER=0 ALT="File Parsers"></TD><TD ROWSPAN="2" VALIGN="TOP" WIDTH="186"><IMG SRC="../../../art/headbard.gif" WIDTH="186" HEIGHT="44" BORDER=0 ALT="File Parsers"></TD><TD VALIGN="TOP" WIDTH="470"><IMG SRC="../../../art/replace1.gif" WIDTH="470" HEIGHT="17" BORDER=0 ALT="*"></TD></TR>
<TR><TD><PRE><IMG SRC="../../../art/arrowrht.gif" WIDTH="14" HEIGHT="14" ALIGN="MIDDLE" BORDER=0 ALT="*"><object id="hhal_1" type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Item1" value="">
<PARAM name="Item2" value=_win32_Contents>
</object><A STYLE="color:black" ID=TOC HREF=JavaScript:hhal_1.Click()>Contents</A>  <IMG SRC="../../../art/arrowrht.gif" WIDTH="14" HEIGHT="14" ALIGN="MIDDLE" BORDER=0 ALT="*"><object id="hhal_2" type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Item1" value="">
<PARAM name="Item2" value=_win32_Index_1sz1>
</object><A STYLE="color:black" HREF=JavaScript:hhal_2.Click()>Index</A>  <IMG SRC="../../../art/arrowrht.gif" WIDTH="14" HEIGHT="14" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black" HREF="../Shell.htm#book_shell">Topic Contents</A></PRE></TD></TR>
<TR><TD COLSPAN="2"><PRE><IMG SRC="../../../art/arrowlft.gif" WIDTH="17" HEIGHT="15" ALIGN="MIDDLE" BORDER=0 ALT="*"><B>Previous Topic:</B> <A STYLE="color:black" HREF="../FileMan.htm">File Manager Extensions</A>
<IMG SRC="../../../art/arrownxt.gif" WIDTH="17" HEIGHT="16" ALIGN="MIDDLE" BORDER=0 ALT="*"><B>Next Topic:</B> <A  STYLE="color:black" HREF="Reference.htm">File Parser Constants</A></PRE></TD></TR>
</TABLE>
<!-- NAV_LINKS_END -->
<BLOCKQUOTE class="body">
<!-- CONTENTS_START -->
<H1>File Parsers</H1>
<BR CLEAR=ALL>
<P>A <I>file parser</I> is a dynamic-link library (DLL) that provides the low-level parsing needed to generate a quick view for a file of a given type.
<P><A CLASS=tctop HREF="FileParser.htm#About_File_Parsers"><IMG SRC="../../../art/arrowy.gif" WIDTH="6" HEIGHT="11" BORDER=0 ALT="arrowy.gif">About File Parsers</A><BR>
<P><A CLASS=tctop HREF="Reference.htm#sec_fileparser_constants"><IMG SRC="../../../art/arrowy.gif" WIDTH="6" HEIGHT="11" BORDER=0 ALT="arrowy.gif">File Parser Constants</A><BR>
<!--*************************************************************--><H2><A NAME="About_File_Parsers">About File Parsers</A></H2>
<P>File parsers work in conjunction with the file viewing components of the Microsoft&#174; Windows&#174; operating system. These components are the shell, the Quick View program (Quikview.exe), and display engines. When the user wants to generate a quick view for a file, the shell responds by calling the Quick View program. The program manages the process, directing one of the display engines to draw the Quick View window and fill it with a view of the file. The display engine uses a file parser to determine the contents of the file and to draw those contents correctly.

<P>You can extend the file viewing capabilities of Windows by supplying additional file parsers. Each file parser is responsible for a specific type or class of file and is associated with one of the display engines. For example, you can allow a quick view to be generated for a .doc file by creating a file parser to support that file type and associating the file parser with the word processor display engine. 

<P>This overview describes the file parser interface and explains how to write file parsers for word processing documents, spreadsheets, databases, bitmapped graphics, and vector graphics. For information about extending the file viewing capabilities in other ways, see <A HREF="../FileView.htm#ch_fileview">File Viewers</A>.

<P>The file viewing technology used in the Quick View feature system has been jointly developed by Microsoft Corporation and Systems Compatibility Corporation. 

<H3><A NAME="Adding_or_Removing_F">Adding or Removing File Parsers</A></H3>
<P>For performance reasons, the file viewer builds a cache of the file parsers in the system the first time the Quick View feature is used. This cache is stored in the registry. If a file parser is added or removed, this cache must be rebuilt. To make the system rebuild the cache, set the "verify data" value under the following key to something other than zero: 
<PRE>\\HKEY_LOCAL_MACHINE\SOFTWARE\SCC\Viewer Technology\MS1 
 
</PRE>
<H3><A NAME="Implementing_a_File_">Implementing a File Parser</A></H3>
<P>Every file parser must implement the following functions from the Microsoft Platform SDK: 
<TABLE>
<TR><TD><A HREF="../functions/VwStreamCloseFunc.htm#VwStreamCloseFunc">VwStreamCloseFunc</A> </TD><TD><A HREF="../functions/VwStreamSectionFunc.htm#VwStreamSectionFunc">VwStreamSectionFunc</A></TD></TR>
<TR><TD><A HREF="../functions/VwStreamOpenFunc.htm#VwStreamOpenFunc">VwStreamOpenFunc</A> </TD><TD><A HREF="../functions/VwStreamSeekFunc.htm#VwStreamSeekFunc">VwStreamSeekFunc</A></TD></TR>
<TR><TD><A HREF="../functions/VwStreamReadFunc.htm#VwStreamReadFunc">VwStreamReadFunc</A> </TD><TD><A HREF="../functions/VwStreamTellFunc.htm#VwStreamTellFunc">VwStreamTellFunc</A></TD></TR>
<TR><TD><A HREF="../functions/VwStreamReadRecordFunc.htm#VwStreamReadRecordFu">VwStreamReadRecordFunc</A> </TD><TD></TD></TR>
</TABLE>
<P>The display engine calls these functions to display a file of the type supported by the file parser. 

<P>The display engine starts the file viewing process by calling <A HREF="../functions/VwStreamOpenFunc.htm#VwStreamOpenFunc">VwStreamOpenFunc</A>, sending the name of a file to the file parser. The first responsibility of any parser is to verify that the given file has the proper format and can be processed. If the file is viewable, the file parser returns a value to the display engine acknowledging the request. 

<P>Once the parser completes verification, the display engine calls <A HREF="../functions/VwStreamSectionFunc.htm#VwStreamSectionFunc">VwStreamSectionFunc</A>, directing the file parser to identify the type and name of the first section of the file to be processed. A section is a portion of the file in which all the data is of one type; it forms a logical breaking point for the processing of the file. The standard section types are word processing, spreadsheet, database, bitmapped graphics, and vector graphics. A file can consist of a single section, multiple sections of the same type, or a combination of sections of different types. The actions that the display engine takes to display the file depend on the type of section currently being processed. The file parser must call the <A HREF="../functions/SOPutSectionType.htm#SOPutSectionType">SOPutSectionType</A> and <A HREF="../functions/SOPutSectionName.htm#SOPutSectionName">SOPutSectionName</A> functions to output the section type and to set the section name. 

<P>Before the file parser returns from <A HREF="../functions/VwStreamSectionFunc.htm#VwStreamSectionFunc">VwStreamSectionFunc</A>, it may need to provide the display engine with additional information. If the portion to be processed is a word processing section, the file parser must set entries for the font table by using the <A HREF="../functions/SOPutFontTableEntry.htm#SOPutFontTableEntry">SOPutFontTableEntry</A> function. If it is a spreadsheet section, the file parser must set the column width by calling the <A HREF="../functions/SOPutColumnInfo.htm#SOPutColumnInfo">SOPutColumnInfo</A> function. If it is a database section, the file parser must set the field format by calling the <A HREF="../functions/SOPutFieldInfo.htm#SOPutFieldInfo">SOPutFieldInfo</A> function. The file parser can also set the date base used by spreadsheets and databases to calculate dates by using the <A HREF="../functions/SOSetDateBase.htm#SOSetDateBase">SOSetDateBase</A> function. In addition, the file parser can set header entries by calling the <A HREF="../functions/SOPutHdrEntry.htm#SOPutHdrEntry">SOPutHdrEntry</A> function. 

<P>After the section type and general information are set, the display engine requests data for the section by calling <A HREF="../functions/VwStreamReadFunc.htm#VwStreamReadFunc">VwStreamReadFunc</A>. The file parser fulfills this request by calling the stream output functions. These functions pass the data to the display engine in a form that is easiest for the engine to display, copy to the clipboard, or write to disk. 

<P>The stream output functions used by the file parser depend on the section type. For word processing sections, the file parser uses the <A HREF="../functions/SOPutParaSpacing.htm#SOPutParaSpacing">SOPutParaSpacing</A>, <A HREF="../functions/SOPutCharAttr.htm#SOPutCharAttr">SOPutCharAttr</A>, and <A HREF="../functions/SOPutChar.htm#SOPutChar">SOPutChar</A> functions to set the spacing for paragraphs, set the style attributes for characters, and output characters, respectively. For spreadsheet sections, the parser uses the <A HREF="../functions/SOPutDataCell.htm#SOPutDataCell">SOPutDataCell</A> and <A HREF="../functions/SOPutTextCell.htm#SOPutTextCell">SOPutTextCell</A> functions to output the content (data or text) of cells. For database sections, it uses the <A HREF="../functions/SOPutField.htm#SOPutField">SOPutField</A> and <A HREF="../functions/SOPutVarField.htm#SOPutVarField">SOPutVarField</A> functions to output the data of fields. The parser uses the <A HREF="../functions/SOPutBitmapHeader.htm#SOPutBitmapHeader">SOPutBitmapHeader</A> and <A HREF="../functions/SOPutScanLineData.htm#SOPutScanLineData">SOPutScanLineData</A> functions for bitmapped graphics sections and the <A HREF="../functions/SOVectorAttr.htm#SOVectorAttr">SOVectorAttr</A> and <A HREF="../functions/SOVectorObject.htm#SOVectorObject">SOVectorObject</A> functions for vector graphics sections.

<P>To set a break for a paragraph, cell, or field, the file parser calls the <A HREF="../functions/SOPutBreak.htm#SOPutBreak">SOPutBreak</A> function with an appropriate value, either SO_PARABREAK, SO_CELLBREAK, or SO_RECORDBREAK. The return value from <B>SOPutBreak</B> tells the file parser how to proceed. If it is the SO_STOP value, the file parser stops all processing and returns from <A HREF="../functions/VwStreamReadFunc.htm#VwStreamReadFunc">VwStreamReadFunc</A>. 

<P>The file parser continues to output data until it reaches the end of the section. The parser must end a section by calling <A HREF="../functions/SOPutBreak.htm#SOPutBreak">SOPutBreak</A> with the SO_SECTIONBREAK value. If this is the last section in the file, the file parser indicates that the end of the file has been reached by using the SO_EOFBREAK value instead.

<P>If there are subsequent sections in the file, the display engine calls <A HREF="../functions/VwStreamSectionFunc.htm#VwStreamSectionFunc">VwStreamSectionFunc</A> again to request the type and name of the next section, and processing continues just as it did for the first section. 

<P>After the last section, the display engine calls <A HREF="../functions/VwStreamCloseFunc.htm#VwStreamCloseFunc">VwStreamCloseFunc</A> to indicate that processing is complete and that no further requests for data will be made. The file parser must close the file and any related files it has opened and clean up resources, such as freeing memory.

<P>If an error occurs while a file is parsed, the file parser should call the <A HREF="../functions/SOBailOut.htm#SOBailOut">SOBailOut</A> function to notify the display engine of the error condition. The parser must immediately return from <A HREF="../functions/VwStreamReadFunc.htm#VwStreamReadFunc">VwStreamReadFunc</A> after calling the <B>SOBailOut</B> function. 

<H3><A NAME="Restartable_Parsing">Restartable Parsing</A></H3>
<P>You must design the file parser so that parsing can be efficiently restarted at discrete locations within a file. The goal is to give the display engine the best performance without it having to store a completely converted copy of a file. 

<P>To facilitate restartable parsing, the display engine incorporates a module, which is called the <I>chunker</I>, that essentially caches data from the parser. The chunker does not cache all the data&#151;only the data that the display engine has most recently requested. However, it does cache state data for restartable locations in the file. This means that as long as the parser maintains its own internal data in a way that can be efficiently restarted, the display engine and the parser can work cooperatively to locate and restart processing at the cached locations. 

<P>The file parser is responsible for determining the best locations for restarting parsing. It does this by calling the <A HREF="../functions/SOPutBreak.htm#SOPutBreak">SOPutBreak</A> function. The chunker assumes that each break is a restartable location in the file. Before calling <B>SOPutBreak</B>, however, the file parser must save up-to-date data about the location so that it can quickly retrieve and begin processing the data at the location if requested to do so. 

<P>The display engine uses the <A HREF="../functions/VwStreamSeekFunc.htm#VwStreamSeekFunc">VwStreamSeekFunc</A> and <A HREF="../functions/VwStreamTellFunc.htm#VwStreamTellFunc">VwStreamTellFunc</A> functions to direct the file parser to a restartable location.

<H3><A NAME="Word_Processing_Sect">Word Processing Sections</A></H3>
<P>Word processing sections contain text organized as paragraphs, tables, and subdocuments. Of these, paragraphs and tables can have attributes, such as indentation, tab stops, and spacing. The text in word processing sections consists of characters having attributes, such as font, height, and weight. Word processing sections can also include embedded objects, allowing bitmapped art and other graphics to be included with the text.

<P>A file parser processes the text associated with a word processing section when the display engine calls the <A HREF="../functions/VwStreamReadFunc.htm#VwStreamReadFunc">VwStreamReadFunc</A> function. The file parser must set all attributes before calling the <A HREF="../functions/SOPutChar.htm#SOPutChar">SOPutChar</A> function or other text output functions. The file parser must never automatically set an attribute as a default. If the state of a current attribute is not known, the file parser must not set it.

<H4><A NAME="Paragraph_attributes">Paragraph attributes</A></H4>
<P>The file parser sets the attributes of a paragraph before outputting characters for the paragraph. The attributes are the alignment, indentation, spacing, tab stops, and margins. 

<P>The file parser sets the alignment to be left, right, centered, or justified by using the <A HREF="../functions/SOPutParaAlign.htm#SOPutParaAlign">SOPutParaAlign</A> function and sets the left, right, and first line indents by using the <A HREF="../functions/SOPutParaIndents.htm#SOPutParaIndents">SOPutParaIndents</A> function. The file parser sets the spacing before and after the paragraph and between lines of the paragraph by using the <A HREF="../functions/SOPutParaSpacing.htm#SOPutParaSpacing">SOPutParaSpacing</A> function. The file parser sets tab stops by using the <A HREF="../functions/SOPutTabStop.htm#SOPutTabStop">SOPutTabStop</A> function, calling the function once for each tab stop. To mark the start and end of a tab stop definition, the file parser calls the <A HREF="../functions/SOStartTabStops.htm#SOStartTabStops">SOStartTabStops</A> and <A HREF="../functions/SOEndTabStops.htm#SOEndTabStops">SOEndTabStops</A> functions. The file parser sets page margins for the paragraph by using the <A HREF="../functions/SOPutParaMargins.htm#SOPutParaMargins">SOPutParaMargins</A> function. 

<H4><A NAME="Tables">Tables</A></H4>
<P>The file parser can add tables to a word processing section's text by using the <A HREF="../functions/SOBeginTable.htm#SOBeginTable">SOBeginTable</A> and <A HREF="../functions/SOEndTable.htm#SOEndTable">SOEndTable</A> functions to mark the start and end of the table definition. It can format the rows and cells in tables by using the <A HREF="../functions/SOPutTableRowFormat.htm#SOPutTableRowFormat">SOPutTableRowFormat</A> and <A HREF="../functions/SOPutTableCellInfo.htm#SOPutTableCellInfo">SOPutTableCellInfo</A> functions. The file parser uses the character and paragraph functions to output the text for each cell and set the attributes. 

<P>The file parser marks the end of each cell and each row by using the <A HREF="../functions/SOPutBreak.htm#SOPutBreak">SOPutBreak</A> function with the SO_TABLECELLBREAK and SO_TABLEROWBREAK values. A file parser must insert a cell break after each cell and a row break at the end of each row. If a file parser inserts a row break before inserting as many cells as were defined for the row, the remaining cells are assumed to be empty. Empty cells may be inserted in the middle of a row by inserting consecutive cell breaks. 

<P>Row and cell formats must be defined before the last cell of a row. After defining the row properties by using the <A HREF="../functions/SOPutTableRowFormat.htm#SOPutTableRowFormat">SOPutTableRowFormat</A> function, the parser must call the <A HREF="../functions/SOPutTableCellInfo.htm#SOPutTableCellInfo">SOPutTableCellInfo</A> function for each cell in the row. After a row is defined, the row properties are assumed to apply to subsequent rows until new row properties are specified. Thus, a filter can define an entire table by specifying the row and cell properties once and then using the appropriate row and cell breaks.

<P>You can add borders to cells by setting the <B>pLeftBorder</B>, <B>pRightBorder</B>, <B>pTopBorder</B>, and <B>pBottomBorder</B> members of the <A HREF="../structures/SOTABLECELLINFO.htm#SOTABLECELLINFO">SOTABLECELLINFO</A> structure to appropriate values when setting the cell format.

<P>You can add tabs to cells by using the special character, the SO_CHCELLTAB value. This character is defined for cells that are merged with their neighbors and acts as a tab that moves the current text position to the location of the next boundary that would have existed if the cells had not been merged.

<H4><A NAME="Subdocuments">Subdocuments</A></H4>
<P>The file parser can add subdocuments to the document. Subdocuments consist of headers, footers, footnotes, and comments. Subdocuments are added to the document using the <A HREF="../functions/SOPutBreak.htm#SOPutBreak">SOPutBreak</A> function. To start a subdocument, the file parser calls <B>SOPutBreak</B> with the SO_SUBDOCBEGINBREAK value. To end the subdocument, the file parser calls <B>SOPutBreak</B> with the SO_SUBDOCENDBREAK value. 

<P>After ending a subdocument, the file parser must restore character and paragraph attributes to what they were before the subdocument was started. The file parser can use the <A HREF="../functions/SUUserPushData.htm#SUUserPushData">SUUserPushData</A> and <A HREF="../functions/SUUserPopData.htm#SUUserPopData">SUUserPopData</A> functions to save and restore nested subdocument information. A parser can nest subdocuments without limit. The following example shows when to save and restore this information.
<PRE>This is a &lt;Bold On&gt; test

    // At this point, the filter should save its internal 
    // information to reflect the fact that bold is on.
    SOPutBreak(SO_SUBDOCBEGINBREAK);
    SOPutSubdocInfo(...);
&lt;Subdoc Begin&gt; This is a &lt;Bold Off&gt;subdocument&lt;Subdoc End&gt;

    // At this point, the filter should restore its internal 
    // information to reflect the fact that bold is on.
    SOPutBreak(SO_SUBDOCENDBREAK);

document &lt;Bold Off&gt;of mine. 
 
</PRE>
<P>File parsers are not expected to correctly exit a subdocument when run from a regular paragraph break (with the SO_PARABREAK value) inside the subdocument. The display engine lets the file parser run to the subdocument's end break (that is, the SO_SUBDOCENDBREAK value) and returns the SO_STOP value. 

<H4><A NAME="Characters_and_chara">Characters and character attributes</A></H4>
<P>The file parser outputs characters by using the <A HREF="../functions/SOPutChar.htm#SOPutChar">SOPutChar</A> function. It can specify extra properties for a character, such as grouped or hidden, when outputting by using the <A HREF="../functions/SOPutCharX.htm#SOPutCharX">SOPutCharX</A> function. The file parser outputs special characters, such as tabs, hard line breaks, hard page breaks, and hyphens by using the <A HREF="../functions/SOPutSpecialCharX.htm#SOPutSpecialCharX">SOPutSpecialCharX</A> function.

<P>Before outputting characters, the file parser sets character attributes by using the <A HREF="../functions/SOPutCharAttr.htm#SOPutCharAttr">SOPutCharAttr</A>, <A HREF="../functions/SOPutCharFontById.htm#SOPutCharFontById">SOPutCharFontById</A>, <A HREF="../functions/SOPutCharFontByName.htm#SOPutCharFontByName">SOPutCharFontByName</A>, and <A HREF="../functions/SOPutCharHeight.htm#SOPutCharHeight">SOPutCharHeight</A> functions. These functions set the style, font, height, and width of the character. The <B>SOPutCharAttr</B> function lets the file parser set style attributes, such as italic, underline, and strikeout. The <B>SOPutCharFontById</B> and <B>SOPutCharFontByName</B> functions can specify any font that the parser added to the font table during processing of the <A HREF="../functions/VwStreamSectionFunc.htm#VwStreamSectionFunc">VwStreamSectionFunc</A> function. The <B>SOPutCharHeight</B> function sets the character height, in half points.

<H4><A NAME="Embedded_graphics_ob">Embedded graphics objects</A></H4>
<P>The file parser can embed graphics objects in the text of a paragraph section by using the <A HREF="../functions/SOPutEmbeddedObject.htm#SOPutEmbeddedObject">SOPutEmbeddedObject</A> function. The function inserts the embedded graphics object at the current location in the document. 

<H3><A NAME="Spreadsheet_Sections">Spreadsheet Sections</A></H3>
<P>The file parser outputs content (data or text) for cells in a spreadsheet by using the <A HREF="../functions/SOPutDataCell.htm#SOPutDataCell">SOPutDataCell</A> and <A HREF="../functions/SOPutTextCell.htm#SOPutTextCell">SOPutTextCell</A> functions. Before outputting cell data, the file parser must get the range of columns to be output by using the <A HREF="../functions/SOGetInfo.htm#SOGetInfo">SOGetInfo</A> function with the SOINFO_COLUMNRANGE value. When <B>SOGetInfo</B> returns, the low-order word of its <I>pInfo</I> parameter identifies the first column of data to generate output for, and the high-order word identifies the last column. The file parser should only call <B>SOPutDataCell</B> or <B>SOPutTextCell</B> for cells within the range indicated by a call to <B>SOGetInfo</B>. When there is no more data within a range of columns, the file parser must call the <A HREF="../functions/SOPutBreak.htm#SOPutBreak">SOPutBreak</A> function with either the SO_EOFBREAK or SO_SECTIONBREAK value, whichever applies. This must be done for each range of columns in the document.

<P>For example, if the first column is 10 and the last column is 19, the filter reads the file from its current position, but it only calls <A HREF="../functions/SOPutDataCell.htm#SOPutDataCell">SOPutDataCell</A> or <A HREF="../functions/SOPutTextCell.htm#SOPutTextCell">SOPutTextCell</A> for cells that belong in columns 10 through 19, inclusively. (Column numbers are zero-based.) The parser skips over cells that belong in columns outside of this range. The filter must produce cells for all columns in the range, filling in with empty cells if necessary. As before, the filter continues until <A HREF="../functions/SOPutBreak.htm#SOPutBreak">SOPutBreak</A> returns the SO_STOP value. 

<P>In general, the file parser should carry out the following steps:
<OL><LI>Determine the desired range of columns.
<LI>Determine the next cell available from the input file. 
<LI>Determine if the cell is in the given range of columns. If not, repeat step 2. 
<LI>If the cell is not empty, call <A HREF="../functions/SOPutDataCell.htm#SOPutDataCell">SOPutDataCell</A> or <A HREF="../functions/SOPutTextCell.htm#SOPutTextCell">SOPutTextCell</A> with the current data. Otherwise, call <B>SOPutDataCell</B> for a cell of the SO_CELLEMPTY type.
<LI>Update local variables, such as row and column numbers.
<LI>Call <A HREF="../functions/SOPutBreak.htm#SOPutBreak">SOPutBreak</A> with the SO_CELLBREAK value. 
<LI>If <A HREF="../functions/SOPutBreak.htm#SOPutBreak">SOPutBreak</A> returns the SO_STOP value, return from the <A HREF="../functions/VwStreamReadFunc.htm#VwStreamReadFunc">VwStreamReadFunc</A> function.
<LI>If at the beginning of the next section, call <A HREF="../functions/SOPutBreak.htm#SOPutBreak">SOPutBreak</A> with the SO_SECTIONBREAK value and return.
<LI>If at the end of the file, call <A HREF="../functions/SOPutBreak.htm#SOPutBreak">SOPutBreak</A> with the SO_EOFBREAK value and return.
<LI>Repeat steps 2 through 10.
</OL>
<P>When the chunker saves local data for various seek positions in a document, it does so within <A HREF="../functions/SOPutBreak.htm#SOPutBreak">SOPutBreak</A> when the break is of the SO_CELLBREAK type. So when a file parser has its local data restored for a random seek position, the data will reflect the state of the file parser during its call to <B>SOPutBreak</B> for the last cell of the previous chunk in the current range of cells. Any tracking done by the parser, such as the current row number, should be updated before <B>SOPutBreak</B> is called for each cell.

<P>Every horizontal range of columns, specified by the <I>dwExtraData</I> parameter in each call to your <A HREF="../functions/VwStreamReadFunc.htm#VwStreamReadFunc">VwStreamReadFunc</A> function, must eventually be terminated by a call to <A HREF="../functions/SOPutBreak.htm#SOPutBreak">SOPutBreak</A> with the SO_EOFBREAK or SO_SECTIONBREAK value, whichever is applicable. The type of break depends on the input file. A file parser must not put a section break at the end of the file, and an end-of-file (EOF) break, of course, cannot occur anywhere but at the actual end of the file.

<P>For example, if the input document contains a single spreadsheet that is 30 columns wide, the display engine can call the parser with three different ranges of columns: 0 to 11, 12 to 23, and 24 to 29. The file parser calls <A HREF="../functions/SOPutBreak.htm#SOPutBreak">SOPutBreak</A> with an EOF break three times, once for each time it reaches the end of the file while processing a given range.

<P>When calling <A HREF="../functions/SOPutBreak.htm#SOPutBreak">SOPutBreak</A> with a section break, the file parser must be sure that the seek position is at the beginning of the next section. This ensures that the file position is where the file parser needs to be when <A HREF="../functions/VwStreamSectionFunc.htm#VwStreamSectionFunc">VwStreamSectionFunc</A> is next called. Any one of the calls to <B>SOPutBreak</B> for a section break may be the one that sets the seek position for the top of the next section.

<H3><A NAME="Database_Sections">Database Sections</A></H3>
<P>The file parser outputs data and text for a database by using the <A HREF="../functions/SOPutField.htm#SOPutField">SOPutField</A>, <A HREF="../functions/SOPutMoreVarField.htm#SOPutMoreVarField">SOPutMoreVarField</A>, and <A HREF="../functions/SOPutVarField.htm#SOPutVarField">SOPutVarField</A> functions. The parser uses the <B>SOPutField</B> function for fields of a fixed size. The other functions are used for variable length fields. The parser sets field information by using the <A HREF="../functions/SOPutFieldInfo.htm#SOPutFieldInfo">SOPutFieldInfo</A> function while processing the <A HREF="../functions/VwStreamSectionFunc.htm#VwStreamSectionFunc">VwStreamSectionFunc</A> function.

<H3><A NAME="Bitmapped_Sections">Bitmapped Sections</A></H3>
<P>The file parser starts a bitmapped section by calling the <A HREF="../functions/SOPutSectionType.htm#SOPutSectionType">SOPutSectionType</A> function with the SO_BITMAP value while processing the <A HREF="../functions/VwStreamSectionFunc.htm#VwStreamSectionFunc">VwStreamSectionFunc</A> function. The file parser must also set the bitmap header information for the section by using the <A HREF="../functions/SOPutBitmapHeader.htm#SOPutBitmapHeader">SOPutBitmapHeader</A> function before returning from <B>VwStreamSectionFunc</B>. The information in the bitmap header allows the chunker to allocate storage for other bitmap information, such as the palette. This means that the file parser must call <B>SOPutBitmapHeader</B> before any other bitmapped section functions.

<H4><A NAME="Section_palettes">Section palettes</A></H4>
<P>The file parser must generate a palette for those sections that have the SO_COLORPALETTE value set in the <B>wImageFlags</B> member of the <A HREF="../structures/SOBITMAPHEADER.htm#SOBITMAPHEADER">SOBITMAPHEADER</A> structure. The parser uses the <A HREF="../functions/SOStartPalette.htm#SOStartPalette">SOStartPalette</A>, <A HREF="../functions/SOPutPaletteEntry.htm#SOPutPaletteEntry">SOPutPaletteEntry</A>, and <A HREF="../functions/SOEndPalette.htm#SOEndPalette">SOEndPalette</A> functions to define the color palette for a bitmapped section. Only one palette may be defined for a bitmapped section.

<P>All members set during the stream read can use RGB values, palette index values, or palette-relative RGB values. These values must be set through the <A HREF="../macros/SOPALETTEINDEX.htm#SOPALETTEINDEX">SOPALETTEINDEX</A>, <A HREF="../macros/SORGB.htm#SORGB">SORGB</A>, or <A HREF="../macros/SOPALETTERGB.htm#SOPALETTERGB">SOPALETTERGB</A> macro. For more information about these types of color values, see the description of the
<object id="hhal_3" type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Item1" value="">
<PARAM name="Item2" value=_win32_Further_Reading>
</object><A HREF=JavaScript:hhal_3.Click()>COLORREF</A> value.

<H4><A NAME="Tiles_and_scan_lines">Tiles and scan lines</A></H4>
<P>A bitmap image in a bitmapped section consists of tiles and scan lines. A tile is a rectangular portion of an image, containing at least one scan line. An image is one or more tiles wide and one or more tiles long. A tile column is the horizontal positioning of a tile; the tiles that have their x-coordinate equal to zero belong to tile column zero, with tile column numbers incrementing in the direction of the increasing x-coordinates.

<P>The file parser specifies its tile length in terms of scan lines. Once the length is specified, the display engine always requests bitmap data as whole tiles; that is, it tells the parser to stop only on integer multiples of the tile length. For formats that contain multiple tiles, file parsers should set the tile length to the minimum number of scan lines required for a single tile. Formats that are not stored in tiles should have the tile width set equal to the image width and the tile length set to one scan line. 

<P>The following values are expected to be valid when tiles are created.
<PRE>TILESACROSS = (ImageWidth+TileWidth-1)/TileWidth
TILESDOWN = (ImageLength+TileLength-1)/TileLength
TILESPERIMAGE=TILESACROSS*TILESDOWN
 </PRE>
<P>To output bitmap data, the file parser outputs a scan line at a time, in sequential order, by using the <A HREF="../functions/SOPutScanLineData.htm#SOPutScanLineData">SOPutScanLineData</A> function. All of the scan lines must belong to the same tile column. After each scan line, the file parser calls the <A HREF="../functions/SOPutBreak.htm#SOPutBreak">SOPutBreak</A> function with the SO_SCANLINEBREAK value. As is normally the case, the return value from <B>SOPutBreak</B> indicates whether the file parser should return from the <A HREF="../functions/VwStreamReadFunc.htm#VwStreamReadFunc">VwStreamReadFunc</A> function.

<H4><A NAME="Building_scan_lines">Building scan lines</A></H4>
<P>The file parser builds the scan line data as a continuous stream of bits that define each pixel. Each pixel is packed into an array of bytes in such a way that if the data were written out in hexadecimal or binary numbers, the pixels could be read in order from left to right. For example, in a 4-bit-per-pixel format, the first pixel is stored in the high-order bits of the first byte (bit 7, bit 6, bit 5, and bit 4), and the second pixel is stored in low-order bits of that byte (bit 3, bit 2, bit 1, and bit 0). So if the first eight pixels of a 4-bit-per-pixel scan line have the hexadecimal values of 0, 2, C, 9, A, 4, 3, and F, the first four bytes of scan line data would be 02, C9, A4, and 3F. 

<P>If the parser provides a palette for the image, the data for each pixel is interpreted as an index into the palette. If no palette exists for the image, the bits for each pixel specify either a true color (24-bit only) or a gray scale value. For 24-bit color, each 3 bytes of a scan line represent the intensities of red, green, and blue of a single pixel. 

<P>When the scan line has been completely specified, the parser must call <A HREF="../functions/SOPutBreak.htm#SOPutBreak">SOPutBreak</A> with the SO_SCANLINEBREAK value, except for the last line of the bitmap. The last line of the bitmap must end with a break of the SO_SECTIONBREAK or SO_EOFBREAK type, whichever applies.

<P>The following example illustrates the use of the bitmapped functions in the simplest possible case. In this case, the parser has scan line data stored one tile wide. The scan line data is already in the format that the parser is required to provide it in, so the data requires no additional processing after being read in. This example also does not check for EOF or read errors.
<PRE>WORD  wBytesRead;
WORD  wBufSize = Proc.ScanLineBufSize;

do
{
...

xread( hFile, Proc.ScanLineBuf, wBufSize, &amp;wBytesRead );

SOPutScanLineData( Proc.ScanLineBuf, hProc );

...

} while( SOPutBreak( SO_SCANLINEBREAK, 0, hProc ) == SO_CONTINUE );
 
</PRE>
<H3><A NAME="Vector_Graphics_Sect">Vector Graphics Sections</A></H3>
<P>The file parser starts a vector graphics section by calling the <A HREF="../functions/SOPutSectionType.htm#SOPutSectionType">SOPutSectionType</A> function with the SO_VECTOR value while processing the <A HREF="../functions/VwStreamSectionFunc.htm#VwStreamSectionFunc">VwStreamSectionFunc</A> function. The file parser must also set the vector header by using the <A HREF="../functions/SOPutVectorHeader.htm#SOPutVectorHeader">SOPutVectorHeader</A> function before returning from <B>VwStreamSectionFunc</B>. The information in the <A HREF="../structures/SOVECTORHEADER.htm#SOVECTORHEADER">SOVECTORHEADER</A> structure defines the size and attributes of the rectangle in which vector graphics are drawn.

<P>The vector graphics functions are similar to the primitive graphic device interface (GDI) functions, but they include extensions based on the file formats being supported. All vector graphics objects are described in two-dimensional space on a logical coordinate system. The direction and resolution of the x- and y-axes are defined in <A HREF="../structures/SOVECTORHEADER.htm#SOVECTORHEADER">SOVECTORHEADER</A>. 

<P>The file parser uses two functions to transfer data. The <A HREF="../functions/SOVectorAttr.htm#SOVectorAttr">SOVectorAttr</A> function sets attributes related to drawing vector graphics objects, and the <A HREF="../functions/SOVectorObject.htm#SOVectorObject">SOVectorObject</A> function defines a vector graphics object to be drawn. The parser specifies an identifier, a data size, and the address of data when it calls a function. The identifier specifies the action to take and the size and data-defined details of the action. Each action has a corresponding structure in which the data must be given. For example, to define a logical font, the parser must set the members of the <A HREF="../structures/SOLOGFONT.htm#SOLOGFONT">SOLOGFONT</A> structure and pass the structure to <B>SOVectorAttr</B>. 

<P>Although vector graphics functions are similar to the GDI functions, they are not exactly the same. For example, the members of the <A HREF="../structures/SOLOGFONT.htm#SOLOGFONT">SOLOGFONT</A> and
<object id="hhal_4" type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Item1" value="">
<PARAM name="Item2" value=_win32_Further_Reading>
</object><A HREF=JavaScript:hhal_4.Click()>LOGFONT</A> structures are not necessarily the same.

<P>The file parser should call the <A HREF="../functions/SOPutBreak.htm#SOPutBreak">SOPutBreak</A> function with the SO_VECTOROBJECTBREAK value after drawing every object.

<H3><A NAME="Writing_a_File_Parse">Writing a File Parser</A></H3>
<P>File parsers should be contained in a set of source and include files as follows, where <I>XXX</I> represents a mnemonic for the data format. For specific examples, see the sample ASCII filter files identified in the following table:

<TABLE>
<TR><TD><B>Generic file name</B></TD><TD><B>Contents</B></TD><TD><B>Sample ASCII filter file</B></TD>
</TR>
<TR><TD></TD><TD></TD>
</TR>
<TR><TD>VS_<I>XXX</I>.C</TD><TD>Code</TD><TD>VS_ASC.C</TD>
</TR>
<TR><TD>VSD_<I>XXX</I>.C</TD><TD>Data</TD><TD>VSD_ASC.C</TD>
</TR>
<TR><TD>VS_<I>XXX</I>.H</TD><TD>Type definitions</TD><TD>VS_ASC.H</TD>
</TR>
<TR><TD>VSP_<I>XXX</I>.H</TD><TD>Portability information</TD><TD>VSP_ASC.H</TD>
</TR>
</TABLE>
<P>The portability information file makes porting of filters platforms easier. A set of include files is provided that will allow conditional compilations to yield executable DLLs for all of these needs from the same set of source files. 
<P>Your VSP_<I>XXX</I>.H file should look something like the following. (For further information, see the corresponding ASCII filter file.)
<UL><LI>The structure type and name of the static data. 
<PRE>#define VwStreamStaticType  ???
#define VwStreamStaticName  ???
 </PRE>
</UL>
<P>The parser must not change the contents of the structure because it is shared among all instances of the parser.
<UL><LI>The structure type and name of the dynamic data.

<PRE>#define VwStreamDynamicType  ???
#define VwStreamDynamicName  ???
 </PRE>
</UL>
<P><object id="hhal_5" type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Item1" value="">
<PARAM name="Item2" value=_win32_Further_Reading>
</object><A HREF=JavaScript:hhal_5.Click()>VwStreamDynamicName</A> is for consistency and has no real use because all dynamic data is accessed through the function pseudonym. Each instance of the parser has a separate copy of dynamic data.
<UL><LI>The structure type and name of the save data.
<PRE>#define VwStreamSaveType  ???
#define VwStreamSaveName  ???
 </PRE>
</UL>
<P><object id="hhal_6" type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Item1" value="">
<PARAM name="Item2" value=_win32_Further_Reading>
</object><A HREF=JavaScript:hhal_6.Click()>VwStreamSaveName</A> should reference an element in the
<object id="hhal_7" type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Item1" value="">
<PARAM name="Item2" value=_win32_Further_Reading>
</object><A HREF=JavaScript:hhal_7.Click()>VwStreamDynamicType</A> structure. The data in this structure is saved after every call to <A HREF="../functions/VwStreamSectionFunc.htm#VwStreamSectionFunc">VwStreamSectionFunc</A> and <A HREF="../functions/VwStreamReadFunc.htm#VwStreamReadFunc">VwStreamReadFunc</A> and restored before every call to <B>VwStreamReadFunc</B>.
<UL><LI>The structure type and name of the section data.

<PRE>#define VwStreamSectionType  ???
#define VwStreamSectionName  ???
 </PRE>
</UL>
<P>If neither of these is defined, the file parser is assumed to be a single section only.
<object id="hhal_8" type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Item1" value="">
<PARAM name="Item2" value=_win32_Further_Reading>
</object><A HREF=JavaScript:hhal_8.Click()>VwStreamSectionName</A> should reference an element in the
<object id="hhal_9" type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Item1" value="">
<PARAM name="Item2" value=_win32_Further_Reading>
</object><A HREF=JavaScript:hhal_9.Click()>VwStreamDynamicType</A> structure. The data in this structure is saved after each call to <A HREF="../functions/VwStreamSectionFunc.htm#VwStreamSectionFunc">VwStreamSectionFunc</A> and is guaranteed to contain the current section's data on entry to <A HREF="../functions/VwStreamReadFunc.htm#VwStreamReadFunc">VwStreamReadFunc</A>.

<P>This example shows the relationship of the various save areas to the dynamic data structure.

<PRE>typedef struct {
 ...
} VwStreamSaveType;
typedef struct {
 ...
} VwStreamSectionType;
typedef struct {
 ...
    VwStreamSectionType VwStreamSectionName; // multisection only 
    VwStreamSaveType VwStreamSaveName;
} VwStreamDynamicType;
 </PRE>
<UL><LI>The stream identifier name and count.

<PRE>#define VwStreamIdName   ???
#define VwStreamIdCount   ???
 </PRE>
</UL>
<P><object id="hhal_10" type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Item1" value="">
<PARAM name="Item2" value=_win32_Further_Reading>
</object><A HREF=JavaScript:hhal_10.Click()>VwStreamIdName</A> is the name of the FILTER_DESC array in VSD_<I>XXX</I>.C, and
<object id="hhal_11" type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Item1" value="">
<PARAM name="Item2" value=_win32_Further_Reading>
</object><A HREF=JavaScript:hhal_11.Click()>VwStreamIdCount</A> is the number of elements in this array. Like the static data, this data should never be changed by a parser.
<UL><LI>The name of the include file. All the structure types used by the parser should be defined in this file.

<PRE>#define VwInclude              "vs_xxx.h"
#define VwStreamUserSaveType   ???
#define VwStreamGenSeekName    ???
#define VwStreamOpenFunc        xxx_stream_open
#define VwStreamSeekFunc        xxx_stream_seek
#define VwStreamTellFunc        xxx_stream_tell
#define VwStreamReadFunc        xxx_stream_read
#define VwStreamReadRecordFunc  xxx_stream_readrecord
#define VwStreamSectionFunc     xxx_stream_section
#define VwStreamCloseFunc       xxx_stream_close
#define VwGetInfoFunc           xxx_getinfo
#define VwGetRtnsFunc           xxx_getrtns
#define VwGetDataFunc           xxx_getdata
#define VwSetDataFunc           xxx_setdata
#define VwAllocProcFunc         xxx_alloc_proc
#define VwFreeProcFunc          xxx_free_proc
#define VwLocalUpFunc           xxx_local_up
#define VwLocalDownFunc         xxx_local_down
#define VwGetSectionDataFunc    xxx_getsectiondata
#define VwSetSectionDataFunc    xxx_setsectiondata
 </PRE>
</UL>
<UL><LI>The top of the VS_<I>XXX</I>.C file should look like this.

<PRE>#include "VSP_XXX.H"
#include "VSCTOP.H"
#include "VS_XXX.PRO"
 </PRE>
</UL>
<!--CONTENTS_END -->
<!-- START PAGE FOOTER -->
<H6><HR size=1></H6>
<P><A ID=line HREF="#pagetop"><IMG src="../../../art/arrowup1.gif" WIDTH="17" HEIGHT="16" ALIGN="MIDDLE" BORDER="0" ALT="Up">&nbsp;Top of Page</A>
<BR><A ID=line HREF="http://www.microsoft.com/misc/cpyright.htm" TARGET="_top">&#169; 1997 Microsoft Corporation. All rights reserved. Terms of Use.</A>
<!-- END PAGE FOOTER -->
</BLOCKQUOTE>
</BODY>
</HTML>