<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Shell Namespace</TITLE>

<META NAME=MS-HKWD CONTENT="Shell Namespace">
<META NAME="Keywords" CONTENT="Internet Tools & Technologies, Windows Shell API">
<META NAME="Platform" CONTENT="Windows, Win95, WinNT, Mac">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=iso8859-1">
<META NAME="MS.LOCALE" CONTENT="EN-US">
<META NAME="ROBOTS" CONTENT="all">

<SCRIPT>
//<!--
var g_isIE = false, g_isNav = false, g_iMaj = 0, g_sPlat = "";
// -->
</SCRIPT>
<SCRIPT SRC="../../code/ver.js"></SCRIPT>


<SCRIPT DEFER SRC="../../code/common.js"></SCRIPT>
<SCRIPT DEFER>
//<!--
function InitPage()
{
	if (g_isIE && g_iMaj >= 4)	
	{
		SetTOC();
	}
}
//-->
</SCRIPT>

<LINK REL="stylesheet" HREF="/msdn/sdk/inetsdk/help/basicsdkIE4.css" TYPE="text/css">
<!-- STYLE_START -->


<SCRIPT>
//<!--
   var sVR = '../../'	// Set root for the style sheet
   var sCSS = '<LINK REL="stylesheet" HREF="' + sVR;

   if(g_isIE)
   {
	   if (g_iMaj >= 4) // For MSIE 4.0 or later
	   {
		   sCSS += 'basicSDKIE4';
		   if (g_sPlat == "Win") // Windows only for now
		   {
			   document.createStyleSheet(sVR + 'advSDKIE4.css');
		   }
	   }
	   else // For MSIE 3.0 or earlier
	   {
		   sCSS += 'basicSDKIE3';
	   }
   }
   else if (g_isNav) // For all Nav versions
   {
	   sCSS += 'basicSDKNAV';
   }
   else
   {
	   sCSS += 'basicSDKIE3'; // default to IE3 sheet
   }

   sCSS += (sCSS == '' ? '' : '.css" TYPE="text/css">');

   document.write(sCSS);
//-->
</SCRIPT>
<!-- STYLE_END -->
</HEAD>
<BODY onload="InitPage()" BGCOLOR="#FFFFFF">

<A NAME="pagetop"></A><A NAME="ch_folder"></A>
<!-- NAV_LINKS_START -->
<TABLE class=main BORDER=0 CELLSPACING="0" CELLPADDING="0" WIDTH="10%"><TR><TD ROWSPAN="3" VALIGN="TOP" WIDTH="121"><IMG SRC="../../art/headbar2.gif" WIDTH="121" HEIGHT="82" BORDER=0 ALT="Shell Namespace"></TD><TD ROWSPAN="2" VALIGN="TOP" WIDTH="186"><IMG SRC="../../art/headbard.gif" WIDTH="186" HEIGHT="44" BORDER=0 ALT="Shell Namespace"></TD><TD VALIGN="TOP" WIDTH="470"><IMG SRC="../../art/replace1.gif" WIDTH="470" HEIGHT="17" BORDER=0 ALT="*"></TD></TR>
<TR><TD><PRE><IMG SRC="../../art/arrowrht.gif" WIDTH="14" HEIGHT="14" ALIGN="MIDDLE" BORDER=0 ALT="*"><object id="hhal_1" type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Item1" value="">
<PARAM name="Item2" value=_win32_Contents>
</object><A STYLE="color:black" ID=TOC HREF=JavaScript:hhal_1.Click()>Contents</A>  <IMG SRC="../../art/arrowrht.gif" WIDTH="14" HEIGHT="14" ALIGN="MIDDLE" BORDER=0 ALT="*"><object id="hhal_2" type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Item1" value="">
<PARAM name="Item2" value=_win32_Index_1sz1>
</object><A STYLE="color:black" HREF=JavaScript:hhal_2.Click()>Index</A>  <IMG SRC="../../art/arrowrht.gif" WIDTH="14" HEIGHT="14" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black" HREF="Shell.htm#book_shell">Topic Contents</A></PRE></TD></TR>
<TR><TD COLSPAN="2"><PRE><IMG SRC="../../art/arrowlft.gif" WIDTH="17" HEIGHT="15" ALIGN="MIDDLE" BORDER=0 ALT="*"><B>Previous Topic:</B> <A STYLE="color:black" HREF="Shortcut.htm">Shell Links</A>
<IMG SRC="../../art/arrownxt.gif" WIDTH="17" HEIGHT="16" ALIGN="MIDDLE" BORDER=0 ALT="*"><B>Next Topic:</B> <A  STYLE="color:black" HREF="objects/Objects.htm">Shell Objects</A></PRE></TD></TR>
</TABLE>
<!-- NAV_LINKS_END -->
<BLOCKQUOTE class="body">
<!-- CONTENTS_START -->
<H1>Shell Namespace</H1>
<BR CLEAR=ALL>
<P>A <I>namespace</I> is a collection of symbols, such as database keys or file and directory names. The shell uses a single hierarchical namespace to organize all objects of interest to the user, including files, storage devices, printers, network resources, and anything else that can be viewed using Microsoft&#174; Windows&#174; Explorer. The root of this unified namespace is the desktop.
<P>In many ways, the shell namespace is analogous to a file system's directory structure. However, the namespace contains more types of objects than just files and directories. This overview discusses some of these associations, outlines the organization of the shell namespace, and describes the functions and interfaces associated with the namespace.
<P><A CLASS=tctop HREF="NameSpace.htm#Folders_and_File_Obj"><IMG SRC="../../art/arrowy.gif" WIDTH="6" HEIGHT="11" BORDER=0 ALT="arrowy.gif">Folders and File Objects</A><BR>
<P><A CLASS=tctop HREF="NameSpace.htm#Item_Identifiers_and"><IMG SRC="../../art/arrowy.gif" WIDTH="6" HEIGHT="11" BORDER=0 ALT="arrowy.gif">Item Identifiers and Pointers to Item Identifier Lists</A><BR>
<P><A CLASS=tctop HREF="NameSpace.htm#Folder_Locations"><IMG SRC="../../art/arrowy.gif" WIDTH="6" HEIGHT="11" BORDER=0 ALT="arrowy.gif">Folder Locations</A><BR>
<P><A CLASS=tctop HREF="NameSpace.htm#Item_Enumeration"><IMG SRC="../../art/arrowy.gif" WIDTH="6" HEIGHT="11" BORDER=0 ALT="arrowy.gif">Item Enumeration</A><BR>
<P><A CLASS=tctop HREF="NameSpace.htm#Shell_Display_Names"><IMG SRC="../../art/arrowy.gif" WIDTH="6" HEIGHT="11" BORDER=0 ALT="arrowy.gif">Display Names</A><BR>
<P><A CLASS=tctop HREF="NameSpace.htm#Object_Attributes_an"><IMG SRC="../../art/arrowy.gif" WIDTH="6" HEIGHT="11" BORDER=0 ALT="arrowy.gif">Object Attributes and Interfaces</A><BR>
<P><A CLASS=tctop HREF="NameSpace.htm#Using_the_Shell_Name"><IMG SRC="../../art/arrowy.gif" WIDTH="6" HEIGHT="11" BORDER=0 ALT="arrowy.gif">Using the Shell Namespace</A><BR>
<P><A CLASS=tctop HREF="NameSpace.htm#Extending_the_Shell_"><IMG SRC="../../art/arrowy.gif" WIDTH="6" HEIGHT="11" BORDER=0 ALT="arrowy.gif">Extending the Shell Namespace</A><BR>
<P><A CLASS=tctop HREF="NameSpace.htm#Shell_Namespace_Refe"><IMG SRC="../../art/arrowy.gif" WIDTH="6" HEIGHT="11" BORDER=0 ALT="arrowy.gif">Shell Namespace Reference</A><BR>
<H2><A NAME="Folders_and_File_Obj">Folders and File Objects</A></H2>
<P>A <I>folder</I> is a collection of items in the shell namespace. A folder is analogous to a file system directory, and many folders are, in fact, directories. However, there are also other types of folders, such as remote computers, storage devices, the Desktop folder, the Control Panel, the Printers folder, and the Fonts folder. A folder can contain other folders as well as items called <I>file objects</I>. Examples of file objects are Control Panel applications, printers, and actual files. Each type of folder can only contain certain kinds of file objects; for example, a Control Panel application can only exist in the Control Panel folder. It cannot exist in a file system directory. 

<P>Because there are many kinds of folders and file objects, each folder is an OLE component object model (COM) object that can enumerate its contents and carry out other actions. More precisely, each folder implements the <A HREF="ifaces/ishellfolder/IShellFolder.htm#shell_ishellfolder">IShellFolder</A> interface. Retrieving the <B>IShellFolder</B> object for a shell folder is referred to as <I>binding</I> to the folder. When an object's <B>IShellFolder</B> interface is obtained, the interface must eventually be freed by calling its <B>Release</B> method. 

<P>You can bind to the desktop folder (retrieve the folder's <A HREF="ifaces/ishellfolder/IShellFolder.htm#shell_ishellfolder">IShellFolder</A> interface) by using the <A HREF="functions/SHGetDesktopFolder.htm#SHGetDesktopFolder">SHGetDesktopFolder</A> function. You can enumerate subfolders by using the <A HREF="ifaces/ishellfolder/EnumObjects.htm#IShellFolder_EnumObjects">IShellFolder::EnumObjects</A> method. You can bind to a subfolder of any given folder by using the <A HREF="ifaces/ishellfolder/BindToObject.htm#IShellFolder_BindToObject">IShellFolder::BindToObject</A> method. Using these three functions, an application can navigate throughout the entire shell namespace.

 
<H2><A NAME="Item_Identifiers_and">Item Identifiers and Pointers to Item Identifier Lists</A></H2>
<P>Objects in the shell namespace are assigned item identifiers and item identifier lists. An <I>item identifier</I> uniquely identifies an item within its parent folder. An <I>item identifier list</I> uniquely identifies an item within the shell namespace by tracing a path to the item from a known point&#151;usually the desktop. A pointer to an item identifier list (PIDL) is used throughout the shell to identify an item. 

<P>Item identifiers and PIDLs are much like the file names and paths, respectively, used in a file system. However, they share this important difference: item identifiers and PIDLs are binary data structures that never appear to the user. Item names that can be shown to the user (called <I>display names</I>) are described in <A HREF="NameSpace.htm#Shell_Display_Names">Display Names</A>. 

<P>An item identifier is defined by the variable-length <A HREF="structures/SHITEMID.htm#SHITEMID">SHITEMID</A> structure. The first two bytes specify the identifier's size, and the format of the remaining bytes depends on the software that implements the parent folder's <A HREF="ifaces/ishellfolder/IShellFolder.htm#shell_ishellfolder">IShellFolder</A> interface. Except for the first two bytes, item identifiers are not strictly defined, and you should make no assumptions about their format when designing applications. To determine whether two item identifiers are equal, your application can use the <A HREF="ifaces/ishellfolder/CompareIDs.htm#IShellFolder_CompareIDs">IShellFolder::CompareIDs</A> method.

<P>The <A HREF="structures/ITEMIDLIST.htm#ITEMIDLIST">ITEMIDLIST</A> structure defines an element in an item identifier list (the only member of this structure is an <A HREF="structures/SHITEMID.htm#SHITEMID">SHITEMID</A> structure). An item identifier list consists of one or more consecutive byte-aligned <B>ITEMIDLIST</B> structures, followed by a 16-bit zero value. An application can traverse a list of item identifiers by examining the size specified in each <B>SHITEMID</B> structure and stopping when it finds a size of zero.

<P>Item identifier lists are almost always allocated using the shell's allocator (an
<object id="hhal_3" type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Item1" value="">
<PARAM name="Item2" value=_win32_Further_Reading>
</object><A HREF=JavaScript:hhal_3.Click()>IMalloc</A> interface that you can retrieve using the <A HREF="functions/SHGetMalloc.htm#SHGetMalloc">SHGetMalloc</A> function). For example, some shell functions create an item identifier list and return a PIDL to it. In such cases, it is usually your responsibility to make sure the application frees the PIDL that is using the shell's allocator. Note that the <B>SHGetMalloc</B> function retrieves the task allocator for OLE applications.

 
<H2><A NAME="Folder_Locations">Folder Locations</A></H2>
<P>Many folders have special meanings to the shell. An application can use shell functions to retrieve the locations of these special folders and to enable the user to browse for specific folders.

<P>Some special folders are <I>virtual folders</I>&#151;so called because they are not actual directories on any storage device, local or remote. Virtual folders like the Desktop folder, the My Computer folder, and the Network Neighborhood folder make a unified namespace possible by serving as containers for any number of storage devices and network resources. Other virtual folders contain file objects, such as the Control Panel and Printers, that are not part of the file system.

<P>You can use the <A HREF="functions/SHGetSpecialFolderLocation.htm#SHGetSpecialFolderLocation">SHGetSpecialFolderLocation</A> function to retrieve the location of a special folder, which can be virtual or part of the file system. The function returns a PIDL, which the application must eventually free using the shell's allocator (see <A HREF="functions/SHGetMalloc.htm#SHGetMalloc">SHGetMalloc</A>). If the folder is part of the file system, you can convert the PIDL to a file system path using the <A HREF="functions/SHGetPathFromIDList.htm#SHGetPathFromIDList">SHGetPathFromIDList</A> function. For a list of special folders, see the description of the <B>SHGetSpecialFolderLocation</B> function.

<P>To display a dialog box that enables the user to browse for a folder, you can use the <A HREF="functions/SHBrowseForFolder.htm#SHBrowseForFolder">SHBrowseForFolder</A> function. Your application can use this function to prompt the user for a directory or remote computer. This function can also be used to browse for network printers, though printers are not considered folders. The application can specify the root folder in which to browse. For example, to prompt the user for a program group, you could call <B>SHBrowseForFolder</B>, specifying the PIDL for the Programs folder as the root.

 
<H2><A NAME="Item_Enumeration">Item Enumeration</A></H2>
<P>A folder's <A HREF="ifaces/ishellfolder/IShellFolder.htm#shell_ishellfolder">IShellFolder</A> interface can be used to determine the folder's contents by using the <A HREF="ifaces/ishellfolder/EnumObjects.htm#IShellFolder_EnumObjects">IShellFolder::EnumObjects</A> method. This method creates an <I>item enumeration object</I>, which is a set of item identifiers that can be retrieved by using the <A HREF="ifaces/ienumidlist/IEnumIDList.htm#shell_ienumidlist">IEnumIDList</A> interface.

<P>One or more item identifiers can be retrieved from the enumeration object by using the <A HREF="ifaces/ienumidlist/Next.htm#IEnumIDList_Next">IEnumIDList::Next</A> method. Calling this function repeatedly allows an application to retrieve all of the item identifiers, one or more at a time. Using other methods, you can skip items in the sequence, return to the beginning of the sequence, or make a copy of the enumeration object to save its state.

<P>When you are finished using the enumeration object, you must free it by calling the <B>Release</B> method. 

 
<H2><A NAME="Shell_Display_Names">Display Names</A></H2>
<P>Because item identifiers are binary data structures, each item in a shell folder also has a <I>display name</I>, which is a string that can be shown to the user. You can use methods in the <A HREF="ifaces/ishellfolder/IShellFolder.htm#shell_ishellfolder">IShellFolder</A> interface to retrieve an item's display name, to find an item with a specified display name, or to change an item's display name.

<P>The <A HREF="ifaces/ishellfolder/GetDisplayNameOf.htm#IShellFolder_GetDisplayNameOf">IShellFolder::GetDisplayNameOf</A> method can be used to retrieve a display name. The actual string returned depends on the type of display name specified. Values identifying the different types of display names are defined by the <A HREF="enums/SHGNO.htm#SHGNO">SHGNO</A> enumeration. 

<P>There is a special type of display name that can be converted back to an item identifier by using the <A HREF="ifaces/ishellfolder/ParseDisplayName.htm#IShellFolder_ParseDisplayName">IShellFolder::ParseDisplayName</A> method. You might use this type of display name as a parameter to the <A HREF="functions/ShellExecute.htm#ShellExecute">ShellExecute</A> function or as a command-line argument for an application. 

<P>The <A HREF="ifaces/ishellfolder/SetNameOf.htm#IShellFolder_SetNameOf">IShellFolder::SetNameOf</A> method can be used to change the display name of a file object or subfolder. Changing an item's display name also changes its item identifier, so the function returns a PIDL containing the new item identifier. 

<P>The <A HREF="enums/SHGNO.htm#SHGNO">SHGNO</A> enumeration consists of two sets of values. The first set is contained in bits 0 through 7 and specifies if the name is relative to this folder or if the name is a full name. The second set is contained in bits 8 through 15 and is a modifier to the first set that specifies what the name will be used for. Here is an example of how an <A HREF="ifaces/ishellfolder/GetDisplayNameOf.htm#IShellFolder_GetDisplayNameOf">IShellFolder::GetDisplayNameOf</A> implementation might handle this enumeration:

<PRE>#define GET_SHGDN_FOR(dwFlags)         ((DWORD)dwFlags &amp; (DWORD)0x0000FF00)
#define GET_SHGDN_RELATION(dwFlags)    ((DWORD)dwFlags &amp; (DWORD)0x000000FF)

STDMETHODIMP CShellFolder::GetDisplayNameOf( LPCITEMIDLIST pidl, 
                                             DWORD dwFlags, 
                                             LPSTRRET lpName)
{
switch(GET_SHGDN_FOR(dwFlags))
   {
   case SHGDN_FORPARSING:
      switch(GET_SHGDN_RELATION(dwFlags))
         {
         case SHGDN_NORMAL:
            //get the full name
            GetParsingFullName(pidl, lpName-&gt;cStr, sizeof(lpName-&gt;cStr));
            break;

         case SHGDN_INFOLDER:
            //get the relative name
            GetParsingRelativeName(pidl, szText, sizeof(szText));
            break;
            
         default:
            return E_INVALIDARG;
         }
      break;

   case SHGDN_FORADDRESSBAR:
      switch(GET_SHGDN_RELATION(dwFlags))
         {
         case SHGDN_NORMAL:
            //get the full name
            GetAddressBarFullName(pidl, lpName-&gt;cStr, sizeof(lpName-&gt;cStr));
            break;

         case SHGDN_INFOLDER:
            //get the relative name
            GetAddressBarRelativeName(pidl, lpName-&gt;cStr, sizeof(lpName-&gt;cStr));
            break;
            
         default:
            return E_INVALIDARG;
         }
      break;

   case SHGDN_NORMAL:
      switch(GET_SHGDN_RELATION(dwFlags))
         {
         case SHGDN_NORMAL:
            //get the full name
            GetNormalFullName(pidl, lpName-&gt;cStr, sizeof(lpName-&gt;cStr));
            break;

         case SHGDN_INFOLDER:
            //get the relative name
            GetNormalRelativeName(pidl, lpName-&gt;cStr, sizeof(lpName-&gt;cStr));
            break;
            
         default:
            return E_INVALIDARG;
         }
      break;
   }

lpName-&gt;uType = STRRET_CSTR;

return S_OK;
}
</PRE>
<H2><A NAME="Object_Attributes_an">Object Attributes and Interfaces</A></H2>
<P>Every file object and folder has attributes that determine, among other things, what actions can be carried out on it. Your application can obtain the attributes of any file object or folder and can retrieve interfaces for items in a shell folder.

<P>To obtain the attributes of a file object or folder, your application can use the <A HREF="ifaces/ishellfolder/GetAttributesOf.htm#IShellFolder_GetAttributesOf">IShellFolder::GetAttributesOf</A> method. Information obtained by this method includes capabilities (such as whether a file object can be deleted or can be a drop target), display attributes (such as whether a folder is shared), contents flags (such as whether a folder has subfolders), and other attributes (such as whether an object is a folder, whether it is part of the file system, and so on). For a list of attributes, see the description of the <B>IShellFolder::GetAttributesOf</B> method.

<P>Your application can retrieve interfaces that carry out actions on a file object or folder by using the <A HREF="ifaces/ishellfolder/GetUIObjectOf.htm#IShellFolder_GetUIObjectOf">IShellFolder::GetUIObjectOf</A> method. This method can be used to retrieve the <A HREF="ifaces/icontextmenu/IContextMenu.htm#shell_icontextmenu">IContextMenu</A>, <A HREF="ifaces/iextracticon/IExtractIcon.htm#shell_iextracticon">IExtractIcon</A>,
<object id="hhal_4" type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Item1" value="">
<PARAM name="Item2" value=_win32_Further_Reading>
</object><A HREF=JavaScript:hhal_4.Click()>IDataObject</A>, or
<object id="hhal_5" type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Item1" value="">
<PARAM name="Item2" value=_win32_Further_Reading>
</object><A HREF=JavaScript:hhal_5.Click()>IDropTarget</A> interface for the object.

 
<H2><A NAME="Using_the_Shell_Name">Using the Shell Namespace</A></H2>
<P>This section contains examples that demonstrate the functions and interfaces associated with the shell namespace. The code samples given here are for demonstration purposes only. If you wish to use them in your application, you must enhance them to perform proper error and parameter checking. 

 
<H3><A NAME="Using_PIDLs_and_Disp">Using PIDLs and Display Names</A></H3>
<P>This section presents an example illustrating how to retrieve the location of a special folder, traverse an item identifier list, and use the <A HREF="ifaces/ishellfolder/IShellFolder.htm#shell_ishellfolder">IShellFolder</A> interface to retrieve display names. The example is a console application that prints the display names of the folders a user would have to open to get to the Programs folder. To display them, the application would carry out these steps:
<OL><LI>Retrieve the PIDL for the Programs folder by using the <A HREF="functions/SHGetSpecialFolderLocation.htm#SHGetSpecialFolderLocation">SHGetSpecialFolderLocation</A> function.
<LI>Bind to the Desktop folder (retrieve the folder's <A HREF="ifaces/ishellfolder/IShellFolder.htm#shell_ishellfolder">IShellFolder</A> interface) by using the <A HREF="functions/SHGetDesktopFolder.htm#SHGetDesktopFolder">SHGetDesktopFolder</A> function.
<LI>Traverse the item identifier list and process elements as follows: print the subfolder's display name, bind to the subfolder, and release the parent folder's <A HREF="ifaces/ishellfolder/IShellFolder.htm#shell_ishellfolder">IShellFolder</A> interface.
</OL>
<P>Before carrying out any of the preceding steps, your application should retrieve a pointer to the shell's
<object id="hhal_6" type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Item1" value="">
<PARAM name="Item2" value=_win32_Further_Reading>
</object><A HREF=JavaScript:hhal_6.Click()>IMalloc</A> interface (which is saved in the g_pMalloc global variable) by using the <A HREF="functions/SHGetMalloc.htm#SHGetMalloc">SHGetMalloc</A> function.

<P>The following example shows the application's main function. This function carries out all of the steps described previously using the application-defined GetNextItemID and CopyItemID functions to traverse the item identifier list and the application-defined PrintStrRet function to print the display names. Code for these application-defined functions is shown following the code for the main function. 

<PRE>#include &lt;conio.h&gt;
#include &lt;stdio.h&gt;
#include &lt;shlobj.h&gt;

// Global pointer to the shell's IMalloc interface. 
LPMALLOC g_pMalloc; 

// main - the application's entry-point function. 
int __cdecl main() 
   { 
   LPITEMIDLIST pidlPrograms; 
   LPSHELLFOLDER pFolder; 

   // Get the shell's allocator. 
   if (!SUCCEEDED(SHGetMalloc(&amp;g_pMalloc))) 
      return 1; 

   // Get the PIDL for the Programs folder. 
   if (SUCCEEDED(SHGetSpecialFolderLocation(NULL, CSIDL_PROGRAMS, &amp;pidlPrograms))) 
      { 
      // Start with the Desktop folder. 
      if (SUCCEEDED(SHGetDesktopFolder(&amp;pFolder))) 
         { 
         LPITEMIDLIST pidl; 
    
         // Process each item identifier in the list. 
         for (pidl = pidlPrograms; pidl != NULL; pidl = GetNextItemID(pidl)) 
            { 
            STRRET sName; 
            LPSHELLFOLDER pSubFolder; 
            LPITEMIDLIST pidlCopy; 

            // Copy the item identifier to a list by itself. 
            if ((pidlCopy = CopyItemID(pidl)) == NULL) 
               break; 
    
            // Display the name of the subfolder. 
            if (SUCCEEDED(pFolder-&gt;lpVtbl-&gt;GetDisplayNameOf(   pFolder, 
                                                               pidlCopy, 
                                                               SHGDN_INFOLDER, 
                                                               &amp;sName))) 
               PrintStrRet(pidlCopy, &amp;sName); 
    
            // Bind to the subfolder. 
            if (!SUCCEEDED(pFolder-&gt;lpVtbl-&gt;BindToObject(   pFolder, 
                                                            pidlCopy, 
                                                            NULL, 
                                                            &amp;IID_IShellFolder, 
                                                            &amp;pSubFolder))) 
               { 
               g_pMalloc-&gt;lpVtbl-&gt;Free(g_pMalloc, pidlCopy); 
               break; 
               } 
    
            // Free the copy of the item identifier. 
            g_pMalloc-&gt;lpVtbl-&gt;Free(g_pMalloc, pidlCopy); 
    
            // Release the parent folder and point to the 
            // subfolder. 
            pFolder-&gt;lpVtbl-&gt;Release(pFolder); 
            pFolder = pSubFolder; 
            } 
    
         // Release the last folder that was bound to. 
         if (pFolder != NULL) 
            pFolder-&gt;lpVtbl-&gt;Release(pFolder); 
         } 
    
      // Free the PIDL for the Programs folder. 
      g_pMalloc-&gt;lpVtbl-&gt;Free(g_pMalloc, pidlPrograms); 
      } 
    
   // Release the shell's allocator. 
   g_pMalloc-&gt;lpVtbl-&gt;Release(g_pMalloc); 

   return 0; 
   } 
</PRE>
<P>Following is the GetNextItemID function. Given a pointer to an element in an item identifier list, this function returns a pointer to the next element (or NULL if there are no more elements). The main function calls this function to traverse the item identifier list for the Programs folder.

<PRE>// GetNextItemID - points to the next element in an item identifier list. 
// Returns a PIDL if successful, or NULL if at the end of the list. 
// pidl - previous element
LPITEMIDLIST GetNextItemID(LPITEMIDLIST pidl) 
   { 
   // Get the size of the specified item identifier. 
   int cb = pidl-&gt;mkid.cb; 

   // If the size is zero, it is the end of the list. 
   if (cb == 0) 
      return NULL; 

   // Add cb to pidl (casting to increment by bytes). 
   pidl = (LPITEMIDLIST) (((LPBYTE) pidl) + cb); 

   // Return NULL if it is null-terminating, or a pidl otherwise. 
   return (pidl-&gt;mkid.cb == 0) ? NULL : pidl; 
   } 
</PRE>
<P>Following is the CopyItemID function. Given a pointer to an element in an item identifier list, this function allocates a new list containing only the specified element followed by a terminating zero. The main function uses this function to create single-element PIDLs, which it passes to <A HREF="ifaces/ishellfolder/IShellFolder.htm#shell_ishellfolder">IShellFolder</A> interface methods.

<PRE>// CopyItemID - creates an item identifier list containing the first 
//     item identifier in the specified list. 
// Returns a PIDL if successful, or NULL if out of memory. 
LPITEMIDLIST CopyItemID(LPITEMIDLIST pidl) 
   { 
   // Get the size of the specified item identifier. 
   int cb = pidl-&gt;mkid.cb; 

   // Allocate a new item identifier list. 
   LPITEMIDLIST pidlNew = (LPITEMIDLIST) 
   g_pMalloc-&gt;lpVtbl-&gt;Alloc(g_pMalloc, cb + sizeof(USHORT)); 
   if (pidlNew == NULL) 
      return NULL; 

   // Copy the specified item identifier. 
   CopyMemory(pidlNew, pidl, cb); 

   // Append a terminating zero. 
   *((USHORT *) (((LPBYTE) pidlNew) + cb)) = 0; 

   return pidlNew; 
   } 
</PRE>
<P>The <A HREF="ifaces/ishellfolder/GetDisplayNameOf.htm#IShellFolder_GetDisplayNameOf">IShellFolder::GetDisplayNameOf</A> method returns a display name in a <A HREF="structures/STRRET.htm#STRRET">STRRET</A> structure. The display name may be returned in one of three ways, which is specified by the <B>uType</B> member of the <B>STRRET</B> structure. The main function calls the following PrintStrRet function to print the display name.
<PRE>// PrintStrRet - prints the contents of a STRRET structure. 
// pidl - PIDL containing the display name if lpStr-&gt;uType is STRRET_OFFSET. 
// lpStr - address of the STRRET structure. 
void PrintStrRet(LPITEMIDLIST pidl, LPSTRRET lpStr) 
   { 
   LPSTR lpsz; 
   int cch; 
    
   switch (lpStr-&gt;uType) 
      { 
      case STRRET_WSTR: 
         cch = WideCharToMultiByte( CP_ACP, 
                                    0, 
                                    lpStr-&gt;pOleStr, 
                                    -1, 
                                    NULL, 
                                    0, 
                                    NULL, 
                                    NULL); 
         lpsz = (LPSTR) g_pMalloc-&gt;lpVtbl-&gt;Alloc(g_pMalloc, cch); 
         if (lpsz != NULL) 
            { 
            WideCharToMultiByte( CP_ACP, 
                                 0, 
                                 lpStr-&gt;pOleStr, 
                                 -1, 
                                 lpsz, 
                                 cch, 
                                 NULL, 
                                 NULL); 
            printf("%s\n", lpsz); 
            g_pMalloc-&gt;lpVtbl-&gt;Free(g_pMalloc, lpsz); 
            } 
         break; 
    
      case STRRET_OFFSET: 
         printf("%s\n", ((char *) pidl) + lpStr-&gt;uOffset); 
         break; 
    
      case STRRET_CSTR: 
         printf("%s\n", lpStr-&gt;cStr); 
         break; 
      } 
   } 
</PRE>
<H3><A NAME="Browsing_for_Folders">Browsing for Folders</A></H3>
<P>The following example uses the <A HREF="functions/SHBrowseForFolder.htm#SHBrowseForFolder">SHBrowseForFolder</A> function to prompt the user for a program group. The Programs directory is specified as the root.

<PRE>// Main_OnBrowse - browses for a program folder. 
// hwnd - handle to the application's main window. 
// 
// Uses the global variable g_pMalloc, which is assumed to point 
//     to the shell's IMalloc interface. 
void Main_OnBrowse(HWND hwnd) 
{ 
    BROWSEINFO bi; 
    LPSTR lpBuffer; 
    LPITEMIDLIST pidlPrograms;  // PIDL for Programs folder 
    LPITEMIDLIST pidlBrowse;    // PIDL selected by user 
 
    // Allocate a buffer to receive browse information. 
    if ((lpBuffer = (LPSTR) g_pMalloc-&gt;lpVtbl-&gt;Alloc( 
            g_pMalloc, MAX_PATH)) == NULL) 
        return; 
 
    // Get the PIDL for the Programs folder. 
    if (!SUCCEEDED(SHGetSpecialFolderLocation( 
            hwnd, CSIDL_PROGRAMS, &amp;pidlPrograms))) { 
        g_pMalloc-&gt;lpVtbl-&gt;Free(g_pMalloc, lpBuffer); 
        return; 
    } 
 
    // Fill in the BROWSEINFO structure. 
    bi.hwndOwner = hwnd; 
    bi.pidlRoot = pidlPrograms; 
    bi.pszDisplayName = lpBuffer; 
    bi.lpszTitle = "Choose a Program Group"; 
    bi.ulFlags = 0; 
    bi.lpfn = NULL; 
    bi.lParam = 0; 
 
    // Browse for a folder and return its PIDL. 
    pidlBrowse = SHBrowseForFolder(&amp;bi); 
    if (pidlBrowse != NULL) { 
 
        // Show the display name, title, and file system path. 
        MessageBox(hwnd, lpBuffer, "Display name", MB_OK); 
        if (SHGetPathFromIDList(pidlBrowse, lpBuffer)) 
            SetWindowText(hwnd, lpBuffer); 
 
        // Free the PIDL returned by SHBrowseForFolder. 
        g_pMalloc-&gt;lpVtbl-&gt;Free(g_pMalloc, pidlBrowse); 
    } 
 
    // Clean up. 
    g_pMalloc-&gt;lpVtbl-&gt;Free(g_pMalloc, pidlPrograms); 
    g_pMalloc-&gt;lpVtbl-&gt;Free(g_pMalloc, lpBuffer); 
} 
</PRE>
<H2><A NAME="Extending_the_Shell_">Extending the Shell Namespace</A></H2>
<P>A namespace extension provides a way for you to define a new object that a browser, such as Windows Explorer, can view. The code you provide and the registry entries you make define the icon images and text that the user sees while viewing your data. It also defines the menus, toolbars, and status information that apply to your data objects. 

<P>One of the reasons it is relatively easy to extend the shell namespace is that Windows Explorer can be viewed as two independent parts: the browser code and the system namespace provider code. Because these parts were written polymorphically and communicate by using COM-based interfaces, they do not depend on each other's implementation. Thus, anyone can provide either browser code that browses the system namespace or a system namespace extension that can be browsed using Windows Explorer.

<P>Your extension has to provide Windows Explorer with the icons, names, and details that you want to represent the items in your namespace. It can provide Explorer with a custom context menu for your data as well as drag-and-drop capabilities. It is important to remember that only you know the contents of the items in your namespace. Therefore, Explorer cannot make any assumptions about these objects and can only display the information that you provide. 

 
<H3><A NAME="Structuring_a_Namesp">Structuring a Namespace Extension</A></H3>
<P>As is the case with shell extensions, a namespace extension is implemented as a COM in-process server DLL. To implement even the simplest extensions, you should have experience with COM and OLE, and you should be knowledgeable about the behavior of Windows Explorer. You must also properly register your extension, or it will not work.

<P>Remember that the construction of an in-process server DLL requires the implementation of a DLL that exports the following functions:
<UL><LI><object id="hhal_7" type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Item1" value="">
<PARAM name="Item2" value=_win32_Further_Reading>
</object><A HREF=JavaScript:hhal_7.Click()>DllGetClassObject</A>
<LI><object id="hhal_8" type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Item1" value="">
<PARAM name="Item2" value=_win32_Further_Reading>
</object><A HREF=JavaScript:hhal_8.Click()>DllCanUnloadNow</A>
</UL>
<P>The DLL also implements an object that exposes the
<object id="hhal_9" type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Item1" value="">
<PARAM name="Item2" value=_win32_Further_Reading>
</object><A HREF=JavaScript:hhal_9.Click()>IClassFactory</A> interface for the creation of the other objects contained in the DLL. Those objects will expose the
<object id="hhal_10" type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Item1" value="">
<PARAM name="Item2" value=_win32_Further_Reading>
</object><A HREF=JavaScript:hhal_10.Click()>IUnknown</A> interface and any other interfaces necessary to implement a namespace extension, including <A HREF="ifaces/ipersistfolder/IPersistFolder.htm#shell_ipersistfolder">IPersistFolder</A>, <A HREF="ifaces/ishellfolder/IShellFolder.htm#shell_ishellfolder">IShellFolder</A>, <A HREF="ifaces/ienumidlist/IEnumIDList.htm#shell_ienumidlist">IEnumIDList</A>, and <A HREF="ifaces/ishellview/IShellView.htm#shell_ishellview">IShellView</A>. These interfaces allow Windows Explorer and your extension to interact. 

<P>It is important to remember that Windows Explorer communicates with your extension by using the <A HREF="ifaces/ishellfolder/IShellFolder.htm#shell_ishellfolder">IShellFolder</A> and <A HREF="ifaces/ishellview/IShellView.htm#shell_ishellview">IShellView</A> interfaces you have implemented in your extension. The <A HREF="ifaces/ishellbrowser/IShellBrowser.htm#shell_ishellbrowser">IShellBrowser</A> interface (implemented by Explorer), allows your extension to communicate with Explorer. This is very similar to site-type interfaces commonly found in OLE hosting situations. 

<P>Beyond these required interfaces, your extension will need to implement other interfaces that will be created by the <A HREF="ifaces/ishellfolder/IShellFolder.htm#shell_ishellfolder">IShellFolder</A> object. These include <A HREF="ifaces/iextracticon/IExtractIcon.htm#shell_iextracticon">IExtractIcon</A> to provide icons, <A HREF="ifaces/icontextmenu/IContextMenu.htm#shell_icontextmenu">IContextMenu</A> to provide context menus for your items, drag-and-drop interfaces (<object id="hhal_11" type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Item1" value="">
<PARAM name="Item2" value=_win32_Further_Reading>
</object><A HREF=JavaScript:hhal_11.Click()>IDropSource</A> and
<object id="hhal_12" type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Item1" value="">
<PARAM name="Item2" value=_win32_Further_Reading>
</object><A HREF=JavaScript:hhal_12.Click()>IDropTarget</A>), and
<object id="hhal_13" type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Item1" value="">
<PARAM name="Item2" value=_win32_Further_Reading>
</object><A HREF=JavaScript:hhal_13.Click()>IDataObject</A> for data transfer.

<P>Studying examples of in-process server DLLs, especially any that contain namespace or shell extensions, is helpful in learning to build namespace extension DLLs. The <B>RegView</B> sample included with the Internet Client SDK is a good example of a namespace extension. 

 
<H3><A NAME="Identifying_Items_in">Identifying Items in the Namespace</A></H3>
<P>One of the operations that must be handled when you are extending the shell namespace is the enumeration of items. A call to the <A HREF="ifaces/ishellfolder/EnumObjects.htm#IShellFolder_EnumObjects">IShellFolder::EnumObjects</A> method returns an <A HREF="ifaces/ienumidlist/IEnumIDList.htm#shell_ienumidlist">IEnumIDList</A> interface that will return a set of identifiers for the items within a specific folder. Called a shell item IDLIST, it is an array of bytes that contains enough data to identify items by the parent folder. Only the first two bytes are defined, and they contain the size of the identifier list. The rest of the identifier list contains data that is specific to the folder implementation. This data has no meaning to the caller. 

<P>A shell item IDLIST must contain sufficient information to identify an object within a folder, but it may also contain additional information for efficient manipulation (such as sorting or retrieving display names). You have the option to store additional information in the shell IDLIST because Windows Explorer does not compare two item identifiers directly for either sorting or identification. Instead it uses <A HREF="ifaces/ishellfolder/CompareIDs.htm#IShellFolder_CompareIDs">IShellFolder::CompareIDs</A> to perform this task.

 
<H3><A NAME="Nonrooted_and_Rooted">Nonrooted and Rooted Explorers</A></H3>
<P>Your namespace extension can be implemented in one of two ways: you can implement your extension so the user can view it using the standard Windows Explorer, or you can create a completely separate namespace. There are no set criteria for determining which to use; you should evaluate which is more logical and better suited for your particular application.

<P>If you choose to implement your extension so the user can browse into it using the standard Explorer, your new namespace is presented as a subnamespace to the system namespace already present. Since the Desktop is the root folder of the system's namespace, it also serves this purpose for your extension. Accordingly, your extension resides within the existing hierarchy of objects on the desktop and appears to the user as just another item in the system namespace. 

<P>If you analyze your application and determine that implementing a completely separate namespace makes more sense, the user will not be able to view it without running a special instance of Windows Explorer rooted in an item of your choosing. The rooted Explorer's top level is referred to as a <I>junction point</I>. The junction point can be a file or a folder, but if the extension uses any junction point, it is, by definition, rooted. This is because Explorer does not support browsing directly into files. 

<P>As noted earlier, you should decide whether to implement your extension as rooted or nonrooted based on which implementation will work best for your application. There are no set rules. If your extension logically blends into the existing hierarchy of objects, a nonrooted Explorer might be best. If not, it will probably be better to implement a rooted Explorer with a specific file as your entry point to the new namespace. 

 
<H4><A NAME="Creating_a_junction_">Creating a junction point</A></H4>
<P>Creating a junction point can be done in several different ways, depending on the item you choose for the junction point, such as a file or directory. For example, to make a junction point in either the Desktop or the My Computer folder, add the following key to the registry:
<PRE>HKEY_LOCAL_MACHINE
    SOFTWARE
        Microsoft
          Windows
            CurrentVersion
               Explorer
                  [MyComputer or Desktop]
                       {CLSID}
</PRE>
<P>You can also use a directory as your junction point. If your operating system supports long file names, you can use the CLSID of your namespace extension as the file extension of a folder (MyFolder.{20D....}. Otherwise, you can create a directory, change its file attributes to read-only, and place a file called Desktop.ini in it. This simple text file is made up of the following:

<P>[.ShellClassInfo]

<P>CLSID={<I>clsid</I>}

 
<H4><A NAME="Opening_a_rooted_Win">Opening a rooted Windows Explorer</A></H4>
<P>To open a rooted Windows Explorer for the namespace you have created, you must provide a way to start the new instance of Explorer.exe using the /root switch on the command line. There are several ways to accomplish this. For example, you can call <A HREF="functions/ShellExecute.htm#ShellExecute">ShellExecute</A> directly, or you can create a shortcut file that contains one of the following as a command line.
<UL><LI>If the junction point is an item under the desktop:
<PRE>explorer.exe /e,/root,::{CLSID of item}
</PRE>
<LI>If the junction point is an item under My Computer:
<PRE>explorer.exe /e,/root,,::{20D04FE0 - 3AEA - 1069 - A2D8 - 08002B30309D}
           \::{CLSID of item}}
</PRE>
<LI>If the junction point is a file system folder:
<PRE>explorer.exe /e,/root, [path to a junction point]
</PRE>
</UL>
<P>When Windows Explorer is opened using the /root::{CLSID} option, it sets the junction point object as the root of the hierarchy and calls the <A HREF="ifaces/ishellfolder/IShellFolder.htm#shell_ishellfolder">IShellFolder</A> interface. 

<P>When the user opens a junction point object or one of its subfolders, Windows Explorer causes the extension to create a view object by calling the <A HREF="ifaces/ishellfolder/CreateViewObject.htm#IShellFolder_CreateViewObject">IShellFolder::CreateViewObject</A> method and requesting an <A HREF="ifaces/ishellview/IShellView.htm#shell_ishellview">IShellView</A> interface. Explorer then calls the <A HREF="ifaces/ishellview/CreateViewWindow.htm#IShellView_CreateViewWindow">IShellView::CreateViewWindow</A> method to cause the extension to create the view window of the folder. One of the parameters passed is a pointer to the <A HREF="ifaces/ishellbrowser/IShellBrowser.htm#shell_ishellbrowser">IShellBrowser</A> interface, which allows the extension to communicate with Explorer. The view object is able to do any combination of the following: add menu items to the menu bar, add toolbar buttons, display status information on the status bar, and process shortcut keys.

 
<H3><A NAME="UI_Negotiation__Menu">UI Negotiation (Menu, Toolbar, and Status Bar)</A></H3>
<P>The mechanism to determine which items will appear in the view window while the contents are visible is similar to OLE in-place activation, but notable differences do exist. Three of them are discussed here.

<P>First, the view window always exists, even if it does not have the input focus. Therefore, it should maintain three states:
<UL><LI>Deactivated
<LI>Activated with the focus
<LI>Activated without the focus
</UL>
<P>The view window may present different sets of menu items depending on the focus state. Windows Explorer notifies the extension of state changes by calling the <A HREF="ifaces/ishellview/UIActivate.htm#IShellView_UIActivate">IShellView::UIActivate</A> method. The view object should call the <A HREF="ifaces/ishellbrowser/OnViewWindowActive.htm#IShellBrowser_OnViewWindowActive">IShellBrowser::OnViewWindowActive</A> method when the view window is activated by the user.

<P>Second, Windows Explorer does not support layout negotiation. Instead, it allows the view window to add toolbar buttons or set status bar text. The view window can also create modeless pop-up windows, calling either the <A HREF="ifaces/ishellbrowser/GetControlWindow.htm#IShellBrowser_GetControlWindow">IShellBrowser::GetControlWindow</A> or <A HREF="ifaces/ishellbrowser/SendControlMsg.htm#IShellBrowser_SendControlMsg">IShellBrowser::SendControlMsg</A> method to control them. Explorer forwards appropriate notification messages from those controls by sending a WM_COMMAND message to the window returned by the <A HREF="ifaces/ishellview/CreateViewWindow.htm#IShellView_CreateViewWindow">IShellView::CreateViewWindow</A> method.

<P>Third, Windows Explorer allows the view window to add menu items to Explorer's pull-down menus (in addition to inserting top-level pull-down menus). In other words, the view object is allowed to insert menu items into submenus returned from the <A HREF="ifaces/ishellbrowser/InsertMenusSB.htm#IShellBrowser_InsertMenusSB">IShellBrowser::InsertMenusSB</A> method. To let Explorer dispatch menu messages correctly, a certain range of menu item identifiers (between FCIDM_SHVIEWFIRST and FCIDM_SHVIEWLAST) must be used.

 
<H3><A NAME="Persistent_View_Stat">Persistent View State</A></H3>
<P>Windows Explorer defines standard view states that can be used by a view implementation. These include: 
<UL><LI>View mode (such as large icon, small icon, and detail) 
<LI>View attributes (such as snap to grid) 
</UL>
<P>Windows Explorer provides a persistent medium in which to store these states, and although using them is not required, it is recommended. The settings are stored in a <A HREF="structures/FOLDERSETTINGS.htm#FOLDERSETTINGS">FOLDERSETTINGS</A> structure. Explorer supplies the current settings to the view object with the <A HREF="ifaces/ishellview/CreateViewWindow.htm#IShellView_CreateViewWindow">IShellView::CreateViewWindow</A> method. Explorer retrieves the view object's current settings by calling the <A HREF="ifaces/ishellview/GetCurrentInfo.htm#IShellView_GetCurrentInfo">IShellView::GetCurrentInfo</A> method.

<P>Windows Explorer also provides a persistent medium (a stream) to let the view object store view-specific information (such as scroll positions or icon layout). The view object can access this stream by calling the <A HREF="ifaces/ishellbrowser/GetViewStateStream.htm#IShellBrowser_GetViewStateStream">IShellBrowser::GetViewStateStream</A> method.

<P>When the user is browsing from one folder to another, Explorer passes the pointer to the previously viewed instance of the <A HREF="ifaces/ishellview/IShellView.htm#shell_ishellview">IShellView</A> interface as a parameter to <A HREF="ifaces/ishellview/CreateViewWindow.htm#IShellView_CreateViewWindow">IShellView::CreateViewWindow</A> (before calling the previous view's <A HREF="ifaces/ishellview/DestroyViewWindow.htm#IShellView_DestroyViewWindow">IShellView::DestroyViewWindow</A> method). This allows the view object being created to determine if the previous view object is of a known type. It does this by calling the <B>QueryInterface</B> method to obtain an interface that is only known between the two objects. If the previous view object is of a known type, current private settings can be exchanged using an application-dependent method.

 
<H3><A NAME="Registering_Your_Nam">Registering Your Namespace Extension</A></H3>
<P>Registering your extension is not difficult, but it must be done precisely or users will not be able to find your namespace extension. 

<P>Namespace extensions, like all COM objects, must be registered in the CLSID section. In addition, they must also have the named value ThreadingModel set to Apartment, as shown below.
<PRE>HKEY_CLASSES_ROOT\CLSID\{CLSID} 
HKEY_CLASSES_ROOT_CLSID\{CLSID}\InProcServer32\(default)=path\filename.dll
HKEY_CLASSES_ROOT_CLSID\{CLSID}&#009;\InProcServer32\"ThreadingModel" = "Apartment"
</PRE>
<P>If your namespace extension is going to run under a rooted Windows Explorer, you should add the following entries so the Open and Explore verbs appear on your namespace extension.
<PRE>HKEY_CLASSES_ROOT_CLSID\{CLSID}\Shell\Open\Command\(default)
                  =c:\windows\explorer.exe/root,%1
HKEY_CLASSES_ROOT_CLSID\{CLSID}\Shell\Explore\Command\(default) 
                  =c:\windows\explorer.exe/e,/root/%1
</PRE>
<P>You can also include entries for the default icon under the following key: 

<PRE>HKEY_CLASSES_ROOT_CLSID\{CLSID}\DefaultIcon\(default)="path\filename.dll",IconIndex
</PRE>
<P>The following is an optional key, but it's one that can be very important. If you include the "Attributes" named value under ...{<I>CLSID</I>}\ShellFolder, you specify the attributes of a junction point by using the SFGAO_* flags returned by the <A HREF="ifaces/ishellfolder/GetAttributesOf.htm#IShellFolder_GetAttributesOf">IShellFolder::GetAttributesOf</A> method.
<PRE>HKEY_CLASSES_ROOT_CLSID\{CLSID}\ShellFolder\Attributes = 0000 00 00 
</PRE>
<P>For example, if the SFGAO_FOLDER flag is set and its junction point exists in the system namespace, the user sees your extension's icon in Windows Explorer's left pane and is able to browse into it using the standard (nonrooted) Explorer. If this flag is not set, you must provide a rooted Explorer for browsing.

<P>Another example is the SFGAO_HASSUBFOLDER flag. If it is set, Explorer can make the extension's icon expandable to the next level by displaying the "+" icon to its left. 

<P>Other registry entries you should know about include those required for putting items into My Computer or on the desktop. The following entries list all the items in those two locations:
<PRE>HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer
               \MyComputer\NameSpace
HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer
               \Desktop\NameSpace
</PRE>
<P>Finally, the following entry is currently required only for Microsoft&#174; Windows NT&amp;rg, but it should always be added to the registry for future compatibility with all operating systems. This is the list of extensions that the shell will load. Extensions that don't appear on this list will not be loaded by the shell on Windows NT. 

<PRE>HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\WindowsNT\CurrentVersion\ShellExtensions
               \Approved\{CLSID}="Extension Name"
</PRE>
<H2><A NAME="Shell_Namespace_Refe">Shell Namespace Reference</A></H2>
<P>The following programming elements are used with the shell namespace. 

<P>
<TABLE>
<TR><TD><B>Interfaces</B></TD></TR>
<TR><TD><A HREF="ifaces/icommdlgbrowser/ICommDlgBrowser.htm#shell_icommdlgbrowser">ICommDlgBrowser</A></TD></TR>
<TR><TD><A HREF="ifaces/idockingwindow/IDockingWindow.htm#shell_idockingwindow">IDockingWindow</A></TD></TR>
<TR><TD><A HREF="ifaces/idockingwindowframe/IDockingWindowFrame.htm#shell_idockingwindowframe">IDockingWindowFrame</A></TD></TR>
<TR><TD><A HREF="ifaces/idockingwindowsite/IDockingWindowSite.htm#shell_idockingwindowsite">IDockingWindowSite</A></TD></TR>
<TR><TD><A HREF="ifaces/ienumidlist/IEnumIDList.htm#shell_ienumidlist">IEnumIDList</A>

</TD></TR>
<TR><TD><A HREF="ifaces/ipersistfolder/IPersistFolder.htm#shell_ipersistfolder">IPersistFolder</A></TD></TR>
<TR><TD><A HREF="ifaces/ishellbrowser/IShellBrowser.htm#shell_ishellbrowser">IShellBrowser</A></TD></TR>
<TR><TD><A HREF="ifaces/ishellexecutehook/IShellExecuteHook.htm#shell_ishellexecutehook">IShellExecuteHook</A></TD></TR>
<TR><TD><A HREF="ifaces/ishellfolder/IShellFolder.htm#shell_ishellfolder">IShellFolder</A></TD></TR>
<TR><TD><A HREF="ifaces/ishellicon/IShellIcon.htm#shell_ishellicon">IShellIcon</A></TD></TR>
<TR><TD><A HREF="ifaces/ishellview/IShellView.htm#shell_ishellview">IShellView</A></TD></TR>
</TABLE>
<P>
<TABLE>
<TR><TD><B>Functions</B></TD></TR>
<TR><TD><A HREF="functions/BrowseCallbackProc.htm#BrowseCallbackProc">BrowseCallbackProc</A></TD></TR>
<TR><TD><A HREF="functions/SHAddToRecentDocs.htm#SHAddToRecentDocs">SHAddToRecentDocs</A></TD></TR>
<TR><TD><A HREF="functions/SHBrowseForFolder.htm#SHBrowseForFolder">SHBrowseForFolder</A></TD></TR>
<TR><TD><A HREF="functions/SHChangeNotify.htm#SHChangeNotify">SHChangeNotify</A></TD></TR>
<TR><TD><A HREF="functions/SHFileOperation.htm#SHFileOperation">SHFileOperation</A></TD></TR>
<TR><TD><A HREF="functions/SHFreeNameMappings.htm#SHFreeNameMappings">SHFreeNameMappings</A></TD></TR>
<TR><TD><A HREF="functions/SHGetDataFromIDList.htm#SHGetDataFromIDList">SHGetDataFromIDList</A></TD></TR>
<TR><TD><A HREF="functions/SHGetDesktopFolder.htm#SHGetDesktopFolder">SHGetDesktopFolder</A></TD></TR>
<TR><TD><A HREF="functions/SHGetFileInfo.htm#SHGetFileInfo">SHGetFileInfo</A></TD></TR>
<TR><TD><A HREF="functions/SHGetInstanceExplorer.htm#SHGetInstanceExplorer">SHGetInstanceExplorer</A></TD></TR>
<TR><TD><A HREF="functions/SHGetMalloc.htm#SHGetMalloc">SHGetMalloc</A></TD></TR>
<TR><TD><A HREF="functions/SHGetPathFromIDList.htm#SHGetPathFromIDList">SHGetPathFromIDList</A></TD></TR>
<TR><TD><A HREF="functions/SHGetSpecialFolderLocation.htm#SHGetSpecialFolderLocation">SHGetSpecialFolderLocation</A></TD></TR>
<TR><TD><A HREF="functions/SHLoadInProc.htm#SHLoadInProc">SHLoadInProc</A></TD></TR>
</TABLE>
<P>
<TABLE>
<TR><TD><B>Structures</B></TD></TR>
<TR><TD><A HREF="structures/BROWSEINFO.htm#BROWSEINFO">BROWSEINFO</A></TD></TR>
<TR><TD><A HREF="structures/CIDA.htm#CIDA">CIDA</A></TD></TR>
<TR><TD><A HREF="structures/FOLDERSETTINGS.htm#FOLDERSETTINGS">FOLDERSETTINGS</A></TD></TR>
<TR><TD><A HREF="structures/SHFILEINFO.htm#SHFILEINFO">SHFILEINFO</A></TD></TR>
<TR><TD><A HREF="structures/SHFILEOPSTRUCT.htm#SHFILEOPSTRUCT">SHFILEOPSTRUCT</A></TD></TR>
<TR><TD><A HREF="structures/SHNAMEMAPPING.htm#SHNAMEMAPPING">SHNAMEMAPPING</A></TD></TR>
<TR><TD><A HREF="structures/STRRET.htm#STRRET">STRRET</A></TD></TR>
</TABLE>
<P>
<TABLE>
<TR><TD><B>Enumerations</B></TD></TR>
<TR><TD><A HREF="enums/SHCONTF.htm#SHCONTF">SHCONTF</A></TD></TR>
<TR><TD><A HREF="enums/SHGNO.htm#SHGNO">SHGNO</A></TD></TR>
</TABLE>

<!--CONTENTS_END -->
<!-- START PAGE FOOTER -->
<H6><HR size=1></H6>
<P><A ID=line HREF="#pagetop"><IMG src="../../art/arrowup1.gif" WIDTH="17" HEIGHT="16" ALIGN="MIDDLE" BORDER="0" ALT="Up">&nbsp;Top of Page</A>
<BR><A ID=line HREF="http://www.microsoft.com/misc/cpyright.htm" TARGET="_top">&#169; 1997 Microsoft Corporation. All rights reserved. Terms of Use.</A>
<!-- END PAGE FOOTER -->
</BLOCKQUOTE>
</BODY>
</HTML>