<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Common Functions</TITLE>

<META NAME=MS-HKWD CONTENT="Common Functions">
<META NAME="Keywords" CONTENT="Internet Tools & Technologies">
<META NAME="Platform" CONTENT="Windows, Win95, WinNT, Mac">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=iso8859-1">
<META NAME="MS.LOCALE" CONTENT="EN-US">
<META NAME="ROBOTS" CONTENT="all">


<SCRIPT>
//<!--
var g_isIE = false, g_isNav = false, g_iMaj = 0, g_sPlat = "";
// -->
</SCRIPT>
<SCRIPT SRC="../../../code/ver.js"></SCRIPT>


<SCRIPT DEFER SRC="../../../code/common.js"></SCRIPT>
<SCRIPT DEFER>
//<!--
function InitPage()
{
	if (g_isIE && g_iMaj >= 4)	
	{
		SetTOC();
	}
}
//-->
</SCRIPT>

<LINK REL="stylesheet" HREF="/msdn/sdk/inetsdk/help/basicsdkIE4.css" TYPE="text/css">
<!-- STYLE_START -->


<SCRIPT>
//<!--
   var sVR = '../../../'	// Set root for the style sheet
   var sCSS = '<LINK REL="stylesheet" HREF="' + sVR;

   if(g_isIE)
   {
	   if (g_iMaj >= 4) // For MSIE 4.0 or later
	   {
		   sCSS += 'basicSDKIE4';
		   if (g_sPlat == "Win") // Windows only for now
		   {
			   document.createStyleSheet(sVR + 'advSDKIE4.css');
		   }
	   }
	   else // For MSIE 3.0 or earlier
	   {
		   sCSS += 'basicSDKIE3';
	   }
   }
   else if (g_isNav) // For all Nav versions
   {
	   sCSS += 'basicSDKNAV';
   }
   else
   {
	   sCSS += 'basicSDKIE3'; // default to IE3 sheet
   }

   sCSS += (sCSS == '' ? '' : '.css" TYPE="text/css">');

   document.write(sCSS);
//-->
</SCRIPT>
<!-- STYLE_END -->
</HEAD>
<BODY onload="InitPage()" BGCOLOR="#FFFFFF">

<A NAME="pagetop"></A><A NAME="winineto_common"></A>
<!-- NAV_LINKS_START -->
<TABLE class=main BORDER=0 CELLSPACING="0" CELLPADDING="0" WIDTH="10%"><TR><TD ROWSPAN="3" VALIGN="TOP" WIDTH="121"><IMG SRC="../../../art/headbar2.gif" WIDTH="121" HEIGHT="82" BORDER=0 ALT="Common Functions"></TD><TD ROWSPAN="2" VALIGN="TOP" WIDTH="186"><IMG SRC="../../../art/headbard.gif" WIDTH="186" HEIGHT="44" BORDER=0 ALT="Common Functions"></TD><TD VALIGN="TOP" WIDTH="470"><IMG SRC="../../../art/replace1.gif" WIDTH="470" HEIGHT="17" BORDER=0 ALT="*"></TD></TR>
<TR><TD><PRE><IMG SRC="../../../art/arrowrht.gif" WIDTH="14" HEIGHT="14" ALIGN="MIDDLE" BORDER=0 ALT="*"><object id="hhal_1" type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Item1" value="">
<PARAM name="Item2" value=_win32_Contents>
</object><A STYLE="color:black" ID=TOC HREF=JavaScript:hhal_1.Click()>Contents</A>  <IMG SRC="../../../art/arrowrht.gif" WIDTH="14" HEIGHT="14" ALIGN="MIDDLE" BORDER=0 ALT="*"><object id="hhal_2" type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Item1" value="">
<PARAM name="Item2" value=_win32_Index_1sz1>
</object><A STYLE="color:black" HREF=JavaScript:hhal_2.Click()>Index</A>  <IMG SRC="../../../art/arrowrht.gif" WIDTH="14" HEIGHT="14" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black" HREF="introduction.htm#ch_winineto">Topic Contents</A></PRE></TD></TR>
<TR><TD COLSPAN="2"><PRE><IMG SRC="../../../art/arrowlft.gif" WIDTH="17" HEIGHT="15" ALIGN="MIDDLE" BORDER=0 ALT="*"><B>Previous Topic:</B> <A STYLE="color:black" HREF="enable.htm">Enabling Internet Functionality</A>
<IMG SRC="../../../art/arrownxt.gif" WIDTH="17" HEIGHT="16" ALIGN="MIDDLE" BORDER=0 ALT="*"><B>Next Topic:</B> <A  STYLE="color:black" HREF="url_functions.htm">Handling Uniform Resource Locators</A></PRE></TD></TR>
</TABLE>
<!-- NAV_LINKS_END -->
<BLOCKQUOTE class="body">
<!-- CONTENTS_START -->
<H1>Common Functions</H1>

<P>The different Internet protocols (such as FTP, HTTP, and Gopher) use several of the same Win32 Internet functions to handle information on the Internet. These common functions handle their tasks in a consistent manner, regardless of the particular protocol to which they are being applied. Applications can use these functions to create general-purpose functions that handle tasks across the different protocols (such as reading files for FTP, HTTP, and Gopher protocols).

<P>The common functions handle the following tasks:

<UL><LI>Downloading resources from the Internet can be handled by the <A HREF="../functions/InternetReadFile.htm#InternetReadFile">InternetReadFile</A>, <A HREF="../functions/InternetSetFilePointer.htm#InternetSetFilePoint">InternetSetFilePointer</A>, <A HREF="../functions/InternetFindNextFile.htm#InternetFindNextFile">InternetFindNextFile</A>, and <A HREF="../functions/InternetQueryDataAvailable.htm#InternetQueryDataAva">InternetQueryDataAvailable</A> functions.
<LI>Setting up asynchronous operations is handled by the <A HREF="../functions/InternetSetStatusCallback.htm#InternetSetStatusCal">InternetSetStatusCallback</A>.
<LI>Viewing and changing options is handled by the <A HREF="../functions/InternetSetOption.htm#InternetSetOption">InternetSetOption</A> and <A HREF="../functions/InternetQueryOption.htm#InternetQueryOption">InternetQueryOption</A> functions.
<LI>Closing all types of HINTERNET handles is handled by the <A HREF="../functions/InternetCloseHandle.htm#InternetCloseHandle">InternetCloseHandle</A> function.
<LI>Placing and removing locks on resources being used with <A HREF="../functions/InternetLockRequestFile.htm#InternetLockRequestF">InternetLockRequestFile</A> and <A HREF="../functions/InternetUnlockRequestFile.htm#InternetUnlockReques">InternetUnlockRequestFile</A>.
</UL>
<H2><A NAME="Using_Common_Functio">Using Common Functions</A></H2>
<P>The following table lists the common functions included in the Win32 Internet functions. The common functions can be used on different types of HINTERNET handles or can be used during different types of sessions.



<TABLE>
<TR><TD><B>Function
 </B></TD><TD><B>Description
</B></TD></TR>
<TR><TD><A HREF="../functions/InternetFindNextFile.htm#InternetFindNextFile">InternetFindNextFile</A> </TD><TD>Continues file enumeration or search. Requires a handle created by the <A HREF="../functions/FtpFindFirstFile.htm#FtpFindFirstFile">FtpFindFirstFile</A>, <A HREF="../functions/GopherFindFirstFile.htm#GopherFindFirstFile">GopherFindFirstFile</A>, or <A HREF="../functions/InternetOpenUrl.htm#InternetOpenUrl">InternetOpenUrl</A> function.</TD></TR>
<TR><TD><A HREF="../functions/InternetLockRequestFile.htm#InternetLockRequestF">InternetLockRequestFile</A> </TD><TD>Allows the user to place a lock on the file that is being used. This function requires a handle returned by the <A HREF="../functions/FtpOpenFile.htm#FtpOpenFile">FtpOpenFile</A>, <A HREF="../functions/GopherOpenFile.htm#GopherOpenFile">GopherOpenFile</A>, <A HREF="../functions/HttpOpenRequest.htm#HttpOpenRequest">HttpOpenRequest</A>, or <A HREF="../functions/InternetOpenUrl.htm#InternetOpenUrl">InternetOpenUrl</A> function.</TD></TR>
<TR><TD><A HREF="../functions/InternetQueryDataAvailable.htm#InternetQueryDataAva">InternetQueryDataAvailable</A> </TD><TD>Queries the amount of data available. Requires a handle created by the <A HREF="../functions/FtpOpenFile.htm#FtpOpenFile">FtpOpenFile</A>, <A HREF="../functions/GopherOpenFile.htm#GopherOpenFile">GopherOpenFile</A>, or <A HREF="../functions/HttpOpenRequest.htm#HttpOpenRequest">HttpOpenRequest</A> function.</TD></TR>
<TR><TD><A HREF="../functions/InternetQueryOption.htm#InternetQueryOption">InternetQueryOption</A> </TD><TD>Queries the setting of an Internet option.</TD></TR>
<TR><TD><A HREF="../functions/InternetReadFile.htm#InternetReadFile">InternetReadFile</A> </TD><TD>Reads URL data. Requires a handle created by the <A HREF="../functions/InternetOpenUrl.htm#InternetOpenUrl">InternetOpenUrl</A>, <A HREF="../functions/FtpOpenFile.htm#FtpOpenFile">FtpOpenFile</A>, <A HREF="../functions/GopherOpenFile.htm#GopherOpenFile">GopherOpenFile</A>, or <A HREF="../functions/HttpOpenRequest.htm#HttpOpenRequest">HttpOpenRequest</A> function.</TD></TR>
<TR><TD><A HREF="../functions/InternetSetFilePointer.htm#InternetSetFilePoint">InternetSetFilePointer</A> </TD><TD>Sets the position for the next read in a file. Requires a handle created by <A HREF="../functions/InternetOpenUrl.htm#InternetOpenUrl">InternetOpenUrl</A> (on an HTTP URL only) or a handle created by <A HREF="../functions/HttpOpenRequest.htm#HttpOpenRequest">HttpOpenRequest</A> using the GET method.</TD></TR>
<TR><TD><A HREF="../functions/InternetSetOption.htm#InternetSetOption">InternetSetOption</A> </TD><TD>Sets an Internet option.</TD></TR>
<TR><TD><A HREF="../functions/InternetSetStatusCallback.htm#InternetSetStatusCal">InternetSetStatusCallback</A> </TD><TD>Sets a callback function that is called with status information. Assigns a callback function to the designated HINTERNET handle and all handles derived from it.</TD></TR>
<TR><TD><A HREF="../functions/InternetUnlockRequestFile.htm#InternetUnlockReques">InternetUnlockRequestFile</A> </TD><TD>Unlocks a file that was locked using the <A HREF="../functions/InternetLockRequestFile.htm#InternetLockRequestF">InternetLockRequestFile</A> function. </TD></TR></TABLE>
<P>Reading files, finding the next file, manipulating options, and setting up asynchronous operations are common to various protocols and HINTERNET handle types.



<H3><A NAME="Read_File">Reading files</A></H3>
<P>The <A HREF="../functions/InternetReadFile.htm#InternetReadFile">InternetReadFile</A> function is used to download resources from an HINTERNET handle returned by the <A HREF="../functions/InternetOpenUrl.htm#InternetOpenUrl">InternetOpenUrl</A>, <A HREF="../functions/FtpOpenFile.htm#FtpOpenFile">FtpOpenFile</A>, <A HREF="../functions/GopherOpenFile.htm#GopherOpenFile">GopherOpenFile</A>, or <A HREF="../functions/HttpOpenRequest.htm#HttpOpenRequest">HttpOpenRequest</A> function. 

<P><A HREF="../functions/InternetReadFile.htm#InternetReadFile">InternetReadFile</A> accepts a void pointer variable that contains the address of a buffer and a pointer to a double-word (DWORD) variable that contains the length of the buffer. It returns the data in the buffer and the amount of data downloaded into the buffer. 

<P>The Win32 Internet functions provide two techniques to download an entire resource: 

<UL><LI>Using the <A HREF="../functions/InternetQueryDataAvailable.htm#InternetQueryDataAva">InternetQueryDataAvailable</A> function.
<LI>Using the return values of <A HREF="../functions/InternetReadFile.htm#InternetReadFile">InternetReadFile</A>.
</UL>
<P><A HREF="../functions/InternetQueryDataAvailable.htm#InternetQueryDataAva">InternetQueryDataAvailable</A> takes the HINTERNET handle created by <A HREF="../functions/InternetOpenUrl.htm#InternetOpenUrl">InternetOpenUrl</A>, <A HREF="../functions/FtpOpenFile.htm#FtpOpenFile">FtpOpenFile</A>, <A HREF="../functions/GopherOpenFile.htm#GopherOpenFile">GopherOpenFile</A>, or <A HREF="../functions/HttpOpenRequest.htm#HttpOpenRequest">HttpOpenRequest</A> (after <A HREF="../functions/HttpSendRequest.htm#HttpSendRequest">HttpSendRequest</A> has been called on the handle) and returns the number of bytes available. The application should allocate a buffer equal to the number of bytes available &#043;1 for the NULL terminator, and use that buffer with <A HREF="../functions/InternetReadFile.htm#InternetReadFile">InternetReadFile</A>. This method does not always work because <B>InternetQueryDataAvailable</B> is checking the file size listed in the header and not the actual file. The information in the header file could be outdated or the header file could be missing, since it is not currently required under all standards.


<!-- ************************ BRADYA: BEGIN UPDATE ************************ -->
<P>The following example reads the contents of the resource accessed by the hResource handle and displayed in the edit box indicated by intCtrlID.

<PRE>int WINAPI Dumper(HWND hX, int intCtrlID, HINTERNET hResource)
{
     LPSTR     lpszData;          // buffer for the data
     DWORD     dwSize;               // size of the data available
     DWORD     dwDownloaded;     // size of the downloaded data
     DWORD     dwSizeSum=0;     // size of the data in the textbox
     LPSTR     lpszHolding;     // buffer to merge the textbox data and buffer

     // Set the cursor to an hourglass.
     SetCursor(LoadCursor(NULL,IDC_WAIT));


     // This loop handles reading the data.  
     do
     {
          // The call to InternetQueryDataAvailable determines the amount of 
          // data available to download.
          if (!InternetQueryDataAvailable(hResource,&amp;dwSize,0,0))
          {
               ErrorOut(hX,GetLastError(),"InternetReadFile");
               SetCursor(LoadCursor(NULL,IDC_ARROW));
               return FALSE;
          }
          else
          {     
               // Allocates a buffer of the size returned by InternetQueryDataAvailable
               lpszData = new char[dwSize+1];

               // Reads the data from the HINTERNET handle.
               if(!InternetReadFile(hResource,(LPVOID)lpszData,dwSize,&amp;dwDownloaded))
               {
                    ErrorOut(hX,GetLastError(),"InternetReadFile");
                    delete[] lpszData;
                    break;
               }
               else
               {
                    // Adds a null terminator to the end of the data buffer
                    lpszData[dwDownloaded]='\0';

                    // Allocates the holding buffer
                    lpszHolding = new char[dwSizeSum + dwDownloaded + 1];
                    
                    // Checks if there has been any data written to the textbox
                    if (dwSizeSum != 0)
                    {
                         // Retrieves the data stored in the textbox if any
                         GetDlgItemText(hX,intCtrlID,(LPSTR)lpszHolding,dwSizeSum);
                         
                         // Adds a null terminator at the end of the textbox data
                         lpszHolding[dwSizeSum]='\0';
                    }
                    else
                    {
                         // Make the holding buffer an empty string. 
                         lpszHolding[0]='\0';
                    }

                    // Adds the new data to the holding buffer
                    strcat(lpszHolding,lpszData);

                    // Writes the holding buffer to the textbox
                    SetDlgItemText(hX,intCtrlID,(LPSTR)lpszHolding);

                    // Delete the two buffers
                    delete[] lpszHolding;
                    delete[] lpszData;

                    // Add the size of the downloaded data to the textbox data size
                    dwSizeSum = dwSizeSum + dwDownloaded + 1;

                    // Check the size of the remaining data.  If it is zero, break.
                    if (dwDownloaded == 0)
                         break;
               }
          }
     }
     while(TRUE);

     // Close the HINTERNET handle
     InternetCloseHandle(hResource);

     // Set the cursor back to an arrow
     SetCursor(LoadCursor(NULL,IDC_ARROW));

     // Return
     return TRUE;
}
</PRE>
<P><A HREF="../functions/InternetReadFile.htm#InternetReadFile">InternetReadFile</A> returns zero bytes read and completes successfully when all available data has been read. This allows an application to use <B>InternetReadFile</B> in a loop to download the data and exit when it returns zero bytes read and completes successfully.

<P>The following example reads the resource from the Internet and displays the resource in the edit box indicated by intCtrlID. The HINTERNET handle, hResource, has been returned by <A HREF="../functions/InternetOpenUrl.htm#InternetOpenUrl">InternetOpenUrl</A>, <A HREF="../functions/FtpOpenFile.htm#FtpOpenFile">FtpOpenFile</A>, <A HREF="../functions/GopherOpenFile.htm#GopherOpenFile">GopherOpenFile</A>, or <A HREF="../functions/HttpOpenRequest.htm#HttpOpenRequest">HttpOpenRequest</A> (after being sent by <A HREF="../functions/HttpSendRequest.htm#HttpSendRequest">HttpSendRequest</A>).

<PRE>int WINAPI Dump(HWND hX, int intCtrlID, HINTERNET hResource)
{
     
     DWORD dwSize = 0;
     LPSTR lpszData;
     LPSTR lpszOutPut;
     LPSTR lpszHolding;
     int nCounter = 1;
     int nBufferSize = 0;
     DWORD BigSize = 8000;

     // Set the cursor to an hourglass
     SetCursor(LoadCursor(NULL,IDC_WAIT));

     // Begin the loop that reads the data
     do
     {
          // Allocate the buffer
          lpszData =new char[BigSize+1];

          // Read the data
          if(!InternetReadFile(hResource,(LPVOID)lpszData,BigSize,&amp;dwSize))
          {
               ErrorOut(hX,GetLastError(),"InternetReadFile");
               delete []lpszData;
               break;
          }
          else
          {
               // Add a null terminator to the end of the buffer
               lpszData[dwSize]='\0';

               // Check if all of the data has been read.  This should never
               // get called on the first time through the loop.
               if (dwSize == 0)
               {
                    // Write the final data to the textbox
                    SetDlgItemText(hX,intCtrlID,lpszHolding);

                    // Delete the existing buffers.
                    delete [] lpszData;
                    delete [] lpszHolding;
                    break;
               }

               // Determine the buffer size to hold the new data and the data
               // already written to the textbox (if any).
               nBufferSize = (nCounter*BigSize)+1;

               // Increment the number of buffers read
               nCounter++;               

               // Allocate the output buffer
               lpszOutPut = new char[nBufferSize];


               // Make sure the buffer is not the initial buffer
               if(nBufferSize != int(BigSize+1))
               {
                    // Copy the data in the holding buffer
                    strcpy(lpszOutPut,lpszHolding);

                    // Concatenate the new buffer with the output buffer
                    strcat(lpszOutPut,lpszData);
     
                    // Delete the holding buffer
                    delete [] lpszHolding;
               }
               else
               {
                    // Copy the data buffer
                    strcpy(lpszOutPut, lpszData);
               }


               // Allocate a holding buffer
               lpszHolding = new char[nBufferSize]; 

               // Copy the output buffer into the holding buffer
               memcpy(lpszHolding,lpszOutPut,nBufferSize);

               // Delete the other buffers
               delete [] lpszData;
               delete [] lpszOutPut;

          }

     }
     while (TRUE);

     // Close the HINTERNET handle
     InternetCloseHandle(hResource);

     // Set the cursor back to an arrow
     SetCursor(LoadCursor(NULL,IDC_ARROW));

     // Return
     return TRUE;
}
</PRE>
<!-- ************************ BRADYA: END UPDATE ************************** --><H3><A NAME="Next_File">Finding the next file</A></H3>
<P>The <A HREF="../functions/InternetFindNextFile.htm#InternetFindNextFile">InternetFindNextFile</A> function is used to find the next file in a file search, using the search parameters and HINTERNET handle from either <A HREF="../functions/FtpFindFirstFile.htm#FtpFindFirstFile">FtpFindFirstFile</A>, <A HREF="../functions/GopherFindFirstFile.htm#GopherFindFirstFile">GopherFindFirstFile</A>, or <A HREF="../functions/InternetOpenUrl.htm#InternetOpenUrl">InternetOpenUrl</A>.

<P>To complete a file search, continue to call <A HREF="../functions/InternetFindNextFile.htm#InternetFindNextFile">InternetFindNextFile</A> using the HINTERNET handle returned by <A HREF="../functions/FtpFindFirstFile.htm#FtpFindFirstFile">FtpFindFirstFile</A>, <A HREF="../functions/GopherFindFirstFile.htm#GopherFindFirstFile">GopherFindFirstFile</A>, or <A HREF="../functions/InternetOpenUrl.htm#InternetOpenUrl">InternetOpenUrl</A> until the function fails with the extended error message ERROR_NO_MORE_FILES. To get the extended error information, call the
<object id="hhal_3" type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Item1" value="">
<PARAM name="Item2" value=_win32_Further_Reading>
</object><A HREF=JavaScript:hhal_3.Click()>GetLastError</A> function.

<P>The following example displays the contents of an FTP directory in the list box, IDC_FTPList. The HINTERNET handle, hSecondary, is a handle returned by the <A HREF="../functions/InternetConnect.htm#InternetConnect">InternetConnect</A> function after it establishes an FTP session.

<!-- ************************ BRADYA: BEGIN UPDATE ************************ -->
<PRE>bool WINAPI DisplayDir(HWND hX, int lstDirectory, HINTERNET hConnect, 
                            DWORD dwFlag)
{
     WIN32_FIND_DATA pDirInfo;
     HINTERNET hDir;
     char DirList[MAX_PATH];

     // Set the cursor to an hourglass
     SetCursor(LoadCursor(NULL,IDC_WAIT));

     // Reset the list box
     SendDlgItemMessage(hX, lstDirectory,LB_RESETCONTENT,0,0);

     // Find the first file
     if ( !(hDir = FtpFindFirstFile (hConnect, TEXT ("*.*"), &amp;pDirInfo,
                                             dwFlag, 0) ))
     {
          // Check if the error was because there were no files
          if (GetLastError()  == ERROR_NO_MORE_FILES) 
          {
               // Alert user
               MessageBox(hX,"There are no files here!!!","Display Dir",MB_OK);

               // Close the HINTERNET handle
               InternetCloseHandle(hDir);

               // Set the cursor back to an arrow
               SetCursor(LoadCursor(NULL,IDC_ARROW));

               // Return
               return TRUE;
          }
          else 
          {
               // Call error handler
               ErrorOut (hX, GetLastError (), "FindFirst error: ");

               // Close the HINTERNET handle
               InternetCloseHandle(hDir);

               // Set the cursor back to an arrow
               SetCursor(LoadCursor(NULL,IDC_ARROW));

               // Return
               return FALSE;
          }
     }
     else
     {

          // Write the filename to a string
          sprintf(DirList, pDirInfo.cFileName);

          // Check the type of file
          if (pDirInfo.dwFileAttributes == FILE_ATTRIBUTE_DIRECTORY)
          {
               // Add &lt;DIR&gt; to indicate that this is a directory to the user
               strcat(DirList," &lt;DIR&gt; ");
          }
       
          // Add the filename (or directory) to the listbox
          SendDlgItemMessage(hX,lstDirectory,LB_ADDSTRING,0,(LPARAM)DirList);
     
     }

     do
     {
          // Find the next file
          if (!InternetFindNextFile (hDir, &amp;pDirInfo))
          {
               // Check if there are no more files left 
               if ( GetLastError() == ERROR_NO_MORE_FILES ) 
               {
                    // Close the HINTERNET handle
                    InternetCloseHandle(hDir);

                    // Set the cursor back to an arrow
                    SetCursor(LoadCursor(NULL,IDC_ARROW));

                    // Return
                    return TRUE;
               }
               else
               {          
                    // Handle the error 
                    ErrorOut (hX,GetLastError(), "InternetFindNextFile");

                    // Close the HINTERNET handle
                    InternetCloseHandle(hDir);

                    // Set the cursor back to an arrow
                    SetCursor(LoadCursor(NULL,IDC_ARROW));

                    // Return 
                    return FALSE;
               }
           }
           else
           {
               // Write the filename to a string
               sprintf(DirList, pDirInfo.cFileName);

               // Check the type of file
               if (pDirInfo.dwFileAttributes == FILE_ATTRIBUTE_DIRECTORY)
               {
                    // Add &lt;DIR&gt; to indicate that this is a directory to the user
                    strcat(DirList," &lt;DIR&gt; ");
               }
     
               // Add the filename (or directory) to the listbox
               SendDlgItemMessage(hX,lstDirectory,LB_ADDSTRING,0,(LPARAM)DirList);
           }
     }
     while ( TRUE);
     
}
</PRE>
<!-- ************************ BRADYA: BEGIN UPDATE ************************ --><H3><A NAME="Manipulate_Options">Manipulating options</A></H3>
<P><A HREF="../functions/InternetSetOption.htm#InternetSetOption">InternetSetOption</A> and <A HREF="../functions/InternetQueryOption.htm#InternetQueryOption">InternetQueryOption</A> are used to manipulate the Win32 Internet API options. 

<P><A HREF="../functions/InternetSetOption.htm#InternetSetOption">InternetSetOption</A> accepts a double-word value that indicates the option to set, a buffer to hold the option setting, and a pointer that contains the address of the variable containing the length of the buffer.

<P><A HREF="../functions/InternetQueryOption.htm#InternetQueryOption">InternetQueryOption</A> accepts a double-word value that indicates the option to query, a buffer to hold the option setting, and a pointer that contains the address of the variable containing the length of the buffer.



<!-- ************************ BRADYA: BEGIN UPDATE ************************ -->
<H3><A NAME="Set_Async">Setting up asynchronous operations</A></H3>
<P>By default, the Win32 Internet functions operate synchronously. An application can request asynchronous operation by setting the INTERNET_FLAG_ASYNC flag in the call to the <A HREF="../functions/InternetOpen.htm#InternetOpen">InternetOpen</A> function. All future calls made against handles derived from the handle returned from <B>InternetOpen</B> will be made asynchronously.

<P>The rationale for asynchronous versus synchronous operation is to allow a single-threaded application to maximize its utilization of the CPU without having to wait for network I/O to complete. Therefore, depending on the request, the operation might complete synchronously or asynchronously. The application should check the return code. If a function returns FALSE or NULL, and
<object id="hhal_4" type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Item1" value="">
<PARAM name="Item2" value=_win32_Further_Reading>
</object><A HREF=JavaScript:hhal_4.Click()>GetLastError</A> returns ERROR_IO_PENDING, the request has been made asynchronously, and the application will be called back with INTERNET_STATUS_REQUEST_COMPLETE when the function has completed.

<P>For an application to be able to make requests asynchronously, it must set the INTERNET_FLAG_ASYNC flag in the call to <A HREF="../functions/InternetOpen.htm#InternetOpen">InternetOpen</A>, it must register a valid callback function, and it must supply a nonzero context value.

<P>To begin asynchronous operation, the application must set the INTERNET_FLAG_ASYNC flag in its call to <A HREF="../functions/InternetOpen.htm#InternetOpen">InternetOpen</A>. It must then register a valid callback function, using <A HREF="../functions/InternetSetStatusCallback.htm#InternetSetStatusCal">InternetSetStatusCallback</A>.

<P>After a callback function is registered for a handle, all operations on that handle can generate status indications, provided that the context value that was supplied when the handle was created was not zero. Providing a zero context value forces an operation to complete synchronously, even though INTERNET_FLAG_ASYNC was specified in <A HREF="../functions/InternetOpen.htm#InternetOpen">InternetOpen</A>.

<P>Status indications are mainly intended to give the application feedback about the operation's progress and are mainly concerned with network operations, such as resolving a host name, connecting to a server, and receiving data. Three special-purpose status indications can be made for a handle:

<UL><LI>INTERNET_STATUS_HANDLE_CLOSING is the last status indication that is made for a handle. 
<LI>INTERNET_STATUS_HANDLE_CREATED indicates when the handle is initially created.
<LI>INTERNET_STATUS_REQUEST_COMPLETE indicates when an asynchronous operation completes.
</UL>
<P>The application must check the <A HREF="../structures/INTERNET_ASYNC_RESULT.htm#INTERNET_ASYNC_RESUL">INTERNET_ASYNC_RESULT</A> structure to determine whether the operation succeeded or failed after receiving an INTERNET_STATUS_REQUEST_COMPLETE indication. 

<P>The following sample shows an example of a callback function and a call to <A HREF="../functions/InternetSetStatusCallback.htm#InternetSetStatusCal">InternetSetStatusCallback</A> to register the function as the callback function.

<PRE>
void
CALLBACK
CInternet::InternetCallback(
    HINTERNET hInternet,
    DWORD dwcontext,
    DWORD dwInternetStatus,
    LPVOID lpvStatusInformation,
    DWORD dwStatusInformationLength
)
{

// Insert code here.

};

INTERNET_STATUS_CALLBACK dwISC;


dwISC = InternetSetStatusCallback(   hInternet,
        (INTERNET_STATUS_CALLBACK) InternetCallback); 
</PRE>
<H3><A NAME="CLOSING_HINTERNET">Closing HINTERNET handles</A></H3>
<P>All HINTERNET handles can be closed by using the <A HREF="../functions/InternetCloseHandle.htm#InternetCloseHandle">InternetCloseHandle</A> function. Client applications must close all HINTERNET handles derrived from the HINTERNET handle to be closed before calling <B>InternetCloseHandle</B>. For more information about HINTERNET handles and the handle hierarchy, see <A HREF="appendix_a.htm#HINTERNET">Appendix A: HINTERNET Handles</A>.

<P>The following example illustrates the handle hierarchy for the Win32 Internet functions.

<PRE>HINTERNET hRootHandle, hOpenUrlHandle;

hRootHandle = InternetOpen("Example", INTERNET_OPEN_TYPE_DIRECT, NULL, 
    NULL, 0);

hOpenUrlHandle = InternetOpenUrl(hRootHandle, 
    "http://www.server.com/default.htm", NULL, 0, 
    INTERNET_FLAG_RAW_DATA,0);

// Close the handle created by InternetOpenUrl, so that the InternetOpen handle can be closed.
InternetCloseHandle(hOpenUrlHandle); 

// Close the handle created by InternetOpen
InternetCloseHandle(hRootHandle);&#009;

</PRE>
<H3><A NAME="Lock_Unlock">Locking and unlocking resources</A></H3>
<P>The <A HREF="../functions/InternetLockRequestFile.htm#InternetLockRequestF">InternetLockRequestFile</A> function allows an application to ensure that the cached resource associated with the HINTERNET handle passed to it will not disappear from the cache. If another download tries to commit a resource that has the same URL as the locked file, the cache avoids removing the file by doing a safe delete. After the application calls the <A HREF="../functions/InternetUnlockRequestFile.htm#InternetUnlockReques">InternetUnlockRequestFile</A> function, the cache is given permission to delete the file.

<P>If the INTERNET_FLAG_NO_CACHE_WRITE or INTERNET_FLAG_DONT_CACHE flag has been set, <A HREF="../functions/InternetLockRequestFile.htm#InternetLockRequestF">InternetLockRequestFile</A> creates a temporary file with the extension TMP, unless the handle is connected to an HTTPS resource. If the function is accessing an HTTPS resource and INTERNET_FLAG_NO_CACHE_WRITE (or INTERNET_FLAG_DONT_CACHE) has been set, <B>InternetLockRequestFile</B> fails.


<!-- ************************ BRADYA: END UPDATE ************************** -->


<!-- CONTENTS_END -->
<!-- START PAGE FOOTER -->
<H6><HR size=1></H6>
<P><A ID=line HREF="#pagetop"><IMG src="../../../art/arrowup1.gif" WIDTH="17" HEIGHT="16" ALIGN="MIDDLE" BORDER="0" ALT="Up">&nbsp;Top of Page</A>
<BR><A ID=line HREF="http://www.microsoft.com/misc/cpyright.htm" TARGET="_top">&#169; 1997 Microsoft Corporation. All rights reserved. Terms of Use.</A>
<!-- END PAGE FOOTER -->
</BLOCKQUOTE>
</BODY>
</HTML>