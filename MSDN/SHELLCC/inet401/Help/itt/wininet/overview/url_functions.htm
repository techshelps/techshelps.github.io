<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Handling Uniform Resource Locators</TITLE>

<META NAME=MS-HKWD CONTENT="Handling Uniform Resource Locators">
<META NAME="Keywords" CONTENT="Internet Tools & Technologies">
<META NAME="Platform" CONTENT="Windows, Win95, WinNT, Mac">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=iso8859-1">
<META NAME="MS.LOCALE" CONTENT="EN-US">
<META NAME="ROBOTS" CONTENT="all">


<SCRIPT>
//<!--
var g_isIE = false, g_isNav = false, g_iMaj = 0, g_sPlat = "";
// -->
</SCRIPT>
<SCRIPT SRC="../../../code/ver.js"></SCRIPT>


<SCRIPT DEFER SRC="../../../code/common.js"></SCRIPT>
<SCRIPT DEFER>
//<!--
function InitPage()
{
	if (g_isIE && g_iMaj >= 4)	
	{
		SetTOC();
	}
}
//-->
</SCRIPT>

<LINK REL="stylesheet" HREF="/msdn/sdk/inetsdk/help/basicsdkIE4.css" TYPE="text/css">
<!-- STYLE_START -->


<SCRIPT>
//<!--
   var sVR = '../../../'	// Set root for the style sheet
   var sCSS = '<LINK REL="stylesheet" HREF="' + sVR;

   if(g_isIE)
   {
	   if (g_iMaj >= 4) // For MSIE 4.0 or later
	   {
		   sCSS += 'basicSDKIE4';
		   if (g_sPlat == "Win") // Windows only for now
		   {
			   document.createStyleSheet(sVR + 'advSDKIE4.css');
		   }
	   }
	   else // For MSIE 3.0 or earlier
	   {
		   sCSS += 'basicSDKIE3';
	   }
   }
   else if (g_isNav) // For all Nav versions
   {
	   sCSS += 'basicSDKNAV';
   }
   else
   {
	   sCSS += 'basicSDKIE3'; // default to IE3 sheet
   }

   sCSS += (sCSS == '' ? '' : '.css" TYPE="text/css">');

   document.write(sCSS);
//-->
</SCRIPT>
<!-- STYLE_END -->
</HEAD>
<BODY onload="InitPage()" BGCOLOR="#FFFFFF">

<A NAME="pagetop"></A><A NAME="Handling_URL"></A>
<!-- NAV_LINKS_START -->
<TABLE class=main BORDER=0 CELLSPACING="0" CELLPADDING="0" WIDTH="10%"><TR><TD ROWSPAN="3" VALIGN="TOP" WIDTH="121"><IMG SRC="../../../art/headbar2.gif" WIDTH="121" HEIGHT="82" BORDER=0 ALT="Handling Uniform Resource Locators"></TD><TD ROWSPAN="2" VALIGN="TOP" WIDTH="186"><IMG SRC="../../../art/headbard.gif" WIDTH="186" HEIGHT="44" BORDER=0 ALT="Handling Uniform Resource Locators"></TD><TD VALIGN="TOP" WIDTH="470"><IMG SRC="../../../art/replace1.gif" WIDTH="470" HEIGHT="17" BORDER=0 ALT="*"></TD></TR>
<TR><TD><PRE><IMG SRC="../../../art/arrowrht.gif" WIDTH="14" HEIGHT="14" ALIGN="MIDDLE" BORDER=0 ALT="*"><object id="hhal_1" type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Item1" value="">
<PARAM name="Item2" value=_win32_Contents>
</object><A STYLE="color:black" ID=TOC HREF=JavaScript:hhal_1.Click()>Contents</A>  <IMG SRC="../../../art/arrowrht.gif" WIDTH="14" HEIGHT="14" ALIGN="MIDDLE" BORDER=0 ALT="*"><object id="hhal_2" type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Item1" value="">
<PARAM name="Item2" value=_win32_Index_1sz1>
</object><A STYLE="color:black" HREF=JavaScript:hhal_2.Click()>Index</A>  <IMG SRC="../../../art/arrowrht.gif" WIDTH="14" HEIGHT="14" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black" HREF="introduction.htm#ch_winineto">Topic Contents</A></PRE></TD></TR>
<TR><TD COLSPAN="2"><PRE><IMG SRC="../../../art/arrowlft.gif" WIDTH="17" HEIGHT="15" ALIGN="MIDDLE" BORDER=0 ALT="*"><B>Previous Topic:</B> <A STYLE="color:black" HREF="common.htm">Common Functions</A>
<IMG SRC="../../../art/arrownxt.gif" WIDTH="17" HEIGHT="16" ALIGN="MIDDLE" BORDER=0 ALT="*"><B>Next Topic:</B> <A  STYLE="color:black" HREF="authentication.htm">Handling Authentication</A></PRE></TD></TR>
</TABLE>
<!-- NAV_LINKS_END -->
<BLOCKQUOTE class="body">
<!-- CONTENTS_START -->
<H1>Handling Uniform Resource Locators</H1>

<P>A Uniform Resource Locator (URL) is a compact representation of the location and access method for a resource located on the Internet. Each URL consists of a scheme (HTTP, HTTPS, FTP, or Gopher) and a scheme-specific string. This string can also include a combination of a directory path, search string, or name of the resource. The Win32 Internet functions provide the ability to create, combine, break down, and canonicalize URLs. For more information on URLs, see RFC 1738, Uniform Resource Locators (URL). This document can be found at <A HREF="http://ds.internic.net/rfc/rfc1738.txt" TARGET="_top">http://ds.internic.net/rfc/rfc1738.txt</A>.<IMG SRC="../../../art/external.gif" WIDTH="19" HEIGHT="8" ALT="External link" >

<P>The URL functions operate in a task-oriented manner. The content and format of the URL that is given to the function is not verified. The calling application should track the use of these functions to ensure that the data is in the intended format. For example, the <A HREF="../functions/InternetCanonicalizeUrl.htm#InternetCanonicalizeUrl">InternetCanonicalizeUrl</A> function would convert the character "%" into the escape sequence "%25" when using no flags. If <B>InternetCanonicalizeUrl</B> is used on the canonicalized URL, the escape sequence "%25" would be converted into the escape sequence "%2525", which would not work properly.

<P>The following table summarizes the URL functions in the Win32 Internet API.

<TABLE>
<TR><TD><B>Function
 </B></TD><TD><B>Description
</B></TD></TR>
<TR><TD><A HREF="../functions/InternetCanonicalizeUrl.htm#InternetCanonicalizeUrl">InternetCanonicalizeUrl</A></TD><TD>Canonicalizes the URL that is passed to the function. By default, <A HREF="../functions/InternetCanonicalizeUrl.htm#InternetCanonicalizeUrl">InternetCanonicalizeUrl</A> always encodes.
</TD></TR>
<TR><TD><A HREF="../functions/InternetCombineUrl.htm#InternetCombineUrl">InternetCombineUrl</A></TD><TD>Combines base and relative URLs into one complete URL.
</TD></TR>
<TR><TD><A HREF="../functions/InternetCrackUrl.htm#InternetCrackUrl">InternetCrackUrl</A></TD><TD>Breaks the URL into its component parts. This information is returned in a <A HREF="../structures/URL_COMPONENTS.htm#URL_COMPONENTS">URL_COMPONENTS</A> structure.
</TD></TR>
<TR><TD><A HREF="../functions/InternetCreateUrl.htm#InternetCreateUrl">InternetCreateUrl</A></TD><TD>Allows an application to create a complete URL from its component parts.
</TD></TR>
<TR><TD><A HREF="../functions/InternetOpenUrl.htm#InternetOpenUrl">InternetOpenUrl</A></TD><TD>Locates the resource designated by a canonicalized URL and creates a handle, which can be used by <A HREF="../functions/InternetReadFile.htm#InternetReadFile">InternetReadFile</A> to retrieve that resource. <A HREF="../functions/InternetOpenUrl.htm#InternetOpenUrl">InternetOpenUrl</A> combines the tasks normally performed by <A HREF="../functions/InternetConnect.htm#InternetConnect">InternetConnect</A> with the operations handled by <A HREF="../functions/FtpOpenFile.htm#FtpOpenFile">FtpOpenFile</A>, <A HREF="../functions/GopherOpenFile.htm#GopherOpenFile">GopherOpenFile</A>, and <A HREF="../functions/HttpOpenRequest.htm#HttpOpenRequest">HttpOpenRequest</A>.</TD></TR></TABLE>
<H2><A NAME="What_Canon_URL">What Is a Canonicalized URL?</A></H2>
<P>The format of all URLs must follow the accepted syntax and semantics in order to access resources via the Internet. Canonicalization is the process of formatting a URL to follow this accepted syntax and semantics.

<P>Characters that must be encoded include any characters that have no corresponding graphic character in the US-ASCII coded character set (hexadecimal 80-FF, which are not used in the US-ASCII coded character set, and hexadecimal 00-1F and 7F, which are control characters), blank spaces, "%" (which is used to encode other characters), and unsafe characters (&lt;, &gt;, ", #, {, }, |, \, ^, ~, [, ], and ').



<H2><A NAME="Using_the_Win32_Inte">Using the Win32 Internet Functions to Handle URLs</A></H2>
<P>The following table summarizes the URL functions included with the Win32 Internet functions. 

<TABLE>
<TR><TD><B>Function
 </B></TD><TD><B>Description
</B></TD></TR>
<TR><TD><A HREF="../functions/InternetCanonicalizeUrl.htm#InternetCanonicalizeUrl">InternetCanonicalizeUrl</A> </TD><TD>Canonicalizes the URL.</TD></TR>
<TR><TD><A HREF="../functions/InternetCombineUrl.htm#InternetCombineUrl">InternetCombineUrl</A> </TD><TD>Combines base and relative URLs.</TD></TR>
<TR><TD><A HREF="../functions/InternetCrackUrl.htm#InternetCrackUrl">InternetCrackUrl</A> </TD><TD>Parses a URL string into components.</TD></TR>
<TR><TD><A HREF="../functions/InternetCreateUrl.htm#InternetCreateUrl">InternetCreateUrl</A> </TD><TD>Creates a URL string from components.</TD></TR>
<TR><TD><A HREF="../functions/InternetOpenUrl.htm#InternetOpenUrl">InternetOpenUrl</A> </TD><TD>Begins retrieving an FTP, Gopher, HTTP, or HTTPS resource.</TD></TR></TABLE>
<H3><A NAME="Canon_URL">Canonicalizing URLs</A></H3>
<P>Canonicalizing a URL is the process that converts a URL (that might contain unsafe characters such as blank spaces, reserved characters, and so on) into an accepted format.

<P>The <A HREF="../functions/InternetCanonicalizeUrl.htm#InternetCanonicalizeUrl">InternetCanonicalizeUrl</A> function can be used to canonicalize URLs. This function is very task-oriented, so the application should track its use carefully. <B>InternetCanonicalizeUrl</B> does not verify that the URL passed to it is already canonicalized and that the URL that it returns is valid.

<P>The following five flags control how <A HREF="../functions/InternetCanonicalizeUrl.htm#InternetCanonicalizeUrl">InternetCanonicalizeUrl</A> handles a particular URL. The flags can be used in combination. If no flags are used, the function encodes the URL by default.

<TABLE>
<TR><TD><B>Value
 </B></TD><TD><B>Meaning
</B></TD></TR>
<TR><TD>ICU_BROWSER_MODE </TD><TD>Do not encode or decode characters after "#" or "?", and do not remove trailing white space after "?". If this value is not specified, the entire URL is encoded, and trailing white space is removed.</TD></TR>
<TR><TD>ICU_DECODE </TD><TD>Convert all %XX sequences to characters, including escape sequences, before the URL is parsed.</TD></TR>
<TR><TD>ICU_ENCODE_SPACES_ONLY </TD><TD>Encode spaces only.</TD></TR>
<TR><TD>ICU_NO_ENCODE </TD><TD>Do not convert unsafe characters to escape sequences.</TD></TR>
<TR><TD>ICU_NO_META </TD><TD>Do not remove meta sequences (such as "." and "..") from the URL.</TD></TR></TABLE>
<P>The ICU_DECODE flag should be used only on canonicalized URLs, because it assumes that all %XX sequences are escape codes and converts them into the characters indicated by the code. If the URL has a "%" symbol in it that is not part of an escape code, ICU_DECODE still treats it as one. This characteristic might cause <A HREF="../functions/InternetCanonicalizeUrl.htm#InternetCanonicalizeUrl">InternetCanonicalizeUrl</A> to create an invalid URL. 

<P>To use <A HREF="../functions/InternetCanonicalizeUrl.htm#InternetCanonicalizeUrl">InternetCanonicalizeUrl</A> to return a completely decoded URL, the ICU_DECODE and ICU_NO_ENCODE flags must be specified. This setup assumes that the URL being passed to <B>InternetCanonicalizeUrl</B> has been previously canonicalized.



<H3><A NAME="Combining_URL">Combining base and relative URLs</A></H3>
<P>A relative URL is a compact representation of the location of a resource relative to an absolute base URL. The base URL must be known to the parser and usually includes the scheme, network location, and parts of the URL path. An application can call <A HREF="../functions/InternetCombineUrl.htm#InternetCombineUrl">InternetCombineUrl</A> to combine the relative URL with its base URL. <B>InternetCombineUrl</B> will also canonicalize the resultant URL.



<H3><A NAME="Cracking_URL">Cracking URLs</A></H3>
<P>The <A HREF="../functions/InternetCrackUrl.htm#InternetCrackUrl">InternetCrackUrl</A> function separates a URL into its component parts and returns the components indicated by the <A HREF="../structures/URL_COMPONENTS.htm#URL_COMPONENTS">URL_COMPONENTS</A> structure that is passed to the function.

<P>The components that make up the <A HREF="../structures/URL_COMPONENTS.htm#URL_COMPONENTS">URL_COMPONENTS</A> structure are the scheme number, host name, port number, user name, password, URL path, and additional information (such as search parameters). Each component, except the scheme and port numbers, has a string member that holds the information and a member that holds the length of the string member. The scheme and port numbers have only a member that stores the corresponding value; they are both returned on all successful calls to <A HREF="../functions/InternetCrackUrl.htm#InternetCrackUrl">InternetCrackUrl</A>.

<P>To get the value of a particular component in the <A HREF="../structures/URL_COMPONENTS.htm#URL_COMPONENTS">URL_COMPONENTS</A> structure, the member that stores the string length of that component must be set to a nonzero value. The string member can be either the address of a buffer or NULL.

<P>If the pointer member contains the address of a buffer, the string length member must contain the size of that buffer. <A HREF="../functions/InternetCrackUrl.htm#InternetCrackUrl">InternetCrackUrl</A> returns the component information as a string in the buffer and stores the string length in the string length member. 

<P>If the pointer member is set to NULL, the string length member can be set to any nonzero value. <A HREF="../functions/InternetCrackUrl.htm#InternetCrackUrl">InternetCrackUrl</A> stores the address of the first character of the URL string that contains the component information and sets the string length to the number of characters in the remaining part of the URL string that pertains to the component. 

<P>All pointer members set to NULL with a nonzero length member point to the appropriate starting point in the URL string. The length stored in the length member must be used to determine the end of the individual component's information.

<P>To finish initializing the <A HREF="../structures/URL_COMPONENTS.htm#URL_COMPONENTS">URL_COMPONENTS</A> structure properly, the <B>dwStructSize</B> member must be set to the size of the <B>URL_COMPONENTS</B> structure.

<P>The following example returns the components of the URL in the edit box, IDC_PreOpen1, and returns the components to the list box, IDC_PreOpenList. To display only the information for an individual component, this function copies the character immediately after the component's information in the string and temporarily replaces it with a NULL.

<PRE>int WINAPI Cracker(HWND hX)
{
    URL_COMPONENTS urlcmpTheUrl;
    int intTestSize = 80;
    LPSTR lpszUrlIn;
    LPURL_COMPONENTS lpUrlComp = &amp;urlcmpTheUrl;
    char TempOut[256];
    char tempChar;

    lpszUrlIn = new char[intTestSize];
    GetDlgItemText(hX,IDC_PreOpen1,lpszUrlIn,intTestSize);
    SendDlgItemMessage(hX,IDC_PreOpenList,LB_RESETCONTENT,0,0);
    urlcmpTheUrl.dwStructSize = sizeof(urlcmpTheUrl);

    urlcmpTheUrl.lpszScheme = NULL;
    urlcmpTheUrl.lpszHostName = NULL;
    urlcmpTheUrl.lpszUserName = NULL;
    urlcmpTheUrl.lpszPassword = NULL;
    urlcmpTheUrl.lpszUrlPath = NULL;
    urlcmpTheUrl.lpszExtraInfo = NULL;
    
    /* the following lines set which components will be displayed */
    urlcmpTheUrl.dwSchemeLength = 1;
    urlcmpTheUrl.dwHostNameLength = 1;
    urlcmpTheUrl.dwUserNameLength = 1;
    urlcmpTheUrl.dwPasswordLength = 1;
    urlcmpTheUrl.dwUrlPathLength = 1;
    urlcmpTheUrl.dwExtraInfoLength = 1;

    if (!InternetCrackUrl(lpszUrlIn,strlen(lpszUrlIn),0, lpUrlComp))
    {
        ErrorOut(hX,GetLastError(),"Cracker");
        return FALSE;
    }
    else
    {
        if (urlcmpTheUrl.dwSchemeLength != 0)
        {
            tempChar = urlcmpTheUrl.lpszScheme[urlcmpTheUrl.dwSchemeLength];
            urlcmpTheUrl.lpszScheme[urlcmpTheUrl.dwSchemeLength]='\0';
            sprintf(TempOut, "Scheme: %s", urlcmpTheUrl.lpszScheme);
            SendDlgItemMessage(hX,IDC_PreOpenList,LB_ADDSTRING,0,
                (LPARAM)TempOut);
            urlcmpTheUrl.lpszScheme[urlcmpTheUrl.dwSchemeLength]= tempChar;
        }

        sprintf(TempOut, "Scheme number: %d", urlcmpTheUrl.nScheme);
        SendDlgItemMessage(hX,IDC_PreOpenList,LB_ADDSTRING,0,
            (LPARAM)TempOut);

        if (urlcmpTheUrl.dwHostNameLength != 0)
        {
            tempChar = urlcmpTheUrl.lpszHostName[urlcmpTheUrl.dwHostNameLength];
            urlcmpTheUrl.lpszHostName[urlcmpTheUrl.dwHostNameLength] = '\0';
            sprintf(TempOut, "Host Name: %s", urlcmpTheUrl.lpszHostName);
            SendDlgItemMessage(hX,IDC_PreOpenList,LB_ADDSTRING,0,
                (LPARAM)TempOut);
            urlcmpTheUrl.lpszHostName[urlcmpTheUrl.dwHostNameLength] = tempChar;
        }
        
        sprintf(TempOut, "Port Number: %d", urlcmpTheUrl.nPort);
        SendDlgItemMessage(hX,IDC_PreOpenList,LB_ADDSTRING,0,
            (LPARAM)TempOut);
        
        if (urlcmpTheUrl.dwUserNameLength != 0)
        {
            tempChar = urlcmpTheUrl.lpszUserName[urlcmpTheUrl.dwUserNameLength];
            urlcmpTheUrl.lpszUserName[urlcmpTheUrl.dwUserNameLength] = '\0';
            sprintf(TempOut, "User Name: %s", urlcmpTheUrl.lpszUserName);
            SendDlgItemMessage(hX,IDC_PreOpenList,LB_ADDSTRING,0,
                (LPARAM)TempOut);
            urlcmpTheUrl.lpszUserName[urlcmpTheUrl.dwUserNameLength] = tempChar;
        }
        
        if (urlcmpTheUrl.dwPasswordLength != 0)
        {
            tempChar= urlcmpTheUrl.lpszPassword[urlcmpTheUrl.dwPasswordLength];
            urlcmpTheUrl.lpszPassword[urlcmpTheUrl.dwPasswordLength] = '\0';
            sprintf(TempOut, "Password: %s", urlcmpTheUrl.lpszPassword);
            SendDlgItemMessage(hX,IDC_PreOpenList,LB_ADDSTRING,0,
                (LPARAM)TempOut);
            urlcmpTheUrl.lpszPassword[urlcmpTheUrl.dwPasswordLength] = tempChar;
        }

        if (urlcmpTheUrl.dwUrlPathLength != 0)
        {
            tempChar=urlcmpTheUrl.lpszUrlPath[urlcmpTheUrl.dwUrlPathLength];
            urlcmpTheUrl.lpszUrlPath[urlcmpTheUrl.dwUrlPathLength] = '\0';
            sprintf(TempOut, "Path: %s", urlcmpTheUrl.lpszUrlPath);
            SendDlgItemMessage(hX,IDC_PreOpenList,LB_ADDSTRING,0,
                (LPARAM)TempOut);
            urlcmpTheUrl.lpszUrlPath[urlcmpTheUrl.dwUrlPathLength] = tempChar;
        }

        if(urlcmpTheUrl.dwExtraInfoLength != 0)
        {
            tempChar = urlcmpTheUrl.lpszExtraInfo[urlcmpTheUrl.dwExtraInfoLength];
            urlcmpTheUrl.lpszExtraInfo[urlcmpTheUrl.dwExtraInfoLength] = '\0';
            sprintf(TempOut, "Extra: %s", urlcmpTheUrl.lpszExtraInfo);
            SendDlgItemMessage(hX,IDC_PreOpenList,LB_ADDSTRING,0,
                (LPARAM)TempOut);
            urlcmpTheUrl.lpszExtraInfo[urlcmpTheUrl.dwExtraInfoLength] = tempChar;
        }

        return TRUE;
    }
}
</PRE>
<H3><A NAME="Creating_URL">Creating URLs</A></H3>
<P>The <A HREF="../functions/InternetCreateUrl.htm#InternetCreateUrl">InternetCreateUrl</A> function uses the information in the <A HREF="../structures/URL_COMPONENTS.htm#URL_COMPONENTS">URL_COMPONENTS</A> structure to create a Uniform Resource Locator.

<P>The components that make up the <A HREF="../structures/URL_COMPONENTS.htm#URL_COMPONENTS">URL_COMPONENTS</A> structure are the scheme, host name, port number, user name, password, URL path, and additional information (such as search parameters). Each component, except the port number, has a string member that holds the information and a member that holds the length of the string member. 

<P>For each required component, the pointer member should contain the address of the buffer holding the information. The length member should be set to zero if the pointer member contains the address of a zero-terminated string; the length member should be set to the string length if the pointer member contains the address of a string that is not zero-terminated. The pointer member of any components that are not required must be set to NULL. 



<H3><A NAME="Direct_Access">Accessing URLs directly</A></H3>
<P>Gopher, FTP, and HTTP resources on the Internet can be accessed directly by using the <A HREF="../functions/InternetOpenUrl.htm#InternetOpenUrl">InternetOpenUrl</A>, <A HREF="../functions/InternetReadFile.htm#InternetReadFile">InternetReadFile</A>, and <A HREF="../functions/InternetFindNextFile.htm#InternetFindNextFile">InternetFindNextFile</A> functions. <B>InternetOpenUrl</B> opens a connection to the resource at the URL passed to the function. When this connection is made, there are two possible steps. First, if the resource is a file, <B>InternetReadFile</B> can download it; second, if the resource is a directory, <B>InternetFindNextFile</B> can enumerate the files within the directory (except when using CERN proxies). For more information on <B>InternetReadFile</B>, see <A HREF="common.htm#Read_File">Reading files</A>. For more information on <B>InternetFindNextFile</B>, see <A HREF="common.htm#Next_File">Finding the next file</A>.

<P>For applications that need to operate through a CERN proxy, <A HREF="../functions/InternetOpenUrl.htm#InternetOpenUrl">InternetOpenUrl</A> can be used to access FTP directories and files. The FTP requests are packaged to appear like an HTTP request, which the CERN proxy would accept.

<P><A HREF="../functions/InternetOpenUrl.htm#InternetOpenUrl">InternetOpenUrl</A> uses the HINTERNET handle created by the <A HREF="../functions/InternetOpen.htm#InternetOpen">InternetOpen</A> function and the URL of the resource. The URL must include the scheme ("http:", "ftp:", "gopher:", "file:" [for a local file], or "https:" [for hypertext protocol secure]) and network location (such as "www.microsoft.com"). The URL can also include a path (for example, "/windows/feature/") and resource name (for example, "default.htm"). For HTTP or HTTPS requests, additional headers can be included.

<P><A HREF="../functions/InternetQueryDataAvailable.htm#InternetQueryDataAva">InternetQueryDataAvailable</A>, <A HREF="../functions/InternetFindNextFile.htm#InternetFindNextFile">InternetFindNextFile</A>, <A HREF="../functions/InternetReadFile.htm#InternetReadFile">InternetReadFile</A>, and <A HREF="../functions/InternetSetFilePointer.htm#InternetSetFilePoint">InternetSetFilePointer</A> (HTTP or HTTPS URLs only) can use the handle that is created by <A HREF="../functions/InternetOpenUrl.htm#InternetOpenUrl">InternetOpenUrl</A> to download the resource.

<P>The following diagram illustrates what handles to use with each function.

<P>
<P><IMG SRC="../../../art/AX_WNT02.gif" WIDTH="175" HEIGHT="140" ALT="Handles to use with functions" >
<P>
 
<P>The root HINTERNET handle created by <A HREF="../functions/InternetOpen.htm#InternetOpen">InternetOpen</A> is used by <A HREF="../functions/InternetOpenUrl.htm#InternetOpenUrl">InternetOpenUrl</A>. The HINTERNET handle created by <B>InternetOpenUrl</B> can be used by <A HREF="../functions/InternetQueryDataAvailable.htm#InternetQueryDataAva">InternetQueryDataAvailable</A>, <A HREF="../functions/InternetReadFile.htm#InternetReadFile">InternetReadFile</A>, <A HREF="../functions/InternetFindNextFile.htm#InternetFindNextFile">InternetFindNextFile</A> (not shown here), and <A HREF="../functions/InternetSetFilePointer.htm#InternetSetFilePoint">InternetSetFilePointer</A> (HTTP or HTTPS URLs only).

<P>For more information about HINTERNET handles and the handle hierarchy, see <A HREF="appendix_a.htm#HINTERNET">Appendix A: HINTERNET Handles</A>.

<P>The following example connects to the resource by using the <A HREF="../functions/InternetOpenUrl.htm#InternetOpenUrl">InternetOpenUrl</A> function. The sample function then uses the <A HREF="../functions/InternetReadFile.htm#InternetReadFile">InternetReadFile</A> function to download the resource. The function displays the downloaded resource in the edit box indicated by intCtrlID.

<!-- ************************ BRADYA: BEGIN UPDATE ************************ -->
<PRE>int WINAPI UrlDump(HWND hX, int intCtrlID)
{
    
     HINTERNET hUrlDump;
     DWORD dwSize=TRUE;
     LPSTR lpszData;
     LPSTR lpszOutPut;
     LPSTR lpszHolding;
     int nCounter=1;
     int nBufferSize;
     DWORD BigSize=8000;

     hUrlDump = InternetOpenUrl(hRootHandle, "server.name", NULL, NULL, 
        INTERNET_FLAG_RAW_DATA, 0);

     do
     {
          // Allocate the buffer
          lpszData =new char[BigSize+1];

          // Read the data
          if(!InternetReadFile(hUrlDump,(LPVOID)lpszData,BigSize,&amp;dwSize))
          {
               ErrorOut(hX,GetLastError(),"InternetReadFile");
               delete []lpszData;
               break;
          }
          else
          {
               // Add a null terminator to the end of the buffer
               lpszData[dwSize]='\0';

               // Check if all of the data has been read.  This should never
               // get called on the first time through the loop.
               if (dwSize == 0)
               {
                    // Write the final data to the textbox
                    SetDlgItemText(hX,intCtrlID,lpszHolding);

                    // Delete the existing buffers.
                    delete [] lpszData;
                    delete [] lpszHolding;
                    break;
               }

               // Determine the buffer size to hold the new data and the data
               // already written to the textbox (if any).
               nBufferSize = (nCounter*BigSize)+1;

               // Increment the number of buffers read
               nCounter++;               

               // Allocate the output buffer
               lpszOutPut = new char[nBufferSize];


               // Make sure the buffer is not the initial buffer
               if(nBufferSize != int(BigSize+1))
               {
                    // Copy the data in the holding buffer
                    strcpy(lpszOutPut,lpszHolding);

                    // Concatenate the new buffer with the output buffer
                    strcat(lpszOutPut,lpszData);
     
                    // Delete the holding buffer
                    delete [] lpszHolding;
               }
               else
               {
                    // Copy the data buffer
                    strcpy(lpszOutPut, lpszData);
               }


               // Allocate a holding buffer
               lpszHolding = new char[nBufferSize]; 

               // Copy the output buffer into the holding buffer
               memcpy(lpszHolding,lpszOutPut,nBufferSize);

               // Delete the other buffers
               delete [] lpszData;
               delete [] lpszOutPut;

          }

     }
     while (TRUE);

     // Close the HINTERNET handle
     InternetCloseHandle(hUrlDump);

     // Set the cursor back to an arrow
     SetCursor(LoadCursor(NULL,IDC_ARROW));

     // Return
     return TRUE;
}
</PRE>
<!-- ************************ BRADYA: BEGIN UPDATE ************************ --><!-- CONTENTS_END -->
<!-- START PAGE FOOTER -->
<H6><HR size=1></H6>
<P><A ID=line HREF="#pagetop"><IMG src="../../../art/arrowup1.gif" WIDTH="17" HEIGHT="16" ALIGN="MIDDLE" BORDER="0" ALT="Up">&nbsp;Top of Page</A>
<BR><A ID=line HREF="http://www.microsoft.com/misc/cpyright.htm" TARGET="_top">&#169; 1997 Microsoft Corporation. All rights reserved. Terms of Use.</A>
<!-- END PAGE FOOTER -->
</BLOCKQUOTE>
</BODY>
</HTML>