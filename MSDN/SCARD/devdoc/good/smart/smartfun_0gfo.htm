<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SCardTransmit</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_smart_scardtransmit"></a>SCardTransmit</h1>
<p>
The <b>SCardTransmit</b> function sends a service request to the smart card, and expects to receive data back from the card.</p>
<pre><code><b>LONG SCardTransmit(
</b>  <b>IN SCARDHANDLE</b><i> hCard</i><b>,</b>  
<b>  IN LPCSCARD_I0_REQUEST</b> <i>pioSendPci</i><b>,</b>
  <b>IN LPCBYTE</b> <i>pbSendBuffer</i><b>,</b>
  <b>IN DWORD</b> <i>cbSendLength</i><b>,</b>
  <b>IN OUT LPSCARD_IO_REQUEST</b> <i>pioRecvPci</i><b>,</b>
  <b>OUT LPBYTE</b> <i>pbRecvBuffer</i><b>,</b>
  <b>IN OUT LPDWORD</b> <i>pcbRecvLength</i>
<b>);</b>
 </code></pre>
<h4>Parameters</h4>
<dl>
<dt>
<i>hCard</i></dt>
<dd>
Supplies the reference value returned from <b>SCardConnect</b>.</dd>
<dt>
<i>pioSendPci</i></dt>
<dd>
Pointer to the protocol header structure for the instruction. This buffer is in the format of an SCARD_IO_REQUEST structure, followed by the specific protocol control information.
<p>
For the <a href="scgloss_7mwk.htm#_smart_t_0_protocol_gly">T=0</a>, <a href="scgloss_7mwk.htm#_smart_t_1_protocol_gly">T=1</a>, and Raw protocols, the PCI structure is constant. The smart card subsystem supplies a global T=0, T=1, or Raw PCI structure, which you can reference by using the symbols SCARD_PCI_T0, SCARD_PCI_T1, and SCARD_PCI_RAW respectively.
</dd>
<dt>
<i>pbSendBuffer</i></dt>
<dd>
Pointer to the actual data to be written to the card.

<p>
<b>T=0 Note</b>  For T=0, the data parameters are placed into the <i>pbSendBuffer</i> according to the following structure:


<pre><code>struct {
    BYTE
        bCla,   // The instruction class
        bIns,   // The instruction code 
        bP1,    // Parameter to the instruction
        bP2,    // Parameter to the instruction
        bP3;    // Size of I/O Transfer
} CmdBytes;
 </code></pre>

<p>
<b>Members</b> 

<dl>
<dt>
<b>bCla</b></dt>
<dd>
The T=0 instruction class</dd>
<dt>
<b>bIns</b></dt>
<dd>
An instruction code in the T=0 instruction class</dd>
<dt>
<b>bP1, bP2</b></dt>
<dd>
Reference codes completing the instruction code</dd>
<dt>
<b>bP3</b></dt>
<dd>
The number of data bytes which are to be transmitted during the command, per ISO 7816-4, Section 8.2.1.
</dd>
</dl>

<p>
The data sent to the card should immediately follow the send buffer. In the special case where no data is sent to the card and no data is expected in return, <b>bP3</b> is not sent.
</dd>
<dt>
<i>cbSendLength</i></dt>
<dd>
Supplies the length (in bytes)of the <i>pbSendBuffer</i> parameter.

<p>
<b>T=0 Note</b>  For T=0, in the special case where no data is sent to the card and no data expected in return, this length must reflect that the <b>bP3</b> member is not being sent: the length should be sizeof(CmdBytes) – sizeof(BYTE).

</dd>
<dt>
<i>pioRecvPci</i></dt>
<dd>
Pointer to the protocol header structure for the instruction, followed by a buffer in which to receive any returned protocol control information (PCI) specific to the protocol in use. This parameter may be NULL if no returned PCI is desired.</dd>
<dt>
<i>pbRecvBuffer</i></dt>
<dd>
Pointer to any data returned from the card.

<p>
<b>T=0 Note</b>  For T=0, the data is immediately followed by the SW1 and SW2 status bytes. If no data is returned from the card, then this buffer will only contain the SW1 and SW2 status bytes.

</dd>
<dt>
<i>pcbRecvLength</i></dt>
<dd>
Supplies the length of the <i>pbRecvBuffer</i> parameter (in bytes) and receives the actual number of bytes received from the smart card.

<p>
<b>T=0 Note</b>  For T=0, the receive buffer must be at least two bytes long, in order to receive the SW1 and SW2 status bytes.

</dd>
</dl>
<h4>Return Values</h4>
<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=48%>If the function…</th>
<th align=left width=52%>The return value is…</th>
</tr>
<tr valign=top>
<td width=48%>Succeeds</td>
<td width=52%>SCARD_S_SUCCESS.</td>
</tr>
<tr valign=top>
<td width=48%>Fails</td>
<td width=52%>An error code (see <a href="scerrors_39v7.htm">Error Codes</a> for a list of all error codes).</td>
</tr>
</table><br>
<h4>Remarks</h4>
<p>
<b>SCardTransmit</b> is a smart card and reader access function. For a description of other access functions, see <a href="scovr_9qpf.htm">Smart Card and Reader Access Functions</a>.</p>
<p>
<b>T=0 Protocol Remarks</b></p>
<p>
For the T=0 protocol, the data received back are the SW1 and SW2 status codes, possibly preceded by response data. The following paragraphs provide information on the send and receive buffers used to transfer data and issue a command.
<dl>
<dt>
<b>Sending Data to the Card</b></dt>
<dd>
To send <i>n</i> bytes of data to the card, where <i>n</i>&gt;0, the send and receive buffers must be formatted as follows.
<p>
The first four bytes of the <i>pbSendBuffer</i> buffer contain the CLA, INS, P1, and P2 values for the T=0 operation. The fifth byte shall be set to <i>n</i>: the size (in bytes) of the data to be transferred to the card. The next <i>n</i> bytes shall contain the data to be sent to the card.

<p>
The <i>cbSendLength</i> parameter shall be set to the size of the T=0 header information (CLA, INS, P1 and P2) plus a byte containing the length of the data to be transferred (<i>n</i>), plus the size of data to be sent. In this example, this is <i>n</i>+5.

<p>
The <i>pbRecvBuffer</i> will receive the SW1 and SW2 status codes from the operation.

<p>
The <i>pcbRecvLength</i> should be at least 2, and will be set to 2 upon return.
</dd>
<dt>
<b>Obtaining Data from the Card</b></dt>
<dd>
To receive <i>n</i>&gt;0 bytes of data from the card, the send and receive buffers must be formatted as follows.
<p>
The first four bytes of the <i>pbSendBuffer</i> buffer contain the CLA, INS, P1, and P2 values for the T=0 operation. The fifth byte shall be set to <i>n</i>: the size (in bytes) of the data to be transferred from the card. If 256 bytes are to be transferred from the card, then this byte shall be set to zero.

<p>
The <i>cbSendLength</i> parameter shall be set to 5, the size of the T=0 header information.

<p>
The <i>pbRecvBuffer</i> will receive the data returned from the card, immediately followed by the SW1 and SW2 status codes from the operation.

<p>
The <i>pcbRecvLength</i> should be at least <i>n</i>+2, and will be set to <i>n</i>+2 upon return.
</dd>
<dt>
<b>Issuing a Command Without Exchanging Data</b></dt>
<dd>
To issue a command to the card that does not involve the exchange of data (either sent or received), the send and receive buffers must be formatted as follows.
<p>
The <i>pbSendBuffer</i> buffer shall contain the CLA, INS, P1, and P2 values for the T=0 operation. The P3 value is not sent. (This is to differentiate the header from the case where 256 bytes are expected to be returned.)

<p>
The <i>cbSendLength</i> parameter shall be set to 4, the size of the T=0 header information (CLA, INS, P1, and P2).

<p>
The <i>pbRecvBuffer</i> will receive the SW1 and SW2 status codes from the operation.

<p>
The <i>pcbRecvLength</i> should be at least 2, and will be set to 2 upon return.

</dd>
</dl>
<h4>QuickInfo</h4>
<p>
&nbsp;&nbsp;<b>Windows NT:</b>  Use version 4.0 SP3 and later.<br>
&nbsp;&nbsp;<b>Windows:</b>  Use Windows 95 OSR2.1.<br>
&nbsp;&nbsp;<b>Windows CE:</b>  Unsupported.<br>
&nbsp;&nbsp;<b>Header:</b> Declared in winscard.h.<br>
&nbsp;&nbsp;<b>Import Library:</b> Link with winscard.lib.</p>
<h4>See Also</h4>
<p>
<a href="smartfun_8qlw.htm"><b>SCardConnect</b></a>, <a href="smartstr_6jas.htm"><b>SCARD_IO_REQUEST</b></a></p>
<p>
</p>
<p>&nbsp;</p></body>
</HTML>
