<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>OPENCARDNAME</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_smart_opencardname"></a>OPENCARDNAME</h1>
<p>
The <b>OPENCARDNAME</b> structure contains the information that the <a href="smartfun_4un9.htm"><b>GetOpenCardName</b></a> function uses to initialize a smart card common dialog. </p>
<pre><code>typedef struct tagOCNA {
    DWORD           dwStructSize;
    HWND            hwndOwner;
    SCARDCONTEXT    hSCardContext;
    LPTSTR          lpstrGroupNames;
    DWORD           nMaxGroupNames;
    LPTSTR          lpstrCardNames;
    DWORD           nMaxCardNames;
    LPGUID          rgguidInterfaces;
    DWORD           cguidInterfaces;
    LPTSTR          lpstrRdr;
    DWORD           nMaxRdr;
    LPTSTR          lpstrCard;
    DWORD           nMaxCard;
    LPCTSTR         lpstrTitle;
    DWORD           dwFlags;
    LPVOID          pvUserData;
    DWORD           dwShareMode;
    DWORD           dwPreferredProtocols;
    DWORD           dwActiveProtocol;
    LPOCNCONNPROCA  lpfnConnect;
    LPOCNCHKPROC    lpfnCheck;
    LPOCNDSCPROC    lpfnDisconnect;
    SCARDHANDLE     hCardHandle;
} OPENCARDNAME, *LPOPENCARDNAME;;
 </code></pre>
<h4>Members</h4>
<dl>
<dt>
<b>dwStructSize</b></dt>
<dd>
Specifies the length of the structure, in bytes. Must not be NULL.</dd>
<dt>
<b>hwndOwner</b></dt>
<dd>
Identifies the window that owns the dialog box. This member can be any valid window handle, or it can be NULL for desktop default.</dd>
<dt>
<b>hSCardContext</b></dt>
<dd>
Context used for communication with the smart card resource manager. Call <a href="smartfun_5t2s.htm"><b>SCardEstablishContext</b></a> to set the <a href="scgloss_7mwi.htm#_smart_resource_manager_context_gly">resource manager context</a> and <a href="smartfun_1cs4.htm"><b>SCardReleaseContext</b></a> to release it. Must not be NULL.</dd>
<dt>
<b>lpstrGroupNames</b></dt>
<dd>
Points to a buffer containing null-terminated group name strings. The last string in the buffer must be terminated by two NULL characters. Each string is the name of a group of cards that is to be included in the search. If <b>lpstrGroupNames</b> is NULL, the default group (<a href="scgloss_7mwj.htm#_smart_scard_defaultreaders_gly">Scard$DefaultReaders</a>) is searched. </dd>
<dt>
<b>nMaxGroupNames</b></dt>
<dd>
Maximum number of bytes (ANSI version) or characters (UNICODE version) in the <b>lpstrGroupNames</b> string.</dd>
<dt>
<b>lpstrCardNames</b></dt>
<dd>
Points to a buffer containing null-terminated card name strings. The last string in the buffer must be terminated by two NULL characters. Each string is the name of a card that is to be located. </dd>
<dt>
<b>nMaxCardNames</b></dt>
<dd>
Maximum number of bytes (ANSI version) or characters (UNICODE version) in the <b>lpstrCardNames</b> string.</dd>
<dt>
<b>rgguidInterfaces</b></dt>
<dd>
An array of GUIDs identifying the interfaces required. NULL for this release (RFU).</dd>
<dt>
<b>cguidInterfaces</b></dt>
<dd>
The number of interfaces in the <b>rgguidInterfaces</b> array. NULL for this release (RFU).</dd>
<dt>
<b>lpstrRdr</b></dt>
<dd>
If the card is located, the <b>lpstrRdr</b> buffer contains the name of the reader that contains the located card. The buffer should be at least 256 characters long.</dd>
<dt>
<b>nMaxRdr</b></dt>
<dd>
Specifies the size, in bytes (ANSI version) or characters (UNICODE version), of the buffer pointed to by <b>lpstrRdr</b>. If the buffer is too small to contain the reader information, <a href="smartfun_4un9.htm"><b>GetOpenCardName</b></a> returns SCARD_E_NO_MEMORY and the required size of the buffer pointed to by <b>lpstrRdr</b>.</dd>
<dt>
<b>lpstrCard</b></dt>
<dd>
If the card is located, the <b>lpstrCard</b> buffer contains the name of the located card. The buffer should be at least 256 characters long. </dd>
<dt>
<b>nMaxCard</b></dt>
<dd>
Specifies the size, in bytes (ANSI version) or characters (UNICODE version), of the buffer pointed to by <b>lpstrCard</b>. If the buffer is too small to contain the card information, <b>GetOpenCardName</b> returns SCARD_E_NO_MEMORY and the required size of the buffer in <b>nMaxCard</b>.</dd>
<dt>
<b>lpstrTitle</b></dt>
<dd>
Points to a string to be placed in the title bar of the dialog box. If this member is NULL, the system uses the default title (that is, "Select Card:").</dd>
<dt>
<b>dwFlags</b></dt>
<dd>
A set of bit flags you can use to initialize the dialog box. When the dialog box returns, it sets these flags to indicate the user's input. This member can be a combination of the following flags: 
<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=34%>Flag</th>
<th align=left width=66%>Meaning</th>
</tr>
<tr valign=top>
<td width=34%>SC_DLG_MINIMAL_UI</td>
<td width=66%>Displays the dialog only if the card being searched for by the calling application is not located and available for use in a reader. This allows the card to be found, connected (either through the internal dialog mechanism or the user callback functions), and returned to the calling application.</td>
</tr>
<tr valign=top>
<td width=34%>SC_DLG_NO_UI</td>
<td width=66%>Force no display of the common dialog UI, regardless of search outcome.</td>
</tr>
<tr valign=top>
<td width=34%>SC_DLG_FORCE_UI</td>
<td width=66%>Force display of the common dialog UI, regardless of the search outcome.</td>
</tr>
</table><br>

</dd>
<dt>
<b>pvUserData</b></dt>
<dd>
A void pointer to user data. This pointer is passed back to the caller on the <b>Connect</b>, <b>Check</b>, and <b>Disconnect</b> routines.</dd>
<dt>
<b>dwShareMode</b></dt>
<dd>
If <b>lpfnConnect</b> is not NULL, the <b>dwShareMode</b> and <b>dwProtocols</b> members are ignored. If <b>lpfnConnect</b> is NULL and <b>dwShareMode</b> is non-zero, then an internal call is made to <a href="smartfun_8qlw.htm"><b>SCardConnect</b></a> using <b>dwShareMode</b> and <b>dwProtocol</b> as the <i>dwShareMode</i> and <i>dwPreferredProtocols</i> parameters. If the connect succeeds, <b>hCardHandle</b> is set to the handle returned by <b>SCardConnect</b>. If <b>lpfnConnect</b> is NULL and <b>dwShareMode</b> is zero, the common dialog returns <b>hCardHandle</b> as NULL.</dd>
<dt>
<b>dwPreferredProtocols</b></dt>
<dd>
Used for internal connection as described in <b>dwShareMode</b>.</dd>
<dt>
<b>dwActiveProtocol</b></dt>
<dd>
Returns the actual protocol in use when the dialog makes a connection to a card.</dd>
<dt>
<b>lpfnConnect</b></dt>
<dd>
Pointer to the caller's card connect routine. If the caller needs to perform additional processing to connect to the card, this function pointer is set to the user's connect function. If the connect function is successful, the card is left connected and initialized, and the card handle is returned. 
<p>
The prototype for the connect routine is 
</dd>
</dl>
<pre><code><b>Connect(
</b>  <i>hSCardContext</i><b>,</b>  // the card context passed in the parameter block
  <i>szReader</i><b>,</b>       // the name of the reader
  <i>mszCards</i><b>,</b>       // multistring containing the possible card names in the reader
  <i>pvUserData</i>      // pointer to user data passed in parameter block
<b>);</b>
</code></pre>
<dl>
<dt>
<b>lpfnCheck</b></dt>
<dd>
Pointer to the caller's card verify routine. If no special card verification is required, this pointer is NULL. 
<p>
If the card is rejected by the verify routine, FALSE is returned and the card will be disconnected, as indicated by <b>lpfnDisconnect</b>. 

<p>
If the card is accepted by the verify routine, TRUE is returned. When the user accepts the card, all other cards currently connected will be disconnected, as indicated by <b>lpfnDisconnect</b>, and this card will be returned as the located card. The located card will remain connected.

<p>
The prototype for the check routine is 
</dd>
</dl>
<pre><code><b>Check(
</b>  <i>hSCardContext</i><b>,</b>  //  the card context passed in the parameter block
  <i>hCard</i><b>,</b>          //  card handle
  <i>pvUserData</i>      //  pointer to user data passed in the parameter block
<b>);</b></code></pre>
<dl>
<dt>
<b>lpfnDisconnect</b></dt>
<dd>
Pointer to the caller's card disconnect routine. 
<p>
The prototype for the disconnect routine is 
</dd>
</dl>
<pre><code><b>Disconnect(
</b>  <i>hSCardContext</i><b>,</b>  //  the card context passed in the parameter block
  <i>hCard</i><b>,</b>          //  card handle
  <i>pvUserData</i>      //  pointer to user data passed in the parameter block
<b>);</b></code></pre>
<p>
<b>Note</b>  When using <b>lpfnConnect</b>, <b>lpfnCheck</b>, and <b>lpfnDisconnect</b>, all three callback procedures should be present. Using these callbacks allows further verification that the calling application has found the appropriate card. This is the best way to ensure the appropriate card is selected.
<dl>
<dt>
<b>hCardHandle</b></dt>
<dd>
Handle of the connected card (either through an internal dialog connect or an <b>lpfnConnect</b> callback.)
</dd>
</dl>
<h4>See Also</h4>
<p>
<a href="scerrors_39v7.htm">Error Codes</a>, <a href="smartfun_4un9.htm"><b>GetOpenCardName</b></a>, <a href="smartfun_8qlw.htm"><b>SCardConnect</b></a>, <a href="smartfun_5t2s.htm"><b>SCardEstablishContext</b></a>, <a href="smartfun_1cs4.htm"><b>SCardReleaseContext</b></a> </p>
<p>&nbsp;</p></body>
</HTML>
