<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>GENERIC.C</title>
<link disabled rel=stylesheet href=../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context7"></a>GENERIC.C</h2>
<pre><code>//THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF <br>//ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO <br>//THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A <br>// PARTICULAR PURPOSE. <br>// <br>// Copyright 1994 - 1998 Microsoft Corporation.  All Rights Reserved. <br>// <br>// PROGRAM: Generic.c <br>// <br>// PURPOSE: Illustrates the 'minimum' functionality of a well-behaved Win32 application.. <br>// <br>// PLATFORMS:  Windows 95, Windows NT, Win32s <br>// <br>// FUNCTIONS: <br>//    WinMain() - calls initialization function, processes message loop <br>//    InitApplication() - Initializes window data nd registers window <br>//    InitInstance() -saves instance handle and creates main window <br>//    WindProc() Processes messages <br>//    About() - Process menssages for "About" dialog box <br>//    MyRegisterClass() - Registers the application's window class <br>//    CenterWindow() -  Centers one window over another <br>// <br>// SPECIAL INSTRUCTIONS: N/A <br>// <br>#define APPNAME "Generic" <br> <br>// Windows Header Files: <br>#include &lt;windows.h&gt; <br> <br>// C RunTime Header Files <br>#include &lt;stdlib.h&gt; <br>#include &lt;malloc.h&gt; <br>#include &lt;memory.h&gt; <br> <br>// Local Header Files <br>#include "generic.h" <br> <br>// Makes it easier to determine appropriate code paths: <br>#if defined (WIN32) <br>   #define IS_WIN32 TRUE <br>#else <br>   #define IS_WIN32 FALSE <br>#endif <br>#define IS_NT      IS_WIN32 &amp;&amp; (BOOL)(GetVersion() &lt; 0x80000000) <br>#define IS_WIN32S  IS_WIN32 &amp;&amp; (BOOL)(!(IS_NT) &amp;&amp; (LOBYTE(LOWORD(GetVersion()))&lt;4)) <br>#define IS_WIN95 (BOOL)(!(IS_NT) &amp;&amp; !(IS_WIN32S)) &amp;&amp; IS_WIN32 <br> <br>// Global Variables: <br> <br>HINSTANCE hInst;      // current instance <br>char szAppName[100];  // Name of the app <br>char szTitle[100];    // The title bar text <br> <br> <br>// Foward declarations of functions included in this code module: <br> <br>ATOM MyRegisterClass(CONST WNDCLASS*); <br>BOOL InitApplication(HINSTANCE); <br>BOOL InitInstance(HINSTANCE, int); <br>LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM); <br>LRESULT CALLBACK About(HWND, UINT, WPARAM, LPARAM); <br>BOOL CenterWindow (HWND, HWND); <br>LPTSTR   GetStringRes (int id); <br> <br> <br>// <br>//  FUNCTION: WinMain(HANDLE, HANDLE, LPSTR, int) <br>// <br>//  PURPOSE: Entry point for the application. <br>// <br>//  COMMENTS: <br>// <br>// This function initializes the application and processes the <br>// message loop. <br>// <br>int APIENTRY WinMain(HINSTANCE hInstance, <br>                     HINSTANCE hPrevInstance, <br>                     LPSTR     lpCmdLine, <br>                     int       nCmdShow) <br>{ <br>   MSG msg; <br>   HANDLE hAccelTable; <br> <br>   // Initialize global strings <br>   lstrcpy (szAppName, APPNAME); <br>   LoadString (hInstance, IDS_APP_TITLE, szTitle, 100); <br> <br> <br>   if (!hPrevInstance) { <br>      // Perform instance initialization: <br>      if (!InitApplication(hInstance)) { <br>         return (FALSE); <br>      } <br>   } <br> <br>   // Perform application initialization: <br>   if (!InitInstance(hInstance, nCmdShow)) { <br>      return (FALSE); <br>   } <br> <br>   hAccelTable = LoadAccelerators (hInstance, szAppName); <br> <br>   // Main message loop: <br>   while (GetMessage(&amp;msg, NULL, 0, 0)) { <br>      if (!TranslateAccelerator (msg.hwnd, hAccelTable, &amp;msg)) { <br>         TranslateMessage(&amp;msg); <br>         DispatchMessage(&amp;msg); <br>      } <br>   } <br> <br>   return (msg.wParam); <br> <br>   lpCmdLine; // This will prevent 'unused formal parameter' warnings <br>} <br> <br>// <br>//  FUNCTION: MyRegisterClass(CONST WNDCLASS*) <br>// <br>//  PURPOSE: Registers the window class. <br>// <br>//  COMMENTS: <br>// <br>//    This function and its usage is only necessary if you want this code <br>//    to be compatible with Win32 systems prior to the 'RegisterClassEx' <br>// function that was added to Windows 95. It is important to call this function <br>//    so that the application will get 'well formed' small icons associated <br>//    with it. <br>// <br>ATOM MyRegisterClass(CONST WNDCLASS *lpwc) <br>{ <br>   HANDLE  hMod; <br>   FARPROC proc; <br>   WNDCLASSEX wcex; <br> <br>   hMod = GetModuleHandle ("USER32"); <br>   if (hMod != NULL) { <br> <br>#if defined (UNICODE) <br>      proc = GetProcAddress (hMod, "RegisterClassExW"); <br>#else <br>      proc = GetProcAddress (hMod, "RegisterClassExA"); <br>#endif <br> <br>      if (proc != NULL) { <br> <br>         wcex.style         = lpwc-&gt;style; <br>         wcex.lpfnWndProc   = lpwc-&gt;lpfnWndProc; <br>         wcex.cbClsExtra    = lpwc-&gt;cbClsExtra; <br>         wcex.cbWndExtra    = lpwc-&gt;cbWndExtra; <br>         wcex.hInstance     = lpwc-&gt;hInstance; <br>         wcex.hIcon         = lpwc-&gt;hIcon; <br>         wcex.hCursor       = lpwc-&gt;hCursor; <br>         wcex.hbrBackground = lpwc-&gt;hbrBackground; <br>                     wcex.lpszMenuName  = lpwc-&gt;lpszMenuName; <br>         wcex.lpszClassName = lpwc-&gt;lpszClassName; <br> <br>         // Added elements for Windows 95: <br>         wcex.cbSize = sizeof(WNDCLASSEX); <br>         wcex.hIconSm = LoadIcon(wcex.hInstance, "SMALL"); <br> <br>         return (*proc)(&amp;wcex);//return RegisterClassEx(&amp;wcex); <br>      } <br>   } <br>   return (RegisterClass(lpwc)); <br>} <br> <br> <br>// <br>//  FUNCTION: InitApplication(HANDLE) <br>// <br>//  PURPOSE: Initializes window data and registers window class <br>// <br>//  COMMENTS: <br>// <br>//       In this function, we initialize a window class by filling out a data <br>//       structure of type WNDCLASS and calling either RegisterClass or <br>//       the internal MyRegisterClass. <br>// <br>BOOL InitApplication(HINSTANCE hInstance) <br>{ <br>    WNDCLASS  wc; <br>    HWND      hwnd; <br> <br>    // Win32 will always set hPrevInstance to NULL, so lets check <br>    // things a little closer. This is because we only want a single <br>    // version of this app to run at a time <br>    hwnd = FindWindow (szAppName, szTitle); <br>    if (hwnd) { <br>        // We found another version of ourself. Lets defer to it: <br>        if (IsIconic(hwnd)) { <br>            ShowWindow(hwnd, SW_RESTORE); <br>        } <br>        SetForegroundWindow (hwnd); <br> <br>        // If this app actually had any functionality, we would <br>        // also want to communicate any action that our 'twin' <br>        // should now perform based on how the user tried to <br>        // execute us. <br>        return FALSE; <br>        } <br> <br>        // Fill in window class structure with parameters that describe <br>        // the main window. <br>        wc.style         = CS_HREDRAW | CS_VREDRAW; <br>        wc.lpfnWndProc   = (WNDPROC)WndProc; <br>        wc.cbClsExtra    = 0; <br>        wc.cbWndExtra    = 0; <br>        wc.hInstance     = hInstance; <br>        wc.hIcon         = LoadIcon (hInstance, szAppName); <br>        wc.hCursor       = LoadCursor(NULL, IDC_ARROW); <br>        wc.hbrBackground = (HBRUSH)(COLOR_WINDOW+1); <br> <br>        // Since Windows95 has a slightly different recommended <br>        // format for the 'Help' menu, lets put this in the alternate menu like this: <br>        if (IS_WIN95) { <br>   wc.lpszMenuName  = "WIN95"; <br>        } else { <br>   wc.lpszMenuName  = szAppName; <br>        } <br>        wc.lpszClassName = szAppName; <br> <br>        // Register the window class and return success/failure code. <br>        if (IS_WIN95) { <br>   return MyRegisterClass(&amp;wc); <br>        } else { <br>   return RegisterClass(&amp;wc); <br>        } <br>} <br> <br>// <br>//   FUNCTION: InitInstance(HANDLE, int) <br>// <br>//   PURPOSE: Saves instance handle and creates main window <br>// <br>//   COMMENTS: <br>// <br>//        In this function, we save the instance handle in a global variable and <br>//        create and display the main program window. <br>// <br>BOOL InitInstance(HINSTANCE hInstance, int nCmdShow) <br>{ <br>   HWND hWnd; <br> <br>   hInst = hInstance; // Store instance handle in our global variable <br> <br>   hWnd = CreateWindow(szAppName, szTitle, WS_OVERLAPPEDWINDOW, <br>      CW_USEDEFAULT, 0, CW_USEDEFAULT, 0, <br>      NULL, NULL, hInstance, NULL); <br> <br>   if (!hWnd) { <br>      return (FALSE); <br>   } <br> <br>   ShowWindow(hWnd, nCmdShow); <br>   UpdateWindow(hWnd); <br> <br>   return (TRUE); <br>} <br> <br>// <br>//  FUNCTION: WndProc(HWND, unsigned, WORD, LONG) <br>// <br>//  PURPOSE:  Processes messages for the main window. <br>// <br>//  MESSAGES: <br>// <br>// WM_COMMAND - process the application menu <br>// WM_PAINT - Paint the main window <br>// WM_DESTROY - post a quit message and return <br>//    WM_DISPLAYCHANGE - message sent to Plug &amp; Play systems when the display changes <br>//    WM_RBUTTONDOWN - Right mouse click -- put up context menu here if appropriate <br>//    WM_NCRBUTTONUP - User has clicked the right button on the application's system menu <br>// <br>// <br>LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam) <br>{ <br>   int wmId, wmEvent; <br>   PAINTSTRUCT ps; <br>   HDC hdc; <br>      POINT pnt; <br>   HMENU hMenu; <br>      BOOL bGotHelp; <br> <br>   switch (message) { <br> <br>      case WM_COMMAND: <br>         wmId    = LOWORD(wParam); // Remember, these are... <br>         wmEvent = HIWORD(wParam); // ...different for Win32! <br> <br>         //Parse the menu selections: <br>         switch (wmId) { <br> <br>            case IDM_ABOUT: <br>               DialogBox(hInst, "AboutBox", hWnd, (DLGPROC)About); <br>               break; <br> <br>            case IDM_EXIT: <br>               DestroyWindow (hWnd); <br>               break; <br> <br>            case IDM_HELPTOPICS: // Only called in Windows 95 <br>               bGotHelp = WinHelp (hWnd, APPNAME".HLP", HELP_FINDER,(DWORD)0); <br>               if (!bGotHelp) <br>               { <br>                  MessageBox (GetFocus(), GetStringRes(IDS_NO_HELP), <br>                              szAppName, MB_OK|MB_ICONHAND); <br>               } <br>               break; <br> <br>            case IDM_HELPCONTENTS: // Not called in Windows 95 <br>               bGotHelp = WinHelp (hWnd, APPNAME".HLP", HELP_CONTENTS,(DWORD)0); <br>               if (!bGotHelp) <br>               { <br>                  MessageBox (GetFocus(), GetStringRes(IDS_NO_HELP), <br>                              szAppName, MB_OK|MB_ICONHAND); <br>               } <br>               break; <br> <br>            case IDM_HELPSEARCH: // Not called in Windows 95 <br>               if (!WinHelp(hWnd, APPNAME".HLP", HELP_PARTIALKEY, <br>                           (DWORD)(LPSTR)"")) <br>               { <br>                  MessageBox (GetFocus(), GetStringRes(IDS_NO_HELP), <br>                              szAppName, MB_OK|MB_ICONHAND); <br>               } <br>               break; <br> <br>            case IDM_HELPHELP: // Not called in Windows 95 <br>               if(!WinHelp(hWnd, (LPSTR)NULL, HELP_HELPONHELP, 0)) <br>               { <br>                  MessageBox (GetFocus(), GetStringRes(IDS_NO_HELP), <br>                              szAppName, MB_OK|MB_ICONHAND); <br>               } <br>               break; <br> <br>            // Here are all the other possible menu options, <br>            // all of these are currently disabled: <br>            case IDM_NEW: <br>            case IDM_OPEN: <br>            case IDM_SAVE: <br>            case IDM_SAVEAS: <br>            case IDM_UNDO: <br>            case IDM_CUT: <br>            case IDM_COPY: <br>            case IDM_PASTE: <br>            case IDM_LINK: <br>            case IDM_LINKS: <br> <br>            default: <br>               return (DefWindowProc(hWnd, message, wParam, lParam)); <br>         } <br>         break; <br> <br>      case WM_NCRBUTTONUP: // RightClick on windows non-client area... <br>         if (IS_WIN95 &amp;&amp; SendMessage(hWnd, WM_NCHITTEST, 0, lParam) == HTSYSMENU) <br>         { <br>            // The user has clicked the right button on the applications <br>            // 'System Menu'. Here is where you would alter the default <br>            // system menu to reflect your application. Notice how the <br>            // explorer deals with this. For this app, we aren't doing <br>            // anything <br>            return (DefWindowProc(hWnd, message, wParam, lParam)); <br>         } else { <br>            // Nothing we are interested in, allow default handling... <br>            return (DefWindowProc(hWnd, message, wParam, lParam)); <br>         } <br>            break; <br> <br>        case WM_RBUTTONDOWN: // RightClick in windows client area... <br>            pnt.x = LOWORD(lParam); <br>            pnt.y = HIWORD(lParam); <br>            ClientToScreen(hWnd, (LPPOINT) &amp;pnt); <br>      // This is where you would determine the appropriate 'context' <br>      // menu to bring up. Since this app has no real functionality, <br>      // we will just bring up the 'Help' menu: <br>            hMenu = GetSubMenu (GetMenu (hWnd), 2); <br>            if (hMenu) { <br>                TrackPopupMenu (hMenu, 0, pnt.x, pnt.y, 0, hWnd, NULL); <br>            } else { <br>            // Couldn't find the menu... <br>                MessageBeep(0); <br>            } <br>            break; <br> <br> <br>      case WM_DISPLAYCHANGE: // Only comes through on plug'n'play systems <br>      { <br>         SIZE  szScreen; <br>         DWORD dwBitsPerPixel = (DWORD)wParam; <br> <br>         szScreen.cx = LOWORD(lParam); <br>         szScreen.cy = HIWORD(lParam); <br> <br>         MessageBox (GetFocus(), GetStringRes(IDS_DISPLAYCHANGED), <br>                     szAppName, 0); <br>      } <br>      break; <br> <br>      case WM_PAINT: <br>         hdc = BeginPaint (hWnd, &amp;ps); <br>         // Add any drawing code here... <br>         EndPaint (hWnd, &amp;ps); <br>         break; <br> <br>      case WM_DESTROY: <br>         // Tell WinHelp we don't need it any more... <br>               WinHelp (hWnd, APPNAME".HLP", HELP_QUIT,(DWORD)0); <br>         PostQuitMessage(0); <br>         break; <br> <br>      default: <br>         return (DefWindowProc(hWnd, message, wParam, lParam)); <br>   } <br>   return (0); <br>} <br> <br>// <br>//  FUNCTION: About(HWND, unsigned, WORD, LONG) <br>// <br>//  PURPOSE:  Processes messages for "About" dialog box <br>//       This version allows greater flexibility over the contents of the 'About' box, <br>//       by pulling out values from the 'Version' resource. <br>// <br>//  MESSAGES: <br>// <br>// WM_INITDIALOG - initialize dialog box <br>// WM_COMMAND    - Input received <br>// <br>// <br>LRESULT CALLBACK About(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam) <br>{ <br>   static  HFONT hfontDlg;    // Font for dialog text <br>   static   HFONT hFinePrint; // Font for 'fine print' in dialog <br>   DWORD   dwVerInfoSize;     // Size of version information block <br>   LPSTR   lpVersion;         // String pointer to 'version' text <br>   DWORD   dwVerHnd=0;        // An 'ignored' parameter, always '0' <br>   UINT    uVersionLen; <br>   WORD    wRootLen; <br>   BOOL    bRetCode; <br>   int     i; <br>   char    szFullPath[256]; <br>   char    szResult[256]; <br>   char    szGetName[256]; <br>   DWORD dwVersion; <br>   char  szVersion[40]; <br>   DWORD dwResult; <br> <br>   switch (message) { <br>        case WM_INITDIALOG: <br>         ShowWindow (hDlg, SW_HIDE); <br> <br>         if (PRIMARYLANGID(GetUserDefaultLangID()) == LANG_JAPANESE) <br>         { <br>            hfontDlg = CreateFont(14, 0, 0, 0, 0, 0, 0, 0, SHIFTJIS_CHARSET, 0, 0, 0, <br>                                  VARIABLE_PITCH | FF_DONTCARE, ""); <br>            hFinePrint = CreateFont(11, 0, 0, 0, 0, 0, 0, 0, SHIFTJIS_CHARSET, 0, 0, 0, <br>                                    VARIABLE_PITCH | FF_DONTCARE, ""); <br>         } <br>         else <br>         { <br>            hfontDlg = CreateFont(14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, <br>                                  VARIABLE_PITCH | FF_SWISS, ""); <br>            hFinePrint = CreateFont(11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, <br>                                    VARIABLE_PITCH | FF_SWISS, ""); <br>         } <br> <br>         CenterWindow (hDlg, GetWindow (hDlg, GW_OWNER)); <br>         GetModuleFileName (hInst, szFullPath, sizeof(szFullPath)); <br> <br>         // Now lets dive in and pull out the version information: <br>         dwVerInfoSize = GetFileVersionInfoSize(szFullPath, &amp;dwVerHnd); <br>         if (dwVerInfoSize) { <br>            LPSTR   lpstrVffInfo; <br>            HANDLE  hMem; <br>            hMem = GlobalAlloc(GMEM_MOVEABLE, dwVerInfoSize); <br>            lpstrVffInfo  = GlobalLock(hMem); <br>            GetFileVersionInfo(szFullPath, dwVerHnd, dwVerInfoSize, lpstrVffInfo); <br>            // The below 'hex' value looks a little confusing, but <br>            // essentially what it is, is the hexidecimal representation <br>            // of a couple different values that represent the language <br>            // and character set that we are wanting string values for. <br>            // 040904E4 is a very common one, because it means: <br>            //   US English, Windows MultiLingual characterset <br>            // Or to pull it all apart: <br>            // 04------        = SUBLANG_ENGLISH_USA <br>            // --09----        = LANG_ENGLISH <br>            // --11----        = LANG_JAPANESE <br>            // ----04E4 = 1252 = Codepage for Windows:Multilingual <br> <br>            lstrcpy(szGetName, GetStringRes(IDS_VER_INFO_LANG)); <br> <br>            wRootLen = lstrlen(szGetName); // Save this position <br> <br>            // Set the title of the dialog: <br>            lstrcat (szGetName, "ProductName"); <br>            bRetCode = VerQueryValue((LPVOID)lpstrVffInfo, <br>               (LPSTR)szGetName, <br>               (LPVOID)&amp;lpVersion, <br>               (UINT *)&amp;uVersionLen); <br> <br>            // Notice order of version and string... <br>            if (PRIMARYLANGID(GetUserDefaultLangID()) == LANG_JAPANESE) <br>            { <br>               lstrcpy(szResult, lpVersion); <br>               lstrcat(szResult, "    o [ W        "); <br>            } <br>            else <br>            { <br>               lstrcpy(szResult, "About "); <br>               lstrcat(szResult, lpVersion); <br>            } <br> <br>            // ----------------------------------------------------- <br> <br>            SetWindowText (hDlg, szResult); <br> <br>            // Walk through the dialog items that we want to replace: <br>            for (i = DLG_VERFIRST; i &lt;= DLG_VERLAST; i++) { <br>               GetDlgItemText(hDlg, i, szResult, sizeof(szResult)); <br>               szGetName[wRootLen] = (char)0; <br>               lstrcat (szGetName, szResult); <br>               uVersionLen   = 0; <br>               lpVersion     = NULL; <br>               bRetCode      =  VerQueryValue((LPVOID)lpstrVffInfo, <br>                  (LPSTR)szGetName, <br>                  (LPVOID)&amp;lpVersion, <br>                  (UINT *)&amp;uVersionLen); <br> <br>               if ( bRetCode &amp;&amp; uVersionLen &amp;&amp; lpVersion) { <br>               // Replace dialog item text with version info <br>                  lstrcpy(szResult, lpVersion); <br>                  SetDlgItemText(hDlg, i, szResult); <br>               } <br>               else <br>               { <br>                  dwResult = GetLastError(); <br> <br>                  wsprintf(szResult, GetStringRes(IDS_VERSION_ERROR), dwResult); <br>                  SetDlgItemText (hDlg, i, szResult); <br>               } <br>               SendMessage (GetDlgItem (hDlg, i), WM_SETFONT, <br>                  (UINT)((i==DLG_VERLAST)?hFinePrint:hfontDlg), <br>                  TRUE); <br>            } // for (i = DLG_VERFIRST; i &lt;= DLG_VERLAST; i++) <br> <br> <br>            GlobalUnlock(hMem); <br>            GlobalFree(hMem); <br> <br>         } else { <br>            // No version information available. <br>         } // if (dwVerInfoSize) <br> <br>            SendMessage (GetDlgItem (hDlg, IDC_LABEL), WM_SETFONT, <br>            (WPARAM)hfontDlg,(LPARAM)TRUE); <br> <br>         // We are  using GetVersion rather then GetVersionEx <br>         // because earlier versions of Windows NT and Win32s <br>         // didn't include GetVersionEx: <br>         dwVersion = GetVersion(); <br> <br>         if (dwVersion &lt; 0x80000000) { <br>            // Windows NT <br>            wsprintf (szVersion, "Microsoft Windows NT %u.%u (Build: %u)", <br>               (DWORD)(LOBYTE(LOWORD(dwVersion))), <br>               (DWORD)(HIBYTE(LOWORD(dwVersion))), <br>                    (DWORD)(HIWORD(dwVersion)) ); <br>         } else if (LOBYTE(LOWORD(dwVersion))&lt;4) { <br>            // Win32s <br>                wsprintf (szVersion, "Microsoft Win32s %u.%u (Build: %u)", <br>               (DWORD)(LOBYTE(LOWORD(dwVersion))), <br>               (DWORD)(HIBYTE(LOWORD(dwVersion))), <br>                    (DWORD)(HIWORD(dwVersion) &amp; ~0x8000) ); <br>         } else { <br>            // Windows 95 <br>                wsprintf (szVersion, "Microsoft Windows 95 %u.%u", <br>                    (DWORD)(LOBYTE(LOWORD(dwVersion))), <br>                    (DWORD)(HIBYTE(LOWORD(dwVersion))) ); <br>         } <br> <br>          SetWindowText (GetDlgItem(hDlg, IDC_OSVERSION), szVersion); <br>         ShowWindow (hDlg, SW_SHOW); <br>         return (TRUE); <br> <br>      case WM_COMMAND: <br>         if (LOWORD(wParam) == IDOK || LOWORD(wParam) == IDCANCEL) { <br>            EndDialog(hDlg, TRUE); <br>            DeleteObject (hfontDlg); <br>            DeleteObject (hFinePrint); <br>            return (TRUE); <br>         } <br>         break; <br>   } <br> <br>    return FALSE; <br>} <br> <br>// <br>//   FUNCTION: CenterWindow(HWND, HWND) <br>// <br>//   PURPOSE: Centers one window over another. <br>// <br>//   COMMENTS: <br>// <br>//        In this function, we save the instance handle in a global variable and <br>//        create and display the main program window. <br>// <br>//       This functionwill center one window over another ensuring that <br>//    the placement of the window is within the 'working area', meaning <br>//    that it is both within the display limits of the screen, and not <br>//    obscured by the tray or other framing elements of the desktop. <br>BOOL CenterWindow (HWND hwndChild, HWND hwndParent) <br>{ <br>   RECT    rChild, rParent, rWorkArea; <br>   int     wChild, hChild, wParent, hParent; <br>   int     xNew, yNew; <br>   BOOL  bResult; <br> <br>   // Get the Height and Width of the child window <br>   GetWindowRect (hwndChild, &amp;rChild); <br>   wChild = rChild.right - rChild.left; <br>   hChild = rChild.bottom - rChild.top; <br> <br>   // Get the Height and Width of the parent window <br>   GetWindowRect (hwndParent, &amp;rParent); <br>   wParent = rParent.right - rParent.left; <br>   hParent = rParent.bottom - rParent.top; <br> <br>   // Get the limits of the 'workarea' <br>   bResult = SystemParametersInfo( <br>      SPI_GETWORKAREA,  // system parameter to query or set <br>      sizeof(RECT), <br>      &amp;rWorkArea, <br>      0); <br>   if (!bResult) { <br>      rWorkArea.left = rWorkArea.top = 0; <br>      rWorkArea.right = GetSystemMetrics(SM_CXSCREEN); <br>      rWorkArea.bottom = GetSystemMetrics(SM_CYSCREEN); <br>   } <br> <br>   // Calculate new X position, then adjust for workarea <br>   xNew = rParent.left + ((wParent - wChild) /2); <br>   if (xNew &lt; rWorkArea.left) { <br>      xNew = rWorkArea.left; <br>   } else if ((xNew+wChild) &gt; rWorkArea.right) { <br>      xNew = rWorkArea.right - wChild; <br>   } <br> <br>   // Calculate new Y position, then adjust for workarea <br>   yNew = rParent.top  + ((hParent - hChild) /2); <br>   if (yNew &lt; rWorkArea.top) { <br>      yNew = rWorkArea.top; <br>   } else if ((yNew+hChild) &gt; rWorkArea.bottom) { <br>      yNew = rWorkArea.bottom - hChild; <br>   } <br> <br>   // Set it, and return <br>   return SetWindowPos (hwndChild, NULL, xNew, yNew, 0, 0, SWP_NOSIZE | SWP_NOZORDER); <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>// <br>// FUNCTION:    GetStringRes (int id INPUT ONLY) <br>// <br>// COMMENTS:    Load the resource string with the ID given, and return a <br>//              pointer to it.  Notice that the buffer is common memory so <br>//              the string must be used before this call is made a second time. <br>// <br>//--------------------------------------------------------------------------- <br> <br>LPTSTR   GetStringRes (int id) <br>{ <br>  static TCHAR buffer[MAX_PATH]; <br> <br>  buffer[0]=0; <br>  LoadString (GetModuleHandle (NULL), id, buffer, MAX_PATH); <br>  return buffer; <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
