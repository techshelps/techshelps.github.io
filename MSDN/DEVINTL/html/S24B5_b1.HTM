<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>

<HEAD><meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">
<meta name="GENERATOR" content="Microsoft FrontPage 2.0">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Supporting Multilingual Text Display with Big Fonts</title>
<style>@import url(../msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="../msdn_ie3.css"></HEAD>

<BODY bgcolor="#FFFFFF">

<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

<h3>Supporting Multilingual Text Display with Big Fonts</h3>

<p>The multiple input languages that Windows 95 supports might
fall into a single charset or they might span several charsets.
To support the display of text that spans multiple charsets, the
system uses &quot;big fonts.&quot; As you can see in <font class="MissingLink" meta="dev0u">Appendix H</font>,
each Windows charset (code page) contains the set of ASCII
characters. Though a big font can represent multiple Windows
charsets, it contains only one set of glyphs for ASCII. Just as
applications identify Arial Bold and Arial Italic as separate
logical fonts, they identify Arial Greek and Arial Russian as
separate logical fonts as well. Arial can now have a Greek or
Russian property in the same way that it can have a bold or
italic style; just as you would save font style information in
your document files, you should now save font charset
information. The glyphs are all contained in a single font file
to maintain consistency of font metrics.</p>

<p><b>Font, Locale, and Charset Signatures</b></p>

<p>The TrueType open specification outlines the standard for big
fonts, which is shared by Windows 95 and Windows NT. From now on,
font vendors need to tag each font they create with a font
signature, which is part of the OS/2 table in a TrueType open
font. Windows and Windows-based applications use the following
structure to exchange font signature information:</p>

<p><font size="2" face="Courier New">typedef struct
tagFONTSIGNATURE {<br>
DWORD fsUsb[4];<br>
DWORD fsCsb[2];<br>
} FONTSIGNATURE;</font></p>

<p>A font signature contains two sets of bits, one for Unicode
subranges and one for Windows and OEM code pages. The lower 32
bits of <i>fsCsb</i> refer to Windows code pages, and the upper
32 bits refer to OEM code pages. The <i>fsUsb</i> field contains
an extra bit that is reserved for the future in case additional
Unicode subranges are added. If a font contains glyphs to
represent characters in a particular charset, the font vendor
will set the bits that identify the charset and the corresponding
Unicode range. Strictly speaking, font signatures identify code
pages, but you can use the table in Figure 6-5 of the previous
section to determine which code-page ID corresponds to a
particular charset. (See <font class="MissingLink" meta="dev0an">Appendix M</font> for the list of font
signature bit values.)</p>

<p>Windows 95 introduces two other signatures that are closely
related to font signatures. The first is the charset signature,
which contains a charset ID, the corresponding code-page ID, and
a generic font signature whose bit fields identify the
charset/code page in question.</p>

<p><font size="2" face="Courier New">typedef struct
tagCHARSETINFO {<br>
UINT ciCharset;<br>
UINT ciACP;<br>
FONTSIGNATURE fs;<br>
} CHARSETINFO;</font></p>

<p>The other signature is the locale signature, which identifies
the Unicode subranges and the charsets that can express the
characters used in the locale. </p>

<p><font size="2" face="Courier New">typedef struct
tagLOCALEFONTSIGNATURE {<br>
DWORD lsUsb[4];<br>
DWORD lsCsbDefault[2];<br>
DWORD lsCsbSupported[2];<br>
} LOCALEFONTSIGNATURE;</font></p>

<p>Only one bit is set in the <i>lsCsbDefault</i> field&#151;the
bit for the charset most commonly associated with the locale. In
contrast, the <i>lsCsbSupported</i> field sets the bits for all
charsets that will work for the locale. For example, the default
charset for English locales is ANSI, but because all Windows
charsets contain English letters, numbers, and basic punctuation,
all Windows charsets support English. Therefore, all bits are set
in the <i>lsCsbSupported</i> field for English locale signatures.</p>

<p>The WM_INPUTLANGCHANGE message conveniently hands you the
default charset ID of the new input language so that you don't
have to look for it. When you trap this message, you can find the
charset value in <i>wParam</i>.</p>

<p>You can use font, locale, and charset signatures to determine
whether or not to accept a WM_INPUTLANGCHANGEREQUEST message. For
example, suppose your application allows the user to change to
only the input languages that the current font can accommodate.
The code below shows how you can retrieve various signatures and
compare them. The <i>lParam</i> of WM_INPUTLANGCHANGEREQUEST
contains the keyboard layout handle for the input language the
user is requesting. The low word of this handle is a language ID,
which the sample code passes to <i>GetLocaleInfo</i> in order to
retrieve a locale signature.</p>

<p>If your application stores the font charset information
whenever the font changes (in this example, in a variable called <i>iCurrFontCharset</i>),
it can call the API function <i>TranslateCharsetInfo</i> in order
to retrieve a charset signature. You can actually call <i>TranslateCharsetInfo</i>
in three ways&#151;you can pass in a charset, a code page, or a
generic font signature. The function determines the other charset
signature fields. Once the signature identifying the charset of
the current font has been retrieved, the sample code below
compares it with the locale signature's charset information to
see whether the current font can accommodate the requested input
language. If it can, it passes the message to <i>DefWindowProc.</i></p>

<p><font size="2" face="Courier New">int iCurrFontCharset;<br>
LOCALEFONTSIGNATURE ls;<br>
CHARSETINFO cs;<br>
<br>
switch (wMsg)<br>
{<br>
<br>
...<br>
<br>
case WM_INPUTLANGCHANGEREQUEST:<br>
GetLocaleInfo(LOWORD(lParam), LOCALE_FONTSIGNATURE,<br>
(LPSTR)&amp;ls, sizeof(ls));<br>
TranslateCharsetInfo( ((LONG)iCurrFontCharset),<br>
&amp;cs, TCI_SRCCHARSET );<br>
if (cs.fs.fsCsb[0] &amp; ls.lsCsbSupported[0])<br>
return DefWindowProc(hwnd, wMsg, wParam, lParam);<br>
else<br>
return (LPARAM)0;<br>
<br>
...<br>
<br>
}</font></p>

<p>You can achieve the same results by comparing the locale
signature with the font signature of the current font. The
following code calls <i>GetTextCharsetInfo</i> on the current
device context to retrieve the font signature for the active
font:</p>

<p><font size="2" face="Courier New">FONTSIGNATURE fs;<br>
LOCALEFONTSIGNATURE ls;<br>
<br>
switch(wMsg)<br>
{<br>
<br>
...<br>
<br>
case WM_INPUTLANGCHANGEREQUEST:<br>
GetLocaleInfo(LOWORD(lParam), LOCALE_FONTSIGNATURE,<br>
(LPSTR)&amp;ls, sizeof(ls));<br>
GetTextCharsetInfo(hdc, &amp;fs, 0);<br>
if (fs.fsCsb[0] &amp; ls.lsCsbSupported[0])<br>
return DefWindowProc(hwnd, wMsg, wParam, lParam);<br>
else<br>
return (LPARAM)0;<br>
<br>
...<br>
<br>
}</font></p>
</FONT></BODY>
</html>
