<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">

<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Unicode in Win32s and Windows 95</title>
<style>@import url(../msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="../msdn_ie3.css"></HEAD>

<BODY bgcolor="#FFFFFF">

<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

<h3>Unicode in Win32s and Windows 95</h3>

<P><b>Glossary</b></p>

<ul>
    <li><b>Clipboard: </b>A Windows utility used as a buffer for
        copying and pasting text.</li>
    <li><b>Win32s API: </b>A subset of the Win32 API that makes
        it possible to create a single binary that runs on
        Windows 3.1 and all 32-bit versions of the Windows
        platform.</li>
</ul>

<p>The 16-bit Windows (Win16) API contains no Unicode support at
all. It's possible to create a Unicode-based program for Windows
3.1, but the application must carry character conversion mapping
tables and routines, and possibly specialized font support.
Creating a new 16-bit Unicode-based application for Windows 3.1
doesn't make sense at this point, because 32-bit applications for
Windows are now standard.</p>

<p>The most Unicode-accessible alternative available for Windows
3.1 is the Win32s API. Applications written for Win32s, a subset
of the Win32 API, can run on Windows 3.1, Windows NT, and Windows
95 without being recompiled. Win32s supports ANSI versions of the
Win32 API entry points but excludes virtually all of the
wide-character entry points because neither Windows 3.1 nor
Windows 95 can support them. For example, the Windows 3.1
graphics device interface (GDI) and file allocation table (FAT)
do not support Unicode. An application that calls the
wide-character variants of the Win32 API&#151;a Win32 application
compiled with the UNICODE flag defined, for instance&#151;cannot
run on Windows 3.1 using Win32s or on Windows 95. Errors
indicating that the -W API calls are not implemented will appear
under Windows 3.1. Under Win32s and Windows 95, the -W API entry
points are stubbed; your application will get a return value
indicating that the call failed.</p>

<p>Although it does not support wide-character API entry points,
Win32s does contain two important API functions&#151;<i>MultiByteToWideChar</i>
and <i>WideCharToMultiByte</i>&#151;that can convert data between
Unicode and local Windows code pages. For example, an application
running on a Japanese edition of Windows 3.1 could call these two
functions to convert between the Unicode and Shift-JIS encodings.</p>

<p>Windows 95 inherited these conversion functions and supports a
handful of low-level wide-character API calls for Unicode text
output, such as <i>TextOutW,</i> <i>GetCharWidthW, </i>and <i>GetTextExtentPointW</i>.
Thus a non-Unicode application running on Windows 95 can share a
Unicode-based file format with a sister application that is
targeted for Windows NT. Using these functions, it's also
possible to develop an application for Windows 95 that processes
data in Unicode. Because the system API is still limited to the
native character set (except for the text functions mentioned
above), such applications need to explicitly convert data before
calling the system, and only those characters in the native
character set can be successfully converted.</p>

<p>For example, if you want a list box to display data from your
document, you will either have to convert the data or use an
owner-draw list box. An owner-draw control informs you when each
item within it needs to be drawn; you can then use <i>TextOutW</i>
to do the drawing. If you are using edit controls for input,
remember that in Windows 95 the edit control will rely on one of
the local character sets. You will have to convert the text
returned from the edit control by calling <i>MultiByteToWideChar</i>.</p>

<p>The Win32 API also handles converting data between character
sets via the clipboard. Windows 95 supports the same clipboard
formats as Windows NT: CF_UNICODETEXT, CF_OEMTEXT, and CF_TEXT
(which should really be called CF_ANSITEXT). Any text copied to
the clipboard is enumerated in all three formats, so it's
possible to cut and paste across applications supporting
different character sets. For example, a simple piece of text can
be copied from one application in ANSI format and pasted to
another in Unicode format or vice versa. Windows 95 also adds the
clipboard format CF_LOCALE, which allows applications to mark
clipboard text with a specific language and character set.</p>

<p>Functions such as <i>GetStringType</i> and <i>LCMapString</i>
operate on only one code page at a time in Windows 95. If you
have decided to support Unicode data, you might need to call
these functions several times with different code page arguments
and then manually combine their output. This requires a little
work. Be sure to use the full Unicode versions of these functions
when your application is running on Windows NT. Programs not
using Unicode can use the Windows95 font charset property to
create multilingual rich-text documents.</p>

<p>Because converting data to and from Unicode adds system
overhead, Win32-based applications running on Windows 95 might
perform more efficiently when based on Windows code pages,
depending on how much text processing they do. Keep in mind,
however, that Unicode is always more efficient for processing Far
Eastern languages, processing multilingual text, and creating a
global code base.</p>

<p>You'll need to decide what's best for your application. The
developers of the Windows 95 help system weighed these factors
and decided to base the full-text search portion of the help
engine on Unicode, primarily since the parsing, searching, and
indexing algorithms the developers used were not easily portable
to variable-width character sets. (See <font class="MissingLink" meta="dev0h">Chapter 5</font>.) The developers
of 32-bit OLE also decided to base their system on Unicode.</p>

<p>The following sample illustrates a typical approach to
handling conversion between Unicode and local character sets. To
optimize performance, you should use a temporary variable on the
stack, allocating a buffer only when a string is too long.</p>

<p>To calculate the necessary buffer size, you have to determine
whether the Windows character set is single-byte or multibyte. <i>GetCPInfo</i>
will return the maximum number of bytes in a character for the
given code page:</p>

<p><font size="2" face="Courier New">CPINFO CPInfo;<br>
GetCPInfo(CP_ACP, &amp;CPInfo); // Get info on current code page.<br>
int cmaxCharSize = CPInfo.MaxCharSize;</font></p>

<p><font size="2" face="Courier New">CP_ACP is a predefined
constant that always refers to the currently installed Windows
character set. For some sample &quot;data,&quot; the literal
string constant <i>lpWide </i>is set to a Unicode string using
the prefix <i>L</i> notation.</font></p>

<p><font size="2" face="Courier New">const WCHAR* lpWide =
L&quot;Unicode&quot;;<br>
<br>
BOOL WideSetWindowText(HWND hwnd, LPWSTR lpWide)<br>
{<br>
CHAR ach[20]; // Try a small buffer on the stack.<br>
LPSTR lpsz = ach;<br>
int cchpsz = sizeof ach;<br>
<br>
DWORD dwFlags = 0;<br>
<br>
// Do the conversion.<br>
int len = WideCharToMultiByte(CP_ACP, dwFlags,<br>
lpWide, -1, lpsz,<br>
cchpsz, NULL, NULL);<br>
if ( !len )<br>
{<br>
if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)<br>
{<br>
int cchWide = wcslen(lpWide);<br>
lpsz = (LPSTR) malloc((cchWide+1)*cmaxCharSize); // usually <br>
// enough<br>
<br>
// Try conversion again with the larger buffer.<br>
cchpsz = cchWide;<br>
len = WideCharToMultiByte(CP_ACP, dwFlags,<br>
lpWide, cchWide, lpsz,<br>
cchpsz, NULL, NULL);<br>
if ( !len )<br>
{<br>
free (lpsz);<br>
return FALSE;<br>
}<br>
BOOL returnVal = SetWindowText(hwnd, lpsz);<br>
free(lpsz);<br>
return returnVal;<br>
}<br>
else<br>
{<br>
return FALSE; // some other error<br>
}<br>
}<br>
<br>
// Set the Window text and return the result.<br>
return SetWindowText(hwnd, lpsz);<br>
}</font></p>
</FONT></BODY>
</html>
