<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">

<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Compatibility Issues</title>
<style>@import url(../msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="../msdn_ie3.css"></HEAD>

<BODY bgcolor="#FFFFFF">

<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

<h3>Compatibility Issues</h3>

<p>The API in Far East editions of Windows constitutes a superset
of the API in European editions of Windows, so English-language
applications will run correctly on Far East editions of Windows.
But what about the reverse situation? Is there a way to run
Japanese-language or Chinese-language applications on English
editions of Windows? Because Windows 95 is based on local
character sets, supporting double-byte ideographic characters on
single-byte editions of Windows 95 is not possible without some
serious hacking.</p>

<p>On Windows NT, however, it is possible to at least display
ideographic characters on non&#150;Far East editions because
Windows NT supports Unicode. You can display Japanese characters
on any language edition of Windows NT if you have an application
that is Unicode-enabled and you have installed a Japanese font,
such as the MS Mincho font or MS Gothic font that ships with
Japanese Windows NT 3.5. However, you will be unable to display
characters that aren't included both in Unicode and in your
installed fonts. For example, Unicode version 1.1 does not
support Korean combining jamos and some rare Korean hangul
characters, so Windows NT 3.5 cannot display them. (Windows NT
3.51, which is based on Unicode 2, does support these
characters.) Keep in mind as well that non&#150;Far East editions
of Windows NT do not support Far East National Language Support
information, such as calendars and currencies, although future
versions of Windows NT will.</p>

<p>Using a Unicode-enabled edit control on Windows NT gives your
application &quot;free&quot; support for the entering of
ideographic characters. The following code excerpt creates an
edit control that can display any Unicode character, given the
appropriate font:</p>

<p><font size="2" face="Courier New">// You can replace the
following line with the compiler<br>
// switch -DUNICODE<br>
#define UNICODE<br>
#include &lt;windows.h&gt;<br>
<br>
...inside the Windows procedure (WndProc)...<br>
switch (message)<br>
{<br>
case WM_CREATE: <br>
// Sets up edit control.<br>
// If UNICODE is defined, the preprocessor will replace <br>
// CreateWindow with CreateWindowW, the Unicode<br>
// version of this function.<br>
hWndEdit = CreateWindow(TEXT(&quot;edit&quot;), NULL,<br>
WS_CHILD | WS_VISIBLE | WS_HSCROLL<br>
| WS_VSCROLL | WS_BORDER | ES_LEFT<br>
<br>
| ES_MULTILINE | ES_NOHIDESEL<br>
| ES_AUTOHSCROLL | ES_AUTOVSCROLL, <br>
0,0,0,0,<br>
hwnd, (HMENU) ID_WEDIT, <br>
hThisInstance, NULL) ;<br>
<br>
SendMessage(hWndEdit, EM_LIMITTEXT, MAXBUFF, 0L) ;<br>
<br>
...other initialization code...<br>
<br>
break ;<br>
<br>
case WM_SETFOCUS:<br>
SetFocus(hWndEdit) ;<br>
return 0 ;<br>
<br>
// other message handling...<br>
case WM_COMMAND:<br>
switch (LOWORD(wParam)) // main menu messages<br>
{<br>
// other menu commands...<br>
case IDM_FONT:<br>
if (Choosefont(cfFont))<br>
{<br>
if ( NULL == (hfScreenFont = <br>
CreateFontIndirect(cfFont.lpLogFont)) )<br>
{<br>
...error out...<br>
}<br>
}<br>
return 0 ; <br>
<br>
... <br>
<br>
}<br>
}</font></p>

<p>One advantage of the above approach is that the application
inherits the edit control from a system DLL. Therefore, when you
run this code on Japanese Windows NT, the application uses a
system edit control that is IME-aware. The user can enter
Japanese characters into the edit control buffer, which the
application can process at will. This functionality is also
available in MFC using <i>CEditView</i>.</p>

<p><b>Running a Single Binary on Japanese Windows and US Windows</b></p>

<p>Suppose you have a slightly different goal&#151;a single,
worldwide binary that runs on both Japanese Windows and US
Windows. Because Japanese editions of Windows support functions
that the US editions do not, your application will have to
&quot;gracefully degrade&quot; on US Windows. On Windows 95, this
is a very simple matter, because additional Far
East&#150;specific functions are stubbed on non&#150;Far East
editions of the operating system. On US Windows NT 3<i>.x,</i>
however, this matter is considerably more complex, because the
operating system does not stub the additional functions that ship
with Japanese Windows NT. For example, the following functions
are undefined on Western editions of Windows NT 3.<i>x</i>. Note
that they are all related to IMEs.</p>

<table border="0" cellpadding="7" cols="2">
<COLGROUP><COL WIDTH="205pt" VALIGN="TOP"><COL WIDTH="205pt" VALIGN="TOP"></COLGROUP><TBODY>    <tr>
        <td valign="top">IMPAddIME</td>
        <td valign="top">WINNLSPostAppMessage</td>
    </tr>
    <tr>
        <td valign="top">IMPDeleteIME</td>
        <td valign="top">WINNLSSendAppMessage</td>
    </tr>
    <tr>
        <td valign="top">IMPGetIME</td>
        <td valign="top">WINNLSSetIMEStatus </td>
    </tr>
    <tr>
        <td valign="top">IMPQueryIME</td>
        <td valign="top">WINNLSGetKeyState</td>
    </tr>
    <tr>
        <td valign="top">IMPSetIME</td>
        <td valign="top">WINNLSSetIMEHandle</td>
    </tr>
    <tr>
        <td valign="top">WINNLSEnableIME</td>
        <td valign="top">WINNLSSetIMEHotkey</td>
    </tr>
    <tr>
        <td valign="top">WINNLSSendString</td>
        <td valign="top">WINNLSGetEnableStatus</td>
    </tr>
    <tr>
        <td valign="top">WINNLSSetKeyState</td>
        <td valign="top">WINNLSGetIMEHotkey</td>
    </tr>
</TBODY></table>

<P><br>
</p>

<p>You can still share a single binary by taking advantage of the
Win32 function <i>GetProcAddress</i>. Instead of calling the
additional API functions by name, you can call them by address.
The array <i>IMEFunc</i> below contains the names of three
IME-related functions, each followed by a pointer to a procedure
address that is initialized to NULL.</p>

<p><font size="2" face="Courier New">Const int NUMIMEFUNCS = 3;<br>
struct _tagIMEfuncs {<br>
LPCHAR pszName;<br>
FARPROC *pFunc;<br>
} IMEFunc[NUMIMEFUNCS] = {&quot;IMPAddIMEA&quot;, NULL,<br>
&quot;IMPDeleteIMEA&quot;, NULL,<br>
&quot;IMPGetIMEA&quot;, NULL};</font></p>

<p>During its initialization phase, your application will call a
function such as <i>LoadIMEFuncs, </i>shown below.</p>

<p>This function will attempt to find each of the procedures
named in the array <i>IMEFunc</i>. If the application is running
on US Windows NT, the IME functions will be undefined, and the
procedure addresses in the <i>IMEFunc</i> array will remain NULL.
If you are running on Japanese Windows NT, the NULL values will
be replaced with the correct procedure addresses. Code in other
parts of the application should check to make sure the procedure
addresses are not NULL before executing any IME-related code.</p>

<p><font size="2" face="Courier New">HMODULE LoadIMEFuncs(struct
_tagIMEFuncs* pIME, int cFuncs)<br>
{<br>
HMODULE hDLL = LoadLibrary(TEXT(&quot;user32&quot;));<br>
if (hDLL)<br>
while (cFuncs-- &gt; 0)<br>
pIME[cFuncs].pFunc = GetProcAddress(hDLL,<br>
pIME[cFuncs].pszName);<br>
return (hDLL);<br>
}<br>
<br>
...<br>
<br>
LoadIMEFuncs(IMEFunc, NUMIMEFUNCS);</font></p>

<p>&nbsp;</p>

<p><b>Running a Single Binary on Windows NT 3.5 and Windows 95</b></p>

<p>Another important compatibility issue involves the ability to
run a single binary on both Windows NT 3.5 and Windows 95, since
the API sets for each platform are slightly different. The major
difference for Far East editions of Windows NT and Windows 95 is
in the IME support. Applications written for the Windows NT
3.5&#150;based IME model will run correctly on Windows 95, but
applications written for the Windows 95&#150;based IME model will
not run on Windows NT 3.5. If Windows 95 is the main platform for
your application, you should definitely implement IME support
based on Windows 95's model. Keep in mind that Windows NT 3.51
and the next version of Windows NT, often referred to as
&quot;Cairo,&quot; use the same IME model as Windows 95 does.</p>
</FONT></BODY>
</html>
