<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">

<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Unicode in Visual C++ 2</title>
<style>@import url(../msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="../msdn_ie3.css"></HEAD>

<BODY bgcolor="#FFFFFF">

<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

<h2>Unicode in Visual C++ 2</h2>

<H3><b>Glossary</b></h3>

<ul>
    <li><b>ANSI C:</b> The standardized C programming language.</li>
    <li><b>Run-time library: </b>Functions included with a C
        compiler that programs can call to perform various basic
        operations.</li>
</ul>

<p>Networks and operating systems are not the only pieces of
software that have historically limited text to 7-bit ASCII or
8-bit ANSI characters&#151;development tools have too. Some
recent compilers contain run-time library support for the
Shift-JIS code page, but they have been difficult to use in
non-Japanese parts of the Far East or with other Japanese code
pages. In the past, developers had to use localized compilers to
get support for plaintext C source files that could handle
non-ANSI string literals or comments. On Windows, compiling
resource files for the Far East or Middle East has traditionally
required localized editions of the Windows resource compiler. You
can use the US Windows 3.1 SDK tools to create resources for
Central and Eastern Europe, Greece, or Turkey, but you still have
to run them on the localized operating system so that editing and
resource compiling work properly. Obviously, using a number of
compilers and operating systems to create foreign-language
products gets complicated, not to mention expensive.</p>

<p>Development tools that support universal, language-independent
applications on 32-bit Windows are now available. The resource
and message compilers that come with Windows NT 3.5, Windows 95,
and Visual C++ 2 compile files into Unicode. The Visual C++ 2
run-time libraries and MFC 3 provide support for ANSI, multibyte,
and Unicode text processing. Select the Unicode support option
during installation and use full-text search in the online books
for explanations on adding Unicode support using the compiler.</p>

<p>Another significant improvement to Visual C++ is that critical
run-time string-processing and character-processing functions
such as <i>isalpha, toupper, printf, strcoll, atof, </i>and <i>strftime
</i>are now locale-sensitive. In addition, the Visual C++ 2
run-time libraries contain multibyte and Unicode versions of
these and numerous other functions. Like the Win32 API model,
it's possible to access these functions through generic
prototypes, which can be resolved in three different ways. (See
Figure 3-17.) If no compile-time flags are defined, the generic
text functions resolve to SBCS functions. If the compile-time
flag _UNICODE is defined (similar to the Win32 UNICODE flag but
preceded by an underscore), the generic prototypes resolve to
wide-character functions. Finally, if the _MBCS flag is defined,
the prototypes resolve to multibyte functions. Visual C++ 2 also
defines the generic type _TCHAR, which is analogous to Win32's
TCHAR, and the text macro _T, which is analogous to Win32's TEXT
macro.</p>

<P><img src="F03FD17.gif" width="336" height="575"></p>

<P><b>Figure 3-17</b> <i>Using Visual C++ 2's generic
text functions.</i></p>

<p>The following is an example of code that can be compiled for
either ANSI or Unicode using the definitions in the Visual C++ 2
header files and the C run-time library functions:</p>

<p><font size="2" face="Courier New">#define _UNICODE // Remove
this line to compile for ANSI.<br>
#include &lt;malloc.h&gt;<br>
#include &lt;string.h&gt;<br>
#include &lt;stdio.h&gt;<br>
#include &lt;tchar.h&gt;<br>
#include &lt;windows.h&gt;<br>
<br>
// Sample Program: a generic function<br>
_TCHAR *ReplaceText(_TCHAR *pszStr, _TCHAR *pszSubst)<br>
{<br>
// pszStr must contain at least one non-null character.<br>
_TCHAR *pchStart = pszStr;<br>
while ( *pchStart ) <br>
if ( *pchStart++ == _T('\\') )<br>
break;<br>
<br>
pchStart[-1] = 0;<br>
_TCHAR *pchEnd = pchStart + _tcslen(pchStart);<br>
while ( --pchEnd &gt;= pchStart )<br>
if ( *pchEnd == _T('\\') )<br>
break;<br>
<br>
pchEnd++;<br>
_TCHAR *pszNew = (_TCHAR *)malloc(sizeof(_TCHAR) *<br>
(_tcslen(pszStr) +<br>
_tcslen(pszSubst) +<br>
_tcslen(pchEnd) + 1));<br>
_tprintf(pszNew, _TEXT(&quot;%s%s%s&quot;), pszStr, pszSubst,
pchEnd);<br>
return pszNew;<br>
}</font></p>

<p>The table below lists the Visual C++ 2 wide-character
functions. All have generic equivalents except <i>mbstowcs,
mbtowc, wctomb, </i>and<i> wcstombs</i>. Function names in
italics are ANSI/ISO-compliant. Function names that are in
boldface are locale-sensitive. Function names that are both in
italics and boldface carry both properties. The character
classification functions and the conversion functions <i>towlower</i>
and <i>towupper</i> behave the same way as their single-byte
counterparts in the C-compiler default locale, but they follow
the character classifications of <i>GetStringTypeW</i> outside
the C-compiler default locale.</p>

<table border="0" cellpadding="7" cols="2">
<COLGROUP><COL WIDTH="140pt" VALIGN="TOP"><COL WIDTH="302pt" VALIGN="TOP"></COLGROUP><TBODY>    <tr>
        <td valign="top"><b><i>Process Control </i></b></td>
        <td valign="top">_wexecl, _wexecle, _wexeclp, _wexeclpe,
        _wexecv, _wexecve, _wexecvp, _wexecvpe, _wspawnl,
        _wspawnle, _wspawnlp, _wspawnlpe, _wspawnv, _wspawnve,
        _wspawnvp, _wspawnvpe</td>
    </tr>
    <tr>
        <td valign="top">&nbsp;</td>
        <td valign="top">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top"><b><i>File/Path</i></b></td>
        <td valign="top">_waccess, _wchdir, _wchmod, _wcreat,
        _wfdopen, _wfindfirst, _wfindnext, _wfopen, _wfreopen,
        _wfsopen, _wfullpath, _wgetcwd, _wgetdcwd, _wgetenv,
        _wmakepath, _wmkdir, _wmktemp, _wopen, _wpopen, _wremove,
        _wrename, _wrmdir, _wsopen, _wsplitpath, _wstat, _wunlink
        </td>
    </tr>
    <tr>
        <td valign="top">&nbsp;</td>
        <td valign="top">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top"><b><i>IO</i></b></td>
        <td valign="top">_fgetwchar, _fputwchar, _snwprintf,
        _vsnwprintf, <i>fgetwc, fgetws, fputwc, fputws, fwprintf,
        fwscanf, getwc, getwchar, getws, putwc, putwchar, putws,
        swprintf, swscanf, ungetwc, vfwprintf, vswprintf,
        vwprintf, wprintf, wscanf</i></td>
    </tr>
    <tr>
        <td valign="top">&nbsp;</td>
        <td valign="top">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top"><b><i>Character Classification</i></b></td>
        <td valign="top"><i>iswalnum, iswalpha, iswascii,
        iswcntrl, iswctype, iswdigit, iswgraph, iswlower,
        iswprint, iswpunct, iswspace, iswupper, iswxdigit</i></td>
    </tr>
    <tr>
        <td valign="top">&nbsp;</td>
        <td valign="top">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top"><b><i>Character Conversion</i></b></td>
        <td valign="top"><b><i>mbstowcs,</i></b> <b><i>mbtowc,</i></b>
        <i>towlower, towupper,</i><b><i> wcstombs, wctomb</i></b></td>
    </tr>
    <tr>
        <td valign="top">&nbsp;</td>
        <td valign="top">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top"><b><i>String Manipulation</i></b></td>
        <td valign="top">_wcsdec, _wcsdup, _wcslwr, _wcsncnt,
        _wcsnextc, _wcsnset, _wcspnp, _wcsrev, _wcsset, _wcsupr, <i>wcscat,
        wcschr, wcscpy, wcscspn, wcslen, wcsncat, wcsncpy,
        wcspbrk, wcsrchr, wcsspn, wcsstr, wcstod, wcstok, wcstol,
        wcstoul</i><b><i>, </i></b><i>wcsxfrm</i></td>
    </tr>
    <tr>
        <td valign="top">&nbsp;</td>
        <td valign="top">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top"><b><i>String Comparison</i></b></td>
        <td valign="top">wcsicmp, <b>_wcsicoll,</b> _wcsncmp, <b>_wcsncoll,</b>
        _wcsnicmp, <b>_wcsnicoll,</b> <i>wcscmp,</i> <b><i>wcscoll</i></b></td>
    </tr>
    <tr>
        <td valign="top">&nbsp;</td>
        <td valign="top">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top"><b><i>Numeric/String Conversion</i></b></td>
        <td valign="top">_itow, _ltow, _ultow, _wtoi, _wtol</td>
    </tr>
    <tr>
        <td valign="top">&nbsp;</td>
        <td valign="top">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top"><b><i>Date/Time Functions</i></b></td>
        <td valign="top">_wasctime, _wctime, _wstrdate,
        _wstrtime, _wutime, <b><i>wcsftime</i></b></td>
    </tr>
    <tr>
        <td valign="top">&nbsp;</td>
        <td valign="top">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top"><b><i>Miscellaneous</i></b></td>
        <td valign="top">_wperror, _wsetlocale, _wsystem,
        _wtempnam, _wtmpnam</td>
    </tr>
</TBODY></table>

<P><br>
</p>

<p>You might notice that some locale-sensitive run-time library
functions overlap the Win32 API. For example, <i>tolower</i> and <i>toupper</i>
correspond to <i>CharUpper</i> and <i>CharLower</i>. C run-time
functions are generally simpler and less flexible than Win32 API
calls, but together they provide the same kind of international
support as the Win32 API. Some C run-time functions actually call
the system to retrieve locale-sensitive information. For example,
when running on Win32, <i>strcoll</i> calls the API function <i>CompareString</i>.
Calling <i>CompareString</i> directly will give you access to
more detailed error messages and will remove an indirection.
Simple run-time functions don't carry the overhead of calling the
system.</p>

<p>One substantial advantage of using the C run times is that
they consistently support Unicode, whereas 32-bit Windows does
not. You can use the wide-character C run-time function calls to
do Unicode programming for Win32s or Windows 95. Similarly, you
don't need a special Japanese compiler to create
Shift-JIS&#150;based applications for Japan. You don't even need
a Japanese development environment&#151;the multibyte C run-time
functions are always available. Finally, if your goal is to write
code that is portable across platforms, you can limit your calls
to the ANSI/ISO C standard run-time functions. Keep in mind that
locale-specific results will vary depending on the target system.</p>
</FONT></BODY>
</html>
