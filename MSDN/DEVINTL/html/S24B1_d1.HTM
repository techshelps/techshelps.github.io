<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">

<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Isolating Localizable Resources</title>
<style>@import url(../msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="../msdn_ie3.css"></HEAD>

<BODY bgcolor="#FFFFFF">

<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

<h2>Isolating Localizable Resources</h2>

<H3><b>Glossary</b></h3>

<ul>
    <li><b>Localizable resource:</b> Any element of a program's
        user interface that requires translation or modification
        for different languages.</li>
    <li><b>Hard-coding:</b> Putting string or character literals
        in the main body of code, such as the .C files or the .H
        files, instead of in Windows resource files. Basing
        numeric constants on the assumed length of a string.</li>
</ul>

<p>It is easy to identify source code that isn't properly set up
for localization. The most extreme cases are populated with
hard-coded strings, constants, and characters. Files containing
hard-coded localizable elements are a nightmare to deal with.
Translators cannot simply translate the source code files,
especially if the code is continually evolving. Many translators
are not programmers and might delete important details, such as
closing quotes or semicolons, or translate programming keywords
as well as strings. Then developers must take time to clean up
these files so that they will compile correctly.</p>

<p>Separating all localizable items into one or more files makes
localization much easier to manage. The following major program
elements require localization:</p>

<table border="0" cellpadding="7" cols="4">
    <tr>
        <td valign="top"><ul>
            <li>Certain algorithms</li>
        </ul>
        </td>
        <td valign="top"><ul>
            <li>Messages</li>
        </ul>
        </td>
    </tr>
    <tr>
        <td valign="top"><ul>
            <li>Constants</li>
        </ul>
        </td>
        <td valign="top"><ul>
            <li>Prompts</li>
        </ul>
        </td>
    </tr>
    <tr>
        <td valign="top"><ul>
            <li>Dialogs</li>
        </ul>
        </td>
        <td valign="top"><ul>
            <li>Sounds</li>
        </ul>
        </td>
    </tr>
    <tr>
        <td valign="top"><ul>
            <li>Macro languages</li>
        </ul>
        </td>
        <td valign="top"><ul>
            <li>Status bars</li>
        </ul>
        </td>
    </tr>
    <tr>
        <td valign="top"><ul>
            <li>Menus</li>
        </ul>
        </td>
        <td valign="top"><ul>
            <li>Toolbars</li>
        </ul>
        </td>
    </tr>
</table>

<p>One approach would be to create a complex process to strip out
all localizable items from source files and reincorporate them
once they have been translated. That way, you could declare
strings in the same area as the code that uses them. However,
designing and implementing such a scheme hardly seems worth the
effort when better localization methods are available. An
alternative approach would be to place all strings and constants
in header files, but then you would have to recompile any source
files that included translated headers. By far the simplest and
most straightforward method of dealing with localizable resources
for Windows-based applications is to put everything in one or
more Windows resource files. As <font class="MissingLink" meta="dev0g">Chapter 4</font> describes in more
detail, Win32 resource files are easy to edit, and they eliminate
the need for recompiling source code.</p>

<p>In addition to elements of the user interface, you might need
to customize some algorithms based on language or locale. If your
application will support multilingual documents, you'll need to
carry code that gives the correct results for a number of
languages. Avoid using #ifdef statements around code to handle
special cases based on language or locale. (See the next section,
&quot;Eliminating Compile Dependencies,&quot; for more advice on
using #ifdefs.) They aren't worth the cost of recompiling your
main executable. Whenever possible, write generic code to support
cultural conventions using the NLSAPI. (See <font class="MissingLink" meta="dev0h">Chapter 5</font>.) You can
separate language-sensitive or locale-sensitive features that
require large code differences&#151;such as spell-checkers or
grammar-checkers&#151;into DLLs. (See Figure 2-6.)</p>

<p><img src="f02fd06.gif" width="388" height="219"></p>

<P><b>Figure 2-6</b> <i>A localized executable consists
of compiled source code plus a localized user interface.
Customized code can be isolated in a DLL.</i></p>

<p>The sample directory structure in Figure 2-7 illustrates how
all localizable files, whether they contain code or user
interface elements, can be placed in a single directory.
Translators need access only to the directory containing the
nativelanguage files and the localized files for which they are
responsible. A multilingual build process can incorporate
resource files from the appropriate language directory and place
resulting files in the appropriate language's build directory.</p>

<p><img src="f02fd07.gif" width="292" height="377"></p>

<P><b>Figure 2-7</b> <i>Sample directory structure. All
files that need to be customized based on language are in the
resources directory Developers update files in the native
directory and use batch files to propagate the changes to other
language directories.</i></p>
</FONT></BODY>
</html>
