<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>

<HEAD><meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">
<meta name="GENERATOR" content="Microsoft FrontPage 2.0">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DBCS Programming Basics</title>
<style>@import url(../msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="../msdn_ie3.css"></HEAD>

<BODY bgcolor="#FFFFFF">

<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

<h3>DBCS Programming Basics</h3>

<p>Each 2-byte character is composed of a Lead Byte- and a trail
byte that must be stored together and manipulated as a unit. A
lead-byte value always falls into one or more ranges above 127;
no 7-bit ASCII character can be a lead byte. NULL can never be a
trail byte but the range of possible trail bytes can overlap to
some degree with ASCII. Trail-byte values are frequently
indistinguishable from lead-byte values; the only way to tell the
difference is from the context of the surrounding characters.
Furthermore, a trail byte taken without its Lead Byte- can be
mistaken for a single-byte character. Code that scans a
double-byte character-set string for a single-byte character
such as a backslash (\), might &quot;find&quot; the second half
of a kanji character.</p>

<p>In the nonsensical filename below, the second DBCS character
has a trail byte equal to the backslash. This is how the filename
would appear on a DBCS system:</p>

<P><img src="G03FD01.gif" width="101" height="22"></p>

<p>The same filename, however, might look like a pathname when
processed by a DBCS-ignorant program.</p>

<P><img src="G03FD02.gif" width="79" height="20"></p>

<p>With double-byte characters, code that searches, selects,
edits, moves, replaces, deletes, or inserts text must check for
double-byte pairs, as shown below:</p>

<p><font size="2" face="Courier New">// Return pointer to the
first '\' in a given string.<br>
char* GetBackslash(char *pszStr)<br>
{<br>
while (*pszStr)<br>
{<br>
if the current byte is not a Lead Byte-<br>
if it is a '\'<br>
break out of loop<br>
else // it is a lead byte<br>
increment pointer 1 byte to point to trail byte<br>
<br>
increment pointer 1 byte to point to next character<br>
}<br>
return(pszStr);<br>
}</font></p>

<p>If you separate a lead byte from its trail byte you will
trash your string. In the following example, inserting the
single-byte value 0x41 (ASCII <i>A</i>) in the middle of a
double-byte character yields strange results when a program has
not been properly DBCS-enabled.</p>

<table border="0" cellpadding="7" cols="2">
<COLGROUP><COL WIDTH="205pt" VALIGN="TOP"><COL WIDTH="205pt" VALIGN="TOP"></COLGROUP><TBODY>    <tr>
        <td valign="top"><img src="G03FD03A.gif" width="88"
        height="28"></td>
        <td valign="top"><img src="G03FD03B.gif" width="92"
        height="26"></td>
    </tr>
    <tr>
        <td valign="top"><b>Before</b></td>
        <td valign="top"><b>After</b></td>
    </tr>
</TBODY></table>

<P><br>
</p>

<p>The Lead Byte- of the kanji character combines with the <i>A</i>
to create a different kanji and the trail byte of the original
kanji becomes the single-byte katakana character <i>se</i>.</p>

<h4>Display Operations</h4>

<p>Not only do coding practices need to be adjusted to avoid
splitting double-byte characters in two, but so do a program's
display operations. Rules of selection, cursor placement, and
cursor movement are the same as you would expect when dealing
with alphabetic characters&#151;the cursor should always end up
between characters and never in the middle of one. The difference
with double-byte characters is that they are a combination of two
encoding units. In a command-line interface, such as the Windows
NT console mode, double-byte characters are generally twice as
wide as ASCII characters. In Windows, ASCII characters can be
drawn with proportional fonts, but ideographic characters,
including Japanese kana, are always monospaced.</p>

<p>In the operations shown in the following example, the cursor
should never end up bisecting a double-byte character.</p>

<table border="0" cellpadding="7" cols="4">
<COLGROUP><COL WIDTH="102pt" VALIGN="TOP"><COL WIDTH="102pt" VALIGN="TOP"><COL WIDTH="87pt" VALIGN="TOP"><COL WIDTH="117pt" VALIGN="TOP"></COLGROUP><TBODY>    <tr>
        <td valign="top">&nbsp;</td>
        <td valign="top"><b><i>Placing the Cursor</i></b></td>
        <td valign="top"><b><i>Backspace-Deleting a Character</i></b></td>
        <td valign="top"><b><i>Selecting a Character</i></b></td>
    </tr>
    <tr>
        <td valign="top">&nbsp;</td>
        <td valign="top">&nbsp;</td>
        <td valign="top">&nbsp;</td>
        <td valign="top">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top"><b><i>Correct</i></b></td>
        <td valign="top"><img src="G03FD04A.gif" width="81"
        height="42"></td>
        <td valign="top"><img src="G03FD04B.gif" width="68"
        height="44"></td>
        <td valign="top"><img src="G03FD04C.gif" width="76"
        height="48"></td>
    </tr>
    <tr>
        <td valign="top"><b><i>Incorrect</i></b></td>
        <td valign="top"><img src="G03FD04D.gif" width="82"
        height="46"></td>
        <td valign="top"><img src="G03FD04E.gif" width="68"
        height="45"></td>
        <td valign="top"><img src="G03FD04F.gif" width="80"
        height="46"></td>
    </tr>
</TBODY></table>

<P><br>
</p>

<p>If you click the mouse on the leftmost three-quarters of the
character, the cursor should end up to the left of the character.
If you click it on the rightmost quarter, the cursor should end
up to the right of the character.</p>
</FONT></BODY>
</html>
