<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>

<HEAD><meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">
<meta name="GENERATOR" content="Microsoft FrontPage 2.0">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DBCS-Enabling Your Core-Code Base</title>
<style>@import url(../msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="../msdn_ie3.css"></HEAD>

<BODY bgcolor="#FFFFFF">

<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

<h3>DBCS-Enabling Your Core-Code Base</h3>

<p>As mentioned in Chapter 2, a good internationalization
shortcut is to use a single source-code base for all language
editions of a program. This means that all language editions are
built from the same source files, but it can also mean that all
language editions share some or all of the executable code. With
a fully run-time DBCS-enabled code base, any language edition can
handle double-byte characters when running on a DBCS edition of
the operating system. A user can run an English application on a
Japanese edition of Windows, freely typing in and editing kanji
strings without problems. For example, Microsoft Visual C++ 2's
integrated editing environment is fully DBCS-enabled. If you run
Visual C++ 2 on Japanese Windows, you can put kanji literal
characters and strings in your source files. The following is an
example of fully run-time DBCS-enabled code:</p>

<p><font size="2" face="Courier New">// an example of a fully
run-time DBCS-enabled function<br>
int charcount (char *pszStr)<br>
{<br>
int count;<br>
for (count = 0; *pszStr; pszStr = CharNext(pszStr))<br>
++count;<br>
return count;<br>
}</font></p>

<p>This might seem like a great scheme at first glance, but
constantly calling the system API <i>CharNext</i> in the inner
loop is needlessly expensive, especially when the application is
running on a non-DBCS platform. (How many French users will
actually run your program on a Japanese edition of Windows?) Not
only will the code be less efficient, but it will have to contain
buffers that are twice as large in order to hold DBCS characters.</p>

<p><b>Run-Time Optimization</b></p>

<p>If having fully run-time DBCS-enabled code is important,
optimization can help. One option for run-time optimization is to
sidetrack the system by writing your own edition of <i>CharNext,</i>
using information about the code page provided by the Win32 API <i>GetCPInfo</i>.
The example in Figure 3-6 avoids the overhead of making a system
call in the inner loop and uses an inline function to keep code
readable.</p>

<p><font size="2" face="Courier New">CPINFO CPInfo; // a
Windows-defined structure for code-page info<br>
BYTE *vbLBRange; // table of lead-byte range values, which can
vary<br>
// in length depending on the code page<br>
BOOL vfDBCS; // Are we running on a DBCS edition of Windows?<br>
<br>
{<br>
// ...somewhere in the initialization code...<br>
GetCPInfo(CP_ACP, &amp;CPInfo);<br>
vbLBRange = CPInfo.LeadByte;<br>
vfDBCS = (CPInfo.MaxCharSize &gt; 1); // Is the max length in
bytes of<br>
// a character in this code<br>
// page more than 1?<br>
}<br>
<br>
...<br>
<br>
inline char* MyCharNext (char *pszStr)<br>
{ <br>
BYTE bRange = O;<br>
<br>
// Check to see whether *pszStr is a Lead Byte-. The constant 12 <br>
// allows for up to 6 pairs of lead-byte range values.<br>
while ((bRange &lt; 12) &amp;&amp; (vbLBRange[bRange] != NULL))<br>
{<br>
if ((*pszStr &gt;= vbLBRange[bRange]) &amp;&amp; <br>
(*pszStr &lt;= vbLBRange[bRange+1])) <br>
return (pszStr + 2); // Skip two bytes.<br>
<br>
bRange += 2; // Go to the next pair of range values.<br>
}<br>
<br>
return (pszStr + 1); // Skip one byte.<br>
}</font></p>

<P><b>Figure 3-6</b> <i>By writing your own version of
CharNext you optimize performance by avoiding the need to call
the system for a heavily used operation.</i></p>

<p>A further optimization would be to make DBCS-related calls
only when the program is running on a DBCS platform. (See Figure
3-7.) You'll find that this amount of effort pays off only with
code that's called the most frequently.</p>

<p><font size="2" face="Courier New">// fully DBCS-enabled code<br>
int charcount (char *pszStr)<br>
{<br>
int count;<br>
if (vfDBCS)<br>
{<br>
for (count = 0; *pszStr; pszStr = MyCharNext(pszStr))<br>
++count;<br>
}<br>
else<br>
{<br>
for (count = 0; *pszStr; pszStr++)<br>
++count;<br>
}<br>
<br>
return count;<br>
}</font></p>

<P><b>Figure 3-7</b> <i>Making DBCS-related calls only
when a program runs on a DBCS platform enhances the performance
of frequently called code.</i></p>

<p><b>Dual Compilation</b></p>

<p>Another widely used approach to DBCS enabling is dual
compilation. Sections of string-handling code bracketed by</p>

<p><font size="2" face="Courier New">#ifdef DBCS<br>
...<br>
#else<br>
...<br>
#endif</font></p>

<p>allow you to use one set of source code files and substitute
code using a compile-time switch. With this approach, the
DBCS-enabled code doesn't affect your program when it's compiled
with the DBCS switch off, which is a great advantage. The main
disadvantage of this method is that in effect it creates a dual
code base that you have to compile, test, and maintain
separately. An example of this approach is shown below.</p>

<p><font size="2" face="Courier New">int charcount (char *pszStr)<br>
{<br>
int count;<br>
#ifndef DBCS<br>
for (count = 0; *pszStr; pszStr++)<br>
#else<br>
for (count = 0; *pszStr; pszStr = CharNext(pszStr))<br>
// (or you could use MyCharNext)<br>
#endif <br>
++count; <br>
return count;<br>
}</font></p>

<p><b>Macros and Inline Functions</b></p>

<p>You could greatly reduce the number of #ifdef DBCS blocks (and
greatly increase the ease of maintaining the code) by defining
several macros.</p>

<p><font size="2" face="Courier New">#ifndef DBCS<br>
#define CharNext(pc) ((*pc) ? pc + 1 : pc)<br>
#define CharPrev(pcStart, pc) ((pc &gt; pcStart) ? pc - 1 :
pcStart)<br>
<br>
#ifndef WIN32<br>
#define IsDBCSLeadByte (bByte) (FALSE)<br>
#endif<br>
#endif<br>
<br>
// The macro Dbcs can surround code that is DBCS-only.<br>
#ifdef DBCS<br>
#define Dbcs (x) (x)<br>
#else<br>
#define Dbcs (x) // Do nothing.<br>
#endif</font></p>

<p>Visual C++ developers can sometimes use inline functions
instead of macros, thus gaining the benefit of easy code
maintenance without the potential traps that come with simple
text substitution.</p>

<p>Notice that because the sample code in Figure 3-6 above calls <i>GetCPInfo,</i>
it will work on any Far East edition of Windows. Unfortunately, a
large body of existing software uses the values in the above
Figure 3-5 to hard-code lead-byte or trail-byte ranges and thus
has to be edited and recompiled to work for different DBCS code
pages. Keep these functions in mind as you try to spare yourself
additional work.</p>
</FONT></BODY>
</html>
