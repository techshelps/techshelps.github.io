<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">

<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Unicode Data Conversion</title>
<style>@import url(../msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="../msdn_ie3.css"></HEAD>

<BODY bgcolor="#FFFFFF">

<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

<h2>Unicode Data Conversion</h2>

<P><b>Glossary</b></p>

<ul>
    <li><b>Boundary:</b> The point of interaction between systems
        or applications that use different character encodings.</li>
</ul>

<p>In the foreseeable future, programs must be ready for a world
in which some data is encoded using Unicode and some data is
encoded using existing character sets. This section describes a
function that converts text files to Unicode or Unicode files to
ANSI-based text. The code follows the guidelines for generic
coding presented at the end of this chapter. It can be used both
in programs that are compiled for Unicode and in programs that
are not. At the heart of the program is a function called <i>Convert</i>
that takes three arguments: a code-page ID and two filenames.
Assuming that the file UNICODE.TXT contained Unicode text, the
following line of code would convert text in the file UNICODE.TXT
to the current ANSI character set (designated as CP_ACP):</p>

<p><font size="2" face="Courier New">Convert( CP_ACP,
&quot;UNICODE.TXT&quot;, &quot;ANSI.TXT&quot; );</font></p>

<p>If the file ANSI.TXT contained ANSI text, the following line
of code would do the reverse:</p>

<p><font size="2" face="Courier New">Convert( CP_ACP,
&quot;ANSI.TXT&quot;, &quot;UNICODE.TXT&quot; );</font></p>

<p><i>Convert</i> uses the Win32 function <i>IsTextUnicode</i> to
determine whether the input file is in Unicode. The easiest
method of converting a file places both input and output files
into simple buffers in memory&#151;a process called memory
mapping. The C++ class shown below wraps the few calls needed to
set this up under Win32. C++ organizes the set of files and view
handles well.</p>

<p><font size="2" face="Courier New">class CMapFile<br>
{<br>
public:<br>
CMapFile(LPTSTR lpFilename, // opens/creates a file<br>
BOOL fWriteable, // and maps a view<br>
DWORD &amp;dwSize);<br>
~CMapFile(); // unmaps the view and <br>
// closes the file<br>
<br>
void Truncate(DWORD dwSize) // file is truncated at file <br>
{ _dwSize = dwSize; }; // close to the new size<br>
<br>
PBYTE_Buff; // pointer to the buffer to which the<br>
// file is mapped in memory<br>
private:<br>
// These variables contain the handles and pointers<br>
// associated with the file and a mapped view of the file.<br>
HANDLE _hFile; // file handle<br>
HANDLE _hMapFile; // handle for mapped view<br>
BOOL _fWriteable; // TRUE for output file<br>
DWORD _dwSize; // size of file<br>
};</font></p>

<p>To create a pointer to a buffer that contains the entire file,
we need to create an object of class <i>CMapFile:</i></p>

<p><font size="2" face="Courier New">CMapFile
mapFile(TEXT(&quot;UNICODE.TXT&quot;), FALSE, 0L);</font></p>

<p><font size="2" face="Courier New">and access its pointer
variable <i>_Buff</i> via <i>mapFile-&gt;_Buff.</i></font></p>

<p>The constructor for <i>CMapFile,</i> shown below, takes care
of opening the file, creating a file mapping of the desired size
(a size of 0 means the whole file), and mapping a view. It
updates the <i>dwsize</i> parameter with the actual size of the
file.</p>

<p><font size="2" face="Courier New">CMapFile :: CMapFile(LPTSTR
lpFilename, BOOL fWriteable,<br>
DWORD &amp;dwSize)<br>
{<br>
_Buff = NULL;<br>
_fWriteable = fWriteable;<br>
<br>
// Open a file for read or create a file for read/write.<br>
<br>
_hFile = (HANDLE) CreateFile(lpFilename,<br>
_fWriteable ?<br>
GENERIC_READ | GENERIC_WRITE :<br>
GENERIC_READ,<br>
0, // exclusive access<br>
0L, // no security <br>
_fWriteable ?<br>
CREATE_ALWAYS : OPEN_EXISTING, <br>
FILE_ATTRIBUTE_NORMAL,<br>
0L); // no template file <br>
<br>
if ((DWORD)_hFile == 0xFFFFFFFF) goto error;<br>
<br>
// Create a file mapping that is either read or read/write.<br>
<br>
_hMapFile = CreateFileMapping(_hFile,<br>
NULL, // no security attributes<br>
_fWriteable ? PAGE_READWRITE:PAGE_READONLY,<br>
0L, // high size DWORD<br>
dwSize, // low size DWORD<br>
NULL); // no name <br>
<br>
if (!_hMapFile) goto error;<br>
<br>
// Create a mapped view that is either read or read/write.<br>
<br>
_Buff = (PBYTE) MapViewOfFile(_hMapFile,<br>
fWriteable ?<br>
FILE_MAP_WRITE : FILE_MAP_READ,<br>
0L, // zero offset <br>
0L,<br>
dwSize);<br>
<br>
if (!_Buff) goto error;<br>
<br>
// Obtain and return the size of the file opened.<br>
<br>
if ((!dwSize) &amp;&amp; 0xFFFFFFFF == (dwSize =
GetFileSize(_hFile,<br>
NULL)))<br>
goto error;<br>
<br>
_dwSize = dwSize;<br>
return;<br>
<br>
error:<br>
ReportError();<br>
return;<br>
}</font></p>

<p>When you are finished with the mapped view, the destructor
will unmap the view, close the handle, truncate the file to the
requested size (if it was writeable), and close the file. If <i>mapFile</i>
is created as an automatic object on the stack, the destructor
for <i>CMapFile</i> will be called automatically when the
variable <i>mapFile </i>goes out of scope. This way you can't
forget to clean up.</p>

<p><font size="2" face="Courier New">CMapFile :: ~CMapFile()<br>
{<br>
DWORD dwErrCode=0;<br>
<br>
UnmapViewOfFile(_Buff); // Unmap the output file.<br>
CloseHandle(_hMapFile); // Close the handle to the file mapping.<br>
if (_fWriteable)<br>
{ // Attempt to truncate the file.<br>
if (_dwSize != SetFilePointer(_hFile,<br>
_dwSize, // low 32 bits<br>
0L, // high 32 bits<br>
FILE_BEGIN))<br>
ReportError();<br>
<br>
if (!SetEndOfFile(_hFile))<br>
ReportError();<br>
}<br>
CloseHandle(_hFile); // Close the file.<br>
}</font></p>

<p>A nifty way to handle all of the error reporting&#151;a method
that will work in any language&#151;is to use <i>FormatMessage</i>
to retrieve a localized message from the system message table, as
in this error-reporting function:</p>

<p><font size="2" face="Courier New">void ReportError()<br>
{<br>
LPTSTR lpMessage;<br>
DWORD dwErrCode = GetLastError();<br>
FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |<br>
FORMAT_MESSAGE_FROM_SYSTEM,<br>
NULL, // no source buffer needed<br>
dwErrCode, // error code for this message<br>
NULL, // default language ID<br>
(LPTSTR)&amp;lpMessage, // allocated by fcn<br>
NULL, // minimum size of buffer<br>
NULL); // no inserts<br>
<br>
MessageBox(NULL, lpMessage, TEXT(&quot;File Error&quot;),<br>
MB_ICONSTOP | MB_OK );<br>
}</font></p>

<p><i>IsTextUnicode</i> tests whether a text file is prefixed by
a BOM, but because the BYTE_ORDER_MARK is not part of the data to
be converted, the following function steps over it before
translation begins:</p>

<p><font size="2" face="Courier New">#define BYTE_ORDER_MARK
0xFEFF<br>
<br>
LPVOID IsFileMarkedUnicode( LPWSTR lp, DWORD &amp;dwSize )<br>
{<br>
if ( dwSize &gt; sizeof(WCHAR) )<br>
{<br>
if ( *lp == BYTE_ORDER_MARK )<br>
{<br>
dwSize -= sizeof(WCHAR);<br>
lp++;<br>
}<br>
}<br>
return lp;<br>
}</font></p>

<p>The next function does the reverse&#151;it marks a Unicode
output file with a BYTE_ORDER_MARK. It initializes the buffer
with 0xFEFF and adjusts the buffer size and pointer.</p>

<p><font size="2" face="Courier New">LPVOID MarkFileUnicode(
LPWSTR lp, DWORD &amp;dwSize )<br>
{<br>
if ( dwSize &gt; sizeof(WCHAR) )<br>
{<br>
*lp = BYTE_ORDER_MARK;<br>
dwSize -= sizeof(WCHAR); // size of buffer is reduced by one <br>
// character<br>
lp++;<br>
}<br>
return lp;<br>
}</font></p>

<p>Now you are ready to pull it all together in the function <i>Convert,</i>
shown on the following page. <i>Convert</i> performs the
following tasks:</p>

<ul>
    <li>Opens and maps the input file by creating a <i>CMapFile</i>
        object as a local variable</li>
    <li>Applies a heuristic check by calling <i>IsTextUnicode</i></li>
    <li>Estimates an upper bound on the size of the output file</li>
    <li>Creates and maps the output file by creating a <i>CMapFile</i>
        object as a local variable</li>
    <li>Converts the data</li>
    <li>Truncates the output file</li>
    <li>Cleans up implicitly by calling the destructors for the <i>CMapFile</i>
        objects when they go out of scope</li>
</ul>

<p><font size="2" face="Courier New">void Convert(UINT iCodePage,
LPTSTR lpInFile, LPTSTR lpOutFile)<br>
{<br>
DWORD dwSizeIn, dwSizeOut;<br>
<br>
dwSizeIn = 0L; // Use the full size for input file.<br>
<br>
// Memory map the input file and obtain its actual size in bytes.<br>
<br>
CMapFile mapIn( lpInFile, FALSE, dwSizeIn );<br>
<br>
if ( mapIn._Buff &amp;&amp; dwSizeIn )<br>
{<br>
<br>
/* Analyze the input buffer for presence of BOM marker and<br>
* step over it if Unicode is the input file or<br>
* prepend BOM marker if Unicode is the output file.<br>
* Size is reduced and pointers are adjusted as needed.<br>
*/<br>
<br>
dwSizeOut = dwSizeIn;<br>
<br>
if (IsTextUnicode(mapIn._Buff, dwSizeIn, NULL))<br>
{<br>
LPWSTR lpInBuff = <br>
(LPWSTR)<br>
IsFileMarkedUnicode((LPWSTR)mapIn._Buff, dwSizeIn);<br>
<br>
// Create an output file of the maximum size needed.<br>
<br>
CMapFile mapOut( lpOutFile, TRUE, dwSizeOut );<br>
<br>
if (mapOut._Buff)<br>
{<br>
// Perform the actual conversion.<br>
<br>
BOOL bUsedDef = TRUE;<br>
<br>
dwSizeOut = WideCharToMultiByte(iCodePage,<br>
WC.COMPOSITECHECK | WC_DEFAULTCHAR, // default mapping<br>
lpInBuff,<br>
dwSizeIn/sizeof(WCHAR), // number of wide characters <br>
(LPSTR) mapOut._Buff,<br>
dwSizeOut, // number of bytes written<br>
&quot;\x7f&quot;, // use DEL as default char <br>
&amp;bUsedDef); // was default char used<br>
// Truncate the output file to its actual length.<br>
mapOut.Truncate(dwSizeOut);<br>
}<br>
}<br>
else <br>
{<br>
<br>
// Create an output file of the maximum size needed.<br>
dwSizeOut = (dwSizeIn+1) * sizeof(WCHAR);<br>
CMapFile mapOut( lpOutFile, TRUE, dwSizeOut );<br>
<br>
if (mapOut._Buff)<br>
{<br>
// Write a Byte Order Mark.<br>
LPWSTR lpOutBuff = (LPWSTR) <br>
MarkFileUnicode((LPWSTR) mapOut._Buff, dwSizeOut);<br>
// Perform the actual conversion.<br>
dwSizeOut = MultiByteToWideChar(iCodePage,<br>
MB_COMPOSITE | MB_USEGLYPHCHARS, <br>
(LPSTR) mapIn._Buff, // input buffer<br>
dwSizeIn, // length of input in bytes<br>
lpOutBuff, // output buffer<br>
dwSizeOut); // max number of wchars to write<br>
// Truncate the output file to its actual length.<br>
mapOut.Truncate((dwSizeOut+1) * sizeof(WCHAR));<br>
}<br>
}<br>
<br>
if ( !dwSizeOut )<br>
{<br>
ReportError();<br>
}<br>
}<br>
}</font></p>

<p>If there is no BOM in the file, <i>IsTextUnicode</i> can still
recognize Unicode data by performing several heuristic checks.
Since the checks aren't perfect, it's usually best to let the
user confirm the choice made by the function. Even if the file
type is recognized correctly, the data might not be converted
from Unicode if the input file contains characters that cannot be
expressed in the code page of the output file. In this situation,
<i>WideCharToMultiByte</i> can substitute a default character. <i>Convert</i>
uses this option, but substituting the default character is not
always the right answer. For example, if a filename entered in
Unicode cannot be translated to the code page used in the
directory structure of a FAT file system floppy disk, you should
instead raise an error condition. Using the Windows default
character <i>?</i> in a filename might result in a file named
????????.???&#151;a bad idea.</p>
</FONT></BODY>
</html>
