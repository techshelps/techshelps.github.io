<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">

<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DBCS-Enabled Programs vs. Non-DBCS-Enabled Programs</title>
<style>@import url(../msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="../msdn_ie3.css"></HEAD>

<BODY bgcolor="#FFFFFF">

<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

<h2>DBCS-Enabled Programs vs. Non-DBCS-Enabled Programs</h2>

<H3><b>Glossary</b></h3>

<ul>
    <li><b>Big-5:</b> The multibyte encoding standardized by
        Taiwan.</li>
    <li><b>GB 2312-80:</b> The multibyte encoding standardized by
        the People's Republic of China.</li>
    <li><b>KS C-5601-1987:</b> The multibyte Wansung encoding
        standardized by Korea.</li>
    <li><b>KS C-5601-1992:</b> The multibyte Johab encoding
        standardized by Korea.</li>
</ul>

<p>If you have both the US and the Japanese edition of Windows
95, you can compare incorrect DBCS behavior with correct DBCS
behavior using Microsoft Wordpad. The edition of Wordpad that
comes with the US edition of Windows 95 is not DBCS-enabled, as
you'll find out if you try running it on the Japanese edition of
Windows 95. Open a file containing Japanese text, such as a
README file, and attempt to do some basic editing. If you press
the Left or Right arrow key, press Backspace, or click around
with the mouse, you'll notice that the insertion point improperly
bisects all full-width characters. To activate the Input Method
Editor (IME) on the Japanese edition of Windows 95, press Alt+~.
(See <font class="MissingLink" meta="dev0j">Chapter 7</font> for more information on how to use IMEs.) Try
inserting and deleting characters in random places. If you add or
delete a half-width character, full-width characters in the
string might shift by 1 byte. This can cause bizarre behavior, as
demonstrated in Figure 3-4.</p>

<table border="0" cellpadding="7" cols="2">
<COLGROUP><COL WIDTH="205pt" VALIGN="TOP"><COL WIDTH="205pt" VALIGN="TOP"></COLGROUP><TBODY>    <tr>
        <td valign="top"><img src="F03FD04A.gif" width="172"
        height="25"></td>
        <td valign="top">A phrase from a file containing Japanese
        text.</td>
    </tr>
    <tr>
        <td valign="top"><img src="F03FD04B.gif" width="171"
        height="31"></td>
        <td valign="top">When the user presses an arrow key, the
        cursor bisects DBCS characters.</td>
    </tr>
    <tr>
        <td valign="top"><img src="F03FD04C.gif" width="175"
        height="33"></td>
        <td valign="top">Selecting half of a DBCS character and a
        full-width katakana character.</td>
    </tr>
    <tr>
        <td valign="top"><img src="F03FD04D.gif" width="158"
        height="30"></td>
        <td valign="top">Hitting Delete. Oops.</td>
    </tr>
</TBODY></table>

<P><br>
</p>

<P><b>Figure 3-4</b> <i>Editing a DBCS file on Japanese
Windows 95 using the US edition of Wordpad.</i></p>

<p>Now open the same file using the Japanese edition of Wordpad
that comes with the Japanese edition of Windows 95. Try
performing some of the same operations you tried with the US
edition. You'll get a feel for why it's necessary to DBCS-enable
your Windows 95&#150;based code and why you can't simply ship
your US edition to the Far East. Imagine how frustrated users
would feel if your software behaved this badly when dealing with
double-byte characters.</p>

<p>Keeping Lead Byte's and trail bytes together requires some
coding vigilance. Strings that might contain double-byte
characters should be parsed from the beginning to the end not
from the end to the beginning. If a DBCS string is processed
backward, it's generally not possible to tell whether a byte is a
character by itself or the second half of a double-byte pair.
(See the section titled <font class="MissingLink" meta="dev10f">&quot;How to Go Backward in a DBCS
String&quot;</font> later in this chapter.) The Win32 API <i>CharPrev</i>
actually goes back to the beginning of DBCS strings and steps
through until it finds the previous character in question; going
forward is easier than going backward. The Windows API <i>IsDBCSLeadByte</i>
can be used to test whether a particular byte is in the default
code page's lead-byte range. (<i>IsDBCSLeadByteEx</i> allows you
to check the lead-byte range of a specified code page.) You can
process any single-byte character you find immediately. For
example, you can display it on the screen. If your program finds
a Lead Byte-, it must read the next byte before doing any further
processing. Figure 3-5 includes the lead-byte and trail-byte
ranges for the code pages used in the Far East editions of
Windows 95.</p>

<table border="0" cellpadding="7" cols="5">
    <tr>
        <td valign="top"><b><i><br>
        Language</i></b></td>
        <td valign="top"><em><strong>Character<br>
        Set Name</strong></em></td>
        <td valign="top"><em><strong>Code<br>
        Page</strong></em></td>
        <td valign="top"><em><strong>Lead-Byte<br>
        Ranges</strong></em></td>
        <td valign="top"><em><strong>Trail-Byte<br>
        Ranges</strong></em></td>
    </tr>
    <tr>
        <td valign="top">Chinese<br>
        (Simplified)</td>
        <td valign="top">GB 2312-80</td>
        <td valign="top">CP 936</td>
        <td valign="top">0xA1&#150;0xFE </td>
        <td valign="top">0xA1&#150;0xFE</td>
    </tr>
    <tr>
        <td valign="top">&nbsp;</td>
        <td valign="top">&nbsp;</td>
        <td valign="top">&nbsp;</td>
        <td valign="top">&nbsp;</td>
        <td valign="top">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top">Chinese<br>
        (Traditional)</td>
        <td valign="top">Big-5</td>
        <td valign="top">CP 950</td>
        <td valign="top">0x81&#150;0xFE </td>
        <td valign="top">0x40&#150;0x7E<br>
        0xA1&#150;0xFE</td>
    </tr>
    <tr>
        <td valign="top">&nbsp;</td>
        <td valign="top">&nbsp;</td>
        <td valign="top">&nbsp;</td>
        <td valign="top">&nbsp;</td>
        <td valign="top">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top">Japanese</td>
        <td valign="top">Shift-JIS (Japan<br>
        Industry Standard)</td>
        <td valign="top">CP 932</td>
        <td valign="top">0x81&#150;0x9F <br>
        0xE0&#150;0xFC</td>
        <td valign="top">0x40&#150;0xFC<br>
        (except 0x7F)</td>
    </tr>
    <tr>
        <td valign="top">&nbsp;</td>
        <td valign="top">&nbsp;</td>
        <td valign="top">&nbsp;</td>
        <td valign="top">&nbsp;</td>
        <td valign="top">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top">Korean <br>
        (Wansung)</td>
        <td valign="top">KS C-5601-1987</td>
        <td valign="top">CP 949</td>
        <td valign="top">0x81&#150;0xFE </td>
        <td valign="top">0x41&#150;0x5A<br>
        0x61&#150;0x7A<br>
        0x81&#150;0xFE</td>
    </tr>
    <tr>
        <td valign="top">&nbsp;</td>
        <td valign="top">&nbsp;</td>
        <td valign="top">&nbsp;</td>
        <td valign="top">&nbsp;</td>
        <td valign="top">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top">Korean <br>
        (Johab)</td>
        <td valign="top">KS C-5601-1992</td>
        <td valign="top">CP 1361</td>
        <td valign="top">0x84&#150;0xD3 <br>
        0xD8<br>
        0xD9&#150;0xDE<br>
        0xE0&#150;0xF9</td>
        <td valign="top">0x41&#150;0x7E<br>
        0x81&#150;0xFE<br>
        (Government<br>
        standard:<br>
        0x31&#150;0x7E<br>
        0x41&#150;0xFE)</td>
    </tr>
</TBODY></table>

<P><br>
</p>

<P><b>Figure 3-5</b><i> Lead-byte and trail-byte ranges
for code pages used in Far East editions of Windows 95.</i></p>

<p>When you are faced with the potential mix of single-byte and
double-byte characters it is no longer safe to use operators such
as ++ or --, which increment or decrement string pointers 1 byte
at a time. These operators can be replaced with the Win32 API
calls <i>CharNext</i> and <i>CharPrev</i> (<i>AnsiNext</i> and <i>AnsiPrev</i>
in 16-bit Windows 3.<i>x</i>), which increment pointers properly
whether the current character is single-byte or double-byte. In
the double-byte world, it is also dangerous to access a string
randomly, as in</p>

<p><font size="2" face="Courier New">char = string[i];</font></p>

<p>Look back at the sample string in Figure 3-3 above. The value
of samplestring[2] is 0x40, but it represents the second half of
a kanji character, not the &quot;at&quot; character (@).</p>
</FONT></BODY>
</html>
