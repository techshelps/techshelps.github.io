<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">

<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Changing the User Interface at Run Time</title>
<style>@import url(../msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="../msdn_ie3.css"></HEAD>

<BODY bgcolor="#FFFFFF">

<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

<h3>Changing the User Interface at Run Time</h3>

<p>On Windows NT, most standard resource calls retrieve resources
based on the language ID of the calling thread locale. (See
Figure 4-11.) Since Windows NT supports multiple-language
resources and allows you to change the thread locale setting, it
follows that programs running on Windows NT can change the
language of the user interface at any time. For example, you
could allow the user to change the user interface language with a
keyboard combination or a menu selection. Automatic teller
machines in many US cities have this function. If your user
interface contains dozens of dialog boxes and hundreds of
messages, it might not be possible to install several language
editions of the user interface without using up a lot of disk
space. In that case, you could allow the user to choose a user
interface language during installation. The setup program would
customize the default resources of the executable to a particular
language using the <i>UpdateResource</i> functions, which are
described in detail in the section titled &quot;Adding, Deleting,
and Replacing Resources&quot; in Volume 2 of the <i>Microsoft
Win32 Programmer's Reference.</i></p>

<table border="0" cellpadding="7" cols="3">
    <tr>
        <td valign="top">CreateDialog</td>
        <td valign="top">DialogBoxIndirectParam</td>
        <td valign="top">LoadCursor</td>
    </tr>
    <tr>
        <td valign="top">CreateDialogIndirect</td>
        <td valign="top">DialogBoxParam</td>
        <td valign="top">LoadIcon</td>
    </tr>
    <tr>
        <td valign="top">CreateDialogIndirectParam</td>
        <td valign="top">FindResource</td>
        <td valign="top">LoadMenu</td>
    </tr>
    <tr>
        <td valign="top">CreateDialogParam</td>
        <td valign="top"><i>FindResourceEx</i></td>
        <td valign="top">LoadResource</td>
    </tr>
    <tr>
        <td valign="top">CreateIconFromResource</td>
        <td valign="top"><i>FormatMessage</i></td>
        <td valign="top">LoadString</td>
    </tr>
    <tr>
        <td valign="top">DialogBox</td>
        <td valign="top">LoadAccelerators</td>
        <td valign="top">MessageBox</td>
    </tr>
    <tr>
        <td valign="top">DialogBoxIndirect</td>
        <td valign="top">LoadBitmap</td>
        <td valign="top"><i>MessageBoxEx</i></td>
    </tr>
</table>

<P><b>Figure 4-11.</b> <i>Standard Windows resource
calls. Functions in italics take a language ID as a parameter.
All others retrieve items based on the calling thread locale (on
Windows NT) or based on the default system locale (on Windows
95).</i></p>

<p>To change the user interface language at run time on Windows
NT, you need to either call API functions that let you specify a
language ID (shown in italics in Figure 4-11) or change the
thread locale setting with the function <i>SetThreadLocale.</i></p>

<p><font size="2" face="Courier New">BOOL rc =
SetThreadLocale(lcid);</font></p>

<p>Only Windows NT supports <i>SetThreadLocale</i> and <i>GetThreadLocale</i>.
You'll need to explore other mechanisms to change the user
interface at run time for Windows 95&#150;based applications. The
section titled <font class="MissingLink" meta="dev12g">&quot;Multiple-Language DLLs&quot;</font> discusses one
alternative.</p>

<p>Regardless of whether a user can select a user interface
language for your program only during installation or can change
it at run time, your program will need to tell the user which
language choices are available. Win32 provides the function <i>EnumResourceLanguages,</i>
which enumerates all language IDs associated with a given
resource type and resource ID. To create a list of available
languages, pick a resource that exists in all sets of language
resources and enumerate the language IDs associated with it. The
sample procedure <i>MyFindAllLanguages</i> below shows the syntax
for calling <i>EnumResourceLanguages</i>.</p>

<p><b>Message Boxes</b></p>

<p>Message boxes make it convenient for you to display error
messages in a dialog box without having to create dozens of
individual dialog templates. The system creates a message box
based on title bar text and message text supplied by the program.
Windows provides several standard combinations of predefined
buttons and icons. (See Figures 4-12 and 4-13.)</p>

<table border="0" cellpadding="7" cols="3">
    <tr>
        <td valign="top"><b><i>Icon Type</i></b></td>
        <td valign="top"><em><strong>Windows NT</strong></em></td>
        <td valign="top"><em><strong>Windows 95</strong></em></td>
    </tr>
    <tr>
        <td valign="top">&nbsp;</td>
        <td valign="top">&nbsp;</td>
        <td valign="top">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top">Exclamation point<br>
        (for warning messages)</td>
        <td valign="top"><img src="F04FD12A.gif" width="45"
        height="49"></td>
        <td valign="top"><img src="F04FD12B.gif" width="38"
        height="41"></td>
    </tr>
    <tr>
        <td valign="top">&nbsp;</td>
        <td valign="top">&nbsp;</td>
        <td valign="top">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top">Stop sign/Do not enter<br>
        (for critical messages)</td>
        <td valign="top"><img src="F04FD12C.gif" width="40"
        height="40"></td>
        <td valign="top"><img src="F04FD12D.gif" width="43"
        height="43"></td>
    </tr>
    <tr>
        <td valign="top">&nbsp;</td>
        <td valign="top">&nbsp;</td>
        <td valign="top">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top">Question mark<br>
        (for messages that require a <i>Yes</i> or <i>No</i>
        answer)</td>
        <td valign="top"><img src="F04FD12E.gif" width="42"
        height="48"></td>
        <td valign="top"><img src="F04FD12F.gif" width="36"
        height="40"></td>
    </tr>
</TBODY></table>

<P><br>
</p>

<P><b>Figure 4-12.</b> <i>Message-box icons predefined
by Windows NT and Windows 95.</i></p>

<table border="0" cellpadding="7" cols="2">
    <tr>
        <td valign="top"><b><i>Constant</i></b></td>
        <td valign="top"><em><strong>Message-Box Buttons</strong></em></td>
    </tr>
    <tr>
        <td valign="top">MB_ABORTRETRYIGNORE</td>
        <td valign="top">Abort, Retry, <i>and</i> Ignore</td>
    </tr>
    <tr>
        <td valign="top">MB_OK</td>
        <td valign="top">OK</td>
    </tr>
    <tr>
        <td valign="top">MB_OKCANCEL</td>
        <td valign="top">OK <i>and</i> Cancel</td>
    </tr>
    <tr>
        <td valign="top">MB_RETRYCANCEL</td>
        <td valign="top">Retry<i> and</i> Cancel</td>
    </tr>
    <tr>
        <td valign="top">MB_YESNO</td>
        <td valign="top">Yes<i> and</i> No</td>
    </tr>
    <tr>
        <td valign="top">MB_YESNOCANCEL</td>
        <td valign="top">Yes, No, <i>and</i> Cancel</td>
    </tr>
</TBODY></table>

<P><br>
</p>

<P><b>Figure 4-13</b><i> Predefined Windows button
combinations.</i></p>

<p>The system handles the display of the dialog box and passes
the application a flag indicating which button the user clicks to
close the dialog box. You can call either <i>MessageBox</i> or <i>MessageBoxEx</i>
to create a message box. <i>MessageBoxEx</i> takes an additional
parameter&#151;a language ID&#151;that allows you to specify the
language of the text in the predefined buttons. Currently Windows
provides buttons only in the language of the system user
interface, but future versions of Windows will probably provide
additional translations.</p>

<p><b>Multiple-Language DLLs</b></p>

<p>Including multiple-language resources in an executable is
convenient for small programs but might prove impractical for
programs with large user interfaces. (You'd have to ship your
product on CD-ROM to customers who had enormous hard drives.) An
alternative is to isolate a program's user interface in a DLL
that can be localized into different editions. Putting
multiple-language resources into DLLs makes an application more
extensible than if you linked everything into a single
executable. A single executable supports a fixed number of
languages, whereas additional DLLs can be released at any time.
You could even sell localized user interface packages as separate
add-on products.</p>

<p>You can create a mechanism for switching the user interface
language during installation or at run time by giving each
language edition of a DLL a unique filename. Distinct names are
necessary because Windows cannot distinguish between two DLLs
with the same module name, even if they contain resources in
different languages. For example, you could incorporate the
ISO-defined, three-letter abbreviation for the appropriate
language into the filename. The sample code below, for Windows
NT, attempts to load a user interface DLL that corresponds to a
locale ID passed into the procedure. It constructs a DLL filename
by calling <i>GetLocaleInfo</i> on the locale ID.</p>

<p>If the sample function <i>LoadLanguage</i> finds a DLL, it
stores the DLL's module handle in the static global variable <i>hModRes</i>.
The program passes this variable as the first parameter to
functions such as <i>LoadString</i> and <i>EnumResourceLanguages</i>
so that the functions will access the resources contained in the
correct DLL. Usually the first parameter to such functions is
NULL, indicating that the current executable file contains the
resources.</p>

<p><font size="2" face="Courier New">///////////////////////////////<br>
// LoadLanguage<br>
//<br>
// Load a language module. This function assumes that the
language<br>
// modules are DLLs and that those DLLs are named using
three-letter<br>
// abbreviations for a language name (for example, deu==German) <br>
// stored in the Windows system registry.<br>
//<br>
// If the function cannot find a DLL that corresponds exactly to
the<br>
// LCID, it attempts to load any DLL associated with the same
primary // language.<br>
//<br>
// LoadLanguage returns TRUE if a module is loaded successfully;
else // it returns FALSE.<br>
<br>
static HANDLE hModRes;<br>
BOOL LoadLanguage(LCID lcid) // locale ID<br>
{<br>
SetThreadLocale(lcid); // change thread locale; Windows NT only<br>
<br>
TCHAR lpszLang[4];<br>
<br>
GetLocaleInfo(lcid, LOCALE_SABBREVLANGNAME, lpszLang, 4);<br>
<br>
if ( (int)(hModRes = LoadLibrary(lpszLang)) &lt; 32 )<br>
{<br>
// Search for any sublanguage.<br>
lcid = MAKELANGID(PRIMARYLANGID(lcid), SUBLANG_DEFAULT);<br>
GetLocaleInfo(lcid, LOCALE_SABBREVLANGNAME, lpszLang, 4);<br>
<br>
if ( (int)(hModRes = LoadLibrary(lpszLang)) &lt; 32 )<br>
{<br>
hModRes = NULL; // not found; use EXE file for resources<br>
return (FALSE);<br>
}<br>
}<br>
return (TRUE); // If we got here, we found a DLL for the<br>
// requested language.<br>
}</font></p>

<p>Occasionally, a user moves or deletes a file. To ensure that
your program always has a working user interface, you can bind
one set of language resources into the executable and use DLLs
only for additional languages, or you can bind in a single error
message telling the user that the user interface module is
missing.</p>

<p>The sample code below searches for all possible language
resources contained in both the current executable and possible
DLL files and builds a list box that displays the possible user
interface language choices to the user. It uses the <i>FindFirstFile</i>
and <i>FindNextFile</i> API functions to search for DLLs named
with three-letter ISO codes. Once the user selects a language,
the program calls the <i>LoadLanguage</i> function described
earlier to load the appropriate DLL. Both <i>EnumResLangProc</i>
and <i>EnumResourceLanguages</i> are fully documented in the
Windows API Quick Reference topics of the same names.</p>

<p><font size="2" face="Courier New">/////////////////////<br>
// struct for use by MyFindAllLanguages and EnumResLangProc<br>
<br>
typedef struct _tagLBData{ // list box data<br>
<br>
HWND hWnd; // handle to window/dialog box<br>
// containing the list box<br>
int nListBox; // ID of the list box to fill<br>
DWORD dwErrCode; // reason for failure of EnumResLangProc<br>
} LBDATA, *PLBDATA;<br>
<br>
#define NAMESTART 12 // offset to filename in list box item <br>
// string (list box item strings will<br>
// not be translated)<br>
<br>
/////////////////////<br>
// The following code will locate all the available languages for
a <br>
// resource, whether you are using resources in separate DLLs,<br>
// resources in the EXE, or both. This example assumes that the
DLLs <br>
// follow the naming convention from the earlier example. With a <br>
// sufficiently unique combination of resource name and type as a
<br>
// flag, you can search for your DLLs anywhere on the path.<br>
<br>
BOOL CALLBACK EnumResLangProc(<br>
HMODULE hModule, // resource-module handle <br>
LPCTSTR lpszType, // address of resource type <br>
LPCTSTR lpszName, // address of resource name <br>
LANGID wIDLanguage, // resource language identifier<br>
LPARAM lParam) // application-defined <br>
// parameter <br>
{<br>
PLBDATA pLBData = (PLBDATA)lParam;<br>
static TCHAR szItemText[NAMESTART + MAX_PATH];<br>
<br>
// Display language ID components in the list box text. The <br>
// format of the text will be: &quot;PriLang SubLang -
FileName&quot;.<br>
<br>
wsprintf(szItemText, TEXT(&quot;%#02x %#02x - &quot;), <br>
PRIMARYLANGID(wIDLanguage),<br>
SUBLANGID(wIDLanguage));<br>
<br>
// Append the name of the file containing the resource.<br>
if (0 &lt; GetModuleFileName(hModule, <br>
&amp;szItemText[ lstrlen(szItemText) ], <br>
MAX_PATH))<br>
{<br>
// Add the line to the list box.<br>
SendDlgItemMessage(pLBData-&gt;hWnd, pLBData-&gt;nListBox, <br>
LB_ADDSTRING, 0, (LPARAM)szItemText);<br>
}<br>
else<br>
{ // Send reason for the failure of the call to GetModuleFileName<br>
// back to our caller.<br>
pLBData-&gt;dwErrCode = GetLastError();<br>
}<br>
// If this call failed, cause the enumeration process in <br>
// EnumResourceLanguages to halt.<br>
return (pLBData-&gt;dwErrCode == ERROR_SUCCESS ? TRUE : FALSE);<br>
}<br>
<br>
///////////////////////////<br>
// MyFindAllLanguages<br>
//<br>
// Fill the given list box with the languages in which the given <br>
// resource is available. This function will add the data to the <br>
// given list box. No assumption is made about any of the list
box's<br>
// attributes (such as whether it is sorted). This function<br>
// first empties the list box.<br>
//<br>
// MyFindAllLanguages returns ERROR_SUCCESS if successful or <br>
// results of GetLastError() if unsuccessful.<br>
<br>
DWORD MyFindAllLanguages( <br>
HWND hWnd, // handle to window or dialog box<br>
// containing the list box<br>
int nListBox, // ID number of the list box to fill<br>
LPCTSTR lpszType, // name or ID number of resource<br>
// type to be enumerated<br>
LPCTSTR lpszName) // name or ID number of resource<br>
// name to be enumuerated<br>
{<br>
// Make sure the list box is empty.<br>
SendDlgItemMessage(hWnd, nListBox, LB_RESETCONTENT, 0, 0);<br>
<br>
LBDATA LBData;<br>
LBData.hWnd = hWnd; // Fill in the LBData fields<br>
LBData.nListBox = nListBox; // so the data gets sent to <br>
// EnumResLangProc.<br>
<br>
LBData.dwErrCode = ERROR_SUCCESS; // Assume we will be <br>
// successful.<br>
<br>
WIN32_FIND_DATA ffd; // for info from FindFirstFile and <br>
// FindNextFile<br>
HANDLE hFind = FindFirstFile(TEXT(&quot;???.DLL&quot;),
&amp;ffd);<br>
<br>
if (hFind != INVALID_HANDLE_VALUE)<br>
{<br>
do<br>
{<br>
HINSTANCE hModule = LoadLibraryEx(ffd.cFileName, hFind,<br>
LOAD_LIBRARY_AS_DATAFILE);<br>
<br>
if ( !EnumResourceLanguages(hModule, // Look in the DLL.<br>
lpszType, // given resource type<br>
lpszName, // given resource name<br>
(ENUMRESLANGPROC) // address of<br>
EnumResLangProc, // callback function<br>
(LPARAM) &amp;LBData) ) // application-defined <br>
// parameter<br>
{<br>
LBData.dwErrCode = GetLastError();<br>
}<br>
FreeLibrary(hModule);<br>
} while (LBData.dwErrCode == ERROR_SUCCESS &amp;&amp; <br>
FindNextFile(hFind, &amp;ffd) );<br>
<br>
FindClose( hFind );<br>
}<br>
else<br>
{<br>
LBData.dwErrCode = GetLastError();<br>
}<br>
<br>
if (LBData.dwErrCode == ERROR_SUCCESS ||<br>
LBData.dwErrCode == ERROR_FILE_NOT_FOUND )<br>
{<br>
LBData.dwErrCode = ERROR_SUCCESS;<br>
<br>
if ( !EnumResourceLanguages( NULL, // Look in the current EXE.<br>
lpszType, // given resource type<br>
lpszName, // given resource name<br>
(ENUMRESLANGPROC) // address of<br>
EnumResLangProc, // callback function<br>
(LPARAM) &amp;LBData) ) // application-defined<br>
{ // parameter<br>
LBData.dwErrCode = GetLastError();<br>
}<br>
}<br>
return (LBData.dwErrCode);<br>
}</font></p>
</FONT></BODY>
</html>
