<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">

<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Storing Strings</title>
<style>@import url(../msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="../msdn_ie3.css"></HEAD>

<BODY bgcolor="#FFFFFF">

<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

<h3>Storing Strings</h3>

<P><b>Glossary</b></p>

<ul>
    <li><b>Message table: </b>A Win32 resource that uses
        sequential numbers rather than escape letters to mark
        replacement parameters, making it convenient to store
        alert messages and error messages that contain several
        replacement parameters.</li>
</ul>

<p>Win32 supports two resource types for storing strings: string
tables and message tables. String tables make sense for short
strings and for strings containing only one replacement
parameter; message tables are more convenient for alert and error
messages that contain more than one replacement parameter.
(Message tables support up to 99 parameters.) The <i>FormatMessage</i>
API function will substitute variables according to each place
marker's numeric label and not according to its position in the
string. Localizers can freely change a string's word order and <i>FormatMessage</i>
will still return correct results. (See Figure 4-7.) The message
table file format is not complicated; you can create message
tables with a simple text editor.</p>

<p><font size="2" face="Courier New">// SAMPLE.MC<br>
LanguageNames=(German=2:msg00002)<br>
<br>
MessageId=1 SymbolicName=IDS_NOFILE<br>
Language=English<br>
Cannot open file %1<br>
.<br>
Language=German<br>
Die Datei %1 kann nicht geöffnet werden.<br>
.<br>
.<br>
MessageId=2 SymbolicName=IDS_OTHERIMAGE<br>
Language=English<br>
%1 is a %2 image.<br>
.<br>
Language=German<br>
%2-Abbild ein %1 ist.<br>
.</font></p>

<P><b>Figure 4-7.</b> <i>A message table that contains
English and German translations of the same strings. Note that
the German translation of IDS_OTHERIMAGE reverses the positions
of the replacement parameters.</i><b><i> </i></b></p>

<P>The syntax for formatting the first message in
Figure 4-7 is as follows:</p>

<p><font size="2" face="Courier New">// lpBuf must be large
enough to hold the formatted message!<br>
DWORD langID = MAKELANGID(LANG_GERMAN, SUBLANG_GERMAN);<br>
HMODULE hModule = LoadLibrary(...);<br>
TCHAR lpBuf[60];<br>
LPVOID lppArgs[10];<br>
<br>
DWORD len = FormatMessage(FORMAT_MESSAGE_FROM_HMODULE |<br>
FORMAT_MESSAGE_ARGUMENT_ARRAY,<br>
hModule, idMsg, langID,<br>
lpBuf, sizeof(lpBuf), lppArgs);</font></p>

<p>You can use <i>FormatMessage</i> with string tables as well as
with message tables, but it is more efficient to use the function
with message tables. <i>FormatMessage</i> can retrieve message
table strings directly, but it cannot access string tables. To
format a string from a string table, you would first have to
retrieve it with the <i>LoadString</i> function and then pass it
in a buffer to <i>FormatMessage</i>. Not only is this an extra
step&#151;it's a convoluted extra step.</p>

<p><i>FormatMessage</i> is particularly useful for a number of
reasons. In conjunction with the API call <i>GetLastError,</i>
you can use it to format error messages returned by the system.
(Consult the <i>Win32 API Quick Reference</i> topic titled
&quot;FormatMessage&quot; for more details.) An example of this
technique is given in <font class="MissingLink" meta="dev28f">Chapter 3</font> in the <i>ReportError</i>
routine. <i>FormatMessage</i> also allows you to specify the
language of the string you want to retrieve from a message table.
<i>LoadString</i> can retrieve only resources associated with the
language of the current thread's locale. (<font class="MissingLink" meta="dev9g">Thread locale is
explained in the section titled &quot;Multiple-Language
Resources&quot;</font>.)</p>

<p>The syntax for creating multiple-language message tables is
quite simple. The message table in Figure 4-7 above contains
English and German translations. The <i>Language=</i> statements
define the language of each message string. (The message table
format also has a CODEPAGE option to allow text to be encoded in
more than one code page in a single file). The <i>LanguageNames</i>
statement associates a &quot;friendly&quot; name you choose, such
as &quot;German,&quot; with a binary filename, such as
&quot;MSG00002.&quot; (&quot;MSG00001&quot; is the English
default.) The message compiler, MC.EXE, uses these names to
generate the binary files MSG00001.BIN and MSG00002.BIN. It also
creates an .RC file that includes the binary files, tagged with
the appropriate language, and a header file that incorporates the
message numbers and symbolic names. (See Figure 4-8.) You can
#include these files in other .RC files.</p>

<p><font size="2" face="Courier New">// SAMPLE.RC<br>
LANGUAGE 9, 1<br>
MESSAGE_TABLE MSG00001.BIN<br>
LANGUAGE 7, 1<br>
MESSAGE_TABLE MSG00002.BIN<br>
<br>
...<br>
<br>
// SAMPLE.H<br>
#define IDS_NOFILE 1<br>
#define IDS_OTHERIMAGE 2</font></p>

<P><b>Figure 4-8.</b> <i>The .RC and .H files that the
message compiler generates for the message table in Figure 4-7.</i></p>

<p><b>Notes on String Tables</b></p>

<p>When adding a string to a string table, always create a new
identifier at the end of the string table. Don't shift
identifiers or reuse old identifiers. Localization tools often
associate strings with their IDs. If you insert a string in the
middle of a table and shift all the resource IDs, translations
that rely on those IDs will suddenly be off by one. For example,
three strings might be initially defined and translated as
follows:</p>

<table border="0" cellpadding="7" cols="3">
    <tr>
        <td valign="top"><b><i>String ID</i></b></td>
        <td valign="top"><em><strong>English</strong></em></td>
        <td valign="top"><em><strong>Spanish</strong></em></td>
    </tr>
    <tr>
        <td valign="top">IDS_STRING1</td>
        <td valign="top">Open</td>
        <td valign="top">Abrir</td>
    </tr>
    <tr>
        <td valign="top">IDS_STRING2</td>
        <td valign="top">Find</td>
        <td valign="top">Buscar</td>
    </tr>
    <tr>
        <td valign="top">IDS_STRING3</td>
        <td valign="top">Copy</td>
        <td valign="top">Copiar</td>
    </tr>
</table>

<p>Inserting a string in the middle of the string table and
shifting the identifiers causes problems, as shown below. Even
though the English strings for IDS_STRING2 and IDS_STRING3 are
now &quot;Save&quot; and &quot;Find,&quot; the Spanish strings
still correspond to &quot;Find&quot; and &quot;Copy.&quot;</p>

<table border="0" cellpadding="7" cols="3">
    <tr>
        <td valign="top"><b><i>String ID</i></b></td>
        <td valign="top"><em><strong>English</strong></em></td>
        <td valign="top"><em><strong>Spanish</strong></em></td>
    </tr>
    <tr>
        <td valign="top">IDS_STRING1</td>
        <td valign="top">Open</td>
        <td valign="top">Abrir</td>
    </tr>
    <tr>
        <td valign="top">IDS_STRING2</td>
        <td valign="top">Save</td>
        <td valign="top">Buscar</td>
    </tr>
    <tr>
        <td valign="top">IDS_STRING3</td>
        <td valign="top">Find</td>
        <td valign="top">Copiar</td>
    </tr>
    <tr>
        <td valign="top">IDS_STRING4</td>
        <td valign="top">Copy</td>
        <td valign="top">Copy</td>
    </tr>
</table>

<p>LoadString, the function for retrieving strings from string
tables, doesn't automatically tell you how large your string
buffer needs to be. The maximum length of a Win32 string resource
is 4k characters (8k bytes), though some tools limit strings to a
maximum of 256 bytes. Allocating a buffer using the system
constant LARGE_SIZE should accommodate the longest string in your
resource file, as in this example:</p>

<p><font size="2" face="Courier New">CHAR pszStr[LARGE_SIZE];<br>
<br>
if (LoadString(hMod, IDS_STRING1, pszStr, LARGE_SIZE))<br>
&lt;proceed&gt;;<br>
else<br>
&lt;error&gt;;</font></p>
</FONT></BODY>
</html>
