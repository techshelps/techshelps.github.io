<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>

<HEAD><meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">
<meta name="GENERATOR" content="Microsoft FrontPage 2.0">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>How to Go Backward in a DBCS String</title>
<style>@import url(../msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="../msdn_ie3.css"></HEAD>

<BODY bgcolor="#FFFFFF">

<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

<h3>How to Go Backward in a DBCS String</h3>

<p>The usual method for retrieving the previous character in a
DBCS string is to go back to the beginning of the string and
progress through it until the previous character is found. An
alternative method that is more efficient in the average case is
to go backward, testing each byte until a &quot;true
non&#150;lead-byte&quot; character is found, and then calculate
the previous character from that point. In the worst-case
scenario (stepping all the way back to the beginning of your
buffer), this method is comparable to the traditional one.</p>

<p><font size="2" face="Courier New">char* MyCharPrev (char *psz,
char *pch)<br>
{<br>
// pch must point either to a single-byte character<br>
// or to the beginning of a double-byte character.<br>
// It cannot point to the middle of a double-byte character.<br>
char *pchTemp;<br>
<br>
// If we are at the beginning, or the previous byte<br>
// is at the beginning, simply return psz.<br>
if (psz &lt;= pch - 1)<br>
return psz;<br>
<br>
pchTemp = pch - 1; // point to previous byte<br>
<br>
// If *(pch-1) is a Lead Byte-, it must actually<br>
// be functioning as a trail byte so return pch-2.<br>
if (IsDBCSLeadByte(*pchTemp))<br>
return (pch - 2);<br>
// Otherwise, step back until a non-lead-byte is found.<br>
while (psz &lt;= --pchTemp &amp;&amp; IsDBCSLeadByte(*pchTemp))<br>
;<br>
// Now pchTemp+1 must point to the beginning of a character,<br>
// so figure out whether we went back an even or an odd<br>
// number of bytes and go back 1 or 2 bytes, respectively.<br>
return (pch - 1 - ((pch - pchTemp) &amp; 1));<br>
{</font></p>
</FONT></BODY>
</html>
