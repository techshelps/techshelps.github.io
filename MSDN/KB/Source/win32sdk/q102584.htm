

<HTML>
<HEAD>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Returning CBR_BLOCK from DDEML Transactions </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q102584">
<META NAME="KBModify" CONTENT="1995/11/02">
<META NAME="KBCreate" CONTENT="1993/08/04">
<META NAME="Keywords" CONTENT="kbui">
<META NAME="KBArea" CONTENT="Support; KB; win32sdk">
<META NAME="Description" CONTENT="  DDEML servers are applications that provide data to client applications. For some servers, this data gathering may be a lengthy process, as when gathering data from sources such as serial ports or a network. DDEML allows a server application to pro...">
<META NAME="Product" CONTENT="Win32 SDK">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QAUD,QAGI,QAYY,QAJH,QAY2,QARL,QAJZ,QBXJ,QALW,QAZM,QAZL,QDL9,QBWO,QBWN,QBVX V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>Returning CBR_BLOCK from DDEML Transactions</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  November 2, 1995</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q102584</B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
The information in this article applies to:

<UL><LI>Microsoft Windows Software Development Kit (SDK) versions 3.1

<LI>Microsoft Win32 Application Programming Interface (API) included with:
<P>
<P><PRE>    - Microsoft Windows NT versions 3.5 and 3.51
    - Microsoft Windows 95 version 4.0
</UL></PRE> 
<P>
<P><h2>SUMMARY</h2>
 
<P>
DDEML servers are applications that provide data to client
applications. For some servers, this data gathering may be a lengthy
process, as when gathering data from sources such as serial ports or a
network. DDEML allows a server application to process data
asynchronously in these situations by returning CBR_BLOCK from the DDE
callback function.
<P>
<P><h2>MORE INFORMATION</h2>
 
<P>
In DDEML-based applications, while transactions can be either
synchronous or asynchronous, only DDEML client applications may choose
to establish either type of transaction when requesting data from a
server application. DDEML server applications do not distinguish
between synchronous and asynchronous transactions.
<P>
Asynchronous transactions can be very useful when client applications
know that the partner server application will take some time to gather
data. This type of transaction frees up the client to do other things
while waiting for a notification from the server of data availability.
<P>
Server applications have no way of determining whether the client
application has requested data synchronously or asynchronously.
Request transactions on the server's side are always synchronous. When
a client requests data, the server's callback receives an XTYP_REQUEST
transaction, where the expected return value is a data handle. If the
server application has to wait for data from a serial port, for
example, access to the CPU by other applications will be delayed,
thereby freezing the system until data arrives.
<P>
There are a couple of ways one can enable the server to gather data in
an asynchronous manner, thereby allowing it to yield to other
applications on the system while it gathers data. One method is to
use CBR_BLOCK; another is to change the request transaction to a
one-time ADVISE loop.
<P>
<P><h3>Method 1</h3>
 
<P>
Given that DDEML callbacks are not re-entrant, and that DDEML expects
a data handle as a return value from the XTYP_REQUEST transaction (and
transactions of XCLASS_DATA class), the server application can block
the callback momentarily. It can do this by returning a CBR_BLOCK
value after posting itself a user-defined message.
<P>
This way, the server application can gather data in the background
while DDEML queues up any further transactions. The server can start
gathering data when its window procedure gets the user defined message
that was posted by its DDE callback function.
<P>
When a server application returns CBR_BLOCK for a request transaction,
DDEML disables the server's callback function. It also queues
transactions that are sent by DDEML after its callback has been
disabled. This feature gives the server an opportunity to gather data
while allowing other applications to run in the system.
<P>
As soon as data becomes available, then the server application can
call DdeEnableCallBack() to re-enable the server callback function.
Once the callback is re-enabled, DDEML will resend the same request
transaction to the server's callback and this time, because data is
ready, the server application can return the appropriate data handle
to the client.
<P>
Transactions that were queued up because of an earlier block are sent
to the server's callback function in the order they were received by
DDEML.
<P>
The pseudo code to implement method 1 might resemble the following:
<P>
<PRE>BOOL gbGatheringData = TRUE;   // Defined GLOBAlly.
</PRE>HDDEDATA ghData = NULL;
<P>
HDDEDATA CALLBACK DdeServerCallBack(...)
<PRE>   {
       switch(txnType)
       {
       case XTYP_REQUEST:

          // If the server takes a long time to gather data...
          // for this topic/item pair, then
          // post a user-defined message to the server app's wndproc
       // and return CBR_BLOCK... DDEML will block the callback
       // and queue transactions.

       if(bGatheringData) {
         PostMessage(hSrvWnd, WM_GATHERDATA, .....) ;
         return CBR_BLOCK;
       }
       else              // Data is ready, send back handle.
         return ghData;

       default:
         return DDE_FNOTPROCESSED;
      }
    }

</PRE>LRESULT CALLBACK SrvWndProc(...)
<PRE>  {
    switch (wMessage)
       {
          case WM_GATHERDATA:

             while (bGatheringData)
               {
                  // Gather data here while yielding to others
                  // at the same time!
      if(!PeekMessage(..))
        bGatheringData = GoGetDataFromSource (&amp;ghData);
                  else {
                    TranslateMessage() ;
                    DispatchMessage ();
                  }
                }
          DdeEnableCallback (idInst, ghConv, EC_ENABLEALL);
             break ;

          default:
            return DefWndProc();
         }
     }

</PRE>Method 2
 
<P>
Advise transactions in DDEML (or DDE) are just a continuous request
link. Changing the transaction from a REQUEST to a "one time only"
ADVISE loop on the client side allows the server to gather data
asynchronously.
<P>
The client application can start an ADVISE transaction from its side
and when the server receives a XTYP_ADVSTART transaction, return TRUE
so that an ADVISE link is established. Once the link is established,
the server can start gathering data, and as soon as it becomes
available, notify the client of its availability.
<P>
This can be done by calling DdePostAdvise(). The server can use
PeekMessage() to gather data if the data gathering process is a
lengthy one, so that other applications on the system will get a
chance to run. Once the client receives the data from the server in
its callback (in its XTYP_ADVDATA transaction), it can disconnect the
the ADVISE link from the server by specifying an XTYP_ADVSTOP
transaction.
<P>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
Additional reference words: 3.10 3.50 3.51 4.00 95<BR>
KBCategory: kbui<BR>
KBSubcategory: UsrDde<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  November 2, 1995</FONT>
	<BR>
	<A HREF="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
