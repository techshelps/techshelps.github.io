

<HTML>
<HEAD>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>HOWTO: Implement Explore and Open in a Namespace Extension </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q179911">
<META NAME="KBModify" CONTENT="1998/03/10">
<META NAME="KBCreate" CONTENT="1998/01/26">
<META NAME="Keywords" CONTENT="UsrShell kbcode">
<META NAME="KBArea" CONTENT="Support; KB; win32sdk">
<META NAME="Description" CONTENT="  When you are creating a namespace extension that has multiple levels of folders, you may have to implement the Explore and Open commands from the context menu. This article discusses how to implement Explore and Open commands from a context menu in...">
<META NAME="Product" CONTENT="Win32 SDK">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Security" CONTENT="PUBLIC ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QBIC,QAB5,QAUD,QBWS,QAFI,QADK,QAH6,QAGI,QBV8,QAB9,QAOG,QABA,QAV1,QAV0,QAMB V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>HOWTO: Implement Explore and Open in a Namespace Extension</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  March 10, 1998</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q179911</B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
 
The information in this article applies to:

<UL><LI>Microsoft Win32 Application Programming Interface (API) included with:
<P>
   - Microsoft Windows 95
   - Microsoft Windows NT 4.0
</UL> 
<P>
<P><h2>SUMMARY</h2>
 
<P>
When you are creating a namespace extension that has multiple levels of
folders, you may have to implement the Explore and Open commands from the
context menu. This article discusses how to implement Explore and Open
commands from a context menu in the Windows Explorer tree. This article
assumes you are already familiar with development of namespace extensions.
For additional information on writing namespace extensions, see David
Campbell's article "Extending the Windows Explorer with Name Space
Extensions" in the July, 1996 issue of the Microsoft Systems Journal. In
addition, please see the following article in the Microsoft Knowledge Base:
<P>
<PRE>   ARTICLE-ID: <B><A HREF="../WIN32SDK/Q178665.htm">Q178665</A></B>
   TITLE     : Sample: RegView.exe: Shell Namespace Extension Example

</PRE><h2>MORE INFORMATION</h2>
 
<P>
When you want to implement Explore and Open commands from your shell view,
normally you will call IShellBrowser::BrowseObject, specifying the proper
options for the desired commands. But you cannot do this for your folder
items in the Windows Explorer tree because the IShellBrowser interface is
not always available to use. Fortunately, you can implement these commands
using ShellExecuteEx and these commands can be used by both the shell
folder and shell view implementations.
<P>
If you want to implement Explore and Open commands in the context menus for
your items in the Windows Explorer tree, you must first add these items to
the menu in your IContextMenu::QueryContextMenu. Because you will be
handling the execution of the commands, you can supply any command ID for
the menu items that you want. Remember that the Explore and Open menu
strings should be localized for use with other languages.
<P>
The first challenge is how to determine which item should be the default
item. Normally, if the item is displayed in Explore mode (a window that
contains a tree), the Explore command is the default. If the item is
displayed in Open mode (no tree present), then Open is the default item in
the context menu. If the context menu is being generated by the shell from
a Explore mode window, it will set the CMF_EXPLORE flag when it calls your
IContextMenu::QueryContextMenu. If this flag is set, you should make
Explore the first and default item in the menu. If this flag is not set,
then you should make Open the first and default item.
<P>
<P><h3>Sample Code</h3>
 
<P>
Following is an example of how you may accomplish this:
<P>
<PRE>   #define IDM_EXPLORE  0
   #define IDM_OPEN     1

   #define IDM_LAST     IDM_OPEN

   STDMETHODIMP CContextMenu::QueryContextMenu( HMENU hMenu,
                                                UINT indexMenu,
                                                UINT idCmdFirst,
                                                UINT idCmdLast,
                                                UINT uFlags)
   {
   if(!(CMF_DEFAULTONLY &amp; uFlags))
      {
      MENUITEMINFO   mii;

      if(uFlags &amp; CMF_EXPLORE)
         {
         //add the Explore command first and make it the default item
         ZeroMemory(&amp;mii, sizeof(mii));
         mii.cbSize = sizeof(mii);
         mii.fMask = MIIM_ID | MIIM_TYPE | MIIM_STATE;
         mii.wID = idCmdFirst + IDM_EXPLORE;
         mii.fType = MFT_STRING;
         mii.dwTypeData = TEXT("&amp;Explore");
         mii.fState = MFS_ENABLED | MFS_DEFAULT;
         InsertMenuItem(   hMenu,
                           indexMenu++,
                           TRUE,
                           &amp;mii);

         ZeroMemory(&amp;mii, sizeof(mii));
         mii.cbSize = sizeof(mii);
         mii.fMask = MIIM_ID | MIIM_TYPE | MIIM_STATE;
         mii.wID = idCmdFirst + IDM_OPEN;
         mii.fType = MFT_STRING;
         mii.dwTypeData = TEXT("&amp;Open");
         mii.fState = MFS_ENABLED;
         InsertMenuItem(   hMenu,
                           indexMenu++,
                           TRUE,
                           &amp;mii);
         }
      else
         {
         //add the Open command first and make it the default item
         ZeroMemory(&amp;mii, sizeof(mii));
         mii.cbSize = sizeof(mii);
         mii.fMask = MIIM_ID | MIIM_TYPE | MIIM_STATE;
         mii.wID = idCmdFirst + IDM_OPEN;
         mii.fType = MFT_STRING;
         mii.dwTypeData = TEXT("&amp;Open");
         mii.fState = MFS_ENABLED | MFS_DEFAULT;
         InsertMenuItem(   hMenu,
                           indexMenu++,
                           TRUE,
                           &amp;mii);

         ZeroMemory(&amp;mii, sizeof(mii));
         mii.cbSize = sizeof(mii);
         mii.fMask = MIIM_ID | MIIM_TYPE | MIIM_STATE;
         mii.wID = idCmdFirst + IDM_EXPLORE;
         mii.fType = MFT_STRING;
         mii.dwTypeData = TEXT("&amp;Explore");
         mii.fState = MFS_ENABLED;
         InsertMenuItem(   hMenu,
                           indexMenu++,
                           TRUE,
                           &amp;mii);
         }

      return MAKE_HRESULT(SEVERITY_SUCCESS, 0, USHORT(IDM_LAST + 1));
      }

   return MAKE_HRESULT(SEVERITY_SUCCESS, 0, USHORT(0));
   }

</PRE>To determine if your shell view is being displayed in Open or Explore mode,
use the IShellBrowser::GetControlWindow method passing FCW_TREE. If this
method returns NULL, then the view is in Open mode. If this method returns
a non-NULL value, then the view is in Explore mode. When the view needs to
display a context menu for an item, it can then obtain the IContextMenu
object using its parent's IShellFolder::GetUIObjectOf and then call the
IContextMenu object's QueryContextMenu method. If the tree is present, the
view should add the CMF_EXPLORE flag in the QueryContextMenu call.
<P>
<P><h3>Sample Code</h3>
 
<P>
Following is an example that obtains the context menu for the specified
items in a view. The view object maintains the IShellFolder interface of
the folder that created it in m_pSFParent.
<P>
<PRE>   #define MENU_OFFSET  1
   #define MENU_MAX     100

   HMENU CShellView::GetContextMenuForItems( UINT uItems,
                                             LPITEMIDLIST *aItems)
   {
   HMENU hMenu;

   if(aItems)
      {
      LPCONTEXTMENU  pContextMenu = NULL;
      m_pSFParent-&gt;GetUIObjectOf(   m_hwndParent,
                                    uItems,
                                    (LPCITEMIDLIST*)aItems,
                                    IID_IContextMenu,
                                    NULL,
                                    (LPVOID*)&amp;pContextMenu);

      if(pContextMenu)
         {
         HMENU hMenu = CreatePopupMenu();

         /*
         See if we are in Explore or Open mode. If the browser's tree is
         present, then we are in Explore mode.
         */
         BOOL  fExplore = FALSE;
         HWND  hwndTree = NULL;
         if(SUCCEEDED(m_pShellBrowser-&gt;GetControlWindow(FCW_TREE,
               &amp;hwndTree)) &amp;&amp; hwndTree)
            {
            fExplore = TRUE;
            }

         if(hMenu &amp;&amp; SUCCEEDED(pContextMenu-&gt;QueryContextMenu( hMenu,
               0,
               MENU_OFFSET,
               MENU_MAX,
               CMF_NORMAL | (fExplore ? CMF_EXPLORE : 0))))
            {
            }
         else
            {
            DestroyMenu(hMenu);
            hMenu = NULL;
            }
         }
      }
   return hMenu;
   }

</PRE>When the user selects an item in the menu, your IContextMenu::InvokeCommand
will be called. If the command identifier is your Explore or Open command,
then you should use ShellExecuteEx to Open or Explore the folder. To use
ShellexecuteEx to Open or Explore the folder, you need to do the following:

<OL><P><LI>Specify the SEE_MASK_IDLIST flag and pass a fully-qualified PIDL for the
   item to be opened or explored.

<P><LI>Specify the SEE_MASK_CLASSNAME flag and specify the class name as
   "folder."

<P><LI>Specify the window handle of the browser window. ShellExecuteEx will
   attempt to establish a DDE conversation with this window if the folder
   should be browsed in the same window. If you are calling InvokeCommand
   from a shell view, you should pass the view's parent window handle. This
   is usually obtained in IShellView::CreateViewWindow by calling the
   IShellBrowser::GetWindow method.

<P><LI>Specify the verb as "explore" or "open", depending upon the desired
   command.
<P>
</OL><h3>Sample Code</h3>
 
<P>
Following is an example of how this is performed:
<P>
<PRE>   STDMETHODIMP CContextMenu::InvokeCommand(LPCMINVOKECOMMANDINFO lpcmi)
   {
   if(HIWORD(lpcmi-&gt;lpVerb))
      {
      //the command is being sent via a verb
      return NOERROR;
      }

   if(LOWORD(lpcmi-&gt;lpVerb) &gt; IDM_LAST)
      return E_INVALIDARG;

   switch(LOWORD(lpcmi-&gt;lpVerb))
      {
      case IDM_EXPLORE:
      case IDM_OPEN:
         {
         LPITEMIDLIST      pidlFQ;
         SHELLEXECUTEINFO  sei;

         /*
         Only one PIDL can be passed to ShellExecuteEx, so default to the
         first one in the list.
         */
         pidlFQ = CreateFullyQualifiedPidl(m_aPidls[0]);

         ZeroMemory(&amp;sei, sizeof(sei));
         sei.cbSize = sizeof(sei);
         sei.fMask = SEE_MASK_IDLIST | SEE_MASK_CLASSNAME;
         sei.lpIDList = pidlFQ;
         sei.lpClass = TEXT("folder");
         sei.hwnd = lpcmi-&gt;hwnd;
         sei.nShow = SW_SHOWNORMAL;

         if(LOWORD(lpcmi-&gt;lpVerb) == IDM_EXPLORE)
            sei.lpVerb = TEXT("explore");
         else
            sei.lpVerb = TEXT("open");

         ShellExecuteEx(&amp;sei);

         DeletePidl(pidlFQ);
         }
         break;

      }

   return NOERROR;
   }

</PRE></OL>These steps allow your namespace extension to properly implement the
Explore and Open commands from a context menu.
<P>
<P><h2>REFERENCES</h2>
 
<P>
Microsoft Systems Journal, July 1996, "Extending the Windows Explorer with
Name Space Extensions," page 41, David Campbell
<P>
For additional information, please see the following article in the
Microsoft Knowledge Base:
<P>
<PRE>   ARTICLE-ID: <B><A HREF="../WIN32SDK/Q178665.htm">Q178665</A></B>
   TITLE : SAMPLE: RegView.exe: Shell Namespace Extension Example
 \*
</PRE> 
<PRE>Keywords          : UsrShell kbcode
Version           : WINDOWS:95; WINNT:4.0
Platform          : WINDOWS winnt
Issue type        : kbhowto</PRE>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
================================================================================<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  March 10, 1998</FONT>
	<BR>
	<A HREF="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
