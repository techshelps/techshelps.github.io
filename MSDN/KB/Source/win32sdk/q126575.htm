

<HTML>
<HEAD>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>PRB: Large DIBs May Not Display Under Win32s </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q126575">
<META NAME="KBModify" CONTENT="1995/02/27">
<META NAME="KBCreate" CONTENT="1995/02/26">
<META NAME="Keywords" CONTENT="kbprg kbprb kbcode">
<META NAME="KBArea" CONTENT="Support; KB; win32sdk">
<META NAME="Description" CONTENT="  DIB functions fail when using large DIBs under Win32s.  CAUSE =====  There is a two-megabyte limit on the size of the area of a DIB that can be blitted using blting functions under Win32s. In versions of Win32s up to 1.2, Microsoft set this size to...">
<META NAME="Product" CONTENT="Win32 SDK">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QA4Q,QAUD,QAY5,QAH2,QAH4,QA5Z,QASR,QAK6,QAK4,QABN,QDKW,QDIU,QAO3,QAO2,QALW V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>PRB: Large DIBs May Not Display Under Win32s</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  February 27, 1995</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q126575</B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
The information in this article applies to:

<UL><LI>Microsoft Win32s versions 1.10, 1.15, or 1.20
</UL> 
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
DIB functions fail when using large DIBs under Win32s.
<P>
<P><h2>CAUSE</h2>
 
<P>
There is a two-megabyte limit on the size of the area of a DIB that can be
blitted using blting functions under Win32s. In versions of Win32s up to
1.2, Microsoft set this size to accommodate DIB blts of 1024*768*24 bits-
per-pixel. In version 1.25, the maximum size of the blitted area will be
enlarged to accommodate 1280*1024*24 bits-per-pixel.
<P>
The following functions are affected:
<P>
<PRE>  SetDIBits
  SetDIBitsToDevice
  CreateDIBitmap
  StretchDIBits

</PRE><h2>WORKAROUND</h2>
 
<P>
To work around the problem, break down large blts into bands that are
smaller than two megabytes. Please keep in mind that the biSizeImage field
of the BITMAPINFOHEADER used with the blting functions will need to be set
to a value smaller than the DIB size limit.
<P>
The following code demonstrates a simple implementation of StretchDIBits()
that can be used with large DIBs under Win32s.
<P>
<PRE>/* Macro to determine the bytes in a DWORD aligned DIB scanline */
#define BYTESPERLINE(Width, BPP) ((WORD)((((DWORD)(Width) *
</PRE>(DWORD)(BPP) + 31) &gt;&gt; 5)) &lt;&lt; 2)
<P>
<PRE>int NewStretchDIBits(
    HDC  hdc,     // handle of device context
    int  XDest,     // x-coordinate of upper-left corner of dest. rect.
    int  YDest,     // y-coordinate of upper-left corner of dest. rect.
    int  nDestWidth,  // width of destination rectangle
    int  nDestHeight, // height of destination rectangle
    int  XSrc,     // x-coordinate of upper-left corner of source rect.
    int  YSrc,     // y-coordinate of upper-left corner of source rect.
    int  nSrcWidth,   // width of source rectangle
    int  nSrcHeight,  // height of source rectangle
    VOID  *lpBits,    // address of bitmap bits
    BITMAPINFO *lpBitsInfo,   // address of bitmap data
    UINT  iUsage,  // usage
    DWORD  dwRop   // raster operation code
   )
{
    BITMAPINFOHEADER  bmiTemp;
    float fDestYDelta;
    LPBYTE lpNewBits;
    int i;

    // Check for NULL pointers and return error
    if (lpBits == NULL) return 0;
    if (lpBitsInfo == NULL) return 0;

    // Get increment value for Y axis of destination
    fDestYDelta = (float)nDestHeight / (float)nSrcHeight;

    // Make backup copy of BITMAPINFOHEADER
    bmiTemp = lpBitsInfo-&gt;bmiHeader;

   // Adjust image sizes for one scan line
    lpBitsInfo-&gt;bmiHeader.biSizeImage =
                       BYTESPERLINE(lpBitsInfo-&gt;bmiHeader.biWidth,
                                    lpBitsInfo-&gt;bmiHeader.biBitCount);
    lpBitsInfo-&gt;bmiHeader.biHeight = 1;

    // Initialize pointer to the image data
    lpNewBits = (LPBYTE)lpBits;

    // Do the stretching
    for (i = 0; i &lt; nSrcHeight; i++)
   if (!StretchDIBits(hdc,
          XDest, YDest + (int)floor(fDestYDelta * (nSrcHeight - (i+1))),
          nDestWidth, (int)ceil(fDestYDelta),
          XSrc, 0,
          nSrcWidth, 1,
          lpNewBits, lpBitsInfo,
          iUsage, SRCCOPY))
        break; // Error!
   else
     // Increment image pointer by one scan line
     lpNewBits += lpBitsInfo-&gt;bmiHeader.biSizeImage;

    // Restore BITMAPINFOHEADER
    lpBitsInfo-&gt;bmiHeader = bmiTemp;

    return(i);
</PRE>}
<P>
<P><h2>STATUS</h2>
 
<P>
This behavior is by design.
<P>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
Additional reference words: 1.15 1.20 1.10<BR>
KBCategory: kbprg kbprb kbcode<BR>
KBSubcategory: W32s<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  February 27, 1995</FONT>
	<BR>
	<A HREF="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
