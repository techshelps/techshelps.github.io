

<HTML>
<HEAD>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>HOWTO: Use VDMDBG Functions on Windows NT </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q182559">
<META NAME="KBModify" CONTENT="1998/03/17">
<META NAME="KBCreate" CONTENT="1998/03/16">
<META NAME="Keywords" CONTENT="BseDebug BseProcThrd">
<META NAME="KBArea" CONTENT="Support; KB; win32sdk">
<META NAME="Description" CONTENT="  Even when programming in a 32-bit environment, there are times when working with 16-bit applications is necessary. In Windows NT, 16-bit applications run within a Virtual DOS Machine (VDM). VDMDBG.dll contains many functions that are useful for wor...">
<META NAME="Product" CONTENT="Win32 SDK">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Security" CONTENT="PUBLIC ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QAY5,QAUD,QBV8,QAB9,QAG8,QBWP,QAGB,QAL4,QBHE,QAG0,QA4H,QAB6,QAKD,QAH6,QAGI V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>HOWTO: Use VDMDBG Functions on Windows NT</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  March 17, 1998</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q182559</B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
 
The information in this article applies to:

<UL><LI>Microsoft Win32 Application Programming Interface (API) included with:
<P>
   - Microsoft Windows NT 4.0
</UL> 
<P>
<P><h2>SUMMARY</h2>
 
<P>
Even when programming in a 32-bit environment, there are times when working
with 16-bit applications is necessary. In Windows NT, 16-bit applications
run within a Virtual DOS Machine (VDM). VDMDBG.dll contains many functions
that are useful for working with 16-bit applications. This library is part
of the Microsoft Platform SDK.
<P>
VDMDBG functions provide a good way to enumerate, create, and terminate 16-
bit processes (tasks) within a VDM. This article describes how to use these
functions on Windows NT.
<P>
<P><h2>MORE INFORMATION</h2>
 
<P>
When you use any of the VDMDBG functions, you need to link VDMDBG.lib with
your project.
<P>
The VDMDBG functions mentioned below are only a subset of the available
functions. However, the functions that are not mentioned are only relevant
to a debugger.
<P>
<P><h3>Enumerating VDMs</h3>
 
<P>
The VDMEnumProcessWOW() function provides a simple way to enumerate all
VDMs running 16-bit Windows tasks. These VDMs contain the WowExec.exe task.
DOS VDMs are not enumerated.
<P>
The declaration for this function is as follows:
<P>
<PRE>   INT WINAPI VDMEnumProcessWOW( PROCESSENUMPROC fp, LPARAM lparam );

</PRE>The return value for this function is the number of VDMs currently running,
or the number enumerated before enumeration was terminated. fp is a pointer
to a callback function. The function is called for each VDM that is
enumerated. lParam is a user-defined value that is passed to the callback
function.
<P>
PROCESSENUMPROC is declared as follows:
<P>
<PRE>   typedef BOOL ( WINAPI *PROCESSENUMPROC )(
      DWORD dwProcessId,
      DWORD dwAttributes,
      LPARAM lpUserDefined
   );

</PRE>The function should return TRUE to stop enumeration or FALSE to continue
enumeration. dwProcessId is the process ID of the NTVDM.exe process. You
will need this ID when calling the other VDM functions mentioned below.
<P>
<P><h3>Enumerating 16-bit Windows Tasks</h3>
 
<P>
You can use VDMEnumTaskWOW() and VDMEnumTaskWOWEx() to enumerate tasks
within a particular VDM. The difference between the two is that
VDMEnumTaskWOWEx() provides more information to the callback function. You
should only use VDMs returned by VDMEnumProcessWOW() with these task
enumeration functions. Using DOS VDMs does not make sense because every DOS
application runs in its own VDM.
<P>
The declarations are:
<P>
<PRE>   INT WINAPI VDMEnumTaskWOW( DWORD dwProcessId, TASKENUMPROC fp,
                              LPARAM lparam );

   INT WINAPI VDMEnumTaskWOWEx( DWORD dwProcessId, TASKENUMPROCEX fp,
                                LPARAM lparam );

</PRE>The return value for each of these functions is the number of tasks
currently running within the indicated VDM, or the number enumerated before
enumeration was terminated. dwProcessId is the process ID of the VDM. fp is
a pointer to a callback function. The function is called for each task that
is enumerated. lparam is a user-defined value that is passed to the
callback function.
<P>
TASKENUMPROC and TASKENUMPROCEX are defined as follows:
<P>
<PRE>   typedef BOOL ( WINAPI *TASKENUMPROC )(
      DWORD dwThreadId,
      WORD hMod16,
      WORD hTask16,
      LPARAM lpUserDefined
   );

   typedef BOOL ( WINAPI *TASKENUMPROCEX )(
      DWORD dwThreadId,
      WORD hMod16,
      WORD hTask16,
      PSZ pszModName,
      PSZ pszFileName,
      LPARAM lpUserDefined
   );

</PRE>These functions should return TRUE to stop enumeration or FALSE to continue
enumeration. You can use hTask16 in a call to terminate the task.
<P>
<P><h3>Example of Enumeration</h3>
 
<P>
<PRE>   // Enumerate all 16-bit tasks on the system.
   #include &lt;windows.h&gt;
   #include &lt;stdio.h&gt;
   #include &lt;vdmdbg.h&gt;

   BOOL WINAPI ProcessEnumProc( DWORD, DWORD, LPARAM );
   BOOL WINAPI TaskEnumProcEx( DWORD, WORD, WORD, PSZ, PSZ, LPARAM );

   void main()
   {
      // Enumerate VDMs.
      VDMEnumProcessWOW(
         (PROCESSENUMPROC)ProcessEnumProc,
         (LPARAM)NULL
      );

   }

   BOOL WINAPI ProcessEnumProc( DWORD dwProcessId, DWORD dwAttrib,
      LPARAM t )
   {
      printf("\nProcess ID: %d\n", dwProcessId);

      // Use process ID of VDM to enumerate through its tasks.
      VDMEnumTaskWOWEx(
         dwProcessId,
         (TASKENUMPROCEX)TaskEnumProcEx,
         (LPARAM)NULL
      );

      // Keep enumerating.
      return FALSE;
   }

   BOOL WINAPI TaskEnumProcEx( DWORD dwThreadId, WORD hMod16, WORD hTask16,
      PSZ pszModName, PSZ pszFileName, LPARAM lParam )
   {
      //print task's information
      printf("Thread ID: %d\n", dwThreadId);
      printf("Module handle: %d\n", hMod16);
      printf("Task handle: %d\n", hTask16);
      printf("Module Name: %s\n", pszModName);
      printf("File Name: %s\n", pszFileName);

      // Keep enumerating.
      return FALSE;
   }

</PRE><h3>Creating 16-bit Tasks</h3>
 
<P>
VDMStartTaskInWOW() creates a task within a VDM. The declaration is as
follows:
<P>
<PRE>   BOOL WINAPI VDMStartTaskInWOW( DWORD dwProcessId, LPSTR lpCommandLine,
                                  WORD wShow );

</PRE>The return value of this function is TRUE if the task is successfully
started, otherwise it is FALSE. dwProcessId is the VDM process ID.
lpCommandLine is a string indicating the filename of the 16-bit application
along with any command-line parameters. wShow indicates how the window will
be shown. wShow can be any value that is valid for the 16-bit ShowWindow()
function.
<P>
<P><h3>Terminating 16-bit Tasks</h3>
 
<P>
To terminate a task within a VDM call VDMTerminateTaskWOW(). The
declaration is as follows:
<P>
<PRE>   BOOL WINAPI VDMTerminateTaskWOW( DWORD dwProcessId, WORD htask );

</PRE>The return value of this function is TRUE if the task is successfully
terminated, otherwise it is FALSE. dwProcessId is the VDM process ID. hTask
is the handle to the task. This task handle can be obtained through
VDMEnumTaskWOW() or VDMEnumTaskWOWEx().
<P>
This method is a rough equivalent to TerminateProcess() in Win32. It should
be avoided, if possible. It does not give the task a chance to cleanly
exit, so data may be lost. Unlike Win32, the WowExec is not guaranteed to
clean up after a terminated task. This can leave the VDM corrupt and
unusable. To terminate the task cleanly, send a WM_CLOSE to its top-level
window.
<P>
<P><h3>Note Regarding 16-bit DOS Applications</h3>
 
<P>
None of the VDMDBG functions work with 16-bit DOS applications. To
enumerate DOS VDMs, you need to use another method. First, you could use
VDMEnumProcessWOW() to make a list of all Win16 VDMs, and then enumerate
all instances of NTVDM.exe using some other scheme (such as PSAPI). Any
NTVDM.exe from the full enumeration that was not in the Win16 list is a DOS
VDM. You can create and terminate 16-bit DOS applications with
CreateProcess() and TerminateProcess().
<P>
<P><h2>REFERENCES</h2>
 
<P>
For additional information, please see the following article in the
Microsoft Knowledge Base:
<P>
<PRE>   ARTICLE-ID: <B><A HREF="../WIN32SDK/Q175030.htm">Q175030</A></B>
   TITLE     : HOWTO: Enumerate Applications in Win32
</PRE> 
<PRE>Keywords          : BseDebug BseProcThrd
Version           : WINNT:4.0
Platform          : winnt
Issue type        : kbhowto</PRE>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
================================================================================<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  March 17, 1998</FONT>
	<BR>
	<A HREF="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
