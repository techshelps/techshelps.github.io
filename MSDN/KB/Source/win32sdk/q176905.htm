

<HTML>
<HEAD>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>BUG: A Level 3 Volume Lock Might Deadlock on Windows 95 </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q176905">
<META NAME="KBModify" CONTENT="1997/11/18">
<META NAME="KBCreate" CONTENT="1997/11/18">
<META NAME="Keywords" CONTENT="BseFileio">
<META NAME="KBArea" CONTENT="Support; KB; win32sdk">
<META NAME="Description" CONTENT="  Deadlock might occur when a Windows 95 application tries to take a level 3 volume lock. The following is a typical scenario:      Process A (32-bit)                           Process B (16-bit)  _________________________                    ________...">
<META NAME="Product" CONTENT="Win32 SDK">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QABT,QAA8,QAGI,QAA3,QDL9,QBWO,QBWN,QA7T,QAH4,QAHO,QAK7,QAJ6,QBWQ,QA8T,QAYV V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>BUG: A Level 3 Volume Lock Might Deadlock on Windows 95</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  November 18, 1997</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q176905</B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
 
The information in this article applies to:

<UL><LI>Microsoft Win32 Application Programming Interface (API) included with:
   - Microsoft Windows 95
</UL> 
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
Deadlock might occur when a Windows 95 application tries to take a level 3
volume lock. The following is a typical scenario:
<P>
<PRE>    Process A (32-bit)                           Process B (16-bit)
 _________________________                    _________________________
|                         |                  |                         |
| 1. Acquire level 2 lock |                  |                         |
|                         |                  |                         |
|                         | 2. Process A     |                         |
|                         |    preempted     |                         |
|                         | ---------------&gt; |                         |
|                         |                  | 3. Attempt a file write |
|                         |                  |                         |
|                         |                  |    -acquire kernel32    |
|                         |                  |     lock                |
|                         |                  |                         |
|                         |                  |    -IFS manager blocks  |
|                         |                  |     on write (Process A |
|                         |                  |     owns level 2 lock)  |
|                         | 4. Process A     |                         |
|                         |    rescheduled   |                         |
|                         | &lt;--------------- |                         |
| 5. Request for level 3  |                  |                         |
|    lock blocks on       |                  |                         |
|    request for kernel32 |                  |                         |
|    lock (owned by       |                  |                         |
|    Process B)           |                  |                         |
|_________________________|                  |_________________________|


</PRE><P><LI>Process A, a 32-bit Windows application, acquires a level 2 volume lock.

<P><LI>Process A's running thread is preempted.

<P><LI>Process B makes a 16-bit Windows API call requiring write access on the
   locked drive. The API acquires the kernel32 lock prior to passing
   the request to the IFS manager. The thread is blocked because it is
   denied write access until process A releases the level 2 lock.

<P><LI>Process A is rescheduled.

<P><LI>Process A requests the level 3 volume lock. The level 3 lock first
   tries to acquire the kernel32 lock. The thread subsequently blocks,
   since the kernel32 lock is already owned by process B.
<P>
</OL>Both processes are now blocked, each one is waiting on a resource that the
other owns.
<P>
<P><h2>CAUSE</h2>
 
<P>
The deadlock takes place because the order in which the resources (write
access to the disk and the kernel32 lock) are requested differs between the
two processes and because the acquisition of these resources is not an
atomic transaction. Furthermore, the problem only seems to show up when
another process is performing 16-bit file I/O on the locked volume.
<P>
<P><h2>RESOLUTION</h2>
 
<P>
There is no viable workaround for 32-bit code. The Windows 95 disk
utilities avoid this problem by thunking to 16-bit code, thereby assuring
that the acquisition of the level 2 and level 3 volume locks is done
atomically.
<P>
<PRE>    Process A (32-bit)                           Process B (16-bit)
 _________________________                    _________________________
|                         |                  |                         |
| 1. Thunk to 16-bit code |                  |                         |
|                         |                  |                         |
| 2. Acquire level 2 lock |                  |                         |
|                         |                  |                         |
| 3. Acquire level 3 lock |                  |                         |
|    (acquires kernel32   |                  |                         |
|    lock)                |                  |                         |
|                         |                  |                         |
| 4. Return from thunk    |                  |                         |
|                         |                  |                         |
|                         | 5. Process A     |                         |
|                         |    preempted     |                         |
|                         | ---------------&gt; |                         |
|                         |                  | 6. Write blocks on      |
|                         |                  |    request for kernel32 |
|                         |                  |    lock                 |
|                         |                  |                         |
|                         | 7. Process A     |                         |
|                         |    rescheduled   |                         |
|                         | &lt;--------------- |                         |
|                         |                  |                         |
| 8. Release level 3 lock |                  |                         |
|    (releases kernel32   |                  |                         |
|    lock)                |                  |                         |
|_________________________|                  |_________________________|


</PRE></OL>There is no deadlock here, since process B is no longer blocked. In
reality, process A may be preempted between steps 2 and 3 above, but since
it will then own the Win16 mutex, no other 16-bit process may be scheduled.
Note that this will have consequences on the code design. To ensure
atomicity, the Win16 mutex must not be released between requests for the
level 2 and level 3 volume locks. Hence, these operations must be performed
from within the context of a single thunk.
<P>
<P><h2>STATUS</h2>
 
<P>
Microsoft has confirmed this to be a bug in the Microsoft products listed
at the beginning of this article. We are researching this bug and will post
new information here in the Microsoft Knowledge Base as it becomes
available.
<P>
<P><h2>MORE INFORMATION</h2>
 
<P>
Note that this problem is fixed in the Windows 95 OEM Service Release 2
(OSR2).
<P>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
Additional query words: disk I/O diskio access kernel base win95<BR>
Keywords          : BseFileio<BR>
Version           : WINNT:<BR>
Platform          : winnt<BR>
Hardware          : x86<BR>
Issue type        : kbbug<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  November 18, 1997</FONT>
	<BR>
	<A HREF="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
