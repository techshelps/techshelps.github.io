

<HTML>
<HEAD>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>How To Deal with Localized and Renamed User and Group Names </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q157234">
<META NAME="KBModify" CONTENT="1996/10/25">
<META NAME="KBCreate" CONTENT="1996/10/08">
<META NAME="Keywords" CONTENT="kbprg kbhowto">
<META NAME="KBArea" CONTENT="Support; KB; win32sdk">
<META NAME="Description" CONTENT="  This article illustrates how to obtain localized and renamed account names associated with accounts on arbitrary machines.  The approach illustrated below is necessary due to localization of Windows NT user and group names, and also to allow for ar...">
<META NAME="Product" CONTENT="Win32 SDK">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QBE6,QBE7,QAI4,QAUJ,QBWP,QABO,QARM,QBG2,QAUD,QACJ,QA9A,QAGU,QA4H,QAN0,QAEF V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>How To Deal with Localized and Renamed User and Group Names</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  October 25, 1996</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q157234</B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
The information in this article applies to:

<UL><LI>Microsoft Win32 Software Development Kit (SDK) for Windows NT,
   versions 3.51, 4.00
</UL> 
<P>
<P><h2>SUMMARY</h2>
 
<P>
This article illustrates how to obtain localized and renamed account names
associated with accounts on arbitrary machines.
<P>
The approach illustrated below is necessary due to localization of
Windows NT user and group names, and also to allow for arbitrary account
renaming by system administrators. This approach works by building a
Sid (security identifier) value that contains a relative ID value
specifying the user or group of interest. The resultant Sid is then looked
up on the machine of interest and results in a name string that is
relevant on the machine where the lookup took place. This is done because
the same Sid value may have different associated text on different
machines, as mentioned above.
<P>
<P><h2>MORE INFORMATION</h2>
 
<P>
<P><h3>Sample Code</h3>
 
<P>
<PRE>/*++

</PRE>Copyright (c) 1996  Microsoft Corporation
<P>
Module Name:
<P>
<PRE>    acctname.c

</PRE>Abstract:
<P>
<PRE>    This module illustrates how to obtain user and group names associated
    with accounts that have been renamed or localized. This sample works
    by building a Sid value and then looking up the name associated with
    that Sid value.

    For example, in a default English install of Windows NT, the local
    administrators group is called "Administrators." In a default German
    install of Windows NT, the local administrators group is called
    "Administratoren." This can lead to problems when managing users
    and groups if the proper steps are not taken.

    The following relative ID values are an index into an account database
    that represents a specific user or group. In DOMAIN_USER_ and
    DOMAIN_GROUP_ cases, the relative ID is appended to the account domain
    Sid from the machine of interest. In the DOMAIN_ALIAS_ case,
    the relative ID is appended to a well-known Sid representing the
    BUILTIN domain that is consistent across machines.

    // Well-known users and groups...

    #define DOMAIN_USER_RID_ADMIN          (0x000001F4L)
    #define DOMAIN_USER_RID_GUEST          (0x000001F5L)

    #define DOMAIN_GROUP_RID_ADMINS        (0x00000200L)
    #define DOMAIN_GROUP_RID_USERS         (0x00000201L)
    #define DOMAIN_GROUP_RID_GUESTS        (0x00000202L)

    // well-known aliases ...

    #define DOMAIN_ALIAS_RID_ADMINS        (0x00000220L)
    #define DOMAIN_ALIAS_RID_USERS         (0x00000221L)
    #define DOMAIN_ALIAS_RID_GUESTS        (0x00000222L)
    #define DOMAIN_ALIAS_RID_POWER_USERS   (0x00000223L)
    #define DOMAIN_ALIAS_RID_ACCOUNT_OPS   (0x00000224L)
    #define DOMAIN_ALIAS_RID_SYSTEM_OPS    (0x00000225L)
    #define DOMAIN_ALIAS_RID_PRINT_OPS     (0x00000226L)
    #define DOMAIN_ALIAS_RID_BACKUP_OPS    (0x00000227L)
    #define DOMAIN_ALIAS_RID_REPLICATOR    (0x00000228L)

    The following section is for informational purposes and is useful for
    visualizing Sid values:

    // Universal well-known SIDs:
    //
    //     Null SID                     S-1-0-0
    //     World                        S-1-1-0
    //     Local                        S-1-2-0
    //     Creator Owner ID             S-1-3-0
    //     Creator Group ID             S-1-3-1
    //     Creator Owner Server ID      S-1-3-2
    //     Creator Group Server ID      S-1-3-3
    //
    //     (Non-unique IDs)             S-1-4

    #define SECURITY_NULL_SID_AUTHORITY       {0,0,0,0,0,0}
    #define SECURITY_WORLD_SID_AUTHORITY      {0,0,0,0,0,1}
    #define SECURITY_LOCAL_SID_AUTHORITY      {0,0,0,0,0,2}
    #define SECURITY_CREATOR_SID_AUTHORITY    {0,0,0,0,0,3}
    #define SECURITY_NON_UNIQUE_AUTHORITY     {0,0,0,0,0,4}

    #define SECURITY_NULL_RID                 (0x00000000L)
    #define SECURITY_WORLD_RID                (0x00000000L)
    #define SECURITY_LOCAL_RID                (0X00000000L)

    #define SECURITY_CREATOR_OWNER_RID        (0x00000000L)
    #define SECURITY_CREATOR_GROUP_RID        (0x00000001L)

    #define SECURITY_CREATOR_OWNER_SERVER_RID (0x00000002L)
    #define SECURITY_CREATOR_GROUP_SERVER_RID (0x00000003L)

    // NT well-known SIDs:
    //
    //     NT Authority          S-1-5
    //     Dialup                S-1-5-1
    //
    //     Network               S-1-5-2
    //     Batch                 S-1-5-3
    //     Interactive           S-1-5-4
    //     Service               S-1-5-6
    //     AnonymousLogon        S-1-5-7       (aka null logon session)
    //     Proxy                 S-1-5-8
    //     ServerLogon           S-1-5-8       (aka domain controller
    //                                            account)
    //
    //     (Logon IDs)           S-1-5-5-X-Y
    //
    //     (NT non-unique IDs)   S-1-5-0x15-...
    //
    //     (Built-in domain)     S-1-5-0x20

    #define SECURITY_NT_AUTHORITY           {0,0,0,0,0,5}   // ntifs

    #define SECURITY_DIALUP_RID             (0x00000001L)
    #define SECURITY_NETWORK_RID            (0x00000002L)
    #define SECURITY_BATCH_RID              (0x00000003L)
    #define SECURITY_INTERACTIVE_RID        (0x00000004L)
    #define SECURITY_SERVICE_RID            (0x00000006L)
    #define SECURITY_ANONYMOUS_LOGON_RID    (0x00000007L)
    #define SECURITY_PROXY_RID              (0x00000008L)
    #define SECURITY_SERVER_LOGON_RID       (0x00000009L)

    #define SECURITY_LOGON_IDS_RID          (0x00000005L)
    #define SECURITY_LOGON_IDS_RID_COUNT    (3L)

    #define SECURITY_LOCAL_SYSTEM_RID       (0x00000012L)

    #define SECURITY_NT_NON_UNIQUE          (0x00000015L)

    #define SECURITY_BUILTIN_DOMAIN_RID     (0x00000020L)

    If no Command line arguments are specified, names are looked up
    on the local machine. If argv[1] is present, the lookup occurs
    on the specified machine.

    For example, acctname.exe \\winbase will look up names from the
    machine named \\winbase. If \\winbase is a default German install
    of Windows NT, names will appear in German locale.

</PRE>Author:
<P>
<PRE>    Scott Field (sfield)    02-Oct-96

--*/

#define WIN32_LEAN_AND_MEAN
#include &lt;windows.h&gt;
#include &lt;lm.h&gt;

</PRE>BOOL
LookupAliasFromRid(
<PRE>    LPWSTR TargetComputer,
    DWORD Rid,
    LPWSTR Name,
    PDWORD cchName
    );

</PRE>BOOL
LookupUserGroupFromRid(
<PRE>    LPWSTR TargetComputer,
    DWORD Rid,
    LPWSTR Name,
    PDWORD cchName
    );

#define RTN_OK 0
#define RTN_USAGE 1
#define RTN_ERROR 13

</PRE>int
__cdecl
wmain(
<PRE>    int argc,
    wchar_t *argv[]
    )
</PRE>{
<PRE>    LPWSTR TargetComputer;
    WCHAR Name[UNLEN+1];
    DWORD cchName = UNLEN;

    if(argc == 2)
        TargetComputer = argv[1];   // target specified machine
    else
        TargetComputer = NULL;      // target local machine

    if(!LookupUserGroupFromRid(
            TargetComputer,
            DOMAIN_USER_RID_ADMIN,
            Name,
            &amp;cchName
            )) {

        printf("LookupUserFromRid error! (rc=%lu)\n", GetLastError());
        return RTN_ERROR;
    }

    printf("'Administrator' user name = %ls\n", Name);

    cchName = UNLEN; // reset buffer size

    if(!LookupAliasFromRid(
            TargetComputer,
            DOMAIN_ALIAS_RID_ADMINS,
            Name,
            &amp;cchName
            )) {

        printf("LookupAliasFromRid error! (rc=%lu)\n", GetLastError());
        return RTN_ERROR;
    }

    printf("'Administrators' local group/alias name = %ls\n", Name);

    return RTN_OK;
</PRE>}
<P>
BOOL
LookupAliasFromRid(
<PRE>    LPWSTR TargetComputer,
    DWORD Rid,
    LPWSTR Name,
    PDWORD cchName
    )
</PRE>{
<PRE>    SID_IDENTIFIER_AUTHORITY sia = SECURITY_NT_AUTHORITY;
    SID_NAME_USE snu;
    PSID pSid;
    WCHAR DomainName[DNLEN+1];
    DWORD cchDomainName = DNLEN;
    BOOL bSuccess = FALSE;

    //
    // Sid is the same regardless of machine, since the well-known
    // BUILTIN domain is referenced.
    //

    if(AllocateAndInitializeSid(
            &amp;sia,
            2,
            SECURITY_BUILTIN_DOMAIN_RID,
            Rid,
            0, 0, 0, 0, 0, 0,
            &amp;pSid
            )) {

        bSuccess = LookupAccountSidW(
                TargetComputer,
                pSid,
                Name,
                cchName,
                DomainName,
                &amp;cchDomainName,
                &amp;snu
                );

        FreeSid(pSid);
    }

    return bSuccess;
</PRE>}
<P>
BOOL
LookupUserGroupFromRid(
<PRE>    LPWSTR TargetComputer,
    DWORD Rid,
    LPWSTR Name,
    PDWORD cchName
    )
</PRE>{
<PRE>    PUSER_MODALS_INFO_2 umi2;
    NET_API_STATUS nas;

    UCHAR SubAuthorityCount;
    PSID pSid;
    SID_NAME_USE snu;

    WCHAR DomainName[DNLEN+1];
    DWORD cchDomainName = DNLEN;
    BOOL bSuccess = FALSE; // assume failure

    //
    // get the account domain Sid on the target machine
    // note: if you were looking up multiple sids based on the same
    // account domain, only need to call this once.
    //

    nas = NetUserModalsGet(TargetComputer, 2, (LPBYTE *)&amp;umi2);

    if(nas != NERR_Success) {
        SetLastError(nas);
        return FALSE;
    }

    SubAuthorityCount = *GetSidSubAuthorityCount(umi2-&gt;usrmod2_domain_id);

    //
    // allocate storage for new Sid. account domain Sid + account Rid
    //

    pSid = (PSID)HeapAlloc(GetProcessHeap(), 0,
            GetSidLengthRequired((UCHAR)(SubAuthorityCount + 1)));

    if(pSid != NULL) {

        if(InitializeSid(
                pSid,
                GetSidIdentifierAuthority(umi2-&gt;usrmod2_domain_id),
                (BYTE)(SubAuthorityCount+1)
                )) {

            DWORD SubAuthIndex = 0;

            //
            // copy existing subauthorities from account domain Sid into
            // new Sid
            //

            for( ; SubAuthIndex &lt; SubAuthorityCount ; SubAuthIndex++) {
                *GetSidSubAuthority(pSid, SubAuthIndex) =
                *GetSidSubAuthority(umi2-&gt;usrmod2_domain_id, SubAuthIndex);
            }

            //
            // append Rid to new Sid
            //

            *GetSidSubAuthority(pSid, SubAuthorityCount) = Rid;

            bSuccess = LookupAccountSidW(
                    TargetComputer,
                    pSid,
                    Name,
                    cchName,
                    DomainName,
                    &amp;cchDomainName,
                    &amp;snu
                    );
        }

        HeapFree(GetProcessHeap(), 0, pSid);
    }

    NetApiBufferFree(umi2);

    return bSuccess;
</PRE>}
<P>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
Additional reference words: 3.21 4.20 rename user group usrmgr kbdss<BR>
KBCategory: kbprg kbhowto<BR>
KBSubcategory: BseSecurity NtwkLmapi CodeSam
<P>


</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  October 25, 1996</FONT>
	<BR>
	<A HREF="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
