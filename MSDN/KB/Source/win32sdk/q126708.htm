

<HTML>
<HEAD>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>HOWTO: Pass Large Memory Block Through Win32s Universal Thunk </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q126708">
<META NAME="KBModify" CONTENT="1997/06/10">
<META NAME="KBCreate" CONTENT="1995/02/28">
<META NAME="Keywords" CONTENT="kbprg W32s">
<META NAME="KBArea" CONTENT="Support; KB; win32sdk">
<META NAME="Description" CONTENT="  You can share memory between 32-bit code and 16-bit code under Win32s using either GlobalAlloc or passing a memory address to a Universal Thunk (UT) routine. For general information on how to share memory under Win32s, please refer to the following...">
<META NAME="Product" CONTENT="Win32 SDK">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QAH6,QAH7,QAD7,QBW6,QAHC,QA2O,QABA,QAC2,QABI,QAH4,QAA8,QA7H,QA6A,QANG,QAR5 V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>HOWTO: Pass Large Memory Block Through Win32s Universal Thunk</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  June 10, 1997</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q126708</B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
 
The information in this article applies to:

<UL><LI>Microsoft Win32s version 1.2, 1.30, 1.30a, 1.30c
</UL> 
<P>
<P><h2>SUMMARY</h2>
 
<P>
You can share memory between 32-bit code and 16-bit code under Win32s using
either GlobalAlloc or passing a memory address to a Universal Thunk (UT)
routine. For general information on how to share memory under Win32s,
please refer to the following Knowledge Base article:
<P>
<PRE>  ARTICLE ID: <B><A HREF="../WIN32SDK/Q105762.htm">Q105762</A></B>
  TITLE     : HOWTO: Share Memory Between 32-Bit and 16-Bit Code on Win32s

</PRE>When you pass a memory address to a thunk routine, the pointer address is
translated via the universal thunk (UT). However, the translated pointer is
only guaranteed for 32K due to performance reasons. For more information on
this limitation, please refer to the following Knowledge Base article:
<P>
<PRE>  ARTICLE ID: <B><A HREF="../WIN32SDK/Q100833.htm">Q100833</A></B>
  TITLE     : INFO: Win32s Translated Pointers Guaranteed for 32K

</PRE>This article describes ways to pass a larger memory block (including
greater than 64K in size) through the Universal Thunk under Win32s.
<P>
<P><h2>MORE INFORMATION</h2>
 
<P>
<P><h3>GlobalAlloc()</h3>
 
<P>
You can call GlobalAlloc() to allocate a larger memory block on the 32-bit
side of the thunk, copy the data into this memory block, send the handle
to the 16-bit side, and lock the handle on the 16-bit side with
GlobalLock(). With this method, you are not limited by the size of the
block that can be passed across the thunk. If the memory block that you
are passing is more than 64K in size, make sure to type cast the return
value from GlobalLock() to a huge pointer on the 16-bit side.
<P>
<P><h3>VirtualAlloc()or HeapAlloc()</h3>
 
<P>
If you allocate the memory using VirtualAlloc(), it will be aligned on a
64K boundary, so that you can address the entire memory block. HeapAlloc()
allocates large memory blocks using VirtualAlloc() as well. NOTE: You
are still limited to 64K of memory, due to the selector tiling.
<P>
<P><h3>Allocate a selector</h3>
 
<P>
To use this method, get the 32-bit offset used by the Win32-based
application and the selector base for the data selector returned by
GetThreadSelectorEntry(), then calculate the linear address of the memory
block. With this linear address, you can use AllocSelector(),
SetSelectorBase(), and SetSelectorLimit() to access the memory block from
the 16-bit side of the thunk.
<P>
For more information on converting the linear address to flat offset on
Win32s, please refer to the following Knowledge Base article:
<P>
<PRE>  ARTICLE ID: <B><A HREF="../WIN32SDK/Q115080.htm">Q115080</A></B>
  TITLE     : HOWTO: Convert a Linear Address to a Flat Offset on Win32s

</PRE>For more information on allocating and using a selector on the 16-bit
side, please refer to the following Knowledge Base article:
<P>
<PRE>  ARTICLE ID: <B><A HREF="../WIN16SDK/Q132005.htm">Q132005</A></B>
  TITLE     : DOCERR: AllocSelector &amp; FreeSelector Documentation Incomplete

</PRE>NOTE: Sparse memory will cause problems in the general case. Make sure that
the memory range has been not only reserved, but also committed.
 

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
Keywords            : kbprg W32s<BR>
Version             : 1.2 1.3 1.30a 1.30c<BR>
Platform            : WINDOWS<BR>
Issue type          : kbhowto<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  June 10, 1997</FONT>
	<BR>
	<A HREF="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
