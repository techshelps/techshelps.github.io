

<HTML>
<HEAD>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>INFO: How Drivers Notify User-Mode Apps of Asynchronous Events </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q117308">
<META NAME="KBModify" CONTENT="1998/02/17">
<META NAME="KBCreate" CONTENT="1994/06/26">
<META NAME="Keywords" CONTENT="">
<META NAME="KBArea" CONTENT="Support; KB; win32ddk">
<META NAME="Description" CONTENT="  In Windows NT, a kernel-mode driver cannot call back into a user-mode application. This is by design. For a driver to notify the application for an asynchronous event, the application needs to keep an I/O request pending with the driver at all time...">
<META NAME="Product" CONTENT="Win32 DDK">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QAGI,QAU9,QAO4,QAPN,QBWP,QAJH,QBB0,QAUQ,QAH4,QAGB,QAIF,QAHT,QADP,QBXN,QAGC V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>INFO: How Drivers Notify User-Mode Apps of Asynchronous Events</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  February 17, 1998</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q117308</B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



<P><h3> </h3>
 
The information in this article applies to:

<UL><LI>Microsoft Win32 Device Development Kit (DDK) for Windows NT,
   versions 3.1, 3.5, 3.51
</UL> 
<P>
<P><h2>SUMMARY</h2>
 
<P>
In Windows NT, a kernel-mode driver cannot call back into a user-mode
application. This is by design. For a driver to notify the application for
an asynchronous event, the application needs to keep an I/O request pending
with the driver at all times so that the driver can complete the request
each time the event occurs. This article outlines a typical scheme that an
application and a driver can use to accomplish asynchronous notification.
<P>
<P><h2>MORE INFORMATION</h2>
 
<P>
<P><h3>The Application</h3>
 
<P>
The application can have a dedicated input thread. The thread goes into a
loop that sends an I/O request and waits for response. If the driver has
been opened and a handle, hDevice, is obtained, the loop can look like the
following:
<P>
<PRE>   while (!ApplicationExiting) {
   
      returnval = DeviceIoControl (hDevice, dwIoControlCode,
                            lpvInBuffer, cbInBuffer, lpvOutBuffer,
                            cbOutBuffer, lpcbBytesReturned, lpoOverlapped);
           if (!returnval &amp;&amp; (GetLastError() == ERROR_IO_PENDING)) {
            WaitForSingleObject (hEvent, INFINITE) // hEvent is located in
   overlapped structure as well
         ... // Code to do action
         ResetEvent (hEvent)
      }
      { ... // Code to handle other situations }
   }

</PRE>The BOOL type, ApplicationExiting(), represents the condition for which the
loop should stop checking for events. The main thread of the application
can set this BOOL to TRUE when it is time to quit. The I/O control code,
dwIoControlCode(), is defined by the driver.
<P>
The above DeviceIoControl call must be made asynchronously in order for the
other application threads to be able to continue to send requests to the
driver while this request is pending. The event that was initialized and
placed in the overlapped structure of the DeviceIoControl call can be used
to make this thread synchronous with the completion of the request. Once
that event has been satisfied, this thread can notify the other application
threads that the event has signaled. If the overlapped structure is not
specified, all other threads will be blocked while this request is
processed in the driver. The other threads will not be released until the
synchronous DeviceIoControl has been completed.
<P>
The user-mode thread can also use ReadFile() or ReadFileEx() instead of
DeviceIoControl() if the driver uses a read request to send in an
asynchronous event notification.
<P>
<P><h3>The Driver</h3>
 
<P>
The driver should not complete the I/O request until an event has occurred.
When the driver receives the I/O request, if an event has occurred and is
waiting to be sent to the application, the driver can complete the request
in the dispatch routine. If no event is waiting to be reported, the driver
should perform the following steps:

<OL><P><LI>Mark the Irp pending, using IoMarkIrpPending().

<P><LI>Set up a cancel routine for the Irp, using IoSetCancelRoutine().

<P><LI>Put the Irp in a storing place (a queue for example).

<P><LI>Return STATUS_PENDING from the dispatch routine.
<P>
</OL>Later, when an event has occurred, the driver can complete the pending
request from its deferred procedure call (DPC) routine. Before the Irp can
be completed, the driver should set the cancel routine address to NULL
using IoSetCancelRoutine.
 
<PRE>Version           : WINNT: 3.1,3.5,3.51;
Platform          : winnt
Issue type        : kbinfo</PRE>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
================================================================================<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  February 17, 1998</FONT>
	<BR>
	<A HREF="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
