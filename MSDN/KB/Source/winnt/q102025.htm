

<HTML>
<HEAD>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Explanation of Big Endian and Little Endian Architecture </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q102025">
<META NAME="KBModify" CONTENT="1997/05/08">
<META NAME="KBCreate" CONTENT="1993/07/27">
<META NAME="Keywords" CONTENT="kbhw nthw">
<META NAME="KBArea" CONTENT="Support; KB; winnt, crossnet, iis">
<META NAME="Description" CONTENT="  When designing computers, there are two different architectures for handling memory storage. They are called Big Endian and Little Endian and refer to the order in which the bytes are stored in memory. Windows NT was designed around Little Endian a...">
<META NAME="Product" CONTENT="Windows NT">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QBWP,QAH4,QAPF,QAJQ,QAI4,QBVV,QBSO,QAJG,QAHT,QDIO,QBW6,QA4F,QALF,QAKD,QAG0 V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>Explanation of Big Endian and Little Endian Architecture</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  May 8, 1997</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q102025</B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



<P><h3> </h3>
 
The information in this article applies to:

<UL><LI>Microsoft Windows NT operating system, version 3.1
<LI>Microsoft Windows NT Advanced Server, version 3.1
</UL> 
<P>
<P><h2>SUMMARY</h2>
 
<P>
When designing computers, there are two different architectures for
handling memory storage. They are called Big Endian and Little Endian
and refer to the order in which the bytes are stored in memory.
Windows NT was designed around Little Endian architecture and was not
designed to be compatible with Big Endian because most programs are
written with some dependency on Little Endian.
<P>
<P><h2>MORE INFORMATION</h2>
 
<P>
These two phrases are derived from "Big End In" and "Little End In."
They refer to the way in which memory is stored. On an Intel computer,
the little end is stored first. This means a Hex word like 0x1234 is
stored in memory as (0x34 0x12). The little end, or lower end, is
stored first. The same is true for a four-byte value; for example,
0x12345678 would be stored as (0x78 0x56 0x34 0x12). "Big End In" does
this in the reverse fashion, so 0x1234 would be stored as (0x12 0x34)
in memory. This is the method used by Motorola computers and can also
be used on RISC-based computers. The RISC-based MIPS computers and the
DEC Alpha computers are configurable for Big Endian or Little Endian.
Windows NT works only in the Little Endian mode on both computers.
<P>
Windows NT was designed around Little Endian architecture. The
Hardware Abstraction Layer (HAL) is written so that all operating
system-related issues are automatically handled. Therefore, it is
possible to create a HAL that could work on Big Endian architecture.
The basic problem with porting the code has to do with the way the
code is written for all programs. Code is often written with the
assumption that Big Endian or Little Endian is being used. This may
not be specific to the HAL; it could be something as simple as bit
masking for graphics. To clarify this concept more, two programming
examples follow.
<P>
<P><h3>Example 1</h3>
 
<P>
<PRE>   struct
   {
      WORD y;
      WORD x;
   } POS;

   lparam = (DWORD) POS;

</PRE>Basically, there is assumption in the code that Little Endian is being
used. The switching of the bytes is being assumed in the 'C'
structure. This is faster on Intel architecture, but will not work
with Big Endian.
<P>
<P><h3>Example 2</h3>
 
<P>
Another example is a common practice of using bit masks. The following
is an example of defining a bit mask:
<P>
<PRE>   #define BITMASK    0x0008

</PRE>This allows you to check if the 4th bit is a 1 if you AND it with
another number. It also allows you to set the 4th bit by OR-ing it
with another value. The problem comes when you OR or AND this with
DWORD (Double Word) or anything other than a WORD size value. This
causes strange things to happen and unexpected results. You might make
assumptions about how it works with Little Endian, yet it won't work
the same way with Big Endian. A large amount of code is already
created with these assumptions built in.
<P>
Note that the PowerPC and Sparc chips are also switchable between Little
Endian and Big Endian. However, the Apple PowerMac implementation of the
PowerPC chip is stuck in Big Endian mode. Hence, Windows NT may port to the
PowerPC, but probably not to the PowerMac implementation of the PowerPC.
<P>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
Additional query words: prodnt uuh apple mips<BR>
Keywords            : kbhw nthw<BR>
Version             : 3.1<BR>
Platform            : WINDOWS<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  May 8, 1997</FONT>
	<BR>
	<A HREF="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
