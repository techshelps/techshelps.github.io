

<HTML>
<HEAD>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>IEEE Floating-Point Representation and MS Languages </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q36068 ">
<META NAME="KBModify" CONTENT="1997/02/28">
<META NAME="KBCreate" CONTENT="1988/10/12">
<META NAME="Keywords" CONTENT="CLngIss FORTLngIss MASMLngIss kbprg">
<META NAME="KBArea" CONTENT="Support; KB; visualc">
<META NAME="Description" CONTENT=" The information in this article is included in the documentation starting with Visual C++ 5.0. Look there for future revisions.   The following information discusses how real*4 (single precision) and real*8 (double precision) numbers are stored inte...">
<META NAME="Product" CONTENT="Visual C++">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QBB2,QAXS,QANY,QAKC,QAJQ,QBWP,QDNG,QBFY,QAHH,QARU,QBC6,QBC9,QBC8,QANO,QBVV V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>IEEE Floating-Point Representation and MS Languages</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  February 28, 1997</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q36068 </B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
6.00 6.00a 6.00ax 7.00 | 1.00 1.50 1.51 1.52 | 1.00 2.00 2.10 4.00
<PRE>MS-DOS                 | WINDOWS             | WINDOWS NT
</PRE>kbprg
<P>
<P>
 
The information in this article applies to:

<UL><LI>Microsoft C for MS-DOS, versions 6.0, 6.0a, and 6.0ax
<LI>Microsoft C/C++ for MS-DOS, version 7.0
<LI>Microsoft Visual C++ for Windows, versions 1.0, 1.5, 1.51, and 1.52
<LI>Microsoft Visual C++ 32-bit Edition, versions 1.0, 2.0, 2.1, and 4.0
<LI>Microsoft FORTRAN, version 5.1
<LI>Microsoft FORTRAN PowerStation for MS-DOS, versions 1.0 and 1.0a
<LI>Microsoft FORTRAN PowerStation 32 for Windows NT, version 1.0
<LI>Microsoft Macro Assembler (MASM), versions 5.1, 6.0, 6.1, and 6.11
</UL> 
<P>
The information in this article is included in the documentation starting
with Visual C++ 5.0. Look there for future revisions.
<P>
<P><h2>SUMMARY</h2>
 
<P>
The following information discusses how real*4 (single precision) and
real*8 (double precision) numbers are stored internally by Microsoft
languages that use the IEEE floating-point format.
<P>
<P><h2>MORE INFORMATION</h2>
 
<P>
There are three internal varieties of real numbers. Microsoft is consistent
with the IEEE numeric standards. Real*4 and real*8 are used in all of our
languages. Real*10 is used with MASM and in the 16-bit versions of the C
compiler. In 16-bit applications, Real* 10 is the internal floating-point
format used in the numerical processors and coprocessors for the Intel
80x86 processor family and also in the emulator math package which emulates
the Intel processors.
<P>
In FORTRAN, real*4 is declared using the words "REAL" or "REAL*4." The
words "DOUBLE PRECISION" or "REAL*8" are used to declare a real*8
number. Real*10 variables cannot be specified in FORTRAN.
<P>
In C, real*4 is declared using the word "float." Real*8 is declared
using the word "double". Real*10 is declared using the words "long
double".
<P>
In MASM, real*4 is declared with the "DD" directive, real*8 is
declared with the "DQ" directive, and real*10 is declared with the
"DT" directive.
<P>
The values are stored as follows:
<P>
<PRE>   real*4  sign bit, 8  bit exponent, 23 bit mantissa
   real*8  sign bit, 11 bit exponent, 52 bit mantissa
   real*10 sign bit, 15 bit exponent, 64 bit mantissa

</PRE>In real*4 and real*8 formats, there is an assumed leading 1 in the
mantissa that is not stored in memory, so the mantissas are actually
24 or 53 bits, even though only 23 or 52 bits are stored. The real*10
format actually stores this bit.
<P>
The exponents are biased by half of their possible value. This means
you subtract this bias from the stored exponent to get the actual
exponent. If the stored exponent is less than the bias, it is actually
a negative exponent.
<P>
The exponents are biased as follows:
<P>
<PRE>   8-bit  (real*4)  exponents are biased by 127
   11-bit (real*8)  exponents are biased by 1023
   15-bit (real*10) exponents are biased by 16383

</PRE>These exponents are not powers of ten; they are powers of two, that
is, 8-bit stored exponents can be up to 127. 2**127 is roughly
equivalent to 10**38, which is the actual limit of real*4.
<P>
The mantissa is stored as a binary fraction of the form 1.XXX... .
This fraction has a value greater than or equal to 1 and less than 2.
Note that real numbers are always stored in normalized form, that is,
the mantissa is left-shifted such that the high-order bit of the
mantissa is always 1. Because this bit is always 1, it is assumed (not
stored) in the real*4 and real*8 formats. The binary (not decimal)
point is assumed to be just to the right of the leading 1.
<P>
The format, then, for the various sizes is as follows:
<P>
<PRE>              BYTE 1    BYTE 2    BYTE 3    BYTE 4   ...  BYTE n
   real*4    SXXX XXXX XMMM MMMM MMMM MMMM MMMM MMMM
   real*8    SXXX XXXX XXXX MMMM MMMM MMMM MMMM MMMM ... MMMM MMMM
   real*10   SXXX XXXX XXXX XXXX 1MMM MMMM MMMM MMMM ... MMMM MMMM

</PRE>S represents the sign bit, the X's are the exponent bits, and the M's
are the mantissa bits. Note that the leftmost bit is assumed in real*4
and real*8 formats, but present as "1" in BYTE 3 of the real*10
format.
<P>
To shift the binary point properly, you first un-bias the exponent and
then move the binary point to the right or left the appropriate number
of bits.
<P>
The following are some examples in real*4 format:
<P>
<PRE>                    SXXX XXXX XMMM MMMM ... MMMM MMMM
</PRE>2   =  1  * 2**1  = 0100 0000 0000 0000 ... 0000 0000 = 4000 0000
<P>
<PRE>   Note the sign bit is zero, and the stored exponent is 128, or
   100 0000 0 in binary, which is 127 plus 1. The stored mantissa is
   (1.) 000 0000 ... 0000 0000, which has an implied leading 1 and
   binary point, so the actual mantissa is one.

</PRE>-2  = -1  * 2**1  = 1100 0000 0000 0000 ... 0000 0000 = C000 0000
<P>
<PRE>   Same as +2 except that the sign bit is set. This is true for all
   IEEE format floating-point numbers.

 4  =  1  * 2**2  = 0100 0000 1000 0000 ... 0000 0000 = 4080 0000

   Same mantissa, exponent increases by one (biased value is 129, or
   100 0000 1 in binary.

 6  = 1.5 * 2**2  = 0100 0000 1100 0000 ... 0000 0000 = 40C0 0000

   Same exponent, mantissa is larger by half--it's (1.) 100 0000 ...
   0000 0000, which, since this is a binary fraction, is 1 1/2 (the
   values of the fractional digits are 1/2, 1/4, 1/8, and so forth.).

 1  = 1   * 2**0  = 0011 1111 1000 0000 ... 0000 0000 = 3F80 0000

   Same exponent as other powers of two, mantissa is one less than two
   at 127, or 011 1111 1 in binary.

</PRE>.75 = 1.5 * 2**-1 = 0011 1111 0100 0000 ... 0000 0000 = 3F40 0000
<P>
<PRE>   The biased exponent is 126, 011 1111 0 in binary, and the mantissa
   is (1.) 100 0000 ... 0000 0000, which is 1 1/2.

</PRE>2.5 = 1.25 * 2**1 = 0100 0000 0010 0000 ... 0000 0000 = 4020 0000
<P>
<PRE>   Exactly the same as two except that the bit that represents 1/4 is
   set in the mantissa.

</PRE>0.1 = 1.6 * 2**-4 = 0011 1101 1100 1100 ... 1100 1101 = 3DCC CCCD
<P>
<PRE>   1/10 is a repeating fraction in binary. The mantissa is just shy of
   1.6, and the biased exponent says that 1.6 is to be divided by 16
   (it is 011 1101 1 in binary, which is 123 in decimal). The true
   exponent is 123 - 127 = -4, which means that the factor by which to
   multiply is 2**-4 = 1/16. Note that the stored mantissa is rounded
   up in the last bit -- an attempt to represent the unrepresentable
   number as accurately as possible. (The reason that 1/10 and 1/100
   are not exactly representable in binary similar to the reason that
   1/3 is not exactly representable in decimal.)

 0  = 1.0 * 2**-128 = all zero's--a special case.

</PRE><h2>REFERENCES</h2>
 
<P>
For more information, please see the following article in the Microsoft
Knowledge Base:
<P>
<PRE>   ARTICLE-ID: <B><A HREF="../URJump.htm">Q92762</A></B>
   TITLE     : Size and Alignment of Data Types Under Windows NT
</PRE>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
KBCategory: kbprg<BR>
KBSubcategory: CLngIss FORTLngIss MASMLngIss<BR>
Additional reference words: kbinf 1.00 1.50 2.00 2.10 4.00 5.10 6.00 6.00a<BR>
6.00ax 7.00 8.00 8.00c 9.00 9.10 floating point 8087 80287 80387 80486<BR>
pentium<BR>
Keywords            : CLngIss FORTLngIss MASMLngIss kbprg<BR>
Version             : 6.00 6.00a 6.00ax 7.00 | 1.00 1.<BR>
Platform            : MS-DOS NT WINDOWS<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  February 28, 1997</FONT>
	<BR>
	<A HREF="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
