

<HTML>
<HEAD>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>INFO: Why pointer1++ = pointer2 Is Not Proper </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q38218 ">
<META NAME="KBModify" CONTENT="1997/08/26">
<META NAME="KBCreate" CONTENT="1988/11/19">
<META NAME="Keywords" CONTENT="CLngIss kbfasttip">
<META NAME="KBArea" CONTENT="Support; KB; visualc">
<META NAME="Description" CONTENT="  The following statement is not correct because the post-increment operator (++) has higher precedence than the assignment operator (=):     pointer1++ = pointer2;  The following statement     pointer1++ = pointer2 ;  is equivalent to the following ...">
<META NAME="Product" CONTENT="Visual C++">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QBQU,QAPN,QAJQ,QAKD,QAB9,QAR4,QBVV,QBFY,QAKM,QBWP,QANY,QAL3,QDL9,QBWQ,QBWO V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>INFO: Why pointer1++ = pointer2 Is Not Proper</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  August 26, 1997</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q38218 </B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
 
The information in this article applies to:

<UL><LI>Microsoft C for MS-DOS, versions 5.1, 6.0, 6.0a, 6.0ax
<LI>Microsoft C/C++ for MS-DOS, version 7.0
<LI>Microsoft Visual C++ for Windows, versions 1.0, 1.5, 1.51, 1.52
<LI>Microsoft Visual C++ 32-bit Edition, versions 1.0, 2.0, 2.1, 4.0, 5.0
</UL> 
<P>
<P><h2>SUMMARY</h2>
 
<P>
The following statement is not correct because the post-increment
operator (++) has higher precedence than the assignment operator (=):
<P>
<PRE>   pointer1++ = pointer2;

</PRE>The following statement
<P>
<PRE>   pointer1++ = pointer2 ;

</PRE>is equivalent to the following statement:
<P>
<PRE>   (pointer1++) = pointer2 ;

</PRE><h2>MORE INFORMATION</h2>
 
<P>
As defined by the post-increment operation, the result of evaluating
the expression (pointer1++) is NOT an lvalue; therefore, (pointer1++)
cannot be used as a left operand of the assignment operator.
<P>
However, a statement such as the following is correct:
<P>
<PRE>   *(pointer1++) = *pointer2;

</PRE>The above statement is equivalent to:
<P>
<PRE>   *pointer1++ = *pointer2;

</PRE>This statement is correct because although (pointer1++) is not an
lvalue, it can be used for indirection and *(pointer1++) is an lvalue.
<P>
It is very important to understand the difference between the value of
the expression (pointer1++) and the value of pointer1. Although
(pointer1++) has higher precedence in the above statements, the result
of evaluating (pointer1++) has the old value that pointer1 had before
the evaluation of the expression (pointer1++). Because of the side
effect of the post-increment operator, the evaluation of (pointer1++)
causes the value of pointer1 to be incremented by one only after the
rest of the statement has been evaluated. In other words, as an
address, (pointer1++) points to the same memory location as pointer1
used to. Therefore, *pointer1++ or *(pointer1++) represents the same
object as *pointer1 used to.
<P>
The following example has the effect of assigning "a" to memory offset
location 0x100, then incrementing ptr1 to point to memory offset
0x101:
<P>
<PRE>char * ptr1 = 0x100; /* ptr1 points to memory offset 0x100 */

*ptr1++ = 'a';       /* ptr1 points to memory offset 0x101 */
</PRE> 
<PRE>Keywords          : CLngIss kbfasttip
Version           : MS-DOS:5.1,6.0,6.00a,6.00ax,7.0;  WINDOWS:1.0,1.5,1.51,1.52; WINDOWS NT:1.0,2.0,2.1,4.0,5.0
Platform          : MS-DOS NT WINDOWS</PRE>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
================================================================================<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  August 26, 1997</FONT>
	<BR>
	<A HREF="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
