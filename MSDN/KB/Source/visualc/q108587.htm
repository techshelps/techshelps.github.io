

<HTML>
<HEAD>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>HOWTO: Get Current CDocument or CView from Anywhere </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q108587">
<META NAME="KBModify" CONTENT="1997/07/31">
<META NAME="KBCreate" CONTENT="1993/12/14">
<META NAME="Keywords" CONTENT="MfcDocView kbhowto">
<META NAME="KBArea" CONTENT="Support; KB; visualc">
<META NAME="Description" CONTENT="  In a Microsoft Foundation Classes (MFC) Windows-based application, it is often useful to be able to get a pointer to the currently active document or view from anywhere in the program. For example, being able to access the current document from a d...">
<META NAME="Product" CONTENT="Visual C++">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QAUD,QADK,QAH4,QAY5,QALW,QAO3,QAO2,QA01,QAY2,QBWT,QABO,QBV8,QA62,QAB9,QAJH V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>HOWTO: Get Current CDocument or CView from Anywhere</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  July 31, 1997</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q108587</B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



<P><h3> </h3>
 
The information in this article applies to:

<UL><LI>The Microsoft Foundation Classes (MFC), included with:
<P><PRE>    - Microsoft Visual C++ for Windows, versions 1.0, 1.5, 1.51, 1.52
    - Microsoft Visual C++ 32-bit Edition, versions 1.0, 2.0, 2.1, 4.0,
      4.1
</UL></PRE> 
<P>
<P><h2>SUMMARY</h2>
 
<P>
In a Microsoft Foundation Classes (MFC) Windows-based application, it
is often useful to be able to get a pointer to the currently active
document or view from anywhere in the program. For example, being able to
access the current document from a dialog box is sometimes useful. This
article discusses the simplest methods for doing so, using the
relationships between MFC objects, and basic MFC architecture.
<P>
<P><h2>MORE INFORMATION</h2>
 
<P>
One of the cases where you might need a pointer to the currently active
view or document is in a modal or modeless dialog box. Generally, a dialog
box should be created by the view class, because the view is what deals
with the application's user interface.
<P>
Because the view class is creating the dialog box, it can pass a pointer to
itself, or the active document [obtained with the GetActiveDocument()
function] to the dialog box. This could be done through the dialog box's
constructor or some other member function. For modal dialog boxes, the view
could also put data from the dialog box into the document when DoModal()
returns.
<P>
These methods are generally preferable to relying on generic functions to
return pointers to the currently active view or document.
<P>
To allow you to get a pointer to the currently active document from
anywhere in the program, add a static member function to your CDocument
derived class as follows:
<P>
Edit the document's header file as follows to add a static member function,
GetDoc():
<P>
<PRE>   // Document header file
   class CMyDoc : public CDocument
   {
      ...
      public:
      static CMyDoc * GetDoc();
      ...
   };

</PRE>For a single document interface (SDI) application, add the following code
to your SDI document's implementation file for CMyDoc::GetDoc():
<P>
<PRE>   // SDI document implementation file
   CMyDoc * CMyDoc::GetDoc()
   {
      CFrameWnd * pFrame = (CFrameWnd *)(AfxGetApp()-&gt;m_pMainWnd);
      return (CMyDoc *) pFrame-&gt;GetActiveDocument();
   }

</PRE>For a multiple document interface (MDI) application, the CMyDoc::GetDoc()
code should be the following:
<P>
<PRE>   CMyDoc * CMyDoc::GetDoc()
   {
      CMDIChildWnd * pChild =
          ((CMDIFrameWnd*)(AfxGetApp()-&gt;m_pMainWnd))-&gt;MDIGetActive();

      if ( !pChild )
          return NULL;

      CDocument * pDoc = pChild-&gt;GetActiveDocument();

      if ( !pDoc )
         return NULL;

      // Fail if doc is of wrong kind
      if ( ! pDoc-&gt;IsKindOf( RUNTIME_CLASS(CMyDoc) ) )
         return NULL;

      return (CMyDoc *) pDoc;
   }

</PRE>To allow you to get a pointer to the currently active view from anywhere in
the program, add a static member function to your CView derived class as
follows:
<P>
Edit the view's header file as follows to add a static member function,
GetView():
<P>
<PRE>   // View header file
   class CMyView
   {
      ...
      public:
      static CMyView * GetView();
      ...
   };

</PRE>For an SDI application, add the following code to your SDI view's
implementation file for CMyView::GetView():
<P>
<PRE>   // View implementation file
   CMyView * CMyView::GetView()
   {
      CFrameWnd * pFrame = (CFrameWnd *)(AfxGetApp()-&gt;m_pMainWnd);

      CView * pView = pFrame-&gt;GetActiveView();

      if ( !pView )
         return NULL;

      // Fail if view is of wrong kind
      // (this could occur with splitter windows, or additional
      // views on a single document
      if ( ! pView-&gt;IsKindOf( RUNTIME_CLASS(CMyView) ) )
         return NULL;

      return (CMyView *) pView;
   }

</PRE>For an MDI application, the CMyView::GetView() code should be the
following:
<P>
<PRE>   // MDI view implementation file
   CMyView * CMyView::GetView()
   {
      CMDIChildWnd * pChild =
          ((CMDIFrameWnd*)(AfxGetApp()-&gt;m_pMainWnd))-&gt;MDIGetActive();

      if ( !pChild )
          return NULL;

      CView * pView = pChild-&gt;GetActiveView();

      if ( !pView )
         return NULL;

      // Fail if view is of wrong kind
      if ( ! pView-&gt;IsKindOf( RUNTIME_CLASS(CMyView) ) )
         return NULL;

      return (CMyView *) pView;
   }

</PRE>Now, from anywhere in your program, where the document or view header files
have been included, you can call:
<P>
<PRE>   CMyDoc::GetDoc();

</PRE>-or-
<P>
<PRE>   CMyView::GetView();

</PRE>to get a pointer to the currently active document or view, respectively.
These functions return NULL if there is no active document or view.
<P>
Note that a pointer to the application's CDocument or CView derived class
is returned, not just a generic CDocument or CView pointer. This allows you
to access members specific to your new class. The MDI versions of these
functions, and the SDI version of the GetView() function, will use run-time
type checking to verify that the document or view is of the correct class.
<P>
<P><h2>REFERENCES</h2>
 
<P>
For more information on this subject, and on the member functions used,
please see:
<P>
Visual C++ 1.0 and Visual C++ for Windows NT "Class Library Reference,
Volume I," page 35, "Relationships Among Documents, Views, Frame Windows,
Templates, and the Application."
<P>
CFrameWnd documentation in the same manual.
 
<PRE>Keywords          : MfcDocView kbhowto
Technology        : kbmfc
Version           : 1.0 1.5 1.51 1.52 2.0 2.1 4.0 4.
Platform          : NT WINDOWS</PRE>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
================================================================================<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  July 31, 1997</FONT>
	<BR>
	<A HREF="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
