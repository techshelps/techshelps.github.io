

<HTML>
<HEAD>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Foundation Class Debug Library Detects Memory Leaks </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q99022 ">
<META NAME="KBModify" CONTENT="1997/07/31">
<META NAME="KBCreate" CONTENT="1993/05/19">
<META NAME="Keywords" CONTENT="MfcMisc kbfasttip kbprg">
<META NAME="KBArea" CONTENT="Support; KB; visualc">
<META NAME="Description" CONTENT="  Version 2.0 of the Microsoft Foundation Classes debugging libraries provide automatic memory leak detection, a new feature that version 1.0 did not provide.  In an application developed with a Microsoft Foundation Classes version 1.0 library, the a...">
<META NAME="Product" CONTENT="Visual C++">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QAH4,QAGI,QBW6,QBHQ,QAEF,QAW6,QAPN,QBFY,QAY5,QBF0,QAIF,QAPF,QABG,QBVV,QA5A V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>Foundation Class Debug Library Detects Memory Leaks</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  July 31, 1997</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q99022 </B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
1.00 1.50 1.51 1.52 | 1.00
<PRE>WINDOWS             | WINDOWS NT
</PRE>kbprg
<P>
 
The information in this article applies to:

<UL><LI>The Microsoft Foundation Classes (MFC) included with:
<P>
<P><PRE>     - Microsoft C/C++ version 7.0
     - Microsoft Visual C++ for Windows, versions 1.0, 1.5, 1.51 and
       1.52
     - Microsoft Visual C++, 32-bit Edition, versions 1.0
</UL></PRE> 
<P>
<P><h2>SUMMARY</h2>
 
<P>
Version 2.0 of the Microsoft Foundation Classes debugging libraries
provide automatic memory leak detection, a new feature that version
1.0 did not provide.
<P>
In an application developed with a Microsoft Foundation Classes
version 1.0 library, the application object code typically calls the
Checkpoint() function in CMemoryState objects in its InitInstance()
and ExitInstance() functions. Then the application calls the
CMemoryState::Difference() function to verify that no memory leaked
during execution. This process is not necessary when the application
uses library version 2.0.
<P>
The Microsoft Foundation Classes version 2.0 debugging libraries
automatically perform memory leak detection. The detection code is in
AFXMEM.CPP, which is installed in the C:\MSVC\MFC\SRC directory by
default. This code detects the case in which an application
dynamically allocates an object and fails to delete the object before
the program terminates. The library sends a TRACE() message to the
debug window stating that memory has leaked. To see these messages,
TRACE() output must be enabled. Please refer to MFC Tech Note #7 for
more information about enabling TRACE() output.
<P>
In version 2.0, placing a CMemoryState::Checkpoint() call in
InitInstance() and ExitInstance(), as demonstrated in the code example
below, does not function correctly. The code example below produces
the following output:
<P>
<PRE>   Memory leaked
   0 bytes in 0 Free Blocks
   0 bytes in 0 Object Blocks
   -56 bytes in -4 Non-Object Blocks

</PRE>The negative numbers indicate that memory is allocated before the
Checkpoint() call in InitInstance() and freed before the Checkpoint()
call in ExitInstance().
<P>
The output shown above is for an application built using the medium memory
model. An application built using the large memory model will double the
byte count shown in the last line of output like so:
<P>
<PRE>  -112 bytes in -4 Non-Object blocks

</PRE>In the Microsoft Foundation Classes Library source code file
WINHAND.CPP, line 75 calls InitHashTable(). The code is as follows:
<P>
<PRE>   m_temporaryMap.InitHashTable(7); // small table for temporary map

</PRE>The code calls this function for each CHandleMap object: _afxMapHDC,
_afxMapHGDIOBJ, _afxMapHMENU, and _afxMapHWND. These hash tables
contain the permanent and temporary maps for window handles and their
associated C++ objects.
<P>
The initial temporary maps that this function creates are destroyed in
the CWinApp::OnIdle() function. In order for manual memory leak
detection to work correctly, these temporary maps may be removed
before your first memory checkpoint is initialized by calling
DeleteTempMap() for each of the CHandleMap objects. In the code
example below, removing the comment indication from the specified
lines of code deletes the temporary maps and enables the manual memory
leak detection code to work correctly.
<P>
As mentioned above, the Microsoft Foundation Classes debugging
libraries for version 2.0 automatically detect memory leaks and the
leak detection code shown below is not necessary.
<P>
<P><h2>More Information</h2>
 
<P>
The problem described in this article does not occur in the 32-bit
<PRE>   versions of MFC included with Microsoft Visual C++ 2.0 or later.

</PRE><h3>Sample Code</h3>
 
<P>
<PRE>/*
 * Compile options needed: None
 */

</PRE>static CMemoryState oldstate, newstate, diffstate;
<P>
BOOL CTheApp::InitInstance()
{
<PRE>   // Remove the comment indication from the following 4 lines to
   // delete the temporary maps and allow the code to detect true
   // memory leaks.
   // CGdiObject::DeleteTempMap();
   // CDC::DeleteTempMap();
   // CMenu::DeleteTempMap();
   // CWnd::DeleteTempMap();

   oldstate.Checkpoint();

   m_pMainWnd = new CMainWindow();
   m_pMainWnd-&gt;ShowWindow( m_nCmdShow );
   m_pMainWnd-&gt;UpdateWindow();

   return TRUE;
</PRE>}
<P>
<PRE>int CTheApp::ExitInstance()
</PRE>{
<PRE>   newstate.Checkpoint();
   if (diffstate.Difference(oldstate, newstate))
      {
      TRACE("Memory leaked\n");
      diffstate.DumpStatistics();
      }
   return 0;
</PRE>}
<P>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
Additional reference words: kbinf 1.00 1.50 1.51 1.52 2.00 2.50 2.51 2.52<BR>
noupdate<BR>
KBCategory: kbprg kbfasttip<BR>
KBSubcategory: MfcMisc<BR>
Keywords          : MfcMisc kbfasttip kbprg<BR>
Technology        : kbMfc<BR>
Version           : 1.00 1.50 1.51 1.52 | 1.00<BR>
Platform          : NT WINDOWS<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  July 31, 1997</FONT>
	<BR>
	<A HREF="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
