

<HTML>
<HEAD>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>INFO: Stack Checking for Windows NT-based Applications </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q100775">
<META NAME="KBModify" CONTENT="1997/09/30">
<META NAME="KBCreate" CONTENT="1993/06/28">
<META NAME="Keywords" CONTENT="CLIss">
<META NAME="KBArea" CONTENT="Support; KB; visualc">
<META NAME="Description" CONTENT="  Stack checking in an application developed for Windows NT differs from stack checking in an MS-DOS application.  MORE INFORMATION  In an MS-DOS application, stack overflow is detected only by software. By default, the compiler inserts a call to the...">
<META NAME="Product" CONTENT="Visual C++">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QAGI,QAY5,QBV8,QBWP,QAH4,QBWA,QDIR,QAB9,QAOT,QBW6,QBVV,QBBI,QAIF,QAJH,QA19 V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>INFO: Stack Checking for Windows NT-based Applications</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  September 30, 1997</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q100775</B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
 
The information in this article applies to:

<UL><LI>The Microsoft C/C++ Compiler (CL.EXE) included with:
   - Microsoft Visual C++ 32-bit Edition, versions 1.0, 2.0, 2.1, 4.0, 5.0
</UL> 
<P>
<P><h2>SUMMARY</h2>
 
<P>
Stack checking in an application developed for Windows NT differs from
stack checking in an MS-DOS application.
<P>
<P><h2>MORE INFORMATION</h2>
 
<P>
In an MS-DOS application, stack overflow is detected only by software. By
default, the compiler inserts a call to the __chkstk() function in the
prologue code for each function. The __chkstk() function compares the
amount of stack space a function requires with the amount of stack space
available. The function issues an overflow error if the current stack
pointer and requested stack allocation exceeds the maximum stack size
specified in the EXE header.
<P>
In the Microsoft Windows NT operating system, stack overflow is detected by
hardware and software working together, using the page protection
mechanisms. Each new Windows NT process has a maximum reserved stack size
and an initial committed stack allocation. Committed memory is physically
allocated to the process and is backed by the page file; it is a relatively
"expensive" resource. Reserved memory is address space that is not mapped
to real memory; it is a relatively "cheap" resource.
<P>
As the stack grows, it moves from the committed portion of stack memory
into the reserved or uncommitted memory. When this happens, a page fault
occurs and the operating system commits another page of memory to the
stack. If a page fault occurs when the stack has already grown to its
maximum specified size, the system reports a stack overflow exception.
<P>
This automatic growth method uses a guard page, a reserved, uncommitted,
memory page that is contiguous with the committed portion of memory. When
the application touches the guard page, the operating system commits that
page and the next uncommitted page becomes the new guard page. Automatic
stack growth works only for the guard page and stack memory must grow in
4K, or one page, increments. If the application touches another reserved
but uncommitted page of stack memory before it touches the guard page, a
normal page fault exception occurs and unpredictable behavior can result.
<P>
If a function included the following statements in its prologue code, this
problem could occur:
<P>
<PRE>   PUSH   EBP
   MOV    EBP,ESP
   SUB    ESP,10000
   PUSH   ESI

</PRE>In this code, the PUSH EBP and PUSH ESI do not occur in the same or in
adjoining 4K stack pages. If the stack must grow to accommodate the 10,000
byte local allocation, this program faults.
<P>
To prevent the fault, the compiler calls the __chkstk() function each time
the local allocation exceeds 4K. The Windows NT __chkstk() function does
not explicitly check for stack overflow as the MS-DOS version does. It
simply touches memory addresses every 4K from the current stack pointer
location to the requested allocation. This triggers the guard pages in the
proper sequence and commits additional memory to the stack as required.
<P>
Therefore, when the compiler command line includes the /Ge option switch
and the prologue code always calls the __chkstk() function, the application
is not running as efficiently as it might because the operating system
supports an automatic mechanism to perform stack overflow detection.
<P>
The /Gs compiler option switch does not disable all __chkstk() calls.
Instead, it disables __chkstk() calls for those functions that require less
than 4K of local storage. The /Gs option is the default behavior of the
compiler.
<P>
The /Gs option accepts an optional parameter, the threshold value. If a
function's local stack allocation exceeds the specified threshold, the
compiler inserts a __chkstk() call into the function prologue. For a user-
mode application to run correctly in Windows NT, the default threshold 4096
is required. To suppress all __chkstk() calls, specify an artificially high
threshold value such as /Gs999999. The /Gs0 option has the same function as
the /Ge option and instructs the compiler to call __chkstk() in every
function. It might be advantageous to change the default value if the code
executes in an environment where the stack is fully committed or if the
stack growth mechanism is otherwise not available.
<P>
For more information, refer to the /Gs compilation option and the
check_stack preprocessor pragma in the Visual C++ Books Online.
<P>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
Additional query words: 8.00 9.00<BR>
Keywords          : CLIss<BR>
Version           : WINDOWS:1.0,2.0,2.1,4.0,5.0;<BR>
Platform          : WINDOWS<BR>
Issue type        : kbinfo<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  September 30, 1997</FONT>
	<BR>
	<A HREF="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
