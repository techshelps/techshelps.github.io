

<HTML>
<HEAD>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>HOWTO: Create 32-bit Import Libraries Without .OBJs or Source </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q131313">
<META NAME="KBModify" CONTENT="1997/10/03">
<META NAME="KBCreate" CONTENT="1995/06/07">
<META NAME="Keywords" CONTENT="LibIss LinkIss kb3rdparty kbcode">
<META NAME="KBArea" CONTENT="Support; KB; visualc">
<META NAME="Description" CONTENT="  This article explains how to create an import library given a .DLL for which you have no source code or object modules. There is no 32-bit utility that can create an import library from a .DLL, as there was with 16-bit versions of Visual C++.  NOTE...">
<META NAME="Product" CONTENT="Visual C++">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QAY5,QAB9,QBV8,QA3P,QBHQ,QBFY,QAUD,QAUJ,QBBI,QAH4,QAEQ,QA4Q,QALQ,QAK6,QABA V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>HOWTO: Create 32-bit Import Libraries Without .OBJs or Source</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  October 3, 1997</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q131313</B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
 
The information in this article applies to:

<UL><LI>The Microsoft Library Manager (LIB.EXE) included with:
   - Microsoft Visual C++, 32-bit Edition, versions 2.0, 2.1, 4.0, 5.0 on
<P><PRE>     the following platform:
     - x86
</UL></PRE> 
<P>
<P><h2>SUMMARY</h2>
 
<P>
This article explains how to create an import library given a .DLL for
which you have no source code or object modules. There is no 32-bit utility
that can create an import library from a .DLL, as there was with 16-bit
versions of Visual C++.
<P>
NOTE: This method may not work with DLLs generated with non-Microsoft
development tools.
<P>
<P><h2>MORE INFORMATION</h2>
 
<P>
Normally, when building a .DLL or any target that exports functions or data
items, an import library (and exports file) is generated as part of the
linking process. But in the case of a third-party .DLL that does not ship
with an import library, you may need to generate an import library in order
to use the .DLL successfully using load-time dynamic linking. An import
library is not needed for run-time dynamic linking.
<P>
There are two ways to create an import library given a .DLL:

<UL><LI>Create a .DEF file for use with the LIB /DEF: command.

<LI>Stub out functions, and use the .OBJ files created to mimic the
   import/export relationships. Then use the LIB /DEF: command to create
   the import library.
<P>
</UL><h3>Creating a .DEF file</h3>
 
<P>
The only time you can use a .DEF file to create an import library from a
.DLL for which you do not have the source code or object modules is if the
.DLL exports functions via a C interface. Specifically, the functions need
to have been declared to use the C calling convention. This is specified by
the _cdecl attribute, normally used in the prototype for the function. Note
that if no attribute is specified, _cdecl is the default when /Gz (_stdcall
is the default) or /Gr (_fastcall is the default) is not specified on the
CL command line. The reason for this limitation is based on an assumption
made by the LIB utility that all names are automatically exported without a
leading underscore. This is only true for _cdecl function names.
<P>
Given a .DLL with functions exported via a C interface, you can create an
import library by following these steps:

<OL><P><LI>Use DUMPBIN /EXPORTS &lt;.DLL file name&gt; to obtain the list of exported
   symbols for the .DLL in question. The symbols appear in the "name"
   column of the table whose headings are "ordinal hint name."

<P><LI>Create a .DEF file that contains an EXPORTS section with the names of
   the functions listed in the "name" column of the DUMPBIN output.

<P><LI>For _cdecl functions, the symbol appears just as it would when used in
   the calling program.  Just place this symbol in the EXPORTS section of
   the .DEF file.

<P><LI>Use LIB /DEF:&lt;.DEF file name&gt; to generate the import library and exports
   file. The base name of the import library will be the base name of the
   .DEF file.  Use /OUT: to control the output library name.
<P>
</OL><h3>Stubbing Out Functions</h3>
 
<P>
For exported functions that use calling conventions other than C, the
situation is a little more complex. This is especially true when you
consider C++ functions and the more complex name decoration schemes
involved. To use this method, you must at least have the header file that
describes the .DLL's interface.
<P>
To create stubbed functions from prototypes in a header file:

<OL><P><LI>When "__declspec(dllimport)" is used in a prototype or declaration,
   change it to "__declspec(dllexport)."

<P><LI>For functions that do not return a value, for C functions in C source,
   and for C functions in C++ source code (used with the 'extern "C"'
   construct), replace the semicolon that terminates the function prototype
   with a matched pair of curly braces ("{}").

<P><LI>For C++ functions (global or member) that return a value, you must
   create a dummy body for the function, and return a dummy value of the
   proper type. (Not having a return statement in the function is illegal.)
   This goes for class member functions, as well. Keep in mind that the
   purpose of this procedure is to trick the LIB utility into generating
   the correct import library, so these dummy bodies have no effect.

<P><LI>For C++ classes, you can stub out the member functions by using the
   prototypes in the class declaration, as long as you disable function
   inlining when you compile.

<P><LI>Function arguments are usually just specified by type in a header file.
   For example, Geta(int). A dummy argument identifier must be specified
   when adding the dummy function body Geta(int x). Otherwise the error
   C2055 is generated.
<P>
</OL><h3>Example</h3>
 
<P>
If the header file that describes MYDLL.DLL looks like:
<P>
<PRE>   // mydll.H

   extern "C" __declspec(dllimport) void _stdcall Function(void);

   class __declspec(dllimport) CMyClass {
        int a;
        long b;
   public:
        int Geta(int);
        long Getb();
        CMyClass();
   };

</PRE></OL>The dummy source file you use to build the import library should look like:
<P>
<PRE>   // mydll.CPP

   extern "C" __declspec(dllexport) void _stdcall Function(void) {}

   class __declspec(dllexport) CMyClass {
        int a;
        long b;
   public:
        int Geta(int x) {return 111;}
        long Getb() {return 111;}
        CMyClass() {}
   };

</PRE>Once the functions are stubbed out, all you need to do is compile the
source file into an .OBJ file:
<P>
<PRE>   CL /c /Ob0 mydll.CPP

</PRE>NOTE: Disabling function inlining is required to force generation of
symbols for the functions defined in CMyClass. If function inlining were
enabled, the compiler would notice that there are no references to the
member functions in the translation unit, so it would discard the function
bodies. See the discussion on inline function expansion under Optimizations
in the Visual C++ CL Command line reference.
<P>
Once you have .OBJ files, you can use LIB /DEF: to create the import
library (.LIB) and exports file (.EXP):
<P>
<PRE>   LIB /DEF: mydll.OBJ

</PRE>For more information on the LIB command, consult the "LIB Reference" in the
Visual C++ Books Online.
<P>
Also, see the following article:
<P>
<PRE>   <B><A HREF="../VISUALC/Q140485.htm">Q140485</A></B> - Exporting PASCAL-Like Symbols in 32-bit DLLs
</PRE>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
Additional query words: 2.50 2.55 LINK /LIB<BR>
Keywords          : LibIss LinkIss kb3rdparty kbcode<BR>
Version           : 2.0 2.1 4.0 5.0<BR>
Platform          : WINDOWS<BR>
Hardware          : x86<BR>
Issue type        : kbhowto<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  October 3, 1997</FONT>
	<BR>
	<A HREF="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
