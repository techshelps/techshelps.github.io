

<HTML>
<HEAD>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>HOWTO: Perform Transactions with the MFC Database Classes </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q128208">
<META NAME="KBModify" CONTENT="1997/07/31">
<META NAME="KBCreate" CONTENT="1995/03/27">
<META NAME="Keywords" CONTENT="MfcDatabase kbcode kbprg">
<META NAME="KBArea" CONTENT="Support; KB; visualc">
<META NAME="Description" CONTENT="  This article discusses topics related to MFC database transactions. Some material here is a clarification and expansion of existing documentation. Other material describes the specific transaction behavior of the Microsoft Access version 2.0 ODBC d...">
<META NAME="Product" CONTENT="Visual C++">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QAGI,QBXJ,QAY5,QA1S,QAU9,QAO2,QAYL,QAGB,QAZV,QBSO,QA9E,QAUD,QALM,QADK,QAIF V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>HOWTO: Perform Transactions with the MFC Database Classes</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  July 31, 1997</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q128208</B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
 
The information in this article applies to:

<UL><LI>The Microsoft Foundation Classes (MFC) included with:
   - Microsoft Visual C++ for Windows, versions 1.5, 1.51, 1.52
   - Microsoft Visual C++, 32-bit Edition, versions 2.0, 2.1, 4.0, 4.1, 5.0
</UL> 
<P>
<P><h2>SUMMARY</h2>
 
<P>
This article discusses topics related to MFC database transactions. Some
material here is a clarification and expansion of existing documentation.
Other material describes the specific transaction behavior of the Microsoft
Access version 2.0 ODBC driver.
<P>
Beginning with Microsoft Visual C++ version 4.2 please refer to the
following two Visual C++ Technical Notes for information on performing
transactions using the MFC Database classes: TN047 (Relaxing Database
Transaction Requirements) and TN068 (Performing Transactions with the
Microsoft Access 7 ODBC Driver).
<P>
<P><h2>MORE INFORMATION</h2>
 
<P>
<P><h3>MFC Database Transactions</h3>
 
<P>
MFC exposes database transactions through three member functions of the
CDatabase class, BeginTrans(), CommitTrans(), and Rollback(). There is a
member variable, m_bTransactions, that indicates whether the driver
provides the capabilities that MFC's model of transactions require. These
capabilities are checked in the CDatabase::Open() member function.
CDatabase::CanTransact() can be called to retrieve the state of that member
variable.
<P>
One major requirement of the MFC transaction model is that the driver
support cursor preservation across transaction commits and rollbacks. This
requirement prohibits transaction support when using most ODBC drivers.
None of the drivers shipped by Microsoft to date meet this requirement.
<P>
There is a way, however, to use transactions with some ODBC drivers that
provide a lesser degree of transaction support than what is required by the
MFC model. The steps involved in getting this support are:

<OL><P><LI>Query the driver for capabilities.

<P><LI>Manually set the m_bTransactions member variable.

<P><LI>Close or Delete the cursor after finishing the transaction.
<P>
</OL>The following sections discuss these three steps in detail.
<P>
<P><h3>Step 1 - Query the Driver for Capabilities</h3>
 
<P>
An application must check two items to determine if it is able to use
transactions as described in this article. They are transaction support and
cursor behavior. There are ODBC API calls that must be used to do this
checking. To check for transaction support, an application must call
SQLGetInfo() with the SQL_TXN_CAPABLE flag. If SQLGetInfo() returns
SQL_TC_NONE, transactions are not supported in any way by the driver and
the application will not be able to use transactions with that driver. For
more information about this, please see the documentation for SQLGetInfo()
in the ODBC version 2.0 Programmer's Reference.
<P>
After determining that the driver will support transactions, the
application must determine the cursor behavior on commit and rollback.
These capabilities can be determined by calling the SQLGetInfo() function
and specifying SQL_CURSOR_COMMIT_BEHAVIOR and SQL_CURSOR_ROLLBACK_BEHAVIOR,
respectively. These functions are called by MFC itself when checking driver
functionality in the CDatabase::Open() function. In MFC version 3.0 and
later, the results of these function calls are stored in the CDatabase
member variables m_nCursorCommitBehavior and m_nCursorRollbackBehavior. In
earlier versions of MFC, these variables do not exist, but the application
can make the SQLGetInfo() calls itself to determine the cursor behavior.
<P>
The cursor commit and cursor rollback behavior will determine how to treat
your CRecordset after the transaction completes. The following shows the
possible return values and what they mean:
<P>
<PRE>Return Value      Meaning
</PRE></OL> 
<PRE>SQL_ERROR         Transactions not supported.

SQL_CB_DELETE     CRecordset::Close() must be called
                  following commit or rollback.

SQL_CB_CLOSE      CRecordset::Requery() must be called
                  following commit or rollback.

SQL_CB_PRESERVE   No special actions need to be taken.
                  (m_bTransactions will be TRUE for a
                  driver that returns this value.)

</PRE>The cursor behavior will determine what you need to do in step 3.
<P>
<P><h3>Step 2 - Manually Set the m_bTransactions Member Variable</h3>
 
<P>
The m_bTransactions member variable of CDatabase is protected. Because of
this, you must derive a class from CDatabase to be able to change its
value. This is one way to do it:
<P>
<PRE>   class CMyDatabase : public CDatabase {

   public:
      void SetTransactions() { m_bTransactions = TRUE; }
   };

</PRE>Now, just call SetTransactions() on your CMyDatabase object to change the
m_bTransactions member to TRUE and enable transactions on your database
after making sure that transactions are supported.
<P>
Step 3 - Close or Delete the Cursor After Finishing the Transaction
 
<P>
Based on the cursor behavior determined in step 1, you must either Close()
the recordset if the cursor behavior is SQL_CB_DELETE, or Requery() the
recordset if the cursor behavior is SQL_CB_CLOSE -- after the transaction
is done.
<P>
<P><h3>An Additional Consideration When using the Microsoft Access 2.0 ODBC Driver</h3>
 
<P>
When using the Microsoft Access version 2.0 or 3.0 ODBC driver, which uses
the Microsoft Access Jet database engine, you must also account for the Jet
database engine's requirement that you cannot begin a transaction on any
database that has an open cursor. In the MFC CRecordset class, an open
cursor means a pending result set.
<P>
Here are a couple of ways to handle this situation:

<UL><LI>Be sure that the recordset is closed when starting a transaction, open
   the recordset after calling the database's BeginTrans() member function,
   and close the recordset immediately after ending the transaction. If you
   are doing multiple transactions, the multiple opening and closing of the
   recordset can negatively affect the application's performance.
<P>
   -or-

<LI>Use the ODBC API function SQLFreeStmt() to explicitly close the cursor
   after ending a transaction and then call Requery() after starting the
   next transaction. When calling SQLFreeStmt(), specify the recordset's
   HSTMT as the first parameter and SQL_CLOSE as the second parameter.
   This second technique is faster than closing and opening the recordset
   at the start of every transaction. The following code fragment
   demonstrates this technique when doing two transactions:
<P>
<PRE>   CMyDatabase   db;
   db.Open("MY_DATASOURCE");
   CMyRecordset  rs(&amp;db);

   db.BeginTrans();                       // start transaction 1
   rs.Open();                             // open the recordset

   // manipulate data

   db.CommitTrans();                      // or Rollback()

   ::SQLFreeStmt(rs.m_hstmt,SQL_CLOSE);   // close the cursor
   db.BeginTrans();                       // start transaction 2
   rs.Requery();                          // now get the result set

   // manipulate data

   db.CommitTrans();                      // end transaction 2

   rs.Close();
   db.Close();

</PRE></UL><h2>REFERENCES</h2>
 
<P>
MFC Technote #47 - "Relaxing Database Transaction Requirements."
<P>
The following MFC Encyclopedia Articles:

<UL><LI>"Transaction"
<LI>"Transaction: Performing a Transaction in a Recordset"
<LI>"Transaction: How Transactions Affect Updates"
<P>
</UL>CDatabase and CRecordset sections of the MFC Class Library Reference.
<P>
ODBC 2.0 Programmer's Reference.
<P>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
Additional query words: 1.52a 2.50 2.5 2.51 2.52 2.52a 3.00 3.10 4.10<BR>
Keywords          : MfcDatabase kbcode kbprg<BR>
Technology        : kbMfc<BR>
Version           : 1.5 1.51 1.52 2.0 2.1 4.0 5.0<BR>
Platform          : NT WINDOWS<BR>
Issue type        : kbhowto<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  July 31, 1997</FONT>
	<BR>
	<A HREF="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
