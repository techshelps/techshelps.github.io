

<HTML>
<HEAD>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>How To Scroll a CFormView to See the Controls </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q155918">
<META NAME="KBModify" CONTENT="1997/07/31">
<META NAME="KBCreate" CONTENT="1996/09/11">
<META NAME="Keywords" CONTENT="MfcDocView kbcode kbhowto kbprg kbusage">
<META NAME="KBArea" CONTENT="Support; KB; visualc">
<META NAME="Description" CONTENT="  When a CFormView is resized to something smaller than the size of the dialog box template that it contains and users need to manipulate a control that is not in the visible view area, they must use the scroll bars to get the control into the visibl...">
<META NAME="Product" CONTENT="Visual C++">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QAB5,QA7O,QAOE,QAMN,QADK,QBXQ,QAHV,QBVV,QAH4,QARL,QABI,QBE7,QBE6,QAUD,QADO V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>How To Scroll a CFormView to See the Controls</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  July 31, 1997</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q155918</B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
4.00 4.10 4.20
WINDOWS NT
kbusage kbprg kbcode kbhowto
<P>
 
The information in this article applies to:

<UL><LI>The Microsoft Foundation Classes (MFC), included with:
   Microsoft Visual C++, 32-bit Edition, versions 4.0, 4.1, 4.2
</UL> 
<P>
<P><h2>SUMMARY</h2>
 
<P>
When a CFormView is resized to something smaller than the size of the
dialog box template that it contains and users need to manipulate a control
that is not in the visible view area, they must use the scroll bars to get
the control into the visible area. This sample code demonstrates how to
scroll the CFormView automatically if users tab to a control that is not in
view.
<P>
<P><h2>MORE INFORMATION</h2>
 
<P>
The code sample below works with a CFormView-derived class that contains a
dialog box template with more than one control in it (typically an edit
control). To see its effect, you must resize the view so that at least one
of the controls is not in the current visible client area, then press the
TAB key to change focus to that control.
<P>
This code works by handling WM_CTLCOLOR messages, checking to see if the
control being draw has focus, and scrolling the CFormView to make sure it
is visible. WM_CTLCOLOR messages are sent by most controls to their parent
before they redraw themselves. The WM_CTLCOLOR message is used instead of
the obvious choice, WM_SETFOCUS, because it is sent to the CFormView, not
to the actual control. Using WM_SETFOCUS requires subclassing each control.
<P>
<P><h3>Sample Code</h3>
 
<P>
<PRE>/* Compile options needed: none
   The class 'CScrollFormView' is derived from CFormView
*/

</PRE>HBRUSH CScrollFormView::OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor)
{
<PRE>   HBRUSH hbr = CFormView::OnCtlColor(pDC, pWnd, nCtlColor);

   if (GetFocus()-&gt;m_hWnd == pWnd-&gt;m_hWnd)
   {
      CRect rcChild, rcParent, rcTemp;

      pWnd-&gt;GetWindowRect(&amp;rcChild);
      GetWindowRect(&amp;rcParent);


     //Get document size. Assume mapping mode is MM_TEXT and ViewPort
     //and Window origins have not been set so we can also assume LP==DP.
      CSize size = GetTotalSize();

      // Determine if scroll bars are visible
      // and subtract their size from the view.
      if (size.cx &gt; rcParent.right - rcParent.left)
         rcParent.bottom -= GetSystemMetrics(SM_CYHSCROLL);
      if (size.cy &gt; rcParent.bottom - rcParent.top)
         rcParent.right -= GetSystemMetrics(SM_CXVSCROLL);

      // Succeed only if no part of the child appears in the parent.
      rcTemp.IntersectRect(rcChild, rcParent);

      if (rcTemp != rcChild)
      {
         POINT pt;

         pt.x = GetDeviceScrollPosition().x;
         pt.y = GetDeviceScrollPosition().y;

         if (rcChild.top &lt; rcParent.top)
         {
            TRACE("control is above the client area\n");
            pt.y -= rcParent.top - rcChild.top +
               GetSystemMetrics(SM_CXEDGE);
         }
         else if (rcChild.bottom &gt; rcParent.bottom)
         {
            TRACE("control is below the client area\n");
            // If the control is taller than the current view
            // scroll up, sacrificing the bottom of the control.
            pt.y += min(rcChild.top - rcParent.top,
               rcChild.bottom - rcParent.bottom +
               GetSystemMetrics(SM_CYHSCROLL) +
               GetSystemMetrics(SM_CXEDGE));
         }

         if (rcChild.left &lt; rcParent.left)
         {
            TRACE("control is left of the client area\n");
            pt.x -= rcParent.left - rcChild.left +
               GetSystemMetrics(SM_CYEDGE);
         }
         else if (rcChild.right &gt; rcParent.right)
         {
            TRACE("control is right of the client area\n");
            // If the control is wider than the current view
            // scroll right, sacrificing the right edge of the control.
            pt.x += min(rcChild.left - rcParent.left,
               rcChild.right - rcParent.right +
               GetSystemMetrics(SM_CXVSCROLL) +
               GetSystemMetrics(SM_CYEDGE));
         }

         ScrollToPosition(pt);  //Assume mapping mode is MM_TEXT.
      }
   }

   // TODO: Return a different brush if the default is not desired.
   return hbr;
</PRE>}
<P>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
KBCategory: kbusage kbprg kbcode kbhowto<BR>
KBSubcategory: MfcDocView<BR>
Additional reference words: 4.00 4.10 4.20 kbdsi<BR>
Keywords          : MfcDocView kbcode kbhowto kbprg kbusage<BR>
Technology        : kbMfc<BR>
Version           : 4.00 4.10 4.20<BR>
Platform          : NT WINDOWS<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  July 31, 1997</FONT>
	<BR>
	<A HREF="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
