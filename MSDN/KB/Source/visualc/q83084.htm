

<HTML>
<HEAD>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>BUG: sscanf() Fails If String Is Longer Than 32K </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q83084 ">
<META NAME="KBModify" CONTENT="1997/07/17">
<META NAME="KBCreate" CONTENT="1992/04/05">
<META NAME="Keywords" CONTENT="kb16bitonly">
<META NAME="KBArea" CONTENT="Support; KB; visualc">
<META NAME="Description" CONTENT="  Passing a string buffer longer than 32K+2 to sscanf() will cause sscanf() to return -1. It doesn't matter what is being read from the buffer.  CAUSE =====  The sscanf() function is implemented in such a way that its buffer has the same restrictions...">
<META NAME="Product" CONTENT="Visual C++">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QBFY,QACJ,QAL3,QAKP,QDKW,QAUD,QATX,QA4Q,QAY2,QAYY,QALZ,QAH4,QAJQ,QDL9,QBWQ V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>BUG: sscanf() Fails If String Is Longer Than 32K</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  July 17, 1997</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q83084 </B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
5.10 6.00 6.00a 6.00ax 7.00 | 5.10 6.00 6.00a | 1.00 1.50
<PRE>MS-DOS                      | OS/2            | WINDOWS
</PRE>kbprg kbbuglist
<P>
 
The information in this article applies to:

<UL><LI>The C Run-time (CRT), included with:
<P>
<P><PRE>    - Microsoft C for MS-DOS, versions 5.1, 6.0, 6.0a, and 6.0ax
    - Microsoft C for OS/2, versions 5.1, 6.0, and 6.0a
    - Microsoft C/C++ for MS-DOS, version 7.0
    - Microsoft Visual C++ for Windows, versions 1.0 and 1.5
</UL></PRE> 
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
Passing a string buffer longer than 32K+2 to sscanf() will cause
sscanf() to return -1. It doesn't matter what is being read from the
buffer.
<P>
<P><h2>CAUSE</h2>
 
<P>
The sscanf() function is implemented in such a way that its buffer has
the same restrictions as a file-stream buffer. Because file streams
cannot have a buffer larger than 32K, sscanf() cannot accept a buffer
larger than 32K.
<P>
<P><h2>RESOLUTION</h2>
 
<P>
You can work around this problem by placing a "\0" character in the
string buffer within the first 32K so that sscanf() sees a string
buffer shorter than 32K. If you are reading the data from a file, you
can work around this problem by using fscanf() and scanning the data
directly from the file you are reading from.
<P>
<P><h2>STATUS</h2>
 
<P>
Microsoft has confirmed this to be a problem in the products listed at
the beginning of this article. We are researching this problem and
will post new information here in the Microsoft Knowledge Base as it
becomes available.
<P>
This is not a problem in Visual C++ 32-bit Edition.
<P>
<P><h2>MORE INFORMATION</h2>
 
<P>
The following code sample reproduces the problem:
<P>
<P><h3>Sample Code</h3>
 
<P>
<PRE>/* Compile options needed: none
*/

#include &lt;stdio.h&gt;
#include &lt;memory.h&gt;

int func ( unsigned bufsize );

</PRE>static char buffer[33000];
FILE *fptr;
<P>
<PRE>void main ()
</PRE>{
<PRE>   int result;
   unsigned bufsize = 32768U;

   while (((result = func (bufsize) ) &gt;= 0) &amp;&amp; (bufsize &lt; 33000U))
      bufsize++;
</PRE>}
<P>
<PRE>int func ( unsigned bufsize )
</PRE>{
<PRE>   int result;
   char data;

   memset( buffer, 'A', bufsize );
   buffer[bufsize] = '\0';

   if (( result = sscanf( buffer, " %c", &amp;data )) != 1)
      printf( "\nSSCANF error\n" );

   printf( "bufsize is %u : sscanf returned %d\n", bufsize, result );
   return result;
</PRE>}
<P>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
Additional reference words: 1.00 1.50 5.10 6.00 6.00a 6.00ax 7.00<BR>
KBCategory: kbprg kbbuglist<BR>
KBSubcategory: CRTIss<BR>
Keywords            : kb16bitonly<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  July 17, 1997</FONT>
	<BR>
	<A HREF="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
