

<HTML>
<HEAD>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SAMPLE: Deriving an OLE Control from a Base Control </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q138411">
<META NAME="KBModify" CONTENT="1997/07/31">
<META NAME="KBCreate" CONTENT="1995/10/19">
<META NAME="Keywords" CONTENT="">
<META NAME="KBArea" CONTENT="Support; KB; visualc">
<META NAME="Description" CONTENT=" This is the Visual C++ 1.5x and 2.x version of this sample. There is an equivalent Visual C++ 4.x 32-bit sample available under the name SHAPES32.   The SHAPES sample illustrates how to derive an OLE control from a base control thus allowing the der...">
<META NAME="Product" CONTENT="Visual C++">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QAPN,QAB5,QA7O,QAMN,QA2O,QABA,QAOE,QAO4,QAVX,QAVW,QAUD,QABO,QAY2,QAHV,QAPF V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>SAMPLE: Deriving an OLE Control from a Base Control</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  July 31, 1997</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q138411</B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
 
The information in this article applies to:

<UL><LI>The Microsoft Foundation Classes (MFC) included with:
   - Microsoft OLE Control Developer's Kit (CDK), versions 1.0, 1.1, 1.2
</UL> 
<P>
This is the Visual C++ 1.5x and 2.x version of this sample. There is an
equivalent Visual C++ 4.x 32-bit sample available under the name SHAPES32.
<P>
<P><h2>SUMMARY</h2>
 
<P>
The SHAPES sample illustrates how to derive an OLE control from a base
control thus allowing the derived control to take advantage of the base
control's methods, properties, and events.
<P>
The following file is available for download from the Microsoft Software
Library:
<P>
<PRE> ~ <A HREF="http://support.microsoft.com/download/support/mslfiles/Shapes2.exe">Shapes2.exe</A> <I>(size: 62505 bytes)</I> 

</PRE>For more information about downloading files from the Microsoft Software
Library, please see the following article in the Microsoft Knowledge Base:
<P>
<PRE>   ARTICLE-ID: <B><A HREF="../zMiscellaneous/Q119591.htm">Q119591</A></B>
   TITLE     : How to Obtain Microsoft Support Files from Online Services

</PRE><h2>MORE INFORMATION</h2>
 
<P>
The Shapes2 sample implements a base control class called CBaseShapeCtrl
and two derived control classes called CCircleCtrl and CRectangleCtrl.
CCircleCtrl and CRectangleCtrl draw themselves using the properties
provided by the base CBaseShapeCtrl class. CCircleCtrl and CRectangleCtrl
also allow access to the methods and events implemented in the base
CBaseShapeCtrl class.
<P>
<P><h3>Properties, Methods, and Events</h3>
 
<P>
The CBaseShapeCtrl class provides the base functionality of a simple shape
control. It implements the following properties, events, and methods:
<P>
<PRE>Name          Type       Use
</PRE> 
<PRE>FillColor     Property   An OLE_COLOR value that represents the color
                         used to fill the shape.
LineColor     Property   An OLE_COLOR value that represents the color
                         used for the shape's outline.
LineWidth     Property   A short value that represents the line width
                         in pixels of the shape's outline.
BaseMethod1   Method     A test method that, when invoked, fires the
                         BaseEvent1 event. Takes a single parameter of
                         type long.
BaseMethod2   Method     A test method that, when invoked, fires the
                         BaseEvent2 event. Takes a single parameter of
                         type BSTR.
BaseEvent1    Event      A test event. Returns a long.
BaseEvent2    Event      A test event. Returns a BSTR.

</PRE>The CCircleCtrl class provides the functionality of a simple circle
control. It implements the following properties, events, and methods:
<P>
<PRE>Name           Type       Use
</PRE> 
<PRE>CircleShape    Property   A boolean value. If TRUE, the control draws
                          itself as a circle. If FALSE, it draws itself
                          as an ellipse.
CircleOffset   Property   A short value that represents the number of
                          pixels offset from the center of the bounding
                          rectangle where the control will draw itself.
CircleMethod1  Method     A test method that, when invoked, fires the
                          CircleEvent1 event. Takes a single parameter
                          of type long.
CircleMethod2  Method     A test method that, when invoked, fires the
                          CircleEvent2 event. Takes a single parameter
                          of type long.
CircleEvent1   Event      A test event. Returns a long.
CircleEvent2   Event      A test event. Returns a long.

</PRE>The CRectangleCtrl class provides the functionality of a simple rectangle
control. It implements the following properties, events, and methods:
<P>
<PRE>Name            Type       Use
</PRE> 
<PRE>RoundedCorners  Property   A boolean value. If TRUE, the control draws
                           itself with rounded corners. If FALSE, it
                           draws itself with square corners.
RectangleInset  Property   A short value that represents the number of
                           pixels inside the control's bounding
                           rectangle where the control will inset itself.
RectMethod1     Method     A test method that, when invoked, fires the
                           RectEvent1 event. Takes no parameters.
RectMethod2     Method     A test method that, when invoked, fires the
                           RectEvent2 event. Takes no parameters.
RectEvent1      Event      A test event. Returns void.
RectEvent2      Event      A test event. Returns void.

</PRE><h3>Modifying the Base Control Class</h3>
 
<P>
Several changes need be made to the code generated by ControlWizard to
allow a derived control to cleanly inherit the functionality provided by a
base control. The following changes were made to the files generated by
ClassWizard:

<OL><P><LI>The ON_OLEVERB entry for AFX_IDS_VERB_PROPERTIES in the CBaseShapeCtrl
   message map was removed:
<P>
   BEGIN_MESSAGE_MAP(CBaseShapeCtrl, COleControl)
<P><PRE>     //{{AFX_MSG_MAP(CBaseShapeCtrl)
     //}}AFX_MSG_MAP
     //ON_OLEVERB(AFX_IDS_VERB_PROPERTIES, OnProperties)
</PRE>   END_MESSAGE_MAP()
<P>
   If this isn't done, control containers will list the Properties verb
   twice when the the user clicks Control Object on the Edit menu.

<P><LI>The CBaseShapeCtrl::CBaseShapeCtrlFactory::UpdateRegistry function was
   changed to simply return TRUE:
<P>
   BOOL CBaseShapeCtrl::CBaseShapeCtrlFactory::UpdateRegistry(
<P><PRE>       BOOL bRegister)
</PRE>   {
<P><PRE>     return TRUE;
</PRE>   }
<P>
   If this isn't done, the base control is registered and containers will
   list it along with the derived controls when the user attempts to
   insert a new control.

<P><LI>The CBaseShapePropPage::CBaseShapePropPageFactory::UpdateRegistry
   function was changed to simply return TRUE:
<P>
   BOOL CBaseShapePropPage::CBaseShapePropPageFactory::UpdateRegistry(
<P><PRE>     BOOL bRegister)
</PRE>   {
<P><PRE>     return TRUE;
</PRE>   }
<P>
   If this isn't done, the base class control's Property page is
   registered, so it will appear in the registry.

<P><LI>The call to InitializeIIDs in the base control class constructor was
   removed:
<P>
   CBaseShapeCtrl::CBaseShapeCtrl()
   {
<P><PRE>     //InitializeIIDs(&amp;IID_DBaseShape, &amp;IID_DBaseShapeEvents);
</PRE><P>
<P><PRE>     // TODO: Initialize your control's instance data here.
</PRE>   }
<P>
   If this isn't done, there will be a memory leak upon termination
   when the cached type information for the base class is not freed.

<P><LI>The code in the base control's section of the project's .odl file was
   changed to comments (commented out). If this isn't done, some
   containers (for example, Visual Basic version 4.0) won't load the
   control.

<P><LI>The CBaseShapeCtrl::DoPropExchange method was modified to not call the
   COleControl::ExchangeVersion function:
<P>
<PRE>   void CBaseShapeCtrl::DoPropExchange(CPropExchange* pPX)
   {
     // ExchangeVersion(pPX, MAKELONG(_wVerMinor, _wVerMajor));
     COleControl::DoPropExchange(pPX);

     ...
   }

   If this isn't done, saving the state of the derived OLE control will
   generate an assertion on line 1169 of the Propset.cpp file. The
   assertion is generated because the _Version property has already been
   serialized by a call to the ExchangeVersion method in the DoPropExchange
   method of the derived control.

</PRE><P><LI>The DoPropExchange method of the derived OLE controls was changed to
   make a call to CBaseShapeCtrl::DoPropExchange instead of
   COleControl::DoPropExchange:
<P>
<PRE>   void CCircleCtrl::DoPropExchange(CPropExchange* pPX)
   {
     ExchangeVersion(pPX, MAKELONG(_wVerMinor, _wVerMajor));
     CBaseShapeCtrl::DoPropExchange(pPX);

     ...
   }

</PRE></OL><h3>Manually Updating the Project's .Odl File</h3>
 
<P>
ClassWizard does not provide any support for developing OLE controls that
are derived from another control. As a result, the property, method, and
event dispatch ID's used by a derived control class need to be manually
updated. MFC Technical Note #39 discusses the dispatch ID numbering scheme
used by MFC. Basically, MFC divides a 32-bit dispatch ID (DISPID) into two
parts. The LOWORD of the DISPID contains the distance from the top of the
dispatch map (1 relative). The HIWORD contains the distance of the dispatch
map from the most derived class (0 relative).
<P>
The CCircleCtrl and CRectangleControl classes use this technique with their
DISPIDs. For example, the CCircleCtrl derived control inherits the
FillColor, LineColor, and LineWidth properties from CBaseShapeCtrl. The
DISPIDs for these properties need to be manually added to the CCircleCtrl
properties section of the project's .odl file and the HIWORD of the DISPIDs
needs to be adjusted:
<P>
<PRE>//  Primary dispatch interface for CCircleCtrl
</PRE>[ uuid(A7EC6760-BFED-11CE-8250-524153480001),
<PRE>  helpstring("Dispatch interface for sample Circle Control"), hidden ]
</PRE>dispinterface _DCircle
{
<PRE>  properties:
    // NOTE - ClassWizard will maintain property information here.
    //    Use extreme caution when editing this section.
    //{{AFX_ODL_PROP(CCircleCtrl)
    [id(0x10001)] OLE_COLOR FillColor;
    [id(0x10002)] OLE_COLOR LineColor;
    [id(0x10003)] short LineWidth;
    [id(1)] boolean CircleShape;
    [id(2)] short CircleOffset;
    //}}AFX_ODL_PROP
    ...

</PRE>The FillColor, LineColor, and LineWidth properties implemented in the base
class have DISPIDs of 1, 2, and 3 respectively. Once the HIWORD portion of
these DISPIDs has been adjusted, they become 0x10001 (65537), 0x10002
(65538), and 0x10003 (65539).
<P>
The DISPIDs for events are handled differently from those for properties
and methods. Event DISPIDs do not have their HIWORD portion adjusted.
Instead, they are sequential. For example, CCircleCtrl inherits the
BaseEvent1 and BaseEvent2 events from the base control. The DISPIDs for the
base events need to be manually added to the CCircleCtrl events section of
the project's .odl file. Also, the DISPIDs assigned by ClassWizard for the
events provided by CCircleCtrl (CircleEvent1 and CircleEvent2) need to have
their DISPIDs manually updated:
<P>
[ uuid(A7EC6761-BFED-11CE-8250-524153480001),
<PRE>  helpstring("Event interface for sample Circle Control") ]
</PRE>dispinterface _DCircleEvents
{
<PRE>  properties:
    //  Event interface has no properties

  methods:
    // NOTE - ClassWizard will maintain event information here.
    //    Use extreme caution when editing this section.
    //{{AFX_ODL_EVENT(CCircleCtrl)
    [id(1)] void BaseEvent1(long lParam);
    [id(2)] void BaseEvent2(BSTR pszString);
    [id(3)] void CircleEvent1(long lParam);
    [id(4)] void CircleEvent2(long lParam);
    //}}AFX_ODL_EVENT
</PRE>};
<P>
Manually updating the DISPIDs can be problematic because ClassWizard may
get confused when it sees the entries for the events in the base class.
As a result, more than one event may be assigned the same DISPID. After
adding new events to a derived class, inspect the project's .odl file,
and fix any conflicts.
<P>
ClassWizard also maintains DISPID values for properties, methods, and
events, in an enum member of the COleControl derived class. Again, because
ClassWizard does not support deriving an OLE control from another control,
it may generate conflicting values for the different DISPIDs. If this
happens, manually edit the values so that they are correct, and match the
values as specified in the .odl file. Following is the portion of the
CCircleCtrl class that shows the DISPIDs used for both the base class and
derived class properties, events, and methods:
<P>
class CCircleCtrl : public CBaseShapeCtrl
{
...
<P>
<PRE>// Dispatch and event IDs
</PRE>public:
<PRE>  enum {
  //{{AFX_DISP_ID(CCircleCtrl)
  //dispidFillColor   = 65537L,
  //dispidLineColor   = 65538L,
  //dispidLineWidth   = 65539L,
  //dispidBaseMethod1 = 65540L,
  //dispidBaseMethod2 = 65541L,

  dispidCircleShape   = 1L,
  dispidCircleOffset  = 2L,
  dispidCircleMethod1 = 3L,
  dispidCircleMethod2 = 4L,

  //eventidBaseEvent1 = 1L,
  //eventidBaseEvent2 = 2L,
  eventidCircleEvent1 = 3L,
  eventidCircleEvent2 = 4L,
  //}}AFX_DISP_ID
</PRE>};
<P>
the Shapes2 sample is based on a ControlWizard-generated OLE control. Files
included with the sample that are directly related to deriving an OLE
control from a base control are:
<P>
<PRE>   Shapes.odl -
   Shows the modified DISPIDs used by the derived control classes.

   Basectl.cpp -
   Provides the implementation of the base CBaseShapeCtrl class.

   Circctl.cpp -
   Provides the implementation of the derived CCircleCtrl class.

   Rectctl.cpp -
   Provides the implementation of the derived CRectangleCtrl class.

</PRE><h2>REFERENCES</h2>
 
<P>
MFC Technical Note #39.
<P>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
Additional query words: 2.00 2.10 2.20 2.50 2.51 2.52 3.00 3.10 3.20<BR>
shapes32<BR>
Technology        : kbMfc kbole<BR>
Version           : 1.0 1.1 1.2<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  July 31, 1997</FONT>
	<BR>
	<A HREF="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
