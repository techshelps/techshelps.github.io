

<HTML>
<HEAD>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>HOWTO: Use Bookmarks with the MFC ODBC Database Classes </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q132398">
<META NAME="KBModify" CONTENT="1997/06/26">
<META NAME="KBCreate" CONTENT="1995/07/09">
<META NAME="Keywords" CONTENT="kbcode kbprg MfcDatabase">
<META NAME="KBArea" CONTENT="Support; KB; visualc">
<META NAME="Description" CONTENT="  This article shows by example how to use bookmarks (32-bit values that uniquely identify a record in a recordset) with the MFC ODBC database classes.  Beginning with version 4.2 of Microsoft Visual C++ the MFC Database classes have been updated wit...">
<META NAME="Product" CONTENT="Visual C++">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QA5V,QAPP,QAH4,QBWR,QA9E,QAKD,QA1S,QAZV,QAU9,QAB4,QAEF,QDMH,QAUR,QAM9,QALX V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>HOWTO: Use Bookmarks with the MFC ODBC Database Classes</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  June 26, 1997</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q132398</B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
 
The information in this article applies to:

<UL><LI>The Microsoft Foundation Classes (MFC) included with:
   - Microsoft Visual C++ for Windows, version 1.52
   - Microsoft Visual C++, 32-bit Edition, versions 2.1, 2.2, 4.0, 5.0
</UL> 
<P>
<P><h2>SUMMARY</h2>
 
<P>
This article shows by example how to use bookmarks (32-bit values that
uniquely identify a record in a recordset) with the MFC ODBC database
classes.
<P>
Beginning with version 4.2 of Microsoft Visual C++ the MFC Database classes
have been updated with a new set of bookmark API's. Please refer to the
Visual C++ online documentation for the CRecordset::SetBookmark and
CRecordset::GetBookmark functions for more information.
<P>
<P><h2>MORE INFORMATION</h2>
 
<P>
Some ODBC drivers provide the ability to use bookmarks. ODBC defines a
bookmark as a 32-bit value that uniquely identifies a record in a
recordset. Once this bookmark is retrieved for a record, the ODBC cursor
can be repositioned to that record at some later time by passing the
bookmark value to SQLExtendedFetch(), an ODBC API.The Microsoft Access
version 2.0 ODBC driver is one driver that supports bookmarks. For more
information about ODBC bookmarks, please see the ODBC 2.x Programmer's
Reference.
<P>
The MFC ODBC database classes do not provide direct support for using
bookmarks. However, the code listed in this article demonstrates how you
can write functions for your CRecordset-derived class that do allow you to
use bookmarks.
<P>
The code was written and tested for the 32-bit MFC ODBC database classes.
If you are using the 16-bit database classes, the code will be very similar
but the variables such as m_wRowStatus, m_bUseUpdateSQL, and
m_bLongBinaryColumns aren't available in 16-bit database classes. Therefore
for 16-bit database classes, you should remove the code in the
MoveToBookmark() fuction that masks out the data truncation warnings when
fetching data for a record. You should also define m_wRowStatus as a data
member of your CRecordset. This variable is already defined for CRecordset
in the 32-bit classes.
<P>
Please keep in mind that when you use the code to move to bookmarks, your
CRecordset's m_lCurrentRecord data member or GetRecordCount() function may
return incorrect results. You could add code to save the m_lCurrentRecord
along with the bookmark value, and then restore that value when you move to
a bookmark, but this may not be enough. For example, moving to the end of
the recordset using the MoveLast() function immediately after the recordset
is open causes the m_lCurrentRecord count to be a negative number, which
means that the current record number cannot be determined. If you then save
this value along with the bookmark value, the m_lCurrentRecord value will
be reset to the undetermined state simply from using the bookmark and
restoring the m_lCurrentRecord value.
<P>
Here is an example of how to use the bookmark code to allow you to
retrieve the value of a counter (autoincrement) field in Microsoft Access
version 2.0, so you can save the value for later use within your
application. Remember that the value for an autoincrement field is created
by the ODBC driver when you add a record.
<P>
The example code moves to a record, gets the bookmark for the record, adds
a record, calls the MoveLast() funtion to get to the newly added record to
retrieve the counter field value, and then moves back to the record it came
from.
<P>
NOTE: The code takes advantage of the fact that the Microsoft Access
version 2.0 driver appends new records to the end of a recordset when using
a dynaset. Other ODBC drivers may not do this.
<P>
<P><h3>Code Sample</h3>
 
<PRE>   .
   .
   .

   CDatabase db;
   db.Open("MYDataSourceName",NULL,NULL,"ODBC;",FALSE);
   CCounterSet rs(&amp;db);

   // Open up dynaset because any records added by a CRecordset using
   // dynasets are appended to the end of the recordset using
   // the Microsoft Access 2.0 driver
   rs.Open(CRecordset::dynaset);

   // move to some record
   rs.MoveNext();

   BOOKMARK bookmark;
   rs.GetBookmark(&amp;bookmark);

   // Add record. Counter field of record is given a value by
   // the ODBC driver
   rs.AddNew();
   rs.m_textfield="SomeText";
   rs.Update();

   // MoveLast to get on record just added
   rs.MoveLast();

   // retrieve the value of the counter field for the
   // newly added record here

   // return to the record you were on
   rs.MoveToBookmark(bookmark);
   .
   .
   .

</PRE><h3>Bookmark Code</h3>
 
<P>
<PRE>// This code was tested with the MFC ODBC database classes
// included with Visual C++ versions 2.1, 2.2 and 4.0, and the Microsoft
// Access version 2.0 ODBC driver, which supports bookmarks.

</PRE>static const char szRowFetch[] = "State:01S01";
static const char szDataTruncated[] = "State:01004";
<P>
<PRE>void CMyRecordset::OnSetOptions(HSTMT hstmt)
</PRE>{
<PRE>   RETCODE nRetCode;

   AFX_SQL_SYNC(::SQLSetStmtOption(hstmt, SQL_USE_BOOKMARKS, SQL_UB_ON));

      if (!Check(nRetCode))
      {
         TRACE("Error setting bookmark use\n");
         ThrowDBException(nRetCode);
      }

      CRecordset::OnSetOptions(hstmt);
   }


   void CMyRecordset::GetBookmark(BOOKMARK * lpBookmark)
   {
      ASSERT(IsOpen());

      // Can't save bookmark if not on valid record
      ASSERT(!IsBOF() &amp;&amp; !IsEOF() &amp;&amp; !IsDeleted());

      RETCODE nRetCode;
      AFX_SQL_SYNC(::SQLGetStmtOption(m_hstmt, SQL_GET_BOOKMARK,
                                      (PTR)lpBookmark));
      if (!Check(nRetCode))
      {
         TRACE("GetBookmark error: A forward-only cursor may be"
               "causing the error\n");
         ThrowDBException(nRetCode);
      }
   }

   void CMyRecordset::MoveToBookmark(BOOKMARK lBookmark)
   {
      ASSERT(IsOpen());

      if (m_nFieldsBound &gt; 0)
      {
         // Reset field flags - mark all clean, all non-null
         memset(m_pbFieldFlags, 0, m_nFields);
      }

      // Clear any edit mode that was set
      ReleaseCopyBuffer();

      RETCODE nRetCode;
      DWORD dwRowsMoved;

      AFX_SQL_ASYNC(this, ::SQLExtendedFetch(m_hstmt,
                           SQL_FETCH_BOOKMARK, (SDWORD)lBookmark,
                           &amp;dwRowsMoved, &amp;m_wRowStatus));

      if (nRetCode == SQL_SUCCESS_WITH_INFO)
      {
         CDBException e(nRetCode);
         // Build the error string but don't send nuisance output to
         // TRACE window
         e.BuildErrorString(m_pDatabase, m_hstmt, FALSE);

         if (e.m_strStateNativeOrigin.Find(szDataTruncated) &gt;= 0)
         {
            // Ignore data truncated warning if binding long binary
            // columns (may mask non-long binary truncation warnings
            // or other warnings)
            if (m_bUseUpdateSQL || !m_bLongBinaryColumns ||
                !m_bUpdatable)
            {
               e.Empty();
               TRACE0("Error: field data truncated during Open or"
                 " Requery.\n");
               ThrowDBException(AFX_SQL_ERROR_DATA_TRUNCATED);
            }
         }
         else if (e.m_strStateNativeOrigin.Find(szRowFetch) &gt;= 0)
         {
            e.Empty();
            TRACE0("Error: fetching row from server during Open or"
                   " Requery.\n");
            ThrowDBException(AFX_SQL_ERROR_ROW_FETCH);
         }
      }
      else
      {
         if (!Check(nRetCode))
         {
            TRACE0("Error: Move operation failed.\n");
            ThrowDBException(nRetCode);
         }
      }

      Fixups();
      m_bBOF = FALSE;
      m_bEOF = FALSE;
   }

</PRE><h2>REFERENCES</h2>
 
<P>
For more information, please see the ODBC 2.0 Programmer's Reference in the
Visual C++ version 2.x Books Online, or the ODBC 2.1 Programmer's Reference
in the Visual C++ version 4.0 Books Online.
<P>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
Additional query words: 2.00 1.50 1.51<BR>
Keywords            : kbcode kbprg MfcDatabase<BR>
Technology          : kbMfc<BR>
Version             : 1.52 2.1 2.2 4.0 5.0<BR>
Platform            : NT WINDOWS<BR>
Issue type          : kbhowto<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  June 26, 1997</FONT>
	<BR>
	<A HREF="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
