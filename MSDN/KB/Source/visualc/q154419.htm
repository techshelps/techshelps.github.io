

<HTML>
<HEAD>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>FAQ: Standard C++ Library Frequently Asked Questions </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q154419">
<META NAME="KBModify" CONTENT="1997/10/07">
<META NAME="KBCreate" CONTENT="1996/08/05">
<META NAME="Keywords" CONTENT="STLIss kbfaq">
<META NAME="KBArea" CONTENT="Support; KB; visualc">
<META NAME="Description" CONTENT="  This article presents a list of Frequently Asked Questions (FAQs) regarding the Standard C++ Libraries, and the answers to those questions. For additional information regarding the Standard C++ Libraries, please refer to the draft ANSII Standard Sp...">
<META NAME="Product" CONTENT="Visual C++">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QABB,QBHQ,QBFY,QABA,QA36,QAVX,QABO,QA56,QA55,QA9O,QDOP,QAB4,QA4Q,QAH4,QAVW V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>FAQ: Standard C++ Library Frequently Asked Questions</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  October 7, 1997</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q154419</B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
 
The information in this article applies to:

<UL><LI>The Standard C++ Library, included with:
   - Microsoft Visual C++, 32-bit Edition, versions 4.2, 5.0
</UL> 
<P>
<P><h2>SUMMARY</h2>
 
<P>
This article presents a list of Frequently Asked Questions (FAQs) regarding
the Standard C++ Libraries, and the answers to those questions. For
additional information regarding the Standard C++ Libraries, please refer
to the draft ANSII Standard Specification and the Visual C++ Books Online.
<P>
<P><h2>MORE INFORMATION</h2>
 
<P>
Standard C++ Libraries Frequently Asked Questions
 
<P>
<P><h3>Question 1</h3>
 
<P>
What does the Standard C++ Library contain?
<P>
A. The Standard C++ Library provides an extensible framework and
<PRE>   contains components for language support, diagnostics, general
   utilities, strings, locales, standard template library (containers,
   iterators, algorithms, numerics,) and input/output.

   The Standard C++ Library can be divided into the following categories:

   1. Standard Template Library (STL) components provide a C++ program
      with access to a subset of the most widely-used algorithms and
      data structures. STL headers can be grouped into three major
      organizing concepts: containers, algorithms, and iterators:

       - Containers are template classes that support common ways to
         organize data, such as &lt;vector&gt;, &lt;list&gt;, &lt;deque&gt;, &lt;stack&gt;,
         &lt;queue&gt;, &lt;set&gt;, and &lt;map&gt;.

       - Algorithms are template functions for performing common operations
         on sequences of objects, such as &lt;functional&gt;, &lt;algorithm&gt;, and
         &lt;numeric&gt;.

       - Iterators are the glue that pastes algorithms and containers
         together, such as &lt;utility&gt;, &lt;iterator&gt;, and &lt;memory&gt;.

   2. Input Output includes components for forward declarations of
      iostreams (&lt;iosfwd&gt;), predefined iostreams objects (&lt;iostream&gt;),
      base iostreams classes (&lt;ios&gt;), stream buffering (&lt;streambuf&gt;),
      stream formatting and manipulators (&lt;iosmanip&gt;, &lt;istream&gt;,
      &lt;ostream&gt;), string streams (&lt;sstream&gt;), and file streams (&lt;fstream&gt;).

   3. Other Standard C++ Headers include:

       - Language Support: components for common type definitions
         used throughout the library (&lt;cstddef&gt;), characteristics of the
         predefined types (&lt;limits&gt;, &lt;cfloat&gt;, &lt;climits&gt;), functions
         supporting start and termination of a C++ program (&lt;cstdlib&gt;),
         support for dynamic memory management (&lt;new&gt;), support for dynamic
         type identification (&lt;typeinfo&gt;), support for exception processing
         (&lt;exception&gt;), and other runtime support (&lt;cstdarg&gt;, &lt;ctime&gt;,
         &lt;csetlmp&gt;, &lt;csignal&gt;).

       - Diagnostics: components for reporting several kinds of
         exceptional conditions (&lt;stdexcept&gt;),documenting program
         assertions (&lt;cassert&gt;), and a global variable for error number
         codes (&lt;cerrno&gt;).

       - Strings: components for string classes (&lt;string&gt;), and
         null-terminated sequence utilities (&lt;cctype&gt;, &lt;cwctype&gt;,
         &lt;cwchar&gt;).

       - Localization: components that C++ programs may use to
         encapsulate cultural differences. The locale facility includes
         internationalization support for character classification and
         string collation, numeric, monetary, and date/time formatting
         and parsing, and message retrieval (&lt;locale&gt;, &lt;clocale&gt;).

</PRE><h3>Question 2</h3>
 
<P>
What is the difference between C-Runtime Library and Standard C++ Library?
What libraries will the Runtime Library compiler options such as /ML, /MT,
/MD, /MLd, /MTd, and /MDd include?
<P>
A. Prior to Visual C++ 4.2 and 5.0, the C-Runtime Library included:
<P>
<PRE>      |------------------------------------------------------------|
      | C-Runtime Library Types and    |    Standard C++           |
      | Related Compiler Switches      |       Library             |
      | -----------------------------------------------------------|
      | Single Threaded (ML)           |    LIBC.LIB               |
      | Multithreaded (MT)             |    LIBCMT.LIB             |
      | Multithreaded DLL version (MD) |    MSVCRT.LIB (Import     |
      |                                |    Library for            |
      |                                |    MSVCRT40.DLL)          |
      | Debug Single Threaded (MLd)    |    LIBCD.LIB              |
      | Debug Multithreaded (MTd)      |    LIBCMTD.LIB            |
      | Debug Multithreaded DLL (MDd)  |    MSVCRTD.LIB (Import    |
      |                                |    Library for            |
      |                                |    MSVCRT40D.DLL)         |
      |------------------------------------------------------------|

   Visual C++ 4.2 and 5.0 include the following Libraries in addition to
   the MFC libraries:

      1. Basic C-Runtime Library.

      2. Standard C++ Library.

      3. Old iostream Library.

   With Visual C++ 4.2 and 5.0, the iostream support has been pulled out of
   the C-Runtime Library and exists as an independent entity. The following
   libraries are current:

      |--------------------------------|---------------------------|
      | Library Types and              |    Basic C Runtime        |
      | Related Compiler Switches      |        Library            |
      |--------------------------------|---------------------------|
      | Single-Threaded (ML)           |    LIBC.LIB               |
      | Multithreaded (MT)             |    LIBCMT.LIB             |
      | Multithreaded DLL version (MD) |    MSVCRT.LIB (Import     |
      |                                |    Library for            |
      |                                |    MSVCRT.DLL)            |
      | Debug Single-Threaded (MLd)    |    LIBCD.LIB              |
      | Debug Multithreaded (MTd)      |    LIBCMTD.LIB            |
      | Debug Multithreaded DLL (MDd)  |    MSVCRTD.LIB (Import    |
      |                                |    Library for            |
      |                                |    MSVCRTD.DLL)           |
      |------------------------------------------------------------|

      |--------------------------------|---------------------------|
      | Library Types and              |      Standard C++         |
      | Related Compiler Switches      |        Library            |
      |--------------------------------|---------------------------|
      | Single-Threaded (ML)           |    LIBCP.LIB              |
      | Multithreaded (MT)             |    LIBCPMT.LIB            |
      | Multithreaded DLL version (MD) |    MSVCPRT.LIB*(Also uses |
      |                                |             MSVCRT.DLL)   |
      | Debug Single-Threaded (MLd)    |    LIBCPD.LIB             |
      | Debug Multithreaded (MTd)      |    LIBCPMTD.LIB           |
      | Debug Multithreaded DLL (MDd)  |    MSVCPRTD.LIB* (Also    |
      |                                |        uses MSVCRTD.DLL)  |
      |------------------------------------------------------------|

   (* NOTE: MSVCPRT.LIB and MSVCPRTD.LIB are static libraries and do not
   have any DLLs directly related to them. These libraries are also
   dependent on MSVCRT.DLL and MSVCRTD.DLL, respectively. If you have any
   applications that use MSVCPRT.LIB or MSVCPRTD.LIB and you use the
   "Ignore Default Library" (/NOD or NODEFAULTLIB) option, be sure to link
   MSVCPRT.LIB (or MSVCPRTD.LIB) and MSVCRT.LIB (or MSVCRTD.LIB) with your
   application. Otherwise, you will get linker errors (LNK2001: unresolved
   externals in MSVCPRT.LIB or MSVCPRTD.LIB) when linking your
   application.)

      |--------------------------------|---------------------------|
      | Library Types and              |      Old iostream         |
      | Related Compiler Switches      |        Library            |
      |--------------------------------|---------------------------|
      | Single-Threaded (ML)           |    LIBCI.LIB              |
      | Multithreaded (MT)             |    LIBCIMT.LIB            |
      | Multithreaded DLL version (MD) |    MSVCIRT.LIB (Import    |
      |                                |    Library for            |
      |                                |    MSVCIRT.DLL)           |
      | Debug Single-Threaded (MLd)    |    LIBCID.LIB             |
      | Debug Multithreaded (MTd)      |    LIBCIMTD.LIB           |
      | Debug Multithreaded DLL (MDd)  |    MSVCIRTD.LIB (Import   |
      |                                |    Library for            |
      |                                |    MSVCIRTD.DLL)          |
      |------------------------------------------------------------|

   In Visual C++ 4.2 and 5.0, there are certain default libraries that your
   program will link with. When you build a release version of your project
   in Visual C++ 4.2 and 5.0, one of the basic C-Runtime Libraries
   (LIBC.LIB, LIBCMT.LIB, and MSVCRT.LIB) is linked by default, depending
   on the compiler option you choose (single-threaded &lt;ML[d]&gt;,
   multithreaded &lt;MT[d]&gt;, or DLL&lt;ML[d]&gt;). Depending on the headers you use
   in your code, a library from the Standard C++ Library or one from the
   Old iostream Library may also be linked.

   For example, if you specify the /ML (single-thread version) compiler
   option, and include &lt;iostream&gt;, a Standard C++ Library Header, the
   libraries LIBC.LIB and LIBCP.LIB are linked with your application by
   default. If you specify the /ML (single-thread version) compiler option,
   and include &lt;iostream.h&gt;, an Old iostream Header, the libraries LIBC.LIB
   and LIBCI.LIB are linked with your application by default.

   Headers determine whether the Standard C++ Libraries and old iostream
   Libraries will be linked. Compiler options (/ML[d], /MT[d], /MD[d])
   determine which version of the libraries (single-threaded,
   multithreaded, or DLL) is to be linked by default.

   NOTE: It may seem that headers without the ".h" extension are Standard
   C++ Headers and ones with the ".h" extension are C-Runtime Headers or
   Old iostream Headers. This is not true. As explained below, the files
   &lt;useoldio.h&gt; and &lt;use_ansi.h&gt; determine the libraries with which your
   application will link.

   Actually, there are two header files, &lt;useoldio.h&gt; and &lt;use_ansi.h&gt;,
   that contain #pragmas. The #pragmas force either the Old iostream
   Library or the Standard C++ Library to be linked in by default.

   The header file &lt;useoldio.h&gt; contains #pragma statements that force the
   Old iostream Library to be linked in. All Old iostream Headers include
   &lt;useoldio.h&gt;: If you include any Old iostream header in your
   application, the Old iostream Library will be linked by default.

      |-------------------------|
      |  Old iostream Headers   |
      |-------------------------|
      |                         |
      | FSTREAM.H  | IOMANIP.H  |
      | IOS.H      | IOSTREAM.H |
      | ISTREAM.H  | OSTREAM.H  |
      | STDIOSTR.H | STREAMB.H  |
      | STRSTREA.H |            |
      |-------------------------|

   The header file &lt;use_ansi.h&gt; contains #pragma statements that force the
   Standard C++ Library to be linked in. All Standard C++ headers include
   &lt;use_ansi.h&gt;: if you include any Standard C++ Header in your
   application, the Standard C++ Library will be linked by default.

      |----------------------------------------------------|
      |              Standard C++ Headers                  |
      |----------------------------------------------------|
      | ALGORITHM  |  BITSET  |   COMPLEX  |  DEQUE        |
      | FSTREAM    |FUNCTIONAL|   IOMANIP  |  IOS          |
      | IOSFWD     | IOSTREAM |   ISTREAM  |  ITERATOR     |
      | LIMITS     | LIST     |   LOCALE   |  MAP          |
      | MEMORY     | NUMERIC  |   OSTREAM  |  QUEUE        |
      | SET        | SSTREAM  |   STACK    |  STDEXCEPT    |
      | STREAMBUF  | STRING   |   STRSTREAM|  TYPEINFO     |
      | UTILITY    | VALARRAY |   VECTOR   |  XIOSBASE     |
      | XLOCALE    | XLOCINFO |   XLOCMON  |  XLOCNUM      |
      | XLOCTIME   | XMEMORY  |   XSTRING  |  XTREE        |
      | XUTILITY   | YMATH.H  |            |               |
      |----------------------------------------------------|

   You cannot mix calls to the Old iostream Library and the new Standard
   C++ Library.

   For more information on related issues, please see Issues Surrounding
   iostream and the Standard C++ Library in Visual C++ Books Online. Also
   see Compiler Error C2371.

</PRE><h3>Question 3</h3>
 
<P>
Can I use existing static or dynamic link libraries, built with Visual C++
4.0 or Visual C++ 4.1, with applications being developed using Visual C++
4.2 and 5.0?
<P>
A. If your application is not going to use the Standard C++ Library, you
<PRE>   can use the existing libraries in your application as they exist.

   If your application is going to use the Standard C++ Library, you need
   to consider the following issues:

    - You will have to re-build your libraries using the Standard C++
      Library.

    - If your library is iostream intensive, you will need to re-write some
      parts of your code before you can re-build the library using the
      Standard C++ Library.

   For more information on this question, see Differences Between Old and
   New iostream Implementations in Visual C++ Books Online, Issues
   Surrounding iostream and Standard C++ Library in Visual C++ Books
   Online, Differences between C-Runtime Library and Standard C++ Library,
   and The Ignore Default Libraries option.

</PRE><h3>Question 4</h3>
 
<P>
I ported my application from Visual C++ 4.1 to Visual C++ 4.2 or 5.0. I do
not want to use the Standard C++ Libraries. How do I retain the Old
iostream functionality?
<P>
A. If you want to retain the Old iostream Library, include one or more of
<PRE>   the Old iostream Header files in your code. Do not use the new Standard
   C++ Headers. You cannot mix calls to the Old iostream Library and the
   new Standard C++ Library.

   For more information, see Issues Surrounding iostream and the Standard
   C++ Library in Visual C++ Books Online, or Differences between C-Runtime
   Library and Standard C++ Library?

</PRE><h3>Question 5</h3>
 
<P>
How do I make the Standard C++ Libraries the default libraries for my
application?
<P>
A. If you want to make the Standard C++ Libraries the default, include one
<PRE>   or more of the new Standard C++ headers. Remember, you cannot mix calls
   to the Old iostream and the new Standard C++ Library. Existing libraries
   (static or dynamic link) that use iostream functions will have to be
   rebuilt using Standard C++ Library iostream functions.

   For more information, see Issues Surrounding iostream and the Standard
   C++ Library in Visual C++ Books Online, or Differences between C Runtime
   Library and Standard C++ Library.

</PRE><h3>Question 6</h3>
 
<P>
Do I still need to include STL in a separate namespace (for example,
"std") in order to use it with MFC?
<P>
A. No. Previous name conflicts between MFC and STL have been resolved in
<PRE>   Visual C++ 4.2.

   The answer is yes if you are using Visual C++ 5.0.

   NOTE: Visual C++ 4.2 does not implement STL in the namespace "std."

</PRE><h3>Question 7</h3>
 
<P>
I want to use Standard C++ Libraries in an MFC application. Will this
cause any conflicts with the C-Runtime Libraries?
<P>
A. No. MFC does not use any C-Runtime functions that will conflict with the
<PRE>   Standard C++ Libraries.

</PRE><h3>Question 8</h3>
 
<P>
I am getting compiler error C2371: 'identifier' redefinition; different
basic types. What is causing this?
<P>
A. Mixing Standard C++ Headers and Old iostream Headers will cause this
<PRE>   error, even if they are included in different source files. Following
   are the different headers:

      |-------------------------|
      |  Old iostream Headers   |
      |-------------------------|
      | FSTREAM.H  | IOMANIP.H  |
      | IOS.H      | IOSTREAM.H |
      | ISTREAM.H  | OSTREAM.H  |
      | STDIOSTR.H | STREAMB.H  |
      | STRSTREA.H |            |
      |-------------------------|

      |----------------------------------------------------|
      |              Standard C++ Headers                  |
      |----------------------------------------------------|
      | ALGORITHM  |  BITSET  |   COMPLEX  |  DEQUE        |
      | FSTREAM    |FUNCTIONAL|   IOMANIP  |  IOS          |
      | IOSFWD     | IOSTREAM |   ISTREAM  |  ITERATOR     |
      | LIMITS     | LIST     |   LOCALE   |  MAP          |
      | MEMORY     | NUMERIC  |   OSTREAM  |  QUEUE        |
      | SET        | SSTREAM  |   STACK    |  STDEXCEPT    |
      | STREAMBUF  | STRING   |   STRSTREAM|  TYPEINFO     |
      | UTILITY    | VALARRAY |   VECTOR   |  XIOSBASE     |
      | XLOCALE    | XLOCINFO |   XLOCMON  |  XLOCNUM      |
      | XLOCTIME   | XMEMORY  |   XSTRING  |  XTREE        |
      | XUTILITY   | YMATH.H  |            |               |
      |----------------------------------------------------|

</PRE><h3>Question 9</h3>
 
<P>
I have a project that was built with the "Ignore Default Libraries"  Option
(/NOD or /NODEFAULTLIB). With Visual C++ 4.2 or 5.0, I am getting linker
error LNK2001: unresolved external symbol 'symbol' : on all iostream
function calls. What has changed?
<P>
A. The iostream functions have been removed from the C-Runtime Library.
<P>
<PRE>   If you are using the Old iostream functions, you will need to add an
   additional library as follows: LIBCI.LIB (single-threaded &lt;ML&gt;),
   LIBCIMT.LIB (multithreaded &lt;MT&gt;), or MSVCIRT.LIB (multithreaded dll
   &lt;MD&gt;).

   If you are using the New iostream functions included with the Standard
   C++ Library, you will need to add an additional library as follows:
   LIBCP.LIB (single-threaded &lt;ML&gt;), LIBCPMT.LIB (multithreaded &lt;MT&gt;), or
   MSVCPRT.LIB (multithreaded dll &lt;MD&gt;).

   Do not mix different versions of the libraries. For example, if you are
   using the single-threaded version of the C-Runtime Library, you must
   also use the single-threaded version of the Old iostream Library or
   Standard C++ Library.

   You cannot mix calls to the Old iostream Library functions and the new
   Standard C++ Library iostream functions.

   For more information, see Issues Surrounding iostream and the Standard
   C++ Library in Visual C++ Books Online. Also see Compiler Error C2371.

</PRE><h3>Question 10</h3>
 
<P>
I am getting compiler warnings C4786 and/or C4788. None of the symbols  in
my program is anywhere near 255 characters in length. What is causing
this?
<P>
A. C4786/C4788 is issued when a symbol's name exceeds 255 characters in
<PRE>   length. This often happens with templates, and especially STL
   components.

   Ignoring this warning is usually safe. Use a #pragma warning (disable:
   4786,4788) to suppress the messages.

   For more information, see Visual C++ Books Online "Build Errors -
   Compiler Warning (level 1) C4786."

</PRE><h3>Question 11</h3>
 
<P>
I am getting compiler warning C4530: C++ exception handler used, but
unwind semantics are not enabled. Specify -GX. What does that mean?
<P>
A. Programs that use the Standard C++ Library must be compiled with C++
<PRE>   exception handling enabled. C++ exception handling can be enabled by:

    - Selecting the "Enable exception handling" option, in the C++
      Language Category of the C/C++ tab in the Project Settings dialog
      box.

      - or -

    - By using the /GX compiler switch.

</PRE><h3>Question 12</h3>
 
<P>
I am getting compiler error C2146, followed by C2065 and finally C2143,
all pointing to the same line in my source. What does this mean?
<P>
A. This sequence of errors can be caused by the following type of
<PRE>   construct:

      vector&lt;int, allocator&lt;int&gt;&gt;iV;

   The problem is caused by the consecutive &gt;&gt; at the end of the
   declaration. The solution is to put a space between two characters, so
   the above construct becomes:

      vector&lt;int, allocator&lt;int&gt; &gt; iV;

   This is consistent with the proposed ANSII specification.

</PRE><h3>Question 13</h3>
 
<P>
NOTE: This question does not apply to Visual C++ 5.0.
<P>
I am getting compiler error C2976 : 'identifier' : too few template
parameters, when instantiating STL containers. Why do the Standard
Template Library containers of Visual C++ 4.2 require an extra  parameter?
What is that extra parameter?
<P>
A. The C++ standard is an evolving piece of work that should provide the
<PRE>   most complete and up-to-date implementation of the Standard C++ Library.
   However, due to certain limitations, some features of the Standard
   Template Library have been implemented differently.

   Several STL components use Default Template Arguments. The ANSII draft
   specification for the STL container classes (such as vector) specifies
   that the second template argument (the allocator) have a default value
   of "allocator" as follows:

      template&lt;class T, class Allocator = allocator&gt; class vector;

   The pre-defined class allocator utilizes Member Templates. Visual C++
   version 4.2 does not support the use of Member Templates.

   Because it is not possible to directly implement the class allocator,
   allocator has been implemented as a template class in the current
   implementation of the STL. The problem lies in attempting to use the
   templated allocator class as a default template argument. Consider the
   following:

      template&lt;class T, class Allocator = allocator&lt;T&gt; &gt; class vector;

   Visual C++ 4.2 does not support this syntax. This made it necessary, in
   the case of STL containers, to remove the default template argument for
   the allocator. The definition of vector now becomes:

      template&lt;class T, class Allocator&gt; class vector;

   The effect of this change is that declaring a container will now
   require that you explicitly specify the allocator class as a template
   argument. The following declaration of an int vector illustrates:

      vector&lt;int&gt; myVector;

   This will cause the following compiler error:

      Compiler error C2976 : 'vector' : too few template parameters

   To correct the error, the declaration must be changed to:

      vector&lt;int, allocator&lt;int&gt; &gt; myVector;

   It is good programming practice to use typedef statements when
   instantiating template classes. Using a typedef has the following
   advantages:

    - If the definition of the class template changes, you can
      simply change the typedef statement and the rest of your program
      will work as is.

    - Template class instantiations tend to get long. Using typedef
      improves the readability of the code.

   For example, if you have a class template such as the following:

      template &lt;class A, class B, class C, class D&gt;
      class Test
      {
      } ;

   you can instantiate a template class using the above class template
   as follows:

      Test&lt;int, int, float, float&gt; ifClass1 ;

   To instantiate in a different source file, you must use:

      Test&lt;int, int, float, float&gt; ifClass2 ;

   If the definition of the class template Test changes as follows:

      template &lt;class A, class B, class C, class D, class E&gt;
      class Test
      {
      } ;

   you will have to modify every instance in your source code to reflect
   the change.

   Using a typedef would have made the process easier because you would
   only need to change the typedef statement. Use a typedef:

      template &lt;class A, class B, class C, class D&gt;
      class Test
      {
      } ;

      typedef Test&lt;int, int, float, float &gt; MYCLASS ;

      MYCLASS myObj1 ;
      MYCLASS myObj2 ;

   if the class template Test definition changes:

      template &lt;class A, class B, class C, class D, class E&gt;
      class Test
      {
      } ;

      typedef Test&lt;int, int, float, float, char&gt; MYCLASS ;

      MYCLASS myObj1 ;
      MYCLASS myObj2 ;

   Note that the only necessary change was to the one line containing
   the typedef.

   This technique of using typedefs will help insulate you from possible
   future changes to the STL. The vector of ints above, for example,
   becomes:

      typedef vector&lt;int, allocator&lt;int&gt; &gt; INTVECTOR;

   If all instances of a vector of ints are declared as type INTVECTOR, you
   will only need to change the typedef if a future version of Visual C++
   returns to using a default template argument of allocator. Typedefs used
   in conjunction with conditional compilation can also help those dealing
   with multiple platform situations using multiple versions of STL. For
   example, a program being compiled for both UNIX (using HP's STL)
   and NT (using Visual C++ 4.2's STL) might have the following definition
   of INTVECTOR:

      #ifdef _MSC_VER // VC++ STL
      typedef vector&lt;int, allocator&lt;int&gt; &gt; INTVECTOR;
      #else   // HP STL
      typedef vector&lt;int&gt; INTVECTOR;
      #endif

</PRE><h2>REFERENCES</h2>
 
<P>
For latest technical discussions concerning the Standard C++ Library see
Microsoft Frequently Asked Questions in the Microsoft Technical Support Web
site at <B><A HREF="http://www.microsoft.com/support/products/developers/visualc.htm">http://www.microsoft.com/support/products/developers/visualc.htm.</A></B>
<P>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
Additional query words: STL STL.H allocator vector deque list map multimap<BR>
set multiset queue stack priority_queue<BR>
Keywords          : STLIss kbfaq<BR>
Version           : WINNT:4.2,5.0;<BR>
Platform          : NT WINDOWS<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  October 7, 1997</FONT>
	<BR>
	<A HREF="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
