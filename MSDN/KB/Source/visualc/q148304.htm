

<HTML>
<HEAD>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>INFO: Frequently Encountered MFC 3.x to 4.0 Porting Issues </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q148304">
<META NAME="KBModify" CONTENT="1997/07/31">
<META NAME="KBCreate" CONTENT="1996/03/08">
<META NAME="Keywords" CONTENT="MfcDLL MfcDocView MfcMisc MFCThreadIss MfcUI kbtshoot kbref kbtshoot">
<META NAME="KBArea" CONTENT="Support; KB; visualc">
<META NAME="Description" CONTENT="  This article lists some of the most frequently encountered bugs, problems, and other issues that you may experience when attempting to port an application written with MFC 3.x (the MFC included with Visual C++ 2.x) to work with MFC 4.0 (the MFC inc...">
<META NAME="Product" CONTENT="Visual C++">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QABA,QAPN,QAYZ,QAGI,QA01,QAH4,QAHT,QA2O,QA6A,QBVV,QAR4,QBFY,QAMB,QA7O,QA56 V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>INFO: Frequently Encountered MFC 3.x to 4.0 Porting Issues</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  July 31, 1997</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q148304</B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
 
The information in this article applies to:

<UL><LI>The Microsoft Foundation Classes (MFC) included with:
   - Microsoft Visual C++, 32-bit Edition, versions 4.0, 4.1, 4.2, 5.0
</UL> 
<P>
<P><h2>SUMMARY</h2>
 
<P>
This article lists some of the most frequently encountered bugs, problems,
and other issues that you may experience when attempting to port an
application written with MFC 3.x (the MFC included with Visual C++ 2.x) to
work with MFC 4.0 (the MFC included with Visual C++ 4.0).
<P>
<P><h3>General Issues</h3>
 

<OL><P><LI>Window classes are no longer pre-registered by MFC.
</OL>2. BUG: The first control on CFormView gets OnSetFocus before
<PRE>   OnInitialUpdate executes.
</PRE></OL>3. CWinApp::m_templateList no longer exists.
4. BUG: The CString += operator may break with null strings.
5. BUG: OnWndMsg case for WM_xSCROLL messages breaks when scroll bars are
<PRE>   scrolled programmatically.
</PRE>6. BUG: OnInitMenuPopup now deletes the menu temp map before returning.
7. Documented CRuntimeClass::m_pfnConstructObject is now m_pfnCreateObject.
8. BUG: Default dialog-based application doesn't work in Win32s.
<P>
<P><h3>CPropertySheet</h3>
 

<OL><P><LI> CPropertySheet always changes its font to the default font.
</OL>10. Property sheet modifications should be done in OnInitDialog after a
<PRE>   call to the base class.
</PRE></OL>11. CPropertySheet::DoModal() causes first chance exception in Windows 95.
12. Property Sheets now have a minimum width.
<P>
<P><h3>DLLs</h3>
 

<OL><P><LI>MFC threads cannot be created during DLL startup.
</OL>14. Regular DLLs using MFC in the Shared Library require AFX_MODULE_STATE
<PRE>   in exported functions.
</PRE></OL>15. BUG: DoModal may fail in MFC extension DLLs.
<P>
<P><h3>CStatusBar and CToolBar</h3>
 

<OL><P><LI>CToolbar::SetSizes and button sizing.
<P>
</OL><h3>CFileDialog</h3>
 

<OL><P><LI>No need to replace the MFC-supplied CFileDialog hook procedure.
</OL>18. CFileDialog is always a child of the Explorer dialog window.
19. CFileDialog member functions GetFileName and GetFileTitle reversed.
<P>
<P><h3>MFC ODBC</h3>
 

<OL><P><LI>BUG: Dynasets with CLongBinary fields throw an exception.
<P>
</OL><h3>MFC OLE</h3>
 

<OL><P><LI>No more Mfcans32.dll, so OLE functions in MFC applications require
   Unicode arguments.
<P>
</OL><h2>STATUS</h2>
 
<P>
Microsoft has confirmed that those issues marked with a BUG prefix are bugs
in Microsoft Visual C++ version 4.0. We are researching these problems and
will post new information here in the Microsoft Knowledge Base as it
becomes available.
<P>
<P><h2>MORE INFORMATION</h2>
 
<P>
<P><h3>General Issues</h3>
 

<OL><P><LI>Window classes are no longer pre-registered by MFC:
<P>
</OL>Previous to version 4.0, MFC pre-registered four window (WNDCLASS) classes,
as documented in MFC Technical Note number 1. These window classes were
AfxWnd, AfxFrameOrView, AfxMDIFrame, and AfxControlBar. Most code (such as
the ONETIME sample) that prevented more than one instance of an application
relied on these classes.
<P>
Now, as of version 4.0, these four classes are not registered until a
window of that type is created. Windows based on a custom WNDCLASS that
fill in information from the MFC window classes will likely just fail to
show, sending the message that window creation failed. GetLastError returns
the value 0x57F (ERROR_WNDCLASS_DOES_NOT_EXIST) to the debug output window
if MFC tracing is turned on.
<P>
From version 4.0 on, you need to provide all of the necessary information
when registering custom window classes with RegisterClass or
AfxRegisterClass. Do not rely on ::GetClassInfo to retrieve class values
for MFC window classes.
<P>
For additional information, please see  MFC Technical Note 1 and the
following articles in the Microsoft Knowledge Base:
<P>
<PRE>   ARTICLE-ID: <B><A HREF="../VISUALC/Q140596.htm">Q140596</A></B>
   TITLE     : MFC 4.0 No Longer Pre-Registers Window Classes

   ARTICLE-ID: <B><A HREF="../VISUALC/Q141752.htm">Q141752</A></B>
   TITLE     : SAMPLE: Limiting 32-bit Applications to a Single Instance

</PRE><P><LI>BUG: The first control on CFormView gets OnSetFocus before
   OnInitialUpdate executes:
<P>
</OL>This causes problems if there is code in OnSetFocus that refers to CWnd
objects that won't be subclassed until the call to the base class
OnInitDialog. This problem may also occur in any other handler called as a
result of the control getting the focus. For example, radio buttons will
generate a BN_CLICKED when they get the focus.
<P>
For additional information and a workaround, please see the following
article in the Microsoft Knowledge Base:
<P>
<PRE>   ARTICLE-ID: <B><A HREF="../VISUALC/Q142274.htm">Q142274</A></B>
   TITLE     : FIX: Assertion Failure When Handling xN_SETFOCUS in
               CFormView

</PRE><P><LI>CWinApp::m_templateList no longer exists:
<P>
</OL>The m_templateList member variable of CWinApp was undocumented in MFC
versions prior to 4.0 but was used frequently enough to be called a porting
issue. Microsoft recommends that you use the GetFirstDocTemplatePosition()
and GetNextDocTemplate() member functions of CWinApp to gain access to the
templates for an application.
<P>
For additional information, please see the following article in the
Microsoft Knowledge Base:
<P>
<PRE>   ARTICLE-ID: <B><A HREF="../VISUALC/Q106455.htm">Q106455</A></B>
   TITLE     : How to Acquire a List of All CDocument Objects

</PRE><P><LI>BUG: The CString += operator may break with null strings:
<P>
</OL>The particular sequence of events that result in this bug is complex. There
is a bug in the MFC source code that incorrectly handles the case when a
null string is used with the += operator.
<P>
For additional information, please see the following article in the
Microsoft Knowledge Base:
<P>
<PRE>   ARTICLE-ID: <B><A HREF="../VISUALC/Q142385.htm">Q142385</A></B>
   TITLE     : FIX: Using CString::operator+= May Cause an Access Violation

</PRE><P><LI>BUG: OnWndMsg case for WM_xSCROLL messages breaks when scroll bars are
   scrolled programmatically:
<P>
</OL>Code was added in MFC 4.0 to pass the full 32 bits of position (when
available) on to the OnxScroll handlers because the WM_xSCROLL messages can
only pack 16 bits of position information. Unfortunately the code that was
added breaks whenever an application programmatically scrolls a scroll bar
by sending a WM_xSCROLL message to itself by way of SendMessage.
<P>
For additional information, please see the following article in the
Microsoft Knowledge Base:
<P>
<PRE>   ARTICLE-ID: <B><A HREF="../VISUALC/Q147684.htm">Q147684</A></B>
   TITLE     : FIX: Sending WM_xSCROLL Message Causes Invalid ASSERT

</PRE><P><LI>BUG: OnInitMenuPopup now deletes the menu temp map before returning:
<P>
</OL>In MFC version 4.0, calls to AfxLockTempMaps and AfxUnlockTempMaps were
added to CWnd::OnInitMenuPopup. When AfxUnlockTempMaps is called, MFC's
temporary object map reference count will go to zero causing all temporary
MFC objects to be deleted. When the call to OnInitMenuPopup returns, the
CMenu pointer passed in to OnInitMenuPopup (which is a temporary pointer)
will be invalid.
<P>
For additional information, please see the following article in the
Microsoft Knowledge Base:
<P>
<PRE>   ARTICLE-ID: <B><A HREF="../VISUALC/Q141532.htm">Q141532</A></B>
   TITLE     : FIX: OnInitMenuPopup Deletes Temporary Objects

</PRE><P><LI>Documented CRuntimeClass::m_pfnConstructObject is now m_pfnCreateObject:
<P>
</OL>m_pfnConstructObject was a documented member variable of CRuntimeClass in
MFC versions prior to 4.0, but the name was changed to reflect the change
in parameters and return value. The documentation included with Visual C++
4.0 was not updated to reflect this change and incorrectly references the
old function name.

<OL><P><LI>BUG: Default dialog-based application doesn't work in Win32s:
<P>
</OL>When AppWizard generates a dialog-based application, it uses a DIALOGEX
resource for the main dialog. Win32s, however, does not support DIALOGEX
resources. As a result, the dialog box looks incorrect in Win32s. This can
be fixed by removing the WS_EX_APPWINDOW style from within the dialog
editor and by changing the DIALOGEX statement to a DIALOG statement in the
.rc file.
<P>
For additional information, please see the Visual C++ Readme file and the
following article in the Microsoft Knowledge Base:
<P>
<PRE>   ARTICLE-ID: <B><A HREF="../VISUALC/Q138971.htm">Q138971</A></B>
   TITLE     : BUG: Default Dialog-Based Application Doesn't Work in Win32s

</PRE></OL><h3>CPropertySheet</h3>
 
<P>
Much of the MFC implementation of CPropertySheet has changed to now wrap
the Windows Property Sheet common control. There have been some formatting
and sizing changes, but more importantly, if code made use of any of the
private MFC implementations of CPropertySheet, the code will likely break
as most of the undocumented members of that class are no longer there.

<OL><P><LI>CPropertySheet always changes its font to the default font:
<P>
</OL>Even if the font of the property pages is changed in the Resource Editor,
property pages will be displayed at run time with the system font. If it is
necessary to change the font, call SetFont() in OnInitDialog; then use an
appropriate MoveWindow() to resize the sheet and move and resize all the
controls on the page. Also, the property sheet is set back to its original
size whenever a page is activated, so it will be necessary to resize the
page in response to a click on the tab control.
<P>
For additional information, please see the following article in the
Microsoft Knowledge Base:
<P>
<PRE>   ARTICLE-ID: <B><A HREF="../VISUALC/Q142170.htm">Q142170</A></B>
   TITLE     : SAMPLE: PRPFONT - How to Set CPropertySheet Fonts

</PRE><P><LI>Property sheet modifications should be done in OnInitDialog after call
   to base class:
<P>
</OL>During CPropertySheet::OnInitDialog, the property sheet is resized and the
four standard buttons (OK, Cancel, Apply, and Help) are hidden at the
bottom of modeless property sheets. The proper place to modify the size of
the sheet or to customize the four property sheet buttons is in
OnInitDialog after the call to the base class. In previous versions of MFC,
it was common practice to hide some of the buttons shown with a modal
property sheet in OnCreate. These buttons can now be easily removed by
modifying styles in the PROPSHEETHEADER structure CPropertySheet::m_psh.
<P>
For additional information, please see the following articles in the
Microsoft Knowledge Base:
<P>
<PRE>   ARTICLE-ID: <B><A HREF="../VISUALC/Q140585.htm">Q140585</A></B>
   TITLE     : PRB: Resizing CPropertySheet in OnInitDialog Does Not Work

   ARTICLE-ID: <B><A HREF="../VISUALC/Q141039.htm">Q141039</A></B>
   TITLE     : How to Hide the Apply Button in CPropertySheet

</PRE><P><LI>CPropertySheet::DoModal() causes first chance exception on Windows 95:
<P>
</OL>A first chance exception occurs on Windows 95 because the property page
sets required styles in the dialog resource. The operating system needs to
handle this, so the message can be ignored. If you surround the DoModal()
call with a try/catch(...) block in an effort to handle the exception
yourself, you will get a stack fault.

<OL><P><LI>Property Sheets now have a minimum width:
<P>
</OL>The minimum width of a CPropertySheet window is the size of the four
buttons (OK, Cancel, Apply, and Help) that would show up along the bottom
of a modal property sheet. This width applies even to modeless property
sheets, which do not show the four buttons along the bottom.
<P>
<P><h3>DLLs</h3>
 

<OL><P><LI>MFC threads cannot be created during DLL startup:
<P>
</OL>Although not a good idea, it was possible to create a thread during the
startup of an MFC DLL in previous versions of MFC. This includes calling
AfxBeginThread or CWinThread::CreateThread in DllMain, RawDllMain,
InitInstance in the DLL, or in any functions called by these. Due to
synchronization of MFC thread startup code and blocking at DllMain during
DLL_PROCESS_ATTACH and DLL_THREAD_ATTACH, this is no longer permitted. MFC
4.0 DLLs that attempt to do this will hang when loaded by an application.
<P>
For additional information, please see the following article in the
Microsoft Knowledge Base:
<P>
<PRE>   ARTICLE-ID: <B><A HREF="../VISUALC/Q142243.htm">Q142243</A></B>
   TITLE     : PRB: Cannot Create an MFC Thread During DLL Startup

</PRE><P><LI>Regular DLLs using MFC in the Shared Library require AFX_MODULE_STATE
   in exported functions:
<P>
</OL>Previously, the USRDLL model required that MFC be statically linked to the
DLL. It is now possible to link dynamically to the Mfc40.dll from a Regular
DLL (the new term for _USRDLLs). The caveat is that to convert a _USRDLL to
be a "Regular DLL using MFC in a Shared Library," you need to make sure
that you manage your module state information correctly. The single line:
<P>
<PRE>   AFX_MANAGE_STATE(AfxGetStaticModuleState());

</PRE></OL>should be added to the beginning of any function exported from the DLL that
operates on MFC objects.
<P>
The following problems are likely to occur if the module state is not
switched appropriately:

<UL><LI>Dialogs and windows fail at creation in a DLL because of missing
   resources.

<LI>Functions for the wrong application object are called and cause stack
   overflow or unpredictable results.

<LI>Unrecognized run-time class information.

<LI>Bad window-to-MFC object handle map linkage.
<P>
</UL>For additional information, please see MFC Technical Note 58 (TN058) and
the following article in the Microsoft Knowledge Base:
<P>
<PRE>   ARTICLE-ID: <B><A HREF="../VISUALC/Q140850.htm">Q140850</A></B>
   TITLE     : How to Convert DLLTRACE to Use MFC in Shared Library

</PRE><P><LI>BUG: DoModal may fail in MFC extension DLLs:
<P>
</OL>When MFC 4.0 creates a dialog box, it passes the current instance handle to
the ::CreateDialogIndirect Windows API - which creates the dialog instead
of the resource handle for the DLL. The template for the dialog was already
loaded by MFC from the correct extension DLL. However, Windows will look in
the .exe file specified by the instance handle for any extra resources
indicated on the template. Windows will not find them if they are in the
DLL, and the dialog creation will fail. To work around this problem, the
current instance handle should be temporarily switched before any calls to
DoModal. Extra resources include such things as the dialog's menu, custom
controls, or an icon on the dialog.
<P>
For additional information, please see the following article in the
Microsoft Knowledge Base:
<P>
<PRE>   ARTICLE-ID: <B><A HREF="../VISUALC/Q147384.htm">Q147384</A></B>
   TITLE     : FIX: Icons, Bitmaps, &amp; Menus Not Displayed in an AFXDLL
               Dialog

</PRE></OL><h3>CStatusBar and CToolBar</h3>
 
<P>
Like CPropertySheet, these MFC classes now wrap the functionality of the
Win32 common controls. Any code that relied on or modified the private,
undocumented implementation of these classes will likely break when
compiled for MFC 4.0. These two common controls support a greater range of
common customizations than did the previous default MFC implementation, and
they do not require significant overrides of the MFC source for such tasks
as constructing palette bars or making resizable toolbars. If needed, the
old implementation of these two classes is still present as the COldToolBar
and COldStatusBar classes. These implementations can be found in the
OLDBARS sample project.

<OL><P><LI>CToolbar::SetSizes and button sizing:
<P>
</OL>Toolbars now require that the width of the button size be at least 7 pixels
greater than the image size. The documentation that ships with Visual C++
4.0 was not updated to reflect this change and is incorrect. An ASSERT that
MFC version 4.0 uses to verify correct parameters in SetSizes also
incorrectly checks for the old value of 6. There are other limits on the
sizes of the toolbar, buttons, and images, but these are correctly covered
by ASSERT statements in the MFC source and have not changed since MFC 3.x.
<P>
For additional information, please see the following article in the
Microsoft Knowledge Base:
<P>
<PRE>   ARTICLE-ID: <B><A HREF="../VISUALC/Q141444.htm">Q141444</A></B>
   TITLE     : DOC: Incorrect Documentation for CToolBar::SetSizes()

</PRE></OL><h3>CFileDialog</h3>
 

<OL><P><LI>No need to replace the MFC-supplied CFileDialog hook procedure:
<P>
</OL>MFC always specifies its own hook procedure (_AfxCommDlgProc) for the Open
File Dialog during the construction of the CFileDialog object so that it
can properly route notifications for the dialog to the proper handlers. As
of MFC 4.x, this hook procedure is used to subclass the CFileDialog object
to the Open File Dialog window. If the hook procedure is replaced, this
subclass procedure won't occur, so any attempt to use the CFileDialog or an
embedded control variable on it (as if it were a window) will fail.

<OL><P><LI>CFileDialog is always a child of the Explorer dialog window:
<P>
</OL>When you use the Explorer-style CFileDialog (which in Windows 95 you are
doing by default), MFC 4.0 assumes the Explorer model of customization.
This implies that custom improvements to the File dialog are included on a
separate template that is added around the standard Explorer dialog. In MFC
4.0, the actual CFileDialog window is a child dialog of the main File
Common Dialog, even if you are not providing a template to customize the
dialog. Therefore, if you have a need to alter the standard Explorer
interface by moving or hiding controls, prefix all GetDlgItem() calls to
Explorer controls with GetParent(). For example, this expression:
<P>
<PRE>   GetParent()-&gt;GetDlgItem(IDOK)

</PRE></OL>will return a pointer to the Open/Save button on the Explorer dialog.
However, this is not recommended because code that relies on the details of
the standard Explorer dialog controls will break if the Explorer layout is
changed in the future.
<P>
This default can be changed by removing the OFN_EXPLORER style. For more
information, see the following Microsoft Knowledge Base article:
<P>
<PRE>   ARTICLE-ID: <B><A HREF="../WIN32SDK/Q131225.htm">Q131225</A></B>
   TITLE     : PRB: CFileDialog::DoModal() Does Not Display FileOpen Dialog

</PRE><P><LI>CFileDialog member functions GetFileName and GetFileTitle reversed:
<P>
</OL>In MFC 4.0, for the file C:\Article.txt:

<UL><LI>CFileDialog::GetFileName returns Article.txt.
<LI>CFileDialog::GetFileTitle returns Article.
<P>
</UL>Previous versions of MFC returned exactly the opposite. These functions
have been changed to work in a manner similar to the Win32 API functions of
the same names. However, the documentation included with Visual C++ 4.0 was
not updated to reflect these changes and is incorrect.
<P>
For additional information, please see the Visual C++ Readme file and the
following article in the Microsoft Knowledge Base:
<P>
<PRE>   ARTICLE-ID: <B><A HREF="../VISUALC/Q142203.htm">Q142203</A></B>
   TITLE     : DOCERR: GetFileTitle() &amp; GetFileName() Docs Are Switched

</PRE></OL><h3>MFC ODBC</h3>
 

<OL><P><LI>BUG: Dynasets with CLongBinary fields throw exception:
<P>
</OL>An MFC ODBC application that uses dynaset recordsets with CLongBinary-bound
fields worked in Visual C++ 2.x, but it now throws an exception in Visual
C++ 4.0 when the recordset is opened. The exception is thrown from
CRecordset::InitRecord.
<P>
For additional information, please see the following article in the
Microsoft Knowledge Base:
<P>
<PRE>   ARTICLE-ID: <B><A HREF="../VISUALC/Q141303.htm">Q141303</A></B>
   TITLE     : FIX: Dynasets w/ CLongBinary Fields Throws Incorrect
               Exception

</PRE></OL><h3>MFC OLE</h3>
 

<OL><P><LI>No more Mfcans32.dll, so OLE functions in MFC applications require
   Unicode arguments:
<P>
</OL>In MFC 3.x, a special DLL was used (Mfcans32.dll) to convert automatically
between Unicode and MBCS when OLE interfaces were called. MFC 4.0 does not
use this DLL; instead, it talks directly to the Unicode OLE interfaces. To
handle this change, MFC applications now must pass the correct type of
parameters - whether Unicode or MBCS - to OLE functions. MFC 4.0 has
provided a number of macros that make this task easier.
<P>
For more information please see MFC Technical Note 59.
<P>
<P><h2>REFERENCES</h2>
 
<P>
You can find the referenced MFC Technical Notes in the Visual C++ InfoView
in the Visual C++ CD-ROM in this directory:
<P>
<PRE>   Visual C++ Books
      MFC 4.0
         MFC Technical Notes

</PRE></OL>The Visual C++ Readme file can be found in the \Msdev\Vcread.wri file or in
the Visual C++ InfoView under:
<P>
<PRE>   README for Microsoft Visual C++ Version 4.0
      Microsoft Foundation Classes (MFC)"
</PRE>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
Additional query words: troubleshoot trouble shoot conversion<BR>
Keywords          : MfcDLL MfcDocView MfcMisc MFCThreadIss MfcUI kbtshoot kbref kbtshoot<BR>
Technology        : kbMfc<BR>
Version           : 4.0 4.1 4.2 5.0<BR>
Platform          : NT WINDOWS<BR>
Issue type        : kbinfo<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  July 31, 1997</FONT>
	<BR>
	<A HREF="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
