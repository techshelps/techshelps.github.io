

<HTML>
<HEAD>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>BUG: Incorrect Code When Increment Pointer Based on a Pointer </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q122543">
<META NAME="KBModify" CONTENT="1997/07/24">
<META NAME="KBCreate" CONTENT="1994/11/07">
<META NAME="Keywords" CONTENT="CodeGen vcbuglist400 vcbuglist500">
<META NAME="KBArea" CONTENT="Support; KB; visualc">
<META NAME="Description" CONTENT="  Incorrect code is generated when an assignment is made in the same statement where a pointer based on a pointer is incremented.  For example, executing the following code:     char buf[100];    void *pvbuf=buf;    unsigned int _based(pvbuf) *Test; ...">
<META NAME="Product" CONTENT="Visual C++">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QAVW,QAVX,QA2O,QABA,QAH4,QBFY,QAO3,QAO2,QAAP,QASR,QAOX,QAJQ,QAPF,QAKP,QALZ V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>BUG: Incorrect Code When Increment Pointer Based on a Pointer</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  July 24, 1997</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q122543</B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
 
The information in this article applies to:

<UL><LI>Microsoft C/C++ Compiler (CL.EXE) included with:
   - Microsoft C/C++ for MS-DOS, version 7.0
   - Microsoft Visual C++ for Windows, versions 1.0, 1.5, 1.51
   - Microsoft Visual C++, 32-bit Edition, versions 1.0, 2.0, 2.1, 4.0,
<P><PRE>     4.1, 4.2, 5.0
</UL></PRE> 
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
Incorrect code is generated when an assignment is made in the same
statement where a pointer based on a pointer is incremented.
<P>
For example, executing the following code:
<P>
<PRE>   char buf[100];
   void *pvbuf=buf;
   unsigned int _based(pvbuf) *Test;

   *(char _based(pvbuf) *)(((char *)Test)++) = '6'

</PRE>in a Win32-based application causes an application error; executing the
same code in a 16-bit Windows-based application causes this error:
<P>
<PRE>   run-time error R6001
   -null pointer assignment

</PRE><h2>CAUSE</h2>
 
<P>
The compiler generates an unnecessary sub command, as shown here:
<P>
<PRE>   mov  bx,WORD PTR _Test
   sub  bx,WORD PTR _pvbuf    ; Not needed
   mov  si,WORD PTR _pvbuf
   mov  BYTE PTR [bx][si],5
   inc  WORD PTR _Test

</PRE><h2>RESOLUTION</h2>
 
<P>
Split the statement into multiple lines. For example,
<P>
<PRE>   *(char _based(pvbuf) *)(((char *)Test)) = '5';
   ((char*)Test)++;

</PRE><h2>STATUS</h2>
 
<P>
Microsoft has confirmed this to be a bug in the Microsoft products listed
at the beginning of this article. We are researching this bug and will post
new information here in the Microsoft Knowledge Base as it becomes
available.
<P>
<P><h2>MORE INFORMATION</h2>
 
<P>
The following sample demonstrates both the problem and its solution.
<P>
<P><h3>Sample Code</h3>
 
<P>
<PRE>   /* Compile options needed: none
   */

   #include &lt;stdio.h&gt;
   #include &lt;conio.h&gt;
   char buf[100];
   void *pvbuf=buf;
   unsigned int _based(pvbuf) *Test;

   void good()
   {
      *(char _based(pvbuf) *)(((char *)Test)) = '5';
      ((char*)Test)++;
      *(char _based(pvbuf) *)(((char *)Test)) = '5';
   }

   void bad()
   {
      *(char _based(pvbuf) *)(((char *)Test)++) = 6;
   }

   void main(void)
   {
      good();
      printf( "Should print out: 5 5 \n%c %c\n",buf[0],buf[1] );
      getch();
      bad();
      printf( "Should print out: 5 6 \n%c %c\n",buf[0],buf[1] );
   }
</PRE>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
Additional query words: 8.00 8.00c 9.00 10.00 10.10 10.20<BR>
Keywords            : CodeGen vcbuglist400 vcbuglist500<BR>
Version             : 7.0 1.0 1.5 1.51 2.0 2.1 4.0 4.1<BR>
Platform            : MS-DOS NT WINDOWS<BR>
Issue type          : kbbug<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  July 24, 1997</FONT>
	<BR>
	<A HREF="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
