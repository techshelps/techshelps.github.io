

<HTML>
<HEAD>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>PRB: DDX Displays Float/Double in Exponential Format </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q131993">
<META NAME="KBModify" CONTENT="1997/07/10">
<META NAME="KBCreate" CONTENT="1995/06/26">
<META NAME="Keywords" CONTENT="MfcMisc kbcode kbprb kbprg">
<META NAME="KBArea" CONTENT="Support; KB; visualc">
<META NAME="Description" CONTENT="  A floating point or double value may appear unexpectedly in exponential format (scientific notation) in an edit control in an MFC dialog box or formview. This may happen if the following is used to associate a DDX variable of type float or double w...">
<META NAME="Product" CONTENT="Visual C++">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QAHH,QAKD,QAUD,QA4Q,QAFO,QAY5,QBFY,QAHP,QAKC,QA56,QA55,QBB2,QAGI,QACJ,QDNG V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>PRB: DDX Displays Float/Double in Exponential Format</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  July 10, 1997</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q131993</B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
1.50 1.51 1.52 | 2.00 2.10 4.00
<PRE>WINDOWS        | WINDOWS NT
</PRE>kbprg kbprb kbcode
<P>
<P>
 
The information in this article applies to:

<UL><LI>The Microsoft Foundation Classes (MFC), included with:
<P>
<P><PRE>    - Microsoft Visual C++ for Windows, versions 1.5, 1.51, 1.52
    - Microsoft Visual C++ 32-bit Edition, versions 2.0, 2.1, and 4.0
</UL></PRE> 
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
A floating point or double value may appear unexpectedly in exponential
format (scientific notation) in an edit control in an MFC dialog box or
formview. This may happen if the following is used to associate a DDX
variable of type float or double with the edit control:
<P>
<PRE>    DDX_Text(CDataExchange* pDX, int nIDC, float&amp; value)
    DDX_Text(CDataExchange* pDX, int nIDC, double&amp; value)

</PRE>This is true even though the documentation indicates that DDX_Text produces
the exponential format only when the decimal point format is not possible.
<P>
<P><h2>CAUSE</h2>
 
<P>
In Visual C++ for Windows version 1.5x and Visual C++ 32-bit Edition,
version 2.x, the edit control value appears in exponential format because
DDX_Text() uses gcvt() for floats and doubles. The gcvt() C Run-time
function returns exponential format for all numbers of the format 0.0&lt;x&gt;,
where x is any sequence of digits.
<P>
In Visual C++ 32-bit Edition, version 4.0, it is less likely that an edit
control's value will appear in exponential format, but still possible.
DDX_Text calls the internal C Run-time function _stprintf() with a format
specifier of "%.*g" and a precision of either FLT_DIG for floats or DBL_DIG
for doubles. As their underlying implementations are the same, _stprintf()
follows the same rules as does printf(). As the Visual C++ 4.0 Books Online
point out in the "printf Type Field Characters" topic, the field type "g"
yields a
<P>
<PRE>   Signed value printed in f or e format, whichever is more compact
   for the given value and precision. The e format is used only when
   the exponent of the value is less than –4 or greater than or equal
   to the precision argument. . .

</PRE><h2>RESOLUTION</h2>
 
<P>
To work around this behavior, rewrite the DDX_Text() function to use
fcvt(). It's a good idea to create a function that calls fcvt() and does
all the formatting of the string returned from fcvt(). You would call this
function from your own DDX_Text().
<P>
<P><h2>STATUS</h2>
 
<P>
This behavior is by design.
<P>
<P><h2>MORE INFORMATION</h2>
 
<P>
The definitions for the float and the double versions of DDX_Text can be
found in the MFC source file DLGFLOAT.CPP in the MFC\SRC subdirectory of
the main Visual C++ product directory. We recommend that you familiarize
yourself with these functions and those that they call to obtain a solid
understanding of their implementations. This will help you rewrite them
in the event you decide to do so.
<P>
The following provides two sample code backbones for the resolution
mentioned above, one for Visual C++ versions 1.5 through 2.2 and one for
Visual C++ 4.0. Sample Code I assumes that you have an edit control with
ID IDC_EDIT1 on a form view with an associated DDX variable of type float
called m_eFloat. The custom DDX_Text function is called DDX_MyFloatText.
It uses the function double_to_char, which reads in a double and returns
a character string representing the double. Sample Code II makes similar
assumptions but supports an edit control with type double as well. The
custom functions are called DDX_MyFloatText and DDX_MyDoubleText. They
both depend on the internal CRT function _stprintf.
<P>
<P><h3>Sample Code I - for Visual C++ 16-bit 1.5x and Visual C++ 32-bit 2.x</h3>
 
<P>
<PRE>// include header files.
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

//............
//............
//............

// The function prototypes
void AFXAPI DDX_MyFloatText(CDataExchange* pDX, int nIDC,
                            float&amp; value);
char *double_to_char (double number);
</PRE>static BOOL PASCAL NEAR _AfxSimpleFloatParse(const char* pszText,
<PRE>                                             double&amp; d);

//............
//............
//............

// Change the DoDataExchange to use DDX_MyFloatText
void CDlgfloatView::DoDataExchange(CDataExchange* pDX)
</PRE>{
<PRE>    CFormView::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CDlgfloatView)
    DDX_MyFloatText(pDX, IDC_EDIT1, m_eFloat);
    //}}AFX_DATA_MAP
</PRE>}
<P>
<PRE>//............
//............
//............


// Implementation of DDX_MyFloatText and other helper functions
void AFXAPI DDX_MyFloatText(CDataExchange* pDX, int nIDC,
                            float&amp; value)
{
    HWND hWndCtrl = pDX-&gt;PrepareEditCtrl(nIDC);
    char szT[64];
    if (pDX-&gt;m_bSaveAndValidate)
    {
        ::GetWindowText(hWndCtrl, szT, sizeof(szT));
        double d;
        if (!_AfxSimpleFloatParse(szT, d))
        {
            AfxMessageBox(AFX_IDP_PARSE_REAL);
            pDX-&gt;Fail();            // throws exception
        }
        value = (float)d;
    }
    else
    {
        char * pszCvt = double_to_char(value);
        if (pszCvt)
        {
            int nNewLen = lstrlen(pszCvt);
            char szOld[64];
            // fast check to see if text really changes (reduces
            // flash in controls)
            if (nNewLen &gt; sizeof(szOld) ||
                ::GetWindowText(hWndCtrl, szOld, sizeof(szOld)) !=
                                nNewLen ||
                lstrcmp(szOld, pszCvt) != 0)
            {
                // change it
                ::SetWindowText(hWndCtrl, pszCvt);
            }
            delete pszCvt;
        }
        else
        {
            TRACE("DDX_MyFloatText() failed to convert float
                  value.\n");
            pDX-&gt;Fail();            // throws exception
        }
    }
</PRE>}
<P>
<PRE>#define PRECISION  5

char *double_to_char (double number)
</PRE>{
<PRE>   char *buffer,*temp ;

   int  decimal_spot,
        sign,
        count,
        current_location = 0,
        zeropos;

   temp = _fcvt (number, PRECISION, &amp;decimal_spot, &amp;sign) ;

   if (strlen (temp) &gt; PRECISION)
      buffer = new char[(strlen (temp) + 3)];
   else
      buffer = new char[(PRECISION + 3)];

   if (buffer == NULL)
   {
      OutputDebugString("Memory allocating attempt has failed in"
                        "'double_to_char'\n") ;
      return (NULL) ;
   }

 /* Add negative sign if required. */

   if (sign)
      buffer [current_location++] = '-' ;

 /* Place decimal point in the correct location. */

   if (decimal_spot &gt; 0)
   {
      strncpy (&amp;buffer [current_location], temp, decimal_spot) ;
      buffer [decimal_spot + current_location] = '.' ;
      strcpy (&amp;buffer [decimal_spot + current_location + 1],
                      &amp;temp [decimal_spot]) ;
   }
   else
   {
      buffer [current_location++] = '0';
      buffer [current_location] = '.' ;
      for(count = current_location-(1+sign);
          count&lt;abs(decimal_spot); count++)
         buffer [count + (current_location+1)] = '0' ;
      strcpy (&amp;buffer [count + (current_location+1)], temp) ;
   }

   zeropos = strlen(buffer)-3;
   if (buffer[zeropos+2] == '0')
   {

     while (buffer[zeropos--] == '0')
         buffer[zeropos+2] = '\0';

     if (buffer[zeropos+1] != '.')
         buffer[zeropos+2] = '\0';

   }
   return (buffer) ;
</PRE>}
<P>
static BOOL PASCAL NEAR _AfxSimpleFloatParse(const char* pszText,
<PRE>                                             double&amp; d)
{
    ASSERT(pszText != NULL);
    while (*pszText == ' ' || *pszText == '\t')
        pszText++;

    ASSERT(!::IsDBCSLeadByte(*pszText));
    char chFirst = pszText[0];
    d = strtod(pszText, (char**)&amp;pszText);
    if (d == 0.0 &amp;&amp; chFirst != '0')
        return FALSE;   // could not convert
    while (*pszText == ' ' || *pszText == '\t')
        pszText++;
    ASSERT(!::IsDBCSLeadByte(*pszText));

    if (*pszText != '\0')
        return FALSE;   // not terminated properly

    return TRUE;
</PRE>}
<P>
<P><h3>Sample Code II - for Visual C++ 32-bit 4.0</h3>
 
<P>
<PRE>//............
//............
//............

// The function prototypes
void AFXAPI DDX_MyFloatText(CDataExchange* pDX, int nIDC, float&amp; value);
void AFXAPI DDX_MyDoubleText(CDataExchange* pDX, int nIDC, double&amp; value);
void AFXAPI _MyAfxTextFloatFormat(CDataExchange* pDX, int nIDC,
                                  void* pData, double value, int nSizeGcvt,
                                  int nSizeType);

//............
//............
//............

// Change the DoDataExchange to use DDX_MyFloatText or DDX_MyDoubleText
void CDlgfloatView::DoDataExchange(CDataExchange* pDX)
</PRE>{
<PRE>    CFormView::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CDlgfloatView)
    DDX_MyFloatText(pDX, IDC_EDIT1, m_eFloat);
    DDX_MyDoubleText(pDX, IDC_EDIT2, m_eDouble);
    //}}AFX_DATA_MAP
</PRE>}
<P>
<PRE>//............
//............
//............

// Implementation of DDX_MyFloatText, DDX_MyDoubleText and
//   _MyAfxTextFloatFormat.

#include &lt;float.h&gt;
#define PRECISION  8

void AFXAPI DDX_MyFloatText(CDataExchange* pDX, int nIDC, float&amp; value)
</PRE>{
<PRE>    _MyAfxTextFloatFormat(pDX, nIDC, &amp;value, value, PRECISION, FLT_DIG);
</PRE>}
<P>
<PRE>void AFXAPI DDX_MyDoubleText(CDataExchange* pDX, int nIDC, double&amp; value)
</PRE>{
<PRE>    _MyAfxTextFloatFormat(pDX, nIDC, &amp;value, value, PRECISION, DBL_DIG);
</PRE>}
<P>
<PRE>void AFXAPI _MyAfxTextFloatFormat(CDataExchange* pDX, int nIDC,
                                  void* pData, double value, int nSizeGcvt,
                                  int nSizeType)
{
    ASSERT(pData != NULL);

    HWND hWndCtrl = pDX-&gt;PrepareEditCtrl(nIDC);

        // Make sure your buffer is big enough. Strings returned by
        // _stprintf() using the "f" specifier tend to be longer
        // than those returned using the "g" specifier.
    TCHAR szBuffer[64];

    if (pDX-&gt;m_bSaveAndValidate)
    {
        ::GetWindowText(hWndCtrl, szBuffer, _countof(szBuffer));
        double d;
        if (!AfxSimpleFloatParse(szBuffer, d))
        {
            AfxMessageBox(AFX_IDP_PARSE_REAL);
            pDX-&gt;Fail();            // throws exception
        }
        if (nSizeType == FLT_DIG)
            *((float*)pData) = (float)d;
        else
            *((double*)pData) = d;
    }
    else
    {
        _stprintf(szBuffer, _T("%.*f"), nSizeGcvt, value);
        AfxSetWindowText(hWndCtrl, szBuffer);
    }
</PRE>}
<P>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
Additional reference words: 1.50 2.00 2.10 4.00<BR>
KBCategory: kbprg kbprb kbcode<BR>
KBSubcategory: MfcMisc<BR>
Keywords            : MfcMisc kbcode kbprb kbprg<BR>
Technology          : kbMfc<BR>
Version             : 1.50 1.51 1.52 | 2.00 2.10 4.00<BR>
Platform            : NT WINDOWS<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  July 10, 1997</FONT>
	<BR>
	<A HREF="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
