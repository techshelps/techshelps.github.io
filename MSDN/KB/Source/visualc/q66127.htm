

<HTML>
<HEAD>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Using _psp to Check Pointers in an Application </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q66127 ">
<META NAME="KBModify" CONTENT="1997/07/17">
<META NAME="KBCreate" CONTENT="1990/10/06">
<META NAME="Keywords" CONTENT="kb16bitonly">
<META NAME="KBArea" CONTENT="Support; KB; visualc">
<META NAME="Description" CONTENT="  To implement a pointer checking routine in your application developed for the MS-DOS operating system, first determine the beginning memory address of your program. The program segment prefix (PSP) is set to the lowest segment of available memory s...">
<META NAME="Product" CONTENT="Visual C++">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QAGI,QANY,QAH4,QAB5,QABH,QABI,QAO3,QAO2,QAJH,QBW6,QAUD,QAKD,QAIF,QAHC,QDIR V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>Using _psp to Check Pointers in an Application</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  July 17, 1997</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q66127 </B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
6.00 6.00a 6.00ax 7.00 | 1.00 1.50
<PRE>MS-DOS                 | WINDOWS
</PRE>kbprg
<P>
 
The information in this article applies to:

<UL><LI>Microsoft C for MS-DOS, versions 6.0, 6.0a, and 6.0ax
<LI>Microsoft C/C++ for MS-DOS, version 7.0
<LI>Microsoft Visual C++ for Windows, versions 1.0 and 1.5
</UL> 
<P>
<P><h2>SUMMARY</h2>
 
<P>
To implement a pointer checking routine in your application developed
for the MS-DOS operating system, first determine the beginning memory
address of your program. The program segment prefix (PSP) is set to
the lowest segment of available memory statically allocated by the
program. However, when an application uses malloc() to dynamically
allocate memory, it can receive memory at an address less than _psp. A
well-designed pointer checking routine must account for this behavior.
<P>
<P><h2>MORE INFORMATION</h2>
 
<P>
When MS-DOS loads an .EXE or .COM file into memory, it creates the PSP
in the lowest segment of the largest contiguous block of available
memory. Other blocks of memory may be available below the location of
the PSP; these blocks of memory are usually fairly small. In an
application that uses the /Zr compiler option to implement pointer
checking, when MS-DOS returns a pointer to a memory segment that has
an address lower than that of the PSP, the application discards the
segment and calls MS-DOS to request another segment. The application
repeats this process until MS-DOS returns a segment value greater than
_psp.
<P>
To implement a similar scheme in an application, use the techniques
below to call a function instead of calling malloc() directly.
However, because the application start-up code calls malloc() directly
to allocate space for the environment and for arguments, the
environment and argument segments may be less than _psp. Further, the
code example below does not implement pointer checking, it only
enables an application to implement pointer checking by comparing
segment values against _psp.
<P>
Another method for the application to receive pointers to segments at
locations greater than _psp is to modify the start-up code to store
the value of _psp at _aseglo, the location at which the application
stores the lower segment limit when it implements pointer checking.
The code required to check the segment returned by an MS-DOS
allocation against the value at _aseglo and to reject nonconforming
segments is already implemented. If the environment and argument
segments must be greater than _psp, modify the start-up code in a
similar manner. If you assign the value of _psp to _aseglo before the
start-up code allocates space for these variables, their segment
values will be greater than _psp. However, Microsoft does not
guarantee the implementation of this feature in any future release of
the C compiler.
<P>
If a malloc() call causes the application to allocate a new segment
from the operating system, the application calls MS-DOS to request
only the amount of memory required to satisfy the request. In
subsequent calls, malloc() requests additional 8K blocks of memory
until the segment grows to 64K and is full. Because the blocks of
memory below the PSP are typically small, they may not be allocated by
the first malloc() calls. You cannot predict with any certainty when
these blocks of memory will be allocated.
<P>
<P><h3>Sample Code</h3>
 
<P>
<PRE>void * _new_malloc(size_t size)
</PRE>{
<PRE>   void *temp_ptr;

   temp_ptr = malloc(size);
   while ((temp_ptr != NULL) &amp;&amp; (FP_SEG(temp_ptr) &lt; _psp))
      temp_ptr = malloc(size);
   return temp_ptr;
</PRE>}
<P>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
Additional reference words: kbinf 6.00 6.00a 6.00ax 7.00 1.00 1.50 R6013<BR>
illegal far-pointer use<BR>
KBCategory: kbprg<BR>
KBSubcategory: CLngIss<BR>
Keywords            : kb16bitonly<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  July 17, 1997</FONT>
	<BR>
	<A HREF="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
