

<HTML>
<HEAD>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>HOWTO: Override an Interface in an MFC Application </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q141277">
<META NAME="KBModify" CONTENT="1998/03/05">
<META NAME="KBCreate" CONTENT="1995/12/14">
<META NAME="Keywords" CONTENT="MfcOLE">
<META NAME="KBArea" CONTENT="Support; KB; visualc">
<META NAME="Description" CONTENT="  In an MFC application, you can override existing interfaces in a class as well as provide additional interfaces. Overriding an interface in this case is synonymous with replacing an interface. The example in this article illustrates how to override...">
<META NAME="Product" CONTENT="Visual C++">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Security" CONTENT="PUBLIC ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QAOE,QBBS,QAB5,QA7O,QAMN,QAUD,QAPN,QAH4,QABO,QAUJ,QAH6,QABA,QADZ,QBDM,QA6A V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>HOWTO: Override an Interface in an MFC Application</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  March 5, 1998</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q141277</B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
 
The information in this article applies to:

<UL><LI>The Microsoft Foundation Classes (MFC) included with:
   - Microsoft Visual C++, 32-bit Edition, versions 2.0, 2.1, 2.2, 4.0, 5.0
</UL> 
<P>
<P><h2>SUMMARY</h2>
 
<P>
In an MFC application, you can override existing interfaces in a class as
well as provide additional interfaces. Overriding an interface in this case
is synonymous with replacing an interface. The example in this article
illustrates how to override an interface in a class while preserving the
original interface implementation so that it can be delegated to by the new
interface implementation.
<P>
This article doesn't deal with overriding the IDispatch implementation as
this is a special case. The following article demonstrates how to override
IDispatch in MFC:
<P>
<PRE>   ARTICLE-ID: <B><A HREF="../VISUALC/Q140616.htm">Q140616</A></B>
   TITLE     : MFCDISP: Replacing MFC's IDispatch implementation

</PRE><h2>MORE INFORMATION</h2>
 
<P>
The following steps will override the IOleObject implementation for a
default OLE Control generated by the Control Wizard.

<OL><P><LI>To add the declaration of the IOleObject implementation to the control,
   add the following code to the header file for the COleControl-derived
   class:
<P>
<P><PRE>      // Interface Maps
      protected:
<PRE></PRE>           // IOleObject
           BEGIN_INTERFACE_PART(MyOleObject, IOleObject)
               INIT_INTERFACE_PART(CIOleOverCtrl, MyOleObject)
               STDMETHOD(SetClientSite)(LPOLECLIENTSITE);
               STDMETHOD(GetClientSite)(LPOLECLIENTSITE*);
               STDMETHOD(SetHostNames)(LPCOLESTR, LPCOLESTR);
               STDMETHOD(Close)(DWORD);
               STDMETHOD(SetMoniker)(DWORD, LPMONIKER);
               STDMETHOD(GetMoniker)(DWORD, DWORD, LPMONIKER*);
               STDMETHOD(InitFromData)(LPDATAOBJECT, BOOL, DWORD);
               STDMETHOD(GetClipboardData)(DWORD, LPDATAOBJECT*);
               STDMETHOD(DoVerb)(LONG, LPMSG, LPOLECLIENTSITE, LONG, HWND,
                       LPCRECT);
               STDMETHOD(EnumVerbs)(IEnumOLEVERB**);
               STDMETHOD(Update)();
               STDMETHOD(IsUpToDate)();
               STDMETHOD(GetUserClassID)(CLSID*);
               STDMETHOD(GetUserType)(DWORD, LPOLESTR*);
               STDMETHOD(SetExtent)(DWORD, LPSIZEL);
               STDMETHOD(GetExtent)(DWORD, LPSIZEL);
               STDMETHOD(Advise)(LPADVISESINK, LPDWORD);
               STDMETHOD(Unadvise)(DWORD);
               STDMETHOD(EnumAdvise)(LPENUMSTATDATA*);
               STDMETHOD(GetMiscStatus)(DWORD, LPDWORD);
               STDMETHOD(SetColorScheme)(LPLOGPALETTE);
           END_INTERFACE_PART(MyOleObject)

      DECLARE_INTERFACE_MAP();

   This adds a nested class XMyOleObject to your control class. Note that
   these macros declare interface methods including the IUnknown interface
   methods, so you must implement the IUnknown methods as well.

</PRE><P><LI>Add the IOleObject interface to the interface map for the control by
   adding an INTERFACE_PART macro to the implementation file for the
   control:
<P>
<P><PRE>      BEGIN_INTERFACE_MAP(CIOleOverCtrl, COleControl)
<PRE></PRE>         INTERFACE_PART(CIOleOverCtrl, IID_IOleObject, MyOleObject)
      END_INTERFACE_MAP()

   Replace CIOleOverCtrl with the name of your control and MyOleObject with
   the name you chose for the nested class that supports IOleObject.

</PRE><P><LI>Implement the interface methods you declared. Add the following code to
   the implementation file for the control:
<P>
<P><PRE>      STDMETHODIMP_(ULONG) CIOleOverCtrl::XMyOleObject::AddRef()
      {
<PRE></PRE>          METHOD_MANAGE_STATE(CIOleOverCtrl, MyOleObject)
          ASSERT_VALID(pThis);

          return pThis-&gt;m_xMyOleObject.AddRef();
      }

      STDMETHODIMP_(ULONG) CIOleOverCtrl::XMyOleObject::Release()
      {
          METHOD_MANAGE_STATE(CIOleOverCtrl, MyOleObject)
          ASSERT_VALID(pThis);

          return pThis-&gt;m_xMyOleObject.Release ();
      }

      STDMETHODIMP CIOleOverCtrl::XMyOleObject::QueryInterface(
          REFIID iid, LPVOID far* ppvObj)
      {
          METHOD_MANAGE_STATE(CIOleOverCtrl, MyOleObject)
          ASSERT_VALID(pThis);

          return pThis-&gt;m_xMyOleObject.QueryInterface ( iid,  ppvObj);
      }

      STDMETHODIMP
      CIOleOverCtrl::XMyOleObject::SetClientSite(LPOLECLIENTSITE
      pClientSite)
      {
          METHOD_MANAGE_STATE(CIOleOverCtrl, MyOleObject)
             ASSERT_VALID(pThis);

          return pThis-&gt;m_xMyOleObject.SetClientSite ( pClientSite );
      }
      ...

</PRE></OL>The rest of the methods follow the same pattern where CIOleOverCtrl is the
name of the control, XMyOleObject is the name of the nested class that
supports IOleObject, and m_xMyOleObject is calculated by removing the I
from the interface being supported and adding m_x.
<P>
Note that these methods simply pass the call on to the original IOleObject
implementation. However, this is not a requirement; you could add
functionality and delegate to the original implementation or not delegate
at all.
<P>
<P><h2>REFERENCES</h2>
 
<P>
Technical Notes #38 and #39.
 
<PRE>Keywords          : MfcOLE
Technology        : kbMfc kbole
Version           : Winnet:2.0,2.1,2.2,4.0,5.0
Platform          : NT WINDOWS
Issue type        : kbhowto</PRE>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
================================================================================<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  March 5, 1998</FONT>
	<BR>
	<A HREF="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
