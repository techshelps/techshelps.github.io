

<HTML>
<HEAD>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>PRB: "Unexpected column data types were returned from query" </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q123977">
<META NAME="KBModify" CONTENT="1997/07/10">
<META NAME="KBCreate" CONTENT="1994/12/14">
<META NAME="Keywords" CONTENT="MfcDatabase kbcode kbprb kbprg">
<META NAME="KBArea" CONTENT="Support; KB; visualc">
<META NAME="Description" CONTENT="  The following exception is thrown in a MFC database application:      Unexpected column data types were returned from query   The message appears in a message box as well as in the Output window of the Visual C++ debugger.  CAUSE =====  This except...">
<META NAME="Product" CONTENT="Visual C++">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QAY5,QAB9,QBV8,QAGX,QAUD,QAE1,QBFY,QAP2,QDMN,QAHE,QAGI,QAEF,QBC9,QBC8,QA56 V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>PRB: "Unexpected column data types were returned from query"</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  July 10, 1997</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q123977</B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
1.50 1.51 1.52 | 2.00 2.10
<PRE>WINDOWS        | WINDOWS NT
</PRE>kbprg kbprb kbcode
<P>
 
The information in this article applies to:
<P>
<PRE>   The Microsoft Foundation Classes (MFC), included with:
    - Microsoft Visual C++ for Windows, versions 1.5, 1.51 and 1.52
    - Microsoft Visual C++ 32-bit Edition, versions 2.0, 2.1
</PRE> 
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
The following exception is thrown in a MFC database application:
<P>
<PRE>   "Unexpected column data types were returned from query"

</PRE>The message appears in a message box as well as in the Output window
of the Visual C++ debugger.
<P>
<P><h2>CAUSE</h2>
 
<P>
This exception is thrown by a record field exchange RFX function if the SQL
type of the column returned in the recordset doesn't match the C type used
to stored the retrieved data for that column. For example, in the MFC
RFX_Text() function for Visual C++ version 1.51, you'll see the following
code segment:
<P>
case CFieldExchange::BindFieldToColumn:
<PRE>        {
        UINT cbColumn;
        int nSqlType = pFX-&gt;GetColumnType(nField, &amp;cbColumn);
        switch (nSqlType)
        {
         default:
   pFX-&gt;m_prs-&gt;ThrowDBException(AFX_SQL_ERROR_FIELD_SCHEMA_MISMATCH);

         case SQL_LONGVARCHAR:
         case SQL_CHAR:
         case SQL_VARCHAR:
            break;

         case SQL_DECIMAL:
         case SQL_NUMERIC:
             // Add room for sign and decimal point
             cbColumn += 2;
             break;
        }

</PRE>NOTE: The RFX_Text() function supports converting SQL_LONGVARCHAR,SQL_CHAR,
SQL_VARCHAR, SQL_DECIMAL, and SQL_NUMERIC fields to a CString. If the
column that the RFX_Text() function represents has any other SQL type, you
will get the exception.
<P>
There are two typical reasons why developers get the exception. First, a
developer has specified a SQL statement as the second argument for the
CRecordset::Open() function. In this case, the columns listed in the SQL
SELECT statement must match the order by which the RFX functions are called
in the CRecordset's DoFieldExchange(). The first RFX function maps to the
first column returned in the recordset, the second RFX function maps to the
second column, and so on. The exception is thrown when the RFX functions
are out of order. Paying attention to the exception can save developers a
lot of debugging time.
<P>
Second, a developer intentionally changes one of the RFX functions to map
the recordset column to a different C type because he or she knows the ODBC
driver is capable of converting the column to any number of C types. For
example, a common scenario is to have the driver return a date in a
character string rather than a TIMESTAMP_STRUCT. Therefore, the developer
will change the RFX_Date() function in the CRecordset's DoFieldExchange()
function to a RFX_Text() function. In this scenario, the MFC RFX functions
are being type strict and the exception shown above will occur.
<P>
<P><h2>RESOLUTION</h2>
 
<P>
In Visual C++ version 2.2 or greater, you will not get the exception
discussed in this article.  Type checking has been relaxed and now you
will only see a message in the Output window:
<P>
<PRE>   "Warning: CString converted from SQL type &lt;SOME_SQL_TYPE&gt;"

</PRE>If you do not have Visual C++ 2.2 or greater and want to remove the
type checking that the RFX functions provide, copy the existing RFX
function into a new function and remove the the code that throws the
exception. Replace the call to RFX_Text() with your new RFX_MyText()
function in the DoFieldExchange() function. For example, to change
the RFX_Text() function so that it doesn't do the type checking,
change the code segment shown near the beginning of this article
to this:
<P>
case CFieldExchange::BindFieldToColumn:
<PRE>        {
            UINT cbColumn;
            int nSqlType = pFX-&gt;GetColumnType(nField, &amp;cbColumn);
            switch (nSqlType)
            {
            default:
                break;

            case SQL_DECIMAL:
            case SQL_NUMERIC:
                // Add room for sign and decimal point
                cbColumn += 2;
                break;
            }

</PRE>By removing the strict type checking of the RFX functions, you can use
functions like RFX_Text() to store SQL_DATE or SQL_TIMESTAMP column data in
strings rather than structures.
<P>
Another alternative is to create a new RFX function that either handles the
BindFieldToColumn case or calls the standard RFX function. For example, you
could re-write your RFX_Text() function to be something like this:
<P>
<PRE>void RFX_MyText(CFieldExchange* pFX, const char *szName,
    CString&amp; value, int nMaxLength, int nColumnType)
</PRE>{
<PRE>    ASSERT(AfxIsValidAddress(pFX, sizeof(CFieldExchange)));
    ASSERT(AfxIsValidString(szName));
    ASSERT(AfxIsValidAddress(&amp;value, sizeof(CString)));

    RETCODE nRetCode;
    UINT nField;
    if (!pFX-&gt;IsFieldType(&amp;nField))
        return;

    if (pFX-&gt;m_nOperation==CFieldExchange::BindFieldToColumn)
    {
            UINT cbColumn;
            int nSqlType = pFX-&gt;GetColumnType(nField, &amp;cbColumn);
            switch (nSqlType)
            {
            default:
                break;

            case SQL_DECIMAL:
            case SQL_NUMERIC:
                // Add room for sign and decimal point
                cbColumn += 2;
                break;
            }

            // Constrain to user specified max length
            if (cbColumn &gt; (UINT)nMaxLength)
                cbColumn = nMaxLength;
            AFX_SQL_SYNC(::SQLBindCol(pFX-&gt;m_prs-&gt;m_hstmt,
                (unsigned short int)nField, SQL_C_CHAR,
                value.GetBufferSetLength(cbColumn+1), cbColumn+1,
                pFX-&gt;m_prs-&gt;GetFieldLength(pFX)));
            value.ReleaseBuffer();
            if (!pFX-&gt;m_prs-&gt;Check(nRetCode))
                pFX-&gt;m_prs-&gt;ThrowDBException(nRetCode);
            return;
    }

    // Undo the increments done in the IsFieldType call above
    if (pFX-&gt;m_nFieldType == CFieldExchange::outputColumn)
          --pFX-&gt;m_nFields;
    else
          --pFX-&gt;m_nParams;

    RFX_Text(pFX, szName, value, nMaxLength, nColumnType);
</PRE>}
<P>
<P><h2>REFERENCES</h2>
 
<P>
For more information about Record Field Exchange (RFX) functions, please
see the following references:
<P>
<PRE>   MFC Technote #43 - "RFX Routines"
   MFC Encyclopedia articles on RFX in the online books
</PRE>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
Additional reference words: 1.50 2.00 2.50 2.51 3.00<BR>
KBCategory: kbprg kbprb kbcode<BR>
KBSubcategory: MfcDatabase<BR>
Keywords            : MfcDatabase kbcode kbprb kbprg<BR>
Technology          : kbMfc<BR>
Version             : 1.50 1.51 1.52 | 2.00 2.10<BR>
Platform            : NT WINDOWS<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  July 10, 1997</FONT>
	<BR>
	<A HREF="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
