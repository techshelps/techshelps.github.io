

<HTML>
<HEAD>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>How To Avoid the ODBC Login Dialog when Using MFC </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q150552">
<META NAME="KBModify" CONTENT="1997/07/31">
<META NAME="KBCreate" CONTENT="1996/05/02">
<META NAME="Keywords" CONTENT="MfcDatabase kbcode kbhowto kbinterop kbprg kbusage">
<META NAME="KBArea" CONTENT="Support; KB; visualc">
<META NAME="Description" CONTENT="  By default, when you use the MFC ODBC database classes to connect to a datasource, ODBC invokes a login dialog box that allows the user to type in any necessary information, such as a password, to log in.  With Visual C++ 4.2, use the CDatabase::Op...">
<META NAME="Product" CONTENT="Visual C++">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QABI,QABH,QAI5,QA9E,QAH4,QAGI,QAUD,QAH6,QAI4,QAY2,QAHE,QA56,QA55,QBFY,QATX V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>How To Avoid the ODBC Login Dialog when Using MFC</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  July 31, 1997</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q150552</B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
1.50 1.51 1.52 | 2.00 2.10 2.20 4.00 4.10 4.20
<PRE>WINDOWS        | WINDOWS NT
</PRE>kbprg kbinterop kbusage kbhowto kbcode
<P>
 
The information in this article applies to:

<UL><LI>The Microsoft Foundation Classes (MFC) included with:
<P>
<P><PRE>    - Microsoft Visual C++ for Windows, versions 1.5, 1.51, 1.52
    - Microsoft Visual C++ 32-bit Edition, versions 2.0, 2.1, 2.2, 4.0,
      4.1, 4.2
</UL></PRE> 
<P>
<P><h2>SUMMARY</h2>
 
<P>
By default, when you use the MFC ODBC database classes to connect to a
datasource, ODBC invokes a login dialog box that allows the user to type in
any necessary information, such as a password, to log in.
<P>
With Visual C++ 4.2, use the CDatabase::OpenEx() method to connect to an
ODBC datasource with MFC. Inside CDatabase::Connect(), which is called
by CDatabase::OpenEx(), is a call to the ODBC API function,
SQLDriverConnect, that does the work to connect.
<P>
With versions of Visual C++ earlier than 4.2, use the CDatabase::Open()
method to connect to an ODBC datasource with MFC. Inside CDatabase::Open()
is a call to the ODBC API function, SQLDriverConnect, that does the work to
connect.
<P>
The last parameter to SQLDriverConnect is a flag indicating whether the
ODBC Driver Manager or driver should prompt for more connection
information. MFC uses the SQL_DRIVER_COMPLETE flag that instructs ODBC to
invoke a login dialog if you do not supply a connect string with all of the
information necessary to make a connection.
<P>
Occasionally it is preferable to suppress ODBC from creating a dialog by
calling SQLDriverConnect and passing SQL_DRIVER_NOPROMPT as the last
parameter. The SQL_DRIVER_NOPROMPT flag instructs ODBC to connect with the
information passed in the connect string. If the connection string does not
contain enough information to connect to the data source, the call to
SQLDriverConnect() returns a value of SQL_ERROR.
<P>
With Visual C++ 4.2, specify the CDatabase::noOdbcDialog option as the
second argument to CDatabase::OpenEx(). This will cause
CDatabase::OpenEx() to call SQLDriverConnect with the SQL_DRIVER_NOPROMPT
flag.
<P>
To accomplish this behavior using the MFC database classes included with
versions of Visual C++ before 4.2, you need to derive a new class from
CDatabase and override CDatabase::Open().
<P>
Copy the code for CDatabase::Open() from the MFC source file Dbcore.cpp.
Then change the call to SQLDriverConnect by replacing SQL_DRIVER_COMPLETE
with SQL_DRIVER_NOPROMPT.
<P>
The second parameter in SQLDriverConnect is a window handle. You need to
pass NULL for this.
<P>
Also, add a check for a return value of SQL_ERROR.
<P>
<P><h2>MORE INFORMATION</h2>
 
<P>
Sample code for Visual C++ 4.2 can be found in the online documentation
for CDatabase::OpenEx().
<P>
<P><h3>Sample Code</h3>
 
<P>
<PRE>// The code provided here works with MFC 4.1.
// Code to work with other versions of MFC before 4.2 will be very similar.
// You just need to copy the source for CDatabase::Open() from
// Dbcore.cpp, make the changes described in this article, and then
// determine which file specific definitions and header files to add
// to your .cpp file.

// MyDataBase.h
// Derive a class from CDatabase

</PRE>class CMyDatabase : public CDatabase
{
<PRE>  public:

  Open(LPCTSTR lpszDSN, BOOL bExclusive = FALSE,
       BOOL bReadonly = FALSE, LPCTSTR lpszConnect = "ODBC;",
       BOOL bUseCursorLib = TRUE);
</PRE>};
<P>
<PRE>//MyDataBase.cpp
#include "stdafx.h"
#include &lt;afxpriv.h&gt;
#include &lt;afxdisp.h&gt;

#include "MyDataBase.h"

// This line of code is borrowed from Dbcore.cpp
</PRE>static const TCHAR szODBC[] = _T("ODBC;");
<P>
<PRE>// These two lines are borrowed from Afximpl.h
// determine number of elements in an array (not bytes)
#define _countof(array) (sizeof(array)/sizeof(array[0]))

</PRE>BOOL CMyDatabase::Open(LPCTSTR lpszDSN, BOOL bExclusive,
<PRE>  BOOL bReadonly, LPCTSTR lpszConnect, BOOL bUseCursorLib)
</PRE>{
<PRE>  UCHAR szConnectOutput[MAX_CONNECT_LEN];

</PRE>#ifdef _68K_
<PRE>  if(nClassObject == 0)
  AfxThrowDBException(AFX_SQL_ERROR_ODBC_LOAD_FAILED, NULL,
                      SQL_NULL_HSTMT);
</PRE>#endif
<P>
ASSERT_VALID(this);
ASSERT(lpszDSN == NULL || AfxIsValidString(lpszDSN));
ASSERT(lpszConnect == NULL || AfxIsValidString(lpszConnect));
<P>
<PRE>// Exclusive access not supported.
</PRE>ASSERT(!bExclusive);
UNUSED(bExclusive);  // unused in release builds
<P>
m_bUpdatable = !bReadonly;
<P>
TRY
{
if (lpszConnect != NULL)
<PRE>  m_strConnect = lpszConnect;

// For Visual Basic &amp; Microsoft Access compatibility, use the
// "ODBC;" (or "odbc;") prefix to the connect string
</PRE>if (_tcsnicmp(m_strConnect, szODBC, lstrlen(szODBC)) != 0)
{
<PRE>  TRACE0("Error: Missing 'ODBC' prefix on connect string.\n");
  return FALSE;
</PRE>}
<P>
<PRE>// Strip "ODBC;"
</PRE>m_strConnect = m_strConnect.Right(m_strConnect.GetLength()
<PRE>                 - lstrlen(szODBC));

</PRE>if (lpszDSN != NULL &amp;&amp; lstrlen(lpszDSN) != 0)
<PRE>  {
    // Append "DSN=" lpszDSN
    m_strConnect += ";DSN=";
     m_strConnect += lpszDSN;
   }

     AllocConnect();

     RETCODE nRetCode;
     // Turn on cursor lib support
     if (bUseCursorLib)
     {
       AFX_SQL_SYNC(::SQLSetConnectOption(m_hdbc,
           SQL_ODBC_CURSORS, SQL_CUR_USE_ODBC));
         // With cursor library added records immediately in result set
         m_bIncRecordCountOnAdd = TRUE;
       }

       HWND hWndTop;
       CWnd* pWnd = CWnd::GetSafeOwner(NULL, &amp;hWndTop);
       if (pWnd == NULL)
         pWnd = CWnd::GetDesktopWindow();
       ASSERT_VALID(pWnd);

       SWORD nResult;
</PRE>#ifndef _MAC
<PRE>       USES_CONVERSION;

   // Code before it was changed:
   //    AFX_SQL_SYNC(::SQLDriverConnect(m_hdbc, pWnd-&gt;m_hWnd,
   //      (UCHAR*)T2A((LPCTSTR)m_strConnect), SQL_NTS,
   //      szConnectOutput, _countof(szConnectOutput),
   //      &amp;nResult, SQL_DRIVER_COMPLETE));

       AFX_SQL_SYNC(::SQLDriverConnect(m_hdbc, NULL,
         (UCHAR*)(const char*)m_strConnect, SQL_NTS,
         szConnectOutput, _countof(szConnectOutput),
         &amp;nResult, SQL_DRIVER_NOPROMPT));

</PRE>#else
<PRE>    AFX_SQL_SYNC(::SQLDriverConnect(m_hdbc, GetWrapperWindow(pWnd-&gt;m_hWnd),
         (UCHAR*)(const char*)m_strConnect, SQL_NTS,
         szConnectOutput, _countof(szConnectOutput),
         &amp;nResult, SQL_DRIVER_COMPLETE));

</PRE>#endif
<PRE>    if (hWndTop != NULL)
      ::EnableWindow(hWndTop, TRUE);

    // Code before it was changed:
     //    if (nRetCode == SQL_NO_DATA_FOUND)
    // Now need to check for SQL_ERROR too
    if ((nRetCode == SQL_NO_DATA_FOUND) || (nRetCode == SQL_ERROR))
    {
      Free();
      return FALSE;
    }

    if (!Check(nRetCode))
    {
</PRE>#ifdef _DEBUG
<PRE>    if (pWnd-&gt;m_hWnd == NULL)
       TRACE0("Error: No default window (AfxGetApp()-&gt;m_pMainWnd) for
   SQLDriverConnect.\n");
</PRE>#endif
<PRE>      ThrowDBException(nRetCode);
    }

    // Connect strings must have "ODBC;"
    m_strConnect = szODBC;
    // Save connect string returned from ODBC
 m_strConnect += (char*)szConnectOutput;

    SWORD nAPIConformance;
    AFX_SQL_SYNC(::SQLGetInfo(m_hdbc, SQL_ODBC_API_CONFORMANCE,
      &amp;nAPIConformance, sizeof(nAPIConformance), &amp;nResult));
    if (!Check(nRetCode))
      ThrowDBException(nRetCode);

    if (nAPIConformance &lt; SQL_OAC_LEVEL1)
      ThrowDBException(AFX_SQL_ERROR_API_CONFORMANCE);

    SWORD nSQLConformance;
    AFX_SQL_SYNC(::SQLGetInfo(m_hdbc, SQL_ODBC_SQL_CONFORMANCE,
      &amp;nSQLConformance, sizeof(nSQLConformance), &amp;nResult));
    if (!Check(nRetCode))
      ThrowDBException(nRetCode);

    if (nSQLConformance &lt; SQL_OSC_MINIMUM)
      ThrowDBException(AFX_SQL_ERROR_SQL_CONFORMANCE);

    AFX_SQL_SYNC(::SQLGetInfo(m_hdbc, SQL_CURSOR_COMMIT_BEHAVIOR,
      &amp;m_nCursorCommitBehavior, sizeof(m_nCursorCommitBehavior),
      &amp;nResult));
    if (!Check(nRetCode))
      m_nCursorCommitBehavior = SQL_ERROR;

    AFX_SQL_SYNC(::SQLGetInfo(m_hdbc, SQL_CURSOR_ROLLBACK_BEHAVIOR,
      &amp;m_nCursorRollbackBehavior, sizeof(m_nCursorRollbackBehavior),
      &amp;nResult));
   if (!Check(nRetCode))
     m_nCursorRollbackBehavior = SQL_ERROR;

   UDWORD dwGetDataExtensions;
   AFX_SQL_SYNC(::SQLGetInfo(m_hdbc, SQL_GETDATA_EXTENSIONS,
     &amp;dwGetDataExtensions, sizeof(dwGetDataExtensions),
     &amp;nResult));
   if (!Check(nRetCode))
     dwGetDataExtensions = 0;
   if (dwGetDataExtensions &amp; SQL_GD_BOUND)
     m_dwUpdateOptions = AFX_SQL_GDBOUND;
   else
     m_dwUpdateOptions = 0;

   // Set required transaction support for CRecordset cursors
   if ((m_nCursorCommitBehavior == SQL_CB_PRESERVE) &amp;&amp;
     (m_nCursorRollbackBehavior == SQL_CB_PRESERVE))
     m_bTransactions = TRUE;

   if (m_bUpdatable)
   {
     // Make sure data source is Updatable
     char szReadOnly[10];
     AFX_SQL_SYNC(::SQLGetInfo(m_hdbc, SQL_DATA_SOURCE_READ_ONLY,
       szReadOnly, _countof(szReadOnly), &amp;nResult));
     if (Check(nRetCode) &amp;&amp; nResult == 1)
       m_bUpdatable = !(lstrcmpA(szReadOnly, "Y") == 0);
     else
       m_bUpdatable = FALSE;
</PRE>#ifdef _DEBUG
<PRE>      if (!m_bUpdatable &amp;&amp; (afxTraceFlags &amp; traceDatabase))
        TRACE0("Warning: data source is readonly.\n");
</PRE>#endif
<PRE>    }
    else
    {
      // Make data source is Updatable
      AFX_SQL_SYNC(::SQLSetConnectOption(m_hdbc,
        SQL_ACCESS_MODE, SQL_MODE_READ_ONLY));
    }

    char szIDQuoteChar[2];
    AFX_SQL_SYNC(::SQLGetInfo(m_hdbc, SQL_IDENTIFIER_QUOTE_CHAR,
      szIDQuoteChar, _countof(szIDQuoteChar), &amp;nResult));
    if (Check(nRetCode) &amp;&amp; nResult == 1)
      m_chIDQuoteChar = szIDQuoteChar[0];
    else
      m_chIDQuoteChar = ' ';

</PRE>#ifdef _DEBUG
<PRE>    if (afxTraceFlags &amp; traceDatabase)
    {
      char szInfo[64];
      AFX_SQL_SYNC(::SQLGetInfo(m_hdbc, SQL_DBMS_NAME,
        szInfo, _countof(szInfo), &amp;nResult));
      if (Check(nRetCode))
      {
        CString strInfo = szInfo;
        TRACE1("DBMS: %s\n", strInfo);
        AFX_SQL_SYNC(::SQLGetInfo(m_hdbc, SQL_DBMS_VER,
          szInfo, _countof(szInfo), &amp;nResult));
        if (Check(nRetCode))
        {
          strInfo = szInfo;
          TRACE1(", Version: %s\n", strInfo);
        }
      }
    }
</PRE>#endif
<PRE>  }
  CATCH_ALL(e)
  {
    Free();
    THROW_LAST();
  }
  END_CATCH_ALL

  return TRUE;
</PRE>}
<P>
<P><h2>REFERENCES</h2>
 
<P>
Class Library Reference for CDatabase::OpenEx member function.
<P>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
Additional reference words: 1.50 1.51 1.52 2.00 2.10 2.20 4.00 4.10 4.20<BR>
KBCategory: kbprg kbinterop kbusage kbhowto kbcode<BR>
KBSubcategory: MfcDatabase<BR>
Keywords          : MfcDatabase kbcode kbhowto kbinterop kbprg kbusage<BR>
Technology        : kbMfc<BR>
Version           : 1.50 1.51 1.52 | 2.00 2.10 2.20<BR>
Platform          : NT WINDOWS<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  July 31, 1997</FONT>
	<BR>
	<A HREF="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
