

<HTML>
<HEAD>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>FIX: Requery Not Affected by Changing a CTime Parameter </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q115217">
<META NAME="KBModify" CONTENT="1997/09/18">
<META NAME="KBCreate" CONTENT="1994/05/22">
<META NAME="Keywords" CONTENT="kb16bitonly MfcDatabase kbbuglist kbfixlist kbprg">
<META NAME="KBArea" CONTENT="Support; KB; visualc">
<META NAME="Description" CONTENT="  Requery() fails to present the correct results if a CTime object is used in a parameterized filter for a CRecordset.  Consider the following scenario: An application uses a parameterized filter where a CTime object is one of the parameters. The CTi...">
<META NAME="Product" CONTENT="Visual C++">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QAPN,QAGI,QAHE,QDKF,QBVW,QAPP,QAYL,QAW6,QAH4,QAY5,QAR4,QAKD,QA4Q,QA6E,QAL3 V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>FIX: Requery Not Affected by Changing a CTime Parameter</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  September 18, 1997</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q115217</B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
1.50
WINDOWS
kbprg kbfixlist kbbuglist
<P>
 
The information in this article applies to:

<UL><LI>The Microsoft Foundation Classes (MFC), included with:
<P><PRE>    - Microsoft Visual C++ for Windows, version 1.5
</UL></PRE> 
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
Requery() fails to present the correct results if a CTime object is
used in a parameterized filter for a CRecordset.
<P>
Consider the following scenario: An application uses a parameterized filter
where a CTime object is one of the parameters. The CTime object is
initialized to some value before the CRecordset is opened; the records that
are returned when the recordset is opened are based on this value. Later,
the CTime object's value may be changed with the intent of requerying for a
different result set. However, after the value of the CTime parameter is
modified and the Requery() function is called, the result set does not
reflect the newly changed CTime parameter. In fact, if the CTime object was
the only changed parameter, the result set does not change at all from the
initial query performed during the opening of the CRecordset.
<P>
<P><h2>CAUSE</h2>
 
<P>
The Microsoft Foundation Classes code fails to store the value of the CTime
object into the proxy buffer used to exchange data between the application
and the ODBC driver. The CRecordset code allocates a proxy, which is a
storage location for holding the parameter data to be used for the query. A
proxy is needed because ODBC drivers know nothing about converting
DATE/TIME/TIMESTAMP data to CTime objects. Instead, the ODBC drivers
convert the data to a TIMESTAMP_STRUCT and store this in the parameter
buffer (the proxy).
<P>
The RFX_Date() function typically handles the fixup for converting
TIMESTAMP_STRUCTs (the data in the proxy) to their corresponding CTime
variables. However, the RFX_Date() routine does not provide an RFX
operation for storing the CTime data into the proxy before doing a
Requery(). Therefore, the initial CTime variable is continually reused for
each Requery() call.
<P>
<P><h2>STATUS</h2>
 
<P>
Microsoft has confirmed this to be a bug in the Microsoft products
listed at the beginning of this article. This bug was corrected in
Visual C++ for Windows, version 1.51.
<P>
<P>
<P><h2>RESOLUTION</h2>
 
<P>
Below are two methods to work around this problem:
<P>
<P><h3>Method #1</h3>
 
<P>
The CRecordset class contains a function called BindParams() that
binds memory where the parameter data is stored and retrieved by the
ODBC driver. It creates the proxy area and stores the value of data
variables (in our case, the CTime object) into the proxy area. It is
called in CRecordset::Open(). This is why the first query is successful.
You can override Requery() and call BindParams() before calling
CRecordset::Requery(). For example:
<P>
BOOL CYourRecordset::Requery()
{
<P>
<PRE>    // code for cleaning up old proxies for parameters - otherwise
    // memory leak occurs
    if (m_pvParamProxy != NULL)
    {
        for (UINT nParam = 0; nParam != m_nParams; nParam++)
            delete m_pvParamProxy[nParam];
    }

    // Rebind parameters and store values in from variables to Proxies.
    BindParams(m_hstmt);
    return CRecordset::Requery();
</PRE>}
<P>
NOTE: Code was added to correct a memory leak that would have occurred by
calling BindParams(). The variable m_pvParamProxy is a member variable of
the CRecordset class, which stores a pointer to all the proxies for the
parameters used by the CRecordset.
<P>
<P><h3>Method #2</h3>
 
<P>
Method #1 is inefficient because it recalls an ODBC function to
rebind parameters. Also, the old proxies have to be deleted. This
second method is more efficient.
<P>
Create a new function in your class derived from CRecordset that stores the
value of the CTime object into the TIMESTAMP_STRUCT proxy. It should look
like the following:
<P>
<PRE>    void CYourRecordset::SetCTimeParam(CTime * pv, int nParam)
    {
        ASSERT (nParam&gt;0 &amp;&amp; nParam&lt;=m_nParams);

        TIMESTAMP_STRUCT * pts=
                     (TIMESTAMP_STRUCT *)m_pvParamProxy[nParam-1];

        pts-&gt;year = (short int)pv-&gt;GetYear();
        pts-&gt;month = (unsigned short int)pv-&gt;GetMonth();
        pts-&gt;day = (unsigned short int)pv-&gt;GetDay();
        pts-&gt;hour = (unsigned short int)pv-&gt;GetHour();
        pts-&gt;minute = (unsigned short int)pv-&gt;GetMinute();
        pts-&gt;second = (unsigned short int)pv-&gt;GetSecond();
        pts-&gt;fraction = 0;

    }

</PRE>The function takes a pointer to a CTime object and the number whose
parameter the CTime object represents.
<P>
Call this function before calling Requery() or override Requery() in
your CRecordset-derived class and then call the function within the
override. For example:
<P>
<PRE>    BOOL CYourRecordset::Requery()
    {
        SetCTimeParam(&amp;m_QueryDate,1);
        return CRecordset::Requery();
    }

    where m_QueryDate is a CTime variable and is the first parameter.

</PRE>Method #2 is faster than method #1 because the code simply stores the CTime
values into the TIMESTAMP_STRUCT proxy.
<P>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
Additional reference words: 1.50 2.50 ODBC<BR>
KBCategory: kbprg kbfixlist kbbuglist<BR>
KBSubcategory: MfcDatabase<BR>
Keywords          : kb16bitonly MfcDatabase kbbuglist kbfixlist kbprg<BR>
Technology        : kbMfc<BR>
Version           : 1.50<BR>
Platform          : WINDOWS<BR>
Solution Type     : kbfix<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  September 18, 1997</FONT>
	<BR>
	<A HREF="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
