

<HTML>
<HEAD>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>FIX: ASSERT in OLECLI1.CPP When Copying Embedding to Clipboard </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q152072">
<META NAME="KBModify" CONTENT="1997/09/19">
<META NAME="KBCreate" CONTENT="1996/06/03">
<META NAME="Keywords" CONTENT="MfcOLE kbbuglist kbfixlist kbole">
<META NAME="KBArea" CONTENT="Support; KB; visualc">
<META NAME="Description" CONTENT="  When you attempt to copy an embedding in an in-place active object to the clipboard, the result is an ASSERT in OLECLI1.CPP. Specifically, the ASSERT occurs in the COleClientItem::XOleClientSite::GetMoniker() function on the following line of code:...">
<META NAME="Product" CONTENT="Visual C++">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QAUD,QAGI,QAW6,QAH4,QAPN,QALW,QAIF,QAGX,QAY5,QAR4,QANH,QAFV,QA9N,QASB,QAKR V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>FIX: ASSERT in OLECLI1.CPP When Copying Embedding to Clipboard</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  September 19, 1997</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q152072</B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
1.50 1.51 1.52 | 2.00 2.10 2.20 4.00 4.10
<PRE>WINDOWS        | WINDOWS NT
</PRE>kbole kbbuglist kbfixlist
<P>
 
The information in this article applies to:

<UL><LI>The Microsoft Foundation Classes (MFC), included with:
   - Microsoft Visual C++ for Windows, versions 1.5, 1.51, 1.52
   - Microsoft Visual C++, 32-bit Edition, versions 2.0, 2.1, 2.2, 4.0, 4.1
</UL> 
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
When you attempt to copy an embedding in an in-place active object to the
clipboard, the result is an ASSERT in OLECLI1.CPP. Specifically, the ASSERT
occurs in the COleClientItem::XOleClientSite::GetMoniker() function on the
following line of code:
<P>
<PRE>   VERIFY(pThis-&gt;m_lpObject-&gt;SetMoniker(OLEWHICHMK_OBJREL,
          *ppMoniker)==S_OK);

</PRE><h2>CAUSE</h2>
 
<P>
When you copy an embedding to the clipboard, a number of data formats are
placed on the clipboard, including link source information. The link source
information contains a moniker used to locate the document in which the
embedding resides.
<P>
When the container assigns a moniker to an embedded object, it will call
the object's IOleObject::SetMoniker() function. The object will then call
the container's IOleClientSite::GetMoniker() function to construct a
composite moniker based on the container's moniker. This is done because
the container may have changed its moniker while the object was not
running.
<P>
When the embedded object calls IOleClientSite::GetMoniker() to get the
container's moniker, COleClientItem::XOleClientSite::GetMoniker() ASSERTs
on the aforementioned line of code because pThis-&gt;m_bMoniker had not been
set to TRUE when the moniker was assigned during a previous call to
COleClientItem::XOleClientSite::GetMoniker().
<P>
The problem is located in the following section of the
COleClientItem::XOleClientSite::GetMoniker() function located in
OLECLI1.CPP:
<P>
<PRE>   // notify the object of the assignment
   if (dwAssign != OLEGETMONIKER_TEMPFORUSER &amp;&amp;
       *ppMoniker != NULL &amp;&amp; !pThis-&gt;m_bMoniker)
   {
      VERIFY(pThis-&gt;m_lpObject-&gt;SetMoniker(
             OLEWHICHMK_OBJREL, *ppMoniker) == S_OK);
      pThis-&gt;m_bMoniker = TRUE;
      ASSERT_VALID(pThis-&gt;m_pDocument);
      pThis-&gt;m_pDocument-&gt;SetModifiedFlag();
   }

</PRE>The pThis-&gt;m_lpObject-&gt;SetMoniker() call results in the object calling
COleClientItem::XOleClientSite::GetMoniker() again. Because pThis-
&gt;m_bMoniker is being set after the pThis-&gt;m_lpObject-&gt;SetMoniker() call,
the subsequent call to pThis-&gt;m_lpObject-&gt;SetMoniker() returns with an
error code of E_FAIL, triggering the ASSERT.
<P>
<P><h2>RESOLUTION</h2>
 
<P>
To work around this problem, you must override the default IOleClientSite
interface implementation in COleClientItem. This can be done by adding an
interface map to the class in your project that is derived from
COleClientItem and setting pThis-&gt;m_bMoniker to TRUE before calling pThis-
&gt;m_lpObject-&gt;SetMoniker() from your custom GetMoniker() function.
<P>
The code below illustrates how to override the COleClientItem-derived
object using the OCLIENT MFC sample application.
<P>
<P><h2>STATUS</h2>
 
<P>
Microsoft has confirmed this to be a bug in the Microsoft products listed
at the beginning of this article. This bug was corrected in Visual C++ 32-
bit Edtion version 4.2.
<P>
<P><h3>MORE INFORMATION</h3>
 
<P>
<P><h3>Sample Code</h3>
 
<P>
<PRE>   // Code to be added to CRectItem class definition in RECTITEM.H
   class CRectItem : public COleClientItem
   {
      // ...original declarations in CRectItem class go here...

      // Interface Map
      BEGIN_INTERFACE_PART(OleClientSite2, IOleClientSite)
         STDMETHOD(SaveObject)();
         STDMETHOD(GetMoniker)(DWORD, DWORD, LPMONIKER*);
         STDMETHOD(GetContainer)(LPOLECONTAINER*);
         STDMETHOD(ShowObject)();
         STDMETHOD(OnShowWindow)(BOOL);
         STDMETHOD(RequestNewObjectLayout)();
      END_INTERFACE_PART(OleClientSite2)

      DECLARE_INTERFACE_MAP()
   };

   // XOleClientSite2 functions to be added to RECTITEM.CPP
   BEGIN_INTERFACE_MAP(CRectItem, COleClientItem)
      INTERFACE_PART(CRectItem, IID_IOleClientSite, OleClientSite2)
   END_INTERFACE_MAP()

   STDMETHODIMP_(ULONG) CRectItem::XOleClientSite2::AddRef()
   {
      METHOD_PROLOGUE_EX_(CRectItem, OleClientSite2)
      return pThis-&gt;ExternalAddRef();
   }

   STDMETHODIMP_(ULONG) CRectItem::XOleClientSite2::Release()
   {
      METHOD_PROLOGUE_EX_(CRectItem, OleClientSite2)
      return pThis-&gt;ExternalRelease();
   }

   STDMETHODIMP CRectItem::XOleClientSite2::QueryInterface(
      REFIID iid, LPVOID* ppvObj)
   {
      METHOD_PROLOGUE_EX_(CRectItem, OleClientSite2)
      return pThis-&gt;ExternalQueryInterface(&amp;iid, ppvObj);
   }

   STDMETHODIMP CRectItem::XOleClientSite2::SaveObject()
   {
      METHOD_PROLOGUE_EX(CRectItem, OleClientSite2)
      ASSERT_VALID(pThis);
      return pThis-&gt;m_xOleClientSite.SaveObject();
   }

   STDMETHODIMP CRectItem::XOleClientSite2::GetMoniker(
       DWORD dwAssign, DWORD dwWhichMoniker, LPMONIKER* ppMoniker)
   {
      METHOD_PROLOGUE_EX(CRectItem, OleClientSite2)
      ASSERT_VALID(pThis);

      USES_CONVERSION;  // note, must #include afxpriv.h

      COleDocument* pDoc = pThis-&gt;GetDocument();
      ASSERT_VALID(pDoc);
      ASSERT(ppMoniker != NULL);
      *ppMoniker = NULL;

      switch (dwWhichMoniker)
      {
      case OLEWHICHMK_CONTAINER:
         // return the current moniker for the document
         *ppMoniker = pDoc-&gt;GetMoniker((OLEGETMONIKER)dwAssign);
         break;

      case OLEWHICHMK_OBJREL:
         {
            if (!pDoc-&gt;IsKindOf(RUNTIME_CLASS(COleLinkingDoc)))
            break;

            // don't return relative moniker if no document moniker
            LPMONIKER lpMoniker = pDoc-
   &gt;GetMoniker((OLEGETMONIKER)dwAssign);
            if (lpMoniker == NULL)
               break;
            lpMoniker-&gt;Release();

            // relative monikers have to handle assignment correctly
            switch (dwAssign)
            {
               case OLEGETMONIKER_ONLYIFTHERE:
                  if (!pThis-&gt;m_bMoniker)
                     break;  // no moniker assigned, don't return one
                   // fall through...

               case OLEGETMONIKER_TEMPFORUSER:
               case OLEGETMONIKER_FORCEASSIGN:
                  {
                     // create item moniker from item name
                     TCHAR szItemName[OLE_MAXITEMNAME];
                     pThis-&gt;GetItemName(szItemName);
                     CreateItemMoniker(OLESTDDELIMOLE, T2COLE(szItemName),
                        ppMoniker);

                     // notify the object of the assignment
                     if (dwAssign != OLEGETMONIKER_TEMPFORUSER &amp;&amp;
                         *ppMoniker != NULL &amp;&amp; !pThis-&gt;m_bMoniker)
                     {
                        pThis-&gt;m_bMoniker = TRUE;
                        VERIFY(pThis-&gt;m_lpObject-&gt;SetMoniker(
                            OLEWHICHMK_OBJREL, *ppMoniker) == S_OK);
                        ASSERT_VALID(pThis-&gt;m_pDocument);
                        pThis-&gt;m_pDocument-&gt;SetModifiedFlag();
                     }
                  }
                  break;

               case OLEGETMONIKER_UNASSIGN:
                  pThis-&gt;m_bMoniker = FALSE;
                  break;
            }
         }
         break;

      case OLEWHICHMK_OBJFULL:
         {
            // get each sub-moniker: item &amp; document
            LPMONIKER lpMoniker1, lpMoniker2;
            GetMoniker(dwAssign, OLEWHICHMK_CONTAINER, &amp;lpMoniker1);
            GetMoniker(dwAssign, OLEWHICHMK_OBJREL, &amp;lpMoniker2);

            // create composite moniker
            if (lpMoniker1 != NULL &amp;&amp; lpMoniker2 != NULL)
                ::CreateGenericComposite(lpMoniker1, lpMoniker2,
   ppMoniker);

            // release sub-monikers
            RELEASE(lpMoniker1);
            RELEASE(lpMoniker2);
         }
         break;
      }
      return *ppMoniker != NULL ? S_OK : E_FAIL;
   }

   STDMETHODIMP CRectItem::XOleClientSite2::GetContainer(LPOLECONTAINER*
      ppContainer)
   {
   #ifdef _DEBUG
      METHOD_PROLOGUE_EX(CRectItem, OleClientSite2)
   #else
      METHOD_PROLOGUE_EX_(CRectItem, OleClientSite2)
   #endif
      ASSERT_VALID(pThis);
      return pThis-&gt;m_xOleClientSite.GetContainer(ppContainer);
   }

   STDMETHODIMP CRectItem::XOleClientSite2::ShowObject()
   {
      METHOD_PROLOGUE_EX(CRectItem, OleClientSite2)
      ASSERT_VALID(pThis);
      return pThis-&gt;m_xOleClientSite.ShowObject();
   }

   STDMETHODIMP CRectItem::XOleClientSite2::OnShowWindow(BOOL fShow)
   {
      METHOD_PROLOGUE_EX(CRectItem, OleClientSite2)
      ASSERT_VALID(pThis);
      return pThis-&gt;m_xOleClientSite.OnShowWindow(fShow);
   }

   STDMETHODIMP CRectItem::XOleClientSite2::RequestNewObjectLayout()
   {
      return E_NOTIMPL;
   }
</PRE>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
Additional reference words: 1.50 1.51 1.52 2.00 2.10 2.20 4.00 4.10 4.20<BR>
                            vcbuglist400 vcfixlist420<BR>
KBCategory: kbole kbbuglist kbfixlist<BR>
KBSubcategory: MfcOLE
<P>

<BR>
Keywords          : MfcOLE kbbuglist kbfixlist kbole<BR>
Technology        : kbMfc<BR>
Version           : 1.50 1.51 1.52 | 2.00 2.10 2.20<BR>
Platform          : NT WINDOWS<BR>
Solution Type     : kbfix<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  September 19, 1997</FONT>
	<BR>
	<A HREF="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
