

<HTML>
<HEAD>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>PRB: Add() Member Function Consuming Large Amount of Memory </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q122236">
<META NAME="KBModify" CONTENT="1997/07/31">
<META NAME="KBCreate" CONTENT="1994/11/01">
<META NAME="Keywords" CONTENT="MfcMisc kbprb kbprg kbtshoot">
<META NAME="KBArea" CONTENT="Support; KB; visualc">
<META NAME="Description" CONTENT="  After calling CStringArray::Add() many times, unusually large amounts of memory become allocated to the application and not freed until the application terminates. This behaviour may be seen in the other array collection classes such as CObArray an...">
<META NAME="Product" CONTENT="Visual C++">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QBW6,QAGI,QAHC,QAA8,QA9O,QAIF,QAGF,QADZ,QAKJ,QAI4,QBWP,QBFY,QA56,QA55,QAY5 V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>PRB: Add() Member Function Consuming Large Amount of Memory</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  July 31, 1997</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q122236</B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
<PRE>1.00 1.50 1.51   | 1.00 2.00 4.00
WINDOWS          | WINDOWS NT
</PRE>kbprg kbtshoot kbprb
<P>
 
The information in this article applies to:

<UL><LI>The  Microsoft Foundation Classes (MFC), included with:
<P>
<P><PRE>    - Microsoft Visual C++ for Windows, versions 1.0, 1.50, and 1.51
    - Microsoft Visual C++, 32-bit Edition, versions 1.0, 2.0, and 4.0
      on the following platform(s): x86
</UL></PRE> 
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
After calling CStringArray::Add() many times, unusually large amounts of
memory become allocated to the application and not freed until the
application terminates. This behaviour may be seen in the other array
collection classes such as CObArray and CPtrArray as well.
<P>
<P><h2>CAUSE</h2>
 
<P>
Each time a call to Add() is made, the array may grow. Memory needs to be
allocated to accommodate the new size of the array. The array is copied to
the new block of memory and the old memory is freed for re-use. The Visual
C++ run-time heap allocator doesn't return freed memory to the system but
instead marks the memory block as unused so that it can re-use the memory
later.
<P>
For each call to Add() that causes the array to be re-allocated, the old
block is marked as unused. The sections marked as unused won't get re-used
by the next call to Add() because the array is too large to fit into the
unused section. Other allocations (such as the CString) prevent adjacent
free unused blocks of memory from being combined into a bigger block of
unused memory.
<P>
<P><h2>RESOLUTION</h2>
 
<P>
A developer using an array data structure typically knows the size of the
array before allocating memory for it. However, if you don't know the size,
you must re-allocate the array as it grows. This means that a new memory
block must be allocated and the data from the old memory block must be
copied to the new block before the old memory block is freed. This can cost
time.
<P>
To work around the problem, call the member function SetSize() with the
approximate size of the array. If you are uncertain about the size of the
array, minimize the amount of memory reallocations by specifying a larger
size to allow room to grow. The first parameter to SetSize() allows you to
change the size of the array and the second parameter allows you to change
the grow size. For example:
<P>
<PRE>   CStringArray array;
      array.SetSize(100,100);

</PRE>Here the array will be allocated an original 100 elements. When the 100
elements have been used and Add() is called for the 101st element, the
array memory block will be reallocated to handle an additional 100 elements
for a total of 200 elements.
<P>
Alternatively, SetSize(0, 100) would cause the initial size for the array
to be zero and an Add() would have to be done before any elements could be
filled. This first Add() in this scenario would cause 100 elements to be
allocated for use by the array.
<P>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
Additional reference words: 1.00 1.50 1.51 2.00 2.10 2.50 3.00 4.00<BR>
fragment leak heap<BR>
KBCategory: kbprg kbtshoot kbprb<BR>
KBSubcategory: MfcMisc<BR>
Keywords          : MfcMisc kbprb kbprg kbtshoot<BR>
Technology        : kbMfc<BR>
Version           : 1.00 1.50 1.51   | 1.00 2.00 4.0<BR>
Platform          : NT WINDOWS<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  July 31, 1997</FONT>
	<BR>
	<A HREF="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
