

<HTML>
<HEAD>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Pointer Arithmetic Wraps Around Segment Ends </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q58987 ">
<META NAME="KBModify" CONTENT="1997/07/17">
<META NAME="KBCreate" CONTENT="1990/02/23">
<META NAME="Keywords" CONTENT="kb16bitonly">
<META NAME="KBArea" CONTENT="Support; KB; visualc">
<META NAME="Description" CONTENT="  In Microsoft C and C++, when you increment or decrement a pointer beyond a segment boundary, the offset of the pointer will wrap around the end. For example, if the pointer is sitting at FFFF and you increment it by 1 (one), the resulting value of ...">
<META NAME="Product" CONTENT="Visual C++">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QBFY,QAO2,QAO3,QA6Y,QAB4,QAPF,QASR,QAN2,QAIA,QAEF,QDMW,QDL9,QBWQ,QBWO,QBWN V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>Pointer Arithmetic Wraps Around Segment Ends</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  July 17, 1997</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q58987 </B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
5.10 6.00 6.00a 6.00ax 7.00 | 5.10 6.00 6.00a 7.00 | 1.00 1.50 1.51
<PRE>MS-DOS                      | OS/2                 | WINDOWS
</PRE>kbprg
<P>
 
The information in this article applies to:
The Microsoft C/C++ Compiler (CL.EXE), included with:
<UL><LI>Microsoft C for MS-DOS, versions 5.1, 6.0, 6.0a, and 6.0ax
<LI>Microsoft C for OS/2, versions 5.1, 6.0, and 6.0a
<LI>Microsoft C/C++ for MS-DOS, version 7.0
<LI>Microsoft Visual C++ for Windows, versions 1.0, 1.5, and 1.51
</UL> 
<P>
<P><h2>SUMMARY</h2>
 
<P>
In Microsoft C and C++, when you increment or decrement a pointer beyond a
segment boundary, the offset of the pointer will wrap around the end. For
example, if the pointer is sitting at FFFF and you increment it by 1 (one),
the resulting value of the offset is 0000. This wraparound behavior is
expected behavior in all memory models except huge. The example below
demonstrates the "hidden" wraparound.
<P>
<P><h2>MORE INFORMATION</h2>
 
<P>
The C language permits writing beyond array boundaries and heap
allocations. Consequently, C compilers do not generate warning or
error messages if an index or pointer goes out of bounds. It is up to
the programmer to monitor indices and pointers.
<P>
If you have an array that is larger than 64K, use the huge keyword or
compile in the huge memory model. Pointer arithmetic for huge data is
performed on the full 32 bits of segment and offset address.
<P>
<P><h3>Sample Code</h3>
 
<P>
<PRE>/* Compile options needed: none
*/

#include &lt;stdio.h&gt;
#include &lt;dos.h&gt;
#include &lt;malloc.h&gt;

void main (void)
</PRE>{
<PRE> char *ptr;

 ptr = (char*) malloc (100);
 printf ("\nSegment is %u, offset is %u\n", FP_SEG(ptr), FP_OFF(ptr));

 FP_OFF(ptr) = 0x0000;
 printf ("\nSegment is %u, offset is %u\n", FP_SEG(ptr), FP_OFF(ptr));
 ptr--;
 printf ("\nSegment is %u, offset is %u\n", FP_SEG(ptr), FP_OFF(ptr));

 FP_OFF(ptr) = 0xFFFF;
 printf ("\nSegment is %u, offset is %u\n", FP_SEG(ptr), FP_OFF(ptr));
 ptr++;
 printf ("\nSegment is %u, offset is %u\n", FP_SEG(ptr), FP_OFF(ptr));
</PRE>}
<P>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
Additional reference words: kbinf 1.00 1.50 6.00 6.00a 6.00ax 7.00 8.00<BR>
8.00c<BR>
KBCategory: kbprg<BR>
KBSubcategory: CLngIss<BR>
Keywords            : kb16bitonly<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  July 17, 1997</FONT>
	<BR>
	<A HREF="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
