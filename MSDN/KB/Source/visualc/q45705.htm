

<HTML>
<HEAD>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Reasons for a 128K Limit on Huge Arrays and halloc()s </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q45705 ">
<META NAME="KBModify" CONTENT="1997/07/17">
<META NAME="KBCreate" CONTENT="1989/06/13">
<META NAME="Keywords" CONTENT="kb16bitonly">
<META NAME="KBArea" CONTENT="Support; KB; visualc">
<META NAME="Description" CONTENT="  In Microsoft C , halloc() and huge arrays are limited to allocating 128K unless the size of the elements is a power of 2.  MORE INFORMATION  With huge pointers and arrays, the Microsoft C Compiler produces 32- bit pointer arithmetic only when acces...">
<META NAME="Product" CONTENT="Visual C++">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QAIB,QBFY,QABN,QBE7,QBE6,QBVV,QAO3,QAO2,QAY4,QAHF,QAUD,QALQ,QAK0,QADX,QBW7 V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>Reasons for a 128K Limit on Huge Arrays and halloc()s</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  July 17, 1997</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q45705 </B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
5.10 6.00 6.00a 6.00ax 7.00 | 5.10 6.00 6.00a | 1.00 1.50
<PRE>MS-DOS                      | OS/2            | WINDOWS
</PRE>kbprg
<P>
 
The information in this article applies to:

<UL><LI>The C Run-time (CRT), included with:
<P>
<P><PRE>    - Microsoft C for MS-DOS, versions 5.1, 6.0, 6.0a, and 6.0ax
    - Microsoft C for OS/2, versions 5.1, 6.0, and 6.0a
    - Microsoft C/C++ for MS-DOS, versions 7.0
    - Microsoft Visual C++ for Windows, versions 1.0 and 1.5
</UL></PRE> 
<P>
<P><h2>SUMMARY</h2>
 
<P>
In Microsoft C , halloc() and huge arrays are limited to allocating 128K
unless the size of the elements is a power of 2.
<P>
<P><h2>MORE INFORMATION</h2>
 
<P>
With huge pointers and arrays, the Microsoft C Compiler produces 32-
bit pointer arithmetic only when accessing whole elements. Only the
16-bit offset of a pointer is used when accessing the individual
members of elements. This technique is used in the interest of speed
and smaller code size. However, it assumes that elements do not extend
from the end of one segment into the beginning of the next. When
crossing a 64K segment boundary, elements must end evenly with the end
of that segment. The following diagram illustrates the conditions
necessary for huge pointers and arrays:
<P>
<PRE>                             Seg1 Seg2
     Segment 1               FFFF 0000               Segment 2
     ----------------------------+----------------------------
    ......| Elem | Elem  | Elem  + Elem  | Elem  | Elem  |.....
    ......| X     | X+1  | X+2   + X+3   | X+4   | X+5   |.....
     ----------------------------+----------------------------
                                 ^ Elements must not cross
                                   a segment boundary.

</PRE>If an element's size is not a power of 2, an array of that element
will not fit evenly into a 64K segment. This is the root of the 128K
limitation. To avoid breaking an element across a segment boundary in
this case, extra space is left at the beginning of the first segment,
pushing the entire array upwards in memory so that the element before
the one that would have spanned the segment boundary ends exactly at
the end of the segment. The element that would have spanned the
segment boundary is pushed to the beginning of the second segment.
<P>
If the allocated elements do not fit evenly into a segment, there can
be only one segment boundary onto which they fall evenly. The function
halloc() uses the element size it is passed to calculate and return a
pointer with an offset that results in the allocated elements falling
evenly on this boundary. The following diagram demonstrates the way
this is done and what can happen at the end of the second segment:
<P>
<PRE>        Segment 1                     Segment 2
        0000           FFFF 0000           FFFF
     +----------------------+-------------------+
     +Pad |Elem |Elem |Elem +Elem |Elem |Elem | +
     +----------------------+-------------------+
      ^   ^                                   ^
      ^   ^                                   Next element won't fall
      ^   ^                                   on segment bounds.
      ^   ^
      ^   Offset returned to allow elements to fall on segment bounds.
      ^
      Padding area used to force element boundary to fall on segment
      boundary.

</PRE>These restrictions should also be considered when allocating memory
for very large elements. For example, a request for three 33K
structures will fail. Two of the structures could be allocated, but
since each would go into a separate segment, neither of the segments
would contain enough space for the third element.
<P>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
Additional reference words: kbinf 5.10 6.00 6.00a 6.00ax 7.00 1.00 1.50 64K<BR>
KBCategory: kbprg<BR>
KBSubcategory: CRTIss<BR>
Keywords            : kb16bitonly<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  July 17, 1997</FONT>
	<BR>
	<A HREF="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
