

<HTML>
<HEAD>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>How to Pass a Far Pointer from Parent to Spawned Child </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q40774 ">
<META NAME="KBModify" CONTENT="1997/07/17">
<META NAME="KBCreate" CONTENT="1989/01/28">
<META NAME="Keywords" CONTENT="kb16bitonly">
<META NAME="KBArea" CONTENT="Support; KB; visualc">
<META NAME="Description" CONTENT="  The best way to pass a pointer from a parent process to a child is to convert the pointer to an ASCII string using sprintf(), spawn the child with the string on the command line, and convert the string back to a pointer with sscanf(). Below is a sa...">
<META NAME="Product" CONTENT="Visual C++">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QAD7,QAH7,QAH6,QATX,QAO3,QAO2,QBFY,QAVK,QAY2,QAUJ,QAPN,QAH4,QAB4,QBQU,QBVV V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>How to Pass a Far Pointer from Parent to Spawned Child</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  July 17, 1997</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q40774 </B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
6.00 6.00a 6.00ax 7.00 | 6.00 6.00a | 1.00 1.50
<PRE>MS-DOS                 | OS/2       | WINDOWS
</PRE>kbprg
<P>
<P>
 
The information in this article applies to:

<UL><LI>Microsoft C for MS-DOS, versions 6.0, 6.0a, and 6.0ax
<LI>Microsoft C for OS/2, versions 6.0 and 6.0a
<LI>Microsoft C/C++ for MS-DOS, version 7.0
<LI>Microsoft Visual C++ for Windows, versions 1.0 and 1.5
</UL> 
<P>
<P><h2>SUMMARY</h2>
 
<P>
The best way to pass a pointer from a parent process to a child
is to convert the pointer to an ASCII string using sprintf(), spawn
the child with the string on the command line, and convert the string
back to a pointer with sscanf(). Below is a sample program that does
this. Note that the program and the child process must be compiled
separately. Be sure to pass a far (segment and offset) pointer rather
than a near (offset only) pointer. Attempting to pass a near pointer
will not work.
<P>
<P><h2>MORE INFORMATION</h2>
 
<P>
It is also possible to leave the pointer in an agreed-upon memory
area. Sometimes unused interrupt vectors are used for this purpose
under DOS. Microsoft does not recommend this method because it could
cause conflicts with other software using the same memory. The method
described above is much safer.
<P>
<P><h3>Sample Code</h3>
 
<P>
Compile the following two programs separately. Be sure to name the
child process MAIN2.EXE, or change the name in the spawnlp() call in
the parent process to match your name.
<P>
<P><h3>Parent Process</h3>
 
<P>
<PRE>/* Compile options needed: /AL
*/

#include &lt;process.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;signal.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
char buffer[80];            /* buffer to be passed to child */
char ascptr[20];            /* holds ASCII version of ptr.  */

void main(void)
</PRE>{
<PRE>int ret;

                            /* initial string */
    strcpy(buffer, "Main1");
    printf("Beginning main1...\nString is:  %s\n", buffer);

                            /* convert address to ASCII */
    sprintf(ascptr, "%p", buffer);
    printf("ASCII version of pointer is: %p\nSpawning main2...\n\n",
            ascptr);

                            /* spawn, passing ASCII address on
                               command line */
    ret = spawnlp(P_WAIT, "main2.exe", "main2", ascptr, NULL);
    printf("\nBack to main1--spawnlp returned %d\n", ret);

                            /* Show that string is changed */
    printf("String is now:  %s\nAll done", buffer);
    exit(0);
</PRE>}
<PRE>/* end of program number one*/


</PRE><h3>Child Process</h3>
 
<P>
<PRE>/* Compile options needed: /AL

</PRE>be sure to name this MAIN2.EXE (main2.c)
<PRE>*/

#include &lt;process.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;signal.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;ctype.h&gt;

char far *ptrstuff;

void main(int argc, char **argv)
</PRE>{
<PRE>int ch;

    printf("In main2:  argv[1] is %s\n", argv[1]);
    if (argc != 2) {        /* error in argument list */
        printf("Error in argument list to main2\n");
        exit(1);
    }

                            /* retrieve pointer value from string */
    sscanf(argv[1], "%p", &amp;ptrstuff);
    printf("\nPointer is actually set to:  %p\n", ptrstuff);

                            /* check to see that it's right */
    printf("Pointer points to: %s\n", ptrstuff);

                            /* change string (CAREFULLY!!!!!) */
    printf("Warning:  modifying the string incorrectly could hang "
           "your system...\n");
    printf("\007Should I modify this string? ");
    ch = getchar();
    if (toupper(ch) == 'Y')  {
        strcpy(ptrstuff, "2nd main");
        printf("Changed string to: %s\n", ptrstuff);
    }
    else printf("String not changed....\n");

    printf("Exiting main2...\n");
    exit(0);
</PRE>}
<P>
<PRE>/* end of child process */
</PRE>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
Additional reference words: kbinf 6.00 6.00a 6.00ax 7.00 1.00 1.50<BR>
KBCategory: kbprg<BR>
KBSubcategory: CRTIss<BR>
Keywords            : kb16bitonly<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  July 17, 1997</FONT>
	<BR>
	<A HREF="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
