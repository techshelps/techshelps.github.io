

<HTML>
<HEAD>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>FIX: CLongBinary Causes "Invalid String or Buffer Length" </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q156134">
<META NAME="KBModify" CONTENT="1997/09/19">
<META NAME="KBCreate" CONTENT="1996/09/17">
<META NAME="Keywords" CONTENT="MfcDatabase vcbuglist400 vcfixlist500 kbprg">
<META NAME="KBArea" CONTENT="Support; KB; visualc">
<META NAME="Description" CONTENT="  When updating CLongBinary data using CRecordset::Update(), you may receive the error  Invalid string or buffer length.   CAUSE =====  MFC's RFX_LongBinary function uses an obsolete method to specify the size of the field when binding the CLongBinar...">
<META NAME="Product" CONTENT="Visual C++">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QAMB,QAH4,QBXT,QA5V,QAKD,QAIB,QAXB,QAEF,QART,QA9E,QAYY,QAR4,QAC1,QBD2,QATX V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>FIX: CLongBinary Causes "Invalid String or Buffer Length"</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  September 19, 1997</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q156134</B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
 
The information in this article applies to:

<UL><LI>The Microsoft Foundation Classes (MFC), included with:
   Microsoft Visual C++, 32-bit Edition, versions 4.0, 4.1, 4.2
</UL> 
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
When updating CLongBinary data using CRecordset::Update(), you may receive
the error "Invalid string or buffer length."
<P>
<P><h2>CAUSE</h2>
 
<P>
MFC's RFX_LongBinary function uses an obsolete method to specify the size
of the field when binding the CLongBinary buffer for the update. MFC
specifies that the length of the long binary field is SQL_DATA_AT_EXEC, a
symbol that signifies that data is transferred via SQLPutData() without
providing any information about the field's size.
<P>
The following is true according to the documentation for SQLExecDirect
(Problems and Information) in the ODBC SDK 2.10 Release Notes, included
with VC++ 4.1:
<P>
<PRE>   SQLSTATE S1090 (Invalid string or buffer length):
   A parameter length value bound by SQLBindParameter was set to
   SQL_DATA_AT_EXEC; the SQL type was either SQL_LONGVARCHAR,
   SQL_LONGVARBINARY, or a long, data-source specific data type; and the
   SQL_NEED_LONG_DATA_LEN information type in SQLGetInfo was "Y."

</PRE>The 32-bit Intersolve 2.11 Oracle 7 ODBC driver for NT and Windows 95
returns this error, which may also be returned by other ODBC drivers
that meet the above criteria.
<P>
<P><h2>RESOLUTION</h2>
 
<P>
To avoid this error, you can modify MFC to use the SQL_LEN_DATA_AT_EXEC()
macro that provides information about the size of the data and thereby
allows the driver to perform the update.
<P>
<P><h2>STATUS</h2>
 
<P>
Microsoft has confirmed this to be a bug in the Microsoft products listed
at the beginning of this article. This bug was corrected in Visual C++
version 5.0.
<P>
<P><h2>MORE INFORMATION</h2>
 
<P>
The following steps detail one method of making the needed changes in
RFX_LongBinary:

<OL><P><LI>Copy the implementation of RFX_LongBinary() (Msdev\Mfc\Src\Dbrfx.cpp)
   into a new .cpp file, and rename the function to something like
   RFX_LongBinary2(). Create a header file for the .cpp file and include
   that in your recordset .cpp file. Be sure to #include "stdafx.h" at
   the top of your new .cpp file and include the .cpp file in your
   project.

<P><LI>Change all RFX_LongBinary() calls in your recordset's DoFieldExchange()
   to calls to RFX_LongBinary2().

<P><LI>In your new RFX_LongBinary2() implementation, copy the following code
   that appears under "case CFieldExchange::SetFieldNull":
<P>
<P><PRE>      // Length is signed value, it's limited by LONG_MAX
      if (value.m_dwDataLength &gt;
<PRE></PRE>          (ULONG)(LONG_MAX - labs(SQL_LEN_DATA_AT_EXEC_OFFSET)))
      {
         ASSERT(FALSE);
         *plLength = LONG_MAX - labs(SQL_LEN_DATA_AT_EXEC_OFFSET);
      }
      else
         *plLength = value.m_dwDataLength;

      *plLength = SQL_LEN_DATA_AT_EXEC(*plLength);

   Paste this code over the line that contains SQL_DATA_AT_EXEC in the
   following code, which appears under "case CFieldExchange::Value":

      {
         // Indicate data will be sent after SQLExecute
         *plLength = SQL_DATA_AT_EXEC;       &lt;&lt; REPLACE THIS LINE
      }

   This causes the macro to be used instead of the constant.

</PRE><P><LI>In the CFieldExchange::SetFieldNull case, you can simply comment out
   the conditional that currently causes the macro to be used only in
   those cases where m_bUseUpdateSQL is FALSE. Comment out a total of five
   lines as noted below:
<P>
<PRE>     if (pFX-&gt;m_prs-&gt;m_bUseUpdateSQL)      // COMMENT OUT THIS LINE
        *plLength = SQL_DATA_AT_EXEC;      // COMMENT OUT THIS LINE
     else                                  // COMMENT OUT THIS LINE
     {                                     // COMMENT OUT THIS LINE
        // Length is signed value, it's limited by LONG_MAX
        if (value.m_dwDataLength &gt;
            (ULONG)(LONG_MAX - labs(SQL_LEN_DATA_AT_EXEC_OFFSET)))
        {
           ASSERT(FALSE);
           *plLength = LONG_MAX - labs(SQL_LEN_DATA_AT_EXEC_OFFSET);
        }
        else
           *plLength = value.m_dwDataLength;

        *plLength = SQL_LEN_DATA_AT_EXEC(*plLength);
     }                                     // COMMENT OUT THIS LINE

</PRE></OL><h2>REFERENCES</h2>
 
<P>
ODBC Programmer's Reference
ODBC SDK 2.10 Release Notes
<P>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
Additional query words: Intersolv Oracle
<P>

Keywords          : MfcDatabase vcbuglist400 vcfixlist500 kbprg<BR>
Technology        : kbMfc<BR>
Version           : 4.0 4.1 4.2<BR>
Platform          : NT WINDOWS<BR>
Solution Type     : kbfix<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  September 19, 1997</FONT>
	<BR>
	<A HREF="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
