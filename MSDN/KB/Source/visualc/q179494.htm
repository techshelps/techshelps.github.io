

<HTML>
<HEAD>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>HOWTO: Use Automation to Retrieve Built-In Document Properties </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q179494">
<META NAME="KBModify" CONTENT="1998/02/06">
<META NAME="KBCreate" CONTENT="1998/01/19">
<META NAME="Keywords" CONTENT="MfcOLE kbcode kbinterop">
<META NAME="KBArea" CONTENT="Support; KB; visualc">
<META NAME="Description" CONTENT="  This article discusses how to use version 4.2 of the Microsoft Foundation Class (MFC) library installed with Microsoft Visual C++ version 5.0 to find and print the built-in document properties of a Microsoft Word 97 document. The built-in document ...">
<META NAME="Product" CONTENT="Visual C++">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QAPN,QAH4,QAIH,QAVX,QAVW,QAG8,QAUJ,QAL3,QBQU,QABA,QAKD,QAHE,QACI,QA9N,QAY2 V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>HOWTO: Use Automation to Retrieve Built-In Document Properties</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  February 6, 1998</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q179494</B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
 
The information in this article applies to:

<UL><LI>The Microsoft Foundation Classes (MFC) included with:
   - Microsoft Visual C++, 32-bit Editions, version 5.0
<LI>Microsoft Word 97 for Windows
</UL> 
<P>
<P><h2>SUMMARY</h2>
 
<P>
This article discusses how to use version 4.2 of the Microsoft Foundation
Class (MFC) library installed with Microsoft Visual C++ version 5.0 to find
and print the built-in document properties of a Microsoft Word 97 document.
The built-in document properties include the document's title, subject,
author, keywords, comments, template, dates, number of pages, words,
characters and many other properties.
<P>
<P><h2>MORE INFORMATION</h2>
 
<P>
You can copy the code in this article to the message handler function of an
event defined in an MFC .cpp file. However, the purpose of the code is to
illustrate the process of using the IDispatch interfaces and member
functions defined in the MSWord8.olb type library. The primary benefit
comes from reading and understanding the code in the example so that you
can modify the example, or write code from scratch to automate finding and
printing a list of the built-in document properties.
<P>
<P><h3>Steps to Create the Project</h3>
 

<OL><P><LI>In Microsoft Word, create a new document named Test.doc.

<P><LI>Follow steps 1 through 12 in the following Microsoft Knowledge Base
   article to create a sample project that uses the IDispatch interfaces
   and member functions defined in the MSWord8.olb type library:
<P>
<P><PRE>      ARTICLE-ID: <B><A HREF="../VISUALC/Q178749.htm">Q178749</A></B>
<PRE></PRE>      TITLE     : HOWTO: Create an Automation Project Using MFC and a
                  Type Library

</PRE><P><LI>At the top of the AutoProjectDlg.cpp, add the following line:
<P>
<P><PRE>      #include "MSWord8.h"
</PRE>
<P><LI>Add the following code to CAutoProjectDlg::OnRun() in the
   AutoProjectDlg.cpp file.
<P>
   Sample Code
   -----------
<P>
<P><PRE>      _Application objWordApp;
      _Document objDoc;
      LPDISPATCH lpDisp;
      Range objRange;
      // Common OLE variants that are easy to use for calling arguments.
      COleVariant covTrue((short)TRUE),
<PRE></PRE>                  covFalse((short)FALSE),
                  covOptional((long)DISP_E_PARAMNOTFOUND, VT_ERROR);

      objWordApp.CreateDispatch("Word.Application");
      objWordApp.SetVisible(TRUE);

      Documents docs(objWordApp.GetDocuments());

      lpDisp = docs.Open(COleVariant("C:\\Test.doc",VT_BSTR),
                                          covFalse,    // Confirm.
                                                       // Conversion.
                                          covFalse,    // ReadOnly.
                                          covFalse,    // AddToRecentFiles.
                                          covOptional, // NULL,
                                                       // PasswordDocument.
                                          covOptional, // PasswordTemplate.
                                          covFalse,    // Revert.
                                          covOptional, // Write-
                                                       // PasswordDocument.
                                          covOptional, // Write-
                                                       // PasswordTemplate.
                                          covOptional  // Format.
                                          );

       objDoc.AttachDispatch(lpDisp);
       lpDisp = objDoc.GetContent();
       objRange.AttachDispatch(lpDisp);

       // Move the insertion point to the beginning of the document.
       objRange.Collapse(COleVariant((long)1));  //0 = wdCollapseEnd.
       objRange.InsertAfter("Here are the BuiltInDocumentProperties!!");
       objRange.InsertParagraphAfter(); // Write them one-by-one in a loop.
       lpDisp = objDoc.GetBuiltInDocumentProperties();

       COleDispatchDriver rootDisp[64];  // Temporary object array.
       int curRootIndex = 0;             // Index into rootDisp[] array.
       DISPID dispID;                    // Temporary dispid for use in
                                         // OleDispatchDriver::
                                         // InvokeHelper().
       DISPID dispID2;                   // Dispid for 'Value'.
       unsigned short *ucPtr;            // Temporary name holder for
                                         // IDispatch::GetIDsOfNames().
       VARIANT vtResult;                 // Holds results from
                                         // OleDispatchDriver::
                                         // InvokeHelper().
       VARIANT vtResult2;                // Holds result for 'Type'.
       BYTE *parmStr;                    // Holds parameter descriptions
                                         // for COleDispatchDriver::
                                         // InvokeHelper().
       rootDisp[0].AttachDispatch(lpDisp);  // LPDISPATCH returned from
                                         // GetBuiltInDocumentProperties.
       VARIANT i;                        // integer;
       VARIANT count;                    // integer;
       char buf[512];                    // General purpose message buffer.
       char buf2[512];

       ucPtr = L"Count";                 // Collections have a Count
                                         // member.

       try
       {
        rootDisp[curRootIndex].m_lpDispatch-&gt;GetIDsOfNames(
                                                IID_NULL,
                                                &amp;ucPtr,
                                                1,
                                                LOCALE_USER_DEFAULT,
                                                &amp;dispID);


        rootDisp[curRootIndex].InvokeHelper(dispID,
                                           DISPATCH_METHOD |
                                           DISPATCH_PROPERTYGET,
                                           VT_VARIANT,
                                           (void *)&amp;vtResult,
                                           NULL);

        count = vtResult;  // Require a separate variable for loop limiter.
        // For i = 1 to count,
        // get the Item, Name &amp; Value members of the collection.
        i.vt = VT_I4;
        for(i.lVal=1; i.lVal&lt;=count.lVal; i.lVal++)
        {
         ucPtr = L"Item";  // Collection has an Item member.
         rootDisp[curRootIndex].m_lpDispatch-&gt;GetIDsOfNames(
                                                IID_NULL,
                                                &amp;ucPtr,
                                                1,
                                                LOCALE_USER_DEFAULT,
                                                &amp;dispID);


         parmStr = (BYTE *)( VTS_VARIANT );
         rootDisp[curRootIndex].InvokeHelper(dispID,
                                            DISPATCH_METHOD |
                                            DISPATCH_PROPERTYGET,
                                            VT_VARIANT,
                                            (void *)&amp;vtResult,
                                            parmStr,
                                            &amp;COleVariant(i));

         // Move to the next element of the array.
         // Get the Name member for the Item.
         rootDisp[++curRootIndex].AttachDispatch(vtResult.pdispVal);
         ucPtr = L"Name";  // Collection has a Name member
         rootDisp[curRootIndex].m_lpDispatch-&gt;GetIDsOfNames(
                                                IID_NULL,
                                                &amp;ucPtr,
                                                1,
                                                LOCALE_USER_DEFAULT,
                                                &amp;dispID);

         rootDisp[curRootIndex].InvokeHelper(dispID,
                                            DISPATCH_METHOD |
                                            DISPATCH_PROPERTYGET,
                                            VT_VARIANT,
                                            (void *)&amp;vtResult,
                                            NULL);

          ucPtr = L"Value";  // Collection has a Value member.
          rootDisp[curRootIndex].m_lpDispatch-&gt;GetIDsOfNames(
                                            IID_NULL,
                                            &amp;ucPtr,
                                            1,
                                            LOCALE_USER_DEFAULT,
                                            &amp;dispID2);

          rootDisp[curRootIndex].InvokeHelper(dispID2,
                                            DISPATCH_METHOD |
                                            DISPATCH_PROPERTYGET,
                                            VT_VARIANT,
                                            (void *)&amp;vtResult2,
                                            NULL);
       Continue: // Come back here from Catch(COleDispatchException).

         rootDisp[curRootIndex--].ReleaseDispatch();

         // Initialize buf2 with representation of the value.
         switch(vtResult2.vt) // Type of property.
         {
          case VT_BSTR:
            sprintf(buf2, "%s", (CString)vtResult2.bstrVal);
            break;
          case VT_DATE:
          {
            COleDateTime codt(vtResult2.date);
            sprintf(buf2, "Time = %d:%02d, Date = %d/%d/%d",
              codt.GetHour(), codt.GetMinute(),
              codt.GetMonth(), codt.GetDay(), codt.GetYear()
               );
          }
            break;
          case VT_I4:
            sprintf(buf2, "%ld", vtResult2.lVal);
            break;
          default:
            sprintf(buf2, "not VT_BSTR, VT_DATE, or VT_I4");
         }  // End of Switch.

         sprintf(buf, "Item(%d).Name = %s, .Type = %d, .Value = %s\n",
                i.lVal, CString(vtResult.bstrVal), vtResult2.vt, buf2);

         objRange.Collapse(COleVariant((long)0));  // Move insertion point
                                                   // to end of the range.
         objRange.InsertAfter(CString(buf));  // Insert after the insertion
                                              // point.

        }  ////////////////// End of For loop. ///////////////////////

        objRange.InsertParagraphAfter(); // Spacing.
        objRange.InsertAfter("");
        objRange.InsertParagraphAfter(); // Spacing.

        // Release IDispatch pointers on local objects.
        if(vtResult.vt == VT_DISPATCH) vtResult.pdispVal-&gt;Release();
        if(count.vt == VT_DISPATCH) count.pdispVal-&gt;Release();
        rootDisp[0].ReleaseDispatch();

        AfxMessageBox("All done, waiting...");
        objDoc.SetSaved(TRUE);  // Hides the "Save your changes..." dialog.
        AfxMessageBox("Word will close now. Goodbye");

        objWordApp.Quit(covFalse, covFalse, covFalse);

       }  // End try.

       catch(COleException *e)
       {
        sprintf(buf, "COleException. SCODE: %08lx.", (long)e-&gt;m_sc);
        ::MessageBox(NULL, buf, "COleException", MB_SETFOREGROUND | MB_OK);
       }

       catch(COleDispatchException *e)
       {
         if(vtResult2.vt ==VT_ERROR)
         {
           AfxMessageBox("Discarding vtResult2.VT_ERROR");
         }
         vtResult2.vt = VT_BSTR;
         vtResult2.bstrVal = L"Value not available";
         goto Continue;
       }

       catch(...)
       {
        MessageBox( "General Exception caught.", "Catch-All",
        MB_SETFOREGROUND | MB_OK);
       }

       //////////////////// For information only. /////////////////////
       //          Do not uncomment the following code snippet.          //
       //  You can copy it and use it in lieu of the previous code when  //
       //             you need to see just one property.                 //
       /***************** Code to get a single property. *****************
       // Works for one property.
       COleDispatchDriver myDocumentProperties(lpDisp);
       COleVariant result;
       // Get myDocumentProperties.Item(1).
       // Item(n) where n = property index
       // value in properties collection.
       UCHAR *parmStr = (BYTE *)( VTS_VARIANT );
       myDocumentProperties.InvokeHelper(0, DISPATCH_METHOD |
                                         DISPATCH_PROPERTYGET,
                                         VT_VARIANT,
                                         (void *)&amp;result,
                                         parmStr,
                                         &amp;COleVariant((long)1));

       COleDispatchDriver myDocumentProperty(result.pdispVal);

       // Get Name of this document property.
       myDocumentProperty.InvokeHelper(3, DISPATCH_METHOD |
                                          DISPATCH_PROPERTYGET,
                                          VT_VARIANT,
                                          (void *)&amp;result,
                                          NULL);

       AfxMessageBox(CString("Item(1).Name =") + CString(result.bstrVal));

       // Release this document property.
       myDocumentProperty.ReleaseDispatch();

       // Release the document properties collection.
       myDocumentProperties.ReleaseDispatch();
       //*************** End of code for single property. ****************/


</PRE><P><LI>You may need to modify the code in CAutoProjectDlg::OnRun() to indicate
   the correct path for your document Test.doc. The document is referenced
   in the following line:
<P>
<P><PRE>      lpDisp = docs.Open(COleVariant("C:\\Test.doc",VT_BSTR),
<P></BLOCKQUOTE>
</OL>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
Additional query words: word 8.0 word8 word97 ole automation<BR>
Keywords          : MfcOLE kbcode kbinterop<BR>
Technology        : kbmfc;kbole<BR>
Version           : win95:5.0;winnt:5.0<BR>
Platform          : Win95 winnt<BR>
Issue type        : kbhowto<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  February 6, 1998</FONT>
	<BR>
	<A HREF="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
