

<HTML>
<HEAD>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SAMPLE: MFCAXS Implements an Active Script Host Using MFC </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q168214">
<META NAME="KBModify" CONTENT="1998/01/19">
<META NAME="KBCreate" CONTENT="1997/05/07">
<META NAME="Keywords" CONTENT="AXSDKSripting MfcOLE kbsample">
<META NAME="KBArea" CONTENT="Support; KB; ie_dev">
<META NAME="Description" CONTENT="  MfcAxscrVb is an instructional sample Active Scripting host written using MFC. It hosts the VBScript DLL; however, the Active Scripting mechanisms are generic to any Active Scripting engine. MfcAxscrVb shows just one possible way to provide dispatc...">
<META NAME="Product" CONTENT="Internet Explorer (Programming)">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QAPN,QDNQ,QAW6,QAB5,QAO4,QALQ,QAH4,QAY2,QDN1,QAEF,QAPF,QBVR,QAM2,QALH,QABO V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>SAMPLE: MFCAXS Implements an Active Script Host Using MFC</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  January 19, 1998</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q168214</B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
 
The information in this article applies to:

<UL><LI>Microsoft Internet Explorer (Programming), versions 3.01, 3.02, 4.0,
   4.01
<LI>Microsoft Visual Basic, Scripting Edition, versions 1.0, 1.1, 2.0
<LI>The Microsoft Foundation Classes (MFC) included with:
   - Microsoft Visual C++, 32-bit Editions, version 5.0
</UL> 
<P>
<P><h2>SUMMARY</h2>
 
<P>
MfcAxscrVb is an instructional sample Active Scripting host written using
MFC. It hosts the VBScript DLL; however, the Active Scripting mechanisms
are generic to any Active Scripting engine. MfcAxscrVb shows just one
possible way to provide dispatch objects from the host, to implement the
host's Active Scripting interfaces, and to connect the messages of windows
in the host with events fired to the scripting engine.
<P>
MfcAxscrVb includes a Visual C++ 5.0 workspace and project file. Although
no VC++ 4.2 compatible makefile or mdpfile is provided, the source code for
MfcAxscrVb is compatible with MFC 4.2b.
<P>
Prerequisites: COM, Automation
<P>
The following file is available for download from the Microsoft
Software Library:
<P>
<PRE> ~ <A HREF="http://support.microsoft.com/download/support/mslfiles/Mfcaxs.exe">Mfcaxs.exe</A> <I>(size: 148749 bytes)</I> 

</PRE>For more information about downloading files from the Microsoft Software
Library, please see the following article in the Microsoft Knowledge Base:
<P>
<PRE>   ARTICLE-ID: <B><A HREF="../zMiscellaneous/Q119591.htm">Q119591</A></B>
   TITLE     : How to Obtain Microsoft Support Files from Online Services

</PRE><h2>MORE INFORMATION</h2>
 
<P>
<P><h2>Running the Sample</h2>
 
<P>
When you run the MfcAxscrVb sample you will notice a large edit control in
the upper left-hand corner of the application. You can paste or type script
into this window and select the "Run Script" button to invoke the script.
Several test scripts are provided for you in the Script.txt and
Testevents.txt files.
<P>
<P><h2>Exposing the Host: Dispatch Objects</h2>
 
<P>
The main focus for this sample is the implementation of dispatch objects
using MFC. The reason for this is simple. A scripting language isn't much
use if there isn't anything to script.
<P>
The core technology upon which all Active Scripting depends is most
certainly that of Automation. A solid working knowledge of Automation is
absolutely necessary before attempting to code any Active Scripting host.
There are several good references for Automation: chapters 14 and 15 of
Brockshmidt's "Inside OLE," chapter 11 of Dale Rogerson's "Inside COM," and
the "OLE Automation Programmer's Reference."
<P>
<P><h3>What is CCmdTargetPlus?</h3>
 
<P>
What you need are some objects that allow for scriptable properties and
methods through IDispatch but also generate scriptable events. MFC
definitely does most of the grunt work for you when implementing dispatch
interfaces for a COM object. However, the only MFC class that supports both
incoming dispatch interfaces and outgoing dispatch interfaces, or event
sinks, is COleControl. COleControl is much too bulky for what you want. You
just want events, a dispatch interface, and type information. VBScript
needs to read type information for dispatch objects that support events.
You could either create this on the fly, or create a static type library
for your host's dispatch objects and obtain the ITypeInfo for each
individual object.
<P>
While probably not necessary, MfcAxscrVb has a base class called
CCmdTargetPlus that supports these three pieces: dispatch interface,
connection points with a control-style event map, and easily accessible
type information through IProvideClassInfo. Most of the code in
CmdTargetPlus was added to allow for event maps, which makes adding events
to derived classes much easier.
<P>
<P><h3>Dispatch Objects</h3>
 
<P>
All host-provided dispatch objects are implemented using CCmdTargetPlus.
There are a few things they need to do to work well. Refer to any of the
dispatch objects (CAButtonDispatch, CBButtonDispatch, and so forth) for a
boilerplate on what is necessary. A brief rundown on MfcAxscrvb's object
model is listed at the end of this document.
<P>
If you add your own objects, be sure to double-check for three unique GUIDs
for the primary dispatch and primary events interfaces, and for the clsid
for the object in sum. This needs to be done in the implementation file and
in the .odl file. (Cut and Paste helps here.) Cut and paste all of the
class wizard macros, and then change them to the new class name. Class
Wizard is very particular, but if you follow everything just right in the
.odl, .h, and .cpp files, you can use it to add new events, properties, and
methods to your dispatch object as if it were an MFC OLE Control. This is
sort of handy.
<P>
MfcAxscrVb keeps the object implementing the dispatch mechanisms separate
from the MFC object, which it is actually referring to. For example, the
dialog box has a button called the "AButton," which is scriptable. The MFC
button object is CButton. The CCmdTargetPlus-derived class,
CAButtonDispatch, is separate and distinct. This is a key point. Only what
the host programmer explicitly chooses to expose for basic MFC objects and
Windows controls will be scriptable.
<P>
<P><h3>CEventsButton, CEventsEdit, CEventsListBox</h3>
 
<P>
For events, there needs to be some code that responds to a Windows event--
say, a button click--and generates an event for the script engine.
(Remember an event is a dispatch Invoke on an interface handled by
connection points in the host object.) This sample accomplishes this by
adding standard MFC message handlers into objects derived from the various
classes. Each of these handlers merely has to call FireEvent (courtesy of
the code added to CCmdTargetPlus) on the dispatch object. Everything else
happens automatically.
<P>
Because the dispatch object and the actual MFC window object are separate
in this sample, the dialog parent needs to explicitly hook the two
together. This is done in the Mfcaxscrvbdlg constructor.
<P>
<P><h2>Named Items</h2>
 
<P>
Once you have dispatch objects, you have to set them up so that the script
engine knows about them. The collection of all the named dispatch objects
that the script engine knows about is called the "Script Namespace." Items
are added to the script namespace through the IActiveScript::AddNamedItem
method. As I mentioned previously, it is the host's duty to implement an
IDispatch for the object and support type-information through ITypeInfo for
the object. When the script engine needs to resolve a reference to a named
item, it uses the IActiveScriptSite::GetItemInfo method to request an
IUnknown pointer (which it queries mainly for IDispatch) and an ITypeInfo
pointer.
<P>
Not everything that a host wants to be scriptable needs to be a named item.
Usually the host will have a hierarchy of objects, where sub-objects are
accessible through a higher-level object. A common metaphor is the
Application-&gt;Document-&gt;Item hierarchy, where the Document object is
accessible from the top-level Application object as an IDispatch property
of the Application object itself. In the same manner, the Document object
itself exposes several sub-objects and each is an Item that you can obtain
through an Item array or other contrivance.
<P>
Using this scheme, the scripting engine is smart enough to navigate to a
sub-item when the script code says the following without needing Document
or Item to be added to the script namespace:
<P>
<PRE>   Set Obj = Application.Document.Item(1)

</PRE>As long as the sub-objects are exposed as get-properties of their parent
object, the script engine finds them successfully. Interestingly enough,
the script engine is able to "assume" the top-level item in the hierarchy.
What this means is that if Application is declared as the top-level item,
then it is sufficient to say the following for the prior script code:
<P>
<PRE>   Set Obj = Document.Item(1)

</PRE>This is exactly how Internet Explorer 3.0 allows you to script code in the
context of the Window object without always prefixing all references to
objects with "Window." A script host needs to identify the top-level script
item in the call to AddNamedItems by using the SCRIPTITEM_GLOBALMEMBERS
flag. What usually isn't made clear by Active Scripting documentation,
however, is that only named items can support events. Using the above
example, there is no syntax to say the following to handle an event in a
particular item:
<P>
<PRE>   Sub Application.Document.Item(1)_OnEvent ' this doesn't work!

</PRE>So, for MfcAxscrvbdlg, because we want to be able to handle the events of
every object in the hierarchy, every object is added as a Named Item. Each
object is also accessible through the top-level Scripter object (the dialog
itself), which does not support events currently.
<P>
<P><h3>WebBrowser Control</h3>
 
<P>
In this sample, the script host exposes only one external object to the
script namespace. This is the WebBrowser control hosted on the dialog by
MFC's default control containment support. All you need is an AddRef'd
dispatch pointer to the control, and you're set. For events, the external
object needs to expose an ITypeInfo pointer somehow. MfcAxscrVb gets this
through IProvideClassInfo::GetClassInfo. As a last resort, a host could
read the object's type-information itself to expose an ITypeInfo.
Fortunately, the WebBrowser control supports GetClassInfo, so MfcAxscrVb
doesn't do this.
<P>
If you wanted to add other external automation objects to the namespace,
all that usually is necessary is to obtain an IUnknown interface using
CoCreateInstance. Alternatively, the host can support a generic means for
obtaining external objects, albeit ones that don't need to have events
handled. In VB, the function to do this is called CreateObject.
<P>
<P><h2>Getting to Other Apps: HostCreateObject</h2>
 
<P>
Other than the set of properties used to expose all of the child objects,
the main Scripter object (the dialog class itself) exposes only one special
method. This method demonstrates a simple means for simulating VB's
CreateObject function. Note that the method is named HostCreateObject to
emphasize that this method is not provided for free by the script engine,
but the host must implement it itself. Some hosts clearly would not want to
provide this ability for security reasons, IE3 is a prime example. The
primary goal of HostCreateObject is to return the dispatch pointer of the
requested object. Once the scripting engine has the dispatch pointer, it
knows what to do from there.
<P>
NOTE: As of version 2.0, the VBScript and JScript engines now support
CreateObject as a built-in function. The host does not need to implement
this function. This function will, however, test an object to make sure it
is safe for scripting before allowing the object to be used. Objects deem
themselves safe for scripting by either supporting the IObjectSafety
interface or marking the appropriate Component Category registry entries
for Safe-For-Scripting. Refer to the Microsoft Knowledge Base for more
information.
<P>
<P><h2>Class Wizard Support</h2>
 
<P>
The last little bit of trickery in MfcAxscrVb is the manipulations made to
support ClassWizard. Class Wizard, technically isn't "dumb." It is just
mentally challenged. It is pretty convenient for what it does, but remember
that it just blindly searches files looking for those special ClassWizard
comments. If you follow the format for COleControl, you can just about get
away with using ClassWizard's Automation and Events tabs.
<P>
One complication is that MfcAxscrVb uses derivation in some of its object
hierarchy. All of the button objects are derived from a common
CButtonDispatch object that exposes properties and methods, all of which it
would individually support. However, when it comes time to fill out the
.odl file, each individual object needs to contain all of the properties
and methods of the parent class. Needless to say, this is going to confuse
Class Wizard when it comes time to number the DISPIDs. If you use Class
Wizard, make sure you double-check the generated DISPIDs in two places: the
.odl file for the automation class and the enumeration inside the class
definition. When working with the derived button classes, it is easy to see
the same DISPID assigned to multiple properties and methods. It is much
easier to correct the DISPIDs, though, than to add everything by scratch,
so the functionality has been left in MfcAxscrVb.
<P>
<P>
With Visual C++ 5.0's improved support of IDL methods and properties
through ClassView, it's a toss up whether ClassWizard is needed or not. But
MfcAxscrVb supports it for now. Enjoy.
<P>
<P><h2>Appendix A: Object Model</h2>
 
<P>
<P><h3>Scripter</h3>
 
<P>
This is the master object from which all other objects are derived. It is
"IMfcaxscrvbDlg" in the .odl file but is added as the Named Item
"Scripter." It has one method, HostCreateObject, which is described above.
<P>
<P><h3>Button Objects</h3>
 
<P>
AButton BButton, CancelButton, OKButton, RunScript
<P>
Properties:

<UL><LI>Caption - text of button face
<P>
</UL>Methods:

<UL><LI>Press - acts as if the button were pushed
<P>
</UL>Events:

<UL><LI>OnClick - fired when button is pushed

<LI>OnMouseOver - fired when mouse rolls over button
<LI>OnFocus(bSet) - fired when focus is given or taken from button
<P>
</UL><h3>BroCon</h3>
 
<P>
BroCon is the name of the WebBrowser control on the dialog box. It supports
all properties and methods as documented in the Internet Client SDK/ActiveX
SDK for the WebBrowser control.
<P>
<P><h3>EditCon</h3>
 
<P>
Methods:

<UL><LI>AppendLine(strToAdd) - adds strToAdd to end of edit text window
<LI>InsertLine(strToAdd, nWhere) - adds strToAdd at line #nWhere
<LI>RemoveLine(nWhere) - removes line # nWhere from edit window
<P>
</UL>Events:

<UL><LI>OnMouseOver - fired when mouse rolls over window
<LI>OnChar(strChar) - fired when character strChar is entered into window
<LI>OnFocus(bSet) - fired when focus is given or taken from button
<P>
</UL><h3>LBox</h3>
 
<P>
Methods:

<UL><LI>AddString(strIn) - adds StrIn into list box
<LI>ClearList - clears all strings from list box
<LI>RemoveString(strRemove) - removes first instance of StrRemove and
   removes it from list box
<LI>SelectString(strSelect) - selects string specified by strSelect
<P>
</UL>Events:

<UL><LI>OnMouseOver - fired when mouse rolls over window
<LI>OnFocus(bSet) - fired when focus is given or taken from button
<LI>OnSelCancel(strCancelled) - When selection is cancelled in a list box
   element strCancelled
<LI>OnSelChange(strChange) - When a list box element strChange is selected
   by the user
</UL> 
<PRE>Keywords          : AXSDKSripting MfcOLE kbsample
Technology        : kbMfc kbInetDev
Version           : 1.0 1.1 2.0 3.0 5.00
Platform          : NT WINDOWS
Solution Type     : kbfile</PRE>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
================================================================================<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  January 19, 1998</FONT>
	<BR>
	<A HREF="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
