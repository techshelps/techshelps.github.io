

<HTML>
<HEAD>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Contents of the FoxPro for MS-DOS GETLESS.TXT File </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q108323">
<META NAME="KBModify" CONTENT="1995/04/18">
<META NAME="KBCreate" CONTENT="1993/12/08">
<META NAME="Keywords" CONTENT="kbreadme">
<META NAME="KBArea" CONTENT="Support; KB; foxpro, crossnet, odbc">
<META NAME="Description" CONTENT="  Below is the complete FoxPro for MS-DOS GETLESS.TXT file. By default, this file is installed in the FOXPRO25\GOODIES\FNDATION subdirectory in FoxPro 2.5. In FoxPro version 2.0, it is installed by default in the FOXPRO2\GOODIES\FNDATION subdirectory...">
<META NAME="Product" CONTENT="Visual FoxPro">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QBFN,QAPN,QDL9,QBWQ,QBWO,QBWN,QAGB,QAUD,QAYZ,QAGQ,QAJH,QAH4,QBXS,QAJQ,QBVV V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>Contents of the FoxPro for MS-DOS GETLESS.TXT File</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  April 18, 1995</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q108323</B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
The information in this article applies to:

<UL><LI>Microsoft FoxPro for MS-DOS, versions 2.0, 2.5, 2.5a, 2.5b
</UL> 
<P>
<P><h2>SUMMARY</h2>
 
<P>
Below is the complete FoxPro for MS-DOS GETLESS.TXT file. By default, this
file is installed in the FOXPRO25\GOODIES\FNDATION subdirectory in FoxPro
2.5. In FoxPro version 2.0, it is installed by default in the
FOXPRO2\GOODIES\FNDATION subdirectory.
<P>
NOTE: This file contains eight questions about the EX1.APP application and
how it implements a foundation READ. The answers to these questions are in
the GETANS.TXT file. Both the EX1.APP and GETANS.TXT files are located in
the same subdirectory as the GETLESS.TXT files.
<P>
<P><h2>MORE INFORMATION</h2>
 
<P>
<PRE>                -------------------------------------
                Coordinating Windows, Menus, and READ
                -------------------------------------


</PRE>This note explains our thinking on new MODAL and associated window
concepts. It also introduces some minor improvements in FoxPro which are
available starting with Beta 4b.
<P>
<P><h3>Event Loop Programming</h3>
 
<P>
In order to produce applications with event-driven interfaces like FoxPro's
own interface, some sophisticated developers have resorted to event loop
programming similar to that utilized inside FoxPro itself and in
environments like the Macintosh and Windows.
<P>
We feel that coding a real event loop in the FoxPro language has very
limited practicality for three reasons. First, the speed of the resulting
application will be sub-optimal. Second, such an application is always in
hard execution and, therefore, a CPU hog and unfriendly in multiprogramming
environments like DESQview, Windows, or the Mac MultiFinder. Finally, such
event loop programming is VERY complex conceptually, probably too complex
for all but the most skilled developers and certainly inaccessible to
beginners.
<P>
That event loop programming was ever needed is, in fact, evidence of
inadequate documentation and an incomplete original design. That event loop
programming ever worked at all is testimony to the ingenuity and skill of
you developers.
<P>
Improvements have been made in FoxPro version 2.0 so that event loop
programming should almost never be required.
<P>
<P><h3>Single READ Interactions (with Multiple Windows)</h3>
 
<P>
With FoxPro version 2.0 it is very easy to incorporate many windows into a
single READ. FoxPro handles virtually all aspects of coordinating windows
containing GETs with other windows -- notably BROWSE and text editing
windows -- more or less automatically.
<P>
Our general recommendation is that a single READ should correspond to a
single interactive session, dedicated to a particular objective, regardless
of the number of windows involved. For example, a single READ might be
used for customer file maintenance, entering invoices and associated detail
lines, entering hours worked into a payroll application, etc. If desired,
such single READ interactions can include access to desk accessories,
BROWSE windows, etc. Moreover, it's possible to restrict access to other
windows as desired by use of the MODAL clause in conjunction with the WITH
clause.
<P>
The overall application structure which is most obvious and easiest to
implement is to use traditional hierarchical menus, buttons, or other
controls to invoke a series of single READ interactions which accomplish
the application's objectives. This approach is generally recommended and
produces applications which may have many lovely, object oriented, multi-
window, event driven features, but which are traditional in overall
architecture.
<P>
<P><h3>Programming Single READ Interactions</h3>
 
<P>
The basic idea is to encompass in a single READ all the windows that you
intend to interact with at a particular READ level. READ MODAL simply means
that the user is prevented from interacting with windows not included in
READ's cooperating set of windows. You will not be able to close, zoom,
minimize, or move windows not involved in a READ MODAL. Also, if BEEP is
SET ON, it'll beep when you click on a forbidden window.)
<P>
You can now control actions taken when windows are brought forward solely
by use of the READ's ACTIVATE and DEACTIVATE clauses. The basic change was
in DEACTIVATE.
<P>
Formerly, DEACTIVATE would attempt to prevent windows from coming forward
if the DEACTIVATE expression returned .F. Also, bringing a window forward
which was not one of the READ windows would terminate the READ.
<P>
This behavior (a) didn't generally work, (b) created insurmountable bugs,
and (c) made it very difficult to coordinate BROWSE and other windows with
READ in a controlled manner. (Upon reflection, you'll note that forcing
termination of a READ when a non-READ window was brought forward is what
actually forced you to write your own event loops in the first place.)
<P>
In addition, this odd behavior could not be emulated under Windows or on
the Mac. Here's what READ does now:
<P>
<PRE>READ MODAL      Windows which aren't specified as part of the READ or
                as an associated window can't be brought forward or
                interacted with in any way. Noting this difference,
                the following applies...

READ            When a window containing GETs is active and you click
                on a new window or select one with the keyboard:

                a. The new window is brought forward, and then

                b. The DEACTIVATE function is evaluated.

                At the time the DEACTIVATE function is evaluated,
                WONTOP() returns the new top window's name and WLAST()
                returns the name of the window formerly on top. Note,
                if you don't want to permit the new window to come on
                top just

                   ACTIVATE WINDOW (WLAST())

                in your DEACTIVATE function. (Note the name expression.)

                The value returned by the DEACTIVATE function answers
                the question "Shall the READ be terminated": .T.
                terminates it and .F. doesn't. You could, of course,
                always return .T. and emulate the old behavior.

                Finally, if a new window remains on top after the
                DEACTIVATE clause is executed, and if it's a window
                containing GETs, its ACTIVATE function is evaluated.

</PRE>Note that in this deceptively simple change, lies the key to easily
coordinating BROWSE and other windows within a READ. The 'Clients' part of
the sample 'Organize' application illustrates the use of these new
constructs.
<P>
We'll upload a project named INV (to Library 2) which utilizes the tutorial
databases to demonstrate how two BROWSE windows can be coordinated with a
READ. Please index DETAIL.DBF on INO and PARTS.DBF on PNO before trying to
run it.
<P>
By the way, none of the above is incompatible with your FoxPro 1.02
applications. If a READ contains no new 2.0 clauses and it's a single-
window READ, it's terminated when another window is brought forward. Of
course, the Screen Builder generates READ CYCLE by default, which triggers
the new behavior.
<P>
<P><h3>Coordinating Multiple READs</h3>
 
<P>
Now let's discuss how to coordinate multiple (possibly multi-window) READs
in an application. It is actually possible to create applications which are
as modeless and fluid as FoxPro's own interface.
<P>
From the interface point of view, it is entirely possible to write
completely event-driven applications, applications where you can switch
from one interactive session to another simply by clicking on the desired
window. However, the constraints of your application will almost certainly
dictate some limitations. For example, you can't permit updates to your
general ledger in the midst of printing your balance sheet, you can't
permit checks to be printed in the midst of calculating your payroll, etc.
<P>
Also even though we've tried to make it as simple as possible, completely
event driven programming remains conceptually complex. You will want to
approach this area with care, starting with modest objectives.
<P>
For example, a good approach might be to start by permitting, say,
customers to be added, zip codes to be looked up, etc. in the midst of
posting orders just by pointing at the appropriate window and clicking. In
other words, pick a few of your single-READ interactions and permit them to
interoperate just like FoxPro's own interface does. See the examples
provided for illustrations of how to accomplish this.
<P>
Eventually, the sophisticated developers among you will doubtless develop
templates to automate or semi-automate this process.
<P>
<P><h3>Improvements in FoxPro</h3>
 
<P>
a. A READ with no GETs may now have a VALID clause. Such a READ will be
<PRE>   called either a "GET-less" or "Foundation" READ. The rationale for the
   term "Foundation" should become clear below. Such a VALID clause is
   triggered by any event which would otherwise terminate the READ. If the
   VALID returns .T. the READ terminates, if it returns .F. the READ
   continues.

</PRE>b. When a GET-less READ having a VALID clause is executing, menus now
<PRE>   remain accessible.

</PRE>c. GET-less READs are now terminated in two ways:
<P>
<PRE>   1. Mouse clicks or keystrokes NOT associated with menu selection or
      activating an OKL.

      Note that selecting items from a menu or executing an OKL routine,
      specifically DOES NOT automatically terminate a GET-less READ. Also,
      if a menu is activated but no selection is made, the READ is not
      terminated.

   2. In addition, GET-less READs are terminated whenever an immediate
      child READ terminates (not a grandchild READ).

      More precisely, if a READ at RDLEVEL() terminates, and if the READ at
      RDLEVEL()-1 is GET-less, the Foundation READ is terminated after the
      child READ has been shut down.

      This is *almost* what used to happen. The difference is that,
      formerly, ANY keystroke or mouse click terminated a GET-less READ.

</PRE>d. When a window containing GETs which is involved in the current READ is
<PRE>   closed, either via the Window menu or the mouse, the window is
   deactivated and hidden, but not released. This permits triggering of
   both the VALID and DEACTIVATE clauses, first VALID then DEACTIVATE.
   Within these clauses it is as if CTRL+W had been pressed. Formerly,
   closing any window involved in the current READ would immediately and
   unconditionally terminate the READ.

</PRE>e. GENSCRN now emits code which does NOT redefine windows if they already
<PRE>   exist. A new generator directive, #REDEFINE, has been added which causes
   GENSCRN to emit old-style code, i.e. so windows are always redefined
   whether or not they already exist.

</PRE>f. GENSCRN has also been modified so, if a required DBF is already open
<PRE>   when the SPR is executed, its current file position is left unchanged.
   If you always want to start at the top of the file, code 'GO TOP' in
   your setup code.

</PRE>g. WONTOP(), WLAST(), WOUTPUT() and similar functions which are used to
<PRE>   check window attributes, have been modified so they now return .F. if
   they are called with an argument naming a non-existent window. Formerly,
   they generated an error and this necessitated circumlocutions like:

      IF WEXIST("fred") and WONTOP("fred")

</PRE>h. A new function WREAD([&lt;window&gt;]) has been provided. This function
<PRE>   returns .T. if the named window is included in the currently executing
   READ and .F. otherwise. If no argument is coded, WONTOP() is assumed.
   That is 'WREAD()' is the same as 'WREAD(WONTOP())'.

</PRE>i. READKEY() now accepts an optional argument of 1 which causes it to
<PRE>   return more specific information about why a READ has been terminated.
   The specific termination codes returned by READKEY(1) are:

      1   None of the following causes
      2   CLEAR READ caused termination
      3   A terminating control (like a push button) was
          selected
      4   A READ window was closed
      5   The DEACTIVATE clause returned .T.
      6   The READ timed out

</PRE>j. The maximum number of nested READs has been increased to 5.
<P>
<P><h3>EX1: Event-Driven Example #1</h3>
 
<P>
The first example is called 'EX1'. It demonstrates coordination of four
different READ interactions, each of which use the 'control3' control
panel. You can switch from one to the other just by clicking on the
application window.
<P>
Applications are launched by use of the 'Application' menu. Execution of
the entire system can be terminated by use of the 'Exit' option in the
<PRE>'Application' menu.

</PRE>This example has been designed so you can utilize any available desk
accessories or windows in conjunction with the application windows: Help,
Filer, Calculator, Calendar/Diary, ASCII Chart, Special Characters, and
Puzzle, editor windows, the project window, etc.
<P>
Before you attempt to write your own multi-READ event driven code, we
recommend you carefully study EX1 and be certain you can answer the
following questions about its operation:

<OL><P><LI>What would happen if the menu handling routine always immediately
   launched the requested application, regardless of RDLEVEL()?

<P><LI>Why is it necessary to specify the 'IN EX1.MPR' clause in the menu
   command in the 'Application' menu?

<P><LI>Where is the code that handles the situation where an application window
   is closed manually either by clicking in its close box, or by selecting
<PRE>   'Close' from the 'File' menu?

</PRE><P><LI>What's the largest number of READs which are ever active at any one time
   while EX1.APP is executing?

<P><LI>What insures that the control panel vanishes when the last remaining
   application window is closed?

<P><LI>If you bring, say, the Calculator up on top of an application window, is
   the application READ still active? The Foundation READ?

<P><LI>When you're executing EX1.APP and neither an application window nor the
   control panel is visible, and you're using, say, the Filer, is there any
   READ active?

<P><LI>When you're running in an application window and you click in another,
   how is control transferred from the first application to the new one?
   What event triggers the transfer?
<P>
</OL>If you can answer all the above questions, you're ready to proceed to the
next example. (We'll post the answers later.)
<P>
<P><h3>EX2: Event-Driven Example #2</h3>
 
<P>
This example is rather similar to EX1, but replaces the single invoice
editing screen with the 'INV' application that, besides editing the invoice
file, includes a different control panel 'control2' and two (2) BROWSE
windows coordinated as part of the READ.
<P>
Study EX2 carefully and you'll see that the changes required to handle this
rather more complex situation were rather simple. If you can answer the 8
questions above about EX1, you should have no difficulty with EX2. And by
now, you should have a general idea how to proceed in your own
applications.
<P>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
Additional reference words: FoxDos 2.00 2.50 2.50a 2.50b<BR>
KBCategory: kbreadme<BR>
KBSubcategory:<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  April 18, 1995</FONT>
	<BR>
	<A HREF="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
