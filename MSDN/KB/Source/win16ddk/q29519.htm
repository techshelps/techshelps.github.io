

<HTML>
<HEAD>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>How to Write a Driver for a Custom Hardware Device </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q29519 ">
<META NAME="KBModify" CONTENT="1996/08/05">
<META NAME="KBCreate" CONTENT="1988/04/29">
<META NAME="Keywords" CONTENT="kbprg kbcode kbwebcontent">
<META NAME="KBArea" CONTENT="Support; KB; win16ddk">
<META NAME="Description" CONTENT="  This article describes how to manage custom communications hardware through an I/O interrupt.  To implement a device that is intended to replace one of the standard devices in Windows, obtain the Windows DDK from Microsoft and write the device driv...">
<META NAME="Product" CONTENT="Win16 DDK">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QADN,QAHC,QAB5,QDL9,QBWO,QBWN,QAU9,QAHB,QA7R,QBWQ,QAGI,QAEF,QAM1,QA5W,QAH4 V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>How to Write a Driver for a Custom Hardware Device</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  August 5, 1996</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q29519 </B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
The information in this article applies to:

<UL><LI>Microsoft Windows Device Development Kit (DDK) for Windows
   versions 3.0, 3.1
</UL> 
<P>
<P><h2>SUMMARY</h2>
 
<P>
This article describes how to manage custom communications hardware through
an I/O interrupt.
<P>
To implement a device that is intended to replace one of the standard
devices in Windows, obtain the Windows DDK from Microsoft and write the
device driver to the appropriate specification. The DDK contains
definitions of keyboard, mouse, display, communications, printer, and
network drivers. The rest of this article discusses how to implement a
driver for a device, such that the implemented driver does not replace a
standard driver.
<P>
Windows version 3.1 includes an installable driver interface, which allows
these types of drivers to be loaded during Windows initialization, coalesce
messages they generate, and get notification of when standard or real mode
Windows swaps them out of memory. For more information on installable
drivers, please refer to Chapter 25 of the "Programmer's Reference, Volume
1: Overview" of the Windows SDK version 3.1. There is also a technical
article on installable drivers in the Microsoft Developer Network (MSDN)
CD-ROM.
<P>
<P><h2>MORE INFORMATION</h2>
 
<P>
Define a driver interface for the device and implement it in a dynamic
linked library (DLL). To handle interrupts, place the interrupt handler in
a FIXED DLL code segment. Any data accessed by the driver's interrupt
handler must also be in a FIXED data segment. The interrupt handler may not
make any Windows API calls except for calling the PostMessage function,
which is defined to be reentrant and callable from an interrupt handler for
just this purpose.
<P>
Note that, to interact properly with the kernel memory manager, the default
data segment of the DLL should be movable if the DLL will make calls to any
Windows APIs. Therefore, the interrupt data is usually in a separate
segment.
<P>
Because the segment is FIXED, it will be page locked in enhanced mode.
Also, it will not move in real mode. Therefore, the selector to the
interrupt data segment may be legally referenced when it is stored in code,
even in real mode.
<P>
For example, a simple interrupt handler could resemble the following:
<P>
<PRE>    WM_DEVICENOTIFY EQU WM_USER + some number

    inthandler proc far

        push    ds
        push    ax
        mov     ax, _INTDATA
        mov     ds, ax
        assume ds:_INTDATA

        ... Process the interrupt at the device, and do the
        ... appropriate things to the interrupt controller.
        ... For this example, assume that an event type is in CX,
        ... which will be the wParam parameter of the posted message.
        ... Data could also be stored to a buffer or reading data
        ... from one. This buffer, or its selector, is stored in
        ... _INTDATA as well. This function cannot call GlobalLock,
        ... therefore the buffer must be fixed (and page locked in
        ... enhanced mode) and its actual segment or selector stored
        ... in _INTDATA.

        push    [hwndNotify]    ;; Stored in _INTDATA segment
        mov     ax, WM_DEVICENOTIFY
        push    cx
        sub     ax, ax
        push    ax              ;; NULL for lParam unless the driver has
        push    ax              ;; something more interesting...
        call    PostMessage

        ... pop other registers

        pop     ax
        pop     ds
        assume ds:nothing
        iret

    inthandler endp

</PRE>The device driver should export an API to set the window that will
receive the notification messages (typically a "DeviceOpen()" function).
The window procedure for the window receiving notification will
process the driver-defined message WM_DEVICENOTIFY.
<P>
In enhanced mode, a VxD (virtual device driver) should be written if
any of the following conditions exist:

<UL><LI>The device processes a lot of data or generates a lot of
   interrupts.
<P>
   -or-

<LI>The timing of interrupt processing requires low interrupt latency.
<P>
   -or-

<LI>Many I/O instructions are required to manage the device.
<P>
</UL>A VxD is a 32-bit flat-model device driver that runs at ring 0, allowing
much faster response time to interrupts and lower overhead I/O. Windows
DLLs run at a lower protection ring, which requires interrupts to be
reflected from the 32-bit WIN386.EXE to the Windows driver, and slows down
I/O instructions. A VxD can interact with a Windows driver or application
by providing protected mode call-ins, which allows Windows code to call the
VxD. For more information on writing a VxD, see the Windows DDK.
<P>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
Additional reference words: 3.00 3.10<BR>
KBCategory: kbprg kbcode kbwebcontent<BR>
KBSubcategory: D2MiscInt<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  August 5, 1996</FONT>
	<BR>
	<A HREF="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
