

<HTML>
<HEAD>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SAMPLE: Helper Functions to Add Event Support to Server </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q159041">
<META NAME="KBModify" CONTENT="1996/11/13">
<META NAME="KBCreate" CONTENT="1996/11/09">
<META NAME="Keywords" CONTENT="kbole kbfile">
<META NAME="KBArea" CONTENT="Support; KB; oleprog">
<META NAME="Description" CONTENT="  The Eventh.exe sample provides helper functions that allow easy implementation of event-handling support in a COM server. It also provides a COM server that uses these functions and a COM client that uses the server.  You can find Eventh.exe, which...">
<META NAME="Product" CONTENT="OLE (Programming)">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT="OLE ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QAPN,QAO4,QAPF,QBC9,QBC8,QANO,QARL,QAI5,QAY5,QBWP,QAW6,QAB5,QAH4,QBV8,QBBS V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>SAMPLE: Helper Functions to Add Event Support to Server</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  November 13, 1996</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q159041</B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
The information in this article applies to:
<P>
- Microsoft COM libraries included with:
<PRE>    - Microsoft Windows NT, version 4.0
    - Microsoft Windows 95
</PRE> 
<P>
<P><h2>SUMMARY</h2>
 
<P>
The Eventh.exe sample provides helper functions that allow easy
implementation of event-handling support in a COM server. It also provides
a COM server that uses these functions and a COM client that uses the
server.
<P>
<PRE>You can find <A HREF="http://support.microsoft.com/download/support/mslfiles/Eventh.exe">Eventh.exe</A> <I>(size: 52192 bytes)</I> 
                       , which is a self-extracting file, on these
</PRE>services:

<UL><LI>Microsoft's World Wide Web site on the Internet:
<P><PRE>      1. On the www.microsoft.com home page, click the Support icon.
      2. Click Knowledge Base, and select OLE.
      3. Enter kbfile Eventh.exe, and click GO!
      4. Open the article, and click the button to download the file.
</PRE>
<LI>Internet (anonymous FTP):
<P><PRE>      1. ftp ftp.microsoft.com.
      2. Change to the Softlib/Mslfiles folder.
      3. Get Eventh.exe.
</PRE>
<LI>Microsoft Download Service (MSDL):
<P><PRE>      1. Dial (206) 936-6735 to connect to MSDL.
      2. Download Eventh.exe.
</PRE><P>
</UL>For additional information about downloading, please see the following
article in the Microsoft Knowledge Base:
<P>
<PRE>   ARTICLE-ID: <B><A HREF="../zMiscellaneous/Q119591.htm">Q119591</A></B>
   TITLE     : How to Obtain Microsoft Support Files from Online
               Services

</PRE>After downloading the file, run it in an empty directory with the -d
switch to set up the directory structure:
<P>
<PRE>   EVENTH.EXE -d

</PRE><h2>MORE INFORMATION</h2>
 
<P>
This sample provides helper functions that allow easy implementation of
event-handling support in a COM server that fires events. A COM server must
implement the following interfaces to fire events:
<P>
<PRE>   IConnectionPointContainer
   IConnectionPoint
   EnumConnectionPoints
   EnumConnections

</PRE>This sample provides a function called CreateStdCPContainer() that
implements the above interfaces and a function called FireEvent() that
the server can use to fire events to all clients who have connected to a
connection point. The helper functions can be found in the Event.cpp and
Event.h files and can be used by 32-bit applications only. These files
are self-contained and can be added to any 32-bit project.
<P>
This sample also provides a COM server that uses the helper functions to
implement event-handling support and a COM client that uses the server.
The COM server is the HELLO automation server sample that ships with the
Win32 SDK with added event-handling support. The COM client is the
HELCTRL automation client sample that ships with the Win32 SDK with
added event-handling support.
<P>
To implement event-handling support in a COM server, the server must
aggregate with the IConnectionPointContainer implementation provided by the
helper function, CreateStdCPContainer. Following is the documentation of
this function:
<P>
<PRE>   HRESULT CreateStdCPContainer(
       IUnknown* punkController,
       ITypeInfo* aptinfo[],
       ULONG cTypeInfos,
       DWORD dwFlags,
       IUnknown** ppunkCPC)

</PRE>The function creates a connection-point container object with connection
points corresponding to the array of typeinfos passed in. The newly created
object, which supports IConnectionPointContainer, is aggregated with
punkController. The implementation uses SAFEARRAYs as the data structure to
store the connection-point objects and the event sink pointers provided by
the COM clients.
<P>
<P><h3>Parameters</h3>
 
<P>
punkController
<PRE> [in] Points to the server's IUnknown. The connection-point container
</PRE>created by this function aggregates with this IUnknown.
<P>
aptinfo
<PRE> [in] Array of pointers to typeinfos. Each one corresponds to an event
</PRE>interface/dispinterface that the object supports. Typically, an object has
only one event interface/dispinterface.
<P>
cTypeInfos
<PRE> [in] Size of aptinfo array. This is typically 1, unless the object has
</PRE>multiple event interfaces.
<P>
dwFlags
<PRE> [in] Indicates the type of connection-point container to create. The two
</PRE>values allowed are CPTYPEFLAG_MULTICAST and CPTYPEFLAG_SINGLECAST.
CPTYPEFLAG_MULTICAST indicates that multiple clients can connect their
sinks to each connection point and the event will be fired to all those
clients. CPTYPEFLAG_SINGLECAST indicates that only one client can connect
its sink to each connection point and the event will be fired only to that
client. These constants are defined in Event.h in this sample.
<P>
ppunkCPC
<PRE> [out] Returns IUnknown* of the created connection-point container object.
</PRE>(This is the private unknown of the aggregate.)
<P>
<P><h3>Return Value</h3>
 
<P>
<PRE>S_OK              Success.
E_INVALIDARG      Invalid argument.
E_OUTOFMEMORY     Memory allocation failed.

</PRE><h3>Example</h3>
 
<P>
In this code example, ptinfo is the typeinfo of the event interface
(obtained from the type library) and riidEvents is the GUID of that
interface. The COM server should call this code in its creation routine.
This server has one event interface. It saves the returned pointer to the
IUnknown* of the connection-point container object in the m_punkCPContainer
data member. It also saves the pointer to the connection point in the m_pcp
data member:
<P>
<PRE>   CreateStdCPContainer(this, &amp;ptinfo, 1, CPTYPEFLAG_MULTICAST,
   &amp;m_punkCPContainer);
   m_punkCPContainer-&gt;QueryInterface(IID_IConnectionPointContainer,
   (void**)&amp;pcpc);
   pcpc-&gt;FindConnectionPoint(riidEvents, &amp;m_pcp);

</PRE>The COM server should implement its IUnknown::QueryInterface. Following is
an example of how to handle a request for IID_IConnectionPointContainer:
<P>
<PRE>   if (iid == IID_IConnectionPointContainer)
        return m_punkCPContainer-&gt;QueryInterface(iid, ppv);

</PRE>After the server has aggregated with the connection-point container object
provided by CreateStdCPContainer, it can use the FireEvent() helper
function to fire events to the clients who have connected to a connection
point. Following is the documentation of FireEvent():
<P>
<PRE>   STDAPI FireEvent(IConnectionPoint FAR *pcp,
         DISPID dispidMember,
         REFIID riid,
         LCID lcid,
         WORD wFlags,
         DISPPARAMS FAR* pdispparams,
         VARIANT FAR* pvarResult,
         EXCEPINFO FAR* pexcepinfo,
         UINT FAR* puArgErr)

</PRE>This fires the event specified by dispidMember to all sinks connected to
the pcp connection point. IDispatch::Invoke fires the event. Consequently,
the event sink in the client must implement IDispatch for this function to
work. If you do not want to use IDispatch to fire events, you must rewrite
this function but you can still use CreateStdCPContainer(). This function
does not stop firing events if the call to a specific event sink fails.
<P>
<P><h3>Parameters</h3>
 
<P>
pcp
<PRE> [in] The connection point for which events are going to be fired. This
</PRE>connection point must be obtained from the connection-point container
created by CreateStdCPContainer().
<P>
The other parameters are the same as the IDispatch::Invoke parameters
and include the DISPID of the event to be fired and the parameters of
the event.
<P>
<P><h3>Return Value</h3>
 
<P>
<PRE>S_OK              Success
E_OUTOFMEMORY     Memory Allocation failure
</PRE>Errors returned by failure of SafeArrayCopy and SafeArrayAccessData.
<P>
<P><h3>Example</h3>
 
<P>
In the following example, m_pcp is the variable referenced in the example
section of the CreateStdCPContainer documentation:
<P>
<PRE>   FireEvent(m_pcp, dispid, IID_NULL, LOCALE_USER_DEFAULT,
             DISPATCH_METHOD, &amp;dispparamsNoArgs, NULL, NULL, NULL);

</PRE><h3>To Compile the Samples</h3>
 
<P>
To compile an ANSI-debug version of the sample for Windows NT and
Windows 95, use the following command:
<P>
<PRE>   nmake

</PRE>To compile a Unicode-debug version of the sample for Windows NT only, use
the following command:
<P>
<PRE>   nmake HOST=NT

</PRE>See the makefile header comments for other make options.
<P>
Compile the HELLO sample before compiling the HELCTRL sample because
HELCTRL uses HELLO's Tlb.h file. In this sample, the HELCTRL client
application uses the server's type library to implement the IDispatch
interface of the event sink. Note that the client can also use its own type
library for this purpose.
<P>
<P><h3>To Run the Samples</h3>
 
<P>
Change Hello.reg to provide the full path of Hello.exe and Hello.tlb.
Register Hello.reg in the registration database by double-clicking it in
Explorer. Run Helctrl.exe and use its menu to control the HELLO server. You
can use CreateHello to create a new instance of HELLO. You can use GetHello
to bind to a running instance of HELLO. Use the Visible menuitem to make
the server visible if required. Use InvokeSayHello to invoke the SayHello
method. The server fires the SaidHello event when SayHello is invoked. The
client displays a message box indicating that it received the fired event.
<P>
Windows NT 4.0 and Windows 95 with DCOM have system-provided marshaling
code for the event interfaces (IConnectionPointContainer, IConnectionPoint,
EnumConnectionPoints and EnumConnections). Without DCOM, Windows NT 3.51
and Windows 95 do not have system-provided marshaling code for these
interfaces. If you want to run these samples on Windows 95 without DCOM and
Windows NT 3.51, install the marshaling code provided in the following
sample from the Microsoft Knowledge Base. Make sure that you carefully read
the installation instructions in the sample before installing the
marshaling code:
<P>
<PRE>   Article ID: <B><A HREF="../OLEPROG/Q149231.htm">Q149231</A></B>
   TITLE:      Marshaling Code for Connection Point Interfaces

</PRE>If you would like to run the server on a remote computer and you want to
gain access to it from the client using DOCM, read the following article in
the Microsoft Knowledge Base. If you do this, make sure that the client
application provides access permission to the user on the server computer,
which is where the server application runs. Otherwise, the server
application cannot fire events to the client application.
<P>
<PRE>   Article ID: <B><A HREF="../OLEPROG/Q158582.htm">Q158582</A></B>
   TITLE     : Configuring a non-DCOM server and client to use DCOM
</PRE>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
KBCategory: kbole kbfile<BR>
KBSubcategory: OleTwoArc<BR>
Additional reference words: 4.00 kbdss
<P>


</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  November 13, 1996</FONT>
	<BR>
	<A HREF="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
