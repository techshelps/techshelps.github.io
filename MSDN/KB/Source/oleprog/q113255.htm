

<HTML>
<HEAD>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Corrections for Inside OLE 2 Sample Code </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q113255">
<META NAME="KBModify" CONTENT="1996/08/05">
<META NAME="KBCreate" CONTENT="1994/03/29">
<META NAME="Keywords" CONTENT="kbole kbfile kbwebcontent">
<META NAME="KBArea" CONTENT="Support; KB; oleprog">
<META NAME="Description" CONTENT="  The sample code for the book  Inside OLE 2,  by Kraig Brockschmidt (Microsoft Press) was originally written to be compatible with OLE 2.0. This code has been updated to be compatible with OLE 2.01, and also to fix some problems in the original code...">
<META NAME="Product" CONTENT="OLE (Programming)">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT="OLE ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QAH4,QAUD,QAAP,QAKP,QA9Q,QAPF,QAR4,QBCH,QDMW,QAEF,QAB4,QBKN,QAW6,QBB1,QAY5 V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>Corrections for Inside OLE 2 Sample Code</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  August 5, 1996</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q113255</B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
The information in this article applies to:

<UL><LI>Microsoft OLE Libraries for Windows and Win32s, version 2.01
<LI>Microsoft OLE Libraries, version 2.1, included with:
<P><PRE>    - Microsoft Windows NT, version 3.5
</UL></PRE> 
<P>
<P><h2>SUMMARY</h2>
 
<P>
The sample code for the book "Inside OLE 2," by Kraig Brockschmidt
(Microsoft Press) was originally written to be compatible with OLE 2.0.
This code has been updated to be compatible with OLE 2.01, and also to fix
some problems in the original code. This article describes the changes that
were made in updating the code. The changes are described in detail in the
"More Information" section of this article below; below a quick list of the
problems that required changes:

<UL><LI>Compiler Errors on IViewObject::Draw()
<LI>Compiler Errors on OleUIAddVerbMenu()
<LI>Compiler Errors on OleStdGetObjectDescriptorFromOleObject()
<LI>Compiler Errors on IDS_CLOSE
<LI>Linker Fails with CLASSLIB Sample
<LI>Compiler Errors Referencing GETICON.H
<LI>Incorrect Prototypes for LibMain() and WEP()
<LI>Patron GP Faults During Activate As
<LI>Patron's Convert To Fails
<LI>CLASSLIB String Allocations Fail with Some Compilers
<LI>CImpIPolyline::WriteToFile() Returns an Incorrect Value
<LI>CImpIOleObject::GetClientSite() Returns an Incorrect Value
<LI>Polyline Registers a Format with an Uninitialized String
<LI>DataTran Reference Counting Problem
<LI>Component Cosmo Fails to Release Polyline Object
<LI>Cosmo Fails to Load When Used with HCosmo Handler
<LI>Patron Does Not Work with Some Printer Drivers
<LI>ClassLib Creates Table of Invalid String Pointers
<LI>Errors in Enumerator Samples
<LI>Samples GP Fault When Closing Iconized Documents
<P>
</UL><h3>Updated Sample Code Available</h3>
 
<P>
The INOLE2 Software Library sample contains a complete source tree for
updated "Inside OLE 2" sample code. All of the changes described in this
article have already been made to the INOLE2 code.
<P>
The easiest way to update all of the "Inside OLE 2" samples is to get a
completely new source tree from INOLE2, and then rebuild the samples from
scratch under OLE 2.01. This article can then be used as a reference,
explaining what changes were made and why there were necessary.
<P>
<PRE>You can find <A HREF="http://support.microsoft.com/download/support/mslfiles/INOLE2.EXE">INOLE2.EXE</A> <I>(size: 2107743 bytes)</I> 
                       , a self-extracting file, on these services:

</PRE><LI>Microsoft's World Wide Web site on the Internet
<P><PRE>      On the www.microsoft.com home page, click the Support icon
      Click Knowledge Base, and select the product
<PRE></PRE>      Enter kbfile <A HREF="http://support.microsoft.com/download/support/mslfiles/INOLE2.EXE">INOLE2.EXE</A> <I>(size: 2107743 bytes)</I> 
                             , and click GO!
      Open the article, and click the button to download the file

</PRE><LI>Internet (anonymous FTP)
<P><PRE>      ftp ftp.microsoft.com
      Change to the Softlib/Mslfiles folder
      Get <A HREF="http://support.microsoft.com/download/support/mslfiles/INOLE2.EXE">INOLE2.EXE</A> <I>(size: 2107743 bytes)</I> 
</PRE>
<LI>The Microsoft Network
<P><PRE>      On the Edit menu, click Go To, and then click Other Location
      Type "mssupport" (without the quotation marks)
      Double-click the MS Software Library icon
      Find the appropriate product area
      Locate and Download INOLE2.EXE
</PRE>
<LI>Microsoft Download Service (MSDL)
<P><PRE>      Dial (206) 936-6735 to connect to MSDL
      Download <A HREF="http://support.microsoft.com/download/support/mslfiles/INOLE2.EXE">INOLE2.EXE</A> <I>(size: 2107743 bytes)</I> 
</PRE><P>
</UL>For additional information about downloading, please see the following
article in the Microsoft Knowledge Base:
<P>
<PRE>   ARTICLE-ID: <B><A HREF="../zMiscellaneous/Q119591.htm">Q119591</A></B>
   TITLE     : How to Obtain Microsoft Support Files from Online Services

</PRE>NOTE: This archive contains subdirectories, be sure to use the -d command
line switch during extraction.
<P>
<P><h2>MORE INFORMATION</h2>
 
<P>
<P><h3>BOOKUI.DLL</h3>
 
<P>
If the original source code to the Inside OLE 2 samples is updated
according to this article, and the samples are then rebuilt to be
compatible with OLE 2.01, it will also be necessary to rebuild an OLE 2.01
version of the OLE2UI library for the samples to use. To do so, build a
library called BOOKUI.DLL according to the instructions in the OLE 2.01
SDK.
<P>
Use this new DLL to replace the INOLE2\BUILD\BOOKUI.DLL file included with
the book.
<P>
If the samples are rebuilt from the INOLE2 Software Library sample, it is
not necessary to manually rebuild BOOKUI.DLL, because INOLE2 already
includes an updated version of BOOKUI.DLL.

<OL><P><LI>Compiler Errors on IViewObject::Draw()
</OL> 
<P>
Problem:
<P>
The prototype for IViewObject::Draw() changed between OLE 2.0 and OLE 2.01.
In 2.0 the lprcBounds and lprcWBounds parameters were prototyped as "const
LPRECTL"; in 2.01 they are prototyped as "LPCRECTL". This change causes
the HCosmo (Chapter 11) and Polyline (Chapters 11 and 16) sample
applications to fail during compilation under 2.01.
<P>
Solution:
<P>
To correct this error, update all references to IViewObject::Draw() in
the Inside OLE 2 sample code by changing const LPRECTL to LPCRECTL.
<P>
This change will be necessary in the following files:
<P>
<PRE>   interfac\iviewobj.cpp
   interfac\iviewobj.h

   chap11\hcosmo\hcosmo.h
   chap11\hcosmo\iviewobj.cpp

   chap11\polyline\iviewobj.cpp
   chap11\polyline\polyline.h

   chap16\polyline\iviewobj.cpp
   chap16\polyline\polyline.h

</PRE><P><LI>Compiler Errors on OleUIAddVerbMenu()
</OL> 
<P>
Problem:
<P>
The prototype for OleUIAddVerbMenu() changed between OLE 2.0 and OLE 2.01.
The OLE2UI library version OLE 2.01 added an additional parameter to
OleUIAddVerbMenu(). This new parameter is an integer value called
"idVerbMax", and it indicates the largest number the container allows for a
verb menu item identifier. The idVerbMax parameter immediately follows the
idVerbMin parameter.
<P>
The Patron sample applications were written for the OLE 2.0 version of the
user interface library, which did not include this new parameter.
Consequently, these samples do not compile with the OLE 2.01 header files.
This difference affects the versions of Patron found in Chapters 9, 12, 13,
14, and 15.
<P>
Solution:
<P>
To correct this problem, perform the following two steps:

<OL><P><LI>Build an OLE 2.01 version of BOOKUI.DLL, as described in problem 1
   above.

<P><LI>Update all calls to OleUIAddVerbMenu() in Patron by passing "ID_VERBMAX"
   (already defined in RESOURCE.H) as the idVerbMax parameter. For example,
   in the function CPage::FQueryObjectSelected(), change the following
<P>
<P><PRE>      OleUIAddVerbMenu(NULL, NULL, hMenu, MENUPOS_OBJECT
<PRE></PRE>          , IDM_VERBMIN, FALSE, 0, &amp;hMenuTemp);

   to read as follows:

      OleUIAddVerbMenu(NULL, NULL, hMenu, MENUPOS_OBJECT
          , IDM_VERBMIN, IDM_VERBMAX, FALSE, 0, &amp;hMenuTemp);

   This change will be necessary in the functions
   CPage::FQueryObjectSelected() and CTenant::AddVerbMenu() in each of the
   following files:

      chap09\patron\page.cpp
      chap09\patron\tenant.cpp

      chap12\patron\page.cpp
      chap12\patron\tenant.cpp

      chap13\patron\page.cpp
      chap13\patron\tenant.cpp

      chap14\patron\page.cpp
      chap14\patron\tenant.cpp

      chap15\patron\page.cpp
      chap15\patron\tenant.cpp

</PRE><P><LI>Compiler Errors on OleStdGetObjectDescriptorFromOleObject()
</OL> 
<P>
Problem:
<P>
The prototype for OleStdGetObjectDescriptorFromOleObject() changed between
OLE 2.0 and OLE 2.01. Version 2.01 of the OLE2UI library added an
additional parameter to OleStdGetObjectDescriptorFromOleObject(). This new
parameter, "lpSizelHim", is an LPSIZEL value and points to a structure that
indicates the dimensions of the object. The lpSizelHim parameter was added
to the end of the existing parameter list.
<P>
The Patron sample applications were written for the OLE 2.0 version of the
user interface library, which did not include this new parameter.
Consequently, these samples do not compile with the OLE 2.01 header files.
This difference affects the versions of Patron in Chapters 9, 12, 13, 14,
and 15.
<P>
Solution:
<P>
To correct this problem, perform the following two steps:

<OL><P><LI>Build an OLE 2.01 version of BOOKUI.DLL, as described in problem 1
   above.
<P>
</OL>2a. To quickly solve the problem, update all calls to
<PRE>    OleStdGetObjectDescriptorFromOleObject() in Patron by passing NULL as
    the lpSizelHim parameter.

</PRE></OL>2b. For a more complete solution to the problem, first declare a local
<PRE>    variable:

       SIZEL   szl;

    Then replace the code:

       stm.hGlobal=OleStdGetObjectDescriptorDataFromOleObject
           (m_pIOleObject, NULL, m_fe.dwAspect, ptl);

    with the code:

       SETSIZEL(szl, (10*(m_rcl.right-m_rcl.left))
           , (10 * (m_rcl.bottom-m_rcl.top)));

       stm.hGlobal=OleStdGetObjectDescriptorDataFromOleObject
           (m_pIOleObject, NULL, m_fe.dwAspect, ptl, &amp;szl);

    This code correctly computes the size of the object and then stores
    those extents into the object descriptor.

</PRE>These changes will be necessary in the function
CTenant::CopyEmbeddedObject() in each of the following files:
<P>
<PRE>   chap09\patron\tenant.cpp
   chap12\patron\tenant.cpp
   chap13\patron\tenant.cpp
   chap14\patron\tenant.cpp
   chap15\patron\tenant.cpp

</PRE>These changes will also be necessary in the function
CTenant::CopyLinkedObject(), found in TENANT.CPP in Chapters 12, 13, 14,
and 15.

<OL><P><LI>Compiler Errors on IDS_CLOSE
</OL> 
<P>
Problem:
<P>
The OLE2UI.H header file shipped with OLE 2.01 defines a symbol IDS_CLOSE.
This symbol causes a conflict with a symbol of the same name defined in the
Cosmo samples.
<P>
This conflict affects the versions of Cosmo in Chapters 10, 13, 14, and 16.
The files affected are COSMO.RC and RESOURCE.H.
<P>
Solution:
<P>
To correct the problem, rename IDS_CLOSE in RESOURCE.H to IDS_CLOSE2, and
change the single occurrence of IDS_CLOSE in COSMO.RC to IDS_CLOSE2 in each
chapter. These changes are necessary in the following files:
<P>
<PRE>   chap10\cosmo\cosmo.rc
   chap10\cosmo\resource.h

   chap13\cosmo\cosmo.rc
   chap13\cosmo\resource.h

   chap14\cosmo\cosmo.rc
   chap14\cosmo\resource.h

   chap16\cosmo\cosmo.rc
   chap16\cosmo\resource.h

</PRE><P><LI>Linker Fails with CLASSLIB Sample
</OL> 
<P>
Problem:
<P>
There is an error in the FILES.LST file in the CLASSLIB directory of the
sample code. The first entry in this file, "cstrtable.obj", is a valid long
filename under Windows NT, but the file created during compilation is
actually "cstrtabl.obj" (no "e" on table). This causes no problems with a
16-bit compiler, because the extra "e" is ignored. However, it will
cause an error with a 32-bit compiler.
<P>
Solution:
<P>
To solve the problem, remove the "e", thus changing "cstrtable.obj"
to "cstrtabl.obj".

<OL><P><LI>Compiler Errors Referencing GETICON.H
</OL> 
<P>
Problem:
<P>
In OLE 2.0, container applications must include the file GETICON.H, which
is supplied with the OLE Software
Development Kit (SDK) version 2.0. In OLE 2.01, applications no longer need
to include GETICON.H, because the information in that file has been moved
to other header files. Because it is no longer needed, GETICON.H is not
included with the OLE 2.01 SDK.
<P>
The Patron sample applications of Chapters 14 and 15 were written for OLE
2.0, so they include GETICON.H. Because this file is no longer available,
these versions of Patron fail to compile with the OLE 2.01 SDK.
<P>
Solution:
<P>
To correct the problem, comment out or delete the line "#include
&lt;geticon.h&gt;" in TENANT.CPP. This change is necessary in the following
files:
<P>
<PRE>   chap14\patron\tenant.cpp
   chap15\patron\tenant.cpp

</PRE><P><LI>Incorrect Prototypes for LibMain() and WEP()
</OL> 
<P>
Problem:
<P>
The LibMain() and WEP() functions in all of the DLL samples are prototyped
incorrectly. These prototypes cause errors when using some compilers (for
example, Borland C++ 4.0); they do not cause problems with other compilers
(for example, Microsoft Visual C++ versions 1.0 and 1.5).
<P>
Solution:
<P>
The DLL samples in Inside OLE 2 implement the LibMain() and WEP() functions
as follows:
<P>
<PRE>   HANDLE FAR PASCAL LibMain(HANDLE hInstance, WORD wDataSeg
       , WORD cbHeapSize, LPSTR lpCmdLine)
       {
       ...

       return hInstance;
       }

   void FAR PASCAL WEP(int bSystemExit)
       {
       return;
       }

</PRE></OL>To match the Windows SDK specifications, both of these functions should
return an int:
<P>
<PRE>   int FAR PASCAL LibMain(HANDLE hInstance, WORD wDataSeg
       , WORD cbHeapSize, LPSTR lpCmdLine)
       {
       ...

       return (int)hInstance;
       }

   int FAR PASCAL WEP(int bSystemExit)
       {
       return 0;
       }

</PRE>To solve this problem, make the changes above to all occurrences of
LibMain() and WEP() in the Inside OLE 2 sample code.

<OL><P><LI>Patron GP Faults During Activate As
</OL> 
<P>
Summary:
<P>
The Patron sample applications from Chapters 14 and 15 support the OLE 2
Convert dialog box. Choosing Activate As from this dialog box sometimes
causes a GP fault.
<P>
Problem:
<P>
The problem lies in the way that the CTenant::Close() function uses the
fReopen flag. When Close() determines that there are no references to the
tenant IStorage, it normally resets the internal state of the tenant to
default values. As part of this process, it sets the member m_pIStorage to
NULL. However, if fReopen is TRUE, this assignment to NULL is skipped.
<P>
This can lead to situations where m_pIStorage is non-NULL but the storage
itself has been destroyed. Thus m_pIStorage is an invalid pointer, and
trying to call through it causes a GP fault.
<P>
To correct this problem, ensure that the m_pIStorage variable is set to
NULL any time its reference count is 0 (zero). This correction involves
removing a condition in the CTenant::Close() function, which is found in
the Patron source file TENANT.CPP.
<P>
Solution:
<P>
To correct this problem, edit the code to CTenant::Close() as follows:
<P>
Where you see the lines
<P>
<PRE>   if (!fReopen)
       m_pIStorage=NULL;

</PRE></OL>remove the "if" statement, leaving:
<P>
<PRE>   m_pIStorage=NULL;

</PRE>The fReopen flag was used in an attempt to provide some optimization when
performing Activate As, but this flag is not necessary. The updated Inside
OLE 2 sample code referenced above has removed the flag entirely. This
affects the TENANT.CPP, TENANT.H, and PAGE.CPP source files of the PATRON
samples in Chapters 14 and 15.

<OL><P><LI>Patron's Convert To Fails
<P>
</OL>Summary:
<P>
The Patron sample applications from Chapters 14 and 15 support the OLE 2
Convert dialog box. When Convert To is chosen from this dialog box, PATRON
fails to perform the conversion properly.
<P>
Problem:
<P>
The problem is that CPage::FConvertObject() releases the page's IStorage
pointer without committing it. Because Patron uses transacted storage, this
discards all changes, including the conversion that just happened.
<P>
The code in error (listed on Page 817 of Inside OLE 2) is as follows:
<P>
<PRE>   if ((CF_SELECTCONVERTTO &amp; ct.dwFlags)
       &amp;&amp; !IsEqualCLSID(ct.clsid, ct.clsidNew))
       {
       LPSTORAGE   pIStorage;

       //This should be the only close necessary.
       m_pTenantCur-&gt;RectGet(&amp;rcl, FALSE);
       m_pTenantCur-&gt;StorageGet(&amp;pIStorage);
       m_pTenantCur-&gt;Close(FALSE, FALSE);

       hr=OleStdDoConvert(pIStorage, ct.clsidNew);
       pIStorage-&gt;Release();

</PRE></OL>This code does not commit the changes to the storage affected by
OleStdDoConvert before releasing pIStorage.
<P>
Solution:
<P>
To correct this problem, include a call to pIStorage-&gt;Commit() before
releasing the storage:
<P>
<PRE>   if ((CF_SELECTCONVERTTO &amp; ct.dwFlags)
       &amp;&amp; !IsEqualCLSID(ct.clsid, ct.clsidNew))
       {
       LPSTORAGE   pIStorage;

       //This should be the only close necessary.
       m_pTenantCur-&gt;RectGet(&amp;rcl, FALSE);
       m_pTenantCur-&gt;StorageGet(&amp;pIStorage);
       m_pTenantCur-&gt;Close(FALSE, FALSE);

       hr=OleStdDoConvert(pIStorage, ct.clsidNew);

       pIStorage-&gt;Commit(STGC_ONLYIFCURRENT);
       pIStorage-&gt;Release();

   ...

</PRE><P><LI>CLASSLIB String Allocations Fail with Some Compilers
</OL> 
<P>
Summary:
<P>
The Inside OLE 2 sample code includes a CLASSLIB library. Compiling the
CStringTable class from this library may cause string space allocation
failures with some compilers.
<P>
Problem:
<P>
The problem is an uninitialized local variable "cchUsed" in the function
CStringTable::FInit(). This routine is found in the CLASSLIB source file
SCSTRTABL.CPP.
<P>
Solution:
<P>
Initialize cchUsed to zero, for example, change the line
<P>
<PRE>   UINT        cchUsed;

</PRE></OL>to read as follows:
<P>
<PRE>   UINT        cchUsed=0;

</PRE><P><LI>CImpIPolyline::WriteToFile() Returns an Incorrect Value
</OL> 
<P>
Summary:
<P>
The Polyline sample DLL in Chapter 4 contains a function,
CImpIPolyline::WriteToFile(), which returns an incorrect value.
<P>
Problem:
<P>
If WriteToFile()'s write operation succeeds, it should return NOERROR.
Instead, it returns POLYLINE_E_WRITEFAILURE.
<P>
Solution:
<P>
In the code for the CImpIPolyline::WriteToFile() function, change the lines
that read
<P>
<PRE>   return (m_pObj-&gt;m_fDirty) ?
       NOERROR : ResultFromScode(POLYLINE_E_WRITEFAILURE);

</PRE></OL>to read as follows:
<P>
<PRE>   return (!m_pObj-&gt;m_fDirty) ?
       NOERROR : ResultFromScode(POLYLINE_E_WRITEFAILURE);

</PRE>Make this change to the Chapter 4 version of Polyline.
CImpIPolyline::WriteToFile() is in the Polyline source file IPOLYLIN.CPP.

<OL><P><LI>CImpIOleObject::GetClientSite() Returns an Incorrect Value
</OL> 
<P>
Summary:
<P>
The Cosmo sample applications in Chapters 10, 13, 14 and 16 contain a
function, CImpIOleObject::GetClientSite(), that returns an incorrect value.
<P>
Problem:
<P>
When GetClientSite() encounters no errors, it should return NOERROR.
Instead, it returns E_NOTIMPL.
<P>
Solution:
<P>
In the code for CImpIOleObject::GetClientSite(), change the line that reads
<P>
<PRE>   return ResultFromScode(E_NOTIMPL);

</PRE></OL>to read as follows:
<P>
<PRE>   return NOERROR;

</PRE>Make this change to the versions of Cosmo in Chapters 10, 13, 14 and 16.
CImpIOleObject::GetClientSite() is in the Cosmo source file IOLEOBJ.CPP.

<OL><P><LI>Polyline Registers a Format with an Uninitialized String
</OL> 
<P>
Summary:
<P>
The Polyline sample DLLs in Chapters 5, 6, 11 and 16 attempt to register a
clipboard format using an uninitialized string. As a result, data formats
do not get properly transferred during clipboard, drag &amp; drop, and compound
document operations.
<P>
Problem:
<P>
The offending line is:
<P>
<PRE>   m_cf=RegisterClipboardFormat(PSZ(IDS_STORAGEFORMAT));

</PRE></OL>At constructor time, the stringtable referenced by the PSZ macro (this
macro tries to access the member CPolyine::m_pST) has not been initialized,
so m_cf is not set properly.
<P>
Solution:
<P>
To correct the error, the line of code listed above that initializes m_cf
must be moved into the function CPolyline::FInit(). Specifically, move the
line of code to occur after the code that initializes the stringtable:
<P>
<PRE>   if (!m_pST-&gt;FInit(IDS_POLYLINEMIN, IDS_POLYLINEMAX))
       return FALSE;

   m_cf=RegisterClipboardFormat(PSZ(IDS_STORAGEFORMAT));

</PRE>Make this one-line change to the versions of Polyline in Chapters 5, 11,
and 16. CPolyline::FInit() is in the Polyline source file POLYLINE.CPP.
<P>
Correcting this error in the Chapter 6 version of Polyline requires an
extra step. All lines initializing the FORMATETC arrays m_rgfeGet[0] and
m_rgfeSet[0] in which m_cf is stored must also be moved into
CPolyline::FInit(). The most convenient way to make this change is to
simply move all the FORMATETC initialization to the end of FInit(). Note
that Polyline does not use the FORMATETC arrays in Chapters 11 and 16, so
this extra step is not necessary in those chapters.

<OL><P><LI>DataTran Reference Counting Problem
</OL> 
<P>
Summary:
<P>
The DataTran data transfer object in Chapter 7 has a reference-counting
problem in the function CImpIDataObj::GetData(). As a result, storage
elements in the STGMEDIUM returned by GetData() may become invalid while
they are still in use.
<P>
Problem:
<P>
GetData() incorrectly fails to call AddRef() on any IStorage or IStream
pointer contained in the STGMEDIUM it returns.
<P>
Solution:
<P>
To correct this error, add the following lines of code to GetData(),
immediately after the line "*pSTM = pRen-&gt;stm;":
<P>
<PRE>   /*
    * Must remember to AddRef any other objects
    * in the STGMEDIUM:  storages and streams.
    */
   if (TYMED_ISTORAGE==pSTM-&gt;tymed)
       pSTM-&gt;pstg-&gt;AddRef();

   if (TYMED_ISTREAM==pSTM-&gt;tymed)
       pSTM-&gt;pstm-&gt;AddRef();

</PRE></OL>GetData() is in the DataTran source file IDATAOBJ.CPP.

<OL><P><LI>Component Cosmo Fails to Release Polyline Object
</OL> 
<P>
Summary:
<P>
The Component Cosmo samples in Chapter 6, 7, 8, 11 and 16 fail to fully
clean up their allocations when closing a document. As a result, files may
not be saved completely and unused code is left in memory.
<P>
Problem:
<P>
In the function CCosmoDoc::~CCosmoDoc(), CoCosmo obtains an IDataObject
pointer on the Polyline object it maintains in the document. It then fails
to release this pointer, resulting in the problems listed above.
<P>
Solution:
<P>
In the code for CCosmoDoc::~CCosmoDoc(), add a call to
IDataObject::Release().
<P>
Change the lines
<P>
<PRE>   if (SUCCEEDED(hr))
       pIDataObject-&gt;DUnadvise(m_dwConn);

</PRE></OL>to read as follows:
<P>
<PRE>   if (SUCCEEDED(hr))
       {
       pIDataObject-&gt;DUnadvise(m_dwConn);
       pIDataObject-&gt;Release();
       }

</PRE>CCosmoDoc::~CCosmoDoc() is in the CoCosmo source file DOCUMENT.CPP.

<OL><P><LI>Cosmo Fails to Load When Used with HCosmo Handler
</OL> 
<P>
Summary:
<P>
The Cosmo sample applications in Chapter 10, 13, 14, or 16, when they are
being used in conjunction with the custom object handler HCosmo from
Chapter 11, fail to load and activate a Cosmo object. This problem occurs
when a container application is reloading a Cosmo object from a saved file,
and also when a container application is reactivating a Cosmo object after
the object has been first created and then deactivated.
<P>
Problem:
<P>
The problem actually lies in HCosmo. HCosmo incorrectly keeps the object
stream open in the object's IStorage. It does this so that it can perform
low-memory saves without having to reopen the stream.
<P>
However, when a process has a stream open and that stream has a particular
IStorage as its parent, the OLE 2 implementation of STORAGE.DLL does not
allow the process to open the stream a second time from the same parent
IStorage. Therefore, when the Cosmo application receives the IStorage
pointer from HCosmo, and attempts to open the same object stream that
HCosmo already has open, the attempt to open the stream fails.
<P>
This problem shows up in HCosmo's implementation of IOleObject::DoVerb().
HCosmo delegates the DoVerb() call to the default handler, and the default
handler attempts to launch Cosmo. As described above, Cosmo cannot open the
object stream, so it returns an error of STG_E_READFAULT to the default
handler, which in turn returns STG_E_READFAULT to HCosmo.
<P>
As noted above, HCosmo keeps the object stream open so that it can perform
low-memory saves without having to reopen the stream. However, this is not
necessary. Because HCosmo never makes changes to the object, it never has
to save anything in a low-memory situation. Specifically, it never has to
save any changes to the storage when its IPersistStorage::Save() is called
with the fSameAsLoad flag set to TRUE. Because this is the only case where
an IPersistStorage implementation should not attempt to allocate memory, it
is totally unnecessary for HCosmo to cache any pointers to the stream.
<P>
Solution:
<P>
To correct the problem, make the following five changes to HCosmo's
IPersistStorage implementation (HCosmo's implementation of IPersistStorage
is in the source file IPERSTOR.CPP):

<OL><P><LI>In CImpIPersistStorage::InitNew(), add the lines below immediately
   before the call to WriteClassStg():
<P>
<P><PRE>      m_pObj-&gt;m_pIStream-&gt;Release();
      m_pObj-&gt;m_pIStream=NULL;
</PRE>
<P><LI>In CImpIPersistStorage::Load(), replace the line
<P>
<P><PRE>      m_pObj-&gt;m_pIStream=pIStream;
</PRE><P>
   with the following:
<P>
<P><PRE>      pIStream-&gt;Release();
      m_pObj-&gt;m_pIStream=NULL;
</PRE>
<P><LI>In CImpIPersistStorage::Save(), remove all the code inside the "if
   (fSameAsLoad)" condition (it is unnecessary).

<P><LI>In CImpIPersistStorage::SaveCompleted(), remove the lines of code below
   that occur inside the "if (NULL!=pIStorage)" condition:
<P>
<P><PRE>      hr=pIStorage-&gt;OpenStream("CONTENTS", 0, STGM_DIRECT
<PRE></PRE>          | STGM_READWRITE | STGM_SHARE_EXCLUSIVE, 0
          , &amp;pIStream);

      if (FAILED(hr))
          return hr;

      if (NULL!=m_pObj-&gt;m_pIStream)
          m_pObj-&gt;m_pIStream-&gt;Release();

      m_pObj-&gt;m_pIStream=pIStream;

</PRE><P><LI>In CImpIPersistStorage::HandsOffStorage(), remove the condition and body
   of code below:
<P>
<P><PRE>      if (NULL!=m_pObj-&gt;m_pIStream)
<PRE></PRE>          {
          m_pObj-&gt;m_pIStream-&gt;Release();
          m_pObj-&gt;m_pIStream=NULL;
          }

</PRE></OL>The m_pIStream member of CFigure can then be eliminated entirely, because
it is no longer used in this IPersistStorage implementation.

<OL><P><LI>Patron Does Not Work with Some Printer Drivers
</OL> 
<P>
Summary:
<P>
The Patron sample applications do not work correctly with certain printer
drivers, including the standard PostScript driver.
<P>
One symptom of failure is getting a blank document window when creating a
new Patron document; that is, no page image appears. Another symptom is
getting a GP fault in the printer driver when attempting to execute
the Printer Setup command from Patron's File menu.
<P>
Problem:
<P>
The problem is caused by the fact that Patron is not sensitive to the
variable length of the DEVMODE structure returned by the printer driver.
Patron normally obtains the DEVMODE data by calling the Windows PrintDlg()
API; it then copies that data to a private stream in its Compound File.
However, Patron only copies sizeof(DEVMODE) bytes, and therefore loses any
additional driver-specific information that might exist at the end of the
DEVMODE structure.
<P>
Some printer drivers, such as the Hewlett-Packard (HP) LaserJet PCL
drivers, use no extra information. Patron works correctly with these
drivers. Other drivers, such as the standard PostScript driver, use extra
information; with these drivers, Patron fails.
<P>
Solution:
<P>
To correct this problem, change the implementation of Patron's CPages class
so that it works with variable length DEVMODE structures, and therefore
with all printer drivers.
<P>
The changes are too extensive to list in this article; as noted at the top
of this article, an updated version of the Inside OLE 2 sample code source
tree is available on the Software Library. The following is a brief
overview of the code that needs to be changed to correct this problem:
<P>
The CPages class is defined in the header file PAGES.H, and implemented in
PAGES.CPP. The functions that need to be updated are:

<UL><LI>CPages::DevmodeSet() and CPages::DevModeGet() in all chapters
<LI>CPages::ConfigureForDevice() in Chapters 2 and 5
<LI>CPages::DevReadConfig() in all chapters other than 2 and 5
<P>
</UL>After these changes have been made, the new Patron will be unable to read
files generated by previous versions of Patron. There is no automatic
conversion facility provided in these samples. To convert a file from the
old Patron format to the new Patron format, follow these steps:

<OL><P><LI>Run an old version of Patron from Chapter 14.
</OL>2. Run a new version of Patron from Chapter 15 (or, run the old Chapter 15
<PRE>   Patron and the new Chapter 14 Patron).
</PRE></OL>3. Load the old file into the old Patron.
4. Transfer all objects from the old Patron to the new Patron, using the
<PRE>   clipboard or drag-and-drop method.
</PRE>5. Save the new document in the new Patron.

<OL><P><LI>ClassLib Creates Table of Invalid String Pointers
</OL> 
<P>
Summary:
<P>
The ClassLib sample framework implements a string table class called
CStringTable. In certain situations the implementation of this class can
create a table of invalid string pointers.
<P>
Problem:
<P>
The function CStringTable::FInit() allocates a block of memory and loads
strings from the application's resources into that memory. It then
initializes a table of far pointers into that memory, one pointer for each
string.
<P>
FInit() then reallocates the memory block, in order to free up any unused
space. This reallocation could move the memory block. Because the far
pointers in the pointer array point into the block that has moved, they all
become invalid.
<P>
Solution:
<P>
To avoid this problem, delete the following lines in the
CStringTable::FInit() function:
<P>
<PRE>   //Now reallocate the string memory to however much we used, plus 1
   psz=(LPSTR)_frealloc(m_pszStrings, cchUsed+1);

   if (NULL!=psz)
       m_pszStrings=psz;

</PRE></OL>This solution wastes a little memory, but is simpler than trying to
recompute all the string pointers; ClassLib is intended to be a simple
example.
<P>
CStringTable::FInit() is in ClassLib's CSTRABL.CPP file.

<OL><P><LI>Errors in Enumerator Samples
</OL> 
<P>
Summary:
<P>
The enumerator samples in "Inside OLE 2" contain two errors. This section
describes the errors and the changes necessary to fix them. The changes are
detailed for the IEnumRect enumerator found in Chapter 3; similar changes
are required in all enumerators in the book's sample code.
<P>
Problem 1:
<P>
If the first parameter to an enumerator's Next() function (called "celt" in
the OLE 2 documentation, "cRects" in the sample) is 1, it is permissible
for the last parameter (called "pceltFetched" in the documentation,
"pdwRects" in the sample) to be NULL. IEnumRect::Next() simply returns
FALSE in this case, which is incorrect.
<P>
Solution 1:
<P>
To correct this error, change the lines of code in IEnumRect::New() that
read
<P>
<PRE>   if (NULL==pdwRects)
       return FALSE;

   *pdwRects=0L;

</PRE></OL>to read as follows:
<P>
<PRE>   if (NULL==pdwRects)
       {
       if (1L!=cRect)
           return FALSE;
       }
   else
       *pdwRects=0L;

</PRE>Problem 2:
<P>
IEnumRect::Next() stores an incorrect value into the out parameter
pdwRects.
<P>
Solution 2:
<P>
To correct this error, change the line of code in IEnumRect::New() that
reads
<P>
<PRE>   *pdwRects=(cRectReturn-cRect);

</PRE>to read as follows:
<P>
<PRE>   if (NULL!=pdwRects)
       *pdwRects=cRectReturn;

</PRE>The same changes should be made to the IENUM.CPP files in the following
"Inside OLE 2" sample code directories:
<P>
<PRE>   interface
   chap03\enumc
   chap03\enumcpp
   chap06\polyline
   chap06\ddataobj
   chap06\edataobj
   chap07\datatran

</PRE><P><LI>Samples GP Fault When Closing Iconized Documents
</OL> 
<P>
Summary:
<P>
The sample applications may cause a GP fault when closing one or more
iconized documents.
<P>
Problem:
<P>
The CClient::QueryCloseAllDocuments() function (found in the ClassLib
source file CCLIENT.CPP) can cause this GP fault through incorrect use of
its local variable hPrevClose.
<P>
Solution:
<P>
To correct this problem, change the code to
CClient::QueryCloseAllDocuments() by adding the two lines below that read
"hPrevClose=NULL":
<P>
BOOL CClient::QueryCloseAllDocuments(BOOL fClose)
<PRE>    {
    ...

    for ( ; hWndT; hWndT=GetWindow(hWndT, GW_HWNDNEXT))
        {
        if (NULL!=hPrevClose)
            {
            pDoc=(LPCDocument)SendMessage(hPrevClose
                , DOCM_PDOCUMENT, 0, 0L);
            CloseDocument(pDoc);
            hPrevClose=NULL;            // ADD THIS LINE
            }

    ...

    //Close the last window as necessary.
    if (fClose &amp;&amp; NULL!=hPrevClose)
        {
        pDoc=(LPCDocument)SendMessage(hPrevClose, DOCM_PDOCUMENT, 0, 0L);
        CloseDocument(pDoc);
        hPrevClose=NULL;                // ADD THIS LINE
        }

    ...
</PRE>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
Additional reference words: 2.01 gpf gp-fault<BR>
KBCategory: kbole kbfile kbwebcontent<BR>
KBSubcategory: LeTwoOth<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  August 5, 1996</FONT>
	<BR>
	<A HREF="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
