

<HTML>
<HEAD>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>PRB: CoCreateInstance Fails in RPC Server </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q141264">
<META NAME="KBModify" CONTENT="1996/07/25">
<META NAME="KBCreate" CONTENT="1995/12/14">
<META NAME="Keywords" CONTENT="kbole kbprg kbprb">
<META NAME="KBArea" CONTENT="Support; KB; oleprog">
<META NAME="Description" CONTENT="  In a RPC server application, calls to any OLE APIs that cause an interface to be marshalled will fail if the application has already called RpcServerListen. In particular, CoGetClassObject and CoCreateInstance fail with E_OUTOFMEMORY even though Co...">
<META NAME="Product" CONTENT="OLE (Programming)">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT="OLE ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QAGI,QAIF,QBWP,QA9Q,QAJH,QAUD,QAPN,QBBS,QAPF,QDL9,QBWQ,QBWO,QBWN,QAW6 V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>PRB: CoCreateInstance Fails in RPC Server</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  July 25, 1996</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q141264</B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
The information in this article applies to:

<UL><LI>32-bit OLE Libraries for Windows 95 and Windows NT 3.51
</UL> 
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
In a RPC server application, calls to any OLE APIs that cause an interface
to be marshalled will fail if the application has already called
RpcServerListen. In particular, CoGetClassObject and CoCreateInstance fail
with E_OUTOFMEMORY even though CoInitialize succeeded and the object is
registered correctly.
<P>
NOTE: This problem has been fixed in Windows NT 4.0. CoGetClassObject
and CoCreateInstance will no long fail if the application has called
RpcServerListen or RpcMgmtWaitServerListen.
<P>
<P><h2>CAUSE</h2>
 
<P>
OLE is also acting as a RPC server. If the application calls
RpcServerListen or RpcMgmtWaitServerListen before OLE calls
RpcServerListen, OLE's call to RpcServerListen will return
RPC_S_ALREADY_LISTENING. This is correct behavior in a RPC server
application because RPC allows only a single thread to block waiting for
RPC client requests. Unfortunately, OLE treats this return value as an
error rather than success.
<P>
<P><h2>RESOLUTION</h2>
 
<P>
To instantiate and use COM objects in an RPC server application, you need
to force OLE to call RpcServerListen first. The application should then
expect its own call to RpcServerListen to return RPC_S_ALREADY_LISTENING,
which should be treated as success.
<P>
Simply calling CoInitialize or OleInitialize is not sufficient to get OLE
to call RpcServerListen. OLE calls RpcServerListen the first time it
marshals an interface. Therefore, the application must marshal an interface
before calling RpcServerListen. This can be done by calling APIs such as
CoRegisterClassObject or CoMarshalInterface. For example, after calling
CoInitialize, the application can register a dummy class factory with
CoRegisterClassObject and then immediately revoke it with
CoRevokeClassObject.
<P>
<P><h2>STATUS</h2>
 
<P>
This behavior is by design.
<P>
<P><h2>MORE INFORMATION</h2>
 
<P>
An RPC server application receives RPC calls via the RPC libraries, which
create a pool of threads for dispatching RPC calls within the server
application. An incoming call is assigned to a thread from the pool, which
unmarshals the parameters and calls the appropriate RPC interface method in
the server. This allows multiple RPC calls to be serviced simultaneously.
<P>
Because the RPC server application has no control over which thread is used
for any given call, the RPC server must be aware of and follow the rules of
the Apartment Model of OLE threading supported by Windows 95 and Windows NT
(beginning with version 3.51) if it will also be acting as a COM client. In
some simple cases, you may just need to use a sequence of CoInitialize,
CoCreateInstance, use and release the object, and CoUninitialize all within
an individual RPC method call. Other cases may require using separate
threads with message loops (apartments) to own the objects and marshaling
of interfaces between threads.
<P>
For more information on the Apartment Model, look up "Processes and
Threads" in the OLE Programmer's Reference included with the Win32 SDK
online documentation, or see the OLE Release Notes included with the Win32
SDK for Windows 95 and Windows NT 3.51 (Mstools\Samples\Ole\Olerel.wri).
<P>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
Additional reference words: 2.0 2.00 4.00<BR>
KBCategory: kbole kbprg kbprb<BR>
KBSubcategory: LeTwoCom<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  July 25, 1996</FONT>
	<BR>
	<A HREF="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
