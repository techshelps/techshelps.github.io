

<HTML>
<HEAD>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>INF: Multiple Active Microsoft SQL Server Statements </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q140896">
<META NAME="KBModify" CONTENT="1997/05/02">
<META NAME="KBCreate" CONTENT="1995/12/07">
<META NAME="Keywords" CONTENT="kbenv kbinterop kbusage ODBC SSrvProg SSrvStProc">
<META NAME="KBArea" CONTENT="Support; KB; sqlserver">
<META NAME="Description" CONTENT="  This article discusses when multiple active statement handles are allowed on an ODBC connection handle with Microsoft SQL Server 6.0 or later. You can find additional information on this topic in the chapter on the Microsoft SQL Server driver in th...">
<META NAME="Product" CONTENT="SQL Server">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QABM,QA9E,QAB9,QAPN,QAO2,QAU9,QAGI,QBG2,QBXS,QAI5 V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>INF: Multiple Active Microsoft SQL Server Statements</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  May 2, 1997</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q140896</B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



<P><h3> </h3>
 
The information in this article applies to:

<UL><LI>Microsoft SQL Server, versions 6.0 &amp; 6.5
<LI>Microsoft Open Database Connectivity, version 2.50
</UL> 
<P>
<P><h2>SUMMARY</h2>
 
<P>
This article discusses when multiple active statement handles are allowed
on an ODBC connection handle with Microsoft SQL Server 6.0 or later. You
can find additional information on this topic in the chapter on the
Microsoft SQL Server driver in the book "Inside ODBC" by Kyle Geiger,
published by Microsoft Press.
<P>
<P><h2>MORE INFORMATION</h2>
 
<P>
This information applies to Microsoft SQL Server ODBC Drivers version
2.50.0121 or later when running against Microsoft SQL Server version 6.0 or
later. Earlier versions of the Microsoft driver or Microsoft SQL Server do
not support multiple active statements on a connection handle. If you are
using third party SQL Server ODBC drivers, you should review the
documentation accompanying the driver to see if it supports multiple active
statements with SQL Server 6.0.
<P>
Prior to SQL Server 6.0, Microsoft SQL Servers did not support multiple
active statement handles on a single ODBC connection handle. This is due to
the architecture of SQL Server's network layers. After the server has built
a result set, it has to send the entire result set to the client before it
will accept a new operation from the client. Client fetch requests do not
have to be sent back to the server, they simply read the next row available
in the network buffer. The server will accept only one type of request from
a client before the result set has been completely sent -- a 'cancel'
command canceling the processing of the result set. Because of this
architecture, no SQL Server clients, either DB-Library or ODBC, can process
more than one result set at a time on a connection handle.
<P>
SQL Server 6.0 does not change this network architecture, but it does
introduce server-side cursors that can be used to open multiple cursors on
a single connection handle. This can be done because each cursor operation
in the ODBC driver generates one individual cursor command which is sent to
SQL Server. When the result set for each cursor command has been received
back at the client, SQL Server considers the command to have completed and
it will accept another command from another statement handle over that
connection handle.
<P>
For example, an application can:
<P>
<PRE>   SQLAllocEnv(&amp;henv):
   SQLAllocConnect(henv, &amp;hdbc);
   SQLAllocStmt(hdbc, &amp;hstmt1);
   SQLAllocStmt(hdbc, &amp;hstmt2);
   SQLSetConnectOption(hdbc, SQL_CURSOR_TYPE, SQL_CURSOR_DYNAMIC);
   SQLSetConnectOption(hdbc, SQL_ROWSET_SIZE, 5);
   SQLExecDirect(hstmt1, "select * from authors", SQL_NTS);

</PRE>When the SQLExecDirect() on hstmt1 is executed, the Microsoft SQL Server
ODBC driver will issue a cursor open request. When SQL Server completes the
cursor open, it considers the command to be finished and will allow the
application to then issue a command on another hstmt:
<P>
<PRE>   SQLExecDirect(hstmt2, "select * from titles", SQL_NTS);

</PRE>Once again, after the server has finished with the cursor open request
issued by the client, it considers the statement to be completed. If at
this point the ODBC application does:
<P>
<PRE>  SQLExtendedFetch(hstmt1, SQL_FETCH_NEXT, 1, ...);

</PRE>the ODBC driver will send to SQL Server a cursor fetch for the first five
rows of the result set. Once the server has transferred the five rows to
the driver, it considers the fetch processing completed and will accept new
requests. The application could then do a fetch on the cursor opened for
the other statement handle:
<P>
<PRE>   SQLExtendedFetch(hstmt2, SQL_FETCH_NEXT, 1, ...);

</PRE>SQL Server will accept this second command on the connection handle
because, as far as it is concerned, it has completed the last command on
the connection handle, which was the fetch of the first five rows of the
rows for hstmt1.
<P>
This process only works when the ODBC driver uses server cursors. As
documented in the Microsoft SQL Server ODBC Driver documentation, the
driver uses server cursors except when the following statement options are
set:
<P>
<PRE>   SQL_CONCURRENCY = SQL_CONCUR_READ_ONLY
   SQL_CURSOR_TYPE = SQL_CURSOR_FORWARD_ONLY
   SQL_ROWSET_SIZE = 1

</PRE>The ODBC driver does use server-side cursors for all other options when
executing a single SELECT statement, or a stored procedure that contains
only a single SELECT statement. The current implementation of server
cursors in SQL Server 6.0 itself does not support batches of SQL statements
or stored procedures that have more than one SELECT statement.
<P>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
Additional query words: sql6 odbc concurrent<BR>
Keywords            : kbenv kbinterop kbusage ODBC SSrvProg SSrvStProc<BR>
Version             : 2.5 6.0<BR>
Platform            : WINDOWS<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  May 2, 1997</FONT>
	<BR>
	<A HREF="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
