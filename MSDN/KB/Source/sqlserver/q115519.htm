

<HTML>
<HEAD>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>INF: How to Scan SQL Errorlog or DBCC Output for Errors </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q115519">
<META NAME="KBModify" CONTENT="1997/04/29">
<META NAME="KBCreate" CONTENT="1994/05/29">
<META NAME="Keywords" CONTENT="kbusage SSrvErr_Log SSrvWinNT">
<META NAME="KBArea" CONTENT="Support; KB; sqlserver">
<META NAME="Description" CONTENT="  It is necessary to frequently examine DBCC output and the SQL error logs to check for problems. This can be an error-prone or laborious process, especially if you must do this on several servers, each of which may have multiple databases.  Windows ...">
<META NAME="Product" CONTENT="SQL Server">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QAB4,QAAP,QATX,QABM,QAHH,QA5A,QBWP,QAKP,QBXN,QAPF,QAIJ,QABH,QABA,QAHG,QDMH V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>INF: How to Scan SQL Errorlog or DBCC Output for Errors</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  April 29, 1997</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q115519</B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



<P><h3> </h3>
 
The information in this article applies to:
<P>
<PRE>  - Microsoft SQL Server, version 4.2
</PRE> 
<P>
<P><h2>SUMMARY</h2>
 
<P>
It is necessary to frequently examine DBCC output and the SQL error logs to
check for problems. This can be an error-prone or laborious process,
especially if you must do this on several servers, each of which may have
multiple databases.
<P>
Windows NT ships with a powerful pattern-searching utility called
FINDSTR.EXE, which can be used to greatly automate this task. It is even
possible to conditionally execute a batch file based on whether certain
error strings are found. This article describes how to do this, including
examples.
<P>
<P><h2>MORE INFORMATION</h2>
 
<P>
Findstr is a high-performance pattern searching utility that uses Win32
asynchronous and file-mapped I/O for best throughput. It allows the use of
regular expressions, recursive searching down a directory tree, and the
ability to exclude patterns thus achieving a NOT function. See your Windows
NT documentation for more information.
<P>
There are two basic approaches to searching SQL error logs or DBCC output
for errors:
<P>
<PRE>   1. State explicitly what strings to find.

   2. State what strings you do not want to find, which will show you
      all but these.

</PRE>In the first approach, you build a list of strings that define errors you
want findstr to match. This list of strings can be supplied as an input
file to findstr.
<P>
For example, say you want to find any occurrences of these strings "table
corrupt" (which accompanies many serious data errors), and "msg 605" (which
is a specific type of error). Place into a file these strings, so the
content simply looks like this:
<P>
<PRE>   table corrupt
   msg 605

</PRE>Run findstr on the DBCC output files using this syntax:
<P>
<PRE>   findstr /i /g:search.txt dbcc.* &gt; findstr.out

</PRE>where SEARCH.TXT is the file containing the search strings, and dbcc.*
matches a group of dbcc output files to search, and FINDSTR.OUT is where
the search results are placed.
<P>
The challenge with this approach is knowing ahead of time what error
strings to search for. Unfortunately, there is no comprehensive list of SQL
error strings which encompasses all possible DBCC, server, and kernel
errors. However, merely searching for these strings may provide fairly good
coverage as a starting point: "table corrupt", "level 16", "level
17"..."level 21", "Severity: 16", "Severity: 17"..."Severity: 21."
<P>
Using a little experimentation, it is usually possible to further refine
this and get fairly reliable checking (certainly more reliable than doing
so by eye).
<P>
The other approach involves using the "reverse match" capability of findstr
to exclude a list of search strings. This approach is more easily applied
to DBCC output than to error log output, since there are fewer distinct
strings which require exclusion. In some ways this approach, if applicable,
is safer since you are only explicitly stating what NOT to match, and any
new or unanticipated errors will be shown by default.
<P>
For example, say you want to exclude all strings in a series of DBCC output
files which contain the strings "The total number", "Table has", and
"checking". Study indicates this will exclude many non-essential DBCC
status messages, and will not result in loss of any errors. Place into a
file these strings, so that the contents simply looks like this:
<P>
<PRE>   The total number
   Table has
   checking

</PRE>Run findstr on the DBCC output files using this syntax:
<P>
<PRE>   findstr /v /i /g:search.txt dbcc.* &gt; findstr.out

</PRE>where SEARCH.TXT is the file containing the search strings, and dbcc.*
matches a group of dbcc output files to search, and findstr.out is where
the search results are placed. The /v parameter indicates "reverse match",
which effectively matches all strings except those in the list.
<P>
Here is a sample exclusion list for error logs, which will filter out non-
essential messages and let through most significant errors.
<P>
<PRE>   Copyright
   All rights reserved
   Logging SQL Server
   initconfig: number
   SQL Server is start
   initializing virtual
   Opening Master Data
   Loading SQL Server
   Recovering Database
   Recovery dbid
   transactions roll
   Activating disk
   initializing virtual
   server name is
   Clearing
   Using 'SQLEVENT.DLL
   Using 'OPENDSNT.DLL
   Using 'NTWDBLIB.DLL
   Using 'SSNMPNTW.DLL
   rolled forward
   default sort
   nocase
   default character
   recovery complete
   terminating due
   windows nt
   (id =
   killed by hostname
   17824
   17825
   1608
   17832
   OS error : 109
   OS error : 232
   unable to write to
   restrictions
   contracts
   server is unnamed
   no_log
   working thread
   Sybase
   network error
   united states
   unable to read login
   duplication
   subdivision
   clause
   number of buffers
   using asynchronous disk
   pipe name is
   number of proc buffers
   network information
   file descriptors
   transactions before ckpt
   shutdown by request

</PRE>In some cases combining these two approaches blends the best
characteristics of both, or at least allows working around difficult
problems which arise from using just one.
<P>
For example, say you are searching your error logs for the strings
"Severity: 16", "Severity: 17"..."Severity: 21", which should match most
serious errors. But you notice in your search output several communication-
related errors such as 1608 and 17832 that are normally not indicative of a
serious problem. You can keep your original search conditions, and exclude
only these specific unwanted errors from the search output by piping one
findstr command into another:
<P>
<PRE>   findstr /i /g:search.txt errorlog*.* | findstr
   /v /i /g:exclude.txt &gt; f.out

</PRE>where search.txt is the file containing the search strings, and errorlog*.*
are your SQL error log files to search, and EXCLUDE.TXT is the file
containing the search strings to exclude, and F.OUT is where the search
results are placed. This approach can be cascaded several levels deep,
excluding successively more at each level.
<P>
It is possible to write a batch file which conditionally takes action based
on whether findstr detects a certain error string. This technique uses the
Windows NT conditional processing commands which are "&amp;&amp;" and "||". The
following command executes the batch file BATCH1.BAT if any of the SQL
error strings in the file SEARCH.TXT are found:
<P>
<PRE>   findstr /i /g:search.txt errorlog*.* &amp;&amp; batch1

</PRE>BATCH1.BAT could invoke a program, or even run an ISQL job which uses the
xp_sendmail capability of SQL Server 4.21 to send a mail message, notifying
an operator of a problem.
<P>
The above techniques can be combined to perform a variety of tasks. For
example the following batch file will continuously run a findstr command
that conditionally executes BATCH1.BAT if any of the SQL error strings in
the file SEARCH.TXT are found, excluding the strings in EXCLUDE.TXT.
<P>
<PRE>   echo off
   :start
   findstr /i /g:search.txt errorlog*.* | findstr
   /v /i /g:exclude.txt &amp;&amp; (echo WARNING &amp; batch1)
   goto start

</PRE>With a little experimentation you will find these techniques can be very
helpful in reducing the labor involved in searching SQL error log and DBCC
output files. These same techniques can also be used for any general text-
searching task, not just those related to SQL Server.
<P>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
Additional query words: errorlogs Windows NT<BR>
Keywords            : kbusage SSrvErr_Log SSrvWinNT<BR>
Version             : 4.2<BR>
Platform            : WINDOWS<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  April 29, 1997</FONT>
	<BR>
	<A HREF="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
