

<HTML>
<HEAD>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Accessing Global Symbols Defined in C from MASM </TITLE>

<!--STYLE_BEGIN-->
<LINK REL="STYLESHEET" HREF="/support/kbstyle.css" TYPE="text/css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q102434">
<META NAME="KBModify" CONTENT="1995/01/06">
<META NAME="KBCreate" CONTENT="1993/08/03">
<META NAME="Keywords" CONTENT="kbprg">
<META NAME="KBArea" CONTENT="Support; KB; masm">
<META NAME="Description" CONTENT="  The code example below demonstrates accessing the following variable types from an assembly language program when the data is defined in a C module:     a global variable    a global variable through a far pointer    a global structure    a global ...">
<META NAME="Product" CONTENT="Macro Assembler">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QAYA,QAEF,QAYL,QAO3,QAO2,QAH4,QA7H,QAYY,QANG,QAXC,QAGI,QAIC,QA4Q,QBFY,QAC2 V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>Accessing Global Symbols Defined in C from MASM</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  January 6, 1995</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q102434</B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
The information in this article applies to:

<UL><LI>Microsoft Macro Assembler for MS-DOS, versions 6.0, 6.0a, 6.0b,
   6.1, 6.1a, and 6.11
<LI>Microsoft Macro Assembler for OS/2, versions 6.0, 6.0a, and 6.0b
</UL> 
<P>
<P><h2>SUMMARY</h2>
 
<P>
The code example below demonstrates accessing the following variable
types from an assembly language program when the data is defined in a
C module:
<P>
<PRE>   a global variable
   a global variable through a far pointer
   a global structure
   a global pointer to a global array of structures.

</PRE><h2>MORE INFORMATION</h2>
 
<P>
None of the global variables are specified as arguments in the call to
the assembly language procedure.
<P>
The .FARDATA directive instructs the assembler to place initialized
variables into the FAR_DATA segment. The .FARDATA? directive instructs
the assembler to place unitialized variables into the FAR_BSS data
segment. For more information on creating data segments, please refer
to pages 44 and 45 of the Microsoft Macro Assembler "Programmer's
Guide" for versions 6.0x and pages 39 and 40 of the Microsoft Macro
Assembler "Programmer's Guide" for versions 6.1x.
<P>
<P><h3>Sample Code</h3>
 
<P>
<PRE>/*
 * Compiler options needed: /AL
 */

#include &lt;stdio.h&gt;

int func1(void);       /* assembly language procedure */
int var1 = 1;
int var2 = 3;
int *ptr2;

</PRE>struct var_tag
{
<PRE>   int var3;
   int var4;
</PRE>} * struct_ptr, struct_var = {5, 7}, v_ray[2] = {{9, 11}, {13, 15}};
<P>
<PRE>void main(void)
</PRE>{
<PRE>   ptr2 = &amp;var2;                /* pointer to variable             */
   struct_ptr = v_ray;          /* pointer to array of structures  */

   printf("After the call to func1(), all values should be doubled.\n");

   printf("\nBefore...\n\n");
   printf("VAR1 is %d\n", var1);
   printf("VAR2 is %d\n", var2);
   printf("struct_var.var3 = %2d,\tstruct_var.var4 = %2d\n",
      struct_var.var3, struct_var.var4);
   printf("v_ray[0].var3   = %2d,\tv_ray[0].var4   = %2d\n",
      struct_ptr[0].var3, struct_ptr[0].var4);
   printf("v_ray[1].var3   = %2d,\tv_ray[1].var4   = %2d\n",
      struct_ptr[1].var3, struct_ptr[1].var4);

   printf("\nCalling func1()...\n");

   func1();                     /* call to assembly procedure */

   printf("\nAfter...\n\n");
   printf("VAR1 is %d\n", var1);
   printf("VAR2 is %d\n", var2);
   printf("struct_var.var3 = %2d,\tstruct_var.var4 = %2d\n",
      struct_var.var3, struct_var.var4);
   printf("v_ray[0].var3   = %2d,\tv_ray[0].var4   = %2d\n",
      struct_ptr[0].var3, struct_ptr[0].var4);
   printf("v_ray[1].var3   = %2d,\tv_ray[1].var4   = %2d\n",
      struct_ptr[1].var3, struct_ptr[1].var4);
</PRE>}
<P>
;=====================================================================
; Assembly module with procedure "func1" called from C module above.
; Assembler options needed: none
<P>
<PRE>info struct                 ; template for structure
   variable_3 DW ?          ;  member offsets
   variable_4 DW ?
</PRE>info ends
<P>
<PRE>.MODEL large, C             ; Specify a language for the externals
</PRE>.8086
<P>
.FARDATA
EXTERN var1:word
<PRE>EXTERN ptr2:dword           ; pointer to var2
</PRE>EXTERN struct_var:dword
<PRE>EXTERN struct_ptr:dword     ; pointer to array of structures

</PRE>.CODE
<P>
func1 PROC uses ax dx di es
<P>
;;;;;;;;;;;;;;;;;;;;;;; Use Variable ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
<PRE>   mov dx, SEG var1         ; get the segment of var1
   mov es, dx
   mov di, OFFSET var1      ; get the offset of var1

   mov dx, es:[di]          ; dereference address to modify value
   shl dx, 1
   mov es:[di], dx

</PRE>;;;;;;;;;;;;;;;;;;;;;; Use pointer to variable ;;;;;;;;;;;;;;;;;;;;
<PRE>   mov dx, SEG ptr2        ; get the segment of pointer
   mov es, dx
   mov di, OFFSET ptr2     ; get the offset of pointer

   mov dx, es:[di+2]       ; dereference ptr to get
                           ; the segment of var2
   mov ax, es:[di]         ; dereference ptr to get the offset of var2
   mov es, dx
   mov di, ax

   mov ax, es:[di]         ; dereference address to modify value
   shl ax, 1
   mov es:[di], ax

</PRE>;;;;;;;;;;;;;;;;;;;;; Use structure ;;;;;;;;;;;;;;;;;;;;;;;;;;;
<PRE>   mov dx, SEG struct_var      ; get structure segment
   mov es, dx
   mov di, OFFSET struct_var   ; get structure offset

   mov ax, es:[di]             ; dereference address to modify var3
   shl ax, 1
   mov es:[di], ax

   mov ax, (info ptr es:[di]).variable_4
                               ; offset determined by info template

   ; Alternative instruction to line of code above
   ; mov ax, es:[di+2]         ; dereference address to modify var4

   shl ax, 1
   mov (info ptr es:[di]).variable_4, ax

   ; Alternate instruction to line above
   ; mov es:[di+2], ax

</PRE>;;;;;;;;;;;;;;;;;; Use pointer to array of structures ;;;;;;;;;
<PRE>   ; ===modifies structure[0]===
   mov dx, SEG struct_ptr      ; get pointer segment
   mov es, dx
   mov di, OFFSET struct_ptr   ; get pointer offset

   mov dx, es:[di+2]           ; dereference pointer to get
                               ; segment of v_ray
   mov ax, es:[di]             ; dereference pointer to get
                               ; offset of v_ray
   mov es, dx
   mov di, ax

   mov ax, es:[di]             ; dereference address to modify var3
   shl ax, 1
   mov es:[di], ax

   mov ax, (info ptr es:[di]).variable_4
                               ; offset determined by info template
   shl ax, 1
   mov (info ptr es:[di]).variable_4, ax

   ;=== modifies structure[1] ===
   mov ax, es:[di+4]           ; advance to next element of array
   shl ax, 1                   ; and modify var3
   mov es:[di+4], ax

   mov ax, (info ptr es:[di+4]).variable_4
                               ; offset determined by info template
   shl ax, 1
   mov (info ptr es:[di+4]).variable_4, ax

   ret
</PRE>func1 ENDP
<P>
END
<P>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
Additional reference words: 6.00 6.00a 6.00b 6.10 6.10a<BR>
KBCategory: kbprg<BR>
KBSubcategory: MASMLngIss<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  January 6, 1995</FONT>
	<BR>
	<A HREF="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
