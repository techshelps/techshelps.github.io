

<HTML>
<HEAD>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>HOWTO: Using VC++ to Start an Active Messaging Session </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q173550">
<META NAME="KBModify" CONTENT="1997/11/21">
<META NAME="KBCreate" CONTENT="1997/09/08">
<META NAME="Keywords" CONTENT="kbcode ActMsg">
<META NAME="KBArea" CONTENT="Support; KB; mapi">
<META NAME="Description" CONTENT="  This article covers these three primary ways to create and then logon to an Active Messaging Session from Visual C++:   - With prompt for Profile   - Without prompt for Profile   - Creating a dynamic Profile on the fly  MORE INFORMATION  With Promp...">
<META NAME="Product" CONTENT="mapi">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QANE,QDJ2,QAI5,QAV5,QAM2,QACF,QAUJ,QAL7,QAFX,QAYC,QA62,QBW7,QBW4,QBHQ,QA6A V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>HOWTO: Using VC++ to Start an Active Messaging Session</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  November 21, 1997</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q173550</B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
 
The information in this article applies to:

<UL><LI>Collaboration Data Objects (CDO), version 1.1
</UL> 
<P>
<P><h2>SUMMARY</h2>
 
<P>
This article covers these three primary ways to create and then logon to an
Active Messaging Session from Visual C++:

<UL><LI>With prompt for Profile

<LI>Without prompt for Profile

<LI>Creating a dynamic Profile on the fly
<P>
</UL><h2>MORE INFORMATION</h2>
 
<P>
<P><h3>With Prompt for Profile</h3>
 
<P>
<PRE>    /**********************************************************/
    // W_PROMPT.CPP
    // ------------
    // This program demonstrates how to use the Session-&gt;Logon
    // of the Active Messaging Library v1.1 via VC++, to prompt
    // the user for a Profile at Logon.  This sample requires
    // VC++ version 5.0 or higher.
    /**********************************************************/

    #import &lt;olemsg32.dll&gt; no_namespace

    #include &lt;assert.h&gt;
    #include &lt;stdio.h&gt;
    #include &lt;tchar.h&gt;

    void dump_com_error(_com_error &amp;e)
    {
       _tprintf(_T("Oops - hit an error!\n"));
       _tprintf(_T("\a\tCode = %08lx\n"), e.Error());
       _tprintf(_T("\a\tCode meaning = %s\n"), e.ErrorMessage());
       _bstr_t bstrSource(e.Source());
       _bstr_t bstrDescription(e.Description());
       _tprintf(_T("\a\tSource = %s\n"), (LPCTSTR) bstrSource);
       _tprintf(_T("\a\tDescription = %s\n"), (LPCTSTR) bstrDescription);
    }

    // If this is placed in the scope of the smart pointers, they must be
    // explicitly Release(d) before CoUninitialize() is called.  If any
    // reference count is non-zero, a protection fault will occur.
    struct StartOle {
      StartOle() { CoInitialize(NULL); }
      ~StartOle() { CoUninitialize(); }
    } _inst_StartOle;

    void main()
    {
    try
      {
          // Create a MAPI.Session pointer
          SessionPtr pSession("MAPI.Session");

          // Logon prompting the user for a profile
          pSession-&gt;Logon;

          // The remaining functionality of your app takes place here

          // Logoff of the MAPI Session
          pSession-&gt;Logoff();
      }
      catch (_com_error &amp;e)
      {
          dump_com_error(e);
      }
    }

</PRE><h3>Without Prompt for Profile</h3>
 
<P>
<PRE>    /**********************************************************/
    // WO_PROMPT.CPP
    // -------------
    // This program demonstrates how to use the Session-&gt;Logon
    // of the Active Messaging Library v1.1 via VC++, to not
    // prompt the user for a Profile at Logon.  This sample
    // requires VC++ version 5.0 or higher.
    /**********************************************************/

    #import &lt;olemsg32.dll&gt; no_namespace

    #include &lt;assert.h&gt;
    #include &lt;stdio.h&gt;
    #include &lt;tchar.h&gt;

    void dump_com_error(_com_error &amp;e)
    {
       _tprintf(_T("Oops - hit an error!\n"));
       _tprintf(_T("\a\tCode = %08lx\n"), e.Error());
       _tprintf(_T("\a\tCode meaning = %s\n"), e.ErrorMessage());
       _bstr_t bstrSource(e.Source());
       _bstr_t bstrDescription(e.Description());
       _tprintf(_T("\a\tSource = %s\n"), (LPCTSTR) bstrSource);
       _tprintf(_T("\a\tDescription = %s\n"), (LPCTSTR) bstrDescription);
    }

    // If this is placed in the scope of the smart pointers, they must be
    // explicitly Release(d) before CoUninitialize() is called.  If any
    // reference count is non-zero, a protection fault will occur.
    struct StartOle {
      StartOle() { CoInitialize(NULL); }
      ~StartOle() { CoUninitialize(); }
    } _inst_StartOle;

    void main()
    {
    try
      {
          // Create a MAPI.Session pointer
          SessionPtr pSession("MAPI.Session");

          // Logon using the specified profile
          pSession-&gt;Logon("YourValidProfileNameGoesHere");

          // The remaining functionality of your app takes place here

          // Logoff of the MAPI Session
          pSession-&gt;Logoff();
      }
      catch (_com_error &amp;e)
      {
          dump_com_error(e);
      }
    }

</PRE><h3>Creating a Dynamic Profile on the Fly</h3>
 
<P>
<PRE>    /**********************************************************/
    // DYN_PROF.CPP
    // ------------
    // This program demonstrates how to use the Session-&gt;Logon
    // of the Active Messaging Library v1.1 via VC++, to create
    // a dynamic Profile at Logon. This is the likely method to
    // use if the application will be run as a Windows NT Service.
    //
    // The key point of this sample is the final parameter to the
    // logon, which allows for creation of a temporary profile
    // for the session. The Active Messaging Library generates a
    // random name for the profile.
    //
    // For an authenticated profile, the format of the string is:
    //
    //   &lt;server name&gt; + \n + &lt;mailbox name&gt;
    //
    // where the server and mailbox names can be unresolved. Note
    // that the mailbox name is not the messaging user's display
    // name, but rather the alias or account name used internally
    // by the user's organization. For example, "johnd" should be
    // used instead of "John Doe".
    //
    // For an anonymous profile, the format is:
    //
    //   &lt;server distinguished name&gt; + \n\n + "anon"
    //
    // where the distinguished name of the server takes the form:
    //
    //   /o=&lt;enterprise&gt;/ou=&lt;site&gt;/cn=Configuration/cn=Servers/cn=&lt;server&gt;
    //
    //
    // This sample demonstrates an authenticated logon, and
    // requires Visual C++ version 5.0 or higher.
    /**********************************************************/

    #import &lt;olemsg32.dll&gt; no_namespace

    #include &lt;assert.h&gt;
    #include &lt;stdio.h&gt;
    #include &lt;tchar.h&gt;

    void dump_com_error(_com_error &amp;e)
    {
       _tprintf(_T("Oops - hit an error!\n"));
       _tprintf(_T("\a\tCode = %08lx\n"), e.Error());
       _tprintf(_T("\a\tCode meaning = %s\n"), e.ErrorMessage());
       _bstr_t bstrSource(e.Source());
       _bstr_t bstrDescription(e.Description());
       _tprintf(_T("\a\tSource = %s\n"), (LPCTSTR) bstrSource);
       _tprintf(_T("\a\tDescription = %s\n"), (LPCTSTR) bstrDescription);
    }

    // If this is placed in the scope of the smart pointers, they must be
    // explicitly Release(d) before CoUninitialize() is called.  If any
    // reference count is non-zero, a protection fault will occur.
    struct StartOle {
      StartOle() { CoInitialize(NULL); }
      ~StartOle() { CoUninitialize(); }
    } _inst_StartOle;

    void main()
    {
    try
      {
          // Create a MAPI.Session pointer
          SessionPtr pSession("MAPI.Session");

          // Create the params used in the Logon including the
          // string used for the ProfileInfo
          VARIANTARG vBoolF;
          vBoolF.vt = VT_BOOL;
          vBoolF.boolVal = FALSE;
          VARIANTARG vBoolT;
          vBoolT.vt = VT_BOOL;
          vBoolT.boolVal = TRUE;

          char * pstrProfileInfo ;

          //Modify malloc param to size needed by your app
          pstrProfileInfo = (char *) malloc (27) ;
          strcpy (pstrProfileInfo, "MyServerName\nMyMailBoxName") ;

          // Logon using the specified profile
          // params: profileName, profilePassword, showDialog,
          //         newSession, parentWindow, NoMail, ProfileInfo
          pSession-&gt;Logon("",
                          "",
                          vBoolF,
                          vBoolT,
                          vBoolF,
                          vBoolF,
                          pstrProfileInfo);

          // Display generated ProfileName to prove the we are logged on
          MessageBoxW(NULL,pSession-&gt;Name.bstrVal,L"",MB_OK) ;

          // The remaining functionality of your app takes place here

          // Logoff of the MAPI Session
          pSession-&gt;Logoff();
      }
      catch (_com_error &amp;e)
      {
          dump_com_error(e);
      }
    }

</PRE><h2>REFERENCES</h2>
 
<P>
For information on obtaining the Active Messaging Library, please see the
following article in the Microsoft Knowledge Base:
<P>
<PRE>   ARTICLE-ID: <B><A HREF="../MAPI/Q171440.htm">Q171440</A></B>
   TITLE     : INFO: Where to Acquire the Active Messaging Libraries


</PRE>For additional information about Collaboration Data Objects versus Active
Messaging, please see the following article in the Microsoft Knowledge
Base:
<P>
<PRE>   ARTICLE-ID: <B><A HREF="../MAPI/Q176916.htm">Q176916</A></B>
   TITLE     : INFO: Active Messaging and Collaboration Data Objects (CDO)

</PRE>The Microsoft Developer Network, January 1997 or later.
<P>
 
<PRE>Keywords          : kbcode ActMsg
Version           : WINDOWS:1.1
Platform          : WINDOWS
Issue type        : kbhowto</PRE>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
================================================================================<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  November 21, 1997</FONT>
	<BR>
	<A HREF="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
