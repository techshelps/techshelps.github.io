

<HTML>
<HEAD>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>The DCB Structure in Windows 3.1 </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q101419">
<META NAME="KBModify" CONTENT="1997/07/23">
<META NAME="KBCreate" CONTENT="1993/07/13">
<META NAME="Keywords" CONTENT="kb16bitonly">
<META NAME="KBArea" CONTENT="Support; KB; win16sdk">
<META NAME="Description" CONTENT="  The data control block (DCB) structure defines the control setting for a serial communications device. OpenComm() and BuildCommDCB() both initialize a DCB structure. However, there are many fields in the DCB that cannot be changed using these proce...">
<META NAME="Product" CONTENT="Win16 SDK">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QBXS,QA7O,QAKD,QAUD,QA7N,QAKC,QBBI,QAAP,QAB4,QAHE,QABA,QDJH,QAB5,QAWN,QAOE V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>The DCB Structure in Windows 3.1</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  July 23, 1997</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q101419</B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
3.10
WINDOWS
kbprg
<P>
 
The information in this article applies to:

<UL><LI>Microsoft Windows Software Development Kit (SDK) for Windows,
   version 3.1
</UL> 
<P>
<P><h2>SUMMARY</h2>
 
<P>
The data control block (DCB) structure defines the control setting for
a serial communications device. OpenComm() and BuildCommDCB() both
initialize a DCB structure. However, there are many fields in the DCB
that cannot be changed using these procedures. These fields can be
updated directly, and these changes can be applied to the
communications port using SetCommState().
<P>
<P><h2>MORE INFORMATION</h2>
 
<P>
OpenComm() uses BuildCommDCB() with "COM1:9600, E, 7, 1" as the
lpszDef parameter to build a default DCB. OpenComm() internally calls
SetCommState() with this default DCB to set the initial state of the
communications port.
<P>
BuildCommDCB() can be used to initialize a DCB with certain settings.
This procedure takes a string in the same format as the MS-DOS mode
command for its lpszDef parameter. For example,
BuildCommDCB("COM1:9600, n, 8, 1", &amp;myDCB) sets myDCB to have a baud
rate of 9600, no parity, 8-bit byte size, and 1 stop bit. This string
needs to contain only the COM port and baud rate; if the other values
are absent, they will default. The default settings are even parity,
byte size of 7, and 1 stop bit. SetCommState() must be called to put
the new DCB settings into effect.
<P>
SetCommState() takes a DCB as a parameter, and sets the port according
to all the parameters. A DCB can be initialized by calling
BuildCommDCB() or the current settings can be returned by calling
GetCommState(). In addition, the fields in the DCB can be modified
directly. After a DCB is changed, SetCommState() must be used to apply
the setting to the port.
<P>
Below is a summary of all the DCB fields. Each field has a description
of what happens in BuildCommDCB(). The information that follows
SetCommState() indicates how the DCB can be manipulated manually. That
DCB can then be used in the lpDCB parameter to SetCommState().
<P>
Id - The ID of the port. This is set by BuildCommDCB(), and is the
<PRE>     same as the OpenComm() return value.

</PRE>BaudRate - BuildCommDCB() - The baud rate is based on the first two
<PRE>     characters in the baud rate position in the MS-DOS mode string. For
     example, "COM1:96,n,8,1" will set the baud rate to 9600. The only
     baud rates that can be set are 110, 150, 300, 600,1200, 2400,
     4800, 9600, and 19200. If none of these baud rates are used,
     BuildCommDCB() returns an error.

     SetCommState() - The BaudRate field can set any baud rate up to 57,600
     by either setting the BaudRate field in the DCB to one of the
     CBR_baudrate constants, or to any number greater than 2 and less
     than CBR_110. Numbers outside this range result in SetCommState()
     returning an IE_BAUDRATE error.

</PRE>ByteSize - BuildCommDCB() - Specifying any number other than 7 or 8
<PRE>     results in an error.

     SetCommState() - The byteSize field can be set to any number between
     4 and 8. Numbers outside this range result in SetCommState()
     returning an IE_BYTESIZE error.

</PRE>Parity - BuildCommDCB - The parity can be set to "E" (even), "O"
<PRE>     (odd), "N" (none), "M" (mark) or "S" (space).

     SetCommState() - The Parity field in the DCB can be set to NOPARITY,
     ODDPARITY, EVENPARITY, MARKPARITY, or SPACEPARITY. Other settings
     result in SetCommState() returning and IE_DEFAULT error.

</PRE>StopBits - BuildCommDCB - Stop bits of 1 or 2 are accepted. Any other
<PRE>     value (including 1.5) returns an error.

     SetCommDCB() - The StopBits field can be set to ONESTOPBIT,
     ONE5STOPBITS, or TWOSTOPBITS. Other settings result in
     SetCommState() returning an IE_DEFAULT error.

</PRE>The time-out field, RlsTimeout, CtsTimeout, or DsrTimeout, enables
time-out checking if its value is anything other than zero. This
time-out checking occurs during WriteComm() regardless of any other
values in the DCB, including fOutxCtsFlow and fOutxDsrFlow. Specifying
INFINITE does not really enable infinite time-out. The value is set to
-1 (which is 65536), which makes the time-out approximately 65
seconds. If a time-out occurs, WriteComm() returns 0 (zero), and
GetCommError() returns a time-out error (CE_CTSTO, CE_DSRTO, or
CE_RLSDTO).
<P>
RlsTimeout - BuildCommDCB() - If the 6th parameter of the MS-DOS mode
<PRE>     string is specified as P, then this time-out is infinite (set to
     -1). Any other value returns an error. If it is not specified, it
     defaults to (zero).

     SetCommDCB() - RlsTimeout can be set to IGNORE, INFINITE, or any
     number.

     This field is the amount of time, in milliseconds, to wait for
     RLSD (same as Carrier Detect) to become high, before copying any
     data to the transmit queue during WriteComm().

</PRE>CtsTimeout - BuildCommDCB() - MS-DOS mode string translated exactly like
<PRE>     RlsTimeout.

    SetCommDCB() - CtsTimeout can be set to IGNORE, INFINITE, or any
    number.

    This field is the amount of time, in milliseconds, to wait for
    CTS (Clear to Send) to become high before copying any data to the
    transmit queue during WriteComm().

</PRE>DsrTimeout - BuildCommDCB() - MS-DOS mode string translated exactly like
<PRE>    RlsTimeout.

    SetCommDCB() - DsrTimeout can be set to IGNORE, INFINITE, or any
    number.

    This field is the amount of time, in milliseconds, to wait for DSR
    (Data Set Ready) to become high before copying any data to the
    transmit queue during WriteComm().

    All of the following flags are set to 0 in BuildCommDCB(), except
    for fBinary, which is set to 1. Any of these can be set to 0 or 1
    before calling SetCommState().

    fBinary - If fBinary is set to zero, reception of the EofChar
        character indicates the end of the input stream. ReadComm()
        will not return any characters past EofChar. If any characters
        are received after EofChar, it will be treated as overflowing
        the receive queue (CE_RXOVER). The reception of EofChar is
        indicated in the COMSTAT status flag CSTF_EOF. If fBinary is
        set to one, the EofChar character has no special meaning.

    fRtsDisable - RTS flow control is used ONLY if fRtsDisable is set
        to 0, and fRtsFlow is set to one. Any other combination will
        disable RTS flow control.

        OpenComm() will set RTS high, and it will remain high unless
        RTS flow control is enabled or fRtsDisable is set.

           fRtsDisable        fRtsFlow         RTS state
           ---------------------------------------------

              0               0                 Set High
              0               1           RTS flow control enabled
              1               0                 Set low
              1               1                 Set low

        CloseComm() does not change the state of RTS or DTR,
        regardless of the state of the disable settings, but it drops
        them momentarily while closing the port.

        If RTS or DTR are not being used for flow control, they can be
        manipulated using EscapeCommFuntion().

    fDtrDisable - Used with fDtrFlow. Functions similar to
        fRtsDisable/fRtsFlow.

    fRtsflow - See fRtsDisable.

    fDtrflow - See fDtrDisable and fRtsDisable.

    fParity - Specifies whether parity checking is enabled. If this
        flag is set, parity checking is performed, and CE_RXPARITY
        errors are reported.

        ReadComm() will return a negative value if it encounters an
        error (such as a parity error). GetCommError()is used to
        retrieve and clear that error. To receive notification of a
        parity error, SetCommEventMask() can be used to enable EV_ERR
        events. GetCommEventMask() should be used to clear the event,
        however, GetCommError() must still be used to clear the error.

    fOutxCtsFlow - Specifies that CTS signal is to be monitored for
        output flow control. If this flag is set and CTS is turned
        off, output is suspended until CTS is again set.

        If the CtsTimeout field contains any value other than zero,
        WriteComm() will wait for CTS, regardless of the value of
        fOutxCtsFlow.

    fOutxDsrFlow - Specifies that DSR signal is to be monitored for
        output flow control. If this flag is set and DSR is turned
        off, output is suspended until DSR is again set.

        If the DsrTimeout field contains any value other than zero,
        WriteComm() will wait for DSR, regardless of the value of
        fOutxDsrFlow.

    fDummy - Reserved.

    fOutX - Specifies that X-on/X-off flow control is used during
        transmission. If this flag is set, transmission stops when the
        XoffChar is received and starts again when the XonChar is
        received.

        If transmission is waiting as a result of the X-off character
        being received, the CSTF_XOFFHOLD flag in the COMSTAT
        structure will be set.

    fInX - Specifies that X-on/X-off flow control is used during
        reception. If this flag is set, the XoffChar character is sent
        when the reception queue comes within XoffLim characters of
        being full and the XonChar character is sent when the
        reception queue comes within XonLim characters of being empty.

        If transmission is waiting as a result of the X-off character
        being transmitted, the CSTF_XOFFSENT flag is set in the
        COMSTAT structure.

    fPeChar - Specifies that characters received with parity errors
        are to be replaced with the character specified by PeChar.

    fNull - Specifies that received null character are to be
        discarded.

    fChEvt - Not actually used.

    fDummy2 - Reserved.

</PRE>XonChar - BuildCommDCB() - Set to 0x11 (CTRL+Q) SetCommState() - Can
<PRE>    be set to any character.

    This field is the X-on character for both transmit and receive.
    See fInX and fOutX.

</PRE>XoffChar - BuildCommDCB() - Set to 0x13 (CTRL+S) SetCommState() - Can
<PRE>    be set to any character.

    This field is the X-off character for both transmit and receive.
    See fInX and fOutX.

</PRE>XonLim - BuildCommSCB() - Set to 10. SetCommState() - Can be set to
<PRE>    any value.

    When the number of characters in the receive queue drops below
    this value, the X-on character is sent, if enabled, and DTR is
    set, if enabled. See fInX and fOutX.

</PRE>XoffLim - BuildCommDCB() - Set to 10. SetCommState() - can be set to
<PRE>    any value.

    When the number of characters in the receive queue exceeds this
    value, the X-off character is sent, if enabled, and DTR is
    dropped, if enabled. See fInX and fOutX.

</PRE>PeChar - BuildCommDCB() - Set to 0. SetCommState() - Can be set to any
<PRE>    character.

    Parity error replacement character. See fPeChar and fParity.

</PRE>EofChar - BuildCommDCB() - Set to 0. SetCommState() - Can be set to
<PRE>    any character.

    Character which specifies end of input. See fBinary.

</PRE>EvtChar - BuildCommDCB() - Set to 0. SetCommState() - Can be set to
<PRE>    any character.

    Specifies the value of the character to be used to signal an
    event. When this value is received, an EV_RXFLAG event will be
    generated. The fChEvt flag is not actually used. Use
    SetCommEventMask() to enable these events.

</PRE>TxDelay - Not actually used.
<P>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
Additional reference words: 3.10<BR>
KBCategory: kbprg<BR>
KBSubcategory: KrCommapi<BR>
Keywords            : kb16bitonly<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  July 23, 1997</FONT>
	<BR>
	<A HREF="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
