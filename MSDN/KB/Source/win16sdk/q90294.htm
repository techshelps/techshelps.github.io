

<HTML>
<HEAD>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Using Large Memory Model, Microsoft C/C++, &amp; Windows 3.1 </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q90294 ">
<META NAME="KBModify" CONTENT="1997/07/23">
<META NAME="KBCreate" CONTENT="1992/10/05">
<META NAME="Keywords" CONTENT="kb16bitonly">
<META NAME="KBArea" CONTENT="Support; KB; win16sdk">
<META NAME="Description" CONTENT="  In Windows version 3.0, using the large memory model with Microsoft C version 6.0 is not recommended. For more information on the problems that occur when using the large memory model under Windows 3.0, query this knowledge base on the following wo...">
<META NAME="Product" CONTENT="Win16 SDK">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QBWN,QDL9,QBWO,QBWQ,QAPF,QBFY,QBW6,QAYY,QAYL,QABA,QBBI,QAH4,QAJH,QAGQ,QA2O V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>Using Large Memory Model, Microsoft C/C++, &amp; Windows 3.1</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  July 23, 1997</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q90294 </B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
3.10
WINDOWS
kbprg
<P>
 
The information in this article applies to:

<UL><LI>Microsoft Windows Software Development Kit (SDK) for Windows
   versions 3.0 and 3.1
</UL> 
<P>
<P><h2>SUMMARY</h2>
 
<P>
In Windows version 3.0, using the large memory model with Microsoft C
version 6.0 is not recommended. For more information on the problems
that occur when using the large memory model under Windows 3.0, query
this knowledge base on the following words:
<P>
<PRE>   large and model and protected

</PRE>Windows version 3.1 and the Microsoft C/C++ version 7.0 compiler have
resolved most of these problems and make the large memory model much
more suitable for developing applications under Windows 3.1.
<P>
<P><h2>MORE INFORMATION</h2>
 
<P>
There are three main problems when using the large memory model under
Windows:

<OL><P><LI>Large model applications can have multiple data segments (this is
   always the case when compiling with Microsoft C 6.0). In Windows
   3.0, these extra segments are loaded as FIXED and page-locked.
   Having a large amount of FIXED page-locked memory results in a
   serious degradation of the memory manager's performance. FIXED
   memory is allocated from the bottom of the global heap, which means
   it normally lies in conventional memory (below 1 MB), which is
   needed by the Windows loader when it loads a new module into
   memory. For more information on this topic, query this knowledge
   base on the following words:
<P>
<P><PRE>      using and memory and below and megabyte
</PRE><P>
   This problem has been corrected in Windows 3.1. In Windows 3.1, an
   application's code and data segments are always loaded as MOVEABLE,
   regardless of the segment attributes specified in the application's
   definition (.DEF) file. A DLL's code and data segments are loaded
   exactly as they are specified in the DLL's .DEF file.

<P><LI>Under both Windows 3.0 and Windows 3.1, only one instance of an
   application with multiple data segments can be run at one time.
   This is because the Windows loader can't fix-up multiple instances
   of a far pointer because code is shared among all instances of an
   application.
<P>
   In most cases, this problem may be resolved by using the /Gx and
   /Gt compile options with the Microsoft C/C++ 7.0 compiler. The /Gx
   option causes the compiler to force static data into the default
   data segment, which results in the application having only one data
   segment. Note, however, that this works only if the application's
   static data, string literals, stack, and heap all fit into a 64K
   segment.
<P>
   The /Gt switch specifies the size a static object must be to be
   allocated its own data segment. When trying to create a single data
   segment, this threshold value should be large enough to ensure
   that no data objects are allocated outside of the default data
   segment. If the /Gt option is not specified, the data threshold
   will be 32767.

<P><LI>The final problem with using large model under both Windows 3.0 and
   Windows 3.1 is the performance degradation that occurs when an
   application uses far pointers to access its data.
<P>
   When running under the protected mode of the Intel 286, 386, and
   486 processors, a far address is a combination of a selector and an
   offset. A selector is essentially an index into an array called a
   descriptor table. A descriptor is an 8-byte value that contains
   information about the segment, such as its base address, size,
   read/write privileges, and so forth.
<P>
   Whenever a far variable is referenced in protected mode, the
   processor must load the descriptor into one of the segment
   registers' descriptor cache and mark the descriptor as being
   accessed. This means that a reference to a far variable requires at
   least two reads from and one write to memory just to obtain the
   variable's linear address.
<P>
   Adding this delay to the time needed for performing far pointer
   arithmetic amounts to a significant loss of performance when
   compared to the medium model, which uses near pointers for data.
   One method to increase the performance of a large model application
   is to explicitly declare commonly used global or static variables
   as being NEAR, which causes the compiler to allocate the variable
   in the default data segment, and to use a near pointer when
   referencing the variable.
<P>
</OL><h3>Conclusion</h3>
 
<P>
Because Windows 3.1 and Microsoft C/C++ 7.0 have resolved most of the
problems related to use of the large memory model, developing
application for Windows 3.1 with the large memory model is much more
acceptable than it was under Windows 3.0 and Microsoft C 6.0.
<P>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
Additional reference words: 3.00 3.10<BR>
KBCategory: kbprg<BR>
KBSubcategory: KrModls<BR>
Keywords            : kb16bitonly<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  July 23, 1997</FONT>
	<BR>
	<A HREF="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
