

<HTML>
<HEAD>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Chaining NotifyRegister Callbacks Issuing Notifications </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q99671 ">
<META NAME="KBModify" CONTENT="1997/07/23">
<META NAME="KBCreate" CONTENT="1993/06/03">
<META NAME="Keywords" CONTENT="kb16bitonly">
<META NAME="KBArea" CONTENT="Support; KB; win16sdk">
<META NAME="Description" CONTENT="  Microsoft Windows version 3.1 can register callback functions with the NotifyRegister() application programming interface (API), which is called on notifications. Callback functions that result in a notification being issued, however, themselves fa...">
<META NAME="Product" CONTENT="Win16 SDK">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QAGI,QAY5,QDL9,QBWO,QBWN,QAA1,QDI2,QAB9,QAIF,QBV8,QAJH,QAO4,QAB4,QBWQ,QBVV V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>Chaining NotifyRegister Callbacks Issuing Notifications</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  July 23, 1997</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q99671 </B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
3.10
WINDOWS
kbprg
<P>
 
The information in this article applies to:

<UL><LI>Microsoft Windows Software Development Kit (SDK) for Windows version 3.1
</UL> 
<P>
<P><h2>SUMMARY</h2>
 
<P>
Microsoft Windows version 3.1 can register callback functions with the
NotifyRegister() application programming interface (API), which
is called on notifications. Callback functions that result in a
notification being issued, however, themselves fail to chain on to
other registered callbacks. This causes negative side-effects to other
applications that use NotifyRegister().
<P>
<P><h2>MORE INFORMATION</h2>
 
<P>
NotifyRegister() can install callback functions that are called in
response to events such as the starting and ending of an application,
the loading of a segment, the freeing of a module, and so forth. Only
one callback can be installed per task running in Windows. When more
than one task is running, each can install a notification callback.
Multiple callback functions are called by a chaining mechanism
implemented in TOOLHELP when an event occurs. Callback functions are
called in the order they were installed by the tasks. See the Windows
Software Development Kit (SDK) version 3.1 "Programmer's Reference,
Volume 2: Functions" manual for more information on NotifyRegister().
<P>
If a callback routine performs an operation that causes another
notification to be issued, then the callback functions are not called
in the usual chained manner. The problem is not that the callback
routine isn't handling reentrancy; rather, NotifyRegister() has not been
implemented to handle callbacks that result in notifications being
issued.
<P>
For example, a common procedure is to call OutputDebugString() to help
debug an application. However, callback functions installed by
NotifyRegister() cannot use OutputDebugString() because this API call
causes the NFY_OUTSTR notification to be issued. When OutputDebugString()
returns, TOOLHELP can't chain on to the next installed callback function.
The result is that only the first callback is called for the event at which
OutputDebugString() was called.
<P>
If printing debug messages from the callback routine is desired, call
PostMessage() to inform the application of the event, and call
OutputDebugString() from the application's window procedure instead of
calling it directly from the callback routine. Using PostMessage() is
necessary for the application to perform any operation, not just a
call to OutputDebugString(), which causes a notification event to occur.
Incidentally, the documentation states that "the notification callback
function cannot use any Windows function, with the exception of Tool
Helper functions and PostMessage.()"
<P>
Having this type of error in an installed NotifyRegister() callback results
in negative side-effects in other applications that use  NotifyRegister().
Microsoft Visual C++ version 1.0 uses TOOLHELP notifications as part of the
integrated development environment debugger. If any application is running
that has installed a callback that causes notifications to be issued,
calling OutputDebugString() for example, Visual C++ will not be able to
initiate debugging an application. Upon starting to debug, Visual C++
displays an error message in a dialog box stating:
<P>
<PRE>   DEBUG ERROR: Could not load debuggee.  Unknown Error in
   Windows (-22)

</PRE>Once the application uninstalls the errant callback routine, Visual C++ can
debug without this error.
<P>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
Additional reference words: 3.10<BR>
KBCategory: kbprg<BR>
KBSubcategory: KrToolHlp<BR>
Keywords            : kb16bitonly<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  July 23, 1997</FONT>
	<BR>
	<A HREF="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
