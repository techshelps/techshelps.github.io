

<HTML>
<HEAD>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Windows 3.1 Card File Format </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q99340 ">
<META NAME="KBModify" CONTENT="1997/07/23">
<META NAME="KBCreate" CONTENT="1993/05/26">
<META NAME="Keywords" CONTENT="kb16bitonly kbprg">
<META NAME="KBArea" CONTENT="Support; KB; win16sdk">
<META NAME="Description" CONTENT="  This article documents the file format used by Microsoft Windows version 3.1 Cardfile. Please note that the Cardfile file format (.CRD) may change in future versions. All numbers in this document, including those in the descriptive text, should be ...">
<META NAME="Product" CONTENT="Win16 SDK">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QAPN,QAW6,QBE7,QBE6,QATX,QALG,QA9Q,QDNG,QA28,QA05,QATJ,QAMB,QDL9,QBWO,QBWN V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>Windows 3.1 Card File Format</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  July 23, 1997</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q99340 </B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
3.10
WINDOWS
kbprg
<P>
 
The information in this article applies to:

<UL><LI>Microsoft Windows Software Development Kit (SDK) for Windows
   versions 3.0 and 3.1
</UL> 
<P>
<P><h2>SUMMARY</h2>
 
<P>
This article documents the file format used by Microsoft Windows
version 3.1 Cardfile. Please note that the Cardfile file format (.CRD)
may change in future versions. All numbers in this document, including
those in the descriptive text, should be interpreted as hexadecimal
numerals. All data pointers and count bytes in the file are unsigned
binary/hexadecimal integers in least-to-most significant format. All
text in the file is saved in low ASCII format. In the text section of
a card's data, &lt;CR&gt; is always followed by &lt;LF&gt;.
<P>
<P><h2>MORE INFORMATION</h2>
 
<P>
<P><h3>Card File Changes in NT 3.51</h3>
 
<P>
The only difference in the unicode format is the signiture (DKO) and the
characters, now 16-bits wide. The Signature can now be MGC.
<P>
The Cardfile file format is as follows:
<P>
<PRE>   Byte #  Description
   -------------------
   0 - 2   Signature bytes--always "RRG" (52 52 47).
   3 - 6   Last object's ID.
   7 - 8   Number of cards in file.

</PRE>Beyond the first 9 bytes are the index lines--the information about
the top line of each card. The first index entry begins at byte 9 in
the file, and successive entries begin 34 bytes after the beginning of
the last index entry (the second entry at byte 3D, the third entry at
byte 71, and so forth). The format for each index line entry is as
follows:
<P>
<PRE>   Byte #  Description
   -------------------
   0 - 5   Null bytes, reserved for future use (should all be 00).
   6 - 9   Absolute position of card data in file.
   A       Flag byte (00).
   B - 32  Index line text.
   33      Null byte; indicates end of index entry.

</PRE>After the last index entry, each card's data is stored. Card data is
in one of four general formats: graphic and text, text only, graphic
only, and blank. Blank cards consist of 4 null bytes; the other card
formats are below:
<P>
<PRE>   Graphic       Text     Graphic
   &amp; Text        Only     Only
   -------------------------------------------------------------------
   0 - 1        0 - 1#    0 - 1         Flag Determining whether or not
                                        the card contains an object.
   2 - 5          *       2 - 5         Unique object ID.
   6 - x          *       6 - x         The OLE object.
   x+1 - x+2      *       x+1 - x+2     Character width, used for device
                                        independence.
   x+3 - x+4      *       x+3 - x+4     Character height.

   x+5 - x+C      *       x+5 - x+C     RECT: left  - X-coordinate of the
                                                      upper-left corner.
                                              top   - Y-coordinate of the
                                                      upper-left corner.
                                              right - X-coordinate of the
                                                      lower-right corner.
                                              bottom- Y-coordinate of the
                                                      lower-right corner.
   x+D - x+E      *       x+D - x+E     Object type embedded=0, linked=1,
or
                                        static=2 (values may change in the
                                        future).
   x+F - x+10   2 - 3     x+F - x+10#   Length of text entry.
   x+11 - y     4 - z         *         Text.

</PRE>NOTE:
<P>
<PRE>   x = 6 + size in bytes of the entire OLE object (the entire size of the
       object is not stored anywhere within the .CRD file). See below for
       more information on the OLE object size.
   y = x + 10 + length of text entry.
   z = 3 + length of text entry.
   # - These bytes are null if no object/text.
   * - These bytes do not exist if no object/text.

</PRE>The first byte of any card's data entry is pointed to by bytes 6-9 in
the index entry. Note that no null byte is used to indicate the end of
the card's data entry; the next card's data entry immediately follows
the last byte of the previous entry, which is null only if the
previous card has no text (null length of text entry).
<P>
<P><h3>OLE Object</h3>
 
<P>
The size of the OLE object is not stored anywhere within the .CRD
file. The OLE object could be loaded using OleLoadFromStream();
however, to get passed the OLE object, the file needs to be parsed.
The OLE object's format description is documented in Appendix C of the
"Object Linking and Embedding Programmer's Reference" version 1.0,
published by Microsoft Press, and also in the Microsoft Windows
Software Development Kit (SDK) "Programmer's Reference, Volume 1:
Overview," Chapter 6, Object Storage Format. Below is an algorithm
that uses the OLE object's format description to parse the OLE object
in the .CRD file and pass it.
<P>
<P><h3>Need Five Primary Functions</h3>
 
<P>
<PRE>   Primary Function        Description
   -----------------------------------
   ReadLong()            - Reads a long from the file and advances the file
                           pointer.
   EatBytes(NumBytes)    - Reads and discards the specified number of bytes
                           from the file and advances the file pointer.
   RdChkVer()            - Reads the version number and advances the file
                           pointer and returns TRUE if version is 1.0. To
                           check the version number, the received value
                           must be converted to Hex then checked against
                           0x0100.
                           (See below for the algorithm of this function.)
   RdChkString()         - Reads the string and checks the value to see if
                           it is either METAFILEPICT, BITMAP, or DIB, then
                           returns TRUE; otherwise, returns FALSE. Advances
                           the file pointer too.
   SkipPresentationObj() - Reads and skips the variable-length presentation
                           object at the end of each object type.
                           (See below for the algorithm of this function.)

</PRE>Algorithm to Skip Over the OLE Object
 
<P>
<PRE>if (RdChkVer)                  // If the version is 1.0
  Format = ReadLong();         // 1==&gt; Linked, 2==&gt; Embedded, 3==&gt; Static
  EatBytes(ReadLong());        // Class String
  if (Format == 3)             // Static object
    ReadLong();                // Width in mmhimetric.
    ReadLong();                // Height in mmhimetric.
    EatBytes(ReadLong());      // Presentation data size and data itself.
  else                         // Embedded or linked objects.
    EatBytes(ReadLong());      // Topic string.
    EatBytes(ReadLong());      // Item string.
    if (Format == 2)           // Embedded object.
      EatBytes(ReadLong());    // Native data and its size.
      SkipPresentationObj()    // Read and eat the presentation object.
    else                       // Linked object.
      EatBytes(ReadLong());    // Network name.
      ReadLong();              // Network type and net driver version.
      ReadLong();              // Link update options.
      SkipPresentationObj()    // Read and eat the presentation object.

</PRE><h3>SkipPresentationObj()</h3>
 
<P>
<PRE>if (RdChkVer)                  // If the version is 1.0
  ReadLong();                  // Format ID
  if (RdChkString())           // if Class String is either
                               // METAFILEPICT or BITMAP or DIB.
    ReadLong();                // Width in mmhimetric.
    ReadLong();                // Height in mmhimetric.
    EatBytes(ReadLong());      // Presentation data size and data itself
  else
    if (!ReadLong())           // if Clipboard format value is NULL
      EatBytes(ReadLong());    // Read Clipboard format name.
    EatBytes(ReadLong());      // Presentation data size and data itself.

</PRE><h3>RdChkVer()</h3>
 
<P>
OLEVer = ReadLong();
OLEVer = (((WORD)(LOBYTE(OLEVer))) &lt;&lt; 8 | (WORD) HIBYTE(OLEVer);
<PRE>if (OLEVer == 0x0100)           // Always use Hex value.
  return TRUE;
</PRE>else
<PRE>  return FALSE;

Additional references: 3.10

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
KBCategory: kbprg<BR>
KBSubCategory: UsrFmt<BR>
Keywords            : kb16bitonly kbprg<BR>
Version             : 3.10<BR>
Platform            : WINDOWS<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  July 23, 1997</FONT>
	<BR>
	<A HREF="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
