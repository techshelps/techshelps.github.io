

<HTML>
<HEAD>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Introduction to Nonpreemptive Multitasking in Windows </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q78155 ">
<META NAME="KBModify" CONTENT="1997/07/23">
<META NAME="KBCreate" CONTENT="1991/11/06">
<META NAME="Keywords" CONTENT="kb16bitonly">
<META NAME="KBArea" CONTENT="Support; KB; win16sdk">
<META NAME="Description" CONTENT="  Applications in the Windows environment are scheduled using a nonpreemptive multitasking system. Usually, multitasking operating systems schedule tasks for execution based on some combination of time slice and/or task priority. However, Windows doe...">
<META NAME="Product" CONTENT="Win16 SDK">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QBWN,QDL9,QBWO,QBWQ,QAEV,QAJH,QAGI,QAYC,QBVV,QAUD,QATK,QAGQ,QAIF,QAA7,QABA V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>Introduction to Nonpreemptive Multitasking in Windows</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  July 23, 1997</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q78155 </B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
3.00 3.10
WINDOWS
kbprg
<P>
 
The information in this article applies to:

<UL><LI>Microsoft Windows Software Development Kit (SDK) for Windows
   versions 3.0 and 3.1
</UL> 
<P>
<P><h2>SUMMARY</h2>
 
<P>
Applications in the Windows environment are scheduled using a
nonpreemptive multitasking system. Usually, multitasking operating
systems schedule tasks for execution based on some combination of time
slice and/or task priority. However, Windows does not preemptively
switch the processor away from a currently running application under
normal circumstances (excluding interrupts). Instead, multitasking in
Windows is based on the messaging system.
<P>
Windows-based applications must cooperatively offer to yield the processor
on a regular basis to allow Windows to multitask. Normally, an application
offers to yield by calling one of three functions: GetMessage(),
PeekMessage(), or WaitMessage(). An application may also yield when it
calls DialogBox(), DialogBoxIndirect(), DialogBoxParam(),
DialogBoxIndirectParam(), MessageBox(), or TrackPopupMenu().
<P>
<P><h2>MORE INFORMATION</h2>
 
<P>
<P><h3>The GetMessage Loop</h3>
 
<P>
In the Windows environment, most applications have a central GetMessage()
loop that allows the application to cooperate with the other applications
running in the system.
<P>
When an application (called "App A") calls GetMessage(), the GetMessage()
function will return if there are any messages in App A's message queue. If
there are no messages, Windows will give control to another application
that has messages in its queue. If there are no messages waiting for any
application in the system, Windows idles. App A's call to GetMessage() will
not return until there is a new message in App A's queue.
<P>
Using this method, the Windows-based application with control will retain
control as long as messages are waiting in its queue. There is a small
wrinkle to this rule: Windows considers WM_PAINT and WM_TIMER messages to
be low-priority messages. If App A calls GetMessage() and has only low-
priority messages in its queue, Windows will pass control to an application
with high-priority messages waiting.
<P>
It is important to note that an application can retain control of the CPU
indefinitely if it does not call GetMessage(), PeekMessage(), or
WaitMessage(). However, an application that fails to periodically make one
of these three calls is very impolite, because it is not allowing Windows
to multitask.
<P>
<P><h3>Background Processing</h3>
 
<P>
In the Windows environment, an application can perform a lengthy processing
task and allow Windows to multitask by using either a PeekMessage() loop or
a Windows timer. In both cases, the general idea is the same: break the
large processing task into small pieces, processing one piece at a time and
offering to yield at regular short intervals.
<P>
An application can use a PeekMessage() loop to perform background
processing because, unlike GetMessage(), PeekMessage() does not wait for a
message to be placed in the application's message queue before returning.
If there are no messages waiting, PeekMessage() returns FALSE.
<P>
A typical PeekMessage() loop resembles the following:
<P>
<PRE>   while (bDoingBackgroundWork)
   {
      if PeekMessage(&amp;msg, hWnd, 0, 0, PM_REMOVE)
      {
         TranslateMessage(&amp;msg); // a message is ready - process it
         DispatchMessage(&amp;msg);
      }
      else
      {
         // PeekMessage returned FALSE, which means no messages ready.
         // Do a small piece of background work here.
      }
   }

</PRE>The PM_REMOVE flag must be specified in the wRemoveMsg parameter;
otherwise, the application will never yield. PeekMessage() will not yield
as long as there are messages in the application's queue. If the
application does not remove and process the messages, PeekMessage() may
send the application into an infinite loop.
<P>
An application creates a Windows timer with the SetTimer() function. An
application can use a Windows timer to do background processing by setting
a timer and doing a small piece of the background job each time a WM_TIMER
message is received or the timer notification function is called. Even if
the application is receiving a steady stream of WM_TIMER messages, other
applications will still have an opportunity to run because Windows
considers WM_TIMER messages to be a low priority.
<P>
It may be necessary to consider two other facts about Windows timers: they
are not asynchronous, and the highest resolution that can be obtained is
about 55 milliseconds.
<P>
<P><h2>REFERENCE</h2>
 
<P>
For more information on using Windows timers, see Chapter 5, "The
Timer," in Charles Petzold's book "Programming Windows 3.1" (Microsoft
Press).
<P>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
Additional reference words: 3.00 3.10<BR>
KBCategory: kbprg<BR>
KBSubcategory: UsrMsg<BR>
Keywords            : kb16bitonly<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  July 23, 1997</FONT>
	<BR>
	<A HREF="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
