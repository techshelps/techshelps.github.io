

<HTML>
<HEAD>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>GlobalReAlloc() and GMEM_ZEROINIT Clarified </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q92942 ">
<META NAME="KBModify" CONTENT="1997/07/23">
<META NAME="KBCreate" CONTENT="1992/11/19">
<META NAME="Keywords" CONTENT="kb16bitonly">
<META NAME="KBArea" CONTENT="Support; KB; win16sdk">
<META NAME="Description" CONTENT="  GlobalReAlloc() is documented in the Windows API's reference manuals. This is a clarification of one of the flags you can set for GlobalReAlloc(). Under one circumstance, when GlobalReAlloc() is used with GMEM_ZEROINIT, it may not zero out all of t...">
<META NAME="Product" CONTENT="Win16 SDK">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QALG,QAGI,QDL9,QBWO,QBWN,QAHC,QBWQ,QBVV,QBW6,QAIF,QACJ,QAA8,QAYZ,QAYV,QALQ V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>GlobalReAlloc() and GMEM_ZEROINIT Clarified</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  July 23, 1997</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q92942 </B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
3.00 3.10
WINDOWS
kbprg
<P>
 
The information in this article applies to:

<UL><LI>Microsoft Windows Software Development Kit (SDK) for Windows
   versions 3.1 and 3.0
</UL> 
<P>
<P><h2>SUMMARY</h2>
 
<P>
GlobalReAlloc() is documented in the Windows API's reference manuals. This
is a clarification of one of the flags you can set for GlobalReAlloc().
Under one circumstance, when GlobalReAlloc() is used with GMEM_ZEROINIT, it
may not zero out all of the reallocated memory. This situation occurs when
GlobalReAlloc() is called to shrink a block of memory and then enlarge it.
<P>
<P><h2>MORE INFORMATION</h2>
 
<P>
When GlobalReAlloc() is used with GMEM_ZEROINIT to increase the size of a
block of memory in the global heap, it will zero out only the bytes it adds
to the memory object; it does not initialize any of the memory that existed
before the call.
<P>
Windows allocates memory from the global heap in multiples of 32 bytes;
enhanced mode allocates memory on even 32-byte boundaries, and standard
mode allocates memory on odd 32-byte boundaries (that is, /E allocates
32/64/96 bytes, /S allocates 16/48/80 bytes).Thus, when 10 bytes are
requested, enhanced Windows actually allocates 32 bytes; when 55 bytes are
requested, enhanced Windows allocates 64 bytes.
<P>
Suppose we have the following sequence of calls in Windows enhanced mode:
<P>
HGLOBAL hMem ;
<P>
<PRE>      // 32 bytes are actually allocated, not 10 because Windows
      // allocates global memory in multiples of 32 bytes. All
      // 32 bytes are initialized to zero.
</PRE>hMem = GlobalAlloc(GMEM_ZEROINIT | GMEM_FIXED, 10);
<P>
<PRE>      // Here, we allocate 32 more bytes and add them to the end of
      // the first 32 bytes. ReAllocating to 40 bytes will cause the
      // block to be 64 bytes long. Only the second 32
      // bytes are initialized to zero. The first 32 bytes are left
      // alone.
</PRE>hMem = GlobalReAlloc(hMem, 40, GMEM_ZEROINIT | GMEM_FIXED);
<P>
<PRE>      // Copy 39 bytes into the memory block. The first 39 bytes
      // will contain the string.
</PRE>lstrcpy((LPSTR)GlobalLock(hMem), "This is a big enough string for our job")
<P>
<PRE>      // Now we shrink the block to 10 bytes. After the call, the
      // block will be 32 bytes long; the second 32 bytes are freed
      // and will no longer exist. The first 32 bytes will still
      // contain the same characters as before the call.
</PRE>hMem = GlobalReAlloc(hMem, 10, GMEM_ZEROINIT | GMEM_FIXED) ;
<P>
<PRE>      // Now, we enlarge the block back to 40 bytes.  After the call,
      // the block will be 64 bytes long, and the second 32 bytes
      // will be initialized to zero. The first 32 bytes will be left
      // alone, however. The area between bytes 10 and 32 does *not*
      // get initialized!
</PRE>hMem = GlobalReAlloc(hMem, 40, GMEM_ZEROINIT | GMEM_FIXED) ;
<P>
When GlobalReAlloc() is called to shrink the block, we told it that we
wanted only 10 bytes; that's all we should use. Then when we enlarge it
back to 40 bytes, GlobalReAlloc() only initializes the memory it adds to
the current block--which is from bytes 33 to 64. The bytes between 10 and
40 were previously used, but GlobalReAlloc() did not initialize them
because it did not allocate them.
<P>
As a result, applications that call GlobalReAlloc() to shrink and then re-
enlarge a block of previously used data should not expect that all the
bytes will be initialized to zero.
<P>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
Additional reference words: 3.00 3.10<BR>
KBCategory: kbprg<BR>
KBSubcategory: KrMm<BR>
Keywords            : kb16bitonly<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  July 23, 1997</FONT>
	<BR>
	<A HREF="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
