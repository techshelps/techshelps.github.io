

<HTML>
<HEAD>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Creating Dynamic-Linked Libraries Without Data Segments </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q68565 ">
<META NAME="KBModify" CONTENT="1997/07/22">
<META NAME="KBCreate" CONTENT="1991/01/22">
<META NAME="Keywords" CONTENT="kb16bitonly">
<META NAME="KBArea" CONTENT="Support; KB; win16sdk">
<META NAME="Description" CONTENT="   Using dynamic-link libraries (DLLs) is a very flexible way to centralize a body of program code. Many applications may use functions from a DLL, while only one copy of the DLL code is in memory. This contrasts with code that is statically linked i...">
<META NAME="Product" CONTENT="Win16 SDK">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QAH4,QAYY,QBFY,QAYL,QDNN,QDL9,QBWO,QBWN,QBVV,QAGI,QAJH,QBHQ,QAB4,QAEF,QBWQ V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>Creating Dynamic-Linked Libraries Without Data Segments</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  July 22, 1997</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q68565 </B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
3.00 3.10
WINDOWS
kbprg
<P>
 
The information in this article applies to:

<UL><LI>Microsoft Windows Software Development Kit for Windows versions
   3.0 and 3.1
</UL> 
<P>
<P>
<P><h2>SUMMARY</h2>
 
<P>
Using dynamic-link libraries (DLLs) is a very flexible way to
centralize a body of program code. Many applications may use functions
from a DLL, while only one copy of the DLL code is in memory. This
contrasts with code that is statically linked into applications, which
requires each application to have its own copy of the shared code.
<P>
By default, each DLL has its own data segment, separate from that of
the calling applications. This default behavior precludes using some
of the standard Windows-application programming practices and C
run-time functions in a DLL. This article discusses techniques to
ensure that no data segment is created for a DLL.
<P>
<P><h2>MORE INFORMATION</h2>
 
<P>
The most common reason to use a DLL that does not have its own data
segment is to ensure that the data segment (DS) register and stack
segment (SS) register are the same (DS == SS). A large majority of the
functions provided with the C run-time libraries expect that DS == SS.
Functions with this requirement have been removed from the
DLL-specific libraries included with the Windows Software Development
Kit (SDK).
<P>
DLLs that have their own data segment will use the stack segment of
the application that calls the DLL. This means that the data segment
and stack segment differ (DS != SS). This fact precludes using many C
run-time functions and any others that require DS and SS to be the
same. A DLL without a data segment will use both the data segment and
the stack segment of the calling application; therefore, DS == SS.
<P>
The clarity of the previous discussion is complicated by the fact that
some items within a DLL will declare their own data segment. The DATA
statement in the module definition (.DEF) file is the mechanism that
Windows uses to determine if the DLL has a data segment. If the .DEF
file declares DATA NONE, then Windows will assume that no data segment
exists for this DLL. Throughout this discussion, DLLs with a DATA NONE
statement in the appropriate .DEF file will be called DATA NONE DLLs.
<P>
Since Windows assumes that a DATA NONE DLL does not have a data
segment, a data segment that is created implicitly by the DLL code
itself is not loaded into memory and will not be visible by HEAPWALK
or other heap management utilities.
<P>
When a DATA NONE DLL does have a data segment, the DLL will use the
application's DS as it should; however, the offset into the data
segment is then calculated as being relative to the DLL's data
segment. Assigning any value to a variable declared in the DLL will
then overwrite any data in the application's data segment.
<P>
This type of anomaly may be difficult to track down. When the data
segment is built for the DLL, items are placed in the data segment
from bottom to top. For example, one integer variable requires two
bytes on the bottom of the DLL's data segment. Writing to this
variable will overwrite 2 bytes on the bottom of the calling
application's data segment. Since the size of an application's data
segment is often many thousands of bytes, this type of error may go
unnoticed and will most likely not cause a general-protection (GP)
fault.
<P>
These offending data segments are created by the C Compiler to store
global and static variables and static text. One symptom of an
unexpected data segment is that the Resource Compiler provides a
warning message similar to the following:
<P>
<PRE>   RC: Warning RW4002: Non-discardable Segment 2 set to PRELOAD

</PRE>This warning is generated when a data segment has been created by the
C Compiler; however, flags have not been defined for that segment
(such as MULTIPLE or DISCARDABLE). The default setting for these
segments is PRELOAD SINGLE.
<P>
A DLL that uses the C run-time code references a global internal
variable __acrtused, which is declared as follows in LIBENTRY.ASM:
<P>
<PRE>   extern __acrtused:abs

</PRE>Referencing this variable informs the linker that the DLL will use the
C run-time code. If the C run-time code is not required by the DLL,
this line should be removed to allow a truly DATA NONE DLL to be
created.
<P>
If the C run-time code is actually used by the DLL, __acrtused must be
declared. This will cause a data segment to be created; however, the
warnings concerning that data segment may be ignored.
<P>
However, if C run-time code is not being used in the DLL, __acrtused
can be removed, and the C run-time code can also be removed from the
DLL. The C run-time code is present in the standard import libraries
xDLLCyW (where "x" is a memory model, and "y" is "E" for emulator math
or "A" for alternate math). If the xNOCRTD libraries are used instead,
no C run-time code is linked into the DLL. In addition to changing the
library specification on the LINK command line, the /NOE option must
be specified.
<P>
To use the application's DS on a function-by-function basis, the
NODATA option can be used on exports. When the linker fixes up a DLL
entry point, it can be told to omit the code that changes DS on DLL
entry. This can be done on a per-export basis, allowing much greater
flexibility because a data segment can still exist, although it is
only only set for certain calls. An example of this type of EXPORT
statement is listed below (fragment of a .DEF file):
<P>
<PRE>   EXPORTS
           MyExportName @145 NODATA

</PRE>When "MyExportName" is called, it will not have the DS set to the
DLL's DS, instead it will retain the application's DS.
<P>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
Additional reference words: 3.00 3.10<BR>
KBCategory: kbprg<BR>
KBSubcategory: KrDll<BR>
Keywords            : kb16bitonly<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  July 22, 1997</FONT>
	<BR>
	<A HREF="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
