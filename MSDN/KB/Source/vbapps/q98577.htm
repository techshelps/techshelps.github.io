

<HTML>
<HEAD>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>INFO: Example of calling EnumFontFamilies from a DLL </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q98577 ">
<META NAME="KBModify" CONTENT="1997/09/29">
<META NAME="KBCreate" CONTENT="1993/05/10">
<META NAME="Keywords" CONTENT="APrgOther vbwin kbfasttip">
<META NAME="KBArea" CONTENT="Support; KB; vbapps">
<META NAME="Description" CONTENT="  This article demonstrates how to obtain a list of available fonts for a device by calling EnumFontFamilies or EnumFonts from a DLL.  Visual Basic already provides a Fonts property for obtaining a list of available font names for a device. Microsoft...">
<META NAME="Product" CONTENT="vbapps">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QBS0,QAUD,QADF,QA4Q,QDL9,QBWQ,QBWO,QBWN,QATJ,QA28,QAH6,QALW,QAUJ,QDNN,QAPF V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>INFO: Example of calling EnumFontFamilies from a DLL</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  September 29, 1997</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q98577 </B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
 
The information in this article applies to:
<P>
- Standard and Professional Editions of Microsoft Visual Basic programming
<PRE>  system for Windows, versions 2.0, 3.0
</PRE> 
<P>
<P><h2>SUMMARY</h2>
 
<P>
This article demonstrates how to obtain a list of available fonts for a
device by calling EnumFontFamilies or EnumFonts from a DLL.
<P>
Visual Basic already provides a Fonts property for obtaining a list of
available font names for a device. Microsoft recommends that you use the
Fonts property instead of the function provided in this article to obtain
a list of available fonts. Use the technique shown in this article only if
you have encountered a bug or limitation when using the Fonts property.
<P>
To create the example shown below, you need a C compiler capable of
creating Windows dynamic link libraries (DLLs), and you need to have the
Visual Basic Control Development Kit (CDK) version 2.0 or 3.0. The CDK
is provided with the Professional Edition of Visual Basic version 2.0
and 3.0 for Windows.
<P>
<P><h2>MORE INFORMATION</h2>
 
<P>
Below are the steps necessary to create a sample DLL that demonstrates
using EnumFontFamilies:
<P>
<P><h3>STEP ONE: Create Example .DLL File</h3>
 

<OL><P><LI>Create a source file called FONTNAME.C and add the following code:
<P>
<P><PRE>      #include &lt;windows.h&gt;
      #include &lt;vbapi.h&gt;
      #include &lt;string.h&gt;
</PRE>   
<P><PRE>      int FAR PASCAL _export EnumFontNames (HDC, HAD);
      int FAR PASCAL  _export GetNextFont (LPLOGFONT, LPNEWTEXTMETRIC,
<PRE></PRE>                                           int, LPARAM);
      BOOL Win31OrGreater (VOID);
   
      int giFontCount;
      float gfVersion;
   
      //================================================================
      // Title
      //      EnumFontNames()
      //
      // Parameters
      //      hdc      Device context for which fonts will be enumerated
      //      had      Handle to Visual Basic string array where the
      //               font names will be placed.
      //
      // Returns
      //      The number of fonts enumerated.
      //================================================================
      int FAR PASCAL EnumFontNames (HDC hdc, HAD had)
      {
         giFontCount = 0;
   
         if ( Win31OrGreater() )
            //Use EnumFontFamilies under Win 3.1 and later
            while (EnumFontFamilies(hdc, NULL, GetNextFont, had));
         else
            //Need to use EnumFonts under Win 3.0
            while (EnumFonts(hdc, NULL, GetNextFont, had));
   
         return giFontCount;
      }
   
      //================================================================
      // Title
      //      GetNextFont()
      //
      // Parameters
      //      lplf     Far pointer to LOGFONT structure
      //      lpntm    Far pointer to NEWTEXTMETRIC structure
      //      FontType Type of font
      //      lp       User-defined.  In this case it holds the handle
      //               to a Visual Basic string array.
      //
      // Returns
      //      TRUE as a signal to enumerate the next font
      //      FALSE as a signal to stop enumeration
      //================================================================
      int FAR PASCAL GetNextFont
      (
         LPLOGFONT lplf,
         LPNEWTEXTMETRIC lpntm,
         int FontType,
         LPARAM lp
      )
      {
         static char szFirstFont[LF_FACESIZE + 1];
         char szFaceName[LF_FACESIZE + 1];
         int iElements, lbound;
   
         HAD had = (HAD) lp;
         LONG lBounds = VBArrayBounds(had, 1);
   
         //Get out if there are no elements in the array
         if (lBounds == AB_INVALIDINDEX)
            return FALSE;
   
         // Store the lower bound of the array for index 1
         lbound = LOBOUND(lBounds);
   
         //Get number of elements in the array
         iElements = HIBOUND(lBounds) - lbound + 1;
   
         //Initialize the vars holding the font face names
         if (giFontCount == 0)
             szFirstFont[0] = '\0';
   
         szFaceName[0] = '\0';
   
         if (giFontCount &lt;= iElements)
         {
            HLSTR hlstr;
            SHORT indexes[1];
   
            //Copy the face size into a buffer so that we can ensure its
            //null terminated
            if ( Win31OrGreater() )
                lstrcpyn((LPSTR) szFaceName, lplf-&gt;lfFaceName,
                         LF_FACESIZE - 1);
            else
                //Need to use C runtime routine fmemcpy instead of
                //lstrcpyn under Win 3.0
               _fmemcpy((LPVOID) szFaceName, lplf-&gt;lfFaceName,
                         LF_FACESIZE - 1);
   
            szFaceName[LF_FACESIZE] = '\0';
   
            if (giFontCount == 0)
   
               //Store the first font retrieved.  If we see this font
               //again, we know we've enumerated all the fonts
               lstrcpy((LPSTR) szFirstFont, szFaceName);
   
            else if (!lstrcmp(szFirstFont, szFaceName))
            //If we see the same face name again, get out and stop
            //enumerating
               return FALSE;
   
            //Assume a single index array
            indexes[0] = lbound + giFontCount;
   
            //Get the VB string handle from the VB array
            hlstr = VBArrayElement(had, VBArrayIndexCount(had),
                                   indexes);
   
            //Make sure the string handle is valid
            if (HIWORD(hlstr))
            {
               //Add the fontname to the array
               VBSetHlstr(&amp;hlstr, (LPSTR) szFaceName, lstrlen((LPSTR)
                          szFaceName));
   
               //Return and get the next font
               giFontCount++;
            }
   
            return TRUE;
         }
   
         else
            //Can't fit all font names into the array provided, so get
            //out.
            return FALSE;
      }
   
      //================================================================
      // Title
      //      Win31OrGreater ()
      //
      // Returns
      //      TRUE if we're running under Windows 3.1 or better
      //      FALSE if we're running under Windows 3.0
      //================================================================
      BOOL Win31OrGreater ( VOID )
      {
          DWORD dVersion;
   
          //Check which version of Windows we're running under
          dVersion = GetVersion();
          if (LOBYTE(LOWORD(dVersion)) &gt; 3 || (LOBYTE(LOWORD(dVersion))
              == 3 &amp;&amp; HIBYTE(LOWORD(dVersion)) &gt; 0))
              return TRUE;
          else
              return FALSE;
      }
   
      //----------------------------------------------------------------
      // Initialize library. This routine is called when the first
      // client loads
      // the DLL.
      //----------------------------------------------------------------
      int FAR PASCAL LibMain
      (
         HANDLE hModule,
         WORD   wDataSeg,
         WORD   cbHeapSize,
         LPSTR  lpszCmdLine
      )
      {
         // Avoid warnings on unused (but required) formal parameters
         wDataSeg = wDataSeg;
         cbHeapSize = cbHeapSize;
         lpszCmdLine = lpszCmdLine;
   
         return 1;
      }
   
      //----------------------------------------------------------------
      // WEP
      //----------------------------------------------------------------
      int FAR PASCAL WEP(int fSystemExit);
   
      //----------------------------------------------------------------
      // Performs cleanup tasks when the DLL is unloaded.  WEP() is
      // called automatically by Windows when the DLL is unloaded (no
      // remaining tasks still have the DLL loaded).  It is strongly
      // recommended that a DLL have a WEP() function, even if it does
      // nothing but returns success (1), as in this example.
      //----------------------------------------------------------------
      int FAR PASCAL WEP
      (
          int fSystemExit
      )
      {
          // Avoid warnings on unused (but required) formal parameters
          fSystemExit = fSystemExit;
   
          return 1;
      }

</PRE><P><LI>Create a module-definition file (DEF) called FONTNAME.DEF and add the
   following:
<P>
<P><PRE>      LIBRARY FONTNAME
</PRE>   
<P><PRE>      DESCRIPTION 'Example of how to enumerate all font names for
<PRE></PRE>                    specific device'
   
      EXETYPE WINDOWS
   
      CODE PRELOAD MOVEABLE DISCARDABLE
      DATA PRELOAD MOVEABLE SINGLE
   
      EXPORTS
         WEP @1 RESIDENTNAME
         ENUMFONTNAMES @2
         GETNEXTFONT @3

</PRE><P><LI>Compile FONTNAME.C from the MS-DOS command line as follows:
<P>
<P><PRE>      CL /c /ASw /W3 FONTNAME.C
</PRE>
<P><LI>Link the resulting FONTNAME.OBJ file as follows:
<P>
<P><PRE>      LINK /NOE /NOD
<PRE></PRE>         FONTNAME.OBJ+LIBENTRY.OBJ,FONTNAME.DLL,,
         LIBW+SDLLCEW+VBAPI.LIB,FONTNAME.DEF;

</PRE><P><LI>Resource compile FONTNAME.DLL to make it Windows 3.0 compatible as
   follows:
<P>
<P><PRE>      RC /30 FONTNAME.DLL
</PRE>
<P><LI>Copy FONTNAME.DLL to the \WINDOWS\SYSTEM directory.
<P>
</OL><h3>STEP TWO: Create Visual Basic Sample Program</h3>
 

<OL><P><LI>Start Visual Basic or from the File menu, choose New Project (ALT, F, N)
   if Visual Basic is already running. Form1 is created by default.

<P><LI>Add a list box (List1) to Form1.

<P><LI>Add the following Declare statement as one, single line to the
   General Declarations section of Form1:
<P>
<P><PRE>      Declare Function EnumFontNames Lib "FONTNAME.DLL" (ByVal hDC As
<PRE></PRE>         Integer, FontNames() As String) As Integer

</PRE><P><LI>Add the following code to the Form_Click event of Form1:
<P>
<PRE>      Sub Form_Click ()
   
         Dim i As Integer
         Dim FontCount As Integer
         ReDim FontNames(255) As String  'Make the array intentionally
                                         'large to hold any number of
                                         'font names
   
         'For Screen fonts, pass Form1.hDC instead.  If using the
         'Common Dialog control, you can also pass the hDC property
         'of the Common Dialog control.
         FontCount = EnumFontNames(Printer.hDC, FontNames())
   
         List1.Clear
         For i = 0 To FontCount - 1
            List1.AddItem FontNames(i)
         Next
   
      End Sub

</PRE><P><LI>From the Run menu, choose Start (ALT, R, S) or press the F5 key to run
   the program.

<P><LI>Click Form1. The available font names for the selected printer will be
   displayed in the list box.
</OL> 
<PRE>Keywords          : APrgOther vbwin kbfasttip
Technology        : kbvba
Version           : WINDOWS:2.0 3.0
Platform          : WINDOWS
Issue type        : kbinfo</PRE>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
================================================================================<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  September 29, 1997</FONT>
	<BR>
	<A HREF="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
