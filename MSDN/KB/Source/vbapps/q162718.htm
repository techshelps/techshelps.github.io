

<HTML>
<HEAD>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>HOWTO: Prepare Visual Basic Applications for the Year 2000 </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q162718">
<META NAME="KBModify" CONTENT="1998/03/20">
<META NAME="KBCreate" CONTENT="1997/01/27">
<META NAME="Keywords" CONTENT="kbinterop">
<META NAME="KBArea" CONTENT="Support; KB; vbapps">
<META NAME="Description" CONTENT="  As a developer, you may be concerned about how your applications will handle dates beyond 12/31/1999. On January 1st of the year 2000, will your programs think it is the year 2000, 1900, or even 1980? The goal of this article is to ensure that your...">
<META NAME="Product" CONTENT="vbapps">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Security" CONTENT="PUBLIC ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QBS0,QACE,QA5F,QAMA,QAH4,QBHQ,QA2K,QABA,QAPF V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>HOWTO: Prepare Visual Basic Applications for the Year 2000</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  March 20, 1998</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q162718</B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



<P><h3> </h3>
 
The information in this article applies to:

<UL><LI>Control Creation, Learning, Professional and Enterprise Editions
   of Microsoft Visual Basic, for Windows, version 5.0
<LI>Standard, Professional, and Enterprise Editions of Microsoft Visual
   Basic, 16-bit and 32-bit, for Windows, version 4.0,
<LI>Standard, Professional, and Enterprise Editions of Microsoft Visual
   Basic for Windows, versions 2.0, 3.0
<LI>Microsoft Visual Basic programming system for Windows, version 1.0
</UL> 
<P>
<P><h2>SUMMARY</h2>
 
<P>
As a developer, you may be concerned about how your applications will
handle dates beyond 12/31/1999. On January 1st of the year 2000, will your
programs think it is the year 2000, 1900, or even 1980? The goal of this
article is to ensure that your Visual Basic applications will behave
properly with dates beyond 12/31/1999. For further information from
Microsoft about software and the year 2000, please see the documentation on
the Microsoft Web site at:
<P>
<PRE>   <B><A HREF="http://www.microsoft.com/Ithome/topics/year2k/default.htm">http://www.microsoft.com/Ithome/topics/year2k/default.htm</A></B>

</PRE><h2>MORE INFORMATION</h2>
 
<P>
While all versions of Visual Basic will handle years greater than 1999 (in
a four-digit format), passing a two-digit year in a date (such as 7/3/45)
forces Visual Basic to assume what century the date corresponds to. Perhaps
the best way to explain this behavior would be to give a quick Visual Basic
history lesson.
<P>
<P><h3>Visual Basic History Lesson</h3>
 
<P>
For all versions of Visual Basic for Windows (including its predecessors
such as Visual Basic for DOS and QuickBasic) prior to and including 3.0,
two-digit years were always assumed to be in the 1900s. The code to
implement this default was built into each version's run-time library and
does not depend on the version of the operating system or the century of
the current system date.
<P>
Between the development cycles for Visual Basic 3.0 and 4.0, two new
entities emerged: Visual Basic for Applications and OLE Automation. Prior
to the advent of these technologies, Visual Basic's runtime library
contained the code responsible for converting a two-digit year to a
four-digit year. OLE Automation exposed a great deal of functionality that
other applications could access. Visual Basic for Applications did not need
to implement this code; it could make calls to the OLE Automation libraries
instead.
<P>
Visual Basic 4.0 was developed with this interoperability in mind and began
to rely on the OLE Automation libraries to convert two-digit years to
four-digit years in most cases. The exception to the rule is the DateSerial
function that was implemented in the Visual Basic runtime library because
Visual Basic required more functionality than the OLE Automation library
could provide at that time.
<P>
During the Visual Basic 4.0 development cycle, Microsoft decided that the
defaults used in previous versions of Visual Basic were reliable but not
necessarily practical. So, a new rule emerged. A two-digit year would be
converted to the current century of the system date. Thus,
Year(Date("1/1/00")) would evaluate to the current century. This new rule
was implemented in the OLE Automation libraries used by Visual Basic 4.0
and Visual Basic for Applications. The Visual Basic 4.0 runtime library
also implements the rule for the DateSerial function.
<P>
Microsoft later reconsidered and changed the default in the OLE Automation
(now simply Automation) libraries as of version 2.20.4049 of OleAut32.dll.
This change does not affect 16-bit applications that rely on the Automation
libraries, only 32-bit applications. Now, a two-digit year between 00 and
29 (such as 17) is interpreted as 2017 while a two-digit year between 30
and 99 (such as 72) is interpreted as 1972. The new Automation libraries
provide the functionality that Visual Basic requires for the DateSerial
function. Thus, Visual Basic 5.0 and subsequent releases no longer
implement rules for this function in their runtime libraries.
<P>
The updated Automation library ships with Internet Explorer version 3.0 and
later, Windows NT 3.51 Service Pack 5, Windows NT 4.0, Windows 95 OSR 2,
Office 97, Visual Basic 5.0 and other products.
<P>
<P><h3>What Does All of This Mean to Developers Who Use Visual Basic?</h3>
 
<P>
Visual Basic 3.0 and prior versions convert all two-digit years to the
1900s.
<P>
Visual Basic 4.0 (16-bit) converts all two-digit years to the century of
the current system date. Depending on the function used, Visual Basic
converts the date based on defaults in either the 16-bit Automation
libraries or the runtime library. The defaults in the 16-bit Automation
libraries have not been modified since Visual Basic 4.0 released so the
behavior is consistent regardless of which date function is used.
<P>
Visual Basic 4.0 (32-bit) converts two-digit years to four-digit years
based on the default in the Automation libraries except when using the
DateSerial function that converts all two-digit years to the century of the
current system date. The 32-bit Automation libraries (OleAut32.dll version
2.10) that shipped when Visual Basic 4.0 was released converted all
two-digit years to the century of the current system date. Later 32-bit
Automation libraries (OleAut32.dll version 2.20 and later) convert
two-digit years to the 1900s if the two-digit year is between 30 and 99. If
the two-digit year is between 00 and 29, the date is converted to the
2000s.
<P>
Visual Basic 5.0 converts two-digit years to four-digit years based on the
default in the Automation libraries for all date functions. Visual Basic
5.0 shipped with version 2.20.4054 that converts two-digit years to the
1900s if the two-digit year is between 30 and 99. If the two-digit year is
between 00 and 29, the date is converted to the 2000s.
<P>
<P><h3>What if I Don't Like Those Defaults?</h3>
 
<P>
You may want to use your own set of rules instead of relying on the
defaults native to Visual Basic. For example, you may want to enter only a
two-digit year and have 00 to 49 correspond to the years 2000 to 2049 and
have 50 to 99 correspond to the years 1950 to 1999.
<P>
When accepting a date string from the user, test the format of the string
to determine the number of digits entered for the year. According to the
rules for this sample application, 1/11/45 is in the year 2045, and not in
the year 1945. Within the code for the application, change the string to
use the appropriate four-digit year, then convert that date string with the
four-digit year into a date variable.
<P>
<P><h3>Sample Code</h3>
 
<P>
The following code evaluates the data entered into a textbox named txtDate
when you click cmdConvertDate. If the date contains a two-digit year, the
date is converted into a four-digit year date according to the sample rule.
The code then displays the initial date entered, the full year as converted
by the code according to the sample rule, and the full year is converted by
the defaults native to Visual Basic. Finally, the date displayed in txtDate
is converted to a non-ambiguous date with the appropriate four-digit year.
<P>
Once you have developed code to handle your own rules for interpreting
two-digit years, you can build that code into a 32-bit custom control with
the Control Creation Edition of Visual Basic. For more information on this
product and on building your own custom controls, please see the Microsoft
Visual Basic Web site at <B><A HREF="http://www.microsoft.com/vbasic">http://www.microsoft.com/vbasic.</A></B>
<P>
This code requires that dates be entered in the mm/dd/yy format, but it
could easily be changed to handle a different date format:
<P>
<PRE>   Private Sub cmdConvertDate_Click()
       Dim strYear As String
       Dim intSlash As Integer

       If IsDate(txtDate) or txtDate = "2/29/00" Then
           'Find first date separator.
           intSlash = InStr(txtDate, "/")
           If intSlash &gt; 0 Then
               'Find second date separator.
               intSlash = InStr(intSlash + 1, txtDate, "/")
               If intSlash &gt; 0 Then
                   'Extract the year from the date.
                   strYear = Mid(txtDate, intSlash + 1)
                   If Len(strYear) = 2 Then
                       If CInt(strYear) &lt; 50 Then
                       ' Less than 50: year = 20XX.
                           strYear = "20" &amp; strYear
                       Else
                       ' Greater than 50: year = 19XX.
                           strYear = "19" &amp; strYear
                       End If
                   End If
                   MsgBox "Date Entered: " &amp; txtDate
                   MsgBox "Year (Our Rule): " &amp; strYear
                   MsgBox "Year (VB Default): " &amp; Year(txtDate)
               Else
                   MsgBox "Date not in expected format!"
               End If
           Else
               MsgBox "Date not in expected format!"
           End If
       Else
           MsgBox "Not a valid date!"
       End If
       '  Clarify date in txtDate.
       txtDate.Text = Left(txtDate.Text, intSlash) &amp; strYear
   End Sub

</PRE><h2>REFERENCES</h2>
 
<P>
Microsoft Visual Basic Help file; Search on "Date and Variant Data Types,"
"IsDate function," "CDate and CVDate functions"
<P>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
Additional query words: IsDate Year 2000 CDate Date Y2K
<P>

(c) Microsoft Corporation 1997, All Rights Reserved.<BR>
Contributions by David Sceppa, Microsoft Corporation<BR>
Keywords          : kbinterop<BR>
Technology        : kbvba<BR>
Version           : WINDOWS:1.0 2.0 3.0 4.0 5.0<BR>
Platform          : WINDOWS<BR>
Issue type        : kbhowto<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  March 20, 1998</FONT>
	<BR>
	<A HREF="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
