

<HTML>
<HEAD>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>INFO: Using Cursors with Microsoft Message Queue Server </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q178516">
<META NAME="KBModify" CONTENT="1998/01/05">
<META NAME="KBCreate" CONTENT="1997/12/25">
<META NAME="Keywords" CONTENT="MQProg">
<META NAME="KBArea" CONTENT="Support; KB; msmq">
<META NAME="Description" CONTENT="  This article contains information about using cursors with Microsoft Message Queue Server (MSMQ).  Using C API calls you can create as many cursors on an MSMQ queue object as you want.  If you use ActiveX components, there is only one implicit curs...">
<META NAME="Product" CONTENT="msmq">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QAO2,QBQU,QAEV,QAY5,QAEF,QAJQ,QAYC,QAGI,QBVV,QAHV,QAXC,QA9N,QA5C,QAUD,QANJ V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>INFO: Using Cursors with Microsoft Message Queue Server</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  January 5, 1998</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q178516</B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
 
The information in this article applies to:

<UL><LI>Microsoft Message Queue Server version 1.0
</UL> 
<P>
<P><h2>SUMMARY</h2>
 
<P>
This article contains information about using cursors with Microsoft
Message Queue Server (MSMQ).
<P>
Using C API calls you can create as many cursors on an MSMQ queue object as
you want.
<P>
If you use ActiveX components, there is only one implicit cursor per MSMQ
queue object. You can have multiple cursors from an ActiveX component by
performing multiple OPENs of the queue with each OPEN queue instance having
one implicit cursor. However, this increases the overall resource
requirements for this component.
<P>
Cursors point to a specific message, not to a relative position in the
queue.
<P>
For ActiveX components, the implicit cursor can advance through the queue
as it does for MSMQQueue.PeekNext, MSMQQueue.PeekCurrent, and
MSMQQueue.ReceiveCurrent. For ActiveX components that always reference the
first message in the queue (MSMQQueue.Peek and MSMQQueue.Receive) the
implicit cursor is a NULL cursor.
<P>
<P><h2>MORE INFORMATION</h2>
 
<P>
<P><h3>Cursors Are Per Application, not Per Queue</h3>
 
<P>
You can have many applications with different cursors pointing to different
locations in a single queue. It is also possible to have more than one
cursor on a queue from a single application. You may also have multiple
cursors pointing to any combination of multiple queues that are subject to
the one implicit cursor per MSMQ queue object imposed by use of the ActiveX
components.
<P>
<P><h3>Cursor Behavior after an Error in Receive Operation</h3>
 
<P>
The cursor never resets but may advance (as you would want it to) when you
use PeekNext.
<P>
When you use ReceiveCurrent and PeekCurrent, the cursor is not moved when
an error occurs. With PeekNext, the cursor is moved even if there is an
error.
<P>
NOTE: The cursor does not move when there is an invalid handle. For
example, if you use peek next and get the error "buffer overflow",
subsequent PeekCurrent operations return the same message and not the
message pointed to before PeekNext.
<P>
<P><h3>Cursor Behavior in Synchronous and Asynchronous Receive</h3>
 
<P>
Cursors behave the same way in synchronous and asynchronous Receive
operations. However, you should not use the same cursor in overlapping
operations.
<P>
For example, you should not fire another Receive using the same cursor
before the first Receive is completed because this may lead to unexpected
behavior.
<P>
<P><h3>Cursor Behavior after a Message Is Removed</h3>
 
<P>
If an application cursor points to a specific message in a queue, when that
message is removed from the queue by another means, (another application,
or another thread in the same application, or deleted from MSMQ Explorer),
the application's cursor continues to point to a shadow of the removed
message. Subsequent Receive or PeekCurrent operations return an error with
the information that the message has already been received:
<P>
<PRE>   (MQ_ERROR_MESSAGE_ALREADY_RECEIVED)

</PRE><h3>Cursor Behavior after a Queue Is Deleted</h3>
 
<P>
When an application has an open queue (regardless of cursor usage) and the
queue is deleted, subsequent Receive or Peek operations return an error
with the information that the queue has been deleted:
<P>
<PRE>   (MQ_ERROR_QUEUE_DELETED)

</PRE><h3>PeekNext Restrictions</h3>
 
<P>
First, you cannot use PeekNext immediately following a Receive operation.
Instead, you must perform a PeekCurrent or another Receive. When you use C
API calls this means after you pass an MQ_ACTION_RECEIVE with a valid
cursor handle, the next call to MSMQReceiveMessage must not contain an
action of MQ_ACTION_PEEK_NEXT.
<P>
Secondly, you cannot perform a PeekNext after creating a cursor. With
ActiveX this restriction applies to attempting to PeekNext after opening a
queue without first performing a PeekCurrent. When you use C API calls this
means you cannot pass MQ_ACTION_PEEK_NEXT after performing a MQCreateCursor
without first performing a MQ_ACTION_PEEK_CURRENT or MQ_ACTION_RECEIVE. If
you use MQCreateCursor and then call an ActiveX component, the ActiveX
components first action must be a PeekCurrent, Peek, or Receive.
<P>
<P><h2>REFERENCES</h2>
 
<P>
MSMQ SDK Online: MSMQ Guide/MSMQ Messages/Reading Messages; Reading
Messages with Cursors; Message and Cursor Behavior
<P>
<B><A HREF="http://www.microsoft.com/msmq/">http://www.microsoft.com/msmq/</A></B>
<P>
 
<PRE>Keywords          : MQProg
Version           : WINNT:1.0
Platform          : winnt
Issue type        : kbinfo</PRE>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
================================================================================<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  January 5, 1998</FONT>
	<BR>
	<A HREF="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
