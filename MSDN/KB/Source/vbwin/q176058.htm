

<HTML>
<HEAD>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>HOWTO: Pass String Data Between Applications Using SendMessage </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q176058">
<META NAME="KBModify" CONTENT="1997/11/03">
<META NAME="KBCreate" CONTENT="1997/10/31">
<META NAME="Keywords" CONTENT="vb5all vb5howto VBKBWinAPI">
<META NAME="KBArea" CONTENT="Support; KB; vbwin">
<META NAME="Description" CONTENT="  There are many ways to achieve inter-process communication using Visual Basic. Unless you establish an OLE Automation client server relationship, string data is difficult to handle cleanly. The main reason is that 32-bit applications run in a separ...">
<META NAME="Product" CONTENT="Visual Basic for Windows">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QBS0,QAH6,QAH7,QAD7,QATX,QAFF,QAH4,QAJH,QAY5,QAHT,QAC2,QAMB,QAGI,QA9N,QALG V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>HOWTO: Pass String Data Between Applications Using SendMessage</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  November 3, 1997</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q176058</B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
 
The information in this article applies to:

<UL><LI>Microsoft Visual Basic Control Creation, Learning, Professional, and
   Enterprise Editions for Windows, version 5.0
</UL> 
<P>
<P><h2>SUMMARY</h2>
 
<P>
There are many ways to achieve inter-process communication using Visual
Basic. Unless you establish an OLE Automation client server relationship,
string data is difficult to handle cleanly. The main reason is that 32-bit
applications run in a separate address space, so the address of a string in
one application is not meaningful to another application in a different
address space. Using the SendMessage() API function to pass a WM_COPYDATA
message avoids this problem.
<P>
This article demonstrates how to pass string data from one application to
another by using the SendMessage API function with the WM_COPYDATA message.
<P>
<P><h2>MORE INFORMATION</h2>
 
<P>
Visual Basic does not support pointers and castings in the manner of Visual
C++. In order to pass string data from one Visual Basic application to
another, the Unicode string must be converted to ASCII prior to passing it
to the other application. The other application must then convert the ASCII
string back to Unicode.
<P>
The following summarizes how to pass string data from one application to
another.
<P>
<P><h3>Step-by-Step Example</h3>
 

<OL><P><LI>Convert the string to a byte array using the CopyMemory() API.

<P><LI>Obtain the address of the byte array using the VarPtr() intrinsic
   function and copy the address and length of the byte array into a
   COPYDATASTRUCT structure.

<P><LI>Pass the COPYDATASTRUCT to another application using the WM_COPYDATA
   message, setting up the other application to receive the message.

<P><LI>Unpack the structure on the target system using CopyMemory(), and
   convert the byte array back to a string using the StrConv() intrinsic
   function.
<P>
</OL>The next section shows you how to create a sample program that demonstrates
passing string data from one application to another.
<P>
<P><h3>Steps to Create the Sample</h3>
 
<P>
To create this sample, you will create two separate projects; a sending
project and a target project.
<P>
Create the target application:

<OL><P><LI>Start a new Standard EXE project in Visual Basic. Form1 is created by
   default. This project will be your target application.

<P><LI>Add a Label control to Form1.

<P><LI>Copy the following code to the Code window of Form1:
<P>
<P><PRE>      Private Sub Form_Load()
<PRE></PRE>          gHW = Me.hWnd
          Hook
          Me.Caption = "Target"
          Me.Show
          Label1.Caption = Hex$(gHW)
      End Sub

      Private Sub Form_Unload(Cancel As Integer)
          Unhook
      End Sub

</PRE><P><LI>Add a module to the project and paste the following code in the Module1
   code window:
<P>
<P><PRE>      Type COPYDATASTRUCT
<PRE></PRE>              dwData As Long
              cbData As Long
              lpData As Long
      End Type

      Public Const GWL_WNDPROC = (-4)
      Public Const WM_COPYDATA = &amp;H4A
      Global lpPrevWndProc As Long
      Global gHW As Long

      'Copies a block of memory from one location to another.
      Declare Sub CopyMemory Lib "kernel32" Alias "RtlMoveMemory" _
         (hpvDest As Any, hpvSource As Any, ByVal cbCopy As Long)

      Declare Function CallWindowProc Lib "user32" Alias _
         "CallWindowProcA" (ByVal lpPrevWndFunc As Long, ByVal hwnd As _
         Long, ByVal Msg As Long, ByVal wParam As Long, ByVal lParam As _
         Long) As Long

      Declare Function SetWindowLong Lib "user32" Alias "SetWindowLongA" _
         (ByVal hwnd As Long, ByVal nIndex As Long, ByVal dwNewLong As _
         Long) As Long

      Public Sub Hook()
          lpPrevWndProc = SetWindowLong(gHW, GWL_WNDPROC, _
          AddressOf WindowProc)
          Debug.Print lpPrevWndProc
      End Sub

      Public Sub Unhook()
          Dim temp As Long
          temp = SetWindowLong(gHW, GWL_WNDPROC, lpPrevWndProc)
      End Sub

      Function WindowProc(ByVal hw As Long, ByVal uMsg As Long, _
         ByVal wParam As Long, ByVal lParam As Long) As Long
          If uMsg = WM_COPYDATA Then
              Call mySub(lParam)
          End If
          WindowProc = CallWindowProc(lpPrevWndProc, hw, uMsg, wParam, _
             lParam)
      End Function

      Sub mySub(lParam As Long)
          Dim cds As COPYDATASTRUCT
          Dim buf(1 To 255) As Byte

          Call CopyMemory(cds, ByVal lParam, Len(cds))

          Select Case cds.dwData
           Case 1
              Debug.Print "got a 1"
           Case 2
              Debug.Print "got a 2"
           Case 3
              Call CopyMemory(buf(1), ByVal cds.lpData, cds.cbData)
              a$ = StrConv(buf, vbUnicode)
              a$ = Left$(a$, InStr(1, a$, Chr$(0)) - 1)
              Form1.Print a$
          End Select
      End Sub

</PRE><P><LI>Save the project and minimize the Visual Basic IDE.
<P>
</OL>Create the Sending Application:

<OL><P><LI>Start a second instance of the Visual Basic IDE and create a new
   Standard EXE project in Visual Basic. Form1 is created by default.

<P><LI>Add a CommandButton to Form1.

<P><LI>Copy the following code to the Code window of Form1:
<P>
<P><PRE>      Private Type COPYDATASTRUCT
<PRE></PRE>              dwData As Long
              cbData As Long
              lpData As Long
      End Type

      Private Const WM_COPYDATA = &amp;H4A

      Private Declare Function FindWindow Lib "user32" Alias _
         "FindWindowA" (ByVal lpClassName As String, ByVal lpWindowName _
         As String) As Long

      Private Declare Function SendMessage Lib "user32" Alias _
         "SendMessageA" (ByVal hwnd As Long, ByVal wMsg As Long, ByVal _
         wParam As Long, lParam As Any) As Long

      'Copies a block of memory from one location to another.
      Private Declare Sub CopyMemory Lib "kernel32" Alias "RtlMoveMemory" _
         (hpvDest As Any, hpvSource As Any, ByVal cbCopy As Long)

      Private Sub Command1_Click()
          Dim cds As COPYDATASTRUCT
          Dim ThWnd As Long
          Dim buf(1 To 255) As Byte

      ' Get the hWnd of the target application
          ThWnd = FindWindow(vbNullString, "Target")
          a$ = "It Works!"
      ' Copy the string into a byte array, converting it to ASCII
          Call CopyMemory(buf(1), ByVal a$, Len(a$))
          cds.dwData = 3
          cds.cbData = Len(a$) + 1
          cds.lpData = VarPtr(buf(1))
          i = SendMessage(ThWnd, WM_COPYDATA, Me.hwnd, cds)
      End Sub

      Private Sub Form_Load()
      ' This gives you visibility that the target app is running
      ' and you are pointing to the correct hWnd
          Me.Caption = Hex$(FindWindow(vbNullString, "Target"))
      End Sub

</PRE><P><LI>Save the project.
<P>
</OL>Running the Sample:

<OL><P><LI>Restore the target application and press the F5 key to run the project.
   Note that the value of the hWnd displayed in the label.

<P><LI>Restore the sending application and press the F5 key to run the project.
   Verify that the hWnd in the form caption matches the hWnd in the label
   on the target application. Click the CommandButton and the text message
   should be displayed on the form of the target application.
<P>
</OL><h2>REFERENCES</h2>
 
<P>
For more information, please see the following articles in the Microsoft
Knowledge Base:
<P>
<PRE>   ARTICLE-ID: <B><A HREF="../VBWIN/Q168795.htm">Q168795</A></B>
   TITLE     : HOWTO: Hook Into a Window's Messages Using AddressOf

   ARTICLE-ID: <B><A HREF="../VBWIN/Q129947.htm">Q129947</A></B>
   TITLE     : INFO: Win32 Replacement for the hmemcpy Function
</PRE></OL> 
<PRE>Keywords          : vb5all vb5howto VBKBWinAPI
Technology        : kbole
Version           : WINDOWS:5.0
Platform          : WINDOWS
Issue type        : kbhowto</PRE>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
================================================================================<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  November 3, 1997</FONT>
	<BR>
	<A HREF="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
