

<HTML>
<HEAD>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>HOWTO: 32-Bit App Can Determine When a Shelled Process Ends </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q129796">
<META NAME="KBModify" CONTENT="1997/10/13">
<META NAME="KBCreate" CONTENT="1995/05/04">
<META NAME="Keywords" CONTENT="APrgOther vb432 VB4WIN">
<META NAME="KBArea" CONTENT="Support; KB; vbwin">
<META NAME="Description" CONTENT="  Executing the Shell() function in a Visual Basic for Windows program starts another executable program asynchronously and returns control to the Visual Basic application. This shelled program continues to run independent of your application until t...">
<META NAME="Product" CONTENT="Visual Basic for Windows">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QBS0,QAIJ,QAY5,QAH4,QAJH,QAB9,QBV8,QDIV,QAGB,QDL9,QBWQ,QBWO,QBWN,QBWS,QA8T V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>HOWTO: 32-Bit App Can Determine When a Shelled Process Ends</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  October 13, 1997</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q129796</B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



<P><h3> </h3>
 
The information in this article applies to:

<UL><LI>Standard, Professional, and Enterprise Editions of Microsoft Visual
   Basic, 32-bit only, for Windows, version 4.0
</UL> 
<P>
<P><h2>SUMMARY</h2>
 
<P>
Executing the Shell() function in a Visual Basic for Windows program starts
another executable program asynchronously and returns control to the Visual
Basic application. This shelled program continues to run independent of
your application until the user closes it.
<P>
However, if your Visual Basic application needs to wait for the shelled
process to terminate, you could use the Windows API to poll the status of
the application, but this is not a very efficient process. This article
shows by example how to use a better process.
<P>
There is a completely different process that would be used to accomplish
the same thing from a 16-bit application. For additional information on the
16-bit implementation, please see the following article in the Microsoft
Knowledge Base:
<P>
<PRE>   ARTICLE-ID: <B><A HREF="../VBWIN/Q96844.htm">Q96844</A></B>
   TITLE     : HOWTO: Determine When a Shelled Process Has Terminated

</PRE><h2>MORE INFORMATION</h2>
 
<P>
The Win32 API has integrated functionality that enables your application to
wait until a shelled process has completed. To use these functions, you
need to have a handle to the shelled process. To accomplish this, you need
to use the CreateProcess() function to begin your shelled program instead
of the Shell() function.
<P>
<P><h3>Creating the Shelled Process</h3>
 
<P>
In a 32-bit application, you need to create an addressable process. To do
this, use the CreateProcess() function to start your shelled application.
The CreateProcess() function gives your program the process handle of the
shelled process via one of its passed parameters.
<P>
<P><h3>Waiting for the Shelled Process to Terminate</h3>
 
<P>
Having used CreateProcess() to get a process handle, you can pass that
handle to the WaitForSingleObject() function. This causes your Visual
Basic application to suspend execution until the shelled process
terminates.
<P>
Below are the steps necessary to build a Visual Basic for Windows program
that uses the CreateProcess() function to execute the Windows Notepad
(NOTEPAD.EXE) application. This code shows by example how to use the
Windows API CreateProcess() and WaitForSingleObject() functions to wait
until a shelled process terminates before resuming execution.
<P>
The syntax of the CreateProcess() function is extremely complicated, so in
the example code, it is encapsulated into a function called ExecCmd().
ExecCmd() takes one parameter, the command line of the application to
execute.
<P>
<P><h3>Step-by-Step Example</h3>
 

<OL><P><LI>Start a new project in Visual Basic. Form1 is created by default.

<P><LI>Add the following code to the general declarations section of Form1:
<P>
<P><PRE>      Private Type STARTUPINFO
<PRE></PRE>         cb As Long
         lpReserved As String
         lpDesktop As String
         lpTitle As String
         dwX As Long
         dwY As Long
         dwXSize As Long
         dwYSize As Long
         dwXCountChars As Long
         dwYCountChars As Long
         dwFillAttribute As Long
         dwFlags As Long
         wShowWindow As Integer
         cbReserved2 As Integer
         lpReserved2 As Long
         hStdInput As Long
         hStdOutput As Long
         hStdError As Long
      End Type

      Private Type PROCESS_INFORMATION
         hProcess As Long
         hThread As Long
         dwProcessID As Long
         dwThreadID As Long
      End Type

      Private Declare Function WaitForSingleObject Lib "kernel32" (ByVal _
         hHandle As Long, ByVal dwMilliseconds As Long) As Long

      Private Declare Function CreateProcessA Lib "kernel32" (ByVal _
         lpApplicationName As Long, ByVal lpCommandLine As String, ByVal _
         lpProcessAttributes As Long, ByVal lpThreadAttributes As Long, _
         ByVal bInheritHandles As Long, ByVal dwCreationFlags As Long, _
         ByVal lpEnvironment As Long, ByVal lpCurrentDirectory As Long, _
         lpStartupInfo As STARTUPINFO, lpProcessInformation As _
         PROCESS_INFORMATION) As Long

      Private Declare Function CloseHandle Lib "kernel32" (ByVal _
         hObject As Long) As Long

      Private Const NORMAL_PRIORITY_CLASS = &amp;H20&amp;
      Private Const INFINITE = -1&amp;

      Public Sub ExecCmd(cmdline$)
         Dim proc As PROCESS_INFORMATION
         Dim start As STARTUPINFO

         ' Initialize the STARTUPINFO structure:
         start.cb = Len(start)

         ' Start the shelled application:
         ret&amp; = CreateProcessA(0&amp;, cmdline$, 0&amp;, 0&amp;, 1&amp;, _
            NORMAL_PRIORITY_CLASS, 0&amp;, 0&amp;, start, proc)

         ' Wait for the shelled application to finish:
         ret&amp; = WaitForSingleObject(proc.hProcess, INFINITE)
         ret&amp; = CloseHandle(proc.hProcess)
      End Sub

</PRE><P><LI>Add the following code the Form_Click() event procedure of Form1:
<P>
<PRE>      Sub Form_Click ()
         ExecCmd "notepad.exe"
         MsgBox "Process Finished"
      End Sub

</PRE><P><LI>Press the F5 key to run the application.

<P><LI>Using the mouse, click the Form1 window. At this point the Notepad
   application is shelled.
<P>
</OL>NOTE: The MsgBox statement following the ExecCmd() subroutine is not
executed because the WaitForSingleObject() function prevents it. The
message box does not appear until Notepad is closed when the user chooses
Exit from Notepad's File menu (ALT, F, X).
<P>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
Additional query words: GetModuleUsage<BR>
Keywords          : APrgOther vb432 VB4WIN<BR>
Version           : WINDOWS:4.0<BR>
Platform          : WINDOWS<BR>
Issue type        : kbhowto<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  October 13, 1997</FONT>
	<BR>
	<A HREF="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
