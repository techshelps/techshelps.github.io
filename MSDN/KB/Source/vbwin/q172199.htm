

<HTML>
<HEAD>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>HOWTO: Optimize Queries in Visual Basic </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q172199">
<META NAME="KBModify" CONTENT="1997/08/05">
<META NAME="KBCreate" CONTENT="1997/07/31">
<META NAME="Keywords" CONTENT="APrgDataAcc PrgOptTips vb432 VB4WIN vb5all vb5howto kbhowto">
<META NAME="KBArea" CONTENT="Support; KB; vbwin">
<META NAME="Description" CONTENT="  Visual Basic allows you to retrieve data from Jet databases (MDB files) by using Structured Query Language (SQL). These query operations can be made more efficient by implementing some of the suggestions in this article.  This article assumes that ...">
<META NAME="Product" CONTENT="Visual Basic for Windows">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QBS0,QA1S,QA7O,QA7N,QA28,QA2Q,QATJ,QBMW,QAX6,QACF,QABO,QDKY,QA26,QAG2,QAY2 V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>HOWTO: Optimize Queries in Visual Basic</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  August 5, 1997</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q172199</B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
 
The information in this article applies to:

<UL><LI>Microsoft Visual Basic Professional and Enterprise Editions for
   Windows, version 5.0
<LI>Professional and Enterprise Editions of Microsoft Visual Basic, 16-bit
   and 32-bit, for Windows, version 4.0
<LI>Professional Edition of Microsoft Visual Basic version 3.0 with the
   Visual Basic 3.0/Microsoft Access 2.0 Compatibility Layer installed
</UL> 
<P>
<P><h2>SUMMARY</h2>
 
<P>
Visual Basic allows you to retrieve data from Jet databases (MDB files) by
using Structured Query Language (SQL). These query operations can be made
more efficient by implementing some of the suggestions in this article.
<P>
This article assumes that you are using the Microsoft Jet database engine.
If you are querying ODBC tables, many of these points still apply. For
more information regarding improving performance of ODBC queries, please
search on the following words in the Microsoft Knowledge Base:
<P>
<PRE>   ODBC and Optimizing and Tables

</PRE><h2>MORE INFORMATION</h2>
 
<P>
Here are some tips for optimizing your SQL queries:
<P>
<P><h3>Performance Analyzer</h3>
 
<P>
If you have Microsoft Access 95 or 97, you can open the database and use
the Performance Analyzer to profile your queries and suggest improvements.
<P>
<P><h3>Table Design</h3>
 
<P>
When defining a field in a table, choose the smallest data type
appropriate for the data in the field. This increases the number of
records that can fit on a page.
<P>
Fields you use in joins should have the same or compatible data types.
<P>
<P><h3>Compact the Database</h3>
 
<P>
This has two performance benefits:

<OL><P><LI>The Microsoft Jet database engine uses a cost-based method of
</OL>optimization. As your database grows, the optimization scheme may no
longer be efficient. Compacting the database updates the database
statistics and re-optimizes all queries.

<OL><P><LI>As your database grows, it will become fragmented. Compacting writes
</OL>all the data in a table into contiguous pages on the hard disk, improving
performance of sequential scans.
<P>
To compact your database, use the CompactDatabase statement. This example
compacts the database and makes a backup:
<P>
<PRE>   DBEngine.CompactDatabase "C:\VB\BIBLIO.MDB", "C:\VB\BIBLIO2.MDB"
   Kill "C:\VB\BIBLIO.BAK"
   Name "C:\VB\BIBLIO.MDB" As "C:\VB\BIBLIO.BAK"
   Name "C:\VB\BIBLIO2.MDB" As "C:\VB\BIBLIO.MDB"

</PRE></OL>If your database is updated heavily, you may want to consider compacting
nightly.
<P>
<P><h3>Avoid Expressions in Query Output</h3>
 
<P>
Expressions in query output can cause query optimization problems if the
query is used later as input to another query and you add criteria to
the calculated output. In the following example, Query1 is used as input
for a second SELECT statement:
<P>
<PRE>   Dim DB As Database
   Dim RS As RecordSet
   Set DB = DBEngine.Workspaces(0).Opendatabase("Biblio.MDB")
   DB.CreateQueryDef("Query1", _
      "SELECT IIF(Au_ID=1,'Hello','Goodbye') AS X FROM Authors")
   Set RS = DB.OpenRecordSet("SELECT * FROM Query1 WHERE X='Hello'")

</PRE>Because the IIF() expression in Query1 cannot be optimized, the WHERE
condition in second SELECT statement also cannot be optimized. If an
expression gets buried deeply enough in a query tree, you can forget that
it is there. As a result, your entire string of queries cannot be
optimized.
<P>
If you can, merge the SQL into a single level of nesting:
<P>
<PRE>   Set RS = DB.OpenRecordSet("SELECT * FROM Authors WHERE Au_ID=1")

</PRE>For more complex nested queries, expose the fields that make up the
expression:
<P>
<PRE>   DB.CreateQueryDef("Query1", _
      "SELECT IIF(Au_ID=1,'Hello','Goodbye') AS X, Au_ID, FROM Authors")
   Set RS = DB.OpenRecordSet("SELECT * FROM Query1 WHERE Au_ID=1")

</PRE>If you cannot avoid calculated values in query output, place them in the
top-level query and not in lower-level queries.
<P>
<P><h3>Output Only the Fields Needed</h3>
 
<P>
When creating a query, return only the fields you need. If a field doesn't
have to be in the SELECT clause, don't add it. The above example of
exposing additional fields to make nested queries more efficient is an
exception.
<P>
<P><h3>GROUP BY, Joins, and Aggregates</h3>
 
<P>
This is an issue when you are joining two tables. For example, if you join
two tables on the Customer Name field, and also GROUP BY the Customer Name
field, make sure that both the GROUP BY field (Customer Name) and the
field that is in the aggregate (Sum, Count, and so on) come from the same
table.
<P>
NOTE: This query is less efficient because the SUM aggregate is on the Ord
table and the GROUP BY clause is on the Cust table:
<P>
<PRE>   SELECT Cust.CustID,
          FIRST(Cust.CustName) AS CustName,
          SUM(Ord.Price) AS Total
   FROM Cust INNER JOIN Ord ON Cust.CustID = Ord.CustID
   GROUP BY Cust.CustID

</PRE>A more efficient query would be to GROUP BY on Ord.CustID:
<P>
<PRE>   SELECT Ord.CustID,
          FIRST(Cust.CustName) AS CustName,
          SUM(Ord.Price) AS Total
   FROM Cust INNER JOIN Ord ON Cust.CustID = Ord.CustID
   GROUP BY Ord.CustID

</PRE>NOTE: The First and Last functions do not have the overhead of other
aggregates and should not weigh very heavily in this decision.
<P>
<P><h3>GROUP BY As Few Fields As Possible</h3>
 
<P>
The more fields in the GROUP BY clause, the longer the query takes to
execute. Use the First aggregate function to help reduce the number of
fields required in the GROUP BY clause.
<P>
Less efficient:
<P>
<PRE>   SELECT Cust.CustID,
          Cust.CustName,
          Cust.Phone,
          SUM(Ord.Price) AS Total
   FROM Cust INNER JOIN Ord ON Cust.CustID = Ord.CustID
   GROUP BY Cust.CustID, Cust.CustName, Cust.Phone

</PRE>More efficient:
<P>
<PRE>   SELECT Ord.CustID,
          FIRST(Cust.CustName) AS CustName,
          FIRST(Cust.Phone) AS Phone,
          SUM(Ord.Price) AS Total
   FROM Cust INNER JOIN Ord ON Cust.CustID = Ord.CustID
   GROUP BY Ord.CustID

</PRE><h3>Nest GROUP BY Clause Before Joining</h3>
 
<P>
If you are joining two tables and only grouping by fields in one of them,
it may be more efficient to split the SELECT statement into two queries.
making the SELECT statement with the GROUP BY clause into a nested query
joined to the non-grouped table in the top-level query.
<P>
Less efficient:
<P>
<PRE>   SELECT Ord.CustID,
          FIRST(Cust.CustName) AS CustName,
          FIRST(Cust.Phone) AS Phone,
          SUM(Ord.Price) AS Total
   FROM Cust INNER JOIN Ord ON Cust.CustID = Ord.CustID
   GROUP BY Ord.CustID

</PRE>More efficient:
<P>
<PRE>   Query1:
   SELECT CustID, SUM(Price) AS Total
   FROM Ord
   GROUP BY CustID

   Query2:
   SELECT Query1.CustID, Cust.CustName, Cust.Phone, Query1.Total
   FROM Cust INNER JOIN Ord ON Cust.CustID = Ord.CustID

</PRE><h3>Index Both Fields Use in Join</h3>
 
<P>
When joining tables, try to index the fields on both sides of a join. This
can speed query execution by allowing the query optimizer to use more
sophisticated internal join strategy.
<P>
However, if you know one table is going to remain relatively small (occupy
1-2 2K pages), it may be more efficient to remove indexes in that
table because fewer pages will have to be read into memory. You should try
this on a case-by-case basis.
<P>
<P><h3>Add Indexes to Speed Searches and Sorts</h3>
 
<P>
Place an index on all fields that are used in a join or in a restriction.
With the use of Rushmore query optimization technology, the Microsoft Jet
2.0 and later database engine is able to take advantage of multiple
indexes on a single table, which makes indexing multiple fields
advantageous.
<P>
Avoid restrictive query criteria on calculated and non-indexed columns
whenever possible.
<P>
Use sorting judiciously, especially with calculated and non-indexed fields.
<P>
<P><h3>Use Optimizable Expressions</h3>
 
<P>
Try to construct your queries so that Rushmore technology can be used to
help optimize them. Rushmore is a data-access technology that permits sets
of records to be queried very efficiently. With Rushmore, when you use
certain types of expressions in query criteria, your query will run much
faster. Rushmore does not automatically speed up all your queries. You must
construct your queries in a certain way for Rushmore to be able to improve
them.
<P>
Use the REFERENCES section at the end of the article to locate more
specific information.
<P>
<P><h3>Use COUNT(*) Instead of COUNT([Column Name])</h3>
 
<P>
The Microsoft Jet database engine has special optimizations that allow
COUNT(*) to be executed much faster than COUNT([Column Name]).
<P>
NOTE: These two operations also have slightly different behavior:

<UL><LI>Count(*) counts all rows returned.

<LI>Count([Column Name]) counts all rows where [Column Name] is not NULL.
<P>
</UL><h3>Avoid LIKE on Parameters</h3>
 
<P>
Because the value of the parameter is unknown at the time the query is
compiled, indexes will not be used. You can gain performance by
concatenating the parameter value as a literal in the SQL statement.
<P>
Use the REFERENCES section at the end of the article to locate more
specific information.
<P>
<P><h3>Avoid LIKE and Leading Wildcard</h3>
 
<P>
If you use the LIKE operator with a wildcard to find approximate matches,
use only one asterisk at the end of character string to ensure that an
index is used. For example, the following criteria uses an index:
<P>
<PRE>   Like "Smith"
   Like "Sm*"

</PRE>The following criteria does not use an index:
<P>
<PRE>   Like "*sen"
   Like "*sen*"

</PRE><h3>Test Joins with Restrictions</h3>
 
<P>
If you use criteria to restrict the values in a field used in a join, test
whether the query runs faster with the criteria placed on the "one" side
or the "many" side of the join. In some queries, you get faster
performance by adding the criteria to the field on the "one" side of the
join instead of the "many" side.
<P>
<P><h3>Use Intermediate Tables</h3>
 
<P>
Use SELECT INTO statements to create work tables, especially if the
results are going to be used in a number of other queries. The more work
you can do up-front, the more efficient the process.
<P>
<P><h3>Avoid NOT IN with SubSelects</h3>
 
<P>
Using sub-selects and NOT IN is poorly optimized. Converting to nested
queries or OUTER JOINs are more efficient. The following example finds
customers without orders:
<P>
Less efficient:
<P>
<PRE>      SELECT Customers.*
      FROM Customers
      WHERE Customers.[Customer ID]
            NOT IN (SELECT [Customer ID] FROM Orders);

</PRE>More efficient:
<P>
<PRE>      SELECT Customers.*
      FROM Customers LEFT JOIN Orders
           ON Customers.[Customer ID] = Orders.[Customer ID]
      WHERE ((Orders.[Customer ID] Is Null));

</PRE><h2>REFERENCES</h2>
 
<P>
For more information about how to optimize queries with Rushmore
technology:
<P>
In Microsoft Visual Basic 4.0 Help, search for "Rushmore technology", then:
<P>
<PRE>  "Optimizing Queries with Rushmore Technology"

</PRE>In Visual Basic 5.0 Books Online, search for "Rushmore Technology", then:
<P>
<PRE>  "Optimizing Queries"

</PRE>In Microsoft Access 2.0 Help, search for "Rushmore Technology", then:
<P>
<PRE>  "Optimizing Queries with Rushmore Technology"
  "Combining Optimizable Expressions for Rushmore"

</PRE>In Microsoft Access 95 Help, search for "Rushmore Technology."
<P>
In Microsoft Access 97 Help, search for "Rushmore Queries."
<P>
The Microsoft Jet Database Engine Programmer's Guide.
<P>
For more information about creating queries in code, please see the
following articles in the Microsoft Knowledge Base:
<P>
<PRE>   ARTICLE-ID: <B><A HREF="../ACCESS/Q117544.htm">Q117544</A></B>
   TITLE     : INF: Query by Form (QBF) Using Dynamic QueryDef (2.0)

   ARTICLE-ID: <B><A HREF="../vbapps/Q136062.htm">Q136062</A></B>
   TITLE     : INF: Query by Form (QBF) Using Dynamic QueryDef (7.0/97)
</PRE>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
Additional query words: Jet DAO speedier quicker optimum<BR>
Keywords          : APrgDataAcc PrgOptTips vb432 VB4WIN vb5all vb5howto kbhowto<BR>
Component         : jet<BR>
Version           : WINDOWS:5.0<BR>
Platform          : WINDOWS<BR>
Issue type        : kbinfo<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  August 5, 1997</FONT>
	<BR>
	<A HREF="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
