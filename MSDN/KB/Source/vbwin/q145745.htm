

<HTML>
<HEAD>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Function Differences Between Asc/AscB/AscW and Chr/ChrB/ChrW </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q145745">
<META NAME="KBModify" CONTENT="1996/03/08">
<META NAME="KBCreate" CONTENT="1996/02/06">
<META NAME="Keywords" CONTENT="kbprg kbhowto">
<META NAME="KBArea" CONTENT="Support; KB; vbwin">
<META NAME="Description" CONTENT="  For years, BASIC programmers have been using the Asc and Chr functions to access and manipulate the ASCII character set. With the advent of Unicode acceptance in mainstream operating systems and applications, the need for improved versions of the A...">
<META NAME="Product" CONTENT="Visual Basic for Windows">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QAY5,QBS0,QAOX,QALG,QAB9,QAUD,QBV8,QALQ,QAKD,QAJQ,QATX,QABB,QAMA,QAWN,QAKE V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>Function Differences Between Asc/AscB/AscW and Chr/ChrB/ChrW</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  March 8, 1996</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q145745</B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
The information in this article applies to:
<P>
- Standard, Professional and Enterprise Editions of Microsoft Visual
<PRE>  Basic, 16-bit and 32-bit, for Windows, version 4.0
</PRE> 
<P>
<P><h2>SUMMARY</h2>
 
<P>
For years, BASIC programmers have been using the Asc and Chr functions to
access and manipulate the ASCII character set. With the advent of Unicode
acceptance in mainstream operating systems and applications, the need for
improved versions of the Asc and Chr functions has developed. To meet this
demand, Microsoft Visual Basic 4.0 for Windows includes the AscB/ChrB and
AscW/ChrW functions.
<P>
<P><h2>MORE INFORMATION</h2>
 
<P>
Unicode is a standard that is designed to replace the ANSI standard for
encoding characters in a numeric form. Because the ANSI standard only uses
a single byte to represent each character, it is limited to a maximum of
256 different characters. While this is sufficient for the needs of an
English speaking audience, it falls short when the worldwide software
market is considered. With the Unicode standard, each character is
represented by two bytes, so that the entire Unicode character set includes
65,536 possible locations.
<P>
Both Microsoft Windows NT and Microsoft OLE 2.0 are entirely Unicode based,
and Visual Basic version 4.0 represents all strings internally in Unicode
format. The AscW and ChrW functions allow access to the full range of
Unicode characters. These functions work in the same way as the original
Asc and Chr functions except that they support arguments from 0 to 65,535
instead of just from 0 to 255. Many Visual Basic objects (such as the debug
window and the label and text box) return a "?" when these objects do not
know how to display an Unicode character.
<P>
Because all strings are now represented internally in Unicode format, it
is not as simple as it used to be to represent binary data in a string.
Using the Chr function to assign data to a string does not result in the
same behavior as before. For example:
<P>
<PRE>   stringvar = Chr(65)

</PRE>results in a two-byte long string, where byte 1 has a value of 65 and byte
2 has a value of 0 (this is the Unicode representation of the letter "A").
Be sure to keep in mind that converting from ANSI to Unicode does not
always entail just adding a second byte with a value of zero as it does in
this case. For example, most of the ANSI character codes in the range
130-159 have completely different Unicode values. Try executing a
<PRE>'Debug.Print AscW(Chr(130))' and you a value of 8218 is displayed.

</PRE>Currently, Microsoft Windows requires a little endian processor, which
means that in a multiple byte entity the first byte is the least
significant, and significance increases in successive bytes. This explains
why the Unicode character "A" is represented internally as the following:
<P>
<PRE>   -------------------
   |   65   |    0   |
   -------------------
     byte 0     byte 1

</PRE>The AscB and ChrB functions can be used to replicate what used to be
accomplished by the Asc and Chr functions, because these functions allow
the manipulation of single byte quantities. If you would like a four-byte
string that has the binary values of 65, 66, 67, and 68 consecutively then
using the Chr function will not work. You must instead use the ChrB
function. For example:
<P>
<PRE>   stringvar = ChrB(65) &amp; ChrB(66) &amp; ChrB(67) &amp; ChrB(68)

</PRE>Alternatively, you can use the ability to create arrays of the new byte
data type and manipulate your binary data that way.
<P>
Listed below is an explanation of the results of some simple uses of these
functions to further clarify this information.
<P>
<PRE>Print Asc(Chr(255))      --&gt; "255"

</PRE>Nothing new here, except that the Chr function is returning a Unicode
character that occupies two bytes instead of a one-byte ANSI character.
<P>
<PRE>Print Asc(ChrB(255))    --&gt; 5 - Invalid procedure call.

</PRE>This usage returns an error because the Asc function always expects at
least a two-byte parameter and the ChrB function is only returning a single
byte.
<P>
<PRE>Print Asc(Chr(256))      --&gt; 5 - Invalid procedure call.

</PRE>Although the Chr function returns a two-byte Unicode character, it still
only takes numbers between 0 and 255 for its argument (note that on a DBCS
enabled system, Asc/Chr handle two-byte DBCS characters, converting them to
and from Unicode). Using the ChrW function allows access to the full 65,536
Unicode character locations.
<P>
<PRE>Print AscW(ChrW(256))   --&gt; "256"

</PRE>This is the new version of the first statement in this section. The ChrW
function takes a value from 0 to 65,536 and returns that character (on
32-bit systems). The AscW function interprets this two-byte character as a
Unicode character and returns the correct Unicode value for that character.
<P>
<PRE>Print Asc(ChrW(256))    --&gt; "65"
Print Asc(ChrW(5000))   --&gt; "63"

</PRE>What is happening here is that the ChrW function is being evaluated first.
ChrW(256) is the character "A", and so the function reduces to Asc("A"),
and the Unicode (and ANSI) number for "A" is 65. Because Visual Basic
does not know how to display the character represented by Chr(5000) it just
displays a "?", and as expected, the Unicode and ANSI value for "?" is 63.
<P>
<PRE>Print AscB(Chr(65))      --&gt; "65"
Print AscB(ChrW(256))    --&gt; "0"
Print AscB(ChrW(257))    --&gt; "1"
Print AscB(ChrW(555))    --&gt; "43"
</PRE>Print AscB(ChrW(65535))  --&gt; "255"
<P>
All of these return values can be explained by understanding how each
character is represented internally (see the little-endian reference above)
and by the fact that the AscB function looks only at the first byte of the
character it receives. Visually it looks like the following diagram:
<P>
<PRE>             -------------------
   Chr(65)   |   65   |    0   |
             -------------------
   Chr(256)  |    0   |    1   |
             -------------------
   Chr(257)  |    1   |    1   |
             -------------------
   Chr(555)  |   43   |    1   |
             -------------------
   Chr(65535)|   255  |  255   |
             -------------------
               byte 0    byte 1

</PRE>The AscB function just returns whatever the first byte of the character is.
<P>
<PRE>Print ChrB(65)         --&gt; ""

</PRE>Visual Basic prints nothing for this call to the ChrB function because the
ChrB function is only returning a one-byte string. One byte strings like
this mean nothing to Visual Basic because they do not constitute a valid
Unicode character (or series of characters).
<P>
<PRE>Print ChrB(65) &amp; ChrB(0)   --&gt; "A"

</PRE>In this case, we are concatenating two one-byte strings into a single
two-byte string. Because the resulting bit pattern is the same as the bit
pattern for the Unicode "A", that is what Visual Basic prints.
<P>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
Additional reference words: 4.00 vb4win vb4all<BR>
KBCategory: Kbprg kbhowto<BR>
Kbsubcategory: PrgOther<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  March 8, 1996</FONT>
	<BR>
	<A HREF="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
