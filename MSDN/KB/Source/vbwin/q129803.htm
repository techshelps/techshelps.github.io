

<HTML>
<HEAD>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Variable Coercion Rules in Visual Basic Version 4.0 </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q129803">
<META NAME="KBModify" CONTENT="1995/10/30">
<META NAME="KBCreate" CONTENT="1995/05/04">
<META NAME="Keywords" CONTENT="kbprg kbcode">
<META NAME="KBArea" CONTENT="Support; KB; vbwin">
<META NAME="Description" CONTENT="  When two or more variables of different types are involved in an expression, Visual Basic uses a set of internal type coercion rules to change the different types into a single type. For every combination of input and result types, there is a speci...">
<META NAME="Product" CONTENT="Visual Basic for Windows">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QBS0,QAHH,QAP2,QATX,QAPF,QAIB,QAFO,QA5F,QAMA,QBVV,QA4Q,QANY,QAH4,QAKC,QAVX V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>Variable Coercion Rules in Visual Basic Version 4.0</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  October 30, 1995</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q129803</B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
The information in this article applies to:

<UL><LI>Standard, Professional, and Enterprise Editions of Microsoft
   Visual Basic, 16-bit and 32-bit, for Windows, version 4.0
</UL> 
<P>
<P><h2>SUMMARY</h2>
 
<P>
When two or more variables of different types are involved in an
expression, Visual Basic uses a set of internal type coercion rules to
change the different types into a single type. For every combination of
input and result types, there is a specific coercion rule. (Contrary to
some speculation, Variants are not involved.) This makes Visual Basic
faster and more efficient, but it can produce some puzzling results if you
aren't aware of what Visual Basic is doing behind the scenes. This article
lays out some of the less obvious conversion rules, their benefits, and
some possible scenarios where this can lead to unexpected results.
<P>
<P><h2>MORE INFORMATION</h2>
 
<P>
Coercion between numeric types is pretty straightforward. Smaller types
(integer) coerced to larger types (double) simply have their value
assigned. Larger types (double) coerced to smaller types (integer) have
their value assigned, but generate an Overflow error if the smaller type
cannot contain the larger type's value. Other coercion rules are not as
obvious.
<P>
NOTE: Any type can be implicitly coerced to any other type (excluding
objects).
<P>
<PRE>   Source Type    Coerced to      Apply this rule
   --------------------------------------------------------------

   Integer        Boolean         0=False, non-zero=True

   Boolean        Byte            False=0, True=255

   Boolean        any numeric     False=0, True=-1
                  (except Byte)

   String         Date            String is analyzed for mm/dd/yy,
                                  and so on

   Date           numeric type    Coerce to Double and use
                                  DateSerial(Double)

   numeric type   Date            Use number as serial date, check
                                  valid date range

   numeric type   Byte            Error if negative

   String         numeric type    Strings are treated as a Double
                                  when they need to represent a
                                  number

</PRE>Some of these rules allow for simplified syntax when writing your code. For
example:
<P>
<PRE>   ReturnCode% = FunctionThatReturnsAnInteger()
   If (ReturnCode%) Then ...

</PRE>This piece of code takes advantage of the implicit Integer to Boolean
coercion and correctly evaluates the expression in the If statement.
<P>
<P><h3>Note on Strings as Numbers</h3>
 
<P>
Treating Strings as Doubles when they need to represent a number gives the
String the maximum possible range and nearly the best possible precision
(only Currency can have more precision, at a sacrifice in range). Because
these coercions are generated by the compiler, the rule must be decided up
front without regard to the actual content of the string.
<P>
Note that "treating as Double" is not quite the same as "coercing to
Double." For example, addition and subtraction operators treat Currency as
a preferable type to Double. Currency plus String will be treated as
Currency plus Double, which would use Currency addition. Thus the string
will be coerced directly to Currency.
<P>
<P><h3>Why Use Coercion Rules?</h3>
 
<P>
The largest reason is performance. Hard-coded coercion rules make Visual
Basic version 4.0 faster and more efficient and provide backward
compatibility to pervious versions of Visual Basic. One of the big speed
advantages comes because Visual Basic version 4.0 now knows the data type
of control properties. Knowing the type of properties provides trememdous
performance advantages. Without it, for example, setting a property
required Basic to package the value in a Variant, and the control to unpack
and coerce it to the right type. Now the control knows it is receiving the
correct specific type, and Basic does a direct coercion to that type
without ever involving the overhead of a Variant.
<P>
<P><h3>Unexpected Results</h3>
 
<P>
The following code pieces show a few common scenarios where errors can be
generated by Visual Basic if types and coercion rules are not carefully
considered:
<P>
<PRE>   Dim I As Integer, J As Integer
   Dim L As Long, M As Long
   Dim S As String

   I = 32767
   L = 32767
   M = 1
   S = "Hello World!"

   J = I + 1
   ' Overflow. Integer upper limit = 32767. No coercion applied.

   J = I + M
   ' Overflow. I+M is coerced to a Long and the value 32768 is generated,
   ' but when the assignment operator is resolved, this Long value is
   ' coerced back to Integer (J's type) and overflows.

   L = I + 1
   ' Overflow. Coercion is not applied until the assignment operator is
   ' resolved. I + 1 'Overflow's the temporary Integer variable created
   ' to resolve the plus operator.

   If I Then Print "I is True"
   If Not I Then Print "Not I is True"
   ' This prints both 'I is True and Not I is True', a logical
   ' contradiction. The value of I = 32767, which is non-zero and under
   ' the Integer to Boolean rule, is coerced to True. With 'Not I',
   ' the NOT operator is applied first, which produces -32768 which is
   ' also non-zero and, therefore, True.

</PRE>The following scenario shows how implicit conversion can generate a variety
of unexpected results. You can add this code to a new program and run it
too see the output.
<P>
<PRE>   Private Sub Form_Click()
      Call MySub(1, 23) '&lt;-- Note: passing *numbers*!
   End Sub

   Private Sub MySub (a As String, b As String)
      Debug.Print "a = "; a, , TypeName(a)
      Debug.Print "b = "; b, , TypeName(b)
      Debug.Print "a + b = "; a + b, , TypeName(a + b)
      Debug.Print "a + b - 1 ="; a + b - 1, TypeName(a + b - 1)
      Debug.Print "1 - a + b ="; 1 - a + b, TypeName(1 - a + b)
      Debug.Print "a + b + 1 ="; a + b + 1, TypeName(a + b + 1)
      Debug.Print "1 + a + b ="; 1 + a + b, TypeName(1 + a + b)
      Debug.Print "(1 + b) / a ="; (1 + b) / a, TypeName((1 + b) / a)
   End Sub

</PRE>The output is:
<P>
<PRE>   a = 1             String
   b = 23            String
   a + b = 123       String
   a + b - 1 = 122   Double
   1 - a + b = 23    Double
   a + b + 1 = 124   Double
   1 + a + b = 25    Double
   (1 + b) / a = 24  Double
</PRE>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
Additional reference words: 4.00 vb4win vb4all<BR>
KBCategory: kbprg kbcode<BR>
KBSubcategory: PrgOther<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  October 30, 1995</FONT>
	<BR>
	<A HREF="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
