

<HTML>
<HEAD>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>HOWTO: Determine When a Shelled Process Has Terminated </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q96844 ">
<META NAME="KBModify" CONTENT="1997/10/13">
<META NAME="KBCreate" CONTENT="1993/03/29">
<META NAME="Keywords" CONTENT="APrgOther vb416 VB4WIN kbfasttip">
<META NAME="KBArea" CONTENT="Support; KB; vbwin">
<META NAME="Description" CONTENT="  Executing the Shell() function in a Visual Basic for Windows program starts another executable program asynchronously and returns control to the Visual Basic application. The shelled program continues to run indefinitely until the user closes it --...">
<META NAME="Product" CONTENT="Visual Basic for Windows">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QBS0,QAH4,QAUD,QAY5,QDL9,QBWQ,QBWO,QBWN,QBIC,QAB9,QBV8,QAGB,QA5F,QAMA,QAJH V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>HOWTO: Determine When a Shelled Process Has Terminated</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  October 13, 1997</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q96844 </B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
 
The information in this article applies to:

<UL><LI>Professional and Enterprise Editions of Microsoft Visual Basic, 16-bit
   only, for Windows, version 4.0
<LI>Standard and Professional Editions of Microsoft Visual Basic for
   Windows, versions 2.0 and 3.0
<LI>Microsoft Visual Basic programming system for Windows, version 1.0
</UL> 
<P>
<P><h2>SUMMARY</h2>
 
<P>
Executing the Shell() function in a Visual Basic for Windows program starts
another executable program asynchronously and returns control to the Visual
Basic application. The shelled program continues to run indefinitely until
the user closes it -- not until your Visual Basic program terminates.
However, your program can wait until the shelled program has finished by
polling the return value of the Windows API GetModuleUsage() function. This
article describes the method and provides a code example.
<P>
NOTE: The GetModuleUsage() function does not exist in Windows NT.
<P>
There is a completely different process that would be used to accomplish
the same thing from a 32-bit application. For additional information on the
32-bit implementation, please see the following article in the Microsoft
Knowledge Base:
<P>
<PRE>   ARTICLE-ID: <B><A HREF="../VBWIN/Q129796.htm">Q129796</A></B>
   TITLE     : How to Determine When a Shelled 32-bit Process Has
               Terminated

</PRE><h2>MORE INFORMATION</h2>
 
<P>
This information is included with the Help file provided with Microsoft
Visual Basic version 3.0 for Windows, and on the Microsoft Developer
Network (MSDN) Visual Basic Starter Kit provided with Microsoft Visual
Basic version 4.0, Professional and Enterprise Editions.
<P>
<P><h3>Technique Also Works with MS-DOS Programs</h3>
 
<P>
The technique described in this article also works for MS-DOS programs. The
return value from the Visual Basic Shell() function is a unique instance
handle to the MS-DOS session that was started in the Shell(). If you call
GetModuleUsage() with that handle after the MS-DOS session in question has
ended, GetModuleUsage() will return 0 because the handle is no longer
valid. This can be verified with the following code:
<P>
<PRE>   Debug.Print Shell("EDIT.COM")
   Debug.Print Shell("EDIT.COM")
   Debug.Print Shell("EDIT.COM")

</PRE>Executing this code will show that the Shell() return value is unique for
each of the shelled MS-DOS programs. Using GetModuleUsage() on one of these
handles after the associated EDIT.COM program has been terminated will
return zero (because the handle isn't valid anymore) and take you out of
the wait loop.
<P>
<P><h3>Monitoring the Status of a Shelled Process</h3>
 
<P>
By using the Windows API GetModuleUsage() function, your Visual Basic
program can monitor the status of a shelled process. The return value from
the Shell() function can be used to call the GetModuleUsage() function
continuously within a loop to find out if the shelled program has finished.
If the Shell() function is successful, the return value is the instance
handle for the shelled program. This instance handle can be passed to the
GetModuleUsage() function to determine the reference count for the module.
When the GetModuleUsage() function returns a value of 0 or less, the
shelled program has finished.
<P>
This algorithm works correctly regardless of the WindowStyle used to shell
the program. In addition, this method works correctly when:

<UL><LI>Shelling to Windows programs.
<LI>Shelling to MS-DOS programs.
<LI>Shelling to applications that do not display a window.
<P>
</UL>Below are the steps necessary to build a Visual Basic for Windows program
that uses the Shell() function to execute the Windows Notepad accessory
(NOTEPAD.EXE). The code shows by example how to use the Windows API
GetModuleUsage() function to wait until a shelled process terminates before
resuming execution.
<P>
<P><h3>Step-by-Step Example</h3>
 

<OL><P><LI>Start Visual Basic for Windows or from the File menu, choose New Project
   (ALT, F, N) if Visual Basic for Windows is already running. Form1 is
   created by default.

<P><LI>Add the following code to the general declarations section of Form1:
<P>
<P><PRE>      Declare Function GetModuleUsage% Lib "Kernel" (ByVal hModule%)
</PRE>   
<P><PRE>      Private Function TestFunc(ByVal lVal As Long) As Integer
      'this function is necessary since the value returned by Shell is an
      'unsigned integer and may exceed the limits of a VB integer
<PRE></PRE>         If (lVal And &amp;H8000&amp;) = 0 Then
           TestFunc = lVal And &amp;HFFFF&amp;
         Else
           TestFunc = &amp;H8000 Or (lVal And &amp;H7FFF&amp;)
         End If
      End Function

</PRE><P><LI>Add the following code to the Form_Click event procedure of Form1:
<P>
<PRE>      Sub Form_Click()
        lRet&amp; = Shell("NOTEPAD.EXE")       ' Modify the path as necessary.
        x% = TestFunc(lRet&amp;)
        While GetModuleUsage(x%) &gt; 0    ' Has Shelled program finished?
           z% = DoEvents()              ' If not, yield to Windows.
        Wend
        MsgBox "Shelled application just terminated", 64
      End Sub

</PRE><P><LI>From the Run menu, choose Start (ALT, R, S) to run the program.

<P><LI>Using the mouse, click in the Form1 window. At this point, the Notepad
   application is shelled.
<P>
</OL>The MsgBox statement following the Shell() Function is not executed because
the While loop prevents it. The message box does not appear until Notepad
is closed when the user chooses Exit from Notepad's File menu (ALT, F, X).
<P>
 
<PRE>Keywords          : APrgOther vb416 VB4WIN kbfasttip
Version           : WINDOWS:2.0,3.0,\4.0
Platform          : WINDOWS
Issue type        : kbhowto</PRE>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
================================================================================<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  October 13, 1997</FONT>
	<BR>
	<A HREF="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
