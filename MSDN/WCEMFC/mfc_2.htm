<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Using MFC for Windows CE as an Application Framework</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>

<h2><a name="_vcce_using_mfc_for_windows_ce_as_an_application_framework"></a>Using MFC for Windows CE as an Application Framework</h2>
<p>
As useful as MFC is as a basic Windows class library, there's a lot more to it than that. MFC is also a complete application framework. An application framework provides both a structural foundation, upon which many types of applications can be built, and a set of fundamental components that you can use to expand on the structure and adapt it to different purposes. MFC for Windows CE is a framework specifically designed for creating Windows CE applications.</p>
<p>
One example of this is the MFC message mapping architecture. Windows CE is a message-driven operating system. This means the operating system communicates with an application window by placing messages in the message queue of the thread that created the window. The thread has a message pump, which removes the messages from the queue and dispatches them to the appropriate window procedure. In traditional, non-MFC applications, the window procedure is a large C++ switch statement whose purpose is to determine what kind of message it has received, then process the message accordingly.</p>
<p>
The MFC framework manages messages a little bit more elegantly. <b>CCommandTarget</b> is the base class for MFC's message mapping architecture. The framework provides a message pump for every class derived from <b>CCommandTarget</b>. These classes use message maps, rather than switch statements, to route messages to their message handler functions. A message map is implemented by a set of simple macros defined in the MFC library. Although you can maintain your classes' message maps and handler functions yourself, the WCE MFC ClassWizard automates this process.</p>
<p>
You generally won't derive classes from <b>CCommandTarget</b> directly. There are several classes derived from <b>CCommandTarget</b>, however, from which you will frequently derive classes of your own. One of the most important classes derived from <b>CCommandTarget</b> is the <b>CWnd</b> class. <b>CWnd</b> encapsulates all the behavior of Windows CE windows and all the functionality related to window management. This class and its subclasses are fundamental to almost every Windows CE application.</p>
<p>
Another notable class derived from <b>CCommandTarget</b> is <b>CWinApp</b>. Every MFC application must have exactly one instance of a class derived from <b>CWinApp</b>. This object, called the application object, is always declared with global scope. This ensures that the application object is constructed before Windows CE calls <b>WinMain</b>, which is the Windows version of the C/C++ <b>main</b> function. <b>WinMain</b> calls the application object's member functions to initialize, run, and terminate the application. The MFC framework provides the implementation of the <b>WinMain</b> function.</p>
<p>
If you're writing an application that has a standard user interface, you will reap enormous benefits from taking advantage of the MFC document/view architecture. This architecture is based on three important classes, <b>CDocument</b>, <b>CView</b>, and <b>CFrameWnd</b>. Document classes, which you derive from <b>CDocument</b>, encapsulate an application's data and are responsible for saving the data and retrieving it from storage. View classes, which you derive from <b>CView</b> or one of it's subclasses, provide the functionality necessary to present the data to the user and to receive user input. A single document may have several views associated with it, so you can present the same data in a variety of formats within the same application. When a user edits a view, the view object notifies the document object. The document object, in its turn, updates all the views associated with it whenever the data changes. The frame window, which you derive from <b>CFrameWnd</b>, provides the frame that contains the views and the command bar.</p>
<p>&nbsp;</p></body>
</HTML>
