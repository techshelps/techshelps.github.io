<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Initializing MAPI</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h3><a name="_mapi1book_initializing_mapi"></a>Initializing MAPI</h3>
<p>
All client applications that use the MAPI libraries must call the <a href="function_6ycl.htm"><b>MAPIInitialize</b></a> function. <b>MAPIInitialize</b> initializes global data for the session and prepares the MAPI libraries to accept calls. There are two flags that are important to set in some situations:</p>
<p class=indent1>
MAPI_NT_SERVICE</p>
<p class=indent1>
MAPI_MULTITHREAD_NOTIFICATIONS</p>
<p>
Set the MAPI_NT_SERVICE flag if your client is implemented as a Windows NT service. If your client is a Windows NT service and you do not set this flag, MAPI will not recognize it as a service. </p>
<p>
The MAPI_MULTITHREAD_NOTIFICATIONS flag relates to how MAPI manages notifications. MAPI creates a hidden window that receives window messages when changes occur to an object generating notifications. The window messages are processed at some point, causing the notifications to be sent and the appropriate <a href="inter010_4y2h.htm"><b>IMAPIAdviseSink::OnNotify</b></a> methods to be called. </p>
<p>
MAPI either creates the notification window on the thread that was used for your first <b>MAPIInitialize</b> call or on a separate thread — a thread dedicated to handling notifications. MAPI expects the thread that is used to create the hidden notification window to:
<ul>
<li>
Have a message loop.</li>
<li>
Remain unblocked throughout the life of the session.</li>
<li>
Have a longer lifetime than any other thread created by your client. </li>
</ul>
<p>
You can choose which thread is used by setting a flag in the first <b>MAPIInitialize</b> call. The danger in allowing one of your threads to handle the notifications is that if the thread disappears, the notification window is destroyed and notifications can no longer be sent to any of your other threads. Also, special processing might be needed to control the dispatching of the notification messages that are posted to the hidden window's message queue.</p>
<p>
If you use a separate window to handle notifications, be assured that notifications will appear at the appropriate time on an appropriate thread. You will not need any special code to check for and process the Windows messages that are posted to the notification window. </p>
<p>
MAPI recommends that the following types of client applications use a separate thread to create the hidden window for notification support:
<ul>
<li>
All 32-bit multithreaded clients</li>
<li>
Single-threaded Windows NT services and Win 32 console applications</li>
<li>
Single-threaded clients that do not need to use their main thread for notification</li>
</ul>
<p>
To use the separate thread approach, call <b>MAPIInitialize</b> on every thread, setting the MAPI_MULTITHREAD_NOTIFICATIONS flag. Calls made from 16-bit clients operate as if the MAPI_MULTITHREAD_NOTIFICATIONS flag is not set.</p>
<p>
<b>Note</b>  Only a client's first call to <b>MAPIInitialize</b> causes a hidden window to be created to support notifications. Subsequent calls only cause a reference count to be incremented.</p>
<p>&nbsp;</p></body>
</HTML>
