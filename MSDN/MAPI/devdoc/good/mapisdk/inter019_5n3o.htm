<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>IMAPIFormMgr::IsInConflict</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h2><a name="_mapi1book_imapiformmgr_isinconflict"></a>IMAPIFormMgr::IsInConflict</h2>
<p>
The <b>IMAPIFormMgr::IsInConflict</b> method determines whether a form can handle its own message conflicts. A message is in conflict if it has been simultaneously edited by more than one user. This can happen to messages in public folders.</p>
<h4>Quick Info</h4>
<p>
See <a href="inter019_3ju6.htm"><b>IMAPIFormMgr : IUnknown</b></a>.</p>
<pre><code><b>HRESULT IsInConflict(
  ULONG</b><i> ulMessageFlags</i><b>,</b>  
<b>  ULONG</b><i> ulMessageStatus</i><b>,</b>   
<b>  LPCSTR</b><i> szMessageClass  </i>
<b>  LPMAPIFOLDER</b><i> pFolderFocus  </i>
<b>);</b>
 </code></pre>
<h4>Parameters</h4>
<dl>
<dt>
<i>ulMessageFlags</i></dt>
<dd>
[in] Pointer to a bitmask of flags — copied from the <a href="propa_95wz.htm">PR_MESSAGE_FLAGS</a> property of a message — that indicates the current state of the message.</dd>
<dt>
<i>ulMessageStatus</i></dt>
<dd>
[in] Bitmask of client- or provider-defined flags — copied from the <a href="propb_3c1f.htm">PR_MSG_STATUS</a> property of a message — that provides further information on the state of the message.</dd>
<dt>
<i>szMessageClass</i></dt>
<dd>
[in] String naming the message's message class.</dd>
<dt>
<i>pFolderFocus</i></dt>
<dd>
[in] Pointer to the folder that contains the message. The <i>pFolderFocus</i> parameter can be NULL if such a folder doesn't exist — for example, in a case where the message is embedded in another message.
</dd>
</dl>
<h4>Return Values</h4>
<dl>
<dt>
S_OK</dt>
<dd>
The form does not handle its own message conflicts.</dd>
<dt>
S_FALSE</dt>
<dd>
The form handles its own message conflicts, or the message for which information was passed is not in conflict.
</dd>
</dl>
<h4>Remarks</h4>
<p>
Form viewers call the <b>IMAPIFormMgr::IsInConflict</b> method to discover if a particular form does not handle its own message conflicts. <b>IsInConflict</b> checks the bitmasks in the <i>ulMessageFlags</i> and <i>ulMessageStatus</i> parameters for the presence of a conflict flag. If a conflict flag is set, <b>IsInConflict</b> resolves the message class passed in the <i>szMessageClass</i> parameter and returns S_OK if the form does not handle its own conflicts. <b>IsInConflict</b> returns S_FALSE if the form handles its own conflicts.</p>
<p>
A form that does not handle its own conflicts must be launched using the <a href="inter019_8ju5.htm"><b>IMAPIFormMgr::LoadForm</b></a> method and cannot reuse an existing form object. </p>
<h4>Notes to Callers</h4>
<p>
Client applications typically have to deal with conflicts when going from one message to the next or previous message in a folder. If a message is in conflict, but the form server for that message can handle conflicts, then the client application should execute its usual code for displaying the next or previous message. If the form server cannot handle conflicts, then the client application should proceed as if it was unaware of the message class of the next or previous message. </p>
<h4>See Also</h4>
<p>
<a href="inter015_9gc4.htm"><b>IMAPIFormAdviseSink::OnActivateNext</b></a>, <a href="propa_95wz.htm">PR_MESSAGE_FLAGS</a>, <a href="propb_3c1f.htm">PR_MSG_STATUS</a></p>
<p>&nbsp;</p></body>
</HTML>
