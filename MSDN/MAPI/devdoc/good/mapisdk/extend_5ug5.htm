<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Idle Engine</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_mapi1book_idle_engine"></a>Idle Engine</h1>
<p>
MAPI provides several functions that are collectively known as the idle engine. These functions allow clients, address book providers, and message store providers to perform various tasks during slow times in the session or in response to a slow time. For example, clients and service providers can defer slow operations or close files that have remained unused for a lengthy period. Transport providers typically do not use the idle engine because the <a href="inter042_250l.htm"><b>IXPLogon::Idle</b></a> method takes its place.</p>
<p>
To use the idle engine, clients and service providers create a callback function that contains the tasks that should occur when the MAPI subsystem is idle. When MAPI detects idle time, it invokes this callback function. The callback function follows the <a href="function_9eg5.htm"><b>FNIDLE</b></a> prototype, defined as follows:</p>
<pre><code>BOOL (STDAPICALLTYPE FNIDLE) (LPVOID lpvContext)
 </code></pre>
<p>
The functions that make up the idle engine are:</p>
<p class=indent1>
<a href="function_6g2t.htm"><b>ChangeIdleRoutine</b></a></p>
<p class=indent1>
<a href="function_18th.htm"><b>DeregisterIdleRoutine</b></a></p>
<p class=indent1>
<a href="function_4twl.htm"><b>EnableIdleRoutine</b></a></p>
<p class=indent1>
<a href="function_8f6t.htm"><b>FtgRegisterIdleRoutine</b></a></p>
<p class=indent1>
<a href="function_2ijp.htm"><b>MAPIDeInitIdle</b></a></p>
<p class=indent1>
<a href="function_546d.htm"><b>MAPIInitIdle</b></a></p>
<p>
To register a callback function, clients and service providers call the <a href="function_8f6t.htm"><b>FtgRegisterIdleRoutine</b></a> function. The input parameters include an optional priority, a block of memory that is passed to your callback function as input, an amount of time to be used in any way appropriate, and a set of option flags. </p>
<p>
Clients and service providers can specify a priority in the <i>priIdle</i> parameter that controls how the idle function runs or specify zero if priority is not an issue. Because negative numbers represent higher priorities than positive numbers or zero, compression and search operations should be assigned negative numbers. Tasks that occur once should be assigned positive numbers.</p>
<p>
To deregister an active callback function, clients and service providers call the <a href="function_18th.htm"><b>DeregisterIdleRoutine</b></a> function. Because <b>DeregisterIdleRoutine</b> operates asynchronously, it is possible for the callback function to be invoked at any time during the deregister call and possibly even after <b>DeregisterIdleRoutine</b> has returned. </p>
<p>
To modify some or all of the characteristics of a callback function, clients and service providers call the <a href="function_6g2t.htm"><b>ChangeIdleRoutine</b></a> function. <b>ChangeIdleRoutine</b> makes changes according to how the flags parameter <i>ircIdle</i> is set; <b>ChangeIdleRoutine</b> can change the function itself, its priority, time setting, and input parameter. </p>
<p>
MAPI defines idle the same as the operating system, when the operating system has a definition. On Win16, MAPI installs a journalling hook that updates a variable with the time of the last user action. Idle time calculations are based on this variable. On Win32, MAPI creates a thread with idle-class priority to schedule idle tasks. This thread keeps track of the time and posts a message to the thread that is to execute the idle task when the time for its execution arrives. Win32 schedules threads, not processes. If tasks that have a priority higher than the idle priority are occurring on the workstation, the idle task should not get scheduled for execution until the tasks have completed. </p>
<p>
All idle tasks run on the thread that called <b>MAPIInitIdle</b>. MAPI has a separate thread for scheduling, but when an idle task becomes eligible, it posts a message back over to the initialization thread and the idle task is executed there. The implications for different types of clients are as follows.</p>
<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=31%>Threading model</th>
<th align=left width=69%>Implication</th>
</tr>
<tr valign=top>
<td width=31%>Single-threaded</td>
<td width=69%>No problem. Idle functions execute on your client's main thread and are serialized through the message loop.</td>
</tr>
<tr valign=top>
<td width=31%>Free-threaded</td>
<td width=69%>Idle functions must be thread-safe, but your client already has the necessary infrastructure. Your client might not need the MAPI idle engine at all. </td>
</tr>
<tr valign=top>
<td width=31%>Apartment-threaded</td>
<td width=69%>Idle function has to execute on the same thread that registered it if it wants to use MAPI, OLE, or any other COM interfaces. The most straightforward way is to register an idle function with MAPI that posts a message to the right thread and dispatch the "real" idle function directly from that thread's message loop. </td>
</tr>
</table><br>
<p>
</p>
<p>&nbsp;</p></body>
</HTML>
