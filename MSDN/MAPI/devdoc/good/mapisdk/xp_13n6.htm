<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Interacting with the MAPI Spooler</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h2><a name="_mapi1book_interacting_with_the_mapi_spooler"></a>Interacting with the MAPI Spooler</h2>
<p>
The methods in the <a href="inter042_2u9a.htm"><b>IXPLogon</b></a> interface are used by the MAPI spooler when calling the transport provider. It should be possible for most types of transport providers to implement most of these methods so that they return quickly. This is desirable because if a method takes a long time to return then it should be broken up with calls back to the MAPI spooler to release the CPU for other tasks. This is critical in nonpreemptive multitasking environments like 16-bit Windows. Transport providers for 16-bit Windows platforms should take particular care to break up any operation that takes more than 0.2 seconds. This is also necessary in 32-bit Windows to provide time to handle system-wide messages such as shutdown notifications or plug-and-play device notifications.</p>
<p>
The MAPI spooler does its work and makes its calls to transport providers when foreground applications are idle. After possibly displaying dialog boxes when the transport provider is first logged on (governed by flags passed from MAPI to the transport provider), transport providers operate in the background unless called by the client to flush send and receive queues. When flushing queues is the only time that a transport provider need not release the CPU, and then only if the user is informed that a potentially long action is in progress. The MAPI spooler typically requests that a transport provider flush its queues in response to a user action, so the transport provider typically does not need to do anything to ensure that the user is informed.</p>
<p>
A transport provider can independently decide to flush a queue and use the STATUS_INBOUND_FLUSH and STATUS_OUTBOUND_FLUSH bits in the <a href="propb_2zj9.htm">PR_STATUS_CODE</a> property of its status row to inform the MAPI spooler that it wants an inordinate amount of attention so that it can get the job done. The status row is updated using the <a href="inter025_0oxj.htm"><b>IMAPISupport::ModifyStatusRow</b></a> method. In this case the transport provider should probably display a progress indicator or other interface to inform the user that a long action is occuring.</p>
<p>
Since network activity often takes more than 0.2 seconds, transport providers should, whenever possible, use asynchronous network requests. This enables them to initiate a request, release the CPU by calling back to the MAPI spooler, and when the MAPI spooler again gives them control, to check to see if their network request has completed. If it has not yet completed, they again release the CPU by calling back to the MAPI spooler with the <a href="inter025_3pt0.htm"><b>IMAPISupport::SpoolerYield</b></a><b> </b>method.</p>
<p>
During message processing, between <a href="inter042_18v9.htm"><b>IXPLogon::SubmitMessage</b></a> and <a href="inter042_576t.htm"><b>IXPLogon::EndMessage</b></a> and during <a href="inter042_1a1x.htm"><b>IXPLogon::StartMessage</b></a> the transport provider typically makes many calls on objects exposed to it by the MAPI spooler. As part of its handling of these objects, the MAPI spooler helps the transport provider behave appropriately as a background process by yielding on its own when appropriate. A transport provider requiring time-critical processing can declare a critical section to the MAPI spooler using the <a href="inter025_5b7d.htm"><b>IMAPISupport::SpoolerNotify</b></a> support object method. In this case, the CPU is released only on explicit <b>SpoolerYield</b> calls by the transport provider until the transport provider ends critical section processing with another call to <b>SpoolerNotify</b>. Note that this is not the same as a Win32 critical section. This should only be done when the transport provider needs real-time control of external resources such as reading incoming data from a FAX line. Since this raises the priority of the MAPI spooler process and can cause the workstation to be unresponsive for the duration of the operation, it is a good idea to notify the user that a potentially long action is underway and provide a progress indicator if possible.</p>
<p>&nbsp;</p></body>
</HTML>
