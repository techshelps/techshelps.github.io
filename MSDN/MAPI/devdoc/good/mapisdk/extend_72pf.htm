<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Validating Parameters to Interface Methods</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h2><a name="_mapi1book_validating_parameters_to_interface_methods"></a>Validating Parameters to Interface Methods</h2>
<p>
Interface method implementers can perform two types of validation: 
<ul>
<li>
Debug validation whereby the implementer displays the values of the input parameters and provides verbose information should there be errors, optionally calling a macro provided by MAPI.</li>
<li>
Full validation whereby the implementer calls a macro provided by MAPI to check that all necessary parameters are present and set to valid values.</li>
</ul>
<p>
The type of validation performed depends on the caller. When the caller is MAPI or a service provider, debug validation is adequate because MAPI and service providers are expected to pass parameters correctly. When the caller is a client, however, full validation is recommended. Service providers cannot and should not count on clients to always pass appropriate parameters.</p>
<p>
MAPI performs debug validation in those interface implementations that are called internally or by service providers and full validation in the implementations that are called by clients. All functions and the utility interfaces, <b>ITableData</b> and <b>IPropData</b>, perform debug validation.</p>
<p>
For every interface method, there are three macros that clients and service providers can call in their implementations. Clients and providers can use one macro for debug validation and the other two for full validation. One of the macros for full validation is called for methods that return HRESULT values and the other is called for methods that return unsigned long values. </p>
<p>
These macros conform to a three part naming convention with each part separated by an underscore. The prefix identifies the macro being called, as described in the following table.</p>
<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=41%>Macro name prefix</th>
<th align=left width=59%>Description</th>
</tr>
<tr valign=top>
<td width=41%><b>Validate</b></td>
<td width=59%>Identifies a macro to be used for fully validating methods that return HRESULT values.</td>
</tr>
<tr valign=top>
<td width=41%><b>UlValidate</b></td>
<td width=59%>Identifies a macro to be used for fully validating methods that return unsigned long values.</td>
</tr>
<tr valign=top>
<td width=41%><b>CheckParameters</b></td>
<td width=59%>Identifies a macro to be used for performing debug validation.</td>
</tr>
</table><br>
<p>
The other two parts identify the interface and method being validated. For example, to fully validate <b>IMAPIProp::GetProps</b>, a method that returns an HRESULT value, service providers call <b>Validate_IMAPIProp_GetProps</b>. To perform debug validation for this method, service providers call <b>CheckParameters_IMAPIProp_GetProps</b>.</p>
<p>
The parameters to these macros vary slightly depending on whether the call is being made in C or C++. As with calls made to interface methods, the first parameter in C must be a pointer to the object implementing the method. In C++, the <i>this</i> pointer should be the first parameter. The rest of the parameters are the same in either language; they are the same parameters that are passed to the method being validated. Therefore, the number and type of parameters passed to a validation macro varies depending on the method being validated. All parameters passed to the method must be passed to a validation macro. </p>
<p>
The three types of validation macros are platform independent; they are guaranteed to work on both RISC and Intel platforms. Their predecessors, the <a href="function_8u0j.htm"><b>ValidateParameters</b></a>, <a href="function_6t4j.htm"><b>UlValidateParameters</b></a>, and <a href="function_83ub.htm"><b>CheckParameters</b></a> functions, perform the same functionality as the macros. However, these functions are available only for Intel platforms. Clients and service providers operating on RISC platforms must use the validation macros.</p>
<p>
The <b>ValidateParameters</b> and <b>UlValidateParameters</b> macros and functions:
<ul>
<li>
Examine the validity of read and write pointers.</li>
<li>
Examine the validity of structures.</li>
<li>
Examine the validity of reserved flags.</li>
<li>
Examine the incoming size of parameters if there is a size limit.</li>
</ul>
<p>
The <b>CheckParameters</b> macro and function are intended to be used by service providers in method implementations that are called by MAPI. They do not perform any real checking of parameters; they supply assert statements. Because the parameters passed by MAPI should be assumed to be correct, service providers do not need to perform full validation in these methods. </p>
<p>
The following code samples illustrate how to call the <b>ValidateParameters</b> macro in C and C++. The method being validated is <b>IMAPITable::QueryRows</b>, a method implemented by service providers that returns an HRESULT value and requires three parameters: the number of rows that are requested, a bitmask of flags, and the address of a pointer to an <b>SRowSet</b> structure.</p>
<p>
For C, the validation occurs as follows:</p>
<pre><code>STDMETHODIMP Table_QueryRows(LPTABLE lpTable, LONG lcRows, 
                             ULONG ulFlags, LPSRowSet FAR * lplprows)
{
    Validate_IMAPITable_QueryRows(lpTable, lcRows, ulFlags, lplprows);
 
    // rest of method implementation
}
 </code></pre>
<p>
For C++, this example would be written as follows:</p>
<pre><code>STDMETHODIMP CTable::QueryRows(LONG lcRows, ULONG ulFlags,
                               LPSRowSet FAR * lplprows)
{
    Validate_IMAPITable_QueryRows(this, lcRows, ulFlags, lplprows);
 
    // rest of method implementation
}
 </code></pre>
<p>&nbsp;</p></body>
</HTML>
