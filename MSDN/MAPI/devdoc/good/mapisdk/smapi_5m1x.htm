<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Controlled Sending of a Message: Simple MAPI Sample</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h2><a name="_mapi1book_controlled_sending_of_a_message_simple_mapi_sample"></a>Controlled Sending of a Message: Simple MAPI Sample</h2>
<p>
This example shows how you can take more control over a message you send by specifying more of the contents of the message, validating addresses before sending, and by denying a sending interface to the user. Again, the client starts by defining its variables.</p>
<pre><code>// Example 2:
// Send a mail message containing a spreadsheet and a short note
// to Sally Jones and copy the Marketing group. Don't prompt the user.

ULONG err;
MapiRecipDesc recips[2],     // this message needs two recipients.
             *tempRecip[2];  // for use by MAPIResolveName

// create the same file attachment as in the previous example.
MapiFileDesc attachment = {0,         // ulReserved, must be 0
                           0,         // no flags; this is a data file
                           (ULONG)-1, // position not specified
                           "c:\\tmp\\tmp.wk3",  // pathname
                           "budget17.wk3",      // original filename
                           NULL};               // MapiFileTagExt unused
 </code></pre>
<p>
The client then uses the <a href="smapiref_1qqt.htm"><b>MAPIResolveName</b></a> function to generate <a href="smapiref_13tr.htm"><b>MapiRecipDesc</b></a> structures for the recipients of the message. It can create them directly, as in the previous example, but then no error checking is possible. Since this client is creating and sending the message without any interaction from the user, it is important to make sure the addresses are valid before sending the message.</p>
<pre><code>// get Sally Jones as the MAPI_TO recipient:
err = MAPIResolveName(0L,            // implicit session
                      0L,            // no UI handle
                      "Sally Jones", // friendly name
                      0L,            // no flags, no UI allowed
                      0L,            // reserved; must be 0
                      &amp;tempRecip[0]);// where to put the result
if(err == SUCCESS_SUCCESS)
    { // memberwise copy the appropriate fields in the returned
      // recipient descriptor.
        recips[0].ulReserved   = tempRecip[0]-&gt;ulReserved;
        recips[0].ulRecipClass = MAPI_TO;
        recips[0].lpszName     = tempRecip[0]-&gt;lpszName;
        recips[0].lpszAddress  = tempRecip[0]-&gt;lpszAddress;
        recips[0].ulEIDSize    = tempRecip[0]-&gt;ulEIDSize;
        recips[0].lpEntryID    = tempRecip[0]-&gt;lpEntryID;
    }
else
    printf("Error: Sally Jones didn't resolve to a single address\r\n");

// get the Marketing alias as the MAPI_CC recipient:
err = MAPIResolveName(0L,            // implicit session
                      0L,            // no UI handle
                      "Marketing",   // friendly name
                      0L,            // no flags, no UI allowed
                      0L,            // reserved; must be 0
                      &amp;tempRecip[1]);// where to put the result
if(err == SUCCESS_SUCCESS)
    { // memberwise copy the appropriate fields in the returned
      // recipient descriptor.
        recips[1].ulReserved   = tempRecip[1]-&gt;ulReserved;
        recips[1].ulRecipClass = MAPI_CC;
        recips[1].lpszName     = tempRecip[1]-&gt;lpszName;
        recips[1].lpszAddress  = tempRecip[1]-&gt;lpszAddress;
        recips[1].ulEIDSize    = tempRecip[1]-&gt;ulEIDSize;
        recips[1].lpEntryID    = tempRecip[1]-&gt;lpEntryID;
    }
else
    printf("Error: Marketing didn't resolve to a single address\r\n");
 </code></pre>
<p>
Now, the client creates the message. Again, you should not hard-code the actual values of the <a href="smapiref_6n1b.htm"><b>MapiMessage</b></a> structure's members.</p>
<pre><code>MapiMessage note = {0, "Budget Proposal",
                   "Here is my budget proposal.\r\n",
                   NULL, NULL, NULL, 0, NULL,
                   2, recips, 1, &amp;attachment};
 </code></pre>
<p>
Again, the client sends the message and records the return value. This time no user interface is displayed. After the <a href="smapiref_8be4.htm"><b>MAPISendMail</b></a> call, the <a href="smapiref_13tr.htm"><b>MapiRecipDesc</b></a> structures allocated by <a href="smapiref_1qqt.htm"><b>MAPIResolveName</b></a> must be released.</p>
<pre><code>err = MAPISendMail (0L,    // use implicit session.
                    0L,    // ulUIParam; 0 is always valid
                    &amp;note, // the message being sent
                    0L,    // do not allow the user to edit the message
                    0L);   // reserved; must be 0
if (err != SUCCESS_SUCCESS )
    printf("Unable to send the message\n");
MAPIFreeBuffer(tempRecips[0]);  // release the recipient descriptors
MAPIFreeBuffer(tempRecips[1]);
 </code></pre>
<p>&nbsp;</p></body>
</HTML>
