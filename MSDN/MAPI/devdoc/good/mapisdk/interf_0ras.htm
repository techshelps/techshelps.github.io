<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Implementing a Sample Object</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h2><a name="_mapi1book_implementing_a_sample_object"></a>Implementing a Sample Object</h2>
<p>
Advise sink objects — objects that support the <a href="inter010_0fn2.htm"><b>IMAPIAdviseSink : IUnknown</b></a> interface — are an example of simple MAPI objects that are implemented by client applications for processing notifications. <b>IMAPIAdviseSink</b> inherits directly from <b>IUnknown</b> and contains only one method, <b>OnNotify</b>. Therefore, to implement an advise sink object, a client creates code for the three methods in <b>IUnknown</b> and for <b>OnNotify</b>. </p>
<p>
The MAPIDEFS.H file defines an <b>IMAPIAdviseSink</b> interface implementation using DECLARE_MAPI_INTERFACE as follows:</p>
<pre><code>#define      INTERFACE  IMAPIAdviseSink

DECLARE_MAPI_INTERFACE_(IMAPIAdviseSink, IUnknown)
{
    BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IMAPIADVISESINK_METHODS(PURE)
};
 </code></pre>
<p>
Clients implementing advise sink objects can define their interfaces in their objects manually or with the MAPI_IUNKNOWN_METHODS and MAPI_IMAPIADVISESINK_METHODS macros. Object implementers should use the interface macros whenever possible to ensure consistency across objects and to save time and effort.</p>
<p>
Implementing the <b>IUnknown::AddRef</b> and <b>IUnknown::Release</b> methods is relatively simple because typically only a few lines of code are needed. Therefore, clients and service providers implementing objects can make their <b>AddRef</b> and <b>Release</b> implementations inline. The following code shows how to define a C++ advise sink object with inline implementations of <b>AddRef</b> and <b>Release</b>.</p>
<pre><code>class  CMAPIAdviseSink : public IMAPIAdviseSink
{
public:
    STDMETHODIMP QueryInterface
                    (REFIID                     riid,
                     LPVOID *                   ppvObj);
    inline STDMETHODIMP_(ULONG) AddRef
                    () { InterlockedIncrement(m_cRef);
                         ++m_cRef; 
                         InterlockedDecrement(m_cRef);
                         return m_cRef; };
    inline STDMETHODIMP_(ULONG) Release
                    () { InterlockedIncrement(m_cRef);
                         ULONG ulCount = --m_cRef;
                         InterlockedDecrement(m_cRef);
                         if (!ulCount)  delete this; 
                         return ulCount;};
    MAPI_IMAPIADVISESINK_METHODS(IMPL);

    BOOL WINAPI AddConnection (LPMDB pMDBObj, ULONG ulConnection);
    void WINAPI RemoveAllLinks (LPMDB pMDBObj);
    
// Constructors and destructors
public :
    inline CMAPIAdviseSink  (CStoreClient * pStore)
                            { m_cRef = 1;
                              m_ulConnection = 0;
                              m_pStore = pStore; 
                              AddRef;};
    ~CMAPIAdviseSink () {Release};

private :
    ULONG               m_cRef; 
    CStoreClient *      m_pStore;
    ULONG               m_ulConnection;
};
 </code></pre>
<p>
In C, the advise sink object is made up of:
<ul>
<li>
A pointer to a vtable that contains pointers to implementations of each of the methods in <b>IUnknown</b> and <b>IMAPIAdviseSink</b>.</li>
<li>
Data members.</li>
</ul>
<p>
The following code sample shows how to define an advise sink object in C and construct its vtable. </p>
<pre><code>// Object definition
typedef struct _ADVISESINK
{
    const ADVISE_Vtbl FAR *    lpVtbl;

    ULONG             cRef;
    STORECLIENT      *pStore;
    ULONG             ulConnection;
    
} ADVISESINK, *LPADVISESINK;

// vtable definition
static const ADVISE_Vtbl vtblADVISE =
{
    ADVISE_QueryInterface,
    ADVISE_AddRef,
    ADVISE_Release,
    ADVISE_OnNotify
};
 </code></pre>
<p>
After an object is declared in C, it must be initialized by setting the vtable pointer to the address of the constructed vtable as is shown following:</p>
<pre><code>LPADVISESINK lpMyObj = NULL;

HRESULT hr = (*lpAllocateBuffer) (sizeof(ADVISESINK), 
                 (LPVOID *)&amp;lpMyObj);
lpMyObj-&gt;lpVtbl = &amp;vtblADVISE;
 </code></pre>
<p>
</p>
<p>&nbsp;</p></body>
</HTML>
