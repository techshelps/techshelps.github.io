<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Implementing Thread-Safe Objects</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h2><a name="_mapi1book_implementing_thread_safe_objects"></a>Implementing Thread-Safe Objects</h2>
<p>
With objects that are returned from interface method calls directly, it is the provider's responsibility to ensure thread-safety. With callback objects, it is the client's responsibility. A service provider implements a thread-safe object by serializing access to shared data within the object, insuring that one thread does not inadvertently replace the work of another thread. A service provider can implement serialized access to data in three ways:
<ul>
<li>
Provide every object with its own critical section, calling the Win32 API function <b>EnterCriticalSection</b> at the beginning of every method and <b>LeaveCriticalSection</b> at the end. Most of the samples in the MAPI SDK use this method. This option has two drawbacks: a high overhead and the possibility of deadlock. Deadlock can occur if, for example, the thread-safe object calls the MAPI support object or an object returned indirectly through one of the copy methods. </li>
<li>
Use a single critical section for all objects, calling <b>EnterCriticalSection</b> when the provider is loaded and <b>LeaveCriticalSection</b> when the provider is unloaded. This option provides the most simplicity, but suffers in performance when used with multithreaded clients. </li>
<li>
Create a small number of critical sections to be associated with crucial shared data structures. The data is isolated from the object, placed, for example, in memory or in a parent object. Access to the data is handled through an internal interface. This option offers the best balance between performance and simplicity. </li>
</ul>
<p>
A client can implement a thread-safe notification callback by calling the MAPI utility <a href="function_1fxn.htm"><b>HrThisThreadAdviseSink</b></a>. <b>HrThisThreadAdviseSink </b>transforms a non-thread-safe advise sink into a thread-safe one. For progress callbacks, there is no such utility at this time. A client can choose to use the MAPI thread-safe progress object or create one manually.</p>
<p>
A thread-safe object might or might not also be thread-aware. A thread-aware object maintains a separate context for every thread that is using it. Service providers are not required to support thread-awareness in their thread-safe objects, although supporting thread-awareness can be useful in some situations. Two MAPI tables always provide their own context by definition. One table used on different threads does not and should not provide unique context.</p>
<p>
A client can choose between receiving notifications on the same thread that was used for the <b>MAPIInitialize</b> call, on the same thread that was used for the <b>Advise</b> call, or on a separate thread owned by MAPI. To ensure that notifications arrive on the same thread that was used to call <b>MAPIInitialize</b>, a client calls <a href="function_6ycl.htm"><b>MAPIInitialize</b></a> and passes zero in the <b>ulFlags</b> member of the <a href="structyp_501c.htm"><b>MAPIINIT_0</b></a> structure. Notifications are then delivered during the main message loop. </p>
<p>
To receive notifications on the MAPI-owned thread, a client calls <b>MAPIInitialize</b> with the <b>ulFlags</b> member of the <b>MAPIINIT_0</b> structure set to MAPI_MULTITHREAD_NOTIFICATIONS. The <b>Advise</b> call is made with the client's advise sink object rather than a wrapped version.</p>
<p>
To ensure that notifications arrive on the same thread that was used to call <b>Advise</b>, a client calls <a href="function_1fxn.htm"><b>HrThisThreadAdviseSink</b></a> and passes the newly created wrapped advise sink to <b>Advise</b> rather than the original advise sink. <b>MAPIInitialize</b> can be called with either flag value. </p>
<p>&nbsp;</p></body>
</HTML>
