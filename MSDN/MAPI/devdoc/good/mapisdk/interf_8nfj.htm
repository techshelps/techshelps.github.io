<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Implementing IUnknown in C++</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h3><a name="_mapi1book_implementing_iunknown_in_c_"></a>Implementing IUnknown in C++</h3>
<p>
Implementing <b>QueryInterface</b>, <b>AddRef</b>, and <b>Release</b> in C++ is fairly simple. After some standard validation of the parameters passed in, an implementation of <b>QueryInterface</b> checks the identifier of the requested interface against the list of supported interfaces. If the requested identifier is among those supported, <b>AddRef</b> is called and the <i>this</i> pointer returned. If the requested identifier is not on the supported list, the output pointer is set to NULL and the MAPI_E_INTERFACE_NOT_SUPPORTED value is returned. </p>
<p>
The following example shows how <b>QueryInterface</b> can be implemented in C++ for a status object, an object that is a subclass of the <a href="inter024_22i8.htm"><b>IMAPIStatus : IMAPIProp</b></a> interface. <b>IMAPIStatus</b> inherits from <b>IUnknown</b> through <b>IMAPIProp</b>. Therefore, because these interfaces are related through inheritance, if a caller asks for any of them, the <i>this</i> pointer can be returned. </p>
<pre><code>HRESULT CMyMAPIObject::QueryInterface (REFIID   riid,  
                                       LPVOID * ppvObj) 
{ 
    // Always set out parameter to NULL, validating it first 
    if (IsBadWritePtr(ppvObj, sizeof(LPVOID))) 
        return E_INVALIDARG;  
 
    *ppvObj = NULL; 
 
    if (riid == IID_IUnknown || riid == IID_IMAPIProp || 
        riid == IID_IMAPIStatus) 
    { 
        // Increment reference count and return pointer
        *ppvObj = (LPVOID)this; 
        AddRef(); 
        return NOERROR; 
    } 
 
    return E_NOINTERFACE; 
} 
 </code></pre>
<p>
Note that this example is a 32-bit implementation; 16-bit implementations must include a call to <b>ResultFromScode</b> on their return statements to translate the 16-bit status code values to HRESULT values. For example, the final return statement would be recoded for 16-bit platforms as:</p>
<pre><code>return ResultFromScode(E_NOINTERFACE);
 </code></pre>
<p>
The following code samples show how to implement the <b>AddRef</b> and <b>Release</b> methods for the CMyMAPIObject object. Because implementing <b>AddRef</b> and <b>Release</b> is so simple, many service providers choose to implement them inline. The calls to the Win32 functions <b>InterlockedIncrement</b> and <b>InterlockedDecrement</b> are to ensure thread safety. The memory for the object is freed by the destructor which is called when the <b>Release</b> method deletes the object. </p>
<pre><code>ULONG CMyMAPIObject::AddRef() 
{    
    InterlockedIncrement(m_cRef); 
    return m_cRef; 
} 
 
ULONG CMyMAPIObject::Release() 
{ 
    // Decrement the object's internal counter 
    ULONG ulRefCount = InterlockedDecrement(m_cRef); 
 
    if (0 == m_cRef) 
    {
        delete this; 
    }
 
    return ulRefCount; 
} 
 </code></pre>
<p>&nbsp;</p></body>
</HTML>
