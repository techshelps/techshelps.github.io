<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Implementing Objects in C</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h2><a name="_mapi1book_implementing_objects_in_c"></a>Implementing Objects in C</h2>
<p>
Client applications and service providers written in C define MAPI objects by creating a data structure and an array of ordered function pointers known as a virtual function table, or vtable. A pointer to the vtable must be the first member of the data structure. In the vtable itself there is one pointer for every method in each interface supported by the object. The order of the pointers must follow the order of the methods in the interface specification published in the MAPIDEFS.H header file. Each function pointer in the vtable is set to the address of the actual implementation of the method. In C++, the vtable is set up automatically by the compiler. In C, it is not. </p>
<p>
The following illustration shows how this works. The box on the far left represents a client that needs to use a service provider object. Through the session, the client obtains a pointer to the object, <i>lpObject</i>. The vtable appears first in the object followed by private data and methods. The vtable pointer points to the actual vtable containing pointers to each of the implementations of the methods in the interface. </p>
<p>
<img src="images/amapi_42.gif" border=0></p>
<p>
The following sample code shows how a C service provider can define a simple status object. The first member is the vtable pointer; the rest of the object is made up of data members. </p>
<pre><code>typedef struct _MYSTATUSOBJECT
{
    const STATUS_Vtbl FAR *lpVtbl;

    ULONG              cRef;
    ANOTHEROBJ        *pObj;
    LPMAPIPROP         lpProp;
    LPFREEBUFFER       lpFreeBuf;

} MYSTATUSOBJECT, *LPMYSTATUSOBJ;
 </code></pre>
<p>
Because this object is a status object, the vtable includes pointers to implementations of each of the methods in the <a href="inter024_22i8.htm"><b>IMAPIStatus : IMAPIProp</b></a> interface as well as pointers to implementations of each of the methods in the base interfaces: <b>IUnknown</b> and <b>IMAPIProp</b>. The order of methods in the vtable match the specified order as defined in MAPIDEFS.H.</p>
<pre><code>static const MYOBJECT_Vtbl vtblSTATUS =
{
    STATUS_QueryInterface,
    STATUS_AddRef,
    STATUS_Release,
    STATUS_GetLastError,
    STATUS_SaveChanges,
    STATUS_GetProps,
    STATUS_GetPropList,
    STATUS_OpenProperty,
    STATUS_SetProps,
    STATUS_DeleteProps,
    STATUS_CopyTo,
    STATUS_CopyProps,
    STATUS_GetNamesFromIDs,
    STATUS_GetIDsFromNames,
    STATUS_ValidateState,
    STATUS_SettingsDialog,
    STATUS_ChangePassword, 
    STATUS_FlushQueues
};
 </code></pre>
<p>
Clients and service providers written in C use objects indirectly through the vtable and add an object pointer as the first parameter in every call. Every call to a MAPI interface method requires a pointer to the object being called as its first parameter. C++ defines a special pointer known as the <i>this</i> pointer for this purpose. The C++ compiler implicitly adds the <i>this</i> pointer as the first parameter to every method call. Since in C there is no such pointer; it must be explicitly added.</p>
<p>
The following code fragment demonstrates how a client can make a call to an instance of MYSTATUSOBJECT:</p>
<pre><code>lpMyObj-&gt;lpVtbl-&gt;ValidateState(lpMyObj, ulUIParam, ulFlags);
 </code></pre>
<p>&nbsp;</p></body>
</HTML>
