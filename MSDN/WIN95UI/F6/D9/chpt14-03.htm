<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">
<meta name="GENERATOR" content="Microsoft FrontPage 2.0">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Enumerating Items in the Shell</title>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>

<BODY bgcolor="#FFFFFF">


<h1><font size="5">Enumerating Items in the Shell</font></h1>

<p>When an application has the IShellFolder interface for a
folder, it can determine the folder's contents by using the
EnumObjects member function. EnumObjects creates an <i>item
enumeration object,</i> which is a set of item identifiers that
can be retrieved by using the IEnumIDList interface. </p>

<p>After you get an item enumeration object, your application can
retrieve all the item IDs one or more at a time from the
enumeration object by repeatedly calling the IEnumIDList::Next
member function. Using other member functions, you can skip items
in the sequence, return to the beginning of the sequence, or
&#147;clone&#148; the enumeration object to save its state. When
your application has finished using the enumeration object, you
must free the object by calling its Release member function. </p>

<p>The MFCENUM and ENUMDESK samples use a tree view control and a
list view control to display items in the shell name space. These
two controls are created when the application starts. The desktop
folder is retrieved, and the tree view control is filled with the
contents of the desktop. </p>

<p><tt>void CMfcenumView::OnFill ()<br>
{<br>
LPSHELLFOLDER lpsf = NULL;<br>
LPITEMIDLIST lpi = NULL;<br>
HRESULT hr;<br>
TV_SORTCB tvscb;<br>
<br>
// Get a pointer to the desktop folder.<br>
hr = SHGetDesktopFolder (&amp;lpsf);<br>
<br>
if (SUCCEEDED (hr))<br>
{<br>
// Initialize the tree view control to be empty.<br>
m_TreeCtl.DeleteAllItems ();<br>
<br>
// Fill in the tree view control from the root.<br>
FillTreeView (lpsf, NULL, TVI_ROOT);<br>
<br>
// Release the folder pointer.<br>
lpsf-&gt;Release ();<br>
}<br>
<br>
tvscb.hParent = TVI_ROOT;<br>
tvscb.lParam = 0;<br>
tvscb.lpfnCompare = TreeViewCompareProc;<br>
<br>
// Sort the items in the tree view control.<br>
m_TreeCtl.SortChildrenCB (&amp;tvscb, FALSE);<br>
}</tt> </p>

<p>The application-defined FillTreeView function enumerates the
items in the folder identified by the first parameter (a pointer
to a shell folder). The second parameter is the fully qualified
item ID list to the item (the PIDL of the item identified by the
first parameter). The third parameter is the tree view parent
item. This function will add only items that are folders or that
have subfolders. </p>

<p>The FillTreeView function first calls SHGetMalloc. All user
interface extensions must use the task allocator to allocate or
free memory objects (such as item ID lists) returned across shell
interfaces. SHGetMalloc does this. </p>

<p><tt>void CMfcenumView::FillTreeView (<br>
LPSHELLFOLDER lpsf, LPITEMIDLIST lpifq, HTREEITEM hParent)<br>
{<br>
TV_ITEM tvi; // tree view item<br>
TV_INSERTSTRUCT tvins; // tree view insert structure<br>
HTREEITEM hPrev = NULL; // previous item added<br>
LPSHELLFOLDER lpsf2 = NULL;<br>
LPENUMIDLIST lpe = NULL;<br>
LPITEMIDLIST lpi = NULL, lpiTemp = NULL, lpifqThisItem;<br>
LPTVITEMDATA lptvid = NULL;<br>
LPMALLOC lpMalloc = NULL;<br>
ULONG ulFetched;<br>
UINT uCount = 0;<br>
HRESULT hr;<br>
char szBuff [256];<br>
HWND hwnd = ::GetParent (m_TreeCtl.m_hWnd);<br>
<br>
// Allocate a shell memory object.<br>
hr = ::SHGetMalloc (&amp;lpMalloc);<br>
if (FAILED (hr))<br>
return;<br>
<br>
if (SUCCEEDED (hr))<br>
{<br>
// Get the IEnumIDList object for the given folder.<br>
hr = lpsf-&gt;EnumObjects (hwnd, SHCONTF_FOLDERS |
SHCONTF_NONFOLDERS,<br>
&amp;lpe);<br>
<br>
if (SUCCEEDED (hr))<br>
{<br>
// Enumerate through the list of folder and nonfolder objects.<br>
while (S_OK == lpe-&gt;Next (1, &amp;lpi, &amp;ulFetched))<br>
{<br>
// Create a fully qualified path to the current item.<br>
// The SH* functions take a fully qualified path PIDL,<br>
// while the interface member functions take a <br>
// relative path PIDL.<br>
ULONG ulAttrs = SFGAO_HASSUBFOLDER | SFGAO_FOLDER;<br>
<br>
// Determine what type of object you have.<br>
lpsf-&gt;GetAttributesOf (<br>
1, (const struct _ITEMIDLIST **)&amp;lpi, &amp;ulAttrs);<br>
<br>
if (ulAttrs &amp; (SFGAO_HASSUBFOLDER | SFGAO_FOLDER))<br>
{<br>
// You need this next if statement to <br>
// avoid adding objects that are not real <br>
// folders to the tree. Some objects can <br>
// have subfolders but aren't real folders.<br>
if (ulAttrs &amp; SFGAO_FOLDER)<br>
{<br>
tvi.mask = TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE | <br>
TVIF_PARAM;<br>
<br>
if (ulAttrs &amp; SFGAO_HASSUBFOLDER)<br>
{<br>
// This item has subfolders, so put a plus sign in the <br>
// tree view control. The first time the user clicks <br>
// the item, you should populate the subfolders.<br>
tvi.cChildren = 1;<br>
tvi.mask |= TVIF_CHILDREN;<br>
}<br>
<br>
// Get some memory for the ITEMDATA structure.<br>
lptvid = (LPTVITEMDATA) lpMalloc-&gt;Alloc (<br>
sizeof (TVITEMDATA));<br>
if (! lptvid)<br>
goto Done; // Error - could not allocate memory<br>
<br>
// Now get the friendly name to <br>
// put in the tree view control.<br>
if (! GetName (lpsf, lpi, SHGDN_NORMAL, szBuff))<br>
goto Done; // Error - could not get friendly name<br>
<br>
tvi.pszText = szBuff;<br>
tvi.cchTextMax = MAX_PATH;<br>
<br>
lpifqThisItem = ConcatPidls (lpifq, lpi);<br>
<br>
// Now make a copy of the ITEMIDLIST.<br>
lptvid-&gt;lpi = CopyITEMID (lpMalloc, lpi);<br>
<br>
GetNormalAndSelectedIcons (lpifqThisItem, &amp;tvi);<br>
<br>
lptvid-&gt;lpsfParent = lpsf; // pointer to parent folder<br>
lpsf-&gt;AddRef ();<br>
<br>
lptvid-&gt;lpifq = ConcatPidls (lpifq, lpi);<br>
tvi.lParam = (LPARAM)lptvid;<br>
<br>
// Populate the tree view insert structure.<br>
// The item is the one filled above.<br>
// Insert it after the last item inserted at this level,<br>
// and indicate that this is a root entry.<br>
tvins.item = tvi;<br>
tvins.hInsertAfter = hPrev;<br>
tvins.hParent = hParent;<br>
<br>
// Add the item to the tree.<br>
hPrev = m_TreeCtl.InsertItem (&amp;tvins);<br>
}<br>
<br>
// Free the task allocator for this item.<br>
lpMalloc-&gt;Free (lpifqThisItem);<br>
lpifqThisItem = 0;<br>
}<br>
<br>
lpMalloc-&gt;Free (lpi); // free the PIDL the shell gave you<br>
lpi = 0;<br>
}<br>
}<br>
}<br>
<br>
else<br>
return;<br>
<br>
Done:<br>
if (lpe)<br>
lpe-&gt;Release ();<br>
<br>
// The following two if statements will be TRUE only if you got
here <br>
// on an error condition from the goto statement. Otherwise, free
<br>
// this memory at the end of the while loop above.<br>
if (lpi &amp;&amp; lpMalloc)<br>
lpMalloc-&gt;Free (lpi);<br>
if (lpifqThisItem &amp;&amp; lpMalloc)<br>
lpMalloc-&gt;Free (lpifqThisItem);<br>
<br>
if (lpMalloc)<br>
lpMalloc-&gt;Release ();<br>
}</tt> </p>

<p>FillTreeView used the folder's IShellFolder interface to get
the folder's contents and then used the IShellFolder::EnumObjects
member function to create an item enumeration object. This
function then called the IEnumIDList::Next member function to
iterate through all the item IDs for all the folders in the name
space. </p>
</body>
</html>
