<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">
<meta name="GENERATOR" content="Microsoft FrontPage 2.0">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>User Interface Extensions and Windows NT</title>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>

<BODY bgcolor="#FFFFFF">


<h1><font size="5">User Interface Extensions and Windows NT</font></h1>

<p>You can use Windows 95 user interface extensions under
Microsoft Windows NT version 3.51 running with its new shell.
(The shell is still due to be released as of this writing.) You
will, however, need to place the extension DLL in
\WINDOWS\SYSTEM32 rather than in \WINDOWS\SYSTEM. You'll also
need to add one step in your application's setup process and
registration. </p>

<p>To have Windows NT recognize and run your user interface
extension, the handler's CLSID must be listed under a new
Registry key that contains a list of approved handlers. By
default, only a person with administrator privileges is allowed
to modify the list in this key. Here is the location where the
CLSID must be registered in Windows NT: </p>

<p><tt>HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\<br>
Shell Extensions\Approved</tt> </p>

<p>To register the extension, you must add a named value to the
Approved key. The name of the value must be the string form of
the CLSID, which you can obtain by using the StringFromCLSID
function. </p>

<p>If you haven't yet written applications for Windows NT, you
might find it odd that your setup application would be unable to
write to the Approved key. The ability to write to this key
depends on the access privileges of the person installing the
application. The setup application should attempt to open the
key, requesting the KEY_SET_VALUE permission. If it succeeds, you
can add the new CLSID to fully register the corresponding
extension. If the request fails, with a security violation, the
person installing the application does not have permission to
register new extensions. In this case, the setup application
might warn the user that some application features will not be
available unless an administrator turns them on (by installing
the application or by writing the Registry keys directly). Or, if
the extension is crucial to the application's functioning, the
setup application might cause the installation to fail
completely, notifying the user that an administrator must install
the program. </p>

<p>The following sample code demonstrates how an application can
register its user interface extension under Windows NT: </p>

<p><tt>// First, attempt to open <br>
// the Registry key where<br>
// approved extensions are listed.<br>
long err;<br>
HKEY hkApproved;<br>
<br>
err = RegOpenKeyEx (<br>
HKEY_LOCAL_MACHINE,<br>
&quot;Software\\Microsoft\\Windows\\CurrentVersion\\&#148;<br>
&#147;Shell Extensions\\Approved&quot;,<br>
0,<br>
KEY_SET_VALUE,<br>
&amp;hkApproved);<br>
<br>
if (err == ERROR_ACCESS_DENIED)<br>
{<br>
// The user does not have permission to add a new value<br>
// to this key. In this case, you might warn the user that some<br>
// application features will not be available unless an
administrator<br>
// installs the application. If the extension is central to the<br>
// application's functioning, tell the user that only an <br>
// administrator can perform the install, and stop the install.<br>
§<br>
}<br>
else if (err == ERROR_FILE_NOT_FOUND)<br>
{<br>
// The key does not exist. This happens only if setup is running<br>
// on Windows 95 instead of Windows NT or if you are installing
on an <br>
// older version of either operating system that lacks the Win95
UI.<br>
§<br>
}<br>
<br>
else if (err != ERROR_SUCCESS)<br>
{<br>
// Some other problem...<br>
}<br>
<br>
else<br>
{<br>
// Assume that lpstrProgID contains your ProgID string.<br>
LPSTR lpstrProgID = &quot;My Bogus Class&quot;;<br>
<br>
// Assume that clsidExtension contains the CLSID structure. <br>
// The following code creates a string from this CLSID. <br>
// If a string version of the CLSID is already handy,<br>
// skip this code.<br>
CLSID clsidExtension = {0x11111111, 0x1111, 0x1111,<br>
0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11};<br>
HRESULT hr;<br>
LPOLESTR lpolestrCLSID;<br>
char rgchCLSID [40];<br>
<br>
CoInitialize (NULL);<br>
<br>
hr = StringFromCLSID (clsidExtension, &amp;lpolestrCLSID);<br>
<br>
// StringFromCLSID returns a Unicode string, so convert to ANSI
for<br>
// calling the Registry. Note that on Windows NT you can call the
<br>
// Unicode version of the Registry API instead.<br>
WideCharToMultiByte (CP_ACP, 0, lpolestrCLSID, -1, rgchCLSID, 40,<br>
NULL, NULL);<br>
<br>
CoTaskMemFree (lpolestrCLSID);<br>
CoUninitialize ();<br>
<br>
// Now add the new value to the Registry.<br>
err = RegSetValueEx (<br>
hkApproved,<br>
rgchCLSID,<br>
0,<br>
REG_SZ,<br>
(const BYTE *)lpstrProgID,<br>
strlen (lpstrProgID));<br>
<br>
// Finally, close the key.<br>
err = RegCloseKey (hkApproved);<br>
}</tt> </p>

<p>If you are registering your extension for Windows NT version
3.51 (with the new shell) by using a REG file, add the following
line: </p>

<p><tt>[HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\<br>
Shell Extensions\Approved\{CLSID_VALUE}]<br>
@=&quot;My Shell Extension&quot;</tt> </p>

<p>For <i>CLSID_VALUE,</i> insert the actual CLSID for your
extension. For <i>My Shell Extension</i>, substitute the name of
the exported user interface extension. </p>
</body>
</html>
