<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">
<meta name="GENERATOR" content="Microsoft FrontPage 2.0">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Copy Hook Handlers</title>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>

<BODY bgcolor="#FFFFFF">


<h1><font size="5">Copy Hook Handlers</font></h1>

<p>Windows 95 calls a copy hook handler before a folder object is
moved, copied, deleted, or renamed. You can create a copy hook
handler to provide approval or disapproval of a given action. The
handler itself does not actually perform the task; the system
does that after it receives approval from the copy hook handler.
You cannot use a copy hook handler to monitor an action, such as
a copying operation, because the handler is not informed of the
success or failure of the action. </p>

<p>Like other user interface extensions, copy hook handlers are
registered in the Registry. A folder object can have multiple
copy hook handlers. A copy hook handler is registered under the
directory\shellex\CopyHookHandlers key. Here is a copy hook
handler registered in the SHELLEXT sample: </p>

<p><tt>[HKEY_CLASSES_ROOT\directory\shellex\CopyHookHandlers\GAKsCopyHook]<br>
@=&quot;{87b9bd00-c65c-11cd-a259-00dd010e8c28}&quot;<br>
[HKEY_CLASSES_ROOT\*\shellex\CopyHookHandlers\GAKsCopyHook]<br>
@=&quot;{87b9bd00-c65c-11cd-a259-00dd010e8c28}&quot;</tt> </p>

<p>Copy hook handlers differ from other user interface extensions
in that the copy hook handler interface is initialized
directly&#151;that is, without using an IShellExtInit or
IPersistFile interface first. Because of this, you don't need to
implement these interfaces. (Hooray! Less work!) You must,
however, implement the ICopyHook interface. But this is easily
done; you need to implement only the standard IUnknown member
functions and ICopyHook's one function, CopyCallBack. </p>

<h4>CopyCallBack</h4>

<p>The system calls the CopyCallBack member function before it
copies, moves, renames, or deletes a folder object. The operation
is designated by the <i>wFunc</i> parameter as one of the
following: </p>

<table border="1">
    <tr>
        <td valign="top">FO_COPY</td>
        <td valign="top">Copies files in <i>pszSrcFile</i> to <i>pszDestFile</i></td>
    </tr>
    <tr>
        <td valign="top">FO_MOVE</td>
        <td valign="top">Moves files in <i>pszSrcFile</i> to <i>pszDestFile</i></td>
    </tr>
    <tr>
        <td valign="top">FO_RENAME</td>
        <td valign="top">Renames files in <i>pszSrcFile</i></td>
    </tr>
    <tr>
        <td valign="top">FO_DELETE</td>
        <td valign="top">Deletes files in <i>pszSrcFile</i></td>
    </tr>
</table>

<p>This function returns an integer value (IDYES or IDNO) that
indicates whether the system should perform the operation. The
system calls each copy hook handler registered for a folder
object until all the handlers have been called or until a handler
returns IDCANCEL. </p>
</body>
</html>
