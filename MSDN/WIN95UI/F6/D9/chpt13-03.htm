<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">
<meta name="GENERATOR" content="Microsoft FrontPage 2.0">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Implementing IShellExtInit</title>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>

<BODY bgcolor="#FFFFFF">


<h1><font size="5">Implementing IShellExtInit</font></h1>

<p>To initialize an instance of a user interface extension, the
system uses one of two interfaces: IShellExtInit or IPersistFile.
You must use the IShellExtInit interface to initialize context
menu handlers, drag-and-drop handlers, and property sheet
handlers. </p>

<p>Like all COM interfaces, IShellExtInit supports the three
standard IUnknown member functions&#151;QueryInterface, AddRef,
and Release&#151;as shown in the PROPEXT sample. (If the syntax
looks a little odd, remember that this sample was written in MFC
and uses the built-in macros that support COM objects and nested
objects.) </p>

<p><tt>// IUnknown for IShellExtInit<br>
STDMETHODIMP CPropExt::XShellInit::QueryInterface (<br>
REFIID riid, void **ppv)<br>
{<br>
METHOD_PROLOGUE (CPropExt, ShellInit);<br>
TRACE (&quot;CPropExt::XShellInit::QueryInterface\n&quot;);<br>
return pThis-&gt;ExternalQueryInterface (&amp;riid, ppv);<br>
}<br>
<br>
STDMETHODIMP_(ULONG) CPropExt::XShellInit::AddRef (void)<br>
{<br>
METHOD_PROLOGUE (CPropExt, ShellInit);<br>
return pThis-&gt;ExternalAddRef ();<br>
}<br>
<br>
STDMETHODIMP_(ULONG) CPropExt::XShellInit::Release (void)<br>
{<br>
METHOD_PROLOGUE (CPropExt, ShellInit);<br>
return pThis-&gt;ExternalRelease ();<br>
}</tt> </p>

<p>When you use the IShellExtInit interface, you must also
implement the Initialize member function. </p>

<h4>Initialize</h4>

<p>This member function is passed a pointer to the IDataObject
that represents the file object(s) being manipulated. My
initialization code gets the name of the selected file. Because
the system stores that filename in the same way that the filename
is stored during a drag procedure, I can get the file by using
the DragQueryFile function. The filename is saved in a member
variable for the extension object. </p>

<p><tt>STDMETHODIMP CPropExt::XShellInit::Initialize (<br>
LPCITEMIDLIST pidlFolder, IDataObject *pdobj, HKEY hkeyProgID)<br>
{<br>
METHOD_PROLOGUE (CPropExt, ShellInit);<br>
TRACE (&quot;CPropExt::XShellInit::Intialize\n&quot;);<br>
<br>
HRESULT hres = E_FAIL;<br>
FORMATETC fmte = <br>
{<br>
CF_HDROP, // use CF_HDROP format<br>
NULL, // no specific device required<br>
DVASPECT_CONTENT, // embedded object<br>
-1, // must be -1 for DVASPECT_CONTENT<br>
TYMED_HGLOBAL // how to transfer data<br>
};<br>
STGMEDIUM medium;<br>
<br>
// No data object<br>
if (pdobj == NULL)<br>
{<br>
TRACE (&quot;CPropExt::XShellInit::Initialize() no data
object&quot;);<br>
return E_FAIL;<br>
}<br>
<br>
// Use the given IDataObject to get a list of filenames
(CF_HDROP).<br>
hres = pdobj-&gt;GetData (&amp;fmte, &amp;medium);<br>
<br>
if (FAILED (hres))<br>
{<br>
TRACE (&quot;CPropExt::XShellInit::Initialize() can't get
data&quot;);<br>
return E_FAIL;<br>
}<br>
<br>
// HDROP can contain more than one file. If the user selects<br>
// multiple files and brings up a context menu, your handler<br>
// will be called. Not all files will be your type! Only the<br>
// first one will be that type.<br>
if (DragQueryFile ((HDROP)medium.hGlobal, (UINT)(-1), NULL, 0) ==
1)<br>
{<br>
DragQueryFile ((HDROP)medium.hGlobal, 0, pThis-&gt;m_szFileName, <br>
sizeof (pThis-&gt;m_szFileName));<br>
hres = S_OK;<br>
}<br>
else<br>
hres = E_FAIL;<br>
<br>
// Release the data.<br>
ReleaseStgMedium (&amp;medium);<br>
<br>
return hres;<br>
}</tt> </p>
</body>
</html>
