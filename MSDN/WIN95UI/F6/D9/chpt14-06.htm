<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">
<meta name="GENERATOR" content="Microsoft FrontPage 2.0">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Filling the List View Control</title>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>

<BODY bgcolor="#FFFFFF">


<h1><font size="5">Filling the List View Control</font></h1>

<p>Now let's look at how to fill the list view control in our
samples with the contents of the folder selected in the tree view
control. In Figure 14-3, the contents of my root C drive are
displayed in a list view control in large icon view. (In Figure
14-2 on page 340, the same contents are displayed in list view.) </p>

<p><b>Figure 14-3.</b> </p>

<p><img src="fig14-3.gif" width="535" height="367"></p>

<h4><i>The contents of the Nancycl2 [C:] folder in large icon
view.</i> </h4>

<p>NOTE: You might have noticed that ENUMDESK, the C sample,
contains a feature that is missing from the MFC version: a
splitter bar. When I first ported the code to MFC, I ignored the
splitter bar, thinking that I would add it later. But of course I
ran out of time. So I leave the implementation of splitter bars
in MFC to you, as an interesting exercise. </p>

<p>In the MFCENUM sample, I populate the list view control
whenever a new folder is selected in the tree view control. The
list view control first deletes all its current items. When the
control is empty, the application uses the SHGetFileInfo function
to retrieve the image lists (large and small) associated with the
shell. </p>

<p><tt>BOOL CMfcenumView::InitListViewImageLists ()<br>
{<br>
HIMAGELIST himlSmall;<br>
HIMAGELIST himlLarge;<br>
SHFILEINFO sfi;<br>
BOOL bSuccess = TRUE;<br>
<br>
himlSmall = (HIMAGELIST) SHGetFileInfo ((LPCSTR)
&quot;C:\\&quot;, <br>
0, &amp;sfi, sizeof (SHFILEINFO), SHGFI_SYSICONINDEX |
SHGFI_SMALLICON);<br>
<br>
himlLarge = (HIMAGELIST) SHGetFileInfo ((LPCSTR)
&quot;C:\\&quot;, <br>
0, &amp;sfi, sizeof (SHFILEINFO), SHGFI_SYSICONINDEX |
SHGFI_LARGEICON);<br>
<br>
if (himlSmall &amp;&amp; himlLarge)<br>
{<br>
::SendMessage (m_ListCtl.m_hWnd, LVM_SETIMAGELIST, <br>
(WPARAM)LVSIL_SMALL, (LPARAM)himlSmall);<br>
::SendMessage (m_ListCtl.m_hWnd, LVM_SETIMAGELIST, <br>
(WPARAM)LVSIL_NORMAL, (LPARAM)himlLarge);<br>
}<br>
else<br>
bSuccess = FALSE;<br>
<br>
return bSuccess;<br>
}</tt> </p>

<p>After you've associated the image lists, it is time to fill
the list view control. This procedure is nearly identical to the
procedure used to fill the tree view control: get a task
allocator for the folder, enumerate the objects, and add those
that can be displayed to the list view control. </p>

<p><tt>BOOL CMfcenumView::InitListViewItems (<br>
LPTVITEMDATA lptvid, LPSHELLFOLDER lpsf)<br>
{<br>
LV_ITEM lvi;<br>
int iCtr;<br>
HRESULT hr;<br>
LPMALLOC lpMalloc;<br>
LPITEMIDLIST lpifqThisItem;<br>
LPITEMIDLIST lpi = NULL;<br>
LPENUMIDLIST lpe = NULL;<br>
LPLVITEMDATA lplvid;<br>
ULONG ulFetched, ulAttrs;<br>
HWND hwnd = ::GetParent (m_ListCtl.m_hWnd);<br>
UINT uFlags;<br>
<br>
lvi.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM;<br>
<br>
hr = SHGetMalloc (&amp;lpMalloc);<br>
if (FAILED (hr))<br>
return FALSE;<br>
<br>
if (SUCCEEDED (hr))<br>
{<br>
hr = lpsf-&gt;EnumObjects (hwnd, SHCONTF_FOLDERS |
SHCONTF_NONFOLDERS, <br>
&amp;lpe);<br>
<br>
if (SUCCEEDED (hr))<br>
{<br>
iCtr = 0;<br>
<br>
while (S_OK == lpe-&gt;Next (1, &amp;lpi, &amp;ulFetched))<br>
{<br>
// Get some memory for the ITEMDATA structure.<br>
lplvid = (LPLVITEMDATA) lpMalloc-&gt;Alloc (sizeof (LVITEMDATA));<br>
if (! lplvid)<br>
goto Done;<br>
<br>
// Since you are interested in the display attributes <br>
// as well as other attributes, you need to set ulAttrs to <br>
// SFGAO_DISPLAYATTRMASK before calling GetAttributesOf().<br>
ulAttrs = SFGAO_DISPLAYATTRMASK;<br>
lpsf-&gt;GetAttributesOf (1, (const struct _ITEMIDLIST
**)&amp;lpi, <br>
&amp;ulAttrs);<br>
lplvid-&gt;ulAttribs = ulAttrs;<br>
<br>
lpifqThisItem = ConcatPidls (lptvid-&gt;lpifq, lpi);<br>
<br>
lvi.iItem = iCtr++;<br>
lvi.iSubItem = 0;<br>
lvi.pszText = LPSTR_TEXTCALLBACK;<br>
lvi.cchTextMax = MAX_PATH;<br>
uFlags = SHGFI_PIDL | SHGFI_SYSICONINDEX | SHGFI_SMALLICON;<br>
lvi.iImage = I_IMAGECALLBACK;<br>
<br>
lplvid-&gt;lpsfParent = lpsf;<br>
lpsf-&gt;AddRef ();<br>
<br>
// Now make a copy of the ITEMIDLIST.<br>
lplvid-&gt;lpi = CopyITEMID (lpMalloc, lpi);<br>
<br>
lvi.lParam = (LPARAM)lplvid;<br>
<br>
// Add the item to the list view control.<br>
if (m_ListCtl.InsertItem (&amp;lvi) == -1)<br>
return FALSE;<br>
<br>
lpMalloc-&gt;Free (lpifqThisItem); <br>
lpifqThisItem = 0;<br>
lpMalloc-&gt;Free (lpi); // free the PIDL the shell gave you<br>
lpi = 0;<br>
}<br>
}<br>
}<br>
<br>
Done:<br>
if (lpe) <br>
lpe-&gt;Release ();<br>
<br>
// The following two if statements will be TRUE only if you got
here <br>
// on an error condition from the goto statement. Otherwise, free
<br>
// this memory at the end of the while loop above.<br>
if (lpi &amp;&amp; lpMalloc) <br>
lpMalloc-&gt;Free (lpi);<br>
if (lpifqThisItem &amp;&amp; lpMalloc) <br>
lpMalloc-&gt;Free (lpifqThisItem);<br>
<br>
if (lpMalloc) <br>
lpMalloc-&gt;Release ();<br>
<br>
return TRUE;<br>
}</tt> </p>

<p>The final step is to sort the list view control by using the
LVM_SORTITEMS message or the CListCtrl::SortItems member
function. Items can be sorted through a callback procedure that
uses the IShellFolder::CompareIDs member function. This function
compares two item ID lists and returns the result. Windows
Explorer always passes 0 as the<i> lParam</i> parameter to
indicate that the items should be sorted by name. The compare
function returns 0 if the objects are the same, a negative value
if <i>pidl1</i> should be placed before <i>pidl2</i>, and a
positive value if <i>pidl2</i> should be placed before <i>pidl1</i>.
</p>

<p><tt>int CALLBACK CMfcenumView::ListViewCompareProc (<br>
LPARAM lparam1, LPARAM lparam2, LPARAM lparamSort)<br>
{<br>
LPLVITEMDATA lplvid1 = (LPLVITEMDATA)lparam1;<br>
LPLVITEMDATA lplvid2 = (LPLVITEMDATA)lparam2;<br>
HRESULT hr;<br>
<br>
hr = lplvid1-&gt;lpsfParent-&gt;CompareIDs (0, lplvid1-&gt;lpi,
lplvid2-&gt;lpi);<br>
<br>
if (FAILED (hr))<br>
return 0;<br>
<br>
return hr;<br>
}</tt> </p>
</body>
</html>
