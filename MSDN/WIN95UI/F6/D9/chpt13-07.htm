<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">
<meta name="GENERATOR" content="Microsoft FrontPage 2.0">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Context Menu Handler Interfaces</title>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>

<BODY bgcolor="#FFFFFF">


<h2>Context Menu Handler Interfaces</h2>

<p>To create a context menu handler, you must implement both the
IShellExtInit and the IContextMenu interfaces. In addition to the
usual IUnknown functions, the context menu handler interface uses
the QueryContextMenu, InvokeCommand, and GetCommandString member
functions. </p>

<h4>QueryContextMenu</h4>

<p>The QueryContextMenu member function is called just before the
system displays an object's context menu. A context menu handler
inserts a menu item by position (MF_BYPOSITION) directly into the
context menu by calling InsertMenu. In the call to InsertMenu,
QueryContextMenu passes the handle to the context menu in the <i>hMenu</i>
parameter. The second parameter, <i>indexMenu</i>, specifies
where to insert the menu item; and the third parameter, <i>idCmdFirst</i>,
provides the first menu item identifier you should use for that
context menu. Because menu items must be string items
(MF_STRING), the <i>uFlags</i> parameter of InsertMenu must be <i>MF_BYPOSITION
| MF_STRING</i> for each menu item the context menu handler
inserts. The following example demonstrates how to add three new
menu items (Sample Menu Item 1, Sample Menu Item 2, and Sample
Menu Item 3) to a context menu: </p>

<p><tt>STDMETHODIMP Sample::QueryContextMenu (HMENU hmenu, <br>
UINT indexMenu, UINT idCmdFirst, UINT idCmdLast, UINT uFlags)<br>
{<br>
int cVerbs = THREE_ITEMS;<br>
<br>
for (int i = 0; i &lt; cVerbs; i++)<br>
{<br>
char szMenu [80];<br>
wsprintf (szMenu, &quot;Sample Menu Item #%d&quot;, i + 1);<br>
InsertMenu (hmenu, indexMenu + i, MF_BYPOSITION | MF_STRING,<br>
idCmdFirst + i, szMenu);<br>
}<br>
<br>
return (HRESULT)cVerbs;<br>
}</tt> </p>

<h4>InvokeCommand</h4>

<p>InvokeCommand is called when the user selects an item from the
context menu for which you have registered a handler. This
function is passed a pointer to the LPCMINVOKECOMMANDINFO
structure, which contains information including the size of the
structure (<i>cbSize</i>), the owner window for any message box
or dialog box (<i>hwnd</i>), the validity of the <i>dwHotkey</i>
and <i>hIcon</i> parameters (<i>fMask</i>), the command to be
executed (<i>lpVerb</i>), the flag to be passed to ShowWindow (<i>nShow</i>),
the hot key to be assigned to the application after it is opened
(<i>dwHotkey</i>), and the handle to an icon (<i>hIcon</i>). Hot
keys and icons are optional. The LOWORD of the <i>lpVerb</i>
member contains the menu item identifier offset (the menu item ID
minus <i>idCmdFirst</i>), which is used to determine what command
the user has chosen. In the following code from the CTXTMENU
sample, this value is the new command, ID_NEWCMD, and a message
box is displayed: </p>

<p><tt>STDMETHODIMP CTxtMenu::XMenuExt::InvokeCommand (<br>
LPCMINVOKECOMMANDINFO lpici)<br>
{<br>
METHOD_PROLOGUE (CTxtMenu, MenuExt);<br>
char szTest [MAX_PATH * 2];<br>
<br>
if (HIWORD (lpici-&gt;lpVerb))<br>
{<br>
AfxMessageBox (&quot;E_FAIL&quot;);<br>
return E_FAIL;<br>
}<br>
<br>
if (LOWORD (lpici-&gt;lpVerb) &gt; ID_NEWCMD)<br>
{<br>
AfxMessageBox (&quot;Invalid Arg&quot;);<br>
return E_INVALIDARG;<br>
}<br>
<br>
if (LOWORD (lpici-&gt;lpVerb) == ID_NEWCMD)<br>
{<br>
wsprintf (szTest, &quot;Context menu for file: %s&quot;,
pThis-&gt;m_szFileName);<br>
::MessageBox (lpici-&gt;hwnd, szTest, &quot;Context Menu
Handler&quot;, MB_OK);<br>
}<br>
else<br>
::MessageBox (lpici-&gt;hwnd, &quot;ID != ID_NEWCMD&quot;,
&quot;Context Menu Handler&quot;,<br>
MB_OK);<br>
<br>
return NOERROR;<br>
}</tt> </p>

<p>After you install the context menu handler, click the item
labeled Test Context Menu to see the dialog box shown in Figure
13-2. </p>

<p><b>Figure 13-2.</b> </p>

<p><img src="fig13-2.gif" width="326" height="100"></p>

<h4><i>The Context Menu Handler dialog box.</i> </h4>

<h4>GetCommandString</h4>

<p>A context menu handler must also implement GetCommandString.
This function is called to provide Help text for a context menu
item. GetCommandString simply copies into the <i>pszName</i>
string the text that will be displayed: </p>

<p><tt>STDMETHODIMP CTxtMenu::XMenuExt::GetCommandString (<br>
UINT idCmd, UINT uType, UINT *pwReserved, LPSTR pszName, UINT
cchMax)<br>
{<br>
if (idCmd &gt; ID_NEWCMD)<br>
return ResultFromScode (E_INVALIDARG);<br>
<br>
if (idCmd == ID_NEWCMD)<br>
lstrcpy (pszName, &quot;Context Menu Test&quot;);<br>
<br>
return NOERROR;<br>
}</tt> </p>
</body>
</html>
