<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">
<meta name="GENERATOR" content="Microsoft FrontPage 2.0">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Creating a Property Sheet</title>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>

<BODY bgcolor="#FFFFFF">


<h2>Creating a Property Sheet</h2>

<p>My PROPS sample demonstrates how to create and manipulate
property sheets. It produces a simple property sheet that
supports two pages. I had already written the TRACKBAR sample
(discussed in Chapter 2), so I put a trackbar on the client area
of the screen and used a property sheet to set values for this
control. </p>

<h3>Converting Dialog Boxes to Property Sheets</h3>

<p>First I took an existing sample and used its dialog boxes for
the pages in my property sheet. I made two major changes to the
dialog templates: </p>

<ul>
    <li>I removed the OK, Cancel, and Help buttons from the
        dialog templates because these buttons are already
        included in the property sheet control. </li>
    <li>I added the DS_3DLOOK dialog box style to the dialog
        templates. This style gives the pages the same
        three-dimensional look as the rest of the built-in dialog
        boxes. </li>
</ul>

<p>In the Microsoft Visual C++ 2.1 resource editor, the DS_3DLOOK
style is not supported with the other dialog box styles. To use
this style, you need to edit your dialog boxes manually. </p>

<p>I also took this opportunity to review my dialog boxes and
concluded that I could rearrange the contents of the original
four dialog boxes into two pages. This added a little extra work
to the conversion, but it improved the organization of the pages
and gave my sample a more polished look. If you aren't converting
dialog boxes to property sheet pages, you can simply use the
resource editor to create a new dialog box, follow the two steps
described in the bulleted list on page 114, and add your
controls. </p>

<p>After I converted the dialog boxes, I produced the property
sheet by defining an array of PROPSHEETPAGE structures for the
pages, filling out a PROPSHEETHEADER structure, and then calling
the PropertySheet function. This function creates handles for the
pages before adding the pages to the property sheet. The order of
the array determines the order of the pages in the property
sheet, so be sure to decide the sequence of the tabs before you
define the pages in the array. </p>

<p>Once a property sheet exists, an application can add and
remove pages dynamically by sending the PSM_ADDPAGE and
PSM_REMOVEPAGE messages or executing their corresponding macros.
By default, when a property sheet is destroyed, its pages are
destroyed in first-in-last-out (FILO) order&#151;that is, the
last page specified in the array of pages is the first page
destroyed. </p>

<p>I wrote the CreatePropertySheet function to create the
property sheet and its pages. This function fills out a
PROPSHEETPAGE structure for the two pages, fills out the
PROPSHEETHEADER structure, and then calls the PropertySheet
function. I replaced the DialogBox function calls in my code with
a call to the CreatePropertySheet function. </p>

<p><tt>int CreatePropertySheet (HWND hwndOwner)<br>
{<br>
PROPSHEETPAGE psp [2];<br>
PROPSHEETHEADER psh;<br>
<br>
psp[0].dwSize = sizeof (PROPSHEETPAGE);<br>
psp[0].dwFlags = PSP_USETITLE;<br>
psp[0].hInstance = hInst;<br>
psp[0].pszTemplate = MAKEINTRESOURCE (IDD_RANGE);<br>
psp[0].pszIcon = NULL;<br>
psp[0].pfnDlgProc = Range;<br>
psp[0].pszTitle = &quot;Trackbar Range&quot;;<br>
psp[0].lParam = 0;<br>
<br>
psp[1].dwSize = sizeof (PROPSHEETPAGE);<br>
psp[1].dwFlags = PSP_USETITLE;<br>
psp[1].hInstance = hInst;<br>
psp[1].pszTemplate = MAKEINTRESOURCE (IDD_PROPS);<br>
psp[1].pszIcon = NULL;<br>
psp[1].pfnDlgProc = PageSize;<br>
psp[1].pszTitle = &quot;Trackbar Page and Line Size&quot;;<br>
psp[1].lParam = 0;<br>
<br>
psh.dwSize = sizeof (PROPSHEETHEADER);<br>
psh.dwFlags = PSH_PROPSHEETPAGE;<br>
psh.hwndParent = hwndOwner;<br>
psh.hInstance = hInst;<br>
psh.pszIcon = NULL;<br>
psh.pszCaption = (LPSTR)&quot;Trackbar Properties&quot;;<br>
psh.nPages = sizeof (psp) / sizeof (PROPSHEETPAGE);<br>
psh.ppsp = (LPCPROPSHEETPAGE) &amp;psp;<br>
<br>
return PropertySheet (&amp;psh);<br>
}</tt> </p>

<h3>Changing the Dialog Procedure</h3>

<p>Next I had to convert my dialog procedure from managing a
dialog box to managing a property sheet page. The major changes
involved the handling of the OK and Cancel buttons. Typically, a
WM_COMMAND message notifies a dialog procedure that the OK or
Cancel button has been clicked. When the procedure gets this
message, it generally verifies the information entered in the
dialog box controls and calls the EndDialog function to destroy
the dialog box. The following code demonstrates how a typical
dialog procedure manages the OK button: </p>

<p><tt>case WM_COMMAND:<br>
if (LOWORD (wParam) == IDOK)<br>
{<br>
uMin = GetDlgItemInt (hDlg, IDE_MIN, &amp;bErr, TRUE);<br>
uMax = GetDlgItemInt (hDlg, IDE_MAX, &amp;bErr, TRUE);<br>
SendMessage (hWndCurrent, TBM_SETRANGE, TRUE, <br>
MAKELONG (uMax, uMin));<br>
EndDialog (hDlg, TRUE);<br>
return TRUE;<br>
}<br>
break;</tt> </p>

<p>In a property sheet, the OK and Cancel notifications are no
longer sent to the dialog procedure. Instead, the procedure must
handle a group of page notifications. My application needed to
handle the following notifications: </p>

<table border="1">
    <tr>
        <td valign="top">PSN_APPLY</td>
        <td valign="top">Sent when the user clicks the OK button
        or the Apply button. This is also the time to validate
        any changes the user has made.</td>
    </tr>
    <tr>
        <td valign="top">PSN_KILLACTIVE</td>
        <td valign="top">Sent when the user clicks a tab on the
        property sheet and switches pages.</td>
    </tr>
    <tr>
        <td valign="top">PSN_RESET</td>
        <td valign="top">Sent when the user clicks the Cancel
        button.</td>
    </tr>
    <tr>
        <td valign="top">PSN_SETACTIVE</td>
        <td valign="top">Sent when a page is coming into focus.
        The application should take this opportunity to
        initialize the controls for that page.</td>
    </tr>
</table>

<p>Initially, I found it difficult to differentiate between the
OK and Apply buttons. They both require the page to validate and
apply the changes the user has made. The only difference is that
clicking OK destroys the property sheet after the changes are
applied, whereas clicking Apply does not. As a result, if the
user applies a change and later cancels out of the property
sheet, the application should reset the property to its initial
value rather than saving the applied value. In other words,
changes are permanent when the user chooses the OK button; the
Apply button allows the user to &#147;try out&#148; an action. </p>

<p>Another change I had to make was removing the EndDialog call.
I couldn't call the EndDialog function for a property sheet page
because it destroys the entire property sheet instead of
destroying only the page. The following dialog procedure handles
the Trackbar Range page: </p>

<p><tt>BOOL APIENTRY Range (<br>
HWND hDlg,<br>
UINT message,<br>
UINT wParam,<br>
LONG lParam)<br>
{<br>
static PROPSHEETPAGE *ps;<br>
BOOL bErr;<br>
static UINT uMin, uMax, uMinSave, uMaxSave;<br>
<br>
switch (message)<br>
{<br>
case WM_INITDIALOG: <br>
// Save the PROPSHEETPAGE information.<br>
ps = (PROPSHEETPAGE *)lParam;<br>
return TRUE;<br>
<br>
case WM_NOTIFY:<br>
switch (((NMHDR FAR *)lParam)-&gt;code) <br>
{<br>
case PSN_SETACTIVE:<br>
// Initialize the controls.<br>
uMinSave = SendMessage (hWndSlider, TBM_GETRANGEMIN, <br>
0L, 0L);<br>
uMaxSave = SendMessage (hWndSlider, TBM_GETRANGEMAX, <br>
0L, 0L);<br>
SetDlgItemInt (hDlg, IDE_MIN, uMinSave, TRUE);<br>
SetDlgItemInt (hDlg, IDE_MAX, uMaxSave, TRUE);<br>
break;<br>
<br>
case PSN_APPLY:<br>
uMin = GetDlgItemInt (hDlg, IDE_MIN, &amp;bErr, TRUE);<br>
uMax = GetDlgItemInt (hDlg, IDE_MAX, &amp;bErr, TRUE);<br>
SendMessage (hWndSlider, TBM_SETRANGE, TRUE, <br>
MAKELONG (uMin, uMax));<br>
SetWindowLong (hDlg, DWL_MSGRESULT, TRUE);<br>
break;<br>
<br>
case PSN_KILLACTIVE:<br>
SetWindowLong (hDlg, DWL_MSGRESULT, FALSE);<br>
return 1;<br>
break;<br>
<br>
case PSN_RESET:<br>
// Reset to the original values.<br>
SendMessage (hWndSlider, TBM_SETRANGE, TRUE, <br>
MAKELONG (uMinSave, uMaxSave));<br>
SetWindowLong (hDlg, DWL_MSGRESULT, FALSE);<br>
break;<br>
}<br>
}<br>
return FALSE;<br>
}</tt> </p>

<p>When a page is created, the dialog procedure for the page
receives a WM_INITDIALOG message (as it does when a dialog box is
created); however, the <i>lParam</i> parameter points to the
PROPSHEETPAGE structure that is used to produce the page. The
dialog procedure can save the pointer to this structure and use
it later to modify the page. </p>
</body>
</html>
