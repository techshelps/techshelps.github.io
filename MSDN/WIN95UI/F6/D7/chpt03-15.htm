<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">
<meta name="GENERATOR" content="Microsoft FrontPage 2.0">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Implementing Drag and Drop for a Tree View Item</title>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>

<BODY bgcolor="#FFFFFF">


<h2>Implementing Drag and Drop for a Tree View Item</h2>

<p>Now that you have a tree view control that can be expanded and
collapsed, it would be neat if the user could pick up one of the
items and drag it to a new location. The tree view control has
some built-in functions that facilitate this operation. When
processing a drag operation for a tree view item, an application
typically does the following: </p>

<ol>
    <li>Processes the start of the drag </li>
    <li>Processes the dragging </li>
    <li>Processes the drop </li>
</ol>

<p>An application processes the start of the drag (picking up the
item) in the window procedure of the parent window by using the
TVN_BEGINDRAG notification (if the user is dragging with the left
mouse button) or the TVN_BEGINRDRAG notification (if the user is
dragging with the right mouse button). These notifications are
sent through a WM_NOTIFY message. The following sample code
creates a drag image, captures the mouse, and sets a Boolean flag
to signal that dragging is occurring: </p>

<p><tt>case WM_NOTIFY:<br>
switch(((LPNMHDR)lParam)-&gt;code)<br>
{<br>
case TVN_BEGINDRAG:<br>
// The user wants to drag an item. Call the drag handler.<br>
BeginDrag (hWndTreeView, (NM_TREEVIEW *)lParam);<br>
// Save the dragged item information.<br>
tvI = ((NM_TREEVIEW *)lParam)-&gt;itemNew;<br>
// Get a handle to the drag object.<br>
hDragItem = tvI.hItem;<br>
break;<br>
<br>
default:<br>
break;<br>
}<br>
break;<br>
§<br>
VOID BeginDrag (HWND hwndTree, NM_TREEVIEW *lItem)<br>
{<br>
HIMAGELIST hIml;<br>
RECT rcl;<br>
<br>
// Create an image to use for dragging.<br>
hIml = TreeView_CreateDragImage (hwndTree,
lItem-&gt;itemNew.hItem);<br>
<br>
// Get the bounding rectangle of the item being dragged.<br>
TreeView_GetItemRect (hwndTree, lItem-&gt;itemNew.hItem,
&amp;rcl, TRUE);<br>
<br>
// Start dragging the image.<br>
ImageList_BeginDrag (hIml, 0, lItem-&gt;ptDrag.x,
lItem-&gt;ptDrag.y);<br>
<br>
// Hide the cursor.<br>
ShowCursor (FALSE);<br>
<br>
// Capture the mouse.<br>
SetCapture (GetParent (hwndTree));<br>
<br>
// Set a global flag that tells whether dragging is occurring.<br>
g_fDragging = TRUE;<br>
}</tt> </p>

<p>The MFCTREE sample handles the drag-and-drop operation through
a virtual function mapped to the WindowProc function: </p>

<p><tt>// Handle the WM_NOTIFY::TVN_BEGINDRAG notification.<br>
LRESULT CMfctreeView::WindowProc (UINT message, WPARAM wParam,<br>
LPARAM lParam) <br>
{<br>
TV_ITEM tvI;<br>
if (message == WM_NOTIFY)<br>
{<br>
if (((LPNMHDR)lParam)-&gt;code == TVN_BEGINDRAG)<br>
{<br>
BeginDrag ((NM_TREEVIEW *)lParam);<br>
tvI = ((NM_TREEVIEW *)lParam)-&gt;itemNew;<br>
<br>
// Get a handle to the drag object.<br>
m_hDragItem = tvI.hItem;<br>
}<br>
}<br>
return CView::WindowProc (message, wParam, lParam);<br>
}<br>
<br>
VOID CMfctreeView::BeginDrag (NM_TREEVIEW *lItem)<br>
{<br>
CImageList *CImage;<br>
<br>
// Create an image to use for dragging.<br>
CImage = m_TreeCtl.CreateDragImage (lItem-&gt;itemNew.hItem);<br>
<br>
// Start dragging the image.<br>
CImage-&gt;BeginDrag (0, lItem-&gt;ptDrag);<br>
<br>
// Hide the cursor.<br>
ShowCursor (FALSE);<br>
<br>
SetCapture ();<br>
m_fDragging = TRUE;<br>
}</tt> </p>

<p>The application processes the dragging operation by capturing
the mouse and monitoring the WM_MOUSEMOVE messages. In a typical
drag-and-drop scenario, the image appears to be dragged because
the cursor is changed to the image of the item being dragged. </p>

<p><tt>VOID CMfctreeView::OnMouseMove (UINT nFlags, CPoint point)<br>
{<br>
HTREEITEM hTarget;<br>
UINT flags;<br>
<br>
if (m_fDragging)<br>
{<br>
// Drag the item to the current mouse position.<br>
m_ImageList.DragMove (point);<br>
<br>
flags = TVHT_ONITEM;<br>
// If the cursor is on an item, highlight it as the drop target.<br>
if ((hTarget = m_TreeCtl.HitTest (point, &amp;flags)) != NULL)<br>
m_TreeCtl.SelectDropTarget (hTarget);<br>
}<br>
<br>
CView::OnMouseMove (nFlags, point);<br>
}</tt> </p>

<p>When the user finishes dragging the item, the application can
look for the WM_LBUTTONUP message. At this point, the currently
selected item is recorded, the mouse is released, and the cursor
is restored to the previous state. This is also the point at
which you want to reset the parentage of the item and reset any
internal structures that are keeping track of your tree items.
Also, remember to reset the drop highlight item. During the drag
operation, the drop highlight item changes dynamically as the
user moves the mouse. When the item is dropped, you need to set
the drop highlight back to NULL, or you will end up with two
items that both appear selected, because selected items and drop
highlight items are painted the same way. This is remedied by
another call to TreeView_SelectItem, passing NULL for the <i>hItem</i>
parameter. </p>

<p><tt>case WM_LBUTTONUP:<br>
// If dragging, stop it.<br>
if (g_fDragging)<br>
{<br>
// Process the item drop.<br>
DropItem (hDragItem, hWndTreeView);<br>
<br>
// Inform the image list that dragging has stopped.<br>
ImageList_EndDrag ();<br>
<br>
// Release the mouse capture.<br>
ReleaseCapture ();<br>
<br>
// Show the cursor.<br>
ShowCursor (TRUE);<br>
<br>
// Reset the global Boolean flag to a nondragging state.<br>
g_fDragging = FALSE; <br>
}<br>
break;<br>
<br>
// Function that processes the item drop<br>
VOID DropItem (HTREEITEM hDragItem, HWND hwnd)<br>
{<br>
HTREEITEM hParent, hNewItem, hTarget;<br>
TV_ITEM tvTarget;<br>
int index;<br>
<br>
// Get the handle to the drop target.<br>
hTarget = TreeView_GetDropHilight (hwnd);<br>
<br>
// Get the parent of the drop target.<br>
hParent = TreeView_GetParent (hwnd, hTarget);<br>
<br>
// Get the image information.<br>
tvTarget.hItem = hTarget;<br>
tvTarget.mask = TVIF_IMAGE;<br>
TreeView_GetItem (hwnd, &amp;tvTarget);<br>
<br>
// Get the index into the structure containing the text for the
items.<br>
for (index = 0; index &lt; NUM_HOUSES; index++)<br>
{<br>
if (rgHouseInfo[index].hItem == hDragItem)<br>
break;<br>
}<br>
<br>
if (index == NUM_HOUSES)<br>
index&#151;;<br>
<br>
// Reinsert the new item.<br>
hNewItem = AddOneItem (hParent, rgHouseInfo[index].szAddress,<br>
hTarget, tvTarget.iImage, hwnd);<br>
<br>
// Delete the dragged item.<br>
TreeView_DeleteItem(hwnd, hDragItem);<br>
<br>
// Reset the drop target to NULL.<br>
TreeView_SelectDropTarget (hwnd, (HTREEITEM)NULL);<br>
}</tt> </p>

<p>As you can see, processing a drag-and-drop operation for a
tree view control is not at all difficult, so you really won't
have any excuse for not supporting it. </p>
</body>
</html>
