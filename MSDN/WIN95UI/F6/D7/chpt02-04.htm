<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">
<meta name="GENERATOR" content="Microsoft FrontPage 2.0">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Working with a Trackbar</title>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>

<BODY bgcolor="#FFFFFF">


<h2>Working with a Trackbar</h2>

<p>My trackbar sample programs allow a user to change or view a
trackbar's range, tick frequency, page size, and line size
through dialog boxes activated from the Options menu. You create
these dialog boxes in the view class. For each dialog box, I
wrote a class derived from CDialog and created a member variable
for each value I needed from the controls. </p>

<p>For example, the Set Trackbar Range dialog box uses edit
controls to let the user enter minimum and maximum values for the
range and specify the trackbar to be set, as shown in Figure 2-4.
For the trackbar, ClassWizard let me set up a member variable
that is an integer between 0 and 2. (How nice that MFC provides
this range checking!) </p>

<p><b>Figure 2-4.</b> </p>

<p><img src="fig2-4.gif" width="290" height="183"></p>

<h4><i>The Set Trackbar Range dialog box.</i> </h4>

<p>I did not place restrictions on the actual minimum and maximum
range values because you can in fact set the range's minimum
value to be greater than the maximum (for instance, a minimum of
10 and a maximum of -1). If you do this, however, your trackbar
will track backward (that is, the slider in a vertical trackbar
will start at the bottom and move upward). When I run the Set
Trackbar Range dialog box, the program simply sets the range on
the specified trackbar by using the SetRange member function, as
shown here: </p>

<p><tt>CRange::CRange (CWnd *pParent /*=NULL*/)<br>
: CDialog (CRange::IDD, pParent)<br>
{<br>
// {{AFX_DATA_INIT (CRange)<br>
m_Min = 0;<br>
m_Max = 0;<br>
m_Slider = 1;<br>
// }}AFX_DATA_INIT<br>
}<br>
<br>
void CRange::DoDataExchange (CDataExchange *pDX)<br>
{<br>
CDialog::DoDataExchange (pDX);<br>
// {{AFX_DATA_MAP (CRange)<br>
DDX_Text (pDX, IDE_MIN, m_Min);<br>
DDX_Text (pDX, IDE_MAX, m_Max);<br>
DDX_Text (pDX, IDE_SLIDER, m_Slider);<br>
DDV_MinMaxInt (pDX, m_Slider, 1, 2);<br>
// }}AFX_DATA_MAP<br>
}<br>
<br>
BEGIN_MESSAGE_MAP (CRange, CDialog)<br>
// {{AFX_MSG_MAP (CRange)<br>
// }}AFX_MSG_MAP<br>
END_MESSAGE_MAP ()<br>
<br>
void CMfctrackView::OnRange () <br>
{<br>
CRange rangeDlg;<br>
<br>
if (rangeDlg.DoModal () == IDOK)<br>
{<br>
switch (rangeDlg.m_Slider)<br>
{<br>
case 1:<br>
m_Slider1.SetRange (rangeDlg.m_Min, rangeDlg.m_Max, TRUE);<br>
break;<br>
<br>
case 2:<br>
m_Slider2.SetRange (rangeDlg.m_Min, rangeDlg.m_Max, TRUE);<br>
break;<br>
<br>
case 3:<br>
m_Slider3.SetRange (rangeDlg.m_Min, rangeDlg.m_Max, TRUE);<br>
break;<br>
<br>
default:<br>
break;<br>
}<br>
}<br>
}</tt> </p>

<p>Finally, you can update the status bar to show which trackbar
notification is being sent to each trackbar. In C, all of this
code is in SLIDER.C, and the handles to the trackbars and the
status bar are all within the scope of the window procedure. When
using MFC, you need to find a different method because the
pointer to the status bar object is not in scope when you need to
set its text. You can create a message map entry for the
WM_HSCROLL and WM_VSCROLL messages and copy the notification to a
character buffer. Then you get a pointer to the status bar and
set the text accordingly: </p>

<p><tt>void CMfctrackView::OnHScroll (UINT nSBCode, UINT nPos, <br>
CScrollBar *pScrollBar) <br>
{<br>
TrackScrolling (nSBCode);<br>
<br>
CView::OnHScroll (nSBCode, nPos, pScrollBar);<br>
}<br>
<br>
void CMfctrackView::OnVScroll (UINT nSBCode, UINT nPos, <br>
CScrollBar *pScrollBar) <br>
{<br>
TrackScrolling (nSBCode);<br>
<br>
CView::OnVScroll (nSBCode, nPos, pScrollBar);<br>
}<br>
<br>
VOID CMfctrackView::TrackScrolling (UINT nSBCode) <br>
{<br>
BOOL bMsg = TRUE;<br>
char *pMsg = NULL;<br>
<br>
switch (nSBCode)<br>
{<br>
case TB_BOTTOM:<br>
pMsg = &quot;TB_BOTTOM&quot;;<br>
break;<br>
<br>
case TB_ENDTRACK:<br>
pMsg = &quot;TB_ENDTRACK&quot;;<br>
break;<br>
<br>
case TB_LINEDOWN:<br>
pMsg = &quot;TB_LINEDOWN&quot;;<br>
break;<br>
<br>
case TB_LINEUP:<br>
pMsg = &quot;TB_LINEUP&quot;;<br>
break;<br>
<br>
case TB_PAGEDOWN:<br>
pMsg = &quot;TB_PAGEDOWN&quot;;<br>
break;<br>
<br>
case TB_PAGEUP:<br>
pMsg = &quot;TB_PAGEUP&quot;;<br>
break;<br>
<br>
case TB_THUMBPOSITION:<br>
pMsg = &quot;TB_THUMBPOSITION&quot;;<br>
break;<br>
<br>
case TB_THUMBTRACK:<br>
pMsg = &quot;TB_THUMBTRACK&quot;;<br>
break;<br>
<br>
default:<br>
bMsg = FALSE;<br>
break;<br>
}<br>
<br>
if (bMsg == TRUE)<br>
{<br>
CStatusBar* pStatus = (CStatusBar*) GetParentFrame()-&gt;<br>
GetDescendantWindow (ID_VIEW_STATUS_BAR);<br>
char szBuf [256];<br>
sprintf (szBuf, &quot;Trackbar message: %s&quot;, pMsg);<br>
pStatus-&gt;SetPaneText (0, szBuf);<br>
pStatus-&gt;UpdateWindow ();<br>
}<br>
}</tt> </p>
</body>
</html>
