<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">
<meta name="GENERATOR" content="Microsoft FrontPage 2.0">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Creating a Multiple-Part Status Bar</title>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>

<BODY bgcolor="#FFFFFF">


<h2>Creating a Multiple-Part Status Bar</h2>

<p>I first wrote the STATUS sample in C using the messages
provided by the Win32 API. I decided to create a multiple-part
status bar to show these elements: </p>

<p>Normal text </p>

<p>Text that &#147;pops out&#148; </p>

<p>Text without a border </p>

<p>An owner-drawn section with a bitmap displayed </p>

<p>The following code, found in the STATUS.C file on the
companion disc, creates the status bar and breaks it into parts.
The array of integers passed in the SB_SETPARTS message (or the
MFC SetParts member function) is an array of endpoints for each
part of the status bar. Because I take care of sizing my status
bar when I handle the WM_SIZE message, I fill in the actual
endpoints at that time. As is the case for most of the common
controls, you need to include the COMMCTRL.H header file in order
to use status bars in your application, and you must include the
COMCTL32.LIB file in your list of libraries. </p>

<p><tt>static HWND hWndStatus;<br>
static int aWidths [4];<br>
<br>
switch (message) <br>
{<br>
case WM_CREATE:<br>
hWndStatus = CreateWindowEx ( <br>
0L, // extended style<br>
STATUSCLASSNAME, // create status bar<br>
&quot;&quot;, // window title<br>
WS_CHILD | WS_BORDER | <br>
WS_VISIBLE | SBS_SIZEGRIP, // window styles<br>
0, 0, 0, 0, // x, y, width, height<br>
hWnd, // parent window<br>
(HMENU)ID_STATUSBAR, // ID<br>
hInst, // instance<br>
NULL); // window data<br>
<br>
if (hWndStatus == NULL)<br>
MessageBox (NULL, &quot;Status Bar not created!&quot;, NULL,
MB_OK);<br>
// Break the status bar into four parts.<br>
SendMessage (hWndStatus, SB_SETPARTS, 4, (LPARAM)aWidths);</tt> </p>

<p>Now that you've created the status bar, you should give it
some text to display. What good is a status bar that doesn't say
anything? Setting text is as easy as sending a message (or
calling an MFC member function). The trick to displaying the
different kinds of text shown in Figure 1-1 on page 9 is to set
the drawing style when setting the text. The <i>wParam</i>
parameter for the SB_SETTEXT message is a combination of the
(zero-based) part of the status bar that receives the text and
the text drawing style. </p>

<p><tt>// Set the text in the first part to normal.<br>
SendMessage (hWndStatus, SB_SETTEXT, 0, <br>
(LPARAM)&quot;Mouse position:&quot;);<br>
<br>
// Set the text in the second part to pop out.<br>
SendMessage (hWndStatus, SB_SETTEXT, 1 | SBT_POPOUT, <br>
(LPARAM)&quot;This text pops out.&quot;);<br>
<br>
// Set the text in the third part to have no borders.<br>
SendMessage (hWndStatus, SB_SETTEXT, 2 | SBT_NOBORDERS, <br>
(LPARAM)&quot;This text has no borders.&quot;);<br>
<br>
// Load the bitmap for the owner-drawn part of the status bar.<br>
hBmp = LoadBitmap (hInst, MAKEINTRESOURCE (ID_BITMAP));<br>
<br>
// Set the fourth part to be owner-drawn and pass the bitmap.<br>
SendMessage (hWndStatus, SB_SETTEXT, 3 | SBT_OWNERDRAW, <br>
(LPARAM)hBmp);</tt> </p>

<p>The MFC version of the code (the MFCSTATUS sample) creates the
status bar in the view class of the OnCreate handler in the
MFCSTVW.CPP file. The status bar is created and the text and
parts initially set using the member functions provided by the
CStatusBarCtrl class. As you can see, the code is very similar.
One difference is in the SetText member function. Whereas the
SB_SETTEXT message packed both the part and the drawing style
into <i>wParam</i>, the SetText member function receives these
two values separately: first the part and then the drawing style.
Another difference between the C version and the MFC version is
that you must include the AFXCMN.H file, which defines the new
common control classes, in your STDAFX.H file. </p>

<p><tt>// The view class is defined as follows in MFCSTVW.H.<br>
<br>
class CMfcstatusView : public CView<br>
{<br>
protected: // create from serialization only<br>
CMfcstatusView ();<br>
DECLARE_DYNCREATE (CMfcstatusView);<br>
CStatus m_Status;<br>
<br>
// Attributes<br>
public:<br>
CMfcstatusDoc *GetDocument ();<br>
<br>
// Operations<br>
public:<br>
<br>
// Overrides<br>
// ClassWizard generated virtual function overrides.<br>
// {{AFX_VIRTUAL (CMfcstatusView)<br>
public:<br>
virtual void OnDraw (CDC *pDC); // overridden to draw <br>
// this view<br>
protected:<br>
// }}AFX_VIRTUAL<br>
<br>
// Implementation<br>
public:<br>
virtual ~CMfcstatusView ();<br>
#ifdef _DEBUG<br>
virtual void AssertValid () const;<br>
virtual void Dump (CDumpContext&amp; dc) const;<br>
#endif<br>
<br>
protected:<br>
<br>
// Generated message map functions<br>
protected:<br>
// {{AFX_MSG (CMfcstatusView)<br>
afx_msg int OnCreate (LPCREATESTRUCT lpCreateStruct);<br>
afx_msg void OnSimple ();<br>
afx_msg void OnMultiple ();<br>
afx_msg void OnSize (UINT nType, int cx, int cy);<br>
afx_msg void OnMouseMove (UINT nFlags, CPoint point);<br>
// }}AFX_MSG<br>
DECLARE_MESSAGE_MAP ()<br>
};<br>
<br>
<br>
<br>
// The status bar is created in MFCSTVW.CPP.<br>
<br>
int CMfcstatusView::OnCreate (LPCREATESTRUCT lpCreateStruct) <br>
{<br>
if (CView::OnCreate (lpCreateStruct) == -1)<br>
return -1;<br>
<br>
// Create the status bar.<br>
m_Status.Create (WS_CHILD | WS_BORDER | WS_VISIBLE |
SBARS_SIZEGRIP, <br>
Crect (0, 0, 0, 0),<br>
this,<br>
ID_STATUSBAR);<br>
<br>
int aWidths [4] = {0, 0, 0, 0};<br>
// Set the status bar to have four parts.<br>
m_Status.SetParts (4, aWidths);<br>
// Set the text in the first part to normal.<br>
m_Status.SetText ((LPCTSTR)&quot;Mouse position:&quot;, 0, 0);<br>
// Set the text in the second part to pop out.<br>
m_Status.SetText ((LPCTSTR)&quot;This text pops out.&quot;, 1,
SBT_POPOUT);<br>
// Set the text in the third part to have no borders.<br>
m_Status.SetText ((LPCTSTR)&quot;This text has no borders.&quot;,
2,<br>
SBT_NOBORDERS);<br>
// Set the fourth part to be owner-drawn.<br>
m_Status.SetText ((LPCTSTR)&quot;&quot;, 3, SBT_OWNERDRAW);<br>
return 0;<br>
}</tt> </p>

<p>Sizing the status bar window and its parts isn't difficult.
It's simply a matter of handling the WM_SIZE message, moving the
status bar window, and setting the endpoints for the parts in the
status bar. Following is the C code I used; I leave the MFC code
as an exercise for you. </p>

<p><tt>case WM_SIZE:<br>
// Resize the status bar to fit along the bottom of the client
area.<br>
MoveWindow (hWndStatus, 0, HIWORD(lParam) - 10, LOWORD(lParam),<br>
HIWORD(lParam), TRUE);<br>
// Set the rectangles for the multiple parts of the status bar.<br>
// Make each part 1/4 of the width of the client area.<br>
aWidths [0] = LOWORD(lParam) / 4;<br>
aWidths [1] = LOWORD(lParam) / 2;<br>
aWidths [2] = LOWORD(lParam) - aWidths [0];<br>
aWidths [3] = -1;<br>
SendMessage (hWndStatus, SB_SETPARTS, 4, (LPARAM)aWidths);<br>
break;</tt> </p>
</body>
</html>
