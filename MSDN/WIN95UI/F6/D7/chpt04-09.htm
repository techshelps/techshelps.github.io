<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">
<meta name="GENERATOR" content="Microsoft FrontPage 2.0">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Creating a Wizard</title>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>

<BODY bgcolor="#FFFFFF">


<h2>Creating a Wizard</h2>

<p>I created the WIZARD sample in C to demonstrate how to
manipulate wizard controls. (A version of this program also
appears in the Win32 SDK.) The design goals for this sample were
simple: first, to create a wizard in which you can step back and
forth; and second, to make it fun. The second goal was the
hardest. After a lot of thought, an inspiration finally came to
me. So if you'll indulge me in a little &#147;company&#148;
humor, let's get started. </p>

<p>Twice a year, each Microsoft employee participates in a
performance review, evaluating our sterling accomplishments of
the past six months, explaining how important we are to the
success of the company, and listing all the reasons why we
deserve a raise. Every time reviews roll around, we complain
about having to do the paperwork, and every time I wonder why
someone hasn't created a cool tool that would generate a
performance review, given some basic data. So I decided to write
a wizard to help with this sometimes painful exercise. In
reality, of course, it ended up being used for nothing more than
chuckles around here, but at least it made the sample a bit more
fun. </p>

<p>The first step in creating any wizard is to create a dialog
box for each page of information you want to collect. You can do
this with the same resource editor you use for standard dialog
boxes. For a wizard page, however, you should remove the OK and
Cancel buttons that are included in the default dialog template. </p>

<p>After you've created the dialog boxes, you must write code
that will first fill out a PROPSHEETPAGE structure for each page
(dialog box) you plan to display and will then fill out a
PROPSHEETHEADER structure for the overall property sheet. The <i>dwFlags</i>
field of the PROPSHEETHEADER structure must include the
PSH_WIZARD flag to specify that this particular property sheet is
a wizard. Finally, the application must call the PropertySheet
function. The following code demonstrates how to fill out these
structures to create a wizard: </p>

<p><tt>// FUNCTION: FillInPropertyPage (PROPSHEETPAGE *, int,
LPSTR, LPFN) <br>
//<br>
// PURPOSE: Fills out the given PROPSHEETPAGE structure<br>
//<br>
// COMMENTS:<br>
// This function fills out a PROPSHEETPAGE structure with the<br>
// information the system needs to create the page.<br>
<br>
void FillInPropertyPage (PROPSHEETPAGE *psp, int idDlg, LPSTR
pszProc,<br>
DLGPROC pfnDlgProc)<br>
{<br>
// Set the size of this structure.<br>
psp-&gt;dwSize = sizeof (PROPSHEETPAGE);<br>
// No special flags<br>
psp-&gt;dwFlags = 0;<br>
// The instance associated with this application<br>
psp-&gt;hInstance = rvInfo.hInst;<br>
// The dialog template to use<br>
psp-&gt;pszTemplate = MAKEINTRESOURCE (idDlg);<br>
// Don't use a special icon in the caption.<br>
psp-&gt;pszIcon = NULL;<br>
// The dialog procedure that handles this page<br>
psp-&gt;pfnDlgProc = pfnDlgProc;<br>
// The title for this page<br>
psp-&gt;pszTitle = pszProc;<br>
// No special application-specific data<br>
psp-&gt;lParam = 0;<br>
}<br>
<br>
// FUNCTION: CreateWizard (HWND)<br>
//<br>
// PURPOSE: Creates the wizard control<br>
//<br>
// COMMENTS:<br>
// This function creates the wizard property sheet.<br>
<br>
int CreateWizard (HWND hwndOwner, HINSTANCE hInst)<br>
{<br>
PROPSHEETPAGE psp [NUM_PAGES];<br>
PROPSHEETHEADER psh;<br>
<br>
// For each page, fill out a PROPSHEETPAGE structure.<br>
FillInPropertyPage (&amp;psp[0], IDD_INFO, <br>
&quot;Your Information&quot;, YourInfo);<br>
FillInPropertyPage (&amp;psp[1], IDD_WORKHABITS, <br>
&quot;Work Habits&quot;, WorkHabits);<br>
FillInPropertyPage (&amp;psp[2], IDD_TEAMWORK, <br>
&quot;Team Work&quot;, TeamWork);<br>
FillInPropertyPage (&amp;psp[3], IDD_RELIABILITY, <br>
&quot;Reliability&quot;, Reliability);<br>
FillInPropertyPage (&amp;psp[4], IDD_GOALS, <br>
&quot;Attainment of Goals&quot;, Goals);<br>
FillInPropertyPage (&amp;psp[5], IDD_ADAPTATION, <br>
&quot;Adaptability to Change&quot;, Adaptation);<br>
<br>
// Fill in the size of the PROPSHEETHEADER structure.<br>
psh.dwSize = sizeof (PROPSHEETHEADER);<br>
// Specify a wizard property sheet with no Apply button.<br>
psh.dwFlags = PSH_PROPSHEETPAGE | PSH_WIZARD | PSH_NOAPPLYNOW;<br>
// Specify the parent window.<br>
psh.hwndParent = hwndOwner;<br>
// The caption for the wizard<br>
psh.pszCaption = (LPSTR)&quot;Review Wizard&quot;;<br>
// The number of pages in this wizard<br>
psh.nPages = sizeof (psp) / sizeof (PROPSHEETPAGE);<br>
// Point to the array of property sheet pages.<br>
psh.ppsp = (LPCPROPSHEETPAGE) &amp;psp;<br>
// Create and run the wizard.<br>
return PropertySheet (&amp;psh);<br>
}</tt> </p>

<p>Although the wizard control simplifies the task of creating a
wizard, it doesn't perform magic: you still have to do a lot
yourself. The preceding code simply fills out the structures and
calls the function to create and run the wizard. If you want
those dialog boxes to gather the data and use the information the
user enters, you need to do some work in your dialog procedures. </p>

<p>Each dialog function, as specified by the <i>pfnDlgProc</i>
member of the PROPSHEETPAGE<b> </b>structure, must process the
messages and notifications it receives. Property sheets rely
heavily on notifications, packaged as WM_NOTIFY messages. The
code used to trap the wizard notifications is similar to the code
used for standard property sheets. Three special notifications
are associated with wizards, however: </p>

<table border="1">
    <tr>
        <td valign="top">PSN_WIZBACK</td>
        <td valign="top">Sent to the property sheet page when the
        user clicks the Back button</td>
    </tr>
    <tr>
        <td valign="top">PSN_WIZNEXT</td>
        <td valign="top">Sent to the property sheet page when the
        user clicks the Next button</td>
    </tr>
    <tr>
        <td valign="top">PSN_WIZFINISH</td>
        <td valign="top">Sent to the property sheet page when the
        user clicks the Finish button</td>
    </tr>
</table>

<p>When these notifications are sent, the default action is to
advance to the next page or to move back to the previous page.
The application's notification handler can disallow either action
by setting the notification result to -1. But that's not all. </p>

<p>Let's say you want your wizard to branch to a specific page
depending on certain user input. For example, your wizard
installs a piece of software, and your application must prompt
for extra information depending on whether the user prefers a
standard setup or a custom setup. The default behavior is to
display the next page in the array of property sheet pages. But
you can override that behavior and branch to a specific page by
setting the notification result to the ID of the page you
need&#151;think of it as a visual GOTO. Your application could by
default display the pages for custom setup in order, but it could
branch past those pages if the user wants a standard setup. </p>
</body>
</html>
