<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">
<meta name="GENERATOR" content="Microsoft FrontPage 2.0">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Character Formatting</title>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>

<BODY bgcolor="#FFFFFF">


<h1><font size="5">Character Formatting</font></h1>

<p>You can apply character formatting to text in a rich edit
control by using the EM_SETCHARFORMAT message. To determine the
current formatting of selected characters, use the
EM_GETCHARFORMAT message. With either message, the application
uses a pointer to the CHARFORMAT structure to specify character
attributes. The following attributes are supported for
characters: </p>

<ul>
    <li>Effects such as boldface, italics, and underlining </li>
    <li>Typeface (also known as <i>facename</i>) </li>
    <li>Point size </li>
    <li>Color </li>
</ul>

<p>Setting the effects is simply a matter of filling out the
CHARFORMAT structure with the size of the structure (for
versioning), specifying which attribute to alter, and sending the
EM_SETCHARFORMAT message. In the RICHED sample, these effects are
toggled, so the handler checks the current effect and toggles it.
The code on the following page is the handler for the Bold
command. The only differences between this handler and the
handlers for italics and underlining are the <i>dwMask</i> field
(CFM_ITALIC for italics and CFM_UNDERLINE for underlining) and
the <i>dwEffects</i> field (CFE_ITALIC for italics and
CFE_UNDERLINE for underlining). </p>

<p><tt>void BoldCmd (HWND hWndRichEdit)<br>
{<br>
CHARFORMAT cf; <br>
<br>
// Fill out the CHARFORMAT structure to set character effects.<br>
cf.cbSize = sizeof (cf);<br>
cf.dwMask = CFM_BOLD;<br>
<br>
// Get the bold status.<br>
SendMessage (hWndRichEdit, EM_GETCHARFORMAT, TRUE,
(LPARAM)&amp;cf);<br>
<br>
// Toggle the bold effect.<br>
cf.dwEffects ^= CFE_BOLD;<br>
<br>
// Set the new bold status.<br>
SendMessage (hWndRichEdit, EM_SETCHARFORMAT, SCF_SELECTION,<br>
(LPARAM)&amp;cf);<br>
}</tt> </p>

<p>The default character formatting is applied to newly inserted
text only if the current selection is empty. Otherwise, the new
text assumes the character formatting of the text it replaces. If
the selection changes, the default character formatting changes
to match the first character in the new selection. </p>

<p>In the RICHED sample, the user can also pick a new typeface by
using one of the drop-down combo boxes on the toolbar, shown in
Figure 5-2. </p>

<p>&nbsp;</p>

<p><b>Figure 5-2.</b></p>

<p><img src="fig5-2.gif" width="483" height="323"></p>

<h4><i>The combo box displaying typeface choices.</i> </h4>

<p>When the user chooses a typeface from the list, the
application's ChangeFaceName function sends an EM_SETCHARFORMAT
message to change the typeface. This function preserves the
previous character effects (boldface, italics, and underlining). </p>

<p><tt>VOID ChangeFaceName (HWND hWndRichEdit, LPTSTR lpFaceName)<br>
{<br>
CHARFORMAT cf;<br>
<br>
// Fill out the CHARFORMAT structure to get the character
effects.<br>
cf.cbSize = sizeof (cf);<br>
cf.dwMask = CFM_ITALIC | CFM_BOLD | CFM_UNDERLINE;<br>
SendMessage (hWndRichEdit, EM_GETCHARFORMAT, TRUE,
(LPARAM)&amp;cf);<br>
<br>
// Include the mask to ask the rich edit control for the current<br>
// typeface.<br>
cf.dwMask |= CFM_FACE;<br>
<br>
// Set the new typeface, preserving the previous effects.<br>
strcpy (cf.szFaceName, lpFaceName);<br>
SendMessage (hWndRichEdit, EM_SETCHARFORMAT, SCF_SELECTION,<br>
(LPARAM)&amp;cf);<br>
}</tt> </p>

<p>You might be wondering how I filled in the font choices. Well,
like any smart developer, I looked for some sample code I could
use. In the Win32 SDK, I found a sample called TTFONTS, which
enumerates all the available fonts and allows the user to play
around with the fields in the TEXTMETRIC and LOGFONT structures.
I was able to use the font-enumerating code from TTFONTS and to
use the structure that was defined to hold font information: </p>

<p><tt>// Structure holding font information<br>
typedef struct tagArFonts<br>
{<br>
int nFonts;<br>
int cySpace;<br>
HDC hdc;<br>
LOGFONT *lf;<br>
TEXTMETRIC *tm;<br>
int *Type;<br>
} ARFONTS, *PARFONTS;</tt> </p>

<p>The code that begins on the following page uses the EnumFonts
function to get the number of fonts, allocates space for the font
information, and fills out a structure for each font found. The
only change I made was to add a filter for TrueType fonts
(because my sample supports only these fonts). Filtering for
TrueType fonts allowed me to make some assumptions about the font
that the user will choose. </p>

<p><tt>PARFONTS BuildFontList (HDC hdcIn, LPINT retnFaces)<br>
{<br>
nFaces = 0; // initialize global face count to 0<br>
hdcGlobal = hdcIn; // save HDC for callbacks<br>
<br>
// Count the number of typefaces.<br>
EnumFonts (hdcGlobal, NULL, (FONTENUMPROC)MyEnumCount,<br>
(LPARAM)&amp;nFaces);<br>
<br>
// Allocate the pointer to the array of ARFONTS structures.<br>
parFontsGlobal = (PARFONTS) LocalAlloc (<br>
LPTR, sizeof(ARFONTS) * (nFaces+1));<br>
<br>
// Step through all fonts again. For each one, fill out a LOGFONT<br>
// structure and a TEXTMETRIC structure.<br>
iFace = 0;<br>
EnumFonts (hdcGlobal, NULL, (FONTENUMPROC)MyEnumFaces,
(LPARAM)NULL);<br>
<br>
*retnFaces = nFaces;<br>
return parFontsGlobal;<br>
}<br>
<br>
int APIENTRY MyEnumFaces (<br>
LPLOGFONT lpLogFont,<br>
LPTEXTMETRIC lpTEXTMETRICs,<br>
DWORD fFontType,<br>
LPVOID lpData)<br>
{<br>
int nFonts;<br>
<br>
UNREFERENCED_PARAMETER (lpTEXTMETRICs);<br>
UNREFERENCED_PARAMETER (fFontType);<br>
UNREFERENCED_PARAMETER (lpData);<br>
<br>
if (fFontType &amp; TRUETYPE_FONTTYPE)<br>
{ <br>
nFonts = 0;<br>
EnumFonts (hdcGlobal, lpLogFont-&gt;lfFaceName, <br>
(FONTENUMPROC)MyEnumCount, (LPARAM)&amp;nFonts);<br>
<br>
parFontsGlobal[iFace].lf = (LPLOGFONT) LocalAlloc (LPTR, <br>
sizeof(LOGFONT) * nFonts);<br>
parFontsGlobal[iFace].tm = (LPTEXTMETRIC) LocalAlloc (LPTR,<br>
sizeof(TEXTMETRIC) * nFonts);<br>
parFontsGlobal[iFace].Type = (LPINT) LocalAlloc (LPTR, <br>
sizeof(int) * nFonts);<br>
<br>
if ((parFontsGlobal[iFace].lf == NULL) ||<br>
(parFontsGlobal[iFace].tm == NULL) ||<br>
(parFontsGlobal[iFace].Type == NULL)) <br>
{<br>
MessageBox (NULL, &quot;alloc failed&quot;, NULL, MB_OK);<br>
return FALSE;<br>
}<br>
<br>
parFontsGlobal[iFace].nFonts = nFonts;<br>
<br>
jFont = 0;<br>
EnumFonts (hdcGlobal, lpLogFont-&gt;lfFaceName, <br>
(FONTENUMPROC)MyEnumCopy, (LPARAM)NULL);<br>
iFace++;<br>
}<br>
<br>
return TRUE;<br>
}<br>
<br>
int APIENTRY MyEnumCount (<br>
LPLOGFONT lpLogFont,<br>
LPTEXTMETRIC lpTEXTMETRICs,<br>
DWORD fFontType,<br>
LPINT lpData)<br>
{<br>
UNREFERENCED_PARAMETER (lpLogFont);<br>
UNREFERENCED_PARAMETER (lpTEXTMETRICs);<br>
UNREFERENCED_PARAMETER (fFontType);<br>
<br>
if (fFontType &amp; TRUETYPE_FONTTYPE)<br>
(*lpData)++;<br>
return TRUE;<br>
}<br>
<br>
int APIENTRY MyEnumCopy (<br>
LPLOGFONT lpLogFont,<br>
LPTEXTMETRIC lpTEXTMETRICs,<br>
DWORD fFontType,<br>
LPVOID lpData)<br>
{<br>
LOGFONT *lplf;<br>
TEXTMETRIC *lptm;<br>
int *pType;<br>
<br>
UNREFERENCED_PARAMETER (lpData);<br>
<br>
if (fFontType &amp; TRUETYPE_FONTTYPE)<br>
{<br>
lplf = parFontsGlobal[iFace].lf;<br>
lptm = parFontsGlobal[iFace].tm;<br>
pType = parFontsGlobal[iFace].Type;<br>
<br>
lplf[jFont] = *lpLogFont;<br>
lptm[jFont] = *lpTEXTMETRICs;<br>
pType[jFont] = fFontType;<br>
<br>
jFont++;<br>
}<br>
return TRUE;<br>
}</tt> </p>

<p>When the structures are filled out, the names of the typefaces
are inserted in the typeface combo box. The point size combo box
is filled with an array of standard point sizes, as shown in
Figure 5-3. The same point sizes are listed for each typeface.
That's why I picked only TrueType fonts. Other kinds of fonts,
such as raster fonts, are device-dependent, and you cannot make
assumptions about their availability or about the point sizes
they support. For a &#147;real&#148; word processor, the point
size combo box can be filled dynamically when the user picks a
typeface. </p>

<p>To change the point size, you simply use the same
EM_SETCHARFORMAT message and specify the CFM_SIZE mask. Bear in
mind that the point size is represented internally as twips, so
you need to multiply the number the user chooses by 20. If you
don't do this, you'll end up getting really tiny letters. </p>

<p>&nbsp;</p>

<p><b>Figure 5-3.</b> </p>

<p><b><img src="fig5-3.gif" width="480" height="321"></b></p>

<h4><i>The combo box displaying the point size options.</i> </h4>

<p><tt>VOID ChangePointSize (HWND hWndRichEdit, int PointSize)<br>
{<br>
CHARFORMAT cf; <br>
<br>
// Fill out the CHARFORMAT structure to set the point size.<br>
cf.cbSize = sizeof (cf);<br>
cf.dwMask = CFM_SIZE;<br>
<br>
// Multiply by 20 to convert to twips.<br>
cf.yHeight = PointSize * 20;<br>
<br>
// Set the point size.<br>
SendMessage (hWndRichEdit, EM_SETCHARFORMAT, SCF_SELECTION,<br>
(LPARAM)&amp;cf);<br>
<br>
// Reset the dirty bit.<br>
SendMessage (hWndRichEdit, EM_SETMODIFY, (WPARAM)TRUE, OL);<br>
}</tt> </p>

<p>Notice in the RICHED sample that the appropriate toolbar
buttons appear &#147;pressed&#148; and the corresponding menu
items are checked when the user has chosen specific character
effects, as shown in Figure 5-4. The sample accomplishes this
task with a function called ToggleButton, which simply takes the
command identifier of the button and a Boolean to toggle the
button on and off. (The identifiers for the menu item and the
button are the same.) </p>

<p>&nbsp;</p>

<p><b>Figure 5-4.</b></p>

<p><b><img src="fig5-4.gif" width="481" height="322"></b></p>

<h4><i>Checked menu items and &#147;pressed&#148; toolbar buttons
indicating character effects.</i> </h4>

<p><tt>BOOL ToggleButton (HWND hWnd, int nID, BOOL bToggle)<br>
{<br>
if (bToggle)<br>
{ // Uncheck the menu item and unpress the toolbar button.<br>
CheckMenuItem (GetMenu(hWnd), nID, MF_BYCOMMAND | MF_UNCHECKED);<br>
SendMessage (hWndToolbar, TB_CHECKBUTTON, nID, MAKELONG (FALSE,
0));<br>
return FALSE;<br>
}<br>
else<br>
{ // Check the menu item and press the toolbar button.<br>
CheckMenuItem (GetMenu (hWnd), nID, MF_BYCOMMAND | MF_CHECKED);<br>
SendMessage (hWndToolbar, TB_CHECKBUTTON, nID, MAKELONG (TRUE,
0));<br>
return TRUE;<br>
}<br>
}</tt> </p>

<p>I did not implement the protected attribute or the color
attribute in the RICHED sample. The protected character attribute
allows the application to specify some text as read-only (without
changing the appearance of the text by graying it out). If the
user tries to modify protected text, the rich edit control sends
its parent window an EN_PROTECTED notification, allowing the
parent window to permit or prevent the change. This is useful for
an application that lets the user change only specific items in a
rich edit control, based on a password. To receive this
notification, the application enables it by using the
EM_SETEVENTMASK message, specifying ENM_PROTECTED. </p>

<p>The foreground color of a rich edit control is also a
character attribute, but the background color is a property of
the control. To set the background color, an application sends
the EM_SETBKGNDCOLOR message. To set the foreground color, the
application fills out the CHARFORMAT structure, specifying the
CFM_COLOR attribute. </p>
</body>
</html>
