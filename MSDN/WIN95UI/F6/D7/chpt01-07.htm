<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">
<meta name="GENERATOR" content="Microsoft FrontPage 2.0">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Using Owner Drawing in a Status Bar</title>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>

<BODY bgcolor="#FFFFFF">


<h2>Using Owner Drawing in a Status Bar</h2>

<p>Status bars are great for displaying text, but what if you
want to put a bitmap in your status bar, as Microsoft Mail does?
Using the Win32 API, you can add a bitmap by taking advantage of
the control's support for owner drawing. Owner drawing lets you
display a bitmap instead of text (or use a different font) in a
section of a status bar. In the code you just saw, you send the
SB_SETTEXT message with the SBT_OWNERDRAW drawing style specified
to tell the system that a part of your status bar should be
owner-drawn. The <i>lParam</i> parameter is a 32-bit,
application-defined value that the application can use when
drawing that part of the status bar (that is, you can pass a
bitmap handle in this parameter if you like). At this point, you
treat the control like any other owner-drawn control: you handle
the WM_DRAWITEM message and then use the information in the
DRAWITEMSTRUCT structure that is passed along. The following code
demonstrates how I did this in the STATUS sample: </p>

<p><tt>case WM_DRAWITEM:<br>
if ((int)wParam == ID_STATUSBAR)<br>
{<br>
LPDRAWITEMSTRUCT lpDis;<br>
HDC hdcMem;<br>
HBITMAP hbmOld;<br>
BITMAP bm;<br>
<br>
// Save the drawing information. This information is specific<br>
// to the part of the status bar to be drawn.<br>
lpDis = (LPDRAWITEMSTRUCT)lParam;<br>
// Create a compatible device context (DC) for the bit block <br>
// transfer (bitblt).<br>
hdcMem = CreateCompatibleDC (lpDis-&gt;hDC);<br>
// Select the bitmap into the DC.<br>
hbmOld = SelectObject (hdcMem, hBmp);<br>
// Get the information about the bitmap's size.<br>
GetObject (hBmp, sizeof (bm), &amp;bm);<br>
// Use BitBlt to transfer the bitmap to the part.<br>
BitBlt (lpDis-&gt;hDC, lpDis-&gt;rcItem.left,
lpDis-&gt;rcItem.top, <br>
bm.bmWidth, bm.bmHeight, hdcMem, 0, 0, SRCCOPY);<br>
// Reselect the original object into the DC.<br>
SelectObject (hdcMem, hbmOld);<br>
// Delete the compatible DC.<br>
DeleteDC (hdcMem);<br>
}<br>
break;</tt> </p>

<p>Some clever readers will notice that I call the BitBlt
function to transfer a bitmap but that this bitmap is not drawn
transparently. I cheated a bit by drawing the background as the
standard gray used in most status bars. If someone were to change
the color of the status bar, this little cheat would show. </p>

<p>The code in my MFC version of this sample looks strikingly
familiar; however, I ran into a big &#147;gotcha&#148; when I
ported this portion of the code. In short, the MFC class that is
provided demands that you override the DrawItem method of the
CStatusBarCtrl class in order to use the owner-drawn capabilities
of the status bar. Initially, I just handled the WM_DRAWITEM
message in the view, and the bitmap and the status bar drew
correctly. But I kept getting these pesky ASSERT messages. When I
tracked down the problem, I was annoyed, to say the least. To
remedy the situation, I used ClassWizard to create a class based
on CStatusBarCtrl and handled the DrawItem method myself. The MFC
sample uses the following code to draw its bitmap on the status
bar: </p>

<p><tt>// CStatus message handlers<br>
<br>
void CStatus::DrawItem (LPDRAWITEMSTRUCT lpDrawItemStruct)<br>
{<br>
static HBITMAP m_Bmp;<br>
<br>
if (m_Bmp == NULL)<br>
// Load the bitmap for the owner-drawn part of the status bar.<br>
m_Bmp = ::LoadBitmap (AfxGetResourceHandle (), <br>
MAKEINTRESOURCE (ID_BITMAP));<br>
// Create a compatible DC for the bit block transfer.<br>
HDC hdcMem = ::CreateCompatibleDC (lpDrawItemStruct-&gt;hDC);<br>
// Select the bitmap into the DC.<br>
HBITMAP hbmOld = (HBITMAP) ::SelectObject (hdcMem,
(HBITMAP)m_Bmp);<br>
<br>
BITMAP bm;<br>
// Get the information about the bitmap's size.<br>
::GetObject ((HBITMAP)m_Bmp, sizeof (bm), &amp;bm);<br>
// Use BitBlt to transfer the bitmap.<br>
::BitBlt (lpDrawItemStruct-&gt;hDC, <br>
lpDrawItemStruct-&gt;rcItem.left, <br>
lpDrawItemStruct-&gt;rcItem.top, <br>
bm.bmWidth, <br>
bm.bmHeight, <br>
hdcMem, 0, 0,<br>
SRCCOPY);<br>
// Reselect the original bitmap.<br>
::SelectObject (hdcMem, hbmOld);<br>
// Delete the compatible DC.<br>
::DeleteDC (hdcMem);<br>
}</tt> </p>
</body>
</html>
