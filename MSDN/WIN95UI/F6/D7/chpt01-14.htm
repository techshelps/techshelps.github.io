<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">
<meta name="GENERATOR" content="Microsoft FrontPage 2.0">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Adding a ToolTip to a Nonbutton Control</title>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>

<BODY bgcolor="#FFFFFF">


<h1><font size="5">Adding a ToolTip to a Nonbutton Control</font></h1>

<p>If your toolbar contains a nonbutton control, you have to do a
bit more work to support ToolTips. In my sample, I created a
combo box and then parented it to the toolbar. To add a ToolTip
to this control, the application must send the TTM_ADDTOOL
message to the ToolTip control (or use the MFC AddTool member
function). It also needs to trap the WM_MOUSEMOVE,
WM_LBUTTONDOWN, and WM_LBUTTONUP messages in the window procedure
for the combo box and pass these on to the ToolTip control so
that it will know to pop up the ToolTip for the combo box. The
following C code demonstrates these steps: </p>

<p><tt>// This code is in the main window procedure after the
combo box<br>
// has been created.<br>
// Set the window procedure for the combo box.<br>
lpfnDefCombo = (WNDPROC) GetWindowLong (hWndCombo, GWL_WNDPROC);<br>
SetWindowLong (hWndCombo, GWL_WNDPROC, (LONG)ComboWndProc);<br>
<br>
// Get the handle to the ToolTip window.<br>
hWndTT = (HWND) SendMessage (hWndToolbar, TB_GETTOOLTIPS, 0, 0);<br>
<br>
if (hWndTT)<br>
{<br>
// Fill out the TOOLINFO structure.<br>
lpToolInfo.cbSize = sizeof (lpToolInfo);<br>
// The uID is the handle of the tool (the combo box).<br>
lpToolInfo.uFlags = TTF_IDISHWND | TTF_CENTERTIP;<br>
// The string ID in the resource<br>
lpToolInfo.lpszText = (LPSTR)IDM_COMBO;<br>
// The window that gets the ToolTip messages<br>
lpToolInfo.hwnd = hWnd;<br>
// The tool<br>
lpToolInfo.uId = (UINT)hWndCombo;<br>
// The instance that owns the string resource<br>
lpToolInfo.hinst = hInst;<br>
<br>
// Set up the ToolTip for the combo box.<br>
SendMessage (hWndTT, TTM_ADDTOOL, 0,<br>
(LPARAM)(LPTOOLINFO)&amp;lpToolInfo);<br>
}<br>
§<br>
<br>
// This function relays the mouse messages from the combo box<br>
// to get the ToolTip to work.<br>
LRESULT CALLBACK ComboWndProc (HWND hWnd, UINT uMessage, WPARAM
wParam, <br>
LPARAM lParam)<br>
{<br>
switch (uMessage)<br>
{<br>
case WM_MOUSEMOVE:<br>
case WM_LBUTTONDOWN:<br>
case WM_LBUTTONUP:<br>
{<br>
MSG msg;<br>
HWND hWndTT;<br>
msg.lParam = lParam;<br>
msg.wParam = wParam;<br>
msg.message = uMessage;<br>
msg.hwnd = hWnd;<br>
hWndTT = (HWND) SendMessage (hWndToolbar, TB_GETTOOLTIPS, 0, 0);<br>
SendMessage (hWndTT, TTM_RELAYEVENT, 0, (LPARAM)(LPMSG)&amp;msg);<br>
break;<br>
}<br>
}<br>
return CallWindowProc (lpfnDefCombo, hWnd, uMessage, wParam,
lParam);<br>
}</tt> </p>

<p>The corresponding MFC procedure is similar. One change I made
was to create a class for my combo-box control derived from
CComboBox and use ClassWizard to create a message map to
WindowProc. Within this function, I did the same type of
processing&#151;except that it was less tedious to fill out the
message structure. Instead, I was able to call
CWnd::GetCurrentMessage. </p>
</body>
</html>
