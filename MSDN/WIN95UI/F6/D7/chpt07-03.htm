<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">
<meta name="GENERATOR" content="Microsoft FrontPage 2.0">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Creating the Windows</title>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>

<BODY bgcolor="#FFFFFF">


<h1><font size="5">Creating the Windows</font></h1>

<p>To set up the basic windows for my application, I wrote a
function to call the worker functions that actually create the
windows. Because these windows are part of the new Windows 95
common control library, I first had to call InitCommonControls to
ensure that COMCTL32.DLL was loaded. </p>

<p>My first control was a multiple-part status bar. The left
section of the status bar displays the currently selected city,
and the right section displays the number of houses listed for
that city. The following code demonstrates how the status bar is
implemented: </p>

<p><tt>g_Listing.hWndStatus = CreateStatusWindow ( <br>
WS_CHILD | WS_BORDER | WS_VISIBLE, // window styles<br>
&quot;&quot;, // default window text<br>
hwndParent, // parent window<br>
ID_STATUS); // ID<br>
<br>
if (g_Listing.hWndStatus == NULL)<br>
MessageBox (NULL, &#147;Status Bar not created!&#148;, NULL,
MB_OK);<br>
<br>
// Set the status bar to have two parts.<br>
lpSBParts [0] = (rcl.right - rcl.left) / 2;<br>
lpSBParts [1] = -1;<br>
SendMessage (g_Listing.hWndStatus, SB_SETPARTS, (WPARAM)2, <br>
(LPARAM)&amp;lpSBParts);</tt> </p>

<p>Next I created the toolbar, using the TB_ADDBITMAP message to
add built-in bitmaps for the standard file and view operations.
This code fills out the TBBUTTON structure with the predefined
bitmap indexes: </p>

<p><tt>// Toolbar buttons<br>
TBBUTTON tbButtons [] = <br>
{<br>
{STD_FILENEW, IDM_NEW, TBSTATE_ENABLED, TBSTYLE_BUTTON, 0L, 0},<br>
{STD_FILEOPEN, IDM_OPEN, TBSTATE_ENABLED, TBSTYLE_BUTTON, 0L, 0},<br>
{STD_FILESAVE, IDM_SAVE, TBSTATE_ENABLED, TBSTYLE_BUTTON, 0L, 0},<br>
{0, 0, TBSTATE_ENABLED, TBSTYLE_SEP, 0L, 0},<br>
{VIEW_LARGEICONS, IDM_LARGEICON, TBSTATE_ENABLED, TBSTYLE_BUTTON,
<br>
0L, 0},<br>
{VIEW_SMALLICONS, IDM_SMALLICON, TBSTATE_ENABLED, TBSTYLE_BUTTON,
<br>
0L, 0},<br>
{VIEW_LIST, IDM_LISTVIEW, TBSTATE_ENABLED, TBSTYLE_BUTTON, 0L,
0},<br>
{VIEW_DETAILS, IDM_REPORTVIEW, TBSTATE_ENABLED, TBSTYLE_BUTTON, <br>
0L, 0},<br>
};</tt> </p>

<p><tt>This piece of code creates the toolbar, as you saw
earlier, in Chapter 1:</tt> </p>

<p><tt>HWND CreateTheToolbar (HWND hWndParent)<br>
{<br>
HWND hWndToolbar;<br>
TBADDBITMAP tb;<br>
int index, stdidx;<br>
<br>
hWndToolbar = CreateToolbarEx (hWndParent, <br>
WS_CHILD | WS_BORDER | WS_VISIBLE | WS_CHILD | TBSTYLE_TOOLTIPS, <br>
ID_TOOLBAR, 11, (HINSTANCE)HINST_COMMCTRL, IDB_STD_SMALL_COLOR, <br>
(LPCTBBUTTON)&amp;tbButtons, 4, 0, 0, 100, 30, sizeof
(TBBUTTON));<br>
<br>
// Add the system-defined view bitmaps.<br>
// The hInst == HINST_COMMCTRL<br>
// The nID == IDB_VIEW_SMALL_COLOR<br>
tb.hInst = HINST_COMMCTRL;<br>
tb.nID = IDB_VIEW_SMALL_COLOR;<br>
stdidx = SendMessage (hWndToolbar, TB_ADDBITMAP, 12,
(LPARAM)&amp;tb);<br>
<br>
// Update the indexes to the bitmaps.<br>
for (index = 4; index &lt; NUM_BUTTONS; index++)<br>
tbButtons[index].iBitmap += stdidx;<br>
<br>
// Add the view buttons.<br>
SendMessage (hWndToolbar, TB_ADDBUTTONS, 4, (LONG)
&amp;tbButtons[4]);<br>
<br>
return hWndToolbar;<br>
}</tt> </p>

<p>As my third step, I created the list view and tree view
windows, using helper functions. I made the tree view control
one-fourth the width of the window's client area and accounted
vertically for both the toolbar and the status bar, as you can
see in the following code. (Note that for this sample I
hard-coded the values that determine the size of the controls. If
I were writing an application for general consumption, I would
instead obtain these values by calling GetSystemMetrics.) </p>

<p><tt>HWND TV_CreateTreeView (HWND hWndParent, HINSTANCE hInst,
int NumCities, <br>
CITYINFO *pCity)<br>
{<br>
HWND hwndTree; // handle to tree view window<br>
RECT rcl; // rectangle for setting size of window<br>
HBITMAP hBmp; // handle to a bitmap<br>
HIMAGELIST hIml; // handle to image list<br>
<br>
// Get the size and position of the parent window.<br>
GetClientRect (hWndParent, &amp;rcl);<br>
<br>
// Create the tree view window, make it 1/4 the width of the
parent<br>
// window, and account for the status bar and the toolbar.<br>
hwndTree = CreateWindowEx (0L,<br>
WC_TREEVIEW, // window class<br>
&quot;&quot;, // no default text<br>
WS_VISIBLE | WS_CHILD | WS_BORDER | TVS_HASLINES | <br>
TVS_HASBUTTONS | TVS_LINESATROOT, | WS_EX_CLIENTEDGE,<br>
0, 27, // x, y<br>
(rcl.right - rcl.left) / 4, // cx<br>
rcl.bottom - rcl.top - 45, // cy <br>
hWndParent, // parent<br>
(HMENU)ID_TREEVIEW, // ID<br>
hInst, // instance<br>
NULL);<br>
<br>
if (hwndTree == NULL)<br>
{<br>
MessageBox (NULL, &#147;CreateWindow of TreeView failed!&#148;,
NULL, MB_OK);<br>
return NULL;<br>
}<br>
<br>
// First create the image list you will need.<br>
hIml = ImageList_Create (BITMAP_WIDTH, BITMAP_HEIGHT, FALSE, 2,
10);<br>
<br>
if (hIml == NULL)<br>
MessageBox (NULL, &#147;ImageList_Create failed!&#148;, NULL,
MB_OK);<br>
<br>
// Load the bitmaps and add them to the image list.<br>
hBmp = LoadBitmap (hInst, MAKEINTRESOURCE (FORSALE_BMP));<br>
idxForSale = ImageList_Add (hIml, hBmp, NULL);<br>
hBmp = LoadBitmap (hInst, MAKEINTRESOURCE (CITY_BMP));<br>
idxCity = ImageList_Add (hIml, hBmp, NULL);<br>
hBmp = LoadBitmap (hInst, MAKEINTRESOURCE (SELCITY_BMP));<br>
idxSelect = ImageList_Add (hIml, hBmp, NULL);<br>
<br>
// Be sure that all the bitmaps were added.<br>
if (ImageList_GetImageCount (hIml) != 3)<br>
{<br>
MessageBox (NULL, &#147;TreeView image list not loaded!&#148;,
NULL, MB_OK);<br>
return FALSE;<br>
}<br>
<br>
// Associate the image list with the tree view control.<br>
TreeView_SetImageList (hwndTree, hIml, idxForSale);<br>
<br>
// Initialize the tree view control by adding &quot;Houses For
Sale.&quot;<br>
TV_InitTreeView (hInst, hwndTree);<br>
<br>
return hwndTree;<br>
}</tt> </p>

<p>I created the list view window, made it three-fourths the
width of the parent window's client area, placed it on the right
side of the area, and accounted vertically for the toolbar and
the status bar, using this code: </p>

<p><tt>HWND LV_CreateListView (HWND hWndParent, HINSTANCE hInst,
int NumHouses,<br>
HOUSEINFO *pHouse)<br>
{<br>
HWND hWndList; // handle to list view window<br>
RECT rcl; // rectangle for setting size of window<br>
HICON hIcon; // handle to an icon<br>
int index; // index used in for loops<br>
HIMAGELIST hSmall, hLarge; // handles to image lists<br>
LV_COLUMN lvC; // list view column structure<br>
char szText [MAX_ITEMLEN]; // place to store some text<br>
int iWidth; // column width<br>
<br>
// Get the size and position of the parent window.<br>
GetClientRect (hWndParent, &amp;rcl);<br>
<br>
iWidth = (rcl.right - rcl.left) - ((rcl.right - rcl.left) / 4);<br>
<br>
// Create the list view window, make it 3/4 the width of the<br>
// parent window, and account for the status bar and the toolbar.<br>
hWndList = CreateWindowEx (0L,<br>
WC_LISTVIEW, // list view class<br>
&quot;&quot;, // no default text<br>
WS_VISIBLE | WS_CHILD | WS_BORDER | LVS_REPORT |
WS_EX_CLIENTEDGE, <br>
(rcl.right - rcl.left) / 4, 27, // x, y<br>
iWidth, rcl.bottom - rcl.top - 42, // cx, cy<br>
hWndParent, // parent<br>
(HMENU)ID_LISTVIEW, // ID<br>
hInst, // instance<br>
NULL);<br>
<br>
if (hWndList == NULL )<br>
return NULL;<br>
<br>
// First initialize the image lists you will need.<br>
// Create image lists for the small and the large icons.<br>
// TRUE specifies small icons; FALSE specifies large.<br>
hSmall = ImageList_Create (BITMAP_WIDTH, BITMAP_HEIGHT, TRUE, 1,
0);<br>
hLarge = ImageList_Create (LG_BITMAP_WIDTH, LG_BITMAP_HEIGHT,
FALSE, <br>
1, 0);<br>
<br>
// Load the icons and add them to the image lists.<br>
hIcon = LoadIcon (hInst, MAKEINTRESOURCE (HOUSE_ICON));<br>
if ((ImageList_AddIcon (hSmall, hIcon) == -1) ||<br>
(ImageList_AddIcon (hLarge, hIcon) == -1))<br>
{<br>
MessageBox (NULL, &quot;ImageList_AddIcon failed!&#148;, NULL,
MB_OK);<br>
return NULL;<br>
}<br>
<br>
// Associate the image lists with the list view control.<br>
ListView_SetImageList (hWndList, hSmall, LVSIL_SMALL);<br>
ListView_SetImageList (hWndList, hLarge, LVSIL_NORMAL);<br>
<br>
// Initialize the LV_COLUMN structure.<br>
// The mask specifies that the fmt, cx, pszText, and iSubitem <br>
// members of the structure are valid.<br>
lvC.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;<br>
lvC.fmt = LVCFMT_LEFT; // left-align column<br>
lvC.cx = iWidth / NUM_COLUMNS + 1; // width of column in pixels<br>
lvC.pszText = szText;<br>
<br>
// Add the columns.<br>
for (index = 0; index &lt; NUM_COLUMNS; index++)<br>
{<br>
lvC.iSubItem = index;<br>
LoadString (hInst, <br>
IDS_ADDRESS + index,<br>
szText,<br>
sizeof (szText));<br>
if (ListView_InsertColumn (hWndList, index, &amp;lvC) == -1)<br>
return NULL;<br>
}<br>
return hWndList;<br>
}</tt> </p>
</body>
</html>
