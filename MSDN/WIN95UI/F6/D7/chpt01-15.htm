<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">
<meta name="GENERATOR" content="Microsoft FrontPage 2.0">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Customizing a Toolbar</title>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>

<BODY bgcolor="#FFFFFF">


<h2>Customizing a Toolbar</h2>

<p>You can support toolbar customization if you create your
toolbar with the CCS_ADJUSTABLE style. The customization features
allow the user to drag a button to a new position or to remove a
button by dragging it off the toolbar. In addition, the user can
double-click the toolbar to display the Customize Toolbar dialog
box, which makes it easy to add, delete, and rearrange toolbar
buttons. An application can display the dialog box by using the
TB_CUSTOMIZE message (or MFC's Customize member function) in
response to a double-click on the toolbar. </p>

<p>Handling toolbar customization in your application involves
handling various notifications that are sent through the
WM_NOTIFY message. In my sample application, I decided to support
the following: </p>

<ul>
    <li>Allowing the user to delete buttons. This is easily done
        by simply responding TRUE to the TBN_QUERYDELETE
        notification. </li>
    <li>Allowing the user to add buttons. Here again, I respond
        TRUE to the TBN_QUERYINSERT notification. </li>
    <li>Displaying customized Help. In response to the
        TBN_CUSTHELP notification, a message box appears, saying
        that the user is now seeing custom Help. You, of course,
        would add displays of more substance to your application.
    </li>
    <li>Resizing the toolbar by autosizing it in response to the
        TBN_TOOLBARCHANGE notification. </li>
</ul>

<p>The following code from the MFCTOOL sample demonstrates how
you can support minimal customization: </p>

<p><tt>LRESULT CMfctoolView::WindowProc (UINT message, WPARAM
wParam, <br>
LPARAM lParam) <br>
{<br>
static CHAR szBuf [128];<br>
LPTOOLTIPTEXT lpToolTipText;<br>
</tt></p>

<p><tt>if (message == WM_NOTIFY)<br>
{<br>
switch (((LPNMHDR)lParam)-&gt;code) <br>
{<br>
case TTN_NEEDTEXT: <br>
// Display the ToolTip text.<br>
lpToolTipText = (LPTOOLTIPTEXT)lParam;<br>
::LoadString (AfxGetResourceHandle (),<br>
lpToolTipText-&gt;hdr.idFrom, // string ID == cmd ID<br>
szBuf,<br>
sizeof (szBuf));<br>
lpToolTipText-&gt;lpszText = szBuf;<br>
break;<br>
<br>
case TBN_QUERYDELETE:<br>
// Toolbar customization--can we delete this button?<br>
return TRUE;<br>
break;<br>
<br>
case TBN_GETBUTTONINFO:<br>
// The toolbar needs information about a button.<br>
return FALSE;<br>
break;<br>
<br>
case TBN_QUERYINSERT:<br>
// Can this button be inserted? Just say yo.<br>
return TRUE;<br>
break;<br>
<br>
case TBN_CUSTHELP:<br>
// Need to display custom Help.<br>
AfxMessageBox (&quot;This Help is custom.&quot;);<br>
break;<br>
<br>
case TBN_TOOLBARCHANGE:<br>
// The user finished dragging a bitmap to the toolbar.<br>
m_ToolBar.AutoSize ();<br>
break;<br>
<br>
default:<br>
return TRUE;<br>
break;<br>
}<br>
}<br>
return CView::WindowProc (message, wParam, lParam);<br>
}</tt> </p>

<p>If you want to have more control over customization, your
application can handle many other notifications that I did not
include in my sample. For instance, if you want to do your own
button dragging, you can trap the TBN_BEGINDRAG and TBN_ENDDRAG
notifications. You might also want to save the state of the
toolbar and allow the user to reset its configuration. You can do
this by using the TB_SAVERESTORE message to save the current
state of the toolbar and waiting for a TBN_RESET notification to
signal that the toolbar needs to be reset to its previous state. </p>
</body>
</html>
