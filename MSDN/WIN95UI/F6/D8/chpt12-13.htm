<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">
<meta name="GENERATOR" content="Microsoft FrontPage 2.0">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Step Six: Implement the IFileViewer Interface</title>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>

<BODY bgcolor="#FFFFFF">


<h3>Step Six: Implement the IFileViewer Interface</h3>

<p>To implement the IFileViewer interface, the file viewer must
implement the three member functions FileShowInitialize,
FileShow, and PrintTo. </p>

<h4>FileShowInitialize</h4>

<p>This is a pre-show function. It allows a file viewer to
determine whether it can display a file and, if it can, to
perform the necessary initialization operations. The system calls
FileShowInitialize before calling IFileViewer::Show.
FileShowInitialize must perform all operations that are prone to
failure; if it succeeds, IFileViewer::Show will not fail. The
system specifies the name of the file that will be displayed by
calling the file viewer's IPersistFile::Load member function.
This function returns NOERROR if it is successful; otherwise, it
returns an OLE-defined error value. In my file viewer, this
function calls AddRef, creates the windows it needs, loads the
file, stores the filename, and returns the error status. </p>

<p><tt>STDMETHODIMP CFileView::XFileViewer::ShowInitialize ( <br>
LPFILEVIEWERSITE lpfsi)<br>
{<br>
METHOD_PROLOGUE (CFileView, FileViewer);<br>
TRACE (&quot;CFileView::XFileViewer::ShowInitialize\n&quot;);<br>
<br>
HRESULT hr;<br>
<br>
// Be sure that you have the file viewer.<br>
if (pThis-&gt;m_lpfsi != lpfsi)<br>
{<br>
pThis-&gt;m_lpfsi = lpfsi;<br>
pThis-&gt;m_lpfsi-&gt;AddRef ();<br>
}<br>
<br>
// Default error code<br>
hr = E_OUTOFMEMORY;<br>
<br>
// Create the windows.<br>
pThis-&gt;m_Wnd = new CMyFrame;<br>
pThis-&gt;m_Wnd-&gt;Create ();<br>
<br>
// Load a file.<br>
HGLOBAL hMem=NULL;<br>
char szwFile [512];<br>
<br>
if (pThis-&gt;m_pszPath == NULL)<br>
return E_UNEXPECTED;<br>
<br>
// This file viewer is registered for a TXT extension that<br>
// is either in a compound file (a single stream called
&quot;Text&quot;)<br>
// or in a flat text file. This sample shows<br>
// how to open and work with both types of files.<br>
<br>
// Make a Unicode copy of the filename.<br>
mbstowcs ((USHORT *)szwFile, pThis-&gt;m_pszPath, sizeof
(szwFile));<br>
<br>
// CAREFUL: StgIsStorageFile returns S_FALSE if the file doesn't<br>
// contain an IStorage object. Don't use SUCCEEDED to test the <br>
// return value!<br>
if (StgIsStorageFile (szwFile) == NOERROR)<br>
{<br>
LPSTORAGE pIStorage = NULL;<br>
LPSTREAM pIStream = NULL;<br>
STATSTG stat;<br>
<br>
// It is a compound file; open it and the text stream.<br>
hr = StgOpenStorage (szwFile, NULL, pThis-&gt;m_grfMode, NULL, 0,<br>
&amp;pIStorage);<br>
<br>
if (FAILED (hr))<br>
return hr;<br>
<br>
mbstowcs ((USHORT *)szwFile, &quot;Text&quot;, sizeof (szwFile));<br>
<br>
hr = pIStorage-&gt;OpenStream (szwFile, 0,<br>
STGM_DIRECT | STGM_READ | STGM_SHARE_EXCLUSIVE, 0,
&amp;pIStream);<br>
<br>
if (SUCCEEDED (hr))<br>
{<br>
// Determine the amount of text and allocate memory.<br>
hr = pIStream-&gt;Stat (&amp;stat, STATFLAG_NONAME);<br>
<br>
if (SUCCEEDED (hr))<br>
{<br>
hMem = (HGLOBAL) malloc (stat.cbSize.LowPart + 1);<br>
<br>
if (hMem != NULL)<br>
// Now load the text into the controls.<br>
hr = pIStream-&gt;Read ((LPVOID)hMem, stat.cbSize.LowPart, <br>
NULL);<br>
else<br>
hr = E_OUTOFMEMORY;<br>
}<br>
pIStream-&gt;Release ();<br>
}<br>
pIStorage-&gt;Release ();<br>
}<br>
<br>
else<br>
{<br>
HANDLE hFile;<br>
DWORD dwFileSize, dwBytesRead;<br>
char *lpBufPtr;<br>
<br>
// Open the text file.<br>
if ((hFile = CreateFile (pThis-&gt;m_pszPath,<br>
GENERIC_READ,<br>
FILE_SHARE_READ,<br>
NULL,<br>
OPEN_EXISTING,<br>
FILE_ATTRIBUTE_NORMAL,<br>
(HANDLE)NULL)) == (HANDLE)(-1))<br>
{<br>
AfxMessageBox (&quot;Failed to open file&quot;);<br>
return STG_E_FILENOTFOUND;<br>
}<br>
<br>
// Get the size of the file.<br>
dwFileSize = GetFileSize (hFile, NULL);<br>
if (dwFileSize == 0xFFFFFFFF)<br>
return STG_E_READFAULT;<br>
<br>
// Allocate a buffer into which the file will be read.<br>
lpBufPtr = (char *) malloc (dwFileSize);<br>
if (lpBufPtr == NULL)<br>
{<br>
CloseHandle (hFile);<br>
return STG_E_READFAULT;<br>
}<br>
<br>
// Read the file contents into a buffer.<br>
ReadFile (hFile, (LPVOID)lpBufPtr, dwFileSize, &amp;dwBytesRead,
NULL);<br>
<br>
// Update the multiline edit control with the file contents.<br>
pThis-&gt;m_Wnd-&gt;UpdateEdit (lpBufPtr);<br>
<br>
// Close the file.<br>
CloseHandle (hFile);<br>
}<br>
<br>
// Tell IFileViewer::Show it's OK to call it.<br>
pThis-&gt;m_fShowInit = TRUE;<br>
<br>
return NOERROR;<br>
}</tt> </p>

<h4>FileShow</h4>

<p>This function is used to display a file. The system specifies
the name of the file to display by calling the file viewer's
IPersistFile::Load member function. This function returns NOERROR
if it is successful or E_UNEXPECTED if IFileView::ShowInitialize
wasn't called before IFileView::Show. This member function is
similar to the Windows ShowWindow function in that it receives a
Show command indicating how the file viewer should initially
display its window. </p>

<p><tt>STDMETHODIMP CFileView::XFileViewer::Show (LPFVSHOWINFO
pvsi)<br>
{<br>
METHOD_PROLOGUE (CFileView, FileViewer);<br>
TRACE (&quot;CFileView::XFileViewer::Show\n&quot;);<br>
<br>
if (! pThis-&gt;m_fShowInit)<br>
return E_UNEXPECTED;<br>
<br>
pThis-&gt;m_pvsi = pvsi;<br>
<br>
// If you could not view the file, go back to the message loop.<br>
if ((pThis-&gt;m_pvsi-&gt;dwFlags &amp; FVSIF_NEWFAILED) == 0)<br>
{<br>
if (pThis-&gt;m_pvsi-&gt;dwFlags &amp; FVSIF_RECT)<br>
pThis-&gt;m_Wnd.MoveWindow (pThis-&gt;m_pvsi-&gt;rect.left, <br>
pThis-&gt;m_pvsi-&gt;rect.top, pThis-&gt;m_pvsi-&gt;rect.right, <br>
pThis-&gt;m_pvsi-&gt;rect.bottom);<br>
pThis-&gt;m_Wnd.ShowWindow (pThis-&gt;m_pvsi-&gt;iShow);<br>
<br>
if (pThis-&gt;m_pvsi-&gt;iShow != SW_HIDE)<br>
{<br>
pThis-&gt;m_Wnd.SetForegroundWindow ();<br>
pThis-&gt;m_Wnd.UpdateWindow ();<br>
}<br>
<br>
// If an old window exists, destroy it now.<br>
if (pThis-&gt;m_pvsi-&gt;dwFlags &amp; FVSIF_PINNED)<br>
{<br>
pThis-&gt;m_lpfsi-&gt;SetPinnedWindow (NULL);<br>
pThis-&gt;m_lpfsi-&gt;SetPinnedWindow (pThis-&gt;m_Wnd.m_hWnd);<br>
}<br>
<br>
if (pThis-&gt;m_pvsi-&gt;punkRel != NULL)<br>
{<br>
pThis-&gt;m_pvsi-&gt;punkRel-&gt;Release ();<br>
pThis-&gt;m_pvsi-&gt;punkRel = NULL;<br>
}<br>
}<br>
return NOERROR;<br>
}</tt> </p>

<h4>PrintTo</h4>

<p>This function prints a file. The system specifies the name of
the file to print by calling the file viewer's IPersistFile::Load
member function. This function returns NOERROR if it is
successful; otherwise, it returns an OLE-defined error value.
This member function resembles Show in that it does not return
until it finishes printing or an error occurs. If a problem
arises, the file viewer object is responsible for informing the
user of the problem. This is not implemented in my file
viewer&#151;it's just a stub. </p>

<p><tt>STDMETHODIMP CFileView::XFileViewer::PrintTo (<br>
LPSTR pszDriver, BOOL fSuppressUI)<br>
{<br>
// This is a stub. Printing isn't implemented.<br>
TRACE (&quot;CFileView::XFileViewer::PrintTo\n&quot;);<br>
<br>
return E_NOTIMPL;<br>
}</tt> </p>
</body>
</html>
