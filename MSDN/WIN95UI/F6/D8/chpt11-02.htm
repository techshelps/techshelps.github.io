<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">
<meta name="GENERATOR" content="Microsoft FrontPage 2.0">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Drag and Drop</title>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>

<BODY bgcolor="#FFFFFF">


<h1><font size="5">Drag and Drop</font></h1>

<p>The drag-and-drop functions in SHELL32.DLL allow an
application to register itself with the system for drag-and-drop
notifications, to query information about the file or files
dropped, and to permit or prevent a drop. Before an application
can process a drop, it must register itself with the system by
using the DragAcceptFiles function. In SHELLFUN, this happens in
the processing of the WM_CREATE message for the main window: </p>

<p><tt>case WM_CREATE:<br>
// Indicate that drag and drop is OK.<br>
DragAcceptFiles (hWnd, TRUE);</tt> </p>

<p>After making this call, the application receives notification
of a drop in the form of the WM_DROPFILES message. In the <i>wParam</i>
parameter of the message, the system packages a handle to a
structure containing information about the drop object. Using
this handle, the application can query information such as the
number of files dropped, the filename(s), and the location of the
drop. To query the number of files being dropped, you can pass a
special value (-1) to the DragQueryFile function in the second
parameter. The application can get the name of the file being
dropped by subsequent calls to DragQueryFile, with the second
parameter specifying the index to the file. The drop operation is
completed with a call to DragFinish. </p>

<p>In the SHELLFUN sample, I allow only one file to be dropped at
a time. The dropped file is opened and read into a data buffer,
to be displayed in a multiline edit control. </p>

<p><tt>case WM_DROPFILES:<br>
{<br>
// A file is being dropped.<br>
int iFiles;<br>
char lpszFile [MAX_PATH];<br>
HDROP hDropInfo = (HANDLE)wParam;<br>
<br>
// Get the number of files.<br>
iFiles = DragQueryFile (hDropInfo, (DWORD)(-1), (LPSTR)NULL, 0);<br>
<br>
if (iFiles != 1) <br>
MessageBox (hWnd, &quot;One file at a time, please.&quot;, NULL,
MB_OK);<br>
<br>
else<br>
{<br>
HANDLE hFile;<br>
DWORD dwFileSize, dwBytesRead;<br>
char *lpBufPtr;<br>
<br>
DragQueryFile (hDropInfo, 0, lpszFile, sizeof (lpszFile));<br>
// Open the file.<br>
if ((hFile = CreateFile (lpszFile,<br>
GENERIC_READ,<br>
FILE_SHARE_READ,<br>
NULL,<br>
OPEN_EXISTING,<br>
FILE_ATTRIBUTE_NORMAL,<br>
(HANDLE)NULL)) == (HANDLE)(-1))<br>
{<br>
MessageBox (hWnd, &#147;File open failed.&quot;, NULL, MB_OK);<br>
break;<br>
}<br>
<br>
// Get the size of the file.<br>
dwFileSize = GetFileSize (hFile, NULL);<br>
if (dwFileSize == 0xFFFFFFFF)<br>
{<br>
MessageBox (NULL, &quot;GetFileSize failed!&quot;, NULL, MB_OK);<br>
break;<br>
}<br>
<br>
// Allocate a buffer to read the file into.<br>
lpBufPtr = (char *) malloc (dwFileSize);<br>
if (lpBufPtr == NULL)<br>
{<br>
MessageBox (NULL, &quot;malloc failed!&quot;, NULL, MB_OK);<br>
CloseHandle (hFile);<br>
break;<br>
}<br>
<br>
// Read the file contents into the buffer.<br>
ReadFile (hFile, (LPVOID)lpBufPtr, dwFileSize, &amp;dwBytesRead,<br>
NULL);<br>
<br>
if (dwBytesRead == 0)<br>
{<br>
MessageBox (hWnd, &quot;Zero bytes read.&quot;, NULL, MB_OK);<br>
break;<br>
}<br>
<br>
// Update the multiline edit control with the file contents.<br>
SendMessage (hwndEdit, WM_SETTEXT, 0, (LPARAM)lpBufPtr);<br>
<br>
// Close the file.<br>
CloseHandle (hFile);<br>
<br>
free (lpBufPtr);<br>
}<br>
<br>
// Signal that the drag-and-drop operation is over.<br>
DragFinish (hDropInfo);<br>
<br>
break;<br>
}</tt> </p>

<p>Figure 11-1 shows the result of dragging a file named <i>A
Sample Text File</i> and dropping it in the SHELLFUN window.
Because the SHELLFUN sample simply reads the file into a buffer
and does no processing, it's easiest to do this with a text file.
(You can drop a binary file, but it'll look funny.) </p>

<p><b>Figure 11-1.</b> </p>

<p><img src="fig11-1.gif" width="641" height="481"></p>

<h4><i>The result of a drag-and-drop operation in the SHELLFUN
sample.</i> </h4>

<p>When the application no longer needs to support drag and drop,
it must unregister itself by using the DragAcceptFiles function
as follows: </p>

<p><tt>DragAcceptFiles (hWnd, FALSE);</tt> </p>

<p>To determine where a file is being dropped, the application
can use another drag-and-drop function, DragQueryPoint. The
DragQueryPoint function returns the drop point, and the
application can then draw the item at that point, as you can see
here: </p>

<p><tt>// A file is being dropped.<br>
POINT pt;<br>
int idx;<br>
char lpszFile [MAX_PATH];<br>
HDC hDC;<br>
<br>
// Find out where the drop is.<br>
DragQueryPoint (hDropInfo, &amp;pt);<br>
<br>
// Get a DC.<br>
hDC = GetDC (hWnd);<br>
<br>
// For each file dropped, write its name out to the client.<br>
for (idx = 0; <br>
DragQueryFile (hDropInfo, idx, lpszFile, sizeof (lpszFile)); <br>
pt.y += 20, idx++)<br>
TextOut (hWnd, pt.x, pt.y, lpszFile, sizeof (lpszFile));<br>
<br>
// Signal that the drag-and-drop operation is over.<br>
DragFinish (hDropInfo);<br>
<br>
// Release the DC.<br>
ReleaseDC (hDC, hWnd);</tt> </p>

<p>NOTE: What you've just seen is a message-based (Windows 3.1)
method of using the drag-and-drop functions in the user interface
library. A new, alternative method uses OLE to perform
drag-and-drop operations. The message-based method is fine for
simple drag-and-drop tasks, whereas the OLE method is far richer
and allows more complex operations. This book does not cover the
OLE-based method in detail, although Chapter 14 contains a sample
that shows how to implement the IDropSource interface for drag
and drop. (See &#147;Supporting Drag and Drop,&#148; page 355.)
For more information about drag and drop using OLE, you can refer
to the Win32 SDK, the Microsoft Visual C++ 2 documentation, and
Inside OLE, 2d edition, by Kraig Brockschmidt (Microsoft Press,
1995). </p>
</body>
</html>
