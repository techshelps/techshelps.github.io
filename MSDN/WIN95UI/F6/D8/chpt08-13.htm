<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">
<meta name="GENERATOR" content="Microsoft FrontPage 2.0">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Assumption: A filename contains only one period.</title>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>

<BODY bgcolor="#FFFFFF">


<h3>Assumption: A filename contains only one period.</h3>

<p>The FAT file system allows only one period in a filename, as a
delimiter. In that case, you know that the three characters
following the period are the file extension. Under file systems
that support long filenames, however, this is not true. What
happens if your application scans a filename looking for a period
in order to find the file extension? Here's a bit of code from
one of my samples that (unfortunately) relies on this assumption:
</p>

<p><tt>// Strip off the extension, if any.<br>
if (pDot = strstr (szLink, &quot;.&quot;))<br>
*pDot = (char)NULL;<br>
<br>
// Add in the LNK extension.<br>
lstrcat (szLink, &quot;.LNK&quot;);</tt> </p>

<p>Had there been more than one period in the filename, my code
would have failed to create a file of the correct type. A better
way to get the name of the file, without the file extension, is
to use a string function that returns the pointer to the
extension by checking the string from the reverse: </p>

<p><tt>if (pDot = strrchr (szLink, `.'))<br>
*pDot = (char)NULL;<br>
<br>
lstrcat (szLink, &quot;.LNK&quot;);</tt> </p>
</body>
</html>
