<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">
<meta name="GENERATOR" content="Microsoft FrontPage 2.0">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>The Structure of Registry Entries</title>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>

<BODY bgcolor="#FFFFFF">


<h2>The Structure of Registry Entries</h2>

<p>The following Registry structure is required if QUIKVIEW is to
associate a file's class identifier or extension with the class
identifier of a file viewer. If you deviate from this structure,
QUIKVIEW won't find your file viewer, and you'll be one
frustrated developer. </p>

<p><tt>HKEY_CLASSES_ROOT<br>
\QuickView<br>
\&lt;extension&gt; = &lt;human-readable document type&gt;<br>
\{&lt;CLSID&gt;} = &lt;human-readable viewer name&gt;<br>
\{&lt;CLSID&gt;} = &lt;human-readable viewer name&gt;<br>
\{&lt;CLSID&gt;} = &lt;human-readable viewer name&gt;<br>
§<br>
[More extension entries for additional file types]<br>
§<br>
<br>
\CLSID<br>
\{&lt;CLSID&gt;} = &lt;human-readable viewer name&gt;<br>
\InprocServer32 = &lt;full path to file viewer DLL&gt;<br>
\ThreadingModel = &lt;Model&gt;<br>
§<br>
[More class IDs for file viewers and other object servers]<br>
§</tt> </p>

<p>How about some explanation? </p>

<ul>
    <li>HKEY_CLASSES_ROOT is the root of the Registry. </li>
    <li>The QuickView key is the top-level key, where the file
        viewer associations are stored. It can have any number of
        extension subkeys (TXT, CPP, and so on), each
        representing a registered file type. Each extension
        subkey can have one or more class identifier subkeys,
        each representing a registered file viewer object. The
        most recently registered file viewer appears first in the
        list of class identifier subkeys, and it is the first one
        found when QUIKVIEW enumerates the registered file
        viewers. </li>
    <li>The &lt;<i>extension</i>&gt; key is a three-character
        file extension preceded by a period (for example, <i>.WRI</i>).
    </li>
    <li>The &lt;<i>human-readable document type</i>&gt; key is a
        string that can be displayed to the user, describing the
        file type associated with the class identifier or
        extension. A file viewer can change this string when it
        is installed so that the name always reflects the
        preferred viewer. For example, this string might be <i>Windows
        Write Document.</i> </li>
    <li>The CLSID key is a 16-byte OLE class identifier spelled
        out in hexadecimal digits in the form
        12345678-1234-1234-1234-1234567890AB, including hyphens.
        All class identifiers are surrounded by curly braces
        (&nbsp;{ }&nbsp;) when stored in the Registry. The file
        viewer class identifier should always differ from the
        file type class identifier because the application that
        created the file might already be using the file type
        class identifier to identify itself as a compound
        document server. </li>
    <li>The &lt;<i>human-readable viewer name</i>&gt; key is a
        string that describes the vendor of the file viewer, as
        such a description might be displayed in an About
        box&#151;<i>Company ABC Write Document Viewer</i>, for
        instance. </li>
    <li>The &lt;<i>Model</i>&gt; subkey specifies the threading
        model as it relates to OLE objects. Under Windows 95, OLE
        is apartment-threaded. The term <i>apartment</i>
        describes a thread with a message queue that supports
        OLE/COM (Component Object Model) objects. Operations that
        yield to the message queue can cause further messages to
        be sent to any objects within the apartment. Apartment
        model threading simply allows multiple apartments where
        previously only one existed (the main application
        thread). By default, a single-threaded application
        consists of a single apartment (its single thread). When
        a process calls CoInitialize or OleInitialize from a
        thread, a new OLE apartment is created. Thereafter, each
        time CoInitialize or OleInitialize is called in a thread,
        a new OLE apartment is created. You can create in-process
        objects that are apartment-model-aware in any apartment.
        You mark the DLL as apartment-model-aware through the <i>ThreadingModel=Apartment</i>
        value of the InprocServer32 key. In-process objects that
        are not apartment-model-aware are created in the main
        apartment of the application, the main apartment being
        the first thread that calls CoInitialize or
        OleInitialize. </li>
</ul>

<p>Each CLSID stored under the file extension subkeys corresponds
to an entry of that same CLSID stored under the top-level key,
called (what else?) CLSID, the standard location for storing
information about OLE objects. For file viewers, an
InprocServer32 subkey is needed under the file viewer's class
identifier key. The value of this subkey is the full path to the
file viewer DLL. In my sample, the file viewer is stored in the
\WINDOWS\SYSTEM\VIEWERS folder. InprocServer32 is a standard OLE
subkey storing the path to an object. Using this subkey allows
the QUIKVIEW program to use standard OLE APIs to access and
create objects from file viewer servers. </p>

<p>An apartment-model-aware process must have thread-safe entry
points because multiple apartments can call CoCreateInstance or
CoGetClassOb-ject simultaneously. In practice, this means that
your application should do the following: </p>

<ul>
    <li>DllGetClassObject must support supplying references to
        multiple class objects. If you implement your class
        objects dynamically, this shouldn't be an issue because
        any class object you supply will be called only from a
        single apartment. If you implement your class object as a
        static object, you must ensure that your AddRef and
        Release member functions use InterlockedIncrement and
        InterlockedDecrement rather than the ++/-- operators. </li>
    <li>With both static and dynamic class objects, global
        lock-count, as implemented for IClassFactory::LockServer,
        must use InterlockedIncrement and InterlockedDecrement.
        If you're not using a global counter for this value now,
        you should start doing so. </li>
    <li>Carefully implement DllCanUnloadNow by using the global
        counter from InterlockedIncrement along with a global
        counter that keeps track of the total number of instances
        that have been created. </li>
</ul>

<p>When you create a file viewer using MFC, you can let MFC
initialize for you, as I did in the MFCVIEW sample. </p>
</body>
</html>
