<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">
<meta name="GENERATOR" content="Microsoft FrontPage 2.0">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SHORTCUT: A SampleThat Manipulates Shortcuts</title>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>

<BODY bgcolor="#FFFFFF">


<h1><font size="5">SHORTCUT: A SampleThat Manipulates Shortcuts</font></h1>

<p>SHORTCUT is a simple MFC-based application in which the user
can create a shortcut for a file selected from the current
directory. When the user chooses the Create Shortcut menu item,
the dialog box shown in Figure 9-4 displays a list of the files
in the current directory. I filled the list box with file options
by using a call to DlgDirList in my handler for the WM_INITDIALOG
message, OnInitDialog. To create a shortcut to a text file named
README, for example, the user would choose README.TXT from the
list. </p>

<p><b>Figure 9-4.</b> </p>

<p><img src="fig9-4.gif" width="288" height="225"></p>

<h4><i>The Create A Shortcut dialog box in the SHORTCUT sample.</i>
</h4>

<p>The user indicates whether the shortcut should appear on the
desktop by checking the Place Shortcut On Desktop option in the
dialog box. After the user selects a file from the list and
clicks the OK button, the application checks to determine whether
the shortcut should be located on the desktop or in the current
directory. If it should be placed on the desktop, the shortcut's
default location is in a subdirectory (called DESKTOP) of the
directory that contains Windows 95. For example, if your
installation of Windows 95 is in the C:\WINDOWS directory, the
shortcut file is placed in C:\WINDOWS\DESKTOP. This subdirectory
is hidden; you can find it by opening an MS-DOS command prompt
and typing <i>attrib desktop</i> or by going into your Windows
installation directory and typing <i>dir desktop</i>. </p>

<p>If your system is configured to use a different profile per
user, the location of the shortcut is different. You can set up a
different profile per user by using the Passwords application in
Control Panel. Open Passwords, click the User Profiles tab, and
then check the Include Desktop Icons And Network Neighborhood
Contents In User Settings option. This stores the desktop icons
(and your desktop shortcut) in the Registry's Desktop
subdirectory under
HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\-Explorer\Shell
Folders. The Desktop key will contain the fully qualified path to
the icons. (Refer to Chapter 10 for a discussion of the Registry
and its keys.) For example, if I set up my computer to support
per-user profiles, the Desktop key will be located under
C:\WINDOWS\PROFILES\NANCYCL\DESKTOP. (The SHORTCUT sample does
not support per-user profiles, so in this case all shortcuts
targeted to the desktop are placed in the DESKTOP subfolder of
the Windows 95 installation directory.) </p>

<p>The shortcut name is completed by retrieving the selected file
through a call to DlgDirSelect, stripping off the filename
extension, and replacing it with the LNK extension. All shortcuts
have the LNK extension. </p>

<p>Then it's time to get down to the real work of creating the
shortcut. The CreateShortCut::CreateIt function actually performs
the task. It takes three parameters: </p>

<ul>
    <li><i>pszShortcutFile</i> is the file that the shortcut will
        point to. </li>
    <li><i>pszLink </i>is the shortcut you are creating with a
        LNK extension. </li>
    <li><i>pszDesc</i> is the description of the file. This is
        the string &quot;Shortcut to <i>filename</i>&quot;, where
        <i>filename</i> is the name of the shortcut target. </li>
</ul>

<p>Because this function makes a call to CoCreateInstance, it is
assumed that CoInitialize has already been called. As you can see
in the following code, this function uses both the IPersistFile
interface, for actually saving the shortcut in the system, and
the IShellLink interface, for storing the path and the
description of the shortcut target: </p>

<p><tt>HRESULT CreateShortCut::CreateIt (LPCSTR pszShortcutFile,
LPSTR pszLink, <br>
LPSTR pszDesc)<br>
{<br>
HRESULT hres;<br>
IShellLink *psl;<br>
<br>
// Create an IShellLink object and get a pointer to the
IShellLink <br>
// interface (returned from CoCreateInstance).<br>
hres = CoCreateInstance (CLSID_ShellLink, NULL,
CLSCTX_INPROC_SERVER,<br>
IID_IShellLink, (void **)&amp;psl);<br>
if (SUCCEEDED (hres))<br>
{<br>
IPersistFile *ppf;<br>
<br>
// Query IShellLink for the IPersistFile interface for <br>
// saving the shortcut in persistent storage.<br>
hres = psl-&gt;QueryInterface (IID_IPersistFile, (void
**)&amp;ppf);<br>
if (SUCCEEDED (hres))<br>
{ <br>
WORD wsz [MAX_PATH]; // buffer for Unicode string<br>
<br>
// Set the path to the shortcut target.<br>
hres = psl-&gt;SetPath (pszShortcutFile);<br>
<br>
if (! SUCCEEDED (hres))<br>
AfxMessageBox (&quot;SetPath failed!&quot;);<br>
<br>
// Set the description of the shortcut.<br>
hres = psl-&gt;SetDescription (pszDesc);<br>
<br>
if (! SUCCEEDED (hres))<br>
AfxMessageBox (&quot;SetDescription failed!&quot;);<br>
<br>
// Ensure that the string consists of ANSI characters.<br>
MultiByteToWideChar (CP_ACP, 0, pszLink, -1, wsz, MAX_PATH);<br>
<br>
// Save the shortcut via the IPersistFile::Save member function.<br>
hres = ppf-&gt;Save (wsz, TRUE);<br>
<br>
if (! SUCCEEDED (hres))<br>
AfxMessageBox (&#147;Save failed!&#148;);<br>
<br>
// Release the pointer to IPersistFile.<br>
ppf-&gt;Release ();<br>
}<br>
// Release the pointer to IShellLink.<br>
psl-&gt;Release ();<br>
}<br>
return hres;<br>
}</tt> </p>

<p>Once you have created the shortcut, you might need to access
and manipulate it programmatically. This is referred to as <i>resolving</i>
the shortcut. I added a function to my sample that demonstrates
how you can resolve a shortcut. I used the same type of dialog
box that I used for creating the shortcut&#151;and used almost
exactly the same code to fill the dialog box with the names of
the files in the current directory and prompt the user to choose
a shortcut to resolve. The only difference was a simple check to
ensure that the user actually picked a LNK file: </p>

<p><tt>void ResolveShortCut::OnOK () <br>
{<br>
char szFile [MAX_PATH];<br>
<br>
// Get the selected item in the list box.<br>
DlgDirSelect (szFile, IDC_LIST1);<br>
<br>
// Find out whether it is a LNK file.<br>
if (strstr (szFile, &#147;.lnk&#148;) != NULL)<br>
// Make the call to ResolveShortcut::ResolveIt here.<br>
ResolveIt (m_hWnd, szFile);<br>
<br>
CDialog::OnOK ();<br>
}</tt> </p>

<p>The ResolveShortCut::ResolveIt function resolves the shortcut.
This function takes two parameters: </p>

<ul>
    <li><i>hwnd</i> is the handle to the window that currently
        has the focus. This is used in case the user must be
        prompted to take an action. For instance, a message box
        is displayed if the user needs to insert a floppy disk,
        if the shortcut is on unshared media, or if network
        problems arise during the resolution of the shortcut. </li>
    <li><i>pszShortcutFile</i> is the fully qualified path to the
        shortcut. </li>
</ul>

<p>Like the function that created the shortcut, this function
calls CoCreateInstance and assumes that CoInitialize has already
been called. Notice that the following code needs to call into
the IPersistFile interface. The IShellLink object implements this
interface to store shortcut information. To get the path
information requested later in the code, the shortcut information
must be loaded first. Failing to load the shortcut information
causes the calls to GetPath and GetDescription to fail. </p>

<p><tt>HRESULT ResolveShortCut::ResolveIt (HWND hwnd, LPCSTR
pszShortcutFile)<br>
{<br>
HRESULT hres;<br>
IShellLink *psl;<br>
char szGotPath [MAX_PATH];<br>
char szDescription [MAX_PATH];<br>
WIN32_FIND_DATA wfd;<br>
<br>
// Get a pointer to the IShellLink interface.<br>
hres = CoCreateInstance (CLSID_ShellLink, NULL,
CLSCTX_INPROC_SERVER,<br>
IID_IShellLink, (void **)&amp;psl);<br>
if (SUCCEEDED (hres))<br>
{<br>
IPersistFile *ppf;<br>
<br>
// Get a pointer to the IPersistFile interface.<br>
hres = psl-&gt;QueryInterface (IID_IPersistFile, (void
**)&amp;ppf);<br>
<br>
if (SUCCEEDED (hres))<br>
{<br>
WORD wsz [MAX_PATH]; // buffer for Unicode string<br>
<br>
// Ensure that the string consists of Unicode characters.<br>
MultiByteToWideChar (CP_ACP, 0, pszShortcutFile, -1, wsz,<br>
MAX_PATH);<br>
<br>
// Load the shortcut.<br>
hres = ppf-&gt;Load (wsz, STGM_READ);<br>
<br>
if (SUCCEEDED (hres))<br>
{<br>
// Resolve the shortcut.<br>
hres = psl-&gt;Resolve (hwnd, SLR_ANY_MATCH);<br>
if (SUCCEEDED (hres))<br>
{<br>
strcpy (szGotPath, pszShortcutFile);<br>
// Get the path to the shortcut target.<br>
hres = psl-&gt;GetPath (szGotPath, MAX_PATH,<br>
(WIN32_FIND_DATA *)&amp;wfd, SLGP_SHORTPATH);<br>
if (! SUCCEEDED (hres))<br>
AfxMessageBox (&quot;GetPath failed!&quot;);<br>
else<br>
AfxMessageBox (szGotPath);<br>
// Get the description of the target.<br>
hres = psl-&gt;GetDescription (szDescription, MAX_PATH);<br>
if (! SUCCEEDED (hres))<br>
AfxMessageBox (&quot;GetDescription failed!&quot;);<br>
else<br>
AfxMessageBox (szDescription);<br>
}<br>
}<br>
// Release the pointer to IPersistFile.<br>
ppf-&gt;Release ();<br>
}<br>
// Release the pointer to IShellLink.<br>
psl-&gt;Release ();<br>
}<br>
return hres;<br>
}</tt></p>
</body>
</html>
