<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">
<meta name="GENERATOR" content="Microsoft FrontPage 2.0">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Step Four: Implement the Basic Object</title>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>

<BODY bgcolor="#FFFFFF">


<h3>Step Four: Implement the Basic Object</h3>

<p>This is the big step. To implement the object, you must first
add the interface definitions and member variables to the header
file FILEVIEW.H. Another very helpful macro,
DECLARE_INTERFACE_MAP, supplies the basic COM interface
definition. Interface maps are similar to message maps. They
provide the standard implementation of the IUnknown interface of
the CCmdTarget class, maintaining a reference count and
aggregation support. </p>

<p>After declaring the interface map, you need to define the
interfaces your object will support&#151;in this case, both
IFileViewer and IPersistFile. The BEGIN_INTERFACE_PART macro
marks the beginning of the definition, and the END_INTERFACE_PART
macro marks the end: </p>

<p><tt>class CFileView : public CCmdTarget<br>
{<br>
§<br>
// Declare the interface map for this object.<br>
DECLARE_INTERFACE_MAP ()<br>
<br>
// IFileViewer interface<br>
BEGIN_INTERFACE_PART (FileViewer, IFileViewer)<br>
// IFileViewer stuff<br>
STDMETHOD(ShowInitialize) (LPFILEVIEWERSITE lpfsi);<br>
STDMETHOD(Show) (LPFVSHOWINFO pvsi);<br>
STDMETHOD(PrintTo) (LPSTR pszDriver, BOOL fSuppressUI);<br>
END_INTERFACE_PART (FileViewer)<br>
<br>
BEGIN_INTERFACE_PART (PersistFile, IPersistFile)<br>
// IPersistFile<br>
STDMETHODIMP IsDirty ();<br>
STDMETHODIMP Load (LPCOLESTR pszFileName, DWORD dwMode);<br>
STDMETHODIMP Save (LPCOLESTR pszFileName, BOOL fRemember);<br>
STDMETHODIMP SaveCompleted (LPCOLESTR pszFileName);<br>
STDMETHODIMP GetCurFile (LPOLESTR __RPC_FAR *ppszFileName);<br>
STDMETHODIMP GetClassID (LPCLSID pClsID);<br>
END_INTERFACE_PART (PersistFile)<br>
<br>
public:<br>
// Member variables<br>
LPFILEVIEWERSITE m_lpfsi; // file viewer site<br>
CLSID m_clsID; // CLSID of this <br>
// file viewer<br>
char m_pszPath [MAX_PATH]; // path from <br>
// IPersistFile::Load<br>
DWORD m_grfMode; // open mode for file<br>
BOOL m_fLoadCalled; // Load already called?<br>
BOOL m_fShowInit; // ShowInitialize called?<br>
CMyFrame *m_Wnd; // viewer frame window<br>
LPFVSHOWINFO m_pvsi;<br>
}</tt> </p>

<p>When creating your own file viewer, you need to be concerned
about both the IPersistFile interface, which is used to get the
path for the file, and the IFileViewer interface, which is
notified when a file viewer should show or print a file. For your
file viewer to work, it must implement functions for each
interface. These interfaces also include the IUnknown member
functions AddRef, Release, and QueryInterface. </p>

<p>NOTE: It is extremely important to specify the definitions of
the interfaces exactly as they are defined in the header file (in
this case, SHLOBJ.H). If you don't do this correctly, your object
won't work. </p>

<p>In the FILEVIEW.CPP file, you must also use a few macros to
implement a data table that CCmdTarget uses to implement
IUnknown, including entries for both IFileViewer and
IPersistFile. The first parameter is the name of the class
containing the interface object; the second parameter is the IID
that is mapped to the embedded class; and the third parameter is
the name of the local class: </p>

<p><tt>BEGIN_INTERFACE_MAP (CFileView, CCmdTarget)<br>
INTERFACE_PART (CFileView, IID_IFileViewer, FileViewer)<br>
INTERFACE_PART (CFileView, IID_IPersistFile, PersistFile)<br>
END_INTERFACE_MAP ()</tt> </p>
</body>
</html>
