<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">
<meta name="GENERATOR" content="Microsoft FrontPage 2.0">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Step Nine: Create the Class to Show the File Contents</title>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>

<BODY bgcolor="#FFFFFF">


<h3>Step Nine: Create the Class to Show the File Contents</h3>

<p>So far, you've seen the steps you need to implement to create
a file viewer that is a COM object in an INPROC server. To
actually show the contents of the file, however, you need to
create some windows. In the MFCVIEW sample, I created a simple
class named CMyFrame, derived from CFrameWnd. This class includes
the frame window and a child multiline edit window: </p>

<p><tt>class CMyFrame : public CFrameWnd<br>
{<br>
DECLARE_DYNCREATE (CMyFrame)<br>
public:<br>
CMyFrame ();<br>
virtual ~CMyFrame ();<br>
void Create (void);<br>
void UpdateEdit (char *);<br>
<br>
// Attributes<br>
public:<br>
CEdit m_Edit;<br>
<br>
// Operations<br>
public:<br>
// Overrides<br>
// ClassWizard generated virtual function overrides.<br>
// {{AFX_VIRTUAL (CMyFrame)<br>
// }}AFX_VIRTUAL<br>
<br>
// Implementation<br>
<br>
protected:<br>
// Generated message map functions<br>
// {{AFX_MSG (CMyFrame)<br>
afx_msg void OnSize (UINT nType, int cx, int cy);<br>
afx_msg void OnFileExit ();<br>
// }}AFX_MSG<br>
DECLARE_MESSAGE_MAP ()<br>
}</tt> </p>

<p>When the ShowInitialize member function is called, it makes a
call to a function in the CMyFrame class in order to create the
frame window and the multiline edit window: </p>

<p><tt>void CMyFrame::Create (void)<br>
{<br>
// Create the frame window.<br>
CFrameWnd::Create (&quot;AfxFrameOrView&quot;, &quot;Nancy's
Viewer&quot;, <br>
WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN,<br>
CRect (CW_USEDEFAULT, CW_USEDEFAULT, 250, 250),<br>
NULL, MAKEINTRESOURCE (IDR_VIEWERMENU), WS_EX_TOPMOST);<br>
<br>
// Create the edit window inside.<br>
// Get the size of the parent window.<br>
CRect wndRect;<br>
GetClientRect (&amp;wndRect);<br>
<br>
// Create a child edit control to display the text.<br>
m_Edit.Create (ES_MULTILINE | ES_AUTOVSCROLL | WS_CHILD | <br>
WS_VISIBLE | ES_AUTOVSCROLL, wndRect, this, ID_EDIT);<br>
}</tt> </p>

<p>The multiline edit control is updated to reflect the contents
of the current file through a call to a member function named
UpdateEdit: </p>

<p><tt>void CMyFrame::UpdateEdit (char *lpBufPtr)<br>
{<br>
::SendMessage (m_Edit.m_hWnd, WM_SETTEXT, 0, (LPARAM)lpBufPtr);<br>
}</tt> </p>

<p>The sample file viewer I created simply displays the file
contents and is resizable. In your own file viewer, you can add
toolbars, status bars, font support, or anything else you like.
You could use one of the new rich edit controls instead of a
standard multiline edit control. The user interface is up to you.
</p>
</body>
</html>
