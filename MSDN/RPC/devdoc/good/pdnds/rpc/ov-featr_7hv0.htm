<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Marshaling Rules for user_marshal and wire_marshal</title>
<link disabled rel=stylesheet href=../../../backsdk3.css>
<style type="text/css">
@import url(../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h2><a name="_rpc_marshaling_rules_for_user_marshal_and_wire_marshal"></a>Marshaling Rules for user_marshal and wire_marshal</h2>
<p>
The OSF-DCE specification for marshaling embedded pointer types requires that you observe the following restrictions when you implement the <i>&lt;type&gt;</i>_UserSize, <i>&lt;type&gt;</i>_UserMarshal, and <i>&lt;type&gt;_</i>UserUnMarshal functions. (The rules and examples given here are for marshaling. However, your sizing and unmarshaling routines must follow the same restrictions):
<ul>
<li>
If the <i>wire-type</i> is a flat type with no pointers, your marshaling routine for the corresponding <i>userm-type </i>should simply marshal the data according to the layout of the <i>wire-type</i>. For example:<pre><code>typedef [wire_marshal (long)] void * HANDLE_HANDLE
 </code></pre>
<p>
Note that the wire type,<b> long</b>, is a flat type. Your HANDLE_HANDLE_UserMarshal function marshals a long whenever a HANDLE_HANDLE object is passed to it. 
</li>
<li>
If the <i>wire-type</i> is a pointer to another type, your marshaling routine for the corresponding <i>userm-type</i> should marshal the data according to the layout for the type that the <i>wire-type</i> points to. The NDR engine takes care of the pointer. For example:<pre><code>typedef struct HDATA{
long size;
[size_is(size) long * pData;
} HDATA;
typedef HDATA * WIRE_TYPE;
typedef [wire_marshal(WIRE_TYPE)] void * HANDLE_DATA
 </code></pre>
<p>
Note that the wire type, WIRE_TYPE, is a pointer type. Your HANDLE_DATA_UserMarshal function marshals the data related to the handle, using the HDATA layout, rather than the HDATA * layout.
</li>
<li>
A <i>wire-type</i> must be either a flat data type or a pointer type. If your transmissible type must be something else (a struct with pointers, for example), use a pointer to your desired type as the <i>wire-type</i>.</li>
</ul>
<p>
The effect of these restrictions is that the types defined with the <b>wire_marshal</b> or <b>user_marshal</b> attributes can be freely embedded in other types.</p>
<h4>See Also</h4>
<p>
<object id=alink_1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink,MENU">
<PARAM name="DefaultTopic" value="../../../notopic_0pk4.htm">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="_rpc_wire_marshal">
</object><a href=JavaScript:alink_1.Click()><b>wire_marshal</b></a>, <object id=alink_2 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink,MENU">
<PARAM name="DefaultTopic" value="../../../notopic_0pk4.htm">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="_rpc_user_marshal">
</object><a href=JavaScript:alink_2.Click()><b>user_marshal</b></a>, <a href="ov-featr_0tda.htm"><b>The type_UserSize Function</b></a>, <a href="ov-featr_1m0e.htm"><b>The type_UserMarshal Function</b></a>, <a href="ov-featr_7nvy.htm"><b>The type_UserUnMarshal Function</b></a>, <a href="ov-featr_338u.htm"><b>The type_UserFree Function</b></a></p>
<p>&nbsp;</p></body>
</HTML>
