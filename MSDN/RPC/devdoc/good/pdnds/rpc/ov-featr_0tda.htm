<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>The type_UserSize Function</title>
<link disabled rel=stylesheet href=../../../backsdk3.css>
<style type="text/css">
@import url(../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h2><a name="_rpc_the_type_usersize_function"></a>The type_UserSize Function</h2>
<p>
The &lt;<i>type&gt;</i><b>_UserSize</b> function is a helper function for the <b>wire_marshal </b>and <b>user_marshal </b>attributes.The stubs call this function to size the rpc data buffer for the user data object before data is marshaled on the client or server side. The function is defined as:</p>
<pre><code>unsigned long __RPC_USER  &lt;type&gt;_UserSize(
    unsigned long __RPC_FAR * pFlags,
    unsigned long             StartingSize,
    &lt;type&gt;  __RPC_FAR *       pMyObj);
 </code></pre>
<p>
The &lt;<i>type</i>&gt; in the function name means the <i>userm-type</i>, as specified in the <b>wire_marshal</b> or <b>user_marshal</b> type definition. This type may be nonremotable or even, when used with the <b>user_marshal</b> attribute, a type unknown to the MIDL compiler. The wire type name (the name of the transmissible type) is not used in the function prototype. Note, however, that the wire type defines the wire layout for the data as specified by OSF DCE.</p>
<p>
The <i>pFlags</i> argument is a pointer to an unsigned long<b> </b>flag field.The upper word of the flag contains NDR data representation flags as defined by OSF DCE for floating point, endianess, and character representations. The lower word contains a marshaling context flag as defined by the COM channel. The exact layout of the flags within the field is:</p>
<table cellspacing=4 cols=3>
<tr valign=top>
<th align=left width=13%>Bits</th>
<th align=left width=26%>Flag</th>
<th align=left width=61%>Value</th>
</tr>
<tr valign=top>
<td width=13%>31-24</td>
<td width=26%>Floating-point representation</td>
<td width=61%>0 = IEEE<br>
1 = VAX<br>
2 = Cray<br>
3 = IBM</td>
</tr>
<tr valign=top>
<td width=13%>23-20</td>
<td width=26%>Integer and floating-point byte order</td>
<td width=61%>0 = Big-endian<br>
1 = Little-endian</td>
</tr>
<tr valign=top>
<td width=13%>19-16</td>
<td width=26%>Character representation</td>
<td width=61%>0 = ASCII<br>
1 = EBCDIC</td>
</tr>
<tr valign=top>
<td width=13%>15-0</td>
<td width=26%>Marshaling context flag</td>
<td width=61%>0 = MSHCTX_LOCAL<br>
1 = MSHCTX_NOSHAREDMEM<br>
2 = MSHCTX_DIFFERENTMSCHINE<br>
3 = MSHCTX_INPROC</td>
</tr>
</table><br>
<p>
The marshaling context flag makes it possible to alter the behavior of your routine depending on the context for the RPC call. For example, if you have a handle (<b>long</b>) to a block of data, you could send the handle for an in-process call, but you would send the actual data for a call to a different machine.</p>
<p>
The marshaling context flag and its values are defined in the wtypes.h and wtypes.idl files in the Win32 SDK. </p>
<p>
<b>Note</b>&nbsp;&nbsp;When the wire type is properly defined, you do not have to use the NDR Data Representation flags, as the NDR engine performs the necessary conversions. The flags and their values are shown here solely for interest.</p>
<p>
The <i>StartingSize</i> argument is the current buffer offset. The starting size indicates the buffer offset for the user object and it may or may not be aligned properly. Your routine should account for whatever padding is necessary. </p>
<p>
The <i>pMyObj</i> argument is a pointer to a user type object.</p>
<p>
The return value is the new offset or buffer position. The function should return the cumulative size, which is the starting size plus possible padding plus the data size.</p>
<p>
The &lt;<i>type&gt;</i>_UserSize function can return an overestimate of the size needed. The actual size of the sent buffer is defined by the data size, not by the buffer allocation size.</p>
<p>
The &lt;<i>type&gt;</i>_UserSize function is not called if the wire size can be computed at compile time. Note that for most unions, even if there are no pointers, the actual size of the wire representation can be determined only at run time.</p>
<h4>See also</h4>
<p>
<a href="ov-featr_7hv0.htm"><b>Marshaling rules for user_marshal and wire_marshal</b></a>, <object id=alink_1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink,MENU">
<PARAM name="DefaultTopic" value="../../../notopic_0pk4.htm">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="_rpc_user_marshal">
</object><a href=JavaScript:alink_1.Click()><b>user_marshal</b></a>, <object id=alink_2 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink,MENU">
<PARAM name="DefaultTopic" value="../../../notopic_0pk4.htm">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="_rpc_wire_marshal">
</object><a href=JavaScript:alink_2.Click()><b>wire_marshal</b></a></p>
<p>&nbsp;</p></body>
</HTML>
