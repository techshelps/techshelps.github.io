<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Server-side Asynchronous RPC</title>
<link disabled rel=stylesheet href=../../../backsdk3.css>
<style type="text/css">
@import url(../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_rpc_server_side_asynchronous_rpc"></a>Server-side Asynchronous RPC</h1>
<p>
The server application responsibilities are:
<ul>
<li>
Handling asynchronous calls.</li>
<li>
Receiving notifications from the client.</li>
<li>
Sending the reply to the client. </li>
</ul>

<h4><a name="_rpc_handling_asynchronous_calls"></a>Handling Asynchronous Calls</h4>
<p>
The manager routine of an asynchronous function always receives the asynchronous handle as the first parameter. The server must keep track of this handle and use it to send the reply when it becomes available. The server must also keep track of the top level pointers for the <b>out</b> and <b>in, out</b> parameters, and update them before calling <a href="pr-func1_6pnw.htm"><b>RpcAsyncCompleteCall</b></a>. </p>
<p>
If the server needs to abort an asynchronous RPC, it calls <a href="pr-func1_8nl8.htm"><b>RpcAsyncAbortCall</b></a>. This API does the same server-side cleanup as <b>RpcAsyncCompleteCall</b> and propagates an exception code (provided by the server application) back to the client.</p>

<h4><a name="_rpc_receiving_cancellations"></a>Receiving Cancellations</h4>
<p>
The server application can call <a href="pr-func2_12r0.htm"><b>RpcServerTestCancel</b></a><b> </b>with the binding handle of the thread in question to find out if the client has requested a cancellation of an outstanding asynchronous call.</p>

<h4><a name="_rpc_sending_the_reply"></a>Sending The Reply</h4>
<p>
When the asynchronous call is complete, the server sends a reply to the client by calling <b>RpcAsyncCompleteCall</b> on the asynchronous handle. This call is necessary even if the asynchronous call has a void return value and no <b>out </b>parameters. If the function has a return value, it is passed by reference to <b>RpcAsyncCompleteCall.</b> </p>
<p>
When the server calls <b>RpcAsyncCompleteCall </b>or<b> RpcAsyncAbortCall</b>, or a call completed because an exception was raised in the manager routine, the server's asynchronous handle is automatically destroyed.</p>
<p>
<b>Note</b>&nbsp;&nbsp;The server must finish updating the <b>in, out</b> and <b>out</b> parameters before calling <b>RpcAsyncCompleteCall</b>. No changes can be made to those parameters or to the asynchronous handle after calling <b>RpcAsyncCompleteCall</b>. </p>
<h4>Example</h4>
<pre><code>//Notice that the server-side CALL_COOKIE contains an asynchronous
//handle, whereas the client-side version contained the actual
//asynchronous state struct.

typedef struct {
  PRPC_ASYNC_STATE pAsync;
  int a ;
  int *c ;
  } CALL_COOKIE;
 
#define APP_ERROR -1
 
static unsigned long DefaultThreadStackSize = 0;
 
//This is the routine that the client calls. It can spawn off an
//asynchronous operation (in this case, a thread) to do the rest 
//of the work and send back the reply when it is done.

void MyAsyncFunc (IN PRPC_ASYNC_STATE pAsync,
                  IN RPC_BINDING_HANDLE hBinding,
                  IN int a,
                  IN int b,
                  OUT int *c)
{
unsigned long ThreadIdentifier;
HANDLE HandleToThread;
CALL_COOKIE *CallCookie;
 
CallCookie = new CALL_COOKIE;
 
CallCookie-&gt;pAsync = pAsync ;
CallCookie-&gt;a = a;
CallCookie-&gt;c = c;
 
HandleToThread = CreateThread (0,
                               DefaultThreadStackSize,
                               (LPTHREAD_START_ROUTINE) ThreadProc,
                               CallCookie,
                               0,
                               &amp;ThreadIdentifier);
// return to the server stub. 
}
 
//This is the thread that sends the reply by
//calling RpcAsyncCompleteCall

void ThreadProc (CALL_COOKIE *Cookie)
{
int retval = 1;
// Fill-in the out params
*(Cookie-&gt;c) = 10;
RpcAsyncCompleteCall (Cookie-&gt;pAsync, &amp;retval);
}
 </code></pre>
<h4>See Also</h4>
<p>
<a href="pr-dtype_876t.htm">RPC_ASYNC_STATE</a>, <a href="pr-func1_6pnw.htm"><b>RpcAsyncCompleteCall</b></a>, <a href="pr-func1_8nl8.htm"><b>RpcAsyncAbortCall</b></a>, <a href="pr-func2_12r0.htm"><b>RpcServerTestCancel</b></a> </p>
<p>&nbsp;</p></body>
</HTML>
