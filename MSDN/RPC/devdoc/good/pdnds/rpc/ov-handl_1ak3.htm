<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Context Handles</title>
<link disabled rel=stylesheet href=../../../backsdk3.css>
<style type="text/css">
@import url(../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_rpc_context_handles"></a>Context Handles</h1>
<p>
A context handle contains context information created and returned by the server. Typically you create a context handle by specifying the <object id=alink_1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink,MENU">
<PARAM name="DefaultTopic" value="../../../notopic_0pk4.htm">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="_rpc_context_handle">
</object><a href=JavaScript:alink_1.Click()><b>context_handle</b></a> attribute on a data-type definition in the IDL file. The type definition also implicitly specifies a context rundown routine, which you must provide. If communication between the client and server breaks down, the server runtime invokes this routine to perform any needed cleanup. </p>
<p>
If you have an interface that requires context, but does not require a context rundown routine, you can do this by applying the <b>context_handle</b> attribute directly to a parameter. In this case, the server will not automatically invoke any rundown routine when communication is broken.</p>
<p>
An interface that uses a context handle must have another handle for the initial binding, which has to take place before the server can return a context handle. f you do not also specify a primary implicit handle to contain the initial binding, the MIDL compiler generates an auto handle for you. The compiler also generates the code in the client stub to perform auto binding.</p>
<h4>Example</h4>
<p>
In this example, a file handle represents state information—it keeps track of the current location in the file. The file-handle parameter to a remote procedure call is packaged as a context handle. A structure contains the file name and the file handle.</p>
<pre><code>/* cxhndlp.c (fragment of file containing remote procedures) */
typedef struct {
     FILE * hFile;
     char   achFile[256];
} FILE_CONTEXT_TYPE;
 </code></pre>
<p>
The function <b>RemoteOpen</b> opens a file on the server:</p>
<pre><code>short RemoteOpen(PPCONTEXT_HANDLE_TYPE pphContext,
         unsigned char         *pszFileName)
{
    FILE               *hFile;
    FILE_CONTEXT_TYPE  *pFileContext;

    if ((hFile = fopen(pszFileName, "r")) == NULL) {
        *pphContext = (PCONTEXT_HANDLE_TYPE) NULL;
    return(-1);
    }
    else {
        pFileContext = (FILE_CONTEXT_TYPE *) 
                       MIDL_user_allocate(sizeof(FILE_CONTEXT_TYPE));
        pFileContext-&gt;hFile = hFile;
        strcpy(pFileContext-&gt;achFile, pszFileName);
        *pphContext = (PCONTEXT_HANDLE_TYPE) pFileContext;
    return(0);
    }
}
 </code></pre>
<p>
The function <b>RemoteRead</b> reads a file on the server. The details have been omitted as they are not important in this example.</p>
<pre><code>void RemoteRead(…)
{. . .}
</code></pre>
<p>
The function <b>RemoteClose</b> closes a file on the server. Note that the server application has to assign NULL to the context handle as part of the close function.This lets the runtime know that the context handle has been deleted. Otherwise, the connection will be kept open and eventually a context rundown will occur.</p>
<pre><code>void RemoteClose(PPCONTEXT_HANDLE_TYPE pphContext)
{
FILE_CONTEXT_TYPE *pFileContext;

    if (*pphContext == NULL)
    {
    //Log error, client tried to close a NULL handle.
    Return;
}
pFileContext = (FILE_CONTEXT_TYPE *)*pphContext;
printf("File %s closed.\n", pFileContext-&gt;achFile);
fclose(pFileConext-&gt;hFile;
MIDL_user_free(pFileContext);

// This tells the runtime, when it is marshalling the out parameters,
// that the context handle has been closed normally.
*pphContext = NULL;
}
 </code></pre>
<h5>Defining the interface:</h5>
<p>
The IDL file defines the handle as a <object id=alink_2 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink,MENU">
<PARAM name="DefaultTopic" value="../../../notopic_0pk4.htm">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="_rpc_void">
</object><a href=JavaScript:alink_2.Click()><b>void</b></a><b> *</b> type and casts it to the required type on the server:</p>
<pre><code>/* file: cxhndl.idl (fragment of interface definition file) */
typedef [context_handle] void * PCONTEXT_HANDLE_TYPE;
typedef [ref] PCONTEXT_HANDLE_TYPE * PPCONTEXT_HANDLE_TYPE;
 </code></pre>
<p>
The first remote procedure call initializes the handle and sets it to a non-null value. You must define the context with an <object id=alink_3 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink,MENU">
<PARAM name="DefaultTopic" value="../../../notopic_0pk4.htm">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="_rpc_out_idl">
</object><a href=JavaScript:alink_3.Click()><b>out</b></a> directional attribute.</p>
<pre><code>short RemoteOpen([out] PPCONTEXT_HANDLE_TYPE pphContext,
                 [in, string] unsigned char * pszFile);
 </code></pre>
<p>
After the <b>RemoteOpen</b> function returns a valid, non-null context handle, subsequent calls use the context handle as an <b>in</b> pointer:</p>
<pre><code>void RemoteRead(
                [in] PCONTEXT_HANDLE_TYPE phContext,
                [out, size_is(cbBuf)] unsigned char achBuf[],
                [in, out] short *pcbBuf);

short RemoteClose([in, out] PPCONTEXT_HANDLE_TYPE pphContext);
 </code></pre>
<h5>The Client Application:</h5>
<p>
After the client calls <b>RemoteOpen</b>, the context handle contains valid data and is used as the binding handle. The client can free the explicit handle used to launch the context handle:</p>
<pre><code>/* cxhndlc.c  (fragment of client side application)*/
printf("Calling the remote procedure RemoteOpen\n");
if (RemoteOpen(&amp;phContext, pszFileName) &lt; 0) {
    printf("Unable to open %s\n", pszFileName);
    Shutdown();
    exit(2);
}

/* Now the context handle also manages the binding. */
status = RpcBindingFree( );
printf("RpcBindingFree returned 0x%x\n", status);
if (status) 
    exit(status);
    </code></pre>
<p>
The client application reads the file until it encounters the end of the file; it then closes the file. The context handle appears as a parameter in the <b>RemoteRead</b> and <b>RemoteClose</b> functions as:</p>
<pre><code>printf("Calling the remote procedure RemoteRead\n");
do {
    cbRead = 1024; // Using a 1K buffer
  RemoteRead(phContext, pbBuf, &amp;cbRead);
  // cbRead contains the number of bytes actually read.  &lt; 1K if we 
  // reach the end of the file.for (i = 0; i &lt; cbRead; i++)
        putchar(*(pbBuf+i));
   }
while(cbRead);

printf("Calling the remote procedure RemoteClose\n");
if (RemoteClose(&amp;phContext) &lt; 0 ) {
    printf("Close failed on %s\n", pszFileName);
    exit(2);
}
 </code></pre>
<h5>The Server Application:</h5>
<p>
The server application includes the <b>RemoteOpen</b>, <b>RemoteRead</b>, and <b>RemoteClose</b> functions shown earlier. IIn addition, if you specified the context handle on a type definition, your server application must also contain a context rundown routine that will be invoked when the connection is lost. A context handle will rundown when the connection closes and all RPC calls from the client process have completed. See <a href="ov-handl_5uqt.htm">Server Context Rundown Routine</a> for details.</p>
<p>
You will find a complete sample program demonstrating context handles in the Win32 SDK directory samples\RPC\handles.</p>
<h4>See also</h4>
<p>
<object id=alink_4 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink,MENU">
<PARAM name="DefaultTopic" value="../../../notopic_0pk4.htm">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="_rpc_context_handle">
</object><a href=JavaScript:alink_4.Click()><b>context_handle</b></a></p>
<p>&nbsp;</p></body>
</HTML>
