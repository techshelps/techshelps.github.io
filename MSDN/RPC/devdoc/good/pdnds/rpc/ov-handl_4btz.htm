<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Application-Initiated Binding</title>
<link disabled rel=stylesheet href=../../../backsdk3.css>
<style type="text/css">
@import url(../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_rpc_application_initiated_binding"></a>Application-Initiated Binding</h1>
<p>
Applications bind to the server and obtain a handle that is used by the stubs to make remote procedure calls. When the client is finished making remote calls, the application can unbind from the server and invalidate the handle. A client application that manages its own binding and handles can obtain a handle in two ways:
<ul>
<li>
Call <a href="pr-func1_4jtz.htm"><b>RpcBindingFromStringBinding</b></a></li>
<li>
Call the name-service functions <a href="pr-func1_001a.htm"><b>RpcNsBindingImportBegin</b></a>, <a href="pr-func1_6cqc.htm"><b>RpcNsBindingImportNext</b></a>, and <a href="pr-func1_1145.htm"><b>RpcNsBindingImportDone</b></a></li>
</ul>
<p>
When the client explicitly calls <b>RpcBindingFromStringBinding</b>, the client must supply the following information to identify the server:
<ul>
<li>
The globally unique identifier (GUID) or UUID of the object.</li>
<li>
The transport type to communicate over, such as named pipes or TCP/IP.</li>
<li>
The network address, which is the server name for the named-pipe transport.</li>
<li>
The endpoint, which contains the pipe name for the named-pipe transport.</li>
</ul>
<p>
(The object UUID and the endpoint information are optional.)</p>
<p>
The client or client stub communicates this identifying information to the RPC run-time library by means of a data structure called the string binding, which combines these elements using a specified syntax.</p>
<p>
In the following examples, the pszNetworkAddress parameter and other parameters that include embedded backslashes can appear strange at first glance. Because the backslash is an escape character in the C programming language, two backslashes are needed to represent each single literal backslash character. The string-binding data structure must contain four backslash characters to represent the two literal backslash characters that precede the server name. The following example shows eight backslashes so four literal backslash characters will appear in the string-binding data structure after processing by the <b>sprintf</b> function. For example:</p>
<pre><code>/* client application */

char * pszUuid = "6B29FC40-CA47-1067-B31D-00DD010662DA";
char * pszProtocol = "ncacn_np";
char * pszNetworkAddress = "\\\\\\\\servername";
char * pszEndpoint = "\\\\pipe\\\\pipename";
char * pszString;

int len = 0;

len  = sprintf(pszString, "%s", pszUuid);
len += sprintf(pszString + len, "@%s:", pszProtocolSequence);
if (pszNetworkAddress != NULL)
    len += sprintf(pszString + len, "%s", pszNetworkAddress);
len += sprintf(pszString + len, "[%s]", pszEndpoint);
 </code></pre>
<p>
In the following example, the string binding appears as:</p>
<pre><code>6B29FC40-CA47-1067-B31D-00DD010662DA@ncacn_np:\\\\servername[\\pipe\\pipename]
 </code></pre>
<p>
The client then obtains the binding handle by calling <b>RpcBindingFromStringBinding</b>:</p>
<pre><code>RPC_BINDING_HANDLE hBinding;
 
status = RpcBindingFromStringBinding(pszString, &amp;hBinding);
...
 </code></pre>
<p>
A convenience function, <a href="pr-func2_712d.htm"><b>RpcStringBindingCompose</b></a>, assembles the object UUID, protocol sequence, network address, and endpoint into the correct syntax for the call to <b>RpcBindingFromStringBinding</b>. You do not have to worry about putting the ampersand, colon, and the various components for each protocol sequence in the right place; you just supply the strings as parameters to the function. The run-time library even allocates the memory needed for the string binding. For example:</p>
<pre><code>char * pszNetworkAddress = "\\\\server";
char * pszEndpoint = "\\pipe\\pipename";
status = RpcStringBindingCompose(
            pszUuid,
            pszProtocolSequence,
            pszNetworkAddress,
            pszEndpoint,
            pszOptions,
            &amp;pszString);
...
status = RpcBindingFromStringBinding(
            pszString,
            &amp;hBinding);
...
 </code></pre>
<p>
Another convenience function, <a href="pr-func1_6hyf.htm"><b>RpcBindingToStringBinding</b></a>, takes a binding handle as input and produces the corresponding string binding.</p>
<p>&nbsp;</p></body>
</HTML>
