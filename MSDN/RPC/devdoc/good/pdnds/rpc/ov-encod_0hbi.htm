<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Incremental Serialization</title>
<link disabled rel=stylesheet href=../../../backsdk3.css>
<style type="text/css">
@import url(../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h3><a name="_rpc_incremental_serialization"></a>Incremental Serialization</h3>
<p>
When using the incremental style, you supply three routines to manipulate the buffer when required by the stub. These routines are: <b>Alloc</b>, <b>Read</b>, and <b>Write</b>. The <b>Alloc</b> routine allocates a buffer of the required size. The <b>Write</b> routine writes the data into the buffer, and the <b>Read</b> routine retrieves a buffer that contains marshalled data. A single serialization call can make several calls to these routines.</p>
<p>
The incremental style of serialization uses the following routines:
<ul>
<li>
MesEncodeIncrementalHandleCreate</li>
<li>
MesDecodeIncrementalHandleCreate</li>
<li>
MesIncrementalHandleReset</li>
<li>
MesHandleFree</li>
</ul>
<p>
The prototypes for the <b>Alloc</b>, <b>Read</b>, and <b>Write</b> functions that you must provide are shown below:</p>
<pre><code>void __RPC_USER Alloc (
   void *State,          /* application-defined pointer */
   char **pBuffer,       /* returns pointer to allocated buffer */
   unsigned int *pSize); /* inputs requested bytes; outputs 
                         /* pBuffer size */
void __RPC_USER Write (
   void *State,          /* application-defined pointer */
   char *Buffer,         /* buffer with serialized data */
   unsigned int Size);   /* number of bytes to write from Buffer */
void __RPC_USER Read (
   void *State,          /* application-defined pointer */
   char **pBuffer,       /* returned pointer to buffer with data */
   unsigned int *pSize); /* number of bytes to read into pBuffer */
 </code></pre>
<p>
The <i>State</i> input argument for all three functions is the application-defined pointer that was associated with the encoding services handle. The application can use this pointer to access the data structure containing application-specific information such as a file handle or stream pointer. Note that the stubs do not modify the <i>State</i> pointer other than to pass it to the <b>Alloc</b>, <b>Read</b>, and <b>Write</b> functions. During encoding, <b>Alloc</b> is called to obtain a buffer into which the data is serialized. Then, <b>Write</b> is called to enable the application to control when and where the serialized data is stored. When decoding, <b>Read </b>is called to return the requested number of bytes of serialized data from wherever the application stored it.</p>
<p>
An important feature of the incremental style is that the handle keeps the state pointer for you. This pointer maintains the state and is never touched by the RPC code, except when passing the pointer to <b>Alloc</b>, <b>Write</b>, or <b>Read</b> function. The handle also maintains an internal state that makes it possible to serialize and deserialize several type instances to the same buffer by adding padding as needed for alignment. The <a href="pr-func1_6md0.htm"><b>MesIncrementalHandleReset</b></a> function resets a handle to its initial state to enable reading or writing from the beginning of the buffer.</p>
<p>
The <b>Alloc</b> and <b>Write</b> functions, along with an application-defined pointer, are associated with an encoding-services handle by a call to the <b>MesEncodeIncrementalHandleCreate</b> function. <b>MesEncodeIncrementalHandleCreate</b> allocates the memory needed for the handle and then initializes it. It has the following prototype:</p>
<pre><code>RPC_STATUS RPC_ENTRY MesEncodeIncrementalHandleCreate (
    void * UserState,        /* application-defined pointer */
    MIDL_ES_ALLOC Alloc,     /* pointer to Alloc function */
    MIDL_ES_WRITE Write,     /* pointer to Write function */
    handle_t *pHandle);      /* receives encoding services handle */
 </code></pre>
<p>
The application can call <a href="pr-func1_9tr9.htm"><b>MesDecodeIncrementalHandleCreate</b></a> to create a decoding handle, <a href="pr-func1_6md0.htm"><b>MesIncrementalHandleReset</b></a> to reinitialize the handle, or <a href="pr-func1_4vtx.htm"><b>MesHandleFree</b></a> to free the handle's memory. The <b>Read</b> function, along with an application-defined parameter, is associated with a decoding handle by a call to the <b>MesDecodeIncrementalHandleCreate</b> routine. The function creates the handle and initializes it. It has the following prototype:</p>
<pre><code>RPC_STATUS RPC_ENTRY MesDecodeIncrementalHandleCreate (
    void * UserState,        /* application-defined pointer */
    MIDL_ES_READ Read,       /* pointer to Read function */
    handle_t Handle);        /* handle to create and initialize */
 </code></pre>
<p>
The <i>UserState</i>, <i>Alloc</i>, <i>Write</i>, and <i>Read</i> parameters of <b>MesIncrementalHandleReset</b> can be NULL to indicate no change.</p>
<pre><code>RPC_STATUS RPC_ENTRY MesIncrementalHandleReset (
    handle_t Handle,         /* handle to reinitialize */
    void * UserState,        /* application-defined pointer */
    MIDL_ES_ALLOC Alloc,     /* pointer to Alloc function */
    MIDL_ES_WRITE Write,     /* pointer to Write function */
    MIDL_ES_READ Read,       /* pointer to Read function */
    MIDL_ES_CODE OpCode);    /* operations allowed */

RPC_STATUS RPC_ENTRY MesHandleFree (
    handle_t Handle);            // handle to free
 </code></pre>
<p>&nbsp;</p></body>
</HTML>
