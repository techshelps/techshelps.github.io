<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>The transmit_as Attribute</title>
<link disabled rel=stylesheet href=../../../backsdk3.css>
<style type="text/css">
@import url(../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h2><a name="_rpc_the_transmit_as_attribute"></a>The transmit_as Attribute</h2>
<p>
The <object id=alink_1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink,MENU">
<PARAM name="DefaultTopic" value="../../../notopic_0pk4.htm">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="_rpc_transmit_as">
</object><a href=JavaScript:alink_1.Click()><b>transmit_as</b></a> attribute offers a way to control data marshalling without worrying about marshalling data at a low level — that is, without worrying about data sizes or byte swapping in a heterogeneous environment. By lettting you reduce the amount of data transmitted over the network, the <b>transmit_as</b> attribute can make your application more efficient.</p>
<p>
You use the <b>transmit_as</b> attribute to specify a data type that will be used for transmission instead of using the data type provided. You supply routines that convert the data type to and from the type that is used for transmission. You must also supply routines to free the memory used for the data type and the transmitted type. For example, the following defines <i>xmit_type</i> as the transmitted data type for an application-presented <i>type</i> specified as <i>type_spec</i>:</p>
<pre><code>typedef [transmit_as (xmit_type)] type_spec type;
 </code></pre>
<p>
The following table describes the four user-supplied routine names. <i>Type</i> is the data type known to the application, and <i>xmit_type</i> is the data type used for transmission:</p>
<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=32%>Routine</th>
<th align=left width=68%>Description</th>
</tr>
<tr valign=top>
<td width=32%><a href="ov-featr_2vxw.htm"><i>type</i><b>_to_xmit</b></a></td>
<td width=68%>Allocates an object of the transmitted type and converts from presented type to transmitted type (caller and callee).</td>
</tr>
<tr valign=top>
<td width=32%><a href="ov-featr_50hg.htm"><i>type</i><b>_from_xmit</b></a></td>
<td width=68%>Converts from transmitted type to presented type (caller and callee).</td>
</tr>
<tr valign=top>
<td width=32%><a href="ov-featr_9y2c.htm"><i>type</i><b>_free_inst</b></a></td>
<td width=68%>Frees resources used by the presented type (callee only).</td>
</tr>
<tr valign=top>
<td width=32%><a href="ov-featr_44hg.htm"><i>type</i><b>_free_xmit</b></a></td>
<td width=68%>Frees storage returned by the <i>type_</i><b>to_xmit </b>routine (caller and callee).</td>
</tr>
</table><br>
<p>
Other than by these four user-supplied functions, the transmitted type is not manipulated by the application. The transmitted type is defined only to move data over the network. After the data is converted to the type used by the application, the memory used by the transmitted type is freed.</p>
<p>
These user-supplied routines are provided by either the client or the server application based on the directional attributes.</p>
<p>
If the parameter is <b>in</b> only, the client transmits to the server. The client needs the <i>type</i><b>_to_xmit</b> and <i>type</i><b>_free_xmit</b> functions. The server needs the <i>type</i><b>_from_xmit</b> and <i>type</i><b>_free_inst</b> functions.</p>
<p>
For an <b>out</b>-only parameter, the server transmits to the client. The server needs the <i>type</i><b>_to_xmit</b> and <i>type</i><b>_free_xmit</b> functions, while the client needs the <i>type</i><b>_from_xmit</b> function. </p>
<p>
For the temporary <i>xmit_type</i> objects, the stub will call <i>type_</i><b>free_xmit</b> to free any memory allocated by a call to <i>type</i><b>_to_xmit</b>. </p>
<p>
Certain guidelines apply to the presented type instance. If the presented type is a pointer or contains a pointer, then the <i>type</i>_<b>from_xmit</b> routine must allocate pointees of the pointers (the presented type object itself is manipulated by the stub in the usual way). </p>
<p>
For <b>out</b> and <b>in, out </b>parameters, or one of their components, of a type that contains the <b>transmit_as</b> attribute, the <i>type</i>_<b>free_inst</b> routine is automatically called for the data objects that have the attribute. For <b>in </b>parameters, the <i>type</i>_<b>free_inst</b> routine is called only if the <b>transmit_as </b>attribute has been applied to the parameter. If the attribute has been applied to the components of the parameter, the <i>type</i>_<b>free_inst</b> routine is not called. There are no freeing calls for the embedded data and at-most-one call (related to the top-level attribute) for an <b>in</b> only parameter.</p>
<p>
Effective with MIDL version 2.0, both client and server must supply all four functions. For example, a linked list can be transmitted as a sized array. The <i>type</i><b>_to_xmit</b> routine walks the linked list and copies the ordered data into an array. The array elements are ordered so the many pointers associated with the list data structure do not have to be transmitted. The <i>type</i><b>_from_xmit</b> routine reads the array and puts its elements into a linked-list data structure.</p>
<p>
The double-linked list (DOUBLE_LINK_LIST) includes data and pointers to the previous and next list elements:</p>
<pre><code>typedef struct _DOUBLE_LINK_LIST {
    short sNumber;
    struct _DOUBLE_LINK_LIST * pNext;
    struct _DOUBLE_LINK_LIST * pPrevious;
} DOUBLE_LINK_LIST;
 </code></pre>
<p>
Rather than shipping the complex data structure, the <b>transmit_as </b>attribute can be used to send it over the network as an array. The sequence of items in the array retains the ordering of the elements in the list at a lower cost:</p>
<pre><code>typedef struct _DOUBLE_XMIT_TYPE {
    short sSize;
    [size_is(sSize)] short asNumber[];
} DOUBLE_XMIT_TYPE;
 </code></pre>
<p>
The <b>transmit_as</b> attribute appears in the IDL file:</p>
<pre><code>typedef [transmit_as(DOUBLE_XMIT_TYPE)]  DOUBLE_LINK_LIST
                                         DOUBLE_LINK_TYPE;
 </code></pre>
<p>
In the following example, <b>ModifyListProc</b> defines the parameter of type DOUBLE_LINK_TYPE as an <b>in,</b> <b>out</b> parameter:</p>
<pre><code>void ModifyListProc([in, out] DOUBLE_LINK_TYPE * pHead)
 </code></pre>
<p>
The four user-defined functions use the name of the type in the function names and use the presented and transmitted types as parameter types, as required:</p>
<pre><code>void __RPC_USER DOUBLE_LINK_TYPE_to_xmit ( 
     DOUBLE_LINK_TYPE __RPC_FAR * pList, 
     DOUBLE_XMIT_TYPE __RPC_FAR * __RPC_FAR * ppArray);

void __RPC_USER DOUBLE_LINK_TYPE_from_xmit ( 
     DOUBLE_XMIT_TYPE __RPC_FAR * pArray,
     DOUBLE_LINK_TYPE __RPC_FAR * pList);

void __RPC_USER DOUBLE_LINK_TYPE_free_inst ( 
     DOUBLE_LINK_TYPE __RPC_FAR * pList);

void __RPC_USER DOUBLE_LINK_TYPE_free_xmit ( 
     DOUBLE_XMIT_TYPE __RPC_FAR * pArray);
 </code></pre>
<p>&nbsp;</p></body>
</HTML>
