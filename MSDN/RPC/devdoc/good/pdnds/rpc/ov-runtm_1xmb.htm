<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Introduction to Run-Time RPC Functions</title>
<link disabled rel=stylesheet href=../../../backsdk3.css>
<style type="text/css">
@import url(../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_rpc_run_time_rpc_functions"></a>Run-Time RPC Functions</h1>
<p>
The run-time RPC functions are those your distributed application calls to establish a binding handle that represents the logical connection between a client and a server. The binding handle enables the RPC run-time libraries to direct a client's remote procedure call to an instance of the specified interface on a server.</p>
<p>
Obtaining the binding handle involves several data structures or strings:
<ul>
<li>
Protocol sequence and network address strings</li>
<li>
Endpoints</li>
<li>
Interface UUIDs and interface version numbers</li>
<li>
Object UUIDs</li>
<li>
Name-service database server entries</li>
</ul>
<p>
The following topics describe these data structures and strings and the RPC functions that allow your application to manipulate them.</p>
<p>
The name-service functions allow a server to register its interface in a database. When a server registers its interface, any client in the domain can query the database, supplying a logical name and an optional object UUID, to obtain a binding handle to the server without knowing the host name of the server.</p>
<p>
The RPC name service makes distributed applications easy to administer. When the server side of the distributed application is moved to another computer, clients do not have to be reconfigured. As long as the database entry name and object UUIDs remain the same, client applications can access the server application as they did before. When a client requests an interface that several servers have registered, the name service shuffles the binding handles before returning them to the client. This provides a measure of load balancing by preventing all the clients from using the same server.</p>
<p>
You can provide more than one implementation of the remote procedure calls defined in an interface. RPC maps a remote procedure call to an implementation of the procedure through a table of function pointers known as the manager entry-point vector (EPV). You can add implementations of the procedure by supplying additional manager EPVs. The client's object UUID determines the appropriate implementation to use.</p>
<p>
You can also add security to your distributed application in two ways: by installing a security package and calling the RPC functions related to security, or by using the security features built into Windows NT™ transport protocols. Most application writers will want to use the RPC security functions instead of transport-level security. Read the section "Using Authenticated RPC" for more details.</p>
<p>
The set of RPC functions supported by Microsoft® RPC overlaps the OSF-DCE RPC functions. The Microsoft RPC functions are optimized for use with MS-DOS and Microsoft 16-bit and 32-bit Windows operating systems. They are fully compatible with other Microsoft naming and calling conventions.</p>
<p>
For a complete description of each function and data structure in Microsoft RPC, see the <a href="pr-func1_042t.htm">RPC Function Reference</a>. </p>
<p>&nbsp;</p></body>
</HTML>
