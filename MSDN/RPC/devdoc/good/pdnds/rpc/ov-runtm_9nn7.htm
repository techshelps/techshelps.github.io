<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Macro Definitions</title>
<link disabled rel=stylesheet href=../../../backsdk3.css>
<style type="text/css">
@import url(../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_rpc_macro_definitions"></a>Macro Definitions</h1>
<p>
The RPC tools achieve model, calling, and naming-convention independence by associating data types and function-return types in the generated stub files and header files with definitions that are specific to each platform. These macro definitions ensure that any data types and functions that require the designation of <b>_</b>&nbsp;<b>_far</b> are specified as far objects.</p>
<p>
The following figure shows the macro definitions that the MIDL compiler applies to function calls between RPC components:</p>
<p>
<img src="images/prog_a29.gif" border=0></p>
<p>
These are the macro definitions:</p>
<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=28%>Definition</th>
<th align=left width=72%>Description</th>
</tr>
<tr valign=top>
<td width=28%><b>_</b> <b>_RPC_API</b></td>
<td width=72%>Applied to calls made by the stub to the user application. Both functions are in the same executable program.</td>
</tr>
<tr valign=top>
<td width=28%><b>_</b> <b>_RPC_FAR</b></td>
<td width=72%>Applied to the standard macro definition for pointers. This macro definition should appear as part of the signature of all user-supplied functions.</td>
</tr>
<tr valign=top>
<td width=28%><b>_</b> <b>_RPC_STUB</b></td>
<td width=72%>Applied to calls made from the run-time library to the stub. These calls can be considered private.</td>
</tr>
<tr valign=top>
<td width=28%><b>_</b> <b>_RPC_USER</b></td>
<td width=72%>Applied to calls made by the run-time library to the user application. These cross the boundary between a DLL and an application.</td>
</tr>
<tr valign=top>
<td width=28%><b>_</b> <b>_RPC_ENTRY</b></td>
<td width=72%>Applied to calls made by the application or stub to the run-time library. This macro definition is applied to all RPC run-time functions.</td>
</tr>
</table><br>
<p>
To link correctly with the Microsoft RPC run-time libraries, stubs, and support routines, some user-supplied functions must also include these macros in the function definition. Use the macro <b>_</b>&nbsp;<b>_RPC_API</b> when you define the functions associated with memory management, user-defined binding handles, and the <b>transmit_as</b> attribute, and use the macro <b>_</b>&nbsp;<b>_RPC_USER</b> when you define the context-rundown routine associated with the context handle. Specify the functions as:
<dl>
<dt>
<b>_</b> <b>_RPC_USER midl_user_allocate(...)</b></dt>
<dt>
<b>_</b> <b>_RPC_USER midl_user_free(...)</b></dt>
<dt>
<b>_</b> <b>_RPC_USER </b><i>handletype</i><b>_bind(...)</b></dt>
<dt>
<b>_</b> <b>_RPC_USER</b> <i>handletype</i><b>_unbind(...)</b></dt>
<dt>
<b>_</b> <b>_RPC_USER </b><i>type</i><b>_to_local</b></dt>
<dt>
<b>_</b> <b>_RPC_USER </b><i>type</i><b>_from_local</b></dt>
<dt>
<b>_</b> <b>_RPC_USER</b> <i>type</i><b>_to_xmit(...)</b></dt>
<dt>
<b>_</b> <b>_RPC_USER</b> <i>type</i><b>_from_xmit(...)</b></dt>
<dt>
<b>_</b> <b>_RPC_USER </b>type<b>_free_local</b></dt>
<dt>
<b>_</b> <b>_RPC_USER</b> <i>type</i><b>_free_inst(...)</b></dt>
<dt>
<b>_</b> <b>_RPC_USER</b> <i>type</i><b>_free_xmit(...)</b></dt>
<dt>
<b>_</b> <b>_RPC_USER context_rundown(...)</b></dt>
<dd>


<p>
<b>Note</b>&nbsp;&nbsp;All pointer parameters in these functions must be specified using the macro <b>_</b>&nbsp;<b>_RPC_FAR</b>.

</dd>
</dl>
<p>
These are the two approaches that can be used to select an application's memory model:
<ol>
<li>
To use a single memory model for all files, compile all source files using the same memory-model compiler switches. For example, to develop a small-model application, compile both the application and the stub source code using the C-compiler switch <b>/AS</b>, as in the following:<pre><code>cl -c /AS myfunc.c
cl -c /AS clstub_c.c
 </code></pre>
</li>
<li>
To use different memory models for the application source files and the support source files (stubs files), use the RPC macros when you define function prototypes in the IDL file. Compile the distributed-application source files using one compiler memory-model setting and compile the support files using another compiler memory-model setting. Use the same memory model for all of the files generated by the compiler.</li>
</ol>
<p>&nbsp;</p></body>
</HTML>
