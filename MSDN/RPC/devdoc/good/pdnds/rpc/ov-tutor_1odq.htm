<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>The Server Application</title>
<link disabled rel=stylesheet href=../../../backsdk3.css>
<style type="text/css">
@import url(../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_rpc_the_server_application"></a>The Server Application</h1>
<p>
The server side of the distributed application informs the system that its services are available and then waits for client requests. </p>
<p>
Depending on the size of your application and your coding preferences, you can choose to implement remote procedures in one or more separate files. In our example, the main server routine is in the source file hellos.c, and the remote procedure remains in the file hellop.c, which we created for the stand-alone program.</p>
<p>
The benefit of organizing the remote procedures in separate files is that the procedures can be linked with a stand-alone program to debug the code before it is converted to a distributed application. After the program works as a stand-alone program, you can compile and link the remote-procedure source files with the server application.</p>
<p>
As with the client-application source file, the server-application source file must include the hello.h header file to obtain definitions for the RPC data and functions and for the interface-specific data and functions.</p>
<p>
The server calls the RPC runtime functions <a href="pr-func2_38kw.htm"><b>RpcServerUseProtseqEp</b></a> and <a href="pr-func2_25ye.htm"><b>RpcServerRegisterIf</b></a><b> </b>to make binding information available to the client. Since we have only one implentation of our remote procedures, we only pass the interface handle name to <b>RpcServerRegisterIf</b>. The other parameters are set to NULL. The server then calls the <a href="pr-func2_8ffy.htm"><b>RpcServerListen</b></a> function to indicate that it is waiting for client requests.</p>
<p>
The server application must also include the two memory management functions that the server stub calls — <b>midl_user_allocate </b>and <b>midl_user_free</b>. These functions allocate and free memory on the server when a remote procedure passes parameters to the server. In our example, <a href="ov-memmg_3rhh.htm"><b>midl_user_allocate</b></a> and <a href="ov-memmg_404l.htm"><b>midl_user_free</b></a><b> </b>are simply wrappers for the C-library functions <b>malloc</b> and <b>free</b>. (Note that, in the MIDL compiler- generated forward declarations, "midl" is uppercase. The header file rpcndr.h defines midl_user_free and midl_user_allocate to be MIDL_user_free and MIDL_user_allocate, respectively.)</p>
<pre><code>/* file: hellos.c */
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;ctype.h&gt;
#include "hello.h"
 
void main()
{
    RPC_STATUS status;
    unsigned char * pszProtocolSequence = "ncacn_np";
    unsigned char * pszSecurity     = NULL; /*Security not implemented */
    unsigned char * pszEndpoint    = "\\pipe\\hello";
    unsigned int    cMinCalls           = 1;
    unsigned int    cMaxCalls           = 20;
    unsigned int    fDontWait           = FALSE;
 
    status = RpcServerUseProtseqEp(pszProtocolSequence,
                                   cMaxCalls,
                                   pszEndpoint,
                                   pszSecurity); 
 
    if (status) {
        exit(status);
    }
 
    status = RpcServerRegisterIf(hello_v1_0_s_ifspec,  
                                 NULL,   
                                 NULL); 
 
    if (status) {
        exit(status);
    }
 
    status = RpcServerListen(cMinCalls,
                             cMaxCalls,
                             fDontWait);
 
    if (status) {
        exit(status);
    }
 
 }  // end main()
 
/******************************************************/
/*         MIDL allocate and free                     */
/******************************************************/
 
void __RPC_FAR * __RPC_USER midl_user_allocate(size_t len)
{
    return(malloc(len));
}
 
void __RPC_USER midl_user_free(void __RPC_FAR * ptr)
{
    free(ptr);
}
 </code></pre>
<p>&nbsp;</p></body>
</HTML>
