<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>The represent_as Attribute</title>
<link disabled rel=stylesheet href=../../../backsdk3.css>
<style type="text/css">
@import url(../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h2><a name="_rpc_the_represent_as_attribute"></a>The represent_as Attribute</h2>
<p>
The <b>represent_as</b> attribute lets you specify how a particular remotable data type is represented for the application. This is done by specifying the name of the represented type for a known transmittable type and supplying the routines to convert the data type to and from the other data type. You must also supply the routines to free the memory used by the data type objects. </p>
<p>
You use the <b>represent_as</b> attribute to present an application with a different and perhaps nonremotable data type, instead of the type that is actually transmitted between the client and server. Also, the type the application manipulates can be unknown at the time of MIDL compilation. When you choose a well-defined transmittable type, you need not be concerned about data representation in the heterogenic environment. The <b>represent_as</b> attribute can make your application more efficient by reducing the amount of data transmitted over the network.</p>
<p>
The <b>represent_as</b> attribute is similar to the <b>transmit_as</b> attribute. However, while <b>transmit_as</b> lets you specify a data type that will be used for transmission, <b>represent_as</b> lets you specify how a data type is represented for the application. The represented type need not be defined in the MIDL processed files; it can be defined at the time the stubs are compiled with the C compiler. To do this, use the include directive in the ACF to compile the appropriate header file. For example, the following ACF defines a local represented <i>repr_type</i> for the given transmittable <i>named_type</i>:</p>
<pre><code>typedef [represent_as(repr_type) [, type_attribute_list] named_type;
 </code></pre>
<p>
The following table describes the four user-supplied routines:</p>
<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=36%>Routine</th>
<th align=left width=64%>Description</th>
</tr>
<tr valign=top>
<td width=36%><i>named_type</i><b>_from_local</b></td>
<td width=64%>Allocates an instance of the network type and converts from the local type to the network type.</td>
</tr>
<tr valign=top>
<td width=36%><i>named_type</i><b>_to_local</b></td>
<td width=64%>Converts from the network type to the local type.</td>
</tr>
<tr valign=top>
<td width=36%><i>named_type</i><b>_free_local</b></td>
<td width=64%>Frees memory allocated by a call to the <i>named_type</i><b>_to_local</b> routine, but not the type itself.</td>
</tr>
<tr valign=top>
<td width=36%><i>named_type</i><b>_free_inst</b></td>
<td width=64%>Frees storage for the network type (both sides).</td>
</tr>
</table><br>
<p>
Other than by these four user-supplied routines, the named type is not manipulated by the application and the only type visible to the application is the represented type. The represented type name is used instead of the named type name in the prototypes and stubs generated by the compiler. You must supply the set of routines for both sides.</p>
<p>
For temporary <i>named_type</i> objects, the stub will call <i>named_type</i><b>_free_inst</b> to free any memory allocated by a call to <i>named_type</i><b>_from_local</b>.</p>
<p>
If the represented type is a pointer or contains a pointer, the <i>named_type</i><b>_to_local</b> routine must allocate pointees of the pointers (the represented type object itself is manipulated by the stub in the usual way). For <b>out</b> and <b>in, out</b> parameters of a type that contain <b>represent_as</b> or one of its components, the <i>named_type</i><b>_free_local</b> routine is automatically called for the data objects that contain the attribute. For <b>in</b> parameters, the <i>named_type</i><b>_free_local</b> routine is only called if the <b>represent_as</b> attribute has been applied to the parameter. If the attribute has been applied to the components of the parameter, the <i>*</i><b>_free_local</b> routine is not called. Freeing routines are not called for the embedded data and at-most-once call (related to the top-level attribute) for an <b>in</b> only parameter.</p>
<p>
<b>Note</b>&nbsp;&nbsp;It is possible to apply both the <b>transmit_as</b> and <b>represent_as</b> attributes to the same type. When marshalling data, the <b>represent_as</b> type conversion is applied first and then the <b>transmit_as</b> conversion is applied. The order is reversed when unmarshalling data. Thus, when marshalling, *<b>_from_local</b> allocates an instance of a named type and translates it from a local type object to the temporary named type object. This object is the presented type object used for the *<b>_to_xmit</b> routine. The *<b>_to_xmit</b> routine then allocates a transmitted type object and translates it from the presented (named) object to the transmitted object.</p>
<p>
An array of long integers can be used to represent a linked list. In this way, the application manipulates the list and the transmission uses an array of long integers when a list of this type is transmitted. You can begin with an array, but using a construct with an open array of long integers is more convenient. The following example shows how to do this:</p>
<pre><code>/* IDL definitions */
 
typedef struct_lbox {
    long        data;
    struct_lbox *        pNext
} LOC_BOX, * PLOC_BOX;
 
/* The definition of the local type visible to the application, 
as shown above, can be omitted in the IDL file. See the include 
in the ACF file. */
 
typedef struct_xmit_lbox {
    short        Size;
    [size_is(Size)] long DaraArr[];
} LONGARR;
 
void WireTheList( [in,out] LONGARR * pData );
 
/* ACF definitions */
 
/* If the IDL file does not have a definition for PLOC_BOX, you 
can still ready it for C compilation with the following include 
statement (notice that this is not a C include): 
include "local.h";*/
 
typedef [represent_as(PLOC_BOX)] LONGARR;
 </code></pre>
<p>
Note that the prototypes of the routines that use the LONGARR type are actually displayed in the STUB.H files as PLOC_BOX in place of the LONGARR type. The same is true of the appropriate stubs in the STUB_C.C file.</p>
<p>
You must supply the folllowing four functions:</p>
<pre><code>void __RPC_USER
LONGARR_from_local(
    PLOC_BOX __RPC_FAR * pList,
    LONGARR __RPC_FAR * _RPC_FAR * ppDataArr );
 
void __RPC_USER
LONGARR_to_local(
    LONGARR __RPC_FAR * _RPC_FAR * ppDataArr,
    PLOC_BOX __RPC_FAR * pList );
 
void __RPC_USER
LONGARR_free_inst(
    LONGARR __RPC_FAR * pDataArr);
 
void __RPC_USER
LONGARR_free_local(
    PLOC_BOX __RPC_FAR * pList );
 </code></pre>
<p>
The routines shown above do the following:
<ul>
<li>
The <b>LONGARR_from_local</b> routine counts the nodes of the list, allocates a LONGARR object with the size <b>sizeof</b>(<b>LONGARR</b>) + Count*<b>sizeof</b>(<b>long</b>), sets the <i>Size</i> field to Count, and copies the data to the <i>DataArr</i> field.</li>
<li>
The <b>LONGARR_to_local</b> routine creates a list with Size nodes and transfers the array to the appropriate nodes.</li>
<li>
The <b>LONGARR_free_inst</b> routine frees nothing in this case.</li>
<li>
The <b>LONGARR_free_local</b> routine frees all the nodes of the list.</li>
</ul>
<p>&nbsp;</p></body>
</HTML>
