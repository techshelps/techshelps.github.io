<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Auto Handles</title>
<link disabled rel=stylesheet href=../../../backsdk3.css>
<style type="text/css">
@import url(../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h2><a name="_rpc_auto_handles"></a>Auto Handles</h2>
<p>
Auto handles are useful when the application does not require a specific server and when it does not need to maintain any state information between the client and server. When you use an auto handle, you do not have to write any client application code to deal with binding and handles — you simply specify the use of the auto handle in the ACF. The stub then defines the handle and manages the binding. </p>
<p>
For example, a time-stamp operation can be implemented using an auto handle. It makes no difference to the client application which server provides it with the time stamp because it can accept the time from any available server.</p>
<p>
You specify the use of auto handles by including the <object id=alink_1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink,MENU">
<PARAM name="DefaultTopic" value="../../../notopic_0pk4.htm">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="_rpc_auto_handle">
</object><a href=JavaScript:alink_1.Click()><b>auto_handle</b></a> attribute in the ACF. The time-stamp example uses the following ACF:</p>
<pre><code>/* ACF file */
[auto_handle]
interface autoh
{
}
 </code></pre>
<p>
<b>Note</b>&nbsp;&nbsp;Auto handles are not supported for the Macintosh platform.</p>
<p>
The auto handle is used by default when the ACF does not include any other handle attribute and when the remote procedures do not use explicit handles. The auto handle is also used by default when the ACF is not present.</p>
<p>
The remote procedures are specified in the IDL file. The auto handle must not appear as an argument to the remote procedure. For example:</p>
<pre><code>/* IDL file */
[ uuid (6B29FC40-CA47-1067-B31D-00DD010662DA),
  version(1.0),
  pointer_default(unique)
]
interface autoh
{
void GetTime([out] long * time);
void Shutdown(void);
}
 </code></pre>
<p>
The benefit of the auto handle is that the developer does not have to write any code to manage the handle; the stubs manage the binding automatically. This is significantly different from the <a href="ov-tutor_77e4.htm">Hello, World example</a>, where the client manages the implicit primitive handle defined in the ACF and must call several run-time functions to establish the binding handle. </p>
<p>
Here, the stubs do all the work and the client only needs to include the generated header file AUTO.H to obtain the function prototypes for the remote procedures. The client application calls to the remote procedures appear just as if they were calls to local procedures as shown:</p>
<pre><code>/* auto handle client application (fragment) */

#include &lt;stdio.h&gt;
#include &lt;time.h&gt;
#include "auto.h"    // header file generated by the MIDL compiler


void main(int argc, char **argv)
{
    time_t t1;
    time_t t2;
    char * pszTime;
    ...

    RpcTryExcept {
        GetTime(&amp;t1);  // GetTime is a remote procedure
        GetTime(&amp;t2);

        pszTime = ctime(&amp;t1);
        printf("time 1= %s\n", pszTime);

        pszTime = ctime(&amp;t2);
        printf("time 2= %s\n", pszTime);

        Shutdown();    // Shutdown is a remote procedure
    }
    RPCExcept(1)    {
    ...
    }
    RPCEndExcept   

    exit(0);
}
 </code></pre>
<p>
The client application does not have to make any explicit calls to the client run-time functions. Those calls are managed by the client stub.</p>
<p>
The server side of the application that uses auto handles must call the function <a href="pr-func1_8bg4.htm"><b>RpcNsBindingExport</b></a> to make binding information about the server available to clients. The auto handle requires a location service running on a server that is accessible to the client. The Microsoft implementation of the name service, the Microsoft Locator, manages auto handles. The server calls the following run-time functions:</p>
<pre><code>/* auto handle server application (fragment) */

#include "auto.h" //header file generated by the MIDL compiler

void main(void)
{
    RpcUseProtseqEp(...);
    RpcServerRegisterIf(...);
    RpcServerInqBindings(...);
    RpcNsBindingExport(...);
    ...
}
 </code></pre>
<p>
The calls to the first two functions are similar to the <a href="ov-tutor_77e4.htm">Hello, World example</a>; these functions make information about the binding available to the client. The calls to the <a href="pr-func2_8bhv.htm"><b>RpcServerInqBindings</b></a> and <a href="pr-func1_8bg4.htm"><b>RpcNsBindingExport</b></a> functions put the information in the name-service database. The call to <a href="pr-func2_8bhv.htm"><b>RpcServerInqBindings</b></a> fills the vector with valid data before the call to the export function. After the data has been exported to the database, the client (or client stubs) can call <a href="pr-func1_001a.htm"><b>RpcNsBindingImportBegin</b></a> and <a href="pr-func1_6cqc.htm"><b>RpcNsBindingImportNext</b></a> to obtain this information. </p>
<p>
The calls to <b>RpcServerInqBindings</b> and <b>RpcNsBindingExport</b> and their associated data structures appear as:</p>
<pre><code>RPC_BINDING_VECTOR * pBindingVector;
RPCSTATUS status;

status = RpcServerInqBindings(&amp;pBindingVector);

status = RpcNsBindingExport(
                fNameSyntaxType,      // name syntax type 
                pszAutoEntryName,     // nsi entry name 
                autoh_ServerIfHandle, // if server handle
                pBindingVector,       // set in previous call 
                NULL);                // UUID vector 
 </code></pre>
<p>
Note that the <b>RpcServerInqBindings</b> parameter &amp;pBindingVector is a pointer to a pointer to <a href="pr-dtype_6tyq.htm"><b>RPC_BINDING_VECTOR</b></a>.</p>
<p>
The previous example shows the parameters to the <a href="pr-func1_8bg4.htm"><b>RpcNsBindingExport</b></a> function that should be used with the Microsoft Locator. As already mentioned, this locator is the Microsoft implementation of the name-service functions provided with Microsoft RPC. For more information about the Microsoft Locator, see <a href="ov-runtm_1xmb.htm"><b>Run-time RPC Functions</b></a>. </p>
<p>
To remove the exported interface from the name-service database completely, the server calls <a href="pr-func1_5cvo.htm"><b>RpcNsBindingUnexport</b></a> as shown:</p>
<pre><code>status = RpcNsBindingUnexport(
                fNameSyntaxType, 
                pszAutoEntryName,  
                auto_ServerIfHandle,
                NULL);              // unexport handles only
 </code></pre>
<p>
The <b>unexport</b> function should be used only when the service is being permanently removed. It should not be used when the service is temporarily disabled, such as when the server is shut down for maintenance. A service can be registered with the name-service database, yet be unavailable because the server is temporarily offline. The client application should contain exception-handling code for such a condition.</p>
<p>
The calls to the remote procedures are surrounded by the exception-handling code. For more information about exception handling, see <a href="ov-runtm_1xmb.htm">Run-time RPC Functions</a>. </p>
<p>&nbsp;</p></body>
</HTML>
