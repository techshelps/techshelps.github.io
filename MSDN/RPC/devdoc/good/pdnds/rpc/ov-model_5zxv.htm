<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>How RPC Works</title>
<link disabled rel=stylesheet href=../../../backsdk3.css>
<style type="text/css">
@import url(../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_rpc_how_rpc_works"></a>How RPC Works</h1>
<p>
The RPC tools make it appear to users as though a client directly calls a procedure located in a remote server program. The client and server each have their own address spaces; that is, each has its own memory resource that is allocated to data used by the procedure. The following figure illustrates the RPC architecture.</p>
<p>
<img src="images/prog_a11.gif" border=0></p>
<p>
As the illustration shows, the client application calls a local stub procedure instead of the actual code implementing the procedure. Stubs are compiled and linked with the client application. Instead of containing the actual code that implements the remote procedure, the client stub code:
<ul>
<li>
Retrieves the required parameters from the client address space.</li>
<li>
Translates the parameters as needed into a standard network data representation (NDR) format for transmission over the network.</li>
<li>
Calls functions in the RPC client run-time library to send the request and its parameters to the server.</li>
</ul>
<p>
The server performs the following steps to call the remote procedure:
<ul>
<li>
The server RPC run-time library functions accept the request and call the server stub procedure.</li>
<li>
The server stub retrieves the parameters from the network buffer and converts them from the network transmission format to the format the server needs.</li>
<li>
The server stub calls the actual procedure on the server.</li>
</ul>
<p>
The remote procedure then runs, possibly generating output parameters and a return value. When the remote procedure is done, a similar sequence of steps returns the data to the client:
<ul>
<li>
The remote procedure returns its data to the server stub.</li>
<li>
The server stub converts output parameters to the format required for transmission over the network and returns them to the RPC run-time library functions.</li>
<li>
The server RPC run-time library functions transmit the data on the network to the client computer.</li>
</ul>
<p>
The client completes the process by accepting the data over the network and returning it to the calling function:
<ul>
<li>
The client RPC run-time library receives the remote-procedure return values and returns them to the client stub.</li>
<li>
The client stub converts the data from its network data representation to the format used by the client computer. The stub writes data into the client memory and returns the result to the calling program on the client.</li>
<li>
The calling procedure continues as if the procedure had been called on the same computer.</li>
</ul>
<p>
For Microsoft Windows 3.<i>x</i>, Windows 95, and Windows NT, the run-time libraries are provided in two parts: an import library, which is linked with the application and the RPC run-time library, which is implemented as a dynamic-link library (DLL). </p>
<p>
The server application contains calls to the server run-time library functions which register the server's interface and allow the server to accept remote procedure calls. The server application also contains the application-specific remote procedures that are called by the client applications.</p>
<p>&nbsp;</p></body>
</HTML>
