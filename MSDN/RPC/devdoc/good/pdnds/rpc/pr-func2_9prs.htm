<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>RpcServerRegisterIfEx</title>
<link disabled rel=stylesheet href=../../../backsdk3.css>
<style type="text/css">
@import url(../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_rpc_rpcserverregisterifex"></a>RpcServerRegisterIfEx</h1>
<p>
The <b>RpcServerRegisterIfEx</b> function registers an interface with the RPC run-time library.</p>
<p>
This function is supported by both server platforms — Windows&nbsp;NT and Windows 95.</p>
<pre><code><b>#include &lt;rpc.h&gt;
RPC_STATUS RPC_ENTRY RpcServerRegisterIfEx( 
  RPC_IF_HANDLE </b><i> IfSpec</i><b>,          </b>
<b>  UUID * </b><i> MgrTypeUuid</i><b>,            </b>
<b>  RPC_MGR_EPV * </b><i> MgrEpv</i><b>,          </b>
<b>  unsigned int</b><i> Flags</i><b>,             </b>
<b>  unsigned int</b><i> MaxCalls</i><b>,          </b>
<b>  RPC_IF_CALLBACK_FN*</b><i> IfCallback  </i>
<b>);</b>
<b> </b></code></pre>
<h4>Parameters</h4>
<dl>
<dt>
<i>IfSpec</i></dt>
<dd>
Specifies a MIDL-generated data structure indicating the interface to register.</dd>
<dt>
<i>MgrTypeUuid</i></dt>
<dd>
Points to a type UUID to associate with the <i>MgrEpv</i> argument. Specifying a null argument value (or a nil UUID) registers <i>IfSpec</i> with a nil type UUID.</dd>
<dt>
<i>MgrEpv</i></dt>
<dd>
Specifies the manager routines' entry-point vector (EPV). To use the MIDL-generated default EPV, specify a null value.</dd>
<dt>
<i>Flags</i></dt>
<dd>
The following flags are defined:
<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=39%>Value</th>
<th align=left width=61%>Meaning</th>
</tr>
<tr valign=top>
<td width=39%>0</td>
<td width=61%>standard interface semantics</td>
</tr>
<tr valign=top>
<td width=39%>RPC_IF_AUTOLISTEN</td>
<td width=61%>This is an <i>auto-listen</i> interface. See <b>Remarks</b> for more details.</td>
</tr>
<tr valign=top>
<td width=39%>RPC_IF_OLE</td>
<td width=61%>Reserved for OLE. Do not use this flag.</td>
</tr>
</table><br>

</dd>
<dt>
<i>MaxCalls</i></dt>
<dd>
Specifies the maximum number of concurrent remote procedure call requests the server can accept. The RPC run-time library guarantees that the server can accept at least this number of concurrent call requests. The actual number can be greater and can vary for each protocol sequence. Use RPC_C_PROTSEQ_MAX_REQS_DEFAULT to specify the default value. A call on an auto-listen interface uses the value of MaxCalls specified for that interface. Calls on other interfaces are governed by the value of the process-wide MaxCalls specified in <a href="pr-func2_8ffy.htm"><b>RpcServerListen</b></a>.</dd>
<dt>
<i>IfCallback</i></dt>
<dd>
Specifies a security callback function, or NULL for no callback. Each registered interface can have a different callback function. See <b>Remarks</b> for more details.
</dd>
</dl>
<h4>Remarks</h4>
<p>
The parameters and effects of <b>RpcServerRegisterIfEx</b> subsume those of <b>RpcServerRegisterIf</b>. The difference is the ability to register an auto-listen interface and to specify a security callback function.</p>
<p>
The server application code calls the <b>RpcServerRegisterIfEx</b> routine to register an interface. To register an interface, the server provides the following information:
<ul>
<li>
Interface specification. <p>
The interface specification is a data structure that the MIDL compiler generates. 
</li>
<li>
Manager type UUID and manager EPV<p>
The manager type UUID and the manager EPV determine which manager routine executes when a server receives a remote procedure call request from a client. For each implementation of an interface offered by a server, it must register a separate manager EPV.
<p>
Note that when specifying a non-nil manager type UUID, the server must also call the <b>RpcObjectSetType</b> routine to register objects of this non-nil type.
</li>
</ul>
<p>
Specifying the RPC_IF_AUTOLISTEN flags marks the interface as an <i>auto-listen</i> interface. The runtime begins listening for calls as soon as the interface is registered, and stops listening when the interface is unregistered. A call to <b>RpcServerUnregisterIf</b> for this interface will wait for the completion of all pending calls on this interface. Calls to <b>RpcServerListen</b> and <b>RpcServerStopServerListening</b> will not affect the interface, nor will a call to <b>RpcServerUnregisterIf</b> with <i>IfSpec</i> == NULL. This allows a DLL to register and unregister RPC interfaces without changing the main application's RPC state.</p>
<p>
Specifying a security callback function allows the server application to restrict access to its interfaces on a per-client basis. Remember that, by default, security is optional; the server runtime will dispatch unsecured calls even if the server has called <b>RpcServerRegisterAuthInfo</b>. If the server wants to accept only authenticated clients, each server stub must call <b>RpcServerInqAuthClient</b> to retrieve the security level, or attempt to impersonate the client with <b>RpcImpersonateClient</b>. </p>
<p>
When a server app specifies a security callback function for its interface(s), the RPC runtime automatically rejects unauthenticated calls to that interface. In addition, the runtime records the interfaces that each client has used. When a client makes an RPC to a heretofore unused interface, the RPC runtime will call the interface's security callback function. </p>
<p>
The signature for the callback function is as follows:</p>
<pre><code>typedef RPC_STATUS
RPC_IF_CALLBACK_FN (
    IN RPC_IF_ID * Interface,
    IN void * Context
    ) ;
 </code></pre>
<p>
<i>Interface</i> contains the UUID and version of the interface in question. </p>
<p>
<i>Context</i> is a server binding handle representing the client. The callback function may pass this handle to <b>RpcImpersonateClient</b> or <b>RpcBindingServerToClient</b> to gain information about the client.</p>
<p>
The callback function should return RPC_S_OK if the client is allowed to call methods in this interface. Any other return code will cause the client to receive the exception RPC_S_ACCESS_DENIED.</p>
<p>
In some cases the RPC runtime may call the security callback function more than once per client per interface. Be sure your callback function can handle this possibility.</p>
<h4>QuickInfo</h4>
<p>
&nbsp;&nbsp;<b>Windows NT:</b>  Yes<br>
&nbsp;&nbsp;<b>Windows CE:</b>  Unsupported.<br>
&nbsp;&nbsp;<b>Header:</b> Declared in rpcdce.h.<br>
&nbsp;&nbsp;<b>Import Library:</b> Link with rpcrt4.lib.</p>
<h4>See Also</h4>
<p>
<a href="ov-runtm_6hph.htm">Registering the Interface</a>, <a href="pr-func1_4jtz.htm"><b>RpcBindingFromStringBinding</b></a>, <a href="pr-func1_319w.htm"><b>RpcBindingSetObject</b></a>, <a href="pr-func1_8bg4.htm"><b>RpcNsBindingExport</b></a>, <a href="pr-func1_001a.htm"><b>RpcNsBindingImportBegin</b></a>, <a href="pr-func1_4i7i.htm"><b>RpcNsBindingLookupBegin</b></a>, <a href="pr-func2_1n8l.htm"><b>RpcObjectSetType</b></a>, <a href="pr-func2_25ye.htm"><b>RpcServerRegisterIf</b></a>, <a href="pr-func2_455y.htm"><b>RpcServerUnregisterIf</b></a></p>
<p>&nbsp;</p></body>
</HTML>
