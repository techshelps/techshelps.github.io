<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Pointers</title>
<link disabled rel=stylesheet href=../../../backsdk3.css>
<style type="text/css">
@import url(../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_rpc_pointers"></a>Pointers</h1>
<p>
It is very efficient to use pointers as C function parameters. The pointer costs only a few bytes and can be used to access a large amount of memory. However, in a distributed application, the client and server procedures can reside in different address spaces on different computers that may not have access to the same memory.</p>
<p>
When one of the remote procedure's parameters is a pointer to an object, the client must transmit a copy of that object and its pointer to the server. If the remote procedure modifies the object through its pointer, the server returns the pointer and its modified copy.</p>
<p>
MIDL offers pointer attributes to minimize the amount of required overhead and the size of your application. For example, you can specify a binary tree using the following definition:</p>
<pre><code>typedef struct _treetype {
    <b>long</b>               lValue;
    struct _treetype * left;
    struct _treetype * right;
} TREETYPE;

TREETYPE * troot;
 </code></pre>
<p>
The contents of a tree node can be accessed by more than one pointer, thus making it more complicated for the RPC support code to manage the data and the pointers. The underlying stub code must resolve the various pointers to the addresses and determine whose copy of the data represents the most recent version.</p>
<p>
The amount of processing can be reduced if you guarantee that your pointer is the only way the application can access that area of memory. The pointer can still have many of the features of a C pointer. For example, it can change between null and non-null values or stay the same. However, as long as the data referenced by the pointer is <a href="ov-arptr_9g1f.htm">unique to the pointer</a>, you can reduce the amount of processing by the stubs. To do this, designate such a pointer by using the <object id=alink_1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink,MENU">
<PARAM name="DefaultTopic" value="../../../notopic_0pk4.htm">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="_rpc_unique">
</object><a href=JavaScript:alink_1.Click()><b>unique</b></a> attribute.</p>
<p>
You can further reduce the complexity if you specify that the non-null pointer to an address of valid memory will not change during the remote call. However, the contents of memory can change and the data returned from the server will be written into this area on the client. To do this, designate such a pointer, known as a <a href="ov-arptr_1z77.htm">reference pointer</a>, by using the <object id=alink_2 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink,MENU">
<PARAM name="DefaultTopic" value="../../../notopic_0pk4.htm">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="_rpc_ref">
</object><a href=JavaScript:alink_2.Click()><b>ref</b></a> attribute.</p>
<p>&nbsp;</p></body>
</HTML>
