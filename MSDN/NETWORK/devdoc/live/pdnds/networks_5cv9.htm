<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Determining the Location of a Share</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h2><a name="_win32_determining_the_location_of_a_share"></a>Determining the Location of a Share</h2>
<p>
<b>Windows NT Only</b></p>
<p>
The following example demonstrates how to use the <a href="networks_9pgl.htm"><b>WNetGetUniversalName</b></a> function to determine the location of a share file on a redirected drive.</p>
<p>
Name the code sample GetUni.cpp and add it to a Windows Consol App project called GetUni and link the libraries SHELL32.LIB,  MPR.LIB, and NETAPI32.LIB to the compiler list of libraries.</p>
<p>
Then from the command prompt, change to the GetUni directory and after compiling GetUni.cpp, run the file GetConn.EXE followed by a drive letter and colon like this:</p>
<pre><code>GetUni H:\

/*
GetUni.cpp  code sample
*/
#define  STRICT
#include &lt;windows.h&gt;
#include &lt;stdio.h&gt;

#define BUFFSIZE = 1000

void main( int argc, char *argv[] )
{
DWORD cbBuff = 1000  //Size of Buffer
  TCHAR szBuff[1000];    //Buffer to receive information
  REMOTE_NAME_INFO  * prni = (REMOTE_NAME_INFO *)   &amp;szBuff;
  //Pointers to head of buffer
  UNIVERSAL_NAME_INFO * puni = (UNIVERSAL_NAME_INFO *) &amp;szBuff;
  DWORD res;

  if((argc &lt; 2) | (lstrcmp(argv[1], "/?") == 0))
  {
    printf("Syntax:  GetUni DrivePathAndFilename\n"
         "Example: GetUni U:\\WINNT\\SYSTEM32\\WSOCK32.DLL\n");
    return;
  }
  
  //Call WNetGetUniversalName using UNIVERSAL_NAME_INFO_LEVEL option
  printf("Call WNetGetUniversalName using UNIVERSAL_NAME_INFO_LEVEL.\n");
  if((res = WNetGetUniversalName((LPTSTR)argv[1],
   UNIVERSAL_NAME_INFO_LEVEL,
   (LPVOID) &amp;szBuff, //Structure is written to this block
   &amp;cbBuff)) != NO_ERROR)     //of memory

    printf("Error: %ld\n\n", res);     //If it fails print the error
else
printf("Universal Name: \t%s\n\n",  //Otherwise print the results
puni-&gt;lpUniversalName);  //using the pointer to the REMOTE_NAME_INFO_LEVEL structure

 //Now call WNetGetUniversalName using the REMOTE_NAME_INFO_LEVEL option
  printf("Call WNetGetUniversalName using REMOTE_NAME_INFO_LEVEL.\n");
  if((res = WNetGetUniversalName((LPTSTR)argv[1], 
     REMOTE_NAME_INFO_LEVEL,     
        (LPVOID) &amp;szBuff,    //Again the structure is written to 
       &amp;cbBuff)) != NO_ERROR)     //this block of memory

    printf("Error: %ld\n", res);    //If it fails print the error
  else
    printf("Universal Name: \t%s\n"    //Otherwise print the results
         "Connection Name:\t%s\n"    //using the pointer to the REMOTE_NAME_INFO_LEVEL structure
       "Remaining Path: \t%s\n",
          prni-&gt;lpUniversalName, 
          prni-&gt;lpConnectionName, 
          prni-&gt;lpRemainingPath);
  return;
}
 </code></pre>
<p>&nbsp;</p></body>
</HTML>
