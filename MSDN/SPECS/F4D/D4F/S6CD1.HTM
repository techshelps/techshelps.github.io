<HTML><HEAD><META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>The MD4 Message Digest Algorithm</TITLE><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">
</OBJECT></FORM>
<H2>The MD4 Message Digest Algorithm</H2>
<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="144pt" VALIGN="TOP"><COL WIDTH="144pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>Network Working Group </P></TD><TD VALIGN="TOP"><P>R. Rivest</P></TD></TR><TR><TD VALIGN="TOP"><P>Request for Comments: 1320</P></TD><TD VALIGN="TOP"><P>MIT Laboratory for Computer Science</P></TD></TR><TR><TD VALIGN="TOP"><P>Obsoletes: RFC 1186  </P></TD><TD VALIGN="TOP"><P>and RSA Data Security, Inc.</P></TD></TR></TBODY></TABLE>
<BR></P><B>April 1992</B></P>
<H3><A NAME="sec0"></A>The MD4 Message-Digest Algorithm</H3><B>Status of this Memo</B></P>
This memo provides information for the Internet community.  It does not specify an Internet standard.  Distribution of this memo is unlimited.</P>
<B>Acknowledgments</B></P>
We would like to thank Don Coppersmith, Burt Kaliski, Ralph Merkle, and Noam Nisan for numerous helpful comments and suggestions.</P>
<B>Table of Contents</B></P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="213pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>Section One: </P></TD><TD VALIGN="TOP"><P>Executive Summary</P></TD></TR><TR><TD VALIGN="TOP"><P>Section Two:</P></TD><TD VALIGN="TOP"><P>Terminology and Notation</P></TD></TR><TR><TD VALIGN="TOP"><P>Section Three:</P></TD><TD VALIGN="TOP"><P>MD4 Algorithm Description</P></TD></TR><TR><TD VALIGN="TOP"><P>Section Four:</P></TD><TD VALIGN="TOP"><P>Summary</P></TD></TR><TR><TD VALIGN="TOP"><P>Section Five:</P></TD><TD VALIGN="TOP"><P>References</P></TD></TR><TR><TD VALIGN="TOP"><P>Section Six:</P></TD><TD VALIGN="TOP"><P>APPENDIX A   Reference Implementation</P></TD></TR><TR><TD VALIGN="TOP"><P>Section Seven:</P></TD><TD VALIGN="TOP"><P>Security Considerations</P></TD></TR><TR><TD VALIGN="TOP"><P>Section Eight:</P></TD><TD VALIGN="TOP"><P>Author's Address</P></TD></TR></TBODY></TABLE>
<BR></P><B>Section One: Executive Summary</B></P>
This document describes the MD4 message-digest algorithm [1]. The algorithm takes as input a message of arbitrary length and produces as output a 128-bit "fingerprint" or "message digest" of the input.   It is conjectured that it is computationally infeasible to produce two messages having the same message digest, or to produce any  message having a given prespecified target message digest. The MD4  algorithm is intended for digital signature applications, where a large file must be "compressed" in a secure manner before being encrypted with a private (secret) key under a public-key cryptosystem such as RSA.</P>
The MD4 algorithm is designed to be quite fast on 32-bit machines. In addition, the MD4 algorithm does not require any large substitution tables; the algorithm can be coded quite compactly.</P>
The MD4 algorithm is being placed in the public domain for review and possible adoption as a standard.  This document replaces the October 1990 RFC 1186 [2].  The main difference is that the reference implementation of MD4 in the  appendix is more portable.</P>
For OSI-based applications, MD4's object identifier is md4 OBJECT IDENTIFIER ::= {iso(1) member-body(2) US(840) rsadsi(113549) digestAlgorithm(2) 4}</P>
In the X.509 type AlgorithmIdentifier [3], the parameters for MD4 should have type NULL.</P>
<B>Section </B><B>Two:  Terminology and Notation</B></P>
In this document a "word" is a 32-bit quantity and a "byte" is an eight-bit quantity. A sequence of bits can be interpreted in a natural manner as a sequence of bytes, where each consecutive group of eight bits is interpreted as a byte with the high-order (most significant) bit of each byte listed first. Similarly, a sequence of bytes can be interpreted as a sequence of 32-bit words, where each consecutive group of four bytes is interpreted as a word with the low-order (least significant) byte given first.</P>
Let x_i denote "x sub i". If the subscript is an expression, we  surround it in braces, as in x_{i+1}. Similarly, we use ^ for   superscripts (exponentiation), so that x^i denotes x to the i-th power.</P>
Let the symbol "+" denote addition of words (i.e., modulo-2^32 addition). Let X &lt;&lt;&lt; s denote the 32-bit value obtained by circularly shifting (rotating) X left by s bit positions. Let not(X) denote the bit-wise complement of X, and let X v Y denote the bit-wise OR of X and Y. Let X xor Y denote the bit-wise XOR of X and Y, and let XY denote the bit-wise AND of X and Y.</P>
<B>Section Three: MD4 Algorithm Description</B></P>
We begin by supposing that we have a b-bit message as input, and that we wish to find its message digest. Here b is an arbitrary nonnegative integer; b may be zero, it need not be a multiple of eight, and it may be arbitrarily large. We imagine the bits of the message written down as follows:</P>
m_0 m_1 ... m_{b-1}</P>
The following five steps are performed to compute the message digest of the message:</P>
<B>Step 1. Append Padding Bits</B></P>
The message is "padded" (extended) so that its length (in bits) is congruent to 448, modulo 512. That is, the message is extended so that it is just 64 bits shy of being a multiple of 512 bits long.  Padding is always performed, even if the length of the message is already congruent to 448, modulo 512.</P>
Padding is performed as follows: a single "1" bit is appended to the message, and then "0" bits are appended so that the length in bits of the padded message becomes congruent to 448, modulo 512. In all, at least one bit and at most 512 bits are appended.</P>
<B>Step 2. Append Length</B></P>
A 64-bit representation of b (the length of the message before the padding bits were added) is appended to the result of the previous step. In the unlikely event that b is greater than 2^64, then only the low-order 64 bits of b are used. (These bits are appended as two 32-bit words and appended low-order word first in accordance with the previous conventions.)</P>
At this point the resulting message (after padding with bits and with  b) has a length that is an exact multiple of 512 bits. Equivalently,  this message has a length that is an exact multiple of 16 (32-bit) words. Let M[0 ... N-1] denote the words of the resulting message, where N is a multiple of 16.</P>
<B>Step 3. Initialize MD Buffer</B></P>
A four-word buffer (A,B,C,D) is used to compute the message digest.  Here each of A, B, C, D is a 32-bit register. These registers are initialized to the following values in hexadecimal, low-order bytes first):</P>
  word A: 01 23 45 67</P>
word B: 89 ab cd ef</P>
word C: fe dc ba 98</P>
  word D: 76 54 32 10</P>
</P>
<B>Step 4. Process Message in 16-Word Blocks</B></P>
We first define three auxiliary functions that each take as input three 32-bit words and produce as output one 32-bit word.</P>
F(X,Y,Z) = XY v not(X) Z</P>
G(X,Y,Z) = XY v XZ v YZ</P>
H(X,Y,Z) = X xor Y xor Z</P>
In each bit position F acts as a conditional: if X then Y else Z.  The function F could have been defined using + instead of v since XY and not(X)Z will never have "1" bits in the same bit position.)  In each bit position G acts as a majority function:  if at least two of X, Y, Z are on, then G has a "1" bit in that bit position, else G has a "0" bit. It is interesting to note that if the bits of X, Y, and Z are independent and unbiased, the each bit of f(X,Y,Z) will be independent and unbiased, and similarly each bit of g(X,Y,Z) will be independent and unbiased. The function H is the bit-wise XOR or parity" function; it has properties similar to those of F and G.</P>
Do the following:</P>
/*Process each 16-word block. */</P>
For i = 0 to N/16-1 do</P>
</P>
/* Copy block i into X. */</P>
For j = 0 to 15 do</P>
    Set X[j] to M[i*16+j].</P>
end /* of loop on j */</P>
</P>
/* Save A as AA, B as BB, C as CC, and D as DD. */</P>
AA = A</P>
BB = B</P>
CC = C</P>
DD = D</P>
</P>
/* Round 1. */</P>
/* Let [abcd k s] denote the operation a = (a + F(b,c,d) + X[k]) &lt;&lt;&lt; s. */</P>
/* Do the following 16 operations. */</P>
[ABCD  0  3]  [DABC  1  7]  [CDAB  2 11]  [BCDA  3 19]</P>
[ABCD  4  3]  [DABC  5  7]  [CDAB  6 11]  [BCDA  7 19]</P>
[ABCD  8  3]  [DABC  9  7]  [CDAB 10 11]  [BCDA 11 19]</P>
[ABCD 12  3]  [DABC 13  7]  [CDAB 14 11]  [BCDA 15 19]</P>
</P>
/* Round 2. */</P>
/* Let [abcd k s] denote the operation a = (a + G(b,c,d) + X[k] + 5A827999) &lt;&lt;&lt; s. */</P>
</P>
 /* Do the following 16 operations. */</P>
[ABCD  0  3]  [DABC  4  5]  [CDAB  8  9]  [BCDA 12 13]</P>
[ABCD  1  3]  [DABC  5  5]  [CDAB  9  9]  [BCDA 13 13]</P>
[ABCD  2  3]  [DABC  6  5]  [CDAB 10  9]  [BCDA 14 13]</P>
[ABCD  3  3]  [DABC  7  5]  [CDAB 11  9]  [BCDA 15 13]</P>
</P>
/* Round 3. */</P>
/* Let [abcd k s] denote the operation a = (a + H(b,c,d) + X[k] + 6ED9EBA1) &lt;&lt;&lt; s. */</P>
/* Do the following 16 operations. */</P>
[ABCD  0  3]  [DABC  8  9]  [CDAB  4 11]  [BCDA 12 15]</P>
[ABCD  2  3]  [DABC 10  9]  [CDAB  6 11]  [BCDA 14 15]</P>
[ABCD  1  3]  [DABC  9  9]  [CDAB  5 11]  [BCDA 13 15]</P>
[ABCD  3  3]  [DABC 11  9]  [CDAB  7 11]  [BCDA 15 15]</P>
</P>
/* Then perform the following additions. (That is, increment each of the four registers by the value it had before this blockwas started.) */</P>
A = A + AA</P>
B = B + BB</P>
C = C + CC</P>
D = D + DD</P>
</P>
end /* of loop on i */</P>
</P>
<B>Note</B>  The value 5A..99 is a hexadecimal 32-bit constant, written with the high-order digit first. This constant represents the square root of 2. The octal value of this constant is 013240474631.</P>
The value 6E..A1 is a hexadecimal 32-bit constant, written with the high-order digit first.  This constant represents the square root of 3. The octal value of this constant is 015666365641.</P>
See Knuth, The Art of Programming, Volume 2 (Seminumerical Algorithms), Second Edition (1981), Addison-Wesley. Table 2, page 660.</P>
<B>Step 5. Output</B></P>
The message digest produced as output is A, B, C, D. That is, we begin with the low-order byte of A, and end with the high-order byte of D.</P>
This completes the description of MD4. A reference implementation in C is given in the appendix.</P>
<B>Section Four:  Summary</B></P>
The MD4 message-digest algorithm is simple to implement, and provides a "fingerprint" or message digest of a message of arbitrary length.  It is conjectured that the difficulty of coming up with two messages having the same message digest is on the order of 2^64 operations, and that the difficulty of coming up with any message having a given message digest is on the order of 2^128 operations. The MD4 algorithm has been carefully scrutinized for weaknesses. It is, however, a relatively new algorithm and further security analysis is of course justified, as is the case with any new proposal of this sort.</P>
<B>Section Five:  References</B></P>
1.    Rivest, R., "The MD4 message digest algorithm", in A.J.Menezes and S.A. Vanstone, editors, Advances in Cryptology - CRYPTO '90 Proceedings, pages 303-311, Springer-Verlag, 1991.</P>
2.    Rivest, R., "The MD4 Message Digest Algorithm", RFC 1186, MIT, October 1990.</P>
3.    CCITT Recommendation X.509 (1988), "The Directory - Authentication Framework".</P>
4.    Rivest, R., "The MD5 Message-Digest Algorithm", RFC 1321, MIT and RSA Data Security, Inc, April 1992.</P>
<B>Section Six:  APPENDIX A - Reference Implementation</B></P>
This appendix contains the following files:</P>
- global.h -- global header file</P>
- md4.h -- header file for MD4</P>
- md4c.c -- source code for MD4</P>
- mddriver.c -- test driver for MD2, MD4 and MD5</P>
The driver compiles for MD5 by default but can compile for MD2 or MD4 if the symbol MD is defined on the C compiler command line as 2 or 4.</P>
The implementation is portable and should work on many different platforms. However, it is not difficult to optimize the implementation on particular platforms, an exercise left to the reader. For example, on "little-endian" platforms where the lowest-addressed byte in a 32-bit word is the least significant and there are no alignment restrictions, the call to Decode in MD4Transform can be replaced with a typecast.</P>
<B>1.  global.h</B></P>
/* GLOBAL.H - RSAREF types and constants */</P>
/* PROTOTYPES should be set to one if and only if the compiler supports function argument prototyping.</P>
The following makes PROTOTYPES default to 0 if it has not already been defined with C compiler flags. */</P>
#ifndef PROTOTYPES</P>
    #define PROTOTYPES 0</P>
#endif</P>
</P>
/* POINTER defines a generic pointer type */</P>
typedef unsigned char *POINTER;</P>
</P>
/* UINT2 defines a two byte word */</P>
typedef unsigned short int UINT2;</P>
</P>
/* UINT4 defines a four byte word */</P>
typedef unsigned long int UINT4;</P>
</P>
/* PROTO_LIST is defined depending on how PROTOTYPES is defined above.  If using PROTOTYPES, then PROTO_LIST returns the list, otherwise it returns an empty list. */</P>
#if PROTOTYPES</P>
    #define PROTO_LIST(list) list</P>
#else</P>
    #define PROTO_LIST(list) ()</P>
#endif</P>
<B>2. md4.h</B></P>
/* MD4.H - header file for MD4C.C */</P>
</P>
/* Copyright (C) 1991-2, RSA Data Security, Inc. Created 1991. </P>
</P>
All rights reserved.</P>
License to copy and use this software is granted provided that it is identified as the "RSA Data Security, Inc. MD4 Message-Digest Algorithm" in all material mentioning or referencing this software or this function.</P>
License is also granted to make and use derivative works provided that such works are identified as "derived from the RSA Data Security, Inc. MD4 Message-Digest Algorithm" in all material mentioning or referencing the derived work.</P>
RSA Data Security, Inc. makes no representations concerning either the merchantability of this software or the suitability of this software for any particular purpose. It is provided "as is" without express or implied warranty of any kind.</P>
These notices must be retained in any copies of any part of this documentation and/or software. */</P>
</P>
/* MD4 context. */</P>
typedef struct {</P>
    UINT4 state[4];                /* state (ABCD) */</P>
    UINT4 count[2];                /* number of bits, modulo 2^64 (lsb first) */</P>
    unsigned char buffer[64];             /* input buffer */</P>
} MD4_CTX;</P>
</P>
void MD4Init PROTO_LIST ((MD4_CTX *));</P>
void MD4Update PROTO_LIST ((MD4_CTX *, unsigned char *, unsigned int));</P>
void MD4Final PROTO_LIST ((unsigned char [16], MD4_CTX *));</P>
<B>3. md4c.c</B></P>
/* MD4C.C - RSA Data Security, Inc., MD4 message-digest algorithm */</P>
/* Copyright (C) 1990-2, RSA Data Security, Inc. All rights reserved.</P>
License to copy and use this software is granted provided that it is identified as the "RSA Data Security, Inc. MD4 Message-Digest Algorithm" in all material mentioning or referencing this software or this function.</P>
License is also granted to make and use derivative works provided that such works are identified as "derived from the RSA Data Security, Inc. MD4 Message-Digest Algorithm" in all material mentioning or referencing the derived work.</P>
RSA Data Security, Inc. makes no representations concerning either the merchantability of this software or the suitability of this software for any particular purpose. It is provided "as is" without express or implied warranty of any kind.</P>
These notices must be retained in any copies of any part of this documentation and/or software. */</P>
</P>
#include "global.h"</P>
#include "md4.h"</P>
</P>
/* Constants for MD4Transform routine.  */</P>
#define S11 3</P>
#define S12 7</P>
#define S13 11</P>
#define S14 19</P>
#define S21 3</P>
#define S22 5</P>
#define S23 9</P>
#define S24 13</P>
#define S31 3</P>
#define S32 9</P>
#define S33 11</P>
#define S34 15</P>
</P>
static void MD4Transform PROTO_LIST ((UINT4 [4], unsigned char [64]));</P>
static void Encode PROTO_LIST ((unsigned char *, UINT4 *, unsigned int));</P>
static void Decode PROTO_LIST ((UINT4 *, unsigned char *, unsigned int));</P>
static void MD4_memcpy PROTO_LIST ((POINTER, POINTER, unsigned int));</P>
static void MD4_memset PROTO_LIST ((POINTER, int, unsigned int));</P>
</P>
static unsigned char PADDING[64] = {</P>
0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0</P>
};</P>
</P>
/* F, G and H are basic MD4 functions. */</P>
#define F(x, y, z) (((x) &amp; (y)) | ((~x) &amp; (z)))</P>
#define G(x, y, z) (((x) &amp; (y)) | ((x) &amp; (z)) | ((y) &amp; (z)))</P>
#define H(x, y, z) ((x) ^ (y) ^ (z))</P>
</P>
/* ROTATE_LEFT rotates x left n bits. */</P>
#define ROTATE_LEFT(x, n) (((x) &lt;&lt; (n)) | ((x) &gt;&gt; (32-(n))))</P>
</P>
/* FF, GG and HH are transformations for rounds 1, 2 and 3 */</P>
/* Rotation is separate from addition to prevent recomputation */</P>
#define FF(a, b, c, d, x, s) {(a) += F ((b), (c), (d)) + (x); (a) = ROTATE_LEFT ((a), (s));}</P>
</P>
#define GG(a, b, c, d, x, s) {(a) += G ((b), (c), (d)) + (x) + (UINT4)0x5a827999; (a) = ROTATE_LEFT ((a), (s));}</P>
</P>
#define HH(a, b, c, d, x, s) {(a) += H ((b), (c), (d)) + (x) + (UINT4)0x6ed9eba1; (a) = \</P>
ROTATE_LEFT ((a), (s)); }</P>
</P>
</P>
/* MD4 initialization. Begins an MD4 operation, writing a new context. */</P>
void MD4Init (context)</P>
MD4_CTX *context;                 /* context */</P>
{</P>
    context-&gt;count[0] = context-&gt;count[1] = 0;</P>
</P>
/* Load magic initialization constants.*/</P>
context-&gt;state[0] = 0x67452301;</P>
context-&gt;state[1] = 0xefcdab89;</P>
context-&gt;state[2] = 0x98badcfe;</P>
context-&gt;state[3] = 0x10325476;</P>
}</P>
</P>
/* MD4 block update operation. Continues an MD4 message-digest operation, processing another message block, and updating the context. */</P>
void MD4Update (context, input, inputLen)</P>
</P>
MD4_CTX *context;                 /* context */</P>
unsigned char *input;                /* input block */</P>
unsigned int inputLen;                /* length of input block */</P>
</P>
{</P>
    unsigned int i, index, partLen;</P>
</P>
/* Compute number of bytes mod 64 */</P>
index = (unsigned int)((context-&gt;count[0] &gt;&gt; 3) &amp; 0x3F);</P>
</P>
/* Update number of bits */</P>
if ((context-&gt;count[0] += ((UINT4)inputLen &lt;&lt; 3))&lt; ((UINT4)inputLen &lt;&lt; 3))</P>
    context-&gt;count[1]++;</P>
    context-&gt;count[1] += ((UINT4)inputLen &gt;&gt; 29);</P>
</P>
    partLen = 64 - index;</P>
</P>
    /* Transform as many times as possible.*/</P>
    if (inputLen &gt;= partLen) {</P>
         MD4_memcpy((POINTER)&amp;context-&gt;buffer[index], (POINTER)input, partLen);</P>
         MD4Transform (context-&gt;state, context-&gt;buffer);</P>
</P>
     for (i = partLen; i + 63 &lt; inputLen; i += 64)</P>
         MD4Transform (context-&gt;state, &amp;input[i]);</P>
</P>
     index = 0;</P>
    }</P>
    else</P>
         i = 0;</P>
</P>
        /* Buffer remaining input */</P>
        MD4_memcpy ((POINTER)&amp;context-&gt;buffer[index], (POINTER)&amp;input[i], inputLen-i);</P>
    }</P>
</P>
</P>
/* MD4 finalization. Ends an MD4 message-digest operation, writing the the message digest and zeroizing the context. */</P>
void MD4Final (digest, context)</P>
</P>
unsigned char digest[16];                 /* message digest */</P>
MD4_CTX *context;                 /* context */</P>
</P>
{</P>
    unsigned char bits[8];</P>
    unsigned int index, padLen;</P>
</P>
    /* Save number of bits */</P>
    Encode (bits, context-&gt;count, 8);</P>
</P>
    /* Pad out to 56 mod 64.*/</P>
    index = (unsigned int)((context-&gt;count[0] &gt;&gt; 3) &amp; 0x3f);</P>
    padLen = (index &lt; 56) ? (56 - index) : (120 - index);</P>
    MD4Update (context, PADDING, padLen);</P>
</P>
    /* Append length (before padding) */</P>
    MD4Update (context, bits, 8);</P>
    </P>
    /* Store state in digest */</P>
    Encode (digest, context-&gt;state, 16);</P>
</P>
    /* Zeroize sensitive information.*/</P>
    MD4_memset ((POINTER)context, 0, sizeof (*context));</P>
}</P>
</P>
</P>
/* MD4 basic transformation. Transforms state based on block. */</P>
static void MD4Transform (state, block)</P>
</P>
UINT4 state[4];</P>
unsigned char block[64];</P>
</P>
{</P>
    UINT4 a = state[0], b = state[1], c = state[2], d = state[3], x[16];</P>
</P>
    Decode (x, block, 64);</P>
</P>
/* Round 1 */</P>
FF (a, b, c, d, x[ 0], S11);                 /* 1 */</P>
FF (d, a, b, c, x[ 1], S12);                 /* 2 */</P>
FF (c, d, a, b, x[ 2], S13);                 /* 3 */</P>
FF (b, c, d, a, x[ 3], S14);                 /* 4 */</P>
FF (a, b, c, d, x[ 4], S11);                 /* 5 */</P>
FF (d, a, b, c, x[ 5], S12);                 /* 6 */</P>
FF (c, d, a, b, x[ 6], S13);                 /* 7 */</P>
FF (b, c, d, a, x[ 7], S14);                 /* 8 */</P>
FF (a, b, c, d, x[ 8], S11);                 /* 9 */</P>
FF (d, a, b, c, x[ 9], S12);                 /* 10 */</P>
FF (c, d, a, b, x[10], S13);             /* 11 */</P>
FF (b, c, d, a, x[11], S14);             /* 12 */</P>
FF (a, b, c, d, x[12], S11);             /* 13 */</P>
FF (d, a, b, c, x[13], S12);             /* 14 */</P>
FF (c, d, a, b, x[14], S13);             /* 15 */</P>
FF (b, c, d, a, x[15], S14);             /* 16 */</P>
</P>
/* Round 2 */</P>
GG (a, b, c, d, x[ 0], S21);             /* 17 */</P>
GG (d, a, b, c, x[ 4], S22);             /* 18 */</P>
GG (c, d, a, b, x[ 8], S23);             /* 19 */</P>
GG (b, c, d, a, x[12], S24);             /* 20 */</P>
GG (a, b, c, d, x[ 1], S21);             /* 21 */</P>
GG (d, a, b, c, x[ 5], S22);             /* 22 */</P>
GG (c, d, a, b, x[ 9], S23);             /* 23 */</P>
GG (b, c, d, a, x[13], S24);             /* 24 */</P>
GG (a, b, c, d, x[ 2], S21);             /* 25 */</P>
GG (d, a, b, c, x[ 6], S22);             /* 26 */</P>
GG (c, d, a, b, x[10], S23);             /* 27 */</P>
GG (b, c, d, a, x[14], S24);             /* 28 */</P>
GG (a, b, c, d, x[ 3], S21);             /* 29 */</P>
GG (d, a, b, c, x[ 7], S22);             /* 30 */</P>
GG (c, d, a, b, x[11], S23);             /* 31 */</P>
GG (b, c, d, a, x[15], S24);             /* 32 */</P>
</P>
/* Round 3 */</P>
HH (a, b, c, d, x[ 0], S31);                /* 33 */</P>
HH (d, a, b, c, x[ 8], S32);             /* 34 */</P>
HH (c, d, a, b, x[ 4], S33);             /* 35 */</P>
HH (b, c, d, a, x[12], S34);             /* 36 */</P>
HH (a, b, c, d, x[ 2], S31);             /* 37 */</P>
HH (d, a, b, c, x[10], S32);             /* 38 */</P>
HH (c, d, a, b, x[ 6], S33);             /* 39 */</P>
HH (b, c, d, a, x[14], S34);             /* 40 */</P>
HH (a, b, c, d, x[ 1], S31);             /* 41 */</P>
HH (d, a, b, c, x[ 9], S32);             /* 42 */</P>
HH (c, d, a, b, x[ 5], S33);             /* 43 */</P>
HH (b, c, d, a, x[13], S34);             /* 44 */</P>
HH (a, b, c, d, x[ 3], S31);             /* 45 */</P>
HH (d, a, b, c, x[11], S32);             /* 46 */</P>
HH (c, d, a, b, x[ 7], S33);             /* 47 */</P>
HH (b, c, d, a, x[15], S34);            /* 48 */</P>
</P>
state[0] += a;</P>
state[1] += b;</P>
state[2] += c;</P>
state[3] += d;</P>
</P>
    /* Zeroize sensitive information.*/</P>
    MD4_memset ((POINTER)x, 0, sizeof (x));</P>
}</P>
</P>
</P>
/* Encodes input (UINT4) into output (unsigned char). Assumes len is a multiple of 4. */</P>
</P>
static void Encode (output, input, len)</P>
unsigned char *output;</P>
UINT4 *input;</P>
unsigned int len;</P>
</P>
{</P>
    unsigned int i, j;</P>
</P>
    for (i = 0, j = 0; j &lt; len; i++, j += 4) {</P>
         output[j] = (unsigned char)(input[i] &amp; 0xff);</P>
         output[j+1] = (unsigned char)((input[i] &gt;&gt; 8) &amp; 0xff);</P>
         output[j+2] = (unsigned char)((input[i] &gt;&gt; 16) &amp; 0xff);</P>
         output[j+3] = (unsigned char)((input[i] &gt;&gt; 24) &amp; 0xff);</P>
    }</P>
}</P>
</P>
</P>
/* Decodes input (unsigned char) into output (UINT4). Assumes len is a multiple of 4. */</P>
static void Decode (output, input, len)</P>
</P>
UINT4 *output;</P>
unsigned char *input;</P>
unsigned int len;</P>
</P>
{</P>
unsigned int i, j;</P>
</P>
for (i = 0, j = 0; j &lt; len; i++, j += 4)</P>
     output[i] = ((UINT4)input[j]) | (((UINT4)input[j+1]) &lt;&lt; 8) | (((UINT4)input[j+2]) &lt;&lt; 16) | \    (((UINT4)input[j+3]) &lt;&lt; 24);</P>
}</P>
</P>
/* Note: Replace "for loop" with standard memcpy if possible. */</P>
static void MD4_memcpy (output, input, len)</P>
POINTER output;</P>
POINTER input;</P>
unsigned int len;</P>
{</P>
unsigned int i;</P>
</P>
for (i = 0; i &lt; len; i++)</P>
     output[i] = input[i];</P>
}</P>
</P>
</P>
/* Note: Replace "for loop" with standard memset if possible. */</P>
static void MD4_memset (output, value, len)</P>
</P>
POINTER output;</P>
int value;</P>
unsigned int len;</P>
</P>
{</P>
unsigned int i;</P>
</P>
for (i = 0; i &lt; len; i++)</P>
    ((char *)output)[i] = (char)value;</P>
}</P>
<B>4. mddriver.c</B></P>
/* MDDRIVER.C - test driver for MD2, MD4 and MD5 */</P>
</P>
/* Copyright (C) 1990-2, RSA Data Security, Inc. Created 1990. </P>
</P>
All  rights reserved.</P>
RSA Data Security, Inc. makes no representations concerning either the merchantability of this software or the suitability of this software for any particular purpose. It is provided "as is" without express or implied warranty of any kind.</P>
These notices must be retained in any copies of any part of this documentation and/or software. */</P>
/* The following makes MD default to MD5 if it has not already been defined with C compiler flags. */</P>
#ifndef MD</P>
    #define MD MD5</P>
#endif</P>
</P>
#include &lt;stdio.h&gt;</P>
#include &lt;time.h&gt;</P>
#include &lt;string.h&gt;</P>
#include "global.h"</P>
#if MD == 2</P>
    #include "md2.h"</P>
#endif</P>
#if MD == 4</P>
    #include "md4.h"</P>
#endif</P>
#if MD == 5</P>
    #include "md5.h"</P>
#endif</P>
</P>
/* Length of test block, number of test blocks. */</P>
#define TEST_BLOCK_LEN 1000</P>
#define TEST_BLOCK_COUNT 1000</P>
</P>
static void MDString PROTO_LIST ((char *));</P>
static void MDTimeTrial PROTO_LIST ((void));</P>
static void MDTestSuite PROTO_LIST ((void));</P>
static void MDFile PROTO_LIST ((char *));</P>
static void MDFilter PROTO_LIST ((void));</P>
static void MDPrint PROTO_LIST ((unsigned char [16]));</P>
</P>
#if MD == 2</P>
    #define MD_CTX MD2_CTX</P>
    #define MDInit MD2Init</P>
    #define MDUpdate MD2Update</P>
    #define MDFinal MD2Final</P>
#endif</P>
#if MD == 4</P>
    #define MD_CTX MD4_CTX</P>
    #define MDInit MD4Init</P>
    #define MDUpdate MD4Update</P>
    #define MDFinal MD4Final</P>
#endif</P>
#if MD == 5</P>
    #define MD_CTX MD5_CTX</P>
    #define MDInit MD5Init</P>
    #define MDUpdate MD5Update</P>
    #define MDFinal MD5Final</P>
#endif</P>
</P>
</P>
/* Main driver.</P>
</P>
Arguments (may be any combination):</P>
-sstring - digests string</P>
-t - runs time trial</P>
-x - runs test script</P>
filename - digests file</P>
(none)- digests standard input */</P>
</P>
int main (argc, argv)</P>
int argc;</P>
char *argv[];</P>
{</P>
    int i;</P>
</P>
    if (argc &gt; 1)</P>
         for (i = 1; i &lt; argc; i++)</P>
             if (argv[i][0] == '-' &amp;&amp; argv[i][1] == 's')</P>
                MDString (argv[i] + 2);</P>
             else if (strcmp (argv[i], "-t") == 0)</P>
                MDTimeTrial ();</P>
             else if (strcmp (argv[i], "-x") == 0)</P>
                MDTestSuite ();</P>
             else</P>
                MDFile (argv[i]);</P>
    else</P>
         MDFilter ();</P>
</P>
return (0);</P>
}</P>
</P>
</P>
/* Digests a string and prints the result. */</P>
static void MDString (string)</P>
</P>
char *string;</P>
</P>
{</P>
    MD_CTX context;</P>
    unsigned char digest[16];</P>
    unsigned int len = strlen (string);</P>
</P>
    MDInit (&amp;context);</P>
    MDUpdate (&amp;context, string, len);</P>
    MDFinal (digest, &amp;context);</P>
</P>
    printf ("MD%d (\"%s\") = ", MD, string);</P>
    MDPrint (digest);</P>
    printf ("\n");</P>
}</P>
</P>
</P>
/* Measures the time to digest TEST_BLOCK_COUNT TEST_BLOCK_LEN-byte blocks. */</P>
static void MDTimeTrial ()</P>
</P>
{</P>
MD_CTX context;</P>
time_t endTime, startTime;</P>
unsigned char block[TEST_BLOCK_LEN], digest[16];</P>
unsigned int i;</P>
</P>
printf ("MD%d time trial. Digesting %d %d-byte blocks ...", MD, TEST_BLOCK_LEN,\ TEST_BLOCK_COUNT);</P>
</P>
/* Initialize block */</P>
for (i = 0; i &lt; TEST_BLOCK_LEN; i++)</P>
     block[i] = (unsigned char)(i &amp; 0xff);</P>
</P>
/* Start timer */</P>
time (&amp;startTime);</P>
</P>
/* Digest blocks */</P>
MDInit (&amp;context);</P>
for (i = 0; i &lt; TEST_BLOCK_COUNT; i++)</P>
     MDUpdate (&amp;context, block, TEST_BLOCK_LEN);</P>
MDFinal (digest, &amp;context);</P>
</P>
/* Stop timer */</P>
time (&amp;endTime);</P>
</P>
printf (" done\n");</P>
printf ("Digest = ");</P>
MDPrint (digest);</P>
</P>
printf ("\nTime = %ld seconds\n", (long)(endTime-startTime));</P>
printf ("Speed = %ld bytes/second\n", (long)TEST_BLOCK_LEN * (long)TEST_BLOCK_COUNT/(endTime -\   startTime));</P>
}</P>
</P>
/* Digests a reference suite of strings and prints the results. */</P>
static void MDTestSuite ()</P>
</P>
{</P>
printf ("MD%d test suite:\n", MD);</P>
</P>
MDString ("");</P>
MDString ("a");</P>
MDString ("abc");</P>
MDString ("message digest");</P>
MDString ("abcdefghijklmnopqrstuvwxyz");</P>
MDString ("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789");</P>
MDString ("12345678901234567890123456789012345678901234567890123456789012345678901234567890");</P>
}</P>
</P>
</P>
/* Digests a file and prints the result. */</P>
static void MDFile (filename)</P>
</P>
char *filename;</P>
</P>
{</P>
FILE *file;</P>
MD_CTX context;</P>
int len;</P>
unsigned char buffer[1024], digest[16];</P>
</P>
if ((file = fopen (filename, "rb")) == NULL)</P>
     printf ("%s can't be opened\n", filename);</P>
</P>
else </P>
    {</P>
     MDInit (&amp;context);</P>
     while (len = fread (buffer, 1, 1024, file))</P>
         MDUpdate (&amp;context, buffer, len);</P>
         MDFinal (digest, &amp;context);</P>
</P>
     fclose (file);</P>
</P>
     printf ("MD%d (%s) = ", MD, filename);</P>
     MDPrint (digest);</P>
     printf ("\n");</P>
    }</P>
}</P>
</P>
</P>
/* Digests the standard input and prints the result. */</P>
static void MDFilter ()</P>
</P>
{</P>
MD_CTX context;</P>
int len;</P>
unsigned char buffer[16], digest[16];</P>
</P>
MDInit (&amp;context);</P>
while (len = fread (buffer, 1, 16, stdin))</P>
     MDUpdate (&amp;context, buffer, len);</P>
MDFinal (digest, &amp;context);</P>
MDPrint (digest);</P>
printf ("\n");</P>
}</P>
/* Prints a message digest in hexadecimal. */</P>
static void MDPrint (digest)</P>
</P>
unsigned char digest[16];</P>
{</P>
unsigned int i;</P>
</P>
for (i = 0; i &lt; 16; i++)</P>
     printf ("%02x", digest[i]);</P>
}</P>
<B>5. Test suite</B></P>
The MD4 test suite (driver option "-x") should print the following results:</P>
MD4 test suite:</P>
MD4 ("") = 31d6cfe0d16ae931b73c59d7e0c089c0</P>
MD4 ("a") = bde52cb31de33e46245e05fbdbd6fb24</P>
MD4 ("abc") = a448017aaf21d8525fc10ae87aa6729d</P>
MD4 ("message digest") = d9130a8164549fe818874806e1c7014b</P>
MD4 ("abcdefghijklmnopqrstuvwxyz") = d79e1c308aa5bbcdeea8ed63df412da9</P>
MD4 ("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789") =</P>
043f8582f241db351ce627e153e7f0e4</P>
MD4 ("123456789012345678901234567890123456789012345678901234567890123456</P>
78901234567890") = e33b4ddc9c38f2199c3e7b164fcc0536</P>
<B>Section Seven:  Security Considerations</B></P>
The level of security discussed in this memo is considered to be sufficient for implementing moderate security hybrid digital-signature schemes based on MD4 and a public-key cryptosystem. We do not know of any reason that MD4 would not be sufficient for implementing very high security digital-signature schemes, but because MD4 was designed to be exceptionally fast, it is "at the edge" in terms of risking successful cryptanalytic attack. After further critical review, it may be appropriate to consider MD4 for very high security applications. For very high security applications before the completion of that review, the MD5 algorithm [4] is recommended.</P>
<B>Section Eight:  Author's Address</B></P>
Ronald L. Rivest<BR>Massachusetts Institute of Technology<BR>Laboratory for Computer Science<BR>NE43-324<BR>545 Technology Square<BR>Cambridge, MA02139-1986<BR>Phone: (617) 253-5880<BR>EMail: rivest@theory.lcs.mit.edu</P></BODY></HTML>
