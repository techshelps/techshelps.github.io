<HTML><HEAD><META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Steps</TITLE><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">
</OBJECT></FORM>
<H2>Steps</H2>This section outlines a set of basic steps that a software publisher might follow to incorporate the LSAPI calls into an application.</P>
1.    Select a unique publisher (company) name. This name, which may be up to 32 characters long,  should include a trademarked name and be the same for all applications that your company develops.</P>
2.    Select a unique product (application) name within the company (publisher) domain. This name must be unique within the first 32 characters. Over the life of an application, the product name usually remains unchanged.</P>
3.    Select a unique version string within the application (product) domain. The version string is used to differentiate multiple versions.</P>
4.    Determine the number of different sets of secrets that are likely to be issued. For purposes of example, four sets are chosen:</P>
    Set 1</P>
    Set 2</P>
    Set 3</P>
    Set 4</P>
5.    Now it is time to select the individual <I>secrets</I> which make up the sets. For each set, choose one or more random secrets:</P>
<P></P>

<TABLE COLS="5" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="72pt" VALIGN="TOP"><COL WIDTH="72pt" VALIGN="TOP"><COL WIDTH="72pt" VALIGN="TOP"><COL WIDTH="72pt" VALIGN="TOP"><COL WIDTH="72pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>Secret Set</P></TD><TD VALIGN="TOP"><P>Secret 1</P></TD><TD VALIGN="TOP"><P>Secret 2</P></TD><TD VALIGN="TOP"><P>Secret 3</P></TD><TD VALIGN="TOP"><P>Secret 4</P></TD></TR><TR><TD VALIGN="TOP"><P>     Set 1</P></TD><TD VALIGN="TOP"><P>0x84FE31</P></TD><TD VALIGN="TOP"><P>0x24178</P></TD><TD VALIGN="TOP"><P>0x36EAB</P></TD><TD VALIGN="TOP"><P>0xAB213</P></TD></TR><TR><TD VALIGN="TOP"><P>     Set 2</P></TD><TD VALIGN="TOP"><P>0x84FE31</P></TD><TD VALIGN="TOP"><P>0x1012A</P></TD><TD VALIGN="TOP"><P>0x34784</P></TD><TD VALIGN="TOP"><P>0xAB213</P></TD></TR><TR><TD VALIGN="TOP"><P>     Set 3</P></TD><TD VALIGN="TOP"><P>0x84FE31</P></TD><TD VALIGN="TOP"><P>0xA6170</P></TD><TD VALIGN="TOP"><P>0x62834</P></TD><TD VALIGN="TOP"><P>0x1074E</P></TD></TR><TR><TD VALIGN="TOP"><P>     Set 4</P></TD><TD VALIGN="TOP"><P>0x84FE31</P></TD><TD VALIGN="TOP"><P>0x71F45</P></TD><TD VALIGN="TOP"><P>0xD6189</P></TD><TD VALIGN="TOP"><P>0x86753</P></TD></TR></TBODY></TABLE>
<BR></P>In this example, the same secret value was chosen for Secret 1 for all four sets. This allows the application to always challenge Secret 1 in the LSRequest(), yet differentiate subsequent challenges through LSUpdate(). The use of the sets is up to the software developer (e.g., each set can represent a different licensing policy if desired).</P>
6.    Embed the challenge algorithms in the application. Some effort will be required to obscure the code and associated data (see the <I>Anti-Tampering Guidelines</I> on page 25). </P>
7.    Add the LSRequest() and LSRelease() calls to the application.. Also include periodic calls to LSUpdate(), as appropriate.</P>
8.    Select the specific LSAPI-compliant license systems for which you wish to issue licenses. For operating system platforms which allow shared or dynamically linked libraries, the set of supported license systems may be expanded after the software product has shipped, provided that the software application does not require license system specific functionality.</P>
Those are the basic steps.</P>
It is not the intent of this specification to offer recommendations on how to handle various error codes. However, the software publisher should carefully consider the implications of the decisions that he or she makes. For example, should an application be allowed to run if the network is unavailable? What if there are no more licenses available? Organizations such as the Microcomputer Managers Association and the Software Publishers Association can offer recommendations to these and other important questions.</P>
<H3><A NAME="sec0"></A>Application Code Example</H3>The following code provides an example of licensing an application with the LSAPI.  This code demonstrates several useful approaches to various situations, utilizing the LSAPI.</P>
First, GetMyLicense(), the section of code which obtains the required units, demonstrates how error codes can be displayed for each individual provider when a license is not obtainable.  This allows the user the capability of determining what caused the failure to obtain the required units, for each individual license provider.  This function will display the error for each provider, as they occur.</P>
Second, the functions which create the challenge query/response, are designed to work on both big endian machines (ex. Sun ) and little endian machines (ex. intel 80x86 family).  If your target machine has the little endian architecture, LITTLE_ENDIAN needs to be defined.</P>
Finally, the update portion of code, PerformUpdate(), could be placed into an automatic scheduler, if one is available on your specific platform, to simplify the update process.</P>
Please note that this code is meant for clarity.  It is a little more verbose than might otherwise be required for your application.  Further, since the code is example code, it is very straight forward in its operations. This should not be a goal in the creation of the licensing code for your applications.  The licensing code should be obfuscated so as to hide its apparent purpose, making it more difficult to subvert. </P>
#include &lt;stdio.h&gt;</P>
#include &lt;stdlib.h&gt;</P>
#include &lt;mem.h&gt;</P>
#include &lt;string.h&gt;</P>
#include &lt;lsapi.h&gt;</P>
</P>
#define MY_PUBLISHER_NAME "ACME(tm) SoftWare Vendor, Inc."</P>
#define MY_PRODUCT_NAME "ACME Number Cruncher"</P>
#define MY_VERSION "Vrsn 0.0a"</P>
#define LOG_COMMENT "ACME requested a license"</P>
</P>
LS_ULONG secrets[4] = {0x1234, 0x4321, 0xABCD, 0xDCBA}</P>
</P>
#if defined(LITTLE_ENDIAN)</P>
    void swap(LS_UCHAR *byte1, LS_UCHAR *byte2)</P>
    {</P>
        LS_UCHAR    tmp;</P>
        tmp = *byte2;</P>
        *byte2 = *byte1;</P>
        *byte1 = tmp;</P>
    }</P>
#endif // LITTLE_ENDIAN</P>
</P>
//</P>
// PlaceInt32() will place a 32 bit integer (signed/unsigned) into the</P>
// provided buffer in the required format for challenge processing.  It</P>
// will return the amount of bytes consumed in the buffer.</P>
//</P>
int PlaceInt32(char *buffer, LS_ULONG value)</P>
{</P>
    // if we are on a little endian machine, we need to re-order the bytes</P>
    #if defined(LITTLE_ENDIAN)</P>
        swap(&amp;(((char *) &amp;value)[0]), &amp;(((char *) &amp;value)[3]));</P>
        swap(&amp;(((char *) &amp;value)[1]), &amp;(((char *) &amp;value)[2]));</P>
    #endif // LITTLE_ENDIAN</P>
    // place the value into the buffer</P>
    *(LS_ULONG *) buffer = value;</P>
    return((int) sizeof(LS_ULONG));</P>
}</P>
</P>
//</P>
// PlaceString() will place an LSAPI string into the supplied buffer, the</P>
// number of bytes occupied will be returned.  The NULL terminator will not</P>
// be copied.</P>
//</P>
int PlaceString(char *buffer, LS_UCHAR *str)</P>
{</P>
    memcpy(buffer, str, strlen(str));</P>
    return((int) strlen(str));</P>
}</P>
</P>
//</P>
// PlaceSecrets() will put the random number, secret number and the secret</P>
// into the supplied buffer in the proper format.  The number of bytes that</P>
// these values occupy in the buffer will be returned.</P>
//</P>
int PlaceSecrets(char *buffer, LS_CHALLENGE *challengeStruct)</P>
{</P>
    char    *bptr;</P>
    int    buffLen, bytes;</P>
</P>
    // initialize the pointers</P>
    bptr = buffer;</P>
    buffLen = 0;</P>
    // place the random number</P>
    bytes = PlaceInt32(bptr, challengeStruct-&gt;ChallengeData.Random);</P>
    bptr+= bytes;</P>
    buffLen+= bytes;</P>
    // place the secret index</P>
    bytes = PlaceInt32(bptr, challengeStruct-&gt;ChallengeData.SecretIndex);</P>
    bptr+= bytes;</P>
    buffLen+= bytes;</P>
    // place the secret itself</P>
    bytes = PlaceInt32(bptr, secrets[challengeStruct-&gt;ChallengeData.Secret[Index]);</P>
    buffLen+= bytes;</P>
    return(buffLen);</P>
}</P>
</P>
//</P>
// PlaceRequestInParameters() will place all of the input parameters for</P>
// an LSRequest call.  It will return the number of bytes it has placed</P>
// into the provided buffer.  The buffer is assumed to be large enough to</P>
// hold all of the arguments</P>
//</P>
int    PlaceRequestInParameters(char *argBuff, LS_UCHAR *LicenseSystem, LS_UCHAR *PublisherName, LS_UCHAR *ProductName, LS_UCHAR *Version, LS_ULONG TotUnitsReserved, LS_UCHAR *LogComment)</P>
{</P>
    char    *bptr;</P>
    int    bytes, buffLen;</P>
</P>
    bytes = 0;</P>
    buffLen = 0;</P>
    bptr = argBuff;</P>
    // place the function name</P>
    bytes = PlaceString(bptr, "LSRequest");</P>
    bptr+= bytes;</P>
    buffLen+= bytes;</P>
    // place the arguments</P>
    bytes = PlaceString(bptr, LicenseSystem);</P>
    bptr+= bytes;</P>
    buffLen+= bytes;</P>
    bytes = PlaceString(bptr, PublisherName);</P>
    bptr+= bytes;</P>
    buffLen+= bytes;</P>
    bytes = PlaceString(bptr, ProductName);</P>
    bptr+= bytes;</P>
    buffLen+= bytes;</P>
    bytes = PlaceString(bptr, Version);</P>
    bptr+= bytes;</P>
    buffLen+= bytes;</P>
    bytes = PlaceInt32(bptr, TotUnitsReserved);</P>
    bptr+= bytes</P>
    buffLen+= bytes;</P>
    bytes = PlaceString(bptr, LogComment);</P>
    bptr+= bytes;</P>
    buffLen+= bytes;</P>
    return(buffLen);</P>
}</P>
</P>
//</P>
// PlaceUpdateInParameters() will place the input parameters for an LSUpdate</P>
// call into the specified buffer.  The number of bytes occupied by this info</P>
// will be returned.  The buffer is assumed to be large enough to hold all of</P>
// the arguments</P>
int PlaceUpdateInParameters(char *argBuff, LS_HANDLE LicenseHandle, LS_ULONG TotUnitsConsumed, LS_ULONG TotUnitsReserved, LS_UCHAR *LogComment)</P>
{</P>
    int    bufferLen;</P>
    char    *bPtr;</P>
</P>
    bufferLen = 0;</P>
    bPtr = argBuff;</P>
    // place the function name</P>
    bytes = PlaceString(bPtr, "LSUpdate");</P>
    // place the arguments</P>
    bytes = PlaceInt32(bPtr, LicenseHandle);</P>
    bPtr+= bytes;</P>
    bufferLen+= bytes;</P>
    bytes = PlaceInt32(bPtr, TotUnitsConsumed);</P>
    bPtr+= bytes</P>
    bufferLen+= bytes;</P>
    bytes = PlaceInt32(bPtr, TotUnitsReserved);</P>
    bPtr+= bytes;</P>
    bufferLen+= bytes;</P>
    bytes = PlaceString(bPtr, LogComment);</P>
    bPtr+= bytes;</P>
    bufferLen+= bytes;</P>
    return(bufferLen);</P>
}</P>
</P>
</P>
//</P>
// void CreateChallengeQuery() will create the input challenge based on</P>
// the supplied parameters. It will return a complete challenge structure,</P>
// utilizing the basic challenge protocol, which is the ready to pass to any</P>
// LSAPI function which requires a challenge.</P>
//</P>
void CreateRequestChallengeQuery(LS_UCHAR *LicenseSystem, LS_UCHAR *PublisherName,LS_UCHAR *ProductName, LS_UCHAR *Version, LS_ULONG TotUnitsReserved,LS_UCHAR *LogComment, LS_CHALLENGE *challengeStruct)</P>
{</P>
    char    *argbuff, *bptr;</P>
    int    buffLen, bytes;</P>
</P>
    // Indicate that we are using the basic protocol</P>
    challengeStruct-&gt;Protocol = LS_BASIC_PROTOCOL;</P>
    // Indicate the size of the challenge data structure to the provider</P>
    challengeStruct-&gt;Size = sizeof(LS_CHALLDATA);</P>
    // Pick a random number, from 0 to maximum value</P>
    challengeStruct-&gt;ChallengeData.Random = random(0xFFFFFFFF);</P>
    // Pick a random secret value from 1 to 4</P>
    challengeStruct-&gt;ChallengeData.SecretIndex = (challengeData-&gt;ulRandom % 4) + 1;</P>
    // Create the buffer for the message digest</P>
argbuff = (char *) malloc(strlen("LSRequest") + strlen(LicenseSystem) + 1 + strlen(PublisherName) +  trlen(ProductName) + 1 + strlen(Version) + 1 + sizeof(LS_ULONG) + strlen(LogComment) + 1 + sizeof(LS_ULONG) + sizeof(LS_ULONG) + 4);</P>
    bptr = argbuff;</P>
    // place the arguments</P>
buffLen = PlaceRequestInParameters(argbuff, LicenseSystem, PublisherName, ProductName, Version, TotUnitsReserved, LogComment);</P>
    bptr+= buffLen;</P>
    // Place the random number, secret number, secret</P>
    bytes = PlaceSecrets(bptr, challengeStruct);</P>
    buffLen+= bytes;</P>
    // Compute the Message Digest</P>
    ComputeMD4(argbuff, buffLen,</P>
        challengeStruct-&gt;ChallengeData.MsgDigest.MessageDigest);</P>
}</P>
</P>
//</P>
// CreateRequestChallengeResponse() will form what the provider should</P>
// respond with for a challenge on an LSRequest call.  This value will be</P>
// returned in messageDigest.  This value can be compared with the value</P>
// returned by the provider to determine the provider's validity.</P>
//</P>
void CreateRequestChallengeResponse(LS_UCHAR *LicenseSystem, LS_UCHAR *PublisherName, LS_UCHAR *ProductName, LS_UCHAR *Version, LS_ULONG TotUnitsReserved, LS_UCHAR LogComment,  LS_ULONG totUnitsGranted, LS_STATUS_CODE Status, LS_CHALLENGE *challengeStruct, LS_UCHAR *messageDigest)</P>
{</P>
    char *argbuff, *bptr;</P>
    int buffLen, bytes;</P>
</P>
    // Create the buffer for the message digest</P>
argbuff = (char *) malloc(strlen("LSRequest") + strlen(LicenseSystem) + 1 + strlen(PublisherName) + 1 + strlen(ProductName) + 1 + strlen(Version) + 1 + sizeof(LS_ULONG) + strlen(LogComment) + 1 + sizeof(LS_ULONG) + sizeof(LS_ULONG) + sizeof(LS_ULONG) +sizeof(LS_ULONG) + sizeof(LS_HANDLE) + 4);</P>
    bptr = argbuff;</P>
    // place the arguments</P>
buffLen = PlaceRequestInParameters(argbuff, LicenseSystem, PublisherName, ProductName, Version, TotUnitsReserved, LogComment);</P>
    bptr+= buffLen;</P>
    // place the output parameters</P>
    bytes = PlaceInt32(bptr, totUnitsGranted);</P>
    bptr+= bytes;</P>
    buffLen+= bytes;</P>
    bytes = PlaceInt32(bptr, Status);</P>
    bptr+= bytes;</P>
    buffLen+= bytes;</P>
    // Place the random number, secret number, secret</P>
    bytes = PlaceSecrets(bptr, challengeStruct);</P>
    buffLen+= bytes;</P>
    // Compute the Message Digest</P>
    ComputeMD4(argbuff, buffLen, messageDigest);</P>
}</P>
</P>
//</P>
// CreateUpdateChallengeQuery() will create the query portion of the challenge</P>
// to send to the provider.  It will return a complete challenge structure</P>
// ready to pass through the API.</P>
//</P>
void CreateUpdateChallengeQuery(LS_HANDLE LicenseHandle, LS_ULONG TotUnitsConsumed, LS_ULONG TotUnitsReserved, LS_UCHAR *LogComment, LS_CHALLENGE *challengeStruct)</P>
{</P>
    char *argBuff, bPtr;</P>
    int bufferLen, bytes;</P>
</P>
    // Indicate that we are using the basic protocol</P>
    challengeStruct-&gt;Protocol = LS_BASIC_PROTOCOL;</P>
    // Indicate the size of the challenge data structure to the provider</P>
    challengeStruct-&gt;Size = sizeof(LS_CHALLDATA);</P>
    // Pick a random number, from 0 to maximum value</P>
    challengeStruct-&gt;ChallengeData.Random = random(0xFFFFFFFF);</P>
    // Pick a random secret value from 1 to 4</P>
    challengeStruct-&gt;ChallengeData.SecretIndex = (challengeData-&gt;Random % 4) + 1;</P>
    // Create the buffer for the message digest</P>
argBuff = (char *) malloc(strlen("LSUpdate") + sizeof(LS_HANDLE) + sizeof(LS_ULONG) + sizeof(LS_ULONG) + strlen(LogComment) + 1 + sizeof(LS_ULONG) + sizeof(LS_ULONG) + SECRET_SIZE);</P>
bPtr = argBuffer;</P>
bufferLen = PlaceUpdateInParameters(argBuffer, LicenseHandle,TotUnitsConsumed, TotUnitsReserved, LogComment);</P>
    bPtr+= bufferLen;</P>
    // place the random number, the secret number, and the secret</P>
    bytes = PlaceSecrets(bPtr, challengeStruct);</P>
    bufferLen+= bytes;</P>
    // Compute the Message Digest</P>
    ComputeMD4(argBuff, bufferLen, challengeStruct-&gt;ChallengeData.MsgDigest.MessageDigest);</P>
}</P>
</P>
//</P>
// CreateUpdateChallengeResponse() will form what the provider should</P>
// respond with for a challenge on an LSUpdate call.  This value will be</P>
// returned in messageDigest.  This value can be compared with the value</P>
// returned by the provider to determine the provider's validity.</P>
//</P>
void CreateUpdateChallengeResponse(LS_HANDLE LicenseHandle, LS_ULONG TotUnitsConsumed, LS_ULONG TotUnitsReserved, LS_UCHAR *LogComment, LS_ULONG totUnitsGranted, LS_ULONG Status, LS_CHALLENGE *challengeStruct, LS_UCHAR *messageDigest)</P>
{</P>
    int        bytes;</P>
    char         *argBuff, *bPtr;</P>
</P>
argBuff = (char *) malloc(strlen("LSUpdate") + sizeof(LS_HANDLE) + sizeof(LS_ULONG) + sizeof(LS_ULONG) + strlen(LogComment) + 1 + sizeof(LS_ULONG) + sizeof(LS_ULONG) + sizeof(LS_ULONG) + sizeof(LS_ULONG) + SECRET_SIZE);</P>
bPtr = argBuffer;</P>
bufferLen = PlaceUpdateInParameters(argBuffer, LicenseHandle,TotUnitsConsumed, TotUnitsReserved, LogComment);</P>
    bPtr+= bufferLen;</P>
    // place the output parameters</P>
    bytes = PlaceInt32(bPtr, totUnitsGranted);</P>
    bPtr+= bytes;</P>
    bufferLen+= bytes;</P>
    bytes = PlaceInt32(bPtr, Status);</P>
    bPtr+= bytes;</P>
    bufferLen+= bytes;</P>
    // place the random number, the secret number, and the secret</P>
    bytes = PlaceSecrets(bPtr, challengeStruct);</P>
    bufferLen+= bytes;</P>
    // Compute the Message Digest</P>
    ComputeMD4(argBuff, bufferLen, messageDigest);</P>
    challengeStruct-&gt;ChallengeData.MsgDigest.MessageDigest);</P>
}</P>
</P>
//</P>
// PrintErrorMessage() will display the error message for the associated</P>
// handle/licensing system.</P>
//</P>
void PrintErrorMessage(LS_HANDLE licHandle, LS_STATUS_CODE status, LS_UCHAR *licSystem)</P>
{</P>
    LS_STATUS_CODE localStat;</P>
    LS_UCHAR *errorBuff;</P>
    LS__ULONG errorBuffSize;</P>
</P>
    errorBuffSize = DEFAULT_ERROR_BUFFER_SZ;</P>
    errorBuff = (LS_UCHAR *) malloc(errorBuffSize);</P>
    localStat = LSGetMessage(licHandle, status, errorBuff, errorBuffSize);</P>
    while (localStat == LS_BUFFER_TOO_SMALL) {</P>
        errorBuffSize*= 2;</P>
        errorBuff = (LS_UCHAR *) realloc(errorBuff, errorBuffSize);</P>
        localStat = LSGetMessage(licHandle, status, errorBuff, errorBuffSize);</P>
    } // end while</P>
    if (localStat != LS_SUCCESS)</P>
        printf("Licensing system %s reports: An unknown licensing system error occured\n",            licSystem);</P>
    else</P>
        printf("Licensing system %s reports: %s\n", licSystem, errorBuff);</P>
    free(errorBuff);</P>
}</P>
</P>
//</P>
// LS_HANDLE GetMyLicense() will retrieve the default number of units from</P>
// each licensing system provider.  It will return the resulting status in</P>
// stat, and the return value will be a valid licensing handle.  Any errors</P>
// encountered with each licensing system will be displayed.  stat will reflect</P>
// the last error encountered.</P>
//</P>
LS_HANDLE GetMyLicense(LS_STATUS_CODE *stat)</P>
{</P>
    LS_ULONG totUnitsGranted, Index;</P>
    LS_HANDLE licHandle;</P>
    LS_CHALLENGE challengeStruct;</P>
    LS_UCHAR messageDigest[16], providerName[255];</P>
    LS_STATUS_CODE localStat;</P>
</P>
</P>
    // visit the first provider</P>
    ulIndex = 0;</P>
    localStat = LSEnumProviders(Index, providerName);</P>
    // if there are no providers installed, return that error code</P>
    if (localStat == LS_BAD_INDEX) {</P>
        *stat = LS_SYSTEM_UNAVAILABLE;</P>
        return(licHandle);</P>
    } // end if</P>
    // otherwise, loop through the providers until either we run out, or</P>
    // successfully retrieve the units necessary to run</P>
    while (localStat != LS_BAD_INDEX) {</P>
        // fill in the challenge structure</P>
CreateRequestChallengeQuery(providerName, MY_PUBLISHER_NAME, MY_PRODUCT_NAME, MY_VERSION, LS_DEFAULT_UNITS, LOG_COMMENT, &amp;challengeStruct);</P>
        // Perform the request with the created challenge</P>
*stat = LSRequest(providerName, (LS_UCHAR *) MY_PUBLISHER_NAME, (LS_UCHAR *) MY_PRODUCT_NAME, (LS_UCHAR *) MY_VERSION, LS_DEFAULT_UNITS, (LS_UCHAR *) LOG_COMMENT, &amp;challengeStruct, &amp;totUnitsGranted, &amp;licHandle);</P>
        // if the status was alright, check the challenge</P>
        if (*stat == LS_SUCCESS) {</P>
// We have received licenses, compute the challenge response ourselves to test the validity of // the provider's response</P>
CreateRequestChallengeResponse(LS_ANY, (LS_UCHAR *) MY_PUBLISHER_NAME, (LS_UCHAR *) MY_PRODUCT_NAME, (LS_UCHAR *) MY_VERSION, LS_DEFAULT_UNITS, (LS_UCHAR *) LOG_COMMENT, totUnitsGranted, *stat, &amp;challengeStruct, messageDigest);</P>
            // compare our response, and the providers response</P>
if (memcmp(messageDigest, challengeStruct.ChallengeData.MsgDigest.MessageDigest, sizeof(messageDigest)) != 0)</P>
            // indicate an error has occured</P>
            *stat = LS_AUTHORIZATION_UNAVAILABLE;</P>
        } // end if</P>
        // if stat indicates an error, get the providers message and display</P>
        // and try the next provider</P>
        if (*stat != LS_SUCCESS)</P>
            PrintErrorMessage(licHandle, *stat, providerName);</P>
        else {</P>
            // we have succesfully gotten our units, return the handle/status</P>
            printf("Units successfully retrieved from license provider %s\n",                providerName);</P>
            return(licHandle);</P>
        } // end else</P>
        // free the handle, and try again</P>
        LSFreeHandle(licHandle);</P>
    } // end while loop</P>
    // we ran out of license providers, just return the last error code, and a</P>
    // meaningless (now freed) handle</P>
    return(licHandle);</P>
}</P>
</P>
</P>
</P>
//</P>
// LS_STATUS_CODE PreformUpdate() will preform an update call for the specified license handle, </P>
// and will return the status of that operation</P>
//</P>
LS_STATUS_CODE PerformUpdate(LS_HANDLE licHandle)</P>
{</P>
    LS_STATUS_CODE    retVal;</P>
    LS_CHALLENGE         challengeStruct;</P>
    LS_ULONG         totUnitsGranted;</P>
    LS_UCHAR        ResponseMessageDigest[16];</P>
</P>
    // form up the challenge query</P>
    CreateUpdateChallengeQuery(licHandle, LS_DEFAULT_UNITS, LS_DEFAULT_UNITS,        (LS_UCHAR *) LOG_COMMENT, &amp;challengeStruct);</P>
    // Make the actual update call, with the default number of units,</P>
    // specifying that we should not acquire any more units</P>
    retVal = LSUpdate(licHandle, LS_DEFAULT_UNITS, LS_DEFAULT_UNITS,        (LS_UCHAR *) LOG_COMMENT, &amp;challengeStruct, &amp;totUnitsGranted);</P>
    // if the status was not OK, return immediately</P>
    if (retVal != LS_SUCCESS)</P>
        return(retVal);</P>
    // create the challenge response</P>
    CreateUpdateChallengeResponse(licHandle, LS_DEFAULT_UNITS, LS_DEFAULT_UNITS,        (LS_UCHAR *) LOG_COMMENT, &amp;challengeStruct, totUnitsGranted, retVal,        ResponseMessageDigest);</P>
    // compare the the provider's response and our own</P>
if (memcmp(messageDigest, challengeStruct.ChallengeData.MsgDigest.MessageDigest, sizeof(messageDigest)) != 0)</P>
        // return an error</P>
        retVal = LS_AUTHORIZATION_UNAVAILABLE;</P>
    // return the result</P>
    return(retVal);</P>
}</P>
</P>
//</P>
// void DoTheWorkOfMyProgram() will preform the actual work of the program.</P>
// Also, it will preform the update based on the recommended default update</P>
// period for the provided handle.</P>
void DoTheWorkOfMyProgram(LS_HANDLE licHandle)</P>
{</P>
    LS_STATUS_CODE status;</P>
</P>
    //</P>
    // This area does whatever the program needs to do</P>
    //</P>
</P>
    // This area would be run periodically, in whatever manner is appropriate</P>
    // for your particular operating system</P>
</P>
    status = PerformUpdate(licHandle);</P>
    // end the program if status was not OK, first displaying the error message</P>
    if (status != LS_SUCCESS) {</P>
        // get our current licensing system name</P>
        // display the error message that occured</P>
        PrintErrorMessage(licHandle, status, licSystem);</P>
        // Free our licensing handle</P>
        LSFreeHandle(licHandle);</P>
        return;</P>
    }</P>
    //</P>
    // continue doing the work of our program, looping/jumping/threading back to</P>
    // the above area periodically</P>
    //</P>
</P>
    //</P>
    // at the end of our program, free our handle</P>
    //</P>
    LSFreeHandle(licHandle);</P>
    return;</P>
}</P>
</P>
void main(int argc, char **argv)</P>
{</P>
    LS_HANDLE licHandle;</P>
    LS_STATUS_CODE stat;</P>
</P>
    // obtain license(s) and retrieve a licensing handle</P>
    licHandle = GetMyLicense(&amp;stat);</P>
    // check the stat</P>
    if (stat != LS_SUCCESS)</P>
        printf("No licenses retrieved from any licensing system! Exiting...\n");</P>
    // otherwise run our program</P>
    else</P>
          DoTheWorkOfMyProgram(licHandle, argc, argv);</P>
}</P>
</P></BODY></HTML>
