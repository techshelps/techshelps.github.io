<HTML><HEAD><META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Anti-Tampering Guidelines</TITLE><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">
</OBJECT></FORM>
<H2>Anti-Tampering Guidelines</H2>The more malicious programmer can defeat any system given enough time. The goal here is to make that effort as reasonably difficult as possible. Defeating the mechanism should not be as simple as doing a one byte patch to the application which calls the license system. Rather, it should be much more confounding.</P>
Below are a few basic guidelines which the software publisher might follow while developing their application. Note that these guidelines may go against certain accepted coding practices. The software publisher will have to decide if the tradeoff is worth making. Additional guidelines may be available from license system vendors.</P>
    Do not compare the challenge result immediately after calling a License Service API function. Rather, save the result and compare later. This is security by obscurity.</P>
    Incorporate an internal and obscure checksum over the code which deals with the license system and with the challenge verification. Even obscure the checksum code if you can.</P>
    If applicable, take over any debug and single-step vectors which might be used by debuggers. Great care should be taken when doing such an advanced measure.</P>
    Do unique things with the challenge result before doing a final compare. Touch the result often without doing anything with it (i.e., do meaningless reads, compares, subtractions, etc.). In situations where a hardware monitor is being used, this may increase the number of hardware breakpoints which occur, thereby further confusing the intruder.</P>
    Verify the challenge result more than once. Provide a faux compare immediately after the LSRequest() and LSUpdate(). This will confuse any intruder.</P>
    Don't do the comparison with a simple compare. Rather, perform some mathematical operations on the result, computing another result which is verified later in the code.</P>
    For platforms which permit self-modifying code, and if the actual challenge algorithms are included in the code, hide them through encryption of the code. Decrypt only long enough to verify a challenge and then re-encrypt it. Checksum the code which calls the encrypt/decrypt routines to prevent alteration. Have the entry point in the challenge algorithms <I>verify</I> the code offset (if applicable) from which it was called. Encrypting the algorithms makes them more difficult to locate in the code. Also encrypt the actual secrets if you choose to include them into your code.</P>
    If the host operating system permits, place most of the challenge code and data into discardable overlays.</P>
    Use different challenge values for LSUpdate() than that used in LSRequest().</P>
    Choose unique sets of secrets for each different application produced by your company. Thus, if one set of secrets is compromised, then only one application is compromised.</P>
    Choose a subset of unique secrets for each application version. Thus, if a set of secrets is compromised for a particular version, those secrets are useless on the next version.</P>
    Call LSUpdate() periodically, as recommended by the LSQuery() function. If no recommendation is provided, a guideline of once every 24 hours can be used.</P>
These are just a few of the possibilities which the software publisher can consider. Think about anti-virus techniques and the measures taken to prevent code modification. Those same anti-tampering techniques are applicable here.</P></BODY></HTML>
