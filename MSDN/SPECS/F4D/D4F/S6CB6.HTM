<HTML><HEAD><META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Apple Macintosh</TITLE><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">
</OBJECT></FORM>
<H2>Apple Macintosh</H2>Providers on the Macintosh can reside in any program – application, desk accessory, system extension, etc. – and can register their presence with the license system management layer.  Once a provider is registered, it can receive any of the five standard License Service functions.  Providers can also unregister at any time to remove themselves from the system.</P>
Macintosh applications statically link with the <I>LSAPI.o</I>  library, which coordinates the interaction between the licensed application and the installed providers (a system extension must also be installed in the user's System Folder).  Applications do not interact directly with the registered license providers.</P>
Developers may contact Sassafras Software at (603) 643-3351 or Apple Computer's Developer Relations group at (408) 996-1010 for further information.</P>
<H3><A NAME="sec0"></A>Data Structures</H3>To provide source-level compatibility with other operating system platforms, all strings pointed to below are NULL-terminated.</P>
Each provider must register with the license system management layer before it can handle License Service calls.  To register, a provider fills in the appropriate fields in a LS_PROVIDER_ELEMENT structure, and calls LSRegister().</P>
LS_PROVIDER_ELEMENT = record</P>
    lsLink: Ptr;    {for management layer use}</P>
    lsType: integer;    {for management layer use}</P>
    lsInternal: LongInt;    {for management layer use}</P>
    lsReserved: LongInt;    {for management layer use}</P>
    lsAddr: ProcPtr;    {address of provider code}</P>
    lsName: Ptr;    {pointer to provider name}</P>
    lsStamp: OSType;    {unique provider stamp}</P>
    lsRefCon: LongInt    {for provider's use}</P>
end;</P>
LS_PROVIDER_PTR = ^LS_PROVIDER_ELEMENT;</P>
The lsAddr field points to the provider routine.  Providers are declared as follows:</P>
<B>procedure</B> MyProvider (lsPB: LS_PBLOCKPTR;</P>
    lsElement: LS_PROVIDER_PTR);</P>
When the provider is called, the LS_PARAMBLOCKREC pointed to by lsPB contains a code for the call being made, as well as all of the pertinent parameters.  lsElement points to the provider's registered LS_PROVIDER_ELEMENT.</P>
LS_PARAMBLOCKREC = <B>record</B></P>
    qLink: Ptr;</P>
    qType: integer;</P>
    ioTrap: integer;</P>
    ioCmdAddr: Ptr;</P>
    ioCompletion: ProcPtr;</P>
    ioResult: integer;</P>
    ioNamePtr: Ptr;</P>
    ioVRefNum: integer;</P>
    ioRefNum: integer;</P>
    csCode: integer;</P>
</P>
    lsResult: LS_STATUS_CODE;</P>
    lsHandle: LS_HANDLE;</P>
    <B>case</B> integer <B>of</B></P>
    1: (</P>
        lsPublisher: Ptr;</P>
        lsProduct: Ptr;</P>
        lsVersion: Ptr;</P>
        lsURequired: LongInt;</P>
        lsLogComm: Ptr;</P>
        lsChallenge: LS_CHALLENGE_PTR</P>
        lsTotUGranted: Ptr;</P>
    );</P>
    2: (</P>
        lsUConsumed: LongInt;</P>
        lsLogComm: Ptr;</P>
    );</P>
    3: (</P>
        lsUConsumed: LogInt;</P>
        lsUReserved: LongInt;</P>
        lsLogComm: Ptr;</P>
        lsChallenge: LS_CHALLENGE_PTR;</P>
        lsTotUGranted: Ptr;</P>
    );</P>
    4: (</P>
        lsInfo: LongInt;</P>
        lsInfoBuffer: Ptr;</P>
        lsBuffSize: Ptr;</P>
        lsActBuffSize: Ptr;</P>
    );</P>
    5: (</P>
        lsValue: LongInt;</P>
        lsBuffSize: LongInt;</P>
        lsBuffer: Ptr</P>
    );</P>
<B>end</B>;</P>
LS_PBLOCKPTR = ^LS_PARAMBLOCKREC;</P>
</P>
The csCode field of a LS_PARAMBLOCKREC gives the reason that the provider was called.  It can take on one of the following values, one for each of the six standard License Service API functions:</P>
LS_REQUEST_CODE = 1;</P>
LS_RELEASE_CODE = 2;</P>
LS_UPDATE_CODE = 3;</P>
LS_QUERYLICENSE_CODE = 4;</P>
LS_GETMESSAGE_CODE = 5;</P>
LS_FREEHANDLE_CODE = 6;</P>
Other values for csCode should be ignored.  This parameter block interface was chosen so that the provider can easily pass the parameter block on to a driver, which can then handle the actual License Service functions.</P>
<H3><A NAME="sec1"></A>License Context Handles</H3>On the Macintosh, an LS_HANDLE is always a pointer to an LS_HANDLE_REC.  Note that the LS_HANDLE type should not be confused with the Memory Manager's Handle type.  The LS_HANDLE_REC has the following format:</P>
LS_HANDLE_REC = <B>record</B></P>
    lhStamp: OSType;</P>
    lhData: <B>array of</B> byte</P>
<B>end</B>;</P>
LS_HANDLE = ^LS_HANDLE_REC;</P>
The size and contents of the lhData array are specific to the provider, and are not interpreted by the license system management layer.</P>
<H3><A NAME="sec2"></A>Provider support calls</H3>When a provider wishes to register with the license system management layer, it first allocates an LS_PROVIDER_ELEMENT, fills in the last four fields with appropriate values, and then calls LSRegister().  LSRegister() is defined in the LSAPI.o library, which must be linked with the provider.  LSRegister() is declared as follows:</P>
<B>function</B> LSRegister (lsElement: LS_PROVIDER_PTR):LS_STATUS_CODE;</P>
The routine a provider uses to unregister is declared as follows:</P>
<B>function</B> LSRemove (lsElement: LS_PROVIDER_PTR):LS_STATUS_CODE;</P>
A provider need register only once, and should only unregister if it is no longer available to the license system.</P>
<H3><A NAME="sec3"></A>Provider example</H3>The following incomplete example code illustrates how a provider registers itself and handles the License Service calls:</P>
{ This procedure creates an LS_PROVIDER_ELEMENT }</P>
{ and registers the provider. }</P>
<B>procedure</B> RegisterMyProvider (myName: Ptr; myRefCon: LongInt);</P>
<B>    const</B></P>
        myStamp = 'TEST';</P>
<B>    var</B></P>
        myElem: LS_PROVIDER_PTR;</P>
<B>begin</B></P>
    { allocate a provider element }</P>
    myElem := LS_PROVIDER_PTR(NewPtr(SizeOf(LS_PROVIDER_ELEMENT)));</P>
    <B>if</B> (myElem = <B>nil</B>) <B>then</B></P>
        { handle the error gracefully };</P>
</P>
    { fill in the provider element }</P>
    myElem^.lsAddr := @MyProvider;</P>
    myElem^.lsName := myName;</P>
    myElem^.lsStamp := myStamp;</P>
    myElem^.lsRefCon := myRefCon;</P>
    err := LSRegister(myElem);</P>
    <B>if</B> (err &lt;&gt; LS_SUCCESS) <B>then</B></P>
        { handle the error gracefully }</P>
<B>end</B>;</P>
</P>
{ This is the main provider code, which handles all }</P>
{ License Service calls from the management layer. }</P>
<B>procedure</B> MyProvider (lsPB: LS_PBLOCKPTR;</P>
    lsElement: LS_PROVIDER_PTR);</P>
<B>begin</B></P>
    lsPB^.lsResult := LS_SUCCESS;    { initialize lsResult }</P>
    <B>case</B> lsPB^.csCode <B>of</B>        { which call has been made? }</P>
        LS_REQUEST_CODE:</P>
            ...;</P>
        LS_RELEASE_CODE:</P>
            ...;</P>
        LS_UPDATE_CODE:</P>
            ...;</P>
        LS_QUERYLICENSE_CODE:</P>
            ...;</P>
        LS_GETMESSAGE_CODE:</P>
            ...;</P>
        <B>otherwise</B></P>
            { always ignore unknown csCode values }</P>
    <B>end</B>;</P>
<B>end</B>;</P>
</P></BODY></HTML>
