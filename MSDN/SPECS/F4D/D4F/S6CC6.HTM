<HTML><HEAD><META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Challenge/Response Protocol</TITLE><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">
</OBJECT></FORM>
<H2>Challenge/Response Protocol</H2>In the Basic Challenge protocol, every license issued has one or more keys called <I>secrets</I>. These secrets, chosen by the software publisher, are typically encrypted within the license itself, with only the license server knowing how to decrypt those secrets. Since the application knows the secrets on the license, it can compute the correct expected response to a challenge -- which the server can only compute if it also knows the secret. The secret itself is never passed between the application and the license system (thus preventing snooping).</P>
In order to perform a challenge, the application generates a random value, which it passes as the challenge to the license system. The license system, in turn, combines that random value along with the "secret" off of the license. This data is fed into a one-way encryption scheme, yielding a unique result. The result of the one-way encryption is returned as the response to the challenge.</P>
<H3><A NAME="sec0"></A>Protocol Details</H3>In the Basic Challenge protocol, the application chooses the index, <I>X</I>, of the secret to be challenged; generates a random number, <I>R</I>; and computes a message digest of the input parameters, <I>R</I>, <I>X</I>, and the secret <I>S</I><I>X</I>. This data is passed to the license system which authenticates the message digest, and then computes a new message digest of the input parameters, output parameters, <I>R</I>, <I>X</I>, and <I>S</I><I>X</I>. This new message digest is passed back to the application, who, in turn, authenticates it. Note that the actual secret, <I>S</I><I>X</I>, is never passed between the application and license system in plain text. The figure below illustrates the protocol:</P>
<P><img src="PROTOCOL.gif"></P>
Let <I>in</I> be a byte stream  which encodes all [in]-parameters, excluding the handle, of an LSAPI function.  All parameters should be in the order specified in the "License Function Calls" section.</P>

<TABLE COLS="2" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="108pt" VALIGN="TOP"><COL WIDTH="202pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>TYPE</P></TD><TD VALIGN="TOP"><P>Description</P></TD></TR><TR><TD VALIGN="TOP"><P>LS_STR *</P></TD><TD VALIGN="TOP"><P>Array of bytes (excluding null)</P></TD></TR><TR><TD VALIGN="TOP"><P>UINT32</P></TD><TD VALIGN="TOP"><P>Least significant byte ascending order</P></TD></TR><TR><TD VALIGN="TOP"><P>INT32</P></TD><TD VALIGN="TOP"><P>Least significant byte ascending order</P></TD></TR><TR><TD VALIGN="TOP"><P>INT16</P></TD><TD VALIGN="TOP"><P>Least significant byte ascending order</P></TD></TR></TBODY></TABLE>
<BR></P>This is taken to include the name of the function being called (e.g., "LSRequest"), but exclude the value of <I>Challenge and LicenseHandle</I>. Let <I>out</I> be a byte stream which encodes all the [out]-parameters. This is taken to include <I>Status</I>, but excludes the value of <I>Challenge and LicenseHandle</I>. All parameters should be in the order specified in the "License Function Calls" section.  "Status" will be the last parameter.  Let  denote concatenation.</P>
The function <I>h</I>(<I>x</I>) is the algorithm which, given input <I>x</I>,  returns the output of the MD4 message digest algorithm. This algorithm, invented by R. Rivest and placed in the public domain, is described later in this chapter. The input <I>x</I> for <I>h</I>() is formed by concatenating all the arguments into a byte stream..   Any string arguments are copied without the NULL terminators. The application receives the output parameters (<I>out</I>) and the response to its challenge. The application accepts the result if and only the response is <I>h</I>(<I>in </I><I> out </I><I> R </I> <I>X </I><I> S</I><I>X</I>). Note that no challenge response is returned if the license request or update does not complete successfully.</P>
The following summarizes what work must be done in the application program in preparing a challenge, and what must be done by the server in preparing the response to a challenge. To prepare a challenge, the application must:</P>
    Generate a 32-bit random number, <I>R</I>.</P>
    Choose the index, <I>X</I>, of the secret to be challenged (1 - 4).</P>
    Look up the secret <I>S</I><I>X</I>.</P>
    Compute <I>h</I>(<I>in </I><I> R </I><I> X </I><I> S</I><I>X</I>).</P>
To respond to a challenge, the LS must:</P>
    Look up the secret <I>S</I><I>X</I> stored within the license, where <I>X</I> is the index of the secret.</P>
    Independently compute <I>h</I>(<I>in </I><I> R </I><I> X </I><I> S</I><I>X</I>) and compare it with the message digest passed in from the application initiating the challenge.</P>
    Compute one more message digest, <I>h</I>(<I>in </I><I> out </I><I> R </I><I> X </I><I> S</I><I>X</I>).</P>
On receiving a response from the LS, the application must:</P>
    Compute a message digest, <I>h</I>(<I>in </I><I> out </I><I> R </I><I> X </I><I> S</I><I>X</I>).</P>
    Compare two strings for equality.</P>
Compliant licensing systems permit a minimum of 4 secrets, each being 4 bytes (32-bits) in length.</P>
<H3><A NAME="sec1"></A>Generating random numbers</H3>The application needs a source of random numbers. These do not have to be of extremely high quality, but they should have good stochastic properties and must be unique to the extent that no random <I>R</I> generated by one application will be generated by another, or by the same application at a later point in time. Since many operating systems do not provide a reasonable source of random bits. A choice of <I>R=h</I>(<I>t</I>)<I>h</I>(<I>t+1</I>)<I>h</I>(<I>t+2</I>), where <I>t</I> is the machine's estimate of the current time, is acceptable if <I>t</I> is guaranteed to increase monotonically and rapidly.</P></BODY></HTML>
