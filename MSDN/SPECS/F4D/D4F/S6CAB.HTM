<HTML><HEAD><META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>MS-DOS and DR-DOS</TITLE><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">
</OBJECT></FORM>
<H2>MS-DOS and DR-DOS</H2>Under DOS environments, each license system provider is implemented as Terminate-and-Stay-Resident (TSR) module. DOS applications statically link to the library LSAPI.LIB. The calling convention for the licensing functions is C language. The LSAPI.LIB library is responsible for coordinating the interaction between the application and the underlying provider TSRs. The LSAPI.LIB itself is not a license system service provider. Applications do not interact directly with the provider TSRs (but may choose to do so).</P>
A license system provider TSR attaches itself to the interrupt 2Fh vector and watches for AH=70h. Upon a match, the TSR further examines the CX register to see if the slot number matches.</P>
Great care should be taken in developing the TSR. The memory space available to MS-DOS applications is very limited. The TSR should be a small and as efficient as possible, discarding initialization code, etc. Provider developers might even consider storing the majority of the provider code into Expanded (EMS) Memory, and only have a small stub as the TSR.</P>
<H3><A NAME="sec0"></A>Data Structures</H3>All strings pointed to below are NULL-terminated. The following defines the SLSREQUEST structure:</P>
SLSREQUEST    struct<BR> Status    DD    ?    ; [out] status code<BR> LicenseHandle    DD    ?    ; [out] handle identifying context<BR> PublisherName    DD    ?    ; pointer to Publisher string<BR> ProductName    DD    ?    ; pointer to Product string<BR> Version    DD    ?    ; pointer to Version string<BR> TotUnitsReserved    DD    ?    ; total units to be reserved<BR> LogComment    DD    ?    ; pointer to comment string<BR> Challenge    DD    ?    ; pointer to SLSCHALLENGE structure<BR> ChallengeResponse    DD    ?    ; pointer to the challenge response<BR> TotUnitsGranted    DD    ?    ; [out] total units actually reserved<BR>SLSREQUEST    ENDS</P>
The following defines the SLSCHALLENGE structure:</P>
SLSCHALLENGE    struct<BR> Protocol    DD    ?    ; specifies the protocol<BR> Size    DD    ?    ; size of ChallengeData structure<BR> ChallengeData    LABEL BYTE<BR>SLSCHALLENGE    ENDS</P>
The following defines the SLSCHALLENGEDATA structure:</P>
SLSCHALLENGEDATA    struct<BR> ChallengedSecret    DD    ?    ; secret to be challenged (1-4)<BR> Random    DD    ?    ; random 32-bit value<BR> MessageDigest    DB 16 DUP ? ; message digest structure<BR>SLSCHALLENGEDATA    ENDS</P>
The following defines the SLSRELEASE structure:</P>
SLSRELEASE    struct<BR> Status              DD  ?    ; [out] Result of the operation   </P>
 LicenseHandle    DD    ?    ; handle identifying license context<BR> TotUnitsConsumed    DD    ?    ; total units consumed<BR> LogComment    DD    ?    ; pointer to comment string<BR>SLSRELEASE    ENDS</P>
The following defines the SLSFREEHANDLE structure:</P>
SLSFREEHANDLE    struct</P>
LicenseHandle    DD    ?    ; The license handle to free</P>
SLSFREEHANDLE ENDS</P>
The following defines the SLSUPDATE structure:</P>
SLSUPDATE    struct<BR> Status    DD    ?    ; [out] status code<BR> hLicenseHandle    DD    ?    ; handle identifying license context<BR> TotUnitsConsumed    DD    ?    ; total units consumed<BR> TotUnitsReserved    DD    ?    ; total units to be reserved<BR> LogComment    DD    ?    ; pointer to comment string<BR> Challenge    DD    ?    ; pointer to SLSCHALLENGE structure<BR> ChallengeResponse    DD    ?    ; pointer to the challenge response<BR> TotUnitsGranted    DD    ?    ; [out] total units actually reserved<BR>SLSUPDATE    ENDS</P>
The following defines the SLSGETMESSAGE structure:</P>
SLSGETMESSAGE    struct<BR> Status    DD    ?    ; [returned] status code<BR> hLicenseHandle    DD    ?    ; handle identifying license context<BR> Value    DD    ?    ; indicates the error code<BR> BufferSize    DD    ?    ; buffer size in bytes<BR> Buffer    DB    <I>BufferSize</I> DUP (?)<BR>            ; [returned] message string<BR>SLSGETMESSAGE    ENDS</P>
The following defines the SLSQUERY structure:</P>
SLSQUERY    struct<BR> Return    DD    ?    ; [returned] status code<BR> LicenseHandle    DD    ?    ; handle identifying license context<BR> InfoIndex    DD    ?    ; information index<BR> InfoBufferSize    DD    ?    ; buffer size in bytes<BR> InfoBuffer    DB    <I>InfoBufferSize</I> DUP (?)</P>
            ; [returned] requested information</P>
ActualBufferSize    DD    ?    ; [out] # of bytes returned in InfoBuffer<BR>SLSQUERY    ENDS</P>
</P>
The following defines the SLSENUMPROVIDERS structure:</P>
     SLSENUMPROVIDERS   struct</P>
          Status        DD   ?   ;[out] returned status</P>
          Index         DD   ?   ; the index of the provider</P>
          Buffer        DD   ?   ; a pointer to the buffer</P>
     SLSENUMPROVIDERS   ENDS</P>
<H3><A NAME="sec1"></A>Interrupt 2Fh Handler</H3>The interrupt 2Fh is the general purpose multiplexed interface used by network software, the operating system, and various system utility programs. The interface is designed so that functions can be hooked in a chain-like fashion. Each interrupt 2Fh handler is expected to implement an installation check function. The AH register contains the multiplex channel, and the AL register contains the specific function code for that handler. Function code AL=00h is the installation check function. If the handler is installed, it must return the value FFh in the AL register. The last handler in the interrupt 2Fh chain (maintained by DOS) will always return a value of 00h in the AL register, indicating that the desired multiplex channel is not installed.</P>
Every Multiplex interrupt handler uses a specific multiplex number which must be given in the AH register. For LSAPI provider TSRs, the value for AH is 70h. Handlers are chained into the 2Fh interrupt vector and discriminate based on the value in AH. The specific function to be performed by the selected handler is placed into the AL register. Other parameters are placed in the remaining registers as needed. Multiplex numbers AH=00h through AH=7Fh are reserved for the operating system, while AH=0B8h through AH=0BFh are reserved for network use. Other applications should use multiplex numbers AH=80h through AH=0FFh.</P>
The following incomplete sample code segments illustrate how the interrupt 2Fh vector is "chained" into.</P>
;</P>
; The following segment of code is used to hook the INT 2Fh vector.;</P>
;</P>
    ...</P>
    CALL    NEAR PTR FindSlot    ; find an unused CX value</P>
    JC    noslots        ; If none available, error...</P>
    CALL    NEAR PTR SetVector    ; take over INT 2Fh vector</P>
    OR    AX, AX        ; did set vector succeed?</P>
    JNZ    setfailed        ; YES:  ...</P>
    ...</P>
    ...</P>
</P>
</P>
; FindSlot()</P>
;     On Entry:    Nothing</P>
;     On Exit:    CX = next unused index slot</P>
;;</P>
FindSlot    Proc    NEAR</P>
    ASSUME    CS:CODE, DS:DATA, ES:NOTHING</P>
    XOR    CX, CX        ; service provider index</P>
fs_loop:    MOV    AX, 7000h        ; installation check function</P>
    INT    2Fh        ; Do install check</P>
    OR    AL, AL        ; Is AL=00h?</P>
    JZ    fs_done        ; YES: CX is our provider index</P>
    INC    CX        ; NO:  Try next CX value</P>
    CMP    CL, 0Fh        ; Up to 15 providers?</P>
    JB    fs_loop        ; NO:  keep trying...</P>
    MOV    CX, 0FFFFh    ; YES: return error (wow!)</P>
    STC            ;</P>
fs_done:    RET            ;;</P>
FindSlot    ENDP</P>
</P>
</P>
; SetVector()</P>
;     On Entry:    CX = provider slot #</P>
;     On Exit:    INT 2Fh vector set to CODE:Handler</P>
;        Original vector saved in CODE:OldHandler</P>
;        Slot # (from CX) saved in CODE:myslot</P>
;        ES:BX set to original vector.</P>
;        Other registers undetermined.</P>
;        AX = 0000h on success, else error code</P>
;;</P>
SetVector    PROC    NEAR</P>
    ASSUME  CS:CODE, DS:NOTHING, ES:NOTHING</P>
    MOV    AX, 352Fh            ; Get INT 2Fh vector</P>
    INT    21h            ; into ES:BX...</P>
    MOV    WORD PTR CS:OldHandler, BX    ; save segment</P>
    MOV    WORD PTR CS:OldHandler+2, ES    ;</P>
    MOV    WORD PTR CS:myslot, CX    ; save my slot #</P>
    PUSH    DS            ; set up DS:SI</P>
    MOV    DS, SEG CODE        ;</P>
    ASSUME    DS:CODE            ;</P>
    MOV    DX, OFFSET CODE:Handler    ; DS:SI --&gt; new handler</P>
    MOV    AL, 2Fh            ; interrupt to set</P>
    MOV    AH, 25h            ; DOS set vector</P>
    INT    21h            ; Set it!!</P>
    POP    DS            ; get back DS=DATA</P>
    RET                ;;</P>
SetVector    ENDP</P>
</P>
</P>
; Handler()</P>
;     This routine handles the interrupt 2Fh vector.</P>
;     On Entry:    AH = multiplex channel</P>
;        AL = function code</P>
;        CX = slot # (if AH=70h)</P>
;     On Exit:    As appropriate for function.</P>
;;</P>
Handler    PROC    FAR</P>
    ASSUME    CS:CODE, DS:NOTHING, ES:NOTHING, SS:NOTHING</P>
    CMP    AH, 70h            ; LSAPI function?</P>
    JZ    is_lsapi            ; YES: look further</P>
chain:    JMP    DWORD PTR CS:OldHandler    ; NO:  chain to next handler</P>
</P>
is_lsapi:    CMP    CX, CS:myslot        ; request for my slot #?</P>
    JNZ    chain            ; NO:  chain to next</P>
    ; looks like we have a function for us</P>
    ; lets check it out</P>
    CMP    AL, 00h            ; Install check?</P>
    JZ    instchk            ; YES:  handle it</P>
    CMP    AL, 05h            ; function in range?</P>
    JA    badfunc            ; NO:  return failure</P>
    ; we get here for functions AL=02h through AL=05h</P>
    ; PLACE CODE HERE FOR OTHER FUNCTIONS</P>
    ; SAVE REGISTERS, ETC.</P>
    ; THIS MIGHT BE A GOOD PLACE FOR A JUMP TABLE</P>
    ...</P>
    ...</P>
</P>
instchk:    MOV    AL, 0FFh            ; indicate we're installed</P>
    IRET</P>
</P>
badfunc:    MOV    AX, 0001h            ; invalid function code</P>
    IRET</P>
    ...</P>
Handler    ENDP</P>
</P>
; CODE segment data variables</P>
OldHandler    DD    ?    ; address of old INT 2Fh handler</P>
myslot        DW    ?    ; provider index #</P>
</P>
</P>
Contact Microsoft's or Novell's Developer Relations Group for further information.</P>
<H4><A NAME="sec2"></A>INT 2Fh, AX=7000h -- Installation Check</H4>Before a service provider hooks into the INT 2Fh chain, it must look for a free index slot. This is accomplished by placing an index value into the CX register and issuing an installation check (detailed below). If a particular slot is in use, the AL register will be returned with 0xFF. Otherwise, the AL register will remain unchanged. The provider  issues the installation check call, incrementing the index value (starting at zero) each time, until it locates a free slot.</P>
Once a free index value has been identified, the provider may hook into the INT 2Fh interrupt chain and go TSR. Thereafter, the TSR must respond to future installation checks when CX contains its index value.</P>

<TABLE COLS="3" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="68pt" VALIGN="TOP"><COL WIDTH="45pt" VALIGN="TOP"><COL WIDTH="243pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>On Entry:</P></TD><TD VALIGN="TOP"><P>AX</P></TD><TD VALIGN="TOP"><P>7000h</P></TD></TR><TR><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P>CX</P></TD><TD VALIGN="TOP"><P>Index of license service provider TSR. This may range from 0x0000 to 0x001F, inclusive. The first provider TSR should use 0x0000; the second 0x0001; the third 0x0002; and so on.<BR></P></TD></TR><TR><TD VALIGN="TOP"><P>On Exit:</P></TD><TD VALIGN="TOP"><P>AL</P></TD><TD VALIGN="TOP"><P>Status: 0x00=not-installed; 0xFF=installed (slot in use)</P></TD></TR></TBODY></TABLE>
<BR></P>This document does not detail the techniques required to properly chain a software interrupt. Developers should consult the MS-DOS Programmer's Reference or the MS-DOS Encyclopedia for further information.</P>
<H4><A NAME="sec3"></A>INT 2Fh, AX=7001h -- Request License</H4>
<TABLE COLS="3" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="68pt" VALIGN="TOP"><COL WIDTH="45pt" VALIGN="TOP"><COL WIDTH="243pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>On Entry:</P></TD><TD VALIGN="TOP"><P>AX</P></TD><TD VALIGN="TOP"><P>7001h</P></TD></TR><TR><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P>CX</P></TD><TD VALIGN="TOP"><P>Index of license system service provider</P></TD></TR><TR><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P>DS:DX</P></TD><TD VALIGN="TOP"><P>Pointer to SLSREQUEST structure (see <I>Data Structures</I> on page 31)</P></TD></TR><TR><TD VALIGN="TOP"><P>On Exit:</P></TD><TD VALIGN="TOP"><P>AX</P></TD><TD VALIGN="TOP"><P>Status: 0x0000=complete (see structure for full status code); any other=provider error</P></TD></TR><TR><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P>ES:BX</P></TD><TD VALIGN="TOP"><P>Contains the provider-specific handle identifying the license context</P></TD></TR></TBODY></TABLE>
<BR></P><H4><A NAME="sec4"></A>INT 2Fh, AX=7002h -- Release License</H4>
<TABLE COLS="3" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="68pt" VALIGN="TOP"><COL WIDTH="45pt" VALIGN="TOP"><COL WIDTH="243pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>On Entry:</P></TD><TD VALIGN="TOP"><P>AX</P></TD><TD VALIGN="TOP"><P>7002h</P></TD></TR><TR><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P>CX</P></TD><TD VALIGN="TOP"><P>Index of license system service provider</P></TD></TR><TR><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P>DS:DX</P></TD><TD VALIGN="TOP"><P>Pointer to SLSRELEASE structure (see <I>Data Structures</I> on page 31)</P></TD></TR><TR><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P>ES:BX</P></TD><TD VALIGN="TOP"><P>Handle identifying the license context</P></TD></TR><TR><TD VALIGN="TOP"><P>On Exit:</P></TD><TD VALIGN="TOP"><P>AX</P></TD><TD VALIGN="TOP"><P>Status: 0x0000=complete (see structure for full status code); any other=provider error</P></TD></TR></TBODY></TABLE>
<BR></P><H4><A NAME="sec5"></A>INT 2Fh, AX=7003h -- Update</H4>
<TABLE COLS="3" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="68pt" VALIGN="TOP"><COL WIDTH="45pt" VALIGN="TOP"><COL WIDTH="243pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>On Entry:</P></TD><TD VALIGN="TOP"><P>AX</P></TD><TD VALIGN="TOP"><P>7003h</P></TD></TR><TR><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P>CX</P></TD><TD VALIGN="TOP"><P>Index of license service provider.</P></TD></TR><TR><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P>DS:DX</P></TD><TD VALIGN="TOP"><P>Pointer to SLSUPDATE structure (see <I>Data Structures</I> on page 31)</P></TD></TR><TR><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P>ES:BX</P></TD><TD VALIGN="TOP"><P>Handle identifying the license context</P></TD></TR><TR><TD VALIGN="TOP"><P>On Exit:</P></TD><TD VALIGN="TOP"><P>AX</P></TD><TD VALIGN="TOP"><P>Status: 0x0000=complete (see structure for full status code); any other=provider error</P></TD></TR></TBODY></TABLE>
<BR></P><H4><A NAME="sec6"></A>INT 2Fh, AX=7004h -- Get Message</H4>
<TABLE COLS="3" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="68pt" VALIGN="TOP"><COL WIDTH="45pt" VALIGN="TOP"><COL WIDTH="243pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>On Entry:</P></TD><TD VALIGN="TOP"><P>AX</P></TD><TD VALIGN="TOP"><P>7004h</P></TD></TR><TR><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P>CX</P></TD><TD VALIGN="TOP"><P>Index of license service provider TSR..</P></TD></TR><TR><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P>DS:DX</P></TD><TD VALIGN="TOP"><P>Pointer to SLSGETMESSAGE structure (see <I>Data Structures</I> on page 31)</P></TD></TR><TR><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P>ES:BX</P></TD><TD VALIGN="TOP"><P>Handle identifying the license context</P></TD></TR><TR><TD VALIGN="TOP"><P>On Exit:</P></TD><TD VALIGN="TOP"><P>AX</P></TD><TD VALIGN="TOP"><P>Status: 0x0000=complete (see structure for full status code); any other=provider error</P></TD></TR></TBODY></TABLE>
<BR></P><H4><A NAME="sec7"></A>INT 2Fh, AX=7005h -- Query License</H4>
<TABLE COLS="3" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="68pt" VALIGN="TOP"><COL WIDTH="45pt" VALIGN="TOP"><COL WIDTH="243pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>On Entry:</P></TD><TD VALIGN="TOP"><P>AX</P></TD><TD VALIGN="TOP"><P>7005h</P></TD></TR><TR><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P>CX</P></TD><TD VALIGN="TOP"><P>Index of license service provider TSR..</P></TD></TR><TR><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P>DS:DX</P></TD><TD VALIGN="TOP"><P>Pointer to SLSQUERY structure (see <I>Data Structures</I> on page 31)</P></TD></TR><TR><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P>ES:BX</P></TD><TD VALIGN="TOP"><P>Handle identifying the license context</P></TD></TR><TR><TD VALIGN="TOP"><P>On Exit:</P></TD><TD VALIGN="TOP"><P>AX</P></TD><TD VALIGN="TOP"><P>Status: 0x0000=complete (see structure for full status code); any other=provider error</P></TD></TR></TBODY></TABLE>
<BR></P><H4><A NAME="sec8"></A>INT 2Fh, AX=7006h -- Free Licensing Handle</H4>
<TABLE COLS="3" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="68pt" VALIGN="TOP"><COL WIDTH="45pt" VALIGN="TOP"><COL WIDTH="243pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>On Entry:</P></TD><TD VALIGN="TOP"><P>AX</P></TD><TD VALIGN="TOP"><P>7006h</P></TD></TR><TR><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P>CX</P></TD><TD VALIGN="TOP"><P>Index of license service provider TSR..</P></TD></TR><TR><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P>DS:DX</P></TD><TD VALIGN="TOP"><P>Pointer to SLSFREEHANDLE structure (see <I>Data Structures</I> on page 32)</P></TD></TR><TR><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P>ES:BX</P></TD><TD VALIGN="TOP"><P>Handle identifying the license context</P></TD></TR><TR><TD VALIGN="TOP"><P>On Exit:</P></TD><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P>No returned values, always successful.</P></TD></TR></TBODY></TABLE>
<BR></P><H4><A NAME="sec9"></A>INT 2Fh, AX=7007h -- Enumerate License Providers</H4>
<TABLE COLS="3" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="68pt" VALIGN="TOP"><COL WIDTH="45pt" VALIGN="TOP"><COL WIDTH="243pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>On Entry:</P></TD><TD VALIGN="TOP"><P>AX</P></TD><TD VALIGN="TOP"><P>7007h</P></TD></TR><TR><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P>CX</P></TD><TD VALIGN="TOP"><P>Index of license service provider TSR..</P></TD></TR><TR><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P>DS:DX</P></TD><TD VALIGN="TOP"><P>Pointer to SLSENUMPROVIDERS structure (see <I>Data Structures</I> on page 32)</P></TD></TR><TR><TD VALIGN="TOP"><P>On Exit:</P></TD><TD VALIGN="TOP"><P>AX</P></TD><TD VALIGN="TOP"><P>Status: 0x0000=complete (see structure for full status code); any other = provider error</P></TD></TR></TBODY></TABLE>
<BR></P></BODY></HTML>
