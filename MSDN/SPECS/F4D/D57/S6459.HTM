<HTML><HEAD><META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>'cmap' - Character To Glyph Index Mapping Table</TITLE><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">
</OBJECT></FORM>
<H3>'cmap' - Character To Glyph Index Mapping Table</H3>This table defines the mapping of character codes to the glyph index values used in the font. It may contain more than one subtable, in order to support more than one character encoding scheme. Character codes that do not correspond to any glyph in the font should be mapped to glyph index 0. The glyph at this location must be a special glyph representing a missing character.</P>
The table header indicates the character encodings for which subtables are present. Each subtable is in one of four possible formats and begins with a format code indicating the format used.</P>
The platform ID and platform-specific encoding ID are used to specify the subtable; this means that each platform ID/platform-specific encoding ID pair may only appear once in the cmap table. Each subtable can specify a different character encoding. (<I>See the 'name' table section).</I> The entries must be sorted first by platform ID and then by platform-specific encoding ID.</P>
When building a Unicode font for Windows, the platform ID should be 3 and the encoding ID should be 1. When building a symbol font for Windows, the platform ID should be 3 and the encoding ID should be 0. When building a font that will be used on the Macintosh, the platform ID should be 1 and the encoding ID should be 0.</P>
All Microsoft Unicode encodings (Platform ID = 3, Encoding ID = 1) must use Format 4 for their 'cmap' subtable. Microsoft <B>strongly</B> recommends using a Unicode 'cmap' for all fonts. However, some other encodings that appear in current fonts follow:</P>

<TABLE COLS="3" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="84pt" VALIGN="TOP"><COL WIDTH="91pt" VALIGN="TOP"><COL WIDTH="193pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>Platform ID</P></TD><TD VALIGN="TOP"><P>Encoding ID</P></TD><TD VALIGN="TOP"><P>Description</P></TD></TR><TR><TD VALIGN="TOP"><P>3</P></TD><TD VALIGN="TOP"><P>0</P></TD><TD VALIGN="TOP"><P>Symbol</P></TD></TR><TR><TD VALIGN="TOP"><P>3</P></TD><TD VALIGN="TOP"><P>1</P></TD><TD VALIGN="TOP"><P>Unicode</P></TD></TR><TR><TD VALIGN="TOP"><P>3</P></TD><TD VALIGN="TOP"><P>2</P></TD><TD VALIGN="TOP"><P>ShiftJIS</P></TD></TR><TR><TD VALIGN="TOP"><P>3</P></TD><TD VALIGN="TOP"><P>3</P></TD><TD VALIGN="TOP"><P>Big5</P></TD></TR><TR><TD VALIGN="TOP"><P>3</P></TD><TD VALIGN="TOP"><P>4</P></TD><TD VALIGN="TOP"><P>PRC</P></TD></TR><TR><TD VALIGN="TOP"><P>3</P></TD><TD VALIGN="TOP"><P>5</P></TD><TD VALIGN="TOP"><P>Wansung</P></TD></TR><TR><TD VALIGN="TOP"><P>3</P></TD><TD VALIGN="TOP"><P>6</P></TD><TD VALIGN="TOP"><P>Johab</P></TD></TR></TBODY></TABLE>
<BR></P>The Character To Glyph Index Mapping Table is organized as follows:</P>

<TABLE COLS="2" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="84pt" VALIGN="TOP"><COL WIDTH="216pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>Type</P></TD><TD VALIGN="TOP"><P>Description</P></TD></TR><TR><TD VALIGN="TOP"><P>USHORT</P></TD><TD VALIGN="TOP"><P>Table version number (0).</P></TD></TR><TR><TD VALIGN="TOP"><P>USHORT</P></TD><TD VALIGN="TOP"><P>Number of encoding tables, <I>n.</I></P></TD></TR></TBODY></TABLE>
<BR></P>This is followed by an entry for each of the <I>n </I>encoding table specifying the particular encoding, and the offset to the actual subtable:</P>

<TABLE COLS="2" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="84pt" VALIGN="TOP"><COL WIDTH="248pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>Type</P></TD><TD VALIGN="TOP"><P>Description</P></TD></TR><TR><TD VALIGN="TOP"><P>USHORT</P></TD><TD VALIGN="TOP"><P>Platform ID.</P></TD></TR><TR><TD VALIGN="TOP"><P>USHORT</P></TD><TD VALIGN="TOP"><P>Platform-specific encoding ID.</P></TD></TR><TR><TD VALIGN="TOP"><P>ULONG</P></TD><TD VALIGN="TOP"><P>Byte offset from beginning of table to the subtable for this encoding.</P></TD></TR></TBODY></TABLE>
<BR></P><H4><A NAME="sec0"></A>Format 0: Byte encoding tableFormat 0: Byte encoding table</H4>This is the Apple standard character to glyph index mapping table.</P>

<TABLE COLS="3" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="72pt" VALIGN="TOP"><COL WIDTH="119pt" VALIGN="TOP"><COL WIDTH="205pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>Type</P></TD><TD VALIGN="TOP"><P>Name</P></TD><TD VALIGN="TOP"><P>Description</P></TD></TR><TR><TD VALIGN="TOP"><P>USHORT</P></TD><TD VALIGN="TOP"><P>format</P></TD><TD VALIGN="TOP"><P>Format number is set to 0. </P></TD></TR><TR><TD VALIGN="TOP"><P>USHORT</P></TD><TD VALIGN="TOP"><P>length</P></TD><TD VALIGN="TOP"><P>This is the length in bytes of the subtable.</P></TD></TR><TR><TD VALIGN="TOP"><P>USHORT</P></TD><TD VALIGN="TOP"><P>version</P></TD><TD VALIGN="TOP"><P>Version number (starts at 0).</P></TD></TR><TR><TD VALIGN="TOP"><P>BYTE</P></TD><TD VALIGN="TOP"><P>glyphIdArray[256]</P></TD><TD VALIGN="TOP"><P>An array that maps character codes to glyph index values.</P></TD></TR></TBODY></TABLE>
<BR></P>This is a simple 1 to 1 mapping of character codes to glyph indices. The glyph set is limited to 256. Note that if this format is used to index into a larger glyph set, only the first 256 glyphs will be accessible.</P>
<H4><A NAME="sec1"></A>Format 2: High-byte mapping through tableFormat 2: High-byte mapping through table</H4>This subtable is useful for the national character code standards used for Japanese, Chinese, and Korean characters. These code standards use a mixed 8/16-bit encoding, in which certain byte values signal the first byte of a 2-byte character (but these values are also legal as the second byte of a 2-byte character).  Character codes are always 1-byte. The glyph set is limited to 256.</P>
In addition, even for the 2-byte characters, the mapping of character codes to glyph index values depends heavily on the first byte. Consequently, the table begins with an array that maps the first byte to a 4-word subHeader. For 2-byte character codes, the subHeader is used to map the second byte's value through a subArray, as described below. When processing mixed 8/16-bit text, subHeader 0 is special: it is used for single-byte character codes. When subHeader zero is used, a second byte is not needed; the single byte value is mapped through the subArray.</P>

<TABLE COLS="3" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="79pt" VALIGN="TOP"><COL WIDTH="122pt" VALIGN="TOP"><COL WIDTH="175pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>Type</P></TD><TD VALIGN="TOP"><P>Name</P></TD><TD VALIGN="TOP"><P>Description</P></TD></TR><TR><TD VALIGN="TOP"><P>USHORT</P></TD><TD VALIGN="TOP"><P>format</P></TD><TD VALIGN="TOP"><P>Format number is set to 2.</P></TD></TR><TR><TD VALIGN="TOP"><P>USHORT</P></TD><TD VALIGN="TOP"><P>length</P></TD><TD VALIGN="TOP"><P>Length in bytes.</P></TD></TR><TR><TD VALIGN="TOP"><P>USHORT</P></TD><TD VALIGN="TOP"><P>version</P></TD><TD VALIGN="TOP"><P>Version number (starts at 0)</P></TD></TR><TR><TD VALIGN="TOP"><P>USHORT</P></TD><TD VALIGN="TOP"><P>subHeaderKeys[256]</P></TD><TD VALIGN="TOP"><P>Array that maps high bytes to subHeaders: value is subHeader index * 8.</P></TD></TR><TR><TD VALIGN="TOP"><P>4 words struct</P></TD><TD VALIGN="TOP"><P>subHeaders[ ]</P></TD><TD VALIGN="TOP"><P>Variable-length array of subHeader structures.</P></TD></TR><TR><TD VALIGN="TOP"><P>4 words-struct</P></TD><TD VALIGN="TOP"><P>subHeaders[ ]</P></TD><TD VALIGN="TOP"><P></P></TD></TR><TR><TD VALIGN="TOP"><P>USHORT</P></TD><TD VALIGN="TOP"><P>glyphIndexArray[ ]</P></TD><TD VALIGN="TOP"><P>Variable-length array containing subarrays used for mapping the low byte of 2-byte characters.</P></TD></TR></TBODY></TABLE>
<BR></P>A subHeader is structured as follows:</P>

<TABLE COLS="3" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="75pt" VALIGN="TOP"><COL WIDTH="119pt" VALIGN="TOP"><COL WIDTH="225pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>Type</P></TD><TD VALIGN="TOP"><P>Name</P></TD><TD VALIGN="TOP"><P>Description</P></TD></TR><TR><TD VALIGN="TOP"><P>USHORT</P></TD><TD VALIGN="TOP"><P>firstCode</P></TD><TD VALIGN="TOP"><P>First valid low byte for this subHeader.</P></TD></TR><TR><TD VALIGN="TOP"><P>USHORT</P></TD><TD VALIGN="TOP"><P>entryCount</P></TD><TD VALIGN="TOP"><P>Number of valid low bytes for this subHeader. </P></TD></TR><TR><TD VALIGN="TOP"><P>SHORT</P></TD><TD VALIGN="TOP"><P>idDelta</P></TD><TD VALIGN="TOP"><P>See text below.</P></TD></TR><TR><TD VALIGN="TOP"><P>USHORT</P></TD><TD VALIGN="TOP"><P>idRangeOffset</P></TD><TD VALIGN="TOP"><P>See text below.</P></TD></TR></TBODY></TABLE>
<BR></P>The firstCode and entryCount values specify a subrange that begins at firstCode and has a length equal to the value of entryCount. This subrange stays within the 0–255 range of the byte being mapped. Bytes outside of this subrange are mapped to glyph index 0 (missing glyph).The offset of the byte within this subrange is then used as index into a corresponding subarray of glyphIndexArray. This subarray is also of length entryCount. The value of the idRangeOffset is the number of bytes past the actual location of the idRangeOffset word where the glyphIndexArray element corresponding to firstCode appears.</P>
Finally, if the value obtained from the subarray is not 0 (which indicates the missing glyph), you should add idDelta to it in order to get the glyphIndex. The value idDelta permits the same subarray to be used for several different subheaders. The idDelta arithmetic is modulo 65536.</P>
<H4><A NAME="sec2"></A>Format 4: Segment mapping to delta valuesFormat 4: Segment mapping to delta values</H4>This is the Microsoft standard character to glyph index mapping table. </P>
This format is used when the character codes for the characters represented by a font fall into several contiguous ranges, possibly with holes in some or all of the ranges (that is, some of the codes in a range may not have a representation in the font). The format-dependent data is divided into three parts, which must occur in the following order: </P>
1.    A four-word header gives parameters for an optimized search of the segment list; </P>
2.    Four parallel arrays describe the segments (one segment for each contiguous range of codes); </P>
3.    A variable-length array of glyph IDs (unsigned words).</P>

<TABLE COLS="3" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="72pt" VALIGN="TOP"><COL WIDTH="144pt" VALIGN="TOP"><COL WIDTH="200pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>Type</P></TD><TD VALIGN="TOP"><P>Name</P></TD><TD VALIGN="TOP"><P>Description</P></TD></TR><TR><TD VALIGN="TOP"><P>USHORT</P></TD><TD VALIGN="TOP"><P>format</P></TD><TD VALIGN="TOP"><P>Format number is set to 4. </P></TD></TR><TR><TD VALIGN="TOP"><P>USHORT</P></TD><TD VALIGN="TOP"><P>length</P></TD><TD VALIGN="TOP"><P>Length in bytes. </P></TD></TR><TR><TD VALIGN="TOP"><P>USHORT</P></TD><TD VALIGN="TOP"><P>version</P></TD><TD VALIGN="TOP"><P>Version number (starts at 0).</P></TD></TR><TR><TD VALIGN="TOP"><P>USHORT</P></TD><TD VALIGN="TOP"><P>segCountX2 </P></TD><TD VALIGN="TOP"><P>2 x segCount.</P></TD></TR><TR><TD VALIGN="TOP"><P>USHORT</P></TD><TD VALIGN="TOP"><P>searchRange </P></TD><TD VALIGN="TOP"><P>2 x (2**floor(log2(segCount)))</P></TD></TR><TR><TD VALIGN="TOP"><P>USHORT</P></TD><TD VALIGN="TOP"><P>entrySelector </P></TD><TD VALIGN="TOP"><P>log2(searchRange/2)</P></TD></TR><TR><TD VALIGN="TOP"><P>USHORT</P></TD><TD VALIGN="TOP"><P>rangeShift </P></TD><TD VALIGN="TOP"><P>2 x segCount - searchRange</P></TD></TR><TR><TD VALIGN="TOP"><P>USHORT</P></TD><TD VALIGN="TOP"><P>endCount[segCount]</P></TD><TD VALIGN="TOP"><P>End characterCode for each segment, last =0xFFFF.</P></TD></TR><TR><TD VALIGN="TOP"><P>USHORT</P></TD><TD VALIGN="TOP"><P>reservedPad</P></TD><TD VALIGN="TOP"><P>Set to 0.</P></TD></TR><TR><TD VALIGN="TOP"><P>USHORT</P></TD><TD VALIGN="TOP"><P>startCount[segCount]</P></TD><TD VALIGN="TOP"><P>Start character code for each segment.</P></TD></TR><TR><TD VALIGN="TOP"><P>USHORT</P></TD><TD VALIGN="TOP"><P>idDelta[segCount]</P></TD><TD VALIGN="TOP"><P>Delta for all character codes in segment.</P></TD></TR><TR><TD VALIGN="TOP"><P>USHORT</P></TD><TD VALIGN="TOP"><P>idRangeOffset[segCount]</P></TD><TD VALIGN="TOP"><P>Offsets into glyphIdArray or 0</P></TD></TR><TR><TD VALIGN="TOP"><P>USHORT</P></TD><TD VALIGN="TOP"><P>glyphIdArray[ ]</P></TD><TD VALIGN="TOP"><P>Glyph index array (arbitrary length)</P></TD></TR></TBODY></TABLE>
<BR></P>The number of segments is specified by segCount, which is not explicitly in the header; however, all of the header parameters are derived from it. The searchRange value is twice the largest power of 2 that is less than or equal to  segCount. For example, if segCount=39, we have the following:</P>

<TABLE COLS="3" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="131pt" VALIGN="TOP"><COL WIDTH="74pt" VALIGN="TOP"><COL WIDTH="230pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>segCountX2</P></TD><TD VALIGN="TOP"><P>78</P></TD><TD VALIGN="TOP"><P></P></TD></TR><TR><TD VALIGN="TOP"><P>searchRange</P></TD><TD VALIGN="TOP"><P>64</P></TD><TD VALIGN="TOP"><P>(2 * largest power of 2 <SPAN CLASS="Symbol">£</SPAN> 39)</P></TD></TR><TR><TD VALIGN="TOP"><P>entrySelector</P></TD><TD VALIGN="TOP"><P>5</P></TD><TD VALIGN="TOP"><P>log2(32)</P></TD></TR><TR><TD VALIGN="TOP"><P>rangeShift</P></TD><TD VALIGN="TOP"><P>14</P></TD><TD VALIGN="TOP"><P>2 x 39 - 64</P></TD></TR></TBODY></TABLE>
<BR></P>Each segment is described by a startCode and endCode, along with an idDelta and an idRangeOffset, which are used for mapping the character codes in the segment. The segments are sorted in order of increasing endCode values, and the segment values are specified in four parallel arrays. You search for the first endCode that is greater than or equal to the character code you want to map. If the corresponding startCode is less than or equal to the character code, then you use the corresponding idDelta and idRangeOffset to map the character code to a glyph index (otherwise, the missingGlyph is returned). For the search to terminate, the final endCode value must be 0xFFFF. This segment need not contain any valid mappings. (It can just map the single character code 0xFFFF to missingGlyph). However, the segment must be present.</P>
If the idRangeOffset value for the segment is not 0, the mapping of character codes relies on glyphIdArray. The character code offset from startCode is added to the idRangeOffset value. This sum is used as an offset from the current location within idRangeOffset itself to index out the correct glyphIdArray value. This obscure indexing trick works because glyphIdArray immediately follows idRangeOffset in the font file. The C expression that yields the glyph index is:</P>
*(idRangeOffset[i]/2 + (c - startCount[i]) + &amp;idRangeOffset[i])</P>
The value <I>c</I>  is the character code in question, and <I>i</I>  is the segment index in which <I>c</I>  appears. If the value obtained from the indexing operation is not 0 (which indicates missingGlyph), idDelta[i] is added to it to get the glyph index. The idDelta arithmetic is modulo 65536.</P>
If the idRangeOffset is 0, the idDelta value is added directly to the character code offset (i.e. idDelta[i] + c) to get the corresponding glyph index. Again, the idDelta arithmetic is modulo 65536.</P>
As an example, the variant part of the table to map characters 10–20, 30–90, and 100–153 onto a contiguous range of glyph indices may look like this:</P>

<TABLE COLS="5" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="99pt" VALIGN="TOP"><COL WIDTH="45pt" VALIGN="TOP"><COL WIDTH="45pt" VALIGN="TOP"><COL WIDTH="54pt" VALIGN="TOP"><COL WIDTH="194pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>segCountX2:</P></TD><TD VALIGN="TOP"><P>8</P></TD><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P></P></TD></TR><TR><TD VALIGN="TOP"><P>searchRange:</P></TD><TD VALIGN="TOP"><P>8</P></TD><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P></P></TD></TR><TR><TD VALIGN="TOP"><P>entrySelector:</P></TD><TD VALIGN="TOP"><P>4</P></TD><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P></P></TD></TR><TR><TD VALIGN="TOP"><P>rangeShift:</P></TD><TD VALIGN="TOP"><P>0</P></TD><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P></P></TD></TR><TR><TD VALIGN="TOP"><P>endCode:</P></TD><TD VALIGN="TOP"><P>20</P></TD><TD VALIGN="TOP"><P>90</P></TD><TD VALIGN="TOP"><P>153</P></TD><TD VALIGN="TOP"><P>0xFFFF</P></TD></TR><TR><TD VALIGN="TOP"><P>reservedPad:</P></TD><TD VALIGN="TOP"><P>0</P></TD><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P></P></TD></TR><TR><TD VALIGN="TOP"><P>startCode:</P></TD><TD VALIGN="TOP"><P>10</P></TD><TD VALIGN="TOP"><P>30</P></TD><TD VALIGN="TOP"><P>100</P></TD><TD VALIGN="TOP"><P>0xFFFF</P></TD></TR><TR><TD VALIGN="TOP"><P>idDelta:</P></TD><TD VALIGN="TOP"><P>-9</P></TD><TD VALIGN="TOP"><P>-18</P></TD><TD VALIGN="TOP"><P>-27</P></TD><TD VALIGN="TOP"><P>1</P></TD></TR><TR><TD VALIGN="TOP"><P>idRangeOffset:</P></TD><TD VALIGN="TOP"><P>0</P></TD><TD VALIGN="TOP"><P>0</P></TD><TD VALIGN="TOP"><P>0</P></TD><TD VALIGN="TOP"><P>0</P></TD></TR></TBODY></TABLE>
<BR></P>This table performs the following mappings:</P>
10 –&gt; 10 – 9 = 1</P>
20 –&gt; 20 – 9 = 11</P>
30 –&gt; 30 – 18 = 12</P>
90 –&gt; 90 – 18 = 72</P>
...and so on.</P>
Note that the delta values could be reworked so as to reorder the segments.</P>
<H4><A NAME="sec3"></A>Format 6: Trimmed table mappingFormat 6: Trimmed table mapping</H4>
<TABLE COLS="3" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="75pt" VALIGN="TOP"><COL WIDTH="119pt" VALIGN="TOP"><COL WIDTH="220pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>Type</P></TD><TD VALIGN="TOP"><P>Name</P></TD><TD VALIGN="TOP"><P>Description</P></TD></TR><TR><TD VALIGN="TOP"><P>USHORT</P></TD><TD VALIGN="TOP"><P>format</P></TD><TD VALIGN="TOP"><P>Format number is set to 6.</P></TD></TR><TR><TD VALIGN="TOP"><P>USHORT</P></TD><TD VALIGN="TOP"><P>length</P></TD><TD VALIGN="TOP"><P>Length in bytes. </P></TD></TR><TR><TD VALIGN="TOP"><P>USHORT</P></TD><TD VALIGN="TOP"><P>version</P></TD><TD VALIGN="TOP"><P>Version number (starts at 0)</P></TD></TR><TR><TD VALIGN="TOP"><P>USHORT</P></TD><TD VALIGN="TOP"><P>firstCode</P></TD><TD VALIGN="TOP"><P>First character code of subrange.</P></TD></TR><TR><TD VALIGN="TOP"><P>USHORT</P></TD><TD VALIGN="TOP"><P>entryCount</P></TD><TD VALIGN="TOP"><P>Number of character codes in subrange.</P></TD></TR><TR><TD VALIGN="TOP"><P>USHORT</P></TD><TD VALIGN="TOP"><P>glyphIdArray [entryCount]</P></TD><TD VALIGN="TOP"><P>Array of glyph index values for character codes in the range.</P></TD></TR></TBODY></TABLE>
<BR></P>The firstCode and entryCount values specify a subrange (beginning at firstCode,length = entryCount) within the range of possible character codes. Codes outside of this subrange are mapped to glyph index 0. The offset of the code (from the first code) within this subrange is used as index to the glyphIdArray, which provides the glyph index value.</P></BODY></HTML>
