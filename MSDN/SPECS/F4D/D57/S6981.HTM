<HTML><HEAD><META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>'VDMX' - Vertical Device Metrics</TITLE><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">
</OBJECT></FORM>
<H3>'VDMX' - Vertical Device Metrics</H3>Under Windows, the usWinAscent and usWinDescent values from the 'OS/2' table will be used to determine the maximum black height for a font at any given size. Windows calls this distance the Font Height. Because TrueType instructions can lead to Font Heights that differ from the actual scaled and rounded values, basing the Font Height strictly on the yMax and yMin can result in "lost pixels." Windows will clip any pixels that extend above the yMax or below the yMin. In order to avoid grid fitting the entire font to determine the correct height, the VDMX table has been defined.</P>
The VDMX table consists of a header followed by groupings of VDMX records:</P>

<TABLE COLS="3" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="80pt" VALIGN="TOP"><COL WIDTH="115pt" VALIGN="TOP"><COL WIDTH="247pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>Type</P></TD><TD VALIGN="TOP"><P>Name</P></TD><TD VALIGN="TOP"><P>Description</P></TD></TR><TR><TD VALIGN="TOP"><P>USHORT</P></TD><TD VALIGN="TOP"><P>version</P></TD><TD VALIGN="TOP"><P>Version number (starts at 0).</P></TD></TR><TR><TD VALIGN="TOP"><P>USHORT</P></TD><TD VALIGN="TOP"><P>numRecs</P></TD><TD VALIGN="TOP"><P>Number of VDMX groups present</P></TD></TR><TR><TD VALIGN="TOP"><P>USHORT</P></TD><TD VALIGN="TOP"><P>numRatios</P></TD><TD VALIGN="TOP"><P>Number of aspect ratio groupings</P></TD></TR><TR><TD VALIGN="TOP"><P>Ratios</P></TD><TD VALIGN="TOP"><P>ratRange[numRatios]</P></TD><TD VALIGN="TOP"><P>Ratio ranges (see below for more info)</P></TD></TR><TR><TD VALIGN="TOP"><P>USHORT</P></TD><TD VALIGN="TOP"><P>offset[numRatios]</P></TD><TD VALIGN="TOP"><P>Offset from start of this table to the VDMX group for this ratio range.</P></TD></TR><TR><TD VALIGN="TOP"><P>Vdmx</P></TD><TD VALIGN="TOP"><P>groups</P></TD><TD VALIGN="TOP"><P>The actual VDMX groupings (documented below)</P></TD></TR></TBODY></TABLE>
<BR></P>struct     Ratios {<BR>     BYTE     bCharSet;     /* Character set (see below) */<BR>     BYTE     xRatio;     /* Value to use for x-Ratio */<BR>     BYTE     yStartRatio;     /* Starting y-Ratio value */<BR>     BYTE     yEndRatio     /* Ending y-ratio value */<BR>}</P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="180pt" VALIGN="TOP"><COL WIDTH="144pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD COLSPAN="2" VALIGN="TOP"><P>Ratios are set up as follows:</P></TD></TR><TR><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P></P></TD></TR><TR><TD VALIGN="TOP"><P>For a 1:1 aspect ratio</P></TD><TD VALIGN="TOP"><P>Ratios.xRatio = 1;<BR>Ratios.yStartRatio = 1;<BR>Ratios.yEndRatio = 1;</P></TD></TR><TR><TD VALIGN="TOP"><P>For 1:1 through 2:1 ratio</P></TD><TD VALIGN="TOP"><P>Ratios.xRatio = 2;<BR>Ratios.yStartRatio = 1;<BR>Ratios.yEndRatio = 2;</P></TD></TR><TR><TD VALIGN="TOP"><P>For 1.33:1 ratio</P></TD><TD VALIGN="TOP"><P>Ratios.xRatio = 4;<BR>Ratios.yStartRatio = 3;<BR>Ratios.yEndRatio = 3;</P></TD></TR><TR><TD VALIGN="TOP"><P>For <I>all</I> aspect ratios</P></TD><TD VALIGN="TOP"><P>Ratio.xRatio = 0;<BR>Ratio.yStartRatio = 0;<BR>Ratio.yEndRatio = 0;</P></TD></TR></TBODY></TABLE>
<BR></P>All values set to zero signal the default grouping to use; if present, this must be the <I>last</I> Ratio group in the table. Ratios of 2:2 are the same as 1:1.</P>
Aspect ratios are matched against the target device by normalizing the entire ratio range record based on the current X resolution and performing a range check of Y resolutions for each record after normalization. Once a match is found, the search stops. If the 0,0,0 group is encountered during the search, it is used (therefore if this group is not at the end of the ratio groupings, no group that follows it will be used). If there is not a match and there is no 0,0,0 record, then there is no VDMX data for that aspect ratio.</P>
Note that range checks are conceptually performed as follows:</P>
(deviceXRatio == Ratio.xRatio) &amp;&amp; (deviceYRatio &gt;= Ratio.yStartRatio) &amp;&amp; (deviceYRatio &lt;= <BR>   Ratio.yEndRatio)</P>
Each ratio grouping refers to a specific VDMX record group; there must be at least 1 VDMX group in the table.</P>
The uCharSet value is used to denote cases where the VDMX group was computed based on a subset of the glyphs present in the font file. The currently defined values for character set are:</P>

<TABLE COLS="2" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="80pt" VALIGN="TOP"><COL WIDTH="360pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>uCharSet</P></TD><TD VALIGN="TOP"><P>Description</P></TD></TR><TR><TD VALIGN="TOP"><P>0</P></TD><TD VALIGN="TOP"><P>No subset; the VDMX group applies to all glyphs in the font. This is used for symbol or dingbat fonts.</P></TD></TR><TR><TD VALIGN="TOP"><P>1</P></TD><TD VALIGN="TOP"><P>Windows ANSI subset; the VDMX group was computed using only the glyphs required to complete the Windows ANSI character set. Windows will ignore any VDMX entries that are not for the ANSI subset (i.e. uCharSet = 1)</P></TD></TR></TBODY></TABLE>
<BR></P>VDMX groups immediately follow the table header. Each set of records (there need only be one set) has the following layout:</P>

<TABLE COLS="3" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="80pt" VALIGN="TOP"><COL WIDTH="115pt" VALIGN="TOP"><COL WIDTH="247pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>Type</P></TD><TD VALIGN="TOP"><P>Name</P></TD><TD VALIGN="TOP"><P>Description</P></TD></TR><TR><TD VALIGN="TOP"><P>USHORT</P></TD><TD VALIGN="TOP"><P>recs</P></TD><TD VALIGN="TOP"><P>Number of height records in this group</P></TD></TR><TR><TD VALIGN="TOP"><P>BYTE</P></TD><TD VALIGN="TOP"><P>startsz</P></TD><TD VALIGN="TOP"><P>Starting yPelHeight</P></TD></TR><TR><TD VALIGN="TOP"><P>BYTE</P></TD><TD VALIGN="TOP"><P>endsz</P></TD><TD VALIGN="TOP"><P>Ending yPelHeight</P></TD></TR><TR><TD VALIGN="TOP"><P>vTable</P></TD><TD VALIGN="TOP"><P>entry[recs]</P></TD><TD VALIGN="TOP"><P>The VDMX records</P></TD></TR></TBODY></TABLE>
<BR></P>struct     vTable {<BR>     USHORT     yPelHeight;     /* yPelHeight to which values apply */<BR>     SHORT      yMax;           /* yMax (in pels) for this yPelHeight */<BR>     SHORT      yMin;           /* yMin (in pels) for this yPelHeight */<BR>}</P>
This table must appear in sorted order (sorted by yPelHeight), but need not be continous. It should have an entry for every pel height where the yMax and yMin do not scale linearly, where linearly scaled heights are defined as:</P>
Hinted yMax and yMin are identical to scaled/rounded yMax and yMin</P>
It is assumed that once yPelHeight reaches 255, all heights will be linear, or at least close enough to linear that it no longer matters. Please note that while the Ratios structure can only support ppem sizes up to 255, the vTable structure can support much larger pel heights (up to 65535). The choice of SHORT and USHORT for vTable is dictated by the requirement that yMax and yMin be signed values (and 127 to -128 is too small a range) and the desire to word-align the vTable elements.</P></BODY></HTML>
