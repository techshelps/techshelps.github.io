<HTML><HEAD><META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Managing the flow of control</TITLE><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">
</OBJECT></FORM>
<H2>Managing the flow of control</H2>This section describes those instructions that make it possible to alter the sequence in which items in the instruction stream are executed. The IF and JMP instructions and their variants work by testing the value of an element on the stack and changing the value of the instruction pointer accordingly.</P>
<H3><A NAME="sec0"></A>IF <I>test</I></H3>IF[ ] </P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="72pt" VALIGN="TOP"><COL WIDTH="370pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>Code Range</P></TD><TD VALIGN="TOP"><P>0x58</P></TD></TR><TR><TD VALIGN="TOP"><P>Pops</P></TD><TD VALIGN="TOP"><P>e: stack element (ULONG)</P></TD></TR><TR><TD VALIGN="TOP"><P>Pushes</P></TD><TD VALIGN="TOP"><P>–</P></TD></TR></TBODY></TABLE>
<BR></P>Tests the element popped off the stack: if it is zero (FALSE), the instruction pointer is jumped to the next ELSE or EIF instruction in the instruction stream. If the element at the top of the stack is nonzero (TRUE),  the next instruction in the instruction stream is executed. Execution continues until an ELSE instruction is encountered or an EIF instruction ends the IF. If an else statement is found before the EIF, the instruction pointer is moved to the EIF statement.</P>
<I>case 1:</I></P>
Element at top of stack is TRUE; instruction pointer is unaffected. IF terminates with EIF.</P>
<P><img src="13904.gif"></P>
<I>case 2:</I></P>
Element at top of stack is TRUE. The instruction stream is sequentially executed until ELSE is encountered whereupon the instruction pointer jumps to the EIF statement that terminates the IF.</P>
<P><img src="13905.gif"></P>
<I>case 3:</I></P>
Element at the top of the stack is FALSE; instruction pointer is moved to the ELSE statement; instructions are then executed sequentially; EIF ends the IF statement.</P>
<P><img src="13906.gif"></P>
<H3><A NAME="sec1"></A>ELSE</H3>ELSE[ ]</P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="72pt" VALIGN="TOP"><COL WIDTH="370pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>Code Range</P></TD><TD VALIGN="TOP"><P>0x1B</P></TD></TR><TR><TD VALIGN="TOP"><P>Pops</P></TD><TD VALIGN="TOP"><P>–</P></TD></TR><TR><TD VALIGN="TOP"><P>Pushes</P></TD><TD VALIGN="TOP"><P>–</P></TD></TR></TBODY></TABLE>
<BR></P>Marks the start of the sequence of instructions that are to be executed if an IF instruction encounters a FALSE value on the stack. This sequence of instructions is terminated with an EIF instruction.</P>
<H3><A NAME="sec2"></A>End IF</H3>EIF[ ]</P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="72pt" VALIGN="TOP"><COL WIDTH="370pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>Code Range</P></TD><TD VALIGN="TOP"><P>0x59</P></TD></TR><TR><TD VALIGN="TOP"><P>Pops</P></TD><TD VALIGN="TOP"><P>–</P></TD></TR><TR><TD VALIGN="TOP"><P>Pushes</P></TD><TD VALIGN="TOP"><P>–</P></TD></TR></TBODY></TABLE>
<BR></P>Marks the end of an IF[ ] instruction.</P>
<H3><A NAME="sec3"></A>Jump Relative On True</H3>JROT[ ] </P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="72pt" VALIGN="TOP"><COL WIDTH="370pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>Code Range</P></TD><TD VALIGN="TOP"><P>0x78 </P></TD></TR><TR><TD VALIGN="TOP"><P>Pops</P></TD><TD VALIGN="TOP"><P>b: Boolean  (ULONG)</P></TD></TR><TR><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P>offset: number of bytes to move instruction pointer (LONG)</P></TD></TR><TR><TD VALIGN="TOP"><P>Pushes</P></TD><TD VALIGN="TOP"><P>–</P></TD></TR></TBODY></TABLE>
<BR></P>Obtains an offset and tests a Boolean value. If the Boolean is TRUE, the signed offset will be added to the instruction pointer and execution will be resumed at the address obtained. Otherwise, the jump is not taken.  The jump is relative to the position of the instruction itself. That is, the instruction pointer is still pointing at the JROT[ ] instruction when offset is added to obtain the new address.</P>
<P><img src="13907.gif"></P>
<I>Example:</I></P>
<I>case 1:</I></P>
Boolean is FALSE.</P>
<img src="13908.gif"></P>
<I>case 2:</I></P>
Boolean is TRUE.</P>
<P><img src="13909.gif"></P>
<H3><A NAME="sec4"></A>JuMP</H3>JMPR[ ]</P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="72pt" VALIGN="TOP"><COL WIDTH="370pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>Code Range</P></TD><TD VALIGN="TOP"><P>0x1C</P></TD></TR><TR><TD VALIGN="TOP"><P>Pops</P></TD><TD VALIGN="TOP"><P>offset: number of bytes to move instruction pointer (LONG)</P></TD></TR><TR><TD VALIGN="TOP"><P>Pushes</P></TD><TD VALIGN="TOP"><P>–</P></TD></TR></TBODY></TABLE>
<BR></P>The signed offset is added to the instruction pointer and execution is resumed at the new location in the instruction steam. The jump is relative to the position of the instruction itself. That is, the instruction pointer is still pointing at the JROT[ ] instruction when offset is added to obtain the new address.</P>
<P><img src="13910.gif"></P>
<H3><A NAME="sec5"></A>Jump Relative On False</H3>JROF[ ] </P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="72pt" VALIGN="TOP"><COL WIDTH="370pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>Code Range</P></TD><TD VALIGN="TOP"><P>0x79</P></TD></TR><TR><TD VALIGN="TOP"><P>Pops</P></TD><TD VALIGN="TOP"><P>e: stack element (ULONG)</P></TD></TR><TR><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P>offset: number of bytes to move instruction pointer (LONG)</P></TD></TR><TR><TD VALIGN="TOP"><P>Pushes</P></TD><TD VALIGN="TOP"><P>–</P></TD></TR></TBODY></TABLE>
<BR></P>In the case where the Boolean is FALSE, the signed offset will be added to the instruction pointer and execution will be resumed there; otherwise, the jump is not taken.  The jump is relative to the position of the instruction itself. That is, the instruction pointer is still pointing at the JROT[ ] instruction when offset is added to obtain the new address.</P>
<P><img src="13911.gif"></P>
<I>case 1:</I></P>
element is FALSE.</P>
<P><img src="13912.gif"></P>
<I>case 2:</I></P>
element is TRUE.</P>
<P><img src="13913.gif"></P></BODY></HTML>
