<HTML><HEAD><META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>EBLC - Embedded Bitmap Location Table</TITLE><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">
</OBJECT></FORM>
<H3>EBLC - Embedded Bitmap Location Table</H3>Three new tables are used to embed bitmaps in TrueType fonts. They are the 'EBLC' table for embedded bitmap locators, the 'EBDT' table for embedded bitmap data, and the 'EBSC' table for embedded bitmap scaling information. TrueType embedded bitmaps are called 'sbits' (for "scaler bitmaps"). A set of bitmaps for a face at a given size is called a strike.</P>
The 'EBLC' table identifies the sizes and glyph ranges of the sbits, and keeps offsets to glyph bitmap data in indexSubTables. The 'EBDT' table then stores the glyph bitmap data, also in a number of different possible formats. Glyph metrics information may be stored in either the 'EBLC' or 'EBDT' table, depending upon the indexSubTable and glyph bitmap formats. The 'EBSC' table identifies sizes that will be handled by scaling up or scaling down other sbit sizes.</P>
The 'EBLC' table uses the same format as the Apple QuickDraw GX 'bloc' table.</P>
The 'EBLC' table begins with a header containing the table version and number of strikes. A TrueType font may have one or more strikes embedded in the 'EBDT' table.</P>
<H4><A NAME="sec0"></A>eblcHeader</H4>
<TABLE COLS="3" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="75pt" VALIGN="TOP"><COL WIDTH="119pt" VALIGN="TOP"><COL WIDTH="220pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>Type</P></TD><TD VALIGN="TOP"><P>Name</P></TD><TD VALIGN="TOP"><P>Description</P></TD></TR><TR><TD VALIGN="TOP"><P>FIXED</P></TD><TD VALIGN="TOP"><P>version</P></TD><TD VALIGN="TOP"><P>initially defined as 0x00020000</P></TD></TR><TR><TD VALIGN="TOP"><P>ULONG</P></TD><TD VALIGN="TOP"><P>numSizes</P></TD><TD VALIGN="TOP"><P>Number of bitmapSizeTables</P></TD></TR></TBODY></TABLE>
<BR></P>The eblcHeader is followed immediately by the bitmapSizeTable array(s). The numSizes in the eblcHeader indicates the number of bitmapSizeTables in the array. Each strike is defined by one bitmapSizeTable.</P>
<H4><A NAME="sec1"></A>bitmapSizeTable</H4>
<TABLE COLS="3" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="89pt" VALIGN="TOP"><COL WIDTH="139pt" VALIGN="TOP"><COL WIDTH="185pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>Type</P></TD><TD VALIGN="TOP"><P>Name</P></TD><TD VALIGN="TOP"><P>Description</P></TD></TR><TR><TD VALIGN="TOP"><P>ULONG</P></TD><TD VALIGN="TOP"><P>indexSubTableArrayOffset</P></TD><TD VALIGN="TOP"><P>offset to index subtable from beginning of EBLC.</P></TD></TR><TR><TD VALIGN="TOP"><P>ULONG</P></TD><TD VALIGN="TOP"><P>indexTablesSize</P></TD><TD VALIGN="TOP"><P>number of bytes in corresponding index subtables and array</P></TD></TR><TR><TD VALIGN="TOP"><P>ULONG</P></TD><TD VALIGN="TOP"><P>numberOfIndexSubTables</P></TD><TD VALIGN="TOP"><P>an index subtable for each range or format change</P></TD></TR><TR><TD VALIGN="TOP"><P>ULONG</P></TD><TD VALIGN="TOP"><P>colorRef</P></TD><TD VALIGN="TOP"><P>not used; set to 0.</P></TD></TR><TR><TD VALIGN="TOP"><P>sbitLineMetrics</P></TD><TD VALIGN="TOP"><P>hori</P></TD><TD VALIGN="TOP"><P>line metrics for text rendered horizontally</P></TD></TR><TR><TD VALIGN="TOP"><P>sbitLineMetrics</P></TD><TD VALIGN="TOP"><P>vert</P></TD><TD VALIGN="TOP"><P>line metrics for text rendered vertically</P></TD></TR><TR><TD VALIGN="TOP"><P>USHORT</P></TD><TD VALIGN="TOP"><P>startGlyphIndex</P></TD><TD VALIGN="TOP"><P>lowest glyph index for this size</P></TD></TR><TR><TD VALIGN="TOP"><P>USHORT</P></TD><TD VALIGN="TOP"><P>endGlyphIndex</P></TD><TD VALIGN="TOP"><P>highest glyph index for this size</P></TD></TR><TR><TD VALIGN="TOP"><P>BYTE</P></TD><TD VALIGN="TOP"><P>ppemX</P></TD><TD VALIGN="TOP"><P>horizontal pixels per Em</P></TD></TR><TR><TD VALIGN="TOP"><P>BYTE</P></TD><TD VALIGN="TOP"><P>ppemY</P></TD><TD VALIGN="TOP"><P>vertical pixels per Em</P></TD></TR><TR><TD VALIGN="TOP"><P>BYTE</P></TD><TD VALIGN="TOP"><P>bitDepth</P></TD><TD VALIGN="TOP"><P>set to 1 for now</P></TD></TR><TR><TD VALIGN="TOP"><P>CHAR</P></TD><TD VALIGN="TOP"><P>flags</P></TD><TD VALIGN="TOP"><P>vertical or horizontal (see bitmapFlags)</P></TD></TR></TBODY></TABLE>
<BR></P>The indexSubTableArrayOffset is the offset from the beginning of the 'EBLC' table to the indexSubTableArray. Each strike has one of these arrays to support various formats and discontiguous ranges of bitmaps. The indexTablesSize is the total number of bytes in the indexSubTableArray and the associated indexSubTables. The numberOfIndexSubTables is a count of the indexSubTables for this strike.</P>
The horizontal and vertical line metrics contain the ascender, descender, linegap, and advance information for the strike. The line metrics format is described in the following table:</P>
<H4><A NAME="sec2"></A>sbitLineMetrics</H4>
<TABLE COLS="2" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="53pt" VALIGN="TOP"><COL WIDTH="140pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>Type</P></TD><TD VALIGN="TOP"><P>Name</P></TD></TR><TR><TD VALIGN="TOP"><P>CHAR</P></TD><TD VALIGN="TOP"><P>ascender</P></TD></TR><TR><TD VALIGN="TOP"><P>CHAR</P></TD><TD VALIGN="TOP"><P>descender</P></TD></TR><TR><TD VALIGN="TOP"><P>BYTE</P></TD><TD VALIGN="TOP"><P>widthMax</P></TD></TR><TR><TD VALIGN="TOP"><P>CHAR</P></TD><TD VALIGN="TOP"><P>caretSlopeNumerator</P></TD></TR><TR><TD VALIGN="TOP"><P>CHAR</P></TD><TD VALIGN="TOP"><P>caretSlopeDenominator</P></TD></TR><TR><TD VALIGN="TOP"><P>CHAR</P></TD><TD VALIGN="TOP"><P>caretOffset</P></TD></TR><TR><TD VALIGN="TOP"><P>CHAR</P></TD><TD VALIGN="TOP"><P>minOriginSB</P></TD></TR><TR><TD VALIGN="TOP"><P>CHAR</P></TD><TD VALIGN="TOP"><P>minAdvanceSB</P></TD></TR><TR><TD VALIGN="TOP"><P>CHAR</P></TD><TD VALIGN="TOP"><P>maxBeforeBL</P></TD></TR><TR><TD VALIGN="TOP"><P>CHAR</P></TD><TD VALIGN="TOP"><P>minAfterBL</P></TD></TR><TR><TD VALIGN="TOP"><P>CHAR</P></TD><TD VALIGN="TOP"><P>pad1</P></TD></TR><TR><TD VALIGN="TOP"><P>CHAR</P></TD><TD VALIGN="TOP"><P>pad2</P></TD></TR></TBODY></TABLE>
<BR></P>The caret slope determines the angle at which the caret is drawn, and the offset is the number of pixels (+ or -) to move the caret. This is a signed char since we are dealing with integer metrics. The minOriginSB, minAdvanceSB , maxBeforeBL, and minAfterBL are described in the diagrams below. The main need for these numbers is for scalers that may need to pre-allocate memory and/or need more metric information to position glyphs. All of the line metrics are one byte in length. The line metrics are not used directly by the rasterizer, but are available to clients who want to parse the 'EBLC' table.</P>
The startGlyphIndex and endGlyphIndex describe the minimum and maximum glyph codes in the strike, but a strike does not necessarily contain bitmaps for all glyph codes in this range. The indexSubTables determine which glyphs are actually present in the 'EBDT' table.</P>
The ppemX and ppemY fields describe the size of the strike in pixels per Em. The ppem measurement is equivalent to point size on a 72 dots per inch device. Typically, ppemX will be equal to ppemY for devices with 'square pixels'. To accommodate devices with rectangular pixels, and to allow for bitmaps with other aspect ratios, ppemX and ppemY may differ.</P>
The 'flags' byte contains two bits to indicate the direction of small glyph metrics: horizontal or vertical.  The remaining bits are reserved.</P>
<H4><A NAME="sec3"></A>Bitmap Flags</H4>
<TABLE COLS="3" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="75pt" VALIGN="TOP"><COL WIDTH="119pt" VALIGN="TOP"><COL WIDTH="220pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>Type</P></TD><TD VALIGN="TOP"><P>Value</P></TD><TD VALIGN="TOP"><P>Description</P></TD></TR><TR><TD VALIGN="TOP"><P>CHAR</P></TD><TD VALIGN="TOP"><P>0x01</P></TD><TD VALIGN="TOP"><P>Horizontal</P></TD></TR><TR><TD VALIGN="TOP"><P>CHAR</P></TD><TD VALIGN="TOP"><P>0x02</P></TD><TD VALIGN="TOP"><P>Vertical</P></TD></TR></TBODY></TABLE>
<BR></P>The colorRef and bitDepth fields are reserved for future enhancements. For monochrome bitmaps they should have the values colorRef=0 and bitDepth=1.</P>
<img src="za0t.gif"></P>
<img src="za1t.gif"> </P>
Associated with the image data for every glyph in a strike is a set of glyph metrics. These glyph metrics describe bounding box height and width, as well as side bearing and advance width information. The glyph metrics can be found in one of two places. For ranges of glyphs (not necessarily the whole strike) whose metrics may be different for each glyph, the glyph metrics are stored along with the glyph image data in the 'EBDT' table. Details of how this is done is described in the 'EBDT' section of this document. For ranges of glyphs whose metrics are identical for every glyph, we save significant space by storing a single copy of the glyph metrics in the indexSubTable in the 'EBLC'.</P>
There are also two different formats for glyph metrics: big glyph metrics and small glyph metrics. Big glyph metrics define metrics information for both horizontal and vertical layouts. This is important in fonts (such as Kanji) where both types of layout may be used. Small glyph metrics define metrics information for one layout direction only. Which direction applies, horizontal or vertical, is determined by the 'flags' field in the bitmapSizeTable.</P>
<H4><A NAME="sec4"></A>bigGlyphMetrics</H4>
<TABLE COLS="2" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="75pt" VALIGN="TOP"><COL WIDTH="119pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>Type</P></TD><TD VALIGN="TOP"><P>Name</P></TD></TR><TR><TD VALIGN="TOP"><P>BYTE</P></TD><TD VALIGN="TOP"><P>height</P></TD></TR><TR><TD VALIGN="TOP"><P>BYTE</P></TD><TD VALIGN="TOP"><P>width</P></TD></TR><TR><TD VALIGN="TOP"><P>CHAR</P></TD><TD VALIGN="TOP"><P>horiBearingX</P></TD></TR><TR><TD VALIGN="TOP"><P>CHAR</P></TD><TD VALIGN="TOP"><P>horiBearingY</P></TD></TR><TR><TD VALIGN="TOP"><P>BYTE</P></TD><TD VALIGN="TOP"><P>horiAdvance</P></TD></TR><TR><TD VALIGN="TOP"><P>CHAR</P></TD><TD VALIGN="TOP"><P>vertBearingX</P></TD></TR><TR><TD VALIGN="TOP"><P>CHAR</P></TD><TD VALIGN="TOP"><P>vertBearingY</P></TD></TR><TR><TD VALIGN="TOP"><P>BYTE</P></TD><TD VALIGN="TOP"><P>vertAdvance</P></TD></TR></TBODY></TABLE>
<BR></P><H4><A NAME="sec5"></A>smallGlyphMetrics</H4>
<TABLE COLS="2" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="75pt" VALIGN="TOP"><COL WIDTH="119pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>Type</P></TD><TD VALIGN="TOP"><P>Name</P></TD></TR><TR><TD VALIGN="TOP"><P>BYTE</P></TD><TD VALIGN="TOP"><P>height</P></TD></TR><TR><TD VALIGN="TOP"><P>BYTE</P></TD><TD VALIGN="TOP"><P>width</P></TD></TR><TR><TD VALIGN="TOP"><P>CHAR</P></TD><TD VALIGN="TOP"><P>BearingX</P></TD></TR><TR><TD VALIGN="TOP"><P>CHAR</P></TD><TD VALIGN="TOP"><P>BearingY</P></TD></TR><TR><TD VALIGN="TOP"><P>BYTE</P></TD><TD VALIGN="TOP"><P>Advance</P></TD></TR></TBODY></TABLE>
<BR></P>The following diagram illustrates the meaning of the glyph metrics.</P>
<img src="13522.gif"></P>
The bitmapSizeTable for each strike contains the offset to an array of indexSubTableArray elements. Each element describes a glyph code range and an offset to the indexSubTable for that range. This allows a strike to contain multiple glyph code ranges and to be represented in multiple index formats if desirable.</P>
<H4><A NAME="sec6"></A>indexSubTableArray</H4>
<TABLE COLS="3" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="58pt" VALIGN="TOP"><COL WIDTH="166pt" VALIGN="TOP"><COL WIDTH="189pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>Type</P></TD><TD VALIGN="TOP"><P>Name</P></TD><TD VALIGN="TOP"><P>Description</P></TD></TR><TR><TD VALIGN="TOP"><P>USHORT</P></TD><TD VALIGN="TOP"><P>firstGlyphIndex</P></TD><TD VALIGN="TOP"><P>first glyph code of this range</P></TD></TR><TR><TD VALIGN="TOP"><P>USHORT</P></TD><TD VALIGN="TOP"><P>lastGlyphIndex</P></TD><TD VALIGN="TOP"><P>last glyph code of this range (inclusive)</P></TD></TR><TR><TD VALIGN="TOP"><P>ULONG</P></TD><TD VALIGN="TOP"><P>additionalOffsetToIndexSubtable</P></TD><TD VALIGN="TOP"><P>add to indexSubTableArrayOffset to get offset from beginning of 'EBLC'</P></TD></TR></TBODY></TABLE>
<BR></P>After determining the strike, the rasterizer searches this array for the range containing the given glyph code. When the range is found, the additionalOffsetToIndexSubtable is added to the indexSubTableArrayOffset to get the offset of the indexSubTable in the 'EBLC'.</P>
The first indexSubTableArray is located after the last bitmapSizeSubTable entry. Then the indexSubTables for the strike follow. Another indexSubTableArray (if more than one strike) and its indexSubTables are next. The 'EBLC' continues with an array and indexSubTables for each strike.</P>
We now have the offset to the indexSubTable. All indexSubTable formats begin with an indexSubHeader which identifies the indexSubTable format, the format of the 'EBDT' image data, and the offset from the beginning of the 'EBDT' table to the beginning of the image data for this range.</P>
<H4><A NAME="sec7"></A>indexSubHeader</H4>
<TABLE COLS="3" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="62pt" VALIGN="TOP"><COL WIDTH="131pt" VALIGN="TOP"><COL WIDTH="220pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>Type</P></TD><TD VALIGN="TOP"><P>Name</P></TD><TD VALIGN="TOP"><P>Description</P></TD></TR><TR><TD VALIGN="TOP"><P>USHORT</P></TD><TD VALIGN="TOP"><P>indexFormat</P></TD><TD VALIGN="TOP"><P>format of this indexSubTable</P></TD></TR><TR><TD VALIGN="TOP"><P>USHORT</P></TD><TD VALIGN="TOP"><P>imageFormat</P></TD><TD VALIGN="TOP"><P>format of 'EBDT' image data</P></TD></TR><TR><TD VALIGN="TOP"><P>ULONG</P></TD><TD VALIGN="TOP"><P>imageDataOffset</P></TD><TD VALIGN="TOP"><P>offset to image data in 'EBDT' table</P></TD></TR></TBODY></TABLE>
<BR></P>There are currently five different formats used for the indexSubTable, depending upon the size and type of bitmap data in the glyph code range. Apple 'bloc' tables support only formats 1 through 3.</P>
The choice of which indexSubTable format to use is up to the font manufacturer, but should be made with the aim of minimizing the size of the font file. Ranges of glyphs with variable metrics — that is, where glyphs may differ from each other in bounding box height, width, side bearings or advance — must use format 1, 3 or 4. Ranges of glyphs with constant metrics can save space by using format 2 or 5, which keep a single copy of the metrics information in the indexSubTable rather than a copy per glyph in the 'EBDT' table. In some monospaced fonts it makes sense to store extra white space around some of the glyphs to keep all metrics identical, thus permitting the use of format 2 or 5.</P>
Structures for each indexSubTable format are listed below.</P>
<H4><A NAME="sec8"></A>indexSubTable1: variable metrics glyphs with 4 byte offsets</H4>
<TABLE COLS="3" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="98pt" VALIGN="TOP"><COL WIDTH="72pt" VALIGN="TOP"><COL WIDTH="243pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>Type</P></TD><TD VALIGN="TOP"><P>Name</P></TD><TD VALIGN="TOP"><P>Description</P></TD></TR><TR><TD VALIGN="TOP"><P>indexSubHeader</P></TD><TD VALIGN="TOP"><P>header</P></TD><TD VALIGN="TOP"><P>header info</P></TD></TR><TR><TD VALIGN="TOP"><P>ULONG</P></TD><TD VALIGN="TOP"><P>offsetArray[]</P></TD><TD VALIGN="TOP"><P>offsetArray[glyphIndex]+imageDataOffset=glyphData</P></TD></TR></TBODY></TABLE>
<BR></P><H4><A NAME="sec9"></A>indexSubTable2: all glyphs have identical metrics</H4>
<TABLE COLS="3" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="98pt" VALIGN="TOP"><COL WIDTH="72pt" VALIGN="TOP"><COL WIDTH="243pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>Type</P></TD><TD VALIGN="TOP"><P>Name</P></TD><TD VALIGN="TOP"><P>Description</P></TD></TR><TR><TD VALIGN="TOP"><P>indexSubHeader</P></TD><TD VALIGN="TOP"><P>header</P></TD><TD VALIGN="TOP"><P>header info</P></TD></TR><TR><TD VALIGN="TOP"><P>ULONG</P></TD><TD VALIGN="TOP"><P>imageSize</P></TD><TD VALIGN="TOP"><P>all the glyphs are of the same size</P></TD></TR><TR><TD VALIGN="TOP"><P>bigGlyphMetrics</P></TD><TD VALIGN="TOP"><P>bigMetrics</P></TD><TD VALIGN="TOP"><P>all glyphs have the same metrics; glyph data may be compressed, byte-aligned, or bit-aligned</P></TD></TR></TBODY></TABLE>
<BR></P><H4><A NAME="sec10"></A>indexSubTable3: variable metrics glyphs with 2 byte offsets</H4>
<TABLE COLS="3" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="98pt" VALIGN="TOP"><COL WIDTH="72pt" VALIGN="TOP"><COL WIDTH="243pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>Type</P></TD><TD VALIGN="TOP"><P>Name</P></TD><TD VALIGN="TOP"><P>Description</P></TD></TR><TR><TD VALIGN="TOP"><P>indexSubHeader</P></TD><TD VALIGN="TOP"><P>header</P></TD><TD VALIGN="TOP"><P>header info</P></TD></TR><TR><TD VALIGN="TOP"><P>USHORT</P></TD><TD VALIGN="TOP"><P>offsetArray[]</P></TD><TD VALIGN="TOP"><P>offsetArray[glyphIndex]+imageDataOffset=glyphData<BR>sizeOfArray=lastGlyph-firstGlyph+1+1 pad if needed</P></TD></TR></TBODY></TABLE>
<BR></P><H4><A NAME="sec11"></A>indexSubTable4: variable metrics glyphs with sparse glyph codes</H4>
<TABLE COLS="3" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="98pt" VALIGN="TOP"><COL WIDTH="72pt" VALIGN="TOP"><COL WIDTH="243pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>Type</P></TD><TD VALIGN="TOP"><P>Name</P></TD><TD VALIGN="TOP"><P>Description</P></TD></TR><TR><TD VALIGN="TOP"><P>indexSubHeader</P></TD><TD VALIGN="TOP"><P>header</P></TD><TD VALIGN="TOP"><P>header info</P></TD></TR><TR><TD VALIGN="TOP"><P>ULONG</P></TD><TD VALIGN="TOP"><P>numGlyphs</P></TD><TD VALIGN="TOP"><P>array length</P></TD></TR><TR><TD VALIGN="TOP"><P>codeOffsetPair</P></TD><TD VALIGN="TOP"><P>glyphArray[]</P></TD><TD VALIGN="TOP"><P>one per glyph; sizeOfArray=lastGlyph-firstGlyph+1</P></TD></TR></TBODY></TABLE>
<BR></P><H4><A NAME="sec12"></A>codeOffsetPair: used by indexSubTable4</H4>
<TABLE COLS="3" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="98pt" VALIGN="TOP"><COL WIDTH="72pt" VALIGN="TOP"><COL WIDTH="243pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>Type</P></TD><TD VALIGN="TOP"><P>Name</P></TD><TD VALIGN="TOP"><P>Description</P></TD></TR><TR><TD VALIGN="TOP"><P>USHORT</P></TD><TD VALIGN="TOP"><P>glyphCode</P></TD><TD VALIGN="TOP"><P>code of glyph present</P></TD></TR><TR><TD VALIGN="TOP"><P>USHORT</P></TD><TD VALIGN="TOP"><P>offset</P></TD><TD VALIGN="TOP"><P>location in EBDT</P></TD></TR></TBODY></TABLE>
<BR></P><H4><A NAME="sec13"></A>indexSubTable5: constant metrics glyphs with sparse glyph codes</H4>
<TABLE COLS="3" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="98pt" VALIGN="TOP"><COL WIDTH="99pt" VALIGN="TOP"><COL WIDTH="216pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>Type</P></TD><TD VALIGN="TOP"><P>Name</P></TD><TD VALIGN="TOP"><P>Description</P></TD></TR><TR><TD VALIGN="TOP"><P>indexSubHeader</P></TD><TD VALIGN="TOP"><P>header</P></TD><TD VALIGN="TOP"><P>header info</P></TD></TR><TR><TD VALIGN="TOP"><P>ULONG</P></TD><TD VALIGN="TOP"><P>imageSize</P></TD><TD VALIGN="TOP"><P>all glyphs have the same data size</P></TD></TR><TR><TD VALIGN="TOP"><P>bigGlyphMetrics</P></TD><TD VALIGN="TOP"><P>bigMetrics</P></TD><TD VALIGN="TOP"><P>all glyphs have the same metrics</P></TD></TR><TR><TD VALIGN="TOP"><P>ULONG</P></TD><TD VALIGN="TOP"><P>numGlyphs</P></TD><TD VALIGN="TOP"><P>array length</P></TD></TR><TR><TD VALIGN="TOP"><P>USHORT</P></TD><TD VALIGN="TOP"><P>glyphCodeArray[]</P></TD><TD VALIGN="TOP"><P>one per glyph, sorted by glyph code; sizeOfArray=lastGlyph-firstGlyph+1+1 pad if needed.</P></TD></TR></TBODY></TABLE>
<BR></P>The size of the 'EBDT' image data can be calculated from the indexSubTable information. For the constant metrics formats (2 and 5) the image data size is constant, and is given in the imageSize field. For the variable metrics formats (1, 3, and 4) image data must be stored contiguously and in glyph code order, so the image data size may be calculated by subtracting the offset for the current glyph from the offset of the next glyph. Because of this, it is necessary to store one extra element in the offsetArray pointing just past the end of the range's image data. This will allow the correct calculation of the image data size for the last glyph in the range.</P>
Contiguous, or nearly contiguous, ranges of glyph codes are handled best by formats 1, 2, and 3 which store an offset for every glyph code in the range. Very sparse ranges of glyph codes should use format 4 or 5 which explicitly call out the glyph codes represented in the range. A small number of missing glyphs can be efficiently represented in formats 1 or 3 by having the offset for the missing glyph be followed by the same offset for the next glyph, thus indicating a data size of zero.</P>
The only difference between formats 1 and 3 is the size of the offsetArray elements: format 1 uses ULONG's while format 3 uses USHORT's. Therefore format 1 can cover a greater range (&gt; 64k bytes) while format 3 saves more space in the 'EBLC' table. Since the offsetArray elements are added to the imageDataOffset base address in the indexSubHeader, a very large set of glyph bitmap data could be addressed by splitting it into multiple ranges, each less than 64k bytes in size, allowing the use of the more efficient format 3.</P>
The 'EBLC' table specification requires double word (ULONG) alignment for all subtables. This occurs naturally for indexSubTable formats 1, 2, and 4, but may not for formats 3 and 5, since they include arrays of type USHORT. When there is an odd number of elements in these arrays it is necessary to add an extra padding element to maintain proper alignment.</P></BODY></HTML>
