<HTML><HEAD><META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Managing outlines</TITLE><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">
</OBJECT></FORM>
<H1>Managing outlines</H1>The following set of instructions make it possible to move the points that make up a glyph outline. They are the instructions that accomplish the actual work of grid-fitting. They include instructions to move points, shift points or groups of points, flip points from off to on the curve or vice versa, and to interpolate points.</P>
<H2><A NAME="sec0"></A>FLIP PoinT</H2>FLIPPT[ ] </P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="72pt" VALIGN="TOP"><COL WIDTH="370pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>Code Range</P></TD><TD VALIGN="TOP"><P>0x80</P></TD></TR><TR><TD VALIGN="TOP"><P>Pops</P></TD><TD VALIGN="TOP"><P>p: point number (ULONG)</P></TD></TR><TR><TD VALIGN="TOP"><P>Pushes</P></TD><TD VALIGN="TOP"><P>–</P></TD></TR><TR><TD VALIGN="TOP"><P>Uses</P></TD><TD VALIGN="TOP"><P>loop, p is referenced in zp0</P></TD></TR></TBODY></TABLE>
<BR></P>Flips points that are <I>off </I>the curve so that they are <I>on</I> the curve and points that are <I>on</I> the curve so that they are <I>off </I>the curve. The point is not marked as touched. The result of a FLIPPT instruction is that the contour describing part of a glyph outline is redefined.</P>
<P><img src="13866.gif"></P>
<I>Before: </I></P>
<P><img src="13867.gif"></P>
<I>After</I></P>
<P> <img src="13868.gif"></P>
<H2><A NAME="sec1"></A>FLIP  RanGe ON</H2>FLIPRGON[ ]</P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="72pt" VALIGN="TOP"><COL WIDTH="370pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>Code Range</P></TD><TD VALIGN="TOP"><P>0x81</P></TD></TR><TR><TD VALIGN="TOP"><P>Pops</P></TD><TD VALIGN="TOP"><P>highpoint: highest point number in range of points to be flipped (ULONG)</P></TD></TR><TR><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P>lowpoint: lowest point number in range of points to be flipped (ULONG)</P></TD></TR><TR><TD VALIGN="TOP"><P>Pushes</P></TD><TD VALIGN="TOP"><P>–</P></TD></TR></TBODY></TABLE>
<BR></P>Flips a range of points beginning with lowpoint and ending with highpoint so that any off the curve points become on the curve points. The points are not marked as touched.</P>
<P><img src="13869.gif"></P>
<I>Example:</I></P>
FLIPRGON[ ] 1 5</P>
<B><I>Before:</I></B>       <img src="13870.gif"></P>
<B><I>After:</I></B>        <img src="13871.gif"></P>
Will make all off curve points between point 0 and point 5 into on curve points as shown</P>
<H2><A NAME="sec2"></A>FLIP RanGe OFF</H2>FLIPRGOFF[ ] </P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="72pt" VALIGN="TOP"><COL WIDTH="370pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>Code Range</P></TD><TD VALIGN="TOP"><P>0x82</P></TD></TR><TR><TD VALIGN="TOP"><P>Pops</P></TD><TD VALIGN="TOP"><P>highpoint: highest point number in range of points to be flipped (ULONG)</P></TD></TR><TR><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P>lowpoint: lowest point number in range of points to be flipped (ULONG)</P></TD></TR><TR><TD VALIGN="TOP"><P>Pushes</P></TD><TD VALIGN="TOP"><P>–</P></TD></TR></TBODY></TABLE>
<BR></P>Flips a range of points beginning with lowpoint and ending with highpoint so that any on curve points become off the curve points. The points are not marked as touched.</P>
<P>Note: </P>
<P>This instruction changes the curve but the position of the points is unaffected.  Accordingly, points affected by this instruction are not marked as touched.</P>
<P><img src="13872.gif"></P>
<I>Example:</I></P>
FLIPRGOFF[ ] 8 6</P>
<I>Before :</I></P>
<P><img src="13873.gif"></P>
<I>After: </I></P>
<P><img src="13874.gif"></P>
<H2><A NAME="sec3"></A>SHift Point by the last point</H2>SHP[a] </P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="72pt" VALIGN="TOP"><COL WIDTH="370pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>Code Range</P></TD><TD VALIGN="TOP"><P>0x32 - 0x33</P></TD></TR><TR><TD VALIGN="TOP"><P>a</P></TD><TD VALIGN="TOP"><P>0: uses rp2 in the zone pointed to by zp1</P></TD></TR><TR><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P>1: uses rp1 in the zone pointed to by zp0</P></TD></TR><TR><TD VALIGN="TOP"><P>Pops</P></TD><TD VALIGN="TOP"><P>p: point to be shifted (ULONG)</P></TD></TR><TR><TD VALIGN="TOP"><P>Pushes</P></TD><TD VALIGN="TOP"><P>–</P></TD></TR><TR><TD VALIGN="TOP"><P>Uses</P></TD><TD VALIGN="TOP"><P>zp0 with rp1 or zp1 with rp2 depending on flag</P></TD></TR><TR><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P>zp2 with point p</P></TD></TR><TR><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P>loop, freedom_vector, projection_vector</P></TD></TR></TBODY></TABLE>
<BR></P>Shift point p by the same amount that the reference point has been shifted. Point p is shifted along the freedom_vector so that the distance between the new position of point p and the current position of point p is the same as the distance between the current position of the reference point and the original position of the reference point.</P>
<P>Note: </P>
<P>Point p is shifted from its current position, not its original position. The distance that the reference point has shifted is measured between its current position and the original position.</P>
In the illustration below rp is the original position of the reference point, rp' is the current position of the reference point, p is the original position of point p, p' is the current position, p" the position after it is shifted by the SHP instruction.  (White indicates original position, gray is current position, black is position to which this instruction moves a point).</P>
<P><img src="SPEC26.gif"></P>
<H2><A NAME="sec4"></A>SHift Contour by the last point</H2>SHC[a] </P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="72pt" VALIGN="TOP"><COL WIDTH="370pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>Code Range</P></TD><TD VALIGN="TOP"><P>0x34 - 0x35</P></TD></TR><TR><TD VALIGN="TOP"><P>a</P></TD><TD VALIGN="TOP"><P> 0: uses rp2 in the zone pointed to by zp1</P></TD></TR><TR><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P>1: uses rp1 in the zone pointed to by zp0</P></TD></TR><TR><TD VALIGN="TOP"><P>Pops</P></TD><TD VALIGN="TOP"><P>c: contour to be shifted (ULONG)</P></TD></TR><TR><TD VALIGN="TOP"><P>Pushes</P></TD><TD VALIGN="TOP"><P>–</P></TD></TR><TR><TD VALIGN="TOP"><P>Uses</P></TD><TD VALIGN="TOP"><P>zp0 with rp1 or zp1 with rp2 depending on flag</P></TD></TR><TR><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P>zp2 with contour c</P></TD></TR><TR><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P>freedom_vector, projection_vector</P></TD></TR></TBODY></TABLE>
<BR></P>Shifts every point on contour c by the same amount that the reference point has been shifted. Each point is shifted along the freedom_vector so that the distance between the new position of the point and the old position of that point is the same as the distance between the current position of the reference point and the original position of the reference point. The distance is measured along the projection_vector. If the reference point is one of the points defining the contour, the reference point is not moved by this instruction.</P>
This instruction is similar to SHP, but every point on the contour is shifted. </P>
<H2><A NAME="sec5"></A>SHift Zone by the last pt</H2>SHZ[a] </P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="72pt" VALIGN="TOP"><COL WIDTH="370pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>Code Range</P></TD><TD VALIGN="TOP"><P>0x36 - 0x37</P></TD></TR><TR><TD VALIGN="TOP"><P>a </P></TD><TD VALIGN="TOP"><P>0:  the reference point rp2 is in the zone pointed to by zp1</P></TD></TR><TR><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P>1: the reference point rp1 is in the zone pointed to by zp0</P></TD></TR><TR><TD VALIGN="TOP"><P>Pops</P></TD><TD VALIGN="TOP"><P>e: zone to be shifted (ULONG)</P></TD></TR><TR><TD VALIGN="TOP"><P>Pushes</P></TD><TD VALIGN="TOP"><P>–</P></TD></TR><TR><TD VALIGN="TOP"><P>Uses</P></TD><TD VALIGN="TOP"><P>zp0 with rp1 or zp1 with rp2 depending on flag</P></TD></TR><TR><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P>freedom_vector, projection_vector</P></TD></TR></TBODY></TABLE>
<BR></P>Shift the points in the specified zone (Z1 or Z0) by the same amount that the reference point has been shifted. The points in the zone are shifted along the freedom_vector so that the distance between the new position of the shifted points and their old position is the same as the distance between the current position of the reference point and the original position of the reference point.</P>
SHZ[a] uses zp0 with rp1 or zp1 with rp2. This instruction is similar to SHC, but all points in the zone are shifted, not just the points on a single contour.</P>
<H2><A NAME="sec6"></A>SHift point by a PIXel amount</H2>SHPIX[ ]</P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="72pt" VALIGN="TOP"><COL WIDTH="370pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>Code Range</P></TD><TD VALIGN="TOP"><P>0x38</P></TD></TR><TR><TD VALIGN="TOP"><P>Pops</P></TD><TD VALIGN="TOP"><P>amount: magnitude of the shift (F26Dot6)</P></TD></TR><TR><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P>p1, p2,...pn: points to be shifted (ULONG)</P></TD></TR><TR><TD VALIGN="TOP"><P>Pushes</P></TD><TD VALIGN="TOP"><P>–</P></TD></TR><TR><TD VALIGN="TOP"><P>Uses</P></TD><TD VALIGN="TOP"><P>zp2, loop, freedom_vector</P></TD></TR></TBODY></TABLE>
<BR></P>Shifts the points specified by the amount stated. When the loop variable is used, the amount to be shifted is put onto the stack only once. That is, if loop = 3, then the contents of the top of the stack should be point p1, point p2, point p3, amount. The value amount is expressed in sixty-fourths of a pixel.</P>
SHPIX is unique in relying solely on the direction of the freedom_vector. It makes no use of the projection_vector. Measurement is made in the direction of the freedom_vector.</P>
<I>Example</I></P>
The instruction shifts points 27, 28, and 29 by 80/64  or 1.25 pixels in the direction of the freedom vector. The distance is measured in the direction of the freedom_vector; the projection vector is ignored.</P>
<P>SHPIX[] </P>
<P><img src="13875.gif"></P>
<H2><A NAME="sec7"></A>Move Stack Indirect Relative Point</H2>MSIRP[a] </P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="72pt" VALIGN="TOP"><COL WIDTH="370pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>Code Range</P></TD><TD VALIGN="TOP"><P>0x3A - 0x3B</P></TD></TR><TR><TD VALIGN="TOP"><P>a</P></TD><TD VALIGN="TOP"><P>0:  Do not set rp0 to p</P></TD></TR><TR><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P>1:  Set rp0 to p</P></TD></TR><TR><TD VALIGN="TOP"><P>Pops</P></TD><TD VALIGN="TOP"><P>d:  distance (F26Dot6)</P></TD></TR><TR><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P>p:  point number (ULONG)</P></TD></TR><TR><TD VALIGN="TOP"><P>Pushes</P></TD><TD VALIGN="TOP"><P>–</P></TD></TR><TR><TD VALIGN="TOP"><P>Uses </P></TD><TD VALIGN="TOP"><P>zp1 with point p and zp0 with rp0, freedom_vector, projection_vector.</P></TD></TR><TR><TD VALIGN="TOP"><P>Sets </P></TD><TD VALIGN="TOP"><P>After it has moved the point this instruction sets rp1 = rp0, </P></TD></TR><TR><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P>rp2 = point p, and if a=1, rp0 is set to point p. </P></TD></TR></TBODY></TABLE>
<BR></P>Makes the distance between a point p and rp0 equal to the value specified on the stack. The distance on the stack is in fractional pixels (F26Dot6). An MSIRP has the same effect as a MIRP instruction except that it takes its value from the stack rather than the Control Value Table. As a result, the cut_in does not affect the results of a MSIRP. Additionally, MSIRP is unaffected by the round_state.</P>
<P><img src="13876.gif"></P>
<P><img src="SPEC27.gif"></P>
<H2><A NAME="sec8"></A>Move Direct Absolute Point</H2>MDAP[ a ] </P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="72pt" VALIGN="TOP"><COL WIDTH="370pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>Code Range</P></TD><TD VALIGN="TOP"><P>0x2E - 0x2F</P></TD></TR><TR><TD VALIGN="TOP"><P>a:</P></TD><TD VALIGN="TOP"><P>0: do not round the value</P></TD></TR><TR><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P>1: round the value</P></TD></TR><TR><TD VALIGN="TOP"><P>Pops</P></TD><TD VALIGN="TOP"><P>p: point number (ULONG)</P></TD></TR><TR><TD VALIGN="TOP"><P>Pushes </P></TD><TD VALIGN="TOP"><P>–</P></TD></TR><TR><TD VALIGN="TOP"><P>Sets </P></TD><TD VALIGN="TOP"><P>rp0 = rp1 = point p </P></TD></TR><TR><TD VALIGN="TOP"><P>Uses </P></TD><TD VALIGN="TOP"><P>zp0, round_state, projection_vector, freedom_vector.</P></TD></TR></TBODY></TABLE>
<BR></P>Sets the reference points rp0 and rp1 equal to point p. If a=1, this instruction rounds point p to the grid point specified by the state variable round_state. If a=0, it simply marks the point as touched in the direction(s) specified by the current freedom_vector. This command is often used to set points in the twilight zone.</P>
<P><img src="13877.gif"></P>
<I>Example:</I></P>
MDAP[0] </P>
When a=0, the point is simply marked as touched and the values of rp0 and rp1 set to point p.</P>
<P><img src="SPEC28.gif"></P>
MDAP[1] assuming that the round_state is round to grid and the freedom_vector is a shown.</P>
<P><img src="SPEC29.gif"></P>
<H2><A NAME="sec9"></A>Move Indirect Absolute Point</H2>MIAP[a] </P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="72pt" VALIGN="TOP"><COL WIDTH="370pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>Code Range </P></TD><TD VALIGN="TOP"><P>0x3E - 0x3F</P></TD></TR><TR><TD VALIGN="TOP"><P>a</P></TD><TD VALIGN="TOP"><P>0:  don't round the distance and don't look at the control_value_cut_in</P></TD></TR><TR><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P>1:  round the distance and look at the control_value_cut_in </P></TD></TR><TR><TD VALIGN="TOP"><P>Pops</P></TD><TD VALIGN="TOP"><P>n:  CVT entry number (ULONG)</P></TD></TR><TR><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P>p:  point number (ULONG)</P></TD></TR><TR><TD VALIGN="TOP"><P>Pushes </P></TD><TD VALIGN="TOP"><P>–</P></TD></TR><TR><TD VALIGN="TOP"><P>Sets</P></TD><TD VALIGN="TOP"><P>rp0 = rp1 = point p</P></TD></TR><TR><TD VALIGN="TOP"><P>Uses</P></TD><TD VALIGN="TOP"><P>zp0, round_state, control_value_cut_in, freedom_vector, projection_vector</P></TD></TR></TBODY></TABLE>
<BR></P>Moves point p to the absolute coordinate position specified by the <I>n</I>th Control Value Table entry. The coordinate is measured along the current projection_vector. If a=1, the position will be rounded as specified by round_state. If a=1, and if the device space difference between the CVT value and the original position is greater than the control_value_cut_in, then the original position will be rounded (instead of the CVT value.) </P>
Rounding is done as if the entire coordinate system has been rotated to be consistent with the projection_vector. That is, if round_state is set to 1, and the projection_vector and freedom_vector are at a 45_ angle to the <I>x</I>-axis, then a MIAP[1] of a point to 2.9 pixels will round to 3.0 pixels along the projection_vector. </P>
The a Boolean above controls both rounding and the use of the control_value_cut_in.  If you would like the meaning of this Boolean to specify only whether or not the MIAP[ ] instruction should look at the control_value_cut_in value, use the ROFF[ ] instruction to turn off rounding.</P>
This instruction can be used to create Twilight Zone points.</P>
<I>Example:</I></P>
MIAP[1] 4 7</P>
<I>case 1:</I></P>
rounding is OFF</P>
<P><img src="SPEC30.gif"></P>
The point is moved to the position specified in the CVT.</P>
<P><img src="13878.gif"></P>
<I>case 2:</I></P>
The cut_in test succeeds and rounding is RTG.</P>
The value in the CVT is subjected to the rounding rule and then the point is moved to the rounded position.</P>
<P><img src="SPEC31.gif"></P>
<P><img src="13879.gif"></P>
<I>case 3:</I></P>
The cut_in test fails and rounding is OFF.</P>
Here the point is not moved.</P>
<P><img src="SPEC32.gif"></P>
<P><img src="13880.gif"></P>
<I>case 4:</I></P>
The cut_in test fails and rounding is RTG.</P>
In this case the point is moved to the nearest grid position.</P>
<P><img src="SPEC33.gif"></P>
<P><img src="13881.gif"></P>
<H2><A NAME="sec10"></A>Move Direct Relative Point</H2>MDRP[abcde] </P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="72pt" VALIGN="TOP"><COL WIDTH="370pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>Code Range</P></TD><TD VALIGN="TOP"><P>0xC0 - 0xDF</P></TD></TR><TR><TD VALIGN="TOP"><P>a</P></TD><TD VALIGN="TOP"><P>0:  do not set rp0 to point p after move</P></TD></TR><TR><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P>1:  do set rp0 to point p after move</P></TD></TR><TR><TD VALIGN="TOP"><P>b</P></TD><TD VALIGN="TOP"><P>0:  do not keep distance greater than or equal to minimum_distance</P></TD></TR><TR><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P>1:  keep distance greater than or equal to minimum_distance</P></TD></TR><TR><TD VALIGN="TOP"><P>c</P></TD><TD VALIGN="TOP"><P>0:  do not round distance</P></TD></TR><TR><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P>1:  round the distance</P></TD></TR><TR><TD VALIGN="TOP"><P>de</P></TD><TD VALIGN="TOP"><P>distance type for engine characteristic compensation</P></TD></TR><TR><TD VALIGN="TOP"><P>Pops</P></TD><TD VALIGN="TOP"><P>p:  point number (ULONG)</P></TD></TR><TR><TD VALIGN="TOP"><P>Pushes</P></TD><TD VALIGN="TOP"><P>–</P></TD></TR><TR><TD VALIGN="TOP"><P>Sets</P></TD><TD VALIGN="TOP"><P>after point p is moved, rp1 is set equal to rp0, rp2 is set equal to point p; if the a flag is set to TRUE, rp0 is set equal to point p</P></TD></TR><TR><TD VALIGN="TOP"><P>Uses</P></TD><TD VALIGN="TOP"><P>zp0 with rp0 and zp1 with point p, round_state, single_width_value, single_width_cut_in, freedom_vector, projection_vector.</P></TD></TR></TBODY></TABLE>
<BR></P>MDRP moves point p along the freedom_vector so that the distance from its new position to the current position of rp0 is the same as the distance between the two points in the original uninstructed outline, and then adjusts it to be consistent with the Boolean settings. Note that it is only the original positions of rp0 and point p and the current position of rp0 that determine the new position of point p along the freedom_vector. </P>
MDRP is typically used to control the width or height of a glyph feature using a value which comes from the original outline. Since MDRP uses a direct measurement and does not reference the control_value_cut_in, it is used to control measurements that are unique to the glyph being instructed. Where there is a need to coordinate the control of a point with the treatment of points in other glyphs in the font, a MIRP instruction is needed.</P>
Though MDRP does not refer to the CVT, its effect does depend upon the single-width cut-in value. If the device space distance between the measured value taken from the uninstructed outline and the single_width_value is less than the single_width_cut_in, the single_width_value will be used in preference to the outline distance. In other words, if the two distances are sufficiently close (differ by less than the single_width_cut_in), the single_width_value will be used.</P>
The setting of the round_state Graphics State variable will determine whether and how the distance of point p from point q is rounded. If the round bit is not set, the value will be unrounded. If the round bit is set, the effect will depend upon the choice of rounding state. The value of the minimum distance variable is the smallest possible value the distance between two points can be rounded to.</P>
Distances measured with the MDRP instruction must be either black, white or gray. Indicating this value in Booleans <I>de </I>allows the interpreter to compensate for engine characteristics as needed. The value <I>de</I> specifies the distance type as described in the chapter, "Instructing Glyphs." Three values are possible: Gray=0, Black=1, White=2.</P>
<I>Example 1:</I></P>
Graphics State Settings</P>
<I>Before MDRP</I></P>
<P><img src="SPEC34.gif"></P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="41pt" VALIGN="TOP"><COL WIDTH="193pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>rp0</P></TD><TD VALIGN="TOP"><P>7</P></TD></TR><TR><TD VALIGN="TOP"><P>rp1</P></TD><TD VALIGN="TOP"><P>?</P></TD></TR><TR><TD VALIGN="TOP"><P>rp2</P></TD><TD VALIGN="TOP"><P>?</P></TD></TR></TBODY></TABLE>
<BR></P><I>Case 1:</I></P>
After MDRP[00001] 8</P>
<P><img src="SPEC35.gif"></P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="50pt" VALIGN="TOP"><COL WIDTH="247pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>rp0</P></TD><TD VALIGN="TOP"><P>7</P></TD></TR><TR><TD VALIGN="TOP"><P>rp1</P></TD><TD VALIGN="TOP"><P>7</P></TD></TR><TR><TD VALIGN="TOP"><P>rp2</P></TD><TD VALIGN="TOP"><P>8</P></TD></TR></TBODY></TABLE>
<BR></P><I>Case 2:</I></P>
After MDRP[10001] 8</P>
<P><img src="SPEC36.gif"></P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="50pt" VALIGN="TOP"><COL WIDTH="256pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>rp0</P></TD><TD VALIGN="TOP"><P>8</P></TD></TR><TR><TD VALIGN="TOP"><P>rp1</P></TD><TD VALIGN="TOP"><P>7</P></TD></TR><TR><TD VALIGN="TOP"><P>rp2</P></TD><TD VALIGN="TOP"><P>8</P></TD></TR></TBODY></TABLE>
<BR></P><P>Example 2:</P>
<P>Point p is moved so that its distance from rp1 is the same as it was in the original outline.</P>
<P><img src="SPEC37.gif"></P>
<H2><A NAME="sec11"></A>Move Indirect Relative Point</H2>MIRP[abcde] </P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="72pt" VALIGN="TOP"><COL WIDTH="370pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>Code Range</P></TD><TD VALIGN="TOP"><P>0xE0 - 0xFF</P></TD></TR><TR><TD VALIGN="TOP"><P>a</P></TD><TD VALIGN="TOP"><P>0:  Do not set rp0 to p</P></TD></TR><TR><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P>1:  Set rp0 to p</P></TD></TR><TR><TD VALIGN="TOP"><P>b</P></TD><TD VALIGN="TOP"><P>0:  Do not keep distance greater than or equal to minimum_distance</P></TD></TR><TR><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P>1:  Keep distance greater than or equal to minimum_distance</P></TD></TR><TR><TD VALIGN="TOP"><P>c</P></TD><TD VALIGN="TOP"><P>0:  Do not round the distance and do not look at the control_value_cut_in</P></TD></TR><TR><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P>1:   Round the distance and look at the control_value_cut_in value</P></TD></TR><TR><TD VALIGN="TOP"><P>de: </P></TD><TD VALIGN="TOP"><P>distance type for engine characteristic compensation </P></TD></TR><TR><TD VALIGN="TOP"><P>Pops</P></TD><TD VALIGN="TOP"><P>n:  CVT entry number (ULONG)</P></TD></TR><TR><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P>p:  point number (ULONG)</P></TD></TR><TR><TD VALIGN="TOP"><P>Pushes</P></TD><TD VALIGN="TOP"><P>–</P></TD></TR><TR><TD VALIGN="TOP"><P>Uses</P></TD><TD VALIGN="TOP"><P>zp0 with rp0 and zp1 with point p. </P></TD></TR><TR><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P>round_state, control_value_cut_in, single_width_value, </P></TD></TR><TR><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P>single_width_cut_in, freedom_vector, projection_vector</P></TD></TR><TR><TD VALIGN="TOP"><P>Sets </P></TD><TD VALIGN="TOP"><P>After it has moved the point this instruction sets rp1 = rp0, </P></TD></TR><TR><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P>rp2 = point p, and if a = 1, rp0 is set to point p. </P></TD></TR></TBODY></TABLE>
<BR></P>A MIRP instruction makes it possible to preserve the distance between two points subject to a number of qualifications. Depending upon the setting of Boolean flag b, the distance can be kept greater than or equal to the value established by the minimum_distance state variable. Similarly, the instruction can be set to round the distance according to the round_state graphics state variable. The value of the minimum distance variable is the smallest possible value the distance between two points can be rounded to. Additionally, if the c Boolean is set, the MIRP instruction acts subject to the control_value_cut_in. If the difference between the actual measurement and the value in the CVT is sufficiently small (less than the cut_in_value), the CVT value will be used and not the actual value. If the device space difference between this distance from the CVT and the single_width_value is smaller than the single_width_cut_in, then use the single_width_value rather than the outline or Control Value Table distance.</P>
MIRP measures distance <I>relative</I>  to point rp0. More formally, MIRP moves point p along the freedom_vector so that the distance from p to rp0 is equal to the distance stated in the reference CVT entry (assuming that the cut_in test succeeds)</P>
The c Boolean above controls both rounding and the use of Control Value Table entries. If you would like the meaning of this Boolean to specify only whether or not the MIRP[ ] instruction should look at the control_value_cut_in, use the ROFF[ ] instruction to turn off rounding. In this manner, it is possible to specify rounding off and no cut_in.</P>
The value de specifies the distance type as described in th chapter, "Instructing Glyphs." Three values are possible: Gray=0, Black=1, White=2.</P>
<I>Example 1</I></P>
MIRP[00110] 3 17</P>
<I>case 1:</I></P>
The cut_in test succeeds and rounding is off.</P>
The point is moved so that the distance from RP0 is equal to that given in CVT entry 17.</P>
<P><img src="13882.gif"></P>
<I>case 2:</I></P>
The cut_in test succeeds and rounding is set to RTG.</P>
The distance in the CVT is rounded and the point is moved by the rounded distance.</P>
<P><img src="13883.gif"></P>
<I>case 3:</I></P>
The cut_in test fails and the round_state is OFF.</P>
The point is not moved.</P>
<P><img src="13884.gif">    </P>
<I>case 4:</I></P>
The cut_in test fails and the round_state is RTG.</P>
The current position of the point is rounded to the grid.</P>
<P><img src="13885.gif"></P>
<H2><A NAME="sec12"></A>ALIGN Relative Point</H2>ALIGNRP[ ] </P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="72pt" VALIGN="TOP"><COL WIDTH="370pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>Code Range </P></TD><TD VALIGN="TOP"><P>0x3C</P></TD></TR><TR><TD VALIGN="TOP"><P>Pops</P></TD><TD VALIGN="TOP"><P>p: point number (ULONG)</P></TD></TR><TR><TD VALIGN="TOP"><P>Pushes </P></TD><TD VALIGN="TOP"><P>–</P></TD></TR><TR><TD VALIGN="TOP"><P>Uses </P></TD><TD VALIGN="TOP"><P>zp1 with point p, zp0 with rp0, loop, freedom_vector, projection_vector.</P></TD></TR></TBODY></TABLE>
<BR></P>Reduces the distance between rp0 and point p to zero. Since distance is measured along the projection_vector and movement is along the freedom_vector, the effect of the instruction is to align points.</P>
<P><img src="13886.gif"></P>
<I>case 1:</I></P>
<P><img src="SPEC38.gif"></P>
<I>case 2:</I></P>
<P><img src="SPEC39.gif"></P>
<H2><A NAME="sec13"></A>Adjust Angle (No Longer Supported)</H2><H2><A NAME="sec14"></A>moves point p to the InterSECTion of two lines</H2>ISECT[ ] </P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="72pt" VALIGN="TOP"><COL WIDTH="370pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>Code Range</P></TD><TD VALIGN="TOP"><P>0x0F</P></TD></TR><TR><TD VALIGN="TOP"><P>Pops</P></TD><TD VALIGN="TOP"><P>b1:  end point of line 2  (ULONG)</P></TD></TR><TR><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P>b0:  start point of line 2  (ULONG)</P></TD></TR><TR><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P>a1:  end point of line 1  (ULONG)</P></TD></TR><TR><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P>a0:  start point of line 1  (ULONG)</P></TD></TR><TR><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P>p:  point to move (ULONG)</P></TD></TR><TR><TD VALIGN="TOP"><P>Pushes</P></TD><TD VALIGN="TOP"><P> –</P></TD></TR><TR><TD VALIGN="TOP"><P>Uses </P></TD><TD VALIGN="TOP"><P>zp2 with point p, zp1 with line A, zp0 with line B</P></TD></TR></TBODY></TABLE>
<BR></P>Puts point p at the intersection of the lines A and B. The points a0 and a1 define line A. Similarly, b0 and b1 define line B. ISECT ignores the freedom_vector in moving point p.</P>
<P><img src="13887.gif"></P>
<I>Example:</I></P>
ISECT[ ] 21 9 5 4 7</P>
<P><img src="13888.gif"></P>
<P>Note:</P>
<P>If lines are parallel to each other, the point is put into the middle of the two lines.</P>
<I>Example:</I></P>
ISECT[ ] 21 9 5 4 7</P>
<P><img src="13889.gif"></P>
<H2><A NAME="sec15"></A>ALIGN Points</H2>ALIGNPTS[ ]</P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="72pt" VALIGN="TOP"><COL WIDTH="370pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>Code Range</P></TD><TD VALIGN="TOP"><P>0x27</P></TD></TR><TR><TD VALIGN="TOP"><P>Pops</P></TD><TD VALIGN="TOP"><P>p1: point number (ULONG)</P></TD></TR><TR><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P>p2: point number (ULONG)</P></TD></TR><TR><TD VALIGN="TOP"><P>Pushes</P></TD><TD VALIGN="TOP"><P>–</P></TD></TR><TR><TD VALIGN="TOP"><P>Uses </P></TD><TD VALIGN="TOP"><P>zp1 with point p1, zp0 with point p2, freedom_vector, projection_vector.</P></TD></TR></TBODY></TABLE>
<BR></P>Makes the distance between point 1 and point 2 zero by moving both along the freedom_vector to the average of both their projections along the projection_vector.</P>
<P><img src="13890.gif"></P>
<I>Example:</I></P>
ALIGNPTS[] 3 7</P>
<P><img src="13891.gif"></P>
<H2><A NAME="sec16"></A>Interpolate Point by the last relative stretch</H2>IP[ ]</P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="72pt" VALIGN="TOP"><COL WIDTH="370pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>Code Range</P></TD><TD VALIGN="TOP"><P>0x39</P></TD></TR><TR><TD VALIGN="TOP"><P>Pops</P></TD><TD VALIGN="TOP"><P>p: point number (ULONG)</P></TD></TR><TR><TD VALIGN="TOP"><P>Pushes</P></TD><TD VALIGN="TOP"><P>–</P></TD></TR><TR><TD VALIGN="TOP"><P>Uses </P></TD><TD VALIGN="TOP"><P>zp0 with rp1, zp1 with rp2, zp2 with point p, loop, freedom_vector, projection_vector</P></TD></TR></TBODY></TABLE>
<BR></P>Moves point p so that its relationship to rp1 and rp2 is the same as it was in the original uninstructed outline. Measurements are made along the projection_vector, and movement to satisfy the interpolation relationship is constrained to be along the freedom_vector. This instruction is illegal if rp1 and rp2 have the same position on the projection_vector.  </P>
<P><img src="SPEC40.gif"></P>
In the example shown, assume that the points referenced by rp1 and rp2 are moved as shown. An IP instruction is then used to preserve their relative relationship with point p. After the IP the following should be true</P>
D(p, rp1)/D(p',rp1') = D(p,rp2)/D(p', rp2')</P>
In other words, the relative distance is preserved.</P>
<H2><A NAME="sec17"></A>UnTouch Point</H2>UTP[ ] </P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="72pt" VALIGN="TOP"><COL WIDTH="370pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>Code Range</P></TD><TD VALIGN="TOP"><P>0x29</P></TD></TR><TR><TD VALIGN="TOP"><P>Pops</P></TD><TD VALIGN="TOP"><P>p: point number (ULONG)</P></TD></TR><TR><TD VALIGN="TOP"><P>Pushes</P></TD><TD VALIGN="TOP"><P>–</P></TD></TR><TR><TD VALIGN="TOP"><P>Uses</P></TD><TD VALIGN="TOP"><P>zp0 with point p, freedom_vector</P></TD></TR></TBODY></TABLE>
<BR></P>Marks point p as untouched. A point may be touched in the <I>x</I>-direction, the <I>y</I>-direction, both, or neither. This instruction uses the current freedom_vector to determine whether to untouch the point in the <I>x</I>-direction, the <I>y</I>-direction, or both. Points that are marked as untouched will be moved by an IUP (interpolate untouched points) instruction. Using UTP you can ensure that a point will be affected by IUP even if it was previously touched.</P>
<H2><A NAME="sec18"></A>Interpolate Untouched Points through the outline</H2>IUP[a]</P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="72pt" VALIGN="TOP"><COL WIDTH="370pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>Code Range</P></TD><TD VALIGN="TOP"><P>0x30 - 0x31</P></TD></TR><TR><TD VALIGN="TOP"><P>a</P></TD><TD VALIGN="TOP"><P>0: interpolate in the <I>y</I>-direction</P></TD></TR><TR><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P>1: interpolate in the <I>x</I>-direction </P></TD></TR><TR><TD VALIGN="TOP"><P>Pops</P></TD><TD VALIGN="TOP"><P>–</P></TD></TR><TR><TD VALIGN="TOP"><P>Pushes</P></TD><TD VALIGN="TOP"><P>–</P></TD></TR><TR><TD VALIGN="TOP"><P>Uses</P></TD><TD VALIGN="TOP"><P>zp2, freedom_vector, projection_vector</P></TD></TR></TBODY></TABLE>
<BR></P>Considers a glyph contour by contour, moving any untouched points in each contour that are between a pair of touched points. If the coordinates of an untouched point were originally between those of the touched pair, it is linearly interpolated between the new coordinates, otherwise the untouched point is shifted by the amount the nearest touched point is shifted. </P>
This instruction operates on points in the glyph zone pointed to by zp2. This zone should almost always be zone 1. Applying IUP to zone 0 is an error.</P>
Consider three consecutive points all on the same contour. Two of the three points, p1 and p3 have been touched. Point p2 is untouched. The effect of an IUP in the x-direction is to move point p2 so that is in the same relative position to points p1 and p3 before they were moved.</P>
The IUP instruction does not touch the points it moves. Thus the untouched points affected by an IUP instruction will be affected by subsequent IUP instructions unless they are touched by an intervening instruction. In this case, the first interpolation is ignored and the point is moved based on its original position.</P>
<P><img src="SPEC41.gif"></P></BODY></HTML>
