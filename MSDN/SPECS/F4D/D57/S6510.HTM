<HTML><HEAD><META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Managing the Graphics State</TITLE><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">
</OBJECT></FORM>
<H3>Managing the Graphics State</H3>Instructions can be used to set the value of Graphics State variables and, in some cases, to retrieve their current value. </P>
<H4><A NAME="sec0"></A>Getting a value</H4>Instructions that retrieve the value of a state variable have names that begin with the word <I>get</I>. Get instructions will return the value of the state variable in question by placing that value on the top of the stack.</P>
The illustration shows the effect of a GPV or get projection_vector instruction. It takes the <I>x </I>and <I>y</I> components of the projection_vector from the Graphics State and places them on the stack.</P>
<P><img src="13749.gif"></P>
<H4><A NAME="sec1"></A>Setting a value</H4>Instructions that change the value of a Graphics State variable have a name that begins with the word <I>set</I>. Set instructions expect their arguments to be at the top of the interpreter stack.</P>
<P>Figure 3–4    Setting the value of the Graphics State variable projection_vector</P>
<P><img src="13750.gif"></P>
In addition to simple sets and gets, some instructions exist to simplify management of the values of state variables. For example, a number of instructions exist to set the direction of the freedom_vector and the projection_vector. In setting a vector, it is possible to set it to either of the coordinate axes, to the direction specified by a line, or to a direction specified by values taken from the stack. An instruction exists that directly sets the freedom_vector to the same value as the projection_vector.</P>
<H5><A NAME="sec2"></A>Set freedom and projection Vectors To Coordinate Axis</H5>SVTCA[a]</P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="63pt" VALIGN="TOP"><COL WIDTH="373pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>Code range</P></TD><TD VALIGN="TOP"><P>0x00 - 0x01</P></TD></TR><TR><TD VALIGN="TOP"><P>a</P></TD><TD VALIGN="TOP"><P>0: set vectors to the <I>y</I>-axis</P></TD></TR><TR><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P>1: set vectors to the <I>x</I>-axis</P></TD></TR><TR><TD VALIGN="TOP"><P>Pops</P></TD><TD VALIGN="TOP"><P>–</P></TD></TR><TR><TD VALIGN="TOP"><P>Pushes</P></TD><TD VALIGN="TOP"><P>–</P></TD></TR><TR><TD VALIGN="TOP"><P>Sets</P></TD><TD VALIGN="TOP"><P>projection_vector</P></TD></TR><TR><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P>freedom_vector</P></TD></TR></TBODY></TABLE>
<BR></P>Sets both the projection_vector and freedom_vector to the same one of the coordinate axes. </P>
The SVTCA is a shortcut for using both the SFVTCA and SPVTCA instructions. SVTCA[1] is equivalent to SFVTCA[1] followed by SPVTCA[1]. This instruction ensures that both movement and measurement are along the same coordinate axis.</P>
<I>Example: </I></P>
SVTCA[1] </P>
<P><img src="SPEC1.gif"></P>
Sets both measurement and movement to the <I>x</I>-direction.</P>
SVTCA[0]</P>
<P><img src="SPEC2.gif"></P>
Sets both measurement and movement to the <I>y</I>-direction.</P>
<H5><A NAME="sec3"></A>Set Projection_Vector To Coordinate Axis</H5>SPVTCA[a]</P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="68pt" VALIGN="TOP"><COL WIDTH="315pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>Code range</P></TD><TD VALIGN="TOP"><P>0x02 - 0x03</P></TD></TR><TR><TD VALIGN="TOP"><P>a</P></TD><TD VALIGN="TOP"><P>0: set the projection_vector to the <I>y</I>-axis</P></TD></TR><TR><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P>1: set the projection_vector to the <I>x</I>-axis</P></TD></TR><TR><TD VALIGN="TOP"><P>Pops</P></TD><TD VALIGN="TOP"><P>–</P></TD></TR><TR><TD VALIGN="TOP"><P>Pushes</P></TD><TD VALIGN="TOP"><P>–</P></TD></TR><TR><TD VALIGN="TOP"><P>Sets</P></TD><TD VALIGN="TOP"><P>projection_vector</P></TD></TR></TBODY></TABLE>
<BR></P>Sets the projection_vector to one of the coordinate axes depending on the value of the flag a. </P>
<I>Example:</I></P>
SPVTCA[0]</P>
<P><img src="SPEC3.gif"></P>
Sets the projection_vector to the <I>y</I>-axis assuring the measurement will be in that direction.</P>
<H5><A NAME="sec4"></A>Set Freedom_Vector to Coordinate Axis</H5>SFVTCA[a]</P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="72pt" VALIGN="TOP"><COL WIDTH="364pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>Code range</P></TD><TD VALIGN="TOP"><P>0x04 - 0x05</P></TD></TR><TR><TD VALIGN="TOP"><P>a </P></TD><TD VALIGN="TOP"><P>0: set the freedom_vector to the <I>y</I>-axis </P></TD></TR><TR><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P>1: set the freedom_vector to the <I>x</I>-axis</P></TD></TR><TR><TD VALIGN="TOP"><P>Pops</P></TD><TD VALIGN="TOP"><P>–</P></TD></TR><TR><TD VALIGN="TOP"><P>Pushes</P></TD><TD VALIGN="TOP"><P>–</P></TD></TR><TR><TD VALIGN="TOP"><P>Sets</P></TD><TD VALIGN="TOP"><P>freedom_vector</P></TD></TR></TBODY></TABLE>
<BR></P>Sets the freedom_vector to one of the coordinate axes depending upon the value of the flag a. </P>
<I>Example:</I></P>
SFVTCA[0]</P>
<P><img src="SPEC4.gif"></P>
Sets the freedom_vector to the <I>y</I>-axis ensuring that movement will be along that axis.</P>
<H5><A NAME="sec5"></A>Set Projection_Vector To Line</H5>SPVTL[a]</P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="72pt" VALIGN="TOP"><COL WIDTH="364pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>Code Range</P></TD><TD VALIGN="TOP"><P>0x06 - 0x07</P></TD></TR><TR><TD VALIGN="TOP"><P>a</P></TD><TD VALIGN="TOP"><P>0:  sets projection_vector to be parallel to line segment from p1 to p2</P></TD></TR><TR><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P>1:  sets projection_vector to be perpendicular to line segment from p1 to <BR> p2; the vector is rotated counter clockwise 90 degrees</P></TD></TR><TR><TD VALIGN="TOP"><P>Pops</P></TD><TD VALIGN="TOP"><P>p1: point number (ULONG)</P></TD></TR><TR><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P>p2: point number (ULONG)</P></TD></TR><TR><TD VALIGN="TOP"><P>Pushes</P></TD><TD VALIGN="TOP"><P>–</P></TD></TR><TR><TD VALIGN="TOP"><P>Uses</P></TD><TD VALIGN="TOP"><P>point p1 in the zone pointed at by zp2</P></TD></TR><TR><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P>point p2 in the zone pointed at by zp1</P></TD></TR><TR><TD VALIGN="TOP"><P>Sets</P></TD><TD VALIGN="TOP"><P>projection_vector</P></TD></TR></TBODY></TABLE>
<BR></P>Sets the projection_vector to a unit vector parallel or perpendicular to the line segment from point p1 to point p2. </P>
<P><img src="SPEC5.gif"></P>
If parallel, the projection_vector points from p1 toward p2 as shown.</P>
If perpendicular the projection_vector is obtained by rotating the parallel vector in a counter clockwise manner as shown. </P>
<P><img src="SPEC6.gif"></P>
<I>case 1:</I></P>
SPVTL[1]</P>
<P><img src="SPEC7.gif"></P>
Sets the projection_vector to be parallel to the line from point 7 to point 14.</P>
<I>case 2:</I></P>
SPVTL[1]</P>
<P><img src="SPEC8.gif"></P>
Sets the projection_vector to be perpendicular to the line from point 7  to point 14.</P>
<I>case 3:</I></P>
SPVTL[1]</P>
<P><img src="SPEC9.gif"></P>
The order in which the points are specified matters.  This instruction sets the projection_vector to be perpendicular to the line from point 14 to point 7.</P>
<H5><A NAME="sec6"></A>Set Freedom_Vector To Line</H5>SFVTL[a]</P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="68pt" VALIGN="TOP"><COL WIDTH="368pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>Code Range</P></TD><TD VALIGN="TOP"><P>0x08 - 0x09</P></TD></TR><TR><TD VALIGN="TOP"><P>a</P></TD><TD VALIGN="TOP"><P>0:  set freedom_vector to be parallel to the line segment defined by points p1 and p2</P></TD></TR><TR><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P>1:  set freedom_vector  perpendicular to the line segment defined by points p1 and p2; the vector is rotated counter clockwise 90 degrees</P></TD></TR><TR><TD VALIGN="TOP"><P>Pops</P></TD><TD VALIGN="TOP"><P>p1: point number (ULONG)</P></TD></TR><TR><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P>p2: point number (ULONG)</P></TD></TR><TR><TD VALIGN="TOP"><P>Pushes</P></TD><TD VALIGN="TOP"><P>–</P></TD></TR><TR><TD VALIGN="TOP"><P>Sets</P></TD><TD VALIGN="TOP"><P>freedom_vector</P></TD></TR><TR><TD VALIGN="TOP"><P>Uses</P></TD><TD VALIGN="TOP"><P>point p1 in the zone pointed at by zp2</P>
<P>point p2 in the zone pointed at by zp1</P></TD></TR></TBODY></TABLE>
<BR></P>Sets the freedom_vector to a unit vector parallel or perpendicular to the line segment defined by points p1 and p2.</P>
<P><img src="SPEC10.gif"></P>
<P>If parallel the freedom_vector points from p1 toward p2 as shown.</P>
<P><img src="SPEC11.gif"></P>
<P>If perpendicular the freedom_vector is obtained by rotating the parallel vector in a counter clockwise manner as shown. </P>
<P><img src="SPEC12.gif"></P>
<H5><A NAME="sec7"></A>Set Freedom_Vector To Projection Vector</H5>SFVTPV[ ]</P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="63pt" VALIGN="TOP"><COL WIDTH="373pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>Code</P></TD><TD VALIGN="TOP"><P>0x0E</P></TD></TR><TR><TD VALIGN="TOP"><P>Pops</P></TD><TD VALIGN="TOP"><P>–</P></TD></TR><TR><TD VALIGN="TOP"><P>Pushes</P></TD><TD VALIGN="TOP"><P>–</P></TD></TR><TR><TD VALIGN="TOP"><P>Sets</P></TD><TD VALIGN="TOP"><P>freedom_vector</P></TD></TR></TBODY></TABLE>
<BR></P>Sets the freedom_vector to be the same as the projection_vector.</P>
<I>Before</I></P>
<P><img src="SPEC13.gif"></P>
<I>After</I></P>
<P><img src="SPEC14.gif"></P>
<H5><A NAME="sec8"></A>Set Dual Projection_Vector To Line</H5>SDPVTL[a]</P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="72pt" VALIGN="TOP"><COL WIDTH="364pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>Code Range</P></TD><TD VALIGN="TOP"><P>0x86 - 0x87</P></TD></TR><TR><TD VALIGN="TOP"><P>a</P></TD><TD VALIGN="TOP"><P>0:  Vectors are parallel to line</P></TD></TR><TR><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P>1:  Vectors are perpendicular to line</P></TD></TR><TR><TD VALIGN="TOP"><P>Pops</P></TD><TD VALIGN="TOP"><P>p1: first point number (ULONG)</P></TD></TR><TR><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P>p2: second point number (ULONG)</P></TD></TR><TR><TD VALIGN="TOP"><P>Pushes</P></TD><TD VALIGN="TOP"><P>–</P></TD></TR><TR><TD VALIGN="TOP"><P>Sets</P></TD><TD VALIGN="TOP"><P>dual_projection_vector and projection_vector</P></TD></TR><TR><TD VALIGN="TOP"><P>Uses</P></TD><TD VALIGN="TOP"><P>point p1 in the zone pointed at by zp2</P></TD></TR><TR><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P>point p2 in the zone pointed at by zp1</P></TD></TR></TBODY></TABLE>
<BR></P>Pops two point numbers from the stack and uses them to specify a line that defines a second, dual_projection_vector. This dual_projection_vector uses coordinates from the scaled outline before any grid-fitting took place. It is used only with the IP, GC, MD, MDRP and MIRP instructions. Those instructions will use the dual_projection_vector when they measure distances between ungrid-fitted points. The dual_projection_vector will disappear when any other instruction that sets the projection_vector is used.</P>
<P><img src="SPEC15.gif"></P>
<P>Note: </P>
<P>The dual_projection_vector is set parallel to the points as they appeared in the original outline before any grid-fitting took place.</P>
<H5><A NAME="sec9"></A>Set Projection_Vector From Stack</H5>SPVFS[ ]</P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="72pt" VALIGN="TOP"><COL WIDTH="364pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>Code Range</P></TD><TD VALIGN="TOP"><P>0x0A</P></TD></TR><TR><TD VALIGN="TOP"><P>Pops</P></TD><TD VALIGN="TOP"><P><I>y</I>:  <I>y</I> component of projection_vector (2.14 fixed point number padded with zeroes)</P></TD></TR><TR><TD VALIGN="TOP"><P><I></I></P></TD><TD VALIGN="TOP"><P>x:  <I>x</I> component of projection_vector (2.14 fixed point number padded with zeroes)</P></TD></TR><TR><TD VALIGN="TOP"><P>Pushes</P></TD><TD VALIGN="TOP"><P>–</P></TD></TR><TR><TD VALIGN="TOP"><P>Sets</P></TD><TD VALIGN="TOP"><P>projection_vector</P></TD></TR></TBODY></TABLE>
<BR></P>Sets the direction of the projection_vector, using values x and y taken from the stack, so that its projections onto the <I>x</I> and <I>y</I>-axes are <I>x</I> and <I>y</I>, which are specified as signed (two's complement) fixed-point (2.14) numbers. The square root of (x2 + y2) must be equal to 0x4000 (hex).</P>
If values are to be saved and used by a glyph program, font program or preprogram across different resolutions, extreme care must be used. The values taken from or put on the stack are 2.14 fixed-point values for the x and y components of the vector in question. The values are based on the normalized vector lengths. More simply, the values must always be set such that (X**2 + Y**2) is 1.</P>
If a TrueType program uses specific values for X and Y to set the vectors to certain angles, these values will <I>not</I> produce identical results across different aspect ratios. Values that work correctly at 1:1 aspect ratios (such as VGA and 8514) will not necessarily yield the desired results at a ratio of 1.33:1 (e.g. the EGA).</P>
By the same token, if a TrueType program is making use of the values returned by GPV and GFV, the values returned for a specific angle will vary with the aspect ratio in use at the time.</P>
<P><img src="SPEC16.gif"></P>
<I>Example:</I></P>
SPVFS[ ]</P>
<P><img src="SPEC17.gif"></P>
Sets the projection_vector to a unit vector that points in the direction of the <I>x</I>-axis</P>
<H5><A NAME="sec10"></A>Set Freedom_Vector From Stack</H5><P>SFVFS[ ]</P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="59pt" VALIGN="TOP"><COL WIDTH="377pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>Code</P></TD><TD VALIGN="TOP"><P>0x0B</P></TD></TR><TR><TD VALIGN="TOP"><P>Pops</P></TD><TD VALIGN="TOP"><P><I>y:  y </I>component of freedom_vector (2.14 fixed point number padded with zeroes)</P></TD></TR><TR><TD VALIGN="TOP"><P><I></I></P></TD><TD VALIGN="TOP"><P>x:  <I>x</I> component of freedom_vector (2.14 fixed point number padded with zeroes)</P></TD></TR><TR><TD VALIGN="TOP"><P>Pushes</P></TD><TD VALIGN="TOP"><P>–</P></TD></TR><TR><TD VALIGN="TOP"><P>Sets</P></TD><TD VALIGN="TOP"><P>freedom_vector</P></TD></TR></TBODY></TABLE>
<BR></P>Sets the direction of the freedom_vector using the values x and y taken from the stack. The vector is set so that its projections onto the <I>x</I>  and <I>y</I> -axes are <I>x</I> and <I>y</I>, which are specified as signed (two's complement) fixed-point (2.14) numbers. The square root of (x2 + y2) must be equal to 0x4000 (hex).</P>
If values are to be saved and used by a glyph program, font program or preprogram across different resolutions, extreme care must be used. The values taken from or put on the stack are 2.14 fixed-point values for the x and y components of the vector in question. The values are based on the normalized vector lengths. More simply, the values must always be set such that (X**2 + Y**2) is 1.</P>
If a TrueType program uses specific values for X and Y to set the vectors to certain angles, these values will <I>not</I> produce identical results across different aspect ratios. Values that work correctly at 1:1 aspect ratios (such as VGA and 8514) will not necessarily yield the desired results at a ratio of 1.33:1 (e.g. the EGA).</P>
By the same token, if a TrueType program is making use of the values returned by GPV and GFV, the values returned for a specific angle will vary with the aspect ratio in use at the time.</P>
<P><img src="13751.gif"></P>
<I>Example:</I></P>
<P><img src="SPEC18.gif"></P>
Sets the freedom_vector to a unit vector that points in the direction of the <I>y</I>-axis.</P>
<H5><A NAME="sec11"></A>Get Projection_Vector</H5>GPV[ ]</P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="72pt" VALIGN="TOP"><COL WIDTH="365pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>Code Range</P></TD><TD VALIGN="TOP"><P>0x0C</P></TD></TR><TR><TD VALIGN="TOP"><P>Pops</P></TD><TD VALIGN="TOP"><P>–</P></TD></TR><TR><TD VALIGN="TOP"><P>Pushes</P></TD><TD VALIGN="TOP"><P><I>x</I>:  <I>x</I> component of projection_vector  (2.14 fixed point number padded with zeroes)</P></TD></TR><TR><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P><I>y</I> :  <I>y</I> component of projection_vector  (2.14 fixed point number padded with zeroes)</P></TD></TR><TR><TD VALIGN="TOP"><P>Gets</P></TD><TD VALIGN="TOP"><P>projection_vector</P></TD></TR></TBODY></TABLE>
<BR></P>Pushes the x and y components of the projection_vector onto the stack as two 2.14 numbers.</P>
If values are to be saved and used by a glyph program, font program or preprogram across different resolutions, extreme care must be used. The values taken from or put on the stack are 2.14 fixed-point values for the x and y components of the vector in question. The values are based on the normalized vector lengths. More simply, the values must always be set such that (X**2 + Y**2) is 1.</P>
If a TrueType program uses specific values for X and Y to set the vectors to certain angles, these values will <I>not</I> produce identical results across different aspect ratios. Values that work correctly at 1:1 aspect ratios (such as VGA and 8514) will not necessarily yield the desired results at a ratio of 1.33:1 (e.g. the EGA).</P>
By the same token, if a TrueType program is making use of the values returned by GPV and GFV, the values returned for a specific angle will vary with the aspect ratio in use at the time.</P>
<P><img src="13752.gif"></P>
<I>Example:</I></P>
case 1:</P>
<P><img src="SPEC19.gif"></P>
The stack entry 0x4000 which when interpreted as a 2.14 number is simply 1. This command reveals that, in this case, the projection_vector is a unit vector that points in the <I>x</I>-direction.</P>
<I>case 2:</I></P>
<P><img src="SPEC20.gif"></P>
Here the projection_vector is a unit vector that points in the direction of the <I>y</I>-axis.</P>
<I>case 3:</I></P>
<P><img src="SPEC21.gif"></P>
<P>Note:</P>
<P>0x2D41 is the hex equivalent of <img src="EQUATE1.gif">. As a result of this instruction, the projection_vector is set to a 45 degree angle relative to the x-axis.</P>
<H5><A NAME="sec12"></A>Get Freedom_Vector</H5>GFV[ ]</P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="77pt" VALIGN="TOP"><COL WIDTH="359pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>Code Range</P></TD><TD VALIGN="TOP"><P>0x0D</P></TD></TR><TR><TD VALIGN="TOP"><P>Pops</P></TD><TD VALIGN="TOP"><P>–</P></TD></TR><TR><TD VALIGN="TOP"><P>Pushes</P></TD><TD VALIGN="TOP"><P>x: x-component of freedom_vector (2.14 number padded with zeroes)</P></TD></TR><TR><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P>y: y component of freedom_vector (2.14 number padded with zeroes)</P></TD></TR><TR><TD VALIGN="TOP"><P>Gets</P></TD><TD VALIGN="TOP"><P>freedom_vector</P></TD></TR></TBODY></TABLE>
<BR></P>Puts the <I>x</I> and <I>y</I>  components of the freedom_vector on the stack. The freedom_vector is put onto the stack as two 2.14 coordinates.</P>
If values are to be saved and used by a glyph program, font program or preprogram across different resolutions, extreme care must be used. The values taken from or put on the stack are 2.14 fixed-point values for the x and y components of the vector in question. The values are based on the normalized vector lengths. More simply, the values must always be set such that (X**2 + Y**2) is 1.</P>
If a TrueType program uses specific values for X and Y to set the vectors to certain angles, these values will <I>not</I> produce identical results across different aspect ratios. Values that work correctly at 1:1 aspect ratios (such as VGA and 8514) will not necessarily yield the desired results at a ratio of 1.33:1 (e.g. the EGA).</P>
By the same token, if a TrueType program is making use of the values returned by GPV and GFV, the values returned for a specific angle will vary with the aspect ratio in use at the time.</P>
<P><img src="13753.gif"></P>
<I>Example</I></P>
GFV[ ]</P>
<P><img src="SPEC22.gif"></P>
<H5><A NAME="sec13"></A>Set Reference Point 0</H5>SRP0[ ] </P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="72pt" VALIGN="TOP"><COL WIDTH="365pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>Code Range</P></TD><TD VALIGN="TOP"><P>0x10</P></TD></TR><TR><TD VALIGN="TOP"><P>Pops</P></TD><TD VALIGN="TOP"><P>p: point number (ULONG)</P></TD></TR><TR><TD VALIGN="TOP"><P>Pushes</P></TD><TD VALIGN="TOP"><P>–</P></TD></TR><TR><TD VALIGN="TOP"><P>Sets</P></TD><TD VALIGN="TOP"><P>rp0</P></TD></TR><TR><TD VALIGN="TOP"><P>Affects</P></TD><TD VALIGN="TOP"><P>IP, MDAP, MIAP, MIRP, MSIRP, SHC, SHE, SHP</P></TD></TR></TBODY></TABLE>
<BR></P>Pops a point number from the stack and sets rp0 to that point number.</P>
<P><img src="13754.gif"></P>
<H5><A NAME="sec14"></A>Set Reference Point 1</H5>SRP1[ ] </P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="72pt" VALIGN="TOP"><COL WIDTH="365pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>Code Range</P></TD><TD VALIGN="TOP"><P>0x11</P></TD></TR><TR><TD VALIGN="TOP"><P>Pops</P></TD><TD VALIGN="TOP"><P>p: point number (ULONG)</P></TD></TR><TR><TD VALIGN="TOP"><P>Pushes</P></TD><TD VALIGN="TOP"><P>–</P></TD></TR><TR><TD VALIGN="TOP"><P>Sets</P></TD><TD VALIGN="TOP"><P>rp1</P></TD></TR><TR><TD VALIGN="TOP"><P>Affects</P></TD><TD VALIGN="TOP"><P>IP, MDAP, MDRP, MIAP, MSIRP, SHC, SHE, SHP</P></TD></TR></TBODY></TABLE>
<BR></P>Pops a point number from the stack and sets rp1 to that point number.</P>
<P><img src="13755.gif"></P>
<H5><A NAME="sec15"></A>Set Reference Point 2</H5>SRP2[ ]</P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="72pt" VALIGN="TOP"><COL WIDTH="365pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>Code Range</P></TD><TD VALIGN="TOP"><P>0x12</P></TD></TR><TR><TD VALIGN="TOP"><P>Pops</P></TD><TD VALIGN="TOP"><P>p:point number (ULONG)</P></TD></TR><TR><TD VALIGN="TOP"><P>Pushes</P></TD><TD VALIGN="TOP"><P>–</P></TD></TR><TR><TD VALIGN="TOP"><P>Sets</P></TD><TD VALIGN="TOP"><P>rp2</P></TD></TR></TBODY></TABLE>
<BR></P>Pops a point number from the stack and sets rp2 to that point number.</P>
<P><img src="13756.gif"></P>
<H5><A NAME="sec16"></A>Set Zone Pointer 0</H5>SZP0[ ]</P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="72pt" VALIGN="TOP"><COL WIDTH="365pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>Code Range</P></TD><TD VALIGN="TOP"><P>0x13</P></TD></TR><TR><TD VALIGN="TOP"><P>Pops</P></TD><TD VALIGN="TOP"><P>n: zone number (ULONG)</P></TD></TR><TR><TD VALIGN="TOP"><P>Pushes</P></TD><TD VALIGN="TOP"><P>–</P></TD></TR><TR><TD VALIGN="TOP"><P>Sets </P></TD><TD VALIGN="TOP"><P>zp0</P></TD></TR><TR><TD VALIGN="TOP"><P>Affects</P></TD><TD VALIGN="TOP"><P>ALIGNPTS, ALIGNRP, DELTAP1, DELTAP2, DELTAP3, IP, ISECT, MD, MDAP, MIAP, MIRP, MSIRP, SHC, SHE, SHP, UTP</P></TD></TR></TBODY></TABLE>
<BR></P>Pops a zone number, n, from the stack and sets zp0 to the zone with that number. If n is 0, zp0 points to zone 0. If n is 1, zp0 points to zone 1. Any other value for n is an error.</P>
<P><img src="13757.gif"></P>
<I>Example:</I></P>
<P><img src="13758.gif"></P>
<H5><A NAME="sec17"></A>Set Zone Pointer 1</H5>SZP1[ ] </P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="72pt" VALIGN="TOP"><COL WIDTH="365pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>Code Range </P></TD><TD VALIGN="TOP"><P>0x14</P></TD></TR><TR><TD VALIGN="TOP"><P>Pops</P></TD><TD VALIGN="TOP"><P>n: zone number (ULONG)</P></TD></TR><TR><TD VALIGN="TOP"><P>Pushes</P></TD><TD VALIGN="TOP"><P>–</P></TD></TR><TR><TD VALIGN="TOP"><P>Sets</P></TD><TD VALIGN="TOP"><P>zp1</P></TD></TR><TR><TD VALIGN="TOP"><P>Affects</P></TD><TD VALIGN="TOP"><P>ALIGNRPTS, ALIGNRP, IP, MD, MDRP, MSIRP, SHC, SHE, SHP, SFVTL, SPVTL</P></TD></TR></TBODY></TABLE>
<BR></P>Pops a zone number, n, from the stack and sets zp1 to the zone with that number. If n is 0, zp1 points to zone 0. If n is 1, zp1 points to zone 1. Any other value for n is an error.</P>
<P><img src="13759.gif"></P>
<I>Example</I></P>
<P><img src="13760.gif"></P>
<H5><A NAME="sec18"></A>Set Zone Pointer 2</H5>SZP2[ ] </P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="72pt" VALIGN="TOP"><COL WIDTH="365pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>Code Range </P></TD><TD VALIGN="TOP"><P>0x15</P></TD></TR><TR><TD VALIGN="TOP"><P>Pops</P></TD><TD VALIGN="TOP"><P>n: zone number (ULONG)</P></TD></TR><TR><TD VALIGN="TOP"><P>Pushes</P></TD><TD VALIGN="TOP"><P>–</P></TD></TR><TR><TD VALIGN="TOP"><P>Sets</P></TD><TD VALIGN="TOP"><P>zp2</P></TD></TR><TR><TD VALIGN="TOP"><P>Affects</P></TD><TD VALIGN="TOP"><P>ISECT, IUP, GC, SHC, SHP, SFVTL, SHPIX, SPVTL, SC</P></TD></TR></TBODY></TABLE>
<BR></P>Pops a zone number, n, from the stack and sets zp2 to the zone with that number. If n is 0, zp2 points to zone 0. If n is 1, zp2 points to zone 1. Any other value for n is an error.</P>
<P><img src="13761.gif"></P>
<H5><A NAME="sec19"></A>Set Zone PointerS</H5>SZPS[ ]</P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="72pt" VALIGN="TOP"><COL WIDTH="365pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>Code Range</P></TD><TD VALIGN="TOP"><P>0x16</P></TD></TR><TR><TD VALIGN="TOP"><P>Pops</P></TD><TD VALIGN="TOP"><P>n: zone number (ULONG)</P></TD></TR><TR><TD VALIGN="TOP"><P>Pushes </P></TD><TD VALIGN="TOP"><P>–</P></TD></TR><TR><TD VALIGN="TOP"><P>Sets</P></TD><TD VALIGN="TOP"><P>zp0, zp1, zp2</P></TD></TR><TR><TD VALIGN="TOP"><P>Affects</P></TD><TD VALIGN="TOP"><P>ALIGNPTS, ALIGNRP, DELTAP1, DELTAP2, DELTAP3, GC, IP, ISECT, IUP, MD, MDAP, MDRP, MIAP, MIRP, MSIRP, SC, SFVTL, SHPIX, SPVTL, SHC, SHE, SHP, SPVTL, UTP </P></TD></TR></TBODY></TABLE>
<BR></P>Pops a zone number from the stack and sets all of the zone pointers to point to the zone with that number. If n is 0, all three zone pointers will point to zone 0. If n is 1, all three zone pointers will point to zone 1. Any other value for n is an error.</P>
<P><img src="13762.gif"></P>
<H5><A NAME="sec20"></A>Round To Half Grid</H5>RTHG[ ]</P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="72pt" VALIGN="TOP"><COL WIDTH="365pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>Code Range </P></TD><TD VALIGN="TOP"><P>0x19</P></TD></TR><TR><TD VALIGN="TOP"><P>Pops</P></TD><TD VALIGN="TOP"><P>–</P></TD></TR><TR><TD VALIGN="TOP"><P>Pushes </P></TD><TD VALIGN="TOP"><P>–</P></TD></TR><TR><TD VALIGN="TOP"><P>Sets</P></TD><TD VALIGN="TOP"><P>round_state</P></TD></TR><TR><TD VALIGN="TOP"><P>Affects</P></TD><TD VALIGN="TOP"><P>MDAP, MDRP, MIAP, MIRP, ROUND</P></TD></TR><TR><TD VALIGN="TOP"><P>Uses</P></TD><TD VALIGN="TOP"><P>freedom_vector, projection_vector</P></TD></TR></TBODY></TABLE>
<BR></P>Sets the round_state variable to state 0 (<I>hg</I>). In this state, the coordinates of a point are rounded to the nearest half grid line.</P>
<I>Example:</I></P>
<P><img src="13763.gif"></P>
<H5><A NAME="sec21"></A>Round To Grid</H5>RTG[ ]</P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="72pt" VALIGN="TOP"><COL WIDTH="365pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>Code Range </P></TD><TD VALIGN="TOP"><P>0x18</P></TD></TR><TR><TD VALIGN="TOP"><P>Pops</P></TD><TD VALIGN="TOP"><P>–</P></TD></TR><TR><TD VALIGN="TOP"><P>Pushes </P></TD><TD VALIGN="TOP"><P>–</P></TD></TR><TR><TD VALIGN="TOP"><P>Sets</P></TD><TD VALIGN="TOP"><P>round_state</P></TD></TR><TR><TD VALIGN="TOP"><P>Affects</P></TD><TD VALIGN="TOP"><P>MDAP, MDRP, MIAP, MIRP, ROUND</P></TD></TR><TR><TD VALIGN="TOP"><P>Uses</P></TD><TD VALIGN="TOP"><P>freedom_vector, projection_vector</P></TD></TR></TBODY></TABLE>
<BR></P>Sets the round_state variable to state 1 (<I>g</I>). In this state, distances are rounded to the closest grid line.</P>
<I>Example:</I></P>
<P><img src="13764.gif"></P>
<H5><A NAME="sec22"></A>Round To Double Grid</H5>RTDG[ ]</P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="72pt" VALIGN="TOP"><COL WIDTH="365pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>Code Range</P></TD><TD VALIGN="TOP"><P>0x3D</P></TD></TR><TR><TD VALIGN="TOP"><P>Pops</P></TD><TD VALIGN="TOP"><P>–</P></TD></TR><TR><TD VALIGN="TOP"><P>Pushes</P></TD><TD VALIGN="TOP"><P>–</P></TD></TR><TR><TD VALIGN="TOP"><P>Sets</P></TD><TD VALIGN="TOP"><P>round_state</P></TD></TR><TR><TD VALIGN="TOP"><P>Affects</P></TD><TD VALIGN="TOP"><P>MDAP, MDRP, MIAP, MIRP, ROUND</P></TD></TR><TR><TD VALIGN="TOP"><P>Uses</P></TD><TD VALIGN="TOP"><P>freedom_vector, projection_vector</P></TD></TR></TBODY></TABLE>
<BR></P>Sets the round_state variable to state 2 (<I>dg</I>). In this state, distances are rounded to the closest half or integer pixel.</P>
<I>Example:</I></P>
<P><img src="13765.gif"></P>
<H5><A NAME="sec23"></A>Round Down To Grid</H5>RDTG[ ]</P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="72pt" VALIGN="TOP"><COL WIDTH="365pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>Code Range</P></TD><TD VALIGN="TOP"><P>0x7D</P></TD></TR><TR><TD VALIGN="TOP"><P>Pops</P></TD><TD VALIGN="TOP"><P>–</P></TD></TR><TR><TD VALIGN="TOP"><P>Pushes</P></TD><TD VALIGN="TOP"><P>–</P></TD></TR><TR><TD VALIGN="TOP"><P>Sets</P></TD><TD VALIGN="TOP"><P>round_state</P></TD></TR><TR><TD VALIGN="TOP"><P>Affects</P></TD><TD VALIGN="TOP"><P>MDAP, MDRP, MIAP, MIRP, ROUND</P></TD></TR><TR><TD VALIGN="TOP"><P>Uses</P></TD><TD VALIGN="TOP"><P>freedom_vector, projection_vector</P></TD></TR></TBODY></TABLE>
<BR></P>Sets the round_state variable to state 3 (<I>dtg</I>). In this state, distances are rounded down to the closest integer grid line.</P>
<I>Example:</I></P>
<P><img src="13766.gif"></P>
<H5><A NAME="sec24"></A>Round Up To Grid</H5>RUTG[ ]</P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="72pt" VALIGN="TOP"><COL WIDTH="365pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>Code Range</P></TD><TD VALIGN="TOP"><P>0x7C</P></TD></TR><TR><TD VALIGN="TOP"><P>Pops</P></TD><TD VALIGN="TOP"><P>–</P></TD></TR><TR><TD VALIGN="TOP"><P>Pushes</P></TD><TD VALIGN="TOP"><P>–</P></TD></TR><TR><TD VALIGN="TOP"><P>Sets</P></TD><TD VALIGN="TOP"><P>round_state</P></TD></TR><TR><TD VALIGN="TOP"><P>Affects</P></TD><TD VALIGN="TOP"><P>MDAP, MDRP, MIAP, MIRP, ROUND</P></TD></TR><TR><TD VALIGN="TOP"><P>Uses</P></TD><TD VALIGN="TOP"><P>freedom_vector, projection_vector</P></TD></TR></TBODY></TABLE>
<BR></P>Sets the round_state variable to state 4 (<I>utg</I>). In this state distances are rounded up to the closest integer pixel boundary.</P>
<I>Example:</I></P>
<P><img src="13767.gif"></P>
<H5><A NAME="sec25"></A>Round OFF</H5>ROFF[ ]</P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="72pt" VALIGN="TOP"><COL WIDTH="365pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>Code Range</P></TD><TD VALIGN="TOP"><P>0x7A</P></TD></TR><TR><TD VALIGN="TOP"><P>Pop</P></TD><TD VALIGN="TOP"><P>–</P></TD></TR><TR><TD VALIGN="TOP"><P>Pushes</P></TD><TD VALIGN="TOP"><P>–</P></TD></TR><TR><TD VALIGN="TOP"><P>Sets</P></TD><TD VALIGN="TOP"><P>round_state</P></TD></TR><TR><TD VALIGN="TOP"><P>Affects</P></TD><TD VALIGN="TOP"><P>MDAP, MDRP, MIAP, MIRP, ROUND</P></TD></TR><TR><TD VALIGN="TOP"><P>Uses</P></TD><TD VALIGN="TOP"><P>freedom_vector, projection_vector</P></TD></TR></TBODY></TABLE>
<BR></P>Sets the round_state variable to state 5 (<I>off</I>). In this state rounding is turned off.</P>
<I>Example:</I></P>
<P><img src="13768.gif"></P>
<H5><A NAME="sec26"></A>Super ROUND</H5>SROUND[ ] </P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="72pt" VALIGN="TOP"><COL WIDTH="365pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>Code Range</P></TD><TD VALIGN="TOP"><P>0x76</P></TD></TR><TR><TD VALIGN="TOP"><P>Pops</P></TD><TD VALIGN="TOP"><P>n: number decomposed to obtain period, phase, threshold</P></TD></TR><TR><TD VALIGN="TOP"><P>Pushes</P></TD><TD VALIGN="TOP"><P>–</P></TD></TR><TR><TD VALIGN="TOP"><P>Sets</P></TD><TD VALIGN="TOP"><P>round_state</P></TD></TR><TR><TD VALIGN="TOP"><P>Affects</P></TD><TD VALIGN="TOP"><P>MDAP, MDRP, MIAP, MIRP, ROUND</P></TD></TR></TBODY></TABLE>
<BR></P>SROUND allows you fine control over the effects of the round_state variable by allowing you to set the values of three components of the round_state: period, phase, and threshold.</P>
More formally, SROUND maps the domain of 26.6 fixed point numbers into a set of discrete values that are separated by equal distances. SROUND takes one argument from the stack, n, which is decomposed into a period, phase and threshold. </P>
The period specifies the length of the separation or space between rounded values in terms of grid spacing. </P>
<P><img src="13769.gif"></P>
<P><img src="13770.gif"></P>
<P><img src="13771.gif"></P>
The phase specifies the offset of the values from multiples of the period.</P>
<P><img src="13772.gif"></P>
<P><img src="13773.gif"></P>
The threshold specifies the part of the domain that is mapped onto each value. More intuitively, the threshold tells a value when to "fall forward" to the next largest integer.</P>
<P><img src="13774.gif"></P>
<P><img src="13775.gif"></P>
Only the lower 8 bits of the argument n are used. For SROUND gridPeriod is equal to 1.0 pixels. The byte is encoded as follows: bits 7 and 6 encode the period, bits 5 and 4 encode the phase and bits 3, 2, 1 and 0 encode the threshold as shown here.</P>
<H5><A NAME="sec27"></A>period</H5>
<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="28pt" VALIGN="TOP"><COL WIDTH="409pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>0</P></TD><TD VALIGN="TOP"><P>period = gridPeriod/2</P></TD></TR><TR><TD VALIGN="TOP"><P>1</P></TD><TD VALIGN="TOP"><P>period = gridPeriod</P></TD></TR><TR><TD VALIGN="TOP"><P>2</P></TD><TD VALIGN="TOP"><P>period = gridPeriod*2</P></TD></TR><TR><TD VALIGN="TOP"><P>3</P></TD><TD VALIGN="TOP"><P>Reserved</P></TD></TR></TBODY></TABLE>
<BR></P><H5><A NAME="sec28"></A>phase</H5>
<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="28pt" VALIGN="TOP"><COL WIDTH="346pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>0</P></TD><TD VALIGN="TOP"><P>phase = 0</P></TD></TR><TR><TD VALIGN="TOP"><P>1</P></TD><TD VALIGN="TOP"><P>phase= period/4</P></TD></TR><TR><TD VALIGN="TOP"><P>2</P></TD><TD VALIGN="TOP"><P>phase = period/2</P></TD></TR><TR><TD VALIGN="TOP"><P>3</P></TD><TD VALIGN="TOP"><P>phase = gridPeriod*3/4</P></TD></TR></TBODY></TABLE>
<BR></P><H5><A NAME="sec29"></A>threshold</H5>
<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="28pt" VALIGN="TOP"><COL WIDTH="346pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>0</P></TD><TD VALIGN="TOP"><P>threshold = period -1</P></TD></TR><TR><TD VALIGN="TOP"><P>1</P></TD><TD VALIGN="TOP"><P>threshold = -3/8 * period</P></TD></TR><TR><TD VALIGN="TOP"><P>2</P></TD><TD VALIGN="TOP"><P>threshold = -2/8 * period</P></TD></TR><TR><TD VALIGN="TOP"><P>3</P></TD><TD VALIGN="TOP"><P>threshold = -1/8 * period</P></TD></TR></TBODY></TABLE>
<BR></P></P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="28pt" VALIGN="TOP"><COL WIDTH="409pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>4</P></TD><TD VALIGN="TOP"><P>threshold = 0/8 * period</P></TD></TR><TR><TD VALIGN="TOP"><P>5</P></TD><TD VALIGN="TOP"><P>threshold = 1/8 * period</P></TD></TR><TR><TD VALIGN="TOP"><P>6</P></TD><TD VALIGN="TOP"><P>threshold = 2/8 * period</P></TD></TR><TR><TD VALIGN="TOP"><P>7</P></TD><TD VALIGN="TOP"><P>threshold =3/8 * period</P></TD></TR></TBODY></TABLE>
<BR></P></P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="28pt" VALIGN="TOP"><COL WIDTH="409pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>8</P></TD><TD VALIGN="TOP"><P>threshold = 4/8 * period</P></TD></TR><TR><TD VALIGN="TOP"><P>9</P></TD><TD VALIGN="TOP"><P>threshold = 5/8 * period</P></TD></TR><TR><TD VALIGN="TOP"><P>10</P></TD><TD VALIGN="TOP"><P>threshold = 6/8 period</P></TD></TR><TR><TD VALIGN="TOP"><P>11</P></TD><TD VALIGN="TOP"><P>threshold = 7/8 * period</P></TD></TR></TBODY></TABLE>
<BR></P></P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="28pt" VALIGN="TOP"><COL WIDTH="409pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>12</P></TD><TD VALIGN="TOP"><P>threshold = 8/8 * period</P></TD></TR><TR><TD VALIGN="TOP"><P>13</P></TD><TD VALIGN="TOP"><P>threshold = 9/8 * period</P></TD></TR><TR><TD VALIGN="TOP"><P>14</P></TD><TD VALIGN="TOP"><P>threshold = 10/8 * period</P></TD></TR><TR><TD VALIGN="TOP"><P>15</P></TD><TD VALIGN="TOP"><P>threshold = 11/8 * period</P></TD></TR></TBODY></TABLE>
<BR></P>For example, SROUND(01:01:1000) maps numbers into the values 0.25, 1.25, 2.25, .... The numbers from -0.25 to 0.75 are mapped into 0.25.  The range of numbers [0.75, 1.75) map into 1.25.  Similarly, the numbers from [1.75, 2.75) map into the number 2.25 and so on.</P>
<P><img src="13776.gif"></P>
Rounding occurs after compensation for engine characteristics, so the steps in the rounding of a number <I>n</I> are:</P>
add engine compensation to <I>n.</I></P>
subtract the phase from <I>n.</I></P>
add the threshold to <I>n.</I></P>
truncate <I>n</I> to the next lowest periodic value (ignore the phase).</P>
add the phase back to <I>n</I>.</P>
if rounding caused a positive number to become negative, set <I>n</I> to the positive round value closest to 0.</P>
if rounding caused a negative number of become positive, set <I>n</I> to the negative round value closest to 0.</P>
the period parameters can have values of 1/2 pixel, 1 pixel, or 2 pixels.  </P>
the phase parameters can have values of 0 pixels, 1/4 pixel, 1/2 pixel, or 3/4 pixel.</P>
the threshold parameters can have values of -3/8 period, -2/8 period,... 11/8 period.  It can also have the special value largest-number-smaller-than-period which causes rounding equivalent to CEILING.  </P>
<H5><A NAME="sec30"></A>Super ROUND 45 degrees</H5>S45ROUND[ ] </P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="72pt" VALIGN="TOP"><COL WIDTH="365pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>Code Range</P></TD><TD VALIGN="TOP"><P>0x77</P></TD></TR><TR><TD VALIGN="TOP"><P>Pops</P></TD><TD VALIGN="TOP"><P>n: ULONG decomposed to obtain period, phase, threshold (ULONG)</P></TD></TR><TR><TD VALIGN="TOP"><P>Pushes</P></TD><TD VALIGN="TOP"><P>–</P></TD></TR><TR><TD VALIGN="TOP"><P>Sets</P></TD><TD VALIGN="TOP"><P>round_state</P></TD></TR><TR><TD VALIGN="TOP"><P>Affects</P></TD><TD VALIGN="TOP"><P>MDAP, MDRP, MIAP, MIRP, ROUND</P></TD></TR></TBODY></TABLE>
<BR></P>S45ROUND is analogous to SROUND. The gridPeriod is SQRT(2)/2 pixels rather than 1 pixel. It is useful for measuring at a 45 degree angle with the coordinate axes.</P>
<H5><A NAME="sec31"></A>Set LOOP variable</H5>SLOOP[ ] </P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="72pt" VALIGN="TOP"><COL WIDTH="365pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>Code Range</P></TD><TD VALIGN="TOP"><P>0x17</P></TD></TR><TR><TD VALIGN="TOP"><P>Pops</P></TD><TD VALIGN="TOP"><P>n: value for loop Graphics State variable (integer)</P></TD></TR><TR><TD VALIGN="TOP"><P>Pushes</P></TD><TD VALIGN="TOP"><P> –</P></TD></TR><TR><TD VALIGN="TOP"><P>Sets</P></TD><TD VALIGN="TOP"><P>loop</P></TD></TR><TR><TD VALIGN="TOP"><P>Affects</P></TD><TD VALIGN="TOP"><P>ALIGNRP, FLIPPT, IP, SHP, SHPIX</P></TD></TR></TBODY></TABLE>
<BR></P>Pops a value, n, from the stack and sets the loop variable count to that value. The loop variable works with the SHP[a], SHPIX[a], IP[&nbsp;], FLIPPT[ ], and ALIGNRP[ ]. The value n indicates the number of times the instruction is to be repeated. After the instruction executes, the loop variable is reset to 1.</P>
<P><img src="13777.gif"></P>
<H5><A NAME="sec32"></A>Set Minimum_ Distance</H5>SMD[ ] </P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="72pt" VALIGN="TOP"><COL WIDTH="365pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>Code Range </P></TD><TD VALIGN="TOP"><P>0x1A</P></TD></TR><TR><TD VALIGN="TOP"><P>Pops</P></TD><TD VALIGN="TOP"><P>distance: value for minimum_distance (F26Dot6)</P></TD></TR><TR><TD VALIGN="TOP"><P>Pushes </P></TD><TD VALIGN="TOP"><P> –</P></TD></TR><TR><TD VALIGN="TOP"><P>Sets </P></TD><TD VALIGN="TOP"><P>minimum_distance</P></TD></TR></TBODY></TABLE>
<BR></P>Pops a value from the stack and sets the minimum_distance variable to that value.  The distance is assumed to be expressed in sixty-fourths of a pixel. </P>
<P><img src="13778.gif"></P>
<H5><A NAME="sec33"></A>INSTruction Execution ConTRol</H5>INSTCTRL[]</P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="72pt" VALIGN="TOP"><COL WIDTH="365pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>Code Range</P></TD><TD VALIGN="TOP"><P>0x8E</P></TD></TR><TR><TD VALIGN="TOP"><P>Pops</P></TD><TD VALIGN="TOP"><P>s:  selector flag (int32)</P></TD></TR><TR><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P>value:  USHORT (padded to 32 bits) used to set value of instruction_control.</P></TD></TR><TR><TD VALIGN="TOP"><P>Pushes</P></TD><TD VALIGN="TOP"><P>–</P></TD></TR><TR><TD VALIGN="TOP"><P>Sets</P></TD><TD VALIGN="TOP"><P>instruction_control</P></TD></TR></TBODY></TABLE>
<BR></P>Sets the instruction control state variable making it possible to turn on or off the execution of instructions and to regulate use of parameters set in the CVT program. INSTCTRL[ ] can only be executed in the CVT program.</P>
This instruction clears and sets various control flags in the rasterizer. The selector flag determines valid values for the value argument. The value determines the new setting of the raterizer control flag. In version 1.0 there are only two flags in use:</P>

<TABLE COLS="3" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="32pt" VALIGN="TOP"><COL WIDTH="103pt" VALIGN="TOP"><COL WIDTH="392pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P></P></TD><TD COLSPAN="2" VALIGN="TOP"><P>Selector flag 1 is used to inhibit grid-fitting. If s=1, valid values for the value argument are 0 (FALSE) and 1 (TRUE). If the value argument is set to TRUE (v=1), any instructions associated with glyphs will not be executed. For example, to inhibit grid-fitting when a glyph is being rotated or stretched, use the following sequence on the preprogram:</P></TD></TR><TR><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P>PUSHB[000] 6</P></TD><TD VALIGN="TOP"><P>/* ask GETINFO to check for stretching or rotation */</P></TD></TR><TR><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P>GETINFO[]</P></TD><TD VALIGN="TOP"><P>/* will push TRUE if glyph is stretched or rotated */</P></TD></TR><TR><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P>IF[]</P></TD><TD VALIGN="TOP"><P>/* tests value at top of stack */</P></TD></TR><TR><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P>PUSHB[000] 1</P></TD><TD VALIGN="TOP"><P>/* value for INSTCTRL */</P></TD></TR><TR><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P>PUSHB[000] 1</P></TD><TD VALIGN="TOP"><P>/* selector for INSTCTRL */</P></TD></TR><TR><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P>INSTRCTRL[]</P></TD><TD VALIGN="TOP"><P>/* based on selector and value will turn grid-fitting off */</P></TD></TR><TR><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P>EIF[]</P></TD><TD VALIGN="TOP"><P></P></TD></TR><TR><TD VALIGN="TOP"><P></P></TD><TD COLSPAN="2" VALIGN="TOP"><P>Selector flag 2 is used to establish that any parameters set in the CVT program should be ignored when instructions associated with glyphs are executed. These include, for example, the values for scantype and the CVT cut-in. If s=1, valid values for the value argument are 0 (FALSE) and 2 (TRUE). If the value argument is set to TRUE (v=2), the default values of those parameters will be used regardless of any changes that may have been made in those values by the preprogram. If the value argument is set to FALSE (v=0), parameter values changed by the CVT program will be used in glyph instructions.</P></TD></TR><TR><TD VALIGN="TOP"><P></P></TD><TD COLSPAN="2" VALIGN="TOP"><P><img src="13779.gif"></P></TD></TR></TBODY></TABLE>
<BR></P><H5><A NAME="sec34"></A>SCAN conversion ConTRoL</H5>SCANCTRL[ ]</P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="72pt" VALIGN="TOP"><COL WIDTH="365pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>Code Range</P></TD><TD VALIGN="TOP"><P>0x85</P></TD></TR><TR><TD VALIGN="TOP"><P>Pops</P></TD><TD VALIGN="TOP"><P>n:  flags indicating when to turn on dropout control mode (16 bit word padded to 32 bits)</P></TD></TR><TR><TD VALIGN="TOP"><P>Pushes</P></TD><TD VALIGN="TOP"><P>–</P></TD></TR><TR><TD VALIGN="TOP"><P>Sets</P></TD><TD VALIGN="TOP"><P>scan_control</P></TD></TR></TBODY></TABLE>
<BR></P>SCANCTRL is used to set the value of the Graphics State variable scan_control which in turn determines whether the scan converter will activate dropout control for this glyph. Use of the dropout control mode is determined by three conditions: </P>
Is the glyph rotated?</P>
Is the glyph stretched?</P>
Is the current setting for ppem less than a specified threshold?</P>
The interpreter pops a word from the stack and looks at the lower 16 bits. </P>
Bits 0-7 represent the threshold value for ppem. A value of FF in bits 0-7 means invoke dropout_control for all sizes. A value of 0 in bits 0-7 means never invoke dropout_control.</P>
Bits 8-13 are used to turn on dropout_control in cases where the specified conditions are met. Bits 8, 9 and 10 are used to turn on the dropout_control mode (assuming other conditions do not block it). Bits 11, 12, and 13 are used to turn off the dropout mode unless other conditions force it. Bits 14 and 15 are reserved for future use.</P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="72pt" VALIGN="TOP"><COL WIDTH="365pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>Bit </P></TD><TD VALIGN="TOP"><P>Meaning if set</P></TD></TR><TR><TD VALIGN="TOP"><P>8</P></TD><TD VALIGN="TOP"><P>Set dropout_control to TRUE if other conditions do not block and ppem is less than or equal to the threshold value.</P></TD></TR><TR><TD VALIGN="TOP"><P>9</P></TD><TD VALIGN="TOP"><P>Set dropout_control to TRUE if other conditions do not block and the glyph is rotated.</P></TD></TR><TR><TD VALIGN="TOP"><P>10 </P></TD><TD VALIGN="TOP"><P>Set dropout_control to TRUE if other conditions do not block and the glyph is stretched.</P></TD></TR><TR><TD VALIGN="TOP"><P>11</P></TD><TD VALIGN="TOP"><P>Set dropout_control to FALSE unless ppem is less than or equal to the threshold value.</P></TD></TR><TR><TD VALIGN="TOP"><P>12</P></TD><TD VALIGN="TOP"><P>Set dropout_control to FALSE unless the glyph is rotated.</P></TD></TR><TR><TD VALIGN="TOP"><P>13</P></TD><TD VALIGN="TOP"><P>Set dropout_control to FALSE unless the glyph is stretched.</P></TD></TR><TR><TD VALIGN="TOP"><P>14</P></TD><TD VALIGN="TOP"><P>Reserved for future use.</P></TD></TR><TR><TD VALIGN="TOP"><P>15</P></TD><TD VALIGN="TOP"><P>Reserved for future use.</P></TD></TR></TBODY></TABLE>
<BR></P><I>For example</I></P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="72pt" VALIGN="TOP"><COL WIDTH="365pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>0x0000</P></TD><TD VALIGN="TOP"><P>No dropout control is invoked</P></TD></TR><TR><TD VALIGN="TOP"><P>0x01FF</P></TD><TD VALIGN="TOP"><P>Always do dropout control</P></TD></TR><TR><TD VALIGN="TOP"><P>0x0A10</P></TD><TD VALIGN="TOP"><P>Do dropout control if the glyph is rotated and has less than 16 pixels per-em</P></TD></TR></TBODY></TABLE>
<BR></P>The scan converter can operate in either a "normal" mode or in a "fix dropout" mode depending on the value of a set of enabling and disabling flags.</P>
<H5><A NAME="sec35"></A>SCANTYPE</H5>SCANTYPE[ ]</P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="81pt" VALIGN="TOP"><COL WIDTH="238pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>Code Range</P></TD><TD VALIGN="TOP"><P>0x8D</P></TD></TR><TR><TD VALIGN="TOP"><P>Pops</P></TD><TD VALIGN="TOP"><P>n:  16 bit integer</P></TD></TR><TR><TD VALIGN="TOP"><P>Pushes</P></TD><TD VALIGN="TOP"><P>–</P></TD></TR><TR><TD VALIGN="TOP"><P>Sets</P></TD><TD VALIGN="TOP"><P>scan_control</P></TD></TR></TBODY></TABLE>
<BR></P>Pops a 16-bit integer whose value is used to determine which rules the scan converter will use. If the value of the argument is 0, the fast scan converter will be used. If the value of the integer is 1 or 2, simple dropout control will be used. If the value of the integer is 4 or 5, smart dropout control will be used. More specifically,</P>
if n=0  rules 1, 2, and 3 are invoked (simple dropout control scan conversion including stubs)</P>
if n=1  rules 1, 2, and 4 are invoked (simple dropout control scan conversion excluding stubs)</P>
if n=2  rules 1 and 2 only are invoked (fast scan conversion; dropout control turned off)</P>
if n=3  same as n = 2</P>
if n = 4  rules 1, 2, and 5 are invoked (smart dropout control scan conversion including stubs)</P>
if n = 5  rules 1, 2, and 6 are invoked (smart dropout control scan conversion excluding stubs)</P>
if n = 6  same as n = 2</P>
if n = 7  same as n = 2</P>
The scan conversion rules are shown here:</P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="68pt" VALIGN="TOP"><COL WIDTH="337pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>Rule 1</P></TD><TD VALIGN="TOP"><P>If a pixel's center falls within the glyph outline, that pixel is turned on.</P></TD></TR><TR><TD VALIGN="TOP"><P>Rule 2</P></TD><TD VALIGN="TOP"><P>If a contour falls exactly on a pixel's center, that pixel is turned on. </P></TD></TR><TR><TD VALIGN="TOP"><P>Rule 3</P></TD><TD VALIGN="TOP"><P>If a scan line between two adjacent pixel centers (either vertical or horizontal) is intersected by both an on-Transition contour and an off-Transition contour and neither of the pixels was already turned on by rules 1 and 2, turn on the left-most pixel (horizontal scan line) or the bottom-most pixel (vertical scan line). This is "Simple" dropout control.</P></TD></TR><TR><TD VALIGN="TOP"><P>Rule 4</P></TD><TD VALIGN="TOP"><P>Apply Rule 3 only if the two contours continue to intersect other scan lines in both directions. That is, do not turn on pixels for 'stubs.' The scanline segments that form a square with the intersected scan line segment are examined to verify that they are intersected by two contours.  It is possible that these could be different contours than the ones intersecting the dropout scan line segment.  This is very unlikely but may have to be controlled with grid-fitting in some exotic glyphs.</P></TD></TR><TR><TD VALIGN="TOP"><P>Rule 5</P></TD><TD VALIGN="TOP"><P>If a scan line between two adjacent pixel centers (either vertical or horizontal) is intersected by both an on-Transition contour and an off-Transition contour and neither of the pixels was already turned on by rules 1 and 2, turn on the pixel which is closer to the midpoint between the on-Transition contour and off-Transition contour. This is "Smart" dropout control.</P></TD></TR><TR><TD VALIGN="TOP"><P>Rule 6</P></TD><TD VALIGN="TOP"><P>Apply Rule 5 only if the two contours continue to intersect other scan lines in both directions. That is, do not turn on pixels for 'stubs.'</P></TD></TR></TBODY></TABLE>
<BR></P>New fonts wishing to use the new modes of the ScanType instruction, but still wishing to work correctly on old rasterizers that don't recognize the new modes should:</P>
First execute a ScanType instruction using an old mode which will give the best approximation to the desired new mode (e.g. Simple Stubs for Smart Stubs), and then</P>
Immediately execute another ScanType instruction with the desired new mode.</P>
<H5><A NAME="sec36"></A>Set Control Value Table Cut In</H5>SCVTCI[ ] </P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="72pt" VALIGN="TOP"><COL WIDTH="365pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>Code Range </P></TD><TD VALIGN="TOP"><P>0x1D</P></TD></TR><TR><TD VALIGN="TOP"><P>Pops</P></TD><TD VALIGN="TOP"><P>n: value for cut_in (F26Dot6)</P></TD></TR><TR><TD VALIGN="TOP"><P>Pushes </P></TD><TD VALIGN="TOP"><P>–</P></TD></TR><TR><TD VALIGN="TOP"><P>Sets </P></TD><TD VALIGN="TOP"><P>control_value_cut_in</P></TD></TR><TR><TD VALIGN="TOP"><P>Affects</P></TD><TD VALIGN="TOP"><P>MIAP, MIRP</P></TD></TR></TBODY></TABLE>
<BR></P>Sets the control_value_cut_in in the Graphics State. The value n is expressed in sixty-fourths of a pixel.</P>
<P><img src="13780.gif"></P>
Increasing the value of the cut_in will increase the range of sizes for which CVT values will be used instead of the original outline value.</P>
<H5><A NAME="sec37"></A>Set Single_Width_Cut_In</H5>SSWCI[ ] </P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="72pt" VALIGN="TOP"><COL WIDTH="365pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>Code Range </P></TD><TD VALIGN="TOP"><P>0x1E</P></TD></TR><TR><TD VALIGN="TOP"><P>Pops</P></TD><TD VALIGN="TOP"><P>n: value for single_width_cut_in (F26dot6)</P></TD></TR><TR><TD VALIGN="TOP"><P>Pushes </P></TD><TD VALIGN="TOP"><P>–</P></TD></TR><TR><TD VALIGN="TOP"><P>Sets</P></TD><TD VALIGN="TOP"><P>single_width_cut_in</P></TD></TR><TR><TD VALIGN="TOP"><P>Affects</P></TD><TD VALIGN="TOP"><P>MIAP, MIRP</P></TD></TR></TBODY></TABLE>
<BR></P>Sets the single_width_cut_in in the Graphics State. The value n is expressed in sixty-fourths of a pixel.</P>
<P><img src="13781.gif"></P>
<H5><A NAME="sec38"></A>Set Single-width</H5>SSW[ ] </P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="72pt" VALIGN="TOP"><COL WIDTH="365pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>Code Range</P></TD><TD VALIGN="TOP"><P>0x1F</P></TD></TR><TR><TD VALIGN="TOP"><P>Pops</P></TD><TD VALIGN="TOP"><P>n: value for single_width_value (FUnits)</P></TD></TR><TR><TD VALIGN="TOP"><P>Pushes </P></TD><TD VALIGN="TOP"><P>–</P></TD></TR><TR><TD VALIGN="TOP"><P>Sets</P></TD><TD VALIGN="TOP"><P>single_width_value</P></TD></TR></TBODY></TABLE>
<BR></P>Sets the single_width_value in the Graphics State. The single_width_value is expressed in FUnits.</P>
<P><img src="13782.gif"></P>
<H5><A NAME="sec39"></A>Set the auto_flip Boolean to ON</H5>FLIPON[ ]</P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="72pt" VALIGN="TOP"><COL WIDTH="365pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>Code Range </P></TD><TD VALIGN="TOP"><P>0x4D</P></TD></TR><TR><TD VALIGN="TOP"><P>Pops</P></TD><TD VALIGN="TOP"><P>–</P></TD></TR><TR><TD VALIGN="TOP"><P>Pushes </P></TD><TD VALIGN="TOP"><P>–</P></TD></TR><TR><TD VALIGN="TOP"><P>Sets</P></TD><TD VALIGN="TOP"><P>auto_flip</P></TD></TR><TR><TD VALIGN="TOP"><P>Affects</P></TD><TD VALIGN="TOP"><P>MIRP</P></TD></TR></TBODY></TABLE>
<BR></P>Sets the auto_flip Boolean in the Graphics State to TRUE causing the MIRP instructions to ignore the sign of Control Value Table entries. The default auto_flip Boolean value is TRUE.</P>
<P><img src="13783.gif"></P>
<H5><A NAME="sec40"></A>Set the auto_flip Boolean to OFF</H5>FLIPOFF[ ]</P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="72pt" VALIGN="TOP"><COL WIDTH="365pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>Code Range</P></TD><TD VALIGN="TOP"><P>0x4E</P></TD></TR><TR><TD VALIGN="TOP"><P>Pops</P></TD><TD VALIGN="TOP"><P>–</P></TD></TR><TR><TD VALIGN="TOP"><P>Pushes</P></TD><TD VALIGN="TOP"><P>–</P></TD></TR><TR><TD VALIGN="TOP"><P>Sets</P></TD><TD VALIGN="TOP"><P>auto_flip</P></TD></TR><TR><TD VALIGN="TOP"><P>Affects</P></TD><TD VALIGN="TOP"><P>MIRP</P></TD></TR></TBODY></TABLE>
<BR></P>Set the auto_flip Boolean in the Graphics State to FALSE causing the MIRP instructions to use the sign of Control Value Table entries.  The default auto_flip Boolean value is TRUE. </P>
<P><img src="13784.gif"></P>
<H5><A NAME="sec41"></A>Set Angle _Weight</H5>SANGW[ ] </P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="72pt" VALIGN="TOP"><COL WIDTH="365pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>Code Range</P></TD><TD VALIGN="TOP"><P>0x7E</P></TD></TR><TR><TD VALIGN="TOP"><P>Pops</P></TD><TD VALIGN="TOP"><P>weight: value for angle_weight</P></TD></TR><TR><TD VALIGN="TOP"><P>Pushes</P></TD><TD VALIGN="TOP"><P>–</P></TD></TR><TR><TD VALIGN="TOP"><P>Sets</P></TD><TD VALIGN="TOP"><P>angle_weight</P></TD></TR></TBODY></TABLE>
<BR></P>SANGW is no longer needed because of dropped support to the AA (Adjust Angle) instruction. AA was the only instruction that used angle_weight in the global graphics state.</P>
Pops a weight value from the stack and sets the value of the angle_weight state variable accordingly.</P>
<P><img src="13785.gif"></P>
<H5><A NAME="sec42"></A>Set Delta_Base in the graphics state</H5>SDB[ ]</P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="72pt" VALIGN="TOP"><COL WIDTH="365pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>Code Range</P></TD><TD VALIGN="TOP"><P>0x5E</P></TD></TR><TR><TD VALIGN="TOP"><P>Pops</P></TD><TD VALIGN="TOP"><P>n: value for the delta_base (ULONG)</P></TD></TR><TR><TD VALIGN="TOP"><P>Pushes</P></TD><TD VALIGN="TOP"><P>–</P></TD></TR><TR><TD VALIGN="TOP"><P>Sets</P></TD><TD VALIGN="TOP"><P>delta_base</P></TD></TR><TR><TD VALIGN="TOP"><P>Affects</P></TD><TD VALIGN="TOP"><P>DELTAP1, DELTAP2, DELTAP3, DELTAC1, DELTAC2, DELTAC3</P></TD></TR></TBODY></TABLE>
<BR></P>Pops a number, n, and sets delta_base to the value n. The default for delta_base is 9.</P>
<P><img src="13786.gif"></P>
<H5><A NAME="sec43"></A>Set Delta_Shift in the graphics state</H5>SDS[ ] </P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="72pt" VALIGN="TOP"><COL WIDTH="365pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>Code Range</P></TD><TD VALIGN="TOP"><P>0x5F</P></TD></TR><TR><TD VALIGN="TOP"><P>Pops</P></TD><TD VALIGN="TOP"><P>n: value for the delta_shift (ULONG)</P></TD></TR><TR><TD VALIGN="TOP"><P>Pushes</P></TD><TD VALIGN="TOP"><P>–</P></TD></TR><TR><TD VALIGN="TOP"><P>Sets</P></TD><TD VALIGN="TOP"><P>delta_shift</P></TD></TR><TR><TD VALIGN="TOP"><P>Affects</P></TD><TD VALIGN="TOP"><P>DELTAP1, DELTAP2, DELTAP3, DELTAC1, DELTAC2, DELTAC3</P></TD></TR></TBODY></TABLE>
<BR></P>Sets delta_shift to the value n. The default for delta_shift is 3.</P>
<P><img src="13787.gif"></P></BODY></HTML>
