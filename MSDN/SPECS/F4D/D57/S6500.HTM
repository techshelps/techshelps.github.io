<HTML><HEAD><META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Anatomy of a TrueType Instruction</TITLE><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">
</OBJECT></FORM>
<H2>Anatomy of a TrueType Instruction</H2>TrueType instructions are uniquely specified by their opcodes. For convenience, this book will refer to instructions by their names. Each instruction name is a mnemonic intended to aid in remembering that instruction's function. For example, the MDAP instruction stands for Move Direct Absolute Point. Similarly, RUTG is short for Round Up To Grid. A brief description of each instruction clarifying the mnemonic marks the start of a new instruction.  </P>
One name may actually refer to several different but closely related instructions. A bracketed list of Boolean values follows each name to uniquely specify a particular variant of a given instruction. The Boolean list can be converted to a binary number and that number added to the base opcode for the instruction to obtain the opcode for any instruction variant.</P>
To obtain the opcode for any instruction, take the lower of the two opcode values given in the code range and add the unsigned binary number represented by the list of binary digits. The left most bit is the most significant. For example, given an instruction with the opcode range 0xCO–0xDF and five Boolean flags (a through e) the opcode for a given instruction base can be computed as shown: </P>
Opcode = 0xC0 + a · 2<SUP>4</SUP> + b · 2<SUP>3</SUP> + c · 2<SUP>2</SUP> + d · 2<SUP>1</SUP> + e · 2<SUP>0</SUP> </P>
If  these flags were set to 11101 the code would be computed as follows:</P>
0xC0 + 1 · 24 + 1 · 23 + 1 · 22 + 0 · 21 + 1 · 20 <BR>    = 0xC0 + 0x10 + 0x8 + 0x4 + 0x1 <BR>    = 0xC0 +  0x1D= 0xDD</P>
Instruction opcodes are part of the instruction stream, a sequence of opcodes and data. The instruction stream is not a stack. While the stream of opcodes and data on the instruction stream is gradually used up, no new data is added to the instruction stream by the execution of another instruction (i.e. there is no equivalent of a push instruction that adds data to the instruction stream). It is possible to alter the flow of control through the instruction stream using one of the jump instructions described in a later section.</P>
The instruction stream is shown as a sequence of opcodes and data. Since the instruction stream is 1-byte wide, words will be broken up into high bytes and low bytes with high bytes appearing first in the stream. For added readability, instruction names are used in illustrations instead of opcodes. An arrow will point to the next instruction awaiting execution.</P>
<P>Figure 3–1    The instruction stream with a push byte instruction (left) and a push word instruction (right)</P>
<P><img src="13726.gif"></P>
A few instructions known collectively as <I>push</I> instructions move data from the instruction stream to the interpreter stack. These instructions are unique in taking their arguments from the instruction stream. All other TrueType instructions take any data needed from the stack at the time they are executed. Any results produced by a TrueType instruction are pushed onto the interpreter stack. </P>
An instruction that expects two arguments and pushes a third would expect the two arguments to be at the top of the stack. Any result pushed by that instruction appears at the top of the stack.</P>
The listing <I>a b c </I>denotes a stack consisting of three elements with <I>a</I> being at the top of the stack, <I>b</I> being in the middle, and <I>c</I> at the bottom as shown.</P>
<P><img src="13727.gif"></P>
To easily remember the order in which stack values are handled during arithmetic or logical operations, imagine writing the stack values from left to right, starting with the bottom value. Then insert the operator between the two furthest right elements. For example, <I>subtract a,b</I> would be interpreted as (b-a):</P>
c b - a</P>
GT a,b would be interpreted as (b&gt;a):</P>
c b &gt; a</P>
The statement push <I>d</I>, <I>e</I> means push <I>d</I> then push <I>e</I> adding two elements to the stack as shown.</P>
<P><img src="13728.gif"></P>
To indicate that the top two stack elements are to be removed the statement would be pop <I>e</I>, <I>d</I>.</P>
<P><img src="13729.gif"></P>
It has already been noted that the bracketed list of binary digits that follows the instruction name uniquely identifies an instruction variant. This is done by having the bits represent a list of Boolean flags that can be set to TRUE with a value of 1 or to FALSE with a value of 0. Binary digits that follow the name can also be grouped to form a larger binary number. In such cases, the documentation specifies the meaning associated with each possible numerical combination.</P>
An instruction specification consists of the instruction name followed by its bracketed Boolean flags. Additional information describing the flags and explaining the stack interaction and any Graphics State dependencies is provided in tabular form:</P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="72pt" VALIGN="TOP"><COL WIDTH="364pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>Code Range</P></TD><TD VALIGN="TOP"><P>the range of hexadecimal codes identifying this instruction and its variants</P></TD></TR><TR><TD VALIGN="TOP"><P>Flags  </P></TD><TD VALIGN="TOP"><P>an explanation of the meaning of a bracketed binary number</P></TD></TR><TR><TD VALIGN="TOP"><P>From IS</P></TD><TD VALIGN="TOP"><P>any arguments taken from the instruction stream by push instructions</P></TD></TR><TR><TD VALIGN="TOP"><P>Pops</P></TD><TD VALIGN="TOP"><P>any arguments popped from the stack</P></TD></TR><TR><TD VALIGN="TOP"><P>Pushes</P></TD><TD VALIGN="TOP"><P>any arguments pushed onto the stack</P></TD></TR><TR><TD VALIGN="TOP"><P>Uses     </P></TD><TD VALIGN="TOP"><P>any state variables whose value this instruction depends upon</P></TD></TR><TR><TD VALIGN="TOP"><P>Sets      </P></TD><TD VALIGN="TOP"><P>any state variables set by this instruction</P></TD></TR></TBODY></TABLE>
<BR></P>Instruction descriptions include illustrations intended to clarify stack interactions, Graphics State effects, and changes to interpreter tables. </P>
In the case of instructions that move points, an illustration will be provided to clarify the direction and magnitude of the movement. In these illustrations, shades of gray will be used to indicate the sequence in which points have been moved. The darker the fill, the more recently a point has been moved.</P></BODY></HTML>
