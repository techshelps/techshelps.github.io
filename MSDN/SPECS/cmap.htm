<HTML>
<HEAD><META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">

<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Character/Glyph Index Mapping</TITLE>

<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>

<BODY bgcolor="#FFFFFF" link=#003399 vlink=#996699>


<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">


<H2>cmap - Character To Glyph Index Mapping Table</H2>
<P>
This table defines the mapping of character
codes to the glyph index values used in the font. It may contain
more than one subtable, in order to support more than one character
encoding scheme. Character codes that do not correspond to any
glyph in the font should be mapped to glyph index 0. The glyph
at this location must be a special glyph representing a missing
character.
<P>
The table header indicates the character encodings for which subtables
are present. Each subtable is in one of four possible formats
and begins with a format code indicating the format used.
<P>
The platform ID and platform-specific encoding ID are used to
specify the subtable; this means that each platform ID/platform-specific
encoding ID pair may only appear once in the cmap table. Each
subtable can specify a different character encoding. (<CITE>See the
'name' table section).</CITE> The entries must be sorted first by
platform ID and then by platform-specific encoding ID.
<P>
When building a Unicode font for Windows, the platform ID should
be 3 and the encoding ID should be 1. When building a symbol font
for Windows, the platform ID should be 3 and the encoding ID should
be 0. When building a font that will be used on the Macintosh,
the platform ID should be 1 and the encoding ID should be 0.
<P>
All Microsoft Unicode encodings (Platform ID = 3, Encoding ID
= 1) must use Format 4 for their 'cmap' subtable. Microsoft <STRONG>strongly</STRONG>
recommends using a Unicode 'cmap' for all fonts. However, some
other encodings that appear in current fonts follow:

<TABLE BGCOLOR="F0F0F0" WIDTH=460>
<THEAD>
<TR>
<TH BGCOLOR="#C0C0C0">Platform ID</TH><TH BGCOLOR="#C0C0C0">Encoding ID</TH><TH BGCOLOR="#C0C0C0">Description</TH></TR>
</THEAD><TBODY>
<TR>
<TD VALIGN=TOP>3</TD><TD VALIGN=TOP>0</TD><TD VALIGN=TOP>Symbol</TD></TR>
<TR>
<TD VALIGN=TOP>3</TD><TD VALIGN=TOP>1</TD><TD VALIGN=TOP>Unicode</TD></TR>
<TR>
<TD VALIGN=TOP>3</TD><TD VALIGN=TOP>2
</TD><TD VALIGN=TOP>ShiftJIS</TD></TR>
<TR>
<TD VALIGN=TOP>3</TD><TD VALIGN=TOP>3
</TD><TD VALIGN=TOP>Big5</TD></TR>
<TR>
<TD VALIGN=TOP>3</TD><TD VALIGN=TOP>4
</TD><TD VALIGN=TOP>PRC</TD></TR>
<TR>
<TD VALIGN=TOP>3</TD><TD VALIGN=TOP>5
</TD><TD VALIGN=TOP>Wansung</TD></TR>
<TR>
<TD VALIGN=TOP>3</TD><TD VALIGN=TOP>6
</TD><TD VALIGN=TOP>Johab</TD></TR>
</TABLE>
&nbsp;&nbsp; 
<P>
The Character To Glyph Index Mapping Table
is organized as follows:

<TABLE BGCOLOR="F0F0F0" WIDTH=460>
<THEAD>
<TR>
<TH BGCOLOR="#C0C0C0">Type</TH>
<TH BGCOLOR="#C0C0C0">Description</TH></TR>
</THEAD><TBODY>
<TR>
<TD VALIGN=TOP>USHORT</TD><TD VALIGN=TOP>Table version number (0).
</TD></TR>
<TR>
<TD VALIGN=TOP>USHORT</TD><TD VALIGN=TOP>Number of encoding tables, <CITE>n.</CITE></TD></TR>
</TABLE>
&nbsp;&nbsp;

<P>
This is followed by an entry for each of the 
<CITE> n </CITE>encoding table specifying the particular encoding, and
the offset to the actual subtable:

<TABLE BGCOLOR="F0F0F0" WIDTH=460>
<THEAD>
<TR>
<TH BGCOLOR="#C0C0C0">Type</TH><TH BGCOLOR="#C0C0C0">Description</TH></TR>
</THEAD><TBODY>
<TR>
<TD VALIGN=TOP>USHORT</TD><TD VALIGN=TOP>Platform ID.</TD></TR>
<TR>
<TD VALIGN=TOP>USHORT</TD><TD VALIGN=TOP>Platform-specific encoding ID.</TD></TR>
<TR>
<TD VALIGN=TOP>ULONG</TD><TD VALIGN=TOP>Byte offset from beginning of table to the subtable for this encoding.</TD></TR>
</TABLE>
&nbsp;&nbsp;

<H4>Format 0: Byte encoding table</H4>
<P>
This is the Apple standard character to glyph index mapping table.

<TABLE BGCOLOR="F0F0F0" WIDTH=460>
<THEAD>
<TR>
<TH BGCOLOR="#C0C0C0">Type</TH><TH BGCOLOR="#C0C0C0">Name</TH><TH BGCOLOR="#C0C0C0">Description</TH></TR>
</THEAD><TBODY>
<TR>
<TD VALIGN=TOP>USHORT</TD><TD VALIGN=TOP>format</TD><TD VALIGN=TOP>Format number is set to 0. </TD></TR>
<TR>
<TD VALIGN=TOP>USHORT</TD><TD VALIGN=TOP>length</TD><TD VALIGN=TOP>This is the length in bytes of the subtable.</TD></TR>
<TR>
<TD VALIGN=TOP>USHORT</TD><TD VALIGN=TOP>version</TD>
<TD VALIGN=TOP>Version number (starts at 0).</TD></TR>
<TR>
<TD VALIGN=TOP>BYTE</TD><TD VALIGN=TOP>glyphIdArray[256]</TD>
<TD VALIGN=TOP>An array that maps character codes to glyph index values.</TD></TR>
</TABLE>
&nbsp;&nbsp;

<P>
This is a simple 1 to 1 mapping of character
codes to glyph indices. The glyph set is limited to 256. Note
that if this format is used to index into a larger glyph set,
only the first 256 glyphs will be accessible.

 <P><BR><H4>Format 2: High-byte mapping through
table</H4>
<P>
This subtable is useful for the national character
code standards used for Japanese, Chinese, and Korean characters.
These code standards use a mixed 8/16-bit encoding, in which certain
byte values signal the first byte of a 2-byte character (but these
values are also legal as the second byte of a 2-byte character).
 Character codes are always 1-byte. The glyph set is limited to
256.
<P>
In addition, even for the 2-byte characters, the mapping of character
codes to glyph index values depends heavily on the first byte.
Consequently, the table begins with an array that maps the first
byte to a 4-word subHeader. For 2-byte character codes, the subHeader
is used to map the second byte's value through a subArray, as
described below. When processing mixed 8/16-bit text, subHeader
0 is special: it is used for single-byte character codes. When
subHeader zero is used, a second byte is not needed; the single
byte value is mapped through the subArray.

<TABLE BGCOLOR="F0F0F0" WIDTH=460>
<THEAD>
<TR>
<TH BGCOLOR="#C0C0C0">Type</TH><TH BGCOLOR="#C0C0C0">Name</TH>
<TH BGCOLOR="#C0C0C0">Description</TH></TR>
</THEAD><TBODY>
<TR>
<TD VALIGN=TOP>USHORT</TD><TD VALIGN=TOP>format</TD>
<TD VALIGN=TOP>Format number is set to 2.</TD></TR>
<TR>
<TD VALIGN=TOP>USHORT</TD><TD VALIGN=TOP>length</TD>
<TD VALIGN=TOP>Length in bytes.</TD></TR>
<TR>
<TD VALIGN=TOP>USHORT</TD><TD VALIGN=TOP>version</TD>
<TD VALIGN=TOP>Version number (starts at 0)</TD></TR>
<TR>
<TD VALIGN=TOP>USHORT</TD><TD VALIGN=TOP>subHeaderKeys[256]</TD>
<TD VALIGN=TOP>Array that maps high bytes to subHeaders: value is subHeader index * 8.</TD></TR>
<TR>
<TD VALIGN=TOP NOWRAP=NOWRAP>4 words struct</TD>
<TD VALIGN=TOP>subHeaders[ ]</TD><TD VALIGN=CENTER>Variable-length array of subHeader structures.</TD></TR>
<TR>
<TD VALIGN=TOP NOWRAP=NOWRAP>4 words-struct</TD>
<TD VALIGN=TOP>subHeaders[ ]</TD><TD VALIGN=TOP>&nbsp;</TD></TR>
<TR>
<TD VALIGN=TOP>USHORT</TD><TD VALIGN=TOP>glyphIndexArray[ ]</TD>
<TD VALIGN=TOP>Variable-length array containing subarrays used for mapping the low byte of 2-byte characters.</TD></TR>
</TABLE>
&nbsp;&nbsp;
<P>
A subHeader is structured as follows:

<TABLE BGCOLOR="F0F0F0" WIDTH=460>
<THEAD>
<TR>
<TH BGCOLOR="#C0C0C0">Type</TH>
<TH BGCOLOR="#C0C0C0">Name</TH><TH BGCOLOR="#C0C0C0">Description</TH></TR>
</THEAD><TBODY>
<TR>
<TD VALIGN=TOP>USHORT</TD><TD VALIGN=TOP>firstCode</TD>
<TD VALIGN=TOP>First valid low byte for this subHeader.</TD></TR>
<TR>
<TD VALIGN=TOP>USHORT</TD><TD VALIGN=TOP>entryCount</TD>
<TD VALIGN=TOP>Number of valid low bytes for this subHeader. </TD></TR>
<TR>
<TD VALIGN=TOP>SHORT</TD><TD VALIGN=TOP>idDelta</TD>
<TD VALIGN=TOP>See text below.</TD></TR>
<TR>
<TD VALIGN=TOP>USHORT</TD><TD VALIGN=TOP>idRangeOffset</TD>
<TD VALIGN=TOP>See text below.</TD></TR>
</TABLE>
&nbsp;&nbsp;
<P>
The firstCode and entryCount values specify
a subrange that begins at firstCode and has a length equal to
the value of entryCount. This subrange stays within the 0-255
range of the byte being mapped. Bytes outside of this subrange
are mapped to glyph index 0 (missing glyph).The offset of the
byte within this subrange is then used as index into a corresponding
subarray of glyphIndexArray. This subarray is also of length entryCount.
The value of the idRangeOffset is the number of bytes past the
actual location of the idRangeOffset word where the glyphIndexArray
element corresponding to firstCode appears.
<P>
Finally, if the value obtained from the subarray is not 0 (which
indicates the missing glyph), you should add idDelta to it in
order to get the glyphIndex. The value idDelta permits the same
subarray to be used for several different subheaders. The idDelta
arithmetic is modulo 65536.
 
<P><BR><H4>Format 4: Segment mapping to delta
values</H4>
<P>
This is the Microsoft standard character to
glyph index mapping table. 
<P>
This format is used when the character codes for the characters
represented by a font fall into several contiguous ranges, possibly
with holes in some or all of the ranges (that is, some of the
codes in a range may not have a representation in the font). The
format-dependent data is divided into three parts, which must
occur in the following order: 
<OL>
<LI>A four-word header gives parameters
for an optimized search of the segment list; 
<LI>Four parallel arrays describe the segments (one segment
for each contiguous range of codes); 
<LI>A variable-length array of glyph IDs (unsigned words).
</OL>

<TABLE BGCOLOR="F0F0F0" WIDTH=460>
<THEAD>
<TR>
<TH BGCOLOR="#C0C0C0">Type</TH>
<TH BGCOLOR="#C0C0C0">Name</TH><TH BGCOLOR="#C0C0C0">Description</TH></TR>
</THEAD><TBODY>
<TR>
<TD VALIGN=TOP>USHORT</TD><TD VALIGN=TOP>format</TD>
<TD VALIGN=TOP>Format number is set to 4. </TD></TR>
<TR>
<TD VALIGN=TOP>USHORT</TD><TD VALIGN=TOP>length</TD>
<TD VALIGN=TOP>Length in bytes. </TD></TR>
<TR>
<TD VALIGN=TOP>USHORT</TD><TD VALIGN=TOP>version</TD>
<TD VALIGN=TOP>Version number (starts at 0).</TD></TR>
<TR>
<TD VALIGN=TOP>USHORT</TD><TD VALIGN=TOP>segCountX2 </TD>
<TD VALIGN=TOP>2 x segCount.</TD></TR>
<TR>
<TD VALIGN=TOP>USHORT</TD><TD VALIGN=TOP>searchRange </TD>
<TD VALIGN=TOP>2 x (2**floor(log2(segCount)))</TD></TR>
<TR>
<TD VALIGN=TOP>USHORT</TD><TD VALIGN=TOP>entrySelector </TD>
<TD VALIGN=TOP>log2(searchRange/2)</TD></TR>
<TR>
<TD VALIGN=TOP>USHORT</TD><TD VALIGN=TOP>rangeShift </TD>
<TD VALIGN=TOP>2 x segCount - searchRange</TD></TR>
<TR>
<TD VALIGN=TOP>USHORT</TD><TD VALIGN=TOP>endCount[segCount]</TD>
<TD VALIGN=TOP>End characterCode for each segment,
<BR>
last =0xFFFF.</TD></TR>
<TR>
<TD VALIGN=TOP>USHORT</TD><TD VALIGN=TOP>reservedPad</TD>
<TD VALIGN=TOP>Set to 0.</TD></TR>
<TR>
<TD VALIGN=TOP>USHORT</TD><TD VALIGN=TOP>startCount[segCount]</TD>
<TD VALIGN=TOP>Start character code for each segment.</TD></TR>
<TR>
<TD VALIGN=TOP>SHORT</TD><TD VALIGN=TOP>idDelta[segCount]</TD>
<TD VALIGN=TOP>Delta for all character codes in segment.</TD></TR>
<TR>
<TD VALIGN=TOP>USHORT</TD><TD VALIGN=TOP>idRangeOffset[segCount]</TD>
<TD VALIGN=TOP>Offsets into glyphIdArray or 0</TD></TR>
<TR>
<TD VALIGN=TOP>USHORT</TD><TD VALIGN=TOP>glyphIdArray[ ]</TD>
<TD VALIGN=TOP>Glyph index array (arbitrary length)</TD></TR>
</TABLE>
&nbsp;&nbsp;
<P>
The number of segments is specified by segCount,
which is not explicitly in the header; however, all of the header
parameters are derived from it. The searchRange value is twice
the largest power of 2 that is less than or equal to  segCount.
For example, if segCount=39, we have the following:

&nbsp;<TABLE WIDTH=460>
<TR>
<TD>segCountX2</TD><TD>78</TD></TR>
<TR>
<TD>searchRange</TD><TD>64</TD><TD>(2 * largest power of 2 &lt;=39)</TD></TR> 
<TR>
<TD>entrySelector</TD><TD>5</TD><TD>log<SUB>2</SUB> (32)</TD></TR>
<TR>
<TD>rangeShift</TD><TD>14</TD><TD>2 x 39 - 64</TD></TR>
</TABLE>&nbsp;&nbsp;

<P>
Each segment is described by a startCode and
endCode, along with an idDelta and an idRangeOffset, which are
used for mapping the character codes in the segment. The segments
are sorted in order of increasing endCode values, and the segment
values are specified in four parallel arrays. You search for the
first endCode that is greater than or equal to the character code
you want to map. If the corresponding startCode is less than or
equal to the character code, then you use the corresponding idDelta
and idRangeOffset to map the character code to a glyph index (otherwise,
the missingGlyph is returned). For the search to terminate, the
final endCode value must be 0xFFFF. This segment need not contain
any valid mappings. (It can just map the single character code
0xFFFF to missingGlyph). However, the segment must be present.
<P>
If the idRangeOffset value for the segment is not 0, the mapping
of character codes relies on glyphIdArray. The character code
offset from startCode is added to the idRangeOffset value. This
sum is used as an offset from the current location within idRangeOffset
itself to index out the correct glyphIdArray value. This obscure
indexing trick works because glyphIdArray immediately follows
idRangeOffset in the font file. The C expression that yields the
glyph index is:
<pre><code>*(idRangeOffset[i]/2 + (c - startCount[i]) + &amp;idRangeOffset[i])</code></pre>
<P>
The value <CITE>c</CITE>  is the character code
in question, and <CITE>i</CITE>  is the segment index in which <CITE>c</CITE>
 appears. If the value obtained from the indexing operation is
not 0 (which indicates missingGlyph), idDelta[i] is added to it
to get the glyph index. The idDelta arithmetic is modulo 65536.
<P>
If the idRangeOffset is 0, the idDelta value is added directly
to the character code offset (i.e. <code>idDelta[i]
+ c</code>) to get the corresponding
glyph index. Again, the idDelta arithmetic is modulo 65536.
<P>
As an example, the variant part of the table to map characters
10-20, 30-90, and 480-153 onto a contiguous range of glyph indices
may look like this:
<P>
<TABLE WIDTH=460>
<tr>
<TD>segCountX2:</TD><TD>8</TD></TR>
<TR>
<TD>searchRange:</TD><TD>8</TD></TR>
<TR>
<TD>entrySelector:</TD><TD>4</TD></TR>
<TR>
<TD>rangeShift:</TD><TD>0</TD></TR>
<TR>
<TD>endCode:</TD><TD>20</TD><TD>90</TD><TD>153</TD><TD>0Xffff</TD></TR>
<TR>
<TD>reservedPad:</TD><TD>0</TD></TR>
<TR> 
<TD>startCode:</TD><TD>10</TD><TD>30</TD><TD>480</TD><TD>0Xffff</TD></TR>
<TR>
<TD>idDelta:</TD><TD>-9</TD><TD>-18</TD><TD>-27</TD><TD>1</TD></TR>
<TR>
<TD>idRangeOffset:</TD><TD>0</TD><TD>0</TD><TD>0</TD><TD>0</TD></TR>
</TABLE>&nbsp;
<P>
This table performs the following mappings:<BR>
<P>10 -&gt; 10 - 9 = 1<BR>
20 -&gt; 20 - 9 = 11<BR>
30 -&gt; 30 - 18 = 12<BR>
90 -&gt; 90 - 18 = 72<BR>
...and so on.

<P>
Note that the delta values could be reworked
so as to reorder the segments. 
<P><BR>
<P>


<BR>&nbsp;<BR><FONT SIZE=5>Format 6: Trimmed table mapping</FONT>
<TABLE BGCOLOR="#F0F0F0" WIDTH=460>
<THEAD>
<TR>
<TH BGCOLOR="#C0C0C0">Type</TH>
<TH BGCOLOR="#C0C0C0">Name</TH>
<TH BGCOLOR="#C0C0C0">Description</TH></TR>
</THEAD><TBODY>
<TR>
<TD VALIGN=TOP>USHORT</TD><TD VALIGN=TOP>format</TD>
<TD VALIGN=TOP>Format number is set to 6.</TD></TR>
<TR>
<TD VALIGN=TOP>USHORT</TD><TD VALIGN=TOP>length</TD>
<TD VALIGN=TOP>Length in bytes. </TD></TR>
<TR>
<TD VALIGN=TOP>USHORT</TD><TD VALIGN=TOP>version</TD>
<TD VALIGN=TOP>Version number (starts at 0)</TD></TR>
<TR>
<TD VALIGN=TOP>USHORT</TD><TD VALIGN=TOP>firstCode</TD>
<TD VALIGN=TOP>First character code of subrange.</TD></TR>
<TR>
<TD VALIGN=TOP>USHORT</TD><TD VALIGN=TOP>entryCount</TD>
<TD VALIGN=TOP>Number of character codes in subrange.</TD></TR>
<TR>
<TD VALIGN=TOP>USHORT</TD><TD VALIGN=TOP>glyphIdArray [entryCount]</TD>
<TD VALIGN=TOP>Array of glyph index values for character codes in the range.</TD></TR>
</TABLE>&nbsp;

<P>
The firstCode and entryCount values specify
a subrange (beginning at firstCode,length = entryCount) within
the range of possible character codes. Codes outside of this subrange
are mapped to glyph index 0. The offset of the code (from the
first code) within this subrange is used as index to the glyphIdArray,
which provides the glyph index value. 

</BODY></HTML>
