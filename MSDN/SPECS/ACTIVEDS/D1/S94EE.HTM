<HTML><HEAD><META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>3.1.2    Custom COM Interfaces</TITLE><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">
</OBJECT></FORM>
<H3>3.1.2    Custom COM Interfaces</H3><P>A "custom" COM interface is one defined by a developer,  as opposed to "standard" COM interfaces that are defined by COM.  A custom COM interface is the recommended way of exposing functionality.  In order to support legacy controllers that use IDispatch as the primary automation mechanism, custom defined interfaces should be derived from IDispatch.  By convention, interfaces of this type are called <B>dual interfaces</B>.  Using dual interfaces allows legacy controllers to handle custom interfaces as if they were IDispatch interfaces.</P>
<P>A custom COM interface is used to access the properties and methods on an object.  A read-only property maps to an interface entry of the form get_&lt;PropertyName&gt;.  A read/write property maps to two interface entries of the form get_&lt;PropertyName&gt; and put_&lt;PropertyName&gt;.  All methods on an interface return an HRESULT value to indicate success or failure.  The HRESULT type is discussed in the COM specification.</P>
<P>To retain compatibility with Automation–enabled controllers, all parameters and return types should be within the subset of those defined by the Automation VARIANT data type.  For more information consult the COM documentation.  A list for informational purposes appears in Appendix A, "COM Automation Data Types."  An object can also expose interfaces that use data types other than those in the VARIANT subset; however, those interfaces will not be callable from Automation controllers like Visual Basic.  Since all Active Directory custom interfaces are derived from IDispatch, they can be used as IDispatch interface pointers.</P>
<P>A custom COM interface definition in IDL format would look like this example:</P>
<P></P>
<P>[ object, uuid(IID_IADsXYZ), oleautomation, dual ]</P>
<P>interface IADsXYZ: IDispatch</P>
<P>{</P>
<P>// Read-only properties.</P>
<P>[propget]</P>
<P>HRESULT AReadOnlyProp ([out, retval]BSTR *pbstrAReadOnlyProp);</P>
<P></P>
<P>// Read/write properties.</P>
<P>[propget]</P>
<P>HRESULT AReadWriteProp ([out, retval]long *plAReadWriteProp);</P>
<P>[propput]</P>
<P>HRESULT AReadWriteProp ([in]long lAReadWriteProp);</P>
<P></P>
<P>// Methods.</P>
<P>HRESULT AMethod ([in]DATE dateInParameter,</P>
<P>[out, retval]BSTR *pbstrReturnValue);</P>
<P>};</P>
<P>The following table describes each member of the interface.  The Active Directory syntax of each member is also noted.  Syntax definitions can be found in Chapter 6, "Object Extensions."</P>

<TABLE COLS="3" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="104pt" VALIGN="TOP"><COL WIDTH="72pt" VALIGN="TOP"><COL WIDTH="266pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B>Method</B></P></TD><TD VALIGN="TOP"><P>Syntax</P></TD><TD VALIGN="TOP"><P>Remark</P></TD></TR><TR><TD VALIGN="TOP"><P>AReadOnlyProp</P></TD><TD VALIGN="TOP"><P>EmailAddress</P></TD><TD VALIGN="TOP"><P>Gets the value of a read-only property of syntax EmailAddress.</P></TD></TR><TR><TD VALIGN="TOP"><P>AReadWriteProp</P></TD><TD VALIGN="TOP"><P>Interval</P></TD><TD VALIGN="TOP"><P>Gets and sets the value of a read-write property of syntax Interval.</P></TD></TR><TR><TD VALIGN="TOP"><P>Amethod</P></TD><TD VALIGN="TOP"><P>Method</P></TD><TD VALIGN="TOP"><P>This is a method that takes a date and returns a string.</P></TD></TR></TBODY></TABLE>
<BR></P></BODY></HTML>
