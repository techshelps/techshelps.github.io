<HTML><HEAD><META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>4.3.1    IADsContainer</TITLE><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">
</OBJECT></FORM>
<H3>4.3.1    IADsContainer</H3><P>IADsContainer is a COM interface defined by Active Directory.  It provides the basic functionality required by all directory service container objects:</P>
<P><B><UL><LI>Object Enumeration.</B>  Simple enumeration is supported by containers.  This includes counting the number of objects in a container, filtering by type, and retrieving objects.</LI></UL></P>
<P><B><UL><LI>Object Life Cycle.</B>  A container is a place where directory service objects are created and destroyed.  The methods Create(), Delete(), MoveHere() and CopyHere() are used for this purpose.</LI></UL></P>
<P>Note that GetInfo and SetInfo <B>do not </B>affect the objects stored in a container.   Calling GetInfo and SetInfo affects the properties of the container object,  not the objects stored in the container.    </P>
<P>The IADsContainer interface definition is as follows:</P>
<P><pre><code>[ object, uuid(IID_IADsContainer), oleautomation, dual ]</P>
<P>interface IADsContainer: IDispatch</P>
<P>{</P>
<P>// Read-only properties.</P>
<P>[propget]</P>
<P>HRESULT Count ([out, retval]long *plCount);</P>
<P>[propget, restricted, id(-4)]</P>
<P>HRESULT _NewEnum ([out, retval]Iunknown *ppEnumerator);</P>
<P></P>
<P>// Read/write properties.</P>
<P>[propget]</P>
<P>HRESULT Filter ([out, retval]VARIANT *pvFilter);</P>
<P>[propput]</P>
<P>HRESULT Filter ([in]VARIANT vFilter);</P>
<P>[propget]</P>
<P>HRESULT Hints ([out, retval]VARIANT *pvHints);</P>
<P>[propput]</P>
<P>HRESULT Hints ([in]VARIANT vHints);</P>
<P></P>
<P>// Methods.</P>
<P>HRESULT GetObject ([in]BSTR bstrClass,</P>
<P>[in]BSTR bstrRelativeName,</P>
<P>[out, retval]IADs **ppNamedObject );</P>
<P>HRESULT Create ([in]BSTR bstrClass,</P>
<P>            [in]BSTR bstrRelativeName,</P>
<P>            [out, retval]IADs **ppNewObject );</P>
<P>HRESULT Delete ([in]bstrClass,</P>
<P>[in]BSTR bstrRelativeName);</P>
<P>HRESULT CopyHere ([in]BSTR bstrSourceObject,</P>
<P>            [in]BSTR bstrNewName,</P>
<P>            [out, retval]IADs **ppNewObject);</P>
<P>HRESULT MoveHere ([in]BSTR bstrSourceObject,</P>
<P>            [in]BSTR bstrNewName,</P>
<P>            [out, retval]IADs **ppNewObject);</P>
<P>};</P>
<P></code></pre></P>

<TABLE COLS="2" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="90pt" VALIGN="TOP"><COL WIDTH="346pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B>Method</B></P></TD><TD VALIGN="TOP"><P><B>Description</B></P></TD></TR><TR><TD VALIGN="TOP"><P>Filter</P></TD><TD VALIGN="TOP"><P>Gets or sets the filter on the object classes that will be returned in a given enumeration.  The client can also give hints to the provider about which properties of the objects it will use after the enumeration.  If Filter is not set or is set to empty, then all objects of all classes will be returned by the enumerator.  Otherwise, each array entry should be of the following format:</P>
<P>&lt;FilterEntry&gt;::=&lt;ClassName&gt;</P>
<P>    |"Provider Specific String"</P>
<P></P>
<P>&lt;ClassName&gt;is a BSTR value that represents a class,.</P></TD></TR><TR><TD VALIGN="TOP"><P>Hints</P></TD><TD VALIGN="TOP"><P>The vHints parameter allows the client to indicate which properties should be loaded, so the provider can attempt to optimize network access.  If no hints are specified, the VARIANT vHints is marked as empty, and the provider is expected to provide as much smart network access as possible.  Otherwise, each entry in the array should have the following format:</P>
<P>&lt;HintEntry&gt;::=&lt;PropName&gt;</P>
<P>&lt;PropName&gt; is a BSTR value that represents a property found in the schema.  </P></TD></TR><TR><TD VALIGN="TOP"><P>Count</P></TD><TD VALIGN="TOP"><P>Gets the number of Active Directory objects within the container.  If there is a filter set, only a count of the classes named in the filter will be returned.</P></TD></TR><TR><TD VALIGN="TOP"><P>_NewEnum</P></TD><TD VALIGN="TOP"><P>Gets an enumerator dependent object.  If there is a filter set, only the classes named in the filter will be enumerated.  Enumeration can be performed using the IEnumVARIANT interface.  See section 0, "5.3    Enumerator Objects" for details.</P>
<P>Enumeration returns IADs interface pointers.</P>
<P></P></TD></TR><TR><TD VALIGN="TOP"><P>GetObject</P></TD><TD VALIGN="TOP"><P>Returns the IADs interface of the item in the container identified by the object's class and relative name (this is the value of the object's IADs::Name property).  If the class name is not provided the provider will return the first item found with the specified name in the current container.</P></TD></TR><TR><TD VALIGN="TOP"><P>Create</P></TD><TD VALIGN="TOP"><P>Creates an object of the class specified by bstrClass, of name bstrRelativeName, and returns a pointer to the newly created object.  The object is not actually created within the directory service until the IADs::SetInfo method is executed on the newly created object.  This is to allow setting of mandatory properties.</P>
<P>The bstrClass value should take the following syntax:</P>
<P>&lt;Class&gt;::=&lt;ClassName&gt;</P>
<P></P>
<P></P>
<P>&lt;ClassName&gt;  is a BSTR value that represents the classes found in the schema. The schema can be browsed using the schema management objects.  See "Schema Management Active Directory objects" in Chapter 6, "Object Extensions," for more details.</P></TD></TR><TR><TD VALIGN="TOP"><P>Delete</P></TD><TD VALIGN="TOP"><P>Deletes the object identified by the provided class and relative name.</P></TD></TR><TR><TD VALIGN="TOP"><P>CopyHere</P></TD><TD VALIGN="TOP"><P>Creates a new object in this container identical to the specified object and returns a pointer to the new object. The destination container must be in the same namespace as the source. Copying objects across namespaces is not permitted. NewName is an optional parameter that, if present, contains the name inside the container.</P></TD></TR><TR><TD VALIGN="TOP"><P>MoveHere</P></TD><TD VALIGN="TOP"><P>Moves the specified object to this container and returns a pointer to the new object. The destination container must be in the same namespace as the source. Moving objects across namespaces is not permitted. NewName is an optional parameter that, if present, contains the name inside the container.</P></TD></TR></TBODY></TABLE>
<BR></P><H4><A NAME="sec0"></A>4.3.1.1    Enumeration</H4><P>Given any interface on any leaf or container Active Directory object, it is possible to perform complete tree navigation and object enumeration.</P>
<P>To navigate up the tree, call QueryInterface for the IADs interface and use the Parent property to find the parent container of the object.  The only container that does not have a parent is the namespaces container.</P>
<P>To navigate down the tree, call QueryInterface for the IADsContainer interface.  If the interface is supported by the object, it is a container.  Use the enumeration methods to expand the tree further.  If the interface is not supported by the object, then it is a leaf, and the tree goes no deeper from that point.</P>
<P><B>Example 1:  Navigating Down a Tree (Visual Basic)</B></P>
<P><pre><code>' This example takes any Active Directory object and attempts</P>
<P>' to navigate down the tree. If the object is not a</P>
<P>' container, then the routine ends.</P>
<P>Dim MyObject as IADs</P>
<P>Dim Child as IADs</P>
<P>Dim Container as IADsContainer</P>
<P></P>
<P>' Setup error handling.</P>
<P>On Error Resume Next</P>
<P></P>
<P>' Bind to a known component.</P>
<P>Set MyObject = GetObject("WinNT://MSFT/Users")</P>
<P></P>
<P>' Ask for the IADsContainer interface.</P>
<P>Set Container = MyObject</P>
<P></P>
<P>' If no error occurs, further navigation is possible.</P>
<P>If Err = 0 Then</P>
<P>    For Each Child in Container</P>
<P>        Debug.Print Child.Name</P>
<P>    Next Child</P>
<P>EndIf</P>
<P></code></pre></P>
<P><B>Example 1:  Navigating Down a Tree (C/C++)</B></P>
<P><pre><code>//</P>
<P>// This example takes any Active Directory object and attempts</P>
<P>// to navigate down the tree. If the object is not a </P>
<P>// container, then the routine ends.</P>
<P>//</P>
<P>IADs         *pMyObject;</P>
<P>IADs         *pChild;</P>
<P>IADsContainer    *pContainer;</P>
<P>IEnumVARIANT    *pEnum;</P>
<P>HRESULT        hr;</P>
<P>BSTR        bstrName;</P>
<P></P>
<P>//</P>
<P>// Bind to a known component.</P>
<P>//</P>
<P>ADsGetObject(TEXT("WinNT://MSFT/Users"),</P>
<P>IID_IADs,</P>
<P>(void**)&amp;pMyObject);</P>
<P></P>
<P>//</P>
<P>// Ask for the IADsContainer interface.</P>
<P>//</P>
<P>hr = pMyObject-&gt;QueryInterface(IID_IADsContainer, &amp;pContainer);</P>
<P></P>
<P>//</P>
<P>// If no error occurs, further navigation is possible.</P>
<P>//</P>
<P>if (SUCCEEDED(hr))</P>
<P>{</P>
<P>//</P>
<P>// Get an enumerator.  ADsBuildEnumerator is a helper function</P>
<P>// supplied by Active Directory - see Appendix B for more details.</P>
<P>//</P>
<P>ADsBuildEnumerator(pContainer, &amp;pEnum);</P>
<P></P>
<P>//</P>
<P>// Enumerate through all the children of the container.</P>
<P>// ADsEnumerateNext is a helper function supplied by Active Directory.</P>
<P>// See Appendix B for more details.</P>
<P>//</P>
<P>do</P>
<P>{</P>
<P>hr = ADsEnumerateNext(pEnum,</P>
<P>    1,</P>
<P>    (void**)&amp;pChild,</P>
<P>    NULL);</P>
<P>if (SUCCEEDED(hr)</P>
<P>{</P>
<P>pChild-&gt;get_Name(&amp;bstrName);</P>
<P>printf("%s\n", bstrName);</P>
<P></P>
<P>SysFreeString(bstrName);</P>
<P>pChild-&gt;Release();</P>
<P></P>
<P>} // if</P>
<P></P>
<P>} while (SUCCEEDED(hr)); // do</P>
<P></P>
<P>//</P>
<P>        // Cleanup.</P>
<P>        //</P>
<P>        pEnum-&gt;Release();</P>
<P>        pContainer-&gt;Release();</P>
<P>    </P>
<P>} // if</P>
<P></P>
<P>//</P>
<P>// Cleanup.</P>
<P>//</P>
<P>pMyObject-&gt;Release();</P>
<P></code></pre></P>
<H4><A NAME="sec1"></A>4.3.1.2    Life Cycle</H4><P><B>Object creation</B> is used to create new objects in a container.  Object creation in Active Directory takes the following steps:</P>
<P><UL>1.  A client calls IADsContainer::Create() to obtain an Active Directory object for the new DS object.  This signals the beginning of the create operation.</UL></P>
<P><UL>2.  The client fills in the mandatory properties and any desired optional properties on the object.</UL></P>
<P>The client calls IADs::SetInfo() to persist the new object in the underlying namespace.</P>
<P>When the client calls SetInfo, the provider attempts to create the actual object in the namespace, and write the property values.</P>
<P>The following example demonstrates creating a user object.</P>
<P><B>Example 1:  Creating a User Object (Visual Basic)</B></P>
<P><pre><code>Dim Container as IADsContainer</P>
<P>Dim NewUser as IADsUser</P>
<P></P>
<P>' Bind to the known container.</P>
<P>Set Container = GetObject("WinNT://Mydomain")</P>
<P></P>
<P>' Create the new wrapper.</P>
<P>Set NewUser = Container.Create("user", "Jane")</P>
<P>' Write it back to the DS</P>
<P>NewUser.SetInfo</P>
<P></P>
<P>' Set Jane's password.</P>
<P>NewUser.SetPassword("Argus")</P>
<P></code></pre></P>
<P><B>Example 1:  Creating a User Object (C/C++)</B></P>
<P><pre><code>IADsContainer    *pContainer;</P>
<P>IADs        *pNewObject;</P>
<P>IADsUser        *pUser;</P>
<P></P>
<P>//</P>
<P>// Bind to the known container.</P>
<P>//</P>
<P>ADsGetObject(TEXT("WinNT://Mydomain"),</P>
<P>IID_IADsContainer,</P>
<P>(void**)&amp;pContainer);</P>
<P></P>
<P>//</P>
<P>// Create the new wrapper.</P>
<P>//</P>
<P>pContainer-&gt;Create(TEXT("user"),</P>
<P>TEXT("Jane"),</P>
<P>&amp;pNewObject);</P>
<P></P>
<P>//</P>
<P>// Get the IADsUser interface from the wrapper.</P>
<P>//</P>
<P>pNewObject-&gt;QueryInterface(IID_IADsUser, &amp;pUser);</P>
<P></P>
<P>//</P>
<P>// Write it back to the DS.</P>
<P>//</P>
<P>pUser-&gt;SetInfo();</P>
<P>//</P>
<P>// Set Jane's password.</P>
<P>//</P>
<P>pUser -&gt;SetPassword(TEXT("Argus"));</P>
<P></P>
<P></P>
<P>//</P>
<P>// Cleanup.</P>
<P>//</P>
<P>pContainer-&gt;Release();</P>
<P>pNewObject-&gt;Release();</P>
<P>pUser-&gt;Release();</P>
<P></code></pre></P>
<P><B>Object deletion</B> is used to remove objects from a directory service.  To delete an object, it's relative path string is passed to the Delete function.   This is the value contained in the Name property on the IADs interface for the object.</P>
<P><B>Important note on deletion:  </B>when an object is deleted,  it is removed from the underlying namespace immediately.  Any interface pointers held by the application for the deleted object are still valid,  because the interface pointers refer to Active Directory objects in memory.  SetInfo and GetInfo calls using interface pointers for an object has been deleted will return an error.  Applications should release any interface pointers for an object when the object is deleted.  This is shown below in Example 2. </P>
<P>The following code deletes the user that was created in example 1.  It also demonstrates how to get the parent container of an object.</P>
<P><B>Example 2:  Deleting a User Object (Visual Basic)</B></P>
<P><pre><code>Dim Container as IADsContainer</P>
<P>Dim User as IADsUser</P>
<P>Dim UserPath as String</P>
<P></P>
<P>' Bind to the known object.  In this case, we happen to know</P>
<P>' the explicit path, but typically the object will be discovered</P>
<P>' using query or enumeration.</P>
<P>Set User = GetObject("WinNT://MSFT/Users/Jane")</P>
<P></P>
<P>' Get the container of the user object.</P>
<P>Set Container = GetObject(User.Parent)</P>
<P></P>
<P></P>
<P>' Delete the user.</P>
<P>Call Container.Delete("user",User.name)</P>
<P></P>
<P>' Release the user object.  Note that we deleted</P>
<P>' the underlying DS object, so we should not hang on to the user</P>
<P>' component.</P>
<P>Set User = Nothing</P>
<P></code></pre></P>
<P><B>Example 2:  Deleting a User Object (C/C++)</B></P>
<P><pre><code>IADsContainer    *pContainer;</P>
<P>BSTR        bstrContainerPath;</P>
<P>IADsUser        *pUser;</P>
<P>BSTR        bstrUserName;</P>
<P></P>
<P>//</P>
<P>// Bind to the known object.  In this case, we happen to know</P>
<P>// the explicit path, but typically the object will be discovered</P>
<P>// using query or enumeration.</P>
<P>//</P>
<P>ADsGetObject(TEXT("WinNT://MSFT/Users/Jane"),</P>
<P>IID_IADsUser,</P>
<P>(void**)&amp;pUser);</P>
<P></P>
<P>//</P>
<P>// Get the container object path.</P>
<P>//</P>
<P>pUser-&gt;get_Parent(&amp;bstrContainerPath);</P>
<P></P>
<P>//</P>
<P>// Get the container object.</P>
<P>//</P>
<P>ADsGetObject(bstrContainerPath,</P>
<P>IID_IADsContainer,</P>
<P>(void**)&amp;pContainer);</P>
<P></P>
<P>//</P>
<P>// Get the user object's name.  (This step is unneccesary in</P>
<P>// this example since we already know the name, but is included to</P>
<P>// indicate that we either need to know the name, or have a ptr </P>
<P>// to the object).</P>
<P>//</P>
<P>pUser-&gt;get_Name(&amp;bstrUserName);</P>
<P></P>
<P>//</P>
<P>// Release the user object.  Note that we are about to delete</P>
<P>// the underlying DS object, so we should not hang on to the user</P>
<P>// component.</P>
<P>//</P>
<P>pUser-&gt;Release();</P>
<P></P>
<P>//</P>
<P>// Delete the user.</P>
<P>//</P>
<P>pContainer-&gt;Delete(TEXT("user"),bstrUserName);</P>
<P></P>
<P>//</P>
<P>// Cleanup.</P>
<P>//</P>
<P>SysFreeString(bstrContainerPath);</P>
<P>SysFreeString(bstrUserPath);</P>
<P>pContainer-&gt;Release();</P>
<P></code></pre></P>
<P><B>Object copy/move</B> is a combination of the creation and deletion functions, with an option to rename an object when it reaches the target container.</P></BODY></HTML>
