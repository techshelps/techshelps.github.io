<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>

<HEAD><META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">
<meta name="GENERATOR" content="Microsoft FrontPage 2.0">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>G. Security Manipulation Objects</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>

<BODY bgcolor="#FFFFFF">



<H1>G. Security Manipulation Objects</h1>

<p>The security interfaces for Active Directory have not been
finalized as of the release of this specification. The proposed
objects and interfaces for ACL manipulation are described in this
appendix.</p>

<p>Each network environment provides various operations designed
to enhance the security of the network and its resources. These
operations typically include security policy, authorization, and
security-related monitoring or auditing. All of these operations
are predicated on successful authentication of the identity of
the user or principal. </p>

<p><i>Authorization</i> refers to access control on resources,
determining who is allowed to use a given resource and how they
can use it. With many systems, the access control mechanism
involves putting an access control list (ACL) on the resource.
The ACL mechanisms are closely tied to the network environment
where they are supported and differ greatly depending on the
network environment. Another important aspect of ACLs is
inheritance, the capability of influencing ACLs on child objects
by modifying ACLs on the container objects.</p>

<p>Active Directory access control is focused on administering
authorization, not on providing other security features typically
needed by services. This is achieved using three dependent
objects:</p>

<ul>
    <li>The <b>Access Control object</b> to support ACL
        manipulation.</li>
</ul>

<ul>
    <li>The <b>Rights collection</b> to support enumeration of
        Right Entry objects.</li>
</ul>

<ul>
    <li>The <b>Right Entry object</b> which supports an interface
        for viewing access rights.</li>
</ul>

<H2>G.1 Access Control Dependent Object</h2>

<p>Access Control objects can be obtained from Active Directory
objects via the IADs::Access() pr ::PropAccess() methods. By
default, each object must support the following permissions:</p>

<ul>
    <li><b>Read</b></li>
</ul>

<ul>
    <li><b>Write</b></li>
</ul>

<ul>
    <li><b>Delete</b></li>
</ul>

<ul>
    <li><b>Edit Access Rights</b></li>
</ul>

<ul>
    <li><b>AllAccess</b></li>
</ul>

<p>AllAccess is shorthand for all available permissions on the
object.</p>

<p>These permissions can be interpreted differently for different
object classes. For example a container might equate the
following permissions with the standard permissions:</p>

<ul>
    <li>List Children = Read</li>
</ul>

<ul>
    <li>Add Children = Write</li>
</ul>

<p>An object class can also support additional permissions. For
example, a User object class can support the following
permissions in addition to the standard permissions:</p>

<ul>
    <li>Set Password</li>
</ul>

<ul>
    <li>Change Password</li>
</ul>

<H2>G.2 IADsAccess</h2>

<p>By convention, the Access Control dependent object supports
the IADsAccess interface for access control browsing and
manipulation. It is derived from IDispatch. The definition looks
like this:</p>

<p>[ object, uuid(IID_IADsAccess), oleautomation, dual ]</p>

<p>interface IADsAccess: IDispatch</p>

<p>{</p>

<p>// Read-only properties.</p>

<p>[propget]</p>

<p>HRESULT InheritanceType ([out, retval]BSTR *pbstrInheritance);</p>

<p>[propget]</p>

<p>HRESULT AvailablePermissions ([out, retval]VARIANT
*pvPermissions);</p>

<p>// Methods.</p>

<p>HRESULT Grant([in]BSTR bstrTrustee,</p>

<p>[in]VARIANT vPerms );</p>

<p>HRESULT Deny([in]BSTR bstrTrustee,</p>

<p>[in]VARIANT vPerms );</p>

<p>HRESULT Revoke([in]BSTR bstrTrustee);</p>

<p>HRESULT Set([in]BSTR bstrTrustee,</p>

<p>[in]VARIANT vPerms );</p>

<p>HRESULT Rights([out, retval]IADsCollection
**ppRightsCollection);</p>

<p>HRESULT Effective([in]BSTR bstrTrustee,</p>

<p>[out, retval]VARIANT *pvPerms );</p>

<p>HRESULT IsAccessPermitted([in]BSTR bstrTrustee,</p>

<p>[in]VARIANT vPerms,</p>

<p>[out, retval]boolean *pbPermitted );</p>

<p>};</p>

<table border="1" cellpadding="7" cols="2">
<COLGROUP><COL WIDTH="120pt" VALIGN="TOP"><COL WIDTH="317pt" VALIGN="TOP"></COLGROUP><TBODY>    <tr>
        <td valign="top"><b>Method</b></td>
        <td valign="top"><b>Description</b></td>
    </tr>
    <tr>
        <td valign="top">InheritanceType</td>
        <td valign="top">Gets a BSTR defining the type of access
        control inheritance the server supports. Currently
        defined access control inheritances are:<p>CREATE TIME</p>
        <p>DYNAMIC</p>
        <p>PERSCRIPTIVE</p>
        </td>
    </tr>
    <tr>
        <td valign="top">AvailablePermissions</td>
        <td valign="top">Gets an array containing all the access
        permissions supported by the object. These permissions
        are the only valid access permissions on this object
        type. Attempting to grant or deny a trustee other
        permissions on the object will result in an error. The
        array is a SAFEARRAY of BSTRs containing the names of the
        access permissions:<p>Read</p>
        <p>Write</p>
        <p>Delete</p>
        <p>Edit</p>
        <p>AllAccess</p>
        <p>Any other permissions supported by the object</p>
        </td>
    </tr>
    <tr>
        <td valign="top">Grant</td>
        <td valign="top">Ensures that the trustee has at least
        the specified access permissions. Other access
        permissions the trustee is allowed or denied will not be
        changed. If the permissions are not valid for the object,
        an error is returned.<p>Permissions are passed as a
        SAFEARRAY of BSTRs. Any permission string from the
        AvailablePermissions property is valid.</p>
        </td>
    </tr>
    <tr>
        <td valign="top">Deny</td>
        <td valign="top">Ensures that the trustee is denied the
        specified access permissions. Other access permissions
        the trustee is allowed or denied will not be changed. If
        the permissions are not valid for the object, an error is
        returned.<p>Permissions are passed as a SAFEARRAY of
        BSTRs. Any permission string from the
        AvailablePermissions property is valid.</p>
        </td>
    </tr>
    <tr>
        <td valign="top">Revoke</td>
        <td valign="top">Ensures that the trustee is not
        explicitly allowed any access permissions on the object.
        The trustee may, however be allowed or denied other
        access permissions because of group membership.</td>
    </tr>
    <tr>
        <td valign="top">Set</td>
        <td valign="top">Ensures that the trustee has exactly the
        specified access permissions. The trustee will no longer
        be allowed other access permissions that were previously
        allowed for that trustee. If the permissions are not
        valid for the object, an error is returned.<p>Permissions
        are passed as a SAFEARRAY of BSTRs. Any permission string
        from the AvailablePermissions property is valid.</p>
        </td>
    </tr>
    <tr>
        <td valign="top">Rights</td>
        <td valign="top">Returns a Rights collection dependent
        object that allows enumerating through the access rights
        on the object. See &quot;Rights Collection
        Sub-Object&quot; later in this chapter.</td>
    </tr>
    <tr>
        <td valign="top">Effective</td>
        <td valign="top">Returns an array containing the
        effective access permissions the specified trustee has on
        the object. The array is a SAFEARRAY of BSTRs containing
        the names of the effective access permissions granted to
        the trustee.</td>
    </tr>
    <tr>
        <td valign="top">IsAccessPermitted</td>
        <td valign="top">Returns TRUE if the specified trustee
        has the specified permissions. If the specified
        permissions are not valid for the object, an error is
        returned.<p>Permissions are passed as a SAFEARRAY of
        BSTRs. Any permission string from the
        AvailablePermissions property is valid.</p>
        </td>
    </tr>
</TBODY></table>

<br>
</p>

<H2>G.3 Rights Collection Dependent Object</h2>

<p>The Rights collection is collection of pointers to Right Entry
dependent objects, which represent the access permissions
currently set on an object. This collection is obtained by
calling the IADsAccess::Rights() method.</p>

<p>The Add and Remove methods on the IADsCollection interface are
not implemented for this collection. Rights on an object are
manipulated using the IADsAccess interface.</p>

<H3>G.3.1 Right Entry Dependent Object</h3>

<p>A Right Entry dependent object describes one access control
entry (ACE) on the ACL that describes the access permissions
currently set on an object. Right entry objects are obtained
exclusively from an enumeration of a Rights collection.</p>

<H4>G.3.1.1 IADsRightEntry</h4>

<p>By convention, the right entry dependent object supports the
IADsRightEntry interface. It is derived from IDispatch. The
definition looks like this:</p>

<p>[ object, uuid(IID_IADsRightEntry), oleautomation, dual ]</p>

<p>interface IADsRightEntry: IDispatch</p>

<p>{</p>

<p>// Read-only properties.</p>

<p>[propget]</p>

<p>HRESULT Trustee ([out, retval]BSTR *pbstrTrustee);</p>

<p>[propget]</p>

<p>HRESULT Permissions ([out, retval]VARIANT *pvPermissions);</p>

<p>};</p>

<table border="1" cellpadding="7" cols="2">
<COLGROUP><COL WIDTH="90pt" VALIGN="TOP"><COL WIDTH="346pt" VALIGN="TOP"></COLGROUP><TBODY>    <tr>
        <td valign="top"><b>Method</b></td>
        <td valign="top"><b>Description</b></td>
    </tr>
    <tr>
        <td valign="top">Trustee</td>
        <td valign="top">Gets the ADsPath string of the Trustee
        object.</td>
    </tr>
    <tr>
        <td valign="top">Permissions</td>
        <td valign="top">Gets a SAFEARRAY of BSTRs containing the
        access permissions granted or denied to the trustee on
        the object. </td>
    </tr>
</TBODY></table>

<br>
</p>

<H3>G.3.2 Examples</h3>

<p>The following examples demonstrate how to use the access
control objects.</p>

<p><b>Example 1: Setting Access Rights on a Property of the User
Object (Visual Basic)</b></p>

<p>Dim User as IADsUser</p>

<p>' Bind to a user object.</p>

<p>Set User = GetObject(&quot;WinNT://MSFT/Users/John&quot;)</p>

<p>' Give the group Everyone read-only access to the Manager
property.</p>

<p>User.
PropAccess(&quot;Manager&quot;).Set(&quot;Everyone&quot;,
Array(&quot;Read&quot;))</p>

<p><b>Example 2: Displaying Access Rights for a Selected User on
a Selected DS Object (Visual Basic)</b></p>

<p>Dim User as IADsUser</p>

<p>Dim RightEntry as IADsRightEntry</p>

<p>Dim Entry as String</p>

<p>' Bind to a user object.</p>

<p>Set User = GetObject(&quot;WinNT://MSFT/Users/John&quot;)</p>

<p>' Enumerate the rights on the user object.</p>

<p>For Each RightEntry In User.Access.Rights</p>

<p>' Print the access rights that are related to Jane.</p>

<p>If RightEntry.Trusteename =
&quot;WinNT://MSFT/Users/Jane&quot; Then</p>

<p>For Each Entry in RightEntry.Permissions</p>

<p>Debug.Print Entry</p>

<p>Next Entry</p>

<p>End If</p>

<p>Next RightEntry</p>

<p><b>Example 3: Determining what a Selected User can do to a
Selected DS Object (Visual Basic)</b></p>

<p>Dim User as IADsUser</p>

<p>Dim Permissions as Variant</p>

<p>Dim Entry as String</p>

<p>' Bind to a user object.</p>

<p>Set User = GetObject(&quot;WinNT://MSFT/Users/John&quot;)</p>

<p>' Find out Jane's effective access rights.</p>

<p>Permissions =
User.Access.Effective(&quot;WinNT://MSFT/Users/Jane&quot;)</p>

<p>For Each Entry in Permissions</p>

<p>Debug.Print Entry</p>

<p>Next Entry</p>

<p><b>Example 4: Determining Who has Explicit Rights to Change a
DS Object (Visual Basic)</b></p>

<p>Dim User as IADsUser</p>

<p>Dim RightEntry as IADsRightEntry</p>

<p>Dim Entry as String</p>

<p>' Bind to a user object.</p>

<p>Set User = GetObject(&quot;WinNT://MSFT/Users/John&quot;)</p>

<p>' Enumerate the &quot;All&quot; or &quot;Write&quot;
permissions on this object.</p>

<p>For Each RightEntry In User.Access.Rights</p>

<p>For Each Entry in RightEntry.Permissions</p>

<p>If Entry = &quot;All&quot; or Entry = &quot;Write&quot;</p>

<p>Debug.Print RightEntry.Trustee</p>

<p>End If</p>

<p>Next Entry</p>

<p>Next RightEntry</p>

<p><b>Example 5: Setting Access Rights on Properties of the User
object (C/C++)</b></p>

<p>IADsAccess *pSimpleAccess;</p>

<p>IADs_Access *pAccess;</p>

<p>IADsUser *pUser;</p>

<p>ACCESS_REQUEST ar[2];</p>

<p>//</p>

<p>// Build up an access request.</p>

<p>//</p>

<p>ar[0].Trustee.pwcsName =
TEXT(&quot;WinNT://MSFT/Users/Jane&quot;);</p>

<p>ar[0].Trustee.Type = TRUSTEE_IS_USER;</p>

<p>ar[0].Trustee.Reserved = 0;</p>

<p>ar[0].grfAccessPermissions = PROV_OBJECT_READ |
PROV_OBJECT_WRITE;</p>

<p>ar[1].Trustee.pwcsName = ADMINISTRATOR;</p>

<p>ar[1].Trustee.Type = TRUSTEE_IS_USER;</p>

<p>ar[1].Trustee.Reserved = 0;</p>

<p>ar[1].grfAccessPermissions = PROV_ALL_ACCESS;</p>

<p>//</p>

<p>// Use the Active Directory helper function ADsGetObject to
bind to John and</p>

<p>// return the user interface.</p>

<p>//</p>

<p>ADsGetObject(TEXT(&quot;WinNT://MSFT/Users/John&quot;),</p>

<p>IID_IADsUser,</p>

<p>(void**)&amp;pUser);</p>

<p>//</p>

<p>// Get the access control object on the user and QI for the</p>

<p>// advanced access control interface.</p>

<p>//</p>

<p>pUser-&gt;Access(&amp;pSimpleAccess);</p>

<p>pSimpleAccess-&gt;QueryInterface(IID_IADs_Access,
(void**)&amp;pAccess);</p>

<p>//</p>

<p>// Grant the access rights specified in the access request.</p>

<p>//</p>

<p>pAccess-&gt;GrantAccessRights(2,ar);</p>

<p>//</p>

<p>// Cleanup.</p>

<p>//</p>

<p>pAccess-&gt;Release();</p>

<p>pSimpleAccess-&gt;Release();</p>

<p>pUser-&gt;Release();</p>

<p><b>Example 6: Determine if a Selected User can change a
Selected Active Directory Object (C/C++)</b></p>

<p>IADsAccess *pSimpleAccess;</p>

<p>IADs_Access *pAccess;</p>

<p>IADsUser *pUser;</p>

<p>boolean bPermitted;</p>

<p>//</p>

<p>// Use the Active Directory helper function ADsGetObject to
bind to John.</p>

<p>//</p>

<p>ADsGetObject(TEXT(&quot;WinNT://MSFT/Users/John&quot;),</p>

<p>IID_IADsUser,</p>

<p>(void**)&amp;pUser</p>

<p>//</p>

<p>// Get the access control object on the user and QI for the</p>

<p>// advanced access control interface.</p>

<p>//</p>

<p>pUser-&gt;Access(&amp;pSimpleAccess);</p>

<p>pSimpleAccess-&gt;QueryInterface(IID_IADs_Access,
(void**)&amp;pAccess);</p>

<p>//</p>

<p>// Determine if the selected user has read/write</p>

<p>// permissions on the object.</p>

<p>//</p>

<p>pAccess-&gt;IsAccessPermitted(TEXT(&quot;WinNT://MSFT/Users/Jane&quot;),</p>

<p>(PROV_OBJECT_READ | PROV_OBJECT_WRITE),</p>

<p>&amp;bPermitted);</p>

<p>if (bPermitted == TRUE)</p>

<p>{</p>

<p>printf(&quot;Jane can change the selected object.\n&quot;);</p>

<p>}</p>

<p>//</p>

<p>// Cleanup.</p>

<p>//</p>

<p>pAccess-&gt;Release();</p>

<p>pSimpleAccess-&gt;Release();</p>

<p>pUser-&gt;Release();</p>
</body>
</html>
