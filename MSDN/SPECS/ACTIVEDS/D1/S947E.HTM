<HTML><HEAD><META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>4.2.1    IADs</TITLE><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">
</OBJECT></FORM>
<H3>4.2.1    IADs</H3><P>IADs is a COM interface that is defined by Active Directory.  It provides basic functionality that is required by all Active Directory objects:</P>
<P><UL><LI>Identifying information that indicates the name and type of the object.</LI></UL></P>
<P><UL><LI>Binding information that uniquely identifies the object instance in a directory tree.</LI></UL></P>
<P><UL><LI>A way to retrieve an interface pointer on the parent container object.</LI></UL></P>
<P><UL><LI>A way to retrieve the access control dependent object for the host object </LI></UL></P>
<P><UL><LI>A way tio retrieve the access control dependent object(s) for properties on the host object </LI></UL></P>
<P><UL><LI>A way to retrieve the schema definition of the object.</LI></UL></P>
<P><UL><LI>A simple caching  system.</LI></UL></P>
<P>The interface definition is as follows:</P>
<P></P>
<P><pre><code>[ object, uuid(IID_IADs), oleautomation, dual ]</P>
<P>interface IADs: IDispatch</P>
<P>{</P>
<P>// Read-only properties.</P>
<P>[propget]</P>
<P>HRESULT Name ([out, retval]BSTR *pbstrName);</P>
<P>[propget]</P>
<P>HRESULT Class ([out, retval]BSTR *pbstrClass);</P>
<P>[propget]</P>
<P>HRESULT GUID ([out, retval]BSTR *pbstrGUID);</P>
<P>[propget]</P>
<P>HRESULT ADsPath ([out, retval]BSTR *pbstrADsPath);</P>
<P>[propget]</P>
<P>HRESULT Parent ([out, retval]BSTR *pbstrParentContainer);</P>
<P>[propget]</P>
<P>HRESULT Schema ([out, retval]BSTR *pbstrSchemaClassObject);</P>
<P></P>
<P>// Methods.</P>
<P>HRESULT Access ([out, retval]IADsAccess **ppComponentAccessControl);</P>
<P>HRESULT PropAccess ([in]BSTR bstrPropName,</P>
<P>   [out, retval]IADsAccess **ppComponentAccessControl);</P>
<P>HRESULT GetInfo ([in,optional]VARIANT vHints);</P>
<P>HRESULT SetInfo (void);</P>
<P>HRESULT Get ([in]BSTR bstrName, [out, retval]VARIANT *pvProp);</P>
<P>HRESULT Put ([in]BSTR bstrName, [in]VARIANT vProp);</P>
<P>HRESULT GetEx ([in]BSTR bstrname, [out, retval] VARIANT *pvProp);</P>
<P>HRESULT PutEx ([in]LONG lnControlCode,[in]BSTR bstrName, [in]VARIANT vProp);</P>
<P>};</P>
</code></pre><P></P>

<TABLE COLS="4" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="81pt" VALIGN="TOP"><COL WIDTH="67pt" VALIGN="TOP"><COL WIDTH="292pt" VALIGN="TOP"><COL WIDTH="0pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B>Method</B></P></TD><TD VALIGN="TOP"><P>Syntax</P></TD><TD COLSPAN="2" VALIGN="TOP"><P>Remark</P></TD></TR><TR><TD VALIGN="TOP"><P>Name</P></TD><TD VALIGN="TOP"><P>String</P></TD><TD COLSPAN="2" VALIGN="TOP"><P>Gets the relative name of the object as named within the underlying namespace.  </P></TD></TR><TR><TD VALIGN="TOP"><P>ADsPath</P></TD><TD VALIGN="TOP"><P>ADsPath</P></TD><TD COLSPAN="2" VALIGN="TOP"><P>Gets the ADsPath string of the object that uniquely identifies the object in a heterogeneous environment.</P></TD></TR><TR><TD VALIGN="TOP"><P>Class</P></TD><TD VALIGN="TOP"><P>String</P></TD><TD COLSPAN="2" VALIGN="TOP"><P>Gets the name of the schema class of this object.  See the object extensions section for more details.</P></TD></TR><TR><TD VALIGN="TOP"><P>GUID</P></TD><TD VALIGN="TOP"><P>String</P></TD><TD COLSPAN="2" VALIGN="TOP"><P>Gets the unique identifier for objects of this schema class.<BR><B>NOTE: </B>Each Active Directory object type is uniquely identified by a GUID.  This GUID is the Active Directory abstraction of the globally unique identifier for the schema class, analogous to an ASN.1 OID.   </P></TD></TR><TR><TD VALIGN="TOP"><P>Parent</P></TD><TD VALIGN="TOP"><P>ADsPath</P></TD><TD COLSPAN="2" VALIGN="TOP"><P>Gets the ADsPath string of the parent container.</P></TD></TR><TR><TD VALIGN="TOP"><P>Schema</P></TD><TD VALIGN="TOP"><P>ADsPath</P></TD><TD COLSPAN="2" VALIGN="TOP"><P>Gets the ADsPath string of the object that represents this schema class in the schema.  See the object extensions chapter for details.</P></TD></TR><TR><TD VALIGN="TOP"><P>Access</P></TD><TD VALIGN="TOP"><P>Method</P></TD><TD COLSPAN="2" VALIGN="TOP"><P>Obtains the IADsAccess interface on the access control object that corresponds to the security permissions on this DS object.  See Chapter 5,"Dependent objects," for more details.</P></TD></TR><TR><TD VALIGN="TOP"><P>PropAccess</P></TD><TD VALIGN="TOP"><P>Method</P></TD><TD VALIGN="TOP"><P>Returns a pointer to the IADsAccess interface on the access control dependent object that represents the access control on a property directly hosted by this object, as indicated by bstrPropName.  See "Access Control Objects" later in this chapter for more details.</P></TD></TR><TR><TD VALIGN="TOP"><P>GetInfo</P></TD><TD VALIGN="TOP"><P>Method</P></TD><TD COLSPAN="2" VALIGN="TOP"><P>Reloads the object with the property values that exist within the directory service.</P>
<P>The vHints parameter allows the client to indicate which properties should be loaded, so the provider can attempt to optimize network access.  If no hints are specified, the VARIANT vHints is marked as empty, and the provider is expected to provide as much smart network access as possible.  Otherwise, each entry in the array should have the following format:</P>
<P>&lt;HintEntry&gt;::=&lt;PropName&gt;</P>
<P></P>
<P> where &lt;PropName&gt; is a BSTR value a property found in the schema.  </P></TD></TR><TR><TD VALIGN="TOP"><P>SetInfo</P></TD><TD VALIGN="TOP"><P>Method</P></TD><TD COLSPAN="2" VALIGN="TOP"><P>Mechanism for committing changes on an object.  If properties have been changed on an object, the SetInfo method will cause the properties to be changed within the directory service. </P></TD></TR><TR><TD VALIGN="TOP"><P>Get</P></TD><TD VALIGN="TOP"><P>Method</P></TD><TD COLSPAN="2" VALIGN="TOP"><P>retrieves the value for a named property.   The Property is specified in the bstrName argument as  &lt;"PropertyName"&gt;.   </P>
<P>The property value is returned in the passed VARIANT structure.</P></TD></TR><TR><TD VALIGN="TOP"><P>Put</P></TD><TD VALIGN="TOP"><P>Method.</P></TD><TD COLSPAN="2" VALIGN="TOP"><P>Sets the value for a named property. The property is specified in the bstrName argument as a string in the form &lt;"PropertyName"&gt;.  </P>
<P>The property value to set is provided in the passed VARIANT structure.</P>
<P><B>NOTE:  </B>to <B>remove</B> a property from an object,  call the <B>PutEx</B> method with the lnControlCode value set to <B>ADS_PROP_CLEAR</B>.</P>
<P></P></TD></TR><TR><TD VALIGN="TOP"><P>GetEx</P></TD><TD VALIGN="TOP"><P>Method</P></TD><TD COLSPAN="2" VALIGN="TOP"><P>retrieves the values for a named single or multi-valued property.   The Property is specified in the bstrName argument as  &lt;"PropertyName"&gt;.   </P>
<P>The property values are returned as a variant array in the passed VARIANT structure.</P></TD></TR><TR><TD VALIGN="TOP"><P>PutEx</P></TD><TD VALIGN="TOP"><P>Method</P></TD><TD COLSPAN="2" VALIGN="TOP"><P>Sets the value(s) for a named single- or multi-valued property. The property is specified in the bstrName argument as a string in the form &lt;"PropertyName"&gt;.</P>
<P>Valid values for lnControlCode are:</P>
<P><B>ADS_PROP_CLEAR: </B> remove the property from the object.</P>
<P><B>ADS_PROP_OVERWRITE:  </B>replaces the current value with the element(s) in the passed variant array,</P>
<P><B>ADS_PROP_APPEND</B>: appends the element(s) in the passed variant array to the current value.</P></TD></TR></TBODY></TABLE>
<BR></P><H4><A NAME="sec0"></A>4.2.1.1    Active Directory Object Type GUIDs</H4>The Active Directory Object GUID should not be confused with a CLSID.  </P>
<P><UL><LI>Active Directory Object Type GUIDs provide consistent identification for well-known objects  that is consistent across providers.  Well-known objects are those that are defined by Active Directory.  The GUID is the Interface ID (IID) for the primary COM interface on the object (see 0).</LI></UL></P>
<P><UL><LI>CLSIDs identify the class code associated with COM objects. </LI></UL></P>
Active Directory objects that are instantiated on behalf of a given Active Directory provider are COM objects with CLSIDs unique to the provider.  The Active Directory Object Type GUID will be the same for all well-known objects of a  type, regardless of provider.  For example,  if three Active Directory providers are installed on a given machine,  there will be 3 different CLSIDs for the Active Directory User object,  one for each provider.  All 3 user objects will have the same Active Directory Type, IID_IADsUser,  indicating that the objects are implementations of the Active Directory User object.   </P>
<H4><A NAME="sec1"></A>4.2.1.2    GetInfo and SetInfo</H4><P>The GetInfo and SetInfo methods provide simple caching  capabilities for properties in Active Directory components.  Operations that involve getting and setting properties occur in cached  mode. No changes are made to an object's properties within the namespace until the SetInfo method is executed. All changes to properties are cached locally until the SetInfo method is called.</P>
<P>GetInfo does not apply to container operations. SetInfo only applies to the creation of a new object in a container.  See 0, below.  </P>
<P>The GetInfo method refreshes the contents of the object's local cache. If the GetInfo method is executed after changes are made to the local object's cache but before the SetInfo method is executed, the changes are lost.  GetInfo allows the client to provide hints about which properties it uses, so that the provider can optimize network access.</P>
<P>A caller can obtain a property value from an Active Directory object at <I>any time</I> after obtaining the object (for example, via GetObject or via Active Directory enumeration).  The caller need not call GetInfo first.   If the property in question has not been previously retrieved,  the provider is responsible for retrieving and caching it to satisfy the request.  Subsequent requests will be satisfied from the cached value.</P>
<P>GetInfo is called to explicitly refresh the object's cached properties from the underlying namespace;  by calling GetInfo,  the caller ensures that the property values are current as of the time of the GetInfo call.</P>
<P>Both GetInfo and SetInfo may require multiple accesses to the underlying namespace to load or store the properties in the Active Directory object.  It is technically possible for a GetInfo or SetInfo operation to be only partially successful.  Active Directory providers are expected to complete as much of the requested operation as possible before returning.  Active Directory provides several standard error codes to indicate that a request was not completely processed.  Users should consult the documentation for the specific providers in use to determine what Active Directory errors are returned for their providers. </P>
<P>Non-property methods are executed as soon as the method call is received and are not processed in cached mode.</P>
<P>The following example modifies a user object in a simple demonstration of the caching system.</P>
<P><B>Example 1:  The Caching System (Visual Basic)</B></P>
<P></P>
<P><pre><code>'Example 1:  The Caching System (Visual Basic)</P>
<P>Dim MyUser As IADsUser</P>
<P></P>
<P>'' Bind to a user object.</P>
<P>Set MyUser = GetObject("WinNT://ntserver/1")</P>
<P></P>
<P>'' Change the nickname and title of the user.</P>
<P>'' Changes are stored in the Active Directory object cache until</P>
<P>'' SetInfo is called.</P>
<P>MyUser.FullName = "Johnny"</P>
<P></P>
<P>'' Call SetInfo to commit the changes to the network.</P>
<P>MyUser.SetInfo</P>
<P></P>
<P>'' Now change the user's password - this is a non-property method</P>
<P>'' and is executed immediately.</P>
<P>MyUser.SetPassword ("Argus")</P>
<P></P>
<P>'' Now refresh the Active Directory object cache with a GetInfo call.</P>
<P>MyUser.GetInfo</P>
<P></P>
<P>' Display some properties.</P>
<P>Debug.Print MyUser.FullName</P>
<P></code></pre></P>
<P><B>Example 1:  The Caching System (C/C++)</B></P>
<P><pre><code>IADsUser    *pUser;</P>
<P>BSTR    bstrNickName;</P>
<P>BSTR    bstrTitle;</P>
<P>VARIANT    vHints;</P>
<P></P>
<P>//</P>
<P>// Bind to the user object.</P>
<P>//</P>
<P>ADsGetObject(TEXT("WinNT://MSFT/Users/John"),</P>
<P>IID_IADsUser,</P>
<P>(void**)&amp;pUser);</P>
<P></P>
<P>//</P>
<P>// Allocate the strings for the changes.</P>
<P>//</P>
<P>bstrNickName = SysAllocString(TEXT("Johnny"));</P>
<P>bstrTitle = SysAllocString(TEXT("General Manager"));</P>
<P>bstrPassword = SysAllocString(TEXT("Argus"));</P>
<P></P>
<P>//</P>
<P>// Change the nickname and title of the user.  The changes</P>
<P>// are made in the local cache only.</P>
<P>//</P>
<P>pUser-&gt;put_NickName(bstrNickName);</P>
<P>pUser-&gt;put_Title(bstrTitle);</P>
<P></P>
<P>//</P>
<P>// Call SetInfo to commit the changes to the network.</P>
<P>//</P>
<P>pUser-&gt;SetInfo();</P>
<P></P>
<P>//</P>
<P>// Now change the user's password - this non-property method</P>
<P>// executes immediately.</P>
<P>//</P>
<P>pUser-&gt;SetPassword(bstrPassword);</P>
<P></P>
<P>//</P>
<P>// Refresh the Active Directory object with a call to GetInfo.  No hints</P>
<P>// are specified.</P>
<P>//</P>
<P>VariantInit(&amp;vHints);</P>
<P>V_VT(&amp;vHints) = VT_EMPTY;</P>
<P>pUser-&gt;GetInfo(vHints);</P>
<P></P>
<P>//</P>
<P>// Clean up and reuse the strings.</P>
<P>//</P>
<P>SysFreeString(bstrNickName);</P>
<P>SysFreeString(bstrTitle);</P>
<P>SysFreeString(bstrPassword);</P>
<P></P>
<P>//</P>
<P>// Retrieve values from the object.</P>
<P>//</P>
<P>pUser-&gt;get_Description(&amp;bstrNickName);</P>
<P>pUser-&gt;get_Location(&amp;bstrTitle);</P>
<P>printf("%s, %s", bstrNickName, bstrTitle);</P>
<P></P>
<P>//</P>
<P>// Release all interfaces.</P>
<P>//</P>
<P>pUser-&gt;Release();</P>
<P></P>
<P></code></pre></P>
<P>The following example demonstrates how to use caching hints to minimize network traffic.  A print queue is polled periodically for its status.</P>
<P><B>Example 2:  Caching Hints (Visual Basic)</B></P>
<P><pre><code>Dim PrintQueue as IADsPrintQueue</P>
<P>Dim Hints as Variant</P>
<P>Dim Counter as Long</P>
<P></P>
<P>' Bind to a print queue object.</P>
<P>Set PrintQueue = GetObject("WinNT://MSFT/Printers/Queue26")</P>
<P></P>
<P>' In this case we are interested in polling the print queue for</P>
<P>' it's status. Set up the hints to identify this.</P>
<P>Hints = Array("Status")</P>
<P></P>
<P>' Loop to poll the queue.</P>
<P>For  Counter = 1 to 1000</P>
<P></P>
<P>' Show the queue status.</P>
<P>Debug.Print PrintQueue.Status</P>
<P></P>
<P>' Wait the polling interval.</P>
<P>Call Sleep(1000)</P>
<P></P>
<P>' Refresh the object cache.</P>
<P>PrintQueue.GetInfo(Hints)</P>
<P></P>
<P>Next Counter</P>
<P></code></pre></P>
<P><B>Example 2:  Caching Hints (C/C++)</B></P>
<P><pre><code>IADsPrintQueue        *pPrintQueue;</P>
<P>IADsPrintQueueOperations *pOperation;</P>
<P>long    *pStatus;</P>
<P></P>
<P>BSTR    bstrStatusString;</P>
<P>BSTR    bstrHint;</P>
<P>DWORD    dwStatusCode;</P>
<P>SAFEARRAY    *psaHints;</P>
<P>SAFEARRAYBOUND rgsabound[1];</P>
<P>VARIANT    vHints;</P>
<P>long    ix[1];</P>
<P>DWORD    dwCounter;</P>
<P></P>
<P>//</P>
<P>// Bind to the print queue object.  Get the Operation Interface and the IADs <BR>// interface</P>
<P>//</P>
<P>ADsGetObject(TEXT("WinNT://MSFT/Printers/Queue26"),</P>
<P>IID_IADsPrintQueueOperations,</P>
<P>(void**)&amp;pOperation);</P>
<P>pOperation-&gt;QueryInterface(IID_IADs,(void **)&amp;pPrintQueue);</P>
<P>//</P>
<P>// In this case we are interested in polling thw queue for</P>
<P>// it's status.  Set up the hints to identify this.</P>
<P>//</P>
<P>bstrHint = SysAllocString(TEXT("Status"));</P>
<P>rgsabound[0].lLBound = 0;</P>
<P>rgsabound[0].cElements = 1;</P>
<P>psaHints = SafeArrayCreate(VT_BSTR, 1, rgsabound);</P>
<P>ix[0]=1;</P>
<P>SafeArrayPutElement(psaHints, ix, bstrHint);</P>
<P>VariantInit(&amp;vHints);</P>
<P>V_VT(&amp;vHints) = VT_BSTR|VT_ARRAY;</P>
<P>V_ARRAY(&amp;vHints) = psaHints;</P>
<P></P>
<P>//</P>
<P>// Loop to poll the queue.</P>
<P>//</P>
<P>For(dwCounter=1;dwCounter&lt;=1000;dwCounter++)</P>
<P>{</P>
<P></P>
<P>//</P>
<P>// Get and report values.</P>
<P>//</P>
<P>pOperation-&gt;get_Status(&amp;dwStatusCode);</P>
<P>printf("%d, \n", dwStatusCode);</P>
<P></P>
<P>//</P>
<P>// Wait the polling interval.</P>
<P>//</P>
<P>Sleep(1000);</P>
<P></P>
<P>//</P>
<P>// Refresh the object cache and destroy old placeholders.</P>
<P>//</P>
<P>pPrintQueue-&gt;GetInfo(vHints);</P>
<P>SysFreeString(bstrStatusString);</P>
<P>}</P>
<P></P>
<P>//</P>
<P>// Cleanup.</P>
<P>//</P>
<P>SafeArrayDestroy(psaHints);</P>
<P>pOperation-&gt;Release();</P>
<P>pPrintQueue-&gt;Release();</P>
<P></code></pre></P></BODY></HTML>
