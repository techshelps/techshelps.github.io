<HTML><HEAD><META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Pointer Moniker Class</TITLE><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">

</OBJECT></FORM>
<H2>Pointer Moniker Class</H2>  </P>
A pointer moniker is a kind of moniker that wraps an existing object pointer in a moniker so that it may participate as a piece in the moniker binding process. Think of pointers as a referencing mechanism into the "active space:" a process's memory. Most moniker implementations are by contrast references into "passive space:" the representation of an object on disk. Pointer monikers provide a means by which a given use of a moniker can transparently reference <I>either</I> active <I>or</I> passive space.</P>
Implementations of functions in IMoniker interface for Pointer Monikers work roughly as follows. IMoniker::BindToObject turns into a QueryInterface on the pointer; IMoniker::BindToStorage returns MK_E_NOSTORAGE; IMoniker::Reduce<B>()</B> reduces the moniker to itself; IMoniker::ComposeWith always does a generic composition; IMoniker::Enum returns NULL; IMoniker::IsSystemMoniker returns MKSYS_PTR; IMoniker::IsEqual<B>()</B> uses the identity test paradigm on pointers after first checking that the other moniker for the right class; IMoniker::Hash returns a constant; IMoniker::GetTimeOfLastChange returns MK_E_UNAVAILABLE; IMoniker::Inverse returns an anti-moniker; IMoniker::RelativePathTo returns the other moniker; IMoniker::GetDisplayName returns NULL; and IMoniker::ParseDisplayName<B>() </B>binds to the punk pointer using IParseDisplayName interface and works from there.</P>
Instances of this kind of moniker refuse to be serialized; that is, IPersistStream::Save will return an error. These monikers can, however, be <I>marshaled</I> to a different process; internally, this marshals and unmarshals the pointer using the standard paradigm for marshaling interface pointers: CoMarshalInterface and CoUnmarshalInterface.</P>
 </P></BODY></HTML>
