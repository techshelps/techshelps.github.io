<HTML><HEAD><META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Footnotes</TITLE><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">

</OBJECT></FORM>
<H3>Footnotes</H3>  </P>
<A NAME="PT2"></A>1. Connecting to objects through an "intelligent/persistent name" (moniker) falls into this category. <font class="MissingLink" meta="returnFNOne">[Back]</font></P>
<A NAME="PT3"></A>2. Any internally-used memory in COM and in-process objects can use any allocation scheme desired, but the COM memory allocator is a handy, efficient, and thread-safe allocator. <font class="MissingLink" meta="returnFNTwo">[Back]</font></P>
<A NAME="PT4"></A>3. This rule is stronger than it might seem to need to be in order to promote more robust application interoperability. <font class="MissingLink" meta="returnFNThree">[Back]</font></P>
<A NAME="PT5"></A>4. Colloquially, of course, pronounced "scum." <font class="MissingLink" meta="returnFNFour">[Back]</font></P>
<A NAME="PT6"></A>5. Strictly speaking, the <I>handler</I> is simply the representative of a remote object that resides in the client's process and which internally contains the remote connection. There is thus <I>always</I> a handler present when remoting is being done, though very often the handler is a trivial one which merely forwards all calls. In that sense, handler is synonymous with the terms <I>proxy object </I>or <I>object proxy. </I>In practice the term handler tends to be used more when there is in fact a non-trivial handler, with <I>proxy</I> usually used when the handler is in fact trivial. <font class="MissingLink" meta="returnFNFive">[Back]</font></P>
<A NAME="PT7"></A>6. Readers more familiar with RPC than with COM will recognize <I>client stub </I>and <I>server stub </I>rather than <I>proxy</I> and <I>stub</I>, but the phrases are analogous. <font class="MissingLink" meta="returnFNSix">[Back]</font></P>
<A NAME="PT8"></A>7.    OLE Controls use the Connectable Objects mechanisms extensively.<font class="MissingLink" meta="returnFNSeven"> [Back]</font></P>
<A NAME="PT9"></A>8. Note that this usage of the term <I>multicasting</I> may differ from what some readers are accustomed to. In some systems <I>multicasting</I> is used to describe a connection-less broadcast. Connectable objects are obviously connection oriented.<font class="MissingLink" meta="returnFNEight"> [Back]</font></P>
<A NAME="PT10"></A>9. This specification recommends that the COM implementation on a given platform (Microsoft&reg;Windows&reg;, Apple&reg; Macintosh&reg;, and so forth.) include a standard storage implementation for use by all applications. <font class="MissingLink" meta="returnFNNine">[Back]</font></P>
<A NAME="PT11"></A>10. This mechanism, in fact, was employed by compound documents in Microsoft's OLE version 1.0. The problems describe here were some of the major limitations of OLE 1.0, which provided much of the impetus for COM's Persistent Storage technology. <font class="MissingLink" meta="returnFNTen">[Back]</font></P>
<A NAME="PT12"></A>11. The application would only create year, month, and day sub-storages for those days that had information in them, that is, the diary application would create sparse storage for efficiency. <font class="MissingLink" meta="returnFNEleven">[Back]</font></P>
<A NAME="PT13"></A>12. Case sensitivity is a locale-sensitive operation: some characters compare case-insensitive-equal in some locales and -not-equal in others. In an IStorage implementation, the case-insensitive comparison is done with respect to the current locale in which the system is presently running. This has implications on the use of IStorage names for those who wish to create globally portable documents.<font class="MissingLink" meta="returnFNTwelve"> [Back]</font></P>
<A NAME="PT14"></A>13. The word <I>moniker</I> is fairly obscure synonym for nickname.<font class="MissingLink" meta="returnFNThirteen"> [Back]</font></P>
<A NAME="PT15"></A>14. One of the few instances of inheritance from one major interface to another, which the <I>IMoniker</I> designer later decided was actually less preferable to having a moniker implement <I>IMoniker</I> and <I>IPersistStream </I>separately. See the first footnote in Chapter 9. <font class="MissingLink" meta="returnFNFourteen">[Back]</font></P>
<A NAME="PT16"></A>15. OLE for Real-Time Market Data was formerly called the "WOSA Extensions for Real Time Market Data". More information on this and other industry-specific extensions to OLE is available from Microsoft. <font class="MissingLink" meta="returnFNFifteen">[Back]</font></P>
<A NAME="PT17"></A>16. Some readers may wonder why Uniform Data Transfer is defined using the Connectable Objects interfaced described previously. The reason is simple: UDT was designed as part of the original OLE 2.0 specification in 1991, and Connectable Objects were not introduced until the release of the OLE Controls specification in 1993. <font class="MissingLink" meta="returnFNSixteen">[Back]</font></P>
<P></P>
 </P></BODY></HTML>
