<HTML><HEAD><META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>IMoniker::BindToStorage</TITLE><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">

</OBJECT></FORM>
<H3>IMoniker::BindToStorage</H3>  </P>
<B>HRESULT IMoniker::BindToStorage(pbc, pmkToLeft, iid, ppvObj)</B></P>
Return access to the persistent <I>storage</I> of the receiver using the given interface, rather than access to the object itself, which is what IMoniker::BindToObject returns. Consider, for example, a moniker which refers to spreadsheet embedded in a word processing document, such as:</P>
  </P>
<BR></P>
<pre><code>[c:\foo\bar.doc]File Moniker +(composition operation) [summaryTable]Item Moniker</code></pre>
  </P>
Calling IMoniker::BindToObject on this composite will enable us to talk to the spreadsheet; calling IMoniker::BindToStorage will let us to talk to the IStorage instance in which it resides.</P>
IMoniker::BindToStorage will most often be called during the right-to-left recursive process of IMoniker::BindToObject invoked on a Generic Composite Moniker. Sometimes it is the case that monikers in the tail of the composite don't require access to the object on their left; they merely require access to its persistent storage. In effect, these monikers can be bound to without also binding to the objects of the monikers to their left, potentially a much more efficient operation.</P>
Some objects do not have an independently identifiable piece of storage. These sorts of objects are really only a object-veneer on the internal state of their container. Examples include named cell ranges inside a Microsoft Excel worksheet, and fragments of a Microsoft Windows Word document delimited by bookmarks. Attempting to call IMoniker::BindToStorage on a moniker which indicates one of these kinds of objects will fail with the error MK_E_NOSTORAGE.</P>
Use of the bind context in IMoniker::BindToStorage is the same as in IMoniker::BindToObject.</P>
  </P>

<TABLE COLS="3" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="83pt" VALIGN="TOP"><COL WIDTH="308pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><B>Argument</B></P></TD><TD VALIGN="TOP"><B>Type</B></P></TD><TD VALIGN="TOP"><B>Description</B></P></TD></TR><TR><TD VALIGN="TOP">pbc</P></TD><TD VALIGN="TOP">IBindCtx*</P></TD><TD VALIGN="TOP">The binding context for this binding operation.</P></TD></TR><TR><TD VALIGN="TOP">iid</P></TD><TD VALIGN="TOP">REFIID</P></TD><TD VALIGN="TOP">The interface by which we want to bind to this storage. Common interfaces passed here include IStorage, IStream, and ILockBytes.</P></TD></TR><TR><TD VALIGN="TOP">ppvObj</P></TD><TD VALIGN="TOP">void**</P></TD><TD VALIGN="TOP">On successful return, a pointer to the instantiated storage is placed here, unless BINDFLAGS_JUSTTESTEXISTENCE was specified in the binding options, in which case NULL <I>may </I>be returned instead.</P></TD></TR><TR><TD VALIGN="TOP">return value</P></TD><TD VALIGN="TOP">HRESULT</P></TD><TD VALIGN="TOP">S_OK,  MK_E_NOSTORAGE, MK_E_EXCEEDEDDEADLINE, MK_E_CONNECTMANUALLY, E_NOINTERFACE, MK_E_INTERMEDIATEINTERFACENOTSUPPORTED, STG_E_ACCESSDENIED</P></TD></TR></TBODY></TABLE>
<BR></P> </P></BODY></HTML>
