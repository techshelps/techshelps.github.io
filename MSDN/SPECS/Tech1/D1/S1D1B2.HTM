<HTML><HEAD><META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>IRpcStubBuffer::Invoke</TITLE><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">

</OBJECT></FORM>
<H3>IRpcStubBuffer::Invoke</H3>  </P>
<B>HRESULT IRpcStubBuffer::Invoke(pMessage, pChannel)</B></P>
Invoke the pMessage-&gt;iMethod'th method in the server object interface instance to which this interface stub is currently connected. The RPC runtime infrastructure (the <I>channel) </I>calls this method on the appropriate interface stub upon receipt of an incoming request from some remote client. See the discussion above regarding how interface stubs implicitly know the IID which they are servicing.</P>
On entry, the members of pMessage are set as follows:</P>
  </P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="110pt" VALIGN="TOP"><COL WIDTH="352pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><B>Member Name</B></P></TD><TD VALIGN="TOP"><B>Value on entry to Invoke()</B></P></TD></TR><TR><TD VALIGN="TOP">reserved members</P></TD><TD VALIGN="TOP">Indeterminate. These members are neither to be read nor to be changed by the stub.</P></TD></TR><TR><TD VALIGN="TOP">pvBuffer</P></TD><TD VALIGN="TOP">Points to a buffer which contains the marshaled incoming arguments. In the case that there are no such arguments (for example, cbBuffer == 0), pvBuffer may be NULL, but will not necessarily be so.</P></TD></TR><TR><TD VALIGN="TOP">cbBuffer</P></TD><TD VALIGN="TOP">The size in bytes of the memory buffer to which pvBuffer points. If pvBuffer is NULL, then cbBuffer will be zero (but the converse is not necessarily true, as was mentioned in pvBuffer).</P></TD></TR><TR><TD VALIGN="TOP">iMethod</P></TD><TD VALIGN="TOP">The zero-based method number in the interface which is being invoked</P></TD></TR><TR><TD VALIGN="TOP">dataRepresentation</P></TD><TD VALIGN="TOP">If NDR transfer syntax is being used, then this indicates the byte order, etc., according to which the data in pvBuffer has been marshaled.</P></TD></TR><TR><TD VALIGN="TOP">rpcFlags</P></TD><TD VALIGN="TOP">Indeterminate. Neither to be read nor to be changed by the stub.</P></TD></TR></TBODY></TABLE>
<BR></P>The stub is to do the following:</P>
<SPAN CLASS="list"><UL><LI>unmarshal the incoming arguments,</LI><LI>invoke the designated operation in the server object,</LI><LI>ask the channel to allocate a new buffer for the return values and out values,</LI><LI>marshal the return values and out values into the buffer, then</LI><LI>return successfully (for example, NOERROR) from Invoke().</LI></UL></SPAN><A NAME="PT2"></A>Errors may of course occur at various places in this process.<font class="MissingLink" meta="aslch07_FNThirteen">13.</font> Such errors will cause the stub to return an error from Invoke() rather than NOERROR. In cases where such an error code is returned, it is the stub's responsibility to have cleaned up any data and other resources allocated by the unmarshaling and marshaling processes or returned as out values from the server object. However, the stub is <I>not</I> responsible for invoking FreeBuffer() to free the actual marshaling buffer (for example, it is illegal for the stub to do so); rather, on error return from Invoke() the caller of Invoke() will ignore pvBuffer, and will also free it if non-NULL. Having made that general statement as to the exit conditions of Invoke(), let us examine its operation in greater detail.</P>
If the stub cannot deal with the indicated dataRepresentation, it is to return RPC_E_SERVER_INVALIDDATAREP. If it understands the data representation, the stub is to then unmarshal the arguments from the buffer provided in pMessage-&gt;pvBuffer, the size of which is passed in pMessage-&gt;cbBuffer. If the argument data cannot be completely unmarshaled, the server is to free any partially unmarshaled data, then return RPC_E_SERVER_CANTUNMARSHALDATA from Invoke().</P>
If the data is successfully completely unmarshaled, then the interface stub is to invoke the designated method in the designated interface on the server object. Notice that the incoming pvBuffer memory buffer is at this time still valid, and that therefore the stub may if it wishes and if appropriate for the argument and data representations in question pass to the server object pointers which point directly into this buffer. The memory allocation and data copying that is thus avoided can at times be a significant performance optimization.</P>
<A NAME="PT3"></A>Once the invocation of the server object returns, the stub is to marshal the return value and out parameters returned from the server back to the client. It does so irrespective of whether the server object invocation returned an error or success code; that is, the stub marshals back to the client whatever the server object returned.<font class="MissingLink" meta="aslch07_FNFourteen">14.</font> The stub gets a reply buffer into which to do this marshaling by calling pChannel-&gt;GetBuffer(), passing in the pMessage structure that it received in Invoke(). Before calling GetBuffer(), the stub is to set the cbBuffer member to the size that it requires for the to-be-allocated reply buffer. Zero is explicitly a legal value for cbBuffer, and the stub must <I>always </I>call GetBuffer() (more precisely, to be clear about the error case: the stub must always call GetBuffer() if the server object method has actually been invoked)<font class="MissingLink" meta="aslch07_FNFifteen">15.</font> to allocate a reply buffer, even if the stub itself does not require one (such as would be the case if for a void-returning function with no out parameters). The stub must also set dataRepresentation as appropriate for the standard by which it intends to marshal the returning values (or would marshal them if there were some).<font class="MissingLink" meta="aslch07_FNSixteen">16.</font> Aside from cbBuffer, dataRepresentation and possibly the contents of the bytes inside the memory buffer, on entry to GetBuffer() no other data accessible from pMessage may be different than they were on entry to Invoke().</P>
Before it allocates a reply buffer, the call to GetBuffer() has the side effect of freeing the memory buffer to which pvBuffer presently points. Thus, the act by the interface stub of allocating a reply buffer for the return values necessarily terminates access by the stub to the incoming marshaled arguments.</P>
If GetBuffer() successfully allocates a reply buffer (see GetBuffer() for a description of how the stub determines this), then the stub is to marshal the return value and returned-out parameters into the buffer according to the rules of the transfer syntax. Once this is complete, the stub is to set the cbBuffer member to the number of bytes it actually marshaled (if it marshaled nothing, then it must explicitly set this to zero ((but see also GetBuffer())), and then return NOERROR from Invoke().</P>
If an error occurs during the unmarshaling of the incoming arguments or the marshaling of the return values, then the interface stub is responsible for correctly freeing any resources consumed by the marshaled data. See in particular CoReleaseMarshalData(). See also the discussion of this topic in IRpcChannelBuffer::SendRecieve().</P>
  </P>

<TABLE COLS="3" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="124pt" VALIGN="TOP"><COL WIDTH="285pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><B>Argument</B></P></TD><TD VALIGN="TOP"><B>Type</B></P></TD><TD VALIGN="TOP"><B>Description</B></P></TD></TR><TR><TD VALIGN="TOP">pMessage</P></TD><TD VALIGN="TOP">RPCOLEMESSAGE *</P></TD><TD VALIGN="TOP">Channel-allocated message structure.</P></TD></TR><TR><TD VALIGN="TOP">pChannel</P></TD><TD VALIGN="TOP">IRpcChannelBuffer *</P></TD><TD VALIGN="TOP">The channel to use for buffer management, and so forth.</P></TD></TR><TR><TD VALIGN="TOP">return value</P></TD><TD VALIGN="TOP">HRESULT</P></TD><TD VALIGN="TOP">S_OK, RPC_E_SERVER_INVALIDDATAREP, RPC_E_SERVER_CANTUNMARSHALDATA, RPC_E_SERVER_CANTMARSHALDATA</P></TD></TR></TBODY></TABLE>
<BR></P> </P></BODY></HTML>
