<HTML><HEAD><META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Chapter 5: COM Clients</TITLE><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">

</OBJECT></FORM>
<H1>Chapter 5: COM Clients</H1>  </P>
As described in earlier chapters, a COM Client is simply any piece of code that makes use of another object through that object's interfaces. In this sense, a COM Client may itself be a COM Server acting in the capacity of a client by virtue of using (or reusing) some other object.</P>
If the client is an application, that is, an executable program as opposed to a .DLL, then it must follow all the requirements for a COM Application as detailed in Chapter 4. That aside, clients have a number of ways to actually get at an object to use as discussed in a previous chapter. The client may call a specific function to create an object, it might ask an existing object to create another, or it might itself implement an object to which some other code hands yet another object's interface pointer. Not all of these objects must have CLSID.</P>
This chapter, however, is concerned with those clients that want to create an object based on a CLSID, because at some point or another, many operations that don't directly involve a CLSID do eventually resolve to this process. For example, moniker binding internally uses a CLSID but shields clients from that fact. In any case, whatever client code uses a CLSID will generally perform the following operations in order to make use of an object:</P>
<SPAN CLASS="list"><OL><LI><font class="MissingLink" meta="aslch05_Identify">Identify the class of object to use</font>.</LI><LI><font class="MissingLink" meta="aslch05_Factory">Obtain the "class factory" for the object class</font> and ask it to create an uninitialized instance of the object class, returning an interface pointer to it.</LI><LI><font class="MissingLink" meta="aslch05_Initialize">Initialize the newly created object</font> by calling an initialization member function of the "initialization interface," that is, one of a generally small set of interfaces that have such functions.</LI><LI>Make use of the object which generally includes calling QueryInterface to <font class="MissingLink" meta="aslch05_Managing">obtain additional working interface pointers</font> on the object. The client must be prepared for the potential absence of a desired interface.</LI><LI><font class="MissingLink" meta="aslch05_Release">Release the object</font> when it is no longer needed.</LI></OL></SPAN>The following sections cover the functions and interfaces involved in each of these steps. In addition, the client may want to more closely <font class="MissingLink" meta="aslch05_Server">manage the loading and unloading of server modules</font> (.DLLs or .EXEs) for optimization purposes, so this chapter includes a section of such management.</P>
As far as the client is concerned, the COM Library exists to provide fundamental implementation locator and object creation services and to handle remote procedure calls to local or remote objects (in addition to memory management services, of course). How a server facilitates these functions is the topic of Chapter 6.</P>
Before examining the details of object creating and manipulation, realize that after the object is created and the client has its first interface pointer to that object, the <I>client cannot distinguish an in-process object from a local object from a remote object</I> by virtue of examining the interface pointer or any other interfaces on that object. That is, all objects appear identically to the client such that after creation, all requests made to the object's services are made by calling interface member functions. Period. There are not special exceptions that a client must make at run-time based on the distance of the object in question. </P>
The COM Library provides any underlying glue to insure that a call made to a local or remote object is, in fact, marshaled properly to the other process or the other computer, respectively. <I>This operation is transparent to the client</I>, who always sees any call to an object as a function call to the objects interfaces as if that object were in-process. This consistency is a key benefit for COM clients as it can treat all objects identically regardless of their actual execution context. If you are interested in understanding how this transparency is achieved, please see Chapter 7, "Communicating via Interfaces: Remoting" for more details. There you will find that all clients do, in fact, always call an in-process object first, but in local and remote cases that in-process object is just a proxy that takes care of generating a remote procedure call.</P>
</P>
 </P></BODY></HTML>
