<HTML><HEAD><META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Enumerators and Enumerator Interfaces</TITLE><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">

</OBJECT></FORM>
<H2>Enumerators and Enumerator Interfaces</H2>  </P>
A frequent programming task is that of iterating through a sequence of items. The COM interfaces are no exception: there are places in several interfaces described in this specification where a client of some object needs to iterate through a sequence of items controlled by the object. COM supports such enumeration through the use of "enumerator objects." Enumerators cleanly separate the caller's desire to loop over a set of objects from the callee's knowledge of how to accomplish that function.</P>
<A NAME="PT3"></A>Enumerators are just a concept; there is no actual interface called IEnumerator or IEnum or the like. This is due to the fact that the function signatures in an enumerator interface must include the type of the things that the enumerator enumerates. As a consequence, separate interfaces exist for each kind of thing that can be enumerated. However, the difference in the type being enumerated is the <I>only</I> difference between each of these interfaces; they are all used in fundamentally the same way. In other words, they are "generic" over the element type. This document describes the semantics of enumerators using a generic interface IEnum and the C++ parameterized type syntax where ELT_T, which stands for <B>EL</B>emen<B>T</B> <B>T</B>ype<font class="MissingLink" meta="aslch03_FNFifteen">15.</font> is representative of the type involved in the enumeration:</P>
  </P>
<BR></P>
<pre><code>   
[
    object,
    uuid(&lt;IID_IEnum &lt;ELT_T&gt;&gt;),  // IID_IEnum&lt;ELT_T&gt;
    pointer_default(unique)
]
interface IEnum&lt;ELT_T&gt; : IUnknown
{
    HRESULT Next( [in] ULONG celt, [out] IUnknown **rgelt, [out] ULONG *pceltFetched );
    HRESULT Skip( [in] ULONG celt );
    HRESULT Reset( void );
    HRESULT Clone( [out] IEnum&lt;ELT_T&gt;**ppenum );
}
</code></pre>
  </P>
A typical use of an enumerator is the following.</P>
  </P>
<BR></P>
<pre><code>//Somewhere there's a type called "String"
typedef char * String;

//Interface defined using template syntax
typedef IEnum&lt;char *&gt;   IEnumString;
...
interface IStringManager { 
   virtual IEnumString* EnumStrings(void) = 0;
   };
...
void SomeFunc(IStringManager * pStringMan)    {
   char *        psz;
   IEnumString * penum;
   penum=pStringMan-&gt;EnumStrings();
   while (S_OK==penum-&gt;Next(1, &amp;psz, NULL))
      {
      //Do something with the string in psz and free it
      }
   penum-&gt;Release();
   return;
   }</code></pre>
  </P>
 </P></BODY></HTML>
