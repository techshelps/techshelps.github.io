<HTML><HEAD><META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>The Interface Binary Standard</TITLE><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">

</OBJECT></FORM>
<H3>The Interface Binary Standard</H3>  </P>
Technically speaking, an interface is some data structure that sits between the client's code and the object's implementation through which the client requests the object's services. The interface in this sense is nothing more than a set of member functions that the client can call to access that object implementation. Those member functions are exposed outside the object implementor application such that clients, local or remote, can call those functions.</P>
The client maintains a pointer to the interface which is, in actuality, a pointer to a pointer to an array of pointers to the object's implementations of the interface member functions. That's a lot of pointers; to clarify matters, the structure is illustrated in Figure 3-1.</P>
<img src="ASL0D.gif"></P>
<B>Figure 3-1: The interface structure: a client has a pointer to an interface which is a pointer to a pointer to an array (table) of pointers to the object's implementation.</B></P>
By convention the pointer to the interface function table is called the pVtbl pointer. The table itself is generally referred to with the name vtbl for virtual function table.</P>
On a given implementation platform, a given method in a given interface (a particular IID, that is) has a fixed calling convention; this is de-coupled from the implementation of the interface. In principle, this decision can be made on a method-by-method basis, though in practice on a given platform virtually all methods in all interfaces use the same calling convention. On Microsoft's 16-bit Windows platform, this default is the __far __cdecl calling convention; on Win32&reg; platforms, the __stdcall calling convention is the default for methods which do not take a variable number of arguments, and __cdecl is used for those that do.</P>
In contrast, just for note, COM API functions (not interface members) use the standard host system-call calling convention, which on both Microsoft Win16 and Win32 is the __far __pascal sequence.</P>
Finally, and quite significantly, <I>all strings passed through all COM interfaces</I> (and, at least on Microsoft platforms, all COM APIs) <I>are Unicode strings</I>. There simply is no other reasonable way to get interoperable objects in the face of (i) location transparency, and (ii) a high-efficiency object architecture that doesn't in all cases intervene system-provided code between client and server. Further, this burden is in practice not large.</P>
<A NAME="PT2"></A>When calling member functions, the caller must include an argument which is the pointer to the object instance itself. This is automatically provided in C++ compilers and completely hidden from the caller. The Microsoft Object Mapping<font class="MissingLink" meta="aslch03_FNOne">1.</font> specifies that this pointer is pushed very last, immediately before the return address. The location of this pointer is the reason that the pIInterface<I> </I>pointer appears at the <I>beginning</I> of the argument list of the equivalent C function prototype: it means that the layout in the stack of the parameters to the C function prototype is exactly that expected by the member function implemented in C++, and so no re-ordering is required.</P>
<A NAME="PT3"></A>Usually the pointer to the interface itself is the pointer to the entire object structure (state variables, or whatever) and that structure immediately follows<font class="MissingLink" meta="aslch03_FNTwo">2.</font> the pVtbl<I> </I>pointer memory as shown in Figure 3-2.</P>
<img src="ASL1D.gif"></P>
<B>Figure 3-2: Convention places object data following the pointer to the interface function table.</B></P>
Since the pVtbl is received as the this pointer in the interface function, the implementor of that function knows which object is being called—an object is, after all, some structure and functions to manipulate that structure, and the interface definition here supplies both.</P>
In any case, this vtbl structure is called a binary standard because on the binary level, the structure is completely determined by the particular interface being used and the platform on which it is being invoked. It is independent of the programming language or tool used to create it. In other words, a program can be written in C to generate this structure to match what C++ does automatically. For more details, see the section "C vs. C++" below. You could even create this structure in Assembler language if so inclined. Since compilers for other languages eventually reduce source code to Assembler language (as is the compiler itself) it is really a matter for compiler vendors to support this structure for languages such as Pascal, COBOL, Smalltalk, and so forth. Thus COM clients, objects, and servers can be written in any languages with appropriate compiler support.</P>
Note that it is technically legal for the binary calling conventions for a given interface to vary according the particular implementation platform in question, though this flexibility should be exercised by COM system implementors only with very careful attention to source portability issues. It is the case, for example, that on the Apple Macintosh, the pVtbl pointer does not point to the first function in the vtbl, but rather to a dummy pointer slot (which is ignored) immediately before the first function; all the function pointers are thus offset by an index of one in the vtbl.</P>
An interface implementor is free to use the memory before and beyond the "as-specified-by-the-standard" vtbl for whatever purpose he may wish; others cannot assume anything about such memory.</P>
 </P></BODY></HTML>
