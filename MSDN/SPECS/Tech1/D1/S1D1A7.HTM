<HTML><HEAD><META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>IRpcChannelBuffer::GetBuffer</TITLE><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">

</OBJECT></FORM>
<H3>IRpcChannelBuffer::GetBuffer</H3>  </P>
<B>HRESULT IRpcChannelBuffer::GetBuffer(pMessage, iid)</B></P>
This method returns a buffer into which data can be marshaled for subsequent transmission over the wire. It is used both by interface proxies and by interface stubs, the former to marshal the incoming arguments for transmission to the server, and the latter to marshal the return values back to the client.</P>
<A NAME="PT2"></A>Upon receipt of an incoming call from the client of the proxy object, interface proxies use GetBuffer() to get a buffer into which they can marshaling the incoming arguments. A new buffer must be obtained for every call operation; old buffers cannot be reused by the interface proxy. The proxy needs to ask for and correctly manage a new buffer even if he himself does not have arguments to marshal (such as a void argument list).<font class="MissingLink" meta="aslch07_FNNine">9.</font> Having marshaled the arguments, the interface proxy then calls SendReceive() to actually invoke the operation. Upon return from SendReceive(), the buffer no longer contains the marshaled arguments but instead contains the marshaled return values (and out parameter values). The interface proxy unmarshals these values, calls FreeBuffer() to free the buffer, then returns to its calling client.</P>
On the server side (in interface stubs), the sequence is somewhat different. The server side will not be explored further here; see instead the description of IRpcStubBuffer::Invoke () for details.</P>
On the client side, the RPCOLEMESSAGE structure argument to GetBuffer() has been allocated and initialized by the caller (or by some other party on the caller's behalf). Interface proxies are to initialize the members of this structure as follows.</P>
  </P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="119pt" VALIGN="TOP"><COL WIDTH="366pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><B>Member Name</B></P></TD><TD VALIGN="TOP"><B>Value to initialize to</B></P></TD></TR><TR><TD VALIGN="TOP">reserved members</P></TD><TD VALIGN="TOP">As always, reserved values must be initialized to zero / NULL.</P></TD></TR><TR><TD VALIGN="TOP">pvBuffer</P></TD><TD VALIGN="TOP">Must be NULL.</P></TD></TR><TR><TD VALIGN="TOP">cbBuffer</P></TD><TD VALIGN="TOP">The size in bytes that the channel should allocate for the buffer; that is, the maximum size in bytes needed to marshal the arguments. The interface proxy will have determined this information by considering the function signature and the particular argument values passed in.</P>
It is explicitly legal to have this value be zero, indicating that that the caller does not himself require a memory buffer.</P></TD></TR><TR><TD VALIGN="TOP">iMethod</P></TD><TD VALIGN="TOP">The zero-based method number in the interface iid which is being invoked</P></TD></TR><TR><TD VALIGN="TOP">dataRepresentation</P></TD><TD VALIGN="TOP">If NDR transfer syntax is being used, then this indicates the byte order, etc., by which the caller will marshal data into the returned buffer.</P></TD></TR><TR><TD VALIGN="TOP">rpcFlags</P></TD><TD VALIGN="TOP">Exact values to be listed here.</P></TD></TR></TBODY></TABLE>
<BR></P><A NAME="PT3"></A>If the GetBuffer() function is successful, then upon function exit pvBuffer will have been changed by the channel to point to a memory buffer of (at least) cbBuffer bytes in size into which the method arguments can now be marshaled (if cbBuffer was zero, pvBuffer may or may not be NULL). The reserved fields in the RPCOLEMESSAGE structure may or may not have been changed by the channel. However, neither the cbBuffer nor iMethod fields of RPCOLEMESSAGE will have been changed; the channel treats these as read-only.<font class="MissingLink" meta="aslch07_FNTen">10.</font> Furthermore, until such time as the now-allocated memory buffer is subsequently freed (see SendReceive() and FreeBuffer()), no party other than the channel may modify any of the data accessible from pMessage with the lone exceptions of the data pointed to by pvBuffer and the member cbBuffer, which may be modified only in limited ways; see below.</P>
The arguments to GetBuffer() are as follows:</P>
  </P>

<TABLE COLS="3" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="124pt" VALIGN="TOP"><COL WIDTH="280pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><B>Argument</B></P></TD><TD VALIGN="TOP"><B>Type</B></P></TD><TD VALIGN="TOP"><B>Description</B></P></TD></TR><TR><TD VALIGN="TOP">pMessage</P></TD><TD VALIGN="TOP">RPCOLEMESSAGE *</P></TD><TD VALIGN="TOP">A message structure initialized as discussed above.</P></TD></TR><TR><TD VALIGN="TOP">iid</P></TD><TD VALIGN="TOP">REFIID</P></TD><TD VALIGN="TOP">The interface identifier of the interface being invoked.</P></TD></TR><TR><TD VALIGN="TOP">return value</P></TD><TD VALIGN="TOP">HRESULT</P></TD><TD VALIGN="TOP">S_OK, E_OUTOFMEMORY, E_UNEXPECTED</P></TD></TR></TBODY></TABLE>
<BR></P> </P></BODY></HTML>
