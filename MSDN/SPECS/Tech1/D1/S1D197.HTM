<HTML><HEAD><META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Caching Interfaces on the Inner Object</TITLE><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">

</OBJECT></FORM>
<H3>Caching Interfaces on the Inner Object</H3>  </P>
In order to avoid reference counting cycles, special action is needed if the outer object wishes to cache pointers to the inner object's interfaces.</P>
Specifically, if the outer object wishes to cache a to an inner object's interface, once it has obtained the interface from the inner object, the outer object should invoke Release on the punkOuter that was given to the inner object at its instantiation time.</P>
  </P>
<BR></P>
<pre><code>// Obtaining inner object interface pointer
pUnkInner-&gt;QueryInterface(IID_IFoo, &amp;pIFoo);
pUnkOuter-&gt;Release();
   
// Releasing inner object interface pointer
pUnkOuter-&gt;AddRef();
pIFoo-&gt;Release();
</code></pre>
  </P>
It is suggested that to allow inner objects to do better resource management that controlling objects delay the acquisition of cached pointers and release them when there is no possible use for them.</P>
 </P></BODY></HTML>
