<HTML><HEAD><META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>IRpcChannelBuffer::SendReceive</TITLE><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">

</OBJECT></FORM>
<H3>IRpcChannelBuffer::SendReceive</H3>  </P>
<B>HRESULT IRpcChannelBuffer::SendReceive(pMessage, pStatus)</B></P>
Cause an invocation to be sent across to the server process. The caller will have first obtained access to a transmission packet in which to marshal the arguments by calling IRpcChannelBuffer::GetBuffer(). The same pMessage structure passed as an argument into that function is passed here to the channel a second time.</P>
In the intervening time period, the method arguments will have been marshaled into the buffer pointed to by pMessage-&gt;pvBuffer. However, the pvBuffer pointer parameter must on entry to SendReceive() be exactly as it was when returned from GetBuffer(). That is, it must point to the start of the memory buffer. The caller should in addition set pMessage-&gt;cbBuffer to the number of bytes actually written into the buffer (zero is explicitly a legal value). No other values accessible from pMessage may be different than they were on exit from GetBuffer().</P>
Upon <I>successful</I> exit from SendReceive(), the incoming buffer pointed to by pvBuffer will have been freed by the channel. In its place will be found a buffer containing the marshaled return values / out parameters from the interface stub: pMessage-&gt;pvBuffer points to the new buffer, and pMessage-&gt;cbBuffer indicates the size thereof. If there are no such return values, then pMessage-&gt;cbBuffer is set to zero, while pMessage-&gt;pvBuffer may or may not be NULL.</P>
<A NAME="PT2"></A>On <I>error</I> exit from SendReceive(),<font class="MissingLink" meta="aslch07_FNEleven">11.</font> the incoming buffer pointed to by pvBuffer may or may not have been freed. If it has been freed, then on error exit pMessage-&gt;pvBuffer is set to NULL and pMessage-&gt;cbBuffer is set to zero. If in contrast, pMessage-&gt;pvBuffer is on error exit not NULL, then that pointer, the data to which it points, and the value pMessage-&gt;cbBuffer will contain exactly as they did on entry; that is, the marshaled arguments will not have been touched. Thus, on error exit from SendReceive(), in no case are any marshaled <I>return values</I> passed back; if a marshaling buffer is in fact returned, then it contains the marshaled <I>arguments</I> as they were on entry.</P>
The exact cases on error exit when the incoming buffer has or has not been freed needs careful attention. There are three cases:</P>
<SPAN CLASS="list"><OL><LI>The channel implementation knows with certainty either that all of the incoming data was successfully unmarshaled or that if any errors occurred during unmarshaling that the interface stub correctly cleaned up. In practical terms, this condition is equivalent to the stub manager having actually called IRpcStubBuffer::Invoke() on the appropriate interface stub. In this case, on exit from SendReceive() the incoming arguments will <I>always</I> have been freed.</LI><LI>The channel implementation knows with certainty the situation in case 1 has <I>not</I> occurred. In this case, on exit from SendReceive(), the incoming arguments will <I>never</I> have been freed.</LI><LI>The channel implementation does not know with certainty that either of the above two cases has occurred. In this case, on exit from SendReceive(), the incoming arguments will <I>always</I> have been freed. This is a possible resource leakage (due to, for example, CoReleaseMarshalData() calls that never get made), but it safely avoids freeing resources that should not be freed.</LI></OL></SPAN>If pMessage-&gt;pvBuffer is returned as non-NULL, then the caller is responsible for subsequently freeing it; see FreeBuffer(). A returned non-NULL pMessage-&gt;pvBuffer may in general legally be (and will commonly be, the success case) different than the (non-NULL) value on entry; for example, the buffer may be legally be reallocated. Further, between the return from SendReceive() and the subsequent freeing call no data accessible from pMessage may be modified, with the possible exception of the data actually in the memory buffer.</P>
Upon successful exit from SendReceive(), the pMessage-&gt;dataRepresentation field will have been modified to contain whatever was returned by the interface stub in field of the same name value on exit to IRpcStubBuffer::Invoke(). This is particularly important when NDR transfer syntax is used, as dataRepresentation indicates critical things (such as byte order) which apply to the marshaled return / out values. Upon error exit from SendReceive(), pMessage-&gt;dataRepresentation is undefined.</P>
  </P>

<TABLE COLS="3" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="128pt" VALIGN="TOP"><COL WIDTH="289pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><B>Argument</B></P></TD><TD VALIGN="TOP"><B>Type</B></P></TD><TD VALIGN="TOP"><B>Description</B></P></TD></TR><TR><TD VALIGN="TOP">pMessage</P></TD><TD VALIGN="TOP">RPCOLEMESSAGE *</P></TD><TD VALIGN="TOP">Message structure containing information to transmit to server.</P></TD></TR><TR><TD VALIGN="TOP">pStatus</P></TD><TD VALIGN="TOP">ULONG *</P></TD><TD VALIGN="TOP">May legally be NULL. If non-NULL, then if either (i) an RPC-infrastructure-detected server-object fault (such as a server object bug caused an exception which was caught by the RPC infrastructure), or (ii) an RPC communications failure occurs, then at this location a status code is written which describes what happened. In the two error cases, the errors E_RPCFAULT and E_RPCSTATUS are (respectively) returned (and are always returned when these errors occur, irrespective of the NULL-ness of pStatus).</P></TD></TR><TR><TD VALIGN="TOP">return value</P></TD><TD VALIGN="TOP">HRESULT</P></TD><TD VALIGN="TOP">S_OK, E_RPCFAULT, E_RPCSTATUS</P></TD></TR></TBODY></TABLE>
<BR></P> </P></BODY></HTML>
