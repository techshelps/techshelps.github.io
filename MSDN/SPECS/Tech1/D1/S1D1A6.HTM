<HTML><HEAD><META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>RPCOLEMESSAGE and Related Structures</TITLE><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">

</OBJECT></FORM>
<H3>RPCOLEMESSAGE and Related Structures</H3>  </P>
Common to several of the methods in IRpcChannelBuffer is a data structure of type RPCOLEMESSAGE. This structure is defined as is show below. The structure is to be packed so that there are no holes in its memory layout.</P>
  </P>
<BR></P>
<pre><code><A NAME="PT2"></A>typedef struct RPCOLEMESSAGE {
   void *            reserved1;
   RPCOLEDATAREP      <B>dataRepresentation</B>;   // in NDR transfer syntax: info about endianness, etc.
   void    *            <B>pvBuffer</B>;            // memory buffer used for marshalling
   ULONG            <B>cbBuffer</B>;            // size of the marshalling buffer
   ULONG            <B>iMethod</B>;            // the method number being invoked
   void *            reserved2[5];
   ULONG            <B>rpcFlags</B>;
   } on the ultimate destination computer <B>MESSAGE</B>;<font class="MissingLink" meta="aslch07_FNEight">8.</font></code></pre>
  </P>
The most significant member of this structure is pvBuffer. It is through the memory buffer to which pvBuffer points that marshaled method arguments are transferred. cbBuffer is used to indicate the size of the buffer. iMethod is indicates a particular method number within the interface being invoked. The IID of that interface is identified through other means: on the client side as a parameter to GetBuffer(), and on the server side as part of the internal state of each interface stub.</P>
At all times all reserved values in this structure are to be initialized to zero by non-RPC-infrastructure parties (such as parties other than the channel / RPC runtime implementor) who allocate RPCOLEMESSAGE structures. However, the RPC channel (more generally, the RPC runtime infrastructure) is free to modify these reserved fields. Therefore, once initialized, the reserved fields must be ignored by the initializing code; they cannot be relied on to remain as zero. Further, there are very carefully specified rules as to what values in these structures may or may not be modified at various times and by which parties. In almost all cases, aside from actually reading and writing data from the marshaling buffer, which is done by proxies and stubs, only the channel may change these fields. See the individual method descriptions for details.</P>
Readers familiar with the connection-oriented DCE protocol may notice that the <I>transfer syntax</I> used for marshaling the arguments, the particular set of rules and conventions according to which data is marshaled, is not explicitly called out. Architecturally speaking, it is only the interface proxy for a given interface and its corresponding interface stub that cares at all about what set of marshaling rules is in fact used. However, in the general case these interface proxies and stubs may be installed on different computers with a network in the middle, be written by different development organizations on different operating systems, and so forth. Accordingly, in cases where the author of an interface proxy for a given IID cannot guarantee that all copies of the corresponding interface stub are in fact always revised and updated in synchrony with his interface proxy, a well-defined convention should be used for the transfer syntax. Indeed, formal transfer syntax standards exist for this purpose. The one most commonly used is known as Network Data Representation (NDR), originally developed by Apollo Corporation and subsequently enhanced and adopted by the Open Software Foundation as part of their Distributed Computing Environment (DCE). The Windows NT operating system also uses NDR in its RPC implementation. Unless very good reasons exist to do otherwise, programmers are encouraged to use the NDR transfer syntax.</P>
When NDR transfer syntax is used (and whether it <I>is</I> in use or not is implicitly known by the proxy or stub), the member dataRepresentation provides further information about the rules by which data in the buffer is marshaled. NDR is a <I>multi-canonical </I>standard, meaning that rather than adopting one standard for things like byte-order, character set, and so forth, multiple standards (a fixed set of them) are accommodated. Specifically, this is accommodated by a <I>reader-make-right </I>policy: the writer / marshaler of the data is free to write the data in any of the supported variations and the reader / unmarshaler is expected to be able to read any of them. The particular data type in use is conveyed in an RPCOLEDATAREP structure, which is defined as follows. Note that this structure, too, is packed; the size of the entire structure is exactly four bytes. The actual layout of the structure in all cases always corresponds to the data representation value as defined in the DCE standard; the particular structure shown here is equivalent to that layout in Microsoft's and other common compilers.</P>
  </P>
<BR></P>
<pre><code>typedef RPCOLEDATAREP {
   UINT      <B>uCharacterRep</B>    : 4;      // least signficant nibble of first byte
   UINT      <B>uByteOrder</B>      : 4;      // most signficant nibble of first byte
   BYTE      <B>uFloatRep</B>;
   BYTE      <B>uReserved</B>;
   BYTE      <B>uReserved2</B>;
   } <B>RPCOLEDATAREP</B>;</code></pre>
  </P>
The values which may legally be found in these fields are as shown in this table. Further information on the interpretation of this field can be found in the NDR Transfer Syntax standards documentation.</P>
  </P>

<TABLE COLS="4" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="101pt" VALIGN="TOP"><COL WIDTH="117pt" VALIGN="TOP"><COL WIDTH="70pt" VALIGN="TOP"><COL WIDTH="141pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><B>Field Name</B></P></TD><TD VALIGN="TOP"><B>Meaning of Field</B></P></TD><TD VALIGN="TOP"><B>Value in field</B></P></TD><TD VALIGN="TOP"><B>Interpretation</B></P></TD></TR><TR><TD VALIGN="TOP">uCharacterRep</P></TD><TD VALIGN="TOP">determines interpretation of single-byte-character valued and single-byte-string valued entities</P></TD><TD VALIGN="TOP">0</P>
1</P></TD><TD VALIGN="TOP">ASCII</P>
EBCDIC</P></TD></TR><TR><TD VALIGN="TOP">uByteOrder</P></TD><TD VALIGN="TOP">integer and floating point byte order</P></TD><TD VALIGN="TOP">0</P>
1</P></TD><TD VALIGN="TOP">Big-endian (Motorola)</P>
Little-endian (Intel)</P></TD></TR><TR><TD VALIGN="TOP">uFloatRep</P></TD><TD VALIGN="TOP">representation of floating point numbers</P></TD><TD VALIGN="TOP">0</P>
1</P>
2</P>
3</P></TD><TD VALIGN="TOP">IEEE</P>
VAX</P>
Cray</P>
IBM</P></TD></TR></TBODY></TABLE>
<BR></P><B>Table. Interpretation of dataPresentation</B></P>
 </P></BODY></HTML>
