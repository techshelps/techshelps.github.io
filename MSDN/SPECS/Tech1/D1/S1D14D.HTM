<HTML><HEAD><META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Globally Unique Identifiers</TITLE><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">

</OBJECT></FORM>
<H2>Globally Unique Identifiers</H2>  </P>
As mentioned earlier in this document, the GUID, from which are also obtained CLSID, IIDs, and any other needed unique identifier, is a 128-bit, or 16-byte, value. The term GUID as used in this specification is completely synonymous and interchangeable with the term "UUID" as used by the DCE RPC architecture; they are indeed one and the same notion. In binary terms, a GUID is a data structure defined as follows, where DWORD is 32-bits, WORD is 16-bits, and BYTE is 8-bits:</P>
  </P>
<BR></P>
<pre><code>typedef struct GUID    {
   DWORD   Data1;
   WORD    Data2;
   WORD    Data3;
   BYTE    Data4[8];
   } <B>GUID</B>;</code></pre>
  </P>
This structure provides applications with some way of addressing the parts of a GUID for debugging purposes, if necessary. This information is also needed when GUIDs are transmitted between computers of different byte orders.</P>
For the most part, applications never manipulate GUIDs directly—they are almost always manipulated either as a constant, such as with interface identifiers, or as a variable of which the absolute value is unimportant. For example, a client might enumerate all object classes registered on the system and display a list of those classes to an end user. That user selects a class from the list which the client then maps to an absolute CLSID value. The client does not care what that value is—it simply knows that it uniquely identifies the object that the user selected.</P>
The GUID design allows for coexistence of several different allocation technologies, but the one by far most commonly used incorporates a 48-bit computer unique identifier together with the current UTC time and some persistent backing store to guard against retrograde clock motion. It is in theory capable of allocating GUIDs at a rate of 10,000,000 per second per computer for the next 3,240 years, enough for most purposes.</P>
<A NAME="PT3"></A>For further information regarding GUID allocation technologies, see pp585-592 of [CAE RPC].<font class="MissingLink" meta="aslch03_FNFive">5.</font></P>
</P>
 </P></BODY></HTML>
