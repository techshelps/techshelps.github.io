<HTML><HEAD><META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CoRevokeClassObject</TITLE><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">

</OBJECT></FORM>
<H3>CoRevokeClassObject</H3>  </P>
<B>HRESULT CoRevokeClassObject(dwRegister)</B></P>
Informs the COM Library that a class factory previously registered with CoRegisterClassObject is no longer available for use. Server applications call this function on shutdown after having detected the necessary unloading conditions.</P>
<SPAN CLASS="list"><UL><LI>There are no instances of the class in existence; that is, the object count is zero.</LI><LI>The class factory has a zero number of locks from IClassFactory::LockServer<I>.</I></LI><LI>The application servicing the class object is not showing itself to the user; that is, not under user control.</LI></UL></SPAN>When, subsequently, the reference count on the class object reaches zero, the class object can be destroyed, allowing the application to exit.</P>
  </P>

<TABLE COLS="3" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="92pt" VALIGN="TOP"><COL WIDTH="73pt" VALIGN="TOP"><COL WIDTH="249pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><B>Argument</B></P></TD><TD VALIGN="TOP"><B>Type</B></P></TD><TD VALIGN="TOP"><B>Description</B></P></TD></TR><TR><TD VALIGN="TOP">dwRegister</P></TD><TD VALIGN="TOP">DWORD</P></TD><TD VALIGN="TOP">A token previously returned from CoRegisterclassObject.</P></TD></TR></TBODY></TABLE>
<BR></P></P>
  </P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="155pt" VALIGN="TOP"><COL WIDTH="249pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><B>Return Value</B></P></TD><TD VALIGN="TOP"><B>Meaning</B></P></TD></TR><TR><TD VALIGN="TOP">S_OK</P></TD><TD VALIGN="TOP">Success.</P></TD></TR><TR><TD VALIGN="TOP">E_UNEXPECTED</P></TD><TD VALIGN="TOP">An unknown error occurred.</P></TD></TR></TBODY></TABLE>
<BR></P>The structure of a server application with its object and class factory is illustrated in Figure 6-2. This figure also illustrates the sequence of calls and events that happen when the client executes the standard object creation sequence of CoGetClassObject<I> </I>and<I> </I>IClassFactory::CreateInstance.</P>
<img src="ASL1G.gif"></P>
<B>Figure 6-2: Creation sequence of an object from a server application. Function calls not in COM are from the Windows API.</B></P>
Compare this figure with .DLL server Figure 6-1 in the previous section. You'll notice that the structure of the server is generally the same that is: both have their object and class factory. You'll also notice that the creation sequence from the client's point of view is identical. Again, once the client determines the CLSID of the desired object that client leaves the specifics up to CoGetClassObject. The only differences between the two figures occur inside the COM Library and the specific means of exposing the class factory from the server (along with the unloading mechanism).</P>
Finally, CoRegisterClassObject<I> </I>and CoRevokeClassObject along with when a server calls them demonstrate why a reference count on the class factory is insufficient to keep a server in memory and why IClassFactory::LockServer exists. CoRegisterClassObject must, in order to be implemented properly, hold on to the IUnknown pointer passed to it (that is, the class factory). The reference counting rules state that CoRegisterClassObject must call AddRef on that pointer accordingly. This reference count can only be removed inside CoRevokeClassObject.</P>
However, CoRevokeClassObject is only called on application shutdown and not at any other time. How does the server know when to start its shutdown sequence? Since it has to <I>be</I> in the process of shutting down to have the final reference counts on the class factory released through CoRevokeClassObject, it cannot use the reference count to determine when to start the shutdown process in the first place. Therefore there has to be another mechanism through which shutdown is controlled which is IClassFactory::LockServer.</P>
</P>
 </P></BODY></HTML>
