<HTML><HEAD><META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>COM Application Responsibilities</TITLE><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">

</OBJECT></FORM>
<H3>COM Application Responsibilities</H3>  </P>
Each process that uses COM in any way—client, server, object implementor—is responsible for three things:</P>
<SPAN CLASS="list"><OL><LI>Verify that the COM Library is a compatible version with the COM function CoBuildVersion<I>.</I></LI><LI>Initialize the COM Library before using any other functions in it by calling the COM function CoInitialize.</LI><LI>Un-initialize the COM Library when it is no longer in use by calling the COM function CoUninitialize<I>.</I></LI></OL></SPAN>While these responsibilities and functions are covered in detail in Chapter 4, note first that most COM Library functions, primarily those that deal with the COM foundation, are prefixed with "Co" to identify their origin. The COM Library may implement other functions to support persistent storage, naming, and data transfer without the "Co" prefix.</P>
<A NAME="PT3"></A>Memory Management Rules</P>
In COM there are many interface member functions and APIs which are called by code written by one programming organization and implemented by code written by another. Many of the parameters and return values of these functions are of types that can be passed around by value; however, sometimes there arises the need to pass data structures for which this is not the case, and for which it is therefore necessary that the caller and the callee agree as to the allocation and de-allocation policy. This could in theory be decided and documented on an individual function by function basis, but it is much more reasonable to adopt a universal convention for dealing with these parameters. Also, having a clear convention is important technically in order that the COM remote procedure call implementation can correctly manage memory.</P>
Memory management of pointers to interfaces is always provided by member functions in the interface in question. For all the COM interfaces these are the AddRef and Release functions found in the IUnknown<I> </I>interface, from which again all other COM interfaces derive (as described earlier in this chapter). This section relates only to non-by-value parameters which are <I>not</I> pointers to interfaces but are instead more mundane things like strings, pointers to structures, and so forth.</P>
<A NAME="PT4"></A>The COM Library provides an implementation of a memory allocator (see CoGetMalloc and CoTaskMemAlloc). Whenever ownership of an allocated chunk of memory is passed through a COM interface or between a client and the COM library, this allocator must be used to allocate the memory.<font class="MissingLink" meta="FNTwo">2.</font></P>
Each parameter to and the return value of a function can be classified into one of three groups: an <B>in</B> parameter, an <B>out</B> parameter (which includes return values), or an <B>in-out</B> parameter. In each class of parameter, the responsibility for allocating and freeing non-by-value parameters is the following:</P>
<SPAN CLASS="list"><UL><LI><B>in</B> parameter Allocated and freed by the caller.</LI><LI><B>out</B> parameter Allocated by the callee; freed by the caller.</LI><LI><B>in-out</B> parameter Initially allocated by the caller, then freed and re-allocated by the callee if necessary. As with out parameters, the caller is responsible for freeing the final returned value.</LI></UL></SPAN>In the latter two cases there is one piece of code that allocates the memory and a different piece of code that frees it. In order for this to be successful, the two pieces of code must of course have knowledge of which memory allocator is being used. Again, it is often the case that the two pieces of code are written by independent development organizations. To make this work, we require that the COM allocator be used.</P>
Further, the treatment of out and in-out parameters in failure conditions needs special attention. If a function returns a status code which is a failure code, then in general the caller has no way to clean up the <I>out </I>or <I>in-out </I>parameters. This leads to a few additional rules:</P>
<SPAN CLASS="list"><UL><LI><A NAME="PT5"></A><B>out</B> parameter<B>  </B>In error returns, out parameters must be <I>always </I>reliably set to a value which will be cleaned up without any action on the caller's part. Further, it is the case that all out pointer parameters (usually passed in a pointer-to-pointer parameter, but which can also be passed as a member of a caller-allocate callee-fill structure) <I>must</I> explicitly be set to NULL. The most straightforward way to ensure this is (in part) to set these values to NULL on function entry.<font class="MissingLink" meta="FNThree">3.</font></LI><LI>    (On success returns, the semantics of the function of course determine the legal return values.)</LI><LI><B>in-out</B> parameter<B>  </B>In error returns, all in-out parameters must either be left alone by the callee (and thus remaining at the value to which it was initialized by the caller; if the caller didn't initialize it, then it's an out parameter, not an in-out parameter) or be explicitly set as in the out parameter error return case.</LI></UL></SPAN>The specific COM APIs and interfaces that apply to memory management are discussed further below.</P>
Remember that these memory management conventions for COM applications apply only across public interfaces and APIs—there is no requirement at all that memory allocation strictly internal to a COM application need be done using these mechanisms.</P>
 </P></BODY></HTML>
