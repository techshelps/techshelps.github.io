<HTML><HEAD><META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CoGetClassObject</TITLE><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">

</OBJECT></FORM>
<H3>CoGetClassObject</H3>  </P>
<B>HRESULT CoGetClassObject(clsid, grfContext, pServerInfo, iid, ppv)</B></P>
<A NAME="PT2"></A>Locate and connect to the class factory object associated with the class identifier clsid. If necessary, the COM Library dynamically loads executable code in order to accomplish this. The interface by which the caller wishes to talk to the class factory object is indicated by iid; this is usually IID_IClassFactory but can, of course, be any other object-creation interface.<font class="MissingLink" meta="aslch05_FNTwo">2.</font> The class factory's interface is returned in ppv with one reference count on it on behalf of the caller, that is, the caller is responsible for calling Release after it has finished using the class factory object.</P>
Different pieces of code can be associated with one CLSID for use in different execution contexts such as in-process, local, or object handler. The context in which the caller is interested is indicated by the grfContext parameter, a group of flags taken from the enumeration CLSCTX:</P>
  </P>
<BR></P>
<pre><code>typedef enum tagCLSCTX {
.....CLSCTX_INPROC_SERVER..........= 1,
.....CLSCTX_INPROC_HANDLER.....= 2,
.....CLSCTX_LOCAL_SERVER..........= 4,
.....CLSCTX_REMOTE_SERVER..........= 16.
.....} <B>CLSCTX</B>;</code></pre>
  </P>
The several contexts are tried in the sequence in which they are listed here. Multiple values may be combined (using bitwise OR) indicating that multiple contexts are acceptable to the caller:</P>
  </P>
<BR></P>
<pre><code>#define <B>CLSCTX_INPROC </B>.....(CLSCTX_INPROC_SERVER | CLSCTX_INPROC_HANDLER)
#define <B>CLSCTX_SERVER</B> .....(CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER | CLSCTX_REMOTE_SERVER)
#define <B>CLSCTX_ALL</B>..........(CLSCTX_INPROC_SERVER | CLSCTX_INPROC_HANDLER | CLSCTX_LOCAL_SERVER | CLSCTX_REMOTE_SERVER)</code></pre>
  </P>
These context values have the following meanings which apply to all remote servers as well:</P>
  </P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="169pt" VALIGN="TOP"><COL WIDTH="267pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><B>Value</B></P></TD><TD VALIGN="TOP"><B>Action Taken by the COM Library</B></P></TD></TR><TR><TD VALIGN="TOP">CLSCTX_INPROC_SERVER</P></TD><TD VALIGN="TOP">Load the in-process code (.DLL) which creates and completely manages the objects of this class. If the .DLL is on a remote computer, invoke a surrogate server as well to load the .DLL.</P></TD></TR><TR><TD VALIGN="TOP">CLSCTX_INPROC_HANDLER</P></TD><TD VALIGN="TOP">Load the in-process code (.DLL) which implements client-side structures of this class when instances of it are accessed remotely. An object handler generally implements object functionality which can only be implemented from an in-process module, relying on a local server for the remainder of the implementation.<font class="MissingLink" meta="aslch05_FNThree">3.</font></P></TD></TR><TR><TD VALIGN="TOP">CLSCTX_LOCAL_SERVER</P></TD><TD VALIGN="TOP">Launch the separate-process code (.EXE) which creates and manages the objects of this class.<font class="MissingLink" meta="aslch05_FNFour"> 4.</font>.</P></TD></TR><TR><TD VALIGN="TOP">CLSCTX_REMOTE_SERVER</P></TD><TD VALIGN="TOP">Launch the separate-process code (.EXE) on another computer which creates and manages objects of this class.</P></TD></TR></TBODY></TABLE>
<BR></P>The COM Library should attempt to load in-process servers first, then in-process handlers, then local servers, then remote servers. This order helps to minimize the frequency with which the library has to launch separate server applications which is generally a much more time-consuming operation than loading a .DLL, especially across the network.</P>
When specifying CLSCTX_REMOTE_SERVER, the caller may pass a COMSERVERINFO structure to indicate the computer on which to run the server module, which is defined as follows:</P>
  </P>
<BR></P>
<pre><code><A NAME="PT3"></A>typedef struct tagCOMSERVERINFO {
.....OLECHAR.....*szRemoteSCMBindingHandle;
.....} <B>COMSERVERINFO</B>;<font class="MissingLink" meta="aslch05_FNFive">5.</font></code></pre>
  </P>
The COM Library implementation of this CoGetClassObject relies on the system registry to map the CLSID to the server module to load or launch, but this process is opaque to the client application. If, however, COM cannot make any association then the function fails with the code REGDB_E_CLASSNOTREG. If this function launches a server application it must wait until that server registers its class factory or until a time-out occurs (duration determined by COM, something on the order of a minute of processing time). See the CoRegisterClassObject function in Chapter 6 under "Exposing the Class Factory from Local Servers."</P>
The arguments to this function are as follows:</P>
  </P>

<TABLE COLS="3" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="101pt" VALIGN="TOP"><COL WIDTH="123pt" VALIGN="TOP"><COL WIDTH="235pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><B>Argument</B></P></TD><TD VALIGN="TOP"><B>Type</B></P></TD><TD VALIGN="TOP"><B>Description</B></P></TD></TR><TR><TD VALIGN="TOP">clsid</P></TD><TD VALIGN="TOP">REFCLSID</P></TD><TD VALIGN="TOP">The class of the class factory to obtain.</P></TD></TR><TR><TD VALIGN="TOP">grfContext</P></TD><TD VALIGN="TOP">DWORD</P></TD><TD VALIGN="TOP">The context in which the executable code is to run.</P></TD></TR><TR><TD VALIGN="TOP">pServerInfo</P></TD><TD VALIGN="TOP">COMSERVERINFO*</P></TD><TD VALIGN="TOP">Identifies the computer on which to activate the executable code. Must be NULL when grfContext does not contain CLSCTX_REMOTE_SERVER. When NULL and grfContext contains CLSCTX_REMOTE_SERVER, COM uses the default computer location for this class.</P></TD></TR><TR><TD VALIGN="TOP">iid</P></TD><TD VALIGN="TOP">REFIID</P></TD><TD VALIGN="TOP">The interface on the class factory object desired by the caller.</P></TD></TR><TR><TD VALIGN="TOP">ppv</P></TD><TD VALIGN="TOP">void **</P></TD><TD VALIGN="TOP">The place in which to put the requested interface.</P></TD></TR></TBODY></TABLE>
<BR></P></P>
  </P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="160pt" VALIGN="TOP"><COL WIDTH="289pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><B>Return Value</B></P></TD><TD VALIGN="TOP"><B>Meaning</B></P></TD></TR><TR><TD VALIGN="TOP">S_OK</P></TD><TD VALIGN="TOP">Success.</P></TD></TR><TR><TD VALIGN="TOP">REGDB_E_CLASSNOTREG</P></TD><TD VALIGN="TOP">An implementation of the requested class could not be located.</P></TD></TR><TR><TD VALIGN="TOP">E_OUTOFMEMORY</P></TD><TD VALIGN="TOP">Memory could not be allocated to service the request.</P></TD></TR><TR><TD VALIGN="TOP">E_UNEXPECTED</P></TD><TD VALIGN="TOP">An unknown error occurred.</P></TD></TR></TBODY></TABLE>
<BR></P>The following code fragment demonstrates how a client would call CoGetClassObject and create an in-process instance of the TextRender object with CLSID_TextRender using the class factory to request an IUnknown pointer for the object. In this example the client is explicitly limiting COM to use only in-process servers:</P>
  </P>
<BR></P>
<pre><code>IClassFactory *.....pCF;
IUnknown *      .....pUnkObj;
HRESULT        .....hr;

hr=CoGetClassObject(CLSID_TextRender, CLSCTX_INPROC_SERVER, NULL, IID_IClassFactory, (void *)pCF);
if (FAILED(hr))
.....//Could not obtain class factory, creation fails completely.

/*
 * Create the object. If this call succeeds the pUnkObj will 
 * be valid and have a reference count on it on behalf of the caller
 * which the caller must Release.
 */
hr=pCF-&gt;CreateInstance(NULL, IID_IUnknown, (void *)pUnkObj);

//Caller must call Release regardless of CreateInstance result
pCF-&gt;Release();

if (FAILED(hr))
.....//Object creation failed: interface may not be supported

/*
 * Now use the object in whatever capacity the caller desires.
 * The first step will be initialization.
 */

//Release the object when finished with it.
pUnkObj-&gt;Release();</code></pre>
  </P>
Since the process of calling CoGetClassObject<I>, </I>IClassFactory::CreateInstance<I>, </I>and IClassFactory::Release is so common in practice, the COM Library provides a wrapper API function for this sequence called CoCreateInstance. This allows the client to avoid the whole issue of class factory objects entirely. However, CoCreateInstance only creates one object at a time; if the client wants to create multiple objects of the same class at once, it is more efficient to obtain the class factory directly and call IClassFactory::CreateInstance multiple times, avoiding excess calls to CoGetClassObject and IClassFactory::Release.</P>
 </P></BODY></HTML>
