<HTML><HEAD><META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CoRegisterClassObject</TITLE><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">

</OBJECT></FORM>
<H3>CoRegisterClassObject</H3>  </P>
<B>HRESULT CoRegisterClassObject(clsid, pUnk, grfContext, grfFlags, pdwRegister)</B></P>
Registers the specified server class factory identified with <I>pUnk </I>with COM in order that it may be connected to by COM Clients. When a server application starts, it creates each class factory it supports and passes them to this function. When a server application exits, it revokes all its registered class objects with CoRevokeClassObject.</P>
Note that an in-process object could call this function to expose a class factory only when the .DLL is already loaded in another process and did not want to expose a class factory until it was loaded for some other reason.</P>
The grfContext<I> </I>flag identifies the execution context of the server and is usually CLSCTX_LOCAL_SERVER. The grfFlags<I> </I>is used to control how connections are made to the class object. Values for this parameter are the following:</P>
  </P>
<BR></P>
<pre><code>typedef enum tagREGCLS
   {
   REGCLS_SINGLEUSE = 0,
   REGCLS_MULTIPLEUSE = 1,
   REGCLS_MULTI_SEPARATE = 2
   } <B>REGCLS</B>;
</code></pre>
  </P>
  </P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="173pt" VALIGN="TOP"><COL WIDTH="280pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><B>Value</B></P></TD><TD VALIGN="TOP"><B>Description</B></P></TD></TR><TR><TD VALIGN="TOP">REGCLS_SINGLEUSE</P></TD><TD VALIGN="TOP">Once one client has connected to the class object with CoGetClassObject, then the class object should be removed from public view so that no other clients can similarly connect to it; new clients will use a new instance of the class factory, running a new copy of the server application if necessary. Specifying this flag does not affect the responsibility of the server to call CoRevokeClassObject<I> </I>on shutdown.</P></TD></TR><TR><TD VALIGN="TOP">REGCLS_MULTIPLEUSE</P></TD><TD VALIGN="TOP">Many CoGetClassObject calls can connect to the same class factory.</P>
When a class factory is registered from a local server (grfContext<I> </I>is CLSCTX_LOCAL_SERVER) and grfFlags<I> </I>includes REGCLS_MULTIPLEUSE, then it is the case that the same class factory will be <I>automatically also registered</I> as the in-process server (CLSCTX_IN-PROC_SERVER) for its own process.</P></TD></TR><TR><TD VALIGN="TOP">REGCLS_MULTI_SEPARATE</P></TD><TD VALIGN="TOP">The same as REGCLS_MULTIPLEUSE, except that registration as a local server does <I>not</I> automatically also register as an in-process server in that same process (or any other, for that matter).</P></TD></TR></TBODY></TABLE>
<BR></P>Thus, registering as</P>
  </P>
<BR></P>
<pre><code>   CLSCTX_LOCAL_SERVER, REGCLS_MULTIPLEUSE</code></pre>
  </P>
is the equivalent to registering as</P>
  </P>
<BR></P>
<pre><code>   (CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER), REGCLS_MULTI_SEPARATE</code></pre>
  </P>
but is different than registering as</P>
  </P>
<BR></P>
<pre><code>   CLSCTX_LOCAL_SERVER, REGCLS_MULTI_SEPARATE.</code></pre>
  </P>
By using REGCLS_MULTI_SEPARATE, an object implementation can cause different class factories to be used according to whether or not it is being created from within the same process as it is implemented.</P>
The following table summarizes the allowable flag combinations and the registrations that are effected by the various combinations:</P>
<P></P>

<TABLE COLS="7" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="109pt" VALIGN="TOP"><COL WIDTH="63pt" VALIGN="TOP"><COL WIDTH="27pt" VALIGN="TOP"><COL WIDTH="104pt" VALIGN="TOP"><COL WIDTH="119pt" VALIGN="TOP"><COL WIDTH="28pt" VALIGN="TOP"><COL WIDTH="36pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD COLSPAN="2" VALIGN="TOP"></P></TD></TR><TR><TD VALIGN="TOP">___</P></TD></TR></TBODY></TABLE>
<BR></P>  </P>

<TABLE COLS="5" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="109pt" VALIGN="TOP"><COL WIDTH="91pt" VALIGN="TOP"><COL WIDTH="104pt" VALIGN="TOP"><COL WIDTH="119pt" VALIGN="TOP"><COL WIDTH="64pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><B>REGCLS<BR>_SINGLEUSE </B></P></TD><TD VALIGN="TOP">REGCLS<BR>_MULTIPLEUSE</P></TD><TD VALIGN="TOP">REGCLS<BR>_MULTI_SEPARATE </P></TD><TD VALIGN="TOP"><B>Other</B></P></TD></TR><TR><TD VALIGN="TOP">_</P></TD></TR></TBODY></TABLE>
<BR></P></P>

<TABLE COLS="5" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="109pt" VALIGN="TOP"><COL WIDTH="91pt" VALIGN="TOP"><COL WIDTH="104pt" VALIGN="TOP"><COL WIDTH="119pt" VALIGN="TOP"><COL WIDTH="64pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP">CLSCTX_IN-<BR>PROC_SERVER </P></TD><TD VALIGN="TOP"><I>error</I></P></TD><TD VALIGN="TOP">In-Process </P></TD><TD VALIGN="TOP">In-Process</P></TD><TD VALIGN="TOP"><I>error</I></P></TD></TR><TR><TD VALIGN="TOP">CLSCTX_LOCAL<BR>_SERVER</P></TD><TD VALIGN="TOP">Local</P></TD><TD VALIGN="TOP">In-Process/Local</P></TD><TD VALIGN="TOP"><B>Just Local</B></P></TD><TD VALIGN="TOP"><I>error</I></P></TD></TR><TR><TD VALIGN="TOP">Both of the above</P></TD><TD VALIGN="TOP"><I>error</I></P></TD><TD VALIGN="TOP">In-Process/Local</P></TD><TD VALIGN="TOP">In-Process/Local</P></TD><TD VALIGN="TOP"><I>error</I></P></TD></TR><TR><TD VALIGN="TOP">Other</P></TD><TD VALIGN="TOP"><I>error</I></P></TD><TD VALIGN="TOP"><I>error</I></P></TD><TD VALIGN="TOP"><I>error</I></P></TD><TD VALIGN="TOP"><I>error</I></P></TD></TR></TBODY></TABLE>
<BR></P>The key difference is in the middle columns and the middle rows. In the REGCLS_MULTIPLEUSE column, they are the same (registers multiple use for both InProc and local); in the REGCLS_MULTI_SEPARATE column, the local server case is local only.</P>
The arguments to this function are as follows:</P>
  </P>

<TABLE COLS="3" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="97pt" VALIGN="TOP"><COL WIDTH="91pt" VALIGN="TOP"><COL WIDTH="231pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><B>Argument</B></P></TD><TD VALIGN="TOP"><B>Type</B></P></TD><TD VALIGN="TOP"><B>Description</B></P></TD></TR><TR><TD VALIGN="TOP">rclsid</P></TD><TD VALIGN="TOP">REFCLSID</P></TD><TD VALIGN="TOP">The CLSID of the class factory being registered.</P></TD></TR><TR><TD VALIGN="TOP">pUnk</P></TD><TD VALIGN="TOP">IUnknown *</P></TD><TD VALIGN="TOP">The class factory whose availability is being published.</P></TD></TR><TR><TD VALIGN="TOP">grfContext</P></TD><TD VALIGN="TOP">DWORD</P></TD><TD VALIGN="TOP">As in CoGetClassObject.</P></TD></TR><TR><TD VALIGN="TOP">grfFlags</P></TD><TD VALIGN="TOP">DWORD</P></TD><TD VALIGN="TOP">REGCLS values that control the use of the class factory.</P></TD></TR><TR><TD VALIGN="TOP">pdwRegister</P></TD><TD VALIGN="TOP">DWORD *</P></TD><TD VALIGN="TOP">A place at which a token is passed back with which this registration can be revoked in CoRevokeClassObject.</P></TD></TR></TBODY></TABLE>
<BR></P></P>
  </P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="124pt" VALIGN="TOP"><COL WIDTH="285pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><B>Return Value</B></P></TD><TD VALIGN="TOP"><B>Meaning</B></P></TD></TR><TR><TD VALIGN="TOP">S_OK</P></TD><TD VALIGN="TOP">Success.</P></TD></TR><TR><TD VALIGN="TOP">CO_E_OBJISREG</P></TD><TD VALIGN="TOP">Error. The indicated class is already registered.</P></TD></TR><TR><TD VALIGN="TOP">E_OUTOFMEMORY</P></TD><TD VALIGN="TOP">Memory could not be allocated to service the request.</P></TD></TR><TR><TD VALIGN="TOP">E_UNEXPECTED</P></TD><TD VALIGN="TOP">An unknown error occurred.</P></TD></TR></TBODY></TABLE>
<BR></P> </P></BODY></HTML>
