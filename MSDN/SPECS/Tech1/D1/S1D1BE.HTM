<HTML><HEAD><META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>IMarshal::GetUnmarshalClass</TITLE><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">

</OBJECT></FORM>
<H3>IMarshal::GetUnmarshalClass</H3>  </P>
<B>HRESULT IMarshal::GetUnmarshalClass(iid, pvInterface, dwDestContext, pvDestContext, mshlflags, pclsid)</B></P>
Answer the class that should be used in the unmarshaling process to create an uninitialized object proxy.</P>
dwDestContext is described in the API function CoMarshalInterface. The implementation of GetUnmarshalClass may wish for some destination contexts for which it takes no special action to delegate to the standard marshaling implementation, which is available through CoGetStandardMarshal. In addition, this delegation should <I>always </I>be done if the dwDestContext parameter contains any flags that the GetUnmarshalClass does not fully understand; it is by this means that we can extend the richness of destination contexts in the future. For example, in the future, one of these bits will likely be defined to indicate that the destination of the marshaling is across the network.</P>
If the caller already has in hand the iid interface identified as being marshaled, he should pass the interface pointer through pvInterface. If he does not have this interface already, then he should pass NULL. This pointer can sometimes, though rarely, be used in order to determine the appropriate unmarshal class. If the IMarshal implementation really needs it, in can always QueryInterface on itself to retrieve the interface pointer; we optionally pass it here only to improve efficiency.</P>
  </P>

<TABLE COLS="3" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="106pt" VALIGN="TOP"><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="286pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><B>Argument</B></P></TD><TD VALIGN="TOP"><B>Type</B></P></TD><TD VALIGN="TOP"><B>Description</B></P></TD></TR><TR><TD VALIGN="TOP">iid</P></TD><TD VALIGN="TOP">REFIID</P></TD><TD VALIGN="TOP">The interface on this object that we are going to marshal.</P></TD></TR><TR><TD VALIGN="TOP">pvInterface</P></TD><TD VALIGN="TOP">void *</P></TD><TD VALIGN="TOP">The actual pointer that will be marshaled. May be NULL.</P></TD></TR><TR><TD VALIGN="TOP">dwDestContext</P></TD><TD VALIGN="TOP">DWORD</P></TD><TD VALIGN="TOP">The destination context relative to the current context in which the unmarshaling will be done.</P></TD></TR><TR><TD VALIGN="TOP">pvDestContext</P></TD><TD VALIGN="TOP">void*</P></TD><TD VALIGN="TOP">Non-NULL for some dwDestContext values.</P></TD></TR><TR><TD VALIGN="TOP">mshlflags</P></TD><TD VALIGN="TOP">DWORD</P></TD><TD VALIGN="TOP">As in CoMarshalInterface().</P></TD></TR><TR><TD VALIGN="TOP">pclsid</P></TD><TD VALIGN="TOP">CLSID *</P></TD><TD VALIGN="TOP">The class to be used in the unmarshaling process.</P></TD></TR><TR><TD VALIGN="TOP">return value</P></TD><TD VALIGN="TOP">HRESULT</P></TD><TD VALIGN="TOP">S_OK, E_FAIL, E_NOINTERFACE, E_UNEXPECTED</P></TD></TR></TBODY></TABLE>
<BR></P> </P></BODY></HTML>
