<HTML><HEAD><META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Causality ID</TITLE><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">

</OBJECT></FORM>
<H3>Causality ID</H3>  </P>
Each ORPC carries with it a UUID known as the causality ID that connects together the chain of ORPC calls that are causally related. If an outgoing ORPC is made while servicing an incoming ORPC, the outgoing call is to have the same causality ID as the incoming call. If an outgoing ORPC is made while not servicing an incoming ORPC, then a new causality ID is allocated for it.</P>
Causality IDs may in theory be reused as soon as it is certain that no transitively outstanding call is still in progress which uses that call. In practice, however, in the face of transitive calls and the possibility of network failures in the middle of such call chains, it is difficult to know for certain when this occurs. Thus, pragmatically, causality IDs are not reusable.</P>
<A NAME="PT2"></A>The causality ID can be used by servers to understand when blocking or deferring an incoming call (supported in some COM server programming models) is very highly probable<font class="MissingLink" meta="aslch15_FNNine">9.</font> to cause a deadlock, and thus should be avoided.</P>
<A NAME="PT3"></A>The causality ID for maybe, idempotent, and broadcast calls must be set to null.<font class="MissingLink" meta="aslch15_FNTen">10.</font> If a server makes a ORPC call while processing such a call, a new causality ID must be generated as if it were a top level call.</P>
 </P></BODY></HTML>
