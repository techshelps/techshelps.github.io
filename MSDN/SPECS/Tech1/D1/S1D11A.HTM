<HTML><HEAD><META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>OBJREF</TITLE><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">

</OBJECT></FORM>
<H3>OBJREF</H3>  </P>
An OBJREF is the data type used to represent an actual marshaled object reference. An OBJREF can either be empty or assume one of five variations, depending on the degree to which the object being marshaled uses the hook architecture (IMarshal, and so forth) in the marshaling infrastructure. The OBJREF structure is a union consisting of a switch flag followed by the appropriate data. </P>
<A NAME="PT2"></A>OBJREF_STANDARD</P>
Contains one interface of an object marshaled in standard form. The data that follows the switch flag is a STDOBJREF structure (described below).</P>
<A NAME="PT3"></A>OBJREF_HANDLER</P>
A marshaling of an object that wants to use handler marshaling. For example, an object wants to be represented in client address spaces by a proxy object that caches state. In this case, the class-specific information is just a standard reference to an interface pointer that the handler (proxy object) will use to communicate with the original object. See the IStdMarshalInfo interface.</P>
  </P>

<TABLE COLS="3" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="65pt" VALIGN="TOP"><COL WIDTH="100pt" VALIGN="TOP"><COL WIDTH="303pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><B>Member</B></P></TD><TD VALIGN="TOP">Type</P></TD><TD VALIGN="TOP">Semantic</P></TD></TR></TBODY></TABLE>
<BR></P></P>

<TABLE COLS="3" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="65pt" VALIGN="TOP"><COL WIDTH="100pt" VALIGN="TOP"><COL WIDTH="303pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP">std</P></TD><TD VALIGN="TOP">STDOBJREF</P></TD><TD VALIGN="TOP">A standard object reference used to connect to the source object.</P></TD></TR><TR><TD VALIGN="TOP">Clsid</P></TD><TD VALIGN="TOP">CLSID</P></TD><TD VALIGN="TOP">The CLSID of handler to create in the destination client.</P></TD></TR></TBODY></TABLE>
<BR></P><A NAME="PT4"></A>OBJREF_LONGSTD</P>
An interface marshaled on an object in long form. Contains a standard reference, along with a set of protocol sequences and network addresses that can be used to bind to an OXID resolver that is able to resolve the OXID in the STDOBJREF. This is useful when marshaling a proxy to give to another computer (a.k.a. the <I>middleman</I> case). The marshaling computer can specify the saResAddr for the resolver on the server computer so that the unmarshaler does not need to call the marshaler (middleman) back to get this information. Further, the marshaler does not need to keep the OXID in its cache beyond the lifetime of its own references in order to satisfy requests from parties that it just gave the OBJREF to.</P>
  </P>

<TABLE COLS="3" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="88pt" VALIGN="TOP"><COL WIDTH="105pt" VALIGN="TOP"><COL WIDTH="276pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><B>Member</B></P></TD><TD VALIGN="TOP">Type</P></TD><TD VALIGN="TOP">Semantic</P></TD></TR></TBODY></TABLE>
<BR></P></P>

<TABLE COLS="3" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="88pt" VALIGN="TOP"><COL WIDTH="105pt" VALIGN="TOP"><COL WIDTH="276pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP">std</P></TD><TD VALIGN="TOP">STDOBJREF</P></TD><TD VALIGN="TOP">A standard object reference used to connect to the source object.</P></TD></TR><TR><TD VALIGN="TOP">SaResAddr</P></TD><TD VALIGN="TOP">STRINGARRAY</P></TD><TD VALIGN="TOP">The resolver address.</P></TD></TR></TBODY></TABLE>
<BR></P><A NAME="PT5"></A>OBJREF_LONGHDLR</P>
Contains the same information as the handler case as well as the object resolver address. This form is needed for the same reason OBJREF_LONGSTD is needed.</P>
  </P>

<TABLE COLS="3" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="88pt" VALIGN="TOP"><COL WIDTH="100pt" VALIGN="TOP"><COL WIDTH="280pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><B>Member</B></P></TD><TD VALIGN="TOP">Type</P></TD><TD VALIGN="TOP">Semantic</P></TD></TR></TBODY></TABLE>
<BR></P></P>

<TABLE COLS="3" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="88pt" VALIGN="TOP"><COL WIDTH="100pt" VALIGN="TOP"><COL WIDTH="280pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP">std</P></TD><TD VALIGN="TOP">STDOBJREF</P></TD><TD VALIGN="TOP">A standard object reference used to connect to the source object.</P></TD></TR><TR><TD VALIGN="TOP">Clsid</P></TD><TD VALIGN="TOP">CLSID</P></TD><TD VALIGN="TOP">The class ID of the handler.</P></TD></TR><TR><TD VALIGN="TOP">SaResAddr</P></TD><TD VALIGN="TOP">STRINGARRAY</P></TD><TD VALIGN="TOP">The resolver address.</P></TD></TR></TBODY></TABLE>
<BR></P><A NAME="PT6"></A>OBJREF_CUSTOM</P>
A marshaling of an object which supports custom marshaling. The Custom format gives an object control over the representation of references to itself. For example, an immutable object might be passed by value, in which case the class-specific information would contain the object's immutable data. See the IMarshal interface. </P>
  </P>

<TABLE COLS="3" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="61pt" VALIGN="TOP"><COL WIDTH="73pt" VALIGN="TOP"><COL WIDTH="334pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><B>Member</B></P></TD><TD VALIGN="TOP">Type</P></TD><TD VALIGN="TOP">Semantic</P></TD></TR></TBODY></TABLE>
<BR></P></P>

<TABLE COLS="3" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="61pt" VALIGN="TOP"><COL WIDTH="73pt" VALIGN="TOP"><COL WIDTH="334pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP">clsid</P></TD><TD VALIGN="TOP">CLSID</P></TD><TD VALIGN="TOP">The CLSID of the object to create in the destination client.</P></TD></TR><TR><TD VALIGN="TOP">size</P></TD><TD VALIGN="TOP">unsigned long</P></TD><TD VALIGN="TOP">The size of the marshaled data provided by the source object and passed here in pData.</P></TD></TR><TR><TD VALIGN="TOP">pData</P></TD><TD VALIGN="TOP">byte*</P></TD><TD VALIGN="TOP">The data bytes that should be passed to IMarshal::UnmarshalInterface on a new instance of class clsid in order to initialize it and complete the unmarshal process.</P></TD></TR></TBODY></TABLE>
<BR></P><A NAME="PT7"></A>STDOBJREF</P>
An instance of a STDOBJREF represents a COM interface pointer that has been marshaled using the standard COM network protocol. A STDOBJREF in general can only be interpreted in the context of an outstanding ORPC, for it may contain an OXID unknown to the computer on which it is unmarshaled, and it is the only computer which is making [an] outstanding call which is guaranteed to be able to provide the binding information for the OXID.</P>
The members and semantics of the STDOBJREF structure are as follows:</P>
  </P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="70pt" VALIGN="TOP"><COL WIDTH="394pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><B>Member</B></P></TD><TD VALIGN="TOP">Semantic</P></TD></TR></TBODY></TABLE>
<BR></P></P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="70pt" VALIGN="TOP"><COL WIDTH="394pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP">flags</P></TD><TD VALIGN="TOP">Flag values taken from the enumeration SORFFLAGS. These are described below.</P></TD></TR><TR><TD VALIGN="TOP">Crefs</P></TD><TD VALIGN="TOP">The number of reference counts on ipid that being transferred in this marshaling.</P></TD></TR><TR><TD VALIGN="TOP">Ipid</P></TD><TD VALIGN="TOP">The IPID of the interface being marshaled.</P></TD></TR><TR><TD VALIGN="TOP">Oid</P></TD><TD VALIGN="TOP">The OID of the object to which ipid corresponds.</P></TD></TR><TR><TD VALIGN="TOP">Oxid</P></TD><TD VALIGN="TOP">The OXID of the server that owns this OID.</P></TD></TR></TBODY></TABLE>
<BR></P>The various SORFLAGS values have the following meanings. The SORF_OXRESx bit flags are reserved for the object exporter's use only, and must be ignored by object importers. They need not be passed through when marshaling an interface proxy.</P>
  </P>

<TABLE COLS="3" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="106pt" VALIGN="TOP"><COL WIDTH="60pt" VALIGN="TOP"><COL WIDTH="307pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><B>Flag</B></P></TD><TD VALIGN="TOP">Value</P></TD><TD VALIGN="TOP">Meaning</P></TD></TR></TBODY></TABLE>
<BR></P></P>

<TABLE COLS="3" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="106pt" VALIGN="TOP"><COL WIDTH="60pt" VALIGN="TOP"><COL WIDTH="307pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP">SORF_NOPING</P></TD><TD VALIGN="TOP">1</P></TD><TD VALIGN="TOP">This OID does not require pinging. Further, all interfaces on this OID, including this IPID, need not be reference counted. Pinging and reference counting on this object and its interfaces are still permitted, however, though such action is pointless.</P></TD></TR><TR><TD VALIGN="TOP">SORF_OXRES1</P></TD><TD VALIGN="TOP">8</P></TD><TD VALIGN="TOP">Reserved for exporter.</P></TD></TR><TR><TD VALIGN="TOP">SORF_OXRES2</P></TD><TD VALIGN="TOP">16</P></TD><TD VALIGN="TOP">Reserved for exporter.</P></TD></TR><TR><TD VALIGN="TOP">SORF_OXRES3</P></TD><TD VALIGN="TOP">32</P></TD><TD VALIGN="TOP">Reserved for exporter.</P></TD></TR><TR><TD VALIGN="TOP">SORF_OXRES4</P></TD><TD VALIGN="TOP">64</P></TD><TD VALIGN="TOP">Reserved for exporter.</P></TD></TR></TBODY></TABLE>
<BR></P><A NAME="PT8"></A>ORPCTHIS</P>
In every Request PDU that is an ORPC, the body (CL case) or the stub data (CO case) which normally contains the marshaled arguments in fact begins with an instance of the ORPCTHIS structure. The marshaled arguments of the COM interface invocation follow the ORPCTHIS; thus, viewed at the DCE RPC perspective, the call has an additional first argument. The ORPCTHIS is padded with zero bytes if necessary to achieve an overall size that is a multiple of eight bytes; thus, the remaining arguments are as a whole eight-byte aligned.</P>
As in regular calls, the causality ID must be propagated. If A calls ComputePi on B, B calls Release on C (which gets converted to RemRelease), and C calls Add on A, A will see the same causality ID that it called B with.</P>
  </P>

<TABLE COLS="3" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="83pt" VALIGN="TOP"><COL WIDTH="112pt" VALIGN="TOP"><COL WIDTH="278pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><B>Member</B></P></TD><TD VALIGN="TOP">Type</P></TD><TD VALIGN="TOP">Semantic</P></TD></TR></TBODY></TABLE>
<BR></P></P>

<TABLE COLS="3" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="83pt" VALIGN="TOP"><COL WIDTH="112pt" VALIGN="TOP"><COL WIDTH="278pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP">version</P></TD><TD VALIGN="TOP">COMVERSION</P></TD><TD VALIGN="TOP">The version number of the COM protocol used to make this particular ORPC. The initial value will be 1.1. Each packet contains the sender's major and minor ORPC version numbers. The client's and server's major versions must be equal. Backward-compatible changes in the protocol are indicated by higher minor version numbers. Therefore, a server's minor version must be greater than or equal to the client's. However, if the server's minor version exceeds the client's minor version, it must return the client's minor version and restrict its use of the protocol to the minor version specified by the client. A protocol version mismatch causes the RPC_E_VERSION_MISMATCH ORPC fault to be returned.</P></TD></TR><TR><TD VALIGN="TOP">flags</P></TD><TD VALIGN="TOP">unsigned long</P></TD><TD VALIGN="TOP">Flag values taken from the enumeration ORPCINFOFLAGS. These are elaborated below.</P></TD></TR><TR><TD VALIGN="TOP">reserved</P></TD><TD VALIGN="TOP">unsigned long</P></TD><TD VALIGN="TOP">Must be set to zero.</P></TD></TR><TR><TD VALIGN="TOP">cid</P></TD><TD VALIGN="TOP">CID</P></TD><TD VALIGN="TOP">The causality ID of this ORPC. See comments below.</P></TD></TR><TR><TD VALIGN="TOP">extensions</P></TD><TD VALIGN="TOP">ORPC_EXTENT_ARRAY*</P></TD><TD VALIGN="TOP">The body extensions, if any, passed with this call. Body extensions are GUID-tagged blobs of data which are marshaled as an array of bytes. Extensions are always marshaled with initial eight-byte alignment. Body extensions which are presently defined are described below.</P></TD></TR></TBODY></TABLE>
<BR></P>The various ORPCINFOFLAGS have the following meanings.</P>
  </P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="124pt" VALIGN="TOP"><COL WIDTH="340pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><B>Flag</B></P></TD><TD VALIGN="TOP">Meaning</P></TD></TR></TBODY></TABLE>
<BR></P></P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="124pt" VALIGN="TOP"><COL WIDTH="340pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP">INFO_NULL</P></TD><TD VALIGN="TOP">(Not a real flag. Merely a defined constant indicating the absence of any flag values.)</P></TD></TR><TR><TD VALIGN="TOP">INFO_LOCAL</P></TD><TD VALIGN="TOP">The destination of this call is on the same computer on which it originates. This value is never to be specified in calls which are not in fact local.</P></TD></TR><TR><TD VALIGN="TOP">INFO_RESERVED1</P></TD><TD VALIGN="TOP">If INFO_LOCAL is set, then reserved for local use; otherwise, reserved for future use.</P></TD></TR><TR><TD VALIGN="TOP">INFO_RESERVED2</P></TD><TD VALIGN="TOP">If INFO_LOCAL is set, then reserved for local use; otherwise, reserved for future use.</P></TD></TR><TR><TD VALIGN="TOP">INFO_RESERVED3</P></TD><TD VALIGN="TOP">If INFO_LOCAL is set, then reserved for local use; otherwise, reserved for future use.</P></TD></TR><TR><TD VALIGN="TOP">INFO_RESERVED4</P></TD><TD VALIGN="TOP">If INFO_LOCAL is set, then reserved for local use; otherwise, reserved for future use.</P></TD></TR></TBODY></TABLE>
<BR></P>Implementations may use the local and reserved flags to indicate any extra information needed for local calls. Note that if the INFO_LOCAL bit is not set and any of the other bits <I>are</I> set, then the receiver should return a fault. </P>
  </P>
<B>Comments</B>   <A NAME="PT9"></A>}3  The cid field contains the causality ID.<font class="MissingLink" meta="aslch15_FNEleven">11.</font> Each time a client makes a call, a new causality ID is generated. If a server makes a call while processing a request from a client, the new call must have the same causality ID. This allows simple servers to avoid working on more then one thing at a time (for example: A calls B calls A again, meanwhile C tries to call A with a new causality ID). It tells the server that he is being called because he asked someone to do something for him. There are several interesting exceptions:</P>
<SPAN CLASS="list"><UL><LI>The causality ID for maybe and idempotent calls must be set to CID_NULL. If a server makes a ORPC call while processing such a call, a new causality ID must be generated.</LI><LI>In the face of network failures, the same causality ID may end up in use by two independent processes at the same time. If A calls B calls C calls D and C fails, both B and D can independently, simultaneously make calls to E with the same causality ID.</LI></UL></SPAN>  </P>
The extensions field contains extensions to the channel header. Two are currently defined for Microsoft's implementation of this protocol (described below). Other implementations may define their own extensions with their own UUIDs. Implementations should skip over extensions they do not recognize or wish to support. Note that in order to force the ORPCTHIS header to be eight-byte aligned, an even number of extensions must be present and the size of the extension data must be a multiple of eight.</P>
<A NAME="PT10"></A>ORPCTHAT</P>
In every Response PDU that is an ORPC, the body (CL case) or the stub data (CO case) which normally contains the marshaled output parameters in fact begins with an instance of the ORPCTHAT structure. The marshaled output parameters of the COM interface invocation follow the ORPCTHAT; thus, viewed at the DCE RPC perspective, the call has additional output parameters. The ORPCTHAT is padded with zero-bytes if necessary to achieve an overall size that is a multiple of eight bytes; thus, the remaining output parameters as a whole [are] eight-byte aligned.</P>
  </P>

<TABLE COLS="3" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="88pt" VALIGN="TOP"><COL WIDTH="145pt" VALIGN="TOP"><COL WIDTH="235pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><B>Member</B></P></TD><TD VALIGN="TOP">Type</P></TD><TD VALIGN="TOP">Semantic</P></TD></TR></TBODY></TABLE>
<BR></P></P>

<TABLE COLS="3" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="88pt" VALIGN="TOP"><COL WIDTH="145pt" VALIGN="TOP"><COL WIDTH="235pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP">flags</P></TD><TD VALIGN="TOP">unsigned long</P></TD><TD VALIGN="TOP">Flag values taken from the enumeration ORPCINFOFLAGS. These are elaborated above. </P></TD></TR><TR><TD VALIGN="TOP">extensions</P></TD><TD VALIGN="TOP">ORPC_EXTENT_ARRAY*</P></TD><TD VALIGN="TOP">The body extensions, if any, returned by this call. Body extensions are GUID-tagged blobs of data which are marshaled as an array of bytes. Extensions are always marshaled with initial eight-byte alignment. </P></TD></TR></TBODY></TABLE>
<BR></P> </P></BODY></HTML>
