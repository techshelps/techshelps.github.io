<HTML><HEAD><META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Footnotes</TITLE><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">

</OBJECT></FORM>
<H3>Footnotes</H3>  </P>
<A NAME="PT2"></A>1.    As in DCE RPC object IDs are indeed only ever interpreted relative to a given computer, this relaxing of the DCE specification is not problematic. <font class="MissingLink" meta="aslch15_returnFNOne">[Back]</font></P>
<A NAME="PT3"></A>2.    The IID in the interface ID field is from a logical perspective actually redundant because the IPID uniquely specifies an interface pointer (though the IID is not recoverable from just the IPID). However, an additional (optional) check to verify that the caller and callee agree on the type of the interface pointer would make the system more robust. Also, the specification of the actual IID in question eases the integration of the COM network protocol with the DCE RPC network protocol. Note that it is not expensive for callers to provide the IID since the space for the IID is allocated in the DCE RPC header, which is always transmitted anyway. <font class="MissingLink" meta="aslch15_returnFNTwo">[Back]</font></P>
<A NAME="PT4"></A>3.     For the specification of the Connectionless Fault PDU, see [CAE RPC], page 520. Page 535 of the same work describes the Connection-oriented Fault PDU. <font class="MissingLink" meta="aslch15_returnFNThree">[Back]</font></P>
<A NAME="PT5"></A>4.     Ibid, page 516. <font class="MissingLink" meta="aslch15_returnFNThree">[Back]</font></P>
<A NAME="PT6"></A>5.     That is, in the Connection-oriented case, the ORPCTHAT also follows four bytes of padding after the fault code; however, the fault code in the Connection-oriented Fault PDU is preceded other data not found in the Connectionless Fault PDU. Consult [CAE RPC] for further details. <font class="MissingLink" meta="aslch15_returnFNThree">[Back]</font></P>
<A NAME="PT7"></A>6.     Whether one actually thinks of this as a new primitive data type or new compositional operator over existing data types depends on one's point of view. Both positions have some merit. <font class="MissingLink" meta="aslch15_returnFNSix">[Back]</font></P>
<A NAME="PT8"></A>7.    Note that the object reference does not include the interface identifier (IID), although you can't do much with the object reference without knowing the IID. The IPID does uniquely specify an IID; however, you can't algorithmically derive the IID from the IPID. This is not a problem because the IID does not have to be explicitly specified; it is either implicitly specified (by the type of the argument in a MIDL declaration) or available explicitly as another argument in the call that is carrying the polymorphic object reference (for example, <B>IUnknown::QueryInterface</B>). <font class="MissingLink" meta="aslch15_returnFNSeven">[Back]</font></P>
<A NAME="PT9"></A>8.     A consequence of allowing for this optimizations is that the reference count on each IPID as seen by the server may be in fact less than the total number of references on that interface as seen by all the extant clients of that interface. <font class="MissingLink" meta="aslch15_returnFNEight">[Back]</font></P>
<A NAME="PT10"></A>9.     This has high probability and not certainty due to some pathological cases involving network failures. Suppose A calls B calls C calls D which will call back to A, and while D is processing its call, the link from B to C goes down, causing B to try to obtain C's services through another party E, which, as D would, calls back to A. In such situations, A may receive incoming calls from both D and E. Only the call from E is actually a potential for deadlock. <font class="MissingLink" meta="aslch15_returnFNNine">[Back]</font></P>
<A NAME="PT11"></A>10.     Though this decision is subject to review. <font class="MissingLink" meta="aslch15_returnFNTen">[Back]</font></P>
<A NAME="PT12"></A>11.     In several early specifications the term <I>logical thread ID</I> was used instead of causality ID. The name was changed because the term logical thread ID implies a single threaded model that is not guaranteed. <font class="MissingLink" meta="aslch15_returnFNEleven">[Back]</font></P>
<A NAME="PT13"></A>12.     See [CAE RPC], Appendix H, p 613. <font class="MissingLink" meta="aslch15_returnFNTwelve">[Back]</font></P>
<A NAME="PT14"></A>13.     Only if reuse of the DCE RPC Endpoint Mapper endpoints is unacceptable. <font class="MissingLink" meta="aslch15_returnFNThirteen">[Back]</font></P>
<A NAME="PT15"></A>14.    This time-out period does not <I>guarantee</I> that OXID information will not be discarded before clients may need it, but is a very good heuristic, and indeed better than a hard-coded time-out value. <font class="MissingLink" meta="aslch15_returnFNFourteen">[Back]</font></P>
<A NAME="PT16"></A>15.     That is, adjusting the set's time-out period after the OID has been removed from it has no effect on the time-out of the OID. <font class="MissingLink" meta="aslch15_returnFNFifteen">[Back]</font></P>
<A NAME="PT17"></A>16.     Not surprisingly, to get around the chicken-and-egg problem, getting to a remote computer's SCM interface is not done via normal CoCreateInstance means. Richer mechanisms for creating an interface to a remote SCM are TBD, but note that the clarity about the SCM-to-SCM interface and its endpoints ensure interconnectivity. <font class="MissingLink" meta="aslch15_returnFNSixteen">[Back]</font></P>
<A NAME="PT18"></A>17.     This is true despite final word whether the Object Exporter will reuse the DCE RPC Endpoint Mapper's endpoints or a different well-known set TBD, as noted above. <font class="MissingLink" meta="aslch15_returnFNSixteen">[Back]</font></P>
<P></P>
 </P></BODY></HTML>
