<HTML><HEAD><META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Location Transparency</TITLE><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">

</OBJECT></FORM>
<H3>Location Transparency</H3>  </P>
COM is designed to allow clients to <I>transparently </I>communicate with objects regardless of where those objects are running, be it the same process, the same computer, or a different computer. What this means is that there is a <I>single programming model</I> for all types of objects for not only clients of those objects but also for the servers of those objects.</P>
From a client's point of view, all objects are access through interface pointers. A pointer must be in-process, and in fact, any call to an interface function always reaches <I>some</I> piece of in-process code first. If the object is in-process, the call reaches it directly, with no intervening system-infrastructure code. If the object is out-of-process, then the call first reaches what is called a <I>proxy</I> object provided by COM itself which generates the appropriate remote procedure call to the other process or the other computer.</P>
From a server's point of view, all calls to an object's interface functions are made through a pointer to that interface. Again, a pointer only has context in a single process, and so the caller must always be some piece of in-process code. If the object is in-process, the caller is the client itself. Otherwise, the caller is a <I>stub</I> object provided by COM that picks up the remote procedure call from the proxy in the client process and turns it into an interface call to the server object.</P>
As far as both clients and servers know, they always communicate directly with some other in-process code as illustrated in Figure 1-8.</P>
The bottom line is that <I>dealing with in-process or remote objects is transparent and identical to dealing with in-process objects</I>. This location transparency has a number of key benefits:</P>
<SPAN CLASS="list"><UL><LI><B>A common solution to problems that are independent of the distance between client and server</B>: For example, connection, function invocation, interface negotiation, feature evolution, and so forth.</LI><LI><B>Programmers leverage their learning</B>: New services are simply exposed through new interfaces, and once programmers learn how to deal with interfaces, they already know how to deal with new services that will be created in the future. This is a great improvement over environments where each service is exposed in a completely different fashion.</LI><LI><B>Systems implementation is centralized</B>: The implementors of COM can focus on making the central process of providing this transparency as efficient and powerful as possible such that every piece of code that uses COM benefits immensely.</LI><LI><B>Interface designers focus on design</B>: In designing a suite of interfaces, the designers can spend their time in the essence of the design—the contracts between the parties—without having to think about the underlying communication mechanisms for any interoperability scenario. COM provides those mechanisms for free and transparently.</LI></UL></SPAN><img src="ASL7B.gif"></P>
<B>Figure 1-8: Clients always call in-process code; objects are always called by in-process code. COM provides the underlying transparent RPC. </B></P>
<A NAME="PT2"></A>The clear separation of interface from implementation provided by location transparency for some situations gets in the way when performance is of critical concern. When designing an interface while focusing on making it natural and functional from the client's point of view, one is sometimes lead to design decisions that are in tension with allowing for efficient implementation of that interface across a network. What is needed is not pure location transparency, but "location transparency, unless you need to care. "COM provides this capability. An object implementor can if he wishes support <I>custom marshaling</I> which allows his objects to take special action when they are used from across the network, different action if he would like than is used in the local case. The key point is that this is done completely transparently to the client. Taken as a whole, this architecture allows one to design client/object interfaces at their natural and easy semantic level without regard to network performance issues, then at a later address network performance issues without disrupting the established design.<font class="MissingLink" meta="aslch01_FNNine">9.</font></P>
Also note again that COM is not a specification for how applications are structured: it is a specification for how applications interoperate. For this reason, COM is not concerned with the internal structure of an application—that is the job of programming languages and development environments. Conversely, programming environments have no set standards for working with objects outside of the immediate application. C++, for example, works extremely well to work with objects inside an application, but has no support for working with objects outside the application. Generally all other programming languages are the same in this regard. Therefore COM, through language-independent interfaces, picks up where programming languages leave off to provide the network-wide interoperability.</P>
</P>
 </P></BODY></HTML>
