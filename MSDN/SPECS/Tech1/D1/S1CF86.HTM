<HTML><HEAD><META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>The Component Software Solution: OLE's COM</TITLE><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">

</OBJECT></FORM>
<H2>The Component Software Solution: OLE's COM</H2>  </P>
The Component Object Model provides a means to address problems of application complexity and evolution of functionality over time. It is a widely available, powerful mechanism for customers to adopt and adapt to a new style multi-vendor distributed computing, while minimizing new software investment. COM is an open standard, fully and completely publicly documented from the lowest levels of its protocols to the highest. As a robust, efficient and workable component architecture it has been proven in the marketplace as the foundation of diverse and several application areas including compound documents, programming widgets, 3D engineering graphics, stock market data transfer, high performance transaction processing, and so on.</P>
The Component Object Model is an object-based programming model designed to promote software interoperability; that is, to allow two or more applications or <I>components</I> to easily cooperate with one another, even if they were written by different vendors at different times, in different programming languages, or if they are running on different computers running different operating systems. To support its interoperability features, COM defines and implements mechanisms that allow applications to connect to each other as<I> software objects. </I>A software object is a collection of related function (or intelligence) and the function's (or intelligence's) associated state.</P>
<img src="ASL1B.gif"></P>
<B>Figure 1-2: Once COM connects client and object, the client and object communicate directly without added overhead.</B></P>
In other words, COM, like a traditional system service API, provides the operations through which a client of some service can connect to multiple providers of that service in a polymorphic fashion. But once a connection is established, <I>COM drops out of the picture. </I>COM serves to connect a client and an object, but once that connection is established, the client and object communicate directly without having to suffer overhead of being forced through a central piece of API code as illustrated in Figure 1-2.</P>
<A NAME="PT3"></A>COM is not a prescribed way to structure an application; rather, it is a set of technologies for building robust groups of services in both systems and applications such that the services and the clients of those services can evolve over time. In this way, COM is a technology that makes the programming, use, and uncoordinated/independent evolution of binary objects <I>possible</I>. COM is not a technology designed primarily for making programming necessarily <I>easy</I>; indeed, some of the difficult requirements that COM accepts and meets necessarily involve some degree of complexity.<font class="MissingLink" meta="aslch01_FNOne">1.</font> However, COM provides a ready base for extensions oriented towards increased ease-of-use, as well as a great basis for powerful, easy development environments, language-specific improvements to provide better language integration, and pre-packaged functionality within the context of application frameworks.</P>
This is a fundamental strength of COM over other proposed object models: COM solves the "deployment problem," the versioning and evolution problem where it is necessary that the functionality of objects can incrementally evolve or change without the need to simultaneously and in lockstep evolve or change all existing the clients of the object. Objects and services can easily continue to support the interfaces through which they communicated with older clients as well as provide new and better interfaces through which they communicate with newer clients.</P>
To solve the versioning problems as well providing connection services without undue overhead, the Component Object Model builds a foundation that:</P>
<SPAN CLASS="list"><UL><LI>Enables the creation and use of reusable components by making them component objects.</LI><LI>Defines a binary standard for interoperability.</LI><LI>Is a true system object model.</LI><LI>Provides distributed capabilities.</LI></UL></SPAN>The following sections describe each of these points in more detail.</P>
 </P></BODY></HTML>
