<HTML><HEAD><META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>COM Clients and Servers</TITLE><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">

</OBJECT></FORM>
<H3>COM Clients and Servers</H3>  </P>
<A NAME="PT3"></A>COM Clients</P>
Whatever application passes a CLSID to COM and asks for an instantiated object in return is a <I>COM Client. </I>Of course, since this client uses COM, it is also a COM application that must perform the required steps described above and in subsequent chapters.</P>
Regardless of the type of server in use (in-process, local, or remote), a COM Client always asks COM to instantiate objects in exactly the same manner. The simplest method for creating one object is to call the COM function CoCreateInstance. This creates one object of the given CLSID and returns an interface pointer of whatever type the client requests. Alternately, the client can obtain an interface pointer to what is called the <I>class factory </I>object for a CLSID by calling CoGetClassObject. This class factory supports an interface called IClassFactory through which the client asks that factory to manufacture an object of its class. At that point the client has interface pointers for <I>two separate objects</I>, the class factory and an object of that class, that each have their own reference counts. It's an important distinction that is illustrated in Figure 2-3 and clarified further in Chapter 5.</P>
<img src="ASL3C.gif"></P>
<B>Figure 2-3: A COM Client creates objects through a class factory.</B></P>
The CoCreateInstance function internally calls CoGetClassObject itself. It's just a more convenient function for clients that want to create one object.</P>
The bottom line is that a COM Client, in addition to its responsibilities as a COM application, is responsible to use COM to obtain a class factory, ask that factory to create an object, initialize the object, and to call that object's (and the class factory's) Release function when the client is finished with it. These steps are the bulk of Chapter 5 which also explains some features of COM that allow clients to manage when servers are loaded and unloaded to optimize performance.</P>
<A NAME="PT4"></A>COM Servers</P>
There are two basic kinds of object servers:</P>
<SPAN CLASS="list"><UL><LI><B>Dynamic Link Library (.DLL) Based  </B>The server is implemented in a module that can be loaded into, and will execute within, a client's address space. (The term .DLL is used in this specification to describe any shared library mechanism that is present on a given COM platform.)</LI><LI><B>.EXE Based  </B>The server is implemented as a stand-alone executable module.</LI></UL></SPAN>Since COM allows for distributed objects, it also allows for the two basic kinds of servers to implemented on a remote computer. To allow client applications to activate remote objects, COM defines the Service Control Manager (SCM) whose role is described below under "The COM Library."</P>
As a client is responsible for using a class factory and for server management, a server is responsible for implementing the class factory, implementing the class of objects that the factory manufactures, exposing the class factory to COM, and providing for unloading the server under the right conditions. A diagram illustrating what exists inside a server module (.EXE or .DLL) is shown in Figure 2-4.</P>
<img src="ASL4C.gif"></P>
<B>Figure 2-4: The general structure of a COM server.</B></P>
How a server accomplishes these requirements depends on whether the server is implemented as a .DLL or .EXE, but is independent of whether the server is on the same computer as the client or on a remote computer. That is, remote servers are the same as local servers but have been registered to be visible to remote clients. Chapter 6 goes into all the necessary details about these implementations as well as how the server publishes its existence to COM in the registration database.</P>
<A NAME="PT5"></A>A special kind of server is called an "custom object handler" that works in conjunction with a local server to provide a partial in-process implementation of an object class.<font class="MissingLink" meta="FNFive">5.</font> Since in-process code is normally much faster to load, in-process calls are extremely fast, and certain resources can be shared only within a single process space, handlers can help improve performance of general object operations as well as the quality of operations such as printing. An object handler is architecturally similar to an in-process server but with more specialized semantics for its use. While the client can control the loading of handlers, it doesn't have to do any special work whatsoever to work with them. The existence of a handler changes nothing for clients.</P>
<A NAME="PT6"></A>The COM Library and Service Control Manager</P>
<A NAME="PT7"></A>As described in Chapter 1, the COM Library itself is the implementation of the standard API functions defined in COM along with support for communicating between objects and clients. The COM Library is then the underlying <I>plumbing</I> that makes everything work transparently through RPC as shown in Figure 2-5 (this the same figure as Figure 1-8 in Chapter 1, repeated here for convenience). Whenever COM determines that it has to establish communication between a client and a local or remote server, it creates <I>proxy</I> objects that act as in-process objects to the client. These proxies then talk to <I>stub</I> objects that are in the same process as the server and can call the server directly. The stubs pick up RPC calls from the proxies, turn them into function calls to the real object, then pass the return values back to the proxy via RPC which in turn returns them to the client.<font class="MissingLink" meta="FNSix">6.</font> The underlying remote procedure call mechanism is based on the standard DCE remote procedure call mechanism.</P>
<img src="ASL5C.gif"></P>
<B>Figure 2-5: COM provides transparent access to local and remote servers through proxy and stub objects.</B></P>
<A NAME="PT8"></A>Architecture for Distributed Objects</P>
The COM architecture for object distribution is similar to the remoting architecture. When a client wants to connect to a server object, the name of the server is stored in the system registry. With distributed objects, the server can implemented as an in-process .DLL, a local executable module, or as an executable module or .DLL running remotely. A component called the Service Control Manager (SCM) is responsible for locating the server and running it. The next section, "The Service Control Manager", explains the role of the SCM in greater depth and Chapter 15 contains the specification for its interfaces.</P>
Making a call to an interface method in a remote object involves the cooperation of several components. The interface proxy is a piece of interface-specific code that resides in the client's process space and prepares the interface parameters for transmittal. It packages, or <I>marshals</I> them in such a way that they can be recreated and understood in the receiving process. The interface stub, also a piece of interface-specific code, resides in the server's process space and reverses the work of the proxy. The stub unpackages, or <I>unmarshals</I> the sent parameters and forwards them on to the server. It also packages reply information to send back to the client.</P>
The actual transmitting of the data across the network is handled by the RPC runtime library and the channel, part of the COM library. The channel works transparently with different channel types and supports both single and multi-threaded applications.</P>
The flow of communication between the components involved in interface remoting is shown in Figure 2-6. On the client side of the process boundary, the client's method call goes through the proxy and then onto the channel. Note that the channel is part of the COM library. The channel sends the buffer containing the marshaled parameters to the RPC runtime library who transmits it across the process boundary. The RPC runtime and the COM libraries exist on both sides of the process.</P>
<img src="ASL6C.gif"></P>
<B>Figure 2-6. Components of COM's distributed architecture.</B></P>
<A NAME="PT9"></A>The Service Control Manager</P>
The Service Control Manager ensures that when a client request is made, the appropriate server is connected and ready to receive the request. The SCM keeps a database of class information based on the system registry that the client caches locally through the COM library. This is the basis for COM's implementation locator services as shown in Figure 2-7.</P>
When a client makes a request to create an object of a CLSID, the COM Library contacts the <I>local</I> SCM (on the same computer) and requests that the appropriate server be located or launched, and a class factory returned to the COM Library. After that, the COM Library, or the client, can ask the class factory to create an object.</P>
<img src="ASL7C.gif"></P>
<B>Figure 2-7: COM delegates responsibility of loading and launching servers to the SCM.</B></P>
The actions taken by the local SCM depend on the type of object server that is registered for the CLSID:</P>
<SPAN CLASS="list"><UL><LI><B><I>In-Process  </I></B>The SCM returns the file path of the .DLL containing the object server implementation. The COM library then loads the .DLL and asks it for its class factory interface pointer.</LI><LI><B><I>Local  </I></B>The SCM starts the local executable which registers a class factory on startup. That pointer is then available to COM.</LI><LI><B><I>Remote  </I></B>The local SCM contacts the SCM running on the appropriate remote computer and forwards the request to the remote SCM. The remote SCM launches the server which registers a class factory like the local server with COM on that remote computer. The remote SCM then maintains a connection to that class factory and returns an RPC connection to the local SCM which corresponds to that remote class factory. The local SCM then returns that connection to COM which creates a class factory proxy which will internally forward requests to the remote SCM via the RPC connection and thus on to the remote server.</LI></UL></SPAN><img src="ASL8C.gif"></P>
Note that if the remote SCM determines that the remote server is actually an in-process server, it launches a <I>surrogate</I> server that then loads that in-process server. The surrogate does nothing more than pass all requests on through to the loaded .DLL.</P>
<A NAME="PT10"></A>Application Security</P>
The technology in COM provides security for applications, regardless of whether they run remotely. There is a default level of security that is provided to non-security-aware applications such as existing OLE applications. Beyond the default, applications that are security-aware can control who is granted access to their services and the type of access that is granted.</P>
Default security insures that system integrity is maintained. When multiple users require the services of a single non-security-aware server, a separate instance for each user is run. Each client/server connection remains independent from the others, preventing clients from accessing each others' data. All non-security-aware servers are run as the security principal who caused them to run. An example involving four clients that all require server "X" is illustrated in Figure 2-8. Since two of the clients are the same user (User2), one instance of server X can service both clients.</P>
The technology used in COM for distribution implements this security system with the authentication services provided by RPC. These services are accessed by applications through the COM library when a call is made to CoInitialize. This security system imposes a restriction on where non-security-aware applications can run. Since the system cannot start a session on another computer without the proper credentials, all servers that run in the client security context normally run where their client is running. The AtBits<I> </I>attribute associated with that class controls where a server is run.</P>
Security-aware servers are those applications that do not allow global access to their services. These servers may run either where the client is running, where their data is stored, or elsewhere depending on a rich set of activation rules. Rather than running as one of their clients; security-aware servers are themselves security principals. Security-aware servers may participate in two-way authentication whereby clients can ask for verification. Security-aware servers can use the services offered by the RPC security provider(s) or supply their own security implementation.</P>
</P>
 </P></BODY></HTML>
