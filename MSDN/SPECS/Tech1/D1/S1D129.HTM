<HTML><HEAD><META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>The Object Exporter</TITLE><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">

</OBJECT></FORM>
<H2>The Object Exporter</H2>  </P>
<A NAME="PT3"></A>Each computer that supports the COM network protocol supports a one-per-computer service known as the computer's 'Object Exporter.' Communication with an Object Exporter is via a DCE RPC, not an ORPC. To ensure connectivity, the Object Exporter resides at well-known endpoints. It is proposed that the Object Exporter either (i) make use of the same endpoints allocated for the DCE RPC Endpoint Mapper (listed below),<font class="MissingLink" meta="aslch15_FNTwelve">12.</font> implying typically that these services are written within the same process on a given computer, or alternately and less preferably (ii) that the Object Exporter resides at a different set of well-known endpoints TBD.</P>
The Object Exporter performs several services:</P>
<SPAN CLASS="list"><UL><LI>It caches and returns to clients when asked the string bindings necessary to connect to OXIDs of exported objects for which this computer is it either itself a client or is the server.</LI><LI>It receives pings from remote client computers to keep its own objects alive.</LI></UL></SPAN>These services are carried out through an RPC interface (not a COM interface) known as IObjectExporter.</P>
An Object Exporter may be asked for the information required to connect to one of two different kinds of OXIDs, either the OXIDs associated with its own objects, or the OXIDs associated with objects for which it itself is a client, and which it has passed on to a second client computer. This second case, where one marshals an object from one client computer to a second, is colloquially referred to the <I>middleman</I> case. In the middleman case, the exporter is required to retain the connection information associated with the OXIDs that it passes on until it is certain that that the second client computer no longer needs them. More on this below.</P>
  </P>

<TABLE COLS="4" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="109pt" VALIGN="TOP"><COL WIDTH="150pt" VALIGN="TOP"><COL WIDTH="109pt" VALIGN="TOP"><COL WIDTH="109pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><A NAME="PT4"></A><B>Protocol String Name(s)</B></P></TD><TD VALIGN="TOP"><BR>Description</P></TD><TD VALIGN="TOP">Object Exporter<BR>End Point<font class="MissingLink" meta="aslch15_FNThirteen">13.</font></P></TD><TD VALIGN="TOP"><B>Endpoint Mapper End Point</B></P></TD></TR></TBODY></TABLE>
<BR></P></P>

<TABLE COLS="4" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="109pt" VALIGN="TOP"><COL WIDTH="150pt" VALIGN="TOP"><COL WIDTH="109pt" VALIGN="TOP"><COL WIDTH="109pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP">ncadg_ip_udp, ip</P></TD><TD VALIGN="TOP">CL over UDP/IP.</P></TD><TD VALIGN="TOP">TBD</P></TD><TD VALIGN="TOP">135</P></TD></TR><TR><TD VALIGN="TOP">ncacn_ip_tcp</P></TD><TD VALIGN="TOP">CO over TCP/IP.</P></TD><TD VALIGN="TOP">TBD</P></TD><TD VALIGN="TOP">135</P></TD></TR><TR><TD VALIGN="TOP">ncadg_ipx</P></TD><TD VALIGN="TOP">CL over IPX.</P></TD><TD VALIGN="TOP">TBD</P></TD><TD VALIGN="TOP">not yet listed</P></TD></TR><TR><TD VALIGN="TOP">ncacn_spx</P></TD><TD VALIGN="TOP">CO over SPX.</P></TD><TD VALIGN="TOP">TBD</P></TD><TD VALIGN="TOP">not yet listed</P></TD></TR><TR><TD VALIGN="TOP">ncacn_nb_nb</P></TD><TD VALIGN="TOP">CO over NetBIOS over NetBEUI.</P></TD><TD VALIGN="TOP">TBD</P></TD><TD VALIGN="TOP">not yet listed</P></TD></TR><TR><TD VALIGN="TOP">ncacn_nb_tcp</P></TD><TD VALIGN="TOP">CO over NetBIOS over TCP/IP.</P></TD><TD VALIGN="TOP">TBD</P></TD><TD VALIGN="TOP">135</P></TD></TR><TR><TD VALIGN="TOP">ncacn_np</P></TD><TD VALIGN="TOP">CO over Named Pipes.</P></TD><TD VALIGN="TOP">TBD</P></TD><TD VALIGN="TOP">not yet listed</P></TD></TR><TR><TD VALIGN="TOP">ncacn_dnet_nsp</P></TD><TD VALIGN="TOP">CO over DECNet Network Services Protocol (DECnet Phase IV).</P></TD><TD VALIGN="TOP">TBD</P></TD><TD VALIGN="TOP">69</P></TD></TR><TR><TD VALIGN="TOP">ncacn_osi_dna</P></TD><TD VALIGN="TOP">CO over Open Systems Interconnection (DECNet Phase V).</P></TD><TD VALIGN="TOP">TBD</P></TD><TD VALIGN="TOP">69</P></TD></TR><TR><TD VALIGN="TOP">ncadg_dds, dds</P></TD><TD VALIGN="TOP">CL over Domain Datagram Service.</P></TD><TD VALIGN="TOP">TBD</P></TD><TD VALIGN="TOP">12</P></TD></TR><TR><TD VALIGN="TOP">ncalrpc</P></TD><TD VALIGN="TOP">Local procedure call.</P></TD><TD VALIGN="TOP">N/A</P></TD><TD VALIGN="TOP">N/A</P></TD></TR></TBODY></TABLE>
<BR></P><B>Table 1. Object Exporter Well-known Endpoints</B></P>
IObjectExporter interface is defined as follows (OBJEX.IDL):</P>
  </P>
<BR></P>
<pre><code>//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:      objex.idl
//
//  Synopsis:      Interface implemented by object exporters.
//
//  This is the interface that needs to be supported by hosts that export
//  objects. Only one instance of this interface can be exported by the host.
//
//  An object exporter needs to be able to:
//  1. return string bindings that can be used to talk to objects it
//     has exported
//  2. receive pings from object importers to keep the objects alive
//
//--------------------------------------------------------------------------
[
    uuid(99fcfec4-5260-101b-bbcb-00aa0021347a),
    pointer_default(unique)
]

interface IObjectExporter
{
    import "obase.idl";

    // Method to get the protocol sequences, string bindings and machine id
    // for an object server given its OXID.

    [idempotent] error_status_t ResolveOxid
    (
    [in]       handle_t       hRpc,
    [in]       OXID           *pOxid,
    [in]       unsigned short cRequestedProtseqs,
    [in,  ref, size_is(cRequestedProtseqs)]
               unsigned short arRequestedProtseqs[],
    [out, ref] MID            *pmid,
    [out, ref] STRINGARRAY   **psaOxidBindings,
    [out, ref] IPID           *pipidRemUnknown
    );

    // Simple ping is used to ping a Set. Client machines use this to inform
    // the object exporter that it is still using the items inside the set.
    // Returns S_TRUE if the SetId is known by the object exporter,
    // S_FALSE if not.

    [idempotent] error_status_t SimplePing
    (
    [in]  handle_t  hRpc,
    [in]  SETID    *pSetId
    );

    // Complex ping is used to create sets of OIDs to ping. The whole set
    // can subsequently be pinged using SimplePing, thus reducing network
    // traffic.

    [idempotent] error_status_t ComplexPing
    (
    [in]  handle_t        hRpc,
    [in]  SETID          *pSetId,
    [in]  unsigned short  SequenceNum,
    [in]  unsigned short  SetPingPeriod,
    [in]  unsigned short  SetNumPingsToTimeout,
    [out] unsigned short *pReqSetPingPeriod,
    [out] unsigned short *pReqSetNumPingsToTimeout,
    [in]  unsigned short  cAddToSet,
    [in]  unsigned short  cDelFromSet,
    [in,  unique, size_is(cAddToSet)]   GUID AddToSet[],   // add these OIDs to the set
    [in,  unique, size_is(cDelFromSet)] GUID DelFromSet[]  // remove these OIDs from the set
    );
}</code></pre>
  </P>
 </P></BODY></HTML>
