<HTML><HEAD><META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Marshaled Interface References</TITLE><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">

</OBJECT></FORM>
<H3>Marshaled Interface References</H3>  </P>
<A NAME="PT2"></A>The COM network protocol extends the Network Data Representation standard specified in [CAE RPC] by defining what can be thought of as a new primitive data type that can be marshaled: that of an interface reference to a COM object.<font class="MissingLink" meta="aslch15_FNSix">6.</font> This is the only extension to NDR made by the COM network protocol.</P>
A marshaled interface references is described by a type known as an OBJREF, which is described in detail below. An OBJREF in actuality has several variations:</P>
<SPAN CLASS="list"><UL><LI>Null.</LI><LI><B>Standard.</B> A standard remote reference. Known as a STDOBJREF. A STDOBJREF contains:

<UL><LI>An IPID, which uniquely specifies the interface and object.</LI><LI>An object ID (OID), which uniquely specifies the identity of the object on which the IPID is found. OIDs are UUIDs; they are universally unique.</LI><LI><A NAME="PT3"></A>An OXID, which identifies the scope where the implementation of the object is active, and can be used to reach the interface pointer.<font class="MissingLink" meta="aslch15_FNSeven">7.</font></LI><LI>A reference count, indicating the number of references to this IPID that are conveyed by this marshaling. This count, though typically a value of one, may in fact be zero, one, or more (see the next section).</LI><LI>Some flags, explained later.</LI></UL></LI><LI><B>Long. </B>A standard reference, along with a set of protocol sequences and network addresses that can be useful when marshaling a proxy to give to another computer (a.k.a. the middle-man case). </LI><LI><B>Custom. </B>Contains a class ID (CLSID) and class-specific information. 

<UL><LI>The Custom format gives an object control over the representation of references to itself. For example, an immutable object might be passed by value, in which case the class-specific information would contain the object's immutable data.</LI></UL></LI><LI><B>Handler. </B>A sub-case of the custom reference in which the class-specific information is standardized.

<UL><LI>For example, an object wishes to be represented in client address spaces by a proxy object that caches state. In this case, the class-specific information is just a standard reference to an interface pointer that the handler (proxy object) will use to communicate with the original object.</LI></UL></LI><LI><B>Long Handler: </B>Contains the same information as the handler case as well as the object resolver address. This form is needed for the same reason the long form is needed.</LI></UL></SPAN>Interface references are <I>always </I>marshaled in little-endian byte order, irrespective of the byte order prevailing in the remainder of the data being marshaled.</P>
 </P></BODY></HTML>
