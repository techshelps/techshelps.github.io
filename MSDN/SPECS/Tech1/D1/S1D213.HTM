<HTML><HEAD><META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>IMoniker::IsRunning</TITLE><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">

</OBJECT></FORM>
<H3>IMoniker::IsRunning</H3>  </P>
<B>HRESULT IMoniker::IsRunning(pbc, pmkToLeft, pmkNewlyRunning)</B></P>
Answer as to whether this moniker is in fact running. As usual, the Running Object Table in whose context this question is to be answered is obtained by this moniker from the Bind context. pmkToLeft is the moniker to the left of this object in the generic composite in which it is found, if any. </P>
If non-NULL, pmkNewlyRunning is the moniker which has most recently been added to the Running Object Table; the implementation of IMoniker::IsRunning can assume that without this object in the Running Object Table, that IMoniker::IsRunning would have reported that it was not running; thus, the only way that it can now be running is if this newly running moniker is in fact itself! This allows for some n[squared]-to-n reductions in algorithms that use monikers. (If the moniker implementation chose to ignore pmkNewlyRunning, no harm would come: this moniker is in fact in the Running Object Table)</P>
Implementations of this method in various kinds of moniker classes are roughly as follows:</P>
Generic Composite Moniker:</P>
  </P>
<BR></P>
<pre><code>if (pmkToLeft != NULL)
    return (pmkToLeft-&gt;ComposeWith(this)) -&gt; IsRunning(pbc, NULL, pmkNewlyRunning);
if (pmkNewlyRunning != NULL) {
    if (pmkNewlyRunning -&gt; IsEqual(this) == NOERROR)
        return NOERROR;
    }
else if (pRunningObjectTable -&gt; IsRunning(this) == NOERROR)
    return NOERROR;
// otherwise, forward it on to my last element.
return this-&gt;Last()-&gt;IsRunning(pbc, this-&gt;AllButLast(), pmkNewlyRunning)</code></pre>
  </P>
Any moniker whose class does not do any wildcard matching.</P>
  </P>
<BR></P>
<pre><code>if (pmkToLeft == NULL) {
    if (pmkNewlyRunning != NULL)
        return pmkNewlyRunning -&gt; IsEqual(this);
    else
        return pRunningObjectTable -&gt; IsRunning(this);
    }
else
    return ResultFromScode(S_FALSE);    <I>// If I </I>was<I> running, then Generic Composite would have caught it.</I></code></pre>
  </P>
A moniker class which has a wild card entry which always matches any instance of the moniker class: if the wild card is present, then all instances of the moniker class to the right of the same other moniker (that is, with the same moniker to their left) are deemed to be running. Such a moniker class might be reasonably used, for example, to match all the addressable ranges in a given spreadsheet. </P>
  </P>
<BR></P>
<pre><code>if (pmkToLeft == NULL) {
    if (pmkNewlyRunning != NULL)
        return pmkNewlyRunning-&gt;IsEqual(this) == NOERROR 
            || pmkNewlyRunning-&gt;IsEqual(my wild card moniker) == NOERROR;
    if <I>(</I>pRunningObjectTable -&gt; IsRunning(this) == NOERROR)
        return NOERROR;
    return pRunningObjectTable -&gt; IsRunning(my wild card moniker);
    }
else 
    return pmkToLeft-&gt;ComposeWith(my wild card moniker) -&gt; IsRunning(pbc, NULL, pmkNewlyRunning);</code></pre>
  </P>
A moniker class which has a wild card entry which matches against some of the objects, but only the ones which are in fact actually currently running. We illustrate here specifically the behaviour of Item Monikers.</P>
  </P>
<BR></P>
<pre><code>if (pmkToLeft == NULL) {
    if (pmkNewlyRunning != NULL) {
        if (pmkNewlyRunning-&gt;IsEqual(this) == NOERROR)
            return NOERROR;
        if (pmkNewlyRunning-&gt;IsEqual(my wild card moniker) != NOERROR)
            return ResultFromScode(S_FALSE);
        goto TestBind:
        }
    }
if (pmkToLeft-&gt;ComposeWith(my wild card moniker)-&gt;IsRunning(pbc, NULL, pmkNewlyRunning) != NOERROR)
    return ResultFromScode(S_FALSE);
TestBind:
<I>// In general, connect to the container and ask whether the object is running. The use of </I>
<I>// IOleItemContainer here is Item Moniker-specific, but the theme is a general one.</I>
IOleItemContainer *pcont;
pmkToLeft-&gt;BindToObject(pbc, NULL, IID_IOleItemContainer, &amp;pcont);
return pcont-&gt;IsRunning(szItemString);</code></pre>
  </P>
The arguments to this function are as follows:</P>
  </P>

<TABLE COLS="3" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="110pt" VALIGN="TOP"><COL WIDTH="77pt" VALIGN="TOP"><COL WIDTH="287pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><B>Argument</B></P></TD><TD VALIGN="TOP"><B>Type</B></P></TD><TD VALIGN="TOP"><B>Description</B></P></TD></TR><TR><TD VALIGN="TOP">pbc</P></TD><TD VALIGN="TOP">IBindCtx*</P></TD><TD VALIGN="TOP">The usual bind context.</P></TD></TR><TR><TD VALIGN="TOP">pmkToLeft</P></TD><TD VALIGN="TOP">IMoniker*</P></TD><TD VALIGN="TOP">The moniker to the left of this one in the composite in which it is found.</P></TD></TR><TR><TD VALIGN="TOP">pmkNewlyRunning</P></TD><TD VALIGN="TOP">IMoniker*</P></TD><TD VALIGN="TOP">May be NULL. If non-NULL, then this is the moniker which has been most recently added to the Running Object Table. In this case, IMoniker::IsRunning implementations may assume that without this moniker in the R.O.T. that IMoniker::IsRunning would return S_FALSE.</P></TD></TR><TR><TD VALIGN="TOP">return value</P></TD><TD VALIGN="TOP">HRESULT</P></TD><TD VALIGN="TOP">S_OK, S_FALSE</P></TD></TR></TBODY></TABLE>
<BR></P> </P></BODY></HTML>
