<HTML><HEAD><META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Reference Counting</TITLE><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">

</OBJECT></FORM>
<H3>Reference Counting</H3>  </P>
Objects accessed through interfaces use a reference counting mechanism to ensure that the lifetime of the object includes the lifetime of references to it. This mechanism is adopted so that independent components can obtain and release access to a single object, and not have to coordinate with each other over the lifetime management. In a sense, the object provides this management, so long as the client components conform to the rules. Within a single component that is completely under the control of a single development organization, clearly that organization can adopt whatever strategy it chooses. The following rules are about how to manage and communicate interface instances between components, and are a reasonable starting point for a policy within a component.</P>
Note that the reference counting paradigm applies only to pointers to interfaces; pointers to data are not referenced counted.</P>
It is important to be very clear on exactly when it is necessary to call AddRef and Release through an interface pointer. By its nature, pointer management is a cooperative effort between separate pieces of code, which must all therefore cooperate in order that the overall management of the pointer be correct. The following discussion should hopefully clarify the rules as to when AddRef and Release need to be called in order that this may happen. Some special reference counting rules apply to objects which are aggregated; see the discussion of aggregation in Chapter 6.</P>
The conceptual model is the following: interface pointers are thought of as living in pointer variables, which for the present discussion will include variables in memory locations and in internal processor registers, and will include both programmer- and compiler-generated variables. In short, it includes all internal computation state that holds an interface pointer. Assignment to or initialization of a pointer variable involves creating a <I>new copy </I>of an already existing pointer: where there was one copy of the pointer in some variable (the value used in the assignment/initialization), there is now two. An assignment to a pointer variable <I>destroys </I>the pointer copy presently in the variable, as does the destruction of the variable itself (that is, the scope in which the variable is found, such as the stack frame, is destroyed).</P>
<SPAN CLASS="list"><UL><LI><B>Rule 1</B>: AddRef must be called for every new copy of an interface pointer, and Release called [for] every destruction of an interface pointer except where subsequent rules explicitly permit otherwise.</LI></UL></SPAN><A NAME="PT2"></A>This is the default case. In short, unless special knowledge permits otherwise, the worst case must be assumed. The exceptions to Rule 1 all involve knowledge of the relationships of the lifetimes of two or more copies of an interface pointer. In general, they fall into two categories.<font class="MissingLink" meta="aslch03_FNNine">9.</font></P>
<img src="ASL3D.gif"></P>
<B>Category 1. Nested lifetimes</B></P>
<img src="ASL4D.gif"></P>
<B>Category 2. Staggered overlapping lifetimes</B></P>
In Category 1 situations, the AddRef A2 and the Release R2 can be omitted, while in Category 2, A2 and R1 can be eliminated.</P>
<SPAN CLASS="list"><UL><LI><B>Rule 2</B>: Special knowledge on the part of a piece of code of the relationships of the beginnings and the endings of the lifetimes of two or more copies of an interface pointer can allow AddRef/Release pairs to be omitted.</LI></UL></SPAN>The following rules call out specific common cases of Rule 2. The first two of these rules are particularly important, as they are especially common.</P>
<SPAN CLASS="list"><UL><LI><B>Rule 2a</B>: <I>In-parameters to functions. </I>The copy of an interface pointer which is passed as an actual parameter to a function has a lifetime which is nested in that of the pointer used to initialize the value. The actual parameter therefore need not be separately reference counted.</LI><LI><B>Rule 2b</B>: <I>Out-parameters from functions, including return values. </I>This is a Category 2 situation. In order to set the out parameter, the function itself by Rule 1 must have a stable copy of the interface pointer. On exit, the responsibility for releasing the pointer is transferred from the callee to the caller. The out-parameter thus need not be separately reference counted.</LI><LI><B>Rule 2c</B>: <I>Local variables. </I>A function implementation clearly has omniscient knowledge of the lifetimes of each of the pointer variables allocated on the stack frame. It can therefore use this knowledge to omit redundant AddRef/Release pairs.</LI><LI><B>Rule 2d</B>: <I>Backpointers</I>. Some data structures are of the nature of containing two components, A and B, each with a pointer to the other. If the lifetime of one component (A) is known to contain the lifetime of the other (B), then the pointer from the second component back to the first (from B to A) need not be reference counted. Often, avoiding the cycle that would otherwise be created is important in maintaining the appropriate deallocation behavior. However, such non-reference counted pointers should be used <I>with extreme caution.<BR><BR></I><A NAME="PT3"></A>In particular, as the remoting infrastructure cannot know about the semantic relationship in use here, such backpointers cannot be remote references. In almost all cases, an alternative design of having the backpointer refer a second "friend" object of the first rather than the object itself (thus avoiding the circularity) is a superiour design. The following figure illustrates this concept.<font class="MissingLink" meta="aslch03_FNTen">10.</font></LI></UL></SPAN><img src="ASL5D.gif"></P>
The following rules call out common non-exceptions to Rule 1.</P>
<SPAN CLASS="list"><UL><LI><B>Rule 1a</B>: <I>In-Out-parameters to functions. </I>The caller must AddRef the actual parameter, since it will be Released by the callee when the out-value is stored on top of it.</LI><LI><B>Rule 1b</B>: <I>Fetching a global variable. </I>The local copy of the interface pointer fetched from an existing copy of the pointer in a global variable must be independently reference counted since called functions might destroy the copy in the global while the local copy is still alive.</LI><LI><B>Rule 1c</B>: <I>New pointers synthesized out of "thin air."</I> A function which synthesizes an interface pointer using special internal knowledge rather than obtaining it from some other source must do an initial AddRef on the newly synthesized pointer. Important examples of such routines include instance creation routines, implementations of IUnknown::QueryInterface, and so forth.</LI><LI><B>Rule 1d</B>: <I>Returning a copy of an internally stored pointer. </I>Once the pointer has been returned, the callee has no idea how its lifetime relates to that of the internally stored copy of the pointer. Thus, the callee must call AddRef on the pointer copy before returning it.</LI></UL></SPAN>Finally, when implementing or using reference counted objects, a technique sometimes termed "artificial reference counts" sometimes proves useful. Suppose you're writing the code in method Foo in some interface IInterface. If in the implementation of Foo you invoke functions which have even the remotest chance of decrementing your reference count, then such function may cause you to release before it returns to Foo. The subsequent code in Foo will crash.</P>
A robust way to protect yourself from this is to insert an AddRef at the beginning of Foo which is paired with a Release just before Foo returns:</P>
  </P>
<BR></P>
<pre><code><A NAME="PT4"></A>void IInterface::Foo(void) {
   this<font class="MissingLink" meta="aslch03_FNEleven">11.</font>-&gt;AddRef();
   /* 
    * Body of Foo, as before, except short-circuit returns
    * need to be changed.
    */
   this-&gt;Release();
   return;
   }
</code></pre>
  </P>
These "artificial" reference counts guarantee object stability while processing is done.</P>
</P>
 </P></BODY></HTML>
