<HTML><HEAD><META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Reusability Through Containment</TITLE><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">

</OBJECT></FORM>
<H3>Reusability Through Containment</H3>  </P>
Let's say that when we decide to implement the TextRender object we find that another object exists with CLSID_TextImage that is capable of accepting text through IDataObject::SetData but can do nothing more than render a metafile or bitmap for that text through IDataObject::GetData. This TextImage object cannot render memory copies of the text and has no concept of reading or writing text to a file. But it does such a good job implementing the graphical rendering that we wish to use it to help implement our TextRender object.</P>
In this case the TextRender object, when asked for a metafile or bitmap of its current text in IDataObject::GetData, would delegate the rendering to the TextImage object. TextRender would first call TextImage's IDataObject::SetData to give it the most recent text (if it has changed since the last call) and then call TextImage's IDataObject::GetData asking for the metafile or bitmap format. This delegation is illustrated in Figure 6-3.</P>
<img src="ASL2G.gif"></P>
<B>Figure 6-3: An outer object that uses inner objects through containment is a client of the inner objects.</B></P>
To create this configuration, the TextRender object would, during its own creation, instantiate the TextImage object with the following code, storing the TextImage's IDataObject pointer in a TextImage field m_pIDataObjImage:</P>
  </P>
<BR></P>
<pre><code>//TextRender initialization
HRESULT     hr;
hr=CoCreateInstance(CLSID_TextImage, CLSCTX_SERVER, NULL, IID_IDataObject, (void *)&amp;m_pIDataObjImage);
if (FAILED(hr))
   //TextImage not available, either fail or disable graphic rendering
//Success:  can now make use of TextImage object.</code></pre>
  </P>
This code is included here to show the NULL parameter in the middle of the call to CoCreateInstance<I>. </I>This is the <I>outer unknown </I>and is only applicable to aggregation. Containment does not make use of the outer unknown concept and so this parameter should always be NULL.</P>
Now that the TextRender object has TextImage's IDataObject it can delegate functionality to TextImage as needed. The following pseudo-code illustrates how TextRender's IDataObject::GetData function might be implemented:</P>
  </P>
<BR></P>
<pre><code>HRESULT CTextRender::GetData(FORMATETC *pFE, STGMEDIUM *pSTM)
   {
   switch ([format in FORMATETC])
      {
      case &lt;text&gt;:
         //Make copy of text and return
      case &lt;metafile&gt;:
      case &lt;bitmap&gt;:
         //Insure TextImage has current text
         m_pIDataObjImage-&gt;SetData(&lt;copy of our current text&gt;);
         return m_pIDataObjImage-&gt;GetData(pFE, pSTM);
      }
   return &lt;error&gt;;
   }</code></pre>
  </P>
Note that if the TextImage object was modified at some later date to implement additional interfaces (such as IPersistFile) or was updated to also support rendering copies of text in memory just like TextRender, <I>the code above would still function perfectly. </I>This is the <I>key</I> power of COM's reusability mechanisms over traditional language-style implementation inheritance: the reused object can freely revise itself so long as it continues to provide the exact behavior it has provided in the past. Since the TextRender object never bothers to query for any other interface on TextImage, and because it never calls TextImage's GetData for any format other than metafile or bitmap, TextImage can implement any number of new interfaces and support any number of new formats in GetData. All TextImage has to insure is that the behavior of SetData for text and the behavior of GetData for metafiles and bitmaps remains the same.</P>
Of course, this is just a simple example of containment. Real components will generally be much more complex and will generally make use of many inner objects and many more interfaces in this manner. But again, since the outer object only depends on the <I>behavior</I> of the inner object and does not care how it goes about performing its operations, the inner object can be modified without requiring any recompilation or any other changes to the outer object. That is reusability at its finest.</P>
 </P></BODY></HTML>
