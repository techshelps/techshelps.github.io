<HTML><HEAD><META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>IMoniker::BindToObject</TITLE><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">

</OBJECT></FORM>
<H3>IMoniker::BindToObject</H3>  </P>
<B>HRESULT IMoniker::BindToObject(pbc, pmkToLeft, iidResult, ppvResult)</B></P>
This is the workhorse function in IMoniker interface. Locate and load the object semantically referred to by this moniker according to the interface indicated by iidResult and return the object through ppvResult. After this call has returned, the semantics of the returned interface, whatever they are, should be fully functional.</P>
In general, each kind of moniker is designed to be used as one piece in a composite which gives the complete path to the object in question. In this composite, any given piece has a certain prefix of the composite to its left, and a certain suffix to its right. If IMoniker::BindToObject is invoked on the given piece, then most often the implementation of IMoniker::BindToObject will require certain services of the object indicated by the prefix to its left. Item monikers, for example, require IOleItemContainer interface of the object to their left; see below. The Item Moniker implementation of IMoniker::BindToObject recursively calls pmkToLeft-&gt;BindToObject in order to obtain this interface. Other implementations of IMoniker::BindToObject might instead invoke pmkToLeft-&gt;BindToStorage if they need access not to the object itself, but to its persistent storage.</P>
<img src="ASL2L.gif"></P>
<B>Figure 3. Interface calculus of moniker pieces</B></P>
In situations where the caller of IMoniker::BindToObject does not have a moniker for the object on the left, but instead has the object itself, a Pointer Moniker can be used to wrap the object pointer so that the moniker may be bound.</P>
In situations where the moniker in fact does <I>not</I> need services of the moniker to its left, yet one is provided by the caller nevertheless, <I>no</I> error should occur; the moniker should simply ignore the needless moniker to its left.</P>
If the object indicated by the moniker does not exist, then the error MK_E_NOOBJECT is returned.</P>
In general, binding a moniker can be quite a complicated process, since it may need to launch servers, open files, and so forth. This often may involve binding to other objects, and it is often the case that binding pieces of the composite to the right of the present piece will require the same [from] other objects. In order to avoid loading the object, releasing it, then having it loaded again later, IMoniker::BindToObject can use the <I>bind context</I> passed through the pbc parameter in order to defer releasing the object until the binding process overall is complete. See IBindCtx::RegisterObjectBound for details.</P>
The bind context also contains a deadline time by which the caller would like the binding process to complete, or fail with the error MK_E_EXCEEDEDDEADLINE if it cannot. This capability is not often used with IMoniker::BindToObject; it is more often used with other IMoniker functions such as IMoniker::GetTimeOfLastChange. Nevertheless, IMoniker::BindToObject implementations should (heuristically) honor the request. See IBindCtx::GetBindOptions for details.</P>
Usually, for most monikers, binding a second time will return the same running object as binding the first time, rather than reloading it again from passive backing store. This functionality is supported with the Running Object Table, which is described in detail later in this chapter. Basically, the <I>Running Object Table </I>is a lookup table keyed by a moniker whose values are pointers to the corresponding now-running object. As objects become running, the[y] register themselves in this table. Implementations of IMoniker::BindToObject can use this table to shortcut the binding process if the object to which they point is already running. </P>
<A NAME="PT2"></A>More precisely, if the passed pmkToLeft parameter is NULL (and this is not an error; that is, the moniker does not <I>require</I> something to its left), then the moniker should fully reduce itself, then look itself up in the Running Object Table and simply return the pointer to the object found there. If the pmkToLeft parameter is non-NULL, then it is the responsibility of the caller to handle this situation; the BindToObject() implementation should <I>not</I> consult the Running Object Table.<font class="MissingLink" meta="aslch11_FNTwo">2.</font> The Running Object Table is accessible from the bind context using IBindCtx::GetRunningObjectTable, an implementation of IMoniker::BindToObject should not use GetRunningObjectTable().</P>
  </P>

<TABLE COLS="3" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="309pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><B>Argument</B></P></TD><TD VALIGN="TOP"><B>Type</B></P></TD><TD VALIGN="TOP"><B>Description</B></P></TD></TR><TR><TD VALIGN="TOP">pbc</P></TD><TD VALIGN="TOP">IBindCtx*</P></TD><TD VALIGN="TOP">The bind context to be used for this binding operation.</P></TD></TR><TR><TD VALIGN="TOP">pmkToLeft</P></TD><TD VALIGN="TOP">IMoniker*</P></TD><TD VALIGN="TOP">The moniker of the object to the left of this moniker.</P></TD></TR><TR><TD VALIGN="TOP">iidResult</P></TD><TD VALIGN="TOP">REFIID</P></TD><TD VALIGN="TOP">The interface by which the caller wishes to connect to the object.</P></TD></TR><TR><TD VALIGN="TOP">ppvResult</P></TD><TD VALIGN="TOP">void**</P></TD><TD VALIGN="TOP">On successful return, a pointer to the instantiated object is placed here, unless BINDFLAGS_JUSTTESTEXISTENCE was specified in the binding options, in which case NULL <I>may </I>be returned instead.</P></TD></TR><TR><TD VALIGN="TOP">return value</P></TD><TD VALIGN="TOP">HRESULT</P></TD><TD VALIGN="TOP">S_OK, MK_E_NOOBJECT, STG_E_ACCESSDENIED, MK_E_EXCEEDEDDEADLINE, MK_E_CONNECTMANUALLY, MK_E_INTERMEDIATEINTERFACENOTSUPPORTED, E_OUTOFMEMORY, E_NOINTERFACE</P></TD></TR></TBODY></TABLE>
<BR></P> </P></BODY></HTML>
