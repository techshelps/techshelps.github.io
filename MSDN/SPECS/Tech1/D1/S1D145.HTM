<HTML><HEAD><META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Footnotes</TITLE><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">

</OBJECT></FORM>
<H2>Footnotes</H2>  </P>
<A NAME="PT2"></A>1.    Easy is a relative term: without COM, some sorts of programming are simply not <I>possible</I> and thus the term easy is utterly empty. <font class="MissingLink" meta="aslch01_returnFNOne">[Back]</font></P>
<A NAME="PT3"></A>2.    The term interface is used in a very similar sense in the Component Object Request Broker Architecture (CORBA) design of the Object Management Group. In both cases the idea of an interface is a signature of functions and, implicitly, capabilities, entirely abstracted from the implementation. The major difference between COM and CORBA at this high level is that CORBA objects have one and only one interface while COM objects can have many interfaces simultaneously. DCE RPC (from OSF) uses the term interface in a similar manner. <font class="MissingLink" meta="aslch01_returnFNTwo">[Back]</font></P>
<A NAME="PT4"></A>3.     Indeed, in principle the intrinsic method dispatch overhead of COM is in fact<I> less</I> than the intrinsic overhead of C++ multiple inheritance method invocations. In a multiple inheritance situation, C++ must on every method invocation adjust the this pointer to be as appropriate for the actual method which is to be executed. In an COM object which supports multiple interfaces, which is directly analogous to the multiple inheritance situation, one must of course also do a similar sort of adjustment, and this is done in the QueryInterface method. However, when using a given interface on the object, one can invoke QueryInterface once and use the returned pointer many times. Thus, the cost of the QueryInterface operation can be amortized over all the subsequent usage, resulting in less overall dispatch overhead. Be aware, however, that this distinction is completely academic. In almost all real word situations, both dispatch mechanisms provide more than adequate performance. <font class="MissingLink" meta="aslch01_returnFNThree">[Back]</font></P>
<A NAME="PT5"></A>4.    There can be subtle differences in the flow-of-control between calling in-process and out-of-process objects. In particular, an out-of-process object call may result in a call-back prior to the completion of the original call. COM provides standard mechanisms to deal with call-backs and reentrancy; even on single-threaded operating systems. Without such standards, true interoperability between out-of-process objects (of which cross-network objects is just a typical case) is impossible. <font class="MissingLink" meta="aslch01_returnFNFour">[Back]</font></P>
<A NAME="PT6"></A>5.     Although class and type can often be used interchangeably, in COM a <I>type</I> is the total signature of an object, which is the union of the interfaces that the object supports. <I>Class</I> is a particular implementation of a type, and can include certain unique implementation-specific attributes such as product name, icon, etc. For example, the chart type (identified by a GUID by whomever first defines that particular combination of interfaces) might be supported by Lotus&trade; 1-2-3 for Windows and Microsoft Excel for the Apple Macintosh, each of which are separate classes. Normally, types are polymorphic; any consumer of the services provided by interfaces making up the type can use any class that implements the type. <font class="MissingLink" meta="aslch01_returnFNFive">[Back]</font></P>
<A NAME="PT7"></A>6.     As an illustration of how unique GUIDs are consider that one could generate 10 million GUIDs a second until the year 5770 AD and each one would be unique. <font class="MissingLink" meta="aslch01_returnFNFive">[Back]</font></P>
<A NAME="PT8"></A>7.    See, for example, Richard Helm (Senior Researcher, IBM Thomas J. Watson Research Center), <I>Ensuring Semantic Integrity of Reusable Objects (Panel)</I>, OOPSLA '92 Conference Proceedings, p.300; John Lamping (Xerox PARC), <I>Typing the Specialization Interface</I>, OOPSLA '93 Conference Proceedings, p.201. <font class="MissingLink" meta="aslch01_returnFNSeven">[Back]</font></P>
<A NAME="PT9"></A>8.    Readers interested in this issue should examine the connectable object architecture described in Chapter 11.<I> </I>Connectable objects enable an event model that provides a standard, powerful convention for a COM object to signal to any interested client that is about to do something, that is doing something, and that it is finished doing something. The model also allows clients to cancel the event outright or to cancel it in favor of an overriding event supplied by the client. This event model coupled with a few additional conventions could provide COM with all the traditional features of implementation inheritance and more without the traditional risks.<I> </I>For an interesting discussion of the problems of traditional implementation inheritance as well as a description of how an inheritance system might be provide robust type-safety, see Hauck, <I>Inheritance Modeled with Explicit Bindings: An Approach to Typed Inheritance</I>, OOPSLA '93 Conference Proceedings, p.231. <font class="MissingLink" meta="aslch01_returnFNEight">[Back]</font></P>
<A NAME="PT10"></A>9.    Not only are there situations where there is a need for designs optimized for cross network efficiency, but there are also cases where in-process efficiency is more important.<I> </I>Just as COM provides mechanisms whereby the remote case can be optimized (custom marshaling) it also allows for the design of interfaces that are optimized for the in-process case. <font class="MissingLink" meta="aslch01_returnFNNine">[Back]</font></P>
<A NAME="PT11"></A>10.    Monikers are COM's way of providing support for what other object systems, such as. CORBA, call persistent interfaces. <font class="MissingLink" meta="aslch01_returnFNTen">[Back]</font></P>
</P>
<P></P>
 </P></BODY></HTML>
