<HTML><HEAD><META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>C vs. C++ vs. ...</TITLE><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">

</OBJECT></FORM>
<H3>C vs. C++ vs. ...</H3>  </P>
This specification documents COM interfaces using C++ syntax as a notation but (again) does not mean COM requires that programmers use C++, or any other particular language. COM is based on a <I>binary </I>interoperability standard, rather than a <I>language</I> interoperability standard. Any language supporting "structure" or "record" types containing double-indirected access to a table of function pointers is suitable.</P>
However, this is not to say all languages are created equal. It is certainly true that since the binary <B>vtbl</B> standard is exactly what most C++ compilers generate on PC and many RISC platforms, C++ is a <I>convenient</I> language to use over a language such as C.</P>
That being said, COM can declare interface declarations for both C++ and C (and for other languages if the COM implementor desires). The C++ definition of an interface, which in general is of the form:</P>
  </P>
<BR></P>
<pre><code>interface ISomeInterface
   {
   virtual RET_T  MemberFunction(ARG1_T arg1, ARG2_T arg2<I> /*, etc */</I>);
   [Other member functions]
   ...
   };</code></pre>
  </P>
then the corresponding C declaration of that interface looks like</P>
  </P>
<BR></P>
<pre><code>typedef struct ISomeInterface
<B>   </B>{
   ISomeInterfaceVtbl *  pVtbl;
   } ISomeInterface;

typedef struct ISomeInterfaceVtbl ISomeInterfaceVtbl<B>;</B>

struct ISomeInterfaceVtbl
<B>   </B>{
   RET_T (*MemberFunction)(ISomeInterface * this, ARG1_T arg1,
      ARG2_T arg2<I> /*, etc */</I>);
   [Other member functions]
   } ;</code></pre>
  </P>
This example also illustrates the algorithm for determining the signature of C form of an interface function given the corresponding C++ form of the interface function:</P>
<SPAN CLASS="list"><UL><LI>Use the same argument list as that of the member function, but add an initial parameter which is the pointer to the interface. This initial parameter is a pointer to a C type of the same name as the interface.</LI><LI>Define a structure type which is a table of function pointers corresponding to the <B>vtbl </B>layout of the interface. The name of this structure type should be the name of the interface followed by <B>Vtbl</B>. Members in this structure have the same names as the member functions of the interface.</LI></UL></SPAN>The C form of interfaces, when instantiated, generates exactly the same binary structure as a C++ interface does when some C++ class inherits the function signatures (but no implementation) from an interface and overrides each virtual function.</P>
These structures show why C++ is more convenient for the object implementor because C++ will automatically generate the <B>vtbl </B>and the object structure pointing to it in the course of instantiating an object. A C object implementor must define and object structure with the pVtbl<I> </I>field first, explicitly allocate both object structure and interface Vtbl structure, explicitly fill in the fields of the Vtbl structure, and explicitly point the pVtbl field in the object structure to the Vtbl structure. Filling the Vtbl structure need only occur once in an application which then simplifies later object allocations. In any case, once the C program has done this explicit work the binary structure is indistinguishable from what C++ would generate.</P>
On the client side of the picture there is also a small difference between using C and C++. Suppose the client application has a pointer to an ISomeInterface on some object in the variable <I>psome</I>. If the client is compiled using C++, then the following line of code would call a member function in the interface:</P>
  </P>
<BR></P>
<pre><code>   psome-&gt;MemberFunction(arg1, arg2, /* other parameters */);</code></pre>
  </P>
A C++ compiler, upon noting that the type of psome<I> </I>is an ISomeInterface * will know to actually perform the double indirection through the hidden pVtbl pointer and will remember to push the psome pointer itself on the stack so the implementation of MemberFunction<I> </I>knows which object to work with. This is, in fact, what C++ compilers do for any member function call; C++ programmers just never see it.</P>
What C++ actually does is be expressed in C as follows:</P>
  </P>
<BR></P>
<pre><code>   psome-&gt;lpVtbl-&gt;MemberFunction(psome, arg1, arg2, /* other parameters */);</code></pre>
  </P>
This is, in fact, how a client written in C would make the same call. These two lines of code show why C++ is more convenient—there is simply less typing and therefore fewer chances to make mistakes. The resulting source code is somewhat cleaner as well. The key point to remember, however, is that <I>how the client calls an interface member depends solely on the language used to implement the client and is completely unrelated to the language used to implement the object</I>. The code shown above to call an interface function is the code necessary to work with the interface binary standard and not the object itself.</P>
 </P></BODY></HTML>
