<HTML><HEAD><META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CoDisconnectObject</TITLE><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">

</OBJECT></FORM>
<H3>CoDisconnectObject</H3>  </P>
<B>HRESULT CoDisconnectObject(pUnkInterface, dwReserved)</B></P>
This function severs any extant Remote Procedure Call connections that are being maintained on behalf of all the interface pointers on this object. This is a very rude operation, and is not to be used in the normal course of processing; clients of interfaces should use IUnknown::Release() instead. In effect, this function is a privileged operation, which should only be invoked by the process in which the object actually is managed.</P>
<A NAME="PT2"></A>The primary purpose of this operation is to give an application process certain and definite control over remoting connections to other processes that may have been made from objects managed by the process. If the application process wishes to exit, then we do not want it to be the case that the extant reference counts from clients of the application's objects in fact keeps the process alive. When the application process wishes to exit, it should inform the extant clients of its objects<font class="MissingLink" meta="aslch07_FNEighteen">18.</font> that the objects are going away. Having so informed its clients, the process can then call this function for each of the object that it manages, even without waiting for a confirmation from each client. Having thus released resources maintained by the remoting connections, the application process can exit safely and cleanly. In effect, CoDisconnectObject() causes a controlled crash of the remoting connections to the object. It is also (one of) the triggers by which a client's subsequent IRpcChannel::IsConnected() call may return false.</P>
For illustration, contrast this with the situation with Microsoft's elderly Dynamic Data Exchange (DDE) desktop application integration protocol. If it has extant DDE connections, an application is required to send a DDE Terminate message before exiting, and it is <I>also </I>responsible for waiting around for an acknowledgment from each client before it can actually exit. Thus, if the client process has crashed, the application process will wait around forever. Because of this, with DDE there simply is no way for an application process to reliably and robustly terminate itself. Using CoDisconnectObject(), we avoid this sort of situation.</P>
  </P>

<TABLE COLS="3" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="101pt" VALIGN="TOP"><COL WIDTH="87pt" VALIGN="TOP"><COL WIDTH="286pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><B>Argument</B></P></TD><TD VALIGN="TOP"><B>Type</B></P></TD><TD VALIGN="TOP"><B>Description</B></P></TD></TR><TR><TD VALIGN="TOP">punkInterface</P></TD><TD VALIGN="TOP">IUnknown *</P></TD><TD VALIGN="TOP">The object that we want to disconnect. May be any interface on the object which is polymorphic with IUnknown*, not necessarily the exact interface returned by <B>QueryInterface(IID_IUnknown...)</B>.</P></TD></TR><TR><TD VALIGN="TOP">dwReserved</P></TD><TD VALIGN="TOP">DWORD</P></TD><TD VALIGN="TOP">Reserved for future use; must be zero.</P></TD></TR><TR><TD VALIGN="TOP">return value</P></TD><TD VALIGN="TOP">HRESULT</P></TD><TD VALIGN="TOP">S_OK, E_FAIL</P></TD></TR></TBODY></TABLE>
<BR></P> </P></BODY></HTML>
