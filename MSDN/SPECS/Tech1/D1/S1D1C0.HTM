<HTML><HEAD><META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>IMarshal::GetMarshalSizeMax</TITLE><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">

</OBJECT></FORM>
<H3>IMarshal::GetMarshalSizeMax</H3>  </P>
<B>HRESULT IMarshal::GetMarshalSizeMax(iid, pvInterface, dwDestContext, pvDestContext, mshlflags, pcb)</B></P>
Return an upper bound on the amount of data that would be written into the marshaling stream in an IMarshal::MarshalInterface() stream. The value returned must be an upper bound in the sense that it must be the case that a subsequent call to MarshalInterface() in fact require no more than the indicated number of bytes of marshaled data.</P>
Callers can optionally use the returned upper bound to pre-allocate stream buffers used in the marshaling process. Note that when IMarshal::MarshalInterface() is ultimately called, the IMarshal implementation cannot rely on the caller actually having called GetMarshalSizeMax() beforehand; it must still be wary of STG_E_MEDIUMFULL errors returned by the stream.</P>
The value returned by this function is guaranteed by the callee to be a conservative estimate of the amount of data needed to marshal the object; it is valid so long as the object instance is alive. Violation of this can be treated as a catastrophic error. To repeat for emphasis: an object <I>must</I> return a reasonable maximum size needed for marshaling: callers have the option of allocating a fixed-size marshaling buffer.</P>
  </P>

<TABLE COLS="3" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="101pt" VALIGN="TOP"><COL WIDTH="78pt" VALIGN="TOP"><COL WIDTH="295pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><B>Argument</B></P></TD><TD VALIGN="TOP"><B>Type</B></P></TD><TD VALIGN="TOP"><B>Description</B></P></TD></TR><TR><TD VALIGN="TOP">iid</P></TD><TD VALIGN="TOP">REFIID</P></TD><TD VALIGN="TOP">The interface of this object that we want to marshal.</P></TD></TR><TR><TD VALIGN="TOP">pvInterface</P></TD><TD VALIGN="TOP">void *</P></TD><TD VALIGN="TOP">The actual pointer that will be marshaled. May be NULL.</P></TD></TR><TR><TD VALIGN="TOP">dwDestContext</P></TD><TD VALIGN="TOP">DWORD</P></TD><TD VALIGN="TOP">As in CoMarshalInterface().</P></TD></TR><TR><TD VALIGN="TOP">pvDestContext</P></TD><TD VALIGN="TOP">void *</P></TD><TD VALIGN="TOP">As in CoMarshalInterface().</P></TD></TR><TR><TD VALIGN="TOP">mshlflags</P></TD><TD VALIGN="TOP">DWORD</P></TD><TD VALIGN="TOP">As in CoMarshalInterface().</P></TD></TR><TR><TD VALIGN="TOP">pcb</P></TD><TD VALIGN="TOP">ULONG *</P></TD><TD VALIGN="TOP">The place at which the maximum marshal size should be returned. A return of zero indicates "unknown maximum size."</P></TD></TR><TR><TD VALIGN="TOP">return value</P></TD><TD VALIGN="TOP">HRESULT</P></TD><TD VALIGN="TOP">S_OK, E_FAIL, E_NOINTERFACE, E_UNEXPECTED</P></TD></TR></TBODY></TABLE>
<BR></P> </P></BODY></HTML>
