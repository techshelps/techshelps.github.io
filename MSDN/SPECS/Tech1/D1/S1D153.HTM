<HTML><HEAD><META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>HRESULT</TITLE><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">

</OBJECT></FORM>
<H3>HRESULT</H3>  </P>
<A NAME="PT2"></A>The key type involved in COM error reporting is HRESULT.<font class="MissingLink" meta="aslch03_FNTwelve">12.</font> In addition, the COM Library provides a few functions and macros to help applications of any kind deal with error information. An HRESULT is a simple 32-bit value:</P>
  </P>
<BR></P>
<pre><code>   typedef LONG <B>HRESULT</B>;</code></pre>
  </P>
An HRESULT is divided up into an internal structure that has four fields with the following format (numbers indicate bit positions):</P>
<img src="ASL6D.gif"></P>
  </P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="74pt" VALIGN="TOP"><COL WIDTH="298pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><B>Field</B></P></TD><TD VALIGN="TOP"><B>Use</B></P></TD></TR><TR><TD VALIGN="TOP"><B>S</B>: </P></TD><TD VALIGN="TOP">(1 bit) Severity field:</P></TD></TR><TR><TD VALIGN="TOP">0</P></TD><TD VALIGN="TOP"><I>Success</I>. The function was successful; it behaved according to its proscribed semantics.</P></TD></TR><TR><TD VALIGN="TOP">1</P></TD><TD VALIGN="TOP"><I>Error</I>. The function failed due to an error condition.</P></TD></TR><TR><TD VALIGN="TOP"><B>R</B>:</P></TD><TD VALIGN="TOP">(2 bits) Reserved for future use; must be set to zero by present programs generating HRESULTs; present code should not take action that relies on any particular bits being set or cleared this field.</P></TD></TR><TR><TD VALIGN="TOP"><B>Facility</B>:</P></TD><TD VALIGN="TOP">(13 bits) Indicates which group of status codes this belongs to. New facilities must be allocated by a central coordinating body since they need to be universally unique.<font class="MissingLink" meta="aslch03_FNThirteen">13.</font> However, the need for new facility codes is very small. Most cases can and should use FACILITY_ITF. See the section "Use of FACILITY_ITF" below.</P></TD></TR><TR><TD VALIGN="TOP"><B>Code</B>: </P></TD><TD VALIGN="TOP">(16 bits) Describes what actually took place, error or otherwise.</P></TD></TR></TBODY></TABLE>
<BR></P>COM presently defines the following facility codes:</P>
  </P>

<TABLE COLS="3" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="124pt" VALIGN="TOP"><COL WIDTH="67pt" VALIGN="TOP"><COL WIDTH="284pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><B>Facility Name</B></P></TD><TD VALIGN="TOP"><B>Facility Value</B></P></TD><TD VALIGN="TOP"><B>Description</B></P></TD></TR><TR><TD VALIGN="TOP">FACILITY_NULL</P></TD><TD VALIGN="TOP">0</P></TD><TD VALIGN="TOP">Used for broadly applicable common status codes that have no specific grouping. S_OK belongs to this facility, for example.</P></TD></TR><TR><TD VALIGN="TOP">FACILITY_ITF</P></TD><TD VALIGN="TOP">4</P></TD><TD VALIGN="TOP">Used for by far the majority of result codes that are returned from an interface member function. Use of this facility indicates that the meaning of the error code is defined solely by the definition of the particular interface in question; an HRESULT with exactly the same 32-bit value returned from another interface might have a different meaning</P></TD></TR><TR><TD VALIGN="TOP">FACILITY_RPC</P></TD><TD VALIGN="TOP">1</P></TD><TD VALIGN="TOP">Used for errors that result from an underlying remote procedure call implementation. In general, this specification does not explicitly document the RPC errors that can be returned from functions, though they nevertheless can be returned in situations where the interface being used is in fact remoted</P></TD></TR><TR><TD VALIGN="TOP">FACILITY_DISPATCH</P></TD><TD VALIGN="TOP">2</P></TD><TD VALIGN="TOP">Used for IDispatch-interface-related status codes.</P></TD></TR><TR><TD VALIGN="TOP">FACILITY_STORAGE</P></TD><TD VALIGN="TOP">3</P></TD><TD VALIGN="TOP">Used for persistent-storage-related status codes. Status codes whose code (lower 16 bits) value is in the range of DOS error codes (less than 256) have the same meaning as the corresponding DOS error.</P></TD></TR><TR><TD VALIGN="TOP">FACILITY_WIN32</P></TD><TD VALIGN="TOP">7</P></TD><TD VALIGN="TOP">Used to provide a means of mapping an error code from a function in the Win32 API into an HRESULT. The semantically significant part of a Win32 error is 16 bits large.</P></TD></TR><TR><TD VALIGN="TOP">FACILITY_WINDOWS</P></TD><TD VALIGN="TOP">8</P></TD><TD VALIGN="TOP">Used for additional error codes from Microsoft-defined interfaces.</P></TD></TR><TR><TD VALIGN="TOP">FACILITY_CONTROL</P></TD><TD VALIGN="TOP">10</P></TD><TD VALIGN="TOP">Used for OLE Controls-related error values.</P></TD></TR></TBODY></TABLE>
<BR></P>A particular HRESULT value by convention uses the following naming structure:</P>
  </P>
<BR></P>
<pre><code>   &lt;Facility&gt;_&lt;Sev&gt;_&lt;Reason&gt;</code></pre>
  </P>
where &lt;<B>Facility</B>&gt; is either the facility name or some other distinguishing identifier, &lt;<B>Sev</B>&gt; is a single letter, one of the set { S, E } indicating the severity (success or error), and &lt;<B>Reason</B>&gt; is a short identifier that describes the meaning of the code. Status codes from FACILITY_NULL omit the &lt;<B>Facility</B>&gt;_ prefix. For example, the status code E_NOMEMORY is the general out-of memory error. All codes have either S_ or E_ in them allowing quick visual determination if the code means success or failure.</P>
The general "success" HRESULT is named S_OK, meaning "everything worked" as per the function specification. The value of this HRESULT is zero. In addition, as it is useful to have functions that can succeed but return Boolean results, the code S_FALSE is defined are success codes intended to mean "function worked and the result is false."</P>
  </P>
<BR></P>
<pre><code>#define   <B>S_OK</B>      0
#define   <B>S_FALSE</B>      1</code></pre>
  </P>
A list of presently-defined standard error codes and their semantics can be found in Appendix A.</P>
From a general interface design perspective, <I>success</I> status codes should be used for circumstances where the consequence of "what happened" in a method invocation is most naturally understood and dealt with by client code by looking at the out-values returned from the interface function: NULL pointers, and so forth. <I>Error</I> status codes should in contrast be used in situations where the function has performed in a manner that would naturally require "out-of-band" processing in the client code, logic that is written to deal with situations in which the interface implementation truly did not behave in a manner under which normal client code can make normal forward progress. The distinction is an imprecise and subtle one, and indeed many existing interface definitions do not for historical reasons abide by this reasoning. However, with this approach, it becomes feasible to implement automated COM development tools that appropriately turn the error codes into exceptions as was mentioned above.</P>
Interface functions in general take the form:</P>
  </P>
<BR></P>
<pre><code>   HRESULT ISomeInteface::SomeFunction(ARG1_T arg1, ... , ARGN_T argn, RET_T * pret);</code></pre>
  </P>
Stylistically, what would otherwise be the return value is passed as an out-value through the last argument of the function. COM development tools which map error returns into exceptions might also consider mapping the last argument of such a function containing only one out-parameter into what the programmer sees as the "return value" of the method invocation.</P>
The COM remoting infrastructure only supports reporting of RPC-induced errors (such as communication failures) through interface member functions that return HRESULTs. For interface member functions of other return types, such as void, such errors are silently discarded. To do otherwise would, to say the least, significantly complicate local / remote transparency.</P>
 </P></BODY></HTML>
