<HTML><HEAD><META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CoMarshalInterface</TITLE><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">

</OBJECT></FORM>
<H3>CoMarshalInterface</H3>  </P>
<B>HRESULT CoMarshalInterface(pstm, riid, pUnk, dwDestContext, pvDestContext, mshlflags)</B></P>
<A NAME="PT2"></A>Marshal the interface riid on the object on which pUnk is an IUnknown* into the given stream in such a way as it can be reconstituted in the destination using CoUnmarshalInterface().<font class="MissingLink" meta="aslch07_FNSeventeen">17.</font> This the root level function by which an interface pointer can be marshaled into a stream. It carries out the test for custom marshaling, using it if present, and carries out standard marshaling if not. This function is normally only called by code in interface proxies or interface stubs that wish to marshal an interface pointer parameter, though it will sometimes also be called by objects which support custom marshaling.</P>
riid indicates the interface on the object which is to be marshaled. It is specifically <I>not </I>the case that pUnk need actually be of interface riid; this function will QueryInterface from pUnk to determine the actual interface pointer to be marshaled.</P>
dwDestContext is a bit field which identifies the execution context relative to the current context in which the unmarshaling will be done. Different marshaling might be done, for example, depending on whether the unmarshal happens on the same workstation vs. on a different workstation on the network; an object could choose to do custom marshaling in one case but not the other. The legal values for dwDestContext are taken from the enumeration MSHCTX, which presently contains the following values.</P>
  </P>
<BR></P>
<pre><code>typedef enum tagMSHCTX {
   MSHCTX_NOSHAREDMEM            = 1,
   MSHCTX_DIFFERENTMACHINE         = 2,
   MSHCTX_SAMEPROCESS            = 4,
   } <B>MSHCTX</B>;</code></pre>
  </P>
These flags have the following meanings.</P>
  </P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="151pt" VALIGN="TOP"><COL WIDTH="339pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><B>Value</B></P></TD><TD VALIGN="TOP"><B>Description</B></P></TD></TR><TR><TD VALIGN="TOP">MSHCTX_NOSHAREDMEM</P></TD><TD VALIGN="TOP">The unmarshaling context does not have shared memory access with the marshaling context.</P></TD></TR><TR><TD VALIGN="TOP">MSHCTX_DIFFERENTMACHINE</P></TD><TD VALIGN="TOP">If this flag is set, then it cannot be assumed that this marshaling is being carried out to the same computer as that on which the marshaling is being done. The unmarshaling context is (very probably) on a computer with a different set of installed applications / components than the marshaling context (for example, is on a different computer). This is significant in that the marshaling cannot in this case assume that it knows whether a certain piece of application code is installed remotely.</P></TD></TR><TR><TD VALIGN="TOP">MSHCTX_SAMEPROCESS</P></TD><TD VALIGN="TOP">The interface is being marshaled to another apartment within the same process in which it is being unmarshaled.</P></TD></TR></TBODY></TABLE>
<BR></P>In the future, more MSHCTX flags may be defined; recall that this is a bit field.</P>
pvDestContext is a parameter that optionally supplies additional information about the destination of the marshaling. If non-NULL, then it is a pointer to a structure of the following form.</P>
  </P>
<BR></P>
<pre><code>typedef struct MSHCTXDATA {
   ULONG            cbStruct;
   IRpcChannelBuffer*      pChannel;
   } <B>MSHCTXDATA</B>;</code></pre>
  </P>
The members in this structure have the following meanings:</P>
  </P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="277pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><B>Value</B></P></TD><TD VALIGN="TOP"><B>Description</B></P></TD></TR><TR><TD VALIGN="TOP">cbStruct</P></TD><TD VALIGN="TOP">The size of the MSHCTXDATA structure in bytes.</P></TD></TR><TR><TD VALIGN="TOP">pChannel</P></TD><TD VALIGN="TOP">The channel object involved in the marshaling process.</P></TD></TR></TBODY></TABLE>
<BR></P>pvDestContext may legally be NULL, in which case such data is not provided.</P>
mslflags indicates the purpose for which the marshal is taking place, as was discussed in an earlier part of this document. Values for this parameter are taken from the enumeration MSHLFLAGS, and have the following interpretation.</P>
  </P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="151pt" VALIGN="TOP"><COL WIDTH="325pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><B>Value</B></P></TD><TD VALIGN="TOP"><B>Description</B></P></TD></TR><TR><TD VALIGN="TOP">MSHLFLAGS_NORMAL</P></TD><TD VALIGN="TOP">The marshaling is occurring because of the normal case of passing an interface from one process to another. The marshaled-data-packet that results from the call will be transported to the other process, where it will be unmarshaled (see CoUnmarshalInterface). </P>
</P></TD></TR><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">With this flag, the marshaled data packet will be unmarshaled either one or zero times. <B>CoReleaseMarshalData </B>is always (eventually) called to free the data packet.</P></TD></TR><TR><TD VALIGN="TOP">MSHLFLAGS_TABLESTRONG</P></TD><TD VALIGN="TOP">The marshaling is occurring because the data-packet is to be stored in a globally-accessible table from which it is to be unmarshaled zero, one, or more times. Further, the presence of the data-packet in the table is to count as a reference on the marshaled interface.</P></TD></TR><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">When removed from the table, it is the responsibility of the table implementor to call <B>CoReleaseMarshalData </B>on the data-packet.</P></TD></TR><TR><TD VALIGN="TOP">MSHLFLAGS_TABLEWEAK</P></TD><TD VALIGN="TOP">The marshaling is occurring because the data-packet is to be stored in a globally-accessible table from which it is to be unmarshaled zero, one, or more times. However, the presence of the data-packet in the table is <I>not </I>to count as a reference on the marshaled interface.</P></TD></TR><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">Destruction of the data-packet is as in the MSHLFLAGS_TABLESTRONG case.</P></TD></TR></TBODY></TABLE>
<BR></P>A consequence of this design is that the marshaled data packet will want to store the value of mshlflags in the marshaled data so as to be able to do the right thing at unmarshal time.</P>
  </P>

<TABLE COLS="3" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="106pt" VALIGN="TOP"><COL WIDTH="91pt" VALIGN="TOP"><COL WIDTH="289pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><B>Argument</B></P></TD><TD VALIGN="TOP"><B>Type</B></P></TD><TD VALIGN="TOP"><B>Description</B></P></TD></TR><TR><TD VALIGN="TOP">pstm</P></TD><TD VALIGN="TOP">IStream *</P></TD><TD VALIGN="TOP">The stream onto which the object should be marshaled. The stream passed to this function must be dynamically grow-able.</P></TD></TR><TR><TD VALIGN="TOP">riid</P></TD><TD VALIGN="TOP">REFIID</P></TD><TD VALIGN="TOP">The interface that we want to marshal.</P></TD></TR><TR><TD VALIGN="TOP">pUnk</P></TD><TD VALIGN="TOP">IUnknown *</P></TD><TD VALIGN="TOP">The object on which we want to marshal the interface riid.</P></TD></TR><TR><TD VALIGN="TOP">dwDestContext</P></TD><TD VALIGN="TOP">DWORD</P></TD><TD VALIGN="TOP">The destination context in which the unmarshaling will occur.</P></TD></TR><TR><TD VALIGN="TOP">pvDestContext</P></TD><TD VALIGN="TOP">void*</P></TD><TD VALIGN="TOP">As described above.</P></TD></TR><TR><TD VALIGN="TOP">mshlflags</P></TD><TD VALIGN="TOP">DWORD</P></TD><TD VALIGN="TOP">The reason that the marshaling is taking place.</P></TD></TR><TR><TD VALIGN="TOP">return value</P></TD><TD VALIGN="TOP">HRESULT</P></TD><TD VALIGN="TOP">S_OK, STG_E_MEDIUMFULL, E_NOINTERFACE, E_FAIL</P></TD></TR></TBODY></TABLE>
<BR></P> </P></BODY></HTML>
