<HTML><HEAD><META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>IBindCtx Interface</TITLE><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">

</OBJECT></FORM>
<H2>IBindCtx Interface</H2>  </P>
The bind context parameter passed to many of the IMoniker operations serves a few purposes. </P>
Its primary purpose is to accumulate the set of objects that get bound during an operation but which should be released when the operation is complete. This is particularly useful in generic composites: using the bind context in this way avoids binding an object, releasing it, only to have it bound again when the operation moves on to another piece of the composite.</P>
Another purpose of the bind context is to pass a group of parameters which do not change as an operation moves from one piece of a generic composite to another. These are the <I>binding</I> <I>options</I>, and are described below. Some of these binding options have a related return value in certain error conditions; the bind context provides the means by which they can be returned. </P>
The bind context is also the only means through which moniker operations should access contextual information about their environment. There should be no direct calls in moniker implementations to API functions that query or set state in the environment; all such calls should instead funnel through the bind context. Doing this allows for future enhancements which can dynamically modify binding behavior. </P>
The predefined piece of contextual information that moniker operations need to access is the Running Object Table; monikers should always access this table indirectly though IBindCtx::GetRunningObjectTable, rather than using the global function GetRunningObjectTable. IBindCtx interface allows for future extensions to the passed-in contextual information in the form the ability to maintain a string-keyed table of objects. See IBindCtx::RegisterObjectParam and related functions.</P>
  </P>
<BR></P>
<pre><code>interface <B>IBindCtx</B> : IUnknown { 
    virtual    HRESULT    <B>RegisterObjectBound</B>(punk);
    virtual    HRESULT    <B>RevokeObjectBound</B>(punk);
    virtual    HRESULT    <B>ReleaseBoundObjects</B>();
    virtual    HRESULT    <B>SetBindOptions</B>(pbindopts);
    virtual    HRESULT    <B>GetBindOptions</B>(pbindopts);
    virtual    HRESULT    <B>GetRunningObjectTable</B>(pprot);
    virtual    HRESULT    <B>RegisterObjectParam</B>(lpszKey, punk);
    virtual    HRESULT    <B>GetObjectParam</B>(lpszKey, ppunk);
    virtual    HRESULT    <B>EnumObjectParam</B>(ppenum);
    virtual    HRESULT    <B>RevokeObjectParam</B>(lpszKey);
    };

typedef struct {
    DWORD    cbStruct;                // the size in bytes of this structure. ie: sizeof(BINDOPTS).
    DWORD    grfFlags;
    DWORD    grfMode;
    DWORD    dwTickCountDeadline;
    } <B>BINDOPTS</B>;

HRESULT <B>CreateBindCtx</B>(reserved, ppbc);</code></pre>
  </P>
 </P></BODY></HTML>
