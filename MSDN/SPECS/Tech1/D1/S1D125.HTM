<HTML><HEAD><META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>IRemUnknown Interface</TITLE><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">

</OBJECT></FORM>
<H2>IRemUnknown Interface</H2>  </P>
The IRemUnknown interface is used by remote clients for manipulating reference counts on the IPIDs that they hold, and for obtaining additional interfaces on the objects on which those IPIDs are found. This interface is implemented by the COM "OXID object" associated with each OXID (NB. not each Object Exporter). The IPID for the IRemUnknown interface on this object is returned from IObjectExporter::ResolveOxid; see below. An OXID object need never be pinged; its interfaces (this IPID included) need never be reference counted.</P>
IRemUnknown is specified as follows (REMUNK.IDL):</P>
  </P>
<BR></P>
<pre><code>//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:   remunk.idl
//
//  The remote version of IUnknown. Once instance of this interface exists 
//  per OXID (whether an OXID represents either a thread or a process is
//  implementation specific). This interface is passed along during OXID 
//  resolution. It is used by clients to query for new interfaces, get 
//  additional references (for marshalling), and release outstanding 
//  references.
//
//+-------------------------------------------------------------------------
[
    object,
    uuid(99fcff28-5260-101b-bbcb-00aa0021347a)
]

import "unknwn.idl";

interface IRemUnknown : IUnknown
{
   // return structure from a QI call
    typedef struct tagREMQIRESULT
    {
      HRESULT      hResult;   // result of call
      STDOBJREF   std;      // data for returned interface
    } REMQIRESULT;

    HRESULT RemQueryInterface
    (
         [in] IPID              ipid,   // interface to QI on
      [in] unsigned long   cRefs,  // count of AddRefs requested for each interface
      [in] unsigned short   cIids,   // count of IIDs that follow
      [in, size_is(cIids)] IID *iids, // IIDs to query for
      [out, size_is(,cIids)] REMQIRESULT **ppQIResults // results returned
    );


   // structure passed to AddRef/Release to specify interface and count of
   // references to Add/Release.
    typedef struct tagREMINTERFACEREF
    {
       IPID      ipid;      // ipid to AddRef/Release
       unsigned long   cRefs;      // number of refs to add/release
    } REMINTERFACEREF;

    HRESULT RemAddRef
    (
       [in] unsigned short cInterfaceRefs,
       [in, size_is(cInterfaceRefs)] REMINTERFACEREF InterfaceRefs[]
    );

    HRESULT RemRelease
    (
       [in] unsigned short cInterfaceRefs,
       [in, size_is(cInterfaceRefs)] REMINTERFACEREF InterfaceRefs[]
    );
}
</code></pre>
  </P>
  </P>
<B>Comment</B>   References are kept per interface rather then per object.  </P>
  </P>
 </P></BODY></HTML>
