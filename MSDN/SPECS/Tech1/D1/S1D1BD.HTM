<HTML><HEAD><META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>IMarshal interface</TITLE><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">

</OBJECT></FORM>
<H3>IMarshal interface</H3>  </P>
IMarshal interface is the mechanism by which an object is custom-marshaled. IMarshal is defined as follows:</P>
  </P>
<BR></P>
<pre><code>interface <B>IMarshal </B>: IUnknown {
   HRESULT   <B>GetUnmarshalClass</B>(iid, pvInterface, dwDestContext, pvDestContext, mshlflags, pclsid);
   HRESULT   <B>GetMarshalSizeMax</B>(iid, pvInterface, dwDestContext, pvDestContext, mshlflags, pcb);
   HRESULT   <B>MarshalInterface</B>(pstm, iid, pvInterface, dwDestContext, pvDestContext, mshlflags);
   HRESULT   <B>UnmarshalInterface</B>(pstm, iid, ppvInterface);
   HRESULT   <B>DisconnectObject</B>(dwReserved);
   HRESULT   <B>ReleaseMarshalData</B>(pstm);
   };</code></pre>
  </P>
The process of custom marshaling an interface pointer involves two steps, with an optional third:</P>
<SPAN CLASS="list"><OL><LI>The code doing the marshaling calls IMarshal::GetUnmarshalClass(). This returns the class ID that will be used to create an uninitialized proxy object in the unmarshaling context.</LI><LI>(Optional) The marshaler calls IMarshal::GetMarshalSizeMax() to learn an upper bound on the amount of memory that will be required by the object to do the marshaling.</LI><LI>The marshaler calls IMarshal::MarshalInterface() to carry out the marshaling.</LI></OL></SPAN>The class IDand the bits that were marshaled into the stream are then conveyed by appropriate means to the destination, where they are unmarshaled. Unmarshaling involves the following essential steps:</P>
<SPAN CLASS="list"><UL><LI>Load the class object that corresponds to the class that the server said to use in GetUnmarshalClass().</LI></UL></SPAN>  </P>
<BR></P>
<pre><code>   IClassFactory * pcf;
   CoGetClassObject(clsid, CLSCTX_INPROCSERVER, IID_IClassFactory, &amp;pcf);</code></pre>
  </P>
<SPAN CLASS="list"><UL><LI>Instantiate the class, asking for IMarshal interface:</LI></UL></SPAN>  </P>
<BR></P>
<pre><code>IMarshal * proxy;
   pcf-&gt;CreateInstance(NULL, IID_IMarshal, &amp;proxy);</code></pre>
  </P>
<SPAN CLASS="list"><UL><LI>Initialize the proxy with IMarshal::UnmarshalInterface() using a copy of the bits that were originally produced by IMarshal::MarshalInterface() and asking for the interface that was originally marshaled.</LI></UL></SPAN>  </P>
<BR></P>
<pre><code>   IOriginal * pobj;
   proxy-&gt;UnmarshalInterface(pstm, IID_Original, &amp;pboj);
   proxy-&gt;Release();
   pcf-&gt;Release();</code></pre>
  </P>
The object proxy is now ready for use.</P>
 </P></BODY></HTML>
