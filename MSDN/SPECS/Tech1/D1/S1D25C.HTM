<HTML><HEAD><META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>OXIDs, Object Exporters, and Computers</TITLE><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">

</OBJECT></FORM>
<H3>OXIDs, Object Exporters, and Computers</H3>  </P>
Although an IPID from a logical perspective semantically determines the server, object and interface to which a particular call should be directed, it does not by itself indicate the binding information necessary to actually carry out an invocation.</P>
The protocol represents this "how-to" communication information in a UUID called an object exporter identifier, otherwise known as an OXID. Conceptually, an OXID can be thought of as an implementation scope for an COM object, which may be a whole computer, a given process, a thread within that process, or other more esoteric implementation scope, but the exact definition of such scopes has no bearing on the COM network protocol.</P>
A given computer at any moment may support several OXIDs; however there is always a unique <I>Object Exporter service </I>per computer which coordinates the management of all the OXIDs on the computer. Data structures in each Object Exporter keep track of the IPIDs exported and imported by that Object Exporter. The Object Exporter resides at well-known end points (one per protocol, of course) on the computer. It supports a DCE RPC interface known as IObjectExporter, which is described below.</P>
An OXID is used to determine the RPC string bindings that allow calls to reach their target IPID. Before making a call, the calling process must translate an OXID into a set of bindings that the underlying RPC implementation understands. It accomplishes by maintaining a cache of these mappings. When the destination application receives an object reference, it checks to see if it recognizes the OXID. If it does not, then it asks the source of the object reference (the server computer from which the object reference was acquired, which is not necessarily the home computer for the interface pointer) for the translation, and saves the resulting set of string bindings in a local table that maps OXIDs to string bindings.</P>
Associated with each OXID (not each Object Exporter) is COM object termed an "OXID object." OXID objects implement (at least) the IRemUnknown interface, through which remote management of reference counts and requests for interfaces are returned.</P>
Each computer is represented by a MID. MIDs are UUIDs and thus universally unique. The MID for a computer may (should) change when the computer reboots. However, when the MID for a computer changes, all OXIDs, OIDs, and IPIDs on that computer become invalid. MIDs are an optimization to simplify the task of determining which OXIDs are exported and pinged by which object exporters.</P>
 </P></BODY></HTML>
