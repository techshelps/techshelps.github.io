<HTML><HEAD><META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>C.2. Collation</TITLE><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">
</OBJECT></FORM>
<H3>C.2. Collation</H3>Korean text is normally collated syllable block by syllable block. Because of the arrangement of the conjoining jamos, sequences of them can be collated with a binary comparison. For example, in comparing (a) LVTLV against (b) LVLV, the first syllable block (LVT) should be compared against the second (LV). Supposing the first two characters are identical—since all trailing consonants have binary values greater than all leading consonants—the T would compare as greater than the second L in (b). This produces the correct ordering between the strings. The positions of the fillers in the code charts were also chosen with this in mind.</P>
  </P>
<B>Note</B>   As with any coded characters, collation cannot just depend on a binary comparison. Odd sequences such as superfluous fillers will produce an incorrect sort, as will cases where a non-jamos character follows a sequence (such as comparing LVT against LVx, where x is a Unicode character above U+11FF, such as IDEOGRAPHIC SPACE).</P>
  </P>
Collating precomposed syllable blocks requires a table, since the syllable blocks are coded in several sets. If mixtures of precomposed syllable blocks and jamos are collated, the easiest approach is to decompose the precomposed syllable blocks before comparing.</P></BODY></HTML>
