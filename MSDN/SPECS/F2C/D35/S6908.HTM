<HTML><HEAD><META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>F.1. Criteria for the Transformation Format</TITLE><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">
</OBJECT></FORM>
<H3>F.1. Criteria for the Transformation Format</H3>The FSS-UTF meets the following criteria:</P>
<UL><LI><FONT FACE="Symbol"></FONT>    It is compatible with historical file systems (which disallow the null byte and the ASCII slash character as a part of the file name).</LI><LI><FONT FACE="Symbol"></FONT>    It is compatible with existing programs. The existing model for multi-byte processing is that ASCII values do not occur in a single byte of a multi-byte encoding. An FSS-UTF representation of a non-ASCII character contains no ASCII code values. If the Unicode value is in the range [0x00, 0x7F] the transformation is in this range; otherwise, the transformed byte sequence does not contain any bytes in the range [0x00, 0x7F].</LI><LI><FONT FACE="Symbol"></FONT>    It is easy to convert from and to Unicode.</LI><LI><FONT FACE="Symbol"></FONT>    The first byte indicates the number of bytes to follow in a multi-byte sequence.</LI><LI><FONT FACE="Symbol"></FONT>    The FSS-UTF is not be extravagant in terms of number of bytes used for encoding.</LI><LI><FONT FACE="Symbol"></FONT>    It is possible to find the start of a character efficiently starting from an arbitrary location in a byte stream.</LI></UL></BODY></HTML>
