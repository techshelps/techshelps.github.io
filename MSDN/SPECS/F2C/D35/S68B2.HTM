<HTML><HEAD><META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>4.4. Unicode Character Equivalence</TITLE><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">
</OBJECT></FORM>
<H3>4.4. Unicode Character Equivalence</H3>Unicode 1.0 defines two sequences of non-spacing marks to be equivalent if they do not interact typographically (Volume 1, p. 18, paragraph 2; and p. 21, item 3). This works well in cases such as the examples cited, such as NON-SPACING DOT BELOW and NON-SPACING DOT ABOVE, which clearly do not interact.</P>
However, a general, consistent method of determining character string equivalence requires an explicit algorithm, which is provided below. Basically it works as follows. Every Unicode non-spacing mark has an associated non-spacing priority (spacing marks have a null priority). Whenever a character is encountered that has a non-null priority, a reordering algorithm is invoked. Essentially, any sequence of non-null priority marks is sorted based on the priority. This algorithm represents a logical description of the process: Optimized algorithms can be used in implementations as long as they are equivalent (that is, they produce the same result).</P>
<UL><LI><FONT FACE="Symbol"></FONT>    Two sequences of characters are equivalent if their canonical ordering representation is identical.</LI><LI><FONT FACE="Symbol"></FONT>    The canonical ordering representation of a string of characters is determined in the following way:

<OL><LI>    Decompose all precomposed characters in the string, based upon Appendix I: Unicode 1.1 Character List, p. 43. This will form the maximal decomposition of the string into component characters.</LI><LI>     Assign a canonical priority to each character, based upon Appendix D: Canonical Ordering Priorities, p. 23. Let p(A) be the priority of the character A.</LI><LI>     Sort the string by successively exchanging each pair (A, B) of adjacent characters wherever p(B) _ 0 &amp; p(A) &gt; p(B).</LI></OL></LI></UL>Examples:</P>
<P></P>

<TABLE COLS="3" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="154pt" VALIGN="TOP"><COL WIDTH="78pt" VALIGN="TOP"><COL WIDTH="190pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP">a + underdot + diaeresis</P></TD><TD VALIGN="TOP">equals</P></TD><TD VALIGN="TOP">a + diaeresis + underdot</P></TD></TR><TR><TD VALIGN="TOP">a + diaeresis + underdot</P></TD><TD VALIGN="TOP">equals</P></TD><TD VALIGN="TOP">a + diaeresis + underdot</P></TD></TR></TBODY></TABLE>
<BR></P>Since <I>underdot</I> has a larger non-spacing priority than <I>circumflex</I>, the algorithm will return the <I>a</I>, then the <I>diaeresis</I>, then the <I>underdot</I>. However, since <I>diaeresis</I> and <I>breve</I> have the same non-spacing priority (because they interact typographically), they do not rearrange:</P>
<P></P>

<TABLE COLS="3" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="137pt" VALIGN="TOP"><COL WIDTH="100pt" VALIGN="TOP"><COL WIDTH="190pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP">a + breve + diaeresis</P></TD><TD VALIGN="TOP">does not equal</P></TD><TD VALIGN="TOP">a + diaeresis + breve</P></TD></TR><TR><TD VALIGN="TOP">a + diaeresis + breve</P></TD><TD VALIGN="TOP">does not equal</P></TD><TD VALIGN="TOP">a + breve + diaeresis</P></TD></TR></TBODY></TABLE>
<BR></P>Thus we get the following results when applying the algorithm. If the results compare as equal, then the originals are equivalent.</P>
  </P>

<TABLE COLS="4" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="114pt" VALIGN="TOP"><COL WIDTH="109pt" VALIGN="TOP"><COL WIDTH="118pt" VALIGN="TOP"><COL WIDTH="127pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><B>Original</B></P></TD><TD VALIGN="TOP">Decompose</P></TD><TD VALIGN="TOP">Sort</P></TD><TD VALIGN="TOP">Result</P></TD></TR></TBODY></TABLE>
<BR></P></P>

<TABLE COLS="4" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="114pt" VALIGN="TOP"><COL WIDTH="109pt" VALIGN="TOP"><COL WIDTH="118pt" VALIGN="TOP"><COL WIDTH="127pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP">a-diaeresis + underdot</P></TD><TD VALIGN="TOP">a + diaeresis + underdot</P></TD><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">a + diaeresis + underdot</P></TD></TR><TR><TD VALIGN="TOP">a + diaeresis + underdot</P></TD><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">a + diaeresis + underdot</P></TD></TR><TR><TD VALIGN="TOP">a + underdot + diaeresis</P></TD><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">a + diaeresis + underdot</P></TD><TD VALIGN="TOP">a + diaeresis + underdot</P></TD></TR><TR><TD VALIGN="TOP">a-underdot + diaeresis</P></TD><TD VALIGN="TOP">a + underdot + diaeresis</P></TD><TD VALIGN="TOP">a + diaeresis + underdot</P></TD><TD VALIGN="TOP">a + diaeresis + underdot</P></TD></TR><TR><TD VALIGN="TOP">a-diaeresis + breve</P></TD><TD VALIGN="TOP">a + diaeresis + breve</P></TD><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">a + diaeresis + breve</P></TD></TR><TR><TD VALIGN="TOP">a + diaeresis + breve</P></TD><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">a + diaeresis + breve</P></TD></TR><TR><TD VALIGN="TOP">a + breve + diaeresis</P></TD><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">a + breve + diaeresis</P></TD></TR><TR><TD VALIGN="TOP">a-breve + diaeresis</P></TD><TD VALIGN="TOP">a + breve + diaeresis</P></TD><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">a + breve + diaeresis </P></TD></TR></TBODY></TABLE>
<BR></P>Characters have the same priority if they interact typographically; different priorities if they do not. Enclosing characters have the priority of base characters.</P>
  </P>
<B>Note</B>   Base characters never sort relative to one another, so the amount of work is limited by the number of non-spacing marks in a row.</P>
  </P>
This algorithm establishes the canonical equivalence of two sequences of characters. For example, this algorithm establishes the canonical equivalence of <I>o + diaeresis</I> to <I>ö</I>. This should not be confused with language-specific collation or matching, which may add additional information. For example, in Swedish, <I>ö</I> is treated as a completely different letter from <I>o</I>, collated after <I>z</I>. In German, <I>ö</I> is weakly equivalent to <I>oe</I>, and collated with <I>oe</I>. In English or French, <I>ö</I> is just an <I>o</I> with a diacritic that indicates that it is pronounced separately from the previous letter (as in coöperate), and is collated with <I>o</I>.</P>
Collation sequences may not require correct sorting outside of a given domain, and may not choose to invoke the canonical equivalency algorithm for excluded characters. For example, an English collator may not need to sort Cyrillic letters properly: In that case, it does not have to maximally decompose and reorder Cyrillic letters, and may just choose to sort them according to Unicode order.</P></BODY></HTML>
