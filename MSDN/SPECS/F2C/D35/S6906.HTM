<HTML><HEAD><META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>C.5. Application Compatibility</TITLE><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">
</OBJECT></FORM>
<H3>C.5. Application Compatibility</H3>For example, if an application program supporting Unicode works in English, it should be easily localizable into Korean, given operating system support. The main areas that cause problems in localization are input, manipulation and rendering:</P>
<UL><LI><FONT FACE="Symbol"></FONT>    Input is easier with jamos, since the keyboard input can exactly match the characters in the data stream. There is no requirement for application programs to support input methods, which removes a significant burden.</LI><LI><FONT FACE="Symbol"></FONT>    Manipulation includes cases such as concatenation or truncation of text. Conjoining jamos must not be confused with a double-byte character set (DBCS), such as shift-JIS, where there is a mixture of codes with different lengths. A major problem with DBCS is that if bytes are treated in isolation (or misinterpreted as a single-byte character set [SBCS]), then the text will be misparsed. For example, if a random byte is misinterpreted as a single byte and removed from a text stream, the meaning of the surrounding bytes can be completely corrupted.
The individual jamos maintain their independent identity: If a character is removed from a text stream, for example, the surrounding characters maintain their correct interpretation. However, programs may want to preserve syllable block boundaries, which does require some analysis of the text.</P></LI><LI><FONT FACE="Symbol"></FONT>    Rendering is not generally a problem for application compatibility. In modern systems it is handled by the the operating system, and does not require any additional work on the part of the application program.</LI><LI><FONT FACE="Symbol"></FONT>    The storage of Korean text using conjoining jamos takes about 2.2 times as many bytes as it does when stored as precomposed Hangul syllables. (The exact figure depends on the particular composition of the text: The factor of 2.2 is based on samples with half of the Korean syllables having two jamos, the others having three, and 20 percent of the text consisting of other characters such as space, punctuation, and so on.) The number of characters in Korean text expressed in jamos is roughly equivalent to the corresponding English text: Systems and application programs that can handle the volume of data necessary for English Unicode will easily handle that of Korean.</LI></UL></BODY></HTML>
