<HTML><HEAD><META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>2.1.1    Block Allocation Structure Fields</TITLE><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">

</OBJECT></FORM>
<H3>2.1.1    Block Allocation Structure Fields</H3><B>Alloc[...]</B><BR>A variable length array of structures.  Each structure in the array contains the following members.</P>
<P><B>Status<BR></B>The status of this space allocation.  Indicates both the position and condition of the specific space allocation within the block.  All bits not specifically defined in this Status member must be ones.</P>
<P>The position status indicates the relative position of this specific Alloc entry in the variable length array of Alloc structures.  </P>

<TABLE COLS="2" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="69pt" VALIGN="TOP"><COL WIDTH="348pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>Position</P>
<P>Status Value</P></TD><TD VALIGN="TOP"><P>Definition</P></TD></TR><TR><TD VALIGN="TOP"><P>1xxxxxxxb</P></TD><TD VALIGN="TOP"><P>Last member of the variable length Alloc structure array.</P></TD></TR><TR><TD VALIGN="TOP"><P>0xxxxxxxb</P></TD><TD VALIGN="TOP"><P>Not last member of the variable length Alloc structure array.</P></TD></TR></TBODY></TABLE>
<BR></P><P>The condition status indicates whether the space described by this Alloc entry is either allocated and active, allocated but superseded (freed), or deallocated and can be reclaimed.</P>

<TABLE COLS="2" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="74pt" VALIGN="TOP"><COL WIDTH="348pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>Condition</P>
<P>Status Value</P></TD><TD VALIGN="TOP"><P>Definition</P></TD></TR><TR><TD VALIGN="TOP"><P>x111xxxxb</P></TD><TD VALIGN="TOP"><P>Free member of the  Alloc structure array.  This is a member that was freed up during a block reclamation operation but cannot be converted to unused because other Alloc entries follow it.  However, this member may be reused.</P></TD></TR><TR><TD VALIGN="TOP"><P>x011xxxxb</P></TD><TD VALIGN="TOP"><P>Allocated member of the allocation structure array.  The region within the block described by this entry is currently active and cannot be reclaimed.</P></TD></TR><TR><TD VALIGN="TOP"><P>x001xxxxb</P></TD><TD VALIGN="TOP"><P>Deallocated member of the allocation structure array.  The region described by a deallocated member can be reclaimed.  An allocation structure array entry changes from 'allocated' to 'deallocated' status when the region it describes is deleted or completely modified.</P></TD></TR><TR><TD VALIGN="TOP"><P>x000xxxxb</P></TD><TD VALIGN="TOP"><P>Null  member of the allocation structure array.  A problem previously occurred when trying to write to this Alloc entry.  It has been marked NULL so that it is not used again.  It may become reusable during the next block reclamation process run on this block.</P></TD></TR></TBODY></TABLE>
<BR></P></P>

<TABLE COLS="2" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="73pt" VALIGN="TOP"><COL WIDTH="348pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>StatusValue</P></TD><TD VALIGN="TOP"><P>Definition</P></TD></TR><TR><TD VALIGN="TOP"><P>xxxx1111b</P></TD><TD VALIGN="TOP"><P>Reserved.  Must be ones</P></TD></TR></TBODY></TABLE>
<BR></P><B>Offset<BR></B>Offset, relative to the beginning of the block, of this space allocation.</P>
<B>Len<BR></B>Length, in bytes, of this space allocation.</P>
<B>BootRecordPtr</B><BR>A pointer to the boot record for this partition.  The Boot Record status bits determines whether the pointer stored here is valid or is to be considered FNULL.</P>
<B>EraseCount</B><BR>The number of times that this block has been erased.  The Erase Count should be 1 after the partition is formatted for the first time.  Each time a block is erased, the erase count is updated by the file system.  </P>
<B>BlockSeq</B><BR>The block's sequence within the partition.  The file system views a partition as a sequence of logically contiguous blocks.  The block sequence enables the file system to translate a blocks logical position within the sequence of blocks to the actual physical location of a block within the partition.</P>
The spare block defined later in this section will have a BlockSeq and BlockSeqChecksum of all 1's (FFFFh).</P>
<B>BlockSeqChecksum</B></P>
This block's sequence checksum.  This is simply the one's complement of the BlockSeq.  A block's contents are valid only if:</P>
            BlockSeq ^ BlockSeqChecksum == 0xffff</P>
If this relationship is not true, the block contains no valid information.  The block is either blank or has been corrupted by removal of the memory media while it was being erased.  If a block's contents are corrupt it is queued for erasure by the file system.  This check is included as yet another fail-safe measure to detect blocks that have been corrupted by removal of the media at some point within an erase cycle.  A simple checksum is used for the sake of efficiency.</P>
Note that the BlockSeqChecksum value for the 'spare' block is an exception to the above algorithm.  The 'spare' block defined later in this section will have a BlockSeqChecksum of all 1's (FFFFh).</P>
<B>Status</B><BR>A bit mapped status field indicating the current status of the block.</P>

<TABLE COLS="4" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="69pt" VALIGN="TOP"><COL WIDTH="69pt" VALIGN="TOP"><COL WIDTH="292pt" VALIGN="TOP"><COL WIDTH="0pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>Bit</P></TD><TD COLSPAN="2" VALIGN="TOP"><P>Definition</P></TD></TR><TR><TD VALIGN="TOP"><P>2-0</P></TD><TD COLSPAN="2" VALIGN="TOP"><P>BootRecordPtrStatus</P>
<P>    Indicates whether this block contains the boot record.<BR>    111        Block doesn't contain boot record.<BR>    110        Block contains current boot record.<BR>    000        Superseded boot record.  Block contained the boot record but  it  was</P>
<P>            superseded and moved to another block.  The pointer is to be</P>
<P>             considered FNULL.</P></TD></TR><TR><TD VALIGN="TOP"><P>9-3</P></TD><TD COLSPAN="2" VALIGN="TOP"><P>Reserved<BR>Must be all 1's.</P></TD></TR><TR><TD VALIGN="TOP"><P>15-10</P></TD><TD COLSPAN="2" VALIGN="TOP"><P>State</P>
<P>    Indicates the current state of the block.</P></TD></TR><TR><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P>State Value</P></TD><TD COLSPAN="2" VALIGN="TOP"><P>Description</P></TD></TR><TR><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P>110000b</P></TD><TD COLSPAN="2" VALIGN="TOP"><P>Block is ready.  It contains a valid header structure.</P></TD></TR><TR><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P>0yyyyyb1<BR></P></TD><TD COLSPAN="2" VALIGN="TOP"><P>Block is queued for erasure.  Any one of these values indicates this state.  The high order bit of zero in the state value generally indicates a "queued for erasure" state.</P></TD></TR><TR><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P>111111b</P></TD><TD COLSPAN="2" VALIGN="TOP"><P>Block is newly erased.  The block does not contain ANY information and is all ones when in this state.</P></TD></TR><TR><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P>111110b</P></TD><TD COLSPAN="2" VALIGN="TOP"><P>Block is in the process of having its erase count updated.  A block that is newly erased must have its erase count updated before it can be used.</P></TD></TR><TR><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P>111100b</P></TD><TD COLSPAN="2" VALIGN="TOP"><P>Block is a spare block.  A spare block has only the erase count and its status field updated.  The block is ready for use by the reclamation process when it's in this state.</P></TD></TR><TR><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P>111000b</P></TD><TD COLSPAN="2" VALIGN="TOP"><P>Block is undergoing the reclamation process.  A block in this state is having data from another block copied into it.</P></TD></TR><TR><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P>000000b</P></TD><TD COLSPAN="2" VALIGN="TOP"><P>Block is retired.  The block should NOT be used by the file system.</P></TD></TR><TR><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P>??????b</P></TD><TD COLSPAN="2" VALIGN="TOP"><P>Block is in an undefined state if the state variable has any other value.  It will be queued for erasure if it has an undefined value.</P></TD></TR></TBODY></TABLE>
<BR></P>1.  yyyyy represents any non-zero value.</P>
<P><B>BootRecordPtrStatus<BR></B>Is used to indicate whether this block contains the boot record pointer for this partition.  The file system, during initialization or a media change, reads a part of the block allocation structure of each block.  The boot record pointer is read from the block containing it and partition information such as total block count, spare block count, block size, root directory location, and name convention, are obtained from the block pointed to.</P>
<P>In order to search for the boot record pointer, the file system must know the block size and the total number of blocks in the partition.  Therefore the file system must obtain the block size and total number of blocks in the partition <B>before</B> it can locate the boot record.</P>
<P>Searching for the boot record is not anticipated to be a performance problem due to the low total number of blocks in the media, and the low read access times for the media.</P>
<P><B>State<BR></B>A set of bit flags that are used by the file system to indicate the current state of this block.</P></BODY></HTML>
