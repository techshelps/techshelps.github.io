<HTML><HEAD><META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>4.1    Formatting an FFS Partition</TITLE><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">

</OBJECT></FORM>
<H2>4.1    Formatting an FFS Partition</H2>The formatting utility is responsible for initializing the contents of a Flash File System partition.  This is a multi-step process summarized as follows:</P>
Obtain the geometry information for the partition.</P>
<P>1.    The formatting utility will need to know the number of erase blocks in a partition and the erase block size.  It needs this information to determine the number and size of the blocks in the partition it is formatting.  The data structures it is about to create are located at fixed positions within each block.  Hence the requirement for the block size and total. </P>
<P>2.    Set the number of spare blocks in the partition.</P>
<P>Either assume the partition will have only one spare block, or ask the user if additional spare blocks should be set aside.  A spare block is a block that is used by the file system to reclaim deallocated areas in other blocks within the partition.  It is NEVER used to store file system structures or data and is only used in the file system's block reclamation process.  Unless at least one spare block within the partition exists, the file system will be unable to reclaim space in other blocks in the event that they are entirely filled.</P>
<P>Additional spare blocks, beyond the mandatory one, and up to a maximum of 8, may be set aside by the formatting utility.  Having additional spare blocks has two advantages:</P>
<P>a.    When the media is extremely full, additional spare blocks speed the file system's deallocated space reclamation process because it does not have to wait on a single block to be erased before it can continue doing writes.</P>
<P>b.    If an unrecoverable error occurs in erasing a block, the block is marked as retired.  Having additional spare blocks allows the file system to recover from the error and to continue to reclaim deallocated space with the media.  However, once all spare blocks are consumed because of erase errors, the file system resorts to WORM behavior and deallocated space reclamation is no longer possible.</P>
<P>3.    If a Flash File System partition already exists on the media, obtain information from each block allocation structure and save it.</P>
<P>If a Flash File System partition does not already exist, skip this step.  However, if a Flash File System partition does exist, information from each block allocation structure must be read and saved across the format operation.</P>
<P>Recall that the block allocation structure is stored at the END of every block.  This means the Status member of the block allocation structure occupies the LAST word in the block.</P>
<P>Obtain the following information from the block allocation structure:</P>
<P>a.    The first item of information to be obtained is the Status of the block.  A block may have a status of retired indicating that it cannot be reused for some reason. The file system writes the retired status into the block Status to indicate that it is not to be reused.</P>
<P>b.    Bits 15-12 of the block Status word contains block status information.  If these bits are set to retired status, the block should not be used.  The blocks having this condition should be recorded so they can be marked as retired after media erasure.</P>
<P>c.    For each block that is not retired save the erase count.  This count is needed so that the file system can evenly cycle the reuse of blocks.  Each erase count should be incremented and rewritten after the block is erased.</P>
<P>4.    Erase the partition.</P>
<P>Erase the entire partition. After erasure all bits within the partition must be 1's.  If a block contains bits that cannot be set to 1's, the block number should be saved so that the block can be marked as retired when it is time to update the block's status.</P>
<P>5.    Initialize the block allocation structure of all blocks that are not spares.  If a Flash File System partition previously existed, the block allocation structure information previously read must be rewritten.  Specifically, the erase count and status must be restored.</P>
<P>After all blocks have had their block allocation structures initialized only the boot record and the root directory entry for this partition need be created.  Again, note that the block allocation structure is stored at the END of every block.  This means the Status member of the block allocation structure occupies the LAST word in the block.</P>
<P>The remainder of the physical block that precedes the block allocation structure <B>must</B> have been erased to all 1's.<BR><BR>Block    struc<BR>    EraseCount    dd    ?    ; If no file system partition previously existed, this field<BR>                ;    should be set to 1.  If a Flash File System partition<BR>                ;    previously existed, this field should be set to the<BR>                ;    updated value of the erase count that you saved for this<BR>                ;    specific physical block.<BR>    BlockSeq    dw    ?    ; <BR>    BlockSeqChecksum    dw    ?    ; Is simply the 1's complement of the BlockSeq value for<BR>                ;    this physical block.<BR>    Status    dw    C3FFh    ; This status indicates a READY block.<BR>                ;    However, if the status of this physical block had been<BR>                ;    previously marked as retired because it was so<BR>                ;    designated in a previously existing file system partition,<BR>                ;    or the erase processing determined that it should be<BR>                ;    retired, the field should be set to 0000h.  This status<BR>                ;    value indicates that the block is retired and should NOT<BR>                ;    be reused.  Skip all other field assignments for this<BR>                ;    physical block.<BR>Block    ends</P>
<P>Since the block is not designated a spare, the BlockSeq and<B> </B>BlockSeqChecksum fields must be initialized.  The first physical block in the partition must have a BlockSeq of 0, the second 1, the third 2 and so on.  Suppose a partition contains n blocks and has two spare blocks.  The partition 'size', as far as the file system is concerned, is (n-2) blocks because the spares are not used for file system storage.  In this example the BlockSeq numbers will have the following sequence (0, 1, 2...(n-3)).  Note that blocks that have been rejected because of their retired status are NOT included in this sequence.</P>
<P>6.    Initialize the block allocation structure of all spare blocks.  If a Flash File System partition previously existed, the block allocation structure information previously read must be rewritten.  Specifically, the erase count and status must be restored.</P>
<P>A physical block that is a designated as a spare block DOES NOT HAVE ITS BlockSeq OR BlockSeqChecksum FIELDS UPDATED.  The file system uses a BlockSeq and a BlockSeqChecksum that are all 1's to indicate that this is a spare block.  Spare block(s) can be placed anywhere in the partition.  For simplicity, they can be located at the beginning of the partition.  Note that there MUST be at least one spare block for the file system to operate correctly.</P>
<P>The remainder of the physical block that precedes the block allocation structure <B>must</B> have been erased to all 1's.<BR><BR>Block    struc<BR>    EraseCount    dd    ?    ; If no file system partition previously existed, this field<BR>                ;    should set to 1.  If a Flash File System partition<BR>                ;    previously existed, this field should be set to the<BR>                ;    updated value of the erase count that you saved for this<BR>                ;    specific physical block.<BR>    BlockSeq    dw    FFFFh    ; Is all 1's for a spare block. <BR>    BlockSeqChecksum    dw    FFFFh    ; Is all 1's for a spare block.<BR>    Status    dw    F3FFh    ; This status indicates a spare block.<BR>                ;    However, if the status of this physical block had been<BR>                ;    previously marked as retired because it was so<BR>                ;    designated in a previously existing file system partition,<BR>                ;    or the erase processing determined that it should be<BR>                ;    retired, the field should be set to 0000h.  This status<BR>                ;    value indicates that the block is retired and should NOT<BR>                ;    be reused.  Skip all other field assignments for this<BR>                ;    physical block.<BR>Block    ends</P>
<P>7.    Create and write the boot record and root directory entry in the first block of the partition.  The boot record, in this example, is located at offset 0 within this block.  The formatting utility will need the media geometry information previously obtained.  The block allocation structure in the first block will also have to be updated to include the entries for the boot record and root directory.  If desired, the formatting utility can also include a 'volume label' during the formatting process.  A 'volume label' is created by creating a FileEntry structure, assigning it the attribute of 'volume label', and pointing the primary pointer of the root directory at the FileEntry.  This makes the 'volume label' appear as a child of the root directory, which it must properly be.  If a volume label isn't desired, then the root directory entry PrimaryPtr is simply left FNULL and the volume label isn't written.  This example includes a volume label.</P>
<P>The physical block containing the BlockSeq value of 0 was arbitrarily chosen to contain the boot record, root directory entry, volume label, and corresponding block allocation structure for this partition.  However, they could be located anywhere in the partition.</P>
<P>The structure members of the BootRecord must be assigned the following values.</P>
<P>BootRecord    struc<BR>    Signature    dw    F1A5h    ; FLASH media signature.<BR>    SerialNumber    dd    ?    ; Holds a unique identifier for the partition. <BR>    FFSWriteVersion    dw    0200h    ; FFS Version 2.0 required for write.<BR>    FFSReadVersion    dw    0200h    ; FFS Version 2.0 required for read.<BR>    TotalBlockCount    dw    ?    ; Media implementation dependent.<BR>    SpareBlockCount    dw    0001h    ; Minimum of one.  Maximum of 8.<BR>    BlockLen    dd    ?    ; Media implementation dependent.<BR>    RootDirectoryPtr    dd    00000001h    ; Pointer to the root DirEntry.<BR>    Status    dw    FFFFh    ; MS-DOS file naming conventions.<BR>    BootCodeLen    dw    0000h    ; Indicates no boot code is in this boot record.  This<BR>                ;    card is not bootable.<BR>    BootCode    db    ...    ; If the media were bootable, boot code would be inserted<BR>                ;    here. This field is not allocated. BootCodeLen is the last<BR>                ;    valid field.<BR>BootRecord    ends</P>
<P>The root DirEntry, in this example, immediately follows the BootRecord structure.  It starts precisely where the BootRecord ends.  The structure members of the root DirEntry structure should be assigned the following values.</P>
<P>RootDirEntry    struc<BR>    Status    dw    FFE1h    ; Indicates that the directory entry exists &amp; does NOT<BR>                ; have most recent attribute/date/time information,<BR>                ; &amp; primary pointer is valid (points to volume label).<BR>    SiblingPtr    dd    FFFFFFFFh    ; FNULL pointer value. <BR>                ; The ROOT must NEVER have a sibling!<BR>    PrimaryPtr    dd    00000002h    ; Pointer to the volume label.<BR>    SecondaryPtr    dd    FFFFFFFFh    ; FNULL pointer value.<BR>                ; The ROOT must NEVER be superseded!<BR>    Attributes    db    10h    ; Same format as MS-DOS attributes.<BR>                ;     Bits    Definition<BR>                ;    7-6    Reserved.  Must be 0's.<BR>                ;    5    1 = ARCHIVE file was modified<BR>                ;    4    1 = DIRECTORY   0 = file<BR>                ;    3    1 = VOLUME label<BR>                ;    2    1 = SYSTEM file or directory<BR>                ;    1    1 = HIDDEN file or directory<BR>                ;    0    1 = READONLY file<BR>    Time    dw    FFFFh    ; Left all ones (unused).</P>
<P>    Date    dw    FFFFh    ; Left all ones (unused).<BR>    VarStructLen    dw    0    ; No variable length structs follow Name.Ext.<BR>    NameLen    db    11    ; MS-DOS name length.<BR>    Name    db    "ROOT    "    ; The root directory has a name.ext of 'ROOT       '.<BR>    Ext    db    "   "    ; <BR>RootDirEntry    ends</P>
<P>The volume label VolLabelFileEntry, in this example, immediately follows the RootDirEntry structure.  It starts precisely where the RootDirEntry ends.  The structure members of the root VolLabFileEntry structure should be assigned the following values.</P>
<P>VolLabFileEntry    struc<BR>    Status    dw    FFF7h    ; Indicates that the file entry exists,                        ; &amp; has most recent attrib/time/date information. <BR>    SiblingPtr    dd    FFFFFFFFh    ; FNULL pointer value (no initial siblings). <BR>    PrimayPtr    dd    FFFFFFFFh    ; FNULL pointer value (no children, ever).<BR>    SecondaryPtr    dd    FFFFFFFFh    ; FNULL pointer value (not superseded).<BR>                ; The ROOT will never be superseded!<BR>    Attributes    db    08h    ; Same format as MS-DOS attributes.<BR>                ;     Bits    Definition<BR>                ;    7-6    Reserved.  Must be 0's.<BR>                ;    5    1 = ARCHIVE file was modified<BR>                ;    4    1 = DIRECTORY   0 = file<BR>                ;    3    1 = VOLUME label<BR>                ;    2    1 = SYSTEM file or directory<BR>                ;    1    1 = HIDDEN file or directory<BR>                ;    0    1 = READONLY file<BR>    Time    dw    (FILL IN)    ; Same format as MS-DOS time.<BR>                ;     Bits    Definition<BR>                ;    15..11    Binary number of hours (0-23).<BR>                ;    10...5    Binary number of minutes (0-59).<BR>                ;    4...0    Binary number of 2 second increments<BR>                ;        (0-29, corresponding to 0-58 seconds).<BR>    Date    dw    (FILL IN)    ; Same format as MS-DOS date.<BR>                ;    Bits    Definition<BR>                ;    15...9    Year (relative to 1980)<BR>                ;    8...5    Month (1-12)<BR>                ;    4...0    Day of month (1-31)<BR>    VarStructLen    dw    0    ; No variable length structs follow Name.Ext.<BR>    NameLen    db    11    ; MS-DOS name length.<BR>    Name    db    "BOGFLOB "    ; The volume is named 'BOGFLOB    '.<BR>    Ext    db    "   "    ; <BR>VolLabFileEntry    ends</P>
<P>The Block Allocation structure <B>must</B> be located at the end of the specified physical block.  The structure members of the Block Allocation structure must be assigned the following values.</P>
<P>Block    struc</P>
<P>    ;------------------------------------------------------------------------------</P>
<P>    ; Alloc[2] --- Third, and last, allocation: the volume label</P>
<P>    ;------------------------------------------------------------------------------</P>
<P>    Status2    db    BFh    ; Active &amp; last FileEntry allocation.</P>
<P>    Offset2    db    (size BootRecord + size RootDirEntry),0,0    ; Offset, relative to the beginning of this  </P>
<P>                ;   block, of the volume label FileEntry.</P>
<P>    Len2    dw    (size VolLabFileEntry)    ; Length of this allocation.<BR></P>
<P>    ;------------------------------------------------------------------------------</P>
<P>    ; Alloc[1] --- Second, and not last, allocation: the root directory</P>
<P>    ;------------------------------------------------------------------------------</P>
<P>    Status1    db    3Fh    ; Active &amp; not last DirEntry allocation.</P>
<P>    Offset1    db    size BootRecord,0,0    ; Offset, relative to the beginning of this block,</P>
<P>                ;   of the root DirEntry.</P>
<P>    Len1    dw    (size RootDirEntry)    ; Length of this allocation.<BR></P>
<P>    ;------------------------------------------------------------------------------</P>
<P>    ; Alloc[0] --- First, and not last, allocation: the boot record</P>
<P>    ;------------------------------------------------------------------------------</P>
<P>    Status0    db    3Fh    ; Active &amp; not last BootRecord allocation.</P>
<P>    Offset0    db    0, 0, 0    ; Offset, relative to the beginning of this block,</P>
<P>                ;   of the BootRecord.</P>
<P>    Len0    dw    (size BootRecord)    ; Length of this allocation.</P>
<P></P>
<P>    ;------------------------------------------------------------------------------</P>
<P>    ; Fixed length portion of BlockAlloc record</P>
<P>    ;------------------------------------------------------------------------------</P>
<P>    BootRecordPtr    dd    00000000h    ; Pointer to the BootRecord.<BR>    EraseCount    dd    (FILL IN)    ; Must be at least 1 or greater depending on whether <BR>                ;    this partition had been used previously.<BR>    BlockSeq    dw    0000h    ; Block 0 within the sequence of blocks in this <BR>                ;    partition.<BR>    BlockSeqChecksum    dw    FFFFh    ; Checksum for a block sequence value of 0.<BR>    Status    dw    C3FEh    ; Block contains allocations and the boot record for <BR>                ;     the partition and is ready for use.<BR>Block    ends</P>
<P>8.    Indicate to the file system that the media has changed.  Not doing so will cause the file system to malfunction.</P>
At this point the newly created partition is ready for use. The guidelines provided in this section assume that the format utility is processing blocks in their physical order starting at the first block and proceeding to the last block in the partition.  This is done only for the sake of example.</P></BODY></HTML>
