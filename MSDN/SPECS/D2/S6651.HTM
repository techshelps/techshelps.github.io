<HTML><HEAD><META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Lexical scope linkage</TITLE><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">
</OBJECT></FORM>
<H2>Lexical scope linkage</H2>The model of a program envisioned by this document is that programs have nested scopes.  The outermost scope is module scope which encompasses all of the symbols not defined within any inner (lexical) scope.  Symbols and types defined at one scoping level are visible to all scopes nested within it.  Symbols and types defined at module scope are visible to all inner scopes.  </P>
The next level of scoping is "function" scope, which in turn contains lexical blocks (including other functions scopes) that can be further nested.  Nested lexical scopes are opened by a procedure, method, thunk, with, or block start symbol.  They are closed by the matching block-end symbol.</P>
In general, symbol searching within a module's symbol table is performed in the following manner.  The lexical scope that contains the current program address is searched for the symbol.  If the symbol is not found within that scope, the enclosing lexical scope is searched.  This search is repeated outward until the symbol is found or module scope is searched unsuccessfully.  Note that lexical scopes at the same depth level are not searched.  As an optimization for CodeView, symbols that open a lexical scope have fields that contain offsets from the beginning of the symbols for the module that point to the parent of the scope, the next lexical scope that is at the same scoping level and the S_END symbol that closes this lexical scope.</P>
The <I>pParent, pNext</I> and<I> pEnd</I> fields described below are filled in by CVPACK and should be emitted as zeroes by the language processor.</P>
<P></P>

<TABLE COLS="2" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="52pt" VALIGN="TOP"><COL WIDTH="324pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B>Field</B></P></TD><TD VALIGN="TOP"><P>Linkage</P></TD></TR><TR><TD VALIGN="TOP"><P><I>pParent</I></P></TD><TD VALIGN="TOP"><P>Used in local procedures, global procedures, thunk start, with start, and block start symbols.  If the scope is not enclosed by another lexical scopes, then <I>pParent</I> is zero.  Otherwise, the parent of this scope is the symbol within this module that opens the outer scope that encloses this scope but  encloses no other scope that encloses this scope.  The <I>pParent</I> field contains the offset from the begining of the module's symbol table of the symbol that opens the enclosing lexical scope.</P></TD></TR><TR><TD VALIGN="TOP"><P><I>pNext</I></P></TD><TD VALIGN="TOP"><P>Used in start search local procedures, global procedures, and thunk start symbols.  The <I>pNext</I> field, along with the start search symbol, defines a group of lexically scoped symbols within a symbol table that are contained within a code segment or PE section.  For each segment or section represented in the symbol table, there is a start search symbol that contains the offset from the start of the symbols for this module to the first procedure or thunk contained in the segment.  Each outermost lexical scope symbol has a next field containing the next outermost scope symbol contained in the segment.  The last outermost scope in the symbol table for each segment has a next field of zero.</P></TD></TR><TR><TD VALIGN="TOP"><P><I>pEnd</I></P></TD><TD VALIGN="TOP"><P>This field is defined for local procedures, global procedures, thunk, block, and with symbols.  The end field contains the offset from the start of the symbols for this module to the matching block end symbol that terminates the lexical scope.</P></TD></TR></TBODY></TABLE>
<BR></P></BODY></HTML>
