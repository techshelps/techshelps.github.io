<HTML><HEAD><META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Device Identification</TITLE><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">
</OBJECT></FORM>
<H3>Device Identification</H3></P>
<H4><A NAME="sec0"></A>General Requirements</H4>The following requirements apply to both the "Minimum Requirements" and "Optimal Requirements" sections below. </P>
</P>
<SPAN CLASS="Symbol">·    </SPAN>All strings must be composed of ASCII values between 32-127 (20h-7Fh), inclusive.</P>
<SPAN CLASS="Symbol">·    </SPAN>All MANUFACTURER, MODEL, CLASS, and COMPATIBLE ID key values must remain static for any device. For a specific hardware configuration of a device, the values of these fields should not change regardless of how NVRAM settings have been configured. However, if additional hardware is installed which requires different device drivers, the device ID keys can differ from what has been originally returned by the device. See the section below for a discussion of multiple "personality" devices. </P>
<SPAN CLASS="Symbol">·    </SPAN>All MANUFACTURER, and MODEL key values must <B>remain unique from each manufacturer</B>.</P>
</P>
<H4><A NAME="sec1"></A>Minimum Requirements</H4></P>
The minimum requirements for reporting device ID's are as described in Section 6.6 of the IEEE 1284 specification. Specifically, these are (case sensitive): <B>MANUFACTURER</B>, <B>COMMAND SET</B>, and <B>MODEL</B>. (The abbreviations: <B>MFG</B>, <B>CMD</B>, and <B>MDL</B> are acceptable, as described in the IEEE 1284 specification). The COMMAND SET field will be ignored under Chicago. </P>
</P>
A unique Plug &amp; Play ID will be generated for the device using the following algorithm: The MANUFACTURER &amp; MODEL fields will be concatenated, and then a 4 digit checksum will be generated on the resulting string.  After the check sum is computed the string will be truncated to 20 characters if its length exceeds 20 characters. The checksum will then be converted to a 4 character string, and appended to the above truncated string, resulting in a string of 24 characters or less. </P>
</P>
A code fragment that illustrates how the checksum &amp; device ID values are generated is listed at the end of this document.</P>
</P>
For example, the following device ID string will be generated for the HP LaserJet 4P printer:</P>
</P>
<B>"Hewlett-PackardHP_La7EE2"</B></P>
</P>
since the MFG field is Hewlett-Packard, and the MDL field is HP LaserJet 4P.</P>
</P>
The parallel port enumerator will then prepend "LPTENUM\" (minus quotes) to the string generated above, and the resulting string will be the Plug and Play ID value. The Plug &amp; Play ID will be used to search all known device information files (INF in Windows) available on the host for a driver which will support the device. Note the ordering of device ID values listed in the INF files will be significant in determining the device driver which is the "best match" for a given device. See the section below on "Ordering Device ID values" for a more detailed description.</P>
</P>
<H4><A NAME="sec2"></A>Optimal Requirements</H4></P>
The recommended requirements for reporting device ID's are as described in the previous section, with 3 additional keywords defined: <B>CLASS, DESCRIPTION</B> and <B>COMPATIBLE ID</B> (which may be abbreviated as <B>CLS, DES, </B>and <B>CID</B> respectively). Note these values are not case sensitive.</P>
</P>
    <B>CLASS</B> should have one of the following values: <B>PRINTER, MODEM, NET, HDC</B><B>, PCMCIA, MEDIA</B><B>, FDC</B><B>, PORTS, SCANNER, DIGCAM</B></P>
<B></B></P>
    <B>DESCRIPTION</B> key is an ASCII string that provides the description of the device the manufacturer would like presented to the user if an INF file is not found. The<B> DESCRIPTION</B> key should be no longer than 128 characters.</P>
</P>
<B>    COMPATIBLE ID</B> key may have any value that exactly matches an ID value listed in an INF file, as described in the previous section.  Additionally there may be Plug &amp; Play IDs assigned to legacy parallel port devices which have driver support in Chicago.  These IDs may also be specified in the CID field. If the device is not compatible with another device, or the manufacturer does not wish to have a compatible device driver used, there is no need to support this keyword.</P>
</P>
<H4><A NAME="sec3"></A>Additional Information on Compatible ID values</H4></P>
The values returned for COMPATIBLE ID should be carefully chosen. If a device returns a compatible ID which is an <B>exact</B> match for a device ID for another vendors device, sufficient care should be taken to ensure that  the manufacturer of the device which is returning the compatible ID has license rights to install the device driver from the vendor  providing the device driver. Microsoft will supply values for COMPATIBLE ID values for many of the printer drivers shipped with Chicago, and vendors are encouraged to freely use these values for COMPATIBLE ID keywords. Additional information on the exact syntax for COMPATIBLE ID values for specific printer models will be provided in the Chicago Device Driver Kit (DDK).<BR></P>
The syntax of the string returned from the device as the COMPATIBLE ID value will be slightly different depending on exactly what a given device is reporting itself as being compatible with.  More specifically, if the device is reporting a compatible ID for the exact device ID of another  physical device, it will need to include the enumerator name as part of the Compatible ID field. Otherwise, one of the compatible ID values documented in the Chicago Device Driver Kit may be used, which will not require the enumerator name. An example will illustrate this best. Suppose the INF file contains the following entry:</P>
</P>
"Sample Printer"                                           =X.DRV,LPTENUM\Sample_Printer_CompaAAAA</P>
</P>
The example above is a listing a printer driver which displays the printer name "Sample Printer", which is supported by X.DRV, and the Plug and Play ID generated from the P1284 keywords (as described later in this paper) is "Sample_Printer_CompaAAAA". As described earlier, the parallel port enumerator will prepend "LPTENUM\" to this, and the resulting value is what is listed in the INF file.</P>
</P>
If another device wished to report itself as compatible with this device, it would need to report its CID keyword as (minus quotes) "LPTENUM\Sample_Printer_CompaAAAA". Alternatively, it could report its CID keyword as (minus quotes) "Sample_Printer_CompaAAAA" only if the INF file contained the line below, duplicating the original ID without the LPTENUM reference:</P>
</P>
"Sample Printer"                                           =X.DRV,LPTENUM\Sample_Printer_CompaAAAA, Sample_Printer_CompaAAAA</P>
</P>
Note that the very first time Chicago is started on a machine, the way in which compatible ID values are processed is handled slightly differently than subsequent sessions. See the section below on "Ordering Device ID values" for more information on compatible ID's.</P>
</P>
A printer which is compatible with the HP LaserJet 4L, and has the necessary rights to use a driver provided by Hewlett-Packard, will return the following string in its compatible ID field:</P>
</P>
<B>"CID:LPTENUM\Hewlett-PackardLaserC029"</B></P>
</P>
A printer which is compatible with the HP LaserJet 4L, and wishes to report the compatible ID for the driver provided by Microsoft will return the following string in its compatible ID field:</P>
</P>
<B>"CID:HP_LaserJet_4L"</B></P>
</P>
</P>
<H4><A NAME="sec4"></A>INF file Requirements</H4></P>
The information described above covers what devices should be reporting back as device identification values. Additional information on the INF file format for Plug &amp; Play devices and specific classes is included in the Chicago Device Driver Kit (DDK)</P>
</P>
<H4><A NAME="sec5"></A>Multiple Emulation (&quot;Personality&quot;) Device Requirements</H4></P>
It is becoming increasingly common for printers to support multiple Page Description Languages, (such as HP-PCL &amp; PostScript) which require separate printer drivers under Windows, or to even for a given device to be multi-function (printer+fax, printer+SCSI drive, etc.). Plug and Play supports the notion of mapping a single device ID for a given device to a single device driver, but not the notion of mapping a <B><I>single</I></B> device ID to multiple device drivers. However, Plug and Play does provide solutions to address this issue, on either the enumerator or class installer level.</P>
</P>
<B>Multiple device drivers installed via a bus enumerator</B></P>
Certain bus enumerators, such as serial ports, provide a mechanism for the device to report multiple device ID values, each of which maps to a specific device driver. The parallel port bus enumerator does not support the ability to enumerate multiple device ID values. Please refer to the "Plug and Play COM Device"  (currently Draft) Specification for additional information on enumerating ID values for a multi-functional device over a serial port.</P>
</P>
<B>Multiple device drivers installed via a class installer</B></P>
Certain class installers, such as the printer class installer under Chicago, provide a mechanism for device vendors to supply their own DLLs which may install device driver support via one of two possible methods. The first method allows the printer class installer provided with Chicago to carry out installation of 1 printer driver (the one which is mapped to a particular printer driver via the Plug and Play ID in an INF file), and then call into a vendor supplied 32 bit DLL at the end of the printer installation process which may then choose to either install additional printer driver(s), or call other class installers to install additional device drivers as needed. The second method allows a vendor supplied DLL  to perform all of the functionality required to install one or more device driver by allowing the printer class installed supplied with Chicago to copy files from an installation diskette &amp; then the printer class installer will call directly into the vendor supplied DLL to perform the rest of the installation process. In both cases, information on the DLL &amp; the entry point to call is provided by the INF file. Additional information on this will be provided in the Chicago Device Driver Kit (DDK).</P>
</P>
<H4><A NAME="sec6"></A>Ordering of Device ID &amp; Compatible Device ID values</H4></P>
As described earlier, the compatible device ID provides the IDs of other devices with which this device is compatible.  The operating system uses this information to load compatible device drivers if necessary.  There can be several compatible device identifiers for each logical device.  The order in which these device IDs are listed in an INF file may be used by the operating system as a criteria for determining which driver should be searched for and loaded first. The information below discussed the impact of ordering device ID values under Chicago.</P>
</P>
The ordering scheme assigns a numeric "rank" value to each ID value, and the lower the rank order the better match a given device driver is considered to be for a given device. A rank order of 0 is determined to be an exact match and when a rank order match of 0 is found the device driver will automatically be installed without prompting the user. If a rank order match of 0 is not found, but a higher order rank match is, the user will be informed that a compatible device driver is available, and the user may either provide a diskette containing the device driver (ideally a rank 0 matching driver) for the device, or choose the most compatible driver as desired. If the user selects the compatible driver, the "best" match (lowest rank order matching) driver will be installed.</P>
</P>
Rank ordering is determined as follows:</P>
</P>
1) Taking the list of all ID values returned by the device, and assign a rank value to them. The device ID build from the MFG and MDL keywords is assigned rank 0, the first CID listed (if present) is assigned rank 1, the 2nd (if present) CID is assigned a rank of 2, etc.</P>
</P>
2) Search the contents of the INF files on the host system for matches with any of the ID values returned by the device.</P>
</P>
3) In cases where an exact match is found, create an "INF rank value", (which is determined by the order that the ID is found in the list after a particular driver, the 1st ID listed in the INF after a particular driver is assigned INF rank of 0, the ID following the 1st (for the same driver) ID is assigned an INF rank of 1, the next (3rd) ID after that is assigned INF rank of 2 etc.), and then add the INF rank value to the rank value of the ID from the device.</P>
</P>
4) Once all INF files have been searched, and all rank values have be determined, if a rank 0 match is found, automatically install the driver without prompting the user. If no rank 0 matches exist, prompt the user if they wish to supply a diskette with a driver for the device, or the user can choose to install the default, compatible, device driver.</P>
</P>
Two examples of how this would work are provided below:</P>
</P>
<B>Example #1:</B></P>
</P>
INF file contains:</P>
</P>
"Sample Printer 1"                                           =X1.DRV,LPTENUM\Sample_Printer_CompaAAAA, Sample_Printer_CompaBBBB</P>
"Sample Printer 2"                                           =X2.DRV,LPTENUM\Sample_Printer_CompaCCCC, LPTENUM\Sample_Printer_CompaDDDD, Sample_Printer_CompaEEEE</P>
</P>
Device returns the following:</P>
</P>
    Device ID (built as described elsewhere in this paper)="LPTENUM\Sample_Printer_CompaCCCC"</P>
    Compatible ID="CID:LPTENUM\ Sample_Printer_CompaAAAA, Sample_Printer_CompaBBBB"</P>
</P>
In this example, the device returns a device ID which is found to have a rank 0 match for "Sample Printer 2" (X2.DRV), and that driver is installed automatically without prompting the user (except to supply diskettes that contain required files). The other ID values are essentially ignored since a rank 0 match was found.</P>
</P>
<B>Example #2:</B></P>
</P>
INF file contains:</P>
</P>
"Sample Printer 1"                                           =X1.DRV,LPTENUM\Sample_Printer_CompaAAAA, Sample_Printer_CompaBBBB</P>
"Sample Printer 2"                                           =X2.DRV,LPTENUM\Sample_Printer_CompaCCCC, LPTENUM\Sample_Printer_CompaDDDD, Sample_Printer_CompaEEEE</P>
"Sample Printer 3"                                           =X3.DRV,LPTENUM\Sample_Printer_CompaFFFF, LPTENUM\Sample_Printer_CompaGGGG, Sample_Printer_CompaHHHH</P>
</P>
Device returns the following:</P>
</P>
    Device ID (built as described elsewhere in this paper)="LPTENUM\Sample_Printer_CompaDDDD"</P>
    Compatible ID="CID:LPTENUM\ Sample_Printer_CompaHHHH, Sample_Printer_CompaBBBB"</P>
</P>
In this example, the device returns a device ID which is not found to have a rank 0 match with any ID values in INF files on the host system. After calculating all of the rank assignments, "Sample Printer 2" (X2.DRV) is determined to have a rank value of 1 (and hence the best match), "Sample Printer 3" (X3.DRV) is determined to have a rank value of 3, and "Sample Printer 1" (X1.DRV) is also determined to have a rank value of 3. The user will then be prompted that an exact match has not been found, but that compatible drivers are available, and offer the opportunity to provide a diskette supplied by the vendor, or for the user to accept the default driver. If the user choose to accept the default driver, the lowest rank order matching driver will be used.</P>
</P>
The only variation on the behavior described above is the very first time Chicago is started on a system. In this one scenario, the best rank matched compatible device driver  will be installed automatically without prompting the user.</P>
<H4><A NAME="sec7"></A>Algorithm for building Plug and Play device ID values for parallel devices</H4></P>
The following code fragment illustrates how parallel devices will have device ID values generated based on the MFG and MDL keywords under Chicago.</P>
</P>
<pre><code>#define MAX_DEVNODE_NAME_ROOT        20</BR>
#define _16_BIT_CHECKSUM            5</BR>
</BR>
WORD    wCRC16a[16]={</BR>
    0000000,    0140301,    0140601,    0000500,</BR>
    0141401,    0001700,    0001200,    0141101,</BR>
    0143001,    0003300,    0003600,    0143501,</BR>
    0002400,    0142701,    0142201,    0002100,</BR>
};</BR>
</BR>
WORD    wCRC16b[16]={</BR>
    0000000,    0146001,    0154001,    0012000,</BR>
    0170001,    0036000,    0024000,    0162001,</BR>
    0120001,    0066000,    0074000,    0132001,</BR>
    0050000,    0116001,    0104001,    0043000,</BR>
};</BR>
</BR>
void BuildP1284PnPID</BR>
(</BR>
    void</BR>
)</BR>
{</BR>
    WORD    wCheckSum;              </BR>
    char    szCheckSum[_16_BIT_CHECKSUM];   </BR>
    WORD    wTempSize;</BR>
</BR>
    LPSTR   lpMFG = NULL;</BR>
    LPSTR   lpMDL = NULL;</BR>
</BR>
    // The following are used to generate checksum values</BR>
    PBYTE   pb;</BR>
    BYTE    bTmp;</BR>
    ULONG   ulSize, ulSeed;</BR>
    PULONG  pulSeed;</BR>
    </BR>
    // following fills in the lpMDL &amp; lpMFG values as returned from device</BR>
    FindP1284Keys(&amp;lpMFG, &amp;lpMDL);</BR>
</BR>
    // N:  Concatenate the MFG and MDL fields</BR>
    wTempSize = (WORD) lstrlen(lpMFG) + (WORD) lstrlen(lpMDL);</BR>
    </BR>
    // Concatenate the provided MFG and MDL P1284 fields</BR>
    lstrcpy(szTemp, lpMFG);</BR>
    lstrcat(szTemp, lpMDL);</BR>
    ulSize=lstrlen(szTemp); </BR>
</BR>
    // Checksum the string</BR>
    // start a seed at 0, and create a pointer to the seed.  After the</BR>
    // checksum, convert the checksum to a word.</BR>
    ulSeed = 0;  </BR>
    pulSeed = &amp;ulSeed;</BR>
</BR>
    for (pb=(BYTE *)szTemp; ulSize; ulSize--, pb++) </BR>
    {</BR>
        bTmp=(BYTE)(((WORD)*pb)^((WORD)*pulSeed));      // Xor CRC with new char</BR>
        *pulSeed=((*pulSeed)&gt;&gt;8) ^ wCRC16a[bTmp&amp;0x0F] ^ wCRC16b[bTmp&gt;&gt;4];</BR>
    }</BR>
    wCheckSum=(WORD)(*pulSeed);</BR>
    ConvertHexWORDToString(szCheckSum, wCheckSum);</BR>
</BR>
    // Form the Dev Node ID.</BR>
    if (wTempSize &gt; MAX_DEVNODE_NAME_ROOT)</BR>
        szTemp[MAX_DEVNODE_NAME_ROOT] = '\0';</BR>
       </BR>
    // Got to remove spaces from lpTemp, Just replace them with Underscores</BR>
    StringSubst ( szTemp, ' ', '_',</BR>
                  wTempSize &gt; MAX_DEVNODE_NAME_ROOT ? MAX_DEVNODE_NAME_ROOT : wTempSize);</BR>
        </BR>
    lstrcpy(szDevNodeName, LPTENUM);</BR>
    lstrcat(szDevNodeName, szTemp);</BR>
    lstrcat(szDevNodeName, szCheckSum);</BR>
}</BR>
</code></pre></BODY></HTML>
