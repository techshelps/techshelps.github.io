<HTML><HEAD><META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Symbols for 16:32 Segmented and 32-bit Flat Architectures</TITLE><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">
</OBJECT></FORM>
<H2>Symbols for 16:32 Segmented and 32-bit Flat Architectures</H2></P>
<H3><A NAME="sec0"></A>(0x1006) BP Relative 16:32 </H3>This symbol specifies symbols that are allocated on the stack for a procedure.  For C/C++, these include the actual parameters to a function and the local nonstatic variables of functions.</P>
</P>

<TABLE COLS="5" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="68pt" VALIGN="TOP"><COL WIDTH="68pt" VALIGN="TOP"><COL WIDTH="67pt" VALIGN="TOP"><COL WIDTH="63pt" VALIGN="TOP"><COL WIDTH="72pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>2</P></TD><TD VALIGN="TOP"><P>2</P></TD><TD VALIGN="TOP"><P>4</P></TD><TD VALIGN="TOP"><P>4</P></TD><TD VALIGN="TOP"><P>*</P></TD></TR><TR><TD VALIGN="TOP"><P>length</P></TD><TD VALIGN="TOP"><P>S_BPREL32</P></TD><TD VALIGN="TOP"><P>offset</P></TD><TD VALIGN="TOP"><P>@type</P></TD><TD VALIGN="TOP"><P>name</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>
<P><I>offset</I>    Signed offset relative to BP.  If <I>offset</I>  is 0, then the symbol was assigned to a register or never instantiated by the optimizer and cannot be evaluated because its location is unknown.</P>
<P><I>@type </I>    Type of the symbol</P>
<P><I>name</I>    Length-prefixed name of the symbol</P>
<H3><A NAME="sec1"></A>(0x1007) Local Data 16:32 </H3>These symbols are used for data that is not exported from a module.  In C/C++, symbols that are declared static are emitted as Local Data symbols.  Symbols that are emitted as Local Data cannot be moved by CVPACK into the global symbol table for the executable file.</P>
</P>

<TABLE COLS="6" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="50pt" VALIGN="TOP"><COL WIDTH="72pt" VALIGN="TOP"><COL WIDTH="58pt" VALIGN="TOP"><COL WIDTH="58pt" VALIGN="TOP"><COL WIDTH="54pt" VALIGN="TOP"><COL WIDTH="54pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>2</P></TD><TD VALIGN="TOP"><P>2</P></TD><TD VALIGN="TOP"><P>4</P></TD><TD VALIGN="TOP"><P>4</P></TD><TD VALIGN="TOP"><P>2</P></TD><TD VALIGN="TOP"><P>*</P></TD></TR><TR><TD VALIGN="TOP"><P>length</P></TD><TD VALIGN="TOP"><P>S_LDATA32</P></TD><TD VALIGN="TOP"><P>@type</P></TD><TD VALIGN="TOP"><P>offset</P></TD><TD VALIGN="TOP"><P>segment</P></TD><TD VALIGN="TOP"><P>name</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>
<P><I>@type</I>    Type index of the symbol.</P>
<P><I>offset</I>    Offset portion of the symbol address.</P>
<P><I>segment</I>    Segment portion of the symbol. address</P>
<P><I>name</I><I>    </I>Length-prefixed name of symbol</P>
<H3><A NAME="sec2"></A>(0x1008 Global Data Symbol 16:32 )</H3>This symbol record has the same format as the Local Data 16:32 except that the record type is S_GDATA32.   For C/C++, symbols that are not specifically declared static are emitted as Global Data Symbols and can be compacted by CVPACK into the global symbol table.</P>
<H3><A NAME="sec3"></A>(0x1009) Public 16:32 </H3>This symbol has the same format as the Local Data 16:32 symbol.  Its use is reserved to symbols in the Publics table emitted by the linker into the Symbol and Type OMF portion of the executable file.  </P>
<H3><A NAME="sec4"></A>(0x100a) Local Procedure Start 16:32 </H3>This symbol record defines local (file static) procedure definition.  For C/C++, functions that are declared static to a module are emitted as Local Procedure symbols.  Functions not specifically declared static are emitted as Global Procedures (see below.)</P>
</P>

<TABLE COLS="8" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="41pt" VALIGN="TOP"><COL WIDTH="50pt" VALIGN="TOP"><COL WIDTH="58pt" VALIGN="TOP"><COL WIDTH="36pt" VALIGN="TOP"><COL WIDTH="36pt" VALIGN="TOP"><COL WIDTH="64pt" VALIGN="TOP"><COL WIDTH="57pt" VALIGN="TOP"><COL WIDTH="33pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>2</P></TD><TD VALIGN="TOP"><P>2</P></TD><TD VALIGN="TOP"><P>4</P></TD><TD VALIGN="TOP"><P>4</P></TD><TD VALIGN="TOP"><P>4</P></TD><TD VALIGN="TOP"><P>4</P></TD><TD VALIGN="TOP"><P>4</P></TD><TD VALIGN="TOP"><P></P></TD></TR><TR><TD VALIGN="TOP"><P>length</P></TD><TD VALIGN="TOP"><P>symbol</P></TD><TD VALIGN="TOP"><P>pParent</P></TD><TD VALIGN="TOP"><P>pEnd</P></TD><TD VALIGN="TOP"><P>pNext</P></TD><TD VALIGN="TOP"><P>proc length</P></TD><TD VALIGN="TOP"><P>debug start</P></TD><TD VALIGN="TOP"><P>-&gt;</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>

<TABLE COLS="6" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="59pt" VALIGN="TOP"><COL WIDTH="52pt" VALIGN="TOP"><COL WIDTH="52pt" VALIGN="TOP"><COL WIDTH="55pt" VALIGN="TOP"><COL WIDTH="81pt" VALIGN="TOP"><COL WIDTH="72pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>4</P></TD><TD VALIGN="TOP"><P>4</P></TD><TD VALIGN="TOP"><P>4</P></TD><TD VALIGN="TOP"><P>2</P></TD><TD VALIGN="TOP"><P>1</P></TD><TD VALIGN="TOP"><P>*</P></TD></TR><TR><TD VALIGN="TOP"><P>debug end</P></TD><TD VALIGN="TOP"><P>@proctype</P></TD><TD VALIGN="TOP"><P>offset</P></TD><TD VALIGN="TOP"><P>segment</P></TD><TD VALIGN="TOP"><P>flags</P></TD><TD VALIGN="TOP"><P>name</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>
<P><I>symbol</I>    S_LPROC32 or S_GPROC32.</P>
<P><I>pParent</I>    See the section on lexical scope linking</P>
<P><I>pEnd</I>    See the section on lexical scope linking</P>
<P><I>pNext</I>    See the section on lexical scope linking</P>
<P><I>proc length</I>    Length in bytes of this procedure</P>
<P><I>debug start</I>    Offset in bytes from the start of the procedure to the point where the stack frame has been set up.  Parameter and frame variables can be viewed at this point.</P>
<P><I>debug end</I>    Offset in bytes from the start of the procedure to the point where the procedure is ready to return and has calculated its return value, if any.  Frame and register variables can still be viewed.</P>
<P><I>@proctype </I>    Type of the procedure type record</P>
<P><I>offset</I>    Offset portion of the procedure address </P>
<P><I>segment</I>    Segment portion of the procedure address</P>
<P><I>flags</I>    Procedure flags:<BR>fpo        :1    true if function has frame pointer omitted</P>
<P>    interrupt    :1    true if function is interrupt routine<BR>return        :1    true if function performs far return</P>
<P>    never        :1    true if function never returns</P>
<P>    unused        :4</P>
<P><I>name</I>    Length-prefixed name of procedure</P>
<H3><A NAME="sec5"></A>(0x100b) Global Procedure Start 16:32 </H3>This symbol is used for procedures that are not specifically declared static to a module.  The format is the same as the Local Procedure Start 16:32 symbol (see above.)</P>
<H3><A NAME="sec6"></A>(0x0206) Thunk Start 16:32 </H3>This record is used to specify any piece of code that exists outside a procedure.  It is followed by an End record.  The thunk record is intended for small code fragments. and a two byte length field is sufficient for its intended purpose.<B> </B></P>
</P>

<TABLE COLS="7" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="43pt" VALIGN="TOP"><COL WIDTH="70pt" VALIGN="TOP"><COL WIDTH="45pt" VALIGN="TOP"><COL WIDTH="58pt" VALIGN="TOP"><COL WIDTH="45pt" VALIGN="TOP"><COL WIDTH="43pt" VALIGN="TOP"><COL WIDTH="51pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>2</P></TD><TD VALIGN="TOP"><P>2</P></TD><TD VALIGN="TOP"><P>4</P></TD><TD VALIGN="TOP"><P>4</P></TD><TD VALIGN="TOP"><P>4</P></TD><TD VALIGN="TOP"><P>4</P></TD><TD VALIGN="TOP"><P>2</P></TD></TR><TR><TD VALIGN="TOP"><P>length</P></TD><TD VALIGN="TOP"><P>S_THUNK32</P></TD><TD VALIGN="TOP"><P>pParent</P></TD><TD VALIGN="TOP"><P>pEnd</P></TD><TD VALIGN="TOP"><P>pNext</P></TD><TD VALIGN="TOP"><P>offset</P></TD><TD VALIGN="TOP"><P>segment</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>

<TABLE COLS="4" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="68pt" VALIGN="TOP"><COL WIDTH="54pt" VALIGN="TOP"><COL WIDTH="63pt" VALIGN="TOP"><COL WIDTH="67pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>2</P></TD><TD VALIGN="TOP"><P>1</P></TD><TD VALIGN="TOP"><P>*</P></TD><TD VALIGN="TOP"><P>*</P></TD></TR><TR><TD VALIGN="TOP"><P>thunk length</P></TD><TD VALIGN="TOP"><P>ordinal</P></TD><TD VALIGN="TOP"><P>name</P></TD><TD VALIGN="TOP"><P>variant</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>
<P><I>pParent</I>    See the section on lexical scope linking</P>
<P><I>pEnd</I>     See the section on lexical scope linking</P>
<P><I>pNext</I>     See the section on lexical scope linking</P>
<P><I>offset</I>    Offset portion of the thunk address </P>
<P><I>segment</I>    Segment portion of the thunk address</P>
<P><I>thunk length</I>     Length in bytes of this thunk</P>
<P><I>ordinal</I>    Ordinal specifying the type of thunk </P>
<P>    0    notype</P>
<P>    1    adjustor</P>
<P>    2    vcall</P>
<P>    3    pcode</P>
<P><I>name</I>     Length-prefixed name of thunk</P>
<P><I>variant</I>     Variant field, depending on value of <I>ordinal</I>.  If <I>ordinal </I>is notype, there is no variant field.  If <I>ordinal</I> is adjustor, the variant field is a two-byte signed value specifying the delta to be added to the <B>this</B> pointer, followed by the length prefixed name of the target function.  If the <I>ordinal</I> is vcall, then the variant field is a two-byte signed displacement into the virtual table.  If <I>ordinal</I> is pcode, the variant is the seg:offset of the pcode entry point.</P>
<H3><A NAME="sec7"></A>(0x0207) Block Start 16:32 </H3>This symbol specifies the start of an inner block of lexically scoped symbols.  The lexical scope is terminated by a matching S_END symbol.</P>
<P></P>

<TABLE COLS="8" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="42pt" VALIGN="TOP"><COL WIDTH="67pt" VALIGN="TOP"><COL WIDTH="42pt" VALIGN="TOP"><COL WIDTH="35pt" VALIGN="TOP"><COL WIDTH="41pt" VALIGN="TOP"><COL WIDTH="35pt" VALIGN="TOP"><COL WIDTH="50pt" VALIGN="TOP"><COL WIDTH="40pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>2</P></TD><TD VALIGN="TOP"><P>2</P></TD><TD VALIGN="TOP"><P>4</P></TD><TD VALIGN="TOP"><P>4</P></TD><TD VALIGN="TOP"><P>4</P></TD><TD VALIGN="TOP"><P>4</P></TD><TD VALIGN="TOP"><P>2</P></TD><TD VALIGN="TOP"><P>*</P></TD></TR><TR><TD VALIGN="TOP"><P>length</P></TD><TD VALIGN="TOP"><P>S_BLOCK32</P></TD><TD VALIGN="TOP"><P>pParent</P></TD><TD VALIGN="TOP"><P>pEnd</P></TD><TD VALIGN="TOP"><P>length</P></TD><TD VALIGN="TOP"><P>offset</P></TD><TD VALIGN="TOP"><P>segment</P></TD><TD VALIGN="TOP"><P>name</P></TD></TR></TBODY></TABLE>
<BR></P><P><I></I></P>
<P>pParent     See the section on lexical scope linking.</P>
<P><I>pEnd</I>     See the section on lexical scope linking.</P>
<P><I>length</I>    Length in bytes of the scope of this block</P>
<P><I>offset</I>    Offset portion of the segmented procedure address</P>
<P><I>segment</I>    Segment portion of the segmented procedure address</P>
<P><I>name</I>     Length-prefixed name of the block</P>
<H3><A NAME="sec8"></A>(0x0208) With Start 16:32 </H3></P>

<TABLE COLS="8" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="38pt" VALIGN="TOP"><COL WIDTH="58pt" VALIGN="TOP"><COL WIDTH="45pt" VALIGN="TOP"><COL WIDTH="32pt" VALIGN="TOP"><COL WIDTH="43pt" VALIGN="TOP"><COL WIDTH="45pt" VALIGN="TOP"><COL WIDTH="54pt" VALIGN="TOP"><COL WIDTH="45pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>2</P></TD><TD VALIGN="TOP"><P>2</P></TD><TD VALIGN="TOP"><P>4</P></TD><TD VALIGN="TOP"><P>4</P></TD><TD VALIGN="TOP"><P>4</P></TD><TD VALIGN="TOP"><P>4</P></TD><TD VALIGN="TOP"><P>2</P></TD><TD VALIGN="TOP"><P>*</P></TD></TR><TR><TD VALIGN="TOP"><P>length</P></TD><TD VALIGN="TOP"><P>S_WITH32</P></TD><TD VALIGN="TOP"><P>pParent</P></TD><TD VALIGN="TOP"><P>pEnd</P></TD><TD VALIGN="TOP"><P>length</P></TD><TD VALIGN="TOP"><P>offset</P></TD><TD VALIGN="TOP"><P>segment</P></TD><TD VALIGN="TOP"><P>expr</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>
<P><I>pParent</I>    See the section on lexical scope linking</P>
<P><I>pEnd</I>     See the section on lexical scope linking</P>
<P><I>length</I>     Length in bytes of the scope of the with block.</P>
<P><I>offset</I>    Offset portion of the segmented address of the start of the block</P>
<P><I>segment</I>    Segment portion of the segmented address of the start of the block</P>
<P><I>expr</I>     Length-prefixed ASCII string, evaluated at run time, of the expression used in the <B>with</B> statement.</P>
<H3><A NAME="sec9"></A>(0x0209) Code Label 16:32 </H3></P>

<TABLE COLS="6" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="61pt" VALIGN="TOP"><COL WIDTH="69pt" VALIGN="TOP"><COL WIDTH="61pt" VALIGN="TOP"><COL WIDTH="61pt" VALIGN="TOP"><COL WIDTH="61pt" VALIGN="TOP"><COL WIDTH="61pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>2</P></TD><TD VALIGN="TOP"><P>2</P></TD><TD VALIGN="TOP"><P>4</P></TD><TD VALIGN="TOP"><P>2</P></TD><TD VALIGN="TOP"><P>1</P></TD><TD VALIGN="TOP"><P>*</P></TD></TR><TR><TD VALIGN="TOP"><P>length</P></TD><TD VALIGN="TOP"><P>S_LABEL32</P></TD><TD VALIGN="TOP"><P>offset</P></TD><TD VALIGN="TOP"><P>segment</P></TD><TD VALIGN="TOP"><P>flags</P></TD><TD VALIGN="TOP"><P>name</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>
<P><I>offset</I>    Offset portion of the segmented address of the start of the block</P>
<P><I>segment</I>    Segment portion of the segmented address of the start of the block</P>
<P><I>flags</I>    Label flags.  This uses the same flag definition as in the S_LPROC16 symbol record.<BR>fpo        :1    true if function has frame pointer omitted</P>
<P>    interrupt    :1    true if function is interrupt routine<BR>return        :1    true if function performs far return</P>
<P>    never        :1    true if function never returns</P>
<P>    unused        :4</P>
<P><I>name</I>    Length prefixed name of label</P>
<H3><A NAME="sec10"></A>(0x020a) Change Execution Model 16:32 </H3>This record is used to notify the debugger that, starting at the given code offset and until the address specified by the next Change Execution Model record, the execution model is of  the specified type. The native execution model is assumed in the absence of Change Execution Model records</P>
</P>

<TABLE COLS="6" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="59pt" VALIGN="TOP"><COL WIDTH="94pt" VALIGN="TOP"><COL WIDTH="45pt" VALIGN="TOP"><COL WIDTH="54pt" VALIGN="TOP"><COL WIDTH="49pt" VALIGN="TOP"><COL WIDTH="49pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>2</P></TD><TD VALIGN="TOP"><P>2</P></TD><TD VALIGN="TOP"><P>4</P></TD><TD VALIGN="TOP"><P>2</P></TD><TD VALIGN="TOP"><P>2</P></TD><TD VALIGN="TOP"><P>*</P></TD></TR><TR><TD VALIGN="TOP"><P>length</P></TD><TD VALIGN="TOP"><P>S_CEXMODEL32</P></TD><TD VALIGN="TOP"><P>offset</P></TD><TD VALIGN="TOP"><P>segment</P></TD><TD VALIGN="TOP"><P>model</P></TD><TD VALIGN="TOP"><P>variant</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>
<P><I>offset</I>    Offset portion of  start of the block</P>
<P><I>segment</I>    Segment portion of the start of block</P>
<P><I>model</I>     The execution model.</P>
<P>    0x00        Not executable code (e.g., a table)</P>
<P>    0x01        Compiler generated jump table</P>
<P>    0x02        Padding for data</P>
<P>    0x03 - 0x1f    Reserved for specific noncode types.</P>
<P>    0x20        Native model (no processor specified)</P>
<P>    0x21        Microfocus Cobol (unused in 16:32)</P>
<P>    0x22        Code padding for alignment</P>
<P>    0x23        Code</P>
<P>    0x24 - 0x3f    Reserved </P>
<P>    0x40        Pcode (Reserved)</P>
<P><I>variant</I>     Variable data dependent upon the execution model field.   If the variant record contains segment or offset information, then CVPACK and CodeView must be modified to process the segment information.</P>
</P>
The other models do not have variant fields.</P>
</P>
<H3><A NAME="sec11"></A>(0x100c) Virtual Function Table Path 16:32 </H3>This record is used to describe the base class path for the virtual function table descriptor.</P>
</P>

<TABLE COLS="6" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="59pt" VALIGN="TOP"><COL WIDTH="94pt" VALIGN="TOP"><COL WIDTH="45pt" VALIGN="TOP"><COL WIDTH="45pt" VALIGN="TOP"><COL WIDTH="45pt" VALIGN="TOP"><COL WIDTH="54pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>2</P></TD><TD VALIGN="TOP"><P>2</P></TD><TD VALIGN="TOP"><P>4</P></TD><TD VALIGN="TOP"><P>4</P></TD><TD VALIGN="TOP"><P>4</P></TD><TD VALIGN="TOP"><P>2</P></TD></TR><TR><TD VALIGN="TOP"><P>length</P></TD><TD VALIGN="TOP"><P>S_VFTTABLE32</P></TD><TD VALIGN="TOP"><P>@root</P></TD><TD VALIGN="TOP"><P>@path</P></TD><TD VALIGN="TOP"><P>offset</P></TD><TD VALIGN="TOP"><P>segment</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>
<P><I>@root</I>     The type index of the class at the root of the path</P>
<P><I>@path</I>     Type index of the record describing the base class path from the root to the leaf class for the virtual function table.</P>
<P><I>offset</I>    Offset portion of  start of the virtual function table</P>
<P><I>segment</I>    Segment portion of the virtual function table</P>
<H3><A NAME="sec12"></A><I> </I>(0x100d) Register Relative 16:32 </H3>This symbol specifies symbols that are allocated relative to a register. </P>
</P>

<TABLE COLS="6" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="68pt" VALIGN="TOP"><COL WIDTH="75pt" VALIGN="TOP"><COL WIDTH="55pt" VALIGN="TOP"><COL WIDTH="54pt" VALIGN="TOP"><COL WIDTH="54pt" VALIGN="TOP"><COL WIDTH="50pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>2</P></TD><TD VALIGN="TOP"><P>2</P></TD><TD VALIGN="TOP"><P>4</P></TD><TD VALIGN="TOP"><P>4</P></TD><TD VALIGN="TOP"><P>2</P></TD><TD VALIGN="TOP"><P>*</P></TD></TR><TR><TD VALIGN="TOP"><P>length</P></TD><TD VALIGN="TOP"><P>S_REGREL32</P></TD><TD VALIGN="TOP"><P>offset</P></TD><TD VALIGN="TOP"><P>@type</P></TD><TD VALIGN="TOP"><P>register</P></TD><TD VALIGN="TOP"><P>name</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>
<P><I>offset</I>    Signed offset relative to register.</P>
<P><I>@type</I>    Type of the symbol</P>
<P><I>register</I>    Register enumerates on which the symbol is based.  Note that the register field can specify a pair of register such as ES:EBX</P>
<P><I>name</I>    Length-prefixed name of the symbol</P>
<P></P>
<H3><A NAME="sec13"></A>(0x100e) Local Thread Storage 16:32 </H3>These symbols are used for data declared with the _<I>_thread </I> storage attribute that is not exported from a module.  In C/C++, _<I>_thread</I> symbols that are declared static are emitted as Local Thread Storage 16:32 symbols.  Symbols that are emitted as Local Thread Storage 16:32 cannot be moved by CVPACK into the global symbol table for the executable file.</P>
</P>

<TABLE COLS="6" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="59pt" VALIGN="TOP"><COL WIDTH="94pt" VALIGN="TOP"><COL WIDTH="45pt" VALIGN="TOP"><COL WIDTH="45pt" VALIGN="TOP"><COL WIDTH="54pt" VALIGN="TOP"><COL WIDTH="49pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>2</P></TD><TD VALIGN="TOP"><P>2</P></TD><TD VALIGN="TOP"><P>4</P></TD><TD VALIGN="TOP"><P>4</P></TD><TD VALIGN="TOP"><P>2</P></TD><TD VALIGN="TOP"><P>*</P></TD></TR><TR><TD VALIGN="TOP"><P>length</P></TD><TD VALIGN="TOP"><P>S_LTHREAD32</P></TD><TD VALIGN="TOP"><P>@type</P></TD><TD VALIGN="TOP"><P>offset</P></TD><TD VALIGN="TOP"><P>segment</P></TD><TD VALIGN="TOP"><P>name</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>
<P><I>@type</I>    type index</P>
<P><I>offset</I>    offset into thread local storage</P>
<P><I>segment</I>    segment of thread local storage</P>
<P><I>name</I>    length prefixed name</P>
</P>
<H3><A NAME="sec14"></A>(0x100f) Global Thread Storage 16:32 </H3>This symbol record has the same format as the Local Thread Storage 16:32 except that the symbol type is S_GTHREAD32.   For C/C++, <I>__thread </I>symbols that are not specifically declared static are emitted as Global Thread Storage 16:32 symbols and can be compacted by CVPACK into the global symbol table.</P></BODY></HTML>
