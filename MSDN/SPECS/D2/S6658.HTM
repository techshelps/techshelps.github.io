<HTML><HEAD><META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>General</TITLE><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">
</OBJECT></FORM>
<H2>General</H2><H3><A NAME="sec0"></A>Format of Symbol Records</H3>Data in the $$SYMBOLS segment is a stream of variable length records with the general format:</P>
</P>

<TABLE COLS="3" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="86pt" VALIGN="TOP"><COL WIDTH="72pt" VALIGN="TOP"><COL WIDTH="67pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>2</P></TD><TD VALIGN="TOP"><P>2</P></TD><TD VALIGN="TOP"><P>*</P></TD></TR><TR><TD VALIGN="TOP"><P>length</P></TD><TD VALIGN="TOP"><P>index</P></TD><TD VALIGN="TOP"><P>data...</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>
<P><I>length</I>    Length of record, excluding the length field</P>
<P><I>index</I>    Type of symbol</P>
<P><I>data</I>    Data specific to each symbol format<BR></P>
The symbol records are described below.  Numbers above the fields indicate the length in bytes, and * means variable length for that field.</P>
Symbol indices are broken into five ranges.  The first range is for symbols whose format does not change with the compilation model of the program or the target machine.  These include register symbols, user-defined type symbols, and so on.  The second range of symbols are those that contain 16:16 segmented addresses.  The third symbol range is for symbols that contain 16:32 addresses.  Note that for flat model programs, the segment is replaced with the section number for PE executable files.  The fourth symbol range is for symbols which are specific to the MIPS architecture/compiler. The fifth range is for CodeView optimization.</P>
The symbol records are formatted such that most fields fall into natural alignment if the symbol length field is placed on a long word boundary.   For all symbols, the variable length data is at the end of the symbol structure.  Note specifically that fields that contain data in potentially nonaligned numeric fields must either pay the load penalty or first do a byte wise copy of the data to a memory that is in natural alignment.  Refer to Section 4 for details about numeric leaves.</P>
16:16 compilers do not have to emit padding bytes between symbols to maintain natural alignment.  The CVPACK utility places the symbols into the executable files in natural alignment and zero pads the symbol to force alignment.  The length of each symbol is adjusted to account for the pad bytes.  16:32 compilers must align symbols on a long word boundary. </P>
Provisions for enabling future implementation of register tracking and a stack machine to perform computation on symbol addresses are provided in the symbols.  When the symbol processor is examining a symbol, the length field of the symbol is compared with the offset of the byte following the end of the symbol name field.  If these are the same, there is no stack machine code at the end of the symbol.  If the length and offset are different, the byte following the end of the symbol name is examined.  If the byte is zero, there is no stack machine code following the symbol.  If the byte is not zero, then the byte indexes into the list of stack machine implementations and styles of register tracking.  If stack machine code is present, the address field of the symbol becomes the initial value of the stack machine.  Microsoft does not currently emit or process stack machine code or register tracking information.  The opcodes and operation of the stack machine has not been defined.</P>
<H3><A NAME="sec1"></A>Symbol Indices</H3><I>*[Note: All symbol records that included one or more CV_typ_t fields have been renamed by having "_16t" appended to their original names.  For instance, the symbol record for S_BPREL32 that included a 16-bit CV_typ_t (now known as CV_typ16_t) is now S_BPREL32_16t.  The records that were so changed all have indices (record type fields) with the 0x1000 bit set.  Records that did not contain CV_typ_t fields were left unchanged.]</I></P>
<P>0x0001    S_COMPILE    Compile flags symbol</P>
<P>0x0005    S_SSEARCH    Start search</P>
<P>0x0006    S_END    End block, procedure, with, or thunk</P>
<P>0x0007    S_SKIP    Skip - Reserve symbol space</P>
<P>0x0008    S_CVRESERVE    Reserved for CodeView internal use</P>
<P>0x0009    S_OBJNAME    Specify name of object file</P>
<P>0x000a    S_ENDARG    Specify end of arguments in function symbols</P>
<P>0x000b    S_COBOLUDT    Microfocus COBOL user-defined type</P>
<P>0x000c    S_MANYREG    Many register symbol</P>
<P>0x000d    S_RETURN    Function return description</P>
<P>0x000e    S_ENTRYTHIS    Description of <B>this</B> pointer at entry</P>
<P></P>
<P>0x1001    S_REGISTER    Register variable</P>
<P>0x1002    S_CONSTANT    Constant symbol</P>
<P>0x1003    S_UDT    User-defined type</P>
<P>0x1004    S_COBOLUDT    Microfocus COBOL user-defined type</P>
<P>0x1005    S_MANYREG    Many register symbol</P>
<P>0x1006    S_BPREL32    BP relative 16:32</P>
<P>0x1007    S_LDATA32    Local data 16:32</P>
<P>0x1008    S_GDATA32    Global data 16:32</P>
<P>0x1009    S_PUB32    Public symbol 16:32</P>
<P>0x100a    S_LPROC32    Local procedure start 16:32</P>
<P>0x100b    S_GPROC32    Global procedure start 16:32</P>
<P>0x0206    S_THUNK32    Thunk start 16:32</P>
<P>0x0207    S_BLOCK32    Block start 16:32</P>
<P>0x0208    S_WITH32    With start 16:32</P>
<P>0x0209    S_LABEL32    Label 16:32</P>
<P>0x020a    S_CEXMODEL32    Change execution model 16:32</P>
<P>0x100c    S_VFTTABLE32    Virtual function table path descriptor 16:32</P>
<P>0x100d    S_REGREL32    16:32 offset relative to arbitrary register</P>
<P>0x100e    S_LTHREAD32    Local Thread Storage data</P>
<P>0x100f    S_GTHREAD32    Global Thread Storage data</P>
<P>0x1010    S_LPROCMIPS    Local procedure start MIPS</P>
<P>0x1011    S_GPROCMIPS    Global procedure start MIPS</P>
<P></P>
<P>0x0400    S_PROCREF    Reference to a procedure</P>
<P>0x0401    S_DATAREF    Reference to data</P>
<P>0x0402    S_ALIGN    Page align symbols</P>
<P></P></BODY></HTML>
