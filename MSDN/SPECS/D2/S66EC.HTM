<HTML><HEAD><META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SubSection Types (sst...)</TITLE><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">
</OBJECT></FORM>
<H2>SubSection Types (sst...)</H2>All values not defined are reserved for future use.</P>
<P>sstModule        0x120</P>
<P>sstTypes        0x121</P>
<P>sstPublic        0x122</P>
<P>sstPublicSym        0x123</P>
<P>sstSymbols        0x124</P>
<P>sstAlignSym        0x125 </P>
<P>sstSrcLnSeg        0x126</P>
<P>sstSrcModule        0x127 </P>
<P>sstLibraries        0x128</P>
<P>sstGlobalSym        0x129</P>
<P>sstGlobalPub        0x12a</P>
<P>sstGlobalTypes        0x12b</P>
<P>sstMPC        0x12c</P>
<P>sstSegMap        0x12d</P>
<P>sstSegName        0x12e</P>
<P>sstPreComp        0x12f</P>
<P>unused        0x130</P>
<P>sstOffsetMap16        0x131</P>
<P>sstOffsetMap32        0x132</P>
<P>sstFileIndex        0x133</P>
<P>sstStaticSym        0x134</P>
</P>
<H3><A NAME="sec0"></A>(0x0120) sstModule</H3>This describes the basic information about an object module including code segments, module name, and the number of segments for the modules that follow.  Directory entries for sstModules precede all other subsection directory entries.</P>
</P>

<TABLE COLS="6" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="72pt" VALIGN="TOP"><COL WIDTH="54pt" VALIGN="TOP"><COL WIDTH="54pt" VALIGN="TOP"><COL WIDTH="63pt" VALIGN="TOP"><COL WIDTH="49pt" VALIGN="TOP"><COL WIDTH="49pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>2</P></TD><TD VALIGN="TOP"><P>2</P></TD><TD VALIGN="TOP"><P>2</P></TD><TD VALIGN="TOP"><P>2</P></TD><TD VALIGN="TOP"><P>*</P></TD><TD VALIGN="TOP"><P>*</P></TD></TR><TR><TD VALIGN="TOP"><P>ovlNumber</P></TD><TD VALIGN="TOP"><P>iLib</P></TD><TD VALIGN="TOP"><P>cSeg</P></TD><TD VALIGN="TOP"><P>Style</P></TD><TD VALIGN="TOP"><P>SegInfo</P></TD><TD VALIGN="TOP"><P>Name</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>
<P><I>ovlNumber</I>    Overlay number</P>
<P><I>iLib</I>    Index into sstLibraries subsection if this module was linked from a library</P>
<P><I>cSeg</I>    Count of the number of code segments this module contributes to</P>
<P><I>Style</I>    Debugging style for this module.  Currently only "CV" is defined.  A module can have only one debugging style.  If a module contains debugging information in an unrecognized style, the information will be discarded.</P>
<P><I>SegInfo</I>    Detailed information about each segment that code is contributed to.   This is an array of <I>cSeg</I> count segment information descriptor structures.</P>
<P><I>Name</I>    Length-prefixed name of module</P>
<P></P>
<I>SegInfo</I> is a  structure that describes each segment to which a module contributes code.  It is formatted as follows:</P>
</P>

<TABLE COLS="4" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="72pt" VALIGN="TOP"><COL WIDTH="76pt" VALIGN="TOP"><COL WIDTH="58pt" VALIGN="TOP"><COL WIDTH="67pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>2</P></TD><TD VALIGN="TOP"><P>2</P></TD><TD VALIGN="TOP"><P>4</P></TD><TD VALIGN="TOP"><P>4</P></TD></TR><TR><TD VALIGN="TOP"><P>Seg</P></TD><TD VALIGN="TOP"><P>pad</P></TD><TD VALIGN="TOP"><P>offset</P></TD><TD VALIGN="TOP"><P>cbSeg</P></TD></TR></TBODY></TABLE>
<BR></P><P>    </P>
<P><I>Seg</I>    Segment that this structure describes</P>
<P><I>pad</I>    Padding to maintain alignment  This field is reserved for future use and must be emitted as zeroes.</P>
<P><I>offset</I>    Offset in segment where the code starts</P>
<P><I>cbSeg</I>    Count of the number of bytes of code in the segment</P>
<H3><A NAME="sec1"></A>(0x0121) sstTypes</H3>The linker emits one of these subsections for every object file that contains a $$TYPES segment.  CVPACK combines all of these subsections in to an sstGlobalTypes subsection and deletes the sstTypes tables.  The sstTypes table contains the contents of the $$TYPES segment except that addresses within the $$TYPES segment have been fixed by the linker.  See also sstPreComp.</P>
<P></P>
<H3><A NAME="sec2"></A>(0x0122) sstPublic</H3> The linker fills each subsection of this type with an entries for the public symbols of a module.  The CVPACK utility combines all of the sstPublics subsections into an sstGlobalPub subsection.  This table has been replaced with the sstPublicSym but is retained for compatibility with previous linkers.</P>
<P></P>

<TABLE COLS="4" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="77pt" VALIGN="TOP"><COL WIDTH="49pt" VALIGN="TOP"><COL WIDTH="67pt" VALIGN="TOP"><COL WIDTH="67pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>2/4</P></TD><TD VALIGN="TOP"><P>2</P></TD><TD VALIGN="TOP"><P>2</P></TD><TD VALIGN="TOP"><P>*</P></TD></TR><TR><TD VALIGN="TOP"><P>offset</P></TD><TD VALIGN="TOP"><P>seg</P></TD><TD VALIGN="TOP"><P>type</P></TD><TD VALIGN="TOP"><P>name</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>
<P><I>offset</I>    Offset of public within segment.  This will be a 16-bit offset unless the executable is a 32-bit exe.  Note that if any public symbols are 16:32 model, then all publics are emitted as 16:32 addresses.</P>
<P><I>seg</I>    Segment index</P>
<P><I>type</I>    Type index of the symbol.  This will be zero if the module was compiled without CodeView information</P>
<P><I>name</I>    Length-prefixed name of public</P>
<H3><A NAME="sec3"></A>(0x0123) sstPublicSym</H3>This table replaces the sstPublic subsection.  The format of the public symbols contained in this table is that of an S_PUB16 or S_PUB32 symbol, as defined in Sections 2.3 and 2.4.  This allows an executable to contain both 16:16 and 16:32 public symbols for mixed-mode executable files.  As with the symbols sections the public section records must start on a 4 byte boundary.</P>
<H3><A NAME="sec4"></A>(0x0124) sstSymbols</H3> The linker emits one of these subsections for every object file that contains a $$SYMBOLS segment.  The sstSymbols table contains the contents of the $$SYMBOLS segment, except that addresses within the $$SYMBOLS segment have been fixed by the linker. CVPACK moves global symbols from the sstSymbols subsection to the sstGlobalSum subsection during packing.  When the remaining symbols are written executables, the subsection type is changed to sstAlignSym.</P>
<H3><A NAME="sec5"></A>(0x0125) sstAlignSym </H3>CVPACK writes the remaining unpacked symbols for a module back to the executable in a subsection of this type.  All symbols have been padded to fall on a long word boundary and the lexical scope linkage fields have been initialized.</P>
<H3><A NAME="sec6"></A>(0x0126) sstSrcLnSeg </H3>The linker fills in each subsection of this type with information obtained from any LINNUM records in the module.  This table has been replaced with the sstSrcModule but is retained for compatibility with previous linkers.   CVPACK rewrites sstSrcLnSeg tables to sstSrcModule tables.</P>
  </P>

<TABLE COLS="4" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="61pt" VALIGN="TOP"><COL WIDTH="61pt" VALIGN="TOP"><COL WIDTH="61pt" VALIGN="TOP"><COL WIDTH="61pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>*</P></TD><TD VALIGN="TOP"><P>2</P></TD><TD VALIGN="TOP"><P>2</P></TD><TD VALIGN="TOP"><P>*</P></TD></TR><TR><TD VALIGN="TOP"><P>name</P></TD><TD VALIGN="TOP"><P>seg</P></TD><TD VALIGN="TOP"><P>cPair</P></TD><TD VALIGN="TOP"><P>line/offset</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>
<P><I>name</I>    Length-prefixed name of source file</P>
<P><I>seg</I>    Segment</P>
<P><I>cPair</I>    Count of number of line number offset pairs to follow</P>
<P><I>line/offset</I>    Line/offset pairs.  This pair consists of the line number followed by the offset of the start of the code for that line within the segment.  All offsets are relative to the beginning of the segment, not the start of the contribution of the module to the segment.  For example, if the module contributes to segment _TEXT starting at offset 0x0100, and the code offset of the first line number is 0x0010 relative to the module, it will show up in the subsection as 0x0110.  The offsets are 16 bits if the executable is a 16:16 executable.  If any segment in the executable is 16:32 model, then all offsets in the line/offset pairs are 32 bit offsets.</P>
<H3><A NAME="sec7"></A>(0x0127) sstSrcModule</H3>This table describes the source line number to addressing mapping information for a module.  The table permits the description of a module containing multiple source files with each source file contributing code to one or more code segments.  The base addresses of the tables described below are all relative to the beginning of the sstSrcModule table.</P>
<P> </P>

<TABLE COLS="1" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="216pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>Module header</P></TD></TR><TR><TD VALIGN="TOP"><P>Information for source file 1</P></TD></TR><TR><TD VALIGN="TOP"><P>Information for segment 1</P></TD></TR><TR><TD VALIGN="TOP"><P>Information for segment 2</P></TD></TR><TR><TD VALIGN="TOP"><P>.</P></TD></TR><TR><TD VALIGN="TOP"><P>Information for source file 2</P></TD></TR><TR><TD VALIGN="TOP"><P>Information for segment 1</P></TD></TR><TR><TD VALIGN="TOP"><P>Information for segment 2</P></TD></TR><TR><TD VALIGN="TOP"><P>.</P></TD></TR><TR><TD VALIGN="TOP"><P>.</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>
The module header structure describes the source file and code segment organization of the module.</P>
<P></P>

<TABLE COLS="5" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="50pt" VALIGN="TOP"><COL WIDTH="40pt" VALIGN="TOP"><COL WIDTH="67pt" VALIGN="TOP"><COL WIDTH="65pt" VALIGN="TOP"><COL WIDTH="54pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>2</P></TD><TD VALIGN="TOP"><P>2</P></TD><TD VALIGN="TOP"><P>4*cFile</P></TD><TD VALIGN="TOP"><P>8*cSeg</P></TD><TD VALIGN="TOP"><P>2*cSeg</P></TD></TR><TR><TD VALIGN="TOP"><P>cFile</P></TD><TD VALIGN="TOP"><P>cSeg</P></TD><TD VALIGN="TOP"><P>baseSrcFile</P></TD><TD VALIGN="TOP"><P>start/end</P></TD><TD VALIGN="TOP"><P>seg</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>
<P><I>cFile</I>    The number of source files contributing code to segments</P>
<P><I>cSeg</I>    The number of code segments receiving code from this module</P>
<P><I>baseSrcFile</I>    This is an array of base offsets from the beginning of the sstSrcModule table</P>
<P><I>start/end</I>    An array of two 32-bit offsets per segment that receives code from this module.  The first offset is the offset within the segment of the first byte of code from this module.  The second  offset is the ending address of the code from this module.  The order of these pairs corresponds to the ordering of the segments in the <I>seg</I> array.  Zeroes in these entries means that the information is not known and the file and line tables described below need to be examined to determine if an address of interest is contained within the code from this module.</P>
<P><I>seg</I>    An array of segment indices that receive code from this module.  If the number of segments is not even, two pad characters are inserted to maintain natural alignment.</P>
<P></P>
<P></P>
The file table describes the code segments that receive code from each source file.</P>
</P>

<TABLE COLS="6" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="49pt" VALIGN="TOP"><COL WIDTH="36pt" VALIGN="TOP"><COL WIDTH="62pt" VALIGN="TOP"><COL WIDTH="72pt" VALIGN="TOP"><COL WIDTH="54pt" VALIGN="TOP"><COL WIDTH="58pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>2</P></TD><TD VALIGN="TOP"><P>2</P></TD><TD VALIGN="TOP"><P>4*cSeg</P></TD><TD VALIGN="TOP"><P>8*cSeg</P></TD><TD VALIGN="TOP"><P>2</P></TD><TD VALIGN="TOP"><P>*</P></TD></TR><TR><TD VALIGN="TOP"><P>cSeg</P></TD><TD VALIGN="TOP"><P>pad</P></TD><TD VALIGN="TOP"><P>baseSrcLn</P></TD><TD VALIGN="TOP"><P>start/end</P></TD><TD VALIGN="TOP"><P>cbName</P></TD><TD VALIGN="TOP"><P>Name</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>
<P><I>cSeg</I>    Number of segments that receive code from this source file.  If the source file contributes code multiple times to a segment, this is reflected in this count.  </P>
<P><I>pad</I>    Pad field used to maintain alignment.  This field is reserved for future use and must be emitted as zero.</P>
<P><I>baseSrcLn</I>    An array of offsets for the line/address mapping tables for each of the segments that receive code from this source file.</P>
<P><I>start/end</I>    An array of two 32-bit offsets per segment that receives code from this module.  The first offset is the offset within the segment of the first byte of code from this module.  The second  offset is the ending address of the code from this module.  The order of these pairs corresponds to the ordering of the segments in the <I>seg</I> array.  Zeroes in these entries means that the information is not known and the file and line tables described below need to be examined to determine if an address of interest is contained within the code from this module.</P>
<P><I>cbName</I>    Count of the number of bytes in source file name</P>
<P><I>Name</I>    Source file name.  This can be a fully or partially qualified path name.</P>
<P></P>
The line number to address mapping information is contained in a table with the following format.  The preferred ordering for this table is by offset order.  Line number and offsets must be unique.</P>
</P>

<TABLE COLS="4" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="68pt" VALIGN="TOP"><COL WIDTH="49pt" VALIGN="TOP"><COL WIDTH="72pt" VALIGN="TOP"><COL WIDTH="81pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>2</P></TD><TD VALIGN="TOP"><P>2</P></TD><TD VALIGN="TOP"><P>4*cPair</P></TD><TD VALIGN="TOP"><P>2*cPair</P></TD></TR><TR><TD VALIGN="TOP"><P>Seg</P></TD><TD VALIGN="TOP"><P>cPair</P></TD><TD VALIGN="TOP"><P>offset</P></TD><TD VALIGN="TOP"><P>linenumber</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>
<P><I>Seg</I>    Segment index for this table</P>
<P><I>cPair</I>    Count of the number of source line pairs to follow</P>
<P><I>offset</I>    An array of 32-bit offsets for the offset within the code segment of the start of the line contained in the parallel array <I>linenumber</I>.</P>
<P><I>linenumber</I>    This is an array of 16-bit line numbers for the numbers of the lines in the source file that cause code to be emitted to the code segment.  This array is parallel to the <I>offset</I> array.  If <I>cPair</I> is not even, then a zero word is emitted to maintain natural alignment in the sstSrcModule table.</P>
<H3><A NAME="sec8"></A>(0x0128) sstLibraries</H3>There can be at most one sstLibraries SubSection.  The format is an array of length-prefixed names.  These names define all the library files used during linking.  The order of this list defines the library index number (see sstModules subsection).  The first entry should be empty (i.e., zero-length string) since library indices are 1-based.</P>
<H3><A NAME="sec9"></A>(0x0129) sstGlobalSym</H3>This subsection contains globally compacted symbols.  The format of the table is a header specifying the symbol and address hash functions, the length of the symbol information, the length of the symbol hash function data, and the length of address hash function data.  This is followed by the symbol information followed by the symbol hash tables followed by the address hash tables.  When the pack utility writes the sstGlobals subsection,  each symbol is zero-padded such that the following symbol starts on a long boundary and the length field is adjusted by the pad count.  Note that symbol and/or address hash data can be discarded and the globally packed symbols linearly searched.  Hash function index 0 means no hash data.  See Section 7.5 for more information about the hashing functions.</P>
The header has the following format:</P>
<P></P>

<TABLE COLS="5" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="72pt" VALIGN="TOP"><COL WIDTH="54pt" VALIGN="TOP"><COL WIDTH="67pt" VALIGN="TOP"><COL WIDTH="63pt" VALIGN="TOP"><COL WIDTH="76pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>2</P></TD><TD VALIGN="TOP"><P>2</P></TD><TD VALIGN="TOP"><P>4</P></TD><TD VALIGN="TOP"><P>4</P></TD><TD VALIGN="TOP"><P>4</P></TD></TR><TR><TD VALIGN="TOP"><P>symhash</P></TD><TD VALIGN="TOP"><P>addrhash</P></TD><TD VALIGN="TOP"><P>cbSymbol</P></TD><TD VALIGN="TOP"><P>cbSymHash</P></TD><TD VALIGN="TOP"><P>cbAddrHash</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>
<P><I>symhash</I>    Index of the symbol hash function</P>
<P><I>addrhash</I>    Index of the address hash function</P>
<P><I>cbSymbol</I>    Count of the number of bytes in the symbol table</P>
<P><I>cbSymHash</I>    Count of the number of bytes in the symbol hash table</P>
<P><I>cbAddrHash</I>    Count of the number of bytes in the address hashing table</P>
</P>
Starting with the NB09 signature files, the sstGlobalSym table can contain S_ALIGN symbols to maintaing 4k alignment of symbols.  Also, starting with NB09 signature files, the sstGlobal can contain S_PROCREF and S_DATAREF symbols to global procedures and to global data symbols that would not otherwise have been globally packed because of symbol type mismatches.  See Section 2.6 for more inforation about the S_PROCREF and S_DATAREF symbols.</P>
<H3><A NAME="sec10"></A>(0x012a) sstGlobalPub</H3>This subsection contains the globally compacted public symbols from the sstPublics.  The format of the table is a header specifying the symbol and address hash functions, the length of the symbol information, the length of the symbol hash function data, and the length of address hash function data.  This is followed by the symbol information followed by the symbol hash tables followed by the address hash tables.  When the pack utility writes the sstGlobals subsection,  each symbol is zero-padded such that the following symbol starts on a long boundaryand the length field of the symbol is adjusted by the pad count.  Note that symbol and/or address hash data can be discarded and the globally packed symbols be linearly searched in low-memory situations.  Hash function index 0 means no hash data.  See Section 7.5 for more information about the hashing functions.</P>
The header has the following format:</P>
<P></P>

<TABLE COLS="5" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="72pt" VALIGN="TOP"><COL WIDTH="54pt" VALIGN="TOP"><COL WIDTH="67pt" VALIGN="TOP"><COL WIDTH="63pt" VALIGN="TOP"><COL WIDTH="76pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>2</P></TD><TD VALIGN="TOP"><P>2</P></TD><TD VALIGN="TOP"><P>4</P></TD><TD VALIGN="TOP"><P>4</P></TD><TD VALIGN="TOP"><P>4</P></TD></TR><TR><TD VALIGN="TOP"><P>symhash</P></TD><TD VALIGN="TOP"><P>addrhash</P></TD><TD VALIGN="TOP"><P>cbSymbol</P></TD><TD VALIGN="TOP"><P>cbSymHash</P></TD><TD VALIGN="TOP"><P>cbAddrHash</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>
<P><I>symhash</I>    Index of the symbol hash function</P>
<P><I>addrhash</I>    Index of the address hash function</P>
<P><I>cbSymbol</I>    Count of the number of bytes in the symbol table</P>
<P><I>cbSymHash</I>    Count of the number of bytes in the symbol hash table</P>
<P><I>cbAddrHash</I>    Count of the number of bytes in the address hashing table</P>
</P>
Starting with the NB09 signature files, the sstGlobalSym table can contain S_ALIGN symbols to maintaing 4k alignment of symbols.  </P>
<P>They contain S_ALIGN symbol records to maintain 4K alignment of tables.  These Note also that sstGlobalPub table contains S_PROCREF symbols.  </P>
<H3><A NAME="sec11"></A>(0x012b) sstGlobalTypes</H3>This subsection contains the packed type records for the executable file.  The first long word of the subsection contains the number of types in the table.  This count is followed by a count-sized array of long offsets to the corresponding type record.  As the sstGlobalTypes subsection is written, each type record is forced to start on a long word boundary.  However, the length of the type string is NOT adjusted by the pad count. The remainder of the subsection contains the type records.  This table is invalid for NB05 signatures.</P>
Types are 48K aligned as well as naturally aligned, so linear traversal of the type table is non-trivial.  The 48K alignment means that no type record crosses a 48K boundary.</P>
<P></P>

<TABLE COLS="2" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="117pt" VALIGN="TOP"><COL WIDTH="234pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>flags</P></TD><TD VALIGN="TOP"><P>types table flag</P></TD></TR><TR><TD VALIGN="TOP"><P>cType</P></TD><TD VALIGN="TOP"><P>count of the number of types</P></TD></TR><TR><TD VALIGN="TOP"><P>offType[cType]</P></TD><TD VALIGN="TOP"><P>offset of each type   See note below.</P></TD></TR><TR><TD VALIGN="TOP"><P>type string 0</P></TD><TD VALIGN="TOP"><P>type string for type index 0x1000</P></TD></TR><TR><TD VALIGN="TOP"><P>type string 1</P></TD><TD VALIGN="TOP"><P>type string for type index 0x1001</P></TD></TR><TR><TD VALIGN="TOP"><P>.</P></TD><TD VALIGN="TOP"><P></P></TD></TR><TR><TD VALIGN="TOP"><P>type string n</P></TD><TD VALIGN="TOP"><P>type string for type index 0x1000 + n</P></TD></TR></TBODY></TABLE>
<BR></P></P>
Note: for NB07 and NB08 executables, the type string offset is from the beginning of the subsection table.  For NB09 executables, the type string offset is from the first type record of the sstGlobalTypes subsection.  Using the offset from the first type record simplifies demand loading of the sstGlobalTypes table.</P>
</P>
The types table flags entry has the following format:</P>

<TABLE COLS="2" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="80pt" VALIGN="TOP"><COL WIDTH="97pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>3</P></TD><TD VALIGN="TOP"><P>1</P></TD></TR><TR><TD VALIGN="TOP"><P>unused</P></TD><TD VALIGN="TOP"><P>signature</P></TD></TR></TBODY></TABLE>
<BR></P></P>
<P><I>unused</I>    Reserved for future use.  Must be emitted as zeroes</P>
<P><I>signature</I>    Global types table signature.</P>
<H3><A NAME="sec12"></A>(0x012c) sstMPC</H3>This table is emitted by the Pcode MPC program when a segmented executable is processed into a non-segmented executable file.  The table contains the mapping from segment indices to frame numbers.</P>
<P></P>
<P></P>

<TABLE COLS="2" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="81pt" VALIGN="TOP"><COL WIDTH="112pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>2</P></TD><TD VALIGN="TOP"><P>2*cSeg</P></TD></TR><TR><TD VALIGN="TOP"><P>cSeg</P></TD><TD VALIGN="TOP"><P>mpSegFrame</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>
<P><I>cSeg</I>    Count of the number of segments converted</P>
<P><I>mpSegFrame</I>    Segment-to-frame mapping table.  A segmented address seg:off is converted to a frame by </P>
<P>    <I>mpSegFrame</I>[segment-1]*16 + offset</P>
<H3><A NAME="sec13"></A>(0x012d) sstSegMap</H3><P>This table contains the mapping between the logical segment indices used in the symbol table and the physical segments where the program was loaded </P>
<P>There is one <B>sstSegMap</B> per executable or DLL. </P>
<P></P>

<TABLE COLS="3" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="37pt" VALIGN="TOP"><COL WIDTH="117pt" VALIGN="TOP"><COL WIDTH="234pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>2</P></TD><TD VALIGN="TOP"><P>cSeg</P></TD><TD VALIGN="TOP"><P>count of the number of segment descriptors in table</P></TD></TR><TR><TD VALIGN="TOP"><P>2</P></TD><TD VALIGN="TOP"><P>cSegLog</P></TD><TD VALIGN="TOP"><P>count of the number of logical segment descriptors</P></TD></TR><TR><TD VALIGN="TOP"><P>20</P></TD><TD VALIGN="TOP"><P>SegDesc 0</P></TD><TD VALIGN="TOP"><P>First segment descriptor</P></TD></TR><TR><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P>.</P></TD><TD VALIGN="TOP"><P></P></TD></TR><TR><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P>.</P></TD><TD VALIGN="TOP"><P></P></TD></TR><TR><TD VALIGN="TOP"><P>20</P></TD><TD VALIGN="TOP"><P>SegDesc N</P></TD><TD VALIGN="TOP"><P>cSeg'th segment descriptor</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>
<P><I>cSeg</I>    The total number of segment descriptors</P>
<P><I>cSegLog</I>    The total number of logical segments.  All group descriptors follow the logical segment descriptors.  The number of group descriptors is given by <I>cSeg - cSegLog.</I></P>
<P>SegDescN    Array of segment descriptors.  Information about a logical segment can be found by using <I>logical segment number - 1</I> as an index into this array.  The 1 is subtracted because the logical segment number is 1 based.</P>
<P>Each element of the segment descriptor array has the following format:</P>
<P></P>

<TABLE COLS="8" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="31pt" VALIGN="TOP"><COL WIDTH="28pt" VALIGN="TOP"><COL WIDTH="34pt" VALIGN="TOP"><COL WIDTH="36pt" VALIGN="TOP"><COL WIDTH="60pt" VALIGN="TOP"><COL WIDTH="62pt" VALIGN="TOP"><COL WIDTH="45pt" VALIGN="TOP"><COL WIDTH="40pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>2</P></TD><TD VALIGN="TOP"><P>2</P></TD><TD VALIGN="TOP"><P>2</P></TD><TD VALIGN="TOP"><P>2</P></TD><TD VALIGN="TOP"><P>2</P></TD><TD VALIGN="TOP"><P>2</P></TD><TD VALIGN="TOP"><P>4</P></TD><TD VALIGN="TOP"><P>4</P></TD></TR><TR><TD VALIGN="TOP"><P>flags</P></TD><TD VALIGN="TOP"><P>ovl</P></TD><TD VALIGN="TOP"><P>group</P></TD><TD VALIGN="TOP"><P>frame</P></TD><TD VALIGN="TOP"><P>iSegName</P></TD><TD VALIGN="TOP"><P>iClassName</P></TD><TD VALIGN="TOP"><P>offset</P></TD><TD VALIGN="TOP"><P>cbseg</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>
<P><I>flags</I>    descriptor flags bit field.  See below for details.</P>
<P><I>ovl</I>    The logical overlay number.</P>
<P><I>group</I>    The group index into the descriptor array.  The group index must either be 0 or <I>cSegLog &lt;= group &lt; cSeg</I>.</P>
<P><I>frame</I>    This value has different meanings depending upon the values of <I>fAbs</I> and <I>fSel</I> in the <I>flags</I> bit array and <I>ovl</I>:<BR><BR><B><I>fAbs</I></B><B>    </B><B><I>fSel</I></B><B>    </B><B><I>ovl</I></B><B>    Operation                 <BR></B>0        0    0    Frame is added to PSP + 0x10 if not a .com file<BR>0        0    0    Frame is added to PSP if it is a .com file<BR>0        0    != 0    Frame is added to current overlay base<BR>1        0    x    Frame is absolute address<BR>0        1    x    Frame contains a selector</P>
<P><I>iSegName</I>    The byte index of the segment or group name in the <B>sstSegName</B> table.  A value of  0xffff indicates there is no name.</P>
<P><I>iClassName</I>    The byte index of the class name in the <B>sstSegName</B> table.  A value of  0xffff indicates there is no name.</P>
<P><I>offset</I>    Byte offset of the logical segment within the specified physical segment.  If <I>fGroup</I> is set in <I>flags</I>, <I>offset</I> is the offset of the group in the physical segment.  Currently, all groups define physical segments so <I>offset</I> will be zero for groups.</P>
<P><I>cbSeg</I>    Byte count of the logical segment or group.</P>
<P>The descriptor flags bit field <I>flags</I> has the following format:</P>
<P></P>

<TABLE COLS="10" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="22pt" VALIGN="TOP"><COL WIDTH="40pt" VALIGN="TOP"><COL WIDTH="25pt" VALIGN="TOP"><COL WIDTH="34pt" VALIGN="TOP"><COL WIDTH="27pt" VALIGN="TOP"><COL WIDTH="30pt" VALIGN="TOP"><COL WIDTH="36pt" VALIGN="TOP"><COL WIDTH="46pt" VALIGN="TOP"><COL WIDTH="40pt" VALIGN="TOP"><COL WIDTH="35pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>:3</P></TD><TD VALIGN="TOP"><P>:1</P></TD><TD VALIGN="TOP"><P>:2</P></TD><TD VALIGN="TOP"><P>:1</P></TD><TD VALIGN="TOP"><P>:1</P></TD><TD VALIGN="TOP"><P>:4</P></TD><TD VALIGN="TOP"><P>:1</P></TD><TD VALIGN="TOP"><P>:1</P></TD><TD VALIGN="TOP"><P>:1</P></TD><TD VALIGN="TOP"><P>:1</P></TD></TR><TR><TD VALIGN="TOP"><P>res</P></TD><TD VALIGN="TOP"><P>fGroup</P></TD><TD VALIGN="TOP"><P>res</P></TD><TD VALIGN="TOP"><P>fAbs</P></TD><TD VALIGN="TOP"><P>fSel</P></TD><TD VALIGN="TOP"><P>res</P></TD><TD VALIGN="TOP"><P>f32Bit</P></TD><TD VALIGN="TOP"><P>fExecute</P></TD><TD VALIGN="TOP"><P>fWrite</P></TD><TD VALIGN="TOP"><P>fRead</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>
<P><I>res</I>    Reserved. and set to zero.</P>
<P><I>fGroup</I>    If set, the descriptor represents a group.  Since groups are not assigned logical segment numbers, these entries are placed after the logcial segment descriptors in the descriptor array.</P>
<P><I>fAbs</I>    <I>frame</I> represents an absolute address.</P>
<P><I>fSel</I>    <I>frame</I> represents a selector.</P>
<P><I>f32Bit</I>    The descriptor describes a 32-bit linear address.</P>
<P><I>fExecute</I>    The segment is executable.</P>
<P><I>fWrite</I>    The segment is writable.</P>
<P><I>fRead</I>    The segment is readable.</P>
<P></P>
<H3><A NAME="sec14"></A>(0x012e) sstSegName</H3>The <B>sstSegName</B> table contains all of the logical segment and class names.  The table is an array of zero-terminated strings.  Each string is indexed by its beginning from the start of the table.  <B> </B>See sstSegMap above.</P>
<H3><A NAME="sec15"></A>(0x012f) sstPreComp</H3>The linker emits one of these sections for every OMF object that has the $$TYPES table flagged as sstPreComp and for every COFF object that contains a .debug$P section.  During packing, CVPACK processes modules with a types table having the sstPreComp index before modules with types table having the sstTypes index.</P>
<H3><A NAME="sec16"></A>(0x0131) sstOffsetMap16</H3>This table provides a mapping from logical to physical offsets.  This mapping is applied between the logical to physical mapping described by the seg map table.</P>

<TABLE COLS="2" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="63pt" VALIGN="TOP"><COL WIDTH="54pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>4</P></TD><TD VALIGN="TOP"><P>16 * cSeg</P></TD></TR><TR><TD VALIGN="TOP"><P>cSeg</P></TD><TD VALIGN="TOP"><P>map</P></TD></TR></TBODY></TABLE>
<BR></P></P>
<P><I>cSeg</I>    Count of the number of physical segments</P>
<P><I>map</I>    Array of mapping information for each physical segment</P>
<P></P>

<TABLE COLS="5" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="61pt" VALIGN="TOP"><COL WIDTH="89pt" VALIGN="TOP"><COL WIDTH="95pt" VALIGN="TOP"><COL WIDTH="58pt" VALIGN="TOP"><COL WIDTH="26pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>4</P></TD><TD VALIGN="TOP"><P>2 * cRangeLog</P></TD><TD VALIGN="TOP"><P>2 * cRangeOff</P></TD><TD VALIGN="TOP"><P>4</P></TD><TD VALIGN="TOP"><P></P></TD></TR><TR><TD VALIGN="TOP"><P>cRangeLog</P></TD><TD VALIGN="TOP"><P>rgoffLog</P></TD><TD VALIGN="TOP"><P>rgbiasLog</P></TD><TD VALIGN="TOP"><P>crangePhys</P></TD><TD VALIGN="TOP"><P>-&gt;</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>

<TABLE COLS="2" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="75pt" VALIGN="TOP"><COL WIDTH="77pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>2 * crangePhys</P></TD><TD VALIGN="TOP"><P>2 * crangePhys</P></TD></TR><TR><TD VALIGN="TOP"><P>rgoffPhys</P></TD><TD VALIGN="TOP"><P>rgbiasPhys</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>
<P><I>crangeLog</I>    Count of logical offset ranges</P>
<P><I>rgoffLog</I>    Array of logical offsets</P>
<P><I> rgbiasLog</I>     Array of logical -&gt; physical bias</P>
<P><I>crangePhys</I>    Count of physical offset ranges</P>
<P><I>rgoffPhys</I>    Array of physical offsets</P>
<P><I>rgbiasPhys</I>    Array of physical -&gt; logical bias</P>
<P></P>
<B>/* M00 REVIEW richards: keithv:  Please supply more details about table usage */</B></P>
</P>
<H3><A NAME="sec17"></A>(0x0132) sstOffsetMap32</H3></P>
This table provides a mapping from logical to physical offsets.  This mapping is applied between the logical to physical mapping described by the seg map table.</P>

<TABLE COLS="2" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="63pt" VALIGN="TOP"><COL WIDTH="54pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>4</P></TD><TD VALIGN="TOP"><P>18 * cSeg</P></TD></TR><TR><TD VALIGN="TOP"><P>cSeg</P></TD><TD VALIGN="TOP"><P>map</P></TD></TR></TBODY></TABLE>
<BR></P></P>
<P><I>cSeg</I>    Count of the number of physical segments</P>
<P><I>map</I>    Array of mapping information for each physical segment</P>
<P></P>

<TABLE COLS="5" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="61pt" VALIGN="TOP"><COL WIDTH="97pt" VALIGN="TOP"><COL WIDTH="85pt" VALIGN="TOP"><COL WIDTH="62pt" VALIGN="TOP"><COL WIDTH="30pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>4</P></TD><TD VALIGN="TOP"><P>4 * cRangeLog</P></TD><TD VALIGN="TOP"><P>4 * cRangeOff</P></TD><TD VALIGN="TOP"><P>4</P></TD><TD VALIGN="TOP"><P> </P></TD></TR><TR><TD VALIGN="TOP"><P>cRangeLog</P></TD><TD VALIGN="TOP"><P>rgoffLog</P></TD><TD VALIGN="TOP"><P>rgbiasLog</P></TD><TD VALIGN="TOP"><P>crangePhys</P></TD><TD VALIGN="TOP"><P>-&gt;</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>

<TABLE COLS="2" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="75pt" VALIGN="TOP"><COL WIDTH="77pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>2 * crangePhys</P></TD><TD VALIGN="TOP"><P>4 * crangePhys</P></TD></TR><TR><TD VALIGN="TOP"><P>rgoffPhys</P></TD><TD VALIGN="TOP"><P>rgbiasPhys</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>
<P><I>crangeLog</I>    Count of logical offset ranges</P>
<P><I>rgoffLog</I>    Array of logical offsets</P>
<P><I> rgbiasLog</I>     Array of logical -&gt; physical bias</P>
<P><I>crangePhys</I>    Count of physical offset ranges</P>
<P><I>rgoffPhys</I>    Array of physical offsets</P>
<P><I>rgbiasPhys</I>    Array of physical -&gt; logical bias</P>
<B></B></P>
/* M00 REVIEW richards: keithv:  Please supply more details about table usage */</P>
<H3><A NAME="sec18"></A>(0x0133) sstFileIndex</H3>This subsection contains an list of all of the sources files that contribute code to any module (compiland) in the executable.  File names are partially qualified relative to the compilation directory.</P>

<TABLE COLS="6" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="51pt" VALIGN="TOP"><COL WIDTH="49pt" VALIGN="TOP"><COL WIDTH="64pt" VALIGN="TOP"><COL WIDTH="68pt" VALIGN="TOP"><COL WIDTH="64pt" VALIGN="TOP"><COL WIDTH="52pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>2</P></TD><TD VALIGN="TOP"><P>2</P></TD><TD VALIGN="TOP"><P>2 * cMod</P></TD><TD VALIGN="TOP"><P>2 * cModules</P></TD><TD VALIGN="TOP"><P>4 * cRef</P></TD><TD VALIGN="TOP"><P>*</P></TD></TR><TR><TD VALIGN="TOP"><P>cMod</P></TD><TD VALIGN="TOP"><P>cRef</P></TD><TD VALIGN="TOP"><P>ModStart</P></TD><TD VALIGN="TOP"><P>cRefCnt</P></TD><TD VALIGN="TOP"><P>NameRef</P></TD><TD VALIGN="TOP"><P>Names</P></TD></TR></TBODY></TABLE>
<BR></P></P>
<P><I>cMod</I>    Count of the number of modules in the executable</P>
<P><I>cRef</I>    Count of the total number of file name references</P>
<P><I>ModStart</I>    Array of indices into the <I>NameOffset</I> table for each module.  Each index is the start of the file name references for each module.</P>
<P><I>cRefCnt</I>    Number of file name references per module</P>
<P><I>NameRef</I>    Array of offsets into the <I>Names</I> table.  For each module, the offset to first referenced file name is at <I>NameRef[ModStart]</I> and continues for <I>cRefCnt</I> entries.</P>
<P><I>Names</I>    List of zero terminated file names.  Each file name is partially qualified relative to the compilation directory. </P>
<P></P>
<H3><A NAME="sec19"></A>(0x0134) sstStaticSym</H3>This subsection is structured exactly like the sstGlobalPub and sstGlobalSym subsections.  It contains S_PROCREF for all static functions as well as S_DATAREF for static module level data and non-static data that could not be included (due to type conflicts) in the sstGlobalSym subsection.</P></BODY></HTML>
