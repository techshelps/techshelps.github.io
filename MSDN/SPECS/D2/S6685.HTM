<HTML><HEAD><META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Leaf Indices Referenced from Symbols</TITLE><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">
</OBJECT></FORM>
<H2>Leaf Indices Referenced from Symbols</H2><H3><A NAME="sec0"></A>(0x1001) Type Modifier </H3>This record is used to indicate the <B>const,</B>r <B>volatile</B> and <B>unaligned</B> properties for any particular type.  </P>
</P>

<TABLE COLS="3" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="81pt" VALIGN="TOP"><COL WIDTH="72pt" VALIGN="TOP"><COL WIDTH="72pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>2</P></TD><TD VALIGN="TOP"><P>4</P></TD><TD VALIGN="TOP"><P>2</P></TD></TR><TR><TD VALIGN="TOP"><P>LF_MODIFIER</P></TD><TD VALIGN="TOP"><P>@index</P></TD><TD VALIGN="TOP"><P>attribute</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>
<P><I>@index</I>    type index of the modified type</P>
<P><I>attribute</I>    const        :1    <B>const</B> attribute.<BR>volatile        :1    <B>volatile</B> attribute.<BR>unaligned    :1    <B>unaligned</B> attribute.</P>
<P>    reserved    :13</P>
<H3><A NAME="sec1"></A><I> </I>(0x1002) Pointer </H3>This record is the generic pointer type record.  It supports the C++ reference type, pointer to data member, and pointer to method.  It also conveys the <B>const</B> and <B>volatile</B> pointer information</P>
.</P>

<TABLE COLS="4" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="95pt" VALIGN="TOP"><COL WIDTH="76pt" VALIGN="TOP"><COL WIDTH="76pt" VALIGN="TOP"><COL WIDTH="63pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>2</P></TD><TD VALIGN="TOP"><P>4</P></TD><TD VALIGN="TOP"><P>4</P></TD><TD VALIGN="TOP"><P>*</P></TD></TR><TR><TD VALIGN="TOP"><P>LF_POINTER</P></TD><TD VALIGN="TOP"><P>@type</P></TD><TD VALIGN="TOP"><P>attribute</P></TD><TD VALIGN="TOP"><P>variant</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>

<TABLE COLS="3" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="83pt" VALIGN="TOP"><COL WIDTH="53pt" VALIGN="TOP"><COL WIDTH="179pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B>@type</B></P></TD><TD VALIGN="TOP"><P><B></B></P></TD><TD VALIGN="TOP"><P><B>Type index of object pointed to</B></P></TD></TR><TR><TD VALIGN="TOP"><P><B>attribute</B></P></TD><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P>Consists of five bit fields:</P></TD></TR><TR><TD VALIGN="TOP"><P><B>ptrtype</B></P></TD><TD VALIGN="TOP"><P>:5</P></TD><TD VALIGN="TOP"><P><B>Ordinal specifying mode of pointer</B></P></TD></TR><TR><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P>0</P></TD><TD VALIGN="TOP"><P>Near</P></TD></TR><TR><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P>1</P></TD><TD VALIGN="TOP"><P>Far</P></TD></TR><TR><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P>2</P></TD><TD VALIGN="TOP"><P>Huge</P></TD></TR><TR><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P>3</P></TD><TD VALIGN="TOP"><P>Based on segment (OBSOLETE)</P></TD></TR><TR><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P>4</P></TD><TD VALIGN="TOP"><P>Based on value</P></TD></TR><TR><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P>5</P></TD><TD VALIGN="TOP"><P>Based on segment of value (OBSOLETE)</P></TD></TR><TR><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P>6</P></TD><TD VALIGN="TOP"><P>Based on address of symbol (OBSOLETE)</P></TD></TR><TR><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P>7</P></TD><TD VALIGN="TOP"><P>Based on segment of symbol address (OBSOLETE)</P></TD></TR><TR><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P>8</P></TD><TD VALIGN="TOP"><P>Based on type</P></TD></TR><TR><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P>9</P></TD><TD VALIGN="TOP"><P>Based on self (OBSOLETE)</P></TD></TR><TR><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P>10</P></TD><TD VALIGN="TOP"><P>Near 32 bit pointer</P></TD></TR><TR><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P>11</P></TD><TD VALIGN="TOP"><P>Far 32 bit pointer</P></TD></TR><TR><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P>12</P></TD><TD VALIGN="TOP"><P>64 bit pointer</P></TD></TR><TR><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P>13-31</P></TD><TD VALIGN="TOP"><P>Reserved</P></TD></TR><TR><TD VALIGN="TOP"><P><B>ptrmode</B></P></TD><TD VALIGN="TOP"><P>:3</P></TD><TD VALIGN="TOP"><P><B>Ordinal specifying pointer mode</B></P></TD></TR><TR><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P>0</P></TD><TD VALIGN="TOP"><P>Pointer</P></TD></TR><TR><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P>1</P></TD><TD VALIGN="TOP"><P>Reference</P></TD></TR><TR><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P>2</P></TD><TD VALIGN="TOP"><P>Pointer to data member</P></TD></TR><TR><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P>3</P></TD><TD VALIGN="TOP"><P>Pointer to method</P></TD></TR><TR><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P>4-7</P></TD><TD VALIGN="TOP"><P>Reserved</P></TD></TR><TR><TD VALIGN="TOP"><P><B><I>isflat32</I></B><B> </B></P></TD><TD VALIGN="TOP"><P>:1</P></TD><TD VALIGN="TOP"><P>True if 16:32 pointer</P></TD></TR><TR><TD VALIGN="TOP"><P><B><I>volatile</I></B></P></TD><TD VALIGN="TOP"><P><B>:1</B></P></TD><TD VALIGN="TOP"><P>True if pointer is volatile</P></TD></TR><TR><TD VALIGN="TOP"><P><B><I>const</I></B></P></TD><TD VALIGN="TOP"><P><B>:1</B></P></TD><TD VALIGN="TOP"><P>True if pointer is const</P></TD></TR><TR><TD VALIGN="TOP"><P><B><I>unaligned</I></B><B> </B></P></TD><TD VALIGN="TOP"><P><B>:1</B></P></TD><TD VALIGN="TOP"><P>True if pointer is unaligned</P></TD></TR><TR><TD VALIGN="TOP"><P><B><I>restrict</I></B></P></TD><TD VALIGN="TOP"><P><B>:1</B></P></TD><TD VALIGN="TOP"><P>True if pointer is restricted</P></TD></TR><TR><TD VALIGN="TOP"><P><B><I>unused</I></B></P></TD><TD VALIGN="TOP"><P><B>:19</B></P></TD><TD VALIGN="TOP"><P>Unused and reserved</P></TD></TR><TR><TD VALIGN="TOP"><P><B></B></P></TD><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P></P></TD></TR><TR><TD VALIGN="TOP"><P><B>variant</B></P></TD><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P>variant portion of the record, depending upon the pointer type</P></TD></TR><TR><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P><I>based on segment</I> - Segment value</P></TD></TR><TR><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P><I>based on type</I>- Index of type followed by length-prefixed name</P></TD></TR><TR><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P><I>based on self</I> - Nothing</P></TD></TR><TR><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P><I>based on symbol</I> - Copy of symbol record including length field</P></TD></TR><TR><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P><I>pointer to  data member</I> - Union specifying pointer to data member</P></TD></TR><TR><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P><I>pointer to method</I>- Union specifying pointer to method</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>
<P></P>
<P>The union specifying the pointer to data member has the format:</P>
</P>

<TABLE COLS="2" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="76pt" VALIGN="TOP"><COL WIDTH="76pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>4</P></TD><TD VALIGN="TOP"><P>2</P></TD></TR><TR><TD VALIGN="TOP"><P>@class</P></TD><TD VALIGN="TOP"><P>format</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>
<P><I>class</I>    Type index of containing class</P>
<P><I>format</I>    0    16:16 data for class with no virtual functions or virtual bases. </P>
<P>    1    16:16 data for class with virtual functions.  </P>
<P>    2    16:16 data for class with virtual bases.  </P>
<P>    3    16:32 data for classes w/wo virtual functions and no virtual bases</P>
<P>    4    16:32 data for class with virtual bases.  </P>
<P>    5    16:16 near method nonvirtual bases with single address point</P>
<P>    6    16:16 near method nonvirtual bases with multiple address points</P>
<P>    7    16:16 near method with virtual bases</P>
<P>    8    16:16 far method nonvirtual bases with single address point</P>
<P>    9    16:16 far method nonvirtual bases with multiple address points</P>
<P>    10    16:16 far method with virtual bases</P>
<P>    11    16:32 method nonvirtual bases with single address point</P>
<P>    12    16:32 method nonvirtual bases with multiple address points</P>
<P>    13    16:32 method with virtual bases</P>
<P></P>
The pointer to data member and pointer to method have the following formats in memory.  In the following descriptions of the format and value of the NULL pointer, * means any value.</P>
 <SPAN CLASS="Symbol">Ø</SPAN>    (00) 16:16 pointer to data member for a class with no virtual functions or bases. </P>
</P>

<TABLE COLS="1" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="68pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>2</P></TD></TR><TR><TD VALIGN="TOP"><P>mdisp</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>
<P><I>mdisp</I>    Displacement to data.  NULL is 0xffff</P>
<P></P>
 <SPAN CLASS="Symbol">Ø</SPAN>    (01) 16:16 pointer to data member for a class with virtual functions.  </P>
</P>

<TABLE COLS="1" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="68pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>2</P></TD></TR><TR><TD VALIGN="TOP"><P>mdisp</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>
<P><I>mdisp</I>    Displacement to data.  NULL is 0</P>
<P></P>
 <SPAN CLASS="Symbol">Ø</SPAN>    (02) 16:16 pointer to data member for a class with virtual bases. </P>
</P>

<TABLE COLS="3" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="68pt" VALIGN="TOP"><COL WIDTH="76pt" VALIGN="TOP"><COL WIDTH="76pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>2</P></TD><TD VALIGN="TOP"><P>2</P></TD><TD VALIGN="TOP"><P>2</P></TD></TR><TR><TD VALIGN="TOP"><P>mdisp</P></TD><TD VALIGN="TOP"><P>pdisp</P></TD><TD VALIGN="TOP"><P>vdisp</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>
<P><I>mdisp</I>    displacement to data</P>
<P><I>pdisp</I>    <B>this</B> pointer displacement to virtual base table pointer</P>
<P><I>vdisp</I>    displacement within virtual base table.  NULL value is (,,0xffff)</P>
<P></P>
 <SPAN CLASS="Symbol">Ø</SPAN>    (03) 16:32 near pointer to data member for a class with and without virtual functions and no virtual bases</P>
</P>

<TABLE COLS="1" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="68pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>4</P></TD></TR><TR><TD VALIGN="TOP"><P>mdisp</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>
<P><I>mdisp</I>    Displacement to data.  NULL is 0x80000000</P>
</P>
 <SPAN CLASS="Symbol">Ø</SPAN>    (04) 16:32 near pointer to data member for a class with virtual bases.</P>
</P>

<TABLE COLS="3" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="68pt" VALIGN="TOP"><COL WIDTH="76pt" VALIGN="TOP"><COL WIDTH="76pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>4</P></TD><TD VALIGN="TOP"><P>4</P></TD><TD VALIGN="TOP"><P>4</P></TD></TR><TR><TD VALIGN="TOP"><P>mdisp</P></TD><TD VALIGN="TOP"><P>pdisp</P></TD><TD VALIGN="TOP"><P>vdisp</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>
<P><I>mdisp</I>    displacement to data</P>
<P><I>pdisp</I>    <B>this</B> pointer displacement to virtual base table pointer</P>
<P><I>vdisp</I>    displacement within virtual base table.  NULL value is (,,0xffffffff)</P>
<P></P>
  <SPAN CLASS="Symbol">Ø</SPAN>    (05) 16:16 pointer to near member function for a class with no virtual functions or bases and a single address point</P>
</P>

<TABLE COLS="1" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="68pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>2</P></TD></TR><TR><TD VALIGN="TOP"><P>off</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>
<P><I>off</I>    near address of method.  NULL is 0</P>
<P></P>
 <SPAN CLASS="Symbol">Ø</SPAN>    (06) 16:32 pointer to near member function  for a class with no virtual bases with multiple address points</P>
<P></P>

<TABLE COLS="2" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="68pt" VALIGN="TOP"><COL WIDTH="76pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>2</P></TD><TD VALIGN="TOP"><P>2</P></TD></TR><TR><TD VALIGN="TOP"><P>off</P></TD><TD VALIGN="TOP"><P>disp</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>
<P><I>off</I>    offset of function</P>
<P><I>disp</I>    displacement of address point.  NULL is (0,*)</P>
<P></P>
 <SPAN CLASS="Symbol">Ø</SPAN>    (07) 16:16 pointer to near member function for a class with virtual bases</P>
</P>

<TABLE COLS="4" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="68pt" VALIGN="TOP"><COL WIDTH="76pt" VALIGN="TOP"><COL WIDTH="76pt" VALIGN="TOP"><COL WIDTH="76pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>2</P></TD><TD VALIGN="TOP"><P>2</P></TD><TD VALIGN="TOP"><P>2</P></TD><TD VALIGN="TOP"><P>2</P></TD></TR><TR><TD VALIGN="TOP"><P>off</P></TD><TD VALIGN="TOP"><P>mdisp</P></TD><TD VALIGN="TOP"><P>pdisp</P></TD><TD VALIGN="TOP"><P>vdisp</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>
<P><I>off</I>    offset of function</P>
<P><I>mdisp</I>    displacement to data</P>
<P><I>pdisp</I>    <B>this</B> pointer displacement to virtual base table pointer</P>
<P><I>vdisp</I>    displacement within virtual base table.  NULL value is (0,*,*,*)</P>
<P></P>
  <SPAN CLASS="Symbol">Ø</SPAN>    (08) 16:16 pointer to far member function for a class with no virtual bases and a single address point</P>
<P></P>

<TABLE COLS="2" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="68pt" VALIGN="TOP"><COL WIDTH="76pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>2</P></TD><TD VALIGN="TOP"><P>2</P></TD></TR><TR><TD VALIGN="TOP"><P>off</P></TD><TD VALIGN="TOP"><P>seg</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>
<P><I>off</I>    offset of function</P>
<P><I>disp</I>    displacement of address point.  NULL is (0:0)</P>
<P></P>
 <SPAN CLASS="Symbol">Ø</SPAN>    (09) 16:16 pointer to far member function for a class with no virtual bases and multiple address points</P>
<P></P>

<TABLE COLS="3" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="68pt" VALIGN="TOP"><COL WIDTH="76pt" VALIGN="TOP"><COL WIDTH="76pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>2</P></TD><TD VALIGN="TOP"><P>2</P></TD><TD VALIGN="TOP"><P>2</P></TD></TR><TR><TD VALIGN="TOP"><P>off</P></TD><TD VALIGN="TOP"><P>seg</P></TD><TD VALIGN="TOP"><P>disp</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>
<P><I>off</I>    offset of function</P>
<P><I>seg</I>    segment of function                        </P>
<P><I>disp</I>    displacement of address point.  NULL is (0:0,*)</P>
<P></P>
 <SPAN CLASS="Symbol">Ø</SPAN>    (10) 16:16 pointer to far member function for a class  with virtual bases</P>
</P>

<TABLE COLS="5" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="68pt" VALIGN="TOP"><COL WIDTH="76pt" VALIGN="TOP"><COL WIDTH="76pt" VALIGN="TOP"><COL WIDTH="76pt" VALIGN="TOP"><COL WIDTH="76pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>2</P></TD><TD VALIGN="TOP"><P>2</P></TD><TD VALIGN="TOP"><P>2</P></TD><TD VALIGN="TOP"><P>2</P></TD><TD VALIGN="TOP"><P>2</P></TD></TR><TR><TD VALIGN="TOP"><P>off</P></TD><TD VALIGN="TOP"><P>seg</P></TD><TD VALIGN="TOP"><P>mdisp</P></TD><TD VALIGN="TOP"><P>pdisp</P></TD><TD VALIGN="TOP"><P>vdisp</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>
<P><I>off</I>    offset of function</P>
<P><I>seg</I>    segment of function                        </P>
<P><I>mdisp</I>    displacement to data</P>
<P><I>pdisp</I>    <B>this</B> pointer displacement to virtual base table pointer</P>
<P><I>vdisp</I>    displacement within virtual base table.  NULL value is (0,*,*,*)</P>
</P>
 <SPAN CLASS="Symbol">Ø</SPAN>    (11) 16:32 pointer to member function for a class with  no virtual bases and a single address point</P>
</P>

<TABLE COLS="1" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="68pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>4</P></TD></TR><TR><TD VALIGN="TOP"><P>off</P></TD></TR></TBODY></TABLE>
<BR></P><P><I></I></P>
<P>off    offset of function. NULL is 0L</P>
<P></P>
 <SPAN CLASS="Symbol">Ø</SPAN>    (012) 16:32 pointer to member function for a class with no virtual bases and multiple address points</P>
</P>

<TABLE COLS="2" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="68pt" VALIGN="TOP"><COL WIDTH="76pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>4</P></TD><TD VALIGN="TOP"><P>4</P></TD></TR><TR><TD VALIGN="TOP"><P>off</P></TD><TD VALIGN="TOP"><P>disp</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>
<P><I>off</I>    offset of function</P>
<P><I>disp</I>    displacement of address point.  NULL is (0L:0L)</P>
</P>
 <SPAN CLASS="Symbol">Ø</SPAN>    (13) 16:32 pointer to member function for a class with virtual bases</P>
            </P>

<TABLE COLS="4" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="68pt" VALIGN="TOP"><COL WIDTH="76pt" VALIGN="TOP"><COL WIDTH="76pt" VALIGN="TOP"><COL WIDTH="76pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>4</P></TD><TD VALIGN="TOP"><P>4</P></TD><TD VALIGN="TOP"><P>4</P></TD><TD VALIGN="TOP"><P>4</P></TD></TR><TR><TD VALIGN="TOP"><P>off</P></TD><TD VALIGN="TOP"><P>mdisp</P></TD><TD VALIGN="TOP"><P>pdisp</P></TD><TD VALIGN="TOP"><P>vdisp</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>
<P><I>off</I>    offset of function</P>
<P><I>mdisp</I>    displacement to data</P>
<P><I>pdisp</I>    <B>this</B> pointer displacement to virtual base table pointer</P>
<P><I>vdisp</I>    displacement within virtual base table.  NULL value is (0L,*,*,*)</P>
<H3><A NAME="sec2"></A>(0x1003) Simple Array </H3></P>

<TABLE COLS="5" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="68pt" VALIGN="TOP"><COL WIDTH="76pt" VALIGN="TOP"><COL WIDTH="72pt" VALIGN="TOP"><COL WIDTH="72pt" VALIGN="TOP"><COL WIDTH="67pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>2</P></TD><TD VALIGN="TOP"><P>4</P></TD><TD VALIGN="TOP"><P>4</P></TD><TD VALIGN="TOP"><P>*</P></TD><TD VALIGN="TOP"><P>*</P></TD></TR><TR><TD VALIGN="TOP"><P>LF_ARRAY</P></TD><TD VALIGN="TOP"><P>@elemtype</P></TD><TD VALIGN="TOP"><P>@idxtype</P></TD><TD VALIGN="TOP"><P>length</P></TD><TD VALIGN="TOP"><P>name</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>
<P><I>@elemtype</I>    Type index of each array element</P>
<P><I>@idxtype</I>    Type index of indexing variable </P>
<P><I>length</I>    Length of array in bytes</P>
<P><I>name</I>    Length-prefixed name of array</P>
<H3><A NAME="sec3"></A>(0x1004) Classes </H3>The format for and classes is as follows:</P>
</P>

<TABLE COLS="8" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="39pt" VALIGN="TOP"><COL WIDTH="38pt" VALIGN="TOP"><COL WIDTH="49pt" VALIGN="TOP"><COL WIDTH="45pt" VALIGN="TOP"><COL WIDTH="45pt" VALIGN="TOP"><COL WIDTH="54pt" VALIGN="TOP"><COL WIDTH="42pt" VALIGN="TOP"><COL WIDTH="40pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>2</P></TD><TD VALIGN="TOP"><P>2</P></TD><TD VALIGN="TOP"><P>2</P></TD><TD VALIGN="TOP"><P>42</P></TD><TD VALIGN="TOP"><P>4</P></TD><TD VALIGN="TOP"><P>4</P></TD><TD VALIGN="TOP"><P>*</P></TD><TD VALIGN="TOP"><P>*</P></TD></TR><TR><TD VALIGN="TOP"><P>leaf</P></TD><TD VALIGN="TOP"><P>count</P></TD><TD VALIGN="TOP"><P>property</P></TD><TD VALIGN="TOP"><P>@field</P></TD><TD VALIGN="TOP"><P>@dList</P></TD><TD VALIGN="TOP"><P>@vshape</P></TD><TD VALIGN="TOP"><P>length</P></TD><TD VALIGN="TOP"><P>name</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>
<P><I>leaf</I>    LF_CLASS or LF_STRUCTURE</P>
<P><I>count</I>    Number of elements  in the class or structure.  This count includes direct, virtual, and indirect virtual bases, and methods including overloads, data members, static data members, friends, and so on.</P>
<P><I>property</I>    Property bit field</P>
<P><I>    </I>packed        :1    Structure is packed<BR>ctor        :1    Class has constructors and/or destructors<BR>overops        :1    Class has overloaded operators<I><BR></I>isnested        :1    Class is a nested class<BR>cnested        :1    Class contains nested classes<BR>opassign    :1    Class has overloaded assignment<BR>opcast        :1    Class has casting methods</P>
<P>    fwdref        :1    Class/structure is a forward (incomplete) reference</P>
<P>    scoped        :1    This is a scoped definition<BR>reserved:8</P>
<P><I>@field</I>    Type index of the field list for this class.    </P>
<P><I>@dList</I>    Type index of the derivation list.  This is output by the compiler as 0x0000 and is filled in by the CVPACK utility to a  LF_DERIVED record containing the type indices of those classes which immediately inherit the current class.  A zero index indicates that no derivation information is available.  A LF_NULL index indicates that  the class is not inherited by other classes.</P>
<P><I>@vshape</I>    Type index of the virtual function table shape descriptor</P>
<P><I>length</I>    Numeric leaf specifying size in bytes of the structure</P>
<P><I>name</I>    Length-prefixed name this type</P>
<H3><A NAME="sec4"></A>(0x1005) Structures</H3>Structures have the same format as classes.  Structure type records are used exclusively by the C compiler.  The C++ compiler emits both class and structure records depending upon the declaration.</P>
<H3><A NAME="sec5"></A>(0x1006) Unions </H3>The format for a Union is as follows:</P>

<TABLE COLS="6" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="63pt" VALIGN="TOP"><COL WIDTH="58pt" VALIGN="TOP"><COL WIDTH="54pt" VALIGN="TOP"><COL WIDTH="45pt" VALIGN="TOP"><COL WIDTH="45pt" VALIGN="TOP"><COL WIDTH="45pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>2</P></TD><TD VALIGN="TOP"><P>2</P></TD><TD VALIGN="TOP"><P>2</P></TD><TD VALIGN="TOP"><P>42</P></TD><TD VALIGN="TOP"><P>*</P></TD><TD VALIGN="TOP"><P>*</P></TD></TR><TR><TD VALIGN="TOP"><P>LF_UNION</P></TD><TD VALIGN="TOP"><P>count</P></TD><TD VALIGN="TOP"><P>property</P></TD><TD VALIGN="TOP"><P>@field</P></TD><TD VALIGN="TOP"><P>length</P></TD><TD VALIGN="TOP"><P>name</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>
<P><I>count</I>     Number of fields in the union</P>
<P><I>property</I>    Property bit field.</P>
<P><I>@field</I>     Type index of field  list.  </P>
<P><I>length</I>    Numeric leaf specifying size in bytes of the union</P>
<P><I>name</I>    Length-prefixed name of union</P>
<H3><A NAME="sec6"></A>(0x1007) Enumeration </H3>The format for an enum is as follows:</P>

<TABLE COLS="6" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="68pt" VALIGN="TOP"><COL WIDTH="54pt" VALIGN="TOP"><COL WIDTH="49pt" VALIGN="TOP"><COL WIDTH="49pt" VALIGN="TOP"><COL WIDTH="49pt" VALIGN="TOP"><COL WIDTH="54pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>2</P></TD><TD VALIGN="TOP"><P>2</P></TD><TD VALIGN="TOP"><P>2</P></TD><TD VALIGN="TOP"><P>4</P></TD><TD VALIGN="TOP"><P>4</P></TD><TD VALIGN="TOP"><P>*</P></TD></TR><TR><TD VALIGN="TOP"><P>LF_ENUM</P></TD><TD VALIGN="TOP"><P>count</P></TD><TD VALIGN="TOP"><P>property</P></TD><TD VALIGN="TOP"><P>@type</P></TD><TD VALIGN="TOP"><P>@fList</P></TD><TD VALIGN="TOP"><P>name</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>
<P><I>count</I>    Number of enumerates</P>
<P><I>property</I>    Property bit field.</P>
<P><I>@type</I>    Underlying type of enum</P>
<P><I>@field</I>     Type index of field  list.</P>
<P><I>name</I>    Length-prefixed name of enum</P>
<H3><A NAME="sec7"></A>(0x1008) Procedure </H3>
<TABLE COLS="6" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="95pt" VALIGN="TOP"><COL WIDTH="49pt" VALIGN="TOP"><COL WIDTH="40pt" VALIGN="TOP"><COL WIDTH="49pt" VALIGN="TOP"><COL WIDTH="45pt" VALIGN="TOP"><COL WIDTH="49pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>2</P></TD><TD VALIGN="TOP"><P>4</P></TD><TD VALIGN="TOP"><P>1</P></TD><TD VALIGN="TOP"><P>1</P></TD><TD VALIGN="TOP"><P>2</P></TD><TD VALIGN="TOP"><P>4</P></TD></TR><TR><TD VALIGN="TOP"><P>LF_PROCEDURE</P></TD><TD VALIGN="TOP"><P>@rvtype</P></TD><TD VALIGN="TOP"><P>call</P></TD><TD VALIGN="TOP"><P>reserved</P></TD><TD VALIGN="TOP"><P>#parms</P></TD><TD VALIGN="TOP"><P>@arglist</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>
<P></P>
<P><I>@rvtype</I>    Type index of the value returned by the procedure</P>
<P><I>call</I>    Calling convention of the procedure</P>
<P>    0    Near C (arguments pushed right to left, caller pops arguments)</P>
<P>    1    Far C </P>
<P>    2    Near pascal  (arguments pushed left to right, callee pops arguments) </P>
<P>    3    Far pascal</P>
<P>    4    Near fastcall</P>
<P>    5    Far fastcall</P>
<P>    6    Reserved</P>
<P>    7    Near stdcall</P>
<P>    8    Far stdcall</P>
<P>    9    Near syscall</P>
<P>    10    Far syscall</P>
<P>    11    This call</P>
<P>    12    MIPS call</P>
<P>    13 Generic</P>
<P>    14-255    Reserved</P>
<P><I>#parms</I>    Number of parameters</P>
<P><I>@arglist</I>    Type index of argument list type record</P>
<H3><A NAME="sec8"></A>(0x1009) Member Function </H3></P>

<TABLE COLS="7" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="89pt" VALIGN="TOP"><COL WIDTH="56pt" VALIGN="TOP"><COL WIDTH="51pt" VALIGN="TOP"><COL WIDTH="45pt" VALIGN="TOP"><COL WIDTH="39pt" VALIGN="TOP"><COL WIDTH="38pt" VALIGN="TOP"><COL WIDTH="57pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>2</P></TD><TD VALIGN="TOP"><P>4</P></TD><TD VALIGN="TOP"><P>4</P></TD><TD VALIGN="TOP"><P>4</P></TD><TD VALIGN="TOP"><P>1</P></TD><TD VALIGN="TOP"><P>1</P></TD><TD VALIGN="TOP"><P></P></TD></TR><TR><TD VALIGN="TOP"><P>LF_MFUNCTION</P></TD><TD VALIGN="TOP"><P>@rvtype</P></TD><TD VALIGN="TOP"><P>@class</P></TD><TD VALIGN="TOP"><P>@this</P></TD><TD VALIGN="TOP"><P>call</P></TD><TD VALIGN="TOP"><P>res</P></TD><TD VALIGN="TOP"><P>-&gt;</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>

<TABLE COLS="3" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="54pt" VALIGN="TOP"><COL WIDTH="57pt" VALIGN="TOP"><COL WIDTH="55pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>2</P></TD><TD VALIGN="TOP"><P>4</P></TD><TD VALIGN="TOP"><P>4</P></TD></TR><TR><TD VALIGN="TOP"><P>#parms</P></TD><TD VALIGN="TOP"><P>@arglist</P></TD><TD VALIGN="TOP"><P>thisadjust</P></TD></TR></TBODY></TABLE>
<BR></P><P><I>@rvtype</I>    Type index of the value returned by the procedure</P>
<P><I>@class</I>    Type index of the containing class of the function</P>
<P><I>@this</I>    Type index of the <B>this</B> parameter of the member function.  A type of void indicates that the member function is static and has no <B>this</B> parameter.</P>
<P><I>call</I>    Calling convention of the procedure.  See Procedure description.</P>
<P><I>res</I>    Reserved.  Must be emitted as zero.</P>
<P><I>#parms</I>    Number of parameters.   This count does not include the <B>this</B><B><I> </I></B>parameter.</P>
<P><I>arglist</I>    List of parameter specifiers.  This list does not include the <B>this</B> parameter.  </P>
<P><I>thisadjust</I>    Logical <B>this</B><B><I> </I></B>adjustor for the method.  Whenever a class element is referenced via the <B>this</B> pointer, <I>thisadjust</I> will be added to the resultant offset before referencing the element.</P>
<P><I></I></P>
<H3><A NAME="sec9"></A>(0x000a) Virtual Function Table Shape </H3>This record describes the format of a virtual function table.  This record is accessed via the vfunctabptr in the member list of the class which introduces the virtual function.  The vfunctabptr is defined either by the LF_VFUNCTAB  or LF_VFUNCOFF member record.  If LF_VFUNCTAB record is used, then vfunctabptr is at the address point of the class.  If LF_VFUNCOFF record is used, then vfunctabptr is at the specified offset from the class address point.  The underlying type of the pointer is a VTShape type record.  This record describes how to interpret the memory at the location pointed to by the virtual function table pointer.</P>

<TABLE COLS="3" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="77pt" VALIGN="TOP"><COL WIDTH="72pt" VALIGN="TOP"><COL WIDTH="76pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>2</P></TD><TD VALIGN="TOP"><P>2</P></TD><TD VALIGN="TOP"><P>4 bits</P></TD></TR><TR><TD VALIGN="TOP"><P>LF_VTSHAPE</P></TD><TD VALIGN="TOP"><P>count</P></TD><TD VALIGN="TOP"><P>descriptor</P></TD></TR><TR><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P></P>
<P>repeated</P></TD></TR></TBODY></TABLE>
<BR></P><P><I></I></P>
<P>count    Number of descriptors</P>
<P><I>descriptor</I>    A four-bit ordinal describing the entry in the virtual table<BR>0    Near<BR>1    Far<BR>2    Thin<BR>3    Address point displacement to outermost class.  This is at entry[-1]     from table address<BR>4    Far pointer to metaclass descriptor.  This is at entry[-2] from table     address</P>
<P>    5    Near32 </P>
<P>    6    Far32 <BR>7 - 15    Reserved</P>
<H3><A NAME="sec10"></A>(0x100a) Cobol0 </H3>This record has been reserved for the Microfocus COBOL compiler.</P>

<TABLE COLS="3" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="77pt" VALIGN="TOP"><COL WIDTH="54pt" VALIGN="TOP"><COL WIDTH="54pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>2</P></TD><TD VALIGN="TOP"><P>4</P></TD><TD VALIGN="TOP"><P>*</P></TD></TR><TR><TD VALIGN="TOP"><P>LF_COBOL0</P></TD><TD VALIGN="TOP"><P>@parent</P></TD><TD VALIGN="TOP"><P>data</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>
<P><I>@parent</I>    Type index of the parent type</P>
<P><I>data</I>    Data </P>
<H3><A NAME="sec11"></A>(0x000c) Cobol1 </H3>This record has been reserved for the Microfocus COBOL compiler.</P>
</P>

<TABLE COLS="2" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="81pt" VALIGN="TOP"><COL WIDTH="49pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>2</P></TD><TD VALIGN="TOP"><P>*</P></TD></TR><TR><TD VALIGN="TOP"><P>LF_COBOL1</P></TD><TD VALIGN="TOP"><P>data</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>
<P><I>data</I>    Data</P>
<H3><A NAME="sec12"></A>(0x100b) Basic Array </H3>
<TABLE COLS="2" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="108pt" VALIGN="TOP"><COL WIDTH="108pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>2</P></TD><TD VALIGN="TOP"><P>4</P></TD></TR><TR><TD VALIGN="TOP"><P>LF_BARRAY</P></TD><TD VALIGN="TOP"><P>@ type</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>
<P><I>type</I>    Type of each element of the array</P>
<H3><A NAME="sec13"></A>(0x000e) Label </H3>This is used for assembler labels where there is no typing information about the label.</P>

<TABLE COLS="2" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="99pt" VALIGN="TOP"><COL WIDTH="90pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>2</P></TD><TD VALIGN="TOP"><P>2</P></TD></TR><TR><TD VALIGN="TOP"><P>LF_LABEL</P></TD><TD VALIGN="TOP"><P>mode</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>
<P><I>mode</I>    Addressing mode of the label</P>
<P>    0    Near label</P>
<P>    4    Far label</P>
<P></P>
<H3><A NAME="sec14"></A>(0x000f) Null </H3>This is used where the symbol requires a type record but the data content is null.</P>

<TABLE COLS="1" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="99pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>2</P></TD></TR><TR><TD VALIGN="TOP"><P>LF_NULL</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>
<H3><A NAME="sec15"></A>(0x0010) Not Translated </H3>This is used when CVPACK encounters a type record that has no equivalent in the CV4.0 format.</P>

<TABLE COLS="1" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="99pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>2</P></TD></TR><TR><TD VALIGN="TOP"><P>LF_NOTTRANS</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>
<H3><A NAME="sec16"></A>(0x100c) Multiply Dimensioned Array </H3>This record is used to describe a multiply dimensioned array.</P>
<P></P>

<TABLE COLS="4" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="90pt" VALIGN="TOP"><COL WIDTH="76pt" VALIGN="TOP"><COL WIDTH="72pt" VALIGN="TOP"><COL WIDTH="54pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>2</P></TD><TD VALIGN="TOP"><P>4</P></TD><TD VALIGN="TOP"><P>4</P></TD><TD VALIGN="TOP"><P>*</P></TD></TR><TR><TD VALIGN="TOP"><P>LF_DIMARRAY</P></TD><TD VALIGN="TOP"><P>@utype</P></TD><TD VALIGN="TOP"><P>@diminfo</P></TD><TD VALIGN="TOP"><P>name</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>
<P><I>@utype</I>    Underlying type of the array</P>
<P><I>@diminfo</I>    Index of the type record containing the dimension information</P>
<P><I>name</I>    Length-prefixed name of the array</P>
<H3><A NAME="sec17"></A>(0x100d) Path to Virtual Function Table </H3>This record is used to describe the path to the virtual function table.</P>
<P></P>

<TABLE COLS="3" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="90pt" VALIGN="TOP"><COL WIDTH="76pt" VALIGN="TOP"><COL WIDTH="72pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>2</P></TD><TD VALIGN="TOP"><P>4</P></TD><TD VALIGN="TOP"><P>4 * count</P></TD></TR><TR><TD VALIGN="TOP"><P>LF_VFTPATH</P></TD><TD VALIGN="TOP"><P>count</P></TD><TD VALIGN="TOP"><P>bases</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>
<P><I>count</I>    Count of number of bases in the path to the virtual function table</P>
<P><I>bases</I>    Type indices of the base classes in the path</P>
<P></P>
<H3><A NAME="sec18"></A>(0x0013) Reference Precompiled Types </H3>This record specifies that the type records are included from the precompiled types contained in another module in the executable.  A module that contains this type record is considered to be a user of the precompiled types.  When emitting to a COFF object the section name should be .debug$P rather than .debug$T.  All other attributes should be the same.</P>

<TABLE COLS="5" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="90pt" VALIGN="TOP"><COL WIDTH="59pt" VALIGN="TOP"><COL WIDTH="57pt" VALIGN="TOP"><COL WIDTH="70pt" VALIGN="TOP"><COL WIDTH="59pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>2</P></TD><TD VALIGN="TOP"><P>4</P></TD><TD VALIGN="TOP"><P>4</P></TD><TD VALIGN="TOP"><P>4</P></TD><TD VALIGN="TOP"><P>*</P></TD></TR><TR><TD VALIGN="TOP"><P>LF_PRECOMP</P></TD><TD VALIGN="TOP"><P>start</P></TD><TD VALIGN="TOP"><P>count</P></TD><TD VALIGN="TOP"><P>signature</P></TD><TD VALIGN="TOP"><P>name</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>
<P><I>start</I>    Starting type index that is included.  This number must correspond to the current  type index in the current module</P>
<P><I>count</I>    count of the number of type indices included.  After including the precompiled types, the type index must be <I>start</I> + <I>count</I></P>
<P><I>signature</I>    Signature for the precompiled types being referencedbythis module.  The signature will be checked against the signature in the S_OBJNAME symbol record and the LF_ENDPRECOMP type record contained in the $$TYPES table of the creator of the precompiled types.  The signature check is used to detect recompilation of the supplier of the precompiled types without recompilation of all of the users of the precompiled types.  The method for computing the signature is unspecified.  It should be sufficiently robust to detect failures to recompile.</P>
<P><I>name</I>    Name of the module containing the precompiled types.  This name must match the module name in the S_OBJNAME symbol emitted by the compiler for the object file containing the precompiled types.</P>
<H3><A NAME="sec19"></A>(0x0014) End of Precompiled Types </H3>This record specifies that the preceding type records in this module can be referenced by another module in the executable.  A module that contains this type record is considered to be the creator of the precompiled types.  The subsection index for the $$TYPES segment for a precompiled types creator is emitted as sstPreComp instead of sstTypes so that the CVPACK can pack the precompiled types creators before the users.  Precompiled types must be emitted as the first type records within the $$TYPES segment and must be self-contained.  That is, they cannot reference a type record whose index is greater than or equal to the type index of the LF_ENDPRECOMP type record.</P>
</P>

<TABLE COLS="2" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="97pt" VALIGN="TOP"><COL WIDTH="76pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>2</P></TD><TD VALIGN="TOP"><P>4</P></TD></TR><TR><TD VALIGN="TOP"><P>LF_ENDPRECOMP</P></TD><TD VALIGN="TOP"><P>signature</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>
<P><I>signature</I>    Signature of the precompiled types.  The signatures in the S_OBJNAME symbol record, the LF_PRECOMP type record and this signature must match.</P>
<H3><A NAME="sec20"></A>(0x100f) OEM Generic Type </H3>This record is supplied to allow third party compiler vendors to emit debug OMF information in an arbitrary format and still allow CVPACK to be able to process the record.  CVPACK processes this record by performing a left to right depth first recursive pack of the records specified by <I>indices</I> below.  The remainder of the data is copied without alteration.</P>
</P>

<TABLE COLS="6" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="69pt" VALIGN="TOP"><COL WIDTH="51pt" VALIGN="TOP"><COL WIDTH="57pt" VALIGN="TOP"><COL WIDTH="52pt" VALIGN="TOP"><COL WIDTH="55pt" VALIGN="TOP"><COL WIDTH="76pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>2</P></TD><TD VALIGN="TOP"><P>2</P></TD><TD VALIGN="TOP"><P>2</P></TD><TD VALIGN="TOP"><P>4</P></TD><TD VALIGN="TOP"><P>4 * <I>count</I></P></TD><TD VALIGN="TOP"><P>*</P></TD></TR><TR><TD VALIGN="TOP"><P>LF_OEM</P></TD><TD VALIGN="TOP"><P>OEM</P></TD><TD VALIGN="TOP"><P>recOEM</P></TD><TD VALIGN="TOP"><P>count</P></TD><TD VALIGN="TOP"><P>indices</P></TD><TD VALIGN="TOP"><P>data</P></TD></TR></TBODY></TABLE>
<BR></P></P>
<P><I>OEM</I>    Microsoft assigned OEM identifier</P>
<P><I>recOEM</I>    OEM assigned record identifier.  These record identifiers are unique per assigned OEM.</P>
<P><I>count</I>    number of type indices that follow</P>
<P><I>indices</I>    Type indices </P>
<P><I>data</I>    remainder of type record.</P>
</P>
<H3><A NAME="sec21"></A>(0x0016) Reference Typeserver </H3>This type record is used to indicate that all type records must be retrieved from the specified Program Data Base (PDB).</P>

<TABLE COLS="4" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="97pt" VALIGN="TOP"><COL WIDTH="76pt" VALIGN="TOP"><COL WIDTH="76pt" VALIGN="TOP"><COL WIDTH="76pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>2</P></TD><TD VALIGN="TOP"><P>4</P></TD><TD VALIGN="TOP"><P>4</P></TD><TD VALIGN="TOP"><P>*</P></TD></TR><TR><TD VALIGN="TOP"><P>LF_TYPESERVER</P></TD><TD VALIGN="TOP"><P>signature</P></TD><TD VALIGN="TOP"><P>age</P></TD><TD VALIGN="TOP"><P>name</P></TD></TR></TBODY></TABLE>
<BR></P></P>
<P><I>signature</I>    Signature of the PDB.  The method of computing this signature is unspecified.  The signature must be verified against the signature in the PDB by using the TypesQuerySignature API call.</P>
<P><I>age</I>    Age of program data base  The method of computing this age is unspecified.  The age must be verified against the age in the PDB by using the TypesQueryAge API call.</P>
<P><I>name</I>    Length prefixed full path name of program data base</P></BODY></HTML>
