<HTML><HEAD><META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>2.6 Deviation from Berkeley Sockets</TITLE><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">

</OBJECT></FORM>
<H3>2.6 Deviation from Berkeley Sockets</H3>  </P>
There are a few limited instances where the Windows Sockets API has had to divert from strict adherence to the Berkeley conventions, usually because of difficulties of implementation in a Windows environment.</P>
<A NAME="PT2"></A>2.6.1 socket data type and error values</P>
A new data type, SOCKET, has been defined.  The definition of this type was necessary for future enhancements to the Windows Sockets specification, such as being able to use sockets as file handles in Windows NT6.  Definition of this type also facilitates porting of applications to a Win/32 environment, as the type will automatically be promoted from 16 to 32 bits.</P>
In UNIX, all handles, including socket handles, are small, non-negative integers, and some applications make assumptions that this will be true.  Windows Sockets handles have no restrictions, other than that the value INVALID_SOCKET is not a valid socket.  Socket handles may take any value in the range 0 to INVALID_SOCKET-1.</P>
Because the SOCKET type is unsigned, compiling existing source code from, for example, a UNIX environment may lead to compiler warnings about signed/unsigned data type mismatches.</P>
This means, for example, that checking for errors when the socket() and accept() routines return should not be done by comparing the return value with -1, or seeing if the value is negative (both common, and legal, approaches in BSD).  Instead, an application should use the manifest constant INVALID_SOCKET as defined in winsock.h.  For example:</P>
TYPICAL BSD STYLE:</P>
  </P>
<BR></P>
<pre><code>s = socket(...);
if (s == -1)    /* or s &lt; 0 */
    {...}</code></pre>
  </P>
PREFERRED STYLE:</P>
  </P>
<BR></P>
<pre><code>s = socket(...);
if (s == INVALID_SOCKET)
    {...}</code></pre>
  </P>
<A NAME="PT3"></A>2.6.2 select() and FD_*</P>
Because a SOCKET is no longer represented by the UNIX-style "small non-negative integer", the implementation of the select() function was changed in the Windows Sockets API.  Each set of sockets is still represented by the fd_set type, but instead of being stored as a bitmask the set is implemented as an array of SOCKETs.  To avoid potential problems, applications must adhere to the use of the FD_XXX macros to set, initialize, clear, and check the fd_set structures.</P>
<A NAME="PT4"></A>2.6.3 Error codes - errno, h_errno &amp; WSAGetLastError()</P>
Error codes set by the Windows Sockets implementation are NOT made available via the errno variable.  Additionally, for the getXbyY() class of functions, error codes are NOT made available via the h_errno variable.  Instead, error codes are accessed by using the WSAGetLastError() API described in section 4.3.11.  This function is provided in Windows Sockets as a precursor (and eventually an alias) for the Win32 function GetLastError().  This is intended to provide a reliable way for a thread in a multi-threaded process to obtain per-thread error information.</P>
For compatibility with BSD, an application may choose to include a line of the form:</P>
  </P>
<BR></P>
<pre><code>#define errno WSAGetLastError()</code></pre>
  </P>
This will allow networking code which was written to use the global errno to work correctly in a single-threaded environment.  There are, obviously, some drawbacks.  If a source file includes code which inspects errno for both socket and non-socket functions, this mechanism cannot be used.  Furthermore, it is not possible for an application to assign a new value to errno.  (In Windows Sockets the function WSASetLastError() may be used for this purpose.)</P>
TYPICAL BSD STYLE:</P>
  </P>
<BR></P>
<pre><code>r = recv(...);
if (r == -1
    &amp;&amp; errno == EWOULDBLOCK)
    {...}</code></pre>
  </P>
PREFERRED STYLE:</P>
  </P>
<BR></P>
<pre><code>r = recv(...);
if (r == -1       /* (but see below) */
    &amp;&amp; WSAGetLastError() == EWOULDBLOCK)
    {...}
</code></pre>
  </P>
Although error constants consistent with 4.3 Berkeley Sockets are provided for compatibility purposes, applications should, where possible, use the "WSA" error code definitions.  For example, a more accurate version of the above source code fragment is:</P>
  </P>
<BR></P>
<pre><code>r = recv(...);
if (r == -1       /* (but see below) */
    &amp;&amp; WSAGetLastError() == WSAEWOULDBLOCK)
    {...}</code></pre>
  </P>
<A NAME="PT5"></A>2.6.4 Pointers</P>
All pointers used by applications with Windows Sockets should be FAR.  To facilitate this, data type definitions such as LPHOSTENT are provided.</P>
<A NAME="PT6"></A>2.6.5 Renamed functions</P>
In two cases it was necessary to rename functions which are used in Berkeley Sockets in order to avoid clashes with other APIs.</P>
<A NAME="PT7"></A>2.6.5.1 close() &amp; closesocket()</P>
In Berkeley Sockets, sockets are represented by standard file descriptors, and so the close() function can be used to close sockets as well as regular files.  While nothing in the Windows Sockets API prevents an implementation from using regular file handles to identify sockets, nothing requires it either.  Socket descriptors are not presumed to correspond to regular file handles, and file operations such as read(), write(), and close() cannot be assumed to work correctly when applied to sockets.  Sockets must be closed by using the closesocket() routine.  Using the close() routine to close a socket is incorrect and the effects of doing so are undefined by this specification.</P>
<A NAME="PT8"></A>2.6.5.1 ioctl() &amp; ioctlsocket()</P>
Various C language run-time systems use the ioctl() routine for purposes unrelated to Windows Sockets.  For this reason we have defined the routine ioctlsocket() which is used to handle socket functions which in the Berkeley Software Distribution are performed using ioctl() and fcntl().</P>
<A NAME="PT9"></A>2.6.6 Blocking routines &amp; EINPROGRESS</P>
Although blocking operations on sockets are supported under Windows Sockets, their use is strongly discouraged.  Programmers who are constrained to use blocking mode - for example, as part of an existing application which is to be ported - should be aware of the semantics of blocking operations in Windows Sockets.  See section 3.1.1 for more details.</P>
<A NAME="PT10"></A>2.6.7 Maximum number of sockets supported</P>
The maximum number of sockets supported by a particular Windows Sockets supplier is implementation specific.  An application should make no assumptions about the availability of a certain number of sockets.  This topic is addressed further in section 4.3.15, WSAStartup().  However, independent of the number of sockets supported by a particular implementation is the issue of the maximum number of sockets which an application can actually make use of.</P>
The maximum number of sockets which a Windows Sockets application can make use of is determined at compile time by the manifest constant FD_SETSIZE.  This value is used in constructing the fd_set structures used in select() (see section 4.1.18).  The default value in winsock.h is 64.  If an application is designed to be capable of working with more than 64 sockets, the implementor should define the manifest FD_SETSIZE in every source file before including winsock.h.  One way of doing this may be to include the definition within the compiler options in the makefile, for example adding  -DFD_SETSIZE=128 as an option to the compiler command line for Microsoft C.  It must be emphasized that defining FD_SETSIZE as a particular value has no effect on the actual number of sockets provided by a Windows Sockets implementation.</P>
<A NAME="PT11"></A>2.6.8 Include files</P>
For ease of portability of existing Berkeley sockets based source code, a number of standard Berkeley include files are supported.  However, these Berkeley header files merely include the winsock.h include file, and it is therefore sufficient (and recommended) that Windows Sockets application source files should simply include winsock.h.</P>
<A NAME="PT12"></A>2.6.9 Return values on API failure</P>
The manifest constant SOCKET_ERROR is provided for checking API failure.  Although use of this constant is not mandatory, it is recommended.  The following example illustrates the use of the SOCKET_ERROR constant:</P>
TYPICAL BSD STYLE:</P>
  </P>
<BR></P>
<pre><code>r = recv(...);
if (r == -1     /* or r &lt; 0 */
    &amp;&amp; errno == EWOULDBLOCK)
    {...}</code></pre>
  </P>
PREFERRED STYLE:</P>
  </P>
<BR></P>
<pre><code>r = recv(...);
if (r == SOCKET_ERROR
    &amp;&amp; WSAGetLastError() == WSAEWOULDBLOCK)
    {...}</code></pre>
  </P>
<A NAME="PT13"></A>2.6.10 Raw Sockets</P>
The Windows Sockets specification does not mandate that a Windows Sockets DLL support raw sockets, that is, sockets opened with SOCK_RAW.  However, a Windows Sockets DLL is allowed and encouraged to supply raw socket support.  A Windows Sockets-compliant application that wishes to use raw sockets should attempt to open the socket with the socket() call (see section 4.1.23), and if it fails either attempt to use another socket type or indicate the failure to the user.</P>
</P>
</P>
6    NT and Windows/NT are trademarks of Microsoft Corporation.</P>
 </P></BODY></HTML>
