<HTML><HEAD><META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>3.3 Microsoft Windows-specific Extension Functions</TITLE><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">

</OBJECT></FORM>
<H3>3.3 Microsoft Windows-specific Extension Functions</H3>  </P>
The Windows Sockets specification provides a number of extensions to the standard set of Berkeley Sockets routines.  Principally, these extended APIs allow message-based, asynchronous access to network events.  While use of this extended API set is not mandatory for socket-based programming  (with the exception of WSAStartup() and WSACleanup()), it is recommended for conformance with the Microsoft Windows programming paradigm.</P>
<P></P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="140pt" VALIGN="TOP"><COL WIDTH="262pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP">WSAAsyncGetHostByAddr()</P></TD><TD VALIGN="TOP">A set of functions which provide asynchronous</P></TD></TR><TR><TD VALIGN="TOP">WSAAsyncGetHostByName()</P></TD><TD VALIGN="TOP">versions of the standard Berkeley</P></TD></TR><TR><TD VALIGN="TOP">WSAAsyncGetProtoByName()</P></TD><TD VALIGN="TOP">getXbyY() functions.  For example, the</P></TD></TR><TR><TD VALIGN="TOP">WSAAsyncGetProtoByNumber()</P></TD><TD VALIGN="TOP">WSAAsyncGetHostByName() function provides an</P></TD></TR><TR><TD VALIGN="TOP">WSAAsyncGetServByName()</P></TD><TD VALIGN="TOP">asynchronous message based implementation of</P></TD></TR><TR><TD VALIGN="TOP">WSAAsyncGetServByPort()</P></TD><TD VALIGN="TOP">the standard Berkeley gethostbyname() function.</P></TD></TR><TR><TD VALIGN="TOP">WSAAsyncSelect()</P></TD><TD VALIGN="TOP">Perform asynchronous version of select()</P></TD></TR><TR><TD VALIGN="TOP">WSACancelAsyncRequest()</P></TD><TD VALIGN="TOP">Cancel an outstanding instance of a WSAAsyncGetXByY() function.</P></TD></TR><TR><TD VALIGN="TOP">WSACancelBlockingCall()</P></TD><TD VALIGN="TOP">Cancel an outstanding "blocking" API call</P></TD></TR><TR><TD VALIGN="TOP">WSACleanup()</P></TD><TD VALIGN="TOP">Sign off from the underlying Windows Sockets DLL.</P></TD></TR><TR><TD VALIGN="TOP">WSAGetLastError()</P></TD><TD VALIGN="TOP">Obtain details of last Windows Sockets API error</P></TD></TR><TR><TD VALIGN="TOP">WSAIsBlocking()</P></TD><TD VALIGN="TOP">Determine if the underlying Windows Sockets DLL is already blocking an existing call for this thread</P></TD></TR><TR><TD VALIGN="TOP">WSASetBlockingHook()</P></TD><TD VALIGN="TOP">"Hook" the blocking method used by the underlying Windows Sockets implementation</P></TD></TR><TR><TD VALIGN="TOP">WSASetLastError()</P></TD><TD VALIGN="TOP">Set the error to be returned by a subsequent WSAGetLastError()</P></TD></TR><TR><TD VALIGN="TOP">WSAStartup()</P></TD><TD VALIGN="TOP">Initialize the underlying Windows Sockets DLL.</P></TD></TR><TR><TD VALIGN="TOP">WSAUnhookBlockingHook()</P></TD><TD VALIGN="TOP">Restore the original blocking function</P></TD></TR></TBODY></TABLE>
<BR></P><A NAME="PT2"></A>3.3.1 Asynchronous select() Mechanism</P>
The WSAAsyncSelect() API allows an application to register an interest in one or many network events.  This API is provided to supersede the need to do polled network I/O.  Any situation in which select() or non-blocking I/O routines (such as send() and recv()) are either already used or are being considered is usually a candidate for the WSAAsyncSelect() API.  When declaring interest in such condition(s), you supply a window handle to be used for notification.  The corresponding window then receives message-based notification of the conditions in which you declared an interest.</P>
WSAAsyncSelect() allows interest to be declared in the following conditions for a particular socket:</P>
Socket readiness for reading<BR>Socket readiness for writing<BR>Out-of-band data ready for reading<BR>Socket readiness for accepting incoming connection<BR>Completion of non-blocking connect()<BR>Connection closure</P>
<A NAME="PT3"></A>3.3.2 Asynchronous Support Routines</P>
The asynchronous "database" functions allow applications to request information in an asynchronous manner.  Some network implementations and/or configurations perform network based operations to resolve such requests.  The WSAAsyncGetXByY() functions allow application developers to request services which would otherwise block the operation of the whole Windows environment if the standard Berkeley function were used.  The WSACancelAsyncRequest() function allows an application to cancel any outstanding asynchronous request.</P>
<A NAME="PT4"></A>3.3.3 Hooking Blocking Methods</P>
As noted in section 3.1.1 above, Windows Sockets implements blocking operations in such a way that Windows message processing can continue, which may result in the application which issued the call receiving a Windows message.  In certain situations an application may want to influence or change the way in which this pseudo-blocking process is implemented.  The WSASetBlockingHook() provides the ability to substitute a named routine which the Windows Sockets implementation is to use when relinquishing the processor during a "blocking" operation.</P>
<A NAME="PT5"></A>3.3.4 Error Handling</P>
For compatibility with thread-based environments, details of API errors are obtained through the WSAGetLastError() API.  Although the accepted "Berkeley-Style" mechanism for obtaining socket-based network errors is via "errno", this mechanism cannot guarantee the integrity of an error ID in a multi-threaded environment.  WSAGetLastError() allows you to retrieve an error code on a per thread basis.</P>
WSAGetLastError() returns error codes which avoid conflict with standard Microsoft C error codes.  Certain error codes returned by certain Windows Sockets routines fall into the standard range of error codes as defined by Microsoft C.  If you are NOT using an application development environment which defines error codes consistent with Microsoft C, you are advised to use the Windows Sockets error codes prefixed by "WSA" to ensure accurate error code detection.</P>
Note that this specification defines a recommended set of error codes, and lists the possible errors which may be returned as a result of each function.  It may be the case in some implementations that other Windows Sockets error codes will be returned in addition to those listed, and applications should be prepared to handle errors other than those enumerated under each API description.  However a Windows Sockets implementation must not return any value which is not enumerated in the table of legal Windows Sockets errors given in Appendix A.1.</P>
<A NAME="PT6"></A>3.3.5 Accessing a Windows Sockets DLL from an Intermediate DLL</P>
A Windows Sockets DLL may be accessed both directly from an application and through an "intermediate" DLL.  An example of such an intermediate DLL would be a virtual network API layer that supports generalized network functionality for applications and uses Windows Sockets.  Such a DLL could be used by several applications simultaneously, and the DLL must take special precautions with respect to the WSAStartup() and WSACleanup() calls to ensure that these routines are called in the context of each task that will make Windows Sockets calls.  This is because the Windows Sockets DLL will need a call to WSAStartup() for each task in order to set up task-specific data structures, and a call to WSACleanup() to free any resources allocated for the task.  </P>
There are (at least) two ways to accomplish this.  The simplest method is for the intermediate DLL to have calls similar to WSAStartup() and WSACleanup() that applications call as appropriate.  The DLL would then call WSAStartup() or WSACleanup()  from within these routines.  Another mechanism is for the intermediate DLL to build a table of task handles, which are obtained from the GetCurrentTask() Windows API, and at each entry point into the intermediate DLL check whether WSAStartup() has been called for the current task, then call WSAStartup() if necessary.</P>
If a DLL makes a blocking call and does not install its own blocking hook, then the DLL author must be aware that control may be returned to the application either by an application-installed blocking hook or by the default blocking hook.  Thus, it is possible that the application will cancel the DLL's blocking operation via WSACancelBlockingCall().  If this occurs, the DLL's blocking operation will fail with the error code WSAEINTR, and the DLL must return control to the calling task as quickly as possible, as the used has likely pressed a cancel or close button and the task has requested control of the CPU.  It is recommended that DLLs which make blocking calls install their own blocking hooks with WSASetBlockingHook() to prevent unforeseen interactions between the application and the DLL.</P>
Note that this is not necessary for DLLs in Windows NT because of its different process and DLL structure.  Under Windows NT, the intermediate DLL could simply call WSAStartup() in its DLL initialization routine, which is called whenever a new process which uses the DLL starts.</P>
<A NAME="PT7"></A>3.3.6 Internal use of Messages by Windows Sockets Implementations</P>
In order to implement Windows Sockets purely as a DLL, it may be necessary for the DLL to post messages internally for communication and timing.  This is perfectly legal; however, a Windows Sockets DLL must not post messages to a window handle opened by a client application except for those messages requested by the application.  A Windows Sockets DLL that needs to use messages for its own purposes must open a hidden window and post any necessary messages to the handle for that window.</P>
<A NAME="PT8"></A>3.3.7 Private API Interfaces</P>
The winsock.def file in Appendix B.7 lists the ordinals defined for the Windows Sockets APIs.  In addition to the ordinal values listed, all ordinals 999 and below are reserved for future Windows Sockets use.  It may be convenient for a Windows Sockets implementation to export additional, private interfaces from the Windows Sockets DLL.  This is perfectly acceptable, as long as the ordinals for these exports are above 1000.  Note that any application that uses a particular Windows Sockets DLL's private APIs will most likely not work on any other vendor's Windows Sockets implementation.  Only the APIs defined in this document are guaranteed to be present in every Windows Sockets implementation.</P>
If an application uses private interfaces of a particular vendor's Windows Sockets DLL, it is recommended that the DLL not be statically linked with the application but rather dynamically loaded with the Windows routines LoadLibrary() and GetProcAddress().  This allows the application to give an informative error message if it is run on a system with a Windows Sockets DLL that does not support the same set of extended functionality.</P>
 </P></BODY></HTML>
