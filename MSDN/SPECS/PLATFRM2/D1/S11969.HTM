<HTML><HEAD><META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>4.1 Socket Routines</TITLE><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">

</OBJECT></FORM>
<H3>4.1 Socket Routines</H3>This chapter presents the socket library routines in alphabetical order, and describes each routine in detail.  </P>
In each routine it is indicated that the header file winsock.h must be included.  Appendix A.2 lists the Berkeley-compatible header files which are supported.  These are provided for compatibility purposes only, and each of them will simply include winsock.h.  The Windows header file windows.h is also needed, but winsock.h will include it if necessary.</P>
<A NAME="PT2"></A>4.1.1 accept()</P>
  </P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="298pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><B>Description</B></P></TD><TD VALIGN="TOP"><B>Accept a connection on a socket</B></P></TD></TR><TR><TD VALIGN="TOP"> </P></TD><TD VALIGN="TOP">#include &lt;winsock.h&gt;</P></TD></TR><TR><TD VALIGN="TOP"> </P></TD><TD VALIGN="TOP">SOCKET PASCAL FAR accept ( SOCKET s, struct sockaddr FAR * addr, </P></TD></TR><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">int FAR * addrlen );</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>

<TABLE COLS="3" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="226pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">s</P></TD><TD VALIGN="TOP">A descriptor identifying a socket which is listening for connections after a listen().</P></TD></TR><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">addr</P></TD><TD VALIGN="TOP">An optional pointer to a buffer which receives the address of the connecting entity, as known to the communications layer.  The exact format of the addr argument is determined by the address family established when the socket was created.</P></TD></TR><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">addrlen</P></TD><TD VALIGN="TOP">An optional pointer to an integer which contains the length of the address addr.</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="298pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP">Remarks</P></TD><TD VALIGN="TOP">This routine extracts the first connection on the queue of pending connections on s, creates a new socket with the same properties as s and returns a handle to the new socket.  If no pending connections are present on the queue, and the socket is not marked as non-blocking, accept() blocks the caller until a connection is present.  If the socket is marked non-blocking and no pending connections are present on the queue, accept() returns an error as described below.  The accepted socket may not be used to accept more connections.  The original socket remains open.<BR>The argument addr is a result parameter that is filled in with the address of the connecting entity, as known to the communications layer.  The exact format of the addr parameter is determined by the address family in which the communication is occurring.  The addrlen is a value-result parameter; it should initially contain the amount of space pointed to by addr; on return it will contain the actual length (in bytes) of the address returned.  This call is used with connection-based socket types such as SOCK_STREAM.  If addr and/or addrlen are equal to NULL, then no information about the remote address of the accepted socket is returned.</P></TD></TR><TR><TD VALIGN="TOP">Return Value</P></TD><TD VALIGN="TOP">If no error occurs, accept() returns a value of type SOCKET which is a descriptor for the accepted packet.  Otherwise, a value of INVALID_SOCKET is returned, and a specific error code may be retrieved by calling WSAGetLastError().<BR>The integer referred to by addrlen initially contains the amount of space pointed to by addr.  On return it will contain the actual length in bytes of the address returned.</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>

<TABLE COLS="3" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="118pt" VALIGN="TOP"><COL WIDTH="190pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP">Error Codes</P></TD><TD VALIGN="TOP">WSANOTINITIALISED<BR><BR>WSAENETDOWN<BR><BR>WSAEFAULT<BR><BR>WSAEINTR<BR><BR>WSAEINPROGRESS<BR><BR>WSAEINVAL<BR><BR>WSAEMFILE<BR>WSAENOBUFS<BR>WSAENOTSOCK<BR>WSAEOPNOTSUPP<BR>WSAEWOULDBLOCK</P></TD><TD VALIGN="TOP">A successful WSAStartup() must occur before using this API.<BR>The Windows Sockets implementation has detected that the network subsystem has failed.<BR>The addrlen argument is too small (less than the sizeof a struct sockaddr).<BR>The (blocking) call was canceled via WSACancelBlockingCall().<BR>A blocking Windows Sockets call is in progress.<BR>listen() was not invoked prior to accept().<BR>The queue is empty upon entry to accept() and there are no descriptors available.<BR>No buffer space is available.<BR>The descriptor is not a socket.<BR>The referenced socket is not a type that supports connection-oriented service.<BR>The socket is marked as non-blocking and no connections are present to be accepted.</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="298pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP">See Also</P></TD><TD VALIGN="TOP">bind(), connect(), listen(), select(), socket(), WSAAsyncSelect()</P></TD></TR></TBODY></TABLE>
<BR></P><A NAME="PT3"></A>4.1.2 bind()</P>
<P></P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="298pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP">Description</P></TD><TD VALIGN="TOP">Associate a local address with a socket.</P></TD></TR><TR><TD VALIGN="TOP"> </P></TD><TD VALIGN="TOP">#include &lt;winsock.h&gt;</P></TD></TR><TR><TD VALIGN="TOP"> </P></TD><TD VALIGN="TOP">int PASCAL FAR bind ( SOCKET s, const struct sockaddr FAR * name, int namelen );</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>

<TABLE COLS="3" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="226pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">s</P></TD><TD VALIGN="TOP">A descriptor identifying an unbound socket.</P></TD></TR><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">name</P></TD><TD VALIGN="TOP">The address to assign to the socket.  The sockaddr structure is defined as follows:</P></TD></TR></TBODY></TABLE>
<BR></P>  </P>
    struct sockaddr {</P>
        u_short    sa_family;</P>
        char    sa_data[14];</P>
    };</P>

<TABLE COLS="3" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="226pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"></P></TD></TR><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">namelen</P></TD><TD VALIGN="TOP">The length of the name.</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="298pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP">Remarks</P></TD><TD VALIGN="TOP">This routine is used on an unconnected datagram or stream socket, before subsequent connect()s or listen()s.  When a socket is created with socket(), it exists in a name space (address family), but it has no name assigned.  bind() establishes the local association (host address/port number) of the socket by assigning a local name to an unnamed socket.</P></TD></TR></TBODY></TABLE>
<BR></P>In the Internet address family, a name consists of several components.  For SOCK_DGRAM and SOCK_STREAM, the name consists of three parts: a host address, the protocol number (set implicitly to UDP or TCP, respectively), and a port number which identifies the application.  If an application does not care what address is assigned to it, it may specify an Internet address equal to INADDR_ANY, a port equal to 0, or both.  If the Internet address is equal to INADDR_ANY, any appropriate network interface will be used; this simplifies application programming in the presence of multi-homed hosts.  If the port is specified as 0, the Windows Sockets implementation will assign a unique port to the application with a value between 1024 and 5000.  The application may use getsockname() after bind() to learn the address that has been assigned to it, but note that getsockname() will not necessarily fill in the Internet address until the socket is connected, since several Internet addresses may be valid if the host is multi-homed.</P>
If an application desires to bind to an arbitrary port outside of the range 1024 to 5000, such as the case of rsh which must bind to any reserved port, code similar to the following may be used:</P>
  </P>
<BR></P>
<pre><code>    SOCKADDR_IN sin;
    SOCKET s;
    u_short alport = IPPORT_RESERVED;

    sin.sin_family = AF_INET;
    sin.sin_addr.s_addr = 0;
    for (;;) {
        sin.sin_port = htons(alport);
        if (bind(s, (LPSOCKADDR)&amp;sin, sizeof (sin)) == 0) {
            /* it worked */
        }
        if ( GetLastError() != WSAEADDRINUSE) {
            /* fail */
        }
        alport--;
        if (alport == IPPORT_RESERVED/2 ) {
            /* fail--all unassigned reserved ports are */
            /* in use. */
        }
    }</code></pre>
  </P>
<P></P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="298pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP">Return Value</P></TD><TD VALIGN="TOP">If no error occurs, bind() returns 0.  Otherwise, it returns SOCKET_ERROR, and a specific error code may be retrieved by calling WSAGetLastError().</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>

<TABLE COLS="3" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="118pt" VALIGN="TOP"><COL WIDTH="190pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP">Error Codes</P></TD><TD VALIGN="TOP">WSANOTINITIALISED<BR><BR>WSAENETDOWN<BR><BR>WSAEADDRINUSE <BR><BR><BR>WSAEFAULT<BR><BR>WSAEINPROGRESS<BR>WSAEAFNOSUPPORT<BR><BR>WSAEINVAL<BR>WSAENOBUFS<BR><BR>WSAENOTSOCK</P></TD><TD VALIGN="TOP">A successful WSAStartup() must occur before using this API.<BR>The Windows Sockets implementation has detected that the network subsystem has failed.<BR>The specified address is already in use.  (See the SO_REUSEADDR socket option under setsockopt().)<BR>The namelen argument is too small (less than the size of a struct sockaddr).<BR>A blocking Windows Sockets call is in progress.<BR>The specified address family is not supported by this protocol.<BR>The socket is already bound to an address.<BR>Not enough buffers available, too many connections.<BR>The descriptor is not a socket.</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="298pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP">See Also</P></TD><TD VALIGN="TOP">connect(), listen(), getsockname(), setsockopt(), socket(), WSACancelBlockingCall().</P></TD></TR></TBODY></TABLE>
<BR></P><A NAME="PT4"></A>4.1.3 closesocket()</P>
<P></P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="298pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP">Description</P></TD><TD VALIGN="TOP">Close a socket.</P></TD></TR><TR><TD VALIGN="TOP"> </P></TD><TD VALIGN="TOP">#include &lt;winsock.h&gt;</P></TD></TR><TR><TD VALIGN="TOP"> </P></TD><TD VALIGN="TOP">int PASCAL FAR closesocket ( SOCKET s );</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>

<TABLE COLS="3" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="226pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">s</P></TD><TD VALIGN="TOP">A descriptor identifying a socket.</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="298pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP">Remarks</P></TD><TD VALIGN="TOP">This function closes a socket.  More precisely, it releases the socket descriptor s, so that further references to s will fail with the error WSAENOTSOCK.  If this is the last reference to the underlying socket, the associated naming information and queued data are discarded.</P></TD></TR></TBODY></TABLE>
<BR></P>The semantics of closesocket() are affected by the socket options SO_LINGER and SO_DONTLINGER as follows:</P>
  </P>

<TABLE COLS="4" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="97pt" VALIGN="TOP"><COL WIDTH="97pt" VALIGN="TOP"><COL WIDTH="97pt" VALIGN="TOP"><COL WIDTH="97pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><B>Option</B></P></TD><TD VALIGN="TOP">Interval</P></TD><TD VALIGN="TOP">Type of close</P></TD><TD VALIGN="TOP">Wait for close?</P></TD></TR></TBODY></TABLE>
<BR></P></P>

<TABLE COLS="4" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="97pt" VALIGN="TOP"><COL WIDTH="97pt" VALIGN="TOP"><COL WIDTH="97pt" VALIGN="TOP"><COL WIDTH="97pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP">SO_DONTLINGER</P></TD><TD VALIGN="TOP">Don't care</P></TD><TD VALIGN="TOP">Graceful</P></TD><TD VALIGN="TOP">No</P></TD></TR><TR><TD VALIGN="TOP">SO_LINGER</P></TD><TD VALIGN="TOP">Zero</P></TD><TD VALIGN="TOP">Hard</P></TD><TD VALIGN="TOP">No</P></TD></TR><TR><TD VALIGN="TOP">SO_LINGER</P></TD><TD VALIGN="TOP">Non-zero</P></TD><TD VALIGN="TOP">Graceful</P></TD><TD VALIGN="TOP">Yes</P></TD></TR></TBODY></TABLE>
<BR></P>If SO_LINGER is set (i.e. the l_onoff field of the linger structure is non-zero; see sections 2.4,  4.1.7 and 4.1.21) with a zero timeout interval (l_linger is zero), closesocket() is not blocked even if queued data has not yet been sent or acknowledged.  This is called a "hard" or "abortive" close, because the socket's virtual circuit is reset immediately, and any unsent data is lost.  Any recv() call on the remote side of the circuit will fail with WSAECONNRESET.</P>
If SO_LINGER is set with a non-zero timeout interval, the closesocket() call blocks until the remaining data has been sent or until the timeout expires.  This is called a graceful disconnect.  Note that if the socket is set to non-blocking and SO_LINGER is set to a non-zero timeout, the call to closesocket() will fail with an error of WSAEWOULDBLOCK.</P>
If SO_DONTLINGER is set on a stream socket (i.e. the l_onoff field of the linger structure is zero; see sections 2.4, 4.1.7 and 4.1.21), the closesocket() call will return immediately.  However, any data queued for transmission will be sent if possible before the underlying socket is closed.  This is also called a graceful disconnect.  Note that in this case the Windows Sockets implementation may not release the socket and other resources for an arbitrary period, which may affect applications which expect to use all available sockets.</P>
<P></P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="298pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP">Return Value</P></TD><TD VALIGN="TOP">If no error occurs, closesocket() returns 0.  Otherwise, a value of SOCKET_ERROR is returned, and a specific error code may be retrieved by calling WSAGetLastError().</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>

<TABLE COLS="3" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="118pt" VALIGN="TOP"><COL WIDTH="190pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP">Error Codes</P></TD><TD VALIGN="TOP">WSANOTINITIALISED<BR><BR>WSAENETDOWN<BR><BR>WSAENOTSOCK<BR>WSAEINPROGRESS<BR>WSAEINTR<BR><BR>WSAEWOULDBLOCK</P></TD><TD VALIGN="TOP">A successful WSAStartup() must occur before using this API.<BR>The Windows Sockets implementation has detected that the network subsystem has failed.<BR>The descriptor is not a socket.<BR>A blocking Windows Sockets call is in progress.<BR>The (blocking) call was canceled via WSACancelBlockingCall().<BR>The socket is marked as nonblocking and SO_LINGER is set to a nonzero timeout value.</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="298pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP">See Also</P></TD><TD VALIGN="TOP">accept(), socket(), ioctlsocket(), setsockopt(), WSAAsyncSelect().</P></TD></TR></TBODY></TABLE>
<BR></P><A NAME="PT5"></A>4.1.4 connect()</P>
<P></P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="298pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP">Description</P></TD><TD VALIGN="TOP">Establish a connection to a peer.</P></TD></TR><TR><TD VALIGN="TOP"> </P></TD><TD VALIGN="TOP">#include &lt;winsock.h&gt;</P></TD></TR><TR><TD VALIGN="TOP"> </P></TD><TD VALIGN="TOP">int PASCAL FAR connect ( SOCKET s, const struct sockaddr FAR * name, int namelen );</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>

<TABLE COLS="3" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="226pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">s</P></TD><TD VALIGN="TOP">A descriptor identifying an unconnected socket.</P></TD></TR><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">name</P></TD><TD VALIGN="TOP">The name of the peer to which the socket is to be connected.</P></TD></TR><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">namelen</P></TD><TD VALIGN="TOP">The length of the name.</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="298pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP">Remarks</P></TD><TD VALIGN="TOP">This function is used to create a connection to the specified foreign association.  The parameter s specifies an unconnected datagram or stream socket  If the socket is unbound, unique values are assigned to the local association by the system, and the socket is marked as bound.  Note that if the address field of the name structure is all zeroes, connect() will return the error WSAEADDRNOTAVAIL.</P></TD></TR></TBODY></TABLE>
<BR></P>For stream sockets (type SOCK_STREAM), an active connection is initiated to the foreign host using name (an address in the name space of the socket).  When the socket call completes successfully, the socket is ready to send/receive data.  </P>
For a datagram socket (type SOCK_DGRAM), a default destination is set, which will be used on subsequent send() and recv() calls.</P>
<P></P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="298pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP">Return Value</P></TD><TD VALIGN="TOP">If no error occurs, connect() returns 0.  Otherwise, it returns SOCKET_ERROR, and a specific error code may be retrieved by calling WSAGetLastError().<BR>On a blocking socket, the return value indicates success or failure of the connection attempt.<BR>On a non-blocking socket, if the return value is SOCKET_ERROR an application should call WSAGetLastError().  If this indicates an error code of WSAEWOULDBLOCK, then your application can either:</P>
1.    Use select() to determine the completion of the connection request by checking if the socket is writeable,</P>
or</P>
2.    If your application is using the message-based WSAAsyncSelect() to indicate interest in connection events, then your application will receive an FD_CONNECT message when the connect operation is complete.</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>

<TABLE COLS="3" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="118pt" VALIGN="TOP"><COL WIDTH="190pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP">Error Codes</P></TD><TD VALIGN="TOP">WSANOTINITIALISED<BR><BR>WSAENETDOWN<BR><BR>WSAEADDRINUSE<BR>WSAEINTR<BR><BR>WSAEINPROGRESS<BR>WSAEADDRNOTAVAIL<BR><BR>WSAEAFNOSUPPORT<BR><BR>WSAECONNREFUSED<BR>WSAEDESTADDREQ<BR>WSAEFAULT<BR>WSAEINVAL<BR>WSAEISCONN<BR>WSAEMFILE<BR>WSAENETUNREACH<BR><BR>WSAENOBUFS<BR><BR>WSAENOTSOCK<BR>WSAETIMEDOUT<BR><BR>WSAEWOULDBLOCK </P></TD><TD VALIGN="TOP">A successful WSAStartup() must occur before using this API.<BR>The Windows Sockets implementation has detected that the network subsystem has failed.<BR>The specified address is already in use.<BR>The (blocking) call was canceled via WSACancelBlockingCall().<BR>A blocking Windows Sockets call is in progress.<BR>The specified address is not available from the local machine.<BR>Addresses in the specified family cannot be used with this socket.<BR>The attempt to connect was forcefully rejected.<BR>A destination address is required.<BR>The namelen argument is incorrect.<BR>The socket is not already bound to an address.<BR>The socket is already connected.<BR>No more file descriptors are available.<BR>The network can't be reached from this host at this time.<BR>No buffer space is available.  The socket cannot be connected.<BR>The descriptor is not a socket.<BR>Attempt to connect timed out without establishing a connection<BR>The socket is marked as non-blocking and the connection cannot be completed immediately.  It is possible to select() the socket while it is connecting by select()ing it for writing.</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="298pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP">See Also</P></TD><TD VALIGN="TOP">accept(), bind(), getsockname(), socket(), select() and WSAAsyncSelect().</P></TD></TR></TBODY></TABLE>
<BR></P><A NAME="PT6"></A>4.1.5 getpeername()</P>
<P></P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="298pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP">Description</P></TD><TD VALIGN="TOP">Get the address of the peer to which a socket is connected.</P></TD></TR><TR><TD VALIGN="TOP"> </P></TD><TD VALIGN="TOP">#include &lt;winsock.h&gt;</P></TD></TR><TR><TD VALIGN="TOP"> </P></TD><TD VALIGN="TOP">int PASCAL FAR getpeername ( SOCKET s, struct sockaddr FAR * name, int FAR * namelen );</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>

<TABLE COLS="3" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="226pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">s</P></TD><TD VALIGN="TOP">A descriptor identifying a connected socket.</P></TD></TR><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">name</P></TD><TD VALIGN="TOP">The structure which is to receive the name of the peer.</P></TD></TR><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">namelen</P></TD><TD VALIGN="TOP">A pointer to the size of the name structure.</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="298pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP">Remarks</P></TD><TD VALIGN="TOP">getpeername() retrieves the name of the peer connected to the socket s and stores it in the struct sockaddr identified by name.  It is used on a connected datagram or stream socket.<BR>On return, the namelen argument contains the actual size of the name returned in bytes.</P></TD></TR><TR><TD VALIGN="TOP">Return Value</P></TD><TD VALIGN="TOP">If no error occurs, getpeername() returns 0.  Otherwise, a value of SOCKET_ERROR is returned, and a specific error code may be retrieved by calling WSAGetLastError().</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>

<TABLE COLS="3" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="118pt" VALIGN="TOP"><COL WIDTH="190pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP">Error Codes</P></TD><TD VALIGN="TOP">WSANOTINITIALISED<BR><BR>WSAENETDOWN<BR><BR>WSAEFAULT<BR>WSAEINPROGRESS<BR>WSAENOTCONN<BR>WSAENOTSOCK</P></TD><TD VALIGN="TOP">A successful WSAStartup() must occur before using this API.<BR>The Windows Sockets implementation has detected that the network subsystem has failed.<BR>The namelen argument is not large enough.<BR>A blocking Windows Sockets call is in progress.<BR>The socket is not connected.<BR>The descriptor is not a socket.</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="298pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP">See Also</P></TD><TD VALIGN="TOP">bind(), socket(), getsockname().</P></TD></TR></TBODY></TABLE>
<BR></P><A NAME="PT7"></A>4.1.6 getsockname()</P>
<P></P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="298pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP">Description</P></TD><TD VALIGN="TOP">Get the local name for a socket.</P></TD></TR><TR><TD VALIGN="TOP"> </P></TD><TD VALIGN="TOP">#include &lt;winsock.h&gt;</P></TD></TR><TR><TD VALIGN="TOP"> </P></TD><TD VALIGN="TOP">int PASCAL FAR getsockname ( SOCKET s, struct sockaddr FAR * name, int FAR * namelen );</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>

<TABLE COLS="3" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="226pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">s</P></TD><TD VALIGN="TOP">A descriptor identifying a bound socket.</P></TD></TR><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">name</P></TD><TD VALIGN="TOP">Receives the address (name) of the socket.</P></TD></TR><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">namelen</P></TD><TD VALIGN="TOP"> The size of the name buffer.</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="298pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP">Remarks</P></TD><TD VALIGN="TOP">getsockname() retrieves the current name for the specified socket descriptor in name.  It is used on a bound and/or connected socket specified by the s parameter.  The local association is returned.  This call is especially useful when a connect() call has been made without doing a bind() first; this call provides the only means by which you can determine the local association which has been set by the system.<BR>On return, the namelen argument contains the actual size of the name returned in bytes.<BR>If a socket was bound to INADDR_ANY, indicating that any of the host's IP addresses should be used for the socket, getsockname() will not necessarily return information about the host IP address, unless the socket has been connected with connect() or accept().  A Windows Sockets application must not assume that the IP address will be changed from INADDR_ANY unless the socket is connected.  This is because for a multi-homed host the IP address that will be used for the socket is unknown unless the socket is connected.</P></TD></TR><TR><TD VALIGN="TOP">Return Value</P></TD><TD VALIGN="TOP">If no error occurs, getsockname() returns 0.  Otherwise, a value of SOCKET_ERROR is returned, and a specific error code may be retrieved by calling WSAGetLastError().</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>

<TABLE COLS="3" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="118pt" VALIGN="TOP"><COL WIDTH="190pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP">Error Codes</P></TD><TD VALIGN="TOP">WSANOTINITIALISED<BR><BR>WSAENETDOWN<BR><BR>WSAEFAULT<BR>WSAEINPROGRESS<BR><BR>WSAENOTSOCK<BR>WSAEINVAL</P></TD><TD VALIGN="TOP">A successful WSAStartup() must occur before using this API.<BR>The Windows Sockets implementation has detected that the network subsystem has failed.<BR>The namelen argument is not large enough.<BR>A blocking Windows Sockets operation is in progress.<BR>The descriptor is not a socket.<BR>The socket has not been bound to an address with bind().</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="298pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP">See Also</P></TD><TD VALIGN="TOP">bind(), socket(), getpeername().</P></TD></TR></TBODY></TABLE>
<BR></P><A NAME="PT8"></A>4.1.7 getsockopt()</P>
<P></P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="298pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP">Description</P></TD><TD VALIGN="TOP">Retrieve a socket option.</P></TD></TR><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">#include &lt;winsock.h&gt;</P></TD></TR><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">int PASCAL FAR getsockopt ( SOCKET s, int level, int optname, char FAR * optval, int FAR * optlen );</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>

<TABLE COLS="3" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="226pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">s</P></TD><TD VALIGN="TOP">A descriptor identifying a socket.</P></TD></TR><TR><TD VALIGN="TOP">  </P></TD><TD VALIGN="TOP">level</P></TD><TD VALIGN="TOP">The level at which the option is defined; the only supported levels are SOL_SOCKET and IPPROTO_TCP.</P></TD></TR><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">optname</P></TD><TD VALIGN="TOP">The socket option for which the value is to be retrieved.</P></TD></TR><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">optval</P></TD><TD VALIGN="TOP">A pointer to the buffer in which the value for the requested option is to be returned.</P></TD></TR><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">optlen</P></TD><TD VALIGN="TOP">A pointer to the size of the optval buffer.</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="298pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP">Remarks</P></TD><TD VALIGN="TOP">getsockopt() retrieves the current value for a socket option associated with a socket of any type, in any state, and stores the result in optval.  Options may exist at multiple protocol levels, but they are always present at the uppermost "socket'' level.  Options affect socket operations, such as whether an operation blocks or not, the routing of packets, out-of-band data transfer, etc.</P></TD></TR></TBODY></TABLE>
<BR></P>The value associated  with the selected option is returned in the buffer optval.  The integer pointed to by  optlen should originally contain the size of this buffer; on return, it will be set to the size of the value returned.  For SO_LINGER, this will be the size of  a struct linger; for all other options it will be the size of an integer.</P>
If the option was never set with setsockopt(), then getsockopt() returns the default value for the option.</P>
The following options are supported for getsockopt().  The Type identifies the type of data addressed by optval.  The TCP_NODELAY option uses level IPPROTO_TCP; all other options use level SOL_SOCKET.</P>
  </P>

<TABLE COLS="3" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="118pt" VALIGN="TOP"><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="226pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><B>Value</B></P></TD><TD VALIGN="TOP">Type</P></TD><TD VALIGN="TOP">Meaning</P></TD></TR></TBODY></TABLE>
<BR></P></P>

<TABLE COLS="3" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="118pt" VALIGN="TOP"><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="226pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP">SO_ACCEPTCONN</P></TD><TD VALIGN="TOP">BOOL</P></TD><TD VALIGN="TOP">Socket is listen()ing.</P></TD></TR><TR><TD VALIGN="TOP">SO_BROADCAST</P></TD><TD VALIGN="TOP">BOOL</P></TD><TD VALIGN="TOP">Socket is configured for the transmission of broadcast messages.</P></TD></TR><TR><TD VALIGN="TOP">SO_DEBUG</P></TD><TD VALIGN="TOP">BOOL</P></TD><TD VALIGN="TOP">Debugging is enabled.  </P></TD></TR><TR><TD VALIGN="TOP">SO_DONTLINGER</P></TD><TD VALIGN="TOP">BOOL</P></TD><TD VALIGN="TOP">If true, the SO_LINGER option is disabled.</P></TD></TR><TR><TD VALIGN="TOP">SO_DONTROUTE</P></TD><TD VALIGN="TOP">BOOL</P></TD><TD VALIGN="TOP">Routing is disabled.</P></TD></TR><TR><TD VALIGN="TOP">SO_ERROR</P></TD><TD VALIGN="TOP">int</P></TD><TD VALIGN="TOP">Retrieve error status and clear.</P></TD></TR><TR><TD VALIGN="TOP">SO_KEEPALIVE</P></TD><TD VALIGN="TOP">BOOL</P></TD><TD VALIGN="TOP">Keepalives are being sent.</P></TD></TR><TR><TD VALIGN="TOP">SO_LINGER</P></TD><TD VALIGN="TOP">struct linger FAR *</P></TD><TD VALIGN="TOP">Returns the current linger options.</P></TD></TR><TR><TD VALIGN="TOP">SO_OOBINLINE</P></TD><TD VALIGN="TOP">BOOL</P></TD><TD VALIGN="TOP">Out-of-band data is being received in the normal data stream.  </P></TD></TR><TR><TD VALIGN="TOP">SO_RCVBUF</P></TD><TD VALIGN="TOP">int</P></TD><TD VALIGN="TOP">Buffer size for receives</P></TD></TR><TR><TD VALIGN="TOP">SO_REUSEADDR</P></TD><TD VALIGN="TOP">BOOL</P></TD><TD VALIGN="TOP">The socket may be bound to an address which is already in use.</P></TD></TR><TR><TD VALIGN="TOP">SO_SNDBUF</P></TD><TD VALIGN="TOP">int</P></TD><TD VALIGN="TOP">Buffer size for sends</P></TD></TR><TR><TD VALIGN="TOP">SO_TYPE</P></TD><TD VALIGN="TOP">int</P></TD><TD VALIGN="TOP">The type of the socket (e.g. SOCK_STREAM).</P></TD></TR><TR><TD VALIGN="TOP">TCP_NODELAY</P></TD><TD VALIGN="TOP">BOOL</P></TD><TD VALIGN="TOP">Disables the Nagle algorithm for send coalescing.</P></TD></TR></TBODY></TABLE>
<BR></P>BSD options not supported for getsockopt() are:</P>
  </P>

<TABLE COLS="3" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="118pt" VALIGN="TOP"><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="226pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><B>Value</B></P></TD><TD VALIGN="TOP">Type</P></TD><TD VALIGN="TOP">Meaning</P></TD></TR></TBODY></TABLE>
<BR></P></P>

<TABLE COLS="3" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="118pt" VALIGN="TOP"><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="226pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP">SO_RCVLOWAT</P></TD><TD VALIGN="TOP">int</P></TD><TD VALIGN="TOP">Receive low water mark</P></TD></TR><TR><TD VALIGN="TOP">SO_RCVTIMEO</P></TD><TD VALIGN="TOP">int</P></TD><TD VALIGN="TOP">Receive timeout</P></TD></TR><TR><TD VALIGN="TOP">SO_SNDLOWAT</P></TD><TD VALIGN="TOP">int</P></TD><TD VALIGN="TOP">Send low water mark</P></TD></TR><TR><TD VALIGN="TOP">SO_SNDTIMEO</P></TD><TD VALIGN="TOP">int</P></TD><TD VALIGN="TOP">Send timeout</P></TD></TR><TR><TD VALIGN="TOP">IP_OPTIONS</P></TD><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">Get options in IP header.</P></TD></TR><TR><TD VALIGN="TOP">TCP_MAXSEG</P></TD><TD VALIGN="TOP">int</P></TD><TD VALIGN="TOP">Get TCP maximum segment size.</P></TD></TR></TBODY></TABLE>
<BR></P>Calling getsockopt() with an unsupported option will result in an error code of WSAENOPROTOOPT being returned from WSAGetLastError().</P>
<P></P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="298pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP">Return Value</P></TD><TD VALIGN="TOP">If no error occurs, getsockopt() returns 0.  Otherwise, a value of SOCKET_ERROR is returned, and a specific error code may be retrieved by calling WSAGetLastError().</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>

<TABLE COLS="3" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="118pt" VALIGN="TOP"><COL WIDTH="190pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP">Error Codes</P></TD><TD VALIGN="TOP">WSANOTINITIALISED<BR><BR>WSAENETDOWN<BR><BR>WSAEFAULT<BR>WSAEINPROGRESS<BR><BR>WSAENOPROTOOPT<BR><BR><BR><BR><BR><BR><BR>WSAENOTSOCK</P></TD><TD VALIGN="TOP">A successful WSAStartup() must occur before using this API.<BR>The Windows Sockets implementation has detected that the network subsystem has failed.<BR>The optlen argument was invalid.<BR>A blocking Windows Sockets operation is in progress.<BR>The option is unknown or unsupported.  In particular, SO_BROADCAST is not supported on sockets of type SOCK_STREAM, while SO_ACCEPTCONN, SO_DONTLINGER, SO_KEEPALIVE, SO_LINGER and SO_OOBINLINE are not supported on sockets of type SOCK_DGRAM.<BR>The descriptor is not a socket.</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="298pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP">See Also</P></TD><TD VALIGN="TOP">setsockopt(), WSAAsyncSelect(), socket().</P></TD></TR></TBODY></TABLE>
<BR></P><A NAME="PT9"></A>4.1.8 htonl()</P>
<P></P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="298pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP">Description</P></TD><TD VALIGN="TOP">Convert a u_long from host to network byte order.</P></TD></TR><TR><TD VALIGN="TOP"> </P></TD><TD VALIGN="TOP">#include &lt;winsock.h&gt;</P></TD></TR><TR><TD VALIGN="TOP"> </P></TD><TD VALIGN="TOP">u_long PASCAL FAR htonl ( u_long hostlong );</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>

<TABLE COLS="3" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="226pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">hostlong</P></TD><TD VALIGN="TOP">A 32-bit number in host byte order.</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="298pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP">Remarks</P></TD><TD VALIGN="TOP">This routine takes a 32-bit number in host byte order and returns a 32-bit number in network byte order.</P></TD></TR><TR><TD VALIGN="TOP">Return Value</P></TD><TD VALIGN="TOP">htonl() returns the value in network byte order.</P></TD></TR><TR><TD VALIGN="TOP">See Also</P></TD><TD VALIGN="TOP">htons(), ntohl(), ntohs().</P></TD></TR></TBODY></TABLE>
<BR></P><A NAME="PT10"></A>4.1.9 htons()</P>
<P></P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="298pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP">Description</P></TD><TD VALIGN="TOP">Convert a u_short from host to network byte order.</P></TD></TR><TR><TD VALIGN="TOP">   </P></TD><TD VALIGN="TOP">#include &lt;winsock.h&gt;</P></TD></TR><TR><TD VALIGN="TOP"> </P></TD><TD VALIGN="TOP">u_short PASCAL FAR htons ( u_short hostshort );</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>

<TABLE COLS="3" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="226pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">hostshort</P></TD><TD VALIGN="TOP">A 16-bit number in host byte order.</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="298pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP">Remarks</P></TD><TD VALIGN="TOP">This routine takes a 16-bit number in host byte order and returns a 16-bit number in network byte order.</P></TD></TR><TR><TD VALIGN="TOP">Return Value</P></TD><TD VALIGN="TOP">htons() returns the value in network byte order.</P></TD></TR><TR><TD VALIGN="TOP">See Also</P></TD><TD VALIGN="TOP">htonl(), ntohl(), ntohs().</P></TD></TR></TBODY></TABLE>
<BR></P><A NAME="PT11"></A>4.1.10 inet_addr()</P>
<P></P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="298pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP">Description</P></TD><TD VALIGN="TOP">Convert a string containing a dotted address into an in_addr.</P></TD></TR><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">#include &lt;winsock.h&gt;</P></TD></TR><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">unsigned long PASCAL FAR inet_addr ( const char FAR * cp );</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>

<TABLE COLS="3" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="226pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">cp</P></TD><TD VALIGN="TOP">A character string representing a number expressed in the Internet standard ".'' notation.</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="298pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP">Remarks</P></TD><TD VALIGN="TOP">This function interprets the character string specified by the cp parameter.  This string represents a numeric Internet address expressed in the Internet standard ".'' notation.  The value returned is a number suitable for use as an Internet address.  All Internet addresses are returned in network order (bytes ordered from left to right).</P></TD></TR></TBODY></TABLE>
<BR></P><A NAME="PT12"></A>Internet Addresses</P>
Values specified using the ".'' notation take one of the following forms:</P>
a.b.c.d    a.b.c    a.b    a</P>
When four parts are specified, each is interpreted as a byte of data and assigned, from left to right, to the four bytes of an Internet address.  Note that when an Internet address is viewed as a 32-bit integer quantity on the Intel architecture, the bytes referred to above appear as "d.c.b.a''.  That is, the bytes on an Intel processor are ordered from right to left.</P>
  </P>
<B>Note</B>   The following notations are only used by Berkeley, and nowhere else on the Internet.  In the interests of compatibility with their software, they are supported as specified.</P>
  </P>
When a three part address is specified, the last part is interpreted as a 16-bit quantity and placed in the right most two bytes of the network address.  This makes the three part address format convenient for specifying Class B network addresses as "128.net.host''.</P>
When a two part address is specified, the last part is interpreted as a 24-bit quantity and placed in the right most three bytes of the network address.  This makes the two part address format convenient for specifying Class A network addresses as "net.host''.</P>
When only one part is given, the value is stored directly in the network address without any byte rearrangement.</P>
<P></P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="298pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP">Return Value</P></TD><TD VALIGN="TOP">If no error occurs, inet_addr() returns an unsigned long containing a suitable binary representation of the Internet address given.  If the passed-in string does not contain a legitimate Internet address, for example if a portion of an "a.b.c.d" address exceeds 255, inet_addr() returns the value INADDR_NONE.</P></TD></TR><TR><TD VALIGN="TOP">See Also</P></TD><TD VALIGN="TOP">inet_ntoa()</P></TD></TR></TBODY></TABLE>
<BR></P><A NAME="PT13"></A>4.1.11 inet_ntoa()</P>
<P></P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="298pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP">Description</P></TD><TD VALIGN="TOP">Convert a network address into a string in dotted format.</P></TD></TR><TR><TD VALIGN="TOP"> </P></TD><TD VALIGN="TOP">#include &lt;winsock.h&gt;</P></TD></TR><TR><TD VALIGN="TOP"> </P></TD><TD VALIGN="TOP">char FAR * PASCAL FAR inet_ntoa ( struct in_addr in );</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>

<TABLE COLS="3" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="226pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">in</P></TD><TD VALIGN="TOP">A structure which represents an Internet host address.</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="298pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP">Remarks</P></TD><TD VALIGN="TOP">This function takes an Internet address structure specified by the in parameter.  It returns an ASCII string representing the address in ".''  notation as "a.b.c.d''.  Note that the string returned by inet_ntoa() resides in memory which is allocated by the Windows Sockets implementation.  The application should not make any assumptions about the way in which the memory is allocated.  The data is guaranteed to be valid until the next Windows Sockets API call within the same thread, but no longer.</P></TD></TR><TR><TD VALIGN="TOP">Return Value</P></TD><TD VALIGN="TOP">If no error occurs, inet_ntoa() returns a char pointer to a static buffer containing the text address in standard ".'' notation.  Otherwise, it returns NULL.  The data should be copied before another Windows Sockets call is made.</P></TD></TR><TR><TD VALIGN="TOP">See Also</P></TD><TD VALIGN="TOP">inet_addr().</P></TD></TR></TBODY></TABLE>
<BR></P><A NAME="PT14"></A>4.1.12 ioctlsocket()</P>
<P></P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="298pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP">Description</P></TD><TD VALIGN="TOP">Control the mode of a socket.</P></TD></TR><TR><TD VALIGN="TOP"> </P></TD><TD VALIGN="TOP">#include &lt;winsock.h&gt;</P></TD></TR><TR><TD VALIGN="TOP"> </P></TD><TD VALIGN="TOP">int PASCAL FAR ioctlsocket ( SOCKET s, long cmd, u_long FAR * argp );</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>

<TABLE COLS="3" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="226pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">s</P></TD><TD VALIGN="TOP">A descriptor identifying a socket.</P></TD></TR><TR><TD VALIGN="TOP">  </P></TD><TD VALIGN="TOP">cmd</P></TD><TD VALIGN="TOP">The command to perform on the socket s.</P></TD></TR><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">argp</P></TD><TD VALIGN="TOP">A pointer to a parameter for cmd.</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="298pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP">Remarks</P></TD><TD VALIGN="TOP">This routine may be used on any socket in any state.  It is used to get or retrieve operating parameters associated with the socket, independent of the protocol and communications subsystem.  The following commands are supported:</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>

<TABLE COLS="3" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="226pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">Command</P></TD><TD VALIGN="TOP">Semantics</P></TD></TR><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">FIONBIO</P></TD><TD VALIGN="TOP">Enable or disable non-blocking mode on the socket s.  argp points at an unsigned long, which is non-zero if non-blocking mode is to be enabled and zero if it is to be disabled.  When a socket is created, it operates in blocking mode (i.e. non-blocking mode is disabled).  This is consistent with BSD sockets.<BR>The WSAAsyncSelect() routine automatically sets a socket to nonblocking mode.  If WSAAsyncSelect() has been issued on a socket, then any attempt to use ioctlsocket() to set the socket back to blocking mode will fail with WSAEINVAL.  To set the socket back to blocking mode, an application must first disable WSAAsyncSelect() by calling WSAAsyncSelect() with the lEvent parameter equal to 0.</P></TD></TR><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">FIONREAD</P></TD><TD VALIGN="TOP">Determine the amount of data which can be read atomically from socket s.  argp points at an unsigned long in which ioctlsocket() stores the result.  If s is of type SOCK_STREAM, FIONREAD returns the total amount of data which may be read in a single recv(); this is normally the same as the total amount of data queued on the socket.  If s is of type SOCK_DGRAM, FIONREAD returns the size of the first datagram queued on the socket.</P></TD></TR><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">SIOCATMARK</P></TD><TD VALIGN="TOP">Determine whether or not all out-of-band data has been read.  This applies only to a socket of type SOCK_STREAM which has been configured for in-line reception of any out-of-band data (SO_OOBINLINE).  If no out-of-band data is waiting to be read,  the operation returns TRUE.  Otherwise it returns FALSE, and the next recv() or recvfrom() performed on the socket will retrieve some or all of the data preceding the "mark"; the application should use the SIOCATMARK operation to determine whether any remains.  If there is any normal data preceding the "urgent" (out of band) data, it will be received in order.  (Note that a recv() or recvfrom() will never mix out-of-band and normal data in the same call.)  argp points at a BOOL in which ioctlsocket() stores the result.</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="298pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP">Compatibility</P></TD><TD VALIGN="TOP">This function is a subset of ioctl() as used in Berkeley sockets.  In particular, there is no command which is equivalent to FIOASYNC, while SIOCATMARK is the only socket-level command which is supported.</P></TD></TR><TR><TD VALIGN="TOP">Return Value</P></TD><TD VALIGN="TOP">Upon successful completion, the ioctlsocket() returns 0.  Otherwise, a value of SOCKET_ERROR is returned, and a specific error code may be retrieved by calling WSAGetLastError().</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>

<TABLE COLS="3" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="118pt" VALIGN="TOP"><COL WIDTH="190pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP">Error Codes</P></TD><TD VALIGN="TOP">WSANOTINITIALISED<BR><BR>WSAENETDOWN<BR><BR>WSAEINVAL<BR><BR><BR>WSAEINPROGRESS<BR><BR>WSAENOTSOCK</P></TD><TD VALIGN="TOP">A successful WSAStartup() must occur before using this API.<BR>The Windows Sockets implementation has detected that the network subsystem has failed.<BR>cmd is not a valid command, or argp is not an acceptable parameter for cmd, or the command is not applicable to the type of socket supplied<BR>A blocking Windows Sockets operation is in progress.<BR></P></TD></TR></TBODY></TABLE>
<BR></P><P></P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="298pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP">See Also</P></TD><TD VALIGN="TOP">socket(), setsockopt(), getsockopt(), WSAAsyncSelect().</P></TD></TR></TBODY></TABLE>
<BR></P><A NAME="PT15"></A>4.1.13 listen()</P>
<P></P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="298pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP">Description</P></TD><TD VALIGN="TOP">Establish a socket to listen for incoming connection.</P></TD></TR><TR><TD VALIGN="TOP"> </P></TD><TD VALIGN="TOP">#include &lt;winsock.h&gt;</P></TD></TR><TR><TD VALIGN="TOP"> </P></TD><TD VALIGN="TOP">int PASCAL FAR listen ( SOCKET s, int backlog );</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>

<TABLE COLS="3" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="226pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">s</P></TD><TD VALIGN="TOP">A descriptor identifying a bound, unconnected socket.</P></TD></TR><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">backlog</P></TD><TD VALIGN="TOP">The maximum length to which the queue of pending connections may grow.</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="298pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP">Remarks</P></TD><TD VALIGN="TOP">To accept connections, a socket is first created with socket(), a backlog for incoming connections is specified with listen(), and then the connections are accepted with accept().  listen() applies only to sockets that support connections, i.e. those of type SOCK_STREAM.  The socket s is put into "passive'' mode where incoming connections are acknowledged and queued pending acceptance by the process.</P></TD></TR></TBODY></TABLE>
<BR></P>This function is typically used by servers that could have more than one connection request at a time: if a connection request arrives with the queue full, the client will receive an error with an indication of WSAECONNREFUSED.</P>
listen() attempts to continue to function rationally when there are no available descriptors.  It will accept connections until the queue is emptied.  If descriptors become available, a later call to listen() or accept() will re-fill the queue to the current or most recent "backlog'', if possible, and resume listening for incoming connections.</P>
<P></P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="298pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP">Compatibility</P></TD><TD VALIGN="TOP">backlog is currently limited (silently) to 5.  As in 4.3BSD, illegal values (less than 1 or greater than 5) are replaced by the nearest legal value.</P></TD></TR><TR><TD VALIGN="TOP">Return Value</P></TD><TD VALIGN="TOP">If no error occurs, listen() returns 0.  Otherwise, a value of SOCKET_ERROR is returned, and a specific error code may be retrieved by calling WSAGetLastError().</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>

<TABLE COLS="3" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="118pt" VALIGN="TOP"><COL WIDTH="190pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP">Error Codes</P></TD><TD VALIGN="TOP">WSANOTINITIALISED<BR><BR>WSAENETDOWN<BR><BR>WSAEADDRINUSE<BR><BR>WSAEINPROGRESS<BR><BR>WSAEINVAL<BR><BR>WSAEISCONN<BR>WSAEMFILE<BR>WSAENOBUFS<BR>WSAENOTSOCK<BR>WSAEOPNOTSUPP</P></TD><TD VALIGN="TOP">A successful WSAStartup() must occur before using this API.<BR>The Windows Sockets implementation has detected that the network subsystem has failed.<BR>An attempt has been made to listen() on an address in use.<BR>A blocking Windows Sockets operation is in progress.<BR>The socket has not been bound with bind() or is already connected.<BR>The socket is already connected.<BR>No more file descriptors are available.<BR>No buffer space is available.<BR>The descriptor is not a socket.<BR>The referenced socket is not of a type that supports the listen() operation.</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="298pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP">See Also</P></TD><TD VALIGN="TOP">accept(),  connect(), socket().</P></TD></TR></TBODY></TABLE>
<BR></P><A NAME="PT16"></A>4.1.14 ntohl()</P>
<P></P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="298pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP">Description</P></TD><TD VALIGN="TOP">Convert a u_long from network to host byte order.</P></TD></TR><TR><TD VALIGN="TOP"> </P></TD><TD VALIGN="TOP">#include &lt;winsock.h&gt;</P></TD></TR><TR><TD VALIGN="TOP"> </P></TD><TD VALIGN="TOP">u_long PASCAL FAR ntohl ( u_long netlong );</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>

<TABLE COLS="3" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="226pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">netlong</P></TD><TD VALIGN="TOP">A 32-bit number in network byte order.</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="298pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP">Remarks</P></TD><TD VALIGN="TOP">This routine takes a 32-bit number in network byte order and returns a 32-bit number in host byte order.</P></TD></TR><TR><TD VALIGN="TOP">Return Value</P></TD><TD VALIGN="TOP">ntohl() returns the value in host byte order.</P></TD></TR><TR><TD VALIGN="TOP">See Also</P></TD><TD VALIGN="TOP">htonl(), htons(), ntohs().</P></TD></TR></TBODY></TABLE>
<BR></P><A NAME="PT17"></A>4.1.15 ntohs()</P>
<P></P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="298pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP">Description</P></TD><TD VALIGN="TOP">Convert a u_short from network to host byte order.</P></TD></TR><TR><TD VALIGN="TOP">   </P></TD><TD VALIGN="TOP">#include &lt;winsock.h&gt;</P></TD></TR><TR><TD VALIGN="TOP"> </P></TD><TD VALIGN="TOP">u_short PASCAL FAR ntohs ( u_short netshort );</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>

<TABLE COLS="3" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="226pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">netshort</P></TD><TD VALIGN="TOP">A 16-bit number in network byte order.</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="298pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP">Remarks</P></TD><TD VALIGN="TOP">This routine takes a 16-bit number in network byte order and returns a 16-bit number in host byte order.</P></TD></TR><TR><TD VALIGN="TOP">Return Value</P></TD><TD VALIGN="TOP">ntohs() returns the value in host byte order.</P></TD></TR><TR><TD VALIGN="TOP">See Also</P></TD><TD VALIGN="TOP">htonl(), htons(), ntohl().</P></TD></TR></TBODY></TABLE>
<BR></P><A NAME="PT18"></A>4.1.16 recv()</P>
<P></P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="298pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP">Description</P></TD><TD VALIGN="TOP">Receive data from a socket.</P></TD></TR><TR><TD VALIGN="TOP"> </P></TD><TD VALIGN="TOP">#include &lt;winsock.h&gt;</P></TD></TR><TR><TD VALIGN="TOP"> </P></TD><TD VALIGN="TOP">int PASCAL FAR recv ( SOCKET s, char FAR * buf, int len, int flags );</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>

<TABLE COLS="3" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="226pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">s</P></TD><TD VALIGN="TOP">A descriptor identifying a connected socket.</P></TD></TR><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">buf</P></TD><TD VALIGN="TOP">A buffer for the incoming data.</P></TD></TR><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">len</P></TD><TD VALIGN="TOP">The length of buf.</P></TD></TR><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">flags</P></TD><TD VALIGN="TOP">Specifies the way in which the call is made.</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="298pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP">Remarks</P></TD><TD VALIGN="TOP">This function is used on connected datagram or stream sockets specified by the s parameter and is used to read incoming data.<BR><BR>For sockets of type SOCK_STREAM, as much information as is currently available up to the size of the buffer supplied is returned.  If the socket has been configured for in-line reception of out-of-band data (socket option SO_OOBINLINE) and out-of-band data is unread, only out-of-band data will be returned.  The application may use the ioctlsocket() SIOCATMARK to determine whether any more out-of-band data remains to be read.<BR><BR>For datagram sockets, data is extracted from the first enqueued datagram, up to the size of the buffer supplied.  If the datagram is larger than the buffer supplied, the buffer is filled with the first part of the datagram, the excess data is lost, and recv() returns the error WSAEMSGSIZE.<BR><BR>If no incoming data is available at the socket, the recv() call waits for data to arrive unless the socket is non-blocking.  In this case a value of SOCKET_ERROR is returned with the error code set to WSAEWOULDBLOCK.  The select() or WSAAsyncSelect() calls may be used to determine when more data arrives.<BR><BR>If the socket is of type SOCK_STREAM and the remote side has shut down the connection gracefully, a recv() will complete immediately with 0 bytes received.  If the connection has been reset, a recv() will fail with the error WSAECONNRESET.<BR><BR>Flags may be used to influence the behavior of the function invocation beyond the options specified for the associated socket.  That is, the semantics of this function are determined by the socket options and the flags parameter.  The latter is constructed by or-ing any of the following values:</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>

<TABLE COLS="3" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="226pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">Value</P></TD><TD VALIGN="TOP">Meaning</P></TD></TR><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">MSG_PEEK</P></TD><TD VALIGN="TOP">Peek at the incoming data.  The data is copied into the buffer but is not removed from the input queue.</P></TD></TR><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">MSG_OOB</P></TD><TD VALIGN="TOP">Process out-of-band data (See section 2.2.3 for a discussion of this topic.)</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="298pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP">Return Value</P></TD><TD VALIGN="TOP">If no error occurs, recv() returns the number of bytes received.  If the connection has been closed, it returns 0.  Otherwise, a value of SOCKET_ERROR is returned, and a specific error code may be retrieved by calling WSAGetLastError().</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>

<TABLE COLS="3" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="118pt" VALIGN="TOP"><COL WIDTH="190pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP">Error Codes</P></TD><TD VALIGN="TOP">WSANOTINITIALISED<BR><BR>WSAENETDOWN<BR><BR>WSAENOTCONN<BR>WSAEINTR<BR><BR>WSAEINPROGRESS<BR><BR>WSAENOTSOCK<BR>WSAEOPNOTSUPP<BR><BR>WSAESHUTDOWN<BR><BR><BR>WSAEWOULDBLOCK<BR><BR>WSAEMSGSIZE<BR><BR>WSAEINVAL<BR>WSAECONNABORTED<BR><BR>WSAECONNRESET</P></TD><TD VALIGN="TOP">A successful WSAStartup() must occur before using this API.<BR>The Windows Sockets implementation has detected that the network subsystem has failed.<BR>The socket is not connected.<BR>The (blocking) call was canceled via WSACancelBlockingCall().<BR>A blocking Windows Sockets operation is in progress.<BR>The descriptor is not a socket.<BR>MSG_OOB was specified, but the socket is not of type SOCK_STREAM.<BR>The socket has been shutdown; it is not possible to recv() on a socket after shutdown() has been invoked with how set to 0 or 2.<BR>The socket is marked as non-blocking and the receive operation would block.<BR>The datagram was too large to fit into the specified buffer and was truncated.<BR>The socket has not been bound with bind().<BR>The virtual circuit was aborted due to timeout or other failure.<BR>The virtual circuit was reset by the remote side.</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="298pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP">See Also</P></TD><TD VALIGN="TOP">recvfrom(), \deleted read(), ,recv(), send(), select(), WSAAsyncSelect(), socket()</P></TD></TR></TBODY></TABLE>
<BR></P><A NAME="PT19"></A>4.1.17 recvfrom()</P>
<P></P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="298pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP">Description</P></TD><TD VALIGN="TOP">Receive a datagram and store the source address.</P></TD></TR><TR><TD VALIGN="TOP"> </P></TD><TD VALIGN="TOP">#include &lt;winsock.h&gt;</P></TD></TR><TR><TD VALIGN="TOP"> </P></TD><TD VALIGN="TOP">int PASCAL FAR recvfrom ( SOCKET s, char FAR * buf, int len, int flags, </P></TD></TR><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">struct sockaddr FAR * from, int FAR * fromlen );</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>

<TABLE COLS="3" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="226pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">s</P></TD><TD VALIGN="TOP">A descriptor identifying a bound socket.</P></TD></TR><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">buf</P></TD><TD VALIGN="TOP">A buffer for the incoming data.</P></TD></TR><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">len</P></TD><TD VALIGN="TOP">The length of buf.</P></TD></TR><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">flags</P></TD><TD VALIGN="TOP">Specifies the way in which the call is made.</P></TD></TR><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">from</P></TD><TD VALIGN="TOP">An optional pointer to a buffer which will hold the source address upon return.</P></TD></TR><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">fromlen</P></TD><TD VALIGN="TOP">An optional pointer to the size of the from buffer.</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="298pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP">Remarks</P></TD><TD VALIGN="TOP">This function is used to read incoming data on a (possibly connected) socket and capture the address from which the data was sent.</P>
For sockets of type SOCK_STREAM, as much information as is currently available up to the size of the buffer supplied is returned.  If the socket has been configured for in-line reception of out-of-band data (socket option SO_OOBINLINE) and out-of-band data is unread, only out-of-band data will be returned.  The application may use the ioctlsocket() SIOCATMARK to determine whether any more out-of-band data remains to be read.  The from and fromlen parameters are ignored for SOCK_STREAM sockets.</P>
For datagram sockets, data is extracted from the first enqueued datagram, up to the size of the buffer supplied.  If the datagram is larger than the buffer supplied, the buffer is filled with the first part of the message, the excess data is lost, and recvfrom() returns the error code WSAEMSGSIZE.</P>
If from is non-zero, and the socket is of type SOCK_DGRAM, the network address of the peer which sent the data is copied to the corresponding struct sockaddr.  The value pointed to by fromlen is initialized to the size of this structure, and is modified on return to indicate the actual size of the address stored there.</P>
If no incoming data is available at the socket, the recvfrom() call waits for data to arrive unless the socket is non-blocking.  In this case a value of SOCKET_ERROR is returned with the error code set to WSAEWOULDBLOCK.  The select() or WSAAsyncSelect() calls may be used to determine when more data arrives.</P>
If the socket is of type SOCK_STREAM and the remote side has shut down the connection gracefully, a recvfrom() will complete immediately with 0 bytes received.  If the connection has been reset recv() will fail with the error WSAECONNRESET.</P>
Flags may be used to influence the behavior of the function invocation beyond the options specified for the associated socket.  That is, the semantics of this function are determined by the socket options and the flags parameter.  The latter is constructed by or-ing any of the following values:</P>
Value        Meaning</P>
MSG_PEEK    Peek at the incoming data.  The data is copied into the buffer but is not removed from the input queue.</P>
MSG_OOB    Process out-of-band data (See section 2.2.3 for a discussion of this topic.)</P></TD></TR><TR><TD VALIGN="TOP">Return Value</P></TD><TD VALIGN="TOP">If no error occurs, recvfrom() returns the number of bytes received.  If the connection has been closed, it returns 0.  Otherwise, a value of SOCKET_ERROR is returned, and a specific error code may be retrieved by calling WSAGetLastError().</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>

<TABLE COLS="3" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="118pt" VALIGN="TOP"><COL WIDTH="190pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP">Error Codes</P></TD><TD VALIGN="TOP">WSANOTINITIALISED<BR><BR>WSAENETDOWN<BR><BR>WSAEFAULT<BR><BR><BR>WSAEINTR<BR><BR>WSAEINPROGRESS<BR><BR>WSAEINVAL<BR>WSAENOTCONN<BR><BR>WSAENOTSOCK<BR>WSAEOPNOTSUPP<BR><BR>WSAESHUTDOWN<BR><BR><BR>WSAEWOULDBLOCK<BR><BR>WSAEMSGSIZE<BR><BR>WSAECONNABORTED<BR><BR>WSAECONNRESET</P></TD><TD VALIGN="TOP">A successful WSAStartup() must occur before using this API.<BR>The Windows Sockets implementation has detected that the network subsystem has failed.<BR>The fromlen argument was invalid: the from buffer was too small to accommodate the peer address.<BR>The (blocking) call was canceled via WSACancelBlockingCall().<BR>A blocking Windows Sockets operation is in progress.<BR>The socket has not been bound with bind().<BR>The socket is not connected (SOCK_STREAM only).<BR>The descriptor is not a socket.<BR>MSG_OOB was specified, but the socket is not of type SOCK_STREAM.<BR>The socket has been shutdown; it is not possible to recvfrom() on a socket after shutdown() has been invoked with how set to 0 or 2.<BR>The socket is marked as non-blocking and the recvfrom() operation would block.<BR>The datagram was too large to fit into the specified buffer and was truncated.<BR>The virtual circuit was aborted due to timeout or other failure.<BR>The virtual circuit was reset by the remote side.</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="298pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP">See Also</P></TD><TD VALIGN="TOP">recv(), send(), socket(), WSAAsyncSelect().</P></TD></TR></TBODY></TABLE>
<BR></P><A NAME="PT20"></A>4.1.18 select()</P>
<P></P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="298pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP">Description</P></TD><TD VALIGN="TOP">Determine the status of one or more sockets, waiting if necessary.</P></TD></TR><TR><TD VALIGN="TOP"> </P></TD><TD VALIGN="TOP">#include &lt;winsock.h&gt;</P></TD></TR><TR><TD VALIGN="TOP"> </P></TD><TD VALIGN="TOP">int PASCAL FAR select ( int nfds, fd_set FAR * readfds, fd_set FAR * writefds, fd_set FAR * exceptfds, const struct timeval FAR * timeout );</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>

<TABLE COLS="3" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="226pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">nfds</P></TD><TD VALIGN="TOP">This argument is ignored and included only for the sake of compatibility.</P></TD></TR><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">readfds</P></TD><TD VALIGN="TOP">An optional pointer to a set of sockets to be checked for readability.</P></TD></TR><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">writefds</P></TD><TD VALIGN="TOP">An optional pointer to a set of sockets to be checked for writability</P></TD></TR><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">exceptfds</P></TD><TD VALIGN="TOP">An optional pointer to a set of sockets to be checked for errors.</P></TD></TR><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">timeout</P></TD><TD VALIGN="TOP">The maximum time for select() to wait, or NULL for blocking operation.</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="298pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP">Remarks</P></TD><TD VALIGN="TOP">This function is used to determine the status of one or more sockets.  For each socket, the caller may request information on read, write or error status.  The set of sockets for which a given status is requested is indicated by an fd_set structure.  Upon return, the structure is updated to reflect the subset of these sockets which meet the specified condition, and select() returns the number of sockets meeting the conditions.  A set of macros is provided for manipulating an fd_set.  These macros are compatible with those used in the Berkeley software, but the underlying representation is completely different.  </P></TD></TR><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">The parameter readfds identifies those sockets which are to be checked for readability.  If the socket is currently listen()ing, it will be marked as readable if an incoming connection request has been received, so that an accept() is guaranteed to complete without blocking.  For other sockets, readability means that queued data is available for reading or, for sockets of type SOCK_STREAM, that the virtual socket corresponding to the socket has been closed, so that a recv() or recvfrom() is guaranteed to complete without blocking.  If the virtual circuit was closed gracefully, then a recv() will return immediately with 0 bytes read; if the virtual circuit was reset, then a recv() will complete immediately with the error code WSAECONNRESET. The presence of out-of-band data will be checked if the socket option SO_OOBINLINE has been enabled (see setsockopt()).</P></TD></TR><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">The parameter writefds identifies those sockets which are to be checked for writability.   If a socket is connect()ing (non-blocking), writability means that the connection establishment successfully completed.  If the socket is not in the process of connect()ing, writability means that a send() or sendto() will complete without blocking.  [It is not specified how long this guarantee can be assumed to be valid, particularly in a multithreaded environment.]</P></TD></TR><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">The parameter exceptfds identifies those sockets which are to be checked for the presence of out-of-band data or any exceptional error conditions.  Note that out-of-band data will only be reported in this way if the option SO_OOBINLINE is FALSE.  For a SOCK_STREAM, the breaking of the connection by the peer or due to KEEPALIVE failure will be indicated as an exception.  This specification does not define which other errors will be included.  If a socket is connect()ing (non-blocking), failure of the connect attempt is indicated in exceptfds.</P></TD></TR><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">Any of readfds, writefds, or exceptfds may be given as NULL if no descriptors are of interest.</P></TD></TR><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">Four macros are defined in the header file winsock.h for manipulating the descriptor sets.  The variable FD_SETSIZE determines the maximum number of descriptors in a set.  (The default value of FD_SETSIZE is 64, which may be modified by #defining FD_SETSIZE to another value before #including winsock.h.)  Internally, an fd_set is represented as an array of SOCKETs; the last valid entry is followed by an element set to INVALID_SOCKET.  The macros are:</P>
FD_CLR(s, *set)    Removes the descriptor s from set.<BR>FD_ISSET(s, *set)    Nonzero if s is a member of the set, zero otherwise.<BR>FD_SET(s, *set)    Adds descriptor s to set.<BR>FD_ZERO(*set)    Initializes the set to the NULL set.</P></TD></TR><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">The parameter timeout controls how long the select() may take to complete.  If timeout is a null pointer, select() will block indefinitely until at least one descriptor meets the specified criteria.  Otherwise, timeout points to a struct timeval which specifies the maximum time that select() should wait before returning.  If the timeval is initialized to {0, 0}, select() will return immediately; this is used to "poll" the state of the selected sockets.  If this is the case, then the select() call is considered nonblocking and the standard assumptions for nonblocking calls apply.  For example, the blocking hook must not be called, and the Windows Sockets implementation must not yield.</P></TD></TR><TR><TD VALIGN="TOP">Return Value</P></TD><TD VALIGN="TOP">select() returns the total number of descriptors which are ready and contained in the fd_set structures, 0 if the time limit expired, or SOCKET_ERROR if an error occurred.  If the return value is SOCKET_ERROR, WSAGetLastError() may be used to retrieve a specific error code.</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>

<TABLE COLS="3" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="118pt" VALIGN="TOP"><COL WIDTH="190pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP">Error Codes</P></TD><TD VALIGN="TOP">WSANOTINITIALISED<BR><BR>WSAENETDOWN<BR><BR>WSAEINVAL<BR>WSAEINTR<BR><BR>WSAEINPROGRESS<BR><BR>WSAENOTSOCK</P></TD><TD VALIGN="TOP">A successful WSAStartup() must occur before using this API.<BR>The Windows Sockets implementation has detected that the network subsystem has failed.<BR>The timeout value is not valid.<BR>The (blocking) call was canceled via WSACancelBlockingCall().<BR>A blocking Windows Sockets operation is in progress.<BR>One of the descriptor sets contains an entry which is not a socket.</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="298pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP">See Also</P></TD><TD VALIGN="TOP">WSAAsyncSelect(), accept(), connect(), recv(), recvfrom(), send().</P></TD></TR></TBODY></TABLE>
<BR></P><A NAME="PT21"></A>4.1.19 send()</P>
<P></P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="298pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP">Description</P></TD><TD VALIGN="TOP">Send data on a connected socket.</P></TD></TR><TR><TD VALIGN="TOP"> </P></TD><TD VALIGN="TOP">#include &lt;winsock.h&gt;</P></TD></TR><TR><TD VALIGN="TOP"> </P></TD><TD VALIGN="TOP">int PASCAL FAR send ( SOCKET s, const char FAR * buf, int len, int flags );</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>

<TABLE COLS="3" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="226pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">s</P></TD><TD VALIGN="TOP">A descriptor identifying a connected socket.</P></TD></TR><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">buf</P></TD><TD VALIGN="TOP">A buffer containing the data to be transmitted.</P></TD></TR><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">len</P></TD><TD VALIGN="TOP">The length of the data in buf.</P></TD></TR><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">flags</P></TD><TD VALIGN="TOP">Specifies the way in which the call is made.</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="298pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP">Remarks</P></TD><TD VALIGN="TOP">send() is used on connected datagram or stream sockets and is used to write outgoing data on a socket.  For datagram sockets, care must be taken not to exceed the maximum IP packet size of the underlying subnets, which is given by the iMaxUdpDg element in the WSAData structure returned by WSAStartup().  If the data is too long to pass atomically through the underlying protocol the error WSAEMSGSIZE is returned, and no data is transmitted.</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>

<TABLE COLS="1" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="370pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP">Note that the successful completion of a send() does not indicate that the data was successfully delivered.</P></TD></TR><TR><TD VALIGN="TOP">If no buffer space is available within the transport system to hold the data to be transmitted, send() will block unless the socket has been placed in a non-blocking I/O mode.  On non-blocking SOCK_STREAM sockets, the number of bytes written may be between 1 and the requested length, depending on buffer availability on both the local and foreign hosts.  The select() call may be used to determine when it is possible to send more data.</P></TD></TR><TR><TD VALIGN="TOP">Flags may be used to influence the behavior of the function invocation beyond the options specified for the associated socket.  That is, the semantics of this function are determined by the socket options and the flags parameter.  The latter is constructed by or-ing any of the following values:</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="298pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP">Value</P></TD><TD VALIGN="TOP">Meaning</P></TD></TR><TR><TD VALIGN="TOP">MSG_DONTROUTE</P></TD><TD VALIGN="TOP">Specifies that the data should not be subject to routing.  A Windows Sockets supplier may choose to ignore this flag; see also the discussion of the SO_DONTROUTE option in section 2.4.</P></TD></TR><TR><TD VALIGN="TOP">MSG_OOB</P></TD><TD VALIGN="TOP">Send out-of-band data (SOCK_STREAM only; see also section 2.2.3)</P></TD></TR><TR><TD VALIGN="TOP">Return Value</P></TD><TD VALIGN="TOP">If no error occurs, send() returns the total number of characters sent.  (Note that this may be less than the number indicated by len.) Otherwise, a value of SOCKET_ERROR is returned, and a specific error code may be retrieved by calling WSAGetLastError().</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>

<TABLE COLS="3" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="118pt" VALIGN="TOP"><COL WIDTH="226pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP">Error Codes</P></TD><TD VALIGN="TOP">WSANOTINITIALISED</P></TD><TD VALIGN="TOP">A successful WSAStartup() must occur before using this API.</P></TD></TR><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">WSAENETDOWN</P></TD><TD VALIGN="TOP">The Windows Sockets implementation has detected that the network subsystem has failed.</P></TD></TR><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">WSAEACCES</P></TD><TD VALIGN="TOP">The requested address is a broadcast address, but the appropriate flag was not set.</P></TD></TR><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">WSAEINTR</P></TD><TD VALIGN="TOP">The (blocking) call was canceled via WSACancelBlockingCall().</P></TD></TR><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">WSAEINPROGRESS</P></TD><TD VALIGN="TOP">A blocking Windows Sockets operation is in progress.</P></TD></TR><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">WSAEFAULT</P></TD><TD VALIGN="TOP">The buf argument is not in a valid part of the user address space.</P></TD></TR><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">WSAENETRESET</P></TD><TD VALIGN="TOP">The connection must be reset because the Windows Sockets implementation dropped it.</P></TD></TR><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">WSAENOBUFS</P></TD><TD VALIGN="TOP">The Windows Sockets implementation reports a buffer deadlock.</P></TD></TR><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">WSAENOTCONN</P></TD><TD VALIGN="TOP">The socket is not connected.</P></TD></TR><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">WSAENOTSOCK</P></TD><TD VALIGN="TOP">The descriptor is not a socket.</P></TD></TR><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">WSAEOPNOTSUPP</P></TD><TD VALIGN="TOP">MSG_OOB was specified, but the socket is not of type SOCK_STREAM.</P></TD></TR><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">WSAESHUTDOWN</P></TD><TD VALIGN="TOP">The socket has been shutdown; it is not possible to send() on a socket after shutdown() has been invoked with how set to 1 or 2.</P></TD></TR><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">WSAEWOULDBLOCK</P></TD><TD VALIGN="TOP">The socket is marked as non-blocking and the requested operation would block.</P></TD></TR><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">WSAEMSGSIZE</P></TD><TD VALIGN="TOP">The socket is of type SOCK_DGRAM, and the datagram is larger than the maximum supported by the Windows Sockets implementation.</P></TD></TR><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">WSAEINVAL</P></TD><TD VALIGN="TOP">The socket has not been bound with bind().</P></TD></TR><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">WSAECONNABORTED</P></TD><TD VALIGN="TOP">The virtual circuit was aborted due to timeout or other failure.</P></TD></TR><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">WSAECONNRESET</P></TD><TD VALIGN="TOP">The virtual circuit was reset by the remote side.</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>

<TABLE COLS="3" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="298pt" VALIGN="TOP"><COL WIDTH="10pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP">See Also</P></TD><TD VALIGN="TOP">recv(), recvfrom(), socket(), sendto(), WSAStartup().</P></TD><TD VALIGN="TOP"></P></TD></TR></TBODY></TABLE>
<BR></P><A NAME="PT22"></A>4.1.20 sendto()</P>
<P></P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="298pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP">Description</P></TD><TD VALIGN="TOP">Send data to a specific destination.</P></TD></TR><TR><TD VALIGN="TOP"> </P></TD><TD VALIGN="TOP">#include &lt;winsock.h&gt;</P></TD></TR><TR><TD VALIGN="TOP"> </P></TD><TD VALIGN="TOP">int PASCAL FAR sendto ( SOCKET s, const char FAR * buf, int len, int flags, const struct sockaddr FAR * to, int tolen );</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>

<TABLE COLS="3" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="226pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">s</P></TD><TD VALIGN="TOP">A descriptor identifying a socket.</P></TD></TR><TR><TD VALIGN="TOP">  </P></TD><TD VALIGN="TOP">buf</P></TD><TD VALIGN="TOP">A buffer containing the data to be transmitted.</P></TD></TR><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">len</P></TD><TD VALIGN="TOP">The length of the data in buf.</P></TD></TR><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">flags</P></TD><TD VALIGN="TOP">Specifies the way in which the call is made.</P></TD></TR><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">to</P></TD><TD VALIGN="TOP">An optional pointer to the address of the target socket.</P></TD></TR><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">tolen</P></TD><TD VALIGN="TOP">The size of the address in to.</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="298pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP">Remarks</P></TD><TD VALIGN="TOP">sendto() is used on datagram or stream sockets and is used to write outgoing data on a socket.  For datagram sockets, care must be taken not to exceed the maximum IP packet size of the underlying subnets, which is given by the iMaxUdpDg element in the WSAData structure returned by WSAStartup().  If the data is too long to pass atomically through the underlying protocol the error WSAEMSGSIZE is returned, and no data is transmitted.</P></TD></TR></TBODY></TABLE>
<BR></P>Note that the successful completion of a sendto() does not indicate that the data was successfully delivered.</P>
sendto() is normally used on a SOCK_DGRAM socket to send a datagram to a specific peer socket identified by the to parameter.  On a SOCK_STREAM socket, the to and tolen parameters are ignored; in this case the sendto() is equivalent to send().</P>
To send a broadcast (on a SOCK_DGRAM only), the address in the to parameter should be constructed using the special IP address INADDR_BROADCAST (defined in winsock.h) together with the intended port number.  It is generally inadvisable for a broadcast datagram to exceed the size at which fragmentation may occur, which implies that the data portion of the datagram (excluding headers) should not exceed 512 bytes.</P>
If no buffer space is available within the transport system to hold the data to be transmitted, sendto() will block unless the socket has been placed in a non-blocking I/O mode.  On non-blocking SOCK_STREAM sockets, the number of bytes written may be between 1 and the requested length, depending on buffer availability on both the local and foreign hosts.  The select() call may be used to determine when it is possible to send more data.</P>
Flags may be used to influence the behavior of the function invocation beyond the options specified for the associated socket.  That is, the semantics of this function are determined by the socket options and the flags parameter.  The latter is constructed by or-ing any of the following values:</P>
  </P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="298pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><B>Value</B></P></TD><TD VALIGN="TOP">Meaning</P></TD></TR></TBODY></TABLE>
<BR></P></P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="298pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP">MSG_DONTROUTE</P></TD><TD VALIGN="TOP">Specifies that the data should not be subject to routing.  A Windows Sockets supplier may choose to ignore this flag; see also the discussion of the SO_DONTROUTE option in section .</P></TD></TR><TR><TD VALIGN="TOP">MSG_OOB</P></TD><TD VALIGN="TOP">Send out-of-band data (SOCK_STREAM only; see also section )</P></TD></TR><TR><TD VALIGN="TOP">Return Value</P></TD><TD VALIGN="TOP">If no error occurs, sendto() returns the total number of characters sent.  (Note that this may be less than the number indicated by len.) Otherwise, a value of SOCKET_ERROR is returned, and a specific error code may be retrieved by calling WSAGetLastError().</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>

<TABLE COLS="3" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="118pt" VALIGN="TOP"><COL WIDTH="190pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP">Error Codes</P></TD><TD VALIGN="TOP">WSANOTINITIALISED<BR><BR>WSAENETDOWN<BR><BR><BR>WSAEACCES<BR><BR>WSAEINTR<BR><BR>WSAEINPROGRESS<BR><BR>WSAEFAULT<BR><BR><BR>WSAENETRESET<BR><BR>WSAENOBUFS<BR><BR>WSAENOTCONN<BR><BR>WSAENOTSOCK<BR>WSAEOPNOTSUPP<BR><BR>WSAESHUTDOWN<BR><BR><BR><BR>WSAEWOULDBLOCK<BR><BR>WSAEMSGSIZE<BR><BR><BR><BR>WSAECONNABORTED<BR><BR>WSAECONNRESET<BR><BR>WSAEADDRNOTAVAIL<BR><BR>WSAEAFNOSUPPORT<BR><BR>WSAEDESTADDRREQ<BR>WSAENETUNREACH</P></TD><TD VALIGN="TOP">A successful WSAStartup() must occur before using this API.</P>
The Windows Sockets implementation has detected that the network subsystem has failed.</P>
The requested address is a broadcast address, but the appropriate flag was not set.</P>
The (blocking) call was canceled via WSACancelBlockingCall().</P>
A blocking Windows Sockets operation is in progress.</P>
The buf or to parameters are not part of the user address space, or the to argument is too small (less than the sizeof a struct sockaddr).</P>
The connection must be reset because the Windows Sockets implementation dropped it.</P>
The Windows Sockets implementation reports a buffer deadlock.</P>
The socket is not connected (SOCK_STREAM only).</P>
The descriptor is not a socket.</P>
MSG_OOB was specified, but the socket is not of type SOCK_STREAM.</P>
The socket has been shutdown; it is not possible to sendto() on a socket after shutdown() has been invoked with how set to 1 or 2.</P>
The socket is marked as non-blocking and the requested operation would block.</P>
The socket is of type SOCK_DGRAM, and the datagram is larger than the maximum supported by the Windows Sockets implementation.</P>
The virtual circuit was aborted due to timeout or other failure.</P>
The virtual circuit was reset by the remote side.</P>
The specified address is not available from the local machine.\deleted </P>
Addresses in the specified family cannot be used with this socket.</P>
A destination address is required.</P>
The network can't be reached from this host at this time.</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="298pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP">See Also</P></TD><TD VALIGN="TOP">recv(), recvfrom(), socket(), send(), WSAStartup().</P></TD></TR></TBODY></TABLE>
<BR></P><A NAME="PT23"></A>4.1.21 setsockopt()</P>
<P></P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="298pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP">Description</P></TD><TD VALIGN="TOP">Set a socket option.</P></TD></TR><TR><TD VALIGN="TOP"> </P></TD><TD VALIGN="TOP">#include &lt;winsock.h&gt;</P></TD></TR><TR><TD VALIGN="TOP"> </P></TD><TD VALIGN="TOP">int PASCAL FAR setsockopt ( SOCKET s, int level, int optname, const char FAR * optval, int optlen );</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>

<TABLE COLS="3" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="226pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">s</P></TD><TD VALIGN="TOP">A descriptor identifying a socket.</P></TD></TR><TR><TD VALIGN="TOP">  </P></TD><TD VALIGN="TOP">level</P></TD><TD VALIGN="TOP">The level at which the option is defined; the only supported levels are SOL_SOCKET and IPPROTO_TCP.</P></TD></TR><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">optname</P></TD><TD VALIGN="TOP">The socket option for which the value is to be set.</P></TD></TR><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">optval</P></TD><TD VALIGN="TOP">A pointer to the buffer in which the value for the requested option is supplied.</P></TD></TR><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">optlen</P></TD><TD VALIGN="TOP">The size of the optval buffer.</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="298pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP">Remarks</P></TD><TD VALIGN="TOP">setsockopt() sets the current value for a socket option associated with a socket of any type, in any state.  Although options may exist at multiple protocol levels, this specification only defines options that exist at the uppermost "socket'' level.  Options affect socket operations, such as whether expedited data is received in the normal data stream, whether broadcast messages may be sent on the socket, etc.  </P></TD></TR></TBODY></TABLE>
<BR></P>There are two types of socket options: Boolean options that enable or disable a feature or behavior, and options which require an integer value or structure.  To enable a Boolean option, optval points to a nonzero integer.  To disable the option optval points to an integer equal to zero.  optlen should be equal to sizeof(int) for Boolean options.  For other options, optval points to the an integer or structure that contains the desired value for the option, and optlen is the length of the integer or structure.</P>
SO_LINGER controls the action taken when unsent data is queued on a socket and a closesocket() is performed.  See closesocket() for a description of the way in which the SO_LINGER settings affect the semantics of closesocket().  The application sets the desired behavior by creating a struct linger (pointed to by the optval argument) with the following elements:</P>
  </P>
<BR></P>
<pre><code>struct linger {
    int    l_onoff;
    int    l_linger;
}</code></pre>
  </P>
To enable SO_LINGER, the application should set l_onoff to a non-zero value, set l_linger to 0 or the desired timeout (in seconds), and call setsockopt().  To enable SO_DONTLINGER (i.e. disable SO_LINGER) l_onoff should be set to zero and setsockopt() should be called.</P>
By default, a socket may not be bound (see bind()) to a local address which is already in use.  On occasions, however, it may be desirable to "re-use" an address in this way.  Since every connection is uniquely identified by the combination of local and remote addresses, there is no problem with having two sockets bound to the same local address as long as the remote addresses are different.  To inform the Windows Sockets implementation that a bind() on a socket should not be disallowed because the desired address is already in use by another socket, the application should set the SO_REUSEADDR socket option for the socket before issuing the bind().  Note that the option is interpreted only at the time of the bind(): it is therefore unnecessary (but harmless) to set the option on a socket which is not to be bound to an existing address, and setting or resetting the option after the bind() has no effect on this or any other socket.</P>
An application may request that the Windows Sockets implementation enable the use of "keep-alive" packets on TCP connections by turning on the SO_KEEPALIVE socket option.  A Windows Sockets implementation need not support the use of keep-alives: if it does, the precise semantics are implementation-specific but should conform to section 4.2.3.6 of RFC 1122: Requirements for Internet Hosts -- Communication Layers.  If a connection is dropped as the result of "keep-alives" the error code WSAENETRESET is returned to any calls in progress on the socket, and any subsequent calls will fail with WSAENOTCONN.  </P>
The TCP_NODELAY option disables the Nagle algorithm.  The Nagle algorithm is used to reduce the number of small packets sent by a host by buffering unacknowledged send data until a full-size packet can be sent.  However, for some applications this algorithm can impede performance, and TCP_NODELAY may be used to turn it off.  Application writers should not set TCP_NODELAY unless the impact of doing so is well-understood and desired, since setting TCP_NODELAY can have a significant negative impact of network performance.  TCP_NODELAY is the only supported socket option which uses level IPPROTO_TCP; all other options use level SOL_SOCKET.</P>
Windows Sockets suppliers are encouraged (but not required) to supply output debug information if the SO_DEBUG option is set by an application.  The mechanism for generating the debug information and the form it takes are beyond the scope of this specification.</P>
The following options are supported for setsockopt().  The Type identifies the type of data addressed by optval.</P>
  </P>

<TABLE COLS="3" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="118pt" VALIGN="TOP"><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="226pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><B>Value</B></P></TD><TD VALIGN="TOP">Type</P></TD><TD VALIGN="TOP">Meaning</P></TD></TR></TBODY></TABLE>
<BR></P></P>

<TABLE COLS="3" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="118pt" VALIGN="TOP"><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="226pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP">SO_BROADCAST</P></TD><TD VALIGN="TOP">BOOL</P></TD><TD VALIGN="TOP">Allow transmission of broadcast messages on the socket.</P></TD></TR><TR><TD VALIGN="TOP">SO_DEBUG</P></TD><TD VALIGN="TOP">BOOL</P></TD><TD VALIGN="TOP">Record debugging information.  </P></TD></TR><TR><TD VALIGN="TOP">SO_DONTLINGER</P></TD><TD VALIGN="TOP">BOOL</P></TD><TD VALIGN="TOP">Don't block close waiting for unsent data to be sent.  Setting this option is equivalent to setting SO_LINGER with l_onoff set to zero.</P></TD></TR><TR><TD VALIGN="TOP">SO_DONTROUTE</P></TD><TD VALIGN="TOP">BOOL</P></TD><TD VALIGN="TOP">Don't route: send directly to interface.</P></TD></TR><TR><TD VALIGN="TOP">SO_KEEPALIVE</P></TD><TD VALIGN="TOP">BOOL</P></TD><TD VALIGN="TOP">Send keepalives</P></TD></TR><TR><TD VALIGN="TOP">SO_LINGER</P></TD><TD VALIGN="TOP">struct linger FAR *</P></TD><TD VALIGN="TOP">Linger on close if unsent data is present</P></TD></TR><TR><TD VALIGN="TOP">SO_OOBINLINE</P></TD><TD VALIGN="TOP">BOOL</P></TD><TD VALIGN="TOP">Receive out-of-band data in the normal data stream.  </P></TD></TR><TR><TD VALIGN="TOP">SO_RCVBUF</P></TD><TD VALIGN="TOP">int</P></TD><TD VALIGN="TOP">Specify buffer size for receives</P></TD></TR><TR><TD VALIGN="TOP">SO_REUSEADDR</P></TD><TD VALIGN="TOP">BOOL</P></TD><TD VALIGN="TOP">Allow the socket to be bound to an address which is already in use.  (See bind().) </P></TD></TR><TR><TD VALIGN="TOP">SO_SNDBUF</P></TD><TD VALIGN="TOP">int</P></TD><TD VALIGN="TOP">Specify buffer size for sends.</P></TD></TR><TR><TD VALIGN="TOP">TCP_NODELAY</P></TD><TD VALIGN="TOP">BOOL</P></TD><TD VALIGN="TOP">Disables the Nagle algorithm for send coalescing.</P></TD></TR></TBODY></TABLE>
<BR></P>BSD options not supported for setsockopt() are:</P>
  </P>

<TABLE COLS="3" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="46pt" VALIGN="TOP"><COL WIDTH="262pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><B>Value</B></P></TD><TD VALIGN="TOP">Type</P></TD><TD VALIGN="TOP">Meaning</P></TD></TR></TBODY></TABLE>
<BR></P></P>

<TABLE COLS="3" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="46pt" VALIGN="TOP"><COL WIDTH="262pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP">SO_ACCEPTCONN</P></TD><TD VALIGN="TOP">BOOL</P></TD><TD VALIGN="TOP">Socket is listening</P></TD></TR><TR><TD VALIGN="TOP">SO_ERROR</P></TD><TD VALIGN="TOP">int</P></TD><TD VALIGN="TOP">Get error status and clear</P></TD></TR><TR><TD VALIGN="TOP">SO_RCVLOWAT</P></TD><TD VALIGN="TOP">int</P></TD><TD VALIGN="TOP">Receive low water mark</P></TD></TR><TR><TD VALIGN="TOP">SO_RCVTIMEO</P></TD><TD VALIGN="TOP">int</P></TD><TD VALIGN="TOP">Receive timeout</P></TD></TR><TR><TD VALIGN="TOP">SO_SNDLOWAT</P></TD><TD VALIGN="TOP">int</P></TD><TD VALIGN="TOP">Send low water mark</P></TD></TR><TR><TD VALIGN="TOP">SO_SNDTIMEO</P></TD><TD VALIGN="TOP">int</P></TD><TD VALIGN="TOP">Send timeout</P></TD></TR><TR><TD VALIGN="TOP">SO_TYPE</P></TD><TD VALIGN="TOP">int</P></TD><TD VALIGN="TOP">Type of the socket</P></TD></TR><TR><TD VALIGN="TOP">IP_OPTIONS</P></TD><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">Set options field in IP header.</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="298pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP">Return Value</P></TD><TD VALIGN="TOP">If no error occurs, setsockopt() returns 0.  Otherwise, a value of SOCKET_ERROR is returned, and a specific error code may be retrieved by calling WSAGetLastError().</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>

<TABLE COLS="3" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="118pt" VALIGN="TOP"><COL WIDTH="190pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP">Error Codes</P></TD><TD VALIGN="TOP">WSANOTINITIALISED<BR><BR>WSAENETDOWN<BR><BR>WSAEFAULT<BR><BR>WSAEINPROGRESS<BR><BR>WSAEINVAL<BR><BR>WSAENETRESET<BR><BR>WSAENOPROTOOPT<BR><BR><BR><BR><BR><BR>WSAENOTCONN<BR><BR>WSAENOTSOCK</P></TD><TD VALIGN="TOP">A successful WSAStartup() must occur before using this API.<BR>The Windows Sockets implementation has detected that the network subsystem has failed.<BR>optval is not in a valid part of the process address  space.<BR>A blocking Windows Sockets operation is in progress.<BR>level is not valid, or the information in optval is not valid.<BR>Connection has timed out when SO_KEEPALIVE is set.<BR>The option is unknown or unsupported.  In particular, SO_BROADCAST is not supported on sockets of type SOCK_STREAM, while SO_DONTLINGER, SO_KEEPALIVE, SO_LINGER and SO_OOBINLINE are not supported on sockets of type SOCK_DGRAM.<BR>Connection has been reset when SO_KEEPALIVE is set.<BR>The descriptor is not a socket.</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="298pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP">See Also</P></TD><TD VALIGN="TOP">bind(), getsockopt(), ioctlsocket(), socket(), WSAAsyncSelect().</P></TD></TR></TBODY></TABLE>
<BR></P><A NAME="PT24"></A>4.1.22 shutdown()</P>
<P></P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="298pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP">Description</P></TD><TD VALIGN="TOP">Disable sends and/or receives on a socket.</P></TD></TR><TR><TD VALIGN="TOP"> </P></TD><TD VALIGN="TOP">#include &lt;winsock.h&gt; </P></TD></TR><TR><TD VALIGN="TOP"> </P></TD><TD VALIGN="TOP">int PASCAL FAR shutdown ( SOCKET s, int how );</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>

<TABLE COLS="3" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="226pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">s</P></TD><TD VALIGN="TOP">A descriptor identifying a socket.</P></TD></TR><TR><TD VALIGN="TOP">  </P></TD><TD VALIGN="TOP">how</P></TD><TD VALIGN="TOP">A flag that describes what types of operation will no longer be allowed.</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="298pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP">Remarks</P></TD><TD VALIGN="TOP">shutdown() is used on all types of sockets to disable reception, transmission, or both.<BR>If how is 0, subsequent receives on the socket will be disallowed.  This has no effect on the lower protocol layers.  For TCP, the TCP window is not changed and incoming data will be accepted (but not acknowledged) until the window is exhausted.  For UDP, incoming datagrams are accepted and queued.  In no case will an ICMP error packet be generated.<BR>If how is 1, subsequent sends are disallowed.  For TCP sockets, a FIN will be sent.<BR>Setting how to 2 disables both sends and receives as described above.<BR>Note that shutdown() does not close the socket, and resources attached to the socket will not be freed until closesocket() is invoked.</P></TD></TR><TR><TD VALIGN="TOP">Comments</P></TD><TD VALIGN="TOP">shutdown() does not block regardless of the SO_LINGER setting on the socket.<BR>An application should not rely on being able to re-use a socket after it has been shut down.  In particular, a Windows Sockets implementation is not required to support the use of connect() on such a socket.</P></TD></TR><TR><TD VALIGN="TOP">Return Value</P></TD><TD VALIGN="TOP">If no error occurs, shutdown() returns 0.  Otherwise, a value of SOCKET_ERROR is returned, and a specific error code may be retrieved by calling WSAGetLastError().</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>

<TABLE COLS="3" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="118pt" VALIGN="TOP"><COL WIDTH="190pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP">Error Codes</P></TD><TD VALIGN="TOP">WSANOTINITIALISED<BR><BR>WSAENETDOWN<BR><BR>WSAEINVAL<BR>WSAEINPROGRESS<BR><BR>WSAENOTCONN<BR><BR>WSAENOTSOCK</P></TD><TD VALIGN="TOP">A successful WSAStartup() must occur before using this API.<BR>The Windows Sockets implementation has detected that the network subsystem has failed.<BR>how is not valid.<BR>A blocking Windows Sockets operation is in progress.<BR>The socket is not connected (SOCK_STREAM only).<BR>The descriptor is not a socket.</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="298pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP">See Also</P></TD><TD VALIGN="TOP">connect(), socket().</P></TD></TR></TBODY></TABLE>
<BR></P><A NAME="PT25"></A>4.1.23 socket()</P>
<P></P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="298pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP">Description</P></TD><TD VALIGN="TOP">Create a socket.</P></TD></TR><TR><TD VALIGN="TOP"> </P></TD><TD VALIGN="TOP">#include &lt;winsock.h&gt;</P></TD></TR><TR><TD VALIGN="TOP"> </P></TD><TD VALIGN="TOP">SOCKET PASCAL FAR socket ( int af, int type, int protocol );</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>

<TABLE COLS="3" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="226pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">af</P></TD><TD VALIGN="TOP">An address format specification.  The only format currently supported is PF_INET, which is the ARPA Internet address format.</P></TD></TR><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">type</P></TD><TD VALIGN="TOP">A type specification for the new socket.</P></TD></TR><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">protocol</P></TD><TD VALIGN="TOP">A particular protocol to be used with the socket, or 0 if the caller does not wish to specify a protocol.</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="298pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP">Remarks</P></TD><TD VALIGN="TOP">socket() allocates a socket descriptor of the specified address family, data type and protocol, as well as related resources.  If a protocol is not specified (i.e. equal to 0), the default for the specified connection mode is used.  Only a single protocol exists to support a particular socket type using a given address format.  However, the address family may be given as AF_UNSPEC (unspecified), in which case the protocol parameter must be specified.  The protocol number to use is particular to the "communication domain'' in which communication is to take place.The following type specifications are supported:</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>

<TABLE COLS="3" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="226pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">Type</P></TD><TD VALIGN="TOP">Explanation</P></TD></TR><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">SOCK_STREAM</P></TD><TD VALIGN="TOP">Provides sequenced, reliable, two-way, connection-based byte streams with an out-of-band data transmission mechanism.  Uses TCP for the Internet address family.</P></TD></TR><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">SOCK_DGRAM</P></TD><TD VALIGN="TOP">Supports datagrams, which are connectionless, unreliable buffers of a fixed (typically small) maximum length.  Uses UDP for the Internet address family.</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>

<TABLE COLS="1" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="370pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP">Sockets of type SOCK_STREAM are full-duplex byte streams.  A stream socket must be in a connected state before any data may be sent or received on it.  A connection to another socket is created with a connect() call.  Once connected, data may be transferred using send() and recv() calls.  When a session has been completed, a closesocket() must be performed.  Out-of-band data may also be transmitted as described in send() and received as described in recv().</P></TD></TR><TR><TD VALIGN="TOP">The communications protocols used to implement a SOCK_STREAM ensure that data is not lost or duplicated.  If data for which the peer protocol has buffer space cannot be successfully transmitted within a reasonable length of time,  the connection is considered broken and subsequent calls will fail with the error code set to WSAETIMEDOUT.</P></TD></TR><TR><TD VALIGN="TOP">SOCK_DGRAM sockets allow sending and receiving of datagrams to and from arbitrary peers using sendto() and recvfrom().  If such a socket is connect()ed to a specific peer, datagrams may be send to that peer send() and may be received from (only) this peer using recv().</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="298pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP">Return Value</P></TD><TD VALIGN="TOP">If no error occurs, socket() returns a descriptor referencing the new socket.  Otherwise, a value of INVALID_SOCKET is returned, and a specific error code may be retrieved by calling WSAGetLastError().</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>

<TABLE COLS="3" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="133pt" VALIGN="TOP"><COL WIDTH="176pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP">Error Codes</P></TD><TD VALIGN="TOP">WSANOTINITIALISED<BR><BR>WSAENETDOWN<BR><BR>WSAEAFNOSUPPORT<BR>WSAEINPROGRESS<BR><BR>WSAEMFILE<BR>WSAENOBUFS<BR><BR>WSAEPROTONOSUPPORT<BR><BR><BR>WSAEPROTOTYPE<BR><BR>WSAESOCKTNOSUPPORT</P></TD><TD VALIGN="TOP">A successful WSAStartup() must occur before using this API.<BR>The Windows Sockets implementation has detected that the network subsystem has failed.<BR>The specified address family is not supported.<BR>A blocking Windows Sockets operation is in progress.<BR>No more file descriptors are available.<BR>No buffer space is available.  The socket cannot be created.<BR>The specified protocol is not supported.<BR>The specified protocol is the wrong type for this socket.<BR>The specified socket type is not supported in this address family.</P></TD></TR></TBODY></TABLE>
<BR></P><P></P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="298pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP">See Also</P></TD><TD VALIGN="TOP">accept(), bind(), connect(), getsockname(), getsockopt(), setsockopt(), listen(), recv(), recvfrom(), select(), send(), sendto(), shutdown(), ioctlsocket().</P></TD></TR></TBODY></TABLE>
<BR></P> </P></BODY></HTML>
