<HTML><HEAD><META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>B.3 Multithreadedness and blocking routines.</TITLE><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">

</OBJECT></FORM>
<H3>B.3 Multithreadedness and blocking routines.</H3>  </P>
Data areas returned by, for example, the getXbyY() routines MUST be on a per thread basis.</P>
Note that an application MUST be prevented from making multiple nested Windows Sockets function calls.  Only one outstanding function call will be allowed for a particular task.  Any Windows Sockets call performed when an existing blocking call is already outstanding will fail with an error code of WSAEINPROGRESS.  There are two exceptions to this restriction: WSACancelBlockingCall() and WSAIsBlocking() may be called at any time.  Windows Sockets suppliers should note that although preliminary drafts of this specification indicated that the restriction only applied to blocking function calls, and that it would be permissible to make non-blocking calls while a blocking call was in progress, this is no longer true.</P>
Regarding the implementation of blocking routines, the solution in Windows Sockets is to simulate the blocking mechanism by having each routine call PeekMessage() as it waits for the completion of its operation.  In anticipation of this, the function WSASetBlockingHook() is provided to allow the programmer to define a special routine to be called instead of the default PeekMessage() loop.  The blocking hook functions are discussed in more detail in 4.3.13, WSASetBlockingHook().</P>
 </P></BODY></HTML>
