<HTML><HEAD><META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Designing Applications for Microsoft BackOffice</TITLE><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">

</OBJECT></FORM>
<H1>Designing Applications for Microsoft BackOffice</H1>  </P>
<img src="DPT0U.gif"></P>
This whitepaper provides a brief technical overview of how to design applications which integrate in a client/server environment with the Microsoft BackOffice family of server applications.  These guidelines have been carefully selected to ensure that the application you develop takes advantage of the great features provide by the Microsoft BackOffice server suite.  Some of these guidelines are not required by your application in order to obtain the Designed for Microsoft BackOffice logo.  However it is recommended that you seriously consider utilizing such features as in the future it is possible that the recommended features become requirements.  These optional features are indicated via a *.  Pointers to additional information such as the Microsoft Developer Network (MSDN), the BackOffice Software Development Kit (SDK) and the Win32&reg; SDK are also provided so that you may quickly find in-depth information on each of these topics.</P>
</P>
Common Application Considerations</P>
Before even delving into creating your client/server application one needs to consider the important basics for any application regardless of where the application resides or which end, client or server, the application is targeted for.  By utilizing these techniques an application is able to take maximum advantage of the operating system platform it is designed to run on.  These techniques don't apply to just client or server based applications but to all applications in general.  They have been provided to simply your job of creating an application and enabling your applications to take advantage of some of the powerful features provided.  Chances are good that you will use some or all of these techniques in both your client and server based applications.  Just like your application will have a core purpose, these techniques provide you with the basic functionality for which you can use the techniques mentioned allow your applications to become more scaleable, manageable and more robust.  This is something which is required by all applications in distributed computing environments today.</P>
Being Network Independent</P>
Programming on top of an independent network transport allows the application to focus on the business application detail at hand without having to deal with the complexities of network data transfer.  A client application can be designed to take advantage of standard, transport-independent interproccess communications interfaces. This helps ensure that the client and server application programs will be able to run on a wide variety of network platforms with little or no modification.</P>
The Windows NT&reg; operating system currently supports numerous sets of networking APIs that provide this transport independence: the Windows&reg; Sockets interface, remote procedure call (RPC), named pipes and the Distributed Component Object Model (DCOM).</P>
A named pipe is a one-way or two-way pipe for communicating between a server process and one or more client processes.  Named pipes are implemented as a file system hence manipulation of named pipes occurs just as with reading and writing to file handles.  As part of the file system they share common functionality, such as caching, with the other file systems.  Additionally, processes on the local computer can use named pipes to communicate with one another without going through networking components.  Remote access to named pipes as with all of the file systems, is provided through the network redirector.  Working with named pipes is just like working with file I/O.  You can use the same file I/O APIs and simply pass in named pipe handles.  Named pipes also support impersonation, which allows a server to change its security identifier so that it matches the client's.  Named pipes also give you the ability to perform asynchronous execution known as overlapped I/O.  Overlapped operations make it possible for one pipe to read and write data simultaneously and for a single thread to perform simultaneous I/O operations on multiple pipe handles. This enables a single-threaded server process to handle communications with multiple client processes efficiently.  Server processes can create named pipes by simply calling <I>CreateNamedPipe</I> while clients can connect to named pipes by using <I>CreateFile</I> or <I>CallNamedPipe</I>.  Pipes can then by manipulated by using the usual <I>Read</I>, <I>Write</I> or <I>ReadEx</I>, <I>WriteEx</I> calls or <I>PeekNamedPipe</I> and <I>TransactNamedPipe</I>.</P>
The Windows Sockets API defines a network programming interface for the Microsoft&reg; Windows-based operating system on the "socket" paradigm popularized in the Berkeley Software Distribution (BSD) from the University of California at Berkeley. It encompasses both familiar Berkeley socket style routines and a set of Windows-specific extensions designed to allow the programmer to take advantage of the message-driven nature of Windows.  Windows Sockets is intended to provide a single API to which application developers can program and multiple network software vendors can conform. Furthermore, in the context of a particular version of Microsoft Windows, it defines a binary interface such that an application written using the Windows Sockets API can work with a conformant protocol implementation from any network software vendor. This specification thus defines the library calls and associated semantics to which an application developer can program and which a network software vendor can implement.  Windows Sockets provides functions which allow you to exchange data from a client to a server.  Servers can register services within a name space.  Functions are also provided to query the different protocols supported within the system as available services in the name space. The service registration and resolution functionality helps you write client server applications. Using this functionality, a service can register its existence with a name space (registration), and a client can find a service within a name space (resolution).</P>
Microsoft&reg; Remote Procedure Call (RPC) for the C and C++ programming languages is designed to help meet the needs of developers working on the next generation of software for the MS-DOS&reg;, Microsoft Windows&reg;, and Microsoft Windows NT&trade; family of operating systems.</P>
Microsoft Remote Procedure Call (RPC) represents the convergence of three powerful programming models: the familiar model of developing C applications by writing procedures and libraries; the model that uses powerful computers as network servers to perform specific tasks for their clients; and the client-server model, in which the client usually manages the user interface while the server handles data storage, queries, and manipulation.  When you write a client-server application, you must provide the layer of code that manages network communication. The advantage of using Microsoft RPC is that the RPC tools provide this layer for you. RPC nearly eliminates the need to write network-specific code, making it easier to develop distributed applications.  Using the remote procedure call model, RPC tools manage many of the details relating to network protocols and communication. This allows you to focus on the details of the application rather than the details of the network.  Microsoft RPC is an evolution of the procedural programming model familiar to all developers.  Microsoft RPC allows a process running in one address space to make a procedure call that will be executed in another address space. The call looks like a standard local procedure call but is actually made to a stub that interacts with the run-time library and performs all the steps necessary to execute the call in the remote address space.  As a tool for creating distributed applications, Microsoft RPC provides the following benefits:</P>
<SPAN CLASS="list"><UL><LI>The RPC programming model is already familiar. You can easily turn functions into remote procedures, which simplifies the development and test cycles.</LI><LI>RPC hides many details of the network interface from the developer. You don't have to understand specific network functions or low-level network protocols to implement powerful distributed applications.</LI><LI>RPC solves the data-translation problems that crop up in heterogeneous networks; individual applications can ignore this problem.</LI><LI>The RPC approach is scalable.  As a network grows, applications can be distributed to more than one computer on the network.</LI><LI>The RPC model is popular within thean industry standard.  The Microsoft implementation is compatible with both client and server.</LI></UL></SPAN></P>
The following items need to be performed when developing a client application to use RPC:</P>
<SPAN CLASS="list"><UL><LI>Defining the function interfaces using the Interface Definition Language (IDL) and compile the IDL file using the MIDL compiler</LI><LI>Determine if your application is going to use automatic binding or application managed binding (managing  binding handles, etc.)</LI></UL></SPAN></P>
The following items need to be performed when developing a server application to use RPC:</P>
<SPAN CLASS="list"><UL><LI>The server application must register it's endpoint and the protocols under communications occur.</LI><LI>The server then enters a listening mode for client requests.</LI></UL></SPAN></P>
<I>For more information regarding Remote Procedure Call see the Win32 SDK/RPC.</I></P>
</P>
The Component Object Model (COM) is designed to allow clients to communicate transparently with objects, regardless of where those objects are running - the same process, the same machine, or a different machine.  This provides a single programming model for all types of objects, both object clients and object servers.  From a client's point of view, all objects are accessed through interface pointers.  COM does not specify how components are structured; it specifies how they interact. COM leaves the concern about the internal structure of a component to programming languages and development environments. Conversely, programming environments have no set standards for working with objects outside of the immediate application. C++, for example, works extremely well to manipulate objects inside an application, but has no support for working with objects outside the application. Generally, all other programming languages are the same in this regard. Therefore COM, through language-independent interfaces, picks up where programming languages leave off to provide the network-wide interoperability.  Today COM provides the components needed to perform cross process communication within the same machine. Beginning with the Windows NT Operating System 4.0 there now exists the opportunity to create not just cross process components but also cross machine components, this is known as distributed COM (DCOM).  DCOM naturally extends the programming model and constructs introduced by OLE 2.0 to work across the network, including:</P>
<SPAN CLASS="list"><UL><LI><I>Location Transparency</I>. Client applications need not know or care where objects are running. Many applications are written indifferent to whether the objects used run within their process, in a different process on the same machine, or in a process on a separate machine.  DCOM allows new applications to be written which take advantage of networking features, but also allows existing applications – thousands of them – to interact with new applications and with each other across networks with proper administration.</LI><LI><I>Packaging Transparency</I>. Client applications need not know or care that objects are packaged as in-process objects (in dynamic-link libraries), or as local or remote objects (in executables). DCOM further allows objects to be packaged as Windows NT Services, synchronizing OLE with the rich administrative and system-integration capabilities of Windows NT.</LI></UL></SPAN>Distributed COM further complements existing COM features with the security and scalability features required to build great <I>distributed </I>component software:</P>
<SPAN CLASS="list"><UL><LI><I>Free-Threaded Objects</I>. High-performance, scaleable object services supporting simultaneous calls can be written for use by remote clients or by clients on the same machine.</LI><LI><I>Launch Security</I>. Network OLE is configured by default so that only machine administrators can launch existing classes from a remote client. Launch security is configurable with a machine-wide default (DefaultLaunchPermission) and on an overriding per-class basis (LaunchPermission). Launch security also applies to local launch requests (requests to use classes by users on the same machine), a new feature to local OLE.</LI><LI><I>Access Security</I>. Network OLE is similarly configured so that only machine administrators can access existing, published objects from a remote client. Access security is also configurable with a maching-wide default (DefaultAccessPermission), on an overriding per-class basis (AccessPermission) when applicable, and on a per-process basis (CoInitializeSecurity or the default security keys). Access security also applies to local attempts to access classes, a new feature to local OLE.</LI><LI><I>Call-Level Security</I>. Network OLE also offers fine-grained configuration of the call security – how connections and calls are authenticated, authorized, encrypted, etc. – of any connection to an object, as well as the ability for the object to impersonate or act under the authority of the caller.</LI></UL></SPAN></P>
<I>For more information on OLE/COM see the Win32 SDK OLE/OLE Programmer's Guide/Guide/The Component Object Model.  For custom interfaces see the Win32 SDK OLE/OLE Programmer's Guide/Appendixes/OLE Custom Interfaces.</I></P>
</P>
*Taking Advantage of the Windows 32-bit API</P>
We believe that ensuring there is a client that executes on standard desktop operating systems is important.  With the release of Windows NT and Windows 95 as 32-bit operating systems there now exists the potential to create powerful 32-bit based client applications.  The Win32 API provides a unified API on the Windows NT and Windows 95 operating systems allows gives the advantage of having a single set of source code that can be used on multiple platforms (X86, MIPS&reg;, Alpha, PowerPC&trade;).  By taking advantage of the Win32 API, a client application can utilize features of the Win32 API.  Some features are detailed below:</P>
<SPAN CLASS="list"><UL><LI>Structured Exception Handling for elegant error and termination handling.  The termination handling ensures that whenever a guarded body of code is executed, a specified block of termination code is also executed. The termination code is executed regardless of how the flow of control leaves the guarded body. For example, a termination handler can guarantee that clean-up tasks are performed even if an exception or some other error occurs while the guarded body of code is being executed.  Structured exception handling is made available to developers primarily through compiler support. For example, the Microsoft compilers provided with the Win32 software development kit support the try keyword that identifies a guarded body of code, and the except and finally keywords that identify an exception handler and a termination handler, respectively.</LI><LI>Use the system defined database, the registry, for storing and retrieving configuration data on a per-user, per-machine, per-application basis.  Since the data is stored in a binary format an application must use the registry functions to manipulate the registry. The registry stores data in a hierarchically structured tree. Each node in the tree is called a key. Each key can contain both subkeys and data entries called values. An application uses the RegOpenKey or RegOpenKeyEx function to open a key and the RegCreateKey or RegCreateKeyEx function to create a key.  An application can use the RegCloseKey function to close a key and write the data it contains into the registry.  An application can use either the RegSetValue or RegSetValueEx function to associate a value and its data with a key and RegDeleteValue to remove a value or RegDeleteKey to remove a key.  To change a key's security information, an application can use the RegSetKeySecurity function.  To retrieve detailed data about a particular subkey, an application can call the RegQueryInfoKey function.  The RegGetKeySecurity function retrieves a copy of the security descriptor protecting a key.  An application can use the RegEnumValue function to enumerate the values for a given key, and the RegQueryValue or RegQueryValueEx function to retrieve a particular value for a key.</LI><LI>Multitasked thread support for scalability and high performance. To the application developer, the advantage of multitasking is the ability to create applications that use more than one process and to create processes that use more than one thread of execution. It is useful for a process to have multiple threads in situations where the application has several tasks to run concurrently.  Multiple threads can be a convenient way to structure a program that performs several similar or identical tasks.   They can be especially beneficial to server applications in the following cases:  <I>Communications bound tasks.</I><B> </B>The portion of a server application that provides services to clients should be implemented in one or more threads separate from the portion of the application that performs processing on behalf of the client or that connects to an auxiliary process.  <I>Tasks within a system of varying priority.</I> The portion of a server application devoted to CPU-intensive tasks should be implemented using different  threads form the portions devoted to  I/O-intensive tasks to ensure that higher-priority tasks receive scheduling preference.</LI><LI>Synchronization for coordination of multiple threads within processes.  In order to coordinate multiple threads of execution synchronization mechanisms, such as wait functions and synchronization objects, and overlapped input and output (I/O) operations are provided.  Synchronization objects have handles which can be specified in one of the wait functions to coordinate the execution of multiple threads.  Objects include events for notification, mutexes for mutually exclusive access to shared resources, and semaphores for limiting the number of threads that may simulataneously access a shared resource.  Wait functions enable a thread to block its own execution. These functions do not return until a set of conditions specified by the wait function's parameters (time-out interval and handles of one or more synchronization objects).  Execution can be suspended on a single object using WaitForSingleObject or WaitForSingleObjectEx.  Threads can also suspend execution on multiple objects using WaitForMultipleObjects, WaitForMultipleObjectsEx, and MsgWaitForMultipleObjects. Synchronous and asynchronous (or overlapped) I/O operations can be performed on files, named pipes, and serial communications devices. Using the WriteFile, ReadFile, DeviceIoControl, WaitCommEvent, ConnectNamedPipe, and TransactNamedPipe, functions can be performed either synchronously or asynchronously while ReadFileEx and WriteFileEx performs asynchronously only. Overlapped operations require a file, named pipe, or communications device that was created with the FILE_FLAG_OVERLAPPED flag. A thread can manage overlapped operations by either of two methods. It can use the GetOverlappedResult function to wait for the overlapped operation to be completed. Alternatively, it can specify a handle of the OVERLAPPED structure's manual-reset event object in one of the wait functions and then call GetOverlappedResult after the wait function returns.</LI><LI>Event logging provides a common repository for recording software and hardware events as well as providing an interface to view them.  Logging consumes resources: disk space and logging time. The event log is not intended to be used as a trace facility.  You should log information about events that can be used to diagnose problems after they have occurred.  Logging low-memory conditions, for example, can provide information about a problem that the system administrator can solve by adding more memory to the computer. The OpenEventLog and ReportEvent functions take an optional server name as a parameter so that the operations can be performed on the remote server. OpenEventLog should be used for reading or performing some administrative operation (backup, clear, query) on the log, and RegisterEventSource should be used for writing to logs. </LI><LI>Performance monitoring provides a mechanism for developers to add performance objects and counters for their applications and other software components so that they can provide performance data to Windows NT Performance Monitor or to your customized performance monitoring programs.  To add performance counters to the system, you must create an extended object.  Your extended object is called when Performance Monitor collects data.</LI></UL></SPAN><SPAN CLASS="list"><OL><LI>To add performance objects and counters for your application, follow the basic steps in the list below:</LI><LI>Design the object types and counters for the application. </LI><LI>Set up the necessary performance monitoring entries in the Registry. This includes the following steps: 

<UL><LI>a.    Create a Performance key in the application's Services node in the Registry. If you don't have such a node you must create one. Create it under HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services.</LI><LI>b.    Create an .INI file containing the names and descriptions of the counter objects and counters. </LI><LI>c.    Create an .H file containing the relative offsets at which the counter objects and counters will be installed in the Registry. </LI><LI>d.    Use the lodctr utility with the .INI and .H files to install the information in the Registry. Lodctr succeeds only if a Performance key exists in the application's Services node.</LI><LI>e.    Add Library, Open, Collect, and Close value entries to the application's Services node in the Registry. These entries specify the name of the application's performance DLL, and the names of the DLLs required functions. The Open and Close entries are optional.</LI></UL></LI><LI>To your application, add functions and data structures for collecting and storing performance data, and a mechanism for communicating the data to the performance DLL.</LI><LI>Create a performance DLL containing a set of exported functions that provide the link between the application and a performance monitoring application (such as Windows NT Performance Monitor).</LI><LI>Modify the application's OEMSETUP.INF file to automate the Registry setup described in step 4.</LI></OL></SPAN><SPAN CLASS="list"><UL><LI>Utilize the National Language Support APIs.  For Windows NT-based applications support Unicode&trade;.  Supporting Unicode means changing applications as follows:

<OL><LI>modify your code to use generic data types - converting from char and char * to TCHAR and TCHAR *, or LPSTR and LPCH to LPTSTR and LPTCH.  Utitlize the MultiByteToWideChar and WideCharToMultiByte APIs as necessary.</LI><LI>modify your code to use generic function prototypes - for example, use _tcslen instead of strlen or GetLocaleInfo instead of GetLocaleInfoA.</LI><LI>surround any character or string literal with the TEXT macro</LI><LI>create generic versions of your data structures</LI><LI>change your make process - utilize the -DUNICODE or -D_UNICODE compile-time flags.</LI><LI>adjust pointer arithmetic</LI><LI>check for any code that assumes a character is always 1 byte long</LI><LI>add Unicode specific code if necessary - that means to utilize the WideCharToMultiByte and MultiByteToWideChar, mbtowc, mbstowcs, etc. functions.</LI><LI>add code to support special Unicode characters</LI><LI>determine how using Unicode will affect file I/O</LI><LI>double-check the way in which you retrieve command line arguments</LI><LI>debug your port by enabling your compiler's type-checking</LI></OL></LI></UL></SPAN><I>For more information see Developing International Software for Windows 95 and Windows NT by Nadine Kano.</I></P>
<SPAN CLASS="list"><UL><LI>Supporting long file names and the universal naming convention.</LI></UL></SPAN><I>For more information on these topics see the Win32 SDK System Services.</I></P>
Being Installable Via Systems Management Server</P>
The application must be installable via Systems Management Server and provide the appropriate PDF and MIF files, supporting user interface-less installation, and support an Uninstall option.  Applications that support Systems Management Server are easier for customers to deploy, manage, upgrade, and inventory.</P>
A software Setup or installation program with Systems Management Server must support these items:</P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="232pt" VALIGN="TOP"><COL WIDTH="232pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP">Providing a Package Definition File</P></TD><TD VALIGN="TOP">A PDF follows the standard initialization file format. It is an ASCII text file containing keys (the key names are enclosed within square brackets). Key names can be separated by spaces. Each key contains one or more entries, where each entry follows the format: name = value1, value2, ... Values are separated by a comma and at least one space. A PDF has specific keys and entries that are used by the system to set the properties of a package.</P></TD></TR><TR><TD VALIGN="TOP">Unattended Setup</P></TD><TD VALIGN="TOP">The program must not require input from the user during the installation, removal, or maintenance of the application. Any information or options required by the Setup program should be supplied by command-line switches to the program, or should be provided in a configuration file that is read by the program at run time.   Because multiple packages can be installed by Systems Management Server at one time, no individual package installation should force a restart as part of its installation program.  To copy system files that may be in use, Setup programs typically construct a batch file containing operations that must be performed during a restart.</P></TD></TR><TR><TD VALIGN="TOP">Providing for Uninstall</P></TD><TD VALIGN="TOP">The setup program should also include a provision to support the removal of the application owned components, clean up environment settings and registry entries.  This is to facilitate software upgrades, retirement, recalls, etc..  The setup program ideally would provide a switch or option as part of the setup procedure supporting Uninstall. </P></TD></TR><TR><TD VALIGN="TOP">Report Status Back to Systems Management Server by Using a Status MIF</P></TD><TD VALIGN="TOP">To report the status of a PCM application installation, a MIF file must be created in the Windows directory. The MIF file should be named appname.MIF, where appname is the name of the application. In fact, the PCM will pick up any file in the Windows directory with an extension of .MIF (and which was created-timestamped-after PCM began the installation) and send it back to Systems Management Server. </P></TD></TR></TBODY></TABLE>
<BR></P><I>For more information see the BackOffice SDK Systems Management Server.</I></P>
Creating Server Based Applications</P>
Back in the days of mainframe programming users logged into mainframe computers from non-intelligent client terminals.  The client terminals essentially an extension of the mainframe computer.  It was as if people were in the same location as the mainframe and logging directly into it.  They were logging directly into it but from afar.  From here they ran programs on powerful mainframe computers which hosted many users simultaneously.  The environment has changed in the face of today with the introduction of more powerful client workstations, each with it's own cpu, memory, storage devices and capable of doing more work, faster.  Servers computers have begun to replace mainframes and clients are now being authenticated by servers for priveleged access.  Programs are still being run, but now they are being run on the client workstations themselves.  These programs may be split into multiple tiers.  One tier of the application may reside on the server while another may reside on the client.  There may be even yet another tier residing on an intermediary computer.  More than likely these application tiers communicate with each other through some form of inter-process communication over a variety of network protocols.  Client portions of an application may exchange data with a server portion or it may intiate some work to be done by the server portion.</P>
In a world today where there are numerous network protocols being used, such as TCP/IP or IPX/SPX, making it difficult for an application developer to create an application which not only focuses on the actual task at hand but to also focus on manipulating the underlying network protocol.  As a solution to this there have been various programming models and APIs developed for applications to use without having to understand the underlying network protocol.</P>
Being in a networked environment where mutliple clients communicate with multiple servers creates the risk of unauthorized users attempting to access server functionality.</P>
Running as a Windows NT Operating System Server Service</P>
Services can be configured to run automatically at system boot time without user intervention and can execute at a different security level than the user.  Services also allow administrators to use remote administration tools providing remote application management. Applications that are designed to run as a service may be more robust, scalable and more suitable for large scale enterprise deployment. </P>
</P>
In the Microsoft Win32 application programming interface (API), a service is an executable object that is installed in a registry database maintained by the service control manager. The services database includes information that determines whether each installed service is started on demand or is started automatically when the system starts. The database can also contain logon and security information for a service so that a service can run even though no user is logged on. It also enables system administrators to customize security requirements for each service and thereby control access to the service. No more than one instance of a service can be running at a time.  A server application running as a Windows NT service can do so using a unique service account for remote administration and control. For example, if a database application and a host connectivity application are both running on the same Windows NT Server system, these applications can run as services under separate service accounts. This helps ensure that only designated host connectivity administrators can administer the host connectivity server application, and that only database administrators can administer database server applications. An additional benefit of this configuration is that it makes it possible for oan administrator to control a group of services that work under a common user account.  Running as a Windows NT service helps a server application impersonate a client while accessing objects on behalf of the client. This capability ensures that the server application can act on behalf of a client without requiring the server application to run with an inappropriately high privilege level. It also ensures that the server application will not be able to perform actions that would be denied the client directly.  Services can be configured to start automatically, either when the server running Windows NT Server itself starts, or when the service is started by a dependent service that starts automatically. In either case, the service starts without human intervention, that is, without a user being required to log on and then explicitly start the service. By starting automatically, a server application implemented as a service is guaranteed to be available whenever needed so long as the Windows NT Server operating system is running. Moreover, related services can be started easily and, where appropriate, automatically.  Finally, implementing a server application as a service allows the application to be installed and controlled using standard user and Win32 API's programming interfaces. Such a service can be started and stopped both locally and remotely, providing network administrators an easy and consistent way to control the service across the network.</P>
Creating a Windows NT Service involves the following items:</P>
<SPAN CLASS="list"><UL><LI>Creating a main function which calls <I>StartServiceCtrlDispatcher</I> to connect to the Service Control Manager and starts a control dispatcher thread</LI><LI>Writing the ServiceMain entry point where the control dispatcher thread starts running</LI><LI>Writing a control handler function for handling service opcodes and reporting back service status</LI><LI>Install a service using the <I>CreateService</I> function</LI></UL></SPAN><I>For more information about creating a Windows NT Service see the Win32 SDK System Services/Services</I></P>
Support Windows NT Operating System Unified Logon</P>
Unified logon allows the client to logon one time to the system and utilize the security system of Windows NT to authenticate the user for network and application resources.  Client applications submit requests to server side components which execute privileged functions and access restricted objects.  One objective of the Windows NT security model is to ensure that the programs that a user runs have no more access to objects than the user does. When a program or process runs on the user's behalf, it is said to be running in the security context of that user. The security context controls what access the subject has to objects or system services. In general, when a subject calls an object service through a protected subsystem, the subject's token is used within the service to determine who made the call and to decide whether the caller has sufficient access authority to perform the requested action.</P>
Windows NT allows one process to take on the security attributes of another through a technique called impersonation.  For example, a server process typically impersonates a client process to complete a task involving objects to which the server does not normally have access.  Impersonation is useful in a distributed computing environment when servers must pass client requests to other server processes or to the operating system. In this case, a server impersonates the client's security context. Other server processes can then handle the request as if it had been made by the original client.  For example, a client makes a request to Server A. If Server A must query Server B to complete the request, Server A impersonates client security context and makes the request to Server B on behalf of the client. Server B uses the original client's security context, rather than the security identity for Server A, to determine whether to complete the task.</P>
</P>
Using named pipes a server process uses the <I>ImpersonateNamedPipeClient</I> function to assume the security token of the client process connected to the specified pipe instance. This function can be useful in determining whether to grant the request of a client process. For example, a named pipe server can provide access to a database or file system to which the server process has privileged access. When a client process makes a request from the server, the client typically has some lesser level of security access. By assuming the security token of the client, the server can attempt to access the protected database. The system then grants or denies the server's access, based on the security level of the client. When the server is finished, it uses the <I>RevertToSelf</I> function to restore its original security token. </P>
Remote procedure calls require that the server call <I>RpcImpersonateClient</I> to overwrite the security for the server thread with the client security context. <I>RpcRevertToSelf</I> restores the security context defined for the server thread.  When binding, the client can specify quality-of-service information about security that specifies how the server can impersonate the client. For example, one of the settings allows the client to specify that the server is not allowed to impersonate it.</P>
Windows NT 3.51 introduces another set of APIs used for impersonation. The <I>LogonUser</I> function attempts to perform a user logon operation. You specify the user with a user name and domain, and authenticate the user with a clear-text password. If the function succeeds, you receive a handle to a token that represents the logged-on user. You can then use this token handle to impersonate the specified user, or to create a process running in the context of the specified user.  Using this security token one may call the <I>ImpersonateLoggedOnUser</I> function, which  lets the calling thread impersonate a user.  Also using this security token one may call the <I>CreateProcessAsUser</I> function which creates a new process and its primary thread. The new process then executes a specified executable file. The <I>CreateProcessAsUser</I> function behaves just like the <I>CreateProcess</I> function, with one important difference: the created process runs in a context in which the system sees the user represented by the security token as if that user had logged on to the system and then called the <I>CreateProcess</I> function.</P>
The process occurs as follows:</P>
<SPAN CLASS="list"><UL><LI>Client submits a request to a server process in order to access a privileged object</LI><LI>Server process calls impersonation function.  This may be <I>ImpersonateNamedPipe</I>, <I>RpcImpersonateClient</I>, or it may be a combination of <I>LogonUser</I> and <I>CreateProcessAsUser</I> or <I>ImpersonateLoggedOnUser</I>.  This effectively switches the security context to that of the client.</LI><LI>Server process access object on behalf of the client.</LI><LI>Server process reverts back to it's own security context via <I>RevertToSelf</I> or <I>RpcRevertToSelf</I></LI></UL></SPAN><I>For more information see the Win32 SDK and query for "impersonation".</I></P>
*Support OLE Automation</P>
OLE Automation is a technology that lets software packages expose their unique features to scripting tools and other applications. OLE Automation uses the OLE Component Object Model (COM).  Using OLE Automation, you can:</P>
<SPAN CLASS="list"><UL><LI>Create applications and programming tools that expose objects.</LI><LI>Create and manipulate objects exposed in one application from another application.</LI><LI>Create tools that access and manipulate objects. These tools can include embedded macro languages, external programming tools, object browsers, and compilers.</LI></UL></SPAN>The objects an application or programming tool exposes are called OLE Automation objects.  Applications and programming tools that access those objects are called OLE Automation controllers.  Applications and other software packages define and expose objects, which can be acted upon by OLE Automation controllers.  Type information describes the exposed objects, and can be used by OLE Automation controllers at either compile time or run time.</P>
OLE Automation controllers can access objects in three ways:</P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="232pt" VALIGN="TOP"><COL WIDTH="232pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP">use the IDispatch interface</P></TD><TD VALIGN="TOP">for compatibility with existing OLE Automation controllers who access objects only through IDispatch.</P></TD></TR><TR><TD VALIGN="TOP">use virtual function table (VTBL) binding</P></TD><TD VALIGN="TOP">faster than both ID binding and late binding because access is direct; no calls are made through IDispatch.</P></TD></TR><TR><TD VALIGN="TOP">use dual interfaces (combination of IDispatch and VTBL binding)</P></TD><TD VALIGN="TOP">Binding can take place at compile time through the VTBL interface, or at run time through IDispatch.</P></TD></TR><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">OLE Automation controllers that can use the VTBL interface may benefit from improved performance.</P></TD></TR><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">Existing OLE Automation controllers that use the IDispatch interface will continue to work.</P></TD></TR><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">The VTBL interface is easier to call from C++.</P></TD></TR><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">Dual interfaces are required for compatibility with the Visual Basic&reg; programming system object support features.</P></TD></TR></TBODY></TABLE>
<BR></P>In order to expose objects within your application as OLE Automation objects you need to consider doing the following:</P>
Use UUIDGEN (in the Win32 SDK) to generate class ids (CLSID) for your class and interface ids (IID) for your interfaces.</P>
Initialize OLE, use CoInitialize</P>
Register the class factories of your exposed objects, use CoRegisterClassObject</P>
Register the active object, use RegisterActiveObject</P>
Implement your exposed objects, implement IClassFactory, IUnknown, IDispatch, any other methods</P>
Implement methods and properties</P>
Revoke the class factories and your object, use RevokeActiveObject</P>
Uninitialize OLE, use CoUninitialize</P>
Create an object description (.ODL) file that describes the properties and methods of the exposed objects, and use MkTypLib to compile the .ODL file into a type library.</P>
Create a registration (.REG) file for your application.</P>
<I>For more information on OLE Automation see the Win32 SDK/OLE/OLE Automation or the OLE Automation Programmer's Reference by Microsoft Press.</I></P>
*Support Remote Administration</P>
Supporting remote administration allows for single seat administration of multiple servers within an enterprise.  Even though servers within an organization may be spread throughout the world it is possible to architect applications to administer remote services running on remote servers.  In order to create server applications which can be administrated remotely you should consider the following:</P>
Utilize the registry to store configuration parameters.  This way you can use tools such as regedt32.exe from a remote location to configure a server.</P>
Use event logging to audit actions, failures, errors, etc.  This way you can use the Event Viewer from a remote machine to view the local machine's event log.</P>
Create a separate UI client portion which communicates to a server portion via RPC.</P>
Support delayed connections.  When applications must communicate over a network take into consideration that the communication might occur over slow WAN links.  For example, using Server Manager for Windows NT Server you can initiate Low Speed Connections so that the client application isn't bottlenecked by enumerating all the servers and workstations in a particular domain.  An application may decide to offload time consuming functions to the server side and have a service perform these functions and return the data to the client.  Also batched requests may be another consideration.</P>
*Supporting Long Filenames and the Universal Naming Convention</P>
<I>Long Filenames</I></P>
Windows NT and Windows 95 now offer the use of long filenames.  These filenames go beyond the old restriction of 8.3 filename length.</P>
To determine which file system your application is currently running under, an application makes a call to the GetVolumeInformation function. This function returns information about the current volume, such as the maximum length of filenames. Once you have called this function, you can use the value returned as the maximum file length within your application and dynamically allocate a buffer for your filenames and for paths. This is preferable to using static buffers for filenames and paths.</P>
The following are general guidelines that apply to all file systems supported within the Windows operating system.  An application that follows these guidelines can create valid names for files and directories regardless of the file system in use.</P>
<SPAN CLASS="list"><UL><LI>Use any character in the current code page for a name, but not a path separator, a character in the range 0 through 31, or any character disallowed by the file system.  A name can contain characters in the extended character set (128–255).</LI><LI>Use the backslash (\) and/or the forward slash (/) to separate components in a path.</LI><LI>Use a period (.) as a directory component in a path to represent the current directory.</LI><LI>Uuse two consecutive periods (..) as a directory component in a path to represent the parent of the current directory.</LI><LI>Use a period (.) to separate components in a directory name or filename.</LI><LI>Do not use the following characters in directory names or filenames, because they are reserved for Windows: &lt; &gt; : " / \ |</LI><LI>Do not use reserved words, such as aux, con, and prn, as filenames or directory names.</LI><LI>pProcess a path as a null-terminated string. The maximum length for a path is given by MAX_PATH.  The Unicode versions of the CreateDirectory, FindFirstFile, GetFileAttributes, and SetFileAttributes functions allow paths to exceed the MAX_PATH length if the path has the \\?\ or \\?\UNC\ prefix.  These prefixes turn off path parsing.  Use the \\?\ prefix with paths for local storage devices and the \\?\UNC\ prefix with paths having the Universal Naming Convention (UNC) format.  An example of a UNC path is \\machine\sharename.</LI><LI>Do not assume case sensitivity, because not all file systems distinguish between case.</LI></UL></SPAN><I>Universal Naming Convention</I></P>
Supporting Universal Naming Convention (UNC) paths when dealing with file names is another way for an application to work seamlessly in a network environment. UNC paths allow logical connections to network devices without the need to specifically reference a network drive letter. The system will be able to locate the network server and path with the UNC name even over a modem connection. The Universal Naming Convention is a naming convention for describing network servers and share points on those servers. UNC names start with two backslashes followed by the server name. All other fields in the name are separated by a single backslash. A typical UNC name would appear as:</P>
\\server\share\subdirectory\filename </P>
Not all of the components of the UNC name need to be present with each command; only the share component is required. For example, dir \\server\share can be used to obtain a directory listing of the root of the specified share.</P>
</P>
Integrating with Microsoft Exchange Server</P>
Messaging Client-Server and Groupware Applications</P>
Server applications extend the basic functionality of Microsoft Exchange Server. They can be used to provide a broad range of services, from mail gateways and voicemail to document management, content indexing, and electronic newspapers.  Server applications communicate with Microsoft Exchange Server components through MAPI. This communication includes actions such as using the address book, accessing information stores (including public folders), and transferring messages. Functions are provided for communicating with Microsoft Exchange Server. Some of these functions extend MAPI functionality, some enhance debugging capabilities, and others add completely new functionality.  Most server applications are either mailbox agents or gateways. As such, a server application is represented in the Microsoft Exchange Server directory as either a Mailbox-Agent or a Mailbox-Gateway object. One way the application can modify its own directory object, as well as the directory objects of recipients or other applications, is by integration with the Microsoft Exchange Server Administrator Program.</P>
A server application that has its own mailbox within Microsoft Exchange Server is a mailbox agent. A typical mailbox agent uses its mailbox to communicate with mail users, gather processing requests, and distribute results.  A server application can use mailboxes in three ways:</P>
<SPAN CLASS="list"><UL><LI>Its Own Mailbox  Most server applications are either mailbox agents or gateways, which have their own mailboxes in information stores on Microsoft Exchange Server.</LI><LI>Other Mailboxes  Two ways server applications can use mailboxes other than their own are delegate access and privileged access.</LI><LI>No mailbox  In the current Beta 2 release of Microsoft Exchange Server, every directory object also has a mailbox. If an application does not need a mailbox, it can disable the mailbox by making it invisible to the Microsoft Exchange Address Book provider and by setting the allowed content length of the mailbox to zero. In future Microsoft Exchange Server beta releases, an application can be configured to have no mailbox at all.</LI></UL></SPAN>A gateway is an interface that connects electronic messaging systems that have different message and address formats. In its simplest form, it receives a mail message, translates it from one messaging system's format to another, maps addresses between the two systems, then delivers the translated message. The benefit to users is that messages transferred by the gateway appear to come directly from the originating mail system. A gateway can translate messages between mail systems within a single organization or between an organization and an outside mail system.</P>
A Microsoft Exchange Server gateway is a client application of the Messaging Application Programming Interface (MAPI). This means that it uses MAPI interfaces, methods, and properties to communicate with Microsoft Exchange Server. A gateway is also a server application for Microsoft Exchange Server; as such, it should be implemented as a service of Microsoft Windows NT Server. A gateway should be integrated with:</P>
<SPAN CLASS="list"><UL><LI>MAPI</LI><LI>Windows NT Server</LI><LI>Microsoft Exchange Administrator</LI></UL></SPAN>Integrating with SQL Serverä</P>
Use Open Data Services</P>
Microsoft Open Data Services (ODS) provides a server-based application programming interface (API). The API consists of C functions and macros used for creating two types of server applications: applications that are initialized as Open Data Services servers and that support user connections and user queries, and applications called extended stored procedures that are added directly to SQL Server and accessed by making procedure calls to SQL Server. Applications created with Open Data Services can interact with SQL Server database clients, with SQL Server database servers, and with any other elements of a network environment that you define.</P>
</P>
This interaction allows you to create powerful applications that can:</P>
<SPAN CLASS="list"><UL><LI>Provide extensions to SQL Server by integrating features from your network environment whenever certain events occur within SQL Server.  For example, you can create extension functions that take specific actions based on updates to SQL Server tables, launch programs that are external to SQL Server, or exchange data with an application external to SQL Server. You can even make these functions transparent to SQL Server users.</LI><LI>Provide gateways to non - SQL Server database environments.  Open Data Services server applications can connect to relational databases to perform general-purpose data access, or to non-relational data sources to perform application-specific tasks.</LI></UL></SPAN>Integrating with the Internet Information Server</P>
Using the Internet Server API (ISAPI)</P>
ISAPI for Windows NT can be used to write applications that Web users can activate by filling out an HTML form or clicking a link in an HTML page on your Web server. The remote application can then take the user-supplied information and do almost anything with it that can be programmed, and then return the results in an HTML page or post the information in a database.</P>
ISAPI can be used to create applications that run as DLLs on your Web server. If you have used Common Gateway Interface (CGI) scripts before, you will find that the ISAPI applications have much better performance because your applications are loaded into memory at server run-time. They require less overhead because each request does not start a separate process.  A client uses ISAPI extensions just like executing CGI applications, but instead of than referencing them as "<I>http://scripts/cgi.exe?Param1+Param2</I>", a client would use "<I>http://scripts/isapi.dll?Param1+Param2</I>".  Because ISAPI applications and filters are implemented as DLLs they are inherently single process and can support thread pooling whereby the Internet Information Server will call out to the extension DLL.  DLLs are also require much less overhead for instantiation compared to a process.  Also function calls are direct and involve no process transition or intermediate steps.  Multiple extension DLLs can be loaded and called simultaneously.  ISAPI extension DLLs are essentially "in-process" CGI applications.</P>
Creating ISAPI extensions involve the following:</P>
<SPAN CLASS="list"><OL><LI>Export and implement GetExtensionVersion.  This provides the initial entry point from the IIS into your extension and is used to provide the version and description of your extension.</LI><LI>Export and implement HttpExtensionProc.  This is the main entry point into functionality for your extension.  It is equivalent to main() in a CGI application.  It is called once per request and called be called simultaneously from multiple threads.  For this reason your extension DLL must be thread safe.</LI><LI>Utilize the EXTENSION_CONTROL_BLOCK data structure.  The ECB contains data about the client request  as well as providing four callback functions which your extension can use.  These callback functions are as follows:
ReadClient is used to obtain data from the client's HTTP request.</P>

WriteClient is used to send data to the HTTP client from a buffer.</P>

GetServerVariable is used to obtain information about the client connection or the server itself.</P>

ServerSupportFunction provides some general purpose functions as well as HTTP Server specific functions.  The basic functions include client URL redirection, sending another URLs data back, and sending back detailed header information.</P></LI></OL></SPAN>ISAPI extensions can also be combined with the Internet Database Connector to create highly interactive sites.</P>
Another feature of ISAPI allows pre-processing of requests and post-processing of responses, permitting site-specific handling of HyperText Transport Protocol (HTTP) requests and responses.  ISAPI filters can be used for applications such as customized authentication, access, compression, encryption, logging or client request analysis.</P>
Creating ISAPI filters involve the following:</P>
<SPAN CLASS="list"><OL><LI>Export and implement GetFilterVersion.  GetFilterVersion gets called with a HTTP_FILTER_VERSION structure which your filter must fill in with version information, events which your filter requests, and the priority level.  ISAPI filters should register only required events since extraneous events can have a significant impact on the performance and scalability of the server.  The priority level is used to assign a call order for you filter with respect to other filters for the same events.  </LI><LI>Export and implement HttpFilterProc.  This represents the main entry point into the filter.  Your filter will typically switch on the notification type.  For notification specific functionality there are several other data structures which allow you to process raw data, pre-process headers, perform authentication, obtain URL maps and perform logging.</LI><LI>Use the HTTP_FILTER_CONTEXT structure which contains context information associated with the HTTP request.  Also contained in the HTTP_FILTER_CONTEXT structure are callback functions.  These callback functions are as follows:
GetServerVariable is used to obtain information about the client connection or the server itself.</P>

ServerSupportFunction provides some general purpose functions as well as HTTP Server specific functions.  The basic functions include  . . . </P>

AddResponseHeaders is used to supply extra header information in response to HTTP requests.</P>

WriteClient is used to send data to the HTTP client from a buffer.</P>

AllocMem is a function used to allocate memory upon request completion all memory allocated with this function is automatically freed.</P></LI></OL></SPAN>Register the filter under HKEY_LOCAL_MACHINE\ System\ CurrentControlSet\ Services\ W3Svc\ Parameters\ Filter DLLs.  This value is a comma-separated list and your filter should be added to the end of the list.</P>
Creating Client Applications for Microsoft BackOffice</P>
In order to develop client applications which communicate with a component in the Microsoft BackOffice suite you should take advantage of the rich set of functionality exposed by APIs specific to each component.  If you are developing your own client/server components then you may choose to expose APIs that expose functionality in the same manner as the BackOffice components.  Methods can range from using one of the interprocess communication methods mentioned above.  The following sections describe the APIs associated with each Microsoft BackOffice component and the functionality which it provides.</P>
SNA Client</P>
Use WOSA APIs (WinAPPC, WinCPI-C, WinRUI, WinSLI) or use FMI</P>
In order to provide one common set of APIs to port applications from various operating systems to Windows NT and Windows version 3.X, a Windows SNA specificationstandard was created. As a direct result of this work, the Windows APPC, Windows CPI-C and Windows LUA specificationsstandards were developed.  All of the Windows SNA specificationsstandards have provided a set of extensions that allow for asynchronous communication.  Asynchronous call completion returns the initial call immediately so the application can continue with other processes. A program that issues a call and does not regain control until the operation completes is not able to perform any other operations. This type of operation, referred to as blocking, is not suited to a server application designed to handle multiple requests from many clients.</P>
Programs written to use Windows APPC can exchange data with programs written to use other implementations of APPC that adhere to the SNA LU 6.2 architecture.  Windows APPC adds to this functionality by providing a set of extensions for asynchronous communication in addition to the full complement of APPC features.</P>
Windows CPI-C is compliant with CPI-C version 1.2 which allows applications developed using the CPI-C Systems Application Architecture API to establish a conversation in order to exchange data and control information flow between two programs.  Support for automatic parameter conversion, communicating with non-CPI-C program, local/remote transparency as well as X/Open CPI-C support for nonblocking calls, the ability to accept multiple conversations, support for data conversion (beyond parameters) and support for security parameters.  Windows CPI-C further adds to this functionality by providing a set of extensions for asynchronous communication in addition to the full complement of supported features in CPI-C version 1.2 (with the exception of resource recovery).</P>
The conventional Logical Unit Application programming interface (LUA) is an application programming interface (API) that allows you to write LUA applications to communicate with host applications.  The Windows LUA interface is provided at the request/response unit (RU) and session levels, allowing programmable control over the Systems Network Architecture (SNA) messages sent between your communications software and the host. It can be used to communicate with any of the logical unit (LU) types 0, 1, 2, or 3 at the host; it is up to the application to send the appropriate SNA messages as required by the host.  For example, you can use LUA to write a 3270 emulation program that communicates with a host 3270 application.  By design, LUA is asynchronous and uses semaphores for notification messages. While semaphores work extremely well for the Windows NT and OS/2&reg; operating systems, the Windows enhancements built into Windows LUA also allows for asynchronous support for Windows version 3.x applications in the LUA interface. Windows LUA provides the following entry-points for both RUI and SLI verbs:  RUI, SLI, WinRUI, and WinSLI. WinRUI and WinSLI provide asynchronous message notification for all Windows-based RUI and SLI verbs while RUI and SLI provide support for event notification. Applications based on Windows version 3.X use WinRUI and WinSLI for asynchronous message notification.</P>
APPC is an application programming interface (API) that allows peer-to-peer communications in a Systems Network Architecture (SNA) environment. By using APPC, programs distributed across a network can work together-communicating with each other and exchanging data-to accomplish a single processing task. A processing task can query a remote database, copy a remote file, send or receive electronic mail, and so on.</P>
</P>
In order to provide one common API to port applications from various operating systems to Windows NT and Windows version 3.x, a Windows SNA standard was created. As a direct result of this work, Windows APPC was developed.</P>
Programs written to use this implementation of APPC can exchange data with programs written to use other implementations of APPC that adhere to the SNA LU 6.2 architecture.</P>
</P>
Asynchronous call completion returns the initial call immediately so the application can continue with other processes. A program that issues a call and does not regain control until the operation completes is not able to perform any other operations. This type of operation, referred to as blocking, is not suited to a server application designed to handle multiple requests from many clients.</P>
SNA Server uses the RegisterWindowsMessage for asynchronous support. With "WinAsyncAPPC" as the input string, you pass a Windows handle by which you will be notified of verb completion. You then issue your verb, and once it completes, a message is posted to the Windows handle that you passed, notifying you that the verb is complete.</P>
With the exception of asynchronous RECEIVE_AND_WAIT and RECEIVE_AND_POST, which can issue certain other verbs while pending, a conversation can have only one incomplete operation at any time.</P>
</P>
CPI-C is a Systems Application Architecture (SAA) adherent application programming interface (API) that allows peer-to-peer communications among programs in a Systems Network Architecture (SNA) environment. (An API is a facility that provides information and services to programs.)</P>
Through CPI-C, programs distributed across a network can work together - communicating with each other and exchanging data - to accomplish a single processing task, such as querying a remote database, copying a remote file, or sending or receiving electronic mail.</P>
These programs communicate as peers, on an equal (rather than hierarchical) basis. Together, programs distributed across a local or wide area network perform distributed processing.</P>
In order to provide one common API to port applications from various operating environments to Windows NT and Windows version 3.x, a Windows SNA standard was created. As a direct result of this work, Windows CPI-C was developed. The CPI-C calls and information presented in this guide represent an evolving Windows CPI-C that is composed of CPI-C version 1.2 and a set of Windows extensions that allow for multiple applications and asynchronous call completion.</P>
CPI-C version 1.0 was first introduced to provide a means by which two applications could speak and listen to each other; in other words, to have a conversation. A conversation is the logical connection between two programs that allows the program to communicate with each other. Programs using CPI-C converse with each other by making program calls. These calls are used to establish the full characteristics of the conversation, to exchange data, and to control the information flow between the two programs.</P>
CPI-C version 1.1 was extended to include four new areas of function: support for resource recovery (not supported in Windows CPI-C), automatic parameter conversion, support for communicating with non - CPI-C programs, and local/remote transparency. Built upon CPI-C version 1.1, X/Open CPI-C provided support for nonblocking calls, the ability to accept multiple conversations, support for data conversion (beyond parameters), and support for security parameters.</P>
CPI-C version 1.2 consolidated CPI-C version 1.1 and X/Open CPI-C by providing function in all the areas described above. Windows CPI-C further adds to this functionality by providing a set of extensions for asynchronous communication in addition to the full complement of supported features in CPI-C version 1.2 (with the exception of resource recovery).</P>
Asynchronous call completion returns the initial call immediately so the application can continue with other processes. A program that issues a call and does not regain control until the operation completes is not able to perform any other operations. This type of operation, referred to as blocking, is not suited to a server application designed to handle multiple requests from many clients. In particular, Windows CPI-C support related to asynchronous communications includes the following calls and extensions:</P>
Set_Processing_Mode</P>
Specify_Windows_Handle</P>
Wait_For_Conversation</P>
WinCPICSetBlockingHook</P>
WinCPICIsBlocking</P>
WinCPICUnhookBlockingHook</P>
</P>
Asynchronous support is appended to the Set_Processing_Mode call and allows you to be notified of call completion on a Windows handle. Through RegisterWindowsMessage with "WinAsyncCPIC" as the string, you pass a Windows handle by which you are notified of call completion. You then make your call, and once it completes, a message is posted to the Windows handle that you passed, notifying you that the call is complete.</P>
With the exception of an asynchronous Receive call that can issue certain other calls while pending, a conversation can have only one incomplete operation at any time. For more information on using an asynchronous Receive call, see "Using Asynchronous Call Completion" later in this chapter. In the case of an incomplete operation, the program can issue Wait_For_Conversation to test for its completion or Cancel_Conversation to end the conversation and the incomplete operation.</P>
The only Windows extensions required for Windows CPI-C are for initialization (WinCPICStartup) and termination (WinCPICleanup) purposes. Depending on your application, other Windows extensions may be useful to you, but they are not required.</P>
</P>
The conventional Logical Unit Application programming interface (LUA) is an application programming interface (API) that allows you to write LUA applications to communicate with host applications.</P>
The interface is provided at the request/response unit (RU) and session levels, allowing programmable control over the Systems Network Architecture (SNA) messages sent between your communications software and the host. It can be used to communicate with any of the logical unit (LU) types 0, 1, 2, or 3 at the host; it is up to the application to send the appropriate SNA messages as required by the host.</P>
For example, you can use LUA to write a 3270 emulation program that communicates with a host 3270 application.</P>
In order to provide one common API to port applications from various operating environments to Windows NT and Windows version 3.x, a Windows SNA standard was created. As a direct result of this work, Windows LUA was developed. The LUA verbs (both Request Unit Interface [RUI] and Session Level Interface [SLI]), routines, and information presented in this guide represent an evolving Windows LUA that is based on IBM ES for OS/2 version 1.0 and includes a set of Windows enhancements.</P>
Asynchronous verb completion returns the initial verb immediately so the application can continue with other processes. A program that issues a verb and does not regain control until the operation completes is not able to perform any other operations. This type of operation, referred to as blocking, is not suited to a server application designed to handle multiple requests from many clients. </P>
By design, LUA is asynchronous and uses semaphores for notification messages. While semaphores work extremely well for the Windows NT and OS/2 systems, the Windows enhancements built into Windows LUA also allows for asynchronous support for Windows version 3.x applications in the LUA interface. Windows LUA provides the following entry-points for both RUI and SLI verbs:  RUI, SLI, WinRUI, and WinSLI. WinRUI and WinSLI provide asynchronous message notification for all Windows-based RUI and SLI verbs while RUI and SLI provide support for event notification. Windows version 3.x applications use WinRUI and WinSLI for asynchronous message notification.</P>
Asynchronous support allows you to be notified of verb completion on a Windows handle. Through RegisterWindowsMessage with "WinRUI" or "WinSLI" as the string, you pass a Windows handle by which you are notified of verb completion. You then make your call and once it completes, a message is posted to the Windows handle that you passed, notifying you that the verb is complete.</P>
The only Windows extensions required for Windows LUA are for initialization (WinRUIStartup or WinSLIStartup) and termination (WinRUICleanup or WinSLICleanup) purposes. Depending on your application, other Windows extension may be useful to you, but they are not required.</P>
The Function Management Interface provides applications with direct access to SNA data flows and information about SNA control flows by means of status messages, while shielding them from the full complexities of SNA protocol handling. It is particularly suited to the requirements of applications emulating 3270-type controllers.  The FMI is defined in terms of the messages that are sent across the interface. Note that this is logically distinct from the definition of the DL-BASE/DMOD interface, which defines the mechanism for sending messages between two components in SNA Server (for example between the local node and the 3270 emulator).  The FMI is used by LU types 0, 1, 2, and 3, but not by LU type 6.2. It provides access to the SSCP-LU session as well as the main PLU-SLU session (see section 3.1.1 below for more information on these sessions). An application can use the FMI to access multiple sessions, and hence multiple LUs, simultaneously.  The 3270 emulator on the client communicates over the LAN with the local node on the server machine by exchanging messages. The content and format of the messages is defined by the FMI.</P>
</P>
<I>For detailed information about each API set see the BackOffice SDK SNA book.</I></P>
Use SNA Server client APIs (support SNA Server user record)</P>
Vendors who want to create applications which integrate a 3270 emulator with SNA Server should utilize the 3270 Emulator Interfaces Specification.  This specification defines the initialization, message passing and termination procedures required for 3270 emulator and SNA Server communication. </P>
<I>See the BackOffice SDK Microsoft SNA Server/3270 Interface Emulator Specification for more information.</I></P>
Use SNA Server compatibility APIs for IBMâ PC Support or Client Access/400</P>
SNA Server 2.11 adds support for the EHNAPPC application programming interface (API) which is the Windows-based APPC API supported by IBM's PC Support and Client Access/400 (CA/400) products. IBM has presented EHNAPPC API to its independent software vendor (ISV) community as the way to write Windows-based applications that integrate with the AS/400&reg;. There are estimated to be more than 60 applications that utilize this API as a way to connect to the AS/400&reg; data and applications. These ISV applications will work unchanged with SNA Server 2.11.</P>
<I>For additional information about the EHNAPPC API, see "IBM AS/400, Client Access/400 for Windows 3.1, API and Technical Reference, Version 3" (SC413531-00).</I></P>
Use ODBC/DRDA Drivers to access Host Data</P>
Many applications use the Open Database Connectivity (ODBC) programming interface to access local and server-based databases, while distributed databases on IBM hosts are usually managed through the Distributed Relational Database Architecture (DRDA) protocol defined by IBM.</P>
SNA Server version 2.11 includes the StarSQL ODBC/DRDA drivers for Windows-based and Windows NT-based clients. With these drivers, applications designed to use the ODBC interface and Structured Query Language (SQL) can access databases located on IBM hosts that use the DRDA protocol to manage distributed data, without requiring a host-based database gateway. These drivers allow ODBC-enabled applications (such as Microsoft&reg; Excel and Microsoft&reg; Access) to query, create, delete, and update tables in the following host databases:</P>
<SPAN CLASS="list"><UL><LI>DB2&reg; for MVS</LI><LI>SQL/DS&trade; for VM and VSE</LI><LI>DB2/400 for OS/400&reg;</LI></UL></SPAN>Use AFTP for File Transfer</P>
The APPC File Transfer Protocol (AFTP) application programming interface (API) is a set of C routines that provides APPC file transfer capabilities. This API makes file transfer programming easier by allowing you to access routines that will interact with any AFTP server. </P>
APIs are provided for creating or destroying an AFTP connection object, establishing a connection to the AFTP server, querying connection characteristics, transferring files, specifying file transfer characteristics, querying file transfer characteristics, listing files on the AFTP server, listing files on the AFTP client, performing directory manipulation, performing file manipulation, querying system information, generating message strings, and controlling trace information.</P>
Messaging Client</P>
Use MAPI for send and post OR use OLE/Messaging and/or OLE/Scheduling</P>
The Messaging Application Programming Interface (MAPI) is a messaging architecture that enables multiple applications to interact with multiple messaging systems seamlessly across a variety of hardware platforms.  The interfaces are used to create and access diverse messaging applications and messaging systems, offering a uniform yet separate environment for development and use and providing true independence for both.  MAPI client applications are divided into three categories: </P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="232pt" VALIGN="TOP"><COL WIDTH="232pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP">Messaging-aware applications</P></TD><TD VALIGN="TOP">A messaging-aware application does not require the services of a messaging system, but includes messaging options as an additional feature. For example, a word processing application can add a "Send" command to its File menu, enabling the user to send a document to another user.</P></TD></TR><TR><TD VALIGN="TOP">Messaging-enabled applications</P></TD><TD VALIGN="TOP">A messaging-enabled application requires the services of a messaging system and typically runs on a network or an on-line service. An example of a messaging-enabled application is Microsoft Mail.</P></TD></TR><TR><TD VALIGN="TOP">Messaging-based workgroup applications</P></TD><TD VALIGN="TOP">A more advanced client application is the messaging-based workgroup, or workflow, application.  The workgroup application requires full access to a wide range of messaging system services, including storage, addressing, and transport services. These applications are designed to operate over a network without users having to manage the applications' network interaction. Examples of such applications include work flow automation programs and bulletin board services.</P></TD></TR></TBODY></TABLE>
<BR></P></P>
MAPI supports each of these types of client applications by providing in its subsystem different levels of programming interfaces.  This multi-level programming interface is described in the following section. </P>
Most client applications will use one client API - either OLE Messaging, Simple MAPI, CMC or Extended MAPI. However, some clients will want to take advantage of what more than one client API has to offer. These clients will want to use Extended MAPI for some tasks and a simpler API for others. The MAPI architecture allows client applications to do this fairly easily by providing several API functions for converting between the environments.</P>
</P>
For instance to send a message you need to consider doing the following:</P>
<SPAN CLASS="list"><UL><LI>Create a <I>MapiMessage</I> structure to contain the message.</LI><LI>Create one or more <I>MapiRecipDesc</I> structures describing the recipients of the message.</LI><LI>Create a text string containing the subject.</LI><LI>Create a text string containing the message text.</LI><LI>Create an array of <I>MapiFileDesc</I> structures, if necessary, to contain any attachments.</LI><LI>Submit the message with the <I>MAPISendMail</I> function.</LI></UL></SPAN>Posting messages and documents to folders (as opposed to sending messages) is a common action performed by client applications. For example, a client application may post information to a public folder so that its associated server application can read the information. To post information, the application uses standard MAPI techniques and follows this sequence shown below.</P>
To post information to a folder</P>
<SPAN CLASS="list"><UL><LI>Start a MAPI session.</LI><LI>Open a public information store and obtain an <I>IMAPIFolder</I> interface.</LI><LI>Open a folder object within the public information store.</LI><LI>Create a message in the folder object. Upon creation, the message exists in memory.</LI><LI>Set relevant properties on the message.</LI><LI>Use <I>SaveChanges</I> to save the message and its properties to disk.</LI></UL></SPAN><I>For information pertaining to MAPI see the Win32 SDK Win32 Extensions/Messaging Application Programming Interface (MAPI).  For information regarding integration with Microsoft Exchange Server see the BackOffice SDK Microsoft Exchange Server.</I></P>
The Microsoft OLE Messaging Library exposes messaging objects for use by tools supporting OLE automation, such as those applications created in the Microsoft Visual Basic&reg; programming system and the Microsoft Visual C++&reg; development system applications.  The messaging library lets you quickly and easily add to your Visual Basic application the ability to send and receive mail messages and to interact with folders and address books. You can create programmable messaging objects, then use their properties and methods to meet the needs of your application.  When you combine messaging objects with other programmable objects exposed by Microsoft Access, Microsoft Excel, and Microsoft Word, you can build custom applications that, for example, would allow your users to extract information from a database, copy it to a spreadsheet for analysis, then create a report and mail the report to several people.  With these powerful building blocks, you can quickly build custom applications that cover your entire line-of-business needs.  The Microsoft OLE Messaging Library does not represent a new messaging model but rather an additional interface to the Microsoft Messaging API (MAPI) model.</P>
<I>For more information about OLE Messaging see the Win32 SDK under \mstools\samples\mapi\olemsg\olemsg.hlp.</I></P>
OLE Scheduling defines programmable objects that can be used to extend the capabilities of Schedule+.  OLE Scheduling is based on the capabilities of OLE Automation. OLE Automation enables you to create instances of programmable scheduling objects. Once you've created the new objects, you can reference them with tools that support OLE Automation, such as Microsoft Visual Basic and Microsoft Visual C++.</P>
<I>For additional information regarding OLE Scheduling see the BackOffice SDK Microsoft Exchange Server/Microsoft Schedule+ Programmer's Guide.</I></P>
Public Folders</P>
For most purposes, applications access public folders the same way they access private folders in private mailboxes - through MAPI. Subject to access restrictions, an application can browse the folders and items in the public store, read items, delete items, modify items, search for items, and create new public folders in the public folder hierarchy. All this is done using MAPI interfaces.</P>
Public folders are distinguished by several unique characteristics. Users can send messages to them because they are addressable objects. They include a property that allows administrators or programmers to control access to their contents. They have an additional property that specifies one or more rules that execute when certain message events occur. Furthermore, each public folder in the information store has a corresponding object in the Microsoft Exchange Server directory.</P>
To develop applications for public folders, you will use one or more of the following interfaces:</P>
<SPAN CLASS="list"><UL><LI>MAPI  Enables you to directly manipulate public folders, their properties, and their contents in the information store. </LI><LI>Microsoft Exchange Server directory access functions  Enables you to control folder objects in the Microsoft Exchange Server directory. The directory stores all administrative properties associated with public folders, including replication schedule and MDB space quota.</LI><LI>Microsoft Exchange Server SDK public folder functions  These functions facilitate access to Microsoft Exchange Server-specific public folder properties, such as access control lists (ACLs) and rules.</LI></UL></SPAN><I>For more information about programming with folders using MAPI, see the MAPI Programmer's Guide and the MAPI Programmer's Reference. For more information about the Microsoft Exchange Server directory access functions, see Directory Operations.</I></P>
Using Custom Forms for Applications</P>
Custom forms are an important part of many applications that run in the Microsoft Exchange Server environment. When you develop forms-based applications for Microsoft Exchange Server, you'll use the MAPI forms interfaces. These interfaces give you the ability to define custom forms, install them in forms registries, and supply them to Microsoft Exchange Server users.</P>
Any MAPI-compliant forms application can run in the Microsoft Exchange Server environment. However, two considerations must be kept in mind when developing forms-based applications in a Microsoft Exchange Server environment:</P>
<SPAN CLASS="list"><UL><LI>Microsoft Exchange Server includes an organization forms registry whose purpose is to store forms for the entire organization. This registry may affect how forms are initially installed. </LI><LI>Microsoft Exchange Server has a conflict-resolution capability that affects how messages and forms are handled when multiple versions of the same message have been created by different users.</LI></UL></SPAN>In MAPI, a forms registry is any storage area where you can install and access forms definitions. Microsoft Exchange Server builds upon and extends the MAPI forms model. It provides a special forms registry called the organization forms registry that can be used as a master forms repository for the entire organization. The main advantage of the organization forms registry is that it can be accessed from anywhere in the organization (subject to access rights). The organization forms registry resides in the public store as a hidden folder and is replicated throughout the organization to facilitate access to forms.</P>
*Extending the Microsoft Exchange Client</P>
The basic Microsoft Exchange Client is included in the Windows 95 operating system as the core mail client in the system. When drivers are loaded that set up the Windows 95 client to communicate with a Microsoft Exchange Server system, functionality specific to Microsoft Exchange Server clients is added to the Microsoft Exchange Client by making use of the client's extensibility interfaces. </P>
Using client extensions to expose application-specific functionality is usually appropriate when one or more of the following conditions is satisfied:</P>
<SPAN CLASS="list"><UL><LI>The application adds to the core capabilities of Microsoft Exchange Server, rather than using Microsoft Exchange Server as a mechanism to deliver completely separate functionality.</LI><LI>The new features are used in the context of a particular message or folder in the Microsoft Exchange Server store.</LI><LI>The new functionality exposes a method for the user to configure a back-end server service used in the Microsoft Exchange Server environment.</LI></UL></SPAN>SQL Server Client</P>
Use ODBC, DB-Libraryä, or Embedded SQLä</P>
Developers can write applications for SQL Server by programming with DB-Library for C, the C-language version of the communication library for SQL Server or with DB-Library for Visual Basic, the Visual Basic version of the communication library for SQL Server.  DB-Library for C is an application programming interface (API) that consists of C functions and macros that allow an application to interact with SQL Server. Included are functions that send Transact-SQL&reg; statements to SQL Server and functions that process the results of those statements. Other functions handle errors and convert data.</P>
DB-Library for C offers a rich set of functions for:</P>
<SPAN CLASS="list"><UL><LI>Opening connections.</LI><LI>Formatting queries.</LI><LI>Sending query batches to the server and retrieving the resulting data.</LI><LI>Using scrollable cursors.</LI><LI>Bulk-copying data from files or program variables to and from the server.</LI><LI>Controlling two-phase commit operations between several participating servers running SQL Server.</LI><LI>Executing stored procedures or remote stored procedures.</LI></UL></SPAN><I>Information about DB-Library can be found in the BackOffice SDK, Microsoft SQL Server Programmer's Toolkit.</I></P>
These functions allow the application developer extremely fine-grained control of data flow back and forth between the client and the server. DB-Library supports multiple environments. C programmers can choose from among:</P>
A multithreaded dynamic-link library (DLL) for the Windows NT operating system</P>
Medium and large model static-link libraries for MS-DOS for both Microsoft and Borland&reg; compilers</P>
A DLL for the Windows operating system</P>
</P>
  In addition to DB-Library, SQL Server supports the Microsoft Open Database Connectivity (ODBC) call-level API. ODBC enables applications for Windows, Windows NT, and Windows 95 to access multiple data sources, including a wide range of relational databases and local indexed sequential access method (ISAM) data. In most cases, DB-Library and ODBC are equally capable of creating SQL Server client applications. ODBC enables applications to access more data sources. DB-Library provides equivalent functionality in multiple client environments, including the MS-DOS&reg; operating system. In addition, DB-Library provides specialized support for SQL Server, such as bulk copy, two-phase commit, and text operations.</P>
<I>Information about ODBC can be found on MSDN Product Documentation/SDKs/Open Database Connectivity (ODBC) SDK 2.10.</I></P>
</P>
Embedded SQL allows programmers to place SQL statements into programs written in a standard programming language, which is termed the host language. SQL statements are delimited with specific starting and ending statements defined by the host language. The resulting program contains source code from two languages — SQL and the host language.  When compiling a program with embedded SQL statements, a precompiler translates the SQL statements into equivalent host language source code. After precompiling, the host language compiler compiles the resulting source code.  The Embedded SQL approach, using programming statements similar to Transact-SQL, is more concise than the function-call approach and is tightly coupled to the existing database structure.  Because the SQL statements are directly included in the source code, Embedded SQL programs are usually special-purpose applications.  Embedded SQL is well suited for environments where the programmer is also in control of the database structure.  However, it is less flexible for environments where the database structure is changing or is not known in advance.</P>
<I>For more information about Embedded SQL see MSDN Product Documentation/SDKs/Embedded SQL for C 4.22.</I></P>
Use Stored Procedures, Triggers and Cursors</P>
<I>Stored Procedures</I></P>
You can refine your applications by using stored procedures, compiled collections of SQL statements and control-of-flow language that execute very quickly. For example, you can use stored procedures called triggers to define business processes.  Stored procedures greatly enhance the power, efficiency, and flexibility of SQL Server, and dramatically improve the performance of SQL statements and batches. </P>
Stored procedures can:</P>
<SPAN CLASS="list"><UL><LI>Take parameters.</LI><LI>Call other procedures.</LI><LI>Return a status value to a calling procedure or batch to indicate success or failure (and the reason for failure).</LI><LI>Return values of parameters to a calling procedure or batch.</LI></UL></SPAN>Stored procedures on other SQL Servers to which the client process is not directly connected to can be executed if the remote server has been set up to allow remote logins. You can write triggers on your local SQL Server that execute procedures on a remote server whenever certain events (inserts, updates, or deletes) occur locally.  Stored procedures differ from ordinary SQL statements and from batches of SQL statements in that they are pre-parsed and pre-normalized. The first time you run a procedure, the SQL Server query processor analyzes it and prepares internal, normalized structure for the procedure that is stored in a system table. The first time the procedure is run when the SQL Server is started, the procedure is then brought into memory and fully compiled (but it does not need to be re-parsed or "sequenced" since this was done when the procedure was created). The fully compiled plan then stays in memory (unless other memory needs force it out so that the next request for execution (whether by the same or a different client) can be processed without any plan compilation overhead.  </P>
Stored procedures return a status value that indicates that they completed successfully or states the reasons for failure.  Stored procedures can also return information to the caller through return parameters.  Remote procedure calls (stored procedures run on a remote SQL Server) also return both types of information.  You can create stored procedures using the CREATE PROCEDURE statement.</P>
<I>Triggers</I></P>
A trigger is a special kind of stored procedure that goes into effect when you modify data in a specified table. Triggers are often created to enforce business rule consistency among logically related data in different tables. </P>
An advantage of triggers is that they are automatic - they work no matter what caused the data modification - a clerk's entry or an application action. Each trigger is specific to one or more of the data modification operations UPDATE, INSERT, or DELETE. The trigger is executed once per SQL statement; it "fires" immediately after the data modification statements are completed. The trigger and the statement that fires it are treated as a single transaction that can be rolled back from within the trigger. If a severe error is detected, the entire transaction automatically rolls back.</P>
Triggers are useful in these ways:</P>
<SPAN CLASS="list"><UL><LI>Triggers can cascade changes through related tables in the database. </LI><LI>For example, a delete trigger on the title_id column of the titles table causes a corresponding deletion of matching rows in other tables, using the title_id column as a unique key to locating rows in titleauthor, sales, and roysched.</LI><LI>Triggers can disallow or roll back changes that violate referential integrity, canceling the attempted data modification transaction. </LI><LI>Such a trigger might go into effect when you try to change a foreign key and the new value does not match its primary key. For example, you can create an insert trigger on titleauthor.title_id that rolls back an insert if the new value does not match some value in titles.title_id. (However, declarative referential integrity (DRI) is usually used for this purpose.)</LI><LI>Triggers can enforce restrictions that are more complex than those defined with CHECK constraints. </LI></UL></SPAN>Unlike CHECK constraints, triggers can reference columns in other tables. For example, a trigger can roll back updates that attempt to increase a book's price by more than 1 percent of its advance, might be checked with a SELECT to another table.</P>
<SPAN CLASS="list"><UL><LI>Triggers can also find the difference between the state of a table before and after a data modification and take action(s) based on that difference.</LI></UL></SPAN>You can create a trigger using the CREATE TRIGGER statement.</P>
<I>Cursors</I></P>
Server cursors allow individual row operations to be performed on a given results set or on the entire set. In SQL Server 6.0, ANSI SQL cursors are server based. In earlier releases, cursors were provided only through the DB-Library and Open Database Connectivity (ODBC) cursor APIs. </P>
The addition of cursors to the server provides an efficient way for single-row operations to occur within a given results set. ANSI SQL cursors support only single-row cursors. Each fetch will return only one row from the results set. Server cursors enhance the general use of relational databases by allowing row-level operations when set-oriented operations are impractical. In relational systems, set operations are preferred; cursors provide a powerful complement to set operations. Using cursors, multiple operations can be performed row by row against a results set with or without returning to the original table. In other words, cursors conceptually return a results set based on tables within the database(s). For example, a cursor can be generated to include a list of all user-defined table names within a database. After the cursor has been opened, movement (fetching) through the results set can include multiple operations against each table by passing each table name as a variable. Cursors are extremely powerful when combined with stored procedures and the EXECUTE statement (to dynamically build strings). </P>
SQL Server provides two interfaces for cursor functions. When using cursors in Transact-SQL batches or stored procedures, ANSI-standard SQL syntax has been added for declaring, opening, and fetching from cursors as well as positioned updates and deletes. When using cursors from a DB-Library or ODBC program, the SQL Server 6.0 client libraries transparently call built-in server functions to handle cursors more efficiently.</P>
Use SQL Distributed Management Objects for Administration</P>
SQL Distributed Management Objects (SQL-DMO) are 32-bit Component Object Model (COM) objects for the Microsoft Windows 95 and Windows NT operating systems. The SQL-DMO objects are OLE Automation Compatible. The SQL-DMO object model includes objects, properties, methods, and collections that are used to write programs that can administer multiple SQL Server-based servers distributed across a network. SQL-DMO programs can range from simple Visual Basic scripts to complex C++ applications. SQL-DMO is the foundation of SQL Enterprise Manager.  Using SQL-DMO you can access objects such as SQL Server devices, logins, language, remote servers, configuration, and security.  As well you can manage application environment such as backup and permissions, databases, indexes, tables, stored procedures and triggers.</P>
Use Integrated Security</P>
Integrated security integrates SQL Server login security with Windows NT security. This allows a network user to log in to a SQL Server without supplying a separate login ID or password. Users can maintain one login ID and password for both Windows NT and SQL Server. </P>
Integrated security lets SQL Server applications take advantage of Windows NT security features, including encrypted passwords, password aging, domain-wide user accounts, and Windows-based user administration. (For more information about these features, see your documentation for Windows NT.)</P>
SQL Server achieves login security integration with Windows NT by using the Windows NT security attributes of a network user to control login access to SQL Server. A user's network security attributes are established at network login time and are validated by Windows NT through a sophisticated password encryption mechanism. When a network user tries to connect to SQL Server, SQL Server uses Windows NT - based facilities to determine with certainty the validated network username of the client. SQL Server then permits or denies login access based on that network username alone, without requiring a separate login name and password to be sent in the client connection request.</P>
Login security integration operates over network protocols that support authenticated connections between clients and servers. Such connections are referred to as trusted connections. </P>
Trusted connections include multi-protocol and named pipes sessions from other Windows NT - based workstations, from Windows for Workgroups - based clients, from Windows 95-based clients, and from Microsoft LAN Manager clients running under the Microsoft Windows or MS-DOS operating system. Using the multi-protocol Net-Library, trusted connections can also be made over the NWLink IPX/SPX protocol from Windows 3.1 clients using Novell&reg; software. (In this case, the user will be prompted for a Windows NT username and password at SQL Server connect time.) Other network protocols do not support authenticated connections, so clients on these protocols must be handled according to SQL Server standard security.</P>
When a user of integrated security logs in to SQL Server over a trusted connection, the user is mapped to a SQL Server login ID, to a default SQL Server login ID (usually called guest), or if the user has administrative privileges to SA.</P>
Once the login process is complete, all other SQL Server security checks are handled as usual. Access to individual SQL Server tables, for example, is managed through the permissions granted within a SQL Server database.</P>
If multiple SQL Server computers participate in a domain managed by a machine running Windows NT Server, a single network login for each user is sufficient to enable access for all of the SQL Server-based servers. For users defined on other domains, SQL Server provides map characters to map the domain name and username to a SQL Server login ID (for example, salesdomain_Chris). These map characters also provide a way to map Windows NT usernames that are not valid SQL Server login IDs to valid SQL Server login IDs.</P>
The recommended way to implement SQL Server security integration is to create two or more locally defined Windows NT groups and then provide the users of those groups with access to SQL Server. The two recommended Windows NT groups are:</P>
A SQLUsers group, to be assigned user privileges</P>
A SQLAdmins group, to be assigned system administrator privileges. (Note that when SQL Server is set up with integrated security, the Administrators group on the local computer is automatically mapped to the sa login ID. This can be disabled if you prefer.)</P>
You can use the DBSETLSECURE command to request a secure, or trusted connection to SQL Server.  SQL Server will then use integrated login security to establish connections made via dbopen.  Any login ID or password supplied by DBSETLUSER, or DBSETLPWD is ignored.  With ODBC you can use the SqlSetConnection API and the SQL_INTEGRATED_SECURITY option to have SQL Server use integrated security.</P>
Systems Management Server Client</P>
Access Systems Management Server Database using Systems Management Server APIs or ODBC</P>
In an Systems Management Server system, a primary site's site database stores the inventory and configuration information for itself and the sites below it in the site hierarchy. Using the Systems Management Server API, your application can access this information. The Systems Management Server API enables your application to retrieve, add, and remove data in the Systems Management Server database. Using the Systems Management Server API, you can access the Sites, Inventoried Objects, Packages, Jobs, Queries, Machine Groups and Site Groups following objects in an Systems Management Server database.:  The Systems Management Server API represents all Systems Management Server objects in terms of containers, folders, and scalars. This paradigm provides a standard interface to all types of objects.  You can use the Systems Management Server API to view the existing packages and jobs within an Systems Management Server database as well as to create new packages and jobs.</P>
<I>For more information about the Systems Management Server APIs the BackOffice SDK Systems Management Server/Microsoft Systems Management Server API.</I></P>
</P>
The inventory and configuration information is stored in multiple tables in order to store the data efficiently. However, this efficient design can make it difficult to view the computer inventory directly from other applications.  The inventory for each computer is stored in the MachineDataTable. However, the specific inventory data (such as group names, attribute names, and the values for groups and attributes) is stored in other tables. The MachineDataTable has keyed pointers to these other tables. The Systems Management ServerVIEW program creates views that resolve these keyed pointers so that you can view the computer inventory easily with other applications.  With the Systems Management ServerVIEW program, you can create database views on a site database. Using the Microsoft Desktop ODBC Database Driver, you can use these views in other applications (such as Microsoft Word for Windows) to view the computer inventory and generate reports.</P>
Systems Management ServerVIEW is provided with the Microsoft Systems Management Server product. </P>
<I>For more information about Systems Management ServerVIEW see the BackOffice SDK Systems Management Server/Systems Management ServerVIEW Samples.</I></P>
</P>
Extend data in the database by providing a MIF file</P>
To add or maintain items in an Systems Management Server database, the Systems Management Server system uses data in the Management Information Format (MIF). For example, computer inventory, events, package locations, job status, and user groups are all reported to the Systems Management Server database as MIF files.  Using the ASCII text files with the MIF format, you can also add, update, or delete custom objects and groups from the Systems Management Server database. You can add objects with new architectures (for example, printers or hardware routers) or add new types of objects of existing architectures (for example, a new computer to the Personal Computer architecture).  In general, the Systems Management Server system can use any MIF file that complies with version 4.5 of the Desktop Management Interface (DMI) specification. However, Systems Management Server treats some aspects of the MIF syntax in a way that is unique to Systems Management Server. The full DMI 4.5 syntax is accepted by the Systems Management Server MIF parser; however, some fields are not used.</P>
<I>For more information see the BackOffice SDK Systems Management Server/Extending the Inventory.</I></P>
Internet Information Server Clients</P>
Support HTTP keep alive</P>
Support NT challenge response</P>
The information contained in this document represents the current view of Microsoft Corporation on the issues discusssed as of the date of publication.  Because Microsoft must respond to changing market conditions, it should not be interpreted to be a commitment on the part of Microsoft, and Microsoft cannot guarantee the accuracy of any information presented after the data of publication.</P>
This document is for informational purposes only.  MICROSOFT MAKES NO WARRANTIES, EXPRESS OR IMPLIED, IN THIS DOCUMENT.</P>
&copy; 1996 Microsoft Corporation.  All rights reserved.</P>
Microsoft, Win32, Windows, Visual Basic, Visual C++, Windows NT and MS-DOS are registered trademarks and BackOffice, the BackOffice logo are trademarks of the Microsoft Corporation.</P>
IBM, AS/400, OS/2 and OS/400 are registered trademarks and SQL/DS and PowerPC are trademarks of International Business Machines Corporation.  MIPS is a registered trademark of MIPS Technologies, Inc.  Novell is a registered trademark of Novell, Inc.  Transact-SQl is a registered trademark and DB-Library and Embedded SQL are trademarks of Sybase, Inc.  Unicode is a registered trademark of Unicode, Inc.</P>
<P></P>
 </P></BODY></HTML>
