<HTML><HEAD><META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>1.2 Strings in Unicode</TITLE><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">

</OBJECT></FORM>
<H2>1.2 Strings in Unicode</H2>All strings in a resource file are now stored in Unicode format. In this format, all characters are represented by a 16-bit (WORD) value. The first 256 characters are identical to the 256 characters in the Windows ANSI character set (although the characters are represented by 16 bits each rather than 8 bits). This means that they are terminated with a UNICODE_NULL symbol rather than a single NULL. The resource compiler translates all normal ASCII strings into Unicode by calling the MultiByteToWideChar function provided by the Windows API. All escaped characters are stored directly, and are assumed to be valid Unicode characters for the resource. If these strings are read in later by an application as ASCII (for instance, by calling the LoadString API), they will be converted back from Unicode to ASCII transparently by the loader.</P>
The only exception to the rule is strings in RCDATA statements. These pseudo-strings are not real strings, but merely a convenient notation for a collection of bytes. Users may overlay a structure over the data from an RCDATA statement and expect certain data to be at certain offsets. If a pseudo-string gets automatically changed into a Unicode string, it will inadvertently change the offsets of things in the structure and break those applications. Hence, these pseudo-strings must be left as ASCII bytes. To specify a Unicode string inside an RCDATA statement, the user should use the explicit L-quoted string.</P></BODY></HTML>
