<HTML><HEAD><META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>3.6 Differentiating 16-Bit and 32-Bit Resource Files</TITLE><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">

</OBJECT></FORM>
<H2>3.6 Differentiating 16-Bit and 32-Bit Resource Files</H2>Because it might be desirable for an independent software vendor's (ISV's) tool that reads and writes resource files to be able to read either the older Windows 16 format files and the new Win32 format, Microsoft has devised a method to do this using illegal type and name ordinal numbers.</P>
The method involved is to place an illegal resource in the resource file. The following eight bytes were chosen:</P>
0x00 0x00 0x00 0x00 0x20 0x00 0x00 0x00</P>
Assume that it is a 16-bit file. In that case, the Type is illegal because the first 0x00 says string, but a zero-length string is an illegal string. This, then, is an illegal 16-bit resource header, indicating that the file is a 32-bit file.</P>
Assume that it is a 32-bit file. Given that, the size of the data is zero, which surely will never be the case.</P>
The Win32 resource compiler prefaces each 32-bit resource file with this string of data (followed by an additional data structure describing a zero-length resource with 0 ordinal type and 0 ordinal name), allowing differentiation of 16-bit and 32-bit resource files. Any tools reading resource files should ignore this resource.</P></BODY></HTML>
