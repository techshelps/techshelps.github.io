<HTML><HEAD><META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Appendix A - CHS mapping</TITLE><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">

</OBJECT></FORM>
<H1>Appendix A - CHS mapping</H1>  </P>
Existing operating systems use a Cylinder-Head-Sector (CHS) mapping for "talking" to hard disk drives via INT 13h. These CHS values limit the maximum number of blocks on a disk to 1024 * 255 * 63 which is slightly less than eight Gigabytes. To overcome this, new operating systems have defined new partition table system type values. These values will be used for partition entries whose limits exceed the CHS mapping capabilities. </P>
The two new system types are 0Eh for primary partitions and 0Fh for extended partitions meeting the criteria above. These entries will have CHS values of 0Fh and will use the LBA starting field (offset 08h in the partition entry) and the Length field (offset 0Ch) to describe the partition. Access to these partitions will be by the INT 13h extensions as defined by Microsoft. The following routine is pseudo-code for detecting an existing partition and calculating geometry using this information.</P>
Partition table entry format</P>
  </P>

<TABLE COLS="3" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="56pt" VALIGN="TOP"><COL WIDTH="145pt" VALIGN="TOP"><COL WIDTH="272pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><B>Offset</B></P></TD><TD VALIGN="TOP"><B>Description</B></P></TD><TD VALIGN="TOP"><B>Variable</B></P></TD></TR><TR><TD VALIGN="TOP">00h</P></TD><TD VALIGN="TOP">Boot indicator</P></TD><TD VALIGN="TOP"></P></TD></TR><TR><TD VALIGN="TOP">01h</P></TD><TD VALIGN="TOP">Start Head</P></TD><TD VALIGN="TOP">StartHead</P></TD></TR><TR><TD VALIGN="TOP">02h</P></TD><TD VALIGN="TOP">Start Sector/Cylinder</P></TD><TD VALIGN="TOP">StartSector</P></TD></TR><TR><TD VALIGN="TOP">03h</P></TD><TD VALIGN="TOP">Start Cylinder (low 8 bits)</P></TD><TD VALIGN="TOP">StartCylinder</P></TD></TR><TR><TD VALIGN="TOP">04h</P></TD><TD VALIGN="TOP">System type</P></TD><TD VALIGN="TOP">SystemType</P></TD></TR><TR><TD VALIGN="TOP">05h</P></TD><TD VALIGN="TOP">Ending Head</P></TD><TD VALIGN="TOP">EndHead</P></TD></TR><TR><TD VALIGN="TOP">06h</P></TD><TD VALIGN="TOP">Ending Sector/Cylinder</P></TD><TD VALIGN="TOP">EndSector</P></TD></TR><TR><TD VALIGN="TOP">07h</P></TD><TD VALIGN="TOP">Ending Cylinder (low 8 bits)</P></TD><TD VALIGN="TOP">EndCylinder</P></TD></TR><TR><TD VALIGN="TOP">08h</P></TD><TD VALIGN="TOP">Starting sector</P></TD><TD VALIGN="TOP">StartingSector</P></TD></TR><TR><TD VALIGN="TOP">0Ch</P></TD><TD VALIGN="TOP">Number of sectors in partition</P></TD><TD VALIGN="TOP">NumSectors</P></TD></TR></TBODY></TABLE>
<BR></P></P>
  </P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="158pt" VALIGN="TOP"><COL WIDTH="305pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><B>Some other variables</B></P></TD><TD VALIGN="TOP"><B>Description</B></P></TD></TR><TR><TD VALIGN="TOP">Sectors<BR>Heads<BR>Cylinders<BR>CHS<BR><BR>capacity<BR></P></TD><TD VALIGN="TOP">Sector value for CHS result<BR>Head value for CHS result<BR>Cylinder value for CHS result<BR>Short for StartHead, StartSector, and StartCylinder<BR><BR>Value returned from SCSI read capacity<BR></P></TD></TR><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP"></P></TD></TR></TBODY></TABLE>
<BR></P>  </P>
<BR></P>
<pre><code>void  GetCHS( void )
{
    ulong  logical_end;
    ushort Sectors;
    ushort Heads;
    ushort Cylinders;


For each drive
    Read Boot sector
    Validate Sector Signature (55AAh)
    Find Partition with largest logical start cylinder
        If no partitions found
            Use your own geometry routine
            exit

    if ((CHS == FF) || (SystemType == 0x0E) || (SystemType == 0x0F))
    {
        /* No Geometry is needed, use INT 13h Extensions */
        exit;
    }
    else 
    {
        Sectors = EndSector;
        Heads = EndHead + 1;
        logical_end = (EndCylinder * Heads * Sectors) +
                      (EndHead * Sectors) + Sectors;

        if (logical_end != StartingSector + NumSectors)
        {
            /* use your own geometry routine */
            exit;
        }

        Cylinders = capacity / (Heads * Sectors);
    }

    /* Now use the calculated Cylinders, Sectors, and Heads values. */
}</code></pre>
  </P>
 </P></BODY></HTML>
