<HTML><HEAD><META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>4.4 Plug and Play Installation Check</TITLE><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">

</OBJECT></FORM>
<H3>4.4 Plug and Play Installation Check</H3>  </P>
This section describes the method for system software to determine if the system has a Plug and Play BIOS.  This Plug and Play installation check indicates whether the system BIOS support for accessing the configuration information about the devices on the systemboard is present and the entry point to these BIOS functions.  This method involves searching for a signature of the ASCII string $PnP in system memory starting from F0000h to FFFFFh at every 16 byte boundary.  This signature indicates the system may have aPlug and Play BIOS and identifies the start of a structure that specifies the entry point of the BIOS code which implements the support described in this document.  The system software can determine if the structure is valid by performing a <B>Checksum</B> operation.  </P>
The method for calculating the checksum is to add up <I>Length </I>bytes from the top of the structure, including the <I>Checksum</I> field, into an 8-bit value.  A resulting sum of zero indicates a valid checksum operation.</P>
The entry points specified in this structure are the software interface to the BIOS functions.  The structure element that specifies the 16-bit protected mode entry point will allow the caller to construct a protected mode selector for calling this support.  The structure of the Plug and Play BIOS Support Installation Check is as follows: </P>
</P>
  </P>

<TABLE COLS="4" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="222pt" VALIGN="TOP"><COL WIDTH="63pt" VALIGN="TOP"><COL WIDTH="75pt" VALIGN="TOP"><COL WIDTH="88pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><B>Field</B></P></TD><TD VALIGN="TOP"><B>Offset</B></P></TD><TD VALIGN="TOP"><B>Length</B></P></TD><TD VALIGN="TOP"><B>Value</B></P></TD></TR><TR><TD VALIGN="TOP">Signature</P></TD><TD VALIGN="TOP">00h</P></TD><TD VALIGN="TOP">4 BYTES</P></TD><TD VALIGN="TOP">$PnP (ASCII)</P></TD></TR><TR><TD VALIGN="TOP">Version</P></TD><TD VALIGN="TOP">04h</P></TD><TD VALIGN="TOP">BYTE</P></TD><TD VALIGN="TOP">10h</P></TD></TR><TR><TD VALIGN="TOP">Length</P></TD><TD VALIGN="TOP">05h</P></TD><TD VALIGN="TOP">BYTE</P></TD><TD VALIGN="TOP">21h</P></TD></TR><TR><TD VALIGN="TOP">Control field</P></TD><TD VALIGN="TOP">06h</P></TD><TD VALIGN="TOP">WORD</P></TD><TD VALIGN="TOP">Varies</P></TD></TR><TR><TD VALIGN="TOP">Checksum</P></TD><TD VALIGN="TOP">08h</P></TD><TD VALIGN="TOP">BYTE</P></TD><TD VALIGN="TOP">Varies</P></TD></TR><TR><TD VALIGN="TOP">Event notification flag address</P></TD><TD VALIGN="TOP">09h</P></TD><TD VALIGN="TOP">DWORD</P></TD><TD VALIGN="TOP">Varies</P></TD></TR><TR><TD VALIGN="TOP">Real Mode 16-bit offset to entry point</P></TD><TD VALIGN="TOP">0Dh</P></TD><TD VALIGN="TOP">WORD</P></TD><TD VALIGN="TOP">Varies</P></TD></TR><TR><TD VALIGN="TOP">Real Mode 16-bit code segment address</P></TD><TD VALIGN="TOP">0Fh</P></TD><TD VALIGN="TOP">WORD</P></TD><TD VALIGN="TOP">Varies</P></TD></TR><TR><TD VALIGN="TOP">16-Bit Protected Mode offset to entry point</P></TD><TD VALIGN="TOP">11h</P></TD><TD VALIGN="TOP">WORD</P></TD><TD VALIGN="TOP">Varies</P></TD></TR><TR><TD VALIGN="TOP">16-Bit Protected Mode code segment base address</P></TD><TD VALIGN="TOP">13h</P></TD><TD VALIGN="TOP">DWORD</P></TD><TD VALIGN="TOP">Varies</P></TD></TR><TR><TD VALIGN="TOP">OEM Device Identifier</P></TD><TD VALIGN="TOP">17h</P></TD><TD VALIGN="TOP">DWORD</P></TD><TD VALIGN="TOP">Varies</P></TD></TR><TR><TD VALIGN="TOP">Real Mode 16-bit data segment address</P></TD><TD VALIGN="TOP">1Bh</P></TD><TD VALIGN="TOP">WORD</P></TD><TD VALIGN="TOP">Varies</P></TD></TR><TR><TD VALIGN="TOP">16-Bit Protected Mode data segment base address</P></TD><TD VALIGN="TOP">1Dh</P></TD><TD VALIGN="TOP">DWORD</P></TD><TD VALIGN="TOP">Varies</P></TD></TR></TBODY></TABLE>
<BR></P><B>Signature </B>is represented as the ASCII string "$PnP", where byte 0='$' (24h), byte 1='P' (50h),byte 2='n' (6Eh), and byte 3='P' (50h).</P>
<B>Version</B> - This is a BCD value that implies a level of compliance with major (high nibble) and minor (low nibble) version changes of the Plug and Play BIOS specification.  For example, the BCD value 10h would be interpreted as version 1.0.</P>
<B>Length</B> - Length of the entire Installation Structure expressed in bytes.  The length count starts at the Signature field.</P>
The <B>Control field</B> is a bit-field that provides system capabilities information.</P>
<P></P>

<TABLE COLS="3" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="46pt" VALIGN="TOP"><COL WIDTH="114pt" VALIGN="TOP"><COL WIDTH="253pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">bits 15:2: Reserved (0)</P></TD><TD VALIGN="TOP"></P></TD></TR><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">bits 1:0:</P></TD><TD VALIGN="TOP">Event notification mechanism</P></TD></TR><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">00=Event notification is not supported</P></TD></TR><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">01=Event notification is handled through polling</P></TD></TR><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">10=Event notification is asynchronous (at interrupt time)</P></TD></TR></TBODY></TABLE>
<BR></P><B>Checksum</B> - The method for calculating the checksum is to add up the number of bytes in the Installation Structure, including the <I>Checksum</I> field, into an 8-bit value.  A resulting sum of zero indicates a valid checksum.</P>
The <B>Event notification flag address</B> specifies the physical address of the <I>Event Flag </I>if event notification is handled through polling.  When event notification is handled through polling, bit 0 of the <I>Event Flag </I>will be set when a system event occurs.  System software will monitor or poll the <I>Event Flag</I> for notification of an event.</P>
If events are handled through asynchronous notification, the system BIOS will specify a system device node which can be obtained from the <I>Get Node</I> runtime function.  The system device node for asynchronous event management will be identified through the device identifier field in the device node data structure and will specify the IRQ number and an I/O port address.  This event system device node can be defined in one of two ways.  First, the device node can follow the generic implementation in which the device identifier is PNP0C03, and the interrupt number and I/O address assigned are system specific.  The only requirement with the generic implementation is that the I/O address bit used for detecting the source of the interrupt and clearing the interrupt line is bit 0.  If bit 0 of this I/O address is set to 1, then the interrupt was generated due to a system event.  The interrupt service routine should reset the interrupt line by clearing bit 0 at the specified I/O address.  All other bits read from the I/O address should not be modified.  The second way the event system device node can be defined is implementation specific where the system vendor must supply their own device identifier and whatever resources are required for servicing the event interrupt.  This method will require a specific device driver associated with the device node identifier to support the event notification interface.</P>
System software should check the <B><I>Control field</I></B> to determine the event notification method implemented on the system.</P>
Refer to the <B>Event Notification Interface</B> section for more information on events.</P>
The <B>Real Mode 16-Bit interface</B> is basically the segment:offset of the entry point.</P>
The <B>16-Bit Protected Mode interface</B> specifies the code segment base address so that the caller can construct the descriptor from this segment base address before calling this support from protected mode.  The offset value is the offset of the entry point.  It is assumed that the 16-Bit Protected Mode interface is sufficient for 32-Bit Protected Mode callers.</P>
The caller must also construct data descriptors for the functions that return information in the function arguments that are pointers.  The only limitation is that the pointer offset can only point to the first 64K bytes of a segment.</P>
If a call is made to these BIOS functions from 32-bit Protected Mode, the 32-bit stack will be used for passing any stack arguments to the Plug and Play BIOS functions.  However, it is important to note that the Plug and Play BIOS functions are not implemented as a full 32-bit protected mode interface and will access arguments on the stack as a 16-bit stack frame.  Therefore, the caller must ensure that the function arguments are pushed onto the stack as 16-bit values and not 32-bit values.  The stack parameter passing is illustrated in <I>Figure 4.4.1</I> below.</P>
<img src="QI0P.gif"></P>
<B><I>Figure 4.4.1 - 16-bit Stack Frame on 32-bit Stack</I></B></P>
The Plug and Play system BIOS can determine whether the stack is a 32-bit stack or a 16-bit stack in 16-bit and 32-bit environments through the use of the LAR - Load Access Rights Byte Instruction.  The LAR instruction will load the high order doubleword for the specified descriptor.  By loading the access rights for the current stack segment selector, the system BIOS can check the B-bit (Big bit) of the stack segment descriptor which identifies the stack segment descriptor as either a 16-bit segment (B-bit clear) or a 32-bit segment (B-bit set).</P>
In addition to executing the LAR command to get the entry point stack size, the BIOS code should avoid  ADD BP,X type stack operands in runtime service code paths. These operands carry the risk of faulting if the 32-bit stack base happens to be close to the 64K boundary.  For the 16-Bit Protected Mode interface, it is assumed that the segment limit fields will be set to 64K.  The code segment must be readable.  The current I/O permission bit map must allow accesses to the I/O ports that the system BIOS may need access to in order to perform the function.  The current privilege level (CPL) must be less than or equal to I/O privilege level.  This will allow the Plug and Play BIOS to use sensitive instructions such as CLI and STI.</P>
The <B>OEM Device Identifier</B> field provides a  means for specifying a device identifier for the system.  The format of the OEM Device Identifier follows the format specified for EISA product identifiers.  A system identifier is not required and if not specified, this field should be 0.</P>
The entry point is assumed to have a function prototype of the form,</P>
<B>                     </B><B><I>int FAR (*entryPoint)(int Function, ...);</I></B></P>
and follow the standard 'C' calling conventions.</P>
System software will interface with all of the functions described in this specification by making a far call to this entry point.  As noted above, the caller will pass a function number and a set of arguments based on the function being called.  Each function will also include an argument which specifies a data selector which will allow the Plug and Play BIOS to access and update variables within the system BIOS memory space.  This data selector parameter is required for protected mode callers.  The caller must create a data segment descriptor using the <B><I>16-bit Protected Mode data segment base address</I></B> specified in the Plug and Play Installation Structure, a limit of 64KB, and the descriptor must be read/write capable.  Real mode callers are required to set this parameter to the <B><I>Real Mode 16-bit data segment address</I></B> specified in the Plug and Play Installation Structure.</P>
Any functions described by this specification which are not supported should return the FUNCTION_NOT_SUPPORTED return code.  The function return codes are described in Appendix C of this specification.</P>
<A NAME="PT2"></A>4.4.1 System BIOS Plug and Play Compliance - "$PnP"</P>
This section describes the support that is guaranteed by the "$PnP" string in the Plug and Play Installation Check structure and specifies the BIOS support required to be Plug and Play compliant for systems with different characteristics.  A Plug and Play compliant system will guarantee:</P>
<SPAN CLASS="list"><OL><LI>The Plug and Play Structure is valid.</LI><LI>Any calls made to the Plug and Play BIOS functions will either perform the function as described by Version 1.0 of this specification or return the FUNCTION_NOT_SUPPORTED error code.  Plug and Play compliant systems are required to provide the support as outlined in the table below.</LI><LI>All of the runtime Plug and Play services will be contained in a contiguous 64K code segment.</LI></OL></SPAN>Presence of the $PnP structure in the system BIOS does not mean that the system is fully Plug and Play compliant.  For instance, a system BIOS could have a valid $PnP structure; yet, return FUNCTION_NOT_SUPPORTED for each of the functions described in this specification.  The following table specifies the required Plug and Play BIOS support necessary for systems with different characteristics to meet full Plug and Play compliance.</P>
  </P>

<TABLE COLS="3" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="249pt" VALIGN="TOP"><COL WIDTH="109pt" VALIGN="TOP"><COL WIDTH="106pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><B>System Characteristics</B></P></TD><TD VALIGN="TOP"><B>Required Functions</B></P></TD><TD VALIGN="TOP"><B>Optional Functions</B></P></TD></TR><TR><TD VALIGN="TOP">Systems with embedded devices on the systemboard.</P></TD><TD VALIGN="TOP">00h, 01h, 02h</P></TD><TD VALIGN="TOP"></P></TD></TR><TR><TD VALIGN="TOP">Proprietary bus devices or local ISA devices on the    systemboard.</P></TD><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP"></P></TD></TR><TR><TD VALIGN="TOP">Systems that support docking to expansion bases</P></TD><TD VALIGN="TOP">03h, 04h, 05h</P></TD><TD VALIGN="TOP"></P></TD></TR><TR><TD VALIGN="TOP">Reserved</P></TD><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">06h, 07h, 08h</P></TD></TR><TR><TD VALIGN="TOP">Systems with an ISA expansion bus</P></TD><TD VALIGN="TOP">40h</P></TD><TD VALIGN="TOP">09h, 0Ah</P></TD></TR><TR><TD VALIGN="TOP">ESCD Interface Functions</P></TD><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">41h, 42h, 43h</P></TD></TR><TR><TD VALIGN="TOP">Systems supporting APM 1.1 (and greater)</P></TD><TD VALIGN="TOP">0Bh</P></TD><TD VALIGN="TOP"></P></TD></TR></TBODY></TABLE>
<BR></P></P>
  </P>
<B>*Note</B>   Functions 09h, 0Ah, and 40h are designed to support systems with an ISA Expansion bus.  The information which must be stored in nonvolatile media is the information concerning the resources allocated to static legacy ISA devices.  If functions 09h and 0Ah designate that the system implementation utilizes the ESCD for storing static resource allocation, then the caller should utilize the interface defined by the <I>ESCD Specification </I>to report statically allocated resources.  Functions 41h, 42h, and 43h defined in section 4.7 specify the ESCD interface.  Refer to the <I>ESCD Specification </I>for a complete description of the interfaces to support the ESCD as well as the format of the ESCD.  BIOS support of these functions is optional.Systems with an ISA Expansion bus may provide these BIOS functions to enhance the Plug and Play BIOS POST process for assigning a conflict free configuration to the required boot devices.</P>
  </P>
The following table provides some examples of systems with certain characteristics and categorically lists the functions that would be required to be Plug and Play compliant.</P>
  </P>

<TABLE COLS="5" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="170pt" VALIGN="TOP"><COL WIDTH="69pt" VALIGN="TOP"><COL WIDTH="69pt" VALIGN="TOP"><COL WIDTH="81pt" VALIGN="TOP"><COL WIDTH="84pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><B>Example Systems</B></P></TD><TD VALIGN="TOP"><B>Runtime Services</B></P></TD><TD VALIGN="TOP"><B>Event</B></P></TD><TD VALIGN="TOP"><B>ISA Allocated Resource Support</B></P></TD><TD VALIGN="TOP"><B>ISA PnP<BR>Isolation</B></P></TD></TR><TR><TD VALIGN="TOP">Systems without an ISA bus;<BR>limited or a variety of boot devices;<BR>No Dynamic Events</P></TD><TD VALIGN="TOP">Required</P></TD><TD VALIGN="TOP">Not <BR>Required</P></TD><TD VALIGN="TOP">Not <BR>Required</P></TD><TD VALIGN="TOP">Not <BR>Required</P></TD></TR><TR><TD VALIGN="TOP">Systems without an ISA bus;<BR>limited or a variety of boot devices;<BR>Dynamic Events supported</P></TD><TD VALIGN="TOP">Required</P></TD><TD VALIGN="TOP">Required</P></TD><TD VALIGN="TOP">Not <BR>Required</P></TD><TD VALIGN="TOP">Not <BR>Required</P></TD></TR><TR><TD VALIGN="TOP">Systems with an ISA bus;<BR>No Dynamic Events</P></TD><TD VALIGN="TOP">Required</P></TD><TD VALIGN="TOP">Not <BR>Required</P></TD><TD VALIGN="TOP">Not<BR>Required </P></TD><TD VALIGN="TOP">Required</P></TD></TR><TR><TD VALIGN="TOP">Systems with an ISA bus;<BR>Dynamic Events supported</P></TD><TD VALIGN="TOP">Required</P></TD><TD VALIGN="TOP">Required</P></TD><TD VALIGN="TOP">Not<BR>Required </P></TD><TD VALIGN="TOP">Required</P></TD></TR></TBODY></TABLE>
<BR></P> </P></BODY></HTML>
