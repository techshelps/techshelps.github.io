<HTML><HEAD><META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>4.6 Event Notification Interface</TITLE><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">

</OBJECT></FORM>
<H3>4.6 Event Notification Interface</H3>  </P>
Certain classes of systems may provide the capability for the addition or removal of system devices while the system unit is powered on, such as inserting a Notebook unit into a Docking Station.  System BIOS support is necessary for providing Event Notification accessible to system software so that when devices are added or removed the system software will comprehend the use or release of system resources by those devices.  Event Notification can be implemented as either a polled method or as asynchronous events.  System software can check the <I>Control Word, </I>which is located in the <I>BIOS Plug and Play Header</I> structure, to determine the Event Notification method supported on the system.  <I>Refer to the Plug and Play Installation Check section for more information on the BIOS Plug and Play Header and the Control Word.</I>  The <I>Control Word </I>has bits defined that indicate the type of Event Notification.  The BIOS Plug and Play Header structure also contains the <I>Event notification flag address, </I>which specifies the physical location of the <I>Event Flag </I>for polling.  The <I>Event Flag </I>is the event polling location.  When a system event occurs bit 0 of the <I>Event Flag</I> will be set to indicate a pending event.  Therefore, if the method for Event Notification is through polling, system software should monitor the <I>Event Flag </I>to determine when a configuration event has occurred.</P>
The asynchronous method of Event Notification allows system software to install an interrupt handler as a means for notification.  The system BIOS will specify a system device node, which can be obtained from the <I>Get Node</I> runtime function, that will specify the requirements for handling asynchronous events.  The system device node for asynchronous event management will be identified through the device identifier field in the device node data structure, and will specify the interrupt number and an I/O port address.  This event system device node can be defined in one of two ways.  First, the device node can follow the generic implementation in which the device identifier is PNP0C03 and the interrupt number and I/O address assigned are system specific.  The only requirement with the generic implementation is that the I/O address bit used for detecting the source of the interrupt and clearing the interrupt line is bit 0.  If bit 0 of this I/O address is set to 1, then the interrupt was generated due to a system event.  The interrupt service routine should reset the interrupt line by clearing bit 0 at the specified I/O address.  All other bits read from the I/O address should not be modified.  The second way the event system device node can be defined is implementation specific where the system vendor must supply their own device identifier and whatever resources are required for servicing the event interrupt.  This method will require a specific device driver associated with the device node identifier to support the event notification interface.</P>
When the system software is notified of an event by either mechanism, it can then call the BIOS runtime function to get the event which will return a message specifying the type of event.  These events are specific to the system and do not represent events that can occur on the various expansion busses, such as PCMCIA insertion and removal events.  The following table describes the types of events that are reported through this BIOS interface:</P>
  </P>

<TABLE COLS="3" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="179pt" VALIGN="TOP"><COL WIDTH="54pt" VALIGN="TOP"><COL WIDTH="260pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><B>Event Identifier</B></P></TD><TD VALIGN="TOP"><B>Value</B></P></TD><TD VALIGN="TOP"><B>Description</B></P></TD></TR><TR><TD VALIGN="TOP">ABOUT_TO_CHANGE_CONFIG</P>
</P></TD><TD VALIGN="TOP">0001h</P></TD><TD VALIGN="TOP">This message provides the system with a mechanism whereby system software can obtain notification from the system BIOS when a change is about to be made to the system.  This notification encompasses initiating a docking, or undocking, sequence.  For systems that support this message, the docking sequence will be suspended until the system software issues a <B>Send_Message()</B> to the system BIOS with either an <B>OK</B> message indicating that it's OK to dock/undock the system, or an <B>ABORT</B> message that signals the BIOS to halt the event. <I>(Refer to Send Message function description below for more information.)</I>  </P></TD></TR><TR><TD VALIGN="TOP">DOCK_CHANGED</P>
</P></TD><TD VALIGN="TOP">0002h</P></TD><TD VALIGN="TOP">This message indicates that new devices have either been successfully added or removed from the system, such as docking to, or undocking from, a docking station.  This message will be used to indicate that a convenience base has been added/removed from the system. </P></TD></TR><TR><TD VALIGN="TOP">SYSTEM_DEVICE_CHANGED</P>
</P></TD><TD VALIGN="TOP">0003h</P></TD><TD VALIGN="TOP">This message indicates that removable ("pluggable") system devices have been removed or inserted into the base unit. </P></TD></TR><TR><TD VALIGN="TOP">CONFIG_CHANGE_FAILED</P>
</P></TD><TD VALIGN="TOP">0004h</P></TD><TD VALIGN="TOP">This message indicates that the system detected an error when attempting to add or remove devices to/from the system, such as attempting to dock to the docking station, or failing to successfully undock from the docking station.  An error code will be returned in the return status for the <I>Get_Event</I> Plug and Play BIOS function if the system is able to determine the cause of the CONFIG_CHANGE_FAILED.  Appendix C contains a complete list of return codes.</P>
</P></TD></TR><TR><TD VALIGN="TOP">UNKNOWN_SYSTEM_EVENT</P></TD><TD VALIGN="TOP">FFFFh</P></TD><TD VALIGN="TOP">An unknown system event has occurred.  The system BIOS is not able to determine the type of event.</P></TD></TR><TR><TD VALIGN="TOP">OEM_DEFINED_EVENTS</P></TD><TD VALIGN="TOP">8000h thru FFFEh</P></TD><TD VALIGN="TOP">OEM defined events allow OEM to define events specific to their system implementation.  These events are only comprehended by the OEM.  These events are identified by the upper bit of the event message being set (bit 7=1). </P></TD></TR></TBODY></TABLE>
<BR></P>To properly support event management, a PnP BIOS should implement the PNP_OS_ACTIVE and PNP_OS_INACTIVE messages, as well as their associated event timing requirements and PnP-OS-Active states as described in section 4.6.2.</P>
<A NAME="PT2"></A>4.6.1 Function 3 - Get Event</P>
<B>Synopsis:</B></P>
  </P>
<BR></P>
<pre><code><I>int FAR (*entryPoint)(Function, Message, BiosSelector);     </I>
int Function;               /* PnP BIOS Function 3 */
unsigned int FAR *Message;  /* Storage for the event message */
unsigned int BiosSelector;  /* PnP BIOS readable/writable selector */ </code></pre>
  </P>
<B>Description:</B></P>
<I>Required for Dynamic Event Management.  </I>This function will allow system software to retrieve a message specifying the type of event that has occurred on the system. This function is supported for either event notification by polling or for asynchronous event notification, if the system BIOS provides event notification.  It is the responsibility of this function to clear the event flag when called if the event notification method implemented is through polling.</P>
If a system event has occurred this call will return the appropriate event notification message in the memory location specified by the <I>Message </I>argument.  <I>Message </I>will be set to one of the following event notification messages:</P>
     ABOUT_TO_CHANGE_CONFIG<BR>     DOCK_CHANGED<BR>     SYSTEM_DEVICE_CHANGED<BR>     CONFIG_CHANGE_FAILED<BR>     UNKNOWN_SYSTEM_EVENT<BR>     OEM_DEFINED_EVENT</P>
The event notification messages are defined in the table at the start of Event Notification Interface section.  If <I>Message </I>is CONFIG_CHANGE_FAILED and the system is able to determine the cause of the error, then the appropriate error should be returned in AX.  This will allow system software the ability notify the user of the cause of the failure.  Refer to Appendix C for a description of the error codes associated with the CONFIG_CHANGE_FAILED event message.</P>
The <I>BiosSelector</I> parameter enables the system BIOS, if necessary, to update system variables that are contained in the system BIOS memory space.  If this function is called from protected mode the caller must create a data segment descriptor using the 16-bit Protected Mode data segment base address specified in the Plug and Play Installation Check data structure, a limit of 64k, and the descriptor must be read/write capable.  If this function is called from real mode, <I>BiosSelector </I>should be set to the Real Mode 16-bit data segment address as specified in the Plug and Play Installation Check structure.  Refer to section 4.4 above for more information on the Plug and Play Installation Check Structure and the elements that make up the structure.</P>
This function is available in real mode and 16-bit protected mode.</P>
<B>Returns:</B></P>
0 if successful - SUCCESS<BR>!0 if an error (Bit 7 set) or a warning occurred or no pending events - error code (The function return codes are described in Appendix C)</P>
The FLAGS and registers will be preserved, except for AX which contains the return code.<B>Example:</B></P>
The following example illustrates how the 'C' style call interface could be made from an assembly language module:</P>
  </P>
<BR></P>
<pre><code><B>          .</B>
          .
          .
     push    Bios Selector     
     push    segment/selector of Message     ; pointer to Message
     push    offset of Message     
     push    GET_EVENT               ; Function 3
     call    FAR PTR entryPoint     
     add     sp,8                    ; Clean up stack
     cmp     ax,SUCCESS              ; Function completed successfully?
     jne     error                   ; No-handle error condition
          .
          .
          .</code></pre>
  </P>
<A NAME="PT3"></A>4.6.2 Function 4 - Send Message</P>
<B>Synopsis:</B></P>
  </P>
<BR></P>
<pre><code><I>int FAR (*entryPoint)(Function, Message, BiosSelector);     </I>
int Function;              /* PnP BIOS Function 4 */
unsigned int Message;      /* Docking Message */
unsigned int BiosSelector; /* PnP BIOS readable/writable selector */ </code></pre>
  </P>
<B>Description:</B></P>
<I>Required for Dynamic Event Management.  </I>This function will provide system software with a mechanism for interacting with the system while handling system events.  There are three classes of messages that are supported by this interface:  Response Messages, Control Messages, and OEM Defined Messages.  The Response Messages are used as a means whereby the system BIOS will not proceed with a particular event until the system software provides a response instructing the system BIOS to continue or abort the processing of that event.  Message values 0 through 3Fh are reserved for Response Messages.  Control Messages provide system software with the ability to cause a particular event to happen.  Message values 40h through 7Fh are reserved for Control Messages.  OEM Defined Messages are specific to the OEM's system implementations and are only understood by the OEM.  Message values 8000h through FFFFh identify OEM Defined Messages.  The following table describes the event messages that system software can send to the system BIOS, where <I>Message</I> has one of the following meanings:</P>
<B>Response Messages 00h through 3Fh:</B></P>
  </P>

<TABLE COLS="3" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="187pt" VALIGN="TOP"><COL WIDTH="50pt" VALIGN="TOP"><COL WIDTH="260pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><B>Message Identifier</B></P></TD><TD VALIGN="TOP"><B>Value</B></P></TD><TD VALIGN="TOP"><B>Description</B></P></TD></TR><TR><TD VALIGN="TOP">OK</P></TD><TD VALIGN="TOP">00h</P></TD><TD VALIGN="TOP">Instructs the system to continue with the sequence which initiated the event.  This message is only valid when the Get Event function has returned one of the ABOUT_TO_XXXXX events.  When the system software is notified with an ABOUT_TO_XXXXX message,  the appropriate actions will not take place  until the Send Message BIOS Function is called with OK.</P></TD></TR><TR><TD VALIGN="TOP">ABORT</P></TD><TD VALIGN="TOP">01h</P></TD><TD VALIGN="TOP">Abort the action which initiated the ABOUT_TO_XXXXX event.  This message instructs the system BIOS to prevent the event from occurring.  For instance, if the event is an undocking sequence, then the system will not be allowed to undock.  It is assumed that it is the responsibility of the system software to communicate to the user the reason for not allowing the system to carry out the action for the event.  This message is only valid when Get Event has returned one of the ABOUT_TO_XXXXX messages.</P></TD></TR></TBODY></TABLE>
<BR></P><B>Control Messages 40h through 7Fh:</B></P>
  </P>

<TABLE COLS="3" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="187pt" VALIGN="TOP"><COL WIDTH="50pt" VALIGN="TOP"><COL WIDTH="260pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><B>Message Identifier</B></P></TD><TD VALIGN="TOP"><B>Value</B></P></TD><TD VALIGN="TOP"><B>Description</B></P></TD></TR><TR><TD VALIGN="TOP">UNDOCK_DEFAULT_ACTION</P></TD><TD VALIGN="TOP">40h</P></TD><TD VALIGN="TOP">This message provides a mechanism for system software to soft eject the system and instructs the system BIOS to take the default action when ejecting the system.</P></TD></TR><TR><TD VALIGN="TOP">POWER_OFF</P></TD><TD VALIGN="TOP">41h</P></TD><TD VALIGN="TOP">This message instructs the system BIOS to power off the system.  It is assumed that the system software will perform the necessary actions to shut the system down before sending this message.</P></TD></TR><TR><TD VALIGN="TOP">PNP_OS_ACTIVE</P></TD><TD VALIGN="TOP">42h</P></TD><TD VALIGN="TOP">This message allows the PnP BIOS to track whether a PnP OS is active and defines event timing.  The PnP BIOS may default to either a PnP-OS-Inactive or PnP-OS-Active state as needed.  However, upon initial OS load, a PnP OS will register with the PnP BIOS by sending the PNP_OS_ACTIVE message to the PnP BIOS.  When the PNP_OS_ACTIVE message is received, the PnP BIOS will operate in the PnP-OS-Active state.  In this state, the PnP BIOS will wait forever after signaling a system event.  This will allow the PnP OS to execute a <I>Plug and Play BIOS Function Get Event</I> call and handle the event (See Section 4.6).  Although a PnP BIOS is not required to support the PNP_OS_ACTIVE message, support is recommended in systems that generate events.  If this message is unsupported, then  MESSAGE_NOT _SUPPORTED should be returned.</P></TD></TR><TR><TD VALIGN="TOP">PNP_OS_INACTIVE</P></TD><TD VALIGN="TOP">43h</P></TD><TD VALIGN="TOP">This message complements the PNP_OS_ACTIVE message.   A PnP OS will send the PNP_OS_INACTIVE message to the PnP BIOS upon OS termination.  When the PNP_OS_INACTIVE message is received, the PnP BIOS will operate in the PnP-OS-Inactive state.  In this state,  no PnP event  timing constraints exist.  The PnP BIOS does not have to wait for the PnP OS to execute a <I>Plug and Play BIOS Function Get Event</I> call (See Section 4.6) and can handle event timing in the manner it best determines.  Although a PnP BIOS is not required to support the PNP_OS_INACTIVE message, support is recommended in systems that generate events.  If this message is unsupported, then MESSAGE_NOT _SUPPORTED should be returned.</P></TD></TR></TBODY></TABLE>
<BR></P><B>OEM Defined Messages 8000h through FFFFh:</B></P>
  </P>

<TABLE COLS="3" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="187pt" VALIGN="TOP"><COL WIDTH="50pt" VALIGN="TOP"><COL WIDTH="260pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><B>Message Identifier</B></P></TD><TD VALIGN="TOP"><B>Value</B></P></TD><TD VALIGN="TOP"><B>Description</B></P></TD></TR><TR><TD VALIGN="TOP">OEM_DEFINED_MESSAGES</P></TD><TD VALIGN="TOP">8000h <BR>thru<BR> FFFFh</P></TD><TD VALIGN="TOP">This message allows OEMs to define messages specific to their system implementation.  These messages are only comprehended by the OEM.  These messages are identified by the upper bit of the message.</P></TD></TR></TBODY></TABLE>
<BR></P>If the system BIOS does not support one of the specified messages, this function will return MESSAGE_NOT_SUPPORTED.</P>
The <I>BiosSelector</I> parameter enables the system BIOS, if necessary, to update system variables that are contained in the system BIOS memory space.  If this function is called from protected mode, the caller must create a data segment descriptor using the 16-bit Protected Mode data segment base address specified in the Plug and Play Installation Check data structure, a limit of 64KB, and the descriptor must be read/write capable.  If this function is called from real mode, <I>BiosSelector </I>should be set to the Real Mode 16-bit data segment address as specified in the Plug and Play Installation Check structure.  Refer to section 4.4 above for more information on the Plug and Play Installation Check Structure and the elements that make up the structure.</P>
This function is available in real mode and 16-bit protected mode.</P>
<B>Returns:</B></P>
0 if successful - SUCCESS</P>
!0 if an error (Bit 7 set) or a warning occurred - error code (The function return codes are described in Appendix C)</P>
The FLAGS and registers will be preserved, except for AX which contains the return code.</P>
<B>Example:</B></P>
The following example illustrates how the 'C' style call interface could be made from an assembly language module:</P>
  </P>
<BR></P>
<pre><code><B>          .</B>
          .
          .
     push    Bios Selector     
     push    Message           ; Message
     push    SEND_MSG          ; Function 4
     call    FAR PTR entryPoint
     add     sp,6              ; Clean up stack
     cmp     ax,SUCCESS        ; Function completed successfully?
     jne     error             ; No-handle error condition
          .
          .
          .</code></pre>
  </P>
<A NAME="PT4"></A>4.6.3 Function 5 - Get Docking Station Information</P>
<B>Synopsis:</B></P>
  </P>
<BR></P>
<pre><code><I>int FAR (*entryPoint)(Function, DockingStationInfo, BiosSelector);     </I>
int Function;                           /* PnP BIOS Function 5 */
unsigned char FAR *DockingStationInfo;  /* Pointer to docking station*/
                                        /*info structure */
 unsigned int BiosSelector;             /* PnP BIOS readable/writable*/
                                        /*selector */</code></pre>
  </P>
<B>Description:</B></P>
<I>Required for Dynamic Event Management.  </I>This function will allow system software to get information which specifies the type of docking device, either expansion or convenience base, the system is connected to, as well as the capabilities of the docking device.  The docking station information will be returned in the memory buffer pointed to by <I>DockingStationInfo</I> in the following format:</P>
</P>
  </P>

<TABLE COLS="4" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="209pt" VALIGN="TOP"><COL WIDTH="81pt" VALIGN="TOP"><COL WIDTH="81pt" VALIGN="TOP"><COL WIDTH="81pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><B>Field</B></P></TD><TD VALIGN="TOP"><B>Offset</B></P></TD><TD VALIGN="TOP"><B>Length</B></P></TD><TD VALIGN="TOP"><B>Value</B></P></TD></TR><TR><TD VALIGN="TOP">Docking station location identifier</P></TD><TD VALIGN="TOP">00h</P></TD><TD VALIGN="TOP">DWORD</P></TD><TD VALIGN="TOP">Varies</P></TD></TR><TR><TD VALIGN="TOP">Serial number</P></TD><TD VALIGN="TOP">04h</P></TD><TD VALIGN="TOP">DWORD</P></TD><TD VALIGN="TOP">Varies</P></TD></TR><TR><TD VALIGN="TOP">Capabilities</P></TD><TD VALIGN="TOP">08h</P></TD><TD VALIGN="TOP">WORD</P></TD><TD VALIGN="TOP">Varies</P></TD></TR></TBODY></TABLE>
<BR></P><P><B><I>Docking station location identifier:</I></B></P>
This field is the docking device location identifier.  The identifier should follow the EISA device identifier format.  The docking device location identifier will allow system software to differentiate between the types of docking stations and convenience bases that the base system unit can be connected to.  This enables the system software to better determine the various docked and undocked configuration states.  LocationId will be set to UNKNOWN_DOCKING_IDENTIFIER (0xFFFFFFFF) for docking stations and/or convenience bases that do not have a product identifier.</P>
<P><B><I>Serial number:</I></B></P>
SerialNum is not required; however, if the docking station does not have a serial number, then 0 should be returned in this parameter.</P>
<P><B><I>Capabilities:</I></B></P>
The Docking Capabilities bit field is defined as follows:</P>
<P></P>

<TABLE COLS="3" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="46pt" VALIGN="TOP"><COL WIDTH="124pt" VALIGN="TOP"><COL WIDTH="298pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">Bits 15:3 Reserved (0)</P></TD><TD VALIGN="TOP"></P></TD></TR><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">Bit 2:1 -</P></TD><TD VALIGN="TOP">00=System should be powered off to dock or undock (Cold Docking)</P></TD></TR><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">01=System supports Warm Docking/Undocking, system must be in suspend</P></TD></TR><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">10=System supports Hot Docking/Undocking, not required to be in suspend</P></TD></TR><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">11=Reserved</P></TD></TR><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">Bit 0 -</P></TD><TD VALIGN="TOP">0=Docking station does not provide support for controlling the docking/undocking sequence (Surprise Style).</P></TD></TR><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">1=Docking station provides support for controlling the docking/undocking </P></TD></TR><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">sequence (VCR Style).</P></TD></TR></TBODY></TABLE>
<BR></P>If the system supports docking and is unable to determine the docking station capabilities, this function will return UNABLE_TO_DETERMINE_DOCK_CAPABILITIES.  All other relevant information, such as the docking station identifier, will be returned in the data structure.</P>
If the system does not support docking, this function will return FUNCTION_NOT_SUPPORTED.  If the system supports docking, but is not currently docked, this function will return SYSTEM_NOT_DOCKED and will not return any information about a docking station.</P>
The <I>BiosSelector</I> parameter enables the system BIOS, if necessary, to update system variables that are contained in the system BIOS memory space.  If this function is called from protected mode, the caller must create a data segment descriptor using the 16-bit Protected Mode data segment base address specified in the Plug and Play Installation Check data structure, a limit of 64KB, and the descriptor must be read/write capable  If this function is called from real mode, <I>BiosSelector </I>should be set to the Real Mode 16-bit data segment address as specified in the Plug and Play Installation Check structure.  Refer to section 4.4 above for more information on the Plug and Play Installation Check Structure and the elements that make up the structure.</P>
The function is available in real mode and 16-bit protected mode.</P>
<B>Returns:</B></P>
0 if successful - SUCCESS</P>
!0 if an error (Bit 7 set) or a warning occurred or the system is not currently docked (The function return codes are described in Appendix C)</P>
The FLAGS and registers will be preserved, except for AX which contains the return code.</P>
<B>Example:</B></P>
The following example illustrates how the 'C' style call interface could be made from an assembly language module:</P>
  </P>
<BR></P>
<pre><code><B>          .</B>
          .
          .
     push   Bios Selector
     push   segment/selector of DockingStationInfo     ; pointer to
                                         ;docking station info
                                         ;data structure
     push   offset of DockingStationInfo     
     push   GET_DOCK_INFO                ; Function 5
     call   FAR PTR entryPoint     
     add    sp,8                         ; Clean up stack
     cmp    ax,SUCCESS                   ; Function completed
                                         ;successfully?
     jne    error                        ; No-handle error condition
          .
          .</code></pre>
  </P>
<A NAME="PT5"></A>4.6.4 Function 6 - Reserved</P>
This function has been reserved for future implementations and should return FUNCTION_NOT_SUPPORTED.</P>
<A NAME="PT6"></A>4.6.5 Function 7 - Reserved</P>
This function has been reserved for future implementations and should return FUNCTION_NOT_SUPPORTED.</P>
<A NAME="PT7"></A>4.6.6 Function 8 - Reserved</P>
This function has been reserved for future implementations and should return FUNCTION_NOT_SUPPORTED.</P>
</P>
 </P></BODY></HTML>
