<HTML><HEAD><META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>4.7 Extended Configuration Services</TITLE><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">

</OBJECT></FORM>
<H3>4.7 Extended Configuration Services</H3>  </P>
This section describes the optional extended services provided by the System BIOS on Plug and Play platforms.</P>
The extended configuration services are a mechanism whereby the system software may specify the system resources assigned to devices that have been installed in the system.  This information will be maintained by the BIOS in some form of nonvolatile storage.  Depending upon the amount of nonvolatile storage available to store system configuration information, one can either store detailed configuration information for all devices or limit the information to a description of the summary resource usage by the static ISA devices in the system.  In both cases, this information is to help the BIOS configure boot devices during the Power On Self Test (POST) phase.  See <B><I>Section 2.1.4</I></B> in the system POST area for a more complete description of the POST process.</P>
<B>Get &amp; Set Statically Allocated Resources</B></P>
Functions 9 and Ah allow the OS to effectively reserve resources allocated by legacy cards in a system. This provides a resource usage map for the BIOS to use to avoid resource conflicts when allocating resources to other  devices.  Only summary resource usage information by the legacy ISA cards must be stored in nonvolatile storage.  This information describes the cumulative usage of system resources by all legacy ISA cards but does not identify the specific resources used by each card.  The POST configuration software will use this information to avoid resource conflicts when configuring boot devices.  This solution can be implemented with minimum NVRAM; however, it does afford  less control over the configuration.  The example in section 4.7.1 describes how Plug and Play ISA resource descriptor information can be stored compactly.  The storage structure definition is left completely up to the OEM.</P>
The operating system should call function 9 to determine if the platform Plug and Play interface supports the ISA resource descriptors or not.  If this call returns without an error, it can be assumed that the platform is storing the ISA resource descriptor information in a proprietary bit map format.  If function calls 9 or 0Ah  return the USE_ESCD_SUPPORT error message, then the caller can assume that this platform supports the ESCD method of data storage.</P>
<B>Read &amp; Write Extended System Configuration Data (ESCD)</B></P>
The ESCD data storage method allows OEMs to differentiate a platform with additional Plug and Play features.  Since the data format stores information about which devices are using what resources, it is possible to maintain an image of the Last Working Configuration of all know devices.   Additionally, system software can modify the ESCD at runtime and affect the configuration of devices for the next boot.  This allows bootable devices to be enabled/disabled and other devices to be locked into specific configurations.  The ESCD also provides detailed configuration information about static devices allowing the POST configuration software to avoid conflicts with these cards.  In general, the ESCD allows the Plug and Play system BIOS to more fully configure the system at power up;  this is important for platforms that must support non-Plug and Play operating systems.</P>
The ESCD format describes every device in the system so storage requirements are much larger.  A typical platform requires 2-4KB of NVRAM.   The Plug and Play interface can support a function call  that allows the caller to Get NVRAM size attributes, and it supports two other functions that provide Read/Write access to the Extended System Configuration Data where it is stored in the NVRAM.  </P>
The operating system should call function 9 to determine which data storage format this platform's Plug and Play interface supports.  If the function 9 call returns without an error, it can be assumed that the platform is storing the ISA resource descriptor information in a proprietary bit map format.  If function calls 9 or 0Ah  return the USE_ESCD_SUPPORT error message, then the caller can assume that this platform supports the ESCD method of data storage.</P>
More detailed and current information about the ESCD definition and format specification can be found in the<I> ESCD Specification.</I></P>
<A NAME="PT2"></A>4.7.1 Function 9 - Set Statically Allocated Resource Information</P>
<B>Synopsis:</B></P>
  </P>
<BR></P>
<pre><code><I>int FAR (*entryPoint)(Function, ResourceBlock, BiosSelector);     </I>
int Function;                     /* PnP BIOS Function 9 */
unsigned char FAR *ResourceBlock; /* Block of statically allocated*/
                                  /*resources */
unsigned int BiosSelector;        /* PnP BIOS readable/writable*/
                                  /*selector */</code></pre>
  </P>
<B>Description:</B></P>
<I>Optional.  </I>This function will allow system software to report the system resources that are being utilized by the static ISA devices installed in the system.  The system software must pass a complete list of system resources used by ALL of the legacy ISA devices that are not located on the system board.  Therefore, any time a legacy ISA device is added or removed from the system, the system software must construct a new resource map and pass the information to the system BIOS by making this function call.  This information is important to the Plug and Play BIOS POST functionality for achieving the ability to bootstrap the operating system from a Plug and Play boot device by allowing the Plug and Play BIOS to configure the boot device around the legacy ISA devices.  The resources allocated to the legacy ISA devices in the system are reported in the <I>ResourceBlock</I> parameter.  The format of the data contained in the block follows the format defined in the <I>Plug and Play ISA Specification </I>under the section labeled <I>Plug and Play Resources.</I>  This data is provided as a series of data structures with each structure having a unique tag or identifier.  The resource descriptors supported by this function are the descriptors that describe IRQ, DMA, I/O addresses, and memory resources.  The resource information specified in this block must be terminated with an <I>END_TAG </I>resource descriptor.</P>
The <I>BiosSelector</I> parameter enables the system BIOS, if necessary, to update system variables that are contained in the system BIOS memory space.  If this function is called from protected mode, the caller must create a data segment descriptor using the 16-bit Protected Mode data segment base address specified in the Plug and Play Installation Check data structure, a limit of 64KB, and the descriptor must be read/write capable.  If this function is called from real mode, <I>BiosSelector </I>should be set to the Real Mode 16-bit data segment address as specified in the Plug and Play Installation Check structure.  Refer to section 4.4 above for more information on the Plug and Play Installation Check Structure and the elements that make up the structure.</P>
If this function returns USE_ESCD_SUPPORT, then reporting resources allocated to devices to the system BIOS must be handled through the interface defined by the <I>ESCD Specification </I>(see sections 4.7.4 - 4.7.6, functions 41h, 42h and 43h.).</P>
This function is available in real mode and 16-bit protected mode.</P>
<B>Returns:</B></P>
0 if successful - SUCCESS<BR>!0 if an error (Bit 7 set) or a warning occurred or no pending events - error code (The function return codes are described in Appendix C)</P>
The FLAGS and registers will be preserved, except for AX which contains the return code.</P>
<B>Example:</B></P>
The following example illustrates how the 'C' style call interface could be made from an assembly language module:</P>
  </P>
<BR></P>
<pre><code><B>          .</B>
          .
          .
     push    Bios Selector     
     push    segment/selector of the Resource Block   ; Pointer to the
                                                      ;data structure
                                                      ;of isa resources
     push    offset of Resource Block     
     push    SET_STATICALLY_ALLOCATED_RESOURCES       ; Function 9
     call    FAR PTR entryPoint     
     add     sp,8                     ; Clean up stack
     cmp     ax,SUCCESS               ; Function completed successfully?
     jne     error                    ; No-handle error condition
          .
          .
          .</code></pre>
  </P>
A BIOS implementor is only required to follow the interface described by this function.  The format of the data passed by the system software must follow the Plug and Play ISA resource descriptor definition.  How the statically allocated resource information is actually stored is left up to the BIOS implementor.  An example of how the information could be stored more compactly than the Plug and Play ISA resource descriptors is as follows:</P>
<P></P>

<TABLE COLS="3" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="46pt" VALIGN="TOP"><COL WIDTH="92pt" VALIGN="TOP"><COL WIDTH="330pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">IRQ</P></TD><TD VALIGN="TOP">2 Bytes - Bits set indicate IRQ used by unconfigurable ISA device</P></TD></TR><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">DMA</P></TD><TD VALIGN="TOP">1 Byte - Bits set indicate DMA used by unconfigurable ISA device</P></TD></TR><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">I/O </P></TD><TD VALIGN="TOP">24 Bytes - Bits set indicate I/O addresses used (100h-3ffh).  Assumes 4 ports used per I/O address bit set</P></TD></TR><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">Memory 640k to 1Mg </P></TD><TD VALIGN="TOP">3 Bytes - Represented in 16k blocks</P></TD></TR><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">Memory 1Mg to 16Mg</P></TD><TD VALIGN="TOP">2 Bytes - Represented in 1Mg increments.</P></TD></TR></TBODY></TABLE>
<BR></P>Storing the information this way would allow the system resources used by unconfigurable ISA devices to be contained in 32 bytes.</P>
  </P>
<B>Note   this is only an example.  It is completely up to the BIOS vendor to choose an appropriate format  for storing the data, which means it could possibly be stored in less than 32 bytes or require more than 32 bytes.</B>   </P>
  </P>
<A NAME="PT3"></A>4.7.2 Function 0Ah - Get Statically Allocated Resource Information</P>
<B>Synopsis:</B></P>
  </P>
<BR></P>
<pre><code><I>int FAR (*entryPoint)(Function, ResourceBlock, BiosSelector);     </I>
int Function;                     /* PnP BIOS Function 0Ah */
unsigned char FAR *ResourceBlock; /* Block of resources statically*/
                                  /*allocated to devices */
unsigned int BiosSelector;        /* PnP BIOS readable/writable*/
                                  /* selector */</code></pre>
  </P>
<B>Description:</B></P>
<I>Optional.  </I>This function will return the system resources that are being utilized by the legacy ISA devices that are installed in the system.  These system resources are the resources that have been reported to the system BIOS through the <I>Set Allocated ISA Resource Info</I> function.  The resources allocated to the legacy ISA devices in the system are reported in the <I>ResourceBlock </I>parameter.  It is important to note that the information returned represents the resource usage rounded up to the nearest granularity range supported by the system BIOS and not the actual resources used by the legacy ISA devices in the system.  It is recommended that the system software keep track of the system resources used by legacy ISA cards in order to account for the exact system resources usage of the legacy ISA cards installed in the system.  The format of the data contained in the block follows the format defined in the <I>Plug and Play ISA Specification </I>under the section labeled <I>Plug and Play Resources</I>.  This data is provided as a series of data structures with each structure having a unique tag or identifier.  The <I>ResourceBlock</I> must be a minimum of 2 Kbytes to ensure that there is adequate space for the system BIOS to return the legacy ISA resource information.</P>
The <I>BiosSelector</I> parameter enables the system BIOS, if necessary, to update system variables that are contained in the system BIOS memory space.  If this function is called from protected mode the caller must create a data segment descriptor using the 16-bit Protected Mode data segment base address specified in the Plug and Play Installation Check data structure, a limit of 64k, and the descriptor must be read/write capable.  If this function is called from real mode, <I>BiosSelector </I>should be set to the Real Mode 16-bit data segment address as specified in the Plug and Play Installation Check structure.  Refer to section 4.4 above for more information on the Plug and Play Installation Check Structure and the elements that make up the structure.</P>
If this function returns USE_ESCD_SUPPORT, then accessing the information describing the resources allocated to devices to the system BIOS must be handled through the interface defined by the <I>ESCD Specification.</I>  Refer to the <I>ESCD Specification </I>for a complete description of the interfaces to support the ESCD as well as the format of the ESCD.</P>
This function is available in real mode and 16-bit protected mode.</P>
<B>Returns:</B></P>
0 if successful - SUCCESS<BR>!0 if an error (Bit 7 set) or a warning occurred or no pending events - error code (The function return codes are described in Appendix C)</P>
The FLAGS and registers will be preserved, except for AX which contains the return code.</P>
<B>Example:</B></P>
The following example illustrates how the 'C' style call interface could be made from an assembly language module:</P>
  </P>
<BR></P>
<pre><code><B>          .</B>
     push    Bios Selector     
     push    segment/selector of the Resource Block   ; Pointer to the
                                                      ;data struct
                                                      ;of isa resources
     push    offset of Resource Block     
     push    GET_STATICALLY_ALLOCATED_RESOURCES       ; Function 0Ah
     call    FAR PTR entryPoint     
     add     sp,8                     ; Clean up stack
     cmp     ax,SUCCESS               ; Function completed successfully?
     jne     error                    ; No-handle error condition
          .</code></pre>
  </P>
<A NAME="PT4"></A>4.7.3 Function 40h - Get Plug &amp; Play ISA Configuration Structure</P>
<B>Synopsis:</B></P>
  </P>
<BR></P>
<pre><code><I>int FAR (*entryPoint)(Function, Configuration, BiosSelector);     </I>
int Function;            4         /* PnP BIOS Function 40h */
unsigned char FAR *Configuration;  /* Address of caller's config.*/
                                   /*structure buffer*/
unsigned int BiosSelector;         /* PnP BIOS readable/writable*/
                                   /*selector */ </code></pre>
  </P>
<B>Description:</B></P>
<I>Required.  </I>This function is used to get the Plug and Play ISA Configuration structure.  The Plug and Play ISA Configuration data structure contains configuration information specific to ISA Plug and Play support.  This function will copy the data structure to the caller's memory buffer specified by <I>Configuration</I>.  A system without any ISA bus capabilities will return the FUNCTION_NOT_SUPPORTED error code.  When the ISA bus is present, the fields in this data structure will be set with the appropriate values.  If the system BIOS did not identify any Plug and Play ISA cards in the system during POST, then the <I>Total number of Card Select Numbers</I> field will be zero and the value in the <I>ISA Read Data Port</I> field is invalid and must not be used by system software.  </P>
On systems with a dynamic ISA bus, like portables, function 40h will be more flexible. When an ISA bus is present, the information returned by function 40h will always be valid after a cold boot.  On a cold boot with no ISA bus present, function 40h will return zeros.  After an ISA warm/hot dock, the function 40h information will also be valid, if the plug and play BIOS isolates and enumerates the plug and play adapter cards before returning control to the plug and play operating system.  If the BIOS does not re-enumerate after an ISA warm/hot dock event, then the information returned by function 40h will be zeros.  After an ISA undock event, this information will also be zeros.</P>
The format of the Plug and Play ISA Configuration structure is defined as follows:</P>
</P>
  </P>

<TABLE COLS="4" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="209pt" VALIGN="TOP"><COL WIDTH="63pt" VALIGN="TOP"><COL WIDTH="81pt" VALIGN="TOP"><COL WIDTH="81pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><B>Field</B></P></TD><TD VALIGN="TOP"><B>Offset</B></P></TD><TD VALIGN="TOP"><B>Length</B></P></TD><TD VALIGN="TOP"><B>Value</B></P></TD></TR><TR><TD VALIGN="TOP">Structure Revision</P></TD><TD VALIGN="TOP">00h</P></TD><TD VALIGN="TOP">BYTE</P></TD><TD VALIGN="TOP">01</P></TD></TR><TR><TD VALIGN="TOP">Total number of Card Select Numbers (CSNs) assigned</P></TD><TD VALIGN="TOP">01h</P></TD><TD VALIGN="TOP">BYTE</P></TD><TD VALIGN="TOP">Varies</P></TD></TR><TR><TD VALIGN="TOP">ISA Read Data Port</P></TD><TD VALIGN="TOP">02h</P></TD><TD VALIGN="TOP">WORD</P></TD><TD VALIGN="TOP">Varies</P></TD></TR><TR><TD VALIGN="TOP">Reserved</P></TD><TD VALIGN="TOP">04h</P></TD><TD VALIGN="TOP">WORD</P></TD><TD VALIGN="TOP">0</P></TD></TR></TBODY></TABLE>
<BR></P><B><I>Structure Revision:</I></B></P>
This is an ordinal value that indicates the revision number of this structure only and does not imply a level of compliance with the Plug and Play BIOS version.</P>
<B><I>Total number of Card Select Numbers:</I></B></P>
This field specifies the total number of CSNs assigned to ISA Plug and Play cards by the system BIOS during the Power-On Self Test (POST).</P>
<B><I>ISA Read Data Port:</I></B></P>
The ISA Read Data Port is used to read information from the Plug and Play registers.  The value represented here is the I/O port that was determined by the system BIOS to not conflict with another ISA I/O port.  <I>Refer to the ISA Plug and Play Specification for more information on the ISA Read Data Port.</I></P>
The <I>BiosSelector</I> parameter enables the system BIOS, if necessary, to update system variables that are contained in the system BIOS memory space.  If this function is called from protected mode, the caller must create a data segment descriptor using the 16-bit Protected Mode data segment base address specified in the Plug and Play Installation Check data structure, a limit of 64KB, and the descriptor must be read/write capable.  If this function is called from real mode, <I>BiosSelector </I>should be set to the Real Mode 16-bit data segment address as specified in the Plug and Play Installation Check structure.  Refer to section 4.4 above for more information on the Plug and Play Installation Check Structure and the elements that make up the structure.</P>
This function is available in real mode and 16-bit protected mode.</P>
<B>Returns:</B></P>
0 if successful - SUCCESS<BR>!0 if an error (Bit 7 set) or a warning occurred - error code (The function return codes are described in Appendix C)</P>
The FLAGS and registers will be preserved, except for AX which contains the return code.</P>
<B>Example:</B></P>
The following example illustrates how the 'C' style call interface could be made from an assembly language module:</P>
  </P>
<BR></P>
<pre><code>     push    Bios Selector     
     push    segment/selector of Config. structure buffer      ; pointer
                                          ;to configuration data buffer
     push    offset of Configuration structure buffer     
     push    GET_ISA_CONFIG_STRUC         ; Function 40h
     call    FAR PTR entryPoint      
     add     sp,8                         ; Clean up stack
     cmp     ax,SUCCESS                   ; Function completed
                                          ;successfully?
     jne     error                        ; No-handle error condition
<B>          .</B>
          .
</code></pre>
  </P>
<A NAME="PT5"></A>4.7.4 Function 41h - Get Extended System Configuration Data (ESCD) Info</P>
<B>Synopsis:</B></P>
  </P>
<BR></P>
<pre><code><I>int FAR (*entryPoint)(Function, MinESCDWriteSize, ESCDSize, NVStorageBase,BiosSelector);     </I>
     
int Function;                      /* PnP BIOS Function 041h */
     
unsiged int FAR *MinESCDWriteSize; /* Minimum buffer size in bytes for*/
                                    /*writing to NVS */
unsigned int FAR *ESCDSize;         /* Size allocated for the ESCD... */
                                    /* .within the nonvolatile*/
                                    /*storage block */
unsigned long FAR *NVStorageBase;   /* 32-bit physical base*/
                                    /*address for.*/
                                    /* .mem mapped nonvolatile*/
                                    /*storage media */
unsigned int BiosSelector;          /* PnP BIOS readable/writable*/
                                    /*selector */ </code></pre>
  </P>
<B>Description:</B></P>
<I>Optional.  </I>This function provides information about the nonvolatile storage on the system that contains the Extended System Configuration Data (ESCD).  It returns the size, in bytes, of the minimum buffer required for writing to NVS in <I>MinESCDWriteSize</I>, the maximum size, in bytes, of the block within the nonvolatile storage area allocated specifically to the ESCD in <I>ESCDSize</I>, and if the nonvolatile storage is memory mapped, the 32-bit absolute physical base address will be returned in <I>NVStorageBase</I>.  The physical base address of the memory mapped nonvolatile storage will allow the caller to construct a 16-bit data segment descriptor with a limit of 64K and read/write access.  This will enable the Plug and Play system BIOS to read and write the memory mapped nonvolatile storage in a protected mode environment.  If the nonvolatile storage is not memory mapped the value returned in <I>NVStorageBase</I> should be 0.  It is assumed that the size of the nonvolatile storage that contains the ESCD will not exceed 32K bytes.   </P>
Refer to the <I>ESCD Specification </I>for a complete description of the interfaces to support the ESCD as well as the format of the ESCD.</P>
<A NAME="PT6"></A>4.7.5 Function 42h - Read Extended System Configuration Data (ESCD)</P>
<B>Synopsis:</B></P>
  </P>
<BR></P>
<pre><code>int FAR (*entryPoint)(Function, ESCDBuffer, ESCDSelector, BiosSelector)
int Function;                    /* PnP BIOS Function 042h */
char FAR *ESCDBuffer;            /* Addr of caller's buffer for storing ESCD */
unsigned int ESCDSelector;       /* ESCD readable/writable selector */ 
unsigned int BiosSelector;       /* PnP BIOS readable/writable selector */ </code></pre>
  </P>
<B>Description:</B></P>
<I>Optional.  </I>This function is used to read the ESCD data from nonvolatile storage on the system into the buffer specified by <I>ESCDBuffer.</I>  The entire ESCD will be placed into the buffer.  It is the responsibility of the caller to ensure that the buffer is large enough to store the entire ESCD.  The caller should use the output from Function 41 (the <I>ESCDSize</I> field) when calculating the size of the <I>ESCDBuffer</I>.  The system BIOS will return the entire ESCD, including information about system board devices.  The system board device configuration information will be contained in the slot 0 portion of the ESCD.   The caller can determine the size of the data in the ESCD from the <I>ESCD Configuration Header Structure</I>.   In protected mode, the <I>ESCDSelector</I> has base = <I>NVStorageBase</I> and limit of at least <I>NVStorageSize.</I> In real mode, the <I>ESCDSelector</I> is a segment that points to <I>NVStorageBase.</I></P>
Refer to the <I>ESCD Specification </I>for a complete description of the interfaces to support the ESCD as well as the format of the ESCD.  </P>
Implementation Note:  Functions Get/Set Statically Allocated Resource Information, and Read/Write Extended System Configuration Data are not required to be implemented on EISA systems. These four plug and play BIOS functions mentioned above may be implemented so that operating systems and utilities can use a single, consistent interface.  At a minimum, a plug and play EISA system is required to support the standard plug and play BIOS functions and include access to NVS through the EISA specific INT15 mechanism.</P>
<A NAME="PT7"></A>4.7.6 Function 43h - Write Extended System Configuration Data (ESCD)</P>
<B>Synopsis:</B></P>
  </P>
<BR></P>
<pre><code><I>int FAR (*entryPoint)(Function, ESCDBuffer, ESCDSelector, BiosSelector);     </I>
int Function;          /* PnP BIOS Function 043h */
char FAR *ESCDBuffer;  /* Buffer containing complete ESCD to write... */
                       /* to nonvolatile storage */
unsigned int ESCDSelector;     /* ESCD readable/writable selector */ 
unsigned int BiosSelector;     /* PnP BIOS readable/writable selector */ </code></pre>
  </P>
<B>Description:</B></P>
<I>Optional.  </I>This function will write the Extended Static Configuration Data (ESCD) contained in the <I>ESCDBuffer </I>to nonvolatile storage on the system.  The data contained in the caller's buffer must contain a complete block of ESCD structures describing the configuration information for devices on the system.  The caller should use the output from Function 41 (the MinESCDWriteSize field) when calculating the size of the <I>ESCDBuffer</I>.  The system BIOS can determine the size of the data in the ESCD structure from the <I>ESCD Configuration Header Structure </I>within the caller's ESCD buffer.   </P>
Refer to the <I>ESCD Specification </I>for a complete description of the interfaces to support the ESCD as well as the format of the ESCD.</P>
 </P></BODY></HTML>
