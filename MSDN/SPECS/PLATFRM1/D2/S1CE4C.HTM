<HTML><HEAD><META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Interrupt Distribution</TITLE><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">

</OBJECT></FORM>
<H2>Interrupt Distribution</H2>  </P>
Ideally, I/O interrupts are routed first to a processor already processing an interrupt for that vector (not level!) and, if no processor is processing an interrupt for that vector, then to the processor running at the lowest interrupt priority level.  Other interrupt distribution schemes can also be supported, with lower performance.</P>
Note that while only one interrupt from any priority level may be outstanding against any one processor at a time, it is possible to have multiple interrupts from the same level simultaneously handled by different processors.</P>
It is always necessary to be able to identify the source of the interrupt.  This could be done via vector, or via a source register read when the interrupt is raised.</P>
Windows NT supports interrupt vectors shared among devices, but of course, only one interrupt from a given vector may be processed at a time, so shared vectors do not fully support parallel interrupt processing.</P>
 </P></BODY></HTML>
