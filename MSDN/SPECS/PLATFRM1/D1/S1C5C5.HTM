<HTML><HEAD><META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>COMMANDS</TITLE><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">

</OBJECT></FORM>
<H2>COMMANDS</H2>  </P>
<A NAME="PT2"></A>DCICreatePrimarySurface</P>
A DCI client makes the GDI <B>Escape</B> call with these parameters to a DCI Provider to request access to the primary display surface. The DCI Provider returns access to the entire surface area; it is the DCI Client's responsibility to position the image at the appropriate coordinate location. </P>
<B>uint Escape (</B><I>hdc</I><B>, DCICOMMAND, sizeof(DCICREATEINPUT), <BR>     (LPDCICREATEINPUT)</B><I>lpInput</I><B>, LPDCIPRIMARY </B><I>*lpSurface</I><B>);</B></P>
<P></P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="154pt" VALIGN="TOP"><COL WIDTH="298pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><I>hdc</I></P></TD><TD VALIGN="TOP">Device context being queried for DCI support.</P></TD></TR><TR><TD VALIGN="TOP">       <I>lpInput</I></P></TD><TD VALIGN="TOP">DCI Client provided<B> DCICREATEINPUT </B>structure with input parameters.</P></TD></TR><TR><TD VALIGN="TOP"><I>lpSurface</I></P></TD><TD VALIGN="TOP">DCI Client provided DWORD for the DCI Provider to put a far pointer to the <B>DCIPRIMARY</B> structure to be returned.  This structure must be allocated by the DCI Provider.</P></TD></TR></TBODY></TABLE>
<BR></P><A NAME="PT3"></A>INPUT PARAMETERS</P>
A DCI Client issuing this DCI Command will set the following fields of the <B>DCICREATEINPUT</B> structure:</P>
<P></P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="172pt" VALIGN="TOP"><COL WIDTH="280pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><B>dwCommand</B></P></TD><TD VALIGN="TOP">Set to the constant DCICREATEPRIMARYSURFACE. </P></TD></TR><TR><TD VALIGN="TOP"><B>dwVersion</B></P></TD><TD VALIGN="TOP">Set to 0x0100 for DCI 1.0.</P></TD></TR></TBODY></TABLE>
<BR></P><A NAME="PT4"></A>RETURNS</P>
A DCI Provider responding to this DCI Command must set the following fields of the <B>DCIPRIMARY</B> structure it returns:</P>
<P></P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="172pt" VALIGN="TOP"><COL WIDTH="280pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><B>dwSize</B></P></TD><TD VALIGN="TOP">DCI Provider must provide the size of the structure created.  This size must be no smaller than <B>sizeof</B>(<B>DCIPRIMARY</B>).  It can be larger, should the DCI Provider need to maintain instance data.</P></TD></TR><TR><TD VALIGN="TOP"><B>dwDCICaps</B></P></TD><TD VALIGN="TOP">At a minimum, DCI_PRIMARY | DCI_VISIBLE must be set.</P>
DCI_1632_ACCESS must be set if the surface uses bank-switched memory and will be accessed via a VFlatD linear-access mechanism.</P></TD></TR><TR><TD VALIGN="TOP"><B>dwCompression</B></P></TD><TD VALIGN="TOP">Access is being requested to the default display driver mode.  The DCI provider must provide the FOURCC of the current display format.  This field must be set to BI_BITFIELDS, if the current display mode is a nonstandard RGB mode </P>
If the format of the frame buffer is different from the current default display driver mode (i.e., GDI is passing 24-bit RGB data, but the display driver is converting this to 16-bit RGB data before writing the data to the frame buffer), then the provider should return the format of the frame buffer.</P></TD></TR><TR><TD VALIGN="TOP"><B>dwMask</B></P></TD><TD VALIGN="TOP">If the current display mode is a nonstandard RGB mode, the DCI provider must set the <B>dwMask</B> fields appropriately. The masks define bit packing -- <B>dwMask</B>[0] is the red mask; <B>dwMask</B>[1] is the green mask; <B>dwMask</B>[2] is the blue mask.</P>
If the format of the frame buffer is different from the current default display driver mode (i.e., GDI is passing 24-bit RGB data, but the display driver is converting this to 16-bit RGB data before writing the data to the frame buffer), then the provider should return the appropriate masks of the frame buffer.</P></TD></TR><TR><TD VALIGN="TOP"><B>dwWidth</B></P></TD><TD VALIGN="TOP">DCI Provider specifies the width of the screen in pixels.</P></TD></TR><TR><TD VALIGN="TOP"><B>dwHeight</B></P></TD><TD VALIGN="TOP">DCI Provider specifies the height of the screen in pixels.</P></TD></TR><TR><TD VALIGN="TOP"><B>lStride</B></P></TD><TD VALIGN="TOP">Specifies the width in bytes of the surface.  The width provided will be used as a stride in performing columnar accesses.  A bottom to top device must set the origin to point to the lowest scan line and provide a negative stride.</P></TD></TR><TR><TD VALIGN="TOP"><B>dwBitCount</B></P></TD><TD VALIGN="TOP">Access is being requested to the default display driver mode.  DCI Provider must set the bit depth of the current display format.</P>
If the format of the frame buffer is different from the current default display driver mode (i.e., GDI is passing 24-bit RGB data, but the display driver is converting this to 16-bit RGB data before writing the data to the frame buffer), then the provider should return the bit depth of the frame buffer.</P></TD></TR><TR><TD VALIGN="TOP"><B>dwOffSurface</B></P></TD><TD VALIGN="TOP"></P></TD></TR><TR><TD VALIGN="TOP"><B>wSelSurface</B></P></TD><TD VALIGN="TOP"><B>wSelSurface:dwOffSurface</B> is the pointer to the surface.  This pointer must be generated at the time <B>CreateSurface</B>.  Note that this is a 48-bit (16:32) pointer is called.  The DCI Client will access it in this manner.  Huge-pointer arithmetic will not be applied here.</P>
If the surface to be accessed is on a bank-switched memory device, the Surface Provider must install a suitable bank-switch handling routine, so that the DCI Client is "tricked" into viewing the entire memory range as a linear memory range.</P></TD></TR><TR><TD VALIGN="TOP"><B>BeginAccess</B></P></TD><TD VALIGN="TOP">Called by DCI Client before accessing the surface.  This function must return a status code when invoked. It is legal for the DCI Provider to fail the call at the time of invocation.  A suitable error code must be returned to indicate the cause of failure.</P>
<B>Note:</B> This pointer may be NULL, if the DCI Provider does not need to take any action corresponding to a <B>BeginAccess</B> call.  </P></TD></TR><TR><TD VALIGN="TOP"><B>EndAccess</B></P></TD><TD VALIGN="TOP">Called by DCI Client at the end of access to display surface.  </P>
<B>Note:</B> This pointer may be NULL, if the DCI Provider does not need to take any action corresponding to an <B>EndAccess</B> call.</P></TD></TR><TR><TD VALIGN="TOP"><B>DestroySurface</B></P></TD><TD VALIGN="TOP">Called by DCI Client when the Client will no longer be using the surface.  The DCI Provider must free all resources allocated when this surface was created.</P></TD></TR></TBODY></TABLE>
<BR></P><A NAME="PT5"></A>COMMENTS</P>
<B>BeginAccess</B> and <B>EndAccess</B> are called as a framework around every set of accesses to the display buffer.  The DCI Client must not access surface memory before a <B>BeginAccess</B> or after an <B>EndAccess</B>.  At <B>BeginAccess</B>, the DCI Provider must ensure that valid access is available to the memory range specified by the <B>wSelSurface:dwOffSurface </B>pointer.  </P>
The DCI Provider may change <I>any</I> and <I>all</I><B> </B>fields in the <B>DCIPRIMARY</B> structure at <B>BeginAccess</B>.  If any changes are made to the <B>DCIPRIMARY</B> structure the DCI Provider must return a suitable status code.  No notification need be returned when callback addresses are changed; the DCI Client cannot assume that these addresses will remain unchanged.</P>
The DCI Client is encouraged to minimize processing time between <B>BeginAccess/EndAccess</B>.  Similarly the DCI Provider is encouraged to optimize the speed of these calls so that the DCI Client does not incur a stiff penalty on each direct access of a surface.  It is valid to return NULL pointers if no action need be taken by the DCI Provider.  </P>
The DCI Provider must manage the mouse cursor during surface accesses.  The DCI Client will provide the bounding rectangle of the area that will be accessed.  The DCI Provider must exclude the cursor at <B>BeginAccess</B>, if the mouse cursor is within this area.  At <B>EndAccess</B>, the DCI Provider must turn the mouse back on, if it was previously excluded.</P>
 </P>
<A NAME="PT6"></A>DCIEnumSurface</P>
  </P>
A DCI client makes a <B>DCIEnumSurface</B> call to a DCI provider to determine what enhanced support, if any, the DCI provider provides.</P>
<B>uint Escape (</B><I>hdc</I><B>, DCICOMMAND, sizeof(DCIENUMINPUT), <BR>     (LPDCIENUMINPUT)</B><I>lpInput</I><B>, (LPVOID)</B><I>NULL</I><B>);</B></P>
<P></P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="172pt" VALIGN="TOP"><COL WIDTH="280pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><I>hdc</I></P></TD><TD VALIGN="TOP">Device context being queried for DCI support.</P></TD></TR><TR><TD VALIGN="TOP"><I>lpInput</I></P></TD><TD VALIGN="TOP">DCI Client provided<B> DCIENUMINPUT </B>structure with input parameters.</P></TD></TR></TBODY></TABLE>
<BR></P><A NAME="PT7"></A>INPUT PARAMETERS</P>
A DCI Client issuing this DCI Command will set the following fields of the <B>DCIENUMINPUT</B> structure:</P>
<P></P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="172pt" VALIGN="TOP"><COL WIDTH="280pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><B>dwCommand</B></P></TD><TD VALIGN="TOP"><B>DCIENUMSURFACE.</B></P></TD></TR><TR><TD VALIGN="TOP"><B>rDest</B>, <B>rSrc</B></P></TD><TD VALIGN="TOP">Rectangular size of destination and source.  The combination of these parameters defines any stretching requirements.  </P>
<B>Note:</B> It is legal for the rectangles to be set to NULL, meaning the client is asking for an enumeration of the largest available surface.  The provider should respond by enumerating the largest surface available in each offscreen or overlay format.</P></TD></TR><TR><TD VALIGN="TOP"><B>EnumCallback</B></P></TD><TD VALIGN="TOP">Callback function provided by caller.  The DCI provider uses this function to inform the caller of the list of color formats supported for the given input parameters.</P></TD></TR><TR><TD VALIGN="TOP"><B>lpContext</B></P></TD><TD VALIGN="TOP">Pointer that identifies the DCI Client's context.  This parameter must be passed back to the DCI Client as a parameter to <B>EnumCallback</B>.</P></TD></TR></TBODY></TABLE>
<BR></P><A NAME="PT8"></A>EnumCallback</P>
DCI Providers indicate support for each surface they support by returning a SurfaceInfo structure that describes the surface.  The DCI Client is being provided the parameters for READ purposes only, and therefore there is no guarantee that the structure will be valid after the callback.  The surface itself need not be created, but fields corresponding to an actual creation must be filled and returned.</P>
<B>void EnumCallback(LPDCISURFACEINFO</B><I> lpSurface</I><B>, LPVOID </B><I>lpContext</I><B>);</B></P>
The following fields of the <B>DCISURFACEINFO</B> passed back to the DCI Client in the <I>lpSurface</I> parameter are must be filled by the DCI Provider:</P>
<P></P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="172pt" VALIGN="TOP"><COL WIDTH="280pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><B>dwSize</B></P></TD><TD VALIGN="TOP">Set to size of structure.  This size must be no smaller than <B>sizeof(DCISURFACEINFO)</B>.  </P></TD></TR><TR><TD VALIGN="TOP"><B>dwDCICaps</B></P></TD><TD VALIGN="TOP">Flags that indicate the kind of support available for the surface being promised.  Capability flags are defined in Chapter 2.</P></TD></TR><TR><TD VALIGN="TOP"><B>dwCompression</B></P></TD><TD VALIGN="TOP">The DCI Provider provides the FOURCC of the surface that it can create.  This field must be set to BI_BITFIELDS, if the current display mode is a nonstandard RGB mode.</P></TD></TR><TR><TD VALIGN="TOP"><B>dwMask</B></P></TD><TD VALIGN="TOP">If promised support mode is a nonstandard RGB mode, the DCI provider must set <B>dwMask</B> fields appropriately. The masks define the bit packing.  <B>dwMask</B>[0] is the red mask; <B>dwMask</B>[1] is the green mask; <B>dwMask</B>[2] is the blue mask.</P></TD></TR><TR><TD VALIGN="TOP"><B>dwWidth</B></P></TD><TD VALIGN="TOP">DCI Provider specifies the width of the surface in pixels.</P></TD></TR><TR><TD VALIGN="TOP"><B>dwHeight</B></P></TD><TD VALIGN="TOP">DCI Provider specifies the height of the surface in pixels.</P></TD></TR><TR><TD VALIGN="TOP"><B>lStride</B></P></TD><TD VALIGN="TOP">Specifies the width in bytes of the surface.  The width provided will be used as a stride in performing columnar accesses.  A bottom-to-top device must set the origin to point to the lowest scanline and provide a negative stride.  For subsampled planar formats, the stride of the subsampled planes will be proportional to the subsampling ratio.  </P></TD></TR><TR><TD VALIGN="TOP"><B>dwBitCount</B></P></TD><TD VALIGN="TOP">Access is being requested to the default display driver mode.  DCI Provider must set the bit depth of the current display format.</P></TD></TR></TBODY></TABLE>
<BR></P><A NAME="PT9"></A>COMMENTS</P>
The DCI Provider calls <B>EnumCallback</B> to indicate offscreen and/or overlay surface support.  While calling the callback, the DCI Provider passes to the DCI Client the <I>lpContext</I><B> </B>parameter that was passed down previously.  </P>
A surface described through a call to <B>EnumCallback</B> is determined by the resources available at the time it is called.  At a later time, even with the same input parameters, the DCI Provider could return a different level of support based upon different resource availability.  In a multitasking environment, resources could get absorbed by a different task between a given tasks call to <B>EnumSurface</B> and the subsequent call to <B>CreateOffscreenSurface</B>.  Hence, enumeration is only a conditional promise of support; it is legal for a subsequent <B>CreateOffscreenSurface</B> to fail.  </P>
If more than one color format is supported, the DCI Provider must call <B>EnumCallback</B> repeatedly to describe each color format.  The DCI Provider must only return from <B>DCIENUMSURFACE</B> after all available surfaces are described.  </P>
The DCI provider must examine the stretching factor requested via the <I>rDest</I> and the <I>rSrc</I> parameters.  Given the stretch factor, the DCI provider must call <B>EnumCallback</B> and provide the color format that the DCI provider will accept.  If a color format is not supported for the given stretch factor, <B>EnumCallback</B> must not be called for that color format.</P>
A call of <B>EnumCallback</B> does not create or grant access to the surface described.  Therefore, the callback fields of the <B>DCISURFACEINFO</B>, and the parameters of <B>BeginAccess</B>, <B>EndAccess</B>, and <B>DestroySurface</B>, should be NULL.</P>
 </P>
<A NAME="PT10"></A>DCICreateOffScreenSurface</P>
  </P>
A DCI client makes the GDI Escape call with these parameters to a DCI Provider to request access to access an offscreen surface.  The DCI Client will tell the DCI Provider about the format of the requested Surface based upon the capabilities returned by a previous  <B>DCIEnumSurface</B> call.  DCI providers who indicated support for offscreen surfaces must support this call and return the corresponding <B>DCISURFACEINFO</B>. </P>
<B>uint Escape (</B><I>hdc</I>,<B> DCICOMMAND, sizeof(DCICREATEINPUT), </B><BR>     <B>(LPDCICREATEINPUT)</B><I>lpInput</I>,<B> LPDCIOFFSCREEN </B><I>*lpSurface);</I></P>
<P></P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="172pt" VALIGN="TOP"><COL WIDTH="280pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><I>hdc</I></P></TD><TD VALIGN="TOP">Device context being queried for DCI support.</P></TD></TR><TR><TD VALIGN="TOP">       <I>lpInput</I></P></TD><TD VALIGN="TOP">DCI Client provided<B> </B>DCICREATEINPUT<B> </B>structure with input parameters.</P></TD></TR><TR><TD VALIGN="TOP"><I>lpSurface</I></P></TD><TD VALIGN="TOP">DCI Client provided DWORD for the DCI Provider to put a far pointer to the <B>DCIOFFSCREEN</B> structure to be returned.  This structure must be allocated by the DCI Provider.</P></TD></TR></TBODY></TABLE>
<BR></P><A NAME="PT11"></A>INPUT PARAMETERS</P>
A DCI Client issuing this DCI Command will set the following fields of the <B>DCICREATEINPUT</B> structure:</P>
<P></P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="172pt" VALIGN="TOP"><COL WIDTH="280pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><B>dwCommand</B></P></TD><TD VALIGN="TOP"><B>DCICREATEOFFSCREENSURFACE</B>.</P></TD></TR><TR><TD VALIGN="TOP"><B>dwVersion</B></P></TD><TD VALIGN="TOP">0x0100 for DCI 1.0.</P></TD></TR><TR><TD VALIGN="TOP"><B>dwCompression</B></P></TD><TD VALIGN="TOP">FOURCC format of surface to be created.  The definition of each of these formats are provided in the attached format documentation. This field will be set to BI_BITFIELDS, if the surface to be created is a non-standard RGB.</P></TD></TR><TR><TD VALIGN="TOP"><B>dwMask</B></P></TD><TD VALIGN="TOP">If <B>dwCompression</B> is BI_BITFIELDS, these masks define the bit packing.  <B>dwMask</B>[0] is the red mask; <B>dwMask</B>[1] is the green mask; <B>dwMask</B>[2] is the blue mask.</P></TD></TR><TR><TD VALIGN="TOP"><B>dwWidth</B></P></TD><TD VALIGN="TOP">Width of the surface to be created in pixels.</P></TD></TR><TR><TD VALIGN="TOP"><B>dwHeight</B></P></TD><TD VALIGN="TOP">Height of the surface to be created in pixels.</P></TD></TR><TR><TD VALIGN="TOP"><B>dwDCICaps</B></P></TD><TD VALIGN="TOP">Describes the capabilities the DCI Client is requesting for this surface.  This flag should describe exactly a surface described by the DCI Provider in a call to an <B>EnumCallback</B>.</P></TD></TR></TBODY></TABLE>
<BR></P><A NAME="PT12"></A>RETURNS</P>
A DCI Provider responding to this DCI Command must set the following fields of the <B>DCIOFFSCREEN</B> structure it returns:</P>
<P></P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="172pt" VALIGN="TOP"><COL WIDTH="280pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><B>dwSize</B></P></TD><TD VALIGN="TOP">DCI Provider must provide the size of the structure created.  This size must be no smaller than <B>sizeof(DCIOFFSCREEN)</B>.  It can be larger, should the DCI Provider need to maintain additional private information pertinent to the object created.</P></TD></TR><TR><TD VALIGN="TOP"><B>dwDCICaps</B></P></TD><TD VALIGN="TOP">At a minimum, DCI_OFFSCREEN must be set.  </P></TD></TR><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">DCI_1632_ACCESS must be set if the surface uses bank-switched memory and will be accessed via a VFlatd linear-access mechanism.</P></TD></TR><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">The DCI Provider must set stretching flags to match the stretching that is active on the surface.</P></TD></TR><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">The DCI Provider must set DCI_VISIBLE if data drawn to this offscreen surface will become instantaneously visible without invoking the <B>Draw</B> callback function.</P></TD></TR><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">The DCI Provider may also set other capability flags.  These flags only promise support; they do not indicate that the support has been activated.</P></TD></TR><TR><TD VALIGN="TOP"><B>dwCompression</B></P></TD><TD VALIGN="TOP">DCI Provider must set the FOURCC format of the surface being created.</P></TD></TR><TR><TD VALIGN="TOP"><B>dwMask</B></P></TD><TD VALIGN="TOP">If the <B>dwCompression</B> field is set to BI_BITFIELDS, specifying a nonstandard bit packing for RGB16, 24 or 32, this field must be set properly. The masks define the bit packing.  <B>dwMask</B>[0] is the red mask; <B>dwMask</B>[1] is the green mask; <B>dwMask</B>[2] is the blue mask.</P></TD></TR><TR><TD VALIGN="TOP"><B>dwWidth</B></P></TD><TD VALIGN="TOP">DCI Provider specifies the width of the surface in pixels.</P></TD></TR><TR><TD VALIGN="TOP"><B>dwHeight</B></P></TD><TD VALIGN="TOP">DCI Provider specifies the height of the surface in pixels.</P></TD></TR><TR><TD VALIGN="TOP"><B>lStride</B></P></TD><TD VALIGN="TOP">Specifies the pitch of the surface in bytes .  The value provided will be used as a stride in performing columnar accesses.  A bottom-to-top device must set the origin to point to the lowest scanline and provide a negative stride.  For subsampled planar formats, the stride of the subsampled planes will be proportional to the subsampling ratio.  </P></TD></TR><TR><TD VALIGN="TOP"><B>dwBitCount</B></P></TD><TD VALIGN="TOP">DCI Provider must set the bit depth of surface being created.</P></TD></TR><TR><TD VALIGN="TOP"><B>dwOffSurface</B></P></TD><TD VALIGN="TOP"></P></TD></TR><TR><TD VALIGN="TOP"><B>wSelSurface</B></P></TD><TD VALIGN="TOP"><B>wSelSurface:dwOffSurface</B> is the pointer to the surface. This pointer must be generated at the time of <B>CreateSurface</B>.  Note that this is a 48-bit (16:32) pointer.  The DCI Client  must access it in this manner.  Huge pointer arithmetic cannot be applied here.  </P></TD></TR><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">If the surface to be accessed is on a bank-switched memory device, then the surface provider must install a suitable bank-switch handling routine, so that the DCI Client is "tricked" into viewing the entire memory range as a linear memory range.</P></TD></TR><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">These fields may be invalid until the DCI Client calls the <B>SetDestination</B> callback.</P></TD></TR><TR><TD VALIGN="TOP"><B>BeginAccess</B></P></TD><TD VALIGN="TOP">Called by DCI Client at the beginning of a draw operation.  This function must return a status code when invoked. It is legal for the DCI Provider to fail the call at the time of invocation.  A suitable error code must be returned to indicate the cause of failure.<B> </B></P></TD></TR><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP"><B>Note:</B> This pointer may be NULL, if the DCI Provider does not need to take any action corresponding to <B>BeginAccess</B>.</P></TD></TR><TR><TD VALIGN="TOP"><B>EndAccess</B></P></TD><TD VALIGN="TOP">Called by DCI Client at the end of access  to display surface.  </P></TD></TR><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP"><B>Note</B>: This pointer may be NULL, if the DCI Provider does not need to take any action corresponding to <B>EndAccess</B>.</P></TD></TR><TR><TD VALIGN="TOP"><B>DestroySurface</B></P></TD><TD VALIGN="TOP">Called by DCI Client when the Client will no longer be using the surface.  The DCI Provider must free all resources allocated when this surface was created.</P></TD></TR><TR><TD VALIGN="TOP"><B>Draw</B></P></TD><TD VALIGN="TOP">Called by DCI Client when data from an offscreen surface must be copied to the screen.  Parameters specifying the transfer are those in effect from the last <B>SetDestination</B> and <B>SetCliplist</B> calls.</P></TD></TR><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">This function is called following a <B>BeginAccess</B> and an <B>EndAccess</B> call.</P></TD></TR><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">This function must return a status code when invoked.  It is legal for the DCI Provider to fail the call. at the time of invocation.  A suitable error code must be returned to indicate the cause of failure.</P></TD></TR><TR><TD VALIGN="TOP"><B>SetDestination</B></P></TD><TD VALIGN="TOP">Called by DCI Client to describe the extent of the destination surface.  This function will be called to reflect window moves or size changes.  The source rectangle is also provided in this call to define any clipping or stretching necessary.  This call can be rejected if the parameters provided cannot be supported.</P></TD></TR><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">Before a call to <B>SetDestination</B>, the DCI Provider does not know where this surface should appear when mapped to the screen.  Therefore, the DCI Client must make this call before calling <B>SetClipList</B>, <B>BeginAccess</B>, or <B>Draw</B>.  If a change is needed, the DCI Provider can update the wSelSurface and <B>dwOffSurface</B> fields of the <B>DCIOFFSCREEEN</B> structure on the next call to <B>BeginAccess</B> and return the DCI_STATUS_POINTERCHANGED status code.  Then the surface is considered initialized.</P></TD></TR><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">This function must return a status code when invoked. It is legal for the DCI Provider to fail the call at the time of invocation.  A suitable error code must be returned to indicate the cause of failure.</P></TD></TR><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP"><B>Note:</B> The client may call <B>SetDestination</B> with the source rectangle pointer set to NULL.  This indicates that the entire offscreen surface is to be mapped to the given destination screen rectangle.</P></TD></TR><TR><TD VALIGN="TOP"><B>SetCliplist</B></P></TD><TD VALIGN="TOP">The DCI Client calls this function to tell the DCI Provider about changes to the overlap status of the window in which drawing is occurring.  Support of this function is required for all offscreen surfaces.</P></TD></TR><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">The DCI Provider will be passed a <B>RGNDATA</B> structure describing the visible area.  The <B>lpBuffer</B> field of the <B>RGNDATA</B> structure is in an array of rectangles.  Fields within the header preceding the array define the length of the array.  The walk order of the rectangles is left-to-right, top-to-bottom.</P></TD></TR><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">This function must return a status code when invoked.  It is legal for the DCI Provider to fail the call. at the time of invocation.  A suitable error code must be returned to indicate the cause of failure.</P></TD></TR><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">It is the DCI Client's responsibility to ensure the bounding rectangle returned in the rcBound field of the <B>RGNDATAHEADER</B> structure intersects the destination rectangle in a prior <B>SetDestination</B> call.  The very first <B>SetClipList</B> call must be preceded by a <B>SetDestination</B> call.</P></TD></TR></TBODY></TABLE>
<BR></P><A NAME="PT13"></A>COMMENTS</P>
<B>BeginAccess</B> and <B>EndAccess</B> are called as a framework around every set of accesses to the display buffer.  The DCI Client must not access surface memory before a <B>BeginAccess</B> or after an <B>EndAccess</B>.  At <B>BeginAccess</B>, the DCI Provider must ensure that valid access is available to the memory range specified by the <B>wSelSurface:dwOffSurface </B>pointer.  </P>
The DCI Provider may change <I>any</I> and <I>all</I><B> </B>fields in the <B>DCIOFFSCREEN</B> structure at <B>BeginAccess</B>.  If any changes are made to the <B>DCISURFACEINFO</B> portion of <B>DCIOFFSCREEN</B> structure, the DCI Provider must return a suitable notification status code.  No notification need be returned when callback addresses are changed; the DCI Client cannot assume that these addresses will remain unchanged.</P>
The DCI Client is encouraged to minimize processing time between <B>BeginAccess/EndAccess</B>.  Similarly the DCI Provider is encouraged to optimize the speed of these calls so that the DCI Client does not incur a stiff penalty on each direct access of a surface.  It is valid to return NULL pointers if no action need be taken by the DCI Provider.  </P>
The DCI Provider must manage the mouse cursor during surface accesses.  The DCI Client will provide the bounding rectangle of the area that will be accessed.  The DCI Provider must exclude the cursor at <B>BeginAccess</B>, if the mouse cursor is within this area.  At <B>EndAccess</B>, the DCI Provider must turn the mouse back on, if it was previously excluded.</P>
Offscreen surfaces need not reside on the graphics memory itself. It is conceivable for the DCI provider to provide access to a system memory buffer as an offscreen surface.  This is particularly attractive for devices with special blitters and limited graphics board memory.</P>
 </P>
<A NAME="PT14"></A>DCICreateOverlaySurface</P>
  </P>
Called by the DCI Client when the DCI Client wants access to overlay control buffers.  Overlay buffers control merging of an offscreen surface with the primary display surface.  Hence, the DCI Client will already have created an offscreen surface prior to calling this function.  The DCI Client invokes this function only if DCI_CANOVERLAY has been set on the offscreen surface.</P>
<B>uint Escape (</B><I>hdc</I><B>, DCICOMMAND, sizeof(DCICREATEINPUT), <BR>     (LPDCICREATEINPUT)</B><I>lpInput</I><B>, LPDCIOVERLAY </B><I>*lpSurface</I><B>);</B></P>
<P></P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="172pt" VALIGN="TOP"><COL WIDTH="280pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><I>hdc</I></P></TD><TD VALIGN="TOP">Device context being queried for DCI support.</P></TD></TR><TR><TD VALIGN="TOP"><I>lpInput</I></P></TD><TD VALIGN="TOP">DCI Client provided<B> DCICREATEINPUT </B>structure with input parameters.</P></TD></TR><TR><TD VALIGN="TOP"><I>lpSurface</I></P></TD><TD VALIGN="TOP">DCI Client provided DWORD for the DCI Provider to put a far pointer to the <B>DCIOVERLAY</B> structure to be returned.  This structure must be allocated by the DCI Provider.</P></TD></TR></TBODY></TABLE>
<BR></P><A NAME="PT15"></A>INPUT PARAMETERS</P>
A DCI Client issuing this DCI Command will set the following fields of the <B>DCICREATEINPUT</B> structure:</P>
<P></P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="172pt" VALIGN="TOP"><COL WIDTH="280pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><B>dwCommand</B></P></TD><TD VALIGN="TOP"><B>DCICREATEOVERLAYSURFACE.</B></P></TD></TR><TR><TD VALIGN="TOP"><B>dwVersion</B></P></TD><TD VALIGN="TOP">0x0100 for DCI 1.0.</P></TD></TR><TR><TD VALIGN="TOP">  <B>lpOffScreenSurface</B></P></TD><TD VALIGN="TOP">The DCI Client provides the handle of the previously created DCI surface on which the overlay functionality is to be exercised.</P></TD></TR></TBODY></TABLE>
<BR></P><A NAME="PT16"></A>RETURNS</P>
A DCI Provider responding to this DCI Command must set the following fields of the <B>DCIOVERLAY</B> structure it returns:</P>
<P></P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="172pt" VALIGN="TOP"><COL WIDTH="280pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><B>dwSize</B></P></TD><TD VALIGN="TOP">DCI Provider must provide the size of the structure created.  This size must be no smaller than <B>sizeof(DCIOVERLAY)</B>.  It can be larger, should the DCI Provider need to maintain additional private information pertinent to the object created.</P></TD></TR><TR><TD VALIGN="TOP"><B>dwDCICaps</B></P></TD><TD VALIGN="TOP">At a minimum,  DCI_OVERLAY must be set.  </P></TD></TR><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">DCI_1632_ACCESS must be set if the surface uses bank-switched memory and will be accessed via a VFlatd linear access mechanism.</P></TD></TR><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">If overlay is being provided through chromakeying, DCI_CHROMAKEY must be set and the value used for chromakeying must be set in <B>dwChromakeyValue</B>.</P></TD></TR><TR><TD VALIGN="TOP"><B>dwMask</B></P></TD><TD VALIGN="TOP">If the <B>dwCompression</B> field is set to BI_BITFIELDS, specifying a nonstandard bit packing for RGB16, 24 or 32, this field must be set properly. The masks define the bit packing.  <B>dwMask</B>[0] is the red mask; <B>dwMask</B>[1] is the green mask; <B>dwMask</B>[2] is the blue mask.</P></TD></TR><TR><TD VALIGN="TOP"><B>dwCompression</B></P></TD><TD VALIGN="TOP">FOURCC of overlay buffer.  The definition of each of these image formats are provided in the attached format documentation.  If the overlay is to be performed via the default display mode, <B>dwCompression</B> field must be set to 0.  If the surface is a nonstandard RGB mode, <B>dwCompression</B> must be set to BI_BITFIELDS. </P></TD></TR><TR><TD VALIGN="TOP"><B>dwMask</B></P></TD><TD VALIGN="TOP">If <B>dwCompression</B> is BI_BITFIELDS, these masks define the bit packing.  <B>dwMask</B>[0] is the red mask; <B>dwMask</B>[1] is the green mask; <B>dwMask</B>[2] is the blue mask. </P></TD></TR><TR><TD VALIGN="TOP"><B>dwWidth</B></P></TD><TD VALIGN="TOP">DCI Provider specifies the width of the surface in pixels.</P></TD></TR><TR><TD VALIGN="TOP"><B>dwHeight</B></P></TD><TD VALIGN="TOP">DCI Provider specifies the height of the surface in pixels.</P></TD></TR><TR><TD VALIGN="TOP"><B>lStride</B></P></TD><TD VALIGN="TOP">Specifies the width in bytes of the surface.  The width provided will be used as a stride in performing columnar accesses.  A bottom-to-top device must set the origin to point to the lowest scanline and provide a negative stride.  For subsampled planar formats, the stride of the subsampled planes will be proportional to the subsampling ratio.  </P></TD></TR><TR><TD VALIGN="TOP"><B>dwBitCount</B></P></TD><TD VALIGN="TOP">DCI Provider must set the bit depth of surface being created.</P></TD></TR><TR><TD VALIGN="TOP"><B>dwOffSurface</B></P></TD><TD VALIGN="TOP"></P></TD></TR><TR><TD VALIGN="TOP"><B>wSelSurface</B></P></TD><TD VALIGN="TOP">For access to an overlay/chromakey buffer, <B>wSelSurface:dwOffSurface</B> is the pointer to the surface.  This pointer must be generated at the time of <B>CreateSurface</B>.  If the overlay/chromakey buffer is to be accessed via the default display mode, <B>wSelSurface:dwOffSurface</B> must not be specified.</P></TD></TR><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">If the surface to be accessed is on a bank-switched memory device, the surface provider must install a suitable bank-switch handling routine, so that the DCI Client is "tricked" into viewing the entire memory range as a linear memory range.</P></TD></TR><TR><TD VALIGN="TOP"><B>BeginAccess</B></P></TD><TD VALIGN="TOP">Called by DCI Client at the beginning of a draw operation.  This function must return a status code when invoked. It is legal for the DCI Provider to fail the call at the time of invocation.  A suitable error code must be returned to indicate the cause of failure.<B> </B></P></TD></TR><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP"><B>Note:</B> This pointer may be NULL, if the DCI Provider does not need to take any action corresponding to <B>BeginAccess</B>.</P></TD></TR><TR><TD VALIGN="TOP"><B>EndAccess</B></P></TD><TD VALIGN="TOP">Called by DCI Client at the end of access to display surface.  </P></TD></TR><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP"><B>Note</B>: This pointer may be NULL, if the DCI Provider does not need to take any action corresponding to <B>EndAccess</B>.</P></TD></TR><TR><TD VALIGN="TOP"><B>DestroySurface</B></P></TD><TD VALIGN="TOP">Will not be called for an overlay buffer.  Only the primary offscreen buffer with which this overlay buffer is associated will be destroyed. </P></TD></TR><TR><TD VALIGN="TOP"><B>SetDestination</B></P></TD><TD VALIGN="TOP">Called by DCI Client to describe the extent of the destination surface.  This function will be called to reflect window moves or size changes.  The source rectangle is also provided in this call to define any stretching necessary.  This call can be rejected if the destination parameters provided cannot be supported.</P></TD></TR><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">Before a call to <B>SetDestination</B>, the DCI Provider does not know where this surface should appear when mapped to the screen.  Therefore, the DCI Client must make this call before calling <B>SetClipList</B>, <B>BeginAccess</B> or <B>Draw</B>.  If a change is needed, the DCI Provider can update the <B>wSelSurface</B> and <B>dwOffSurface</B> fields of the <B>DCIOFFSCREEEN</B> structure on the next call to <B>BeginAccess</B> and return the DCI_STATUS_POINTERCHANGED status code.  Then, the surface is considered initialized.</P></TD></TR><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">This function must return a status code when invoked. It is legal for the DCI Provider to fail the call at the time of invocation.  A suitable error code must be returned to indicate the cause of failure.</P></TD></TR><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP"><B>Note:</B> The client may call SetDestination with the source rectangle pointer set to NULL.  This indicates that the entire offscreen surface is to be mapped to the given destination screen rectangle.</P></TD></TR><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP"></P></TD></TR><TR><TD VALIGN="TOP"><B>SetCliplist</B></P></TD><TD VALIGN="TOP">The DCI Client calls this function to tell the DCI Provider about changes to the overlap status of the window in which drawing is occurring.  Support of this function is required for all offscreen surfaces.</P></TD></TR><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">The DCI Provider will be passed a <B>RGNDATA</B> structure describing the visible area.  The <B>lpBuffer</B> field of the <B>RGNDATA</B> structure is in an array of rectangles.  Fields within the header preceding the array define the length of the array.  The walk order of the rectangles is top-to-bottom, left-to-right.</P></TD></TR><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">This function must return a status code when invoked.  It is legal for the DCI Provider to fail the call at the time of invocation.  A suitable error code must be returned to indicate the cause of failure.</P></TD></TR><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">It is the DCI Client's responsibility to ensure the bounding rectangle returned in the rcBound field of the <B>RGNDATAHEADER</B> structure intersects the destination rectangle in a prior <B>SetDestination</B> call.  The very first <B>SetClipList</B> call must be preceded by a <B>SetDestination</B> call.</P></TD></TR><TR><TD VALIGN="TOP"><B>dwChromakeyValue</B></P></TD><TD VALIGN="TOP">If overlay is to be controlled via chromakey, DCI Provider must return the value which will enable data from the offscreen surface to be placed on the primary display surface. </P></TD></TR><TR><TD VALIGN="TOP"><B>dwChromakeyMask</B></P></TD><TD VALIGN="TOP">These masks inform the user that the <B>dwChromakeyValue </B>must be XORed into place.  It represents that not all bits of locations in the overlay buffer are for chromakey purposes.  </P></TD></TR></TBODY></TABLE>
<BR></P><A NAME="PT17"></A>COMMENTS</P>
If overlay control is to be performed via the primary display control buffer, all returns (specifically the <B>lpSurface</B>, <B>BitmapInfo</B>, <B>dwCompression</B> and <B>wSelSurface:dwOffSurface</B> fields) must be zeroed.  The only valid data when overlay control is to be provided via the primary display surface is <B>dwChromakeyValue</B> and <B>dwChromakeyMask</B>.</P>
<B>BeginAccess</B> and <B>EndAccess</B> are called as a framework around every set of accesses to the display buffer.  The DCI Client must not access surface memory before a <B>BeginAccess</B> or after an <B>EndAccess</B>.  At <B>BeginAccess</B>, the DCI Provider must ensure that valid access is available to the memory range specified by the <B>wSelSurface:dwOffSurface </B>pointer.  </P>
The DCI Provider may change <I>any </I>and<I> all</I><B> </B>fields in the <B>DCIOVERLAY</B> structure at <B>BeginAccess</B>.  If any changes are made to the <B>DCISURFACEINFO</B> portion or to the <B>dwChromakey</B> fields of <B>DCIOVERLAY</B> structure the DCI Provider must return a suitable notification status code.  No notification need be returned when callback addresses are changed; the DCI Client cannot assume that these addresses will remain unchanged.</P>
The DCI Client is encouraged to minimize processing time between <B>BeginAccess/EndAccess</B>.  Similarly the DCI Provider is encouraged to optimize the speed of these calls so that the DCI Client does not incur a stiff penalty on each direct access of a surface.  It is valid to return NULL pointers if no action need be taken by the DCI Provider.  </P>
 </P></BODY></HTML>
