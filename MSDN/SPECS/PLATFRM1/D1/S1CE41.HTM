<HTML><HEAD><META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Vflat.386 in Windows Chicago</TITLE><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">

</OBJECT></FORM>
<H3>Vflat.386 in Windows Chicago</H3>  </P>
If your display adapter does not use a flat memory model and requires bank switching with a frame buffer larger than 64K, you can use the virtual flat framebuffer device (VFLATD) supplied by Microsoft.</P>
The following illustration shows the Chicago display-driver architecture.</P>
<img src="ADU9A.gif"></P>
Writing display drivers for previous versions of Windows required you to write a large amount of assembly code covering a variety of display tasks. In Chicago's new display driver architecture, the DIB engine supplies most of the code necessary to create a display driver. All your minidriver needs is the hardware-specific code for your display; you simply redirect the software calls from GDI to the DIB engine. If you cannot use the DIB engine, you must write a full display driver that supplies the new display functions Chicago requires. However, you still need to make calls to the VFLATD if you need to virtualize frame buffers larger than 64K.</P>
 </P></BODY></HTML>
