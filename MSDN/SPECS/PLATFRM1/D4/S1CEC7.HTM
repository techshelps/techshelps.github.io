<HTML><HEAD><META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>6.2. Plug and Play Resource Data Types</TITLE><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">

</OBJECT></FORM>
<H3>6.2. Plug and Play Resource Data Types</H3>  </P>
Plug and Play resource data fully describes all resource requirements of a Plug and Play ISA card as well as resource programmability and interdependencies.  Plug and Play resource data is supplied as a series of "tagged" data structures.  To minimize the amount of storage needed on Plug and Play ISA cards two different data types are supported.  These are called small items and large items.   The general format of the structure is shown below.  The first byte defines the type and size for most information and is followed by one or more bytes of the actual information.  Bit[7] of the first byte is used as the tag identifier to differentiate between a small item or a large item data type.  </P>
<A NAME="PT2"></A>6.2.1. Resource Data Requirements</P>
The minimum level of functionality of Plug and Play cards was defined earlier.  This implies that the Plug and Play version number data type (small item format), the identifier string data type (large item format) and all resource types to identify the fixed resources will always be present.  The identifier string is used by the operating system for device related configuration and error messages.   Card vendors may include several identifiers if they would like to support multiple text formats (ANSI, Unicode) and international languages.  The description of an identifier string is included in the section on large item format.</P>
It is recommended that configurable boot devices include all configuration information on their cards to allow Plug and Play BIOS to manage resources during boot time.  Refer to the section on boot devices for more information.</P>
A Plug and Play logical device may use any number of resources and any combination of small item or large item data types.  The general format is :</P>
<SPAN CLASS="list"><OL><LI>Plug and Play version number type</LI><LI>Identifier string resource type</LI><LI>Logical device ID resource type

<UL><LI>Any compatible device ID resource type for this logical device</LI><LI>Resource data types to match what the function uses (IRQ, memory, I/O, DMA)-the order is not important.</LI><LI>Any dependent functions needed if the Plug and Play card is configurable.  The order of the resource data establishes the binding to the configuration registers.</LI></UL></LI></OL></SPAN></P>
  </P>
<B>Note</B>   Step 3 is repeated for each logical device present on the Plug and Play card.</P>
  </P>
<SPAN CLASS="list"><OL><LI>End tag resource type to indicate the end of resources for this Plug and Play card.</LI></OL></SPAN>The order of resource descriptors is significant because configuration registers are programmed in the same order that descriptors are read (see section 4.6.1).  This may be important in some hardware implementations.  Further, in the case of Dependent Functions it may be necessary to include null descriptors ('filler') in order to maintain the desired descriptor-to-register mapping regardless of which Dependent Function is programmed by the software. NULL descriptors are defined for each resource type (see resource descriptor sections).</P>
<A NAME="PT3"></A>6.2.2. Small Resource Data Type</P>
A small resource data type may be 2-8 bytes in size and adheres to the following format:</P>
Table 3.  Small Resource Data Type Tag Bit Definitions</P>
  </P>
<P></P>

<TABLE COLS="7" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="126pt" VALIGN="TOP"><COL WIDTH="125pt" VALIGN="TOP"><COL WIDTH="125pt" VALIGN="TOP"><COL WIDTH="105pt" VALIGN="TOP"><COL WIDTH="10pt" VALIGN="TOP"><COL WIDTH="10pt" VALIGN="TOP"><COL WIDTH="0pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><B>Offset</B></P></TD><TD COLSPAN="3" VALIGN="TOP"><B>Field</B></P></TD><TD COLSPAN="3" VALIGN="TOP"></P></TD><TD COLSPAN="4" VALIGN="TOP"></P></TD></TR><TR><TD VALIGN="TOP">Byte 0</P></TD><TD VALIGN="TOP"><B>Tag Bit[7]</B></P></TD><TD VALIGN="TOP"><B>Tag Bits[6:3]</B></P></TD><TD COLSPAN="3" VALIGN="TOP"><B>Tag Bits [2:0]</B></P></TD></TR><TR><TD VALIGN="TOP"></P></TD><TD VALIGN="TOP">Type = 0</P></TD><TD VALIGN="TOP">Small item name</P></TD><TD COLSPAN="3" VALIGN="TOP">Length = n bytes</P></TD></TR><TR><TD VALIGN="TOP">Bytes 1 to n</P></TD><TD COLSPAN="3" VALIGN="TOP">Actual information</P></TD><TD COLSPAN="3" VALIGN="TOP"></P></TD><TD COLSPAN="4" VALIGN="TOP"></P></TD></TR></TBODY></TABLE>
<BR></P>The following small information items are currently defined for Plug and Play ISA devices:</P>
Table 4.  Small Resource Items</P>
  </P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="328pt" VALIGN="TOP"><COL WIDTH="154pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><B>Small Item Name</B></P></TD><TD VALIGN="TOP"><B>Value</B></P></TD></TR><TR><TD VALIGN="TOP">Plug and Play version number</P></TD><TD VALIGN="TOP">0x1</P></TD></TR><TR><TD VALIGN="TOP">Logical device ID</P></TD><TD VALIGN="TOP">0x2</P></TD></TR><TR><TD VALIGN="TOP">Compatible device ID</P></TD><TD VALIGN="TOP">0x3</P></TD></TR><TR><TD VALIGN="TOP">IRQ format</P></TD><TD VALIGN="TOP">0x4</P></TD></TR><TR><TD VALIGN="TOP">DMA format</P></TD><TD VALIGN="TOP">0x5</P></TD></TR><TR><TD VALIGN="TOP">Start dependent Function </P></TD><TD VALIGN="TOP">0x6</P></TD></TR><TR><TD VALIGN="TOP">End dependent Function</P></TD><TD VALIGN="TOP">0x7</P></TD></TR><TR><TD VALIGN="TOP">I/O port descriptor</P></TD><TD VALIGN="TOP">0x8</P></TD></TR><TR><TD VALIGN="TOP">Fixed location I/O port descriptor</P></TD><TD VALIGN="TOP">0x9</P></TD></TR><TR><TD VALIGN="TOP"><I>Reserved</I></P></TD><TD VALIGN="TOP">0xA - 0xD</P></TD></TR><TR><TD VALIGN="TOP">Vendor defined</P></TD><TD VALIGN="TOP">0xE</P></TD></TR><TR><TD VALIGN="TOP">End tag</P></TD><TD VALIGN="TOP">0xF</P></TD></TR></TBODY></TABLE>
<BR></P><A NAME="PT4"></A>6.2.2.1. Plug and Play Version Number</P>
The Plug and Play Version Number identifies the version of the Plug and Play specification with which this card is compatible.  A vendor specific version number is included and may be used by a device driver to verify the version of the card.  </P>
  </P>

<TABLE COLS="3" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="71pt" VALIGN="TOP"><COL WIDTH="398pt" VALIGN="TOP"><COL WIDTH="10pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><B>Offset</B></P></TD><TD VALIGN="TOP"><B>Field Name</B></P></TD><TD VALIGN="TOP"></P></TD></TR><TR><TD VALIGN="TOP">Byte 0</P></TD><TD VALIGN="TOP">Value = 00001010B (Type = 0, small item name = 0x1, length = 2)</P></TD><TD VALIGN="TOP"></P></TD></TR><TR><TD VALIGN="TOP">Byte 1</P></TD><TD VALIGN="TOP">Plug and Play version number (in packed BCD format, major bits[7:4], minor bits[3:0]) Example: Version 1.0 = 0x10, Version 2.3 = 0x23, Version 2.91= 0x29</P></TD><TD VALIGN="TOP"></P></TD></TR><TR><TD VALIGN="TOP">Byte 2</P></TD><TD VALIGN="TOP">Vendor specific version number</P></TD><TD VALIGN="TOP"></P></TD></TR></TBODY></TABLE>
<BR></P><A NAME="PT5"></A>6.2.2.2. Logical Device ID</P>
The Logical Device ID provides a mechanism for uniquely identifying multiple logical devices embedded in a single physical board.  The format of the logical device ID is identical to the Vendor ID field (see Sec. 6.1).</P>
<SPAN CLASS="list"><UL><LI>bits[15:0] -  three character compressed ASCII EISA ID. (See table for bit definitions.)
Compressed ASCII is defined as 5 bits per character, "00001" = "A" ... "11010" = "Z".  This field must contain a  valid EISA ID, although it is not required to have the same 3 letters as the Vendor ID.</P></LI><LI>bits[31:16] -  manufacturer-specific function number and revision. (See table for bit definitions.) It is the manufacturer's responsibility to have unique bits[31:16] for different functions.</LI></UL></SPAN>This identifier  may be used to select a device driver for the device. Because of this, Logical Device IDs must be uniquely associated with a specific function.  However, there is no need for the Logical Device ID itself to have a unique value, either on a card, or across cards.  For instance, a card that implements two communications ports may use the exact same Logical Device ID for both.  Similarly, two different products (different Vendor IDs) may both implement the same function, and therefore will use the same Logical Device ID for it.  The Logical Device ID is required on all cards.  On single-function cards, the Logical Device ID may be the same as the card's vendor ID</P>
The Logical Device ID includes information about what optional commands are supported.  Also, bit zero of the flags field is used to indicate that this device should be activated by the BIOS at boot time if this system includes a Plug and Play BIOS.  Refer to the section on Plug and Play boot devices (Appendix C, Sec. C-2) for details.</P>
  </P>

<TABLE COLS="5" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="0pt" VALIGN="TOP"><COL WIDTH="397pt" VALIGN="TOP"><COL WIDTH="0pt" VALIGN="TOP"><COL WIDTH="10pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><B>Offset</B></P></TD><TD COLSPAN="3" VALIGN="TOP"><B>Field Name</B></P></TD><TD COLSPAN="3" VALIGN="TOP"></P></TD></TR><TR><TD VALIGN="TOP">Byte 0</P></TD><TD COLSPAN="3" VALIGN="TOP">Value = 000101xxB (Type = 0, small item name = 0x2,  length = (5 or 6))</P></TD><TD COLSPAN="3" VALIGN="TOP"></P></TD></TR><TR><TD COLSPAN="2" VALIGN="TOP">Byte 1</P></TD><TD COLSPAN="2" VALIGN="TOP">Bit[7]           0</P>
Bits[6:2]       First character in compressed ASCII</P>
Bits[1:0]       Second character in compressed ASCII bits[4:3]</P></TD></TR><TR><TD COLSPAN="2" VALIGN="TOP">Byte 2</P></TD><TD COLSPAN="2" VALIGN="TOP">Bits[7:5]        Second character in compressed ASCII bits[2:0]</P>
Bits[4:0]        Third character in compressed ASCII</P></TD></TR><TR><TD COLSPAN="2" VALIGN="TOP">Byte 3</P></TD><TD COLSPAN="2" VALIGN="TOP">(Vendor Assigned)</P>
Bits[7:4]        First hexadecimal digit of function number<BR>          (bit 7 is msb)</P>
Bits[3:0]        Second hexadecimal digit of function number<BR>          (bit 3 is msb)</P></TD></TR><TR><TD COLSPAN="2" VALIGN="TOP">Byte 4</P></TD><TD COLSPAN="2" VALIGN="TOP">(Vendor Assigned) </P>
Bits[7:4]        Third hexadecimal digit of function number<BR>          (bit 7 is msb)</P>
Bits[3:0]        Hexadecimal digit of revision level (bit 3 is msb)</P></TD></TR><TR><TD VALIGN="TOP">Byte 5</P></TD><TD COLSPAN="3" VALIGN="TOP">Flags:<BR>Bits[7:1], if set, indicate commands supported per logical device for registers in the range of 0x31 to 0x37 respectively.</P>
Bit[0], if set, indicates this logical device is capable of participating in the boot process  Note:  Cards that power-up active MUST have this bit set.  However, if this bit is set, the card may or may not power-up active.</P></TD><TD COLSPAN="3" VALIGN="TOP"></P></TD></TR><TR><TD VALIGN="TOP">Byte 6</P></TD><TD COLSPAN="3" VALIGN="TOP">Flags:<BR>Bit[7:0], if set, indicate commands supported per logical device for registers in the range of 0x38 to 0x3F respectively.</P></TD><TD COLSPAN="3" VALIGN="TOP"></P></TD></TR></TBODY></TABLE>
<BR></P><A NAME="PT6"></A>6.2.2.3. Compatible Device ID</P>
The compatible device ID provides the IDs of other devices with which this device is compatible.  The operating system uses this information to load compatible device drivers if necessary.  There can be several compatible device identifiers for each logical device.  The order of these device IDs may be used by the operating system as a criteria for determining which driver should be searched for and loaded first.</P>
  </P>

<TABLE COLS="5" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="0pt" VALIGN="TOP"><COL WIDTH="397pt" VALIGN="TOP"><COL WIDTH="0pt" VALIGN="TOP"><COL WIDTH="10pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><B>Offset</B></P></TD><TD COLSPAN="3" VALIGN="TOP"><B>Field Name</B></P></TD><TD COLSPAN="3" VALIGN="TOP"></P></TD></TR><TR><TD VALIGN="TOP">Byte 0</P></TD><TD COLSPAN="3" VALIGN="TOP">Value = 00011100B (Type = 0, small item name = 0x3,  length = 4)</P></TD><TD COLSPAN="3" VALIGN="TOP"></P></TD></TR><TR><TD COLSPAN="2" VALIGN="TOP">Byte 1</P></TD><TD COLSPAN="2" VALIGN="TOP">Bit[7]           0</P>
Bits[6:2]       First character in compressed ASCII</P>
Bits[1:0]       Second character in compressed ASCII bits[4:3]</P></TD></TR><TR><TD COLSPAN="2" VALIGN="TOP">Byte 2</P></TD><TD COLSPAN="2" VALIGN="TOP">Bits[7:5]        Second character in compressed ASCII bits[2:0]</P>
Bits[4:0]        Third character in compressed ASCII</P></TD></TR><TR><TD COLSPAN="2" VALIGN="TOP">Byte 3</P></TD><TD COLSPAN="2" VALIGN="TOP">(Vendor Assigned)</P>
Bits[7:4]        First hexadecimal digit of function number<BR>          (bit 7 is msb)</P>
Bits[3:0]        Second hexadecimal digit of function number<BR>          (bit 3 is msb)</P></TD></TR><TR><TD COLSPAN="2" VALIGN="TOP">Byte 4</P></TD><TD COLSPAN="2" VALIGN="TOP">(Vendor Assigned) </P>
Bits[7:4]        Third hexadecimal digit of function number<BR>          (bit 7 is msb)</P>
Bits[3:0]        Hexadecimal digit of revision level (bit 3 is msb)</P></TD></TR></TBODY></TABLE>
<BR></P>As an example of the use of compatible IDs, consider a card vendor who ships a device with logical ID 0xABCD0000. At a later date, this vendor ships a new device with a logical ID 0xABCD0001. This new device is 100% compatible with the old device but also has added functionality. For this device, the vendor could include the Compatible device ID 0xABCD0000. In this case, the exact driver for 0xABCD0001 will be loaded if it can be located. If the driver for 0xABCD0001 can not be found, the driver for device 0xABCD0000 will be loaded for the device.</P>
A list of standard compatible device drivers is available from the Plug and Play Association as file "devids.txt" on the Association's Compuserve forum, PLUGPLAY.</P>
<A NAME="PT7"></A>6.2.2.4. IRQ Format</P>
The IRQ data structure indicates that the device uses an interrupt level and supplies a mask with bits set indicating the levels implemented in this device.  For standard ISA implementation there are 16 possible interrupt levels so a two byte field is used.  This structure is repeated for each separate interrupt level required. </P>
NULL IRQ Descriptor: IRQ mask bits set to all zero (no bits set to 1) (all other fields ignored).</P>
PnP Software action:  Corresponding IRQ level select register programmed to all zeros.  The IRQ type select register is programmed to 0x02h (High-true, edge-sensitve interrupts).</P>
  </P>

<TABLE COLS="3" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="398pt" VALIGN="TOP"><COL WIDTH="10pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><B>Offset</B></P></TD><TD VALIGN="TOP"><B>Field Name</B></P></TD><TD VALIGN="TOP"></P></TD></TR><TR><TD VALIGN="TOP">Byte 0</P></TD><TD VALIGN="TOP">Value = 0010001XB (Type = 0, small item name = 0x4,  length = (2 or 3))</P></TD><TD VALIGN="TOP"></P></TD></TR><TR><TD VALIGN="TOP">Byte 1</P></TD><TD VALIGN="TOP">IRQ mask bits[7:0].  Bit[0] represents IRQ0, bit[1] is IRQ1, and so on.</P></TD><TD VALIGN="TOP"></P></TD></TR><TR><TD VALIGN="TOP">Byte 2</P></TD><TD VALIGN="TOP">IRQ mask bits[15:8].  Bit[0] represents IRQ8, bit[1] is IRQ9, and so on.</P></TD><TD VALIGN="TOP"></P></TD></TR><TR><TD VALIGN="TOP">Byte 3</P></TD><TD VALIGN="TOP">IRQ Information.  Each bit, when set, indicates this device is capable of driving a certain type of interrupt. (Optional--if not included then assume ISA compatible edge sensitive, high true interrupts)<BR>Bit[7:4]          <I>Reserved and must be 0</I><BR>Bit[3]     Low true level sensitive<BR>Bit[2]     High true level sensitive  <BR>Bit[1]     Low true edge sensitive<BR>Bit[0]     High true edge sensitive (Must be supported for ISA compatibility)</P></TD><TD VALIGN="TOP"></P></TD></TR></TBODY></TABLE>
<BR></P>  </P>
<B>Note</B>   Low true, level sensitive interrupts may be electrically shared, the process of how this might work is beyond the scope of this specification.  Only IRQs that exist on the ISA bus connectors are valid.</P>
  </P>
<A NAME="PT8"></A>6.2.2.5. DMA Format</P>
The DMA data structure indicates that the device uses a DMA channel and supplies a mask with bits set indicating the channels actually implemented in this device.  This structure is repeated for each separate channel required. </P>
NULL DMA Descriptor: DMA channel mask bits set to all zero (no bits set to 1) (all other fields ignored).</P>
PnP Software action:  Corresponding DMA channel select register programmed to 0x04h. </P>
</P>
  </P>

<TABLE COLS="3" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="398pt" VALIGN="TOP"><COL WIDTH="10pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><B>Offset</B></P></TD><TD VALIGN="TOP"><B>Field Name</B></P></TD><TD VALIGN="TOP"></P></TD></TR><TR><TD VALIGN="TOP">Byte 0</P></TD><TD VALIGN="TOP">Value = 00101010B (Type = 0, small item name = 0x5,  length = 2)</P></TD><TD VALIGN="TOP"></P></TD></TR><TR><TD VALIGN="TOP">Byte 1</P></TD><TD VALIGN="TOP">DMA channel mask bits[7:0].  Bit[0] is channel 0.</P></TD><TD VALIGN="TOP"></P></TD></TR><TR><TD VALIGN="TOP">Byte 2</P></TD><TD VALIGN="TOP">Bit[7]                    <I>Reserved and must be 0</I></P>
Bits[6:5]     DMA channel speed supported<BR>          Status<BR>          00     Indicates compatibility mode<BR>          01     Indicates Type A DMA as described in the EISA Specification<BR>          10     Indicates Type B DMA<BR>          11     Indicates Type F</P>
Bit[4]         DMA word mode<BR>          Status<BR>          0     DMA may not execute in count by word mode<BR>          1     DMA may execute in count by word mode</P>
Bit[3]        DMA byte mode status<BR>          Status<BR>          0     DMA may not execute in count by byte mode<BR>          1     DMA may execute in count by byte mode</P>
Bit[2]         Logical device bus master status<BR>          Status<BR>          0     Logical device is not a bus master<BR>          1     Logical device is a bus master </P>
Bits[1:0]         DMA transfer type preference <BR>          Status<BR>          00     8-bit only <BR>          01     8- and 16-bit  <BR>          10     16-bit only  <BR>          11          <I>Reserved</I><BR></P></TD><TD VALIGN="TOP"></P></TD></TR></TBODY></TABLE>
<BR></P><A NAME="PT9"></A>6.2.2.6. Start Dependent Functions</P>
Each logical device requires a set of resources.  This set of resources may have interdependencies that need to be expressed to allow arbitration software to make resource allocation decisions about the logical device. Dependent functions are used to express these interdependencies. The data structure definitions for dependent functions are shown here. For a detailed description of the use of dependent functions refer to the next section.</P>
  </P>

<TABLE COLS="3" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="398pt" VALIGN="TOP"><COL WIDTH="10pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><B>Offset</B></P></TD><TD VALIGN="TOP"><B>Field Name</B></P></TD><TD VALIGN="TOP"></P></TD></TR><TR><TD VALIGN="TOP">Byte 0</P></TD><TD VALIGN="TOP">Value = 0011000xB (Type = 0, small item name = 0x6,  length =(0 or 1))</P></TD><TD VALIGN="TOP"></P></TD></TR></TBODY></TABLE>
<BR></P>Start Dependent Function fields may be of length 0 or 1 bytes. The extra byte is optionally used to denote priority for the resource group following the Start DF tag. If the extra byte is not included, this indicates the dependent function priority is 'acceptable'. If the Priority byte is included, the priorities are defined as:</P>
  </P>

<TABLE COLS="3" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="398pt" VALIGN="TOP"><COL WIDTH="10pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><B>Value</B></P></TD><TD VALIGN="TOP"><B>Definition</B></P></TD><TD VALIGN="TOP"></P></TD></TR><TR><TD VALIGN="TOP">0</P></TD><TD VALIGN="TOP">Good configuration - Highest Priority and preferred configuration</P></TD><TD VALIGN="TOP"></P></TD></TR><TR><TD VALIGN="TOP">1</P></TD><TD VALIGN="TOP">Acceptable configuration - Lower Priority but acceptable configuration</P></TD><TD VALIGN="TOP"></P></TD></TR><TR><TD VALIGN="TOP">2</P></TD><TD VALIGN="TOP">Sub-optimal configuration - Functional configuration but not optimal</P></TD><TD VALIGN="TOP"></P></TD></TR><TR><TD VALIGN="TOP">3 - 255</P></TD><TD VALIGN="TOP">Reserved</P></TD><TD VALIGN="TOP"></P></TD></TR></TBODY></TABLE>
<BR></P>Note that if multiple Dependent Functions have the same priority, they are further prioritized by the order in which they appear in the resource data structure.  The Dependent Function which appears earliest (nearest the beginning) in the structure has the highest priority, and so on.</P>
<A NAME="PT10"></A>6.2.2.7. End Dependent Functions</P>
  </P>

<TABLE COLS="3" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="398pt" VALIGN="TOP"><COL WIDTH="10pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><B>Offset</B></P></TD><TD VALIGN="TOP"><B>Field Name</B></P></TD><TD VALIGN="TOP"></P></TD></TR><TR><TD VALIGN="TOP">Byte 0</P></TD><TD VALIGN="TOP">Value = 00111000B (Type = 0, small item name = 0x7  length =0)</P></TD><TD VALIGN="TOP"></P></TD></TR></TBODY></TABLE>
<BR></P>Note that only one End Dependent Function item is allowed per logical device.  This enforces the fact that Dependent Functions are not nestable (see section 7.0).</P>
<A NAME="PT11"></A>6.2.2.8. I/O Port Descriptor</P>
There are two types of descriptors for I/O ranges. The first descriptor is a full function descriptor for programmable ISA cards. The second descriptor is a minimal descriptor for old ISA cards with fixed I/O requirements that use a 10-bit ISA address decode. The first type descriptor can also be used to describe fixed I/O requirements for ISA cards that require a 16-bit address decode. This is accomplished  by setting the range minimum base address and range maximum base address to the same fixed I/O value.\revauth1 \revdttm1709962031  </P>
NULL I/O Port Descriptor: Range Length field set to all zeros (all other fields ignored).</P>
PnP Software action:  Corresponding I/O port base address registers programmed to all zeros.</P>
</P>
  </P>

<TABLE COLS="3" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="154pt" VALIGN="TOP"><COL WIDTH="256pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><B>Offset</B></P></TD><TD VALIGN="TOP"><B>Field Name</B></P></TD><TD VALIGN="TOP"><B>Definition</B></P></TD></TR><TR><TD VALIGN="TOP">Byte 0</P></TD><TD VALIGN="TOP">I/O port descriptor </P></TD><TD VALIGN="TOP">Value = 01000111B (Type = 0, Small item name = 0x8, Length = 7)</P></TD></TR><TR><TD VALIGN="TOP">Byte 1</P></TD><TD VALIGN="TOP">Information</P></TD><TD VALIGN="TOP">Bits[7:1] are reserved and must be 0</P>
Bit[0], if set, indicates the logical device decodes the full 16 bit ISA address. If bit[0] is not set, this indicates the logical device only decodes ISA address bits[9:0].</P>
</P></TD></TR><TR><TD VALIGN="TOP">Byte 2</P></TD><TD VALIGN="TOP">Range minimum base address<BR>bits[7:0]</P></TD><TD VALIGN="TOP">Address bits[7:0] of the minimum base I/O address that the card may be configured for.  </P></TD></TR><TR><TD VALIGN="TOP">Byte 3</P></TD><TD VALIGN="TOP">Range minimum base address<BR>bits[15:8]</P></TD><TD VALIGN="TOP">Address bits[15:8] of the minimum base I/O address that the card may be configured for.</P></TD></TR><TR><TD VALIGN="TOP">Byte 4</P></TD><TD VALIGN="TOP">Range maximum base address<BR>bits[7:0]</P></TD><TD VALIGN="TOP">Address bits[7:0] of the maximum base I/O address that the card may be configured for.  </P></TD></TR><TR><TD VALIGN="TOP">Byte 5</P></TD><TD VALIGN="TOP">Range maximum base address<BR>bits[15:8]</P></TD><TD VALIGN="TOP">Address bits[15:8] of the maximum base I/O address that the card may be configured for.</P></TD></TR><TR><TD VALIGN="TOP">Byte 6</P></TD><TD VALIGN="TOP">Base alignment</P></TD><TD VALIGN="TOP">Alignment for minimum base address, increment in 1 byte blocks.</P></TD></TR><TR><TD VALIGN="TOP">Byte 7</P></TD><TD VALIGN="TOP">Range length</P></TD><TD VALIGN="TOP">The number of contiguous I/O ports requested.</P></TD></TR></TBODY></TABLE>
<BR></P>The minimum base address has to be aligned on the boundary specified by the alignment field.</P>
<A NAME="PT12"></A>6.2.2.9. Fixed Location I/O Port Descriptor</P>
  </P>

<TABLE COLS="3" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="154pt" VALIGN="TOP"><COL WIDTH="256pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><B>Offset</B></P></TD><TD VALIGN="TOP"><B>Field Name</B></P></TD><TD VALIGN="TOP"><B>Definition</B></P></TD></TR><TR><TD VALIGN="TOP">Byte 0</P></TD><TD VALIGN="TOP">Fixed Location I/O port descriptor </P></TD><TD VALIGN="TOP">Value = 01001011B (Type = 0, Small item name = 0x9, Length = 3)</P></TD></TR><TR><TD VALIGN="TOP">Byte 1</P></TD><TD VALIGN="TOP">Range base address<BR>bits[7:0]</P></TD><TD VALIGN="TOP">Address bits[7:0] of the base I/O address that the card may be configured for. This descriptor assumes a 10 bit ISA address decode.  </P></TD></TR><TR><TD VALIGN="TOP">Byte 2</P></TD><TD VALIGN="TOP">Range base address<BR>bits[9:8]</P></TD><TD VALIGN="TOP">Address bits[9:8] of the base I/O address that the card may be configured for.  This descriptor assumes a 10 bit ISA address decode.  </P></TD></TR><TR><TD VALIGN="TOP">Byte 3</P></TD><TD VALIGN="TOP">Range length</P></TD><TD VALIGN="TOP">The number of contiguous I/O ports requested.</P></TD></TR></TBODY></TABLE>
<BR></P><A NAME="PT13"></A>6.2.2.10. Vendor Defined</P>
The vendor defined resource data type is for vendor use.</P>
  </P>

<TABLE COLS="3" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="398pt" VALIGN="TOP"><COL WIDTH="10pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><B>Offset</B></P></TD><TD VALIGN="TOP"><B>Field Name</B></P></TD><TD VALIGN="TOP"></P></TD></TR><TR><TD VALIGN="TOP">Byte 0</P></TD><TD VALIGN="TOP">Value = 01110xxxB (Type = 0, small item name = 0xE,  length = (1-7))</P></TD><TD VALIGN="TOP"></P></TD></TR><TR><TD VALIGN="TOP">Byte 1 to 7</P></TD><TD VALIGN="TOP">Vendor defined</P></TD><TD VALIGN="TOP"></P></TD></TR></TBODY></TABLE>
<BR></P><A NAME="PT14"></A>6.2.2.11. End Tag</P>
The End tag identifies an end of resource data.  Note:  If the checksum field is zero, the resource data is treated as if it checksummed properly.  Configuration proceeds normally.</P>
  </P>

<TABLE COLS="3" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="398pt" VALIGN="TOP"><COL WIDTH="10pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><B>Offset</B></P></TD><TD VALIGN="TOP"><B>Field Name</B></P></TD><TD VALIGN="TOP"></P></TD></TR><TR><TD VALIGN="TOP">Byte 0</P></TD><TD VALIGN="TOP">Value = 01111001B (Type = 0, small item name = 0xF,  length = 1)</P></TD><TD VALIGN="TOP"></P></TD></TR><TR><TD VALIGN="TOP">Byte 1</P></TD><TD VALIGN="TOP">Check sum covering all resource data after the serial identifier. This check sum is generated such that adding it to the sum of all the data bytes will produce a zero sum.</P></TD><TD VALIGN="TOP"></P></TD></TR></TBODY></TABLE>
<BR></P><A NAME="PT15"></A>6.2.3. Large Resource Data Type</P>
To allow for larger amounts of data to be included in the configuration data structure the large format is shown below.  This includes a 16-bit length field allowing up to 64 Kbytes of data.</P>
Table 5.  Large Resource Data Type Tag Bit Definitions</P>
  </P>

<TABLE COLS="3" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="398pt" VALIGN="TOP"><COL WIDTH="10pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><B>Offset</B></P></TD><TD VALIGN="TOP"><B>Field Name</B></P></TD><TD VALIGN="TOP"></P></TD></TR><TR><TD VALIGN="TOP">Byte 0</P></TD><TD VALIGN="TOP">Value = 1xxxxxxxB (Type = 1, Large item name = xxxxxxx)</P></TD><TD VALIGN="TOP"></P></TD></TR><TR><TD VALIGN="TOP">Byte 1</P></TD><TD VALIGN="TOP">Length of data items bits[7:0]</P></TD><TD VALIGN="TOP"></P></TD></TR><TR><TD VALIGN="TOP">Byte 2</P></TD><TD VALIGN="TOP">Length of data items bits[15:8]</P></TD><TD VALIGN="TOP"></P></TD></TR><TR><TD VALIGN="TOP">Bytes 3 to n</P></TD><TD VALIGN="TOP">Actual data items</P></TD><TD VALIGN="TOP"></P></TD></TR></TBODY></TABLE>
<BR></P>The following large information items are currently defined for Plug and Play ISA devices:</P>
Table 6.  Large Resource Items</P>
  </P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="328pt" VALIGN="TOP"><COL WIDTH="154pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><B>Large Item Name</B></P></TD><TD VALIGN="TOP"><B>Value</B></P></TD></TR><TR><TD VALIGN="TOP">Memory range descriptor</P></TD><TD VALIGN="TOP">0x1</P></TD></TR><TR><TD VALIGN="TOP">Identifier string (ANSI)</P></TD><TD VALIGN="TOP">0x2</P></TD></TR><TR><TD VALIGN="TOP">Identifier string (Unicode)</P></TD><TD VALIGN="TOP">0x3</P></TD></TR><TR><TD VALIGN="TOP">Vendor defined</P></TD><TD VALIGN="TOP">0x4</P></TD></TR><TR><TD VALIGN="TOP">32-bit memory range descriptor</P></TD><TD VALIGN="TOP">0x5</P></TD></TR><TR><TD VALIGN="TOP">32-bit fixed location memory range descriptor</P></TD><TD VALIGN="TOP">0x6</P></TD></TR><TR><TD VALIGN="TOP"><I>Reserved</I></P></TD><TD VALIGN="TOP">0x7 - 0x7F</P></TD></TR></TBODY></TABLE>
<BR></P><A NAME="PT16"></A>6.2.3.1. Memory Range Descriptor</P>
NULL Memory Range Descriptor: Range Length field set to all zeros (all other fields ignored)</P>
PnP Software action: Corresponding base address registers and limit address/range length registers programmed to all zeros.</P>
  </P>

<TABLE COLS="3" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="64pt" VALIGN="TOP"><COL WIDTH="144pt" VALIGN="TOP"><COL WIDTH="256pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><B>Size</B></P></TD><TD VALIGN="TOP"><B>Field</B> <B>Name</B></P></TD><TD VALIGN="TOP"><B>Definition</B></P></TD></TR><TR><TD VALIGN="TOP">Byte</P></TD><TD VALIGN="TOP">Memory range descriptor</P></TD><TD VALIGN="TOP">Value = 10000001B (Type = 1, Large item name = 1)</P></TD></TR><TR><TD VALIGN="TOP">Byte</P></TD><TD VALIGN="TOP">Length, bits[7:0]</P></TD><TD VALIGN="TOP">Value = 00001001B (9)</P></TD></TR><TR><TD VALIGN="TOP">Byte</P></TD><TD VALIGN="TOP">Length, bits[15:8]</P></TD><TD VALIGN="TOP">Value = 00000000B</P></TD></TR><TR><TD VALIGN="TOP">Byte</P></TD><TD VALIGN="TOP">Information</P></TD><TD VALIGN="TOP">This field provides extra information about this memory.  </P>
Bit[7]                    <I>Reserved and must be 0</I><BR>Bit[6]     Memory is an expansion ROM<BR>Bit[5]     Memory is shadowable.<BR>Bits[4:3]     Memory control.  <BR>          Status<BR>          00     8-bit memory only<BR>          01     16-bit memory only<BR>          10     8- and 16-bit supported.<BR>          11          <I>Reserved</I><BR>Bit[2]     Support type<BR>          Status<BR>          1     decode supports high address<BR>          0     decode supports range length. <BR>Bit[1]     Cache support type<BR>          Status<BR>          1     read cacheable, write-through<BR>          0     non-cacheable.<BR>Bit[0]     Write status<BR>          Status<BR>          1     writeable<BR>          0     non-writeable (ROM)</P></TD></TR><TR><TD VALIGN="TOP">Byte</P></TD><TD VALIGN="TOP">Range minimum base address<BR>bits[7:0]</P></TD><TD VALIGN="TOP">Address bits[15:8] of the minimum base memory address for which the card may be configured.  </P></TD></TR><TR><TD VALIGN="TOP">Byte</P></TD><TD VALIGN="TOP">Range minimum base address<BR>bits[15:8]</P></TD><TD VALIGN="TOP">Address bits[23:16] of the minimum base memory address for which the card may be configured</P></TD></TR><TR><TD VALIGN="TOP">Byte</P></TD><TD VALIGN="TOP">Range maximum base address<BR>bits[7:0]</P></TD><TD VALIGN="TOP">Address bits[15:8] of the maximum base memory address for which the card may be configured.  </P></TD></TR><TR><TD VALIGN="TOP">Byte</P></TD><TD VALIGN="TOP">Range maximum base address<BR>bits[15:8]</P></TD><TD VALIGN="TOP">Address bits[23:16] of the maximum base memory address for which the card may be configured</P></TD></TR><TR><TD VALIGN="TOP"><BR>Byte</P></TD><TD VALIGN="TOP"><BR>Base alignment bits[7:0]</P></TD><TD VALIGN="TOP">This field contains the lower eight bits of the base alignment.  The base alignment provides the increment for the minimum base address. (0x0000 = 64 KByte)</P></TD></TR><TR><TD VALIGN="TOP"><BR>Byte</P></TD><TD VALIGN="TOP"><BR>Base alignment bits[15:8]</P></TD><TD VALIGN="TOP">This field contains the upper eight bits of the base alignment.  The base alignment provides the increment for the minimum base address.  (0x0000 = 64 KByte)</P></TD></TR><TR><TD VALIGN="TOP"><BR>Byte</P></TD><TD VALIGN="TOP"><BR>Range length bits[7:0]</P></TD><TD VALIGN="TOP">This field contains the lower eight bits of the memory range length.  The range length provides the length of the memory range in 256 byte blocks.</P></TD></TR><TR><TD VALIGN="TOP"><BR>Byte</P></TD><TD VALIGN="TOP"><BR>Range length bits[15:8]</P></TD><TD VALIGN="TOP">This field contains the upper eight bits of the memory range length.  The range length field provides the length of the memory range in 256 byte blocks.</P></TD></TR></TBODY></TABLE>
<BR></P>The minimum value for a valid base alignment is 256.  The minimum base address has to be aligned on the boundary specified by the alignment field.</P>
  </P>
<B>Note</B>   Address bits [7:0] of memory base addresses are assumed to be 0.</P>
  </P>
  </P>
<B>Note</B>   A Memory range descriptor can be used to describe a fixed memory address by setting the range minimum base address and the range maximum base address to the same value.</P>
  </P>
  </P>
<B>Note</B>   Mixing of 24-bit and 32-bit memory descriptors is not allowed (see section A.3.1).</P>
  </P>
<A NAME="PT17"></A>6.2.3.2. ANSI Identifier String</P>
  </P>

<TABLE COLS="3" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="154pt" VALIGN="TOP"><COL WIDTH="256pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><B>Size</B></P></TD><TD VALIGN="TOP"><B>Field Name</B></P></TD><TD VALIGN="TOP"><B>Definition</B></P></TD></TR><TR><TD VALIGN="TOP">Byte</P></TD><TD VALIGN="TOP">Identifier string</P></TD><TD VALIGN="TOP">Value = 10000010B (Type = 1, Large item name = 2)</P></TD></TR><TR><TD VALIGN="TOP">Byte</P></TD><TD VALIGN="TOP">Length, bits[7:0]</P></TD><TD VALIGN="TOP">Lower eight bits of identifier string length</P></TD></TR><TR><TD VALIGN="TOP">Byte</P></TD><TD VALIGN="TOP">Length, bits[15:8]</P></TD><TD VALIGN="TOP">Upper eight bits of identifier string length</P></TD></TR><TR><TD VALIGN="TOP">N * bytes</P></TD><TD VALIGN="TOP">Identifier string</P></TD><TD VALIGN="TOP">Device description as an ANSI string </P></TD></TR></TBODY></TABLE>
<BR></P>The identifier string is 8-bit ANSI. The length of the string is defined in the structure so the string does not need to be zero terminated. Display software will insure the proper termination gets added to the string so that the termination byte does not need to be stored in the card's non-volatile storage. Each card is required to have an identifier string, each logical device may optionally have an identifier string.</P>
<A NAME="PT18"></A>6.2.3.3. Unicode Identifier String</P>
  </P>

<TABLE COLS="3" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="154pt" VALIGN="TOP"><COL WIDTH="256pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><B>Size</B></P></TD><TD VALIGN="TOP"><B>Field Name</B></P></TD><TD VALIGN="TOP"><B>Definition</B></P></TD></TR><TR><TD VALIGN="TOP">Byte</P></TD><TD VALIGN="TOP">Identifier string</P></TD><TD VALIGN="TOP">Value = 10000011B (Type = 1, Large item name = 3)</P></TD></TR><TR><TD VALIGN="TOP">Byte</P></TD><TD VALIGN="TOP">Length, bits[7:0]</P></TD><TD VALIGN="TOP">Lower eight bits of length of string plus four</P></TD></TR><TR><TD VALIGN="TOP">Byte</P></TD><TD VALIGN="TOP">Length, bits[15:8]</P></TD><TD VALIGN="TOP">Upper eight bits of length of string plus four</P></TD></TR><TR><TD VALIGN="TOP">Byte</P></TD><TD VALIGN="TOP">Country identifier, bits[7:0]</P></TD><TD VALIGN="TOP"><I>To be determined</I></P></TD></TR><TR><TD VALIGN="TOP">Byte</P></TD><TD VALIGN="TOP">Country identifier, bits[15:8]</P></TD><TD VALIGN="TOP"><I>To be determined</I></P></TD></TR><TR><TD VALIGN="TOP">N * bytes</P></TD><TD VALIGN="TOP">Identifier string</P></TD><TD VALIGN="TOP">Device description characters</P></TD></TR></TBODY></TABLE>
<BR></P>Currently, only ANSI identifier strings are defined.  The definition for Unicode will be added at a later time.</P>
<A NAME="PT19"></A>6.2.3.4. Vendor Defined</P>
The vendor defined resource data type is for vendor use.</P>
  </P>

<TABLE COLS="3" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="154pt" VALIGN="TOP"><COL WIDTH="256pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><B>Size</B></P></TD><TD VALIGN="TOP"><B>Field Name</B></P></TD><TD VALIGN="TOP"><B>Definition</B></P></TD></TR><TR><TD VALIGN="TOP">Byte</P></TD><TD VALIGN="TOP">Vendor defined</P></TD><TD VALIGN="TOP">Value = 10000100B (Type = 1, Large item name = 4)</P></TD></TR><TR><TD VALIGN="TOP">Byte</P></TD><TD VALIGN="TOP">Length, bits[7:0]</P></TD><TD VALIGN="TOP">Lower eight bits of vendor defined data</P></TD></TR><TR><TD VALIGN="TOP">Byte</P></TD><TD VALIGN="TOP">Length, bits[15:8]</P></TD><TD VALIGN="TOP">Upper eight bits of vendor defined data</P></TD></TR><TR><TD VALIGN="TOP">N * bytes</P></TD><TD VALIGN="TOP">Vendor Defined</P></TD><TD VALIGN="TOP">Vendor defined data bytes</P></TD></TR></TBODY></TABLE>
<BR></P><A NAME="PT20"></A>6.2.3.5. 32-bit Memory Range Descriptor</P>
  </P>

<TABLE COLS="6" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="63pt" VALIGN="TOP"><COL WIDTH="1pt" VALIGN="TOP"><COL WIDTH="128pt" VALIGN="TOP"><COL WIDTH="2pt" VALIGN="TOP"><COL WIDTH="270pt" VALIGN="TOP"><COL WIDTH="28pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><B>Size</B></P></TD><TD COLSPAN="2" VALIGN="TOP"><B>Field Name</B></P></TD><TD COLSPAN="4" VALIGN="TOP"><B>Definition</B></P></TD></TR><TR><TD COLSPAN="2" VALIGN="TOP">Byte</P></TD><TD COLSPAN="3" VALIGN="TOP">Memory range descriptor</P></TD><TD COLSPAN="3" VALIGN="TOP">Value = 10000101B (Type = 1, Large item name = 5)</P></TD></TR><TR><TD COLSPAN="2" VALIGN="TOP">Byte</P></TD><TD COLSPAN="3" VALIGN="TOP">Length, bits[7:0]</P></TD><TD COLSPAN="3" VALIGN="TOP">Value = 00010001B (17)</P></TD></TR><TR><TD COLSPAN="2" VALIGN="TOP">Byte</P></TD><TD COLSPAN="3" VALIGN="TOP">Length, bits[15:8]</P></TD><TD COLSPAN="3" VALIGN="TOP">Value = 00000000B</P></TD></TR><TR><TD COLSPAN="2" VALIGN="TOP">Byte</P></TD><TD COLSPAN="3" VALIGN="TOP">Information</P></TD><TD COLSPAN="3" VALIGN="TOP">This field provides extra information about this memory.  </P>
Bit[7]                    <I>Reserved and must be 0</I><BR>Bit[6]     Memory is an expansion ROM<BR>Bit[5]     Memory is shadowable.<BR>Bits[4:3]     Memory control.  <BR>          Status<BR>          00     8-bit memory only<BR>          01     16-bit memory only<BR>          10     8- and 16-bit supported.<BR>          11     32-bit memory only<BR>Bit[2]     Support type<BR>          Status<BR>          1     decode supports high address<BR>          0     decode supports range length <BR>Bit[1]     Cache support type<BR>          Status<BR>          1     read cacheable, write-through<BR>          0     non-cacheable.<BR>Bit[0]     Write status<BR>          Status<BR>          1     writeable<BR>          0     non-writeable (ROM)</P></TD></TR><TR><TD COLSPAN="2" VALIGN="TOP">Byte</P></TD><TD COLSPAN="3" VALIGN="TOP">Range minimum base address<BR>bits[7:0]</P></TD><TD COLSPAN="3" VALIGN="TOP">Address bits[7:0] of the minimum base memory address for which the card may be configured.  </P></TD></TR><TR><TD COLSPAN="2" VALIGN="TOP">Byte</P></TD><TD COLSPAN="3" VALIGN="TOP">Range minimum base address<BR>bits[15:8]</P></TD><TD COLSPAN="3" VALIGN="TOP">Address bits[15:8] of the minimum base memory address for which the card may be configured</P></TD></TR><TR><TD COLSPAN="2" VALIGN="TOP">Byte</P></TD><TD COLSPAN="3" VALIGN="TOP">Range minimum base address<BR>bits[23:16]</P></TD><TD COLSPAN="3" VALIGN="TOP">Address bits[23:16] of the minimum base memory address for which the card may be configured.  </P></TD></TR><TR><TD COLSPAN="2" VALIGN="TOP">Byte</P></TD><TD COLSPAN="3" VALIGN="TOP">Range minimum base address<BR>bits[31:24]</P></TD><TD COLSPAN="3" VALIGN="TOP">Address bits[31:24] of the minimum base memory address for which the card may be configured</P></TD></TR><TR><TD COLSPAN="2" VALIGN="TOP">Byte</P></TD><TD COLSPAN="3" VALIGN="TOP">Range maximum base address<BR>bits[7:0]</P></TD><TD COLSPAN="3" VALIGN="TOP">Address bits[7:0] of the maximum base memory address for which the card may be configured.  </P></TD></TR><TR><TD COLSPAN="2" VALIGN="TOP">Byte</P></TD><TD COLSPAN="3" VALIGN="TOP">Range maximum base address<BR>bits[15:8]</P></TD><TD COLSPAN="3" VALIGN="TOP">Address bits[15:8] of the maximum base memory address for which the card may be configured</P></TD></TR><TR><TD COLSPAN="2" VALIGN="TOP">Byte</P></TD><TD COLSPAN="3" VALIGN="TOP">Range maximum base address<BR>bits[23:16]</P></TD><TD COLSPAN="3" VALIGN="TOP">Address bits[23:16] of the maximum base memory address for which the card may be configured.  </P></TD></TR><TR><TD COLSPAN="2" VALIGN="TOP">Byte</P></TD><TD COLSPAN="3" VALIGN="TOP">Range maximum base address<BR>bits[31:24]</P></TD><TD COLSPAN="3" VALIGN="TOP">Address bits[31:24] of the maximum base memory address for which the card may be configured</P></TD></TR><TR><TD COLSPAN="2" VALIGN="TOP"><BR>Byte</P></TD><TD COLSPAN="3" VALIGN="TOP"><BR>Base alignment bits[7:0]</P></TD><TD COLSPAN="3" VALIGN="TOP">This field contains Bits[7:0] of the base alignment.  The base alignment provides the increment for the minimum base address.</P></TD></TR><TR><TD COLSPAN="2" VALIGN="TOP"><BR>Byte</P></TD><TD COLSPAN="3" VALIGN="TOP"><BR>Base alignment bits[15:8]</P></TD><TD COLSPAN="3" VALIGN="TOP">This field contains Bits[15:8] of the base alignment.  The base alignment provides the increment for the minimum base address.</P></TD></TR><TR><TD COLSPAN="2" VALIGN="TOP"><BR>Byte</P></TD><TD COLSPAN="3" VALIGN="TOP"><BR>Base alignment bits[23:16]</P></TD><TD COLSPAN="3" VALIGN="TOP">This field contains Bits[23:16] of the base alignment.  The base alignment provides the increment for the minimum base address. </P></TD></TR><TR><TD COLSPAN="2" VALIGN="TOP"><BR>Byte</P></TD><TD COLSPAN="3" VALIGN="TOP"><BR>Base alignment bits[31:24]</P></TD><TD COLSPAN="3" VALIGN="TOP">This field contains Bits[31:24] of the base alignment.  The base alignment provides the increment for the minimum base address.</P></TD></TR><TR><TD COLSPAN="2" VALIGN="TOP"><BR>Byte</P></TD><TD COLSPAN="3" VALIGN="TOP"><BR>Range length bits[7:0]</P></TD><TD COLSPAN="3" VALIGN="TOP">This field contains Bits[7:0] of the memory range length.  The range length provides the length of the memory range in 1 byte blocks.</P></TD></TR><TR><TD COLSPAN="2" VALIGN="TOP"><BR>Byte</P></TD><TD COLSPAN="3" VALIGN="TOP"><BR>Range length bits[15:8]</P></TD><TD COLSPAN="3" VALIGN="TOP">This field contains Bits[15:8] of the memory range length.  The range length provides the length of the memory range in 1 byte blocks.</P></TD></TR><TR><TD COLSPAN="2" VALIGN="TOP"><BR>Byte</P></TD><TD COLSPAN="3" VALIGN="TOP"><BR>Range length bits[23:16]</P></TD><TD COLSPAN="3" VALIGN="TOP">This field contains Bits[23:16] of the memory range length.  The range length provides the length of the memory range in 1 byte blocks.</P></TD></TR><TR><TD COLSPAN="2" VALIGN="TOP"><BR>Byte</P></TD><TD COLSPAN="3" VALIGN="TOP"><BR>Range length bits[31:24]</P></TD><TD COLSPAN="3" VALIGN="TOP">This field contains Bits[31:24] of the memory range length.  The range length provides the length of the memory range in 1 byte blocks.</P></TD></TR></TBODY></TABLE>
<BR></P>  </P>
<B>Note</B>   Mixing of 24-bit and 32-bit memory descriptors is not allowed (see section A.3.1).</P>
  </P>
<A NAME="PT21"></A>6.2.3.6. 32-bit Fixed Location Memory Range Descriptor</P>
NULL Memory Range Descriptor: Range Length field set to all zeros (all other fields ignored).</P>
PnP Software action: Corresponding base address registers and limit address/range length registers programmed to all zeros.</P>
</P>
  </P>

<TABLE COLS="3" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="64pt" VALIGN="TOP"><COL WIDTH="144pt" VALIGN="TOP"><COL WIDTH="256pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><B>Size</B></P></TD><TD VALIGN="TOP"><B>Field Name</B></P></TD><TD VALIGN="TOP"><B>Definition</B></P></TD></TR><TR><TD VALIGN="TOP">Byte</P></TD><TD VALIGN="TOP">Memory range descriptor</P></TD><TD VALIGN="TOP">Value = 10000110B (Type = 1, Large item name = 6)</P></TD></TR><TR><TD VALIGN="TOP">Byte</P></TD><TD VALIGN="TOP">Length, bits[7:0]</P></TD><TD VALIGN="TOP">Value = 00001001B (9)</P></TD></TR><TR><TD VALIGN="TOP">Byte</P></TD><TD VALIGN="TOP">Length, bits[15:8]</P></TD><TD VALIGN="TOP">Value = 00000000B</P></TD></TR><TR><TD VALIGN="TOP">Byte</P></TD><TD VALIGN="TOP">Information</P></TD><TD VALIGN="TOP">This field provides extra information about this memory.  </P>
Bit[7]                    <I>Reserved and must be 0</I><BR>Bit[6]     Memory is an expansion ROM<BR>Bit[5]     Memory is shadowable.<BR>Bits[4:3]     Memory control.  <BR>          Status<BR>          00     8-bit memory only<BR>          01     16-bit memory only<BR>          10     8- and 16-bit supported.<BR>          11     32-bit memory only<BR>Bit[2]     Support type<BR>          Status<BR>          1     decode supports high address<BR>          0     decode supports range length<BR>Bit[1]     Cache support type<BR>          Status<BR>          1     read cacheable, write-through<BR>          0     non-cacheable.<BR>Bit[0]     Write status<BR>          Status<BR>          1     writeable<BR>          0     non-writeable (ROM)</P></TD></TR><TR><TD VALIGN="TOP">Byte</P></TD><TD VALIGN="TOP">Range base address<BR>bits[7:0]</P></TD><TD VALIGN="TOP">Address bits[7:0] of the base memory address for which the card may be configured.  </P></TD></TR><TR><TD VALIGN="TOP">Byte</P></TD><TD VALIGN="TOP">Range base address<BR>bits[15:8]</P></TD><TD VALIGN="TOP">Address bits[15:8] of the base memory address for which the card may be configured</P></TD></TR><TR><TD VALIGN="TOP">Byte</P></TD><TD VALIGN="TOP">Range base address<BR>bits[23:16]</P></TD><TD VALIGN="TOP">Address bits[23:16] of the base memory address for which the card may be configured.  </P></TD></TR><TR><TD VALIGN="TOP">Byte</P></TD><TD VALIGN="TOP">Range base address<BR>bits[31:24]</P></TD><TD VALIGN="TOP">Address bits[31:24] of the base memory address for which the card may be configured</P></TD></TR><TR><TD VALIGN="TOP"><BR>Byte</P></TD><TD VALIGN="TOP"><BR>Range length bits[7:0]</P></TD><TD VALIGN="TOP">This field contains Bits[7:0] of the memory range length.  The range length provides the length of the memory range in 1 byte blocks.</P></TD></TR><TR><TD VALIGN="TOP"><BR>Byte</P></TD><TD VALIGN="TOP"><BR>Range length bits[15:8]</P></TD><TD VALIGN="TOP">This field contains Bits[15:8] of the memory range length.  The range length provides the length of the memory range in 1 byte blocks.</P></TD></TR><TR><TD VALIGN="TOP"><BR>Byte</P></TD><TD VALIGN="TOP"><BR>Range length bits[23:16]</P></TD><TD VALIGN="TOP">This field contains Bits[23:16] of the memory range length.  The range length provides the length of the memory range in 1 byte blocks.</P></TD></TR><TR><TD VALIGN="TOP"><BR>Byte</P></TD><TD VALIGN="TOP"><BR>Range length bits[31:24]</P></TD><TD VALIGN="TOP">This field contains Bits[31:24] of the memory range length.  The range length provides the length of the memory range in 1 byte blocks.</P></TD></TR></TBODY></TABLE>
<BR></P>The minimum base address has to be aligned on the boundary specified by the alignment field.</P>
  </P>
<B>Note</B>   Mixing of 24-bit and 32-bit memory descriptors is not allowed (see section A.3.1).</P>
  </P>
 </P></BODY></HTML>
