<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>

<HEAD><META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SMART IOCTL API Specification</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>

<BODY TOPMARGIN=0 LEFTMARGIN=10 BGCOLOR="#FFFFFF" LINK="#000066"
VLINK="#666666" TEXT="#000000">



<font size="2" face="verdana,arial,helvetica">
<!--DocHeaderEnd-->
<h2>SMART IOCTL API Specification</h2>
This specification describes the API for an application to issue SMART commands to an IDE drive under Microsoft&#174; Windows&#174; 95 and Windows NT&reg;. Under Windows 95, the API is implemented in a Vendor Specific Driver (VSD), Smartvsd.vxd.
<P>SMART functionality is implemented as a "pass through" mechanism whereby the application sets up the IDE registers in a structure and passes it to the driver through the DeviceIoControl API. The registers are checked for validity and passed to the IDE port driver for execution. Any error from the IDE interface is returned to the application.
<P>SMART stands for Self-Monitoring Analysis and Reporting Technology. You can find more information on SMART in the document SFF8035 version 1.0.
<P>DFP stands for Disk Fault Prediction, and was an early naming of SMART. As you can see, the acronym still occurs in command names.
<h2>Software Interface</h2>
<P>The interface to the driver is via the Win32&#174; DeviceIoControl API function. Before an application can call the DeviceIoControl API, a handle to the target driver must be obtained by a call to the CreateFile API. Under Windows 95, the driver will be automatically loaded if it is placed it in the \Windows\System\IOsubsys directory, so it will not be necessary for application software to load it.
<P>The DeviceIoControl API is documented in the Win32 online reference guide as follows:
<P><img src="iocl1.gif" alt="DeviceIOControl" width=605 height=149 border=0>
<P>
<BR>The DeviceIoControl function sends a control code directly to a device driver, causing the given device to perform the specified operation. 
<h3>Parameters</h3>
<P><b>hDevice</b>
<P>Identifies the device. The CreateFile function returns this handle. 
<P><b>dwIoControlCode</b>
<P>Specifies the control code for the operation. This value identifies the specific operation to be performed and the type of device on which the operation is to be performed. The following values are defined for this driver. 
<P>
<TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="Arial" SIZE=2><b>Value</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>Meaning</b></FONT></TD></TR>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>DFP_GET_VERSION (0x00074080)</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Gets the version and revision number of the driver.
</FONT></TD></TR>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>DFP_SEND_DRIVE_COMMAND (0x0007c084)</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Sends a command to a drive. Sends a command to a drive that sends data. If a command is sent to a drive that does not send data, no data is transferred.
</FONT></TD></TR>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>DFP_RECEIVE_DRIVE_DATA (0x0007c088)</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Sends a command to the drive that returns data.
</FONT></TD></TR>
</TABLE><b>pvInBuffer</b>
<P>Points to a buffer containing the data required to perform the operation. This parameter can be NULL if the dwIoControlCode parameter specifies an operation that does not require input data. 
<P><b>cbInBuffer</b>
<P>Specifies the size, in bytes, of the lpvInBuffer buffer. 
<P><b>lpvOutBuffer</b>
<P>Points to a buffer in which the operation's output data is returned. This parameter can be NULL if the dwIoControlCode parameter specifies an operation that does not produce output data. 
<P><b>cbOutBuffer</b>
<P>Specifies the size, in bytes, of the lpvOutBuffer buffer. 
<P><b>lpcbBytesReturned</b>
<P>Points to a 32-bit variable that receives the size, in bytes, of the data returned in the lpvOutBuffer buffer. 
<P><b>lpoOverlapped</b>
<P>Points to an OVERLAPPED structure. This parameter is ignored if the hDevice handle was opened without specifying the FILE_FLAG_OVERLAPPED flag. This parameter can be NULL if you do not want overlapped operation.
<P>OVERLAPPED (asynchronous) I/O will not be used by this driver, so this parameter should be set to NULL.
<P><b>Return Value</b>
<P>If the function succeeds, the return value is TRUE; otherwise, it is FALSE. To get extended error information, use the GetLastError function. 
<P><h3>Functions</h3>
<P>The following functions are supported.
<P>
<TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="Arial" SIZE=2><b>Value</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>Meaning</b></FONT></TD></TR>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>DFP_GET_VERSION</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Gets the version and revision number of the driver.
</FONT></TD></TR>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>DFP_SEND_DRIVE_COMMAND </FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Sends a command to a drive Sends a command to a drive that sends data. If a command is sent to a drive that does not send data, no data is transferred.
</FONT></TD></TR>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>DFP_RECEIVE_DRIVE_DATA </FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Sends a command to the drive that returns data.
</FONT></TD></TR>
</TABLE><h5>DFP_GET_VERSION</h5>
<P>This function returns the version of the driver and its capabilities.
<P>The input parameters to DeviceIoControl for this function are as follows.
<P>
<TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="Arial" SIZE=2><b>Parameter</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>Value</b></FONT></TD></TR>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>hDevice</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Handle returned from CreateFile function</FONT></TD></TR>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>DwIoControlCode</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>DFP_GET_VERSION (see Data Structures section for value)</FONT></TD></TR>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>lpvInBuffer</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>NULL</FONT></TD></TR>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>cbInBuffer</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>0</FONT></TD></TR>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>LpvOutBuffer</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Pointer to GetVersionOutParams structure (see Data Structures section for definition)</FONT></TD></TR>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>cbOutBuffer</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Size of the GetVersionOutParams structure </FONT></TD></TR>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>LpcbBytesReturned</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Pointer to DWORD to receive number of bytes returned</FONT></TD></TR>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>lpoOverlapped</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>NULL</FONT></TD></TR>
</TABLE><h5>DFP_SEND_DRIVE_COMMAND </h5>
<P>This Ioctl command code is used to send a DFP command to the disk controller when the command will either transfer data to the drive or when the command will not transfer any data.
<P>The input parameters to DeviceIoControl for this function are as follows.
<P>
<TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="Arial" SIZE=2><b>Parameter</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>Value</b></FONT></TD></TR>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>hDevice</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Handle returned from CreateFile function</FONT></TD></TR>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>DwIoControlCode</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>DFP_SEND_DRIVE_COMMAND (see "Data Structures" section for value)</FONT></TD></TR>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>lpvInBuffer</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Pointer to SendCommandInParams (see "Data Structures" section for definition)</FONT></TD></TR>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>cbInBuffer</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Size of SendCommandInParams (accounting for buffer length)</FONT></TD></TR>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>LpvOutBuffer</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Pointer to SendCmdOutParams structure (see "Data Structures" section for definition)</FONT></TD></TR>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>cbOutBuffer</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Size of SendCmdOutParams structure (accounting for buffer length of zero)</FONT></TD></TR>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>LpcbBytesReturned</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Pointer to DWORD to receive number of bytes returned</FONT></TD></TR>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>lpoOverlapped</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>NULL</FONT></TD></TR>
</TABLE><h5>DFP_RECEIVE_DRIVE_DATA</h5>
<P>Uses same arguments as Send Command to Drive. The field cBufferSize in SENDCMDINPARAMS is the maximum size of the expected output from the command.
<P>This Ioctl command code is used to send a DFP command that will transfer data from the drive, or to send an Identify command to the disk controller.
<P>The input parameters to DeviceIoControl for this function are as follows.
<P>
<TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="Arial" SIZE=2><b>Parameter</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>Value</b></FONT></TD></TR>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>hDevice</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Handle returned from CreateFile function</FONT></TD></TR>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>DwIoControlCode</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>DFP_RECEIVE_DRIVE_DATA (see "Data Structures" section for value)</FONT></TD></TR>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>lpvInBuffer</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Pointer to SendCommandInParams (see "Data Structures" section for definition)</FONT></TD></TR>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>cbInBuffer</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Size of SendCommandInParams</FONT></TD></TR>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>LpvOutBuffer</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Pointer to SendCmdOutParams structure (see "Data Structures" section for definition)</FONT></TD></TR>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>cbOutBuffer</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Size of SendCmdOutParams structure (accounting for buffer length)</FONT></TD></TR>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>LpcbBytesReturned</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Pointer to DWORD to receive number of bytes returned</FONT></TD></TR>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>lpoOverlapped</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>NULL</FONT></TD></TR>
</TABLE><h3>Error Handling</h3>
<P>DeviceIoControl returns FALSE when it fails and TRUE when it succeeds. There are many types of failure, both from the DeviceIoControl API and from the driver. In order to determine the exact cause of an error, the application must examine three values: the return code from DeviceIoControl, the value returned from the GetLastError API, and the status value returned by the driver. Unfortunately, the current documentation for DeviceIoControl does not specify the error values from the API. Therefore, the driver will not attempt to pass error information through the GetLastError function but will use the DriverStatusStructure to pass error information back to the caller.
<P>Before calling the IOCTL APIs in the driver, set the bDriverError member of the DriverStatusStructure to zero. Then, if the return code from DeviceIoControl is FALSE, check the bDriverError member of DriverStatusStructure. If it is nonzero, the error is from the driver. If it is zero, the error is from DeviceIoControl and GetLastError must be called to determine the exact error.
<P><b>IMPORTANT</b>: If the driver cannot validate the DriverStatus structure, it will not attempt to place error codes in it. This might occur when the address is NULL or when the length passed is not valid.
<P><h3>Supported Commands</h3>
<P>There are three IDE commands supported in this driver, ID (0xEC), ATAPI ID (0xA1), and SMART (0xB0). The "subcommands" of the SMART commands (features register values) are limited to the currently defined values (0xD0 through 0xD6, 0xD8 through 0xEF). SMART subcommand 0xD7, write threshold value, is not allowed. Any other command or SMART subcommand will result in an error being returned from the driver. Any SMART command that is not currently implemented on the target drive will result in an ABORT error from the IDE interface.
<P><h3>Data Structures</h3>
<P>The following data structures and constants are used in the API.
<P><b>Note</b> All reserved fields should be set to zero. All structures are aligned on DWORD boundaries.
<P><h4>GetVersionOutParams</h4>
<P>This structure contains the data returned from the Get Driver Version function.
<P><img src="iocl2.gif" alt="GetVersionOutParams" width=630 height=107 border=0>
<P>The bit positions of the fCapabilities member are defined as follows.
<P>
<TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="Arial" SIZE=2><b>Bit</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Name</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Value</FONT></TD></TR>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>0</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>IDE IDENTIFY Cmd</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>0 = not supported, 1 = supported</FONT></TD></TR>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>1</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>ATAPI IDENTIFY Cmd</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>0 = not supported, 1 = supported</FONT></TD></TR>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>2</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>SMART command set</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>0 = not supported, 1 = supported</FONT></TD></TR>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>3-31</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Reserved for future</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>0</FONT></TD></TR>
</TABLE>
<BR>The bit positions of the bIDEDeviceMap member are defined as follows.
<P>
<TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="Arial" SIZE=2><b>Bit</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Meaning</FONT></TD></TR>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>0</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>IDE device is attached to primary controller, drive 0.
</FONT></TD></TR>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>1</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>IDE device is attached to primary controller, drive 1.
</FONT></TD></TR>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>2</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>IDE device is attached to secondary controller, drive 0.
</FONT></TD></TR>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>3</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>IDE device is attached to secondary controller, drive 1.
</FONT></TD></TR>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>4</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>ATAPI device is attached to primary controller, drive 0.
</FONT></TD></TR>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>5</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>ATAPI device is attached to primary controller, drive 1.
</FONT></TD></TR>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>6</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>ATAPI device is attached to secondary controller, drive 0.
</FONT></TD></TR>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>7</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>ATAPI device is attached to secondary controller, drive 1.
</FONT></TD></TR>
</TABLE><h4>SendCmdInParams</h4>
<P>This structure contains the input parameters for the Send Command To Drive functions that will transfer data to the drive:
<P><img src="iocl3.gif" alt="SendCmdInParams" width=599 height=121 border=0>
<P><b>Note</b> The bDriveNumber parameter corresponds to the four possible IDE drives in an ATA system. 0 is the first drive on the first controller, 1 is the second drive on the first controller, 2 is the first drive on the second controller, and 3 is the third drive on the second controller. An application can determine drive mappings by examining the bIDEDeviceMap member of the GETVERSIONOUTPARAMS structure. If the command will not result in any data being transferred to the drive, cBufferSize should be set to zero.
<P><h4>DriverStatus</h4>
<P>This structure contains the result of any command to the SMART driver.
<P><img src="iocl4.gif" alt="DriverStatus" width=515 height=79 border=0>

<P><h4>SendCmdOutParams</h4>
<P><img src="iocl5.gif" alt="SendCmdOutParams" width=599 height=79 border=0>

<P><b>Note</b> cBufferSize is filled in the driver to indicate how much data was returned in the bBuffer location.
<P><h4>IDERegs</h4>
<P>This structure contains the values to be written to the IDE registers by the driver. It is used in the SendCmdInParams structure. Although most of these values do not need to be specified by the application, allowing the application to specify them increases the flexibility of the interface. This is subject to review and revision. See each individual command for information on the required register values.
<P><img src="iocl6.gif" alt="IDERegs" width=584 height=135 border=0>typedef struct _IDEREGS {

<P><h4>Error Definitions</h4>
<P>This section summarizes the errors that can be returned from the device I/O control
<P><h5>Returned from DeviceIoControl</h5>
<P>The following errors are possible on the device I/O control.
<P>
<TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="Arial" SIZE=2><b>Error</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>Meaning</b></FONT></TD></TR>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>ERROR_ACCESS_DENIED</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>User is not allowed to make this request.
</FONT></TD></TR>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>ERROR_NOT_ENOUGH_MEMORY</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>System could not issue request due to resource requirements.
</FONT></TD></TR>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>ERROR_INVALID_FUNCTION</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>The IOCTL code passed was invalid.
</FONT></TD></TR>
</TABLE><h5>Returned in Output Buffer</h5>
<P>The following driver errors are defined.
<P>
<TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="Arial" SIZE=2><b>Error</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>Value</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>Meaning</b></FONT></TD></TR>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>NO_ERROR</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>0</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>No error.
</FONT></TD></TR>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>IDE_ERROR</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>1</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>IDE command resulted in an error from the drive/controller. Examine bIDEStatus to determine the error. bIDEStatus will contain the value read from the IDE error register.
</FONT></TD></TR>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>INVALID_FLAG</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>2</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>An invalid command flag was passed.
</FONT></TD></TR>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>INVALID_COMMAND</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>3</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>An invalid IDE drive command register was passed. In this version of the driver, only the IDENTIFY (0xEC), ATAPI IDENTIFY (0xA1), and DFP (0xB0) commands are valid.
</FONT></TD></TR>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>INVALID_BUFFER</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>4</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>A buffer pointer was not valid (bad pointer, bad length, etc.). This could be any pointer passed to the driver.
</FONT></TD></TR>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>INVALID_DRIVE</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>5</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>The drive number was invalid. Either the drive number or the value in the drive/head register was not valid.
</FONT></TD></TR>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>ERROR_NO_MEM</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>7</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Could not lock user's buffer for I/O.
</FONT></TD></TR>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>INVALID_REGISTER</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>8</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Some IDE register (besides the command and drive/head register) value not valid. Examples are invalid DFP "subcommands" in the features register.
</FONT></TD></TR>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>NOT_SUPPORTED</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>9</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>A bit has been set in the fCmdFlags that the driver does not support, or a reserved field is nonzero.
</FONT></TD></TR>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>NO_IDE_DEVICE</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>10</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>No device attached to the controller that is specified by the drive number passed in the command.
</FONT></TD></TR>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>RESERVED</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>11-255</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Reserved for future.
</FONT></TD></TR>
</TABLE><h3>Driver Name</h3>
<P>Under Windows 95, the name of the executable is Smartvsd.vxd. This file will reside in the \Windows\System\IOsubsys directory.
<P>

<p>
&#169; 1997 Microsoft Corporation. All rights reserved. <a href="http://www.microsoft.com/misc/cpyright.htm">Legal Notices.</a>

</blockquote>

</font>
</body>
</html>
