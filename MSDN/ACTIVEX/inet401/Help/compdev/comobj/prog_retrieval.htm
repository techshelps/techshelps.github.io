<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Data Path Properties</TITLE>

<META NAME=MS-HKWD CONTENT="Data Path Properties">
<META NAME="Keywords" CONTENT="Component Development">
<META NAME="Platform" CONTENT="Windows, Win95, WinNT">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=iso8859-1">
<META NAME="MS.LOCALE" CONTENT="EN-US">
<META NAME="ROBOTS" CONTENT="all">


<SCRIPT>
//<!--
var g_isIE = false, g_isNav = false, g_iMaj = 0, g_sPlat = "";
// -->
</SCRIPT>
<SCRIPT SRC="../../code/ver.js"></SCRIPT>


<SCRIPT DEFER SRC="../../code/common.js"></SCRIPT>
<SCRIPT DEFER>
//<!--
function InitPage()
{
	if (g_isIE && g_iMaj >= 4)	
	{
		SetTOC();
	}
}
//-->
</SCRIPT>

<LINK REL="stylesheet" HREF="/msdn/sdk/inetsdk/help/basicsdkIE4.css" TYPE="text/css">
<!-- STYLE_START -->


<SCRIPT>
//<!--
   var sVR = '../../'	// Set root for the style sheet
   var sCSS = '<LINK REL="stylesheet" HREF="' + sVR;

   if(g_isIE)
   {
	   if (g_iMaj >= 4) // For MSIE 4.0 or later
	   {
		   sCSS += 'basicSDKIE4';
		   if (g_sPlat == "Win") // Windows only for now
		   {
			   document.createStyleSheet(sVR + 'advSDKIE4.css');
		   }
	   }
	   else // For MSIE 3.0 or earlier
	   {
		   sCSS += 'basicSDKIE3';
	   }
   }
   else if (g_isNav) // For all Nav versions
   {
	   sCSS += 'basicSDKNAV';
   }
   else
   {
	   sCSS += 'basicSDKIE3'; // default to IE3 sheet
   }

   sCSS += (sCSS == '' ? '' : '.css" TYPE="text/css">');

   document.write(sCSS);
//-->
</SCRIPT>
<!-- STYLE_END -->
</HEAD>
<BODY onload="InitPage()" BGCOLOR="#FFFFFF">

<A NAME="pagetop"></A><A NAME="prog_retrieval"></A>
<!-- NAV_LINKS_START -->
<TABLE class=main BORDER=0 CELLSPACING="0" CELLPADDING="0" WIDTH="10%"><TR><TD ROWSPAN="3" VALIGN="TOP" WIDTH="121"><IMG SRC="../../art/headbar2.gif" WIDTH="121" HEIGHT="82" BORDER=0 ALT="Data Path Properties"></TD><TD ROWSPAN="2" VALIGN="TOP" WIDTH="186"><IMG SRC="../../art/headbarc.gif" WIDTH="186" HEIGHT="44" BORDER=0 ALT="Data Path Properties"></TD><TD VALIGN="TOP" WIDTH="470"><IMG SRC="../../art/replace1.gif" WIDTH="470" HEIGHT="17" BORDER=0 ALT="*"></TD></TR><TR><TD><PRE><IMG SRC="../../art/arrowrht.gif" WIDTH="14" HEIGHT="14" ALIGN="MIDDLE" BORDER=0 ALT="*"><object id="hhal_1" type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Item1" value="">
<PARAM name="Item2" value=_win32_Contents>
</object><A STYLE="color:black" ID=TOC HREF=JavaScript:hhal_1.Click()>Contents</A>  <IMG SRC="../../art/arrowrht.gif" WIDTH="14" HEIGHT="14" ALIGN="MIDDLE" BORDER=0 ALT="*"><object id="hhal_2" type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Item1" value="">
<PARAM name="Item2" value=_win32_Index_1sz1>
</object><A STYLE="color:black" HREF=JavaScript:hhal_2.Click()>Index</A>  <IMG SRC="../../art/arrowrht.gif" WIDTH="14" HEIGHT="14" ALIGN="MIDDLE" BORDER=0 ALT="*"><object id="hhal_3" type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Item1" value="">
<PARAM name="Item2" value=_win32_COM_Objects_for_the_Internet>
</object><A STYLE="color:black" HREF=JavaScript:hhal_3.Click()>Topic Contents</A>
</PRE></TD></TR>
<TR><TD COLSPAN="2"><PRE><IMG SRC="../../art/arrowlft.gif" WIDTH="17" HEIGHT="15" ALIGN="MIDDLE" BORDER=0 ALT="*"><B>Previous Topic:</B> <A STYLE="color:black" HREF="store_persist.htm">Storage of Control Persistent Data</A>
<IMG SRC="../../art/arrownxt.gif" WIDTH="17" HEIGHT="16" ALIGN="MIDDLE" BORDER=0 ALT="*"><B>Next Topic:</B> <A  STYLE="color:black" HREF="data_retrieval.htm">Cooperative and Asynchronous Data Retrieval</A>
</PRE></TD></TR>
</TABLE>
<!-- NAV_LINKS_END -->
<BLOCKQUOTE class="body">
<!-- CONTENTS_START -->
<h1>Data Path Properties</h1>

<P>The impetus for much of the work in this document finds its origins in the concept of "progressive rendering" ("progressive disclosure") for something like a picture or a picture control. In such cases, the picture should be able to display an initial low-detail picture, followed by mid-detail and high-detail renderings.

<P>This document is, however, concerned with the more general problem of retrieving any significant amounts of data in a cooperative fashion from possibly many distributed locations after the control has already been instantiated and is possibly interacting with the container and the user in other ways. This capability has been called "Progressive Rendering," "Progressive Property Disclosure," and "Progressive Downloading." The term "Progressive Data Retrieval" will be used to refer to all of these more special cases at once, because it makes no assumptions about the exact type of data that is being retrieved&#151;for example, it might be properties, might be images, might be anything.

<P>In all the following sections, it is very important to keep in mind that the control is ultimately responsible for specifying the exact format and structure of any linked data and decides exactly how it will be pulled from the named source. The container has nothing to do with this other than being able to control the relative priority of the retrieval and being notified when the loading state of a control changes. So, for example, a container doesn't have to care about how a picture control chooses to progressively render low-, mid-, and high-detail images (from a GIF, for instance). The picture control would internally know where and how each image is stored in its data, and retrieve those in turn. The container would then be notified through
<object id="hhal_4" type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Item1" value="">
<PARAM name="Item2" value=_win32_Further_Reading>
</object><A HREF=JavaScript:hhal_4.Click()>IAdviseSink::OnViewChange</A> when the control has enough data to do something meaningful in <B>IViewObject2::Draw</B> (which is a moot point for an in-place active control whose window is visible because the control would just update itself, but this will be important later on for windowless controls).

<P>The point of all this is that the container chooses where to tell controls to store and retrieve their data; the controls choose how to store and retrieve that data in a cooperative, asynchronous, and progressive manner. The asynchronous aspect may apply to none, some, or all of a control's data.

<P>This section is, thus, about "Data Path Properties," and describes the architecture for having a control save and load pieces of its data (BLOBs especially) in locations other than where the control's properties are kept. That is, for any number of reasons, it may be inappropriate or impossible for a control to store absolutely all of its data in the same location as its properties. Here are some examples:

<UL>
<LI>The control is being embedded and its BLOB data is too large to store in an embedded manner, such as in an HTML document.
<LI>The control wants to retrieve BLOBs in an asynchronous manner regardless of where the control's properties are stored. A video control is a good example where this would be important.
<LI>The control may be sharing BLOBs with other controls so it is inappropriate and/or wasteful to duplicate the BLOB in each control's persistent state (this is similar to the original linking concept in OLE Documents). Sharing a company logo across many Web pages is a good example, and excellent performance can be achieved in this case when a URL cache is in operation&#151;the BLOB itself may have already been downloaded from another page and can simply be pulled from the cache immediately.
<LI>The control may want to allow BLOBs to be modified so that whenever the control retrieves the data, it can retrieve the most recent information. A weather-map control that always shows the latest satellite image is a good example.
<LI>The control may simply want to separate properties from BLOBs for its own reasons.
</UL>

<P>To address these particular concerns, a control may use one or more "Data Path Properties" to reference external sources of data. As shown in the following illustration, each "path" (as they're called for short) is a value of some kind that is stored like any other properties in the control's persistent data. When the control needs to retrieve data from a source, it has the container create a moniker from the string representation of the property value and calls
<object id="hhal_5" type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Item1" value="">
<PARAM name="Item2" value=_win32_Further_Reading>
</object><A HREF=JavaScript:hhal_5.Click()>IMoniker::BindToStorage</A> to retrieve some sort of storage pointer (usually
<object id="hhal_6" type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Item1" value="">
<PARAM name="Item2" value=_win32_Further_Reading>
</object><A HREF=JavaScript:hhal_6.Click()>IStream</A>, but not limited to that). In binding a URL moniker, the control can choose whether the binding itself will be synchronous or asynchronous, and whether or not the data transfer itself will be synchronous or asynchronous.

<P>

<P><IMG SRC="../../art/comobj4.gif" WIDTH="208" HEIGHT="136" ALT="Figure 4: Data Path Properties are values which can be parsed into monikers that reference sources of data external to the control's embedded properties" >

<P>

<P>In short, each path property is a control-managed "link" to an outside data source. As described in an earlier section, this capability has always been available in OLE Documents, except that such links were always internal to the control. Such hidden use of external resources is not acceptable in the Internet environment where authoring tools need to manage the interconnections between many Internet sites.

<P>Data Path Properties address the following issues:

<UL>
<LI>How to expose the existence of path properties from a control.
<LI>How to specify exactly what type of data a particular path should refer to so that an authoring tool can provide appropriate browsing UI or automatically assign a path property referring to the correct format of data.
<LI>How to assign values to path properties, which may occur through either the authoring tool (automatically or manually) or the control itself (manually through its own property pages).
<LI>How to save each path property in the control's persistent data.
<LI>How to cooperatively retrieve data referred to with a path property ,which might include container participation.
<LI>How to communicate a control's "readiness" to a container at run time so that the container can manage dependencies on the control's internal state.
</UL>

<P>Linking capabilities using path properties are equally usable in both the Persistent Embedding and Persistent Linking cases as described in an earlier section. For clarity, the combinations of Persistent Embedding and Persistent Linking with Data Path Properties are shown in the following illustrations.

<P>

<P><IMG SRC="../../art/comobj5.gif" WIDTH="266" HEIGHT="232" ALT="Figure 5: A control that uses data paths is embedded in a document, but each path references an external source of data" >

<P>

<P>

<P><IMG SRC="../../art/comobj6.gif" WIDTH="371" HEIGHT="232" ALT="Figure 6: A control that uses data paths is linked to a document and itself contains addition paths that reference external sources of data" >

<P>

<P>With data paths, a control can allow its persistent data to be distributed around a file system or the Internet. For example, a sophisticated motion-picture control may separately reference its AVI data, its audio data, and a lengthy text transcript of the dialogue. The control could then have <B>MoviePath</B>, <B>AudioPath</B>, and <B>TranscriptPath</B> properties. In a similar manner, a picture control might store three separate detail images and use the properties <B>LowDetailImagePath</B>, <B>MediumDetailImagePath</B>, and <B>HighDetailImagePath</B> (and maybe the motion picture control uses these three as well to provide progressive rendering of a static image&#151;anything is possible). This document places no restrictions on the exact data formats stored in locations given to path properties&#151;the control ultimately determines the formats it can employ.

<P>The following sections provide information about data path properties, starting with how a control exposes its path properties and the data formats associated with those paths. This is followed with a discussion of how path values are assigned, how a control saves a path property, and how a control uses a property to retrieve data asynchronously. A later section
describes how the control communicates its "readiness" to a container and how the container handles different readiness states.


<h2><A NAME="Exposing_Data_Path_P">Exposing Data Path Properties and Corresponding Data Format</A></h2>

<P>The following characteristics apply to publicly exposed path properties and controls that provide them:

<OL>
<LI>A path property can be a property of any type, most commonly a
<object id="hhal_7" type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Item1" value="">
<PARAM name="Item2" value=_win32_Further_Reading>
</object><A HREF=JavaScript:hhal_7.Click()>BSTR</A> (allowing easy manipulation through Microsoft&#174;Visual Basic&#174; code such as <B>MyObj.TranscriptPath</B>), but other types are allowed, such as
<object id="hhal_8" type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Item1" value="">
<PARAM name="Item2" value=_win32_Further_Reading>
</object><A HREF=JavaScript:hhal_8.Click()>IUnknown</A> or <A HREF="../idispatchex/references/IDispatch.htm#IDispatch">IDispatch</A>. Choice of the exact property type is the decision of the control developer.
<LI>All path properties regardless of type are tagged with a special custom attribute GUID that identifies the property as being a "path." This simplifies the process for an authoring tool to find path properties with a quick check through the control's type information. This standard GUID is defined as <B>GUID_PathProperty</B> with the value of <B>{0002DE80-0000-0000-C000-000000000046}</B>.
<LI>The custom attribute described in 2 can express one or more MIME type values to describe the actual data type that this path should reference. The syntax is the same as that for the <B>Accept:</B> fields of HTTP headers (see below, and see the HTTP specification for complete information). 
<LI>A path property can be assigned any <B>dispID</B> that the control developer sees fit.
<LI>A control marks each path property with the <B>[bindable]</B> attribute. This is because a container may allow path assignment through its own user interface and may be displaying path properties in its own property browser. <B>[bindable]</B> is, thus, necessary to keep the property browser synchronized with the control's state. With this attribute, the control must call
<object id="hhal_9" type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Item1" value="">
<PARAM name="Item2" value=_win32_Further_Reading>
</object><A HREF=JavaScript:hhal_9.Click()>IPropertyNotifySink</A> methods if the container has connected an implementation of that sink interface through the control's connection points. Controls can choose to mark path properties as <B>[requestedit]</B> and <B>[displaybind]</B>, if desired, but these are not requirements.
<LI>The control's <B>coclass</B> entry in its type information is tagged with another special custom attribute GUID that specifies "this control has one or more path properties." This standard GUID is defined as <B>GUID_HasPathProperties</B> with the value <B>{0002DE81-0000-0000-C000-000000000046}</B>. The value of this attribute is the number of path properties that exist in the control. This attribute thus allows authoring tools to quickly and efficiently determine if a control has path properties at all and quickly describes how many path properties exist.
</OL>

<P>The HTTP <B>Accept:</B> syntax is summarized as follows:
<PRE>
&#009;&lt;field&gt;  =    Accept: &lt;entry&gt; *[ , &lt;entry&gt;
&#009;&lt;entry&gt;  =    &lt;content type&gt; *[ ; &lt;param&gt; ]
&#009;&lt;param&gt;  =    &lt;attr&gt; = &lt;float&gt;
&#009;&lt;attr&gt;   =    q / mxs / mxb
&#009;&lt;float&gt;  =    &lt;ANSI-C floating point text representation&gt;
</PRE>

<P>as in:

<PRE>
Accept: text/plain, text/html, image/*
Accept: text/x-dvi; q=.8; mxb=100000; mxt=5.0, text/x-c
</PRE>
<P>A "custom attribute" as now supported in type information is defined using the keyword <B>custom</B> with a (GUID, value) pair as arguments for the attribute. This is shown in the following example:
<PRE>
#define GUID_PathProperty 0002DE80-0000-0000-C000-000000000046

[id(1), bindable, displaybind, propget, custom(GUID_PathProperty
    , "text/plain; q=0.5, text/html, text/*")]
    BSTR TranscriptPath(void);
</PRE>

<P>This defines the
<object id="hhal_10" type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Item1" value="">
<PARAM name="Item2" value=_win32_Further_Reading>
</object><A HREF=JavaScript:hhal_10.Click()>BSTR</A> property <B>TranscriptPath</B> as a path property with the types of plain text, HTML text, and other text (using HTTP <B>Accept:</B> syntax). This information is retrieved from the type information through the new type library interface <B>ITypeInfo2</B> as described in the next section.

<P>As an example of defining path properties in this way, consider a control that has an AVI <B>MoviePath</B> property, a RIFF <B>AudioPath</B> property, and an ANSI text <B>TranscriptPath</B> property that would include them in its type library this way (in ODL syntax; exact MIME types have been omitted because the code below is demonstrating the definition of multiple properties):
<PRE>
#define GUID_PathProperty      0002DE80-0000-0000-C000-000000000046
#define GUID_HasPathProperties 0002DE81-0000-0000-C000-000000000046


[&lt;attributes&gt;]
library
    {
    importlib &lt;path to header that includes GUID_PropertyPath and GUID_HasPathProperties&gt;

    [&lt;attributes&gt;]
    interface IMyObjectProperties
        {
        //Other stuff here...

        [id(1), bindable, displaybind, propget, custom(GUID_PathProperty, "...")]
            BSTR MoviePath(void);

        [id(1), bindable, displaybind, propput, custom(GUID_PathProperty, "...")]
            void MoviePath([in] BSTR pathVideo);

        [id(2), bindable, propget, custom(GUID_PathProperty, "...")]
            BSTR AudioPath(void);

        [id(2), bindable, propput, custom(GUID_PathProperty, "...")]
            void AudioPath([in] BSTR pathAudio);

        [id(3), bindable, propget, custom(GUID_PathProperty, "...")]
            BSTR TranscriptPath(void);

        [id(3), bindable, propput, custom(GUID_PathProperty, "...")]
            void TranscriptPath([in] BSTR pathText);

        //Other stuff here...
        }


    [&lt;other attributes&gt;, custom(GUID_HasPathProperties, "3")]
    coclass MyObject
        {
        interface IMyObjectProperties;
        ...
        }

    }
</PRE>
<h3><A NAME="Author_Time_Discover">Author-Time Discovery of Path Properties</A></h3>

<P>Authoring tools and other containers will want to know exactly which control properties are, in fact, data path properties as well as the type of data that should be referenced through each property. This allows the authoring tool to effectively enumerate data paths and retrieve their current values, which is useful when the authoring tool needs to update any such properties to perform link management.

<P>First, to determine if any particular control has any path properties, the authoring tool should perform the following actions:

<OL>
<LI>Retrieve the control's type information for its <B>coclass</B> either through <B>IProvideClassInfo::GetClassInfo</B> or from the type library directly. These methods result in an
<object id="hhal_11" type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Item1" value="">
<PARAM name="Item2" value=_win32_Further_Reading>
</object><A HREF=JavaScript:hhal_11.Click()>ITypeInfo</A> interface for that part of the type library.
<LI>Call <B>ITypeInfo::QueryInterface(IID_ITypeInfo2</B>, <B>&amp;pITypeInfo2)</B> to retrieve the interface necessary to read custom attributes. If this interface does not exist, the container has to assume that no path properties exist.
<LI>Call <B>pITypeInfo2-&gt;GetCustData(GUID_HasPathProperties, &amp;va)</B> to retrieve the value of the custom attribute into the
<object id="hhal_12" type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Item1" value="">
<PARAM name="Item2" value=_win32_Further_Reading>
</object><A HREF=JavaScript:hhal_12.Click()>VARIANT</A> in <B>va</B>. If this function fails, or if the value in <B>va</B> is empty or zero, the control has no path properties.
</OL>

<P>Having this knowledge in hand, the authoring tool can then enumerate the properties in any of the control's incoming interfaces and check if those properties are data paths using the following procedure. These steps assume that <B>pTI2</B> is the <B>ITypeinfo2</B> pointer to one of the control's <B>interface</B> or <B>dispinterface</B> entries (available through the
<object id="hhal_13" type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Item1" value="">
<PARAM name="Item2" value=_win32_Further_Reading>
</object><A HREF=JavaScript:hhal_13.Click()>ITypeInfo</A> of the control's <B>coclass</B>):

<OL>
<LI>Get the count of the functions in the interface using <B>pTI2-&gt;GetTypeAttr</B> which returns a TYPEATTR whose <B>cFuncs</B> field has the number of function. Call <B>pTI2-&gt;ReleaseTypeAttr</B> when finished.
<LI>Iterate in a for loop where the index counter (<object id="hhal_14" type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Item1" value="">
<PARAM name="Item2" value=_win32_index>
</object><A HREF=JavaScript:hhal_14.Click()>index</A>) begins at zero and counts to <B>cFuncs-1</B> (<B>cFuncs</B> is from step 1) through the functions.
<LI>For each function, call <B>pTI2-&gt;GetFuncCustData(index</B>, <B>GUID_PathProperty</B>, &amp;va) to attempt to read the custom path property attribute's value into the <B>VARIANT va</B>.
<LI>If the <B>GetFuncCustData</B> call fails, or if the contents of <B>va</B> are empty, this property is not a data path. On success, the property is a data path and the value in <B>va</B> will be the description of the MIME type.
<LI>To determine the dispID of the property, call <B>pTI2-&gt;GetFuncDesc</B> and look in the <B>FUNCDESC</B> structure for the <I>memid</I> field, which is the dispID. Be sure to call <B>pTI2-&gt;ReleaseFuncDesc</B> when done with the <B>FUNCDESC</B> structure.
<LI>For optimization purposes, one can count the number of path properties found so far and exit the loop early if that number matches the value that was read from the <B>GUID_HasPathProperties</B> in the steps used to determine if the control had any paths.
<LI>Once the loop is complete, the authoring tool will have a list of dispIDs (which may have some duplicates) for all the control's data path properties. The authoring tool can use <B>pTI2-&gt;GetNames</B> with these dispIDs to retrieve text names for those properties.
</OL>

<P>What then does a tool do with such knowledge of paths and their data types? There are three general scenarios:

<OL>
<LI>If the authoring tool is interactive, it might be able to display the data browsing UI based on the data format associated with any given path property. That is, if the tool knows that a path property uses the MIME type given in the value of the <B>GUID_PathProperty</B> attribute and that tool has a UI that can browse for that type, the tool can enable a "..." button in its property browser UI that invokes a File/Open type of dialog box when pressed. The user then selects a file and the name of that data file is assigned to the path property.
<LI>If the authoring tool is automatic, it uses other available information (for example, a data repository) to determine the source of any particular piece of data. Knowing the format that the control needs for a data path allows such a tool to find some appropriate data, create a path name for it, and assign that name to the control.
<LI>When the authoring tool publishes a document to an Internet site, it will want to check for any dependencies on outside data&#151;that is, it will want to check for any control properties that reference data outside the document. The authoring tool can then check whether that path will be valid at run time and if not, it can choose to relocate the data to an accessible location and assign a new path to the control before saving that control. This is necessary, for example, when a control references a file on the local file system when the document is being placed on an Internet site.
</OL>

<P>Of course, the sophistication of the authoring tool is almost limitless. With the tagging and MIME-typing of data path properties, this document guarantees that any such tool can always determine the data format associated with a path. It's then a matter of whether the tool recognizes that GUID.


<h2><A NAME="Assigning_Path_Prope">Assigning Path Properties</A></h2>

<P>The values of path properties&#151;the strings that identify storage locations&#151;are assumed to be assigned only at author-time. In this case there are two possibilities:

<OL>
<LI>The authoring tool obtains the name from the user or creates it automatically, assigning it to the control through a "set property" operation (through a dispinterface or dual interface depending on the nature of the control). Note that if a transfer is already underway for this property, the control must abort the transfer as described below.
<LI>The control obtains the name itself from its own property page UI; in that case it makes the change unilaterally. Any path properties marked with <B>[requestedit]</B> means the control is required to call any connected
<object id="hhal_15" type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Item1" value="">
<PARAM name="Item2" value=_win32_Further_Reading>
</object><A HREF=JavaScript:hhal_15.Click()>IPropertyNotifySink</A> interface's <B>OnRequestEdit</B> function to decide whether the change is actually allowed. If <B>OnRequestEdit</B> returns <B>S_FALSE</B>, the control must not change its path in this way (the authoring tool is essentially saying that the document or Internet site state is read-only as far as document/page contents are concerned).
</OL>

<P>In both cases, a change in the value of any path property will generate a call to any connected
<object id="hhal_16" type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Item1" value="">
<PARAM name="Item2" value=_win32_Further_Reading>
</object><A HREF=JavaScript:hhal_16.Click()>IPropertyNotifySink</A> interface's <B>OnChanged</B> member, because path properties are marked with <B>[bindable]</B>. In both cases, an authoring tool that displays its own property browsing UI would update itself to reflect the current state of the control. This also gives the authoring tool the chance to modify the path when the user changes it through the control's property pages directly. When the user makes the change, the control will notify the authoring tool through <B>OnChanged</B>. The authoring tool then reads the new value of the path property, modifies it as necessary, and sends the modified value back to the control. Therefore, in both the first and second cases above, the authoring tool has the final say in the exact value assigned to any path property.

<P>The most preferable case is where the value is simply a container-relative name. Relative file names and URLs are identical in form: "../pictures/tree.bmp" serves equally well in both the local file system and Internet environments. Relative item names, like "!Picture 6", identifies the path as pointing to some other part of the same container document. In URL cases, the name may be absolute, which indicates that there's no relative path between the container document and the location described in the data path.

<P>In any case, a control must always obtain some moniker from a data path name to bind to the storage so referenced. Because the name may only be relative, the container is always given the chance to create the actual moniker itself. The details of this are covered in the next section.

<P>Use of relative names allows an authoring tool to move the root document&#151;and possibly an entire site&#151;around, without invalidating any external links stored in data paths. For example, consider the author-time case where the document being created is stored in "c:\pages\mypage.doc" and in that document is a bitmap control with an <B>ImagePath</B> property. The authoring tool assigns the name "frog.bmp" to this property. When the control wishes to access the bitmap named in the <B>ImagePath</B> property, it passes "frog.bmp" to the authoring tool and asks for a moniker in return. The authoring tool sees two file names and can combine them into one "c:\pages\frog.bmp" name. The authoring tool then returns this name in a moniker so that the control can bind that moniker and retrieve the data.

<P>Now when the author saves the document to an Internet site at Publish time, the location of the document changes to something like "http://www.bogons.com/bogazoid/mypage.htm". In addition, the authoring tool copies "frog.bmp" to that same site where it becomes "http://www.bogons.com/bogazoid/frog.bmp". At run time, the control reloads the path property name "frog.bmp" and asks the container to make it a moniker. The container simply combines the document URL with the relative name "frog.bmp" to generate the exact URL for the bitmap.

<P>In some cases, the control may have obtained an absolute filename (or URL) from its own property pages at author-time. So, for instance, the user types in "c:\pages\frog.bmp" instead of just "frog.bmp." Initially, the control will internally save the absolute string, but because it sends an <B>OnChanged</B> notification (data path is <B>[bindable]</B>), the authoring tool retrieves this new value and computes the relative path to that same file from the document's current location (using the file moniker's <B>RelativePathTo</B> member, for example). The relative path in this case will end up as just "frog.bmp", which the authoring tool simply assigns back to the control.

<P>In the case where the user gives a control an absolute URL, there's nothing the authoring tool can do at author-time when the document is stored on a local file system. At publish time, however, the authoring tool first determines the new URL of the document. It can then cycle through all known path properties of each control before it saves that control. If the authoring tool finds an absolute URL in a property, that tool can attempt to compute the relative path between the document's URL and the path's URL. Once it has computed this relative path, it can assign the relative name to the path property and proceed with saving the control.

<P>When the authoring tool supports relative path names that are not either file names or URLs, but are instead item names that identify a piece of storage in the document itself, such as "#Picture 6", the authoring tool must specify, in its own documentation, what prefix character marks the name as an item of some kind. This is a note to the container's moniker creation mechanism in <A HREF="reference/IBindHost_CreateMoniker.htm#IBindHost::CreateMoniker">IBindHost::CreateMoniker</A> as described in the next section.

<h3><A NAME="Storing_and_Comparin">Storing and Comparing Path Properties</A></h3>

<P>Controls should always ensure that they can produce a string for any path property. This is because all interfaces that deal with path properties (either <A HREF="../idispatchex/references/IDispatch.htm#IDispatch">IDispatch</A> for the property itself or <A HREF="reference/IBindHost.htm#IBindHost">IBindHost</A>, in a section below, for converting the string into a moniker) deal with paths as strings.

<P>However, controls should not compare two path properties as strings. Instead, the comparison should be carried out using two monikers created from those strings through <A HREF="reference/IBindHost_CreateMoniker.htm#IBindHost::CreateMoniker">IBindHost::CreateMoniker</A> (see below). With monikers, the comparison between <B>pmk1</B> and <B>pmk2</B> is the call <B>pmk1-&gt;IsEqual(pmk2)</B> or <B>pmk2-&gt;IsEqual(pmk1)</B>.


<h3><A NAME="Integrated_Author_To">Integrated Author Tool Browsing and Control Property Pages</A></h3>

<P>A sophisticated container or authoring tool will likely provide its own browsing UI for various types of data, typically the most common types of data that would be assigned to path properties (images, sound, and video). To maintain as much of a consistent user interface as possible, a container should make such browsing UI available to a control's property pages so that the property page can invoke that UI instead of showing its own, which would likely be inconsistent.

<P>This integration is achieved through a container-side interface called <B>IOleBuilderManager</B>. An exact specification for this interface is not, however, available at this time and will be provided at a later date. The basic idea, however, is that through this interface a control's property page can test for the availability of container-side browsing UI and invoke that UI if it is available. This allows the page to enable a "Browse..." button for a particular path property, invoking the container's UI when that button is pressed.


<h2><A NAME="Container_Supply_of_">Container Supply of Monikers Through IBindHost</A></h2>

<P>Working with data paths requires, of course, the ability of the control to access data referenced by its path properties. The key part of such data access is providing some means by which the control turns a data path name into a moniker that it can bind. Because the container/authoring tool is the one that generally knows the context that modifies any relative path name, the container, in this relationship, is responsible for generating an appropriate moniker when the control asks for one.

<P>This step happens through a container's (or authoring tool's) implementation of the interface <A HREF="reference/IBindHost.htm#IBindHost">IBindHost</A>, which is implemented as a service available through a container site's implementation of <A HREF="reference/IServiceProvider.htm#IServiceProvider">IServiceProvider</A>, and is the topic of the next section. The control accesses the bind host implementation by calling <B>QueryInterface(IID_IServiceProvider...)</B> on whatever site pointer it already has and calling <B>IServiceProvider::QueryService(SID_SBindHost)</B>. Use of the service provider means that the bind host is generally a separate object from the site; although as an implementation convenience, it could be implemented on the site directly.

<P>Of course, in order for a control to have a site through which it can access these services, the control must provide some means through which the container can pass its site pointer to the control in the first place. Many controls implement
<object id="hhal_17" type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Item1" value="">
<PARAM name="Item2" value=_win32_Further_Reading>
</object><A HREF=JavaScript:hhal_17.Click()>IOleObject</A> whose <B>SetClientSite</B> member accomplishes exactly this. However, not all controls need to implement <B>IOleObject</B>, so a section below describes a simple siting mechanism using <A HREF="reference/IObjectWithSite.htm#IObjectWithSite">IObjectWithSite</A> to achieve the same ends.

<P>This document requires that a control using data paths supports a siting mechanism. If the control doesn't support
<object id="hhal_18" type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Item1" value="">
<PARAM name="Item2" value=_win32_Further_Reading>
</object><A HREF=JavaScript:hhal_18.Click()>IOleObject</A>, it must support <A HREF="reference/IObjectWithSite.htm#IObjectWithSite">IObjectWithSite</A>. A container that supports data paths must provide a site through one of these mechanisms and must generally implement <A HREF="reference/IBindHost.htm#IBindHost">IBindHost</A> and provide access to it through the site's <A HREF="reference/IServiceProvider.htm#IServiceProvider">IServiceProvider</A>. If a control that uses paths finds itself without a container site, it can still degenerate gracefully by calling
<object id="hhal_19" type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Item1" value="">
<PARAM name="Item2" value=_win32_MkParseDisplayNameEx>
</object><A HREF=JavaScript:hhal_19.Click()>MkParseDisplayNameEx</A> itself, as necessary.




<h3><A NAME="Overview_of_IBindHos">Overview of IBindHost</A></h3>

<P>The creation of a moniker from a potentially relative path name is what is considered a container-side "service" that a control accesses through <A HREF="reference/IBindHost_CreateMoniker.htm#IBindHost::CreateMoniker">IBindHost::CreateMoniker</A>. In addition, a control asks its container to download data through <A HREF="reference/IBindHost_MonikerBindToStorage.htm#IBindHost::MonikerBindToStorage">IBindHost::MonikerBindToStorage</A> as described in a later section.

<P>The <A HREF="reference/IBindHost.htm#IBindHost">IBindHost</A> interface is defined as follows:

<PRE>
interface IBindHost : IUnknown
    {
    HRESULT CreateMoniker([in] LPCOLESTR pszName, [in] IBindCtx *pBC
        , [out] IMoniker** ppmk, [in] DWORD dwReserved);

    HRESULT MonikerBindToStorage([in] IMoniker *pMk, [in] IBindCtx *pBC
        , [in] IBindStatusCallback *pBSC, [in] REFIID riid
        , [out, iid_is(riid)] void **ppvObj);

    HRESULT MonikerBindToObject([in] IMoniker *pMk, [in] IBindCtx *pBC
        , [in] IBindStatusCallback *pBSC, [in] REFIID riid
        , [out, iid_is(riid)] void **ppvObj);
    }
</PRE>

<P>The <B>CreateMoniker</B> member takes a text string of some path&#151;which may be absolute or relative&#151;and returns a moniker that references the actual absolute location. That is, the container combines its known document location with the path supplied in <I>pszName</I> to create the resulting moniker. How the container does this depends on the document path and the type of name found in <I>pszName</I>, which is either something that the URL moniker can handle (including file names) or an item name referring to some portion of the container document itself.

<P>In the item name case, a container can specify a prefix character, like "#" or "&gt;", that it will use to differentiate an item name from some other kind of name. This fact should be known to users of the container at author-time so that those users can enter the correct names in whatever UI is used to assign path values. When the container detects its prefix character, it knows that it has to parse the name according to its own rules.

<P>In any other case, the container creates a moniker from the text string directly using
<object id="hhal_20" type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Item1" value="">
<PARAM name="Item2" value=_win32_MkParseDisplayNameEx>
</object><A HREF=JavaScript:hhal_20.Click()>MkParseDisplayNameEx</A> This handles the cases where URLs are given as well as display names of File Item monikers and other similar composites. If for some reason <A HREF="reference/IBindHost_CreateMoniker.htm#IBindHost::CreateMoniker">IBindHost::CreateMoniker</A> fails, the calling control can degenerate to calling <B>MkParseDisplayNameEx</B> itself, but this should only be used as a last resort.

<P>Either way, the container now has a moniker for the data path as well as a moniker naming its own document. To return a full moniker from <B>ParseDisplayName</B> it calls <I>pmkDocument-&gt;ComposeWith(pmkPath</I>, <I>kReturn</I>) where <I>pmkReturn</I> receives the moniker to return to the caller.

<P>This rule assumes that the document moniker class implements <B>ComposeWith</B> in an intelligent manner. If the document moniker is a File moniker, for example, and the path moniker is a File moniker, <B>ComposeWith</B> will return one File moniker with the combination. The same applies for any case where the path moniker is a URL and the document is either a File or a URL. It is even possible to mix a URL document moniker with a File moniker for the path, provided that the File moniker is not absolute (where the combination would make no sense).

<P>When the path moniker is some item or composite, the File or URL moniker <B>ComposeWith</B> implementations simply create another composite.

<P>The bottom line is that <A HREF="reference/IBindHost_CreateMoniker.htm#IBindHost::CreateMoniker">IBindHost::CreateMoniker</A> will create a precise moniker that is the combination of the document's own moniker (obtainable through <B>IOleClientSite::GetMoniker(OLEWHICHMK_CONTAINER)</B> and a moniker created from the path name. The control can use this moniker to bind, but this is not the moniker that the control should save. See below for more information on persistence.


<h3><A NAME="Generic_Siting_with_">Generic Siting with IObjectWithSite</A></h3>

<P>A control that does not need
<object id="hhal_21" type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Item1" value="">
<PARAM name="Item2" value=_win32_Further_Reading>
</object><A HREF=JavaScript:hhal_21.Click()>IOleObject</A>, but still requires access to its container site, specifically for the purposes of accessing container-side services, must instead implement <A HREF="reference/IObjectWithSite.htm#IObjectWithSite">IObjectWithSite</A>:

<PRE>
interface IObjectWithSite : IUnknown
    {
    HRESULT SetSite([in] IUnknown *pUnkSite);
    HRESULT GetSite([in] REFIID riid, [out, iid_is(riid)] void **ppvSite);
    }
</PRE>

<P>In the absence of
<object id="hhal_22" type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Item1" value="">
<PARAM name="Item2" value=_win32_Further_Reading>
</object><A HREF=JavaScript:hhal_22.Click()>IOleObject</A> a container can attempt to provide the
<object id="hhal_23" type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Item1" value="">
<PARAM name="Item2" value=_win32_Further_Reading>
</object><A HREF=JavaScript:hhal_23.Click()>IUnknown</A> pointer to its site through <A HREF="reference/IObjectWithSite_SetSite.htm#IObjectWithSite::SetSite">IObjectWithSite::SetSite</A>. <A HREF="reference/IObjectWithSite_GetSite.htm#IObjectWithSite::GetSite">IObjectWithSite::GetSite</A> is included as a hooking mechanism, which allows a third party to intercept calls from the control to the site.

<P>When a control needs to create a moniker from a data path, it obtains the bind host through the site's <A HREF="reference/IServiceProvider.htm#IServiceProvider">IServiceProvider</A> interface and proceeds from there.




<!-- CONTENTS_END -->
<!-- START PAGE FOOTER -->
<H6><HR size=1></H6>
<P><A ID=line HREF="#pagetop"><IMG src="../../art/arrowup1.gif" WIDTH="17" HEIGHT="16" ALIGN="MIDDLE" BORDER="0" ALT="Up">&nbsp;Top of Page</A>
<BR><A ID=line HREF="http://www.microsoft.com/misc/cpyright.htm" TARGET="_top">&#169; 1997 Microsoft Corporation. All rights reserved. Terms of Use.</A>
<!-- END PAGE FOOTER -->
</BLOCKQUOTE>
</BODY>
</HTML>
