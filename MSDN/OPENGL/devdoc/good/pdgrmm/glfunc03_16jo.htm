<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>glTexImage2D</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_ogl_glteximage2d"></a>glTexImage2D</h1>
<p>
The <b>glTexImage2D</b> function specifies a two-dimensional texture image.</p>
<pre><code><b>void glTexImage2D(
  GLenum</b><i> target</i><b>,        </b>
<b>  GLint</b><i> level</i><b>,          </b>
<b>  GLint</b><i> components</i><b>,     </b>
<b>  GLsizei</b><i> width</i><b>,        </b>
<b>  GLsizei</b><i> height</i><b>,       </b>
<b>  GLint</b><i> border</i><b>,         </b>
<b>  GLenum</b><i> format</i><b>,        </b>
<b>  GLenum</b><i> type</i><b>,          </b>
<b>  const GLvoid</b><i> *pixels  </i>
<b>);</b>
 </code></pre>
<h4>Parameters</h4>
<dl>
<dt>
<i>target</i></dt>
<dd>
The target texture. Must be GL_TEXTURE_2D. </dd>
<dt>
<i>level</i></dt>
<dd>
The level-of-detail number. Level 0 is the base image level. Level <i>n</i> is the <i>n</i>th mipmap reduction image. </dd>
<dt>
<i>components</i></dt>
<dd>
The number of color components in the texture. Must be 1, 2, 3, or 4. </dd>
<dt>
<i>width</i></dt>
<dd>
The width of the texture image. Must be 2^<i>n</i>&nbsp;+&nbsp;2(<i>border</i>) for some integer <i>n</i>. </dd>
<dt>
<i>height</i></dt>
<dd>
The height of the texture image. Must be 2^<i>m</i>&nbsp;+&nbsp;2(<i>border</i>) for some integer <i>m</i>. </dd>
<dt>
<i>border</i></dt>
<dd>
The width of the border. Must be either 0 or 1. </dd>
<dt>
<i>format</i></dt>
<dd>
The format of the pixel data. It can assume one of nine symbolic values:
<dl>
<dt>
GL_COLOR_INDEX</dt>
<dd>
Each element is a single value, a color index. It is converted to fixed point (with an unspecified number of 0 bits to the right of the binary point), shifted left or right depending on the value and sign of GL_INDEX_SHIFT, and added to GL_INDEX_OFFSET (see <a href="glfunc03_881e.htm"><b>glPixelTransfer</b></a>). The resulting index is converted to a set of color components using the GL_PIXEL_MAP_I_TO_R, GL_PIXEL_MAP_I_TO_G, GL_PIXEL_MAP_I_TO_B, and GL_PIXEL_MAP_I_TO_A tables, and clamped to the range [0,1]. </dd>
<dt>
GL_RED</dt>
<dd>
Each element is a single red component. It is converted to floating point and assembled into an RGBA element by attaching 0.0 for green and blue, and 1.0 for alpha. Each component is then multiplied by the signed scale factor GL_c_SCALE, added to the signed bias GL_c_BIAS, and clamped to the range [0,1] (see <b>glPixelTransfer</b>). </dd>
<dt>
GL_GREEN</dt>
<dd>
Each element is a single green component. It is converted to floating point and assembled into an RGBA element by attaching 0.0 for red and blue, and 1.0 for alpha. Each component is then multiplied by the signed scale factor GL_c_SCALE, added to the signed bias GL_c_BIAS, and clamped to the range [0,1] (see <a href="glfunc03_881e.htm"><b>glPixelTransfer</b></a>). </dd>
<dt>
GL_BLUE</dt>
<dd>
Each element is a single blue component. It is converted to floating point and assembled into an RGBA element by attaching 0.0 for red and green, and 1.0 for alpha. Each component is then multiplied by the signed scale factor GL_c_SCALE, added to the signed bias GL_c_BIAS, and clamped to the range [0,1] (see <b>glPixelTransfer</b>). </dd>
<dt>
GL_ALPHA</dt>
<dd>
Each element is a single red component. It is converted to floating point and assembled into an RGBA element by attaching 0.0 for red, green, and blue. Each component is then multiplied by the signed scale factor GL_c_SCALE, added to the signed bias GL_c_BIAS, and clamped to the range [0,1] (see <a href="glfunc03_881e.htm"><b>glPixelTransfer</b></a>). </dd>
<dt>
GL_RGB</dt>
<dd>
Each element is an RGB triple. It is converted to floating point and assembled into an RGBA element by attaching 1.0 for alpha. Each component is then multiplied by the signed scale factor GL_c_SCALE, added to the signed bias GL_c_BIAS, and clamped to the range [0,1] (see <b>glPixelTransfer</b>). </dd>
<dt>
GL_RGBA </dt>
<dd>
Each element is a complete RGBA element. It is converted to floating point. Each component is then multiplied by the signed scale factor GL_c_SCALE, added to the signed bias GL_c_BIAS, and clamped to the range [0,1] (see <a href="glfunc03_881e.htm"><b>glPixelTransfer</b></a>).</dd>
<dt>
GL_BGR_EXT </dt>
<dd>
Each pixel is a group of three components in this order: blue, green, red.
<p>
GL_BGR_EXT provides a format that matches the memory layout of Windows device-independent bitmaps (DIBs). Thus your applications can use the same data with Win32 function calls and OpenGL pixel function calls.
</dd>
<dt>
GL_BGRA_EXT </dt>
<dd>
Each pixel is a group of four components in this order: blue, green, red, alpha.
<p>
GL_BGRA_EXT provides a format that matches the memory layout of Windows device-independent bitmaps (DIBs). Thus your applications can use the same data with Win32 function calls and OpenGL pixel function calls.
</dd>
<dt>
GL_LUMINANCE </dt>
<dd>
Each element is a single luminance value. It is converted to floating point, and then assembled into an RGBA element by replicating the luminance value three times for red, green, and blue, and attaching 1.0 for alpha. Each component is then multiplied by the signed scale factor GL_c_SCALE, added to the signed bias GL_c_BIAS, and clamped to the range [0,1] (see <b>glPixelTransfer</b>). </dd>
<dt>
GL_LUMINANCE_ALPHA</dt>
<dd>
Each element is a luminance/alpha pair. It is converted to floating point, and then assembled into an RGBA element by replicating the luminance value three times for red, green, and blue. Each component is then multiplied by the signed scale factor GL_c_SCALE, added to the signed bias GL_c_BIAS, and clamped to the range [0,1] (see <a href="glfunc03_881e.htm"><b>glPixelTransfer</b></a>).</dd>
</dl>
</dd>
<dt>
<i>type </i></dt>
<dd>
The data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, and GL_FLOAT.</dd>
<dt>
<i>pixels</i></dt>
<dd>
A pointer to the image data in memory.
</dd>
</dl>
<h4>Remarks</h4>
<p>
The <b>glTexImage2D</b> function specifies a two-dimensional texture image. Texturing maps a portion of a specified <i>texture image</i> onto each graphical primitive for which texturing is enabled. Two-dimensional texturing is enabled and disabled using <a href="glfunc01_3l5x.htm"><b>glEnable</b></a> and <b>glDisable</b> with argument GL_TEXTURE_2D.</p>
<p>
Texture images are defined with <b>glTexImage2D</b>. The arguments describe the parameters of the texture image, such as height, width, width of the border, level-of-detail number (see <a href="glfunc03_9upe.htm"><b>glTexParameter</b></a>), and number of color components provided. The last three arguments describe the way the image is represented in memory. These arguments are identical to the pixel formats used for <a href="glfunc01_6lbn.htm"><b>glDrawPixels</b></a>.</p>
<p>
Data is read from <i>pixels</i> as a sequence of signed or unsigned bytes, shorts or longs, or single-precision floating-point values, depending on <i>type</i>. These values are grouped into sets of one, two, three, or four values, depending on <i>format</i>, to form elements. If <i>type</i> is GL_BITMAP, the data is considered as a string of unsigned bytes (and <i>format</i> must be GL_COLOR_INDEX). Each data byte is treated as eight 1-bit elements, with bit ordering determined by GL_UNPACK_LSB_FIRST (see <a href="glfunc03_7kdh.htm"><b>glPixelStore</b></a>). Please see <a href="glfunc01_6lbn.htm"><b>glDrawPixels</b></a> for a description of the acceptable values for the <i>type</i> parameter. </p>
<p>
A texture image can have up to four components per texture element, depending on <i>components</i>. A one-component texture image uses only the red component of the RGBA color extracted from <i>pixels</i>. A two-component image uses the R and A values. A three-component image uses the R, G, and B values. A four-component image uses all of the RGBA components.</p>
<p>
Texturing has no effect in color-index mode.</p>
<p>
The texture image can be represented by the same data formats as the pixels in a <b>glDrawPixels</b> command, except that GL_STENCIL_INDEX and GL_DEPTH_COMPONENT cannot be used. The <a href="glfunc03_7kdh.htm"><b>glPixelStore</b></a> and <a href="glfunc03_881e.htm"><b>glPixelTransfer</b></a> modes affect texture images in exactly the way they affect <b>glDrawPixels</b>.</p>
<p>
A texture image with zero height or width indicates the null texture. If the null texture is specified for level-of-detail 0, it is as if texturing were disabled.</p>
<p>
The following functions retrieve information related to <b>glTexImage2D</b>:</p>
<p class=indent1>
<a href="glfunc02_3d45.htm"><b>glGetTexImage</b></a> </p>
<p class=indent1>
<a href="glfunc03_7pgk.htm"><b>glIsEnabled</b></a> with argument GL_TEXTURE_2D</p>
<h4>Error Codes</h4>
<p>
The following are the error codes generated and their conditions.</p>
<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=43%>Error Code</th>
<th align=left width=57%>Condition</th>
</tr>
<tr valign=top>
<td width=43%>GL_INVALID_ENUM </td>
<td width=57%><i>target</i> was not GL_TEXTURE_2D.</td>
</tr>
<tr valign=top>
<td width=43%>GL_INVALID_ENUM </td>
<td width=57%><i>format</i> was not an accepted <i>format</i> constant. Format constants other than GL_STENCIL_INDEX and GL_DEPTH_COMPONENT were accepted.</td>
</tr>
<tr valign=top>
<td width=43%>GL_INVALID_ENUM </td>
<td width=57%><i>type</i> was not a <i>type</i> constant.</td>
</tr>
<tr valign=top>
<td width=43%>GL_INVALID_ENUM </td>
<td width=57%><i>type</i> was GL_BITMAP and <i>format</i> was not GL_COLOR_INDEX.</td>
</tr>
<tr valign=top>
<td width=43%>GL_INVALID_VALUE </td>
<td width=57%><i>level</i> was less than zero or greater than log (2)  max, where <i>max</i> was the returned value of GL_MAX_TEXTURE_SIZE.</td>
</tr>
<tr valign=top>
<td width=43%>GL_INVALID_VALUE </td>
<td width=57%><i>components</i> was not 1, 2, 3, or 4.</td>
</tr>
<tr valign=top>
<td width=43%>GL_INVALID_VALUE </td>
<td width=57%><i>width</i> or <i>height</i> was less than zero or greater than 2 + GL_MAX_TEXTURE_SIZE, or if either could not be represented as 2^<i>k</i> + 2(<i>border</i>) for some integer value of <i>k</i>.</td>
</tr>
<tr valign=top>
<td width=43%>GL_INVALID_VALUE </td>
<td width=57%><i>border</i> was not 0 or 1.</td>
</tr>
<tr valign=top>
<td width=43%>GL_INVALID_OPERATION </td>
<td width=57%><b>glTexImage2D</b> was called between a call to <b>glBegin</b> and the corresponding call to <b>glEnd</b>.</td>
</tr>
</table><br>
<h4>QuickInfo</h4>
<p>
&nbsp;&nbsp;<b>Windows NT:</b>  Use version 3.5 and later.<br>
&nbsp;&nbsp;<b>Windows:</b>  Use Windows 95 and later.<br>
&nbsp;&nbsp;<b>Windows CE:</b>  Unsupported.<br>
&nbsp;&nbsp;<b>Header:</b> Declared in gl.h.<br>
&nbsp;&nbsp;<b>Import Library:</b> Link with opengl32.lib.</p>
<h4>See Also</h4>
<p>
<a href="glfunc01_9u3y.htm"><b>glBegin</b></a>, <a href="glfunc01_6lbn.htm"><b>glDrawPixels</b></a>, <a href="glfunc01_9u3y.htm"><b>glEnd</b></a>, <a href="glfunc02_5rmv.htm"><b>glFog</b></a>, <a href="glfunc03_7pgk.htm"><b>glIsEnabled</b></a>, <a href="glfunc03_7kdh.htm"><b>glPixelStore</b></a>, <a href="glfunc03_881e.htm"><b>glPixelTransfer</b></a>, <a href="glfunc03_6xyu.htm"><b>glTexEnv</b></a>, <a href="glfunc03_73u6.htm"><b>glTexGen</b></a>, <a href="glfunc03_16hw.htm"><b>glTexImage1D</b></a>, <a href="glfunc03_9upe.htm"><b>glTexParameter</b></a> </p>
<p>&nbsp;</p></body>
</HTML>
