<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>IRIS GL and OpenGL Differences</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_ogl_iris_gl_and_opengl_differences"></a>IRIS GL and OpenGL Differences</h1>
<p>
This appendix lists the differences between OpenGL and IRIS GL. A term for each difference is given, followed by a description.
<dl>
<dt>
accumulation wrapping</dt>
<dd>
The OpenGL accumulation buffer operation is not defined when component values exceed 1.0 or drop below  –1.0.</dd>
<dt>
antialiased lines </dt>
<dd>
OpenGL stipples antialiased lines. IRIS GL does not.</dd>
<dt>
arc </dt>
<dd>
OpenGL supports arcs in its utility library. </dd>
<dt>
attribute lists </dt>
<dd>
The attributes pushed by IRIS GL <b>pushattributes</b> differ from any of the attribute sets pushed by OpenGL <a href="glfunc03_68iq.htm"><b>glPushAttrib</b></a>. Because all OpenGL states can be read back, however, you can implement any desired push/pop semantics using OpenGL.</dd>
<dt>
automatic texture scaling</dt>
<dd>
The OpenGL texture interface does not support automatic scaling of images to power-of-two dimensions. However, the GLU supports image scaling.</dd>
<dt>
bbox </dt>
<dd>
OpenGL doesn't support conditional execution of display lists. </dd>
<dt>
callfunc </dt>
<dd>
OpenGL doesn't support callback from display lists. Note that IRIS GL doesn't support this functionality either, when client and server are on different platforms.</dd>
<dt>
circle </dt>
<dd>
OpenGL supports circles with the GLU. In OpenGL both circles and arcs (disks and partial disks) can have holes. Also, you can change subdivision of the primitives in OpenGL, and the primitives' surface normals are available for lighting.</dd>
<dt>
clear options</dt>
<dd>
OpenGL actually clears buffers. It doesn't apply currently specified pixel operations, such as blending and logicop, regardless of their modes. To clear using such features, you must render a window-size polygon.</dd>
<dt>
closed lines </dt>
<dd>
OpenGL renders all single-width aliased lines such that abutting lines share no pixels. This means that the "last" pixel of an independent line is not drawn.</dd>
<dt>
color/normal flag </dt>
<dd>
OpenGL lighting is explicitly enabled or disabled. When enabled, it is effective regardless of the order in which colors and normals are specified.
<p>
You cannot enable or disable lighting between OpenGL <a href="glfunc01_9u3y.htm"><b>glBegin</b></a> and <a href="glfunc01_9u3y.htm"><b>glEnd</b></a> commands. To disable lighting between <b>glBegin</b> and <b>glEnd</b>, specify zero ambient, diffuse, and specular material reflectance, and then set the material emission to the desired color.
</dd>
<dt>
concave polygons</dt>
<dd>
The core OpenGL API doesn't handle concave polygons, but the GLU supports decomposing concave, non-self-intersecting contours into triangles. These triangles can either be drawn immediately or returned.</dd>
<dt>
current computed color </dt>
<dd>
OpenGL has no equivalent to a current computed color. If you're using OpenGL as a lighting engine, you can use feedback to obtain colors generated by lighting calculations. </dd>
<dt>
current graphics position </dt>
<dd>
OpenGL doesn't maintain a current graphics position. IRIS GL commands that depend on current graphics position, such as relative lines and polygons, are not included in OpenGL. </dd>
<dt>
curves </dt>
<dd>
OpenGL does not support IRIS GL curves. Use of NURBS curves is recommended.</dd>
<dt>
defs/binds </dt>
<dd>
OpenGL doesn't have the concept of material, light, or texture objects; only of material, light, and texture properties. You can use display lists to create their own objects, however. </dd>
<dt>
depthcue </dt>
<dd>
OpenGL provides no direct support for depth cueing, but its fog support is a more general capability that you can easily use to emulate the IRIS GL <b>depthcue</b> function.</dd>
<dt>
display list editing</dt>
<dd>
OpenGL display lists can't be edited, only created and destroyed. Because you specify display list names, however, you can redefine individual display lists in a hierarchy.
<p>
OpenGL display lists are designed for data caching, not for database management. They are guaranteed to be stored on the server in client/server environments, so they are not limited by network bandwidth during execution.

<p>
OpenGL display lists can be called between <a href="glfunc01_9u3y.htm"><b>glBegin</b></a> and <a href="glfunc01_9u3y.htm"><b>glEnd</b></a> commands, so the display list hierarchy can be made fine enough that it can, in effect, be edited.
</dd>
<dt>
error checking</dt>
<dd>
OpenGL checks for errors more carefully than IRIS GL. For example, all OpenGL functions that are not accepted between <b>glBegin</b> and <b>glEnd</b> are detected as errors, and have no other effect. </dd>
<dt>
error return values</dt>
<dd>
When an OpenGL command that returns a value detects an error, it always returns zero. OpenGL commands that return data through passed pointers make no change to the array contents if an error is detected.</dd>
<dt>
error side effects</dt>
<dd>
When an OpenGL command results in an error, its only side effect is to update the error flag to the appropriate value. No other state changes are made. (An exception is the OUT_OF_MEMORY error, which is fatal.)</dd>
<dt>
feedback </dt>
<dd>
Feedback is standardized in OpenGL so it doesn't change from machine to machine.</dd>
<dt>
fonts and strings</dt>
<dd>
OpenGL requires character glyphs to be manipulated as individual display lists. It provides a display list calling function that accepts a list of display list names, each name represented as 1, 2, or 4 bytes. The <a href="glfunc01_8bub.htm"><b>glCallLists</b></a> function adds a separately specified offset to each display list name before the call, allowing lists of display list names to be treated as strings. 
<p>
This mechanism provides all the functionality of IRIS GL fonts, and considerably more. For example, characters comprised of triangles can be easily manipulated. 
</dd>
<dt>
frontbuffer</dt>
<dd>
IRIS GL has complex rules for rendering to the front buffer in single buffer mode. OpenGL handles rendering to the front buffer in a straightforward way.</dd>
<dt>
hollow polygons</dt>
<dd>
You can use the OpenGL stencil capacity to render hollow polygons. OpenGL doesn't support other means for creating hollow polygons.</dd>
<dt>
index clamping</dt>
<dd>
Where possible, OpenGL treats color and stencil indexes as bit fields rather than numbers. Thus indexes are masked, rather than clamped, to the supported range of the framebuffer.</dd>
<dt>
integer colors</dt>
<dd>
Signed integer color components (red, green, blue, or alpha) are mapped linearly to floating points such that the most negative integer maps to –1.0 and the most positive integer maps to 1.0. This mapping occurs when you specify the color, before OpenGL replaces the current color.
<p>
Unsigned integer color components are mapped linearly to floating points such that 0 maps to 0.0 and the largest integer maps to 1.0. This mapping occurs when you specify the color, before OpenGL replaces the current color.
</dd>
<dt>
integer normals</dt>
<dd>
Integer normal components are mapped just like signed color components. The most negative integer maps to –1.0, and the most positive integer maps to 1.0. pixel fragments.
<p>
Pixels drawn by <a href="glfunc01_6lbn.htm"><b>glDrawPixels</b></a> or <a href="glfunc01_36ur.htm"><b>glCopyPixels</b></a> are always rasterized and converted to fragments. The resulting fragments are textured, fogged, depth buffered, blended, and so on, just as if they were generated from geometric points. Fragment data that isn't provided by the source pixels is augmented from the current raster position. For example, RGBA pixels take the raster position Z and texture coordinates. Depth pixels take the raster position color and texture coordinates.
</dd>
<dt>
invariance</dt>
<dd>
OpenGL guarantees certain consistency that IRIS GL doesn't. For example, OpenGL guarantees that identical code sequences sent to the same system, differing only in the specified blending function, will generate the same pixel fragments. (The fragments differ, however, if blending is enabled and then disabled.)</dd>
<dt>
lighting equation </dt>
<dd>
The OpenGL lighting equation differs slightly from the IRIS GL equation. OpenGL supports separate attenuation for each light source, rather than a single attenuation for all the light sources like IRIS GL. OpenGL adjusts the equation so that ambient, diffuse, and specular lighting contributions are all attenuated. Also, OpenGL allows you to specify separate colors for the ambient, diffuse, and specular intensities of light sources, as well as for the ambient, diffuse, and specular reflectance of materials. All OpenGL light and material colors include alpha.
<p>
Setting the specular exponent to zero does not defeat specular lighting in OpenGL.
</dd>
<dt>
mapw </dt>
<dd>
OpenGL utilities support mapping between object and window coordinates.</dd>
<dt>
matrix mode</dt>
<dd>
Where the IRIS GL <b>ortho</b>, <b>ortho2</b>, <b>perspective</b>, and <b>window</b> functions operate on a particular matrix, all OpenGL matrix operations work on the current matrix. All OpenGL matrix operations except <a href="glfunc03_6h2x.htm"><b>glLoadIdentity</b></a> and <a href="glfunc03_3260.htm"><b>glLoadMatrix</b></a> multiply the current matrix rather than replacing it (as do <b>ortho</b>, <b>ortho2</b>, <b>perspective</b>, and <b>window</b> in the IRIS GL).</dd>
<dt>
mipmaps, automatic generation</dt>
<dd>
The OpenGL texture interface does not support automatic generation of mipmap images. However, the GLU supports the automatic generation of mipmap images for both 1-D and 2-D textures.</dd>
<dt>
move/draw/pmove/pdraw/pclos </dt>
<dd>
OpenGL supports only Begin/End style graphics, because it does not maintain a current graphics position. The scalar parameter specification of the old move/draw commands is accepted by OpenGL for all vertex related commands, however.</dd>
<dt>
mprojection mode</dt>
<dd>
IRIS GL doesn't transform geometry by the modelview matrix while in projection matrix mode. OpenGL always transforms by both the modelview and the projection matrix, regardless of matrix mode. </dd>
<dt>
multi-buffer drawing</dt>
<dd>
OpenGL renders to each color buffer individually, rather than computing a single new color value based on the contents of one color buffer and writing it to all the enabled color buffers, as IRIS GL does.</dd>
<dt>
NURBS </dt>
<dd>
OpenGL supports NURBS with a combination of core capability (evaluators) and GLU support. All IRIS GL NURBS capabilities are supported.</dd>
<dt>
old polygon mode</dt>
<dd>
Aliased OpenGL polygons are always point-sampled. IRIS GL's polygon compatibility mode, where pixels outside the polygon perimeter are included in its rasterization, is not supported. If your code uses this polygon mode, it's probably for rectangles. Old polygon mode rectangles appear one pixel wider and higher. </dd>
<dt>
packed color formats </dt>
<dd>
OpenGL accepts colors as 8-bit components, but these components are treated as an array of bytes rather than as bytes packed into larger words. By encouraging array indexing rather than shifting, OpenGL promotes endian-invariant programming.
<p>
Just as IRIS GL accepts packed colors both for geometric and pixel rendering, OpenGL accepts arrays of color components for geometric and pixel rendering.
</dd>
<dt>
patches </dt>
<dd>
OpenGL doesn't support IRIS GL patches.</dd>
<dt>
per-bit color writemask </dt>
<dd>
OpenGL writemasks for color components enable or disable changes to the entire component (red, green, blue, or alpha), not to individual bits of components. Note that per-bit writemasks are supported for both color indexes and stencil indexes, however.</dd>
<dt>
per-bit depth writemask </dt>
<dd>
OpenGL writemasks for depth components enable or disable changes to the entire component, not to individual bits of the depth component.</dd>
<dt>
pick </dt>
<dd>
The OpenGL Utility library includes support for generating a pick matrix.</dd>
<dt>
pixel coordinates </dt>
<dd>
In both OpenGL and IRIS GL, the origin of a window's coordinate system is at its lower left corner. OpenGL places the origin at the lower left corner of this pixel, however, while IRIS GL places it at the center of the lower left pixel.</dd>
<dt>
pixel zoom</dt>
<dd>
OpenGL negative zoom factors reflect about the current graphics position. IRIS GL doesn't define the operation of negative zoom factors, and instead provides RIGHT_TO_LEFT and TOP_TO_BOTTOM reflection pixmodes. These reflection modes reflect in place, rather than about the current raster position. OpenGL doesn't define reflection modes. </dd>
<dt>
pixmode</dt>
<dd>
OpenGL pixel transfers operate on individual color components, rather than on packed groups of four 8-bit components as does IRIS GL. While OpenGL provides substantially more pixel capability than IRIS GL, it doesn't support packed color constructs, and it doesn't enable color components to be reassigned (red to green, red to blue, and so on) during pixel copy operations.</dd>
<dt>
polf/poly </dt>
<dd>
OpenGL provides no direct support for vertex lists other than display lists. Functions like <b>polf</b> and <b>poly</b> can be implemented easily using the OpenGL API, however.</dd>
<dt>
polygon provoking vertex </dt>
<dd>
Flat shaded IRIS GL polygons take the color of the last vertex specified, while OpenGL polygons take the color of the first vertex specified.</dd>
<dt>
polygon stipple </dt>
<dd>
With IRIS GL the polygon stipple pattern is relative to the screen. With OpenGL it is relative to a window.</dd>
<dt>
polygon vertex count </dt>
<dd>
There is no limit to the number of vertices between <a href="glfunc01_9u3y.htm"><b>glBegin</b></a> and <a href="glfunc01_9u3y.htm"><b>glEnd</b></a> with OpenGL, even for <b>glBegin(</b>POLYGON<b>)</b>. With IRIS GL, polygons are limited to no more than 255 vertices.</dd>
<dt>
readdisplay </dt>
<dd>
Reading pixels outside window boundaries is properly a window system capability, rather than a rendering capability. Use Win32 functions to replace the IRIS GL <b>readdisplay</b> command.</dd>
<dt>
relative move/draw/pmove/pdraw/pclos </dt>
<dd>
OpenGL doesn't maintain a current graphics position, and therefore doesn't support relative vertex operations. </dd>
<dt>
RGBA logicop() </dt>
<dd>
OpenGL does not support logical operations on RGBA buffers. </dd>
<dt>
sbox() </dt>
<dd>
<b>sbox</b> is an IRIS GL rectangle primitive that is well-defined only if transformed without rotation. It is designed to be rendered faster than standard rectangles. While OpenGL doesn't support such a primitive, it can be tuned to render rectangles very quickly when the matrices and other modes are in states that simplify calculations. </dd>
<dt>
scalar arguments</dt>
<dd>
All OpenGL commands that are accepted between <a href="glfunc01_9u3y.htm"><b>glBegin</b></a> and <a href="glfunc01_9u3y.htm"><b>glEnd</b></a> have entry points that accept scalar arguments. For example, <a href="glfunc01_62b6.htm"><b>glColor4f</b></a><b>(</b>red, green, blue, alpha<b>)</b>.</dd>
<dt>
scissor</dt>
<dd>
The OpenGL <a href="glfunc03_4nxu.htm"><b>glScissor</b></a> function doesn't track the viewport. The IRIS GL <b>viewport</b> command automatically updates the <b>scrmask</b>.</dd>
<dt>
scrbox() </dt>
<dd>
OpenGL doesn't support bounding box computation.</dd>
<dt>
scrsubdivide() </dt>
<dd>
OpenGL doesn't support screen subdivision.</dd>
<dt>
single matrix mode </dt>
<dd>
OpenGL always maintains two matrices: ModelView and Projection. While an OpenGL implementation can consolidate these into a single matrix for performance reasons, it must always present the two-matrix model to the programmer.</dd>
<dt>
subpixel mode</dt>
<dd>
All OpenGL rendering is subpixel positioned—subpixel mode is always on.</dd>
<dt>
swaptmesh() </dt>
<dd>
OpenGL doesn't support the <b>swaptmesh</b> capability. It does offer two types of triangle meshes, however: one that corresponds to the default "strip" behavior of the IRIS GL, and another that corresponds to calling <b>swaptmesh</b> prior to the third and all subsequent vertices when using IRIS GL.</dd>
<dt>
vector arguments</dt>
<dd>
All OpenGL commands that are accepted between <a href="glfunc01_9u3y.htm"><b>glBegin</b></a> and <a href="glfunc01_9u3y.htm"><b>glEnd</b></a> have entry points that accept vector arguments. For example, <a href="glfunc01_62b6.htm"><b>glColor4fv</b></a>.</dd>
<dt>
window management </dt>
<dd>
OpenGL includes no window system commands. It is always supported as an extension to a window or operating system that includes capability for device and window control. Each extension provides a system-specific mechanism for creating, destroying, and manipulating OpenGL rendering contexts. For example, the OpenGL extension to the X window system (GLX) includes roughly 10 commands for this purpose.
<p>
IRIS GL commands such as <b>gconfig</b> and <b>drawmode</b> are not implemented by OpenGL.
</dd>
<dt>
window offset</dt>
<dd>
IRIS GL returns viewport and character positions in screen, rather than window, coordinates. OpenGL always uses window coordinates.</dd>
<dt>
z rendering</dt>
<dd>
OpenGL doesn't support rendering colors to the depth buffer. It does allow for additional color buffers, which can be implemented using the same memory that is used for depth buffers in other window configurations. But these additional color buffers cannot share memory with the depth buffer in any single configuration.
</dd>
</dl>
<p>
</p>
<p>&nbsp;</p></body>
</HTML>
