<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>OpenGL Performance Tips</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_ogl_opengl_performance_tips"></a>OpenGL Performance Tips</h1>
<p>
These programming practices optimize your application's performance:
<ul>
<li>
Use <a href="glfunc01_58vg.htm"><b>glColorMaterial</b></a> when only a single material property is being varied rapidly (at each vertex, for example). Use <a href="glfunc03_7cq4.htm"><b>glMaterial</b></a> for infrequent changes, or when more than a single material property is being varied rapidly. </li>
<li>
Use <a href="glfunc03_6h2x.htm"><b>glLoadIdentity</b></a> to initialize a matrix, rather than loading your own copy of the identity matrix. </li>
<li>
Use specific matrix calls such as <a href="glfunc03_21d1.htm"><b>glRotate</b></a>, <a href="glfunc03_9a05.htm"><b>glTranslate</b></a>, and <a href="glfunc03_1691.htm"><b>glScale</b></a>, rather than composing your own rotation, translation, and scale matrices and calling <a href="glfunc03_0xmg.htm"><b>glMultMatrix</b></a>. </li>
<li>
Use <a href="glfunc03_68iq.htm"><b>glPushAttrib</b></a> and <a href="glfunc03_68iq.htm"><b>glPopAttrib</b></a> to save and restore state values. Use query functions only when your application requires the state values for its own computations. </li>
<li>
Use display lists to encapsulate potentially expensive state changes. For example, place all the <a href="glfunc03_16hw.htm"><b>glTexImage</b></a> calls required to completely specify a texture (and perhaps the associated <a href="glfunc03_9upe.htm"><b>glTexParameter</b></a>, <a href="glfunc03_7kdh.htm"><b>glPixelStore</b></a>, and <a href="glfunc03_881e.htm"><b>glPixelTransfer</b></a> calls as well) into a single display list. Call this display list to select the texture. </li>
<li>
Use display lists to encapsulate the rendering calls of rigid objects that will be drawn repeatedly. </li>
<li>
To minimize network bandwidth in client/server environments, use evaluators even for simple surface tessellations. </li>
<li>
If possible, to avoid the overhead of GL_NORMALIZE, provide unit-length normals. Because <a href="glfunc03_1691.htm"><b>glScale</b></a><b> </b>almost always requires enabling GL_NORMALIZE, avoid using <b>glScale</b> when doing lighting. </li>
<li>
If smooth shading isn't required, set <a href="glfunc03_24rw.htm"><b>glShadeModel</b></a> to GL_FLAT. </li>
<li>
Use a single <a href="glfunc01_8koi.htm"><b>glClear</b></a> call per frame, if possible. Do not use <b>glClear</b> to clear small subregions of the buffers; use it only to clear the buffer completely or nearly completely. </li>
<li>
To draw multiple independent triangles, use a single call rather than multiple calls to <a href="glfunc01_9u3y.htm"><b>glBegin</b></a><b>(</b>GL_TRIANGLES<b>)</b> or a call to <b>glBegin(</b>GL_POLYGON<b>)</b>. Similarly:<p>
To draw even a single triangle, use GL_TRIANGLES rather than GL_POLYGON. 
<p>
Use a single call to <b>glBegin(</b>GL_QUADS<b>)</b> rather than calling <b>glBegin(</b>GL_POLYGON<b>)</b> repeatedly. 
<p>
Use a single call to <b>glBegin(</b>GL_LINES<b>)</b> to draw multiple independent line segments, rather than calling <b>glBegin(</b>GL_LINES<b>)</b> multiple times. 
</li>
<li>
In general, use the vector forms of commands to pass precomputed data, and use the scalar forms of commands to pass values that are computed near call time. </li>
<li>
Avoid making redundant mode changes, such as setting the color to the same value between each vertex of a flat-shaded polygon.</li>
<li>
When drawing or copying images, disable rasterization and per-fragment operations, which consume a lot of resources. OpenGL can apply textures to pixel images.</li>
</ul>
<p>
</p>
<p>&nbsp;</p></body>
</HTML>
