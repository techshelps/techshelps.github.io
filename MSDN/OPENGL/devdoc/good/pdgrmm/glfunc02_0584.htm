<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>glGetColorTableEXT</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_ogl_glgetcolortableext"></a>glGetColorTableEXT</h1>
<p>
The <b>glGetColorTableEXT</b> function gets the color table data of the current targeted texture palette.</p>
<pre><code><b>void glGetColorTableEXT(
  GLenum</b><i> target</i><b>,</b>        
<b>  GLenum</b><i> format</i><b>,</b>        
<b>  GLenum</b><i> type</i><b>,</b>          
<b>  const GLvoid *</b><i> data</i>   
<b>);</b>
 </code></pre>
<h4>Parameters</h4>
<dl>
<dt>
<i>target</i></dt>
<dd>
The target texture that is to have its palette changed. Must be TEXTURE_1D or TEXTURE_2D.</dd>
<dt>
<i>format</i></dt>
<dd>
The format of the pixel data. The following symbolic constants are accepted: 
<dl>
<dt>
GL_RGBA </dt>
<dd>
Each pixel is a group of four components in the following order: red, green, blue, alpha. The RGBA format is determined in this way:
<p>
1.The <b>glGetColorTableEXT</b> function converts floating-point values directly to an internal format with unspecified precision. Signed integer values are mapped linearly to the internal format such that the most positive representable integer value maps to 1.0, and the most negative representable integer value maps to – 1.0. Unsigned integer data is mapped similarly: the largest integer value maps to 1.0, and zero maps to 0.0. 

<p>
2.The <b>glGetColorTableEXT</b> function multiplies the resulting color values by GL_c_SCALE and adds them to GL_c_BIAS, where <i>c</i> is RED, GREEN, BLUE, and ALPHA for the respective color components. The results are clamped to the range [0,1].

<p>
3.If GL_MAP_COLOR is TRUE, <b>glGetColorTableEXT</b> scales each color component by the size of lookup table GL_PIXEL_MAP_c_TO_c, then replaces the component by the value that it references in that table; <i>c</i> is R, G, B, or A, respectively.

<p>
4.The <b>glGetColorTableEXT</b> function converts the resulting RGBA colors to fragments by attaching the current raster position z-coordinate and texture coordinates to each pixel, then assigning <i>x</i> and <i>y</i> window coordinates to the <i>n</i>th fragment such that

<p>
<i>x (n) </i> = <i>x (r) </i> + <i>n</i> mod <i>width</i>

<p>
<i>y (n) </i> = <i>y (r) </i> + <font face="Symbol">ë</font> <i>n/width</i> <font face="Symbol">û</font>

<p>
where (<i>x (r) , y (r) </i>) is the current raster position. 

<p>
5.These pixel fragments are then treated just like the fragments generated by rasterizing points, lines, or polygons. The <b>glGetColorTableEXT</b> function applies texture mapping, fog, and all the fragment operations before writing the fragments to the frame buffer. 
</dd>
<dt>
GL_RED </dt>
<dd>
Each pixel is a single red component. 
<p>
The <b>glGetColorTableEXT</b> function converts this component to the internal format in the same way that the red component of an RGBA pixel is, then converts it to an RGBA pixel with green and blue set to 0.0, and alpha set to 1.0. After this conversion, the pixel is treated just as if it had been read as an RGBA pixel. 
</dd>
<dt>
GL_GREEN </dt>
<dd>
Each pixel is a single green component. 
<p>
The <b>glGetColorTableEXT</b> function converts this component to the internal format in the same way that the green component of an RGBA pixel is, and then converts it to an RGBA pixel with red and blue set to 0.0, and alpha set to 1.0. After this conversion, the pixel is treated just as if it had been read as an RGBA pixel. 
</dd>
<dt>
GL_BLUE </dt>
<dd>
Each pixel is a single blue component. 
<p>
The <b>glGetColorTableEXT</b> function converts this component to the internal format in the same way that the blue component of an RGBA pixel is, and then converts it to an RGBA pixel with red and green set to 0.0, and alpha set to 1.0. After this conversion, the pixel is treated just as if it had been read as an RGBA pixel. 
</dd>
<dt>
GL_ALPHA </dt>
<dd>
Each pixel is a single alpha component. 
<p>
The <b>glGetColorTableEXT</b> function converts this component to the internal format in the same way that the alpha component of an RGBA pixel is, and then converts it to an RGBA pixel with red, green, and blue set to 0.0. After this conversion, the pixel is treated just as if it had been read as an RGBA pixel. 
</dd>
<dt>
GL_RGB </dt>
<dd>
Each pixel is a group of three components in this order: red, green, blue. 
<p>
The <b>glGetColorTableEXT</b> function converts each component to the internal format in the same way that the red, green, and blue components of an RGBA pixel are. The color triple is converted to an RGBA pixel with alpha set to 1.0. After this conversion, the pixel is treated just as if it had been read as an RGBA pixel. 
</dd>
<dt>
GL_BGR_EXT </dt>
<dd>
Each pixel is a group of three components in this order: blue, green, red.
<p>
GL_BGR_EXT provides a format that matches the memory layout of Windows device-independent bitmaps (DIBs). Thus your applications can use the same data with Win32 function calls and OpenGL pixel function calls.
</dd>
<dt>
GL_BGRA_EXT </dt>
<dd>
Each pixel is a group of four components in this order: blue, green, red, alpha.
<p>
GL_BGRA_EXT provides a format that matches the memory layout of Windows device-independent bitmaps (DIBs). Thus your applications can use the same data with Win32 function calls and OpenGL pixel function calls.
</dd>
</dl>
</dd>
<dt>
<i>type</i></dt>
<dd>
The data type for <i>data</i>. The following symbolic constants are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, and GL_FLOAT. 
<p>
The following table summarizes the meaning of the valid constants for the <i>type</i> parameter.

<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=48%>Constant</th>
<th align=left width=52%>Meaning</th>
</tr>
<tr valign=top>
<td width=48%>GL_UNSIGNED_BYTE</td>
<td width=52%>Unsigned 8-bit integer </td>
</tr>
<tr valign=top>
<td width=48%>GL_BYTE</td>
<td width=52%>Signed 8-bit integer</td>
</tr>
<tr valign=top>
<td width=48%>GL_UNSIGNED_SHORT</td>
<td width=52%>Unsigned 16-bit integer</td>
</tr>
<tr valign=top>
<td width=48%>GL_SHORT</td>
<td width=52%>Signed 16-bit integer</td>
</tr>
<tr valign=top>
<td width=48%>GL_UNSIGNED_INT</td>
<td width=52%>Unsigned 32-bit integer</td>
</tr>
<tr valign=top>
<td width=48%>GL_INT</td>
<td width=52%>32-bit integer</td>
</tr>
<tr valign=top>
<td width=48%>GL_FLOAT</td>
<td width=52%>Single-precision floating-point value</td>
</tr>
</table><br>

</dd>
<dt>
<i>data</i></dt>
<dd>
Points to the location where returned color table information is to be stored. Each color table entry is stored as if it was a single pixel of a 1-D texture. Because all textures have a default palette, <b>glGetColorTableEXT</b> always returns palette information even if the texture data is not in a paletted format.
</dd>
</dl>
<h4>Remarks</h4>
<p>
The <b>glGetColorTableEXT</b> function gets the actual color table data specified by <a href="glfunc01_83n8.htm"><b>glColorTableEXT</b></a> and <a href="glfunc01_425w.htm"><b>glColorSubTableEXT</b></a>.</p>
<p>
<b>Note</b>  The <b>glGetColorTableEXT</b> function is an extension function that is not part of the standard OpenGL library but is part of the GL_EXT_paletted_texture extension. To check whether your implementation of OpenGL supports <b>glGetColorTableEXT</b>, call <a href="glfunc02_6dwn.htm"><b>glGetString</b></a><b>(</b>GL_EXTENSIONS<b>)</b>. If it returns GL_EXT_paletted_texture, <b>glGetColorTableEXT</b> is supported. To obtain the function address of an extension function, call <a href="ntopnglr_6yer.htm"><b>wglGetProcAddress</b></a>.</p>
<h4>Error Codes</h4>
<p>
The following are the error codes generated and their conditions.</p>
<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=45%>Error Code</th>
<th align=left width=55%>Condition</th>
</tr>
<tr valign=top>
<td width=45%>GL_INVALID_ENUM </td>
<td width=55%><i>target</i>, <i>format</i>, or <i>type </i>was not an accepted value.</td>
</tr>
<tr valign=top>
<td width=45%>GL_INVALID_OPERATION </td>
<td width=55%><b>glGetColorTableEXT</b> was called between <b>glBegin</b> and <b>glEnd</b> pairs.</td>
</tr>
</table><br>
<h4>See Also</h4>
<p>
<a href="glfunc01_425w.htm"><b>glColorSubTableEXT</b></a>, <a href="glfunc01_83n8.htm"><b>glColorTableEXT</b></a>, <a href="glfunc02_9svo.htm"><b>glGetColorTableParameterfvEXT</b></a>, <a href="glfunc02_9svo.htm"><b>glGetColorTableParameterivEXT</b></a>, <a href="ntopnglr_6yer.htm"><b>wglGetProcAddress</b></a> </p>
<p>&nbsp;</p></body>
</HTML>
