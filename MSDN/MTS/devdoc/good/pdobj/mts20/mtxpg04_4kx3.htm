<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Components and Threading</title>
<link disabled rel=stylesheet href=../../../backsdk3.css>
<style type="text/css">
@import url(../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>

<h1><a name="asconcomponentsandthreading"></a>Components and Threading</h1>
<p>
The MTS run-time environment manages <a href="vipdef01_1yih.htm#asdefthread">threads</a> for you. <a href="vipdef01_1yih.htm#asdefvipercomponent">MTS components</a> need not, and, in fact, should not, create threads. Components must never terminate a thread that calls into a <a href="vipdef01_1yih.htm#asdefdll">DLL</a>.</p>
<p>
Every MTS component has a <b>ThreadingModel</b> Registry attribute, which you can specify when you develop the component. This attribute determines how the component's objects are assigned to threads for method execution. You can view the threading-model attribute in the <a href="vipdef01_1yih.htm#asdefmicrosofttransactionserverexplorer">MTS Explorer</a> by clicking the Property view in the Components folder. The possible values are Single, Apartment, and Both.</p>
<p>
Single-Threaded Components</p>
<p>
All objects of a single-threaded component execute on the <a href="vipdef01_1yih.htm#asdefmainthread">main thread</a>. This is compatible with the default <a href="vipdef01_1yih.htm#asdefcom">COM</a> threading model, which is used for components that do not have a <b>ThreadingModel</b> Registry attribute.</p>
<p>
The main<i> </i>threading<i> </i>model provides compatibility with COM components that are not reentrant. Because objects always execute on the main thread, method execution is serialized across all objects in the component. In fact, method execution is serialized across all components in a process that uses this policy. This allows components to use libraries that are not reentrant, but it has very limited scalability.</p>
<h5>Limitations for Single-Threaded Components</h5>
<p>
Single-threaded, <a href="vipdef01_1yih.htm#asdefstatefulinstance">stateful</a> components are prone to <a href="vipdef01_1yih.htm#asdefdeadlock">deadlocks</a>. You can eliminate this problem by using <a href="vipdef01_1yih.htm#asdefstatelessinstance">stateless</a> objects and calling <b>SetComplete</b> before returning from any method.</p>
<p>
The following scenario describes how such a deadlock can occur. Suppose you have a single-threaded Account component, which is written to be both transactional and stateful. The following scenario describes how two clients, Client 1 and Client 2, could call objects in a way that causes an application deadlock:
<ul>
<li>
Client 1 creates Account object A and calls it to update an account record. The database update is done under object A's <a href="vipdef01_1yih.htm#asdeftransaction">transaction</a> (Transaction 1). Because the object does not call <b>SetComplete</b> before returning to the client, Transaction 1 remains active.</li>
<li>
Next, Client 2 creates Account object B and calls it to update the same account. Because its work is done under a different transaction (Transaction 2), the attempt to update the account record will block while waiting for Transaction 1 to complete.</li>
<li>
Client 1 makes another call to object A, for instance, to have it make another change to the account record and complete the transaction. However, the call must wait for the main thread, which is still busy servicing the call from Client 2.</li>
<li>
The two clients are now deadlocked. Client 1 holds a lock on the account record, while waiting for the server's main thread so that it can complete Transaction 1. Client 2 holds the server's main thread, while waiting for Transaction 1 to complete so that it can update the account record.</li>
</ul>
<p>
Note that this is not a deadlock from the SQL perspective because A's and B's connections are in different transactions.</p>
<p>
Apartment-Threaded Components</p>
<p>
Each object of an apartment-threaded component is assigned to a thread its <i>apartment</i>, for the life of the object; however, multiple threads  can be used for multiple objects. This is a standard COM <a href="vipdef01_1yih.htm#asdefconcurrency">concurrency</a> model. Each apartment is tied to a specific thread and has a Windows message pump.</p>
<p>
The apartment threading model provides significant concurrency improvements over the main threading model. <a href="vipdef01_1yih.htm#asdefactivity">Activities</a> determine apartment boundaries; two objects can execute concurrently as long as they are in different activities. These objects may be in the same component or in different components.</p>
<h6>See Also</h6>
<p>
<a href="mtxpg04_5tf7.htm">Activities</a></p>
<p>&nbsp; </p></body>
</HTML>
