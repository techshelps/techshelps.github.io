<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Application Design Notes: Using Separate Transactions (Visual Basic)</title>
<link disabled rel=stylesheet href=../../../backsdk3.css>
<style type="text/css">
@import url(../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>

<h1><a name="asconapplicationdesignnotesusingseparatetransactions"></a>Application Design Notes: Using Separate Transactions</h1>
<p>
In <a href="mtxpg07vb_7qr3.htm">Building Transactional Components</a>, you saw the benefits of composing work under a <a href="vipdef01_1yih.htm#asdeftransaction">transaction</a>. The <a href="mtxpg10vb_57dx.htm">scenario</a> in this section demonstrates a case in which using multiple transactions within an <a href="vipdef01_1yih.htm#asdefactivity">activity</a> is required.</p>
<p>
The major functional change in this scenario is the addition of the UpdateReceipt component, which makes the maximum receipt number durable by storing it in a database. As in <a href="mtxpg08vb_4hnp.htm">Sharing State</a>, the Shared Property Manager stores the receipt number. On every 100 transactions, the value in the database is incremented by 100. This dispenses a block of receipt numbers that are assigned to the next 100 transactions.</p>
<p>
The UpdateReceipt component has a transaction attribute of <b>Requires a new transaction</b>. This guarantees that UpdateReceipt's work happens in a separate transaction. Thus, there is no connection between the success or failure of Account's work and UpdateReceipt's work.</p>
<p>
This might appear to lower the <a href="vipdef01_1yih.htm#asdeffaulttolerance">fault tolerance</a> of the application. For example, if the Account object aborts the transaction, a receipt number is still assigned. Therefore, skips in the receipt number sequence are possible. However, the application doesn't really need consecutively increasing receipt numbers—it just requires that there be no duplicate receipts. In this scenario, it's more important for the monetary transaction to be completed properly. Furthermore, requesting an update on every one-hundredth transaction improves performance by conserving calls to the database.</p>
<p>
Composing both database updates under a single transaction would reduce the application's scalability. Even though UpdateReceipt is a simple update, it would consume more server resources because the database connection would have to be maintained until the Account object has completed its work. Thus, locks would be held longer than necessary, preventing other clients from writing to the database. Only when all work has been completed could these resources be freed.</p>
<h5>See Also</h5>
<p>
<a href="mtxpg04_5soj.htm">Transactions</a>, <a href="mtxpg04_8ier.htm">Transaction Attributes</a></p>
<p>&nbsp; </p></body>
</HTML>
