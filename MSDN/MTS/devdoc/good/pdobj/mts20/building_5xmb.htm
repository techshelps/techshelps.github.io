<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Holding State in Objects</title>
<link disabled rel=stylesheet href=../../../backsdk3.css>
<style type="text/css">
@import url(../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>

<h1><a name="asholdingstateinobjects"></a>Holding State in Objects</h1>
<p>
Although there are many benefits to using <i>stateless</i> MTS objects, there are cases where holding state is desirable. This topic provides some guidelines in deciding where state is held in your application.</p>
<p>
The following diagram shows a <i>three-tier architecture</i>:</p>
<p>
<img src="images/state1.gif" border=0></p>
<p>
Typically, the latency between tiers differs greatly. Calls between the <i>presentation tier</i> and <i>business tier</i> are often an order of magnitude slower than calls between the business tier and <i>data</i> <i>tier</i>. As a result, held state is more costly when calling into the business tier.</p>
<p>
However, it often makes sense to hold state within the <i>transaction boundary</i> itself. For example, the objects in the data tier may represent a complex join across many tables in separate databases. Reconstructing the data object state is potentially more inefficient than the cost of the resources held by those objects while they remain active.</p>
<p>
Since objects lose state on transaction boundaries, if you need to hold state across transactions, use the Shared Property Manager or store the state in a database.</p>
<h3>Example: Order-Entry Application</h3>
<p>
There are two separate issues when considering the effects of holding state in an application:
<ul>
<li>
Network roundtrips&nbsp;— More frequent network roundtrips and slower connections extend the <i>lifetime</i> of the called MTS object.</li>
<li>
Held resources&nbsp;— Holding state often means holding onto a resource, such as a database connection, and potentially, locks on the database.</li>
</ul>
<p>
Consider the example of an online shopping application. The client chooses items from a catalog and submits an order. Order processing is handled by a business object, which in turn stores the order in a database (not shown).</p>
<p>
One way of building the application is for the client to call an <b>Order</b> object, with each call adding or removing an item from the order:</p>
<p>
<img src="images/state2.gif" border=0></p>
<p>
This application has the following properties:
<ul>
<li>
Client maintains no state.</li>
<li>
Server maintains state across multiple calls.</li>
<li>
Many network roundtrips.</li>
<li>
High contention for resources. The database connection is held for the lifetime of the <b>Order</b> object. This is not a very scalable solution.</li>
</ul>
<p>
You can require that the client cache the items in an array or recordset:</p>
<p>
<img src="images/state3.gif" border=0></p>
<p>
This application has the following properties:
<ul>
<li>
Stateful client.</li>
<li>
Server is virtually stateless with one call to the server.</li>
<li>
Fewer network roundtrips.</li>
<li>
Less contention for resources. This is a scalable solution.</li>
</ul>
<h3>Concurrency</h3>
<p>
In addition to network bandwidth and resources, concurrency affects application performance. There are two types of <i>concurrency</i>:
<ul>
<li>
<b>Pessimistic</b>&nbsp;— As soon as editing begins, the database locks the records being changed. The records are unlocked when all changes are complete. No two users can access the same record at the same time.</li>
<li>
<b>Optimistic</b>&nbsp;— The database locks the records being changed only when the changes are committed. Two users can access the same record at the same time, and the database must be able to reconcile, or simply reject, changed records that have been edited by multiple users prior to commit.</li>
</ul>
<p>
Implementing a server cache implies <i>optimistic concurrency</i>. The server does not have to hold locks on the database, thus freeing resources.</p>
<p>
However, if there is high contention for the resource, <i>pessimistic concurrency </i>may be preferred. It is easier to reject a request to access a database and have the server try again than it is to reconcile cached, out-of-date data with a rapidly changing database.</p>
<p>&nbsp; </p></body>
</HTML>
