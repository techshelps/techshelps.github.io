<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Debugging Java Classes</title>
<link disabled rel=stylesheet href=../../../backsdk3.css>
<style type="text/css">
@import url(../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>

<h1><a name="asdebuggingjavaclasses"></a>Debugging Java Classes</h1>
<p>
Debug your Java classes as thoroughly as possible before converting the Java classes into MTS components. Note that once your Java class is converted into an MTS component, it is not possible to step through the code in the Visual J++ debugger, or in any current debugging tool as well.</p>
<h5>Sidebar: Using Visual J++ to Debug Java Classes</h5>
<p>
Microsoft Visual J++ (VJ++) provides a Java debugger that you can use to set breakpoints in your code. Note that when you are using VJ++ to debug, if you set a breakpoint in a Java source file before starting the debugging session, Visual J++ may not stop on the breakpoint. For performance reasons, the debugger preloads only the <i>main class</i> of your project. The main class is either the class with the same name as the project or the class you specify in VJ++. If you use the editor to set breakpoints in other classes before the classes are loaded, the breakpoints are disabled.</p>
<p>
You can choose one of the following options to load the correct class so that the debugger stops at breakpoints.
<ul>
<li>
Select the class in the category <b>Additional Classes</b>, located on the <b>Debug</b> tab of the <b>Project Settings</b> dialog box, and make sure the first column is checked. This loads the class when the debugging session starts.</li>
<li>
Right-click a method in the ClassView pane of the <b>Project Workspace </b>and select <b>Set Breakpoint</b> from the <b>Shortcut</b> menu. This causes a break when program execution enters the method.</li>
<li>
Set the breakpoint after Visual J++ has loaded the class during debugging. You may need to step through your Java source until the class is loaded.</li>
</ul>
<p>
When a method has one or more overloaded versions and shows up as a called method in the <b>Call Stack</b> window, the type and value for the parameters are not displayed in some cases. It appears as though the method takes no parameters. This occurs when the called method is not defined as the first version of the overloaded method in the class definition. For example, see the following class definition:</p>
<pre><code>public class Test
   {
       int method(short s)
       {
           return s;
       }

       int method(int i)
       {
           return i;
       }
   }</code></pre>
<p>
If you were looking at a call to the second version of the method in the <b>Call Stack </b>window, it would appear without the type and value for the method:</p>
<pre><code>method()</code></pre>
<p>
To view the method’s parameters, change the order of the method overloads so that the method that you are currently debugging is first in the class definition.</p>
<p>
<b>printf</b>-style Debugging</p>
<p>
You can use <b>printf</b>-style debugging to debug your Java classes without using a debugger. printf-style debugging involves including status text messages into your code, allowing you to "step through" your code without a debugger. You can also use printf-style debugging to return error information. The following code shows how you can add a <code>System.out.println</code> call to the <b>try</b> clause of the Hellojtx.HelloObj.SayHello sample.</p>
<pre><code>try
{    
System.out.println("This message is from the HelloObj implementation");
    result[0] = "Hello from simple MTS Java sample";
    MTx.GetObjectContext().SetComplete();
    return 0;
}</code></pre>
<p>
The client must be a Java client class, and you must use the JVIEW<b> </b>console<b> </b>window to run that class. Note that you need to configure your component to run in the process of its caller, which is in this case JVIEW. Otherwise, this debugging technique results in your component running in the MTS server process (mtx.exe), which would put the println output in the bit bucket rather than the JVIEW console window.</p>
<p>
Use the MTS Explorer to configure your component to run in the caller's process by following these steps.
<ol>
<li>
Right-click the component.</li>
<li>
Click the <b>Properties </b>option.</li>
<li>
Click the <b>Activation</b> tab and clear the <b>In a server process on this</b> <b>computer</b> checkbox.</li>
<li>
Select the <b>In the creator’s process</b>... checkbox.</li>
<li>
Reload the <b>Client</b> class. Your component's <code>println</code> calls will be visible in the JVIEW console window.</li>
</ol>
<p>
Using the AWT Classes</p>
<p>
You can also use the AWT (Abstract Window Toolkit) classes to display intermediate results, even if your component is running in a server process. The java.awt package provides an integrated set of classes to manage user interface components such as windows, dialog boxes, buttons, checkboxes, lists, menus, scrollbars, and text fields.</p>
<p>
The following example demonstrates how to use the AWT classes to display intermediate results in a dialog box:</p>
<pre><code>import java.awt.*;

public final class MyMessage extends Frame
{

    private Button closeButton;
    private Label textLabel;

    // constructor
    public MyMessage(String msg)
    {
        super("Debug Window");

        Panel panel;

        textLabel = new Label (msg, Label.CENTER);
        closeButton = new Button ("Close");

        setLayout (new BorderLayout (15, 15));
        add ("Center", textLabel);

        add ("South", closeButton);

        pack();
        show();
    }

    public boolean action (Event e, Object arg)
    {

        if (e.target == closeButton)
        {
            hide();
            dispose();
            return true;
        }

        return false;
    }

}</code></pre>
<p>
Asynchronous Java Garbage Collection</p>
<p>
Note that <i>garbage collection</i> for Java components is asynchronous to program execution and can cause unexpected behavior. This behavior especially affects MTS components that perform functions such as enumerating through the collections in the catalog because the collection count will be too high (garbage collection is not synchronized). To force synchronous release of references to COM or MTS objects, you can use the release method defined in class com.ms.com.ComLib.</p>
<p>
<b>Example:</b></p>
<pre><code>Import com.ms.com.ComLib
…
ComLib.release(someMTSObject);</code></pre>
<p>
This method releases the reference to the object when the call is executed. Release the object reference when you are sure that the reference is no longer needed. Note that if you fail to release the reference, an application error is not returned. However, an incorrect collection count results because the object reference is released asynchronously when the garbage collector eventually runs.</p>
<p>
You can also force the release of your reference and not call that released reference again. </p>
<p>
<b>Example:</b></p>
<pre><code>myHello = null;
    System.gc();</code></pre>
<p>
Note that forcing the release of an object reference consumes extensive system resources. It is recommended that you use the release method defined in com.ms.com.ComLib class to release references to MTS objects in a synchronous fashion.</p>
<p>&nbsp; </p></body>
</HTML>
