<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>IObjectControl::CanBePooled Method (Visual C++)</title>
<link disabled rel=stylesheet href=../../../backsdk3.css>
<style type="text/css">
@import url(../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>

<h1><a name="asmthcanbepooledvc"></a>IObjectControl::CanBePooled Method</h1>
<p>
Implementing this method allows an <a href="vipdef01_1yih.htm#asdefmicrosofttransactionserverobject">MTS object</a> to notify the MTS run-time environment of whether it can be pooled for reuse. Return TRUE if you want the object to be pooled for reuse, or FALSE if not.</p>
<p>
<b>Provided By</b></p>
<p>
<a href="objctxvc_24tf.htm"><b>IObjectContext</b></a></p>
<pre><b>BOOL IObjectControl::CanBePooled ( );</b></pre>
<p>
<b>Return Values</b></p>
<p>
TRUE<br>
Notifies the MTS run-time environment that it can pool this object on deactivation for later reuse.</p>
<p>
FALSE<br>
Notifies the MTS run-time environment that it should not pool this object on deactivation, but should release its last reference to the object so that the object will be destroyed.</p>
<p>
<b>Remarks</b></p>
<p>
When an object returns TRUE from the <a href="#asmthcanbepooledvc"><b>CanBePooled</b></a>method, it indicates to the MTS run-time environment that it can be added to an object pool after deactivation rather than being destroyed. Whenever an <a href="vipdef01_1yih.htm#asdefinstance">instance</a> is required, one is drawn from the pool rather than created by the <a href="vipdef01_1yih.htm#asdefclassfactory">class factory</a>.</p>
<p>
The way recycling works is that an object cleans itself up in its <a href="objctrlvc_100z.htm"><b>Deactivate</b></a> method and is returned to an object pool. Later, when an instance of the same component is needed, the cleaned up object can be reused. For this to work, an object must be accessible on different <a href="vipdef01_1yih.htm#asdefthread">threads</a> each time it's activated. Recycling isn't possible under the <a href="vipdef01_1yih.htm#asdefapartmentthread">apartment threading</a> model because, in that model, although an object can be instantiated on any thread, it can only be used by the thread on which it was instantiated. If you want instances of a component to be recyclable, you should register the component with the <b>ThreadingModel</b> Registry value set to <b>Both</b>. This indicates to MTS that the component's objects can be called from different threads.</p>
<p>
In MTS, these objects will run under the apartment threading model and won't be recycled even if they return TRUE from the <b>CanBePooled</b> method. However, if you configure a component to support both threading models, the component will run under the current version of MTS and will also be able to take advantage of recycling as soon as it becomes available, without any changes to the code.</p>
<p>
Deciding whether to enable recycling is a matter of weighing the costs and benefits. Recycling requires writing additional code, and there's a risk that some state may be inadvertently retained from one activation to the next. When you allow objects to be pooled, you have to be very careful in your <a href="objctrlvc_3crn.htm"><b>Activate</b></a> and <b>Deactivate</b> methods to ensure that a recycled object is always restored to a state that's equivalent to the state of a newly created object. Another consideration to take into account is the amount of resources required to maintain an object pool. Objects that hold a lot of resources can be expensive to pool. However, in certain situations, recycling can be extremely efficient, resulting in improved performance and increased scalability. The trade-off is between the cost of holding onto resources while objects are pooled (and inactive) versus the cost of creating and destroying the resources.</p>
<p>
It's usually best to enable recycling for objects that cost more to create than they cost to reinitialize. For example, if a component contains a complex structure, and that structure can be reused, it could save a lot of time if the structure didn't have to be recreated every time an instance of the component was activated. This is a case in which you might want to enable recycling, which you would do by returning TRUE from the <b>CanBePooled</b> method.</p>
<p>
You could still create the structure in the object's <a href="vipdef01_1yih.htm#asdefconstructor">constructor</a> and release it in the destructor. The constructor is only called once, when a new object is created by the class factory. When recycling is enabled, that only happens when the object pool is empty. The <b>Activate</b> method, on the other hand, is called whether a new instance is created by the class factory or a recycled instance is drawn from the pool. Similarly, the object's destructor is only called when no further instances are needed, for example, when the server is shutting down. The <b>Deactivate</b> method is called every time the object is deactivated, whether it's being destroyed or returned to the pool for recycling.</p>
<p>
So, in this example, you'd use the object's <b>Activate</b> method to initialize, or reinitialize, the structure that's being reused, and you'd use the <b>Deactivate</b> method to restore the object to a state that the <b>Activate</b> method can handle. (The <b>Activate</b> method must be able to handle both new objects created by the class factory and reused objects drawn from the pool.) This combined use of the <b>Activate</b>, <b>Deactivate</b>, and <b>CanBePooled</b> methods eliminates the need to recreate reusable resources every time an instance is activated.</p>
<p>
For some objects, recycling isn't efficient. For example, if an object acquires a lot of state during its lifetime that isn't reusable, and has little to do during its construction, it's usually cheaper to create a new instance whenever one is needed. In that case, you would return FALSE from the <b>CanBePooled</b> method.</p>
<p>
<b>Note  </b> Returning TRUE from the <b>CanBePooled</b> method doesn't guarantee that objects will be recycled; it only gives the MTS run-time environment permission to recycle them. On systems that don't support object pooling, a return value of TRUE is ignored. Returning FALSE from the <b>CanBePooled</b> method guarantees that instances of a component aren't recycled.</p>
<p>
<a href="objctrlvc_8njs.htm"><b>Example</b></a></p>
<p>
<b>See Also</b></p>
<p>
<a href="mtxpg04_5s37.htm">Deactivating Objects</a>, <a href="mtxpg04_8v6v.htm">Object Pooling and Recycling</a></p>
<p>&nbsp; </p></body>
</HTML>
