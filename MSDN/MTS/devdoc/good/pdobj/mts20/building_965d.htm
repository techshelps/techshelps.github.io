<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Developing MTS Components with Java</title>
<link disabled rel=stylesheet href=../../../backsdk3.css>
<style type="text/css">
@import url(../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>

<h1><a name="asdevelopingmtscomponentswithjava"></a>Developing MTS Components with Java</h1>
<p>
You can develop Java MTS components using tools provided by MTS and Visual J++. It is also recommended that you install the latest version of the Microsoft SDK for Java, available at http://www.microsoft.com/java.</p>
<p>
This section contains the following topics:
<ul>
<li>
Implementing a Component in Java</li>
<li>
Using an MTS Component from Java</li>
<li>
Using the Java Sample Bank Components</li>
</ul>
<p>
Implementing a Component in Java</p>
<p>
<b><img src="images/prcarrow.gif" border=0>To implement a component in Java, follow these steps</b>
<ol>
<li>
Run the ActiveX Component Wizard for Java (available with Visual J++) for each Java class file. Use the wizard to create new IDL files.</li>
<li>
Modify the IDL files to add JAVACLASS and PROGID to the coclass attributes. See "Using IDL Files with Java Components."</li>
<li>
Run the ActiveX Component Wizard for Java again. Use the IDL files that you created in Step 1 to create type libraries for your components.</li>
</ol>
<p>
This will create a set of Java class files, typically under \%systemroot%\Java\Trustlib. It will create one class file for each custom interface, and one class file for each coclass in the library.
<ol>
<li>
Run JAVAGUID against each class file generated in Step 3. See "Working with GUIDs in Java" for more information.</li>
<li>
Recompile your Java implementation classes.</li>
<li>
Run EXEGEN to convert the type libraries and class files into a DLL. See "Using EXEGEN to Create DLLs."</li>
<li>
Use the MTS Explorer to install the DLL.</li>
</ol>
<h5>Using IDL Files with Java Components</h5>
<p>
To specify the custom attributes in a type library, add the following in your IDL or ODL file:</p>
<pre><code>#include &lt;JavaAttr.h&gt;</code></pre>
<p>
Within the attributes section of a coclass, specify the JAVACLASS:</p>
<pre><code>JAVACLASS("<i>package</i>.<i>class</i>")</code></pre>
<p>
You may optionally specify a PROGID:</p>
<pre><code>PROGID("<i>Progid</i>")</code></pre>
<p>
For example:</p>
<pre><code>    [
        uuid(a2cda060-2d38-11d0-b94b-0080c7394688),
        helpstring("Account Class"),
        JAVACLASS("Account.AccountObj"),
        PROGID("Bank.Account.VJ"),
        TRANSACTION_REQUIRED
    ]
    coclass CAccount
    {
        [default] interface IAccount;
    };</code></pre>
<h5>Using EXEGEN to Create DLLs</h5>
<p>
EXEGEN is the Java executable file generator. To use this file, copy it to the appropriate destination folders (usually \JavaSDK\bin). This version of EXEGEN.EXE is capable of creating DLL files from Java classes, and can also include user-specified resources in its output files. This version of EXEGEN no longer supports the /base: directive. Class files are always included with the proper name. It supports a new /D directive that causes it to generate a DLL file instead of an EXE.</p>
<p>
EXEGEN is now capable of reading five types of input files:
<ul>
<li>
Java class files</li>
<li>
RES files containg resources to be included</li>
<li>
Executable files containg resources to be included</li>
<li>
TLB files containing type libraries to be included</li>
<li>
Text files describing which classes should be registered (DLL only).</li>
</ul>
<p>
If you use EXEGEN to create a DLL, the DLL can self-register any included Java classes that implement COM objects. There are two ways to tell EXEGEN which classes should be registered:
<ul>
<li>
Include a type library that contains custom attributes for the classes. This is the preferred method.</li>
</ul>
<p>
–&nbsp;or&nbsp;–
<ul>
<li>
Include a text file as input that gives EXEGEN the necessary directions. Each line of the text file describes one Java class, using the following keywords:<ul>
<li>
class:JavaClassName </li>
</ul>
</li>
</ul>
<p>
Required keyword.
<ul>
<li>
clsid:{.....}</li>
</ul>
<p>
Optional keyword that specifies the clsid GUID. If omitted, EXEGEN chooses a unique GUID.
<ul>
<li>
progid:ProgId</li>
</ul>
<p>
Optional keyword. If omitted, the class will be registered without a progid.</p>
<h5>Working with GUIDs in Java</h5>
<p>
When an MTS method uses a GUID parameter, you must pass an instance of class com.ms.com._Guid. Do not use class Guid, CLSID or IID from package com.ms.com; they will not work and they are deprecated. The definition of class _Guid is:</p>
<pre><code>package com.ms.com;
public final class _Guid {

    // Constructors
    public _Guid (String s);
    public _Guid (byte[] b);
    public _Guid (int a, short b, short c,
        byte b0, byte b1, byte b2, byte b3,
        byte b4, byte b5, byte b6, byte b7);
    public _Guid ();

    // methods
    public void set(byte[] b);
    public void set(String s);
    public void set(int a, short b, short c,
        byte b0, byte b1, byte b2, byte b3,
        byte b4, byte b5, byte b6, byte b7);

    public byte[] toByteArray();
    public String toString();
}</code></pre>
<p>
Instances of this class can be constructed from a String (in the form “{00000000-0000-0000-0000-000000000000}”), from an array of 16 bytes, or from the usual parts of a Guid. Once constructed, the value can also be changed. Method toByteArray will return an array of 16 bytes as stored in the Guid, and method toString will return a string in the same form used by the constructor.</p>
<p>
<b>JAVAGUID.EXE</b></p>
<p>
Microsoft Transaction Server supplies a tool, JAVAGUID.EXE, that will post-process the output of JAVATLB. The following occurs for each class file:
<ul>
<li>
If any method takes a GUID as a parameter, the class of that parameter will be changed to com.ms.com._Guid.</li>
<li>
If the class file is an interface derived from a type library, a public static final member named <b>iid</b> will be added to the class. This member will contain the interface ID of the interface.</li>
<li>
If the class file represents a coclass derived from a type library, a public static final member named <b>clsid</b> will be added to the class. This member will contain the CLSID of the class.</li>
</ul>
<p>
The <b>clsid</b> and <b>iid</b> members that JAVAGUID adds are useful as parameters to <b>IObjectContext.CreateInstance</b> and <b>ITransactionContextEx.CreateInstance</b>.</p>
<p>
JAVAGUID can only be executed from the command line. It takes one or more parameters which are names of class files to update.</p>
<p>
JAVATLB will eventually be updated to make JAVAGUID unnecessary.</p>
<p>
Using an MTS Component from Java</p>
<p>
To use an MTS component from Java, run the Java Type Library Wizard against the type library for the component. This will create several Java class files, typically under \%systemroot%\Java\TrustLib. It will create one class file for each custom interface, and one class file for each coclass in the library.</p>
<p>
Assume, for example, that the type library contained one interface named IMyInterface, and one coclass, named CMyClass.</p>
<p>
From Java, you can create a new instance of the component by executing</p>
<pre><code>new CMyClass()</code></pre>
<p>
If you want to control transaction boundaries in the class, you can execute</p>
<pre><code>ITransactionContextEx.CreateInstance ( CMyClass.clsid, IMyInterface.iid )</code></pre>
<p>
You should never call Java’s <b>new</b> operator on the class that you implemented. Instead, use one of the following techniques:
<ul>
<li>
Use Java's new operator on the class created by the Java Type Library Wizard. This will cause the Java VM to call <b>CoCreateInstance</b>.</li>
<li>
Call <b>MTx.GetObjectContext().CreateInstance</b> (<i>clsid</i>, <i>iid</i>);<br>
This will create a new instance in the same activity as the current instance. This only works if the calling code is itself an MTS component.</li>
<li>
If you have a reference to an <b>ITransactionContextEx</b> object, call its <b>CreateInstance</b> method. This will create a new instance in the transaction owned by the <b>ITransactionContextEx</b> object.</li>
</ul>
<p>
All of these techinques will result in the creation of a new instance of the class that you implemented.</p>
<p>
Using the Java Sample Bank Components</p>
<p>
The Java Sample Bank components are automatically configured by MTS Setup and require no additional steps in order to run them.</p>
<p>
If you want to recompile the Java Sample Bank components, follow these steps:
<ol>
<li>
Run the SetJavaDev.bat file located in the \mts\Samples\Account.VJ folder. Javatlb.exe must be in your path for this batch file to run properly.</li>
<li>
Recompile your Java component implementation classes.</li>
<li>
After you recompile the component classes, use the mkdll.bat file located in the \mts\Samples\Account.VJ folder to generate and register vjacct.dll. Exegen.exe must be in your path for this batch file to run properly. You can also add running mkdll.bat as a build step to your Visual J++ project to simplify recompiling.</li>
<li>
Using the MTS Explorer, import the new components into the Sample Bank package.</li>
</ol>
<p>&nbsp; </p></body>
</HTML>
