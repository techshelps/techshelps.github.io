<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Debugging Visual C++ MTS Components</title>
<link disabled rel=stylesheet href=../../../backsdk3.css>
<style type="text/css">
@import url(../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>

<h1><a name="asdebuggingvisualcmtscomponents"></a>Debugging Visual C++ MTS Components</h1>
<p>
You can use Visual Studio 97 to debug MTS components written in Visual C++, including components that call SQL Server functions or stored procedures. For more information, see <a href="building_1ur7.htm">Debugging Visual Basic MTS Components</a>.</p>
<p>
The following information applies to components that have their activation property set to <b>In a dedicated server process</b>.</p>
<p>
Microsoft Transaction Server supports the COM transparent remote debugging infrastructure. If transparent remote debugging is enabled, then stepping into a client process will automatically stop at the actual object's code in the server process, even if the server is on a different computer on the network. A debugging session is automatically started on the server process if necessary. Similarly, single stepping past the return address of code in a server object will automatically stop just past the corresponding call site in the client's process.</p>
<p>
In Microsoft Visual C++, selecting the <b>OLE RPC debugging</b> check box (on the <b>Tools</b> menu, select the <b>Options </b>submenu and choose the <b>Debug</b> property sheet) enables transparent remote debugging. It is not known at this time whether other debuggers support this infrastructure.</p>
<p>
You can also debug your Microsoft Transaction Server component DLL in Visual C++ by performing the following steps. Each of these steps is made either inside the MTS Explorer or inside of a Visual C++ session with your MTS DLL project.
<ol>
<li>
Shutdown server processes using the MTS Explorer. To do this, right-click <b>My</b> <b>Computer</b>, and select <b>Shutdown</b> <b>Server</b> <b>Process</b>.</li>
<li>
In your Visual C++ session, under <b>Project</b>,<b> Settings</b>, <b>Debug</b>, <b>General</b>, set the program arguments to the following string: <b>"/p: </b><i>PackageName</i><b>"</b>, for example:</li>
</ol>
<p>
<code>/p: "Sample Bank"</code></p>
<ol>
<li>
In the same property sheet, set the executable to the full path of the Mtx.exe process, for example: <b>"c:\MTx\MTx.exe"</b>.</li>
<li>
Set breakpoints in your component DLL, and you are ready to debug.</li>
<li>
Run the server process (in the <b>Build</b> menu, select <b>Start Debug</b> and click <b>Go</b>.)</li>
</ol>
<p>
The following information applies to in-process component DLLs that have their activation property set to <b>In the creator's process</b>.</p>
<p>
You can debug your in-process MTS component DLL in Visual C++ by performing the following steps. Each of these steps is made inside a Visual C++ session with your base process project. 
<ol>
<li>
Set the component DLL under <b>Build,</b> <b>Settings, Debug, Additional DLLs</b>.</li>
<li>
Now you are ready to step into or set breakpoints in your component DLL at will.</li>
</ol>
<p>
If you are using Visual Studio and Microsoft Foundation Classes (MFC) to debug, the TRACE macro can facilitate your debugging. The TRACE macro is an output debug function that traces debugging output to evaluate argument validity. The TRACE macro expressions specify a variable number of arguments that are used in exactly the same way that a variable number of arguments are used in the run-time function <b>printf</b>. The TRACE macro provides similar functionality to the <b>printf</b> function by sending a formatted string to a dump device such as a file or debug monitor. Like <b>printf</b> for C programs under MS-DOS, the TRACE macro is a convenient way to track the value of variables as your program executes. In the Debug environment, the TRACE macro output goes to afxDump. In the Release environment, the TRACE macro output does nothing.</p>
<p>
<b>Example:</b></p>
<pre><code>// example for TRACE
int i = 1;
char sz[] = "one";
TRACE( "Integer = %d, String = %s\n", i, sz );
// Output: 'Integer = 1, String = one'</code></pre>
<p>
The TRACE macro is available only in the debug version of MFC, but a similar function could be written for use without MFC. For more information on using the TRACE macro, see the "MFC Debugging Support" section in <i>Microsoft Visual C++ Programmer's Guide</i>.</p>
<p>
Note that you should avoid using standard ASSERT code in Visual C++. Instead, it is recommended that you write assert macros like a <b>MessageBox</b> using the MB_SERVICE_NOTIFICATION flag, and TRACE macro statements using the <b>OutputDebugString</b> function call.</p>
<p>&nbsp; </p></body>
</HTML>
