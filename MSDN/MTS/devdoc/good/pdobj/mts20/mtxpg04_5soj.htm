<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Transactions</title>
<link disabled rel=stylesheet href=../../../backsdk3.css>
<style type="text/css">
@import url(../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>

<h1><a name="ascontransactions"></a>Transactions</h1>
<p>
MTS simplifies the task of developing application <a href="vipdef01_1yih.htm#asdefcomponent">components</a> by allowing you to perform work with <a href="vipdef01_1yih.htm#asdeftransaction">transactions</a>. This protects applications from anomalies caused by concurrent updates or system failures.</p>
<p>
Transactions maintain the <a href="vipdef01_1yih.htm#asdefacid">ACID</a> properties:
<ul>
<li>
<i>Atomicity</i> ensures that all the updates completed under a specific transaction are committed and made durable, or that they get aborted and rolled back to their previous state.</li>
<li>
<i>Consistency</i> means that a transaction is a correct transformation of the system state, preserving the state invariants.</li>
<li>
<i>Isolation</i> protects concurrent transactions from seeing each other's partial and uncommitted results, which might create inconsistencies in the application state. <a href="vipdef01_1yih.htm#asdefresourcemanager">Resource managers</a> use transaction-based synchronization protocols to isolate the uncommitted work of active transactions.</li>
<li>
<i>Durability</i> means that committed updates to managed resources, such as a database record, survive failures, including communication failures, process failures, and server system failures. Transactional logging even allows you to recover the durable state after disk media failures.</li>
</ul>
<p>
The intermediate states of a transaction are not visible outside the transaction, and either all the work happens or none of it does. This allows you to develop application components as if each transaction executes sequentially and without regard to concurrency. This is a tremendous simplification for application developers.</p>
<p>
You can declare that a component is transactional, in which case MTS associates transactions with the component's <a href="vipdef01_1yih.htm#asdefmicrosofttransactionserverobject">objects</a>. When an object's method is executed, the services that resource managers and <a href="vipdef01_1yih.htm#asdefresourcedispenser">resource dispensers</a> perform on its behalf execute under a transaction. This can also include work that it performs for other MTS objects. Work from multiple objects can be composed into a single <a href="vipdef01_1yih.htm#asdefatomicity">atomic</a> transaction.</p>
<p>
<b>Multiple objects composed into a transaction</b></p>
<p>
<img src="images/vi0402.gif" border=0></p>
<p>
Without transactions, error recovery is extremely difficult, especially when multiple objects update multiple databases. The possible combinations of failure modes are too great even to consider. Transactions simplify error recovery. Resource managers automatically undo the transaction's work, and the application retries the entire business transaction.</p>
<p>
Transactions also provide a simple <a href="vipdef01_1yih.htm#asdefconcurrency">concurrency</a> model. Because a transaction's <a href="vipdef01_1yih.htm#asdefisolation">isolation</a> prevents one client's work from interfering with other clients, you can develop components as though only a single client executes at a time.</p>
<p>
Components Declare Transactional Requirements</p>
<p>
Every <a href="vipdef01_1yih.htm#asdefvipercomponent">MTS component</a> has a transaction attribute that is recorded in the MTS <a href="vipdef01_1yih.htm#asdefcatalog">catalog</a>. MTS uses this attribute during object creation to determine whether the object should be created to execute within a transaction, and whether a transaction is required or optional. For more information on transaction attributes, see <a href="mtxpg04_8ier.htm">Transaction Attributes</a>.</p>
<p>
Components that make updates to multiple transactional resources, such as database records, for example, can ensure that their objects are always created within a transaction. If the object is created from a <a href="vipdef01_1yih.htm#asdefcontext">context</a> that has a transaction, the new context inherits that transaction; otherwise, the system automatically initiates a transaction.</p>
<p>
Components that only perform a single transactional update can be declared to support, but not require, transactions. If the object is created from a context that has a transaction, the new context inherits that transaction. This allows the work of multiple objects to be composed into a single <a href="vipdef01_1yih.htm#asdefatomicity">atomic</a> transaction. If the object is created from a context that does not have a transaction, the object can rely on the resource manager to ensure that the single update is atomic.</p>
<p>
How Work Is Associated with a Transaction</p>
<p>
An object's associated <a href="vipdef01_1yih.htm#asdefcontext">context object</a> indicates whether the object is executing within a transaction and, if so, the identity of the transaction.</p>
<p>
<a href="vipdef01_1yih.htm#asdefresourcedispenser">Resource dispensers</a> can use the context object to provide transaction-based services to the MTS object. For example, when an object executing within a transaction allocates a database connection by using the <a href="vipdef01_1yih.htm#asdefodbcresourcedispenser">ODBC resource dispenser</a>, the connection is automatically enlisted on the transaction. All database updates using this connection become part of the transaction, and are either atomically committed or aborted. For more information, see <a href="mtxpg04_00ab.htm">Enlisting Resources in Transactions</a>.</p>
<p>
Stateful and Stateless Objects</p>
<p>
Like any <a href="vipdef01_1yih.htm#asdefcom">COM</a> object, <a href="vipdef01_1yih.htm#asdefmicrosofttransactionserverobject">MTS objects</a> can maintain internal state across multiple interactions with a <a href="vipdef01_1yih.htm#asdefclient">client</a>. Such an object is said to be <a href="vipdef01_1yih.htm#asdefstatefulinstance">stateful</a>.<i> </i>MTS objects can also be <a href="vipdef01_1yih.htm#asdefstatelessinstance">stateless</a><i>,</i> which means the object does not hold any intermediate state while waiting for the next call from a client.</p>
<p>
When a transaction is committed or aborted, all of the objects that are involved in the transaction are deactivated, causing them to lose any state they acquired during the course of the transaction. This helps ensure transaction <a href="vipdef01_1yih.htm#asdefisolation">isolation</a> and database <a href="vipdef01_1yih.htm#asdefconsistency">consistency</a>; it also frees server resources for use in other transactions.</p>
<p>
Completing a transaction enables MTS to deactivate an object and reclaim its resources, thus increasing the scalability of the application. Maintaining state on an object requires the object to remain activated, holding potentially valuable resources such as database connections. Stateless objects are more efficient and are thus recommended. For more information on object deactivation, see <a href="mtxpg04_5s37.htm">Deactivating Objects</a>.</p>
<p>
How Objects Can Participate in Transaction Outcome</p>
<p>
You can use methods implemented on the <b>IObjectContext</b> interface to enable an MTS object to participate in determining a transaction's outcome. The <b>SetComplete</b>, <b>SetAbort</b>, <b>DisableCommit</b>, and <b>EnableCommit</b> methods work in conjunction with the component's transaction attribute to allow one or more objects to be composed simply and safely within transactions.
<ul>
<li>
<b>SetComplete</b> indicates that the object has successfully completed its work for the transaction. The object is deactivated upon return from the method that first entered the <a href="vipdef01_1yih.htm#asdefcontext">context</a>.</li>
<li>
<b>SetAbort</b> indicates that the object's work can never be committed. The object is deactivated upon return from the method that first entered the context.</li>
<li>
<b>EnableCommit</b> indicates that the object's work is not necessarily done, but that its transactional updates can be committed in their current form.</li>
<li>
<b>DisableCommit</b> indicates that the object's transactional updates can not be committed in their current form.</li>
</ul>
<p>
Both<b> SetComplete</b> and <b>SetAbort </b>deactivate the object on return from the method. MTS reactivates the object on the next call that requires object execution.</p>
<p>
Objects that need to retain state across multiple calls from a client can protect themselves from having their work committed prematurely by the client. By calling <b>DisableCommit</b> before returning control to the client, the object can guarantee that its transaction cannot successfully be committed without the object doing its remaining work and calling <b>EnableCommit</b>.</p>
<p>
Client-Controlled vs. Automatic Transactions</p>
<p>
Transactions can either be controlled directly by the client, or automatically by the MTS run-time environment.</p>
<p>
<a href="vipdef01_1yih.htm#asdefclient">Clients</a> can have direct control over transactions by using a transaction context object. The client uses the <b>ITransactionContext</b> interface to create MTS objects that execute within the client's transactions, and to commit or abort the transactions.</p>
<p>
Transactions can <a href="vipdef01_1yih.htm#asdefautomatictransaction">automatically</a> be initiated by the MTS run-time environment to satisfy the component's transaction expectations. MTS components can be declared so that their objects always execute within a transaction, regardless of how the objects are created. This feature simplifies component development, because you do not need to write application logic to handle the special case where an object is created by a client not using transactions.</p>
<p>
This feature also reduces the burden on client applications. Clients do not need to initiate a transaction simply because the component that they are using requires it.</p>
<p>
MTS automatically initiates transactions as needed to satisfy a component's requirements. This event occurs, for example, when a client that is not using transactions creates an object in an MTS component that is declared to require transactions.</p>
<p>
MTS completes automatic transactions when the MTS object that triggered their creation has completed its work. This event occurs when returning from a method call on the object after it has called <b>SetComplete</b> or <b>SetAbort</b>. <b>SetComplete</b> causes the transaction to be committed; <b>SetAbort</b> causes it to be aborted.</p>
<p>
A transaction cannot be committed while any method is executing in an object that is participating in the transaction. The system behaves as if the object disables the commit for the duration of each method call.</p>
<h6>See Also</h6>
<p>
<a href="mtxpg07vb_7qr3.htm">Building Transactional Components</a>, <a href="mtxpg10vb_2tpv.htm">Multiple Transactions</a></p>
<p>&nbsp; </p></body>
</HTML>
