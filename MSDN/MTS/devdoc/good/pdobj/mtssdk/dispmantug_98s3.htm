<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Threading Issues</title>
<link disabled rel=stylesheet href=../../../backsdk3.css>
<style type="text/css">
@import url(../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>

<p>
<a name="asthreadingissues"></a>Threading Issues</p>
<p>
Calls into a resource dispenser may originate in one of the following threads:
<ul>
<li>
Apartment thread (STA)</li>
<li>
Free thread (MTA)</li>
<li>
Non-COM thread (application or DispMan's garbage-collector thread)</li>
</ul>
<p>
If a resource dispenser is not a COM object, then it must be able to handle calls arriving from any thread at any time. If a resource dispenser is a COM object, then the COM object should be registered with a <i>Threading Model of Both</i>. This allows STA or MTA threads to create and use the resource dispenser without a <i>thread switch</i>.</p>
<p>
If a resource dispenser creates and uses another COM object (for example, an <i>out-of-process</i> resource manager) then the resource dispenser may need to maintain multiple proxies to this other COM object, and ensure that calls to this other COM object are made using the appropriate proxy for the calling thread. When the resource dispenser creates this object, it <i>marshals</i> and saves the reference. Before calling the object again, it must <i>unmarshal</i> to create a proxy for the calling thread.</p>
<p>
It may be more efficient to cache these per-thread proxies by keeping a map from the ThreadId to a proxy pointer. This map will continue to expand as new threads are used in the process.</p>
<p>&nbsp; </p></body>
</HTML>
