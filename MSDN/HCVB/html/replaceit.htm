<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Replace It</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>

<font face="verdana,arial,helvetica" size="2"><h1><a name="replaceit"></a>Replace It</h1>
<BR>
Some of the RichTextBox properties just don’t make sense for XEditor. Others don’t work with a simple pass-through strategy. And still others can be improved. As an example, consider the FileName property.</p>
<BR>
The RichTextBox control has two ways to load the contents of a file into the control. You can set the FileName property or you can call the LoadFile method. The LoadFile method has a parameter that specifies whether to load the file in text or in RTF format, but design-time properties can’t have parameters. This leads to some confusion. You can’t control how a file is loaded if you use the FileName property, but you can’t load at design time with the LoadFile method.</p>
<BR>
My solution is that XEditor has both a design-time-only FileName property and a run-time-only LoadFile method, and that the FileName property actually uses the LoadFile method. I maintain my own internal variable for the complete file path and never use the FileName property of the delegated RichTextBox control. In addition, I provide a read-only FilePath property that returns the full path of the file. (FileName returns only the base and extension.) In other words, I provide most of the same functionality, but with a different architecture. Let’s take a look.</p>
<BR>
I start with a private <i>sFilePath </i>variable. It contains either an empty string, if the contents of the control did not come from a file, or the full path of the current file. Any code that can load a new file must ensure that this variable is always valid. Here’s how the FileName and FilePath properties deal with <i>sFilePath</i>:</p>
<pre><code>' Read-only, run-time only<BR>Property Get FilePath() As String<BR>    FileName = sFilePath<BR>End Property<BR><BR>' Run time or design time<BR>Property Get FileName() As String<BR>    If sFilePath &lt;&gt; sEmpty Then FileName = GetFileBaseExt(sFilePath)<BR>End Property<BR><BR>' Design-time only (use LoadFile at run time)<BR>Property Let FileName(sFileNameA As String)<BR>    If Ambient.UserMode Then ErrRaise eeSetNotSupportedAtRuntime<BR>    ' Can't pass through design-time errors<BR>    On Error GoTo FailFileName<BR>    If sFileNameA = sEmpty Then<BR>        ' Empty text only if it comes from a file<BR>        If sFilePath &lt;&gt; sEmpty Then Text = sEmpty<BR>        sFilePath = sEmpty<BR>    Else<BR>        sFileNameA = GetFullPath(sFileNameA)<BR>        LoadFile sFileNameA<BR>        sFilePath = sFileNameA<BR>    End If<BR>    PropertyChanged &quot;FileName&quot;<BR>    Exit Property<BR>FailFileName:<BR>    ' Could empty FileName and Text, but I choose to ignore them<BR>End Property</code></pre>
<BR>
The Property Get procedures simply return the variable in the appropriate format. First, the Property Let uses the Ambient.UserMode property to prevent run-time changes. Then it deals with the three possibilities: an empty string, a valid filename, and an invalid filename. Notice that actual loading of files is deferred to the LoadFile method shown below:</p>
<pre><code>‘ Run-time only (use FileName at design time)<BR>Sub LoadFile(sFileNameA As String, _<BR>             Optional ordTextModeA As ELoadSave = elsDefault)<BR>    If sFileNameA = sEmpty Then Exit Sub<BR>    BugAssert ordTextModeA &gt;= elsDefault And ordTextModeA &lt;= elstext<BR>    If ordTextModeA = elsDefault Then<BR>        ordTextModeA = IIf(TextMode, elstext, elsrtf)<BR>    End If<BR>    If TextMode Then Set Font = fontDefault<BR>    ‘ Don’t reload clean file<BR>    sFileNameA = GetFullPath(sFileNameA)<BR>    If sFileNameA = sFilePath And DirtyBit = False Then Exit Sub<BR>    ‘ Use RichTextBox method (raise unhandled errors to caller)<BR>    txt.LoadFile sFileNameA, ordTextModeA<BR>    sFilePath = sFileNameA<BR>    DirtyBit = False<BR>End Sub</code></pre>
<BR>
This method uses the LoadFile property of the delegated RichTextBox control. The code uses the TextMode and DirtyBit properties, which I’ll discuss shortly. Unlike the FileName property, this function lets unhandled errors pass through to the caller (which might be the FileName property). Methods are always <BR>run-time-only, but this one can be called by a design-time-only property. The SaveFile method works much the same as LoadFile. XEditor has other properties that can change the filename, but they all work by calling LoadFile or SaveFile.</p>
</font></BODY>
</HTML>
