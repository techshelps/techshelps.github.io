<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>The top window list</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>

<font face="verdana,arial,helvetica" size="2"><h1><a name="thetopwindowlist"></a>The top window list</h1>
<BR>
The Top Windows list box in WinWatch lists each top-level window. Top-level windows are what you probably think of as Windows programs. In fact, the top-level window list in WinWatch usually will show the same programs as the taskbar in Windows NT 4 and Windows 95. My bet is that Windows refreshes the taskbar with code very similar to this:</p>
<pre><code>Private Sub RefreshTopWinList()<BR>    Dim sTitle As String, hWnd As Long<BR><BR>    SetRedraw lstTopWin, False<BR>    lstTopWin.Clear<BR>    ' Get first top-level window<BR>    hWnd = GetWindow(GetDesktopWindow(), GW_CHILD)<BR>    BugAssert hWnd &lt;&gt; hNull<BR>    ' Iterate through remaining windows<BR>    Do While hWnd &lt;&gt; hNull<BR>        sTitle = WindowTextLineFromWnd(hWnd)<BR>        ' Determine whether to display titled, visible, and unowned<BR>        If IsVisibleTopWnd(hWnd, chkBlank, _<BR>                           chkInvisible, chkOwned) Then<BR>            lstTopWin.AddItem sTitle<BR>            lstTopWin.ItemData(lstTopWin.NewIndex) = hWnd<BR>        End If<BR>        ' Get next child<BR>        hWnd = GetWindow(hWnd, GW_HWNDNEXT)<BR>    Loop<BR>    SetRedraw lstTopWin, True<BR>End Sub</code></pre>
<BR>
The only thing the taskbar has that this code doesn’t provide is small icons, and you’ll learn how to add them in Chapter 8.</p>
<BR>
This iteration loop works a lot like the loops for Process32First and Module32&shy;First, except that you pass the constants GW_HWNDCHILD and GW_HWNDNEXT to GetWindow. You could also say that it’s like IterateChildWindows (from <BR>“Iterating the hard way” earlier in this chapter) without the recursion. You could do the same thing with EnumWindows and your own EnumWindowsProc function, but in this case I think GetWindow is simpler. Either way, GetWindow and EnumWindows are standard Win32 functions, so there’s no need to jump through portability hoops as we did with processes and modules.</p>
<BR>
For each found window, you check to ensure that the window meets certain criteria—that it has a title, is visible, and is not owned by another window. Windows that meet all the criteria (as determined by IsVisibleTopWnd) have their titles and window handles placed in the list box. Here’s how the decision is made:</p>
<pre><code>Function IsVisibleTopWnd(hWnd As Long, _<BR>                Optional IgnoreEmpty As Boolean = False, _<BR>                Optional IgnoreVisible As Boolean = False, _<BR>                Optional IgnoreOwned As Boolean = False) _<BR>                As Boolean<BR>    If IgnoreEmpty Or WindowTextFromWnd(hWnd) &lt;&gt; sEmpty Then<BR>        If IgnoreVisible Or IsWindowVisible(hWnd) Then<BR>            If IgnoreOwned Or GetWindow(hWnd, GW_OWNER) = hNull Then<BR>                IsVisibleTopWnd = True<BR>            End If<BR>        End If<BR>    End If<BR>End Function</code></pre>
<BR>
The code to fill the top window list uses the values of the Show check boxes to determine which windows to display:</p>
<pre><code>If IsVisibleTopWnd(hWnd, chkBlank, _<BR>                   chkInvisible, chkOwned) Then<BR>    lstTopWin.AddItem sTitle<BR>    lstTopWin.ItemData(lstTopWin.NewIndex) = hWnd<BR>End If</code></pre>
<BR>
If you experiment by checking the boxes, one at a time, you’ll learn some interesting facts about Windows. For example, if you check the Show Invisible box, you’ll learn that Windows maintains a lot of invisible windows behind the scenes. There are also a bunch of windows with blank titles. If you check the Show Owned box, you’ll see lots of modeless dialog boxes. For example, if Visual Basic is running, you’ll see that all your code windows are actually top-level windows owned by the Visual Basic window.</p>
<BR>
You might also want to check out RefreshAllLists. This procedure calls Refresh&shy;TopWinList, RefreshProcessList, and RefreshFullWinList (more on that later) to update all the window information on the display. It is called when you load WinWatch, when you click the Refresh button, when you change any of the Show check boxes, or when you select a window that no longer exists.</p>
<BR>
Now that we’ve covered top-level windows, modules, and processes, we are ready to talk a little more about handles for windows, modules, and processes.</p>
</font></BODY>
</HTML>
