<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Typeless Strings</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>

<font face="verdana,arial,helvetica" size="2"><h1><a name="typelessstrings"></a>Typeless Strings</h1>
<BR>
Now that you understand Unicode and pointers, you have the knowledge to understand how to hack strings and string pointers with CopyMemory. This is a little bit tricky because the type library version of CopyMemory doesn’t work exactly the same as the Declare version. At first I thought this was a bug or at least a limitation of type libraries. After studying the issue, I’m inclined to consider it a bug or at least a mistake in how the Declare statement handles As Any.</p>
<BR>
Let’s assume that we define an aliased version of CopyMemory with the following Declare statement:</p>
<pre><code>Declare Sub CopyMemoryD Lib “KERNEL32” Alias “RtlMoveMemory” ( _<BR>    lpvDest As Any, lpvSource As Any, ByVal cbCopy As Long)</code></pre>
<BR>
We’ll further assume that the type library defines the same thing with its own peculiar syntax but calls its version CopyMemoryT. You can look in WIN&shy;BASE.IDL on the companion CD if you’re interested in the syntax.</p>
<pre><code>sSrc = “This is text&quot;<BR>sDstD = “************&quot;<BR>sDstT = “************&quot;<BR>CopyMemoryD ByVal sDstD, ByVal sSrc, Len(sSrc)<BR>CopyMemoryT ByVal sDstT, ByVal sSrc, Len(sSrc)<BR>Debug.Print sDstD<BR>Debug.Print sDstT</code></pre>
<BR>
The output looks like this:</p>
<pre><code>This is text<BR>This i******</code></pre>
<BR>
What happened here is that the Declare version, because it is written in Basic, noticed that the arguments being passed to it were Strings. It did the normal Unicode conversion, creating two temporary ANSI buffers. It copied the ANSI source to the ANSI destination, which was then converted back to Unicode. The type library version, because it is written in the language-independent IDL language, had no idea of the type being passed to it. Instead of creating ANSI buffers, it just copied the internal Unicode source to the Unicode destination. But the string length passed to it was the character count, not the byte count. Only half the characters got copied. The solution is to use LenB rather than Len so that you’ll pass a byte count.</p>
<pre><code>CopyMemoryT ByVal sDstT, ByVal sSrc, LenB(sSrc)</code></pre>
<BR>
So far, so good. But one of the reasons to use a CopyMemory with As Any parameters is so that you can also pass pointers. Let’s say some API function (GetEnvironmentStrings, to name one) returns a pointer as a Long. You might want to call CopyMemory like this:</p>
<pre><code>CopyMemoryD ByVal sDstD, ByVal pSrc, Len(sDstD)<BR>CopyMemoryT ByVal sDstT, ByVal pSrc, LenB(sDstT)</code></pre>
<BR>
What’s going to happen here depends on whether <i>pSrc </i>is a pointer to a Unicode string or an ANSI string. Let’s assume that it’s a pointer to ANSI characters that you got from an ANSI API function. In the Declare version, you’ll copy from the ANSI pointer to the temporary ANSI buffer, and all will be fine when Visual Basic converts that temporary buffer back to Unicode. In the type library version, you’ll copy from the ANSI pointer to the Unicode string. The result will be a string of question marks that you’ll have to convert with StrConv.</p>
<BR>
If, on the other hand, <i>pSrc </i>points to a Unicode string (from a Unicode or COM API function or from StrPtr), the Declare version CopyMemoryD will copy both the characters and the zero bytes of the Unicode string into the temporary ANSI buffer, which will then be converted back to an unintelligible Basic string. <BR>The type library CopyMemoryT will copy from Unicode to Unicode with no <BR>conversion.</p>
<BR>
If that description leaves you scratching your head, don’t worry about it. You can bypass all this trouble by using the CopyMemory aliases in the type library: Copy&shy;&shy;MemoryStr, CopyMemoryToStr, and CopyMemoryStrToStr. Call them like this:</p>
<pre><code>CopyMemory ByVal pDst, ByVal pSrc, cDst<BR>CopyMemoryStr ByVal pDst, sSrc, cDst<BR>CopyMemoryToStr sDst, ByVal pSrc, cDst<BR>CopyMemoryStrToStr sDst, sSrc, cDst</code></pre>
<BR>
These will do the right thing whether you’re using WIN.TLB or WINU.TLB.</p>
</font></BODY>
</HTML>
