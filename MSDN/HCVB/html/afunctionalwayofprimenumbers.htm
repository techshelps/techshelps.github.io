<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>A Functional Way of Prime Numbers</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>

<font face="verdana,arial,helvetica" size="2"><h1><a name="afunctionalwayofprimenumbers"></a>A Functional Way of Prime Numbers</h1>
<BR>
The first task in converting existing code to a component is to change the model from functional to object-oriented. Of course, if you’re starting from scratch, you can start out object-oriented but you still need to put yourself in an object state of mind. Most of us still program in functional mode. Here’s how I changed my way of thinking about the sieve of Eratosthenes.</p>
<BR>
First look at the sieve in functional form. The algorithm shown here is pretty much the same as the one presented in <i>Byte</i> magazine in 1983 and used by hundreds of reviewers in many languages ever since. Variable names have been changed to protect the guilty. The function interface has been changed to accept an array that will be filled with the prime numbers the algorithm finds. The only logical change in the algorithm is that nonprime numbers are marked with True rather than False to take advantage of Visual Basic’s automatic initialization to 0.</p>
<pre><code>Function Sieve(ai() As Integer) As Integer<BR>    Dim iLast As Integer, cPrime As Integer, iCur As Integer, i As Integer<BR>    Dim af() As Boolean<BR>    ‘ Parameter should have dynamic array for maximum number of primes<BR>    If LBound(ai) &lt;&gt; 0 Then Exit Function<BR>    iLast = UBound(ai)<BR>    ‘ Create array large enough for maximum prime (initializing to zero)<BR>    ReDim af(0 To iLast + 1) As Boolean<BR>    For iCur = 2 To iLast<BR>        ‘ Anything still zero is a prime<BR>        If Not af(iCur) Then<BR>            ‘ Cancel its multiples because they can’t be prime<BR>            For i = iCur + iCur To iLast Step iCur<BR>                af(i) = True<BR>            Next<BR>            ‘ Count this prime<BR>            ai(cPrime) = iCur<BR>            cPrime = cPrime + 1<BR>        End If<BR>    Next<BR>    ‘ Resize array to the number of primes found<BR>    ReDim Preserve ai(0 To cPrime) As Integer<BR>    Sieve = cPrime<BR>End Function</code></pre>
<BR>
The Select Case block of the client program where the function version is called looks like this:</p>
<pre><code>Case estBasicLocalFunction<BR>    ‘ Get all at once<BR>    ms = timeGetTime()<BR>    For i = 1 To cIter<BR>        ReDim ai(0 To cPrimeMax)<BR>        cPrime = Sieve(ai())<BR>        If fDisplay Then<BR>            lstOutput.Clear<BR>            For iPrime = 0 To cPrime - 1<BR>                lstOutput.AddItem ai(iPrime)<BR>                lstOutput.TopIndex = lstOutput.ListCount - 1<BR>                lstOutput.Refresh<BR>            Next<BR>        End If<BR>    Next<BR>    txtTime.Text = timeGetTime() - ms<BR>    txtPrimes.Text = cPrime</code></pre>
<BR>
Our job is to convert the local sieve function into a local CSieve class. After that, we can worry about converting to other kinds of COM components.</p>
</font></BODY>
</HTML>
