<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Implementing multiple interfaces</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>

<font face="verdana,arial,helvetica" size="2"><h1><a name="implementingmultipleinterfaces"></a>Implementing multiple interfaces</h1>
<BR>
The CBugFilter class presented earlier implemented the IFilter interface. You could access the IFilter interface or the default _CBugFilter interface through separate object variables. Think about this for a moment. If you can get two interfaces through polymorphism, why not three interfaces? Why not 12? Why not 137 interfaces?</p>
<BR>
No problem.</p>
<BR>
Consider the CJumpHop class. It implements two interfaces: IHop and IJump. Here’s IHop:</p>
<pre><code>‘ IHop interface<BR>Function Hop() As String<BR>End Function</code></pre>
<BR>
You can probably guess the IJump interface:</p>
<pre><code>‘ IJump interface<BR>Function Jump() As String<BR>End Function</code></pre>
<BR>
The CJumpHop class implements both of these interfaces:</p>
<pre><code>‘ CJumpHop class<BR>Implements IJump<BR>Implements IHop<BR><BR>Private Function IHop_Hop() As String<BR>    IHop_Hop = “Hop”<BR>End Function<BR><BR>Private Function IJump_Jump() As String<BR>    IJump_Jump = “Jump”<BR>End Function</code></pre>
<BR>
You can access the implementation of either interface through an appropriate object variable:</p>
<pre><code>Dim h As IHop, j As IJump<BR>Set h = New CJumpHop<BR>Debug.Print h.Hop<BR>Set j = h<BR>Debug.Print j.Jump</code></pre>
<BR>
You can access the Hop method polymorphically through the <i>h </i>object variable or you can access the Jump method polymorphically through the <i>j </i>object variable. Notice also that you can get at the IJump interface through an IHop object variable (<i>Set j = h</i>).</p>
<BR>
You could extend the CJumpHop class to have members of its own:</p>
<pre><code>‘ Additional methods belonging to CJumpHop<BR>Function Skip() As String<BR>    Skip = “Skip”<BR>End Function<BR><BR>Function Hop() As String<BR>    Hop = IHop_Hop<BR>End Function<BR><BR>Function Jump() As String<BR>    Jump = IJump_Jump<BR>End Function</code></pre>
<BR>
These methods aren’t polymorphic. They belong directly to the class and can be used like this:</p>
<pre><code>Dim j As New CJumpHop<BR>    Debug.Print jh.Skip<BR>    Debug.Print jh.Hop<BR>    Debug.Print jh.Jump</code></pre>
<BR>
Notice that the Hop and Jump methods simply delegate to the polymorphic versions so that the CJumpHop class can have non-polymorphic versions without doing any work. The Hop method and the IHop_Hop method are separate methods accessible through different parts of the object, but they share the same implementation code.</p>
<BR>
This probably looks like a whole lot of nothing, and with interfaces this simple, it is. But imagine that you have a collection of graphical objects—stars, polyhedrons, ovals, and so on. There’s a separate class for each kind of object, but the classes all implement the same interfaces. The IDrawable interface has methods and properties for setting the position and color of the shape object, and for drawing it. The IScaleable interface has methods and properties for scaling the objects to different sizes. The IMangleable interface has methods and properties for twisting and skewing the object. Now let’s say you have a collection of these objects, and you want to draw the ones that are scaleable. You might do it something like this:</p>
<pre><code>Dim scaleable As IScaleable, drawable As IDrawable, shape As CShape<BR>    On Error Resume Next<BR>For Each shape In shapes<BR>    Set scaleable = shape<BR>    ‘ An error indicates that the shape isn’t scaleable<BR>    If Err = 0 Then        <BR>        scaleable.Scale Rnd<BR>        Set drawable = shape<BR>        drawable.Color = QBColor(GetRandom(1, 15))<BR>        drawable.X = GetRandom(0, pbShapes.Width)<BR>        drawable.Y = GetRandom(0, pbShapes.Height)<BR>        drawable.Draw pbShapes<BR>    End If<BR>Next<BR>    On Error Goto 0</code></pre>
<BR>
Like most air code, this snippet is probably full of bugs and errors, but I’m sure you could make it work. In fact, there’s an example that does something very similar with multiple interfaces on the Visual Basic CD.</p>
</font></BODY>
</HTML>
