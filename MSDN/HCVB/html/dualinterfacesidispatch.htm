<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Dual Interfaces and IDispatch</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>

<font face="verdana,arial,helvetica" size="2"><h1><a name="dualinterfacesidispatch"></a>Dual Interfaces and IDispatch</h1>
<BR>
When you call a method or property, it will work in different ways, depending on a factor that is mostly beyond your control. Some OLE classes have IDispatch interfaces, some have COM (sometimes called vtable) interfaces, and some have both (dual interfaces). From Visual Basic’s viewpoint, IDispatch represents evil and COM represents virtue. Dual interfaces represent a pact with the devil to make do in a world of sin, but you should never need the darker IDispatch side.</p>
<BR>
This doesn’t mean IDispatch is evil in general. You still need it for VBScript and other environments that always do late binding. Some authorities will claim that there are realistic situations where you don’t know a server’s name until run time and therefore you will need late binding. For example, you might have two polymorphic servers that provide the exact same services in two different ways. You have to ask your user (or perhaps ask an external database or a Web site) whether to use the UglyFast server or the PrettySlow server. These might be completely different servers running on different remote machines. You could write code like this:</p>
<pre><code>If fFastAtAnyPrice Then<BR>    Set obj = CreateObject(“UglyFast.CJumpInTheLake”)<BR>Else<BR>    Set obj = CreateObject(“PrettySlow.CPlungeIntoThePool”)<BR>End If</code></pre>
<BR>
I have yet to see a practical example of this situation under Visual Basic, but I’m told that there are some. Even in cases where you need CreateObject, it might still be possible to get early binding with the new Implements statement.</p>
<BR>
The IDispatch interface was designed for late-bound objects. It works (and works much faster) with early-bound objects, but it’s less flexible. It still filters all arguments through Variants and it still does a certain amount of parsing and general thrashing to find the addresses and specify the arguments of methods and properties. Some of the information it finds is already known by the type library.</p>
<BR>
The COM interface, by contrast, is simple and direct. It consists of a simple table of addresses for each of the methods and properties. When you call a method, Visual Basic looks up its address and calls it. There are only two steps, and they translate into very few assembly language instructions. The table that makes this possible is called a <i>vtable,</i> and it has the exact same format as the vtable that makes virtual functions possible in C++. The tradeoff is information. If you have information, you construct a vtable and make fast calls through it. If you don’t </p>
<BR>
<b>Problem:</b>  If you choose a class solution over an equivalent functional solution, what performance penalty, if any, must you accept? There’s no easy one-to-one comparison, but the following information might give you a clue about the relative performance of methods, procedures, properties, and variables. As a bonus, you get a comparison of creating objects with New in the declaration versus using Set with New.</p>
<table>
<tr valign=top>
<td>
<b>Problem</b></td>
<td>
<b>P-Code</b></td>
<td>
<b>Native Code</b></td>
</tr>
<tr valign=top>
<td>
Call method function on object</td>
<td>
0.0476 sec</td>
<td>
0.0090 sec</td>
</tr>
<tr valign=top>
<td>
Call method function on New object</td>
<td>
0.0466 sec</td>
<td>
0.0096 sec</td>
</tr>
<tr valign=top>
<td>
Call method function on late-bound object</td>
<td>
1.0185 sec</td>
<td>
0.7828 sec</td>
</tr>
<tr valign=top>
<td>
Call private function</td>
<td>
0.0438 sec</td>
<td>
0.0071 sec</td>
</tr>
<tr valign=top>
<td>
Pass variable to method sub on object</td>
<td>
0.0268 sec</td>
<td>
0.0055 sec</td>
</tr>
<tr valign=top>
<td>
Pass variable to method sub on New object</td>
<td>
0.0287 sec</td>
<td>
0.0071 sec</td>
</tr>
<tr valign=top>
<td>
Pass variable to method sub on late-bound object</td>
<td>
0.8585 sec</td>
<td>
0.6980 sec</td>
</tr>
<tr valign=top>
<td>
Pass variable to private sub</td>
<td>
0.0384 sec</td>
<td>
0.0088 sec</td>
</tr>
<tr valign=top>
<td>
Assign through Property Let on object</td>
<td>
0.0232 sec</td>
<td>
0.0094 sec</td>
</tr>
<tr valign=top>
<td>
Assign through Property Let on New object</td>
<td>
0.0252 sec</td>
<td>
0.0057 sec</td>
</tr>
<tr valign=top>
<td>
Assign through Property Let on late-bound object</td>
<td>
0.7661 sec</td>
<td>
0.6229 sec</td>
</tr>
<tr valign=top>
<td>
Assign through private Property Let</td>
<td>
0.0176 sec</td>
<td>
0.0014 sec</td>
</tr>
<tr valign=top>
<td>
Assign from Property Get on object</td>
<td>
0.0327 sec</td>
<td>
0.0069 sec</td>
</tr>
<tr valign=top>
<td>
Assign from Property Get on New object</td>
<td>
0.0301 sec</td>
<td>
0.0068 sec</td>
</tr>
<tr valign=top>
<td>
Assign from Property Get on late-bound object</td>
<td>
0.8045 sec</td>
<td>
0.6790 sec</td>
</tr>
<tr valign=top>
<td>
Assign from private Property Get</td>
<td>
0.0172 sec</td>
<td>
0.0005 sec</td>
</tr>
<tr valign=top>
<td>
Assign to public property on object</td>
<td>
0.0068 sec</td>
<td>
0.0020 sec</td>
</tr>
<tr valign=top>
<td>
Assign to public property on New object</td>
<td>
0.0058 sec</td>
<td>
0.0019 sec</td>
</tr>
<tr valign=top>
<td>
Assign to public property on late-bound object</td>
<td>
0.8582 sec</td>
<td>
0.7918 sec</td>
</tr>
<tr valign=top>
<td>
Assign to private variable</td>
<td>
0.0032 sec</td>
<td>
0.0003 sec</td>
</tr>
<tr valign=top>
<td>
Assign from public property on object</td>
<td>
0.0079 sec</td>
<td>
0.0018 sec</td>
</tr>
<tr valign=top>
<td>
Assign from public property on New object</td>
<td>
0.0090 sec</td>
<td>
0.0016 sec</td>
</tr>
<tr valign=top>
<td>
Assign from public property on late-bound object</td>
<td>
0.9445 sec</td>
<td>
0.8459 sec</td>
</tr>
<tr valign=top>
<td>
Assign from private variable</td>
<td>
0.0035 sec</td>
<td>
0.0004 sec</td>
</tr>
</table><BR>
<BR>
<b>Conclusion:</b>  Hard to say. Using classes and objects definitely has a performance cost. Classes that wrap very simple operations might cost more than they are worth, but for most classes, the overhead is tiny compared to the total cost of what the class actually does.</p>
<BR>
have information, you look up that information the hard way and make slower calls. If you have the information but don’t use it, you’re wasting your time.</p>
<BR>
So if COM servers with dual interfaces are better than those with IDispatch interfaces, where do you find dual interfaces? The answer is: almost everywhere. For example, you’ll always get them from Visual Basic. In fact, there are only two development tools I know of that create dispatch-only ActiveX components. Unfortunately, one of them is probably the most common tool for creating components: the Microsoft Foundation Class (MFC) library. The other is the Delphi programming environment (version 2). Both Microsoft and Borland are moving to new tools that create dual interfaces.</p>
<BR>
Lest you think that MFC creates slow, fat COM objects, let me clarify one thing. What has the greatest effect on the speed of any component is its slowest part. If COM calls through IDispatch are the slowest part of a component’s operation, then you can blame the provider of that component. Generally, the bottleneck for controls is window creation and management. The bottleneck for COM EXE servers is transfer across process boundaries through a process called marshaling. You’ll see performance examples demonstrating this in Chapter 10. The Performance sidebar in Chapter 10 illustrates that a Visual Basic DLL component compiled to native code is significantly faster than an equivalent C++ MFC component. Dual interfaces, not the programming language or the compiler, make the difference.</p>
</font></BODY>
</HTML>
