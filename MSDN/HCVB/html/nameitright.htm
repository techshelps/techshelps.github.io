<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Name It Right</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>

<font face="verdana,arial,helvetica" size="2"><h1><a name="nameitright"></a>Name It Right</h1>
<BR>
I flamed about the hated XEditor1 convention in Chapter 1. Well, the buck stops here. The only way I’m ever going to succeed in my campaign against evil is to stop making it so damn easy. If you want to name an instance of my control XEditor1, you’re going to have to type it in yourself. I define the preferred prefix name as <i>edit</i>. For the first XEditor control you place on a form, I give you the name <i>edit</i>. Normally, you’ll need only one XEditor per project, but if you’re going to have more than one, you’ll probably want to rename it to <i>editRight</i>, <i>editTop</i>, or something similar. In the unlikely case that you fail to rename your first XEditor and then request a second, its name will come out as <i>edit1</i>.</p>
<BR>
The code that makes this work starts when the control is created in the User&shy;Control_InitProperties event:</p>
<pre><code>Extender.Name = UniqueControlName(&quot;edit&quot;, Extender)</code></pre>
<BR>
The UniqueControlName function creates a unique name for the current instance, based on the given prefix. The code resides in CTLTOOL.BAS, a module for tools that are related to creating controls:</p>
<pre><code>Function UniqueControlName(sPrefix As String, Ext As Object) As String<BR>    Dim v As Variant, s As String, c As Long, fFound As Boolean<BR>    On Error GoTo UniqueControlNameFail<BR>    s = sPrefix<BR>    Do<BR>        fFound = False<BR>        ' Search for a control with the proposed prefix name<BR>        For Each v In Ext.Container.Controls<BR>            If v.Name = s Then<BR>                ' Nope, try another name<BR>                fFound = True<BR>                c = c + 1<BR>                s = sPrefix &amp; c<BR>                Exit For<BR>            End If<BR>        Next<BR>    Loop Until fFound = False<BR>    ' Use this name<BR>    UniqueControlName = s<BR>    Exit Function<BR><BR>UniqueControlNameFail:<BR>    ' Failure probably means no Extender.Container.Controls<BR>    UniqueControlName = sPrefix<BR>End Function</code></pre>
<BR>
Visual Basic designers would probably be horrified at the use I’ve put to the Extender object. This isn’t what it was designed for. But I could have done worse.</p>
<BR>
You can get around my naming convention enforcement by copying an existing XEditor control and pasting it onto the form. Visual Basic will ask if you want a control array, and if you say no, it will give you the hated name XEditor1. I tried to intercept and rename the control in this situation and, after much experimenting, I found a way. But my fix had a side effect. If a user deliberately typed <i>XEditor1 </i>as the instance name, I would change the name to <i>edit1 </i>the next time the form was loaded. Even I am not rude enough to leave code like that in my control.</p>
</font></BODY>
</HTML>
