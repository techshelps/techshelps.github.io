<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Collections 101-Data Storage</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>

<font face="verdana,arial,helvetica" size="2"><h1><a name="collections101datastorage"></a>Collections 101-Data Storage</h1>
<BR>
A Collection is what some computer science books refer to as a <i>dictionary,</i> that is, a table of items in which you can look up an entry by using a key. Collections start out simple, but they can easily become complicated. Let’s briefly &shy;run through the features of Collections by looking at a simple one:</p>
<pre><code>Dim animals As New Collection</code></pre>
<BR>
Here’s the code to load a Collection with strings—which are actually converted to Variants because that’s the only data type Collections recognize:</p>
<pre><code>‘ Create collection<BR>animals.Add “Lion”<BR>animals.Add “Tiger”<BR>animals.Add “Bear”<BR>animals.Add “Shrew”, , 1<BR>animals.Add “Weasel”, , , 1</code></pre>
<BR>
The first three Add methods put <i>Lion</i>, <i>Tiger</i>,<i> </i>and <i>Bear</i> in the Collection in that order, as items 1, 2, and 3. The Collection class is one-based, and new items go at the end unless you specify otherwise. The fourth Add method uses the third parameter to specify that the new item will precede existing item 1. The last Add method uses the fourth parameter to specify that the new item will follow existing item 1.</p>
<BR>
Once you have a Collection, you’ll want to access its members. You can use indexes, just as you do for an array:</p>
<pre><code>Debug.Print animals(3) &amp; “ “ &amp; animals.Item(3)</code></pre>
<BR>
Notice that <i>animals(3) </i>is a shortcut for <i>animals.Item(3)</i>. Item is the default member and can be omitted.</p>
<BR>
You might also want to replace one item of a Collection with another.</p>
<pre><code>animals(2) = “Wolverine”</code></pre>
<BR>
If you think this should work with a simple assignment, think again. Visual Basic could have made this work. (It was requested.) Look back at the implementation of Item in the CVector or CList class to see how easy it would have been to add assignment to the Collection class. All you have to do is implement the Item property with Get, Let, and Set procedures. Instead, they implemented Item as a function, and of course you can’t Let or Set a function. As a result, the only way to replace an item is to delete the old item and insert a new one in its place:</p>
<pre><code>animals.Add “Wolverine”, , 2<BR>animals.Remove 3</code></pre>
<BR>
Here’s the standard way to iterate through a Collection:</p>
<pre><code>Dim vAnimal As Variant<BR>For Each vAnimal In animals<BR>    s = s &amp; Space$(4) &amp; vAnimal &amp; sCrLf<BR>    Debug.Print vAnimal<BR>Next</code></pre>
<BR>
In the previous edition of this book, I suggested replacing items with the following code: </p>
<pre><code>animals.Remove 2<BR>animals.Add “Wolverine”, , 2</code></pre>
<BR>
Hardcore reader Ralf Kretzschmar pointed out that this syntax fails if you’re trying to replace the last item. Here’s a procedure that always gets the syntax right regardless of whether you specify the item to be replaced by index or by key:</p>
<pre><code>Sub CollectionReplace(n As Collection, vIndex As Variant, _<BR>                      vVal As Variant)<BR>    If VarType(vIndex) = vbString Then<BR>        n.Remove vIndex<BR>        n.Add vVal, vIndex<BR>    Else<BR>        n.Add vVal, , vIndex<BR>        n.Remove vIndex + 1<BR>    End If<BR>End Sub</code></pre>
<BR>
Of course, you can still iterate through a Collection by index:</p>
<pre><code>Dim i As Integer<BR>For i = 1 To animals.Count<BR>    s = s &amp; Space$(4) &amp; animals(i) &amp; sCrLf<BR>    Debug.Print animals(i)<BR>Next</code></pre>
<BR>
This technique is risky, however. It’s easy to confuse the indexing system because the Collection class is one-based, while many of the predefined Visual Basic collections (Forms and Controls) are zero-based for compatibility with previous versions. Furthermore, as you might have discovered with ListBox controls, you can’t delete members from or add members to a collection while iterating because this changes the index and the count, which often causes the loop to fail. Yet this is one of the most frequent reasons to iterate. You can sometimes get around the limitation by iterating backward, but For Each is a more reliable looping technique.</p>
<BR>
If you want to remove everything from a Collection, you have to do it in a loop:</p>
<pre><code>Do While animals.Count<BR>    animals.Remove 1<BR>Loop</code></pre>
<BR>
It would be handy if the Collection class had a Clear method like the CList class does, but no such luck. You can also clear a Collection by setting it to Nothing, but then you’ll have to Set it to a New Collection before using it again.</p>
</font></BODY>
</HTML>
