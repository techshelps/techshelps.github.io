<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Using Data Resources</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>

<font face="verdana,arial,helvetica" size="2"><h1><a name="usingdataresources"></a>Using Data Resources</h1>
<BR>
Let’s start with raw binary data—if you know how that works, you can figure out what to do with other kinds of data. You can cram any binary data you want into a resource file. Use the predefined RT_RCDATA type, or invent your own resource type name. Of course, WinWatch won’t know how to handle unknown data types; the best it can do is dump the binary data in hex format.</p>
<BR>
The goal is to turn a resource into an array of bytes, which is the approved way for Visual Basic to handle binary data. You can also handle data as strings, but that’s politically incorrect, particularly in a chapter such as this, which deals with multiple languages. Here’s how ShowData reads and dumps generic data:</p>
<pre><code>Sub ShowData(ByVal hMod As Long, sData As String, _<BR>             Optional sDataType As String = “RCDATA”)<BR>    <BR>    Dim hRes As Long, hmemRes As Long, cRes As Long<BR>    Dim pRes As Long, abRes() As Byte<BR>    If sDataType = “RCDATA” Then<BR>        hRes = FindResourceStrId(hMod, sData, RT_RCDATA)<BR>    Else<BR>        hRes = FindResourceStrStr(hMod, sData, sDataType)<BR>    End If<BR>    If hRes = hNull Then<BR>        pbResource.Print “Can’t display data: “ &amp; sCrLf &amp; sCrLf &amp; _<BR>                         WordWrap(ApiError(Err.LastDllError), 25)<BR>        Exit Sub<BR>    End If<BR>    ‘ Allocate memory block and get its size<BR>    hmemRes = LoadResource(hMod, hRes)<BR>    cRes = SizeofResource(hMod, hRes)<BR>    ‘ Don’t dump more than 500 bytes<BR>    If cRes &gt; 500 Then cRes = 500<BR>    ‘ Lock it to get pointer<BR>    pRes = LockResource(hmemRes)<BR>    ‘ Allocate byte array of right size<BR>    ReDim abRes(cRes)<BR>    ‘ Copy memory block to array<BR>    CopyMemory abRes(0), ByVal pRes, cRes<BR>    ‘ Free resource (no need to unlock)<BR>    Call FreeResource(hmemRes)<BR>    pbResource.Print HexDump(abRes, False)<BR><BR>End Sub</code></pre>
<BR>
First you use FindResourceStrId or FindResourceStrStr (aliases for FindResource) to get a handle to the resource. Then you move through the memory-allocation fire drill described in the sidebar, “The Zen of Windows Memory Management,” page 454: allocate, lock, process, unlock, free. You’ll learn to recognize this pattern. The <i>process</i> step in ShowData copies the resource to a byte array. Refer back to the sidebar, “CopyMemory: A Strange and Terrible Saga,” page 90, to find the story of CopyMemory and its aliased friends CopyMemoryToStr and CopyMemoryRef.</p>
<BR>
You can probably guess what the HexDump function (or its cousins, HexDumpS and HexDumpB) looks like; check it out in UTILITY.BAS. It dumps in either <BR>8-byte rows (if you pass False as the second argument) or the traditional 16-byte format used by most debuggers. I use the 8-byte form in WinWatch so that the dump will fit in the picture box. Your dumps will look a lot better if you set the font of the output object (label, text box, picture box, printer) to a mono&shy;space font.</p>
</font></BODY>
</HTML>
