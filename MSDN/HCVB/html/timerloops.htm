<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Timer Loops</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>

<font face="verdana,arial,helvetica" size="2"><h1><a name="timerloops"></a>Timer Loops</h1>
<BR>
Animating the card backs illustrates one of the fundamental problems of Windows programming. Before we get to the specifics of making cards wink and flash, however, let’s talk about the problem in general.</p>
<BR>
Let’s say that you want to perform some operation (such as animation) in the background forever. This is easy in MS-DOS:</p>
<pre><code>Do<BR>    Draw it, x, y<BR>    If x &lt;= xMax Then x = x + 1 Else x = 0<BR>    If y &lt;= yMax Then y = y + 1 Else y = 0<BR>Loop</code></pre>
<BR>
Even in MS-DOS, however, this often doesn’t work very well. Your animation might run too fast, or it might run too fast on some machines and too slowly on others. To even things out, you can insert a Wait statement:</p>
<pre><code>Do<BR>    Draw it, x, y<BR>    If x &lt;= xMax Then x = x + 1 Else x = 0<BR>    If y &lt;= yMax Then y = y + 1 Else y = 0<BR>    Wait 100 ‘ microseconds<BR>Loop</code></pre>
<BR>
This might work fine for a machine running only MS-DOS, but depending on how Wait was implemented, it might be very rude indeed under 16-bit Windows. In the bad old days, Wait functions were often written as busy loops:</p>
<pre><code>Sub Wait(msWait As Long)<BR>    Dim msEnd As Long<BR>    msEnd = GetTickCount() + msWait  ‘ Get microseconds<BR>    Do<BR>    Loop While GetTickCount() &lt; msEnd<BR>End Sub</code></pre>
<BR>
This is the height of bad manners in any non-preemptive multitasking operating system because you are grabbing the processor and throwing away all cycles until you are finished, thus blocking all other programs. A preemptive multi&shy;tasking operating system such as Windows 95 or Windows NT might be able to jump in and steal control, but you’re nevertheless wasting a time slice that could be better used by someone else. Even your MS-DOS programs shouldn’t do this because it will cause them to hog the system when running in a Windows MS-DOS session.</p>
<BR>
One Visual Basic solution is to put DoEvents in the busy loop:</p>
<pre><code>Sub DoWaitEvents(msWait As Long)<BR>    Dim msEnd As Long<BR>    msEnd = GetTickCount + msWait<BR>    Do<BR>        DoEvents<BR>    Loop While GetTickCount &lt; msEnd<BR>End Sub</code></pre>
<BR>
This procedure resides in the UTILITY module in VBCore, and is a reasonable way to wait for short periods. I wouldn’t use it to wait for more than half a second or so. The DoEvents call releases your time slice to any other processes that are waiting for their turn to run. If DoEvents were written in Visual Basic, it would look something like this:</p>
<pre><code>Do While PeekMessage(msg, pNull, 0, 0, PM_REMOVE)<BR>    TranslateMessage msg<BR>    DispatchMessage msg<BR>Loop<BR>Sleep 0 </code></pre>
<BR>
In other words, DoEvents handles all pending messages and surrenders its time slice before returning to deal with your next message.</p>
<BR>
Notice the call to Sleep at the end of the loop. I’ve heard quite a bit of debate about the relative merits of <i>Sleep 0</i> versus <i>Sleep 1</i> for giving up your time slice. Here’s what the documentation says: “A value of zero causes the thread to relinquish the remainder of its time slice to any other thread of equal priority that is ready to run.” This means that if other threads aren’t quite ready or aren’t of equal priority, they won’t run. I’ve seen tests indicating that <i>Sleep 1</i> is often a more effective way of yielding.</p>
<BR>
So if <i>Sleep 1</i> is good way to wait for a very short time, why wouldn’t <i>Sleep 1000</i> be a good way of waiting for one second? The problem with Sleep is that it really sleeps. Your program gets absolutely no processing time and will not be able to paint or do anything else until the sleep is over. Generally, Sleep is useful for multithreaded applications in which one thread can sleep while another continues working. Sleep is usually a bad idea for a normal Visual Basic program that has only one thread. We’ll talk more about threads, processes, and waiting in Chapter 11.</p>
<BR>
The real problem with using Sleep or DoEvents to wait is that it’s not the Windows Way. If other processes use too much time, you’ll be way past quitting time when you get control back. In any multitasking system, someone else could want the same time slot you want. Your best chance of getting control at a specific time is to request it politely using a Windows Timer—which, in Visual Basic, means using the Timer control or a timer class.</p>
<BR>
You’re probably not accustomed to thinking of the Timer control as just another looping structure comparable to Do/Loop or For/Next. But why not? Consider the following “bad” loop:</p>
<pre><code>Dim x As Integer, y As Integer, secStop As Double<BR>Do<BR>    If x &lt;= xMax Then x = x + 1 Else x = 0<BR>    If y &lt;= yMax Then y = y + 1 Else y = 0<BR>    If Draw(it, x, y) = False Then Exit Do<BR>    secStop = Timer + .1  ‘ Wait one-tenth second<BR>    Do <BR>        DoEvents <BR>    Loop Until Timer &gt; secStop<BR>Loop</code></pre>
<BR>
Notice the following points:
<ul>
<li>
This loop is an endless Do Loop.<BR><BR></li>
<li>
The loop has an exit in the middle via Exit Do.<BR><BR></li>
<li>
The loop uses the Timer function in a loop to wait one tenth of a <BR>second.<BR><BR></li>
<li>
The loop uses normal local variables, reinitializing them when they <BR>exceed a maximum.</li>
</ul>
<BR>
Now let’s convert to a “good” loop:</p>
<pre><code>tmrAnimate.Interval = 100  ‘ 100 microseconds is one-tenth second<BR>§<BR>Sub tmrAnimate_Timer()<BR>    Static x As Integer, y As Integer<BR>    If x &lt;= xMax Then x = x + 1 Else x = 0<BR>    If y &lt;= yMax Then y = y + 1 Else y = 0<BR>    If Draw(it, x, y) = False Then tmrAnimate.Enabled = False<BR>End Sub</code></pre>
<BR>
Here’s how the code is transformed:
<ul>
<li>
A Sub statement replaces Do; an End Sub replaces Loop.<BR><BR></li>
<li>
The exit changes from Exit Do to <i>tmrAnimate.Enabled <font face="Symbol"><span style="font-family:symbol">&#61;</span></font> False.</i><BR><BR></li>
<li>
The time period is set with the Interval property outside the loop.<BR><BR></li>
<li>
The variables must be declared static because you’ll leave the loop on every iteration, but you want them to be unchanged when you come back.</li>
</ul>
<BR>
We’ll see how this technique works in the Fun ’n Games program after a brief look at the CTimer class.</p>
</font></BODY>
</HTML>
