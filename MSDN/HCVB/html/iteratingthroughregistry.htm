<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Iterating through the registry</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>

<font face="verdana,arial,helvetica" size="2"><h1><a name="iteratingthroughregistry"></a>Iterating through the registry </h1>
<BR>
You can iterate through the registry items and nodes the way you expect to iterate through any collection. Iterate through items by index like this: </p>
<pre><code>For i = 0 To node.ItemCount - 1<BR>    With node.Items(i)<BR>        s = s &amp; .Name &amp; “(“ &amp; i &amp; “) = “ &amp; VarToStr(.Value) &amp; sCrLf<BR>    End With<BR>Next</code></pre>
<BR>
The VarToStr function in this loop is local to the test program. It converts numeric, integer, or binary data to a string in the following format:</p>
<pre><code>(0) = Default<BR>Bytes(1) = 54 00 68 00 65 00 20 00  ...<BR>String(2) = A String<BR>Number(3) = &amp;H00000005 (5)<BR>ExpandString(4) = A C:\temp string</code></pre>
<BR>
Normally, it’s easier to iterate with For Each. The CRegItemWalker and CReg&shy;NodeWalker classes do the hard work (as explained in Chapter 4) so that you can iterate easily: </p>
<pre><code>For Each nodesSub In node<BR>    s = s &amp; nodesSub.Name &amp; sCrLf<BR>    ‘ Iterate items with For Each<BR>    For Each item In nodesSub.Items<BR>        s = s &amp; item.Name &amp; “ = “ &amp; VarToStr(item.Value) &amp; sCrLf<BR>    Next<BR>Next</code></pre>
<BR>
The outer loop walks through nodes, and the inner loop walks through the items of each node. </p>
<BR>
You can use these techniques to iterate yourself, but there’s an even easier way. CRegNode knows how to walk using the WalkNodes, WalkItems, and WalkAll&shy;Nodes methods. Let’s look at WalkAllNodes, which walks recursively through all the nested nodes at and below the current node. WalkAllNodes keeps walking through nodes with For Each, calling itself on each node it finds until there are no nodes left to walk. There’s only one problem. How does WalkAllNodes know what to do with what it walks? It doesn’t. Only the client can say what needs to be done, and the way to ask the client is through an interface. </p>
<BR>
The IUseRegItems interface provides the template for registry operations on items or nodes: </p>
<pre><code>Function UseNode(node As CRegNode, ByVal iLevel As Long) As Boolean<BR><BR>End Function<BR><BR>Function UseItem(item As CRegItem, ByVal iLevel As Long) As Boolean<BR><BR>End Function</code></pre>
<BR>
The client of the CRegNode class implements the IUseRegItems interface and passes an IUseRegItems object to CRegNode. In the Test Registry program, the main form does the implementing. It provides IUseRegItems_UseItem and IUse&shy;RegItems_UseNode functions that append formatted text for each node or item to a module-level string, which is written to a textbox when the walk is finished. In real life, you’d probably want to do something more interesting—such as put the nodes in a TreeView and the items in a ListView. </p>
<BR>
The WalkAllNodes method calls back to the IUseRegItems object you pass it so that your code can handle the real work. The client code is easy: </p>
<pre><code>node.WalkAllNodes Me, node, 0</code></pre>
<BR>
The first parameter of WalkAllNodes is the IUseRegItems object that tells what to do with each node and item. Since the client form implements IUseRegItems, it can simply pass itself. The second parameter is the starting node. The third parameter is the indent level. Each nested call to WalkAllNodes increments the indent level, which is passed back to the client in the UseNode and UseItem procedures. The client can use the level to produce formatted output. For example, here’s how the Test Registry form implements the UseNode procedure: </p>
<pre><code>Private Function IUseRegItems_UseNode(node As CRegNode, _<BR>                                      ByVal iLevel As Long) As Boolean<BR>With node<BR>    sOut = sOut &amp; Space$((iLevel) * 4) &amp; .Name &amp; “ : “ &amp; sCrLf<BR>    .WalkItems Me, iLevel<BR>    DoEvents<BR>End With<BR>End Function</code></pre>
<BR>
After writing the formatted node information, the code calls WalkItems to handle the item information. For each note item, WalkItems calls UseItem, which Test Registry implements like this:</p>
<pre><code>Private Function IUseRegItems_UseItem(item As CRegItem, _<BR>                                      ByVal iLevel As Long) As Boolean<BR>With item<BR>    sOut = sOut &amp; Space$((iLevel - 1) * 4) &amp; “ &gt; “ &amp; _<BR>                  .Name &amp; “ : “ &amp; VarToStr(.Value) &amp; sCrLf<BR>End With<BR>End Function</code></pre>
<BR>
The last piece of this puzzle is the implementation of WalkAllNodes in the CRegNode class. First it calls the UseNode method of the IUseRegItems object to display the current node. Then it calls WalkAllNodes recursively to do the same thing again on each node in the current node. </p>
<pre><code>Function WalkAllNodes(use As IUseRegItems, nodeStart As CRegNode, _<BR>                      ByVal iLevel As Long) As CRegNode<BR>    If use.UseNode(nodeStart, iLevel) Then<BR>        Set WalkAllNodes = nodeStart<BR>        Exit Function<BR>    End If<BR>    Dim i As Long, nodeT As CRegNode<BR>    ‘ Iterate by index for greater speed<BR>    For i = 0 To nodeStart.NodeCount - 1<BR>        Set WalkAllNodes = WalkAllNodes(use, nodeStart.Nodes(i), _<BR>                                        iLevel + 1)<BR>    Next<BR>End Function</code></pre>
<BR>
Notice that WalkAllNodes and UseNode are functions (as are WalkNodes, Walk&shy;Items, and UseItem). This enables you to write registry search procedures. Your implementation of UseNode could check for items that meet a certain condition and return True when it is found. WalkAllNodes would recognize the return as a signal to stop walking and return the current node up through the recursion chain. The Test Registry sample program doesn’t use this feature. It always returns False so that the walk continues until there are no more nodes. </p>
<BR>
Let me make one more point about node and item walking. Under Windows NT there are many things in the registry that your programs might not have the right to access. I’m not going to get into the security issues now. The point is that if you walk through a place you have no right to walk, you’ll encounter an access denied error (5). If you’re not careful, this will terminate your walk, leaving additional walkable objects unwalked. The CRegNode and CRegItem classes have to trap errors and skip unwalkable objects rather than failing on them. This requires some messy code, particularly in the More method of the CRegNodeWalker class.</p>
</font></BODY>
</HTML>
