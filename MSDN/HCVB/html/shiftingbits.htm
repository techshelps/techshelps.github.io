<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Shifting Bits</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>

<font face="verdana,arial,helvetica" size="2"><h1><a name="shiftingbits"></a>Shifting Bits</h1>
<BR>
Occasionally, you need to shift bits. This bit operation doesn’t come up that often in Basic, but when you need to get a certain bit into a certain position, nothing else will do.</p>
<BR>
Shifting left 1 bit means multiplying by 2, shifting left 2 bits means multiplying by 4, and so on. Similarly, shifting right 1 bit means dividing by 2, and so on. In Basic terms, the operation starts out looking simple:</p>
<pre><code>Function LShiftWord1(w As Integer, c As Integer) As Integer<BR>    LShiftWord1 = w * (2 ^ c)<BR>End Function<BR><BR>Function RShiftWord1(w As Integer, c As Integer) As Integer<BR>    RShiftWord1 = w \ (2 ^ c)<BR>End Function</code></pre>
<BR>
These functions work as long as you feed them positive integers and the results come out as positive integers. Otherwise, things go wrong. Before we get to the real version, let’s take a look at a C++ version:</p>
<pre><code>// Shift bits of DWord right<BR>DWORD DLLAPI RShiftDWord(DWORD dw, unsigned c)<BR>{<BR>   return dw &gt;&gt; c;<BR>}</code></pre>
<BR>
That’s it. Even if you’re not a C++ programmer, you can probably guess the code for LShiftDWord, RShiftWord, and LShiftWord. There’s still a function call for shifting. What Visual Basic really needs are Shl and Shr operators as in most other languages. Then the work would be done automatically inline. Unfortunately, you have to do the messy job yourself if you’re not willing to add a C++ DLL.</p>
<pre><code>Function LShiftWord(ByVal w As Integer, ByVal c As Integer) As Integer<BR>    BugAssert c &gt;= 0 And c &lt;= 15<BR>    Dim dw As Long<BR>    dw = w * Power2(c)<BR>    If dw And &amp;H8000&amp; Then<BR>        LShiftWord = CInt(dw And &amp;H7FFF&amp;) Or &amp;H8000<BR>    Else<BR>        LShiftWord = dw And &amp;HFFFF&amp;<BR>    End If<BR>End Function</code></pre>
<p>
Notice that this function uses the Power2 property to look up powers of 2 rather than calculating them. See “Module initialization versus component initialization” earlier in this chapter.</p>
<p>
Since shifting is faster than the equivalent multiplication and <BR>division operations in assembly language, hardcore programmers in other languages often shift bits to optimize multiplication and division by multiples of 2. But you can see why the functions I just mentioned are useless for optimization: it doesn’t do any good to fake division by shifting if your shift function fakes shifting by dividing.</p>
<BR>
The function works by doing the arithmetic on a temporary Long variable and then converting the result back to an Integer. But you can’t do that for the LShiftDWord and RShiftDWord functions because there isn’t a larger integer size to cast down from. The functions have to use error trapping to identify overflow, and they will fail on some input. It’s the best I could do, and rarely will you ever hit the limits.</p>
<BR>
The Win32 GetLogicalDrives function returns a Long in which the corresponding bit is set for each existing drive. The easiest way to check those drives is to loop through all 26 bits, shifting them one at a time into the rightmost position and then testing them. Here’s a function that translates bits into a more Basic-like string of pluses and minuses:</p>
<pre><code>Function VBGetLogicalDrives() As String<BR><BR>    Dim f32 As Long, i As Integer, s As String<BR>    f32 = GetLogicalDrives()<BR>    For i = 0 To 25<BR>        s = s &amp; IIf(f32 And 1, “+”, “-”)<BR>        f32 = RShiftDWord(f32, 1)<BR>    Next<BR>    VBGetLogicalDrives = s<BR>    <BR>End Function</code></pre>
<BR>
The CDrives class described in Chapter 4 has a more realistic example of RShift&shy;DWord and GetLogicalDrives.</p>
</font></BODY>
</HTML>
