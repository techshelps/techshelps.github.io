<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Typeless Variables</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>

<font face="verdana,arial,helvetica" size="2"><h1><a name="typelessvariables"></a>Typeless Variables</h1>
<BR>
The Windows API frequently requires typeless parameters. The idea is to pass different types of data to the same function. For example, the GetObject function handles pens, brushes, fonts, bitmaps, and palettes through the same parameter. This works fine in weakly typed languages such as C. It doesn’t work so well in Basic, a schizophrenic language that can’t make up its mind whether to be strongly typed or weakly typed. The Declare statement, at any rate, is strongly typed, most of the time. (Basic is also a typeless language, through its Variant type; but just as Basic doesn’t do pointers, Windows doesn’t do Variants.)</p>
<BR>
Every variable has a type, explicit or assumed, regardless of the host language. When you pass a variable to a function, that function must figure out the type so that it knows what to do with the variable. The type can be embedded in the data (as in Basic Variants), or it can be supplied as a separate parameter to the function. That’s the easy part. The tricky part is getting Basic to turn off its data typing so that you can pass different kinds of data. The Alias attribute of the Declare statement and the Any parameter type enable you to lie, cheat, steal, and have your way with data.</p>
<BR>
The GetObject API function illustrates several points about untyped parameters. The C version looks like this:</p>
<pre><code>int GetObject(<BR>    HGDIOBJ hgdiobj,  // Handle of graphics object<BR>    int cbBuffer,     // Size of buffer for object information<BR>    LPVOID lpvObject  // Pointer to buffer for object information<BR>);</code></pre>
<BR>
To use GetObject, you pass it the handle of a logical pen, a brush, a font, a bitmap, or a palette. You pass the length of the data you want to get back and the address of the variable where you want the data placed. This variable will have type LOGPEN, LOGBRUSH, LOGFONT, BITMAP, or int, depending on the data. Windows will use the handle to find the data and will then copy it to the variable.</p>
<p>
The Basic prototype presents several problems. First, GetObject is the name of a Visual Basic function. In old versions of Visual Basic, you got an error if you tried to declare a function with an existing function name, but the current version (and version 4) offers no objections if you redefine GetObject with either a Declare statement or a Basic function. Nevertheless, don’t do it. You should rename this function. I call mine VBGetObject.</p>
<p>
You can redefine a function to replace the built-in version with a new version. For example, you could write your own version of InStr. Any code you wrote earlier that uses the built-in InStr will work with your new version. This is how you use the renaming feature. You abuse it by giving your function the same name as the built-in version but different behavior. See the sidebar “Better Basic Through Subclassing,”page 240, for a more complete discussion of this feature.</p>
<BR>
You’ll encounter the name problem in several cases in the Windows API, and it’s likely to come up anytime you try to use a DLL written for another language. For example, the Windows API includes the _lopen, _lread, _lwrite, and _lclose functions, but you can’t write declarations for them because a Basic name can’t start with an underscore. (My type library calls them lopen, lread, lwrite, and lclose.) Basic provides the Alias attribute to let you specify that a name recognized in one way by the DLL can have a different Basic name.</p>
<BR>
The second problem is to turn off Basic’s type checking. In other words, you need a type that corresponds to a C void pointer. The Any type passed by reference is a rough equivalent. When you declare a parameter with As Any, you cancel the contract. Basic no longer promises the Windows API anything in particular. Windows promises to write no more than the specified number of bytes to the specified variable, whether they fit or not. It’s up to you to pass a variable that can accept the data. If you’re the kind of programmer who doesn’t mind working without a net, you might be getting bright ideas about using As Any in your own Basic procedures. Forget it. Basic accepts As Any only in Declare statements. Use Variant, not As Any, to write typeless functions in Basic.</p>
<BR>
The declaration for VBGetObject looks like this:</p>
<pre><code>Declare Function VBGetObject Lib &quot;GDI32&quot; Alias &quot;GetObjectA&quot; ( _<BR>    ByVal hObject As Long, ByVal cbBuffer As Long, _<BR>    lpvObject As Any) As Long</code></pre>
<BR>
Notice that the real name of the function is GetObjectA, not GetObject. I’ll explain why in the next section.</p>
<BR>
The Basic version of C’s BITMAP type looks like this:</p>
<pre><code>Type BITMAP<BR>    bmType As Long<BR>    bmWidth As Long<BR>    bmHeight As Long<BR>    bmWidthBytes As Long<BR>    bmPlanes As Integer<BR>    bmBitsPixel As Integer<BR>    bmBits As Long<BR>End Type</code></pre>
<BR>
You can pass a BITMAP variable to VBGetObject:</p>
<pre><code>Dim bmp As BITMAP<BR>§<BR>c = VBGetObject(pbBitmap.Picture, Len(bmp), bmp)</code></pre>
<BR>
That’s easy enough if you happen to know that the Picture property of a picture box containing a bitmap is actually a bitmap handle. (Chapter 6 explains this and related issues.) But you’d better be sure that whatever gets passed to the function is what you say it is. If you pass a bitmap handle in parameter 1, the length of a LOGPEN in parameter 2, and a LOGBRUSH variable in parameter 3, you won’t like the results.</p>
<BR>
If you ignore the safety net that Basic offers, you must be ready to accept the consequences. Or, better yet, use the safety net. You can alias as many functions as you want to the same API function, so why not do a type-safe version for each data type?</p>
<pre><code>Declare Function GetObjectBrush Lib &quot;GDI32&quot; Alias &quot;GetObjectA&quot; ( _<BR>    ByVal hBrush As Long, ByVal cbBuffer As Long, _<BR>    lpBrush As LOGBRUSH) As Long<BR>Declare Function GetObjectBitmap Lib &quot;GDI32&quot; Alias &quot;GetObjectA&quot; ( _<BR>    ByVal hBitmap As Long, ByVal cbBuffer As Long, _<BR>    lpBitmap As BITMAP) As Long</code></pre>
<BR>
The Windows API type library provides these functions and several other GetObject variations, but don’t let the increased safety make you overconfident. If you pass a LOGPEN variable to GetObjectBrush, you get the error <i>ByRef argument type mismatch</i>. But if you pass a Pen handle to GetObjectBrush, neither Basic nor Windows complains. Windows gets the data type and the data from the handle, but it can’t tell whether you passed the matching length and destination variable.</p>
<BR>
Visual Basic 4 didn’t support a type library equivalent to the As Any syntax, and it didn’t support structures in type libraries. Therefore, VBGetObject had to be implemented with the Declare statement. Those limitations are gone. You’ll find VBGetObject and all its aliases in the current Windows API type library.</p>
</font></BODY>
</HTML>
