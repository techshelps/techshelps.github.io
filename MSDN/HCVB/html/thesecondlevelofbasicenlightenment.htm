<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Chapter 2: The Second Level of Basic Enlightenment</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>

<font face="verdana,arial,helvetica" size="2">
<h4>Chapter 2</h4>
<h1><a name="thesecondlevelofbasicenlightenment"></a>The Second Level of Basic Enlightenment</h1>
<p>
Visual Basic doesn’t do pointers. Windows does. That’s the contradiction you must resolve in order to achieve the second level of enlightenment.</p>
<p>
You’ve already mastered the first level—designing forms and using Basic statements. The second level—calling the Windows API—requires a different kind of understanding. Even if you have experienced moments of clarity and truth with previous versions of Visual Basic, you must now learn again as a little child, because the gods have changed the rules.</p>
<p>
Although on the surface this chapter appears to be about how to write Declare statements for Windows API functions, it is actually a meditation on the mysteries of pointers. Although it takes you step by step through the syntax of passing integers, user-defined types, arrays, and strings to DLL functions, below the surface its theme is addresses and how to become one with them. Lest you feel that your growing enlightenment comes from your own efforts, the chapter starts off with a type library that makes much of what you’ll learn irrelevant.</p>
<p>
So let’s start at the beginning—with <i>addresses,</i> locations in memory that contain data or instructions. Everything a running program does consists of manipulating addresses and their contents. As designed by Kemeny and Kurtz, however, Basic shielded you from addresses. You could have programmed for years without knowing that memory even existed, much less that locations within it were called addresses.</p>
<p>
Meanwhile, Brian Kernighan and Dennis Ritchie designed C, a language that not only allowed you to get addresses but also let you put them in variables called pointers, manipulate those variables to point at different addresses, and do almost anything that you could previously do only in assembly language. The C philosophy is pretty much the opposite of the Basic philosophy in every way. And C is the language in which—and seemingly for which—Microsoft wrote Windows.</p>
<p>
Basic is abstract; C is specific. Basic is high-level; C is low-level. Basic is protective; C is undisciplined. Basic is basic; C is un-Basic. A good C programmer can write a Basic interpreter. A good Basic programmer can write a C pretty printer while the C programmer is still declaring variables.</p>
<p>
Fortunately, you don’t have to learn C to be a Windows programmer. But you do need to know some of the things C programmers know—things that Basic programmers aren’t supposed to worry their pretty little heads with. Nevertheless, this chapter won’t wander too far from the Basic Way. It will show you some tricks for keeping your un-Basic excursions short and for wrapping up the results so that they look Basic.</p>
</font></BODY>
</HTML>
