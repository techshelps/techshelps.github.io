<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>GetFullPathName</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>

<font face="verdana,arial,helvetica" size="2"><h1><a name="getfullpathname"></a>GetFullPathName</h1>
<BR>
When you are given a filename or a relative path, you’ll often need to convert it to a full pathname. You could write the code to find the pathname in Basic, but the operating system can provide the information more reliably. That way, your code will work even if the rules defining paths and filenames change (as they did for Windows NT and Windows 95). Win32 provides the GetFullPath&shy;Name function.</p>
<BR>
Use GetFullPathName as shown here:</p>
<pre><code>Dim sBase As String, pBase As Long<BR>sFullName = String$(cMaxPath, 0)<BR>c = GetFullPathName(sName, cMaxPath, sFullName, pBase)<BR>sFullName = Left$(sFullName, c)<BR>If c Then s = s &amp; “Full name: “ &amp; sFullName &amp; sCrLf</code></pre>
<BR>
Notice the last argument passed to GetFullPathName. The function returns a pointer to the filename portion of the full pathname. That’s handy in C, but it’s not much use in Basic. The Basic Way is to return the 1-based position of the filename string within the full pathname string. Then you can use Mid$ to cut out the filename.</p>
<BR>
The only way to convert that filename pointer to a position index is to write a wrapper function in C that calculates the index by comparing the pointer to the start of the full pathname to the filename pointer. You can’t do the pointer arithmetic in Basic because the <i>pBase</i> pointer returned by GetFullPathName is a pointer to the temporary ANSI string used during Unicode conversion. That temporary string is gone, so a pointer to it is meaningless.</p>
<BR>
But let’s put that aside for the moment. Instead, let’s take another look at GetFull&shy;PathName. Do you notice anything missing? It returns only the pathname but no other useful information, such as the extension or the directory. Why not? Many languages provide a function to split a full pathname into its parts. For example, Microsoft Visual C++ provides _splitpath. A language that lacks this invaluable tool is unthinkable. One way or another we must add it to Visual Basic, and the Win32 GetFullPathName function provides part of the solution. But to make it fully functional, you need to parse the rest of the full path&shy;name to provide the directory and extension parts. If you’re going that far, it’s easy enough to ignore the filename pointer provided by GetFullPathName and just parse for the basename position in Basic.</p>
<BR>
That’s exactly what my GetFullPath function does. It returns indexes to the pathname parts through optional reference parameters, and it returns the full pathname in the return value. You can use the whole works like this:</p>
<pre><code>s = s &amp; sCrLf &amp; “Test GetFullPath with all arguments” &amp; sCrLf &amp; sCrLf<BR>sFullName = GetFullPath(sName, iBase, iExt, iDir)<BR>If sFullName &lt;&gt; sEmpty Then<BR>    s = s &amp; “Relative file: “ &amp; sName &amp; sCrLf<BR>    s = s &amp; “Full name: “ &amp; sFullName &amp; sCrLf<BR>    s = s &amp; “File: “ &amp; Mid$(sFullName, iBase) &amp; sCrLf<BR>    s = s &amp; “Extension: “ &amp; Mid$(sFullName, iExt) &amp; sCrLf<BR>    s = s &amp; “Base name: “ &amp; Mid$(sFullName, iBase, _<BR>                                 iExt - iBase) &amp; sCrLf<BR>    s = s &amp; “Drive: “ &amp; Left$(sFullName, iDir - 1) &amp; sCrLf<BR>    s = s &amp; “Directory: “ &amp; Mid$(sFullName, iDir, _<BR>                                 iBase - iDir) &amp; sCrLf<BR>    s = s &amp; “Path: “ &amp; Left$(sFullName, iBase - 1) &amp; sCrLf<BR>Else<BR>    s = s &amp; “Invalid name: “ &amp; sName<BR>End If</code></pre>
<BR>
It would be annoying to have to provide all those index arguments in cases where you didn’t need them, but fortunately they’re optional. The following list shows just about all the possible permutations, although some of these make more sense than others.</p>
<pre><code>sFullName = GetFullPath(sName, iBase, iExt, iDir)<BR>sFullName = GetFullPath(sName, iBase, iExt)<BR>sFullName = GetFullPath(sName, iBase)<BR>sFullName = GetFullPath(sName)<BR>sFullName = GetFullPath(sName, , iExt)<BR>sFullName = GetFullPath(sName, , iExt, iDir)<BR>sFullName = GetFullPath(sName, , , iDir)<BR>sFullName = GetFullPath(sName, iBase, , iDir)</code></pre>
<BR>
Although these cover the bases, they’re not particularly convenient, so UTIL&shy;ITY.BAS (and UTILITY.CLS through delegation) also provides wrappers for some of the most common operations:</p>
<pre><code>sName = “Hardcore.frm”<BR>sPart = GetFullPath(sName)      ‘ C:\Hardcore\Hardcore.frm<BR>sPart = GetFileBase(sName)      ‘ Hardcore<BR>sPart = GetFileBaseExt(sName)   ‘ Hardcore.frm<BR>sPart = GetFileExt(sName)       ‘ .frm<BR>sPart = GetFileDir(sName)       ‘ C:\Hardcore\</code></pre>
<BR>
Now that we’ve seen how GetFullPath works, let’s take a look at how it’s implemented in Basic, as shown on the following page.</p>
<pre><code>Function GetFullPath(sFileName As String, _<BR>                     Optional FilePart As Long, _<BR>                     Optional ExtPart As Long, _<BR>                     Optional DirPart As Long) As String<BR><BR>    Dim c As Long, p As Long, sRet As String<BR>    If sFileName = sEmpty Then ApiRaise ERROR_INVALID_PARAMETER<BR>    <BR>    ‘ Get the path size, then create string of that size<BR>    sRet = String(cMaxPath, 0)<BR>    c = GetFullPathName(sFileName, cMaxPath, sRet, p)<BR>    If c = 0 Then ApiRaise Err.LastDllError<BR>    BugAssert c &lt;= cMaxPath<BR>    sRet = Left$(sRet, c)<BR><BR>    ‘ Get the directory, file, and extension positions<BR>    GetDirExt sRet, FilePart, DirPart, ExtPart<BR>    GetFullPath = sRet<BR>    <BR>End Function</code></pre>
<BR>
Most of the function is straightforward API calling as discussed in Chapter 2. The error-handling functions ApiRaise and ApiRaiseIf were discussed in “What’s Wrong with That?” earlier in this chapter. Actually, most of the code is hidden in the call to GetDirExt, which contains big, ugly chunks of inconsistent parsing code for finding the different file parts. I’ll spare you the details of how I parse from the front to find the directory position and from the back to find the extension and base positions. The code (like that for all the procedures in this section) is in UTILITY.BAS.</p>
</font></BODY>
</HTML>
