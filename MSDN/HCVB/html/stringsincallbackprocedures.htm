<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Strings in Callback Procedures</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>

<font face="verdana,arial,helvetica" size="2"><h1><a name="stringsincallbackprocedures"></a>Strings in Callback Procedures</h1>
<BR>
Enumeration of windows and fonts is a relatively simple matter, but enumeration of resources brings us to another level. I won’t get to what resources are or what you can do with them until later. The important thing here is that the callback procedures for the resource functions take string arguments.</p>
<BR>
Here’s what EnumResourceTypes looks like in C:</p>
<pre><code>BOOL EnumResourceTypes(<BR>    HMODULE hModule,             // Resource-module handle<BR>    ENUMRESTYPEPROC lpEnumFunc,  // Pointer to callback function<BR>    LONG lParam                  // Application-defined parameter<BR>    );</code></pre>
<BR>
The ENUMRESTYPEPROC parameter requires a procedure that looks like this:</p>
<pre><code>BOOL CALLBACK EnumResTypeProc(<BR>    HANDLE hModule,              // Resource-module handle <BR>    LPTSTR lpszType,             // Pointer to resource type <BR>    LONG lParam                  // Application-defined parameter<BR>    );</code></pre>
<BR>
The question is, how will you write an EnumResTypeProc that takes an LPTSTR parameter in Basic? Your first try might look something like this:</p>
<pre><code>Function EnumResTypeProc(ByVal hModule As Long, _ <BR>                         ByVal lpszType As String, _<BR>                         lParam As Long) As Long</code></pre>
<BR>
That’s how you would write the parameters if you were writing a Declare statement for a function to be called from Basic. You’d use a String type for <i>lpszType</i>, knowing that Basic would automatically translate to Unicode. But you’re not writing a Declare statement; you’re writing a function. And it won’t be called by Basic; it will be called by Windows. And Windows hasn’t a clue about the String type. The only way Windows is going to understand what to do is if you write the function like this:</p>
<pre><code>Function EnumResTypeProc(ByVal hModule As Long, _<BR>                         ByVal lpszType As Long, _<BR>                         lParam As Long) As Long</code></pre>
<BR>
Windows will pass you a pointer to the string, but then what will you do with it in Basic? By now you should have figured out what you can do when the API passes a pointer: pass it on. The hack to convert an API pointer requires several API calls, so I wrap it in a function called PointerToString:</p>
<pre><code>Function PointerToString(p As Long) As String<BR>    Dim c As Long<BR>    c = lstrlenPtr(p)<BR>    PointerToString = String$(c, 0)<BR>    If UnicodeTypeLib Then<BR>        CopyMemoryToStr PointerToString, ByVal p, c * 2<BR>    Else<BR>        CopyMemoryToStr PointerToString, ByVal p, c<BR>    End If<BR>End Function</code></pre>
<BR>
This looks simple, but if measured in the hours it took me to figure it out, PointerToString would be a pretty long function. First you get the length of the string. The normal version of the lstrlen function takes a string argument, but in this case we have a pointer, not a string, so you must use the lstrlenPtr alias. Keep in mind that lstrlenPtr might actually be lstrlenA or lstrlenW, depending on whether the API type library you have loaded is WIN.TLB or WINU.TLB. In either case, it returns the internal string length so that you can create a Basic string to hold it.</p>
<BR>
The length is returned in characters, but CopyMemory expects bytes. The Unicode version (as indicated by the test of UnicodeTypeLib) must double the character count. The ANSI version will actually be working on a temporary ANSI copy of the string created for the Unicode conversion. “Dealing with Strings,” page 72, describes what goes on behind the scenes in more detail. Given PointerToString, you can define the contents of the EnumResTypeProc:</p>
<pre><code>Function EnumResTypeProc(ByVal hModule As Long, ByVal lpszType As Long, _<BR>                         lParam As Long) As Long<BR>    If lpszType &lt; 65535 Then<BR>        ' Enumerate resources by ID<BR>        Call EnumResourceNamesID(hNull, lpszType, _<BR>                                 AddressOf EnumResNameProc, lParam)<BR>    Else<BR>        ' Enumerate resources by string name<BR>        Call EnumResourceNamesStr(hNull, PointerToString(lpszType), _<BR>                                  AddressOf EnumResNameProc, lParam)<BR>    End If<BR>    EnumResTypeProc = True<BR>End Function</code></pre>
<BR>
Uh-oh. You can see how PointerToString is used to convert <i>lpszType</i> to a string, but the rest of the code raises more questions than it answers. What does it mean to pass a resource ID, and why would the value of the <i>lpszType </i>pointer be relevant? Those questions have more to do with resources than callbacks, so I’ll defer them until later.</p>
</font></BODY>
</HTML>
