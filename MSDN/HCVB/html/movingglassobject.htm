<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Moving a Glass Object</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>

<font face="verdana,arial,helvetica" size="2"><h1><a name="movingglassobject"></a>Moving a Glass Object</h1>
<BR>
Now you have everything necessary to draw a transparent image anywhere. The Draw method does the work. Users can call the Draw method themselves, but generally, they won’t. Instead, they’ll call the Move method or modify the Left and Top properties, which will, in turn, call the Draw method.</p>
<BR>
Conceptually, the Draw method works a lot like the GDI DrawIcon function. The code is on the following page.</p>
<pre><code>Public Sub Draw()<BR>With cvsDst<BR>    BugAssert fExist<BR>    If fVisible = False Then Exit Sub<BR><BR>    ‘ Copy old background to its last location<BR>    If xOld &lt;&gt; -1 Then<BR>        Call BitBlt(hdcDst, xOld, yOld, dxSrc, dySrc, _<BR>                    hdcBack, 0, 0, vbSrcCopy)<BR>    End If<BR>    ‘ Save current background and position for next time<BR>    Call BitBlt(hdcBack, 0, 0, dxSrc, dySrc, _<BR>                hdcDst, xLeft, yTop, vbSrcCopy)<BR>    ‘ Create cache copy of background to work on<BR>    Call BitBlt(hdcCache, 0, 0, dxSrc, dySrc, _<BR>                hdcDst, xLeft, yTop, vbSrcCopy)<BR>    xOld = xLeft: yOld = yTop<BR>    ‘ Save color and set to white and black<BR>    Dim clrBack As Long, clrFore As Long<BR>    clrBack = GetBkColor(hdcCache)<BR>    clrFore = GetTextColor(hdcCache)<BR>    Call SetBkColor(hdcCache, vbWhite)<BR>    Call SetTextColor(hdcCache, vbBlack)<BR>    ‘ Mask the background<BR>    Call BitBlt(hdcCache, 0, 0, dxSrc, dySrc, hdcMask, 0, 0, vbSrcAnd)<BR>    ‘ Put image in hole created by mask<BR>    Call BitBlt(hdcCache, 0, 0, dxSrc, dySrc, hdcImage, 0, 0, vbSrcPaint)<BR>    ‘ Restore color<BR>    Call SetBkColor(hdcCache, clrBack)<BR>    Call SetTextColor(hdcCache, clrFore)<BR>    ‘ Put finished cache on screen<BR>    Call BitBlt(hdcDst, xLeft, yTop, dxSrc, dySrc, _<BR>                hdcCache, 0, 0, vbSrcCopy)<BR>End With<BR>End Sub</code></pre>
<BR>
This method, like every other method and property in CPictureGlass, starts out by asserting that the object exists. This assertion will fail if the user declares a CPictureGlass object but then tries to use it before initializing with the Create method. Draw also terminates without doing anything if <i>fVisible</i> (controlled by the Visible property) is False.</p>
<BR>
Draw next restores the previous background (if there is one) and saves two copies of the current background—one to work on and one to restore next time. Without this step, each drawing would work but wouldn’t erase itself; you’d see a trail of image “droppings.” Finally you mask out the shape of the image on the background of the temporary copy and plunk the image (with its inverted </p>
<BR>
<b>Transparent Blits</b></p>
<BR>
It has been alleged that some video drivers support transparent blits. I have never come across one, and so, being unable to test the feature, I didn’t build it into CPictureGlass. However, the Video tab in the All About program (ALLABOUT&shy;.VBP) will tell you whether your system supports transparent blits. If so, you could do faster, smoother animation with the following code:</p>
<pre><code>If GetDeviceCaps(hdcDst, CAPS1) And C1_TRANSPARENT Then<BR>    ordModeOld = GetBkMode(hdcDst, NEWTRANSPARENT)<BR>    clrOld = SetBkColor(hdcDst, clrMask)<BR>    Call BitBlt(hdcDst, xLeft, yTop, dxSrc, dySrc, _<BR>                hdcImage, 0, 0, NEWTRANSPARENT)<BR>    Call SetBkMode(hdcDst, ordModeOld)<BR>    Call SetBkColor(hdcDst, clrOld)<BR>End If</code></pre>
<BR>
This is air code because I had nothing to test it with. This feature has been around long enough that hardware vendors ought to support it, and maybe some do. But not for the hardware I use.</p>
<BR>
background) into the hole. Only when the whole image and background have been assembled off-screen do you copy the temporary <i>hdcCache</i> to the screen. You could do all this blitting and color changing directly on the container, but you’d end up with a whole lot of flicker.</p>
</font></BODY>
</HTML>
