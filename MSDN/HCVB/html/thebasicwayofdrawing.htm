<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>The Basic Way of Drawing</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>

<font face="verdana,arial,helvetica" size="2"><h1><a name="thebasicwayofdrawing"></a>The Basic Way of Drawing</h1>
<BR>
You probably know more about Visual Basic drawing than I do. It’s not that I’m ignorant (though I admit to being weak in math); rather, the simple vector graphics I recommend just aren’t that difficult.</p>
<BR>
The fade trick I’m about to show you, however, is fun and isn’t what you might expect. You’ve no doubt seen the fade from black to blue on the setup screens of many Microsoft products. Looking at the output, I would have guessed that it was produced with some sort of palette manipulation. It’s not.</p>
<BR>
The Fade procedure simply draws adjacent lines with increasing color intensity. It uses optional arguments to enable defaults. For example, a simple Fade command with no arguments draws a blue fade from top to bottom of the current form. You can draw the fade on any form or picture box. You can specify red, green, or blue fades or any combination of the three. You can specify a horizontal or vertical fade—or both for a diagonal fade. Here are some examples, using named arguments:</p>
<pre><code>‘ Default black to blue vertical fade on current form<BR>Fade Me<BR>’ Make it blue to black<BR>Fade Me, LightToDark:=False<BR>’ Red horizontal fade on FBlit<BR>Fade FBlit, Red:=True, Horizontal:=True<BR>’ Violet vertical fade on picture box<BR>Fade pbTest(0), Red:=True, Blue:=True<BR>’ Black to white diagonal fade on current form<BR>Fade Me, Horizontal:=True, Vertical:=True, _<BR>     Red:=True, Green:=True, Blue:=True</code></pre>
<BR>
Fade draws the background of the Bit Blast program used later in this chapter (BITBLAST.VBP). You’ll see it in various figures, starting with Figure 7-6 on page 392, but it’s different each time because it is called with random values in the Form_Resize event:</p>
<pre><code>Private Sub Form_Resize()<BR>    Fade Me, Red:=Random(0, 1), Green:=Random(0, 1), _<BR>             Blue:=Random(0, 1), Horizontal:=Random(0, 1), _<BR>             Vertical:=Random(0, 1), LightToDark:=Random(0, 1)<BR>End Sub</code></pre>
<BR>
The Fade sub (with other effects in FUN.BAS) is long, but it takes only a few lines to do the real work. Most of the code saves and restores properties and handles defaults based on the optional arguments:</p>
<pre><code>Sub Fade(cvsDst As Object, _<BR>         Optional Red As Boolean = False, _<BR>         Optional Green As Boolean = False, _<BR>         Optional Blue As Boolean = True, _<BR>         Optional Vertical As Boolean = True, _<BR>         Optional Horizontal As Boolean = False, _<BR>         Optional LightToDark As Boolean = True)<BR>With cvsDst<BR>    ‘ Trap errors<BR>    On Error Resume Next<BR><BR>    ‘ Save properties<BR>    Dim fAutoRedraw As Boolean, ordDrawStyle As Integer<BR>    Dim ordDrawMode As Integer, iDrawWidth As Integer<BR>    Dim ordScaleMode As Integer<BR>    Dim rScaleWidth As Single, rScaleHeight As Single<BR>    fAutoRedraw = .AutoRedraw: iDrawWidth = .DrawWidth<BR>    ordDrawStyle = .DrawStyle: ordDrawMode = .DrawMode<BR>    rScaleWidth = .ScaleWidth: rScaleHeight = .ScaleHeight<BR>    ordScaleMode = .ScaleMode<BR>    ‘ Err set if object lacks one of previous properties<BR>    If Err Then Exit Sub<BR>    ‘ If you get here, object is OK (Printer lacks AutoRedraw)<BR>    fAutoRedraw = .AutoRedraw<BR><BR>    ‘ Set properties required for fade<BR>    .AutoRedraw = True<BR>    .DrawWidth = 3              ‘ Must be greater than 1 for dithering<BR>    .DrawStyle = vbInsideSolid  ‘ vbInvisible gives an interesting effect<BR>    .DrawMode = vbCopyPen       ‘ Try vbXorPen or vbMaskNotPen<BR>    .ScaleMode = vbPixels<BR>    .ScaleWidth = 256 * 2: .ScaleHeight = 256 * 2<BR><BR>    Dim clr As Long, i As Integer, x As Integer, y As Integer<BR>    Dim iRed As Integer, iGreen As Integer, iBlue As Integer<BR>    For i = 0 To 255<BR>        ‘ Set line color<BR>        If LightToDark Then<BR>            If Red Then iRed = 255 - i<BR>            If Blue Then iBlue = 255 - i<BR>            If Green Then iGreen = 255 - i<BR>        Else<BR>            If Red Then iRed = i<BR>            If Blue Then iBlue = i<BR>            If Green Then iGreen = i<BR>        End If<BR>        clr = RGB(iRed, iGreen, iBlue)<BR>        ‘ Draw each line of fade<BR>        If Vertical Then<BR>            cvsDst.Line (0, y)-(.ScaleWidth, y + 2), clr, BF<BR>            y = y + 2<BR>        End If<BR>        If Horizontal Then<BR>            cvsDst.Line (x, 0)-(x + 2, .ScaleHeight), clr, BF<BR>            x = x + 2<BR>        End If<BR>    Next<BR>    ‘ Put things back the way you found them<BR>    .AutoRedraw = fAutoRedraw: .DrawWidth = iDrawWidth<BR>    .DrawStyle = ordDrawStyle: .DrawMode = ordDrawMode<BR>    .ScaleMode = ordScaleMode<BR>    .ScaleWidth = rScaleWidth: .ScaleHeight = rScaleHeight<BR>End With<BR>End Sub</code></pre>
<BR>
The property settings are crucial to making the fade work accurately and efficiently. For example, fading slows to a crawl if you don’t set AutoRedraw. The vbInsideSolid draw style is the only one that works properly (although vbIn&shy;visible gives an interesting effect). The vbCopyPen draw mode ensures that you overwrite anything on the background rather than interact with it. Setting the scale properties makes it easier to draw in multiples of 256 (the number of color intensities) regardless of the size of the target. All these settings must be saved and restored in case someone else wants to draw on your fade with different settings.</p>
<BR>
Remember, you’re drawing the fade only to the current size of the target object. If you allow the object to be resized, you’ll need to put Fade in the Resize event. Since Fade is no speed demon, it might be better to make faded forms a fixed size, as the Bit Blast form is.</p>
<BR>
All the statements in the Fade function take advantage of the <i>With cvsDst </i>block except the Line statements. Visual Basic’s Line, PSet, and Circle statements use a nonstandard format that can’t be represented with a normal method syntax. The language parser would have to contain special-case code to handle these statements in a With block. So far, that code has not been written. The request was postponed in Visual Basic version 4 and then postponed again in version 5. </p>
<BR>
Although we’re using a naming convention (<i>cvsDst</i>) that implies a canvas type, the actual type is Object—and we’re paying the price with late binding. This is where we could use some public access to Visual Basic’s internal interfaces. I don’t know whether it really exists, and if so, whether they call it ICanvas, IDrawable, or IItsOurSecret, but whatever it’s named, Fade could draw a lot faster if it knew the interface of the object it’s drawing on. I shouldn’t have to write separate FadeForm, FadePictureBox, FadeUserControl, and FadePrinter procedures to get efficient drawing.</p>
<BR>
<b>Hardcore Drawing</b></p>
<BR>
Help is available for all you hardcore programmers who want to draw 3-D shapes in Visual Basic. The OpenGL library is already part of Windows NT, and you can use it on Windows 95 if you get the library through the Win32 Software Developer’s Kit. OpenGL supports three-dimensional drawing with shading, lighting, hidden surface removal, texturing, and who knows what else. I was afraid that if I started playing with it, I’d never finish this book so unfortunately you’re on your own. I know of several people who have used it successfully from Visual Basic.</p>
</font></BODY>
</HTML>
