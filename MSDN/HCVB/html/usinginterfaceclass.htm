<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Using an interface class</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>

<font face="verdana,arial,helvetica" size="2"><h1><a name="usinginterfaceclass"></a>Using an interface class</h1>
<BR>
Now let’s look at the generic FilterTextFile procedure (in FILTER.BAS). Notice that it takes an IFilter parameter:</p>
<pre><code>Sub FilterTextFile(filter As IFilter)<BR>    <BR>    BugAssert filter.Source &lt;&gt; sEmpty<BR>    ‘ Target can be another file or replacement of current file<BR>    Dim sTarget As String, fReplace As Boolean<BR>    sTarget = filter.Target<BR>    If sTarget = sEmpty Or sTarget = filter.Source Then<BR>        sTarget = MUtility.GetTempFile(“FLT”, “.”)<BR>        fReplace = True<BR>    End If<BR>    <BR>    ‘ Open input file<BR>    On Error GoTo FilterTextError1<BR>    Dim nIn As Integer, nOut As Integer<BR>    nIn = FreeFile<BR>    Open filter.Source For Input Access Read Lock Write As #nIn<BR><BR>    ‘ Open target output file<BR>    On Error GoTo FilterTextError2<BR>    nOut = FreeFile<BR>    Open sTarget For Output Access Write Lock Read Write As #nOut<BR><BR>    ‘ Filter each line<BR>    On Error GoTo FilterTextError3<BR>    Dim sLine As String, iLine As Long, eca As EChunkAction<BR>    Do Until EOF(nIn)<BR>        Line Input #nIn, sLine<BR>        iLine = iLine + 1<BR>        eca = filter.Translate(sLine, iLine)<BR>        Select Case eca<BR>        Case ecaAbort<BR>            GoTo FilterTextError3   ‘ Stop processing<BR>        Case ecaTranslate<BR>            Print #nOut, sLine      ‘ Write modified line to output<BR>        Case ecaSkip<BR>                                    ‘ Ignore<BR>        Case Else<BR>            BugAssert True          ‘ Should never happen<BR>        End Select<BR>    Loop<BR>    <BR>    ‘ Close files<BR>    On Error GoTo FilterTextError1<BR>    Close nIn<BR>    Close nOut<BR>    If fReplace Then<BR>        ‘ Destroy old file and replace it with new one<BR>        Kill filter.Source<BR>        On Error Resume Next   ‘ No more errors allowed<BR>        Name sTarget As filter.Source<BR>        ‘ If this fails, you’re in trouble<BR>        BugAssert Err = 0<BR>    End If<BR>    Exit Sub<BR>        <BR>FilterTextError3:<BR>    Close nOut<BR>FilterTextError2:<BR>    Close nIn<BR>FilterTextError1:<BR>    MErrors.ErrRaise Err<BR>End Sub</code></pre>
<BR>
If you study the code carefully, you can see that it does not depend in any way on what the filter actually does. FilterTextFile just loops through each line of Source, calling the Translate method on each line and writing the result to Target. It doesn’t matter what file names Source or Target contain or what Translate does to the text.</p>
<BR>
If you have read the previous edition of this book, you might remember that the old version of FilterTextFile took an Object parameter rather than an IFilter parameter. The description of the old FilterTextFile was largely a diatribe on what real object-oriented languages did and how that compared to Visual Basic’s pitiful version of polymorphism. Well, that flame is gone. Visual Basic’s version of polymorphism didn’t come out the way I expected. But, the functionality is there, and…well, judge for yourself.</p>
<BR>
Now that FilterTextFile takes an IFilter, you can’t just pass a form or a ListBox or some other random object. Any object you pass must have a class that implements IFilter. Passing an inappropriate object causes a polite error at compile time rather than a rude one at run time. More importantly, Visual Basic can bind the IFilter calls at compile time, making polymorphic classes almost as fast as non-polymorphic ones. That’s a big turnaround from version 4 where polymorphic algorithms were often as much as 10 times slower than comparable non-polymorphic algorithms.</p>
<BR>
I’ve shown FilterTextFile here because it’s more interesting, but I’ll be using FilterText in some of the examples. FilterText does a similar operation, but it assumes that Source and Target contain a text string with each line of text separated by a carriage return/line feed combination. The code just grabs lines of text from Source, filters them, and writes the result to Target. The Bug Wizard uses FilterTextFile and the Global Wizard uses FilterText for reasons that need not concern us. There’s nothing sacred about Source and Target. You could write filter procedures that assume Source and Target are URLs or database record identifiers. </p>
<BR>
<b>NOTE</b>&#09;The error trap in FilterTextFile doesn’t have anything to do with polymorphic classes, but it does illustrate a stair-stepped error trap. Often, when something goes wrong while you’re building something with a series of Basic statements, you need to unbuild <BR>it in the opposite order, undoing only the parts you have finished. A carefully designed series of error traps can take you back to <BR>the initial state.</p>
</font></BODY>
</HTML>
