<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Comparing and Swapping</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>

<font face="verdana,arial,helvetica" size="2"><h1><a name="comparingswapping"></a>Comparing and Swapping</h1>
<BR>
Sorting is a simple operation. You compare the elements and swap the ones that are out of order until all are in order. A QuickSort does this differently than a Heap sort or an Insertion sort does, but all that matters to the programmer using the procedure is how you compare and swap. Both these operations can vary greatly, depending on what you’re sorting and how you want to sort it.</p>
<BR>
By changing the comparison routine, you can control whether data is sorted in ascending or descending order and other aspects of sorting. You can sort integers by value only, but you can sort strings by case-sensitive value, by case-insensitive value, by length, by the sums of the Roman numeral values of the characters, or by whatever you choose. To sort objects, you’ll probably want to compare based on a property such as size, color, name, position, or type.</p>
<BR>
The sort algorithm always works the same no matter what you’re sorting, but the compare operation varies. You need a way to combine a generic sort routine with a specific compare routine. The way to do this is to pass in a helper object that has Compare and Swap methods with the appropriate arguments (enforced through an interface). If you don’t like my Compare and Swap methods, define your own helper class. We’re going to get to helper classes in a moment. For now we’re interested only in the methods. For example, here’s <BR>a very simple Compare method that sorts numeric data in ascending order:</p>
<pre><code>Private Function ISortHelper_Compare(v1 As Variant, _<BR>                                     v2 As Variant) As Integer<BR>    If v1 &lt; v2 Then<BR>        ISortHelper_Compare = -1<BR>    ElseIf v1 = v2 Then<BR>        ISortHelper_Compare = 0<BR>    Else<BR>        ISortHelper_Compare = 1<BR>    End If<BR>End Function</code></pre>
<BR>
You can compare numeric values (and non–case-sensitive strings) with relational operators. You return negative, zero, or positive (usually <font face="Symbol"><span style="font-family:symbol">&#45;</span></font>1, 0, or 1), depending on whether the first value is less than, equal to, or greater than the second value. No matter how complex your comparison, only these three results are valid. (Ignore errors for now.) Incidentally, the Basic StrComp function works the same way, for the same reasons.</p>
<BR>
The SortArray sub uses Compare this way:</p>
<pre><code>If .Compare(aTarget(iFirst), aTarget(iLast)) &gt; 0 Then<BR>    .Swap aTarget(iFirst), aTarget(iLast)<BR>End If</code></pre>
<BR>
Because this code simply checks to see whether the value is greater than 0, Compare could still work if it returned only 1 and 0. Comparison routines are also used by search routines (as you’ll see in “Binary Search,” page 295), and these routines must be able to distinguish all three results.</p>
<BR>
Here’s a specific Compare function from the CSortHelper class (SORTHELP.CLS):</p>
<pre><code>Private Function ISortHelper_Compare(v1 As Variant, _<BR>                                     v2 As Variant) As Integer<BR>    ‘ Use string comparisons only on strings<BR>    If TypeName(v1) &lt;&gt; “String” Then esmMode = esmSortVal<BR>    <BR>    Dim i As Integer<BR>    Select Case esmMode<BR>    ‘ Sort by value (same as esmSortBin for strings)<BR>    Case esmSortVal<BR>        If v1 &lt; v2 Then<BR>            i = -1<BR>        ElseIf v1 = v2 Then<BR>            i = 0<BR>        Else<BR>            i = 1<BR>        End If<BR>    ‘ Sort case-insensitive<BR>    Case esmSortText<BR>        i = StrComp(v1, v2, 1)<BR>    ‘ Sort case-sensitive<BR>    Case esmSortbin<BR>        i = StrComp(v1, v2, 0)<BR>    ‘ Sort by string length<BR>    Case esmSortLen<BR>        If Len(v1) = Len(v2) Then<BR>            If v1 = v2 Then<BR>                i = 0<BR>            ElseIf v1 &lt; v2 Then<BR>                i = -1<BR>            Else<BR>                i = 1<BR>            End If<BR>        ElseIf Len(v1) &lt; Len(v2) Then<BR>            i = -1<BR>        Else<BR>            i = 1<BR>        End If<BR>    End Select<BR>    If fHiToLo Then i = -i<BR>    ISortHelper_Compare = i<BR>End Function</code></pre>
<BR>
This code tests the private class variables <i>esmMode </i>(of Enum type ESortMode) and <i>fHiToLo.</i></p>
<BR>
Swapping presents similar problems. To swap data, you simply assign the first element to a temporary variable, assign the second element to the first, and assign the temporary variable to the second. Here’s the default swap routine for SortArray:</p>
<pre><code>Private Sub ISortHelper_Swap(v1 As Variant, v2 As Variant)<BR>    Dim vT As Variant<BR>    vT = v1<BR>    v1 = v2<BR>    v2 = vT<BR>End Sub</code></pre>
<BR>
This works well for simple types, but if you’re swapping objects, files, or some other data, you’ll probably need a different swap routine. For example, if you were swapping files, you might want to simply swap the names rather than actually exchange all the data. Also, the sort, shuffle, and search procedures in this chapter will need a custom helper class to work with object variants. For one thing, you’ll need to use the Set statement to make assignments in the swap routines. For another, you’ll have to specify which properties to work on in the compare routines.</p>
</font></BODY>
</HTML>
