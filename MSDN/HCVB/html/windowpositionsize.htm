<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Windows position and size</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>

<font face="verdana,arial,helvetica" size="2"><h1><a name="windowpositionsize"></a>Window position and size</h1>
<BR>
Windows knows everything that you need to know about every window’s position—both the rectangle of the window and the rectangle of its client area. A rectangle includes the screen coordinates of the left, right, top, and bottom, thus describing both the size and the position of the window. Various Windows API functions use the rectangle coordinates to control the size and the position of a window.</p>
<BR>
Of course, you usually won’t need these functions in Visual Basic. When you’re working on forms and controls, it’s easier to read or modify the Left, Top, Width, and Height attributes or to use the Move method. If you’re interested only in the client area, you can use the ScaleLeft, ScaleTop, ScaleWidth, and Scale&shy;Height properties.</p>
<BR>
Occasionally, however, you’ll need to perform operations that Visual Basic does not support. When you convert Visual Basic rectangles to Windows rectangles, the following utility functions can make your code shorter:</p>
<pre><code>Function xRight(obj As Object) As Single<BR>    xRight = obj.Left + obj.Width<BR>End Function<BR><BR>Function yBottom(obj As Object) As Single<BR>    yBottom = obj.Top + obj.Height<BR>End Function</code></pre>
<BR>
Just be sure that anything you pass to these functions really has Left, Top, Width, and Height properties.</p>
<BR>
WinWatch has to solve a window coordinate problem. It must find the window located at a given position—specifically, the position the user points to. The cmdPoint_Click event toggles point mode on and off, the Form_MouseMove event displays information for the window to which the user is currently pointing, and the Form_MouseDown event selects the window being pointed to as the current window, forcing an update in various list boxes. Let’s look at the code that makes this happen, starting with cmdPoint_Click:</p>
<pre><code>Private Sub cmdPoint_Click()<BR>    If cmdPoint.Caption = “&amp;Point” Then<BR>        fCapture = True<BR>        cmdPoint.Caption = “End &amp;Point&quot;<BR>        Call SetCapture(Me.hWnd)<BR>        lblMsg.Caption = “Move mouse for window information&quot;<BR>    Else<BR>        fCapture = False<BR>        cmdPoint.Caption = “&amp;Point&quot;<BR>        ReleaseCapture<BR>        lblMsg.Caption = sMsg<BR>    End If<BR>End Sub</code></pre>
<BR>
This sub toggles the form-level flag <i>fCapture</i>, changes messages and captions, and, most important, sets the form to capture all mouse movements anywhere on the screen. Normally, each window captures only its own mouse events; but with SetCapture on, you get everything.</p>
<BR>
The Form_MouseMove sub illustrates some of the problems involved in converting Windows screen coordinates to Visual Basic form coordinates:</p>
<pre><code>Private Sub Form_MouseMove(Button As Integer, Shift As Integer, _<BR>                           x As Single, y As Single)<BR>    If fCapture Then<BR>        Dim pt As POINTL, hWnd As Long<BR>        Static hWndLast As Long<BR>        ' Set point and convert it to screen coordinates<BR>        pt.x = x / Screen.TwipsPerPixelX<BR>        pt.y = y / Screen.TwipsPerPixelY<BR>        ClientToScreen Me.hWnd, pt<BR>        ' Find window under it<BR>        hWnd = WindowFromPoint(pt.x, pt.y)<BR>        ' Update display only if window has changed<BR>        If hWnd &lt;&gt; hWndLast Then<BR>            lblWin.Caption = GetWndInfo(hWnd)<BR>            hWndLast = hWnd<BR>        End If<BR>    End If<BR>End Sub</code></pre>
<BR>
This code does nothing unless capture mode is on (as indicated by <i>fCapture</i>). If it is on, the mouse position that is received by the form is specified in twips, so you must divide by the TwipsPerPixelX or TwipsPerPixelY property of the Screen object to get <i>x</i> or <i>y </i>in pixels. These adjusted values are put in a POINTL variable (Windows calls it POINT, but that name conflicts with the Visual Basic Point method) and passed to ClientToScreen to make them relative to the screen rather than to WinWatch. The adjusted values can then be passed to the Window&shy;FromPoint function, which will return the window under the mouse pointer.</p>
<BR>
WindowFromPoint uses one of the ugliest hacks in this book. To understand how it works, look carefully at the C prototypes for both ClientToScreen and WindowFromPoint:</p>
<pre><code>BOOL ClientToScreen(HWND hWnd, LPPOINT lpPoint);<BR>HWND WindowFromPoint(POINT Point);</code></pre>
<BR>
In ClientToScreen, the POINTL variable is passed as a pointer (by reference, in Visual Basic terms). Most functions in the Windows API pass structures this <BR>way. WindowFromPoint, its cousin ChildWindowFromPoint, and a few others break the rules by passing POINT parameters by value. You might remember from Chapter 2<b> </b>that structures (UDTs in Visual Basic) are always passed by reference in order to save stack space. But take a look at the size of a POINTL variable:</p>
<pre><code>Public Type POINTL<BR>    x As Long<BR>    y As Long<BR>End Type</code></pre>
<BR>
You have to know a little Windows history to understand the problem. In 16-bit mode, a POINT was two Integers, which equaled one Long. A pointer is also a Long. You would gain nothing if you passed by reference. Apparently, a performance-conscious designer of the first version of Windows decided to save a few clock cycles by passing by value, never anticipating that Windows might someday be ported to 32 bits. Well, it turns out that in 32-bit C you can pass a 64-bit POINTL variable by value. It might not be efficient, but at least it’s portable. In Visual Basic, however, you can’t pass a UDT variable by value, period—not 16-bit, not 32-bit, not 64-bit. Visual Basic could have supported this for small UDTs, but the Visual Basic designers must have assumed that no one would ever want to do it.</p>
<BR>
But there is an indirect way of passing a 64-bit structure by value. When you pass any argument, the processor pushes the arguments onto the stack. It turns out that 32-bit Intel processors always push in 32-bit chunks. When you pass a 64-bit chunk, the processor actually pushes two 32-bit values. To make this work in Visual Basic, you make explicit what’s actually happening under the surface. The following function is in the Windows API type library, but a Declare statement would look like this:</p>
<pre><code>Declare Function WindowFromPoint Lib “USER32” _<BR>    (ByVal xPoint As Long, ByVal yPoint As Long) As Long</code></pre>
<BR>
In your code, you must pass the parts separately rather than in one chunk.</p>
<pre><code>hWnd = WindowFromPoint(pt.x, pt.y)</code></pre>
<BR>
If this seems complicated, just be glad that 16-bit Windows is dead. The portable version of this hack described in the last version of my book was twice as complicated.</p>
<BR>
You might want to examine the Form_MouseDown event procedure to get more details on how a window being clicked is identified and converted into the current window.</p>
</font></BODY>
</HTML>
