<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Using Bitmaps</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>

<font face="verdana,arial,helvetica" size="2"><h1><a name="usingbitmaps"></a>Using Bitmaps</h1>
<BR>
WinWatch needs to display a selected bitmap in a picture box. There are lots of ways to do this, but we’re going to do it the easy way. The reason it’s easy is because I’ve hidden all the ugly details in procedures that we’ll look at later. Here’s the easy part:</p>
<pre><code>Sub ShowBitmap(ByVal hMod As Long, sBitmap As String)<BR>With pbResource<BR><BR>    Dim hPal As Long, hPal2 As Long<BR>    ‘ Convert resource into bitmap handle<BR>    hResourceCur = LoadBitmapPalette(hMod, sBitmap, hPal)<BR>    If hResourceCur = hNull Then<BR>        pbResource.Print “Can’t load bitmap: “ &amp; sCrLf &amp; sCrLf &amp; _<BR>                         WordWrap(ApiError(Err.LastDllError), 25)<BR>        Exit Sub<BR>    End If<BR>    ‘ Convert hBitmap to Picture (clip anything larger than picture box)<BR>    .Picture = BitmapToPicture(hResourceCur, hPal)<BR>    ‘ Set the form palette to use this picture’s palette<BR>    Palette = .Picture<BR>    ‘ Make sure palette is realized<BR>    Refresh<BR>    DoEvents<BR>    ‘ Draw the palette<BR>    DrawPalette pbResource, hPal, .Width, .Height * 0.1, 0, .Height * 0.9<BR>    ‘ Record the type for cleanup<BR>    ordResourceLast = RT_BITMAP<BR>End With<BR>End Sub</code></pre>
<BR>
The first step is to convert the resource into a bitmap handle. Remember, at this point the <i>sBitmap </i>string will be either the name of a bitmap resource (MyBitmap) </p>
<BR>
<b>The Zen of Windows Memory Management</b></p>
<BR>
Normally, the Windows Way of managing memory is the least of your worries. Dim, ReDim, Private, Public, and Static do it all for you, and, for the most part, transparently. You don’t ordinarily use the Windows memory functions directly because they deal with pointers, and Visual Basic doesn’t do pointers. But there are exceptions to every rule, and loading unknown resources is one of them.</p>
<BR>
Here’s a 30-second introduction to the rarely needed art of Windows global memory management:
<ol>
<li>
Get a handle to a global memory block. You can create a generic one with GlobalAlloc, or you can create a resource block by calling Load&shy;Resource on the value returned by FindResource. Use resource functions instead of global memory functions on resource blocks. You have several choices for how you want the memory to be allocated, but I’ll leave you to the documentation.<BR><BR></li>
<li>
Measure the memory with GlobalSize (or remember its size if you created it with GlobalAlloc). If it’s a resource, use SizeofResource. If you don’t know the size of a global memory block, there won’t be much you can safely do with it in Visual Basic.<BR><BR></li>
<li>
Lock the memory handle with GlobalLock (or LockResource if it’s a resource handle). This means that you ask the memory manager to let you play with the memory for a while. If your request is granted, you’ll be given a pointer to the memory and other users will be locked out of it.<BR><BR></li>
<li>
Have your way with the pointer and the stuff it points to. This is the tricky part because, in Visual Basic, a pointer is like a handle—all you can do with it is pass it on to another API function. For example, you can use CopyMemory to copy the memory of a pointer to a Visual Basic string. (You must know the size to do this; see step 2.) If you dare, you can modify the string and copy it back to the pointer (again using CopyMemory). If you change the size of the data, you’ll need to call GlobalReAlloc to change the size of the original block before copying. You can find other API functions to pass your memory pointers to (such as sndPlaySound, described later).<BR><BR></li>
<li>
When you’re done with the block, use GlobalUnlock to release the pointer back to the system. Some kinds of global memory don’t need to be unlocked, but it does no harm and might save you from a horrible fate if you mix up your fixed and movable memory. I always <BR>unlock. The exception to this rule is that you don’t need to unlock re&shy;sources. In fact, the Win32 UnlockResource function is nothing more than a C macro that does nothing. If you like to be consistent, you can call the do-nothing UnlockResource function in the PICTOOL.BAS module.<BR><BR></li>
<li>
Free the memory if you created it; leave it alone if Windows created <BR>it. Use GlobalFree to free memory you created with GlobalAlloc; use FreeResource to free memory loaded with LoadResource.</li>
</ol>
<BR>
or, more likely, a numeric resource ID converted into a string (#01001). In days of old, we would have read the resource with the simpler LoadBitmap API function, but LoadBitmap only loads device dependent bitmaps. The new LoadImage function loads any bitmap, including device independent bitmaps (DIB), and it can load them from files as well as from resources. It’s also more flexible for loading icons and cursors, as we’ll see later. Unfortunately, when LoadImage loads a bitmap with a palette, it throws away any accompanying palette. I had to write my own LoadBitmapPalette function to get both. But ignore the palette issue for now.</p>
<BR>
The <i>hResourceCur </i>returned by LoadBitmapPalette is actually a bitmap handle. At this point, I could work directly on the handle. I could select the bitmap into the DC of the picture box. I could create a memory DC, select the bitmap into it, and then blit the memory DC to the DC of the picture box. I demonstrated some of these GDI choices in Chapter 7. But what I really want to do with that Windows-style handle is turn it into a Visual Basic–style picture. Once I have a picture, I can assign it to various Picture properties or blit it with the PaintPicture method.</p>
<BR>
The BitmapToPicture function does the conversion. Again, I’m ignoring the palette issue until after I check out the COM magic that makes picture conversion possible.</p>
</font></BODY>
</HTML>
