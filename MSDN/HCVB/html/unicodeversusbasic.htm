<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Unicode Versus Basic</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>

<font face="verdana,arial,helvetica" size="2"><h1><a name="unicodeversusbasic"></a>Unicode Versus Basic</h1>
<p>
Stringwise, we are cursed to live in interesting times. The world according to Microsoft (and many other international companies) is moving from ANSI to Unicode characters, but the transition isn’t exactly a smooth one.</p>
<p>
Most of the Unicode confusion comes from the fact that we are in the midst of a comprehensive change in the way characters are represented. The old way uses the ANSI character set for the first 256 bytes but reserves some characters as double byte character prefixes so that non-ANSI character sets can be represented. This is very efficient for the cultural imperialists who got there first with Latin characters, but it’s inefficient for those who use larger character sets such as Chinese ideograms and Sumerian hieroglyphics. Unicode represents all characters in two bytes. This is inefficient for the cultural imperialists (although they still get the honor of claiming most of the first 128 characters with zero in the upper byte), but it’s more efficient (and more fair) for the rest of the world. Instead of having 256 unique characters, you can have 65,535—enough to handle all the characters of almost all the world’s languages.</p>
<p>
Eventually, everybody will use Unicode, but different systems have chosen different ways of dealing with the transition.
<ul>
<li>
<b>Windows 3<i>.</i>x<i>.</i></b>&nbsp;Doesn’t know a Unicode from a dress code and <BR>never will.<br><br></li>
<li>
<b>16-bit COM.</b>&nbsp;Ditto.<br><br></li>
<li>
<b>Windows NT.</b>&nbsp;Was written from the ground up—first to do the right thing (Unicode) and second to be compatible (ANSI). All strings are Unicode internally, but Windows NT also completely supports ANSI <BR>by translating internal Unicode strings to ANSI strings at runtime. Ob&shy;- viously, Windows NT programs that use Unicode strings directly can be more efficient by avoiding frequent string translations, although just as obviously, Unicode strings take about twice as much data space.<br><br></li>
<li>
<b>Windows 95.</b>&nbsp;Is based largely on Windows 3.<i>x</i> code and therefore uses ANSI strings internally. Furthermore, it doesn’t support Unicode strings even indirectly in most contexts—with one big exception.<br><br></li>
<li>
<b>32-bit Component Object Module.</b>&nbsp;Was written from the ground up to do the right thing (Unicode) and to hell with compatibility. COM doesn’t do ANSI. The COM string types—OLESTR and BSTR—are Unicode all the way. Any 32-bit operating system that wants to do COM must have at least partial support for Unicode. Windows 95 has just enough Unicode support to make COM work.<br><br></li>
<li>
<b>Visual Basic.</b>&nbsp;The Basic designers had to make some tough decisions about how they would represent strings internally. They might have chosen ANSI because it’s the common subset of Windows 95 and Windows NT, and converted to Unicode whenever they needed to deal with COM. But since Visual Basic version 5 is COM inside and out (as Chapters 3 and 10 will pound into your head), they chose Unicode as the internal format, despite potential incompatibilities with Windows 95. The Unicode choice caused many problems and inefficiencies both for the developers of Visual Basic and for Visual Basic developers—but the alternative would have been worse.<br><br></li>
<li>
<b>The Real World.</b>&nbsp;Most existing data files use ANSI. The WKS, DOC, BAS, TXT, and most other standard file formats use ANSI. If a system uses Unicode internally but needs to read from or write to common data formats, it must do Unicode to ANSI conversion. Someday there will be Unicode data file formats, but it might not happen in your <BR>lifetime.</li>
</ul>
<p>
What does this mean for you? Trouble.</p>
</font></BODY>
</HTML>
