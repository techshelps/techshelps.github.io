<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Finding Items</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>

<font face="verdana,arial,helvetica" size="2"><h1><a name="findingitems"></a>Finding Items</h1>
<BR>
Rather than examining all of the code, let’s just look at a few interesting properties. The Item property illustrates indexing by number or by string, and its Property Get procedure has a quirky return value that changes depending on the argument.</p>
<BR>
Remember that the Item property is the default. It can be used for reading items:</p>
<pre><code>Debug.Print srt(3)<BR>Debug.Print srt(&quot;Lion&quot;)</code></pre>
<BR>
Numeric indexing of XListBoxPlus works like using the List property of ListBox, except that it is one-based. String indexing does a lookup on the data:</p>
<pre><code>Property Get Item(ByVal vIndex As Variant) As String<BR>    If VarType(vIndex) &lt;&gt; vbString Then<BR>        ' For numeric index, return string value<BR>        Item = lst.List(vIndex - 1)<BR>    Else<BR>        ' For string index, return matching index or 0 for none<BR>        Item = Match(vIndex)<BR>        If Item = 0 Then ErrRaise eseItemNotFound<BR>    End If<BR>End Property</code></pre>
<BR>
The Match function is used here and in many other parts of the implementation to do string lookups. How do you suppose it works? If you remember Chapter 6, you might want to use LookupItem, which is a wrapper for the SendMessage API function with the LB_FINDSTRING message. But this message is case insensitive, and that’s not what you need for searching some kinds of sorted data. Furthermore, Windows doesn’t know that the internal list box is sorted; the only way it can find an item is with a linear search. But you know that it’s sorted. The most efficient way to find a sorted item is with a bi-<BR>nary search—the same one we talked about in Chapter 5. Here’s the code for Match: </p>
<pre><code>Private Function Match(ByVal sItem As String) As Integer<BR>    Dim iPos As Integer<BR>    Select Case esmlMode<BR>    Case esmlUnsorted, esmlShuffle<BR>        Match = LookupItem(lst, sItem) + 1<BR>    Case Else   ' Some kind of sorting<BR>        If BSearch(sItem, iPos) Then Match = iPos + 1 Else Match = 0<BR>    End Select<BR>End Function</code></pre>
<BR>
Either way, Match will come up with an index to the item, if it exists. Match is also used in the Item Property Let, which enables you to assign items: </p>
<pre><code>.Item(3) = &quot;Deer&quot;<BR>.Item(&quot;Lion&quot;) = &quot;Big Cat&quot;</code></pre>
<BR>
It works this way:</p>
<pre><code>Property Let Item(ByVal vIndex As Variant, sItemA As String)<BR>    ' For string index, look up matching index<BR>    If VarType(vIndex) = vbString Then<BR>        vIndex = Match(vIndex)<BR>        ' Fail if old item isn't found or if new item is found<BR>        If vIndex = 0 Then ErrRaise eseItemNotFound<BR>        If Match(sItemA) Then ErrRaise eseDuplicateNotAllowed<BR>    End If<BR>    ' Assign value by removing old and inserting new<BR>    Remove vIndex<BR>    Add sItemA<BR>End Property</code></pre>
<BR>
This code converts a string index to a numeric index and then uses the Remove and Add methods to assign it in the proper sort order. I could go on to show how Remove finds and deletes items, but the code is the same as the Item Property Get. The Add method is more interesting:</p>
<pre><code>Sub Add(sItem As String, Optional iPos As Integer = 1)<BR>With lst<BR>    ' Adding differs depending on the mode<BR>    Select Case esmlMode<BR>    Case esmlUnsorted<BR>        ' Add where directed (start is default)<BR>        .AddItem sItem, iPos - 1<BR>    Case esmlShuffle<BR>        ' Add at random position<BR>        iPos = GetRandom(0, .ListCount - 1)<BR>        If .ListCount Then<BR>            .AddItem sItem, iPos<BR>        Else<BR>            .AddItem sItem<BR>        End If<BR>        <BR>    Case Else   ' Some kind of sorting<BR>        ' Binary search for the item<BR>        If BSearch(sItem, iPos) Then<BR>            ErrRaise eseDuplicateNotAllowed<BR>        Else<BR>            ' Insert at sorted position<BR>            If .ListCount Then<BR>                .AddItem sItem, iPos<BR>            Else<BR>                .AddItem sItem<BR>            End If<BR>        End If<BR>    End Select<BR>End With<BR>End Sub</code></pre>
<BR>
Add recognizes the optional position argument in unsorted modes, but ignores it if the data is sorted. The data is always inserted at the correct position so that the list remains sorted. The only time you actually have to sort the data is if you change the sort mode. Notice that the code raises an error if you try to insert an item that already exists into a sorted list. Duplicate items could have been permitted, but I made a design judgment that most applications that want sorted lists would not want duplicates.</p>
<BR>
There’s a lot more to XListBoxPlus, but I’ll leave you to explore the rest.</p>
</font></BODY>
</HTML>
