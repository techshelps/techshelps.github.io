<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Unique process IDs</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>

<font face="verdana,arial,helvetica" size="2"><h1><a name="uniqueprocessids"></a>Unique process IDs</h1>
<p>
What can you do with a process ID? Two things. You can pass it to OpenProcess to get a process handle, or you can use it for the same thing Windows uses it for—a unique identifier of the process. A process handle can’t serve this purpose because there might be multiple handles to the same process. WinWatch stores process IDs in the <i>ItemData</i> array of the Processes list box. It stores top window handles in the <i>ItemData</i> array of the Top Windows list box. Since it’s possible to get a process ID from a top window handle and vice versa, WinWatch can use the <i>ItemData </i>information to keep all the list boxes in sync.</p>
<p>
Whenever a user clicks on any of the list boxes or takes any other action that could change their contents, the UpdateDisplay procedure is called. This procedure is the heart of WinWatch logic where all exceptions and special cases are worked out. I’m not particularly proud of this procedure, but I can say it’s more structured than the baling wire code that held previous versions of Win&shy;Watch together.</p>
<p>
I’ll let you study UpdateDisplay on your own, but I would like to make one <BR>minor point about the event procedures that call it. They use a module-level <i>fInClick</i> flag to protect agains circular references. For example, the <i>lstTopWin&shy;_Click</i> procedure calls UpdateDisplay, which might set the ListIndex property of <i>lstTopwin</i>, which would call <i>lstTopWin_Click</i>, which would call UpdateDis&shy;play, which might set the ListIndex property of <i>lstTopWin</i>, and so on. You have the potential for an infinite call cycle, or, depending on the program logic, perhaps just one extra call. Instead the <i>lstTopWin_Click</i> procedure checks the module-level <i>fInClick </i>flag and exits immediately if it is True. If it’s False, the procedure sets <i>fInClick </i>to True and then calls UpdateDisplay. You might want to use a similar strategy in your programs to guard against recursive Click events.</p>
</font></BODY>
</HTML>
