<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>An Object-Oriented Way of Prime Numbers</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>

<font face="verdana,arial,helvetica" size="2"><h1><a name="anobject-orientedwayofprimenumbers"></a>An Object-Oriented Way of Prime Numbers</h1>
<BR>
One way to make the program object-oriented is to turn the sieve function into a method that fills an array of prime numbers passed by reference. The CSieve class does this through the AllPrimes method. The code is very similar to the local sieve function. The problem with this kind of method is that you must calculate all the prime numbers before you can get the first one. But some clients can’t wait. Those quink scientists I mentioned earlier, for example, want a steady stream of numbers fed to them one at a time.</p>
<BR>
This is the classic trade-off you’ll come to know in COM design. The purpose of any server is to transfer data across boundaries. Often, setting up the transfer is the most expensive part. You can be more efficient by passing larger chunks of data. But the larger the chunk, the longer the client has to wait. In this exercise, you’ll be testing the extremes—all at once versus one at a time. <BR>In real programs, you might want to compromise by transferring medium-sized chunks.</p>
<BR>
The trick in getting numbers one at a time is to break the sieve function—which seems like an integrated whole—into its parts. Here’s what sieve really does:
<ul>
<li>
Keeps its state (number of primes, current number) in local variables<BR><BR></li>
<li>
Initializes an array to False by redimensioning it<BR><BR></li>
<li>
Loops through each potential prime number<BR><BR></li>
<li>
Marks out all multiples of primes<BR><BR></li>
<li>
Counts the primes as it finds them</li>
</ul>
<BR>
You can break these tasks into the following members, methods, and properties:
<ul>
<li>
The state is kept in private variables shared by all the methods and properties rather than in local variables. This includes the array of flags for each potential prime (<i>af</i>), the number currently being tested (<i>iCur</i>), the maximum prime (<i>iMaxPrime</i>), and the count of primes (<i>cPrime</i>).<BR><BR></li>
<li>
A ReInitialize method resets all the internal variables and starts counting again from 0.<BR><BR></li>
<li>
A MaxPrime property sets the upper bound on the search for primes. From a user’s viewpoint, it would be better not to have a maximum and instead to simply calculate whether each number is a prime without reference to later primes. But you’d have to turn to someone other than Eratosthenes for an algorithm. So let’s stick with the sieve. When you change MaxPrime, you break the algorithm. Therefore, the Max&shy;Prime Property Let procedure must call ReInitialize to start counting from 0.<BR><BR></li>
<li>
A NextPrime property calculates and returns the next prime.<BR><BR></li>
<li>
A Primes property (read-only) tells you how many prime numbers have been counted so far.</li>
</ul>
<BR>
Here’s the code to implement these methods and properties:</p>
<pre><code>Private af() As Boolean, iCur As Integer<BR>Private iMaxPrime As Integer, cPrime As Integer<BR><BR>Private Sub Class_Initialize()<BR>    ‘ Default size is largest integer<BR>    iMaxPrime = 32766<BR>    ReInitialize<BR>End Sub<BR><BR>Sub ReInitialize()<BR>    ReDim af(0 To iMaxPrime)<BR>    iCur = 1: cPrime = 0<BR>End Sub<BR><BR>Property Get NextPrime() As Integer<BR>    ‘ Loop until you find a prime or overflow array<BR>    iCur = iCur + 1<BR>    On Error GoTo OverMaxPrime<BR>    Do While af(iCur)<BR>        iCur = iCur + 1<BR>    Loop<BR>    ‘ Cancel multiples of this prime<BR>    Dim i As Long<BR>    For i = iCur + iCur To iMaxPrime Step iCur<BR>        af(i) = True<BR>    Next<BR>    ‘ Count and return it<BR>    cPrime = cPrime + 1<BR>    NextPrime = iCur<BR>OverMaxPrime:       ‘ Array overflow comes here<BR>End Property<BR><BR>Property Get MaxPrime() As Integer<BR>    MaxPrime = iMaxPrime<BR>End Property<BR><BR>Property Let MaxPrime(iMaxPrimeA As Integer)<BR>    iMaxPrime = iMaxPrimeA<BR>    ReInitialize<BR>End Property<BR><BR>Property Get Primes() As Integer<BR>    Primes = cPrime<BR>End Property</code></pre>
<BR>
As you can see, the NextPrime property does most of the work. It looks quite different from the Sieve function, but it does essentially the same thing. You might need to study both the Sieve function and the NextPrime property for a minute to see the connection.</p>
<BR>
The code that calls the class methods looks a little different from the code that calls the function.</p>
<pre><code>Case estBasicLocalClass<BR>    ‘ Basic local class<BR>    Dim sieveLocal As New CSieve<BR>    sieveLocal.MaxPrime = txtMaxPrime.Text<BR>    If chkAll = vbUnchecked Then<BR>        ‘ Get one at a time<BR>        ms = timeGetTime()<BR>        For i = 1 To cIter<BR>            sieveLocal.ReInitialize<BR>            Do<BR>                iPrime = sieveLocal.NextPrime<BR>                If fDisplay And iPrime Then<BR>                    lstOutput.AddItem iPrime<BR>                    lstOutput.TopIndex = lstOutput.ListCount - 1<BR>                    lstOutput.Refresh<BR>                End If<BR>            Loop Until iPrime = 0<BR>        Next<BR>        txtTime.Text = timeGetTime() - ms<BR>        txtPrimes.Text = sieveLocal.Primes<BR>    Else<BR>        ‘ Get all at once<BR>        §</code></pre>
<BR>
The code calling the AllPrimes method to get all the primes at once looks a lot like the functional version, so there’s no need to show it here.</p>
</font></BODY>
</HTML>
