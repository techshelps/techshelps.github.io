<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Fastest Versus Safest</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>

<font face="verdana,arial,helvetica" size="2"><h1><a name="fastestversussafest"></a>Fastest Versus Safest</h1>
<BR>
<i>Bruce:</i> OK, so we’ve optimized this code, and we’re going to get a giant performance benefit. Anything else?</p>
<BR>
<i>Jane:</i> What happens if you pass GetToken an empty string?</p>
<BR>
<i>Bruce:</i> Why would you do that?</p>
<BR>
<i>Joe:</i> Maybe just out of orneriness.</p>
<BR>
<i>Jane:</i> Or maybe you’re parsing a file a line at a time, and some lines are blank. I just want to know whether you’re handling boundaries.</p>
<BR>
<i>Bruce:</i> I guess I’m not sure what would happen. I suppose a user might also pass an empty string for the separators. What else could go wrong?</p>
<BR>
<i>Archaeologist’s Note: An interminable discussion about error handling has been edited out. Here is the end of that discussion.</i></p>
<BR>
<i>Bruce:</i> OK, so we end up with this:</p>
<pre><code>Function GetToken5(sTarget As String, sSeps As String) As String<BR>    <BR>    ‘ Note that sSave and iStart must be static from call to call<BR>    ‘ If first call, make copy of string<BR>    Static sSave As String, iStart As Integer, cSave As Integer<BR>    <BR>    ‘ Assume failure<BR>    GetToken5 = sEmpty<BR>    If sTarget &lt;&gt; sEmpty Then<BR>        iStart = 1<BR>        sSave = sTarget<BR>        cSave = Len(sSave)<BR>    Else<BR>        If sSave = sEmpty Then Exit Function<BR>    End If<BR>    <BR>    ‘ Find start of next token<BR>    Dim iNew As Integer<BR>    iNew = StrSpan2(sSave, iStart, sSeps)<BR>    If iNew Then<BR>        ‘ Set position to start of token<BR>        iStart = iNew<BR>    Else<BR>        ‘ If no new token, return empty string<BR>        sSave = sEmpty<BR>        Exit Function<BR>    End If<BR>    <BR>    ‘ Find end of token<BR>    iNew = StrBreak2(sSave, iStart, sSeps)<BR>    If iNew = 0 Then<BR>        ‘ If no end of token, set to end of string<BR>        iNew = cSave + 1<BR>    End If<BR><BR>    ‘ Cut token out of sTarget string<BR>    GetToken5 = Mid$(sSave, iStart, iNew - iStart)<BR>    ‘ Set new starting position<BR>    iStart = iNew<BR><BR>End Function</code></pre>
<BR>
<i>Bruce:</i> But isn’t this error-handling code going to slow us down?</p>
<BR>
<i>Joe:</i> So what?</p>
<BR>
<i>Jane:</i> I never thought I’d hear you say that.</p>
<BR>
<i>Joe:</i> Well, speed is important, but it isn’t everything. If all I wanted was speed, I could write GetToken like this:</p>
<pre><code>Function GetToken(sTarget As String, sSeps As String) As String<BR>    GetToken = sEmpty<BR>End Function</code></pre>
<BR>
That would really be fast. I could parse huge files in no time at all.</p>
<BR>
<i>Bruce:</i> But it doesn’t work.</p>
<BR>
<i>Joe:</i> It works as well as the original if you pass it invalid arguments—better, in some cases.</p>
<BR>
<i>Mary:</i> OK, OK. We get the point.</p>
<BR>
<i>Joe:</i> It doesn’t matter how fast your code is if it doesn’t work.</p>
<BR>
<i>Archaeologist’s Note: At this point, the code review broke down into arguments about language features and proposals for enhancements. Suffice it to say that the discussion resulted in at least one variation of </i>GetToken<i>, named </i>GetQToken<i>, which recognized each quoted string as a single token. Another version, named </i>GetOptToken<i>, was discussed but not implemented. It would have recognized command-line options initiated with the forward slash or the hyphen character, skipped the option characters, and returned the value of the argument. You can find modern translations of the parsing routines (including </i>GetQToken<i>) in </i>PARSE.BAS<i>. The global class </i>PARSE.CLS<i> in the VBCore component delegates its implementation to </i>PARSE.BAS<i>. The parsing functions are used in several samples, including </i>GLOBWIZ.VBP<i>.</i></p>
</font></BODY>
</HTML>
