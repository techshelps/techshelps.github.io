<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Handling Multiple Instances</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>

<font face="verdana,arial,helvetica" size="2"><h1><a name="handlingmultipleinstances"></a>Handling Multiple Instances</h1>
<BR>
The discussion of Windows so far in this chapter might have enlightened you, but it probably hasn’t put much bread on your table. Here’s a more practical problem.</p>
<BR>
What happens if you try to start two copies of the same program? Some programs, such as Calculator, don’t mind at all and will keep starting copies until you run out of memory. Others quit after displaying a message box saying that you can run only one copy. Still others, such as Microsoft Exchange, reactivate the current copy every time you try to start a new copy. For every program you write, you need to think about this issue and choose a strategy.</p>
<BR>
If it’s OK to run multiple copies, you don’t need to do anything. That’s the default. If you want to run only one copy, terminating each additional attempt with an error message, you don’t need to do much. Just put the following in Form_Load:</p>
<pre><code>If App.PrevInstance Then <BR>    MsgBox “You cannot start more than one copy&quot;<BR>    End<BR>End If</code></pre>
<BR>
This technique has one problem—App.PrevInstance is always False in the Visual Basic environment. You can launch multiple versions of Visual Basic running the same program, but each will think that it’s the only one. You’ll have difficulty debugging complicated code that uses the PrevInstance property. You can’t test it in the environment because it won’t behave the same, but you can’t easily test it outside the environment because you don’t have a debugger.</p>
<BR>
A bigger problem with putting up an error message in this situation is that it’s rarely the right thing to do. It’s much better to change the focus to the first copy and terminate the second copy. On the surface, it doesn’t seem to be hard to accomplish this in Visual Basic. The technique on the following page (from ALLABOUT&shy;.FRM) will work for many programs.</p>
<pre><code>    If App.PrevInstance Then<BR>        Dim sTitle As String<BR>        ‘ Save my title<BR>        sTitle = Me.Caption<BR>        ‘ Change my title bar so I won’t activate myself<BR>        Me.Caption = Hex$(Me.hWnd)<BR>        ‘ Activate other instance<BR>        AppActivate sTitle<BR>        ‘ Terminate myself<BR>        End<BR>    End If</code></pre>
<BR>
Is changing the caption before activating the other instance a neat trick or what? This works great for programs that always have the same title, but what if the other instance has a different title? Notepad’s title contains the name of the current file. So does the Visual Basic environment. In fact, the Windows interface standard specifies that any window representing a document should have the document name in the title. But if you don’t know the document name, you can’t call AppActivate.</p>
<BR>
WinWatch handles multiple copies the hard way. It calls the GetFirstInstWnd function to find out whether there is another instance. If so, it activates that window by calling the SetForegroundWindow API function. The call looks like this:</p>
<pre><code>    Dim hWndOther As Long<BR>    hWndOther = GetFirstInstWnd(Me.hWnd)<BR>    If hWndOther &lt;&gt; hNull Then<BR>        ‘ Uncomment this line for debugging<BR>        ‘MsgBox “Activating first instance&quot;<BR>        SetForegroundWindow hWndOther<BR>        End<BR>    End If</code></pre>
<BR>
The GetFirstInstWnd function does the actual work. It works by looping through all the top windows until it finds one that has a different process ID, but the same module name. That’s the duplicate. The code (in MODTOOL.BAS) looks like this:</p>
<pre><code>Function GetFirstInstWnd(hWndMe As Long) As Long<BR>    Dim hWndYou As Long, idMe As Long, sExeMe As String<BR><BR>    ' Get my own process ID and executable name<BR>    idMe = MWinTool.ProcIDFromWnd(hWndMe)<BR>    sExeMe = ExeNameFromWnd(hWndMe)<BR>    ' Get first sibling to start iterating top-level windows<BR>    hWndYou = GetWindow(hWndMe, GW_HWNDFIRST)<BR>    Do While hWndYou &lt;&gt; hNull<BR>        ' Ignore if process ID of target is same<BR>        If idMe &lt;&gt; MWinTool.ProcIDFromWnd(hWndYou) Then<BR>            ' Ignore if module name is different<BR>            If sExeMe = ExeNameFromWnd(hWndYou) Then<BR>                ' Return first with same module, different process<BR>                GetFirstInstWnd = hWndYou<BR>                Exit Function<BR>            End If<BR>        End If<BR>        ' Get next sibling<BR>        hWndYou = GetWindow(hWndYou, GW_HWNDNEXT)<BR>    Loop<BR>End Function</code></pre>
<p>
This technique works for most applications, but it’s not infallible. Your program might have multiple top-level windows, and the first one returned might not be the one you want to activate. That’s why MODTOOL.BAS also contains the GetAllInstWnd function, which returns a Collection of all the window handles of other instances. GetAllInstWnd enables you to follow one of Joe Hacker’s favorite design rules: “If in doubt, let the user decide.” You could create a dialog box form with a list box of existing instances. Let the user decide whether to cancel the request, launch a new instance, or activate an existing one. This would be an excellent way to handle the new multiple instance model that is becoming popular as an alternative to the Multiple Document Interface—each document is handled by a separate independent instance of a small program rather than by a separate MDI window of a large program.</p>
<p>
<b>WARNING&#09;</b>Terminating a duplicate instance is one of those rare cases when you should actually use the End statement. Although the name sounds harmless, End is actually more like an Abort statement that means stop by any means even if it can’t do normal cleanup. Experienced Visual Basic programmers terminate their programs by unloading all the active forms. Normally, all it takes is an Unload Me statement in the main form. But if you’re trying to terminate in the main Form_Load, there is, by definition, nothing to unload. So the rule is simple: Never use End except in Form_Load. In the first edition of this book, I violated this rule by providing a procedure that looked for a duplicate instance and terminated that instance with an End statement inside the procedure. I got a rude surprise when I tried to put that procedure in the VBCore component. Visual Basic won’t let you use the End statement in a DLL or a control. The GetFirstInstWnd function can be in a DLL because it returns the other instance rather than trying to take action about it. This is a more flexible structure anyway. The caller of GetFirstInstWnd can decide what it wants to do about the duplicate instance.</p>
</font></BODY>
</HTML>
