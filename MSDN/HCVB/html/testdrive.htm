<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Test Drive</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>

<font face="verdana,arial,helvetica" size="2"><h1><a name="testdrive"></a>Test Drive</h1>
<BR>
When I write a new class, I start by creating a test form that exercises the class. I put a command button and either a large label or a TextBox control on the form. Before I start writing the class itself, I declare an object of the proposed class in the command button’s Click event procedure and write some code that uses the properties and methods of the class, outputting any status information to the label or the text box. Normally, I name the test program using the name preceded by a <i>T,</i> for example, TDRIVE.FRM to test the CDrive class in DRIVE&shy;.CLS. In this case, however, I combined drive testing with testing of other information classes and forms, including an About form. The actual name of the test project is ALLABOUT.FRM in ALLABOUT.VBG. You can see it, with output from CDrive, in Figure 3-2.</p>
<BR><img src="f03te02.gif"></p><BR>
<b>Figure 3-2. The Drives tab of the All About program.</b></p>
<BR>
To examine the class, let’s start by declaring three CDrive object variables:</p>
<pre><code>Dim driveDat As New CDrive<BR>Dim driveCur As New CDrive<BR>Dim driveNet As New CDrive</code></pre>
<BR>
At this point, the drive objects have no meaning; they aren’t yet connected with any physical disk drive. You must somehow connect each Basic drive object to a real-world drive object.</p>
<BR>
The modern way of specifying a drive is with a root path—the standard system introduced by the Win32 API. Lettered drives have root paths in the form <i>D:\</i>, and network drives that are not associated with letters have root paths in the form <i>\\server\share\</i>. Notice that root paths always end in a backslash. Our CDrive class will have a Root property as the means of specifying a drive:</p>
<pre><code>driveDat.Root = “a:\”              ‘ Set to lettered drive<BR>driveCur.Root = sEmpty             ‘ Set to current drive<BR>driveNet.Root = “\\brucem1\root\”  ‘ Set to network drive</code></pre>
<BR>
Back in the ancient days of MS-DOS, drives were sometimes represented by the numbers 0 through 26 (with 0 representing the current drive) and sometimes by the numbers 0 through 25 (with 0 representing drive A). You needed to read the documentation carefully to see which system to use for any MS-DOS function call. One of the reasons for using a class is to eliminate such inconsistencies. The CDrive class recognizes numeric Root property values, with the number 0 representing the current drive and the numbers 1 through 26 representing local drives.</p>
<BR>
You can initialize a drive as follows:</p>
<pre><code>driveDat.Root = 1                  ‘ Set to A:<BR>driveCur.Root = 0                  ‘ Set to current drive</code></pre>
<BR>
Of course, in Basic a class can have a default property, and the obvious one for the CDrive class is Root:</p>
<pre><code>driveDat = 1                       ‘ Set to A:<BR>driveCur = 0                       ‘ Set to current drive<BR>driveDat = “a:\”                   ‘ Set to lettered drive<BR>driveCur = sEmpty                  ‘ Set to current drive<BR>driveNet = “\\brucem1\root\”       ‘ Set to network drive</code></pre>
<BR>
If you don’t like any of those, you don’t have to set anything. By default, the Root property will be <i>sEmpty </i>and you’ll get the default drive.</p>
<BR>
Once the drive is initialized, you can read its Root property (which has been converted to the root path format) or its Number property. The Number property is 0 for network drives:</p>
<pre><code>‘ Assume that current drive is C:<BR>Debug.Print driveDat.Number        ‘ Prints 1<BR>Debug.Print driveCur.Number        ‘ Prints 3<BR>Debug.Print driveNet.Number        ‘ Prints 0<BR>Debug.Print driveDat.Root          ‘ Prints “A:\”<BR>Debug.Print driveCur.Root          ‘ Prints “C:\”<BR>Debug.Print driveNet.Root          ‘ Prints “\\BRUCEM1\ROOT\”</code></pre>
<BR>
Of course, what you really want is the drive data in the form of read-only properties FreeBytes, TotalBytes, Label, Serial, and KindStr. You can use them this way:</p>
<pre><code>    Const sBFormat = “#,###,###,##0”<BR>    With driveCur<BR>        s = s &amp; “Drive “ &amp; .Root &amp; “ [“ &amp; .Label &amp; “:” &amp; _<BR>                .Serial &amp; “] (“ &amp; .KindStr &amp; “) has “ &amp; _<BR>                Format$(.FreeBytes, sBFormat) &amp; “ free from “ &amp; _<BR>                Format$(.TotalBytes, sBFormat) &amp; sCrLf<BR>    End With</code></pre>
<BR>
This code displays information in the following format:</p>
<pre><code>Drive C:\ [BRUCEM1:1F81754F](Fixed) has 3 bytes free from 1,058,767,000</code></pre>
<BR>
The CDrive class is designed with the assumption that drive objects don’t change their properties. In real life, of course, drives sometimes do change. You might remove a 14.4 megabyte disk from your <i>A</i> drive and insert a 7.2 megabyte disk. You might disconnect a large network drive from your <i>O</i> drive and connect a small one. CD-ROM technology might change while your program is running. You can make sure that a drive object reinitializes its state from the drive it represents by setting the object variable to a new drive object or by assigning the Root property (even if you reassign the current value).</p>
</font></BODY>
</HTML>
