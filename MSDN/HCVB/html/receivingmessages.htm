<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Receiving Messages</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>

<font face="verdana,arial,helvetica" size="2"><h1><a name="receivingmessages"></a>Receiving Messages</h1>
<BR>
Visual Basic controls and forms constantly receive messages and translate them into events or attributes according to instructions in the messages. For example, let’s say that you used the Menu Editor to define a File menu named mnuFile with items mnuNew, mnuOpen, and so on. When the user of your application chooses Open, the mnuOpen_Click event occurs, and the code in the mnuOpen_Click event procedure executes.</p>
<BR>
But what really happens behind the scenes? Windows gets a signal from the mouse port that a click has occurred at a certain screen location (or possibly it discovers that the Alt, F, and O keys have been pressed consecutively). Windows checks its internal information to find out which window owns that location and discovers that the click occurred on the Open item of the File menu. It then sends a slew of messages related to this event, culminating in a WM_COMMAND message with the ID number of the Open item.</p>
<BR>
Meanwhile, the window procedure for the form containing the menu has a Select Case block similar to the one shown here:</p>
<pre><code>Select Case iMessage<BR>Case WM_COMMAND<BR>    Select Case wParam<BR>    Case IDM_NEW<BR>        mnuNew_Click<BR>    Case IDM_OPEN<BR>        mnuOpen_Click<BR>    §<BR>    End Select<BR>§<BR>End Select</code></pre>
<BR>
This code intercepts the WM_COMMAND message, and the mnuOpen_Click event starts executing. In short, Windows sends messages; Visual Basic turns them into events.</p>
<BR>
Now consider the system menu. By default, Visual Basic puts the standard system menu on all forms whose ControlBox property is set to True. When a user chooses from a system menu, Windows sends the WM_SYSCOMMAND message to the window (form). The window procedure for a form works this way:</p>
<pre><code>‘ Set default return value<BR>WindowProc = 0&amp;<BR>‘ Handle messages<BR>Select Case iMessage<BR>Case WM_DOHOPEVENT<BR>    Form.HopEvent_Click<BR>Case WM_GETJUMPDATA<BR>    Form.JumpData = wParam<BR>Case Else<BR>    ‘ Let default window procedure handle the rest<BR>    WindowProc = DefWindowProc(hWnd, iMessage, wParam, lParam)<BR>End Select</code></pre>
<BR>
Because the WM_SYSCOMMAND message isn’t handled by a specific Case statement, it falls through to the Case Else statement to be handled by DefWindow&shy;Proc. The default window procedure knows how to do the standard operations—move, size, minimize, maximize, close, and switch to—which are the same for any window.</p>
<BR>
But what if you add an About item to the system menu? Visual Basic won’t help you do this, but neither will it stand in your way. It’s a simple matter to add an item to the system menu using Windows API calls:</p>
<pre><code>Const IDM_ABOUT = 1010<BR>Dim hSysMenu As Long<BR>‘ Get handle of system menu<BR>hSysMenu = GetSystemMenu(hWnd, 0&amp;)<BR>‘ Append separator and menu item with ID IDM_ABOUT<BR>Call AppendMenu(hSysMenu, MF_SEPARATOR, 0&amp;, 0&amp;)<BR>Call AppendMenu(hSysMenu, MF_STRING, IDM_ABOUT, “About...”)</code></pre>
<BR>
When the user selects this new menu item, Windows sends a WM_SYS&shy;COMMAND message with the IDM_ABOUT value to the window procedure. Having no clue what to do with this message, the window procedure passes it off to Def&shy;WindowProc, which also hasn’t a clue. Your message rides off into the sunset.</p>
</font></BODY>
</HTML>
