<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Text and Rich Text Modes</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>

<font face="verdana,arial,helvetica" size="2"><h1><a name="textrichtextmodes"></a>Text and Rich Text Modes</h1>
<BR>
The RichTextBox control is chock full of cool features that often get in your way and cause headaches. Sometimes multiple fonts and formatted text are overkill. Sometimes you just want a souped-up Notepad.</p>
<BR>
Fortunately, the RichEdit Windows control has EM_GETTEXTMODE and EM-_SETTEXTMODE messages. Unfortunately, these messages are undocumented and appear to have absolutely no effect on any of the syntax variations I could think of. Well, that’s how it goes with undocumented features. I’ll have to hack out my own version by maintaining an internal <i>fTextMode </i>variable and disabling all the rich text features when it is True.</p>
<BR>
The implementation of the TextMode property is the classic Get/Let pair that simply returns or modifies the <i>fTextMode </i>variable.</p>
<pre><code>Property Get Textmode() As Boolean<BR>    TextMode = fTextMode<BR>End Property<BR><BR>Property Let TextMode(ByVal fTextModeA As Boolean)<BR>    ' Change to TextMode dirties the file, but not vice versa<BR>    If Not fTextMode and fTextMode &lt;&gt; fTextModeA Then DirtyBit = True<BR>    fTextMode = fTextModeA<BR>    PropertyChanged &quot;TextMode&quot;<BR>End Property</code></pre>
<BR>
The interesting part is what you do with the TextMode properties in XEditor properties and methods. For example, here’s what happens in the SaveFile method:</p>
<pre><code>Sub SaveFile(sFileNameA As String, _<BR>             Optional ordTextModeA As ELoadSave = elsDefault)<BR>    If sFileNameA = sEmpty Then Exit Sub<BR>    BugAssert ordTextModeA &gt;= elseDefault And ordTextModeA &lt;= elstext<BR>    If ordTextModeA = elsDefault Then<BR>        ordTextModeA = IIf(TextMode, elsText, elsRTF)<BR>    End If<BR>    ' Use RichTextBox method (raise unhandled errors to caller)<BR>    sFileNameA = GetFullPath(sFileNameA)<BR>    txt.SaveFile sFileNameA, ordTextModeA<BR>    sFilePath = sFileNameA<BR>    DirtyBit = False<BR>End Sub</code></pre>
<BR>
The LoadFile method shown earlier works much the same. In both cases, the work is delegated to the appropriate method (LoadFile or SaveFile) of the <BR>internal RichTextBox control. This method takes an argument that specifies whether to save the Text property or the TextRTF property. Most of the code in SaveFile and LoadFile deals with figuring out the appropriate mode to save in.</p>
<BR>
When I started working with the RichTextBox, I had some preconceptions about how LoadFile and SaveFile should work. This might be obvious to everyone else, but bear with me while I explain a little text mode history.</p>
</font></BODY>
</HTML>
