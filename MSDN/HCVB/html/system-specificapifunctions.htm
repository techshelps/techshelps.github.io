<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>System-Specific API Functions</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>

<font face="verdana,arial,helvetica" size="2"><h1><a name="system-specificapifunctions"></a>System-Specific API Functions</h1>
<BR>
You might remember the olden days when Windows evangelists claimed that any API function supported in Windows NT should have at least a stub in Windows 95, and vice versa. This was mostly the way things worked in Windows 95 and Windows NT 3.51. But let me warn you that this policy is no longer operable.</p>
<BR>
I’ve been informed, by people who know, that many of the new API functions that will be introduced in future versions of Windows might not have stubs in their counterparts. If one version of Windows has API functions another lacks, you must conditionally load the function pointers for the supporting operating system and call the functions dynamically. This is a messy business in C++ and other low-level languages, and I thought it would be impossible in Visual Basic. Not so. It turns out that all API functions defined with Declare statements are called dynamically, and if you need to call one function in one operating system and another in a different system, it’s as easy as pie.</p>
<BR>
That’s exactly what you have to do to iterate through processes and modules in Visual Basic. If the host system is Windows 95, you need to call the Tool&shy;Help32 functions located in KERNEL32.DLL. If the host system is Windows NT, you need to call the process functions in PSAPI.DLL. If you call the wrong API function from the wrong operating system, you’ll end up with a rude message. Windows NT will inform you that there are no ToolHelp32 functions in KERNEL32.DLL. Windows 95 will tell you that PSAPI.DLL can’t be found (even if it’s right there). Either way, you won’t get what you want.</p>
<BR>
For the moment, let’s ignore the substantial differences between the two different approaches. Just take it on faith that Windows NT starts iterating through processes with a function called EnumProcesses. Windows 95 starts iterating through processes with a function called Process32First. To call these functions from their appropriate operating systems, write Declare statements for each in the same module. I put mine in MODTOOL.BAS.</p>
<BR>
Notice first that we define both functions. It would be slightly more efficient to use conditional compilation to define the appropriate Declare statement for each operating system, but then we’d end up with two different versions of the program. Instead we’ll check at run time and make sure that the wrong function is never called from the right operating system. Notice also that we’re using Declare statements, not a type library. A type library won’t work in this situation because Visual Basic loads all type library function entries at compile time rather than at run time.</p>
<BR>
We’ll take a closer look at the code shortly, but in summary, you can write a wrapper function that works like this:</p>
<pre><code>Function CreateProcessList() As CVector<BR>    If IsNT Then <BR>        f = EnumProcesses(...)<BR>    Else<BR>        f = Process32First(...)<BR>    End If<BR>End Function</code></pre>
<BR>
As long as you call the right function, there’s no problem. You can even trap the error that occurs when a function doesn’t exist:</p>
<pre><code>Function CreateProcessList() As CVector<BR>    On Error Resume Next<BR>    f = EnumProcesses(...)<BR>    If Err Then f = Process32First(...)<BR>End Function</code></pre>
<BR>
How does this work? Well, I don’t have access to Visual Basic source code, so I’m not positive. And it doesn’t really matter. But it works as if it were coded like the following.</p>
<BR>
A Declare statement in code creates a UDT variable containing information about the Declare—function pointer address, types, aliases, DLL, etc. The address is the key field here. If the code were written in Visual Basic, the data structure might look like this:</p>
<pre><code>Type TDeclare<BR>    proc As Long<BR>    name As String<BR>    dll As String<BR>    hMod As Long<BR>    alias As String<BR>    return As TParam<BR>    params() As TParam<BR>End Type</code></pre>
<BR>
For each Declare statement the compiler would create this variable:</p>
<pre><code>Private declGetVersion As TDeclare</code></pre>
<BR>
This happens at compile time. Then at run time, the program might call the declared function:</p>
<pre><code>i = GetVersion</code></pre>
<BR>
Behind the scenes Visual Basic checks to see if the DLL is loaded using code that might look like the following.</p>
<pre><code>With declGetVersion <BR>    ‘ Make sure the DLL is loaded<BR>    If .hMod = 0 Then <BR>        .hMod = LoadLibrary(.dll)<BR>        ‘ Probably set the .hMod for all other Declares with same DLL<BR>    End If   <BR>    ‘ Make sure the procedure variable is set<BR>    If .proc = 0 Then<BR>        If .alias = sEmpty Then .alias = .name<BR>        .proc = GetProcAddress(.hMod, .alias)<BR>    End If<BR>    i = (.proc)() ‘ Procedure parameter syntax not yet invented<BR>End With</code></pre>
<BR>
Of course you can’t really call procedure parameters in Visual Basic, but this gives you some idea of what must be going on behind the scenes. With a type library, the data structure for all function entries are initialized at compile time. If you hit an error such as a missing DLL or a missing function, you’ll fail at compile time, not at run time. This is why you have to use Declare statements to iterate through processes.</p>
<BR>
If you understand how this works, you can use the knowledge to hack around DLL problems such as one encountered by a reader of the first edition of this book. He had a client DLL in a mystery directory that wasn’t known until run time. The DLL wasn’t in the windows directory, the system directory, or the path, so his Declare statements wouldn’t work and he couldn’t patch them at run time when he knew the directory. Look back at the pseudocode above to figure out the solution.</p>
<BR>
The problem is in the LoadLibrary call. But if you look up help on LoadLibrary, you’ll see that it looks for the DLL in the current directory among other locations. The solution for this reader was this:</p>
<pre><code>sCurDir = CurDir$<BR>ChDir sDllDir<BR>Call FirstFuncInDLL()<BR>ChDir sCurDir</code></pre>
<BR>
LoadLibrary is called only once, so the current directory matters for only the first DLL function.</p>
</font></BODY>
</HTML>
