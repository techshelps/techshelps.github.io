<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Iterative QuickSort</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>

<font face="verdana,arial,helvetica" size="2"><h1><a name="iterativequicksort"></a>Iterative QuickSort</h1>
<BR>
For every recursive algorithm, there is an iterative algorithm. In the first edition of this book, I challenged readers to write the iterative version of SortArray. Scott D. Killen answered the call with an implementation that used my CStack class to save sections of the array for later sorting. Scott credits the book <i>Practical Algorithms in C<font face="Symbol"><span style="font-family:symbol">&#43;&#43;</span></font> </i>(John Wiley and Sons, Inc., 1995) by Bryan Flamig as his source. Here’s the code:</p>
<pre><code>‘ Iterative QuickSort algorithm<BR>Sub SortArray(aTarget() As Variant, Optional vFirst As Variant, _<BR>              Optional vLast As Variant, Optional helper As ISortHelper)<BR>    Dim iFirst As Long, iLast As Long<BR>    If IsMissing(vFirst) Then iFirst = LBound(aTarget) Else iFirst = vFirst<BR>    If IsMissing(vLast) Then iLast = UBound(aTarget) Else iLast = vLast<BR>    If helper Is Nothing Then Set helper = New CSortHelper<BR>    <BR>With helper<BR>    Dim iLo As Long, iHi As Long, iRand As Long, stack As New CStack<BR>    Do<BR>        Do<BR>            ‘ Swap from ends until first and last meet in the middle<BR>            If iFirst &lt; iLast Then<BR>                ‘ If we’re in the middle and out of order, swap<BR>                If iLast - iFirst = 1 Then<BR>                    If .Compare(aTarget(iFirst), aTarget(iLast)) &gt; 0 Then<BR>                        .Swap aTarget(iFirst), aTarget(iLast)<BR>                    End If<BR>                Else<BR>                    ‘ Split at some random point<BR>                    .Swap aTarget(iLast), _<BR>                          aTarget(MRandom.Random(iFirst, iLast))<BR>                    ‘ Swap high values below the split for low values above<BR>                    iLo = iFirst: iHi = iLast<BR>                    Do<BR>                        ‘ Find any low value larger than split<BR>                        Do While (iLo &lt; iHi) And _<BR>                                 (.Compare(aTarget(iLo), aTarget(iLast)) &lt;= 0)<BR>                            iLo = iLo + 1<BR>                        Loop<BR>                        ‘ Find any high value smaller than split<BR>                        Do While (iHi &gt; iLo) And _<BR>                                 (.Compare(aTarget(iHi), aTarget(iLast)) &gt;= 0)<BR>                            iHi = iHi - 1<BR>                        Loop<BR>                        ‘ Swap too high low value for too low high value<BR>                        If iLo &lt; iHi Then .Swap aTarget(iLo), aTarget(iHi)<BR>                    Loop While iLo &lt; iHi<BR>                    ‘ Current (iLo) is larger than split (iLast), so swap<BR>                    .Swap aTarget(iLo), aTarget(iLast)<BR>                    ‘ Push range markers of larger part for later sorting<BR>                    If (iLo - iFirst) &lt; (iLast - iLo) Then<BR>                        stack.Push iLo + 1<BR>                        stack.Push iLast<BR>                        iLast = iLo - 1<BR>                    Else<BR>                        stack.Push iFirst<BR>                        stack.Push iLo - 1<BR>                        iFirst = iLo + 1<BR>                    End If<BR>                    ‘ Exit from inner loop to process smaller part<BR>                    Exit Do<BR>                End If<BR>            End If<BR>            <BR>            ‘ If stack empty, Exit outer loop<BR>            If stack.Count = 0 Then Exit Sub<BR>            ‘ Else pop first and last from last deferred section<BR>            iLast = stack.Pop<BR>            iFirst = stack.Pop<BR>        Loop<BR>    Loop<BR>End With<BR>End Sub</code></pre>
<BR>
Scott’s code proves two points. First, iterative algorithms aren’t necessarily faster than recursive ones. If you check the two versions in the TimeIt application, you’ll see that the recursive version wins by half a hair. But in a race that close you have to give the advantage to the code that uses the least resources. The iterative version gets the nod as the official SortArray procedure in the VBCore component because it can never run out of stack space.</p>
<BR>
The second point is that recursive algorithms can be a lot simpler than iterative ones. In fact, I think of the recursive version as documentation for the iterative version. You can read the recursive code and it makes sense. Not so the iterative code. I stepped through it and added comments that attempt to explain what’s going on, but I still don’t really understand the details. Mainly I just pray that it works.</p>
<BR>
Don’t read too much into this particular result. You’ll have to analyze your algo&shy;rithms on a case-by-case basis. Think carefully before you start trying to reorganize natural recursive algorithms into twisted iterative ones. For algorithms that don’t recurse deeply, saving stack space probably won’t matter. In fact, <BR>32-bit programs aren’t nearly as likely to run out of stack space as were 16-bit programs. Sometimes iterative algorithms are clearer anyway. The iterative binary search algorithm at the end of this chapter could have been written recursively, but it wouldn’t have been any clearer.</p>
<BR>
The SortArray sub is used to sort arrays containing strings and integers in the Test Sort program (TSORT.VBP), shown in Figure 5-3. This program sorts arrays and is used in the implementation of sorted collections and a sorted list box control. For now, we’re interested only in arrays. (I’ve already discussed sorted collections and list boxes.) SortArray is also used to sort an array of playing cards in the Fun ’n Games program (FUNNGAME.VBP) described in Chapter 6.</p>
<p><BR><img src="f05te03.gif"></p>
<b>Figure 5-3. The Test Sort program.</b></p>
<p>
I’m embarrassed to admit that the recursive version of this al&shy;gorithm in the first edition contained an example of one of the oldest and most pervasive bugs you can write. It made several assignments inside a loop that could just as easily have been made outside the loop. As a result, the function was four to five times slower than necessary. Sharp-eyed reader David Wilmer identified the problem. To make matters worse, the same bug actually showed up in five different places on the CD. I reported the problem and provided a fix (with abject apologies) on the Internet site for the book, but some readers might have missed it. My only excuse (a weak one) is that it wasn’t originally my bug. The code came from an old version of SORTDEMO, but I learned later that the bug and the fix were described years ago in the Knowledge Base for QuickBasic. I don’t spend a lot of time wandering through bug reports in defunct products, so I missed it. Sorry about that.</p>
</font></BODY>
</HTML>
