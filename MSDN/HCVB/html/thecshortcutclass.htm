<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>The CShortcut Class</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>

<font face="verdana,arial,helvetica" size="2"><h1><a name="thecshortcutclass"></a>The CShortcut Class</h1>
<BR>
Earlier I mentioned a CShortCut server written in C++. Notice that the name of the Visual Basic version has a different case. Of course, the real difference between these components is their GUIDs. Their interfaces are actually very similar, and their implementations aren’t much different either. Aside from petty language differences such as curly braces, the difference is that dealing with Variants and Strings is a whole lot easier in Visual Basic. The C++ version is on the CD if you want to compare them.</p>
<BR>
The IShellLink interface seems to be designed specifically to cause trouble for Visual Basic programmers. On the one hand it ignores interface capabilities, such as properties, that would make access easy. Furthermore, it uses types, such as unsigned integers, that Visual Basic doesn’t understand. Like many API functions, it’s designed to enable every possible feature, not to be convenient or easy to use. In other words, it needs a Visual Basic–friendly wrapper:</p>
<pre><code>Private link As New CShellLink</code></pre>
<BR>
CShellLink wraps the IShellLink interface and <i>link</i> represents a particular shell link. The main purpose of the CShortcut class is to transfer the properties of the <i>link </i>object to and from a corresponding LNK file.</p>
<h2><a name="thesavemethod"></a>The Save method</h2>
<BR>
CShortcut saves its link object to a file using the Save method:</p>
<pre><code>‘ Link file parameter is Variant to accept any of these:<BR>’      edstDesktop          - Put on desktop<BR>’      edstCommonDesktop    - Put on shared desktop<BR>’      edstPrograms         - Put on programs menu<BR>’      edstCommonPrograms   - Put on shared programs menu<BR>’      edstStartMenu        - Put on start menu<BR>’      edstCurrent          - Put in current directory<BR>’      edstPath             - Put in same directory as target file<BR>’      [directory]          - Put in hardcoded path<BR>’      [file.LNK]           - Put in hardcoded file<BR>Function Save(vLinkFile As Variant) As String<BR>    Dim sLink As String<BR>    ‘ Convert constant or directory to full path<BR>    sLink = FixLocation(vLinkFile)<BR>    If sLink = sEmpty Then ErrRaise eeFileNotFound<BR><BR>    ‘ Save the object to disk<BR>    MCasts.IVBPersistFile(link).Save sLink, APITRUE<BR>    Save = sLink<BR>End Function</code></pre>
<BR>
Since the link file might be passed in as a constant representing a standard location, the method returns the real path in case the caller needs to locate the link file.</p>
<h2><a name="interfacecasting"></a>Interface casting</h2>
<BR>
The Windows implementation of the IShellLink interface also implements the IPersistFile interface. You need to call the Save method of IPersistFile to save your changes to the link file. The Visual Basic way of doing this is to create a separate object variable for the persistent object:</p>
<pre><code>Dim persist As IVBPersistFile<BR>Set persist = link<BR>persist.Save sLink, APITRUE</code></pre>
<BR>
This technique is a little messy because it leaves unnecessary object variables lying around. Most object-oriented languages support a casting syntax so that you can typecast one object to another type with which it is polymorphic. The syntax varies depending on the language and on whether inheritance is used, but a compatible Visual Basic syntax might look like this:</p>
<pre><code>IVBPersistFile(link).Save sLink, APITRUE</code></pre>
<BR>
Or perhaps Visual Basic could have provided an operator and made the syntax look like this:</p>
<pre><code>link@IVBPersistFile.Save sLink, APITRUE</code></pre>
<BR>
Unfortunately, Visual Basic doesn’t support either of these syntaxes, but you can fake it by writing a typecasting function. The global module GCasts contains casting functions for all the interfaces provided by VBCore and by the Windows API type library. Here’s an example:</p>
<pre><code>Function IVBPersistFile(obj As IVBPersistFile) As IVBPersistFile<BR>    Set IVBPersistFile = obj<BR>End Function</code></pre>
<BR>
All the other casting functions look exactly like this one except for the function name, which is also the name of the interface type being typecast. Since the CShortcut class resides in the same component as the casting functions, you must further qualify the casting function with the name of the MCasts object as explained in Chapter 5.</p>
<pre><code>MCasts.IVBPersistFile(link).Save sLink, APITRUE</code></pre>
<BR>
Your own references to casting functions won’t need this qualification.</p>
<BR>
By the way, APITRUE is a C-style True with a value of 1, indicating something that matters for certain uses of IPersistFile. It has no effect in the architecture of CShortcut.</p>
<h2><a name="theresolvemethod"></a>The Resolve method</h2>
<BR>
Resolve is the opposite of Save. You pass it the name of the LNK file you want to open. You can also pass optional parameters that control what happens if the LNK file you specify doesn’t contain a valid shortcut:</p>
<pre><code>‘ Flags control behavior if LNK file reference can’t be resolved:<BR>’    SLR_ANY_MATCH - Display a dialog (with hWnd parameter as parent<BR>’                    window) asking user whether to search for reference<BR>’    SLR_NO_UI     - Search the disk for the time period specified by<BR>’                    TimeOut parameter<BR>Sub Resolve(sFileA As String, _<BR>            Optional Flags As ESLR = SLR_ANY_MATCH, _<BR>            Optional hWnd As Long = hNull, _<BR>            Optional TimeOut As Integer = 0)<BR>    ‘ Load from LNK file and resolve<BR>    MCasts.IVBPersistFile(link).Load sFileA, STGM_DIRECT<BR>    If Flags = SLR_NO_UI And TimeOut &gt; 0 Then<BR>        Flags = Flags Or MBytes.LShiftDWord(TimeOut, 16)<BR>    End If<BR>    link.Resolve hWnd, Flags<BR>End Sub</code></pre>
<BR>
Sometimes LNK files get out of date when a user moves the executable file that the shortcut references. The default flag, SLR_ANY_MATCH, specifies that a dialog box will ask the user what to do for unresolved shortcuts. The SLR_NO_UI specifies that an appropriate (we hope) action will be taken without user interaction.</p>
<h2><a name="cshortcutproperties"></a>CShortcut properties</h2>
<BR>
The CShortcut properties work as you would expect, except that the underlying CShellLink uses API-style strings while the friendly versions have to use Visual Basic strings. The Arguments property is typical:</p>
<pre><code>Property Get Arguments() As String<BR>    Dim s As String<BR>    s = String$(cMaxPath, 0)<BR>    link.GetArguments s, cMaxPath<BR>    Arguments = MUtility.StrZToStr(s)<BR>End Property<BR><BR>Property Let Arguments(sArgumentsA As String)<BR>    link.SetArguments sArgumentsA<BR>End Property</code></pre>
<BR>
The Property Get works like any API string access function. You pass the underlying <i>link </i>object a string buffer and a maximum length. It fills the buffer with a null-terminated string, which you convert to a Visual Basic string. The other properties are similar. Some of them have a little more code to set defaults or validate input.</p>
<h2><a name="whatsnext"></a>What’s next</h2>
<BR>
If you can figure out how to use the IShellLink interface, you should be able to use other interfaces, starting with the new ones introduced by Windows 95 and now available in Unicode variations for Windows NT 4.0. </p>
<BR>
The most important interface behind what you see on your screen and in Windows Explorer is IShellFolder. It’s the manager behind the new object hierarchy starting on your desktop with My Computer and moving up to the directories and files on your system. Ideally, this new paradigm would be everywhere by now. All sorts of programs, not just Windows Explorer, would be organizing objects in similar hierarchies. You do see that in a few programs, but it certainly hasn’t become pervasive. My theory of why starts with the semi-random name assigned to this hierarchy—the shell namespace. Nobody understands what <BR>it is, much less how to program it. How can you take something seriously <BR>when its main data structures are named PIDL and SHITEMID. Furthermore, the samples for it are written in tortured C, not C++. As for Visual Basic, well, this is probably the most Visual Basic–hostile interface you’ll ever encounter, and frankly I don’t think it’s all that great for C++ either. Nevertheless, we’ll do a few things with IShellFolder in Chapter 11. </p>
<BR>
IShellFolder is intimately related to other new interfaces that let you create helpers for any new document types your programs create. For example, ICon&shy;textMenu lets you access the context menus for registered file types. IShell&shy;PropSheetExt lets you write property sheet extensions that display information about the file type when users right click on a file and select Properties from the context menu. Context menu handlers, drag-and-drop handlers, property sheet handlers, and file viewers are not the same as similar features in your application because they affect your documents, not your program. In fact, your program might not be running when the shell extension goes into action. The idea was that everybody who creates a new document type would automatically provide all the appropriate handlers. Unfortunately, they forgot to make it easy. I was hoping to get around to that for this book, but I guess I’ll leave it to you. Of course, by the time you’re ready to start, new interfaces associated with Internet Explorer and future versions of Windows might lure you away from the task. Let’s hope they make these new interfaces easier to program.</p>
<BR>
Next on my list is IStorage. The Visual Basic file I/O system is nothing to brag about. It carries a lot of compatibility baggage and lacks some fundamental features, such as the ability to commit changes without closing an open file. COM provides the IStorage interface and some related API functions as an enhanced I/O system that does everything normal file systems do plus a few other tricks you’ve never seen before. Even if it didn’t do that extra stuff, it would still be a better, more object-oriented system than the one built into Visual Basic. Alas, you’ll have to fight with COM to get it to work with Visual Basic. Too bad. But don’t let that stop you. You might even want to combine IStorage and IShell&shy;Folder to create a complete object hierarcy representing all the system objects and all of their contents.</p>
<BR>
Something else you might think about is implementing ITypeInfo in order to create object browsing tools. Don’t bother. Visual Basic comes with the TypeLib Information component (TLBINF32.DLL), which already provides everything you need and more. This is the same component that provides all the information used by Visual Basic’s Object Browser and other browsing features. The only problem is figuring out how to use it. There’s no documentation. There’s no support. But all you have to do is load the DLL in the References dialog box. Then look at the members with the Object Browser. You’ll have to figure the object hierarchy from the names only. It’s not a project for the faint of heart, but I’d rather try to decipher this DLL than try to implement ITypeInfo from scratch.</p>
<BR>
Visual Basic comes with an ActiveX Control Interface Wizard that fakes inheritance of controls with delegation, but it doesn’t do anything about faking <BR>inheritance of classes. All you need to do is use the TypeLib Information component to read in all the properties, methods, and enums of the public class you want to enhance. Use this information to create the delegated members of classes in the same way that the wizard does it for controls. It’s one more project I wanted to do for this book, but never got around to.</p>
<BR>
<b>NOTE&#09;</b>At this point you may be feeling annoyed. If I really know how <BR>to do this stuff, why don’t I tell you the details? Why don’t I do <BR>it myself? I have to plead guilty. In fact, I’m downright embarrassed. My feeble excuse is that half of the problem involves type libraries, and since this book is about Visual Basic, I don’t have to explain the foreign IDL and ODL languages in detail. Besides, I give you hints (if you study them long and hard enough) in the CShortcut example. But the real reason is that I ran out of time. Sorry.</p>
</font></BODY>
</HTML>
