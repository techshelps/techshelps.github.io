<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>XDropStack Calling</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>

<font face="verdana,arial,helvetica" size="2"><h1><a name="xdropstackcalling"></a>XDropStack Calling</h1>
<BR>
Now let’s take a closer look at the XEditor search properties and methods used by the XDropStack control. The FindWhat property and its cousin ReplaceWith are the keys.</p>
<BR>
The FindWhat property represents the top of the stack (or front of the list) and is normally used without an index. You read from it to find the current find string:</p>
<pre><code>sFind = edit.FindWhat</code></pre>
<BR>
You write to it to add an item to the list:</p>
<pre><code>edit.FindWhat = sFind</code></pre>
<BR>
But it is also possible to index the FindWhat property to read all the items out of the list. Let’s look at the FindWhat property and its relatives to see how this works:</p>
<pre><code>Property Get FindWhat(Optional iIndex As Long = 1) As String<BR>With nFindWhat<BR>    If .Count = 0 Or iIndex &gt; .Count Then Exit Property<BR>    FindWhat = .Item(iIndex)<BR>End With<BR>End Property<BR><BR>Property Let FindWhat(Optional iIndex As Long = 1, sWhatA As String)<BR>With nFindWhat<BR>    ' Don't use optional parameter on Let<BR>    BugAssert iIndex = 1<BR>    Dim v As Variant, i As Long<BR>    For i = 1 To .Count<BR>        ' If item is in list, move to start of list<BR>        If .Item(i) = sWhatA Then<BR>            .Add sWhatA, , 1<BR>            .Remove i + 1<BR>            NotifySearchChange eseFindWhat<BR>            Exit Property<BR>        End If<BR>    Next<BR>    ' If item isn't in list, add it<BR>    If .Count Then<BR>        .Add sWhatA, , 1<BR>    Else<BR>        .Add sWhatA<BR>    End If<BR>    NotifySearchChange eseFindWhat<BR>End With<BR>End Property<BR><BR>Property Get FindWhatCount() As Long<BR>    FindWhatCount = nFindWhat.Count<BR>End Property<BR><BR>Property Get FindWhatMax() As Long<BR>    FindWhatMax = cFindWhatMax<BR>End Property<BR><BR>Property Let FindWhatMax(cFindWhatMaxA As Long)<BR>    cFindWhatMax = cFindWhatMaxA<BR>    Dim v As Variant, i As Integer<BR>    For i = nFindWhat.Count To cFindWhatMax + 1 Step -1<BR>        ' If item is in list beyond maximum, remove it<BR>        nFindWhat.Remove i<BR>    Next<BR>    NotifySearchChange eseFindWhat<BR>End Property</code></pre>
<BR>
The most important point about the FindWhat property is that it hides an internal Collection of strings. The default argument makes FindWhat look like a simple string property, and some simple clients might prefer to use the current string as if there were no others. But clients (such as the FSearch form) who wish to initialize a list can do so. What they can’t do is modify any item other than the top item because that would contradict the definition of a drop stack. The definitions of Property Get, Set, and Let procedures with the same name must all match—if one has an optional parameter, all must have the same optional parameter. You can’t prevent clients from writing code that uses the index, but you can assert that what they are doing is illegal, and if they do it anyway, ignore their foolish request.</p>
<BR>
The Property Let is what really makes the list work. It adds each new string to the list and ensures that the list isn’t too long and that the list doesn’t have &shy;duplicates. Finally, it calls NotifySearchChange, which raises a SearchChange event so that if the FSearch form modifies the search list through its drop stack, any other client using the list can recognize the change and update its list. The remaining search option properties also call NotifySearchChange in case a client represents them in some other way. Edwina monitors only FindWhat property changes, but your clients might want to monitor other options such as case sensitivity or direction. The FSearch form also monitors the SearchChange event so that any changes from the client made while the modal search form is active will be recognized as they happen.</p>
<BR>
The XDropStack implementation looks a lot like the implementation of the FindWhat list. Of course, combo boxes work a little differently than collections, so there are some differences in design. Figure 9-6 shows a picture of how <BR>the data is organized in both formats. You can check out the code details in DROPSTACK.CTL.</p>
<p><BR><img src="f09te06.gif"></p>
<b>Figure 9-6. A find list in XEditor and XDropStack.</b></p>
<p>
<b>CHALLENGE</b>&#09;Your next assignment is to save the Find and Replace lists with the SaveSetting function when Edwina terminates and to restore them with GetSetting at startup. You might notice that the XEditor control doesn’t allow you to enter items in the FindWhat list at design time. It would certainly be possible to do this in much <BR>the same way that you can enter list or combo box items in the List property at design time, but this isn’t the way search lists are normally maintained. My copy of Edwina has a different search list than your copy. While it’s saving the search list, Edwina should probably save the user’s favorite font and colors. And, of course, any respectable editor should provide a list of the most recently edited files and reopen the last one with the cursor position restored.</p>
</font></BODY>
</HTML>
