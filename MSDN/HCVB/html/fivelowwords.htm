<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Five Low Words</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>

<font face="verdana,arial,helvetica" size="2"><h1><a name="fivelowwords"></a>Five Low Words</h1>
<BR>
Consider the simple LoWord function, which extracts the low word of a DWord. What could be simpler? Just mask out the high byte of the argument and return the result:</p>
<pre><code>Function LoWord1(ByVal dw As Long) As Integer<BR>    LoWord1 = dw And &amp;HFFFF&amp;<BR>End Function</code></pre>
<BR>
This works fine as long as the low word is less than or equal to 32767. But now try this:</p>
<pre><code>w = LoWord1(32768)</code></pre>
<BR>
You get an overflow because 32768 is out of the integer range (<font face="Symbol"><span style="font-family:symbol">&#45;</span></font>32768 through 32767). If you’re accustomed to another language, you might expect that you could use a conversion function to force the assignment to an integer. Basic conversion functions such as CInt, however, don’t force anything. They request politely. If you change the guts of LoWord as shown here, you get the same overflow error:</p>
<pre><code>LoWord1 = CInt(dw And &amp;HFFFF&amp;)</code></pre>
<BR>
In most languages, type conversion or casting means “force by wrapping, truncation, or whatever it takes.” In Basic, it means “Mother, may I?” And in this <BR>case, the answer is always “No.” You might argue that any Long from <font face="Symbol"><span style="font-family:symbol">&#45;</span></font>32768 <BR>through 65535 can legitimately be converted to an Integer, and I’ll agree with you. But we lose.</p>
<BR>
In order to do the right thing for all integers, you must specifically check for the sign bit:</p>
<pre><code>Function LoWord2(ByVal dw As Long) As Integer<BR>    If dw And &amp;H8000&amp;) Then<BR>        LoWord2 = dw Or &amp;HFFFF0000<BR>    Else<BR>        LoWord2 = dw And &amp;HFFFF&amp;<BR>    End If<BR>End Function</code></pre>
<BR>
Checking for the sign bit takes time; this version of LoWord is a few ticks slower than the previous one. But remember Joe Hacker’s motto: “It doesn’t matter how fast your code is if it doesn’t work.”</p>
<BR>
There’s more than one way to get a DWord in Basic. You could simply copy the bits of the low word to the result. Basic provides a roundabout method of doing this with the LSet statement. You have to set up two structures that split the data in different ways:</p>
<pre><code>Private Type TLoHiLong<BR>    lo As Integer<BR>    hi As Integer<BR>End Type<BR><BR>Private Type TAllLong<BR>    all As Long<BR>End Type</code></pre>
<BR>
Then you write the data into one structure and read it out of the other:</p>
<pre><code>Function LoWord3(ByVal dw As Long) As Integer<BR>    Dim lohi As TLoHiLong<BR>    Dim all  As TAllLong<BR>    all.all = dw<BR>    LSet lohi = all<BR>    LoWord3 = lohi.lo<BR>End Function</code></pre>
<BR>
This code looks complicated, but internally it’s not doing a lot. This version is slower than the LoWord2 version, but it has the advantage of always working at the same speed, regardless of the number passed to it.</p>
<BR>
There’s another way to copy bits using the Windows API CopyMemory function. See the sidebar “CopyMemory: A Strange and Terrible Saga” in Chapter 2 for the bizarre story of what Copy&shy;Memory really is. Here’s the code to simply copy the contents of the low word to a separate word-sized variable:</p>
<pre><code>Function LoWord4(ByVal dw As Long) As Integer<BR>    CopyMemory LoWord4, dw 2<BR>End function</code></pre>
<BR>
I expected this code to beat the LSet version, but it usually came out a little slower. While LoWord is short and sweet, HiWord is a bit more difficult, as you will soon see.</p>
<BR>
Keep in mind that this version works only on Little Endian systems such as the Pentium. Visual Basic is now available on machines running Digital’s Alpha chip, which is a Big Endian system. <i>Endian </i>refers to the order in which bytes are stored. The term is taken from a story in <i>Gulliver’s Travels</i> by Jonathan Swift about wars fought between those who thought eggs should be cracked on the Big End and those who insisted on the Little End. With chips, as with eggs, it doesn’t really matter as long as you know which end is up.</p>
<BR>
The Big Endian version of LoWord4 would probably look like the following code:</p>
<pre><code>Function LoWord4(ByVal dw As Long) As Integer<BR>    CopyMemory LoWord4, ByVal VarPtr(dw) + 2, 2 <BR>End Function</code></pre>
<BR>
That’s what HiWord looks like on Little Endian systems, so the Big Endian HiWord would probably look like the Little Endian LoWord. I didn’t have an Alpha machine to test this on. I don’t know if Alphas even have a CopyMemory equivalent. If you’re fortunate enough to develop on an Alpha machine, you’ll have to check carefully all the hacks I do with CopyMemory. If you have problems, it should be easy to fix them with conditional compilation.</p>
<BR>
Face it, Bit bashing isn’t Basic’s strong point. Here’s what the same function looks like in C++:</p>
<pre><code>WORD DLLAPI LoWord(DWORD dw)<BR>{<BR>    return (WORD) (dw &amp; OxFFFF);<BR>}</code></pre>
<BR>
The C++ version is simpler, but it turns out to be slightly slower (probably because of the cost of calling it through a DLL). But even if C++ bit bashing were faster, the difference wouldn’t justify adding an extra DLL. The official LoWord  in the VBCore component and in BYTES.BAS has the same code shown in LoWord2 above. It’s fast enough.</p>
<BR>
<b>PERFORMANCE</b></p>
<BR>
<b>Problem:</b> Compare several methods of stripping the low word of a DWord.</p>
<table>
<tr valign=top>
<td>
<b>Problem</b></td>
<td>
<b>P-Code</b></td>
<td>
<b>Native Code</b></td>
</tr>
<tr valign=top>
<td>
AND positive low word</td>
<td>
.0191 sec</td>
<td>
.0016 sec</td>
</tr>
<tr valign=top>
<td>
AND negative low word</td>
<td>
Overflow</td>
<td>
Overflow</td>
</tr>
<tr valign=top>
<td>
AND positive low word after sign check</td>
<td>
.0226 sec</td>
<td>
.0017 sec</td>
</tr>
<tr valign=top>
<td>
OR negative low word after sign check</td>
<td>
.0228 sec</td>
<td>
.0016 sec</td>
</tr>
<tr valign=top>
<td>
Copy low word with LSet</td>
<td>
.0232 sec</td>
<td>
.0033 sec</td>
</tr>
<tr valign=top>
<td>
Copy low word with CopyMemory</td>
<td>
.0259 sec</td>
<td>
.0068 sec</td>
</tr>
<tr valign=top>
<td>
AND low word in C++</td>
<td>
.0084 sec</td>
<td>
.0024 sec</td>
</tr>
</table><BR>
<BR>
<b>Conclusion:</b> It’s a close race with p-code but no contest with native code. <BR>A compiler covers a multitude of sins. Realistically, of course, that extra speed isn’t noticeable except in the most deeply nested of loops.</p>
<BR>
Not only is the C++ version easier to write, it’s also faster. Realistically, of course, that extra speed is seldom noticeable except in the most deeply nested loops. It’s certainly not worth adding a C++ DLL just for this function (or its relatives). In fact, if you check the performance sidebar, you can see that I have been <BR>cheating—comparing the p-code versions instead of the compiled versions. The version in the VBCore component (or BYTES.BAS) is actually the one that uses CopyMemory. It’s fast enough.</p>
</font></BODY>
</HTML>
