<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Where Angels Fear to Thread</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>

<font face="verdana,arial,helvetica" size="2"><h1><a name="whereangelsfeartothread"></a>Where Angels Fear to Thread</h1>
<BR>
The Test Thread program shown in Figure 11-6 starts a thread and lives to tell the tale—or at least it does if you can keep your hands off the debugging commands. That’s the first rule of thread debugging in the IDE. Don’t. Debug.Print seems to work for displaying status messages, but that’s about it.</p>
<BR><img src="f11te06.gif"></p><BR>
<b>Figure 11-6. The Test Thread program.</b></p>
<BR>
The program consists of two buttons that update four text boxes with data maintained by the thread. The main button toggles between starting the thread while passing it a parameter, and stopping the thread while receiving a return value:</p>
<pre><code>Private Sub cmdStartStop_Click()<BR>    If cmdStartStop.Caption = &quot;&amp;Start Thread&quot; Then<BR>        StartThread txtStartStop<BR>        cmdStartStop.Caption = &quot;&amp;Stop Thread&quot;<BR>        lblStartStop.Caption = &quot;Return value:&quot;<BR>        cmdUpdate_Click<BR>    Else<BR>        txtStartStop = StopThread<BR>        cmdStartStop.Caption = &quot;&amp;Start Thread&quot;<BR>        lblStartStop.Caption = &quot;Argument:&quot;<BR>        cmdUpdate_Click<BR>    End If<BR>End Sub<BR><BR>Private Sub cmdUpdate_Click()<BR>    txtCalc = CalcCount<BR>    txtAPI = APICount<BR>    txtBasic = BasicTime<BR>End Sub</code></pre>
<BR>
The CalcCount, APICount, and BasicTime functions are just public functions that return private variables modified by the thread procedure in THREAD.BAS. The thread procedure, like any procedure used with the AddressOf operator, must be in a standard module. You’re used to that from earlier experience with callbacks in Chapters 2 and 6. Here’s the code to start the thread procedure:</p>
<pre><code>Sub StartThread(ByVal i As Long)<BR>    ' Signal that thread is starting<BR>    fRunning = True<BR>    ' Create new thread<BR>    hThread = CreateThread(ByVal pNull, 0, AddressOf ThreadProc, _<BR>                           ByVal i, 0, idThread)<BR>    If hThread = 0 Then MsgBox &quot;Can't start thread&quot;<BR>End Sub</code></pre>
<BR>
First we signal that the thread is starting by using the most primitive and inflexible method of thread synchronization—a global variable. Bear with me. Then we call CreateThread to start a thread in the procedure ThreadProc. The first argument is the security attribute, which we ignore. The second is the stack size, which we pass as zero to let the operating system decide. The third argument is the address of the procedure that will run the thread. The fourth is a 32-bit parameter passed to the thread. This could be a pointer to something useful (such as a string or a UDT), but in this case, it’s just numeric data. The fifth argument is for options flags, but we don’t have any. The last argument is a reference to a variable that will receive the thread ID, a unique identifier which the sample program stores in the global variable <i>idThread </i>and then ignores. The function returns a thread handle, which is also stored in a global variable.</p>
<BR>
The thread procedures you start have some leeway in what they do, but some parts are invariant, as this example shows:</p>
<pre><code>Sub ThreadProc(ByVal i As Long)<BR>    ' Use parameter<BR>    cCalc = i<BR>    Do While fRunning<BR>        ' Calculate something<BR>        cCalc = cCalc + 1<BR>        ' Use an API call<BR>        cAPI = GetTickCount<BR>        ' Use a Basic function<BR>        datBasic = Now<BR>        ' Switch immediately to another thread<BR>        Sleep 1<BR>    Loop<BR>    ' Return a value<BR>    ExitThread cCalc<BR>End Sub</code></pre>
<BR>
The main purpose of this thread is to prove that we can indeed run a thread and do calculations, make API calls, and use Visual Basic statements inside it. After updating several global variables, the thread sleeps so that other threads can continue working immediately. When the main thread (the calling process) signals to stop by changing the <i>fRunning </i>variable, the thread exits by calling ExitThread, passing whatever it wishes to return to the process that started it.</p>
<BR>
The documentation for CreateThread says that the thread procedure can be a function that returns a Long value and that ExitThread will be called automatically. Well, that might be true in C or C++, but I crashed when I made ThreadProc a function and returned without explicitly calling ExitThread. I changed to a sub to make absolutely clear that the return value must go through ExitThread.</p>
<BR>
My StopThread procedure is what causes the thread loop to terminate so that ExitThread will be called:</p>
<pre><code>Function StopThread() As Long<BR>    ' Signal thread to stop<BR>    fRunning = False<BR>    ' Make sure thread is dead before returning exit code<BR>    Do<BR>        Call GetExitCodeThread(hThread, StopThread)<BR>    Loop While StopThread = STILL_ACTIVE<BR>    CloseHandle hThread<BR>    hThread = 0<BR>End Function</code></pre>
<BR>
It might take a while after the global variable is changed before the thread procedure checks the signal variable and terminates the thread, so StopThread has to loop until GetExitCodeThread comes up with a valid exit code.</p>
</font></BODY>
</HTML>
