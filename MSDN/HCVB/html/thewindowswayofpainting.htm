<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>The Windows Way of Painting</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>

<font face="verdana,arial,helvetica" size="2"><h1><a name="thewindowswayofpainting"></a>The Windows Way of Painting</h1>
<BR>
The Windows Way of painting is to beg, borrow, steal, or create a GDI object and then select that object into a device context. GDI objects, like almost every&shy;thing else in Windows, are identified by handle. These handle types include HBITMAP, HPEN, HBRUSH, HFONT, HPALETTE, and HRGN.</p>
<BR>
I’ve never found selecting objects into device contexts to be intuitive; I just do it by rote. Let’s go through the process with a bitmap. If you can select a bitmap, you can select anything. First you need an HDC to write to, and then you need the handle of a bitmap. How can you get an HBITMAP? Let me count the ways:
<ul>
<li>
You can create one with CreateBitmap or CreateCompatibleBitmap. We’ll do both in a later section, “Inside the Glass,” page 408.<BR><BR></li>
<li>
You can use the Handle property of a picture object containing a bit&shy;map. Because the Handle is the default member of the picture object and the picture object is the Picture property, you can think of the Picture property as the handle. But if you already have a picture containing a bitmap, you probably don’t need to select it into anything.<BR><BR></li>
<li>
You can get a handle to a bitmap out of a bitmap resource. You can get it into a picture with LoadResPicture (but then you don’t need it), or you can get it the hard way, as WinWatch does—by digging it out of an EXE file. See “Finding Resources,” Chapter 8.</li>
</ul>
<BR>
OK. Assuming that you have an HDC and an HBITMAP, you also need a handle to retain the old bitmap. Even if you created an empty DC and didn’t think you put a bitmap there, you’d better be prepared to get one out and put it back when you’re done. Your code looks something like this:</p>
<pre><code>Private hDC As Long, hBitmap As Long, hBitmapOld As Long<BR>’ Get hDC and hBitmap from somewhere<BR>§<BR>    hBitmapOld = SelectObject(hDC, hBitmap)</code></pre>
<BR>
At this point, if everything goes right, your bitmap appears in the device context. When you’re done, you must clean up by selecting the old bitmap (or other object) back into the DC and then deleting your bitmap:</p>
<pre><code>Call SelectObject(hDC, hBitmapOld)<BR>Call DeleteObject(hBitmap)</code></pre>
<BR>
I admit that I often ignore the return values. After all, what can you do if your cleanup fails? It’s not supposed to. OK, OK; so I should have asserted:</p>
<pre><code>f = SelectObject(hDC, hBitmapOld)<BR>BugAssert f<BR>f = DeleteObject(hBitmap)<BR>BugAssert f</code></pre>
<BR>
Is that good enough for you?</p>
<BR>
Since you don’t always know when it’s safe to destroy the object, you might find it easier to create a temporary DC, select the bitmap into it, copy your temporary DC to the target DC, and then destroy the temporary:</p>
<pre><code>hDCTemp = CreateCompatibleDC(0&amp;)<BR>hBitmapOld = SelectObject(hDCTemp, hBitmap)<BR>’ Copy temporary to destination<BR>Call BitBlt(hDCDst, 0, 0, dxDst, dyDst, hDCTemp, 0, 0, vbSrcCopy)<BR>Call SelectObject(hDCTemp, hBitmapOld)<BR>Call DeleteObject(hBitmap)<BR>Call DeleteDC(hDCTemp)</code></pre>
<BR>
Now you’re rid of the bitmap and don’t need to worry about selecting it out and deleting it later.</p>
<p>
The same process applies to pens, brushes, and fonts, although you’ll rarely need to use them in Visual Basic. The process is similar for palettes, except that you use the specific SelectPalette function instead of the generic SelectObject. If this seems like Greek to you, follow the instructions explicitly and all will be well.</p>
<p>
Technically, HMETAFILE, HCURSOR, and HICON aren’t considered GDI objects because you don’t select them as you do the others. But they are in the GDI, they work somewhat like objects, and they are part of the Windows Way. Nevertheless, we’ll ignore them here. I’ll talk about icon and cursor handles in Chapter 8. Other than the sidebar “Metafiles 1, Visual Basic 0,” page 373, you’re on your own with metafiles.</p>
</font></BODY>
</HTML>
