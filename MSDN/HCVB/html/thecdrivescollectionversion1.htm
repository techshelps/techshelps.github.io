<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>The CDrives collection, version 1</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>

<font face="verdana,arial,helvetica" size="2"><h1><a name="thecdrivescollectionversion1"></a>The CDrives collection, version 1</h1>
<BR>
You can use the CDrive class from Chapter 3 to create a CDrives collection class. Notice the naming convention: collectionlike classes should always be plural. Figure 4-2 shows the CDrives collection and its relationship to the CDrive class. But before we get to the real CDrives class, let’s look at my first implementation, which I saved under the name CDrivesO.</p>
<BR><img src="f04te02.gif"></p><BR>
<b>Figure 4-2. The CDrives class.</b></p>
<BR>
The following code (from TCOLLECT.FRM) shows that CDrives and CDrivesO are mostly polymorphic classes that can be called using the same code:</p>
<pre><code>s = s &amp; “Drive information for available drives:” &amp; sCrLf<BR>Dim drives As Object, drive As CDrive<BR>If chkOld Then<BR>    Set drives = New CDrivesO<BR>Else<BR>    Set drives = New CDrives<BR>End If<BR>For Each drive In drives<BR>    With drive<BR>        s = s &amp; “Drive “ &amp; .Root &amp; “ [“ &amp; .Label &amp; “:” &amp; _<BR>                .Serial &amp; “] (“ &amp; .KindStr &amp; “) has “ &amp; _<BR>                Format$(.FreeBytes, sBFormat) &amp; “ free from “ &amp; _<BR>                Format$(.TotalBytes, sBFormat) &amp; sCrLf<BR>    End With<BR>Next</code></pre>
<BR>
Most of the work in a class representing an internal Collection is done in the Class_Initialize event procedure. Here’s how it works in CDrivesO:</p>
<pre><code>Private drives As New Collection<BR><BR>Private Sub Class_Initialize()<BR>    Refresh<BR>End Sub
‘ Argument handy for refreshing local and/or remote, but not floppies<BR>Public Sub Refresh(Optional iFirst As Integer = 1)<BR>    Dim i As Integer, af As Long, sRoot As String<BR>    Dim drive As CDrive<BR>    ‘ Remove old ones<BR>    Do While drives.Count &gt; iFirst<BR>        drives.Remove iFirst<BR>    Loop<BR>    ‘ Insert new<BR>    af = GetLogicalDrives()<BR>    For i = iFirst To 26<BR>        If RShiftDWord(af, i - 1) And 1 Then<BR>            Set drive = New CDrive<BR>            drive.Root = i<BR>            drives.Add drive, drive.Root<BR>        End If<BR>    Next<BR>End Sub</code></pre>
<BR>
The Class_Initialize Sub simply calls Refresh to do the real work. Calling a public initialization method from the initialization event is a common technique in classes that sometimes need to override automatic initialization. Refresh uses <BR>the Win32 GetLogicalDrives function and the RShiftDWord function (described in Chapter 5) to calculate which drives actually exist in the system. The drives are then initialized and added to the internal Collection. The Refresh method is important and useful for the old version, but you’ll soon see that it’s now history in the real CDrives class, which calculates drives as they are needed.</p>
<BR>
With the internal Collection in place, it’s easy to implement the standard properties and methods of a collection. You expose the Count and Item properties by passing through the Count and Item of the internal Collection as follows:</p>
<pre><code>Public Property Get Count() As Integer<BR>    Count = drives.Count<BR>End Property<BR><BR>‘ Default property<BR>Public Property Get Item(v As Variant) As CDrive<BR>    ‘ Return default (Nothing) if error<BR>    On Error Resume Next<BR>    Set Item = drives(v)<BR>End Property</code></pre>
<p>
Embedding a Collection object in the class and passing its members through with similar external members is another example of delegation. In a classic object-oriented language, you would use inheritance for the same purpose. Specifically, you would derive the CDrivesO class from the Collection class. You wouldn’t have to write any code to get the Count and Item properties. You would have to write code for any additional members you wanted (such as Refresh), and you’d disable or enhance any members you wanted to eliminate or change (such as Add and Remove).</p>
<p>
At first glance, you might think it impossible to implement the Add and Remove properties. If you could add a new drive to your system just by calling the Add method, you’d never run out of disk space, but even the Plug and Play standard can’t promise that. On the other hand, it’s easy enough to use Add to connect to a network drive and Remove to disconnect one. Check out the WNetAddConnection2 and WNetCancelConnection2 API functions. I’ll leave it to you to enhance the CDrives collection to make it fully network-aware.</p>
</font></BODY>
</HTML>
