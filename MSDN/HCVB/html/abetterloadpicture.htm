<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>A better LoadPicture</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>

<font face="verdana,arial,helvetica" size="2"><h1><a name="abetterloadpicture"></a>A better LoadPicture</h1>
<BR>
You can load any icon into a picture if you have a handle for the icon. The IconToPicture function (PICTOOL.BAS) turns an icon handle into a Picture object in the same way BitmapToPicture turns a bitmap into a picture. (For more information, see “Using Bitmaps,” page 453). Therefore, if you could get the handle of a small icon image out of a multi-image icon file, you could load it into a picture. </p>
<BR>
It so happens that the Win32 API has a new LoadImage function that delivers icons, cursors, and bitmaps. I don’t need it for bitmaps, and I haven’t figured out a good way to use it for cursors, but it works fine for icons. You tell it what size icon you want, and it gives you a handle to that icon. As an added benefit, LoadImage can load from either an ICO file or from an icon resource. In other words, it does most of the work of the Visual Basic LoadPicture and LoadRes&shy;Picture functions. I use LoadImage to create a better LoadAnyPicture that takes an additional optional argument that specifies what kind of icon to load. Here’s how the Test Icons program calls my new LoadPicture:</p>
<pre><code>‘ Load icon with Basic’s LoadPicture (system metrics size)<BR>Set img(eipBasic).Picture = LoadPicture(“i.ico”)<BR>Set pb(eipBasic).Picture = LoadPicture(“i.ico”)<BR>‘ Load icon with Basic’s LoadPicture (system metrics size)<BR>Set img(eipDefault).Picture = LoadAnyPicture(“i.ico”, eisDefault)<BR>Set pb(eipDefault).Picture = LoadAnyPicture(“i.ico”, eisDefault)<BR>‘ Load icon stretched to system metrics size<BR>Set img(eipShell).Picture = LoadAnyPicture(“i.ico”, eisShell)<BR>Set pb(eipShell).Picture = LoadAnyPicture(“i.ico”, eisShell)<BR>‘ Load first icon image in file with its real size<BR>Set img(eipImage).Picture = LoadAnyPicture(“i.ico”, eisImage)<BR>Set pb(eipImage).Picture = LoadAnyPicture(“i.ico”, eisImage)<BR>‘ Load small (16 by 16) icon, squashing if necessary<BR>Set img(eipSmall).Picture = LoadAnyPicture(“i.ico”, eisSmall)<BR>Set pb(eipSmall).Picture = LoadAnyPicture(“i.ico”, eisSmall)<BR>‘ Load huge (48 by 48) icon<BR>Set img(eipHuge).Picture = LoadAnyPicture(“i.ico”, eisHuge)<BR>Set pb(eipHuge).Picture = LoadAnyPicture(“i.ico”, eisHuge)</code></pre>
<BR>
Notice the fourth set of commands (the ones with the <i>eisImage </i>parameter). This is how you load small icons and other icons of unusual size from single-image icon files. Normally, Visual Basic stretches these icons to the system metrics size, but if you give the <i>eisImage </i>constant, you should get the real size of the image. In most cases, you should let Windows decide which image to use and when. But if you had an icon editor that let you define icons of any size, you could use LoadAnyPicture with <i>eisImage</i> to get transparent images for animation. </p>
<BR>
Here’s the code for the better LoadPicture from PICTOOL.BAS: </p>
<pre><code>Function LoadAnyPicture(Optional sPicture As String, _<BR>                        Optional eis As EIconSize = eisDefault _<BR>                        ) As Picture<BR>    Dim hIcon As Long, sExt As String, xy As Long, af As Long<BR>    ‘ If no picture, return Nothing (clears picture)<BR>    If sPicture = sEmpty Then Exit Function<BR>    ‘ Use default LoadPicture for all except icons with argument<BR>    sExt = MUtility.GetFileExt(sPicture)<BR>    If UCase$(sExt) &lt;&gt; “.ICO” Or eis = -1 Then<BR>        Set LoadAnyPicture = VB.LoadPicture(sPicture)<BR>        Exit Function<BR>    End If<BR>    <BR>    Select Case eis<BR>    Case eisSmall<BR>        xy = 16: af = LR_LOADFROMFILE<BR>    Case eisHuge<BR>        xy = 48: af = LR_LOADFROMFILE<BR>    Case eisImage<BR>        xy = 0: af = LR_LOADFROMFILE Or LR_LOADREALSIZE<BR>    Case eisShell ‘ Get icon size from system<BR>        xy = GetShellIconSize(): af = LR_LOADFROMFILE<BR>    Case Is &gt; 0   ‘ Use arbitrary specified size—72 by 72 or whatever<BR>        xy = eis: af = LR_LOADFROMFILE<BR>    Case Else     ‘ Includes eisDefault<BR>        xy = 0: af = LR_LOADFROMFILE Or LR_DEFAULTSIZE<BR>    End Select<BR>    hIcon = LoadImage(0&amp;, sPicture, IMAGE_ICON, xy, xy, af)<BR>    ‘ If this fails, use original load<BR>    If hIcon &lt;&gt; hNull Then<BR>        Set LoadAnyPicture = IconToPicture(hIcon)<BR>    Else<BR>        Set LoadAnyPicture = VB.LoadPicture(sPicture)<BR>    End If<BR>End Function</code></pre>
<BR>
This function deals only with icons. The first section of code checks for other types or for a command line without an optional argument, and then calls the normal LoadPicture to do the work. If an optional argument is provided, the code sets up the appropriate size and flags and calls LoadImage. Finally it checks to see whether LoadImage worked, and, if not, it again falls back on the original LoadPicture. The LoadImage function is implemented as a stub under Windows NT 3.51, so you’ll always fall through to the old LoadPicture. That’s OK because all icons are the same size in that environment.</p>
</font></BODY>
</HTML>
