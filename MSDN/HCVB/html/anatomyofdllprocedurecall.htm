<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Anatomy of a DLL Procedure Call</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>

<font face="verdana,arial,helvetica" size="2"><h1><a name="anatomyofdllprocedurecall"></a>Anatomy of a DLL Procedure Call</h1>
<p>
We’ve been pretending that the ZAPI functions are written in Basic to be called by Basic, but in reality they are written as a C DLL to be called from C, Pascal, Logo, Scheme, and the current language of the month. The ZAPI library couldn’t be a Visual Basic DLL because it needs to support all languages directly, not through COM Automation. Also, many callers won’t have the Visual Basic run-time DLL on their disks. The last thing the author of ZAPI had in mind was making it easy to call API functions from Basic. Internally, ZAPI uses whatever conventions are most efficient (usually taken from C, but sometimes from Pascal).</p>
<p>
In order to call a procedure in a DLL, you need either a type library entry or a Declare statement for it. Since Declare statements are written in Basic, I’ll concentrate on them. The Zapem API function, shown in Figure 2-5, serves as a preliminary model for writing and using Declare statements.</p>
<p><img src="f02te05.gif"></p><p>
<b>Figure 2-5.&nbsp;Declaring and using a DLL function.</b></p>
<p>
A lot is packed into this short bit of code. Take a look at the labeled sections in Figure 2-5, which correspond to the numbered sections here:
<ol>
<li>
A Declare statement looks sort of like the first line of a procedure <BR>definition except that it starts with the Declare keyword. You specify whether the procedure is a Sub or a Function and then give the name of the procedure followed by the argument list and, for Functions, the return value.<br><br></li>
<li>
You must include the name of the DLL containing the procedure in <BR>a Lib clause. If you’re calling your own DLL, you probably know the name. If you’re calling the Windows API, you sometimes have to guess. C programmers don’t need to put the DLL name in their declarations, and since most API documentation is designed for C programmers, you might have trouble figuring it out. Microsoft Visual C++ comes with a file named WIN32API.CSV that tells all for Win32. Another tech&shy;nique is to use the /DUMP option of the LINK program provided with Visual Basic. The command <i>LINK /DUMP /EXPORTS ODBC32.DLL</i>, for example, will show all the functions provided by the ODBC32 DLL. If that doesn’t help, use the trial-and-error method, starting with the DLLs shown in Table 2-1.<table>
<tr valign=top>
<td>
<b>Services</b></td>
<td>
<b>DLL</b></td>
</tr>
<tr valign=top>
<td>
Common controls</td>
<td>
COMCTL32</td>
</tr>
<tr valign=top>
<td>
Common dialogs</td>
<td>
COMDLG32</td>
</tr>
<tr valign=top>
<td>
Drag and drop, icon extraction, Windows 95 shell</td>
<td>
SHELL32</td>
</tr>
<tr valign=top>
<td>
Graphics Device Interface</td>
<td>
GDI32</td>
</tr>
<tr valign=top>
<td>
Graphics (3-D lines and surfaces)</td>
<td>
OPENGL32 (NT only)</td>
</tr>
<tr valign=top>
<td>
Graphics (games and animation)</td>
<td>
WING32</td>
</tr>
<tr valign=top>
<td>
Memory, disks, processes, resources, tasks, modules</td>
<td>
KERNEL32</td>
</tr>
<tr valign=top>
<td>
Multimedia, sound, MIDI, joysticks, timing</td>
<td>
WINMM</td>
</tr>
<tr valign=top>
<td>
Networks (WNet)</td>
<td>
MPR</td>
</tr>
<tr valign=top>
<td>
Networks (LanMan)</td>
<td>
NETAPI32</td>
</tr>
<tr valign=top>
<td>
NT Security, Registry, and other advanced services</td>
<td>
ADVAPI32</td>
</tr>
<tr valign=top>
<td>
Component Object Model (COM)</td>
<td>
OLE32</td>
</tr>
<tr valign=top>
<td>
Automation and type conversion</td>
<td>
OLEAUT32</td>
</tr>
<tr valign=top>
<td>
Version checking</td>
<td>
VERSION</td>
</tr>
<tr valign=top>
<td>
Windows, menus, strings, messages</td>
<td>
USER32</td>
</tr>
</table><br>
</li>
</ol>
<p>
<b>Table 2-1.&nbsp;Windows system DLLs.</b>
<ol>
<li>
The big question is whether to pass by value or by reference. Most <BR>arguments should be passed by value, but you’ll hear a lot about the exceptions later in this chapter.<br><br></li>
<li>
The original Basic version of Zapem returned a Boolean value, but <BR>the Windows BOOL type isn’t the same as a Basic Boolean. A BOOL <BR>is actually an int, which is 32 bits wide. To C programmers, a Boolean <BR>is actually a typedef called VARIANT_BOOL that evaluates to a C short (16 bits). In other words, a Boolean is the same size as a Basic Integer. Although you should declare what Windows calls BOOL as Long, you can assign the result to a Boolean. Basic automatically performs the type conversion from Long to Boolean on return values.</li>
</ol>
<p>
That’s the quick introduction to API calls. When you get down to actual coding, though, things get complicated. Every type of argument has its own quirks and patterns, and you must look at each type specifically. Fortunately, the Windows API never uses the Variant, Currency, Single, or Double type. The remaining types fall into patterns that I can discuss one by one.</p>
<p>
The COM Automation API uses Variant and other Visual Basic data types. Theoretically, you could use them in declarations for the COM Automation system DLLs or for COM Automation–compatible DLLs that you write. You can even use the Optional and ParamArray attributes in Declare statements. This chapter, however, concentrates on the integer and string types used by the Windows API.</p>
</font></BODY>
</HTML>
