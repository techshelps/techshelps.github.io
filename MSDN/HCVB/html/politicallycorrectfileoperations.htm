<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Politically Correct File Operations</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>

<font face="verdana,arial,helvetica" size="2"><h1><a name="politicallycorrectfileoperations"></a>Politically Correct File Operations</h1>
<BR>
Deleting, copying, renaming, and moving files should be simple, right? Visual Basic provides the Kill, FileCopy, and Name statements for the first three operations and, contrary to the documentation, you can also use Name to move files across disks. Who could be offended by such simple features?</p>
<BR>
Well, you might be offended if the FileCopy statement overwrote an important file without asking for confirmation. I might be ticked off if your Kill statement accidentally killed all the files in the DeleteMe.Not folder, with no way to &shy;recover them. Our customers might be frustrated and confused if our FileCopy brought the whole system to a halt while copying a 1-MB file from a remote drive to a floppy disk with no visual clue to why the keyboard and the mouse weren’t responding.</p>
<BR>
The SHFileOperation function provides the means to delete, rename, copy, and move files with all the protections, warnings, and status reports you could ever imagine—and some that you never dreamed of. I use SHFileOperation in my CopyAnyFile, DeleteAnyFile, RenameAnyFile, and MoveAnyFile functions.</p>
<BR>
For the SHFileOperation function, I use both Visual Basic UDT and Declare statements because they work better than the type library for strings in structures. There’s something very unusual about the C structure, so let’s have a look:</p>
<pre><code>Private Declare Function SHFileOperation Lib &quot;shell32.dll&quot; _<BR>    Alias &quot;SHFileOperationA&quot; (lpFileOp As SHFILEOPSTRUCT) As Long<BR><BR>Private Type SHFILEOPSTRUCT<BR>    hWnd As Long                ' Window owner of any dialogs<BR>    wFunc As Long               ' Copy, move, rename, or delete code<BR>    pFrom As String             ' Source file<BR>    pTo As String               ' Destination file or directory<BR>    fFlags As Integer           ' Options to control the operations</code></pre>
<BR>
Busted</p>
<BR>
Many old programs (including the previous version of a well-known programming environment which I won’t name because it has been fixed) provide an example of how not to program files under 32-bit Windows. When these programs modify a file, the creation time and the modification time are always the same. In other words, they don’t really modify the files when you save them. Instead, they re-create the file, probably in the same way most 16-bit programs modify a file. They copy to a temporary file, make the changes on the copy, and, if all goes well, close the temporary, delete the old version, and rename the temporary to the old name.</p>
<BR>
Uh-oh. What’s that flashing red light in the mirror?</p>
<BR>
“OK, buddy. You know what you did wrong?”</p>
<BR>
“I didn’t do anything, officer. I’ve been saving files that way for years, and nobody ever complained before.”</p>
<BR>
“Yeah, that’s because you were driving on 16-bit roads. We couldn’t recognize you guys there, but I can spot an old MS-DOS programmer a mile off on this new 32-bit superhighway.”</p>
<BR>
“Hey, how did you know?”</p>
<p>
“Look at that file creation time. When I see one that’s the same as the write time, 95 times out of 100 it’s one of you old programmers replacing a file without copying the time and attributes.”</p>
<p>
“What’s wrong with that?”</p>
<pre><code>    fAnyOperationsAbortedLo As Integer ' Indicates partial failure<BR>    fAnyOperationsAbortedHi As Integer<BR>    hNameMappingsLo As Long     ' Array indicating each success<BR>    hNameMappingsHi As Long<BR>    lpszProgressTitleLo As Long ' Title for progress dialog<BR>    lpszProgressTitleHi As Long<BR>End Type</code></pre>
<BR>
The first few fields indicating the operation and the files to work on are easy. But there’s something wrong with the <i>fFlags </i>field. It’s an Integer instead of a Long, and in the C include files the designer took special steps to declare that the structure members shouldn’t be aligned on DWORD boundaries. Visual Basic (and some other languages) always align structure fields on DWORD boundaries because it makes access more efficient. The only way to fake the original alignment is to split the fields into separate high and low words. Fortunately, </p>
<BR>
“I’ll bet this file is actually three months, maybe a year old. You’re falsifying data. It might be an innocent mistake, but you’re hurting yourself. The file taxes are higher on newer files. And it also screws up our maintenance equipment. Tell you what—I’ll give you a break. Just take this warning ticket into the station within three days and pick up our ReplaceFile function from FILETOOL.BAS. Use it from now on, and we’ll cancel the 4-MB disk fine.”</p>
<pre><code>Sub ReplaceFile(sOld As String, sTmp As String)<BR>    Dim fnd As WIN32_FIND_DATA, hFind As Long, hOld As Long, f As Boolean<BR>    ' Get file time and attributes of old file
    hFind = FindFirstFile(sOld, fnd)<BR>    If hFind = hInvalid Then ApiRaise Err.LastDllError<BR>    ' Replace by deleting old and renaming new to old<BR>    Kill sOld<BR>    Name sTmp As sOld<BR>    ' Assign old attributes and time to new file<BR>    hOld = lopen(sOld, OF_WRITE Or OF_SHARE_DENY_WRITE)<BR>    If hOld = hInvalid Then ApiRaise Err.LastDllError<BR>    f = SetFileTime(hOld, fnd.ftCreationTime, _<BR>                    fnd.ftLastAccessTime, fnd.ftLastWriteTime)<BR>    If f Then ApiRaise Err.LastDllError<BR>    lclose hOld<BR>    f = SetFileAttributes(sOld, fnd.dwFileAttributes)<BR>    If f Then ApiRaise Err.LastDllError<BR>End Sub</code></pre>
<p>
“Now why didn’t I think of that? Hey, thanks.”</p>
<p>
“No problem, buddy. But if I catch you overwriting file times again, I’m going to throw the disk at you.”<BR>
</dd>
<dt>
these fields aren’t as important as the other fields, and in fact, my code doesn’t use them. But if you want to, you’re in for a struggle.</p>
<p>
Why the packing? Normally, the only reason to pack structures is so that you can store more of them on disk, but nobody’s going to be using a big array of these structures. If the designers had some good reason (that I can’t imagine) to pack the structure and make the <i>fFlags </i>field (with its bad Hungarian name) an Integer rather than a Long, why not put it at the end so it doesn’t throw all the others out of alignment? This is typical of the SH functions, all of which seem half-baked, unfinished, and inconsistent with the rest of the Windows API. For example, why is the structure given the redundant name SHFILEOPSTRUCT instead of SHFILEOP or just FILEOP? If you like hopeless arguments about API design, the shell functions leave plenty of room for debate.</p>
<BR>
The CopyAnyFile function illustrates the general form of my wrapper functions. You can find the others in FILETOOL.BAS.</p>
<pre><code>Function CopyAnyFile(sSrc As String, sDst As String, _<BR>                     Optional Options As Long = 0, _<BR>                     Optional Owner As Long = hNull) As Boolean<BR>    If MUtility.HasShell Then<BR>        Dim fo As SHFILEOPSTRUCT, f As Long<BR>        fo.wFunc = FO_COPY<BR>        Debug.Print TypeName(fo.wFunc)<BR>        fo.pFrom = sSrc<BR>        fo.pTo = sDst<BR>        fo.fFlags = Options<BR>        fo.hWnd = Owner<BR>        ' Mask out invalid flags<BR>        fo.fFlags = fo.fFlags And FOF_COPYFLAGS<BR>        f = SHFileOperation(fo)<BR>        CopyAnyFile = (f = 0)<BR>    Else<BR>        ' For Windows NT 3.51<BR>        On Error Resume Next<BR>        ' FileCopy expects full name of destination file<BR>        FileCopy sSrc, sDst<BR>        If Err Then<BR>            Err = 0<BR>            ' CopyAnyFile can handle destination directory<BR>            sDst = MUtility.NormalizePath(sDst) &amp; _<BR>                   MUtility.GetFileBaseExt(sSrc)<BR>            FileCopy sSrc, sDst<BR>        End If<BR>        ' Enhance further to emulate SHFileOperation options<BR>        ' such as validation and wild cards<BR>        CopyAnyFile = (Err = 0)<BR>    End If<BR>End Function</code></pre>
<BR>
The trick in calling FileCopy, FileMove, FileRename, and FileDelete is to pass the correct flags. Table 11-2 offers a brief summary of the flags. The default behavior is to produce a confirmation dialog box if anything is to be deleted or overwritten and to put up a progress dialog box if the operation lasts long enough to make a user wonder what’s going on. You can test other operations with the Windows Interface Tricks application, shown in Figure 11-10 on the following page.</p>
<table>
<tr valign=top>
<td>
<b>Flag</b></td>
<td>
<b>Purpose</b></td>
</tr>
<tr valign=top>
<td>
FOF_NOCONFIRMATION</td>
<td>
Overwrite or delete files without confirmation</td>
</tr>
<tr valign=top>
<td>
FOF_ALLOWUNDO</td>
<td>
Put deleted files (except those from floppy disks) in Recycle Bin</td>
</tr>
<tr valign=top>
<td>
FOF_SILENT</td>
<td>
Prevent display of a progress dialog box for slow operations</td>
</tr>
<tr valign=top>
<td>
FOF_SIMPLEPROGRESS</td>
<td>
Simplify the progress dialog box by not showing filenames</td>
</tr>
<tr valign=top>
<td>
FOF_RENAMEONCOLLISION</td>
<td>
Create new numbered files (<i>Copy #1 of...</i>) if copied or moved files conflict with existing files</td>
</tr>
<tr valign=top>
<td>
FOF_MULTIDESTFILES</td>
<td>
Copy or move a wildcard source to multiple </td>
</tr>
<tr valign=top>
<td>
target files rather than to a single destination directory</td>
<td>
</td>
</tr>
<tr valign=top>
<td>
FOF_FILESONLY</td>
<td>
Interpret a wildcard source to mean files only, not directories</td>
</tr>
<tr valign=top>
<td>
FOF_NOCONFIRMMKDIR</td>
<td>
Create any needed destination directories without confirmation</td>
</tr>
</table><BR>
<BR>
<b>Table 11-2. Option flags for file operation functions.</b></p>
</font></BODY>
</HTML>
