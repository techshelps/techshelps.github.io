<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Functional DLLs</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>

<font face="verdana,arial,helvetica" size="2"><h1><a name="functionaldlls"></a>Functional DLLs</h1>
<BR>
The DLLs in Visual Basic version 4 were a useful feature, but some programmers wanted more. They wanted to put functions in DLLs, just as you can do with most other languages that support DLLs. Visual Basic seemed to be split into two different worlds. In programs, object-oriented programming was voluntary. In DLLs, it was mandatory. If you wanted to put ordinary procedures in a DLL, well, you could write that DLL in some other language.</p>
<BR>
If you looked in the Object Browser, you could see that Visual Basic itself wasn’t playing by the same rules. It had the Visual Basic Objects and Procedures li&shy;&shy;-<BR>brary and the Visual Basic for Applications library. Somebody was writing DLLs containing both procedures and classes in some language. Why couldn’t that language be Visual Basic? This is a familiar story. Visual Basic used optional <BR>arguments, controls, properties on forms, and who knows what else before it let us use them. But eventually it lets us play ball.</p>
<BR>
Visual Basic version 5 lets you put procedures in DLLs, but the feature isn’t as simple as you might hope. Something strange is going on behind the scenes. You can see it in the Object Browser. Sure, it looks like FileLen is a function in the Visual Basic for Applications library. You can use FileLen as if it were a function. But it’s not. It’s a method of the VBA object. Anytime you want to use FileLen, you have a choice. You can say this:</p>
<pre><code>cFile = VBA.FileLen(sFile)</code></pre>
<BR>
Or you can say this:</p>
<pre><code>cFile = FileLen(sFile)</code></pre>
<BR>
It’s a pretty obvious choice in most cases, although the sidebar “Better Basic Through Subclassing” describes a situation where you want to qualify library procedures. The VBA object is kind of a default object—comparable to a default property. You can leave off the object name just as you can leave off the property name of a default property. Visual Basic instantiates the VBA object for you, and you can pretend it doesn’t exist.</p>
<BR>
The secret to putting procedures in a DLL is that you write them as methods of what Visual Basic calls a global object. We’re now ready to write a library called VBCore, based on global objects.</p>
</font></BODY>
</HTML>
