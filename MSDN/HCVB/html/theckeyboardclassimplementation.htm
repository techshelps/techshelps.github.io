<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>The CKeyboard Class Implementation</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>

<font face="verdana,arial,helvetica" size="2"><h1><a name="theckeyboardclassimplementation"></a>The CKeyboard Class Implementation</h1>
<BR>
CKeyboard is a simple wrapper for the Windows functions GetKeyboardState and SetKeyboardState. These two functions work on an array of 256 bytes that represent the 256 keys on the keyboard. What? Your keyboard doesn’t have 256 keys? Well, if it did, you could put them in this array. Windows is just leaving room for expansion.</p>
<BR>
The Byte type in Visual Basic makes key handling easy. The CKeyboard property procedures share the following private array:</p>
<pre><code>Private abKeys(0 To 255) As Byte</code></pre>
<BR>
To read the state of a key, you get all the key states and then read the one you want, using the virtual key code as an index into the key array:</p>
<pre><code>Property Get CapsState() As Boolean<BR>    ' Get toggled and pressed state of all keys<BR>    GetKeyboardState abKeys(0)<BR>    ' Check low bit for state<BR>    CapsState = abKeys(VK_CAPITAL) And 1<BR>End Property</code></pre>
<BR>
The low bit of each toggle key indicates whether the toggle is on or off. Notice how we pass the array to GetKeyboardState by passing the first element. “Arrays” in Chapter 2 explains how this works.</p>
<BR>
Virtual key codes in the Visual Basic format (such as vbKeyInsert) are in the VBRUN type library under KeyCodeConstants. You can also find them with Windows-style names (VK_DELETE) in the Windows API type library under UserConst.</p>
<BR>
To change the state of a key, you must read in the current key states, modify the key in the array, and write the result back with SetKeyboardState:</p>
<pre><code>Property Let CapsState(fCapsStateA As Boolean)<BR>    ' Get toggled and pressed state of all keys<BR>    GetKeyboardState abKeys(0)<BR>    ' Set low bit to new pressed state<BR>    If fCapsStateA Then<BR>        abKeys(VK_CAPITAL) = abKeys(VK_CAPITAL) Or 1<BR>    Else<BR>        abKeys(VK_CAPITAL) = abKeys(VK_CAPITAL) And &amp;HFE<BR>    End If<BR>    ' Store changed array<BR>    SetKeyboardState abKeys(0)<BR>End Property</code></pre>
<BR>
The KeyPressed property works the same way, except that it will check any key. The pressed state of a key is stored in the high bit, and you must provide the virtual key code of the key. Here’s the Property Get procedure:</p>
<pre><code>Property Get KeyPressed(iKey As Integer) As Boolean<BR>    ' Get toggled and pressed state of all keys<BR>    GetKeyboardState abKeys(0)<BR>    ' Check high bit for state<BR>    KeyPressed = abKeys(iKey) And &amp;H80<BR>End Property</code></pre>
<BR>
A Property Get procedure with an argument makes the property look like an array element, as described in the sidebar “Property Arrays” in Chapter 4. Check out the KeyPressed Property Let in KEYBOARD.CLS.</p>
<BR>
Here’s how you can use KeyPressed to read keys:</p>
<pre><code>fShift = Keyboard.KeyPressed(VK_CONTROL) ' Is Ctrl key down?</code></pre>
<BR>
You can also press a key programmatically:</p>
<pre><code>Keyboard.KeyPressed(VK_F1) = True   ' Press F1<BR>DoEvents<BR>Keyboard.KeyPressed(VK_F1) = False  ' Release F1</code></pre>
<BR>
So why didn’t I use the KeyPressed property to press the insert key in the XEditor control? Because KeyPressed puts the key into the system keyboard queue, and the system determines what window to route the key to. I wanted to send the key to a specific window.</p>
</font></BODY>
</HTML>
