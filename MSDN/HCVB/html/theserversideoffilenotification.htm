<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>The Server Side of File Notification</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>

<font face="verdana,arial,helvetica" size="2"><h1><a name="theserversideoffilenotification"></a>The Server Side of File Notification</h1>
<BR>
The File Notification Server is a slow EXE server, not a fast DLL server. Why? Because a DLL server would be too efficient. You want the server code to run in a separate thread, and, in Visual Basic, putting it in a separate EXE is the best way to do that. Performance isn’t really an issue with file notification. The more important issue is making sure notifications don’t slow down normal operation of the client.</p>
<BR>
The Connect method is what launches each file notification thread, but before we examine it, let’s look at some of the data it uses. The server maintains an array of notification handles. In addition, it must keep a parallel array of the data associated with each handle. Later you’ll see why the handles need to be in a separate array. For each notification, the server maintains four pieces of information: the directory to be watched, the type of event, a flag indicating whether to check subdirectories, and the IFileNotifier object to be called when a file event occurs. The data looks like this:</p>
<pre><code>Public Type TConnection<BR>    sDir As String<BR>    efn As EFILE_NOTIFY<BR>    fSubTree As Boolean<BR>    notifier As IFileNotifier<BR>End Type<BR><BR>' Actually cLastNotify + 1 allowed<BR>Public Const cLastNotify = 28<BR>' One extra blank item in each array for easy compacting<BR>Public ahNotify(0 To cLastNotify + 1) As Long<BR>Public aconNotify(0 To cLastNotify + 1) As TConnection<BR>Public aerr(errFirst To errLast) As String<BR>' Count of connected objects managed by class<BR>Public cObject As Long</code></pre>
<BR>
I use arrays with a fixed size because it’s easier than dealing with dynamic structures. In a single-threaded server, you’d have one handle and one connection block for each client, but the Notify server is marked for unattended execution with a thread pool of four. Each of those threads will have its own array of handles, so potentially you could have more than 100 clients. Realistically it’s pretty unlikely that the server would have more than four simultaneous clients. Regardless of threads and clients, the notification handles must be arranged in an array because, as you’ll see shortly, that’s the way WaitForMultipleHandles expects them. That’s why handles and object data are kept in parallel arrays. Notice that the array is public data residing in NOTIFY.BAS, not in NOTIFY.CLS. Every client (within the same thread) shares the same arrays of handles and notifications.</p>
<BR>
Here’s how the Connect method initializes this data for each notification request:</p>
<pre><code>Function Connect(notifier As IFileNotifier, sDir As String, _<BR>                 efn As EFILE_NOTIFY, fSubTree As Boolean) As Long<BR>    Connect = hInvalid ' Assume fail<BR>    Dim i As Long, h As Long<BR>    ' Find blank handle space<BR>    For i = 0 To cLastNotify<BR>        If ahNotify(i) = hInvalid Then<BR>            ' Set up notification<BR>            h = FindFirstChangeNotification(sDir, fSubTree, efn)<BR>            Connect = h<BR>            If h = hInvalid Then<BR>                ' Change notification unsupported on remote disks<BR>                If Err.LastDllError &lt;&gt; ERROR_NOT_SUPPORTED Then<BR>                    RaiseError errInvalidArgument<BR>                End If<BR>                Exit Function<BR>            End If<BR>            ' Store information<BR>            ahNotify(i) = h<BR>            With aconNotify(i)<BR>                Set .notifier = notifier<BR>                .sDir = sDir<BR>                .efn = efn<BR>                .fSubTree = fSubTree<BR>            End With<BR>            Exit Function<BR>        End If<BR>    Next<BR>    RaiseError errTooManyNotifications<BR>End Function</code></pre>
<BR>
Connect looks for a blank slot in the array. When it finds one, it initializes the slot with a file notification handle obtained by calling the FindFirst&shy;&shy;-<BR>ChangeNotification API function. You can see what happens to the parameters passed by the client. If everything goes well, Connect stores the handle and other data in the appropriate arrays. You can look through the code to see the details of how RaiseError handles errors and Disconnect undoes the work done by Connect.</p>
<BR>
The important point about this code is that FindFirstChangeNotification requests that the kernel send off a thread to watch for file events. All you need to do is wait for the event to happen. But wait where? Who will the kernel notify when it gets a file event? It can’t wait in the Connect event (which must return to the client), but where else can it go? </p>
<BR>
The only other place is in the server’s standard module. You need a loop that checks periodically for changes. Theoretically, you could put the loop in Sub Main (as I did in the previous version of this book). But changes in the way Visual Basic handles server startup forced me to change. I use the Main procedure to initialize server data, but at some point I have to return control to the client. So instead of looping in Main, I use a Windows timer to start a separate loop procedure. Here’s the initialization code:</p>
<pre><code>Sub Main()<BR><BR>    Dim i As Integer<BR>    For i = 0 To cLastNotify<BR>        ahNotify(i) = hInvalid<BR>    Next<BR>    aerr(errInvalidDirectory) = &quot;Invalid directory&quot;<BR>    aerr(errInvalidType) = &quot;Invalid notification type&quot;<BR>    aerr(errInvalidArgument) = &quot;Invalid argument&quot;<BR>    aerr(errTooManyNotifications) = &quot;Too many notifications&quot;<BR>    aerr(errNotificationNotFound) = &quot;Notification not found&quot;<BR>    BugMessage &quot;Initialized static data&quot;<BR><BR>    ' Start the wait loop and return to the caller<BR>    Call SetTimer(hNull, 0, 200, AddressOf WaitForNotify)<BR>    BugMessage &quot;Started Timer&quot;<BR>    <BR>End Sub</code></pre>
<BR>
The SetTimer function specifies that a callback called WaitForNotify will be started every 200 milliseconds. You can see a better example of a Windows timer in the CTimer class (TIMER.BAS and TIMER.CLS), which I mentioned in Chapter 7. The callback procedure must satisfy the very specific format shown below. The first part of this code simply kills the timer (we only want it to execute once). After that, it starts the real notification loop:</p>
<pre><code>Sub WaitForNotify(ByVal hWnd As Long, ByVal iMsg As Long, _<BR>                  ByVal idTimer As Long, ByVal cCount As Long)<BR>    ' Ignore all parameters except idTimer<BR>    <BR>    ' This one-time callback is used only to start the loop<BR>    KillTimer hNull, idTimer<BR>    BugMessage &quot;Killed Timer&quot;<BR><BR>    Dim iStatus As Long, f As Boolean<BR>    ' Keep waiting for file change events until no more objects<BR>    Do<BR>        '  Wait 100 milliseconds for notification<BR>        iStatus = WaitForMultipleObjects(Count, ahNotify(0), _<BR>                                         False, 100)<BR>        Select Case iStatus<BR>        Case WAIT_TIMEOUT<BR>            ' Nothing happened<BR>            BugMessage &quot;Waited for timeout&quot;<BR>            DoEvents<BR>        Case 0 To Count<BR>            BugMessage &quot;Got a notification&quot;<BR>            ' Ignore errors from client; that's their problem<BR>            On Error Resume Next<BR>            ' Call client object with information<BR>            With aconNotify(iStatus)<BR>                .notifier.Change .sDir, .efn, .fSubTree<BR>            End With<BR>            ' Wait for next notification<BR>            f = FindNextChangeNotification(ahNotify(iStatus))<BR>            BugAssert f<BR>        Case WAIT_FAILED<BR>            ' Indicates no notification requests<BR>            ' BugMessage &quot;No notification requests&quot;<BR>            DoEvents<BR>        Case Else<BR>            BugMessage &quot;Can't happen&quot;<BR>        End Select<BR>    ' Class Initialize and Terminate events keep reference count<BR>    Loop Until cObject = -1<BR>End Sub</code></pre>
<BR>
The WaitForMultipleObjects function waits for what Windows calls an object. A Win32 object can be a process, a thread, a mutex, an event, a semaphore, console input, or a change notification. I’m not even going to define these things, much less explain why or how you would want to wait on one. The point is that you must put the handles of those objects in a contiguous array and pass the number of objects, followed by the address of the first object. You must also indicate whether you want to wait until all objects have returned or wait only for the first one. In this case, you pass False to wait for the first file notification object. Finally you pass the timeout period, 100 milliseconds.</p>
<BR>
When I say that WaitForMultipleObjects waits, I mean that literally. As soon as the thread executing this Visual Basic server code hits WaitForMultipleObjects, it stops dead. The server is no longer running. All the other programs in the system get all the cycles, and you get nothing. That’s what you asked for. If you doubt it, change the timeout period to the constant INFINITE (–<font face="Symbol"><span style="font-family:symbol">&#49;</span></font>). The server locks tight, and absolutely nothing happens in it except responses to file events. The client keeps running and responding to file change notifications, but when the client tries to call the server’s Disconnect method, no one’s home. A timeout period is desperately needed in the WAIT_TIMEOUT case so that the server can get control and respond to other Connect and Disconnect requests.</p>
<BR>
When a file notification object does come through, WaitForMultipleObjects returns its index into the handle array. The <i>Case 0 to Count</i> block handles the notifications by using the stored client object to call the client’s FileChange event procedure. It must then call FindNextChangeNotification to wait for the next event. Incidentally, Count is simply a Property Get procedure that counts the handles in the array.</p>
</font></BODY>
</HTML>
