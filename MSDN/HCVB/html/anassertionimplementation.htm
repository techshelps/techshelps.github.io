<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>An Assertion Implementation</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>

<font face="verdana,arial,helvetica" size="2"><h1><a name="anassertionimplementation"></a>An Assertion Implementation</h1>
<BR>
Here’s one way to code an assertion procedure in Visual Basic:</p>
<pre><code>Sub BugAssert(ByVal fExpression As Boolean, _<BR>              Optional sExpression As String = sEmpty)<BR>#If afDebug Then<BR>    If fExpression Then Exit Sub<BR>    BugMessage “BugAssert failed: “ &amp; sExpression<BR>    Stop<BR>#End If<BR>End Sub</code></pre>
<BR>
This short assertion procedure packs in some interesting twists. First is the optional argument. The intention is to fill the argument with a string containing the same information you would get from the C compiler. You could fill in both arguments yourself when writing code, but normally you would just use the simple version at design time:</p>
<pre><code>BugAssert 2 + 2 = 5</code></pre>
<BR>
Later you use a text-processing program that scans through source code and automatically fills in the second argument:</p>
<pre><code>BugAssert 2 + 2 = 5, “2 + 2 = 5, file LIES.BAS, line 325”</code></pre>
<BR>
Visual Basic might not know the expression, file, and line, but it’s easy enough to write a program that does. Microsoft refers to programs that modify source code as <i>wizards, </i>and Visual Basic includes several of them. The Debug Wizard (BUGWIZ.EXE) shown in Figure 1-2 is the first of several wizards used in this book. For now, we’re interested only in the program; we’ll return to the code in Chapter 3.</p>
<BR>
The line number displayed in asserts was of limited use in previous versions <BR>of Visual Basic, but finally, in version 5, you can actually see a status display that tells what line and column the cursor is on. Unlike all the other program&shy;mer’s editors I’ve seen, the Visual Basic editor doesn’t have a Goto command to move to a specified line. But first things first. At least we get the current line displayed on the toolbar (even though it took five versions).</p>
<BR>
The next interesting thing about the code is the Exit Sub statement in the first unconditional line. For readability of structured code, I would normally use an If/End If block around the rest of the code rather than an Exit Sub. In this case, however, the important thing is not readability but that the Stop statement be the last executable statement of the procedure. This makes it more convenient to step back through the assertion procedure and come out in the calling procedure ready to debug.</p>
<BR><img src="f01te02.gif"></p><BR>
<b>Figure 1-2. The Debug Wizard.</b></p>
<BR>
Speaking of the Stop statement, this is a wonder that C compilers and preprocessors can’t match. It puts you in a perfect position to step into the code that caused the bug and fix it on the spot, assuming that you’re working in the IDE. Of course it doesn’t help if your program is an EXE or DLL, but in that case you just want to terminate with a message anyway. BugMessage will display the message, and then Stop will terminate.</p>
<BR>
You might wonder why I call the procedure BugAssert instead of Assert. I put all my debug procedures in the DEBUG.BAS module and start each name with <i>Bug</i>. Then I can easily search for all words that start with <i>Bug</i> and replace them with <i>‘ Bug</i>, thus commenting out all debug calls before I ship my program. Debug Wizard performs this operation automatically. (Incidentally, that’s another reason all my Bug routines are subs, not functions. You can’t comment out functions in expressions mechanically.)</p>
<BR>
You might also wonder why you can’t use conditional compilation to automatically comment out unnecessary code. Well, you can if you have a preprocessor that supports macros. In C, assert is a macro that, when debugging is on, converts the statement</p>
<pre><code>assert(2 + 2 == 5)</code></pre>
<BR>
to a statement roughly equivalent to this:</p>
<pre><code>if !(2 + 2 == 5)<BR>    printf(“Assertion failed: %s, file %s, line %d\n”, <BR>           “2 + 2 == 5”, “lies.c”, “6”);</code></pre>
<BR>
Conditional compilation is a familiar feature in many languages, but it might be new to Basic programmers (although old-timers might remember metacom&shy;mands from MS-DOS and Macintosh Basic compilers). Basic conditional statements (like their metacommand ancestors) give instructions to the compiler (or interpreter) about how to create the program. The results of the commands live on at run time, but the commands themselves are long gone.</p>
<BR>
Another way to think of this is that conditional compilation is an easy way of commenting out blocks of code. Let’s say you want to try out different destroy algorithms. In previous versions of Visual Basic (or perhaps using the Comment Block and Uncomment Block buttons on the Edit toolbar in this version), you might have written this:</p>
<pre><code>SafeSlowDestroy earth<BR>‘FastRiskyDestroy earth</code></pre>
<BR>
After running the safe, slow version a few times to ensure that it works, you would have commented out the first line and removed the comment from the second to test it. Of course, in reality, each block would probably have more than one line, and affected code might be scattered in several places. Changing these calls by hand is a major inconvenience with great potential for bugs. Conditional compilation makes it easy to switch back and forth:</p>
<pre><code>#Const fSafeSlow = 1<BR>#If fSafeSlow Then <BR>    SafeSlowDestroy earth<BR>#Else<BR>    FastRiskyDestroy earth<BR>#End If</code></pre>
<BR>
To try the fast, risky version, simply change the definition of the <i>fSafeSlow</i> <BR>constant to 0. Notice that the syntax for compile-time tests and constants is exactly the same as for run-time tests and constants except that the compile-time lines start with a pound sign (#). If you don’t define an <i>fSafeSlow </i>constant in this example, it is assumed to be 0. This default enables you to fake the C language #ifdef and #ifndef statements even though Visual Basic doesn’t directly support them.</p>
<BR>
<b>Conditional Compilation for Blockheads</b></p>
<BR>
In Visual Basic, there’s no relation or communication between compile-time and run-time statements. You can’t use a constant created with #Const in an If statement, and you can’t use a constant created with Const in an #If statement. Despite syntax similarities, compile-time Visual Basic and run-time Visual Basic are different languages handled by different language interpreters at different times.</p>
<BR>
If debugging is off, the preprocessor will produce a blank—absolutely no code. If you look back at BugAssert, you’ll see that if debugging is off, it will produce something—an empty procedure.</p>
<BR>
Imagine calling an empty procedure hundreds of times in the code you ship to customers. Imagine doing it in p-code. In native code, an empty procedure is just one instruction, but you still have all the code to evaluate the expression and push arguments onto the stack. An empty procedure might be comparatively cheap, but the motto of the defensive programmer is “When in doubt, assert.” Personally, I can’t follow this advice comfortably if I know that every assertion costs a call, a return, and many worthless bytes of code. I wrote Debug Wizard to eliminate all that code. I need to run it only occasionally during the life of a project.</p>
</font></BODY>
</HTML>
