<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Collection Methods and Properties</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>

<font face="verdana,arial,helvetica" size="2"><h1><a name="collectionmethodsproperties"></a>Collection Methods and Properties</h1>
<BR>
My biggest beef with list boxes is that although they look and act like collections, they’re not quite collections. For one thing, they’re zero-based instead of one-based. For another, they have the wrong property and method names—ListCount, List, AddItem, and RemoveItem instead of Count, Item, Add, and Remove. Furthermore, they don’t work with For Each.</p>
<BR>
You can curse the darkness or you can light a candle. I did both. The XListBox&shy;Plus control has one-based collection methods and properties. It looks and works like a collection.</p>
<BR>
The design of XListBoxPlus is more interesting than its code. This class tries to combine the best features of list boxes and collections, keeping in mind that list boxes can’t work quite the same way as collections work. The biggest difference is that list boxes have a selected item, and collections don’t. Other &shy;differences are simply limitations of list boxes—limitations that XListBoxPlus &shy;attempts to eliminate. Table 11-1 compares what you can do with a list box, a collection, and a sorted list box (represented by <i>lst</i>, <i>n</i>, and <i>srt</i>, respectively).</p>
<table>
<tr valign=top>
<td>
<b>Operation</b></td>
<td>
<b>ListBox</b></td>
<td>
<b>Collection</b></td>
<td>
<b>XListBoxPlus</b></td>
</tr>
<tr valign=top>
<td>
Get item 3</td>
<td>
s = lst.List(2)</td>
<td>
s = n.Item(3)</td>
<td>
s = srt.Item(3)</td>
</tr>
<tr valign=top>
<td>
Get &quot;Pig&quot; index</td>
<td>
Can’t do it</td>
<td>
Can’t do it</td>
<td>
i = srt(&quot;Pig&quot;)</td>
</tr>
<tr valign=top>
<td>
Select &quot;Pig&quot;</td>
<td>
lst.Text = &quot;Pig&quot;</td>
<td>
Undefined</td>
<td>
srt.Text = &quot;Pig&quot;</td>
</tr>
<tr valign=top>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
srt.Current = &quot;Pig&quot;</td>
</tr>
<tr valign=top>
<td>
Change item 3</td>
<td>
lst.List(2) = &quot;Dog&quot;</td>
<td>
Can’t do it</td>
<td>
srt.Item(3) = &quot;Dog&quot;</td>
</tr>
<tr valign=top>
<td>
Change &quot;Dog&quot;</td>
<td>
Can’t do it</td>
<td>
Can’t do it</td>
<td>
srt(&quot;Dog&quot;) = &quot;Cat&quot; </td>
</tr>
<tr valign=top>
<td>
Select item 3</td>
<td>
lst.ListIndex = 2</td>
<td>
Undefined</td>
<td>
srt.Current = 3</td>
</tr>
<tr valign=top>
<td>
Get index</td>
<td>
i = lst.ListIndex</td>
<td>
Can’t do it</td>
<td>
i = srt.Current</td>
</tr>
<tr valign=top>
<td>
Get selected</td>
<td>
s = lst.Text </td>
<td>
Undefined</td>
<td>
s = srt.Text</td>
</tr>
<tr valign=top>
<td>
Add &quot;Cat&quot;</td>
<td>
lst.AddItem &quot;Cat&quot;</td>
<td>
n.Add &quot;Cat&quot;</td>
<td>
srt.Add &quot;Cat&quot;</td>
</tr>
<tr valign=top>
<td>
Remove item 3</td>
<td>
lst.RemoveItem 2</td>
<td>
n.Remove 3</td>
<td>
srt.Remove 3</td>
</tr>
<tr valign=top>
<td>
Remove &quot;Pig&quot;</td>
<td>
Can’t do it</td>
<td>
n.Remove &quot;Pig&quot;</td>
<td>
srt.Remove &quot;Pig&quot;</td>
</tr>
<tr valign=top>
<td>
Iterate by item</td>
<td>
Can’t do it</td>
<td>
For Each v in n</td>
<td>
For Each v in srt</td>
</tr>
<tr valign=top>
<td>
Iterate by index</td>
<td>
For i = 0 To _</td>
<td>
For i = 1 To _</td>
<td>
For i = 1 To _</td>
</tr>
<tr valign=top>
<td>
      </td>
<td>
     lst.ListCount –1</td>
<td>
     n.Count</td>
<td>
     srt.Count</td>
</tr>
</table><BR>
<BR>
<b>Table 11-1. List box and collection operations.</b></p>
<BR>
Most of these operations are clear once you understand list boxes and collections, but a few bear further study. I programmed with list boxes for years before I understood two of their more useful, but obscure, features. I knew that the Text property was important for combo boxes, but I didn’t know it even existed for list boxes. I always wrote this redundant code to access the selected item:</p>
<pre><code>s = lst.List(lst.ListIndex)</code></pre>
<BR>
Every time I wrote it I cursed the authors of the ListBox control for requiring such an ugly syntax, and I took a little jab at them in the first edition of this book. Well, I like my crow with catsup. Here’s what you can do instead:</p>
<pre><code>s = lst.Text</code></pre>
<BR>
The Text property can also be used to look up an item. (Yum! Feathers and all.) You can select the <i>Crow </i>item with this syntax:</p>
<pre><code>lst.Text = &quot;Crow&quot;</code></pre>
<BR>
If there is no <i>Crow </i>item, you’ll deselect whatever is currently selected (ListIndex = –1). The lookup is case insensitive (<i>crow </i>finds <i>Crow</i>), but complete (<i>Cro </i>doesn’t find <i>Crow</i>).</p>
<BR>
This is cool, but the XListBoxPlus is even more so. You can index by number or by string value. It works kind of like collections, but</p>
<pre><code>i = n(&quot;Pig&quot;)</code></pre>
<BR>
and</p>
<pre><code>i = srt(&quot;Pig&quot;)</code></pre>
<BR>
don’t mean exactly the same thing. Indexed collections return objects, as explained later in this chapter in “Sorted Collections,” but sorted list boxes contain strings, not objects. Indexing has to mean something different.</p>
<BR>
I made the default Item property return a numeric index if you pass a string, or a string if you pass an index. Purists might object to a property returning different types for different arguments, but it works in this case.</p>
<BR>
Here are few other points for users of the XListBoxPlus class:
<ul>
<li>
Properties that are read-only at design time are the bane of the control delegator. I couldn’t figure out a way to delegate the cool new Check&shy;Box style, the MultiSelect property, or the IntegralHeight property.<BR><BR></li>
<li>
There’s no way to duplicate the neat little drop-down editing box that you get for the List and ItemData properties. XListBoxPlus uses a property page instead.<BR><BR></li>
<li>
In sorted mode, you can have only one copy of each item. I could have designed the class to allow duplicate entries, but that doesn’t make much sense for sorted items.<BR><BR></li>
<li>
When no item is selected, the Index property is 0 rather than –<font face="Symbol"><span style="font-family:symbol">&#49;</span></font>. This makes for easier conditional testing. You can also set Index to 0 to select nothing.<BR>
CHALLENGE&#09;I’d like to have a sorted version of the FileListBox control, but couldn’t create one by delegating because the original control doesn’t allow addition or removal of items. Technically, you don’t need to add or remove items to sort a list box, but you do need to exchange items, and that can’t be done with a FileListBox control because nothing can be assigned to List items. You could, however, design a class to make an internal list box look and act like a FileListBox control, except that it could be sorted by date, name, extension, or attributes. To do this, you would use the Dir function to reload the list box in the current sort order at appropriate times. I’ve always wanted a file list box like that, and the only reason I didn’t create one for this book is that I can do most of what I want with the ListView control. But the ListView has its problems, so you might want to use XListBoxPlus as a model for your own XFileListPlus control.</p>
</li>
</ul>
</font></BODY>
</HTML>
