<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Paths</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>

<font face="verdana,arial,helvetica" size="2"><h1><a name="paths"></a>Paths</h1>
<BR>
Paths are recorded sequences of deferred line drawing commands. The idea is that you can draw an irregular, invisible shape using various commands and then perform an operation on the whole shape at once. Let’s try it:</p>
<pre><code>‘ Start recording path<BR>BeginPath hDC<BR>’ Do some draw operations<BR>ForeColor = vbYellow<BR>FillColor = vbRed<BR>FillStyle = vbSolid<BR>Line (ScaleWidth * 0.2, ScaleHeight * 0.3)- _<BR>     (ScaleWidth * 0.8, ScaleHeight * 0.7)<BR>Circle (ScaleWidth * 0.5, ScaleHeight * 0.5), _<BR>        ScaleHeight * 0.3<BR>’ Stop recording path<BR>EndPath hDC<BR>’ Do something to finished path<BR>StrokeAndFillPath hDC<BR>’ Update device context<BR>Refresh</code></pre>
<BR>
If you step through this code, nothing happens when you step over the Line and Circle statements. The figures aren’t drawn until you reach the StrokeAnd&shy;FillPath procedure, and they usually won’t be visible until you call the Refresh method. Both figures are filled (except in the intersection) with the current FillColor and FillStyle, even though the Line statement doesn’t have the <i>F</i> argument that specifies filling.</p>
<BR>
We’re mixing Visual Basic statements and Windows API statements, but that’s OK because the Visual Basic statements are calling API functions under the surface. The Line statement probably calls Rectangle, Circle probably calls Ellipse, and they’re both working on the same device context that was passed to the path procedures. The API documentation has a long list of line drawing functions that you can use in paths, but the only Visual Basic statements that work are Line, Circle, and Print.</p>
<BR>
Print? Since when did Print get to be a line drawing statement? Well, since Windows got TrueType fonts. Try this:</p>
<pre><code>‘ Set a large, TrueType font<BR>With Font<BR>    .Name = “Lucida Console”<BR>    .Bold = True<BR>    .Italic = True<BR>    .Size = 48<BR>End With<BR>ForeColor = vbGreen<BR>FillColor = vbMagenta<BR>FillStyle = vbDiagonalCross<BR>’ Make Print statement into a path, and then fill<BR>BeginPath hDC<BR>Print “Hello”<BR>EndPath hDC<BR>StrokeAndFillPath hDC<BR>Refresh</code></pre>
<BR>
This code draws outlined green text filled with magenta cross-hatches. I was going to include a screen shot, but it was just too hideous.</p>
<BR>
Besides drawing and filling a path, you can also draw it (StrokePath), fill it (FillPath), and turn it into a region (PathToRegion). I don’t have much to say about regions, except that paths make them easier to manage. In fact, I’m not going to discuss path-related functions such as FlattenPath, WidenPath, Set&shy;MiterLimit, CloseFigure, or ExtCreatePen. You can explore these on your own.</p>
<BR>
You must set AutoRedraw to True to use paths. I also found that some path features behaved differently under Windows 95 than under Windows NT.</p>
</font></BODY>
</HTML>
