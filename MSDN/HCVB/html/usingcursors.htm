<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Using Cursors</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>

<font face="verdana,arial,helvetica" size="2"><h1><a name="usingcursors"></a>Using Cursors</h1>
<BR>
Early versions of Visual Basic lacked any means of assigning a custom mouse pointer, although this is a common technique in Windows-based programs. Many programmers who tried to get around this limitation turned to the Windows API, but even then solutions proved unexpectedly difficult.</p>
<BR>
Visual Basic now provides a simple and intuitive solution (see the sidebar “Cursors Eat Mouse Icons for Lunch,” page 442). But WinWatch can’t use the Visual Basic Way because it gets cursors from resources. If you check out the Windows API Help, the solution looks simple: just call SetCursor. When you try this, however, the new cursor flickers on and then disappears. Every time you move the cursor, Visual Basic’s original cursor is restored.</p>
<BR>
Here’s how WinWatch works around this limitation:</p>
<pre><code>Sub ShowCursor(ByVal hMod As Long, sCursor As String)<BR>    ‘ Get cursor handle<BR>    hResourceCur = LoadImage(hMod, sCursor, IMAGE_CURSOR, 0, 0, 0)<BR>    If hResourceCur &lt;&gt; hNull Then<BR>        ordPointerLast = MousePointer<BR>        MousePointer = vbCustom<BR>        MouseIcon = CursorToPicture(hResourceCur)<BR>        ordResourceLast = RT_CURSOR<BR>        Call DrawIconEx(pbResource.hDC, 0, 0, hResourceCur, _<BR>                        0, 0, 0, hNull, DI_NORMAL)<BR>    Else<BR>        pbResource.Print “Can’t display cursor: “ &amp; sCrLf &amp; sCrLf &amp; _<BR>                         WordWrap(ApiError(Err.LastDllError), 25)<BR>    End If<BR>End Sub</code></pre>
<BR>
It simply calls the CursorToPicture function and sets the resulting picture to the form’s MouseIcon property. That’s half the operation. You must also restore the cursor when you change resources. Here’s the part of the Select Case block in ClearResource that restores the previous cursor.</p>
<pre><code>Case RT_GROUP_CURSOR, RT_CURSOR<BR>    MousePointer = ordPointerLast</code></pre>
<BR>
You saw the BitmapToPicture function, and I told you that IconToPicture looked the same. You can probably guess what CursorToPicture looks like. But you guessed wrong:</p>
<pre><code>Function CursorToPicture(ByVal hIcon As Long) As IPicture<BR>    ‘ It’s just an alias<BR>    Set CursorToPicture = IconToPicture(hIcon)<BR>End Function</code></pre>
<BR>
The StdPicture class is notoriously ignorant about cursors. It accepts them but doesn’t distinguish them from icons. The MouseIcon property, however, knows the difference, and that’s all that matters.</p>
<BR>
ShowCursor also uses the DrawIconEx function (which also doesn’t distinguish between icons and cursors) to draw a static picture of the cursor. The Draw&shy;Cursors procedure uses code similar to that in ShowIcons to draw each of the cursors in a cursor group. Then it uses the same code as ShowCursor to load the one that best fits the current environment.</p>
</font></BODY>
</HTML>
