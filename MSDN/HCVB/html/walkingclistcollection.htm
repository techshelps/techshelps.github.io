<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Walking the CList collection</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>

<font face="verdana,arial,helvetica" size="2"><h1><a name="walkingclistcollection"></a>Walking the CList collection </h1>
<BR>
The CList collection class already has an iterator class, and it already attaches itself to that iterator. You got a sanitized preview of the Attach method on page 175. Here’s the real code:</p>
<pre><code>‘ Attach a list to iterator<BR>Sub Attach(connectA As CList, Optional fEnumerate As Boolean = False)<BR>    ‘ Initialize position in collection<BR>    Set connect = connectA<BR>    If fEnumerate Then<BR>        ‘ Connect walker to CEnumVariant so it can call methods<BR>        Set vars = New CEnumVariant<BR>        vars.Attach Me<BR>    End If<BR>End Sub</code></pre>
<BR>
If you create the iterator object yourself (as we did in earlier examples), it doesn’t need a connection with CEnumVariant and any implementation of the IVariant&shy;Walker interface should be ignored. The <i>fEnumerate</i> flag should be true only when Attach is called by the NewEnum method of CList.</p>
<BR>
But we do want CList to work with For Each, and since the iteration mechanism is already in place, it’s extremely easy for the IVariantWalker members to take advantage of the existing public More method through delegation. You might remember that the original CListWalker class had a More method that returned True or False to indicate whether there were more items. It returned the actual data through a separate Item property. Here’s how IVariantWalker_More takes advantage of those methods.</p>
<pre><code>Private Function IVariantWalker_More(v As Variant) As Boolean<BR>    ‘ Move to next element<BR>    IVariantWalker_More = More<BR>    If IVariantWalker_More = False Then Exit Function<BR>    ‘ Return element through reference<BR>    If IsObject(lnkCur.Item) Then<BR>        Set v = lnkCur.Item<BR>    Else<BR>        v = lnkCur.Item<BR>    End If<BR>End Function</code></pre>
<BR>
The implementation of Skip does something even more interesting. It delegates its work to IVariantWalker_More in a loop:</p>
<pre><code>Private Sub IVariantWalker_Skip(c As Long)<BR>    ‘ Skip a given number of elements<BR>    Dim i As Long, v As Variant<BR>    For i = 1 To c<BR>        If IVariantWalker_More(v) = False Then Exit For<BR>    Next<BR>End Sub</code></pre>
<BR>
<b>Problem:</b> Compare iterating through various data structures, and for each data structure, compare iterating with For Each to iterating with For and an index variable.</p>
<table>
<tr valign=top>
<td>
<b>Problem</b></td>
<td>
<b>P-Code</b></td>
<td>
<b>Native Code</b></td>
</tr>
<tr valign=top>
<td>
For I on Variant Integer array</td>
<td>
0.0005 sec</td>
<td>
0.0002 sec</td>
</tr>
<tr valign=top>
<td>
For Each on Variant Integer array</td>
<td>
0.0009 sec</td>
<td>
0.0006 sec</td>
</tr>
<tr valign=top>
<td>
For I on Integer array</td>
<td>
0.0004 sec</td>
<td>
0.0001 sec</td>
</tr>
<tr valign=top>
<td>
For Each on Integer array</td>
<td>
0.0008 sec</td>
<td>
0.0004 sec</td>
</tr>
<tr valign=top>
<td>
For I on Integer collection</td>
<td>
0.0125 sec</td>
<td>
0.0082 sec</td>
</tr>
<tr valign=top>
<td>
For Each on Integer collection</td>
<td>
0.0013 sec</td>
<td>
0.0011 sec</td>
</tr>
<tr valign=top>
<td>
For I on Variant Integer vector</td>
<td>
0.0038 sec</td>
<td>
0.0033 sec</td>
</tr>
<tr valign=top>
<td>
For Each on Variant Integer vector</td>
<td>
0.0231 sec</td>
<td>
0.0228 sec</td>
</tr>
<tr valign=top>
<td>
For I on Integer vector</td>
<td>
0.0017 sec</td>
<td>
0.0013 sec</td>
</tr>
<tr valign=top>
<td>
For Each on Integer vector</td>
<td>
0.0183 sec</td>
<td>
0.0196 sec</td>
</tr>
<tr valign=top>
<td>
For I on Integer list</td>
<td>
0.9113 sec</td>
<td>
0.8657 sec</td>
</tr>
<tr valign=top>
<td>
For Each on Integer list</td>
<td>
0.0184 sec</td>
<td>
0.0195 sec</td>
</tr>
<tr valign=top>
<td>
For I on Variant object array</td>
<td>
0.0570 sec</td>
<td>
0.0567 sec</td>
</tr>
<tr valign=top>
<td>
For Each on Variant object array</td>
<td>
0.0615 sec</td>
<td>
0.0607 sec</td>
</tr>
<tr valign=top>
<td>
For I on object array</td>
<td>
0.0008 sec</td>
<td>
0.0004 sec</td>
</tr>
<tr valign=top>
<td>
For Each on object array</td>
<td>
0.0597 sec</td>
<td>
0.0625 sec</td>
</tr>
<tr valign=top>
<td>
For I on object collection</td>
<td>
0.0834 sec</td>
<td>
0.0862 sec</td>
</tr>
</table><BR>
<BR>
You might want to keep this technique in mind. Usually, you can optimize the Skip method by changing the state variable, but in some kinds of collections (such as lists), the only way to get ahead is to keep iterating.</p>
<BR>
The original list iterator didn’t have the equivalent of a Reset method (you could restart with the Attach method), so IVariantWalker_Reset has to be implemented from scratch by resetting the Head friend property.</p>
<pre><code>Private Sub IVariantWalker_Reset()<BR>    ‘ Move to first element<BR>    If connect.Count Then Set lnkCur = connect.Head<BR>End Sub</code></pre>
<table>
<tr valign=top>
<td>
<b>Problem</b></td>
<td>
<b>P-Code</b></td>
<td>
<b>Native Code</b></td>
</tr>
<tr valign=top>
<td>
For Each on object collection</td>
<td>
0.0035 sec</td>
<td>
0.0036 sec</td>
</tr>
<tr valign=top>
<td>
For I on object vector</td>
<td>
0.0750 sec</td>
<td>
0.0745 sec</td>
</tr>
<tr valign=top>
<td>
For Each on object vector</td>
<td>
0.0258 sec</td>
<td>
0.0241 sec</td>
</tr>
<tr valign=top>
<td>
For I on object list</td>
<td>
0.9805 sec</td>
<td>
0.9887 sec</td>
</tr>
<tr valign=top>
<td>
For Each on object list</td>
<td>
0.0234 sec</td>
<td>
0.2240 sec</td>
</tr>
</table><BR>
<BR>
<b>Conclusion:</b> The results speak for themselves, but let me highlight a few points. I provide two array tests. One is a Variant array, because it’s only fair to compare Variant arrays to Variant collections, vectors, and lists. But if you’re doing real work with integers, you don’t care what’s fair—you just want speed. The difference between using Variant arrays and type-specific arrays is a minor one for Integers but a major one for objects.</p>
<BR>
Nothing beats an array for raw speed, but vectors do get decent performance. You can’t necessarily see it from the data here, but if you actually run the TimeIt application with different numbers in the Iterations field (iterations here is &shy;actually the number of items in the data structure), you’ll see that collections and lists get much slower as you add more data, while arrays and vectors slow at a constant rate. Lists are shown for comparison, but they come in last in every category and you probably don’t want to use them for this kind of operation.</p>
<BR>
When comparing For Each to For with an index variable, arrays and vectors are far faster with an index variable. Collections and lists are faster with For Each; if you study the implementation of the CVector and CList classes, you can get a good idea why. The internal iterators for Collections and arrays are probably implemented much like the ones for CList and CVector, respectively.</p>
<BR>
The iterator for the CList class is crucial to its performance. You don’t even want to think about iterating with indexes, because they depend on the iterator &shy;anyway. It might look from the outside as if you’re walking through one item at a time, but you’re actually using the internal iterator to walk all the way from the start of the list to the current index. The Performance sidebar above shows the heavy toll this takes.</p>
</font></BODY>
</HTML>
