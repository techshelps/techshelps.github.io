<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>The CdriveWalker class</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>

<font face="verdana,arial,helvetica" size="2"><h1><a name="thecdrivewalkerclass"></a>The CDriveWalker class</h1>
<BR>
You don’t have to go far to figure out that the CDriveWalker class is a little unusual. Take a look at the first few lines of code:</p>
<pre><code>‘ Implement Basic-friendly version of IEnumVARIANT<BR>Implements IVariantWalker<BR>‘ Delegate to class that implements real IEnumVARIANT<BR>Private vars As CEnumVariant<BR>‘ Connect back to parent collection<BR>Private connect As CDrives</code></pre>
<BR>
We’re going to implement a nice, friendly Basic-style interface (IVariantWalker) that does all the stuff the For Each syntax expects us to do. But because the real IEnumVARIANT is so Basic-hostile that we can’t afford to deal with its horrors every time we want to write a collection, we’ll delegate to a CEnumVariant <BR>ob&shy;ject, which will actually implement IEnumVARIANT. When your client code hits a For Each block, Visual Basic will think CEnumVariant is an IEnumVARIANT (if you implement it, you are it) and will call its methods. Those methods will, in turn, through a process too horrible to describe, call the IVariantWalker <BR>methods, which will iterate through the collection. Figure 4-4 on the following page tries to make sense of the whole iteration mess.</p>
<BR><img src="f04te04.gif"></p><BR>
<b>Figure 4-4. The whole iteration mess.</b></p>
<BR>
In real life, you can ignore most of the details; just implement IVariantWalker and delegate it to CEnumVariant. Here’s the internal data the CDriveWalker class uses to maintain its position and connections:</p>
<pre><code>‘ Private state data<BR>Private i As Long<BR><BR>Private Sub Class_Initialize()<BR>    ‘ Initialize position in collection<BR>    i = 1<BR>    ‘ Connect walker to CEnumVariant so it can call methods<BR>    Set vars = New CEnumVariant<BR>    vars.Attach Me<BR>End Sub</code></pre>
<BR>
CDriveWalker also needs methods and properties to receive a connection from the CDrives collection and to pass a connection back from the CEnumVariant object (<i>vars</i>) to the CDrives collection (which will pass it back to the client program).</p>
<pre><code>‘ Receive connection from CDrives<BR>Sub Attach(connectA As CDrives)<BR>    Set connect = connectA<BR>End Sub<BR><BR>‘ Return IEnumVARIANT (indirectly) to client collection<BR>Friend Property Get NewEnum() As IEnumVARIANT<BR>    Set NewEnum = vars<BR>End Property</code></pre>
<BR>
Finally, with all this paperwork out of the way, you can actually write the code to move to the next item, skip some items, and reset the iteration.</p>
<pre><code>Private Function IVariantWalker_More(v As Variant) As Boolean<BR>    ‘ Find the next drive and return it through reference<BR>    Do While i &lt;= 26<BR>        ‘ Check flags to see if next drive exists<BR>        If MBytes.RShiftDWord(connect.DriveFlags, i - 1) And 1 Then<BR>            Dim drive As CDrive<BR>            Set drive = New CDrive<BR>            drive.Root = i<BR>            Set v = drive<BR>            IVariantWalker_More = True<BR>            i = i + 1<BR>            Exit Function<BR>        End If<BR>        i = i + 1<BR>    Loop<BR>End Function<BR><BR>Private Sub IVariantWalker_Skip(c As Long)<BR>    ‘ Skip ahead in the iteration<BR>    i = i + c<BR>End Sub<BR><BR>Private Sub IVariantWalker_Reset()<BR>    ‘ Reset the iteration<BR>    i = 1<BR>End Sub</code></pre>
<BR>
The More method (which would be named Next if Visual Basic allowed it) is the most important method and the only one called by For Each. Notice how it returns a Boolean indicating whether there are more items and also returns the next item through a reference parameter.</p>
<BR>
The Skip and Reset methods are not called by For Each, but they are called by the Locals window in the IDE. If it looks like a miracle that Visual Basic can display all the items in a collection before you’ve even iterated through them, well, it’s not—although it is remarkable. The Locals window is iterating, skipping, and resetting behind the scenes to display the parts of the collection you request. If you have enough patience and memory, you can verify that the Locals &shy;window actually has limits—it won’t display more than 256 items in a collection.</p>
<BR>
If all this sounds complicated, you ain’t seen nothin’ yet. And you don’t need to see nothin’. The Collection Wizard can write all the repetitive hack code, leaving you to worry only about how your collection works. We’ll take a look in a few pages.</p>
</font></BODY>
</HTML>
