<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CVector Implementation</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>

<font face="verdana,arial,helvetica" size="2"><h1><a name="cvectorimplementation"></a>CVector Implementation</h1>
<BR>
The CVector class is essentially a wrapper around an array. Here’s the internal data that makes it work:</p>
<pre><code>Private av() As Variant<BR>Private iLast As Long<BR>Private cChunk As Long<BR><BR>Private Sub Class_Initialize()<BR>    cChunk = 10     ‘ Default size can be overridden<BR>    ReDim Preserve av(1 To cChunk) As Variant<BR>    iLast = 1<BR>End Sub</code></pre>
<BR>
Most of the implementation is in the Item property. Because CVector is a variant container class and because you don’t know whether the variants in the internal array will be objects or variables, you must implement all three property procedures—Get, Let, and Set. Here’s the code:</p>
<pre><code>‘ Item is the default property<BR>Property Get Item(ByVal i As Long) As Variant<BR>    BugAssert i &gt; 0<BR>    ‘ If index is out-of-range, return default (Empty)<BR>    On Error Resume Next<BR>    If IsObject(av(i)) Then<BR>        Set Item = av(i)<BR>    Else<BR>        Item = av(i)<BR>    End If<BR>End Property<BR><BR>Property Let Item(ByVal i As Long, ByVal vItemA As Variant)<BR>    BugAssert i &gt; 0<BR>    On Error GoTo FailLetItem<BR>    av(i) = vItemA<BR>    If i &gt; iLast Then iLast = i<BR>    Exit Property<BR>FailLetItem:<BR>    If i &gt; UBound(av) Then<BR>        ReDim Preserve av(1 To i + cChunk) As Variant<BR>        Resume      ‘ Try again<BR>    End If<BR>    ErrRaise Err.Number     ‘ Other VB error for client<BR>End Property<BR><BR>Property Set Item(ByVal i As Long, ByVal vItemA As Variant)<BR>    BugAssert i &gt; 0<BR>    On Error GoTo FailSetItem<BR>    Set av(i) = vItemA<BR>    If i &gt; iLast Then iLast = i<BR>    Exit Property<BR>FailSetItem:<BR>    If i &gt; UBound(av) Then<BR>        ReDim Preserve av(1 To i + cChunk) As Variant<BR>        Resume      ‘ Try again<BR>    End If<BR>    ErrRaise Err.Number     ‘ Other VB error for client</code></pre>
<BR>
As I stated earlier, CVector is the <i>av </i>Variant array in a thin class wrapper. The Item property accesses elements of the array, but because it is marked as the default property, clients don’t have to give the Item method name. Access to the indexed Item property looks like access to an array. The sidebar on page 184 gives more details on how property procedures can be used to simulate array indexes.</p>
<BR>
The main complication in the Property Get is that you have to check to see whether the variant being accessed is a variable or an object so that you can use Set to assign objects. My implementation turns off error checking and lets invalid data requests return Empty. I could have chosen to raise an out-of-range error, and that might be more appropriate in vectors of integers or other types that don’t have an equivalent of Empty.</p>
<BR>
The Let and Set property procedures use error trapping to identify when you try to insert beyond the end of the array. The array is then resized. The size of the <i>cChunk </i>variable determines the efficiency of the vector. A larger chunk size means faster element writes because the expensive redimensioning is less &shy;fre&shy;-quent, but it also means more wasted data space.</p>
<BR>
The CVector class has a couple of other properties. The Chunk property just gets or (more likely) sets the size of the data chunks. The default size (10) is a good compromise for most vectors, but you can fine-tune it if you like. The Last property returns or sets the last element in the array:</p>
<pre><code>Property Get Last() As Long<BR>    Last = iLast<BR>End Property<BR>Property Let Last(iLastA As Long)<BR>    BugAssert iLastA &gt; 0<BR>    ReDim Preserve av(1 To iLastA) As Variant<BR>    iLast = iLastA<BR>End Property</code></pre>
<BR>
Notice that setting Last specifically resizes the array. Usually it is used to shrink a vector when you know you’ll no longer need data beyond a certain point. You can also use it to expand an array specifically rather than automatically.</p>
<BR>
What’s the cost? Well, in the Item Property Get, you pay for accessing the array through a procedure call rather than inline code. You also pay for checking to see if the entry is an object, but that’s not really the vector’s fault; you’d have to do the same thing with an array of variants. In the Item Property Let and Property Set, you also pay for the procedure call. In addition, there’s an extra expense for an error trap, even when you don’t hit it. And when you do hit the error trap, you pay an even bigger penalty for resizing the array.</p>
<BR>
What does this add up to? It depends on what you’re comparing it to. Check the Performance sidebar on page 191. You could get the same benefits at less cost by hard-coding similar error traps into each program that needs an expandable array. But since CVector exists as compiled native code in the VBCore DLL, the cost usually isn’t worth worrying about.</p>
<BR>
If you want even greater efficiency, use the typed versions in VBCore. I started with the general CVector class for variants, and then I did a Save As to create the CVectorInt class. Next I did a global search and replace to change Variant to Integer, and then I cut out the variant-specific features. From there it was easy to create CVectorInt, CVectorLng, CVectorBool, CVectorStr, CVectorSng, and CVectorDbl.</p>
<BR>
Of these, the most interesting is CVectorBool. A Visual Basic Boolean is a 16-bit value (the same as an Integer). This is kind of a strange choice, but don’t blame Visual Basic; COM Automation defines the size. Many languages make Boolean types 8-bit to save data space in arrays. Windows makes its BOOL type the system integer size (Long in 32-bit) for greater efficiency. But all it really takes to store a Boolean is one bit. That’s how many bits CVectorBool uses for each element. It actually stores its elements as Longs and crams 32 Boolean values into each of them, using logical operators to insert and extract the bits. All this happens behind the scenes. The Item property returns the bits as Boolean, just as you would expect. The CVectorBool class is 16 times more data efficient than an array of Booleans, and the performance cost for this savings is small. Check it out in VECTORBOOL.CLS.</p>
<BR>
<b>Property Arrays</b></p>
<BR>
Visual Basic is the only language I know that uses parentheses for array subscripts. (Most languages use square brackets.) This practice leads to ambiguity in the language. Does</p>
<pre><code>i = Zap(4)</code></pre>
<BR>
assign element 4 of the <i>Zap</i> array to <i>i</i>, or does it call the Zap function with argument 4 and assign the result to <i>i</i>? I used to think this was a flaw in the &shy;language, but it’s handy when you create properties that look and act like arrays.</p>
<BR>
For example, assume that you are creating a CParanoia class,<i> </i>whose objects have an EnemyList property. You want to use it as follows:</p>
<pre><code>scared.EnemyList(i) = “Jones”<BR>Calumniate scared.EnemyList(i)</code></pre>
<BR>
EnemyList looks like an array and acts like an array, but you must implement <BR>it as a property, and properties can’t be arrays. You might expect that if you <BR>declare a public array in a form or a class, it would become a property array:</p>
<pre><code>Public EnemyList(1 To 10) As String</code></pre>
<BR>
Visual Basic throws this statement out at compile time with a message telling you that arrays can’t be public. You can usually create more reliable properties with Property Get and Property Let anyway, but it’s not immediately clear how to do this. The answer is that you fake subscripts with property parameters.</p>
<BR>
Behind your properties, you must have a private array or a collection. Let’s use an array here:</p>
<BR>
You can have lots of fun enhancing my CVector class. Start with multiple dimensions. How about a CMatrix class? Maybe you could write some functions that do math on vectors or matrices. FORTRAN can do addition, subtraction, multiplication, division, and even exponentiation on arrays. Why can’t Visual Basic? You can also do comparisons and logical operations. Without operator overloading, Visual Basic might not be able to make array expressions as natural as they are in some languages, but with care, you can probably come up with a fairly clean syntax. With native code, the operations themselves can be as fast in Visual Basic as they are in other languages.</p>
<pre><code>Private asEnemies(1 To 10) As String</code></pre>
<BR>
Property Get procedures normally don’t have parameters, but when faking subscripts, you need one argument for every array dimension. Since you’re faking a one-dimensional array, you need only one argument:</p>
<pre><code>Property Get EnemyList(i As Integer) As String<BR>    If i &gt;= 1 And i &lt;= 10 Then EnemyList = asEnemies(i)<BR>End Property</code></pre>
<BR>
Normally, Property Let procedures have one argument, but you’ll need an extra argument for each array dimension. The assignment parameter must be the last parameter:</p>
<pre><code>Property Let EnemyList(i As Integer, sEnemyA As String)<BR>    If i &gt;= 1 And i &lt;= 10 Then asEnemies(i) = sEnemyA<BR>End Property</code></pre>
<BR>
Expanding on this technique, you can easily design properties that represent multidimensional arrays:</p>
<pre><code>iHiCard = deck.Cards(iClubs, iJack)</code></pre>
<BR>
You can even have array properties with string or real number indexes:</p>
<pre><code>iHiCard = deck.Cards(“Clubs”, “Jack”) <BR>Print patient.Temperature(98.6)</code></pre>
<BR>
Obviously, this syntax would be impossible with real arrays. You decide how your parameters relate to the data hidden in your class.</p>
</font></BODY>
</HTML>
