<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>The process list-Windows NT view</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>

<font face="verdana,arial,helvetica" size="2"><h1><a name="theprocesslistwindowsntview"></a>The process list—Windows NT view</h1>
<BR>
When CreateProcessList is called under Windows NT, it calls the EnumProcesses function to get a list of all the processes in the system. PSAPI.DLL provides EnumProcesses and a variety of other functions for iterating through modules, threads, and more esoteric system data. This DLL isn’t part of Windows NT, but it is a standard, redistributable tool provided with the Win32 Software Development Kit. It is also provided on the CD of this book. The DLL works by reading the Windows NT performance database, which is part of the registry. With <BR>previous versions of Windows NT, programmers had to read the performance data out of the registry directly. It’s a very quirky operation that I wouldn’t have attempted in Visual Basic. Enumerating processes with PSAPI.DLL is more <BR>complicated than calling the ToolHelp32 functions, but it’s a lot easier than reading the weird registry format of the performance database.</p>
<BR>
Here’s the Windows NT half of CreateProcessList:</p>
<pre><code>Else<BR>        ' Windows NT uses PSAPI functions<BR>        Dim i As Long, iCur As Long, cRequest As Long, cGot As Long<BR>        Dim aProcesses() As Long, hProcess As Long, hModule As Long<BR>        cRequest = 96       ' Request in bytes for 24 processes<BR>        Do<BR>            ReDim aProcesses(0 To (cRequest / 4) - 1) As Long<BR>            f = EnumProcesses(aProcesses(0), cRequest, cGot)<BR>            If f = 0 Then Exit Function<BR>            If cGot &lt; cRequest Then Exit Do<BR>            cRequest = cRequest * 2<BR>        Loop<BR>        cGot = cGot / 4     ' From bytes to processes<BR>        ReDim Preserve aProcesses(0 To cGot - 1) As Long<BR><BR>        For i = 0 To cGot - 1<BR>            hProcess = OpenProcess(PROCESS_QUERY_INFORMATION Or _<BR>                                   PROCESS_VM_READ, 0, _<BR>                                   aProcesses(i))<BR>            ' Ignore processes that fail (probably no<BR>            ' security rights)<BR>            If hProcess = 0 Then GoTo NextFor<BR>            ' Get first module only<BR>            f = EnumProcessModules(hProcess, hModule, 4, c)<BR>            If f = 0 Then GoTo NextFor<BR>            sName = String$(cMaxPath, 0)<BR>            c = GetModuleFileNameEx(hProcess, hModule, sName, cMaxPath)<BR>            ' Put this process in vector and count it<BR>            Set process = New CProcess<BR>            process.Create aProcesses(i), Left$(sName, c)<BR>            iCur = iCur + 1<BR>            Set vec(iCur) = process<BR>NextFor:<BR>        Next<BR>    End If<BR>    Set CreateProcessList = vec<BR>End Function</code></pre>
<BR>
This code starts off by reading the process IDs for all the processes into an array. This is equivalent to calling CreateToolhelp32Snapshot under Windows 95. Unfortunately, there’s no way to determine the appropriate size of the array except trial and error. I made my initial guess large enough to handle all my processes with one pass through the loop, but you might keep your system even busier than mine.</p>
<BR>
Once you’ve got process IDs, the next step is to convert them into handles with OpenProcess. This is a normal Win32 function supported by both versions of Windows. It’s in the Windows API type library, so there’s no need for a Declare statement. We’ll see OpenProcess again in Chapter 11. Once you have a process handle, use it to get a module handle with EnumProcessModules—the function used later to build a module list. In this case, we need only the first module, which in Windows NT is always the main process module.</p>
<p>
With the process and module in hand, it’s time to get the module name with Get&shy;ModuleFileNameEx. You might remember GetModuleFileName from 16-bit Windows. It still exists in 32-bit windows, but unlike the 16-bit version, it requires a real module handle rather than an instance handle, and even then it fails for all processes other than the current one. GetModuleFileNameEx works for any process, but it requires both the process and the module handle.</p>
<p>
FLAME&#09;The loop in CreateProcessList is a perfect illustration of why Basic programmers need the Continue statement enjoyed by C, C++, and Java programmers. Structured programming fanatics will object to my use of GoTo to skip to the next iteration when a process is discovered to be inaccessible, but two additional levels of nesting would be even more unstructured in my view.</p>
<BR>
The CreateProcessList function is complicated so that the RefreshProcessList procedure of WinWatch can be simple:</p>
<pre><code>Private Sub RefreshProcessList()<BR>    Dim processes As CVector, process As CProcess, i As Long<BR>    Set processes = CreateProcessList<BR>    SetRedraw lstProcess, False<BR>    lstProcess.Clear<BR>    For i = 1 To processes.Last<BR>        lstProcess.AddItem processes(i).EXEName<BR>        lstProcess.ItemData(lstProcess.NewIndex) = processes(i).id<BR>    Next<BR>    SetRedraw lstProcess, True<BR>End Sub</code></pre>
</font></BODY>
</HTML>
