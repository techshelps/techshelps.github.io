<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>The XPictureGlass Control</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>

<font face="verdana,arial,helvetica" size="2"><h1><a name="thexpictureglasscontrol"></a>The XPictureGlass Control</h1>
<BR>
If you were confused by the code for the CPictureGlass class, you’ll like the control version. It requires only four lines of code. Of course, any control requires a lot more than four lines of code, but I’m counting only the ones you have to write yourself. The ActiveX Control Interface Wizard generated the rest.</p>
<BR>
Although controls are a major feature of Visual Basic version 5, this is the first I’ve had to say about creating them. I’ll have more to say about controls in Chapter 9, but I won’t be doing much hand-holding. The documentation on creating controls is good, and I assume you’ll use it. I’ll only get into a few quirks related to specific tasks I want to accomplish. So here’s a brief outline of how I created XPictureGlass.
<ol>
<li>
Asked the ActiveX Control Interface Wizard to generate a control that had the same properties, methods, and events as a PictureBox. I didn’t delegate to an internal PictureBox; I emulated a new one. I instructed the wizard to delegate all the emulated members to the UserControl. Had I stopped there, I would have had essentially a PictureBox control. If you assign a picture to the Picture property, it appears on the surface of the UserControl just as it would on a normal PictureBox.<BR><BR></li>
<li>
Gave the control a MaskColor property (but not a MaskPicture <BR>property).<BR><BR></li>
<li>
Changed the BackStyle property of the UserControl to Transparent (0) at design time. <BR><BR></li>
<li>
Did a few minor fixups that the wizard can’t handle such as changing color properties to type OLE_COLOR and using standard enums for properties that need drop-down enumerations. These tasks are documented in manuals and in the wizard’s summary report (CTLWIZ.TXT).<BR><BR></li>
<li>
Added the following lines of code:</li>
</ol>
<pre><code>Public Property Set Picture(ByVal New_Picture As Picture)<BR>    Set UserControl.Picture = New_Picture<BR>    ‘ Begin new code<BR>    Set UserControl.MaskPicture = New_Picture<BR>    If Not New_Picture Is Nothing Then<BR>        UserControl.Width = New_Picture.Width<BR>        UserControl.Height = New_Picture.Height<BR>    End If<BR>    ‘ End new code<BR>    PropertyChanged “Picture”<BR>End Property</code></pre>
<BR>
That’s it.</p>
<BR>
So why did I go through all that rigamarole with CPictureGlass? Well, XPic&shy;tureGlass exists at a much higher level than CPictureGlass. The developers of Visual Basic gave UserControl the MaskColor and MaskPicture properties at the last minute (they’re documented in the README). You set the MaskColor that you want masked out and the MaskPicture to the picture you want to mask. In this case, the Picture property and the MaskPicture property get the same value. Then behind the scenes—with some sort of magic not entirely different than what you saw in CPictureGlass—they make a mask from the MaskPicture and MaskColor and blit it onto the UserControl surface.</p>
<BR>
But they do a lot more…. For example, they do events. If you click on a transparent pixel of the control (one that has the MaskColor), you don’t get a mouse click event. If you click on an opaque bit, you do. In order to make transparency so easy, the Visual Basic designers had to make high-level decisions about how to work with AutoRedraw and ClipControls properties on the container. The decisions they made will probably work better for you than they did for the Fun ’n Games program.</p>
<BR>
When you animate the picture, it saves and restores the background, whatever it is. When you animate the control, it respects controls on the form but wipes out anything it interacts with on the form background. The control is designed to be transparent on the bitmap surface that you saved for the form when you set AutoRedraw to True. Furthermore, it doesn’t understand the trick (see “Style bits,” page 310) used to turn off ClipControls at run time. A partial solution is to set AutoRedraw to True and call the control’s Refresh method in the form’s Paint event. The problem with that is that none of the other fun effects works as well with AutoRedraw set to True. Never mind. Fun ’n Games is just a demo, and, as noted earlier, real programs will need a more sophisticated painting strategy.</p>
</font></BODY>
</HTML>
