<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Using Sounds</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>

<font face="verdana,arial,helvetica" size="2"><h1><a name="usingsounds"></a>Using Sounds</h1>
<BR>
WinWatch is just a demo, and showing a hex dump of unknown data formats is good enough. But you’ll have to do better than that in real life. WinWatch does know about one nonstandard resource: sounds in the WAVE format.</p>
<BR>
Nonstandard formats can be a problem unless everyone who uses the format agrees on the type name. Someone might put a wave file in a program as an RCDATA resource type. If that someone was you, you’d know what to do. But to WinWatch, it’s just data. You could turn the data into a string and search the string for some identifying data instead of producing a hex dump. A hex dump of wave data, for example, looks like this:</p>
<pre><code>52 49 46 46 B2 87 00 00  RIFF....<BR>57 41 56 45 66 6D 74 20  WAVEfmt</code></pre>
<BR>
WinWatch could test data blocks to see whether they contain such recognizable formats, but that’s up to you. My version recognizes only wave data that has the type name WAVE. This works for TRES. If you see a resource with type WAVE in another program, there’s a good chance you’ll be able to play it, although you have no guarantee that a particular wave resource won’t contain waves for a surfing program.</p>
<BR>
Assuming that you do have a wave sound resource, here’s the code to play it:</p>
<pre><code>Sub PlayWave(ByVal hMod As Long, sWave As String)<BR>    ‘ Convert wave resource to memory<BR>    Dim hWave As Long, hmemWave As Long, pWave As Long<BR>    hWave = FindResourceStrStr(hMod, sWave, “WAVE”)<BR>    hmemWave = LoadResource(hMod, hWave)<BR>    pWave = LockResource(hmemWave)<BR>    Call FreeResource(hmemWave)<BR>    ‘ Play it<BR>    If sndPlaySoundAsLp(pWave, SND_MEMORY Or SND_NODEFAULT) Then<BR>        pbResource.Print “Sound played”<BR>    Else<BR>        pbResource.Print “Can’t play sound: “ &amp; sCrLf &amp; sCrLf &amp; _<BR>                         WordWrap(ApiError(Err.LastDllError), 25)<BR>    End If<BR>End Sub</code></pre>
<BR>
If this isn’t clear, you might refer to “The Zen of Windows Memory Management” on pages 454–455. The sndPlaySoundAsLp function is a type-safe alias to the multimedia sndPlaySound function. The Windows API type library provides two other aliases. You can use the raw version to play sound files or system alerts. For example, use this statement to play a wave file:</p>
<pre><code>f = sndPlaySound(“c:\windows\wave\helpme.wav”, SND_SYNC)</code></pre>
<BR>
Use this statement to play the sound associated with SystemExclamation in <BR>the registry:</p>
<pre><code>f = sndPlaySound(“SystemExclamation”, SND_SYNC)</code></pre>
<BR>
When you load a sound with LoadResData, you get back an array of bytes. The Test Resources program uses the sndPlaySoundAsBytes alias to play a wave string. It’s wrapped in the following function in UTILITY.BAS.</p>
<pre><code>Function PlayWave(ab() As Byte, Optional Flags As Long = _<BR>                                SND_MEMORY Or SND_SYNC) As Boolean<BR>    PlayWave = sndPlaySoundAsBytes(ab(0), Flags)<BR>End Function</code></pre>
<BR>
You can play sounds with the Multimedia MCI control, which is appropriate in the context of other multimedia features, but it’s overkill if you’re simply playing sounds. Adding a control takes up a good chunk of memory resources, whereas using the sndPlaySound function takes up very little.</p>
<BR>
A bit of advice: if you’re tempted to start putting sound resources in your programs left and right, think again. Ask the guy across the hall from me how much he enjoyed those amusing sounds in the Test Resources program the 500th time he heard them during my debugging phase. He’ll suggest that you use the sounds associated with existing events in the registry. You can find the standard events in the \HKEY_CURRENT_USER\AppEvents\EventLabels key. The sounds associated with the events are in \HKEY_CURRENT_USER\AppEvents\Schemes&shy;\Apps. By using the registry, you give users the opportunity to override your choice of sounds (or perhaps remove them) with the Sounds applet in the Control Panel. I’ll examine the registry in more detail in Chapter 10, but this should give you some idea of how to let users have the final say about potentially annoying noises.</p>
</font></BODY>
</HTML>
