<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Variant Iterators</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>

<font face="verdana,arial,helvetica" size="2"><h1><a name="variantiterators"></a>Variant Iterators</h1>
<BR>
Before I get into the details, I want to connect the For Each syntax with the concept of iterators introduced in “Using A List Iterator Class,” page 172. You’ll remember that CList had a CListWalker class that could iterate through the items in a list. To prove it worked, I demonstrated a nested loop. (See page 173.) The outer loop created an iterator object and used it to walk through the list, but in the middle of the walk, the outer iterator suspended operation and created an inner iterator object. When the inner iterator finished walking, it returned control to the outer iterator, which remembered its position and kept walking. The outer and inner iterators were separate objects, each with its own state variables.</p>
<BR>
The For Each syntax works the same way. If you’re like me, you might program for several years without ever using a nested For Each loop on the same &shy;collection. But they do work, as this example illustrates:</p>
<pre><code>s = s &amp; sCrLf &amp; “Nested iteration loops with For Each: “ &amp; sCrLf<BR>Dim vAnimal2 As Variant<BR>For Each vAnimal In animals<BR>    s = s &amp; Space$(4) &amp; vAnimal &amp; sCrLf<BR>    If vAnimal = “Lion” Then<BR>        For Each vAnimal2 In animals<BR>            s = s &amp; Space$(8) &amp; vAnimal2 &amp; sCrLf<BR>        Next<BR>    End If<BR>Next</code></pre>
<BR>
The output looks like this:</p>
<pre><code>Shrew<BR>Wolverine<BR>Lion<BR>    Shrew<BR>    Wolverine<BR>    Lion<BR>    Tiger<BR>    Bear<BR>Tiger<BR>Bear</code></pre>
<BR>
Here’s how it works. Each time your code hits a For Each block, Visual Basic creates a new iterator object. The iterator object’s class must implement the IEnumVARIANT interface, and Visual Basic knows that such an object will have a Next method (like the More method of CListWalker). So each time through the loop, Visual Basic calls the Next method and uses the result as the current variant entry.</p>
<BR>
To enumerate variants, we’ll have to implement IEnumVARIANT in an iterator class. Our collection class will have to create iterator objects of type IEnum&shy;VARIANT. The collection object will have to somehow let Visual Basic know about these iterator objects. Unfortunately, we can’t do any of this stuff directly.</p>
</font></BODY>
</HTML>
