<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Implementing a Stack</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>

<font face="verdana,arial,helvetica" size="2"><h1><a name="implementingstack"></a>Implementing a Stack</h1>
<BR>
The easiest way to implement a stack is to use an internal Collection. You &shy;simply add new members to the end of the Collection in the Push method and take them off the end in the Pop method:</p>
<pre><code>‘ CStackCol implements IStack<BR>Implements IStack<BR>Private stack As Collection<BR><BR>Private Sub Class_Initialize()<BR>    Set stack = New Collection<BR>End Sub<BR><BR>Private Sub IStack_Push(vArg As Variant)<BR>    stack.Add vArg<BR>End Sub<BR><BR>Private Function IStack_Pop() As Variant<BR>    If stack.Count Then<BR>        If IsObject(stack(stack.Count)) Then<BR>            Set IStack_Pop = stack(stack.Count)<BR>        Else<BR>            IStack_Pop = stack(stack.Count)<BR>        End If<BR>        stack.Remove stack.Count<BR>    End If<BR>End Function<BR><BR>Private Property Get IStack_Count() As Long<BR>    IStack_Count = stack.Count<BR>End Property</code></pre>
<BR>
The Collection version is easy to implement, and its performance isn’t bad—for a small stack. The problem with the Collection-based stack is that it slows way down if you push too many things onto it. This isn’t really surprising. Implementing IStack with a Collection is like shooting ducks with a grenade launcher.</p>
<BR>
A linked list might be more appropriate. I won’t show the implementation because it looks a lot like a simplified version of the CList code you’ve already seen. Check it out for yourself in STACKLST.CLS.</p>
<BR>
The list version is a little slow for small stacks, but its speed is constant. In fact, it turns out to be a lot faster than the Collection version for large stacks. Also, it doesn’t waste data space like this vector version:</p>
<pre><code>Private av() As Variant<BR>Private Const cChunk = 10<BR>Private iLast As Long, iCur As Long
Private Sub IStack_Push(vArg As Variant)<BR>    iCur = iCur + 1<BR>    On Error GoTo FailPush<BR>    If IsObject(vArg) Then<BR>        Set av(iCur) = vArg<BR>    Else<BR>        av(iCur) = vArg<BR>    End If<BR>    Exit Sub<BR>FailPush:<BR>    iLast = iLast + cChunk  ‘ Grow<BR>    ReDim Preserve av(1 To iLast) As Variant<BR>    Resume                  ‘ Try again<BR>End Sub<BR><BR>Private Function IStack_Pop() As Variant<BR>    If iCur Then<BR>        If IsObject(av(iCur)) Then<BR>            Set IStack_Pop = av(iCur)<BR>        Else<BR>            IStack_Pop = av(iCur)<BR>        End If<BR>        iCur = iCur - 1<BR>        If iCur &lt; (iLast - cChunk) Then<BR>            iLast = iLast - cChunk      ‘ Shrink<BR>            ReDim Preserve av(1 To iLast) As Variant<BR>        End If<BR>    End If<BR>End Function<BR><BR>Private Property Get IStack_Count() As Long<BR>    IStack_Count = iCur<BR>End Property</code></pre>
<p>
The vector version is the most complicated and has the most lines of code, but don’t let that fool you. It’s far and away the fastest, as the Performance sidebar on the facing page shows. It does waste a little data space, but you can adjust that by changing the <i>cChunk </i>constant. In fact, if you set <i>cChunk </i>to 1, you won’t waste any data space and you’ll still be faster than the other versions—even though you’ll be resizing the array for every push and pop.</p>
<p>
<b>Problem:</b> Compare the speed of stacks based on Collections, linked lists, and vectors.<table>
<tr valign=top>
<td>
<b>Problem</b></td>
<td>
<b>P-Code</b></td>
<td>
<b>Native Code</b></td>
</tr>
<tr valign=top>
<td>
Use Collection stack of 500 numbers</td>
<td>
0.1161 sec</td>
<td>
0.0853 sec</td>
</tr>
<tr valign=top>
<td>
Use Collection stack of 5000 numbers</td>
<td>
10.0181 sec</td>
<td>
9.3406 sec</td>
</tr>
<tr valign=top>
<td>
Use linked list stack of 500 numbers</td>
<td>
0.1357 sec</td>
<td>
0.0972 sec</td>
</tr>
<tr valign=top>
<td>
Use linked list stack of 5000 numbers</td>
<td>
1.3360 sec</td>
<td>
1.0265 sec</td>
</tr>
<tr valign=top>
<td>
Use vector stack of 500 numbers</td>
<td>
0.0294 sec</td>
<td>
0.0162 sec</td>
</tr>
<tr valign=top>
<td>
Use vector stack of 5000 numbers</td>
<td>
0.2929 sec</td>
<td>
0.1597 sec</td>
</tr>
</table><BR>
<BR>
<b>Conclusion: </b>Not even close. Vectors win by several laps. The CStack class in VBCore is a noninterface version of CStackVec.</p>
</p>
</font></BODY>
</HTML>
