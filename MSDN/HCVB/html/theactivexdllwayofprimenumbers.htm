<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>The ActiveX DLL Way of Prime Numbers</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>

<font face="verdana,arial,helvetica" size="2"><h1><a name="theactivexdllwayofprimenumbers"></a>The ActiveX DLL Way of Prime Numbers</h1>
<BR>
Once you have an object-oriented solution, you’re just a few clicks away from an ActiveX DLL server. Here’s all you have to do to turn the CSieve class into a Sieve component. None of the steps require writing code:
<ol>
<li>
Select New from the File menu, and choose ActiveX DLL in the project type list. Name the project SieveBasDllN. This will be a native code DLL component written in Visual Basic.<BR><BR></li>
<li>
Remove the dummy class the IDE automatically puts in a new pro&shy;-<BR>ject, and insert the file SIEVE.CLS (the local CSieve class from the last <BR>section).<BR><BR></li>
<li>
Change the name property from CSieve to CSieveBasDllN. Use Save As commands to name the class file SieveBasDllN.CLS and the project file SieveBasDllN.VBP.<BR><BR></li>
<li>
Change the instancing property from private to MultiUse (5). This is the generic way to make a class public. If this class were to be part <BR>of an object hierarchy and it were created by the top-level class of the <BR>hierarchy, you might want to set it to PublicNotCreatable (2) so that clients couldn’t create it directly. We discussed the reasons for setting GlobalMultiUse back in Chapter 5. Figure 10-2 on the following page shows the settings so far.<BR><BR></li>
<li>
Open the Project Properties dialog box, and fill out blank fields starting with Project Description. The description is optional, but you’ll have a rude server indeed if you fail to provide it. Any client that wanted to register and use your services would have to guess your purpose from the project name. When you write a server, you don’t know who will use it. It might be called from Excel, from Word, or from a program you’ve never heard of. Visual Basic itself is a typical client. It offers a References dialog box for loading and registering servers, and it has an Object Browser for displaying public classes. Both use the description to identify the server.<BR><BR></li>
<li>
Write a help file for your server, and provide the filename and context ID of the server help topic in the Help File Name and Project Help ContextID fields. Why doesn’t my server have a help file? Well, uh...<BR>it has a virtual help file.<BR><BR></li>
<li>
Leave the Startup Object as None. In version 4 you had to specify a startup module—even if it did nothing. Now if your startup doesn’t need to do anything, Visual Basic won’t specify it for you automa&shy;ti&shy;cally. Keep in mind that any startup done in a Sub Main specified <BR>by this dialog box occurs once for the whole component and all the classes in it. It’s not the same as the object-specific startup that occurs in Class_Initialize events.<BR><BR></li>
<li>
Ignore the Upgrade ActiveX Controls checkbox. The server has no controls to upgrade.<BR><BR></li>
<li>
The SieveBasDllN component has no user interaction, so you mark <BR>it as having Unattended Execution. This makes it suitable for running with multithreaded clients. I discuss the implications of Unattended <BR>Execution in “Threads and Synchronization” in Chapter 11.<BR><BR></li>
<li>
&#09;On the Component tab, I accept the default setting of Project Compatibility. If I were creating a new implementation of an existing component (such as one of the Sieve components from the first edition of this book), I might want to set Binary Compatibility. I’ll talk more about this issue later.<BR><BR></li>
<li>
&#09;Compile the DLL to native code. The client program also uses a p-code version of the DLL. It’s created in exactly the same way except that <BR>the name and the compile options are different. When the server is compiled in the IDE, it is automatically registered. I’ll look at component registration in more detail in “Registering components” later in this chapter.</li>
</ol>
<BR><img src="f10te02.gif"></p><BR>
<b>Figure 10-2. Settings for ActiveX DLL server.</b></p>
<BR>
<b>Problem: </b>Compare calculating prime numbers functionally, locally, externally, with objects, and with early or late binding.</p>
<table>
<tr valign=top>
<td>
<b>Problem</b></td>
<td>
<b>P-Code</b></td>
<td>
<b>Native Code</b></td>
</tr>
<tr valign=top>
<td>
Local Basic function </td>
<td>
.1270 sec</td>
<td>
.0380 sec</td>
</tr>
<tr valign=top>
<td>
Early-bound Local Basic class, one at a time</td>
<td>
.1750 sec</td>
<td>
.0400 sec</td>
</tr>
<tr valign=top>
<td>
Late-bound Local Basic class, one at a time</td>
<td>
.7550 sec</td>
<td>
.6120 sec</td>
</tr>
<tr valign=top>
<td>
Early-bound Local Basic class, all at once</td>
<td>
.1460 sec</td>
<td>
.0330 sec</td>
</tr>
<tr valign=top>
<td>
Late-bound Local Basic class, all at once</td>
<td>
.1540 sec</td>
<td>
.0330 sec</td>
</tr>
<tr valign=top>
<td>
Basic global function in DLL</td>
<td>
.1210 sec</td>
<td>
.0350 sec</td>
</tr>
<tr valign=top>
<td>
Early-bound Basic class in DLL, one at a time </td>
<td>
.1710 sec</td>
<td>
.0390 sec</td>
</tr>
<tr valign=top>
<td>
Late-bound Basic class in DLL, one at a time</td>
<td>
.8380 sec</td>
<td>
.6040 sec</td>
</tr>
<tr valign=top>
<td>
Early-bound Basic class in DLL, all at once</td>
<td>
.1450 sec</td>
<td>
.0330 sec</td>
</tr>
<tr valign=top>
<td>
Late-bound Basic class in DLL, all at once</td>
<td>
.1510 sec</td>
<td>
.0330 sec</td>
</tr>
<tr valign=top>
<td>
Early-bound Basic class in EXE, one at a time</td>
<td>
9.8660 sec</td>
<td>
9.2240 sec</td>
</tr>
<tr valign=top>
<td>
Late-bound Basic class in EXE, one at a time</td>
<td>
20.5320 sec</td>
<td>
18.9650 sec</td>
</tr>
<tr valign=top>
<td>
Early-bound Basic class in EXE, all at once</td>
<td>
.2040 sec</td>
<td>
.0810 sec</td>
</tr>
<tr valign=top>
<td>
Late-bound Basic class in EXE, all at once</td>
<td>
.2210 sec</td>
<td>
.1040 sec</td>
</tr>
<tr valign=top>
<td>
Basic class in control, one at a time</td>
<td>
.5930 sec</td>
<td>
.3660 sec</td>
</tr>
<tr valign=top>
<td>
Basic class in control, all at once</td>
<td>
.1470 sec</td>
<td>
.0340 sec</td>
</tr>
<tr valign=top>
<td>
Early-bound C++ class in ATL DLL, one at a time</td>
<td>
NA</td>
<td>
.0150 sec</td>
</tr>
<tr valign=top>
<td>
Late-bound C++ class in ATL DLL, one at a time</td>
<td>
NA</td>
<td>
.2900 sec</td>
</tr>
<tr valign=top>
<td>
Early-bound C++ class in ATL DLL, all at once</td>
<td>
NA</td>
<td>
.0150 sec</td>
</tr>
<tr valign=top>
<td>
Late-bound C++ class in ATL DLL, all at once</td>
<td>
NA</td>
<td>
.0160 sec</td>
</tr>
<tr valign=top>
<td>
Early-bound C++ class in MFC DLL, one at a time</td>
<td>
NA</td>
<td>
.0830 sec</td>
</tr>
<tr valign=top>
<td>
Late-bound C++ class in MFC DLL, one at a time</td>
<td>
NA</td>
<td>
.1660 sec</td>
</tr>
<tr valign=top>
<td>
Early-bound C++ class in MFC DLL, all at once</td>
<td>
NA</td>
<td>
.0230 sec</td>
</tr>
<tr valign=top>
<td>
Late-bound C++ class in MFC DLL, all at once</td>
<td>
NA</td>
<td>
.0240 sec</td>
</tr>
</table><BR>
<BR>
<b>Conclusion: </b>Switching from a functional approach to an object-oriented approach doesn’t have a significant cost, but you do need to worry about late binding. Passing data across process boundaries has a significant cost, but you can reduce it by using early binding and transferring data in large chunks. Of course, total performance might not be an important goal; some clients could prefer an even flow of data instead of big chunks that take a long time to process. Visual Basic native code isn’t too far behind C++ native code, and when you compare to MFC, Visual Basic is actually faster. That’s because MFC doesn’t have dual interfaces as do Visual Basic and ATL. But notice that MFC is faster for late-bound operations (because it implements a fast, custom version of the IDispatch interface). In most cases, which kind of late-bound server is faster matters about as much as which breed of cart horse is faster.</p>
<BR>
The client code to access a public class in an ActiveX DLL server is pretty much the same as the code to access a private class in the current application. Only the class and the object variable names change. So instead of looking at this boilerplate, let’s take a quick look at the dark side—late binding. The only reason the Sieve Client program does late binding is to prove how slow it is. The reason I’m showing it here is to demonstrate that it can sometimes be more flexible than early binding.</p>
<pre><code>        ‘ Set variable at run time<BR>        Dim sieveLate As Object<BR>        Select Case cboServer.ListIndex<BR>        Case estBasicLocalClass<BR>            Set sieveLate = New CSieve<BR>#Const fUseTypeLib = 1<BR>#If fUseTypeLib Then<BR>        Case estBasicDllPCode<BR>            Set sieveLate = New CSieveBasDllP<BR>        Case estBasicDllNative<BR>            Set sieveLate = New CSieveBasDllN<BR>        §<BR>#Else<BR>        Case estBasicEXE<BR>            Set sieveLate = CreateObject(“SieveBasDllP.CSieveBasDllP”)<BR>        Case estBasicDllNative<BR>            Set sieveLate = CreateObject(“SieveBasDllN.CSieveBasDllN”)<BR>        §<BR>#End If<BR>        End Select<BR>        sieveLate.MaxPrime = txtMaxPrime.Text<BR>        If chkAll = vbUnchecked Then<BR>            ‘ Get one at a time<BR>            ms = timeGetTime()<BR>            For i = 1 To cIter<BR>                sieveLate.ReInitialize<BR>                Do<BR>                    iPrime = sieveLate.NextPrime<BR>                    ‘ More of the same...</code></pre>
<BR>
An interesting point is that the same variable can be used for all the different kinds of servers. In the early binding branch of this code, every server uses a different class and must have a different object variable. Therefore, the code to calculate the prime numbers must be duplicated for each class, with no difference other than the variable name. In the late binding branch, the same variable can work for any class because the class isn’t selected until run time. As a result, the code needs to be written only once. We could get the same behavior for early binding by writing an ISieve interface and making all the sieve classes implement it. But that’s not the point of this exercise.</p>
<p>
Notice that there are two ways of creating a new late-bound object—one using the New statement and the other using CreateObject. In this case, there’s a type library, so New is slightly more efficient. But in most cases where you have a type library, you can use early binding. Use CreateObject for those cases (rare in my experience) where you don’t have a type library or don’t know the name of the class until run time.</p>
<p>
<b>NOTE&#09;</b>You shouldn’t think of your DLL or OCX components as complete until you select the DLL base address. You do this on the Compile tab of the Project Properties dialog box. Visual Basic gives you a default base address, but if you accept it, your component will have a very good chance of being bumped by one of the other dummies who accepted the default address instead of selecting their own. If two components in the system have the same base address, the operating system will have to relocate one or the other. You don’t want it to be yours. The operating system expects base addresses to be on 64-KB boundaries, so there are 32,512 64-KB chunks in the available address range. You have a very good chance of avoiding everybody else’s range if you select your range randomly. The Address-o-matic program (as seen on TV) doesn’t aspire to being a wizard, but it will assign you a base address that isn’t in my range or in the Visual Basic range. You could enhance it to keep a database of known addresses to avoid, including the ranges for your company, your clients, and major component vendors. By the way, my range is one megabyte starting at &amp;H2E8B0000. Keep out!</p>
</font></BODY>
</HTML>
