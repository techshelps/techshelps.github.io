<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Walking Through Files</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>

<font face="verdana,arial,helvetica" size="2"><h1><a name="walkingthroughfiles"></a>Walking Through Files</h1>
<BR>
Sometime during your programming career, you’ve probably known the frustration of working with the Dir$ function. For simple operations, it’s very easy to use but it runs out of power quickly.</p>
<BR>
The worst limitation of Dir$ is documented right up front; you can’t call it &shy;recursively. This is a severe limitation for a function that ought to be able to <BR>iterate through your entire hard disk, finding files that match a given description or displaying directory trees. Workarounds exist, but the performance is unacceptable as shown in the “Performance” sidebar below. The other problem with Dir$ is that it returns only the filename. If you’re building a file display with attributes, file length, and file time, you have to hit the disk once for each item for each file.</p>
<BR>
But nothing prevents you from calling the Win32 FindFirstFile, FindNextFile, and FindClose functions to iterate through files yourself. You can recurse as much as you like and grab all the file data you need in one fell swoop. That’s what Dir$ is doing under the surface, anyway—but it’s throwing away all the information it finds except the filename.</p>
<BR>
The following WalkAllFiles function walks recursively through all the files and directories from a given starting directory. It calls the UseFile method of the </p>
<BR>
<b>Problem:</b> Compare the speed of finding files with the Dir$ function to equivalent techniques, such as using FindFileFirst and using the operating system’s Find dialog box.</p>
<table>
<tr valign=top>
<td>
<b>Problem</b></td>
<td>
<b>Native code</b></td>
<td>
<b>P-code</b></td>
</tr>
<tr valign=top>
<td>
Use the Visual Basic Dir$ function</td>
<td>
39 seconds</td>
<td>
 39 seconds</td>
</tr>
<tr valign=top>
<td>
Use the Win32 FindFirstFile function</td>
<td>
9 seconds</td>
<td>
 9 seconds</td>
</tr>
<tr valign=top>
<td>
Use the Windows Explorer Find dialog</td>
<td>
6 seconds</td>
<td>
</td>
</tr>
</table><BR>
<BR>
<b>Conclusion:  </b>The Dir$ function is clearly a loser, whereas FindFirstFile performs quite well. Your results will vary, depending on the host operating system, the size of the disk, and how many levels of nested directories it has. The times above were recorded under Windows 95 on a machine with a 1 GB hard disk. Try it for yourself with the Time It program. You might find a use for the function being tested (FindFiles in FILETOOL.BAS) in your own programs. It finds all occurences of a given file and returns the locations in a collection.</p>
<BR>
IUseFile interface to pass all the file data it finds back to the client. Here’s IUseFile:</p>
<pre><code>Function UseFile(UserData As Variant, FilePath As String, _<BR>                 FileInfo As CFileInfo) As Boolean<BR><BR>End Function</code></pre>
<BR>
The first parameter is any user-defined integer that the caller wants to pass to the client. Since UserData is passed by reference, the client can modify the data and pass it back. The <i>FilePath </i>parameter might be useful to clients, especially during a recursive walk. The <i>FileInfo </i>parameter contains everything the client might want to know about the file.</p>
<BR>
Here’s the WalkAllFiles function that uses IUseFile:</p>
<pre><code>Function WalkAllFiles(fileit As IUseFile, _<BR>                      Optional ByVal ewmf As EWalkModeFile = ewmfBoth, _<BR>                      Optional ByVal Start As String) As Boolean<BR><BR>    ‘ Statics for less memory use in recursive procedure<BR>    Static sName As String, fd As WIN32_FIND_DATA, iLevel As Long<BR>    Static fi As New CFileInfo<BR>    Dim hFiles As Long, f As Boolean<BR>    If Start = sEmpty Then Start = CurDir$<BR>    ‘ Maintain level to ensure collection is cleared first time<BR>    If iLevel = 0 Then Start = MUtility.NormalizePath(Start)<BR>    iLevel = iLevel + 1<BR>    <BR>    ‘ Find first file (get handle to find)<BR>    hFiles = FindFirstFile(Start &amp; “*.*”, fd)<BR>    f = (hFiles &lt;&gt; INVALID_HANDLE_VALUE)<BR>    Do While f<BR>        sName = MBytes.ByteZToStr(fd.cFileName)<BR>        ‘ Skip . and ..<BR>        If Left$(sName, 1) &lt;&gt; “.” Then<BR>            ‘ Create a file info object from file data<BR>            fi.CreateFromFile Start &amp; sName, fd.dwFileAttributes, _<BR>                              fd.nFileSizeLow, fd.ftLastWriteTime, _<BR>                              fd.ftLastAccessTime, fd.ftCreationTime<BR>            If fd.dwFileAttributes And vbDirectory Then<BR>                If ewmf And ewmfDirs Then<BR>                    ‘ Let client use directory data<BR>                    WalkAllFiles = fileit.UseFile(iLevel, Start, fi)<BR>                    ‘ If client returns True, walk terminates<BR>                    If WalkAllFiles Then Exit Function<BR>                End If<BR>                ‘ Call recursively on each directory<BR>                WalkAllFiles = WalkAllFiles(fileit, ewmf, _<BR>                                            Start &amp; sName &amp; “\”)<BR>            Else<BR>                If ewmf And ewmfFiles Then<BR>                    ‘ Let client use file data<BR>                    WalkAllFiles = fileit.UseFile(iLevel, Start, fi)<BR>                    ‘ If client returns True, walk terminates<BR>                    If WalkAllFiles Then Exit Function<BR>                End If<BR>            End If<BR>        End If<BR>        ‘ Keep looping until no more files<BR>        f = FindNextFile(hFiles, fd)<BR>    Loop<BR>    f = FindClose(hFiles)<BR>    ‘ Return the matching files in collection<BR>    iLevel = iLevel - 1<BR>End Function</code></pre>
<BR>
The client can use all or part of the data it receives in any way it wants. The WalkAllFiles function passes the recursion level in the <i>UserData </i>parameter to allow the client to format data according to its nesting level. A client that wants to use WalkAllFiles as a search engine can stop the walk by returning True from the UseFile method when it finds a file that meets its search criteria. In the Test Shell Folders application in Figure 11-11, the walk can be stopped by clicking the Stop button, which sets a flag telling the client to return True on the next iteration. You’ll soon get a chance to compare WalkAllFiles to the similar Walk&shy;AllFolders function, which walks through the shell name space.</p>
<BR>
I provide a similar WalkFiles function that iterates through a single directory. I’m not going to show the code, but here’s the signature:</p>
<pre><code>Function WalkFiles(fileit As IUseFile, _<BR>                   Optional ByVal ewmf As EWalkModeFile = ewmfBoth, _<BR>                   Optional ByVal Start As String, _<BR>                   Optional UserData As Variant) As Boolean</code></pre>
<BR>
WalkFiles also calls the IUseFile interface to pass data to the client, but the <i>UseFile </i>parameters have a different purpose for a single-directory walk. The path doesn’t have much value in this case and will usually be ignored. The level wouldn’t be of much use either, so instead WalkFiles takes an optional <i>UserData </i>parameter that will be passed on to the client in the UserData parameter of UseFile. The client implementation can pass back modified data. For example, the Test Shell Folders program passes a count variable with an initial value of zero. The UseFile implementation increments this count for each file and then displays the count of files at the end of the walk.</p>
<BR><img src="f11te11.gif"></p><BR>
<b>Figure 11-11. The Test Shell Folders application.</b></p>
</font></BODY>
</HTML>
