<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Using Shell</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>

<font face="verdana,arial,helvetica" size="2"><h1><a name="usingshell"></a>Using Shell</h1>
<BR>
The first thing you have to decide when running someone else’s program is whether to run synchronously or asynchronously. Generally, programs written for Windows want to run asynchronously. You send your children off to the video parlor and forget about them. Or you keep in touch by phone—COM, DDE, or the Clipboard, in Windows’ terms. Character-based programs (at least those that have survived the Windows onslaught) will usually prefer to operate synchronously. You send your children to the store to get some flour and eggs, but you can’t finish baking until they get back with the goods—usually <BR>a modified file. Of course, nothing prevents character-based programs from work&shy;ing independently or Windows-based programs from modifying data for their parents.</p>
<BR><img src="f11te04.gif"></p><BR>
<b>Figure 11-4. The Test Execute program.</b></p>
<BR>
The Shell function assumes that you want to run programs asynchronously. Running programs synchronously requires an extra effort. In olden times, hard&shy;core 16-bit Visual Basic programmers used the GetModuleUsage API function to wait for programs to terminate. The 32-bit version works much differently.</p>
<BR>
The Shell function returns a process ID. Process IDs and handles were introduced in “The process list—Windows NT view” in Chapter 6. To summarize, every process has an ID number that uniquely identifies it, but most operations on processes require handles. You can get a handle from an ID with the Win32 OpenProcess function, which requires you to specify what you would like permission to do with the handle. You can open multiple handles with &shy;different permissions. The WaitOnProgram procedure hides some of the details. If you want to wait for a program to finish, you can call it like this:</p>
<pre><code>Dim idProg As Long, iExit As Long<BR>idProg = Shell(&quot;mktyplib shelllnk.odl&quot;, vbHide)<BR>iExit = WaitOnProgram(idProg)<BR>If iExit Then MsgBox &quot;Compile failed&quot;</code></pre>
<BR>
WaitOnProgram returns the exit code of the shelled program. This assumes that the program chooses to return a meaningful exit code and isn’t written in Visual Basic. Most character-mode programs set exit codes out of habit, but many Windows programs don’t bother. Visual Basic itself returns an exit code when launched from the command line, but it doesn’t provide any means for you to set an exit code in your own programs. (If you’re thinking you could call the ExitProcess API yourself, forget it. I tried that, but the exit code you set doesn’t show up on the outside.)</p>
<BR>
The WaitOnProgram function takes an optional <i>WaitDead</i> parameter that determines which of two strategies will be used. The default (False in the example above) polls for termination in a DoEvents loop. If the <i>WaitDead </i>argument is True, the calling program is stopped dead in its tracks. Here’s the code:</p>
<pre><code>Function WaitOnProgram(ByVal idProg As Long, _<BR>                       Optional ByVal WaitDead As Boolean) As Long<BR>    Dim cRead As Long, iExit As Long, hProg As Long<BR>    ' Get process handle<BR>    hProg = OpenProcess(PROCESS_ALL_ACCESS, False, idProg)<BR>    If WaitDead Then<BR>        ' Stop dead until process terminates<BR>        Dim iResult As Long<BR>        iResult = WaitForSingleObject(hProg, INFINITE)<BR>        If iResult = WAIT_FAILED Then ErrRaise Err.LastDllError<BR>        ' Get the return value<BR>        GetExitCodeProcess hProg, iExit<BR>    Else<BR>        ' Get the return value<BR>        GetExitCodeProcess hProg, iExit<BR>        ' Wait, but allow painting and other processing<BR>        Do While iExit = STILL_ACTIVE<BR>            DoEvents<BR>            GetExitCodeProcess hProg, iExit<BR>        Loop<BR>    End If<BR>    CloseHandle hProg<BR>    WaitOnProgram = iExit<BR>End Function</code></pre>
<BR>
If you take the dead wait route, the WaitForSingleObject API function puts the Test Execute program into hibernation. You can click away as much as you want, but nothing fazes the Test Execute program until the child terminates. This is very efficient for other programs in the system because you’re not using any resources while you wait. But it’s a pretty rude way to behave if the calling program has a user interface. The program won’t even be repainted. In fact, if you do this in the IDE, Visual Basic itself will hibernate because it’s the real program waiting for the shelled program to finish. Generally you’ll only want to use the dead wait option from programs that have no user interface.</p>
</font></BODY>
</HTML>
