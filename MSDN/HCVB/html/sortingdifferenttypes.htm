<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Sorting Different Types</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>

<font face="verdana,arial,helvetica" size="2"><h1><a name="sortingdifferenttypes"></a>Sorting Different Types</h1>
<BR>
My version of SortArray sorts arrays of Variants. This is the most flexible way to define the procedure, but it won’t help if you have an array of Integers or Strings to sort. You can pass an Integer argument to a Variant parameter, but you can’t pass an array of Integers to a Variant array parameter. All those elements must be lined up in a row, and Basic must know the distance between them, which will be different for Integers than for Variants.</p>
<BR>
One solution is to put anything you want to sort in a Variant array. You can stuff the array with strings, integers, or real numbers, and SortArray will do the right thing with them. But it won’t necessarily be fast. You probably won’t see any difference if you’re sorting 150 integers or 50 strings. But if you’re doing the Mondo Double Sort From Down Under, you’ll want to write a separate Sort&shy;ArrayDouble for it. This process is so mechanical that you might be tempted to do it with conditional compilation:</p>
<pre><code># If SortArrayType = 0 Then<BR>Sub SortArray(aTarget() As Variant, iFirst As Integer, __<BR>              iLast As Integer, helper As ISortHelper)<BR>    Dim vSplit As Variant<BR># ElseIf SortArrayType = 1 Then<BR>Sub SortArray(aTarget() As Integer, iFirst As Integer, _<BR>              iLast As Integer, helper As ISortHelper)<BR>    Dim vSplit As Integer<BR># ElseIf SortArrayType = 2 Then<BR>Sub SortArray(aTarget() As Long, iFirst As Integer, _<BR>              iLast As Integer, helper As ISortHelper)<BR>    Dim vSplit As Long<BR># ElseIf SortArrayType = 3 Then<BR>Sub SortArray(aTarget() As String, iFirst As Integer, _<BR>              iLast As Integer, helper As ISortHelper)<BR>    Dim vSplit As String<BR># ElseIf SortArrayType = 4 Then<BR>§<BR>End Sub</code></pre>
<BR>
This trick is so ugly and fraught with potential for error that I hesitate to include it. Still, it’s interesting to see how you can change the internal operation of a procedure simply by changing parameter and variable types. Because the default value for a conditional constant is 0, you will get the Variant version of SortArray by doing nothing. You need to define a value for SortArrayType in the Make tab of the Project Properties dialog box to get any other type. One disadvantage of this hack is that you can have only one type of SortArray per project. That’s one reason I recommend the cut-and-paste method of getting different SortArray routines over the conditional compilation method. C++ <BR>provides a feature called templates for getting around this kind of problem, but I don’t expect to see anything like this in Visual Basic for a long time—if ever.</p>
</font></BODY>
</HTML>
