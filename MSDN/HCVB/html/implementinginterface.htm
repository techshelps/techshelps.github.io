<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Implementing an interface</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>

<font face="verdana,arial,helvetica" size="2"><h1><a name="implementinginterface"></a>Implementing an interface</h1>
<BR>
Let’s begin the process with a simple implementation of the filter class in Bug Wizard, CBug&shy;Filter. The key statement in an interface implementation is the Implements statement. At first glance, there’s not much to it:</p>
<pre><code>‘ CBugFilter implements IFilter<BR>Implements IFilter</code></pre>
<BR>
The interesting thing about this statement is not what it looks like, but what it does to the code window containing it. The object dropdown gets a new entry for IFilter. If you select IFilter, the procedure dropdown shows the event procedures that you must implement. When you select the Source property get procedure, the IDE automatically puts the cursor on the property method, if one exists, or creates a Source property get procedure if one doesn’t exist. The IDE creates the following procedure and puts the cursor on the blank line in the middle, ready for you to type in the implementation code:</p>
<pre><code>Private Property Get IFilter_Source() As String<BR><BR>End Property</code></pre>
<BR>
Interface procedures look like event procedures because, like event procedures, you can’t change their names. But unlike event procedures, you can’t ignore them. You must implement each and every member defined by the interface. By using the Implements keyword, you are signing a contract. You agree to implement all members exactly as they are defined in the interface. Try violating the contract. Change IFilter_Target to IFilter_Targot, or change the return type of IFilter_Translate to Integer. When you try to compile, Visual Basic will inform you in no uncertain terms that you are a cad and a deceiver and that you must fulfill your obligations if you wish to continue.</p>
<BR>
Here’s the interface part of the implementation I gave my CBugFilter class:</p>
<pre><code>‘ Implementation of IFilter interface<BR>Private sSource As String, sTarget As String<BR><BR>Private Property Get IFilter_Source() As String<BR>    IFilter_Source = sSource<BR>End Property<BR>Private Property Let IFilter_Source(sSourceA As String)<BR>    sSource = sSourceA<BR>End Property<BR><BR>Private Property Get IFilter_Target() As String<BR>    IFilter_Target = sTarget<BR>End Property<BR>Private Property Let IFilter_Target(sTargetA As String)<BR>    sTarget = sTargetA<BR>End Property<BR><BR>Private Function IFilter_Translate(sLine As String, _<BR>                                   ByVal iLine As Long) As EChunkAction<BR>    IFilter_Translate = ecaTranslate  ‘ Always translate with this filter<BR>    <BR>    Select Case eftFilterType<BR>    Case eftDisableBug<BR>        CommentOut sLine, sBug<BR>    Case eftEnableBug<BR>        CommentIn sLine, sBug<BR>    Case eftDisableProfile<BR>        CommentOut sLine, sProfile<BR>    Case eftEnableProfile<BR>        CommentIn sLine, sProfile<BR>    Case eftExpandAsserts<BR>        ExpandAsserts sLine, iLine<BR>    Case eftTrimAsserts<BR>        TrimAsserts sLine<BR>    End Select<BR>End Function</code></pre>
<BR>
Source and Target are unvalidated properties that you would normally implement with a Public member rather than with separate property procedures. The Implements statement won’t let you take that shortcut. If you look back at the IFilter class, you’ll notice that it also doesn’t take the Public member shortcut, although it could. You might want to experiment with Public members in interface classes, but don’t be surprised if Visual Basic makes choices about parameter names and ByVal attributes that you wouldn’t make yourself. By defining the Property Get and Let procedures yourself, you get better control over the code that will be used in the implemented class.</p>
<BR>
There’s no room for creativity in how you declare interface members in the implementing class. The creativity comes in the implementation of members such as the Translate function. Notice how the <i>sLine</i> parameter is passed by reference so that the modified version will be returned to the caller, but <i>iLine</i> is passed by value so that the caller’s copy can’t be changed.</p>
<BR>
As for what Translate actually does, it calls other procedures that do the actual work. If you reread the description of the Bug Wizard program, you can probably guess most of what these procedures are actually doing. The decision of which procedure to use is based on another property that is part of CBugFilter but not part of IFilter:</p>
<pre><code>Property Get FilterType() As EFilterType<BR>    FilterType = eftFilterType<BR>End Property<BR><BR>Property Let FilterType(eftFilterTypeA As EFilterType)<BR>    If eftFilterTypeA &gt;= eftMinFilter And _<BR>       eftFilterTypeA &lt;= eftMaxFilter Then<BR>        eftFilterType = eftFilterTypeA<BR>    Else<BR>        eftFilterType = eftMaxFilter<BR>    End If<BR>End Property</code></pre>
<BR>
This property uses an EFilterType Enum and an eftFilterType member variable (not shown). Next we’ll see how a client can use both the IFilter properties and the CBugFilter properties.</p>
</font></BODY>
</HTML>
