<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Unicode API Functions</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>

<font face="verdana,arial,helvetica" size="2"><h1><a name="unicodeapifunctions"></a>Unicode API Functions</h1>
<BR>
I’ve been assuming that you want to use only the ANSI versions of API functions, but if all your customers are running Windows NT, you can increase the efficiency of your programs by using Unicode functions. There are several ways to do this. One hard way is to fake Unicode strings by using byte arrays in Declare statements. The other hard way is to use a real pointer to the internal Unicode data. The easy way is to use a type library. Try the hard ways first so that you’ll appreciate the easy way.</p>
<BR>
There’s another reason to use Unicode functions. All COM API functions are Unicode by definition. You must define these as Unicode even if you’re dealing with Windows 95. Let’s take an example. REGTLB is a command-line program that can register type libraries. It calls the LoadTypeLib and RegisterTypeLib functions, which are COM functions in OLEAUT32.DLL. Both these functions are defined as Unicode functions in the Windows API type library. You can simply call them from Visual Basic and they’ll do the right thing. Of course, one of the type libraries you might want to register is WIN.TLB. Catch 22: you can’t register a type library using functions that are defined in that type library.</p>
<BR>
So let’s take a look at two ways of defining LoadTypeLib (RegisterTypeLib is similar). After cleanup of extraneous macros, the C definitions of LoadTypeLib and RegisterTypeLib look like this:</p>
<pre><code>HRESULT LoadTypeLib(LPCWSTR szFile, ITypeLib ** pptlib);<BR>HRESULT RegisterTypeLib(ITypeLib * ptlib, LPWSTR szFullPath, _<BR>                        LPWSTR szHelpDir);</code></pre>
<BR>
An HRESULT is a COM error type that is closely related to Visual Basic’s Err object. Any function that returns an HRESULT will recognize Basic-style error traps with On Error. In other words, to Visual Basic, HRESULT isn’t really a return value and LoadTypeLib and RegisterTypeLib aren’t really functions. It’s as if they were defined like this:</p>
<pre><code>Sub LoadTypeLib(szFile As String, pptlib As ITypeLib)<BR>Sub RegisterTypeLib(ByVal ptlib As ITypeLib, szFullPath As String, _<BR>                    szHelpDir As String)</code></pre>
<BR>
ITypeLib is a standard COM type. I’ll use Object instead. You get late binding instead of early binding, but that’s OK in this example. More on that later.</p>
<BR>
If you define these functions with Declare statements, you have to fake two things. First, you can’t define the HRESULT type. Bitwise, an HRESULT is a Long, and you’ll have to receive it as a Long and handle errors yourself rather than letting Basic do it for you. Second, you’ll have to come up with some way to pass Unicode strings. Here are two versions of the Declare statements:</p>
<pre><code>#If ordUnicode = ordRawBytes Then<BR>' Receive string arguments as Byte arrays<BR>Private Declare Function LoadTypeLib Lib &quot;oleaut32.dll&quot; ( _<BR>    pFileName As Byte, pptlib As Object) As Long<BR>Private Declare Function RegisterTypeLib Lib &quot;oleaut32.dll&quot; ( _<BR>    ByVal ptlib As Object, szFullPath As Byte, _<BR>    szHelpFile As Byte) As Long<BR>#ElseIf ordUnicode = ordStrPtr Then<BR>' Receive string arguments as pointers<BR>Private Declare Function LoadTypeLib Lib &quot;oleaut32.dll&quot; ( _<BR>    ByVal pFileName As Long, pptlib As Object) As Long<BR>Private Declare Function RegisterTypeLib Lib &quot;oleaut32.dll&quot; ( _<BR>    ByVal ptlib As Object, ByVal szFullPath As Long, _<BR>    ByVal szHelpFile As Long) As Long<BR>#ElseIf ordUnicode = ordTypeLib Then<BR>    ' No Declare needed!<BR>#End If</code></pre>
<BR>
Page 88 has some conditional code that uses the Declare or the type library entry depending on how you set the constant <i>ordUnicode</i>.</p>
<pre><code>Function RegTypelib(sLib As String) As Long<BR>#If ordUnicode = ordRawBytes Then<BR>    Dim suLib() As Byte, errOK As Long, tlb As Object<BR>    ' Basic automatically translates strings to Unicode Byte arrays<BR>    ' but doesn't null-terminate, so you must do it yourself<BR>    suLib = sLib &amp; vbNullChar<BR>    ' Pass first byte of array<BR>    errOK = LoadTypeLib(suLib(0), tlb)<BR>    If errOK = 0 Then errOK = RegisterTypeLib(tlb, suLib(0), 0)<BR>    RegTypelib = errOK<BR>#ElseIf ordUnicode = ordStrPtr Then<BR>    Dim errOK As Long, tlb As Object<BR>    ' Pass pointer to real (Unicode) string<BR>    errOK = LoadTypeLib(StrPtr(sLib), tlb)<BR>    If errOK = 0 Then errOK = RegisterTypeLib(tlb, StrPtr(sLib), 0)<BR>    RegTypelib = errOK<BR>#ElseIf ordUnicode = ordTypeLib Then<BR>    Dim tlb As ITypeLib<BR>    On Error GoTo FailRegTypeLib<BR>    ' Real HRESULT and real Unicode strings from type library<BR>    LoadTypeLib sLib, tlb<BR>    RegisterTypeLib tlb, sLib, sNullStr<BR>    Exit Function<BR>FailRegTypeLib:<BR>    MsgBox Err &amp; &quot;: &quot; &amp; Err.Description<BR>    RegTypelib = Err<BR>#End If<BR>End Function</code></pre>
<BR>
Notice that in the first two versions you have to treat the procedures as functions and handle the return value. The version that uses the type library is processed like a sub. You use error trapping to deal with the hidden HRESULT. The StrPtr function used in the second version gets a pointer to the real Unicode string and passes the pointer directly. I’ll have more to say about StrPtr in the next section.</p>
</font></BODY>
</HTML>
