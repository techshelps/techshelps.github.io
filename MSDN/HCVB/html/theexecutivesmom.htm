<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>The Executive’s Mom</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>

<font face="verdana,arial,helvetica" size="2"><h1><a name="theexecutivesmom"></a>The Executive’s Mom</h1>
<BR>
The Run method of CExecutive calls one of the top ten most complicated Win32 functions, CreateProcess. Actually, CreateProcess isn’t quite as bad as it looks—once you figure out that most of its argument variations don’t apply to you. In the CExecutive class, it’s the properties that do the work. Most of them set up the STARTUPINFO structure containing input, and a few of them read the process and thread handles returned in the PROCESS_INFORMATION structure. I’m not going to get into the messy details of using these structures. Let’s just say that after your ducks are lined up, knocking them over with the Run method is no big deal.</p>
<pre><code>Sub Run(sCmd As String)<BR><BR>    ' Process any environment variables<BR>    Dim sCmdLine As String, sPipeOut As String, sPipeErr As String<BR>    sCmdLine = MUtility.ExpandEnvStr(sCmd)<BR>    sProg = MParse.GetQToken(sCmdLine, &quot; &quot;)<BR>    <BR>    ' Create standard input, output, and error pipes<BR>    CreatePipes<BR>    <BR>    ' Create process and run it<BR>    If CreateProcess(sNullStr, sCmdLine, ByVal pNull, ByVal pNull, _<BR>                     APITRUE, 0&amp;, pNull, sInitDir, start, proc) Then<BR>        <BR>        ' Must close write end of out and err handles before you can read<BR>        CloseHandleNull hWriteStdOut<BR>        CloseHandleNull hWriteStdErr<BR>        <BR>        Select Case ewm<BR>        Case ewmWaitIdle<BR>            ' Wait, but allow painting and other processing<BR>            Do<BR>                GetExitCodeProcess proc.hProcess, iExit<BR>                DoEvents<BR>            Loop Until ReadPipeChunk And ReadPipeErrChunk And Completed<BR>        Case ewmWaitDead<BR>            ' Stop dead until process terminates<BR>            Dim iResult As Long<BR>            iResult = WaitForSingleObject(proc.hProcess, INFINITE)<BR>            If iResult = WAIT_FAILED Then ErrRaise Err.LastDllError<BR>            ' Get the return value<BR>            GetExitCodeProcess proc.hProcess, iExit<BR>            Do<BR>            Loop Until ReadPipeChunk And ReadPipeErrChunk And Completed<BR>        Case Else<BR>            ' Caller must call use ExitCode and pipe chunks directly<BR>        End Select<BR>        CloseHandleNull proc.hProcess<BR>        CloseHandleNull proc.hThread<BR>    Else<BR>        ApiRaise Err.LastDllError<BR>    End If<BR>End Sub</code></pre>
<BR>
Most of the work here is handling the WaitMode property (represented by the <i>emw </i>variable). It’s very similar to what you already saw in WaitOnProgram.</p>
<BR>
The code to handle standard input and output pipes is the most difficult part. The standard input, standard output, and error pipes are set up in the CreatePipes procedure. The output can be read all at once from the PipedOutText property when Run is finished. If <i>WaitMode</i> is <i>ewmNoWait</i>, you can read the pipe in chunks the way you see it done in the Run method. Windows is not very forgiving in its handling of pipes. If you get anything wrong, you’ll crash, as I learned the hard way over and over again. But I think I’ve finally got the kinks worked out so that you can pipe safely with CExecutive.</p>
<BR>
The Shell function takes the same constants known to Create&shy;Process, ShellExecute, and their obsolete API ancestor WinExec. These are the same constants used by ShowWindow to modify the appearance of an existing window, and, frankly, many of them don’t make sense in the context of starting a new program. The Display Options settings in the Test Execute &shy;program—Hidden,Has Focus, Minimized, and Maximized—work better for me. Take a look at the logic in the check box event procedures and the GetDisplay function (TEXECUTE.FRM), which translates these sensible settings into the arbitrary constants required by Windows.</p>
</font></BODY>
</HTML>
