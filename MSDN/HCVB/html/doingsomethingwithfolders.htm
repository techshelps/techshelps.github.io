<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Doing Something with folders</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>

<font face="verdana,arial,helvetica" size="2"><h1><a name="doingsomethingwithfolders"></a>Doing something with folders</h1>
<BR>
After all those preliminaries, we’re ready to actually do something. Let’s start with the Test Shell Folders program (TFOLDER.VBG) shown in Figure 11-11. It can walk through files or folders, one at a time or all at once. You can start with either a path or one of the locations shown in the Special Folders list box. You can click the Context Menu button to bring up a context menu on the current path or special folder, and then you can click the button with three dots to browse for a starting folder. And as a bonus, you can stop a walk. You’ll see what this button is for if you try to walk the whole desktop.</p>
<BR>
Let’s start with the Walk All Folders button: </p>
<pre><code>Private Sub cmdWalkFolders_Click()<BR>    Dim folder As IVBShellFolder<BR>    txtOut = “Walk folders recursively: “ &amp; sCrLfCrLf<BR>    fStop = False<BR>    fWalkAll = True<BR>    If chkPath Then<BR>        Set folder = FolderFromItem(txtPath)<BR>    Else<BR>        With lstSpecial<BR>            Set folder = FolderFromItem(.ItemData(.ListIndex))<BR>        End With<BR>    End If<BR>    WalkAllFolders folder, Me, 0, WalkType(cboWalk.ListIndex)<BR>End Sub</code></pre>
<BR>
The event procedure uses FolderFromItem to turn a special folder constant or a path into a folder. Once you have a folder, you can start walking. The form implements the IUseFolder interface, which WalkAllFolders will call back in the same way that WalkAllFiles calls IUseFile. The <i>Me </i>argument represents the form’s IUseFolder object. And finally, after several pages of preliminaries, we’re ready to do some actual work. I don’t think WalkAllFolders will be an anticlimax:</p>
<pre><code>Function WalkAllFolders(folder As IVBShellFolder, foldit As IUseFolder, _<BR>                        Optional ByVal Level As Long = 0, _<BR>                        Optional ByVal ewm As EWalkMode = ewmBoth, _<BR>                        Optional ByVal hWnd As Long = hNull) As Long<BR>    InitIf  ‘ Initialize if in standard module<BR>    <BR>    Dim idenum As IVBEnumIDList, folderNew As IVBShellFolder<BR>    Dim pidl As Long, cFetched As Long, afAttrib As Long<BR>    <BR>    ‘ Get the IEnumIDList object for the given folder<BR>    On Error GoTo WalkAllFoldersFail<BR>    folder.EnumObjects hWnd, ewm, idenum<BR>    <BR>    ‘ Enumerate through the list of folder and nonfolder objects<BR>    On Error GoTo WalkAllFoldersFail2<BR>    Dim hRes As Long<BR>    Do<BR>        hRes = idenum.Next(1, pidl, cFetched)<BR>        ‘ 0 means got another, 1 means no more, anything else is error<BR>        ‘ but there had better not be any errors because we’ll ignore them<BR>        If hRes Then Exit Do<BR>        <BR>        ‘ Pass to user-implemented interface to do something with folder<BR>        ‘ (True in return means user requested termination)<BR>        WalkAllFolders = foldit.UseFolder(Level, folder, pidl)<BR>        If WalkAllFolders Then<BR>            Allocator.Free pidl<BR>            Exit Function<BR>        End If<BR>        <BR>        ‘ It’s not in the docs, but you pass in the attributes you want<BR>        ‘ to check and GetAttributes passes back whether those attributes<BR>        ‘ are set, ignoring all others<BR>        afAttrib = SFGAO_HASSUBFOLDER Or SFGAO_FOLDER<BR>        folder.GetAttributesOf 1, pidl, afAttrib<BR>        <BR>        ‘ If there are subfolders, process them recursively<BR>        If afAttrib And (SFGAO_HASSUBFOLDER Or SFGAO_FOLDER) Then<BR>            folder.BindToObject pidl, 0, iidShellFolder, folderNew<BR>            WalkAllFolders = WalkAllFolders(folderNew, foldit, Level + 1, ewm)<BR>        End If<BR>WalkAllFoldersFail2:<BR>        ‘ Free the pidl from Next<BR>        Allocator.Free pidl<BR>    Loop<BR>WalkAllFoldersFail:<BR><BR>End Function</code></pre>
<BR>
The walk is accomplished through a call to the EnumObjects method of IShell&shy;Folder. It returns an  IEnumIDList object, which looks and works a lot like the IEnumVARIANT interface described in Chapter 4. Of course, as we’ve noted several times (especially in Chapters 3, 4, and 10), most system interfaces are Basic-hostile, forcing us to use Basic-friendly binary-compatible versions called IVB&shy;ShellFolder and IVBEnumIDList.</p>
<BR>
Once we’ve created an ID enumerator, we can call its Next method to walk through all the items in the folder. For each item, we call the UseFolder method of IUseFolder to let the client do whatever they want with the folder. The Use&shy;Folder method takes a CFileInfo parameter, providing the client with all the information they could possibly want. You can check out my FileInfoFromFolder function to see how a folder and a PIDL become a CFileInfo object. If the user doesn’t tell us to stop (by returning True), we call the GetAttributesOf method to see whether this folder has subfolders. If it does, we call the BindToObject method to bind the current folder object to a new sub&shy;folder object. Finally we call ourselves recursively to handle the new folder.</p>
<BR>
Whew!</p>
<BR>
And that’s just the start. You might also want to check out ContextPopMenu. It starts out similar to WalkAllFolders, but instead of binding to a nested folder, it calls the GetUIObjectOf method to get an IVBContextMenu object and then uses that object to display the standard context menu for the item. ContextPopMenu is based on a C version in a <i>PC Magazine</i> article by Jeff Prosise.</p>
<BR>
Ideally, I’d provide other functions or classes that integrate other shell features such as property sheet handlers, icon extractors, and drag and drop handlers. Another time.</p>
</font></BODY>
</HTML>
