<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Resource callbacks</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>

<font face="verdana,arial,helvetica" size="2"><h1><a name="resourcecallbacks"></a>Resource callbacks</h1>
<BR>
Most of the real work of finding resources is done by UpdateResources. It looks like this:</p>
<pre><code>Private Sub UpdateResources(ByVal hMod As Long)<BR>    ‘ Turn on hourglass, turn off redrawing<BR>    HourGlass Me<BR>    Call LockWindowUpdate(lstResource.hWnd)<BR>    lstResource.Clear<BR>    <BR>    Call EnumResourceTypes(hMod, AddressOf ResTypeProc, Me)<BR>    <BR>    Call LockWindowUpdate(hNull)<BR>    HourGlass Me<BR>End Sub</code></pre>
<BR>
The EnumResourceTypes API function sets up a callback function named Res&shy;TypeProc. As described in “Limits of Procedure Pointers,” page 99, the callback procedure must reside in a BAS module, although it would be a lot handier to put it in WINWATCH.FRM with the UpdateResources procedure. The callback procedure will need access to the form so that it can fill the Resources list box and inspect the Filter Resources check box. How can we make these controls available to the standard module containing the callback? Well, we could always use global variables, but there is a better way. Like most callback functions, EnumResourceTypes has an extra parameter for user-defined data. We can use that parameter to pass the whole form. Here’s how it works:</p>
<pre><code>Function ResTypeProc(ByVal hModule As Long, ByVal lpszType As Long, _<BR>                     frm As Form) As Long<BR>    ResTypeProc = True      ‘ Always return True<BR>    If lpszType &lt;= 65535 Then<BR>        ‘ Enumerate resources by ID<BR>        Call EnumResourceNamesID(hModule, lpszType, _<BR>                                 AddressOf ResNameProc, frm)<BR>    Else<BR>        ‘ Enumerate resources by string name<BR>        Call EnumResourceNamesStr(hModule, PointerToString(lpszType), _<BR>                                  AddressOf ResNameProc, frm)<BR>    End If<BR>End Function</code></pre>
<BR>
First look at that ByRef Form parameter. Windows expects that parameter to be a ByVal Long, but Long is the size of a pointer, so we can pass anything we want here as long as we pass it by reference. We couldn’t be so fast and loose with types if ResTypeProc were going to be called by Visual Basic, but it’s not. Windows is the only caller and as long as it gets 32 bits, it doesn’t care what they point to. Notice that the only thing the procedure does with the <i>frm </i>parameter is pass it on to EnumResourceNames (which sets up ResNameProc as a callback).</p>
<BR>
An unusual thing about ResTypeProc is how it handles the string pointer <i>lpsz&shy;Type. </i>Actually, this isn’t all that unusual. Windows often overloads string pointers to represent integers in some situations. For reasons that need not concern us, pointers always have a non-zero high word. That means that Windows can use a high word of zero to signal that a pointer isn’t really a pointer. With resources, Windows uses the low word for standard resource types. There are constants with values of less than 65,536 for common resource types such as icons, bit&shy;maps, and cursors. Unusual and user-defined types have string names. When you’re enumerating resource types, you don’t know whether you’re going to get a real string pointer or one of these constants. The Windows API type library provides EnumResourceNamesID and EnumResourceNamesStr as aliases for the EnumResourceNames API function so you can enumerate the resource names for constants or strings. Here’s the callback function:</p>
<pre><code>Function ResNameProc(ByVal hModule As Long, ByVal lpszType As Long, _<BR>                     ByVal lpszName As Long, frm As Form) As Long<BR>    Dim sType As String, sName As String<BR>    ResNameProc = True      ‘ Always return True<BR>    If lpszName &lt;= 65535 Then<BR>        sName = Format$(lpszName, “00000”)<BR>    Else<BR>        sName = PointerToString(lpszName)<BR>    End If<BR>    If lpszType &lt;= 65535 Then<BR>        sType = ResourceIdToStr(lpszType)<BR>    Else<BR>        sType = PointerToString(lpszType)<BR>    End If<BR>    If frm.chkFilter = vbChecked Then<BR>        If Not ValidateResource(hModule, sName, sType) Then Exit Function<BR>    End If<BR>    frm.lstResource.AddItem sName &amp; “   “ &amp; sType<BR>End Function</code></pre>
<BR>
Once again, you have to check the values of <i>lpszType </i>and <i>lpszName </i>to see if they are strings or integers. Windows uses integers to represent standard resources such as the stop sign icon or the arrow cursor. In this case, if we get an integer ID for the resource name, we format it as a zero-aligned string so that it will line up correctly in the list box. If we get an integer ID for the type, we look up the type name with the ResourceIdToStr function, which is just a Select Case block that returns string names for the standard type names.</p>
</font></BODY>
</HTML>
