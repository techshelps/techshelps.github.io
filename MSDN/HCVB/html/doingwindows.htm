<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Doing windows</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>

<font face="verdana,arial,helvetica" size="2"><h1><a name="doingwindows"></a>Doing windows</h1>
<BR>
Let’s review polymorphism with Implements and see how it works in WinWatch. The IWindowsHelper interface is the template for any polymorphic class that needs to do something to a window (based on its handle). CWindowToFile is an IWindowsHelper class that writes window information to a file. CWindow&shy;ToForm is an IWindowsHelper class that writes window information to a form—specifically to a label on the form and to a treeview control.</p>
<BR>
Note that IterateChildWindows and IWindowsHelper are general elements that you might use in any project. They’re in the VBCore project. CWindowToFile and CWindowToForm are project specific. They are designed for WinWatch, which is the only project that is likely to need them. Polymorphism turns object-oriented programming upside down. When you write classes for encapsulation, you usually create one class to be used from many programs. When you write classes for polymorphism, you have only one interface, but you create many project-specific classes that implement the interface. You can see how this works in the WinWatch code that uses the IWindowsHelper classes:</p>
<pre><code>Private Sub RefreshFullWinList(fLogFile As Boolean)<BR>    Const sLog = &quot;WINLIST.TXT&quot;<BR><BR>    Call LockWindowUpdate(tvwWin.hWnd)<BR>    tvwWin.Nodes.Clear<BR>    HourGlass Me<BR>    If fLogFile Then<BR>        lblMsg.Caption = &quot;Creating log file &quot; &amp; sLog &amp; &quot;...&quot;<BR>        nFileCur = FreeFile<BR>        Open sLog For Output As nFileCur<BR>        Print #nFileCur, sEmpty<BR>        Print #nFileCur, &quot;Window List &quot; &amp; sCrLf<BR>        Dim helperFile As CWindowToFile<BR>        Set helperFile = New CWindowToFile<BR>        helperFile.FileNumber = nFileCur<BR>        ''@B IterateChildWindows<BR>        Call IterateChildWindows(-1, GetDesktopWindow(), helperFile)<BR>        ''@E IterateChildWindows<BR>        Close nFileCur<BR>    Else<BR>        lblMsg.Caption = &quot;Building window list...&quot;<BR>        Dim helperForm As CWindowToForm<BR>        Set helperForm = New CWindowToForm<BR>        Set helperForm.TreeViewControl = tvwWin<BR>        helperForm.ShowInvisible = chkInvisible<BR>        Call IterateChildWindows(-1, GetDesktopWindow(), helperForm)<BR>    End If<BR>    lblMsg.Caption = sMsg<BR>    HourGlass Me<BR>    tvwWin.Refresh<BR>    Call LockWindowUpdate(hNull)<BR>End Sub</code></pre>
<BR>
You create and pass to IterateChildWindows a completely different object, depending on what you’re doing. The ISortHelper interface and the CSortHelper class from Chapter 5 at least had object-oriented pretensions. But the IWindows&shy;Helper interface and the CWindowToFile and CWindowToForm classes have no purpose other than to provide a platform for the DoWindow method. In fact, DoWindow is almost all there is to these classes.</p>
<BR>
Here’s the interface the classes are built on:</p>
<pre><code>Function DoWindow(ByVal iLevel As Integer, _<BR>                  ByVal hWnd As Long) As Long<BR>End Function</code></pre>
<BR>
That’s all there is to it. Here’s the CWindowToFile version:</p>
<pre><code>Implements IWindowsHelper<BR><BR>Public FileNumber As Integer<BR><BR>Private Function IWindowsHelper_DoWindow(ByVal iLevel As Integer, _<BR>                                         ByVal hWnd As Long) As Long<BR><BR>    BugAssert hWnd &lt;&gt; hNull<BR>    ‘ Ignore desktop window (level -1)<BR>    If iLevel &gt;= 0 Then<BR>        ‘ Write data to log file<BR>        Print #FileNumber, GetWndInfo(hWnd, iLevel)<BR>    End If<BR>    ‘ Always successful<BR>    IWindowsHelper_DoWindow = hNull<BR>End Function</code></pre>
<BR>
<b>Recursion</b></p>
<BR>
A good recursive algorithm looks simple and symmetrical but has a magical complexity when you watch it in action. Code your recursive routines carefully to avoid recursing forever. Recursion works best if you have a limited task with clean exits. Also be sure that you don’t recurse too deeply and eat up all your stack space. IterateChildWindows recurses once for each level of child windows, but you’re not likely to find more than five levels of child windows. In other words, the algorithm recurses frequently but not deeply. Each level releases its stack resources before going on to the next.</p>
<BR>
If you use algorithms that recurse deeply (recursive sorting algorithms, for example), try to minimize your stack use. Don’t use more parameters than necessary, and declare local variables with Static rather than Dim. Static variables save stack space because they aren’t stored on the stack. You’ll need to watch out for side effects, however. Static variables retain their values across calls, so you should avoid using Static for any variable that you don’t specifically initialize on each entrance.</p>
<BR>
You must also pay attention to how you declare parameters. Notice that the <i>iLevel</i> and <i>hWnd</i> parameters of IterateChildWindows are passed by value (using ByVal) rather than by reference. Each level keeps its own local arguments on the stack so that changes to the current level don’t affect other levels. If you passed by reference, you’d be affecting the <i>hWnd</i> of the higher-level calls each time you set <i>hWnd</i> in a recursive call. Everything would be fine as long as you were recursing down, but you’d be lost as soon as you started back up.</p>
<BR>
This class does have one independent property, FileNumber, which must be set by the caller. But the only code is the implementation of DoWindow. It calls the GetWndInfo function to analyze and describe the window. The CWindowTo&shy;Form version is pretty much the same except that it updates a treeview control instead of writing to a file.</p>
<BR>
Both IterateChildWindows and the DoWindow method are functions. This enables you to search for a window with certain features. For example, you could write your own version of FindWindow to search the window hierarchy for a window with a given class, title, or other feature. Your DoWindow function would return the window handle when it found the appropriate window, but hNull in all other cases. Any found handle would bubble up through the levels of recursion, stopping the iteration process and returning the handle via the top-level call to IterateChildWindows. In the WinWatch versions of DoWindow, we want to continue as long as any windows are left, so we always return hNull to indicate that DoWindow hasn’t found the magic window. In WinWatch, the outer call to IterateChildWindows just throws away the returned handle, using the Call syntax.</p>
<BR>
You can use the log file created by WinWatch to get a snapshot of the window state. Want to know the class name of a button or an icon in a particular program? Run WinWatch and click the Log File button.</p>
</font></BODY>
</HTML>
