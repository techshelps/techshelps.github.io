<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>When reference counting goes wrong</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>

<font face="verdana,arial,helvetica" size="2"><h1><a name="whenreferencecountinggoeswrong"></a>When reference counting goes wrong</h1>
<BR>
Visual Basic always does reference counting behind the scenes whether you need it or not. For example, consider this code:</p>
<pre><code>Dim toughluck As CHardway, toobad As CHardway<BR>Set toughluck = New CHardway    ‘ c = 1<BR>Set toobad = toughluck          ‘ c = 2<BR>’ Use toobad...<BR>Set toobad = Nothing            ‘ c = 1<BR>’ Use toughluck...</code></pre>
<BR>
When <i>toobad </i>is set, the reference count is incremented. When <i>toobad </i>is destroyed, the reference count is decremented. But you can see that, in this case, the use of <i>toobad </i>is nested within the lifetime of <i>toughluck</i>. There’s really no need to mess with the reference count if you know the second reference is nested within the first. In C++ or B--, you can optimize this code by not doing the nested reference count. In Visual Basic, the reference count always happens behind the scenes whether you need it or not. This is no big deal because reference counting is cheap and situations in which you can determine at compile time that a reference is always nested are rare. Skipping this optimization in exchange for having the language take care of all the reference counting for you is a good trade-off.</p>
<BR>
In real Visual Basic code, references are rarely destroyed explicitly by setting an object variable to Nothing. Instead, they are created and destroyed automatically when you pass objects to procedures, return them from functions, set or get them with properties, or destroy other objects that hold references to them. Think of your program as a display panel in a science fiction movie where mysterious lights blink on and off in unintelligible patterns. You’re supposed to follow the plot of the movie, not try to figure out exactly what makes each light go on or off.</p>
<BR>
But there is one situation in which you have to understand and override the default reference counting behavior. That situation involves circular references. Let’s say you create object A. Object A creates object B. B and A have to communicate with each other, so A passes a reference of itself to B. B has a reference to A. A has a reference to B. Now you, the creator of A, have a reference to A, but you don’t have a direct reference to B. </p>
<BR>
Now suppose you’re done with A, so you attempt to terminate it, releasing your reference to A. You might wish that terminating A would cause A to release <BR>its reference to B, but A has no way to do this. B still has a reference to A, so A’s reference count isn’t zero and it can’t terminate. B can’t terminate because A still has a reference to B. And now you, the creator of A, no longer have a reference to A. Both A and B live on as independent objects and you have no way to destroy either of them. </p>
<BR>
If you’re running in the Visual Basic environment, your program won’t terminate normally when you unload its forms. You have to hit the End button to kill it. The independent objects will continue to eat up resources even though you’re finished with them and don’t want them in memory. This can cause lots of problems—in extreme cases you might even have to use the Task Manager to terminate rogue EXE servers. </p>
</font></BODY>
</HTML>
