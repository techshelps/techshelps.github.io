<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>GetToken</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>

<font face="verdana,arial,helvetica" size="2"><h1><a name="gettoken"></a>GetToken</h1>
<BR>
<i>Bruce: </i>The original GetToken in REMLINE worked exactly like the C strtok function. It follows a classic design for iteration functions that have to be called repeatedly until they report no more items to iterate. In this type of function, you call it with one set of arguments the first time, and then you call it with another set of arguments each subsequent time.</p>
<BR>
GetToken works the same way. The first time, you pass the string to be parsed; after that, you pass an empty string. It goes like this:</p>
<pre><code>sSeparator = “, “ &amp; sTab &amp; sCrLf  <BR>sToken = GetToken(sCommand, sSeparator)<BR>Do While sToken &lt;&gt; sEmpty<BR>    ‘ Do something with sToken<BR>    sToken = GetToken(sEmpty, sSeparator)<BR>Loop</code></pre>
<BR>
That’s the philosophy. Here’s the code:</p>
<pre><code>Function GetToken1(sTarget As String, sSeps As String) As String<BR>    <BR>    ‘ Note that sSave and iStart must be static from call to call<BR>    ‘ If first call, make copy of string<BR>    Static sSave As String, iStart As Integer<BR>    If sTarget &lt;&gt; sEmpty Then<BR>        iStart = 1<BR>        sSave = sTarget<BR>    End If<BR><BR>    ‘ Find start of next token<BR>    Dim iNew As Integer<BR>    iNew = StrSpan1(Mid$(sSave, iStart, Len(sSave)), sSeps)<BR>    If iNew Then<BR>        ‘ Set position to start of token<BR>        iStart = iNew + iStart - 1<BR>    Else<BR>        ‘ If no new token, return empty string<BR>        GetToken1 = sEmpty<BR>        Exit Function<BR>    End If<BR>    <BR>    ‘ Find end of token<BR>    iNew = StrBreak1(Mid$(sSave, iStart, Len(sSave)), sSeps)<BR>    If iNew Then<BR>        ‘ Set position to end of token<BR>        iNew = iStart + iNew - 1<BR>    Else<BR>        ‘ If no end of token, set to end of string<BR>        iNew = Len(sSave) + 1<BR>    End If<BR>    ‘ Cut token out of sTarget string<BR>    GetToken1 = Mid$(sSave, iStart, iNew - iStart)<BR>    ‘ Set new starting position<BR>    iStart = iNew<BR><BR>End Function</code></pre>
</font></BODY>
</HTML>
