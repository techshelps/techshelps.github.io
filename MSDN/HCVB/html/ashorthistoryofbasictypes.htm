<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>A Short History of Basic Types</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>

<font face="verdana,arial,helvetica" size="2"><h1><a name="ashorthistoryofbasictypes"></a>A Short History of Basic Types</h1>
<dl>
<dt>
Kemeny and Kurtz designed Basic with numbers and strings as its two data types. A variable was always a number unless it ended with a dollar sign, in which case it was a string. A number was actually a floating-point number, although users didn’t need to know this. There was no such thing as an integer. Kemeny and Kurtz claimed that this was a feature. For example, in comparing Basic to Pascal, their book <i>Back to BASIC</i> had this to say:</dt>
<dd>
<i>Incidentally, Pascal requires that the user know about two kinds of numbers—integer and real. Reals are used for general computation, while integers must be used in for-loops and as array subscripts. Pascal thus permanently burdens the user with matters that are tem&shy;-p&shy;orary peculiarities of the ways computers do arithmetic. (page 96)</i></dd>
</dl>
<p>
Is the difference between integers and floating-point numbers simply a relic of computer technology? I think not. In any case, performance was obviously not a priority. Developers of Basic compilers and interpreters never bought this line. The compilers and particularly the interpreters castigated by Kemeny and Kurtz as “Street Basic” added types for integers, long integers, and various sizes of real numbers. User-defined types and fixed-length strings crept into the language. Basic acquired the types of Pascal without the discipline of enforced data declarations. You could simply add a type-declaration character ($, &amp;, %, !, #, or @) to a variable to specify its type. Or you could use the Def statement (borrowed from a similar feature in FORTRAN) to specify that variables with a certain initial character would have a particular type.</p>
<p>
Then Microsoft shook things up again, returning to the roots of Basic with the introduction of the Variant type, which can contain any native type. You need only this one type; the computer, not the programmer, chooses which type goes into a Variant. You pay a price for this convenience (refer to the “Performance” sidebar on page 34), but in many cases it’s worth the cost. Variants contain not only the variable data but also information about the variable. This enables Basic to do automatic type conversion and lets you do your own type checking. Variants can also include special values such as Null, Nothing, Empty, and Error. I’ll be talking about variants and the trade-offs involved in using them throughout this book.</p>
<p>
The introduction of Option Explicit in Visual Basic version 2 was another milestone in the history of Basic data types. By setting Option Explicit, you force yourself to declare every variable, just as you do in Pascal. This feature prevents one of the most common and annoying Basic bugs, the misspelling error. If you misspell the name of a variable, Basic creates a new variable with the new spelling and the default data type (formerly Single, now Variant). You think that you’re assigning a value to or calculating with the original variable, but you’re actually using the new one. You don’t need to hit this bug very often to decide that declaring every variable is not too high a price to pay to avoid it.</p>
<p>
Visual Basic is moving away from type-declaration characters. Version 4 offered three new simple types—Date, Byte, and Boolean. But Basic does not pro&shy;vide a type-declaration character for any of these types. Nor does it provide type-<BR>declaration characters for complex types such as Object, Form, Control, and Variant. There just aren’t enough unused punctuation characters to go around.</p>
<p>
Despite this trend, the dollar-sign character for strings still rules in one important context. Basic functions that return strings come in two styles: naked and dressed to kill. The naked version of Mid takes a variant argument and returns a variant. The dressed-up version (Mid$) takes a string argument and returns a string. Basic manuals no longer note this difference, but it exists just the same. (The Time It program described later in this chapter demonstrates the difference between calling Mid and Mid$ in different contexts.)</p>
<p>
<b>Dollar Signs in Basic Functions</b><p>
I really don’t like the looks of those dollar signs. I’d much rather use the naked version. But I’m not willing to take a noticeable speed hit for cosmetic reasons. Therefore, you’ll see the dressed-up version in samples that use strings (common) and the naked version in samples that use variants (rare).</p>
</p>
</font></BODY>
</HTML>
