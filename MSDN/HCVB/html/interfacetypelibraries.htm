<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Interface Type Libraries</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>

<font face="verdana,arial,helvetica" size="2"><h1><a name="interfacetypelibraries"></a>Interface Type Libraries</h1>
<BR>
Interface type libraries can be written either in Object Description Language (ODL) or in Interface Description Language (IDL). ODL is the language preferred by the Visual Basic group and they provide the MKTYPLIB compiler on the Visual Basic CD. IDL is the language preferred by the C++ group and they provide the MIDL compiler with their product. Both of these compilers are poorly documented and bedeviled by bugs, but I prefer the new bugs in MIDL to the old bugs in MKTYPLIB. Since this is a Visual Basic book, I won’t go very far into the details of IDL or ODL. If you have a little C background, you can learn a lot from examples and comments in the source to the Windows API type library, which is provided with this book. The CD also has an article about writing type libraries with ODL, but the emphasis is on API functions rather than interfaces.</p>
<BR>
To give you some idea of what I’m talking about, I’ll have to show part of the IDL source for IShellLink. You can see the whole thing in the SHLOBJ.IDL file on the CD:</p>
<pre><code>[   odl,<BR>    helpstring(“Visual Basic version of IShellLink interface”),<BR>#ifdef UNICODE<BR>    uuid(000214F9-0000-0000-C000-000000000046)<BR>#else<BR>    uuid(000214EE-0000-0000-C000-000000000046)<BR>#endif<BR>]<BR>interface IVBShellLink : IUnknown {<BR><BR>    [ helpstring(“Retrieves the path and filename … “) ]<BR>    HRESULT GetPath([in, out] LPTSTR pszFile,<BR>                    [in] int cchMaxPath,<BR>                    [in, out] LPVOID pfd,<BR>                    [in] ESLGP fFlags);<BR><BR>    [ helpstring(“Retrieves the list of … identifiers”) ]<BR>    HRESULT GetIDList([out, retval] LPITEMIDLIST * ppidl);<BR>    [ helpstring(“Sets the list of shell link item identifiers”) ]<BR>    HRESULT SetIDList([in] LPCITEMIDLIST pidl);<BR><BR>    [ helpstring(“Retrieves the … description string”) ]<BR>    HRESULT GetDescription([in, out] LPTSTR pszName,<BR>                           [in] int cchMaxName);<BR>    [ helpstring(“Sets the shell link description string”) ]<BR>    HRESULT SetDescription([in] LPCTSTR pszName);<BR><BR>    [ helpstring(“Retrieves the … working directory”) ]<BR>    HRESULT GetWorkingDirectory([in, out] LPTSTR pszDir,<BR>                                [in] int cchMaxPath);<BR>    [ helpstring(“Sets the … working directory”) ]<BR>    HRESULT SetWorkingDirectory([in] LPCTSTR pszDir);<BR><BR>    [ helpstring(“Retrieves the … command-line arguments”) ]<BR>    HRESULT GetArguments(LPTSTR pszArgs, int cchMaxPath);<BR>    [ helpstring(“Sets the … command-line arguments”) ]<BR>    HRESULT SetArguments([in] LPCTSTR pszArgs);<BR><BR>    [ propget, helpstring(“Retrieves or sets the … hot key”) ]<BR>    HRESULT Hotkey([out, retval] WORD *pwHotkey);<BR>    [ propput ]<BR>    HRESULT Hotkey([in] WORD wHotkey);<BR>    §<BR>    [ helpstring(“Resolves a shell link … “) ]<BR>    HRESULT Resolve([in] HWND hwnd,<BR>                    [in] ESLR fFlags);<BR><BR>    [ helpstring(“Sets the … path and filename”) ]<BR>    HRESULT SetPath([in] LPCTSTR pszFile);<BR>};</code></pre>
<BR>
This shows a few key parts of the interface. In real life, there’s no such thing as part of an interface. Every method and property must be present with parame&shy;ters of exactly the right size in exactly the right order. You must use the <i>uuid </i>attribute to provide the correct GUID, and you must derive the interface from either IUnknown or from an interface that derives from IUnknown. Don’t worry about what derive means; just use the syntax shown above. Once you meet those requirements, the rest can be lies.</p>
<BR>
My version of the interface lies about the method names and parameters. Just as we can lie with aliases in Declare statements, we can lie to improve interfaces. If you can get your hands on the original C header file SHLOBJ.H from which I created SHLOBJ.IDL, you can see what kind of whoppers I’m telling. For example, the official names of the Hotkey property Get and Let procedures are GetHotkey and SetHotkey, and normally they don’t have the propget and propset attributes because C and C++ don’t support properties. I’d like to turn GetDescription and SetDescription into properties, too, but because they use LPTSTR parameters for strings, the Get and Set must be different and can’t be converted to properties.</p>
<BR>
I’m also lying about some of the types. The WORD type used by the Hotkey property and the DWORD type used by the Resolve method are unsigned integers in the original interface, but I make them signed integers compatible with Visual Basic’s Integer and Long types by using alias features that you don’t really want to know about.</p>
<BR>
The IVBShellLink interface provides a template for defining the methods and properties of an imaginary class. A shell link file is just a binary file, and, theoretically, we could figure out its format and write the code to create and read such files. Also, we could use this code to implement the methods and properties of IVBShellLink. But Windows already implements this interface. We don’t need to reinvent the wheel; we just need some way to hook up the Windows implementation to our template. Here’s the type library syntax:</p>
<pre><code>[    uuid(00021401-0000-0000-C000-000000000046),<BR>    helpstring(“Visual Basic CShellLink class”)<BR>]<BR>coclass CShellLink {<BR>    [default]<BR>    interface IVBShellLink;<BR>};</code></pre>
<BR>
COM uses the term <i>coclass </i>to describe what Visual Basic calls a class. The Windows developers who created the system implementation of IShellLink gave it a magic GUID number starting with 00021401, and we can reuse their implementation by declaring a coclass with the magic number.</p>
<BR>
There’s one more piece to the puzzle. The Windows implementation of IShell&shy;Link depends on an interface called IPersistFile. You can look this one up in OAOBJ.IDL on the CD. We’ll only be dealing with its Load and Save methods.</p>
<BR>
<b>CHALLENGE</b>&#09;This should give you another piece of the COM language puzzle. When you create the CJumpStart class, Visual Basic <BR>creates a default interface named _CJumpStart with all the <BR>methods and properties you give your class. It creates a co&shy;-<BR>class named CJumpStart that implements the default interface. <BR>It generates hidden GUIDs for both the interface and the <BR>coclass and puts them in a hidden type library. Now you’re <BR>ready to write your own COM language that competes with <BR>Visual Basic.</p>
</font></BODY>
</HTML>
