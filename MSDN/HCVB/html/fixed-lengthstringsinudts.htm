<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Fixed-Length Strings in UDTs</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>

<font face="verdana,arial,helvetica" size="2"><h1><a name="fixed-lengthstringsinudts"></a>Fixed-Length Strings in UDTs</h1>
<BR>
A few Windows functions use structures (UDTs to Basic programmers) containing strings. This creates a problem because a Basic string in a Basic UDT differs somewhat from a C string in a C structure. I once made the foolish mistake of asserting on a Microsoft e-mail alias where Visual Basic is discussed that Basic programmers cannot use Windows structures containing strings. Take my word for it: don’t try to tell hardcore programmers what they can and cannot do. This was back in the old days when dealing with strings in the HLSTR format was more difficult, but even then the real hackers found a way.</p>
<BR>
In C, as in Basic, a structure can contain two types of strings. In Basic, the first type is called a fixed-length string; in C, it is called an array of characters. The WIN32_FIND_DATA type (used with FindFirstFile and friends) illustrates. It looks like this in C:</p>
<pre><code>typedef struct _WIN32_FIND_DATA {<BR>    DWORD    dwFileAttributes;<BR>    FILETIME ftCreationTime;<BR>    FILETIME ftLastAccessTime;<BR>    FILETIME ftLastWriteTime;<BR>    DWORD    nFileSizeHigh;<BR>    DWORD    nFileSizeLow;<BR>    DWORD    dwReserved0;<BR>    DWORD    dwReserved1;<BR>    TCHAR    cFileName[ MAX_PATH ]; // 260<BR>    TCHAR    cAlternateFileName[ 14 ];<BR>} WIN32_FIND_DATA;</code></pre>
<BR>
In Basic, it looks like this:</p>
<pre><code>Public Type WIN32_FIND_DATA<BR>    dwFileAttributes As Long<BR>    ftCreationTime As FILETIME<BR>    ftLastAccessTime As FILETIME<BR>    ftLastWriteTime As FILETIME<BR>    nFileSizeHigh As Long<BR>    nFileSizeLow As Long<BR>    dwReserved0 As Long<BR>    dwReserved1 As Long<BR>    cFileName As String * 260<BR>    cAlternateFileName As String * 14<BR>End Type</code></pre>
<BR>
No problem. The <i>cFileName</i> and <i>cAlternateFileName</i> fields work the same in both C and Basic. You can use them just the way you would expect:</p>
<pre><code>Dim fnd As WIN32_FIND_DATA<BR>hFind = FindFirstFile(“*.*&quot;, fnd)<BR>Debug.Print fnd.cFileName</code></pre>
<BR>
Of course, some additional work goes on in the background. Basic fixed-length strings are stored as Unicode, but they must be converted to ANSI when passed to API functions.</p>
<BR>
Unfortunately, the type library version of the WIN32_FIND_DATA works a little bit differently. Language-independent type libraries don’t know anything about Basic fixed-length strings. You have to define this structure to store the strings in byte arrays. You can check WINBASE.IDL on the companion CD to see how this is done in a type library. Here’s what it would look like if you coded the same type in Basic:</p>
<pre><code>Public Type WIN32_FIND_DATA<BR>    dwFileAttributes As Long<BR>§<BR>#If Unicode Then <BR>    cFileName(0 To 519) As Byte<BR>    cAlternateFileName(0 To 27) As Byte<BR>#Else<BR>    cFileName(0 To 259) As Byte<BR>    cAlternateFileName(0 To 13) As Byte<BR>#End If<BR>End Type</code></pre>
<BR>
In reality, you couldn’t use the Unicode version of such a type because you can’t write Unicode Declare statements (except with the hacks described in “Unicode API Functions,” page 86). But if you could (or if you used the type library version), using the data would look like this:</p>
<pre><code>Dim fnd As WIN32_FIND_DATA<BR>hFind = FindFirstFile(“*.*&quot;, fnd)<BR>If UnicodeTypeLib Then<BR>    Debug.Print fnd.cFileName<BR>Else<BR>    Debug.Print StrConv(fnd.cFileName, vbUnicode)<BR>End If</code></pre>
<BR>
The UnicodeTypeLib constant is defined with a value of zero in the ANSI version of the Windows API type library (WIN.TLB). It’s defined to nonzero in the Unicode version (WINU.TLB). Notice that the Unicode test is done at runtime. You could also define a Unicode constant in the IDE and test with #If rather than If. Although compile-time testing is faster, it wouldn’t work with the VBCore component that we’ll examine in Chapter 5. Having tests for the Unicode type library scattered throughout code would be ugly and difficult to maintain. Therefore, I hide the test in the BytesToStr wrapper function:</p>
<pre><code>Function BytesToStr(ab() As Byte) As String<BR>    If UnicodeTypeLib Then<BR>        BytesToStr = ab<BR>    Else<BR>        BytesToStr = StrConv(ab, vbUnicode)<BR>    End If<BR>End Function</code></pre>
<BR>
This lets me shorten the calling code:</p>
<pre><code>hFind = FindFirstFile(“*.*&quot;, fnd)<BR>Debug.Print BytesToStr(fnd.cFileName)</code></pre>
<BR>
The difference between fixed-length strings in type libraries and in Basic UDTs is annoying. Fortunately, Windows rarely uses fixed-length strings in structures. One solution is to write Declare statements and UDTs rather than the type <BR>library. Although easier and more familiar, this strategy works only for ANSI <BR>functions because Visual Basic doesn’t directly support Unicode Declare statements. For most users, this probably won’t be an issue, but in the long run I think Windows NT will be an important platform and Unicode will be the best way to target it. I use the type library solution consistently because it works for both kinds of strings.</p>
</font></BODY>
</HTML>
