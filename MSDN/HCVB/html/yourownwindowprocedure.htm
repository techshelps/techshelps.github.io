<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Your own window procedure</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>

<font face="verdana,arial,helvetica" size="2"><h1><a name="yourownwindowprocedure"></a>Your own window procedure</h1>
<BR>
Writing your own window procedure and hooking it up to a form or control window is a lot easier than juggling knives, but not much safer. The technique is known as subclassing a window. You simply replace the existing window procedure with your own. Usually your window procedure will identify and handle some specific messages, but defer other messages back to the original window procedure.</p>
<BR>
So let’s start by throwing a few knives. After we’ve caught them, we’ll look at some of the bad things that could have happened had we missed (as I did when writing this code). Here’s a window procedure for capturing the About menu item that we put on the system menu in the last section. You can see this code in TSYSMENU.VBP:</p>
<pre><code>Public procOld As Long<BR>Public Const IDM_ABOUT As Long = 1010<BR><BR>Public Function SysMenuProc(ByVal hWnd As Long, ByVal iMsg As Long, _<BR>                            ByVal wParam As Long, lParam As Long) As Long<BR>    ‘ Ignore everything but system commands<BR>    If iMsg = WM_SYSCOMMAND Then<BR>        ‘ Check for one special menu item<BR>        If wParam = IDM_ABOUT Then<BR>            MsgBox “Callback Test&quot;<BR>            Exit Function<BR>        End If<BR>    End If<BR>    ‘ Let old window procedure handle other messages<BR>    SysMenuProc = CallWindowProc(procOld, hWnd, iMsg, wParam, lParam)<BR>End Function</code></pre>
<BR>
This code goes in TSYSMENU.BAS. You might prefer to keep everything in the form module, but you can’t. Windows procedures, like other callback functions, must be in standard modules so that there will be one and only one copy. Anything that must be accessed by other modules, such as forms, must be public. This issue was summarized in “The Ultimate Hack: Procedure Pointers” in Chapter 2.</p>
<BR>
The code that attaches the window procedure can be in any module. This code is in the Form_Load procedure of TSYSMENU.FRM:</p>
<pre><code>‘ Install system menu window procedure<BR>procOld = SetWindowLong(hWnd, GWL_WNDPROC, AddressOf SysMenuProc)</code></pre>
<BR>
Here’s how you restore the old window procedure in Form_Unload:</p>
<pre><code>Call SetWindowLong(hWnd, GWL_WNDPROC, procOld)</code></pre>
<BR>
The first SetWindowLong installs the address of SysMenuProc as the window procedure for the form. Visual Basic has already provided a window procedure for the form, but we’re replacing it with our new window procedure. At the same time, we store the address of the old window procedure in <i>procOld. </i>Notice that the <i>procOld </i>variable is public so that it can be accessed by either the form or the window procedure. The form needs this variable to restore the old window procedure in Form_Unload. The window procedure needs it to pass off most of the work.</p>
<BR>
As soon as our window procedure, SysMenuProc, is installed, it starts getting messages at a furious pace—perhaps hundreds per second. But we care about only one message—WM_SYSCOMMAND. If you look up WM_SYSCOMMAND, you’ll see that it responds not only to system menu commands, but also to other menu commands, to accelerator commands, and to other situations that don’t concern us. But we care about only one command—IDM_ABOUT. This is the menu ID that we installed for our new About item in the last section. We could have a Select statement here and handle other menu commands, such as SC_MOVE, SC_SIZE, SC_MAXIMIZE, and SC_MINIMIZE. But we don’t want to. The form already knows how to do that stuff. If it’s our menu item, we handle it and exit. Otherwise, we pass it on.</p>
<BR>
The CallWindowProc API function lets us pass control back to the original window procedure, which knows how to do normal form processing. We let that procedure do its thing, and we receive its return value so that we can return it to whoever subclassed us. Keep in mind that you aren’t the only programmer in the world who might be subclassing your window. There might be a whole chain of subclassers, and you had better be a polite member of the chain.</p>
<BR>
Notice that the <i>lParam </i>parameter of the window procedure is ByRef, while all the others are ByVal. This is because the CallWindowProc API function is defined in the Windows API type library as taking a void * (equivalent to As Any by reference). So if CallWindowProc is receiving ByRef, then SysMenuProc had better also receive ByRef. You could change SysMenuProc to receive <i>lParam </i>ByVal, but if you did, you’d have to change how you pass <i>lParam </i>to Call&shy;WindowProc. For example, you could call like this:</p>
<pre><code>SysMenuProc = CallWindowProc(procOld, hWnd, iMsg, wParam, ByVal lParam)</code></pre>
<BR>
Either way works for SysMenuProc because the one menu message it handles doesn’t use <i>lParam</i>. The important thing is that you have to pass on exactly the same bits you receive. If you get your types mixed up, you’ll probably crash or hang instantly. You won’t be able to step through your code and find the bug. The compiler won’t warn you. You won’t be able to use Debug.Print. You won’t pass Go. You won’t collect $200. You won’t even go to jail. If you try to pass garbage on the stack several hundred times a second, you won’t be forgiven. <BR>I didn’t learn this from a textbook.</p>
</font></BODY>
</HTML>
