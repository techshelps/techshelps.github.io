<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Variable prefixes</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>

<font face="verdana,arial,helvetica" size="2"><h1><a name="variableprefixes"></a>Variable prefixes</h1>
<p>
Much of the confusion in current Hungarian variations comes from trying to make the prefix do too many conflicting things. At various times, I’ve seen the pre&shy;fix used to indicate several different concepts. Even if you don’t buy into Hungarian, any naming convention must deal with some of the following <BR>elements:
<ul>
<li>
<b>The purpose of the variable.</b>&nbsp;Is the variable used as a handle, a Boolean flag, a bit flag (an array of bits), an index, a count, an ordinal, a string, or an ID? Generally, this is the most useful piece of information you can provide, and it’s language independent. A handle is a handle, regardless of the language.<br><br></li>
<li>
<b>The data type of the variable.</b>&nbsp;This information is usually irrelevant because the data type is implied by the purpose. Furthermore, the data type is language specific. If you design your naming con&shy;vention for a language that supports signed and unsigned types (C and most variations of Pascal), the convention becomes irrelevant for languages that have only signed integers (Basic and FORTRAN). And if you use specific features of your language (such as C’s type&shy;def) to rename standard types, those names will be irrelevant in lang&shy;uages that don’t let you rename types (most languages). If you’re familiar with the Windows API, you’re sensing that I don’t think much of its naming conventions. Right you are. A good deal of Chapter 2 will be spent telling you how to translate these names into something intelligible to Basic. The naming conventions proposed here ignore the data type.<br><br></li>
<li>
<b>The context of the variable.</b>&nbsp;Generally, this means using a modifier indicating that the variable is in an array or a collection. Languages that support pointers require a modifier to distinguish a pointer to a variable from the variable itself. You can use a count modifier to indicate a count of variables. For example, if the modifier <i>h</i> is for a handle, <i>a</i> is for an array, <i>p</i> is for a pointer, and <i>c</i> is for a count, then you could have an <i>ah</i> (an array of handles), a <i>ph</i> (a pointer to a handle), or a <i>ch</i> (a count of handles).<br><br></li>
<li>
<b>The scope of the variable.</b>&nbsp;Some conventions clearly distinguish variables that are local, global, or somewhere in between (module-level in Visual Basic). Usually, local is assumed to be the default, requiring no modifier, and <i>g</i> is used as a prefix modifier for globals. <BR>You could use <i>m</i> as a prefix modifier for module-level variables (as the Visual Basic convention does). This isn’t a bad idea in principle, but in practice I don’t find it very useful. I don’t use globals often, and the distinction between local and module-level variables is usually clear from the context. Also, it would be easy to get carried away with distinguishing between static and normal locals or between fixed and dynamic arrays. You could go further and add prefix letters to distingish between ByVal and ByRef, to indicate the subtypes within variants, and to show whether the moon was full when the code was written.<br><br></li>
<li>
<b>The modifiability of the variable.</b>&nbsp;Many conventions distinguish constants from variables, usually by making constants all uppercase. <BR>I don’t find this distinction very useful. A constant can be identified when necessary by its name and the context. If <i>clr</i> is the prefix for a color, it’s pretty clear that <i>clrTitle</i> is a variable and <i>clrRed</i> is a constant. In addition, if you want to make the title red by assigning <i>clrRed</i> to <i>clrTitle</i>, it doesn’t make much difference whether <i>clrRed</i> is a variable or a constant.</li>
</ul>
<p>
What I’m creating here is a more portable Hungarian that works for Basic. I often don’t care what type a variable has when I use it; I’m much more interested in whether a handle is a handle to a window, a file, or a GDI object than in what data type it is. I use integers for different purposes: counts, indexes, handles, ordinals, and bit fields. Whether they are Longs or Integers usually doesn’t matter after the declaration. If I need to know, I can always go back to the declaration and check.</p>
<p>
The point of Hungarian is not to be an absolute standard for everyone but to be standard across a given department, project, program, or, in this case, book. I’ve used the conventions defined in Table 1-2 throughout (consistently, I hope).</p>
<p>
Some prefixes modify other prefixes. For example, <i>acmd</i> is an array of buttons, <i>ccmd</i> is a count of buttons, and <i>ncmd</i> is a collection of buttons. Strict Hungarian always uses <i>c</i> as a modifier. You could use <i>ciWindow</i> as a count of indexes to windows or <i>chWindow</i> as a count of handles to windows, but I often find that I can make the meaning clearer by omitting the second part of the prefix. If I’m counting windows, <i>cWindow</i> is sufficient.</p>
<p>
I’ll introduce and explain some additional conventions later in the book. In particular, some of the new object-oriented features of Visual Basic require further discussion and variations.</p>
<table>
<tr valign=top>
<td>
<b>Prefix</b></td>
<td>
<b>Variable or Object</b></td>
</tr>
<tr valign=top>
<td>
i </td>
<td>
integer index (type Integer or Long)</td>
</tr>
<tr valign=top>
<td>
h</td>
<td>
handle</td>
</tr>
<tr valign=top>
<td>
ord</td>
<td>
ordinal (a numeric identification code used when the specific value is unimportant except to distinguish the variable from others)</td>
</tr>
<tr valign=top>
<td>
x, y</td>
<td>
<i>x</i> and <i>y</i> coordinates of points</td>
</tr>
<tr valign=top>
<td>
dx, dy</td>
<td>
delta (or distance) in terms of <i>x</i> and <i>y</i> coordinates (<i>dx</i> is width, <i>dy</i> is height)</td>
</tr>
<tr valign=top>
<td>
f</td>
<td>
Boolean</td>
</tr>
<tr valign=top>
<td>
af</td>
<td>
bit flag (an array of Booleans represented by bits)</td>
</tr>
<tr valign=top>
<td>
r</td>
<td>
real number (either Single or Double)</td>
</tr>
<tr valign=top>
<td>
b</td>
<td>
Byte</td>
</tr>
<tr valign=top>
<td>
v</td>
<td>
Variant</td>
</tr>
<tr valign=top>
<td>
cur</td>
<td>
Currency</td>
</tr>
<tr valign=top>
<td>
time</td>
<td>
time</td>
</tr>
<tr valign=top>
<td>
date</td>
<td>
Date</td>
</tr>
<tr valign=top>
<td>
dt</td>
<td>
Date and time combined</td>
</tr>
<tr valign=top>
<td>
s</td>
<td>
String</td>
</tr>
<tr valign=top>
<td>
p</td>
<td>
pointer (Long variable from or for an API function)</td>
</tr>
<tr valign=top>
<td>
cmd</td>
<td>
button</td>
</tr>
<tr valign=top>
<td>
chk</td>
<td>
check box</td>
</tr>
<tr valign=top>
<td>
txt</td>
<td>
text box</td>
</tr>
<tr valign=top>
<td>
pb</td>
<td>
picture box</td>
</tr>
<tr valign=top>
<td>
pic</td>
<td>
picture</td>
</tr>
<tr valign=top>
<td>
lst</td>
<td>
list box</td>
</tr>
<tr valign=top>
<td>
cbo</td>
<td>
combo box</td>
</tr>
<tr valign=top>
<td>
lbl</td>
<td>
label</td>
</tr>
<tr valign=top>
<td>
mnu</td>
<td>
menu</td>
</tr>
<tr valign=top>
<td>
tmr</td>
<td>
timer</td>
</tr>
<tr valign=top>
<td>
opt</td>
<td>
option button (radio button)</td>
</tr>
<tr valign=top>
<td>
c</td>
<td>
count</td>
</tr>
<tr valign=top>
<td>
A</td>
<td>
array</td>
</tr>
<tr valign=top>
<td>
N</td>
<td>
collection</td>
</tr>
</table><br>
<p>
<b>Table 1-2.&nbsp;Hardcore Hungarian for variables.</b></p>
</font></BODY>
</HTML>
