<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Using the file information wrapper class</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>

<font face="verdana,arial,helvetica" size="2"><h1><a name="usingfileinformationwrapperclass"></a>Using the file information wrapper class</h1>
<BR>
The SHGetFileInfo function is complicated, in the typical API style. In other words, it’s un-Basic and needs some wrappers. I wrote my wrappers as a class named CFileInfo. As usual, let’s watch this class in action before we start to examine how it works.</p>
<BR>
The Windows Interface Tricks application (TWHIZ.VBP) demonstrates the information you can get and the operations you can perform on files. Figure 11-10 shows a frozen screen shot of the program, but to really get a feel for what you can do, you’ll have to run it. There’s a lot going on in this application; you’ll need to study the Win32 API Help to fully understand the functions.</p>
<BR><img src="f11te10.gif"></p><BR>
<b>Figure 11-10. File information and operations.</b></p>
<BR>
The following code from the program shows how to get the information displayed for the source file, including large and small icons in Image controls:</p>
<pre><code>Private Sub NewSource()<BR>With fiSrc<BR>    Dim s As String, sOld As String<BR>    On Error GoTo FailNewSource<BR>    sOld = fiSrc<BR>    ‘ Assign a file name to a file information object<BR>    fiSrc = txtSrc.Text<BR>    ‘ Get back all the information about the file<BR>    s = s &amp; “Display name: “ &amp; .DisplayName &amp; sCrLf<BR>    s = s &amp; “Type name: “ &amp; .TypeName &amp; sCrLf<BR>    s = s &amp; “Length: “ &amp; .Length &amp; “ bytes” &amp; sCrLf<BR>    s = s &amp; “Created: “ &amp; .Created &amp; sCrLf<BR>    s = s &amp; “Last modified: “ &amp; .Modified &amp; sCrLf<BR>    s = s &amp; “Last accessed: “ &amp; .Accessed &amp; sCrLf<BR>    lblSrc.Caption = s<BR>    Set imgLIcon.Picture = .ShellIcon()<BR>    Set imgSIcon.Picture = .SmallIcon()<BR>    Set imgLIconSel.Picture = .ShellIcon(SHGFI_SELECTED)<BR>    Set imgSIconSel.Picture = .SmallIcon(SHGFI_SELECTED)<BR>    Set imgLIconLink.Picture = .ShellIcon(SHGFI_LINKOVERLAY)<BR>    Set imgSIconLink.Picture = .SmallIcon(SHGFI_LINKOVERLAY)<BR>    §</code></pre>
<BR>
That example shows one side of the CFileInfo class, but the default Item property is actually a Variant. You can pass it a string file name as shown above, or you can pass it an integer representing an item in the shell name space. The shell name space is the organization of icons you see in the Explorer under Windows 95 and Windows NT. The idea is to represent everything used by your computer, not just files, in a hierarchical structure. I’ll take a closer look at this new way of organizing data shortly.</p>
<BR>
For now, notice the UpDown control (upper right corner of the screen in Figure 11-10) that lets you select a special folder location. You can cycle through constants representing special folder locations. The most interesting are CSIDL&shy;_BITBUCKET (Recycle Bin), CSIDL_DESKTOP (Desktop), and CSIDL_DRIVES (My Computer). The following code gets the information for a special folder location:</p>
<pre><code>Private Sub NewSpecialFolder(ByVal iInc As Long)<BR>    Do<BR>        On Error Resume Next<BR>        fiFolder = udSpecLoc                ‘ Folder to CFileInfo object<BR>        If Err = 0 Then Exit Do<BR>        udSpecLoc.Value = udSpecLoc + iInc  ‘ Skip missing numbers<BR>        ‘ Wrap property doesn’t work on assignment<BR>        If udSpecLoc = udSpecLoc.Min Then udSpecLoc = udSpecLoc.Max<BR>        If udSpecLoc = udSpecLoc.Max Then udSpecLoc = udSpecLoc.Min<BR>    Loop<BR>    lblSpecLoc.Caption = “Special folder: “ &amp; fiFolder.DisplayName<BR>    imgLSpecLoc = fiFolder.ShellIcon<BR>    imgSSpecLoc = fiFolder.SmallIcon<BR>End Sub</code></pre>
<BR>
Some values in the range of special folder constants are invalid, so the code has to cycle through until it finds an acceptable constant.</p>
<BR>
You can also get information from a CFileInfo object by assigning it a data structure called a PIDL, which you receive from the shell name space. A PIDL is actually a pointer stored in a Long. But that’s another story—unfortunately, a horror story.</p>
<h2><a name="wrappingupfileinformation"></a>Wrapping up file information</h2>
<BR>
Most of the work of creating a CFileInfo object (FILEINFO.CLS) is done in the Item property Let procedure of the class. Item is the default property so that you can create a new object by assigning a file name, a special folder, or a PIDL to the object. The code in this procedure is a wrapper for the FindFirstFile and SHGetFileInfo API functions. It will get all the information it can about the file and store it in the following private variables:</p>
<pre><code>Private Enum EItemState<BR>    eisNotCreated<BR>    eisFile                     ‘ File or directory<BR>    eisDrive                    ‘ Drive<BR>    eisID                       ‘ PIDL passed to us<BR>    eisFolder                   ‘ PIDL created by us from special folder<BR>End Enum<BR>Private eis As EItemState       ‘ How object was created<BR>Private vItem As Variant        ‘ File name or PIDL<BR>Private shfi As SHFILEINFO      ‘ Info from SHGetFileInfo<BR>Private fd As WIN32_FIND_DATA   ‘ Info from FindFirstFile<BR>Private afAttr As Long          ‘ File attributes<BR>Private afOption As Long        ‘ Options for SHGetFileInfo</code></pre>
<BR>
SHGetFileInfo is one of those multipurpose functions that tries to do too many things at once, but ends up not doing enough. You pass it a structure and any combination of 15 different flags. It looks at all the flags to determine what to return in the structure. Even with all of that, it doesn’t return all the &shy;information you might need and you have to call FindFirstFile to get additional information.</p>
<BR>
Here’s the code to analyze what kind of item is being created and to set up all the necessary options and make the appropriate API calls:</p>
<pre><code>Property Let Item(vItemA As Variant)<BR>    Dim h As Long, f As Long, af As Long<BR>    Destroy     ‘ Clear any previous assignment<BR>    If VarType(vItemA) = vbString Then<BR>        ‘ String item is a file, directory, or drive<BR>        If Len(vItemA) &lt;= 3 And Mid$(vItemA, 2, 1) = “:” Then<BR>            ‘ Must be drive, get attributes<BR>            afAttr = 0: afOption = 0<BR>        Else<BR>            ‘ No terminating backslashes<BR>            MUtility.DenormalizePath vItemA<BR>            ‘ For file, get information in advance<BR>            h = FindFirstFile(vItemA, fd)<BR>            If h = hInvalid Then ApiRaise Err.LastDllError<BR>            FindClose h<BR>            afAttr = fd.dwFileAttributes<BR>            afOption = SHGFI_USEFILEATTRIBUTES<BR>        End If<BR>        eis = eisFile<BR>        af = afOption And (Not SHGFI_PIDL) Or _<BR>             SHGFI_DISPLAYNAME Or SHGFI_TYPENAME<BR>        f = SHGetFileInfo(vItemA, afAttr, shfi, LenB(shfi), af)<BR>    Else<BR>        ‘ Integer item is a special folder constant or pidl<BR>        If vItemA &lt; 50 Then<BR>            ‘ Turn special folder location into a pidl<BR>            Dim pidl As Long<BR>            SHGetSpecialFolderLocation 0, CLng(vItemA), pidl<BR>            vItemA = pidl<BR>            eis = eisFolder<BR>        Else<BR>            eis = eisID<BR>            pidl = vItemA<BR>        End If<BR>        ‘ For special folders or other PIDLs, everything comes from system<BR>        afAttr = 0: afOption = 0<BR>        ‘ Get item ID pointer, but don’t use attributes<BR>        af = SHGFI_PIDL Or SHGFI_DISPLAYNAME Or _<BR>             SHGFI_TYPENAME<BR>        f = SHGetItemInfo(pidl, afAttr, shfi, Len(shfi), af)<BR>    End If<BR>    If f Then<BR>        vItem = vItemA<BR>    Else<BR>        eis = eisNotCreated<BR>    End If<BR>End Property</code></pre>
<BR>
This code follows several different paths, but ultimately it comes down to either calling SHGetFileInfo for a file object or calling SHGetItemInfo for a PIDL object. These are both aliases for the SHGetFileInfo function, but the Windows API type library offers versions that take a different type for the first parameter. In C++, a string is a pointer and a PIDL is a pointer, so with the appropriate typecasting, you can pass either one in the same parameter. That’s not such a good idea in Visual Basic (and I don’t think much of it in C++ either).</p>
<BR>
The GetFileItemInfo function takes a Variant parameter and determines from the Variant type which API alias to call. Most of the CFileInfo methods call GetFile&shy;ItemInfo to get additional information about a file. For example, here’s the SmallIcon method:</p>
<pre><code>Function SmallIcon(Optional afOverlay As Long = 0) As Picture<BR>    Dim shfiT As SHFILEINFO<BR>    If eis = eisNotCreated Then Exit Function<BR>    ' Filter out any invalid flags -- only overlays allowed<BR>    afOverlay = afOverlay And (SHGFI_LINKOVERLAY Or SHGFI_SELECTED _<BR>                               Or SHGFI_OPENICON)<BR>    ' Add in standard and small icon flags<BR>    afOverlay = afOverlay Or afOption Or SHGFI_ICON Or SHGFI_SMALLICON<BR>    GetFileItemInfo vItem, shfiT, afOverlay, afAttr<BR>    Set SmallIcon = MPicTool.IconToPicture(shfiT.hIcon)<BR>End Function</code></pre>
<BR>
The <i>afOverlay</i> parameter allows you the option of specifying whether the standard icon will appear selected, as a shortcut, or open. The open overlay isn’t really an overlay; it’s a completely different icon indicating that a folder is open. The open flag is ignored for files, which don’t have a separate icon for the open state.</p>
<p>
You can probably guess the implementation of the Length, Created, Modified, and Accessed methods, which use data received from the call to FindFirstFile. There’s a lot more detail to the CFileInfo class. For example, it also handles drives and supplies appropriate drive data in properties—but I’ll leave you to struggle through that yourself.</p>
<p>
SHGetFileInfo retrieves additional data not used in the CFileInfo class. For example, large and small icons used by the system are maintained in two internal ImageLists. Unfortunately, the Visual Basic ImageList control doesn’t give you a way to use them. It’s possible to iterate through the system ImageList control directly by using ImageList API functions with SHGetFileInfo. This technique is illustrated in the Windows Interface Tricks application. It turned out to be a dead end, however; I couldn’t find anything useful to do with system ImageLists in Visual Basic that couldn’t be done more easily without them.</p>
</font></BODY>
</HTML>
