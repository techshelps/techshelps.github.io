<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>A Basic Cwindow Class</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>

<font face="verdana,arial,helvetica" size="2"><h1><a name="abasiccwindowclass"></a>A Basic CWindow class</h1>
<BR>
WinWatch looks at windows from the outside and must do things the Windows Way, not the Basic Way. But this was a choice, not a requirement. It’s not impossible to access window features in an object-oriented way; all you need is a CWindow class written in Visual Basic. I actually wrote this class, but WinWatch doesn’t use it. Sometimes the functional philosophy is more convenient than the object religion.
</p>
<BR>
You might find it amusing to check out CWindow on the companion CD, in the TWINDOW.VBP project. This class might even work for some of your projects. I’ll describe the design, but frankly, I wrote CWindow more to show that it could be done than as a practical tool. It simply wraps the more common API functions related to windows in a thin layer.
</p>
<BR>
CWindow has only one private member variable, <i>hWnd</i>. You initialize this internal variable using the Handle property, but you don’t have to use the name <i>Handle</i> because it is the default property:</p>
<pre><code>Dim wnd As New CWindow<BR>wnd = Me.hWnd</code></pre>
<BR>
You can also initialize the object with one of a variety of Create methods:</p>
<pre><code>wnd.CreateFromPoint x, y                      ‘ WindowFromPoint<BR>wnd.CreateFromFind “MyClass&quot;, “My Title”      ‘ FindWindow<BR>wnd.CreateFromActive                          ‘ GetActiveWindow</code></pre>
<BR>
Once you initialize the object, you can get and read properties or call methods:</p>
<pre><code>wnd.Caption = “My Title”                      ‘ GetWindowText<BR>wnd.Capture True                              ‘ SetCapture<BR>wnd.Capture False                             ‘ ReleaseCapture<BR>sClass = wnd.ClassName                        ‘ GetClassName</code></pre>
<BR>
Most of these methods and properties have one-line implementations. Here are a couple to give you the idea:</p>
<pre><code>Private hWnd As Long<BR>Public Property Get Handle() As Long<BR>    Handle = hWnd<BR>End Property<BR><BR>Public Property Let Handle(ByVal hWndA As Long)<BR>    If IsWindow(hWndA) Then hWnd = hWndA Else hWnd = hNull<BR>End Property</code></pre>
<BR>
I started writing new methods and properties as fast as I could type them, but I gave up after a while because I could see that the class wasn’t going to be much use. Feel free to finish the implementation. You can see my first cut in Figure 6-2 on the following page.</p>
<BR>
The problem with CWindow is that it adds a layer of complication and inefficiency without offering much advantage. For example, imagine that you have some code that retrieves a window handle and then uses it to get some data about the window. Which of the following is easier?</p>
<pre><code>With wnd<BR>    f = .CreateFromFind(“SciCalc”)<BR>    fVisible = .Visible<BR>    sTitle = .Caption<BR>    idProc = .ProcID<BR>End With</code></pre>
<BR><img src="f06te02.gif"></p>
<BR>
<b>Figure 6-2. First draft of the CWindow class.</b></p>
<BR>
And here’s the alternative:</p>
<pre><code>hWnd = FindWindow(“SciCalc”)<BR>fVisible = IsWindowVisible(hWnd)<BR>sTitle = WindowTextFromWnd(hWnd)<BR>idProc = ProcIDFromWnd(hWnd)</code></pre>
<BR>
Either way, you must write the declarations for the Windows API functions and wrap un-Basic functions in Visual Basic wrappers (as you’ll see later). But you’re doing the same work—just packaging it differently.</p>
</font></BODY>
</HTML>
