<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Using Version Data</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>

<font face="verdana,arial,helvetica" size="2"><h1><a name="usingversiondata"></a>Using Version Data</h1>
<p>
I was once foolish enough to write what must have been the most complicated batch file ever to ship with a commercial product. I speak of the disastrous MASM 5.0 SETUP.BAT, powered by the infamous batch utility WHAT.EXE. I won’t lead you through that sad history (except to note that writing polite batch files is harder than programming in assembler). But I would like to mention the batch file versioning problems I experienced with early versions of MS-DOS, since they relate to version problems we still suffer with Visual Basic.</p>
<p>
In those days, a new MS-DOS version (and operating systems that emulated it) seemed to come out every few months, each with a different undocumented trick for displaying a blank line in a batch file. In some versions, two spaces following the ECHO command did the job. In others, you had to use a text editor that let you insert the ASCII character 0 or 255 after ECHO. The current method (ECHO followed immediately by a dot) didn’t work in early versions.</p>
<p>
You might have hoped to escape such problems in Windows and Visual Basic, but version differences remain the bane of all those who program for Windows. You’ll still find controls and DLLs that change their interface in a fashion that seems as random as the MS-DOS batch language. If your system seems to crash in unexpected ways, chances are good that somehow you’re running an outdated version of a DLL or a control you didn’t even know you had.</p>
<p>
Fortunately, Windows 3.1 added resources for embedding version data in your programs and an API for finding version information in other programs. The same system is used in 32-bit Windows. That’s why you’ll see a version resource in every polite 32-bit executable file (EXE or DLL). Although version data are stored as resources, you don’t use the normal resource system to access them. Instead, you pass the filename of the file to be examined and then use a series of complicated API calls to extract the data. The whole process is so Byzantine that it really needs to be wrapped in a user-friendly package—such as my CVersion class.</p>
</font></BODY>
</HTML>
