<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Recursive QuickSort</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>

<font face="verdana,arial,helvetica" size="2"><h1><a name="recursivequicksort"></a>Recursive QuickSort</h1>
<BR>
The following QuickSort algorithm for sorting arrays is taken directly from the SORTDEMO program, with only slight modifications to make it more modular and to accommodate differences between Visual Basic and QuickBasic:</p>
<pre><code>‘ Recursive QuickSort algorithm<BR>Sub SortArrayRec(aTarget() As Variant, _<BR>                 Optional vFirst As Variant, Optional vLast As Variant, _<BR>                 Optional helper As ISortHelper)<BR>    Dim iFirst As Long, iLast As Long<BR>    If IsMissing(vFirst) Then iFirst = LBound(aTarget) Else iFirst = vFirst<BR>    If IsMissing(vLast) Then iLast = UBound(aTarget) Else iLast = vLast<BR>    If helper Is Nothing Then Set helper = New CSortHelper<BR>    <BR>With helper<BR>    If iFirst &lt; iLast Then<BR><BR>        ‘ Only two elements in this subdivision; exchange if<BR>        ‘ they are out of order, and end recursive calls<BR>        If iLast - iFirst = 1 Then<BR>            If .Compare(aTarget(iFirst), aTarget(iLast)) &gt; 0 Then<BR>                .Swap aTarget(iFirst), aTarget(iLast)<BR>            End If<BR>        Else<BR><BR>            Dim iLo As Long, iHi As Long<BR>            ‘ Pick pivot element at random and move to end<BR>            .Swap aTarget(iLast), aTarget(MRandom.Random(iFirst, iLast))<BR>            iLo = iFirst: iHi = iLast<BR>            Do<BR><BR>                ‘ Move in from both sides toward pivot element<BR>                Do While (iLo &lt; iHi) And _<BR>                         .Compare(aTarget(iLo), aTarget(iLast)) &lt;= 0<BR>                    iLo = iLo + 1<BR>                Loop<BR>                Do While (iHi &gt; iLo) And _<BR>                         .Compare(aTarget(iHi), aTarget(iLast)) &gt;= 0<BR>                    iHi = iHi - 1<BR>                Loop<BR><BR>                ‘ If you haven’t reached pivot element, it means<BR>                ‘ that two elements on either side are out of<BR>                ‘ order, so swap them<BR>                If iLo &lt; iHi Then .Swap aTarget(iLo), aTarget(iHi)<BR>            Loop While iLo &lt; iHi<BR><BR>            ‘ Move pivot element back to its proper place<BR>            .Swap aTarget(iLo), aTarget(iLast)<BR><BR>            ‘ Recursively call SortArrayRec (pass smaller<BR>            ‘ subdivision first to use less stack space)<BR>            If (iLo - iFirst) &lt; (iLast - iLo) Then<BR>                SortArrayRec aTarget(), iFirst, iLo - 1, helper<BR>                SortArrayRec aTarget(), iLo + 1, iLast, helper<BR>            Else<BR>                SortArrayRec aTarget(), iLo + 1, iLast, helper<BR>                SortArrayRec aTarget(), iFirst, iLo - 1, helper<BR>            End If<BR>        End If<BR>    End If<BR>End With<BR>End Sub</code></pre>
<BR>
For the moment, ignore the helper object parameter and concentrate on the algorithm. QuickSort works on the divide-and-conquer principle. It splits the array into two groups and then sorts both the top and the bottom. It does this by calling itself to sort each group. Recursion makes QuickSort intelligible but also subjects it to stack limitations. A recursive algorithm has the potential to run out of stack space as it pushes more arguments and local variables onto the stack each time it calls itself.</p>
</font></BODY>
</HTML>
