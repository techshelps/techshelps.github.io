<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Initializing Standard Module Variables</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>

<font face="verdana,arial,helvetica" size="2"><h1><a name="initializingstandardmodulevariables"></a>Initializing Standard Module Variables</h1>
<BR>
Initializing variables in standard modules is a little trickier. It would be nice to have a Module_Initialize event in which you could initialize internal values, but since there isn’t one, you have to do some hacking to initialize variables with the static variable technique described earlier.</p>
<BR>
You might be laboring under the misconception that Visual Basic doesn’t support global initialized variables in standard modules. Not so. Property procedures make it easy, if not obvious. Normally, I think of properties as being attached to forms and classes, but no rule says that a property has to be tied to an object. For example, here’s a global variable, <i>cLastWindow, </i>initialized to 20:</p>
<pre><code>Private fNotFirstTime As Boolean<BR>Private cLastWindowI As Integer<BR>§<BR>Public Property Get cLastWindow() As Integer<BR>    If Not fNotFirstTime Then <BR>        fNotFirstTime = True<BR>        cLastWindowI = 20<BR>    End If<BR>    cLastWindow = cLastWindowI<BR>End Property<BR><BR>Property Let cLastWindow(cLastWindowA As Integer)<BR>    fNotFirstTime = True<BR>    cLastWindowI = cLastWindowA<BR>End Property</code></pre>
<BR>
You can use this property from anywhere, just like any other global variable:</p>
<pre><code>For i = 1 To cLastWindow<BR>    WipeWindow i <BR>Next<BR>cLastWindow = cLastWindow - 1</code></pre>
<BR>
Users of your standard module needn’t be the wiser about how you wrote it, especially if you hide it in a DLL so that no one can see the source.</p>
<BR>
If your standard module contains several variables that need to be initialized, you can write your own Module_Initialize routine. Call it from every procedure that uses one of the variables:</p>
<pre><code>If Not fNotFirstTime Then Module_Initialize</code></pre>
<BR>
This might not be as efficient as you’d like. Testing for <i>fNotFirstTime </i>all over the place is no fun, but the test is True only once. Don’t forget to initialize <i>fNotFirstTime </i>along with the other variables.</p>
<BR>
A property with a Property Get but no Property Let or Property Set acts like a read-only variable—otherwise known as a constant. Let’s take my favorite constant, <i>sCrLf</i>. It’s simply a string consisting of a carriage return and a linefeed. You can’t define it with Const because it has two control characters, which must be tied together with the concatenation operator (&amp; or +). Visual Basic (unlike every other language I’ve encountered) doesn’t allow control characters in constants, even though Chr$(13) and the concatenation operator could easily be evaluated by the compiler at design time.</p>
<BR>
The following solution isn’t really necessary, because Visual Basic provides <i>vbCrLf </i>and the Windows API type library provides <i>sCrLf</i>.<i> </i>But if you didn’t have a type library with the constant, you could define your own in a standard module this way:</p>
<pre><code>Public Property Get sCrLf() As String<BR>    Static s As String<BR>    If s = sEmpty Then s = Chr$(13) &amp; Chr$(10)<BR>    sCrLf = s<BR>End Property</code></pre>
</font></BODY>
</HTML>
