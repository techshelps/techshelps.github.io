<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Using Vectors</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>

<font face="verdana,arial,helvetica" size="2"><h1><a name="usingvectors"></a>Using Vectors</h1>
<BR>
Before Collections, Visual Basic programmers used to get around the array size problem by resizing arrays in chunks. My CVector class uses the chunk technique but hides the ugly details.</p>
<BR>
As usual, I’ll show you what you can do with a CVector before I show you how it works. Here’s a typical initialization loop:</p>
<pre><code>Dim vector As New CVector, i As Long, s As String<BR>s = “Insert numbers in vector: “ &amp; sCrLf<BR>For i = 1 To 15<BR>    vector(i) = i * i<BR>    s = s &amp; Space$(4) &amp; i * i &amp; “: vector(“ &amp; i &amp; “)” &amp; sCrLf<BR>Next</code></pre>
<BR>
Vectors can grow to whatever size you want. Just keep adding more elements, and the vector automatically adjusts.</p>
<BR>
Notice that the vectors are one-based. That’s a design choice. I could have started them at 0 or <font face="Symbol"><span style="font-family:symbol">&#45;</span></font>1 or 5. In an early implementation, I started them at 0 but often used them as if they started at 1. Since vectors always waste space, I felt wasting that extra 0 element wasn’t a big deal. But with use, I discovered that ignoring that extra element wasn’t such a good idea. If you like negative vectors, go ahead, but you’ll end up with a different class with different implementation problems.</p>
<BR>
Don’t worry about inserting elements far beyond the end of the array. That works. You can even initialize from the top down:</p>
<pre><code>For i = 100 To 1 Step -1<BR>    vv(i) = i * i<BR>Next</code></pre>
<BR>
Normally, you’ll want to read only the elements that have been initialized:</p>
<pre><code>s = s &amp; “Read numbers from vector: “ &amp; sCrLf<BR>For i = 1 To vector.Last<BR>    s = s &amp; Space$(4) &amp; “vector(“ &amp; i &amp; “) = “ &amp; vector(i) &amp; sCrLf<BR>Next</code></pre>
<BR>
The vector keeps track of the last element to be initialized and reports it through the Last property.</p>
<BR>
CVector addresses the problem of growing arrays, but what about shrinking arrays? Well, it is possible to shrink the vector by setting the Last property:</p>
<pre><code>s = s &amp; “Shrink vector to 5 and read numbers: “ &amp; sCrLf<BR>vector.Last = 5<BR>For i = 1 To vector.Last<BR>    s = s &amp; Space$(4) &amp; “vector(“ &amp; i &amp; “) = “ &amp; vector(i) &amp; sCrLf<BR>Next<BR><BR>s = s &amp; “Read numbers with For Each: “ &amp; sCrLf<BR>Dim v As Variant<BR>For Each v In vector<BR>    s = s &amp; Space$(4) &amp; “v = “ &amp; v &amp; sCrLf<BR>Next</code></pre>
<BR>
If you shrink the vector, all the elements beyond the new Last get thrown into the bit bucket. Expanding the vector to the original size won’t bring them back, and there’s no way to delete entries in the middle of the vector. As with arrays, entries stay exactly where you put them unless you move them.</p>
<BR>
If this looks too good to be true, well, there is a cost—and it’s one that experienced programmers know well. You spend data space to get better performance.</p>
</font></BODY>
</HTML>
