<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>32-Bit Windows Operating System Interface-Based Client</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h3><a name="_bkopr_32_bit_windows_operating_system_interface_based_client"></a>32-Bit Windows Operating System Interface-Based Client</h3>
<p>
With the release of Windows NT and Windows 95 as 32-bit operating systems, there now exists the potential to create powerful 32-bit-based client applications. The Win32 API provides a unified development API on the Windows NT and Windows 95 operating systems, allowing a single set of source code to be used on multiple platforms (Intel-based, MIPS, Alpha AXP, PowerPC). By taking advantage of the Win32 API, a client application can use the following features.</p>
<p>
<b>Structured Exception Handling </b></p>
<p>
Structured termination handling ensures that whenever a guarded body of code is executed, a specified block of termination code is also executed, regardless of how the flow of control leaves the guarded body. Structured exception handling is made available to developers primarily through compiler support. For example, the Microsoft compilers provided with the Platform SDK support the <b>try</b> keyword that identifies a guarded body of code, and the <b>except</b> and <b>finally</b> keywords that identify an exception handler and a termination handler, respectively.</p>
<p>
<b>The Registry</b></p>
<p>
The registry is used for storing and retrieving configuration data on a per-user, per-machine, and per-application basis. Because the data is stored in a binary format, an application must use the registry functions to manipulate the registry. The registry stores data in a hierarchically-structured tree with each node in the tree called a <i>key</i>. Each key can contain both subkeys and data entries called <i>values</i>.</p>
<p>
<b>Multitasked Thread Support</b></p>
<p>
To the developer, multitasking thread support offers the ability to create applications that use more than one process and to create processes that use more than one thread of execution. It is useful for a process to have multiple threads in situations where the application has several tasks to run concurrently. Multiple threads can be a convenient way to structure a program that performs several similar or identical tasks, and can be especially beneficial to server applications in the following cases: 
<ul>
<li>
<b>For communications-bound tasks</b>. The portion of a server application that provides services to clients should be implemented in one or more threads separate from the portion of the application that performs processing on behalf of the client or that connects to an auxiliary process.</li>
<li>
<b>For tasks within a system of varying priority</b>. The portion of a server application devoted to CPU-intensive tasks should be implemented using different threads from the portions devoted to I/O-intensive tasks to ensure that higher-priority tasks receive scheduling preference.</li>
</ul>
<p>
<b>Synchronization</b></p>
<p>
To coordinate multiple threads of execution, synchronization mechanisms, such as wait functions and synchronization objects, and overlapped input and output (I/O) operations are provided. Synchronization objects have handles that can be specified in one of the wait functions to coordinate the execution of multiple threads. Objects include events for notification, mutexes for mutually exclusive access to shared resources, and semaphores for limiting the number of threads that may simultaneously access a shared resource. Wait functions enable a thread to block its own execution. These functions do not return until a set of conditions specified by the wait function's parameters (time-out interval and handles of one or more synchronization objects) are satisfied.</p>
<p>
<b>Event Logging</b></p>
<p>
Event logging provides a common repository for recording software and hardware events, as well as an interface with which to view them. Logging consumes resources: disk space and logging time. The event log is not intended to be used as a trace facility. You should log information about events that can be used to diagnose problems after they have occurred. Logging low-memory conditions, for example, can provide information about a problem that the system administrator can solve by adding more memory to the computer. </p>
<p>
<b>Performance Monitoring</b></p>
<p>
Performance Monitor provides a mechanism for developers to add performance objects and counters for their applications and other software components, so that they can provide performance data to Windows NT Performance Monitor or to your customized performance monitoring programs. To add performance counters to the system, you must create an extended object. Your extended object is called when Performance Monitor collects data.</p>
<p>&nbsp;</p></body>
</HTML>
