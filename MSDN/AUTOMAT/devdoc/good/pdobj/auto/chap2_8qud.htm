<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>"Hello World" Sample</title>
<link disabled rel=stylesheet href=../../../backsdk3.css>
<style type="text/css">
@import url(../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_oa96_hello_world_sample"></a>"Hello" Sample</h1>
<p>
The Hello sample is an Automation application with one object. It has these characteristics:
<ul>
<li>
Supports VTBL binding.</li>
<li>
Permits multiple instances of its exposed object to exist at the same time.</li>
<li>
Implements <b>IErrorInfo </b>for exception handling.</li>
</ul>
<p>
This sample has been simplified for demonstration purposes. It has the following limitations:
<ul>
<li>
Has only one object.</li>
<li>
Uses only scalar argument types. Automation also supports methods and properties that accept arguments of complex types, including arrays, references to objects, and formatted data, but not structures.</li>
<li>
Supports one national language.</li>
</ul>
<p>
The sections that follow demonstrate how the Hello sample exposes a simple class. The code is abridged to illustrate the essential parts. For a complete listing, see the source code in the <i>OLE Programmer's Reference</i> in the Win32 SDK.</p>

<h4><a name="_oa96_initializing_ole"></a>Initializing OLE</h4>
<p>
When the Hello application starts, it initializes OLE and then creates the object to be exposed through Automation. For example (Main.cpp):</p>
<pre><code>BOOL InitInstance (HINSTANCE hinst)
{
    HRESULT hr;
    TCHAR ach[STR_LEN]; 

    // Intialize OLE.
    hr = OleInitialize(NULL);
    if (FAILED(hr))
        return FALSE;

    // Create an instance of the Hello Application object. The object is
    // created with refcount 0.
    LoadString(hinst, IDS_HelloMessage, ach, sizeof(ach));
    hr = CHello::Create(hinst, ach, &amp;g_phello);
    if (FAILED(hr))
        return FALSE;
    return TRUE;
}
 </code></pre>
<p>
This function calls <b>OleInitialize</b> to initialize OLE. It loads the string <code>ach</code> with the initial Hello message, obtained from the string table through the constant <code>IDS_HelloMessage</code>. Then it calls <code>CHello::Create</code> to create a single, global instance of the application object, passing it the initial Hello message and receiving a value for <code>g_phello</code>, a pointer to the instance. If the function is successful, it returns a value of <b>True</b>.</p>

<h4><a name="_oa96_registering_the_active_object"></a>Registering the Active Object</h4>
<p>
After Hello creates an instance of the object, it exposes and registers the class factory (if necessary) and registers the active object (Main.cpp):</p>
<pre><code>BOOL ProcessCmdLine(LPSTR pCmdLine, 
                    LPDWORD pdwRegisterCF, 
                    LPDWORD pdwRegisterActiveObject, 
                    int nCmdShow)
{
    LPCLASSFACTORY pcf = NULL;
    HRESULT hr;

    *pdwRegisterCF = 0;
    *pdwRegisterActiveObject = 0;

    // Expose class factory for application object if command line
    // contains the /Automation switch.
    if (_fstrstr(pCmdLine, "-Automation") != NULL
        || _fstrstr(pCmdLine, "/Automation") != NULL)
    {
        pcf = new CHelloCF;
        if (!pcf)
            goto error;
        pcf-&gt;AddRef();
        hr = CoRegisterClassObject(CLSID_Hello, pcf,
                                    CLSCTX_LOCAL_SERVER,
                                    REGCLS_SINGLEUSE,
                                    pdwRegisterCF);
        if (hr != NOERROR)
            goto error;
        pcf-&gt;Release();
    }
    else g_phello-&gt;ShowWindow(nCmdShow); //Show if started stand-alone.

RegisterActiveObject(g_phello, CLSID_Hello, ACTIVEOBJECT_WEAK,
                    pdwRegisterActiveObject);
    return TRUE;

error:
    if (!pcf)
        pcf-&gt;Release();
    return FALSE;
}
 </code></pre>
<p>
The sample first checks the command line for the <b>/Automation </b>switch. This switch indicates that the application should be started for programmatic access, so that ActiveX clients can create additional instances of the application's class. In this case, the class factory must be created and registered. If the switch is present, the Hello sample creates a new <code>CHelloCF</code> object and calls its <b>AddRef </b>method, thereby creating the class factory.</p>
<p>
Next, the sample calls <b>CoRegisterClassObject</b> to register the class factory. It passes the object's CLSID (<code>CLSID_Hello</code>), a pointer to the <code>CHelloCF</code> object (<code>pcf</code>), and two constants (CLSCTX_LOCAL_SERVER and REGCLS_SINGLEUSE) that govern the class factory's use. 
<ul>
<li>
CLSCTX_LOCAL_SERVER indicates that the executable code for the object runs in a separate process space from the controller. </li>
<li>
REGCLS_SINGLEUSE allows only one ActiveX client to use each instance of the class factory. The value returned through <code>pdwRegisterCF </code>must later be used to revoke the class factory. </li>
</ul>
<p>
The example specifies weak registration (<code>ACTIVEOBJECT_WEAK</code>), which means that OLE will release the object when all external connections to it have disappeared. You should always give ActiveX objects weak registration. For more information, see "<a href="chap5_2k38.htm">RegisterActiveObject</a>" in Chapter 5, "<a href="chap5_5t9v.htm">Dispatch Interface and API Functions</a>." </p>
<p>
The <i>OLE Programmer's Reference</i> provides more information on the functions<b> OleInitialize</b> and <b>CoRegisterClassObject</b>. <i>Inside OLE, Second Edition, </i>published by Microsoft Press,<i> </i>provides more information about verifying application entries in the registration database.</p>

<h4><a name="_oa96_registering_the_hello_application"></a>Registering the Hello Application</h4>
<p>
Finally, the sample registers the Hello application object in the running object table (ROT). Registering an active object allows ActiveX clients to retrieve an object that is already running, rather than create a new instance of the object. Use weak registration (ACTIVEOBJECT_WEAK) so that the running object table releases its reference when all external references are released. If strong registration is used (the default), the running object table will not release the reference until <a href="chap5_14xg.htm"><b>RevokeActiveObject</b></a> is called. For more information, refer to Chapter 5, "<a href="chap5_5t9v.htm">Dispatch Interface and API Functions</a>." </p>
<p>
The following sample shows the registration entries for the Hello object.</p>
<pre><code>REGEDIT
; Registration information for Automation Hello 2.0 Application.

; Version independent registration. Points to Version 2.0.
HKEY_CLASSES_ROOT\Hello.Application = Automation Hello Application
HKEY_CLASSES_ROOT\Hello.Application\Clsid = {F37C8061-4AD5-101B-B826-00DD01103DE1}

; Version 2.0 registration.
HKEY_CLASSES_ROOT\Hello.Application.2 = Automation Hello 2.0 Application
HKEY_CLASSES_ROOT\Hello.Application.2\Clsid = {F37C8061-4AD5-101B-B826-00DD01103DE1}
 </code></pre>

<h4><a name="_oa96_implementing_idispatch"></a>Implementing IDispatch</h4>
<p>
The <b>IDispatch </b>interface provides access to and information about an object. The interface requires the member functions <b>GetTypeInfoCount,</b> <b>GetTypeInfo,</b> <b>GetIdsOfNames,</b> and <b>Invoke.</b> The Hello sample implements <b>IDispatch </b>as follows (Hello.cpp):</p>
<pre><code>STDMETHODIMP
CHello::GetTypeInfoCount(UINT FAR* pctinfo)
{
    *pctinfo = 1;
    return NOERROR;
}

STDMETHODIMP
CHello::GetTypeInfo(
        UINT itinfo,
        LCID lcid,
        ITypeInfo FAR* FAR* pptinfo)
{
    *pptinfo = NULL;

    if(itinfo != 0)
        return ResultFromScode(DISP_E_BADINDEX);

    m_ptinfo-&gt;AddRef();
    *pptinfo = m_ptinfo;

    return NOERROR;
}

STDMETHODIMP
CHello::GetIDsOfNames(
        REFIID riid,
        OLECHAR FAR* FAR* rgszNames,
        UINT cNames,
        LCID lcid,
        DISPID FAR* rgdispid)
{
    return DispGetIDsOfNames(m_ptinfo, rgszNames, cNames, rgdispid);
}

STDMETHODIMP
CHello::Invoke(
        DISPID dispidMember,
        REFIID riid,
        LCID lcid,
        WORD wFlags,
        DISPPARAMS FAR* pdispparams,
        VARIANT FAR* pvarResult,
        EXCEPINFO FAR* pexcepinfo,
        UINT FAR* puArgErr)
{
    {
        return DispInvoke(
        this, m_ptinfo,
        dispidMember, wFlags, pdispparams,
        pvarResult, pexcepinfo, puArgErr);
}
}
 </code></pre>
<p>
Automation includes two functions, <b>DispGetIdsOfNames</b> and <a href="chap5_1e79.htm"><b>DispInvoke</b></a>, which provide standard implementations for <b>IDispatch::GetIDsOfNames</b>, and <a href="chap5_61id.htm"><b>IDispatch::Invoke</b></a>. The Hello sample uses these two functions to simplify the code.</p>

<h4><a name="_oa96_implementing_iunknown"></a>Implementing IUnknown</h4>
<p>
Every OLE object must implement the <b>IUnknown</b> interface, which allows controllers to query the object to find out what interfaces it supports. <b>IUnknown</b> has three member functions: <b>QueryInterface</b>, <b>AddRef</b>, and <b>Release</b>. The Hello sample implements these functions for the CHello object as follows (Hello.cpp):</p>
<pre><code>STDMETHODIMP
CHello::QueryInterface(REFIID iid, void FAR* FAR* ppv)
{
    *ppv = NULL;
    if (iid == IID_IUnknown || iid == IID_IDispatch || iid == IID_IHello
        *ppv = this;
    else if (iid == IID_ISupportErrorInfo)
        *ppv = &amp;m_SupportErrorInfo;
    else return ResultFromScode(E_NOINTERFACE);

    AddRef();
    return NOERROR;
}

STDMETHODIMP_(ULONG)
CHello::AddRef(void)
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG)
CHello::Release(void)
{
if (--m_cRef == 0)
    {
        delete this;
        return 0;
    }
    return m_cRef;
}
 </code></pre>

<h4><a name="_oa96_implementing_iclassfactory"></a>Implementing IClassFactory</h4>
<p>
A class factory is a class that is capable of creating instances of another class. The Hello sample implements a single class factory named <code>CHelloCF</code>, as follows (HelloCf.cpp):</p>
<pre><code>CHelloCF::CHelloCF(void)
{
    m_cRef = 0; 
}

STDMETHODIMP
CHelloCF::QueryInterface(REFIID iid, void FAR* FAR* ppv)
{
    *ppv = NULL;
    if (iid == IID_IUnknown || iid == IID_IClassFactory)
        *ppv = this;
    else
        return ResultFromScode(E_NOINTERFACE);
    AddRef();
    return NOERROR;
}

STDMETHODIMP_(ULONG)
CHelloCF::AddRef(void)
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG)
CHelloCF::Release(void)
{
    if (--m_cRef == 0)
    {
        delete this;
        return 0;
    }
    return m_cRef;
}

STDMETHODIMP
CHelloCF::CreateInstance(IUnknown FAR* punkOuter,
                        REFIID riid,
                        void FAR* FAR* ppv)
{
    HRESULT hr;

    *ppv = NULL;

    // This implementation doesn't allow aggregation.
    if (punkOuter)
        return ResultFromScode(CLASS_E_NOAGGREGATION);

    hr = g_phello-&gt;QueryInterface(riid, ppv);
    if (FAILED(hr)) 
    {
        g_phello-&gt;Quit();
        return hr;
    }
    return NOERROR;
}
STDMETHODIMP
CHelloCF::LockServer(BOOL fLock)
{
    CoLockObjectExternal(g_phello, fLock, TRUE);
    return NOERROR;
}
 </code></pre>
<p>
The function CHelloCF::CHelloCF is a C++ constructor function. By default, the constructor function initializes the object's VTBLs; CHelloCF::CHelloCF also initializes the reference count for the class. </p>
<p>
The class factory supports six member functions. <b>QueryInterface</b>, <b>AddRef</b>, and <b>Release</b> are the required <b>IUnknown</b> members, and <b>CreateInstance</b> and <b>LockServer</b> are the required <b>IClassFactory</b> members.</p>

<h4><a name="_oa96_implementing_vtbl_binding"></a>Implementing VTBL Binding</h4>
<p>
In addition to the <b>IDispatch</b> interface, the Hello sample supports VTBL binding. When a member is invoked, objects that support a VTBL interface return an HRESULT instead of a value, and pass their return value as the last parameter. Objects may also accept a LCID parameter, which allows them to parse strings correctly for the local language. The following example shows how the <b>Visible</b> property is implemented (Hello.cpp):</p>
<pre><code>STDMETHODIMP
CHello::put_Visible(BOOL bVisible)
{
    ShowWindow(bVisible ? SW_SHOW : SW_HIDE);
    return NOERROR;
}

STDMETHODIMP
CHello::get_Visible(BOOL FAR* pbool)
{
    *pbool =  m_bVisible;
    return NOERROR;
}
 </code></pre>
<p>
Additional information must be specified in the .odl file to create a <a href="chap8_8wq4.htm"><b>dual</b></a> interface, as shown in "Creating Type Information" later in this chapter.</p>

<h4><a name="_oa96_registering_the_interface_for_vtbl_binding"></a>Registering the Interface for VTBL Binding</h4>
<p>
The following lines from the Hello.reg file register the interface for VTBL binding. In the example, <b>ProxyStubClsid</b> refers to the proxy and stub implementation of <b>IDispatch</b>.</p>
<pre><code>HKEY_CLASSES_ROOT\Interface\{F37C8062-4AD5-101B-B826-00DD01103DE1} = IHello
HKEY_CLASSES_ROOT\Interface\{F37C806 2-4AD5-101B-B826-00DD01103DE1}\TypeLib = {F37C8060-4AD5-101B-B826-00DD01103DE1}
HKEY_CLASSES_ROOT\Interface\{F37C8062-4AD5-101B-B826-00DD01103DE1}\ProxyStubClsid32 = {00020424-0000-0000-C000-000000000046}
 </code></pre>

<h4><a name="_oa96_handling_errors"></a>Handling Errors</h4>
<p>
The Hello sample includes an exception handler that passes exceptions through <a href="chap5_61id.htm"><b>IDispatch::Invoke</b></a><b>,</b> and supports rich error information through VTBLs (Hello.cpp):</p>
<pre><code>STDMETHODIMP
CHello::RaiseException(int nID)
{
    extern return value g_scodes[];
    char szError[STR_LEN];
    ICreateErrorInfo *pcerrinfo;
    IErrorInfo *perrinfo;
    HRESULT hr;
    BSTR bstrDescription = NULL;

if (LoadString(g_phello-&gt;m_hinst,nID, szError, sizeof(szError)))
    bstrDescription = SysAllocString(TO_OLE_STRING(szError));

// Set ErrorInfo object so that VTBL binding controller can get
// rich error information. If the controller is using IDispatch
// to access properties or methods, DispInvoke will fill the 
// EXCEPINFO structure using the values specified in the ErrorInfo
// object, and Dispinvoke will return DISP_E_EXCEPTION. The 
// property or method must return a failure return value for DispInvoke 
// to do this.
hr = CreateErrorInfo(hr))
{

    pcerrinfo-&gt;SetGUID(rguid);
    pcerrinfo-&gt;SetSource(g_phello-&gt;m_bstrProgID);
    if (bstrDescription)
        pcerrinfo-&gt;SetDescription(bstrDescription);
    hr = pcerrinfo-&gt;QueryInterface(IID_IErrorInfo, 
    (LPVOID FAR*) &amp;perrinfo);
    if (succeeded(hr))
    {
    
        SetErrorInfo(0,perrinfo);
        perrinfo-&gt;Release();
}

if (bstrDescription)
        SysFreeString(bstrDescription);
    return ResultFromScode(g_scodes[nID-1001]);
}
 </code></pre>
<p>
The member functions of the Hello sample call this routine when an exception occurs. <b>RaiseException</b> sets the system's error object so that controller applications that call through VTBLs can retrieve rich error information. Controllers that call through <a href="chap5_61id.htm"><b>IDispatch::Invoke</b></a> will be returned with this error information by <a href="chap5_1e79.htm"><b>DispInvoke</b></a> through the EXCEPINFO structure.</p>
<p>
Hello also implements the <b>ISupportErrorInfo</b> interface, which allows ActiveX clients to query whether an error object will be available (Hello.cpp):</p>
<pre><code>CSupportErrorInfo::CSupportErrorInfo(IUnknown FAR* punkObject,
                                    REFIID riid)
{
    m_punkObject = punkObject;
    m_iid = riid;
}

STDMETHODIMP
CSupportErrorInfo::QueryInterface(REFIID iid, void FAR* FAR* ppv)
{
    return m_punkObject-&gt;QueryInterface(iid, ppv);
}

STDMETHODIMP_(ULONG)
CSupportErrorInfo::AddRef(void)
{
    return m_punkObject-&gt;AddRef();
}

STDMETHODIMP_(ULONG)
CSupportErrorInfo::Release(void)
{
    return m_punkObject-&gt;Release();
}

STDMETHODIMP
CSupportErrorInfo::InterfaceSupportsErrorInfo(REFIID riid)
{
    return (riid == m_iid) ? NOERROR : ResultFromScode(S_FALSE);
}
 </code></pre>

<h4><a name="_oa96_releasing_objects_and_ole"></a>Releasing Objects and OLE</h4>
<p>
When the Hello application ends, it revokes the class factory and the active object, and uninitializes OLE. For example (Main.cpp):</p>
<pre><code>void Uninitialize(DWORD dwRegisterCF, DWORD dwRegisterActiveObject)
{
    if (dwRegisterCF != 0)
        CoRevokeClassObject(dwRegisterCF);
    if (dwRegisterActiveObject != 0)
        RevokeActiveObject(dwRegisterActiveObject, NULL);
    OleUninitialize();
}
 </code></pre>

<h4><a name="_oa96_creating_type_information"></a>Creating Type Information</h4>
<p>
Type information for the Hello sample is described in ODL. The MIDL compiler and MkTypLib utility use the .odl file to create a type library (Hellotl.tlb) and a header file (Hellotl.h). </p>
<p>
The following example shows the description for the Hello type library, interface, and Application object (Hello.odl):</p>
<pre><code>[
    uuid(F37C8060-4AD5-101B-B826-00DD01103DE1),      // LIBID_Hello.
    helpstring("Hello 2.0 Type Library"),
    lcid(0x009),
    version(2.0)
]
library Hello
{
    importlib("stdole32.tlb"); 
    [
    uuid(F37C8062-4AD5-101B-B826-00DD01103DE1),   // IID_Ihello.
    helpstring("Application object for the Hello application."),
    oleautomation,
    dual
    ]
    interface IHello : IDispatch
    {
        [propget, helpstring("Returns the application of the object.")]
        HRESULT Application([out, retval] IHello** retval);

    [propget,
        helpstring("Returns the full name of the application.")]
        HRESULT FullName([out, retval] BSTR* retval);

        [propget, id(0), 
        helpstring("Returns the name of the application.")]
        HRESULT Name([out, retval] BSTR* retval);

        [propget, helpstring("Returns the parent of the object.")]
        HRESULT Parent([out, retval] IHello** retval);

        [propput]
        HRESULT Visible([in] boolean VisibleFlag);
        [propget,
        helpstring
        ("Sets or returns whether the main window is visible.")]
        HRESULT Visible([out, retval] boolean* retval);

        [helpstring("Exits the application.")]
        HRESULT Quit();

        [propput,
        helpstring("Sets or returns the hello message to be used.")]
        HRESULT HelloMessage([in] BSTR Message);
        [propget] 
        HRESULT HelloMessage([out, retval] BSTR *retval);

        [helpstring("Say Hello using HelloMessage.")]
        HRESULT SayHello();
    }


    [
        uuid(F37C8061-4AD5-101B-B826-00DD01103DE1),      // CLSID_Hello.
        helpstring("Hello Class"),
        appobject
    ]
    coclass Hello
    {
        [default]        interface IHello;
                            interface IDispatch;
    }
}
 </code></pre>
<p>
The items enclosed by square brackets are <i>attributes</i>, which provide further information about the objects in the file. The <a href="chap8_9a9a.htm"><b>oleautomation</b></a><b> </b>and <a href="chap8_8wq4.htm"><b>dual</b></a><b> </b>attributes, for example, indicate that the IHello interface supports both <b>IDispatch</b> and VTBL binding. The <a href="chap8_516c.htm"><b>appobject</b></a><b> </b>attribute indicates that Hello is the Application object.</p>
<p>
For more information about attributes, refer to Chapter 8, "<a href="chap8_75b9.htm">Type Libraries and the Object Description Language</a>." </p>

<h4><a name="_oa96_creating_the_hello_registration_file"></a>Creating the Hello Registration File</h4>
<p>
The system registration database lists all the OLE objects in the system. OLE uses this database to locate objects and determine their capabilities. The registration file registers the application, the type library, and the exposed classes of the sample (Hello.reg):</p>
<pre><code>REGEDIT
; Registration information for Automation Hello 2.0 Application.

; Version independent registration. Points to Version 2.0.
HKEY_CLASSES_ROOT\Hello.Application = Hello 2.0 Application
HKEY_CLASSES_ROOT\Hello.Application\Clsid = {F37C8061-4AD5-101B-B826-00DD01103DE1}

; Version 2.0 registration
HKEY_CLASSES_ROOT\Hello.Application.2 = Hello 2.0 Application
HKEY_CLASSES_ROOT\Hello.Application.2\Clsid = {F37C8061-4AD5-101B-B826-00DD01103DE1} 
HKEY_CLASSES_ROOT\CLSID\{F37C8061-4AD5-101B-B826-00DD01103DE1} = Hello 2.0 Application
HKEY_CLASSES_ROOT\CLSID\{F37C8061-4AD5-101B-B826-00DD01103DE1}\ProgID = Hello.Application.2
HKEY_CLASSES_ROOT\CLSID\{F37C8061-4AD5-101B-B826-00DD01103DE1}\VersionIndependentProgID = Hello.Application
HKEY_CLASSES_ROOT\CLSID\{F37C8061-4AD5-101B-B826-00DD01103DE1}\LocalServer = hello.exe /Automation
HKEY_CLASSES_ROOT\CLSID\{F37C8061-4AD5-101B-B826-00DD01103DE1}\TypeLib = {F37C8061-4AD5-101B-B826-00DD01103DE1}
HKEY_CLASSES_ROOT\CLSID\{F37C8061-4AD5-101B-B826-00DD01103DE1}\Programmable

; Type library registration information
HKEY_CLASSES_ROOT\TypeLib\{F37C8060-4AD5-101B-B826-00DD01103DE1}
HKEY_CLASSES_ROOT\TypeLib\{F37C8060-4AD5-101B-B826-00DD01103DE1}\2.0 = Hello 2.0 Type Library
HKEY_CLASSES_ROOT\TypeLib\{F37C8060-4AD5-101B-B826-00DD01103DE1}\2.0\HELPDIR =
; English
HKEY_CLASSES_ROOT\TypeLib\{F37C8060-4AD5-101B-B826-00DD01103DE1}\2.0\9\win32 = hello.tlb

;Interface registration. All interfaces that support vtable binding ;must be registered as follows. RegisterTypeLib &amp; LoadTypeLib will do ;this automatically.

; IID_IHello = {F37C8062-4AD5-101B-B826-00DD01103DE1}
; LIBID_Hello = {F37C8060-4AD5-101B-B826-00DD01103DE1}
HKEY_CLASSES_ROOT\Interface\{F37C8062-4AD5-101B-B826-00DD01103DE1} = IHello
HKEY_CLASSES_ROOT\Interface\{F37C8062-4AD5-101B-B826-00DD01103DE1}\TypeLib = {F37C8060-4AD5-101B-B826-00DD01103DE1}
HKEY_CLASSES_ROOT\Interface\{F37C8062-4AD5-101B-B826-00DD01103DE1}\ProxyStubClsid32 = {00020424-0000-0000-C000-000000000046}
 </code></pre>
<p>
To merge an object's registration information with the system registry, the object should expose the <b>DLLRegisterServer </b>API,<b> </b>as described in the <i>OLE Programmer's Referenc</i>e. <b>DLLRegisterServer </b>should call <a href="chap9_69b6.htm"><b>RegisterTypeLib</b></a><b> </b>to register the type library and the interfaces supported by the application. This only applies to in-process servers. Out-of-process servers such as the Hello sample do not export <b>DLLRegisterServer</b>.</p>
<p>&nbsp;</p></body>
</HTML>
