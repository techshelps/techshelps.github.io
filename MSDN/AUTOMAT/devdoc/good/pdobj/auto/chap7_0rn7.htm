<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Variant Manipulation API Functions</title>
<link disabled rel=stylesheet href=../../../backsdk3.css>
<style type="text/css">
@import url(../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_oa96_variant_manipulation_api_functions"></a>Variant Manipulation API Functions</h1>
<p>
These functions are provided to allow applications to manipulate VARIANTARG variables.<b> </b>Applications that implement <b>IDispatch</b> should test each VARIANTARG for all permitted types by attempting to coerce the variant to each type using <a href="chap7_6vhh.htm"><b>VariantChangeType</b></a> or <a href="chap7_8h14.htm"><b>VariantChangeTypeEx</b></a>.<b> </b>If objects are allowed, the application should always test for object types before other types.<b> </b>If an object type is expected, the application must use <b>IUnknown::QueryInterface</b> to test whether the object is the desired type.</p>
<p>
Although applications can access and interpret the VARIANTARGs without these functions, using them ensures uniform conversion and coercion rules for all implementors of <b>IDispatch</b>.<b> </b>For example, these functions automatically coerce numeric arguments to strings, and vice versa, when necessary.</p>
<p>
Because variants can contain strings, references to scalars, objects, and arrays, all data ownership rules must be followed. All variant manipulation functions should conform to the following rules:
<ol>
<li>
Before use, all VARIANTARGs must be initialized by <a href="chap7_19ys.htm"><b>VariantInit</b></a>.</li>
<li>
For the types VT_UI1, VT_I2, VT_I4, VT_R4, VT_R8, VT_BOOL, VT_ERROR, VT_CY, and VT_DATE, data is stored within the VARIANT structure. Any pointers to the data become invalid when the type of the variant is changed.</li>
<li>
For VT_BYREF | any type, the memory pointed to by the variant is owned and freed by the caller of the function.</li>
<li>
For VT_BSTR, there is only one owner for the string. All strings in variants must be allocated with the <a href="chap7_8r53.htm"><b>SysAllocString</b></a><b> </b>function. When releasing or changing the type of a variant with the VT_BSTR type, <a href="chap7_2g6f.htm"><b>SysFreeString</b></a> is called on the contained string.</li>
<li>
For VT_ARRAY | any type, the rule is analogous to the rule for VT_BSTR. All arrays in variants must be allocated with <a href="chap7_1rvp.htm"><b>SafeArrayCreate</b></a>. When releasing or changing the type of a variant with the VT_ARRAY flag set, <a href="chap7_96bd.htm"><b>SafeArrayDestroy</b></a><b> </b>is called.</li>
<li>
For VT_DISPATCH and VT_UNKNOWN, the objects that are pointed to have reference counts that are incremented when they are placed in a variant. When releasing or changing the type of the variant, <b>Release</b> is called on the object that is pointed to.</li>
</ol>
<p>&nbsp;</p></body>
</HTML>
