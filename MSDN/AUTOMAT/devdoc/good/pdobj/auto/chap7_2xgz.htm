<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>String Manipulation Functions</title>
<link disabled rel=stylesheet href=../../../backsdk3.css>
<style type="text/css">
@import url(../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_oa96_string_manipulation_functions"></a>String Manipulation Functions</h1>
<p>
To handle strings that are allocated by one component and freed by another, Automation defines a special set of functions. These functions use the following data type:</p>
<pre><code>typedef OLECHAR FAR* BSTR;
</code></pre>
<p>
These strings are zero-terminated, and in most cases they can be treated just like OLECHAR* strings. However, you can query a <a href="chap6_7isy.htm">BSTR</a> for its length rather than scan it, so it can contain embedded null characters. The length is stored as an integer at the memory location preceding the data in the string. Instead of reading this location directly, applications should use the string manipulation functions to access the length of a BSTR. </p>
<p>
In situations where a BSTR will not be translated from ANSI to Unicode, or vice versa, you can use BSTRs to pass binary data. For example, if code will run only on 16-bit systems and interact only with other 16-bit systems, you can use BSTRs. The preferred method of passing binary data is to use a SAFEARRAY of VT_UI1.</p>
<p>
In 32-bit OLE, BSTRs use Unicode like all other strings in 32-bit OLE. In 16-bit OLE, BSTRs use ANSI. Win32 provides <b>MultiByteToWideChar</b> and <b>WideCharToMultiByte</b> to convert ANSI strings to Unicode, and Unicode strings to ANSI. Automation caches the space allocated for BSTRs. This speeds up the <a href="chap7_8r53.htm"><b>SysAllocString</b></a><b>/<a href="chap7_2g6f.htm">SysFreeString</a></b> sequence. However, this may also cause <b>IMallocSpy</b> to assign leaks to the wrong memory user because it is not aware of the caching done by Automation. </p>
<p>
For example, if the application allocates a BSTR and frees it, the free block of memory is put into the BSTR cache by Automation. If the application then allocates another BSTR, it can get the free block from the cache. If the second BSTR allocation is not freed, <b>IMallocSpy</b> will attribute the leak to the first allocation of the BSTR. You can determine the correct source of the leak (the second allocation) by disabling the BSTR caching using the debug version of Oleaut32.dll, and by setting the environment variable OANOCACHE=1 before running the application.</p>
<p>
A null pointer is a valid value for a BSTR variable. By convention, it is always treated the same as a pointer to a BSTR that contains zero characters.<b> </b>Also by convention, calls to functions that take a BSTR reference parameter must pass either a null pointer, or a pointer to an allocated BSTR.<b> </b>If the implementation of a function that takes a BSTR reference parameter assigns a new BSTR to the parameter, it must free the previously referenced BSTR.</p>
<p>&nbsp;</p></body>
</HTML>
