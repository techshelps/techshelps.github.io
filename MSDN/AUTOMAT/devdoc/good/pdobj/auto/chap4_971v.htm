<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Kinds of Collections</title>
<link disabled rel=stylesheet href=../../../backsdk3.css>
<style type="text/css">
@import url(../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h3><a name="_oa96_kinds_of_collections"></a>Kinds of Collections</h3>
<p>
The standard for collections lets you describe two kinds of collections, depending on whether it makes sense for the collected objects to exist outside the collection.</p>
<p>
In some cases, it is not logical for an object to exist independently of its collection. For example, an application's Documents collection contains all Document objects currently open. Opening a document means adding it to the collection, and closing the document means removing it from the collection. All open documents are part of the collection. The application cannot have open documents that are not part of the collection. The relationship between the collection and the members of the collection can be shown in the following ways:
<ul>
<li>
<b>Documents.Add</b> creates an object (an open document) and adds it to the collection. Because an object is created, a reference to it is returned.<pre><code>Set MyDoc = Documents.Add
</code></pre>
</li>
<li>
<b>Document.Close</b> removes an object from the collection.<pre><code>Set SomeDoc = Documents(3)
SomeDoc.Close
</code></pre>
</li>
</ul>
<p>
In other cases, it is logical for the objects to exist outside the collection. For example, a Mail application might have Name objects, and many collections of these Name objects. Each Name object would have a user's e-mail name, full name, and possibly other information. The e-mail name and full name would likely be properties named EmailName and FullName<b>.</b></p>
<p>
Additionally, the application might have the following collections of Name objects.
<ul>
<li>
A collection for the "To" list on each piece of e-mail.</li>
<li>
 A collection of the names of the people to whom a user has sent e-mail.</li>
</ul>
<p>
The collections of Name objects could be indexed by using either EmailName or FullName.</p>
<p>
For these collections, the <b>Add</b> method does not create an object because the object already exists. Therefore, the <b>Add</b> method should take an object as an argument, and should not return a value. </p>
<p>
Assuming the existence of two collections (AddressBook and ToList), a user might execute the following code to add a Name object to the ToList collection:</p>
<pre><code>Dim Message as Object
Dim AddressBook as Object
Dim NameRef as Object
.
.
.

Set NameRef = AddressBook.Names("Fred Funk")
Message.ToList.Add   NameRef
</code></pre>
<p>
The Name object already exists and is contained in the AddressBook collection. The first line of code obtains a reference to the Name object for "Fred Funk" and points to NameRef. The second line of code adds a reference to the object to the ToList collection. No new object is created, so no reference is returned from the <b>Add</b> method. </p>
<p>
Unlike the relationship between Documents and Document, there is no way for the collected object (the Name) to know how to remove itself from the collections in which it is contained. To remove an item from a collection, use the <b>Remove </b>method, as follows:</p>
<pre><code>Message.ToList.Remove("Fred Funk")
</code></pre>
<p>
This line of code removes the Name object that has the FullName "Fred Funk." The "Fred Funk" object may exist in other collections, but they will be unaffected.</p>
<p>&nbsp;</p></body>
</HTML>
