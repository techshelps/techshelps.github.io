<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>VarNumFromParseNum</title>
<link disabled rel=stylesheet href=../../../backsdk3.css>
<style type="text/css">
@import url(../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_oa96_varnumfromparsenum"></a>VarNumFromParseNum</h1>
<pre><code><b>HRESULT VarNumFromParseNum( 
  [in]  NUMPARSE </b><i> *pnumprs</i><b>,      </b>
<b>  [in]  unsigned char </b><i> *rgbDig</i><b>,  </b>
<b>  [in]  unsigned long </b><i> dwVtBits</i><b>,  </b>
<b>  [out]  VARIANT </b><i> *pvar          </i>
<b>);</b>
 </code></pre>
<p>
Once the number is parsed, the caller can call <b>VarNumFromParseNum</b> to convert the parse results to a number. The <a href="chap7_406d.htm">NUMPARSE</a> structure and digit array can be passed in unchanged from the <a href="chap7_5eya.htm"><b>VarParseNumFromStr</b></a> call or you can fill in the parameters from any source. This function will choose the smallest type allowed that can hold the result value with as little precision loss as possible. The result variant is an [out] parameter, so its contents are not freed before storing the result.</p>
<h4>Parameters</h4>
<dl>
<dt>
<i>pnumprs</i></dt>
<dd>
Parsed results. <i>cDig</i> = size of <i>rgbDic</i></dd>
<dt>
<i>rgbDig</i></dt>
<dd>
Contains the values of the digits. The <i>cDig</i> field of NUMPARSE contains the number of digits.</dd>
<dt>
<i>dwVtBits</i></dt>
<dd>
Contains one bit set for each type that is acceptable as a return value (in many cases, just one bit).
<p>
<b>VarNumFromParseNum</b> flags that indicate acceptable result types:

<pre><code>VTBIT_I1 
VTBIT_UI1
VTBIT_I2
VTBIT_UI2
VTBIT_I4
VTBIT_UI4
VTBIT_R4
VTBIT_R8
VTBIT_CY
VTBIT_DECIMAL</code></pre>
</dd>
<dt>
</dt>
<dt>
<i>pvar</i></dt>
<dd>
Pointer to the result variant.
</dd>
</dl>
<h4>Return Value</h4>
<p>
The return value obtained from the returned HRESULT is one of the following.</p>
<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=48%>Return value</th>
<th align=left width=52%>Meaning</th>
</tr>
<tr valign=top>
<td width=48%>S_OK</td>
<td width=52%>Success.</td>
</tr>
<tr valign=top>
<td width=48%>E_OUTOFMEMORY</td>
<td width=52%>Out of memory.</td>
</tr>
<tr valign=top>
<td width=48%>DISP_E_OVERFLOW</td>
<td width=52%>The number is too large to be represented in an allowed type. There is no error if precision is lost in the conversion.</td>
</tr>
</table><br>
<p>
For rounding decimal numbers, the digit array must be at least one digit longer than the maximum required for data types. The maximum number of digits required for the DECIMAL data type is 29, so the digit array must have room for 30 digits. There must also be enough digits to accept the number in octal, if that parsing options is selected. (Hexadecimal and octal numbers are limited by <b>VarNumFromParseNum</b> to the magnitude of an <b>unsigned long </b>[32 bits], so they need 11 octal digits.)</p>
<p>&nbsp;</p></body>
</HTML>
