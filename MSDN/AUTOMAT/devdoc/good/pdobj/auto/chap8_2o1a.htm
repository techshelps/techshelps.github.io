<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>The /mktyplib203 Option</title>
<link disabled rel=stylesheet href=../../../backsdk3.css>
<style type="text/css">
@import url(../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h3><a name="_oa96_the_mktyplib203_option"></a>The /mktyplib203 Option</h3>
<p>
The MIDL compiler behaves differently from the MkTypLib utility. The /<b>mktyplib203</b> option removes most of these differences and makes MIDL act like MkTypLib, version 2.03. </p>
<p>
For example, BOOL (a MkTypLib base type) is defined differently in MIDL than it is in MkTypLib. MkTypLib treats BOOL as a VARIANT_BOOL. However, BOOL is defined in the file Wtypes.idl as a long data type. If a VARIANT_BOOL is to be placed in the type library, it has to explicitly use VARIANT_BOOL in the .idl/.odl file. If BOOL is used when VARIANT_BOOL is meant to be used, then the /<b>mktyplib203</b> option should also be used. </p>
<p>
MIDL normally puts globally unique identifier (GUID) predefinitions in its generated header files, and only puts GUID instantiations in the file generated by the <b>/iid</b> option. With the /<b>mktyplib203</b> option, MIDL defines GUIDs in the header files in the way that MkTypLib does. They are defined with a macro that can be compiled conditionally to generate either a predefined or an instantiated GUID. </p>
<p>
With the /<b>mktyplib203</b> option enabled, it is invalid to put any statements outside of the library block. A pure ODL syntax must be used; it cannot be mixed and matched in this mode. </p>
<p>
MkTypLib is used to require <a href="chap8_8gxg.htm"><b>struct</b></a><b>, <a href="chap8_4nji.htm">union</a>,</b> and <a href="chap8_3xv1.htm"><b>enum</b></a> to be defined as part of type definitions. For example: </p>
<pre><code>typedef struct foo { int i; } bar;
</code></pre>
<p>
In this statement, MkTypLib generates a TKIND_RECORD named "bar." Because the "foo" was not recorded anywhere in the type library, it can be omitted. </p>
<p>
MIDL allows normal C definitions of <b>structure, union,</b> and <b>enum</b>:</p>
<pre><code>struct foo {int i;};
    typedef struct foo bar;
</code></pre>
<p>
– Or –</p>
<pre><code>    typedef struct foo {int i;} bar;
</code></pre>
<p>
This statement generates a TKIND_RECORD named "foo" and (if the type definition is public) a TKIND_ALIAS named "bar." The "foo" can still be omitted, in which case MIDL generates a name for it.</p>
<p>
When the /<b>mktyplib203</b> option is enabled, the original MkTypLib type definition syntax is required for structures, unions, and enumerators. The behavior is the same as under MkTypLib (that is, "foo" is not included in the type library). </p>
<p>
<b>Note</b>  MkTypLib permits some scoping errors, such as giving enumerators their own scope. These errors are fixed by MIDL, and cannot be reintroduced, even with the <b>/mktyplib203</b> switch. Even though the /<b>mktyplib203</b> switch enables MIDL to compile most earlier .odl files, there can be a few exceptions. These are cases where the .odl files were already broken, and MkTypLib did not catch the errors.</p>
<p>&nbsp;</p></body>
</HTML>
