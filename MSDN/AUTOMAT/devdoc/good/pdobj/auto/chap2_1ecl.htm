<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>"Lines" Sample</title>
<link disabled rel=stylesheet href=../../../backsdk3.css>
<style type="text/css">
@import url(../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_oa96_lines_sample"></a>"Lines" Sample</h1>
<p>
The Lines sample is an ActiveX component application that implements  collections. This sample file allows a collection of lines to be drawn on a pane using Automation. This sample implements the following features:
<ul>
<li>
<b>Dual</b> interfaces that allow access to automation properties and methods through VTBL binding and <b>IDispatch</b>.</li>
<li>
Rich error information for VTBL-binding controllers implemented by <b>ISupportErrorInfo</b> and <b>IErrorInfo</b>.</li>
<li>
Two collections.</li>
<li>
Active object registration using <a href="chap5_2k38.htm"><b>RegisterActiveObject</b></a> and <a href="chap5_14xg.htm"><b>RevokeActiveObject</b></a>.</li>
<li>
Correct shutdown behavior.</li>
<li>
A registration file that contains Lines.Application as the ProgID.</li>
<li>
Initial invisibility.</li>
</ul>
<p>
The following routine initializes OLE, and then creates an instance of the Lines Application object (Main.cpp):</p>
<pre><code>BOOL InitInstance (HINSTANCE hinst)
{
    HRESULT hr;

    // Intialize OLE.
    hr = OleInitialize(NULL);
    if (FAILED(hr))
        return FALSE;

    // Create an instance of the Lines Application object. The object is
    // created with refcount 0.
    hr = CApplication::Create(hinst, &amp;g_pApplication);
    if (FAILED(hr))
        return FALSE;
    return TRUE;
}
 </code></pre>

<h4><a name="_oa96_initializing_the_active_object"></a>Initializing the Active Object</h4>
<p>
The following function creates and registers the application's class factory, and then registers the Lines Application object as the active object (Main.cpp):</p>
<pre><code>BOOL ProcessCmdLine(LPSTR lpCmdLine, LPDWORD pdwRegisterCF,
                    LPDWORD pdwRegisterActiveObject, int nCmdShow)
{
    LPCLASSFACTORY pcf = NULL;
    HRESULT hr; 
    *pdwRegisterCF = 0;
    *pdwRegisterActiveObject = 0;

    // Expose class factory for application object if command line
    // contains the /Automation switch.
    if (_fstrstr(lpCmdLine, "-Automation") != NULL
        || _fstrstr(lpCmdLine, "/Automation") != NULL)
    {
        pcf = new CApplicationCF;
        if (!pcf)
            goto error;
        pcf-&gt;AddRef();
        hr = CoRegisterClassObject(CLSID_Lines, pcf,
                                CLSCTX_LOCAL_SERVER, REGCLS_SINGLEUSE,
                                pdwRegisterCF);
        if (hr != NOERROR)
            goto error;
        pcf-&gt;Release();
    }
    else                // Show window if started as stand-alone. 
    g_pApplication-&gt;ShowWindow(nCmdShow );

// Register Lines Application object in the running object table (ROT). // Use weak registration so that the ROT releases its reference when 
// all external references are released.
    RegisterActiveObject(g_pApplication, CLSID_Lines, ACTIVEOBJECT_WEAK,
            pdwRegisterActiveObject);
    return TRUE;

error:
    if (pcf)
        pcf-&gt;Release();
    return FALSE;
}
 </code></pre>

<h4><a name="_oa96_registering_the_active_object_02"></a>Registering the Active Object</h4>
<p>
The sample application exposes the class factory for the Lines application, <b>CApplicationCF</b>, if the command line contains the <b>/Automation</b> switch. The switch indicates that the application was started for programmatic access, and therefore OLE needs to register the class factory and create an instance of the Application object. OLE applies this switch if it appears on the command line or in the application's registration file. OLE also supports the <b>/Embedding</b> switch, which indicates that an application has been started by a container application.</p>
<p>
You should register the class factory for the Application object only if the application is launched with the <b>/Automation</b> switch. When <b>/Automation</b> is not specified, the application has been started for some reason other than programmatic access through Automation. If the class factory is registered under these circumstances, and a user later requests a new instance of the Application object, Automation will return the existing instance instead of creating a new one.</p>
<p>
The sample calls <b>CoRegisterClassObject </b>to register the class factory as the active object. The CLSCTX_LOCAL_SERVER flag means the code that creates and manages Application objects will run in a separate process space.</p>
<p>
Because the Application object's class factory is exposed, the call specifies the REGCLS_SINGLEUSE flag. When a multiple-document interface (MDI) application starts, it typically registers the class factory for its Document object, specifying REGCLS_MULTIPLEUSE. This flag, defined in the REGCLS enumeration, allows the existing application instance to be used later, when instances of the document objects need to be created. Each new Application object, however, requires a new instance of the application to be launched, and should therefore specify REGCLS_SINGLEUSE. If the application registered its class factory using REGCLS_MULTIPLEUSE, then the next <b>CreateObject</b> call that tries to create the application will get an existing copy.</p>
<p>
In the following example, the macro defines a CLSID for Lines (Tlb.h):</p>
<pre><code>DEFINE_GUID(CLSID_Lines,0x3C591B21,0x1F13,0x101B,0xB8,0x26,0x00,0xDD,0x01,0x10,0x3D,0xE1);
 </code></pre>
<p>
When the MIDL compiler to MkTypLib creates the optional header file (Tlb.h), it inserts DEFINE_GUID macros for each library, interface, and each class in an application.</p>

<h4><a name="_oa96_creating_the_lines_registration_file"></a>Creating the Lines Registration File</h4>
<p>
The registration file provides information about the application, the Application object, classes of objects, type libraries, and interfaces. Entries for objects and interfaces start with the constant HKEY_CLASSES_ROOT, which represents the root key of the entire registration database. Entries for type libraries start with HKEY_TYPELIB_ROOT. After the constant, each entry supplies specific information about an object, type library, or interface.</p>
<p>
Use the following steps to create the registration file:
<ol>
<li>
Copy the file Lines.reg.</li>
<li>
Rename and edit this file, adding entries for the application.</li>
</ol>

<h4><a name="_oa96_registering_the_lines_application_files"></a>Registering the Lines Application Files</h4>
<p>
The Lines sample uses the following entries to register its Application object (Lines.Application) and its type library with the system (Lines.reg):</p>
<pre><code>REGEDIT
; Registration information for the Lines Application object. Version independent registration.

HKEY_CLASSES_ROOT\Lines.Application = Lines
HKEY_CLASSES_ROOT\Lines.Application\Clsid = {3C591B21-1F13-101B-B826-00DD01103DE1}

; Version 1.0 registration
HKEY_CLASSES_ROOT\Lines.Application.1 = Lines 1.0
HKEY_CLASSES_ROOT\Lines.Application.1\Clsid = {3C591B21-1F13-101B-B826-00DD01103DE1}
   
HKEY_CLASSES_ROOT\CLSID\{3C591B21-1F13-101B-B826-00DD01103DE1} = Lines 1.0
HKEY_CLASSES_ROOT\CLSID\{3C591B21-1F13-101B-B826-00DD01103DE1}\ProgID = Lines.Application.1
HKEY_CLASSES_ROOT\CLSID\{3C591B21-1F13-101B-B826-00DD01103DE1}\VersionIndependentProgID = Lines.Application
HKEY_CLASSES_ROOT\CLSID\{3C591B21-1F13-101B-B826-00DD01103DE1}\LocalServer32 = lines.exe /Automation
HKEY_CLASSES_ROOT\CLSID\{3C591B21-1F13-101B-B826-00DD01103DE1}\TypeLib = {3C591B20-1F13-101B-B826-00DD01103DE1}
HKEY_CLASSES_ROOT\CLSID\{3C591B21-1F13-101B-B826-00DD01103DE1}\Programmable

; Type library registration information.
HKEY_CLASSES_ROOT\TypeLib\{3C591B20-1F13-101B-B826-00DD01103DE1}
HKEY_CLASSES_ROOT\TypeLib\{3C591B20-1F13-101B-B826-00DD01103DE1}\1.0 = Lines 1.0 Type Library
HKEY_CLASSES_ROOT\TypeLib\{3C591B20-1F13-101B-B826-00DD01103DE1}\1.0\HELPDIR =
;English     
HKEY_CLASSES_ROOT\TypeLib\{3C591B20-1F13-101B-B826-00DD01103DE1}\1.0\9\win32 = lines.tlb 

; Interface registration. All interfaces that support VTBL binding must be 
; registered as follows. RegisterTypeLib will do this automatically.

; LIBID_Lines = {3C591B20-1F13-101B-B826-00DD01103DE1}

; IID_IPoint = {3C591B25-1F13-101B-B826-00DD01103DE1}
HKEY_CLASSES_ROOT\Interface\{3C591B25-1F13-101B-B826-00DD01103DE1} = IPoint
HKEY_CLASSES_ROOT\Interface\{3C591B25-1F13-101B-B826-00DD01103DE1}\TypeLib = {3C591B20-1F13-101B-B826-00DD01103DE1}
HKEY_CLASSES_ROOT\Interface\{3C591B25-1F13-101B-B826-00DD01103DE1}\ProxyStubClsid32 = {00020424-0000-0000-C000-000000000046}

; IID_ILine = {3C591B24-1F13-101B-B826-00DD01103DE1}
HKEY_CLASSES_ROOT\Interface\{3C591B24-1F13-101B-B826-00DD01103DE1} = ILine
HKEY_CLASSES_ROOT\Interface\{3C591B24-1F13-101B-B826-00DD01103DE1}\TypeLib = {3C591B20-1F13-101B-B826-00DD01103DE1}
HKEY_CLASSES_ROOT\Interface\{3C591B24-1F13-101B-B826-00DD01103DE1}\ProxyStubClsid32 = {00020424-0000-0000-C000-000000000046}

; IID_ILines = {3C591B26-1F13-101B-B826-00DD01103DE1}
HKEY_CLASSES_ROOT\Interface\{3C591B26-1F13-101B-B826-00DD01103DE1} = ILines
HKEY_CLASSES_ROOT\Interface\{3C591B26-1F13-101B-B826-00DD01103DE1}\TypeLib = {3C591B20-1F13-101B-B826-00DD01103DE1}
HKEY_CLASSES_ROOT\Interface\{3C591B26-1F13-101B-B826-00DD01103DE1}\ProxyStubClsid32 = {00020424-0000-0000-C000-000000000046}

; IID_IPoints = {3C591B27-1F13-101B-B826-00DD01103DE1}
HKEY_CLASSES_ROOT\Interface\{3C591B27-1F13-101B-B826-00DD01103DE1} = IPoints
HKEY_CLASSES_ROOT\Interface\{3C591B27-1F13-101B-B826-00DD01103DE1}\TypeLib = {3C591B20-1F13-101B-B826-00DD01103DE1}
HKEY_CLASSES_ROOT\Interface\{3C591B27-1F13-101B-B826-00DD01103DE1}\ProxyStubClsid32 = {00020424-0000-0000-C000-000000000046}

; IID_IPane = {3C591B23-1F13-101B-B826-00DD01103DE1}
HKEY_CLASSES_ROOT\Interface\{3C591B23-1F13-101B-B826-00DD01103DE1} = IPane
HKEY_CLASSES_ROOT\Interface\{3C591B23-1F13-101B-B826-00DD01103DE1}\TypeLib = {3C591B20-1F13-101B-B826-00DD01103DE1}
HKEY_CLASSES_ROOT\Interface\{3C591B23-1F13-101B-B826-00DD01103DE1}\ProxyStubClsid32 = {00020424-0000-0000-C000-000000000046}

; IID_IApplication = {3C591B22-1F13-101B-B826-00DD01103DE1}
HKEY_CLASSES_ROOT\Interface\{3C591B22-1F13-101B-B826-00DD01103DE1} = IApplication
HKEY_CLASSES_ROOT\Interface\{3C591B22-1F13-101B-B826-00DD01103DE1}\TypeLib = {3C591B20-1F13-101B-B826-00DD01103DE1}
HKEY_CLASSES_ROOT\Interface\{3C591B22-1F13-101B-B826-00DD01103DE1}\ProxySt
 </code></pre>

<h4><a name="_oa96_creating_the_iunknown_interface_for_the_lines_application"></a>Creating the IUnknown Interface for the Lines Application</h4>
<p>
The <b>IUnknown </b>interface for the Lines object looks like this (Lines.cpp):</p>
<pre><code>STDMETHODIMP
CLine::QueryInterface(REFIID iid, void FAR* FAR* ppv)
{
    *ppv = NULL;

    if (iid == IID_IUnknown || iid == IID_IDispatch || iid == IID_ILine)
        *ppv = this; 
    else if (iid == IID_ISupportErrorInfo)
        *ppv = &amp;m_SupportErrorInfo;
    else return ResultFromScode(E_NOINTERFACE);

    AddRef();
    return NOERROR;
}

STDMETHODIMP_(ULONG)
CLine::AddRef(void)
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG)
CLine::Release(void)
{
    if(--m_cRef == 0)
    {
        delete this;
        return 0;
    }
    return m_cRef;
}
 </code></pre>

<h4><a name="_oa96_creating_the_idispatch_interface_for_the_lines_application"></a>Creating the IDispatch Interface for the Lines Application</h4>
<p>
The following sections explain how to implement <b>IDispatch</b> by using <a href="chap5_0mnc.htm"><b>CreateStdDispatch</b></a> and <a href="chap5_1e79.htm"><b>DispInvoke</b></a>.</p>
<h5>Implementing IDispatch by Calling CreateStdDispatch</h5>
<p>
The simplest way to implement the <b>IDispatch</b> interface is to call <a href="chap5_0mnc.htm"><b>CreateStdDispatch</b></a>. This approach works for ActiveX objects that return only the standard dispatch exception codes, support a single national language, and do not support dual interfaces.</p>
<p>
<b>CreateStdDispatch</b> returns a pointer to the created <b>IDispatch</b> interface. It takes three pointers as input: a pointer to the object's <b>IUnknown </b>interface, a pointer to the object to expose, and a pointer to the type information for the object. The following example implements <b>IDispatch</b> for an object named CCalc by calling <b>CreateStdDispatch</b> on the loaded type information:</p>
<pre><code>CCalc FAR*
CCalc::Create()
{
    HRESULT hresult;
    CCalc FAR* pcalc;
    ITypeLib FAR* ptlib;
    ITypeInfo FAR* ptinfo;
    IUnknown FAR* punkStdDisp;

    ptlib = NULL;
    ptinfo = NULL;

    // Some error handling code omitted.
    if ((pcalc = new FAR CCalc()) == NULL)
        return NULL;
    pcalc-&gt;AddRef();

    // Load the type library from the information in the registry.
    if ((hresult = LoadRegTypeLib(LIBID_DspCalc2, 1, 0, 0x0409, &amp;ptlib))
        !=     NOERROR){ 
        goto LError0;
    }
    if ((hresult = ptlib-&gt;GetTypeInfoOfGuid(IID_ICalculator, &amp;ptinfo))
        != NOERROR){
        goto LError0;
    }

    // Create an aggregate with an instance of the default
    // implementation of IDispatch that is initialized with our
    // TypeInfo.
    //
    hresult = CreateStdDispatch(
            pcalc,                        // Controlling unknown.
            &amp;(pcalc-&gt;m_arith),            // VTBL pointer to dispatch on.
            ptinfo,
            &amp;punkStdDisp);
 </code></pre>
<h5>Implementing IDispatch by Delegating</h5>
<p>
Another way to implement <b>IDispatch</b> is to use the dispatch functions <a href="chap5_1e79.htm"><b>DispInvoke</b></a> and <a href="chap5_1jxv.htm"><b>DispGetIDsOfNames</b></a>. These functions give you the option of supporting multiple national languages and creating application-specific exceptions that are passed back to ActiveX clients.</p>
<p>
The Lines sample implements <a href="chap5_32cz.htm"><b>IDispatch::GetIDsOfNames</b></a><b> </b>and <a href="chap5_61id.htm"><b>IDispatch::Invoke</b></a> using these functions<b> </b>(Lines.cpp):</p>
<pre><code>STDMETHODIMP 
CLines::GetIDsOfNames(
        REFIID riid,
        char FAR* FAR* rgszNames,
        UINT cNames,
        LCID lcid,
        DISPID FAR* rgdispid)
{
    return DispGetIDsOfNames(m_ptinfo, rgszNames, cNames, rgdispid);
}

STDMETHODIMP
CLines::Invoke(
        DISPID dispidMember,
        REFIID riid,
        LCID lcid,
        WORD wFlags,
        DISPPARAMS FAR* pdispparams,
        VARIANT FAR* pvarResult,
        EXCEPINFO FAR* pexcepinfo,
        UINT FAR* puArgErr)
{
    
    {
    return DispInvoke(
        this, m_ptinfo,
        dispidMember, wFlags, pdispparams,
        pvarResult, pexcepinfo, puArgErr);
}
}
 </code></pre>
<p>
The Lines object implements the <b>IID_ILine</b> <b>dual</b> interface for VTBL binding. It also implements the <b>IID_ISupportErrorInfo</b> interface so that it can return rich, contextual error information through VTBLs.</p>

<h4><a name="_oa96_implementing_the_class_factory_for_the_lines_application"></a>Implementing the Class Factory for the Lines Application</h4>
<p>
The Lines sample implements a class factory for its Application object, as follows (Appcf.cpp):</p>
<pre><code>STDMETHODIMP
CApplicationCF::CreateInstance(IUnknown FAR* punkOuter,
                                REFIID riid,
                                void FAR* FAR* ppv)
{
    HRESULT hr;

    *ppv = NULL;

    // This implementation doesn't allow aggregation.
    if (punkOuter)
        return ResultFromScode(CLASS_E_NOAGGREGATION);

    // This is REGCLS_SINGLEUSE class factory, so CreateInstance will be
    // called at most once. An application object has a REGCLS_SINGLEUSE 
    // class factory. The global application object has already been 
    // created when CreateInstance is called. A REGCLS_MULTIPLEUSE class 
    // factory's CreateInstance would be called multiple times and would 
    // create a new object each time. An MDI application would have a 
    // REGCLS_MULTIPLEUSE class factory for its document objects.
    
    hr = g_pApplication-&gt;QueryInterface(riid, ppv);
    if (FAILED(hr)) 
    {
        g_pApplication-&gt;Quit();
        return hr;
    }
    return NOERROR;
}

STDMETHODIMP
CApplicationCF::LockServer(BOOL fLock)
{
    CoLockObjectExternal(g_pApplication, fLock, TRUE);
    return NOERROR;
}
 </code></pre>
<p>
The object's class factory must also implement an <b>IUnknown</b> interface. For example (Appcf.cpp):</p>
<pre><code>STDMETHODIMP
CApplicationCF::QueryInterface(REFIID iid, void FAR* FAR* ppv)
{
    *ppv = NULL;

    if (iid == IID_IUnknown || iid == IID_IClassFactory)
        *ppv = this;
    else
        return ResultFromScode(E_NOINTERFACE); 
    AddRef();
    return NOERROR;
}

STDMETHODIMP_(ULONG)
CApplicationCF::AddRef(void)
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG)
CApplicationCF::Release(void)
{
    if(--m_cRef == 0)
    {
        delete this;
        return 0;
    }
    return m_cRef;
}
 </code></pre>

<h4><a name="_oa96_setting_up_the_vtbl_interface"></a>Setting Up the VTBL Interface</h4>
<p>
The Lines sample supports VTBL binding as well as the <b>IDispatch </b>interface.<b> </b>By supporting this <a href="chap8_8wq4.htm"><b>dual</b></a> interface, the sample allows ActiveX clients both the flexibility of the <b>IDispatch</b> interface and the speed of VTBLs. Controllers that know the names of the members can compile directly against the function pointers in the VTBL. Controllers that do not have this information can use <b>IDispatch</b> at <br>
run time.</p>
<p>
To have a <b>dual</b> interface, an interface must:
<ul>
<li>
Declare all of its members to return an HRESULT, and pass their actual return values as the last parameter.</li>
<li>
Have only Automation-compatible parameters and return types, as described in Chapter 7, "<a href="chap7_5alv.htm">Conversion and Manipulation Functions</a>." </li>
<li>
Specify the <b>dual </b>attribute on the interface description in the .odl file.</li>
<li>
Initialize the VTBLs with the appropriate member function pointers.</li>
</ul>
<p>
In the Lines sample, the interfaces <b>IPoint, IPoints, ILine, ILines, IPane,</b> and <b>IApplication</b> are all dual interfaces. The <b>IPoint</b> interface defines functions that get and put the values of the <b>X</b> and <b>Y</b> properties, as follows (Point.cpp):</p>
<pre><code>STDMETHODIMP
CPoint::get_x(int FAR* pnX)
{
    *pnX = m_nX;
    return NOERROR;
}

STDMETHODIMP
CPoint::put_x(int nX)
{
    m_nX = nX;
    return NOERROR;
}

STDMETHODIMP
CPoint::get_y(int FAR* pnY)
{
    *pnY = m_nY; 
    return NOERROR;
}

STDMETHODIMP
CPoint::put_y(int nY)
{
    m_nY = nY; 
    return NOERROR;
}
 </code></pre>
<p>
The <b>get_x</b> and <b>get_y</b> accessor functions pass their return values in the last parameter, <i>pnX</i> and <i>pnY</i>, and return an HRESULT as the function value.</p>
<p>
In the .odl file, the interface is described as follows (Lines.odl):</p>
<pre><code>[
        uuid(3C591B25-1F13-101B-B826-00DD01103DE1),    // IID_IPoint.
        helpstring("Point object."),
        oleautomation,
        dual
    ]
    interface IPoint : IDispatch
    {
        [propget, helpstring("Returns and sets x coordinate.")]
        HRESULT x([out, retval] int* retval); 
        [propput, helpstring("Returns and sets x coordinate.")]
        HRESULT x([in] int Value);

        [propget, helpstring("Returns and sets y coordinate.")]
        HRESULT y([out, retval] int* retval); 
        [propput, helpstring("Returns and sets y coordinate.")]
        HRESULT y([in] int Value);
    }
 </code></pre>
<p>
The attributes <a href="chap8_9a9a.htm"><b>oleautomation</b></a><b> </b>and<b> <a href="chap8_8wq4.htm">dual</a> </b>indicate that the interface supports both <b>IDispatch </b>and VTBL binding. All of the member functions are declared with HRESULT return values. The <b>Get</b> accessor functions, indicated by the <a href="chap8_6w50.htm"><b>propget</b></a><i> </i>attribute, return their value in the last parameter. This parameter has the <a href="chap8_2o1g.htm"><b>out</b></a><b> </b>and <a href="chap8_1vak.htm"><b>retval</b></a><b> </b>attributes.</p>
<p>
In the Lines sample, the Application object exposes the following method (App.cpp):</p>
<pre><code>STDMETHODIMP
CApplication::CreatePoint(IPoint FAR* FAR* ppPoint)
{
    CPoint FAR* ppoint = NULL;
    HRESULT hr;

    // Create new item and QueryInterface for IDispatch.
    hr = CPoint::Create(&amp;ppoint);
    if (FAILED(hr))
        {hr = RaiseException(IDS_OutOfMemory); goto error;}

    hr = ppoint-&gt;QueryInterface(IID_IDispatch, (void FAR* FAR*)ppPoint);
    if (FAILED(hr))
        {hr = RaiseException(IDS_Unexpected); goto error;}
    return NOERROR;

error:
    if (ppoint)
        delete ppoint;
    return hr;
}
 </code></pre>
<p>
The <b>CreatePoint</b> method creates a new point and returns a pointer to it in the parameter <code>pPoint</code>.</p>
<p>
In the Lines sample, the CLine object exposes the <b>Color</b> property. This property is implemented by the following accessor functions (Lines.cpp):</p>
<pre><code>STDMETHODIMP
CLine::get_Color(long FAR* plColorref)
{
    *plColorref =  m_colorref;
    return NOERROR;
}
STDMETHODIMP
CLine::put_Color(long lColorref)
{
    m_colorref = (COLORREF)lColorref;
    return NOERROR;
}
 </code></pre>

<h4><a name="_oa96_implementing_the_value_property"></a>Implementing the Value Property</h4>
<p>
In the Lines sample, <code>ILines.Item, IPoints.Item,</code> and <code>IApplication.Name</code> are the <code>Value</code> properties of the objects <code>ILines, IPoints,</code> and <code>IApplication,</code> respectively. The <code>ILines.Item</code> object is described as follows:</p>
<pre><code>interface ILines : IDispatch
    {
.
.// Some descriptions omitted for brevity.
.
    [propget, id(0), helpstring(
"Given an integer index, returns one of the lines in the collection")]
    HRESULT Item([in] long Index,[out, retval] ILine** retval); 
.
}
 </code></pre>
<p>
Using this property, a user can refer to the fourth line in the collection as <b>ILines(4).Item</b> or simply as <b>ILines(4)</b>.</p>
<p>
For more information on recommended objects, properties, and methods, see Chapter 4, "<a href="chap4_8joz.htm">Standard Objects and Naming Guidelines</a>." </p>

<h4><a name="_oa96_restricting_access_to_objects"></a>Restricting Access to Objects</h4>
<p>
Automation provides several ways of restricting access to objects. The simplest approach is not to document the properties and methods you do not want users to see. Alternatively, you can prevent a property or method from appearing in type library browsers by specifying the <a href="chap8_8mum.htm"><b>hidden</b></a> attribute in the .odl file.</p>
<p>
The <a href="chap8_0wbo.htm"><b>restricted</b></a><b> </b>attribute goes one step further, preventing user calls from binding to the property or method, as well as hiding it from type browsers. For example, the following restricts access to the<b> _NewEnum</b> property of the ILines object:</p>
<pre><code>[propget, restricted, id(DISPID_NEWENUM)]          // Must be propget.
    HRESULT _NewEnum( [out, retval] IUnknown** retval);
 </code></pre>
<p>
Restricted properties and methods can be invoked by ActiveX clients, but are not visible to the user who may be using a language such as Visual Basic. In addition, they cannot be bound to by user calls.</p>

<h4><a name="_oa96_creating_collection_objects"></a>Creating Collection Objects</h4>
<p>
A collection object contains a group of exposed objects of the same type and can iterate over them. Collection objects do not need an <b>IClassFactory</b> implementation, because they are accessed from elements that have their own class factories.</p>
<p>
For example, the Lines sample has a collection object named CLines that iterates over a group of Line objects. The following routine creates and initializes the CLines collection object (Lines.cpp):</p>
<pre><code>STDMETHODIMP
CLines::Create(ULONG lMaxSize, long lLBound, CPane FAR* pPane,
                CLines FAR* FAR* ppLines)
{
    HRESULT hr;
    CLines FAR* pLines = NULL;
    SAFEARRAYBOUND sabound[1];

    *ppLines = NULL;

    // Create new collection.
    pLines = new CLines();
    if (pLines == NULL)
        goto error;

    pLines-&gt;m_cMax = lMaxSize;
    pLines-&gt;m_cElements = 0;
    pLines-&gt;m_lLBound = lLBound;
    pLines-&gt;m_pPane = pPane;

    // Load type information for the Lines collection from type library.
    hr = LoadTypeInfo(&amp;pLines-&gt;m_ptinfo, IID_ILines);
    if (FAILED(hr))
        goto error;

    // Create a safe array of variants used to implement the collection.
    sabound[0].cElements = lMaxSize;
    sabound[0].lLbound = lLBound;
    pLines-&gt;m_psa = SafeArrayCreate(VT_VARIANT, 1, sabound);
    if (pLines-&gt;m_psa == NULL)
    {
        hr = ResultFromScode(E_OUTOFMEMORY);
        goto error;
    }

    *ppLines = pLines;
    return NOERROR;

error:
    if (pLines == NULL)
        return ResultFromScode(E_OUTOFMEMORY);
    if (pLines-&gt;m_ptinfo)
        pLines-&gt;m_ptinfo-&gt;Release();
    if (pLines-&gt;m_psa)
        SafeArrayDestroy(pLines-&gt;m_psa);

    pLines-&gt;m_psa = NULL;
    pLines-&gt;m_ptinfo = NULL;

    delete pLines;
    return hr;
}
 </code></pre>
<p>
The parameters to <b>CLines::Create </b>specify the maximum number of lines that the collection can contain, the lower bound of the indexes of the collection, and a pointer to a pane, which contains the lines and points in the sample.</p>

<h4><a name="_oa96_implementing_the_ienumvariant_interface_for_the_lines_application"></a>Implementing the IEnumVARIANT Interface for the Lines Application</h4>
<p>
In the Lines sample, <b>CEnumVariant</b> implements the <b>Next, Skip, Reset,</b> and <b>Clone</b> member functions (Enumvar.cpp):</p>
<pre><code>STDMETHODIMP
CEnumVariant::Next(ULONG cElements, VARIANT FAR* pvar,
                    ULONG FAR* pcElementFetched)
{
    HRESULT hr;
    ULONG l;
    long l1;
    ULONG l2;

    if (pcElementFetched != NULL)
        *pcElementFetched = 0;

    // Retrieve the elements of the next cElements.
    for (l1=m_lCurrent, l2=0; l1&lt;(long)(m_lLBound+m_cElements) &amp;&amp;
        l2&lt;cElements; l1++, l2++)
    {
        hr = SafeArrayGetElement(m_psa, &amp;l1, &amp;pvar[l2]);
        if (FAILED(hr))
            goto error;
    }
    // Set count of elements retrieved.
    if (pcElementFetched != NULL)
        *pcElementFetched = l2;
    m_lCurrent = l1;

    return (l2 &lt; cElements) ? ResultFromScode(S_FALSE) : NOERROR;
error:
    for (l=0; l&lt;cElements; l++)
        VariantClear(&amp;pvar[l]);
    return hr;
}

STDMETHODIMP
CEnumVariant::Skip(ULONG cElements)
{
    m_lCurrent += cElements; 
    if (m_lCurrent &gt; (long)(m_lLBound+m_cElements))
    {
        m_lCurrent =  m_lLBound+m_cElements;
        return ResultFromScode(S_FALSE);
    }
    else return NOERROR;
}

STDMETHODIMP
CEnumVariant::Reset()
{
    m_lCurrent = m_lLBound;
    return NOERROR;
}

STDMETHODIMP
CEnumVariant::Clone(IEnumVARIANT FAR* FAR* ppenum)
{
    CEnumVariant FAR* penum = NULL;
    HRESULT hr;

    *ppenum = NULL;
    
    hr = CEnumVariant::Create(m_psa, m_cElements, &amp;penum);
    if (FAILED(hr))
        goto error;
    penum-&gt;AddRef();
    penum-&gt;m_lCurrent = m_lCurrent;

    *ppenum = penum;
    return NOERROR;
error:
    if (penum)
        penum-&gt;Release();
    return hr;
}
 </code></pre>

<h4><a name="_oa96_implementing_the__newenum_property_for_the_lines_application"></a>Implementing the _NewEnum Property for the Lines Application</h4>
<p>
The Lines sample contains two collections, Lines and Points, and implements a <b>_NewEnum</b> property for each. Both are restricted properties, available to ActiveX clients, but invisible to users of scripting or macro languages supported by ActiveX clients. The property returns an enumerator (<b>IEnumVARIANT</b>) for the items in the collection.</p>
<p>
The following code implements the <b>_NewEnum</b> property for the Lines collection (Lines.cpp):</p>
<pre><code>STDMETHODIMP
CLines::get__NewEnum(IUnknown FAR* FAR* ppunkEnum)
{
    CEnumVariant FAR* penum = NULL;;
    HRESULT hr;

    *ppunkEnum = NULL;

    // Create a new enumerator for items currently in the collection and 
    // QueryInterface for IUnknown.
    hr = CEnumVariant::Create(m_psa, m_cElements, &amp;penum);
    if (FAILED(hr))
        {hr = RaiseException(IDS_OutOfMemory); goto error;}
    hr = penum-&gt;QueryInterface(IID_IUnknown, (VOID FAR* FAR*)ppunkEnum);
    if (FAILED(hr))
        {hr = RaiseException(IDS_Unexpected); goto error;}
    return NOERROR;

error:
    if (penum)
        delete penum;
    return hr;
}
 </code></pre>

<h4><a name="_oa96_returning_errors_02"></a>Returning Errors</h4>
<p>
The Lines sample defines an exception handler that fills the EXCEPINFO structure and signals <b>IDispatch</b> to return DISP_E_EXCEPTION (App.cpp):</p>
<pre><code>STDMETHODIMP
HRESULT RaiseException (int nID, Refguid rguid)
{
    extern return value g_scodes[];
    TCHAR szError[STR_LEN];
    ICreateErrorInfo *pcerrinfo;
    IErrorInfo *perrinfo;
    HRESULT hr;
    BSTR bstrDescription = NULL;

    if (LoadString(g_pApplication-&gt;m_hinst, nID, szError,     sizeof(szError)));
    bstrDescription =    SysAllocString(TO_OLE_STRING(szError));

    // Set ErrInfo object so that VTBL binding controllers can get
    // rich error information. If the controller is using IDispatch to     // access properties or methods, DispInvoke will fill the EXCEPINFO     // structure using the values specified in the ErrorInfo object and     // DispInvoke will return DISP_e_EXCEPTION. The property or method     // must return a failure return value for DispInvoke to do this.
        hr = CreateErrorInfo(&amp;pcerrinfo);
        if (SUCCEEDED(hr))
    {
        pcerrinfo-&gt;SetGUID(rguid);
        pcerrinfo-&gt;SetSource(g_pApplication-&gt;m_bstrProgID);
        if (bstrDescription)
            pcerrinfo-&gt;SetDescription(bstrDescription);
        hr = pcerrinfo-&gt;QueryInterface(IID_IerrorInfo, (LPVOID FAR*)                 &amp;perrinfo);
        if (SUCCEEDED(hr))
{
            SetErrorInfo(0, perrinfo);
            perrinfo-&gt;Release();
    }
    if (bstrDescription)
        SysFreeString(bstrDescription);
    return ResultFromScode(g_scodes[nID-1001]);
}
 </code></pre>
<p>
Properties and methods in the Lines sample call this routine when an exception occurs. <b>RaiseException</b> sets the system's error object, so that controller applications that call through VTBLs can retrieve rich error information. Controllers that call through <a href="chap5_61id.htm"><b>IDispatch::Invoke</b></a> will be returned with this error information by <a href="chap5_1e79.htm"><b>DispInvoke</b></a> through the EXCEPINFO structure.</p>

<h4><a name="_oa96_passing_exceptions_through_vtbls"></a>Passing Exceptions Through VTBLs</h4>
<p>
The Lines sample also provides rich error information for members invoked through VTBLs. Because VTBL-bound calls bypass the <b>IDispatch</b> interface, they cannot return exceptions through<b> IDispatch</b>. Instead, they must use the error handling interfaces in Automation. The <b>RaiseException</b> function shown in the example calls <a href="chap11_25wv.htm"><b>CreateErrorInfo</b></a> to create an error object, then fills the object's data fields with information about the error. When all of the information has been successfully recorded, it calls <a href="chap11_31in.htm"><b>SetErrorInfo</b></a> to associate the error object with the current thread of execution.</p>
<p>
ActiveX objects similar to the collection object (CApplication), which use the error interfaces, must also implement the <b>ISupportErrorInfo</b> interface. This interface identifies the object as supporting the error interfaces, and ensures that error information can be propagated correctly up the call chain. The following example shows how the Lines sample implements this interface (Errinfo.cpp):</p>
<pre><code>STDMETHODIMP
CSupportErrorInfo::CSupportErrorInfo(IUnknown FAR* punkObject,
        REFIID riid)
{
    m_punkObject = punkObject;
    m_iid = riid;
}

CSupportErrorInfo::QueryInterface(REFIID iid, void FAR* FAR* ppv)
{
    return m_punkObject-&gt;QueryInterface(iid, ppv);
}

STDMETHODIMP_(ULONG)
CSupportErrorInfo::AddRef(void)
{
    return m_punkObject-&gt;AddRef();
}

STDMETHODIMP_(ULONG)
CSupportErrorInfo::Release(void)
{
    return m_punkObject-&gt;Release();
}

STDMETHODIMP
CSupportErrorInfo::InterfaceSupportsErrorInfo(REFIID riid)
{
    return (riid == m_iid) ? NOERROR : ResultFromScode(S_FALSE);
}
 </code></pre>
<p>
<b>ISupportErrorInfo</b> has the <b>QueryInterface</b>, <b>AddRef</b>, and <code>Release</code><b> </b>methods inherited from the <b>IUnknown </b>interface, along with the <b>InterfaceSupportsErrorInfo</b> method. ActiveX clients call <b>InterfaceSupportsErrorInfo</b> to check whether the ActiveX object supports the <b>IErrorInfo</b> interface, so they can access the error object. For details, see Chapter 11, "<a href="chap11_0fqr.htm">Error Handling Interfaces</a>." </p>

<h4><a name="_oa96_releasing_ole_on_exit"></a>Releasing OLE on Exit</h4>
<p>
The following code revokes an active Lines object, revokes the Lines class, and then uninitializes OLE (Main.cpp):</p>
<pre><code>void Uninitialize(DWORD dwRegisterCF, DWORD dwRegisterActiveObject)
{
    if (dwRegisterCF != 0)
        CoRevokeClassObject(dwRegisterCF);
    if (dwRegisterActiveObject != 0)
        RevokeActiveObject(dwRegisterActiveObject, NULL);
    OleUninitialize();
}
 </code></pre>

<h4><a name="_oa96_writing_an_object_description_script"></a>Writing an Object Description Script</h4>
<p>
An object description script is essentially an annotated header file, written in ODL. The following example shows a portion of Lines.odl, the object description script for the Lines sample.</p>
<pre><code>[
    uuid(3C591B20-1F13-101B-B826-00DD01103DE1),        // LIBID_Lines.
    helpstring("Lines 1.0 Type Library"),
    lcid(0x09),
    version(1.0)
]

library Lines
{
    importlib("stdole.tlb");
    #define DISPID_NEWENUM -4
.
.
.
 </code></pre>
<p>
The preceding entry describes the type library (Lines.tlb) created by the sample. The items in square brackets are attributes, which provide additional information about the library. In the example, the attributes give the library's UUID, a Help string, an LCID, and a version number.</p>
<p>
The <b>importlib</b> directive is similar to the C or C++ <b>#include</b> directive. It allows access to the type descriptions in the file Stdole.tlb from the Lines library. However, it does not copy those types into the Lines.tlb. To use Lines.tlb, both the Lines.tlb and Stdole.tlb files must be available.</p>
<p>
By default, .odl files are preprocessed with the C preprocessor, so the <b>#include</b> and <b>#define</b> directives can be used.</p>
<p>
The object description script continues with information on the objects in the type library:</p>
<pre><code>    [
        uuid(3C591B25-1F13-101B-B826-00DD01103DE1),        // IID_Ipoint.
        helpstring("Point object."),
        oleautomation,
        dual
    ]
    interface IPoint : IDispatch
    {
        [propget, helpstring("Returns and sets x coordinate.")]
        HRESULT x( [out, retval] int* retval);
        [propput, helpstring("Returns and sets x coordinate.")]
        HRESULT x([in] int Value);

        [propget, helpstring("Returns and sets y coordinate.")]
        HRESULT y( [out, retval] int* retval);
        [propput, helpstring("Returns and sets y coordinate.")]
        HRESULT y([in] int Value);
    }
    // .
    // Additional definitions omitted for brevity.
    // .
}
 </code></pre>
<p>
This entry describes the <b>IPoint</b> interface. The interface has the attributes <a href="chap8_9a9a.htm"><b>oleautomation</b></a><b> </b>and <a href="chap8_8wq4.htm"><b>dual</b></a>, indicating that the types of all its properties and methods are compatible with Automation, and that it supports binding through both <b>IDispatch </b>and VTBLs. The <b>IPoint</b> interface has two pairs of property accessor functions, which set and return the <b>X</b> and <b>Y</b> properties.</p>
<p>
The <b>Value </b>parameter of both the <b>X</b> and <b>Y</b> properties has the <a href="chap8_992m.htm"><b>in</b></a><b> </b>attribute. These parameters supply a value and are read-only. Conversely, the <i>retval </i>parameter of each property has the <a href="chap8_2o1g.htm"><b>out</b></a><b> </b>and <a href="chap8_1vak.htm"><b>retval</b></a><i> </i>attributes, indicating that it returns the value of the property.</p>
<p>
Because <b>IPoint</b> supports VTBL binding and rich error information, its properties return HRESULTs and pass their function return values through <i>retval</i><b> </b>parameters. For more information, see Chapter 8, "<a href="chap8_75b9.htm">Type Libraries and the Object Description Language</a>." </p>
<pre><code>[
        uuid(3C591B21-1F13-101B-B826-00DD01103DE1),        // CLSID_Lines.
        helpstring("Lines Class"),
        appobject
    ]
    coclass Lines
    {
        [default] interface IApplication;
            interface IDispatch;
    }
}
 </code></pre>
<p>
The file concludes with the description of the Lines Application object, as specified by the <a href="chap8_516c.htm"><b>appobject</b></a><b> </b>attribute. The <a href="chap8_2sj8.htm"><b>default</b></a><b> </b>attribute applies to the <b>IApplication</b> interface, indicating that this interface will be returned by default.</p>
<p>&nbsp;</p></body>
</HTML>
