<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>VARIANT and VARIANTARG</title>
<link disabled rel=stylesheet href=../../../backsdk3.css>
<style type="text/css">
@import url(../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_oa96_variant_and_variantarg"></a>VARIANT and VARIANTARG</h1>
<p>
Use VARIANTARG to describe arguments passed within DISPPARAMS, and VARIANT to specify variant data that cannot be passed by reference. The VARIANT type cannot have the VT_BYREF bit set. VARIANTs can be passed by value, even if VARIANTARGs cannot.</p>
<pre><code>typedef struct FARSTRUCT tagVARIANT VARIANT;
typedef struct FARSTRUCT tagVARIANT VARIANTARG;

typedef struct tagVARIANT  {
    VARTYPE vt;
    unsigned short wReserved1;
    unsigned short wReserved2;
    unsigned short wReserved3;
    union {
        unsigned char        bVal;                        // VT_UI1.
        short                    iVal;                        // VT_I2    .
        long                    lVal;                        // VT_I4    .
        float                    fltVal;                    // VT_R4    .
        double                dblVal;                    // VT_R8    .
        VARIANT_BOOL        boolVal;                        // VT_BOOL.
        SCODE                    scode;                    // VT_ERROR.
        CY                        cyVal;                    // VT_CY    .
        DATE                    date;                        // VT_DATE.
        BSTR                    bstrVal;                    // VT_BSTR.
        IUnknown                FAR* punkVal;            // VT_UNKNOWN.
        IDispatch             FAR* pdispVal;            // VT_DISPATCH.
        SAFEARRAY            FAR* parray;            // VT_ARRAY|*.
        unsigned char        FAR* pbVal;                // VT_BYREF|VT_UI1.
        short                    FAR* piVal;                // VT_BYREF|VT_I2.
        long                    FAR* plVal;                // VT_BYREF|VT_I4.
        float                    FAR* pfltVal;            // VT_BYREF|VT_R4.
        double                FAR* pdblVal;            // VT_BYREF|VT_R8.
        VARIANT_BOOL        FAR* pboolVal;                // VT_BYREF|VT_BOOL.
        SCODE                    FAR* pscode;            // VT_BYREF|VT_ERROR.
        CY                        FAR* pcyVal;            // VT_BYREF|VT_CY.
        DATE                    FAR* pdate;                // VT_BYREF|VT_DATE.
        BSTR                    FAR* pbstrVal;            // VT_BYREF|VT_BSTR.
        IUnknown FAR*        FAR* ppunkVal;            // VT_BYREF|VT_UNKNOWN.
        IDispatch FAR*        FAR* ppdispVal;        // VT_BYREF|VT_DISPATCH.
        SAFEARRAY FAR*        FAR* pparray;            // VT_ARRAY|*.
        VARIANT                FAR* pvarVal;            // VT_BYREF|VT_VARIANT.
        void                    FAR* byref;                // Generic ByRef.
    };
};
 </code></pre>
<p>
To simplify extracting values from VARIANTARGs, Automation provides a set of functions for manipulating this type. Use of these functions is strongly recommended to ensure that applications apply consistent coercion rules.</p>
<p>
The <i>vt</i> value governs the interpretation of the union as follows:</p>
<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=31%>Value</th>
<th align=left width=69%>Description</th>
</tr>
<tr valign=top>
<td width=31%>VT_EMPTY</td>
<td width=69%>No value was specified. If an optional argument to an Automation method is left blank, do not pass a VARIANT of type VT_EMPTY. Instead, pass a VARIANT of type VT_ERROR with a value of DISP_E_PARAMNOTFOUND.</td>
</tr>
<tr valign=top>
<td width=31%>VT_EMPTY | VT_BYREF</td>
<td width=69%>Not valid.</td>
</tr>
<tr valign=top>
<td width=31%>VT_UI1</td>
<td width=69%>An unsigned 1-byte character is stored in <i>bVal</i>.</td>
</tr>
<tr valign=top>
<td width=31%>VT_UI1 | VT_BYREF</td>
<td width=69%>A reference to an unsigned 1-byte character was passed. A pointer to the value is in <i>pbVal</i>.</td>
</tr>
<tr valign=top>
<td width=31%>VT_I2</td>
<td width=69%>A 2-byte integer value is stored in <i>iVal</i>.</td>
</tr>
<tr valign=top>
<td width=31%>VT_I2 | VT_BYREF</td>
<td width=69%>A reference to a 2-byte integer was passed. A pointer to the value is in <i>piVal</i>.</td>
</tr>
<tr valign=top>
<td width=31%>VT_I4</td>
<td width=69%>A 4-byte integer value is stored in <i>lVal</i>.</td>
</tr>
<tr valign=top>
<td width=31%>VT_I4 | VT_BYREF</td>
<td width=69%>A reference to a 4-byte integer was passed. A pointer to the value is in <i>plVal</i>.</td>
</tr>
<tr valign=top>
<td width=31%>VT_R4</td>
<td width=69%>An IEEE 4-byte real value is stored in<i> fltVal</i>.</td>
</tr>
<tr valign=top>
<td width=31%>VT_R4 | VT_BYREF</td>
<td width=69%>A reference to an IEEE 4-byte real value was passed. A pointer to the value is in <i>pfltVal</i>.</td>
</tr>
<tr valign=top>
<td width=31%>VT_R8</td>
<td width=69%>An 8-byte IEEE real value is stored in <i>dblVal</i>.</td>
</tr>
<tr valign=top>
<td width=31%>VT_R8 | VT_BYREF</td>
<td width=69%>A reference to an 8-byte IEEE real value was passed. A pointer to its value is in <i>pdblVal</i>.</td>
</tr>
<tr valign=top>
<td width=31%>VT_CY</td>
<td width=69%>A currency value was specified.<b> </b>A currency number is stored as an 8-byte, two's complement integer, scaled by 10,000 to give a fixed-point number with 15 digits to the left of the decimal point and 4 digits to the right.<b> </b>The value is in <i>cyVal</i>.</td>
</tr>
<tr valign=top>
<td width=31%>VT_CY | VT_BYREF</td>
<td width=69%>A reference to a currency value was passed. A pointer to the value is in <i>pcyVal</i>.</td>
</tr>
<tr valign=top>
<td width=31%>VT_BSTR</td>
<td width=69%>A string was passed; it is stored in <i>bstrVal</i>. This pointer must be obtained and freed by the BSTR functions, which are described in Chapter 7, "<a href="chap7_5alv.htm">Conversion and Manipulation Functions</a>." </td>
</tr>
<tr valign=top>
<td width=31%>VT_BSTR | VT_BYREF</td>
<td width=69%>A reference to a string was passed.<b> </b>A BSTR* that points to a BSTR is in <i>pbstrVal</i>.<b> </b>The referenced pointer must be obtained or freed by the BSTR functions.</td>
</tr>
<tr valign=top>
<td width=31%>VT_NULL</td>
<td width=69%>A propagating null value was specified. (This should not be confused with the null pointer.) The null value is used for tri-state logic, as with SQL.</td>
</tr>
<tr valign=top>
<td width=31%>VT_NULL | VT_BYREF</td>
<td width=69%>Not valid.</td>
</tr>
<tr valign=top>
<td width=31%>VT_ERROR</td>
<td width=69%>An SCODE was specified. The type of the error is specified in <i>scodee</i>. Generally, operations on error values should raise an exception or propagate the error to the return value, as appropriate.</td>
</tr>
<tr valign=top>
<td width=31%>VT_ERROR | VT_BYREF</td>
<td width=69%>A reference to an SCODE was passed.<b> </b>A pointer to the value is in <i>pscode.</i></td>
</tr>
<tr valign=top>
<td width=31%>VT_BOOL</td>
<td width=69%>A Boolean (True/False) value was specified. A value of 0xFFFF (all bits 1) indicates True; a value of 0 (all bits 0) indicates False. No other values are valid.</td>
</tr>
<tr valign=top>
<td width=31%>VT_BOOL | VT_BYREF</td>
<td width=69%>A reference to a Boolean value. A pointer to the Boolean value is in<i> pbool</i>.</td>
</tr>
<tr valign=top>
<td width=31%>VT_DATE</td>
<td width=69%>A value denoting a date and time was specified.<b> </b>Dates are represented as double-precision numbers, where midnight, January 1, 1900 is 2.0, January 2, 1900 is 3.0, and so on. The value is passed in <i>date</i>.<p>
This is the same numbering system used by most spreadsheet programs, although some specify incorrectly that February 29, 1900 existed, and thus set January 1, 1900 to 1.0. The date can be converted to and from an MS-DOS representation using <a href="chap7_54th.htm"><b>VariantTimeToDosDateTime</b></a>, which is discussed in Chapter 7, "<a href="chap7_5alv.htm">Conversion and Manipulation Functions</a>." </p>
</td>
</tr>
<tr valign=top>
<td width=31%>VT_DATE | VT_BYREF</td>
<td width=69%>A reference to a date was passed.<b> </b>A pointer to the value is in <i>pdate</i>.</td>
</tr>
<tr valign=top>
<td width=31%>VT_DISPATCH</td>
<td width=69%>A pointer to an object was specified.<b> </b>The pointer is in <i>pdispVal</i>.<b> </b>This object is known only to implement <b>IDispatch</b>. The object can be queried as to whether it supports any other desired interface by calling <b>QueryInterface</b> on the object.<b> </b>Objects that do not implement <b>IDispatch</b> should be passed using VT_UNKNOWN.</td>
</tr>
<tr valign=top>
<td width=31%>VT_DISPATCH | VT_BYREF</td>
<td width=69%>A pointer to a pointer to an object was specified. The pointer to the object is stored in the location referred to by <i>ppdispVal</i>.</td>
</tr>
<tr valign=top>
<td width=31%>VT_VARIANT</td>
<td width=69%>Invalid. VARIANTARGs must be passed by reference.</td>
</tr>
<tr valign=top>
<td width=31%>VT_VARIANT | VT_BYREF</td>
<td width=69%>A pointer to another VARIANTARG is passed in <i>pvarVal</i>.<b> </b>This referenced VARIANTARG will never have the VT_BYREF bit set in <i>vt</i>, so only one level of indirection can ever be present.<b> </b>This value can be used to support languages that allow functions to change the types of variables passed by reference.</td>
</tr>
<tr valign=top>
<td width=31%>VT_UNKNOWN</td>
<td width=69%>A pointer to an object that implements the <b>IUnknown</b> interface is passed in<i> punkVal</i>.</td>
</tr>
<tr valign=top>
<td width=31%>VT_UNKNOWN | VT_BYREF</td>
<td width=69%>A pointer to the <b>IUnknown</b> interface is passed in <i>ppunkVal</i>. The pointer to the interface is stored in the location referred to by <i>ppunkVal</i>.</td>
</tr>
<tr valign=top>
<td width=31%>VT_ARRAY | &lt;anything&gt;</td>
<td width=69%>An array of data type &lt;anything&gt; was passed. (VT_EMPTY and VT_NULL are invalid types to combine with VT_ARRAY.)<b> </b>The pointer in <i>pbyrefVal</i> points to an array descriptor, which describes the dimensions, size, and in-memory location of the array.<b> </b>The array descriptor is never accessed directly, but instead is read and modified using the functions described in Chapter 7, "<a href="chap7_5alv.htm">Conversion and Manipulation Functions</a>." </td>
</tr>
</table><br>
<p>&nbsp;</p></body>
</HTML>
