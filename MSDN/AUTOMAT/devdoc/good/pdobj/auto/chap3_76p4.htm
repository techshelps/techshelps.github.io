<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Accessing Members Through IDispatch</title>
<link disabled rel=stylesheet href=../../../backsdk3.css>
<style type="text/css">
@import url(../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h2><a name="_oa96_accessing_members_through_idispatch"></a>Accessing Members Through IDispatch</h2>
<p>
To bind to exposed objects at run time, use the <b>IDispatch </b>interface.</p>
<h5>&nbsp;&nbsp;&nbsp;&nbsp;To create an ActiveX client using IDispatch</h5>
<ol>
<li>
Initialize OLE.</li>
<li>
Create an instance of the object you want to access. The object's ActiveX component creates the object.</li>
<li>
Obtain a reference to the object's<b> IDispatch</b> interface (if it has implemented one).</li>
<li>
Manipulate the object through the methods and properties exposed in its <b>IDispatch</b> interface.</li>
<li>
Terminate the object by invoking the appropriate method in its <b>IDispatch</b> interface, or by releasing all references to the object.</li>
<li>
Uninitialize OLE.</li>
</ol>
<p>
The following table shows the minimum set of functions necessary to manipulate a remote object.</p>
<table cellspacing=4 cols=3>
<tr valign=top>
<th align=left width=28%>Function</th>
<th align=left width=43%>Purpose</th>
<th align=left width=29%>Interface</th>
</tr>
<tr valign=top>
<td width=28%><b>OleInitialize</b></td>
<td width=43%>Initializes OLE.</td>
<td width=29%>OLE API function</td>
</tr>
<tr valign=top>
<td width=28%><b>CoCreateInstance</b></td>
<td width=43%>Creates an instance of the class represented by the specified CLSID, and returns a pointer to the object's<b> IUnknown</b> interface.</td>
<td width=29%>Component object API function</td>
</tr>
<tr valign=top>
<td width=28%><b>QueryInterface</b></td>
<td width=43%>Checks whether <b>IDispatch</b> has been implemented for the object. If so, returns a pointer to the<b> IDispatch</b> implementation.</td>
<td width=29%><b>IUnknown</b></td>
</tr>
<tr valign=top>
<td width=28%><b>GetIDsOfNames</b></td>
<td width=43%>Returns dispatch identifiers (DISPIDs) for properties and methods and their parameters.</td>
<td width=29%><b>IDispatch</b></td>
</tr>
<tr valign=top>
<td width=28%><b>Invoke</b></td>
<td width=43%>Invokes a method, or sets or gets a property of the remote object.</td>
<td width=29%><b>IDispatch</b></td>
</tr>
<tr valign=top>
<td width=28%><b>Release</b></td>
<td width=43%>Decrements the reference count for an <b>IUnknown</b> or <b>IDispatch</b> object.</td>
<td width=29%><b>IUnknown</b></td>
</tr>
<tr valign=top>
<td width=28%><b>OleUninitialize</b></td>
<td width=43%>Uninitializes OLE.</td>
<td width=29%>OLE API function</td>
</tr>
</table><br>
<p>
The code that follows is extracted from a generalized Windows-based ActiveX client. The controller relies on helper functions provided in the file Invhelp.cpp, which is available in the Browse directory of the samples. Error checking is omitted to save space, but would normally be used where an HRESULT is returned.</p>
<p>
The two functions that follow initialize OLE, and then create an instance of an object and get a pointer to the object's <b>IDispatch</b> interface (Invhelp.cpp):</p>
<pre><code>BOOL InitOle(void)
{
    if(OleInitialize(NULL) != 0)
        return FALSE;

    return TRUE;
}
HRESULT CreateObject(LPSTR pszProgID, IDispatch FAR* FAR* ppdisp)
{
    CLSID clsid;                  // CLSID of ActiveX object.
    HRESULT hr;
    LPUNKNOWN punk = NULL;        // IUnknown of ActiveX object.
    LPDISPATCH pdisp = NULL;      // IDispatch of ActiveX object.

    *ppdisp = NULL;

    // Retrieve CLSID from the ProgID that the user specified.
    hr = CLSIDFromProgID(pszProgID, &amp;clsid);
    if (FAILED(hr))
        goto error;

    // Create an instance of the ActiveX object and ask for the
    // IDispatch interface.
    hr = CoCreateInstance(clsid, NULL, CLSCTX_SERVER, 
                            IID_IUnknown, (void FAR* FAR*)&amp;punk);
    if (FAILED(hr))
        goto error;

    hr = punk-&gt;QueryInterface(IID_IDispatch, (void FAR* FAR*)&amp;pdisp);
    if (FAILED(hr))
        goto error;

    *ppdisp = pdisp;
    punk-&gt;Release();
    return NOERROR;
    
error:
    if (punk) punk-&gt;Release();
    if (pdisp) pdisp-&gt;Release();
    return hr;
}
</code></pre>
<p>
The <b>CreateObject</b> function is passed a ProgID and returns a pointer to the <b>IDispatch</b> implementation of the specified object. <b>CreateObject</b> calls the OLE API <b>CLSIDFromProgID </b>to get the CLSID that corresponds to the requested object, and then passes the CLSID to <b>CoCreateInstance</b> to create an instance of the object and get a pointer to the object's <b>IUnknown </b>interface. (The <b>CLSIDFromProgID </b>function is described in the <i>OLE Programmer</i>'<i>s Reference.)</i> With this pointer, <b>CreateObject</b> calls <b>IUnknown::QueryInterface,</b> specifying IID_IDispatch,<b> </b>to get a pointer to the object's <b>IDispatch</b> interface.</p>
<pre><code>HRESULT FAR
Invoke(LPDISPATCH pdisp,
    WORD wFlags,
    LPVARIANT pvRet,
    EXCEPINFO FAR* pexcepinfo,
    UINT FAR* pnArgErr,
    LPSTR pszName,
    char *pszFmt,
    ...)
{
    va_list argList;
    va_start(argList, pszFmt);
    DISPID dispid;
    HRESULT hr;
    VARIANTARG* pvarg = NULL;

    if (pdisp == NULL)
        return ResultFromScode(E_INVALIDARG);

    // Get DISPID of property/method.
    hr = pdisp-&gt;GetIDsOfNames(IID_NULL, &amp;pszName, 1,
        LOCALE_SYSTEM_DEFAULT, &amp;dispid);
    if(FAILED(hr))
        return hr;

    DISPPARAMS dispparams;
    _fmemset(&amp;dispparams, 0, sizeof dispparams);

    // Determine number of arguments.
    if (pszFmt != NULL)
        CountArgsInFormat(pszFmt, &amp;dispparams.cArgs);

    // Property puts have a named argument that represents the value
    // being assigned to the property.
    DISPID dispidNamed = DISPID_PROPERTYPUT;
    if (wFlags &amp; DISPATCH_PROPERTYPUT)
    {
        if (dispparams.cArgs == 0)
            return ResultFromScode(E_INVALIDARG);
        dispparams.cNamedArgs = 1;
        dispparams.rgdispidNamedArgs = &amp;dispidNamed;
    }
    if (dispparams.cArgs != 0)
    {
        // Allocate memory for all VARIANTARG parameters.
        pvarg = new VARIANTARG[dispparams.cArgs];
        if(pvarg == NULL)
            return ResultFromScode(E_OUTOFMEMORY);
        dispparams.rgvarg = pvarg;
        _fmemset(pvarg, 0, sizeof(VARIANTARG) * dispparams.cArgs);

        // Get ready to traverse the vararg list.
        LPSTR psz = pszFmt;
        pvarg += dispparams.cArgs - 1;   // Params go in opposite order.

        while (psz = GetNextVarType(psz, &amp;pvarg-&gt;vt))
        {
            if (pvarg &lt; dispparams.rgvarg)
            {
                hr = ResultFromScode(E_INVALIDARG);
                goto cleanup;  
            }
            switch (pvarg-&gt;vt)
            {
            case VT_I2:
                V_I2(pvarg) = va_arg(argList, short);
                break;
            case VT_I4:
                V_I4(pvarg) = va_arg(argList, long);
                break;
            // Additional cases omitted to save space.
            default:
                {
                    hr = ResultFromScode(E_INVALIDARG);
                    goto cleanup;  
                }
                break;
            }
            --pvarg;             // Get ready to fill next argument.
        } //while
    } //if

    // Initialize return variant, in case caller forgot. Caller can pass
    // Null if no return value is expected.
    if (pvRet)
        VariantInit(pvRet);
    // Make the call.
    hr = pdisp-&gt;Invoke(dispid, IID_NULL, LOCALE_SYSTEM_DEFAULT, wFlags,
        &amp;dispparams, pvRet, pexcepinfo, pnArgErr);

cleanup:
    // Clean up any arguments that need it.
    if (dispparams.cArgs != 0)
    {
        VARIANTARG FAR* pvarg = dispparams.rgvarg;
        UINT cArgs = dispparams.cArgs;
        while (cArgs--)
        {
            switch (pvarg-&gt;vt)
            {
            case VT_BSTR:
                VariantClear(pvarg);
                break;
            }
            ++pvarg;
        }
    }
    delete dispparams.rgvarg;
    va_end(argList);
    return hr;
}
</code></pre>
<p>
In this example, the <b>Invoke</b> function is a general-purpose function that calls <a href="chap5_61id.htm"><b>IDispatch::Invoke</b></a> to invoke a property or method of an ActiveX object. As arguments, it accepts the object's <b>IDispatch</b> implementation, the name of the member to invoke, flags that control the invocation, and a variable list of the member's arguments. It can be found in the Browse sample in the file Invelp.cpp.</p>
<p>
Using the object's <b>IDispatch</b> implementation and the name of the member, it calls <b>GetIDsOfNames</b> to get the DISPID of the requested member. The member's DISPID must be used later, in the call to <b>IDispatch::Invoke</b>.</p>
<p>
The invocation flags specify whether a method, PROPERTYPUT, or PROPERTYGET function is being invoked. The helper function simply passes these flags directly to <b>IDispatch::Invoke</b>.</p>
<p>
The helper function next fills in the DISPPARAMS structure with the parameters of the member. DISPPARAMS structures have the following form:</p>
<pre><code>typedef struct FARSTRUCT tagDISPPARAMS{
    VARIANTARG FAR* rgvarg;           // Array of arguments.
    DISPID FAR* rgdispidNamedArgs;    // DISPIDs of named arguments.
    UINT cArgs;                       // Number of arguments.
    UINT cNamedArgs;                  // Number of named arguments.
} DISPPARAMS;
</code></pre>
<p>
The <i>rgvarg</i> field is a pointer to an array of VARIANTARG structures. Each element of the array specifies an argument, whose position in the array corresponds to its position in the parameter list of the method definition. The <i>cArgs</i> field specifies the total number of arguments, and the <i>cNamedArgs </i>field specifies the number of named arguments.</p>
<p>
For methods and property get functions, all arguments can be accessed as positional, or they can be accessed as named arguments. Property put functions have a named argument that is the new value for the property. The DISPID of this argument is DISPID_PROPERTYPUT.</p>
<p>
To build the <i>rgvarg </i>array, the <b>Invoke</b> helper function retrieves the parameter values and types from its own argument list, and constructs a VARIANTARG structure for each one. (For a description of the format string that specifies the types of the parameters, see the file Invhelp.cpp.) Parameters are put in the array in reverse order, so that the last parameter is in <i>rgvarg</i>[0], and so forth. Although VARIANTARG has the following five fields, only the first and fifth are used.</p>
<pre><code>typedef struct FARSTRUCT tagVARIANT VARIANTARG;

struct FARSTRUCT tagVARIANT{
    VARTYPE vt;
    unsigned short wReserved1;
    unsigned short wReserved2;
    unsigned short wReserved3;
    union {
        short        iVal;        /* VT_I2        */
.
.    // The rest of this union specifies numerous other types.
.

    };
} VARIANTARG;
</code></pre>
<p>
The first field contains the argument's type, and the fifth contains its value. To pass a long integer, for example, the <i>vt</i> and <i>iVal</i> fields of the VARIANTARG structure would be filled with VT_I4 (long integer) and the actual value of the long integer.</p>
<p>
In addition, for property put functions, the first element of the <i>rgdispidNamedArgs</i> array must contain DISPID_PROPERTYPUT.</p>
<p>
After filling the DISPPARAMS structure, the <b>Invoke</b> helper function initializes <code>pvRet,</code> a variant in which <a href="chap5_61id.htm"><b>IDispatch::Invoke</b></a> returns a value from the method or property. The following is the actual call to <b>IDispatch::Invoke</b>:</p>
<pre><code>hr = pdisp-&gt;Invoke(dispid, IID_NULL, LOCALE_SYSTEM_DEFAULT, wFlags,
        &amp;dispparams, pvRet, pexcepinfo, pnArgErr);
</code></pre>
<p>
The variable <code>pdisp</code><i> </i>is a pointer to the object's <b>IDispatch</b> interface. DISPID indicates the method or property being invoked. The value IID_NULL must be specified for all <a href="chap5_61id.htm"><b>IDispatch::Invoke</b></a> calls, and LOCALE_SYSTEM_DEFAULT is a constant denoting the default locale identifier (LCID) for this system. In the final two arguments, <code>pexcepinfo </code>and<code> pnArgErr</code>, <b>IDispatch::Invoke</b> can return error information. </p>
<p>
If the invoked member has defined an exception handler, it returns exception information in <code>pexcepinfo</code>. If certain errors occur in the argument vector, <code>pnArgErr</code> points to the errant argument. The function return value <code>hr</code> is an HRESULT that indicates success or various types of failure.</p>
<p>
For more information, including how to pass optional arguments, see "<b>IDispatch::Invoke</b>" in Chapter 5, "<a href="chap5_5t9v.htm">Dispatch Interface and API Functions</a>." </p>
<p>&nbsp;</p></body>
</HTML>
