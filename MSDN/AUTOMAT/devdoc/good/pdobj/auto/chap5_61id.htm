<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>IDispatch::Invoke</title>
<link disabled rel=stylesheet href=../../../backsdk3.css>
<style type="text/css">
@import url(../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_oa96_idispatch_invoke"></a>IDispatch::Invoke</h1>
<pre><code><b>HRESULT Invoke( 
  DISPID </b><i> dispIdMember</i><b>,      </b>
<b>  REFIID </b><i> riid</i><b>,              </b>
<b>  LCID </b><i> lcid</i><b>,                </b>
<b>  WORD </b><i> wFlags</i><b>,              </b>
<b>  DISPPARAMS FAR* </b><i> pDispParams</i><b>,  </b>
<b>  VARIANT FAR* </b><i> pVarResult</i><b>,  </b>
<b>  EXCEPINFO FAR* </b><i> pExcepInfo</i><b>,  </b>
<b>  unsigned int FAR* </b><i> puArgErr  </i>
<b>);</b>
 </code></pre>
<p>
Provides access to properties and methods exposed by an object. The dispatch function <a href="chap5_1e79.htm"><b>DispInvoke</b></a> provides a standard implementation of <b>IDispatch::Invoke</b>.</p>
<h4>Parameters</h4>
<dl>
<dt>
<i>dispIdMember</i></dt>
<dd>
Identifies the member. Use <b>GetIDsOfNames</b> or the object's documentation to obtain the dispatch identifier.</dd>
<dt>
<i>riid</i></dt>
<dd>
Reserved for future use. Must be IID_NULL.</dd>
<dt>
<i>lcid</i></dt>
<dd>
The locale context in which to interpret arguments. The <i>lcid</i> is used by the <b>GetIDsOfNames</b> function, and is also passed to <b>Invoke</b> to allow the object<b> </b>to interpret its arguments specific to a locale. 
<p>
Applications that do not support multiple national languages can ignore this parameter. For more information, refer to "<a href="chap2_1zqr.htm">Supporting Multiple National Languages</a>" in Chapter 2, "<a href="chap2_9nqr.htm">Exposing ActiveX Objects</a>." 
</dd>
<dt>
<i>wFlags</i></dt>
<dd>
Flags describing the context of the <b>Invoke</b> call, include:

<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=41%>Value</th>
<th align=left width=59%>Description</th>
</tr>
<tr valign=top>
<td width=41%>DISPATCH_METHOD</td>
<td width=59%>The member is invoked as a method. If a property has the same name, both this and the DISPATCH_PROPERTYGET flag may be set.</td>
</tr>
<tr valign=top>
<td width=41%>DISPATCH_PROPERTYGET</td>
<td width=59%>The member is retrieved as a property or data member.</td>
</tr>
<tr valign=top>
<td width=41%>DISPATCH_PROPERTYPUT</td>
<td width=59%>The member is changed as a property or data member.</td>
</tr>
<tr valign=top>
<td width=41%>DISPATCH_PROPERTYPUTREF</td>
<td width=59%>The member is changed by a reference assignment, rather than a value assignment. This flag is valid only when the property accepts a reference to an object.</td>
</tr>
</table><br>

</dd>
<dt>
<i>pDispParams</i></dt>
<dd>
Pointer to a structure containing an array of arguments, an array of argument DISPIDs for named arguments, and counts for the number of elements in the arrays. See the Comments section that follows for a description of the DISPPARAMS structure.</dd>
<dt>
<i>pVarResult</i></dt>
<dd>
Pointer to the location where the result is to be stored, or Null if the caller expects no result. This argument is ignored if DISPATCH_PROPERTYPUT or DISPATCH_PROPERTYPUTREF is specified.</dd>
<dt>
<i>pExcepInfo</i></dt>
<dd>
Pointer to a structure that contains exception information.<b> </b>This structure should be filled in if DISP_E_EXCEPTION is returned. Can be Null.</dd>
<dt>
<i>puArgErr</i></dt>
<dd>
The index within <i>rgvarg</i> of the first argument that has an error. Arguments are stored in <i>pDispParams-&gt;rgvarg</i> in reverse order, so the first argument is the one with the highest index in the array. This parameter is returned only when the resulting return value is DISP_E_TYPEMISMATCH or DISP_E_PARAMNOTFOUND. For details, see "Returning Errors" in the following Comments section.
</dd>
</dl>
<h4>Return Value</h4>
<p>
The return value obtained from the returned HRESULT is one of the following:</p>
<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=39%>Return value</th>
<th align=left width=61%>Meaning</th>
</tr>
<tr valign=top>
<td width=39%>S_OK</td>
<td width=61%>Success.</td>
</tr>
<tr valign=top>
<td width=39%>DISP_E_BADPARAMCOUNT</td>
<td width=61%>The number of elements provided to DISPPARAMS is different from the number of arguments accepted by the method or property.</td>
</tr>
<tr valign=top>
<td width=39%>DISP_E_BADVARTYPE</td>
<td width=61%>One of the arguments in <i>rgvarg</i> is not a valid variant type. </td>
</tr>
<tr valign=top>
<td width=39%>DISP_E_EXCEPTION</td>
<td width=61%>The application needs to raise an exception. In this case, the structure passed in <i>pExcepInfo</i> should be filled in.</td>
</tr>
<tr valign=top>
<td width=39%>DISP_E_MEMBERNOTFOUND</td>
<td width=61%>The requested member does not exist, or the call to <b>Invoke </b>tried to set the value of a read-only property.</td>
</tr>
<tr valign=top>
<td width=39%>DISP_E_NONAMEDARGS</td>
<td width=61%>This implementation of <b>IDispatch</b> does not support named arguments.</td>
</tr>
<tr valign=top>
<td width=39%>DISP_E_OVERFLOW</td>
<td width=61%>One of the arguments in <i>rgvarg</i> could not be coerced to the specified type.</td>
</tr>
<tr valign=top>
<td width=39%>DISP_E_PARAMNOTFOUND</td>
<td width=61%>One of the parameter DISPIDs does not correspond to a parameter on the method. In this case, <i>puArgErr</i> should be set to the first argument that contains the error.</td>
</tr>
<tr valign=top>
<td width=39%>DISP_E_TYPEMISMATCH</td>
<td width=61%>One or more of the arguments could not be coerced. The index within <i>rgvarg</i> of the first parameter with the incorrect type is returned in the <i>puArgErr</i> parameter.</td>
</tr>
<tr valign=top>
<td width=39%>DISP_E_UNKNOWNINTERFACE</td>
<td width=61%>The interface identifier passed in <i>riid</i> is not IID_NULL.</td>
</tr>
<tr valign=top>
<td width=39%>DISP_E_UNKNOWNLCID</td>
<td width=61%>The member being invoked interprets string arguments according to the LCID, and the LCID is not recognized. If the LCID is not needed to interpret arguments, this error should not be returned.</td>
</tr>
<tr valign=top>
<td width=39%>DISP_E_PARAMNOTOPTIONAL</td>
<td width=61%>A required parameter was omitted.</td>
</tr>
</table><br>
<p>
In 16-bit versions, you can define your own errors using the MAKE_SCODE value macro.</p>
<h4>Comments</h4>
<p>
Generally, you should not implement <b>Invoke</b> directly. Instead, use the dispatch interface create functions <a href="chap5_0mnc.htm"><b>CreateStdDispatch</b></a><b> </b>and <a href="chap5_1e79.htm"><b>DispInvoke</b></a>. For details, refer to "CreateStdDispatch" and "DispInvoke" in this chapter, and "<a href="chap2_6l5x.htm">Creating the IDispatch Interface</a>" in Chapter 2, "<a href="chap2_9nqr.htm">Exposing ActiveX Objects</a>." </p>
<p>
If some application-specific processing needs to be performed before calling a member, the code should perform the necessary actions, and then call <a href="chap9_2h7p.htm"><b>ITypeInfo::Invoke</b></a> to invoke the member. <b>ITypeInfo::Invoke</b> acts exactly like <b>IDispatch::Invoke</b>. The standard implementations of <b>IDispatch::Invoke</b> created by <b>CreateStdDispatch </b>and <b>DispInvoke </b>defer to <b>ITypeInfo::Invoke</b>.</p>
<p>
In an ActiveX client, <b>IDispatch::Invoke</b> should be used to get and set the values of properties, or to call a method of an ActiveX object. The <i>dispIdMember</i> argument identifies the member to invoke. The DISPIDs that identify members are defined by the implementor of the object and can be determined by using the object's documentation, the <a href="chap5_32cz.htm"><b>IDispatch::GetIDsOfNames</b></a> function, or the <b>ITypeInfo</b> interface.</p>
<p>
The information that follows addresses developers of ActiveX clients and others who use code to expose ActiveX objects. It describes the behavior that users of exposed objects should expect.</p>

<h4><a name="_oa96_calling_a_method_with_no_arguments"></a>Calling a Method With No Arguments</h4>
<p>
The simplest use of <b>Invoke </b>is to call a method that does not have any arguments. You only need to pass the DISPID of the method, a LCID, the DISPATCH_METHOD flag, and an empty DISPPARAMS structure. For example:</p>
<pre><code>HRESULT hresult;
IUnknown FAR* punk;
IDispatch FAR* pdisp = (IDispatch FAR*)NULL;
OLECHAR FAR* szMember = "Simple";
DISPID dispid;
DISPPARAMS dispparamsNoArgs = {NULL, NULL, 0, 0};

hresult = CoCreateInstance(CLSID_CMyObject, NULL, CLSCTX_SERVER,
                IID_Unknown, (void FAR* FAR*)&amp;punk);

hresult = punk-&gt;QueryInterface(IID_IDispatch,
                (void FAR* FAR*)&amp;pdisp);

hresult = pdisp-&gt;GetIDsOfNames(IID_NULL, &amp;szMember, 1,
                LOCALE_USER_DEFAULT, &amp;dispid);

hresult = pdisp-&gt;<b>Invoke</b>(
        dispid,
        IID_NULL,
        LOCALE_USER_DEFAULT,
        DISPATCH_METHOD,
        &amp;dispparamsNoArgs, NULL, NULL, NULL);
</code></pre>
<p>
The example invokes a method named <b>Simple</b> on an object of the class CMyObject. First, it calls <b>CoCreateInstance</b>, which instantiates the object and returns a pointer to the object's <b>IUnknown </b>interface (<code>punk</code>). Next, it calls <b>QueryInterface</b>, receiving a pointer to the object's <b>IDispatch</b> interface (<code>pdisp</code>). It then uses <code>pdisp</code><i> </i>to call the object's <b>GetIDsOfNames </b>function, passing the string <b>Simple</b> in <code>szMember</code><i> </i>to get the DISPID for the <b>Simple</b> method. With the DISPID for <b>Simple</b> in <code>dispid,</code> it calls <b>Invoke </b>to invoke the method, specifying DISPATCH_METHOD for the <code>wFlags </code>parameter and using the system default locale.</p>
<p>
To further simplify the code, the example declares a DISPPARAMS structure named <code>dispparamsNoArgs</code> that is<i> </i>appropriate to an <b>Invoke</b> call with no arguments.</p>
<p>
Because the <b>Simple</b> method does not take any arguments and does not return a result, the <code>puArgErr </code>and <code>pVarResult</code><i> </i>parameters are Null. In addition, the example passes Null for <code>pExcepInfo,</code> indicating that it is not prepared to handle exceptions and will handle only HRESULT errors.</p>
<p>
Most methods, however, take one or more arguments. To invoke these methods, the DISPPARAMS structure should be filled in, as described in "Passing Parameters" later in this chapter.</p>
<p>
Automation defines special DISPIDs for invoking an object's <b>Value</b> property (the default), and the members _<b>NewEnum,</b> and <b>Evaluate</b>. For details, see "<a href="chap6_7x2c.htm">DISPID</a>" in Chapter 6, "<a href="chap6_33eb.htm">Data Types, Structures, and Enumerations</a>." </p>

<h4><a name="_oa96_getting_and_setting_properties"></a>Getting and Setting Properties</h4>
<p>
Properties are accessed in the same way as methods, except you specify DISPATCH_PROPERTYGET or DISPATCH_PROPERTYPUT instead of DISPATCH_METHOD.<b> </b>Some languages can not distinguish between retrieving a property and calling a method. In this case, you should set the flags DISPATCH_PROPERTYGET and DISPATCH_METHOD.</p>
<p>
The following example gets the value of a property named <b>On.</b> You can assume that the object has been created, and that its interfaces have been queried, as in the previous example.</p>
<pre><code>VARIANT FAR *pVarResult;
// Code omitted for brevity.
szMember = "On";
hresult = pdisp-&gt;GetIDsOfNames(IID_NULL, &amp;szMember, 1, 
                LOCALE_USER_DEFAULT, &amp;dispid);

hresult = pdisp-&gt;Invoke(
        dispid,
        IID_NULL,
        LOCALE_USER_DEFAULT,
        DISPATCH_PROPERTYGET,
        &amp;dispparamsNoArgs, pVarResult, NULL, NULL);
</code></pre>
<p>
As in the previous example, the code calls <b>GetIDsOfNames</b> for the DISPID of the <b>On</b> property, and then passes the ID to <b>Invoke</b>. Then, <b>Invoke</b> returns the property's value in<b> </b><code>pVarResult</code><i>.</i> In general, the return value does not set VT_BYREF. However, this bit may be set and a pointer returned to the return value, if the lifetime of the return value is the same as that of the object.</p>
<p>
To change the property's value, the call looks like this:</p>
<pre><code>VARIANT FAR *pVarResult;
DISPPARAMS dispparams; 
DISPID mydispid = DISP_PROPERTYPUT

// Code omitted for brevity.

szMember = "On";
dispparams.rgvarg[0].vt = VT_BOOL;
dispparams.rgvarg[0].bool = FALSE;
dispparams.rgdispidNamedArgs = &amp;mydispid;
dispparams.cArgs = 1;
dispparams.cNamedArgs = 1;
hresult = pdisp-&gt;GetIDsOfNames(IID_NULL, &amp;szMember, 1, 
                LOCALE_USER_DEFAULT, &amp;dispid); 

hresult = pdisp-&gt;Invoke(
        dispid,
        IID_NULL,
        LOCALE_USER_DEFAULT,
        DISPATCH_PROPERTYPUT,
        &amp;dispparams, NULL, NULL, NULL);
</code></pre>
<p>
The new value for the property (the Boolean value False) is passed as an argument when the <b>On</b> property's <b>Put</b> function is invoked. The DISPID for the argument is DISPID_PROPERTYPUT. This DISPID is defined by Automation to designate the parameter that contains the new value for a property's <b>Put</b> function. The remaining details of the DISPPARAMS structure are described in the next section, "Passing Parameters." </p>
<p>
The DISPATCH_PROPERTYPUT flag in the previous example indicates that a property is being set by value. In Visual Basic, the following statement assigns the <b>Value</b> property (the default) of YourObj to the <b>Prop</b> property:</p>
<pre><code>MyObj.Prop = YourObj
</code></pre>
<p>
This statement should be flagged as a DISPATCH_PROPERTYPUT. Similarly, statements like the following assign the <b>Value</b> property of one object to the <b>Value</b> property of another object.</p>
<pre><code>Worksheet.Cell(1,1) = Worksheet.Cell(6,6)
MyDoc.Text1 = YourDoc.Text1
</code></pre>
<p>
These statements result in a PROPERTY_PUT operation on <code>Worksheet.Cell(1,1)</code> and <code>MyDoc.Text1</code>.</p>
<p>
Use the DISPATCH_PROPERTYPUTREF flag to indicate a property or data member that should be set by reference. For example, the following Visual Basic statement assigns the pointer <b>YourObj</b> to the property <b>Prop,</b> and should be flagged as DISPATCH_PROPERTYPUTREF.</p>
<pre><code>Set MyObj.Prop = YourObj
</code></pre>
<p>
The <b>Set </b>statement causes a reference assignment, rather than a value assignment.</p>
<p>
The parameter on the right side is always passed by name, and should not be accessed positionally.</p>

<h4><a name="_oa96_passing_parameters"></a>Passing Parameters</h4>
<p>
Arguments to the method or property being invoked are passed in the DISPPARAMS structure. This structure consists of a pointer to an array of arguments represented as variants, a pointer to an array of DISPIDs for named arguments, and the number of arguments in each array.</p>
<pre><code>typedef struct FARSTRUCT tagDISPPARAMS{
    VARIANTARG FAR* rgvarg;            // Array of arguments.
    DISPID FAR* rgdispidNamedArgs;     // Dispatch IDs of named arguments.
    unsigned int cArgs;                // Number of arguments.
    unsigned int cNamedArgs;         // Number of named arguments.
} DISPPARAMS;
</code></pre>
<p>
The arguments are passed<b> </b>in the array <i>rgvarg</i>[ ], with the number of arguments passed in <i>cArgs</i>.<b> </b>The arguments in the array should be placed from last to first, so <i>rgvarg</i>[0] has the last argument and <i>rgvarg</i>[<i>cArgs</i> –1] has the first argument. The method or property may change the values of elements within the array <i>rgvarg</i>, but only if it has set the VT_BYREF flag. Otherwise, consider the elements as <br>
read-only.</p>
<p>
A dispatch invocation can have named arguments as well as positional arguments. If <i>cNamedArgs</i> is 0, all the elements of <i>rgvarg</i>[ ] represent positional arguments. If <i>cNamedArgs</i> is not 0, each element of <i>rgdispidNamedArgs</i>[ ] contains the DISPID of a named argument, and the value of the argument is in the matching element of <i>rgvarg</i>[ ]. The DISPIDs of the named arguments are always contiguous in <i>rgdispidNamedArgs</i>, and their values are in the first <i>cNamedArgs</i> elements of <i>rgvarg</i>. Named arguments cannot be accessed positionally, and positional arguments cannot be named.</p>
<p>
The DISPID of an argument is its zero-based position in the argument list. For example, the following method takes three arguments.</p>
<pre><code>BOOL _export CDECL
CCredit::CheckCredit(BSTR bstrCustomerID,    // DISPID = 0.
                     BSTR bstrLenderID,        // DISPID = 1.
                     CURRENCY cLoanAmt)        // DISPID = 2.
{
// Code omitted.
}
</code></pre>
<p>
If you include the DISPID with each named argument, you can pass the named arguments to <b>Invoke</b> in any order. For example, if a method is to be invoked with two positional arguments, followed by three named arguments (<i>A, B,</i> and <i>C</i>), using the following hypothetical syntax, then <i>cArgs</i> would be 5, and <i>cNamedArgs</i> would be 3.</p>
<pre><code>object.method("arg1", "arg2",<b> </b>A := "argA", B := "argB", C := "argC")
</code></pre>
<p>
The first positional argument would be in <i>rgvarg</i>[4].<b> </b>The second positional argument would be in <i>rgvarg</i>[3]. The ordering of named arguments is not important to the <b>IDispatch</b> implementation, but these arguments are generally passed in reverse order. The argument <i>A</i> would be in <i>rgvarg</i>[2], with the DISPID of <i>A</i> in <i>rgdispidNamedArgs</i>[2].<b> </b>The argument <i>B</i> would be in <i>rgvarg</i>[1], with the corresponding DISPID in <i>rgdispidNamedArgs</i>[1].<b> </b>The argument <i>C</i> would be in <i>rgvarg</i>[0], with the DISPID corresponding to <i>C</i> in <i>rgdispidNamedArgs</i>[0]. The following diagram illustrates the arrays and their contents.</p>
<p>
<img src="images/oa07_01.gif" border=0></p>
<p>
You can also use <b>Invoke</b> on members with optional arguments, but all optional arguments must be of type VARIANT. As with required arguments, the contents of the argument vector depend on whether the arguments are positional or named. The invoked member must ensure that the arguments are valid. <b>Invoke<i> </i></b>merely passes the DISPPARAMS structure it receives.</p>
<p>
Omitting named arguments is straightforward. You would pass the arguments in <i>rgvarg</i> and their DISPIDs in <i>rgdispidNamedArgs</i>. To omit the argument named <i>B</i> (in the preceding example) you would set <i>rgvarg</i>[0] to the value of <i>C</i>, with its DISPID in <i>rgdispidNamedArgs</i>[0]; and <i>rgvarg</i>[1] to the value of <i>A,</i> with its DISPID in <i>rgdispidNamedArgs</i>[1]. The subsequent positional arguments would occupy elements 2 and 3 of the arrays. In this case, <i>cArgs</i> is 4 and <i>cNamedArgs</i> <br>
is 2.</p>
<p>
If the arguments are positional (unnamed), you would set <i>cArgs</i> to the total number of possible arguments, <i>cNamedArgs </i>to 0, and pass VT_ERROR as the type of the omitted arguments, with the status code DISP_E_PARAMNOTFOUND as the value. For example, the following code invokes <code>ShowMe (,1)</code>.</p>
<pre><code>VARIANT FAR *pVarResult;
EXCEPINFO FAR *pExcepInfo;
unsigned int FAR *puArgErr;
DISPPARAMS dispparams; 

// Code omitted for brevity.

szMember = "ShowMe";
hresult = pdisp-&gt;GetIDsOfNames(IID_NULL, &amp;szMember, 1,
                                LOCALE_USER_DEFAULT, &amp;dispid) ;
dispparams.rgvarg[0].vt = VT_I2;
dispparams.rgvarg[0].ival = 1;
dispparams.rgvarg[1].vt = VT_ERROR;
dispparams.rgvarg[1].scode = DISP_E_PARAMNOTFOUND;
dispparams.cArgs = 2;
dispparams.cNamedArgs = 0;

hresult = pdisp-&gt;Invoke(
        dispid,
        IID_NULL,
        LOCALE_USER_DEFAULT,
        DISPATCH_METHOD,
        &amp;dispparams, pVarResult, pExcepInfo, puArgErr);
</code></pre>
<p>
The example takes two positional arguments, but omits the first. Therefore, <i>rgvarg</i>[0] contains 1, the value of the last argument in the argument list, and <i>rgvarg</i>[1] contains VT_ERROR and the error return value, indicating the omitted first argument.</p>
<p>
The calling code is responsible for releasing all strings and objects referred to by <i>rgvarg</i>[ ] or placed in <i>*pVarResult</i>. As with other parameters that are passed by value, if the invoked member must maintain access to a string after returning, you should copy the string. Similarly, if the member needs access to a passed-object pointer after returning, it must call the <b>AddRef</b> function on the object.<b> </b>A common example occurs when an object property is changed to refer to a new object, using the DISPATCH_PROPERTYPUTREF flag.</p>
<p>
For those implementing <b>IDispatch::Invoke,</b> Automation provides the <a href="chap5_66nh.htm"><b>DispGetParam</b></a> function to retrieve parameters from the argument vector and coerce them to the proper type. For details, see "DispGetParam" later in this chapter.</p>

<h4><a name="_oa96_indexed_properties"></a>Indexed Properties</h4>
<p>
When you invoke indexed properties of any dimension, you must pass the indexes as additional arguments.<b> </b>To set an indexed property, place the new value in the first element of the <i>rgvarg</i>[ ] vector, and the indexes in the subsequent elements. To get an indexed property, pass the indexes in the first <i>n</i> elements of <i>rgvarg</i>, and the number of indexes in <i>cArg</i>.<i> </i><b>Invoke</b> returns the value of the property in <i>pVarResult</i>.</p>
<p>
Automation stores array data in column-major order, which is the same ordering scheme used by Visual Basic and FORTRAN, but different from C, C++, and Pascal. If you are programming in C, C++, or Pascal, you must pass the indexes in the reverse order. The following example shows how to fill the DISPPARAMS structure in C++.</p>
<pre><code>dispparams.rgvarg[0].vt = VT_I2;
dispparams.rgvarg[0].iVal = 99;
dispparams.rgvarg[1].vt = VT_I2;
dispparams.rgvarg[1].iVal = 2;
dispparams.rgvarg[2].vt = VT_I2;
dispparams.rgvarg[2].iVal = 1;
dispparams.rgdispidNamedArgs = DISPID_PROPERTYPUT;
dispparams.cArgs = 3;
dispparams.cNamedArgs = 1;
</code></pre>
<p>
The example changes the value of Prop[1,2] to 99. The new property value is passed in <i>rgvarg</i>[0]. The right-most index is passed in <code>rgvarg[1]</code>, and the next index in <code>rgvarg[2]</code>. The <code>cArgs</code><i> </i>field specifies the number of elements of <code>rgvarg[ ]</code> that contain data, and <code>cNamedArgs</code> is <code>1</code>, indicating the new value for the property.</p>
<p>
Property collections are an extension of this feature.</p>

<h4><a name="_oa96_raising_exceptions_during_invoke"></a>Raising Exceptions During Invoke</h4>
<p>
When you implement <b>IDispatch::Invoke,</b> errors can be communicated either through the normal return value or by raising an exception. An exception is a special situation that is normally handled by jumping to the nearest routine enclosing the exception handler.</p>
<p>
To raise an exception, <b>IDispatch::Invoke</b> returns DISP_E_EXCEPTION and fills the structure passed through <i>pExcepInfo </i>with information about the cause of the exception or error. You can use the information to understand the cause of the exception and proceed as necessary.</p>
<p>
The exception information structure includes an error code number that identifies the kind of exception (a string that describes the error in a human-readable way). It also includes a Help file and a Help context number that can be passed to Windows Help for details about the error. At a minimum, the error code number must be filled with a valid number.</p>
<p>
If you consider <b>IDispatch</b> another way to call C++ methods in an interface, EXCEPINFO models the raising of an exception or <b>longjmp()</b> call by such a method.</p>

<h4><a name="_oa96_returning_errors"></a>Returning Errors</h4>
<p>
<b>Invoke</b> returns DISP_E_MEMBERNOTFOUND if one of the following conditions occurs:
<ul>
<li>
A member or parameter with the specified DISPID and matching <i>cArgs </i>cannot be found<i>,</i> and the parameter is not optional.</li>
<li>
The member is a void function, and the caller did not set <i>pVarResult</i> to Null.</li>
<li>
The member is a read-only property, and the caller set <i>wFlags</i> to DISPATCH_PROPERTYPUT or DISPATCH_PROPERTYPUTREF.</li>
</ul>
<p>
If <b>Invoke</b> finds the member, but uncovers errors in the argument list, it returns one of several other errors. DISP_E_BAD_PARAMCOUNT means that the DISPPARAMS structure contains an incorrect number of parameters for the property or method. DISP_E_NONAMEDARGS means that <b>Invoke</b> received named arguments, but they are not supported by the member.</p>
<p>
DISP_E_PARAMNOTFOUND means that the correct number of parameters was passed, but the DISPID for one or more parameters was incorrect. If <b>Invoke </b>cannot convert one of the arguments to the desired type, it returns DISP_E_TYPEMISMATCH. In these two cases, if it can identify which argument is incorrect, <b>Invoke </b>sets *<i>puArgErr</i> to the index within <i>rgvarg</i> of the argument with the error. For example, if an Automation method expects a reference to a double-precision number as an argument, but receives a reference to an integer, the argument is coerced. However, if the method receives a date, <b>IDispatch::Invoke</b> returns DISP_E_TYPEMISMATCH and sets <i>*puArgErr </i>to the index of the integer in the argument array.</p>
<p>
Automation provides functions to perform standard conversions of VARIANT, and these functions should be used for consistent operation. DISP_E_TYPEMISMATCH is returned only when these functions fail. For more information about converting arguments, see Chapter 7, "<a href="chap7_5alv.htm">Conversion and Manipulation Functions</a>." </p>
<h4>Example</h4>
<p>
This code from the Lines sample file Lines.cpp implements the <b>Invoke</b> member function for the CLines class.</p>
<pre><code>STDMETHODIMP
CLines::<b>Invoke</b>(
    DISPID dispidMember,
    REFIID riid,
    LCID lcid,
    WORD wFlags,
    DISPPARAMS FAR* pDispParams,
    VARIANT FAR* pVarResult,
    EXCEPINFO FAR* pExcepInfo,
    UINT FAR* puArgErr)
{ 
    return DispInvoke(
        this, m_ptinfo,
        dispidMember, wFlags, pDispParams,
        pVarResult, pExcepInfo, puArgErr); 
}
</code></pre>
<p>
The next code example calls the <b>CLines::Invoke</b> member function to get the value of the <b>Color</b> property:</p>
<pre><code>HRESULT hr;
EXCEPINFO excepinfo;
UINT nArgErr;
VARIANT vRet;
DISPPARAMS FAR* pdisp;
OLECHAR FAR* szMember;
DISPPARAMS dispparamsNoArgs = {NULL, NULL, 0, 0};

// Initialization code omitted for brevity.
szMember = "Color";
hr = pdisp-&gt;GetIDsOfNames(IID_NULL, &amp;szMember, 1, LOCALE_USER_DEFAULT,
    &amp;dispid);

// Get Color property.
hr = pdisp-&gt;Invoke(dispid, IID_NULL, LOCALE_SYSTEM_DEFAULT,
    DISPATCH_PROPERTYGET, &amp;dispparams, &amp;vRet, &amp;excepinfo, &amp;nArgErr);
</code></pre>
<h4>See Also</h4>
<p>
<a href="chap5_0mnc.htm"><b>CreateStdDispatch</b></a>,<b> <a href="chap5_1e79.htm">DispInvoke</a></b>, <a href="chap5_66nh.htm"><b>DispGetParam</b></a>,<b> <a href="chap9_2h7p.htm">ITypeInfo::Invoke</a></b> </p>
<p>&nbsp;</p></body>
</HTML>
