<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Developing Macros for More Than One Platform</TITLE><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGPROPERTIES="FIXED" TEXT="#000000" BGCOLOR="#FFFFFF">


<FONT FACE="ARIAL,HELVETICA" SIZE="2"><H2 CLASS="h1">Developing Macros for More Than One Platform</H2><P CLASS="t">The WordBasic macro language is shared across platforms, but there are a few things to take into account when developing cross-platform macros. This section organizes cross-platform issues into three areas:</P>
<UL><LI>    Using platform-specific instructions and arguments</LI><LI>    Handling platform-level differences</LI><LI>    Moving cross-platform macros between platforms</LI></UL><P></P>
<P CLASS="t">Most of this section deals with differences between the Macintosh and Windows platforms. There are very few WordBasic differences between the Windows 3.<I>x,</I> Windows 95, and Windows NT versions of Word. For the most part, you don't need to worry about Windows differences unless you're declaring external functions, which may need to be declared differently in Windows 95 and Windows NT (see "Using the Declare Statement to Call External Routines" later in this section).</P>
<P CLASS="t">You use the <B>AppInfo$</B><B>()</B> function to return the name of the current platform. In Windows, AppInfo$(1) returns a string containing "Windows," "Windows 95," or "Windows NT" and the version number; on the Macintosh, it returns a string containing "Macintosh" and the system software version number. After you've determined the platform, you use a control structure to run the appropriate block of instructions for that platform. </P>
<P CLASS="t">The following example uses <B>InStr</B><B>()</B> to determine whether the string returned by AppInfo$(1) contains the word "Macintosh"; if it does, the flag variable, MacintoshFlag, is set to 1. A control structure then tests the value of the MacintoshFlag variable to determine whether to run instructions for Windows or for the Macintosh.</P>
<P CLASS="spacing"><BR></P>
<PRE>If Instr(AppInfo$(1), "Macintosh") &lt;&gt; 0 Then MacintoshFlag = 1
If MacintoshFlag = 0 Then
    ChDir "C:\WINWORD6\TEMPLATE"
    FileOpen "ARTICLE.DOT"
Else
    ChDir "HD:MICROSOFT WORD 6:TEMPLATES"
    FileOpen "ARTICLE TEMPLATE"
End If
</PRE>
<H3 CLASS="h3"><A NAME="sec0"></A>Using Platform-Specific Instructions and Arguments</H3><P CLASS="t">WordBasic includes a number of statements and functions that are specific to a particular platform. A statement or function intended for use on one platform only will produce an error if run on another platform. In addition, some dialog-equivalent statements take arguments that are valid on one platform only. Once you use <B>AppInfo</B><B>()</B> to determine which platform the macro is running on, you can use a control structure to ensure that platform-specific statements, functions, and arguments run only when the macro is running on the appropriate platform.</P>
<P CLASS="t">The following paragraphs describe significant areas where Windows and Macintosh statements differ. For a complete list of Macintosh- and Windows-specific statements and functions, see "Language Differences Across Versions of Word" in Part 2, "WordBasic Reference."</P>
<H4 CLASS="h4"><A NAME="sec1"></A>Differences in Page Setup</H4><P CLASS="t">Because of differences in printing and page setup in Windows and on the Macintosh, the <B>FilePageSetup</B> statement is available only in Windows. A separate set of statements is provided for page setup on the Macintosh:<B> FileDocumentLayout</B>, <B>FileMacPageSetup</B>, <B>FileMacCustomPageSetupGX</B>, and <B>FileMacPageSetupGX</B>. On a Macintosh with QuickDraw&trade; GX installed,  use <B>FileMacCustomPageSetupGX</B> and <B>FileMacPageSetupGX </B>instead of <B>FileMacPageSetup</B>. </P>
<P CLASS="t">You can use the <B>GetSystemInfo$</B><B>()</B> function to determine whether QuickDraw GX is installed. The return value of GetSystemInfo$(519) is "Yes" if QuickDraw GX is installed and "No" if it is not. </P>
<H4 CLASS="h4"><A NAME="sec2"></A>Custom Dialog Box Accelerators</H4><P CLASS="t">When you display a custom dialog box on the Macintosh, accelerators specified in the dialog box definition do not appear with an underline. However, the accelerators do work as expected. After the user presses the COMMAND key, an underline appears under the specified characters.</P>
<P CLASS="t">To automatically display accelerators in a dialog box (without the user pressing the COMMAND key), add a <B>MenuMode</B> instruction to the macro before displaying the custom dialog box, as shown in the following macro:</P>
<P CLASS="spacing"><BR></P>
<PRE>Sub MAIN
MenuMode
Begin Dialog UserDialog 320,144, "Microsoft Word"
OKButton 10, 6, 88, 21
CancelButton 10, 30, 88, 21
CheckBox 150, 84, 100, 18, "C&amp;heck Box", .CheckBox1
End Dialog
Dim dlg As UserDialog
n = Dialog(dlg)
End Sub
</PRE>
<H4 CLASS="h4"><A NAME="sec3"></A>Differences in WordBasic Sort Order </H4><P CLASS="t">The ANSI character sort order differs between the Macintosh and Windows. The specific sort order of ANSI characters is relevant when you write WordBasic macros that compare strings. The sort order is predictable for alphabetic and numeric characters (for example, "A" comes before "B" and "3" comes before "4"). However, the sort order for the remaining characters is not predictable. To determine whether "!" is greater than or less than "?" on the current platform, you can create an array of those characters and use the <B>SortArray</B><B>()</B><B> </B>function to sort them. </P>
<H4 CLASS="h4"><A NAME="sec4"></A>Screen Updating</H4><P CLASS="t">In Windows, the <B>ScreenUpdating</B> statement turns off screen updating so that changes to document and application windows are not displayed on the screen. On the Macintosh, changes within document windows are not displayed, but changes to the document window frame are displayed. For example, if a document window is moved while screen updating is turned off, the document window frame is shown in the new position. Likewise, if a document is opened while screen updating is turned off, the document's window frame will be displayed (the document itself will appear blank until screen updating is turned on, or until the macro ends).</P>
<H4 CLASS="h4"><A NAME="sec5"></A>Using SendKeys</H4><P CLASS="t">On the Macintosh, a <B>SendKeys</B> instruction can send no more than 10 keystrokes, and can send them only to Word; <B>SendKeys</B> cannot be used to send keystrokes to another application. You can send a SHIFT key combination using the plus sign (+), but you cannot send key combinations including OPTION or COMMAND. For a list of keystrokes supported by <B>SendKeys</B>, see Part 2, "WordBasic Reference."</P>
<H4 CLASS="h4"><A NAME="sec6"></A>Differences in Custom Dialog Box Capabilities</H4><P CLASS="t">On the Macintosh, you can store the picture displayed in a picture dialog box control in a "resource fork" (you can use <B>Picture</B> or <B>DlgSetPicture</B> to specify a resource fork as the storage place). Also available on the Macintosh are two instructions, <B>DlgStoreValues</B> and <B>DlgLoadValues</B><B>()</B><B>,</B> with which you can store and load custom dialog box settings. In Word version 6.0 for the Macintosh, Word version 6.0 for Windows NT, and Word version 7.0, you can use a single <B>DlgVisible</B> instruction to show or hide a range of controls (in Windows 3.<I>x</I>, a single <B>DlgVisible</B> instruction can affect one control only).</P>
<P CLASS="t">The <B>DlgFocus</B> statement does not change the focus in a Word version 6.0 for the Macintosh custom dialog box. </P>
<P CLASS="t">The following commands, which control the size or position of custom dynamic dialog boxes in the Windows versions of Word, are not available and generate errors in Word version 6.0 for the Macintosh: <B>AppSize</B>, <B>AppMove</B>, <B>AppWindowHeight</B>, <B>AppWindowWidth</B>, <B>AppWindowPosTop</B>, <B>AppWindowPosLeft</B></P>
<H4 CLASS="h4"><A NAME="sec7"></A>Making a Network Connection</H4><P CLASS="t">In Windows, you can use the <B>Connect</B> statement to connect to a network drive; on the Macintosh, you can use the <B>MountVolume</B> statement. You can use <B>Connect</B> to display the Connect dialog box; <B>MountVolume</B> does not have a dialog box associated with it.</P>
<H3 CLASS="h3"><A NAME="sec8"></A>Handling Platform-Level Differences</H3><P CLASS="t">Even when a WordBasic statement or function has the same result on all platforms, the code may need to be different. Different platforms have different system-specific functionality such as file-naming conventions that need to be considered in cross-platform macros.</P>
<H4 CLASS="h4"><A NAME="sec9"></A>Specifying Filenames and Paths</H4><P CLASS="t">In Windows, you use the question mark (?) and asterisk (*) wildcards to specify a group of files. Wildcards are not accepted on the Macintosh, but you can use the <B>MacID$</B><B>()</B> function to specify files of a certain type. A Macintosh file type is a unique four-letter label assigned to every file created by a Macintosh application (you can use the <B>FileType$</B><B>()</B> function to determine a file's type).</P>
<P CLASS="t">The following example creates a list of all the text files in a folder (the MacintoshFlag variable has been set earlier in the macro):</P>
<P CLASS="spacing"><BR></P>
<PRE>If MacintoshFlag = 0 Then
    textfilename$ = Files$("*.TXT")
Else
    textfilename$ = Files$(MacID$("TEXT"))
End If
Insert textfilename$
While textfilename$ &lt;&gt; ""
    textfilename$ = Files$()
    Insert textfilename$
Wend
</PRE>
<P CLASS="t"><B>MacID$</B><B>()</B> can also be used to specify file types with the <B>FileOpen</B> and <B>Kill</B> statements. The following instructions display the Open dialog box showing a list of all the template files in a folder (the MacintoshFlag variable has been set earlier in the macro):</P>
<P CLASS="spacing"><BR></P>
<PRE>Dim dlg as FileOpen
GetCurValues dlg
If MacintoshFlag = 0 Then
    Chdir "C:\WINWORD\TEMPLATE"
    dlg.Name = "*.DOT"
Else
    Chdir "HD1:WORD:TEMPLATES"
    dlg.Name = MacID$("WTBN")
End If
choice = Dialog(dlg)
If choice Then FileOpen dlg
</PRE>
<P></P>
<P CLASS="nh"><B>Note</B></P>
<P CLASS="nt">Although <B>MacID$</B><B>()</B> appears to return a string, it actually returns a value that doesn't correspond to any WordBasic data type. Consequently, <B>MacID$</B><B>()</B> should be used only with the statements described here that accept the internal value it returns. In addition, you cannot concatenate the value returned by <B>MacID$</B><B>()</B> with a path string; instead, you use <B>ChDir</B> to change the current folder.</P>
<P></P>
<P CLASS="t">You can use <B>MacID$</B><B>()</B> with a Macintosh application signature to specify an application. <B>MacID$</B><B>()</B> can be used to specify an application with the following instructions: <B>AppActivate</B>, <B>AppClose</B>, <B>AppCount</B>, <B>AppGetNames</B>, <B>AppGetNames</B><B>()</B>, <B>AppIsRunning</B><B>()</B>, and <B>Shell</B>. <B>MacID$</B><B>()</B> provides a more reliable way to specify an application than the application name, because the user may change the application name but is not likely to change the Macintosh application signature. The following example uses <B>MacID$</B><B>()</B> with <B>AppIsRunning</B><B>()</B> and <B>Shell</B> to determine whether Microsoft Excel is running, and to start it if it isn't.</P>
<P CLASS="spacing"><BR></P>
<PRE>If AppIsRunning(MacID$("XCEL")) = 0 Then Shell MacID$("XCEL")
</PRE>
<P CLASS="t">Note that you don't need to specify a path or folder when you use <B>MacID$</B><B>()</B> to specify an application.</P>
<H4 CLASS="h4"><A NAME="sec10"></A>Using Settings Files</H4><P CLASS="t">There are a few differences to be aware of when working with settings files in Windows 3.<I>x</I> and on the Macintosh.</P>
<UL><LI>    If you don't specify a path in the filename for<B> SetPrivateProfileString</B> or <B>GetPrivateProfileString</B>, Word stores or looks for the file in the Windows folder in Windows or the Preferences folder on the Macintosh. </LI><LI>    In Windows, settings files are text files and they can be opened by a text editor like any other text file. On the Macintosh, settings files are not text files; they can be edited directly using the <B>ToolsAdvancedSettings</B> command or the ResEdit program.</LI><LI>    The Macintosh does not include an equivalent of the Windows WIN.INI file that can be accessed by <B>SetProfileString</B> and <B>GetProfileString$</B><B>()</B>.</LI><LI>    In Word version 6.0 for Windows, settings are stored in a settings file called WINWORD6.INI; in Word version 6.0 for the Macintosh, they're stored in a file called Word Settings (6). You can use <B>SetPrivateProfileString</B> and <B>GetPrivateProfileString$</B><B>()</B> to change settings in WINWORD6.INI or Word Settings (6). For example:
<P CLASS="spacing"><BR></P>
<PRE>a$ = GetPrivateProfileString$("Microsoft Word", "USER-DOT-PATH", \<BR>    "Word Settings (6)")
</PRE></LI></UL><P></P>
<P></P>
<P CLASS="nh"><B>Note</B></P>
<P CLASS="nt">Windows 95 and Windows NT do not use the settings files WIN.INI and WINWORD6.INI. Instead, settings are stored in the registry. For information about returning and setting values in the registry, see "Accessing the Windows Registry" earlier in this chapter. </P>
<P></P>
<H4 CLASS="h4"><A NAME="sec11"></A>Working with DDE</H4><P CLASS="t">When an application runs on more than one platform, the same application may have a different application name in Windows and on the Macintosh. For example, in Windows, the DDE application name for Microsoft Word is "WinWord," whereas on the Macintosh, it's "MSWord," although "WinWord" is also accepted.</P>
<P CLASS="t">The instructions used to initiate DDE conversations are the same in Windows and on the Macintosh, but since DDE application names may be different on different platforms, separate instructions may be necessary for each platform. Also, it's a good idea to use <B>MacID$</B><B>()</B> to specify an application on the Macintosh if you use the <B>AppIsRunning</B><B>()</B> and <B>Shell</B> instructions when initiating a DDE conversation. In the following example, a different block of instructions for each platform is used to initiate a DDE conversation with Microsoft Excel (the MacintoshFlag variable has been set earlier in the macro). Note that Microsoft Excel has the same DDE application name in Windows and on the Macintosh, so separate <B>DDEInitiate</B><B>()</B> instructions are not needed.</P>
<P CLASS="spacing"><BR></P>
<PRE>If MacintoshFlag = 0 Then
    If AppIsRunning("Microsoft Excel")&nbsp;=&nbsp;0 Then Shell "EXCEL.EXE", 4
    chan&nbsp;=&nbsp;DDEInitiate("Excel", "System")
Else
    If AppIsRunning(MacID$("XCEL"))&nbsp;=&nbsp;0 Then Shell MacID$("XCEL"), 4
    chan&nbsp;=&nbsp;DDEInitiate("Microsoft Excel", "System")
End If
chan&nbsp;=&nbsp;DDEInitiate("Excel", "System")
topics$&nbsp;=&nbsp;DDERequest$(chan, "Topics")
Insert topics$
</PRE>
<H4 CLASS="h4"><A NAME="sec12"></A>Using the Declare Statement to Call External Routines</H4><P CLASS="t">In Windows, you can use the <B>Declare</B> statement to call routines stored in a dynamic-link library (DLL) or a Word add-in library (WLL). On the Macintosh, only routines stored in a WLL can be called. When a macro created in a Windows version of Word  is converted to Word version 6.0 for the Macintosh, any <B>Declare</B> statements that refer to Windows DLLs will return the WordBasic error 543, "Unable to open specified library." </P>
<P CLASS="t"><B>Declare</B> instructions in macros ported from Word version 6.0 for Windows to Word version 7.0 or Word version 6.0 for Windows NT need to be modified. Because you cannot declare an external routine in a 16-bit library from a 32-bit application, such as Word version 7.0 or Word version 6.0 for Windows NT, you must update macros that declare routines in 16-bit libraries to identify the 32-bit versions of those libraries. Also the names, locations, and parameters of many Windows 3.<I>x</I> operating system routines (often referred to as API calls) changed in Windows 95 and Windows NT. You must update macros that declare Windows 3.<I>x</I> API calls to declare the correct routines in Windows 95 or Windows NT. Windows 95 and Windows NT function libraries are documented in the Microsoft Win32 Software Development Kit.</P>
<P CLASS="t">Unlike routine names in Windows 3.<I>x</I>, routine names are case-sensitive in Windows 95 and Windows NT. In addition, some routines need to be declared with different variable types in Windows 95 or Windows NT: INT return values or parameters must be declared as LONG; handles must be declared as LONG. For more information on using the <B>Declare</B> statement, see "Calling Routines in DLLs" earlier in this chapter.</P>
<H3 CLASS="h3"><A NAME="sec13"></A>Moving a Cross-Platform Macro Between Platforms</H3><P CLASS="t">There are two potential problems that can occur when you move a macro with platform-specific instructions between Word version 6.0 for Windows and Word version 6.0 for the Macintosh. These problems occur when one version of Word does not recognize instructions that are supported in another version. Specifically, Word version 6.0, 6.0a, and 6.0c for Windows do not support the Macintosh-specific WordBasic statements and functions available in Word version 6.0 for the Macintosh. In this situation, the following two problems can occur:</P>
<UL><LI>    If you develop a macro in Word version 6.0, 6.0a, or 6.0c for Windows and then move the macro to Word version 6.0 for the Macintosh, instructions specific to the Macintosh version of Word will produce an error —  error 124, "Unknown command, subroutine, or function" —  until the macro is edited on the Macintosh (the macro must be "dirtied").</LI><LI>    If you develop a macro in Word version 6.0 for the Macintosh, move the macro to Word version 6.0 or 6.0a for Windows, and then edit and save the macro in Windows, Macintosh-specific keywords will be removed from the macro; they will not be restored if the macro is moved back to the Macintosh. (The macro should still run correctly in Windows, since the Macintosh-specific instructions should not run on the Windows platform anyway. But the macro will no longer run correctly if it is moved back to the Macintosh.) Note that this problem does not occur in Word version 6.0c for Windows.</LI></UL><P></P>
<P></P>
<P CLASS="nh"><B>Note</B></P>
<P CLASS="nt">These problems do not occur if you develop cross platform macros in Word version 7.0 or Word version 6.0 for Windows NT.</P>
<P></P>
<P CLASS="t">Typically, a cross-platform macro is developed on one platform and then tested on the other platforms for which it is intended. If you're working with Word version 6.0 or 6.0a for Windows, you need to avoid editing the macro on more than one platform. That is, once you choose a platform for developing a Word 6.0 or 6.0a cross-platform macro, you must stick with it; if you edit the macro on more than one platform, you may encounter problems.</P>
<P CLASS="t">If you develop cross-platform macros in Word for Windows, you need to make sure the macros run properly on the Macintosh before you distribute them. You may want to distribute your cross-platform macros in execute-only format so that they cannot be edited (you use the <B>MacroCopy </B>statement to make a macro execute-only). If you don't want to distribute your cross-platform macros in execute-only format (that is, if you don't want to disable editing), you run the risk that a user will edit the macro. </P>
<P></P>

<TABLE COLS="1" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="348pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><FONT FACE="ARIAL,HELVETICA" SIZE="2"><P CLASS="sbrh"><B>Moving a Macro with Extended Characters Between Platforms</B></P>
<P CLASS="sbrt">In Windows and on the Macintosh, different character codes are used to represent international characters. If you create a macro that contains string values with international characters in them (for example, á, ç, and ö), these characters will change when the macro is opened or run on another platform. To avoid this result, use the following steps to move the macro between platforms:</P>
<P CLASS="sbrlb">1.    Copy the text of the macro from the macro-editing window into a new document and save the document.</P>
<P CLASS="sbrlb">2.    Open the document on the other platform, save it in Text Only format, close it, and then open it again.</P>
<P CLASS="sbrlb">3.    Copy the text from the document into a new macro-editing window.</P>
<P></P>
<P CLASS="sbrt">Note that distributing a macro as execute-only does not correct this behavior. If you need to distribute a macro with extended characters in string values, you must create separate templates with unique versions of the macro for each platform.</P>
<P CLASS="sbrh"><B></B></P></FONT></TD></TR></TBODY></TABLE>
<P CLASS="spacing"><BR></P><P></P></FONT></FONT></BODY></HTML>
