<HTML><HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Chapter 3  Sample Application 1: West Coast Airways</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><body bgcolor="#FFFFFF" link=#003399 vlink=#996699>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><FONT FACE="Verdana, Arial, Hevetica" SIZE="2">

<H1 CLASS="title">Chapter 3  Sample Application 1: West Coast Airways</H1><P CLASS="t">In this chapter, we take the concepts that the first two chapters covered and use them to build an application in Microsoft Excel. Let's start by taking a glance at what the completed application will look like. If you have access to a computer as you read, start Excel and open the file named CHAP03-1.XLS on the companion disk packaged with this book.</P>
<H1><A NAME="sec0"></A>What the Application Does</H1><P CLASS="t">The sample application we're looking at uses as its subject a fictitious airline named West Coast Airways. West Coast Airways does business in the western United States, serving Arizona, California, Colorado, Idaho, Montana, Nevada, Oregon, Utah, Washington, and Wyoming. The application was developed solely in Excel 5 and is used by the company and specifically by its president to track summary financial data for each of the West Coast Airways sales offices—the company has one sales office in each state in which it does business. The application presents revenue and profit data in various formats for analysis, a few of which are shown in Figure 3-1 on the next page.</P>
<P CLASS="t">Users move from one format to another by choosing buttons to move to different Excel sheets, which we refer to as "forms." (The pictures and maps you see on these forms were created in drawing programs and imported as bitmaps.)</P>
<P><img src="F03RC01.gif"></P>
<P>Figure 3-1. <I>Some of the formats in which the West Coast Airways application displays data.</I></P>
<H2><A NAME="sec1"></A>The Control Form</H2><P CLASS="t">As soon as CHAP03-1.XLS is opened, Excel displays the main form of the application, the Control form. The Control form is used to access the various forms in the application and has several elements: a title box, some graphics, a listbox, and some buttons on a blue background.</P>
<P><img src="G03RC01.gif"></P>
<P CLASS="t">Here is a list of the objects required to create these elements:</P>
<P CLASS="t"><B>Worksheet object:</B> This object serves as the basis for the form; the whole area that makes up the form is, indeed, an Excel worksheet.</P>
<P CLASS="t"><B>TextBox object:</B> The title at the top of the screen, "West Coast Airways," is an Excel TextBox object.</P>
<P CLASS="t"><B>Picture objects:</B> Four Picture objects appear on the main form; these are the four small airplanes below the title.</P>
<P CLASS="t"><B>ListBox object:</B> The ListBox object appears in the lower left portion of the form and displays a list of the states in which the company does business. The user can select a state from the list to display sales information about that state.</P>
<P CLASS="t"><B>Button objects:</B> Three Button objects appear in the lower right portion of the screen: Map Sheet, Summary Data, and Quit. The user can choose these buttons either to see color-coded maps that show financial information at a glance or to quit the application.</P>
<P CLASS="t"><B>Range object:</B> It isn't obvious, but the Range object has been used to design this form. The blue background is a range of worksheet cells that have been colored blue so that the screen looks like a form instead of a spreadsheet.</P>
<H2><A NAME="sec2"></A>The State Forms</H2><P CLASS="t">Each state form shows summary financial information about a specific state. To display a state form, select a state from the listbox on the Control form. Selecting California from the list, for example, runs a Visual Basic for Applications (VBA) macro that activates the California form. A state form contains several Excel objects:</P>
<P><img src="G03RC02.gif"></P>
<P CLASS="t"><B>Button object:</B> The button at the top of the sheet is the Control button; choosing it activates the Control form.</P>
<P CLASS="t"><B>Picture object:</B> Each state form includes a map of the selected state in the form of an imported bitmap. The maps contained in this application were created in a product called MapLand by Software Illustrated. The user can click this map to activate the map form. (See the next section.)</P>
<P CLASS="t"><B>Rectangle object:</B> Behind the state map is a dark gray area; this is an Excel Rectangle object that has been colored gray.</P>
<P CLASS="t"><B>TextBox object:</B> Beneath the map, an Excel TextBox object displays the name of the state.</P>
<P CLASS="t"><B>Range objects:</B> In the upper right portion of the screen, a table displays financial data specific to the selected state. This table is merely a range of cells in which data has been entered; the cells have been formatted using various colors and special effects to make them visually appealing. Note that a range of cells lies behind the other objects on the form; the gridlines have been removed to give the cells the appearance of plain white space.</P>
<P CLASS="t"><B>ChartObject object:</B> Below the table is a ChartObject object—or what is known as an on-sheet chart. As mentioned earlier, Excel uses two types of objects for charts: a chart that floats as a graphical object on a sheet—known as a ChartObject object—and a chart that exists on a separate sheet by itself—known as a Chart object. The ChartObject object in this case graphically displays the data from the range of cells above it and is actually linked to the cells. If the data in the cells changes, the ChartObject object is automatically updated.</P>
<P CLASS="t"><B>Worksheet object:</B> Again, the Worksheet object is the basis for this form.</P>
<P CLASS="t">The California form shows summary financial data for West Coast Airways business in the state of California. You'll notice that the table in the upper right displays data for the years 1993 and 1994 along with the percentage difference for various values between those two years. The chart in the lower right is linked to the table. The map of California and the textbox under the map visually key the user to the category of data being displayed on the form—namely, that for California. You'll notice that the map is color coded based on the percentage change in revenue from 1993 to 1994. If the revenue decreases by more than 20 percent, the map is red; if the change is between <FONT FACE="Verdana, Arial, Helvetica" SIZE="2">-</FONT>20 percent and 20 percent, the map is green; if the change is greater than 20 percent, the map is blue. After reviewing the data for California, you can choose the Control button to run a macro that activates the Control form. On the Control form, try selecting some of the other states from the listbox. You'll see that each of the state forms is constructed in the same manner.</P>
<H2><A NAME="sec3"></A>The Map Form</H2><P CLASS="t">On the Control form, choose the Map Sheet button to display the map form. The map form shows a color-coded map of the western United States, which gives the user a quick view of how West Coast Airways is doing throughout the region. The map form contains these objects:</P>
<P><img src="G03RC03O.gif"></P>
<P CLASS="t"><B>Button object:</B> Choosing the Control button activates the Control form.</P>
<P CLASS="t"><B>Picture objects:</B> Ten Picture objects appear on this form; they are bitmaps, each of which depicts a state in which West Coast Airways does business. Together, they form a map of the western United States.</P>
<P CLASS="t"><B>OptionButton objects:</B> Two OptionButton objects—Revenue and Net Income— are displayed on the left side of the form below the Control button.</P>
<P CLASS="t"><B>TextBox object:</B> Under the optionbuttons, a TextBox object displays a legend for the colors in the map.</P>
<P CLASS="t"><B>Range object:</B> A range of gray cells that lies behind the other objects.</P>
<P CLASS="t"><B>Worksheet object:</B> Again, the Worksheet object is the basis for this form.</P>
<P CLASS="t">The map form gives the user an immediate impression of how the company is doing in the different states—in terms of either revenue or net income (profit). By selecting either the Revenue or the Net Income optionbutton, the user launches a macro that updates the map with the appropriate data. The macro retrieves the numbers for percentage changes in revenue (growth) or net income from the state forms and colors the individual states appropriately. Try selecting the Revenue and Net Income optionbuttons now, and notice how the states change color. The user can choose the Control button to activate the Control form or click any of the individual states on the map to run a macro that activates the state form for the selected state. Try clicking some of the states on the map form now to activate the respective state forms. Recall that you can return to the map form from a state form by clicking the state map. After viewing data in the map and state forms, choose the Control button to return to the Control form.</P>
<H2><A NAME="sec4"></A>The SummaryData Form</H2><P CLASS="t">The second button on the Control form is the Summary Data button. Choose this button now to run a macro that activates the SummaryData form, which summarizes data for all of the states served by the company. The SummaryData form contains a number of objects:</P>
<P><img src="G03RC04.gif"></P>
<P CLASS="t"><B>Button object:</B> Choosing the Control button activates the Control form.</P>
<P CLASS="t"><B>OptionButton objects:</B> The Revenue and Net Income OptionButton objects control which type of data is displayed in the chart.</P>
<P CLASS="t"><B>Range objects:</B> A Range object holds the cells in the table that summarizes the data for the whole company. The table contains formulas that are linked to the individual state forms; if the data on one of the state forms changes, Excel automatically updates the table on the SummaryData form. A range of gray cells also lies behind the other objects.</P>
<P CLASS="t"><B>ChartObject object:</B> The on-sheet chart displays the data from the table in the form of a three-dimensional pie chart. The chart also includes a legend and a title and is automatically updated if the table changes.</P>
<P CLASS="t"><B>Worksheet object:</B> The Worksheet object is the basis for the form.</P>
<P CLASS="t">Selecting the Revenue or Net Income optionbutton changes the data displayed in the chart. The ChartObject object linked to the data in the table displays either "Revenue" or "Net Income" in the title above the chart. Notice the number formatting applied to the data in the table: All numbers are formatted as currency, and negative numbers are enclosed in parentheses.</P>
<H2><A NAME="sec5"></A>Flaws in the West Coast Airways Application</H2><P CLASS="t">Because the West Coast Airways application is such a simple one, it would probably serve best as a prototype rather than as an actual information system. Taking a critical eye to the application shows that it suffers from several flaws that would limit its use in a real-world setting.</P>
<P CLASS="t">First, the application offers no mechanism for getting data into the application other than entering it manually. Instead, the application could be set up so that the manager for each state's operation could enter data in the separate state forms and then forward the forms to the company's Finance Department viae-mail; there, the forms could be combined with the rest of the data for the West Coast Airways system. Or the state forms could use database queries that would import data from a corporate database directly into the state forms.</P>
<P CLASS="t">The second flaw involves protection of data. Nothing has been done to protect the data in the forms or the individual objects that reside on the forms. In any of the tables on the various state forms or on the SummaryData form, any user can enter any data in any of the cells. A real-world application, on the other hand, would use different levels of protection. Some elements of the application would be fully protected, and other elements would allow for different levels of access so that only certain users could change or enter certain values.</P>
<P CLASS="t">The application's third flaw lies in some of the Excel interface artifacts that are displayed on the screen. For example, unless you've changed your menu and toolbar settings manually, the standard Excel menubar with all the standard menus is displayed at the top of the Excel screen, and some Excel toolbars are visible. A professional application would not allow these or any other Excel artifacts to be displayed, in order to give the impression that a true stand-alone application—not an Excel macro—is being used.</P>
<P CLASS="t">The fourth flaw in the application is that it does not provide any mechanism for printing or distributing data. The user could choose the Print command from the Excel File menu and print any screen; however, this possibility might not be obvious to a user who is not familiar with Excel. A professional application would provide a simple interface to allow the user to print data and might also allow the user to distribute the data over e-mail.</P>
<P CLASS="t">All of these flaws are easily eliminated by taking advantage of Excel's more advanced objects—objects that deal with database access, control of user input, interaction with e-mail systems, and the Excel environment. We will not fix these flaws here, but in upcoming chapters in this book you will learn about the more advanced Excel objects that allow you to build a fully functional information system.</P>
<H2><A NAME="sec6"></A>Flying the Planes</H2><P CLASS="t">Before you close the West Coast Airways application, you should be aware of one feature we have not yet explored. If you click any of the airplane bitmaps or the title box on the Control form, you can make the airplanes "fly." For a few seconds, the four airplanes move in succession across the screen and wrap around again, giving the impression of flight. You've actually launched a macro that uses a For-Next loop to give this animated effect. After you finish watching the airplanes fly across the screen, you can choose the Quit button to close the West Coast Airways application. Quit runs a macro that closes the file that contains the application but does not exit Excel.</P>
<H2><A NAME="sec7"></A>Moving On</H2><P CLASS="t">Shortly, we'll look at all of the macro code behind this application and even look at code that was used to build some of the application's interface elements. But first let's investigate some of the objects that this application includes.</P>
<H1><A NAME="sec8"></A>Excel Objects Used in the West Coast Airways Application</H1><P CLASS="t">In Chapter 1, we looked briefly at the purpose and function of a few Excel objects: Application, Workbook, Worksheet, and Range. The West Coast Airways application uses all of these objects plus a few others, most of which are graphical: Picture, ListBox, Button, Rectangle, TextBox, ChartObject, and OptionButton. All of these additional objects fall into a special class in Excel 5 known as "DrawingObject objects." In fact, a special collection called the "DrawingObjects collection" contains all of these objects, as well as some others. The DrawingObjects collection is a special collection in Excel 5 that contains objects of different types. It is itself contained in three different kinds of objects in Excel 5: Worksheet, DialogSheet, and Chart.</P>
<P CLASS="nt"><B>Note   </B>"Object A contains Object B" or "Collection A contains Object B" means that Object B is one level directly below A in the Excel object hierarchy, described in Chapter 1. Refer to Figure 1-2 on page 18, but note that the step in levels between a <I>collection</I> and a subobjectis illustrated quite differently from the step in levels between a <I>singular object</I> and a subobject. (Recall that a collection is itself a singular object and that you call a method on a collection with an index or a name argument to get to the subobjects it contains. You use a property, on the other hand, to get to a singular subobject.)</P>
<P CLASS="t">All floating graphical objects in Excel fall below the DrawingObjects collection in the Excel object hierarchy. It makes sense, then, that this collection is contained in the Worksheet, DialogSheet, and Chart objects because these three objects can serve as forms for designing user interfaces. You use objects from the DrawingObjects collection to add graphical elements and controls to such forms.</P>
<H2><A NAME="sec9"></A>The DrawingObjects Collection</H2><P CLASS="t">The DrawingObjects collection contains several objects, all of which are also contained in their own separate object-specific collections. Following is a list of all objects that fall beneath DrawingObjects in the Excel object hierarchy.</P>
<P CLASS="t">This list has been broken down into two different sections: "Graphical objects" and "Controls." A graphical object is used to design custom forms. A control, on the other hand, is an object that a user usually manipulates with a mouse to launch a macro.</P>
<H4><I>Graphical objects</I></H4>
<P CLASS="t"><B>ChartObject:</B> An on-sheet chart that is linked to a range of data.</P>
<P CLASS="t"><B>GroupObject:</B> A set of objects that have been grouped together to create a single object so that all the objects can be manipulated as a unit.</P>
<P CLASS="t"><B>OLEObject:</B> A linked or embedded OLE object.</P>
<P CLASS="t"><B>Drawing:</B> A polygon created with the Excel Freeform drawing tool on the Drawing toolbar.</P>
<P CLASS="t"><B>Picture:</B> An imported bitmap generated in a third-party drawing program.</P>
<P CLASS="t"><B>TextBox:</B> A box that contains text. (A textbox can be blank.)</P>
<P CLASS="t"><B>Label:</B> A static text label. Labels are often used with controls.</P>
<P CLASS="t"><B>Arc:</B> An arc.</P>
<P CLASS="t"><B>Line:</B> A line.</P>
<P CLASS="t"><B>Oval:</B> An oval.</P>
<P CLASS="t"><B>Rectangle:</B> A rectangle.</P>
<H4><I>Controls</I></H4>
<P CLASS="t"><B>Button:</B> A button control.</P>
<P CLASS="t"><B>CheckBox:</B> A checkbox control that turns on and off with alternating clicks of the mouse.</P>
<P CLASS="t"><B>DropDown:</B> A dropdown list.</P>
<P CLASS="t"><B>GroupBox:</B> A box used to group OptionButton objects so that only one option can be set at a time.</P>
<P CLASS="t"><B>ListBox:</B> A standard listbox control.</P>
<P CLASS="t"><B>OptionButton:</B> An optionbutton control for which only one button in a group can be selected at a time.</P>
<P CLASS="t"><B>ScrollBar:</B> A scrollbar control used to increment or decrement a value by using a slider.</P>
<P CLASS="t"><B>Spinner:</B> A spinner control used to increment or decrement a value by clicking  the up or down arrow.</P>
<P CLASS="t"><B>EditBox:</B> An editbox control used to enter text (on dialogsheets only).</P>
<P CLASS="nt"><B>Note   </B>All of these objects are "objects in collections" and can be accessed either from their own collections or from the DrawingObjects collection. This is similar to the Sheets and Worksheets collections; each worksheet is contained both in the Worksheets collection and—along with other types of sheets—in the Sheets collection. Being able to use either the DrawingObjects collection or a specific collection allows you to perform the same action easily on all drawingobjects or on only certain kinds of drawingobjects.</P>
<H4><I>Graphical objects</I></H4>
<P CLASS="t">Although each of the objects in the "graphical objects" category on the preceding two pages has its own unique set of properties and methods, these objects also have a set of shared properties and methods. Below is a list of the properties that the graphical objects share. A list of the methods that the graphical objects share follows.</P>
<P CLASS="t"><B>Border:</B> Returns the border of the object (can be used to set the border's line style; does not apply to the Label object).</P>
<P CLASS="t"><B>BottomRightCell:</B> Applies only to objects on worksheets; returns the cell under the bottom right corner of the object.</P>
<P CLASS="t"><B>Enabled:</B> If True, the user can click the object to launch a macro if one has been assigned. If False, the user cannot launch a macro by clicking the object.</P>
<P CLASS="t"><B>Height:</B> The height of the object in points. (A point is 1/72 of an inch.)</P>
<P CLASS="t"><B>Interior:</B> Returns the interior of the object and is usually used to set the color (does not apply to the Line object).</P>
<P CLASS="t"><B>Left:</B> The distance in points (1/72 inch) that the object lies from the left border of the chart, worksheet, or dialogsheet on which the object resides.</P>
<P CLASS="t"><B>Locked:</B> If True, the user cannot manipulate the object in any way when the sheet is protected. If False, even if the sheet is protected, the object can be manipulated.</P>
<P CLASS="t"><B>Name:</B> The name of the object.</P>
<P CLASS="t"><B>OnAction:</B> The name of a macro that runs when the user clicks the object.</P>
<P CLASS="t"><B>Placement:</B> Can be one of three values: xlMoveAndSize (the object moves and resizes with the cells underneath it), xlMove (the object moves but does not resize with the cells underneath it), or xlFreeFloating (the object neither moves nor resizes with the cells underneath it). This property applies only to graphical objects on worksheets.</P>
<P CLASS="t"><B>PrintObject:</B> If True, the object is printed when a user prints the sheet. If False, the object does not appear on printouts.</P>
<P CLASS="t"><B>RoundedCorners:</B> If True, the object is displayed with rounded corners; if False, the object is displayed with square (90-degree-angle) corners (applies to the ChartObject, GroupObject, Rectangle, and TextBox objects only).</P>
<P CLASS="t"><B>Shadow:</B> If True, the object is displayed with a shadow behind it (does not apply to the Arc, Line, or Label objects).</P>
<P CLASS="t"><B>Top:</B> The distance in points (1/72 inch) that the object lies from the top border of the chart, worksheet, or dialogsheet on which the object resides.</P>
<P CLASS="t"><B>TopLeftCell:</B> Applies only to objects on worksheets; returns the cell under the top left corner of the object.</P>
<P CLASS="t"><B>Visible:</B> If True, the object is displayed. If False, the object is hidden from view.</P>
<P CLASS="t"><B>Width:</B> The width of the object in points (1/72 inch).</P>
<P CLASS="t"><B>ZOrder:</B> A placement order in which the object falls in the screen area in which the object resides. This order is used when objects are stacked on top of one another. A ZOrder of 1, for example, means that an object is hidden by any other object that overlaps it on the screen.</P>
<P CLASS="t">The following list shows the set of methods that graphical objects share:</P>
<P CLASS="t"><B>BringToFront:</B> Brings an object to the top of a three-dimensional stack of objects.</P>
<P CLASS="t"><B>Copy:</B> Copies the object to the clipboard.</P>
<P CLASS="t"><B>CopyPicture:</B> Copies the object to the clipboard as a picture.</P>
<P CLASS="t"><B>Cut:</B> Deletes the object and places it on the clipboard.</P>
<P CLASS="t"><B>Delete:</B> Deletes the object.</P>
<P CLASS="t"><B>Duplicate:</B> Duplicates the object (copies and pastes it in one action).</P>
<P CLASS="t"><B>Select:</B> Selects the object.</P>
<P CLASS="t"><B>SendToBack:</B> Places the object behind any overlapping objects on the screen (that is, sets the ZOrder property to 1).</P>
<P CLASS="nt"><B>Note   </B>Because all of these graphical objects share a common set of properties and methods, you have only one set of properties and methods to learn. Then the one set can be used for all of the graphical objects to which the properties and methods apply. Note that a number of the control objects in the DrawingObjects collection share some of the properties and methods listed above.</P>
<H1><A NAME="sec10"></A>Building the West Coast Airways Application</H1><P CLASS="t">Now that we've summarized the objects that are used in the West Coast Airways application, let's build it. A good place to start is with a conceptual understanding of the flow of the application. The diagram at the top of the next page shows the various paths the user can take when navigating the West Coast Airways system:</P>
<P><img src="CHART.gif"></P>
<P CLASS="t">We should also consider the flow of data in the application. The data that governs the application resides in the state forms. The SummaryData form, however, contains a table in which formulas are linked to the data in the state forms, and the map form contains maps that are color coded based on the data in the state forms. Here's how data in the application flows:</P>
<P><img src="CHART2.gif"></P>
<H2><A NAME="sec11"></A>Beginning the Process of Building the Application</H2><P CLASS="t">We'll begin building the application by using a workbook in which some of the objects are already placed in their appropriate positions on various worksheets. Open the file CHAP03-2.XLS, which is included on the companion disk packaged with this book. After you open the file, you'll see a workbook that contains five sheets: Template, Module1, Control, SummaryData, and MapSheet. The worksheet named Template will be used as a template for making the individual state forms. Module1 will hold the VBA code for the application. Control, SummaryData, and MapSheet will be used to design the Control, SummaryData, and map forms.</P>
<P CLASS="t">Throughout the rest of this chapter, we will analyze several macros that you can use to build the application. All of these macros are contained in the text file named CHAP03.TXT. You can choose either to import the text file directly into Module1 of the file CHAP03-2.XLS and run the macros as you read or to type the macros manually as they appear in this chapter. To import the text file, click the Module1 tab to activate the module. Next choose the File command from the Insert menu, and then select CHAP03.TXT and choose OK. The code from the text file then appears in the body of the VBA module. To get the most out of this chapter, you might want to instead write the macros by yourself after reading about each macro. You can then use the code in CHAP03.TXT as a backup should you find it difficult to get your macros to run properly.</P>
<H2><A NAME="sec12"></A>Option Statements</H2><P CLASS="t">The code in this application uses arrays in a few different instances. To ensure that array indexing always starts at 1 (as opposed to 0), enter as the first line of code in Module1 an Option Base statement:</P>
<P CLASS="spacing"><BR></P>
<PRE><FONT FACE="Courier" SIZE="2"><B>Option Base</B> 1</FONT></PRE>
<P CLASS="t">You might also want to turn on forced variable declaration while writing your code. To do so, type the following statement at the top of the VBA module under the Option Base 1 statement:</P>
<P CLASS="spacing"><BR></P>
<PRE><FONT FACE="Courier" SIZE="2"><B>Option Explicit</B></FONT></PRE>
<H2><A NAME="sec13"></A>Creating the State Forms</H2><P CLASS="t">So far, no worksheets in the workbook represent the different state forms. We will need 10 such state form worksheets. Each worksheet will be formatted in exactly the same manner—with a Control button, a map, a table of fictitious data, and a chart linked to that data. As a result, we can probably save time by using macros to set up the worksheets, as opposed to setting up each worksheet separately.</P>
<H3>Using a worksheet template</H3>
<P CLASS="t">To help begin the process of setting up the 10 worksheets, the Template worksheet is included in the CHAP03-2.XLS workbook. Click the Template tab to take a look at it. You will notice that a formatted table in the upper right area of the worksheet depicts revenue and profit for 1993 and 1994 as well as the percentage difference for such values between the two years.</P>
<P CLASS="t">If the formula bar is not currently displayed in Excel, choose the Formula Bar command from the View menu. The formula bar is a thin bar that resides just above the worksheet (see Figure 2-1 on page 38); it serves two purposes. The right portion of the formula bar can be used to enter data and formulas in cells; the left portion of the formula bar contains the Name drop-down list box, which you can use to manually set the Name property of any range or DrawingObject object on the worksheet. (You can also use the Name box to go to a cell on the worksheet; if you select a name from the list, Excel selects the cell that matches the name.) If you look at the contents of the cells in the ranges F4:G6 and F9:G10 on the Template worksheet, you see formulas that contain the RAND() worksheet function for generating random numbers. The RAND() function has been used here merely to generate fictitious data. If  you select F4:G6, the name Rand1 is displayed in the Name box; likewise, if you select F9:G10, the name Rand2 is displayed. As you will see later in this chapter, these range names will be employed in one of the macros used to set up the application. Also note that the name of cell G7 is RevenueGrowth and that the name of cell G11 is NetIncomeGrowth. (Again, cell names are displayed in the Name box.)</P>
<H3>Automating the process of creating forms</H3>
<P CLASS="t">If you now select the MapSheet worksheet, you can see all of the states for which we need to create forms. And if you select an individual state, you can see the name of the state in the Name box. (The names of the state bitmaps, like the names of the ranges discussed in the previous section, have already been set up for you in the CHAP03-2.XLS workbook.) We can use the Name properties that are already set for the bitmaps on the MapSheet worksheet to create separate forms for each state. We would, however, like the separate state forms to appear in alphabetic order; as a result, we must sort the names of the bitmaps on the MapSheet worksheet before we use them to create the state forms. The Range object has a Sort method; if we can somehow transfer the names of the bitmaps to a worksheet range, we can sort them and then use them to create the state forms. The BuildStateList macro on the next page transfers all of the state bitmap names on the MapSheet worksheet to a range on the SummaryData worksheet and then sorts the names.</P>
<P><B>F Y I</B></P>
<P>Automated Macro Design vs. Manual Design</P>
<P>This chapter includes macros such as BuildStateList, below, which is used to set up your application, and macros such as GotoControl, on page 146, which is used in running your application. Often, you set up your application's environment manually, but the setup macros here serve to familiarize you with manipulating Excel objects through VBA—in addition to simply helping you get your sample application running.</P>
<P>To distinguish between the setup macros and the macros that run your application, each setup macro in this chapter is headed "Application Setup Macro." After you run the setup macros, you no longer need to include them in Module1 in order for the application to run.</P>
<H4>APPLICATION SETUP MACRO</H4>
<P CLASS="spacing"><BR></P>
<PRE><FONT FACE="Courier" SIZE="2"><B>Sub</B> BuildStateList()<BR>    <B>Dim</B> TopOfList <B>As</B> Range<BR>    <B>Dim</B> DrawVar <B>As</B> Drawing<BR>    <B>Dim</B> Counter <B>As Integer</B><BR>    Worksheets("SummaryData").Activate<BR>    Worksheets("SummaryData").Range("B11").Name = "TopOfList"<BR>    <B>Set</B> TopOfList = Worksheets("SummaryData").Range("TopOfList")<BR>    Counter = 11<BR>    <B>For</B> <B>Each</B> DrawVar <B>In</B> Worksheets("MapSheet").Drawings<BR>        Worksheets("SummaryData").Range("B" &amp; Counter).Value = _<BR>            DrawVar.Name<BR>        Counter = Counter + 1<BR>    <B>Next</B><BR>    TopOfList.CurrentRegion.Sort TopOfList<BR>    TopOfList.CurrentRegion.Name = "StateList"<BR><B>End Sub</B></FONT></PRE>
<P CLASS="t">In the fifth line of the BuildStateList macro, the SummaryData worksheet is made active by calling the Activate method. Then the Name property of Range("B11") on the SummaryData worksheet is set to "TopOfList"<I>,</I> and the Set statement in the seventh line sets the TopOfList Range object to Range("TopOfList")<I>.</I> The For-Each-Next loop is used in the Drawings collection on the MapSheet worksheet; the Drawings collection contains all of the drawings (that is, all of the state bitmaps) on the worksheet. The statements in the For-Each-Next loop set the Value properties of cells on the SummaryData worksheet equal to the names of the drawings on the MapSheet worksheet. The list of names starts at TopOfList and then grows down one cell at a time. The Sort method is then called on the range returned by the CurrentRegion property of TopOfList. CurrentRegion is a Range property that holds a Range reference for all contiguous cells that contain data. Last, when we use the CurrentRegion property, the range that contains the sorted list is given the name StateList<I>.</I> Run the BuildStateList macro now to generate the sorted list.</P>
<P><img src="G03RC07.gif"></P>
<P CLASS="t">Now we'll use the sorted list on the SummaryData worksheet to make worksheets that represent a state form for each state in the list. To add the 10 worksheets that represent the forms, we'll call the Copy method on the Worksheet object to copy the Template worksheet 10 times. We'll also set the Name property of each new worksheet to the appropriate state name and then place a ChartObject object on each worksheet. The MakeSheets macro below accomplishes these tasks:</P>
<H4>APPLICATION SETUP MACRO</H4>
<P CLASS="spacing"><BR></P>
<PRE><FONT FACE="Courier" SIZE="2"><B>Sub</B> MakeSheets()<BR>    <B>Dim</B> StateList <B>As</B> Range<BR>    <B>Dim</B> StateName <B>As</B> Range<BR>    <B>Set</B> StateList = Worksheets("SummaryData").Range("StateList")<BR>    <B>For</B> <B>Each</B> StateName <B>In</B> StateList<BR>        ActiveWorkbook.Worksheets("Template").Copy ActiveSheet<BR>        <B>With</B> ActiveSheet<BR>            .Name = StateName.Value<BR>            .Calculate<BR>            .Range("Rand1").Copy<BR>            .Range("Rand1").PasteSpecial xlValues<BR>            .Range("Rand2").Copy<BR>            .Range("Rand2").PasteSpecial xlValues<BR>            .ChartObjects.Add(190.5, 155.25, 233.25, 118.5).Select<BR>        <B>End With</B><BR>        ActiveChart.ChartWizard Range("E3:F3,H3," &amp; _<BR>                                      "E7:F7,H7," &amp; _<BR>                                      "E11:F11,H11")<BR>        Range("A1").Select<BR>    <B>Next</B><BR><B>End Sub</B></FONT></PRE>
<P CLASS="t">The MakeSheets macro uses a For-Each-Next loop to go through each of the cells in the StateList range, creating a new copy of the Template worksheet for each cell in the range and setting the Name property of each new worksheet to the value of each cell encountered. Notice that other things are going on in the body of the For-Each-Next loop as well. Recall that the Template worksheet contains formulas that use the RAND( ) worksheet function. By calling the Calculate method each time a new worksheet is copied, you force new random numbers to be generated, which makes it easy to create different fictitious data sets for each worksheet. After the worksheet is copied, however, you will want to convert the random formulas to actual values. You do so by calling the Range object's Copy method and then calling the PasteSpecial method, passing the constant xlValues as the first argument. This replaces all formulas in the range with the values such formulas represent (after the last recalculation). The MakeSheets macro converts the Rand1 and Rand2 ranges in this way.</P>
<P CLASS="t">Notice the call to the Add method of the ChartObjects collection. Recall that collections are actually objects that have properties and methods. In this instance, calling the Add method on the ChartObjects collection adds a new ChartObject object to the collection. Four arguments are passed to the Add method; these are values that are used to set the Left, Top, Width, and Height properties of the added ChartObject object.</P>
<P CLASS="t">In the same statement in which the Add method is called, the Select method is called as well, which ensures that the ChartObject object is selected after it has been added.</P>
<P CLASS="t">After you exit the With control structure, the ChartWizard method is called on the ActiveChart object. ActiveChart is used to reference the ChartObject object that was just added; ChartWizard is used, among other things, to link the ChartObject object to data in the worksheet. The first argument for ChartWizard takes a range address that represents the source of the linked data; in the call to ChartWizard, a series of noncontiguous ranges is specified to chart the values for Revenue and Net Income for 1993 and 1994. The last statement in the For-Each-Next loop selects the first range on the worksheet so that the ChartObject object does not remain selected.</P>
<P><B>F Y I</B></P>
<P>Using the Object Returned by the Add Method</P>
<P>How can you call the Add and Select methods in a single VBA statement? The Add method actually returns an object—specifically, the new object that the method created. If you want to be able to refer to the new object again easily, you can use this fact to set a variable to the new object, as in the following:</P>
<P><B>Dim</B> NewChart <B>As</B> ChartObject<BR><B>Set</B> NewChart = ActiveSheet.ChartObjects.Add(50, 20, 80, 20)</P>
<P>You can also use the returned object immediately, as in the following example, which sets a property and calls a method on two new objects:</P>
<P>ActiveSheet.ChartObjects.Add(50, 20, 80, 20).Name = "MyNewChart1"<BR>ActiveSheet.ChartObjects.Add(80, 30, 80, 20).SendToBack</P>
<P>In the MakeSheets macro (see page 143) we use this feature to select the new chart and then call the ChartWizard method on the ActiveChart, but we could have also called ChartWizard directly, at the cost of making the code more cluttered and less readable.</P>
<P>Note that when calling the Add method, if you do not use the result in an expression (by assigning it, setting a property on it, or calling a method on it), you must either explicitly use the Call keyword or omit the parentheses from the argument list, as in the following examples:</P>
<P><B>Call </B>ActiveSheet.ChartObjects.Add(50, 20, 80, 20)<BR>ActiveSheet.ChartObjects.Add 50, 20, 80, 20</P>
<P CLASS="t"></P>
<P>Tip</P>
<P>If you have not already done so, run the MakeSheets macro now. As each new worksheet is added and each new ChartObject object is created, you see a lot of flashing on the screen whenever something on the screen changes. You can prevent intermediate screen updates—and improve performance—by inserting the following statement at the top of the macro:</P>
<P>Application.ScreenUpdating = <B>False</B></P>
<P>This statement has been omitted from the macros in this chapter so that you can see the results of property settings and method calls as they occur.</P>
<P></P>
<H3>Adding Control buttons to the state forms</H3>
<P CLASS="t">Now that you have 10 worksheets to represent the 10 state forms, you must add some of the other objects to the forms. Start by adding a Control button to each form:</P>
<H4>APPLICATION SETUP MACRO</H4>
<P CLASS="spacing"><BR></P>
<PRE><FONT FACE="Courier" SIZE="2"><B>Sub</B> AddButtons()<BR>    <B>Dim</B> WorksheetVar <B>As</B> Worksheet<BR>    <B>For</B> <B>Each</B> WorksheetVar <B>In</B> ActiveWorkbook.Worksheets<BR>        <B>If</B> WorksheetVar.Name &lt;&gt; "Control" <B>Then</B><BR>            WorksheetVar.Activate<BR>            WorksheetVar.Buttons.Add(50, 20, 80, 20).Select<BR>            <B>With</B> Selection<BR>                .Caption = "Control"<BR>                .OnAction = "GotoControl"<BR>            <B>End With<BR></B>            Range("A1").Select<BR>        <B>End If<BR></B>    <B>Next</B><BR><B>End Sub</B></FONT></PRE>
<P CLASS="t">The AddButtons macro above uses a For-Each-Next loop to go through each worksheet in ActiveWorkbook, adding a Button object to each worksheet except the Control worksheet. (The If statement prevents the Control worksheet from being modified.) The macro adds the Button objects by calling the Add method on the worksheet's Buttons collection. Like the ChartObjects collection, the Buttons collection has an Add method that takes four arguments; these are values that are used to set the Left, Top, Width, and Height properties of the new Button object. In the body of the For-Each-Next loop after the Button object is added, the Caption property is set to Control and the OnAction property is set to GotoControl. An object's OnAction property holds the name of a macro that is executed whenever the object is clicked. In this case, if the user chooses any of the Control buttons, the GotoControl macro is executed. Here is the macro:</P>
<P CLASS="spacing"><BR></P>
<PRE><FONT FACE="Courier" SIZE="2"><B>Sub </B>GotoControl()<BR>    Worksheets("Control").Activate<BR>    Worksheets("Control").Range("A1").Select<BR><B>End Sub</B></FONT></PRE>
<P CLASS="t">This macro merely calls the Activate method on the Control Worksheet object. If you have not already done so, run the AddButtons macro now. After the macro completes, Control buttons are displayed on the 10 state forms and on the map and SummaryData forms.</P>
<P><img src="G03RC08.gif"></P>
<H3>Adding maps to the state forms</H3>
<P CLASS="t">Next you need to add the map bitmaps to each of the state forms. You can do this easily by copying the bitmaps one by one from the MapSheet worksheet to the appropriate state forms. The CopyMaps macro automates the process:</P>
<H4>APPLICATION SETUP MACRO</H4>
<P CLASS="spacing"><BR></P>
<PRE><FONT FACE="Courier" SIZE="2"><B>Sub</B> CopyMaps()<BR>    <B>Dim</B> DrawVar<B> As</B> Drawing<BR>    <B>For Each</B> DrawVar <B>In</B> Worksheets("MapSheet").Drawings<BR>        DrawVar.Copy<BR>        <B>With</B> Worksheets(DrawVar.Name)<BR>            .Activate<BR>            .Range("B7").Select<BR>            .Paste<BR>        <B>End With</B><BR>        <B>With</B> Selection<BR>            <B>If</B> .Width &lt;= 80 <B>Or</B> .Height &lt;= 110 <B>Then</B><BR>                <B>Do Until</B> .Width &gt;= 80 <B>Or</B> .Height &gt;= 110<BR>                    .Width = .Width * 1.1<BR>                    .Height = .Height * 1.1<BR>                <B>Loop</B><BR>            <B>Else</B><BR>                <B>Do Until</B> .Width &lt; 80 <B>Or</B> .Height &lt; 110<BR>                    .Width = .Width * 0.9<BR>                    .Height = .Height * 0.9<BR>                <B>Loop</B><BR>            <B>End If<BR></B>            .Top = 70<BR>            .Left = 50<BR>            .Interior.ColorIndex = 5<BR>            .Shadow = <B>True</B><BR>        <B>End With</B><BR>        Range("A1").Select<BR>    <B>Next</B><BR><B>End Sub</B></FONT></PRE>
<P CLASS="t">Copying the state map drawings from the MapSheet worksheet to each of the state forms presents one problem: Each state map is a different size, yet on each map form you probably want the state map to appear about the same size as the other state maps. So when copying each state map, it's important to adjust the relative size of the map as it is pasted to the state form.</P>
<P CLASS="t">The first few lines in the For-Each-Next loop of the CopyMaps macro copy a state map from the MapSheet worksheet to the appropriate state form. An If-Then-Else statement then determines whether the map is too small or too large in relative terms, with the target size of each drawing set at a width of 80 points and a height of 110 points. If the state map drawing is not the correct size, one of two Do-Loops enlarges or shrinks the map until it reaches the appropriate size. The Top and Left properties of the drawing are then set to adjust the position of the state map on the form, and the ColorIndex of the Interior object is set to 5 to make each map drawing blue. The Shadow property is then set to True to give each map a shadow. Last, Range("A1") is selected so that the maps do not remain selected.</P>
<P CLASS="t">Run the CopyMaps macro. A blue drawing is displayed on each state form to depict a map of the state.</P>
<H3>Adding a rectangle behind each state form map</H3>
<P CLASS="t">Use the following macro to add a dark gray rectangle behind each state bitmap to make it stand out:</P>
<H4>APPLICATION SETUP MACRO</H4>
<P CLASS="spacing"><BR></P>
<PRE><FONT FACE="Courier" SIZE="2"><B>Sub</B> AddRectangles()<BR>    <B>Dim</B> RangeVar <B>As</B> Range<BR>    <B>Dim</B> StateList <B>As</B> Range<BR>    <B>Set</B> StateList = Worksheets("SummaryData").Range("StateList")<BR>    <B>For</B> <B>Each</B> RangeVar <B>In</B> StateList<BR>        Worksheets(RangeVar.Value).Activate<BR>        ActiveSheet.Rectangles.Add(25, 50, 140, 200).Select<BR>        <B>With</B> Selection<BR>            .Interior.ColorIndex = 16<BR>            .Shadow = <B>True</B><BR>            .SendToBack<BR>        <B>End With</B><BR>        Range("A1").Select<BR>    <B>Next</B><BR><B>End Sub</B></FONT></PRE>
<P CLASS="t">In the AddRectangles macro above, a For-Each-Next loop is used on the range that the StateList object represents. The macro uses the state name in each cell in the range to activate each state form in turn. For each state form, the Add method is called on the Rectangles collection, and arguments for Left, Top, Width, and Height are passed. The ColorIndex property of the Interior object is then set to 16 to color the rectangle dark gray. Next, setting the Shadow property to True places a shadow around the rectangle. And last, the SendToBack method is called to set the ZOrder property of the rectangle to 1 so that it appears behind the graphical image of the state map.</P>
<H3>Adding a textbox to each state form</H3>
<P CLASS="t">The last object that must be added to each state form is a TextBox object, which displays the name of the state. Use the AddTextBoxes macro below to add the textboxes:</P>
<H4>APPLICATION SETUP MACRO</H4>
<P CLASS="spacing"><BR></P>
<PRE><FONT FACE="Courier" SIZE="2"><B>Sub</B> AddTextBoxes()<BR>    <B>Dim</B> RangeVar <B>As</B> Range<BR>    <B>Dim</B> StateList <B>As</B> Range<BR>    <B>Set</B> StateList = Worksheets("SummaryData").Range("StateList")<BR>    <B>For</B> <B>Each</B> RangeVar <B>In</B> StateList<BR>        Worksheets(RangeVar.Value).Activate<BR>        ActiveSheet.TextBoxes.Add(35, 205, 115, 35).Select<BR>        <B>With</B> Selection<BR>            <B>With</B> .Font<BR>                .Name = "Times New Roman"<BR>                .Size = 18<BR>                .Bold = <B>True</B><BR>            <B>End With</B><BR>            .Text = RangeVar.Value<BR>            .Shadow = <B>True</B><BR>            .HorizontalAlignment = xlCenter<BR>            .VerticalAlignment = xlCenter<BR>            .Border.Weight = xlMedium<BR>            .Interior.ColorIndex = 19<BR>        <B>End With</B><BR>        Range("A1").Select<BR>    <B>Next</B><BR><B>End Sub</B></FONT></PRE>
<P CLASS="t">Like the AddRectangles macro, the AddTextBoxes macro uses a For-Each-Next loop to call an Add method (this time on the TextBoxes collection) for each state form. After a textbox is added to each form, several properties of the textbox and of its font are set. The font properties that are set are Name, Size, and Bold. The following TextBox object properties are set:</P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="138pt" VALIGN="TOP"><COL WIDTH="304pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP">
	<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<P>Text</P></FONT></TD><TD VALIGN="TOP">
	<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<P>Value of the cell in StateList</P></FONT></TD></TR><TR><TD VALIGN="TOP">
	<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<P>Shadow</P></FONT></TD><TD VALIGN="TOP">
	<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<P>True</P></FONT></TD></TR><TR><TD VALIGN="TOP">
	<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<P>HorizontalAlignment</P></FONT></TD><TD VALIGN="TOP">
	<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<P>Set to xlCenter to center the text horizontally in the box</P></FONT></TD></TR><TR><TD VALIGN="TOP">
	<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<P>VerticalAlignment</P></FONT></TD><TD VALIGN="TOP">
	<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<P>Set to xlCenter</P></FONT></TD></TR><TR><TD VALIGN="TOP">
	<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<P>Border.Weight</P></FONT></TD><TD VALIGN="TOP">
	<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<P>Set to xlMedium to give the border a medium-weight line</P></FONT></TD></TR><TR><TD VALIGN="TOP">
	<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<P>Interior.ColorIndex</P></FONT></TD><TD VALIGN="TOP">
	<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<P>Set to 19 to give the textbox a light yellow color</P></FONT></TD></TR></TBODY></TABLE>
<P CLASS="spacing"><BR></P><P><img src="G03RC09.gif"></P>
<P><B>F Y I</B></P>
<P>Automated Macro Design vs. Manual Design</P>
<P>The macros covered so far in this chapter have for the most part been used to create and design forms. The actions that these macros perform could have easily been accomplished manually in Excel rather than by using macros. For example, instead of using the MakeSheets macro (see page 143), you could have just as easily made 10 copies of the Template worksheet, used Excel's ChartWizard (on the Standard toolbar) to make charts on each worksheet, and then added the button, rectangle, and textbox to each worksheet by using the tools on the Drawing toolbar. Although we could perform these design tasks manually, we will continue to use macros to design the rest of the forms in this application so that you can further familiarize yourself with the objects, properties, and methods involved.</P>
<H2><A NAME="sec14"></A>Working with the Control Form</H2><P CLASS="t">Now that all of the state forms have been designed, let's start designing the Control form by changing the background color, adding a listbox, and drawing a rectangle around the listbox. To be sure you have a feel for the pros and cons of automated vs. manual design, we list the manual steps involved in setting up this form; running the AddListBox macro on the next page, however, accomplishes the same result. In this case, only a single form is being set up, so in a real-life situation you would probably perform these steps manually, rather than spending the time to write a macro such as AddListBox.</P>
<P CLASS="t">First the background color of the Control form should be set to blue to make it appear as more of a form than a spreadsheet grid. You can do this manually by selecting the range A1:Z70, clicking the right mouse button, and then selecting Format Cells from the shortcut menu. In the Format Cells dialog box, click the Patterns tab, and then select the blue color under Cell Shading. Finish by choosing OK.</P>
<H3>Adding a listbox to the Control form</H3>
<P CLASS="t">Now you need to add a listbox to the form. If the Forms toolbar is not visible, choose the Toolbars command from the View menu, check the Forms check box, and choose OK. Click the ListBox tool on the Forms toolbar and draw the listbox on the lower left portion of the screen.</P>
<P><img src="G03RC10.gif"></P>
<P CLASS="t">To put a dark gray border around the listbox, add a rectangle behind it by first clicking the Filled Rectangle tool on the Drawing toolbar and then drawing a rectangle on top of the listbox. As with the Forms toolbar, you might need to first make the Drawing toolbar visible.</P>
<P><img src="G03RC11.gif"></P>
<P CLASS="t">Next point to the rectangle, click the right mouse button, and select Format Object from the shortcut menu. Click the Patterns tab, and select a medium weight line from the Weight drop-down list box, check the Shadow check box, and select gray for the Fill color.</P>
<P><img src="G03RC12.gif"></P>
<P CLASS="t">Now to place the rectangle behind the listbox, point to the rectangle, click the right mouse button, and select SendToBack from the shortcut menu.</P>
<P CLASS="t">You can also accomplish these same tasks—coloring the background cells blue and adding the listbox and the rectangle behind the background—by running the following macro:</P>
<H4>APPLICATION S'ETUP MACRO</H4>
<P CLASS="spacing"><BR></P>
<PRE><FONT FACE="Courier" SIZE="2"><B>Sub</B> AddListBox()<BR>    <B>With</B> Worksheets("Control")<BR>        .Select<BR>        .Range("A1:Z70").Interior.ColorIndex = 5<BR>        .ListBoxes.Add 100, 150, 100, 100<BR>        .Rectangles.Add 90, 140, 120, 120<BR>    <B>End With</B><BR>    <B>With</B> ActiveSheet.Rectangles(1)<BR>        .Interior.ColorIndex = 16<BR>        .Border.Weight = xlMedium<BR>        .Shadow = <B>True</B><BR>        .SendToBack<BR>    <B>End With</B><BR><B>End Sub</B></FONT></PRE>
<P CLASS="t">The AddListBox macro above first sets the ColorIndex property of the range's Interior object to blue, adds the listbox, adds the rectangle, and then formats the rectangle and calls the SendToBack method on the rectangle. After you add the listbox, you'll notice that no values are displayed in the list. You can choose from two ways to add a list of data so that it will be displayed in a listbox: You can link the listbox to a range on a worksheet, or you can add values to the listbox directly by using a macro. The second is the preferred way—adding values directly—because it results in better performance than does linking the listbox to a worksheet range.</P>
<P CLASS="t">The following macro assigns the appropriate values to the listbox by storing the values directly in the listbox. To do so, the macro assigns an array to the List property; the macro also assigns another macro to the OnAction property. The OnAction macro—GotoSheet—is executed whenever an item is selected from the listbox.</P>
<H4>APPLICATION SETUP MACRO</H4>
<P CLASS="spacing"><BR></P>
<PRE><FONT FACE="Courier" SIZE="2"><B>Sub</B> InitializeListBox()<BR>    <B>Dim</B> StateList <B>As</B> Range<BR>    <B>Dim</B> ListBox1 <B>As</B> ListBox<BR>    <B>Dim</B> ListArray() <B>As String</B><BR>    <B>Dim</B> ArraySize <B>As Integer</B><BR>    <B>Dim</B> Counter <B>As Integer</B><BR>    <B>Dim</B> RangeVar <B>As</B> Range<BR>    <B>Set</B> StateList = Worksheets("SummaryData").Range("StateList")<BR>    <B>Set</B> ListBox1 = Worksheets("Control").ListBoxes(1)<BR>    Counter = 1<BR>    ArraySize = StateList.Rows.Count<BR>    <B>ReDim</B> ListArray(ArraySize)<BR>    Worksheets("Control").Activate<BR>    <B>For Each</B> RangeVar <B>In</B> StateList<BR>        ListArray(Counter) = RangeVar.Value<BR>        Counter = Counter + 1<BR>    <B>Next</B><BR>    <B>With</B> ListBox1<BR>        .RemoveAllItems<BR>        .List = ListArray<BR>        .OnAction = "GotoSheet"<BR>    <B>End With</B><BR><B>End</B> <B>Sub</B></FONT></PRE>
<P CLASS="t">The InitializeListBox macro first builds a dynamic array that contains all the values in the StateList Range object. The size of the array is determined by calling the Rows method on StateList to return the rows encompassed by StateList and then calling the Count method to get the exact number of rows. A For-Each-Next loop then goes through all the values in StateList to assign values to ListArray. Next the RemoveAllItems method is called on ListBox1 to remove any items currently in the list, and ListArray is assigned to ListBox1's List property. Last, the GotoSheet macro name is assigned to the OnAction property.</P>
<P CLASS="t">GotoSheet and ColorMap, which is called by GotoSheet, appear below:</P>
<P CLASS="spacing"><BR></P>
<PRE><FONT FACE="Courier" SIZE="2"><B>Sub</B> GotoSheet()<BR>    <B>Dim</B> ListBox1 <B>As </B>ListBox<BR>    <B>Dim</B> SheetName <B>As String<BR></B>    <B>Set</B> ListBox1 = Worksheets("Control").ListBoxes(1)<BR>    SheetName = ListBox1.List(ListBox1.Value)<BR>    <B>With</B> Worksheets(SheetName)<BR>        ColorMap .Drawings(SheetName), "RevenueGrowth"<BR>        .Activate<BR>    <B>End With<BR></B>    Range("A1").Select<BR><B>End Sub</B><BR><BR><B>Sub</B> ColorMap(<B>ByRef</B> Map <B>As </B>Drawing, <B>ByVal</B> ValueName <B>As String</B>)<BR>        <B>Select</B> <B>Case</B> Worksheets(Map.Name).Range(ValueName).Value<BR>            <B>Case Is</B> &lt; -0.2<BR>                Map.Interior.ColorIndex = 3<BR>            <B>Case</B> -0.2 <B>To</B> 0.2<BR>                Map.Interior.ColorIndex = 4<BR>            <B>Case Is</B> &gt; 0.2<BR>                Map.Interior.ColorIndex = 5<BR>        <B>End Select</B><BR><B>End Sub</B></FONT></PRE>
<P CLASS="t">When the user selects a state from the listbox, the GotoSheet macro runs. GotoSheet retrieves the text of the item selected from the listbox in an interesting way: by indexing the list stored in the listbox. No single property of the ListBox object returns a text string that corresponds to the item selected. A ListBox object has a Value property that returns the index of the item selected and a List property that contains all of the items in the list. By using the Value property as an index on the List property, therefore, you can retrieve the text string that corresponds to the item selected. Doing so retrieves the name of the appropriate state form, which is used to call the Activate method on the worksheet that corresponds to the form.</P>
<P CLASS="t">Before the Activate method is called, a call is made to the ColorMap macro. ColorMap takes two arguments: a Drawing object passed by reference and a string passed by value. The Drawing object corresponds to the Drawing object that depicts the state map on the selected state form, and the string is "RevenueGrowth". You might recall that the cell in the state form table that contains the percentage change between 1993 and 1994 has the name RevenueGrowth. The ColorMap macro uses a Select Case statement to change the color of the map on the state form depending on the value in the cell named RevenueGrowth. If the value is less than –0.2, the map is colored red; if the value is between –0.2 and 0.2, the map is colored green; and if the value is greater than 0.2, the map is colored blue. This visual effect gives the user an immediate view of revenue growth for each state. A red map on a state form tells the user that revenue for 1994 was less than 80 percent of what it was for 1993. Likewise, a green map indicates a moderate revenue increase or decrease, and a blue map represents a high level of growth. After you run the InitializeListBox macro (see page 153), click several of the states in the listbox to see this effect.</P>
<H2><A NAME="sec15"></A>Working with the Map Form</H2><P CLASS="t">The next major component that you need to design is the map form. To create the map form, first select the MapSheet worksheet. This worksheet includes a Control button and 10 state maps. When completed, the form will have a dark gray background, two optionbuttons for changing the map color display to either revenue or net income growth, and a textbox that displays a legend for the map colors. You can make all of these changes by running the AddMapOptionButtons and AddMapLegend macros. However, you can also design the map form manually. The process of changing the background color of the map form manually is the same as it was for the Control form: You select the cells and then select a dark gray color in the Patterns tab of the Format Cells dialog box. To add optionbuttons to the form manually, use the Option Button tool on the Forms toolbar. Last, to manually add the textbox that displays the legend, use the Text Box tool on the Drawing toolbar.</P>
<P CLASS="t">Take a look now at the AddMapOptionButtons macro, which changes the background color and adds the optionbuttons for you:</P>
<H4>APPLICATION SETUP MACRO</H4>
<P CLASS="spacing"><BR></P>
<PRE><FONT FACE="Courier" SIZE="2"><B>Sub</B> AddMapOptionButtons()<BR>    <B>Dim</B> CaptionArray <B>As Variant</B><BR>    <B>Dim</B> NameArray <B>As Variant</B><BR>    <B>Dim</B> ButtonCounter <B>As Integer<BR></B>    <B>Dim</B> TopValue <B>As Integer</B><BR>    CaptionArray = Array("Revenue", "Net Income")<BR>    NameArray = Array("RevenueOpt", "NetIncomeOpt")<BR>    <B>With</B> Worksheets("MapSheet")<BR>        .Activate<BR>        .Range("A1:Z70").Interior.ColorIndex = 16<BR>        TopValue = 100<BR>        <B>For</B> ButtonCounter = 1 <B>To</B> 2<BR>            .OptionButtons.Add 20, TopValue, 80, 20<BR>            <B>With</B> .OptionButtons(ButtonCounter)<BR>                .Caption = CaptionArray(ButtonCounter)<BR>                .Name = NameArray(ButtonCounter)<BR>                .Border.Weight = xlMedium<BR>                .Interior.ColorIndex = 15<BR>                .OnAction = "ChangeMap"<BR>            <B>End With</B><BR>            TopValue = TopValue + 20<BR>        <B>Next</B><BR>    <B>End With<BR>End Sub</B></FONT></PRE>
<P CLASS="t">AddMapOptionButtons uses two arrays, CaptionArray and NameArray, to store the captions and names that will be assigned to the optionbuttons after they are added. After activating MapSheet, the macro sets the color of the background cells to dark gray. The macro then uses a For-Next loop to call the Add method on the OptionButtons collection twice to add two optionbuttons. Next the macro uses an index to CaptionArray and NameArray to assign values to the Caption and Name properties of the optionbuttons. Note that the Caption property refers to the text string that is displayed on the control, whereas the Name property is the name of the control as it appears in the formula bar's Name box when selected. Last the macro formats the weight of the border and the color of the interior and then assigns the ChangeMap macro name to the OnAction property. The ChangeMap macro follows:</P>
<P CLASS="spacing"><BR></P>
<PRE><FONT FACE="Courier" SIZE="2"><B>Sub</B> ChangeMap()<BR>    <B>Dim</B> DrawVar <B>As</B> Drawing<B><BR></B>    <B>Dim</B> DisplayValue <B>As String<BR></B>    <B>Select Case</B> Application.Caller<BR>        <B>Case</B> "RevenueOpt"<BR>            DisplayValue = "RevenueGrowth"<BR>        <B>Case</B> "NetIncomeOpt"<BR>            DisplayValue = "NetIncomeGrowth"<BR>    <B>End Select</B><BR>    <B>For Each</B> DrawVar <B>In</B> Worksheets("MapSheet").Drawings<BR>        ColorMap DrawVar, DisplayValue<BR>    <B>Next</B><BR><B>End Sub</B></FONT></PRE>
<P CLASS="t">ChangeMap uses a Select Case statement with the Caller property of the Application object as the test expression. The Caller property contains the name of the object or control responsible for launching a macro. For example, the optionbuttons to which ChangeMap is assigned are named RevenueOpt and NetIncomeOpt;<I> </I>therefore, when ChangeMap is run, Application.Caller evaluates to either "RevenueOpt" or "NetIncomeOpt". Depending on the evaluation of the test expression, the DisplayValue string is assigned either "RevenueGrowth" or "NetIncomeGrowth". Then a For-Each-Next loop calls the ColorMap macro (described earlier, in the section titled "Working with the Control Form," beginning on page 151) to color each of the map drawings on the map form. The color assigned to each drawing depends on the level of growth of the company's revenue or net income—as shown in the respective state forms.</P>
<P><B>F Y I</B></P>
<P>Assigning OnAction Macros Manually</P>
<P>After you run the AddMapOptionButtons macro, beginning on page 155, try choosing the two optionbuttons on the map form to see the colors of the maps change. Note that up to this point we have always used the OnAction property of an object to assign a macro to the object. You can also assign a macro to an object manually by pointing to the object, clicking the right mouse button, and selecting Assign Macro from the shortcut menu. After you do this, you can select a macro from the Assign Macro dialog box.</P>
<H3>Adding a legend to the map form</H3>
<P CLASS="t">The next step is to add a legend to the map form. You can add it manually or by using the macro shown below:</P>
<H4>APPLICATION SETUP MACRO</H4>
<P CLASS="spacing"><BR></P>
<PRE><FONT FACE="Courier" SIZE="2"><B>Sub</B> AddMapLegend()<BR>    <B>Dim</B> LegendString <B>As String</B><BR>    LegendString = "Red: &gt; 20% Decrease" &amp; Chr(10) &amp; _<BR>                   "Green: -20% to 20% Growth" &amp; Chr(10) &amp; _<BR>                   "Blue: &gt; 20% Growth"<BR>    <B>With</B> Worksheets("MapSheet")<BR>        .Select<BR>        .TextBoxes.Add 10, 180, 175, 50<BR>        <B>With</B> .TextBoxes(1)<BR>            .Text = LegendString<BR>            .Interior.ColorIndex = 19<BR>            .Border.Weight = xlMedium<BR>            .Shadow = <B>True</B><BR>            <B>With</B> .Font<BR>                .Size = 12<BR>                .Bold = <B>True</B><BR>            <B>End With</B><BR>        <B>End With<BR></B>    <B>End With</B><BR><B>End Sub</B></FONT></PRE>
<P CLASS="t">Note that in the AddMapLegend macro above, two line continuation characters (a space followed by an underscore [_]) are used in the portion that assigns a text string to the LegendString variable. Also notice that the Chr function inserts a carriage return character in the string. (Macintosh users should use Chr(13) to insert a linefeed in a TextBox object.)</P>
<P CLASS="t">All of the objects have now been added to the map form.</P>
<P><img src="G03RC13.gif"></P>
<H3>Assigning macros to the map drawings</H3>
<P CLASS="t">Now you need to assign a macro to each of the state map drawings in the map form so that a user can click a state map to activate the appropriate state form. The AssignMapMacros macro below assigns the GotoStateForm macro to each state map on the map form:</P>
<H4>APPLICATION SETUP MACRO</H4>
<P CLASS="spacing"><BR></P>
<PRE><FONT FACE="Courier" SIZE="2"><B>Sub</B> AssignMapMacros()<BR>    <B>Dim</B> DrawVar <B>As</B> Drawing<BR>    <B>With</B> Worksheets("MapSheet")<BR>        .Select<BR>        <B>For Each</B> DrawVar <B>In</B> .Drawings<BR>            DrawVar.OnAction = "GotoStateForm"<BR>        <B>Next</B><BR>    <B>End With</B><BR><B>End Sub</B></FONT></PRE>
<P CLASS="t">The GotoStateForm macro is shown at the top of the facing page. Notice how Application.Caller in GotoStateForm is used to determine the appropriate worksheet to activate after a state map is clicked. Also notice that the ColorMap macro (described earlier, in the section titled "Working with the Control Form," beginning on page 151) is called to update the color of the map on the state form so that the map displays the appropriate color for depicting revenue growth. In this application, we always call the ColorMap macro when going to a state form in case the data on which the color of the map is based ever changes. </P>
<P CLASS="spacing"><BR></P>
<PRE><FONT FACE="Courier" SIZE="2"><B>Sub </B>GotoStateForm()<BR>    <B>Dim</B> Map <B>As String<BR></B>    Map = Application.Caller<BR>    <B>With</B> Worksheets(Map)<BR>        ColorMap .Drawings(Map), "RevenueGrowth"<BR>        .Activate<BR>    <B>End With<BR></B>    Range("A1").Select<BR><B>End Sub</B></FONT></PRE>
<H3>Activating the map form from a state form</H3>
<P CLASS="t">Although it is already possible to activate a state form from the map form, it should also be possible to go from a state form back to the map form. The AssignStateMapMacros macro below assigns the GotoMap macro name to the map drawings on the state forms:</P>
<H4>APPLICATION SETUP MACRO</H4>
<P CLASS="spacing"><BR></P>
<PRE><FONT FACE="Courier" SIZE="2"><B>Sub</B> AssignStateMapMacros()<BR>    <B>Dim</B> StateList <B>As</B> Range<BR>    <B>Dim</B> RangeVar <B>As</B> Range<BR>    <B>Set</B> StateList = Worksheets("SummaryData").Range("StateList")<BR>    <B>For Each</B> RangeVar <B>In</B> StateList<BR>        Worksheets(RangeVar.Value).Drawings(1).OnAction = "GotoMap"<BR>    <B>Next</B><BR><B>End Sub</B></FONT></PRE>
<P CLASS="t">The GotoMap macro below updates all of the drawings on the map form in case any of the underlying data on the state forms has changed. To update the colors, however, it is necessary to check to see which optionbutton on the map form is currently selected; an If statement does so by checking the value of the RevenueOpt optionbutton. If the value is equal to the constant xlOn, the map colors are updated to depict revenue growth. If the value is not equal to this constant, the map colors are updated to depict net income growth.</P>
<P CLASS="spacing"><BR></P>
<PRE><FONT FACE="Courier" SIZE="2"><B>Sub</B> GotoMap()<BR>    <B>Dim</B> DrawVar <B>As</B> Drawing<BR>    <B>Dim</B> DisplayVal <B>As String</B><BR>    <B>Dim</B> RevenueOpt <B>As</B> OptionButton<BR>    <B>Set</B> RevenueOpt = _<BR>            Worksheets("MapSheet").OptionButtons("RevenueOpt")<BR>    <B>If</B> RevenueOpt.Value = xlOn <B>Then</B><BR>        DisplayVal = "RevenueGrowth"<BR>    <B>Else</B><BR>        DisplayVal = "NetIncomeGrowth"<BR>    <B>End If</B><BR>    <B>For Each</B> DrawVar <B>In</B> Worksheets("MapSheet").Drawings<BR>        ColorMap DrawVar, DisplayVal<BR>    <B>Next</B><BR>    Worksheets("MapSheet").Select<BR>    Range("A1").Select<BR><B>End Sub</B></FONT></PRE>
<H2><A NAME="sec16"></A>Adding Buttons to the Control Form</H2><P CLASS="t">As the application looks now, a user can go from the Control form to any state form and back again and from a state form to the map form and back again. We now need to link the forms so that the user can access either the map form or the SummaryData form by choosing a button on the Control form. The Control form should also include a button for quitting the application. So we need three more buttons on the Control form.</P>
<P><img src="CHART3.gif"></P>
<P CLASS="t">You can add these buttons manually by using the Button tool on the Forms toolbar or by running the AddControlButtons macro:</P>
<H4>APPLICATION SETUP MACRO</H4>
<P CLASS="spacing"><BR></P>
<PRE><FONT FACE="Courier" SIZE="2"><B>Sub</B> AddControlButtons()<BR>    <B>Dim</B> CaptionArray <B>As Variant</B><BR>    <B>Dim</B> MacroArray <B>As Variant</B><BR>    <B>Dim</B> ButtonCounter <B>As Integer</B><BR>    <B>Dim</B> TopValue <B>As Integer</B><BR>    CaptionArray = Array("Map Sheet", "Summary Data", "Quit")<BR>    MacroArray = Array("GotoMap", "GotoSummary", "QuitApp")<BR>    <B>With</B> Worksheets("Control")<BR>        .Activate<BR>        TopValue = 140<BR>        <B>For</B> ButtonCounter = 1 <B>To</B> 3<BR>            .Buttons.Add 260, TopValue, 80, 30<BR>            <B>With</B> .Buttons(ButtonCounter)<BR>                .Caption = CaptionArray(ButtonCounter)<BR>                .OnAction = MacroArray(ButtonCounter)<BR>            <B>End With</B><BR>        TopValue = TopValue + 40<BR>        <B>Next</B><BR>    <B>End With</B><BR><B>End Sub</B></FONT></PRE>
<P CLASS="t">The AddControlButtons macro uses two arrays—one to hold the caption for each button and one to hold the names of the macros to assign to each button. A For-Next loop is then used to add the buttons to the form and to assign the appropriate captions and macros. The macros that are launched by the SummaryData and Quit buttons are shown below:</P>
<P CLASS="spacing"><BR></P>
<PRE><FONT FACE="Courier" SIZE="2"><B>Sub</B> GotoSummary()<BR>    Worksheets("SummaryData").Select<BR>    Range("A1").Select<BR><B>End Sub</B><BR><BR><B>Sub</B> QuitApp()<BR>    ActiveWorkbook.Close<BR><B>End Sub</B></FONT></PRE>
<H2><A NAME="sec17"></A>Designing the SummaryData Form</H2><P CLASS="t">So far, you've done little to the SummaryData form, which currently holds only a list of state names. The completed SummaryData form, however, should contain a table that lists revenue and profit figures for each state, a chart that's linked to the table, and two optionbuttons that let the user toggle between revenue and net income data in the chart. The BuildTable macro shown below builds and formats the table. (You can also build and format this table manually.)</P>
<H4>APPLICATION SETUP MACRO</H4>
<P CLASS="spacing"><BR></P>
<PRE><FONT FACE="Courier" SIZE="2"><B>Sub</B> BuildTable()<BR>    <B>Dim</B> TopOfList <B>As</B> Range<BR>    <B>Dim </B>StateList <B>As</B> Range<BR>    <B>Dim </B>StateName <B>As</B> Range<BR>    <B>Dim </B>StCnt <B>As</B> <B>Integer</B><BR>    <B>Set </B>TopOfList = Worksheets("SummaryData").Range("TopOfList")<BR>    <B>Set </B>StateList = Worksheets("SummaryData").Range("StateList")<BR>    <B>With</B> Worksheets("SummaryData")<BR>    <B>    </B>.Activate<BR>    <B>    </B>.Range("A1:Z70").Interior.ColorIndex = 16<BR>    <B>End With<BR></B><BR>    'Add a formula in the cells--for example, =Arizona!Revenue<BR>    StCnt = 0<BR>    <B>For Each</B> StateName <B>In</B> StateList<BR>        StateName.Offset(0, 1).Formula = _<BR>                "=" &amp; StateName.Value &amp; "!Revenue"<BR>        StateName.Offset(0, 2).Formula = _<BR>                "=" &amp; StateName.Value &amp; "!Net_Income"<BR>        StCnt = StCnt + 1<BR>    <B>Next<BR></B><BR>    'Add headings, totals formulas, and cell formatting<BR>    <B>With</B> TopOfList<BR>        'Column headings:<BR>        .Offset(-1, 0).Value = "'1994"<BR>        .Offset(-1, 1).Value = "Revenue"<BR>        .Offset(-1, 2).Value = "Net Income"<BR><BR>        'Row heading and totals formulas on bottom row:<BR>        .Offset(StCnt, 0).Value = "Total"<BR>        .Offset(StCnt, 1).FormulaR1C1 = _<BR>                "=SUM(R[-" &amp; StCnt &amp; "]C:R[-1]C)"<BR>        .Offset(StCnt, 2).FormulaR1C1 = _<BR>                "=SUM(R[-" &amp; StCnt &amp; "]C:R[-1]C)"<BR><BR>        'Cell formatting:<BR>        .CurrentRegion.NumberFormat = "$#,##0_);($#,##0)"<BR>        .CurrentRegion.AutoFormat Format:=xlColor2<BR>        .CurrentRegion.BorderAround , xlMedium<BR>    <B>End With<BR></B>    Worksheets("SummaryData").Columns(1).ColumnWidth = 2<BR><B>End Sub</B></FONT></PRE>
<P CLASS="t">This macro takes advantage of several features of the Range object that have not yet been discussed; we'll look at those here. The first With statement activates the SummaryData worksheet and colors the background cells dark gray.</P>
<P CLASS="t">Next a For-Each-Next loop goes through StateList row by row, using the Range object's Offset method to refer to neighboring cells and assigning values to the Formula properties of those cells. Offset takes two arguments: a row number and a column number. The first call to Offset returns the cell that is one column to the right in the same row as the current cell in StateList. The Formula property is then set for this cell to a formula that evaluates to "=<I>StateName</I>!Revenue". This formula links the cell to the cell named Revenue on the appropriate state form. For example, in the California row of the table, this formula would be "=California!Revenue". Note that all Excel worksheet formulas that involve links to cells on other worksheets adhere to this syntax: a worksheet name followed by an exclamation point, and then either a cell address or a cell name. The next statement in the For-Each-Next loop performs a similar action: setting the Formula property of the cell in the next column equal to "=<I>StateName</I>!NetIncome". This formula links the cell to the NetIncome cell on the appropriate state form.</P>
<P CLASS="t">The block of code inside the With statement after the For-Each-Next loop adds headings and formats and fills in the bottom row with totals for the Revenue and Net Income columns. Labels are added using the Offset method and Value property of a Range object. The totals are created by setting the Formula properties of the respective cells to a SUM formula that calculates the sum of all numbers in the rows of that particular table column. The SUM formula takes a Range argument, specified here by a starting cell address and an ending cell address, with the two separated by a colon. The SUM formulas used in the BuildTable macro use relative addresses, in which row and column number offsets are specified. The exact syntax of the SUM formula is "=SUM(R[-" &amp; StCnt &amp; "]C:R[-1]C)", where StCnt represents the number of rows that contain data. The formula can be read as "sum the values starting at StCnt rows up in the same column and ending one row up in the same column." Note that because no column offset is specified, it is assumed to be zero.</P>
<P CLASS="t">After the macro enters the SUM formulas in the bottom row of the table, it formats the entire table. The NumberFormat property of the range that encompasses the table is set to a currency format, and the AutoFormat method is called on the range to apply a built-in format named xlColor2. Last the macro places a solid border of medium weight around the table and sets the ColumnWidth property of the worksheet's first column to 2 to reduce the width of the form's left margin, as shown here:</P>
<P><img src="G03RC15.gif"></P>
<H3>Adding a chart to the SummaryData form</H3>
<P CLASS="t">Next you need to add a chart to the SummaryData form. You would typically create a single on-sheet chart manually by using the ChartWizard tool on the Standard toolbar. The CreateChart macro shown below adds a chart for you automatically:</P>
<H4>APPLICATION SETUP MACRO</H4>
<P CLASS="spacing"><BR></P>
<PRE><FONT FACE="Courier" SIZE="2"><B>Sub</B> CreateChart()<BR>    <B>Dim </B>TableRange <B>As</B> Range<BR>    <B>Dim </B>RevenueRange <B>As</B> Range<BR>    <B>Dim </B>NetIncomeRange <B>As</B> Range<BR>    <B>Dim </B>R1 <B>As</B> Range<BR>    <B>Dim </B>R2 <B>As</B> Range<BR>    <B>Dim </B>FirstRow <B>As Integer</B><BR>    <B>Dim </B>FirstColumn <B>As Integer</B><BR>    <B>Dim </B>LastRow <B>As Integer</B><BR>    <B>Dim </B>LastColumn <B>As Integer</B><BR><BR>    Worksheets("SummaryData").Activate<BR>    <BR>    'TableRange is the entire table<BR>    <B>Set</B> TableRange = Worksheets("SummaryData").Range("TopOfList") _<BR>                     .CurrentRegion<BR>                     <BR>    'Make it easy to refer to the boundaries of the table<BR>    FirstRow = TableRange.Row<BR>    FirstColumn = TableRange.Column<BR>    LastRow = TableRange.Rows.Count + FirstRow - 1<BR>    LastColumn = TableRange.Columns.Count + FirstColumn - 1<BR>    <BR>    'Point to and name the revenue portion of the table<BR>    '(including row headings but not including totals)<BR>    <B>Set</B> RevenueRange = Worksheets("SummaryData").Range( _<BR>                            Cells(FirstRow, FirstColumn), _<BR>                            Cells(LastRow - 1, LastColumn - 1))<BR>    RevenueRange.Name = "RevenueRange"<BR>    <BR>    'R1 is the range that holds row headings (but not "Total"),<BR>    'R2 is the range that holds NetIncome values (but not total)<BR>    <B>Set</B> R1 = Range(Cells(FirstRow, FirstColumn), _<BR>                   Cells(LastRow - 1, LastColumn - 2))<BR>    <B>Set</B> R2 = Range(Cells(FirstRow, FirstColumn + 2), _<BR>                   Cells(LastRow - 1, LastColumn))<BR>                   <BR>    'Point to and name the net income portion of the table<BR>    '(including row headings but not including totals)<BR>    <B>Set</B> NetIncomeRange = Union(R1, R2)<BR>    NetIncomeRange.Name = "NetIncomeRange"<BR>    <BR>    'Add a chart that's linked to RevenueRange<BR>    RevenueRange.Select<BR>    ActiveSheet.ChartObjects.Add(198.75, 12, 240, 243).Select<BR>    ActiveChart.ChartWizard source:=RevenueRange, _<BR>                            gallery:=xl3DPie, _<BR>                            format:=1, _<BR>                            plotBy:=xlColumns, _<BR>                            categoryLabels:=1, _<BR>                            seriesLabels:=1<BR>                            <BR>    'Format the new chart<BR>    Worksheets("SummaryData").ChartObjects(1).Activate<BR>    <B>With</B> ActiveChart<BR>        .Elevation = 55<BR>        .Legend.Shadow = True<BR>        .Legend.Interior.ColorIndex = 15<BR>        .ChartTitle.Font.Size = 18<BR>        .ChartTitle.Font.Bold = True<BR>        .ChartTitle.Border.LineStyle = xlMedium<BR>        .ChartTitle.Shadow = True<BR>        .ChartTitle.Interior.ColorIndex = 15<BR><B>    End With</B><BR>    <BR>    'Deactivate the chart by hiding the ActiveWindow<BR>    ActiveWindow.Visible = False<BR>    <B>With</B> Worksheets("SummaryData").ChartObjects(1)<BR>        .Border.LineStyle = xlNone<BR>        .Interior.ColorIndex = 16<BR>    <B>End With</B><BR>    Worksheets("SummaryData").Range("A1").Select<BR><B>End Sub</B></FONT></PRE>
<P CLASS="t">The CreateChart macro above selects the appropriate data range in the table that is on the SummaryData form, calls the Add method of the ChartObjects collection to add an on-sheet chart, and then calls the ChartWizard method to link the chart to the appropriate range in the table. The CreateChart macro then activates the chart and formats various properties of the chart itself.</P>
<P CLASS="t">The first portion of the CreateChart macro is rather complicated because the first two columns of the table (excluding the last row, which contains totals) must be selected before the macro can call the Add method of the ChartObjects collection. We know that the cell at the top of the list of states is named TopOfList. The eighth line of the macro sets the TableRange variable equal to the range that corresponds to the CurrentRegion property of the TopOfList range; this is actually the entire table. (The line continuation character [_] is used in the statement to carry it over to the next line.) The next four statements set integer variables that reference the table's first and last rows and first and last columns.</P>
<P CLASS="t">The RevenueRange object variable is then set equal to the range in the table that corresponds to the table's first two columns, excluding the last row. The statement uses the Range object and the Cells method. Cells takes two arguments—a row number and a column number—and returns a single cell that represents the intersection of the row and column numbers on the worksheet. The Cells method can be called on the Application, Worksheet, or Range object. In this case, the call is made on the Application object. (Application is the default when no object is specified.) Because Cells is called on the Application object here, the appropriate worksheet must be active at the time, which is why the Activate method is called on the SummaryData Worksheet object at the beginning of the macro.</P>
<P CLASS="t">Note that when called from a worksheet, Range acts as a method that returns a Range object and can take as arguments either a single range address or two individual cell addresses. When Range takes two cell addresses as arguments, the range that is returned is the entire range that falls between those two cells. By using the Range and Cells methods in conjunction, you can set the RevenueRange object to the table's first two columns, excluding the last row. A name is then assigned to the range so that this complicated process need not be repeated the next time you want to select this range.</P>
<P CLASS="t">The next set of statements are more complicated yet. They involve selecting a range of data to be used to chart net income values. Such a chart requires selecting the first and last columns of the table, excluding the last row. The chart created in the CreateChart macro displays revenue values. However, a range for charting net income will also be set in this macro to be used by the ChangeChart macro (described in the next section). The ChangeChart macro is called by the optionbuttons that you still must add to the SummaryData form. ChangeChart allows the user to change which set of data is linked to the chart. To set NetIncomeRange, two range variables, R1 and R2, are used. Again, by using the Range and Cells methods, R1 is set to the table's first column, excluding the last row, and R2 is set to the table's last column, excluding the last row. Then the Union function combines R1 with R2 and assigns the union to the NetIncomeRange variable. The range is then given a name so that it can be accessed easily in the future.</P>
<P CLASS="t">After all this complicated manipulation of ranges, RevenueRange is selected, and the Add method is called on the ChartObjects collection to add a chart to the form. Next the macro calls the ChartWizard method on the new chart to link it to RevenueRange. Notice that several other arguments are passed to the ChartWizard method to specify values for various properties of the chart. After the chart is linked to the worksheet, the chart is activated so that additional properties of the chart can be set, including the elevation of the chart and various properties of the Legend and ChartTitle objects. The chart is then deactivated when the macro sets the Visible property of the ActiveWindow object to False. Last the line style of the border and the color of the interior of the chart are set. The line style is set to xlNone so that no border appears, and the color is set to dark gray to make the chart blend in with the background.</P>
<P><img src="G03RC16.gif"></P>
<H3>Adding optionbuttons to the SummaryData form</H3>
<P CLASS="t">You now need to add the two optionbuttons that allow the user to choose between displaying revenue information and displaying net income information on the chart. The AddChartOptionButtons macro below adds the two optionbuttons to the SummaryData form and sets the OnAction property of each optionbutton to the ChangeChart macro:</P>
<H4>APPLICATION SETUP MACRO</H4>
<P CLASS="spacing"><BR></P>
<PRE><FONT FACE="Courier" SIZE="2"><B>Sub</B> AddChartOptionButtons()<BR>    <B>Dim</B> CaptionArray <B>As Variant</B><BR>    <B>Dim</B> NameArray <B>As Variant</B><BR>    <B>Dim</B> ButtonCounter <B>As Integer</B><BR>    <B>Dim</B> TopValue <B>As Integer</B><BR>    CaptionArray = Array("Revenue", "Net Income")<BR>    NameArray = Array("RevenueChart", "NetIncomeChart")<BR>    <B>With</B> Worksheets("SummaryData")<BR>        .Select<BR>        TopValue = 60<BR>        <B>For</B> ButtonCounter = 1 <B>To</B> 2<BR>            .OptionButtons.Add 20, TopValue, 80, 20<BR>            <B>With</B> .OptionButtons(ButtonCounter)<BR>                .Caption = CaptionArray(ButtonCounter)<BR>                .Name = NameArray(ButtonCounter)<BR>                .Border.Weight = xlMedium<BR>                .Interior.ColorIndex = 15<BR>                .OnAction = "ChangeChart"<BR>            <B>End With</B><BR>            TopValue = TopValue + 20<BR>        <B>Next</B><BR>    <B>End With</B><BR><B>End Sub</B></FONT></PRE>
<P CLASS="t">The AddChartOptionButtons macro is nearly identical to the AddMapOptionButtons macro discussed earlier, in the section titled "Working with the Map Form," beginning on page 155. We will not, therefore, look at AddChartOptionButtons in detail. However, the ChangeChart macro, which allows the user to change data that has been charted, appears below. It is assigned to the optionbuttons on the SummaryData form.</P>
<P CLASS="spacing"><BR></P>
<PRE><FONT FACE="Courier" SIZE="2"><B>Sub </B>ChangeChart()<BR>    <B>Dim</B> RevenueRange <B>As</B> Range<BR>    <B>Dim</B> NetIncomeRange <B>As</B> Range<BR>    <B>Set</B> RevenueRange = Worksheets("SummaryData").Range("RevenueRange")<BR>    <B>Set</B> NetIncomeRange = Worksheets("SummaryData").Range("NetIncomeRange")<BR>    Worksheets("SummaryData").ChartObjects(1).Select<BR>    <B>Select Case</B> Application.Caller<BR>        <B>Case</B> "RevenueChart"<BR>            ActiveChart.ChartWizard source:=RevenueRange<BR>        <B>Case</B> "NetIncomeChart"<BR>            ActiveChart.ChartWizard source:=NetIncomeRange<BR>    <B>End Select</B><BR>    Worksheets("SummaryData").Range("A1").Select<BR><B>End Sub</B></FONT></PRE>
<P CLASS="t">The ChangeChart macro above employs a Select Case statement that uses Application.Caller as the test expression. If the RevenueChart optionbutton is selected, RevenueRange is passed as the source argument to the ChartWizard method, and revenue data is displayed on the chart. If the NetIncomeChart optionbutton is selected, however, NetIncomeRange is passed as the source argument to ChartWizard, and net income data is displayed on the chart.</P>
<H2><A NAME="sec18"></A>Completing the Control Form</H2><P CLASS="t">The application is now nearly complete. Still missing are two elements on the Control form: the title textbox and the airplane graphics.</P>
<H3>Adding the title textbox to the Control form</H3>
<P CLASS="t">You can use the AddAppTitleBox macro below to add the title textbox:</P>
<H4>APPLICATION SETUP MACRO</H4>
<P CLASS="spacing"><BR></P>
<PRE><FONT FACE="Courier" SIZE="2"><B>Sub </B>AddAppTitleBox()<BR>    <B>Dim</B> TitleString <B>As String</B><BR>    TitleString = "West Coast Airways"<BR>    Worksheets("Control").Select<BR>    ActiveSheet.TextBoxes.Add 90, 30, 250, 30<BR>    <B>With</B> ActiveSheet.TextBoxes(1)<BR>        .Text = TitleString<BR>        .Interior.ColorIndex = 15<BR>        .Border.Weight = xlMedium<BR>        .Shadow = <B>True</B><BR>        .Font.Size = 22<BR>        .Font.Bold = <B>True</B><BR>        .HorizontalAlignment = xlCenter<BR>        .VerticalAlignment = xlCenter<BR>    <B>End With</B><BR>    Range("A1").Select<BR><B>End Sub</B></FONT></PRE>
<P CLASS="t">AddAppTitleBox merely calls the Add method on the TextBoxes collection and sets various properties of the added textbox.</P>
<H3>Inserting the airplane graphics in the Control form</H3>
<P CLASS="t">Now you're ready to insert the Picture objects that represent the bitmaps of the airplanes flying across the screen. A file named PLANE.BMP on the companion disk packaged with this book contains a bitmap of an airplane. To insert the bitmap file in the Control form manually, choose the Picture command from the Insert menu, and then select the PLANE.BMP file.</P>
<P>Note</P>
<P>Excel's Picture command (found on the Insert menu in Windows) is not available on the Macintosh. The CHAP03-2.XLS file on the Macintosh disk (available from Microsoft Press through a fulfillment order) contains a bitmap picture of an airplane already. Macintosh users should use this bitmap rather than the PLANE.BMP file. The InsertPlanes macro on the Macintosh disk omits the code for inserting the PLANE.BMP file and uses the following line of code in place of the With Selection statement:</P>
<P><B>With</B> ActiveSheet.Pictures(1)</P>
<P>See the section titled "Using the Companion Disk," beginning on page xxvii, for instructions on ordering the Macintosh fulfillment disk.</P>
<P></P>
<P CLASS="t">Make three additional copies of the Picture object, and space them evenly across the form immediately below the application title box. The InsertPlanes macro below automates the process of inserting the bitmap, making the copies, and spacing the objects evenly. (This macro assumes that the PLANE.BMP file is saved in the same directory as is the workbook in which the macro is being run: ThisWorkbook.)</P>
<H4>APPLICATION SETUP MACRO</H4>
<P CLASS="spacing"><BR></P>
<PRE><FONT FACE="Courier" SIZE="2"><B>Sub</B> InsertPlanes()<BR>    <B>Dim</B> PlaneCounter <B>As Integer</B><BR>    <B>Dim</B> LeftValue <B>As Integer</B><BR>    <B>Dim</B> PathString <B>As String</B><BR>    <B>Dim</B> DirectoryVar <B>As String<BR></B>    DirectoryVar = Application.PathSeparator<BR>    PathString = ThisWorkbook.Path &amp; DirectoryVar &amp; "PLANE.BMP"<BR>    Worksheets("Control").Activate<BR>    ActiveSheet.Pictures.Insert(PathString).Select<BR>    <B>With</B> Selection<BR>        .Border.LineStyle = xlNone<BR>        .Copy<BR>    <B>End With</B><BR>    <B>For</B> PlaneCounter = 1 <B>To</B> 3<BR>        ActiveSheet.Paste<BR>    <B>Next</B><BR>    LeftValue = 50<BR>    <B>For</B> PlaneCounter = 1 <B>To</B> 4<BR>        <B>With</B> Worksheets("Control").Pictures(PlaneCounter)<BR>            .Left = LeftValue<BR>            .Top = 80<BR>            .OnAction = "FlyPlanes"<BR>            LeftValue = LeftValue + 110<BR>        <B>End With</B><BR>    <B>Next</B><BR>    Worksheets("Control").TextBoxes(1).OnAction = "FlyPlanes"<BR>    Range("A1").Select<BR><B>End Sub</B></FONT></PRE>
<P CLASS="t">In the InsertPlanes macro, the string DirectoryVar is set to Application.PathSeparator, which returns the correct operating system path separator regardless of whether the macro is run on a Macintosh or in Windows (either ":" or "\"). You then build the path for the PLANE.BMP file by appending the directory separator and the PLANE.BMP filename to the end of the string returned by ThisWorkbook.Path<I>. </I>This happens to be the path to which the current workbook file is saved. You then insert the PLANE.BMP bitmap by calling the Insert method on the Pictures collection, and continue by setting the LineStyle property of the Border object to xlNone to take away the border around the picture. The picture is then copied to the clipboard. Next a For-Next loop pastes the picture three times so that you now have four pictures on the Control form. A For-Each-Next loop then spaces the four pictures evenly in a horizontal line across the form below the application title box. It does so by setting the Left and Top properties of each picture appropriately. The OnAction property of each picture is set to the FlyPlanes macro, and at the end of the macro, the OnAction property of the application's title TextBox object is also set to FlyPlanes. The FlyPlanes macro appears below:</P>
<P CLASS="spacing"><BR></P>
<PRE><FONT FACE="Courier" SIZE="2"><B>Sub</B> FlyPlanes()<BR>    <B>Dim</B> DrawVar <B>As</B> Picture<BR>    <B>Dim</B> FlightCounter <B>As Integer</B><BR>    <B>Dim</B> Counter <B>As Integer</B><BR>    <B>For</B> Counter = 1 <B>To</B> 4<BR>        Worksheets("Control").Pictures.Group<BR>        <B>With</B> Worksheets("Control").GroupObjects(1)<BR>            <B>For</B> FlightCounter = 1 <B>To</B> 6<BR>                .Left = .Left + 10<BR>            <B>Next</B><BR>            .Ungroup<BR>        <B>End With</B><BR>        <B>For Each</B> DrawVar <B>In</B> Worksheets("Control").Pictures<BR>            <B>If</B> DrawVar.Left &gt; 355 <B>Then</B><BR>                DrawVar.Left = 0<BR>            <B>End If</B><BR>        <B>Next</B><BR>        Worksheets("Control").Pictures.Group<BR>        <B>With</B> Worksheets("Control").GroupObjects(1)<BR>            <B>For</B> FlightCounter = 1 <B>To</B> 5<BR>                .Left = .Left + 10<BR>            <B>Next</B><BR>            .Ungroup<BR>        <B>End With</B><BR>    <B>Next</B><BR>    Range("A1").Select<BR><B>End Sub</B></FONT></PRE>
<P CLASS="t">FlyPlanes first calls the Group method on the Control form's Pictures collection. Doing so groups all the airplane bitmap pictures together so that they can be treated as a single object—that is, as a GroupObject object. This single object is then referenced as GroupObjects(1), and a For-Next loop moves the group 60 points horizontally across the screen in an animated fashion by incrementing the Left property of the group. The Ungroup method is then called on the group to again break it into four separate Picture objects. The macro then moves the Picture object that is on the far right back to the far left by setting the Left property to 0. The objects are grouped again and then moved 50 more points across the screen to the right. Last the Ungroup method is called on the group so that FlyPlanes will work the next time it is called.</P>
<P CLASS="t">The Control form is now complete.</P>
<P><img src="G03RC17.gif"></P>
<H2><A NAME="sec19"></A>Setting Environment Properties</H2><P CLASS="t">Although you are nearly finished creating the West Coast Airways application, one last task remains. You have probably noticed that many of the Excel artifacts that remind users that they are using a spreadsheet software program still appear in the application. Such artifacts include row and column headings, gridlines on many of the forms, scrollbars, worksheet tabs, and the formula bar at the top and the status bar at the bottom of the work area. Properties of the Window object control some of these artifacts. Properties of the Application object control others. For example, settings for gridlines, row and column headings, tabs, and scrollbars are made through Window properties; settings for the formula bar and status bar display are made through Application properties. You can save Window property settings with a workbook file, but you cannot do so with Application property settings. In addition, some of these Window properties are specific to the Worksheet object, and others are specific to the Workbook object. For example, settings for gridlines and row and column headings are Worksheet specific; settings for scrollbars and tabs are Workbook specific. So to turn off the display of gridlines and row and column headings on all of the forms in the application, you must activate each worksheet and set the appropriate display property for gridlines and row and column headings. You can do this manually by going to each worksheet, choosing the<B> </B>Options command from the Tools menu, and making the appropriate selections from the View tab. The necessary Workbook-specific and Application-specific property settings can be made in the same Options dialog box, but they need be made only one time. However, the SetUpEnvironment macro below will perform all these tasks for you:</P>
<H4>APPLICATION SETUP MACRO</H4>
<P CLASS="spacing"><BR></P>
<PRE><FONT FACE="Courier" SIZE="2"><B>Sub</B> SetUpEnvironment()<BR>    <B>Dim</B> WorksheetVar <B>As</B> Worksheet<BR>    <B>For</B> Each WorksheetVar <B>In</B> ActiveWorkbook.Worksheets<BR>        WorksheetVar.Select<BR>        <B>With</B> ActiveWindow<BR>            .DisplayGridlines = <B>False</B><BR>            .DisplayHeadings = <B>False</B><BR>        <B>End With</B><BR>    <B>Next</B><BR>    <B>With</B> ActiveWindow<BR>        .DisplayHorizontalScrollBar = <B>False</B><BR>        .DisplayVerticalScrollBar = <B>False</B><BR>        .DisplayWorkbookTabs = <B>False</B><BR>    <B>End With</B><BR>    Application.DisplayFormulaBar = <B>False</B><BR>    Application.DisplayStatusBar = <B>False</B><BR>    Worksheets("Control").Activate<BR><B>End Sub</B></FONT></PRE>
<P CLASS="t">SetUpEnvironment uses a For-Each-Next loop to set all of the Worksheet-specific Window properties and then uses a With statement on the ActiveWindow to set all of the Workbook-specific Window properties. Last the macro sets the necessary Application-specific properties.</P>
<P CLASS="t">Run the SetUpEnvironment macro. If you save the file, all but the Application-specific property settings are saved with the file and are then restored when the file is opened again. To restore the Application property settings, write an Auto_Open macro that sets the property settings whenever the workbook file is opened.</P>
<P CLASS="t">The Auto_Open macro below sets the Application-specific properties of DisplayStatusBar and DisplayFormulaBar:</P>
<P CLASS="spacing"><BR></P>
<PRE><FONT FACE="Courier" SIZE="2"><B>Sub</B> Auto_Open()<BR>    Application.DisplayStatusBar = <B>False</B><BR>    Application.DisplayFormulaBar = <B>False</B><BR><B>End Sub</B></FONT></PRE>
<P CLASS="t">Auto_Open is called automatically when the file is opened. Note that VBA also provides an Auto_Close macro that runs every time a workbook file is closed. After you add the Auto_Open macro, return to the Control form and save the file.</P>
<H2><A NAME="sec20"></A>Finding Module1 in the Completed Application</H2><P CLASS="t">If you would like to review the code in Module1, you can redisplay the worksheet tabs through the Options dialog box, or you can press the Ctrl-PgUp or Ctrl-PgDown keys until Module1 becomes the active sheet. Such key combinations let you move from one sheet to another without using tabs.</P>
<H1><A NAME="sec21"></A>Looking Ahead</H1><P CLASS="t">Congratulations! You have successfully built the West Coast Airways application. As mentioned, this application suffers from a few flaws that would limit its implementation as a full-fledged information system. If you have mastered the concepts covered in this chapter, however, you are well on your way to building powerful information systems in Excel.</P>
<P CLASS="t">The rest of the chapters in this book cover more advanced topics associated with more complicated Excel objects, including database access, data flow, control of user input, and e-mail integration. Mastering these advanced topics and the more complicated objects in Excel will allow you to transform applications such as West Coast Airways into full-fledged information systems. The discussion of such advanced topics begins with the next chapter, "Building Information Systems with Pivottables and Charts."</P>
<H1><A NAME="sec22"></A>S U M M A R Y</H1><P CLASS="t">This chapter introduced most of Excel's graphical objects and showed you how to manipulate them through VBA to create a simple application. The following list summarizes this chapter's key points:</P>
<UL><LI>Graphical objects share many methods and properties, with which you can manipulate collections of objects using a single For-Each-Next loop.</LI><LI>You can set up the environment for your application manually or by using macros. How efficient either method is depends on how many times you repeat the same series of setup steps.</LI><LI>You can call the ChartWizard method in a macro to create or change a chart, or you can use Excel's ChartWizard tool to create or change a chart manually. A chart can be set up so that it changes automatically whenever the data to which it is linked changes.</LI><LI>You tell an object on a sheet to respond to mouse clicks by setting the object's OnAction property to a macro name. A macro can use the Application.Caller property to determine which object was clicked.</LI><LI>The Range object's Offset method can be used to manipulate cells; the Cells and Union methods can be used to create ranges.</LI><LI>Some aspects of the Excel environment can be saved with a workbook. Others must be reset each time a workbook is opened; to reset these aspects, you use the Auto_Open macro.</LI></UL><P CLASS="t"></P></FONT>
</FONT></BODY></HTML>
